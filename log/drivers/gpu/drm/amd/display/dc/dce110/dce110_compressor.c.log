commit 4fc4dca8320e46b067037496fde3a6d95381d60f
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:50 2019 +0200

    drm/amd: drop use of drmp.h in os_types.h
    
    Drop use of the deprecated drmP.h from display/dc/os_types.h
    
    Fix all fallout after this change.
    Most of the fixes was adding a missing include of vmalloc.h.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-4-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index 12083bb8ef02..72b580a4eb85 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -24,6 +24,7 @@
  */
 
 #include <linux/delay.h>
+#include <linux/slab.h>
 
 #include "dm_services.h"
 

commit c366be543c5ea35f4d4103f5ee69f052ce2bffe1
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:49 2019 +0200

    drm/amd: drop dependencies on drm_os_linux.h
    
    Fix so no files in drm/amd/ depends on the
    deprecated drm_os_linux.h header file.
    
    It was done manually:
    - remove drm_os_linux.h from drmP.h
    - fix all build errros
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-3-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index 7b23239d33fe..12083bb8ef02 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -23,6 +23,8 @@
  *
  */
 
+#include <linux/delay.h>
+
 #include "dm_services.h"
 
 #include "dce/dce_11_0_d.h"

commit eb87161a9cb02a058e7535a729af4ed098da89f0
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Dec 18 13:05:54 2018 +0000

    amdgpu/dc: remove various variables that are defined but never used
    
    There are several variables that are defined and never used and hence can
    be removed. Remove them. Cleans up clang -Wunused-const-variable warnings:
    
    warning: ‘dvi_hdmi_dongle_signature_str’ defined but not used
    warning: ‘dce11_one_lpt_channel_max_resolution’ defined but not used
    warning: ‘ddc_hw_status_addr’ defined but not used
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index 52d50e24a995..7b23239d33fe 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -62,8 +62,6 @@ static const struct dce110_compressor_reg_offsets reg_offsets[] = {
 }
 };
 
-static const uint32_t dce11_one_lpt_channel_max_resolution = 2560 * 1600;
-
 static uint32_t align_to_chunks_number_per_line(uint32_t pixels)
 {
 	return 256 * ((pixels + 255) / 256);

commit 65d38262b3e82fc795464e48ee88cb66fd4c85aa
Author: hersen wu <hersenxs.wu@amd.com>
Date:   Tue Oct 30 16:39:15 2018 -0400

    drm/amd/display: fbc state could not reach while enable fbc
    
       [WHY] fbc is within the data path from memory to dce. while
       re-configure mc dmif, fbc should be enabled. otherwise, fbc
       may not be enabled properly.
    
       [HOW] before re-configure mc dmif, disable fbc, only after
       dmif re-configuration fully done, enable fbc again.
    
    Signed-off-by: hersen wu <hersenxs.wu@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index 1f7f25013217..52d50e24a995 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -64,65 +64,37 @@ static const struct dce110_compressor_reg_offsets reg_offsets[] = {
 
 static const uint32_t dce11_one_lpt_channel_max_resolution = 2560 * 1600;
 
-enum fbc_idle_force {
-	/* Bit 0 - Display registers updated */
-	FBC_IDLE_FORCE_DISPLAY_REGISTER_UPDATE = 0x00000001,
-
-	/* Bit 2 - FBC_GRPH_COMP_EN register updated */
-	FBC_IDLE_FORCE_GRPH_COMP_EN = 0x00000002,
-	/* Bit 3 - FBC_SRC_SEL register updated */
-	FBC_IDLE_FORCE_SRC_SEL_CHANGE = 0x00000004,
-	/* Bit 4 - FBC_MIN_COMPRESSION register updated */
-	FBC_IDLE_FORCE_MIN_COMPRESSION_CHANGE = 0x00000008,
-	/* Bit 5 - FBC_ALPHA_COMP_EN register updated */
-	FBC_IDLE_FORCE_ALPHA_COMP_EN = 0x00000010,
-	/* Bit 6 - FBC_ZERO_ALPHA_CHUNK_SKIP_EN register updated */
-	FBC_IDLE_FORCE_ZERO_ALPHA_CHUNK_SKIP_EN = 0x00000020,
-	/* Bit 7 - FBC_FORCE_COPY_TO_COMP_BUF register updated */
-	FBC_IDLE_FORCE_FORCE_COPY_TO_COMP_BUF = 0x00000040,
-
-	/* Bit 24 - Memory write to region 0 defined by MC registers. */
-	FBC_IDLE_FORCE_MEMORY_WRITE_TO_REGION0 = 0x01000000,
-	/* Bit 25 - Memory write to region 1 defined by MC registers */
-	FBC_IDLE_FORCE_MEMORY_WRITE_TO_REGION1 = 0x02000000,
-	/* Bit 26 - Memory write to region 2 defined by MC registers */
-	FBC_IDLE_FORCE_MEMORY_WRITE_TO_REGION2 = 0x04000000,
-	/* Bit 27 - Memory write to region 3 defined by MC registers. */
-	FBC_IDLE_FORCE_MEMORY_WRITE_TO_REGION3 = 0x08000000,
-
-	/* Bit 28 - Memory write from any client other than MCIF */
-	FBC_IDLE_FORCE_MEMORY_WRITE_OTHER_THAN_MCIF = 0x10000000,
-	/* Bit 29 - CG statics screen signal is inactive */
-	FBC_IDLE_FORCE_CG_STATIC_SCREEN_IS_INACTIVE = 0x20000000,
-};
-
-
 static uint32_t align_to_chunks_number_per_line(uint32_t pixels)
 {
 	return 256 * ((pixels + 255) / 256);
 }
 
-static void reset_lb_on_vblank(struct dc_context *ctx)
+static void reset_lb_on_vblank(struct compressor *compressor, uint32_t crtc_inst)
 {
-	uint32_t value, frame_count;
+	uint32_t value;
+	uint32_t frame_count;
+	uint32_t status_pos;
 	uint32_t retry = 0;
-	uint32_t status_pos =
-			dm_read_reg(ctx, mmCRTC_STATUS_POSITION);
+	struct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);
+
+	cp110->offsets = reg_offsets[crtc_inst];
+
+	status_pos = dm_read_reg(compressor->ctx, DCP_REG(mmCRTC_STATUS_POSITION));
 
 
 	/* Only if CRTC is enabled and counter is moving we wait for one frame. */
-	if (status_pos != dm_read_reg(ctx, mmCRTC_STATUS_POSITION)) {
+	if (status_pos != dm_read_reg(compressor->ctx, DCP_REG(mmCRTC_STATUS_POSITION))) {
 		/* Resetting LB on VBlank */
-		value = dm_read_reg(ctx, mmLB_SYNC_RESET_SEL);
+		value = dm_read_reg(compressor->ctx, DCP_REG(mmLB_SYNC_RESET_SEL));
 		set_reg_field_value(value, 3, LB_SYNC_RESET_SEL, LB_SYNC_RESET_SEL);
 		set_reg_field_value(value, 1, LB_SYNC_RESET_SEL, LB_SYNC_RESET_SEL2);
-		dm_write_reg(ctx, mmLB_SYNC_RESET_SEL, value);
+		dm_write_reg(compressor->ctx, DCP_REG(mmLB_SYNC_RESET_SEL), value);
 
-		frame_count = dm_read_reg(ctx, mmCRTC_STATUS_FRAME_COUNT);
+		frame_count = dm_read_reg(compressor->ctx, DCP_REG(mmCRTC_STATUS_FRAME_COUNT));
 
 
 		for (retry = 10000; retry > 0; retry--) {
-			if (frame_count != dm_read_reg(ctx, mmCRTC_STATUS_FRAME_COUNT))
+			if (frame_count != dm_read_reg(compressor->ctx, DCP_REG(mmCRTC_STATUS_FRAME_COUNT)))
 				break;
 			udelay(10);
 		}
@@ -130,13 +102,11 @@ static void reset_lb_on_vblank(struct dc_context *ctx)
 			dm_error("Frame count did not increase for 100ms.\n");
 
 		/* Resetting LB on VBlank */
-		value = dm_read_reg(ctx, mmLB_SYNC_RESET_SEL);
+		value = dm_read_reg(compressor->ctx, DCP_REG(mmLB_SYNC_RESET_SEL));
 		set_reg_field_value(value, 2, LB_SYNC_RESET_SEL, LB_SYNC_RESET_SEL);
 		set_reg_field_value(value, 0, LB_SYNC_RESET_SEL, LB_SYNC_RESET_SEL2);
-		dm_write_reg(ctx, mmLB_SYNC_RESET_SEL, value);
-
+		dm_write_reg(compressor->ctx, DCP_REG(mmLB_SYNC_RESET_SEL), value);
 	}
-
 }
 
 static void wait_for_fbc_state_changed(
@@ -226,10 +196,10 @@ void dce110_compressor_enable_fbc(
 		uint32_t addr;
 		uint32_t value, misc_value;
 
-
 		addr = mmFBC_CNTL;
 		value = dm_read_reg(compressor->ctx, addr);
 		set_reg_field_value(value, 1, FBC_CNTL, FBC_GRPH_COMP_EN);
+		/* params->inst is valid HW CRTC instance start from 0 */
 		set_reg_field_value(
 			value,
 			params->inst,
@@ -238,8 +208,10 @@ void dce110_compressor_enable_fbc(
 
 		/* Keep track of enum controller_id FBC is attached to */
 		compressor->is_enabled = true;
-		compressor->attached_inst = params->inst;
-		cp110->offsets = reg_offsets[params->inst];
+		/* attached_inst is SW CRTC instance start from 1
+		 * 0 = CONTROLLER_ID_UNDEFINED means not attached crtc
+		 */
+		compressor->attached_inst = params->inst + CONTROLLER_ID_D0;
 
 		/* Toggle it as there is bug in HW */
 		set_reg_field_value(value, 0, FBC_CNTL, FBC_GRPH_COMP_EN);
@@ -268,9 +240,10 @@ void dce110_compressor_enable_fbc(
 void dce110_compressor_disable_fbc(struct compressor *compressor)
 {
 	struct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);
+	uint32_t crtc_inst = 0;
 
 	if (compressor->options.bits.FBC_SUPPORT) {
-		if (dce110_compressor_is_fbc_enabled_in_hw(compressor, NULL)) {
+		if (dce110_compressor_is_fbc_enabled_in_hw(compressor, &crtc_inst)) {
 			uint32_t reg_data;
 			/* Turn off compression */
 			reg_data = dm_read_reg(compressor->ctx, mmFBC_CNTL);
@@ -284,8 +257,10 @@ void dce110_compressor_disable_fbc(struct compressor *compressor)
 			wait_for_fbc_state_changed(cp110, false);
 		}
 
-		/* Sync line buffer  - dce100/110 only*/
-		reset_lb_on_vblank(compressor->ctx);
+		/* Sync line buffer which fbc was attached to dce100/110 only */
+		if (crtc_inst > CONTROLLER_ID_UNDEFINED && crtc_inst < CONTROLLER_ID_D3)
+			reset_lb_on_vblank(compressor,
+					crtc_inst - CONTROLLER_ID_D0);
 	}
 }
 
@@ -328,6 +303,8 @@ void dce110_compressor_program_compressed_surface_address_and_pitch(
 	uint32_t compressed_surf_address_low_part =
 		compressor->compr_surface_address.addr.low_part;
 
+	cp110->offsets = reg_offsets[params->inst];
+
 	/* Clear content first. */
 	dm_write_reg(
 		compressor->ctx,
@@ -410,13 +387,7 @@ void dce110_compressor_set_fbc_invalidation_triggers(
 	value = dm_read_reg(compressor->ctx, addr);
 	set_reg_field_value(
 		value,
-		fbc_trigger |
-		FBC_IDLE_FORCE_GRPH_COMP_EN |
-		FBC_IDLE_FORCE_SRC_SEL_CHANGE |
-		FBC_IDLE_FORCE_MIN_COMPRESSION_CHANGE |
-		FBC_IDLE_FORCE_ALPHA_COMP_EN |
-		FBC_IDLE_FORCE_ZERO_ALPHA_CHUNK_SKIP_EN |
-		FBC_IDLE_FORCE_FORCE_COPY_TO_COMP_BUF,
+		fbc_trigger,
 		FBC_IDLE_FORCE_CLEAR_MASK,
 		FBC_IDLE_FORCE_CLEAR_MASK);
 	dm_write_reg(compressor->ctx, addr, value);
@@ -549,7 +520,7 @@ void dce110_compressor_construct(struct dce110_compressor *compressor,
 	compressor->base.channel_interleave_size = 0;
 	compressor->base.dram_channels_num = 0;
 	compressor->base.lpt_channels_num = 0;
-	compressor->base.attached_inst = 0;
+	compressor->base.attached_inst = CONTROLLER_ID_UNDEFINED;
 	compressor->base.is_enabled = false;
 	compressor->base.funcs = &dce110_compressor_funcs;
 

commit 6f66ccf0aa8f6d430d161a1ac2bc43e665d2fc59
Author: Roman Li <Roman.Li@amd.com>
Date:   Tue Jun 5 14:24:53 2018 -0400

    drm/amd/display: fix potential infinite loop in fbc path
    
    - Fixing integer overflow bug in wait_for_fbc_state_changed()
    - Correct the max value of retries for the corresponding warning
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index df027013e50c..1f7f25013217 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -143,7 +143,7 @@ static void wait_for_fbc_state_changed(
 	struct dce110_compressor *cp110,
 	bool enabled)
 {
-	uint16_t counter = 0;
+	uint32_t counter = 0;
 	uint32_t addr = mmFBC_STATUS;
 	uint32_t value;
 
@@ -158,7 +158,7 @@ static void wait_for_fbc_state_changed(
 		counter++;
 	}
 
-	if (counter == 10) {
+	if (counter == 1000) {
 		DC_LOG_WARNING("%s: wait counter exceeded, changes to HW not applied",
 			__func__);
 	} else {

commit 5099114ba3b2e5ae9fb487aeb3ae0434fe38a7da
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu May 31 09:09:59 2018 -0500

    drm/amdgpu/display: drop DRM_AMD_DC_FBC kconfig option
    
    Just enable it always.  This was leftover from feature
    bring up.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index 111c4921987f..df027013e50c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -551,9 +551,7 @@ void dce110_compressor_construct(struct dce110_compressor *compressor,
 	compressor->base.lpt_channels_num = 0;
 	compressor->base.attached_inst = 0;
 	compressor->base.is_enabled = false;
-#if defined(CONFIG_DRM_AMD_DC_FBC)
 	compressor->base.funcs = &dce110_compressor_funcs;
 
-#endif
 }
 

commit fe78627d430435d22316fe39f2012ece31bf23c2
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Fri Jun 15 08:32:28 2018 -0500

    drm/amd/display: fix type of variable
    
    Currently, the maximum value that *counter* can reach is 255, and
    code at line 150: while (counter < 1000) { implies a bigger value
    could be expected.
    
    Fix this by changing the type of variable *counter* from uint8_t
    to uint16_t.
    
    Addresses-Coverity-ID: 1470030 ("Operands don't affect result")
    Fixes: 2b6199a1d1b7 ("drm/amd/display: replace msleep with udelay in fbc path")
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index e2994d337044..111c4921987f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -143,7 +143,7 @@ static void wait_for_fbc_state_changed(
 	struct dce110_compressor *cp110,
 	bool enabled)
 {
-	uint8_t counter = 0;
+	uint16_t counter = 0;
 	uint32_t addr = mmFBC_STATUS;
 	uint32_t value;
 

commit 2b6199a1d1b70fccd62aed961ba4c2b979ae499c
Author: Roman Li <Roman.Li@amd.com>
Date:   Thu May 3 13:29:42 2018 -0400

    drm/amd/display: replace msleep with udelay in fbc path
    
    FBC enabling and disabling path has msleep which leads to
    BUG hit when called in atomic context, hence this patch
    replaces msleeps with udelays appropriately.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index 9150d2694450..e2994d337044 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -121,10 +121,10 @@ static void reset_lb_on_vblank(struct dc_context *ctx)
 		frame_count = dm_read_reg(ctx, mmCRTC_STATUS_FRAME_COUNT);
 
 
-		for (retry = 100; retry > 0; retry--) {
+		for (retry = 10000; retry > 0; retry--) {
 			if (frame_count != dm_read_reg(ctx, mmCRTC_STATUS_FRAME_COUNT))
 				break;
-			msleep(1);
+			udelay(10);
 		}
 		if (!retry)
 			dm_error("Frame count did not increase for 100ms.\n");
@@ -147,14 +147,14 @@ static void wait_for_fbc_state_changed(
 	uint32_t addr = mmFBC_STATUS;
 	uint32_t value;
 
-	while (counter < 10) {
+	while (counter < 1000) {
 		value = dm_read_reg(cp110->base.ctx, addr);
 		if (get_reg_field_value(
 			value,
 			FBC_STATUS,
 			FBC_ENABLE_STATUS) == enabled)
 			break;
-		msleep(10);
+		udelay(100);
 		counter++;
 	}
 

commit 1409bc6b2bff44ea4e366b892dcac4a1cf0a5e8b
Author: Roman Li <roman.li@amd.com>
Date:   Thu Mar 29 11:14:25 2018 -0400

    drm/amd/display: Fix FBC text console corruption
    
    Signed-off-by: Roman Li <roman.li@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index 775d3bf0bd39..9150d2694450 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -102,6 +102,43 @@ static uint32_t align_to_chunks_number_per_line(uint32_t pixels)
 	return 256 * ((pixels + 255) / 256);
 }
 
+static void reset_lb_on_vblank(struct dc_context *ctx)
+{
+	uint32_t value, frame_count;
+	uint32_t retry = 0;
+	uint32_t status_pos =
+			dm_read_reg(ctx, mmCRTC_STATUS_POSITION);
+
+
+	/* Only if CRTC is enabled and counter is moving we wait for one frame. */
+	if (status_pos != dm_read_reg(ctx, mmCRTC_STATUS_POSITION)) {
+		/* Resetting LB on VBlank */
+		value = dm_read_reg(ctx, mmLB_SYNC_RESET_SEL);
+		set_reg_field_value(value, 3, LB_SYNC_RESET_SEL, LB_SYNC_RESET_SEL);
+		set_reg_field_value(value, 1, LB_SYNC_RESET_SEL, LB_SYNC_RESET_SEL2);
+		dm_write_reg(ctx, mmLB_SYNC_RESET_SEL, value);
+
+		frame_count = dm_read_reg(ctx, mmCRTC_STATUS_FRAME_COUNT);
+
+
+		for (retry = 100; retry > 0; retry--) {
+			if (frame_count != dm_read_reg(ctx, mmCRTC_STATUS_FRAME_COUNT))
+				break;
+			msleep(1);
+		}
+		if (!retry)
+			dm_error("Frame count did not increase for 100ms.\n");
+
+		/* Resetting LB on VBlank */
+		value = dm_read_reg(ctx, mmLB_SYNC_RESET_SEL);
+		set_reg_field_value(value, 2, LB_SYNC_RESET_SEL, LB_SYNC_RESET_SEL);
+		set_reg_field_value(value, 0, LB_SYNC_RESET_SEL, LB_SYNC_RESET_SEL2);
+		dm_write_reg(ctx, mmLB_SYNC_RESET_SEL, value);
+
+	}
+
+}
+
 static void wait_for_fbc_state_changed(
 	struct dce110_compressor *cp110,
 	bool enabled)
@@ -232,19 +269,23 @@ void dce110_compressor_disable_fbc(struct compressor *compressor)
 {
 	struct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);
 
-	if (compressor->options.bits.FBC_SUPPORT &&
-		dce110_compressor_is_fbc_enabled_in_hw(compressor, NULL)) {
-		uint32_t reg_data;
-		/* Turn off compression */
-		reg_data = dm_read_reg(compressor->ctx, mmFBC_CNTL);
-		set_reg_field_value(reg_data, 0, FBC_CNTL, FBC_GRPH_COMP_EN);
-		dm_write_reg(compressor->ctx, mmFBC_CNTL, reg_data);
-
-		/* Reset enum controller_id to undefined */
-		compressor->attached_inst = 0;
-		compressor->is_enabled = false;
-
-		wait_for_fbc_state_changed(cp110, false);
+	if (compressor->options.bits.FBC_SUPPORT) {
+		if (dce110_compressor_is_fbc_enabled_in_hw(compressor, NULL)) {
+			uint32_t reg_data;
+			/* Turn off compression */
+			reg_data = dm_read_reg(compressor->ctx, mmFBC_CNTL);
+			set_reg_field_value(reg_data, 0, FBC_CNTL, FBC_GRPH_COMP_EN);
+			dm_write_reg(compressor->ctx, mmFBC_CNTL, reg_data);
+
+			/* Reset enum controller_id to undefined */
+			compressor->attached_inst = 0;
+			compressor->is_enabled = false;
+
+			wait_for_fbc_state_changed(cp110, false);
+		}
+
+		/* Sync line buffer  - dce100/110 only*/
+		reset_lb_on_vblank(compressor->ctx);
 	}
 }
 

commit 1296423bf23c7a58133970e223b1f47ec6570308
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Feb 20 17:42:50 2018 -0500

    drm/amd/display: define DC_LOGGER for logger
    
    Created a DC_LOGGER define. This is used to
    pass the logger into the macros.
    
    Anywhere we need to use the logger we need to define
    DC_LOGGER
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index af854f21e9f5..775d3bf0bd39 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -34,6 +34,8 @@
 
 #include "dce110_compressor.h"
 
+#define DC_LOGGER \
+		cp110->base.ctx->logger
 #define DCP_REG(reg)\
 	(reg + cp110->offsets.dcp_offset)
 #define DMIF_REG(reg)\
@@ -120,14 +122,10 @@ static void wait_for_fbc_state_changed(
 	}
 
 	if (counter == 10) {
-		DC_LOG_WARNING(
-			cp110->base.ctx->logger,
-			"%s: wait counter exceeded, changes to HW not applied",
+		DC_LOG_WARNING("%s: wait counter exceeded, changes to HW not applied",
 			__func__);
 	} else {
-		DC_LOG_SYNC(
-			cp110->base.ctx->logger,
-			"FBC status changed to %d", enabled);
+		DC_LOG_SYNC("FBC status changed to %d", enabled);
 	}
 
 
@@ -310,9 +308,7 @@ void dce110_compressor_program_compressed_surface_address_and_pitch(
 	if (compressor->min_compress_ratio == FBC_COMPRESS_RATIO_1TO1)
 		fbc_pitch = fbc_pitch / 8;
 	else
-		DC_LOG_WARNING(
-			compressor->ctx->logger,
-			"%s: Unexpected DCE11 compression ratio",
+		DC_LOG_WARNING("%s: Unexpected DCE11 compression ratio",
 			__func__);
 
 	/* Clear content first. */

commit 2f3fd67a8af25f5b4d549c3e9cc515dbf1839ffc
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Fri Feb 16 13:57:42 2018 -0500

    drm/amd/display: Use MACROS instead of dm_logger
    
    Created MACROS for all log levels. Also Replaced
    usage of dm_logger_write to the defined MACROS
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index 6923662413cd..af854f21e9f5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -120,13 +120,13 @@ static void wait_for_fbc_state_changed(
 	}
 
 	if (counter == 10) {
-		dm_logger_write(
-			cp110->base.ctx->logger, LOG_WARNING,
+		DC_LOG_WARNING(
+			cp110->base.ctx->logger,
 			"%s: wait counter exceeded, changes to HW not applied",
 			__func__);
 	} else {
-		dm_logger_write(
-			cp110->base.ctx->logger, LOG_SYNC,
+		DC_LOG_SYNC(
+			cp110->base.ctx->logger,
 			"FBC status changed to %d", enabled);
 	}
 
@@ -310,8 +310,8 @@ void dce110_compressor_program_compressed_surface_address_and_pitch(
 	if (compressor->min_compress_ratio == FBC_COMPRESS_RATIO_1TO1)
 		fbc_pitch = fbc_pitch / 8;
 	else
-		dm_logger_write(
-			compressor->ctx->logger, LOG_WARNING,
+		DC_LOG_WARNING(
+			compressor->ctx->logger,
 			"%s: Unexpected DCE11 compression ratio",
 			__func__);
 

commit 3eab79163fcb0f7777440dfe360d2eedbbcc47b9
Author: Shirish S <shirish.s@amd.com>
Date:   Tue Sep 26 15:35:42 2017 +0530

    drm/amd/display: make FBC configurable option
    
    Currently FBC is guarded with ENABLE_FBC macro,
    which needs to be manually enabled in Makefile.
    
    This patch moves it to Kconfig so that there
    wont be any need to additional patch to be carried
    for enabling or disabling on every SoC.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index 3872febb4f6b..6923662413cd 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -514,7 +514,7 @@ void dce110_compressor_construct(struct dce110_compressor *compressor,
 	compressor->base.lpt_channels_num = 0;
 	compressor->base.attached_inst = 0;
 	compressor->base.is_enabled = false;
-#ifdef ENABLE_FBC
+#if defined(CONFIG_DRM_AMD_DC_FBC)
 	compressor->base.funcs = &dce110_compressor_funcs;
 
 #endif

commit c13b408b81f8a101501d78ca499afee98e0f0ab9
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 14:34:39 2017 +1000

    amdgpu/dc: another round of dce/dcn construct cleanups.
    
    This removes any remaining pointless return codepaths from the
    DCE code.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index 90770cb2ffcd..3872febb4f6b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -393,12 +393,8 @@ struct compressor *dce110_compressor_create(struct dc_context *ctx)
 	if (!cp110)
 		return NULL;
 
-	if (dce110_compressor_construct(cp110, ctx))
-		return &cp110->base;
-
-	BREAK_TO_DEBUGGER();
-	kfree(cp110);
-	return NULL;
+	dce110_compressor_construct(cp110, ctx);
+	return &cp110->base;
 }
 
 void dce110_compressor_destroy(struct compressor **compressor)
@@ -485,7 +481,7 @@ static const struct compressor_funcs dce110_compressor_funcs = {
 };
 
 
-bool dce110_compressor_construct(struct dce110_compressor *compressor,
+void dce110_compressor_construct(struct dce110_compressor *compressor,
 	struct dc_context *ctx)
 {
 
@@ -522,6 +518,5 @@ bool dce110_compressor_construct(struct dce110_compressor *compressor,
 	compressor->base.funcs = &dce110_compressor_funcs;
 
 #endif
-	return true;
 }
 

commit 2004f45ef83f07f43f5da6ede780b08068c7583d
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Sep 27 10:53:50 2017 -0400

    drm/amd/display: Use kernel alloc/free
    
    Abstractions are frowned upon.
    
    cocci script:
    virtual context
    virtual patch
    virtual org
    virtual report
    
    @@
    expression ptr;
    @@
    
    - dm_alloc(ptr)
    + kzalloc(ptr, GFP_KERNEL)
    
    @@
    expression ptr, size;
    @@
    
    - dm_realloc(ptr, size)
    + krealloc(ptr, size, GFP_KERNEL)
    
    @@
    expression ptr;
    @@
    
    - dm_free(ptr)
    + kfree(ptr)
    
    v2: use GFP_KERNEL, not GFP_ATOMIC. add cocci script
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index f82c26995609..90770cb2ffcd 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -388,7 +388,7 @@ void dce110_compressor_set_fbc_invalidation_triggers(
 struct compressor *dce110_compressor_create(struct dc_context *ctx)
 {
 	struct dce110_compressor *cp110 =
-		dm_alloc(sizeof(struct dce110_compressor));
+		kzalloc(sizeof(struct dce110_compressor), GFP_KERNEL);
 
 	if (!cp110)
 		return NULL;
@@ -397,13 +397,13 @@ struct compressor *dce110_compressor_create(struct dc_context *ctx)
 		return &cp110->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(cp110);
+	kfree(cp110);
 	return NULL;
 }
 
 void dce110_compressor_destroy(struct compressor **compressor)
 {
-	dm_free(TO_DCE110_COMPRESSOR(*compressor));
+	kfree(TO_DCE110_COMPRESSOR(*compressor));
 	*compressor = NULL;
 }
 

commit 07fde11f27fb4de3b63ef117593291b094a23e15
Author: Roman Li <Roman.Li@amd.com>
Date:   Fri Aug 25 16:44:20 2017 -0400

    drm/amd/display: program fbc for scatter/gather
    
    Fixing screen flickering when FBC enabled on Stoney
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index 2e97e5757fb9..f82c26995609 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -189,7 +189,7 @@ void dce110_compressor_enable_fbc(
 		(!dce110_compressor_is_fbc_enabled_in_hw(compressor, NULL))) {
 
 		uint32_t addr;
-		uint32_t value;
+		uint32_t value, misc_value;
 
 
 		addr = mmFBC_CNTL;
@@ -206,9 +206,23 @@ void dce110_compressor_enable_fbc(
 		compressor->attached_inst = params->inst;
 		cp110->offsets = reg_offsets[params->inst];
 
-		/*Toggle it as there is bug in HW */
+		/* Toggle it as there is bug in HW */
 		set_reg_field_value(value, 0, FBC_CNTL, FBC_GRPH_COMP_EN);
 		dm_write_reg(compressor->ctx, addr, value);
+
+		/* FBC usage with scatter & gather for dce110 */
+		misc_value = dm_read_reg(compressor->ctx, mmFBC_MISC);
+
+		set_reg_field_value(misc_value, 1,
+				FBC_MISC, FBC_INVALIDATE_ON_ERROR);
+		set_reg_field_value(misc_value, 1,
+				FBC_MISC, FBC_DECOMPRESS_ERROR_CLEAR);
+		set_reg_field_value(misc_value, 0x14,
+				FBC_MISC, FBC_SLOW_REQ_INTERVAL);
+
+		dm_write_reg(compressor->ctx, mmFBC_MISC, misc_value);
+
+		/* Enable FBC */
 		set_reg_field_value(value, 1, FBC_CNTL, FBC_GRPH_COMP_EN);
 		dm_write_reg(compressor->ctx, addr, value);
 

commit 1bd4653a29a49f6fd732cd294e0f87b15feec5a8
Author: Roman Li <Roman.Li@amd.com>
Date:   Wed Aug 16 19:06:49 2017 -0400

    drm/amd/display: increase polling interval for fbc status update
    
    1.Fixing error message:
    "wait counter exceeded, changes to HW not applied"
    2. Added "FBC status changed to 0/1" logs
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index 9759d8e790a3..2e97e5757fb9 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -115,7 +115,7 @@ static void wait_for_fbc_state_changed(
 			FBC_STATUS,
 			FBC_ENABLE_STATUS) == enabled)
 			break;
-		udelay(10);
+		msleep(10);
 		counter++;
 	}
 
@@ -124,7 +124,13 @@ static void wait_for_fbc_state_changed(
 			cp110->base.ctx->logger, LOG_WARNING,
 			"%s: wait counter exceeded, changes to HW not applied",
 			__func__);
+	} else {
+		dm_logger_write(
+			cp110->base.ctx->logger, LOG_SYNC,
+			"FBC status changed to %d", enabled);
 	}
+
+
 }
 
 void dce110_compressor_power_up_fbc(struct compressor *compressor)

commit 72f0281d34b464121f9f6b75a2d7a2502055ec79
Author: Roman Li <Roman.Li@amd.com>
Date:   Wed Jul 19 16:59:14 2017 -0400

    drm/amd/display: fix index and union overwrite in compressor
    
      Fixing 2 bugs in compressor:
    - array out of bounds due to incorrect index
    - compressor options always 0 due to union overwrite
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index 1e59f4e31a6a..9759d8e790a3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -198,7 +198,7 @@ void dce110_compressor_enable_fbc(
 		/* Keep track of enum controller_id FBC is attached to */
 		compressor->is_enabled = true;
 		compressor->attached_inst = params->inst;
-		cp110->offsets = reg_offsets[params->inst - 1];
+		cp110->offsets = reg_offsets[params->inst];
 
 		/*Toggle it as there is bug in HW */
 		set_reg_field_value(value, 0, FBC_CNTL, FBC_GRPH_COMP_EN);
@@ -469,6 +469,7 @@ bool dce110_compressor_construct(struct dce110_compressor *compressor,
 	struct dc_context *ctx)
 {
 
+	compressor->base.options.raw = 0;
 	compressor->base.options.bits.FBC_SUPPORT = true;
 
 	/* for dce 11 always use one dram channel for lpt */
@@ -490,7 +491,6 @@ bool dce110_compressor_construct(struct dce110_compressor *compressor,
 	compressor->base.allocated_size = 0;
 	compressor->base.preferred_requested_size = 0;
 	compressor->base.min_compress_ratio = FBC_COMPRESS_RATIO_INVALID;
-	compressor->base.options.raw = 0;
 	compressor->base.banks_num = 0;
 	compressor->base.raw_size = 0;
 	compressor->base.channel_interleave_size = 0;

commit 1663ae1c4288da81b9f1668d204aa8ed55ebf849
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Jun 27 16:34:27 2017 -0400

    drm/amd/display: Connect DC resource to FBC compressor
    
    - Connected DC resource to FBC compressor,
    - Initial Implementation of FBC for Stoney/Carrizo
    - Code is currently guarded with "ENABLE_FBC" compile time flag
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index 5fe83045d1a6..1e59f4e31a6a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -175,7 +175,6 @@ void dce110_compressor_power_up_fbc(struct compressor *compressor)
 
 void dce110_compressor_enable_fbc(
 	struct compressor *compressor,
-	uint32_t paths_num,
 	struct compr_addr_and_pitch_params *params)
 {
 	struct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);
@@ -366,43 +365,6 @@ void dce110_compressor_set_fbc_invalidation_triggers(
 	dm_write_reg(compressor->ctx, addr, value);
 }
 
-bool dce110_compressor_construct(struct dce110_compressor *compressor,
-				 struct dc_context *ctx)
-{
-
-	compressor->base.options.bits.FBC_SUPPORT = true;
-
-	 /* for dce 11 always use one dram channel for lpt */
-	compressor->base.lpt_channels_num = 1;
-	compressor->base.options.bits.DUMMY_BACKEND = false;
-
-	/*
-	 * check if this system has more than 1 dram channel; if only 1 then lpt
-	 * should not be supported
-	 */
-
-
-	compressor->base.options.bits.CLK_GATING_DISABLED = false;
-
-	compressor->base.ctx = ctx;
-	compressor->base.embedded_panel_h_size = 0;
-	compressor->base.embedded_panel_v_size = 0;
-	compressor->base.memory_bus_width = ctx->asic_id.vram_width;
-	compressor->base.allocated_size = 0;
-	compressor->base.preferred_requested_size = 0;
-	compressor->base.min_compress_ratio = FBC_COMPRESS_RATIO_INVALID;
-	compressor->base.options.raw = 0;
-	compressor->base.banks_num = 0;
-	compressor->base.raw_size = 0;
-	compressor->base.channel_interleave_size = 0;
-	compressor->base.dram_channels_num = 0;
-	compressor->base.lpt_channels_num = 0;
-	compressor->base.attached_inst = 0;
-	compressor->base.is_enabled = false;
-
-	return true;
-}
-
 struct compressor *dce110_compressor_create(struct dc_context *ctx)
 {
 	struct dce110_compressor *cp110 =
@@ -503,3 +465,43 @@ static const struct compressor_funcs dce110_compressor_funcs = {
 };
 
 
+bool dce110_compressor_construct(struct dce110_compressor *compressor,
+	struct dc_context *ctx)
+{
+
+	compressor->base.options.bits.FBC_SUPPORT = true;
+
+	/* for dce 11 always use one dram channel for lpt */
+	compressor->base.lpt_channels_num = 1;
+	compressor->base.options.bits.DUMMY_BACKEND = false;
+
+	/*
+	 * check if this system has more than 1 dram channel; if only 1 then lpt
+	 * should not be supported
+	 */
+
+
+	compressor->base.options.bits.CLK_GATING_DISABLED = false;
+
+	compressor->base.ctx = ctx;
+	compressor->base.embedded_panel_h_size = 0;
+	compressor->base.embedded_panel_v_size = 0;
+	compressor->base.memory_bus_width = ctx->asic_id.vram_width;
+	compressor->base.allocated_size = 0;
+	compressor->base.preferred_requested_size = 0;
+	compressor->base.min_compress_ratio = FBC_COMPRESS_RATIO_INVALID;
+	compressor->base.options.raw = 0;
+	compressor->base.banks_num = 0;
+	compressor->base.raw_size = 0;
+	compressor->base.channel_interleave_size = 0;
+	compressor->base.dram_channels_num = 0;
+	compressor->base.lpt_channels_num = 0;
+	compressor->base.attached_inst = 0;
+	compressor->base.is_enabled = false;
+#ifdef ENABLE_FBC
+	compressor->base.funcs = &dce110_compressor_funcs;
+
+#endif
+	return true;
+}
+

commit 7f524a0d838d8d9334003b956b73729f27a1315a
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Fri Jun 23 13:35:53 2017 -0400

    drm/amd/display: remove unneeded FBC hw programming code
    
    - Removed uneeded FBC code.
    - Initial placeholder for FBC implementation on stoney/carrizo
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
index 518150a414e2..5fe83045d1a6 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -94,199 +94,8 @@ enum fbc_idle_force {
 	FBC_IDLE_FORCE_CG_STATIC_SCREEN_IS_INACTIVE = 0x20000000,
 };
 
-static uint32_t lpt_size_alignment(struct dce110_compressor *cp110)
-{
-	/*LPT_ALIGNMENT (in bytes) = ROW_SIZE * #BANKS * # DRAM CHANNELS. */
-	return cp110->base.raw_size * cp110->base.banks_num *
-		cp110->base.dram_channels_num;
-}
-
-static uint32_t lpt_memory_control_config(struct dce110_compressor *cp110,
-	uint32_t lpt_control)
-{
-	/*LPT MC Config */
-	if (cp110->base.options.bits.LPT_MC_CONFIG == 1) {
-		/* POSSIBLE VALUES for LPT NUM_PIPES (DRAM CHANNELS):
-		 * 00 - 1 CHANNEL
-		 * 01 - 2 CHANNELS
-		 * 02 - 4 OR 6 CHANNELS
-		 * (Only for discrete GPU, N/A for CZ)
-		 * 03 - 8 OR 12 CHANNELS
-		 * (Only for discrete GPU, N/A for CZ) */
-		switch (cp110->base.dram_channels_num) {
-		case 2:
-			set_reg_field_value(
-				lpt_control,
-				1,
-				LOW_POWER_TILING_CONTROL,
-				LOW_POWER_TILING_NUM_PIPES);
-			break;
-		case 1:
-			set_reg_field_value(
-				lpt_control,
-				0,
-				LOW_POWER_TILING_CONTROL,
-				LOW_POWER_TILING_NUM_PIPES);
-			break;
-		default:
-			dm_logger_write(
-				cp110->base.ctx->logger, LOG_WARNING,
-				"%s: Invalid LPT NUM_PIPES!!!",
-				__func__);
-			break;
-		}
-
-		/* The mapping for LPT NUM_BANKS is in
-		 * GRPH_CONTROL.GRPH_NUM_BANKS register field
-		 * Specifies the number of memory banks for tiling
-		 * purposes. Only applies to 2D and 3D tiling modes.
-		 * POSSIBLE VALUES:
-		 * 00 - DCP_GRPH_NUM_BANKS_2BANK: ADDR_SURF_2_BANK
-		 * 01 - DCP_GRPH_NUM_BANKS_4BANK: ADDR_SURF_4_BANK
-		 * 02 - DCP_GRPH_NUM_BANKS_8BANK: ADDR_SURF_8_BANK
-		 * 03 - DCP_GRPH_NUM_BANKS_16BANK: ADDR_SURF_16_BANK */
-		switch (cp110->base.banks_num) {
-		case 16:
-			set_reg_field_value(
-				lpt_control,
-				3,
-				LOW_POWER_TILING_CONTROL,
-				LOW_POWER_TILING_NUM_BANKS);
-			break;
-		case 8:
-			set_reg_field_value(
-				lpt_control,
-				2,
-				LOW_POWER_TILING_CONTROL,
-				LOW_POWER_TILING_NUM_BANKS);
-			break;
-		case 4:
-			set_reg_field_value(
-				lpt_control,
-				1,
-				LOW_POWER_TILING_CONTROL,
-				LOW_POWER_TILING_NUM_BANKS);
-			break;
-		case 2:
-			set_reg_field_value(
-				lpt_control,
-				0,
-				LOW_POWER_TILING_CONTROL,
-				LOW_POWER_TILING_NUM_BANKS);
-			break;
-		default:
-			dm_logger_write(
-				cp110->base.ctx->logger, LOG_WARNING,
-				"%s: Invalid LPT NUM_BANKS!!!",
-				__func__);
-			break;
-		}
-
-		/* The mapping is in DMIF_ADDR_CALC.
-		 * ADDR_CONFIG_PIPE_INTERLEAVE_SIZE register field for
-		 * Carrizo specifies the memory interleave per pipe.
-		 * It effectively specifies the location of pipe bits in
-		 * the memory address.
-		 * POSSIBLE VALUES:
-		 * 00 - ADDR_CONFIG_PIPE_INTERLEAVE_256B: 256 byte
-		 * interleave
-		 * 01 - ADDR_CONFIG_PIPE_INTERLEAVE_512B: 512 byte
-		 * interleave
-		 */
-		switch (cp110->base.channel_interleave_size) {
-		case 256: /*256B */
-			set_reg_field_value(
-				lpt_control,
-				0,
-				LOW_POWER_TILING_CONTROL,
-				LOW_POWER_TILING_PIPE_INTERLEAVE_SIZE);
-			break;
-		case 512: /*512B */
-			set_reg_field_value(
-				lpt_control,
-				1,
-				LOW_POWER_TILING_CONTROL,
-				LOW_POWER_TILING_PIPE_INTERLEAVE_SIZE);
-			break;
-		default:
-			dm_logger_write(
-				cp110->base.ctx->logger, LOG_WARNING,
-				"%s: Invalid LPT INTERLEAVE_SIZE!!!",
-				__func__);
-			break;
-		}
 
-		/* The mapping for LOW_POWER_TILING_ROW_SIZE is in
-		 * DMIF_ADDR_CALC.ADDR_CONFIG_ROW_SIZE register field
-		 * for Carrizo. Specifies the size of dram row in bytes.
-		 * This should match up with NOOFCOLS field in
-		 * MC_ARB_RAMCFG (ROW_SIZE = 4 * 2 ^^ columns).
-		 * This register DMIF_ADDR_CALC is not used by the
-		 * hardware as it is only used for addrlib assertions.
-		 * POSSIBLE VALUES:
-		 * 00 - ADDR_CONFIG_1KB_ROW: Treat 1KB as DRAM row
-		 * boundary
-		 * 01 - ADDR_CONFIG_2KB_ROW: Treat 2KB as DRAM row
-		 * boundary
-		 * 02 - ADDR_CONFIG_4KB_ROW: Treat 4KB as DRAM row
-		 * boundary */
-		switch (cp110->base.raw_size) {
-		case 4096: /*4 KB */
-			set_reg_field_value(
-				lpt_control,
-				2,
-				LOW_POWER_TILING_CONTROL,
-				LOW_POWER_TILING_ROW_SIZE);
-			break;
-		case 2048:
-			set_reg_field_value(
-				lpt_control,
-				1,
-				LOW_POWER_TILING_CONTROL,
-				LOW_POWER_TILING_ROW_SIZE);
-			break;
-		case 1024:
-			set_reg_field_value(
-				lpt_control,
-				0,
-				LOW_POWER_TILING_CONTROL,
-				LOW_POWER_TILING_ROW_SIZE);
-			break;
-		default:
-			dm_logger_write(
-				cp110->base.ctx->logger, LOG_WARNING,
-				"%s: Invalid LPT ROW_SIZE!!!",
-				__func__);
-			break;
-		}
-	} else {
-		dm_logger_write(
-			cp110->base.ctx->logger, LOG_WARNING,
-			"%s: LPT MC Configuration is not provided",
-			__func__);
-	}
-
-	return lpt_control;
-}
-
-static bool is_source_bigger_than_epanel_size(
-	struct dce110_compressor *cp110,
-	uint32_t source_view_width,
-	uint32_t source_view_height)
-{
-	if (cp110->base.embedded_panel_h_size != 0 &&
-		cp110->base.embedded_panel_v_size != 0 &&
-		((source_view_width * source_view_height) >
-		(cp110->base.embedded_panel_h_size *
-			cp110->base.embedded_panel_v_size)))
-		return true;
-
-	return false;
-}
-
-static uint32_t align_to_chunks_number_per_line(
-	struct dce110_compressor *cp110,
-	uint32_t pixels)
+static uint32_t align_to_chunks_number_per_line(uint32_t pixels)
 {
 	return 256 * ((pixels + 255) / 256);
 }
@@ -372,25 +181,11 @@ void dce110_compressor_enable_fbc(
 	struct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);
 
 	if (compressor->options.bits.FBC_SUPPORT &&
-		(compressor->options.bits.DUMMY_BACKEND == 0) &&
-		(!dce110_compressor_is_fbc_enabled_in_hw(compressor, NULL)) &&
-		(!is_source_bigger_than_epanel_size(
-			cp110,
-			params->source_view_width,
-			params->source_view_height))) {
+		(!dce110_compressor_is_fbc_enabled_in_hw(compressor, NULL))) {
 
 		uint32_t addr;
 		uint32_t value;
 
-		/* Before enabling FBC first need to enable LPT if applicable
-		 * LPT state should always be changed (enable/disable) while FBC
-		 * is disabled */
-		if (compressor->options.bits.LPT_SUPPORT && (paths_num < 2) &&
-			(params->source_view_width *
-				params->source_view_height <=
-				dce11_one_lpt_channel_max_resolution)) {
-			dce110_compressor_enable_lpt(compressor);
-		}
 
 		addr = mmFBC_CNTL;
 		value = dm_read_reg(compressor->ctx, addr);
@@ -432,11 +227,6 @@ void dce110_compressor_disable_fbc(struct compressor *compressor)
 		compressor->attached_inst = 0;
 		compressor->is_enabled = false;
 
-		/* Whenever disabling FBC make sure LPT is disabled if LPT
-		 * supported */
-		if (compressor->options.bits.LPT_SUPPORT)
-			dce110_compressor_disable_lpt(compressor);
-
 		wait_for_fbc_state_changed(cp110, false);
 	}
 }
@@ -469,17 +259,6 @@ bool dce110_compressor_is_fbc_enabled_in_hw(
 	return false;
 }
 
-bool dce110_compressor_is_lpt_enabled_in_hw(struct compressor *compressor)
-{
-	/* Check the hardware register */
-	uint32_t value = dm_read_reg(compressor->ctx,
-		mmLOW_POWER_TILING_CONTROL);
-
-	return get_reg_field_value(
-		value,
-		LOW_POWER_TILING_CONTROL,
-		LOW_POWER_TILING_ENABLE);
-}
 
 void dce110_compressor_program_compressed_surface_address_and_pitch(
 	struct compressor *compressor,
@@ -499,17 +278,6 @@ void dce110_compressor_program_compressed_surface_address_and_pitch(
 	dm_write_reg(compressor->ctx,
 		DCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS), 0);
 
-	if (compressor->options.bits.LPT_SUPPORT) {
-		uint32_t lpt_alignment = lpt_size_alignment(cp110);
-
-		if (lpt_alignment != 0) {
-			compressed_surf_address_low_part =
-				((compressed_surf_address_low_part
-					+ (lpt_alignment - 1)) / lpt_alignment)
-					* lpt_alignment;
-		}
-	}
-
 	/* Write address, HIGH has to be first. */
 	dm_write_reg(compressor->ctx,
 		DCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS_HIGH),
@@ -518,9 +286,7 @@ void dce110_compressor_program_compressed_surface_address_and_pitch(
 		DCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS),
 		compressed_surf_address_low_part);
 
-	fbc_pitch = align_to_chunks_number_per_line(
-		cp110,
-		params->source_view_width);
+	fbc_pitch = align_to_chunks_number_per_line(params->source_view_width);
 
 	if (compressor->min_compress_ratio == FBC_COMPRESS_RATIO_1TO1)
 		fbc_pitch = fbc_pitch / 8;
@@ -543,197 +309,6 @@ void dce110_compressor_program_compressed_surface_address_and_pitch(
 
 }
 
-void dce110_compressor_disable_lpt(struct compressor *compressor)
-{
-	struct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);
-	uint32_t value;
-	uint32_t addr;
-	uint32_t inx;
-
-	/* Disable all pipes LPT Stutter */
-	for (inx = 0; inx < 3; inx++) {
-		value =
-			dm_read_reg(
-				compressor->ctx,
-				DMIF_REG(mmDPG_PIPE_STUTTER_CONTROL_NONLPTCH));
-		set_reg_field_value(
-			value,
-			0,
-			DPG_PIPE_STUTTER_CONTROL_NONLPTCH,
-			STUTTER_ENABLE_NONLPTCH);
-		dm_write_reg(
-			compressor->ctx,
-			DMIF_REG(mmDPG_PIPE_STUTTER_CONTROL_NONLPTCH),
-			value);
-	}
-	/* Disable Underlay pipe LPT Stutter */
-	addr = mmDPGV0_PIPE_STUTTER_CONTROL_NONLPTCH;
-	value = dm_read_reg(compressor->ctx, addr);
-	set_reg_field_value(
-		value,
-		0,
-		DPGV0_PIPE_STUTTER_CONTROL_NONLPTCH,
-		STUTTER_ENABLE_NONLPTCH);
-	dm_write_reg(compressor->ctx, addr, value);
-
-	/* Disable LPT */
-	addr = mmLOW_POWER_TILING_CONTROL;
-	value = dm_read_reg(compressor->ctx, addr);
-	set_reg_field_value(
-		value,
-		0,
-		LOW_POWER_TILING_CONTROL,
-		LOW_POWER_TILING_ENABLE);
-	dm_write_reg(compressor->ctx, addr, value);
-
-	/* Clear selection of Channel(s) containing Compressed Surface */
-	addr = mmGMCON_LPT_TARGET;
-	value = dm_read_reg(compressor->ctx, addr);
-	set_reg_field_value(
-		value,
-		0xFFFFFFFF,
-		GMCON_LPT_TARGET,
-		STCTRL_LPT_TARGET);
-	dm_write_reg(compressor->ctx, mmGMCON_LPT_TARGET, value);
-}
-
-void dce110_compressor_enable_lpt(struct compressor *compressor)
-{
-	struct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);
-	uint32_t value;
-	uint32_t addr;
-	uint32_t value_control;
-	uint32_t channels;
-
-	/* Enable LPT Stutter from Display pipe */
-	value = dm_read_reg(compressor->ctx,
-		DMIF_REG(mmDPG_PIPE_STUTTER_CONTROL_NONLPTCH));
-	set_reg_field_value(
-		value,
-		1,
-		DPG_PIPE_STUTTER_CONTROL_NONLPTCH,
-		STUTTER_ENABLE_NONLPTCH);
-	dm_write_reg(compressor->ctx,
-		DMIF_REG(mmDPG_PIPE_STUTTER_CONTROL_NONLPTCH), value);
-
-	/* Enable Underlay pipe LPT Stutter */
-	addr = mmDPGV0_PIPE_STUTTER_CONTROL_NONLPTCH;
-	value = dm_read_reg(compressor->ctx, addr);
-	set_reg_field_value(
-		value,
-		1,
-		DPGV0_PIPE_STUTTER_CONTROL_NONLPTCH,
-		STUTTER_ENABLE_NONLPTCH);
-	dm_write_reg(compressor->ctx, addr, value);
-
-	/* Selection of Channel(s) containing Compressed Surface: 0xfffffff
-	 * will disable LPT.
-	 * STCTRL_LPT_TARGETn corresponds to channel n. */
-	addr = mmLOW_POWER_TILING_CONTROL;
-	value_control = dm_read_reg(compressor->ctx, addr);
-	channels = get_reg_field_value(value_control,
-			LOW_POWER_TILING_CONTROL,
-			LOW_POWER_TILING_MODE);
-
-	addr = mmGMCON_LPT_TARGET;
-	value = dm_read_reg(compressor->ctx, addr);
-	set_reg_field_value(
-		value,
-		channels + 1, /* not mentioned in programming guide,
-				but follow DCE8.1 */
-		GMCON_LPT_TARGET,
-		STCTRL_LPT_TARGET);
-	dm_write_reg(compressor->ctx, addr, value);
-
-	/* Enable LPT */
-	addr = mmLOW_POWER_TILING_CONTROL;
-	value = dm_read_reg(compressor->ctx, addr);
-	set_reg_field_value(
-		value,
-		1,
-		LOW_POWER_TILING_CONTROL,
-		LOW_POWER_TILING_ENABLE);
-	dm_write_reg(compressor->ctx, addr, value);
-}
-
-void dce110_compressor_program_lpt_control(
-	struct compressor *compressor,
-	struct compr_addr_and_pitch_params *params)
-{
-	struct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);
-	uint32_t rows_per_channel;
-	uint32_t lpt_alignment;
-	uint32_t source_view_width;
-	uint32_t source_view_height;
-	uint32_t lpt_control = 0;
-
-	if (!compressor->options.bits.LPT_SUPPORT)
-		return;
-
-	lpt_control = dm_read_reg(compressor->ctx,
-		mmLOW_POWER_TILING_CONTROL);
-
-	/* POSSIBLE VALUES for Low Power Tiling Mode:
-	 * 00 - Use channel 0
-	 * 01 - Use Channel 0 and 1
-	 * 02 - Use Channel 0,1,2,3
-	 * 03 - reserved */
-	switch (compressor->lpt_channels_num) {
-	/* case 2:
-	 * Use Channel 0 & 1 / Not used for DCE 11 */
-	case 1:
-		/*Use Channel 0 for LPT for DCE 11 */
-		set_reg_field_value(
-			lpt_control,
-			0,
-			LOW_POWER_TILING_CONTROL,
-			LOW_POWER_TILING_MODE);
-		break;
-	default:
-		dm_logger_write(
-			compressor->ctx->logger, LOG_WARNING,
-			"%s: Invalid selected DRAM channels for LPT!!!",
-			__func__);
-		break;
-	}
-
-	lpt_control = lpt_memory_control_config(cp110, lpt_control);
-
-	/* Program LOW_POWER_TILING_ROWS_PER_CHAN field which depends on
-	 * FBC compressed surface pitch.
-	 * LOW_POWER_TILING_ROWS_PER_CHAN = Roundup ((Surface Height *
-	 * Surface Pitch) / (Row Size * Number of Channels *
-	 * Number of Banks)). */
-	rows_per_channel = 0;
-	lpt_alignment = lpt_size_alignment(cp110);
-	source_view_width =
-		align_to_chunks_number_per_line(
-			cp110,
-			params->source_view_width);
-	source_view_height = (params->source_view_height + 1) & (~0x1);
-
-	if (lpt_alignment != 0) {
-		rows_per_channel = source_view_width * source_view_height * 4;
-		rows_per_channel =
-			(rows_per_channel % lpt_alignment) ?
-				(rows_per_channel / lpt_alignment + 1) :
-				rows_per_channel / lpt_alignment;
-	}
-
-	set_reg_field_value(
-		lpt_control,
-		rows_per_channel,
-		LOW_POWER_TILING_CONTROL,
-		LOW_POWER_TILING_ROWS_PER_CHAN);
-
-	dm_write_reg(compressor->ctx,
-		mmLOW_POWER_TILING_CONTROL, lpt_control);
-}
-
-/*
- * DCE 11 Frame Buffer Compression Implementation
- */
-
 void dce110_compressor_set_fbc_invalidation_triggers(
 	struct compressor *compressor,
 	uint32_t fbc_trigger)
@@ -792,21 +367,20 @@ void dce110_compressor_set_fbc_invalidation_triggers(
 }
 
 bool dce110_compressor_construct(struct dce110_compressor *compressor,
-	struct dc_context *ctx)
+				 struct dc_context *ctx)
 {
-	struct dc_bios *bp = ctx->dc_bios;
-	struct embedded_panel_info panel_info;
 
 	compressor->base.options.bits.FBC_SUPPORT = true;
-	compressor->base.options.bits.LPT_SUPPORT = true;
-	 /* For DCE 11 always use one DRAM channel for LPT */
+
+	 /* for dce 11 always use one dram channel for lpt */
 	compressor->base.lpt_channels_num = 1;
 	compressor->base.options.bits.DUMMY_BACKEND = false;
 
-	/* Check if this system has more than 1 DRAM channel; if only 1 then LPT
-	 * should not be supported */
-	if (compressor->base.memory_bus_width == 64)
-		compressor->base.options.bits.LPT_SUPPORT = false;
+	/*
+	 * check if this system has more than 1 dram channel; if only 1 then lpt
+	 * should not be supported
+	 */
+
 
 	compressor->base.options.bits.CLK_GATING_DISABLED = false;
 
@@ -826,13 +400,6 @@ bool dce110_compressor_construct(struct dce110_compressor *compressor,
 	compressor->base.attached_inst = 0;
 	compressor->base.is_enabled = false;
 
-	if (BP_RESULT_OK ==
-			bp->funcs->get_embedded_panel_info(bp, &panel_info)) {
-		compressor->base.embedded_panel_h_size =
-			panel_info.lcd_timing.horizontal_addressable;
-		compressor->base.embedded_panel_v_size =
-			panel_info.lcd_timing.vertical_addressable;
-	}
 	return true;
 }
 
@@ -857,3 +424,82 @@ void dce110_compressor_destroy(struct compressor **compressor)
 	dm_free(TO_DCE110_COMPRESSOR(*compressor));
 	*compressor = NULL;
 }
+
+bool dce110_get_required_compressed_surfacesize(struct fbc_input_info fbc_input_info,
+						struct fbc_requested_compressed_size size)
+{
+	bool result = false;
+
+	unsigned int max_x = FBC_MAX_X, max_y = FBC_MAX_Y;
+
+	get_max_support_fbc_buffersize(&max_x, &max_y);
+
+	if (fbc_input_info.dynamic_fbc_buffer_alloc == 0) {
+		/*
+		 * For DCE11 here use Max HW supported size:  HW Support up to 3840x2400 resolution
+		 * or 18000 chunks.
+		 */
+		size.preferred_size = size.min_size = align_to_chunks_number_per_line(max_x) * max_y * 4;  /* (For FBC when LPT not supported). */
+		size.preferred_size_alignment = size.min_size_alignment = 0x100;       /* For FBC when LPT not supported */
+		size.bits.preferred_must_be_framebuffer_pool = 1;
+		size.bits.min_must_be_framebuffer_pool = 1;
+
+		result = true;
+	}
+	/*
+	 * Maybe to add registry key support with optional size here to override above
+	 * for debugging purposes
+	 */
+
+	return result;
+}
+
+
+void get_max_support_fbc_buffersize(unsigned int *max_x, unsigned int *max_y)
+{
+	*max_x = FBC_MAX_X;
+	*max_y = FBC_MAX_Y;
+
+	/* if (m_smallLocalFrameBufferMemory == 1)
+	 * {
+	 *	*max_x = FBC_MAX_X_SG;
+	 *	*max_y = FBC_MAX_Y_SG;
+	 * }
+	 */
+}
+
+
+unsigned int controller_id_to_index(enum controller_id controller_id)
+{
+	unsigned int index = 0;
+
+	switch (controller_id) {
+	case CONTROLLER_ID_D0:
+		index = 0;
+		break;
+	case CONTROLLER_ID_D1:
+		index = 1;
+		break;
+	case CONTROLLER_ID_D2:
+		index = 2;
+		break;
+	case CONTROLLER_ID_D3:
+		index = 3;
+		break;
+	default:
+		break;
+	}
+	return index;
+}
+
+
+static const struct compressor_funcs dce110_compressor_funcs = {
+	.power_up_fbc = dce110_compressor_power_up_fbc,
+	.enable_fbc = dce110_compressor_enable_fbc,
+	.disable_fbc = dce110_compressor_disable_fbc,
+	.set_fbc_invalidation_triggers = dce110_compressor_set_fbc_invalidation_triggers,
+	.surface_address_and_pitch = dce110_compressor_program_compressed_surface_address_and_pitch,
+	.is_fbc_enabled_in_hw = dce110_compressor_is_fbc_enabled_in_hw
+};
+
+

commit 4562236b3bc0a28aeb6ee93b2d8a849a4c4e1c7c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 12 15:58:20 2017 -0400

    drm/amd/dc: Add dc display driver (v2)
    
    Supported DCE versions: 8.0, 10.0, 11.0, 11.2
    
    v2: rebase against 4.11
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
new file mode 100644
index 000000000000..518150a414e2
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -0,0 +1,859 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dm_services.h"
+
+#include "dce/dce_11_0_d.h"
+#include "dce/dce_11_0_sh_mask.h"
+#include "gmc/gmc_8_2_sh_mask.h"
+#include "gmc/gmc_8_2_d.h"
+
+#include "include/logger_interface.h"
+
+#include "dce110_compressor.h"
+
+#define DCP_REG(reg)\
+	(reg + cp110->offsets.dcp_offset)
+#define DMIF_REG(reg)\
+	(reg + cp110->offsets.dmif_offset)
+
+static const struct dce110_compressor_reg_offsets reg_offsets[] = {
+{
+	.dcp_offset = (mmDCP0_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),
+	.dmif_offset =
+		(mmDMIF_PG0_DPG_PIPE_DPM_CONTROL
+			- mmDMIF_PG0_DPG_PIPE_DPM_CONTROL),
+},
+{
+	.dcp_offset = (mmDCP1_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),
+	.dmif_offset =
+		(mmDMIF_PG1_DPG_PIPE_DPM_CONTROL
+			- mmDMIF_PG0_DPG_PIPE_DPM_CONTROL),
+},
+{
+	.dcp_offset = (mmDCP2_GRPH_CONTROL - mmDCP0_GRPH_CONTROL),
+	.dmif_offset =
+		(mmDMIF_PG2_DPG_PIPE_DPM_CONTROL
+			- mmDMIF_PG0_DPG_PIPE_DPM_CONTROL),
+}
+};
+
+static const uint32_t dce11_one_lpt_channel_max_resolution = 2560 * 1600;
+
+enum fbc_idle_force {
+	/* Bit 0 - Display registers updated */
+	FBC_IDLE_FORCE_DISPLAY_REGISTER_UPDATE = 0x00000001,
+
+	/* Bit 2 - FBC_GRPH_COMP_EN register updated */
+	FBC_IDLE_FORCE_GRPH_COMP_EN = 0x00000002,
+	/* Bit 3 - FBC_SRC_SEL register updated */
+	FBC_IDLE_FORCE_SRC_SEL_CHANGE = 0x00000004,
+	/* Bit 4 - FBC_MIN_COMPRESSION register updated */
+	FBC_IDLE_FORCE_MIN_COMPRESSION_CHANGE = 0x00000008,
+	/* Bit 5 - FBC_ALPHA_COMP_EN register updated */
+	FBC_IDLE_FORCE_ALPHA_COMP_EN = 0x00000010,
+	/* Bit 6 - FBC_ZERO_ALPHA_CHUNK_SKIP_EN register updated */
+	FBC_IDLE_FORCE_ZERO_ALPHA_CHUNK_SKIP_EN = 0x00000020,
+	/* Bit 7 - FBC_FORCE_COPY_TO_COMP_BUF register updated */
+	FBC_IDLE_FORCE_FORCE_COPY_TO_COMP_BUF = 0x00000040,
+
+	/* Bit 24 - Memory write to region 0 defined by MC registers. */
+	FBC_IDLE_FORCE_MEMORY_WRITE_TO_REGION0 = 0x01000000,
+	/* Bit 25 - Memory write to region 1 defined by MC registers */
+	FBC_IDLE_FORCE_MEMORY_WRITE_TO_REGION1 = 0x02000000,
+	/* Bit 26 - Memory write to region 2 defined by MC registers */
+	FBC_IDLE_FORCE_MEMORY_WRITE_TO_REGION2 = 0x04000000,
+	/* Bit 27 - Memory write to region 3 defined by MC registers. */
+	FBC_IDLE_FORCE_MEMORY_WRITE_TO_REGION3 = 0x08000000,
+
+	/* Bit 28 - Memory write from any client other than MCIF */
+	FBC_IDLE_FORCE_MEMORY_WRITE_OTHER_THAN_MCIF = 0x10000000,
+	/* Bit 29 - CG statics screen signal is inactive */
+	FBC_IDLE_FORCE_CG_STATIC_SCREEN_IS_INACTIVE = 0x20000000,
+};
+
+static uint32_t lpt_size_alignment(struct dce110_compressor *cp110)
+{
+	/*LPT_ALIGNMENT (in bytes) = ROW_SIZE * #BANKS * # DRAM CHANNELS. */
+	return cp110->base.raw_size * cp110->base.banks_num *
+		cp110->base.dram_channels_num;
+}
+
+static uint32_t lpt_memory_control_config(struct dce110_compressor *cp110,
+	uint32_t lpt_control)
+{
+	/*LPT MC Config */
+	if (cp110->base.options.bits.LPT_MC_CONFIG == 1) {
+		/* POSSIBLE VALUES for LPT NUM_PIPES (DRAM CHANNELS):
+		 * 00 - 1 CHANNEL
+		 * 01 - 2 CHANNELS
+		 * 02 - 4 OR 6 CHANNELS
+		 * (Only for discrete GPU, N/A for CZ)
+		 * 03 - 8 OR 12 CHANNELS
+		 * (Only for discrete GPU, N/A for CZ) */
+		switch (cp110->base.dram_channels_num) {
+		case 2:
+			set_reg_field_value(
+				lpt_control,
+				1,
+				LOW_POWER_TILING_CONTROL,
+				LOW_POWER_TILING_NUM_PIPES);
+			break;
+		case 1:
+			set_reg_field_value(
+				lpt_control,
+				0,
+				LOW_POWER_TILING_CONTROL,
+				LOW_POWER_TILING_NUM_PIPES);
+			break;
+		default:
+			dm_logger_write(
+				cp110->base.ctx->logger, LOG_WARNING,
+				"%s: Invalid LPT NUM_PIPES!!!",
+				__func__);
+			break;
+		}
+
+		/* The mapping for LPT NUM_BANKS is in
+		 * GRPH_CONTROL.GRPH_NUM_BANKS register field
+		 * Specifies the number of memory banks for tiling
+		 * purposes. Only applies to 2D and 3D tiling modes.
+		 * POSSIBLE VALUES:
+		 * 00 - DCP_GRPH_NUM_BANKS_2BANK: ADDR_SURF_2_BANK
+		 * 01 - DCP_GRPH_NUM_BANKS_4BANK: ADDR_SURF_4_BANK
+		 * 02 - DCP_GRPH_NUM_BANKS_8BANK: ADDR_SURF_8_BANK
+		 * 03 - DCP_GRPH_NUM_BANKS_16BANK: ADDR_SURF_16_BANK */
+		switch (cp110->base.banks_num) {
+		case 16:
+			set_reg_field_value(
+				lpt_control,
+				3,
+				LOW_POWER_TILING_CONTROL,
+				LOW_POWER_TILING_NUM_BANKS);
+			break;
+		case 8:
+			set_reg_field_value(
+				lpt_control,
+				2,
+				LOW_POWER_TILING_CONTROL,
+				LOW_POWER_TILING_NUM_BANKS);
+			break;
+		case 4:
+			set_reg_field_value(
+				lpt_control,
+				1,
+				LOW_POWER_TILING_CONTROL,
+				LOW_POWER_TILING_NUM_BANKS);
+			break;
+		case 2:
+			set_reg_field_value(
+				lpt_control,
+				0,
+				LOW_POWER_TILING_CONTROL,
+				LOW_POWER_TILING_NUM_BANKS);
+			break;
+		default:
+			dm_logger_write(
+				cp110->base.ctx->logger, LOG_WARNING,
+				"%s: Invalid LPT NUM_BANKS!!!",
+				__func__);
+			break;
+		}
+
+		/* The mapping is in DMIF_ADDR_CALC.
+		 * ADDR_CONFIG_PIPE_INTERLEAVE_SIZE register field for
+		 * Carrizo specifies the memory interleave per pipe.
+		 * It effectively specifies the location of pipe bits in
+		 * the memory address.
+		 * POSSIBLE VALUES:
+		 * 00 - ADDR_CONFIG_PIPE_INTERLEAVE_256B: 256 byte
+		 * interleave
+		 * 01 - ADDR_CONFIG_PIPE_INTERLEAVE_512B: 512 byte
+		 * interleave
+		 */
+		switch (cp110->base.channel_interleave_size) {
+		case 256: /*256B */
+			set_reg_field_value(
+				lpt_control,
+				0,
+				LOW_POWER_TILING_CONTROL,
+				LOW_POWER_TILING_PIPE_INTERLEAVE_SIZE);
+			break;
+		case 512: /*512B */
+			set_reg_field_value(
+				lpt_control,
+				1,
+				LOW_POWER_TILING_CONTROL,
+				LOW_POWER_TILING_PIPE_INTERLEAVE_SIZE);
+			break;
+		default:
+			dm_logger_write(
+				cp110->base.ctx->logger, LOG_WARNING,
+				"%s: Invalid LPT INTERLEAVE_SIZE!!!",
+				__func__);
+			break;
+		}
+
+		/* The mapping for LOW_POWER_TILING_ROW_SIZE is in
+		 * DMIF_ADDR_CALC.ADDR_CONFIG_ROW_SIZE register field
+		 * for Carrizo. Specifies the size of dram row in bytes.
+		 * This should match up with NOOFCOLS field in
+		 * MC_ARB_RAMCFG (ROW_SIZE = 4 * 2 ^^ columns).
+		 * This register DMIF_ADDR_CALC is not used by the
+		 * hardware as it is only used for addrlib assertions.
+		 * POSSIBLE VALUES:
+		 * 00 - ADDR_CONFIG_1KB_ROW: Treat 1KB as DRAM row
+		 * boundary
+		 * 01 - ADDR_CONFIG_2KB_ROW: Treat 2KB as DRAM row
+		 * boundary
+		 * 02 - ADDR_CONFIG_4KB_ROW: Treat 4KB as DRAM row
+		 * boundary */
+		switch (cp110->base.raw_size) {
+		case 4096: /*4 KB */
+			set_reg_field_value(
+				lpt_control,
+				2,
+				LOW_POWER_TILING_CONTROL,
+				LOW_POWER_TILING_ROW_SIZE);
+			break;
+		case 2048:
+			set_reg_field_value(
+				lpt_control,
+				1,
+				LOW_POWER_TILING_CONTROL,
+				LOW_POWER_TILING_ROW_SIZE);
+			break;
+		case 1024:
+			set_reg_field_value(
+				lpt_control,
+				0,
+				LOW_POWER_TILING_CONTROL,
+				LOW_POWER_TILING_ROW_SIZE);
+			break;
+		default:
+			dm_logger_write(
+				cp110->base.ctx->logger, LOG_WARNING,
+				"%s: Invalid LPT ROW_SIZE!!!",
+				__func__);
+			break;
+		}
+	} else {
+		dm_logger_write(
+			cp110->base.ctx->logger, LOG_WARNING,
+			"%s: LPT MC Configuration is not provided",
+			__func__);
+	}
+
+	return lpt_control;
+}
+
+static bool is_source_bigger_than_epanel_size(
+	struct dce110_compressor *cp110,
+	uint32_t source_view_width,
+	uint32_t source_view_height)
+{
+	if (cp110->base.embedded_panel_h_size != 0 &&
+		cp110->base.embedded_panel_v_size != 0 &&
+		((source_view_width * source_view_height) >
+		(cp110->base.embedded_panel_h_size *
+			cp110->base.embedded_panel_v_size)))
+		return true;
+
+	return false;
+}
+
+static uint32_t align_to_chunks_number_per_line(
+	struct dce110_compressor *cp110,
+	uint32_t pixels)
+{
+	return 256 * ((pixels + 255) / 256);
+}
+
+static void wait_for_fbc_state_changed(
+	struct dce110_compressor *cp110,
+	bool enabled)
+{
+	uint8_t counter = 0;
+	uint32_t addr = mmFBC_STATUS;
+	uint32_t value;
+
+	while (counter < 10) {
+		value = dm_read_reg(cp110->base.ctx, addr);
+		if (get_reg_field_value(
+			value,
+			FBC_STATUS,
+			FBC_ENABLE_STATUS) == enabled)
+			break;
+		udelay(10);
+		counter++;
+	}
+
+	if (counter == 10) {
+		dm_logger_write(
+			cp110->base.ctx->logger, LOG_WARNING,
+			"%s: wait counter exceeded, changes to HW not applied",
+			__func__);
+	}
+}
+
+void dce110_compressor_power_up_fbc(struct compressor *compressor)
+{
+	uint32_t value;
+	uint32_t addr;
+
+	addr = mmFBC_CNTL;
+	value = dm_read_reg(compressor->ctx, addr);
+	set_reg_field_value(value, 0, FBC_CNTL, FBC_GRPH_COMP_EN);
+	set_reg_field_value(value, 1, FBC_CNTL, FBC_EN);
+	set_reg_field_value(value, 2, FBC_CNTL, FBC_COHERENCY_MODE);
+	if (compressor->options.bits.CLK_GATING_DISABLED == 1) {
+		/* HW needs to do power measurement comparison. */
+		set_reg_field_value(
+			value,
+			0,
+			FBC_CNTL,
+			FBC_COMP_CLK_GATE_EN);
+	}
+	dm_write_reg(compressor->ctx, addr, value);
+
+	addr = mmFBC_COMP_MODE;
+	value = dm_read_reg(compressor->ctx, addr);
+	set_reg_field_value(value, 1, FBC_COMP_MODE, FBC_RLE_EN);
+	set_reg_field_value(value, 1, FBC_COMP_MODE, FBC_DPCM4_RGB_EN);
+	set_reg_field_value(value, 1, FBC_COMP_MODE, FBC_IND_EN);
+	dm_write_reg(compressor->ctx, addr, value);
+
+	addr = mmFBC_COMP_CNTL;
+	value = dm_read_reg(compressor->ctx, addr);
+	set_reg_field_value(value, 1, FBC_COMP_CNTL, FBC_DEPTH_RGB08_EN);
+	dm_write_reg(compressor->ctx, addr, value);
+	/*FBC_MIN_COMPRESSION 0 ==> 2:1 */
+	/*                    1 ==> 4:1 */
+	/*                    2 ==> 8:1 */
+	/*                  0xF ==> 1:1 */
+	set_reg_field_value(value, 0xF, FBC_COMP_CNTL, FBC_MIN_COMPRESSION);
+	dm_write_reg(compressor->ctx, addr, value);
+	compressor->min_compress_ratio = FBC_COMPRESS_RATIO_1TO1;
+
+	value = 0;
+	dm_write_reg(compressor->ctx, mmFBC_IND_LUT0, value);
+
+	value = 0xFFFFFF;
+	dm_write_reg(compressor->ctx, mmFBC_IND_LUT1, value);
+}
+
+void dce110_compressor_enable_fbc(
+	struct compressor *compressor,
+	uint32_t paths_num,
+	struct compr_addr_and_pitch_params *params)
+{
+	struct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);
+
+	if (compressor->options.bits.FBC_SUPPORT &&
+		(compressor->options.bits.DUMMY_BACKEND == 0) &&
+		(!dce110_compressor_is_fbc_enabled_in_hw(compressor, NULL)) &&
+		(!is_source_bigger_than_epanel_size(
+			cp110,
+			params->source_view_width,
+			params->source_view_height))) {
+
+		uint32_t addr;
+		uint32_t value;
+
+		/* Before enabling FBC first need to enable LPT if applicable
+		 * LPT state should always be changed (enable/disable) while FBC
+		 * is disabled */
+		if (compressor->options.bits.LPT_SUPPORT && (paths_num < 2) &&
+			(params->source_view_width *
+				params->source_view_height <=
+				dce11_one_lpt_channel_max_resolution)) {
+			dce110_compressor_enable_lpt(compressor);
+		}
+
+		addr = mmFBC_CNTL;
+		value = dm_read_reg(compressor->ctx, addr);
+		set_reg_field_value(value, 1, FBC_CNTL, FBC_GRPH_COMP_EN);
+		set_reg_field_value(
+			value,
+			params->inst,
+			FBC_CNTL, FBC_SRC_SEL);
+		dm_write_reg(compressor->ctx, addr, value);
+
+		/* Keep track of enum controller_id FBC is attached to */
+		compressor->is_enabled = true;
+		compressor->attached_inst = params->inst;
+		cp110->offsets = reg_offsets[params->inst - 1];
+
+		/*Toggle it as there is bug in HW */
+		set_reg_field_value(value, 0, FBC_CNTL, FBC_GRPH_COMP_EN);
+		dm_write_reg(compressor->ctx, addr, value);
+		set_reg_field_value(value, 1, FBC_CNTL, FBC_GRPH_COMP_EN);
+		dm_write_reg(compressor->ctx, addr, value);
+
+		wait_for_fbc_state_changed(cp110, true);
+	}
+}
+
+void dce110_compressor_disable_fbc(struct compressor *compressor)
+{
+	struct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);
+
+	if (compressor->options.bits.FBC_SUPPORT &&
+		dce110_compressor_is_fbc_enabled_in_hw(compressor, NULL)) {
+		uint32_t reg_data;
+		/* Turn off compression */
+		reg_data = dm_read_reg(compressor->ctx, mmFBC_CNTL);
+		set_reg_field_value(reg_data, 0, FBC_CNTL, FBC_GRPH_COMP_EN);
+		dm_write_reg(compressor->ctx, mmFBC_CNTL, reg_data);
+
+		/* Reset enum controller_id to undefined */
+		compressor->attached_inst = 0;
+		compressor->is_enabled = false;
+
+		/* Whenever disabling FBC make sure LPT is disabled if LPT
+		 * supported */
+		if (compressor->options.bits.LPT_SUPPORT)
+			dce110_compressor_disable_lpt(compressor);
+
+		wait_for_fbc_state_changed(cp110, false);
+	}
+}
+
+bool dce110_compressor_is_fbc_enabled_in_hw(
+	struct compressor *compressor,
+	uint32_t *inst)
+{
+	/* Check the hardware register */
+	uint32_t value;
+
+	value = dm_read_reg(compressor->ctx, mmFBC_STATUS);
+	if (get_reg_field_value(value, FBC_STATUS, FBC_ENABLE_STATUS)) {
+		if (inst != NULL)
+			*inst = compressor->attached_inst;
+		return true;
+	}
+
+	value = dm_read_reg(compressor->ctx, mmFBC_MISC);
+	if (get_reg_field_value(value, FBC_MISC, FBC_STOP_ON_HFLIP_EVENT)) {
+		value = dm_read_reg(compressor->ctx, mmFBC_CNTL);
+
+		if (get_reg_field_value(value, FBC_CNTL, FBC_GRPH_COMP_EN)) {
+			if (inst != NULL)
+				*inst =
+					compressor->attached_inst;
+			return true;
+		}
+	}
+	return false;
+}
+
+bool dce110_compressor_is_lpt_enabled_in_hw(struct compressor *compressor)
+{
+	/* Check the hardware register */
+	uint32_t value = dm_read_reg(compressor->ctx,
+		mmLOW_POWER_TILING_CONTROL);
+
+	return get_reg_field_value(
+		value,
+		LOW_POWER_TILING_CONTROL,
+		LOW_POWER_TILING_ENABLE);
+}
+
+void dce110_compressor_program_compressed_surface_address_and_pitch(
+	struct compressor *compressor,
+	struct compr_addr_and_pitch_params *params)
+{
+	struct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);
+	uint32_t value = 0;
+	uint32_t fbc_pitch = 0;
+	uint32_t compressed_surf_address_low_part =
+		compressor->compr_surface_address.addr.low_part;
+
+	/* Clear content first. */
+	dm_write_reg(
+		compressor->ctx,
+		DCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS_HIGH),
+		0);
+	dm_write_reg(compressor->ctx,
+		DCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS), 0);
+
+	if (compressor->options.bits.LPT_SUPPORT) {
+		uint32_t lpt_alignment = lpt_size_alignment(cp110);
+
+		if (lpt_alignment != 0) {
+			compressed_surf_address_low_part =
+				((compressed_surf_address_low_part
+					+ (lpt_alignment - 1)) / lpt_alignment)
+					* lpt_alignment;
+		}
+	}
+
+	/* Write address, HIGH has to be first. */
+	dm_write_reg(compressor->ctx,
+		DCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS_HIGH),
+		compressor->compr_surface_address.addr.high_part);
+	dm_write_reg(compressor->ctx,
+		DCP_REG(mmGRPH_COMPRESS_SURFACE_ADDRESS),
+		compressed_surf_address_low_part);
+
+	fbc_pitch = align_to_chunks_number_per_line(
+		cp110,
+		params->source_view_width);
+
+	if (compressor->min_compress_ratio == FBC_COMPRESS_RATIO_1TO1)
+		fbc_pitch = fbc_pitch / 8;
+	else
+		dm_logger_write(
+			compressor->ctx->logger, LOG_WARNING,
+			"%s: Unexpected DCE11 compression ratio",
+			__func__);
+
+	/* Clear content first. */
+	dm_write_reg(compressor->ctx, DCP_REG(mmGRPH_COMPRESS_PITCH), 0);
+
+	/* Write FBC Pitch. */
+	set_reg_field_value(
+		value,
+		fbc_pitch,
+		GRPH_COMPRESS_PITCH,
+		GRPH_COMPRESS_PITCH);
+	dm_write_reg(compressor->ctx, DCP_REG(mmGRPH_COMPRESS_PITCH), value);
+
+}
+
+void dce110_compressor_disable_lpt(struct compressor *compressor)
+{
+	struct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);
+	uint32_t value;
+	uint32_t addr;
+	uint32_t inx;
+
+	/* Disable all pipes LPT Stutter */
+	for (inx = 0; inx < 3; inx++) {
+		value =
+			dm_read_reg(
+				compressor->ctx,
+				DMIF_REG(mmDPG_PIPE_STUTTER_CONTROL_NONLPTCH));
+		set_reg_field_value(
+			value,
+			0,
+			DPG_PIPE_STUTTER_CONTROL_NONLPTCH,
+			STUTTER_ENABLE_NONLPTCH);
+		dm_write_reg(
+			compressor->ctx,
+			DMIF_REG(mmDPG_PIPE_STUTTER_CONTROL_NONLPTCH),
+			value);
+	}
+	/* Disable Underlay pipe LPT Stutter */
+	addr = mmDPGV0_PIPE_STUTTER_CONTROL_NONLPTCH;
+	value = dm_read_reg(compressor->ctx, addr);
+	set_reg_field_value(
+		value,
+		0,
+		DPGV0_PIPE_STUTTER_CONTROL_NONLPTCH,
+		STUTTER_ENABLE_NONLPTCH);
+	dm_write_reg(compressor->ctx, addr, value);
+
+	/* Disable LPT */
+	addr = mmLOW_POWER_TILING_CONTROL;
+	value = dm_read_reg(compressor->ctx, addr);
+	set_reg_field_value(
+		value,
+		0,
+		LOW_POWER_TILING_CONTROL,
+		LOW_POWER_TILING_ENABLE);
+	dm_write_reg(compressor->ctx, addr, value);
+
+	/* Clear selection of Channel(s) containing Compressed Surface */
+	addr = mmGMCON_LPT_TARGET;
+	value = dm_read_reg(compressor->ctx, addr);
+	set_reg_field_value(
+		value,
+		0xFFFFFFFF,
+		GMCON_LPT_TARGET,
+		STCTRL_LPT_TARGET);
+	dm_write_reg(compressor->ctx, mmGMCON_LPT_TARGET, value);
+}
+
+void dce110_compressor_enable_lpt(struct compressor *compressor)
+{
+	struct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);
+	uint32_t value;
+	uint32_t addr;
+	uint32_t value_control;
+	uint32_t channels;
+
+	/* Enable LPT Stutter from Display pipe */
+	value = dm_read_reg(compressor->ctx,
+		DMIF_REG(mmDPG_PIPE_STUTTER_CONTROL_NONLPTCH));
+	set_reg_field_value(
+		value,
+		1,
+		DPG_PIPE_STUTTER_CONTROL_NONLPTCH,
+		STUTTER_ENABLE_NONLPTCH);
+	dm_write_reg(compressor->ctx,
+		DMIF_REG(mmDPG_PIPE_STUTTER_CONTROL_NONLPTCH), value);
+
+	/* Enable Underlay pipe LPT Stutter */
+	addr = mmDPGV0_PIPE_STUTTER_CONTROL_NONLPTCH;
+	value = dm_read_reg(compressor->ctx, addr);
+	set_reg_field_value(
+		value,
+		1,
+		DPGV0_PIPE_STUTTER_CONTROL_NONLPTCH,
+		STUTTER_ENABLE_NONLPTCH);
+	dm_write_reg(compressor->ctx, addr, value);
+
+	/* Selection of Channel(s) containing Compressed Surface: 0xfffffff
+	 * will disable LPT.
+	 * STCTRL_LPT_TARGETn corresponds to channel n. */
+	addr = mmLOW_POWER_TILING_CONTROL;
+	value_control = dm_read_reg(compressor->ctx, addr);
+	channels = get_reg_field_value(value_control,
+			LOW_POWER_TILING_CONTROL,
+			LOW_POWER_TILING_MODE);
+
+	addr = mmGMCON_LPT_TARGET;
+	value = dm_read_reg(compressor->ctx, addr);
+	set_reg_field_value(
+		value,
+		channels + 1, /* not mentioned in programming guide,
+				but follow DCE8.1 */
+		GMCON_LPT_TARGET,
+		STCTRL_LPT_TARGET);
+	dm_write_reg(compressor->ctx, addr, value);
+
+	/* Enable LPT */
+	addr = mmLOW_POWER_TILING_CONTROL;
+	value = dm_read_reg(compressor->ctx, addr);
+	set_reg_field_value(
+		value,
+		1,
+		LOW_POWER_TILING_CONTROL,
+		LOW_POWER_TILING_ENABLE);
+	dm_write_reg(compressor->ctx, addr, value);
+}
+
+void dce110_compressor_program_lpt_control(
+	struct compressor *compressor,
+	struct compr_addr_and_pitch_params *params)
+{
+	struct dce110_compressor *cp110 = TO_DCE110_COMPRESSOR(compressor);
+	uint32_t rows_per_channel;
+	uint32_t lpt_alignment;
+	uint32_t source_view_width;
+	uint32_t source_view_height;
+	uint32_t lpt_control = 0;
+
+	if (!compressor->options.bits.LPT_SUPPORT)
+		return;
+
+	lpt_control = dm_read_reg(compressor->ctx,
+		mmLOW_POWER_TILING_CONTROL);
+
+	/* POSSIBLE VALUES for Low Power Tiling Mode:
+	 * 00 - Use channel 0
+	 * 01 - Use Channel 0 and 1
+	 * 02 - Use Channel 0,1,2,3
+	 * 03 - reserved */
+	switch (compressor->lpt_channels_num) {
+	/* case 2:
+	 * Use Channel 0 & 1 / Not used for DCE 11 */
+	case 1:
+		/*Use Channel 0 for LPT for DCE 11 */
+		set_reg_field_value(
+			lpt_control,
+			0,
+			LOW_POWER_TILING_CONTROL,
+			LOW_POWER_TILING_MODE);
+		break;
+	default:
+		dm_logger_write(
+			compressor->ctx->logger, LOG_WARNING,
+			"%s: Invalid selected DRAM channels for LPT!!!",
+			__func__);
+		break;
+	}
+
+	lpt_control = lpt_memory_control_config(cp110, lpt_control);
+
+	/* Program LOW_POWER_TILING_ROWS_PER_CHAN field which depends on
+	 * FBC compressed surface pitch.
+	 * LOW_POWER_TILING_ROWS_PER_CHAN = Roundup ((Surface Height *
+	 * Surface Pitch) / (Row Size * Number of Channels *
+	 * Number of Banks)). */
+	rows_per_channel = 0;
+	lpt_alignment = lpt_size_alignment(cp110);
+	source_view_width =
+		align_to_chunks_number_per_line(
+			cp110,
+			params->source_view_width);
+	source_view_height = (params->source_view_height + 1) & (~0x1);
+
+	if (lpt_alignment != 0) {
+		rows_per_channel = source_view_width * source_view_height * 4;
+		rows_per_channel =
+			(rows_per_channel % lpt_alignment) ?
+				(rows_per_channel / lpt_alignment + 1) :
+				rows_per_channel / lpt_alignment;
+	}
+
+	set_reg_field_value(
+		lpt_control,
+		rows_per_channel,
+		LOW_POWER_TILING_CONTROL,
+		LOW_POWER_TILING_ROWS_PER_CHAN);
+
+	dm_write_reg(compressor->ctx,
+		mmLOW_POWER_TILING_CONTROL, lpt_control);
+}
+
+/*
+ * DCE 11 Frame Buffer Compression Implementation
+ */
+
+void dce110_compressor_set_fbc_invalidation_triggers(
+	struct compressor *compressor,
+	uint32_t fbc_trigger)
+{
+	/* Disable region hit event, FBC_MEMORY_REGION_MASK = 0 (bits 16-19)
+	 * for DCE 11 regions cannot be used - does not work with S/G
+	 */
+	uint32_t addr = mmFBC_CLIENT_REGION_MASK;
+	uint32_t value = dm_read_reg(compressor->ctx, addr);
+
+	set_reg_field_value(
+		value,
+		0,
+		FBC_CLIENT_REGION_MASK,
+		FBC_MEMORY_REGION_MASK);
+	dm_write_reg(compressor->ctx, addr, value);
+
+	/* Setup events when to clear all CSM entries (effectively marking
+	 * current compressed data invalid)
+	 * For DCE 11 CSM metadata 11111 means - "Not Compressed"
+	 * Used as the initial value of the metadata sent to the compressor
+	 * after invalidation, to indicate that the compressor should attempt
+	 * to compress all chunks on the current pass.  Also used when the chunk
+	 * is not successfully written to memory.
+	 * When this CSM value is detected, FBC reads from the uncompressed
+	 * buffer. Set events according to passed in value, these events are
+	 * valid for DCE11:
+	 *     - bit  0 - display register updated
+	 *     - bit 28 - memory write from any client except from MCIF
+	 *     - bit 29 - CG static screen signal is inactive
+	 * In addition, DCE11.1 also needs to set new DCE11.1 specific events
+	 * that are used to trigger invalidation on certain register changes,
+	 * for example enabling of Alpha Compression may trigger invalidation of
+	 * FBC once bit is set. These events are as follows:
+	 *      - Bit 2 - FBC_GRPH_COMP_EN register updated
+	 *      - Bit 3 - FBC_SRC_SEL register updated
+	 *      - Bit 4 - FBC_MIN_COMPRESSION register updated
+	 *      - Bit 5 - FBC_ALPHA_COMP_EN register updated
+	 *      - Bit 6 - FBC_ZERO_ALPHA_CHUNK_SKIP_EN register updated
+	 *      - Bit 7 - FBC_FORCE_COPY_TO_COMP_BUF register updated
+	 */
+	addr = mmFBC_IDLE_FORCE_CLEAR_MASK;
+	value = dm_read_reg(compressor->ctx, addr);
+	set_reg_field_value(
+		value,
+		fbc_trigger |
+		FBC_IDLE_FORCE_GRPH_COMP_EN |
+		FBC_IDLE_FORCE_SRC_SEL_CHANGE |
+		FBC_IDLE_FORCE_MIN_COMPRESSION_CHANGE |
+		FBC_IDLE_FORCE_ALPHA_COMP_EN |
+		FBC_IDLE_FORCE_ZERO_ALPHA_CHUNK_SKIP_EN |
+		FBC_IDLE_FORCE_FORCE_COPY_TO_COMP_BUF,
+		FBC_IDLE_FORCE_CLEAR_MASK,
+		FBC_IDLE_FORCE_CLEAR_MASK);
+	dm_write_reg(compressor->ctx, addr, value);
+}
+
+bool dce110_compressor_construct(struct dce110_compressor *compressor,
+	struct dc_context *ctx)
+{
+	struct dc_bios *bp = ctx->dc_bios;
+	struct embedded_panel_info panel_info;
+
+	compressor->base.options.bits.FBC_SUPPORT = true;
+	compressor->base.options.bits.LPT_SUPPORT = true;
+	 /* For DCE 11 always use one DRAM channel for LPT */
+	compressor->base.lpt_channels_num = 1;
+	compressor->base.options.bits.DUMMY_BACKEND = false;
+
+	/* Check if this system has more than 1 DRAM channel; if only 1 then LPT
+	 * should not be supported */
+	if (compressor->base.memory_bus_width == 64)
+		compressor->base.options.bits.LPT_SUPPORT = false;
+
+	compressor->base.options.bits.CLK_GATING_DISABLED = false;
+
+	compressor->base.ctx = ctx;
+	compressor->base.embedded_panel_h_size = 0;
+	compressor->base.embedded_panel_v_size = 0;
+	compressor->base.memory_bus_width = ctx->asic_id.vram_width;
+	compressor->base.allocated_size = 0;
+	compressor->base.preferred_requested_size = 0;
+	compressor->base.min_compress_ratio = FBC_COMPRESS_RATIO_INVALID;
+	compressor->base.options.raw = 0;
+	compressor->base.banks_num = 0;
+	compressor->base.raw_size = 0;
+	compressor->base.channel_interleave_size = 0;
+	compressor->base.dram_channels_num = 0;
+	compressor->base.lpt_channels_num = 0;
+	compressor->base.attached_inst = 0;
+	compressor->base.is_enabled = false;
+
+	if (BP_RESULT_OK ==
+			bp->funcs->get_embedded_panel_info(bp, &panel_info)) {
+		compressor->base.embedded_panel_h_size =
+			panel_info.lcd_timing.horizontal_addressable;
+		compressor->base.embedded_panel_v_size =
+			panel_info.lcd_timing.vertical_addressable;
+	}
+	return true;
+}
+
+struct compressor *dce110_compressor_create(struct dc_context *ctx)
+{
+	struct dce110_compressor *cp110 =
+		dm_alloc(sizeof(struct dce110_compressor));
+
+	if (!cp110)
+		return NULL;
+
+	if (dce110_compressor_construct(cp110, ctx))
+		return &cp110->base;
+
+	BREAK_TO_DEBUGGER();
+	dm_free(cp110);
+	return NULL;
+}
+
+void dce110_compressor_destroy(struct compressor **compressor)
+{
+	dm_free(TO_DCE110_COMPRESSOR(*compressor));
+	*compressor = NULL;
+}
