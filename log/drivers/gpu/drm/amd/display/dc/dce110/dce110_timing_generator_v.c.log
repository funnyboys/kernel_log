commit e7e10c464a481e9e94ae571f849d09c8820f1fdb
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Apr 8 15:49:52 2019 -0400

    drm/amd/display: stop external access to internal optc sync params
    
    These are internal otg params and should be handled as such.
    Thich change passes the params as function arguments.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
index a3cef60380ed..a13a2f58944e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
@@ -435,6 +435,11 @@ static void dce110_timing_generator_v_set_blank(struct timing_generator *tg,
 
 static void dce110_timing_generator_v_program_timing(struct timing_generator *tg,
 	const struct dc_crtc_timing *timing,
+	int vready_offset,
+	int vstartup_start,
+	int vupdate_offset,
+	int vupdate_width,
+	const enum signal_type signal,
 	bool use_vbios)
 {
 	if (use_vbios)

commit d6014e776ceb5da2d86ce405f692522f2b0370f2
Author: Shirish S <shirish.s@amd.com>
Date:   Wed Mar 28 12:22:22 2018 +0530

    drm/amd/display: remove dummy is_blanked() to optimise boot time
    
    is_blanked() hook is a dummy one for underlay pipe, hence
    when called, it loops for ~300ms at boot.
    
    This patch removes this dummy call and adds missing checks.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
index 8ad04816e7d3..a3cef60380ed 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
@@ -648,12 +648,6 @@ static void dce110_timing_generator_v_disable_vga(
 	return;
 }
 
-static bool dce110_tg_v_is_blanked(struct timing_generator *tg)
-{
-	/* Signal comes from the primary pipe, underlay is never blanked. */
-	return false;
-}
-
 /** ********************************************************************************************
  *
  * DCE11 Timing Generator Constructor / Destructor
@@ -670,7 +664,6 @@ static const struct timing_generator_funcs dce110_tg_v_funcs = {
 		.set_early_control = dce110_timing_generator_v_set_early_control,
 		.wait_for_state = dce110_timing_generator_v_wait_for_state,
 		.set_blank = dce110_timing_generator_v_set_blank,
-		.is_blanked = dce110_tg_v_is_blanked,
 		.set_colors = dce110_timing_generator_v_set_colors,
 		.set_overscan_blank_color =
 				dce110_timing_generator_v_set_overscan_color_black,

commit 1296423bf23c7a58133970e223b1f47ec6570308
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Feb 20 17:42:50 2018 -0500

    drm/amd/display: define DC_LOGGER for logger
    
    Created a DC_LOGGER define. This is used to
    pass the logger into the macros.
    
    Anywhere we need to use the logger we need to define
    DC_LOGGER
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
index a8e93072ab5c..8ad04816e7d3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
@@ -38,6 +38,8 @@
 
 #include "timing_generator.h"
 
+#define DC_LOGGER \
+	tg->ctx->logger
 /** ********************************************************************************
  *
  * DCE11 Timing Generator Implementation
@@ -606,8 +608,7 @@ static uint32_t dce110_timing_generator_v_get_vblank_counter(struct timing_gener
 static bool dce110_timing_generator_v_did_triggered_reset_occur(
 	struct timing_generator *tg)
 {
-	DC_LOG_ERROR(tg->ctx->logger,
-					"Timing Sync not supported on underlay pipe\n");
+	DC_LOG_ERROR("Timing Sync not supported on underlay pipe\n");
 	return false;
 }
 
@@ -615,8 +616,7 @@ static void dce110_timing_generator_v_setup_global_swap_lock(
 	struct timing_generator *tg,
 	const struct dcp_gsl_params *gsl_params)
 {
-	DC_LOG_ERROR(tg->ctx->logger,
-					"Timing Sync not supported on underlay pipe\n");
+	DC_LOG_ERROR("Timing Sync not supported on underlay pipe\n");
 	return;
 }
 
@@ -624,24 +624,21 @@ static void dce110_timing_generator_v_enable_reset_trigger(
 	struct timing_generator *tg,
 	int source_tg_inst)
 {
-	DC_LOG_ERROR(tg->ctx->logger,
-					"Timing Sync not supported on underlay pipe\n");
+	DC_LOG_ERROR("Timing Sync not supported on underlay pipe\n");
 	return;
 }
 
 static void dce110_timing_generator_v_disable_reset_trigger(
 	struct timing_generator *tg)
 {
-	DC_LOG_ERROR(tg->ctx->logger,
-						"Timing Sync not supported on underlay pipe\n");
+	DC_LOG_ERROR("Timing Sync not supported on underlay pipe\n");
 	return;
 }
 
 static void dce110_timing_generator_v_tear_down_global_swap_lock(
 	struct timing_generator *tg)
 {
-	DC_LOG_ERROR(tg->ctx->logger,
-						"Timing Sync not supported on underlay pipe\n");
+	DC_LOG_ERROR("Timing Sync not supported on underlay pipe\n");
 	return;
 }
 

commit 2f3fd67a8af25f5b4d549c3e9cc515dbf1839ffc
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Fri Feb 16 13:57:42 2018 -0500

    drm/amd/display: Use MACROS instead of dm_logger
    
    Created MACROS for all log levels. Also Replaced
    usage of dm_logger_write to the defined MACROS
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
index 59b4cd329715..a8e93072ab5c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
@@ -606,7 +606,7 @@ static uint32_t dce110_timing_generator_v_get_vblank_counter(struct timing_gener
 static bool dce110_timing_generator_v_did_triggered_reset_occur(
 	struct timing_generator *tg)
 {
-	dm_logger_write(tg->ctx->logger, LOG_ERROR,
+	DC_LOG_ERROR(tg->ctx->logger,
 					"Timing Sync not supported on underlay pipe\n");
 	return false;
 }
@@ -615,7 +615,7 @@ static void dce110_timing_generator_v_setup_global_swap_lock(
 	struct timing_generator *tg,
 	const struct dcp_gsl_params *gsl_params)
 {
-	dm_logger_write(tg->ctx->logger, LOG_ERROR,
+	DC_LOG_ERROR(tg->ctx->logger,
 					"Timing Sync not supported on underlay pipe\n");
 	return;
 }
@@ -624,7 +624,7 @@ static void dce110_timing_generator_v_enable_reset_trigger(
 	struct timing_generator *tg,
 	int source_tg_inst)
 {
-	dm_logger_write(tg->ctx->logger, LOG_ERROR,
+	DC_LOG_ERROR(tg->ctx->logger,
 					"Timing Sync not supported on underlay pipe\n");
 	return;
 }
@@ -632,7 +632,7 @@ static void dce110_timing_generator_v_enable_reset_trigger(
 static void dce110_timing_generator_v_disable_reset_trigger(
 	struct timing_generator *tg)
 {
-	dm_logger_write(tg->ctx->logger, LOG_ERROR,
+	DC_LOG_ERROR(tg->ctx->logger,
 						"Timing Sync not supported on underlay pipe\n");
 	return;
 }
@@ -640,7 +640,7 @@ static void dce110_timing_generator_v_disable_reset_trigger(
 static void dce110_timing_generator_v_tear_down_global_swap_lock(
 	struct timing_generator *tg)
 {
-	dm_logger_write(tg->ctx->logger, LOG_ERROR,
+	DC_LOG_ERROR(tg->ctx->logger,
 						"Timing Sync not supported on underlay pipe\n");
 	return;
 }

commit bf93b448b80bf71c2003659b06487879153b8b9b
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Nov 30 21:29:47 2017 -0500

    drm/amdgpu: add license to files where it was missing
    
    These files were missing it before.
    
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
    Acked-by: Christian KÃ¶nig <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
index 07d9303d5477..59b4cd329715 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
@@ -1,3 +1,26 @@
+/*
+ * Copyright 2017 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
 #include "dm_services.h"
 
 /* include DCE11 register header files */

commit c13b408b81f8a101501d78ca499afee98e0f0ab9
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 14:34:39 2017 +1000

    amdgpu/dc: another round of dce/dcn construct cleanups.
    
    This removes any remaining pointless return codepaths from the
    DCE code.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
index 93ca6ae48cb9..07d9303d5477 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
@@ -668,13 +668,10 @@ static const struct timing_generator_funcs dce110_tg_v_funcs = {
 				dce110_timing_generator_v_enable_advanced_request
 };
 
-bool dce110_timing_generator_v_construct(
+void dce110_timing_generator_v_construct(
 	struct dce110_timing_generator *tg110,
 	struct dc_context *ctx)
 {
-	if (!tg110)
-		return false;
-
 	tg110->controller_id = CONTROLLER_ID_UNDERLAY0;
 
 	tg110->base.funcs = &dce110_tg_v_funcs;
@@ -688,6 +685,4 @@ bool dce110_timing_generator_v_construct(
 	tg110->min_h_blank = 56;
 	tg110->min_h_front_porch = 4;
 	tg110->min_h_back_porch = 4;
-
-	return true;
 }

commit aed8b319180f18402ed90929f85e2b3e5b81e71d
Author: Shirish S <shirish.s@amd.com>
Date:   Thu Jun 8 11:55:06 2017 +0530

    drm/amd/display: remove get_position() of underlay
    
    get_position() returns CRTC vertical/horizontal counters,
    hence it is not applicable for underlay which is plane and not
    attached to one crtc.
    This patch hence removes the callback from dce110_tg_v_funcs
    and hence fixes a bug in dc_debug.c where in
    get_position() for underlay pipe is called un-conditionally.
    
    Witout this patch get_position() is called in case one has
    to update underlay plane's data,
    since callback implmented with an ASSERT(),
    the old_surface_count and new_surface_count mismatches; causing
    only one plane update which is not right and also assert makes the
    rendering slow.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
index 759c55bb4d15..93ca6ae48cb9 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
@@ -570,13 +570,6 @@ static void dce110_timing_generator_v_set_early_control(
 	dm_write_reg(tg->ctx, address, regval);
 }
 
-static void dce110_timing_generator_get_underlay_position(struct timing_generator *tg,
-	struct crtc_position *position)
-{
-	//Should never hit this case
-	ASSERT(false);
-}
-
 static uint32_t dce110_timing_generator_v_get_vblank_counter(struct timing_generator *tg)
 {
 	uint32_t addr = mmCRTCV_STATUS_FRAME_COUNT;
@@ -652,7 +645,7 @@ static const struct timing_generator_funcs dce110_tg_v_funcs = {
 		.enable_crtc = dce110_timing_generator_v_enable_crtc,
 		.disable_crtc = dce110_timing_generator_v_disable_crtc,
 		.is_counter_moving = dce110_timing_generator_v_is_counter_moving,
-		.get_position = dce110_timing_generator_get_underlay_position,
+		.get_position = NULL, /* Not to be implemented for underlay*/
 		.get_frame_count = dce110_timing_generator_v_get_vblank_counter,
 		.set_early_control = dce110_timing_generator_v_set_early_control,
 		.wait_for_state = dce110_timing_generator_v_wait_for_state,

commit 72ada5f76939ed00c07c584be7691a29d3c2c3da
Author: Eric Cook <Eric.Cook@amd.com>
Date:   Tue Apr 18 15:24:50 2017 -0400

    drm/amd/display: FreeSync Auto Sweep Support
    
    Implement core support to allow for FreeSync Auto Sweep to work
    
    Signed-off-by: Eric Cook <Eric.Cook@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
index c95b69446ced..759c55bb4d15 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
@@ -570,24 +570,11 @@ static void dce110_timing_generator_v_set_early_control(
 	dm_write_reg(tg->ctx, address, regval);
 }
 
-static void dce110_timing_generator_v_get_crtc_positions(
-	struct timing_generator *tg,
-	int32_t *h_position,
-	int32_t *v_position)
+static void dce110_timing_generator_get_underlay_position(struct timing_generator *tg,
+	struct crtc_position *position)
 {
-	uint32_t value;
-
-	value = dm_read_reg(tg->ctx, mmCRTCV_STATUS_POSITION);
-
-	*h_position = get_reg_field_value(
-			value,
-			CRTCV_STATUS_POSITION,
-			CRTC_HORZ_COUNT);
-
-	*v_position = get_reg_field_value(
-			value,
-			CRTCV_STATUS_POSITION,
-			CRTC_VERT_COUNT);
+	//Should never hit this case
+	ASSERT(false);
 }
 
 static uint32_t dce110_timing_generator_v_get_vblank_counter(struct timing_generator *tg)
@@ -665,7 +652,7 @@ static const struct timing_generator_funcs dce110_tg_v_funcs = {
 		.enable_crtc = dce110_timing_generator_v_enable_crtc,
 		.disable_crtc = dce110_timing_generator_v_disable_crtc,
 		.is_counter_moving = dce110_timing_generator_v_is_counter_moving,
-		.get_position = dce110_timing_generator_v_get_crtc_positions,
+		.get_position = dce110_timing_generator_get_underlay_position,
 		.get_frame_count = dce110_timing_generator_v_get_vblank_counter,
 		.set_early_control = dce110_timing_generator_v_set_early_control,
 		.wait_for_state = dce110_timing_generator_v_wait_for_state,

commit 648013696767f0266aa7bd44407786a99f7a7910
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Feb 24 11:31:23 2017 -0500

    drm/amd/display: Fix warnings in DC
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
index 682a3de7ba48..c95b69446ced 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
@@ -74,7 +74,6 @@ static bool dce110_timing_generator_v_disable_crtc(struct timing_generator *tg)
 
 static void dce110_timing_generator_v_blank_crtc(struct timing_generator *tg)
 {
-	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 	uint32_t addr = mmCRTCV_BLANK_CONTROL;
 	uint32_t value = dm_read_reg(tg->ctx, addr);
 

commit 4b5e7d620901778b24a2980bbc9941eff9b47f77
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Fri Jan 6 16:23:18 2017 -0500

    drm/amd/display: set blank functionality
    
    1. remove the sleep mechanism while set_blank true from
    the timing generator.
    Since Hw sequencer is the one that manages the flow
    he will be responsible for wait for blanck in a critical places.
    
    Signed-off-by: Leon Elazar <leon.elazar@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
index 3bf3179e07c5..682a3de7ba48 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
@@ -72,12 +72,11 @@ static bool dce110_timing_generator_v_disable_crtc(struct timing_generator *tg)
 	return true;
 }
 
-static bool dce110_timing_generator_v_blank_crtc(struct timing_generator *tg)
+static void dce110_timing_generator_v_blank_crtc(struct timing_generator *tg)
 {
 	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
 	uint32_t addr = mmCRTCV_BLANK_CONTROL;
 	uint32_t value = dm_read_reg(tg->ctx, addr);
-	uint8_t counter = 100;
 
 	set_reg_field_value(
 		value,
@@ -92,35 +91,9 @@ static bool dce110_timing_generator_v_blank_crtc(struct timing_generator *tg)
 		CRTC_BLANK_DE_MODE);
 
 	dm_write_reg(tg->ctx, addr, value);
-
-	while (counter > 0) {
-		value = dm_read_reg(tg->ctx, addr);
-
-		if (get_reg_field_value(
-			value,
-			CRTCV_BLANK_CONTROL,
-			CRTC_BLANK_DATA_EN) == 1 &&
-			get_reg_field_value(
-			value,
-			CRTCV_BLANK_CONTROL,
-			CRTC_CURRENT_BLANK_STATE) == 1)
-			break;
-
-		msleep(1);
-		counter--;
-	}
-
-	if (!counter) {
-		dm_logger_write(tg->ctx->logger, LOG_ERROR,
-				"timing generator %d blank timing out.\n",
-				tg110->controller_id);
-		return false;
-	}
-
-	return true;
 }
 
-static bool dce110_timing_generator_v_unblank_crtc(struct timing_generator *tg)
+static void dce110_timing_generator_v_unblank_crtc(struct timing_generator *tg)
 {
 	uint32_t addr = mmCRTCV_BLANK_CONTROL;
 	uint32_t value = dm_read_reg(tg->ctx, addr);
@@ -138,8 +111,6 @@ static bool dce110_timing_generator_v_unblank_crtc(struct timing_generator *tg)
 		CRTC_BLANK_DE_MODE);
 
 	dm_write_reg(tg->ctx, addr, value);
-
-	return true;
 }
 
 static bool dce110_timing_generator_v_is_in_vertical_blank(
@@ -429,13 +400,13 @@ static void dce110_timing_generator_v_enable_advanced_request(
 	dm_write_reg(tg->ctx, addr, value);
 }
 
-static bool dce110_timing_generator_v_set_blank(struct timing_generator *tg,
+static void dce110_timing_generator_v_set_blank(struct timing_generator *tg,
 		bool enable_blanking)
 {
 	if (enable_blanking)
-		return dce110_timing_generator_v_blank_crtc(tg);
+		dce110_timing_generator_v_blank_crtc(tg);
 	else
-		return dce110_timing_generator_v_unblank_crtc(tg);
+		dce110_timing_generator_v_unblank_crtc(tg);
 }
 
 static void dce110_timing_generator_v_program_timing(struct timing_generator *tg,

commit 4562236b3bc0a28aeb6ee93b2d8a849a4c4e1c7c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 12 15:58:20 2017 -0400

    drm/amd/dc: Add dc display driver (v2)
    
    Supported DCE versions: 8.0, 10.0, 11.0, 11.2
    
    v2: rebase against 4.11
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
new file mode 100644
index 000000000000..3bf3179e07c5
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
@@ -0,0 +1,743 @@
+#include "dm_services.h"
+
+/* include DCE11 register header files */
+#include "dce/dce_11_0_d.h"
+#include "dce/dce_11_0_sh_mask.h"
+
+#include "dc_types.h"
+#include "dc_bios_types.h"
+#include "dc.h"
+
+#include "include/grph_object_id.h"
+#include "include/logger_interface.h"
+#include "dce110_timing_generator.h"
+#include "dce110_timing_generator_v.h"
+
+#include "timing_generator.h"
+
+/** ********************************************************************************
+ *
+ * DCE11 Timing Generator Implementation
+ *
+ **********************************************************************************/
+
+/**
+* Enable CRTCV
+*/
+
+static bool dce110_timing_generator_v_enable_crtc(struct timing_generator *tg)
+{
+/*
+* Set MASTER_UPDATE_MODE to 0
+* This is needed for DRR, and also suggested to be default value by Syed.
+*/
+
+	uint32_t value;
+
+	value = 0;
+	set_reg_field_value(value, 0,
+			CRTCV_MASTER_UPDATE_MODE, MASTER_UPDATE_MODE);
+	dm_write_reg(tg->ctx,
+			mmCRTCV_MASTER_UPDATE_MODE, value);
+
+	/* TODO: may want this on for looking for underflow */
+	value = 0;
+	dm_write_reg(tg->ctx, mmCRTCV_MASTER_UPDATE_MODE, value);
+
+	value = 0;
+	set_reg_field_value(value, 1,
+			CRTCV_MASTER_EN, CRTC_MASTER_EN);
+	dm_write_reg(tg->ctx,
+			mmCRTCV_MASTER_EN, value);
+
+	return true;
+}
+
+static bool dce110_timing_generator_v_disable_crtc(struct timing_generator *tg)
+{
+	uint32_t value;
+
+	value = dm_read_reg(tg->ctx,
+			mmCRTCV_CONTROL);
+	set_reg_field_value(value, 0,
+			CRTCV_CONTROL, CRTC_DISABLE_POINT_CNTL);
+	set_reg_field_value(value, 0,
+				CRTCV_CONTROL, CRTC_MASTER_EN);
+	dm_write_reg(tg->ctx,
+			mmCRTCV_CONTROL, value);
+	/*
+	 * TODO: call this when adding stereo support
+	 * tg->funcs->disable_stereo(tg);
+	 */
+	return true;
+}
+
+static bool dce110_timing_generator_v_blank_crtc(struct timing_generator *tg)
+{
+	struct dce110_timing_generator *tg110 = DCE110TG_FROM_TG(tg);
+	uint32_t addr = mmCRTCV_BLANK_CONTROL;
+	uint32_t value = dm_read_reg(tg->ctx, addr);
+	uint8_t counter = 100;
+
+	set_reg_field_value(
+		value,
+		1,
+		CRTCV_BLANK_CONTROL,
+		CRTC_BLANK_DATA_EN);
+
+	set_reg_field_value(
+		value,
+		0,
+		CRTCV_BLANK_CONTROL,
+		CRTC_BLANK_DE_MODE);
+
+	dm_write_reg(tg->ctx, addr, value);
+
+	while (counter > 0) {
+		value = dm_read_reg(tg->ctx, addr);
+
+		if (get_reg_field_value(
+			value,
+			CRTCV_BLANK_CONTROL,
+			CRTC_BLANK_DATA_EN) == 1 &&
+			get_reg_field_value(
+			value,
+			CRTCV_BLANK_CONTROL,
+			CRTC_CURRENT_BLANK_STATE) == 1)
+			break;
+
+		msleep(1);
+		counter--;
+	}
+
+	if (!counter) {
+		dm_logger_write(tg->ctx->logger, LOG_ERROR,
+				"timing generator %d blank timing out.\n",
+				tg110->controller_id);
+		return false;
+	}
+
+	return true;
+}
+
+static bool dce110_timing_generator_v_unblank_crtc(struct timing_generator *tg)
+{
+	uint32_t addr = mmCRTCV_BLANK_CONTROL;
+	uint32_t value = dm_read_reg(tg->ctx, addr);
+
+	set_reg_field_value(
+		value,
+		0,
+		CRTCV_BLANK_CONTROL,
+		CRTC_BLANK_DATA_EN);
+
+	set_reg_field_value(
+		value,
+		0,
+		CRTCV_BLANK_CONTROL,
+		CRTC_BLANK_DE_MODE);
+
+	dm_write_reg(tg->ctx, addr, value);
+
+	return true;
+}
+
+static bool dce110_timing_generator_v_is_in_vertical_blank(
+		struct timing_generator *tg)
+{
+	uint32_t addr = 0;
+	uint32_t value = 0;
+	uint32_t field = 0;
+
+	addr = mmCRTCV_STATUS;
+	value = dm_read_reg(tg->ctx, addr);
+	field = get_reg_field_value(value, CRTCV_STATUS, CRTC_V_BLANK);
+	return field == 1;
+}
+
+static bool dce110_timing_generator_v_is_counter_moving(struct timing_generator *tg)
+{
+	uint32_t value;
+	uint32_t h1 = 0;
+	uint32_t h2 = 0;
+	uint32_t v1 = 0;
+	uint32_t v2 = 0;
+
+	value = dm_read_reg(tg->ctx, mmCRTCV_STATUS_POSITION);
+
+	h1 = get_reg_field_value(
+			value,
+			CRTCV_STATUS_POSITION,
+			CRTC_HORZ_COUNT);
+
+	v1 = get_reg_field_value(
+			value,
+			CRTCV_STATUS_POSITION,
+			CRTC_VERT_COUNT);
+
+	value = dm_read_reg(tg->ctx, mmCRTCV_STATUS_POSITION);
+
+	h2 = get_reg_field_value(
+			value,
+			CRTCV_STATUS_POSITION,
+			CRTC_HORZ_COUNT);
+
+	v2 = get_reg_field_value(
+			value,
+			CRTCV_STATUS_POSITION,
+			CRTC_VERT_COUNT);
+
+	if (h1 == h2 && v1 == v2)
+		return false;
+	else
+		return true;
+}
+
+static void dce110_timing_generator_v_wait_for_vblank(struct timing_generator *tg)
+{
+	/* We want to catch beginning of VBlank here, so if the first try are
+	 * in VBlank, we might be very close to Active, in this case wait for
+	 * another frame
+	 */
+	while (dce110_timing_generator_v_is_in_vertical_blank(tg)) {
+		if (!dce110_timing_generator_v_is_counter_moving(tg)) {
+			/* error - no point to wait if counter is not moving */
+			break;
+		}
+	}
+
+	while (!dce110_timing_generator_v_is_in_vertical_blank(tg)) {
+		if (!dce110_timing_generator_v_is_counter_moving(tg)) {
+			/* error - no point to wait if counter is not moving */
+			break;
+		}
+	}
+}
+
+/**
+* Wait till we are in VActive (anywhere in VActive)
+*/
+static void dce110_timing_generator_v_wait_for_vactive(struct timing_generator *tg)
+{
+	while (dce110_timing_generator_v_is_in_vertical_blank(tg)) {
+		if (!dce110_timing_generator_v_is_counter_moving(tg)) {
+			/* error - no point to wait if counter is not moving */
+			break;
+		}
+	}
+}
+
+static void dce110_timing_generator_v_wait_for_state(struct timing_generator *tg,
+	enum crtc_state state)
+{
+	switch (state) {
+	case CRTC_STATE_VBLANK:
+		dce110_timing_generator_v_wait_for_vblank(tg);
+		break;
+
+	case CRTC_STATE_VACTIVE:
+		dce110_timing_generator_v_wait_for_vactive(tg);
+		break;
+
+	default:
+		break;
+	}
+}
+
+static void dce110_timing_generator_v_program_blanking(
+	struct timing_generator *tg,
+	const struct dc_crtc_timing *timing)
+{
+	uint32_t vsync_offset = timing->v_border_bottom +
+			timing->v_front_porch;
+	uint32_t v_sync_start = timing->v_addressable + vsync_offset;
+
+	uint32_t hsync_offset = timing->h_border_right +
+			timing->h_front_porch;
+	uint32_t h_sync_start = timing->h_addressable + hsync_offset;
+
+	struct dc_context *ctx = tg->ctx;
+	uint32_t value = 0;
+	uint32_t addr = 0;
+	uint32_t tmp = 0;
+
+	addr = mmCRTCV_H_TOTAL;
+	value = dm_read_reg(ctx, addr);
+	set_reg_field_value(
+		value,
+		timing->h_total - 1,
+		CRTCV_H_TOTAL,
+		CRTC_H_TOTAL);
+	dm_write_reg(ctx, addr, value);
+
+	addr = mmCRTCV_V_TOTAL;
+	value = dm_read_reg(ctx, addr);
+	set_reg_field_value(
+		value,
+		timing->v_total - 1,
+		CRTCV_V_TOTAL,
+		CRTC_V_TOTAL);
+	dm_write_reg(ctx, addr, value);
+
+	addr = mmCRTCV_H_BLANK_START_END;
+	value = dm_read_reg(ctx, addr);
+
+	tmp = timing->h_total -
+		(h_sync_start + timing->h_border_left);
+
+	set_reg_field_value(
+		value,
+		tmp,
+		CRTCV_H_BLANK_START_END,
+		CRTC_H_BLANK_END);
+
+	tmp = tmp + timing->h_addressable +
+		timing->h_border_left + timing->h_border_right;
+
+	set_reg_field_value(
+		value,
+		tmp,
+		CRTCV_H_BLANK_START_END,
+		CRTC_H_BLANK_START);
+
+	dm_write_reg(ctx, addr, value);
+
+	addr = mmCRTCV_V_BLANK_START_END;
+	value = dm_read_reg(ctx, addr);
+
+	tmp = timing->v_total - (v_sync_start + timing->v_border_top);
+
+	set_reg_field_value(
+		value,
+		tmp,
+		CRTCV_V_BLANK_START_END,
+		CRTC_V_BLANK_END);
+
+	tmp = tmp + timing->v_addressable + timing->v_border_top +
+		timing->v_border_bottom;
+
+	set_reg_field_value(
+		value,
+		tmp,
+		CRTCV_V_BLANK_START_END,
+		CRTC_V_BLANK_START);
+
+	dm_write_reg(ctx, addr, value);
+
+	addr = mmCRTCV_H_SYNC_A;
+	value = 0;
+	set_reg_field_value(
+		value,
+		timing->h_sync_width,
+		CRTCV_H_SYNC_A,
+		CRTC_H_SYNC_A_END);
+	dm_write_reg(ctx, addr, value);
+
+	addr = mmCRTCV_H_SYNC_A_CNTL;
+	value = dm_read_reg(ctx, addr);
+	if (timing->flags.HSYNC_POSITIVE_POLARITY) {
+		set_reg_field_value(
+			value,
+			0,
+			CRTCV_H_SYNC_A_CNTL,
+			CRTC_H_SYNC_A_POL);
+	} else {
+		set_reg_field_value(
+			value,
+			1,
+			CRTCV_H_SYNC_A_CNTL,
+			CRTC_H_SYNC_A_POL);
+	}
+	dm_write_reg(ctx, addr, value);
+
+	addr = mmCRTCV_V_SYNC_A;
+	value = 0;
+	set_reg_field_value(
+		value,
+		timing->v_sync_width,
+		CRTCV_V_SYNC_A,
+		CRTC_V_SYNC_A_END);
+	dm_write_reg(ctx, addr, value);
+
+	addr = mmCRTCV_V_SYNC_A_CNTL;
+	value = dm_read_reg(ctx, addr);
+	if (timing->flags.VSYNC_POSITIVE_POLARITY) {
+		set_reg_field_value(
+			value,
+			0,
+			CRTCV_V_SYNC_A_CNTL,
+			CRTC_V_SYNC_A_POL);
+	} else {
+		set_reg_field_value(
+			value,
+			1,
+			CRTCV_V_SYNC_A_CNTL,
+			CRTC_V_SYNC_A_POL);
+	}
+	dm_write_reg(ctx, addr, value);
+
+	addr = mmCRTCV_INTERLACE_CONTROL;
+	value = dm_read_reg(ctx, addr);
+	set_reg_field_value(
+		value,
+		timing->flags.INTERLACE,
+		CRTCV_INTERLACE_CONTROL,
+		CRTC_INTERLACE_ENABLE);
+	dm_write_reg(ctx, addr, value);
+}
+
+static void dce110_timing_generator_v_enable_advanced_request(
+	struct timing_generator *tg,
+	bool enable,
+	const struct dc_crtc_timing *timing)
+{
+	uint32_t addr = mmCRTCV_START_LINE_CONTROL;
+	uint32_t value = dm_read_reg(tg->ctx, addr);
+
+	if (enable) {
+		if ((timing->v_sync_width + timing->v_front_porch) <= 3) {
+			set_reg_field_value(
+				value,
+				3,
+				CRTCV_START_LINE_CONTROL,
+				CRTC_ADVANCED_START_LINE_POSITION);
+		} else {
+			set_reg_field_value(
+				value,
+				4,
+				CRTCV_START_LINE_CONTROL,
+				CRTC_ADVANCED_START_LINE_POSITION);
+		}
+		set_reg_field_value(
+			value,
+			0,
+			CRTCV_START_LINE_CONTROL,
+			CRTC_LEGACY_REQUESTOR_EN);
+	} else {
+		set_reg_field_value(
+			value,
+			2,
+			CRTCV_START_LINE_CONTROL,
+			CRTC_ADVANCED_START_LINE_POSITION);
+		set_reg_field_value(
+			value,
+			1,
+			CRTCV_START_LINE_CONTROL,
+			CRTC_LEGACY_REQUESTOR_EN);
+	}
+
+	dm_write_reg(tg->ctx, addr, value);
+}
+
+static bool dce110_timing_generator_v_set_blank(struct timing_generator *tg,
+		bool enable_blanking)
+{
+	if (enable_blanking)
+		return dce110_timing_generator_v_blank_crtc(tg);
+	else
+		return dce110_timing_generator_v_unblank_crtc(tg);
+}
+
+static void dce110_timing_generator_v_program_timing(struct timing_generator *tg,
+	const struct dc_crtc_timing *timing,
+	bool use_vbios)
+{
+	if (use_vbios)
+		dce110_timing_generator_program_timing_generator(tg, timing);
+	else
+		dce110_timing_generator_v_program_blanking(tg, timing);
+}
+
+static void dce110_timing_generator_v_program_blank_color(
+		struct timing_generator *tg,
+		const struct tg_color *black_color)
+{
+	uint32_t addr = mmCRTCV_BLACK_COLOR;
+	uint32_t value = dm_read_reg(tg->ctx, addr);
+
+	set_reg_field_value(
+		value,
+		black_color->color_b_cb,
+		CRTCV_BLACK_COLOR,
+		CRTC_BLACK_COLOR_B_CB);
+	set_reg_field_value(
+		value,
+		black_color->color_g_y,
+		CRTCV_BLACK_COLOR,
+		CRTC_BLACK_COLOR_G_Y);
+	set_reg_field_value(
+		value,
+		black_color->color_r_cr,
+		CRTCV_BLACK_COLOR,
+		CRTC_BLACK_COLOR_R_CR);
+
+	dm_write_reg(tg->ctx, addr, value);
+}
+
+static void dce110_timing_generator_v_set_overscan_color_black(
+	struct timing_generator *tg,
+	const struct tg_color *color)
+{
+	struct dc_context *ctx = tg->ctx;
+	uint32_t addr;
+	uint32_t value = 0;
+
+	set_reg_field_value(
+			value,
+			color->color_b_cb,
+			CRTC_OVERSCAN_COLOR,
+			CRTC_OVERSCAN_COLOR_BLUE);
+
+	set_reg_field_value(
+			value,
+			color->color_r_cr,
+			CRTC_OVERSCAN_COLOR,
+			CRTC_OVERSCAN_COLOR_RED);
+
+	set_reg_field_value(
+			value,
+			color->color_g_y,
+			CRTC_OVERSCAN_COLOR,
+			CRTC_OVERSCAN_COLOR_GREEN);
+
+	addr = mmCRTCV_OVERSCAN_COLOR;
+	dm_write_reg(ctx, addr, value);
+	addr = mmCRTCV_BLACK_COLOR;
+	dm_write_reg(ctx, addr, value);
+	/* This is desirable to have a constant DAC output voltage during the
+	 * blank time that is higher than the 0 volt reference level that the
+	 * DAC outputs when the NBLANK signal
+	 * is asserted low, such as for output to an analog TV. */
+	addr = mmCRTCV_BLANK_DATA_COLOR;
+	dm_write_reg(ctx, addr, value);
+
+	/* TO DO we have to program EXT registers and we need to know LB DATA
+	 * format because it is used when more 10 , i.e. 12 bits per color
+	 *
+	 * m_mmDxCRTC_OVERSCAN_COLOR_EXT
+	 * m_mmDxCRTC_BLACK_COLOR_EXT
+	 * m_mmDxCRTC_BLANK_DATA_COLOR_EXT
+	 */
+}
+
+static void dce110_tg_v_program_blank_color(struct timing_generator *tg,
+		const struct tg_color *black_color)
+{
+	uint32_t addr = mmCRTCV_BLACK_COLOR;
+	uint32_t value = dm_read_reg(tg->ctx, addr);
+
+	set_reg_field_value(
+		value,
+		black_color->color_b_cb,
+		CRTCV_BLACK_COLOR,
+		CRTC_BLACK_COLOR_B_CB);
+	set_reg_field_value(
+		value,
+		black_color->color_g_y,
+		CRTCV_BLACK_COLOR,
+		CRTC_BLACK_COLOR_G_Y);
+	set_reg_field_value(
+		value,
+		black_color->color_r_cr,
+		CRTCV_BLACK_COLOR,
+		CRTC_BLACK_COLOR_R_CR);
+
+	dm_write_reg(tg->ctx, addr, value);
+
+	addr = mmCRTCV_BLANK_DATA_COLOR;
+	dm_write_reg(tg->ctx, addr, value);
+}
+
+static void dce110_timing_generator_v_set_overscan_color(struct timing_generator *tg,
+	const struct tg_color *overscan_color)
+{
+	struct dc_context *ctx = tg->ctx;
+	uint32_t value = 0;
+	uint32_t addr;
+
+	set_reg_field_value(
+		value,
+		overscan_color->color_b_cb,
+		CRTCV_OVERSCAN_COLOR,
+		CRTC_OVERSCAN_COLOR_BLUE);
+
+	set_reg_field_value(
+		value,
+		overscan_color->color_g_y,
+		CRTCV_OVERSCAN_COLOR,
+		CRTC_OVERSCAN_COLOR_GREEN);
+
+	set_reg_field_value(
+		value,
+		overscan_color->color_r_cr,
+		CRTCV_OVERSCAN_COLOR,
+		CRTC_OVERSCAN_COLOR_RED);
+
+	addr = mmCRTCV_OVERSCAN_COLOR;
+	dm_write_reg(ctx, addr, value);
+}
+
+static void dce110_timing_generator_v_set_colors(struct timing_generator *tg,
+	const struct tg_color *blank_color,
+	const struct tg_color *overscan_color)
+{
+	if (blank_color != NULL)
+		dce110_tg_v_program_blank_color(tg, blank_color);
+	if (overscan_color != NULL)
+		dce110_timing_generator_v_set_overscan_color(tg, overscan_color);
+}
+
+static void dce110_timing_generator_v_set_early_control(
+		struct timing_generator *tg,
+		uint32_t early_cntl)
+{
+	uint32_t regval;
+	uint32_t address = mmCRTC_CONTROL;
+
+	regval = dm_read_reg(tg->ctx, address);
+	set_reg_field_value(regval, early_cntl,
+			CRTCV_CONTROL, CRTC_HBLANK_EARLY_CONTROL);
+	dm_write_reg(tg->ctx, address, regval);
+}
+
+static void dce110_timing_generator_v_get_crtc_positions(
+	struct timing_generator *tg,
+	int32_t *h_position,
+	int32_t *v_position)
+{
+	uint32_t value;
+
+	value = dm_read_reg(tg->ctx, mmCRTCV_STATUS_POSITION);
+
+	*h_position = get_reg_field_value(
+			value,
+			CRTCV_STATUS_POSITION,
+			CRTC_HORZ_COUNT);
+
+	*v_position = get_reg_field_value(
+			value,
+			CRTCV_STATUS_POSITION,
+			CRTC_VERT_COUNT);
+}
+
+static uint32_t dce110_timing_generator_v_get_vblank_counter(struct timing_generator *tg)
+{
+	uint32_t addr = mmCRTCV_STATUS_FRAME_COUNT;
+	uint32_t value = dm_read_reg(tg->ctx, addr);
+	uint32_t field = get_reg_field_value(
+			value, CRTCV_STATUS_FRAME_COUNT, CRTC_FRAME_COUNT);
+
+	return field;
+}
+
+static bool dce110_timing_generator_v_did_triggered_reset_occur(
+	struct timing_generator *tg)
+{
+	dm_logger_write(tg->ctx->logger, LOG_ERROR,
+					"Timing Sync not supported on underlay pipe\n");
+	return false;
+}
+
+static void dce110_timing_generator_v_setup_global_swap_lock(
+	struct timing_generator *tg,
+	const struct dcp_gsl_params *gsl_params)
+{
+	dm_logger_write(tg->ctx->logger, LOG_ERROR,
+					"Timing Sync not supported on underlay pipe\n");
+	return;
+}
+
+static void dce110_timing_generator_v_enable_reset_trigger(
+	struct timing_generator *tg,
+	int source_tg_inst)
+{
+	dm_logger_write(tg->ctx->logger, LOG_ERROR,
+					"Timing Sync not supported on underlay pipe\n");
+	return;
+}
+
+static void dce110_timing_generator_v_disable_reset_trigger(
+	struct timing_generator *tg)
+{
+	dm_logger_write(tg->ctx->logger, LOG_ERROR,
+						"Timing Sync not supported on underlay pipe\n");
+	return;
+}
+
+static void dce110_timing_generator_v_tear_down_global_swap_lock(
+	struct timing_generator *tg)
+{
+	dm_logger_write(tg->ctx->logger, LOG_ERROR,
+						"Timing Sync not supported on underlay pipe\n");
+	return;
+}
+
+static void dce110_timing_generator_v_disable_vga(
+	struct timing_generator *tg)
+{
+	return;
+}
+
+static bool dce110_tg_v_is_blanked(struct timing_generator *tg)
+{
+	/* Signal comes from the primary pipe, underlay is never blanked. */
+	return false;
+}
+
+/** ********************************************************************************************
+ *
+ * DCE11 Timing Generator Constructor / Destructor
+ *
+ *********************************************************************************************/
+static const struct timing_generator_funcs dce110_tg_v_funcs = {
+		.validate_timing = dce110_tg_validate_timing,
+		.program_timing = dce110_timing_generator_v_program_timing,
+		.enable_crtc = dce110_timing_generator_v_enable_crtc,
+		.disable_crtc = dce110_timing_generator_v_disable_crtc,
+		.is_counter_moving = dce110_timing_generator_v_is_counter_moving,
+		.get_position = dce110_timing_generator_v_get_crtc_positions,
+		.get_frame_count = dce110_timing_generator_v_get_vblank_counter,
+		.set_early_control = dce110_timing_generator_v_set_early_control,
+		.wait_for_state = dce110_timing_generator_v_wait_for_state,
+		.set_blank = dce110_timing_generator_v_set_blank,
+		.is_blanked = dce110_tg_v_is_blanked,
+		.set_colors = dce110_timing_generator_v_set_colors,
+		.set_overscan_blank_color =
+				dce110_timing_generator_v_set_overscan_color_black,
+		.set_blank_color = dce110_timing_generator_v_program_blank_color,
+		.disable_vga = dce110_timing_generator_v_disable_vga,
+		.did_triggered_reset_occur =
+				dce110_timing_generator_v_did_triggered_reset_occur,
+		.setup_global_swap_lock =
+				dce110_timing_generator_v_setup_global_swap_lock,
+		.enable_reset_trigger = dce110_timing_generator_v_enable_reset_trigger,
+		.disable_reset_trigger = dce110_timing_generator_v_disable_reset_trigger,
+		.tear_down_global_swap_lock =
+				dce110_timing_generator_v_tear_down_global_swap_lock,
+		.enable_advanced_request =
+				dce110_timing_generator_v_enable_advanced_request
+};
+
+bool dce110_timing_generator_v_construct(
+	struct dce110_timing_generator *tg110,
+	struct dc_context *ctx)
+{
+	if (!tg110)
+		return false;
+
+	tg110->controller_id = CONTROLLER_ID_UNDERLAY0;
+
+	tg110->base.funcs = &dce110_tg_v_funcs;
+
+	tg110->base.ctx = ctx;
+	tg110->base.bp = ctx->dc_bios;
+
+	tg110->max_h_total = CRTC_H_TOTAL__CRTC_H_TOTAL_MASK + 1;
+	tg110->max_v_total = CRTC_V_TOTAL__CRTC_V_TOTAL_MASK + 1;
+
+	tg110->min_h_blank = 56;
+	tg110->min_h_front_porch = 4;
+	tg110->min_h_back_porch = 4;
+
+	return true;
+}
