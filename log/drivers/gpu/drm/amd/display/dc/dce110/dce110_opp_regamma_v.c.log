commit c366be543c5ea35f4d4103f5ee69f052ce2bffe1
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:49 2019 +0200

    drm/amd: drop dependencies on drm_os_linux.h
    
    Fix so no files in drm/amd/ depends on the
    deprecated drm_os_linux.h header file.
    
    It was done manually:
    - remove drm_os_linux.h from drmP.h
    - fix all build errros
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian KÃ¶nig" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-3-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
index 9b65b77e8823..34c5e3c7c6d2 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
@@ -23,6 +23,8 @@
  *
  */
 
+#include <linux/delay.h>
+
 #include "dm_services.h"
 
 /* include DCE11 register header files */

commit 97110c98a0fa2091190dc3068734ef9f1c12b588
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Oct 31 14:41:41 2017 -0400

    drm/amd/display: Remove extra arr_points element
    
    arr_points[1] and [2] were duplicated. Remove the extra
    one. If we ever need more points we can add them but the
    current state of affairs is confusing.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
index e98ed3058ea2..9b65b77e8823 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
@@ -175,7 +175,7 @@ static void regamma_config_regions_and_segments(
 		value = 0;
 		set_reg_field_value(
 			value,
-			params->arr_points[2].custom_float_slope,
+			params->arr_points[1].custom_float_slope,
 			GAMMA_CORR_CNTLA_END_CNTL2,
 			GAMMA_CORR_CNTLA_EXP_REGION_END_BASE);
 

commit 4dec2aa9eb1386e592d76f380360360178c4af02
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 14:34:35 2017 +1000

    amdgpu/dc: make program_regamma_pwl return void
    
    The return value was unused.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
index c86105b8cfaf..e98ed3058ea2 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
@@ -490,7 +490,7 @@ static void program_pwl(struct dce_transform *xfm_dce,
 	}
 }
 
-bool dce110_opp_program_regamma_pwl_v(
+void dce110_opp_program_regamma_pwl_v(
 	struct transform *xfm,
 	const struct pwl_params *params)
 {
@@ -512,8 +512,6 @@ bool dce110_opp_program_regamma_pwl_v(
 
 	/* Power return to auto back */
 	power_on_lut(xfm, false, false, true);
-
-	return true;
 }
 
 void dce110_opp_power_on_regamma_lut_v(

commit 7a09f5be98df25a7253e4647e801120b37b90feb
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Fri Jul 28 13:08:03 2017 -0400

    drm/amd/display: move regamma from opp to dpp for dce
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
index 876445f14c85..c86105b8cfaf 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
@@ -29,12 +29,12 @@
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_sh_mask.h"
 
-#include "dce/dce_opp.h"
+#include "dce110_transform_v.h"
 
-static void power_on_lut(struct output_pixel_processor *opp,
+static void power_on_lut(struct transform *xfm,
 	bool power_on, bool inputgamma, bool regamma)
 {
-	uint32_t value = dm_read_reg(opp->ctx, mmDCFEV_MEM_PWR_CTRL);
+	uint32_t value = dm_read_reg(xfm->ctx, mmDCFEV_MEM_PWR_CTRL);
 	int i;
 
 	if (power_on) {
@@ -65,10 +65,10 @@ static void power_on_lut(struct output_pixel_processor *opp,
 				COL_MAN_GAMMA_CORR_MEM_PWR_DIS);
 	}
 
-	dm_write_reg(opp->ctx, mmDCFEV_MEM_PWR_CTRL, value);
+	dm_write_reg(xfm->ctx, mmDCFEV_MEM_PWR_CTRL, value);
 
 	for (i = 0; i < 3; i++) {
-		value = dm_read_reg(opp->ctx, mmDCFEV_MEM_PWR_CTRL);
+		value = dm_read_reg(xfm->ctx, mmDCFEV_MEM_PWR_CTRL);
 		if (get_reg_field_value(value,
 				DCFEV_MEM_PWR_CTRL,
 				COL_MAN_INPUT_GAMMA_MEM_PWR_DIS) &&
@@ -81,11 +81,11 @@ static void power_on_lut(struct output_pixel_processor *opp,
 	}
 }
 
-static void set_bypass_input_gamma(struct dce110_opp *opp110)
+static void set_bypass_input_gamma(struct dce_transform *xfm_dce)
 {
 	uint32_t value;
 
-	value = dm_read_reg(opp110->base.ctx,
+	value = dm_read_reg(xfm_dce->base.ctx,
 			mmCOL_MAN_INPUT_GAMMA_CONTROL1);
 
 	set_reg_field_value(
@@ -94,11 +94,11 @@ static void set_bypass_input_gamma(struct dce110_opp *opp110)
 				COL_MAN_INPUT_GAMMA_CONTROL1,
 				INPUT_GAMMA_MODE);
 
-	dm_write_reg(opp110->base.ctx,
+	dm_write_reg(xfm_dce->base.ctx,
 			mmCOL_MAN_INPUT_GAMMA_CONTROL1, value);
 }
 
-static void configure_regamma_mode(struct dce110_opp *opp110, uint32_t mode)
+static void configure_regamma_mode(struct dce_transform *xfm_dce, uint32_t mode)
 {
 	uint32_t value = 0;
 
@@ -108,7 +108,7 @@ static void configure_regamma_mode(struct dce110_opp *opp110, uint32_t mode)
 				GAMMA_CORR_CONTROL,
 				GAMMA_CORR_MODE);
 
-	dm_write_reg(opp110->base.ctx, mmGAMMA_CORR_CONTROL, 0);
+	dm_write_reg(xfm_dce->base.ctx, mmGAMMA_CORR_CONTROL, 0);
 }
 
 /*
@@ -128,7 +128,7 @@ static void configure_regamma_mode(struct dce110_opp *opp110, uint32_t mode)
  *****************************************************************************
  */
 static void regamma_config_regions_and_segments(
-	struct dce110_opp *opp110, const struct pwl_params *params)
+	struct dce_transform *xfm_dce, const struct pwl_params *params)
 {
 	const struct gamma_curve *curve;
 	uint32_t value = 0;
@@ -146,7 +146,7 @@ static void regamma_config_regions_and_segments(
 			GAMMA_CORR_CNTLA_START_CNTL,
 			GAMMA_CORR_CNTLA_EXP_REGION_START_SEGMENT);
 
-		dm_write_reg(opp110->base.ctx, mmGAMMA_CORR_CNTLA_START_CNTL,
+		dm_write_reg(xfm_dce->base.ctx, mmGAMMA_CORR_CNTLA_START_CNTL,
 				value);
 	}
 	{
@@ -157,7 +157,7 @@ static void regamma_config_regions_and_segments(
 			GAMMA_CORR_CNTLA_SLOPE_CNTL,
 			GAMMA_CORR_CNTLA_EXP_REGION_LINEAR_SLOPE);
 
-		dm_write_reg(opp110->base.ctx,
+		dm_write_reg(xfm_dce->base.ctx,
 			mmGAMMA_CORR_CNTLA_SLOPE_CNTL, value);
 	}
 	{
@@ -168,7 +168,7 @@ static void regamma_config_regions_and_segments(
 			GAMMA_CORR_CNTLA_END_CNTL1,
 			GAMMA_CORR_CNTLA_EXP_REGION_END);
 
-		dm_write_reg(opp110->base.ctx,
+		dm_write_reg(xfm_dce->base.ctx,
 			mmGAMMA_CORR_CNTLA_END_CNTL1, value);
 	}
 	{
@@ -185,7 +185,7 @@ static void regamma_config_regions_and_segments(
 			GAMMA_CORR_CNTLA_END_CNTL2,
 			GAMMA_CORR_CNTLA_EXP_REGION_END_SLOPE);
 
-		dm_write_reg(opp110->base.ctx,
+		dm_write_reg(xfm_dce->base.ctx,
 			mmGAMMA_CORR_CNTLA_END_CNTL2, value);
 	}
 
@@ -218,7 +218,7 @@ static void regamma_config_regions_and_segments(
 			GAMMA_CORR_CNTLA_EXP_REGION1_NUM_SEGMENTS);
 
 		dm_write_reg(
-			opp110->base.ctx,
+				xfm_dce->base.ctx,
 			mmGAMMA_CORR_CNTLA_REGION_0_1,
 			value);
 	}
@@ -250,7 +250,7 @@ static void regamma_config_regions_and_segments(
 			GAMMA_CORR_CNTLA_REGION_2_3,
 			GAMMA_CORR_CNTLA_EXP_REGION3_NUM_SEGMENTS);
 
-		dm_write_reg(opp110->base.ctx,
+		dm_write_reg(xfm_dce->base.ctx,
 			mmGAMMA_CORR_CNTLA_REGION_2_3,
 			value);
 	}
@@ -282,7 +282,7 @@ static void regamma_config_regions_and_segments(
 			GAMMA_CORR_CNTLA_REGION_4_5,
 			GAMMA_CORR_CNTLA_EXP_REGION5_NUM_SEGMENTS);
 
-		dm_write_reg(opp110->base.ctx,
+		dm_write_reg(xfm_dce->base.ctx,
 			mmGAMMA_CORR_CNTLA_REGION_4_5,
 			value);
 	}
@@ -314,7 +314,7 @@ static void regamma_config_regions_and_segments(
 			GAMMA_CORR_CNTLA_REGION_6_7,
 			GAMMA_CORR_CNTLA_EXP_REGION7_NUM_SEGMENTS);
 
-		dm_write_reg(opp110->base.ctx,
+		dm_write_reg(xfm_dce->base.ctx,
 			mmGAMMA_CORR_CNTLA_REGION_6_7,
 			value);
 	}
@@ -346,7 +346,7 @@ static void regamma_config_regions_and_segments(
 			GAMMA_CORR_CNTLA_REGION_8_9,
 			GAMMA_CORR_CNTLA_EXP_REGION9_NUM_SEGMENTS);
 
-		dm_write_reg(opp110->base.ctx,
+		dm_write_reg(xfm_dce->base.ctx,
 			mmGAMMA_CORR_CNTLA_REGION_8_9,
 			value);
 	}
@@ -378,7 +378,7 @@ static void regamma_config_regions_and_segments(
 			GAMMA_CORR_CNTLA_REGION_10_11,
 			GAMMA_CORR_CNTLA_EXP_REGION11_NUM_SEGMENTS);
 
-		dm_write_reg(opp110->base.ctx,
+		dm_write_reg(xfm_dce->base.ctx,
 			mmGAMMA_CORR_CNTLA_REGION_10_11,
 			value);
 	}
@@ -410,7 +410,7 @@ static void regamma_config_regions_and_segments(
 			GAMMA_CORR_CNTLA_REGION_12_13,
 			GAMMA_CORR_CNTLA_EXP_REGION13_NUM_SEGMENTS);
 
-		dm_write_reg(opp110->base.ctx,
+		dm_write_reg(xfm_dce->base.ctx,
 			mmGAMMA_CORR_CNTLA_REGION_12_13,
 			value);
 	}
@@ -442,13 +442,13 @@ static void regamma_config_regions_and_segments(
 			GAMMA_CORR_CNTLA_REGION_14_15,
 			GAMMA_CORR_CNTLA_EXP_REGION15_NUM_SEGMENTS);
 
-		dm_write_reg(opp110->base.ctx,
+		dm_write_reg(xfm_dce->base.ctx,
 			mmGAMMA_CORR_CNTLA_REGION_14_15,
 			value);
 	}
 }
 
-static void program_pwl(struct dce110_opp *opp110,
+static void program_pwl(struct dce_transform *xfm_dce,
 		const struct pwl_params *params)
 {
 	uint32_t value = 0;
@@ -459,10 +459,10 @@ static void program_pwl(struct dce110_opp *opp110,
 		GAMMA_CORR_LUT_WRITE_EN_MASK,
 		GAMMA_CORR_LUT_WRITE_EN_MASK);
 
-	dm_write_reg(opp110->base.ctx,
+	dm_write_reg(xfm_dce->base.ctx,
 		mmGAMMA_CORR_LUT_WRITE_EN_MASK, value);
 
-	dm_write_reg(opp110->base.ctx,
+	dm_write_reg(xfm_dce->base.ctx,
 		mmGAMMA_CORR_LUT_INDEX, 0);
 
 	/* Program REGAMMA_LUT_DATA */
@@ -473,15 +473,15 @@ static void program_pwl(struct dce110_opp *opp110,
 				params->rgb_resulted;
 
 		while (i != params->hw_points_num) {
-			dm_write_reg(opp110->base.ctx, addr, rgb->red_reg);
-			dm_write_reg(opp110->base.ctx, addr, rgb->green_reg);
-			dm_write_reg(opp110->base.ctx, addr, rgb->blue_reg);
+			dm_write_reg(xfm_dce->base.ctx, addr, rgb->red_reg);
+			dm_write_reg(xfm_dce->base.ctx, addr, rgb->green_reg);
+			dm_write_reg(xfm_dce->base.ctx, addr, rgb->blue_reg);
 
-			dm_write_reg(opp110->base.ctx, addr,
+			dm_write_reg(xfm_dce->base.ctx, addr,
 				rgb->delta_red_reg);
-			dm_write_reg(opp110->base.ctx, addr,
+			dm_write_reg(xfm_dce->base.ctx, addr,
 				rgb->delta_green_reg);
-			dm_write_reg(opp110->base.ctx, addr,
+			dm_write_reg(xfm_dce->base.ctx, addr,
 				rgb->delta_blue_reg);
 
 			++rgb;
@@ -491,36 +491,36 @@ static void program_pwl(struct dce110_opp *opp110,
 }
 
 bool dce110_opp_program_regamma_pwl_v(
-	struct output_pixel_processor *opp,
+	struct transform *xfm,
 	const struct pwl_params *params)
 {
-	struct dce110_opp *opp110 = TO_DCE110_OPP(opp);
+	struct dce_transform *xfm_dce = TO_DCE_TRANSFORM(xfm);
 
 	/* Setup regions */
-	regamma_config_regions_and_segments(opp110, params);
+	regamma_config_regions_and_segments(xfm_dce, params);
 
-	set_bypass_input_gamma(opp110);
+	set_bypass_input_gamma(xfm_dce);
 
 	/* Power on gamma LUT memory */
-	power_on_lut(opp, true, false, true);
+	power_on_lut(xfm, true, false, true);
 
 	/* Program PWL */
-	program_pwl(opp110, params);
+	program_pwl(xfm_dce, params);
 
 	/* program regamma config */
-	configure_regamma_mode(opp110, 1);
+	configure_regamma_mode(xfm_dce, 1);
 
 	/* Power return to auto back */
-	power_on_lut(opp, false, false, true);
+	power_on_lut(xfm, false, false, true);
 
 	return true;
 }
 
 void dce110_opp_power_on_regamma_lut_v(
-	struct output_pixel_processor *opp,
+	struct transform *xfm,
 	bool power_on)
 {
-	uint32_t value = dm_read_reg(opp->ctx, mmDCFEV_MEM_PWR_CTRL);
+	uint32_t value = dm_read_reg(xfm->ctx, mmDCFEV_MEM_PWR_CTRL);
 
 	set_reg_field_value(
 		value,
@@ -546,11 +546,11 @@ void dce110_opp_power_on_regamma_lut_v(
 		DCFEV_MEM_PWR_CTRL,
 		COL_MAN_INPUT_GAMMA_MEM_PWR_DIS);
 
-	dm_write_reg(opp->ctx, mmDCFEV_MEM_PWR_CTRL, value);
+	dm_write_reg(xfm->ctx, mmDCFEV_MEM_PWR_CTRL, value);
 }
 
 void dce110_opp_set_regamma_mode_v(
-	struct output_pixel_processor *opp,
+	struct transform *xfm,
 	enum opp_regamma mode)
 {
 	// TODO: need to implement the function

commit cc0cb445ae56890a322abe2cc8df63b1ccab74fb
Author: Leon Elazar <leon.elazar@amd.com>
Date:   Wed Jan 11 14:33:36 2017 -0500

    drm/amd/display: Fixing some fallout from dc_target removal
    
    Also avoid allocating memory dce110_set_output_transfer_func
    if not needed
    
    Signed-off-by: Leon Elazar <leon.elazar@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
index 8164aa6bcb00..876445f14c85 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
@@ -548,3 +548,10 @@ void dce110_opp_power_on_regamma_lut_v(
 
 	dm_write_reg(opp->ctx, mmDCFEV_MEM_PWR_CTRL, value);
 }
+
+void dce110_opp_set_regamma_mode_v(
+	struct output_pixel_processor *opp,
+	enum opp_regamma mode)
+{
+	// TODO: need to implement the function
+}

commit d7194cf6b8ddf0344e70834397d0b1af2cc5fe05
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Tue Dec 20 20:24:24 2016 -0500

    drm/amd/display: Implement gamma correction using input LUT
    
    The dc_gamma in dc_surface will be programmed to the input
    LUT if provided.  If dc_gamma is not provided in dc_surface
    regamma may be used to emulate gamma.
    
    Some refactor and cleanup included as well.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
index 81fcbc52e4ab..8164aa6bcb00 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
@@ -30,7 +30,6 @@
 #include "dce/dce_11_0_sh_mask.h"
 
 #include "dce/dce_opp.h"
-#include "gamma_types.h"
 
 static void power_on_lut(struct output_pixel_processor *opp,
 	bool power_on, bool inputgamma, bool regamma)

commit ab3ee7a556343c9549ccbefb9d31039377806f28
Author: Zeyu Fan <Zeyu.Fan@amd.com>
Date:   Wed Dec 14 18:54:41 2016 -0500

    drm/amd/display: OPP refactor and consolidation for DCE.
    
    Signed-off-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
index 3b3a9175b2c3..81fcbc52e4ab 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
@@ -29,7 +29,7 @@
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_sh_mask.h"
 
-#include "dce110_opp.h"
+#include "dce/dce_opp.h"
 #include "gamma_types.h"
 
 static void power_on_lut(struct output_pixel_processor *opp,

commit 4562236b3bc0a28aeb6ee93b2d8a849a4c4e1c7c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 12 15:58:20 2017 -0400

    drm/amd/dc: Add dc display driver (v2)
    
    Supported DCE versions: 8.0, 10.0, 11.0, 11.2
    
    v2: rebase against 4.11
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
new file mode 100644
index 000000000000..3b3a9175b2c3
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_opp_regamma_v.c
@@ -0,0 +1,551 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dm_services.h"
+
+/* include DCE11 register header files */
+#include "dce/dce_11_0_d.h"
+#include "dce/dce_11_0_sh_mask.h"
+
+#include "dce110_opp.h"
+#include "gamma_types.h"
+
+static void power_on_lut(struct output_pixel_processor *opp,
+	bool power_on, bool inputgamma, bool regamma)
+{
+	uint32_t value = dm_read_reg(opp->ctx, mmDCFEV_MEM_PWR_CTRL);
+	int i;
+
+	if (power_on) {
+		if (inputgamma)
+			set_reg_field_value(
+				value,
+				1,
+				DCFEV_MEM_PWR_CTRL,
+				COL_MAN_INPUT_GAMMA_MEM_PWR_DIS);
+		if (regamma)
+			set_reg_field_value(
+				value,
+				1,
+				DCFEV_MEM_PWR_CTRL,
+				COL_MAN_GAMMA_CORR_MEM_PWR_DIS);
+	} else {
+		if (inputgamma)
+			set_reg_field_value(
+				value,
+				0,
+				DCFEV_MEM_PWR_CTRL,
+				COL_MAN_INPUT_GAMMA_MEM_PWR_DIS);
+		if (regamma)
+			set_reg_field_value(
+				value,
+				0,
+				DCFEV_MEM_PWR_CTRL,
+				COL_MAN_GAMMA_CORR_MEM_PWR_DIS);
+	}
+
+	dm_write_reg(opp->ctx, mmDCFEV_MEM_PWR_CTRL, value);
+
+	for (i = 0; i < 3; i++) {
+		value = dm_read_reg(opp->ctx, mmDCFEV_MEM_PWR_CTRL);
+		if (get_reg_field_value(value,
+				DCFEV_MEM_PWR_CTRL,
+				COL_MAN_INPUT_GAMMA_MEM_PWR_DIS) &&
+			get_reg_field_value(value,
+					DCFEV_MEM_PWR_CTRL,
+					COL_MAN_GAMMA_CORR_MEM_PWR_DIS))
+			break;
+
+		udelay(2);
+	}
+}
+
+static void set_bypass_input_gamma(struct dce110_opp *opp110)
+{
+	uint32_t value;
+
+	value = dm_read_reg(opp110->base.ctx,
+			mmCOL_MAN_INPUT_GAMMA_CONTROL1);
+
+	set_reg_field_value(
+				value,
+				0,
+				COL_MAN_INPUT_GAMMA_CONTROL1,
+				INPUT_GAMMA_MODE);
+
+	dm_write_reg(opp110->base.ctx,
+			mmCOL_MAN_INPUT_GAMMA_CONTROL1, value);
+}
+
+static void configure_regamma_mode(struct dce110_opp *opp110, uint32_t mode)
+{
+	uint32_t value = 0;
+
+	set_reg_field_value(
+				value,
+				mode,
+				GAMMA_CORR_CONTROL,
+				GAMMA_CORR_MODE);
+
+	dm_write_reg(opp110->base.ctx, mmGAMMA_CORR_CONTROL, 0);
+}
+
+/*
+ *****************************************************************************
+ *  Function: regamma_config_regions_and_segments
+ *
+ *     build regamma curve by using predefined hw points
+ *     uses interface parameters ,like EDID coeff.
+ *
+ * @param   : parameters   interface parameters
+ *  @return void
+ *
+ *  @note
+ *
+ *  @see
+ *
+ *****************************************************************************
+ */
+static void regamma_config_regions_and_segments(
+	struct dce110_opp *opp110, const struct pwl_params *params)
+{
+	const struct gamma_curve *curve;
+	uint32_t value = 0;
+
+	{
+		set_reg_field_value(
+			value,
+			params->arr_points[0].custom_float_x,
+			GAMMA_CORR_CNTLA_START_CNTL,
+			GAMMA_CORR_CNTLA_EXP_REGION_START);
+
+		set_reg_field_value(
+			value,
+			0,
+			GAMMA_CORR_CNTLA_START_CNTL,
+			GAMMA_CORR_CNTLA_EXP_REGION_START_SEGMENT);
+
+		dm_write_reg(opp110->base.ctx, mmGAMMA_CORR_CNTLA_START_CNTL,
+				value);
+	}
+	{
+		value = 0;
+		set_reg_field_value(
+			value,
+			params->arr_points[0].custom_float_slope,
+			GAMMA_CORR_CNTLA_SLOPE_CNTL,
+			GAMMA_CORR_CNTLA_EXP_REGION_LINEAR_SLOPE);
+
+		dm_write_reg(opp110->base.ctx,
+			mmGAMMA_CORR_CNTLA_SLOPE_CNTL, value);
+	}
+	{
+		value = 0;
+		set_reg_field_value(
+			value,
+			params->arr_points[1].custom_float_x,
+			GAMMA_CORR_CNTLA_END_CNTL1,
+			GAMMA_CORR_CNTLA_EXP_REGION_END);
+
+		dm_write_reg(opp110->base.ctx,
+			mmGAMMA_CORR_CNTLA_END_CNTL1, value);
+	}
+	{
+		value = 0;
+		set_reg_field_value(
+			value,
+			params->arr_points[2].custom_float_slope,
+			GAMMA_CORR_CNTLA_END_CNTL2,
+			GAMMA_CORR_CNTLA_EXP_REGION_END_BASE);
+
+		set_reg_field_value(
+			value,
+			params->arr_points[1].custom_float_y,
+			GAMMA_CORR_CNTLA_END_CNTL2,
+			GAMMA_CORR_CNTLA_EXP_REGION_END_SLOPE);
+
+		dm_write_reg(opp110->base.ctx,
+			mmGAMMA_CORR_CNTLA_END_CNTL2, value);
+	}
+
+	curve = params->arr_curve_points;
+
+	{
+		value = 0;
+		set_reg_field_value(
+			value,
+			curve[0].offset,
+			GAMMA_CORR_CNTLA_REGION_0_1,
+			GAMMA_CORR_CNTLA_EXP_REGION0_LUT_OFFSET);
+
+		set_reg_field_value(
+			value,
+			curve[0].segments_num,
+			GAMMA_CORR_CNTLA_REGION_0_1,
+			GAMMA_CORR_CNTLA_EXP_REGION0_NUM_SEGMENTS);
+
+		set_reg_field_value(
+			value,
+			curve[1].offset,
+			GAMMA_CORR_CNTLA_REGION_0_1,
+			GAMMA_CORR_CNTLA_EXP_REGION1_LUT_OFFSET);
+
+		set_reg_field_value(
+			value,
+			curve[1].segments_num,
+			GAMMA_CORR_CNTLA_REGION_0_1,
+			GAMMA_CORR_CNTLA_EXP_REGION1_NUM_SEGMENTS);
+
+		dm_write_reg(
+			opp110->base.ctx,
+			mmGAMMA_CORR_CNTLA_REGION_0_1,
+			value);
+	}
+
+	curve += 2;
+	{
+		value = 0;
+		set_reg_field_value(
+			value,
+			curve[0].offset,
+			GAMMA_CORR_CNTLA_REGION_2_3,
+			GAMMA_CORR_CNTLA_EXP_REGION2_LUT_OFFSET);
+
+		set_reg_field_value(
+			value,
+			curve[0].segments_num,
+			GAMMA_CORR_CNTLA_REGION_2_3,
+			GAMMA_CORR_CNTLA_EXP_REGION2_NUM_SEGMENTS);
+
+		set_reg_field_value(
+			value,
+			curve[1].offset,
+			GAMMA_CORR_CNTLA_REGION_2_3,
+			GAMMA_CORR_CNTLA_EXP_REGION3_LUT_OFFSET);
+
+		set_reg_field_value(
+			value,
+			curve[1].segments_num,
+			GAMMA_CORR_CNTLA_REGION_2_3,
+			GAMMA_CORR_CNTLA_EXP_REGION3_NUM_SEGMENTS);
+
+		dm_write_reg(opp110->base.ctx,
+			mmGAMMA_CORR_CNTLA_REGION_2_3,
+			value);
+	}
+
+	curve += 2;
+	{
+		value = 0;
+		set_reg_field_value(
+			value,
+			curve[0].offset,
+			GAMMA_CORR_CNTLA_REGION_4_5,
+			GAMMA_CORR_CNTLA_EXP_REGION4_LUT_OFFSET);
+
+		set_reg_field_value(
+			value,
+			curve[0].segments_num,
+			GAMMA_CORR_CNTLA_REGION_4_5,
+			GAMMA_CORR_CNTLA_EXP_REGION4_NUM_SEGMENTS);
+
+		set_reg_field_value(
+			value,
+			curve[1].offset,
+			GAMMA_CORR_CNTLA_REGION_4_5,
+			GAMMA_CORR_CNTLA_EXP_REGION5_LUT_OFFSET);
+
+		set_reg_field_value(
+			value,
+			curve[1].segments_num,
+			GAMMA_CORR_CNTLA_REGION_4_5,
+			GAMMA_CORR_CNTLA_EXP_REGION5_NUM_SEGMENTS);
+
+		dm_write_reg(opp110->base.ctx,
+			mmGAMMA_CORR_CNTLA_REGION_4_5,
+			value);
+	}
+
+	curve += 2;
+	{
+		value = 0;
+		set_reg_field_value(
+			value,
+			curve[0].offset,
+			GAMMA_CORR_CNTLA_REGION_6_7,
+			GAMMA_CORR_CNTLA_EXP_REGION6_LUT_OFFSET);
+
+		set_reg_field_value(
+			value,
+			curve[0].segments_num,
+			GAMMA_CORR_CNTLA_REGION_6_7,
+			GAMMA_CORR_CNTLA_EXP_REGION6_NUM_SEGMENTS);
+
+		set_reg_field_value(
+			value,
+			curve[1].offset,
+			GAMMA_CORR_CNTLA_REGION_6_7,
+			GAMMA_CORR_CNTLA_EXP_REGION7_LUT_OFFSET);
+
+		set_reg_field_value(
+			value,
+			curve[1].segments_num,
+			GAMMA_CORR_CNTLA_REGION_6_7,
+			GAMMA_CORR_CNTLA_EXP_REGION7_NUM_SEGMENTS);
+
+		dm_write_reg(opp110->base.ctx,
+			mmGAMMA_CORR_CNTLA_REGION_6_7,
+			value);
+	}
+
+	curve += 2;
+	{
+		value = 0;
+		set_reg_field_value(
+			value,
+			curve[0].offset,
+			GAMMA_CORR_CNTLA_REGION_8_9,
+			GAMMA_CORR_CNTLA_EXP_REGION8_LUT_OFFSET);
+
+		set_reg_field_value(
+			value,
+			curve[0].segments_num,
+			GAMMA_CORR_CNTLA_REGION_8_9,
+			GAMMA_CORR_CNTLA_EXP_REGION8_NUM_SEGMENTS);
+
+		set_reg_field_value(
+			value,
+			curve[1].offset,
+			GAMMA_CORR_CNTLA_REGION_8_9,
+			GAMMA_CORR_CNTLA_EXP_REGION9_LUT_OFFSET);
+
+		set_reg_field_value(
+			value,
+			curve[1].segments_num,
+			GAMMA_CORR_CNTLA_REGION_8_9,
+			GAMMA_CORR_CNTLA_EXP_REGION9_NUM_SEGMENTS);
+
+		dm_write_reg(opp110->base.ctx,
+			mmGAMMA_CORR_CNTLA_REGION_8_9,
+			value);
+	}
+
+	curve += 2;
+	{
+		value = 0;
+		set_reg_field_value(
+			value,
+			curve[0].offset,
+			GAMMA_CORR_CNTLA_REGION_10_11,
+			GAMMA_CORR_CNTLA_EXP_REGION10_LUT_OFFSET);
+
+		set_reg_field_value(
+			value,
+			curve[0].segments_num,
+			GAMMA_CORR_CNTLA_REGION_10_11,
+			GAMMA_CORR_CNTLA_EXP_REGION10_NUM_SEGMENTS);
+
+		set_reg_field_value(
+			value,
+			curve[1].offset,
+			GAMMA_CORR_CNTLA_REGION_10_11,
+			GAMMA_CORR_CNTLA_EXP_REGION11_LUT_OFFSET);
+
+		set_reg_field_value(
+			value,
+			curve[1].segments_num,
+			GAMMA_CORR_CNTLA_REGION_10_11,
+			GAMMA_CORR_CNTLA_EXP_REGION11_NUM_SEGMENTS);
+
+		dm_write_reg(opp110->base.ctx,
+			mmGAMMA_CORR_CNTLA_REGION_10_11,
+			value);
+	}
+
+	curve += 2;
+	{
+		value = 0;
+		set_reg_field_value(
+			value,
+			curve[0].offset,
+			GAMMA_CORR_CNTLA_REGION_12_13,
+			GAMMA_CORR_CNTLA_EXP_REGION12_LUT_OFFSET);
+
+		set_reg_field_value(
+			value,
+			curve[0].segments_num,
+			GAMMA_CORR_CNTLA_REGION_12_13,
+			GAMMA_CORR_CNTLA_EXP_REGION12_NUM_SEGMENTS);
+
+		set_reg_field_value(
+			value,
+			curve[1].offset,
+			GAMMA_CORR_CNTLA_REGION_12_13,
+			GAMMA_CORR_CNTLA_EXP_REGION13_LUT_OFFSET);
+
+		set_reg_field_value(
+			value,
+			curve[1].segments_num,
+			GAMMA_CORR_CNTLA_REGION_12_13,
+			GAMMA_CORR_CNTLA_EXP_REGION13_NUM_SEGMENTS);
+
+		dm_write_reg(opp110->base.ctx,
+			mmGAMMA_CORR_CNTLA_REGION_12_13,
+			value);
+	}
+
+	curve += 2;
+	{
+		value = 0;
+		set_reg_field_value(
+			value,
+			curve[0].offset,
+			GAMMA_CORR_CNTLA_REGION_14_15,
+			GAMMA_CORR_CNTLA_EXP_REGION14_LUT_OFFSET);
+
+		set_reg_field_value(
+			value,
+			curve[0].segments_num,
+			GAMMA_CORR_CNTLA_REGION_14_15,
+			GAMMA_CORR_CNTLA_EXP_REGION14_NUM_SEGMENTS);
+
+		set_reg_field_value(
+			value,
+			curve[1].offset,
+			GAMMA_CORR_CNTLA_REGION_14_15,
+			GAMMA_CORR_CNTLA_EXP_REGION15_LUT_OFFSET);
+
+		set_reg_field_value(
+			value,
+			curve[1].segments_num,
+			GAMMA_CORR_CNTLA_REGION_14_15,
+			GAMMA_CORR_CNTLA_EXP_REGION15_NUM_SEGMENTS);
+
+		dm_write_reg(opp110->base.ctx,
+			mmGAMMA_CORR_CNTLA_REGION_14_15,
+			value);
+	}
+}
+
+static void program_pwl(struct dce110_opp *opp110,
+		const struct pwl_params *params)
+{
+	uint32_t value = 0;
+
+	set_reg_field_value(
+		value,
+		7,
+		GAMMA_CORR_LUT_WRITE_EN_MASK,
+		GAMMA_CORR_LUT_WRITE_EN_MASK);
+
+	dm_write_reg(opp110->base.ctx,
+		mmGAMMA_CORR_LUT_WRITE_EN_MASK, value);
+
+	dm_write_reg(opp110->base.ctx,
+		mmGAMMA_CORR_LUT_INDEX, 0);
+
+	/* Program REGAMMA_LUT_DATA */
+	{
+		const uint32_t addr = mmGAMMA_CORR_LUT_DATA;
+		uint32_t i = 0;
+		const struct pwl_result_data *rgb =
+				params->rgb_resulted;
+
+		while (i != params->hw_points_num) {
+			dm_write_reg(opp110->base.ctx, addr, rgb->red_reg);
+			dm_write_reg(opp110->base.ctx, addr, rgb->green_reg);
+			dm_write_reg(opp110->base.ctx, addr, rgb->blue_reg);
+
+			dm_write_reg(opp110->base.ctx, addr,
+				rgb->delta_red_reg);
+			dm_write_reg(opp110->base.ctx, addr,
+				rgb->delta_green_reg);
+			dm_write_reg(opp110->base.ctx, addr,
+				rgb->delta_blue_reg);
+
+			++rgb;
+			++i;
+		}
+	}
+}
+
+bool dce110_opp_program_regamma_pwl_v(
+	struct output_pixel_processor *opp,
+	const struct pwl_params *params)
+{
+	struct dce110_opp *opp110 = TO_DCE110_OPP(opp);
+
+	/* Setup regions */
+	regamma_config_regions_and_segments(opp110, params);
+
+	set_bypass_input_gamma(opp110);
+
+	/* Power on gamma LUT memory */
+	power_on_lut(opp, true, false, true);
+
+	/* Program PWL */
+	program_pwl(opp110, params);
+
+	/* program regamma config */
+	configure_regamma_mode(opp110, 1);
+
+	/* Power return to auto back */
+	power_on_lut(opp, false, false, true);
+
+	return true;
+}
+
+void dce110_opp_power_on_regamma_lut_v(
+	struct output_pixel_processor *opp,
+	bool power_on)
+{
+	uint32_t value = dm_read_reg(opp->ctx, mmDCFEV_MEM_PWR_CTRL);
+
+	set_reg_field_value(
+		value,
+		0,
+		DCFEV_MEM_PWR_CTRL,
+		COL_MAN_GAMMA_CORR_MEM_PWR_FORCE);
+
+	set_reg_field_value(
+		value,
+		power_on,
+		DCFEV_MEM_PWR_CTRL,
+		COL_MAN_GAMMA_CORR_MEM_PWR_DIS);
+
+	set_reg_field_value(
+		value,
+		0,
+		DCFEV_MEM_PWR_CTRL,
+		COL_MAN_INPUT_GAMMA_MEM_PWR_FORCE);
+
+	set_reg_field_value(
+		value,
+		power_on,
+		DCFEV_MEM_PWR_CTRL,
+		COL_MAN_INPUT_GAMMA_MEM_PWR_DIS);
+
+	dm_write_reg(opp->ctx, mmDCFEV_MEM_PWR_CTRL, value);
+}
