commit 12e2b2d4c65f6164830e25fcd9624519a424b182
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jul 3 16:20:42 2019 -0400

    drm/amd/display: add dcc programming for dual plane
    
    Add dual plane dcc programming support for
    surfaces.
    
    Removes unions from plane size and dcc params as they
    serve no practical purpose only making our code
    more convoluted. This results in easy dual plane
    dcc and surface size programming.
    
    Temporary diags_dm code is used to handle the interface
    change without breaking functionality as a diags change
    needs to be applied after this one.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
index 9b9fc3d96c07..d54172d88f5f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
@@ -229,26 +229,26 @@ static void program_tiling(
 static void program_size_and_rotation(
 	struct dce_mem_input *mem_input110,
 	enum dc_rotation_angle rotation,
-	const union plane_size *plane_size)
+	const struct plane_size *plane_size)
 {
 	uint32_t value = 0;
-	union plane_size local_size = *plane_size;
+	struct plane_size local_size = *plane_size;
 
 	if (rotation == ROTATION_ANGLE_90 ||
 		rotation == ROTATION_ANGLE_270) {
 
-		swap(local_size.video.luma_size.x,
-		     local_size.video.luma_size.y);
-		swap(local_size.video.luma_size.width,
-		     local_size.video.luma_size.height);
-		swap(local_size.video.chroma_size.x,
-		     local_size.video.chroma_size.y);
-		swap(local_size.video.chroma_size.width,
-		     local_size.video.chroma_size.height);
+		swap(local_size.surface_size.x,
+		     local_size.surface_size.y);
+		swap(local_size.surface_size.width,
+		     local_size.surface_size.height);
+		swap(local_size.chroma_size.x,
+		     local_size.chroma_size.y);
+		swap(local_size.chroma_size.width,
+		     local_size.chroma_size.height);
 	}
 
 	value = 0;
-	set_reg_field_value(value, local_size.video.luma_pitch,
+	set_reg_field_value(value, local_size.surface_pitch,
 			UNP_GRPH_PITCH_L, GRPH_PITCH_L);
 
 	dm_write_reg(
@@ -257,7 +257,7 @@ static void program_size_and_rotation(
 		value);
 
 	value = 0;
-	set_reg_field_value(value, local_size.video.chroma_pitch,
+	set_reg_field_value(value, local_size.chroma_pitch,
 			UNP_GRPH_PITCH_C, GRPH_PITCH_C);
 	dm_write_reg(
 		mem_input110->base.ctx,
@@ -297,8 +297,8 @@ static void program_size_and_rotation(
 		value);
 
 	value = 0;
-	set_reg_field_value(value, local_size.video.luma_size.x +
-			local_size.video.luma_size.width,
+	set_reg_field_value(value, local_size.surface_size.x +
+			local_size.surface_size.width,
 			UNP_GRPH_X_END_L, GRPH_X_END_L);
 	dm_write_reg(
 		mem_input110->base.ctx,
@@ -306,8 +306,8 @@ static void program_size_and_rotation(
 		value);
 
 	value = 0;
-	set_reg_field_value(value, local_size.video.chroma_size.x +
-			local_size.video.chroma_size.width,
+	set_reg_field_value(value, local_size.chroma_size.x +
+			local_size.chroma_size.width,
 			UNP_GRPH_X_END_C, GRPH_X_END_C);
 	dm_write_reg(
 		mem_input110->base.ctx,
@@ -315,8 +315,8 @@ static void program_size_and_rotation(
 		value);
 
 	value = 0;
-	set_reg_field_value(value, local_size.video.luma_size.y +
-			local_size.video.luma_size.height,
+	set_reg_field_value(value, local_size.surface_size.y +
+			local_size.surface_size.height,
 			UNP_GRPH_Y_END_L, GRPH_Y_END_L);
 	dm_write_reg(
 		mem_input110->base.ctx,
@@ -324,8 +324,8 @@ static void program_size_and_rotation(
 		value);
 
 	value = 0;
-	set_reg_field_value(value, local_size.video.chroma_size.y +
-			local_size.video.chroma_size.height,
+	set_reg_field_value(value, local_size.chroma_size.y +
+			local_size.chroma_size.height,
 			UNP_GRPH_Y_END_C, GRPH_Y_END_C);
 	dm_write_reg(
 		mem_input110->base.ctx,
@@ -637,7 +637,7 @@ void dce_mem_input_v_program_surface_config(
 	struct mem_input *mem_input,
 	enum surface_pixel_format format,
 	union dc_tiling_info *tiling_info,
-	union plane_size *plane_size,
+	struct plane_size *plane_size,
 	enum dc_rotation_angle rotation,
 	struct dc_plane_dcc_param *dcc,
 	bool horizotal_mirror)

commit a14cc8422a2601348bc5279c1d849920e91170f2
Author: Christian König <christian.koenig@amd.com>
Date:   Fri Jul 6 14:19:07 2018 +0200

    drm/amd/display: make function tables const
    
    It is good practice to make global function tables const to avoid
    accidental override.
    
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
index 0564c8e31252..9b9fc3d96c07 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
@@ -1011,7 +1011,7 @@ void dce110_free_mem_input_v(
 {
 }
 
-static struct mem_input_funcs dce110_mem_input_v_funcs = {
+static const struct mem_input_funcs dce110_mem_input_v_funcs = {
 	.mem_input_program_display_marks =
 			dce_mem_input_v_program_display_marks,
 	.mem_input_program_chroma_display_marks =

commit 3722c794641f91e0b960dd901d6c5d2f3cc24080
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Wed Feb 21 16:57:10 2018 -0500

    drm/amd/display: Implementing new bandwidth registers for DCE120
    
    Registers are added and defined.
    Programmed to default values.
    Stutter level watermark register is being set to calculated value.
    Urgent level registers are programmed to the same as urgency.
    The programming of the registers is not expected to have any
    functional difference in performance.
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
index 7bab8c6d2a73..0564c8e31252 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
@@ -923,6 +923,7 @@ void dce_mem_input_v_program_display_marks(
 	struct mem_input *mem_input,
 	struct dce_watermarks nbp,
 	struct dce_watermarks stutter,
+	struct dce_watermarks stutter_enter,
 	struct dce_watermarks urgent,
 	uint32_t total_dest_line_time_ns)
 {

commit 8aa111e34deedded58cd8576755f31659ba676f5
Author: Gustavo A. R. Silva <garsilva@embeddedor.com>
Date:   Fri Nov 10 16:31:09 2017 -0600

    drm/amd/display/dc/dce110/dce110_mem_input_v: use swap macro in program_size_and_rotation
    
    Make use of the swap macro instead of _manually_ swapping values
    and remove unnecessary variable swap.
    
    This makes the code easier to read and maintain.
    
    This code was detected with the help of Coccinelle.
    
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
index a06c6024deb4..7bab8c6d2a73 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
@@ -237,26 +237,14 @@ static void program_size_and_rotation(
 	if (rotation == ROTATION_ANGLE_90 ||
 		rotation == ROTATION_ANGLE_270) {
 
-		uint32_t swap;
-		swap = local_size.video.luma_size.x;
-		local_size.video.luma_size.x =
-			local_size.video.luma_size.y;
-		local_size.video.luma_size.y  = swap;
-
-		swap = local_size.video.luma_size.width;
-		local_size.video.luma_size.width =
-			local_size.video.luma_size.height;
-		local_size.video.luma_size.height = swap;
-
-		swap = local_size.video.chroma_size.x;
-		local_size.video.chroma_size.x =
-			local_size.video.chroma_size.y;
-		local_size.video.chroma_size.y  = swap;
-
-		swap = local_size.video.chroma_size.width;
-		local_size.video.chroma_size.width =
-			local_size.video.chroma_size.height;
-		local_size.video.chroma_size.height = swap;
+		swap(local_size.video.luma_size.x,
+		     local_size.video.luma_size.y);
+		swap(local_size.video.luma_size.width,
+		     local_size.video.luma_size.height);
+		swap(local_size.video.chroma_size.x,
+		     local_size.video.chroma_size.y);
+		swap(local_size.video.chroma_size.width,
+		     local_size.video.chroma_size.height);
 	}
 
 	value = 0;

commit 0a1c73ec8e4834d72441ae77f436869fd5179d8f
Author: Shirish S <shirish.s@amd.com>
Date:   Thu May 25 14:40:21 2017 +0530

    drm/amd/display: re-order the luma chroma addres updation
    
    The DCE engine triggers scan as soon as the luma
    address is updated, since it is updated before chroma address
    the chroma data is not scanned out properly or in order.
    This patch fixes this by re-ordering the same.
    
    BUG: SWDEV-119421
    TEST: (On Chromium OS for Stoney Only)
        * Executed below tests to see YUV(underlay) & RGB planes on eDP
          plane_test --format XR24 --size 500x100 -p --format NV12 --size 500x500
        * Chroma data is scanned properly.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
index 9777a4d961d5..a06c6024deb4 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
@@ -137,12 +137,12 @@ static void program_addr(
 			addr->grph.addr);
 		break;
 	case PLN_ADDR_TYPE_VIDEO_PROGRESSIVE:
-		program_pri_addr_l(
-			mem_input110,
-			addr->video_progressive.luma_addr);
 		program_pri_addr_c(
 			mem_input110,
 			addr->video_progressive.chroma_addr);
+		program_pri_addr_l(
+			mem_input110,
+			addr->video_progressive.luma_addr);
 		break;
 	default:
 		/* not supported */

commit c34892144d38eddb4499ac425c24455b1e34dd61
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon May 15 08:31:51 2017 -0400

    drm/amd/display: dce 8 - 12 mem_input refactor to new style
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
index 78dd3ae3af5f..9777a4d961d5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
@@ -33,29 +33,17 @@
 #include "include/logger_interface.h"
 #include "inc/dce_calcs.h"
 
-#include "dce110_mem_input.h"
-
-#define DCP_REG(reg) (reg + mem_input110->offsets.dcp)
-/*#define DMIF_REG(reg) (reg + mem_input110->offsets.dmif)*/
-/*#define PIPE_REG(reg) (reg + mem_input110->offsets.pipe)*/
-
-static const struct dce110_mem_input_reg_offsets dce110_mi_v_reg_offsets[] = {
-	{
-		.dcp = 0,
-		.dmif = 0,
-		.pipe = 0,
-	}
-};
+#include "dce/dce_mem_input.h"
 
 static void set_flip_control(
-	struct dce110_mem_input *mem_input110,
+	struct dce_mem_input *mem_input110,
 	bool immediate)
 {
 	uint32_t value = 0;
 
 	value = dm_read_reg(
 			mem_input110->base.ctx,
-			DCP_REG(mmUNP_FLIP_CONTROL));
+			mmUNP_FLIP_CONTROL);
 
 	set_reg_field_value(value, 1,
 			UNP_FLIP_CONTROL,
@@ -63,13 +51,13 @@ static void set_flip_control(
 
 	dm_write_reg(
 			mem_input110->base.ctx,
-			DCP_REG(mmUNP_FLIP_CONTROL),
+			mmUNP_FLIP_CONTROL,
 			value);
 }
 
 /* chroma part */
 static void program_pri_addr_c(
-	struct dce110_mem_input *mem_input110,
+	struct dce_mem_input *mem_input110,
 	PHYSICAL_ADDRESS_LOC address)
 {
 	uint32_t value = 0;
@@ -84,7 +72,7 @@ UNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_C__GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_C_MAS
 
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_C),
+		mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_C,
 		value);
 
 	temp = 0;
@@ -98,13 +86,13 @@ UNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_C__GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_C_MAS
 
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_C),
+		mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_C,
 		value);
 }
 
 /* luma part */
 static void program_pri_addr_l(
-	struct dce110_mem_input *mem_input110,
+	struct dce_mem_input *mem_input110,
 	PHYSICAL_ADDRESS_LOC address)
 {
 	uint32_t value = 0;
@@ -120,7 +108,7 @@ UNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_L__GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_L_MAS
 
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_L),
+		mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_L,
 		value);
 
 	temp = 0;
@@ -134,12 +122,12 @@ UNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_L__GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_L_MAS
 
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_L),
+		mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_L,
 		value);
 }
 
 static void program_addr(
-	struct dce110_mem_input *mem_input110,
+	struct dce_mem_input *mem_input110,
 	const struct dc_plane_address *addr)
 {
 	switch (addr->type) {
@@ -162,19 +150,19 @@ static void program_addr(
 	}
 }
 
-static void enable(struct dce110_mem_input *mem_input110)
+static void enable(struct dce_mem_input *mem_input110)
 {
 	uint32_t value = 0;
 
-	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_GRPH_ENABLE));
+	value = dm_read_reg(mem_input110->base.ctx, mmUNP_GRPH_ENABLE);
 	set_reg_field_value(value, 1, UNP_GRPH_ENABLE, GRPH_ENABLE);
 	dm_write_reg(mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_ENABLE),
+		mmUNP_GRPH_ENABLE,
 		value);
 }
 
 static void program_tiling(
-	struct dce110_mem_input *mem_input110,
+	struct dce_mem_input *mem_input110,
 	const union dc_tiling_info *info,
 	const enum surface_pixel_format pixel_format)
 {
@@ -239,7 +227,7 @@ static void program_tiling(
 }
 
 static void program_size_and_rotation(
-	struct dce110_mem_input *mem_input110,
+	struct dce_mem_input *mem_input110,
 	enum dc_rotation_angle rotation,
 	const union plane_size *plane_size)
 {
@@ -277,7 +265,7 @@ static void program_size_and_rotation(
 
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_PITCH_L),
+		mmUNP_GRPH_PITCH_L,
 		value);
 
 	value = 0;
@@ -285,7 +273,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_PITCH_C, GRPH_PITCH_C);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_PITCH_C),
+		mmUNP_GRPH_PITCH_C,
 		value);
 
 	value = 0;
@@ -293,7 +281,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_X_START_L, GRPH_X_START_L);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_X_START_L),
+		mmUNP_GRPH_X_START_L,
 		value);
 
 	value = 0;
@@ -301,7 +289,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_X_START_C, GRPH_X_START_C);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_X_START_C),
+		mmUNP_GRPH_X_START_C,
 		value);
 
 	value = 0;
@@ -309,7 +297,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_Y_START_L, GRPH_Y_START_L);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_Y_START_L),
+		mmUNP_GRPH_Y_START_L,
 		value);
 
 	value = 0;
@@ -317,7 +305,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_Y_START_C, GRPH_Y_START_C);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_Y_START_C),
+		mmUNP_GRPH_Y_START_C,
 		value);
 
 	value = 0;
@@ -326,7 +314,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_X_END_L, GRPH_X_END_L);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_X_END_L),
+		mmUNP_GRPH_X_END_L,
 		value);
 
 	value = 0;
@@ -335,7 +323,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_X_END_C, GRPH_X_END_C);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_X_END_C),
+		mmUNP_GRPH_X_END_C,
 		value);
 
 	value = 0;
@@ -344,7 +332,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_Y_END_L, GRPH_Y_END_L);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_Y_END_L),
+		mmUNP_GRPH_Y_END_L,
 		value);
 
 	value = 0;
@@ -353,7 +341,7 @@ static void program_size_and_rotation(
 			UNP_GRPH_Y_END_C, GRPH_Y_END_C);
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_GRPH_Y_END_C),
+		mmUNP_GRPH_Y_END_C,
 		value);
 
 	value = 0;
@@ -378,12 +366,12 @@ static void program_size_and_rotation(
 
 	dm_write_reg(
 		mem_input110->base.ctx,
-		DCP_REG(mmUNP_HW_ROTATION),
+		mmUNP_HW_ROTATION,
 		value);
 }
 
 static void program_pixel_format(
-	struct dce110_mem_input *mem_input110,
+	struct dce_mem_input *mem_input110,
 	enum surface_pixel_format format)
 {
 	if (format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {
@@ -393,7 +381,7 @@ static void program_pixel_format(
 
 		value =	dm_read_reg(
 				mem_input110->base.ctx,
-				DCP_REG(mmUNP_GRPH_CONTROL));
+				mmUNP_GRPH_CONTROL);
 
 		switch (format) {
 		case SURFACE_PIXEL_FORMAT_GRPH_PALETA_256_COLORS:
@@ -440,12 +428,12 @@ static void program_pixel_format(
 
 		dm_write_reg(
 				mem_input110->base.ctx,
-				DCP_REG(mmUNP_GRPH_CONTROL),
+				mmUNP_GRPH_CONTROL,
 				value);
 
 		value =	dm_read_reg(
 				mem_input110->base.ctx,
-				DCP_REG(mmUNP_GRPH_CONTROL_EXP));
+				mmUNP_GRPH_CONTROL_EXP);
 
 		/* VIDEO FORMAT 0 */
 		set_reg_field_value(
@@ -455,7 +443,7 @@ static void program_pixel_format(
 				VIDEO_FORMAT);
 		dm_write_reg(
 				mem_input110->base.ctx,
-				DCP_REG(mmUNP_GRPH_CONTROL_EXP),
+				mmUNP_GRPH_CONTROL_EXP,
 				value);
 
 	} else {
@@ -465,7 +453,7 @@ static void program_pixel_format(
 
 		value =	dm_read_reg(
 				mem_input110->base.ctx,
-				DCP_REG(mmUNP_GRPH_CONTROL_EXP));
+				mmUNP_GRPH_CONTROL_EXP);
 
 		switch (format) {
 		case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
@@ -487,17 +475,17 @@ static void program_pixel_format(
 
 		dm_write_reg(
 			mem_input110->base.ctx,
-			DCP_REG(mmUNP_GRPH_CONTROL_EXP),
+			mmUNP_GRPH_CONTROL_EXP,
 			value);
 	}
 }
 
-bool dce110_mem_input_v_is_surface_pending(struct mem_input *mem_input)
+bool dce_mem_input_v_is_surface_pending(struct mem_input *mem_input)
 {
-	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
+	struct dce_mem_input *mem_input110 = TO_DCE_MEM_INPUT(mem_input);
 	uint32_t value;
 
-	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_GRPH_UPDATE));
+	value = dm_read_reg(mem_input110->base.ctx, mmUNP_GRPH_UPDATE);
 
 	if (get_reg_field_value(value, UNP_GRPH_UPDATE,
 			GRPH_SURFACE_UPDATE_PENDING))
@@ -507,12 +495,12 @@ bool dce110_mem_input_v_is_surface_pending(struct mem_input *mem_input)
 	return false;
 }
 
-bool dce110_mem_input_v_program_surface_flip_and_addr(
+bool dce_mem_input_v_program_surface_flip_and_addr(
 	struct mem_input *mem_input,
 	const struct dc_plane_address *address,
 	bool flip_immediate)
 {
-	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
+	struct dce_mem_input *mem_input110 = TO_DCE_MEM_INPUT(mem_input);
 
 	set_flip_control(mem_input110, flip_immediate);
 	program_addr(mem_input110,
@@ -584,13 +572,13 @@ static const unsigned int *get_dvmm_hw_setting(
 	}
 }
 
-void dce110_mem_input_v_program_pte_vm(
+void dce_mem_input_v_program_pte_vm(
 		struct mem_input *mem_input,
 		enum surface_pixel_format format,
 		union dc_tiling_info *tiling_info,
 		enum dc_rotation_angle rotation)
 {
-	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
+	struct dce_mem_input *mem_input110 = TO_DCE_MEM_INPUT(mem_input);
 	const unsigned int *pte = get_dvmm_hw_setting(tiling_info, format, false);
 	const unsigned int *pte_chroma = get_dvmm_hw_setting(tiling_info, format, true);
 
@@ -628,36 +616,36 @@ void dce110_mem_input_v_program_pte_vm(
 		break;
 	}
 
-	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_PIPE_OUTSTANDING_REQUEST_LIMIT));
+	value = dm_read_reg(mem_input110->base.ctx, mmUNP_PIPE_OUTSTANDING_REQUEST_LIMIT);
 	/* TODO: un-hardcode requestlimit */
 	set_reg_field_value(value, 0xff, UNP_PIPE_OUTSTANDING_REQUEST_LIMIT, UNP_PIPE_OUTSTANDING_REQUEST_LIMIT_L);
 	set_reg_field_value(value, 0xff, UNP_PIPE_OUTSTANDING_REQUEST_LIMIT, UNP_PIPE_OUTSTANDING_REQUEST_LIMIT_C);
-	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_PIPE_OUTSTANDING_REQUEST_LIMIT), value);
+	dm_write_reg(mem_input110->base.ctx, mmUNP_PIPE_OUTSTANDING_REQUEST_LIMIT, value);
 
-	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_CONTROL));
+	value = dm_read_reg(mem_input110->base.ctx, mmUNP_DVMM_PTE_CONTROL);
 	set_reg_field_value(value, page_width, UNP_DVMM_PTE_CONTROL, DVMM_PAGE_WIDTH);
 	set_reg_field_value(value, page_height, UNP_DVMM_PTE_CONTROL, DVMM_PAGE_HEIGHT);
 	set_reg_field_value(value, min_pte_before_flip, UNP_DVMM_PTE_CONTROL, DVMM_MIN_PTE_BEFORE_FLIP);
-	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_CONTROL), value);
+	dm_write_reg(mem_input110->base.ctx, mmUNP_DVMM_PTE_CONTROL, value);
 
-	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_ARB_CONTROL));
+	value = dm_read_reg(mem_input110->base.ctx, mmUNP_DVMM_PTE_ARB_CONTROL);
 	set_reg_field_value(value, pte[5], UNP_DVMM_PTE_ARB_CONTROL, DVMM_PTE_REQ_PER_CHUNK);
 	set_reg_field_value(value, 0xff, UNP_DVMM_PTE_ARB_CONTROL, DVMM_MAX_PTE_REQ_OUTSTANDING);
-	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_ARB_CONTROL), value);
+	dm_write_reg(mem_input110->base.ctx, mmUNP_DVMM_PTE_ARB_CONTROL, value);
 
-	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_CONTROL_C));
+	value = dm_read_reg(mem_input110->base.ctx, mmUNP_DVMM_PTE_CONTROL_C);
 	set_reg_field_value(value, page_width_chroma, UNP_DVMM_PTE_CONTROL_C, DVMM_PAGE_WIDTH_C);
 	set_reg_field_value(value, page_height_chroma, UNP_DVMM_PTE_CONTROL_C, DVMM_PAGE_HEIGHT_C);
 	set_reg_field_value(value, min_pte_before_flip_chroma, UNP_DVMM_PTE_CONTROL_C, DVMM_MIN_PTE_BEFORE_FLIP_C);
-	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_CONTROL_C), value);
+	dm_write_reg(mem_input110->base.ctx, mmUNP_DVMM_PTE_CONTROL_C, value);
 
-	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_ARB_CONTROL_C));
+	value = dm_read_reg(mem_input110->base.ctx, mmUNP_DVMM_PTE_ARB_CONTROL_C);
 	set_reg_field_value(value, pte_chroma[5], UNP_DVMM_PTE_ARB_CONTROL_C, DVMM_PTE_REQ_PER_CHUNK_C);
 	set_reg_field_value(value, 0xff, UNP_DVMM_PTE_ARB_CONTROL_C, DVMM_MAX_PTE_REQ_OUTSTANDING_C);
-	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_ARB_CONTROL_C), value);
+	dm_write_reg(mem_input110->base.ctx, mmUNP_DVMM_PTE_ARB_CONTROL_C, value);
 }
 
-void dce110_mem_input_v_program_surface_config(
+void dce_mem_input_v_program_surface_config(
 	struct mem_input *mem_input,
 	enum surface_pixel_format format,
 	union dc_tiling_info *tiling_info,
@@ -666,7 +654,7 @@ void dce110_mem_input_v_program_surface_config(
 	struct dc_plane_dcc_param *dcc,
 	bool horizotal_mirror)
 {
-	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
+	struct dce_mem_input *mem_input110 = TO_DCE_MEM_INPUT(mem_input);
 
 	enable(mem_input110);
 	program_tiling(mem_input110, tiling_info, format);
@@ -943,7 +931,7 @@ static void program_nbp_watermark_c(
 			marks);
 }
 
-void dce110_mem_input_v_program_display_marks(
+void dce_mem_input_v_program_display_marks(
 	struct mem_input *mem_input,
 	struct dce_watermarks nbp,
 	struct dce_watermarks stutter,
@@ -965,7 +953,7 @@ void dce110_mem_input_v_program_display_marks(
 
 }
 
-void dce110_mem_input_program_chroma_display_marks(
+void dce_mem_input_program_chroma_display_marks(
 	struct mem_input *mem_input,
 	struct dce_watermarks nbp,
 	struct dce_watermarks stutter,
@@ -1036,42 +1024,29 @@ void dce110_free_mem_input_v(
 
 static struct mem_input_funcs dce110_mem_input_v_funcs = {
 	.mem_input_program_display_marks =
-			dce110_mem_input_v_program_display_marks,
+			dce_mem_input_v_program_display_marks,
 	.mem_input_program_chroma_display_marks =
-			dce110_mem_input_program_chroma_display_marks,
+			dce_mem_input_program_chroma_display_marks,
 	.allocate_mem_input = dce110_allocate_mem_input_v,
 	.free_mem_input = dce110_free_mem_input_v,
 	.mem_input_program_surface_flip_and_addr =
-			dce110_mem_input_v_program_surface_flip_and_addr,
+			dce_mem_input_v_program_surface_flip_and_addr,
 	.mem_input_program_pte_vm =
-			dce110_mem_input_v_program_pte_vm,
+			dce_mem_input_v_program_pte_vm,
 	.mem_input_program_surface_config =
-			dce110_mem_input_v_program_surface_config,
+			dce_mem_input_v_program_surface_config,
 	.mem_input_is_flip_pending =
-			dce110_mem_input_v_is_surface_pending
+			dce_mem_input_v_is_surface_pending
 };
 /*****************************************/
 /* Constructor, Destructor               */
 /*****************************************/
 
-bool dce110_mem_input_v_construct(
-	struct dce110_mem_input *mem_input110,
+void dce110_mem_input_v_construct(
+	struct dce_mem_input *dce_mi,
 	struct dc_context *ctx)
 {
-	mem_input110->base.funcs = &dce110_mem_input_v_funcs;
-	mem_input110->base.ctx = ctx;
-
-	mem_input110->base.inst = 0;
-
-	mem_input110->offsets = dce110_mi_v_reg_offsets[0];
-
-	return true;
+	dce_mi->base.funcs = &dce110_mem_input_v_funcs;
+	dce_mi->base.ctx = ctx;
 }
 
-#if 0
-void dce110_mem_input_v_destroy(struct mem_input **mem_input)
-{
-	dm_free(TO_DCE110_MEM_INPUT(*mem_input));
-	*mem_input = NULL;
-}
-#endif

commit 4b28b76bfe14430a91de74a5cf9215f3c108acf9
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu May 11 17:15:14 2017 -0400

    drm/amd/display: fix mpo blanking out on one of planes being set not visible
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
index 02739d3efa97..78dd3ae3af5f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
@@ -664,8 +664,7 @@ void dce110_mem_input_v_program_surface_config(
 	union plane_size *plane_size,
 	enum dc_rotation_angle rotation,
 	struct dc_plane_dcc_param *dcc,
-	bool horizotal_mirror,
-	bool visible)
+	bool horizotal_mirror)
 {
 	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
 

commit 9037d802a97812cb8d614b48f817a5532cf1558c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue May 2 17:29:48 2017 -0400

    drm/amd/display: refactor bw related variable structure in val_ctx
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
index 9c32b5bbdff5..02739d3efa97 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
@@ -679,7 +679,7 @@ static void program_urgency_watermark(
 	const struct dc_context *ctx,
 	const uint32_t urgency_addr,
 	const uint32_t wm_addr,
-	struct bw_watermarks marks_low,
+	struct dce_watermarks marks_low,
 	uint32_t total_dest_line_time_ns)
 {
 	/* register value */
@@ -734,7 +734,7 @@ static void program_urgency_watermark(
 
 static void program_urgency_watermark_l(
 	const struct dc_context *ctx,
-	struct bw_watermarks marks_low,
+	struct dce_watermarks marks_low,
 	uint32_t total_dest_line_time_ns)
 {
 	program_urgency_watermark(
@@ -747,7 +747,7 @@ static void program_urgency_watermark_l(
 
 static void program_urgency_watermark_c(
 	const struct dc_context *ctx,
-	struct bw_watermarks marks_low,
+	struct dce_watermarks marks_low,
 	uint32_t total_dest_line_time_ns)
 {
 	program_urgency_watermark(
@@ -762,7 +762,7 @@ static void program_stutter_watermark(
 	const struct dc_context *ctx,
 	const uint32_t stutter_addr,
 	const uint32_t wm_addr,
-	struct bw_watermarks marks)
+	struct dce_watermarks marks)
 {
 	/* register value */
 	uint32_t stutter_cntl = 0;
@@ -822,7 +822,7 @@ static void program_stutter_watermark(
 
 static void program_stutter_watermark_l(
 	const struct dc_context *ctx,
-	struct bw_watermarks marks)
+	struct dce_watermarks marks)
 {
 	program_stutter_watermark(ctx,
 			mmDPGV0_PIPE_STUTTER_CONTROL,
@@ -832,7 +832,7 @@ static void program_stutter_watermark_l(
 
 static void program_stutter_watermark_c(
 	const struct dc_context *ctx,
-	struct bw_watermarks marks)
+	struct dce_watermarks marks)
 {
 	program_stutter_watermark(ctx,
 			mmDPGV1_PIPE_STUTTER_CONTROL,
@@ -844,7 +844,7 @@ static void program_nbp_watermark(
 	const struct dc_context *ctx,
 	const uint32_t wm_mask_ctrl_addr,
 	const uint32_t nbp_pstate_ctrl_addr,
-	struct bw_watermarks marks)
+	struct dce_watermarks marks)
 {
 	uint32_t value;
 
@@ -926,7 +926,7 @@ static void program_nbp_watermark(
 
 static void program_nbp_watermark_l(
 	const struct dc_context *ctx,
-	struct bw_watermarks marks)
+	struct dce_watermarks marks)
 {
 	program_nbp_watermark(ctx,
 			mmDPGV0_WATERMARK_MASK_CONTROL,
@@ -936,7 +936,7 @@ static void program_nbp_watermark_l(
 
 static void program_nbp_watermark_c(
 	const struct dc_context *ctx,
-	struct bw_watermarks marks)
+	struct dce_watermarks marks)
 {
 	program_nbp_watermark(ctx,
 			mmDPGV1_WATERMARK_MASK_CONTROL,
@@ -946,9 +946,9 @@ static void program_nbp_watermark_c(
 
 void dce110_mem_input_v_program_display_marks(
 	struct mem_input *mem_input,
-	struct bw_watermarks nbp,
-	struct bw_watermarks stutter,
-	struct bw_watermarks urgent,
+	struct dce_watermarks nbp,
+	struct dce_watermarks stutter,
+	struct dce_watermarks urgent,
 	uint32_t total_dest_line_time_ns)
 {
 	program_urgency_watermark_l(
@@ -968,9 +968,9 @@ void dce110_mem_input_v_program_display_marks(
 
 void dce110_mem_input_program_chroma_display_marks(
 	struct mem_input *mem_input,
-	struct bw_watermarks nbp,
-	struct bw_watermarks stutter,
-	struct bw_watermarks urgent,
+	struct dce_watermarks nbp,
+	struct dce_watermarks stutter,
+	struct dce_watermarks urgent,
 	uint32_t total_dest_line_time_ns)
 {
 	program_urgency_watermark_c(

commit 5e141de45218d36a6b98c783834684fd0d617f7a
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Mar 21 18:17:12 2017 -0400

    drm/amd/display: Rename bandwidth_calcs.h to dce_calcs.h
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
index aac47955e9bf..9c32b5bbdff5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
@@ -31,7 +31,7 @@
 #include "gmc/gmc_8_2_sh_mask.h"
 
 #include "include/logger_interface.h"
-#include "inc/bandwidth_calcs.h"
+#include "inc/dce_calcs.h"
 
 #include "dce110_mem_input.h"
 

commit 8693049a896c2c3a2bb74f0efde62318636beaef
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Mon Jan 16 20:50:47 2017 -0500

    drm/amd/display: rename BGRA8888 to ABGR8888
    
    DC actually support ABGR8888 instead of BGRA8888 (R/B swap rather than endian swap) ,
    rename to avoid confusion
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
index b12506adcba4..aac47955e9bf 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
@@ -405,7 +405,7 @@ static void program_pixel_format(
 			grph_format = 1;
 			break;
 		case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
-		case SURFACE_PIXEL_FORMAT_GRPH_BGRA8888:
+		case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
 			grph_depth = 2;
 			grph_format = 0;
 			break;

commit 624d7c4708b27be2dc095579394efadd80f090dd
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Jan 9 09:42:33 2017 -0500

    drm/amd/display: Pass visible flag into surface programming
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
index 757e946d0837..b12506adcba4 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
@@ -664,7 +664,8 @@ void dce110_mem_input_v_program_surface_config(
 	union plane_size *plane_size,
 	enum dc_rotation_angle rotation,
 	struct dc_plane_dcc_param *dcc,
-	bool horizotal_mirror)
+	bool horizotal_mirror,
+	bool visible)
 {
 	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
 

commit 197062bf12d7a516ea96e24859fe5981e30ea9ff
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Wed Nov 30 16:15:47 2016 -0500

    drm/amd/display: refactor DCE11 DVVM
    
    - move to new programming style
    - clean up table to make it obvious what we are programming
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
index f0310bab4030..757e946d0837 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
@@ -584,7 +584,7 @@ static const unsigned int *get_dvmm_hw_setting(
 	}
 }
 
-bool dce110_mem_input_v_program_pte_vm(
+void dce110_mem_input_v_program_pte_vm(
 		struct mem_input *mem_input,
 		enum surface_pixel_format format,
 		union dc_tiling_info *tiling_info,
@@ -655,11 +655,9 @@ bool dce110_mem_input_v_program_pte_vm(
 	set_reg_field_value(value, pte_chroma[5], UNP_DVMM_PTE_ARB_CONTROL_C, DVMM_PTE_REQ_PER_CHUNK_C);
 	set_reg_field_value(value, 0xff, UNP_DVMM_PTE_ARB_CONTROL_C, DVMM_MAX_PTE_REQ_OUTSTANDING_C);
 	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_ARB_CONTROL_C), value);
-
-	return true;
 }
 
-bool dce110_mem_input_v_program_surface_config(
+void dce110_mem_input_v_program_surface_config(
 	struct mem_input *mem_input,
 	enum surface_pixel_format format,
 	union dc_tiling_info *tiling_info,
@@ -674,8 +672,6 @@ bool dce110_mem_input_v_program_surface_config(
 	program_tiling(mem_input110, tiling_info, format);
 	program_size_and_rotation(mem_input110, rotation, plane_size);
 	program_pixel_format(mem_input110, format);
-
-	return true;
 }
 
 static void program_urgency_watermark(

commit 4562236b3bc0a28aeb6ee93b2d8a849a4c4e1c7c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 12 15:58:20 2017 -0400

    drm/amd/dc: Add dc display driver (v2)
    
    Supported DCE versions: 8.0, 10.0, 11.0, 11.2
    
    v2: rebase against 4.11
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
new file mode 100644
index 000000000000..f0310bab4030
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_mem_input_v.c
@@ -0,0 +1,1081 @@
+/*
+ * Copyright 2012-16 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+#include "dm_services.h"
+
+#include "dce/dce_11_0_d.h"
+#include "dce/dce_11_0_sh_mask.h"
+/* TODO: this needs to be looked at, used by Stella's workaround*/
+#include "gmc/gmc_8_2_d.h"
+#include "gmc/gmc_8_2_sh_mask.h"
+
+#include "include/logger_interface.h"
+#include "inc/bandwidth_calcs.h"
+
+#include "dce110_mem_input.h"
+
+#define DCP_REG(reg) (reg + mem_input110->offsets.dcp)
+/*#define DMIF_REG(reg) (reg + mem_input110->offsets.dmif)*/
+/*#define PIPE_REG(reg) (reg + mem_input110->offsets.pipe)*/
+
+static const struct dce110_mem_input_reg_offsets dce110_mi_v_reg_offsets[] = {
+	{
+		.dcp = 0,
+		.dmif = 0,
+		.pipe = 0,
+	}
+};
+
+static void set_flip_control(
+	struct dce110_mem_input *mem_input110,
+	bool immediate)
+{
+	uint32_t value = 0;
+
+	value = dm_read_reg(
+			mem_input110->base.ctx,
+			DCP_REG(mmUNP_FLIP_CONTROL));
+
+	set_reg_field_value(value, 1,
+			UNP_FLIP_CONTROL,
+			GRPH_SURFACE_UPDATE_PENDING_MODE);
+
+	dm_write_reg(
+			mem_input110->base.ctx,
+			DCP_REG(mmUNP_FLIP_CONTROL),
+			value);
+}
+
+/* chroma part */
+static void program_pri_addr_c(
+	struct dce110_mem_input *mem_input110,
+	PHYSICAL_ADDRESS_LOC address)
+{
+	uint32_t value = 0;
+	uint32_t temp = 0;
+	/*high register MUST be programmed first*/
+	temp = address.high_part &
+UNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_C__GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_C_MASK;
+
+	set_reg_field_value(value, temp,
+		UNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_C,
+		GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_C);
+
+	dm_write_reg(
+		mem_input110->base.ctx,
+		DCP_REG(mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_C),
+		value);
+
+	temp = 0;
+	value = 0;
+	temp = address.low_part >>
+	UNP_GRPH_PRIMARY_SURFACE_ADDRESS_C__GRPH_PRIMARY_SURFACE_ADDRESS_C__SHIFT;
+
+	set_reg_field_value(value, temp,
+		UNP_GRPH_PRIMARY_SURFACE_ADDRESS_C,
+		GRPH_PRIMARY_SURFACE_ADDRESS_C);
+
+	dm_write_reg(
+		mem_input110->base.ctx,
+		DCP_REG(mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_C),
+		value);
+}
+
+/* luma part */
+static void program_pri_addr_l(
+	struct dce110_mem_input *mem_input110,
+	PHYSICAL_ADDRESS_LOC address)
+{
+	uint32_t value = 0;
+	uint32_t temp = 0;
+
+	/*high register MUST be programmed first*/
+	temp = address.high_part &
+UNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_L__GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_L_MASK;
+
+	set_reg_field_value(value, temp,
+		UNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_L,
+		GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_L);
+
+	dm_write_reg(
+		mem_input110->base.ctx,
+		DCP_REG(mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH_L),
+		value);
+
+	temp = 0;
+	value = 0;
+	temp = address.low_part >>
+	UNP_GRPH_PRIMARY_SURFACE_ADDRESS_L__GRPH_PRIMARY_SURFACE_ADDRESS_L__SHIFT;
+
+	set_reg_field_value(value, temp,
+		UNP_GRPH_PRIMARY_SURFACE_ADDRESS_L,
+		GRPH_PRIMARY_SURFACE_ADDRESS_L);
+
+	dm_write_reg(
+		mem_input110->base.ctx,
+		DCP_REG(mmUNP_GRPH_PRIMARY_SURFACE_ADDRESS_L),
+		value);
+}
+
+static void program_addr(
+	struct dce110_mem_input *mem_input110,
+	const struct dc_plane_address *addr)
+{
+	switch (addr->type) {
+	case PLN_ADDR_TYPE_GRAPHICS:
+		program_pri_addr_l(
+			mem_input110,
+			addr->grph.addr);
+		break;
+	case PLN_ADDR_TYPE_VIDEO_PROGRESSIVE:
+		program_pri_addr_l(
+			mem_input110,
+			addr->video_progressive.luma_addr);
+		program_pri_addr_c(
+			mem_input110,
+			addr->video_progressive.chroma_addr);
+		break;
+	default:
+		/* not supported */
+		BREAK_TO_DEBUGGER();
+	}
+}
+
+static void enable(struct dce110_mem_input *mem_input110)
+{
+	uint32_t value = 0;
+
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_GRPH_ENABLE));
+	set_reg_field_value(value, 1, UNP_GRPH_ENABLE, GRPH_ENABLE);
+	dm_write_reg(mem_input110->base.ctx,
+		DCP_REG(mmUNP_GRPH_ENABLE),
+		value);
+}
+
+static void program_tiling(
+	struct dce110_mem_input *mem_input110,
+	const union dc_tiling_info *info,
+	const enum surface_pixel_format pixel_format)
+{
+	uint32_t value = 0;
+
+	set_reg_field_value(value, info->gfx8.num_banks,
+		UNP_GRPH_CONTROL, GRPH_NUM_BANKS);
+
+	set_reg_field_value(value, info->gfx8.bank_width,
+		UNP_GRPH_CONTROL, GRPH_BANK_WIDTH_L);
+
+	set_reg_field_value(value, info->gfx8.bank_height,
+		UNP_GRPH_CONTROL, GRPH_BANK_HEIGHT_L);
+
+	set_reg_field_value(value, info->gfx8.tile_aspect,
+		UNP_GRPH_CONTROL, GRPH_MACRO_TILE_ASPECT_L);
+
+	set_reg_field_value(value, info->gfx8.tile_split,
+		UNP_GRPH_CONTROL, GRPH_TILE_SPLIT_L);
+
+	set_reg_field_value(value, info->gfx8.tile_mode,
+		UNP_GRPH_CONTROL, GRPH_MICRO_TILE_MODE_L);
+
+	set_reg_field_value(value, info->gfx8.pipe_config,
+		UNP_GRPH_CONTROL, GRPH_PIPE_CONFIG);
+
+	set_reg_field_value(value, info->gfx8.array_mode,
+		UNP_GRPH_CONTROL, GRPH_ARRAY_MODE);
+
+	set_reg_field_value(value, 1,
+		UNP_GRPH_CONTROL, GRPH_COLOR_EXPANSION_MODE);
+
+	set_reg_field_value(value, 0,
+		UNP_GRPH_CONTROL, GRPH_Z);
+
+	dm_write_reg(
+		mem_input110->base.ctx,
+		mmUNP_GRPH_CONTROL,
+		value);
+
+	value = 0;
+
+	set_reg_field_value(value, info->gfx8.bank_width_c,
+		UNP_GRPH_CONTROL_C, GRPH_BANK_WIDTH_C);
+
+	set_reg_field_value(value, info->gfx8.bank_height_c,
+		UNP_GRPH_CONTROL_C, GRPH_BANK_HEIGHT_C);
+
+	set_reg_field_value(value, info->gfx8.tile_aspect_c,
+		UNP_GRPH_CONTROL_C, GRPH_MACRO_TILE_ASPECT_C);
+
+	set_reg_field_value(value, info->gfx8.tile_split_c,
+		UNP_GRPH_CONTROL_C, GRPH_TILE_SPLIT_C);
+
+	set_reg_field_value(value, info->gfx8.tile_mode_c,
+		UNP_GRPH_CONTROL_C, GRPH_MICRO_TILE_MODE_C);
+
+	dm_write_reg(
+		mem_input110->base.ctx,
+		mmUNP_GRPH_CONTROL_C,
+		value);
+}
+
+static void program_size_and_rotation(
+	struct dce110_mem_input *mem_input110,
+	enum dc_rotation_angle rotation,
+	const union plane_size *plane_size)
+{
+	uint32_t value = 0;
+	union plane_size local_size = *plane_size;
+
+	if (rotation == ROTATION_ANGLE_90 ||
+		rotation == ROTATION_ANGLE_270) {
+
+		uint32_t swap;
+		swap = local_size.video.luma_size.x;
+		local_size.video.luma_size.x =
+			local_size.video.luma_size.y;
+		local_size.video.luma_size.y  = swap;
+
+		swap = local_size.video.luma_size.width;
+		local_size.video.luma_size.width =
+			local_size.video.luma_size.height;
+		local_size.video.luma_size.height = swap;
+
+		swap = local_size.video.chroma_size.x;
+		local_size.video.chroma_size.x =
+			local_size.video.chroma_size.y;
+		local_size.video.chroma_size.y  = swap;
+
+		swap = local_size.video.chroma_size.width;
+		local_size.video.chroma_size.width =
+			local_size.video.chroma_size.height;
+		local_size.video.chroma_size.height = swap;
+	}
+
+	value = 0;
+	set_reg_field_value(value, local_size.video.luma_pitch,
+			UNP_GRPH_PITCH_L, GRPH_PITCH_L);
+
+	dm_write_reg(
+		mem_input110->base.ctx,
+		DCP_REG(mmUNP_GRPH_PITCH_L),
+		value);
+
+	value = 0;
+	set_reg_field_value(value, local_size.video.chroma_pitch,
+			UNP_GRPH_PITCH_C, GRPH_PITCH_C);
+	dm_write_reg(
+		mem_input110->base.ctx,
+		DCP_REG(mmUNP_GRPH_PITCH_C),
+		value);
+
+	value = 0;
+	set_reg_field_value(value, 0,
+			UNP_GRPH_X_START_L, GRPH_X_START_L);
+	dm_write_reg(
+		mem_input110->base.ctx,
+		DCP_REG(mmUNP_GRPH_X_START_L),
+		value);
+
+	value = 0;
+	set_reg_field_value(value, 0,
+			UNP_GRPH_X_START_C, GRPH_X_START_C);
+	dm_write_reg(
+		mem_input110->base.ctx,
+		DCP_REG(mmUNP_GRPH_X_START_C),
+		value);
+
+	value = 0;
+	set_reg_field_value(value, 0,
+			UNP_GRPH_Y_START_L, GRPH_Y_START_L);
+	dm_write_reg(
+		mem_input110->base.ctx,
+		DCP_REG(mmUNP_GRPH_Y_START_L),
+		value);
+
+	value = 0;
+	set_reg_field_value(value, 0,
+			UNP_GRPH_Y_START_C, GRPH_Y_START_C);
+	dm_write_reg(
+		mem_input110->base.ctx,
+		DCP_REG(mmUNP_GRPH_Y_START_C),
+		value);
+
+	value = 0;
+	set_reg_field_value(value, local_size.video.luma_size.x +
+			local_size.video.luma_size.width,
+			UNP_GRPH_X_END_L, GRPH_X_END_L);
+	dm_write_reg(
+		mem_input110->base.ctx,
+		DCP_REG(mmUNP_GRPH_X_END_L),
+		value);
+
+	value = 0;
+	set_reg_field_value(value, local_size.video.chroma_size.x +
+			local_size.video.chroma_size.width,
+			UNP_GRPH_X_END_C, GRPH_X_END_C);
+	dm_write_reg(
+		mem_input110->base.ctx,
+		DCP_REG(mmUNP_GRPH_X_END_C),
+		value);
+
+	value = 0;
+	set_reg_field_value(value, local_size.video.luma_size.y +
+			local_size.video.luma_size.height,
+			UNP_GRPH_Y_END_L, GRPH_Y_END_L);
+	dm_write_reg(
+		mem_input110->base.ctx,
+		DCP_REG(mmUNP_GRPH_Y_END_L),
+		value);
+
+	value = 0;
+	set_reg_field_value(value, local_size.video.chroma_size.y +
+			local_size.video.chroma_size.height,
+			UNP_GRPH_Y_END_C, GRPH_Y_END_C);
+	dm_write_reg(
+		mem_input110->base.ctx,
+		DCP_REG(mmUNP_GRPH_Y_END_C),
+		value);
+
+	value = 0;
+	switch (rotation) {
+	case ROTATION_ANGLE_90:
+		set_reg_field_value(value, 3,
+			UNP_HW_ROTATION, ROTATION_ANGLE);
+		break;
+	case ROTATION_ANGLE_180:
+		set_reg_field_value(value, 2,
+			UNP_HW_ROTATION, ROTATION_ANGLE);
+		break;
+	case ROTATION_ANGLE_270:
+		set_reg_field_value(value, 1,
+			UNP_HW_ROTATION, ROTATION_ANGLE);
+		break;
+	default:
+		set_reg_field_value(value, 0,
+			UNP_HW_ROTATION, ROTATION_ANGLE);
+		break;
+	}
+
+	dm_write_reg(
+		mem_input110->base.ctx,
+		DCP_REG(mmUNP_HW_ROTATION),
+		value);
+}
+
+static void program_pixel_format(
+	struct dce110_mem_input *mem_input110,
+	enum surface_pixel_format format)
+{
+	if (format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {
+		uint32_t value;
+		uint8_t grph_depth;
+		uint8_t grph_format;
+
+		value =	dm_read_reg(
+				mem_input110->base.ctx,
+				DCP_REG(mmUNP_GRPH_CONTROL));
+
+		switch (format) {
+		case SURFACE_PIXEL_FORMAT_GRPH_PALETA_256_COLORS:
+			grph_depth = 0;
+			grph_format = 0;
+			break;
+		case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
+			grph_depth = 1;
+			grph_format = 1;
+			break;
+		case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
+		case SURFACE_PIXEL_FORMAT_GRPH_BGRA8888:
+			grph_depth = 2;
+			grph_format = 0;
+			break;
+		case SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:
+		case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:
+		case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010_XR_BIAS:
+			grph_depth = 2;
+			grph_format = 1;
+			break;
+		case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
+		case SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:
+		case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:
+			grph_depth = 3;
+			grph_format = 0;
+			break;
+		default:
+			grph_depth = 2;
+			grph_format = 0;
+			break;
+		}
+
+		set_reg_field_value(
+				value,
+				grph_depth,
+				UNP_GRPH_CONTROL,
+				GRPH_DEPTH);
+		set_reg_field_value(
+				value,
+				grph_format,
+				UNP_GRPH_CONTROL,
+				GRPH_FORMAT);
+
+		dm_write_reg(
+				mem_input110->base.ctx,
+				DCP_REG(mmUNP_GRPH_CONTROL),
+				value);
+
+		value =	dm_read_reg(
+				mem_input110->base.ctx,
+				DCP_REG(mmUNP_GRPH_CONTROL_EXP));
+
+		/* VIDEO FORMAT 0 */
+		set_reg_field_value(
+				value,
+				0,
+				UNP_GRPH_CONTROL_EXP,
+				VIDEO_FORMAT);
+		dm_write_reg(
+				mem_input110->base.ctx,
+				DCP_REG(mmUNP_GRPH_CONTROL_EXP),
+				value);
+
+	} else {
+		/* Video 422 and 420 needs UNP_GRPH_CONTROL_EXP programmed */
+		uint32_t value;
+		uint8_t video_format;
+
+		value =	dm_read_reg(
+				mem_input110->base.ctx,
+				DCP_REG(mmUNP_GRPH_CONTROL_EXP));
+
+		switch (format) {
+		case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
+			video_format = 2;
+			break;
+		case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
+			video_format = 3;
+			break;
+		default:
+			video_format = 0;
+			break;
+		}
+
+		set_reg_field_value(
+			value,
+			video_format,
+			UNP_GRPH_CONTROL_EXP,
+			VIDEO_FORMAT);
+
+		dm_write_reg(
+			mem_input110->base.ctx,
+			DCP_REG(mmUNP_GRPH_CONTROL_EXP),
+			value);
+	}
+}
+
+bool dce110_mem_input_v_is_surface_pending(struct mem_input *mem_input)
+{
+	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
+	uint32_t value;
+
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_GRPH_UPDATE));
+
+	if (get_reg_field_value(value, UNP_GRPH_UPDATE,
+			GRPH_SURFACE_UPDATE_PENDING))
+		return true;
+
+	mem_input->current_address = mem_input->request_address;
+	return false;
+}
+
+bool dce110_mem_input_v_program_surface_flip_and_addr(
+	struct mem_input *mem_input,
+	const struct dc_plane_address *address,
+	bool flip_immediate)
+{
+	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
+
+	set_flip_control(mem_input110, flip_immediate);
+	program_addr(mem_input110,
+		address);
+
+	mem_input->request_address = *address;
+
+	return true;
+}
+
+/* Scatter Gather param tables */
+static const unsigned int dvmm_Hw_Setting_2DTiling[4][9] = {
+		{  8, 64, 64,  8,  8, 1, 4, 0, 0},
+		{ 16, 64, 32,  8, 16, 1, 8, 0, 0},
+		{ 32, 32, 32, 16, 16, 1, 8, 0, 0},
+		{ 64,  8, 32, 16, 16, 1, 8, 0, 0}, /* fake */
+};
+
+static const unsigned int dvmm_Hw_Setting_1DTiling[4][9] = {
+		{  8, 512, 8, 1, 0, 1, 0, 0, 0},  /* 0 for invalid */
+		{ 16, 256, 8, 2, 0, 1, 0, 0, 0},
+		{ 32, 128, 8, 4, 0, 1, 0, 0, 0},
+		{ 64,  64, 8, 4, 0, 1, 0, 0, 0}, /* fake */
+};
+
+static const unsigned int dvmm_Hw_Setting_Linear[4][9] = {
+		{  8, 4096, 1, 8, 0, 1, 0, 0, 0},
+		{ 16, 2048, 1, 8, 0, 1, 0, 0, 0},
+		{ 32, 1024, 1, 8, 0, 1, 0, 0, 0},
+		{ 64,  512, 1, 8, 0, 1, 0, 0, 0}, /* new for 64bpp from HW */
+};
+
+/* Helper to get table entry from surface info */
+static const unsigned int *get_dvmm_hw_setting(
+		union dc_tiling_info *tiling_info,
+		enum surface_pixel_format format,
+		bool chroma)
+{
+	enum bits_per_pixel {
+		bpp_8 = 0,
+		bpp_16,
+		bpp_32,
+		bpp_64
+	} bpp;
+
+	if (format >= SURFACE_PIXEL_FORMAT_INVALID)
+		bpp = bpp_32;
+	else if (format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
+		bpp = chroma ? bpp_16 : bpp_8;
+	else
+		bpp = bpp_8;
+
+	switch (tiling_info->gfx8.array_mode) {
+	case DC_ARRAY_1D_TILED_THIN1:
+	case DC_ARRAY_1D_TILED_THICK:
+	case DC_ARRAY_PRT_TILED_THIN1:
+		return dvmm_Hw_Setting_1DTiling[bpp];
+	case DC_ARRAY_2D_TILED_THIN1:
+	case DC_ARRAY_2D_TILED_THICK:
+	case DC_ARRAY_2D_TILED_X_THICK:
+	case DC_ARRAY_PRT_2D_TILED_THIN1:
+	case DC_ARRAY_PRT_2D_TILED_THICK:
+		return dvmm_Hw_Setting_2DTiling[bpp];
+	case DC_ARRAY_LINEAR_GENERAL:
+	case DC_ARRAY_LINEAR_ALLIGNED:
+		return dvmm_Hw_Setting_Linear[bpp];
+	default:
+		return dvmm_Hw_Setting_2DTiling[bpp];
+	}
+}
+
+bool dce110_mem_input_v_program_pte_vm(
+		struct mem_input *mem_input,
+		enum surface_pixel_format format,
+		union dc_tiling_info *tiling_info,
+		enum dc_rotation_angle rotation)
+{
+	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
+	const unsigned int *pte = get_dvmm_hw_setting(tiling_info, format, false);
+	const unsigned int *pte_chroma = get_dvmm_hw_setting(tiling_info, format, true);
+
+	unsigned int page_width = 0;
+	unsigned int page_height = 0;
+	unsigned int page_width_chroma = 0;
+	unsigned int page_height_chroma = 0;
+	unsigned int temp_page_width = pte[1];
+	unsigned int temp_page_height = pte[2];
+	unsigned int min_pte_before_flip = 0;
+	unsigned int min_pte_before_flip_chroma = 0;
+	uint32_t value = 0;
+
+	while ((temp_page_width >>= 1) != 0)
+		page_width++;
+	while ((temp_page_height >>= 1) != 0)
+		page_height++;
+
+	temp_page_width = pte_chroma[1];
+	temp_page_height = pte_chroma[2];
+	while ((temp_page_width >>= 1) != 0)
+		page_width_chroma++;
+	while ((temp_page_height >>= 1) != 0)
+		page_height_chroma++;
+
+	switch (rotation) {
+	case ROTATION_ANGLE_90:
+	case ROTATION_ANGLE_270:
+		min_pte_before_flip = pte[4];
+		min_pte_before_flip_chroma = pte_chroma[4];
+		break;
+	default:
+		min_pte_before_flip = pte[3];
+		min_pte_before_flip_chroma = pte_chroma[3];
+		break;
+	}
+
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_PIPE_OUTSTANDING_REQUEST_LIMIT));
+	/* TODO: un-hardcode requestlimit */
+	set_reg_field_value(value, 0xff, UNP_PIPE_OUTSTANDING_REQUEST_LIMIT, UNP_PIPE_OUTSTANDING_REQUEST_LIMIT_L);
+	set_reg_field_value(value, 0xff, UNP_PIPE_OUTSTANDING_REQUEST_LIMIT, UNP_PIPE_OUTSTANDING_REQUEST_LIMIT_C);
+	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_PIPE_OUTSTANDING_REQUEST_LIMIT), value);
+
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_CONTROL));
+	set_reg_field_value(value, page_width, UNP_DVMM_PTE_CONTROL, DVMM_PAGE_WIDTH);
+	set_reg_field_value(value, page_height, UNP_DVMM_PTE_CONTROL, DVMM_PAGE_HEIGHT);
+	set_reg_field_value(value, min_pte_before_flip, UNP_DVMM_PTE_CONTROL, DVMM_MIN_PTE_BEFORE_FLIP);
+	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_CONTROL), value);
+
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_ARB_CONTROL));
+	set_reg_field_value(value, pte[5], UNP_DVMM_PTE_ARB_CONTROL, DVMM_PTE_REQ_PER_CHUNK);
+	set_reg_field_value(value, 0xff, UNP_DVMM_PTE_ARB_CONTROL, DVMM_MAX_PTE_REQ_OUTSTANDING);
+	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_ARB_CONTROL), value);
+
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_CONTROL_C));
+	set_reg_field_value(value, page_width_chroma, UNP_DVMM_PTE_CONTROL_C, DVMM_PAGE_WIDTH_C);
+	set_reg_field_value(value, page_height_chroma, UNP_DVMM_PTE_CONTROL_C, DVMM_PAGE_HEIGHT_C);
+	set_reg_field_value(value, min_pte_before_flip_chroma, UNP_DVMM_PTE_CONTROL_C, DVMM_MIN_PTE_BEFORE_FLIP_C);
+	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_CONTROL_C), value);
+
+	value = dm_read_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_ARB_CONTROL_C));
+	set_reg_field_value(value, pte_chroma[5], UNP_DVMM_PTE_ARB_CONTROL_C, DVMM_PTE_REQ_PER_CHUNK_C);
+	set_reg_field_value(value, 0xff, UNP_DVMM_PTE_ARB_CONTROL_C, DVMM_MAX_PTE_REQ_OUTSTANDING_C);
+	dm_write_reg(mem_input110->base.ctx, DCP_REG(mmUNP_DVMM_PTE_ARB_CONTROL_C), value);
+
+	return true;
+}
+
+bool dce110_mem_input_v_program_surface_config(
+	struct mem_input *mem_input,
+	enum surface_pixel_format format,
+	union dc_tiling_info *tiling_info,
+	union plane_size *plane_size,
+	enum dc_rotation_angle rotation,
+	struct dc_plane_dcc_param *dcc,
+	bool horizotal_mirror)
+{
+	struct dce110_mem_input *mem_input110 = TO_DCE110_MEM_INPUT(mem_input);
+
+	enable(mem_input110);
+	program_tiling(mem_input110, tiling_info, format);
+	program_size_and_rotation(mem_input110, rotation, plane_size);
+	program_pixel_format(mem_input110, format);
+
+	return true;
+}
+
+static void program_urgency_watermark(
+	const struct dc_context *ctx,
+	const uint32_t urgency_addr,
+	const uint32_t wm_addr,
+	struct bw_watermarks marks_low,
+	uint32_t total_dest_line_time_ns)
+{
+	/* register value */
+	uint32_t urgency_cntl = 0;
+	uint32_t wm_mask_cntl = 0;
+
+	/*Write mask to enable reading/writing of watermark set A*/
+	wm_mask_cntl = dm_read_reg(ctx, wm_addr);
+	set_reg_field_value(wm_mask_cntl,
+			1,
+			DPGV0_WATERMARK_MASK_CONTROL,
+			URGENCY_WATERMARK_MASK);
+	dm_write_reg(ctx, wm_addr, wm_mask_cntl);
+
+	urgency_cntl = dm_read_reg(ctx, urgency_addr);
+
+	set_reg_field_value(
+		urgency_cntl,
+		marks_low.a_mark,
+		DPGV0_PIPE_URGENCY_CONTROL,
+		URGENCY_LOW_WATERMARK);
+
+	set_reg_field_value(
+		urgency_cntl,
+		total_dest_line_time_ns,
+		DPGV0_PIPE_URGENCY_CONTROL,
+		URGENCY_HIGH_WATERMARK);
+	dm_write_reg(ctx, urgency_addr, urgency_cntl);
+
+	/*Write mask to enable reading/writing of watermark set B*/
+	wm_mask_cntl = dm_read_reg(ctx, wm_addr);
+	set_reg_field_value(wm_mask_cntl,
+			2,
+			DPGV0_WATERMARK_MASK_CONTROL,
+			URGENCY_WATERMARK_MASK);
+	dm_write_reg(ctx, wm_addr, wm_mask_cntl);
+
+	urgency_cntl = dm_read_reg(ctx, urgency_addr);
+
+	set_reg_field_value(urgency_cntl,
+		marks_low.b_mark,
+		DPGV0_PIPE_URGENCY_CONTROL,
+		URGENCY_LOW_WATERMARK);
+
+	set_reg_field_value(urgency_cntl,
+		total_dest_line_time_ns,
+		DPGV0_PIPE_URGENCY_CONTROL,
+		URGENCY_HIGH_WATERMARK);
+
+	dm_write_reg(ctx, urgency_addr, urgency_cntl);
+}
+
+static void program_urgency_watermark_l(
+	const struct dc_context *ctx,
+	struct bw_watermarks marks_low,
+	uint32_t total_dest_line_time_ns)
+{
+	program_urgency_watermark(
+		ctx,
+		mmDPGV0_PIPE_URGENCY_CONTROL,
+		mmDPGV0_WATERMARK_MASK_CONTROL,
+		marks_low,
+		total_dest_line_time_ns);
+}
+
+static void program_urgency_watermark_c(
+	const struct dc_context *ctx,
+	struct bw_watermarks marks_low,
+	uint32_t total_dest_line_time_ns)
+{
+	program_urgency_watermark(
+		ctx,
+		mmDPGV1_PIPE_URGENCY_CONTROL,
+		mmDPGV1_WATERMARK_MASK_CONTROL,
+		marks_low,
+		total_dest_line_time_ns);
+}
+
+static void program_stutter_watermark(
+	const struct dc_context *ctx,
+	const uint32_t stutter_addr,
+	const uint32_t wm_addr,
+	struct bw_watermarks marks)
+{
+	/* register value */
+	uint32_t stutter_cntl = 0;
+	uint32_t wm_mask_cntl = 0;
+
+	/*Write mask to enable reading/writing of watermark set A*/
+
+	wm_mask_cntl = dm_read_reg(ctx, wm_addr);
+	set_reg_field_value(wm_mask_cntl,
+		1,
+		DPGV0_WATERMARK_MASK_CONTROL,
+		STUTTER_EXIT_SELF_REFRESH_WATERMARK_MASK);
+	dm_write_reg(ctx, wm_addr, wm_mask_cntl);
+
+	stutter_cntl = dm_read_reg(ctx, stutter_addr);
+
+	if (ctx->dc->debug.disable_stutter) {
+		set_reg_field_value(stutter_cntl,
+			0,
+			DPGV0_PIPE_STUTTER_CONTROL,
+			STUTTER_ENABLE);
+	} else {
+		set_reg_field_value(stutter_cntl,
+			1,
+			DPGV0_PIPE_STUTTER_CONTROL,
+			STUTTER_ENABLE);
+	}
+
+	set_reg_field_value(stutter_cntl,
+		1,
+		DPGV0_PIPE_STUTTER_CONTROL,
+		STUTTER_IGNORE_FBC);
+
+	/*Write watermark set A*/
+	set_reg_field_value(stutter_cntl,
+		marks.a_mark,
+		DPGV0_PIPE_STUTTER_CONTROL,
+		STUTTER_EXIT_SELF_REFRESH_WATERMARK);
+	dm_write_reg(ctx, stutter_addr, stutter_cntl);
+
+	/*Write mask to enable reading/writing of watermark set B*/
+	wm_mask_cntl = dm_read_reg(ctx, wm_addr);
+	set_reg_field_value(wm_mask_cntl,
+		2,
+		DPGV0_WATERMARK_MASK_CONTROL,
+		STUTTER_EXIT_SELF_REFRESH_WATERMARK_MASK);
+	dm_write_reg(ctx, wm_addr, wm_mask_cntl);
+
+	stutter_cntl = dm_read_reg(ctx, stutter_addr);
+	/*Write watermark set B*/
+	set_reg_field_value(stutter_cntl,
+		marks.b_mark,
+		DPGV0_PIPE_STUTTER_CONTROL,
+		STUTTER_EXIT_SELF_REFRESH_WATERMARK);
+	dm_write_reg(ctx, stutter_addr, stutter_cntl);
+}
+
+static void program_stutter_watermark_l(
+	const struct dc_context *ctx,
+	struct bw_watermarks marks)
+{
+	program_stutter_watermark(ctx,
+			mmDPGV0_PIPE_STUTTER_CONTROL,
+			mmDPGV0_WATERMARK_MASK_CONTROL,
+			marks);
+}
+
+static void program_stutter_watermark_c(
+	const struct dc_context *ctx,
+	struct bw_watermarks marks)
+{
+	program_stutter_watermark(ctx,
+			mmDPGV1_PIPE_STUTTER_CONTROL,
+			mmDPGV1_WATERMARK_MASK_CONTROL,
+			marks);
+}
+
+static void program_nbp_watermark(
+	const struct dc_context *ctx,
+	const uint32_t wm_mask_ctrl_addr,
+	const uint32_t nbp_pstate_ctrl_addr,
+	struct bw_watermarks marks)
+{
+	uint32_t value;
+
+	/* Write mask to enable reading/writing of watermark set A */
+
+	value = dm_read_reg(ctx, wm_mask_ctrl_addr);
+
+	set_reg_field_value(
+		value,
+		1,
+		DPGV0_WATERMARK_MASK_CONTROL,
+		NB_PSTATE_CHANGE_WATERMARK_MASK);
+	dm_write_reg(ctx, wm_mask_ctrl_addr, value);
+
+	value = dm_read_reg(ctx, nbp_pstate_ctrl_addr);
+
+	set_reg_field_value(
+		value,
+		1,
+		DPGV0_PIPE_NB_PSTATE_CHANGE_CONTROL,
+		NB_PSTATE_CHANGE_ENABLE);
+	set_reg_field_value(
+		value,
+		1,
+		DPGV0_PIPE_NB_PSTATE_CHANGE_CONTROL,
+		NB_PSTATE_CHANGE_URGENT_DURING_REQUEST);
+	set_reg_field_value(
+		value,
+		1,
+		DPGV0_PIPE_NB_PSTATE_CHANGE_CONTROL,
+		NB_PSTATE_CHANGE_NOT_SELF_REFRESH_DURING_REQUEST);
+	dm_write_reg(ctx, nbp_pstate_ctrl_addr, value);
+
+	/* Write watermark set A */
+	value = dm_read_reg(ctx, nbp_pstate_ctrl_addr);
+	set_reg_field_value(
+		value,
+		marks.a_mark,
+		DPGV0_PIPE_NB_PSTATE_CHANGE_CONTROL,
+		NB_PSTATE_CHANGE_WATERMARK);
+	dm_write_reg(ctx, nbp_pstate_ctrl_addr, value);
+
+	/* Write mask to enable reading/writing of watermark set B */
+	value = dm_read_reg(ctx, wm_mask_ctrl_addr);
+	set_reg_field_value(
+		value,
+		2,
+		DPGV0_WATERMARK_MASK_CONTROL,
+		NB_PSTATE_CHANGE_WATERMARK_MASK);
+	dm_write_reg(ctx, wm_mask_ctrl_addr, value);
+
+	value = dm_read_reg(ctx, nbp_pstate_ctrl_addr);
+	set_reg_field_value(
+		value,
+		1,
+		DPGV0_PIPE_NB_PSTATE_CHANGE_CONTROL,
+		NB_PSTATE_CHANGE_ENABLE);
+	set_reg_field_value(
+		value,
+		1,
+		DPGV0_PIPE_NB_PSTATE_CHANGE_CONTROL,
+		NB_PSTATE_CHANGE_URGENT_DURING_REQUEST);
+	set_reg_field_value(
+		value,
+		1,
+		DPGV0_PIPE_NB_PSTATE_CHANGE_CONTROL,
+		NB_PSTATE_CHANGE_NOT_SELF_REFRESH_DURING_REQUEST);
+	dm_write_reg(ctx, nbp_pstate_ctrl_addr, value);
+
+	/* Write watermark set B */
+	value = dm_read_reg(ctx, nbp_pstate_ctrl_addr);
+	set_reg_field_value(
+		value,
+		marks.b_mark,
+		DPGV0_PIPE_NB_PSTATE_CHANGE_CONTROL,
+		NB_PSTATE_CHANGE_WATERMARK);
+	dm_write_reg(ctx, nbp_pstate_ctrl_addr, value);
+}
+
+static void program_nbp_watermark_l(
+	const struct dc_context *ctx,
+	struct bw_watermarks marks)
+{
+	program_nbp_watermark(ctx,
+			mmDPGV0_WATERMARK_MASK_CONTROL,
+			mmDPGV0_PIPE_NB_PSTATE_CHANGE_CONTROL,
+			marks);
+}
+
+static void program_nbp_watermark_c(
+	const struct dc_context *ctx,
+	struct bw_watermarks marks)
+{
+	program_nbp_watermark(ctx,
+			mmDPGV1_WATERMARK_MASK_CONTROL,
+			mmDPGV1_PIPE_NB_PSTATE_CHANGE_CONTROL,
+			marks);
+}
+
+void dce110_mem_input_v_program_display_marks(
+	struct mem_input *mem_input,
+	struct bw_watermarks nbp,
+	struct bw_watermarks stutter,
+	struct bw_watermarks urgent,
+	uint32_t total_dest_line_time_ns)
+{
+	program_urgency_watermark_l(
+		mem_input->ctx,
+		urgent,
+		total_dest_line_time_ns);
+
+	program_nbp_watermark_l(
+		mem_input->ctx,
+		nbp);
+
+	program_stutter_watermark_l(
+		mem_input->ctx,
+		stutter);
+
+}
+
+void dce110_mem_input_program_chroma_display_marks(
+	struct mem_input *mem_input,
+	struct bw_watermarks nbp,
+	struct bw_watermarks stutter,
+	struct bw_watermarks urgent,
+	uint32_t total_dest_line_time_ns)
+{
+	program_urgency_watermark_c(
+		mem_input->ctx,
+		urgent,
+		total_dest_line_time_ns);
+
+	program_nbp_watermark_c(
+		mem_input->ctx,
+		nbp);
+
+	program_stutter_watermark_c(
+		mem_input->ctx,
+		stutter);
+}
+
+void dce110_allocate_mem_input_v(
+	struct mem_input *mi,
+	uint32_t h_total,/* for current stream */
+	uint32_t v_total,/* for current stream */
+	uint32_t pix_clk_khz,/* for current stream */
+	uint32_t total_stream_num)
+{
+	uint32_t addr;
+	uint32_t value;
+	uint32_t pix_dur;
+	if (pix_clk_khz != 0) {
+		addr = mmDPGV0_PIPE_ARBITRATION_CONTROL1;
+		value = dm_read_reg(mi->ctx, addr);
+		pix_dur = 1000000000ULL / pix_clk_khz;
+		set_reg_field_value(
+			value,
+			pix_dur,
+			DPGV0_PIPE_ARBITRATION_CONTROL1,
+			PIXEL_DURATION);
+		dm_write_reg(mi->ctx, addr, value);
+
+		addr = mmDPGV1_PIPE_ARBITRATION_CONTROL1;
+		value = dm_read_reg(mi->ctx, addr);
+		pix_dur = 1000000000ULL / pix_clk_khz;
+		set_reg_field_value(
+			value,
+			pix_dur,
+			DPGV1_PIPE_ARBITRATION_CONTROL1,
+			PIXEL_DURATION);
+		dm_write_reg(mi->ctx, addr, value);
+
+		addr = mmDPGV0_PIPE_ARBITRATION_CONTROL2;
+		value = 0x4000800;
+		dm_write_reg(mi->ctx, addr, value);
+
+		addr = mmDPGV1_PIPE_ARBITRATION_CONTROL2;
+		value = 0x4000800;
+		dm_write_reg(mi->ctx, addr, value);
+	}
+
+}
+
+void dce110_free_mem_input_v(
+	struct mem_input *mi,
+	uint32_t total_stream_num)
+{
+}
+
+static struct mem_input_funcs dce110_mem_input_v_funcs = {
+	.mem_input_program_display_marks =
+			dce110_mem_input_v_program_display_marks,
+	.mem_input_program_chroma_display_marks =
+			dce110_mem_input_program_chroma_display_marks,
+	.allocate_mem_input = dce110_allocate_mem_input_v,
+	.free_mem_input = dce110_free_mem_input_v,
+	.mem_input_program_surface_flip_and_addr =
+			dce110_mem_input_v_program_surface_flip_and_addr,
+	.mem_input_program_pte_vm =
+			dce110_mem_input_v_program_pte_vm,
+	.mem_input_program_surface_config =
+			dce110_mem_input_v_program_surface_config,
+	.mem_input_is_flip_pending =
+			dce110_mem_input_v_is_surface_pending
+};
+/*****************************************/
+/* Constructor, Destructor               */
+/*****************************************/
+
+bool dce110_mem_input_v_construct(
+	struct dce110_mem_input *mem_input110,
+	struct dc_context *ctx)
+{
+	mem_input110->base.funcs = &dce110_mem_input_v_funcs;
+	mem_input110->base.ctx = ctx;
+
+	mem_input110->base.inst = 0;
+
+	mem_input110->offsets = dce110_mi_v_reg_offsets[0];
+
+	return true;
+}
+
+#if 0
+void dce110_mem_input_v_destroy(struct mem_input **mem_input)
+{
+	dm_free(TO_DCE110_MEM_INPUT(*mem_input));
+	*mem_input = NULL;
+}
+#endif
