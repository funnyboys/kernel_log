commit 3ba01817365c5a2c07a8be09117f3e22e16f5c80
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Sat Apr 18 19:22:55 2020 -0400

    drm/amd/display: Move panel_cntl specific register from abm to panel_cntl.
    
    [Why]
    panel_cntl specific register should be access in panel_cntl object.
    
    [How]
    Move these register access from abm to panel_cntl.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 6bd8d4e1c294..b77e9dc16086 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1066,7 +1066,7 @@ void dce110_blank_stream(struct pipe_ctx *pipe_ctx)
 
 	if (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP) {
 		hws->funcs.edp_backlight_control(link, false);
-		dc_link_set_abm_disable(link);
+		link->dc->hwss.set_abm_immediate_disable(pipe_ctx);
 	}
 
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
@@ -2355,6 +2355,7 @@ static void init_hw(struct dc *dc)
 	struct abm *abm;
 	struct dmcu *dmcu;
 	struct dce_hwseq *hws = dc->hwseq;
+	uint32_t backlight = MAX_BACKLIGHT_LEVEL;
 
 	bp = dc->ctx->dc_bios;
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
@@ -2401,12 +2402,17 @@ static void init_hw(struct dc *dc)
 		audio->funcs->hw_init(audio);
 	}
 
-	abm = dc->res_pool->abm;
-	if (abm != NULL) {
-		abm->funcs->init_backlight(abm);
-		abm->funcs->abm_init(abm);
+	for (i = 0; i < dc->link_count; i++) {
+		struct dc_link *link = dc->links[i];
+
+		if (link->panel_cntl)
+			backlight = link->panel_cntl->funcs->hw_init(link->panel_cntl);
 	}
 
+	abm = dc->res_pool->abm;
+	if (abm != NULL)
+		abm->funcs->abm_init(abm, backlight);
+
 	dmcu = dc->res_pool->dmcu;
 	if (dmcu != NULL && abm != NULL)
 		abm->dmcu_is_running = dmcu->funcs->is_dmcu_initialized(dmcu);
@@ -2721,6 +2727,7 @@ bool dce110_set_backlight_level(struct pipe_ctx *pipe_ctx,
 	struct dc_link *link = pipe_ctx->stream->link;
 	struct dc  *dc = link->ctx->dc;
 	struct abm *abm = pipe_ctx->stream_res.abm;
+	struct panel_cntl *panel_cntl = link->panel_cntl;
 	struct dmcu *dmcu = dc->res_pool->dmcu;
 	bool fw_set_brightness = true;
 	/* DMCU -1 for all controller id values,
@@ -2728,23 +2735,38 @@ bool dce110_set_backlight_level(struct pipe_ctx *pipe_ctx,
 	 */
 	uint32_t controller_id = pipe_ctx->stream_res.tg->inst + 1;
 
-	if (abm == NULL || (abm->funcs->set_backlight_level_pwm == NULL))
+	if (abm == NULL || panel_cntl == NULL || (abm->funcs->set_backlight_level_pwm == NULL))
 		return false;
 
 	if (dmcu)
 		fw_set_brightness = dmcu->funcs->is_dmcu_initialized(dmcu);
 
-	abm->funcs->set_backlight_level_pwm(
-			abm,
-			backlight_pwm_u16_16,
-			frame_ramp,
-			controller_id,
-			link->panel_cntl->inst,
-			fw_set_brightness);
+	if (!fw_set_brightness && panel_cntl->funcs->driver_set_backlight)
+		panel_cntl->funcs->driver_set_backlight(panel_cntl, backlight_pwm_u16_16);
+	else
+		abm->funcs->set_backlight_level_pwm(
+				abm,
+				backlight_pwm_u16_16,
+				frame_ramp,
+				controller_id,
+				link->panel_cntl->inst);
 
 	return true;
 }
 
+void dce110_set_abm_immediate_disable(struct pipe_ctx *pipe_ctx)
+{
+	struct abm *abm = pipe_ctx->stream_res.abm;
+	struct panel_cntl *panel_cntl = pipe_ctx->stream->link->panel_cntl;
+
+	if (abm)
+		abm->funcs->set_abm_immediate_disable(abm,
+				pipe_ctx->stream->link->panel_cntl->inst);
+
+	if (panel_cntl)
+		panel_cntl->funcs->store_backlight_level(panel_cntl);
+}
+
 static const struct hw_sequencer_funcs dce110_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.program_output_csc = program_output_csc,
@@ -2781,6 +2803,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.set_cursor_position = dce110_set_cursor_position,
 	.set_cursor_attribute = dce110_set_cursor_attribute,
 	.set_backlight_level = dce110_set_backlight_level,
+	.set_abm_immediate_disable = dce110_set_abm_immediate_disable,
 };
 
 static const struct hwseq_private_funcs dce110_private_funcs = {

commit 1e461c37d1fb6712561ad682b2d67ed4f5cbd3ff
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Wed Apr 22 18:08:03 2020 -0400

    drm/amd/display: Use cursor locking to prevent flip delays
    
    [Why]
    Current locking scheme for cursor can result in a flip missing
    its vsync, deferring it for one or more vsyncs.  Result is a
    potential for stuttering when cursor is moved.
    
    [How]
    Use cursor update lock so that flips are not blocked while cursor
    is being programmed.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 30469026c642..6bd8d4e1c294 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2767,6 +2767,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.disable_plane = dce110_power_down_fe,
 	.pipe_control_lock = dce_pipe_control_lock,
 	.interdependent_update_lock = NULL,
+	.cursor_lock = dce_pipe_control_lock,
 	.prepare_bandwidth = dce110_prepare_bandwidth,
 	.optimize_bandwidth = dce110_optimize_bandwidth,
 	.set_drr = set_drr,

commit 4b0e95d1838f0e1d8bd4ca79f1fa17d7af1ddad6
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Apr 22 18:08:01 2020 -0400

    drm/amd/display: Add set backlight to hw sequencer.
    
    [Why & How]
    Add set backlight to hw sequencer, dmu communication will
    be handled in hw sequencer for new asics.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 9cd130c8894a..30469026c642 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2714,6 +2714,37 @@ void dce110_set_cursor_attribute(struct pipe_ctx *pipe_ctx)
 				pipe_ctx->plane_res.xfm, attributes);
 }
 
+bool dce110_set_backlight_level(struct pipe_ctx *pipe_ctx,
+		uint32_t backlight_pwm_u16_16,
+		uint32_t frame_ramp)
+{
+	struct dc_link *link = pipe_ctx->stream->link;
+	struct dc  *dc = link->ctx->dc;
+	struct abm *abm = pipe_ctx->stream_res.abm;
+	struct dmcu *dmcu = dc->res_pool->dmcu;
+	bool fw_set_brightness = true;
+	/* DMCU -1 for all controller id values,
+	 * therefore +1 here
+	 */
+	uint32_t controller_id = pipe_ctx->stream_res.tg->inst + 1;
+
+	if (abm == NULL || (abm->funcs->set_backlight_level_pwm == NULL))
+		return false;
+
+	if (dmcu)
+		fw_set_brightness = dmcu->funcs->is_dmcu_initialized(dmcu);
+
+	abm->funcs->set_backlight_level_pwm(
+			abm,
+			backlight_pwm_u16_16,
+			frame_ramp,
+			controller_id,
+			link->panel_cntl->inst,
+			fw_set_brightness);
+
+	return true;
+}
+
 static const struct hw_sequencer_funcs dce110_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.program_output_csc = program_output_csc,
@@ -2747,7 +2778,8 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.edp_power_control = dce110_edp_power_control,
 	.edp_wait_for_hpd_ready = dce110_edp_wait_for_hpd_ready,
 	.set_cursor_position = dce110_set_cursor_position,
-	.set_cursor_attribute = dce110_set_cursor_attribute
+	.set_cursor_attribute = dce110_set_cursor_attribute,
+	.set_backlight_level = dce110_set_backlight_level,
 };
 
 static const struct hwseq_private_funcs dce110_private_funcs = {

commit ffadb9d6520843500d848f5f882ae74cc1aa11ce
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Fri Apr 17 18:26:47 2020 -0400

    drm/amd/display: fix bug in the logic for panel power control
    
    [Why]
    there's a bug in the new logic for panel power control.  the check is
    wrong, and will skip panel power control under the wrong conditions.
    
    [How]
    fix to check for NULL panel_cntl
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Ashley Thomas <Ashley.Thomas2@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 7d4cb7fd31a7..9cd130c8894a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -796,7 +796,7 @@ void dce110_edp_power_control(
 		return;
 	}
 
-	if (link->panel_cntl)
+	if (!link->panel_cntl)
 		return;
 
 	if (power_up !=

commit d4caa72e275c1920d38a9541b2e4dcc167733734
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Wed Apr 8 13:31:50 2020 -0400

    drm/amd/display: change from panel to panel cntl
    
    [Why]
    it doesn't represent panel specifically, it's more like the control
    logic for the panel
    
    [How]
    change from panel to panel cntl to make it a bit more clear
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 09891fb5239a..7d4cb7fd31a7 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -53,7 +53,7 @@
 #include "abm.h"
 #include "audio.h"
 #include "reg_helper.h"
-#include "panel.h"
+#include "panel_cntl.h"
 
 /* include DCE11 register header files */
 #include "dce/dce_11_0_d.h"
@@ -796,10 +796,11 @@ void dce110_edp_power_control(
 		return;
 	}
 
-	if (link->panel)
+	if (link->panel_cntl)
 		return;
 
-	if (power_up != link->panel->funcs->is_panel_powered_on(link->panel)) {
+	if (power_up !=
+		link->panel_cntl->funcs->is_panel_powered_on(link->panel_cntl)) {
 		/* Send VBIOS command to prompt eDP panel power */
 		if (power_up) {
 			unsigned long long current_ts = dm_get_timestamp(ctx);
@@ -878,7 +879,8 @@ void dce110_edp_backlight_control(
 		return;
 	}
 
-	if (enable && link->panel && link->panel->funcs->is_panel_backlight_on(link->panel)) {
+	if (enable && link->panel_cntl &&
+		link->panel_cntl->funcs->is_panel_backlight_on(link->panel_cntl)) {
 		DC_LOG_HW_RESUME_S3(
 				"%s: panel already powered up. Do nothing.\n",
 				__func__);

commit 904fb6e0f4e8158e6db1e21c3c97bdc238e537f5
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Sat Mar 28 01:44:14 2020 -0400

    drm/amd/display: move panel power seq to new panel struct
    
    [Why]
    panel power sequencer is currently just sitting in hwseq but it really
    it tied to internal panels
    
    [How]
    make a new panel struct to contain power sequencer code
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 78240db90004..09891fb5239a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -53,6 +53,7 @@
 #include "abm.h"
 #include "audio.h"
 #include "reg_helper.h"
+#include "panel.h"
 
 /* include DCE11 register header files */
 #include "dce/dce_11_0_d.h"
@@ -695,31 +696,6 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 
 
 
-}
-
-/*todo: cloned in stream enc, fix*/
-bool dce110_is_panel_backlight_on(struct dc_link *link)
-{
-	struct dc_context *ctx = link->ctx;
-	struct dce_hwseq *hws = ctx->dc->hwseq;
-	uint32_t value;
-
-	REG_GET(LVTMA_PWRSEQ_CNTL, LVTMA_BLON, &value);
-
-	return value;
-}
-
-bool dce110_is_panel_powered_on(struct dc_link *link)
-{
-	struct dc_context *ctx = link->ctx;
-	struct dce_hwseq *hws = ctx->dc->hwseq;
-	uint32_t pwr_seq_state, dig_on, dig_on_ovrd;
-
-	REG_GET(LVTMA_PWRSEQ_STATE, LVTMA_PWRSEQ_TARGET_STATE_R, &pwr_seq_state);
-
-	REG_GET_2(LVTMA_PWRSEQ_CNTL, LVTMA_DIGON, &dig_on, LVTMA_DIGON_OVRD, &dig_on_ovrd);
-
-	return (pwr_seq_state == 1) || (dig_on == 1 && dig_on_ovrd == 1);
 }
 
 static enum bp_result link_transmitter_control(
@@ -810,7 +786,6 @@ void dce110_edp_power_control(
 		bool power_up)
 {
 	struct dc_context *ctx = link->ctx;
-	struct dce_hwseq *hwseq = ctx->dc->hwseq;
 	struct bp_transmitter_control cntl = { 0 };
 	enum bp_result bp_result;
 
@@ -821,7 +796,10 @@ void dce110_edp_power_control(
 		return;
 	}
 
-	if (power_up != hwseq->funcs.is_panel_powered_on(link)) {
+	if (link->panel)
+		return;
+
+	if (power_up != link->panel->funcs->is_panel_powered_on(link->panel)) {
 		/* Send VBIOS command to prompt eDP panel power */
 		if (power_up) {
 			unsigned long long current_ts = dm_get_timestamp(ctx);
@@ -892,7 +870,6 @@ void dce110_edp_backlight_control(
 		bool enable)
 {
 	struct dc_context *ctx = link->ctx;
-	struct dce_hwseq *hws = ctx->dc->hwseq;
 	struct bp_transmitter_control cntl = { 0 };
 
 	if (dal_graphics_object_id_get_connector_id(link->link_enc->connector)
@@ -901,7 +878,7 @@ void dce110_edp_backlight_control(
 		return;
 	}
 
-	if (enable && hws->funcs.is_panel_backlight_on(link)) {
+	if (enable && link->panel && link->panel->funcs->is_panel_backlight_on(link->panel)) {
 		DC_LOG_HW_RESUME_S3(
 				"%s: panel already powered up. Do nothing.\n",
 				__func__);
@@ -2784,8 +2761,6 @@ static const struct hwseq_private_funcs dce110_private_funcs = {
 	.disable_stream_gating = NULL,
 	.enable_stream_gating = NULL,
 	.edp_backlight_control = dce110_edp_backlight_control,
-	.is_panel_backlight_on = dce110_is_panel_backlight_on,
-	.is_panel_powered_on = dce110_is_panel_powered_on,
 };
 
 void dce110_hw_sequencer_construct(struct dc *dc)

commit d1ebfdd8d0fc30ff65b85a4bf3fa9e5e35006466
Author: Wyatt Wood <wyatt.wood@amd.com>
Date:   Tue Mar 31 09:31:16 2020 -0400

    drm/amd/display: Unify psr feature flags
    
    [Why]
    As it stands, psr has feature flags in dm, stream, and link. Most are
    not defined well enough, and different dm layers have different uses for
    these same flags.
    
    [How]
    We define a new structure called psr_settings in dc_link that will hold
    the following psr feature flags:
    
    psr_feature_enable - psr is supported
    psr_allow_active - psr is currently active
    psr_version - internal psr version supported
    psr_frame_capture_indication_req
    psr_sdp_transmit_line_num_deadline
    The last two flags were moved out of the power module
    for the purposes of consolidating psr flags.
    Their use is already well-defined.
    
    Psr caps reported by sink will also be stored in dc_link,
    in dpcd_caps.psr_caps.
    
    Signed-off-by: Wyatt Wood <wyatt.wood@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index c279982947e1..78240db90004 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1432,7 +1432,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
 
-	pipe_ctx->stream->link->psr_feature_enabled = false;
+	pipe_ctx->stream->link->psr_settings.psr_feature_enabled = false;
 
 	return DC_OK;
 }
@@ -1838,7 +1838,7 @@ static bool should_enable_fbc(struct dc *dc,
 		return false;
 
 	/* PSR should not be enabled */
-	if (pipe_ctx->stream->link->psr_feature_enabled)
+	if (pipe_ctx->stream->link->psr_settings.psr_feature_enabled)
 		return false;
 
 	/* Nothing to compress */

commit 033baeeefbf088416b975ac1aae08a4b8e8ef914
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Sun Apr 5 16:41:08 2020 -0400

    drm/amd/display: Make cursor source translation adjustment optional
    
    [Why]
    In some usecases, like tiled display, the stream and plane configuration
    can be setup in a way where the caller expects DAL to perform the
    clipping, eg:
    
    P0:
    src_rect(0, 0, w, h)
    dst_rect(0, 0, w, h)
    
    P1:
    src_rect(w, 0, w, h)
    dst_rect(0, 0, w, h)
    
    Cursor is enabled on both streams with the same position.
    
    This can result in double cursor on tiled display, even though this
    behavior is technically correct from the DC interface point of view.
    
    We need a mechanism to control this dynamically.
    
    [How]
    This is something that should live in the DM layer based on detection
    of the specified configuration but it's not something that we really
    have enough information to deal with today.
    
    Add a flag to the cursor position state that specifies whether we
    want DC to do the translation or not and make it opt-in and let
    the DM decide when to do it.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 67f7ca346696..c279982947e1 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2692,9 +2692,15 @@ void dce110_set_cursor_position(struct pipe_ctx *pipe_ctx)
 	 *
 	 * This translation isn't affected by scaling so it needs to be
 	 * done *after* we adjust the position for the scale factor.
+	 *
+	 * This is only done by opt-in for now since there are still
+	 * some usecases like tiled display that might enable the
+	 * cursor on both streams while expecting dc to clip it.
 	 */
-	pos_cpy.x += pipe_ctx->plane_state->src_rect.x;
-	pos_cpy.y += pipe_ctx->plane_state->src_rect.y;
+	if (pos_cpy.translate_by_source) {
+		pos_cpy.x += pipe_ctx->plane_state->src_rect.x;
+		pos_cpy.y += pipe_ctx->plane_state->src_rect.y;
+	}
 
 	if (pipe_ctx->plane_state->address.type
 			== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)

commit 03a4059b8dddf6a299ca941cc6e0d66bb146d884
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Sun Apr 5 16:40:55 2020 -0400

    drm/amd/display: Fix incorrect cursor pos on scaled primary plane
    
    [Why]
    Cursor pos is correctly adjusted from DC side for source rect offset
    on DCN ASIC, but only on the overlay.
    
    This is because DM places offsets the cursor for primary planes only
    to workaround missing code in DCE for the adjustment we're now correctly
    doing in DC for DCN ASIC.
    
    [How]
    Drop the adjustment for source rect from the DM side of things and put
    the code where it actually belongs - in DC on the pipe level.
    
    This matches what we do for DCN now.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Zhan Liu <Zhan.Liu@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 0976e378659f..67f7ca346696 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2685,6 +2685,17 @@ void dce110_set_cursor_position(struct pipe_ctx *pipe_ctx)
 		.mirror = pipe_ctx->plane_state->horizontal_mirror
 	};
 
+	/**
+	 * If the cursor's source viewport is clipped then we need to
+	 * translate the cursor to appear in the correct position on
+	 * the screen.
+	 *
+	 * This translation isn't affected by scaling so it needs to be
+	 * done *after* we adjust the position for the scale factor.
+	 */
+	pos_cpy.x += pipe_ctx->plane_state->src_rect.x;
+	pos_cpy.y += pipe_ctx->plane_state->src_rect.y;
+
 	if (pipe_ctx->plane_state->address.type
 			== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)
 		pos_cpy.enable = false;

commit accde06fcb7fd82abdfa77ecf4dc63d724a6d9bf
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Wed Feb 5 20:47:41 2020 -0500

    drm/amd/display: Add function pointers for panel related hw functions
    
    [Why]
    Make panel backlight and power on/off functions into
    hardware specific function pointers
    
    [How]
    Add function pointers for panel related hw functions
     - is_panel_powered_on
     - is_panel_backlight_on
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 28b681b33f7a..0976e378659f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -698,8 +698,10 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 }
 
 /*todo: cloned in stream enc, fix*/
-static bool is_panel_backlight_on(struct dce_hwseq *hws)
+bool dce110_is_panel_backlight_on(struct dc_link *link)
 {
+	struct dc_context *ctx = link->ctx;
+	struct dce_hwseq *hws = ctx->dc->hwseq;
 	uint32_t value;
 
 	REG_GET(LVTMA_PWRSEQ_CNTL, LVTMA_BLON, &value);
@@ -707,11 +709,12 @@ static bool is_panel_backlight_on(struct dce_hwseq *hws)
 	return value;
 }
 
-static bool is_panel_powered_on(struct dce_hwseq *hws)
+bool dce110_is_panel_powered_on(struct dc_link *link)
 {
+	struct dc_context *ctx = link->ctx;
+	struct dce_hwseq *hws = ctx->dc->hwseq;
 	uint32_t pwr_seq_state, dig_on, dig_on_ovrd;
 
-
 	REG_GET(LVTMA_PWRSEQ_STATE, LVTMA_PWRSEQ_TARGET_STATE_R, &pwr_seq_state);
 
 	REG_GET_2(LVTMA_PWRSEQ_CNTL, LVTMA_DIGON, &dig_on, LVTMA_DIGON_OVRD, &dig_on_ovrd);
@@ -818,7 +821,7 @@ void dce110_edp_power_control(
 		return;
 	}
 
-	if (power_up != is_panel_powered_on(hwseq)) {
+	if (power_up != hwseq->funcs.is_panel_powered_on(link)) {
 		/* Send VBIOS command to prompt eDP panel power */
 		if (power_up) {
 			unsigned long long current_ts = dm_get_timestamp(ctx);
@@ -898,7 +901,7 @@ void dce110_edp_backlight_control(
 		return;
 	}
 
-	if (enable && is_panel_backlight_on(hws)) {
+	if (enable && hws->funcs.is_panel_backlight_on(link)) {
 		DC_LOG_HW_RESUME_S3(
 				"%s: panel already powered up. Do nothing.\n",
 				__func__);
@@ -2764,6 +2767,8 @@ static const struct hwseq_private_funcs dce110_private_funcs = {
 	.disable_stream_gating = NULL,
 	.enable_stream_gating = NULL,
 	.edp_backlight_control = dce110_edp_backlight_control,
+	.is_panel_backlight_on = dce110_is_panel_backlight_on,
+	.is_panel_powered_on = dce110_is_panel_powered_on,
 };
 
 void dce110_hw_sequencer_construct(struct dc *dc)

commit 96577cf82a1331732a71199522398120c649f1cf
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Tue Jan 14 15:39:07 2020 -0500

    drm/amd/display: linux enable oled panel support dc part
    
    [Why] old panel has been enabled for window driver but not linux.
    
    [How] enable oled panel support for linux. this patch is dc part.
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 56d4ec7bdad7..28b681b33f7a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -71,6 +71,8 @@
 #define PANEL_POWER_UP_TIMEOUT 300
 #define PANEL_POWER_DOWN_TIMEOUT 500
 #define HPD_CHECK_INTERVAL 10
+#define OLED_POST_T7_DELAY 100
+#define OLED_PRE_T11_DELAY 150
 
 #define CTX \
 	hws->ctx
@@ -936,9 +938,21 @@ void dce110_edp_backlight_control(
 	if (cntl.action == TRANSMITTER_CONTROL_BACKLIGHT_ON)
 		edp_receiver_ready_T7(link);
 	link_transmitter_control(ctx->dc_bios, &cntl);
+
+	if (enable && link->dpcd_sink_ext_caps.bits.oled)
+		msleep(OLED_POST_T7_DELAY);
+
+	if (link->dpcd_sink_ext_caps.bits.oled ||
+		link->dpcd_sink_ext_caps.bits.hdr_aux_backlight_control == 1 ||
+		link->dpcd_sink_ext_caps.bits.sdr_aux_backlight_control == 1)
+		dc_link_backlight_enable_aux(link, enable);
+
 	/*edp 1.2*/
 	if (cntl.action == TRANSMITTER_CONTROL_BACKLIGHT_OFF)
 		edp_receiver_ready_T9(link);
+
+	if (!enable && link->dpcd_sink_ext_caps.bits.oled)
+		msleep(OLED_PRE_T11_DELAY);
 }
 
 void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)

commit 009114f6df84150a567b05537aa29b9d660e419b
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Jan 14 17:04:24 2020 -0500

    drm/amd/display: Added locking for atomic update stream and update planes
    
    [Why]
    Screen flickering when HDR switches between FP16 and ARGB2101010
    
    [How]
    Moved pipe_control_lock so stream update and plane update occur atomically
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Lucy Li <lucy.li@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index a961b94aefd9..56d4ec7bdad7 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2574,17 +2574,6 @@ static void dce110_apply_ctx_for_surface(
 	if (dc->fbc_compressor)
 		dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);
 
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-		struct pipe_ctx *old_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
-
-		if (stream == pipe_ctx->stream) {
-			if (!pipe_ctx->top_pipe &&
-				(pipe_ctx->plane_state || old_pipe_ctx->plane_state))
-				dc->hwss.pipe_control_lock(dc, pipe_ctx, true);
-		}
-	}
-
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
@@ -2607,16 +2596,6 @@ static void dce110_apply_ctx_for_surface(
 
 	}
 
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-		struct pipe_ctx *old_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
-
-		if ((stream == pipe_ctx->stream) &&
-			(!pipe_ctx->top_pipe) &&
-			(pipe_ctx->plane_state || old_pipe_ctx->plane_state))
-			dc->hwss.pipe_control_lock(dc, pipe_ctx, false);
-	}
-
 	if (dc->fbc_compressor)
 		enable_fbc(dc, context);
 }
@@ -2626,6 +2605,7 @@ static void dce110_post_unlock_program_front_end(
 		struct dc_state *context)
 {
 }
+
 static void dce110_power_down_fe(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
@@ -2742,6 +2722,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.disable_audio_stream = dce110_disable_audio_stream,
 	.disable_plane = dce110_power_down_fe,
 	.pipe_control_lock = dce_pipe_control_lock,
+	.interdependent_update_lock = NULL,
 	.prepare_bandwidth = dce110_prepare_bandwidth,
 	.optimize_bandwidth = dce110_optimize_bandwidth,
 	.set_drr = set_drr,

commit bbf5f6c3f83bedd71006473849138a446ad4d9a3
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Jan 14 16:23:31 2020 -0500

    drm/amd/display: Split program front end part that occur outside lock
    
    [Why]
    Eventually want to lock at a higher level in stack.
    To do this, we need to be able to isolate the parts that need to be done
    after pipe unlock.
    
    [How]
    Split out programming that is done post unlock.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 5b689273ff44..a961b94aefd9 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2621,6 +2621,11 @@ static void dce110_apply_ctx_for_surface(
 		enable_fbc(dc, context);
 }
 
+static void dce110_post_unlock_program_front_end(
+		struct dc *dc,
+		struct dc_state *context)
+{
+}
 static void dce110_power_down_fe(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
@@ -2722,6 +2727,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.init_hw = init_hw,
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
 	.apply_ctx_for_surface = dce110_apply_ctx_for_surface,
+	.post_unlock_program_front_end = dce110_post_unlock_program_front_end,
 	.update_plane_addr = update_plane_addr,
 	.update_pending_status = dce110_update_pending_status,
 	.enable_accelerated_mode = dce110_enable_accelerated_mode,

commit 5b5abe9526073ccbf3032d27b5864520829cdd9c
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Mon Dec 9 17:26:34 2019 -0500

    drm/amd/display: make PSR static screen entry within 30 ms
    
    [Why]
    With different refresh rate panels, the PSR entry/exit time is
    different since it is dependent on 2 frame entry time today
    
    [How]
    Make static screen num frame entry time to be calculated
    such that entry time is within 30 ms instead of fixed num
    frames.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 4939cf3b316f..5b689273ff44 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1373,9 +1373,13 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	// DRR should set trigger event to monitor surface update event
 	if (stream->adjust.v_total_min != 0 && stream->adjust.v_total_max != 0)
 		event_triggers = 0x80;
+	/* Event triggers and num frames initialized for DRR, but can be
+	 * later updated for PSR use. Note DRR trigger events are generated
+	 * regardless of whether num frames met.
+	 */
 	if (pipe_ctx->stream_res.tg->funcs->set_static_screen_control)
 		pipe_ctx->stream_res.tg->funcs->set_static_screen_control(
-				pipe_ctx->stream_res.tg, event_triggers);
+				pipe_ctx->stream_res.tg, event_triggers, 2);
 
 	if (!dc_is_virtual_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_res.stream_enc->funcs->dig_connect_to_otg(
@@ -1706,6 +1710,8 @@ static void set_drr(struct pipe_ctx **pipe_ctx,
 	struct drr_params params = {0};
 	// DRR should set trigger event to monitor surface update event
 	unsigned int event_triggers = 0x80;
+	// Note DRR trigger events are generated regardless of whether num frames met.
+	unsigned int num_frames = 2;
 
 	params.vertical_total_max = vmax;
 	params.vertical_total_min = vmin;
@@ -1721,7 +1727,7 @@ static void set_drr(struct pipe_ctx **pipe_ctx,
 		if (vmax != 0 && vmin != 0)
 			pipe_ctx[i]->stream_res.tg->funcs->set_static_screen_control(
 					pipe_ctx[i]->stream_res.tg,
-					event_triggers);
+					event_triggers, num_frames);
 	}
 }
 
@@ -1738,30 +1744,31 @@ static void get_position(struct pipe_ctx **pipe_ctx,
 }
 
 static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
-		int num_pipes, const struct dc_static_screen_events *events)
+		int num_pipes, const struct dc_static_screen_params *params)
 {
 	unsigned int i;
-	unsigned int value = 0;
+	unsigned int triggers = 0;
 
-	if (events->overlay_update)
-		value |= 0x100;
-	if (events->surface_update)
-		value |= 0x80;
-	if (events->cursor_update)
-		value |= 0x2;
-	if (events->force_trigger)
-		value |= 0x1;
+	if (params->triggers.overlay_update)
+		triggers |= 0x100;
+	if (params->triggers.surface_update)
+		triggers |= 0x80;
+	if (params->triggers.cursor_update)
+		triggers |= 0x2;
+	if (params->triggers.force_trigger)
+		triggers |= 0x1;
 
 	if (num_pipes) {
 		struct dc *dc = pipe_ctx[0]->stream->ctx->dc;
 
 		if (dc->fbc_compressor)
-			value |= 0x84;
+			triggers |= 0x84;
 	}
 
 	for (i = 0; i < num_pipes; i++)
 		pipe_ctx[i]->stream_res.tg->funcs->
-			set_static_screen_control(pipe_ctx[i]->stream_res.tg, value);
+			set_static_screen_control(pipe_ctx[i]->stream_res.tg,
+					triggers, params->num_frames);
 }
 
 /*

commit f42ea55be1114768e36c4e8dff4400ca811309cf
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Nov 5 13:17:30 2019 -0500

    drm/amd/display: add separate of private hwss functions
    
    [Why]
    Some function pointers in the hwss function pointer table are
    meant to be hw sequencer entry points to be called from dc.
    
    However some of those function pointers are not meant to
    be entry points, but instead used as a code reuse/inheritance
    tool called directly by other hwss functions, not by dc.
    
    Therefore, we want a more clear separation of which functions
    we determine to be interface functions vs the functions we
    use within hwss.
    
    [How]
    DC interface functions will be stored in:
        struct hw_sequencer_funcs
    Functions used within HWSS will be stored in:
        struct hwseq_private_funcs
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 2b2ee6893e25..4939cf3b316f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -653,10 +653,9 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 {
 	enum dc_lane_count lane_count =
 		pipe_ctx->stream->link->cur_link_settings.lane_count;
-
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;
 	struct dc_link *link = pipe_ctx->stream->link;
-
+	const struct dc *dc = link->dc;
 
 	uint32_t active_total_with_borders;
 	uint32_t early_control = 0;
@@ -669,7 +668,7 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 	link->link_enc->funcs->connect_dig_be_to_fe(link->link_enc,
 						    pipe_ctx->stream_res.stream_enc->id, true);
 
-	link->dc->hwss.update_info_frame(pipe_ctx);
+	dc->hwss.update_info_frame(pipe_ctx);
 
 	/* enable early control to avoid corruption on DP monitor*/
 	active_total_with_borders =
@@ -1049,6 +1048,7 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 	struct encoder_unblank_param params = { { 0 } };
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->link;
+	struct dce_hwseq *hws = link->dc->hwseq;
 
 	/* only 3 items below are used by unblank */
 	params.timing = pipe_ctx->stream->timing;
@@ -1058,7 +1058,7 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 		pipe_ctx->stream_res.stream_enc->funcs->dp_unblank(pipe_ctx->stream_res.stream_enc, &params);
 
 	if (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP) {
-		link->dc->hwss.edp_backlight_control(link, true);
+		hws->funcs.edp_backlight_control(link, true);
 	}
 }
 
@@ -1066,9 +1066,10 @@ void dce110_blank_stream(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->link;
+	struct dce_hwseq *hws = link->dc->hwseq;
 
 	if (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP) {
-		link->dc->hwss.edp_backlight_control(link, false);
+		hws->funcs.edp_backlight_control(link, false);
 		dc_link_set_abm_disable(link);
 	}
 
@@ -1325,9 +1326,10 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	struct drr_params params = {0};
 	unsigned int event_triggers = 0;
 	struct pipe_ctx *odm_pipe = pipe_ctx->next_odm_pipe;
+	struct dce_hwseq *hws = dc->hwseq;
 
-	if (dc->hwss.disable_stream_gating) {
-		dc->hwss.disable_stream_gating(dc, pipe_ctx);
+	if (hws->funcs.disable_stream_gating) {
+		hws->funcs.disable_stream_gating(dc, pipe_ctx);
 	}
 
 	if (pipe_ctx->stream_res.audio != NULL) {
@@ -1357,10 +1359,10 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	/*  */
 	/* Do not touch stream timing on seamless boot optimization. */
 	if (!pipe_ctx->stream->apply_seamless_boot_optimization)
-		dc->hwss.enable_stream_timing(pipe_ctx, context, dc);
+		hws->funcs.enable_stream_timing(pipe_ctx, context, dc);
 
-	if (dc->hwss.setup_vupdate_interrupt)
-		dc->hwss.setup_vupdate_interrupt(dc, pipe_ctx);
+	if (hws->funcs.setup_vupdate_interrupt)
+		hws->funcs.setup_vupdate_interrupt(dc, pipe_ctx);
 
 	params.vertical_total_min = stream->adjust.v_total_min;
 	params.vertical_total_max = stream->adjust.v_total_max;
@@ -1553,9 +1555,10 @@ void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 	bool can_apply_edp_fast_boot = false;
 	bool can_apply_seamless_boot = false;
 	bool keep_edp_vdd_on = false;
+	struct dce_hwseq *hws = dc->hwseq;
 
-	if (dc->hwss.init_pipes)
-		dc->hwss.init_pipes(dc, context);
+	if (hws->funcs.init_pipes)
+		hws->funcs.init_pipes(dc, context);
 
 	edp_stream = get_edp_stream(context);
 
@@ -1592,7 +1595,7 @@ void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 	if (!can_apply_edp_fast_boot && !can_apply_seamless_boot) {
 		if (edp_link_with_sink && !keep_edp_vdd_on) {
 			/*turn off backlight before DP_blank and encoder powered down*/
-			dc->hwss.edp_backlight_control(edp_link_with_sink, false);
+			hws->funcs.edp_backlight_control(edp_link_with_sink, false);
 		}
 		/*resume from S3, no vbios posting, no need to power down again*/
 		power_down_all_hw_blocks(dc);
@@ -2007,13 +2010,14 @@ enum dc_status dce110_apply_ctx_to_hw(
 		struct dc *dc,
 		struct dc_state *context)
 {
+	struct dce_hwseq *hws = dc->hwseq;
 	struct dc_bios *dcb = dc->ctx->dc_bios;
 	enum dc_status status;
 	int i;
 
 	/* Reset old context */
 	/* look up the targets that have been removed since last commit */
-	dc->hwss.reset_hw_ctx_wrap(dc, context);
+	hws->funcs.reset_hw_ctx_wrap(dc, context);
 
 	/* Skip applying if no targets */
 	if (context->stream_count <= 0)
@@ -2038,7 +2042,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 			continue;
 		}
 
-		dc->hwss.enable_display_power_gating(
+		hws->funcs.enable_display_power_gating(
 				dc, i, dc->ctx->dc_bios,
 				PIPE_GATING_CONTROL_DISABLE);
 	}
@@ -2347,19 +2351,20 @@ static void init_hw(struct dc *dc)
 	struct transform *xfm;
 	struct abm *abm;
 	struct dmcu *dmcu;
+	struct dce_hwseq *hws = dc->hwseq;
 
 	bp = dc->ctx->dc_bios;
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		xfm = dc->res_pool->transforms[i];
 		xfm->funcs->transform_reset(xfm);
 
-		dc->hwss.enable_display_power_gating(
+		hws->funcs.enable_display_power_gating(
 				dc, i, bp,
 				PIPE_GATING_CONTROL_INIT);
-		dc->hwss.enable_display_power_gating(
+		hws->funcs.enable_display_power_gating(
 				dc, i, bp,
 				PIPE_GATING_CONTROL_DISABLE);
-		dc->hwss.enable_display_pipe_clock_gating(
+		hws->funcs.enable_display_pipe_clock_gating(
 			dc->ctx,
 			true);
 	}
@@ -2445,6 +2450,8 @@ static void dce110_program_front_end_for_pipe(
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
 	unsigned int i;
+	struct dce_hwseq *hws = dc->hwseq;
+
 	DC_LOGGER_INIT();
 	memset(&tbl_entry, 0, sizeof(tbl_entry));
 
@@ -2503,10 +2510,10 @@ static void dce110_program_front_end_for_pipe(
 	if (pipe_ctx->plane_state->update_flags.bits.full_update ||
 			pipe_ctx->plane_state->update_flags.bits.in_transfer_func_change ||
 			pipe_ctx->plane_state->update_flags.bits.gamma_change)
-		dc->hwss.set_input_transfer_func(dc, pipe_ctx, pipe_ctx->plane_state);
+		hws->funcs.set_input_transfer_func(dc, pipe_ctx, pipe_ctx->plane_state);
 
 	if (pipe_ctx->plane_state->update_flags.bits.full_update)
-		dc->hwss.set_output_transfer_func(dc, pipe_ctx, pipe_ctx->stream);
+		hws->funcs.set_output_transfer_func(dc, pipe_ctx, pipe_ctx->stream);
 
 	DC_LOG_SURFACE(
 			"Pipe:%d %p: addr hi:0x%x, "
@@ -2609,6 +2616,7 @@ static void dce110_apply_ctx_for_surface(
 
 static void dce110_power_down_fe(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
+	struct dce_hwseq *hws = dc->hwseq;
 	int fe_idx = pipe_ctx->plane_res.mi ?
 		pipe_ctx->plane_res.mi->inst : pipe_ctx->pipe_idx;
 
@@ -2616,7 +2624,7 @@ static void dce110_power_down_fe(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	if (dc->current_state->res_ctx.pipe_ctx[fe_idx].stream)
 		return;
 
-	dc->hwss.enable_display_power_gating(
+	hws->funcs.enable_display_power_gating(
 		dc, fe_idx, dc->ctx->dc_bios, PIPE_GATING_CONTROL_ENABLE);
 
 	dc->res_pool->transforms[fe_idx]->funcs->transform_reset(
@@ -2705,14 +2713,10 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.program_output_csc = program_output_csc,
 	.init_hw = init_hw,
-	.init_pipes = init_pipes,
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
 	.apply_ctx_for_surface = dce110_apply_ctx_for_surface,
 	.update_plane_addr = update_plane_addr,
 	.update_pending_status = dce110_update_pending_status,
-	.set_input_transfer_func = dce110_set_input_transfer_func,
-	.set_output_transfer_func = dce110_set_output_transfer_func,
-	.power_down = dce110_power_down,
 	.enable_accelerated_mode = dce110_enable_accelerated_mode,
 	.enable_timing_synchronization = dce110_enable_timing_synchronization,
 	.enable_per_frame_crtc_position_reset = dce110_enable_per_frame_crtc_position_reset,
@@ -2723,8 +2727,6 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.blank_stream = dce110_blank_stream,
 	.enable_audio_stream = dce110_enable_audio_stream,
 	.disable_audio_stream = dce110_disable_audio_stream,
-	.enable_display_pipe_clock_gating = enable_display_pipe_clock_gating,
-	.enable_display_power_gating = dce110_enable_display_power_gating,
 	.disable_plane = dce110_power_down_fe,
 	.pipe_control_lock = dce_pipe_control_lock,
 	.prepare_bandwidth = dce110_prepare_bandwidth,
@@ -2732,22 +2734,33 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.set_drr = set_drr,
 	.get_position = get_position,
 	.set_static_screen_control = set_static_screen_control,
-	.reset_hw_ctx_wrap = dce110_reset_hw_ctx_wrap,
-	.enable_stream_timing = dce110_enable_stream_timing,
-	.disable_stream_gating = NULL,
-	.enable_stream_gating = NULL,
 	.setup_stereo = NULL,
 	.set_avmute = dce110_set_avmute,
 	.wait_for_mpcc_disconnect = dce110_wait_for_mpcc_disconnect,
-	.edp_backlight_control = dce110_edp_backlight_control,
 	.edp_power_control = dce110_edp_power_control,
 	.edp_wait_for_hpd_ready = dce110_edp_wait_for_hpd_ready,
 	.set_cursor_position = dce110_set_cursor_position,
 	.set_cursor_attribute = dce110_set_cursor_attribute
 };
 
+static const struct hwseq_private_funcs dce110_private_funcs = {
+	.init_pipes = init_pipes,
+	.update_plane_addr = update_plane_addr,
+	.set_input_transfer_func = dce110_set_input_transfer_func,
+	.set_output_transfer_func = dce110_set_output_transfer_func,
+	.power_down = dce110_power_down,
+	.enable_display_pipe_clock_gating = enable_display_pipe_clock_gating,
+	.enable_display_power_gating = dce110_enable_display_power_gating,
+	.reset_hw_ctx_wrap = dce110_reset_hw_ctx_wrap,
+	.enable_stream_timing = dce110_enable_stream_timing,
+	.disable_stream_gating = NULL,
+	.enable_stream_gating = NULL,
+	.edp_backlight_control = dce110_edp_backlight_control,
+};
+
 void dce110_hw_sequencer_construct(struct dc *dc)
 {
 	dc->hwss = dce110_funcs;
+	dc->hwseq->funcs = dce110_private_funcs;
 }
 

commit 2b77dcc5e5aa382832af93a581de8293db72d888
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Nov 5 13:04:34 2019 -0500

    drm/amd/display: rename core_dc to dc
    
    [Why]
    First, to make code more consistent
    Second, to get rid of those scenario where we create a second
    local pointer to dc when it's already passed in.
    
    [How]
    Rename core_dc to dc
    Remove duplicate local pointers to dc
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 1dc065f1125c..2b2ee6893e25 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -945,15 +945,15 @@ void dce110_edp_backlight_control(
 void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 {
 	/* notify audio driver for audio modes of monitor */
-	struct dc *core_dc;
+	struct dc *dc;
 	struct clk_mgr *clk_mgr;
 	unsigned int i, num_audio = 1;
 
 	if (!pipe_ctx->stream)
 		return;
 
-	core_dc = pipe_ctx->stream->ctx->dc;
-	clk_mgr = core_dc->clk_mgr;
+	dc = pipe_ctx->stream->ctx->dc;
+	clk_mgr = dc->clk_mgr;
 
 	if (pipe_ctx->stream_res.audio && pipe_ctx->stream_res.audio->enabled == true)
 		return;
@@ -961,7 +961,7 @@ void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 	if (pipe_ctx->stream_res.audio) {
 		for (i = 0; i < MAX_PIPES; i++) {
 			/*current_state not updated yet*/
-			if (core_dc->current_state->res_ctx.pipe_ctx[i].stream_res.audio != NULL)
+			if (dc->current_state->res_ctx.pipe_ctx[i].stream_res.audio != NULL)
 				num_audio++;
 		}
 

commit 78c7738211e027f122ada3f59c2c5e8a83ee3c59
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Oct 29 15:05:56 2019 -0400

    drm/amd/display: cleanup of function pointer tables
    
    [Why]
    It is becoming increasingly hard to figure out which
    function is called on the different DCN versions
    
    [How]
    1. Make function pointer table init in its own init.c file
    2. Remove other scenarios in hwseq.c file that need to
    include headers of other DCN versions. (If needed,
    it should have been done via the function pointers)
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 3f5fbad587e7..1dc065f1125c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -61,6 +61,8 @@
 
 #include "atomfirmware.h"
 
+#define GAMMA_HW_POINTS_NUM 256
+
 /*
  * All values are in milliseconds;
  * For eDP, after power-up/power/down,
@@ -268,7 +270,7 @@ static void build_prescale_params(struct ipp_prescale_params *prescale_params,
 }
 
 static bool
-dce110_set_input_transfer_func(struct pipe_ctx *pipe_ctx,
+dce110_set_input_transfer_func(struct dc *dc, struct pipe_ctx *pipe_ctx,
 			       const struct dc_plane_state *plane_state)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
@@ -596,7 +598,7 @@ dce110_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
 }
 
 static bool
-dce110_set_output_transfer_func(struct pipe_ctx *pipe_ctx,
+dce110_set_output_transfer_func(struct dc *dc, struct pipe_ctx *pipe_ctx,
 				const struct dc_stream_state *stream)
 {
 	struct transform *xfm = pipe_ctx->plane_res.xfm;
@@ -1358,7 +1360,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		dc->hwss.enable_stream_timing(pipe_ctx, context, dc);
 
 	if (dc->hwss.setup_vupdate_interrupt)
-		dc->hwss.setup_vupdate_interrupt(pipe_ctx);
+		dc->hwss.setup_vupdate_interrupt(dc, pipe_ctx);
 
 	params.vertical_total_min = stream->adjust.v_total_min;
 	params.vertical_total_max = stream->adjust.v_total_max;
@@ -2501,10 +2503,10 @@ static void dce110_program_front_end_for_pipe(
 	if (pipe_ctx->plane_state->update_flags.bits.full_update ||
 			pipe_ctx->plane_state->update_flags.bits.in_transfer_func_change ||
 			pipe_ctx->plane_state->update_flags.bits.gamma_change)
-		dc->hwss.set_input_transfer_func(pipe_ctx, pipe_ctx->plane_state);
+		dc->hwss.set_input_transfer_func(dc, pipe_ctx, pipe_ctx->plane_state);
 
 	if (pipe_ctx->plane_state->update_flags.bits.full_update)
-		dc->hwss.set_output_transfer_func(pipe_ctx, pipe_ctx->stream);
+		dc->hwss.set_output_transfer_func(dc, pipe_ctx, pipe_ctx->stream);
 
 	DC_LOG_SURFACE(
 			"Pipe:%d %p: addr hi:0x%x, "

commit b86a1aa36a92bcfbc062c5e99c1d084f27f25bab
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:48:35 2019 -0500

    drm/amd/display: rename DCN1_0 kconfig to DCN
    
    Since dcn20 and dcn21 are under dcn1 it doesnt make sense to
    have it named dcn1.
    
    Change it to "dcn" to make it generic
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 811896a43b67..3f5fbad587e7 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1223,7 +1223,7 @@ static void program_scaler(const struct dc *dc,
 {
 	struct tg_color color = {0};
 
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+#if defined(CONFIG_DRM_AMD_DC_DCN)
 	/* TOFPGA */
 	if (pipe_ctx->plane_res.xfm->funcs->transform_set_pixel_storage_depth == NULL)
 		return;

commit 1da37801a8b0fffb024fea594c7f1d7867ed8aa0
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:38:55 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_0 and DSC_SUPPORTED
    
    [Why]
    
    DCN2 and DSC are stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup NV defninitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN2 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * dce/dce_dmcu.c: dcn20_*lock_phy()
        * dce/dce_dmcu.c: dcn20_funcs
        * dce/dce_dmcu.c: dcn20_dmcu_create()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 37f5bbcba155..811896a43b67 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1322,9 +1322,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct drr_params params = {0};
 	unsigned int event_triggers = 0;
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	struct pipe_ctx *odm_pipe = pipe_ctx->next_odm_pipe;
-#endif
 
 	if (dc->hwss.disable_stream_gating) {
 		dc->hwss.disable_stream_gating(dc, pipe_ctx);
@@ -1390,7 +1388,6 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		pipe_ctx->stream_res.opp,
 		&stream->bit_depth_params,
 		&stream->clamping);
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	while (odm_pipe) {
 		odm_pipe->stream_res.opp->funcs->opp_set_dyn_expansion(
 				odm_pipe->stream_res.opp,
@@ -1404,7 +1401,6 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 				&stream->clamping);
 		odm_pipe = odm_pipe->next_odm_pipe;
 	}
-#endif
 
 	if (!stream->dpms_off)
 		core_link_enable_stream(context, pipe_ctx);

commit 4338ffa8df23d6665f53dd38da2e415940e3bf13
Author: Sung Lee <sung.lee@amd.com>
Date:   Wed Oct 16 10:24:01 2019 -0400

    drm/amd/display: Use SIGNAL_TYPE_NONE in disable_output unless eDP
    
    [WHY]
    Currently made a change where disable_output is called using signal_type.
    Using actual signal_type when calilng disable_output in power_down_encoders
    would make DP to HDMI dongle not light up on boot. As it would have signal_type
    SIGNAL_TYPE_DISPLAY_PORT.
    
    [HOW]
    Set signal_type to SIGNAL_TYPE_NONE unless it is eDP.
    
    Signed-off-by: Sung Lee <sung.lee@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index f0e837d14000..37f5bbcba155 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1438,6 +1438,9 @@ static void power_down_encoders(struct dc *dc)
 			if (!dc->links[i]->wa_flags.dp_keep_receiver_powered)
 				dp_receiver_power_ctrl(dc->links[i], false);
 
+		if (signal != SIGNAL_TYPE_EDP)
+			signal = SIGNAL_TYPE_NONE;
+
 		dc->links[i]->link_enc->funcs->disable_output(
 				dc->links[i]->link_enc, signal);
 	}

commit d4c2a96fdbfffc4c6a892a63d8fb218eb5fbc5f2
Author: Lewis Huang <Lewis.Huang@amd.com>
Date:   Thu Oct 3 16:01:25 2019 +0800

    drm/amd/display: take signal type from link
    
    [Why]
    Signal is update to EDP when driver disable first encoder. The
    following encoder using SIGNAL_TYPE_EDP to handle other
    device. When encoder signal is HDMI, driver will detect it is dp
    and release phy. It cause hw hang.
    
    [How]
    Take signal type from link->connector_signal.
    
    Signed-off-by: Lewis Huang <Lewis.Huang@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 9150e546dcf2..f0e837d14000 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1421,8 +1421,6 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 static void power_down_encoders(struct dc *dc)
 {
 	int i;
-	enum connector_id connector_id;
-	enum signal_type signal = SIGNAL_TYPE_NONE;
 
 	/* do not know BIOS back-front mapping, simply blank all. It will not
 	 * hurt for non-DP
@@ -1433,15 +1431,12 @@ static void power_down_encoders(struct dc *dc)
 	}
 
 	for (i = 0; i < dc->link_count; i++) {
-		connector_id = dal_graphics_object_id_get_connector_id(dc->links[i]->link_id);
-		if ((connector_id == CONNECTOR_ID_DISPLAY_PORT) ||
-			(connector_id == CONNECTOR_ID_EDP)) {
+		enum signal_type signal = dc->links[i]->connector_signal;
 
+		if ((signal == SIGNAL_TYPE_EDP) ||
+			(signal == SIGNAL_TYPE_DISPLAY_PORT))
 			if (!dc->links[i]->wa_flags.dp_keep_receiver_powered)
 				dp_receiver_power_ctrl(dc->links[i], false);
-			if (connector_id == CONNECTOR_ID_EDP)
-				signal = SIGNAL_TYPE_EDP;
-		}
 
 		dc->links[i]->link_enc->funcs->disable_output(
 				dc->links[i]->link_enc, signal);

commit ed4766022f88dfba871d9cc2975e834a32a16bb4
Author: Ahzo <Ahzo@tutanota.com>
Date:   Fri Oct 11 19:55:03 2019 +0200

    drm/amd/display: add NULL checks for clock manager pointer
    
    This fixes kernel NULL pointer dereferences on shutdown:
    RIP: 0010:build_audio_output.isra.0+0x97/0x110 [amdgpu]
    RIP: 0010:enable_link_dp+0x186/0x300 [amdgpu]
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Ahzo <Ahzo@tutanota.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 021e406a0ca2..9150e546dcf2 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1161,8 +1161,9 @@ static void build_audio_output(
 		}
 	}
 
-	if (pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT ||
-			pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {
+	if (state->clk_mgr &&
+		(pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT ||
+			pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST)) {
 		audio_output->pll_info.dp_dto_source_clock_in_khz =
 				state->clk_mgr->funcs->get_dp_ref_clk_frequency(
 						state->clk_mgr);

commit ab4a4072f260162284c15789329522a6773023ed
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Fri Sep 6 18:26:23 2019 -0400

    drm/amd/display: exit PSR during detection
    
    [Why]
    If 48mhz refclk is turned off during PSR, we will have issue doing
    link training during detection.
    
    [How]
    Get out of PSR before detection
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index f8c1b4f1b987..021e406a0ca2 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1410,7 +1410,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
 
-	pipe_ctx->stream->link->psr_enabled = false;
+	pipe_ctx->stream->link->psr_feature_enabled = false;
 
 	return DC_OK;
 }
@@ -1521,18 +1521,6 @@ static struct dc_stream_state *get_edp_stream(struct dc_state *context)
 	return NULL;
 }
 
-static struct dc_link *get_edp_link(struct dc *dc)
-{
-	int i;
-
-	// report any eDP links, even unconnected DDI's
-	for (i = 0; i < dc->link_count; i++) {
-		if (dc->links[i]->connector_signal == SIGNAL_TYPE_EDP)
-			return dc->links[i];
-	}
-	return NULL;
-}
-
 static struct dc_link *get_edp_link_with_sink(
 		struct dc *dc,
 		struct dc_state *context)
@@ -1826,7 +1814,7 @@ static bool should_enable_fbc(struct dc *dc,
 		return false;
 
 	/* PSR should not be enabled */
-	if (pipe_ctx->stream->link->psr_enabled)
+	if (pipe_ctx->stream->link->psr_feature_enabled)
 		return false;
 
 	/* Nothing to compress */

commit 6a1112da65f985fb407f82caee158091717c72c7
Author: zhengbin <zhengbin13@huawei.com>
Date:   Sat Oct 5 10:44:36 2019 +0800

    drm/amd/display: Remove set but not used variables 'pp_smu', 'old_pipe'
    
    Fixes gcc '-Wunused-but-set-variable' warning:
    
    drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c: In function dce110_enable_audio_stream:
    drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c:949:23: warning: variable pp_smu set but not used [-Wunused-but-set-variable]
    drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c: In function dce110_disable_audio_stream:
    drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c:983:23: warning: variable pp_smu set but not used [-Wunused-but-set-variable]
    drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c: In function dce110_program_front_end_for_pipe:
    drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c:2429:19: warning: variable old_pipe set but not used [-Wunused-but-set-variable]
    
    'pp_smu' is not used since commit 170a2398d2d8 ("drm/amd/display:
    make clk_mgr call enable_pme_wa")
    
    'old_pipe' is not used since commit 65d38262b3e8 ("drm/amd/display:
    fbc state could not reach while enable fbc")
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: zhengbin <zhengbin13@huawei.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 01a924bf477a..f8c1b4f1b987 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -944,7 +944,6 @@ void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 {
 	/* notify audio driver for audio modes of monitor */
 	struct dc *core_dc;
-	struct pp_smu_funcs *pp_smu = NULL;
 	struct clk_mgr *clk_mgr;
 	unsigned int i, num_audio = 1;
 
@@ -957,9 +956,6 @@ void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 	if (pipe_ctx->stream_res.audio && pipe_ctx->stream_res.audio->enabled == true)
 		return;
 
-	if (core_dc->res_pool->pp_smu)
-		pp_smu = core_dc->res_pool->pp_smu;
-
 	if (pipe_ctx->stream_res.audio) {
 		for (i = 0; i < MAX_PIPES; i++) {
 			/*current_state not updated yet*/
@@ -984,7 +980,6 @@ void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx)
 {
 	struct dc *dc;
-	struct pp_smu_funcs *pp_smu = NULL;
 	struct clk_mgr *clk_mgr;
 
 	if (!pipe_ctx || !pipe_ctx->stream)
@@ -1001,9 +996,6 @@ void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx)
 	if (pipe_ctx->stream_res.audio) {
 		pipe_ctx->stream_res.audio->enabled = false;
 
-		if (dc->res_pool->pp_smu)
-			pp_smu = dc->res_pool->pp_smu;
-
 		if (dc_is_dp_signal(pipe_ctx->stream->signal))
 			pipe_ctx->stream_res.stream_enc->funcs->dp_audio_disable(
 					pipe_ctx->stream_res.stream_enc);
@@ -2464,7 +2456,6 @@ static void dce110_program_front_end_for_pipe(
 		struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct mem_input *mi = pipe_ctx->plane_res.mi;
-	struct pipe_ctx *old_pipe = NULL;
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
@@ -2472,9 +2463,6 @@ static void dce110_program_front_end_for_pipe(
 	DC_LOGGER_INIT();
 	memset(&tbl_entry, 0, sizeof(tbl_entry));
 
-	if (dc->current_state)
-		old_pipe = &dc->current_state->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
-
 	memset(&adjust, 0, sizeof(adjust));
 	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
 

commit 470e2ca569bf780f832e3020ceb5afdef16a9084
Author: Bayan Zabihiyan <bayan.zabihiyan@amd.com>
Date:   Thu Aug 8 11:08:52 2019 -0400

    drm/amd/display: Expose OTG_V_TOTAL_MID for HW Diags
    
    [Why]
    Existing HW Features, HW Diags test requested that the
    registers be exposed.
    
    [How]
    Add V_TOTAL_MID to existing DC structures.
    Make sure values are passed down throughout DC
    Add Register definition.
    Program the additional registers
    Add additional Logic for V_TOTAL_CONTROL.
    
    Signed-off-by: Bayan Zabihiyan <bayan.zabihiyan@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index d2d887972956..01a924bf477a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1719,7 +1719,8 @@ void dce110_set_safe_displaymarks(
  ******************************************************************************/
 
 static void set_drr(struct pipe_ctx **pipe_ctx,
-		int num_pipes, int vmin, int vmax)
+		int num_pipes, unsigned int vmin, unsigned int vmax,
+		unsigned int vmid, unsigned int vmid_frame_number)
 {
 	int i = 0;
 	struct drr_params params = {0};

commit 574304041bb9508a4e73533e8d1702b0e713d321
Author: Su Sung Chung <Su.Chung@amd.com>
Date:   Thu Jul 25 14:43:55 2019 -0400

    drm/amd/display: fix audio endpoint not getting disabled issue
    
    [Why]
    Disable_audio_stream gets enum option as a paramenter which will decide
    if we free acquired resources or not. However checks for the option is
    guarded by the other condition which check if audio stream is getting
    diabled more than once. With both conditions combined, if we attempt to
    disable audio stream twice in a row, first with keep and second with
    free as an option, we will never free any resources, which will make
    system think there is audio endpoint connected even after we plug out
    the device
    
    [How]
    Get rid of option as parameter to disable_audio_stream and move the part
    of the code that free acquired resources to outside where to keep or to
    free resources is actually determined
    
    Signed-off-by: Su Sung Chung <Su.Chung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e475a6488234..d2d887972956 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -981,7 +981,7 @@ void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 	}
 }
 
-void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
+void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx)
 {
 	struct dc *dc;
 	struct pp_smu_funcs *pp_smu = NULL;
@@ -1004,24 +1004,13 @@ void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 		if (dc->res_pool->pp_smu)
 			pp_smu = dc->res_pool->pp_smu;
 
-		if (option != KEEP_ACQUIRED_RESOURCE ||
-				!dc->debug.az_endpoint_mute_only)
-			/*only disalbe az_endpoint if power down or free*/
-			pipe_ctx->stream_res.audio->funcs->az_disable(pipe_ctx->stream_res.audio);
-
 		if (dc_is_dp_signal(pipe_ctx->stream->signal))
 			pipe_ctx->stream_res.stream_enc->funcs->dp_audio_disable(
 					pipe_ctx->stream_res.stream_enc);
 		else
 			pipe_ctx->stream_res.stream_enc->funcs->hdmi_audio_disable(
 					pipe_ctx->stream_res.stream_enc);
-		/*don't free audio if it is from retrain or internal disable stream*/
-		if (option == FREE_ACQUIRED_RESOURCE && dc->caps.dynamic_audio == true) {
-			/*we have to dynamic arbitrate the audio endpoints*/
-			/*we free the resource, need reset is_audio_acquired*/
-			update_audio_usage(&dc->current_state->res_ctx, dc->res_pool, pipe_ctx->stream_res.audio, false);
-			pipe_ctx->stream_res.audio = NULL;
-		}
+
 		if (clk_mgr->funcs->enable_pme_wa)
 			/*this is the first audio. apply the PME w/a in order to wake AZ from D3*/
 			clk_mgr->funcs->enable_pme_wa(clk_mgr);
@@ -1034,7 +1023,7 @@ void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 	}
 }
 
-void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)
+void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->link;
@@ -1051,7 +1040,7 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)
 		pipe_ctx->stream_res.stream_enc->funcs->stop_dp_info_packets(
 			pipe_ctx->stream_res.stream_enc);
 
-	dc->hwss.disable_audio_stream(pipe_ctx, option);
+	dc->hwss.disable_audio_stream(pipe_ctx);
 
 	link->link_enc->funcs->connect_dig_be_to_fe(
 			link->link_enc,
@@ -1914,8 +1903,25 @@ static void dce110_reset_hw_ctx_wrap(
 			/* Disable if new stream is null. O/w, if stream is
 			 * disabled already, no need to disable again.
 			 */
-			if (!pipe_ctx->stream || !pipe_ctx->stream->dpms_off)
-				core_link_disable_stream(pipe_ctx_old, FREE_ACQUIRED_RESOURCE);
+			if (!pipe_ctx->stream || !pipe_ctx->stream->dpms_off) {
+				core_link_disable_stream(pipe_ctx_old);
+
+				/* free acquired resources*/
+				if (pipe_ctx_old->stream_res.audio) {
+					/*disable az_endpoint*/
+					pipe_ctx_old->stream_res.audio->funcs->
+							az_disable(pipe_ctx_old->stream_res.audio);
+
+					/*free audio*/
+					if (dc->caps.dynamic_audio == true) {
+						/*we have to dynamic arbitrate the audio endpoints*/
+						/*we free the resource, need reset is_audio_acquired*/
+						update_audio_usage(&dc->current_state->res_ctx, dc->res_pool,
+								pipe_ctx_old->stream_res.audio, false);
+						pipe_ctx_old->stream_res.audio = NULL;
+					}
+				}
+			}
 
 			pipe_ctx_old->stream_res.tg->funcs->set_blank(pipe_ctx_old->stream_res.tg, true);
 			if (!hwss_wait_for_blank_complete(pipe_ctx_old->stream_res.tg)) {

commit b1f6d01c4a3b7eeb2eb035e79d425cd6a696fa45
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Aug 6 17:17:28 2019 -0400

    drm/amd/display: re structure odm to allow 4 to 1 support
    
    Currently odm is handled using top_bottom pipe by special casing
    the differing opps to differentiate from mpc combine.
    
    Since top/bottom pipe list was made to track mpc muxing this creates
    difficulties in adding a 4 pipe odm case support.
    
    Rather than continue using mpc combine list, this change reworks odm
    to use it's own linked list to keep track of odm combine pipes. This
    also opens up options for using mpo with odm, if a practical use case
    is ever found.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 94b55143827e..e475a6488234 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1341,7 +1341,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	struct drr_params params = {0};
 	unsigned int event_triggers = 0;
 #if defined(CONFIG_DRM_AMD_DC_DCN2_0)
-	struct pipe_ctx *odm_pipe = dc_res_get_odm_bottom_pipe(pipe_ctx);
+	struct pipe_ctx *odm_pipe = pipe_ctx->next_odm_pipe;
 #endif
 
 	if (dc->hwss.disable_stream_gating) {
@@ -1409,7 +1409,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		&stream->bit_depth_params,
 		&stream->clamping);
 #if defined(CONFIG_DRM_AMD_DC_DCN2_0)
-	if (odm_pipe) {
+	while (odm_pipe) {
 		odm_pipe->stream_res.opp->funcs->opp_set_dyn_expansion(
 				odm_pipe->stream_res.opp,
 				COLOR_SPACE_YCBCR601,
@@ -1420,6 +1420,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 				odm_pipe->stream_res.opp,
 				&stream->bit_depth_params,
 				&stream->clamping);
+		odm_pipe = odm_pipe->next_odm_pipe;
 	}
 #endif
 
@@ -2079,7 +2080,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 		if (pipe_ctx_old->stream && !pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
 			continue;
 
-		if (pipe_ctx->top_pipe)
+		if (pipe_ctx->top_pipe || pipe_ctx->prev_odm_pipe)
 			continue;
 
 		status = apply_single_controller_ctx_to_hw(

commit 8a31820b12187c7e31c52e8a00075359d9efac52
Author: Martin Leung <martin.leung@amd.com>
Date:   Tue Jul 9 15:15:17 2019 -0400

    drm/amd/display: Make init_hw and init_pipes generic for seamless boot
    
    [Why]
    For seamless boot the init_hw sequence must be split into
    actual hardware vs pipes, in order to defer pipe initialization to set mode
    and skip of pipe-destructive sequences
    
    [How]
    made dcn10_init_hw and dcn10_init_pipes generic for future dcns to inherit
    deleted dcn20 specific versions. This is part 1 of a 2 partimplementation
    of seamless boot
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 997615582528..94b55143827e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -731,7 +731,7 @@ static enum bp_result link_transmitter_control(
  * @brief
  * eDP only.
  */
-void hwss_edp_wait_for_hpd_ready(
+void dce110_edp_wait_for_hpd_ready(
 		struct dc_link *link,
 		bool power_up)
 {
@@ -799,7 +799,7 @@ void hwss_edp_wait_for_hpd_ready(
 	}
 }
 
-void hwss_edp_power_control(
+void dce110_edp_power_control(
 		struct dc_link *link,
 		bool power_up)
 {
@@ -881,7 +881,7 @@ void hwss_edp_power_control(
  * @brief
  * eDP only. Control the backlight of the eDP panel
  */
-void hwss_edp_backlight_control(
+void dce110_edp_backlight_control(
 		struct dc_link *link,
 		bool enable)
 {
@@ -2758,9 +2758,9 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.setup_stereo = NULL,
 	.set_avmute = dce110_set_avmute,
 	.wait_for_mpcc_disconnect = dce110_wait_for_mpcc_disconnect,
-	.edp_backlight_control = hwss_edp_backlight_control,
-	.edp_power_control = hwss_edp_power_control,
-	.edp_wait_for_hpd_ready = hwss_edp_wait_for_hpd_ready,
+	.edp_backlight_control = dce110_edp_backlight_control,
+	.edp_power_control = dce110_edp_power_control,
+	.edp_wait_for_hpd_ready = dce110_edp_wait_for_hpd_ready,
 	.set_cursor_position = dce110_set_cursor_position,
 	.set_cursor_attribute = dce110_set_cursor_attribute
 };

commit ac42fd639550b386c41d8f3f2dc657d96fde7235
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Wed Jul 10 18:35:18 2019 -0400

    drm/amd/display: reset hdmi tmds rate and data scramble on pipe reset
    
    [why]
    hdmi data scramble and tmds rate is not reset during pipe reset.
    
    [how]
    reset hdmi tmds rate and data scramble on pipe reset
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Chris Park <Chris.Park@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 9c50f09233bb..997615582528 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1040,9 +1040,12 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)
 	struct dc_link *link = stream->link;
 	struct dc *dc = pipe_ctx->stream->ctx->dc;
 
-	if (dc_is_hdmi_tmds_signal(pipe_ctx->stream->signal))
+	if (dc_is_hdmi_tmds_signal(pipe_ctx->stream->signal)) {
 		pipe_ctx->stream_res.stream_enc->funcs->stop_hdmi_info_packets(
 			pipe_ctx->stream_res.stream_enc);
+		pipe_ctx->stream_res.stream_enc->funcs->hdmi_reset_stream_attribute(
+			pipe_ctx->stream_res.stream_enc);
+	}
 
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_res.stream_enc->funcs->stop_dp_info_packets(

commit 3f52aa9f9f6f611d19035961fba0f8343bcb3e6c
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Wed Jul 3 10:02:39 2019 -0400

    drm/amd/display: Set enabled to false at start of audio disable
    
    [Why]
    In an effort to stop redundant calls to dce110_disable_audio_stream
    the audio->enabled flag was added to the audio resource struct. While
    this state probably shouldn't have been tracked on the audio struct
    itself it still works fine for some sequences.
    
    However, it does not work for cases where we're freeing the audio
    resource (such as hotplugs) or when dynamic audio is enabled.
    
    In these cases the pipe_ctx->stream_res.audio = NULL before we can
    set audio->enabled = false. The next time we acquire the audio resource
    such as on hotplug the audio will not be enabled for the stream since
    DC thinks it's still enabled.
    
    Audio state tracking should cover this sequence.
    
    [How]
    Set audio->enabled = false at the start as long as we have
    pipe_ctx->stream_res.audio.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Zhan Liu <Zhan.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index ddc5add503ec..9c50f09233bb 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -999,6 +999,8 @@ void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 	pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
 			pipe_ctx->stream_res.stream_enc, true);
 	if (pipe_ctx->stream_res.audio) {
+		pipe_ctx->stream_res.audio->enabled = false;
+
 		if (dc->res_pool->pp_smu)
 			pp_smu = dc->res_pool->pp_smu;
 
@@ -1029,8 +1031,6 @@ void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 		/* dal_audio_disable_azalia_audio_jack_presence(stream->audio,
 		 * stream->stream_engine_id);
 		 */
-		if (pipe_ctx->stream_res.audio)
-			pipe_ctx->stream_res.audio->enabled = false;
 	}
 }
 

commit f591344e89dca887afeb5bbe21fa199687fd4a5f
Author: Julian Parkin <julian.parkin@amd.com>
Date:   Wed Jul 3 13:59:26 2019 -0400

    drm/amd/display: Clean up dynamic metadata logic
    
     [Why]
    Code to enable DCN20 dynamic metadata feature is duplicated in two places
    and was added to DCE110 enable stream.
    
    [How]
    Create DCN20 specific enable stream function for clarity, and add a hardware
    sequencer function to program dynamic metadata to avoid the duplicate
    code.
    
    Signed-off-by: Julian Parkin <julian.parkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 41f5ef6c5085..ddc5add503ec 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -667,29 +667,7 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 	link->link_enc->funcs->connect_dig_be_to_fe(link->link_enc,
 						    pipe_ctx->stream_res.stream_enc->id, true);
 
-	/* update AVI info frame (HDMI, DP)*/
-	/* TODO: FPGA may change to hwss.update_info_frame */
-
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
-	if (pipe_ctx->stream_res.stream_enc->funcs->set_dynamic_metadata != NULL &&
-			pipe_ctx->plane_res.hubp != NULL) {
-		if (pipe_ctx->stream->dmdata_address.quad_part != 0) {
-			/* if using dynamic meta, don't set up generic infopackets */
-			pipe_ctx->stream_res.encoder_info_frame.hdrsmd.valid = false;
-			pipe_ctx->stream_res.stream_enc->funcs->set_dynamic_metadata(
-					pipe_ctx->stream_res.stream_enc,
-					true, pipe_ctx->plane_res.hubp->inst,
-					dc_is_dp_signal(pipe_ctx->stream->signal) ?
-							dmdata_dp : dmdata_hdmi);
-		} else
-			pipe_ctx->stream_res.stream_enc->funcs->set_dynamic_metadata(
-					pipe_ctx->stream_res.stream_enc,
-					false, pipe_ctx->plane_res.hubp->inst,
-					dc_is_dp_signal(pipe_ctx->stream->signal) ?
-							dmdata_dp : dmdata_hdmi);
-	}
-#endif
-	dce110_update_info_frame(pipe_ctx);
+	link->dc->hwss.update_info_frame(pipe_ctx);
 
 	/* enable early control to avoid corruption on DP monitor*/
 	active_total_with_borders =

commit 1d0610bc26d8e2fe82de77d8be3e1ed0958feddc
Author: Alvin Lee <alvin.lee2@amd.com>
Date:   Thu Jun 20 13:03:25 2019 -0400

    drm/amd/display: Disable Audio on reinitialize hardware
    
    [Why]
    When we recover from hang, we do not want to skip the audio enable call.
    
    [How]
    Disable audio in dc_reinitialize_hardware
    
    Signed-off-by: Alvin Lee <alvin.lee2@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 3a937e297a89..41f5ef6c5085 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -965,11 +965,17 @@ void hwss_edp_backlight_control(
 void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 {
 	/* notify audio driver for audio modes of monitor */
-	struct dc *core_dc = pipe_ctx->stream->ctx->dc;
+	struct dc *core_dc;
 	struct pp_smu_funcs *pp_smu = NULL;
-	struct clk_mgr *clk_mgr = core_dc->clk_mgr;
+	struct clk_mgr *clk_mgr;
 	unsigned int i, num_audio = 1;
 
+	if (!pipe_ctx->stream)
+		return;
+
+	core_dc = pipe_ctx->stream->ctx->dc;
+	clk_mgr = core_dc->clk_mgr;
+
 	if (pipe_ctx->stream_res.audio && pipe_ctx->stream_res.audio->enabled == true)
 		return;
 
@@ -999,9 +1005,15 @@ void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 
 void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 {
-	struct dc *dc = pipe_ctx->stream->ctx->dc;
+	struct dc *dc;
 	struct pp_smu_funcs *pp_smu = NULL;
-	struct clk_mgr *clk_mgr = dc->clk_mgr;
+	struct clk_mgr *clk_mgr;
+
+	if (!pipe_ctx || !pipe_ctx->stream)
+		return;
+
+	dc = pipe_ctx->stream->ctx->dc;
+	clk_mgr = dc->clk_mgr;
 
 	if (pipe_ctx->stream_res.audio && pipe_ctx->stream_res.audio->enabled == false)
 		return;

commit 40fd9090aec688be730d54a00fd2fdcb37e16701
Author: Nevenko Stupar <Nevenko.Stupar@amd.com>
Date:   Tue Jun 11 17:35:16 2019 -0400

    drm/amd/display:Use Pixel clock in 100Hz units for HDMI Audio wall clock DTO
    
    [Why]
    -Pass and use pixel clock in 100 Hz to Audio for HDMI
    audio DTO for Audio wall clock programming so audio DTO gets
    increased precision for timings with /1001 factor.
    -For HDMI TMDS for N and CTS ACR tables are based on 10 KHz
    units, these does not need to be modified as N and CTS values
    are still valid using current tables.
    
    Signed-off-by: Nevenko Stupar <Nevenko.Stupar@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 858a58856ebd..3a937e297a89 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1162,27 +1162,27 @@ static void build_audio_output(
 			stream->timing.flags.INTERLACE;
 
 	audio_output->crtc_info.refresh_rate =
-		(stream->timing.pix_clk_100hz*10000)/
+		(stream->timing.pix_clk_100hz*100)/
 		(stream->timing.h_total*stream->timing.v_total);
 
 	audio_output->crtc_info.color_depth =
 		stream->timing.display_color_depth;
 
-	audio_output->crtc_info.requested_pixel_clock =
-			pipe_ctx->stream_res.pix_clk_params.requested_pix_clk_100hz / 10;
+	audio_output->crtc_info.requested_pixel_clock_100Hz =
+			pipe_ctx->stream_res.pix_clk_params.requested_pix_clk_100hz;
 
-	audio_output->crtc_info.calculated_pixel_clock =
-			pipe_ctx->stream_res.pix_clk_params.requested_pix_clk_100hz / 10;
+	audio_output->crtc_info.calculated_pixel_clock_100Hz =
+			pipe_ctx->stream_res.pix_clk_params.requested_pix_clk_100hz;
 
 /*for HDMI, audio ACR is with deep color ratio factor*/
 	if (dc_is_hdmi_signal(pipe_ctx->stream->signal) &&
-		audio_output->crtc_info.requested_pixel_clock ==
-				(stream->timing.pix_clk_100hz / 10)) {
+		audio_output->crtc_info.requested_pixel_clock_100Hz ==
+				(stream->timing.pix_clk_100hz)) {
 		if (pipe_ctx->stream_res.pix_clk_params.pixel_encoding == PIXEL_ENCODING_YCBCR420) {
-			audio_output->crtc_info.requested_pixel_clock =
-					audio_output->crtc_info.requested_pixel_clock/2;
-			audio_output->crtc_info.calculated_pixel_clock =
-					pipe_ctx->stream_res.pix_clk_params.requested_pix_clk_100hz/20;
+			audio_output->crtc_info.requested_pixel_clock_100Hz =
+					audio_output->crtc_info.requested_pixel_clock_100Hz/2;
+			audio_output->crtc_info.calculated_pixel_clock_100Hz =
+					pipe_ctx->stream_res.pix_clk_params.requested_pix_clk_100hz/2;
 
 		}
 	}

commit 709527c77a8977e95166d7d446e6a54f60e1e285
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Mon Jun 24 13:14:14 2019 -0400

    drm/amd/display: update infoframe after dig fe is turned on (v2)
    
    [Why]
    The AVI infoframe is incorrectly programmed on DCN1/2 when enabling a
    stream - causing the wrong pixel encoding to be used for display.
    
    This is because the AVI infoframe is programmed before the DIG BE is
    connected to the FE and turned on, so enabling the AFMT block doesn't
    actually work and the registers subsequently can't be written to.
    
    [How]
    Program the infoframe *after* turning on the DIG FE. This was the
    behavior previously used but it was incorrectly reverted
    when adding the DCN2 HW sequencer code.
    
    v2: Don't call update_info_frame twice
    
    Fixes: 7ed4e6352c16fe01 ("drm/amd/display: Add DCN2 HW Sequencer and Resource")
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 5f69f05fb711..858a58856ebd 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -689,6 +689,7 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 							dmdata_dp : dmdata_hdmi);
 	}
 #endif
+	dce110_update_info_frame(pipe_ctx);
 
 	/* enable early control to avoid corruption on DP monitor*/
 	active_total_with_borders =

commit d7929c1e13e3788e7cb741d75b5baec5e53eff21
Merge: 8ac875db0fdc 80d42db02b3a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jun 25 08:42:25 2019 -0500

    Merge branch 'drm-next' into drm-next-5.3
    
    Backmerge drm-next and fix up conflicts due to drmP.h removal.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit 170a2398d2d80f0df0d6c664dddd237baf4408cf
Author: Su Sung Chung <Su.Chung@amd.com>
Date:   Thu May 30 14:59:03 2019 -0400

    drm/amd/display: make clk_mgr call enable_pme_wa
    
    [why]
    Before for raven and navi we are calling pp_smu functions for pme
    
    [how]
    refactor a code so we will call clk_mgr's enable_pme_wa function so we
    can use pme_wa for future asics. This way we don't need to worry about
    different ASIC since clk_mgr already have that information
    
    Signed-off-by: Su Sung Chung <Su.Chung@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index edda426e32b4..940e74b7d2c6 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -958,30 +958,12 @@ void hwss_edp_backlight_control(
 		edp_receiver_ready_T9(link);
 }
 
-// Static helper function which calls the correct function
-// based on pp_smu version
-static void set_pme_wa_enable_by_version(struct dc *dc)
-{
-	struct pp_smu_funcs *pp_smu = NULL;
-
-	if (dc->res_pool->pp_smu)
-		pp_smu = dc->res_pool->pp_smu;
-
-	if (pp_smu) {
-		if (pp_smu->ctx.ver == PP_SMU_VER_RV && pp_smu->rv_funcs.set_pme_wa_enable)
-			pp_smu->rv_funcs.set_pme_wa_enable(&(pp_smu->rv_funcs.pp_smu));
-#ifdef CONFIG_DRM_AMD_DC_DCN2_0
-		else if (pp_smu->ctx.ver == PP_SMU_VER_NV && pp_smu->nv_funcs.set_pme_wa_enable)
-			pp_smu->nv_funcs.set_pme_wa_enable(&(pp_smu->nv_funcs.pp_smu));
-#endif
-	}
-}
-
 void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 {
 	/* notify audio driver for audio modes of monitor */
 	struct dc *core_dc = pipe_ctx->stream->ctx->dc;
 	struct pp_smu_funcs *pp_smu = NULL;
+	struct clk_mgr *clk_mgr = core_dc->clk_mgr;
 	unsigned int i, num_audio = 1;
 
 	if (pipe_ctx->stream_res.audio && pipe_ctx->stream_res.audio->enabled == true)
@@ -999,9 +981,9 @@ void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 
 		pipe_ctx->stream_res.audio->funcs->az_enable(pipe_ctx->stream_res.audio);
 
-		if (num_audio >= 1 && pp_smu != NULL)
+		if (num_audio >= 1 && clk_mgr->funcs->enable_pme_wa)
 			/*this is the first audio. apply the PME w/a in order to wake AZ from D3*/
-			set_pme_wa_enable_by_version(core_dc);
+			clk_mgr->funcs->enable_pme_wa(clk_mgr);
 		/* un-mute audio */
 		/* TODO: audio should be per stream rather than per link */
 		pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
@@ -1015,6 +997,7 @@ void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 {
 	struct dc *dc = pipe_ctx->stream->ctx->dc;
 	struct pp_smu_funcs *pp_smu = NULL;
+	struct clk_mgr *clk_mgr = dc->clk_mgr;
 
 	if (pipe_ctx->stream_res.audio && pipe_ctx->stream_res.audio->enabled == false)
 		return;
@@ -1043,9 +1026,9 @@ void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 			update_audio_usage(&dc->current_state->res_ctx, dc->res_pool, pipe_ctx->stream_res.audio, false);
 			pipe_ctx->stream_res.audio = NULL;
 		}
-		if (pp_smu != NULL)
+		if (clk_mgr->funcs->enable_pme_wa)
 			/*this is the first audio. apply the PME w/a in order to wake AZ from D3*/
-			set_pme_wa_enable_by_version(dc);
+			clk_mgr->funcs->enable_pme_wa(clk_mgr);
 
 		/* TODO: notify audio driver for if audio modes list changed
 		 * add audio mode list change flag */

commit 284358f2acc189fa99088819cfdf93daf97a147d
Author: hersen wu <hersenxs.wu@amd.com>
Date:   Sat Jun 1 18:23:38 2019 -0400

    drm/amd/display/dc: fix azalia workaround sw implementation bug
    
    caller of pp_nv_set_pme_wa_enable pass incorrect pp_smu:
    dc->res_pool->pp_smu. it should be dc->res_pool->pp_smu->nv_funcs.pp_smu.
    with incorrect input, pp->dm = NULL. This causes system crash.
    
    Signed-off-by: hersen wu <hersenxs.wu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e7cc58ef6a5e..edda426e32b4 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -969,10 +969,10 @@ static void set_pme_wa_enable_by_version(struct dc *dc)
 
 	if (pp_smu) {
 		if (pp_smu->ctx.ver == PP_SMU_VER_RV && pp_smu->rv_funcs.set_pme_wa_enable)
-			pp_smu->rv_funcs.set_pme_wa_enable(&(pp_smu->ctx));
+			pp_smu->rv_funcs.set_pme_wa_enable(&(pp_smu->rv_funcs.pp_smu));
 #ifdef CONFIG_DRM_AMD_DC_DCN2_0
 		else if (pp_smu->ctx.ver == PP_SMU_VER_NV && pp_smu->nv_funcs.set_pme_wa_enable)
-			pp_smu->nv_funcs.set_pme_wa_enable(&(pp_smu->ctx));
+			pp_smu->nv_funcs.set_pme_wa_enable(&(pp_smu->nv_funcs.pp_smu));
 #endif
 	}
 }

commit 7ed4e6352c16fe018864bc4e626c48e27a0cefee
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Feb 22 16:52:08 2019 -0500

    drm/amd/display: Add DCN2 HW Sequencer and Resource
    
    Add DCN2 resource definition and HW Sequencer changes.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 2a7ac452d458..e7cc58ef6a5e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -666,7 +666,26 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 
 	/* update AVI info frame (HDMI, DP)*/
 	/* TODO: FPGA may change to hwss.update_info_frame */
-	dce110_update_info_frame(pipe_ctx);
+
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	if (pipe_ctx->stream_res.stream_enc->funcs->set_dynamic_metadata != NULL &&
+			pipe_ctx->plane_res.hubp != NULL) {
+		if (pipe_ctx->stream->dmdata_address.quad_part != 0) {
+			/* if using dynamic meta, don't set up generic infopackets */
+			pipe_ctx->stream_res.encoder_info_frame.hdrsmd.valid = false;
+			pipe_ctx->stream_res.stream_enc->funcs->set_dynamic_metadata(
+					pipe_ctx->stream_res.stream_enc,
+					true, pipe_ctx->plane_res.hubp->inst,
+					dc_is_dp_signal(pipe_ctx->stream->signal) ?
+							dmdata_dp : dmdata_hdmi);
+		} else
+			pipe_ctx->stream_res.stream_enc->funcs->set_dynamic_metadata(
+					pipe_ctx->stream_res.stream_enc,
+					false, pipe_ctx->plane_res.hubp->inst,
+					dc_is_dp_signal(pipe_ctx->stream->signal) ?
+							dmdata_dp : dmdata_hdmi);
+	}
+#endif
 
 	/* enable early control to avoid corruption on DP monitor*/
 	active_total_with_borders =
@@ -951,6 +970,10 @@ static void set_pme_wa_enable_by_version(struct dc *dc)
 	if (pp_smu) {
 		if (pp_smu->ctx.ver == PP_SMU_VER_RV && pp_smu->rv_funcs.set_pme_wa_enable)
 			pp_smu->rv_funcs.set_pme_wa_enable(&(pp_smu->ctx));
+#ifdef CONFIG_DRM_AMD_DC_DCN2_0
+		else if (pp_smu->ctx.ver == PP_SMU_VER_NV && pp_smu->nv_funcs.set_pme_wa_enable)
+			pp_smu->nv_funcs.set_pme_wa_enable(&(pp_smu->ctx));
+#endif
 	}
 }
 
@@ -1337,6 +1360,9 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct drr_params params = {0};
 	unsigned int event_triggers = 0;
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	struct pipe_ctx *odm_pipe = dc_res_get_odm_bottom_pipe(pipe_ctx);
+#endif
 
 	if (dc->hwss.disable_stream_gating) {
 		dc->hwss.disable_stream_gating(dc, pipe_ctx);
@@ -1402,6 +1428,20 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		pipe_ctx->stream_res.opp,
 		&stream->bit_depth_params,
 		&stream->clamping);
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	if (odm_pipe) {
+		odm_pipe->stream_res.opp->funcs->opp_set_dyn_expansion(
+				odm_pipe->stream_res.opp,
+				COLOR_SPACE_YCBCR601,
+				stream->timing.display_color_depth,
+				stream->signal);
+
+		odm_pipe->stream_res.opp->funcs->opp_program_fmt(
+				odm_pipe->stream_res.opp,
+				&stream->bit_depth_params,
+				&stream->clamping);
+	}
+#endif
 
 	if (!stream->dpms_off)
 		core_link_enable_stream(context, pipe_ctx);

commit 76d981a9fe8239b722b6efa5b5f8b85e9b8e4056
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Jun 17 13:04:43 2019 -0500

    Revert "drm/amd/display: make clk_mgr call enable_pme_wa"
    
    This reverts commit a1651530a3bacf1d796fdb7bc587faef9f305d36.
    
    Revert this to apply the version that includes DCN2 support.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 5a831410bc55..2a7ac452d458 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -939,12 +939,26 @@ void hwss_edp_backlight_control(
 		edp_receiver_ready_T9(link);
 }
 
+// Static helper function which calls the correct function
+// based on pp_smu version
+static void set_pme_wa_enable_by_version(struct dc *dc)
+{
+	struct pp_smu_funcs *pp_smu = NULL;
+
+	if (dc->res_pool->pp_smu)
+		pp_smu = dc->res_pool->pp_smu;
+
+	if (pp_smu) {
+		if (pp_smu->ctx.ver == PP_SMU_VER_RV && pp_smu->rv_funcs.set_pme_wa_enable)
+			pp_smu->rv_funcs.set_pme_wa_enable(&(pp_smu->ctx));
+	}
+}
+
 void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 {
 	/* notify audio driver for audio modes of monitor */
 	struct dc *core_dc = pipe_ctx->stream->ctx->dc;
 	struct pp_smu_funcs *pp_smu = NULL;
-	struct clk_mgr *clk_mgr = core_dc->clk_mgr;
 	unsigned int i, num_audio = 1;
 
 	if (pipe_ctx->stream_res.audio && pipe_ctx->stream_res.audio->enabled == true)
@@ -962,9 +976,9 @@ void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 
 		pipe_ctx->stream_res.audio->funcs->az_enable(pipe_ctx->stream_res.audio);
 
-		if (num_audio >= 1 && clk_mgr->funcs->enable_pme_wa)
+		if (num_audio >= 1 && pp_smu != NULL)
 			/*this is the first audio. apply the PME w/a in order to wake AZ from D3*/
-			clk_mgr->funcs->enable_pme_wa(clk_mgr);
+			set_pme_wa_enable_by_version(core_dc);
 		/* un-mute audio */
 		/* TODO: audio should be per stream rather than per link */
 		pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
@@ -978,7 +992,6 @@ void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 {
 	struct dc *dc = pipe_ctx->stream->ctx->dc;
 	struct pp_smu_funcs *pp_smu = NULL;
-	struct clk_mgr *clk_mgr = dc->clk_mgr;
 
 	if (pipe_ctx->stream_res.audio && pipe_ctx->stream_res.audio->enabled == false)
 		return;
@@ -1007,9 +1020,9 @@ void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 			update_audio_usage(&dc->current_state->res_ctx, dc->res_pool, pipe_ctx->stream_res.audio, false);
 			pipe_ctx->stream_res.audio = NULL;
 		}
-		if (clk_mgr->funcs->enable_pme_wa)
+		if (pp_smu != NULL)
 			/*this is the first audio. apply the PME w/a in order to wake AZ from D3*/
-			clk_mgr->funcs->enable_pme_wa(clk_mgr);
+			set_pme_wa_enable_by_version(dc);
 
 		/* TODO: notify audio driver for if audio modes list changed
 		 * add audio mode list change flag */

commit 2454fcea338ad821a39d471bc7db5a58ba41b742
Merge: 561564bea324 51e857af9f3f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jun 14 11:31:13 2019 +0200

    Merge tag 'drm-misc-next-2019-06-14' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for v5.3:
    
    UAPI Changes:
    
    Cross-subsystem Changes:
    - Add code to signal all dma-fences when freed with pending signals.
    - Annotate reservation object access in CONFIG_DEBUG_MUTEXES
    
    Core Changes:
    - Assorted documentation fixes.
    - Use irqsave/restore spinlock to add crc entry.
    - Move code around to drm_client, for internal modeset clients.
    - Make drm_crtc.h and drm_debugfs.h self-contained.
    - Remove drm_fb_helper_connector.
    - Add bootsplash to todo.
    - Fix lock ordering in pan_display_legacy.
    - Support pinning buffers to current location in gem-vram.
    - Remove the now unused locking functions from gem-vram.
    - Remove the now unused kmap-object argument from vram helpers.
    - Stop checking return value of debugfs_create.
    - Add atomic encoder enable/disable helpers.
    - pass drm_atomic_state to atomic connector check.
    - Add atomic support for bridge enable/disable.
    - Add self refresh helpers to core.
    
    Driver Changes:
    - Add extra delay to make MTP SDM845 work.
    - Small fixes to virtio, vkms, sii902x, sii9234, ast, mcde, analogix, rockchip.
    - Add zpos and ?BGR8888 support to meson.
    - More removals of drm_os_linux and drmP headers for amd, radeon, sti, r128, r128, savage, sis.
    - Allow synopsis to unwedge the i2c hdmi bus.
    - Add orientation quirks for GPD panels.
    - Edid cleanups and fixing handling for edid < 1.2.
    - Add runtime pm to stm.
    - Handle s/r in dw-hdmi.
    - Add hooks for power on/off to dsi for stm.
    - Remove virtio dirty tracking code, done in drm core.
    - Rework BO handling in ast and mgag200.
    
    Tiny conflict in drivers/gpu/drm/amd/display/dc/clk_mgr/clk_mgr.c,
    needed #include <linux/slab.h> to make it compile.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    From: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/0e01de30-9797-853c-732f-4a5bd6e61445@linux.intel.com

commit a1651530a3bacf1d796fdb7bc587faef9f305d36
Author: Su Sung Chung <Su.Chung@amd.com>
Date:   Thu May 30 14:59:03 2019 -0400

    drm/amd/display: make clk_mgr call enable_pme_wa
    
    refactor a code so we will call clk_mgr's enable_pme_wa function so we
    can use pme_wa for future asics. This way we don't need to worry about
    different ASIC since clk_mgr already have that information
    
    Signed-off-by: Su Sung Chung <Su.Chung@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 2a7ac452d458..5a831410bc55 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -939,26 +939,12 @@ void hwss_edp_backlight_control(
 		edp_receiver_ready_T9(link);
 }
 
-// Static helper function which calls the correct function
-// based on pp_smu version
-static void set_pme_wa_enable_by_version(struct dc *dc)
-{
-	struct pp_smu_funcs *pp_smu = NULL;
-
-	if (dc->res_pool->pp_smu)
-		pp_smu = dc->res_pool->pp_smu;
-
-	if (pp_smu) {
-		if (pp_smu->ctx.ver == PP_SMU_VER_RV && pp_smu->rv_funcs.set_pme_wa_enable)
-			pp_smu->rv_funcs.set_pme_wa_enable(&(pp_smu->ctx));
-	}
-}
-
 void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 {
 	/* notify audio driver for audio modes of monitor */
 	struct dc *core_dc = pipe_ctx->stream->ctx->dc;
 	struct pp_smu_funcs *pp_smu = NULL;
+	struct clk_mgr *clk_mgr = core_dc->clk_mgr;
 	unsigned int i, num_audio = 1;
 
 	if (pipe_ctx->stream_res.audio && pipe_ctx->stream_res.audio->enabled == true)
@@ -976,9 +962,9 @@ void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 
 		pipe_ctx->stream_res.audio->funcs->az_enable(pipe_ctx->stream_res.audio);
 
-		if (num_audio >= 1 && pp_smu != NULL)
+		if (num_audio >= 1 && clk_mgr->funcs->enable_pme_wa)
 			/*this is the first audio. apply the PME w/a in order to wake AZ from D3*/
-			set_pme_wa_enable_by_version(core_dc);
+			clk_mgr->funcs->enable_pme_wa(clk_mgr);
 		/* un-mute audio */
 		/* TODO: audio should be per stream rather than per link */
 		pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
@@ -992,6 +978,7 @@ void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 {
 	struct dc *dc = pipe_ctx->stream->ctx->dc;
 	struct pp_smu_funcs *pp_smu = NULL;
+	struct clk_mgr *clk_mgr = dc->clk_mgr;
 
 	if (pipe_ctx->stream_res.audio && pipe_ctx->stream_res.audio->enabled == false)
 		return;
@@ -1020,9 +1007,9 @@ void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 			update_audio_usage(&dc->current_state->res_ctx, dc->res_pool, pipe_ctx->stream_res.audio, false);
 			pipe_ctx->stream_res.audio = NULL;
 		}
-		if (pp_smu != NULL)
+		if (clk_mgr->funcs->enable_pme_wa)
 			/*this is the first audio. apply the PME w/a in order to wake AZ from D3*/
-			set_pme_wa_enable_by_version(dc);
+			clk_mgr->funcs->enable_pme_wa(clk_mgr);
 
 		/* TODO: notify audio driver for if audio modes list changed
 		 * add audio mode list change flag */

commit 3de5aa81c5065abd31bf981483c4c6caa97e8798
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Tue May 28 16:36:42 2019 -0400

    drm/amd/display: S3 Resume time increase after decoupling DPMS from fast boot
    
    [Why]
    We incorrectly began powering down the display at boot/resume whenever
    fast boot was not possible. This should not be done in the case where there
    exists a stream for the eDP since this implies that we want to turn it on.
    
    [How]
    Add check for eDP stream to decide whether to power off edp.
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Reza Amini <Reza.Amini@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 3042741b165a..2a7ac452d458 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1507,6 +1507,18 @@ static void disable_vga_and_power_gate_all_controllers(
 	}
 }
 
+
+static struct dc_stream_state *get_edp_stream(struct dc_state *context)
+{
+	int i;
+
+	for (i = 0; i < context->stream_count; i++) {
+		if (context->streams[i]->signal == SIGNAL_TYPE_EDP)
+			return context->streams[i];
+	}
+	return NULL;
+}
+
 static struct dc_link *get_edp_link(struct dc *dc)
 {
 	int i;
@@ -1550,12 +1562,16 @@ void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 	int i;
 	struct dc_link *edp_link_with_sink = get_edp_link_with_sink(dc, context);
 	struct dc_link *edp_link = get_edp_link(dc);
+	struct dc_stream_state *edp_stream = NULL;
 	bool can_apply_edp_fast_boot = false;
 	bool can_apply_seamless_boot = false;
+	bool keep_edp_vdd_on = false;
 
 	if (dc->hwss.init_pipes)
 		dc->hwss.init_pipes(dc, context);
 
+	edp_stream = get_edp_stream(context);
+
 	// Check fastboot support, disable on DCE8 because of blank screens
 	if (edp_link && dc->ctx->dce_version != DCE_VERSION_8_0 &&
 		    dc->ctx->dce_version != DCE_VERSION_8_1 &&
@@ -1563,15 +1579,16 @@ void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 
 		// enable fastboot if backend is enabled on eDP
 		if (edp_link->link_enc->funcs->is_dig_enabled(edp_link->link_enc)) {
-			/* Find eDP stream and set optimization flag */
-			for (i = 0; i < context->stream_count; i++) {
-				if (context->streams[i]->signal == SIGNAL_TYPE_EDP) {
-					context->streams[i]->apply_edp_fast_boot_optimization = true;
-					can_apply_edp_fast_boot = true;
-					break;
-				}
+			/* Set optimization flag on eDP stream*/
+			if (edp_stream) {
+				edp_stream->apply_edp_fast_boot_optimization = true;
+				can_apply_edp_fast_boot = true;
 			}
 		}
+
+		// We are trying to enable eDP, don't power down VDD
+		if (edp_stream)
+			keep_edp_vdd_on = true;
 	}
 
 	// Check seamless boot support
@@ -1586,14 +1603,14 @@ void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 	 * it should get turned off
 	 */
 	if (!can_apply_edp_fast_boot && !can_apply_seamless_boot) {
-		if (edp_link_with_sink) {
+		if (edp_link_with_sink && !keep_edp_vdd_on) {
 			/*turn off backlight before DP_blank and encoder powered down*/
 			dc->hwss.edp_backlight_control(edp_link_with_sink, false);
 		}
 		/*resume from S3, no vbios posting, no need to power down again*/
 		power_down_all_hw_blocks(dc);
 		disable_vga_and_power_gate_all_controllers(dc);
-		if (edp_link_with_sink)
+		if (edp_link_with_sink && !keep_edp_vdd_on)
 			dc->hwss.edp_power_control(edp_link_with_sink, false);
 	}
 	bios_set_scratch_acc_mode_change(dc->ctx->dc_bios);

commit c366be543c5ea35f4d4103f5ee69f052ce2bffe1
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:49 2019 +0200

    drm/amd: drop dependencies on drm_os_linux.h
    
    Fix so no files in drm/amd/ depends on the
    deprecated drm_os_linux.h header file.
    
    It was done manually:
    - remove drm_os_linux.h from drmP.h
    - fix all build errros
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian Knig" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-3-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 7ac50ab1b762..54c266e84416 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -22,6 +22,9 @@
  * Authors: AMD
  *
  */
+
+#include <linux/delay.h>
+
 #include "dm_services.h"
 #include "dc.h"
 #include "dc_bios_types.h"

commit 44ab1aa84ae6fa73b9a05c0c611b0e3d2ba05917
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Fri May 10 14:57:48 2019 -0400

    drm/amd/display: do not power on eDP power rail early
    
    [Why]
    Modern Standby may toggle display adapter state between D0
    and D3 state unpredictably.
    But events that cause transition to D0 are not always resulting
    in a display light up scenario.
    
    Modern eDP panels should be able to power on panel logic
    quickly upon VDD going high. Based on spec, the T3 time
    between VDD on and HPD high can be between 0 and 80 ms.
    
    Doing any tricky sorts of optimization by powering on panel
    VDD early during D0 transition on can negatively impact other
    features due to unnecessary power drain and toggling when
    final system state does not intend for the panel to be lit up.
    
    We need OEMs to source higher end panels that have T3 time
    close to 0 if they want quick S3/Modern Standby resume times.
    
    [How]
    Remove panel VDD power on in init_hw
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index f3dd117b4831..3042741b165a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2352,9 +2352,6 @@ static void init_hw(struct dc *dc)
 		 * default signal on connector). */
 		struct dc_link *link = dc->links[i];
 
-		if (link->link_enc->connector.id == CONNECTOR_ID_EDP)
-			dc->hwss.edp_power_control(link, true);
-
 		link->link_enc->funcs->hw_init(link->link_enc);
 	}
 

commit 70d9e8cb8b4439dcfd42bee08831ffb1c02a4805
Author: Paul Hsieh <paul.hsieh@amd.com>
Date:   Tue May 7 17:58:58 2019 +0800

    drm/amd/display: disable PSR/ABM before destroy DMCU struct
    
    [Why]
    1. DMCU is not running on some platform but driver still send ABM
       command. It may cause assert due to DMCU is not alive.
    2. To make sure PSR disable when driver disable
    
    [How]
    1. Add dmcu_is_running in ABM struct, driver can check this flag to
       determine driver should send ABM command or not.
    2. Send PSR disable command when destroy PSR
    
    Signed-off-by: Paul Hsieh <paul.hsieh@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index f9ee77115a5d..f3dd117b4831 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2324,6 +2324,7 @@ static void init_hw(struct dc *dc)
 	struct dc_bios *bp;
 	struct transform *xfm;
 	struct abm *abm;
+	struct dmcu *dmcu;
 
 	bp = dc->ctx->dc_bios;
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
@@ -2379,6 +2380,10 @@ static void init_hw(struct dc *dc)
 		abm->funcs->abm_init(abm);
 	}
 
+	dmcu = dc->res_pool->dmcu;
+	if (dmcu != NULL && abm != NULL)
+		abm->dmcu_is_running = dmcu->funcs->is_dmcu_initialized(dmcu);
+
 	if (dc->fbc_compressor)
 		dc->fbc_compressor->funcs->power_up_fbc(dc->fbc_compressor);
 

commit 0a32df9cfdb3f48ef77ed821f1b4a3154a234a6e
Author: Eryk Brol <eryk.brol@amd.com>
Date:   Wed May 8 09:08:03 2019 -0400

    drm/amd/display: Disable audio stream only if it's currently enabled
    
    [Why]
    Previously there were 2 consecutive calls being made to disable
    audio stream. The first one disabled the audio stream, and the second
    one went through and also tried to disable the audio stream causing
    BACO entry issues due to the ASIC appearing busy.
    
    [How]
    1. Add a status field to the audio struct which stores enabled/disabled
    info
    2. In the calls to enable/disable audio stream check if we're already
    in the desired state before executing the function
    
    Signed-off-by: Eryk Brol <eryk.brol@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index bb28b057a4c8..f9ee77115a5d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -961,6 +961,9 @@ void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 	struct pp_smu_funcs *pp_smu = NULL;
 	unsigned int i, num_audio = 1;
 
+	if (pipe_ctx->stream_res.audio && pipe_ctx->stream_res.audio->enabled == true)
+		return;
+
 	if (core_dc->res_pool->pp_smu)
 		pp_smu = core_dc->res_pool->pp_smu;
 
@@ -980,6 +983,8 @@ void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 		/* TODO: audio should be per stream rather than per link */
 		pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
 					pipe_ctx->stream_res.stream_enc, false);
+		if (pipe_ctx->stream_res.audio)
+			pipe_ctx->stream_res.audio->enabled = true;
 	}
 }
 
@@ -988,6 +993,9 @@ void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 	struct dc *dc = pipe_ctx->stream->ctx->dc;
 	struct pp_smu_funcs *pp_smu = NULL;
 
+	if (pipe_ctx->stream_res.audio && pipe_ctx->stream_res.audio->enabled == false)
+		return;
+
 	pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
 			pipe_ctx->stream_res.stream_enc, true);
 	if (pipe_ctx->stream_res.audio) {
@@ -1021,6 +1029,8 @@ void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 		/* dal_audio_disable_azalia_audio_jack_presence(stream->audio,
 		 * stream->stream_engine_id);
 		 */
+		if (pipe_ctx->stream_res.audio)
+			pipe_ctx->stream_res.audio->enabled = false;
 	}
 }
 

commit dc88b4a684d284a200c0ecfd8d87179d6f6c89a3
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Mon Apr 22 19:39:35 2019 -0400

    drm/amd/display: make clk mgr soc specific
    
    [Why]
    First step of refactoring clk mgr to better handle different
    ways of handling clock operations. Clock operation policies are
    soc specific and not just DCN vesion specific. It is not a hw resource,
    should not be in the resource pool.
    
    [How]
    Change clock manager creation to be based on HW internal ID, rename
    clock manager members to be more clear. Move clock manager out of
    resource.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 69f215967af3..bb28b057a4c8 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -46,6 +46,7 @@
 #include "link_encoder.h"
 #include "link_hwss.h"
 #include "clock_source.h"
+#include "clk_mgr.h"
 #include "abm.h"
 #include "audio.h"
 #include "reg_helper.h"
@@ -2378,7 +2379,7 @@ void dce110_prepare_bandwidth(
 		struct dc *dc,
 		struct dc_state *context)
 {
-	struct clk_mgr *dccg = dc->res_pool->clk_mgr;
+	struct clk_mgr *dccg = dc->clk_mgr;
 
 	dce110_set_safe_displaymarks(&context->res_ctx, dc->res_pool);
 
@@ -2392,7 +2393,7 @@ void dce110_optimize_bandwidth(
 		struct dc *dc,
 		struct dc_state *context)
 {
-	struct clk_mgr *dccg = dc->res_pool->clk_mgr;
+	struct clk_mgr *dccg = dc->clk_mgr;
 
 	dce110_set_displaymarks(dc, context);
 

commit eed928dcd83ee8c80fa05013bbc019bc9e9e2a0e
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Apr 29 14:35:01 2019 -0400

    drm/amd/display: enabling stream after HPD low to high happened
    
    [Why]
    1. No real HPD plug in/out but HPD happens,
     the driver notifies OS connection changed.
    2. No display in target.
    
    When HPD goes low to high,
    the driver should regard as HPD and enter setmode flow.
    
    [How]
    In this case, even stream didn't change but still retrain.
    
    Signed-off-by: Chiawen Huang <chiawen.huang@amd.com>
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index d3c821f3899b..69f215967af3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2023,8 +2023,10 @@ enum dc_status dce110_apply_ctx_to_hw(
 		if (pipe_ctx->stream == NULL)
 			continue;
 
-		if (pipe_ctx->stream == pipe_ctx_old->stream)
+		if (pipe_ctx->stream == pipe_ctx_old->stream &&
+			pipe_ctx->stream->link->link_state_valid) {
 			continue;
+		}
 
 		if (pipe_ctx_old->stream && !pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
 			continue;

commit be4b289f10ca7ef4272fa0339b167827ba5fd2cd
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Wed Apr 24 10:20:15 2019 -0400

    drm/amd/display: Remove DPMS state dependency for fast boot
    
    [Why]
    The DPMS state of a display should not impact whether we want to enable fast boot.
    Currently fast boot is not enabled when resuming from S4 because of this.
    
    [How]
    Remove check for DPMS state when determining if fast boot
    can be applied.
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 5919716832a5..d3c821f3899b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1496,10 +1496,11 @@ static void disable_vga_and_power_gate_all_controllers(
 	}
 }
 
-static struct dc_link *get_link_for_edp(struct dc *dc)
+static struct dc_link *get_edp_link(struct dc *dc)
 {
 	int i;
 
+	// report any eDP links, even unconnected DDI's
 	for (i = 0; i < dc->link_count; i++) {
 		if (dc->links[i]->connector_signal == SIGNAL_TYPE_EDP)
 			return dc->links[i];
@@ -1507,23 +1508,13 @@ static struct dc_link *get_link_for_edp(struct dc *dc)
 	return NULL;
 }
 
-static struct dc_link *get_link_for_edp_to_turn_off(
+static struct dc_link *get_edp_link_with_sink(
 		struct dc *dc,
 		struct dc_state *context)
 {
 	int i;
 	struct dc_link *link = NULL;
 
-	/* check if eDP panel is suppose to be set mode, if yes, no need to disable */
-	for (i = 0; i < context->stream_count; i++) {
-		if (context->streams[i]->signal == SIGNAL_TYPE_EDP) {
-			if (context->streams[i]->dpms_off == true)
-				return context->streams[i]->sink->link;
-			else
-				return NULL;
-		}
-	}
-
 	/* check if there is an eDP panel not in use */
 	for (i = 0; i < dc->link_count; i++) {
 		if (dc->links[i]->local_sink &&
@@ -1546,59 +1537,53 @@ static struct dc_link *get_link_for_edp_to_turn_off(
 void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 {
 	int i;
-	struct dc_link *edp_link_to_turnoff = NULL;
-	struct dc_link *edp_link = get_link_for_edp(dc);
-	bool can_edp_fast_boot_optimize = false;
-	bool apply_edp_fast_boot_optimization = false;
+	struct dc_link *edp_link_with_sink = get_edp_link_with_sink(dc, context);
+	struct dc_link *edp_link = get_edp_link(dc);
+	bool can_apply_edp_fast_boot = false;
 	bool can_apply_seamless_boot = false;
 
-	for (i = 0; i < context->stream_count; i++) {
-		if (context->streams[i]->apply_seamless_boot_optimization) {
-			can_apply_seamless_boot = true;
-			break;
-		}
-	}
-
 	if (dc->hwss.init_pipes)
 		dc->hwss.init_pipes(dc, context);
 
-	if (edp_link) {
-		/* this seems to cause blank screens on DCE8 */
-		if ((dc->ctx->dce_version == DCE_VERSION_8_0) ||
-		    (dc->ctx->dce_version == DCE_VERSION_8_1) ||
-		    (dc->ctx->dce_version == DCE_VERSION_8_3))
-			can_edp_fast_boot_optimize = false;
-		else
-			can_edp_fast_boot_optimize =
-				edp_link->link_enc->funcs->is_dig_enabled(edp_link->link_enc);
+	// Check fastboot support, disable on DCE8 because of blank screens
+	if (edp_link && dc->ctx->dce_version != DCE_VERSION_8_0 &&
+		    dc->ctx->dce_version != DCE_VERSION_8_1 &&
+		    dc->ctx->dce_version != DCE_VERSION_8_3) {
+
+		// enable fastboot if backend is enabled on eDP
+		if (edp_link->link_enc->funcs->is_dig_enabled(edp_link->link_enc)) {
+			/* Find eDP stream and set optimization flag */
+			for (i = 0; i < context->stream_count; i++) {
+				if (context->streams[i]->signal == SIGNAL_TYPE_EDP) {
+					context->streams[i]->apply_edp_fast_boot_optimization = true;
+					can_apply_edp_fast_boot = true;
+					break;
+				}
+			}
+		}
 	}
 
-	if (can_edp_fast_boot_optimize)
-		edp_link_to_turnoff = get_link_for_edp_to_turn_off(dc, context);
-
-	/* if OS doesn't light up eDP and eDP link is available, we want to disable
-	 * If resume from S4/S5, should optimization.
-	 */
-	if (can_edp_fast_boot_optimize && !edp_link_to_turnoff) {
-		/* Find eDP stream and set optimization flag */
-		for (i = 0; i < context->stream_count; i++) {
-			if (context->streams[i]->signal == SIGNAL_TYPE_EDP) {
-				context->streams[i]->apply_edp_fast_boot_optimization = true;
-				apply_edp_fast_boot_optimization = true;
-			}
+	// Check seamless boot support
+	for (i = 0; i < context->stream_count; i++) {
+		if (context->streams[i]->apply_seamless_boot_optimization) {
+			can_apply_seamless_boot = true;
+			break;
 		}
 	}
 
-	if (!apply_edp_fast_boot_optimization && !can_apply_seamless_boot) {
-		if (edp_link_to_turnoff) {
+	/* eDP should not have stream in resume from S4 and so even with VBios post
+	 * it should get turned off
+	 */
+	if (!can_apply_edp_fast_boot && !can_apply_seamless_boot) {
+		if (edp_link_with_sink) {
 			/*turn off backlight before DP_blank and encoder powered down*/
-			dc->hwss.edp_backlight_control(edp_link_to_turnoff, false);
+			dc->hwss.edp_backlight_control(edp_link_with_sink, false);
 		}
 		/*resume from S3, no vbios posting, no need to power down again*/
 		power_down_all_hw_blocks(dc);
 		disable_vga_and_power_gate_all_controllers(dc);
-		if (edp_link_to_turnoff)
-			dc->hwss.edp_power_control(edp_link_to_turnoff, false);
+		if (edp_link_with_sink)
+			dc->hwss.edp_power_control(edp_link_with_sink, false);
 	}
 	bios_set_scratch_acc_mode_change(dc->ctx->dc_bios);
 }

commit e7e10c464a481e9e94ae571f849d09c8820f1fdb
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Apr 8 15:49:52 2019 -0400

    drm/amd/display: stop external access to internal optc sync params
    
    These are internal otg params and should be handled as such.
    Thich change passes the params as function arguments.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 7d7e93c87c28..5919716832a5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1299,6 +1299,11 @@ static enum dc_status dce110_enable_stream_timing(
 		pipe_ctx->stream_res.tg->funcs->program_timing(
 				pipe_ctx->stream_res.tg,
 				&stream->timing,
+				0,
+				0,
+				0,
+				0,
+				pipe_ctx->stream->signal,
 				true);
 	}
 

commit 1352c779cb74d427f4150cbe779a2f7886f70cae
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue Apr 16 10:30:29 2019 -0400

    drm/amd/display: Fill prescale_params->scale for RGB565
    
    [Why]
    An assertion is thrown when using SURFACE_PIXEL_FORMAT_GRPH_RGB565
    formats on DCE since the prescale_params->scale wasn't being filled.
    
    Found by a dmesg-fail when running the
    igt@kms_plane@pixel-format-pipe-a-planes test on Baffin.
    
    [How]
    Fill in the scale parameter.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 7ac50ab1b762..7d7e93c87c28 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -242,6 +242,9 @@ static void build_prescale_params(struct ipp_prescale_params *prescale_params,
 	prescale_params->mode = IPP_PRESCALE_MODE_FIXED_UNSIGNED;
 
 	switch (plane_state->format) {
+	case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
+		prescale_params->scale = 0x2082;
+		break;
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
 	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
 		prescale_params->scale = 0x2020;

commit 0de34efc7b5f1f34676dcdd7ed8bb8a20038724d
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Mar 20 17:10:41 2019 -0400

    drm/amd/display: fix clk_mgr naming
    
    clk_mgr is called dccg in dc_state, this change fixes that
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index a1c4d26c6747..7ac50ab1b762 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1166,8 +1166,8 @@ static void build_audio_output(
 	if (pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT ||
 			pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {
 		audio_output->pll_info.dp_dto_source_clock_in_khz =
-				state->dccg->funcs->get_dp_ref_clk_frequency(
-						state->dccg);
+				state->clk_mgr->funcs->get_dp_ref_clk_frequency(
+						state->clk_mgr);
 	}
 
 	audio_output->pll_info.feed_back_divider =

commit 813d20dccf93f84f4c16236f7c037dc34db48f10
Author: Aidan Wood <Aidan.Wood@amd.com>
Date:   Fri Feb 22 13:37:03 2019 -0500

    drm/amd/display: Fix multi-thread writing to 1 state
    
    [Why]
    Multiple threads were writing back to one global VBA in DC resulting
    in multiple threads overwriting eachother's data
    
    [How]
    Add an instance of DML (which contains VBA) to each context and
    change all calls that used dc->dml to use context->dml. Created a
    seperate copy constructor for linux in a case where there is no
    access to DC.
    
    Signed-off-by: Aidan Wood <Aidan.Wood@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 1019c59c2e3b..a1c4d26c6747 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1630,18 +1630,18 @@ static void dce110_set_displaymarks(
 			dc->bw_vbios->blackout_duration, pipe_ctx->stream);
 		pipe_ctx->plane_res.mi->funcs->mem_input_program_display_marks(
 			pipe_ctx->plane_res.mi,
-			context->bw.dce.nbp_state_change_wm_ns[num_pipes],
-			context->bw.dce.stutter_exit_wm_ns[num_pipes],
-			context->bw.dce.stutter_entry_wm_ns[num_pipes],
-			context->bw.dce.urgent_wm_ns[num_pipes],
+			context->bw_ctx.bw.dce.nbp_state_change_wm_ns[num_pipes],
+			context->bw_ctx.bw.dce.stutter_exit_wm_ns[num_pipes],
+			context->bw_ctx.bw.dce.stutter_entry_wm_ns[num_pipes],
+			context->bw_ctx.bw.dce.urgent_wm_ns[num_pipes],
 			total_dest_line_time_ns);
 		if (i == underlay_idx) {
 			num_pipes++;
 			pipe_ctx->plane_res.mi->funcs->mem_input_program_chroma_display_marks(
 				pipe_ctx->plane_res.mi,
-				context->bw.dce.nbp_state_change_wm_ns[num_pipes],
-				context->bw.dce.stutter_exit_wm_ns[num_pipes],
-				context->bw.dce.urgent_wm_ns[num_pipes],
+				context->bw_ctx.bw.dce.nbp_state_change_wm_ns[num_pipes],
+				context->bw_ctx.bw.dce.stutter_exit_wm_ns[num_pipes],
+				context->bw_ctx.bw.dce.urgent_wm_ns[num_pipes],
 				total_dest_line_time_ns);
 		}
 		num_pipes++;

commit 248cbed60db05f39913707c1ad74999730487fd6
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Thu Feb 28 14:45:13 2019 -0500

    drm/amd/display: use dc_is_virtual instead of ENUM
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Nevenko Stupar <Nevenko.Stupar@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 951fdf189ef5..1019c59c2e3b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1368,7 +1368,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		pipe_ctx->stream_res.tg->funcs->set_static_screen_control(
 				pipe_ctx->stream_res.tg, event_triggers);
 
-	if (pipe_ctx->stream->signal != SIGNAL_TYPE_VIRTUAL)
+	if (!dc_is_virtual_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_res.stream_enc->funcs->dig_connect_to_otg(
 			pipe_ctx->stream_res.stream_enc,
 			pipe_ctx->stream_res.tg->inst);

commit 661a8cd9516b182c80fff1b2fdfb1b1e42e212d1
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Mar 8 17:09:46 2019 -0500

    drm/amd/display: add missing opp programming for odm
    
    A number of places opp programming was missing for odm second pipe.
    This change fixes the oversight.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e5a3c47c72a2..951fdf189ef5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1377,7 +1377,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 			pipe_ctx->stream_res.opp,
 			COLOR_SPACE_YCBCR601,
 			stream->timing.display_color_depth,
-			pipe_ctx->stream->signal);
+			stream->signal);
 
 	pipe_ctx->stream_res.opp->funcs->opp_program_fmt(
 		pipe_ctx->stream_res.opp,

commit fe6119fb0361521ba4df8887c1791df9c08296f1
Author: Wesley Chalmers <Wesley.Chalmers@amd.com>
Date:   Fri Mar 1 14:28:19 2019 -0500

    drm/amd/display: Fix DP audio regression
    
    Audio was unmuted for HDMI only, need to do so for DP as well.
    
    Signed-off-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Reviewed-by: Chris Park <Chris.Park@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 6b24ddd57a4e..e5a3c47c72a2 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -974,9 +974,8 @@ void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 			set_pme_wa_enable_by_version(core_dc);
 		/* un-mute audio */
 		/* TODO: audio should be per stream rather than per link */
-		if (dc_is_hdmi_tmds_signal(pipe_ctx->stream->signal))
-			pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
-				pipe_ctx->stream_res.stream_enc, false);
+		pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
+					pipe_ctx->stream_res.stream_enc, false);
 	}
 }
 

commit 7fe538a4d64135d8f8e4aca8d0aedf266958025c
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Fri Mar 1 11:12:50 2019 -0500

    drm/amd/display: fix DP 422 VID_M half the rate issue.
    
    [Description]
    when programming VID_TIMING, we were using the original VESA timing for DP_VIDM/N.
    for YCbCr420 or compressed YCbCr422, using half rate as  YCbCr444.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 7ec9958ddd26..6b24ddd57a4e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1052,9 +1052,8 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 	struct dc_link *link = stream->link;
 
 	/* only 3 items below are used by unblank */
-	params.pixel_clk_khz = pipe_ctx->stream->timing.pix_clk_100hz / 10;
+	params.timing = pipe_ctx->stream->timing;
 	params.link_settings.link_rate = link_settings->link_rate;
-	params.pixel_encoding = pipe_ctx->stream->timing.pixel_encoding;
 
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_res.stream_enc->funcs->dp_unblank(pipe_ctx->stream_res.stream_enc, &params);

commit ae5041f3a03134a4cd5fc1c41e082c0e5d290392
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Fri Aug 17 17:57:44 2018 -0400

    drm/amd/display: Fix setting DP_VID_N_MUL
    
    [Why]
    Need to set VID_N_MUL for 4:2:0 cases
    
    [How]
    Move setting to enc1_stream_encoder_dp_unblank and
    ensure it is also set for non-4:2:0 cases.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 89f575f0cd65..7ec9958ddd26 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1054,6 +1054,7 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 	/* only 3 items below are used by unblank */
 	params.pixel_clk_khz = pipe_ctx->stream->timing.pix_clk_100hz / 10;
 	params.link_settings.link_rate = link_settings->link_rate;
+	params.pixel_encoding = pipe_ctx->stream->timing.pixel_encoding;
 
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_res.stream_enc->funcs->dp_unblank(pipe_ctx->stream_res.stream_enc, &params);

commit 33d7598d7022eac064b48e42dd4ae3e1dc9b52cd
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Fri Feb 22 16:50:00 2019 -0500

    drm/amd/display: fix up reference clock abstractions
    
    [why]
    "reference clock" is a very overloaded variable in DC and causes confusion
    as there are multiple sources of reference clock, which may be different values
    incorrect input values to DML will cause DCHUB to be programmed improperly
    and lead to hard to debug underflow issues
    
    [how]
    instead of using ref clock everywhere, specify WHICH ref clock:
    - xtalin
    - dccg refclk
    - dchub refclk
    
    these are all distinct values which may not be equal
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: David Francis <David.Francis@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index ae424c72cd77..89f575f0cd65 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2635,7 +2635,7 @@ void dce110_set_cursor_position(struct pipe_ctx *pipe_ctx)
 	struct mem_input *mi = pipe_ctx->plane_res.mi;
 	struct dc_cursor_mi_param param = {
 		.pixel_clk_khz = pipe_ctx->stream->timing.pix_clk_100hz / 10,
-		.ref_clk_khz = pipe_ctx->stream->ctx->dc->res_pool->ref_clock_inKhz,
+		.ref_clk_khz = pipe_ctx->stream->ctx->dc->res_pool->ref_clocks.xtalin_clock_inKhz,
 		.viewport = pipe_ctx->plane_res.scl_data.viewport,
 		.h_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.horz,
 		.v_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.vert,

commit 02553f57dcddc07a6770d391a54c7eabad59f391
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Fri Feb 15 09:27:22 2019 -0500

    drm/amd/display: Rename is_hdmi to is_hdmi_tmds type
    
    HDMI has TMDS and FRL signal types. Be specific about what is used.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Nevenko Stupar <Nevenko.Stupar@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 21a621822a59..ae424c72cd77 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -616,7 +616,7 @@ dce110_set_output_transfer_func(struct pipe_ctx *pipe_ctx,
 
 void dce110_update_info_frame(struct pipe_ctx *pipe_ctx)
 {
-	bool is_hdmi;
+	bool is_hdmi_tmds;
 	bool is_dp;
 
 	ASSERT(pipe_ctx->stream);
@@ -624,13 +624,13 @@ void dce110_update_info_frame(struct pipe_ctx *pipe_ctx)
 	if (pipe_ctx->stream_res.stream_enc == NULL)
 		return;  /* this is not root pipe */
 
-	is_hdmi = dc_is_hdmi_signal(pipe_ctx->stream->signal);
+	is_hdmi_tmds = dc_is_hdmi_tmds_signal(pipe_ctx->stream->signal);
 	is_dp = dc_is_dp_signal(pipe_ctx->stream->signal);
 
-	if (!is_hdmi && !is_dp)
+	if (!is_hdmi_tmds && !is_dp)
 		return;
 
-	if (is_hdmi)
+	if (is_hdmi_tmds)
 		pipe_ctx->stream_res.stream_enc->funcs->update_hdmi_info_packets(
 			pipe_ctx->stream_res.stream_enc,
 			&pipe_ctx->stream_res.encoder_info_frame);
@@ -974,8 +974,9 @@ void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 			set_pme_wa_enable_by_version(core_dc);
 		/* un-mute audio */
 		/* TODO: audio should be per stream rather than per link */
-		pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
-			pipe_ctx->stream_res.stream_enc, false);
+		if (dc_is_hdmi_tmds_signal(pipe_ctx->stream->signal))
+			pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
+				pipe_ctx->stream_res.stream_enc, false);
 	}
 }
 
@@ -1026,7 +1027,7 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)
 	struct dc_link *link = stream->link;
 	struct dc *dc = pipe_ctx->stream->ctx->dc;
 
-	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
+	if (dc_is_hdmi_tmds_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_res.stream_enc->funcs->stop_hdmi_info_packets(
 			pipe_ctx->stream_res.stream_enc);
 

commit 522f82f35fd0057cae326ad21a5f93a221b08b25
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Wed Jan 30 16:14:38 2019 -0500

    drm/amd/display: make seamless boot work generically
    
    [Why]
    Seamless boot code not working on all ASICs because of
    some underflow issues caused by some uninitialized HW
    state.
    
    [How]
    Keep some logical and power gating init code in hw_init.
    Move some per pipe init code to enable accelerated mode
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 5c7fb92d081c..21a621822a59 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1551,6 +1551,9 @@ void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 		}
 	}
 
+	if (dc->hwss.init_pipes)
+		dc->hwss.init_pipes(dc, context);
+
 	if (edp_link) {
 		/* this seems to cause blank screens on DCE8 */
 		if ((dc->ctx->dce_version == DCE_VERSION_8_0) ||

commit 0f1a6ad724cd5270c7c7d1bba98ac1222a0943b6
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Tue Jan 15 10:46:46 2019 -0500

    drm/amd/display: PPLIB Hookup
    
    [Why]
    Make dml and integration with pplib clearer.
    
    [How]
    Change the way the dml formula is initialized to make its values more
    clear. Restructure DC interface with pplib into rv_funcs.
    Cap clocks received from pplib.
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Signed-off-by: Eryk Brol <eryk.brol@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 5e4db3712eef..5c7fb92d081c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -935,13 +935,31 @@ void hwss_edp_backlight_control(
 		edp_receiver_ready_T9(link);
 }
 
+// Static helper function which calls the correct function
+// based on pp_smu version
+static void set_pme_wa_enable_by_version(struct dc *dc)
+{
+	struct pp_smu_funcs *pp_smu = NULL;
+
+	if (dc->res_pool->pp_smu)
+		pp_smu = dc->res_pool->pp_smu;
+
+	if (pp_smu) {
+		if (pp_smu->ctx.ver == PP_SMU_VER_RV && pp_smu->rv_funcs.set_pme_wa_enable)
+			pp_smu->rv_funcs.set_pme_wa_enable(&(pp_smu->ctx));
+	}
+}
+
 void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 {
-	struct dc *core_dc = pipe_ctx->stream->ctx->dc;
 	/* notify audio driver for audio modes of monitor */
-	struct pp_smu_funcs_rv *pp_smu = core_dc->res_pool->pp_smu;
+	struct dc *core_dc = pipe_ctx->stream->ctx->dc;
+	struct pp_smu_funcs *pp_smu = NULL;
 	unsigned int i, num_audio = 1;
 
+	if (core_dc->res_pool->pp_smu)
+		pp_smu = core_dc->res_pool->pp_smu;
+
 	if (pipe_ctx->stream_res.audio) {
 		for (i = 0; i < MAX_PIPES; i++) {
 			/*current_state not updated yet*/
@@ -951,9 +969,9 @@ void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 
 		pipe_ctx->stream_res.audio->funcs->az_enable(pipe_ctx->stream_res.audio);
 
-		if (num_audio >= 1 && pp_smu != NULL && pp_smu->set_pme_wa_enable != NULL)
+		if (num_audio >= 1 && pp_smu != NULL)
 			/*this is the first audio. apply the PME w/a in order to wake AZ from D3*/
-			pp_smu->set_pme_wa_enable(&pp_smu->pp_smu);
+			set_pme_wa_enable_by_version(core_dc);
 		/* un-mute audio */
 		/* TODO: audio should be per stream rather than per link */
 		pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
@@ -964,17 +982,18 @@ void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 {
 	struct dc *dc = pipe_ctx->stream->ctx->dc;
+	struct pp_smu_funcs *pp_smu = NULL;
 
 	pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
 			pipe_ctx->stream_res.stream_enc, true);
 	if (pipe_ctx->stream_res.audio) {
-		struct pp_smu_funcs_rv *pp_smu = dc->res_pool->pp_smu;
+		if (dc->res_pool->pp_smu)
+			pp_smu = dc->res_pool->pp_smu;
 
 		if (option != KEEP_ACQUIRED_RESOURCE ||
-				!dc->debug.az_endpoint_mute_only) {
+				!dc->debug.az_endpoint_mute_only)
 			/*only disalbe az_endpoint if power down or free*/
 			pipe_ctx->stream_res.audio->funcs->az_disable(pipe_ctx->stream_res.audio);
-		}
 
 		if (dc_is_dp_signal(pipe_ctx->stream->signal))
 			pipe_ctx->stream_res.stream_enc->funcs->dp_audio_disable(
@@ -989,9 +1008,9 @@ void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 			update_audio_usage(&dc->current_state->res_ctx, dc->res_pool, pipe_ctx->stream_res.audio, false);
 			pipe_ctx->stream_res.audio = NULL;
 		}
-		if (pp_smu != NULL && pp_smu->set_pme_wa_enable != NULL)
+		if (pp_smu != NULL)
 			/*this is the first audio. apply the PME w/a in order to wake AZ from D3*/
-			pp_smu->set_pme_wa_enable(&pp_smu->pp_smu);
+			set_pme_wa_enable_by_version(dc);
 
 		/* TODO: notify audio driver for if audio modes list changed
 		 * add audio mode list change flag */

commit d6001aed266391e05517ff03078c144d4b279d5d
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Jan 25 14:40:14 2019 -0500

    drm/amd/display: Refactor for setup periodic interrupt.
    
    [Why]
    Current periodic interrupt start point calc in optc
    is not clear.
    
    [How]
    1. DM convert delta time to lines number and dc will calculate the
       start position as per lines number and interrupt type.
    2. hwss calculates the start point as per line offset.
    3. optc programs vertical interrupts register as per start point
       and interrupt source.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 42ee0a6eeec0..5e4db3712eef 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1333,10 +1333,8 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	if (!pipe_ctx->stream->apply_seamless_boot_optimization)
 		dc->hwss.enable_stream_timing(pipe_ctx, context, dc);
 
-	if (pipe_ctx->stream_res.tg->funcs->program_vupdate_interrupt)
-		pipe_ctx->stream_res.tg->funcs->program_vupdate_interrupt(
-						pipe_ctx->stream_res.tg,
-							&stream->timing);
+	if (dc->hwss.setup_vupdate_interrupt)
+		dc->hwss.setup_vupdate_interrupt(pipe_ctx);
 
 	params.vertical_total_min = stream->adjust.v_total_min;
 	params.vertical_total_max = stream->adjust.v_total_max;

commit 240d09d070a7e082d9cb3c2a6112ce3c43bf5df5
Author: Gary Kattan <gary.kattan@amd.com>
Date:   Fri Jan 25 15:04:14 2019 -0800

    drm/amd/display: Ungate stream before programming registers
    
    [Why]
    Certain tests fail after a fresh reboot. This is caused by writing to
    registers prior to ungating the stream we're trying to program.
    
    [How]
    Make sure the stream is ungated before writing to its registers.
    This also enables power-gating plane resources before init_hw
    initializes them.
    Additionally, this does some refactoring to move gating/ungating
    from enable/disable_plane functions to where stream resources are
    enabled/disabled.
    
    Signed-off-by: Gary Kattan <gary.kattan@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 453ff071793b..42ee0a6eeec0 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1300,6 +1300,10 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	struct drr_params params = {0};
 	unsigned int event_triggers = 0;
 
+	if (dc->hwss.disable_stream_gating) {
+		dc->hwss.disable_stream_gating(dc, pipe_ctx);
+	}
+
 	if (pipe_ctx->stream_res.audio != NULL) {
 		struct audio_output audio_output;
 
@@ -2684,6 +2688,8 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.set_static_screen_control = set_static_screen_control,
 	.reset_hw_ctx_wrap = dce110_reset_hw_ctx_wrap,
 	.enable_stream_timing = dce110_enable_stream_timing,
+	.disable_stream_gating = NULL,
+	.enable_stream_gating = NULL,
 	.setup_stereo = NULL,
 	.set_avmute = dce110_set_avmute,
 	.wait_for_mpcc_disconnect = dce110_wait_for_mpcc_disconnect,

commit ce72741b53cdc70f9738c04920fefb93448f1f5e
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Sun Jan 20 01:54:01 2019 -0500

    drm/amd/display: remove screen flashes on seamless boot
    
    [Why]
    We want boot to desktop to be seamless
    
    [How]
    During init pipes, avoid touching the pipes where GOP has already
    enabled the HW to the state we want.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e1b285ea01ac..453ff071793b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1521,6 +1521,14 @@ void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 	struct dc_link *edp_link = get_link_for_edp(dc);
 	bool can_edp_fast_boot_optimize = false;
 	bool apply_edp_fast_boot_optimization = false;
+	bool can_apply_seamless_boot = false;
+
+	for (i = 0; i < context->stream_count; i++) {
+		if (context->streams[i]->apply_seamless_boot_optimization) {
+			can_apply_seamless_boot = true;
+			break;
+		}
+	}
 
 	if (edp_link) {
 		/* this seems to cause blank screens on DCE8 */
@@ -1549,7 +1557,7 @@ void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 		}
 	}
 
-	if (!apply_edp_fast_boot_optimization) {
+	if (!apply_edp_fast_boot_optimization && !can_apply_seamless_boot) {
 		if (edp_link_to_turnoff) {
 			/*turn off backlight before DP_blank and encoder powered down*/
 			dc->hwss.edp_backlight_control(edp_link_to_turnoff, false);

commit 2c850b7b9e7d0fb36e0bd1ad1238ff55e5c4dcdc
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Jan 14 15:19:44 2019 -0500

    drm/amd/display: add n_vid_mul and half pix_rate for odm
    
    Dp needs half container rate to properly support odm
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 4df8a43b5018..e1b285ea01ac 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1032,8 +1032,7 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 	struct dc_link *link = stream->link;
 
 	/* only 3 items below are used by unblank */
-	params.pixel_clk_khz =
-		pipe_ctx->stream->timing.pix_clk_100hz / 10;
+	params.pixel_clk_khz = pipe_ctx->stream->timing.pix_clk_100hz / 10;
 	params.link_settings.link_rate = link_settings->link_rate;
 
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
@@ -1043,6 +1042,7 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 		link->dc->hwss.edp_backlight_control(link, true);
 	}
 }
+
 void dce110_blank_stream(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;

commit fb55546ea4b50f04ef41c196b8ac1824e26bc48c
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Sun Jan 20 01:23:07 2019 -0500

    drm/amd/display: refactor init_hw to isolate pipe related init
    
    [Why]
    Pipe related init is possible to optimized if we know what we
    intend to program, and if we can determine it matches what is
    already programmed for the pipe.
    
    [How]
    First step is to isolate the pipe related init code
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index a4386348a981..4df8a43b5018 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2275,6 +2275,11 @@ static void dce110_enable_per_frame_crtc_position_reset(
 
 }
 
+static void init_pipes(struct dc *dc, struct dc_state *context)
+{
+	// Do nothing
+}
+
 static void init_hw(struct dc *dc)
 {
 	int i;
@@ -2642,6 +2647,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.program_output_csc = program_output_csc,
 	.init_hw = init_hw,
+	.init_pipes = init_pipes,
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
 	.apply_ctx_for_surface = dce110_apply_ctx_for_surface,
 	.update_plane_addr = update_plane_addr,

commit 9c0fb8d45bfcf2e8f080489913db443c1fd241ed
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Sun Jan 20 01:45:36 2019 -0500

    drm/amd/display: refactor programming of DRR
    
    [Why]
    Keep enable_stream_timing programming only
    timing related stuff.
    
    [How]
    Move DRR and static screen mask programming from
    enable_stream_timing to outside in
    apply_single_controller_ctx_to_hw
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 21ceda410244..a4386348a981 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1250,8 +1250,6 @@ static enum dc_status dce110_enable_stream_timing(
 	struct pipe_ctx *pipe_ctx_old = &dc->current_state->res_ctx.
 			pipe_ctx[pipe_ctx->pipe_idx];
 	struct tg_color black_color = {0};
-	struct drr_params params = {0};
-	unsigned int event_triggers = 0;
 
 	if (!pipe_ctx_old->stream) {
 
@@ -1280,20 +1278,6 @@ static enum dc_status dce110_enable_stream_timing(
 				pipe_ctx->stream_res.tg,
 				&stream->timing,
 				true);
-
-		params.vertical_total_min = stream->adjust.v_total_min;
-		params.vertical_total_max = stream->adjust.v_total_max;
-		if (pipe_ctx->stream_res.tg->funcs->set_drr)
-			pipe_ctx->stream_res.tg->funcs->set_drr(
-				pipe_ctx->stream_res.tg, &params);
-
-		// DRR should set trigger event to monitor surface update event
-		if (stream->adjust.v_total_min != 0 &&
-				stream->adjust.v_total_max != 0)
-			event_triggers = 0x80;
-		if (pipe_ctx->stream_res.tg->funcs->set_static_screen_control)
-			pipe_ctx->stream_res.tg->funcs->set_static_screen_control(
-				pipe_ctx->stream_res.tg, event_triggers);
 	}
 
 	if (!pipe_ctx_old->stream) {
@@ -1313,6 +1297,8 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		struct dc *dc)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
+	struct drr_params params = {0};
+	unsigned int event_triggers = 0;
 
 	if (pipe_ctx->stream_res.audio != NULL) {
 		struct audio_output audio_output;
@@ -1348,6 +1334,19 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 						pipe_ctx->stream_res.tg,
 							&stream->timing);
 
+	params.vertical_total_min = stream->adjust.v_total_min;
+	params.vertical_total_max = stream->adjust.v_total_max;
+	if (pipe_ctx->stream_res.tg->funcs->set_drr)
+		pipe_ctx->stream_res.tg->funcs->set_drr(
+			pipe_ctx->stream_res.tg, &params);
+
+	// DRR should set trigger event to monitor surface update event
+	if (stream->adjust.v_total_min != 0 && stream->adjust.v_total_max != 0)
+		event_triggers = 0x80;
+	if (pipe_ctx->stream_res.tg->funcs->set_static_screen_control)
+		pipe_ctx->stream_res.tg->funcs->set_static_screen_control(
+				pipe_ctx->stream_res.tg, event_triggers);
+
 	if (pipe_ctx->stream->signal != SIGNAL_TYPE_VIRTUAL)
 		pipe_ctx->stream_res.stream_enc->funcs->dig_connect_to_otg(
 			pipe_ctx->stream_res.stream_enc,

commit d2d7885f75b614a982a73383956570d95d79c23e
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Sun Jan 20 01:41:44 2019 -0500

    drm/amd/display: add seamless boot flag to stream
    
    [Why]
    If we determine the stream we are trying to commit
    matches HW, we want to try to optimize.
    
    [How]
    Try to acquire the HW resources that are already enabled
    and optimize.
    Also skip backend reprogramming
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e2d8362dd5b1..21ceda410244 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1339,7 +1339,9 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	}
 
 	/*  */
-	dc->hwss.enable_stream_timing(pipe_ctx, context, dc);
+	/* Do not touch stream timing on seamless boot optimization. */
+	if (!pipe_ctx->stream->apply_seamless_boot_optimization)
+		dc->hwss.enable_stream_timing(pipe_ctx, context, dc);
 
 	if (pipe_ctx->stream_res.tg->funcs->program_vupdate_interrupt)
 		pipe_ctx->stream_res.tg->funcs->program_vupdate_interrupt(

commit a122b62d8ac484091c536ad04e1d0ea156ae6de7
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Sun Jan 20 01:13:42 2019 -0500

    drm/amd/display: refactor out programming of vupdate interrupt
    
    [Why]
    More clearly isolate the code that is involved in programming of
    vupdate interrupt
    
    [How]
    Add function for programming of vupdate interrupt.
    Call it after timing is programmed.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index fd7cd5b5a17c..e2d8362dd5b1 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1341,6 +1341,11 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	/*  */
 	dc->hwss.enable_stream_timing(pipe_ctx, context, dc);
 
+	if (pipe_ctx->stream_res.tg->funcs->program_vupdate_interrupt)
+		pipe_ctx->stream_res.tg->funcs->program_vupdate_interrupt(
+						pipe_ctx->stream_res.tg,
+							&stream->timing);
+
 	if (pipe_ctx->stream->signal != SIGNAL_TYPE_VIRTUAL)
 		pipe_ctx->stream_res.stream_enc->funcs->dig_connect_to_otg(
 			pipe_ctx->stream_res.stream_enc,

commit 12a8bd8862ebd7d6e0f764120e2f322ddc077a11
Author: Shirish S <shirish.s@amd.com>
Date:   Mon Feb 4 14:24:25 2019 +0530

    drm/amd/display: Use context parameters to enable FBC
    
    [What]
    FBC fails to get enabled when switched between LINEAR(console/VT)
    and non-LINEAR(GUI) based rendering due to default value of
    tiling info stored in the current_state which is used for deciding
    whether or not to turn FBC on or off.
    
    [How]
    Use context structure's tiling information which is coherant with
    the screen updates.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index db0ef41eb91c..fd7cd5b5a17c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2535,7 +2535,7 @@ static void dce110_apply_ctx_for_surface(
 	}
 
 	if (dc->fbc_compressor)
-		enable_fbc(dc, dc->current_state);
+		enable_fbc(dc, context);
 }
 
 static void dce110_power_down_fe(struct dc *dc, struct pipe_ctx *pipe_ctx)

commit d2c460e7537f003e5bfb1a94c9201bcbeca6949f
Author: hersen wu <hersenxs.wu@amd.com>
Date:   Fri Jan 11 12:43:20 2019 -0500

    drm/amd/display: Connect dig_fe to otg directly instead of calling bios
    
    [Why] After call bios table crtc_source_select, dal will program fmt
    again. The bios table program dig_source_select and other fmt register
    for bios usage which is redundancy and uncessary.
    
    [How] Program dig_soruce_select register directly
    
    Signed-off-by: hersen wu <hersenxs.wu@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 026d973698f4..db0ef41eb91c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -614,52 +614,6 @@ dce110_set_output_transfer_func(struct pipe_ctx *pipe_ctx,
 	return true;
 }
 
-static enum dc_status bios_parser_crtc_source_select(
-		struct pipe_ctx *pipe_ctx)
-{
-	struct dc_bios *dcb = pipe_ctx->stream->ctx->dc_bios;
-	/* call VBIOS table to set CRTC source for the HW
-	 * encoder block
-	 * note: video bios clears all FMT setting here. */
-	struct bp_crtc_source_select crtc_source_select = {0};
-
-	crtc_source_select.engine_id = pipe_ctx->stream_res.stream_enc->id;
-	crtc_source_select.controller_id = pipe_ctx->stream_res.tg->inst + 1;
-	/*TODO: Need to un-hardcode color depth, dp_audio and account for
-	 * the case where signal and sink signal is different (translator
-	 * encoder)*/
-	crtc_source_select.signal = pipe_ctx->stream->signal;
-	crtc_source_select.enable_dp_audio = false;
-	crtc_source_select.sink_signal = pipe_ctx->stream->signal;
-
-	switch (pipe_ctx->stream->timing.display_color_depth) {
-	case COLOR_DEPTH_666:
-		crtc_source_select.display_output_bit_depth = PANEL_6BIT_COLOR;
-		break;
-	case COLOR_DEPTH_888:
-		crtc_source_select.display_output_bit_depth = PANEL_8BIT_COLOR;
-		break;
-	case COLOR_DEPTH_101010:
-		crtc_source_select.display_output_bit_depth = PANEL_10BIT_COLOR;
-		break;
-	case COLOR_DEPTH_121212:
-		crtc_source_select.display_output_bit_depth = PANEL_12BIT_COLOR;
-		break;
-	default:
-		BREAK_TO_DEBUGGER();
-		crtc_source_select.display_output_bit_depth = PANEL_8BIT_COLOR;
-		break;
-	}
-
-	if (BP_RESULT_OK != dcb->funcs->crtc_source_select(
-		dcb,
-		&crtc_source_select)) {
-		return DC_ERROR_UNEXPECTED;
-	}
-
-	return DC_OK;
-}
-
 void dce110_update_info_frame(struct pipe_ctx *pipe_ctx)
 {
 	bool is_hdmi;
@@ -1387,12 +1341,10 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	/*  */
 	dc->hwss.enable_stream_timing(pipe_ctx, context, dc);
 
-	/* TODO: move to stream encoder */
 	if (pipe_ctx->stream->signal != SIGNAL_TYPE_VIRTUAL)
-		if (DC_OK != bios_parser_crtc_source_select(pipe_ctx)) {
-			BREAK_TO_DEBUGGER();
-			return DC_ERROR_UNEXPECTED;
-		}
+		pipe_ctx->stream_res.stream_enc->funcs->dig_connect_to_otg(
+			pipe_ctx->stream_res.stream_enc,
+			pipe_ctx->stream_res.tg->inst);
 
 	pipe_ctx->stream_res.opp->funcs->opp_set_dyn_expansion(
 			pipe_ctx->stream_res.opp,

commit 0c522b65b04915bae0040258c3945b943e44d0e6
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Fri Jan 11 17:09:18 2019 -0500

    drm/amd/display: take dpms_off into account for edp turn off logic
    
    [why]
    Previously we incorrectly skipped backlight control when stream is
    present but dpms_off = true. This causes backlight to remain on in
    the we boot up or resume into a external display only configuration
    where VBIOS posted on the eDP.
    
    [How]
    Add dpms_off into the condition for edp need to turn off.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 97796fa2f6b6..026d973698f4 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1520,7 +1520,7 @@ static struct dc_link *get_link_for_edp(struct dc *dc)
 	return NULL;
 }
 
-static struct dc_link *get_link_for_edp_not_in_use(
+static struct dc_link *get_link_for_edp_to_turn_off(
 		struct dc *dc,
 		struct dc_state *context)
 {
@@ -1529,8 +1529,12 @@ static struct dc_link *get_link_for_edp_not_in_use(
 
 	/* check if eDP panel is suppose to be set mode, if yes, no need to disable */
 	for (i = 0; i < context->stream_count; i++) {
-		if (context->streams[i]->signal == SIGNAL_TYPE_EDP)
-			return NULL;
+		if (context->streams[i]->signal == SIGNAL_TYPE_EDP) {
+			if (context->streams[i]->dpms_off == true)
+				return context->streams[i]->sink->link;
+			else
+				return NULL;
+		}
 	}
 
 	/* check if there is an eDP panel not in use */
@@ -1572,7 +1576,7 @@ void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 	}
 
 	if (can_edp_fast_boot_optimize)
-		edp_link_to_turnoff = get_link_for_edp_not_in_use(dc, context);
+		edp_link_to_turnoff = get_link_for_edp_to_turn_off(dc, context);
 
 	/* if OS doesn't light up eDP and eDP link is available, we want to disable
 	 * If resume from S4/S5, should optimization.

commit 8635c5a784105af8b833c43bf22cbabd6e64a8f1
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Fri Jan 11 16:54:05 2019 -0500

    revert "drm/amd/display: Add condition to sync eDP SW status and HW status"
    
    [Why]
    This change causes regression for S4 resume where gamma is not
    programmed. The change incorrectly updates the requested dpms_off
    state.
    
    This reverts commit d2b1d6bbc56afab8ebae9d52d7ca0ea3569bd600.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 144a1c8dca1d..97796fa2f6b6 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1557,7 +1557,6 @@ void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 	int i;
 	struct dc_link *edp_link_to_turnoff = NULL;
 	struct dc_link *edp_link = get_link_for_edp(dc);
-	struct dc_bios *bios = dc->ctx->dc_bios;
 	bool can_edp_fast_boot_optimize = false;
 	bool apply_edp_fast_boot_optimization = false;
 
@@ -1584,20 +1583,6 @@ void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 			if (context->streams[i]->signal == SIGNAL_TYPE_EDP) {
 				context->streams[i]->apply_edp_fast_boot_optimization = true;
 				apply_edp_fast_boot_optimization = true;
-
-				/* When after S4 and S5, vbios may post edp and previous dpms_off
-				 * doesn't make sense.
-				 * Update dpms_off state to align hw and sw state via check
-				 * vBios scratch register.
-				 */
-				if (bios->funcs->is_active_display)	{
-					const struct connector_device_tag_info *device_tag = &(edp_link->device_tag);
-
-					if (bios->funcs->is_active_display(bios,
-							context->streams[i]->signal,
-							device_tag))
-						context->streams[i]->dpms_off = false;
-				}
 			}
 		}
 	}

commit 070fe7246f0666d8da2b06e4e829adaf26c75a0f
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Dec 12 18:09:16 2018 -0500

    drm/amd/display: fix PME notification not working in RV desktop
    
    [Why]
    PPLIB not receive the PME when unplug.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Chris Park <Chris.Park@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 602a41d1fc5d..144a1c8dca1d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -997,7 +997,7 @@ void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 
 		pipe_ctx->stream_res.audio->funcs->az_enable(pipe_ctx->stream_res.audio);
 
-		if (num_audio == 1 && pp_smu != NULL && pp_smu->set_pme_wa_enable != NULL)
+		if (num_audio >= 1 && pp_smu != NULL && pp_smu->set_pme_wa_enable != NULL)
 			/*this is the first audio. apply the PME w/a in order to wake AZ from D3*/
 			pp_smu->set_pme_wa_enable(&pp_smu->pp_smu);
 		/* un-mute audio */
@@ -1014,6 +1014,8 @@ void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 	pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
 			pipe_ctx->stream_res.stream_enc, true);
 	if (pipe_ctx->stream_res.audio) {
+		struct pp_smu_funcs_rv *pp_smu = dc->res_pool->pp_smu;
+
 		if (option != KEEP_ACQUIRED_RESOURCE ||
 				!dc->debug.az_endpoint_mute_only) {
 			/*only disalbe az_endpoint if power down or free*/
@@ -1033,6 +1035,9 @@ void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 			update_audio_usage(&dc->current_state->res_ctx, dc->res_pool, pipe_ctx->stream_res.audio, false);
 			pipe_ctx->stream_res.audio = NULL;
 		}
+		if (pp_smu != NULL && pp_smu->set_pme_wa_enable != NULL)
+			/*this is the first audio. apply the PME w/a in order to wake AZ from D3*/
+			pp_smu->set_pme_wa_enable(&pp_smu->pp_smu);
 
 		/* TODO: notify audio driver for if audio modes list changed
 		 * add audio mode list change flag */

commit 4bd0dc68fd00f41ed64fbcfe7b7afe93763b04ad
Author: Joshua Aberback <joshua.aberback@amd.com>
Date:   Mon Dec 10 13:46:34 2018 -0500

    drm/amd/display: Fix missing hwss function for dce
    
    [Why]
    The driver will crash on dce hardware due to a null function pointer.
    
    [How]
    - bring back "program_csc_matrix" functionality as "program_output_csc" for
    dce110
    - dce110 doesn't use the "opp_id" parameter, so use 0 when there's no hubp
    
    Signed-off-by: Joshua Aberback <joshua.aberback@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 8e961e699db5..602a41d1fc5d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2616,6 +2616,28 @@ static void dce110_wait_for_mpcc_disconnect(
 	/* do nothing*/
 }
 
+static void program_output_csc(struct dc *dc,
+		struct pipe_ctx *pipe_ctx,
+		enum dc_color_space colorspace,
+		uint16_t *matrix,
+		int opp_id)
+{
+	int i;
+	struct out_csc_color_matrix tbl_entry;
+
+	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment == true) {
+		enum dc_color_space color_space = pipe_ctx->stream->output_color_space;
+
+		for (i = 0; i < 12; i++)
+			tbl_entry.regval[i] = pipe_ctx->stream->csc_color_matrix.matrix[i];
+
+		tbl_entry.color_space = color_space;
+
+		pipe_ctx->plane_res.xfm->funcs->opp_set_csc_adjustment(
+				pipe_ctx->plane_res.xfm, &tbl_entry);
+	}
+}
+
 void dce110_set_cursor_position(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_cursor_position pos_cpy = pipe_ctx->stream->cursor_position;
@@ -2666,6 +2688,7 @@ void dce110_set_cursor_attribute(struct pipe_ctx *pipe_ctx)
 
 static const struct hw_sequencer_funcs dce110_funcs = {
 	.program_gamut_remap = program_gamut_remap,
+	.program_output_csc = program_output_csc,
 	.init_hw = init_hw,
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
 	.apply_ctx_for_surface = dce110_apply_ctx_for_surface,

commit 380604e27bc9c26ce64a83044aa1ea76ffd28caf
Author: Ken Chalmers <ken.chalmers@amd.com>
Date:   Tue Nov 6 14:24:12 2018 -0500

    drm/amd/display: Use 100 Hz precision for pipe pixel clocks
    
    [Why]
    Users would like more accurate pixel clocks, especially for fractional
    "TV" frame rates like 59.94 Hz.
    
    [How]
    Store and communicate pixel clocks with 100 Hz accuracy from
    dc_crtc_timing through to BIOS command table setpixelclock call.
    
    Signed-off-by: Ken Chalmers <ken.chalmers@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e947cc5381ec..8e961e699db5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1074,7 +1074,7 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 
 	/* only 3 items below are used by unblank */
 	params.pixel_clk_khz =
-		pipe_ctx->stream->timing.pix_clk_khz;
+		pipe_ctx->stream->timing.pix_clk_100hz / 10;
 	params.link_settings.link_rate = link_settings->link_rate;
 
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
@@ -1160,27 +1160,27 @@ static void build_audio_output(
 			stream->timing.flags.INTERLACE;
 
 	audio_output->crtc_info.refresh_rate =
-		(stream->timing.pix_clk_khz*1000)/
+		(stream->timing.pix_clk_100hz*10000)/
 		(stream->timing.h_total*stream->timing.v_total);
 
 	audio_output->crtc_info.color_depth =
 		stream->timing.display_color_depth;
 
 	audio_output->crtc_info.requested_pixel_clock =
-			pipe_ctx->stream_res.pix_clk_params.requested_pix_clk;
+			pipe_ctx->stream_res.pix_clk_params.requested_pix_clk_100hz / 10;
 
 	audio_output->crtc_info.calculated_pixel_clock =
-			pipe_ctx->stream_res.pix_clk_params.requested_pix_clk;
+			pipe_ctx->stream_res.pix_clk_params.requested_pix_clk_100hz / 10;
 
 /*for HDMI, audio ACR is with deep color ratio factor*/
 	if (dc_is_hdmi_signal(pipe_ctx->stream->signal) &&
 		audio_output->crtc_info.requested_pixel_clock ==
-				stream->timing.pix_clk_khz) {
+				(stream->timing.pix_clk_100hz / 10)) {
 		if (pipe_ctx->stream_res.pix_clk_params.pixel_encoding == PIXEL_ENCODING_YCBCR420) {
 			audio_output->crtc_info.requested_pixel_clock =
 					audio_output->crtc_info.requested_pixel_clock/2;
 			audio_output->crtc_info.calculated_pixel_clock =
-					pipe_ctx->stream_res.pix_clk_params.requested_pix_clk/2;
+					pipe_ctx->stream_res.pix_clk_params.requested_pix_clk_100hz/20;
 
 		}
 	}
@@ -1621,8 +1621,8 @@ static uint32_t compute_pstate_blackout_duration(
 	pstate_blackout_duration_ns = 1000 * blackout_duration.value >> 24;
 
 	total_dest_line_time_ns = 1000000UL *
-		stream->timing.h_total /
-		stream->timing.pix_clk_khz +
+		(stream->timing.h_total * 10) /
+		stream->timing.pix_clk_100hz +
 		pstate_blackout_duration_ns;
 
 	return total_dest_line_time_ns;
@@ -2567,7 +2567,7 @@ static void dce110_apply_ctx_for_surface(
 				pipe_ctx->plane_res.mi,
 				pipe_ctx->stream->timing.h_total,
 				pipe_ctx->stream->timing.v_total,
-				pipe_ctx->stream->timing.pix_clk_khz,
+				pipe_ctx->stream->timing.pix_clk_100hz / 10,
 				context->stream_count);
 
 		dce110_program_front_end_for_pipe(dc, pipe_ctx);
@@ -2622,7 +2622,7 @@ void dce110_set_cursor_position(struct pipe_ctx *pipe_ctx)
 	struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
 	struct mem_input *mi = pipe_ctx->plane_res.mi;
 	struct dc_cursor_mi_param param = {
-		.pixel_clk_khz = pipe_ctx->stream->timing.pix_clk_khz,
+		.pixel_clk_khz = pipe_ctx->stream->timing.pix_clk_100hz / 10,
 		.ref_clk_khz = pipe_ctx->stream->ctx->dc->res_pool->ref_clock_inKhz,
 		.viewport = pipe_ctx->plane_res.scl_data.viewport,
 		.h_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.horz,

commit ceb3dbb4690db8377ad127a5666cd4775d9f70f4
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Fri Nov 9 09:21:21 2018 -0500

    drm/amd/display: remove sink reference in dc_stream_state
    
    [why]
    dc_stream_state containing a pointer to sink is poor design.
    Sink describes the display, and the specifications or capabilities
    it has.  That information is irrelevant for dc_stream_state, which describes
    hardware state, and is generally used for hardware programming.  It
    could further be argued that dc_sink itself is just a convenience dc
    provides, and DC should be perfectly capable of programming hardware
    without any dc_sinks (for example, emulated sinks).
    
    [how]
    Phase 1:
    Deprecate use of dc_sink pointer in dc_stream.  Most references are trivial
    to remove, but some call sites are risky (such as is_timing_changed) with
    no obvious logical replacement.  These will be removed in follow up change.
    
    Add dc_link pointer to dc_stream.  This is the typical reason DC really needed
    sink pointer, and most call sites are replaced with this.
    
    DMs also need minor updates, as all 3 DMs leverage stream->sink for
    some functionality.  this is replaced instead by a pointer to private data
    inside dc_stream_state, which is used by DMs as a quality of life improvment
    for some key functionality.  it allows DMs to set pointers have to their own objects
    which associate OS objects to dc_stream_states (such as DisplayTarget
    and amdgpu_dm_connector).  Without the private pointer, DMs would be
    forced to perform a lookup for callbacks.
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: David Francis <David.Francis@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 4bf24758217f..e947cc5381ec 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -617,12 +617,11 @@ dce110_set_output_transfer_func(struct pipe_ctx *pipe_ctx,
 static enum dc_status bios_parser_crtc_source_select(
 		struct pipe_ctx *pipe_ctx)
 {
-	struct dc_bios *dcb;
+	struct dc_bios *dcb = pipe_ctx->stream->ctx->dc_bios;
 	/* call VBIOS table to set CRTC source for the HW
 	 * encoder block
 	 * note: video bios clears all FMT setting here. */
 	struct bp_crtc_source_select crtc_source_select = {0};
-	const struct dc_sink *sink = pipe_ctx->stream->sink;
 
 	crtc_source_select.engine_id = pipe_ctx->stream_res.stream_enc->id;
 	crtc_source_select.controller_id = pipe_ctx->stream_res.tg->inst + 1;
@@ -652,8 +651,6 @@ static enum dc_status bios_parser_crtc_source_select(
 		break;
 	}
 
-	dcb = sink->ctx->dc_bios;
-
 	if (BP_RESULT_OK != dcb->funcs->crtc_source_select(
 		dcb,
 		&crtc_source_select)) {
@@ -692,10 +689,10 @@ void dce110_update_info_frame(struct pipe_ctx *pipe_ctx)
 void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 {
 	enum dc_lane_count lane_count =
-		pipe_ctx->stream->sink->link->cur_link_settings.lane_count;
+		pipe_ctx->stream->link->cur_link_settings.lane_count;
 
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;
-	struct dc_link *link = pipe_ctx->stream->sink->link;
+	struct dc_link *link = pipe_ctx->stream->link;
 
 
 	uint32_t active_total_with_borders;
@@ -1048,7 +1045,7 @@ void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
 void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
-	struct dc_link *link = stream->sink->link;
+	struct dc_link *link = stream->link;
 	struct dc *dc = pipe_ctx->stream->ctx->dc;
 
 	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
@@ -1073,7 +1070,7 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 {
 	struct encoder_unblank_param params = { { 0 } };
 	struct dc_stream_state *stream = pipe_ctx->stream;
-	struct dc_link *link = stream->sink->link;
+	struct dc_link *link = stream->link;
 
 	/* only 3 items below are used by unblank */
 	params.pixel_clk_khz =
@@ -1090,7 +1087,7 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 void dce110_blank_stream(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
-	struct dc_link *link = stream->sink->link;
+	struct dc_link *link = stream->link;
 
 	if (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP) {
 		link->dc->hwss.edp_backlight_control(link, false);
@@ -1408,7 +1405,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
 
-	pipe_ctx->stream->sink->link->psr_enabled = false;
+	pipe_ctx->stream->link->psr_enabled = false;
 
 	return DC_OK;
 }
@@ -1813,18 +1810,15 @@ static bool should_enable_fbc(struct dc *dc,
 	if (i == dc->res_pool->pipe_count)
 		return false;
 
-	if (!pipe_ctx->stream->sink)
-		return false;
-
-	if (!pipe_ctx->stream->sink->link)
+	if (!pipe_ctx->stream->link)
 		return false;
 
 	/* Only supports eDP */
-	if (pipe_ctx->stream->sink->link->connector_signal != SIGNAL_TYPE_EDP)
+	if (pipe_ctx->stream->link->connector_signal != SIGNAL_TYPE_EDP)
 		return false;
 
 	/* PSR should not be enabled */
-	if (pipe_ctx->stream->sink->link->psr_enabled)
+	if (pipe_ctx->stream->link->psr_enabled)
 		return false;
 
 	/* Nothing to compress */

commit 12750d1647f118496f1da727146f255f5e44d500
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Thu Nov 22 02:07:06 2018 -0500

    drm/amd/display: fix YCbCr420 blank color
    
    [Why]
    YCbCr420 packing format uses two chanels for luma, and 1
    channel for both chroma component. Our previous implementation
    did not account for this and results in every other pixel having
    very high luma value, showing greyish color instead of black.
    
    YCbCr444 = <Y1, Cb1, Cr1>; <Y2, Cb2, Cr2> .....
    YCbCr420 = <Y1, Y2,  Cb1>; <Y3, Y4,  Cr1> .....
    
    [How]
    Program the second channel with the black color value for luma
    as well.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Hugo Hu <Hugo.Hu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 6349ba7bec7c..4bf24758217f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1267,10 +1267,19 @@ static void program_scaler(const struct dc *dc,
 		pipe_ctx->plane_res.scl_data.lb_params.depth,
 		&pipe_ctx->stream->bit_depth_params);
 
-	if (pipe_ctx->stream_res.tg->funcs->set_overscan_blank_color)
+	if (pipe_ctx->stream_res.tg->funcs->set_overscan_blank_color) {
+		/*
+		 * The way 420 is packed, 2 channels carry Y component, 1 channel
+		 * alternate between Cb and Cr, so both channels need the pixel
+		 * value for Y
+		 */
+		if (pipe_ctx->stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)
+			color.color_r_cr = color.color_g_y;
+
 		pipe_ctx->stream_res.tg->funcs->set_overscan_blank_color(
 				pipe_ctx->stream_res.tg,
 				&color);
+	}
 
 	pipe_ctx->plane_res.xfm->funcs->transform_set_scaler(pipe_ctx->plane_res.xfm,
 		&pipe_ctx->plane_res.scl_data);

commit 65d38262b3e82fc795464e48ee88cb66fd4c85aa
Author: hersen wu <hersenxs.wu@amd.com>
Date:   Tue Oct 30 16:39:15 2018 -0400

    drm/amd/display: fbc state could not reach while enable fbc
    
       [WHY] fbc is within the data path from memory to dce. while
       re-configure mc dmif, fbc should be enabled. otherwise, fbc
       may not be enabled properly.
    
       [HOW] before re-configure mc dmif, disable fbc, only after
       dmif re-configuration fully done, enable fbc again.
    
    Signed-off-by: hersen wu <hersenxs.wu@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 2f062bacd78a..6349ba7bec7c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1766,12 +1766,13 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
  *  Check if FBC can be enabled
  */
 static bool should_enable_fbc(struct dc *dc,
-			      struct dc_state *context,
-			      uint32_t *pipe_idx)
+		struct dc_state *context,
+		uint32_t *pipe_idx)
 {
 	uint32_t i;
 	struct pipe_ctx *pipe_ctx = NULL;
 	struct resource_context *res_ctx = &context->res_ctx;
+	unsigned int underlay_idx = dc->res_pool->underlay_pipe_index;
 
 
 	ASSERT(dc->fbc_compressor);
@@ -1786,14 +1787,28 @@ static bool should_enable_fbc(struct dc *dc,
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		if (res_ctx->pipe_ctx[i].stream) {
+
 			pipe_ctx = &res_ctx->pipe_ctx[i];
-			*pipe_idx = i;
-			break;
+
+			if (!pipe_ctx)
+				continue;
+
+			/* fbc not applicable on underlay pipe */
+			if (pipe_ctx->pipe_idx != underlay_idx) {
+				*pipe_idx = i;
+				break;
+			}
 		}
 	}
 
-	/* Pipe context should be found */
-	ASSERT(pipe_ctx);
+	if (i == dc->res_pool->pipe_count)
+		return false;
+
+	if (!pipe_ctx->stream->sink)
+		return false;
+
+	if (!pipe_ctx->stream->sink->link)
+		return false;
 
 	/* Only supports eDP */
 	if (pipe_ctx->stream->sink->link->connector_signal != SIGNAL_TYPE_EDP)
@@ -1817,8 +1832,9 @@ static bool should_enable_fbc(struct dc *dc,
 /*
  *  Enable FBC
  */
-static void enable_fbc(struct dc *dc,
-		       struct dc_state *context)
+static void enable_fbc(
+		struct dc *dc,
+		struct dc_state *context)
 {
 	uint32_t pipe_idx = 0;
 
@@ -1828,10 +1844,9 @@ static void enable_fbc(struct dc *dc,
 		struct compressor *compr = dc->fbc_compressor;
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[pipe_idx];
 
-
 		params.source_view_width = pipe_ctx->stream->timing.h_addressable;
 		params.source_view_height = pipe_ctx->stream->timing.v_addressable;
-
+		params.inst = pipe_ctx->stream_res.tg->inst;
 		compr->compr_surface_address.quad_part = dc->ctx->fbc_gpu_addr;
 
 		compr->funcs->surface_address_and_pitch(compr, &params);
@@ -2046,10 +2061,10 @@ enum dc_status dce110_apply_ctx_to_hw(
 			return status;
 	}
 
-	dcb->funcs->set_scratch_critical_state(dcb, false);
-
 	if (dc->fbc_compressor)
-		enable_fbc(dc, context);
+		enable_fbc(dc, dc->current_state);
+
+	dcb->funcs->set_scratch_critical_state(dcb, false);
 
 	return DC_OK;
 }
@@ -2408,7 +2423,6 @@ static void dce110_program_front_end_for_pipe(
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
-	unsigned int underlay_idx = dc->res_pool->underlay_pipe_index;
 	unsigned int i;
 	DC_LOGGER_INIT();
 	memset(&tbl_entry, 0, sizeof(tbl_entry));
@@ -2449,15 +2463,6 @@ static void dce110_program_front_end_for_pipe(
 
 	program_scaler(dc, pipe_ctx);
 
-	/* fbc not applicable on Underlay pipe */
-	if (dc->fbc_compressor && old_pipe->stream &&
-	    pipe_ctx->pipe_idx != underlay_idx) {
-		if (plane_state->tiling_info.gfx8.array_mode == DC_ARRAY_LINEAR_GENERAL)
-			dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);
-		else
-			enable_fbc(dc, dc->current_state);
-	}
-
 	mi->funcs->mem_input_program_surface_config(
 			mi,
 			plane_state->format,
@@ -2534,6 +2539,9 @@ static void dce110_apply_ctx_for_surface(
 	if (num_planes == 0)
 		return;
 
+	if (dc->fbc_compressor)
+		dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);
+
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *old_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
@@ -2576,6 +2584,9 @@ static void dce110_apply_ctx_for_surface(
 			(pipe_ctx->plane_state || old_pipe_ctx->plane_state))
 			dc->hwss.pipe_control_lock(dc, pipe_ctx, false);
 	}
+
+	if (dc->fbc_compressor)
+		enable_fbc(dc, dc->current_state);
 }
 
 static void dce110_power_down_fe(struct dc *dc, struct pipe_ctx *pipe_ctx)

commit 37cd85ce3322706d9d357ffbe54481fa884af9e5
Author: David Francis <David.Francis@amd.com>
Date:   Tue Oct 16 14:21:32 2018 -0400

    drm/amd/display: Remove dc_stream_state->status
    
    [Why]
    dc_state has an array of dc_stream_status that contain
    pointers to the dc_plane_state and other useful information
    
    Confusingly, dc_stream_state also contains a dc_stream_status
    called status.  This struct was partially initialized and
    used in a few places
    
    [How]
    stream->status.link has been replaced with stream->sink->link.
    If a stream does not have a sink, or a sink does not have a link,
    something has gone seriously wrong
    
    All other properties of stream->status were zeroed by kzalloc
    and never initialized, so they have been replaced by the number 0
    
    This is a refactor: no functional change is intended
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 9724a17e352b..2f062bacd78a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2282,7 +2282,7 @@ static void dce110_enable_per_frame_crtc_position_reset(
 	int i;
 
 	gsl_params.gsl_group = 0;
-	gsl_params.gsl_master = grouped_pipes[0]->stream->triggered_crtc_reset.event_source->status.primary_otg_inst;
+	gsl_params.gsl_master = 0;
 
 	for (i = 0; i < group_size; i++)
 		grouped_pipes[i]->stream_res.tg->funcs->setup_global_swap_lock(

commit 593f79a236e11fbc570db509242c2b4ef0526c5d
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Nov 2 10:51:50 2018 -0500

    drm/amdgpu/display: check if fbc is available in set_static_screen_control (v2)
    
    The value is dependent on whether fbc is available.
    
    v2: only check if num_pipes is valid
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 4789270c29d9..9724a17e352b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1750,7 +1750,12 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
 	if (events->force_trigger)
 		value |= 0x1;
 
-	value |= 0x84;
+	if (num_pipes) {
+		struct dc *dc = pipe_ctx[0]->stream->ctx->dc;
+
+		if (dc->fbc_compressor)
+			value |= 0x84;
+	}
 
 	for (i = 0; i < num_pipes; i++)
 		pipe_ctx[i]->stream_res.tg->funcs->

commit d2b1d6bbc56afab8ebae9d52d7ca0ea3569bd600
Author: Lewis Huang <Lewis.Huang@amd.com>
Date:   Thu Oct 18 17:52:19 2018 +0800

    drm/amd/display: Add condition to sync eDP SW status and HW status
    
    [Why]
    Need to disable EDP backlight when enter S4 with EDP only
    and resume from S4 with secondary only.
    
    [How]
    Align the real hw and sw state via vBios scratch register in
    function enable_accelerated_mode when resume from S4.
    
    Signed-off-by: Lewis Huang <Lewis.Huang@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 8873a6092052..4789270c29d9 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1546,6 +1546,7 @@ void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 	int i;
 	struct dc_link *edp_link_to_turnoff = NULL;
 	struct dc_link *edp_link = get_link_for_edp(dc);
+	struct dc_bios *bios = dc->ctx->dc_bios;
 	bool can_edp_fast_boot_optimize = false;
 	bool apply_edp_fast_boot_optimization = false;
 
@@ -1572,6 +1573,20 @@ void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 			if (context->streams[i]->signal == SIGNAL_TYPE_EDP) {
 				context->streams[i]->apply_edp_fast_boot_optimization = true;
 				apply_edp_fast_boot_optimization = true;
+
+				/* When after S4 and S5, vbios may post edp and previous dpms_off
+				 * doesn't make sense.
+				 * Update dpms_off state to align hw and sw state via check
+				 * vBios scratch register.
+				 */
+				if (bios->funcs->is_active_display)	{
+					const struct connector_device_tag_info *device_tag = &(edp_link->device_tag);
+
+					if (bios->funcs->is_active_display(bios,
+							context->streams[i]->signal,
+							device_tag))
+						context->streams[i]->dpms_off = false;
+				}
 			}
 		}
 	}

commit 3917a470757cf55155663240481b1dda0206717b
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Fri Oct 12 17:31:58 2018 -0400

    drm/amd/display: Remove program_csc_matrix
    
    [Why] On DCN1/DCE, There are two functions programming OCSC:
    program_csc_matrix and program_output_csc. They do the same thing.
    
    [How] Consolidate to use only program_output_csc.
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index de220778da8e..8873a6092052 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2582,28 +2582,6 @@ static void dce110_wait_for_mpcc_disconnect(
 	/* do nothing*/
 }
 
-static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
-		enum dc_color_space colorspace,
-		uint16_t *matrix)
-{
-	int i;
-	struct out_csc_color_matrix tbl_entry;
-
-	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment
-				== true) {
-			enum dc_color_space color_space =
-				pipe_ctx->stream->output_color_space;
-
-			//uint16_t matrix[12];
-			for (i = 0; i < 12; i++)
-				tbl_entry.regval[i] = pipe_ctx->stream->csc_color_matrix.matrix[i];
-
-			tbl_entry.color_space = color_space;
-			//tbl_entry.regval = matrix;
-			pipe_ctx->plane_res.xfm->funcs->opp_set_csc_adjustment(pipe_ctx->plane_res.xfm, &tbl_entry);
-	}
-}
-
 void dce110_set_cursor_position(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_cursor_position pos_cpy = pipe_ctx->stream->cursor_position;
@@ -2654,7 +2632,6 @@ void dce110_set_cursor_attribute(struct pipe_ctx *pipe_ctx)
 
 static const struct hw_sequencer_funcs dce110_funcs = {
 	.program_gamut_remap = program_gamut_remap,
-	.program_csc_matrix = program_csc_matrix,
 	.init_hw = init_hw,
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
 	.apply_ctx_for_surface = dce110_apply_ctx_for_surface,

commit 262485a50fd4532a8d71165190adc7a0a19bcc9e
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Fri Oct 12 21:34:32 2018 -0400

    drm/amd/display: Expand dc to use 16.16 bit backlight
    
    [Why] We want to increase precision for backlight setting.
    But DC interface takes 8 bit backlight level value only.
    
    [How] DMCU already takes 16 bit backlight level.
    Expand the DC interface to take 16.16 bit value.
    Max 32 bit backlight value (0xFFFF) will represent
    max backlight (100%)
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index de3c3276db10..de220778da8e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1085,7 +1085,6 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 
 	if (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP) {
 		link->dc->hwss.edp_backlight_control(link, true);
-		stream->bl_pwm_level = EDP_BACKLIGHT_RAMP_DISABLE_LEVEL;
 	}
 }
 void dce110_blank_stream(struct pipe_ctx *pipe_ctx)

commit 69133b89359120e741dff3e09dcfdc08ff954445
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Wed Oct 10 19:02:48 2018 -0400

    drm/amd/display: Fix up coverity issues
    
    [Why]
    Coverity found various high-impact issues that need resolving.
    
    [How]
    Fix  some buffer overruns and uninitialized variables.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e8c362046db7..de3c3276db10 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -548,14 +548,14 @@ dce110_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
 
 	regamma_params->hw_points_num = hw_points;
 
-	i = 1;
-	for (k = 0; k < 16 && i < 16; k++) {
+	k = 0;
+	for (i = 1; i < 16; i++) {
 		if (seg_distr[k] != -1) {
 			regamma_params->arr_curve_points[k].segments_num = seg_distr[k];
 			regamma_params->arr_curve_points[i].offset =
 					regamma_params->arr_curve_points[k].offset + (1 << seg_distr[k]);
 		}
-		i++;
+		k++;
 	}
 
 	if (seg_distr[k] != -1)

commit 84e7fc05a92700297f1de945251fa3b14349532c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Sep 28 07:46:42 2018 -0400

    drm/amd/display: rename dccg to clk_mgr
    
    In preparation for adding the actual dccg block since the
    current implementation of dccg is mor eof a clock manager
    than a hw block
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index bd3ce10f6309..e8c362046db7 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2357,7 +2357,7 @@ void dce110_prepare_bandwidth(
 		struct dc *dc,
 		struct dc_state *context)
 {
-	struct dccg *dccg = dc->res_pool->dccg;
+	struct clk_mgr *dccg = dc->res_pool->clk_mgr;
 
 	dce110_set_safe_displaymarks(&context->res_ctx, dc->res_pool);
 
@@ -2371,7 +2371,7 @@ void dce110_optimize_bandwidth(
 		struct dc *dc,
 		struct dc_state *context)
 {
-	struct dccg *dccg = dc->res_pool->dccg;
+	struct clk_mgr *dccg = dc->res_pool->clk_mgr;
 
 	dce110_set_displaymarks(dc, context);
 

commit 9566b67586fb1d96c36207fd975087d68296755c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Sep 18 15:00:49 2018 -0400

    drm/amd/display: remove safe_to_lower flag from dc, use 2 functions instead
    
    This is done to keep things more readable, avoids a true/false flag
    in dc interface layer.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 0d25dcf6408a..bd3ce10f6309 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2352,22 +2352,33 @@ static void init_hw(struct dc *dc)
 
 }
 
-void dce110_set_bandwidth(
+
+void dce110_prepare_bandwidth(
 		struct dc *dc,
-		struct dc_state *context,
-		bool decrease_allowed)
+		struct dc_state *context)
 {
 	struct dccg *dccg = dc->res_pool->dccg;
 
-	if (decrease_allowed)
-		dce110_set_displaymarks(dc, context);
-	else
-		dce110_set_safe_displaymarks(&context->res_ctx, dc->res_pool);
+	dce110_set_safe_displaymarks(&context->res_ctx, dc->res_pool);
 
 	dccg->funcs->update_clocks(
 			dccg,
 			context,
-			decrease_allowed);
+			false);
+}
+
+void dce110_optimize_bandwidth(
+		struct dc *dc,
+		struct dc_state *context)
+{
+	struct dccg *dccg = dc->res_pool->dccg;
+
+	dce110_set_displaymarks(dc, context);
+
+	dccg->funcs->update_clocks(
+			dccg,
+			context,
+			true);
 }
 
 static void dce110_program_front_end_for_pipe(
@@ -2667,7 +2678,8 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.enable_display_power_gating = dce110_enable_display_power_gating,
 	.disable_plane = dce110_power_down_fe,
 	.pipe_control_lock = dce_pipe_control_lock,
-	.set_bandwidth = dce110_set_bandwidth,
+	.prepare_bandwidth = dce110_prepare_bandwidth,
+	.optimize_bandwidth = dce110_optimize_bandwidth,
 	.set_drr = set_drr,
 	.get_position = get_position,
 	.set_static_screen_control = set_static_screen_control,

commit 24f7dd7ea98dc54fa45a0dd10c7a472e00ca01d4
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Sep 13 17:42:14 2018 -0400

    drm/amd/display: move pplib/smu notification to dccg block
    
    This is done to clear up the clock programming sequence
    since the only time we need to notify pplib is after
    clock update.
    
    This also renames the clk block to dccg, at the moment
    this block contains both clock management and dccg
    functionality.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index b75ede5f84f7..0d25dcf6408a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1192,8 +1192,8 @@ static void build_audio_output(
 	if (pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT ||
 			pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {
 		audio_output->pll_info.dp_dto_source_clock_in_khz =
-				state->dis_clk->funcs->get_dp_ref_clk_frequency(
-						state->dis_clk);
+				state->dccg->funcs->get_dp_ref_clk_frequency(
+						state->dccg);
 	}
 
 	audio_output->pll_info.feed_back_divider =
@@ -1743,34 +1743,6 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
 			set_static_screen_control(pipe_ctx[i]->stream_res.tg, value);
 }
 
-/* unit: in_khz before mode set, get pixel clock from context. ASIC register
- * may not be programmed yet
- */
-static uint32_t get_max_pixel_clock_for_all_paths(
-	struct dc *dc,
-	struct dc_state *context)
-{
-	uint32_t max_pix_clk = 0;
-	int i;
-
-	for (i = 0; i < MAX_PIPES; i++) {
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-
-		if (pipe_ctx->stream == NULL)
-			continue;
-
-		/* do not check under lay */
-		if (pipe_ctx->top_pipe)
-			continue;
-
-		if (pipe_ctx->stream_res.pix_clk_params.requested_pix_clk > max_pix_clk)
-			max_pix_clk =
-				pipe_ctx->stream_res.pix_clk_params.requested_pix_clk;
-	}
-
-	return max_pix_clk;
-}
-
 /*
  *  Check if FBC can be enabled
  */
@@ -2380,191 +2352,22 @@ static void init_hw(struct dc *dc)
 
 }
 
-void dce110_fill_display_configs(
-	const struct dc_state *context,
-	struct dm_pp_display_configuration *pp_display_cfg)
-{
-	int j;
-	int num_cfgs = 0;
-
-	for (j = 0; j < context->stream_count; j++) {
-		int k;
-
-		const struct dc_stream_state *stream = context->streams[j];
-		struct dm_pp_single_disp_config *cfg =
-			&pp_display_cfg->disp_configs[num_cfgs];
-		const struct pipe_ctx *pipe_ctx = NULL;
-
-		for (k = 0; k < MAX_PIPES; k++)
-			if (stream == context->res_ctx.pipe_ctx[k].stream) {
-				pipe_ctx = &context->res_ctx.pipe_ctx[k];
-				break;
-			}
-
-		ASSERT(pipe_ctx != NULL);
-
-		/* only notify active stream */
-		if (stream->dpms_off)
-			continue;
-
-		num_cfgs++;
-		cfg->signal = pipe_ctx->stream->signal;
-		cfg->pipe_idx = pipe_ctx->stream_res.tg->inst;
-		cfg->src_height = stream->src.height;
-		cfg->src_width = stream->src.width;
-		cfg->ddi_channel_mapping =
-			stream->sink->link->ddi_channel_mapping.raw;
-		cfg->transmitter =
-			stream->sink->link->link_enc->transmitter;
-		cfg->link_settings.lane_count =
-			stream->sink->link->cur_link_settings.lane_count;
-		cfg->link_settings.link_rate =
-			stream->sink->link->cur_link_settings.link_rate;
-		cfg->link_settings.link_spread =
-			stream->sink->link->cur_link_settings.link_spread;
-		cfg->sym_clock = stream->phy_pix_clk;
-		/* Round v_refresh*/
-		cfg->v_refresh = stream->timing.pix_clk_khz * 1000;
-		cfg->v_refresh /= stream->timing.h_total;
-		cfg->v_refresh = (cfg->v_refresh + stream->timing.v_total / 2)
-							/ stream->timing.v_total;
-	}
-
-	pp_display_cfg->display_count = num_cfgs;
-}
-
-uint32_t dce110_get_min_vblank_time_us(const struct dc_state *context)
-{
-	uint8_t j;
-	uint32_t min_vertical_blank_time = -1;
-
-	for (j = 0; j < context->stream_count; j++) {
-		struct dc_stream_state *stream = context->streams[j];
-		uint32_t vertical_blank_in_pixels = 0;
-		uint32_t vertical_blank_time = 0;
-
-		vertical_blank_in_pixels = stream->timing.h_total *
-			(stream->timing.v_total
-			 - stream->timing.v_addressable);
-
-		vertical_blank_time = vertical_blank_in_pixels
-			* 1000 / stream->timing.pix_clk_khz;
-
-		if (min_vertical_blank_time > vertical_blank_time)
-			min_vertical_blank_time = vertical_blank_time;
-	}
-
-	return min_vertical_blank_time;
-}
-
-static int determine_sclk_from_bounding_box(
-		const struct dc *dc,
-		int required_sclk)
-{
-	int i;
-
-	/*
-	 * Some asics do not give us sclk levels, so we just report the actual
-	 * required sclk
-	 */
-	if (dc->sclk_lvls.num_levels == 0)
-		return required_sclk;
-
-	for (i = 0; i < dc->sclk_lvls.num_levels; i++) {
-		if (dc->sclk_lvls.clocks_in_khz[i] >= required_sclk)
-			return dc->sclk_lvls.clocks_in_khz[i];
-	}
-	/*
-	 * even maximum level could not satisfy requirement, this
-	 * is unexpected at this stage, should have been caught at
-	 * validation time
-	 */
-	ASSERT(0);
-	return dc->sclk_lvls.clocks_in_khz[dc->sclk_lvls.num_levels - 1];
-}
-
-static void pplib_apply_display_requirements(
-	struct dc *dc,
-	struct dc_state *context)
-{
-	struct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;
-
-	pp_display_cfg->all_displays_in_sync =
-		context->bw.dce.all_displays_in_sync;
-	pp_display_cfg->nb_pstate_switch_disable =
-			context->bw.dce.nbp_state_change_enable == false;
-	pp_display_cfg->cpu_cc6_disable =
-			context->bw.dce.cpuc_state_change_enable == false;
-	pp_display_cfg->cpu_pstate_disable =
-			context->bw.dce.cpup_state_change_enable == false;
-	pp_display_cfg->cpu_pstate_separation_time =
-			context->bw.dce.blackout_recovery_time_us;
-
-	pp_display_cfg->min_memory_clock_khz = context->bw.dce.yclk_khz
-		/ MEMORY_TYPE_MULTIPLIER;
-
-	pp_display_cfg->min_engine_clock_khz = determine_sclk_from_bounding_box(
-			dc,
-			context->bw.dce.sclk_khz);
-
-	pp_display_cfg->min_engine_clock_deep_sleep_khz
-			= context->bw.dce.sclk_deep_sleep_khz;
-
-	pp_display_cfg->avail_mclk_switch_time_us =
-						dce110_get_min_vblank_time_us(context);
-	/* TODO: dce11.2*/
-	pp_display_cfg->avail_mclk_switch_time_in_disp_active_us = 0;
-
-	pp_display_cfg->disp_clk_khz = dc->res_pool->dccg->clks.dispclk_khz;
-
-	dce110_fill_display_configs(context, pp_display_cfg);
-
-	/* TODO: is this still applicable?*/
-	if (pp_display_cfg->display_count == 1) {
-		const struct dc_crtc_timing *timing =
-			&context->streams[0]->timing;
-
-		pp_display_cfg->crtc_index =
-			pp_display_cfg->disp_configs[0].pipe_idx;
-		pp_display_cfg->line_time_in_us = timing->h_total * 1000
-							/ timing->pix_clk_khz;
-	}
-
-	if (memcmp(&dc->prev_display_config, pp_display_cfg, sizeof(
-			struct dm_pp_display_configuration)) !=  0)
-		dm_pp_apply_display_requirements(dc->ctx, pp_display_cfg);
-
-	dc->prev_display_config = *pp_display_cfg;
-}
-
-static void dce110_set_bandwidth(
+void dce110_set_bandwidth(
 		struct dc *dc,
 		struct dc_state *context,
 		bool decrease_allowed)
 {
-	struct dc_clocks req_clks;
 	struct dccg *dccg = dc->res_pool->dccg;
 
-	req_clks.dispclk_khz = context->bw.dce.dispclk_khz;
-	req_clks.phyclk_khz = get_max_pixel_clock_for_all_paths(dc, context);
-
 	if (decrease_allowed)
 		dce110_set_displaymarks(dc, context);
 	else
 		dce110_set_safe_displaymarks(&context->res_ctx, dc->res_pool);
 
-	if (dccg->funcs->update_dfs_bypass)
-		dccg->funcs->update_dfs_bypass(
-			dccg,
-			dc,
-			context,
-			req_clks.dispclk_khz);
-
 	dccg->funcs->update_clocks(
 			dccg,
-			&req_clks,
+			context,
 			decrease_allowed);
-	pplib_apply_display_requirements(dc, context);
 }
 
 static void dce110_program_front_end_for_pipe(
@@ -2839,10 +2642,6 @@ void dce110_set_cursor_attribute(struct pipe_ctx *pipe_ctx)
 				pipe_ctx->plane_res.xfm, attributes);
 }
 
-static void ready_shared_resources(struct dc *dc, struct dc_state *context) {}
-
-static void optimize_shared_resources(struct dc *dc) {}
-
 static const struct hw_sequencer_funcs dce110_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.program_csc_matrix = program_csc_matrix,
@@ -2877,9 +2676,6 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.setup_stereo = NULL,
 	.set_avmute = dce110_set_avmute,
 	.wait_for_mpcc_disconnect = dce110_wait_for_mpcc_disconnect,
-	.ready_shared_resources = ready_shared_resources,
-	.optimize_shared_resources = optimize_shared_resources,
-	.pplib_apply_display_requirements = pplib_apply_display_requirements,
 	.edp_backlight_control = hwss_edp_backlight_control,
 	.edp_power_control = hwss_edp_power_control,
 	.edp_wait_for_hpd_ready = hwss_edp_wait_for_hpd_ready,

commit 6004f172b375f5747e89afc62ad3baaf1bebd58a
Merge: 612c6bd5e3f8 17b57b1883c1
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Oct 4 11:03:34 2018 +1000

    BackMerge v4.19-rc6 into drm-next
    
    I have some pulls based on rc6, and I prefer to have an explicit backmerge.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit 599760d6d0abbab71f9726b49858d2ec45e74c0a
Author: Roman Li <Roman.Li@amd.com>
Date:   Wed Sep 26 13:42:16 2018 -0400

    drm/amd/display: Fix Vega10 lightup on S3 resume
    
    [Why]
    There have been a few reports of Vega10 display remaining blank
    after S3 resume. The regression is caused by workaround for mode
    change on Vega10 - skip set_bandwidth if stream count is 0.
    As a result we skipped dispclk reset on suspend, thus on resume
    we may skip the clock update assuming it hasn't been changed.
    On some systems it causes display blank or 'out of range'.
    
    [How]
    Revert "drm/amd/display: Fix Vega10 black screen after mode change"
    Verified that it hadn't cause mode change regression.
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Sun peng Li <Sunpeng.Li@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 14384d9675a8..b2f308766a9e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2560,7 +2560,7 @@ static void pplib_apply_display_requirements(
 	dc->prev_display_config = *pp_display_cfg;
 }
 
-void dce110_set_bandwidth(
+static void dce110_set_bandwidth(
 		struct dc *dc,
 		struct dc_state *context,
 		bool decrease_allowed)

commit aa9c4abe466ac7cd4ab8e1d81b959c3d51173745
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Thu Aug 16 14:27:11 2018 -0400

    drm/amd/display: Refactor FPGA-specific link setup
    
    FPGA doesn't program backend, so we don't need certain link settings
    (audio stream for example).
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index dc1eed5ba996..6b7cccc486d8 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1377,26 +1377,13 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	/*  */
 	dc->hwss.enable_stream_timing(pipe_ctx, context, dc);
 
-	/* FPGA does not program backend */
-	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
-		pipe_ctx->stream_res.opp->funcs->opp_set_dyn_expansion(
-		pipe_ctx->stream_res.opp,
-		COLOR_SPACE_YCBCR601,
-		stream->timing.display_color_depth,
-		pipe_ctx->stream->signal);
-
-		pipe_ctx->stream_res.opp->funcs->opp_program_fmt(
-			pipe_ctx->stream_res.opp,
-			&stream->bit_depth_params,
-			&stream->clamping);
-		return DC_OK;
-	}
 	/* TODO: move to stream encoder */
 	if (pipe_ctx->stream->signal != SIGNAL_TYPE_VIRTUAL)
 		if (DC_OK != bios_parser_crtc_source_select(pipe_ctx)) {
 			BREAK_TO_DEBUGGER();
 			return DC_ERROR_UNEXPECTED;
 		}
+
 	pipe_ctx->stream_res.opp->funcs->opp_set_dyn_expansion(
 			pipe_ctx->stream_res.opp,
 			COLOR_SPACE_YCBCR601,

commit d82f99422b21c0e9d174be453d0a5062da40568e
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Aug 21 14:28:05 2018 -0500

    drm/amd/display: move edp fast boot optimization flag to stream
    
    [Why]
    During S4/S3 stress test it is possible to resume from S4 without
    calling mode set on eDP, meaning high level optimization flag is not
    reset. If this is followed by an S3 resume call, driver will see
    optimization flag is set and consume it and think backend is powered
    on when in fact it is not.
    
    This results in PHY being off in sequence where
    S4->Resume->S3->Resume->ApplyOpt->black screen.
    
    [How]
    Move optimization flag to stream instead of a DC flag.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index ce1e0f6ec3ca..dc1eed5ba996 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1557,32 +1557,40 @@ static struct dc_link *get_link_for_edp_not_in_use(
  */
 void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 {
+	int i;
 	struct dc_link *edp_link_to_turnoff = NULL;
 	struct dc_link *edp_link = get_link_for_edp(dc);
-	bool can_eDP_fast_boot_optimize = false;
+	bool can_edp_fast_boot_optimize = false;
+	bool apply_edp_fast_boot_optimization = false;
 
 	if (edp_link) {
 		/* this seems to cause blank screens on DCE8 */
 		if ((dc->ctx->dce_version == DCE_VERSION_8_0) ||
 		    (dc->ctx->dce_version == DCE_VERSION_8_1) ||
 		    (dc->ctx->dce_version == DCE_VERSION_8_3))
-			can_eDP_fast_boot_optimize = false;
+			can_edp_fast_boot_optimize = false;
 		else
-			can_eDP_fast_boot_optimize =
+			can_edp_fast_boot_optimize =
 				edp_link->link_enc->funcs->is_dig_enabled(edp_link->link_enc);
 	}
 
-	if (can_eDP_fast_boot_optimize) {
+	if (can_edp_fast_boot_optimize)
 		edp_link_to_turnoff = get_link_for_edp_not_in_use(dc, context);
 
-		/* if OS doesn't light up eDP and eDP link is available, we want to disable
-		 * If resume from S4/S5, should optimization.
-		 */
-		if (!edp_link_to_turnoff)
-			dc->apply_edp_fast_boot_optimization = true;
+	/* if OS doesn't light up eDP and eDP link is available, we want to disable
+	 * If resume from S4/S5, should optimization.
+	 */
+	if (can_edp_fast_boot_optimize && !edp_link_to_turnoff) {
+		/* Find eDP stream and set optimization flag */
+		for (i = 0; i < context->stream_count; i++) {
+			if (context->streams[i]->signal == SIGNAL_TYPE_EDP) {
+				context->streams[i]->apply_edp_fast_boot_optimization = true;
+				apply_edp_fast_boot_optimization = true;
+			}
+		}
 	}
 
-	if (!dc->apply_edp_fast_boot_optimization) {
+	if (!apply_edp_fast_boot_optimization) {
 		if (edp_link_to_turnoff) {
 			/*turn off backlight before DP_blank and encoder powered down*/
 			dc->hwss.edp_backlight_control(edp_link_to_turnoff, false);

commit 1e7e86c43f38d2cc0183ae2a440c70f3c6163883
Author: Samson Tam <Samson.Tam@amd.com>
Date:   Tue May 1 10:39:26 2018 -0400

    drm/amd/display: decouple front and backend pgm using dpms_off as backend enable flag
    
    Signed-off-by: Samson Tam <Samson.Tam@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index ae4792494fe7..ce1e0f6ec3ca 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1349,8 +1349,6 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		struct dc *dc)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
-	struct pipe_ctx *pipe_ctx_old = &dc->current_state->res_ctx.
-			pipe_ctx[pipe_ctx->pipe_idx];
 
 	if (pipe_ctx->stream_res.audio != NULL) {
 		struct audio_output audio_output;
@@ -1405,46 +1403,12 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 			stream->timing.display_color_depth,
 			pipe_ctx->stream->signal);
 
-	if (pipe_ctx->stream->signal != SIGNAL_TYPE_VIRTUAL)
-		stream->sink->link->link_enc->funcs->setup(
-			stream->sink->link->link_enc,
-			pipe_ctx->stream->signal);
-
-	if (pipe_ctx->stream->signal != SIGNAL_TYPE_VIRTUAL)
-		pipe_ctx->stream_res.stream_enc->funcs->setup_stereo_sync(
-		pipe_ctx->stream_res.stream_enc,
-		pipe_ctx->stream_res.tg->inst,
-		stream->timing.timing_3d_format != TIMING_3D_FORMAT_NONE);
-
-
 	pipe_ctx->stream_res.opp->funcs->opp_program_fmt(
 		pipe_ctx->stream_res.opp,
 		&stream->bit_depth_params,
 		&stream->clamping);
 
-	if (dc_is_dp_signal(pipe_ctx->stream->signal))
-		pipe_ctx->stream_res.stream_enc->funcs->dp_set_stream_attribute(
-			pipe_ctx->stream_res.stream_enc,
-			&stream->timing,
-			stream->output_color_space);
-
-	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
-		pipe_ctx->stream_res.stream_enc->funcs->hdmi_set_stream_attribute(
-			pipe_ctx->stream_res.stream_enc,
-			&stream->timing,
-			stream->phy_pix_clk,
-			pipe_ctx->stream_res.audio != NULL);
-
-	if (dc_is_dvi_signal(pipe_ctx->stream->signal))
-		pipe_ctx->stream_res.stream_enc->funcs->dvi_set_stream_attribute(
-			pipe_ctx->stream_res.stream_enc,
-			&stream->timing,
-			(pipe_ctx->stream->signal == SIGNAL_TYPE_DVI_DUAL_LINK) ?
-			true : false);
-
-	resource_build_info_frame(pipe_ctx);
-	dce110_update_info_frame(pipe_ctx);
-	if (!pipe_ctx_old->stream)
+	if (!stream->dpms_off)
 		core_link_enable_stream(context, pipe_ctx);
 
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;

commit 98e6436d3af5fef7ca9b59d865dd5807ede36fb9
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Aug 21 14:40:28 2018 -0500

    drm/amd/display: Refactor FreeSync module
    
    Remove dependency on internal sink map and instead
    use existing stream and plane state
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 2f2c5155c5aa..ae4792494fe7 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1286,6 +1286,8 @@ static enum dc_status dce110_enable_stream_timing(
 	struct pipe_ctx *pipe_ctx_old = &dc->current_state->res_ctx.
 			pipe_ctx[pipe_ctx->pipe_idx];
 	struct tg_color black_color = {0};
+	struct drr_params params = {0};
+	unsigned int event_triggers = 0;
 
 	if (!pipe_ctx_old->stream) {
 
@@ -1315,9 +1317,19 @@ static enum dc_status dce110_enable_stream_timing(
 				&stream->timing,
 				true);
 
-		pipe_ctx->stream_res.tg->funcs->set_static_screen_control(
-				pipe_ctx->stream_res.tg,
-				0x182);
+		params.vertical_total_min = stream->adjust.v_total_min;
+		params.vertical_total_max = stream->adjust.v_total_max;
+		if (pipe_ctx->stream_res.tg->funcs->set_drr)
+			pipe_ctx->stream_res.tg->funcs->set_drr(
+				pipe_ctx->stream_res.tg, &params);
+
+		// DRR should set trigger event to monitor surface update event
+		if (stream->adjust.v_total_min != 0 &&
+				stream->adjust.v_total_max != 0)
+			event_triggers = 0x80;
+		if (pipe_ctx->stream_res.tg->funcs->set_static_screen_control)
+			pipe_ctx->stream_res.tg->funcs->set_static_screen_control(
+				pipe_ctx->stream_res.tg, event_triggers);
 	}
 
 	if (!pipe_ctx_old->stream) {
@@ -1328,8 +1340,6 @@ static enum dc_status dce110_enable_stream_timing(
 		}
 	}
 
-
-
 	return DC_OK;
 }
 
@@ -1719,16 +1729,24 @@ static void set_drr(struct pipe_ctx **pipe_ctx,
 {
 	int i = 0;
 	struct drr_params params = {0};
+	// DRR should set trigger event to monitor surface update event
+	unsigned int event_triggers = 0x80;
 
 	params.vertical_total_max = vmax;
 	params.vertical_total_min = vmin;
 
 	/* TODO: If multiple pipes are to be supported, you need
-	 * some GSL stuff
+	 * some GSL stuff. Static screen triggers may be programmed differently
+	 * as well.
 	 */
-
 	for (i = 0; i < num_pipes; i++) {
-		pipe_ctx[i]->stream_res.tg->funcs->set_drr(pipe_ctx[i]->stream_res.tg, &params);
+		pipe_ctx[i]->stream_res.tg->funcs->set_drr(
+			pipe_ctx[i]->stream_res.tg, &params);
+
+		if (vmax != 0 && vmin != 0)
+			pipe_ctx[i]->stream_res.tg->funcs->set_static_screen_control(
+					pipe_ctx[i]->stream_res.tg,
+					event_triggers);
 	}
 }
 

commit 5a83c93249098df2ee3b0039ec8f4495b959fcd0
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue Aug 21 14:36:49 2018 -0500

    drm/amd/display: Add support for toggling DFS bypass
    
    [Why]
    
    If the hardware supports DFS bypass it will always be enabled after
    creation of the DCCG. DFS bypass should only be enabled when
    the current stream consists of a single embedded panel and the
    minimum display clock is below the DFS bypass threshold.
    
    [How]
    
    Add a function to the DCCG table that updates the DFS bypass state
    when setting the bandwidth. If the DFS bypass state is changed, the
    clock needs to be reprogrammed to reflect this before the DPREFCLK
    is updated for audio endpoints. The existing display clock value
    is used as the target display clock value when reprogramming since the
    resulting change will be equal or larger to the current value.
    
    These changes only specifically target dce110 but do offer a framework
    for support on other applicable targets.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: David Francis <David.Francis@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 14384d9675a8..2f2c5155c5aa 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2566,6 +2566,7 @@ void dce110_set_bandwidth(
 		bool decrease_allowed)
 {
 	struct dc_clocks req_clks;
+	struct dccg *dccg = dc->res_pool->dccg;
 
 	req_clks.dispclk_khz = context->bw.dce.dispclk_khz;
 	req_clks.phyclk_khz = get_max_pixel_clock_for_all_paths(dc, context);
@@ -2575,8 +2576,15 @@ void dce110_set_bandwidth(
 	else
 		dce110_set_safe_displaymarks(&context->res_ctx, dc->res_pool);
 
-	dc->res_pool->dccg->funcs->update_clocks(
-			dc->res_pool->dccg,
+	if (dccg->funcs->update_dfs_bypass)
+		dccg->funcs->update_dfs_bypass(
+			dccg,
+			dc,
+			context,
+			req_clks.dispclk_khz);
+
+	dccg->funcs->update_clocks(
+			dccg,
 			&req_clks,
 			decrease_allowed);
 	pplib_apply_display_requirements(dc, context);

commit dc37a9a08d5760e405ffdd94ec6bbb6efededba6
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Thu Aug 16 15:44:38 2018 -0400

    Revert "drm/amdgpu/display: Replace CONFIG_DRM_AMD_DC_DCN1_0 with CONFIG_X86"
    
    This reverts commit 8624c3c4dbfe24fc6740687236a2e196f5f4bfb0.
    
    We need CONFIG_DRM_AMD_DC_DCN1_0 to guard code that is using fp math.
    
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Michel Dnzer <michel.daenzer@amd.com>
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 215409eb9495..14384d9675a8 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1250,7 +1250,7 @@ static void program_scaler(const struct dc *dc,
 {
 	struct tg_color color = {0};
 
-#ifdef CONFIG_X86
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	/* TOFPGA */
 	if (pipe_ctx->plane_res.xfm->funcs->transform_set_pixel_storage_depth == NULL)
 		return;

commit 95f05a3a2e6895ecfd8b4f64b5d6c6cf0b6a3f4a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Aug 16 15:35:21 2018 -0500

    drm/amdgpu/display: disable eDP fast boot optimization on DCE8
    
    Seems to cause blank screens.
    
    Bug: https://bugs.freedesktop.org/show_bug.cgi?id=106940
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 5450d4d38e8a..215409eb9495 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1588,7 +1588,13 @@ void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 	bool can_eDP_fast_boot_optimize = false;
 
 	if (edp_link) {
-		can_eDP_fast_boot_optimize =
+		/* this seems to cause blank screens on DCE8 */
+		if ((dc->ctx->dce_version == DCE_VERSION_8_0) ||
+		    (dc->ctx->dce_version == DCE_VERSION_8_1) ||
+		    (dc->ctx->dce_version == DCE_VERSION_8_3))
+			can_eDP_fast_boot_optimize = false;
+		else
+			can_eDP_fast_boot_optimize =
 				edp_link->link_enc->funcs->is_dig_enabled(edp_link->link_enc);
 	}
 

commit ad8960a6cb06c446d0a391ce095f6f28edf36aff
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Thu Aug 2 09:45:09 2018 -0400

    drm/amd/display: Check if clock source in use before disabling
    
    [why]
    We are disabling clock source while other pipes are still using
    it, because we don't verify the number of pipes that share it.
    
    [how]
    - Adding a function in resources to return the number of pipes
    sharing the clock source.
    - Checking that no one is sharing the clock source before disabling
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 1d98e3678b04..5450d4d38e8a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1908,7 +1908,9 @@ static void dce110_reset_hw_ctx_wrap(
 			pipe_ctx_old->plane_res.mi->funcs->free_mem_input(
 					pipe_ctx_old->plane_res.mi, dc->current_state->stream_count);
 
-			if (old_clk)
+			if (old_clk && 0 == resource_get_clock_source_reference(&context->res_ctx,
+										dc->res_pool,
+										old_clk))
 				old_clk->funcs->cs_power_down(old_clk);
 
 			dc->hwss.disable_plane(dc, pipe_ctx_old);

commit 5ae6fe572929587a304471bf4a641361a45152b5
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Mon Jul 23 14:13:23 2018 -0400

    drm/amd/display: Use calculated disp_clk_khz value for dce110
    
    [Why]
    
    The calculated values for actual disp_clk_khz were ignored when
    notifying pplib of the new display requirements. In order to honor DFS
    bypass clocks from the hardware, the calculated value should be used.
    
    [How]
    
    The return value for set_dispclk is now assigned back into new_clocks
    and correctly carried through into dccg->clks.phyclk_khz. When notifying
    pplib of new display requirements dccg->clks.phyclk_khz is used
    instead of dce.dispclk_khz. The value of dce.dispclk_khz was never
    explicitly set to anything before.
    
    A 15% higher display clock value than calculated is no longer requested
    for dce110 since it now makes use of the calculated value.
    
    Since dce112 makes use of dce110's set_bandwidth but not its
    update_clocks it needs to have the value correctly carried through.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 1149c413f6d2..1d98e3678b04 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2530,7 +2530,7 @@ static void pplib_apply_display_requirements(
 	/* TODO: dce11.2*/
 	pp_display_cfg->avail_mclk_switch_time_in_disp_active_us = 0;
 
-	pp_display_cfg->disp_clk_khz = context->bw.dce.dispclk_khz;
+	pp_display_cfg->disp_clk_khz = dc->res_pool->dccg->clks.dispclk_khz;
 
 	dce110_fill_display_configs(context, pp_display_cfg);
 
@@ -2559,7 +2559,7 @@ void dce110_set_bandwidth(
 {
 	struct dc_clocks req_clks;
 
-	req_clks.dispclk_khz = context->bw.dce.dispclk_khz * 115 / 100;
+	req_clks.dispclk_khz = context->bw.dce.dispclk_khz;
 	req_clks.phyclk_khz = get_max_pixel_clock_for_all_paths(dc, context);
 
 	if (decrease_allowed)

commit f358b39d187500717b4bc8633cef45d87eff0a3e
Author: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
Date:   Tue Jul 17 11:53:54 2018 -0400

    drm/amd/display: Fix Vega10 black screen after mode change
    
    [Why]
    The sequence is slightly changed when bring .set_bandwidth out
    from the end of programming backend to the end of programming
    surface. Vega10 doesn't like to get clocks updated if
    stream_count is zero in the current context (Atomic Reset).
    
    [How]
    Do not update clocks if no stream is showing up in the context.
    
    Fixes 1b2b130192 "dc: Remove 300Mhz minimum disp clk limit."
    
    Signed-off-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 33a14e163f88..1149c413f6d2 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2552,7 +2552,7 @@ static void pplib_apply_display_requirements(
 	dc->prev_display_config = *pp_display_cfg;
 }
 
-static void dce110_set_bandwidth(
+void dce110_set_bandwidth(
 		struct dc *dc,
 		struct dc_state *context,
 		bool decrease_allowed)

commit 4841203102a337b4b627e6dd3a1dc8c88aec982b
Author: Michel Dnzer <michel.daenzer@amd.com>
Date:   Tue Jul 17 12:37:45 2018 +0200

    drm/amdgpu/display: Replace CONFIG_DRM_AMD_DC_DCN1_0 with CONFIG_X86
    
    Allowing CONFIG_DRM_AMD_DC_DCN1_0 to be disabled on X86 was an
    opportunity for display with Raven Ridge accidentally not working.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Michel Dnzer <michel.daenzer@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 45388bff2c7d..33a14e163f88 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1250,7 +1250,7 @@ static void program_scaler(const struct dc *dc,
 {
 	struct tg_color color = {0};
 
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+#ifdef CONFIG_X86
 	/* TOFPGA */
 	if (pipe_ctx->plane_res.xfm->funcs->transform_set_pixel_storage_depth == NULL)
 		return;

commit bf53769d9fc95c89d2f1588463c268c3af987748
Author: Gloria Li <geling.li@amd.com>
Date:   Tue Jul 3 14:39:22 2018 -0400

    drm/amd/display: add HDR visual confirm
    
    [Why]
    Testing team wants a way to tell if HDR is on or not
    
    [How]
    Program the overscan color to visually indicate the HDR state of the top-most plane
    
    Signed-off-by: Gloria Li <geling.li@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e48eb3056af5..45388bff2c7d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1256,7 +1256,7 @@ static void program_scaler(const struct dc *dc,
 		return;
 #endif
 
-	if (dc->debug.surface_visual_confirm)
+	if (dc->debug.visual_confirm == VISUAL_CONFIRM_SURFACE)
 		get_surface_visual_confirm_color(pipe_ctx, &color);
 	else
 		color_space_to_black_color(dc,

commit 6c4fff068f7940993b3ec74a9996f4b514089d1a
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Wed Jun 27 13:49:20 2018 -0400

    drm/amd/display: Add NULL check for local sink in edp_power_control
    
    [WHY]
    PNP cause bsod regression fix
    
    [HOW]
    Add NULL check
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Hugo Hu <Hugo.Hu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 109d4103d10d..e48eb3056af5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -871,9 +871,11 @@ void hwss_edp_power_control(
 			unsigned long long wait_time_ms = 0;
 
 			/* max 500ms from LCDVDD off to on */
-			unsigned long long edp_poweroff_time_ms =
-					500 + link->local_sink->edid_caps.panel_patch.extra_t12_ms;
+			unsigned long long edp_poweroff_time_ms = 500;
 
+			if (link->local_sink != NULL)
+				edp_poweroff_time_ms =
+						500 + link->local_sink->edid_caps.panel_patch.extra_t12_ms;
 			if (link->link_trace.time_stamp.edp_poweroff == 0)
 				wait_time_ms = edp_poweroff_time_ms;
 			else if (duration_in_ms < edp_poweroff_time_ms)

commit 08ed681c8453c2934136bcc3b30bca4dee8a5fca
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Jun 21 13:33:41 2018 -0400

    drm/amd/display: add dcn cursor hotsport rotation and mirror support
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 7227cfddb352..109d4103d10d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2807,7 +2807,8 @@ void dce110_set_cursor_position(struct pipe_ctx *pipe_ctx)
 		.viewport = pipe_ctx->plane_res.scl_data.viewport,
 		.h_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.horz,
 		.v_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.vert,
-		.rotation = pipe_ctx->plane_state->rotation
+		.rotation = pipe_ctx->plane_state->rotation,
+		.mirror = pipe_ctx->plane_state->horizontal_mirror
 	};
 
 	if (pipe_ctx->plane_state->address.type

commit ff58798725ba9c747cd934e2623f7a0610b3f0dd
Author: Hugo Hu <hugo.hu@amd.com>
Date:   Fri Jun 15 15:49:55 2018 -0400

    drm/amd/display: Patch for extend time to panel poweron.
    
    [WHY]
    In eDP spec, the min duration in LCDVDD on-off-on sequence should be
    500ms, some BOE panels need 700ms to pass.
    [HOW]
    Add patch to wait more time when eDP power on.
    
    Signed-off-by: Hugo Hu <hugo.hu@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 5b41cbe06f59..7227cfddb352 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -871,10 +871,13 @@ void hwss_edp_power_control(
 			unsigned long long wait_time_ms = 0;
 
 			/* max 500ms from LCDVDD off to on */
+			unsigned long long edp_poweroff_time_ms =
+					500 + link->local_sink->edid_caps.panel_patch.extra_t12_ms;
+
 			if (link->link_trace.time_stamp.edp_poweroff == 0)
-				wait_time_ms = 500;
-			else if (duration_in_ms < 500)
-				wait_time_ms = 500 - duration_in_ms;
+				wait_time_ms = edp_poweroff_time_ms;
+			else if (duration_in_ms < edp_poweroff_time_ms)
+				wait_time_ms = edp_poweroff_time_ms - duration_in_ms;
 
 			if (wait_time_ms) {
 				msleep(wait_time_ms);

commit 39a9f4d89e123b62c8a5cc26696ea8afa98e0e88
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Jun 19 15:49:02 2018 -0400

    drm/amd/display: add additional info for cursor position programming
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index bf4df34bc1df..5b41cbe06f59 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2801,9 +2801,10 @@ void dce110_set_cursor_position(struct pipe_ctx *pipe_ctx)
 	struct dc_cursor_mi_param param = {
 		.pixel_clk_khz = pipe_ctx->stream->timing.pix_clk_khz,
 		.ref_clk_khz = pipe_ctx->stream->ctx->dc->res_pool->ref_clock_inKhz,
-		.viewport_x_start = pipe_ctx->plane_res.scl_data.viewport.x,
-		.viewport_width = pipe_ctx->plane_res.scl_data.viewport.width,
-		.h_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.horz
+		.viewport = pipe_ctx->plane_res.scl_data.viewport,
+		.h_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.horz,
+		.v_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.vert,
+		.rotation = pipe_ctx->plane_state->rotation
 	};
 
 	if (pipe_ctx->plane_state->address.type

commit 93ed1814c668fb13f3b23b629528e90a2b0d5ea3
Author: Hugo Hu <hugo.hu@amd.com>
Date:   Mon Jun 18 15:27:58 2018 -0400

    drm/amd/display: Correct calculation of duration time.
    
    Signed-off-by: Hugo Hu <hugo.hu@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 9cbd5036db07..bf4df34bc1df 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -864,10 +864,10 @@ void hwss_edp_power_control(
 		if (power_up) {
 			unsigned long long current_ts = dm_get_timestamp(ctx);
 			unsigned long long duration_in_ms =
-					dm_get_elapse_time_in_ns(
+					div64_u64(dm_get_elapse_time_in_ns(
 							ctx,
 							current_ts,
-							div64_u64(link->link_trace.time_stamp.edp_poweroff, 1000000));
+							link->link_trace.time_stamp.edp_poweroff), 1000000);
 			unsigned long long wait_time_ms = 0;
 
 			/* max 500ms from LCDVDD off to on */

commit 7f93c1de64693dc18afe55559f14cee6b5403c6c
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Sat Jun 9 19:33:14 2018 -0400

    drm/amd/display: add valid regoffset and NULL pointer check
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 3b983b3f3423..9cbd5036db07 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1475,7 +1475,7 @@ static void power_down_controllers(struct dc *dc)
 {
 	int i;
 
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+	for (i = 0; i < dc->res_pool->timing_generator_count; i++) {
 		dc->res_pool->timing_generators[i]->funcs->disable_crtc(
 				dc->res_pool->timing_generators[i]);
 	}
@@ -1515,12 +1515,13 @@ static void disable_vga_and_power_gate_all_controllers(
 	struct timing_generator *tg;
 	struct dc_context *ctx = dc->ctx;
 
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+	for (i = 0; i < dc->res_pool->timing_generator_count; i++) {
 		tg = dc->res_pool->timing_generators[i];
 
 		if (tg->funcs->disable_vga)
 			tg->funcs->disable_vga(tg);
-
+	}
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		/* Enable CLOCK gating for each pipe BEFORE controller
 		 * powergating. */
 		enable_display_pipe_clock_gating(ctx,

commit c910a717dac6540a636a57c1a34261c6d84fc0eb
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 23 18:39:21 2018 -0400

    drm/amd/display: clean up set_bandwidth usage
    
    This removes redundant set_bandwidth calls as well
    as fixes a bug in post_set_address_update where dcn1
    would never get to lower clocks.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 4cdf86690d19..3b983b3f3423 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2036,8 +2036,6 @@ enum dc_status dce110_apply_ctx_to_hw(
 	if (dc->fbc_compressor)
 		dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);
 
-	dc->hwss.set_bandwidth(dc, context, false);
-
 	dce110_setup_audio_dto(dc, context);
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
@@ -2066,9 +2064,6 @@ enum dc_status dce110_apply_ctx_to_hw(
 			return status;
 	}
 
-	/* to save power */
-	dc->hwss.set_bandwidth(dc, context, true);
-
 	dcb->funcs->set_scratch_critical_state(dcb, false);
 
 	if (dc->fbc_compressor)

commit 2dfa76d328630de3dd4fc09b296ee9771ba13e39
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon May 28 18:09:52 2018 -0400

    drm/amd/display: remove invalid assert when no max_pixel_clk is found
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 34eb7a33851b..4cdf86690d19 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1779,9 +1779,6 @@ static uint32_t get_max_pixel_clock_for_all_paths(
 				pipe_ctx->stream_res.pix_clk_params.requested_pix_clk;
 	}
 
-	if (max_pix_clk == 0)
-		ASSERT(0);
-
 	return max_pix_clk;
 }
 

commit 6ca11246180a6e5e6b5b668545c2575b304c9f7f
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 23 16:44:26 2018 -0400

    drm/amd/display: rename display clock block to dccg
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 02aa0a2ec875..34eb7a33851b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2569,8 +2569,8 @@ static void dce110_set_bandwidth(
 	else
 		dce110_set_safe_displaymarks(&context->res_ctx, dc->res_pool);
 
-	dc->res_pool->display_clock->funcs->update_clocks(
-			dc->res_pool->display_clock,
+	dc->res_pool->dccg->funcs->update_clocks(
+			dc->res_pool->dccg,
 			&req_clks,
 			decrease_allowed);
 	pplib_apply_display_requirements(dc, context);

commit fab55d61b9f04693abc6fdbc92e3fdf3872915b1
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 23 16:21:54 2018 -0400

    drm/amd/display: redesign dce/dcn clock voltage update request
    
    The goal of this change is to move clock programming and voltage
    requests to a single function. As of this change only dce is affected.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index ddc8ffda9067..02aa0a2ec875 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1663,7 +1663,7 @@ static void dce110_set_displaymarks(
 	}
 }
 
-static void set_safe_displaymarks(
+void dce110_set_safe_displaymarks(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool)
 {
@@ -1755,23 +1755,15 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
 }
 
 /* unit: in_khz before mode set, get pixel clock from context. ASIC register
- * may not be programmed yet.
- * TODO: after mode set, pre_mode_set = false,
- * may read PLL register to get pixel clock
+ * may not be programmed yet
  */
 static uint32_t get_max_pixel_clock_for_all_paths(
 	struct dc *dc,
-	struct dc_state *context,
-	bool pre_mode_set)
+	struct dc_state *context)
 {
 	uint32_t max_pix_clk = 0;
 	int i;
 
-	if (!pre_mode_set) {
-		/* TODO: read ASIC register to get pixel clock */
-		ASSERT(0);
-	}
-
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
@@ -1793,74 +1785,6 @@ static uint32_t get_max_pixel_clock_for_all_paths(
 	return max_pix_clk;
 }
 
-/*
- * Find clock state based on clock requested. if clock value is 0, simply
- * set clock state as requested without finding clock state by clock value
- */
-
-static void apply_min_clocks(
-	struct dc *dc,
-	struct dc_state *context,
-	enum dm_pp_clocks_state *clocks_state,
-	bool pre_mode_set)
-{
-	struct state_dependent_clocks req_clocks = {0};
-
-	if (!pre_mode_set) {
-		/* set clock_state without verification */
-		if (context->dis_clk->funcs->set_min_clocks_state) {
-			context->dis_clk->funcs->set_min_clocks_state(
-						context->dis_clk, *clocks_state);
-			return;
-		}
-
-		/* TODO: This is incorrect. Figure out how to fix. */
-		context->dis_clk->funcs->apply_clock_voltage_request(
-				context->dis_clk,
-				DM_PP_CLOCK_TYPE_DISPLAY_CLK,
-				context->dis_clk->clks.dispclk_khz,
-				pre_mode_set,
-				false);
-
-		context->dis_clk->funcs->apply_clock_voltage_request(
-				context->dis_clk,
-				DM_PP_CLOCK_TYPE_DISPLAYPHYCLK,
-				context->dis_clk->clks.phyclk_khz,
-				pre_mode_set,
-				false);
-		return;
-	}
-
-	/* get the required state based on state dependent clocks:
-	 * display clock and pixel clock
-	 */
-	req_clocks.display_clk_khz = context->bw.dce.dispclk_khz;
-
-	req_clocks.pixel_clk_khz = get_max_pixel_clock_for_all_paths(
-			dc, context, true);
-
-	if (context->dis_clk->funcs->get_required_clocks_state) {
-		*clocks_state = context->dis_clk->funcs->get_required_clocks_state(
-				context->dis_clk, &req_clocks);
-		context->dis_clk->funcs->set_min_clocks_state(
-			context->dis_clk, *clocks_state);
-	} else {
-		context->dis_clk->funcs->apply_clock_voltage_request(
-				context->dis_clk,
-				DM_PP_CLOCK_TYPE_DISPLAY_CLK,
-				req_clocks.display_clk_khz,
-				pre_mode_set,
-				false);
-
-		context->dis_clk->funcs->apply_clock_voltage_request(
-				context->dis_clk,
-				DM_PP_CLOCK_TYPE_DISPLAYPHYCLK,
-				req_clocks.pixel_clk_khz,
-				pre_mode_set,
-				false);
-	}
-}
-
 /*
  *  Check if FBC can be enabled
  */
@@ -2079,7 +2003,6 @@ enum dc_status dce110_apply_ctx_to_hw(
 	struct dc_bios *dcb = dc->ctx->dc_bios;
 	enum dc_status status;
 	int i;
-	enum dm_pp_clocks_state clocks_state = DM_PP_CLOCKS_STATE_INVALID;
 
 	/* Reset old context */
 	/* look up the targets that have been removed since last commit */
@@ -2113,54 +2036,10 @@ enum dc_status dce110_apply_ctx_to_hw(
 				PIPE_GATING_CONTROL_DISABLE);
 	}
 
-	set_safe_displaymarks(&context->res_ctx, dc->res_pool);
-
 	if (dc->fbc_compressor)
 		dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);
 
-	/*TODO: when pplib works*/
-	apply_min_clocks(dc, context, &clocks_state, true);
-
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	if (dc->ctx->dce_version >= DCN_VERSION_1_0) {
-		if (context->bw.dcn.calc_clk.fclk_khz
-				> dc->current_state->bw.dcn.cur_clk.fclk_khz) {
-			struct dm_pp_clock_for_voltage_req clock;
-
-			clock.clk_type = DM_PP_CLOCK_TYPE_FCLK;
-			clock.clocks_in_khz = context->bw.dcn.calc_clk.fclk_khz;
-			dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
-			dc->current_state->bw.dcn.cur_clk.fclk_khz = clock.clocks_in_khz;
-			context->bw.dcn.cur_clk.fclk_khz = clock.clocks_in_khz;
-		}
-		if (context->bw.dcn.calc_clk.dcfclk_khz
-				> dc->current_state->bw.dcn.cur_clk.dcfclk_khz) {
-			struct dm_pp_clock_for_voltage_req clock;
-
-			clock.clk_type = DM_PP_CLOCK_TYPE_DCFCLK;
-			clock.clocks_in_khz = context->bw.dcn.calc_clk.dcfclk_khz;
-			dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
-			dc->current_state->bw.dcn.cur_clk.dcfclk_khz = clock.clocks_in_khz;
-			context->bw.dcn.cur_clk.dcfclk_khz = clock.clocks_in_khz;
-		}
-		if (context->bw.dcn.calc_clk.dispclk_khz
-				> dc->current_state->bw.dcn.cur_clk.dispclk_khz) {
-			dc->res_pool->display_clock->funcs->set_clock(
-					dc->res_pool->display_clock,
-					context->bw.dcn.calc_clk.dispclk_khz);
-			dc->current_state->bw.dcn.cur_clk.dispclk_khz =
-					context->bw.dcn.calc_clk.dispclk_khz;
-			context->bw.dcn.cur_clk.dispclk_khz =
-					context->bw.dcn.calc_clk.dispclk_khz;
-		}
-	} else
-#endif
-	if (context->bw.dce.dispclk_khz
-			> dc->current_state->bw.dce.dispclk_khz) {
-		dc->res_pool->display_clock->funcs->set_clock(
-				dc->res_pool->display_clock,
-				context->bw.dce.dispclk_khz * 115 / 100);
-	}
+	dc->hwss.set_bandwidth(dc, context, false);
 
 	dce110_setup_audio_dto(dc, context);
 
@@ -2191,7 +2070,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 	}
 
 	/* to save power */
-	apply_min_clocks(dc, context, &clocks_state, false);
+	dc->hwss.set_bandwidth(dc, context, true);
 
 	dcb->funcs->set_scratch_critical_state(dcb, false);
 
@@ -2680,15 +2559,20 @@ static void dce110_set_bandwidth(
 		struct dc_state *context,
 		bool decrease_allowed)
 {
-	dce110_set_displaymarks(dc, context);
+	struct dc_clocks req_clks;
 
-	if (decrease_allowed || context->bw.dce.dispclk_khz > dc->current_state->bw.dce.dispclk_khz) {
-		dc->res_pool->display_clock->funcs->set_clock(
-				dc->res_pool->display_clock,
-				context->bw.dce.dispclk_khz * 115 / 100);
-		dc->current_state->bw.dce.dispclk_khz = context->bw.dce.dispclk_khz;
-	}
+	req_clks.dispclk_khz = context->bw.dce.dispclk_khz * 115 / 100;
+	req_clks.phyclk_khz = get_max_pixel_clock_for_all_paths(dc, context);
+
+	if (decrease_allowed)
+		dce110_set_displaymarks(dc, context);
+	else
+		dce110_set_safe_displaymarks(&context->res_ctx, dc->res_pool);
 
+	dc->res_pool->display_clock->funcs->update_clocks(
+			dc->res_pool->display_clock,
+			&req_clks,
+			decrease_allowed);
 	pplib_apply_display_requirements(dc, context);
 }
 

commit 765b26836430e9d9ebef95fced42dd167b4ccad6
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 23 13:16:50 2018 -0400

    drm/amd/display: replace clocks_value struct with dc_clocks
    
    This will avoid structs with duplicate information. Also
    removes pixel clock voltage request. This has no effect since
    pixel clock does not affect dcn voltage and this function only
    matters for dcn.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 353ffcbdf5ba..ddc8ffda9067 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1818,21 +1818,14 @@ static void apply_min_clocks(
 		context->dis_clk->funcs->apply_clock_voltage_request(
 				context->dis_clk,
 				DM_PP_CLOCK_TYPE_DISPLAY_CLK,
-				context->dis_clk->cur_clocks_value.dispclk_in_khz,
-				pre_mode_set,
-				false);
-
-		context->dis_clk->funcs->apply_clock_voltage_request(
-				context->dis_clk,
-				DM_PP_CLOCK_TYPE_PIXELCLK,
-				context->dis_clk->cur_clocks_value.max_pixelclk_in_khz,
+				context->dis_clk->clks.dispclk_khz,
 				pre_mode_set,
 				false);
 
 		context->dis_clk->funcs->apply_clock_voltage_request(
 				context->dis_clk,
 				DM_PP_CLOCK_TYPE_DISPLAYPHYCLK,
-				context->dis_clk->cur_clocks_value.max_non_dp_phyclk_in_khz,
+				context->dis_clk->clks.phyclk_khz,
 				pre_mode_set,
 				false);
 		return;
@@ -1859,13 +1852,6 @@ static void apply_min_clocks(
 				pre_mode_set,
 				false);
 
-		context->dis_clk->funcs->apply_clock_voltage_request(
-				context->dis_clk,
-				DM_PP_CLOCK_TYPE_PIXELCLK,
-				req_clocks.pixel_clk_khz,
-				pre_mode_set,
-				false);
-
 		context->dis_clk->funcs->apply_clock_voltage_request(
 				context->dis_clk,
 				DM_PP_CLOCK_TYPE_DISPLAYPHYCLK,

commit 6f0db2dc02def18ee6fb93f408a847077addb4fc
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Wed May 30 10:57:32 2018 -0400

    drm/amd/display: Make it more clear when info frames affect DP or HDMI
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 1dd2ae46d505..353ffcbdf5ba 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -665,16 +665,25 @@ static enum dc_status bios_parser_crtc_source_select(
 
 void dce110_update_info_frame(struct pipe_ctx *pipe_ctx)
 {
+	bool is_hdmi;
+	bool is_dp;
+
 	ASSERT(pipe_ctx->stream);
 
 	if (pipe_ctx->stream_res.stream_enc == NULL)
 		return;  /* this is not root pipe */
 
-	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
+	is_hdmi = dc_is_hdmi_signal(pipe_ctx->stream->signal);
+	is_dp = dc_is_dp_signal(pipe_ctx->stream->signal);
+
+	if (!is_hdmi && !is_dp)
+		return;
+
+	if (is_hdmi)
 		pipe_ctx->stream_res.stream_enc->funcs->update_hdmi_info_packets(
 			pipe_ctx->stream_res.stream_enc,
 			&pipe_ctx->stream_res.encoder_info_frame);
-	else if (dc_is_dp_signal(pipe_ctx->stream->signal))
+	else
 		pipe_ctx->stream_res.stream_enc->funcs->update_dp_info_packets(
 			pipe_ctx->stream_res.stream_enc,
 			&pipe_ctx->stream_res.encoder_info_frame);

commit 5099114ba3b2e5ae9fb487aeb3ae0434fe38a7da
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu May 31 09:09:59 2018 -0500

    drm/amdgpu/display: drop DRM_AMD_DC_FBC kconfig option
    
    Just enable it always.  This was leftover from feature
    bring up.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index cae0054c102a..1dd2ae46d505 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -34,9 +34,7 @@
 #include "dce/dce_hwseq.h"
 #include "gpio_service_interface.h"
 
-#if defined(CONFIG_DRM_AMD_DC_FBC)
 #include "dce110_compressor.h"
-#endif
 
 #include "bios/bios_parser_helper.h"
 #include "timing_generator.h"
@@ -1497,10 +1495,8 @@ static void power_down_all_hw_blocks(struct dc *dc)
 
 	power_down_clock_sources(dc);
 
-#if defined(CONFIG_DRM_AMD_DC_FBC)
 	if (dc->fbc_compressor)
 		dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);
-#endif
 }
 
 static void disable_vga_and_power_gate_all_controllers(
@@ -1742,9 +1738,7 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
 	if (events->force_trigger)
 		value |= 0x1;
 
-#if defined(CONFIG_DRM_AMD_DC_FBC)
 	value |= 0x84;
-#endif
 
 	for (i = 0; i < num_pipes; i++)
 		pipe_ctx[i]->stream_res.tg->funcs->
@@ -1872,8 +1866,6 @@ static void apply_min_clocks(
 	}
 }
 
-#if defined(CONFIG_DRM_AMD_DC_FBC)
-
 /*
  *  Check if FBC can be enabled
  */
@@ -1952,7 +1944,6 @@ static void enable_fbc(struct dc *dc,
 		compr->funcs->enable_fbc(compr, &params);
 	}
 }
-#endif
 
 static void dce110_reset_hw_ctx_wrap(
 		struct dc *dc,
@@ -2129,10 +2120,9 @@ enum dc_status dce110_apply_ctx_to_hw(
 
 	set_safe_displaymarks(&context->res_ctx, dc->res_pool);
 
-#if defined(CONFIG_DRM_AMD_DC_FBC)
 	if (dc->fbc_compressor)
 		dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);
-#endif
+
 	/*TODO: when pplib works*/
 	apply_min_clocks(dc, context, &clocks_state, true);
 
@@ -2210,12 +2200,9 @@ enum dc_status dce110_apply_ctx_to_hw(
 
 	dcb->funcs->set_scratch_critical_state(dcb, false);
 
-#if defined(CONFIG_DRM_AMD_DC_FBC)
 	if (dc->fbc_compressor)
 		enable_fbc(dc, context);
 
-#endif
-
 	return DC_OK;
 }
 
@@ -2530,10 +2517,9 @@ static void init_hw(struct dc *dc)
 		abm->funcs->init_backlight(abm);
 		abm->funcs->abm_init(abm);
 	}
-#if defined(CONFIG_DRM_AMD_DC_FBC)
+
 	if (dc->fbc_compressor)
 		dc->fbc_compressor->funcs->power_up_fbc(dc->fbc_compressor);
-#endif
 
 }
 
@@ -2719,9 +2705,7 @@ static void dce110_program_front_end_for_pipe(
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
-#if defined(CONFIG_DRM_AMD_DC_FBC)
 	unsigned int underlay_idx = dc->res_pool->underlay_pipe_index;
-#endif
 	unsigned int i;
 	DC_LOGGER_INIT();
 	memset(&tbl_entry, 0, sizeof(tbl_entry));
@@ -2762,7 +2746,6 @@ static void dce110_program_front_end_for_pipe(
 
 	program_scaler(dc, pipe_ctx);
 
-#if defined(CONFIG_DRM_AMD_DC_FBC)
 	/* fbc not applicable on Underlay pipe */
 	if (dc->fbc_compressor && old_pipe->stream &&
 	    pipe_ctx->pipe_idx != underlay_idx) {
@@ -2771,7 +2754,6 @@ static void dce110_program_front_end_for_pipe(
 		else
 			enable_fbc(dc, dc->current_state);
 	}
-#endif
 
 	mi->funcs->mem_input_program_surface_config(
 			mi,

commit 1a05873f21d6192575382afd2feb18df935e46f0
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu May 10 14:21:47 2018 -0400

    drm/amd/display: Refactor audio programming
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index c29052b6da5a..cae0054c102a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -972,19 +972,35 @@ void hwss_edp_backlight_control(
 		edp_receiver_ready_T9(link);
 }
 
-void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)
+void dce110_enable_audio_stream(struct pipe_ctx *pipe_ctx)
 {
-	struct dc_stream_state *stream = pipe_ctx->stream;
-	struct dc_link *link = stream->sink->link;
-	struct dc *dc = pipe_ctx->stream->ctx->dc;
+	struct dc *core_dc = pipe_ctx->stream->ctx->dc;
+	/* notify audio driver for audio modes of monitor */
+	struct pp_smu_funcs_rv *pp_smu = core_dc->res_pool->pp_smu;
+	unsigned int i, num_audio = 1;
 
-	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
-		pipe_ctx->stream_res.stream_enc->funcs->stop_hdmi_info_packets(
-			pipe_ctx->stream_res.stream_enc);
+	if (pipe_ctx->stream_res.audio) {
+		for (i = 0; i < MAX_PIPES; i++) {
+			/*current_state not updated yet*/
+			if (core_dc->current_state->res_ctx.pipe_ctx[i].stream_res.audio != NULL)
+				num_audio++;
+		}
 
-	if (dc_is_dp_signal(pipe_ctx->stream->signal))
-		pipe_ctx->stream_res.stream_enc->funcs->stop_dp_info_packets(
-			pipe_ctx->stream_res.stream_enc);
+		pipe_ctx->stream_res.audio->funcs->az_enable(pipe_ctx->stream_res.audio);
+
+		if (num_audio == 1 && pp_smu != NULL && pp_smu->set_pme_wa_enable != NULL)
+			/*this is the first audio. apply the PME w/a in order to wake AZ from D3*/
+			pp_smu->set_pme_wa_enable(&pp_smu->pp_smu);
+		/* un-mute audio */
+		/* TODO: audio should be per stream rather than per link */
+		pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
+			pipe_ctx->stream_res.stream_enc, false);
+	}
+}
+
+void dce110_disable_audio_stream(struct pipe_ctx *pipe_ctx, int option)
+{
+	struct dc *dc = pipe_ctx->stream->ctx->dc;
 
 	pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
 			pipe_ctx->stream_res.stream_enc, true);
@@ -1015,7 +1031,23 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)
 		 * stream->stream_engine_id);
 		 */
 	}
+}
 
+void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)
+{
+	struct dc_stream_state *stream = pipe_ctx->stream;
+	struct dc_link *link = stream->sink->link;
+	struct dc *dc = pipe_ctx->stream->ctx->dc;
+
+	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
+		pipe_ctx->stream_res.stream_enc->funcs->stop_hdmi_info_packets(
+			pipe_ctx->stream_res.stream_enc);
+
+	if (dc_is_dp_signal(pipe_ctx->stream->signal))
+		pipe_ctx->stream_res.stream_enc->funcs->stop_dp_info_packets(
+			pipe_ctx->stream_res.stream_enc);
+
+	dc->hwss.disable_audio_stream(pipe_ctx, option);
 
 	link->link_enc->funcs->connect_dig_be_to_fe(
 			link->link_enc,
@@ -1298,6 +1330,30 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	struct pipe_ctx *pipe_ctx_old = &dc->current_state->res_ctx.
 			pipe_ctx[pipe_ctx->pipe_idx];
 
+	if (pipe_ctx->stream_res.audio != NULL) {
+		struct audio_output audio_output;
+
+		build_audio_output(context, pipe_ctx, &audio_output);
+
+		if (dc_is_dp_signal(pipe_ctx->stream->signal))
+			pipe_ctx->stream_res.stream_enc->funcs->dp_audio_setup(
+					pipe_ctx->stream_res.stream_enc,
+					pipe_ctx->stream_res.audio->inst,
+					&pipe_ctx->stream->audio_info);
+		else
+			pipe_ctx->stream_res.stream_enc->funcs->hdmi_audio_setup(
+					pipe_ctx->stream_res.stream_enc,
+					pipe_ctx->stream_res.audio->inst,
+					&pipe_ctx->stream->audio_info,
+					&audio_output.crtc_info);
+
+		pipe_ctx->stream_res.audio->funcs->az_configure(
+				pipe_ctx->stream_res.audio,
+				pipe_ctx->stream->signal,
+				&audio_output.crtc_info,
+				&pipe_ctx->stream->audio_info);
+	}
+
 	/*  */
 	dc->hwss.enable_stream_timing(pipe_ctx, context, dc);
 
@@ -1949,6 +2005,86 @@ static void dce110_reset_hw_ctx_wrap(
 	}
 }
 
+static void dce110_setup_audio_dto(
+		struct dc *dc,
+		struct dc_state *context)
+{
+	int i;
+
+	/* program audio wall clock. use HDMI as clock source if HDMI
+	 * audio active. Otherwise, use DP as clock source
+	 * first, loop to find any HDMI audio, if not, loop find DP audio
+	 */
+	/* Setup audio rate clock source */
+	/* Issue:
+	* Audio lag happened on DP monitor when unplug a HDMI monitor
+	*
+	* Cause:
+	* In case of DP and HDMI connected or HDMI only, DCCG_AUDIO_DTO_SEL
+	* is set to either dto0 or dto1, audio should work fine.
+	* In case of DP connected only, DCCG_AUDIO_DTO_SEL should be dto1,
+	* set to dto0 will cause audio lag.
+	*
+	* Solution:
+	* Not optimized audio wall dto setup. When mode set, iterate pipe_ctx,
+	* find first available pipe with audio, setup audio wall DTO per topology
+	* instead of per pipe.
+	*/
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (pipe_ctx->stream == NULL)
+			continue;
+
+		if (pipe_ctx->top_pipe)
+			continue;
+
+		if (pipe_ctx->stream->signal != SIGNAL_TYPE_HDMI_TYPE_A)
+			continue;
+
+		if (pipe_ctx->stream_res.audio != NULL) {
+			struct audio_output audio_output;
+
+			build_audio_output(context, pipe_ctx, &audio_output);
+
+			pipe_ctx->stream_res.audio->funcs->wall_dto_setup(
+				pipe_ctx->stream_res.audio,
+				pipe_ctx->stream->signal,
+				&audio_output.crtc_info,
+				&audio_output.pll_info);
+			break;
+		}
+	}
+
+	/* no HDMI audio is found, try DP audio */
+	if (i == dc->res_pool->pipe_count) {
+		for (i = 0; i < dc->res_pool->pipe_count; i++) {
+			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+			if (pipe_ctx->stream == NULL)
+				continue;
+
+			if (pipe_ctx->top_pipe)
+				continue;
+
+			if (!dc_is_dp_signal(pipe_ctx->stream->signal))
+				continue;
+
+			if (pipe_ctx->stream_res.audio != NULL) {
+				struct audio_output audio_output;
+
+				build_audio_output(context, pipe_ctx, &audio_output);
+
+				pipe_ctx->stream_res.audio->funcs->wall_dto_setup(
+					pipe_ctx->stream_res.audio,
+					pipe_ctx->stream->signal,
+					&audio_output.crtc_info,
+					&audio_output.pll_info);
+				break;
+			}
+		}
+	}
+}
 
 enum dc_status dce110_apply_ctx_to_hw(
 		struct dc *dc,
@@ -2040,79 +2176,8 @@ enum dc_status dce110_apply_ctx_to_hw(
 				dc->res_pool->display_clock,
 				context->bw.dce.dispclk_khz * 115 / 100);
 	}
-	/* program audio wall clock. use HDMI as clock source if HDMI
-	 * audio active. Otherwise, use DP as clock source
-	 * first, loop to find any HDMI audio, if not, loop find DP audio
-	 */
-	/* Setup audio rate clock source */
-	/* Issue:
-	* Audio lag happened on DP monitor when unplug a HDMI monitor
-	*
-	* Cause:
-	* In case of DP and HDMI connected or HDMI only, DCCG_AUDIO_DTO_SEL
-	* is set to either dto0 or dto1, audio should work fine.
-	* In case of DP connected only, DCCG_AUDIO_DTO_SEL should be dto1,
-	* set to dto0 will cause audio lag.
-	*
-	* Solution:
-	* Not optimized audio wall dto setup. When mode set, iterate pipe_ctx,
-	* find first available pipe with audio, setup audio wall DTO per topology
-	* instead of per pipe.
-	*/
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-
-		if (pipe_ctx->stream == NULL)
-			continue;
-
-		if (pipe_ctx->top_pipe)
-			continue;
-
-		if (pipe_ctx->stream->signal != SIGNAL_TYPE_HDMI_TYPE_A)
-			continue;
-
-		if (pipe_ctx->stream_res.audio != NULL) {
-			struct audio_output audio_output;
-
-			build_audio_output(context, pipe_ctx, &audio_output);
-
-			pipe_ctx->stream_res.audio->funcs->wall_dto_setup(
-				pipe_ctx->stream_res.audio,
-				pipe_ctx->stream->signal,
-				&audio_output.crtc_info,
-				&audio_output.pll_info);
-			break;
-		}
-	}
-
-	/* no HDMI audio is found, try DP audio */
-	if (i == dc->res_pool->pipe_count) {
-		for (i = 0; i < dc->res_pool->pipe_count; i++) {
-			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-
-			if (pipe_ctx->stream == NULL)
-				continue;
-
-			if (pipe_ctx->top_pipe)
-				continue;
-
-			if (!dc_is_dp_signal(pipe_ctx->stream->signal))
-				continue;
-
-			if (pipe_ctx->stream_res.audio != NULL) {
-				struct audio_output audio_output;
-
-				build_audio_output(context, pipe_ctx, &audio_output);
 
-				pipe_ctx->stream_res.audio->funcs->wall_dto_setup(
-					pipe_ctx->stream_res.audio,
-					pipe_ctx->stream->signal,
-					&audio_output.crtc_info,
-					&audio_output.pll_info);
-				break;
-			}
-		}
-	}
+	dce110_setup_audio_dto(dc, context);
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx_old =
@@ -2131,31 +2196,6 @@ enum dc_status dce110_apply_ctx_to_hw(
 		if (pipe_ctx->top_pipe)
 			continue;
 
-		if (context->res_ctx.pipe_ctx[i].stream_res.audio != NULL) {
-
-			struct audio_output audio_output;
-
-			build_audio_output(context, pipe_ctx, &audio_output);
-
-			if (dc_is_dp_signal(pipe_ctx->stream->signal))
-				pipe_ctx->stream_res.stream_enc->funcs->dp_audio_setup(
-						pipe_ctx->stream_res.stream_enc,
-						pipe_ctx->stream_res.audio->inst,
-						&pipe_ctx->stream->audio_info);
-			else
-				pipe_ctx->stream_res.stream_enc->funcs->hdmi_audio_setup(
-						pipe_ctx->stream_res.stream_enc,
-						pipe_ctx->stream_res.audio->inst,
-						&pipe_ctx->stream->audio_info,
-						&audio_output.crtc_info);
-
-			pipe_ctx->stream_res.audio->funcs->az_configure(
-					pipe_ctx->stream_res.audio,
-					pipe_ctx->stream->signal,
-					&audio_output.crtc_info,
-					&pipe_ctx->stream->audio_info);
-		}
-
 		status = apply_single_controller_ctx_to_hw(
 				pipe_ctx,
 				context,
@@ -2968,6 +3008,8 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.disable_stream = dce110_disable_stream,
 	.unblank_stream = dce110_unblank_stream,
 	.blank_stream = dce110_blank_stream,
+	.enable_audio_stream = dce110_enable_audio_stream,
+	.disable_audio_stream = dce110_disable_audio_stream,
 	.enable_display_pipe_clock_gating = enable_display_pipe_clock_gating,
 	.enable_display_power_gating = dce110_enable_display_power_gating,
 	.disable_plane = dce110_power_down_fe,

commit fb5fb63aa91aa7b353e3f7f0031299760f65ecf2
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Tue May 1 19:49:03 2018 -0400

    drm/amd/display: add register offset != 0 check.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index a92fb0aa2ff3..c29052b6da5a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1004,9 +1004,9 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)
 		/*don't free audio if it is from retrain or internal disable stream*/
 		if (option == FREE_ACQUIRED_RESOURCE && dc->caps.dynamic_audio == true) {
 			/*we have to dynamic arbitrate the audio endpoints*/
-			pipe_ctx->stream_res.audio = NULL;
 			/*we free the resource, need reset is_audio_acquired*/
 			update_audio_usage(&dc->current_state->res_ctx, dc->res_pool, pipe_ctx->stream_res.audio, false);
+			pipe_ctx->stream_res.audio = NULL;
 		}
 
 		/* TODO: notify audio driver for if audio modes list changed

commit eb0e515464e4a1be730c7ac7a01c3ba04c98ea97
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Apr 18 11:37:53 2018 -0400

    drm/amd/display: get rid of 32.32 unsigned fixed point
    
    32.32 is redundant, 31.32 does everything we use 32.32 for
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index ae500421edb6..a92fb0aa2ff3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -509,19 +509,19 @@ dce110_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
 	rgb_resulted[hw_points - 1].green = output_tf->tf_pts.green[start_index];
 	rgb_resulted[hw_points - 1].blue = output_tf->tf_pts.blue[start_index];
 
-	arr_points[0].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
-					     dal_fixed31_32_from_int(region_start));
-	arr_points[1].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
-					     dal_fixed31_32_from_int(region_end));
+	arr_points[0].x = dc_fixpt_pow(dc_fixpt_from_int(2),
+					     dc_fixpt_from_int(region_start));
+	arr_points[1].x = dc_fixpt_pow(dc_fixpt_from_int(2),
+					     dc_fixpt_from_int(region_end));
 
 	y_r = rgb_resulted[0].red;
 	y_g = rgb_resulted[0].green;
 	y_b = rgb_resulted[0].blue;
 
-	y1_min = dal_fixed31_32_min(y_r, dal_fixed31_32_min(y_g, y_b));
+	y1_min = dc_fixpt_min(y_r, dc_fixpt_min(y_g, y_b));
 
 	arr_points[0].y = y1_min;
-	arr_points[0].slope = dal_fixed31_32_div(arr_points[0].y,
+	arr_points[0].slope = dc_fixpt_div(arr_points[0].y,
 						 arr_points[0].x);
 
 	y_r = rgb_resulted[hw_points - 1].red;
@@ -531,21 +531,21 @@ dce110_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
 	/* see comment above, m_arrPoints[1].y should be the Y value for the
 	 * region end (m_numOfHwPoints), not last HW point(m_numOfHwPoints - 1)
 	 */
-	y3_max = dal_fixed31_32_max(y_r, dal_fixed31_32_max(y_g, y_b));
+	y3_max = dc_fixpt_max(y_r, dc_fixpt_max(y_g, y_b));
 
 	arr_points[1].y = y3_max;
 
-	arr_points[1].slope = dal_fixed31_32_zero;
+	arr_points[1].slope = dc_fixpt_zero;
 
 	if (output_tf->tf == TRANSFER_FUNCTION_PQ) {
 		/* for PQ, we want to have a straight line from last HW X point,
 		 * and the slope to be such that we hit 1.0 at 10000 nits.
 		 */
-		const struct fixed31_32 end_value = dal_fixed31_32_from_int(125);
+		const struct fixed31_32 end_value = dc_fixpt_from_int(125);
 
-		arr_points[1].slope = dal_fixed31_32_div(
-				dal_fixed31_32_sub(dal_fixed31_32_one, arr_points[1].y),
-				dal_fixed31_32_sub(end_value, arr_points[1].x));
+		arr_points[1].slope = dc_fixpt_div(
+				dc_fixpt_sub(dc_fixpt_one, arr_points[1].y),
+				dc_fixpt_sub(end_value, arr_points[1].x));
 	}
 
 	regamma_params->hw_points_num = hw_points;
@@ -569,16 +569,16 @@ dce110_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
 	i = 1;
 
 	while (i != hw_points + 1) {
-		if (dal_fixed31_32_lt(rgb_plus_1->red, rgb->red))
+		if (dc_fixpt_lt(rgb_plus_1->red, rgb->red))
 			rgb_plus_1->red = rgb->red;
-		if (dal_fixed31_32_lt(rgb_plus_1->green, rgb->green))
+		if (dc_fixpt_lt(rgb_plus_1->green, rgb->green))
 			rgb_plus_1->green = rgb->green;
-		if (dal_fixed31_32_lt(rgb_plus_1->blue, rgb->blue))
+		if (dc_fixpt_lt(rgb_plus_1->blue, rgb->blue))
 			rgb_plus_1->blue = rgb->blue;
 
-		rgb->delta_red = dal_fixed31_32_sub(rgb_plus_1->red, rgb->red);
-		rgb->delta_green = dal_fixed31_32_sub(rgb_plus_1->green, rgb->green);
-		rgb->delta_blue = dal_fixed31_32_sub(rgb_plus_1->blue, rgb->blue);
+		rgb->delta_red = dc_fixpt_sub(rgb_plus_1->red, rgb->red);
+		rgb->delta_green = dc_fixpt_sub(rgb_plus_1->green, rgb->green);
+		rgb->delta_blue = dc_fixpt_sub(rgb_plus_1->blue, rgb->blue);
 
 		++rgb_plus_1;
 		++rgb;

commit b79655c37b209315d3b533f6d63a3d6f5fcb6f84
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Apr 12 22:40:02 2018 -0400

    drm/amd/display: Cleanup unused SetPlaneConfig
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 2288d0aa773b..ae500421edb6 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2269,74 +2269,6 @@ static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 
 	pipe_ctx->plane_res.xfm->funcs->transform_set_gamut_remap(pipe_ctx->plane_res.xfm, &adjust);
 }
-
-/**
- * TODO REMOVE, USE UPDATE INSTEAD
- */
-static void set_plane_config(
-	const struct dc *dc,
-	struct pipe_ctx *pipe_ctx,
-	struct resource_context *res_ctx)
-{
-	struct mem_input *mi = pipe_ctx->plane_res.mi;
-	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
-	struct xfm_grph_csc_adjustment adjust;
-	struct out_csc_color_matrix tbl_entry;
-	unsigned int i;
-
-	memset(&adjust, 0, sizeof(adjust));
-	memset(&tbl_entry, 0, sizeof(tbl_entry));
-	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
-
-	dce_enable_fe_clock(dc->hwseq, mi->inst, true);
-
-	set_default_colors(pipe_ctx);
-	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment == true) {
-		tbl_entry.color_space =
-			pipe_ctx->stream->output_color_space;
-
-		for (i = 0; i < 12; i++)
-			tbl_entry.regval[i] =
-			pipe_ctx->stream->csc_color_matrix.matrix[i];
-
-		pipe_ctx->plane_res.xfm->funcs->opp_set_csc_adjustment
-				(pipe_ctx->plane_res.xfm, &tbl_entry);
-	}
-
-	if (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {
-		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
-
-		for (i = 0; i < CSC_TEMPERATURE_MATRIX_SIZE; i++)
-			adjust.temperature_matrix[i] =
-				pipe_ctx->stream->gamut_remap_matrix.matrix[i];
-	}
-
-	pipe_ctx->plane_res.xfm->funcs->transform_set_gamut_remap(pipe_ctx->plane_res.xfm, &adjust);
-
-	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
-	program_scaler(dc, pipe_ctx);
-
-	program_surface_visibility(dc, pipe_ctx);
-
-	mi->funcs->mem_input_program_surface_config(
-			mi,
-			plane_state->format,
-			&plane_state->tiling_info,
-			&plane_state->plane_size,
-			plane_state->rotation,
-			NULL,
-			false);
-	if (mi->funcs->set_blank)
-		mi->funcs->set_blank(mi, pipe_ctx->plane_state->visible);
-
-	if (dc->config.gpu_vm_support)
-		mi->funcs->mem_input_program_pte_vm(
-				pipe_ctx->plane_res.mi,
-				plane_state->format,
-				&plane_state->tiling_info,
-				plane_state->rotation);
-}
-
 static void update_plane_addr(const struct dc *dc,
 		struct pipe_ctx *pipe_ctx)
 {
@@ -3023,7 +2955,6 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.init_hw = init_hw,
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
 	.apply_ctx_for_surface = dce110_apply_ctx_for_surface,
-	.set_plane_config = set_plane_config,
 	.update_plane_addr = update_plane_addr,
 	.update_pending_status = dce110_update_pending_status,
 	.set_input_transfer_func = dce110_set_input_transfer_func,

commit 87ac8fb08bc7c69a39842c73f3a9d06eb73f02cc
Author: Shirish S <shirish.s@amd.com>
Date:   Wed Apr 25 14:42:28 2018 +0530

    drm/amd/display: disable FBC on underlay pipe
    
    FBC is not applicable for the underlay pipe,
    hence disallow enabling and disabling of the same.
    
    This also fixes the BUG hit of calling sleep in
    atomic context.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 51c6c70a4a30..2288d0aa773b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2747,6 +2747,9 @@ static void dce110_program_front_end_for_pipe(
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
+#if defined(CONFIG_DRM_AMD_DC_FBC)
+	unsigned int underlay_idx = dc->res_pool->underlay_pipe_index;
+#endif
 	unsigned int i;
 	DC_LOGGER_INIT();
 	memset(&tbl_entry, 0, sizeof(tbl_entry));
@@ -2788,7 +2791,9 @@ static void dce110_program_front_end_for_pipe(
 	program_scaler(dc, pipe_ctx);
 
 #if defined(CONFIG_DRM_AMD_DC_FBC)
-	if (dc->fbc_compressor && old_pipe->stream) {
+	/* fbc not applicable on Underlay pipe */
+	if (dc->fbc_compressor && old_pipe->stream &&
+	    pipe_ctx->pipe_idx != underlay_idx) {
 		if (plane_state->tiling_info.gfx8.array_mode == DC_ARRAY_LINEAR_GENERAL)
 			dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);
 		else

commit 3158223efde597521505b586a88a6d43c8f2324f
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Mon Apr 9 17:19:27 2018 -0400

    drm/amd/display: Refactor otg_blank sequence
    
    Also rename otg_blank to blank_pixel_data.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e70ccb9b6afe..51c6c70a4a30 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1233,7 +1233,7 @@ static void program_scaler(const struct dc *dc,
 		&pipe_ctx->plane_res.scl_data);
 }
 
-static enum dc_status dce110_prog_pixclk_crtc_otg(
+static enum dc_status dce110_enable_stream_timing(
 		struct pipe_ctx *pipe_ctx,
 		struct dc_state *context,
 		struct dc *dc)
@@ -1299,7 +1299,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 			pipe_ctx[pipe_ctx->pipe_idx];
 
 	/*  */
-	dc->hwss.prog_pixclk_crtc_otg(pipe_ctx, context, dc);
+	dc->hwss.enable_stream_timing(pipe_ctx, context, dc);
 
 	/* FPGA does not program backend */
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
@@ -3041,7 +3041,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.get_position = get_position,
 	.set_static_screen_control = set_static_screen_control,
 	.reset_hw_ctx_wrap = dce110_reset_hw_ctx_wrap,
-	.prog_pixclk_crtc_otg = dce110_prog_pixclk_crtc_otg,
+	.enable_stream_timing = dce110_enable_stream_timing,
 	.setup_stereo = NULL,
 	.set_avmute = dce110_set_avmute,
 	.wait_for_mpcc_disconnect = dce110_wait_for_mpcc_disconnect,

commit f0c0761b38ac30b04d4fed436ff10e894ec0e525
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Apr 9 16:15:20 2018 -0400

    drm/amd/display: Use dig enable to determine fast boot optimization.
    
    Linux doesn't know lid state, better to check dig enable
    value from register.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index bd34193ad779..e70ccb9b6afe 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1471,15 +1471,15 @@ static void disable_vga_and_power_gate_all_controllers(
 	}
 }
 
-static bool is_eDP_lid_closed(struct dc_state *context)
+static struct dc_link *get_link_for_edp(struct dc *dc)
 {
 	int i;
 
-	for (i = 0; i < context->stream_count; i++) {
-		if (context->streams[i]->signal == SIGNAL_TYPE_EDP)
-			return context->streams[i]->lid_state_closed;
+	for (i = 0; i < dc->link_count; i++) {
+		if (dc->links[i]->connector_signal == SIGNAL_TYPE_EDP)
+			return dc->links[i];
 	}
-	return false;
+	return NULL;
 }
 
 static struct dc_link *get_link_for_edp_not_in_use(
@@ -1516,41 +1516,22 @@ static struct dc_link *get_link_for_edp_not_in_use(
  */
 void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 {
-	/* check eDP lid state and BIOS_SCRATCH_3 to determine fast boot optimization
-	 * UEFI boot
-	 *				edp_active_status_from_scratch		fast boot optimization
-	 * S4/S5 resume:
-	 * Lid Open		true								true
-	 * Lid Close	false								false
-	 *
-	 * S3/ resume:
-	 * Lid Open		false								false
-	 * Lid Close	false								false
-	 *
-	 * Legacy boot:
-	 *				edp_active_status_from_scratch		fast boot optimization
-	 * S4/S resume:
-	 * Lid Open		true								true
-	 * Lid Close	true								false
-	 *
-	 * S3/ resume:
-	 * Lid Open		false								false
-	 * Lid Close	false								false
-	 */
-	struct dc_bios *dcb = dc->ctx->dc_bios;
-	bool lid_state_closed = is_eDP_lid_closed(context);
 	struct dc_link *edp_link_to_turnoff = NULL;
-	bool edp_active_status_from_scratch =
-			(dcb->funcs->get_vga_enabled_displays(dc->ctx->dc_bios) == ATOM_DISPLAY_LCD1_ACTIVE);
+	struct dc_link *edp_link = get_link_for_edp(dc);
+	bool can_eDP_fast_boot_optimize = false;
+
+	if (edp_link) {
+		can_eDP_fast_boot_optimize =
+				edp_link->link_enc->funcs->is_dig_enabled(edp_link->link_enc);
+	}
 
-	/*Lid open*/
-	if (!lid_state_closed) {
+	if (can_eDP_fast_boot_optimize) {
 		edp_link_to_turnoff = get_link_for_edp_not_in_use(dc, context);
 
 		/* if OS doesn't light up eDP and eDP link is available, we want to disable
 		 * If resume from S4/S5, should optimization.
 		 */
-		if (!edp_link_to_turnoff && edp_active_status_from_scratch)
+		if (!edp_link_to_turnoff)
 			dc->apply_edp_fast_boot_optimization = true;
 	}
 

commit 2c37e49a6bcd5e0c66963301e9feab63b5f928f3
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Apr 6 21:38:10 2018 -0400

    drm/amd/display: Check SCRATCH reg to determine S3 resume.
    
    Use lid state only to determine fast boot optimization is not enough.
    For S3/Resume, due to bios isn't involved in boot, eDP wasn't
    light up, while lid state is open, if do fast boot optimization,
    eDP panel will skip enable link and result in black screen after boot.
    And becasue of bios isn't involved, no matter UEFI or Legacy boot,
    BIOS_SCRATCH_3 value should be 0, use this to determine the case.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 4a4b3bcd4230..bd34193ad779 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1516,18 +1516,41 @@ static struct dc_link *get_link_for_edp_not_in_use(
  */
 void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 {
-	/* check eDP lid state:
-	 * If lid is open, vbios already light up eDP, so we can leverage vbios and skip eDP
-	 * programming
+	/* check eDP lid state and BIOS_SCRATCH_3 to determine fast boot optimization
+	 * UEFI boot
+	 *				edp_active_status_from_scratch		fast boot optimization
+	 * S4/S5 resume:
+	 * Lid Open		true								true
+	 * Lid Close	false								false
+	 *
+	 * S3/ resume:
+	 * Lid Open		false								false
+	 * Lid Close	false								false
+	 *
+	 * Legacy boot:
+	 *				edp_active_status_from_scratch		fast boot optimization
+	 * S4/S resume:
+	 * Lid Open		true								true
+	 * Lid Close	true								false
+	 *
+	 * S3/ resume:
+	 * Lid Open		false								false
+	 * Lid Close	false								false
 	 */
+	struct dc_bios *dcb = dc->ctx->dc_bios;
 	bool lid_state_closed = is_eDP_lid_closed(context);
 	struct dc_link *edp_link_to_turnoff = NULL;
+	bool edp_active_status_from_scratch =
+			(dcb->funcs->get_vga_enabled_displays(dc->ctx->dc_bios) == ATOM_DISPLAY_LCD1_ACTIVE);
 
+	/*Lid open*/
 	if (!lid_state_closed) {
 		edp_link_to_turnoff = get_link_for_edp_not_in_use(dc, context);
 
-		/* if OS doesn't light up eDP and eDP link is available, we want to disable */
-		if (!edp_link_to_turnoff)
+		/* if OS doesn't light up eDP and eDP link is available, we want to disable
+		 * If resume from S4/S5, should optimization.
+		 */
+		if (!edp_link_to_turnoff && edp_active_status_from_scratch)
 			dc->apply_edp_fast_boot_optimization = true;
 	}
 

commit 339cc82ae67700cb25a5bb10842cca5b09a79afe
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Apr 4 17:27:18 2018 -0400

    drm/amd/display: Check lid state to determine fast boot optimization.
    
    For legacy enable boot up with lid closed, eDP information couldn't be
    read correctly via SBIOS_SCRATCH_3 results in eDP cannot be light up
    properly when open lid.
    Check lid state instead can resolve the issue.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 1b5c11c8fa1f..4a4b3bcd4230 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1471,6 +1471,17 @@ static void disable_vga_and_power_gate_all_controllers(
 	}
 }
 
+static bool is_eDP_lid_closed(struct dc_state *context)
+{
+	int i;
+
+	for (i = 0; i < context->stream_count; i++) {
+		if (context->streams[i]->signal == SIGNAL_TYPE_EDP)
+			return context->streams[i]->lid_state_closed;
+	}
+	return false;
+}
+
 static struct dc_link *get_link_for_edp_not_in_use(
 		struct dc *dc,
 		struct dc_state *context)
@@ -1505,20 +1516,17 @@ static struct dc_link *get_link_for_edp_not_in_use(
  */
 void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 {
-	struct dc_bios *dcb = dc->ctx->dc_bios;
-
-	/* vbios already light up eDP, so we can leverage vbios and skip eDP
+	/* check eDP lid state:
+	 * If lid is open, vbios already light up eDP, so we can leverage vbios and skip eDP
 	 * programming
 	 */
-	bool can_eDP_fast_boot_optimize =
-			(dcb->funcs->get_vga_enabled_displays(dc->ctx->dc_bios) == ATOM_DISPLAY_LCD1_ACTIVE);
-
-	/* if OS doesn't light up eDP and eDP link is available, we want to disable */
+	bool lid_state_closed = is_eDP_lid_closed(context);
 	struct dc_link *edp_link_to_turnoff = NULL;
 
-	if (can_eDP_fast_boot_optimize) {
+	if (!lid_state_closed) {
 		edp_link_to_turnoff = get_link_for_edp_not_in_use(dc, context);
 
+		/* if OS doesn't light up eDP and eDP link is available, we want to disable */
 		if (!edp_link_to_turnoff)
 			dc->apply_edp_fast_boot_optimization = true;
 	}

commit fc6de1c565e03f492a3d9725b93092dac0cc1845
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Apr 3 16:07:16 2018 -0400

    drm/amd/display: Fix regamma not affecting full-intensity color values
    
    Hardware understands the regamma LUT as a piecewise linear function,
    with points spaced exponentially along the range. We previously
    programmed the LUT for range [2^-10, 2^0). This causes (normalized)
    color values of 1 (=2^0) to miss the programmed LUT, and fall onto the
    end region.
    
    For DCE, the end region is extrapolated using a single (base, slope)
    pair, using the max y-value from the last point in the curve as base.
    This presents a problem, since this value affects all three color
    channels. Scaling down the intensity of say - the blue regamma curve -
    will not affect it's end region. This is especially noticiable when
    using RedShift. It scales down the blue and green channels, but leaves
    full-intensity colors unshifted.
    
    Therefore, extend the range to cover [2^-10, 2^1) by programming another
    hardware segment, containing only one point. That way, we won't be
    hitting the end region.
    
    Note that things are a bit different for DCN, since the end region can
    be set per-channel.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 15897f0a9616..1b5c11c8fa1f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -456,10 +456,13 @@ dce110_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
 
 	} else {
 		/* 10 segments
-		 * segment is from 2^-10 to 2^0
+		 * segment is from 2^-10 to 2^1
+		 * We include an extra segment for range [2^0, 2^1). This is to
+		 * ensure that colors with normalized values of 1 don't miss the
+		 * LUT.
 		 */
 		region_start = -10;
-		region_end = 0;
+		region_end = 1;
 
 		seg_distr[0] = 4;
 		seg_distr[1] = 4;
@@ -471,7 +474,7 @@ dce110_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
 		seg_distr[7] = 4;
 		seg_distr[8] = 4;
 		seg_distr[9] = 4;
-		seg_distr[10] = -1;
+		seg_distr[10] = 0;
 		seg_distr[11] = -1;
 		seg_distr[12] = -1;
 		seg_distr[13] = -1;

commit ab892598d033d1943e1dcb0326f2622d6026f524
Author: Roman Li <Roman.Li@amd.com>
Date:   Thu Mar 29 10:56:17 2018 -0400

    drm/amd/display: fix brightness level after resume from suspend
    
    Adding missing call to cache current backlight values.
    Otherwise the brightness resets to default value on resume.
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 68a182ce53c7..15897f0a9616 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1046,8 +1046,10 @@ void dce110_blank_stream(struct pipe_ctx *pipe_ctx)
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->sink->link;
 
-	if (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP)
+	if (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP) {
 		link->dc->hwss.edp_backlight_control(link, false);
+		dc_link_set_abm_disable(link);
+	}
 
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_res.stream_enc->funcs->dp_blank(pipe_ctx->stream_res.stream_enc);

commit 45a2d58e84e6d28c2d9ae8e68bd815d9a98ad52e
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Apr 10 16:08:44 2018 -0400

    drm/amd/display: Fix 64-bit division in hwss_edp_power_control
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 52427ae42e0f..68a182ce53c7 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -857,7 +857,7 @@ void hwss_edp_power_control(
 					dm_get_elapse_time_in_ns(
 							ctx,
 							current_ts,
-							link->link_trace.time_stamp.edp_poweroff) / 1000000;
+							div64_u64(link->link_trace.time_stamp.edp_poweroff, 1000000));
 			unsigned long long wait_time_ms = 0;
 
 			/* max 500ms from LCDVDD off to on */

commit 84ffa80123f56f80145dc638f21dfcbedda5610d
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Thu Mar 29 17:04:12 2018 -0400

    drm/amd/display: Fix dim display on DCE11
    
    Before programming the input gamma, check that we're not using the
    identity correction.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 78bf4fae9e0d..52427ae42e0f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -280,7 +280,9 @@ dce110_set_input_transfer_func(struct pipe_ctx *pipe_ctx,
 	build_prescale_params(&prescale_params, plane_state);
 	ipp->funcs->ipp_program_prescale(ipp, &prescale_params);
 
-	if (plane_state->gamma_correction && dce_use_lut(plane_state->format))
+	if (plane_state->gamma_correction &&
+			!plane_state->gamma_correction->is_identity &&
+			dce_use_lut(plane_state->format))
 		ipp->funcs->ipp_program_input_lut(ipp, plane_state->gamma_correction);
 
 	if (tf == NULL) {

commit 5282cbe32ea5b8008f86a743922f018287113e2c
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Mar 27 10:05:10 2018 -0400

    drm/amd/display: Change disable backlight ramp change threshold from 0 to maximum value.
    
    Instead of user set brightness with range of percentage,
    HLK test set brightness level with range of normal, this will result in
    HLK test case set brightness from 0 to 255, DC set brightness with ramp is 0,
    and disabled ramp change which will fail the HLK test.
    Fix:
    In case of unblank stream and turn on edp, change brightness level in
    stream to 0xFFFFFFFF(actural maximum level is 0xFF), use that value as
    a flag to recogonize this the case of resume from S3.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index db2d15dfb831..78bf4fae9e0d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1036,7 +1036,7 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 
 	if (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP) {
 		link->dc->hwss.edp_backlight_control(link, true);
-		stream->bl_pwm_level = 0;
+		stream->bl_pwm_level = EDP_BACKLIGHT_RAMP_DISABLE_LEVEL;
 	}
 }
 void dce110_blank_stream(struct pipe_ctx *pipe_ctx)

commit 78d5d04d118d55b6c51ca787d5debb9ad1b8a391
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Tue Mar 20 14:53:04 2018 -0400

    drm/amd/display: add delay between panel pwr off to on.
    
    As per eDP 1.4 spec, there must be at least 500ms delay
    between eDP power off and on.
    This change added time stamp when edp power off, which can
    be used to calculate duration time when edp power on.
    If duration less than 500ms, add a wait.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e8df50f30e5b..db2d15dfb831 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -849,6 +849,28 @@ void hwss_edp_power_control(
 
 	if (power_up != is_panel_powered_on(hwseq)) {
 		/* Send VBIOS command to prompt eDP panel power */
+		if (power_up) {
+			unsigned long long current_ts = dm_get_timestamp(ctx);
+			unsigned long long duration_in_ms =
+					dm_get_elapse_time_in_ns(
+							ctx,
+							current_ts,
+							link->link_trace.time_stamp.edp_poweroff) / 1000000;
+			unsigned long long wait_time_ms = 0;
+
+			/* max 500ms from LCDVDD off to on */
+			if (link->link_trace.time_stamp.edp_poweroff == 0)
+				wait_time_ms = 500;
+			else if (duration_in_ms < 500)
+				wait_time_ms = 500 - duration_in_ms;
+
+			if (wait_time_ms) {
+				msleep(wait_time_ms);
+				dm_output_to_console("%s: wait %lld ms to power on eDP.\n",
+						__func__, wait_time_ms);
+			}
+
+		}
 
 		DC_LOG_HW_RESUME_S3(
 				"%s: Panel Power action: %s\n",
@@ -862,9 +884,14 @@ void hwss_edp_power_control(
 		cntl.coherent = false;
 		cntl.lanes_number = LANE_COUNT_FOUR;
 		cntl.hpd_sel = link->link_enc->hpd_source;
-
 		bp_result = link_transmitter_control(ctx->dc_bios, &cntl);
 
+		if (!power_up)
+			/*save driver power off time stamp*/
+			link->link_trace.time_stamp.edp_poweroff = dm_get_timestamp(ctx);
+		else
+			link->link_trace.time_stamp.edp_poweron = dm_get_timestamp(ctx);
+
 		if (bp_result != BP_RESULT_OK)
 			DC_LOG_ERROR(
 					"%s: Panel Power bp_result: %d\n",

commit 5d4b05ddd826d877327ecabf987b7c61ec3cb0c5
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Thu Mar 15 13:01:46 2018 -0400

    drm/amd/display: Add Dynamic debug prints
    
    Created Macros for DC_LOG_XXX to pr_debug() & DRM_DEBUG_KMS.
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index c6212301712b..e8df50f30e5b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -70,8 +70,9 @@
 
 #define CTX \
 	hws->ctx
-#define DC_LOGGER \
-	ctx->logger
+
+#define DC_LOGGER_INIT()
+
 #define REG(reg)\
 	hws->regs->reg
 
@@ -2701,7 +2702,7 @@ static void dce110_program_front_end_for_pipe(
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
 	unsigned int i;
-	struct dc_context *ctx = dc->ctx;
+	DC_LOGGER_INIT();
 	memset(&tbl_entry, 0, sizeof(tbl_entry));
 
 	if (dc->current_state)

commit 3032deb52a6bf706657c39d6335c81ce3265974d
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Mar 14 11:19:15 2018 -0400

    drm/amd/display: Correct print types in DC_LOGS
    
    Correct the types used for printing in logs. This is needed for adding
    dynamic printing (LINUX), otherwise we get warnings.
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 075ab291cdc7..c6212301712b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2777,13 +2777,13 @@ static void dce110_program_front_end_for_pipe(
 		dc->hwss.set_output_transfer_func(pipe_ctx, pipe_ctx->stream);
 
 	DC_LOG_SURFACE(
-			"Pipe:%d 0x%x: addr hi:0x%x, "
+			"Pipe:%d %p: addr hi:0x%x, "
 			"addr low:0x%x, "
 			"src: %d, %d, %d,"
 			" %d; dst: %d, %d, %d, %d;"
 			"clip: %d, %d, %d, %d\n",
 			pipe_ctx->pipe_idx,
-			pipe_ctx->plane_state,
+			(void *) pipe_ctx->plane_state,
 			pipe_ctx->plane_state->address.grph.addr.high_part,
 			pipe_ctx->plane_state->address.grph.addr.low_part,
 			pipe_ctx->plane_state->src_rect.x,

commit 7a84077304e84d0254d505a76cc40971cb74c2de
Author: Roman Li <Roman.Li@amd.com>
Date:   Wed Mar 14 18:02:07 2018 -0400

    drm/amd/display: add assert in enable FBC
    
    Adding assert to prevent possible null deref warning.
    Only can happen under abnormal circumstances.
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index daa4673675f1..075ab291cdc7 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1801,6 +1801,9 @@ static bool should_enable_fbc(struct dc *dc,
 		}
 	}
 
+	/* Pipe context should be found */
+	ASSERT(pipe_ctx);
+
 	/* Only supports eDP */
 	if (pipe_ctx->stream->sink->link->connector_signal != SIGNAL_TYPE_EDP)
 		return false;

commit 3722c794641f91e0b960dd901d6c5d2f3cc24080
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Wed Feb 21 16:57:10 2018 -0500

    drm/amd/display: Implementing new bandwidth registers for DCE120
    
    Registers are added and defined.
    Programmed to default values.
    Stutter level watermark register is being set to calculated value.
    Urgent level registers are programmed to the same as urgency.
    The programming of the registers is not expected to have any
    functional difference in performance.
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 30dd62f0f5fa..daa4673675f1 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1539,6 +1539,7 @@ static void dce110_set_displaymarks(
 			pipe_ctx->plane_res.mi,
 			context->bw.dce.nbp_state_change_wm_ns[num_pipes],
 			context->bw.dce.stutter_exit_wm_ns[num_pipes],
+			context->bw.dce.stutter_entry_wm_ns[num_pipes],
 			context->bw.dce.urgent_wm_ns[num_pipes],
 			total_dest_line_time_ns);
 		if (i == underlay_idx) {
@@ -1564,6 +1565,7 @@ static void set_safe_displaymarks(
 		MAX_WATERMARK, MAX_WATERMARK, MAX_WATERMARK, MAX_WATERMARK };
 	struct dce_watermarks nbp_marks = {
 		SAFE_NBP_MARK, SAFE_NBP_MARK, SAFE_NBP_MARK, SAFE_NBP_MARK };
+	struct dce_watermarks min_marks = { 0, 0, 0, 0};
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (res_ctx->pipe_ctx[i].stream == NULL || res_ctx->pipe_ctx[i].plane_res.mi == NULL)
@@ -1573,6 +1575,7 @@ static void set_safe_displaymarks(
 				res_ctx->pipe_ctx[i].plane_res.mi,
 				nbp_marks,
 				max_marks,
+				min_marks,
 				max_marks,
 				MAX_WATERMARK);
 

commit 14d6f644368de1a890b747547f36cef0423fbec8
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Mar 5 10:28:34 2018 -0500

    drm/amd/display: Fixed dim around 1sec when resume from S3 (v2)
    
    root cause:
    DMCU try to perform a smoothness brightness change.Incorrect initial
    brightness level causes the 1 sec dim.
    Change:
    Cache brightness level in stream, and clear it when edp backlight on.
    If brightness level in stream is 0, set brightness with ramp value is 0.
    DMCU will set the brightness without smoothness transition.
    
    v2: squash in null pointer fix (Harry)
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 3e9cd1b7f32c..30dd62f0f5fa 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1006,8 +1006,10 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_res.stream_enc->funcs->dp_unblank(pipe_ctx->stream_res.stream_enc, &params);
 
-	if (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP)
+	if (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP) {
 		link->dc->hwss.edp_backlight_control(link, true);
+		stream->bl_pwm_level = 0;
+	}
 }
 void dce110_blank_stream(struct pipe_ctx *pipe_ctx)
 {

commit 2a54bd6e08164b80f2a322a8b1935f6ab55d1846
Author: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
Date:   Fri Mar 2 13:35:53 2018 -0500

    drm/amd/display: Use actual TG instance instead of pipe instance
    
    Signed-off-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 206569e13a2c..3e9cd1b7f32c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1132,7 +1132,7 @@ static void build_audio_output(
 static void get_surface_visual_confirm_color(const struct pipe_ctx *pipe_ctx,
 		struct tg_color *color)
 {
-	uint32_t color_value = MAX_TG_COLOR_VALUE * (4 - pipe_ctx->pipe_idx) / 4;
+	uint32_t color_value = MAX_TG_COLOR_VALUE * (4 - pipe_ctx->stream_res.tg->inst) / 4;
 
 	switch (pipe_ctx->plane_res.scl_data.format) {
 	case PIXEL_FORMAT_ARGB8888:

commit d1aaad05d0c39c8bf796e556ebbcc4ed6f4d799a
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Mar 2 17:19:27 2018 -0500

    drm/amd/display: Check for HW blocks in HWSS, rather than DC core for cursor
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 9de3d793f12e..206569e13a2c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2937,15 +2937,18 @@ void dce110_set_cursor_attribute(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_cursor_attributes *attributes = &pipe_ctx->stream->cursor_attributes;
 
-	if (pipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes)
+	if (pipe_ctx->plane_res.ipp &&
+	    pipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes)
 		pipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes(
 				pipe_ctx->plane_res.ipp, attributes);
 
-	if (pipe_ctx->plane_res.mi->funcs->set_cursor_attributes)
+	if (pipe_ctx->plane_res.mi &&
+	    pipe_ctx->plane_res.mi->funcs->set_cursor_attributes)
 		pipe_ctx->plane_res.mi->funcs->set_cursor_attributes(
 				pipe_ctx->plane_res.mi, attributes);
 
-	if (pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes)
+	if (pipe_ctx->plane_res.xfm &&
+	    pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes)
 		pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes(
 				pipe_ctx->plane_res.xfm, attributes);
 }

commit d03f3f6304336b85737d77393d55cd4d89154c72
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Tue Feb 27 15:34:30 2018 -0500

    drm/amd/display: fix check condition for edp power control
    
    Per discussion with VBIOS team, the orginal check is not correct in
    all cases on latest VBIOS. Additional check is needed. This change should
    maintain old behaviour on older VBIOS.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index ca0484894084..9de3d793f12e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -737,10 +737,14 @@ static bool is_panel_backlight_on(struct dce_hwseq *hws)
 
 static bool is_panel_powered_on(struct dce_hwseq *hws)
 {
-	uint32_t value;
+	uint32_t pwr_seq_state, dig_on, dig_on_ovrd;
+
+
+	REG_GET(LVTMA_PWRSEQ_STATE, LVTMA_PWRSEQ_TARGET_STATE_R, &pwr_seq_state);
+
+	REG_GET_2(LVTMA_PWRSEQ_CNTL, LVTMA_DIGON, &dig_on, LVTMA_DIGON_OVRD, &dig_on_ovrd);
 
-	REG_GET(LVTMA_PWRSEQ_STATE, LVTMA_PWRSEQ_TARGET_STATE_R, &value);
-	return value == 1;
+	return (pwr_seq_state == 1) || (dig_on == 1 && dig_on_ovrd == 1);
 }
 
 static enum bp_result link_transmitter_control(

commit 623a7e96cd73a46d15f64b1c5e1f4ea3548271f2
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Feb 22 16:50:39 2018 -0500

    drm/amd/display: Remove 300Mhz minimum disp clk limit.
    
    300Mhz disp clk limit was a workaround that was fixed in SMU and is no
    longer needed.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index c2041a63cccd..ca0484894084 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2106,9 +2106,6 @@ enum dc_status dce110_apply_ctx_to_hw(
 			return status;
 	}
 
-	/* pplib is notified if disp_num changed */
-	dc->hwss.set_bandwidth(dc, context, true);
-
 	/* to save power */
 	apply_min_clocks(dc, context, &clocks_state, false);
 

commit f215a57dca691c0ba1c96a8905c46c1168b66ad3
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Wed Feb 21 16:37:16 2018 -0500

    drm/amd/display: update infoframe after dig fe is turned on
    
    Before dig fe is enabled, infoframe can't be programmed. So in
    suspend resume case our infoframe programmming was not going through.
    
    This change changes the sequence so that infoframe is programmed
    after.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index f21aa04e93da..c2041a63cccd 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -684,15 +684,22 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;
 	struct dc_link *link = pipe_ctx->stream->sink->link;
 
-	/* 1. update AVI info frame (HDMI, DP)
-	 * we always need to update info frame
-	*/
+
 	uint32_t active_total_with_borders;
 	uint32_t early_control = 0;
 	struct timing_generator *tg = pipe_ctx->stream_res.tg;
 
-	/* TODOFPGA may change to hwss.update_info_frame */
+	/* For MST, there are multiply stream go to only one link.
+	 * connect DIG back_end to front_end while enable_stream and
+	 * disconnect them during disable_stream
+	 * BY this, it is logic clean to separate stream and link */
+	link->link_enc->funcs->connect_dig_be_to_fe(link->link_enc,
+						    pipe_ctx->stream_res.stream_enc->id, true);
+
+	/* update AVI info frame (HDMI, DP)*/
+	/* TODO: FPGA may change to hwss.update_info_frame */
 	dce110_update_info_frame(pipe_ctx);
+
 	/* enable early control to avoid corruption on DP monitor*/
 	active_total_with_borders =
 			timing->h_addressable
@@ -713,12 +720,8 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->stream_res.stream_enc->funcs->dp_audio_enable(pipe_ctx->stream_res.stream_enc);
 	}
 
-	/* For MST, there are multiply stream go to only one link.
-	 * connect DIG back_end to front_end while enable_stream and
-	 * disconnect them during disable_stream
-	 * BY this, it is logic clean to separate stream and link */
-	link->link_enc->funcs->connect_dig_be_to_fe(link->link_enc,
-						    pipe_ctx->stream_res.stream_enc->id, true);
+
+
 
 }
 

commit 1296423bf23c7a58133970e223b1f47ec6570308
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Feb 20 17:42:50 2018 -0500

    drm/amd/display: define DC_LOGGER for logger
    
    Created a DC_LOGGER define. This is used to
    pass the logger into the macros.
    
    Anywhere we need to use the logger we need to define
    DC_LOGGER
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 9e31f06ab4c8..f21aa04e93da 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -70,6 +70,8 @@
 
 #define CTX \
 	hws->ctx
+#define DC_LOGGER \
+	ctx->logger
 #define REG(reg)\
 	hws->regs->reg
 
@@ -816,7 +818,7 @@ void hwss_edp_wait_for_hpd_ready(
 	dal_gpio_destroy_irq(&hpd);
 
 	if (false == edp_hpd_high) {
-		DC_LOG_ERROR(ctx->logger,
+		DC_LOG_ERROR(
 				"%s: wait timed out!\n", __func__);
 	}
 }
@@ -840,7 +842,7 @@ void hwss_edp_power_control(
 	if (power_up != is_panel_powered_on(hwseq)) {
 		/* Send VBIOS command to prompt eDP panel power */
 
-		DC_LOG_HW_RESUME_S3(ctx->logger,
+		DC_LOG_HW_RESUME_S3(
 				"%s: Panel Power action: %s\n",
 				__func__, (power_up ? "On":"Off"));
 
@@ -856,11 +858,11 @@ void hwss_edp_power_control(
 		bp_result = link_transmitter_control(ctx->dc_bios, &cntl);
 
 		if (bp_result != BP_RESULT_OK)
-			DC_LOG_ERROR(ctx->logger,
+			DC_LOG_ERROR(
 					"%s: Panel Power bp_result: %d\n",
 					__func__, bp_result);
 	} else {
-		DC_LOG_HW_RESUME_S3(ctx->logger,
+		DC_LOG_HW_RESUME_S3(
 				"%s: Skipping Panel Power action: %s\n",
 				__func__, (power_up ? "On":"Off"));
 	}
@@ -886,7 +888,7 @@ void hwss_edp_backlight_control(
 	}
 
 	if (enable && is_panel_backlight_on(hws)) {
-		DC_LOG_HW_RESUME_S3(ctx->logger,
+		DC_LOG_HW_RESUME_S3(
 				"%s: panel already powered up. Do nothing.\n",
 				__func__);
 		return;
@@ -894,7 +896,7 @@ void hwss_edp_backlight_control(
 
 	/* Send VBIOS command to control eDP panel backlight */
 
-	DC_LOG_HW_RESUME_S3(ctx->logger,
+	DC_LOG_HW_RESUME_S3(
 			"%s: backlight action: %s\n",
 			__func__, (enable ? "On":"Off"));
 
@@ -2687,7 +2689,7 @@ static void dce110_program_front_end_for_pipe(
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
 	unsigned int i;
-
+	struct dc_context *ctx = dc->ctx;
 	memset(&tbl_entry, 0, sizeof(tbl_entry));
 
 	if (dc->current_state)
@@ -2762,7 +2764,7 @@ static void dce110_program_front_end_for_pipe(
 	if (pipe_ctx->plane_state->update_flags.bits.full_update)
 		dc->hwss.set_output_transfer_func(pipe_ctx, pipe_ctx->stream);
 
-	DC_LOG_SURFACE(dc->ctx->logger,
+	DC_LOG_SURFACE(
 			"Pipe:%d 0x%x: addr hi:0x%x, "
 			"addr low:0x%x, "
 			"src: %d, %d, %d,"
@@ -2785,7 +2787,7 @@ static void dce110_program_front_end_for_pipe(
 			pipe_ctx->plane_state->clip_rect.width,
 			pipe_ctx->plane_state->clip_rect.height);
 
-	DC_LOG_SURFACE(dc->ctx->logger,
+	DC_LOG_SURFACE(
 			"Pipe %d: width, height, x, y\n"
 			"viewport:%d, %d, %d, %d\n"
 			"recout:  %d, %d, %d, %d\n",

commit 2f3fd67a8af25f5b4d549c3e9cc515dbf1839ffc
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Fri Feb 16 13:57:42 2018 -0500

    drm/amd/display: Use MACROS instead of dm_logger
    
    Created MACROS for all log levels. Also Replaced
    usage of dm_logger_write to the defined MACROS
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 73e0bcd5ba8f..9e31f06ab4c8 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -816,7 +816,7 @@ void hwss_edp_wait_for_hpd_ready(
 	dal_gpio_destroy_irq(&hpd);
 
 	if (false == edp_hpd_high) {
-		dm_logger_write(ctx->logger, LOG_ERROR,
+		DC_LOG_ERROR(ctx->logger,
 				"%s: wait timed out!\n", __func__);
 	}
 }
@@ -840,7 +840,7 @@ void hwss_edp_power_control(
 	if (power_up != is_panel_powered_on(hwseq)) {
 		/* Send VBIOS command to prompt eDP panel power */
 
-		dm_logger_write(ctx->logger, LOG_HW_RESUME_S3,
+		DC_LOG_HW_RESUME_S3(ctx->logger,
 				"%s: Panel Power action: %s\n",
 				__func__, (power_up ? "On":"Off"));
 
@@ -856,11 +856,11 @@ void hwss_edp_power_control(
 		bp_result = link_transmitter_control(ctx->dc_bios, &cntl);
 
 		if (bp_result != BP_RESULT_OK)
-			dm_logger_write(ctx->logger, LOG_ERROR,
+			DC_LOG_ERROR(ctx->logger,
 					"%s: Panel Power bp_result: %d\n",
 					__func__, bp_result);
 	} else {
-		dm_logger_write(ctx->logger, LOG_HW_RESUME_S3,
+		DC_LOG_HW_RESUME_S3(ctx->logger,
 				"%s: Skipping Panel Power action: %s\n",
 				__func__, (power_up ? "On":"Off"));
 	}
@@ -886,7 +886,7 @@ void hwss_edp_backlight_control(
 	}
 
 	if (enable && is_panel_backlight_on(hws)) {
-		dm_logger_write(ctx->logger, LOG_HW_RESUME_S3,
+		DC_LOG_HW_RESUME_S3(ctx->logger,
 				"%s: panel already powered up. Do nothing.\n",
 				__func__);
 		return;
@@ -894,7 +894,7 @@ void hwss_edp_backlight_control(
 
 	/* Send VBIOS command to control eDP panel backlight */
 
-	dm_logger_write(ctx->logger, LOG_HW_RESUME_S3,
+	DC_LOG_HW_RESUME_S3(ctx->logger,
 			"%s: backlight action: %s\n",
 			__func__, (enable ? "On":"Off"));
 
@@ -2762,7 +2762,7 @@ static void dce110_program_front_end_for_pipe(
 	if (pipe_ctx->plane_state->update_flags.bits.full_update)
 		dc->hwss.set_output_transfer_func(pipe_ctx, pipe_ctx->stream);
 
-	dm_logger_write(dc->ctx->logger, LOG_SURFACE,
+	DC_LOG_SURFACE(dc->ctx->logger,
 			"Pipe:%d 0x%x: addr hi:0x%x, "
 			"addr low:0x%x, "
 			"src: %d, %d, %d,"
@@ -2785,7 +2785,7 @@ static void dce110_program_front_end_for_pipe(
 			pipe_ctx->plane_state->clip_rect.width,
 			pipe_ctx->plane_state->clip_rect.height);
 
-	dm_logger_write(dc->ctx->logger, LOG_SURFACE,
+	DC_LOG_SURFACE(dc->ctx->logger,
 			"Pipe %d: width, height, x, y\n"
 			"viewport:%d, %d, %d, %d\n"
 			"recout:  %d, %d, %d, %d\n",

commit f03628232fe93ce7af18079ce69c2dfd4c95d70f
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Feb 14 17:12:39 2018 -0500

    drm/amd/display: Clear dmps off for eDP when resume.
    
    This patch fixed secondary screen only S4 resume, eDP is unintentionally
    light up due to incorrect dpms off flag.
    
    When entering S4, dpms off flags are set to true via
    set power state. During resume, eDP is light up by vbios, so the flags
    should be changed to false to match the real state.
    By change the flag properly, eDP is able to be turned off properly as per
    OS request.
    
    This change may affect S3/S4 Shut down resume IOIC, need to verify
    those cases.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 0422c72a7579..73e0bcd5ba8f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1320,10 +1320,8 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 
 	resource_build_info_frame(pipe_ctx);
 	dce110_update_info_frame(pipe_ctx);
-	if (!pipe_ctx_old->stream) {
-		if (!pipe_ctx->stream->dpms_off)
-			core_link_enable_stream(context, pipe_ctx);
-	}
+	if (!pipe_ctx_old->stream)
+		core_link_enable_stream(context, pipe_ctx);
 
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
 

commit ec47734a6d0e82c132e3e0883f2f663f138da43a
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Fri Feb 9 12:51:01 2018 -0500

    drm/amd/display: Fix increment when sampling OTF in DCE
    
    Previously, the number of software segmets per region was reduced to 16.
    This needs to be reflected in the sampling distance (increment) used when
    translating to the hardware format.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index bc698644d42a..0422c72a7579 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -481,7 +481,7 @@ dce110_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
 
 	j = 0;
 	for (k = 0; k < (region_end - region_start); k++) {
-		increment = 32 / (1 << seg_distr[k]);
+		increment = NUMBER_SW_SEGMENTS / (1 << seg_distr[k]);
 		start_index = (region_start + k + MAX_LOW_POINT) *
 				NUMBER_SW_SEGMENTS;
 		for (i = start_index; i < start_index + NUMBER_SW_SEGMENTS;

commit 08616da569751be1b9ce6128a28930847670c80d
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Fri Feb 2 09:46:41 2018 -0500

    drm/amd/display: Use hardware max low point when sampling OTF
    
    The MAX_LOW_POINT macro should reflect the maximum low point within
    hardware. Otherwise, sampling for the hardware points from the output
    transfer function (OTF) will be incorrect.
    
    Also, fix usage of MAX_LOW_POINT accordingly.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 9e97cd74b0ec..bc698644d42a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -409,7 +409,7 @@ static bool convert_to_custom_float(struct pwl_result_data *rgb_resulted,
 	return true;
 }
 
-#define MAX_LOW_POINT      11
+#define MAX_LOW_POINT      25
 #define NUMBER_REGIONS     16
 #define NUMBER_SW_SEGMENTS 16
 
@@ -443,8 +443,8 @@ dce110_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
 		/* 16 segments
 		 * segments are from 2^-11 to 2^5
 		 */
-		region_start = -MAX_LOW_POINT;
-		region_end = NUMBER_REGIONS - MAX_LOW_POINT;
+		region_start = -11;
+		region_end = region_start + NUMBER_REGIONS;
 
 		for (i = 0; i < NUMBER_REGIONS; i++)
 			seg_distr[i] = 4;

commit 4cac1e6d2ffaddcdd054abf73c3a3c30eb659099
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Feb 2 17:35:00 2018 -0500

    drm/amd/display: Keep eDP stream enabled during boot.
    
    This path fixed specific eDP panel cold boot black screen
    due to unnecessary enable link.
    Change:
    In case of boot up with eDP, if OS is going to set mode
    on eDP, keep eDP light up, do not disable and reset corresponding
    HW.
    This change may affect dce asics and S3/S4 Resume with multi-monitor.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 5c387e8d58a2..9e97cd74b0ec 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -57,6 +57,8 @@
 #include "dce/dce_11_0_sh_mask.h"
 #include "custom_float.h"
 
+#include "atomfirmware.h"
+
 /*
  * All values are in milliseconds;
  * For eDP, after power-up/power/down,
@@ -1425,23 +1427,6 @@ static void disable_vga_and_power_gate_all_controllers(
 	}
 }
 
-static struct dc_link *get_link_for_edp(
-		struct dc *dc)
-{
-	int i;
-	struct dc_link *link = NULL;
-
-	/* check if there is an eDP panel not in use */
-	for (i = 0; i < dc->link_count; i++) {
-		if (dc->links[i]->local_sink &&
-			dc->links[i]->local_sink->sink_signal == SIGNAL_TYPE_EDP) {
-			link = dc->links[i];
-			break;
-		}
-	}
-
-	return link;
-}
 static struct dc_link *get_link_for_edp_not_in_use(
 		struct dc *dc,
 		struct dc_state *context)
@@ -1477,13 +1462,27 @@ static struct dc_link *get_link_for_edp_not_in_use(
 void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 {
 	struct dc_bios *dcb = dc->ctx->dc_bios;
-	struct dc_link *edp_link_to_turnoff = get_link_for_edp_not_in_use(dc, context);
 
-	struct dc_link *edp_link = get_link_for_edp(dc);
-	if (dcb->funcs->get_vga_enabled_displays(dc->ctx->dc_bios) != 0) {
-		if (edp_link) {
-			/*we need turn off backlight before DP_blank and encoder powered down, todo add optimization*/
-			dc->hwss.edp_backlight_control(edp_link, false);
+	/* vbios already light up eDP, so we can leverage vbios and skip eDP
+	 * programming
+	 */
+	bool can_eDP_fast_boot_optimize =
+			(dcb->funcs->get_vga_enabled_displays(dc->ctx->dc_bios) == ATOM_DISPLAY_LCD1_ACTIVE);
+
+	/* if OS doesn't light up eDP and eDP link is available, we want to disable */
+	struct dc_link *edp_link_to_turnoff = NULL;
+
+	if (can_eDP_fast_boot_optimize) {
+		edp_link_to_turnoff = get_link_for_edp_not_in_use(dc, context);
+
+		if (!edp_link_to_turnoff)
+			dc->apply_edp_fast_boot_optimization = true;
+	}
+
+	if (!dc->apply_edp_fast_boot_optimization) {
+		if (edp_link_to_turnoff) {
+			/*turn off backlight before DP_blank and encoder powered down*/
+			dc->hwss.edp_backlight_control(edp_link_to_turnoff, false);
 		}
 		/*resume from S3, no vbios posting, no need to power down again*/
 		power_down_all_hw_blocks(dc);

commit ed8462acafaf428e319548f63a0d808e436c8ea3
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Thu Feb 1 15:16:20 2018 -0500

    drm/amd/display: add force_trigger even to static screen control
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 53243d5bad9a..5c387e8d58a2 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1625,6 +1625,8 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
 		value |= 0x80;
 	if (events->cursor_update)
 		value |= 0x2;
+	if (events->force_trigger)
+		value |= 0x1;
 
 #if defined(CONFIG_DRM_AMD_DC_FBC)
 	value |= 0x84;

commit 91d4a12900347636a049038c289c3999a388e082
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Jan 31 16:45:26 2018 -0500

    drm/amd/display: boot up/S4 fix mainlink off before BL.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 54c933b94093..53243d5bad9a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1481,7 +1481,7 @@ void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 
 	struct dc_link *edp_link = get_link_for_edp(dc);
 	if (dcb->funcs->get_vga_enabled_displays(dc->ctx->dc_bios) != 0) {
-		if (edp_link_to_turnoff) {
+		if (edp_link) {
 			/*we need turn off backlight before DP_blank and encoder powered down, todo add optimization*/
 			dc->hwss.edp_backlight_control(edp_link, false);
 		}

commit 8f8372c7d17792f8b8b5fbf539f8f2b75dce0e15
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Fri Jan 19 17:55:26 2018 -0500

    drm/amd/display: Optimize regamma calculations
    
    There are several optimizations:
    1) Use predefined SRGB, don't calculate. This is the most common case.
    2) Precompute HW X points at boot since they're fixed in ColModule
    3) Precompute PQ - it never changes and is very CPU intensive in fixed pt.
    4) Reduce number of points in ColModule to 512 (32x16) from 1024. This also
    requires reducing some regions for legacy DCEs to 16 pts at most.
    
    Performance
    1) is super-fast, build_output_tf is 1-2us, down from 25000-30000.
    Programming also fast since only one reg write.
    2)+3) gives build_output_tf for PQ in ~100us range, down from ~80000-110000
    2) + 4) results in slightly over 50% improvement. It gives an idea of the
    savings when we can't use SRGB or PQ table (e.g. sdr white level > 80).
    
    There's also a bit of refactoring: renaming some stuff that was misleading
    and removing a lot of magic numbers that novices might not be able to
    understand where they come from and what they mean.
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index b87974e2a41b..54c933b94093 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -407,6 +407,10 @@ static bool convert_to_custom_float(struct pwl_result_data *rgb_resulted,
 	return true;
 }
 
+#define MAX_LOW_POINT      11
+#define NUMBER_REGIONS     16
+#define NUMBER_SW_SEGMENTS 16
+
 static bool
 dce110_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
 				      struct pwl_params *regamma_params)
@@ -421,8 +425,8 @@ dce110_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
 	struct fixed31_32 y1_min;
 	struct fixed31_32 y3_max;
 
-	int32_t segment_start, segment_end;
-	uint32_t i, j, k, seg_distr[16], increment, start_index, hw_points;
+	int32_t region_start, region_end;
+	uint32_t i, j, k, seg_distr[NUMBER_REGIONS], increment, start_index, hw_points;
 
 	if (output_tf == NULL || regamma_params == NULL || output_tf->type == TF_TYPE_BYPASS)
 		return false;
@@ -437,34 +441,20 @@ dce110_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
 		/* 16 segments
 		 * segments are from 2^-11 to 2^5
 		 */
-		segment_start = -11;
-		segment_end = 5;
-
-		seg_distr[0] = 2;
-		seg_distr[1] = 2;
-		seg_distr[2] = 2;
-		seg_distr[3] = 2;
-		seg_distr[4] = 2;
-		seg_distr[5] = 2;
-		seg_distr[6] = 3;
-		seg_distr[7] = 4;
-		seg_distr[8] = 4;
-		seg_distr[9] = 4;
-		seg_distr[10] = 4;
-		seg_distr[11] = 5;
-		seg_distr[12] = 5;
-		seg_distr[13] = 5;
-		seg_distr[14] = 5;
-		seg_distr[15] = 5;
+		region_start = -MAX_LOW_POINT;
+		region_end = NUMBER_REGIONS - MAX_LOW_POINT;
+
+		for (i = 0; i < NUMBER_REGIONS; i++)
+			seg_distr[i] = 4;
 
 	} else {
 		/* 10 segments
 		 * segment is from 2^-10 to 2^0
 		 */
-		segment_start = -10;
-		segment_end = 0;
+		region_start = -10;
+		region_end = 0;
 
-		seg_distr[0] = 3;
+		seg_distr[0] = 4;
 		seg_distr[1] = 4;
 		seg_distr[2] = 4;
 		seg_distr[3] = 4;
@@ -472,8 +462,8 @@ dce110_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
 		seg_distr[5] = 4;
 		seg_distr[6] = 4;
 		seg_distr[7] = 4;
-		seg_distr[8] = 5;
-		seg_distr[9] = 5;
+		seg_distr[8] = 4;
+		seg_distr[9] = 4;
 		seg_distr[10] = -1;
 		seg_distr[11] = -1;
 		seg_distr[12] = -1;
@@ -488,10 +478,12 @@ dce110_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
 	}
 
 	j = 0;
-	for (k = 0; k < (segment_end - segment_start); k++) {
+	for (k = 0; k < (region_end - region_start); k++) {
 		increment = 32 / (1 << seg_distr[k]);
-		start_index = (segment_start + k + 25) * 32;
-		for (i = start_index; i < start_index + 32; i += increment) {
+		start_index = (region_start + k + MAX_LOW_POINT) *
+				NUMBER_SW_SEGMENTS;
+		for (i = start_index; i < start_index + NUMBER_SW_SEGMENTS;
+				i += increment) {
 			if (j == hw_points - 1)
 				break;
 			rgb_resulted[j].red = output_tf->tf_pts.red[i];
@@ -502,15 +494,15 @@ dce110_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
 	}
 
 	/* last point */
-	start_index = (segment_end + 25) * 32;
+	start_index = (region_end + MAX_LOW_POINT) * NUMBER_SW_SEGMENTS;
 	rgb_resulted[hw_points - 1].red = output_tf->tf_pts.red[start_index];
 	rgb_resulted[hw_points - 1].green = output_tf->tf_pts.green[start_index];
 	rgb_resulted[hw_points - 1].blue = output_tf->tf_pts.blue[start_index];
 
 	arr_points[0].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
-					     dal_fixed31_32_from_int(segment_start));
+					     dal_fixed31_32_from_int(region_start));
 	arr_points[1].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
-					     dal_fixed31_32_from_int(segment_end));
+					     dal_fixed31_32_from_int(region_end));
 
 	y_r = rgb_resulted[0].red;
 	y_g = rgb_resulted[0].green;

commit c5fc7f59a71a65310e7e23b0f76057ffda02bcb0
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Jan 24 13:18:57 2018 -0500

    drm/amd/display: resume from S3 bypass power down HW block.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index bc1c4546ef69..b87974e2a41b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1484,20 +1484,21 @@ static struct dc_link *get_link_for_edp_not_in_use(
  */
 void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 {
+	struct dc_bios *dcb = dc->ctx->dc_bios;
 	struct dc_link *edp_link_to_turnoff = get_link_for_edp_not_in_use(dc, context);
 
 	struct dc_link *edp_link = get_link_for_edp(dc);
-
-	if (edp_link)
-		/*we need turn off backlight before DP_blank and encoder powered down*/
-		dc->hwss.edp_backlight_control(edp_link, false);
-
-	power_down_all_hw_blocks(dc);
-	disable_vga_and_power_gate_all_controllers(dc);
-
-	if (edp_link_to_turnoff)
-		dc->hwss.edp_power_control(edp_link_to_turnoff, false);
-
+	if (dcb->funcs->get_vga_enabled_displays(dc->ctx->dc_bios) != 0) {
+		if (edp_link_to_turnoff) {
+			/*we need turn off backlight before DP_blank and encoder powered down, todo add optimization*/
+			dc->hwss.edp_backlight_control(edp_link, false);
+		}
+		/*resume from S3, no vbios posting, no need to power down again*/
+		power_down_all_hw_blocks(dc);
+		disable_vga_and_power_gate_all_controllers(dc);
+		if (edp_link_to_turnoff)
+			dc->hwss.edp_power_control(edp_link_to_turnoff, false);
+	}
 	bios_set_scratch_acc_mode_change(dc->ctx->dc_bios);
 }
 

commit 5180d4a4766d7df4b3ffae919f867ce9598d8942
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Thu Jan 18 19:09:06 2018 -0500

    drm/amd/display: add eDP 1.2+ polling for T7
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 364b88a1d4ea..bc1c4546ef69 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -927,9 +927,13 @@ void hwss_edp_backlight_control(
 	 * Enable it in the future if necessary.
 	 */
 	/* dc_service_sleep_in_milliseconds(50); */
+		/*edp 1.2*/
+	if (cntl.action == TRANSMITTER_CONTROL_BACKLIGHT_ON)
+		edp_receiver_ready_T7(link);
 	link_transmitter_control(ctx->dc_bios, &cntl);
 	/*edp 1.2*/
-	edp_receiver_ready_T9(link);
+	if (cntl.action == TRANSMITTER_CONTROL_BACKLIGHT_OFF)
+		edp_receiver_ready_T9(link);
 }
 
 void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)
@@ -976,9 +980,6 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)
 		 */
 	}
 
-	/* blank at encoder level */
-	if (dc_is_dp_signal(pipe_ctx->stream->signal))
-		pipe_ctx->stream_res.stream_enc->funcs->dp_blank(pipe_ctx->stream_res.stream_enc);
 
 	link->link_enc->funcs->connect_dig_be_to_fe(
 			link->link_enc,

commit dc75dd707cb558b5e757d839620cf317f96bf578
Author: Roman Li <Roman.Li@amd.com>
Date:   Tue Jan 23 11:12:27 2018 -0500

    drm/amd/display: fix boot-up on vega10
    
    Fixing null-deref on Vega10 due to regression after
    'fix cursor related Pstate hang' change.
    Added null checks in setting cursor position.
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index d7a21a2462a9..364b88a1d4ea 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2928,22 +2928,27 @@ void dce110_set_cursor_position(struct pipe_ctx *pipe_ctx)
 	if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
 		pos_cpy.enable = false;
 
-	ipp->funcs->ipp_cursor_set_position(ipp, &pos_cpy, &param);
-	mi->funcs->set_cursor_position(mi, &pos_cpy, &param);
+	if (ipp->funcs->ipp_cursor_set_position)
+		ipp->funcs->ipp_cursor_set_position(ipp, &pos_cpy, &param);
+	if (mi->funcs->set_cursor_position)
+		mi->funcs->set_cursor_position(mi, &pos_cpy, &param);
 }
 
 void dce110_set_cursor_attribute(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_cursor_attributes *attributes = &pipe_ctx->stream->cursor_attributes;
 
-	pipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes(
+	if (pipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes)
+		pipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes(
 				pipe_ctx->plane_res.ipp, attributes);
 
-	pipe_ctx->plane_res.mi->funcs->set_cursor_attributes(
-			pipe_ctx->plane_res.mi, attributes);
+	if (pipe_ctx->plane_res.mi->funcs->set_cursor_attributes)
+		pipe_ctx->plane_res.mi->funcs->set_cursor_attributes(
+				pipe_ctx->plane_res.mi, attributes);
 
-	pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes(
-		pipe_ctx->plane_res.xfm, attributes);
+	if (pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes)
+		pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes(
+				pipe_ctx->plane_res.xfm, attributes);
 }
 
 static void ready_shared_resources(struct dc *dc, struct dc_state *context) {}

commit f774b339826439aaccad026e376dcec79b7cbcd1
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Thu Jan 18 19:24:27 2018 -0500

    drm/amd/display: remove unused function prototypes
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 914d39eceec7..d7a21a2462a9 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1517,7 +1517,7 @@ static uint32_t compute_pstate_blackout_duration(
 	return total_dest_line_time_ns;
 }
 
-void dce110_set_displaymarks(
+static void dce110_set_displaymarks(
 	const struct dc *dc,
 	struct dc_state *context)
 {
@@ -2299,7 +2299,7 @@ static void update_plane_addr(const struct dc *dc,
 	plane_state->status.requested_address = plane_state->address;
 }
 
-void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)
+static void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 

commit 33fd17d9125c008143c3df166e01f2e9f89f48ce
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Thu Jan 18 19:07:54 2018 -0500

    drm/amd/display: fix cursor related Pstate hang
    
    Move cursor programming to inside the OTG_MASTER_UPDATE_LOCK
    
    If graphics plane go from 1 pipe to hsplit, the cursor updates
    after mpc programming and unlock. Which means there is a window
    of time where cursor is enabled on the wrong pipe if it's on
    the right side of the screen (i.e. case where cursor need to
    move from pipe 0 to pipe 3 post split). This will cause pstate hang.
    
    Solution is to program the cursor while still locked.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index fbb84a7ccaf5..914d39eceec7 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2908,6 +2908,44 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 	}
 }
 
+void dce110_set_cursor_position(struct pipe_ctx *pipe_ctx)
+{
+	struct dc_cursor_position pos_cpy = pipe_ctx->stream->cursor_position;
+	struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
+	struct mem_input *mi = pipe_ctx->plane_res.mi;
+	struct dc_cursor_mi_param param = {
+		.pixel_clk_khz = pipe_ctx->stream->timing.pix_clk_khz,
+		.ref_clk_khz = pipe_ctx->stream->ctx->dc->res_pool->ref_clock_inKhz,
+		.viewport_x_start = pipe_ctx->plane_res.scl_data.viewport.x,
+		.viewport_width = pipe_ctx->plane_res.scl_data.viewport.width,
+		.h_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.horz
+	};
+
+	if (pipe_ctx->plane_state->address.type
+			== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)
+		pos_cpy.enable = false;
+
+	if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
+		pos_cpy.enable = false;
+
+	ipp->funcs->ipp_cursor_set_position(ipp, &pos_cpy, &param);
+	mi->funcs->set_cursor_position(mi, &pos_cpy, &param);
+}
+
+void dce110_set_cursor_attribute(struct pipe_ctx *pipe_ctx)
+{
+	struct dc_cursor_attributes *attributes = &pipe_ctx->stream->cursor_attributes;
+
+	pipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes(
+				pipe_ctx->plane_res.ipp, attributes);
+
+	pipe_ctx->plane_res.mi->funcs->set_cursor_attributes(
+			pipe_ctx->plane_res.mi, attributes);
+
+	pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes(
+		pipe_ctx->plane_res.xfm, attributes);
+}
+
 static void ready_shared_resources(struct dc *dc, struct dc_state *context) {}
 
 static void optimize_shared_resources(struct dc *dc) {}
@@ -2951,6 +2989,8 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.edp_backlight_control = hwss_edp_backlight_control,
 	.edp_power_control = hwss_edp_power_control,
 	.edp_wait_for_hpd_ready = hwss_edp_wait_for_hpd_ready,
+	.set_cursor_position = dce110_set_cursor_position,
+	.set_cursor_attribute = dce110_set_cursor_attribute
 };
 
 void dce110_hw_sequencer_construct(struct dc *dc)

commit 69b9723a81e74e517048e1523a24d76fe8e2aef2
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Thu Jan 18 12:53:04 2018 -0500

    drm/amd/display: wait for T9 after backlight off mainlink blank.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index d293cafb6418..fbb84a7ccaf5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -928,6 +928,8 @@ void hwss_edp_backlight_control(
 	 */
 	/* dc_service_sleep_in_milliseconds(50); */
 	link_transmitter_control(ctx->dc_bios, &cntl);
+	/*edp 1.2*/
+	edp_receiver_ready_T9(link);
 }
 
 void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)

commit 9557080196d7c328aa514d2303a2fd7a985c5c2d
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Fri Jan 12 15:47:48 2018 -0500

    drm/amd/display: Fix unused variable compilation error
    
    Fix:
    
    drivers/gpu/drm/amd/amdgpu/../dal-dev/dc/dce110/dce110_hw_sequencer.c:
    In function dce110_blank_stream:
    drivers/gpu/drm/amd/amdgpu/../dal-dev/dc/dce110/dce110_hw_sequencer.c:1008:31:
    error: unused variable params [-Werror=unused-variable]
      struct encoder_unblank_param params = { { 0 } };
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index cb20d2c2a6ab..d293cafb6418 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1005,7 +1005,6 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 }
 void dce110_blank_stream(struct pipe_ctx *pipe_ctx)
 {
-	struct encoder_unblank_param params = { { 0 } };
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->sink->link;
 

commit 41b497421a1f07ab99814da740984f907747120b
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Thu Jan 11 15:31:26 2018 -0500

    drm/amd/display: eDP sequence BL off first then DP blank.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 65a584523ac0..cb20d2c2a6ab 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -989,12 +989,31 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 		struct dc_link_settings *link_settings)
 {
 	struct encoder_unblank_param params = { { 0 } };
+	struct dc_stream_state *stream = pipe_ctx->stream;
+	struct dc_link *link = stream->sink->link;
 
 	/* only 3 items below are used by unblank */
 	params.pixel_clk_khz =
 		pipe_ctx->stream->timing.pix_clk_khz;
 	params.link_settings.link_rate = link_settings->link_rate;
-	pipe_ctx->stream_res.stream_enc->funcs->dp_unblank(pipe_ctx->stream_res.stream_enc, &params);
+
+	if (dc_is_dp_signal(pipe_ctx->stream->signal))
+		pipe_ctx->stream_res.stream_enc->funcs->dp_unblank(pipe_ctx->stream_res.stream_enc, &params);
+
+	if (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP)
+		link->dc->hwss.edp_backlight_control(link, true);
+}
+void dce110_blank_stream(struct pipe_ctx *pipe_ctx)
+{
+	struct encoder_unblank_param params = { { 0 } };
+	struct dc_stream_state *stream = pipe_ctx->stream;
+	struct dc_link *link = stream->sink->link;
+
+	if (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP)
+		link->dc->hwss.edp_backlight_control(link, false);
+
+	if (dc_is_dp_signal(pipe_ctx->stream->signal))
+		pipe_ctx->stream_res.stream_enc->funcs->dp_blank(pipe_ctx->stream_res.stream_enc);
 }
 
 
@@ -2911,6 +2930,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.enable_stream = dce110_enable_stream,
 	.disable_stream = dce110_disable_stream,
 	.unblank_stream = dce110_unblank_stream,
+	.blank_stream = dce110_blank_stream,
 	.enable_display_pipe_clock_gating = enable_display_pipe_clock_gating,
 	.enable_display_power_gating = dce110_enable_display_power_gating,
 	.disable_plane = dce110_power_down_fe,

commit 7c357e61e21bf98dc0a892cbc587240c6f2b2432
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Tue Jan 9 18:37:04 2018 -0500

    drm/amd/display: dpms off mute az audio endpoint only.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index f982f23aa0da..65a584523ac0 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -947,7 +947,11 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)
 	pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
 			pipe_ctx->stream_res.stream_enc, true);
 	if (pipe_ctx->stream_res.audio) {
-		pipe_ctx->stream_res.audio->funcs->az_disable(pipe_ctx->stream_res.audio);
+		if (option != KEEP_ACQUIRED_RESOURCE ||
+				!dc->debug.az_endpoint_mute_only) {
+			/*only disalbe az_endpoint if power down or free*/
+			pipe_ctx->stream_res.audio->funcs->az_disable(pipe_ctx->stream_res.audio);
+		}
 
 		if (dc_is_dp_signal(pipe_ctx->stream->signal))
 			pipe_ctx->stream_res.stream_enc->funcs->dp_audio_disable(

commit cf1835f03ffb3b547d27d44999bffe836f29d360
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Jan 8 16:47:39 2018 -0500

    drm/amd/display: fix backlight not off at resume from S4
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index d036d1da03e3..f982f23aa0da 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -914,6 +914,7 @@ void hwss_edp_backlight_control(
 	/*todo: unhardcode*/
 	cntl.lanes_number = LANE_COUNT_FOUR;
 	cntl.hpd_sel = link->link_enc->hpd_source;
+	cntl.signal = SIGNAL_TYPE_EDP;
 
 	/* For eDP, the following delays might need to be considered
 	 * after link training completed:
@@ -1407,7 +1408,24 @@ static void disable_vga_and_power_gate_all_controllers(
 	}
 }
 
-static struct dc_link *get_link_for_eDP_not_in_use(
+static struct dc_link *get_link_for_edp(
+		struct dc *dc)
+{
+	int i;
+	struct dc_link *link = NULL;
+
+	/* check if there is an eDP panel not in use */
+	for (i = 0; i < dc->link_count; i++) {
+		if (dc->links[i]->local_sink &&
+			dc->links[i]->local_sink->sink_signal == SIGNAL_TYPE_EDP) {
+			link = dc->links[i];
+			break;
+		}
+	}
+
+	return link;
+}
+static struct dc_link *get_link_for_edp_not_in_use(
 		struct dc *dc,
 		struct dc_state *context)
 {
@@ -1441,16 +1459,19 @@ static struct dc_link *get_link_for_eDP_not_in_use(
  */
 void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 {
-	struct dc_link *eDP_link_to_turnoff = get_link_for_eDP_not_in_use(dc, context);
+	struct dc_link *edp_link_to_turnoff = get_link_for_edp_not_in_use(dc, context);
+
+	struct dc_link *edp_link = get_link_for_edp(dc);
 
-	if (eDP_link_to_turnoff)
-		dc->hwss.edp_backlight_control(eDP_link_to_turnoff, false);
+	if (edp_link)
+		/*we need turn off backlight before DP_blank and encoder powered down*/
+		dc->hwss.edp_backlight_control(edp_link, false);
 
 	power_down_all_hw_blocks(dc);
 	disable_vga_and_power_gate_all_controllers(dc);
 
-	if (eDP_link_to_turnoff)
-		dc->hwss.edp_power_control(eDP_link_to_turnoff, false);
+	if (edp_link_to_turnoff)
+		dc->hwss.edp_power_control(edp_link_to_turnoff, false);
 
 	bios_set_scratch_acc_mode_change(dc->ctx->dc_bios);
 }

commit bc373a890f14958c98e476e38b0a71adab3fc733
Author: Roman Li <Roman.Li@amd.com>
Date:   Fri Dec 29 17:45:03 2017 -0500

    drm/amd/display: Fix null-derefs on non-dcn builds
    
    Fixing regression introduced by
    'Use real BE and FE index to program regs.'
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 58823bafdbe6..d036d1da03e3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2819,7 +2819,8 @@ static void dce110_apply_ctx_for_surface(
 
 static void dce110_power_down_fe(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
-	int fe_idx = pipe_ctx->plane_res.mi->inst;
+	int fe_idx = pipe_ctx->plane_res.mi ?
+		pipe_ctx->plane_res.mi->inst : pipe_ctx->pipe_idx;
 
 	/* Do not power down fe when stream is active on dce*/
 	if (dc->current_state->res_ctx.pipe_ctx[fe_idx].stream)

commit 405c50a07d3f67971d3e01cec83dbdcd5bdd529e
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Wed Dec 20 10:07:42 2017 -0500

    drm/amd/display: Fix check for setting input TF
    
    We no longer change the plane state pointer for full updates, and as
    such, we weren't setting the input transfer function and programming the
    degamma registers when we are supposed to. Check for a full update, an
    input TF change, or a gamma change in the update flags instead to correct
    this.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index f415f382bb36..58823bafdbe6 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -275,7 +275,7 @@ dce110_set_input_transfer_func(struct pipe_ctx *pipe_ctx,
 	build_prescale_params(&prescale_params, plane_state);
 	ipp->funcs->ipp_program_prescale(ipp, &prescale_params);
 
-	if (plane_state->gamma_correction && dce_use_lut(plane_state))
+	if (plane_state->gamma_correction && dce_use_lut(plane_state->format))
 		ipp->funcs->ipp_program_input_lut(ipp, plane_state->gamma_correction);
 
 	if (tf == NULL) {
@@ -2648,7 +2648,6 @@ static void dce110_program_front_end_for_pipe(
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
-	struct pipe_ctx *cur_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
 	unsigned int i;
 
 	memset(&tbl_entry, 0, sizeof(tbl_entry));
@@ -2717,10 +2716,13 @@ static void dce110_program_front_end_for_pipe(
 				plane_state->rotation);
 
 	/* Moved programming gamma from dc to hwss */
-	if (cur_pipe_ctx->plane_state != pipe_ctx->plane_state) {
+	if (pipe_ctx->plane_state->update_flags.bits.full_update ||
+			pipe_ctx->plane_state->update_flags.bits.in_transfer_func_change ||
+			pipe_ctx->plane_state->update_flags.bits.gamma_change)
 		dc->hwss.set_input_transfer_func(pipe_ctx, pipe_ctx->plane_state);
+
+	if (pipe_ctx->plane_state->update_flags.bits.full_update)
 		dc->hwss.set_output_transfer_func(pipe_ctx, pipe_ctx->stream);
-	}
 
 	dm_logger_write(dc->ctx->logger, LOG_SURFACE,
 			"Pipe:%d 0x%x: addr hi:0x%x, "

commit e07f541f50a31541f761300aa8bf6e3008ac448b
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Dec 19 16:47:02 2017 -0500

    drm/amd/display: Use real BE and FE index to program regs.
    
    In case of some pipes are fused, pipe_idx should not
    be used to program pipe regs. Instead of that, BE and FE
    inst number should be used for reg index.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 57bc994c7a28..f415f382bb36 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -625,7 +625,7 @@ static enum dc_status bios_parser_crtc_source_select(
 	const struct dc_sink *sink = pipe_ctx->stream->sink;
 
 	crtc_source_select.engine_id = pipe_ctx->stream_res.stream_enc->id;
-	crtc_source_select.controller_id = pipe_ctx->pipe_idx + 1;
+	crtc_source_select.controller_id = pipe_ctx->stream_res.tg->inst + 1;
 	/*TODO: Need to un-hardcode color depth, dp_audio and account for
 	 * the case where signal and sink signal is different (translator
 	 * encoder)*/
@@ -1091,7 +1091,7 @@ static void build_audio_output(
 
 	audio_output->pll_info.dto_source =
 		translate_to_dto_source(
-			pipe_ctx->pipe_idx + 1);
+			pipe_ctx->stream_res.tg->inst + 1);
 
 	/* TODO hard code to enable for now. Need get from stream */
 	audio_output->pll_info.ss_enabled = true;
@@ -2147,7 +2147,7 @@ static void program_surface_visibility(const struct dc *dc,
 	} else if (!pipe_ctx->plane_state->visible)
 		blank_target = true;
 
-	dce_set_blender_mode(dc->hwseq, pipe_ctx->pipe_idx, blender_mode);
+	dce_set_blender_mode(dc->hwseq, pipe_ctx->stream_res.tg->inst, blender_mode);
 	pipe_ctx->stream_res.tg->funcs->set_blank(pipe_ctx->stream_res.tg, blank_target);
 
 }
@@ -2189,7 +2189,7 @@ static void set_plane_config(
 	memset(&tbl_entry, 0, sizeof(tbl_entry));
 	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
 
-	dce_enable_fe_clock(dc->hwseq, pipe_ctx->pipe_idx, true);
+	dce_enable_fe_clock(dc->hwseq, mi->inst, true);
 
 	set_default_colors(pipe_ctx);
 	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment == true) {
@@ -2495,7 +2495,7 @@ void dce110_fill_display_configs(
 
 		num_cfgs++;
 		cfg->signal = pipe_ctx->stream->signal;
-		cfg->pipe_idx = pipe_ctx->pipe_idx;
+		cfg->pipe_idx = pipe_ctx->stream_res.tg->inst;
 		cfg->src_height = stream->src.height;
 		cfg->src_width = stream->src.width;
 		cfg->ddi_channel_mapping =
@@ -2659,7 +2659,7 @@ static void dce110_program_front_end_for_pipe(
 	memset(&adjust, 0, sizeof(adjust));
 	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
 
-	dce_enable_fe_clock(dc->hwseq, pipe_ctx->pipe_idx, true);
+	dce_enable_fe_clock(dc->hwseq, mi->inst, true);
 
 	set_default_colors(pipe_ctx);
 	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment
@@ -2817,7 +2817,7 @@ static void dce110_apply_ctx_for_surface(
 
 static void dce110_power_down_fe(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
-	int fe_idx = pipe_ctx->pipe_idx;
+	int fe_idx = pipe_ctx->plane_res.mi->inst;
 
 	/* Do not power down fe when stream is active on dce*/
 	if (dc->current_state->res_ctx.pipe_ctx[fe_idx].stream)

commit 25292028d74b4b13ab512bcac60a5e02e2a48b90
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Dec 19 11:51:40 2017 -0500

    drm/amd/display: Disable eDP with a proper sequence.
    
    Proper sequence should be:
    disable backlight
    dp blank
    disable output
    edp power off
    
    In enable accelatate mode, all the encoder and controller
    are disabled, so move disable eDP to the function is the
    easiest way to implement.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index d046212708b5..57bc994c7a28 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1407,6 +1407,31 @@ static void disable_vga_and_power_gate_all_controllers(
 	}
 }
 
+static struct dc_link *get_link_for_eDP_not_in_use(
+		struct dc *dc,
+		struct dc_state *context)
+{
+	int i;
+	struct dc_link *link = NULL;
+
+	/* check if eDP panel is suppose to be set mode, if yes, no need to disable */
+	for (i = 0; i < context->stream_count; i++) {
+		if (context->streams[i]->signal == SIGNAL_TYPE_EDP)
+			return NULL;
+	}
+
+	/* check if there is an eDP panel not in use */
+	for (i = 0; i < dc->link_count; i++) {
+		if (dc->links[i]->local_sink &&
+			dc->links[i]->local_sink->sink_signal == SIGNAL_TYPE_EDP) {
+			link = dc->links[i];
+			break;
+		}
+	}
+
+	return link;
+}
+
 /**
  * When ASIC goes from VBIOS/VGA mode to driver/accelerated mode we need:
  *  1. Power down all DC HW blocks
@@ -1414,11 +1439,19 @@ static void disable_vga_and_power_gate_all_controllers(
  *  3. Enable power gating for controller
  *  4. Set acc_mode_change bit (VBIOS will clear this bit when going to FSDOS)
  */
-void dce110_enable_accelerated_mode(struct dc *dc)
+void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 {
-	power_down_all_hw_blocks(dc);
+	struct dc_link *eDP_link_to_turnoff = get_link_for_eDP_not_in_use(dc, context);
 
+	if (eDP_link_to_turnoff)
+		dc->hwss.edp_backlight_control(eDP_link_to_turnoff, false);
+
+	power_down_all_hw_blocks(dc);
 	disable_vga_and_power_gate_all_controllers(dc);
+
+	if (eDP_link_to_turnoff)
+		dc->hwss.edp_power_control(eDP_link_to_turnoff, false);
+
 	bios_set_scratch_acc_mode_change(dc->ctx->dc_bios);
 }
 

commit 146a9f636824dedb6b5722bd4361cc111624d053
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Fri Dec 15 17:58:45 2017 -0500

    drm/amd/display: Pass full 3x4 remap matrix for color transform
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 1a289381c62c..d046212708b5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2121,6 +2121,7 @@ static void program_surface_visibility(const struct dc *dc,
 
 static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 {
+	int i = 0;
 	struct xfm_grph_csc_adjustment adjust;
 	memset(&adjust, 0, sizeof(adjust));
 	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
@@ -2128,33 +2129,10 @@ static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 
 	if (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {
 		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
-		adjust.temperature_matrix[0] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[0];
-		adjust.temperature_matrix[1] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[1];
-		adjust.temperature_matrix[2] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[2];
-		adjust.temperature_matrix[3] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[4];
-		adjust.temperature_matrix[4] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[5];
-		adjust.temperature_matrix[5] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[6];
-		adjust.temperature_matrix[6] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[8];
-		adjust.temperature_matrix[7] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[9];
-		adjust.temperature_matrix[8] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[10];
+
+		for (i = 0; i < CSC_TEMPERATURE_MATRIX_SIZE; i++)
+			adjust.temperature_matrix[i] =
+				pipe_ctx->stream->gamut_remap_matrix.matrix[i];
 	}
 
 	pipe_ctx->plane_res.xfm->funcs->transform_set_gamut_remap(pipe_ctx->plane_res.xfm, &adjust);
@@ -2195,33 +2173,10 @@ static void set_plane_config(
 
 	if (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {
 		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
-		adjust.temperature_matrix[0] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[0];
-		adjust.temperature_matrix[1] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[1];
-		adjust.temperature_matrix[2] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[2];
-		adjust.temperature_matrix[3] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[4];
-		adjust.temperature_matrix[4] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[5];
-		adjust.temperature_matrix[5] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[6];
-		adjust.temperature_matrix[6] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[8];
-		adjust.temperature_matrix[7] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[9];
-		adjust.temperature_matrix[8] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[10];
+
+		for (i = 0; i < CSC_TEMPERATURE_MATRIX_SIZE; i++)
+			adjust.temperature_matrix[i] =
+				pipe_ctx->stream->gamut_remap_matrix.matrix[i];
 	}
 
 	pipe_ctx->plane_res.xfm->funcs->transform_set_gamut_remap(pipe_ctx->plane_res.xfm, &adjust);
@@ -2689,33 +2644,10 @@ static void dce110_program_front_end_for_pipe(
 
 	if (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {
 		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
-		adjust.temperature_matrix[0] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[0];
-		adjust.temperature_matrix[1] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[1];
-		adjust.temperature_matrix[2] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[2];
-		adjust.temperature_matrix[3] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[4];
-		adjust.temperature_matrix[4] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[5];
-		adjust.temperature_matrix[5] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[6];
-		adjust.temperature_matrix[6] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[8];
-		adjust.temperature_matrix[7] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[9];
-		adjust.temperature_matrix[8] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[10];
+
+		for (i = 0; i < CSC_TEMPERATURE_MATRIX_SIZE; i++)
+			adjust.temperature_matrix[i] =
+				pipe_ctx->stream->gamut_remap_matrix.matrix[i];
 	}
 
 	pipe_ctx->plane_res.xfm->funcs->transform_set_gamut_remap(pipe_ctx->plane_res.xfm, &adjust);

commit 3bc4aaa95204669e39b22849f2f0eb38f0212fc2
Author: Roman Li <Roman.Li@amd.com>
Date:   Fri Dec 15 17:18:19 2017 -0500

    drm/amd/display: Fix FBC topology change
    
    With FBC enabled there was a potential null-deref
    on topology change due to hardcorded pipe index.
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 2ecb3482452d..1a289381c62c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1690,9 +1690,13 @@ static void apply_min_clocks(
  *  Check if FBC can be enabled
  */
 static bool should_enable_fbc(struct dc *dc,
-			      struct dc_state *context)
+			      struct dc_state *context,
+			      uint32_t *pipe_idx)
 {
-	struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[0];
+	uint32_t i;
+	struct pipe_ctx *pipe_ctx = NULL;
+	struct resource_context *res_ctx = &context->res_ctx;
+
 
 	ASSERT(dc->fbc_compressor);
 
@@ -1704,6 +1708,14 @@ static bool should_enable_fbc(struct dc *dc,
 	if (context->stream_count != 1)
 		return false;
 
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		if (res_ctx->pipe_ctx[i].stream) {
+			pipe_ctx = &res_ctx->pipe_ctx[i];
+			*pipe_idx = i;
+			break;
+		}
+	}
+
 	/* Only supports eDP */
 	if (pipe_ctx->stream->sink->link->connector_signal != SIGNAL_TYPE_EDP)
 		return false;
@@ -1729,11 +1741,14 @@ static bool should_enable_fbc(struct dc *dc,
 static void enable_fbc(struct dc *dc,
 		       struct dc_state *context)
 {
-	if (should_enable_fbc(dc, context)) {
+	uint32_t pipe_idx = 0;
+
+	if (should_enable_fbc(dc, context, &pipe_idx)) {
 		/* Program GRPH COMPRESSED ADDRESS and PITCH */
 		struct compr_addr_and_pitch_params params = {0, 0, 0};
 		struct compressor *compr = dc->fbc_compressor;
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[0];
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[pipe_idx];
+
 
 		params.source_view_width = pipe_ctx->stream->timing.h_addressable;
 		params.source_view_height = pipe_ctx->stream->timing.v_addressable;

commit 6d5d346f0462c1921877b260379115d21f6269c9
Author: Ken Chalmers <ken.chalmers@amd.com>
Date:   Thu Dec 14 12:44:39 2017 -0500

    drm/amd/display: Eliminate several Maximus-specific code paths
    
    This allows Maximus emulation to more closely mirror actual silicon
    execution.
    
    * Enable pool->base.display_clock creation on Maximus.
    * Enable rest of dce110_apply_ctx_to_hw on Maximus.
    * Remove apply_ctx_to_hw_fpga (no longer necessary with the full
      dce110_apply_ctx_to_hw enabled).
    * Disable the dmcu->funcs->set_psr_wait_loop call in dce112_set_clock
      for Maximus (this was the only fix-up necessary after enabling
      dce110_apply_ctx_to_hw; everything else works unmodified on
      Maximus).
    
    Signed-off-by: Ken Chalmers <ken.chalmers@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 86cdd7b4811f..2ecb3482452d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1748,36 +1748,6 @@ static void enable_fbc(struct dc *dc,
 }
 #endif
 
-static enum dc_status apply_ctx_to_hw_fpga(
-		struct dc *dc,
-		struct dc_state *context)
-{
-	enum dc_status status = DC_ERROR_UNEXPECTED;
-	int i;
-
-	for (i = 0; i < MAX_PIPES; i++) {
-		struct pipe_ctx *pipe_ctx_old =
-				&dc->current_state->res_ctx.pipe_ctx[i];
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-
-		if (pipe_ctx->stream == NULL)
-			continue;
-
-		if (pipe_ctx->stream == pipe_ctx_old->stream)
-			continue;
-
-		status = apply_single_controller_ctx_to_hw(
-				pipe_ctx,
-				context,
-				dc);
-
-		if (status != DC_OK)
-			return status;
-	}
-
-	return DC_OK;
-}
-
 static void dce110_reset_hw_ctx_wrap(
 		struct dc *dc,
 		struct dc_state *context)
@@ -1847,11 +1817,6 @@ enum dc_status dce110_apply_ctx_to_hw(
 	if (context->stream_count <= 0)
 		return DC_OK;
 
-	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
-		apply_ctx_to_hw_fpga(dc, context);
-		return DC_OK;
-	}
-
 	/* Apply new context */
 	dcb->funcs->set_scratch_critical_state(dcb, true);
 

commit 9c6569dea07cd730d424b84c8348d19bb4bb2ff0
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Dec 1 09:49:46 2017 -0500

    drm/amd/display: Call validate_fbc should_enable_fbc
    
    validate_fbc never fails a modeset. It's simply used to decide whether
    to use FBC or not. Calling it validate_fbc might be confusing to some so
    rename it to should_enable_fbc.
    
    With that let's also remove the DC_STATUS return code and return bool
    and make enable_fbc a void function since we never check it's return
    value and probably never want to anyways.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index f0002d63eb63..86cdd7b4811f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1689,60 +1689,54 @@ static void apply_min_clocks(
 /*
  *  Check if FBC can be enabled
  */
-static enum dc_status validate_fbc(struct dc *dc,
-		struct dc_state *context)
+static bool should_enable_fbc(struct dc *dc,
+			      struct dc_state *context)
 {
-	struct pipe_ctx *pipe_ctx =
-			      &context->res_ctx.pipe_ctx[0];
+	struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[0];
 
 	ASSERT(dc->fbc_compressor);
 
 	/* FBC memory should be allocated */
 	if (!dc->ctx->fbc_gpu_addr)
-		return DC_ERROR_UNEXPECTED;
+		return false;
 
 	/* Only supports single display */
 	if (context->stream_count != 1)
-		return DC_ERROR_UNEXPECTED;
+		return false;
 
 	/* Only supports eDP */
 	if (pipe_ctx->stream->sink->link->connector_signal != SIGNAL_TYPE_EDP)
-		return DC_ERROR_UNEXPECTED;
+		return false;
 
 	/* PSR should not be enabled */
 	if (pipe_ctx->stream->sink->link->psr_enabled)
-		return DC_ERROR_UNEXPECTED;
+		return false;
 
 	/* Nothing to compress */
 	if (!pipe_ctx->plane_state)
-		return DC_ERROR_UNEXPECTED;
+		return false;
 
 	/* Only for non-linear tiling */
 	if (pipe_ctx->plane_state->tiling_info.gfx8.array_mode == DC_ARRAY_LINEAR_GENERAL)
-		return DC_ERROR_UNEXPECTED;
+		return false;
 
-	return DC_OK;
+	return true;
 }
 
 /*
  *  Enable FBC
  */
-static enum dc_status enable_fbc(struct dc *dc,
-		struct dc_state *context)
+static void enable_fbc(struct dc *dc,
+		       struct dc_state *context)
 {
-	enum dc_status status = validate_fbc(dc, context);
-
-	if (status == DC_OK) {
+	if (should_enable_fbc(dc, context)) {
 		/* Program GRPH COMPRESSED ADDRESS and PITCH */
 		struct compr_addr_and_pitch_params params = {0, 0, 0};
 		struct compressor *compr = dc->fbc_compressor;
-		struct pipe_ctx *pipe_ctx =
-				      &context->res_ctx.pipe_ctx[0];
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[0];
 
-		params.source_view_width =
-				pipe_ctx->stream->timing.h_addressable;
-		params.source_view_height =
-				pipe_ctx->stream->timing.v_addressable;
+		params.source_view_width = pipe_ctx->stream->timing.h_addressable;
+		params.source_view_height = pipe_ctx->stream->timing.v_addressable;
 
 		compr->compr_surface_address.quad_part = dc->ctx->fbc_gpu_addr;
 
@@ -1751,7 +1745,6 @@ static enum dc_status enable_fbc(struct dc *dc,
 
 		compr->funcs->enable_fbc(compr, &params);
 	}
-	return status;
 }
 #endif
 

commit 4486c3fcdff71381871f418b7bcd3a496cd632b1
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Nov 27 09:30:48 2017 -0500

    drm/amd/display: Remove dead enable_plane function definition and call
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 80d36610c302..f0002d63eb63 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2053,9 +2053,6 @@ enum dc_status dce110_apply_ctx_to_hw(
 				context,
 				dc);
 
-		if (dc->hwss.enable_plane)
-			dc->hwss.enable_plane(dc, pipe_ctx, context);
-
 		if (DC_OK != status)
 			return status;
 	}

commit 5b92d9d409e742ca09a4cb924e3f781eddbf7d81
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Nov 22 21:05:55 2017 -0500

    drm/amd/display: Remove redundant NULL check in DCE11 HWSS
    
    We already check this a couple lines earlier.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index dd8386778361..80d36610c302 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2017,8 +2017,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 		if (pipe_ctx->stream == pipe_ctx_old->stream)
 			continue;
 
-		if (pipe_ctx->stream && pipe_ctx_old->stream
-				&& !pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
+		if (pipe_ctx_old->stream && !pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
 			continue;
 
 		if (pipe_ctx->top_pipe)

commit 904623ee5936e2226009b2f238f28781aecd2565
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Nov 24 16:31:03 2017 -0500

    drm/amd/display: Move wait for hpd ready out from edp power control.
    
    It may take over 200ms for wait hpd ready. To optimize the resume time,
    we can power on eDP in init_hw, wait for hpd ready when doing link
    training.
    
    also create separate eDP enable function to make sure eDP is powered up
    before doing and DPCD access, as HPD low will result in DPDC transaction
    failure.
    
    After optimization,
    setpowerstate 145ms -> 9.8ms,
    DPMS 387ms -> 18.9ms
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 21fc27aab909..dd8386778361 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -870,8 +870,6 @@ void hwss_edp_power_control(
 				"%s: Skipping Panel Power action: %s\n",
 				__func__, (power_up ? "On":"Off"));
 	}
-
-	hwss_edp_wait_for_hpd_ready(link, true);
 }
 
 /*todo: cloned in stream enc, fix*/
@@ -972,11 +970,9 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)
 	}
 
 	/* blank at encoder level */
-	if (dc_is_dp_signal(pipe_ctx->stream->signal)) {
-		if (pipe_ctx->stream->sink->link->connector_signal == SIGNAL_TYPE_EDP)
-			hwss_edp_backlight_control(link, false);
+	if (dc_is_dp_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_res.stream_enc->funcs->dp_blank(pipe_ctx->stream_res.stream_enc);
-	}
+
 	link->link_enc->funcs->connect_dig_be_to_fe(
 			link->link_enc,
 			pipe_ctx->stream_res.stream_enc->id,
@@ -988,15 +984,12 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 		struct dc_link_settings *link_settings)
 {
 	struct encoder_unblank_param params = { { 0 } };
-	struct dc_link *link = pipe_ctx->stream->sink->link;
 
 	/* only 3 items below are used by unblank */
 	params.pixel_clk_khz =
 		pipe_ctx->stream->timing.pix_clk_khz;
 	params.link_settings.link_rate = link_settings->link_rate;
 	pipe_ctx->stream_res.stream_enc->funcs->dp_unblank(pipe_ctx->stream_res.stream_enc, &params);
-	if (link->connector_signal == SIGNAL_TYPE_EDP)
-		hwss_edp_backlight_control(link, true);
 }
 
 
@@ -1342,10 +1335,8 @@ static void power_down_encoders(struct dc *dc)
 
 			if (!dc->links[i]->wa_flags.dp_keep_receiver_powered)
 				dp_receiver_power_ctrl(dc->links[i], false);
-			if (connector_id == CONNECTOR_ID_EDP) {
+			if (connector_id == CONNECTOR_ID_EDP)
 				signal = SIGNAL_TYPE_EDP;
-				hwss_edp_backlight_control(dc->links[i], false);
-			}
 		}
 
 		dc->links[i]->link_enc->funcs->disable_output(
@@ -2976,6 +2967,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.pplib_apply_display_requirements = pplib_apply_display_requirements,
 	.edp_backlight_control = hwss_edp_backlight_control,
 	.edp_power_control = hwss_edp_power_control,
+	.edp_wait_for_hpd_ready = hwss_edp_wait_for_hpd_ready,
 };
 
 void dce110_hw_sequencer_construct(struct dc *dc)

commit 4d06ccd0af1ea5f3a3b74ca421b9cd9840d5e5c6
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Nov 10 12:12:40 2017 -0500

    drm/amd/display: Fix access of wrong array element TF format conversion
    
    Found by smatch:
    drivers/gpu/drm/amd/amdgpu/../display/dc/dce110/dce110_hw_sequencer.c:357
    convert_to_custom_float() error: buffer overflow 'arr_points' 2 <= 2
    drivers/gpu/drm/amd/amdgpu/../display/dc/dce110/dce110_hw_sequencer.c:358
    convert_to_custom_float() warn: buffer overflow 'arr_points' 2 <= 2
    
    Regression:
    drm/amd/display: Remove extra arr_points element
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 981bcd291602..21fc27aab909 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -354,8 +354,8 @@ static bool convert_to_custom_float(struct pwl_result_data *rgb_resulted,
 		return false;
 	}
 
-	if (!convert_to_custom_float_format(arr_points[2].slope, &fmt,
-					    &arr_points[2].custom_float_slope)) {
+	if (!convert_to_custom_float_format(arr_points[1].slope, &fmt,
+					    &arr_points[1].custom_float_slope)) {
 		BREAK_TO_DEBUGGER();
 		return false;
 	}

commit 34996173c88ca69f276eb2979586016fbbaa34ca
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Nov 10 12:08:13 2017 -0500

    drm/amd/display: Remove redundant checks in set_default_colors
    
    pipe_ctx->stream and pipe_ctx->plane_state are never NULL
    
    Found by smatch:
    drivers/gpu/drm/amd/amdgpu/../display/dc/dce110/dce110_hw_sequencer.c:2111
    set_default_colors() error: we previously assumed 'pipe_ctx->stream'
    could be null (see line 2101)
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index da2e44058cc2..981bcd291602 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2095,16 +2095,8 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
 	struct default_adjustment default_adjust = { 0 };
 
 	default_adjust.force_hw_default = false;
-	if (pipe_ctx->plane_state == NULL)
-		default_adjust.in_color_space = COLOR_SPACE_SRGB;
-	else
-		default_adjust.in_color_space =
-				pipe_ctx->plane_state->color_space;
-	if (pipe_ctx->stream == NULL)
-		default_adjust.out_color_space = COLOR_SPACE_SRGB;
-	else
-		default_adjust.out_color_space =
-				pipe_ctx->stream->output_color_space;
+	default_adjust.in_color_space = pipe_ctx->plane_state->color_space;
+	default_adjust.out_color_space = pipe_ctx->stream->output_color_space;
 	default_adjust.csc_adjust_type = GRAPHICS_CSC_ADJUST_TYPE_SW;
 	default_adjust.surface_pixel_format = pipe_ctx->plane_res.scl_data.format;
 

commit ede569844a1b11b368a88269545a9d83cf98063c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Nov 10 12:00:41 2017 -0500

    drm/amd/display: Remove plane_res.mi check in dce110_apply_ctx_for_surface
    
    plane_res.mi (memory interface) can never be NULL for DCE110
    
    Found by smatch:
    drivers/gpu/drm/amd/amdgpu/../display/dc/dce110/dce110_hw_sequencer.c:2881
    dce110_apply_ctx_for_surface() error: we previously assumed
    'pipe_ctx->plane_res.mi' could be null (see line 2873)
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e650bdcd9423..da2e44058cc2 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2872,13 +2872,12 @@ static void dce110_apply_ctx_for_surface(
 			continue;
 
 		/* Need to allocate mem before program front end for Fiji */
-		if (pipe_ctx->plane_res.mi != NULL)
-			pipe_ctx->plane_res.mi->funcs->allocate_mem_input(
-					pipe_ctx->plane_res.mi,
-					pipe_ctx->stream->timing.h_total,
-					pipe_ctx->stream->timing.v_total,
-					pipe_ctx->stream->timing.pix_clk_khz,
-					context->stream_count);
+		pipe_ctx->plane_res.mi->funcs->allocate_mem_input(
+				pipe_ctx->plane_res.mi,
+				pipe_ctx->stream->timing.h_total,
+				pipe_ctx->stream->timing.v_total,
+				pipe_ctx->stream->timing.pix_clk_khz,
+				context->stream_count);
 
 		dce110_program_front_end_for_pipe(dc, pipe_ctx);
 

commit 4f804817d5cfb4bd1abf59a29721446af4b4cfd4
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Nov 9 13:55:46 2017 -0500

    drm/amd/display: Move update_plane_addr to apply_ctx_for_surface for dce.
    
    Move update_plane_addr to apply_ctx_for_surface, address update will
    just be called once, not twice for updat type is full and medium.
    This will reduce some reg access and duration time.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 09051dfe1844..e650bdcd9423 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2881,6 +2881,9 @@ static void dce110_apply_ctx_for_surface(
 					context->stream_count);
 
 		dce110_program_front_end_for_pipe(dc, pipe_ctx);
+
+		dc->hwss.update_plane_addr(dc, pipe_ctx);
+
 		program_surface_visibility(dc, pipe_ctx);
 
 	}

commit 2194e3ae902a89579141d860d010d78d422cbc4f
Author: Roman Li <Roman.Li@amd.com>
Date:   Tue Nov 7 10:58:40 2017 -0500

    drm/amd/display: Fix unbalanced locking in surface apply
    
    also simplifying syntax and removing unused variable in
    dce110_apply_ctx_for_surface()
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 750bbe9edf5c..09051dfe1844 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2849,22 +2849,19 @@ static void dce110_apply_ctx_for_surface(
 		int num_planes,
 		struct dc_state *context)
 {
-	int i, be_idx;
+	int i;
 
 	if (num_planes == 0)
 		return;
 
-	be_idx = -1;
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *old_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
 
-		if (stream == context->res_ctx.pipe_ctx[i].stream) {
-			be_idx = context->res_ctx.pipe_ctx[i].stream_res.tg->inst;
+		if (stream == pipe_ctx->stream) {
 			if (!pipe_ctx->top_pipe &&
 				(pipe_ctx->plane_state || old_pipe_ctx->plane_state))
 				dc->hwss.pipe_control_lock(dc, pipe_ctx, true);
-			break;
 		}
 	}
 

commit 7f914a62c94fb29b96a88d72c9a2688db95275cf
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Nov 6 14:40:31 2017 -0500

    drm/amd/display: Apply work around for stutter.
    
    Power on one plane after disable all the planes, for
    a hw bug work around to resolve stutter efficiency issue.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 4f321507ba06..750bbe9edf5c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1411,7 +1411,7 @@ static void disable_vga_and_power_gate_all_controllers(
 				true);
 
 		dc->current_state->res_ctx.pipe_ctx[i].pipe_idx = i;
-		dc->hwss.power_down_front_end(dc,
+		dc->hwss.disable_plane(dc,
 			&dc->current_state->res_ctx.pipe_ctx[i]);
 	}
 }
@@ -1838,7 +1838,7 @@ static void dce110_reset_hw_ctx_wrap(
 			if (old_clk)
 				old_clk->funcs->cs_power_down(old_clk);
 
-			dc->hwss.power_down_front_end(dc, pipe_ctx_old);
+			dc->hwss.disable_plane(dc, pipe_ctx_old);
 
 			pipe_ctx_old->stream = NULL;
 		}
@@ -2063,8 +2063,8 @@ enum dc_status dce110_apply_ctx_to_hw(
 				context,
 				dc);
 
-		if (dc->hwss.power_on_front_end)
-			dc->hwss.power_on_front_end(dc, pipe_ctx, context);
+		if (dc->hwss.enable_plane)
+			dc->hwss.enable_plane(dc, pipe_ctx, context);
 
 		if (DC_OK != status)
 			return status;
@@ -2969,7 +2969,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.unblank_stream = dce110_unblank_stream,
 	.enable_display_pipe_clock_gating = enable_display_pipe_clock_gating,
 	.enable_display_power_gating = dce110_enable_display_power_gating,
-	.power_down_front_end = dce110_power_down_fe,
+	.disable_plane = dce110_power_down_fe,
 	.pipe_control_lock = dce_pipe_control_lock,
 	.set_bandwidth = dce110_set_bandwidth,
 	.set_drr = set_drr,

commit bd1be8e894e4963595a35ebeff512dc63d3ee328
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Nov 1 14:31:58 2017 -0400

    drm/amd/display: A few more color indentation changes
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 97630fcd230f..4f321507ba06 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -307,10 +307,9 @@ dce110_set_input_transfer_func(struct pipe_ctx *pipe_ctx,
 	return result;
 }
 
-static bool convert_to_custom_float(
-		struct pwl_result_data *rgb_resulted,
-		struct curve_points *arr_points,
-		uint32_t hw_points_num)
+static bool convert_to_custom_float(struct pwl_result_data *rgb_resulted,
+				    struct curve_points *arr_points,
+				    uint32_t hw_points_num)
 {
 	struct custom_float_format fmt;
 
@@ -322,26 +321,20 @@ static bool convert_to_custom_float(
 	fmt.mantissa_bits = 12;
 	fmt.sign = true;
 
-	if (!convert_to_custom_float_format(
-		arr_points[0].x,
-		&fmt,
-		&arr_points[0].custom_float_x)) {
+	if (!convert_to_custom_float_format(arr_points[0].x, &fmt,
+					    &arr_points[0].custom_float_x)) {
 		BREAK_TO_DEBUGGER();
 		return false;
 	}
 
-	if (!convert_to_custom_float_format(
-		arr_points[0].offset,
-		&fmt,
-		&arr_points[0].custom_float_offset)) {
+	if (!convert_to_custom_float_format(arr_points[0].offset, &fmt,
+					    &arr_points[0].custom_float_offset)) {
 		BREAK_TO_DEBUGGER();
 		return false;
 	}
 
-	if (!convert_to_custom_float_format(
-		arr_points[0].slope,
-		&fmt,
-		&arr_points[0].custom_float_slope)) {
+	if (!convert_to_custom_float_format(arr_points[0].slope, &fmt,
+					    &arr_points[0].custom_float_slope)) {
 		BREAK_TO_DEBUGGER();
 		return false;
 	}
@@ -349,26 +342,20 @@ static bool convert_to_custom_float(
 	fmt.mantissa_bits = 10;
 	fmt.sign = false;
 
-	if (!convert_to_custom_float_format(
-		arr_points[1].x,
-		&fmt,
-		&arr_points[1].custom_float_x)) {
+	if (!convert_to_custom_float_format(arr_points[1].x, &fmt,
+					    &arr_points[1].custom_float_x)) {
 		BREAK_TO_DEBUGGER();
 		return false;
 	}
 
-	if (!convert_to_custom_float_format(
-		arr_points[1].y,
-		&fmt,
-		&arr_points[1].custom_float_y)) {
+	if (!convert_to_custom_float_format(arr_points[1].y, &fmt,
+					    &arr_points[1].custom_float_y)) {
 		BREAK_TO_DEBUGGER();
 		return false;
 	}
 
-	if (!convert_to_custom_float_format(
-		arr_points[2].slope,
-		&fmt,
-		&arr_points[2].custom_float_slope)) {
+	if (!convert_to_custom_float_format(arr_points[2].slope, &fmt,
+					    &arr_points[2].custom_float_slope)) {
 		BREAK_TO_DEBUGGER();
 		return false;
 	}
@@ -377,50 +364,38 @@ static bool convert_to_custom_float(
 	fmt.sign = true;
 
 	while (i != hw_points_num) {
-		if (!convert_to_custom_float_format(
-			rgb->red,
-			&fmt,
-			&rgb->red_reg)) {
+		if (!convert_to_custom_float_format(rgb->red, &fmt,
+						    &rgb->red_reg)) {
 			BREAK_TO_DEBUGGER();
 			return false;
 		}
 
-		if (!convert_to_custom_float_format(
-			rgb->green,
-			&fmt,
-			&rgb->green_reg)) {
+		if (!convert_to_custom_float_format(rgb->green, &fmt,
+						    &rgb->green_reg)) {
 			BREAK_TO_DEBUGGER();
 			return false;
 		}
 
-		if (!convert_to_custom_float_format(
-			rgb->blue,
-			&fmt,
-			&rgb->blue_reg)) {
+		if (!convert_to_custom_float_format(rgb->blue, &fmt,
+						    &rgb->blue_reg)) {
 			BREAK_TO_DEBUGGER();
 			return false;
 		}
 
-		if (!convert_to_custom_float_format(
-			rgb->delta_red,
-			&fmt,
-			&rgb->delta_red_reg)) {
+		if (!convert_to_custom_float_format(rgb->delta_red, &fmt,
+						    &rgb->delta_red_reg)) {
 			BREAK_TO_DEBUGGER();
 			return false;
 		}
 
-		if (!convert_to_custom_float_format(
-			rgb->delta_green,
-			&fmt,
-			&rgb->delta_green_reg)) {
+		if (!convert_to_custom_float_format(rgb->delta_green, &fmt,
+						    &rgb->delta_green_reg)) {
 			BREAK_TO_DEBUGGER();
 			return false;
 		}
 
-		if (!convert_to_custom_float_format(
-			rgb->delta_blue,
-			&fmt,
-			&rgb->delta_blue_reg)) {
+		if (!convert_to_custom_float_format(rgb->delta_blue, &fmt,
+						    &rgb->delta_blue_reg)) {
 			BREAK_TO_DEBUGGER();
 			return false;
 		}

commit b310b081ad744dca288af33ef8331796840a1da2
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Oct 31 15:16:56 2017 -0400

    drm/amd/display: Bunch more color indentation cleanups
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 6b3ab4320b0c..97630fcd230f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -432,8 +432,9 @@ static bool convert_to_custom_float(
 	return true;
 }
 
-static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
-		*output_tf, struct pwl_params *regamma_params)
+static bool
+dce110_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
+				      struct pwl_params *regamma_params)
 {
 	struct curve_points *arr_points;
 	struct pwl_result_data *rgb_resulted;
@@ -448,8 +449,7 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 	int32_t segment_start, segment_end;
 	uint32_t i, j, k, seg_distr[16], increment, start_index, hw_points;
 
-	if (output_tf == NULL || regamma_params == NULL ||
-			output_tf->type == TF_TYPE_BYPASS)
+	if (output_tf == NULL || regamma_params == NULL || output_tf->type == TF_TYPE_BYPASS)
 		return false;
 
 	arr_points = regamma_params->arr_points;
@@ -528,17 +528,14 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 
 	/* last point */
 	start_index = (segment_end + 25) * 32;
-	rgb_resulted[hw_points - 1].red =
-			output_tf->tf_pts.red[start_index];
-	rgb_resulted[hw_points - 1].green =
-			output_tf->tf_pts.green[start_index];
-	rgb_resulted[hw_points - 1].blue =
-			output_tf->tf_pts.blue[start_index];
+	rgb_resulted[hw_points - 1].red = output_tf->tf_pts.red[start_index];
+	rgb_resulted[hw_points - 1].green = output_tf->tf_pts.green[start_index];
+	rgb_resulted[hw_points - 1].blue = output_tf->tf_pts.blue[start_index];
 
 	arr_points[0].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
-			dal_fixed31_32_from_int(segment_start));
+					     dal_fixed31_32_from_int(segment_start));
 	arr_points[1].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
-			dal_fixed31_32_from_int(segment_end));
+					     dal_fixed31_32_from_int(segment_end));
 
 	y_r = rgb_resulted[0].red;
 	y_g = rgb_resulted[0].green;
@@ -547,9 +544,8 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 	y1_min = dal_fixed31_32_min(y_r, dal_fixed31_32_min(y_g, y_b));
 
 	arr_points[0].y = y1_min;
-	arr_points[0].slope = dal_fixed31_32_div(
-					arr_points[0].y,
-					arr_points[0].x);
+	arr_points[0].slope = dal_fixed31_32_div(arr_points[0].y,
+						 arr_points[0].x);
 
 	y_r = rgb_resulted[hw_points - 1].red;
 	y_g = rgb_resulted[hw_points - 1].green;
@@ -568,12 +564,11 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 		/* for PQ, we want to have a straight line from last HW X point,
 		 * and the slope to be such that we hit 1.0 at 10000 nits.
 		 */
-		const struct fixed31_32 end_value =
-				dal_fixed31_32_from_int(125);
+		const struct fixed31_32 end_value = dal_fixed31_32_from_int(125);
 
 		arr_points[1].slope = dal_fixed31_32_div(
-			dal_fixed31_32_sub(dal_fixed31_32_one, arr_points[1].y),
-			dal_fixed31_32_sub(end_value, arr_points[1].x));
+				dal_fixed31_32_sub(dal_fixed31_32_one, arr_points[1].y),
+				dal_fixed31_32_sub(end_value, arr_points[1].x));
 	}
 
 	regamma_params->hw_points_num = hw_points;
@@ -581,18 +576,15 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 	i = 1;
 	for (k = 0; k < 16 && i < 16; k++) {
 		if (seg_distr[k] != -1) {
-			regamma_params->arr_curve_points[k].segments_num =
-					seg_distr[k];
+			regamma_params->arr_curve_points[k].segments_num = seg_distr[k];
 			regamma_params->arr_curve_points[i].offset =
-					regamma_params->arr_curve_points[k].
-					offset + (1 << seg_distr[k]);
+					regamma_params->arr_curve_points[k].offset + (1 << seg_distr[k]);
 		}
 		i++;
 	}
 
 	if (seg_distr[k] != -1)
-		regamma_params->arr_curve_points[k].segments_num =
-				seg_distr[k];
+		regamma_params->arr_curve_points[k].segments_num = seg_distr[k];
 
 	rgb = rgb_resulted;
 	rgb_plus_1 = rgb_resulted + 1;
@@ -607,15 +599,9 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 		if (dal_fixed31_32_lt(rgb_plus_1->blue, rgb->blue))
 			rgb_plus_1->blue = rgb->blue;
 
-		rgb->delta_red = dal_fixed31_32_sub(
-			rgb_plus_1->red,
-			rgb->red);
-		rgb->delta_green = dal_fixed31_32_sub(
-			rgb_plus_1->green,
-			rgb->green);
-		rgb->delta_blue = dal_fixed31_32_sub(
-			rgb_plus_1->blue,
-			rgb->blue);
+		rgb->delta_red = dal_fixed31_32_sub(rgb_plus_1->red, rgb->red);
+		rgb->delta_green = dal_fixed31_32_sub(rgb_plus_1->green, rgb->green);
+		rgb->delta_blue = dal_fixed31_32_sub(rgb_plus_1->blue, rgb->blue);
 
 		++rgb_plus_1;
 		++rgb;

commit 97110c98a0fa2091190dc3068734ef9f1c12b588
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Oct 31 14:41:41 2017 -0400

    drm/amd/display: Remove extra arr_points element
    
    arr_points[1] and [2] were duplicated. Remove the extra
    one. If we ever need more points we can add them but the
    current state of affairs is confusing.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index d22745e6dff0..6b3ab4320b0c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -539,8 +539,6 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 			dal_fixed31_32_from_int(segment_start));
 	arr_points[1].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
 			dal_fixed31_32_from_int(segment_end));
-	arr_points[2].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
-			dal_fixed31_32_from_int(segment_end));
 
 	y_r = rgb_resulted[0].red;
 	y_g = rgb_resulted[0].green;
@@ -563,10 +561,8 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 	y3_max = dal_fixed31_32_max(y_r, dal_fixed31_32_max(y_g, y_b));
 
 	arr_points[1].y = y3_max;
-	arr_points[2].y = y3_max;
 
 	arr_points[1].slope = dal_fixed31_32_zero;
-	arr_points[2].slope = dal_fixed31_32_zero;
 
 	if (output_tf->tf == TRANSFER_FUNCTION_PQ) {
 		/* for PQ, we want to have a straight line from last HW X point,
@@ -578,9 +574,6 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 		arr_points[1].slope = dal_fixed31_32_div(
 			dal_fixed31_32_sub(dal_fixed31_32_one, arr_points[1].y),
 			dal_fixed31_32_sub(end_value, arr_points[1].x));
-		arr_points[2].slope = dal_fixed31_32_div(
-			dal_fixed31_32_sub(dal_fixed31_32_one, arr_points[1].y),
-			dal_fixed31_32_sub(end_value, arr_points[1].x));
 	}
 
 	regamma_params->hw_points_num = hw_points;

commit 631aaa0af4be3de8f0184095075650afaa023334
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Tue Oct 31 15:55:15 2017 -0400

    drm/amd/display: send display_count msg so SMU can enter S0i2
    
    SMU can future lower voltages in long idle case when all display is off.
    
    If all display output is turned off via DPMS, send display_count = 0
    after all output are turned off.
    
    otherwise send display_count msg before turning on display to make sure
    SMU exit S0i2 state.  before is not neccessary as we are out of S0i2
    when driver execute code, but send message before anyways for correctness.
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 1ec008404784..d22745e6dff0 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2595,6 +2595,10 @@ void dce110_fill_display_configs(
 
 		ASSERT(pipe_ctx != NULL);
 
+		/* only notify active stream */
+		if (stream->dpms_off)
+			continue;
+
 		num_cfgs++;
 		cfg->signal = pipe_ctx->stream->signal;
 		cfg->pipe_idx = pipe_ctx->pipe_idx;
@@ -3024,6 +3028,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.wait_for_mpcc_disconnect = dce110_wait_for_mpcc_disconnect,
 	.ready_shared_resources = ready_shared_resources,
 	.optimize_shared_resources = optimize_shared_resources,
+	.pplib_apply_display_requirements = pplib_apply_display_requirements,
 	.edp_backlight_control = hwss_edp_backlight_control,
 	.edp_power_control = hwss_edp_power_control,
 };

commit a6114e854c55c928b9b8bcf7014eb205bd112c68
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Oct 31 16:27:59 2017 -0400

    drm/amd/display: Fix some more color indentations
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 3002978c860e..1ec008404784 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -257,9 +257,9 @@ static void build_prescale_params(struct ipp_prescale_params *prescale_params,
 	}
 }
 
-static bool dce110_set_input_transfer_func(
-	struct pipe_ctx *pipe_ctx,
-	const struct dc_plane_state *plane_state)
+static bool
+dce110_set_input_transfer_func(struct pipe_ctx *pipe_ctx,
+			       const struct dc_plane_state *plane_state)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
 	const struct dc_transfer_func *tf = NULL;
@@ -280,25 +280,19 @@ static bool dce110_set_input_transfer_func(
 
 	if (tf == NULL) {
 		/* Default case if no input transfer function specified */
-		ipp->funcs->ipp_set_degamma(ipp,
-				IPP_DEGAMMA_MODE_HW_sRGB);
+		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_HW_sRGB);
 	} else if (tf->type == TF_TYPE_PREDEFINED) {
 		switch (tf->tf) {
 		case TRANSFER_FUNCTION_SRGB:
-			ipp->funcs->ipp_set_degamma(ipp,
-					IPP_DEGAMMA_MODE_HW_sRGB);
+			ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_HW_sRGB);
 			break;
 		case TRANSFER_FUNCTION_BT709:
-			ipp->funcs->ipp_set_degamma(ipp,
-					IPP_DEGAMMA_MODE_HW_xvYCC);
+			ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_HW_xvYCC);
 			break;
 		case TRANSFER_FUNCTION_LINEAR:
-			ipp->funcs->ipp_set_degamma(ipp,
-					IPP_DEGAMMA_MODE_BYPASS);
+			ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
 			break;
 		case TRANSFER_FUNCTION_PQ:
-			result = false;
-			break;
 		default:
 			result = false;
 			break;
@@ -640,9 +634,9 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 	return true;
 }
 
-static bool dce110_set_output_transfer_func(
-	struct pipe_ctx *pipe_ctx,
-	const struct dc_stream_state *stream)
+static bool
+dce110_set_output_transfer_func(struct pipe_ctx *pipe_ctx,
+				const struct dc_stream_state *stream)
 {
 	struct transform *xfm = pipe_ctx->plane_res.xfm;
 
@@ -2756,8 +2750,7 @@ static void dce110_program_front_end_for_pipe(
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
-	struct pipe_ctx *cur_pipe_ctx =
-					&dc->current_state->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
+	struct pipe_ctx *cur_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
 	unsigned int i;
 
 	memset(&tbl_entry, 0, sizeof(tbl_entry));
@@ -2850,10 +2843,8 @@ static void dce110_program_front_end_for_pipe(
 
 	/* Moved programming gamma from dc to hwss */
 	if (cur_pipe_ctx->plane_state != pipe_ctx->plane_state) {
-		dc->hwss.set_input_transfer_func(
-				pipe_ctx, pipe_ctx->plane_state);
-		dc->hwss.set_output_transfer_func(
-				pipe_ctx, pipe_ctx->stream);
+		dc->hwss.set_input_transfer_func(pipe_ctx, pipe_ctx->plane_state);
+		dc->hwss.set_output_transfer_func(pipe_ctx, pipe_ctx->stream);
 	}
 
 	dm_logger_write(dc->ctx->logger, LOG_SURFACE,

commit efd5220405df0acd43eb7e16948e92eec87ce2cb
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Oct 31 14:34:13 2017 -0400

    drm/amd/display: Bunch of indentation cleanups in color stuff
    
    Trying to align with kernel coding style and make it a bit more
    readable.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 73c38c93f5df..3002978c860e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -650,13 +650,11 @@ static bool dce110_set_output_transfer_func(
 	xfm->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
 
 	if (stream->out_transfer_func &&
-		stream->out_transfer_func->type ==
-			TF_TYPE_PREDEFINED &&
-		stream->out_transfer_func->tf ==
-			TRANSFER_FUNCTION_SRGB) {
+	    stream->out_transfer_func->type == TF_TYPE_PREDEFINED &&
+	    stream->out_transfer_func->tf == TRANSFER_FUNCTION_SRGB) {
 		xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_SRGB);
-	} else if (dce110_translate_regamma_to_hw_format(
-				stream->out_transfer_func, &xfm->regamma_params)) {
+	} else if (dce110_translate_regamma_to_hw_format(stream->out_transfer_func,
+							 &xfm->regamma_params)) {
 		xfm->funcs->opp_program_regamma_pwl(xfm, &xfm->regamma_params);
 		xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_USER);
 	} else {

commit e6c258cb4e6fbc7500c493df22f52e1046c575b0
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Oct 30 17:32:14 2017 -0400

    drm/amd/display: Refactor disable front end pipes.
    
    There are different code to disable front end, it is
    difficult to debug and adding new process.
    This refactor makes all disable front end call the same
    functions.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 44315aef445b..73c38c93f5df 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1464,7 +1464,9 @@ static void disable_vga_and_power_gate_all_controllers(
 		enable_display_pipe_clock_gating(ctx,
 				true);
 
-		dc->hwss.power_down_front_end(dc, i);
+		dc->current_state->res_ctx.pipe_ctx[i].pipe_idx = i;
+		dc->hwss.power_down_front_end(dc,
+			&dc->current_state->res_ctx.pipe_ctx[i]);
 	}
 }
 
@@ -1890,7 +1892,7 @@ static void dce110_reset_hw_ctx_wrap(
 			if (old_clk)
 				old_clk->funcs->cs_power_down(old_clk);
 
-			dc->hwss.power_down_front_end(dc, pipe_ctx_old->pipe_idx);
+			dc->hwss.power_down_front_end(dc, pipe_ctx_old);
 
 			pipe_ctx_old->stream = NULL;
 		}
@@ -2950,8 +2952,10 @@ static void dce110_apply_ctx_for_surface(
 	}
 }
 
-static void dce110_power_down_fe(struct dc *dc, int fe_idx)
+static void dce110_power_down_fe(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
+	int fe_idx = pipe_ctx->pipe_idx;
+
 	/* Do not power down fe when stream is active on dce*/
 	if (dc->current_state->res_ctx.pipe_ctx[fe_idx].stream)
 		return;

commit 069d418f412ec4b33056dc7d84b63c80c2e50abf
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Tue Sep 26 19:45:43 2017 -0400

    drm/amd/display: Don't use dc_link in link_encoder
    
    dc_link is at a higher level than link_encoder, and we only want
    higher-level components to be able to access lower-level ones,
    not the other way around.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 868040a4f7ff..44315aef445b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -814,11 +814,11 @@ static enum bp_result link_transmitter_control(
  * eDP only.
  */
 void hwss_edp_wait_for_hpd_ready(
-	struct link_encoder *enc,
-	bool power_up)
+		struct dc_link *link,
+		bool power_up)
 {
-	struct dc_context *ctx = enc->ctx;
-	struct graphics_object_id connector = enc->connector;
+	struct dc_context *ctx = link->ctx;
+	struct graphics_object_id connector = link->link_enc->connector;
 	struct gpio *hpd;
 	bool edp_hpd_high = false;
 	uint32_t time_elapsed = 0;
@@ -882,16 +882,16 @@ void hwss_edp_wait_for_hpd_ready(
 }
 
 void hwss_edp_power_control(
-	struct link_encoder *enc,
-	bool power_up)
+		struct dc_link *link,
+		bool power_up)
 {
-	struct dc_context *ctx = enc->ctx;
+	struct dc_context *ctx = link->ctx;
 	struct dce_hwseq *hwseq = ctx->dc->hwseq;
 	struct bp_transmitter_control cntl = { 0 };
 	enum bp_result bp_result;
 
 
-	if (dal_graphics_object_id_get_connector_id(enc->connector)
+	if (dal_graphics_object_id_get_connector_id(link->link_enc->connector)
 			!= CONNECTOR_ID_EDP) {
 		BREAK_TO_DEBUGGER();
 		return;
@@ -907,11 +907,11 @@ void hwss_edp_power_control(
 		cntl.action = power_up ?
 			TRANSMITTER_CONTROL_POWER_ON :
 			TRANSMITTER_CONTROL_POWER_OFF;
-		cntl.transmitter = enc->transmitter;
-		cntl.connector_obj_id = enc->connector;
+		cntl.transmitter = link->link_enc->transmitter;
+		cntl.connector_obj_id = link->link_enc->connector;
 		cntl.coherent = false;
 		cntl.lanes_number = LANE_COUNT_FOUR;
-		cntl.hpd_sel = enc->hpd_source;
+		cntl.hpd_sel = link->link_enc->hpd_source;
 
 		bp_result = link_transmitter_control(ctx->dc_bios, &cntl);
 
@@ -925,7 +925,7 @@ void hwss_edp_power_control(
 				__func__, (power_up ? "On":"Off"));
 	}
 
-	hwss_edp_wait_for_hpd_ready(enc, true);
+	hwss_edp_wait_for_hpd_ready(link, true);
 }
 
 /*todo: cloned in stream enc, fix*/
@@ -934,14 +934,14 @@ void hwss_edp_power_control(
  * eDP only. Control the backlight of the eDP panel
  */
 void hwss_edp_backlight_control(
-	struct dc_link *link,
-	bool enable)
+		struct dc_link *link,
+		bool enable)
 {
-	struct dce_hwseq *hws = link->dc->hwseq;
-	struct dc_context *ctx = link->dc->ctx;
+	struct dc_context *ctx = link->ctx;
+	struct dce_hwseq *hws = ctx->dc->hwseq;
 	struct bp_transmitter_control cntl = { 0 };
 
-	if (dal_graphics_object_id_get_connector_id(link->link_id)
+	if (dal_graphics_object_id_get_connector_id(link->link_enc->connector)
 		!= CONNECTOR_ID_EDP) {
 		BREAK_TO_DEBUGGER();
 		return;
@@ -982,7 +982,7 @@ void hwss_edp_backlight_control(
 	 * Enable it in the future if necessary.
 	 */
 	/* dc_service_sleep_in_milliseconds(50); */
-	link_transmitter_control(link->dc->ctx->dc_bios, &cntl);
+	link_transmitter_control(ctx->dc_bios, &cntl);
 }
 
 void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)
@@ -1396,12 +1396,14 @@ static void power_down_encoders(struct dc *dc)
 
 			if (!dc->links[i]->wa_flags.dp_keep_receiver_powered)
 				dp_receiver_power_ctrl(dc->links[i], false);
-			if (connector_id == CONNECTOR_ID_EDP)
+			if (connector_id == CONNECTOR_ID_EDP) {
 				signal = SIGNAL_TYPE_EDP;
+				hwss_edp_backlight_control(dc->links[i], false);
+			}
 		}
 
 		dc->links[i]->link_enc->funcs->disable_output(
-				dc->links[i]->link_enc, signal, dc->links[i]);
+				dc->links[i]->link_enc, signal);
 	}
 }
 
@@ -2541,6 +2543,10 @@ static void init_hw(struct dc *dc)
 		 * required signal (which may be different from the
 		 * default signal on connector). */
 		struct dc_link *link = dc->links[i];
+
+		if (link->link_enc->connector.id == CONNECTOR_ID_EDP)
+			dc->hwss.edp_power_control(link, true);
+
 		link->link_enc->funcs->hw_init(link->link_enc);
 	}
 

commit fa2123dbccdc881fae02aaf8b05758db53d62955
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Tue Oct 17 15:29:22 2017 -0400

    drm/amd/display: Multi display synchronization logic
    
    This feature synchronizes multiple displays with various timings
    to a display with the highest refresh rate
    it is enabled if edid caps flag multi_display_sync is set to one
    
    There are limitations on refresh rates allowed
    that can be synchronized. That would
    prevent from underflow and other potential
    corruptions.
    
    Multi display synchronization is using the
    same functions as timing_sync in order to minimize
    redunduncy and decision to disable synchronization is
    based on trigger parametre set in DM
    
    Feature is developed for DCN1 and DCE11
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Mikita Lipski <Mikita.Lipski@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 58d019cacaa2..868040a4f7ff 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2457,20 +2457,16 @@ static void dce110_enable_timing_synchronization(
 
 	for (i = 1 /* skip the master */; i < group_size; i++)
 		grouped_pipes[i]->stream_res.tg->funcs->enable_reset_trigger(
-					grouped_pipes[i]->stream_res.tg, gsl_params.gsl_group);
-
-
+				grouped_pipes[i]->stream_res.tg,
+				gsl_params.gsl_group);
 
 	for (i = 1 /* skip the master */; i < group_size; i++) {
 		DC_SYNC_INFO("GSL: waiting for reset to occur.\n");
 		wait_for_reset_trigger_to_occur(dc_ctx, grouped_pipes[i]->stream_res.tg);
-		/* Regardless of success of the wait above, remove the reset or
-		 * the driver will start timing out on Display requests. */
-		DC_SYNC_INFO("GSL: disabling trigger-reset.\n");
-		grouped_pipes[i]->stream_res.tg->funcs->disable_reset_trigger(grouped_pipes[i]->stream_res.tg);
+		grouped_pipes[i]->stream_res.tg->funcs->disable_reset_trigger(
+				grouped_pipes[i]->stream_res.tg);
 	}
 
-
 	/* GSL Vblank synchronization is a one time sync mechanism, assumption
 	 * is that the sync'ed displays will not drift out of sync over time*/
 	DC_SYNC_INFO("GSL: Restoring register states.\n");
@@ -2480,6 +2476,39 @@ static void dce110_enable_timing_synchronization(
 	DC_SYNC_INFO("GSL: Set-up complete.\n");
 }
 
+static void dce110_enable_per_frame_crtc_position_reset(
+		struct dc *dc,
+		int group_size,
+		struct pipe_ctx *grouped_pipes[])
+{
+	struct dc_context *dc_ctx = dc->ctx;
+	struct dcp_gsl_params gsl_params = { 0 };
+	int i;
+
+	gsl_params.gsl_group = 0;
+	gsl_params.gsl_master = grouped_pipes[0]->stream->triggered_crtc_reset.event_source->status.primary_otg_inst;
+
+	for (i = 0; i < group_size; i++)
+		grouped_pipes[i]->stream_res.tg->funcs->setup_global_swap_lock(
+					grouped_pipes[i]->stream_res.tg, &gsl_params);
+
+	DC_SYNC_INFO("GSL: enabling trigger-reset\n");
+
+	for (i = 1; i < group_size; i++)
+		grouped_pipes[i]->stream_res.tg->funcs->enable_crtc_reset(
+				grouped_pipes[i]->stream_res.tg,
+				gsl_params.gsl_master,
+				&grouped_pipes[i]->stream->triggered_crtc_reset);
+
+	DC_SYNC_INFO("GSL: waiting for reset to occur.\n");
+	for (i = 1; i < group_size; i++)
+		wait_for_reset_trigger_to_occur(dc_ctx, grouped_pipes[i]->stream_res.tg);
+
+	for (i = 0; i < group_size; i++)
+		grouped_pipes[i]->stream_res.tg->funcs->tear_down_global_swap_lock(grouped_pipes[i]->stream_res.tg);
+
+}
+
 static void init_hw(struct dc *dc)
 {
 	int i;
@@ -2976,6 +3005,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.power_down = dce110_power_down,
 	.enable_accelerated_mode = dce110_enable_accelerated_mode,
 	.enable_timing_synchronization = dce110_enable_timing_synchronization,
+	.enable_per_frame_crtc_position_reset = dce110_enable_per_frame_crtc_position_reset,
 	.update_info_frame = dce110_update_info_frame,
 	.enable_stream = dce110_enable_stream,
 	.disable_stream = dce110_disable_stream,

commit 56ef6ed9faf35b9057630dd12aeca134f98214ec
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Mon Oct 23 17:02:02 2017 -0400

    drm/amd/display: Move hdr_metadata from plane to stream
    
    Need to move HDR Metadata from Surface to Stream since there is only one
    infoframe possible per stream.
    
    Also cleaning up some duplicate definitions.
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 61e11a1161bb..58d019cacaa2 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2279,8 +2279,7 @@ static void set_plane_config(
 	dce_enable_fe_clock(dc->hwseq, pipe_ctx->pipe_idx, true);
 
 	set_default_colors(pipe_ctx);
-	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment
-			== true) {
+	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment == true) {
 		tbl_entry.color_space =
 			pipe_ctx->stream->output_color_space;
 

commit 3dc780ec3473200ef870eae9b19169445d76be4c
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Oct 17 14:48:11 2017 -0400

    drm/amd/display: Move lock to front end program.
    
    Moved lock and unlock to apply_ctx_to_surface, since all
    the front end programming is within apply_ctx_to_surface.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 07ff8d2faf3f..61e11a1161bb 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2873,8 +2873,14 @@ static void dce110_apply_ctx_for_surface(
 
 	be_idx = -1;
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *old_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
+
 		if (stream == context->res_ctx.pipe_ctx[i].stream) {
 			be_idx = context->res_ctx.pipe_ctx[i].stream_res.tg->inst;
+			if (!pipe_ctx->top_pipe &&
+				(pipe_ctx->plane_state || old_pipe_ctx->plane_state))
+				dc->hwss.pipe_control_lock(dc, pipe_ctx, true);
 			break;
 		}
 	}
@@ -2898,6 +2904,16 @@ static void dce110_apply_ctx_for_surface(
 		program_surface_visibility(dc, pipe_ctx);
 
 	}
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *old_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
+
+		if ((stream == pipe_ctx->stream) &&
+			(!pipe_ctx->top_pipe) &&
+			(pipe_ctx->plane_state || old_pipe_ctx->plane_state))
+			dc->hwss.pipe_control_lock(dc, pipe_ctx, false);
+	}
 }
 
 static void dce110_power_down_fe(struct dc *dc, int fe_idx)

commit 2b7c97d687e81db07d8c67b32ff920e7bf59444e
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Nov 15 18:27:31 2017 -0500

    drm/amd/display: fix seq issue: turn on clock before programming afmt.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index c3de7f305cd3..07ff8d2faf3f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -991,6 +991,16 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)
 	struct dc_link *link = stream->sink->link;
 	struct dc *dc = pipe_ctx->stream->ctx->dc;
 
+	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
+		pipe_ctx->stream_res.stream_enc->funcs->stop_hdmi_info_packets(
+			pipe_ctx->stream_res.stream_enc);
+
+	if (dc_is_dp_signal(pipe_ctx->stream->signal))
+		pipe_ctx->stream_res.stream_enc->funcs->stop_dp_info_packets(
+			pipe_ctx->stream_res.stream_enc);
+
+	pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
+			pipe_ctx->stream_res.stream_enc, true);
 	if (pipe_ctx->stream_res.audio) {
 		pipe_ctx->stream_res.audio->funcs->az_disable(pipe_ctx->stream_res.audio);
 
@@ -1015,18 +1025,6 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)
 		 */
 	}
 
-	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
-		pipe_ctx->stream_res.stream_enc->funcs->stop_hdmi_info_packets(
-			pipe_ctx->stream_res.stream_enc);
-
-	if (dc_is_dp_signal(pipe_ctx->stream->signal))
-		pipe_ctx->stream_res.stream_enc->funcs->stop_dp_info_packets(
-			pipe_ctx->stream_res.stream_enc);
-
-	pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
-			pipe_ctx->stream_res.stream_enc, true);
-
-
 	/* blank at encoder level */
 	if (dc_is_dp_signal(pipe_ctx->stream->signal)) {
 		if (pipe_ctx->stream->sink->link->connector_signal == SIGNAL_TYPE_EDP)

commit 93984bbc70b3f321b8f6a3ec303e31b084e54230
Author: Shirish S <shirish.s@amd.com>
Date:   Mon Nov 20 10:37:08 2017 +0530

    drm/amd/display: check plane state before validating fbc
    
    While validation fbc, array_mode of the pipe is accessed
    without checking plane_state exists for it.
    Causing to null pointer dereferencing followed by
    reboot when a crtc associated with external display(not
    connected) is page flipped.
    
    This patch adds a check for plane_state before using
    it to validate fbc.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index be14a2665072..c3de7f305cd3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1774,6 +1774,10 @@ static enum dc_status validate_fbc(struct dc *dc,
 	if (pipe_ctx->stream->sink->link->psr_enabled)
 		return DC_ERROR_UNEXPECTED;
 
+	/* Nothing to compress */
+	if (!pipe_ctx->plane_state)
+		return DC_ERROR_UNEXPECTED;
+
 	/* Only for non-linear tiling */
 	if (pipe_ctx->plane_state->tiling_info.gfx8.array_mode == DC_ARRAY_LINEAR_GENERAL)
 		return DC_ERROR_UNEXPECTED;

commit 827f11e97dbc591f0c9619151b9a89f082e8ecb8
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Oct 17 17:18:24 2017 -0400

    drm/amd/display: Should disable when new stream is null
    
    core_link_disable_stream should be called when the new stream is null
    (i.e. want to disable). Modify the if condition to reflect that.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 1229a3315018..be14a2665072 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1868,8 +1868,10 @@ static void dce110_reset_hw_ctx_wrap(
 				pipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {
 			struct clock_source *old_clk = pipe_ctx_old->clock_source;
 
-			/* disable already, no need to disable again */
-			if (pipe_ctx->stream && !pipe_ctx->stream->dpms_off)
+			/* Disable if new stream is null. O/w, if stream is
+			 * disabled already, no need to disable again.
+			 */
+			if (!pipe_ctx->stream || !pipe_ctx->stream->dpms_off)
 				core_link_disable_stream(pipe_ctx_old, FREE_ACQUIRED_RESOURCE);
 
 			pipe_ctx_old->stream_res.tg->funcs->set_blank(pipe_ctx_old->stream_res.tg, true);

commit bf5563ede9f254fba083c6b56e4ca8b836babb1d
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Nov 7 05:30:47 2017 +1000

    amdgpu/dc: fix indentation warning from smatch.
    
    This fixes all the current smatch:
    warn: inconsistent indenting
    
    Reviewed-by: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 399a5984ada3..1229a3315018 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -775,8 +775,8 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 	 * connect DIG back_end to front_end while enable_stream and
 	 * disconnect them during disable_stream
 	 * BY this, it is logic clean to separate stream and link */
-	 link->link_enc->funcs->connect_dig_be_to_fe(link->link_enc,
-			pipe_ctx->stream_res.stream_enc->id, true);
+	link->link_enc->funcs->connect_dig_be_to_fe(link->link_enc,
+						    pipe_ctx->stream_res.stream_enc->id, true);
 
 }
 
@@ -1306,7 +1306,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		stream->timing.display_color_depth,
 		pipe_ctx->stream->signal);
 
-	pipe_ctx->stream_res.opp->funcs->opp_program_fmt(
+		pipe_ctx->stream_res.opp->funcs->opp_program_fmt(
 			pipe_ctx->stream_res.opp,
 			&stream->bit_depth_params,
 			&stream->clamping);
@@ -2594,21 +2594,21 @@ uint32_t dce110_get_min_vblank_time_us(const struct dc_state *context)
 	uint8_t j;
 	uint32_t min_vertical_blank_time = -1;
 
-		for (j = 0; j < context->stream_count; j++) {
-			struct dc_stream_state *stream = context->streams[j];
-			uint32_t vertical_blank_in_pixels = 0;
-			uint32_t vertical_blank_time = 0;
+	for (j = 0; j < context->stream_count; j++) {
+		struct dc_stream_state *stream = context->streams[j];
+		uint32_t vertical_blank_in_pixels = 0;
+		uint32_t vertical_blank_time = 0;
 
-			vertical_blank_in_pixels = stream->timing.h_total *
-				(stream->timing.v_total
-					- stream->timing.v_addressable);
+		vertical_blank_in_pixels = stream->timing.h_total *
+			(stream->timing.v_total
+			 - stream->timing.v_addressable);
 
-			vertical_blank_time = vertical_blank_in_pixels
-				* 1000 / stream->timing.pix_clk_khz;
+		vertical_blank_time = vertical_blank_in_pixels
+			* 1000 / stream->timing.pix_clk_khz;
 
-			if (min_vertical_blank_time > vertical_blank_time)
-				min_vertical_blank_time = vertical_blank_time;
-		}
+		if (min_vertical_blank_time > vertical_blank_time)
+			min_vertical_blank_time = vertical_blank_time;
+	}
 
 	return min_vertical_blank_time;
 }

commit 3b21b6d239f43c0d797bf0deb8c0f8c846862eb1
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Tue Oct 17 15:36:13 2017 -0400

    drm/amd/display: Fix no display on Fiji
    
    Allocate memory for the second pipe allocate_mem_input() needs to
    be done prior to program pipefront end. Itshows sensitive to
    Fiji.Failure to do sowill cause error in allocate memory
    allocate_mem_input() on the second connected display.
    
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 2a6d3ca12954..399a5984ada3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1370,16 +1370,6 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
 
-	/* mst support - use total stream count */
-	if (pipe_ctx->plane_res.mi != NULL) {
-		pipe_ctx->plane_res.mi->funcs->allocate_mem_input(
-				pipe_ctx->plane_res.mi,
-				stream->timing.h_total,
-				stream->timing.v_total,
-				stream->timing.pix_clk_khz,
-				context->stream_count);
-	}
-
 	pipe_ctx->stream->sink->link->psr_enabled = false;
 
 	return DC_OK;
@@ -2891,6 +2881,15 @@ static void dce110_apply_ctx_for_surface(
 		if (pipe_ctx->stream != stream)
 			continue;
 
+		/* Need to allocate mem before program front end for Fiji */
+		if (pipe_ctx->plane_res.mi != NULL)
+			pipe_ctx->plane_res.mi->funcs->allocate_mem_input(
+					pipe_ctx->plane_res.mi,
+					pipe_ctx->stream->timing.h_total,
+					pipe_ctx->stream->timing.v_total,
+					pipe_ctx->stream->timing.pix_clk_khz,
+					context->stream_count);
+
 		dce110_program_front_end_for_pipe(dc, pipe_ctx);
 		program_surface_visibility(dc, pipe_ctx);
 

commit 9b38bd1b8f5c874c3d1f330e0dcf4e7d84137477
Author: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
Date:   Fri Oct 20 16:45:53 2017 -0400

    drm/amd/display:: Fix NULL pointer in Raven hotplug
    
    Programming sequence to frontend and backend has been switched.
    In such case, program_scaler() is gettingcalled when programming
    frontend, and should be removed from backend programming routine.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e8b8daeeed97..2a6d3ca12954 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1369,13 +1369,6 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	}
 
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
-	/* program_scaler and allocate_mem_input are not new asic */
-	if ((!pipe_ctx_old ||
-	     memcmp(&pipe_ctx_old->plane_res.scl_data, &pipe_ctx->plane_res.scl_data,
-		    sizeof(struct scaler_data)) != 0) &&
-	     pipe_ctx->plane_state) {
-		program_scaler(dc, pipe_ctx);
-	}
 
 	/* mst support - use total stream count */
 	if (pipe_ctx->plane_res.mi != NULL) {

commit b9b171fffc9358be9e98cbc2bc7ef3fbe029f170
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Tue Oct 10 16:28:02 2017 -0400

    drm/amd/display: LGD panel willl flash line under window
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 5e5763c0ee94..e8b8daeeed97 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1399,6 +1399,15 @@ static void power_down_encoders(struct dc *dc)
 	int i;
 	enum connector_id connector_id;
 	enum signal_type signal = SIGNAL_TYPE_NONE;
+
+	/* do not know BIOS back-front mapping, simply blank all. It will not
+	 * hurt for non-DP
+	 */
+	for (i = 0; i < dc->res_pool->stream_enc_count; i++) {
+		dc->res_pool->stream_enc[i]->funcs->dp_blank(
+					dc->res_pool->stream_enc[i]);
+	}
+
 	for (i = 0; i < dc->link_count; i++) {
 		connector_id = dal_graphics_object_id_get_connector_id(dc->links[i]->link_id);
 		if ((connector_id == CONNECTOR_ID_DISPLAY_PORT) ||

commit e6f4f9cfde0f586c276190f541ecfc80d9b688bc
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Thu Oct 5 16:00:29 2017 -0400

    drm/amd/display: fix null dereference in reset hw ctx
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 867a0eb9f2e0..5e5763c0ee94 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1877,7 +1877,7 @@ static void dce110_reset_hw_ctx_wrap(
 			struct clock_source *old_clk = pipe_ctx_old->clock_source;
 
 			/* disable already, no need to disable again */
-			if (!pipe_ctx->stream->dpms_off)
+			if (pipe_ctx->stream && !pipe_ctx->stream->dpms_off)
 				core_link_disable_stream(pipe_ctx_old, FREE_ACQUIRED_RESOURCE);
 
 			pipe_ctx_old->stream_res.tg->funcs->set_blank(pipe_ctx_old->stream_res.tg, true);

commit 8feabd03d34e4555c119e69269dae28f52e0d86c
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Mon Oct 2 14:39:42 2017 -0400

    drm/amd/display: rename struct mem_input to hubp for dcn
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index bf7318246401..867a0eb9f2e0 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1378,15 +1378,14 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	}
 
 	/* mst support - use total stream count */
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	if (pipe_ctx->plane_res.mi->funcs->allocate_mem_input != NULL)
-#endif
+	if (pipe_ctx->plane_res.mi != NULL) {
 		pipe_ctx->plane_res.mi->funcs->allocate_mem_input(
-					pipe_ctx->plane_res.mi,
-					stream->timing.h_total,
-					stream->timing.v_total,
-					stream->timing.pix_clk_khz,
-					context->stream_count);
+				pipe_ctx->plane_res.mi,
+				stream->timing.h_total,
+				stream->timing.v_total,
+				stream->timing.pix_clk_khz,
+				context->stream_count);
+	}
 
 	pipe_ctx->stream->sink->link->psr_enabled = false;
 
@@ -1556,7 +1555,7 @@ static void set_safe_displaymarks(
 		SAFE_NBP_MARK, SAFE_NBP_MARK, SAFE_NBP_MARK, SAFE_NBP_MARK };
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (res_ctx->pipe_ctx[i].stream == NULL)
+		if (res_ctx->pipe_ctx[i].stream == NULL || res_ctx->pipe_ctx[i].plane_res.mi == NULL)
 			continue;
 
 		res_ctx->pipe_ctx[i].plane_res.mi->funcs->mem_input_program_display_marks(
@@ -1565,6 +1564,7 @@ static void set_safe_displaymarks(
 				max_marks,
 				max_marks,
 				MAX_WATERMARK);
+
 		if (i == underlay_idx)
 			res_ctx->pipe_ctx[i].plane_res.mi->funcs->mem_input_program_chroma_display_marks(
 				res_ctx->pipe_ctx[i].plane_res.mi,
@@ -1572,6 +1572,7 @@ static void set_safe_displaymarks(
 				max_marks,
 				max_marks,
 				MAX_WATERMARK);
+
 	}
 }
 

commit 067c878a220cbe6198b3cfdc7f372adab4762ad8
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Oct 3 15:03:49 2017 -0400

    drm/amd/display: Fixed switching mode half screen gamma incorrect.
    
            Half screen gamma setting and cursor are incorrect
            when switching mode through win+p due to wrong programming
            gamma sequence (In case of bottom pipe, gamma and cursor are
            programmed before front end programmed, pipe is power gated).
    
            change:
            1. Cache curor attributes to stream
            2. Move set gamma and cursor inside front end
               programming.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 81ebf2b9c71d..bf7318246401 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2725,6 +2725,8 @@ static void dce110_program_front_end_for_pipe(
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
+	struct pipe_ctx *cur_pipe_ctx =
+					&dc->current_state->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
 	unsigned int i;
 
 	memset(&tbl_entry, 0, sizeof(tbl_entry));
@@ -2815,6 +2817,14 @@ static void dce110_program_front_end_for_pipe(
 				&plane_state->tiling_info,
 				plane_state->rotation);
 
+	/* Moved programming gamma from dc to hwss */
+	if (cur_pipe_ctx->plane_state != pipe_ctx->plane_state) {
+		dc->hwss.set_input_transfer_func(
+				pipe_ctx, pipe_ctx->plane_state);
+		dc->hwss.set_output_transfer_func(
+				pipe_ctx, pipe_ctx->stream);
+	}
+
 	dm_logger_write(dc->ctx->logger, LOG_SURFACE,
 			"Pipe:%d 0x%x: addr hi:0x%x, "
 			"addr low:0x%x, "

commit d050f8ed14494ea23c6e10b5893010946ef0f78b
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Fri Sep 29 16:36:34 2017 -0400

    drm/amd/display: add dpms state to DC
    
    - avoid eDP screen flash 4 times when resume from s3
    - improve s3 and boot time
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 453d2ffd5c4a..81ebf2b9c71d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1364,12 +1364,8 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	resource_build_info_frame(pipe_ctx);
 	dce110_update_info_frame(pipe_ctx);
 	if (!pipe_ctx_old->stream) {
-		core_link_enable_stream(context, pipe_ctx);
-
-
-		if (dc_is_dp_signal(pipe_ctx->stream->signal))
-			dce110_unblank_stream(pipe_ctx,
-				&stream->sink->link->cur_link_settings);
+		if (!pipe_ctx->stream->dpms_off)
+			core_link_enable_stream(context, pipe_ctx);
 	}
 
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
@@ -1879,7 +1875,10 @@ static void dce110_reset_hw_ctx_wrap(
 				pipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {
 			struct clock_source *old_clk = pipe_ctx_old->clock_source;
 
-			core_link_disable_stream(pipe_ctx_old, FREE_ACQUIRED_RESOURCE);
+			/* disable already, no need to disable again */
+			if (!pipe_ctx->stream->dpms_off)
+				core_link_disable_stream(pipe_ctx_old, FREE_ACQUIRED_RESOURCE);
+
 			pipe_ctx_old->stream_res.tg->funcs->set_blank(pipe_ctx_old->stream_res.tg, true);
 			if (!hwss_wait_for_blank_complete(pipe_ctx_old->stream_res.tg)) {
 				dm_error("DC: failed to blank crtc!\n");

commit 4176664b1fc8aa052f886037590cac4fb0dd8afb
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Sep 27 23:23:16 2017 -0400

    drm/amd/display: audio dynamic resource acquired related
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 247e81806c4a..453d2ffd5c4a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -985,10 +985,11 @@ void hwss_edp_backlight_control(
 	link_transmitter_control(link->dc->ctx->dc_bios, &cntl);
 }
 
-void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
+void dce110_disable_stream(struct pipe_ctx *pipe_ctx, int option)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->sink->link;
+	struct dc *dc = pipe_ctx->stream->ctx->dc;
 
 	if (pipe_ctx->stream_res.audio) {
 		pipe_ctx->stream_res.audio->funcs->az_disable(pipe_ctx->stream_res.audio);
@@ -999,6 +1000,13 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 		else
 			pipe_ctx->stream_res.stream_enc->funcs->hdmi_audio_disable(
 					pipe_ctx->stream_res.stream_enc);
+		/*don't free audio if it is from retrain or internal disable stream*/
+		if (option == FREE_ACQUIRED_RESOURCE && dc->caps.dynamic_audio == true) {
+			/*we have to dynamic arbitrate the audio endpoints*/
+			pipe_ctx->stream_res.audio = NULL;
+			/*we free the resource, need reset is_audio_acquired*/
+			update_audio_usage(&dc->current_state->res_ctx, dc->res_pool, pipe_ctx->stream_res.audio, false);
+		}
 
 		/* TODO: notify audio driver for if audio modes list changed
 		 * add audio mode list change flag */
@@ -1871,7 +1879,7 @@ static void dce110_reset_hw_ctx_wrap(
 				pipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {
 			struct clock_source *old_clk = pipe_ctx_old->clock_source;
 
-			core_link_disable_stream(pipe_ctx_old);
+			core_link_disable_stream(pipe_ctx_old, FREE_ACQUIRED_RESOURCE);
 			pipe_ctx_old->stream_res.tg->funcs->set_blank(pipe_ctx_old->stream_res.tg, true);
 			if (!hwss_wait_for_blank_complete(pipe_ctx_old->stream_res.tg)) {
 				dm_error("DC: failed to blank crtc!\n");

commit 3eab79163fcb0f7777440dfe360d2eedbbcc47b9
Author: Shirish S <shirish.s@amd.com>
Date:   Tue Sep 26 15:35:42 2017 +0530

    drm/amd/display: make FBC configurable option
    
    Currently FBC is guarded with ENABLE_FBC macro,
    which needs to be manually enabled in Makefile.
    
    This patch moves it to Kconfig so that there
    wont be any need to additional patch to be carried
    for enabling or disabling on every SoC.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index a891e387ed7b..247e81806c4a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -34,7 +34,7 @@
 #include "dce/dce_hwseq.h"
 #include "gpio_service_interface.h"
 
-#ifdef ENABLE_FBC
+#if defined(CONFIG_DRM_AMD_DC_FBC)
 #include "dce110_compressor.h"
 #endif
 
@@ -1445,7 +1445,7 @@ static void power_down_all_hw_blocks(struct dc *dc)
 
 	power_down_clock_sources(dc);
 
-#ifdef ENABLE_FBC
+#if defined(CONFIG_DRM_AMD_DC_FBC)
 	if (dc->fbc_compressor)
 		dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);
 #endif
@@ -1618,7 +1618,7 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
 	if (events->cursor_update)
 		value |= 0x2;
 
-#ifdef ENABLE_FBC
+#if defined(CONFIG_DRM_AMD_DC_FBC)
 	value |= 0x84;
 #endif
 
@@ -1748,7 +1748,7 @@ static void apply_min_clocks(
 	}
 }
 
-#ifdef ENABLE_FBC
+#if defined(CONFIG_DRM_AMD_DC_FBC)
 
 /*
  *  Check if FBC can be enabled
@@ -1940,7 +1940,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 
 	set_safe_displaymarks(&context->res_ctx, dc->res_pool);
 
-#ifdef ENABLE_FBC
+#if defined(CONFIG_DRM_AMD_DC_FBC)
 	if (dc->fbc_compressor)
 		dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);
 #endif
@@ -2124,7 +2124,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 
 	dcb->funcs->set_scratch_critical_state(dcb, false);
 
-#ifdef ENABLE_FBC
+#if defined(CONFIG_DRM_AMD_DC_FBC)
 	if (dc->fbc_compressor)
 		enable_fbc(dc, context);
 
@@ -2533,7 +2533,7 @@ static void init_hw(struct dc *dc)
 		abm->funcs->init_backlight(abm);
 		abm->funcs->abm_init(abm);
 	}
-#ifdef ENABLE_FBC
+#if defined(CONFIG_DRM_AMD_DC_FBC)
 	if (dc->fbc_compressor)
 		dc->fbc_compressor->funcs->power_up_fbc(dc->fbc_compressor);
 #endif
@@ -2781,7 +2781,7 @@ static void dce110_program_front_end_for_pipe(
 
 	program_scaler(dc, pipe_ctx);
 
-#ifdef ENABLE_FBC
+#if defined(CONFIG_DRM_AMD_DC_FBC)
 	if (dc->fbc_compressor && old_pipe->stream) {
 		if (plane_state->tiling_info.gfx8.array_mode == DC_ARRAY_LINEAR_GENERAL)
 			dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);

commit 8740196935625dfb171ab115120315060e4a8a41
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Mon Sep 25 18:03:14 2017 -0400

    drm/amd/display: Move power control from link encoder to hwsequencer
    
    A recent commit moved the backlight control code along with the register
    defines, but did not move the power control code. This along with
    remnant fields in the dce110_link_enc_registers struct made it so that
    the code still compiled, but any attempts to access the
    LVTMA_PWRSEQ_STATE register led to reading from an address of 0. This
    patch corrects that.
    
    Also, rename blacklight_control to edp_backlight_control (Typo fix).
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index f28fce6e6ba4..a891e387ed7b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -32,6 +32,7 @@
 #include "dce110_hw_sequencer.h"
 #include "dce110_timing_generator.h"
 #include "dce/dce_hwseq.h"
+#include "gpio_service_interface.h"
 
 #ifdef ENABLE_FBC
 #include "dce110_compressor.h"
@@ -45,10 +46,10 @@
 #include "transform.h"
 #include "stream_encoder.h"
 #include "link_encoder.h"
+#include "link_hwss.h"
 #include "clock_source.h"
 #include "abm.h"
 #include "audio.h"
-#include "dce/dce_hwseq.h"
 #include "reg_helper.h"
 
 /* include DCE11 register header files */
@@ -56,6 +57,15 @@
 #include "dce/dce_11_0_sh_mask.h"
 #include "custom_float.h"
 
+/*
+ * All values are in milliseconds;
+ * For eDP, after power-up/power/down,
+ * 300/500 msec max. delay from LCDVCC to black video generation
+ */
+#define PANEL_POWER_UP_TIMEOUT 300
+#define PANEL_POWER_DOWN_TIMEOUT 500
+#define HPD_CHECK_INTERVAL 10
+
 #define CTX \
 	hws->ctx
 #define REG(reg)\
@@ -780,25 +790,150 @@ static bool is_panel_backlight_on(struct dce_hwseq *hws)
 	return value;
 }
 
+static bool is_panel_powered_on(struct dce_hwseq *hws)
+{
+	uint32_t value;
+
+	REG_GET(LVTMA_PWRSEQ_STATE, LVTMA_PWRSEQ_TARGET_STATE_R, &value);
+	return value == 1;
+}
+
 static enum bp_result link_transmitter_control(
-		struct dc_link *link,
+		struct dc_bios *bios,
 	struct bp_transmitter_control *cntl)
 {
 	enum bp_result result;
-	struct dc_bios *bp = link->dc->ctx->dc_bios;
 
-	result = bp->funcs->transmitter_control(bp, cntl);
+	result = bios->funcs->transmitter_control(bios, cntl);
 
 	return result;
 }
 
+/*
+ * @brief
+ * eDP only.
+ */
+void hwss_edp_wait_for_hpd_ready(
+	struct link_encoder *enc,
+	bool power_up)
+{
+	struct dc_context *ctx = enc->ctx;
+	struct graphics_object_id connector = enc->connector;
+	struct gpio *hpd;
+	bool edp_hpd_high = false;
+	uint32_t time_elapsed = 0;
+	uint32_t timeout = power_up ?
+		PANEL_POWER_UP_TIMEOUT : PANEL_POWER_DOWN_TIMEOUT;
+
+	if (dal_graphics_object_id_get_connector_id(connector)
+			!= CONNECTOR_ID_EDP) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	if (!power_up)
+		/*
+		 * From KV, we will not HPD low after turning off VCC -
+		 * instead, we will check the SW timer in power_up().
+		 */
+		return;
+
+	/*
+	 * When we power on/off the eDP panel,
+	 * we need to wait until SENSE bit is high/low.
+	 */
+
+	/* obtain HPD */
+	/* TODO what to do with this? */
+	hpd = get_hpd_gpio(ctx->dc_bios, connector, ctx->gpio_service);
+
+	if (!hpd) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	dal_gpio_open(hpd, GPIO_MODE_INTERRUPT);
+
+	/* wait until timeout or panel detected */
+
+	do {
+		uint32_t detected = 0;
+
+		dal_gpio_get_value(hpd, &detected);
+
+		if (!(detected ^ power_up)) {
+			edp_hpd_high = true;
+			break;
+		}
+
+		msleep(HPD_CHECK_INTERVAL);
+
+		time_elapsed += HPD_CHECK_INTERVAL;
+	} while (time_elapsed < timeout);
+
+	dal_gpio_close(hpd);
+
+	dal_gpio_destroy_irq(&hpd);
+
+	if (false == edp_hpd_high) {
+		dm_logger_write(ctx->logger, LOG_ERROR,
+				"%s: wait timed out!\n", __func__);
+	}
+}
+
+void hwss_edp_power_control(
+	struct link_encoder *enc,
+	bool power_up)
+{
+	struct dc_context *ctx = enc->ctx;
+	struct dce_hwseq *hwseq = ctx->dc->hwseq;
+	struct bp_transmitter_control cntl = { 0 };
+	enum bp_result bp_result;
+
+
+	if (dal_graphics_object_id_get_connector_id(enc->connector)
+			!= CONNECTOR_ID_EDP) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	if (power_up != is_panel_powered_on(hwseq)) {
+		/* Send VBIOS command to prompt eDP panel power */
+
+		dm_logger_write(ctx->logger, LOG_HW_RESUME_S3,
+				"%s: Panel Power action: %s\n",
+				__func__, (power_up ? "On":"Off"));
+
+		cntl.action = power_up ?
+			TRANSMITTER_CONTROL_POWER_ON :
+			TRANSMITTER_CONTROL_POWER_OFF;
+		cntl.transmitter = enc->transmitter;
+		cntl.connector_obj_id = enc->connector;
+		cntl.coherent = false;
+		cntl.lanes_number = LANE_COUNT_FOUR;
+		cntl.hpd_sel = enc->hpd_source;
+
+		bp_result = link_transmitter_control(ctx->dc_bios, &cntl);
+
+		if (bp_result != BP_RESULT_OK)
+			dm_logger_write(ctx->logger, LOG_ERROR,
+					"%s: Panel Power bp_result: %d\n",
+					__func__, bp_result);
+	} else {
+		dm_logger_write(ctx->logger, LOG_HW_RESUME_S3,
+				"%s: Skipping Panel Power action: %s\n",
+				__func__, (power_up ? "On":"Off"));
+	}
+
+	hwss_edp_wait_for_hpd_ready(enc, true);
+}
 
 /*todo: cloned in stream enc, fix*/
 /*
  * @brief
  * eDP only. Control the backlight of the eDP panel
  */
-void hwss_blacklight_control(
+void hwss_edp_backlight_control(
 	struct dc_link *link,
 	bool enable)
 {
@@ -828,6 +963,7 @@ void hwss_blacklight_control(
 	cntl.action = enable ?
 		TRANSMITTER_CONTROL_BACKLIGHT_ON :
 		TRANSMITTER_CONTROL_BACKLIGHT_OFF;
+
 	/*cntl.engine_id = ctx->engine;*/
 	cntl.transmitter = link->link_enc->transmitter;
 	cntl.connector_obj_id = link->link_enc->connector;
@@ -846,7 +982,7 @@ void hwss_blacklight_control(
 	 * Enable it in the future if necessary.
 	 */
 	/* dc_service_sleep_in_milliseconds(50); */
-	link_transmitter_control(link, &cntl);
+	link_transmitter_control(link->dc->ctx->dc_bios, &cntl);
 }
 
 void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
@@ -886,7 +1022,7 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 	/* blank at encoder level */
 	if (dc_is_dp_signal(pipe_ctx->stream->signal)) {
 		if (pipe_ctx->stream->sink->link->connector_signal == SIGNAL_TYPE_EDP)
-			hwss_blacklight_control(link, false);
+			hwss_edp_backlight_control(link, false);
 		pipe_ctx->stream_res.stream_enc->funcs->dp_blank(pipe_ctx->stream_res.stream_enc);
 	}
 	link->link_enc->funcs->connect_dig_be_to_fe(
@@ -908,7 +1044,7 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 	params.link_settings.link_rate = link_settings->link_rate;
 	pipe_ctx->stream_res.stream_enc->funcs->dp_unblank(pipe_ctx->stream_res.stream_enc, &params);
 	if (link->connector_signal == SIGNAL_TYPE_EDP)
-		hwss_blacklight_control(link, true);
+		hwss_edp_backlight_control(link, true);
 }
 
 
@@ -2821,7 +2957,8 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.wait_for_mpcc_disconnect = dce110_wait_for_mpcc_disconnect,
 	.ready_shared_resources = ready_shared_resources,
 	.optimize_shared_resources = optimize_shared_resources,
-	.backlight_control = hwss_blacklight_control
+	.edp_backlight_control = hwss_edp_backlight_control,
+	.edp_power_control = hwss_edp_power_control,
 };
 
 void dce110_hw_sequencer_construct(struct dc *dc)

commit 19af33aca4384f840838a781f105726bb24c604f
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Sep 20 14:06:24 2017 -0400

    drm/amd/display: make sure BL off to mainlink off has enough time
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 9fc43bcac5bc..f28fce6e6ba4 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -819,13 +819,6 @@ void hwss_blacklight_control(
 		return;
 	}
 
-	if (!enable && !is_panel_backlight_on(hws)) {
-		dm_logger_write(ctx->logger, LOG_HW_RESUME_S3,
-				"%s: panel already powered down. Do nothing.\n",
-				__func__);
-		return;
-	}
-
 	/* Send VBIOS command to control eDP panel backlight */
 
 	dm_logger_write(ctx->logger, LOG_HW_RESUME_S3,

commit 5eefbc40173644b5f74d7e074ba6cd8de5563e05
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Fri Sep 15 17:42:20 2017 -0400

    drm/amd/display: moving backlight registers to hwsequencer
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index d83a330712f7..9fc43bcac5bc 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -56,6 +56,15 @@
 #include "dce/dce_11_0_sh_mask.h"
 #include "custom_float.h"
 
+#define CTX \
+	hws->ctx
+#define REG(reg)\
+	hws->regs->reg
+
+#undef FN
+#define FN(reg_name, field_name) \
+	hws->shifts->field_name, hws->masks->field_name
+
 struct dce110_hw_seq_reg_offsets {
 	uint32_t crtc;
 };
@@ -761,6 +770,92 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 
 }
 
+/*todo: cloned in stream enc, fix*/
+static bool is_panel_backlight_on(struct dce_hwseq *hws)
+{
+	uint32_t value;
+
+	REG_GET(LVTMA_PWRSEQ_CNTL, LVTMA_BLON, &value);
+
+	return value;
+}
+
+static enum bp_result link_transmitter_control(
+		struct dc_link *link,
+	struct bp_transmitter_control *cntl)
+{
+	enum bp_result result;
+	struct dc_bios *bp = link->dc->ctx->dc_bios;
+
+	result = bp->funcs->transmitter_control(bp, cntl);
+
+	return result;
+}
+
+
+/*todo: cloned in stream enc, fix*/
+/*
+ * @brief
+ * eDP only. Control the backlight of the eDP panel
+ */
+void hwss_blacklight_control(
+	struct dc_link *link,
+	bool enable)
+{
+	struct dce_hwseq *hws = link->dc->hwseq;
+	struct dc_context *ctx = link->dc->ctx;
+	struct bp_transmitter_control cntl = { 0 };
+
+	if (dal_graphics_object_id_get_connector_id(link->link_id)
+		!= CONNECTOR_ID_EDP) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	if (enable && is_panel_backlight_on(hws)) {
+		dm_logger_write(ctx->logger, LOG_HW_RESUME_S3,
+				"%s: panel already powered up. Do nothing.\n",
+				__func__);
+		return;
+	}
+
+	if (!enable && !is_panel_backlight_on(hws)) {
+		dm_logger_write(ctx->logger, LOG_HW_RESUME_S3,
+				"%s: panel already powered down. Do nothing.\n",
+				__func__);
+		return;
+	}
+
+	/* Send VBIOS command to control eDP panel backlight */
+
+	dm_logger_write(ctx->logger, LOG_HW_RESUME_S3,
+			"%s: backlight action: %s\n",
+			__func__, (enable ? "On":"Off"));
+
+	cntl.action = enable ?
+		TRANSMITTER_CONTROL_BACKLIGHT_ON :
+		TRANSMITTER_CONTROL_BACKLIGHT_OFF;
+	/*cntl.engine_id = ctx->engine;*/
+	cntl.transmitter = link->link_enc->transmitter;
+	cntl.connector_obj_id = link->link_enc->connector;
+	/*todo: unhardcode*/
+	cntl.lanes_number = LANE_COUNT_FOUR;
+	cntl.hpd_sel = link->link_enc->hpd_source;
+
+	/* For eDP, the following delays might need to be considered
+	 * after link training completed:
+	 * idle period - min. accounts for required BS-Idle pattern,
+	 * max. allows for source frame synchronization);
+	 * 50 msec max. delay from valid video data from source
+	 * to video on dislpay or backlight enable.
+	 *
+	 * Disable the delay for now.
+	 * Enable it in the future if necessary.
+	 */
+	/* dc_service_sleep_in_milliseconds(50); */
+	link_transmitter_control(link, &cntl);
+}
+
 void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
@@ -798,7 +893,7 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 	/* blank at encoder level */
 	if (dc_is_dp_signal(pipe_ctx->stream->signal)) {
 		if (pipe_ctx->stream->sink->link->connector_signal == SIGNAL_TYPE_EDP)
-			link->link_enc->funcs->backlight_control(link->link_enc, false);
+			hwss_blacklight_control(link, false);
 		pipe_ctx->stream_res.stream_enc->funcs->dp_blank(pipe_ctx->stream_res.stream_enc);
 	}
 	link->link_enc->funcs->connect_dig_be_to_fe(
@@ -820,7 +915,7 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 	params.link_settings.link_rate = link_settings->link_rate;
 	pipe_ctx->stream_res.stream_enc->funcs->dp_unblank(pipe_ctx->stream_res.stream_enc, &params);
 	if (link->connector_signal == SIGNAL_TYPE_EDP)
-			link->link_enc->funcs->backlight_control(link->link_enc, true);
+		hwss_blacklight_control(link, true);
 }
 
 
@@ -1184,7 +1279,7 @@ static void power_down_encoders(struct dc *dc)
 		}
 
 		dc->links[i]->link_enc->funcs->disable_output(
-				dc->links[i]->link_enc, signal);
+				dc->links[i]->link_enc, signal, dc->links[i]);
 	}
 }
 
@@ -2733,7 +2828,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.wait_for_mpcc_disconnect = dce110_wait_for_mpcc_disconnect,
 	.ready_shared_resources = ready_shared_resources,
 	.optimize_shared_resources = optimize_shared_resources,
-
+	.backlight_control = hwss_blacklight_control
 };
 
 void dce110_hw_sequencer_construct(struct dc *dc)

commit 68d77dd8214e5186d535ec7af29722aaad621824
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Wed Sep 13 11:36:34 2017 -0400

    drm/amd/display: power_down_Hw need signal type to turnoff backlight
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 590b2ad37105..d83a330712f7 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1171,6 +1171,7 @@ static void power_down_encoders(struct dc *dc)
 {
 	int i;
 	enum connector_id connector_id;
+	enum signal_type signal = SIGNAL_TYPE_NONE;
 	for (i = 0; i < dc->link_count; i++) {
 		connector_id = dal_graphics_object_id_get_connector_id(dc->links[i]->link_id);
 		if ((connector_id == CONNECTOR_ID_DISPLAY_PORT) ||
@@ -1178,10 +1179,12 @@ static void power_down_encoders(struct dc *dc)
 
 			if (!dc->links[i]->wa_flags.dp_keep_receiver_powered)
 				dp_receiver_power_ctrl(dc->links[i], false);
+			if (connector_id == CONNECTOR_ID_EDP)
+				signal = SIGNAL_TYPE_EDP;
 		}
 
 		dc->links[i]->link_enc->funcs->disable_output(
-				dc->links[i]->link_enc, SIGNAL_TYPE_NONE);
+				dc->links[i]->link_enc, signal);
 	}
 }
 

commit e008b0bcc63793d3e42fd88f412a90f329a05865
Author: Roman Li <Roman.Li@amd.com>
Date:   Thu Sep 7 17:02:47 2017 -0400

    drm/amd/display: Add FBC on/off to front-end programming
    
    - Fixing text mode for cases when VT-switch doesn't result
    in timing change
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index b3448a41718e..590b2ad37105 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2554,6 +2554,15 @@ static void dce110_program_front_end_for_pipe(
 
 	program_scaler(dc, pipe_ctx);
 
+#ifdef ENABLE_FBC
+	if (dc->fbc_compressor && old_pipe->stream) {
+		if (plane_state->tiling_info.gfx8.array_mode == DC_ARRAY_LINEAR_GENERAL)
+			dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);
+		else
+			enable_fbc(dc, dc->current_state);
+	}
+#endif
+
 	mi->funcs->mem_input_program_surface_config(
 			mi,
 			plane_state->format,

commit 6bf520280f3621d458e2ef3bd3c48acb89a39af7
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Tue Sep 5 12:20:39 2017 -0400

    drm/amd/display: Driver message to SMU to indicate display off
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index de154329b049..b3448a41718e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1889,6 +1889,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 			return status;
 	}
 
+	/* pplib is notified if disp_num changed */
 	dc->hwss.set_bandwidth(dc, context, true);
 
 	/* to save power */
@@ -2683,7 +2684,7 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 	}
 }
 
-static void ready_shared_resources(struct dc *dc) {}
+static void ready_shared_resources(struct dc *dc, struct dc_state *context) {}
 
 static void optimize_shared_resources(struct dc *dc) {}
 

commit c13b408b81f8a101501d78ca499afee98e0f0ab9
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 14:34:39 2017 +1000

    amdgpu/dc: another round of dce/dcn construct cleanups.
    
    This removes any remaining pointless return codepaths from the
    DCE code.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 5bbfc34d6f01..de154329b049 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2723,10 +2723,8 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 
 };
 
-bool dce110_hw_sequencer_construct(struct dc *dc)
+void dce110_hw_sequencer_construct(struct dc *dc)
 {
 	dc->hwss = dce110_funcs;
-
-	return true;
 }
 

commit f6baff4d1a0e3235b4a8ffd755e257b998705419
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Sep 8 10:24:21 2017 -0400

    drm/amd/display: Change comments to bring in line with internal tree
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 37497e88a930..5bbfc34d6f01 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1439,13 +1439,11 @@ static uint32_t get_max_pixel_clock_for_all_paths(
 	return max_pix_clk;
 }
 
-/* Find clock state based on clock requested. if clock value is 0, simply
+/*
+ * Find clock state based on clock requested. if clock value is 0, simply
  * set clock state as requested without finding clock state by clock value
- *TODO: when dce120_hw_sequencer.c is created, override apply_min_clock.
- *
- * TODOFPGA  remove TODO after implement dal_display_clock_get_cur_clocks_value
- * etc support for dcn1.0
  */
+
 static void apply_min_clocks(
 	struct dc *dc,
 	struct dc_state *context,

commit 05230fa90d96523755ddad30972a25b6651de739
Author: Roman Li <Roman.Li@amd.com>
Date:   Tue Sep 5 18:23:46 2017 -0400

    drm/amd/display: Disable FBC for linear tiling
    
    - Fixing text console on FBC-enabled builds
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 31592e53f504..37497e88a930 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1552,6 +1552,10 @@ static enum dc_status validate_fbc(struct dc *dc,
 	if (pipe_ctx->stream->sink->link->psr_enabled)
 		return DC_ERROR_UNEXPECTED;
 
+	/* Only for non-linear tiling */
+	if (pipe_ctx->plane_state->tiling_info.gfx8.array_mode == DC_ARRAY_LINEAR_GENERAL)
+		return DC_ERROR_UNEXPECTED;
+
 	return DC_OK;
 }
 

commit 21e67d4d52ca8688feb8c4f6e6d29b2d16d578ad
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 5 15:50:48 2017 -0400

    drm/amd/display: No need to keep track of unreffed clk sources
    
    This simplifies clock source reprogramming a bit.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index c57dc45d6677..31592e53f504 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1640,6 +1640,8 @@ static void dce110_reset_hw_ctx_wrap(
 
 		if (!pipe_ctx->stream ||
 				pipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {
+			struct clock_source *old_clk = pipe_ctx_old->clock_source;
+
 			core_link_disable_stream(pipe_ctx_old);
 			pipe_ctx_old->stream_res.tg->funcs->set_blank(pipe_ctx_old->stream_res.tg, true);
 			if (!hwss_wait_for_blank_complete(pipe_ctx_old->stream_res.tg)) {
@@ -1650,27 +1652,14 @@ static void dce110_reset_hw_ctx_wrap(
 			pipe_ctx_old->plane_res.mi->funcs->free_mem_input(
 					pipe_ctx_old->plane_res.mi, dc->current_state->stream_count);
 
+			if (old_clk)
+				old_clk->funcs->cs_power_down(old_clk);
+
 			dc->hwss.power_down_front_end(dc, pipe_ctx_old->pipe_idx);
 
 			pipe_ctx_old->stream = NULL;
 		}
 	}
-
-	/* power down changed clock sources */
-	for (i = 0; i < dc->res_pool->clk_src_count; i++)
-		if (context->res_ctx.clock_source_changed[i]) {
-			struct clock_source *clk = dc->res_pool->clock_sources[i];
-
-			clk->funcs->cs_power_down(clk);
-			context->res_ctx.clock_source_changed[i] = false;
-		}
-
-	if (context->res_ctx.dp_clock_source_changed) {
-		struct clock_source *clk = dc->res_pool->dp_clock_source;
-
-		clk->funcs->cs_power_down(clk);
-		context->res_ctx.clock_source_changed[i] = false;
-	}
 }
 
 

commit b8ea60cea245e8cd68b6ac45b9680a590f76391a
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Aug 28 19:44:38 2017 -0400

    drm/amd/display: Remove switching of clk sources at end of commit
    
    This should be taken care of in validate now.
    
    All of timing sync is quite broken at the moment anyways. Will submit
    another patch set to address that.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 96db166b7fba..c57dc45d6677 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1344,40 +1344,6 @@ static void set_safe_displaymarks(
 	}
 }
 
-static void switch_dp_clock_sources(
-	const struct dc *dc,
-	struct resource_context *res_ctx)
-{
-	uint8_t i;
-	for (i = 0; i < MAX_PIPES; i++) {
-		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
-
-		if (pipe_ctx->stream == NULL || pipe_ctx->top_pipe)
-			continue;
-
-		if (dc_is_dp_signal(pipe_ctx->stream->signal)) {
-			struct clock_source *clk_src =
-				resource_find_used_clk_src_for_sharing(
-						res_ctx, pipe_ctx);
-
-			if (clk_src &&
-				clk_src != pipe_ctx->clock_source) {
-				if (resource_unreference_clock_source(res_ctx,
-				    dc->res_pool, pipe_ctx->clock_source)) {
-					pipe_ctx->clock_source->funcs->cs_power_down(pipe_ctx->clock_source);
-					pipe_ctx->clock_source = NULL;
-				}
-
-				pipe_ctx->clock_source = clk_src;
-				resource_reference_clock_source(
-						res_ctx, dc->res_pool, clk_src);
-
-				dce_crtc_switch_to_clk_src(dc->hwseq, clk_src, i);
-			}
-		}
-	}
-}
-
 /*******************************************************************************
  * Public functions
  ******************************************************************************/
@@ -1939,8 +1905,6 @@ enum dc_status dce110_apply_ctx_to_hw(
 
 	dcb->funcs->set_scratch_critical_state(dcb, false);
 
-	switch_dp_clock_sources(dc, &context->res_ctx);
-
 #ifdef ENABLE_FBC
 	if (dc->fbc_compressor)
 		enable_fbc(dc, context);

commit 9d0dcecd93e4997c65b18404f1ab2fce2ab79010
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Aug 28 19:05:17 2017 -0400

    drm/amd/display: Power down clock source at commit
    
    Still one more in dc_validate_global
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 75c636cba545..96db166b7fba 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1683,18 +1683,28 @@ static void dce110_reset_hw_ctx_wrap(
 			pipe_ctx_old->stream_res.tg->funcs->disable_crtc(pipe_ctx_old->stream_res.tg);
 			pipe_ctx_old->plane_res.mi->funcs->free_mem_input(
 					pipe_ctx_old->plane_res.mi, dc->current_state->stream_count);
-			if (resource_unreference_clock_source(
-					&dc->current_state->res_ctx, dc->res_pool,
-					pipe_ctx_old->clock_source)) {
-				pipe_ctx_old->clock_source->funcs->cs_power_down(pipe_ctx_old->clock_source);
-				pipe_ctx_old->clock_source = NULL;
-			}
 
 			dc->hwss.power_down_front_end(dc, pipe_ctx_old->pipe_idx);
 
 			pipe_ctx_old->stream = NULL;
 		}
 	}
+
+	/* power down changed clock sources */
+	for (i = 0; i < dc->res_pool->clk_src_count; i++)
+		if (context->res_ctx.clock_source_changed[i]) {
+			struct clock_source *clk = dc->res_pool->clock_sources[i];
+
+			clk->funcs->cs_power_down(clk);
+			context->res_ctx.clock_source_changed[i] = false;
+		}
+
+	if (context->res_ctx.dp_clock_source_changed) {
+		struct clock_source *clk = dc->res_pool->dp_clock_source;
+
+		clk->funcs->cs_power_down(clk);
+		context->res_ctx.clock_source_changed[i] = false;
+	}
 }
 
 

commit 4a6295361c737a80e9f079952ac863a3b0c26acf
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Aug 28 18:43:45 2017 -0400

    drm/amd/display: Don't reset clock source at unref
    
    Powering down the clock source during unref is unsafe as we might want
    to unref during atomic_check
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index b36220bc619d..75c636cba545 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1362,9 +1362,12 @@ static void switch_dp_clock_sources(
 
 			if (clk_src &&
 				clk_src != pipe_ctx->clock_source) {
-				resource_unreference_clock_source(
-					res_ctx, dc->res_pool,
-					&pipe_ctx->clock_source);
+				if (resource_unreference_clock_source(res_ctx,
+				    dc->res_pool, pipe_ctx->clock_source)) {
+					pipe_ctx->clock_source->funcs->cs_power_down(pipe_ctx->clock_source);
+					pipe_ctx->clock_source = NULL;
+				}
+
 				pipe_ctx->clock_source = clk_src;
 				resource_reference_clock_source(
 						res_ctx, dc->res_pool, clk_src);
@@ -1680,9 +1683,12 @@ static void dce110_reset_hw_ctx_wrap(
 			pipe_ctx_old->stream_res.tg->funcs->disable_crtc(pipe_ctx_old->stream_res.tg);
 			pipe_ctx_old->plane_res.mi->funcs->free_mem_input(
 					pipe_ctx_old->plane_res.mi, dc->current_state->stream_count);
-			resource_unreference_clock_source(
+			if (resource_unreference_clock_source(
 					&dc->current_state->res_ctx, dc->res_pool,
-					&pipe_ctx_old->clock_source);
+					pipe_ctx_old->clock_source)) {
+				pipe_ctx_old->clock_source->funcs->cs_power_down(pipe_ctx_old->clock_source);
+				pipe_ctx_old->clock_source = NULL;
+			}
 
 			dc->hwss.power_down_front_end(dc, pipe_ctx_old->pipe_idx);
 

commit 603767f903bf5bf301728b197dcde63cf880fe2e
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Fri Sep 1 16:14:01 2017 -0400

    drm/amd/display: fix default dithering
    
    bug: default is mapped to no dithering.
    
    default to spatial dithering based on color depth
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 47e8b582445e..b36220bc619d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1104,15 +1104,11 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		stream->timing.timing_3d_format != TIMING_3D_FORMAT_NONE);
 
 
-/*vbios crtc_source_selection and encoder_setup will override fmt_C*/
-	if (pipe_ctx->stream->signal != SIGNAL_TYPE_EDP &&
-		pipe_ctx->stream->signal != SIGNAL_TYPE_LVDS) {
-	/*for embedded panel, don't override VBIOS's setting*/
-		pipe_ctx->stream_res.opp->funcs->opp_program_fmt(
-			pipe_ctx->stream_res.opp,
-			&stream->bit_depth_params,
-			&stream->clamping);
-	}
+	pipe_ctx->stream_res.opp->funcs->opp_program_fmt(
+		pipe_ctx->stream_res.opp,
+		&stream->bit_depth_params,
+		&stream->clamping);
+
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_res.stream_enc->funcs->dp_set_stream_attribute(
 			pipe_ctx->stream_res.stream_enc,

commit 1b7441b00a986cbed017a13ccf316efb54ab7a4b
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Fri Sep 1 12:51:47 2017 -0400

    drm/amd/display: fix crc_source_select use hardcoded color depth
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 9fb0ba7e7b7d..47e8b582445e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -667,7 +667,25 @@ static enum dc_status bios_parser_crtc_source_select(
 	crtc_source_select.signal = pipe_ctx->stream->signal;
 	crtc_source_select.enable_dp_audio = false;
 	crtc_source_select.sink_signal = pipe_ctx->stream->signal;
-	crtc_source_select.display_output_bit_depth = PANEL_8BIT_COLOR;
+
+	switch (pipe_ctx->stream->timing.display_color_depth) {
+	case COLOR_DEPTH_666:
+		crtc_source_select.display_output_bit_depth = PANEL_6BIT_COLOR;
+		break;
+	case COLOR_DEPTH_888:
+		crtc_source_select.display_output_bit_depth = PANEL_8BIT_COLOR;
+		break;
+	case COLOR_DEPTH_101010:
+		crtc_source_select.display_output_bit_depth = PANEL_10BIT_COLOR;
+		break;
+	case COLOR_DEPTH_121212:
+		crtc_source_select.display_output_bit_depth = PANEL_12BIT_COLOR;
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		crtc_source_select.display_output_bit_depth = PANEL_8BIT_COLOR;
+		break;
+	}
 
 	dcb = sink->ctx->dc_bios;
 

commit 1e4cee77bbd50d6c868439bfaf8ad61b6c6fcfc3
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Aug 28 19:35:25 2017 -0400

    drm/amd/display: add backlight control in blankstream.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 3b4ca1a9217f..9fb0ba7e7b7d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -778,9 +778,11 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 
 
 	/* blank at encoder level */
-	if (dc_is_dp_signal(pipe_ctx->stream->signal))
+	if (dc_is_dp_signal(pipe_ctx->stream->signal)) {
+		if (pipe_ctx->stream->sink->link->connector_signal == SIGNAL_TYPE_EDP)
+			link->link_enc->funcs->backlight_control(link->link_enc, false);
 		pipe_ctx->stream_res.stream_enc->funcs->dp_blank(pipe_ctx->stream_res.stream_enc);
-
+	}
 	link->link_enc->funcs->connect_dig_be_to_fe(
 			link->link_enc,
 			pipe_ctx->stream_res.stream_enc->id,
@@ -792,12 +794,15 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 		struct dc_link_settings *link_settings)
 {
 	struct encoder_unblank_param params = { { 0 } };
+	struct dc_link *link = pipe_ctx->stream->sink->link;
 
 	/* only 3 items below are used by unblank */
 	params.pixel_clk_khz =
 		pipe_ctx->stream->timing.pix_clk_khz;
 	params.link_settings.link_rate = link_settings->link_rate;
 	pipe_ctx->stream_res.stream_enc->funcs->dp_unblank(pipe_ctx->stream_res.stream_enc, &params);
+	if (link->connector_signal == SIGNAL_TYPE_EDP)
+			link->link_enc->funcs->backlight_control(link->link_enc, true);
 }
 
 

commit 1f0997f1555571a9c16205a851ffbce92097196d
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Aug 28 19:33:23 2017 -0400

    drm/amd/display: not override the FMT setting set by VBIOS for eDP
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 42caad423430..3b4ca1a9217f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1082,11 +1082,14 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 
 
 /*vbios crtc_source_selection and encoder_setup will override fmt_C*/
-	pipe_ctx->stream_res.opp->funcs->opp_program_fmt(
+	if (pipe_ctx->stream->signal != SIGNAL_TYPE_EDP &&
+		pipe_ctx->stream->signal != SIGNAL_TYPE_LVDS) {
+	/*for embedded panel, don't override VBIOS's setting*/
+		pipe_ctx->stream_res.opp->funcs->opp_program_fmt(
 			pipe_ctx->stream_res.opp,
 			&stream->bit_depth_params,
 			&stream->clamping);
-
+	}
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_res.stream_enc->funcs->dp_set_stream_attribute(
 			pipe_ctx->stream_res.stream_enc,

commit ab8db3e1653c50ae19d1c31d82f94beb5115aeef
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Mon Aug 28 14:25:01 2017 -0400

    drm/amd/display: Move dis_clk into dc_state.
    
    dis_clk is single instance across pipes.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 1c6e2006f2a1..42caad423430 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -828,6 +828,7 @@ static enum audio_dto_source translate_to_dto_source(enum controller_id crtc_id)
 }
 
 static void build_audio_output(
+	struct dc_state *state,
 	const struct pipe_ctx *pipe_ctx,
 	struct audio_output *audio_output)
 {
@@ -889,8 +890,8 @@ static void build_audio_output(
 	if (pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT ||
 			pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {
 		audio_output->pll_info.dp_dto_source_clock_in_khz =
-				pipe_ctx->dis_clk->funcs->get_dp_ref_clk_frequency(
-						pipe_ctx->dis_clk);
+				state->dis_clk->funcs->get_dp_ref_clk_frequency(
+						state->dis_clk);
 	}
 
 	audio_output->pll_info.feed_back_divider =
@@ -1109,7 +1110,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	resource_build_info_frame(pipe_ctx);
 	dce110_update_info_frame(pipe_ctx);
 	if (!pipe_ctx_old->stream) {
-		core_link_enable_stream(pipe_ctx);
+		core_link_enable_stream(context, pipe_ctx);
 
 
 		if (dc_is_dp_signal(pipe_ctx->stream->signal))
@@ -1461,42 +1462,34 @@ static void apply_min_clocks(
 	bool pre_mode_set)
 {
 	struct state_dependent_clocks req_clocks = {0};
-	struct pipe_ctx *pipe_ctx;
-	int i;
-
-	for (i = 0; i < MAX_PIPES; i++) {
-		pipe_ctx = &context->res_ctx.pipe_ctx[i];
-		if (pipe_ctx->dis_clk != NULL)
-			break;
-	}
 
 	if (!pre_mode_set) {
 		/* set clock_state without verification */
-		if (pipe_ctx->dis_clk->funcs->set_min_clocks_state) {
-			pipe_ctx->dis_clk->funcs->set_min_clocks_state(
-						pipe_ctx->dis_clk, *clocks_state);
+		if (context->dis_clk->funcs->set_min_clocks_state) {
+			context->dis_clk->funcs->set_min_clocks_state(
+						context->dis_clk, *clocks_state);
 			return;
 		}
 
 		/* TODO: This is incorrect. Figure out how to fix. */
-		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
-				pipe_ctx->dis_clk,
+		context->dis_clk->funcs->apply_clock_voltage_request(
+				context->dis_clk,
 				DM_PP_CLOCK_TYPE_DISPLAY_CLK,
-				pipe_ctx->dis_clk->cur_clocks_value.dispclk_in_khz,
+				context->dis_clk->cur_clocks_value.dispclk_in_khz,
 				pre_mode_set,
 				false);
 
-		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
-				pipe_ctx->dis_clk,
+		context->dis_clk->funcs->apply_clock_voltage_request(
+				context->dis_clk,
 				DM_PP_CLOCK_TYPE_PIXELCLK,
-				pipe_ctx->dis_clk->cur_clocks_value.max_pixelclk_in_khz,
+				context->dis_clk->cur_clocks_value.max_pixelclk_in_khz,
 				pre_mode_set,
 				false);
 
-		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
-				pipe_ctx->dis_clk,
+		context->dis_clk->funcs->apply_clock_voltage_request(
+				context->dis_clk,
 				DM_PP_CLOCK_TYPE_DISPLAYPHYCLK,
-				pipe_ctx->dis_clk->cur_clocks_value.max_non_dp_phyclk_in_khz,
+				context->dis_clk->cur_clocks_value.max_non_dp_phyclk_in_khz,
 				pre_mode_set,
 				false);
 		return;
@@ -1510,28 +1503,28 @@ static void apply_min_clocks(
 	req_clocks.pixel_clk_khz = get_max_pixel_clock_for_all_paths(
 			dc, context, true);
 
-	if (pipe_ctx->dis_clk->funcs->get_required_clocks_state) {
-		*clocks_state = pipe_ctx->dis_clk->funcs->get_required_clocks_state(
-				pipe_ctx->dis_clk, &req_clocks);
-		pipe_ctx->dis_clk->funcs->set_min_clocks_state(
-			pipe_ctx->dis_clk, *clocks_state);
+	if (context->dis_clk->funcs->get_required_clocks_state) {
+		*clocks_state = context->dis_clk->funcs->get_required_clocks_state(
+				context->dis_clk, &req_clocks);
+		context->dis_clk->funcs->set_min_clocks_state(
+			context->dis_clk, *clocks_state);
 	} else {
-		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
-				pipe_ctx->dis_clk,
+		context->dis_clk->funcs->apply_clock_voltage_request(
+				context->dis_clk,
 				DM_PP_CLOCK_TYPE_DISPLAY_CLK,
 				req_clocks.display_clk_khz,
 				pre_mode_set,
 				false);
 
-		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
-				pipe_ctx->dis_clk,
+		context->dis_clk->funcs->apply_clock_voltage_request(
+				context->dis_clk,
 				DM_PP_CLOCK_TYPE_PIXELCLK,
 				req_clocks.pixel_clk_khz,
 				pre_mode_set,
 				false);
 
-		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
-				pipe_ctx->dis_clk,
+		context->dis_clk->funcs->apply_clock_voltage_request(
+				context->dis_clk,
 				DM_PP_CLOCK_TYPE_DISPLAYPHYCLK,
 				req_clocks.pixel_clk_khz,
 				pre_mode_set,
@@ -1806,7 +1799,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 		if (pipe_ctx->stream_res.audio != NULL) {
 			struct audio_output audio_output;
 
-			build_audio_output(pipe_ctx, &audio_output);
+			build_audio_output(context, pipe_ctx, &audio_output);
 
 			pipe_ctx->stream_res.audio->funcs->wall_dto_setup(
 				pipe_ctx->stream_res.audio,
@@ -1834,7 +1827,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 			if (pipe_ctx->stream_res.audio != NULL) {
 				struct audio_output audio_output;
 
-				build_audio_output(pipe_ctx, &audio_output);
+				build_audio_output(context, pipe_ctx, &audio_output);
 
 				pipe_ctx->stream_res.audio->funcs->wall_dto_setup(
 					pipe_ctx->stream_res.audio,
@@ -1868,7 +1861,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 
 			struct audio_output audio_output;
 
-			build_audio_output(pipe_ctx, &audio_output);
+			build_audio_output(context, pipe_ctx, &audio_output);
 
 			if (dc_is_dp_signal(pipe_ctx->stream->signal))
 				pipe_ctx->stream_res.stream_enc->funcs->dp_audio_setup(

commit 608ac7bb3924178d7bfa8b88d79d3d9d72b8f485
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Fri Aug 25 16:16:10 2017 -0400

    drm/amd/display: Rename dc validate_context and current_context
    
    Rename all the dc validate_context to dc_stateand
    dc current_context to current_state.
    
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 3502faa1458f..1c6e2006f2a1 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -976,11 +976,11 @@ static void program_scaler(const struct dc *dc,
 
 static enum dc_status dce110_prog_pixclk_crtc_otg(
 		struct pipe_ctx *pipe_ctx,
-		struct validate_context *context,
+		struct dc_state *context,
 		struct dc *dc)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
-	struct pipe_ctx *pipe_ctx_old = &dc->current_context->res_ctx.
+	struct pipe_ctx *pipe_ctx_old = &dc->current_state->res_ctx.
 			pipe_ctx[pipe_ctx->pipe_idx];
 	struct tg_color black_color = {0};
 
@@ -1032,11 +1032,11 @@ static enum dc_status dce110_prog_pixclk_crtc_otg(
 
 static enum dc_status apply_single_controller_ctx_to_hw(
 		struct pipe_ctx *pipe_ctx,
-		struct validate_context *context,
+		struct dc_state *context,
 		struct dc *dc)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
-	struct pipe_ctx *pipe_ctx_old = &dc->current_context->res_ctx.
+	struct pipe_ctx *pipe_ctx_old = &dc->current_state->res_ctx.
 			pipe_ctx[pipe_ctx->pipe_idx];
 
 	/*  */
@@ -1257,7 +1257,7 @@ static uint32_t compute_pstate_blackout_duration(
 
 void dce110_set_displaymarks(
 	const struct dc *dc,
-	struct validate_context *context)
+	struct dc_state *context)
 {
 	uint8_t i, num_pipes;
 	unsigned int underlay_idx = dc->res_pool->underlay_pipe_index;
@@ -1415,7 +1415,7 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
  */
 static uint32_t get_max_pixel_clock_for_all_paths(
 	struct dc *dc,
-	struct validate_context *context,
+	struct dc_state *context,
 	bool pre_mode_set)
 {
 	uint32_t max_pix_clk = 0;
@@ -1456,7 +1456,7 @@ static uint32_t get_max_pixel_clock_for_all_paths(
  */
 static void apply_min_clocks(
 	struct dc *dc,
-	struct validate_context *context,
+	struct dc_state *context,
 	enum dm_pp_clocks_state *clocks_state,
 	bool pre_mode_set)
 {
@@ -1545,7 +1545,7 @@ static void apply_min_clocks(
  *  Check if FBC can be enabled
  */
 static enum dc_status validate_fbc(struct dc *dc,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	struct pipe_ctx *pipe_ctx =
 			      &context->res_ctx.pipe_ctx[0];
@@ -1575,7 +1575,7 @@ static enum dc_status validate_fbc(struct dc *dc,
  *  Enable FBC
  */
 static enum dc_status enable_fbc(struct dc *dc,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	enum dc_status status = validate_fbc(dc, context);
 
@@ -1604,14 +1604,14 @@ static enum dc_status enable_fbc(struct dc *dc,
 
 static enum dc_status apply_ctx_to_hw_fpga(
 		struct dc *dc,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	enum dc_status status = DC_ERROR_UNEXPECTED;
 	int i;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx_old =
-				&dc->current_context->res_ctx.pipe_ctx[i];
+				&dc->current_state->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->stream == NULL)
@@ -1634,7 +1634,7 @@ static enum dc_status apply_ctx_to_hw_fpga(
 
 static void dce110_reset_hw_ctx_wrap(
 		struct dc *dc,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	int i;
 
@@ -1642,7 +1642,7 @@ static void dce110_reset_hw_ctx_wrap(
 	/* look up the targets that have been removed since last commit */
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx_old =
-			&dc->current_context->res_ctx.pipe_ctx[i];
+			&dc->current_state->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		/* Note: We need to disable output if clock sources change,
@@ -1664,9 +1664,9 @@ static void dce110_reset_hw_ctx_wrap(
 			}
 			pipe_ctx_old->stream_res.tg->funcs->disable_crtc(pipe_ctx_old->stream_res.tg);
 			pipe_ctx_old->plane_res.mi->funcs->free_mem_input(
-					pipe_ctx_old->plane_res.mi, dc->current_context->stream_count);
+					pipe_ctx_old->plane_res.mi, dc->current_state->stream_count);
 			resource_unreference_clock_source(
-					&dc->current_context->res_ctx, dc->res_pool,
+					&dc->current_state->res_ctx, dc->res_pool,
 					&pipe_ctx_old->clock_source);
 
 			dc->hwss.power_down_front_end(dc, pipe_ctx_old->pipe_idx);
@@ -1679,7 +1679,7 @@ static void dce110_reset_hw_ctx_wrap(
 
 enum dc_status dce110_apply_ctx_to_hw(
 		struct dc *dc,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	struct dc_bios *dcb = dc->ctx->dc_bios;
 	enum dc_status status;
@@ -1705,7 +1705,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 	/* below is for real asic only */
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx_old =
-					&dc->current_context->res_ctx.pipe_ctx[i];
+					&dc->current_state->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->stream == NULL || pipe_ctx->top_pipe)
@@ -1735,31 +1735,31 @@ enum dc_status dce110_apply_ctx_to_hw(
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	if (dc->ctx->dce_version >= DCN_VERSION_1_0) {
 		if (context->bw.dcn.calc_clk.fclk_khz
-				> dc->current_context->bw.dcn.cur_clk.fclk_khz) {
+				> dc->current_state->bw.dcn.cur_clk.fclk_khz) {
 			struct dm_pp_clock_for_voltage_req clock;
 
 			clock.clk_type = DM_PP_CLOCK_TYPE_FCLK;
 			clock.clocks_in_khz = context->bw.dcn.calc_clk.fclk_khz;
 			dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
-			dc->current_context->bw.dcn.cur_clk.fclk_khz = clock.clocks_in_khz;
+			dc->current_state->bw.dcn.cur_clk.fclk_khz = clock.clocks_in_khz;
 			context->bw.dcn.cur_clk.fclk_khz = clock.clocks_in_khz;
 		}
 		if (context->bw.dcn.calc_clk.dcfclk_khz
-				> dc->current_context->bw.dcn.cur_clk.dcfclk_khz) {
+				> dc->current_state->bw.dcn.cur_clk.dcfclk_khz) {
 			struct dm_pp_clock_for_voltage_req clock;
 
 			clock.clk_type = DM_PP_CLOCK_TYPE_DCFCLK;
 			clock.clocks_in_khz = context->bw.dcn.calc_clk.dcfclk_khz;
 			dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
-			dc->current_context->bw.dcn.cur_clk.dcfclk_khz = clock.clocks_in_khz;
+			dc->current_state->bw.dcn.cur_clk.dcfclk_khz = clock.clocks_in_khz;
 			context->bw.dcn.cur_clk.dcfclk_khz = clock.clocks_in_khz;
 		}
 		if (context->bw.dcn.calc_clk.dispclk_khz
-				> dc->current_context->bw.dcn.cur_clk.dispclk_khz) {
+				> dc->current_state->bw.dcn.cur_clk.dispclk_khz) {
 			dc->res_pool->display_clock->funcs->set_clock(
 					dc->res_pool->display_clock,
 					context->bw.dcn.calc_clk.dispclk_khz);
-			dc->current_context->bw.dcn.cur_clk.dispclk_khz =
+			dc->current_state->bw.dcn.cur_clk.dispclk_khz =
 					context->bw.dcn.calc_clk.dispclk_khz;
 			context->bw.dcn.cur_clk.dispclk_khz =
 					context->bw.dcn.calc_clk.dispclk_khz;
@@ -1767,7 +1767,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 	} else
 #endif
 	if (context->bw.dce.dispclk_khz
-			> dc->current_context->bw.dce.dispclk_khz) {
+			> dc->current_state->bw.dce.dispclk_khz) {
 		dc->res_pool->display_clock->funcs->set_clock(
 				dc->res_pool->display_clock,
 				context->bw.dce.dispclk_khz * 115 / 100);
@@ -1848,7 +1848,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx_old =
-					&dc->current_context->res_ctx.pipe_ctx[i];
+					&dc->current_state->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->stream == NULL)
@@ -2327,7 +2327,7 @@ static void init_hw(struct dc *dc)
 }
 
 void dce110_fill_display_configs(
-	const struct validate_context *context,
+	const struct dc_state *context,
 	struct dm_pp_display_configuration *pp_display_cfg)
 {
 	int j;
@@ -2375,7 +2375,7 @@ void dce110_fill_display_configs(
 	pp_display_cfg->display_count = num_cfgs;
 }
 
-uint32_t dce110_get_min_vblank_time_us(const struct validate_context *context)
+uint32_t dce110_get_min_vblank_time_us(const struct dc_state *context)
 {
 	uint8_t j;
 	uint32_t min_vertical_blank_time = -1;
@@ -2427,7 +2427,7 @@ static int determine_sclk_from_bounding_box(
 
 static void pplib_apply_display_requirements(
 	struct dc *dc,
-	struct validate_context *context)
+	struct dc_state *context)
 {
 	struct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;
 
@@ -2481,16 +2481,16 @@ static void pplib_apply_display_requirements(
 
 static void dce110_set_bandwidth(
 		struct dc *dc,
-		struct validate_context *context,
+		struct dc_state *context,
 		bool decrease_allowed)
 {
 	dce110_set_displaymarks(dc, context);
 
-	if (decrease_allowed || context->bw.dce.dispclk_khz > dc->current_context->bw.dce.dispclk_khz) {
+	if (decrease_allowed || context->bw.dce.dispclk_khz > dc->current_state->bw.dce.dispclk_khz) {
 		dc->res_pool->display_clock->funcs->set_clock(
 				dc->res_pool->display_clock,
 				context->bw.dce.dispclk_khz * 115 / 100);
-		dc->current_context->bw.dce.dispclk_khz = context->bw.dce.dispclk_khz;
+		dc->current_state->bw.dce.dispclk_khz = context->bw.dce.dispclk_khz;
 	}
 
 	pplib_apply_display_requirements(dc, context);
@@ -2508,8 +2508,8 @@ static void dce110_program_front_end_for_pipe(
 
 	memset(&tbl_entry, 0, sizeof(tbl_entry));
 
-	if (dc->current_context)
-		old_pipe = &dc->current_context->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
+	if (dc->current_state)
+		old_pipe = &dc->current_state->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
 
 	memset(&adjust, 0, sizeof(adjust));
 	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
@@ -2627,7 +2627,7 @@ static void dce110_apply_ctx_for_surface(
 		struct dc *dc,
 		const struct dc_stream_state *stream,
 		int num_planes,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	int i, be_idx;
 
@@ -2657,7 +2657,7 @@ static void dce110_apply_ctx_for_surface(
 static void dce110_power_down_fe(struct dc *dc, int fe_idx)
 {
 	/* Do not power down fe when stream is active on dce*/
-	if (dc->current_context->res_ctx.pipe_ctx[fe_idx].stream)
+	if (dc->current_state->res_ctx.pipe_ctx[fe_idx].stream)
 		return;
 
 	dc->hwss.enable_display_power_gating(

commit 41f97c0773aed681ad65fa27ee88b503fbdcd298
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Thu Aug 24 17:40:00 2017 -0400

    drm/amd/display: DF C-state entry blocked when DPMS
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 8ba61b9b8792..3502faa1458f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2697,6 +2697,10 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 	}
 }
 
+static void ready_shared_resources(struct dc *dc) {}
+
+static void optimize_shared_resources(struct dc *dc) {}
+
 static const struct hw_sequencer_funcs dce110_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.program_csc_matrix = program_csc_matrix,
@@ -2727,7 +2731,10 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.prog_pixclk_crtc_otg = dce110_prog_pixclk_crtc_otg,
 	.setup_stereo = NULL,
 	.set_avmute = dce110_set_avmute,
-	.wait_for_mpcc_disconnect = dce110_wait_for_mpcc_disconnect
+	.wait_for_mpcc_disconnect = dce110_wait_for_mpcc_disconnect,
+	.ready_shared_resources = ready_shared_resources,
+	.optimize_shared_resources = optimize_shared_resources,
+
 };
 
 bool dce110_hw_sequencer_construct(struct dc *dc)

commit a0c38ebaa1fe99ea8d112d808d84a2e75194fcf6
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Aug 21 12:59:41 2017 -0400

    drm/amd/display: write dpcd 0x600 to 2 for DP/eDP when powerdown
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 7516c198d13a..8ba61b9b8792 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1147,8 +1147,16 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 static void power_down_encoders(struct dc *dc)
 {
 	int i;
-
+	enum connector_id connector_id;
 	for (i = 0; i < dc->link_count; i++) {
+		connector_id = dal_graphics_object_id_get_connector_id(dc->links[i]->link_id);
+		if ((connector_id == CONNECTOR_ID_DISPLAY_PORT) ||
+			(connector_id == CONNECTOR_ID_EDP)) {
+
+			if (!dc->links[i]->wa_flags.dp_keep_receiver_powered)
+				dp_receiver_power_ctrl(dc->links[i], false);
+		}
+
 		dc->links[i]->link_enc->funcs->disable_output(
 				dc->links[i]->link_enc, SIGNAL_TYPE_NONE);
 	}

commit 3005e437e70fd4d1da64d91b4ef027f62d3b9a41
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Thu Aug 17 16:24:11 2017 -0400

    drm/amd/display: re-enable audio after LT test
    
    [Description]
    Audio should be attached to the same pipe once it is attached.
    We will not remove audio endpoint in disable stream.
    We will reeanble the audio after automated link training test
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e6c6f1108078..7516c198d13a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -758,8 +758,6 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->stream_res.stream_enc->funcs->hdmi_audio_disable(
 					pipe_ctx->stream_res.stream_enc);
 
-		pipe_ctx->stream_res.audio = NULL;
-
 		/* TODO: notify audio driver for if audio modes list changed
 		 * add audio mode list change flag */
 		/* dal_audio_disable_azalia_audio_jack_presence(stream->audio,

commit fb3466a450cc4684654367ae2f47fc3fc7846574
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Aug 1 15:00:25 2017 -0400

    drm/amd/display: Flattening core_dc to dc
    
    -Flattening core_dc to dc
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index ccde7c80d658..e6c6f1108078 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -164,7 +164,7 @@ static void enable_display_pipe_clock_gating(
 }
 
 static bool dce110_enable_display_power_gating(
-	struct core_dc *dc,
+	struct dc *dc,
 	uint8_t controller_id,
 	struct dc_bios *dcb,
 	enum pipe_gating_control power_gating)
@@ -944,7 +944,7 @@ static void get_surface_visual_confirm_color(const struct pipe_ctx *pipe_ctx,
 	}
 }
 
-static void program_scaler(const struct core_dc *dc,
+static void program_scaler(const struct dc *dc,
 		const struct pipe_ctx *pipe_ctx)
 {
 	struct tg_color color = {0};
@@ -955,7 +955,7 @@ static void program_scaler(const struct core_dc *dc,
 		return;
 #endif
 
-	if (dc->public.debug.surface_visual_confirm)
+	if (dc->debug.surface_visual_confirm)
 		get_surface_visual_confirm_color(pipe_ctx, &color);
 	else
 		color_space_to_black_color(dc,
@@ -979,7 +979,7 @@ static void program_scaler(const struct core_dc *dc,
 static enum dc_status dce110_prog_pixclk_crtc_otg(
 		struct pipe_ctx *pipe_ctx,
 		struct validate_context *context,
-		struct core_dc *dc)
+		struct dc *dc)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct pipe_ctx *pipe_ctx_old = &dc->current_context->res_ctx.
@@ -1035,7 +1035,7 @@ static enum dc_status dce110_prog_pixclk_crtc_otg(
 static enum dc_status apply_single_controller_ctx_to_hw(
 		struct pipe_ctx *pipe_ctx,
 		struct validate_context *context,
-		struct core_dc *dc)
+		struct dc *dc)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct pipe_ctx *pipe_ctx_old = &dc->current_context->res_ctx.
@@ -1146,7 +1146,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 
 /******************************************************************************/
 
-static void power_down_encoders(struct core_dc *dc)
+static void power_down_encoders(struct dc *dc)
 {
 	int i;
 
@@ -1156,7 +1156,7 @@ static void power_down_encoders(struct core_dc *dc)
 	}
 }
 
-static void power_down_controllers(struct core_dc *dc)
+static void power_down_controllers(struct dc *dc)
 {
 	int i;
 
@@ -1166,7 +1166,7 @@ static void power_down_controllers(struct core_dc *dc)
 	}
 }
 
-static void power_down_clock_sources(struct core_dc *dc)
+static void power_down_clock_sources(struct dc *dc)
 {
 	int i;
 
@@ -1181,7 +1181,7 @@ static void power_down_clock_sources(struct core_dc *dc)
 	}
 }
 
-static void power_down_all_hw_blocks(struct core_dc *dc)
+static void power_down_all_hw_blocks(struct dc *dc)
 {
 	power_down_encoders(dc);
 
@@ -1196,7 +1196,7 @@ static void power_down_all_hw_blocks(struct core_dc *dc)
 }
 
 static void disable_vga_and_power_gate_all_controllers(
-		struct core_dc *dc)
+		struct dc *dc)
 {
 	int i;
 	struct timing_generator *tg;
@@ -1224,7 +1224,7 @@ static void disable_vga_and_power_gate_all_controllers(
  *  3. Enable power gating for controller
  *  4. Set acc_mode_change bit (VBIOS will clear this bit when going to FSDOS)
  */
-void dce110_enable_accelerated_mode(struct core_dc *dc)
+void dce110_enable_accelerated_mode(struct dc *dc)
 {
 	power_down_all_hw_blocks(dc);
 
@@ -1250,7 +1250,7 @@ static uint32_t compute_pstate_blackout_duration(
 }
 
 void dce110_set_displaymarks(
-	const struct core_dc *dc,
+	const struct dc *dc,
 	struct validate_context *context)
 {
 	uint8_t i, num_pipes;
@@ -1316,7 +1316,7 @@ static void set_safe_displaymarks(
 }
 
 static void switch_dp_clock_sources(
-	const struct core_dc *dc,
+	const struct dc *dc,
 	struct resource_context *res_ctx)
 {
 	uint8_t i;
@@ -1408,7 +1408,7 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
  * may read PLL register to get pixel clock
  */
 static uint32_t get_max_pixel_clock_for_all_paths(
-	struct core_dc *dc,
+	struct dc *dc,
 	struct validate_context *context,
 	bool pre_mode_set)
 {
@@ -1449,7 +1449,7 @@ static uint32_t get_max_pixel_clock_for_all_paths(
  * etc support for dcn1.0
  */
 static void apply_min_clocks(
-	struct core_dc *dc,
+	struct dc *dc,
 	struct validate_context *context,
 	enum dm_pp_clocks_state *clocks_state,
 	bool pre_mode_set)
@@ -1538,7 +1538,7 @@ static void apply_min_clocks(
 /*
  *  Check if FBC can be enabled
  */
-static enum dc_status validate_fbc(struct core_dc *dc,
+static enum dc_status validate_fbc(struct dc *dc,
 		struct validate_context *context)
 {
 	struct pipe_ctx *pipe_ctx =
@@ -1568,7 +1568,7 @@ static enum dc_status validate_fbc(struct core_dc *dc,
 /*
  *  Enable FBC
  */
-static enum dc_status enable_fbc(struct core_dc *dc,
+static enum dc_status enable_fbc(struct dc *dc,
 		struct validate_context *context)
 {
 	enum dc_status status = validate_fbc(dc, context);
@@ -1597,7 +1597,7 @@ static enum dc_status enable_fbc(struct core_dc *dc,
 #endif
 
 static enum dc_status apply_ctx_to_hw_fpga(
-		struct core_dc *dc,
+		struct dc *dc,
 		struct validate_context *context)
 {
 	enum dc_status status = DC_ERROR_UNEXPECTED;
@@ -1627,7 +1627,7 @@ static enum dc_status apply_ctx_to_hw_fpga(
 }
 
 static void dce110_reset_hw_ctx_wrap(
-		struct core_dc *dc,
+		struct dc *dc,
 		struct validate_context *context)
 {
 	int i;
@@ -1672,7 +1672,7 @@ static void dce110_reset_hw_ctx_wrap(
 
 
 enum dc_status dce110_apply_ctx_to_hw(
-		struct core_dc *dc,
+		struct dc *dc,
 		struct validate_context *context)
 {
 	struct dc_bios *dcb = dc->ctx->dc_bios;
@@ -1965,7 +1965,7 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
  * -------------------------------------------------|
  *
  ******************************************************************************/
-static void program_surface_visibility(const struct core_dc *dc,
+static void program_surface_visibility(const struct dc *dc,
 		struct pipe_ctx *pipe_ctx)
 {
 	enum blnd_mode blender_mode = BLND_MODE_CURRENT_PIPE;
@@ -2038,7 +2038,7 @@ static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
  * TODO REMOVE, USE UPDATE INSTEAD
  */
 static void set_plane_config(
-	const struct core_dc *dc,
+	const struct dc *dc,
 	struct pipe_ctx *pipe_ctx,
 	struct resource_context *res_ctx)
 {
@@ -2117,7 +2117,7 @@ static void set_plane_config(
 	if (mi->funcs->set_blank)
 		mi->funcs->set_blank(mi, pipe_ctx->plane_state->visible);
 
-	if (dc->public.config.gpu_vm_support)
+	if (dc->config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->plane_res.mi,
 				plane_state->format,
@@ -2125,7 +2125,7 @@ static void set_plane_config(
 				plane_state->rotation);
 }
 
-static void update_plane_addr(const struct core_dc *dc,
+static void update_plane_addr(const struct dc *dc,
 		struct pipe_ctx *pipe_ctx)
 {
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
@@ -2163,7 +2163,7 @@ void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)
 	}
 }
 
-void dce110_power_down(struct core_dc *dc)
+void dce110_power_down(struct dc *dc)
 {
 	power_down_all_hw_blocks(dc);
 	disable_vga_and_power_gate_all_controllers(dc);
@@ -2208,7 +2208,7 @@ static bool wait_for_reset_trigger_to_occur(
 
 /* Enable timing synchronization for a group of Timing Generators. */
 static void dce110_enable_timing_synchronization(
-		struct core_dc *dc,
+		struct dc *dc,
 		int group_index,
 		int group_size,
 		struct pipe_ctx *grouped_pipes[])
@@ -2257,7 +2257,7 @@ static void dce110_enable_timing_synchronization(
 	DC_SYNC_INFO("GSL: Set-up complete.\n");
 }
 
-static void init_hw(struct core_dc *dc)
+static void init_hw(struct dc *dc)
 {
 	int i;
 	struct dc_bios *bp;
@@ -2394,7 +2394,7 @@ uint32_t dce110_get_min_vblank_time_us(const struct validate_context *context)
 }
 
 static int determine_sclk_from_bounding_box(
-		const struct core_dc *dc,
+		const struct dc *dc,
 		int required_sclk)
 {
 	int i;
@@ -2420,7 +2420,7 @@ static int determine_sclk_from_bounding_box(
 }
 
 static void pplib_apply_display_requirements(
-	struct core_dc *dc,
+	struct dc *dc,
 	struct validate_context *context)
 {
 	struct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;
@@ -2474,7 +2474,7 @@ static void pplib_apply_display_requirements(
 }
 
 static void dce110_set_bandwidth(
-		struct core_dc *dc,
+		struct dc *dc,
 		struct validate_context *context,
 		bool decrease_allowed)
 {
@@ -2491,7 +2491,7 @@ static void dce110_set_bandwidth(
 }
 
 static void dce110_program_front_end_for_pipe(
-		struct core_dc *dc, struct pipe_ctx *pipe_ctx)
+		struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct mem_input *mi = pipe_ctx->plane_res.mi;
 	struct pipe_ctx *old_pipe = NULL;
@@ -2572,7 +2572,7 @@ static void dce110_program_front_end_for_pipe(
 	if (mi->funcs->set_blank)
 		mi->funcs->set_blank(mi, pipe_ctx->plane_state->visible);
 
-	if (dc->public.config.gpu_vm_support)
+	if (dc->config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->plane_res.mi,
 				plane_state->format,
@@ -2618,7 +2618,7 @@ static void dce110_program_front_end_for_pipe(
 }
 
 static void dce110_apply_ctx_for_surface(
-		struct core_dc *dc,
+		struct dc *dc,
 		const struct dc_stream_state *stream,
 		int num_planes,
 		struct validate_context *context)
@@ -2648,7 +2648,7 @@ static void dce110_apply_ctx_for_surface(
 	}
 }
 
-static void dce110_power_down_fe(struct core_dc *dc, int fe_idx)
+static void dce110_power_down_fe(struct dc *dc, int fe_idx)
 {
 	/* Do not power down fe when stream is active on dce*/
 	if (dc->current_context->res_ctx.pipe_ctx[fe_idx].stream)
@@ -2662,7 +2662,7 @@ static void dce110_power_down_fe(struct core_dc *dc, int fe_idx)
 }
 
 static void dce110_wait_for_mpcc_disconnect(
-		struct core_dc *dc,
+		struct dc *dc,
 		struct resource_pool *res_pool,
 		struct pipe_ctx *pipe_ctx)
 {
@@ -2724,7 +2724,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.wait_for_mpcc_disconnect = dce110_wait_for_mpcc_disconnect
 };
 
-bool dce110_hw_sequencer_construct(struct core_dc *dc)
+bool dce110_hw_sequencer_construct(struct dc *dc)
 {
 	dc->hwss = dce110_funcs;
 

commit 77a4ea53fd89ccf823e77cc31cea808a3589f732
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Aug 2 16:56:03 2017 -0400

    drm/amd/display: change bw_dceip and bw_vbios into pointers
    
    -Change bw_calcs_dceip into pointer
    -Change bw_calcs_vbios into pointer
    
    This is needed for flattening of core_dc into dc, as without this the
    diags build fails
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 5b46e776b9b7..ccde7c80d658 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1264,7 +1264,7 @@ void dce110_set_displaymarks(
 			continue;
 
 		total_dest_line_time_ns = compute_pstate_blackout_duration(
-			dc->bw_vbios.blackout_duration, pipe_ctx->stream);
+			dc->bw_vbios->blackout_duration, pipe_ctx->stream);
 		pipe_ctx->plane_res.mi->funcs->mem_input_program_display_marks(
 			pipe_ctx->plane_res.mi,
 			context->bw.dce.nbp_state_change_wm_ns[num_pipes],

commit a2607aef3d0210859d4e9cae6bba7e134ec720d8
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Aug 8 11:35:10 2017 -0400

    drm/amd/display: Fix regression in dce110_apply_ctx_for_surfaces
    
    Caused by "add programming for 0 plane case" which was tested on DCN but
    not on DCE.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index c29e51409286..5b46e776b9b7 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2639,7 +2639,7 @@ static void dce110_apply_ctx_for_surface(
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		if (pipe_ctx->stream == stream)
+		if (pipe_ctx->stream != stream)
 			continue;
 
 		dce110_program_front_end_for_pipe(dc, pipe_ctx);

commit f0c4d9977ae215859ff13304ef0fc02a8b779478
Author: Corbin McElhanney <corbin.mcelhanney@amd.com>
Date:   Thu Aug 3 14:20:14 2017 -0400

    drm/amd/display: fix HDMI 12bits last two bits are zero issue
    
    (FF-158) -[FF N-1] HDMI Deep Color Mode incorrect bit depth:
    FMT_DYNAMIC_EXP_EN is being reset to 0
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 59925723271e..c29e51409286 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1044,14 +1044,14 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	/*  */
 	dc->hwss.prog_pixclk_crtc_otg(pipe_ctx, context, dc);
 
-	pipe_ctx->stream_res.opp->funcs->opp_set_dyn_expansion(
-			pipe_ctx->stream_res.opp,
-			COLOR_SPACE_YCBCR601,
-			stream->timing.display_color_depth,
-			pipe_ctx->stream->signal);
-
 	/* FPGA does not program backend */
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
+		pipe_ctx->stream_res.opp->funcs->opp_set_dyn_expansion(
+		pipe_ctx->stream_res.opp,
+		COLOR_SPACE_YCBCR601,
+		stream->timing.display_color_depth,
+		pipe_ctx->stream->signal);
+
 	pipe_ctx->stream_res.opp->funcs->opp_program_fmt(
 			pipe_ctx->stream_res.opp,
 			&stream->bit_depth_params,
@@ -1064,6 +1064,11 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 			BREAK_TO_DEBUGGER();
 			return DC_ERROR_UNEXPECTED;
 		}
+	pipe_ctx->stream_res.opp->funcs->opp_set_dyn_expansion(
+			pipe_ctx->stream_res.opp,
+			COLOR_SPACE_YCBCR601,
+			stream->timing.display_color_depth,
+			pipe_ctx->stream->signal);
 
 	if (pipe_ctx->stream->signal != SIGNAL_TYPE_VIRTUAL)
 		stream->sink->link->link_enc->funcs->setup(

commit 3e9ad6164b98f82ff4b191980c502f09fee4deef
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Thu Aug 3 00:22:25 2017 -0400

    drm/amd/display: add programming for 0 plane case
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index d3368a8bd1d5..59925723271e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2614,18 +2614,27 @@ static void dce110_program_front_end_for_pipe(
 
 static void dce110_apply_ctx_for_surface(
 		struct core_dc *dc,
-		const struct dc_plane_state *plane_state,
+		const struct dc_stream_state *stream,
+		int num_planes,
 		struct validate_context *context)
 {
-	int i;
+	int i, be_idx;
 
-	if (!plane_state)
+	if (num_planes == 0)
 		return;
 
+	be_idx = -1;
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		if (stream == context->res_ctx.pipe_ctx[i].stream) {
+			be_idx = context->res_ctx.pipe_ctx[i].stream_res.tg->inst;
+			break;
+		}
+	}
+
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		if (pipe_ctx->plane_state != plane_state)
+		if (pipe_ctx->stream == stream)
 			continue;
 
 		dce110_program_front_end_for_pipe(dc, pipe_ctx);

commit 96c50c0d0cead772001fd4ab1861594c059e7e0f
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 15:58:26 2017 -0400

    drm/amd/display: Move encoder_info_frame to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipes->encoder_info_frame/pipes->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipe_with_clk_src->encoder_info_frame/pipe_with_clk_src->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/ctx->encoder_info_frame->/ctx->stream_res\.encoder_info_frame->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipe->encoder_info_frame/pipe->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipe_ctx->encoder_info_frame/pipe_ctx->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[pipe_offset\]\.encoder_info_frame/pipe_ctx\[pipe_offset\]\.stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[i\]->encoder_info_frame/grouped_pipes\[i\]->stream_^Cs\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[0\]->encoder_info_frame/grouped_pipes\[0\]->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[1\]->encoder_info_frame/grouped_pipes\[1\]->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]->encoder_info_frame/pipe_ctx\[i\]->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx_old->encoder_info_frame/pipe_ctx_old->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_set\[j\]->encoder_info_frame/pipe_set\[j\]->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]\.encoder_info_frame/pipe_ctx\[i\]\.stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipes\[i\]\.encoder_info_frame/pipes\[i\]\.stream_res\.encoder_info_frame/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 93161a92a427..d3368a8bd1d5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -690,11 +690,11 @@ void dce110_update_info_frame(struct pipe_ctx *pipe_ctx)
 	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_res.stream_enc->funcs->update_hdmi_info_packets(
 			pipe_ctx->stream_res.stream_enc,
-			&pipe_ctx->encoder_info_frame);
+			&pipe_ctx->stream_res.encoder_info_frame);
 	else if (dc_is_dp_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_res.stream_enc->funcs->update_dp_info_packets(
 			pipe_ctx->stream_res.stream_enc,
-			&pipe_ctx->encoder_info_frame);
+			&pipe_ctx->stream_res.encoder_info_frame);
 }
 
 void dce110_enable_stream(struct pipe_ctx *pipe_ctx)

commit 10688217e3af3ec73892139bed3d23a6e1170a14
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 15:17:43 2017 -0400

    drm/amd/display: Move pix_clk_params into stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipes->pix_clk_params/pipes->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipe_with_clk_src->pix_clk_params/pipe_with_clk_src->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/ctx->pix_clk_params->/ctx->stream_res\.pix_clk_params->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->pix_clk_params/pipe->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipe_ctx->pix_clk_params/pipe_ctx->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[pipe_offset\]\.pix_clk_params/pipe_ctx\[pipe_offset\]\.stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[i\]->pix_clk_params/grouped_pipes\[i\]->stream_^Cs\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[0\]->pix_clk_params/grouped_pipes\[0\]->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[1\]->pix_clk_params/grouped_pipes\[1\]->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]->pix_clk_params/pipe_ctx\[i\]->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx_old->pix_clk_params/pipe_ctx_old->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_set\[j\]->pix_clk_params/pipe_set\[j\]->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]\.pix_clk_params/pipe_ctx\[i\]\.stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipes\[i\]\.pix_clk_params/pipes\[i\]\.stream_res\.pix_clk_params/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index ef5d496656e5..93161a92a427 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -870,20 +870,20 @@ static void build_audio_output(
 		stream->timing.display_color_depth;
 
 	audio_output->crtc_info.requested_pixel_clock =
-			pipe_ctx->pix_clk_params.requested_pix_clk;
+			pipe_ctx->stream_res.pix_clk_params.requested_pix_clk;
 
 	audio_output->crtc_info.calculated_pixel_clock =
-			pipe_ctx->pix_clk_params.requested_pix_clk;
+			pipe_ctx->stream_res.pix_clk_params.requested_pix_clk;
 
 /*for HDMI, audio ACR is with deep color ratio factor*/
 	if (dc_is_hdmi_signal(pipe_ctx->stream->signal) &&
 		audio_output->crtc_info.requested_pixel_clock ==
 				stream->timing.pix_clk_khz) {
-		if (pipe_ctx->pix_clk_params.pixel_encoding == PIXEL_ENCODING_YCBCR420) {
+		if (pipe_ctx->stream_res.pix_clk_params.pixel_encoding == PIXEL_ENCODING_YCBCR420) {
 			audio_output->crtc_info.requested_pixel_clock =
 					audio_output->crtc_info.requested_pixel_clock/2;
 			audio_output->crtc_info.calculated_pixel_clock =
-					pipe_ctx->pix_clk_params.requested_pix_clk/2;
+					pipe_ctx->stream_res.pix_clk_params.requested_pix_clk/2;
 
 		}
 	}
@@ -1003,7 +1003,7 @@ static enum dc_status dce110_prog_pixclk_crtc_otg(
 
 		if (false == pipe_ctx->clock_source->funcs->program_pix_clk(
 				pipe_ctx->clock_source,
-				&pipe_ctx->pix_clk_params,
+				&pipe_ctx->stream_res.pix_clk_params,
 				&pipe_ctx->pll_settings)) {
 			BREAK_TO_DEBUGGER();
 			return DC_ERROR_UNEXPECTED;
@@ -1425,9 +1425,9 @@ static uint32_t get_max_pixel_clock_for_all_paths(
 		if (pipe_ctx->top_pipe)
 			continue;
 
-		if (pipe_ctx->pix_clk_params.requested_pix_clk > max_pix_clk)
+		if (pipe_ctx->stream_res.pix_clk_params.requested_pix_clk > max_pix_clk)
 			max_pix_clk =
-				pipe_ctx->pix_clk_params.requested_pix_clk;
+				pipe_ctx->stream_res.pix_clk_params.requested_pix_clk;
 	}
 
 	if (max_pix_clk == 0)

commit afaacef482759215681ad0a8c6a8b60cc7d29592
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 14:59:17 2017 -0400

    drm/amd/display: Move audio to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipes->audio/pipes->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipe_with_clk_src->audio/pipe_with_clk_src->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/ctx->audio->/ctx->stream_res\.audio->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->audio/pipe->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx->audio/pipe_ctx->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[pipe_offset\]\.audio/pipe_ctx\[pipe_offset\]\.stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[i\]->audio/grouped_pipes\[i\]->stream_^Cs\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[0\]->audio/grouped_pipes\[0\]->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[1\]->audio/grouped_pipes\[1\]->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]->audio/pipe_ctx\[i\]->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx_old->audio/pipe_ctx_old->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_set\[j\]->audio/pipe_set\[j\]->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]\.audio/pipe_ctx\[i\]\.stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipes\[i\]\.audio/pipes\[i\]\.stream_res\.audio/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 48d151039fe8..ef5d496656e5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -729,7 +729,7 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 	tg->funcs->set_early_control(tg, early_control);
 
 	/* enable audio only within mode set */
-	if (pipe_ctx->audio != NULL) {
+	if (pipe_ctx->stream_res.audio != NULL) {
 		if (dc_is_dp_signal(pipe_ctx->stream->signal))
 			pipe_ctx->stream_res.stream_enc->funcs->dp_audio_enable(pipe_ctx->stream_res.stream_enc);
 	}
@@ -748,8 +748,8 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->sink->link;
 
-	if (pipe_ctx->audio) {
-		pipe_ctx->audio->funcs->az_disable(pipe_ctx->audio);
+	if (pipe_ctx->stream_res.audio) {
+		pipe_ctx->stream_res.audio->funcs->az_disable(pipe_ctx->stream_res.audio);
 
 		if (dc_is_dp_signal(pipe_ctx->stream->signal))
 			pipe_ctx->stream_res.stream_enc->funcs->dp_audio_disable(
@@ -758,7 +758,7 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->stream_res.stream_enc->funcs->hdmi_audio_disable(
 					pipe_ctx->stream_res.stream_enc);
 
-		pipe_ctx->audio = NULL;
+		pipe_ctx->stream_res.audio = NULL;
 
 		/* TODO: notify audio driver for if audio modes list changed
 		 * add audio mode list change flag */
@@ -1094,7 +1094,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 			pipe_ctx->stream_res.stream_enc,
 			&stream->timing,
 			stream->phy_pix_clk,
-			pipe_ctx->audio != NULL);
+			pipe_ctx->stream_res.audio != NULL);
 
 	if (dc_is_dvi_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_res.stream_enc->funcs->dvi_set_stream_attribute(
@@ -1792,13 +1792,13 @@ enum dc_status dce110_apply_ctx_to_hw(
 		if (pipe_ctx->stream->signal != SIGNAL_TYPE_HDMI_TYPE_A)
 			continue;
 
-		if (pipe_ctx->audio != NULL) {
+		if (pipe_ctx->stream_res.audio != NULL) {
 			struct audio_output audio_output;
 
 			build_audio_output(pipe_ctx, &audio_output);
 
-			pipe_ctx->audio->funcs->wall_dto_setup(
-				pipe_ctx->audio,
+			pipe_ctx->stream_res.audio->funcs->wall_dto_setup(
+				pipe_ctx->stream_res.audio,
 				pipe_ctx->stream->signal,
 				&audio_output.crtc_info,
 				&audio_output.pll_info);
@@ -1820,13 +1820,13 @@ enum dc_status dce110_apply_ctx_to_hw(
 			if (!dc_is_dp_signal(pipe_ctx->stream->signal))
 				continue;
 
-			if (pipe_ctx->audio != NULL) {
+			if (pipe_ctx->stream_res.audio != NULL) {
 				struct audio_output audio_output;
 
 				build_audio_output(pipe_ctx, &audio_output);
 
-				pipe_ctx->audio->funcs->wall_dto_setup(
-					pipe_ctx->audio,
+				pipe_ctx->stream_res.audio->funcs->wall_dto_setup(
+					pipe_ctx->stream_res.audio,
 					pipe_ctx->stream->signal,
 					&audio_output.crtc_info,
 					&audio_output.pll_info);
@@ -1853,7 +1853,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 		if (pipe_ctx->top_pipe)
 			continue;
 
-		if (context->res_ctx.pipe_ctx[i].audio != NULL) {
+		if (context->res_ctx.pipe_ctx[i].stream_res.audio != NULL) {
 
 			struct audio_output audio_output;
 
@@ -1862,17 +1862,17 @@ enum dc_status dce110_apply_ctx_to_hw(
 			if (dc_is_dp_signal(pipe_ctx->stream->signal))
 				pipe_ctx->stream_res.stream_enc->funcs->dp_audio_setup(
 						pipe_ctx->stream_res.stream_enc,
-						pipe_ctx->audio->inst,
+						pipe_ctx->stream_res.audio->inst,
 						&pipe_ctx->stream->audio_info);
 			else
 				pipe_ctx->stream_res.stream_enc->funcs->hdmi_audio_setup(
 						pipe_ctx->stream_res.stream_enc,
-						pipe_ctx->audio->inst,
+						pipe_ctx->stream_res.audio->inst,
 						&pipe_ctx->stream->audio_info,
 						&audio_output.crtc_info);
 
-			pipe_ctx->audio->funcs->az_configure(
-					pipe_ctx->audio,
+			pipe_ctx->stream_res.audio->funcs->az_configure(
+					pipe_ctx->stream_res.audio,
 					pipe_ctx->stream->signal,
 					&audio_output.crtc_info,
 					&pipe_ctx->stream->audio_info);

commit 8e9c4c8cf35ff23aafc69f9ef4c9cc471dac4094
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 14:36:12 2017 -0400

    drm/amd/display: Move stream_enc to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipes->stream_enc/pipes->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/ctx->stream_enc->/ctx->stream_res\.stream_enc->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->stream_enc/pipe->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx->stream_enc/pipe_ctx->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[pipe_offset\]\.stream_enc/pipe_ctx\[pipe_offset\]\.stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[i\]->stream_enc/grouped_pipes\[i\]->stream_^Cs\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[0\]->stream_enc/grouped_pipes\[0\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[1\]->stream_enc/grouped_pipes\[1\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]->stream_enc/pipe_ctx\[i\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx_old->stream_enc/pipe_ctx_old->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_set\[j\]->stream_enc/pipe_set\[j\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]\.stream_enc/pipe_ctx\[i\]\.stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipes\[i\]\.stream_enc/pipes\[i\]\.stream_res\.stream_enc/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 1d7c7fb668be..48d151039fe8 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -659,7 +659,7 @@ static enum dc_status bios_parser_crtc_source_select(
 	struct bp_crtc_source_select crtc_source_select = {0};
 	const struct dc_sink *sink = pipe_ctx->stream->sink;
 
-	crtc_source_select.engine_id = pipe_ctx->stream_enc->id;
+	crtc_source_select.engine_id = pipe_ctx->stream_res.stream_enc->id;
 	crtc_source_select.controller_id = pipe_ctx->pipe_idx + 1;
 	/*TODO: Need to un-hardcode color depth, dp_audio and account for
 	 * the case where signal and sink signal is different (translator
@@ -684,16 +684,16 @@ void dce110_update_info_frame(struct pipe_ctx *pipe_ctx)
 {
 	ASSERT(pipe_ctx->stream);
 
-	if (pipe_ctx->stream_enc == NULL)
+	if (pipe_ctx->stream_res.stream_enc == NULL)
 		return;  /* this is not root pipe */
 
 	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
-		pipe_ctx->stream_enc->funcs->update_hdmi_info_packets(
-			pipe_ctx->stream_enc,
+		pipe_ctx->stream_res.stream_enc->funcs->update_hdmi_info_packets(
+			pipe_ctx->stream_res.stream_enc,
 			&pipe_ctx->encoder_info_frame);
 	else if (dc_is_dp_signal(pipe_ctx->stream->signal))
-		pipe_ctx->stream_enc->funcs->update_dp_info_packets(
-			pipe_ctx->stream_enc,
+		pipe_ctx->stream_res.stream_enc->funcs->update_dp_info_packets(
+			pipe_ctx->stream_res.stream_enc,
 			&pipe_ctx->encoder_info_frame);
 }
 
@@ -731,7 +731,7 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 	/* enable audio only within mode set */
 	if (pipe_ctx->audio != NULL) {
 		if (dc_is_dp_signal(pipe_ctx->stream->signal))
-			pipe_ctx->stream_enc->funcs->dp_audio_enable(pipe_ctx->stream_enc);
+			pipe_ctx->stream_res.stream_enc->funcs->dp_audio_enable(pipe_ctx->stream_res.stream_enc);
 	}
 
 	/* For MST, there are multiply stream go to only one link.
@@ -739,7 +739,7 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 	 * disconnect them during disable_stream
 	 * BY this, it is logic clean to separate stream and link */
 	 link->link_enc->funcs->connect_dig_be_to_fe(link->link_enc,
-			pipe_ctx->stream_enc->id, true);
+			pipe_ctx->stream_res.stream_enc->id, true);
 
 }
 
@@ -752,11 +752,11 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 		pipe_ctx->audio->funcs->az_disable(pipe_ctx->audio);
 
 		if (dc_is_dp_signal(pipe_ctx->stream->signal))
-			pipe_ctx->stream_enc->funcs->dp_audio_disable(
-					pipe_ctx->stream_enc);
+			pipe_ctx->stream_res.stream_enc->funcs->dp_audio_disable(
+					pipe_ctx->stream_res.stream_enc);
 		else
-			pipe_ctx->stream_enc->funcs->hdmi_audio_disable(
-					pipe_ctx->stream_enc);
+			pipe_ctx->stream_res.stream_enc->funcs->hdmi_audio_disable(
+					pipe_ctx->stream_res.stream_enc);
 
 		pipe_ctx->audio = NULL;
 
@@ -768,24 +768,24 @@ void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 	}
 
 	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
-		pipe_ctx->stream_enc->funcs->stop_hdmi_info_packets(
-			pipe_ctx->stream_enc);
+		pipe_ctx->stream_res.stream_enc->funcs->stop_hdmi_info_packets(
+			pipe_ctx->stream_res.stream_enc);
 
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
-		pipe_ctx->stream_enc->funcs->stop_dp_info_packets(
-			pipe_ctx->stream_enc);
+		pipe_ctx->stream_res.stream_enc->funcs->stop_dp_info_packets(
+			pipe_ctx->stream_res.stream_enc);
 
-	pipe_ctx->stream_enc->funcs->audio_mute_control(
-			pipe_ctx->stream_enc, true);
+	pipe_ctx->stream_res.stream_enc->funcs->audio_mute_control(
+			pipe_ctx->stream_res.stream_enc, true);
 
 
 	/* blank at encoder level */
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
-		pipe_ctx->stream_enc->funcs->dp_blank(pipe_ctx->stream_enc);
+		pipe_ctx->stream_res.stream_enc->funcs->dp_blank(pipe_ctx->stream_res.stream_enc);
 
 	link->link_enc->funcs->connect_dig_be_to_fe(
 			link->link_enc,
-			pipe_ctx->stream_enc->id,
+			pipe_ctx->stream_res.stream_enc->id,
 			false);
 
 }
@@ -799,14 +799,14 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 	params.pixel_clk_khz =
 		pipe_ctx->stream->timing.pix_clk_khz;
 	params.link_settings.link_rate = link_settings->link_rate;
-	pipe_ctx->stream_enc->funcs->dp_unblank(pipe_ctx->stream_enc, &params);
+	pipe_ctx->stream_res.stream_enc->funcs->dp_unblank(pipe_ctx->stream_res.stream_enc, &params);
 }
 
 
 void dce110_set_avmute(struct pipe_ctx *pipe_ctx, bool enable)
 {
-	if (pipe_ctx != NULL && pipe_ctx->stream_enc != NULL)
-		pipe_ctx->stream_enc->funcs->set_avmute(pipe_ctx->stream_enc, enable);
+	if (pipe_ctx != NULL && pipe_ctx->stream_res.stream_enc != NULL)
+		pipe_ctx->stream_res.stream_enc->funcs->set_avmute(pipe_ctx->stream_res.stream_enc, enable);
 }
 
 static enum audio_dto_source translate_to_dto_source(enum controller_id crtc_id)
@@ -834,7 +834,7 @@ static void build_audio_output(
 	struct audio_output *audio_output)
 {
 	const struct dc_stream_state *stream = pipe_ctx->stream;
-	audio_output->engine_id = pipe_ctx->stream_enc->id;
+	audio_output->engine_id = pipe_ctx->stream_res.stream_enc->id;
 
 	audio_output->signal = pipe_ctx->stream->signal;
 
@@ -1071,8 +1071,8 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 			pipe_ctx->stream->signal);
 
 	if (pipe_ctx->stream->signal != SIGNAL_TYPE_VIRTUAL)
-		pipe_ctx->stream_enc->funcs->setup_stereo_sync(
-		pipe_ctx->stream_enc,
+		pipe_ctx->stream_res.stream_enc->funcs->setup_stereo_sync(
+		pipe_ctx->stream_res.stream_enc,
 		pipe_ctx->stream_res.tg->inst,
 		stream->timing.timing_3d_format != TIMING_3D_FORMAT_NONE);
 
@@ -1084,21 +1084,21 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 			&stream->clamping);
 
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
-		pipe_ctx->stream_enc->funcs->dp_set_stream_attribute(
-			pipe_ctx->stream_enc,
+		pipe_ctx->stream_res.stream_enc->funcs->dp_set_stream_attribute(
+			pipe_ctx->stream_res.stream_enc,
 			&stream->timing,
 			stream->output_color_space);
 
 	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
-		pipe_ctx->stream_enc->funcs->hdmi_set_stream_attribute(
-			pipe_ctx->stream_enc,
+		pipe_ctx->stream_res.stream_enc->funcs->hdmi_set_stream_attribute(
+			pipe_ctx->stream_res.stream_enc,
 			&stream->timing,
 			stream->phy_pix_clk,
 			pipe_ctx->audio != NULL);
 
 	if (dc_is_dvi_signal(pipe_ctx->stream->signal))
-		pipe_ctx->stream_enc->funcs->dvi_set_stream_attribute(
-			pipe_ctx->stream_enc,
+		pipe_ctx->stream_res.stream_enc->funcs->dvi_set_stream_attribute(
+			pipe_ctx->stream_res.stream_enc,
 			&stream->timing,
 			(pipe_ctx->stream->signal == SIGNAL_TYPE_DVI_DUAL_LINK) ?
 			true : false);
@@ -1860,13 +1860,13 @@ enum dc_status dce110_apply_ctx_to_hw(
 			build_audio_output(pipe_ctx, &audio_output);
 
 			if (dc_is_dp_signal(pipe_ctx->stream->signal))
-				pipe_ctx->stream_enc->funcs->dp_audio_setup(
-						pipe_ctx->stream_enc,
+				pipe_ctx->stream_res.stream_enc->funcs->dp_audio_setup(
+						pipe_ctx->stream_res.stream_enc,
 						pipe_ctx->audio->inst,
 						&pipe_ctx->stream->audio_info);
 			else
-				pipe_ctx->stream_enc->funcs->hdmi_audio_setup(
-						pipe_ctx->stream_enc,
+				pipe_ctx->stream_res.stream_enc->funcs->hdmi_audio_setup(
+						pipe_ctx->stream_res.stream_enc,
 						pipe_ctx->audio->inst,
 						&pipe_ctx->stream->audio_info,
 						&audio_output.crtc_info);

commit 6b670fa965b620bf0131a0a339a388a0581bc466
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 13:59:26 2017 -0400

    drm/amd/display: Move TG to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipes->tg/pipes->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/ctx->tg->/ctx->stream_res\.tg->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->tg/pipe->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx->tg/pipe_ctx->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[pipe_offset\]\.tg/pipe_ctx\[pipe_offset\]\.stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/grouped_pipes\[i\]->tg/grouped_pipes\[i\]->stream_^Cs\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/grouped_pipes\[0\]->tg/grouped_pipes\[0\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/grouped_pipes\[1\]->tg/grouped_pipes\[1\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx\[i\]->tg/pipe_ctx\[i\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx_old->tg/pipe_ctx_old->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_set\[j\]->tg/pipe_set\[j\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx\[i\]\.tg/pipe_ctx\[i\]\.stream_res\.tg/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 0601105a5e3f..1d7c7fb668be 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -710,7 +710,7 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 	*/
 	uint32_t active_total_with_borders;
 	uint32_t early_control = 0;
-	struct timing_generator *tg = pipe_ctx->tg;
+	struct timing_generator *tg = pipe_ctx->stream_res.tg;
 
 	/* TODOFPGA may change to hwss.update_info_frame */
 	dce110_update_info_frame(pipe_ctx);
@@ -967,9 +967,9 @@ static void program_scaler(const struct core_dc *dc,
 		pipe_ctx->plane_res.scl_data.lb_params.depth,
 		&pipe_ctx->stream->bit_depth_params);
 
-	if (pipe_ctx->tg->funcs->set_overscan_blank_color)
-		pipe_ctx->tg->funcs->set_overscan_blank_color(
-				pipe_ctx->tg,
+	if (pipe_ctx->stream_res.tg->funcs->set_overscan_blank_color)
+		pipe_ctx->stream_res.tg->funcs->set_overscan_blank_color(
+				pipe_ctx->stream_res.tg,
 				&color);
 
 	pipe_ctx->plane_res.xfm->funcs->transform_set_scaler(pipe_ctx->plane_res.xfm,
@@ -991,15 +991,15 @@ static enum dc_status dce110_prog_pixclk_crtc_otg(
 		/* program blank color */
 		color_space_to_black_color(dc,
 				stream->output_color_space, &black_color);
-		pipe_ctx->tg->funcs->set_blank_color(
-				pipe_ctx->tg,
+		pipe_ctx->stream_res.tg->funcs->set_blank_color(
+				pipe_ctx->stream_res.tg,
 				&black_color);
 
 		/*
 		 * Must blank CRTC after disabling power gating and before any
 		 * programming, otherwise CRTC will be hung in bad state
 		 */
-		pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, true);
+		pipe_ctx->stream_res.tg->funcs->set_blank(pipe_ctx->stream_res.tg, true);
 
 		if (false == pipe_ctx->clock_source->funcs->program_pix_clk(
 				pipe_ctx->clock_source,
@@ -1009,19 +1009,19 @@ static enum dc_status dce110_prog_pixclk_crtc_otg(
 			return DC_ERROR_UNEXPECTED;
 		}
 
-		pipe_ctx->tg->funcs->program_timing(
-				pipe_ctx->tg,
+		pipe_ctx->stream_res.tg->funcs->program_timing(
+				pipe_ctx->stream_res.tg,
 				&stream->timing,
 				true);
 
-		pipe_ctx->tg->funcs->set_static_screen_control(
-				pipe_ctx->tg,
+		pipe_ctx->stream_res.tg->funcs->set_static_screen_control(
+				pipe_ctx->stream_res.tg,
 				0x182);
 	}
 
 	if (!pipe_ctx_old->stream) {
-		if (false == pipe_ctx->tg->funcs->enable_crtc(
-				pipe_ctx->tg)) {
+		if (false == pipe_ctx->stream_res.tg->funcs->enable_crtc(
+				pipe_ctx->stream_res.tg)) {
 			BREAK_TO_DEBUGGER();
 			return DC_ERROR_UNEXPECTED;
 		}
@@ -1073,7 +1073,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	if (pipe_ctx->stream->signal != SIGNAL_TYPE_VIRTUAL)
 		pipe_ctx->stream_enc->funcs->setup_stereo_sync(
 		pipe_ctx->stream_enc,
-		pipe_ctx->tg->inst,
+		pipe_ctx->stream_res.tg->inst,
 		stream->timing.timing_3d_format != TIMING_3D_FORMAT_NONE);
 
 
@@ -1359,7 +1359,7 @@ static void set_drr(struct pipe_ctx **pipe_ctx,
 	 */
 
 	for (i = 0; i < num_pipes; i++) {
-		pipe_ctx[i]->tg->funcs->set_drr(pipe_ctx[i]->tg, &params);
+		pipe_ctx[i]->stream_res.tg->funcs->set_drr(pipe_ctx[i]->stream_res.tg, &params);
 	}
 }
 
@@ -1372,7 +1372,7 @@ static void get_position(struct pipe_ctx **pipe_ctx,
 	/* TODO: handle pipes > 1
 	 */
 	for (i = 0; i < num_pipes; i++)
-		pipe_ctx[i]->tg->funcs->get_position(pipe_ctx[i]->tg, position);
+		pipe_ctx[i]->stream_res.tg->funcs->get_position(pipe_ctx[i]->stream_res.tg, position);
 }
 
 static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
@@ -1393,8 +1393,8 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
 #endif
 
 	for (i = 0; i < num_pipes; i++)
-		pipe_ctx[i]->tg->funcs->
-			set_static_screen_control(pipe_ctx[i]->tg, value);
+		pipe_ctx[i]->stream_res.tg->funcs->
+			set_static_screen_control(pipe_ctx[i]->stream_res.tg, value);
 }
 
 /* unit: in_khz before mode set, get pixel clock from context. ASIC register
@@ -1646,12 +1646,12 @@ static void dce110_reset_hw_ctx_wrap(
 		if (!pipe_ctx->stream ||
 				pipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {
 			core_link_disable_stream(pipe_ctx_old);
-			pipe_ctx_old->tg->funcs->set_blank(pipe_ctx_old->tg, true);
-			if (!hwss_wait_for_blank_complete(pipe_ctx_old->tg)) {
+			pipe_ctx_old->stream_res.tg->funcs->set_blank(pipe_ctx_old->stream_res.tg, true);
+			if (!hwss_wait_for_blank_complete(pipe_ctx_old->stream_res.tg)) {
 				dm_error("DC: failed to blank crtc!\n");
 				BREAK_TO_DEBUGGER();
 			}
-			pipe_ctx_old->tg->funcs->disable_crtc(pipe_ctx_old->tg);
+			pipe_ctx_old->stream_res.tg->funcs->disable_crtc(pipe_ctx_old->stream_res.tg);
 			pipe_ctx_old->plane_res.mi->funcs->free_mem_input(
 					pipe_ctx_old->plane_res.mi, dc->current_context->stream_count);
 			resource_unreference_clock_source(
@@ -1984,7 +1984,7 @@ static void program_surface_visibility(const struct core_dc *dc,
 		blank_target = true;
 
 	dce_set_blender_mode(dc->hwseq, pipe_ctx->pipe_idx, blender_mode);
-	pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, blank_target);
+	pipe_ctx->stream_res.tg->funcs->set_blank(pipe_ctx->stream_res.tg, blank_target);
 
 }
 
@@ -2152,9 +2152,9 @@ void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)
 
 	plane_state->status.current_address = pipe_ctx->plane_res.mi->current_address;
 	if (pipe_ctx->plane_res.mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
-			pipe_ctx->tg->funcs->is_stereo_left_eye) {
+			pipe_ctx->stream_res.tg->funcs->is_stereo_left_eye) {
 		plane_state->status.is_right_eye =\
-				!pipe_ctx->tg->funcs->is_stereo_left_eye(pipe_ctx->tg);
+				!pipe_ctx->stream_res.tg->funcs->is_stereo_left_eye(pipe_ctx->stream_res.tg);
 	}
 }
 
@@ -2218,28 +2218,28 @@ static void dce110_enable_timing_synchronization(
 	 * Since HW doesn't care which one, we always assign
 	 * the 1st one in the group. */
 	gsl_params.gsl_group = 0;
-	gsl_params.gsl_master = grouped_pipes[0]->tg->inst;
+	gsl_params.gsl_master = grouped_pipes[0]->stream_res.tg->inst;
 
 	for (i = 0; i < group_size; i++)
-		grouped_pipes[i]->tg->funcs->setup_global_swap_lock(
-					grouped_pipes[i]->tg, &gsl_params);
+		grouped_pipes[i]->stream_res.tg->funcs->setup_global_swap_lock(
+					grouped_pipes[i]->stream_res.tg, &gsl_params);
 
 	/* Reset slave controllers on master VSync */
 	DC_SYNC_INFO("GSL: enabling trigger-reset\n");
 
 	for (i = 1 /* skip the master */; i < group_size; i++)
-		grouped_pipes[i]->tg->funcs->enable_reset_trigger(
-					grouped_pipes[i]->tg, gsl_params.gsl_group);
+		grouped_pipes[i]->stream_res.tg->funcs->enable_reset_trigger(
+					grouped_pipes[i]->stream_res.tg, gsl_params.gsl_group);
 
 
 
 	for (i = 1 /* skip the master */; i < group_size; i++) {
 		DC_SYNC_INFO("GSL: waiting for reset to occur.\n");
-		wait_for_reset_trigger_to_occur(dc_ctx, grouped_pipes[i]->tg);
+		wait_for_reset_trigger_to_occur(dc_ctx, grouped_pipes[i]->stream_res.tg);
 		/* Regardless of success of the wait above, remove the reset or
 		 * the driver will start timing out on Display requests. */
 		DC_SYNC_INFO("GSL: disabling trigger-reset.\n");
-		grouped_pipes[i]->tg->funcs->disable_reset_trigger(grouped_pipes[i]->tg);
+		grouped_pipes[i]->stream_res.tg->funcs->disable_reset_trigger(grouped_pipes[i]->stream_res.tg);
 	}
 
 
@@ -2247,7 +2247,7 @@ static void dce110_enable_timing_synchronization(
 	 * is that the sync'ed displays will not drift out of sync over time*/
 	DC_SYNC_INFO("GSL: Restoring register states.\n");
 	for (i = 0; i < group_size; i++)
-		grouped_pipes[i]->tg->funcs->tear_down_global_swap_lock(grouped_pipes[i]->tg);
+		grouped_pipes[i]->stream_res.tg->funcs->tear_down_global_swap_lock(grouped_pipes[i]->stream_res.tg);
 
 	DC_SYNC_INFO("GSL: Set-up complete.\n");
 }

commit a6a6cb349e39ef23a341a17752eebf69a5c0d7ff
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 13:55:28 2017 -0400

    drm/amd/display: Move OPP to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipes->opp/pipes->stream_res\.opp/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/ctx->opp->/ctx->stream_res\.opp->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->opp/pipe->stream_res\.opp/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx->opp/pipe_ctx->stream_res\.opp/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 1586dc95f5e4..0601105a5e3f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1044,16 +1044,16 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	/*  */
 	dc->hwss.prog_pixclk_crtc_otg(pipe_ctx, context, dc);
 
-	pipe_ctx->opp->funcs->opp_set_dyn_expansion(
-			pipe_ctx->opp,
+	pipe_ctx->stream_res.opp->funcs->opp_set_dyn_expansion(
+			pipe_ctx->stream_res.opp,
 			COLOR_SPACE_YCBCR601,
 			stream->timing.display_color_depth,
 			pipe_ctx->stream->signal);
 
 	/* FPGA does not program backend */
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
-	pipe_ctx->opp->funcs->opp_program_fmt(
-			pipe_ctx->opp,
+	pipe_ctx->stream_res.opp->funcs->opp_program_fmt(
+			pipe_ctx->stream_res.opp,
 			&stream->bit_depth_params,
 			&stream->clamping);
 		return DC_OK;
@@ -1078,8 +1078,8 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 
 
 /*vbios crtc_source_selection and encoder_setup will override fmt_C*/
-	pipe_ctx->opp->funcs->opp_program_fmt(
-			pipe_ctx->opp,
+	pipe_ctx->stream_res.opp->funcs->opp_program_fmt(
+			pipe_ctx->stream_res.opp,
 			&stream->bit_depth_params,
 			&stream->clamping);
 

commit 86a66c4eb7365c96230bca218634439f7b057306
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 11:55:55 2017 -0400

    drm/amd/display: Move mi, ipp, xfm to plane_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.mi/\.plane_res.mi/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->mi/->plane_res.mi/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.ipp/\.plane_res.ipp/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->ipp/->plane_res.ipp/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.xfm/\.plane_res.xfm/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->xfm/->plane_res.xfm/g'
    
    To clean up bad renames:
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.min/\.min/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.min/->min/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mic/->mic/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.mis/\.mis/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mid/->mid/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.mid/\.mid/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mis/->mis/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.min/\.min/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.min/->min/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mic/->mic/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.mis/\.mis/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mid/->mid/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.mid/\.mid/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mis/->mis/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.ipps/\.ipps/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/mpcc_cfg\.plane_res\.mi/mpcc_cfg\.mi/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/mi->plane_res\./mi->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/cfg->plane_res\./cfg->/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index dee18c92fd52..1586dc95f5e4 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -242,7 +242,7 @@ static bool dce110_set_input_transfer_func(
 	struct pipe_ctx *pipe_ctx,
 	const struct dc_plane_state *plane_state)
 {
-	struct input_pixel_processor *ipp = pipe_ctx->ipp;
+	struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
 	const struct dc_transfer_func *tf = NULL;
 	struct ipp_prescale_params prescale_params = { 0 };
 	bool result = true;
@@ -625,7 +625,7 @@ static bool dce110_set_output_transfer_func(
 	struct pipe_ctx *pipe_ctx,
 	const struct dc_stream_state *stream)
 {
-	struct transform *xfm = pipe_ctx->xfm;
+	struct transform *xfm = pipe_ctx->plane_res.xfm;
 
 	xfm->funcs->opp_power_on_regamma_lut(xfm, true);
 	xfm->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
@@ -951,7 +951,7 @@ static void program_scaler(const struct core_dc *dc,
 
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	/* TOFPGA */
-	if (pipe_ctx->xfm->funcs->transform_set_pixel_storage_depth == NULL)
+	if (pipe_ctx->plane_res.xfm->funcs->transform_set_pixel_storage_depth == NULL)
 		return;
 #endif
 
@@ -962,8 +962,8 @@ static void program_scaler(const struct core_dc *dc,
 				pipe_ctx->stream->output_color_space,
 				&color);
 
-	pipe_ctx->xfm->funcs->transform_set_pixel_storage_depth(
-		pipe_ctx->xfm,
+	pipe_ctx->plane_res.xfm->funcs->transform_set_pixel_storage_depth(
+		pipe_ctx->plane_res.xfm,
 		pipe_ctx->plane_res.scl_data.lb_params.depth,
 		&pipe_ctx->stream->bit_depth_params);
 
@@ -972,7 +972,7 @@ static void program_scaler(const struct core_dc *dc,
 				pipe_ctx->tg,
 				&color);
 
-	pipe_ctx->xfm->funcs->transform_set_scaler(pipe_ctx->xfm,
+	pipe_ctx->plane_res.xfm->funcs->transform_set_scaler(pipe_ctx->plane_res.xfm,
 		&pipe_ctx->plane_res.scl_data);
 }
 
@@ -1125,10 +1125,10 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 
 	/* mst support - use total stream count */
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	if (pipe_ctx->mi->funcs->allocate_mem_input != NULL)
+	if (pipe_ctx->plane_res.mi->funcs->allocate_mem_input != NULL)
 #endif
-		pipe_ctx->mi->funcs->allocate_mem_input(
-					pipe_ctx->mi,
+		pipe_ctx->plane_res.mi->funcs->allocate_mem_input(
+					pipe_ctx->plane_res.mi,
 					stream->timing.h_total,
 					stream->timing.v_total,
 					stream->timing.pix_clk_khz,
@@ -1260,16 +1260,16 @@ void dce110_set_displaymarks(
 
 		total_dest_line_time_ns = compute_pstate_blackout_duration(
 			dc->bw_vbios.blackout_duration, pipe_ctx->stream);
-		pipe_ctx->mi->funcs->mem_input_program_display_marks(
-			pipe_ctx->mi,
+		pipe_ctx->plane_res.mi->funcs->mem_input_program_display_marks(
+			pipe_ctx->plane_res.mi,
 			context->bw.dce.nbp_state_change_wm_ns[num_pipes],
 			context->bw.dce.stutter_exit_wm_ns[num_pipes],
 			context->bw.dce.urgent_wm_ns[num_pipes],
 			total_dest_line_time_ns);
 		if (i == underlay_idx) {
 			num_pipes++;
-			pipe_ctx->mi->funcs->mem_input_program_chroma_display_marks(
-				pipe_ctx->mi,
+			pipe_ctx->plane_res.mi->funcs->mem_input_program_chroma_display_marks(
+				pipe_ctx->plane_res.mi,
 				context->bw.dce.nbp_state_change_wm_ns[num_pipes],
 				context->bw.dce.stutter_exit_wm_ns[num_pipes],
 				context->bw.dce.urgent_wm_ns[num_pipes],
@@ -1294,15 +1294,15 @@ static void set_safe_displaymarks(
 		if (res_ctx->pipe_ctx[i].stream == NULL)
 			continue;
 
-		res_ctx->pipe_ctx[i].mi->funcs->mem_input_program_display_marks(
-				res_ctx->pipe_ctx[i].mi,
+		res_ctx->pipe_ctx[i].plane_res.mi->funcs->mem_input_program_display_marks(
+				res_ctx->pipe_ctx[i].plane_res.mi,
 				nbp_marks,
 				max_marks,
 				max_marks,
 				MAX_WATERMARK);
 		if (i == underlay_idx)
-			res_ctx->pipe_ctx[i].mi->funcs->mem_input_program_chroma_display_marks(
-				res_ctx->pipe_ctx[i].mi,
+			res_ctx->pipe_ctx[i].plane_res.mi->funcs->mem_input_program_chroma_display_marks(
+				res_ctx->pipe_ctx[i].plane_res.mi,
 				nbp_marks,
 				max_marks,
 				max_marks,
@@ -1652,8 +1652,8 @@ static void dce110_reset_hw_ctx_wrap(
 				BREAK_TO_DEBUGGER();
 			}
 			pipe_ctx_old->tg->funcs->disable_crtc(pipe_ctx_old->tg);
-			pipe_ctx_old->mi->funcs->free_mem_input(
-					pipe_ctx_old->mi, dc->current_context->stream_count);
+			pipe_ctx_old->plane_res.mi->funcs->free_mem_input(
+					pipe_ctx_old->plane_res.mi, dc->current_context->stream_count);
 			resource_unreference_clock_source(
 					&dc->current_context->res_ctx, dc->res_pool,
 					&pipe_ctx_old->clock_source);
@@ -1936,8 +1936,8 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
 	/* Lb color depth */
 	default_adjust.lb_color_depth = pipe_ctx->plane_res.scl_data.lb_params.depth;
 
-	pipe_ctx->xfm->funcs->opp_set_csc_default(
-					pipe_ctx->xfm, &default_adjust);
+	pipe_ctx->plane_res.xfm->funcs->opp_set_csc_default(
+					pipe_ctx->plane_res.xfm, &default_adjust);
 }
 
 
@@ -2026,7 +2026,7 @@ static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 				gamut_remap_matrix.matrix[10];
 	}
 
-	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
+	pipe_ctx->plane_res.xfm->funcs->transform_set_gamut_remap(pipe_ctx->plane_res.xfm, &adjust);
 }
 
 /**
@@ -2037,7 +2037,7 @@ static void set_plane_config(
 	struct pipe_ctx *pipe_ctx,
 	struct resource_context *res_ctx)
 {
-	struct mem_input *mi = pipe_ctx->mi;
+	struct mem_input *mi = pipe_ctx->plane_res.mi;
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
@@ -2059,8 +2059,8 @@ static void set_plane_config(
 			tbl_entry.regval[i] =
 			pipe_ctx->stream->csc_color_matrix.matrix[i];
 
-		pipe_ctx->xfm->funcs->opp_set_csc_adjustment
-				(pipe_ctx->xfm, &tbl_entry);
+		pipe_ctx->plane_res.xfm->funcs->opp_set_csc_adjustment
+				(pipe_ctx->plane_res.xfm, &tbl_entry);
 	}
 
 	if (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {
@@ -2094,7 +2094,7 @@ static void set_plane_config(
 				gamut_remap_matrix.matrix[10];
 	}
 
-	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
+	pipe_ctx->plane_res.xfm->funcs->transform_set_gamut_remap(pipe_ctx->plane_res.xfm, &adjust);
 
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
 	program_scaler(dc, pipe_ctx);
@@ -2114,7 +2114,7 @@ static void set_plane_config(
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
-				pipe_ctx->mi,
+				pipe_ctx->plane_res.mi,
 				plane_state->format,
 				&plane_state->tiling_info,
 				plane_state->rotation);
@@ -2128,8 +2128,8 @@ static void update_plane_addr(const struct core_dc *dc,
 	if (plane_state == NULL)
 		return;
 
-	pipe_ctx->mi->funcs->mem_input_program_surface_flip_and_addr(
-			pipe_ctx->mi,
+	pipe_ctx->plane_res.mi->funcs->mem_input_program_surface_flip_and_addr(
+			pipe_ctx->plane_res.mi,
 			&plane_state->address,
 			plane_state->flip_immediate);
 
@@ -2144,14 +2144,14 @@ void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)
 		return;
 
 	plane_state->status.is_flip_pending =
-			pipe_ctx->mi->funcs->mem_input_is_flip_pending(
-					pipe_ctx->mi);
+			pipe_ctx->plane_res.mi->funcs->mem_input_is_flip_pending(
+					pipe_ctx->plane_res.mi);
 
 	if (plane_state->status.is_flip_pending && !plane_state->visible)
-		pipe_ctx->mi->current_address = pipe_ctx->mi->request_address;
+		pipe_ctx->plane_res.mi->current_address = pipe_ctx->plane_res.mi->request_address;
 
-	plane_state->status.current_address = pipe_ctx->mi->current_address;
-	if (pipe_ctx->mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
+	plane_state->status.current_address = pipe_ctx->plane_res.mi->current_address;
+	if (pipe_ctx->plane_res.mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 			pipe_ctx->tg->funcs->is_stereo_left_eye) {
 		plane_state->status.is_right_eye =\
 				!pipe_ctx->tg->funcs->is_stereo_left_eye(pipe_ctx->tg);
@@ -2488,7 +2488,7 @@ static void dce110_set_bandwidth(
 static void dce110_program_front_end_for_pipe(
 		struct core_dc *dc, struct pipe_ctx *pipe_ctx)
 {
-	struct mem_input *mi = pipe_ctx->mi;
+	struct mem_input *mi = pipe_ctx->plane_res.mi;
 	struct pipe_ctx *old_pipe = NULL;
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct xfm_grph_csc_adjustment adjust;
@@ -2515,8 +2515,8 @@ static void dce110_program_front_end_for_pipe(
 			tbl_entry.regval[i] =
 			pipe_ctx->stream->csc_color_matrix.matrix[i];
 
-		pipe_ctx->xfm->funcs->opp_set_csc_adjustment
-				(pipe_ctx->xfm, &tbl_entry);
+		pipe_ctx->plane_res.xfm->funcs->opp_set_csc_adjustment
+				(pipe_ctx->plane_res.xfm, &tbl_entry);
 	}
 
 	if (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {
@@ -2550,7 +2550,7 @@ static void dce110_program_front_end_for_pipe(
 				gamut_remap_matrix.matrix[10];
 	}
 
-	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
+	pipe_ctx->plane_res.xfm->funcs->transform_set_gamut_remap(pipe_ctx->plane_res.xfm, &adjust);
 
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
 
@@ -2569,7 +2569,7 @@ static void dce110_program_front_end_for_pipe(
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
-				pipe_ctx->mi,
+				pipe_ctx->plane_res.mi,
 				plane_state->format,
 				&plane_state->tiling_info,
 				plane_state->rotation);
@@ -2673,7 +2673,7 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 
 			tbl_entry.color_space = color_space;
 			//tbl_entry.regval = matrix;
-			pipe_ctx->xfm->funcs->opp_set_csc_adjustment(pipe_ctx->xfm, &tbl_entry);
+			pipe_ctx->plane_res.xfm->funcs->opp_set_csc_adjustment(pipe_ctx->plane_res.xfm, &tbl_entry);
 	}
 }
 

commit 6702a9ac53f88a373a9969b4dee292f4c5f023f5
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 11:51:21 2017 -0400

    drm/amd/display: Move scl_data to plane_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.scl_data/\.plane_res.scl_data/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->scl_data/->plane_res.scl_data/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index ea9ce87d348a..dee18c92fd52 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -914,7 +914,7 @@ static void get_surface_visual_confirm_color(const struct pipe_ctx *pipe_ctx,
 {
 	uint32_t color_value = MAX_TG_COLOR_VALUE * (4 - pipe_ctx->pipe_idx) / 4;
 
-	switch (pipe_ctx->scl_data.format) {
+	switch (pipe_ctx->plane_res.scl_data.format) {
 	case PIXEL_FORMAT_ARGB8888:
 		/* set boarder color to red */
 		color->color_r_cr = color_value;
@@ -964,7 +964,7 @@ static void program_scaler(const struct core_dc *dc,
 
 	pipe_ctx->xfm->funcs->transform_set_pixel_storage_depth(
 		pipe_ctx->xfm,
-		pipe_ctx->scl_data.lb_params.depth,
+		pipe_ctx->plane_res.scl_data.lb_params.depth,
 		&pipe_ctx->stream->bit_depth_params);
 
 	if (pipe_ctx->tg->funcs->set_overscan_blank_color)
@@ -973,7 +973,7 @@ static void program_scaler(const struct core_dc *dc,
 				&color);
 
 	pipe_ctx->xfm->funcs->transform_set_scaler(pipe_ctx->xfm,
-		&pipe_ctx->scl_data);
+		&pipe_ctx->plane_res.scl_data);
 }
 
 static enum dc_status dce110_prog_pixclk_crtc_otg(
@@ -1114,10 +1114,10 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 				&stream->sink->link->cur_link_settings);
 	}
 
-	pipe_ctx->scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
+	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
 	/* program_scaler and allocate_mem_input are not new asic */
 	if ((!pipe_ctx_old ||
-	     memcmp(&pipe_ctx_old->scl_data, &pipe_ctx->scl_data,
+	     memcmp(&pipe_ctx_old->plane_res.scl_data, &pipe_ctx->plane_res.scl_data,
 		    sizeof(struct scaler_data)) != 0) &&
 	     pipe_ctx->plane_state) {
 		program_scaler(dc, pipe_ctx);
@@ -1927,14 +1927,14 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
 		default_adjust.out_color_space =
 				pipe_ctx->stream->output_color_space;
 	default_adjust.csc_adjust_type = GRAPHICS_CSC_ADJUST_TYPE_SW;
-	default_adjust.surface_pixel_format = pipe_ctx->scl_data.format;
+	default_adjust.surface_pixel_format = pipe_ctx->plane_res.scl_data.format;
 
 	/* display color depth */
 	default_adjust.color_depth =
 		pipe_ctx->stream->timing.display_color_depth;
 
 	/* Lb color depth */
-	default_adjust.lb_color_depth = pipe_ctx->scl_data.lb_params.depth;
+	default_adjust.lb_color_depth = pipe_ctx->plane_res.scl_data.lb_params.depth;
 
 	pipe_ctx->xfm->funcs->opp_set_csc_default(
 					pipe_ctx->xfm, &default_adjust);
@@ -2096,7 +2096,7 @@ static void set_plane_config(
 
 	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
 
-	pipe_ctx->scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
+	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
 	program_scaler(dc, pipe_ctx);
 
 	program_surface_visibility(dc, pipe_ctx);
@@ -2552,7 +2552,7 @@ static void dce110_program_front_end_for_pipe(
 
 	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
 
-	pipe_ctx->scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
+	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
 
 	program_scaler(dc, pipe_ctx);
 
@@ -2602,14 +2602,14 @@ static void dce110_program_front_end_for_pipe(
 			"viewport:%d, %d, %d, %d\n"
 			"recout:  %d, %d, %d, %d\n",
 			pipe_ctx->pipe_idx,
-			pipe_ctx->scl_data.viewport.width,
-			pipe_ctx->scl_data.viewport.height,
-			pipe_ctx->scl_data.viewport.x,
-			pipe_ctx->scl_data.viewport.y,
-			pipe_ctx->scl_data.recout.width,
-			pipe_ctx->scl_data.recout.height,
-			pipe_ctx->scl_data.recout.x,
-			pipe_ctx->scl_data.recout.y);
+			pipe_ctx->plane_res.scl_data.viewport.width,
+			pipe_ctx->plane_res.scl_data.viewport.height,
+			pipe_ctx->plane_res.scl_data.viewport.x,
+			pipe_ctx->plane_res.scl_data.viewport.y,
+			pipe_ctx->plane_res.scl_data.recout.width,
+			pipe_ctx->plane_res.scl_data.recout.height,
+			pipe_ctx->plane_res.scl_data.recout.x,
+			pipe_ctx->plane_res.scl_data.recout.y);
 }
 
 static void dce110_apply_ctx_for_surface(

commit 3be5262e353b8ab97c528bfc7d0dd3c820e4ba27
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:55:38 2017 -0400

    drm/amd/display: Rename more dc_surface stuff to plane_state
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e4310a376116..ea9ce87d348a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -215,11 +215,11 @@ static bool dce110_enable_display_power_gating(
 }
 
 static void build_prescale_params(struct ipp_prescale_params *prescale_params,
-		const struct dc_plane_state *surface)
+		const struct dc_plane_state *plane_state)
 {
 	prescale_params->mode = IPP_PRESCALE_MODE_FIXED_UNSIGNED;
 
-	switch (surface->format) {
+	switch (plane_state->format) {
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
 	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
 		prescale_params->scale = 0x2020;
@@ -240,7 +240,7 @@ static void build_prescale_params(struct ipp_prescale_params *prescale_params,
 
 static bool dce110_set_input_transfer_func(
 	struct pipe_ctx *pipe_ctx,
-	const struct dc_plane_state *surface)
+	const struct dc_plane_state *plane_state)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
 	const struct dc_transfer_func *tf = NULL;
@@ -250,14 +250,14 @@ static bool dce110_set_input_transfer_func(
 	if (ipp == NULL)
 		return false;
 
-	if (surface->in_transfer_func)
-		tf = surface->in_transfer_func;
+	if (plane_state->in_transfer_func)
+		tf = plane_state->in_transfer_func;
 
-	build_prescale_params(&prescale_params, surface);
+	build_prescale_params(&prescale_params, plane_state);
 	ipp->funcs->ipp_program_prescale(ipp, &prescale_params);
 
-	if (surface->gamma_correction && dce_use_lut(surface))
-		ipp->funcs->ipp_program_input_lut(ipp, surface->gamma_correction);
+	if (plane_state->gamma_correction && dce_use_lut(plane_state))
+		ipp->funcs->ipp_program_input_lut(ipp, plane_state->gamma_correction);
 
 	if (tf == NULL) {
 		/* Default case if no input transfer function specified */
@@ -1119,7 +1119,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	if ((!pipe_ctx_old ||
 	     memcmp(&pipe_ctx_old->scl_data, &pipe_ctx->scl_data,
 		    sizeof(struct scaler_data)) != 0) &&
-	     pipe_ctx->surface) {
+	     pipe_ctx->plane_state) {
 		program_scaler(dc, pipe_ctx);
 	}
 
@@ -1916,11 +1916,11 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
 	struct default_adjustment default_adjust = { 0 };
 
 	default_adjust.force_hw_default = false;
-	if (pipe_ctx->surface == NULL)
+	if (pipe_ctx->plane_state == NULL)
 		default_adjust.in_color_space = COLOR_SPACE_SRGB;
 	else
 		default_adjust.in_color_space =
-				pipe_ctx->surface->color_space;
+				pipe_ctx->plane_state->color_space;
 	if (pipe_ctx->stream == NULL)
 		default_adjust.out_color_space = COLOR_SPACE_SRGB;
 	else
@@ -1971,16 +1971,16 @@ static void program_surface_visibility(const struct core_dc *dc,
 		/* For now we are supporting only two pipes */
 		ASSERT(pipe_ctx->bottom_pipe->bottom_pipe == NULL);
 
-		if (pipe_ctx->bottom_pipe->surface->visible) {
-			if (pipe_ctx->surface->visible)
+		if (pipe_ctx->bottom_pipe->plane_state->visible) {
+			if (pipe_ctx->plane_state->visible)
 				blender_mode = BLND_MODE_BLENDING;
 			else
 				blender_mode = BLND_MODE_OTHER_PIPE;
 
-		} else if (!pipe_ctx->surface->visible)
+		} else if (!pipe_ctx->plane_state->visible)
 			blank_target = true;
 
-	} else if (!pipe_ctx->surface->visible)
+	} else if (!pipe_ctx->plane_state->visible)
 		blank_target = true;
 
 	dce_set_blender_mode(dc->hwseq, pipe_ctx->pipe_idx, blender_mode);
@@ -2038,7 +2038,7 @@ static void set_plane_config(
 	struct resource_context *res_ctx)
 {
 	struct mem_input *mi = pipe_ctx->mi;
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
 	unsigned int i;
@@ -2103,57 +2103,57 @@ static void set_plane_config(
 
 	mi->funcs->mem_input_program_surface_config(
 			mi,
-			surface->format,
-			&surface->tiling_info,
-			&surface->plane_size,
-			surface->rotation,
+			plane_state->format,
+			&plane_state->tiling_info,
+			&plane_state->plane_size,
+			plane_state->rotation,
 			NULL,
 			false);
 	if (mi->funcs->set_blank)
-		mi->funcs->set_blank(mi, pipe_ctx->surface->visible);
+		mi->funcs->set_blank(mi, pipe_ctx->plane_state->visible);
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->mi,
-				surface->format,
-				&surface->tiling_info,
-				surface->rotation);
+				plane_state->format,
+				&plane_state->tiling_info,
+				plane_state->rotation);
 }
 
 static void update_plane_addr(const struct core_dc *dc,
 		struct pipe_ctx *pipe_ctx)
 {
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 
-	if (surface == NULL)
+	if (plane_state == NULL)
 		return;
 
 	pipe_ctx->mi->funcs->mem_input_program_surface_flip_and_addr(
 			pipe_ctx->mi,
-			&surface->address,
-			surface->flip_immediate);
+			&plane_state->address,
+			plane_state->flip_immediate);
 
-	surface->status.requested_address = surface->address;
+	plane_state->status.requested_address = plane_state->address;
 }
 
 void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)
 {
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 
-	if (surface == NULL)
+	if (plane_state == NULL)
 		return;
 
-	surface->status.is_flip_pending =
+	plane_state->status.is_flip_pending =
 			pipe_ctx->mi->funcs->mem_input_is_flip_pending(
 					pipe_ctx->mi);
 
-	if (surface->status.is_flip_pending && !surface->visible)
+	if (plane_state->status.is_flip_pending && !plane_state->visible)
 		pipe_ctx->mi->current_address = pipe_ctx->mi->request_address;
 
-	surface->status.current_address = pipe_ctx->mi->current_address;
+	plane_state->status.current_address = pipe_ctx->mi->current_address;
 	if (pipe_ctx->mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 			pipe_ctx->tg->funcs->is_stereo_left_eye) {
-		surface->status.is_right_eye =\
+		plane_state->status.is_right_eye =\
 				!pipe_ctx->tg->funcs->is_stereo_left_eye(pipe_ctx->tg);
 	}
 }
@@ -2490,7 +2490,7 @@ static void dce110_program_front_end_for_pipe(
 {
 	struct mem_input *mi = pipe_ctx->mi;
 	struct pipe_ctx *old_pipe = NULL;
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
 	unsigned int i;
@@ -2558,21 +2558,21 @@ static void dce110_program_front_end_for_pipe(
 
 	mi->funcs->mem_input_program_surface_config(
 			mi,
-			surface->format,
-			&surface->tiling_info,
-			&surface->plane_size,
-			surface->rotation,
+			plane_state->format,
+			&plane_state->tiling_info,
+			&plane_state->plane_size,
+			plane_state->rotation,
 			NULL,
 			false);
 	if (mi->funcs->set_blank)
-		mi->funcs->set_blank(mi, pipe_ctx->surface->visible);
+		mi->funcs->set_blank(mi, pipe_ctx->plane_state->visible);
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->mi,
-				surface->format,
-				&surface->tiling_info,
-				surface->rotation);
+				plane_state->format,
+				&plane_state->tiling_info,
+				plane_state->rotation);
 
 	dm_logger_write(dc->ctx->logger, LOG_SURFACE,
 			"Pipe:%d 0x%x: addr hi:0x%x, "
@@ -2581,21 +2581,21 @@ static void dce110_program_front_end_for_pipe(
 			" %d; dst: %d, %d, %d, %d;"
 			"clip: %d, %d, %d, %d\n",
 			pipe_ctx->pipe_idx,
-			pipe_ctx->surface,
-			pipe_ctx->surface->address.grph.addr.high_part,
-			pipe_ctx->surface->address.grph.addr.low_part,
-			pipe_ctx->surface->src_rect.x,
-			pipe_ctx->surface->src_rect.y,
-			pipe_ctx->surface->src_rect.width,
-			pipe_ctx->surface->src_rect.height,
-			pipe_ctx->surface->dst_rect.x,
-			pipe_ctx->surface->dst_rect.y,
-			pipe_ctx->surface->dst_rect.width,
-			pipe_ctx->surface->dst_rect.height,
-			pipe_ctx->surface->clip_rect.x,
-			pipe_ctx->surface->clip_rect.y,
-			pipe_ctx->surface->clip_rect.width,
-			pipe_ctx->surface->clip_rect.height);
+			pipe_ctx->plane_state,
+			pipe_ctx->plane_state->address.grph.addr.high_part,
+			pipe_ctx->plane_state->address.grph.addr.low_part,
+			pipe_ctx->plane_state->src_rect.x,
+			pipe_ctx->plane_state->src_rect.y,
+			pipe_ctx->plane_state->src_rect.width,
+			pipe_ctx->plane_state->src_rect.height,
+			pipe_ctx->plane_state->dst_rect.x,
+			pipe_ctx->plane_state->dst_rect.y,
+			pipe_ctx->plane_state->dst_rect.width,
+			pipe_ctx->plane_state->dst_rect.height,
+			pipe_ctx->plane_state->clip_rect.x,
+			pipe_ctx->plane_state->clip_rect.y,
+			pipe_ctx->plane_state->clip_rect.width,
+			pipe_ctx->plane_state->clip_rect.height);
 
 	dm_logger_write(dc->ctx->logger, LOG_SURFACE,
 			"Pipe %d: width, height, x, y\n"
@@ -2614,19 +2614,18 @@ static void dce110_program_front_end_for_pipe(
 
 static void dce110_apply_ctx_for_surface(
 		struct core_dc *dc,
-		const struct dc_plane_state *surface,
+		const struct dc_plane_state *plane_state,
 		struct validate_context *context)
 {
 	int i;
 
-	/* TODO remove when removing the surface reset workaroud*/
-	if (!surface)
+	if (!plane_state)
 		return;
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		if (pipe_ctx->surface != surface)
+		if (pipe_ctx->plane_state != plane_state)
 			continue;
 
 		dce110_program_front_end_for_pipe(dc, pipe_ctx);

commit 0971c40e180696c3512b9a63ca7ca5161cbfce32
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:33:33 2017 -0400

    drm/amd/display: Rename dc_stream to dc_stream_state
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream/struct dc_stream_state/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream_state_update/struct dc_stream_update/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream_state_status/struct dc_stream_status/g'
    
    Plus some manual changes
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 84dc8916de96..e4310a376116 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -623,7 +623,7 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 
 static bool dce110_set_output_transfer_func(
 	struct pipe_ctx *pipe_ctx,
-	const struct dc_stream *stream)
+	const struct dc_stream_state *stream)
 {
 	struct transform *xfm = pipe_ctx->xfm;
 
@@ -745,7 +745,7 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 
 void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 {
-	struct dc_stream *stream = pipe_ctx->stream;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->sink->link;
 
 	if (pipe_ctx->audio) {
@@ -833,7 +833,7 @@ static void build_audio_output(
 	const struct pipe_ctx *pipe_ctx,
 	struct audio_output *audio_output)
 {
-	const struct dc_stream *stream = pipe_ctx->stream;
+	const struct dc_stream_state *stream = pipe_ctx->stream;
 	audio_output->engine_id = pipe_ctx->stream_enc->id;
 
 	audio_output->signal = pipe_ctx->stream->signal;
@@ -981,7 +981,7 @@ static enum dc_status dce110_prog_pixclk_crtc_otg(
 		struct validate_context *context,
 		struct core_dc *dc)
 {
-	struct dc_stream *stream = pipe_ctx->stream;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct pipe_ctx *pipe_ctx_old = &dc->current_context->res_ctx.
 			pipe_ctx[pipe_ctx->pipe_idx];
 	struct tg_color black_color = {0};
@@ -1037,7 +1037,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		struct validate_context *context,
 		struct core_dc *dc)
 {
-	struct dc_stream *stream = pipe_ctx->stream;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct pipe_ctx *pipe_ctx_old = &dc->current_context->res_ctx.
 			pipe_ctx[pipe_ctx->pipe_idx];
 
@@ -1229,7 +1229,7 @@ void dce110_enable_accelerated_mode(struct core_dc *dc)
 
 static uint32_t compute_pstate_blackout_duration(
 	struct bw_fixed blackout_duration,
-	const struct dc_stream *stream)
+	const struct dc_stream_state *stream)
 {
 	uint32_t total_dest_line_time_ns;
 	uint32_t pstate_blackout_duration_ns;
@@ -2325,7 +2325,7 @@ void dce110_fill_display_configs(
 	for (j = 0; j < context->stream_count; j++) {
 		int k;
 
-		const struct dc_stream *stream = context->streams[j];
+		const struct dc_stream_state *stream = context->streams[j];
 		struct dm_pp_single_disp_config *cfg =
 			&pp_display_cfg->disp_configs[num_cfgs];
 		const struct pipe_ctx *pipe_ctx = NULL;
@@ -2370,7 +2370,7 @@ uint32_t dce110_get_min_vblank_time_us(const struct validate_context *context)
 	uint32_t min_vertical_blank_time = -1;
 
 		for (j = 0; j < context->stream_count; j++) {
-			struct dc_stream *stream = context->streams[j];
+			struct dc_stream_state *stream = context->streams[j];
 			uint32_t vertical_blank_in_pixels = 0;
 			uint32_t vertical_blank_time = 0;
 

commit c9614aeb12f80fa7a787e608d75b707175997edd
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:24:04 2017 -0400

    drm/amd/display: Rename dc_surface to dc_plane_state
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_surface/struct dc_plane_state/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_update/struct dc_surface_update/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_status/struct dc_surface_status/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_dcc_cap/struct dc_surface_dcc_cap/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 1f18fcf52661..84dc8916de96 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -215,7 +215,7 @@ static bool dce110_enable_display_power_gating(
 }
 
 static void build_prescale_params(struct ipp_prescale_params *prescale_params,
-		const struct dc_surface *surface)
+		const struct dc_plane_state *surface)
 {
 	prescale_params->mode = IPP_PRESCALE_MODE_FIXED_UNSIGNED;
 
@@ -240,7 +240,7 @@ static void build_prescale_params(struct ipp_prescale_params *prescale_params,
 
 static bool dce110_set_input_transfer_func(
 	struct pipe_ctx *pipe_ctx,
-	const struct dc_surface *surface)
+	const struct dc_plane_state *surface)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
 	const struct dc_transfer_func *tf = NULL;
@@ -2038,7 +2038,7 @@ static void set_plane_config(
 	struct resource_context *res_ctx)
 {
 	struct mem_input *mi = pipe_ctx->mi;
-	struct dc_surface *surface = pipe_ctx->surface;
+	struct dc_plane_state *surface = pipe_ctx->surface;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
 	unsigned int i;
@@ -2123,7 +2123,7 @@ static void set_plane_config(
 static void update_plane_addr(const struct core_dc *dc,
 		struct pipe_ctx *pipe_ctx)
 {
-	struct dc_surface *surface = pipe_ctx->surface;
+	struct dc_plane_state *surface = pipe_ctx->surface;
 
 	if (surface == NULL)
 		return;
@@ -2138,7 +2138,7 @@ static void update_plane_addr(const struct core_dc *dc,
 
 void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)
 {
-	struct dc_surface *surface = pipe_ctx->surface;
+	struct dc_plane_state *surface = pipe_ctx->surface;
 
 	if (surface == NULL)
 		return;
@@ -2490,7 +2490,7 @@ static void dce110_program_front_end_for_pipe(
 {
 	struct mem_input *mi = pipe_ctx->mi;
 	struct pipe_ctx *old_pipe = NULL;
-	struct dc_surface *surface = pipe_ctx->surface;
+	struct dc_plane_state *surface = pipe_ctx->surface;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
 	unsigned int i;
@@ -2614,7 +2614,7 @@ static void dce110_program_front_end_for_pipe(
 
 static void dce110_apply_ctx_for_surface(
 		struct core_dc *dc,
-		const struct dc_surface *surface,
+		const struct dc_plane_state *surface,
 		struct validate_context *context)
 {
 	int i;

commit 7a09f5be98df25a7253e4647e801120b37b90feb
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Fri Jul 28 13:08:03 2017 -0400

    drm/amd/display: move regamma from opp to dpp for dce
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index b62a7614fd28..1f18fcf52661 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -625,26 +625,26 @@ static bool dce110_set_output_transfer_func(
 	struct pipe_ctx *pipe_ctx,
 	const struct dc_stream *stream)
 {
-	struct output_pixel_processor *opp = pipe_ctx->opp;
+	struct transform *xfm = pipe_ctx->xfm;
 
-	opp->funcs->opp_power_on_regamma_lut(opp, true);
-	opp->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
+	xfm->funcs->opp_power_on_regamma_lut(xfm, true);
+	xfm->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
 
 	if (stream->out_transfer_func &&
 		stream->out_transfer_func->type ==
 			TF_TYPE_PREDEFINED &&
 		stream->out_transfer_func->tf ==
 			TRANSFER_FUNCTION_SRGB) {
-		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_SRGB);
+		xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_SRGB);
 	} else if (dce110_translate_regamma_to_hw_format(
-				stream->out_transfer_func, &opp->regamma_params)) {
-			opp->funcs->opp_program_regamma_pwl(opp, &opp->regamma_params);
-			opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_USER);
+				stream->out_transfer_func, &xfm->regamma_params)) {
+		xfm->funcs->opp_program_regamma_pwl(xfm, &xfm->regamma_params);
+		xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_USER);
 	} else {
-		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_BYPASS);
+		xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_BYPASS);
 	}
 
-	opp->funcs->opp_power_on_regamma_lut(opp, false);
+	xfm->funcs->opp_power_on_regamma_lut(xfm, false);
 
 	return true;
 }

commit 690b5e3960810c733f812f8849c3a05415c2f53d
Author: Roman Li <Roman.Li@amd.com>
Date:   Thu Jul 27 20:00:06 2017 -0400

    drm/amd/display: Initial prototype of FBC implementation
    
    - Protected by ENABLE_FBC compile flag
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index ad831e586021..b62a7614fd28 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1528,6 +1528,69 @@ static void apply_min_clocks(
 	}
 }
 
+#ifdef ENABLE_FBC
+
+/*
+ *  Check if FBC can be enabled
+ */
+static enum dc_status validate_fbc(struct core_dc *dc,
+		struct validate_context *context)
+{
+	struct pipe_ctx *pipe_ctx =
+			      &context->res_ctx.pipe_ctx[0];
+
+	ASSERT(dc->fbc_compressor);
+
+	/* FBC memory should be allocated */
+	if (!dc->ctx->fbc_gpu_addr)
+		return DC_ERROR_UNEXPECTED;
+
+	/* Only supports single display */
+	if (context->stream_count != 1)
+		return DC_ERROR_UNEXPECTED;
+
+	/* Only supports eDP */
+	if (pipe_ctx->stream->sink->link->connector_signal != SIGNAL_TYPE_EDP)
+		return DC_ERROR_UNEXPECTED;
+
+	/* PSR should not be enabled */
+	if (pipe_ctx->stream->sink->link->psr_enabled)
+		return DC_ERROR_UNEXPECTED;
+
+	return DC_OK;
+}
+
+/*
+ *  Enable FBC
+ */
+static enum dc_status enable_fbc(struct core_dc *dc,
+		struct validate_context *context)
+{
+	enum dc_status status = validate_fbc(dc, context);
+
+	if (status == DC_OK) {
+		/* Program GRPH COMPRESSED ADDRESS and PITCH */
+		struct compr_addr_and_pitch_params params = {0, 0, 0};
+		struct compressor *compr = dc->fbc_compressor;
+		struct pipe_ctx *pipe_ctx =
+				      &context->res_ctx.pipe_ctx[0];
+
+		params.source_view_width =
+				pipe_ctx->stream->timing.h_addressable;
+		params.source_view_height =
+				pipe_ctx->stream->timing.v_addressable;
+
+		compr->compr_surface_address.quad_part = dc->ctx->fbc_gpu_addr;
+
+		compr->funcs->surface_address_and_pitch(compr, &params);
+		compr->funcs->set_fbc_invalidation_triggers(compr, 1);
+
+		compr->funcs->enable_fbc(compr, &params);
+	}
+	return status;
+}
+#endif
+
 static enum dc_status apply_ctx_to_hw_fpga(
 		struct core_dc *dc,
 		struct validate_context *context)
@@ -1836,6 +1899,11 @@ enum dc_status dce110_apply_ctx_to_hw(
 
 	switch_dp_clock_sources(dc, &context->res_ctx);
 
+#ifdef ENABLE_FBC
+	if (dc->fbc_compressor)
+		enable_fbc(dc, context);
+
+#endif
 
 	return DC_OK;
 }
@@ -2244,6 +2312,7 @@ static void init_hw(struct core_dc *dc)
 	if (dc->fbc_compressor)
 		dc->fbc_compressor->funcs->power_up_fbc(dc->fbc_compressor);
 #endif
+
 }
 
 void dce110_fill_display_configs(

commit bdf9a1a0e16c9e60be796341d79da87503a1cf70
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Tue Jul 25 16:45:18 2017 -0400

    drm/amd/display: move ocsc programming from opp to dpp for dce
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 6afe572cfb06..ad831e586021 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1868,8 +1868,8 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
 	/* Lb color depth */
 	default_adjust.lb_color_depth = pipe_ctx->scl_data.lb_params.depth;
 
-	pipe_ctx->opp->funcs->opp_set_csc_default(
-					pipe_ctx->opp, &default_adjust);
+	pipe_ctx->xfm->funcs->opp_set_csc_default(
+					pipe_ctx->xfm, &default_adjust);
 }
 
 
@@ -1991,8 +1991,8 @@ static void set_plane_config(
 			tbl_entry.regval[i] =
 			pipe_ctx->stream->csc_color_matrix.matrix[i];
 
-		pipe_ctx->opp->funcs->opp_set_csc_adjustment
-				(pipe_ctx->opp, &tbl_entry);
+		pipe_ctx->xfm->funcs->opp_set_csc_adjustment
+				(pipe_ctx->xfm, &tbl_entry);
 	}
 
 	if (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {
@@ -2446,8 +2446,8 @@ static void dce110_program_front_end_for_pipe(
 			tbl_entry.regval[i] =
 			pipe_ctx->stream->csc_color_matrix.matrix[i];
 
-		pipe_ctx->opp->funcs->opp_set_csc_adjustment
-				(pipe_ctx->opp, &tbl_entry);
+		pipe_ctx->xfm->funcs->opp_set_csc_adjustment
+				(pipe_ctx->xfm, &tbl_entry);
 	}
 
 	if (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {
@@ -2587,8 +2587,31 @@ static void dce110_wait_for_mpcc_disconnect(
 	/* do nothing*/
 }
 
+static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
+		enum dc_color_space colorspace,
+		uint16_t *matrix)
+{
+	int i;
+	struct out_csc_color_matrix tbl_entry;
+
+	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment
+				== true) {
+			enum dc_color_space color_space =
+				pipe_ctx->stream->output_color_space;
+
+			//uint16_t matrix[12];
+			for (i = 0; i < 12; i++)
+				tbl_entry.regval[i] = pipe_ctx->stream->csc_color_matrix.matrix[i];
+
+			tbl_entry.color_space = color_space;
+			//tbl_entry.regval = matrix;
+			pipe_ctx->xfm->funcs->opp_set_csc_adjustment(pipe_ctx->xfm, &tbl_entry);
+	}
+}
+
 static const struct hw_sequencer_funcs dce110_funcs = {
 	.program_gamut_remap = program_gamut_remap,
+	.program_csc_matrix = program_csc_matrix,
 	.init_hw = init_hw,
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
 	.apply_ctx_for_surface = dce110_apply_ctx_for_surface,

commit 54e8695ef14acc04e9aa99957249f520cf52e826
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jul 26 16:54:39 2017 -0400

    drm/amd/display: collapse dce11 reset_hw_ctx_wrap into 1 function
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index d45773087644..6afe572cfb06 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1345,28 +1345,6 @@ static void switch_dp_clock_sources(
  * Public functions
  ******************************************************************************/
 
-static void reset_single_pipe_hw_ctx(
-		const struct core_dc *dc,
-		struct pipe_ctx *pipe_ctx,
-		struct validate_context *context)
-{
-	core_link_disable_stream(pipe_ctx);
-	pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, true);
-	if (!hwss_wait_for_blank_complete(pipe_ctx->tg)) {
-		dm_error("DC: failed to blank crtc!\n");
-		BREAK_TO_DEBUGGER();
-	}
-	pipe_ctx->tg->funcs->disable_crtc(pipe_ctx->tg);
-	pipe_ctx->mi->funcs->free_mem_input(
-				pipe_ctx->mi, context->stream_count);
-	resource_unreference_clock_source(&context->res_ctx, dc->res_pool,
-			 &pipe_ctx->clock_source);
-
-	dc->hwss.power_down_front_end((struct core_dc *)dc, pipe_ctx->pipe_idx);
-
-	pipe_ctx->stream = NULL;
-}
-
 static void set_drr(struct pipe_ctx **pipe_ctx,
 		int num_pipes, int vmin, int vmax)
 {
@@ -1580,7 +1558,7 @@ static enum dc_status apply_ctx_to_hw_fpga(
 	return DC_OK;
 }
 
-static void reset_hw_ctx_wrap(
+static void dce110_reset_hw_ctx_wrap(
 		struct core_dc *dc,
 		struct validate_context *context)
 {
@@ -1603,9 +1581,24 @@ static void reset_hw_ctx_wrap(
 			continue;
 
 		if (!pipe_ctx->stream ||
-				pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
-			reset_single_pipe_hw_ctx(
-				dc, pipe_ctx_old, dc->current_context);
+				pipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {
+			core_link_disable_stream(pipe_ctx_old);
+			pipe_ctx_old->tg->funcs->set_blank(pipe_ctx_old->tg, true);
+			if (!hwss_wait_for_blank_complete(pipe_ctx_old->tg)) {
+				dm_error("DC: failed to blank crtc!\n");
+				BREAK_TO_DEBUGGER();
+			}
+			pipe_ctx_old->tg->funcs->disable_crtc(pipe_ctx_old->tg);
+			pipe_ctx_old->mi->funcs->free_mem_input(
+					pipe_ctx_old->mi, dc->current_context->stream_count);
+			resource_unreference_clock_source(
+					&dc->current_context->res_ctx, dc->res_pool,
+					&pipe_ctx_old->clock_source);
+
+			dc->hwss.power_down_front_end(dc, pipe_ctx_old->pipe_idx);
+
+			pipe_ctx_old->stream = NULL;
+		}
 	}
 }
 
@@ -2619,7 +2612,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.set_drr = set_drr,
 	.get_position = get_position,
 	.set_static_screen_control = set_static_screen_control,
-	.reset_hw_ctx_wrap = reset_hw_ctx_wrap,
+	.reset_hw_ctx_wrap = dce110_reset_hw_ctx_wrap,
 	.prog_pixclk_crtc_otg = dce110_prog_pixclk_crtc_otg,
 	.setup_stereo = NULL,
 	.set_avmute = dce110_set_avmute,

commit 2f3bfb2794e1aed018e344469f9c371f36f12867
Author: Roman Li <Roman.Li@amd.com>
Date:   Wed Jul 26 14:42:38 2017 -0400

    drm/amd/display: safeguard compressor api
    
    Only call compressor api if it's available.
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 15f6eeef343d..d45773087644 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1185,7 +1185,8 @@ static void power_down_all_hw_blocks(struct core_dc *dc)
 	power_down_clock_sources(dc);
 
 #ifdef ENABLE_FBC
-	dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);
+	if (dc->fbc_compressor)
+		dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);
 #endif
 }
 
@@ -1658,7 +1659,8 @@ enum dc_status dce110_apply_ctx_to_hw(
 	set_safe_displaymarks(&context->res_ctx, dc->res_pool);
 
 #ifdef ENABLE_FBC
-	dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);
+	if (dc->fbc_compressor)
+		dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);
 #endif
 	/*TODO: when pplib works*/
 	apply_min_clocks(dc, context, &clocks_state, true);
@@ -2246,7 +2248,8 @@ static void init_hw(struct core_dc *dc)
 		abm->funcs->abm_init(abm);
 	}
 #ifdef ENABLE_FBC
-	dc->fbc_compressor->funcs->power_up_fbc(dc->fbc_compressor);
+	if (dc->fbc_compressor)
+		dc->fbc_compressor->funcs->power_up_fbc(dc->fbc_compressor);
 #endif
 }
 

commit 4fa086b9b6640818c053c79d4d7104790ba76cb7
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Jul 25 20:51:26 2017 -0400

    drm/amd/display: Roll core_stream into dc_stream
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 119365960cd0..15f6eeef343d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -623,21 +623,21 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 
 static bool dce110_set_output_transfer_func(
 	struct pipe_ctx *pipe_ctx,
-	const struct core_stream *stream)
+	const struct dc_stream *stream)
 {
 	struct output_pixel_processor *opp = pipe_ctx->opp;
 
 	opp->funcs->opp_power_on_regamma_lut(opp, true);
 	opp->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
 
-	if (stream->public.out_transfer_func &&
-		stream->public.out_transfer_func->type ==
+	if (stream->out_transfer_func &&
+		stream->out_transfer_func->type ==
 			TF_TYPE_PREDEFINED &&
-		stream->public.out_transfer_func->tf ==
+		stream->out_transfer_func->tf ==
 			TRANSFER_FUNCTION_SRGB) {
 		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_SRGB);
 	} else if (dce110_translate_regamma_to_hw_format(
-				stream->public.out_transfer_func, &opp->regamma_params)) {
+				stream->out_transfer_func, &opp->regamma_params)) {
 			opp->funcs->opp_program_regamma_pwl(opp, &opp->regamma_params);
 			opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_USER);
 	} else {
@@ -702,7 +702,7 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 	enum dc_lane_count lane_count =
 		pipe_ctx->stream->sink->link->cur_link_settings.lane_count;
 
-	struct dc_crtc_timing *timing = &pipe_ctx->stream->public.timing;
+	struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;
 	struct dc_link *link = pipe_ctx->stream->sink->link;
 
 	/* 1. update AVI info frame (HDMI, DP)
@@ -745,7 +745,7 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 
 void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 {
-	struct core_stream *stream = pipe_ctx->stream;
+	struct dc_stream *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->sink->link;
 
 	if (pipe_ctx->audio) {
@@ -797,7 +797,7 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 
 	/* only 3 items below are used by unblank */
 	params.pixel_clk_khz =
-		pipe_ctx->stream->public.timing.pix_clk_khz;
+		pipe_ctx->stream->timing.pix_clk_khz;
 	params.link_settings.link_rate = link_settings->link_rate;
 	pipe_ctx->stream_enc->funcs->dp_unblank(pipe_ctx->stream_enc, &params);
 }
@@ -833,7 +833,7 @@ static void build_audio_output(
 	const struct pipe_ctx *pipe_ctx,
 	struct audio_output *audio_output)
 {
-	const struct core_stream *stream = pipe_ctx->stream;
+	const struct dc_stream *stream = pipe_ctx->stream;
 	audio_output->engine_id = pipe_ctx->stream_enc->id;
 
 	audio_output->signal = pipe_ctx->stream->signal;
@@ -841,33 +841,33 @@ static void build_audio_output(
 	/* audio_crtc_info  */
 
 	audio_output->crtc_info.h_total =
-		stream->public.timing.h_total;
+		stream->timing.h_total;
 
 	/*
 	 * Audio packets are sent during actual CRTC blank physical signal, we
 	 * need to specify actual active signal portion
 	 */
 	audio_output->crtc_info.h_active =
-			stream->public.timing.h_addressable
-			+ stream->public.timing.h_border_left
-			+ stream->public.timing.h_border_right;
+			stream->timing.h_addressable
+			+ stream->timing.h_border_left
+			+ stream->timing.h_border_right;
 
 	audio_output->crtc_info.v_active =
-			stream->public.timing.v_addressable
-			+ stream->public.timing.v_border_top
-			+ stream->public.timing.v_border_bottom;
+			stream->timing.v_addressable
+			+ stream->timing.v_border_top
+			+ stream->timing.v_border_bottom;
 
 	audio_output->crtc_info.pixel_repetition = 1;
 
 	audio_output->crtc_info.interlaced =
-			stream->public.timing.flags.INTERLACE;
+			stream->timing.flags.INTERLACE;
 
 	audio_output->crtc_info.refresh_rate =
-		(stream->public.timing.pix_clk_khz*1000)/
-		(stream->public.timing.h_total*stream->public.timing.v_total);
+		(stream->timing.pix_clk_khz*1000)/
+		(stream->timing.h_total*stream->timing.v_total);
 
 	audio_output->crtc_info.color_depth =
-		stream->public.timing.display_color_depth;
+		stream->timing.display_color_depth;
 
 	audio_output->crtc_info.requested_pixel_clock =
 			pipe_ctx->pix_clk_params.requested_pix_clk;
@@ -878,7 +878,7 @@ static void build_audio_output(
 /*for HDMI, audio ACR is with deep color ratio factor*/
 	if (dc_is_hdmi_signal(pipe_ctx->stream->signal) &&
 		audio_output->crtc_info.requested_pixel_clock ==
-				stream->public.timing.pix_clk_khz) {
+				stream->timing.pix_clk_khz) {
 		if (pipe_ctx->pix_clk_params.pixel_encoding == PIXEL_ENCODING_YCBCR420) {
 			audio_output->crtc_info.requested_pixel_clock =
 					audio_output->crtc_info.requested_pixel_clock/2;
@@ -959,7 +959,7 @@ static void program_scaler(const struct core_dc *dc,
 		get_surface_visual_confirm_color(pipe_ctx, &color);
 	else
 		color_space_to_black_color(dc,
-				pipe_ctx->stream->public.output_color_space,
+				pipe_ctx->stream->output_color_space,
 				&color);
 
 	pipe_ctx->xfm->funcs->transform_set_pixel_storage_depth(
@@ -981,7 +981,7 @@ static enum dc_status dce110_prog_pixclk_crtc_otg(
 		struct validate_context *context,
 		struct core_dc *dc)
 {
-	struct core_stream *stream = pipe_ctx->stream;
+	struct dc_stream *stream = pipe_ctx->stream;
 	struct pipe_ctx *pipe_ctx_old = &dc->current_context->res_ctx.
 			pipe_ctx[pipe_ctx->pipe_idx];
 	struct tg_color black_color = {0};
@@ -990,7 +990,7 @@ static enum dc_status dce110_prog_pixclk_crtc_otg(
 
 		/* program blank color */
 		color_space_to_black_color(dc,
-				stream->public.output_color_space, &black_color);
+				stream->output_color_space, &black_color);
 		pipe_ctx->tg->funcs->set_blank_color(
 				pipe_ctx->tg,
 				&black_color);
@@ -1011,7 +1011,7 @@ static enum dc_status dce110_prog_pixclk_crtc_otg(
 
 		pipe_ctx->tg->funcs->program_timing(
 				pipe_ctx->tg,
-				&stream->public.timing,
+				&stream->timing,
 				true);
 
 		pipe_ctx->tg->funcs->set_static_screen_control(
@@ -1037,7 +1037,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		struct validate_context *context,
 		struct core_dc *dc)
 {
-	struct core_stream *stream = pipe_ctx->stream;
+	struct dc_stream *stream = pipe_ctx->stream;
 	struct pipe_ctx *pipe_ctx_old = &dc->current_context->res_ctx.
 			pipe_ctx[pipe_ctx->pipe_idx];
 
@@ -1047,7 +1047,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	pipe_ctx->opp->funcs->opp_set_dyn_expansion(
 			pipe_ctx->opp,
 			COLOR_SPACE_YCBCR601,
-			stream->public.timing.display_color_depth,
+			stream->timing.display_color_depth,
 			pipe_ctx->stream->signal);
 
 	/* FPGA does not program backend */
@@ -1074,7 +1074,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		pipe_ctx->stream_enc->funcs->setup_stereo_sync(
 		pipe_ctx->stream_enc,
 		pipe_ctx->tg->inst,
-		stream->public.timing.timing_3d_format != TIMING_3D_FORMAT_NONE);
+		stream->timing.timing_3d_format != TIMING_3D_FORMAT_NONE);
 
 
 /*vbios crtc_source_selection and encoder_setup will override fmt_C*/
@@ -1086,20 +1086,20 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_enc->funcs->dp_set_stream_attribute(
 			pipe_ctx->stream_enc,
-			&stream->public.timing,
-			stream->public.output_color_space);
+			&stream->timing,
+			stream->output_color_space);
 
 	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_enc->funcs->hdmi_set_stream_attribute(
 			pipe_ctx->stream_enc,
-			&stream->public.timing,
+			&stream->timing,
 			stream->phy_pix_clk,
 			pipe_ctx->audio != NULL);
 
 	if (dc_is_dvi_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_enc->funcs->dvi_set_stream_attribute(
 			pipe_ctx->stream_enc,
-			&stream->public.timing,
+			&stream->timing,
 			(pipe_ctx->stream->signal == SIGNAL_TYPE_DVI_DUAL_LINK) ?
 			true : false);
 
@@ -1129,9 +1129,9 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 #endif
 		pipe_ctx->mi->funcs->allocate_mem_input(
 					pipe_ctx->mi,
-					stream->public.timing.h_total,
-					stream->public.timing.v_total,
-					stream->public.timing.pix_clk_khz,
+					stream->timing.h_total,
+					stream->timing.v_total,
+					stream->timing.pix_clk_khz,
 					context->stream_count);
 
 	pipe_ctx->stream->sink->link->psr_enabled = false;
@@ -1228,7 +1228,7 @@ void dce110_enable_accelerated_mode(struct core_dc *dc)
 
 static uint32_t compute_pstate_blackout_duration(
 	struct bw_fixed blackout_duration,
-	const struct core_stream *stream)
+	const struct dc_stream *stream)
 {
 	uint32_t total_dest_line_time_ns;
 	uint32_t pstate_blackout_duration_ns;
@@ -1236,8 +1236,8 @@ static uint32_t compute_pstate_blackout_duration(
 	pstate_blackout_duration_ns = 1000 * blackout_duration.value >> 24;
 
 	total_dest_line_time_ns = 1000000UL *
-		stream->public.timing.h_total /
-		stream->public.timing.pix_clk_khz +
+		stream->timing.h_total /
+		stream->timing.pix_clk_khz +
 		pstate_blackout_duration_ns;
 
 	return total_dest_line_time_ns;
@@ -1805,19 +1805,19 @@ enum dc_status dce110_apply_ctx_to_hw(
 				pipe_ctx->stream_enc->funcs->dp_audio_setup(
 						pipe_ctx->stream_enc,
 						pipe_ctx->audio->inst,
-						&pipe_ctx->stream->public.audio_info);
+						&pipe_ctx->stream->audio_info);
 			else
 				pipe_ctx->stream_enc->funcs->hdmi_audio_setup(
 						pipe_ctx->stream_enc,
 						pipe_ctx->audio->inst,
-						&pipe_ctx->stream->public.audio_info,
+						&pipe_ctx->stream->audio_info,
 						&audio_output.crtc_info);
 
 			pipe_ctx->audio->funcs->az_configure(
 					pipe_ctx->audio,
 					pipe_ctx->stream->signal,
 					&audio_output.crtc_info,
-					&pipe_ctx->stream->public.audio_info);
+					&pipe_ctx->stream->audio_info);
 		}
 
 		status = apply_single_controller_ctx_to_hw(
@@ -1862,13 +1862,13 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
 		default_adjust.out_color_space = COLOR_SPACE_SRGB;
 	else
 		default_adjust.out_color_space =
-				pipe_ctx->stream->public.output_color_space;
+				pipe_ctx->stream->output_color_space;
 	default_adjust.csc_adjust_type = GRAPHICS_CSC_ADJUST_TYPE_SW;
 	default_adjust.surface_pixel_format = pipe_ctx->scl_data.format;
 
 	/* display color depth */
 	default_adjust.color_depth =
-		pipe_ctx->stream->public.timing.display_color_depth;
+		pipe_ctx->stream->timing.display_color_depth;
 
 	/* Lb color depth */
 	default_adjust.lb_color_depth = pipe_ctx->scl_data.lb_params.depth;
@@ -1932,35 +1932,35 @@ static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
 
 
-	if (pipe_ctx->stream->public.gamut_remap_matrix.enable_remap == true) {
+	if (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {
 		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
 		adjust.temperature_matrix[0] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[0];
+				gamut_remap_matrix.matrix[0];
 		adjust.temperature_matrix[1] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[1];
+				gamut_remap_matrix.matrix[1];
 		adjust.temperature_matrix[2] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[2];
+				gamut_remap_matrix.matrix[2];
 		adjust.temperature_matrix[3] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[4];
+				gamut_remap_matrix.matrix[4];
 		adjust.temperature_matrix[4] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[5];
+				gamut_remap_matrix.matrix[5];
 		adjust.temperature_matrix[5] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[6];
+				gamut_remap_matrix.matrix[6];
 		adjust.temperature_matrix[6] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[8];
+				gamut_remap_matrix.matrix[8];
 		adjust.temperature_matrix[7] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[9];
+				gamut_remap_matrix.matrix[9];
 		adjust.temperature_matrix[8] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[10];
+				gamut_remap_matrix.matrix[10];
 	}
 
 	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
@@ -1987,48 +1987,48 @@ static void set_plane_config(
 	dce_enable_fe_clock(dc->hwseq, pipe_ctx->pipe_idx, true);
 
 	set_default_colors(pipe_ctx);
-	if (pipe_ctx->stream->public.csc_color_matrix.enable_adjustment
+	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment
 			== true) {
 		tbl_entry.color_space =
-			pipe_ctx->stream->public.output_color_space;
+			pipe_ctx->stream->output_color_space;
 
 		for (i = 0; i < 12; i++)
 			tbl_entry.regval[i] =
-			pipe_ctx->stream->public.csc_color_matrix.matrix[i];
+			pipe_ctx->stream->csc_color_matrix.matrix[i];
 
 		pipe_ctx->opp->funcs->opp_set_csc_adjustment
 				(pipe_ctx->opp, &tbl_entry);
 	}
 
-	if (pipe_ctx->stream->public.gamut_remap_matrix.enable_remap == true) {
+	if (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {
 		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
 		adjust.temperature_matrix[0] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[0];
+				gamut_remap_matrix.matrix[0];
 		adjust.temperature_matrix[1] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[1];
+				gamut_remap_matrix.matrix[1];
 		adjust.temperature_matrix[2] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[2];
+				gamut_remap_matrix.matrix[2];
 		adjust.temperature_matrix[3] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[4];
+				gamut_remap_matrix.matrix[4];
 		adjust.temperature_matrix[4] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[5];
+				gamut_remap_matrix.matrix[5];
 		adjust.temperature_matrix[5] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[6];
+				gamut_remap_matrix.matrix[6];
 		adjust.temperature_matrix[6] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[8];
+				gamut_remap_matrix.matrix[8];
 		adjust.temperature_matrix[7] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[9];
+				gamut_remap_matrix.matrix[9];
 		adjust.temperature_matrix[8] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[10];
+				gamut_remap_matrix.matrix[10];
 	}
 
 	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
@@ -2260,7 +2260,7 @@ void dce110_fill_display_configs(
 	for (j = 0; j < context->stream_count; j++) {
 		int k;
 
-		const struct core_stream *stream = context->streams[j];
+		const struct dc_stream *stream = context->streams[j];
 		struct dm_pp_single_disp_config *cfg =
 			&pp_display_cfg->disp_configs[num_cfgs];
 		const struct pipe_ctx *pipe_ctx = NULL;
@@ -2276,8 +2276,8 @@ void dce110_fill_display_configs(
 		num_cfgs++;
 		cfg->signal = pipe_ctx->stream->signal;
 		cfg->pipe_idx = pipe_ctx->pipe_idx;
-		cfg->src_height = stream->public.src.height;
-		cfg->src_width = stream->public.src.width;
+		cfg->src_height = stream->src.height;
+		cfg->src_width = stream->src.width;
 		cfg->ddi_channel_mapping =
 			stream->sink->link->ddi_channel_mapping.raw;
 		cfg->transmitter =
@@ -2290,10 +2290,10 @@ void dce110_fill_display_configs(
 			stream->sink->link->cur_link_settings.link_spread;
 		cfg->sym_clock = stream->phy_pix_clk;
 		/* Round v_refresh*/
-		cfg->v_refresh = stream->public.timing.pix_clk_khz * 1000;
-		cfg->v_refresh /= stream->public.timing.h_total;
-		cfg->v_refresh = (cfg->v_refresh + stream->public.timing.v_total / 2)
-							/ stream->public.timing.v_total;
+		cfg->v_refresh = stream->timing.pix_clk_khz * 1000;
+		cfg->v_refresh /= stream->timing.h_total;
+		cfg->v_refresh = (cfg->v_refresh + stream->timing.v_total / 2)
+							/ stream->timing.v_total;
 	}
 
 	pp_display_cfg->display_count = num_cfgs;
@@ -2305,7 +2305,7 @@ uint32_t dce110_get_min_vblank_time_us(const struct validate_context *context)
 	uint32_t min_vertical_blank_time = -1;
 
 		for (j = 0; j < context->stream_count; j++) {
-			const struct dc_stream *stream = &context->streams[j]->public;
+			struct dc_stream *stream = context->streams[j];
 			uint32_t vertical_blank_in_pixels = 0;
 			uint32_t vertical_blank_time = 0;
 
@@ -2388,7 +2388,7 @@ static void pplib_apply_display_requirements(
 	/* TODO: is this still applicable?*/
 	if (pp_display_cfg->display_count == 1) {
 		const struct dc_crtc_timing *timing =
-			&context->streams[0]->public.timing;
+			&context->streams[0]->timing;
 
 		pp_display_cfg->crtc_index =
 			pp_display_cfg->disp_configs[0].pipe_idx;
@@ -2441,48 +2441,48 @@ static void dce110_program_front_end_for_pipe(
 	dce_enable_fe_clock(dc->hwseq, pipe_ctx->pipe_idx, true);
 
 	set_default_colors(pipe_ctx);
-	if (pipe_ctx->stream->public.csc_color_matrix.enable_adjustment
+	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment
 			== true) {
 		tbl_entry.color_space =
-			pipe_ctx->stream->public.output_color_space;
+			pipe_ctx->stream->output_color_space;
 
 		for (i = 0; i < 12; i++)
 			tbl_entry.regval[i] =
-			pipe_ctx->stream->public.csc_color_matrix.matrix[i];
+			pipe_ctx->stream->csc_color_matrix.matrix[i];
 
 		pipe_ctx->opp->funcs->opp_set_csc_adjustment
 				(pipe_ctx->opp, &tbl_entry);
 	}
 
-	if (pipe_ctx->stream->public.gamut_remap_matrix.enable_remap == true) {
+	if (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {
 		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
 		adjust.temperature_matrix[0] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[0];
+				gamut_remap_matrix.matrix[0];
 		adjust.temperature_matrix[1] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[1];
+				gamut_remap_matrix.matrix[1];
 		adjust.temperature_matrix[2] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[2];
+				gamut_remap_matrix.matrix[2];
 		adjust.temperature_matrix[3] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[4];
+				gamut_remap_matrix.matrix[4];
 		adjust.temperature_matrix[4] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[5];
+				gamut_remap_matrix.matrix[5];
 		adjust.temperature_matrix[5] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[6];
+				gamut_remap_matrix.matrix[6];
 		adjust.temperature_matrix[6] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[8];
+				gamut_remap_matrix.matrix[8];
 		adjust.temperature_matrix[7] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[9];
+				gamut_remap_matrix.matrix[9];
 		adjust.temperature_matrix[8] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[10];
+				gamut_remap_matrix.matrix[10];
 	}
 
 	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);

commit 3639fa68122154b453eeaac840daadf3c7c56db4
Author: Zeyu Fan <Zeyu.Fan@amd.com>
Date:   Tue Jul 25 15:14:24 2017 -0400

    drm/amd/display: Clean up some DCN1 guards
    
    Signed-off-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index aa4777a8ec36..119365960cd0 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1104,11 +1104,11 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 			true : false);
 
 	resource_build_info_frame(pipe_ctx);
-
+	dce110_update_info_frame(pipe_ctx);
 	if (!pipe_ctx_old->stream) {
 		core_link_enable_stream(pipe_ctx);
 
-	dce110_update_info_frame(pipe_ctx);
+
 		if (dc_is_dp_signal(pipe_ctx->stream->signal))
 			dce110_unblank_stream(pipe_ctx,
 				&stream->sink->link->cur_link_settings);
@@ -1664,7 +1664,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 	apply_min_clocks(dc, context, &clocks_state, true);
 
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	if (dc->ctx->dce_version == DCN_VERSION_1_0) {
+	if (dc->ctx->dce_version >= DCN_VERSION_1_0) {
 		if (context->bw.dcn.calc_clk.fclk_khz
 				> dc->current_context->bw.dcn.cur_clk.fclk_khz) {
 			struct dm_pp_clock_for_voltage_req clock;

commit 6be425f3dc16bac797f300136b976bce46229784
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Mon Jul 24 10:47:02 2017 -0400

    drm/amd/display: break up plane disable and disconnect in set mode
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 58701fdb7c94..aa4777a8ec36 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2583,7 +2583,10 @@ static void dce110_power_down_fe(struct core_dc *dc, int fe_idx)
 				dc->res_pool->transforms[fe_idx]);
 }
 
-static void dce110_wait_for_mpcc_disconnect(struct resource_pool *res_pool, struct pipe_ctx *pipe_ctx)
+static void dce110_wait_for_mpcc_disconnect(
+		struct core_dc *dc,
+		struct resource_pool *res_pool,
+		struct pipe_ctx *pipe_ctx)
 {
 	/* do nothing*/
 }

commit b73a22d3257f9ec237c46be12d74b58d5a925d8c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Jul 24 14:04:27 2017 -0400

    drm/amd/display: Roll core_sink into dc_sink
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index fe8084e290a3..58701fdb7c94 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -657,7 +657,7 @@ static enum dc_status bios_parser_crtc_source_select(
 	 * encoder block
 	 * note: video bios clears all FMT setting here. */
 	struct bp_crtc_source_select crtc_source_select = {0};
-	const struct core_sink *sink = pipe_ctx->stream->sink;
+	const struct dc_sink *sink = pipe_ctx->stream->sink;
 
 	crtc_source_select.engine_id = pipe_ctx->stream_enc->id;
 	crtc_source_select.controller_id = pipe_ctx->pipe_idx + 1;

commit d0778ebfd58f5650de17531296ee5ecdde39ba68
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sat Jul 22 20:05:20 2017 -0400

    drm/amd/display: Roll core_link into dc_link
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index cf6bf2098b7c..fe8084e290a3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -700,10 +700,10 @@ void dce110_update_info_frame(struct pipe_ctx *pipe_ctx)
 void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 {
 	enum dc_lane_count lane_count =
-		pipe_ctx->stream->sink->link->public.cur_link_settings.lane_count;
+		pipe_ctx->stream->sink->link->cur_link_settings.lane_count;
 
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->public.timing;
-	struct core_link *link = pipe_ctx->stream->sink->link;
+	struct dc_link *link = pipe_ctx->stream->sink->link;
 
 	/* 1. update AVI info frame (HDMI, DP)
 	 * we always need to update info frame
@@ -746,7 +746,7 @@ void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
 void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
 {
 	struct core_stream *stream = pipe_ctx->stream;
-	struct core_link *link = stream->sink->link;
+	struct dc_link *link = stream->sink->link;
 
 	if (pipe_ctx->audio) {
 		pipe_ctx->audio->funcs->az_disable(pipe_ctx->audio);
@@ -1111,7 +1111,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	dce110_update_info_frame(pipe_ctx);
 		if (dc_is_dp_signal(pipe_ctx->stream->signal))
 			dce110_unblank_stream(pipe_ctx,
-				&stream->sink->link->public.cur_link_settings);
+				&stream->sink->link->cur_link_settings);
 	}
 
 	pipe_ctx->scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
@@ -2220,7 +2220,7 @@ static void init_hw(struct core_dc *dc)
 		/* Power up AND update implementation according to the
 		 * required signal (which may be different from the
 		 * default signal on connector). */
-		struct core_link *link = dc->links[i];
+		struct dc_link *link = dc->links[i];
 		link->link_enc->funcs->hw_init(link->link_enc);
 	}
 
@@ -2283,11 +2283,11 @@ void dce110_fill_display_configs(
 		cfg->transmitter =
 			stream->sink->link->link_enc->transmitter;
 		cfg->link_settings.lane_count =
-			stream->sink->link->public.cur_link_settings.lane_count;
+			stream->sink->link->cur_link_settings.lane_count;
 		cfg->link_settings.link_rate =
-			stream->sink->link->public.cur_link_settings.link_rate;
+			stream->sink->link->cur_link_settings.link_rate;
 		cfg->link_settings.link_spread =
-			stream->sink->link->public.cur_link_settings.link_spread;
+			stream->sink->link->cur_link_settings.link_spread;
 		cfg->sym_clock = stream->phy_pix_clk;
 		/* Round v_refresh*/
 		cfg->v_refresh = stream->public.timing.pix_clk_khz * 1000;

commit e12cfcb1d447cc937d1abc6f4aab8bbe5f88542e
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 20 11:43:32 2017 -0400

    drm/amd/display: Roll core_surface into dc_surface
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index efba8d7964eb..cf6bf2098b7c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -215,11 +215,11 @@ static bool dce110_enable_display_power_gating(
 }
 
 static void build_prescale_params(struct ipp_prescale_params *prescale_params,
-		const struct core_surface *surface)
+		const struct dc_surface *surface)
 {
 	prescale_params->mode = IPP_PRESCALE_MODE_FIXED_UNSIGNED;
 
-	switch (surface->public.format) {
+	switch (surface->format) {
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
 	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
 		prescale_params->scale = 0x2020;
@@ -240,7 +240,7 @@ static void build_prescale_params(struct ipp_prescale_params *prescale_params,
 
 static bool dce110_set_input_transfer_func(
 	struct pipe_ctx *pipe_ctx,
-	const struct core_surface *surface)
+	const struct dc_surface *surface)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
 	const struct dc_transfer_func *tf = NULL;
@@ -250,14 +250,14 @@ static bool dce110_set_input_transfer_func(
 	if (ipp == NULL)
 		return false;
 
-	if (surface->public.in_transfer_func)
-		tf = surface->public.in_transfer_func;
+	if (surface->in_transfer_func)
+		tf = surface->in_transfer_func;
 
 	build_prescale_params(&prescale_params, surface);
 	ipp->funcs->ipp_program_prescale(ipp, &prescale_params);
 
-	if (surface->public.gamma_correction && dce_use_lut(surface))
-		ipp->funcs->ipp_program_input_lut(ipp, surface->public.gamma_correction);
+	if (surface->gamma_correction && dce_use_lut(surface))
+		ipp->funcs->ipp_program_input_lut(ipp, surface->gamma_correction);
 
 	if (tf == NULL) {
 		/* Default case if no input transfer function specified */
@@ -1857,7 +1857,7 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
 		default_adjust.in_color_space = COLOR_SPACE_SRGB;
 	else
 		default_adjust.in_color_space =
-				pipe_ctx->surface->public.color_space;
+				pipe_ctx->surface->color_space;
 	if (pipe_ctx->stream == NULL)
 		default_adjust.out_color_space = COLOR_SPACE_SRGB;
 	else
@@ -1908,16 +1908,16 @@ static void program_surface_visibility(const struct core_dc *dc,
 		/* For now we are supporting only two pipes */
 		ASSERT(pipe_ctx->bottom_pipe->bottom_pipe == NULL);
 
-		if (pipe_ctx->bottom_pipe->surface->public.visible) {
-			if (pipe_ctx->surface->public.visible)
+		if (pipe_ctx->bottom_pipe->surface->visible) {
+			if (pipe_ctx->surface->visible)
 				blender_mode = BLND_MODE_BLENDING;
 			else
 				blender_mode = BLND_MODE_OTHER_PIPE;
 
-		} else if (!pipe_ctx->surface->public.visible)
+		} else if (!pipe_ctx->surface->visible)
 			blank_target = true;
 
-	} else if (!pipe_ctx->surface->public.visible)
+	} else if (!pipe_ctx->surface->visible)
 		blank_target = true;
 
 	dce_set_blender_mode(dc->hwseq, pipe_ctx->pipe_idx, blender_mode);
@@ -1975,7 +1975,7 @@ static void set_plane_config(
 	struct resource_context *res_ctx)
 {
 	struct mem_input *mi = pipe_ctx->mi;
-	struct core_surface *surface = pipe_ctx->surface;
+	struct dc_surface *surface = pipe_ctx->surface;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
 	unsigned int i;
@@ -2040,42 +2040,42 @@ static void set_plane_config(
 
 	mi->funcs->mem_input_program_surface_config(
 			mi,
-			surface->public.format,
-			&surface->public.tiling_info,
-			&surface->public.plane_size,
-			surface->public.rotation,
+			surface->format,
+			&surface->tiling_info,
+			&surface->plane_size,
+			surface->rotation,
 			NULL,
 			false);
 	if (mi->funcs->set_blank)
-		mi->funcs->set_blank(mi, pipe_ctx->surface->public.visible);
+		mi->funcs->set_blank(mi, pipe_ctx->surface->visible);
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->mi,
-				surface->public.format,
-				&surface->public.tiling_info,
-				surface->public.rotation);
+				surface->format,
+				&surface->tiling_info,
+				surface->rotation);
 }
 
 static void update_plane_addr(const struct core_dc *dc,
 		struct pipe_ctx *pipe_ctx)
 {
-	struct core_surface *surface = pipe_ctx->surface;
+	struct dc_surface *surface = pipe_ctx->surface;
 
 	if (surface == NULL)
 		return;
 
 	pipe_ctx->mi->funcs->mem_input_program_surface_flip_and_addr(
 			pipe_ctx->mi,
-			&surface->public.address,
-			surface->public.flip_immediate);
+			&surface->address,
+			surface->flip_immediate);
 
-	surface->status.requested_address = surface->public.address;
+	surface->status.requested_address = surface->address;
 }
 
 void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)
 {
-	struct core_surface *surface = pipe_ctx->surface;
+	struct dc_surface *surface = pipe_ctx->surface;
 
 	if (surface == NULL)
 		return;
@@ -2084,7 +2084,7 @@ void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->mi->funcs->mem_input_is_flip_pending(
 					pipe_ctx->mi);
 
-	if (surface->status.is_flip_pending && !surface->public.visible)
+	if (surface->status.is_flip_pending && !surface->visible)
 		pipe_ctx->mi->current_address = pipe_ctx->mi->request_address;
 
 	surface->status.current_address = pipe_ctx->mi->current_address;
@@ -2425,7 +2425,7 @@ static void dce110_program_front_end_for_pipe(
 {
 	struct mem_input *mi = pipe_ctx->mi;
 	struct pipe_ctx *old_pipe = NULL;
-	struct core_surface *surface = pipe_ctx->surface;
+	struct dc_surface *surface = pipe_ctx->surface;
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
 	unsigned int i;
@@ -2493,21 +2493,21 @@ static void dce110_program_front_end_for_pipe(
 
 	mi->funcs->mem_input_program_surface_config(
 			mi,
-			surface->public.format,
-			&surface->public.tiling_info,
-			&surface->public.plane_size,
-			surface->public.rotation,
+			surface->format,
+			&surface->tiling_info,
+			&surface->plane_size,
+			surface->rotation,
 			NULL,
 			false);
 	if (mi->funcs->set_blank)
-		mi->funcs->set_blank(mi, pipe_ctx->surface->public.visible);
+		mi->funcs->set_blank(mi, pipe_ctx->surface->visible);
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->mi,
-				surface->public.format,
-				&surface->public.tiling_info,
-				surface->public.rotation);
+				surface->format,
+				&surface->tiling_info,
+				surface->rotation);
 
 	dm_logger_write(dc->ctx->logger, LOG_SURFACE,
 			"Pipe:%d 0x%x: addr hi:0x%x, "
@@ -2517,20 +2517,20 @@ static void dce110_program_front_end_for_pipe(
 			"clip: %d, %d, %d, %d\n",
 			pipe_ctx->pipe_idx,
 			pipe_ctx->surface,
-			pipe_ctx->surface->public.address.grph.addr.high_part,
-			pipe_ctx->surface->public.address.grph.addr.low_part,
-			pipe_ctx->surface->public.src_rect.x,
-			pipe_ctx->surface->public.src_rect.y,
-			pipe_ctx->surface->public.src_rect.width,
-			pipe_ctx->surface->public.src_rect.height,
-			pipe_ctx->surface->public.dst_rect.x,
-			pipe_ctx->surface->public.dst_rect.y,
-			pipe_ctx->surface->public.dst_rect.width,
-			pipe_ctx->surface->public.dst_rect.height,
-			pipe_ctx->surface->public.clip_rect.x,
-			pipe_ctx->surface->public.clip_rect.y,
-			pipe_ctx->surface->public.clip_rect.width,
-			pipe_ctx->surface->public.clip_rect.height);
+			pipe_ctx->surface->address.grph.addr.high_part,
+			pipe_ctx->surface->address.grph.addr.low_part,
+			pipe_ctx->surface->src_rect.x,
+			pipe_ctx->surface->src_rect.y,
+			pipe_ctx->surface->src_rect.width,
+			pipe_ctx->surface->src_rect.height,
+			pipe_ctx->surface->dst_rect.x,
+			pipe_ctx->surface->dst_rect.y,
+			pipe_ctx->surface->dst_rect.width,
+			pipe_ctx->surface->dst_rect.height,
+			pipe_ctx->surface->clip_rect.x,
+			pipe_ctx->surface->clip_rect.y,
+			pipe_ctx->surface->clip_rect.width,
+			pipe_ctx->surface->clip_rect.height);
 
 	dm_logger_write(dc->ctx->logger, LOG_SURFACE,
 			"Pipe %d: width, height, x, y\n"
@@ -2549,7 +2549,7 @@ static void dce110_program_front_end_for_pipe(
 
 static void dce110_apply_ctx_for_surface(
 		struct core_dc *dc,
-		struct core_surface *surface,
+		const struct dc_surface *surface,
 		struct validate_context *context)
 {
 	int i;

commit 08b1688620426ad3e09fc7a98aabc28dda30cde6
Author: Zeyu Fan <Zeyu.Fan@amd.com>
Date:   Sun Jul 23 18:30:15 2017 -0400

    drm/amd/display: Move DCHUBBUB block from MemInput to HW sequencer.
    
    Signed-off-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 6ab9712ed808..efba8d7964eb 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -49,6 +49,7 @@
 #include "abm.h"
 #include "audio.h"
 #include "dce/dce_hwseq.h"
+#include "reg_helper.h"
 
 /* include DCE11 register header files */
 #include "dce/dce_11_0_d.h"

commit b6762f0c16a43c3d2867fb652f8efa429f70c83d
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Mon Jul 24 11:18:29 2017 -0400

    drm/amd/display: add missing func for dce11o to avoid crash
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 72e099953a05..6ab9712ed808 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2582,6 +2582,11 @@ static void dce110_power_down_fe(struct core_dc *dc, int fe_idx)
 				dc->res_pool->transforms[fe_idx]);
 }
 
+static void dce110_wait_for_mpcc_disconnect(struct resource_pool *res_pool, struct pipe_ctx *pipe_ctx)
+{
+	/* do nothing*/
+}
+
 static const struct hw_sequencer_funcs dce110_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.init_hw = init_hw,
@@ -2611,6 +2616,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.prog_pixclk_crtc_otg = dce110_prog_pixclk_crtc_otg,
 	.setup_stereo = NULL,
 	.set_avmute = dce110_set_avmute,
+	.wait_for_mpcc_disconnect = dce110_wait_for_mpcc_disconnect
 };
 
 bool dce110_hw_sequencer_construct(struct core_dc *dc)

commit 0a87425a37b4c1f06d75949ea39e60455a2b0a4f
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Wed Jul 12 22:35:52 2017 -0400

    drm/amd/display: move VGA to HWSS from TG
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index baafe6609d24..72e099953a05 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1198,7 +1198,8 @@ static void disable_vga_and_power_gate_all_controllers(
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		tg = dc->res_pool->timing_generators[i];
 
-		tg->funcs->disable_vga(tg);
+		if (tg->funcs->disable_vga)
+			tg->funcs->disable_vga(tg);
 
 		/* Enable CLOCK gating for each pipe BEFORE controller
 		 * powergating. */

commit 516666318fe1f427ab81e2ebe45d116a9667c3b5
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jul 21 17:35:16 2017 -0400

    drm/amd/display: support for updated register headers on DCN
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index b691ef956d45..baafe6609d24 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -256,7 +256,7 @@ static bool dce110_set_input_transfer_func(
 	ipp->funcs->ipp_program_prescale(ipp, &prescale_params);
 
 	if (surface->public.gamma_correction && dce_use_lut(surface))
-	    ipp->funcs->ipp_program_input_lut(ipp, surface->public.gamma_correction);
+		ipp->funcs->ipp_program_input_lut(ipp, surface->public.gamma_correction);
 
 	if (tf == NULL) {
 		/* Default case if no input transfer function specified */

commit 15e173352eeae76286e0d018f9eec6b55726caa4
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Jul 17 16:04:02 2017 -0400

    drm/amd/display: fix aviInfoFrame bar Info and add set_avMute
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 5d64611eb6a6..b691ef956d45 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -801,6 +801,13 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 	pipe_ctx->stream_enc->funcs->dp_unblank(pipe_ctx->stream_enc, &params);
 }
 
+
+void dce110_set_avmute(struct pipe_ctx *pipe_ctx, bool enable)
+{
+	if (pipe_ctx != NULL && pipe_ctx->stream_enc != NULL)
+		pipe_ctx->stream_enc->funcs->set_avmute(pipe_ctx->stream_enc, enable);
+}
+
 static enum audio_dto_source translate_to_dto_source(enum controller_id crtc_id)
 {
 	switch (crtc_id) {
@@ -1095,10 +1102,11 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 			(pipe_ctx->stream->signal == SIGNAL_TYPE_DVI_DUAL_LINK) ?
 			true : false);
 
+	resource_build_info_frame(pipe_ctx);
+
 	if (!pipe_ctx_old->stream) {
 		core_link_enable_stream(pipe_ctx);
 
-	resource_build_info_frame(pipe_ctx);
 	dce110_update_info_frame(pipe_ctx);
 		if (dc_is_dp_signal(pipe_ctx->stream->signal))
 			dce110_unblank_stream(pipe_ctx,
@@ -2600,7 +2608,8 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.set_static_screen_control = set_static_screen_control,
 	.reset_hw_ctx_wrap = reset_hw_ctx_wrap,
 	.prog_pixclk_crtc_otg = dce110_prog_pixclk_crtc_otg,
-	.setup_stereo = NULL
+	.setup_stereo = NULL,
+	.set_avmute = dce110_set_avmute,
 };
 
 bool dce110_hw_sequencer_construct(struct core_dc *dc)

commit 7b0c470fcb44b7dbe63db5b5fb52b6123ebe335f
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Mon Jul 10 14:04:21 2017 -0400

    drm/amd/display: Flattening to dc_transfer_func
    
    Flattening dc transfer functions in the following manner:
    transfer_func > core_transfer_func > dc_transfer_func
    
    References to deleted structs are updated as needed.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index d3c84dc36b80..5d64611eb6a6 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -242,7 +242,7 @@ static bool dce110_set_input_transfer_func(
 	const struct core_surface *surface)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
-	const struct core_transfer_func *tf = NULL;
+	const struct dc_transfer_func *tf = NULL;
 	struct ipp_prescale_params prescale_params = { 0 };
 	bool result = true;
 
@@ -250,7 +250,7 @@ static bool dce110_set_input_transfer_func(
 		return false;
 
 	if (surface->public.in_transfer_func)
-		tf = DC_TRANSFER_FUNC_TO_CORE(surface->public.in_transfer_func);
+		tf = surface->public.in_transfer_func;
 
 	build_prescale_params(&prescale_params, surface);
 	ipp->funcs->ipp_program_prescale(ipp, &prescale_params);
@@ -262,8 +262,8 @@ static bool dce110_set_input_transfer_func(
 		/* Default case if no input transfer function specified */
 		ipp->funcs->ipp_set_degamma(ipp,
 				IPP_DEGAMMA_MODE_HW_sRGB);
-	} else if (tf->public.type == TF_TYPE_PREDEFINED) {
-		switch (tf->public.tf) {
+	} else if (tf->type == TF_TYPE_PREDEFINED) {
+		switch (tf->tf) {
 		case TRANSFER_FUNCTION_SRGB:
 			ipp->funcs->ipp_set_degamma(ipp,
 					IPP_DEGAMMA_MODE_HW_sRGB);
@@ -283,7 +283,7 @@ static bool dce110_set_input_transfer_func(
 			result = false;
 			break;
 		}
-	} else if (tf->public.type == TF_TYPE_BYPASS) {
+	} else if (tf->type == TF_TYPE_BYPASS) {
 		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
 	} else {
 		/*TF_TYPE_DISTRIBUTED_POINTS - Not supported in DCE 11*/

commit 87449a90c2545eaed5757153770346563378463b
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Jul 6 14:27:49 2017 -0400

    drm/amd/display: Fix MPO visual confirm
    
    1. Need to blend non-active area to show visual confirm borders
    2. Set number of Visual Confirm lines based on pipe instance
    3. Set Different colors representing surface format of bottom most plan
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 8778af76f4e0..d3c84dc36b80 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -916,11 +916,15 @@ static void get_surface_visual_confirm_color(const struct pipe_ctx *pipe_ctx,
 		/* set boarder color to blue */
 		color->color_b_cb = color_value;
 		break;
-	case PIXEL_FORMAT_420BPP12:
-	case PIXEL_FORMAT_420BPP15:
+	case PIXEL_FORMAT_420BPP8:
 		/* set boarder color to green */
 		color->color_g_y = color_value;
 		break;
+	case PIXEL_FORMAT_420BPP10:
+		/* set boarder color to yellow */
+		color->color_g_y = color_value;
+		color->color_r_cr = color_value;
+		break;
 	case PIXEL_FORMAT_FP16:
 		/* set boarder color to white */
 		color->color_r_cr = color_value;

commit c3aa1d67295c8fc87364dfe8920c9e30775fd124
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Fri Jun 30 15:19:55 2017 -0400

    drm/amd/display: Set static screen register for stoney/carrizo
    
    -Set CRTC_STATIC_SCREEN_EVENT for stoney/carrizo for FBC implementation
    -Code is currently guarded with "ENABLE_FBC" compile time flag
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 72d5f753949d..8778af76f4e0 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1395,6 +1395,10 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
 	if (events->cursor_update)
 		value |= 0x2;
 
+#ifdef ENABLE_FBC
+	value |= 0x84;
+#endif
+
 	for (i = 0; i < num_pipes; i++)
 		pipe_ctx[i]->tg->funcs->
 			set_static_screen_control(pipe_ctx[i]->tg, value);

commit 1663ae1c4288da81b9f1668d204aa8ed55ebf849
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Jun 27 16:34:27 2017 -0400

    drm/amd/display: Connect DC resource to FBC compressor
    
    - Connected DC resource to FBC compressor,
    - Initial Implementation of FBC for Stoney/Carrizo
    - Code is currently guarded with "ENABLE_FBC" compile time flag
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index fd1cb7fe45bc..72d5f753949d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -33,6 +33,10 @@
 #include "dce110_timing_generator.h"
 #include "dce/dce_hwseq.h"
 
+#ifdef ENABLE_FBC
+#include "dce110_compressor.h"
+#endif
+
 #include "bios/bios_parser_helper.h"
 #include "timing_generator.h"
 #include "mem_input.h"
@@ -1166,6 +1170,10 @@ static void power_down_all_hw_blocks(struct core_dc *dc)
 	power_down_controllers(dc);
 
 	power_down_clock_sources(dc);
+
+#ifdef ENABLE_FBC
+	dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);
+#endif
 }
 
 static void disable_vga_and_power_gate_all_controllers(
@@ -1630,6 +1638,10 @@ enum dc_status dce110_apply_ctx_to_hw(
 	}
 
 	set_safe_displaymarks(&context->res_ctx, dc->res_pool);
+
+#ifdef ENABLE_FBC
+	dc->fbc_compressor->funcs->disable_fbc(dc->fbc_compressor);
+#endif
 	/*TODO: when pplib works*/
 	apply_min_clocks(dc, context, &clocks_state, true);
 
@@ -2215,6 +2227,9 @@ static void init_hw(struct core_dc *dc)
 		abm->funcs->init_backlight(abm);
 		abm->funcs->abm_init(abm);
 	}
+#ifdef ENABLE_FBC
+	dc->fbc_compressor->funcs->power_up_fbc(dc->fbc_compressor);
+#endif
 }
 
 void dce110_fill_display_configs(

commit cfe4645e17f8dbe680c35c439d000313f2648482
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jun 14 18:58:04 2017 -0400

    drm/amd/display: fix dcn pipe reset sequence
    
    This change fixes dcn10 front end reset sequence. Previously we
    would reset front end during flip which led to issues
    in certain MPO and 4k/5k scenarios. We would also never properly
    power gate our front end.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 0bab85b27a85..fd1cb7fe45bc 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1185,8 +1185,7 @@ static void disable_vga_and_power_gate_all_controllers(
 		enable_display_pipe_clock_gating(ctx,
 				true);
 
-		dc->hwss.power_down_front_end(
-			dc, &dc->current_context->res_ctx.pipe_ctx[i]);
+		dc->hwss.power_down_front_end(dc, i);
 	}
 }
 
@@ -1340,7 +1339,7 @@ static void reset_single_pipe_hw_ctx(
 	resource_unreference_clock_source(&context->res_ctx, dc->res_pool,
 			 &pipe_ctx->clock_source);
 
-	dc->hwss.power_down_front_end((struct core_dc *)dc, pipe_ctx);
+	dc->hwss.power_down_front_end((struct core_dc *)dc, pipe_ctx->pipe_idx);
 
 	pipe_ctx->stream = NULL;
 }
@@ -2538,17 +2537,17 @@ static void dce110_apply_ctx_for_surface(
 	}
 }
 
-static void dce110_power_down_fe(struct core_dc *dc, struct pipe_ctx *pipe)
+static void dce110_power_down_fe(struct core_dc *dc, int fe_idx)
 {
 	/* Do not power down fe when stream is active on dce*/
-	if (pipe->stream)
+	if (dc->current_context->res_ctx.pipe_ctx[fe_idx].stream)
 		return;
 
 	dc->hwss.enable_display_power_gating(
-		dc, pipe->pipe_idx, dc->ctx->dc_bios, PIPE_GATING_CONTROL_ENABLE);
-	if (pipe->xfm)
-		pipe->xfm->funcs->transform_reset(pipe->xfm);
-	memset(&pipe->scl_data, 0, sizeof(struct scaler_data));
+		dc, fe_idx, dc->ctx->dc_bios, PIPE_GATING_CONTROL_ENABLE);
+
+	dc->res_pool->transforms[fe_idx]->funcs->transform_reset(
+				dc->res_pool->transforms[fe_idx]);
 }
 
 static const struct hw_sequencer_funcs dce110_funcs = {

commit 866294f80582e252913c72b5e0f1792f6133424d
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Jun 21 16:48:06 2017 -0400

    drm/amd/display: Don't program scaler if we have no surface
    
    If we don't have a surface in dc_commit_streams scl_data won't get
    populated in resource_build_scaling_params_for_context. In this case we
    shouldn't attempt to program the scaler.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index a83d260cda45..0bab85b27a85 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1099,10 +1099,12 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 
 	pipe_ctx->scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
 	/* program_scaler and allocate_mem_input are not new asic */
-	if (!pipe_ctx_old || memcmp(&pipe_ctx_old->scl_data,
-				&pipe_ctx->scl_data,
-				sizeof(struct scaler_data)) != 0)
+	if ((!pipe_ctx_old ||
+	     memcmp(&pipe_ctx_old->scl_data, &pipe_ctx->scl_data,
+		    sizeof(struct scaler_data)) != 0) &&
+	     pipe_ctx->surface) {
 		program_scaler(dc, pipe_ctx);
+	}
 
 	/* mst support - use total stream count */
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)

commit 7950f0f9815a2dc2e3e1cc2d341d486ac2ae8bae
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Jun 13 17:08:22 2017 -0400

    drm/amd/display: fix dc_post_update_surfaces_to_stream
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 7c509811efa6..a83d260cda45 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2538,17 +2538,12 @@ static void dce110_apply_ctx_for_surface(
 
 static void dce110_power_down_fe(struct core_dc *dc, struct pipe_ctx *pipe)
 {
-	int i;
-
-	for (i = 0; i < dc->res_pool->pipe_count; i++)
-		if (&dc->current_context->res_ctx.pipe_ctx[i] == pipe)
-			break;
-
-	if (i == dc->res_pool->pipe_count)
+	/* Do not power down fe when stream is active on dce*/
+	if (pipe->stream)
 		return;
 
 	dc->hwss.enable_display_power_gating(
-		dc, i, dc->ctx->dc_bios, PIPE_GATING_CONTROL_ENABLE);
+		dc, pipe->pipe_idx, dc->ctx->dc_bios, PIPE_GATING_CONTROL_ENABLE);
 	if (pipe->xfm)
 		pipe->xfm->funcs->transform_reset(pipe->xfm);
 	memset(&pipe->scl_data, 0, sizeof(struct scaler_data));

commit c8210d5ae37b3c0e5dc2a91095dd1147c524977d
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Jun 9 10:12:36 2017 -0400

    drm/amd/display: Don't call DCN clk code for Vega
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index ac99d283bf0a..7c509811efa6 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1633,7 +1633,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 	apply_min_clocks(dc, context, &clocks_state, true);
 
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	if (resource_parse_asic_id(dc->ctx->asic_id) == DCN_VERSION_1_0) {
+	if (dc->ctx->dce_version == DCN_VERSION_1_0) {
 		if (context->bw.dcn.calc_clk.fclk_khz
 				> dc->current_context->bw.dcn.cur_clk.fclk_khz) {
 			struct dm_pp_clock_for_voltage_req clock;

commit 7f5c22d1652327b64375e88b184b0df502c7bdc7
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Thu Jun 8 15:55:02 2017 -0500

    drm/amd/display: RV stereo support
    
    HDMI frame pack and DP frame alternate in band
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 616533e25534..ac99d283bf0a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2057,6 +2057,11 @@ void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)
 		pipe_ctx->mi->current_address = pipe_ctx->mi->request_address;
 
 	surface->status.current_address = pipe_ctx->mi->current_address;
+	if (pipe_ctx->mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
+			pipe_ctx->tg->funcs->is_stereo_left_eye) {
+		surface->status.is_right_eye =\
+				!pipe_ctx->tg->funcs->is_stereo_left_eye(pipe_ctx->tg);
+	}
 }
 
 void dce110_power_down(struct core_dc *dc)
@@ -2576,6 +2581,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.set_static_screen_control = set_static_screen_control,
 	.reset_hw_ctx_wrap = reset_hw_ctx_wrap,
 	.prog_pixclk_crtc_otg = dce110_prog_pixclk_crtc_otg,
+	.setup_stereo = NULL
 };
 
 bool dce110_hw_sequencer_construct(struct core_dc *dc)

commit 1bf56e62cc4fbff6d701b798da05a91f78aa12e9
Author: Zeyu Fan <Zeyu.Fan@amd.com>
Date:   Fri Jun 2 17:25:49 2017 -0400

    drm/amd/display: Call program_gamut explicitly instead of entire set_plane
    
    This fixes on boot crush on Vega, Polaris with Dal3.
    
    Signed-off-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 7dd4b02b5938..616533e25534 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1894,6 +1894,47 @@ static void program_surface_visibility(const struct core_dc *dc,
 
 }
 
+static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
+{
+	struct xfm_grph_csc_adjustment adjust;
+	memset(&adjust, 0, sizeof(adjust));
+	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
+
+
+	if (pipe_ctx->stream->public.gamut_remap_matrix.enable_remap == true) {
+		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
+		adjust.temperature_matrix[0] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[0];
+		adjust.temperature_matrix[1] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[1];
+		adjust.temperature_matrix[2] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[2];
+		adjust.temperature_matrix[3] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[4];
+		adjust.temperature_matrix[4] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[5];
+		adjust.temperature_matrix[5] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[6];
+		adjust.temperature_matrix[6] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[8];
+		adjust.temperature_matrix[7] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[9];
+		adjust.temperature_matrix[8] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[10];
+	}
+
+	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
+}
+
 /**
  * TODO REMOVE, USE UPDATE INSTEAD
  */
@@ -2509,6 +2550,7 @@ static void dce110_power_down_fe(struct core_dc *dc, struct pipe_ctx *pipe)
 }
 
 static const struct hw_sequencer_funcs dce110_funcs = {
+	.program_gamut_remap = program_gamut_remap,
 	.init_hw = init_hw,
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
 	.apply_ctx_for_surface = dce110_apply_ctx_for_surface,

commit c1473558e617d886276e4a8b3c139b681d90d67c
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Fri May 19 17:40:50 2017 -0400

    drm/amd/display: program scaler not called.
    
    Scaler code in case of UPDATE_TYPE_MED was not called
    since new pipe context and current context are the same.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 65c691569eb7..7dd4b02b5938 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2408,10 +2408,8 @@ static void dce110_program_front_end_for_pipe(
 	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
 
 	pipe_ctx->scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
-	if (old_pipe && memcmp(&old_pipe->scl_data,
-				&pipe_ctx->scl_data,
-				sizeof(struct scaler_data)) != 0)
-		program_scaler(dc, pipe_ctx);
+
+	program_scaler(dc, pipe_ctx);
 
 	mi->funcs->mem_input_program_surface_config(
 			mi,

commit 98489c026edc48d9c783f783cc82f2e8811e0ee4
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue May 16 13:52:28 2017 -0400

    drm/amd/display: Refactor use_lut() from dce110 to dce
    
    use_lut() checks if the input surface's pixel format is compatible with
    a 256 entry LUT. This function can be used across different versions and
    not just dce11.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 20ad1cb263db..65c691569eb7 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -28,10 +28,10 @@
 #include "core_types.h"
 #include "core_status.h"
 #include "resource.h"
-#include "hw_sequencer.h"
 #include "dm_helpers.h"
 #include "dce110_hw_sequencer.h"
 #include "dce110_timing_generator.h"
+#include "dce/dce_hwseq.h"
 
 #include "bios/bios_parser_helper.h"
 #include "timing_generator.h"
@@ -233,19 +233,6 @@ static void build_prescale_params(struct ipp_prescale_params *prescale_params,
 	}
 }
 
-
-/* Only use LUT for 8 bit formats */
-static bool use_lut(const struct core_surface *surface)
-{
-	switch (surface->public.format) {
-	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
-	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
-		return true;
-	default:
-		return false;
-	}
-}
-
 static bool dce110_set_input_transfer_func(
 	struct pipe_ctx *pipe_ctx,
 	const struct core_surface *surface)
@@ -264,7 +251,7 @@ static bool dce110_set_input_transfer_func(
 	build_prescale_params(&prescale_params, surface);
 	ipp->funcs->ipp_program_prescale(ipp, &prescale_params);
 
-	if (surface->public.gamma_correction && use_lut(surface))
+	if (surface->public.gamma_correction && dce_use_lut(surface))
 	    ipp->funcs->ipp_program_input_lut(ipp, surface->public.gamma_correction);
 
 	if (tf == NULL) {

commit 4b28b76bfe14430a91de74a5cf9215f3c108acf9
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu May 11 17:15:14 2017 -0400

    drm/amd/display: fix mpo blanking out on one of planes being set not visible
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 8a663003017c..20ad1cb263db 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1986,8 +1986,9 @@ static void set_plane_config(
 			&surface->public.plane_size,
 			surface->public.rotation,
 			NULL,
-			false,
-			pipe_ctx->surface->public.visible);
+			false);
+	if (mi->funcs->set_blank)
+		mi->funcs->set_blank(mi, pipe_ctx->surface->public.visible);
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
@@ -2432,8 +2433,9 @@ static void dce110_program_front_end_for_pipe(
 			&surface->public.plane_size,
 			surface->public.rotation,
 			NULL,
-			false,
-			pipe_ctx->surface->public.visible);
+			false);
+	if (mi->funcs->set_blank)
+		mi->funcs->set_blank(mi, pipe_ctx->surface->public.visible);
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(

commit f46661dd42f3648b92eca73ba2c48f5d9a418b1b
Author: Amy Zhang <Amy.Zhang@amd.com>
Date:   Tue May 9 14:45:54 2017 -0400

    drm/amd/display: Move output transfer function to stream updates
    
    Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 150c8a4e7b61..8a663003017c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -631,7 +631,6 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 
 static bool dce110_set_output_transfer_func(
 	struct pipe_ctx *pipe_ctx,
-	const struct core_surface *surface, /* Surface - To be removed */
 	const struct core_stream *stream)
 {
 	struct output_pixel_processor *opp = pipe_ctx->opp;

commit c66a54dc4a8403ab269568b3f964b0efd4052932
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 3 11:40:40 2017 -0400

    drm/amd/display: switch to using calc_clk and cur_clk for dcn bw setting
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 41aeceba5ae5..150c8a4e7b61 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1647,24 +1647,38 @@ enum dc_status dce110_apply_ctx_to_hw(
 	apply_min_clocks(dc, context, &clocks_state, true);
 
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	if (context->bw.dcn.calc_clk.fclk_khz
-			> dc->current_context->bw.dcn.calc_clk.fclk_khz) {
-		struct dm_pp_clock_for_voltage_req clock;
-
-		clock.clk_type = DM_PP_CLOCK_TYPE_FCLK;
-		clock.clocks_in_khz = context->bw.dcn.calc_clk.fclk_khz;
-		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
-		dc->current_context->bw.dcn.calc_clk.fclk_khz = clock.clocks_in_khz;
-	}
-	if (context->bw.dcn.calc_clk.dcfclk_khz
-			> dc->current_context->bw.dcn.calc_clk.dcfclk_khz) {
-		struct dm_pp_clock_for_voltage_req clock;
-
-		clock.clk_type = DM_PP_CLOCK_TYPE_DCFCLK;
-		clock.clocks_in_khz = context->bw.dcn.calc_clk.dcfclk_khz;
-		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
-		dc->current_context->bw.dcn.calc_clk.dcfclk_khz = clock.clocks_in_khz;
-	}
+	if (resource_parse_asic_id(dc->ctx->asic_id) == DCN_VERSION_1_0) {
+		if (context->bw.dcn.calc_clk.fclk_khz
+				> dc->current_context->bw.dcn.cur_clk.fclk_khz) {
+			struct dm_pp_clock_for_voltage_req clock;
+
+			clock.clk_type = DM_PP_CLOCK_TYPE_FCLK;
+			clock.clocks_in_khz = context->bw.dcn.calc_clk.fclk_khz;
+			dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
+			dc->current_context->bw.dcn.cur_clk.fclk_khz = clock.clocks_in_khz;
+			context->bw.dcn.cur_clk.fclk_khz = clock.clocks_in_khz;
+		}
+		if (context->bw.dcn.calc_clk.dcfclk_khz
+				> dc->current_context->bw.dcn.cur_clk.dcfclk_khz) {
+			struct dm_pp_clock_for_voltage_req clock;
+
+			clock.clk_type = DM_PP_CLOCK_TYPE_DCFCLK;
+			clock.clocks_in_khz = context->bw.dcn.calc_clk.dcfclk_khz;
+			dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
+			dc->current_context->bw.dcn.cur_clk.dcfclk_khz = clock.clocks_in_khz;
+			context->bw.dcn.cur_clk.dcfclk_khz = clock.clocks_in_khz;
+		}
+		if (context->bw.dcn.calc_clk.dispclk_khz
+				> dc->current_context->bw.dcn.cur_clk.dispclk_khz) {
+			dc->res_pool->display_clock->funcs->set_clock(
+					dc->res_pool->display_clock,
+					context->bw.dcn.calc_clk.dispclk_khz);
+			dc->current_context->bw.dcn.cur_clk.dispclk_khz =
+					context->bw.dcn.calc_clk.dispclk_khz;
+			context->bw.dcn.cur_clk.dispclk_khz =
+					context->bw.dcn.calc_clk.dispclk_khz;
+		}
+	} else
 #endif
 	if (context->bw.dce.dispclk_khz
 			> dc->current_context->bw.dce.dispclk_khz) {

commit 9037d802a97812cb8d614b48f817a5532cf1558c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue May 2 17:29:48 2017 -0400

    drm/amd/display: refactor bw related variable structure in val_ctx
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index c89df8acb458..41aeceba5ae5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1252,17 +1252,17 @@ void dce110_set_displaymarks(
 			dc->bw_vbios.blackout_duration, pipe_ctx->stream);
 		pipe_ctx->mi->funcs->mem_input_program_display_marks(
 			pipe_ctx->mi,
-			context->bw_results.nbp_state_change_wm_ns[num_pipes],
-			context->bw_results.stutter_exit_wm_ns[num_pipes],
-			context->bw_results.urgent_wm_ns[num_pipes],
+			context->bw.dce.nbp_state_change_wm_ns[num_pipes],
+			context->bw.dce.stutter_exit_wm_ns[num_pipes],
+			context->bw.dce.urgent_wm_ns[num_pipes],
 			total_dest_line_time_ns);
 		if (i == underlay_idx) {
 			num_pipes++;
 			pipe_ctx->mi->funcs->mem_input_program_chroma_display_marks(
 				pipe_ctx->mi,
-				context->bw_results.nbp_state_change_wm_ns[num_pipes],
-				context->bw_results.stutter_exit_wm_ns[num_pipes],
-				context->bw_results.urgent_wm_ns[num_pipes],
+				context->bw.dce.nbp_state_change_wm_ns[num_pipes],
+				context->bw.dce.stutter_exit_wm_ns[num_pipes],
+				context->bw.dce.urgent_wm_ns[num_pipes],
 				total_dest_line_time_ns);
 		}
 		num_pipes++;
@@ -1275,9 +1275,9 @@ static void set_safe_displaymarks(
 {
 	int i;
 	int underlay_idx = pool->underlay_pipe_index;
-	struct bw_watermarks max_marks = {
+	struct dce_watermarks max_marks = {
 		MAX_WATERMARK, MAX_WATERMARK, MAX_WATERMARK, MAX_WATERMARK };
-	struct bw_watermarks nbp_marks = {
+	struct dce_watermarks nbp_marks = {
 		SAFE_NBP_MARK, SAFE_NBP_MARK, SAFE_NBP_MARK, SAFE_NBP_MARK };
 
 	for (i = 0; i < MAX_PIPES; i++) {
@@ -1502,7 +1502,7 @@ static void apply_min_clocks(
 	/* get the required state based on state dependent clocks:
 	 * display clock and pixel clock
 	 */
-	req_clocks.display_clk_khz = context->dispclk_khz;
+	req_clocks.display_clk_khz = context->bw.dce.dispclk_khz;
 
 	req_clocks.pixel_clk_khz = get_max_pixel_clock_for_all_paths(
 			dc, context, true);
@@ -1647,30 +1647,30 @@ enum dc_status dce110_apply_ctx_to_hw(
 	apply_min_clocks(dc, context, &clocks_state, true);
 
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	if (context->fclk_khz
-			> dc->current_context->fclk_khz) {
+	if (context->bw.dcn.calc_clk.fclk_khz
+			> dc->current_context->bw.dcn.calc_clk.fclk_khz) {
 		struct dm_pp_clock_for_voltage_req clock;
 
 		clock.clk_type = DM_PP_CLOCK_TYPE_FCLK;
-		clock.clocks_in_khz = context->fclk_khz;
+		clock.clocks_in_khz = context->bw.dcn.calc_clk.fclk_khz;
 		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
-		dc->current_context->fclk_khz = clock.clocks_in_khz;
+		dc->current_context->bw.dcn.calc_clk.fclk_khz = clock.clocks_in_khz;
 	}
-	if (context->dcfclk_khz
-			> dc->current_context->dcfclk_khz) {
+	if (context->bw.dcn.calc_clk.dcfclk_khz
+			> dc->current_context->bw.dcn.calc_clk.dcfclk_khz) {
 		struct dm_pp_clock_for_voltage_req clock;
 
 		clock.clk_type = DM_PP_CLOCK_TYPE_DCFCLK;
-		clock.clocks_in_khz = context->dcfclk_khz;
+		clock.clocks_in_khz = context->bw.dcn.calc_clk.dcfclk_khz;
 		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
-		dc->current_context->dcfclk_khz = clock.clocks_in_khz;
+		dc->current_context->bw.dcn.calc_clk.dcfclk_khz = clock.clocks_in_khz;
 	}
 #endif
-	if (context->dispclk_khz
-			> dc->current_context->dispclk_khz) {
+	if (context->bw.dce.dispclk_khz
+			> dc->current_context->bw.dce.dispclk_khz) {
 		dc->res_pool->display_clock->funcs->set_clock(
 				dc->res_pool->display_clock,
-				context->dispclk_khz * 115 / 100);
+				context->bw.dce.dispclk_khz * 115 / 100);
 	}
 	/* program audio wall clock. use HDMI as clock source if HDMI
 	 * audio active. Otherwise, use DP as clock source
@@ -2275,32 +2275,32 @@ static void pplib_apply_display_requirements(
 	struct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;
 
 	pp_display_cfg->all_displays_in_sync =
-		context->bw_results.all_displays_in_sync;
+		context->bw.dce.all_displays_in_sync;
 	pp_display_cfg->nb_pstate_switch_disable =
-			context->bw_results.nbp_state_change_enable == false;
+			context->bw.dce.nbp_state_change_enable == false;
 	pp_display_cfg->cpu_cc6_disable =
-			context->bw_results.cpuc_state_change_enable == false;
+			context->bw.dce.cpuc_state_change_enable == false;
 	pp_display_cfg->cpu_pstate_disable =
-			context->bw_results.cpup_state_change_enable == false;
+			context->bw.dce.cpup_state_change_enable == false;
 	pp_display_cfg->cpu_pstate_separation_time =
-			context->bw_results.blackout_recovery_time_us;
+			context->bw.dce.blackout_recovery_time_us;
 
-	pp_display_cfg->min_memory_clock_khz = context->bw_results.required_yclk
+	pp_display_cfg->min_memory_clock_khz = context->bw.dce.yclk_khz
 		/ MEMORY_TYPE_MULTIPLIER;
 
 	pp_display_cfg->min_engine_clock_khz = determine_sclk_from_bounding_box(
 			dc,
-			context->bw_results.required_sclk);
+			context->bw.dce.sclk_khz);
 
 	pp_display_cfg->min_engine_clock_deep_sleep_khz
-			= context->bw_results.required_sclk_deep_sleep;
+			= context->bw.dce.sclk_deep_sleep_khz;
 
 	pp_display_cfg->avail_mclk_switch_time_us =
 						dce110_get_min_vblank_time_us(context);
 	/* TODO: dce11.2*/
 	pp_display_cfg->avail_mclk_switch_time_in_disp_active_us = 0;
 
-	pp_display_cfg->disp_clk_khz = context->dispclk_khz;
+	pp_display_cfg->disp_clk_khz = context->bw.dce.dispclk_khz;
 
 	dce110_fill_display_configs(context, pp_display_cfg);
 
@@ -2329,12 +2329,11 @@ static void dce110_set_bandwidth(
 {
 	dce110_set_displaymarks(dc, context);
 
-	if (decrease_allowed || context->dispclk_khz > dc->current_context->dispclk_khz) {
+	if (decrease_allowed || context->bw.dce.dispclk_khz > dc->current_context->bw.dce.dispclk_khz) {
 		dc->res_pool->display_clock->funcs->set_clock(
 				dc->res_pool->display_clock,
-				context->dispclk_khz * 115 / 100);
-		dc->current_context->bw_results.dispclk_khz = context->dispclk_khz;
-		dc->current_context->dispclk_khz = context->dispclk_khz;
+				context->bw.dce.dispclk_khz * 115 / 100);
+		dc->current_context->bw.dce.dispclk_khz = context->bw.dce.dispclk_khz;
 	}
 
 	pplib_apply_display_requirements(dc, context);

commit ff5ef99248662ef98a64c11c5370ecd9fbbf57a6
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Jun 15 16:27:42 2017 -0400

    drm/amdgpu/display: Enable DCN in DC
    
    Enable DCN in DC.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index dc4c16416370..c89df8acb458 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -947,6 +947,12 @@ static void program_scaler(const struct core_dc *dc,
 {
 	struct tg_color color = {0};
 
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+	/* TOFPGA */
+	if (pipe_ctx->xfm->funcs->transform_set_pixel_storage_depth == NULL)
+		return;
+#endif
+
 	if (dc->public.debug.surface_visual_confirm)
 		get_surface_visual_confirm_color(pipe_ctx, &color);
 	else
@@ -1113,6 +1119,9 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 		program_scaler(dc, pipe_ctx);
 
 	/* mst support - use total stream count */
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+	if (pipe_ctx->mi->funcs->allocate_mem_input != NULL)
+#endif
 		pipe_ctx->mi->funcs->allocate_mem_input(
 					pipe_ctx->mi,
 					stream->public.timing.h_total,
@@ -1637,6 +1646,26 @@ enum dc_status dce110_apply_ctx_to_hw(
 	/*TODO: when pplib works*/
 	apply_min_clocks(dc, context, &clocks_state, true);
 
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+	if (context->fclk_khz
+			> dc->current_context->fclk_khz) {
+		struct dm_pp_clock_for_voltage_req clock;
+
+		clock.clk_type = DM_PP_CLOCK_TYPE_FCLK;
+		clock.clocks_in_khz = context->fclk_khz;
+		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
+		dc->current_context->fclk_khz = clock.clocks_in_khz;
+	}
+	if (context->dcfclk_khz
+			> dc->current_context->dcfclk_khz) {
+		struct dm_pp_clock_for_voltage_req clock;
+
+		clock.clk_type = DM_PP_CLOCK_TYPE_DCFCLK;
+		clock.clocks_in_khz = context->dcfclk_khz;
+		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
+		dc->current_context->dcfclk_khz = clock.clocks_in_khz;
+	}
+#endif
 	if (context->dispclk_khz
 			> dc->current_context->dispclk_khz) {
 		dc->res_pool->display_clock->funcs->set_clock(

commit a2b8659db9b435853cb0dc78d225a492e7ee69d0
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Sat Apr 22 14:17:51 2017 -0400

    drm/amd/display: decouple resource_pool from resource_context
    
    to avoid null access in case res_ctx is used to access res_pool before it's fully constructed
    
    also make it clear which function has dependency on resource_pool
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 0e69aceb0bad..dc4c16416370 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1260,10 +1260,12 @@ void dce110_set_displaymarks(
 	}
 }
 
-static void set_safe_displaymarks(struct resource_context *res_ctx)
+static void set_safe_displaymarks(
+		struct resource_context *res_ctx,
+		const struct resource_pool *pool)
 {
 	int i;
-	int underlay_idx = res_ctx->pool->underlay_pipe_index;
+	int underlay_idx = pool->underlay_pipe_index;
 	struct bw_watermarks max_marks = {
 		MAX_WATERMARK, MAX_WATERMARK, MAX_WATERMARK, MAX_WATERMARK };
 	struct bw_watermarks nbp_marks = {
@@ -1308,9 +1310,11 @@ static void switch_dp_clock_sources(
 			if (clk_src &&
 				clk_src != pipe_ctx->clock_source) {
 				resource_unreference_clock_source(
-					res_ctx, &pipe_ctx->clock_source);
+					res_ctx, dc->res_pool,
+					&pipe_ctx->clock_source);
 				pipe_ctx->clock_source = clk_src;
-				resource_reference_clock_source(res_ctx, clk_src);
+				resource_reference_clock_source(
+						res_ctx, dc->res_pool, clk_src);
 
 				dce_crtc_switch_to_clk_src(dc->hwseq, clk_src, i);
 			}
@@ -1336,8 +1340,8 @@ static void reset_single_pipe_hw_ctx(
 	pipe_ctx->tg->funcs->disable_crtc(pipe_ctx->tg);
 	pipe_ctx->mi->funcs->free_mem_input(
 				pipe_ctx->mi, context->stream_count);
-	resource_unreference_clock_source(
-			&context->res_ctx, &pipe_ctx->clock_source);
+	resource_unreference_clock_source(&context->res_ctx, dc->res_pool,
+			 &pipe_ctx->clock_source);
 
 	dc->hwss.power_down_front_end((struct core_dc *)dc, pipe_ctx);
 
@@ -1530,7 +1534,7 @@ static enum dc_status apply_ctx_to_hw_fpga(
 	enum dc_status status = DC_ERROR_UNEXPECTED;
 	int i;
 
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx_old =
 				&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
@@ -1561,7 +1565,7 @@ static void reset_hw_ctx_wrap(
 
 	/* Reset old context */
 	/* look up the targets that have been removed since last commit */
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx_old =
 			&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
@@ -1609,7 +1613,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 	dcb->funcs->set_scratch_critical_state(dcb, true);
 
 	/* below is for real asic only */
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx_old =
 					&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
@@ -1629,14 +1633,14 @@ enum dc_status dce110_apply_ctx_to_hw(
 				PIPE_GATING_CONTROL_DISABLE);
 	}
 
-	set_safe_displaymarks(&context->res_ctx);
+	set_safe_displaymarks(&context->res_ctx, dc->res_pool);
 	/*TODO: when pplib works*/
 	apply_min_clocks(dc, context, &clocks_state, true);
 
 	if (context->dispclk_khz
 			> dc->current_context->dispclk_khz) {
-		context->res_ctx.pool->display_clock->funcs->set_clock(
-				context->res_ctx.pool->display_clock,
+		dc->res_pool->display_clock->funcs->set_clock(
+				dc->res_pool->display_clock,
 				context->dispclk_khz * 115 / 100);
 	}
 	/* program audio wall clock. use HDMI as clock source if HDMI
@@ -1658,7 +1662,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 	* find first available pipe with audio, setup audio wall DTO per topology
 	* instead of per pipe.
 	*/
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->stream == NULL)
@@ -1685,8 +1689,8 @@ enum dc_status dce110_apply_ctx_to_hw(
 	}
 
 	/* no HDMI audio is found, try DP audio */
-	if (i == context->res_ctx.pool->pipe_count) {
-		for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+	if (i == dc->res_pool->pipe_count) {
+		for (i = 0; i < dc->res_pool->pipe_count; i++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 			if (pipe_ctx->stream == NULL)
@@ -1713,7 +1717,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 		}
 	}
 
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx_old =
 					&dc->current_context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
@@ -2297,8 +2301,8 @@ static void dce110_set_bandwidth(
 	dce110_set_displaymarks(dc, context);
 
 	if (decrease_allowed || context->dispclk_khz > dc->current_context->dispclk_khz) {
-		context->res_ctx.pool->display_clock->funcs->set_clock(
-				context->res_ctx.pool->display_clock,
+		dc->res_pool->display_clock->funcs->set_clock(
+				dc->res_pool->display_clock,
 				context->dispclk_khz * 115 / 100);
 		dc->current_context->bw_results.dispclk_khz = context->dispclk_khz;
 		dc->current_context->dispclk_khz = context->dispclk_khz;
@@ -2446,7 +2450,7 @@ static void dce110_apply_ctx_for_surface(
 	if (!surface)
 		return;
 
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->surface != surface)

commit 72ada5f76939ed00c07c584be7691a29d3c2c3da
Author: Eric Cook <Eric.Cook@amd.com>
Date:   Tue Apr 18 15:24:50 2017 -0400

    drm/amd/display: FreeSync Auto Sweep Support
    
    Implement core support to allow for FreeSync Auto Sweep to work
    
    Signed-off-by: Eric Cook <Eric.Cook@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 6a93c96b9b26..0e69aceb0bad 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1362,6 +1362,18 @@ static void set_drr(struct pipe_ctx **pipe_ctx,
 	}
 }
 
+static void get_position(struct pipe_ctx **pipe_ctx,
+		int num_pipes,
+		struct crtc_position *position)
+{
+	int i = 0;
+
+	/* TODO: handle pipes > 1
+	 */
+	for (i = 0; i < num_pipes; i++)
+		pipe_ctx[i]->tg->funcs->get_position(pipe_ctx[i]->tg, position);
+}
+
 static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
 		int num_pipes, const struct dc_static_screen_events *events)
 {
@@ -2486,6 +2498,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.pipe_control_lock = dce_pipe_control_lock,
 	.set_bandwidth = dce110_set_bandwidth,
 	.set_drr = set_drr,
+	.get_position = get_position,
 	.set_static_screen_control = set_static_screen_control,
 	.reset_hw_ctx_wrap = reset_hw_ctx_wrap,
 	.prog_pixclk_crtc_otg = dce110_prog_pixclk_crtc_otg,

commit 94267b3df7ee00f21fa0ff7d618ca7e0574db5ed
Author: Sylvia Tsai <sylvia.tsai@amd.com>
Date:   Fri Apr 21 15:29:55 2017 -0400

    drm/amd/display: PSR Refactor
    
    - Refacotr PSR to follow correct module pattern
    - fix eDP only working on sink index 0.
    
    Signed-off-by: Sylvia Tsai <sylvia.tsai@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 6b249f5bf1da..6a93c96b9b26 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1005,6 +1005,10 @@ static enum dc_status dce110_prog_pixclk_crtc_otg(
 				pipe_ctx->tg,
 				&stream->public.timing,
 				true);
+
+		pipe_ctx->tg->funcs->set_static_screen_control(
+				pipe_ctx->tg,
+				0x182);
 	}
 
 	if (!pipe_ctx_old->stream) {
@@ -1015,6 +1019,8 @@ static enum dc_status dce110_prog_pixclk_crtc_otg(
 		}
 	}
 
+
+
 	return DC_OK;
 }
 
@@ -1114,6 +1120,8 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 					stream->public.timing.pix_clk_khz,
 					context->stream_count);
 
+	pipe_ctx->stream->sink->link->psr_enabled = false;
+
 	return DC_OK;
 }
 
@@ -1355,9 +1363,17 @@ static void set_drr(struct pipe_ctx **pipe_ctx,
 }
 
 static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
-		int num_pipes, int value)
+		int num_pipes, const struct dc_static_screen_events *events)
 {
 	unsigned int i;
+	unsigned int value = 0;
+
+	if (events->overlay_update)
+		value |= 0x100;
+	if (events->surface_update)
+		value |= 0x80;
+	if (events->cursor_update)
+		value |= 0x2;
 
 	for (i = 0; i < num_pipes; i++)
 		pipe_ctx[i]->tg->funcs->

commit 974db151d48b6793fc2b708d1c3f9ceee735fc5a
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Apr 18 16:51:39 2017 -0400

    drm/amd/display: remove unnecessary allocation for regamma_params inside opp
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 2fbf6ddcf3be..6b249f5bf1da 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -637,7 +637,7 @@ static bool dce110_set_output_transfer_func(
 	struct output_pixel_processor *opp = pipe_ctx->opp;
 
 	opp->funcs->opp_power_on_regamma_lut(opp, true);
-	opp->regamma_params->hw_points_num = GAMMA_HW_POINTS_NUM;
+	opp->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
 
 	if (stream->public.out_transfer_func &&
 		stream->public.out_transfer_func->type ==
@@ -646,8 +646,8 @@ static bool dce110_set_output_transfer_func(
 			TRANSFER_FUNCTION_SRGB) {
 		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_SRGB);
 	} else if (dce110_translate_regamma_to_hw_format(
-				stream->public.out_transfer_func, opp->regamma_params)) {
-			opp->funcs->opp_program_regamma_pwl(opp, opp->regamma_params);
+				stream->public.out_transfer_func, &opp->regamma_params)) {
+			opp->funcs->opp_program_regamma_pwl(opp, &opp->regamma_params);
 			opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_USER);
 	} else {
 		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_BYPASS);

commit 2180e7cca4d5b93b9f150a83d83e27b7fb82a72f
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Apr 17 11:39:19 2017 -0400

    drm/amd/display: update dce8 & 10 bw programming
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 6bf03d680314..2fbf6ddcf3be 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2266,7 +2266,7 @@ static void dce110_set_bandwidth(
 		struct validate_context *context,
 		bool decrease_allowed)
 {
-	dc->hwss.set_displaymarks(dc, context);
+	dce110_set_displaymarks(dc, context);
 
 	if (decrease_allowed || context->dispclk_khz > dc->current_context->dispclk_khz) {
 		context->res_ctx.pool->display_clock->funcs->set_clock(
@@ -2468,7 +2468,6 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.enable_display_power_gating = dce110_enable_display_power_gating,
 	.power_down_front_end = dce110_power_down_fe,
 	.pipe_control_lock = dce_pipe_control_lock,
-	.set_displaymarks = dce110_set_displaymarks,
 	.set_bandwidth = dce110_set_bandwidth,
 	.set_drr = set_drr,
 	.set_static_screen_control = set_static_screen_control,

commit ab3c179893fd44953008d1b1442973ecb1bb5c7e
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Fri Mar 31 15:25:04 2017 -0500

    drm/amd/display: Add support for programming stereo sync
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 1401331080c5..6bf03d680314 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1056,6 +1056,13 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 			stream->sink->link->link_enc,
 			pipe_ctx->stream->signal);
 
+	if (pipe_ctx->stream->signal != SIGNAL_TYPE_VIRTUAL)
+		pipe_ctx->stream_enc->funcs->setup_stereo_sync(
+		pipe_ctx->stream_enc,
+		pipe_ctx->tg->inst,
+		stream->public.timing.timing_3d_format != TIMING_3D_FORMAT_NONE);
+
+
 /*vbios crtc_source_selection and encoder_setup will override fmt_C*/
 	pipe_ctx->opp->funcs->opp_program_fmt(
 			pipe_ctx->opp,

commit 1ce71fcd5dddf4a3198a96e422122edc210847e9
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Tue Apr 11 22:24:44 2017 -0400

    drm/amd/display: use full surface update when stream is NULL
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 7430be502efd..1401331080c5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1599,11 +1599,11 @@ enum dc_status dce110_apply_ctx_to_hw(
 	apply_min_clocks(dc, context, &clocks_state, true);
 
 	if (context->dispclk_khz
-			> dc->current_context->dispclk_khz)
+			> dc->current_context->dispclk_khz) {
 		context->res_ctx.pool->display_clock->funcs->set_clock(
 				context->res_ctx.pool->display_clock,
 				context->dispclk_khz * 115 / 100);
-
+	}
 	/* program audio wall clock. use HDMI as clock source if HDMI
 	 * audio active. Otherwise, use DP as clock source
 	 * first, loop to find any HDMI audio, if not, loop find DP audio

commit 313bf4ff0180107b687dbd10dde8fd021247cd37
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Apr 6 16:21:58 2017 -0400

    drm/amd/display: Add same check as reset pipes for programing backend regs.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 839c34409c63..7430be502efd 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1689,6 +1689,10 @@ enum dc_status dce110_apply_ctx_to_hw(
 		if (pipe_ctx->stream == pipe_ctx_old->stream)
 			continue;
 
+		if (pipe_ctx->stream && pipe_ctx_old->stream
+				&& !pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
+			continue;
+
 		if (pipe_ctx->top_pipe)
 			continue;
 

commit 28f72454320d2084cc082c8509135bdfd4012c10
Author: Jordan Lazare <Jordan.Lazare@amd.com>
Date:   Thu Mar 30 13:08:34 2017 -0400

    drm/amd/display: Fill in vrefresh and min_vblank_time for dce8/dce10
    
    PPLib is now calling into DC to get vrefresh and min_vblank_time, but
    since full bandwidth calcs are missing for those generations, the pplib
    structures were never being filled. This change fills the currently
    required fields to prevent screen corruption.
    
    Signed-off-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 2a3a39e31717..839c34409c63 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2097,7 +2097,7 @@ static void init_hw(struct core_dc *dc)
 	}
 }
 
-static void fill_display_configs(
+void dce110_fill_display_configs(
 	const struct validate_context *context,
 	struct dm_pp_display_configuration *pp_display_cfg)
 {
@@ -2146,7 +2146,7 @@ static void fill_display_configs(
 	pp_display_cfg->display_count = num_cfgs;
 }
 
-static uint32_t get_min_vblank_time_us(const struct validate_context *context)
+uint32_t dce110_get_min_vblank_time_us(const struct validate_context *context)
 {
 	uint8_t j;
 	uint32_t min_vertical_blank_time = -1;
@@ -2224,13 +2224,13 @@ static void pplib_apply_display_requirements(
 			= context->bw_results.required_sclk_deep_sleep;
 
 	pp_display_cfg->avail_mclk_switch_time_us =
-						get_min_vblank_time_us(context);
+						dce110_get_min_vblank_time_us(context);
 	/* TODO: dce11.2*/
 	pp_display_cfg->avail_mclk_switch_time_in_disp_active_us = 0;
 
 	pp_display_cfg->disp_clk_khz = context->dispclk_khz;
 
-	fill_display_configs(context, pp_display_cfg);
+	dce110_fill_display_configs(context, pp_display_cfg);
 
 	/* TODO: is this still applicable?*/
 	if (pp_display_cfg->display_count == 1) {

commit 18f7a1e4083a5be0ce02df736d3f9a82246dd89b
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Mar 23 10:34:06 2017 -0400

    drm/amd/display: Power on front end during set mode.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e5e52c705954..2a3a39e31717 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1722,6 +1722,9 @@ enum dc_status dce110_apply_ctx_to_hw(
 				context,
 				dc);
 
+		if (dc->hwss.power_on_front_end)
+			dc->hwss.power_on_front_end(dc, pipe_ctx, context);
+
 		if (DC_OK != status)
 			return status;
 	}

commit 745cc746da42a3a8a48fb7a6b8c4ee2c3f2cdf8b
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Mar 14 12:30:29 2017 -0400

    drm/amd/display: remove dc_pre_update_surfaces_to_stream from dc use
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index cb7a673e15e9..e5e52c705954 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2094,50 +2094,6 @@ static void init_hw(struct core_dc *dc)
 	}
 }
 
-static void dce110_power_on_pipe_if_needed(
-		struct core_dc *dc,
-		struct pipe_ctx *pipe_ctx,
-		struct validate_context *context)
-{
-	struct pipe_ctx *old_pipe_ctx = &dc->current_context->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
-	struct dc_bios *dcb = dc->ctx->dc_bios;
-	struct tg_color black_color = {0};
-
-	if (!old_pipe_ctx->stream && pipe_ctx->stream) {
-		dc->hwss.enable_display_power_gating(
-				dc,
-				pipe_ctx->pipe_idx,
-				dcb, PIPE_GATING_CONTROL_DISABLE);
-
-		/*
-		 * This is for powering on underlay, so crtc does not
-		 * need to be enabled
-		 */
-
-		pipe_ctx->tg->funcs->program_timing(pipe_ctx->tg,
-				&pipe_ctx->stream->public.timing,
-				false);
-
-		pipe_ctx->tg->funcs->enable_advanced_request(
-				pipe_ctx->tg,
-				true,
-				&pipe_ctx->stream->public.timing);
-
-		pipe_ctx->mi->funcs->allocate_mem_input(pipe_ctx->mi,
-				pipe_ctx->stream->public.timing.h_total,
-				pipe_ctx->stream->public.timing.v_total,
-				pipe_ctx->stream->public.timing.pix_clk_khz,
-				context->stream_count);
-
-		/* TODO unhardcode*/
-		color_space_to_black_color(dc,
-				COLOR_SPACE_YCBCR601, &black_color);
-		pipe_ctx->tg->funcs->set_blank_color(
-				pipe_ctx->tg,
-				&black_color);
-	}
-}
-
 static void fill_display_configs(
 	const struct validate_context *context,
 	struct dm_pp_display_configuration *pp_display_cfg)
@@ -2481,7 +2437,6 @@ static void dce110_power_down_fe(struct core_dc *dc, struct pipe_ctx *pipe)
 static const struct hw_sequencer_funcs dce110_funcs = {
 	.init_hw = init_hw,
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
-	.prepare_pipe_for_context = dce110_power_on_pipe_if_needed,
 	.apply_ctx_for_surface = dce110_apply_ctx_for_surface,
 	.set_plane_config = set_plane_config,
 	.update_plane_addr = update_plane_addr,

commit 8fa9ca2ec6919656db87391a1633692ee8d57c22
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Jun 15 16:21:43 2017 -0400

    drm/amd/display: Remove DCE12 guards
    
    Signed-off-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 66d5f346f195..cb7a673e15e9 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1427,8 +1427,6 @@ static void apply_min_clocks(
 			return;
 		}
 
-		/* TODOFPGA */
-#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
 		/* TODO: This is incorrect. Figure out how to fix. */
 		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
 				pipe_ctx->dis_clk,
@@ -1451,7 +1449,6 @@ static void apply_min_clocks(
 				pre_mode_set,
 				false);
 		return;
-#endif
 	}
 
 	/* get the required state based on state dependent clocks:
@@ -1468,7 +1465,6 @@ static void apply_min_clocks(
 		pipe_ctx->dis_clk->funcs->set_min_clocks_state(
 			pipe_ctx->dis_clk, *clocks_state);
 	} else {
-#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
 		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
 				pipe_ctx->dis_clk,
 				DM_PP_CLOCK_TYPE_DISPLAY_CLK,
@@ -1489,7 +1485,6 @@ static void apply_min_clocks(
 				req_clocks.pixel_clk_khz,
 				pre_mode_set,
 				false);
-#endif
 	}
 }
 

commit 2c8ad2d5a20c8b7425b547dd4a969ffecad29b39
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Jun 15 16:20:24 2017 -0400

    drm/amd/display: Enable DCE12 support
    
    This wires DCE12 support into DC and enables it.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 041830e05b67..66d5f346f195 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1396,9 +1396,12 @@ static uint32_t get_max_pixel_clock_for_all_paths(
 	return max_pix_clk;
 }
 
-/*
- * Find clock state based on clock requested. if clock value is 0, simply
+/* Find clock state based on clock requested. if clock value is 0, simply
  * set clock state as requested without finding clock state by clock value
+ *TODO: when dce120_hw_sequencer.c is created, override apply_min_clock.
+ *
+ * TODOFPGA  remove TODO after implement dal_display_clock_get_cur_clocks_value
+ * etc support for dcn1.0
  */
 static void apply_min_clocks(
 	struct core_dc *dc,
@@ -1425,6 +1428,30 @@ static void apply_min_clocks(
 		}
 
 		/* TODOFPGA */
+#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
+		/* TODO: This is incorrect. Figure out how to fix. */
+		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
+				pipe_ctx->dis_clk,
+				DM_PP_CLOCK_TYPE_DISPLAY_CLK,
+				pipe_ctx->dis_clk->cur_clocks_value.dispclk_in_khz,
+				pre_mode_set,
+				false);
+
+		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
+				pipe_ctx->dis_clk,
+				DM_PP_CLOCK_TYPE_PIXELCLK,
+				pipe_ctx->dis_clk->cur_clocks_value.max_pixelclk_in_khz,
+				pre_mode_set,
+				false);
+
+		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
+				pipe_ctx->dis_clk,
+				DM_PP_CLOCK_TYPE_DISPLAYPHYCLK,
+				pipe_ctx->dis_clk->cur_clocks_value.max_non_dp_phyclk_in_khz,
+				pre_mode_set,
+				false);
+		return;
+#endif
 	}
 
 	/* get the required state based on state dependent clocks:
@@ -1441,6 +1468,28 @@ static void apply_min_clocks(
 		pipe_ctx->dis_clk->funcs->set_min_clocks_state(
 			pipe_ctx->dis_clk, *clocks_state);
 	} else {
+#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
+		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
+				pipe_ctx->dis_clk,
+				DM_PP_CLOCK_TYPE_DISPLAY_CLK,
+				req_clocks.display_clk_khz,
+				pre_mode_set,
+				false);
+
+		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
+				pipe_ctx->dis_clk,
+				DM_PP_CLOCK_TYPE_PIXELCLK,
+				req_clocks.pixel_clk_khz,
+				pre_mode_set,
+				false);
+
+		pipe_ctx->dis_clk->funcs->apply_clock_voltage_request(
+				pipe_ctx->dis_clk,
+				DM_PP_CLOCK_TYPE_DISPLAYPHYCLK,
+				req_clocks.pixel_clk_khz,
+				pre_mode_set,
+				false);
+#endif
 	}
 }
 

commit b2d0a103e6a0a823b46dd2d7f8c2de82c419e286
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Mar 1 18:27:17 2017 -0500

    drm/amd/display: add init calculation to scaler params
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index d9dcb37a4f65..041830e05b67 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -927,6 +927,7 @@ static void get_surface_visual_confirm_color(const struct pipe_ctx *pipe_ctx,
 		color->color_b_cb = color_value;
 		break;
 	case PIXEL_FORMAT_420BPP12:
+	case PIXEL_FORMAT_420BPP15:
 		/* set boarder color to green */
 		color->color_g_y = color_value;
 		break;

commit cf43759306002e29f025344504dc680a9a0b3ac8
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Feb 22 17:52:22 2017 -0500

    drm/amd/display: bandwidth update fix
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 2d2daa694a30..d9dcb37a4f65 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1209,93 +1209,6 @@ static uint32_t compute_pstate_blackout_duration(
 	return total_dest_line_time_ns;
 }
 
-/* get the index of the pipe_ctx if there were no gaps in the pipe_ctx array*/
-int get_bw_result_idx(
-		struct resource_context *res_ctx,
-		int pipe_idx)
-{
-	int i, collapsed_idx;
-
-	if (res_ctx->pipe_ctx[pipe_idx].top_pipe)
-		return 3;
-
-	collapsed_idx = 0;
-	for (i = 0; i < pipe_idx; i++) {
-		if (res_ctx->pipe_ctx[i].stream)
-			collapsed_idx++;
-	}
-
-	return collapsed_idx;
-}
-
-static bool is_watermark_set_a_greater(
-		const struct bw_watermarks *set_a,
-		const struct bw_watermarks *set_b)
-{
-	if (set_a->a_mark > set_b->a_mark
-			|| set_a->b_mark > set_b->b_mark
-			|| set_a->c_mark > set_b->c_mark
-			|| set_a->d_mark > set_b->d_mark)
-		return true;
-	return false;
-}
-
-static bool did_watermarks_increase(
-		struct pipe_ctx *pipe_ctx,
-		struct validate_context *context,
-		struct validate_context *old_context)
-{
-	int collapsed_pipe_idx = get_bw_result_idx(&context->res_ctx,
-			pipe_ctx->pipe_idx);
-	int old_collapsed_pipe_idx = get_bw_result_idx(&old_context->res_ctx,
-			pipe_ctx->pipe_idx);
-	struct pipe_ctx *old_pipe_ctx =  &old_context->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
-
-	if (!old_pipe_ctx->stream)
-		return true;
-
-	if (is_watermark_set_a_greater(
-			&context->bw_results.nbp_state_change_wm_ns[collapsed_pipe_idx],
-			&old_context->bw_results.nbp_state_change_wm_ns[old_collapsed_pipe_idx]))
-		return true;
-	if (is_watermark_set_a_greater(
-			&context->bw_results.stutter_exit_wm_ns[collapsed_pipe_idx],
-			&old_context->bw_results.stutter_exit_wm_ns[old_collapsed_pipe_idx]))
-		return true;
-	if (is_watermark_set_a_greater(
-			&context->bw_results.urgent_wm_ns[collapsed_pipe_idx],
-			&old_context->bw_results.urgent_wm_ns[old_collapsed_pipe_idx]))
-		return true;
-
-	return false;
-}
-
-static void program_wm_for_pipe(struct core_dc *dc,
-		struct pipe_ctx *pipe_ctx,
-		struct validate_context *context)
-{
-	int total_dest_line_time_ns = compute_pstate_blackout_duration(
-			dc->bw_vbios.blackout_duration,
-			pipe_ctx->stream);
-	int bw_result_idx = get_bw_result_idx(&context->res_ctx,
-				pipe_ctx->pipe_idx);
-
-	pipe_ctx->mi->funcs->mem_input_program_display_marks(
-		pipe_ctx->mi,
-		context->bw_results.nbp_state_change_wm_ns[bw_result_idx],
-		context->bw_results.stutter_exit_wm_ns[bw_result_idx],
-		context->bw_results.urgent_wm_ns[bw_result_idx],
-		total_dest_line_time_ns);
-
-	if (pipe_ctx->top_pipe)
-		pipe_ctx->mi->funcs->mem_input_program_chroma_display_marks(
-				pipe_ctx->mi,
-				context->bw_results.nbp_state_change_wm_ns[bw_result_idx + 1],
-				context->bw_results.stutter_exit_wm_ns[bw_result_idx + 1],
-				context->bw_results.urgent_wm_ns[bw_result_idx + 1],
-				total_dest_line_time_ns);
-}
-
 void dce110_set_displaymarks(
 	const struct core_dc *dc,
 	struct validate_context *context)
@@ -1589,7 +1502,7 @@ static void reset_hw_ctx_wrap(
 	}
 }
 
-/*TODO: const validate_context*/
+
 enum dc_status dce110_apply_ctx_to_hw(
 		struct core_dc *dc,
 		struct validate_context *context)
@@ -1768,7 +1681,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 			return status;
 	}
 
-	dc->hwss.set_displaymarks(dc, context);
+	dc->hwss.set_bandwidth(dc, context, true);
 
 	/* to save power */
 	apply_min_clocks(dc, context, &clocks_state, false);
@@ -1777,6 +1690,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 
 	switch_dp_clock_sources(dc, &context->res_ctx);
 
+
 	return DC_OK;
 }
 
@@ -2135,7 +2049,6 @@ static void init_hw(struct core_dc *dc)
 	}
 }
 
-/* TODO: move this to apply_ctx_tohw some how?*/
 static void dce110_power_on_pipe_if_needed(
 		struct core_dc *dc,
 		struct pipe_ctx *pipe_ctx,
@@ -2180,31 +2093,175 @@ static void dce110_power_on_pipe_if_needed(
 	}
 }
 
-static void dce110_increase_watermarks_for_pipe(
-		struct core_dc *dc,
-		struct pipe_ctx *pipe_ctx,
-		struct validate_context *context)
+static void fill_display_configs(
+	const struct validate_context *context,
+	struct dm_pp_display_configuration *pp_display_cfg)
+{
+	int j;
+	int num_cfgs = 0;
+
+	for (j = 0; j < context->stream_count; j++) {
+		int k;
+
+		const struct core_stream *stream = context->streams[j];
+		struct dm_pp_single_disp_config *cfg =
+			&pp_display_cfg->disp_configs[num_cfgs];
+		const struct pipe_ctx *pipe_ctx = NULL;
+
+		for (k = 0; k < MAX_PIPES; k++)
+			if (stream == context->res_ctx.pipe_ctx[k].stream) {
+				pipe_ctx = &context->res_ctx.pipe_ctx[k];
+				break;
+			}
+
+		ASSERT(pipe_ctx != NULL);
+
+		num_cfgs++;
+		cfg->signal = pipe_ctx->stream->signal;
+		cfg->pipe_idx = pipe_ctx->pipe_idx;
+		cfg->src_height = stream->public.src.height;
+		cfg->src_width = stream->public.src.width;
+		cfg->ddi_channel_mapping =
+			stream->sink->link->ddi_channel_mapping.raw;
+		cfg->transmitter =
+			stream->sink->link->link_enc->transmitter;
+		cfg->link_settings.lane_count =
+			stream->sink->link->public.cur_link_settings.lane_count;
+		cfg->link_settings.link_rate =
+			stream->sink->link->public.cur_link_settings.link_rate;
+		cfg->link_settings.link_spread =
+			stream->sink->link->public.cur_link_settings.link_spread;
+		cfg->sym_clock = stream->phy_pix_clk;
+		/* Round v_refresh*/
+		cfg->v_refresh = stream->public.timing.pix_clk_khz * 1000;
+		cfg->v_refresh /= stream->public.timing.h_total;
+		cfg->v_refresh = (cfg->v_refresh + stream->public.timing.v_total / 2)
+							/ stream->public.timing.v_total;
+	}
+
+	pp_display_cfg->display_count = num_cfgs;
+}
+
+static uint32_t get_min_vblank_time_us(const struct validate_context *context)
 {
-	if (did_watermarks_increase(pipe_ctx, context, dc->current_context))
-		program_wm_for_pipe(dc, pipe_ctx, context);
+	uint8_t j;
+	uint32_t min_vertical_blank_time = -1;
+
+		for (j = 0; j < context->stream_count; j++) {
+			const struct dc_stream *stream = &context->streams[j]->public;
+			uint32_t vertical_blank_in_pixels = 0;
+			uint32_t vertical_blank_time = 0;
+
+			vertical_blank_in_pixels = stream->timing.h_total *
+				(stream->timing.v_total
+					- stream->timing.v_addressable);
+
+			vertical_blank_time = vertical_blank_in_pixels
+				* 1000 / stream->timing.pix_clk_khz;
+
+			if (min_vertical_blank_time > vertical_blank_time)
+				min_vertical_blank_time = vertical_blank_time;
+		}
+
+	return min_vertical_blank_time;
 }
 
-static void dce110_set_bandwidth(struct core_dc *dc)
+static int determine_sclk_from_bounding_box(
+		const struct core_dc *dc,
+		int required_sclk)
 {
 	int i;
 
-	for (i = 0; i < dc->current_context->res_ctx.pool->pipe_count; i++) {
-		struct pipe_ctx *pipe_ctx = &dc->current_context->res_ctx.pipe_ctx[i];
+	/*
+	 * Some asics do not give us sclk levels, so we just report the actual
+	 * required sclk
+	 */
+	if (dc->sclk_lvls.num_levels == 0)
+		return required_sclk;
 
-		if (!pipe_ctx->stream)
-			continue;
+	for (i = 0; i < dc->sclk_lvls.num_levels; i++) {
+		if (dc->sclk_lvls.clocks_in_khz[i] >= required_sclk)
+			return dc->sclk_lvls.clocks_in_khz[i];
+	}
+	/*
+	 * even maximum level could not satisfy requirement, this
+	 * is unexpected at this stage, should have been caught at
+	 * validation time
+	 */
+	ASSERT(0);
+	return dc->sclk_lvls.clocks_in_khz[dc->sclk_lvls.num_levels - 1];
+}
+
+static void pplib_apply_display_requirements(
+	struct core_dc *dc,
+	struct validate_context *context)
+{
+	struct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;
+
+	pp_display_cfg->all_displays_in_sync =
+		context->bw_results.all_displays_in_sync;
+	pp_display_cfg->nb_pstate_switch_disable =
+			context->bw_results.nbp_state_change_enable == false;
+	pp_display_cfg->cpu_cc6_disable =
+			context->bw_results.cpuc_state_change_enable == false;
+	pp_display_cfg->cpu_pstate_disable =
+			context->bw_results.cpup_state_change_enable == false;
+	pp_display_cfg->cpu_pstate_separation_time =
+			context->bw_results.blackout_recovery_time_us;
+
+	pp_display_cfg->min_memory_clock_khz = context->bw_results.required_yclk
+		/ MEMORY_TYPE_MULTIPLIER;
+
+	pp_display_cfg->min_engine_clock_khz = determine_sclk_from_bounding_box(
+			dc,
+			context->bw_results.required_sclk);
+
+	pp_display_cfg->min_engine_clock_deep_sleep_khz
+			= context->bw_results.required_sclk_deep_sleep;
+
+	pp_display_cfg->avail_mclk_switch_time_us =
+						get_min_vblank_time_us(context);
+	/* TODO: dce11.2*/
+	pp_display_cfg->avail_mclk_switch_time_in_disp_active_us = 0;
 
-		program_wm_for_pipe(dc, pipe_ctx, dc->current_context);
+	pp_display_cfg->disp_clk_khz = context->dispclk_khz;
+
+	fill_display_configs(context, pp_display_cfg);
+
+	/* TODO: is this still applicable?*/
+	if (pp_display_cfg->display_count == 1) {
+		const struct dc_crtc_timing *timing =
+			&context->streams[0]->public.timing;
+
+		pp_display_cfg->crtc_index =
+			pp_display_cfg->disp_configs[0].pipe_idx;
+		pp_display_cfg->line_time_in_us = timing->h_total * 1000
+							/ timing->pix_clk_khz;
+	}
+
+	if (memcmp(&dc->prev_display_config, pp_display_cfg, sizeof(
+			struct dm_pp_display_configuration)) !=  0)
+		dm_pp_apply_display_requirements(dc->ctx, pp_display_cfg);
+
+	dc->prev_display_config = *pp_display_cfg;
+}
+
+static void dce110_set_bandwidth(
+		struct core_dc *dc,
+		struct validate_context *context,
+		bool decrease_allowed)
+{
+	dc->hwss.set_displaymarks(dc, context);
+
+	if (decrease_allowed || context->dispclk_khz > dc->current_context->dispclk_khz) {
+		context->res_ctx.pool->display_clock->funcs->set_clock(
+				context->res_ctx.pool->display_clock,
+				context->dispclk_khz * 115 / 100);
+		dc->current_context->bw_results.dispclk_khz = context->dispclk_khz;
+		dc->current_context->dispclk_khz = context->dispclk_khz;
 	}
 
-	dc->current_context->res_ctx.pool->display_clock->funcs->set_clock(
-			dc->current_context->res_ctx.pool->display_clock,
-			dc->current_context->dispclk_khz * 115 / 100);
+	pplib_apply_display_requirements(dc, context);
 }
 
 static void dce110_program_front_end_for_pipe(
@@ -2335,15 +2392,6 @@ static void dce110_program_front_end_for_pipe(
 			pipe_ctx->scl_data.recout.y);
 }
 
-static void dce110_prepare_pipe_for_context(
-		struct core_dc *dc,
-		struct pipe_ctx *pipe_ctx,
-		struct validate_context *context)
-{
-	dce110_power_on_pipe_if_needed(dc, pipe_ctx, context);
-	dc->hwss.increase_watermarks_for_pipe(dc, pipe_ctx, context);
-}
-
 static void dce110_apply_ctx_for_surface(
 		struct core_dc *dc,
 		struct core_surface *surface,
@@ -2388,7 +2436,7 @@ static void dce110_power_down_fe(struct core_dc *dc, struct pipe_ctx *pipe)
 static const struct hw_sequencer_funcs dce110_funcs = {
 	.init_hw = init_hw,
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
-	.prepare_pipe_for_context = dce110_prepare_pipe_for_context,
+	.prepare_pipe_for_context = dce110_power_on_pipe_if_needed,
 	.apply_ctx_for_surface = dce110_apply_ctx_for_surface,
 	.set_plane_config = set_plane_config,
 	.update_plane_addr = update_plane_addr,
@@ -2407,7 +2455,6 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.power_down_front_end = dce110_power_down_fe,
 	.pipe_control_lock = dce_pipe_control_lock,
 	.set_displaymarks = dce110_set_displaymarks,
-	.increase_watermarks_for_pipe = dce110_increase_watermarks_for_pipe,
 	.set_bandwidth = dce110_set_bandwidth,
 	.set_drr = set_drr,
 	.set_static_screen_control = set_static_screen_control,

commit 5936223f7b51e122beb511265e2112777f7a887e
Author: Jordan Lazare <Jordan.Lazare@amd.com>
Date:   Thu Feb 23 14:07:29 2017 -0500

    drm/amd/display: Fix gamma colour corruption for 10 bit surfaces
    
    Gamma LUT shouldn't be used for 10-bit and above. Should instead be
    using prescale and bypassing input gamma.
    
    Signed-off-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 2f68bf20dfe2..2d2daa694a30 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -233,6 +233,19 @@ static void build_prescale_params(struct ipp_prescale_params *prescale_params,
 	}
 }
 
+
+/* Only use LUT for 8 bit formats */
+static bool use_lut(const struct core_surface *surface)
+{
+	switch (surface->public.format) {
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
+		return true;
+	default:
+		return false;
+	}
+}
+
 static bool dce110_set_input_transfer_func(
 	struct pipe_ctx *pipe_ctx,
 	const struct core_surface *surface)
@@ -251,7 +264,7 @@ static bool dce110_set_input_transfer_func(
 	build_prescale_params(&prescale_params, surface);
 	ipp->funcs->ipp_program_prescale(ipp, &prescale_params);
 
-	if (surface->public.gamma_correction)
+	if (surface->public.gamma_correction && use_lut(surface))
 	    ipp->funcs->ipp_program_input_lut(ipp, surface->public.gamma_correction);
 
 	if (tf == NULL) {

commit 4b679bc3cab09f2af44bd34dfc197939a4602aa8
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Feb 22 13:46:29 2017 -0500

    drm/amd/display: HDMI deep color mode audio issue
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 6915cc46754b..2f68bf20dfe2 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -873,25 +873,7 @@ static void build_audio_output(
 					audio_output->crtc_info.requested_pixel_clock/2;
 			audio_output->crtc_info.calculated_pixel_clock =
 					pipe_ctx->pix_clk_params.requested_pix_clk/2;
-		}
 
-		if (pipe_ctx->pix_clk_params.pixel_encoding != PIXEL_ENCODING_YCBCR422) {
-			switch (pipe_ctx->pix_clk_params.color_depth) {
-			case COLOR_DEPTH_888:
-				break;
-			case COLOR_DEPTH_101010:
-				audio_output->crtc_info.calculated_pixel_clock = (audio_output->crtc_info.calculated_pixel_clock * 30) / 24;
-			break;
-			case COLOR_DEPTH_121212:
-				audio_output->crtc_info.calculated_pixel_clock = (audio_output->crtc_info.calculated_pixel_clock * 36) / 24;
-			break;
-			case COLOR_DEPTH_161616:
-				audio_output->crtc_info.calculated_pixel_clock = (audio_output->crtc_info.calculated_pixel_clock * 48) / 24;
-			break;
-			default:
-				ASSERT(0);
-			break;
-			}
 		}
 	}
 

commit 181a888fcd723c4bc63f43aac50713c34ae9102e
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Fri Feb 17 13:59:11 2017 -0500

    drm/amd/display: fix incorrect programming for YCbCr422 and YCbCr420
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 76a397d90adc..6915cc46754b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -861,10 +861,6 @@ static void build_audio_output(
 	audio_output->crtc_info.requested_pixel_clock =
 			pipe_ctx->pix_clk_params.requested_pix_clk;
 
-	/*
-	 * TODO - Investigate why calculated pixel clk has to be
-	 * requested pixel clk
-	 */
 	audio_output->crtc_info.calculated_pixel_clock =
 			pipe_ctx->pix_clk_params.requested_pix_clk;
 
@@ -1044,15 +1040,14 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 			stream->public.timing.display_color_depth,
 			pipe_ctx->stream->signal);
 
+	/* FPGA does not program backend */
+	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
 	pipe_ctx->opp->funcs->opp_program_fmt(
 			pipe_ctx->opp,
 			&stream->bit_depth_params,
 			&stream->clamping);
-
-	/* FPGA does not program backend */
-	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
 		return DC_OK;
-
+	}
 	/* TODO: move to stream encoder */
 	if (pipe_ctx->stream->signal != SIGNAL_TYPE_VIRTUAL)
 		if (DC_OK != bios_parser_crtc_source_select(pipe_ctx)) {
@@ -1065,6 +1060,12 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 			stream->sink->link->link_enc,
 			pipe_ctx->stream->signal);
 
+/*vbios crtc_source_selection and encoder_setup will override fmt_C*/
+	pipe_ctx->opp->funcs->opp_program_fmt(
+			pipe_ctx->opp,
+			&stream->bit_depth_params,
+			&stream->clamping);
+
 	if (dc_is_dp_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_enc->funcs->dp_set_stream_attribute(
 			pipe_ctx->stream_enc,

commit 87b58768eccd311fdc7694c09966754d5ce90538
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Thu Feb 16 22:28:46 2017 -0500

    drm/amd/display: audio bug fix part 1: Add missing audio ACR
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 9c9183f96e04..76a397d90adc 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -868,6 +868,37 @@ static void build_audio_output(
 	audio_output->crtc_info.calculated_pixel_clock =
 			pipe_ctx->pix_clk_params.requested_pix_clk;
 
+/*for HDMI, audio ACR is with deep color ratio factor*/
+	if (dc_is_hdmi_signal(pipe_ctx->stream->signal) &&
+		audio_output->crtc_info.requested_pixel_clock ==
+				stream->public.timing.pix_clk_khz) {
+		if (pipe_ctx->pix_clk_params.pixel_encoding == PIXEL_ENCODING_YCBCR420) {
+			audio_output->crtc_info.requested_pixel_clock =
+					audio_output->crtc_info.requested_pixel_clock/2;
+			audio_output->crtc_info.calculated_pixel_clock =
+					pipe_ctx->pix_clk_params.requested_pix_clk/2;
+		}
+
+		if (pipe_ctx->pix_clk_params.pixel_encoding != PIXEL_ENCODING_YCBCR422) {
+			switch (pipe_ctx->pix_clk_params.color_depth) {
+			case COLOR_DEPTH_888:
+				break;
+			case COLOR_DEPTH_101010:
+				audio_output->crtc_info.calculated_pixel_clock = (audio_output->crtc_info.calculated_pixel_clock * 30) / 24;
+			break;
+			case COLOR_DEPTH_121212:
+				audio_output->crtc_info.calculated_pixel_clock = (audio_output->crtc_info.calculated_pixel_clock * 36) / 24;
+			break;
+			case COLOR_DEPTH_161616:
+				audio_output->crtc_info.calculated_pixel_clock = (audio_output->crtc_info.calculated_pixel_clock * 48) / 24;
+			break;
+			default:
+				ASSERT(0);
+			break;
+			}
+		}
+	}
+
 	if (pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT ||
 			pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {
 		audio_output->pll_info.dp_dto_source_clock_in_khz =

commit 70063a5957126087f167ff3890784d7b3b36c844
Author: Amy Zhang <Amy.Zhang@amd.com>
Date:   Thu Feb 16 11:04:48 2017 -0500

    drm/amd/display: Add bypass case for PQ transfer function
    
    - Source and destination color space should be the same for
      app control case
    - Bypass degamma, regamma, and gamut remap
    - Add hdr supported check for info frame
    
    Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 9b6d251a1c22..9c9183f96e04 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -279,6 +279,8 @@ static bool dce110_set_input_transfer_func(
 			result = false;
 			break;
 		}
+	} else if (tf->public.type == TF_TYPE_BYPASS) {
+		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
 	} else {
 		/*TF_TYPE_DISTRIBUTED_POINTS - Not supported in DCE 11*/
 		result = false;
@@ -428,7 +430,8 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 	int32_t segment_start, segment_end;
 	uint32_t i, j, k, seg_distr[16], increment, start_index, hw_points;
 
-	if (output_tf == NULL || regamma_params == NULL)
+	if (output_tf == NULL || regamma_params == NULL ||
+			output_tf->type == TF_TYPE_BYPASS)
 		return false;
 
 	arr_points = regamma_params->arr_points;

commit e166ad43d5c1312f258ef4adabe1fac2b9da7e18
Author: Julia Lawall <julia.lawall@lip6.fr>
Date:   Tue Feb 14 07:19:36 2017 +0100

    drm/amd/dc: hw_sequencer: fix semicolon.cocci warnings
    
    Remove unneeded semicolon.
    
    Generated by: scripts/coccinelle/misc/semicolon.cocci
    
    Signed-off-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 0afb3c64b651..9b6d251a1c22 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2070,7 +2070,7 @@ static void init_hw(struct core_dc *dc)
 			true);
 	}
 
-	dce_clock_gating_power_up(dc->hwseq, false);;
+	dce_clock_gating_power_up(dc->hwseq, false);
 	/***************************************/
 
 	for (i = 0; i < dc->link_count; i++) {

commit b3c64dff24e829c0b61b340fbaf0efaf20ce5d58
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Fri Feb 10 17:51:27 2017 -0500

    drm/amd/display: color distortion after DPMS+ background color fix
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 88a2fa99f5da..0afb3c64b651 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1054,6 +1054,8 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 	if (!pipe_ctx_old->stream) {
 		core_link_enable_stream(pipe_ctx);
 
+	resource_build_info_frame(pipe_ctx);
+	dce110_update_info_frame(pipe_ctx);
 		if (dc_is_dp_signal(pipe_ctx->stream->signal))
 			dce110_unblank_stream(pipe_ctx,
 				&stream->sink->link->public.cur_link_settings);

commit e266fdf6944749e100b065b5a95c7bb33d2aa2d6
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Tue Feb 7 10:41:37 2017 -0600

    drm/amd/display: Enable regamma 25 segments and use double buffer.
    
    Moved custom floating point calculation to the shared place
    between dce's.
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 6a5cec0d4e1f..88a2fa99f5da 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -49,6 +49,7 @@
 /* include DCE11 register header files */
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_sh_mask.h"
+#include "custom_float.h"
 
 struct dce110_hw_seq_reg_offsets {
 	uint32_t crtc;
@@ -286,174 +287,6 @@ static bool dce110_set_input_transfer_func(
 	return result;
 }
 
-static bool build_custom_float(
-	struct fixed31_32 value,
-	const struct custom_float_format *format,
-	bool *negative,
-	uint32_t *mantissa,
-	uint32_t *exponenta)
-{
-	uint32_t exp_offset = (1 << (format->exponenta_bits - 1)) - 1;
-
-	const struct fixed31_32 mantissa_constant_plus_max_fraction =
-		dal_fixed31_32_from_fraction(
-			(1LL << (format->mantissa_bits + 1)) - 1,
-			1LL << format->mantissa_bits);
-
-	struct fixed31_32 mantiss;
-
-	if (dal_fixed31_32_eq(
-		value,
-		dal_fixed31_32_zero)) {
-		*negative = false;
-		*mantissa = 0;
-		*exponenta = 0;
-		return true;
-	}
-
-	if (dal_fixed31_32_lt(
-		value,
-		dal_fixed31_32_zero)) {
-		*negative = format->sign;
-		value = dal_fixed31_32_neg(value);
-	} else {
-		*negative = false;
-	}
-
-	if (dal_fixed31_32_lt(
-		value,
-		dal_fixed31_32_one)) {
-		uint32_t i = 1;
-
-		do {
-			value = dal_fixed31_32_shl(value, 1);
-			++i;
-		} while (dal_fixed31_32_lt(
-			value,
-			dal_fixed31_32_one));
-
-		--i;
-
-		if (exp_offset <= i) {
-			*mantissa = 0;
-			*exponenta = 0;
-			return true;
-		}
-
-		*exponenta = exp_offset - i;
-	} else if (dal_fixed31_32_le(
-		mantissa_constant_plus_max_fraction,
-		value)) {
-		uint32_t i = 1;
-
-		do {
-			value = dal_fixed31_32_shr(value, 1);
-			++i;
-		} while (dal_fixed31_32_lt(
-			mantissa_constant_plus_max_fraction,
-			value));
-
-		*exponenta = exp_offset + i - 1;
-	} else {
-		*exponenta = exp_offset;
-	}
-
-	mantiss = dal_fixed31_32_sub(
-		value,
-		dal_fixed31_32_one);
-
-	if (dal_fixed31_32_lt(
-			mantiss,
-			dal_fixed31_32_zero) ||
-		dal_fixed31_32_lt(
-			dal_fixed31_32_one,
-			mantiss))
-		mantiss = dal_fixed31_32_zero;
-	else
-		mantiss = dal_fixed31_32_shl(
-			mantiss,
-			format->mantissa_bits);
-
-	*mantissa = dal_fixed31_32_floor(mantiss);
-
-	return true;
-}
-
-static bool setup_custom_float(
-	const struct custom_float_format *format,
-	bool negative,
-	uint32_t mantissa,
-	uint32_t exponenta,
-	uint32_t *result)
-{
-	uint32_t i = 0;
-	uint32_t j = 0;
-
-	uint32_t value = 0;
-
-	/* verification code:
-	 * once calculation is ok we can remove it
-	 */
-
-	const uint32_t mantissa_mask =
-		(1 << (format->mantissa_bits + 1)) - 1;
-
-	const uint32_t exponenta_mask =
-		(1 << (format->exponenta_bits + 1)) - 1;
-
-	if (mantissa & ~mantissa_mask) {
-		BREAK_TO_DEBUGGER();
-		mantissa = mantissa_mask;
-	}
-
-	if (exponenta & ~exponenta_mask) {
-		BREAK_TO_DEBUGGER();
-		exponenta = exponenta_mask;
-	}
-
-	/* end of verification code */
-
-	while (i < format->mantissa_bits) {
-		uint32_t mask = 1 << i;
-
-		if (mantissa & mask)
-			value |= mask;
-
-		++i;
-	}
-
-	while (j < format->exponenta_bits) {
-		uint32_t mask = 1 << j;
-
-		if (exponenta & mask)
-			value |= mask << i;
-
-		++j;
-	}
-
-	if (negative && format->sign)
-		value |= 1 << (i + j);
-
-	*result = value;
-
-	return true;
-}
-
-static bool convert_to_custom_float_format(
-	struct fixed31_32 value,
-	const struct custom_float_format *format,
-	uint32_t *result)
-{
-	uint32_t mantissa;
-	uint32_t exponenta;
-	bool negative;
-
-	return build_custom_float(
-		value, format, &negative, &mantissa, &exponenta) &&
-	setup_custom_float(
-		format, negative, mantissa, exponenta, result);
-}
-
 static bool convert_to_custom_float(
 		struct pwl_result_data *rgb_resulted,
 		struct curve_points *arr_points,
@@ -579,7 +412,7 @@ static bool convert_to_custom_float(
 	return true;
 }
 
-bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
+static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 		*output_tf, struct pwl_params *regamma_params)
 {
 	struct curve_points *arr_points;

commit ab8812a3861efd3d60a4079711f2d1b08b8af50e
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Wed Feb 8 11:28:33 2017 -0500

    drm/amd/display: Audio is not switching to DP when HDMI/DP hot plug/unplug
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 5e99f6c27c9a..6a5cec0d4e1f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1732,7 +1732,6 @@ enum dc_status dce110_apply_ctx_to_hw(
 	struct dc_bios *dcb = dc->ctx->dc_bios;
 	enum dc_status status;
 	int i;
-	bool programmed_audio_dto = false;
 	enum dm_pp_clocks_state clocks_state = DM_PP_CLOCKS_STATE_INVALID;
 
 	/* Reset old context */
@@ -1782,6 +1781,80 @@ enum dc_status dce110_apply_ctx_to_hw(
 				context->res_ctx.pool->display_clock,
 				context->dispclk_khz * 115 / 100);
 
+	/* program audio wall clock. use HDMI as clock source if HDMI
+	 * audio active. Otherwise, use DP as clock source
+	 * first, loop to find any HDMI audio, if not, loop find DP audio
+	 */
+	/* Setup audio rate clock source */
+	/* Issue:
+	* Audio lag happened on DP monitor when unplug a HDMI monitor
+	*
+	* Cause:
+	* In case of DP and HDMI connected or HDMI only, DCCG_AUDIO_DTO_SEL
+	* is set to either dto0 or dto1, audio should work fine.
+	* In case of DP connected only, DCCG_AUDIO_DTO_SEL should be dto1,
+	* set to dto0 will cause audio lag.
+	*
+	* Solution:
+	* Not optimized audio wall dto setup. When mode set, iterate pipe_ctx,
+	* find first available pipe with audio, setup audio wall DTO per topology
+	* instead of per pipe.
+	*/
+	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (pipe_ctx->stream == NULL)
+			continue;
+
+		if (pipe_ctx->top_pipe)
+			continue;
+
+		if (pipe_ctx->stream->signal != SIGNAL_TYPE_HDMI_TYPE_A)
+			continue;
+
+		if (pipe_ctx->audio != NULL) {
+			struct audio_output audio_output;
+
+			build_audio_output(pipe_ctx, &audio_output);
+
+			pipe_ctx->audio->funcs->wall_dto_setup(
+				pipe_ctx->audio,
+				pipe_ctx->stream->signal,
+				&audio_output.crtc_info,
+				&audio_output.pll_info);
+			break;
+		}
+	}
+
+	/* no HDMI audio is found, try DP audio */
+	if (i == context->res_ctx.pool->pipe_count) {
+		for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+			if (pipe_ctx->stream == NULL)
+				continue;
+
+			if (pipe_ctx->top_pipe)
+				continue;
+
+			if (!dc_is_dp_signal(pipe_ctx->stream->signal))
+				continue;
+
+			if (pipe_ctx->audio != NULL) {
+				struct audio_output audio_output;
+
+				build_audio_output(pipe_ctx, &audio_output);
+
+				pipe_ctx->audio->funcs->wall_dto_setup(
+					pipe_ctx->audio,
+					pipe_ctx->stream->signal,
+					&audio_output.crtc_info,
+					&audio_output.pll_info);
+				break;
+			}
+		}
+	}
+
 	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx_old =
 					&dc->current_context->res_ctx.pipe_ctx[i];
@@ -1797,21 +1870,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 			continue;
 
 		if (context->res_ctx.pipe_ctx[i].audio != NULL) {
-			/* Setup audio rate clock source */
-			/* Issue:
-			* Audio lag happened on DP monitor when unplug a HDMI monitor
-			*
-			* Cause:
-			* In case of DP and HDMI connected or HDMI only, DCCG_AUDIO_DTO_SEL
-			* is set to either dto0 or dto1, audio should work fine.
-			* In case of DP connected only, DCCG_AUDIO_DTO_SEL should be dto1,
-			* set to dto0 will cause audio lag.
-			*
-			* Solution:
-			* Not optimized audio wall dto setup. When mode set, iterate pipe_ctx,
-			* find first available pipe with audio, setup audio wall DTO per topology
-			* instead of per pipe.
-			*/
+
 			struct audio_output audio_output;
 
 			build_audio_output(pipe_ctx, &audio_output);
@@ -1833,15 +1892,6 @@ enum dc_status dce110_apply_ctx_to_hw(
 					pipe_ctx->stream->signal,
 					&audio_output.crtc_info,
 					&pipe_ctx->stream->public.audio_info);
-
-			if (!programmed_audio_dto) {
-				pipe_ctx->audio->funcs->wall_dto_setup(
-					pipe_ctx->audio,
-					pipe_ctx->stream->signal,
-					&audio_output.crtc_info,
-					&audio_output.pll_info);
-				programmed_audio_dto = true;
-			}
 		}
 
 		status = apply_single_controller_ctx_to_hw(

commit a99240d5f8e14fc081e2cccad6ac46b48cea7def
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Feb 2 17:08:19 2017 -0500

    drm/amd/display: use disp clock value in context rather than bw_results
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index a1a5dc6fcb67..5e99f6c27c9a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1651,7 +1651,7 @@ static void apply_min_clocks(
 	/* get the required state based on state dependent clocks:
 	 * display clock and pixel clock
 	 */
-	req_clocks.display_clk_khz = context->bw_results.dispclk_khz;
+	req_clocks.display_clk_khz = context->dispclk_khz;
 
 	req_clocks.pixel_clk_khz = get_max_pixel_clock_for_all_paths(
 			dc, context, true);
@@ -1776,11 +1776,11 @@ enum dc_status dce110_apply_ctx_to_hw(
 	/*TODO: when pplib works*/
 	apply_min_clocks(dc, context, &clocks_state, true);
 
-	if (context->bw_results.dispclk_khz
-			> dc->current_context->bw_results.dispclk_khz)
+	if (context->dispclk_khz
+			> dc->current_context->dispclk_khz)
 		context->res_ctx.pool->display_clock->funcs->set_clock(
 				context->res_ctx.pool->display_clock,
-				context->bw_results.dispclk_khz * 115 / 100);
+				context->dispclk_khz * 115 / 100);
 
 	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx_old =
@@ -2289,7 +2289,7 @@ static void dce110_set_bandwidth(struct core_dc *dc)
 
 	dc->current_context->res_ctx.pool->display_clock->funcs->set_clock(
 			dc->current_context->res_ctx.pool->display_clock,
-			dc->current_context->bw_results.dispclk_khz * 115 / 100);
+			dc->current_context->dispclk_khz * 115 / 100);
 }
 
 static void dce110_program_front_end_for_pipe(

commit 6728b30c974e38711f70dc38edf68503bf71c4a9
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Jan 24 15:19:42 2017 -0500

    drm/amd/display: Move backlight from encoder to ABM
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index d67f1100c3d9..a1a5dc6fcb67 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -2214,8 +2214,10 @@ static void init_hw(struct core_dc *dc)
 	}
 
 	abm = dc->res_pool->abm;
-	if (abm != NULL)
+	if (abm != NULL) {
+		abm->funcs->init_backlight(abm);
 		abm->funcs->abm_init(abm);
+	}
 }
 
 /* TODO: move this to apply_ctx_tohw some how?*/

commit 5e7773a219f7821163ad2b17be0d02f8be8ce0c6
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Mon Jan 23 16:55:20 2017 -0500

    drm/amd/display: DMCU Compile and Load
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 6acb9faf29f1..d67f1100c3d9 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -42,6 +42,7 @@
 #include "stream_encoder.h"
 #include "link_encoder.h"
 #include "clock_source.h"
+#include "abm.h"
 #include "audio.h"
 #include "dce/dce_hwseq.h"
 
@@ -2166,6 +2167,7 @@ static void init_hw(struct core_dc *dc)
 	int i;
 	struct dc_bios *bp;
 	struct transform *xfm;
+	struct abm *abm;
 
 	bp = dc->ctx->dc_bios;
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
@@ -2210,6 +2212,10 @@ static void init_hw(struct core_dc *dc)
 		struct audio *audio = dc->res_pool->audios[i];
 		audio->funcs->hw_init(audio);
 	}
+
+	abm = dc->res_pool->abm;
+	if (abm != NULL)
+		abm->funcs->abm_init(abm);
 }
 
 /* TODO: move this to apply_ctx_tohw some how?*/

commit 7ec6b963b17a51159c38e2446499a69edf5b20e5
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Jan 25 14:51:39 2017 -0500

    drm/amd/display: Expose hw sequencer gamma function
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index c3e0865f3148..6acb9faf29f1 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -578,7 +578,7 @@ static bool convert_to_custom_float(
 	return true;
 }
 
-static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
+bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 		*output_tf, struct pwl_params *regamma_params)
 {
 	struct curve_points *arr_points;

commit 23ae4f8e59c926df806ba837b2a2040984077641
Author: Amy Zhang <Amy.Zhang@amd.com>
Date:   Tue Jan 24 09:50:05 2017 -0500

    drm/amd/display: Fix Warnings
    
    - Remove mixed declarations and unused variables
    
    Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index ce56f23806bc..c3e0865f3148 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -581,12 +581,10 @@ static bool convert_to_custom_float(
 static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 		*output_tf, struct pwl_params *regamma_params)
 {
-	if (output_tf == NULL || regamma_params == NULL)
-		return false;
-
-	struct gamma_curve *arr_curve_points = regamma_params->arr_curve_points;
-	struct curve_points *arr_points = regamma_params->arr_points;
-	struct pwl_result_data *rgb_resulted = regamma_params->rgb_resulted;
+	struct curve_points *arr_points;
+	struct pwl_result_data *rgb_resulted;
+	struct pwl_result_data *rgb;
+	struct pwl_result_data *rgb_plus_1;
 	struct fixed31_32 y_r;
 	struct fixed31_32 y_g;
 	struct fixed31_32 y_b;
@@ -594,8 +592,14 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 	struct fixed31_32 y3_max;
 
 	int32_t segment_start, segment_end;
-	uint32_t i, j, k, seg_distr[16], increment, start_index;
-	uint32_t hw_points = 0;
+	uint32_t i, j, k, seg_distr[16], increment, start_index, hw_points;
+
+	if (output_tf == NULL || regamma_params == NULL)
+		return false;
+
+	arr_points = regamma_params->arr_points;
+	rgb_resulted = regamma_params->rgb_resulted;
+	hw_points = 0;
 
 	memset(regamma_params, 0, sizeof(struct pwl_params));
 
@@ -742,8 +746,8 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 		regamma_params->arr_curve_points[k].segments_num =
 				seg_distr[k];
 
-	struct pwl_result_data *rgb = rgb_resulted;
-	struct pwl_result_data *rgb_plus_1 = rgb_resulted + 1;
+	rgb = rgb_resulted;
+	rgb_plus_1 = rgb_resulted + 1;
 
 	i = 1;
 

commit 86e2e1bee07134f712cb6b807b7f0205057bd11e
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Fri Jan 20 15:54:13 2017 -0500

    drm/amd/display: Check we got a stream in update_info_frame
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 6dbfc570b8c6..ce56f23806bc 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -837,6 +837,11 @@ static enum dc_status bios_parser_crtc_source_select(
 
 void dce110_update_info_frame(struct pipe_ctx *pipe_ctx)
 {
+	ASSERT(pipe_ctx->stream);
+
+	if (pipe_ctx->stream_enc == NULL)
+		return;  /* this is not root pipe */
+
 	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
 		pipe_ctx->stream_enc->funcs->update_hdmi_info_packets(
 			pipe_ctx->stream_enc,

commit 8693049a896c2c3a2bb74f0efde62318636beaef
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Mon Jan 16 20:50:47 2017 -0500

    drm/amd/display: rename BGRA8888 to ABGR8888
    
    DC actually support ABGR8888 instead of BGRA8888 (R/B swap rather than endian swap) ,
    rename to avoid confusion
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e9fd83e9af79..6dbfc570b8c6 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -214,7 +214,7 @@ static void build_prescale_params(struct ipp_prescale_params *prescale_params,
 
 	switch (surface->public.format) {
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
-	case SURFACE_PIXEL_FORMAT_GRPH_BGRA8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
 		prescale_params->scale = 0x2020;
 		break;
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:

commit 534db198866070fdb655423637afdce6cf0c05db
Author: Amy Zhang <Amy.Zhang@amd.com>
Date:   Fri Jan 13 16:49:26 2017 -0500

    drm/amd/display: HDR Enablement For Applications
    
    - Made sure dest color space is updated in stream and info frame
    - Optimized segment distribution algorithm for regamma mapping
    
    Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index ee393a168c84..e9fd83e9af79 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -594,39 +594,88 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 	struct fixed31_32 y3_max;
 
 	int32_t segment_start, segment_end;
-	uint32_t hw_points, start_index;
-	uint32_t i, j;
+	uint32_t i, j, k, seg_distr[16], increment, start_index;
+	uint32_t hw_points = 0;
 
 	memset(regamma_params, 0, sizeof(struct pwl_params));
 
 	if (output_tf->tf == TRANSFER_FUNCTION_PQ) {
-		/* 16 segments x 16 points
+		/* 16 segments
 		 * segments are from 2^-11 to 2^5
 		 */
 		segment_start = -11;
 		segment_end = 5;
 
+		seg_distr[0] = 2;
+		seg_distr[1] = 2;
+		seg_distr[2] = 2;
+		seg_distr[3] = 2;
+		seg_distr[4] = 2;
+		seg_distr[5] = 2;
+		seg_distr[6] = 3;
+		seg_distr[7] = 4;
+		seg_distr[8] = 4;
+		seg_distr[9] = 4;
+		seg_distr[10] = 4;
+		seg_distr[11] = 5;
+		seg_distr[12] = 5;
+		seg_distr[13] = 5;
+		seg_distr[14] = 5;
+		seg_distr[15] = 5;
+
 	} else {
-		/* 10 segments x 16 points
+		/* 10 segments
 		 * segment is from 2^-10 to 2^0
 		 */
 		segment_start = -10;
 		segment_end = 0;
+
+		seg_distr[0] = 3;
+		seg_distr[1] = 4;
+		seg_distr[2] = 4;
+		seg_distr[3] = 4;
+		seg_distr[4] = 4;
+		seg_distr[5] = 4;
+		seg_distr[6] = 4;
+		seg_distr[7] = 4;
+		seg_distr[8] = 5;
+		seg_distr[9] = 5;
+		seg_distr[10] = -1;
+		seg_distr[11] = -1;
+		seg_distr[12] = -1;
+		seg_distr[13] = -1;
+		seg_distr[14] = -1;
+		seg_distr[15] = -1;
+	}
+
+	for (k = 0; k < 16; k++) {
+		if (seg_distr[k] != -1)
+			hw_points += (1 << seg_distr[k]);
 	}
 
-	hw_points = (segment_end - segment_start) * 16;
 	j = 0;
-	/* (segment + 25) * 32, every 2nd point */
-	start_index = (segment_start + 25) * 32;
-	for (i = start_index; i <= 1025; i += 2) {
-		if (j > hw_points)
-			break;
-		rgb_resulted[j].red = output_tf->tf_pts.red[i];
-		rgb_resulted[j].green = output_tf->tf_pts.green[i];
-		rgb_resulted[j].blue = output_tf->tf_pts.blue[i];
-		j++;
+	for (k = 0; k < (segment_end - segment_start); k++) {
+		increment = 32 / (1 << seg_distr[k]);
+		start_index = (segment_start + k + 25) * 32;
+		for (i = start_index; i < start_index + 32; i += increment) {
+			if (j == hw_points - 1)
+				break;
+			rgb_resulted[j].red = output_tf->tf_pts.red[i];
+			rgb_resulted[j].green = output_tf->tf_pts.green[i];
+			rgb_resulted[j].blue = output_tf->tf_pts.blue[i];
+			j++;
+		}
 	}
 
+	/* last point */
+	start_index = (segment_end + 25) * 32;
+	rgb_resulted[hw_points - 1].red =
+			output_tf->tf_pts.red[start_index];
+	rgb_resulted[hw_points - 1].green =
+			output_tf->tf_pts.green[start_index];
+	rgb_resulted[hw_points - 1].blue =
+			output_tf->tf_pts.blue[start_index];
+
 	arr_points[0].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
 			dal_fixed31_32_from_int(segment_start));
 	arr_points[1].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
@@ -677,11 +726,22 @@ static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
 
 	regamma_params->hw_points_num = hw_points;
 
-	for (i = 0; i < segment_end - segment_start; i++) {
-		regamma_params->arr_curve_points[i].offset = i * 16;
-		regamma_params->arr_curve_points[i].segments_num = 4;
+	i = 1;
+	for (k = 0; k < 16 && i < 16; k++) {
+		if (seg_distr[k] != -1) {
+			regamma_params->arr_curve_points[k].segments_num =
+					seg_distr[k];
+			regamma_params->arr_curve_points[i].offset =
+					regamma_params->arr_curve_points[k].
+					offset + (1 << seg_distr[k]);
+		}
+		i++;
 	}
 
+	if (seg_distr[k] != -1)
+		regamma_params->arr_curve_points[k].segments_num =
+				seg_distr[k];
+
 	struct pwl_result_data *rgb = rgb_resulted;
 	struct pwl_result_data *rgb_plus_1 = rgb_resulted + 1;
 

commit 306dadf01aba27bed2daa49a782b22586af64c93
Author: Amy Zhang <Amy.Zhang@amd.com>
Date:   Fri Jan 13 16:19:36 2017 -0500

    drm/amd/display: Set default degamma to sRGB instead of bypass
    
    Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index b51668e3bb52..ee393a168c84 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -255,7 +255,7 @@ static bool dce110_set_input_transfer_func(
 	if (tf == NULL) {
 		/* Default case if no input transfer function specified */
 		ipp->funcs->ipp_set_degamma(ipp,
-				IPP_DEGAMMA_MODE_BYPASS);
+				IPP_DEGAMMA_MODE_HW_sRGB);
 	} else if (tf->public.type == TF_TYPE_PREDEFINED) {
 		switch (tf->public.tf) {
 		case TRANSFER_FUNCTION_SRGB:

commit 6235b23cb92ba5bf30430400b216ea2114afe777
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Sat Jan 14 18:57:57 2017 -0500

    drm/amd/display: remove hw_crtc_timing
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 1a9ba127b781..b51668e3bb52 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -886,7 +886,7 @@ void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
 	struct encoder_unblank_param params = { { 0 } };
 
 	/* only 3 items below are used by unblank */
-	params.crtc_timing.pixel_clock =
+	params.pixel_clk_khz =
 		pipe_ctx->stream->public.timing.pix_clk_khz;
 	params.link_settings.link_rate = link_settings->link_rate;
 	pipe_ctx->stream_enc->funcs->dp_unblank(pipe_ctx->stream_enc, &params);

commit cc0cb445ae56890a322abe2cc8df63b1ccab74fb
Author: Leon Elazar <leon.elazar@amd.com>
Date:   Wed Jan 11 14:33:36 2017 -0500

    drm/amd/display: Fixing some fallout from dc_target removal
    
    Also avoid allocating memory dce110_set_output_transfer_func
    if not needed
    
    Signed-off-by: Leon Elazar <leon.elazar@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 6e70cf7b99ef..1a9ba127b781 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -721,43 +721,27 @@ static bool dce110_set_output_transfer_func(
 	const struct core_stream *stream)
 {
 	struct output_pixel_processor *opp = pipe_ctx->opp;
-	const struct core_gamma *ramp = NULL;
-	struct pwl_params *regamma_params;
-	bool result = false;
-
-	if (surface->public.gamma_correction)
-		ramp = DC_GAMMA_TO_CORE(surface->public.gamma_correction);
-
-	regamma_params = dm_alloc(sizeof(struct pwl_params));
-	if (regamma_params == NULL)
-		goto regamma_alloc_fail;
-
-	regamma_params->hw_points_num = GAMMA_HW_POINTS_NUM;
 
 	opp->funcs->opp_power_on_regamma_lut(opp, true);
+	opp->regamma_params->hw_points_num = GAMMA_HW_POINTS_NUM;
 
 	if (stream->public.out_transfer_func &&
-			stream->public.out_transfer_func->type ==
+		stream->public.out_transfer_func->type ==
 			TF_TYPE_PREDEFINED &&
-			stream->public.out_transfer_func->tf ==
+		stream->public.out_transfer_func->tf ==
 			TRANSFER_FUNCTION_SRGB) {
 		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_SRGB);
 	} else if (dce110_translate_regamma_to_hw_format(
-			stream->public.out_transfer_func, regamma_params)) {
-		opp->funcs->opp_program_regamma_pwl(opp, regamma_params);
-		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_USER);
+				stream->public.out_transfer_func, opp->regamma_params)) {
+			opp->funcs->opp_program_regamma_pwl(opp, opp->regamma_params);
+			opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_USER);
 	} else {
 		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_BYPASS);
 	}
 
 	opp->funcs->opp_power_on_regamma_lut(opp, false);
 
-	result = true;
-
-	dm_free(regamma_params);
-
-regamma_alloc_fail:
-	return result;
+	return true;
 }
 
 static enum dc_status bios_parser_crtc_source_select(

commit fcd2f4bf8bbe73ac860d1be275a22a54a8d8d385
Author: Amy Zhang <Amy.Zhang@amd.com>
Date:   Thu Jan 5 17:12:20 2017 -0500

    drm/amd/display: Output Transfer Function Regamma Refactor
    
    - Create translation function to translate logical format to hw format
    - Refactor to use transfer function in dc instead of input gamma
    
    Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 415b12accd2c..6e70cf7b99ef 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -42,7 +42,6 @@
 #include "stream_encoder.h"
 #include "link_encoder.h"
 #include "clock_source.h"
-#include "gamma_calcs.h"
 #include "audio.h"
 #include "dce/dce_hwseq.h"
 
@@ -286,6 +285,436 @@ static bool dce110_set_input_transfer_func(
 	return result;
 }
 
+static bool build_custom_float(
+	struct fixed31_32 value,
+	const struct custom_float_format *format,
+	bool *negative,
+	uint32_t *mantissa,
+	uint32_t *exponenta)
+{
+	uint32_t exp_offset = (1 << (format->exponenta_bits - 1)) - 1;
+
+	const struct fixed31_32 mantissa_constant_plus_max_fraction =
+		dal_fixed31_32_from_fraction(
+			(1LL << (format->mantissa_bits + 1)) - 1,
+			1LL << format->mantissa_bits);
+
+	struct fixed31_32 mantiss;
+
+	if (dal_fixed31_32_eq(
+		value,
+		dal_fixed31_32_zero)) {
+		*negative = false;
+		*mantissa = 0;
+		*exponenta = 0;
+		return true;
+	}
+
+	if (dal_fixed31_32_lt(
+		value,
+		dal_fixed31_32_zero)) {
+		*negative = format->sign;
+		value = dal_fixed31_32_neg(value);
+	} else {
+		*negative = false;
+	}
+
+	if (dal_fixed31_32_lt(
+		value,
+		dal_fixed31_32_one)) {
+		uint32_t i = 1;
+
+		do {
+			value = dal_fixed31_32_shl(value, 1);
+			++i;
+		} while (dal_fixed31_32_lt(
+			value,
+			dal_fixed31_32_one));
+
+		--i;
+
+		if (exp_offset <= i) {
+			*mantissa = 0;
+			*exponenta = 0;
+			return true;
+		}
+
+		*exponenta = exp_offset - i;
+	} else if (dal_fixed31_32_le(
+		mantissa_constant_plus_max_fraction,
+		value)) {
+		uint32_t i = 1;
+
+		do {
+			value = dal_fixed31_32_shr(value, 1);
+			++i;
+		} while (dal_fixed31_32_lt(
+			mantissa_constant_plus_max_fraction,
+			value));
+
+		*exponenta = exp_offset + i - 1;
+	} else {
+		*exponenta = exp_offset;
+	}
+
+	mantiss = dal_fixed31_32_sub(
+		value,
+		dal_fixed31_32_one);
+
+	if (dal_fixed31_32_lt(
+			mantiss,
+			dal_fixed31_32_zero) ||
+		dal_fixed31_32_lt(
+			dal_fixed31_32_one,
+			mantiss))
+		mantiss = dal_fixed31_32_zero;
+	else
+		mantiss = dal_fixed31_32_shl(
+			mantiss,
+			format->mantissa_bits);
+
+	*mantissa = dal_fixed31_32_floor(mantiss);
+
+	return true;
+}
+
+static bool setup_custom_float(
+	const struct custom_float_format *format,
+	bool negative,
+	uint32_t mantissa,
+	uint32_t exponenta,
+	uint32_t *result)
+{
+	uint32_t i = 0;
+	uint32_t j = 0;
+
+	uint32_t value = 0;
+
+	/* verification code:
+	 * once calculation is ok we can remove it
+	 */
+
+	const uint32_t mantissa_mask =
+		(1 << (format->mantissa_bits + 1)) - 1;
+
+	const uint32_t exponenta_mask =
+		(1 << (format->exponenta_bits + 1)) - 1;
+
+	if (mantissa & ~mantissa_mask) {
+		BREAK_TO_DEBUGGER();
+		mantissa = mantissa_mask;
+	}
+
+	if (exponenta & ~exponenta_mask) {
+		BREAK_TO_DEBUGGER();
+		exponenta = exponenta_mask;
+	}
+
+	/* end of verification code */
+
+	while (i < format->mantissa_bits) {
+		uint32_t mask = 1 << i;
+
+		if (mantissa & mask)
+			value |= mask;
+
+		++i;
+	}
+
+	while (j < format->exponenta_bits) {
+		uint32_t mask = 1 << j;
+
+		if (exponenta & mask)
+			value |= mask << i;
+
+		++j;
+	}
+
+	if (negative && format->sign)
+		value |= 1 << (i + j);
+
+	*result = value;
+
+	return true;
+}
+
+static bool convert_to_custom_float_format(
+	struct fixed31_32 value,
+	const struct custom_float_format *format,
+	uint32_t *result)
+{
+	uint32_t mantissa;
+	uint32_t exponenta;
+	bool negative;
+
+	return build_custom_float(
+		value, format, &negative, &mantissa, &exponenta) &&
+	setup_custom_float(
+		format, negative, mantissa, exponenta, result);
+}
+
+static bool convert_to_custom_float(
+		struct pwl_result_data *rgb_resulted,
+		struct curve_points *arr_points,
+		uint32_t hw_points_num)
+{
+	struct custom_float_format fmt;
+
+	struct pwl_result_data *rgb = rgb_resulted;
+
+	uint32_t i = 0;
+
+	fmt.exponenta_bits = 6;
+	fmt.mantissa_bits = 12;
+	fmt.sign = true;
+
+	if (!convert_to_custom_float_format(
+		arr_points[0].x,
+		&fmt,
+		&arr_points[0].custom_float_x)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	if (!convert_to_custom_float_format(
+		arr_points[0].offset,
+		&fmt,
+		&arr_points[0].custom_float_offset)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	if (!convert_to_custom_float_format(
+		arr_points[0].slope,
+		&fmt,
+		&arr_points[0].custom_float_slope)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	fmt.mantissa_bits = 10;
+	fmt.sign = false;
+
+	if (!convert_to_custom_float_format(
+		arr_points[1].x,
+		&fmt,
+		&arr_points[1].custom_float_x)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	if (!convert_to_custom_float_format(
+		arr_points[1].y,
+		&fmt,
+		&arr_points[1].custom_float_y)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	if (!convert_to_custom_float_format(
+		arr_points[2].slope,
+		&fmt,
+		&arr_points[2].custom_float_slope)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	fmt.mantissa_bits = 12;
+	fmt.sign = true;
+
+	while (i != hw_points_num) {
+		if (!convert_to_custom_float_format(
+			rgb->red,
+			&fmt,
+			&rgb->red_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		if (!convert_to_custom_float_format(
+			rgb->green,
+			&fmt,
+			&rgb->green_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		if (!convert_to_custom_float_format(
+			rgb->blue,
+			&fmt,
+			&rgb->blue_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		if (!convert_to_custom_float_format(
+			rgb->delta_red,
+			&fmt,
+			&rgb->delta_red_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		if (!convert_to_custom_float_format(
+			rgb->delta_green,
+			&fmt,
+			&rgb->delta_green_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		if (!convert_to_custom_float_format(
+			rgb->delta_blue,
+			&fmt,
+			&rgb->delta_blue_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		++rgb;
+		++i;
+	}
+
+	return true;
+}
+
+static bool dce110_translate_regamma_to_hw_format(const struct dc_transfer_func
+		*output_tf, struct pwl_params *regamma_params)
+{
+	if (output_tf == NULL || regamma_params == NULL)
+		return false;
+
+	struct gamma_curve *arr_curve_points = regamma_params->arr_curve_points;
+	struct curve_points *arr_points = regamma_params->arr_points;
+	struct pwl_result_data *rgb_resulted = regamma_params->rgb_resulted;
+	struct fixed31_32 y_r;
+	struct fixed31_32 y_g;
+	struct fixed31_32 y_b;
+	struct fixed31_32 y1_min;
+	struct fixed31_32 y3_max;
+
+	int32_t segment_start, segment_end;
+	uint32_t hw_points, start_index;
+	uint32_t i, j;
+
+	memset(regamma_params, 0, sizeof(struct pwl_params));
+
+	if (output_tf->tf == TRANSFER_FUNCTION_PQ) {
+		/* 16 segments x 16 points
+		 * segments are from 2^-11 to 2^5
+		 */
+		segment_start = -11;
+		segment_end = 5;
+
+	} else {
+		/* 10 segments x 16 points
+		 * segment is from 2^-10 to 2^0
+		 */
+		segment_start = -10;
+		segment_end = 0;
+	}
+
+	hw_points = (segment_end - segment_start) * 16;
+	j = 0;
+	/* (segment + 25) * 32, every 2nd point */
+	start_index = (segment_start + 25) * 32;
+	for (i = start_index; i <= 1025; i += 2) {
+		if (j > hw_points)
+			break;
+		rgb_resulted[j].red = output_tf->tf_pts.red[i];
+		rgb_resulted[j].green = output_tf->tf_pts.green[i];
+		rgb_resulted[j].blue = output_tf->tf_pts.blue[i];
+		j++;
+	}
+
+	arr_points[0].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
+			dal_fixed31_32_from_int(segment_start));
+	arr_points[1].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
+			dal_fixed31_32_from_int(segment_end));
+	arr_points[2].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
+			dal_fixed31_32_from_int(segment_end));
+
+	y_r = rgb_resulted[0].red;
+	y_g = rgb_resulted[0].green;
+	y_b = rgb_resulted[0].blue;
+
+	y1_min = dal_fixed31_32_min(y_r, dal_fixed31_32_min(y_g, y_b));
+
+	arr_points[0].y = y1_min;
+	arr_points[0].slope = dal_fixed31_32_div(
+					arr_points[0].y,
+					arr_points[0].x);
+
+	y_r = rgb_resulted[hw_points - 1].red;
+	y_g = rgb_resulted[hw_points - 1].green;
+	y_b = rgb_resulted[hw_points - 1].blue;
+
+	/* see comment above, m_arrPoints[1].y should be the Y value for the
+	 * region end (m_numOfHwPoints), not last HW point(m_numOfHwPoints - 1)
+	 */
+	y3_max = dal_fixed31_32_max(y_r, dal_fixed31_32_max(y_g, y_b));
+
+	arr_points[1].y = y3_max;
+	arr_points[2].y = y3_max;
+
+	arr_points[1].slope = dal_fixed31_32_zero;
+	arr_points[2].slope = dal_fixed31_32_zero;
+
+	if (output_tf->tf == TRANSFER_FUNCTION_PQ) {
+		/* for PQ, we want to have a straight line from last HW X point,
+		 * and the slope to be such that we hit 1.0 at 10000 nits.
+		 */
+		const struct fixed31_32 end_value =
+				dal_fixed31_32_from_int(125);
+
+		arr_points[1].slope = dal_fixed31_32_div(
+			dal_fixed31_32_sub(dal_fixed31_32_one, arr_points[1].y),
+			dal_fixed31_32_sub(end_value, arr_points[1].x));
+		arr_points[2].slope = dal_fixed31_32_div(
+			dal_fixed31_32_sub(dal_fixed31_32_one, arr_points[1].y),
+			dal_fixed31_32_sub(end_value, arr_points[1].x));
+	}
+
+	regamma_params->hw_points_num = hw_points;
+
+	for (i = 0; i < segment_end - segment_start; i++) {
+		regamma_params->arr_curve_points[i].offset = i * 16;
+		regamma_params->arr_curve_points[i].segments_num = 4;
+	}
+
+	struct pwl_result_data *rgb = rgb_resulted;
+	struct pwl_result_data *rgb_plus_1 = rgb_resulted + 1;
+
+	i = 1;
+
+	while (i != hw_points + 1) {
+		if (dal_fixed31_32_lt(rgb_plus_1->red, rgb->red))
+			rgb_plus_1->red = rgb->red;
+		if (dal_fixed31_32_lt(rgb_plus_1->green, rgb->green))
+			rgb_plus_1->green = rgb->green;
+		if (dal_fixed31_32_lt(rgb_plus_1->blue, rgb->blue))
+			rgb_plus_1->blue = rgb->blue;
+
+		rgb->delta_red = dal_fixed31_32_sub(
+			rgb_plus_1->red,
+			rgb->red);
+		rgb->delta_green = dal_fixed31_32_sub(
+			rgb_plus_1->green,
+			rgb->green);
+		rgb->delta_blue = dal_fixed31_32_sub(
+			rgb_plus_1->blue,
+			rgb->blue);
+
+		++rgb_plus_1;
+		++rgb;
+		++i;
+	}
+
+	convert_to_custom_float(rgb_resulted, arr_points, hw_points);
+
+	return true;
+}
+
 static bool dce110_set_output_transfer_func(
 	struct pipe_ctx *pipe_ctx,
 	const struct core_surface *surface, /* Surface - To be removed */
@@ -308,10 +737,13 @@ static bool dce110_set_output_transfer_func(
 	opp->funcs->opp_power_on_regamma_lut(opp, true);
 
 	if (stream->public.out_transfer_func &&
-	    stream->public.out_transfer_func->type == TF_TYPE_PREDEFINED &&
-	    stream->public.out_transfer_func->tf == TRANSFER_FUNCTION_SRGB) {
+			stream->public.out_transfer_func->type ==
+			TF_TYPE_PREDEFINED &&
+			stream->public.out_transfer_func->tf ==
+			TRANSFER_FUNCTION_SRGB) {
 		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_SRGB);
-	} else if (ramp && calculate_regamma_params(regamma_params, ramp, surface, stream)) {
+	} else if (dce110_translate_regamma_to_hw_format(
+			stream->public.out_transfer_func, regamma_params)) {
 		opp->funcs->opp_program_regamma_pwl(opp, regamma_params);
 		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_USER);
 	} else {

commit ab2541b67395088b9de8ebf3943ef9ef86bccc41
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Thu Dec 29 15:27:12 2016 -0500

    drm/amd/display: Remove dc_target object
    
    dc_target does not fit well into DRM framework so removed it.
    This will prevent the driver from leveraging the pipe-split
    code for tiled displays, so will have to be handled at a higher
    level.  Most places that used dc_target now directly use dc_stream
    instead.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 751dbb88c265..415b12accd2c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -753,7 +753,7 @@ static enum dc_status apply_single_controller_ctx_to_hw(
 					stream->public.timing.h_total,
 					stream->public.timing.v_total,
 					stream->public.timing.pix_clk_khz,
-					context->target_count);
+					context->stream_count);
 
 	return DC_OK;
 }
@@ -1055,7 +1055,7 @@ static void reset_single_pipe_hw_ctx(
 	}
 	pipe_ctx->tg->funcs->disable_crtc(pipe_ctx->tg);
 	pipe_ctx->mi->funcs->free_mem_input(
-				pipe_ctx->mi, context->target_count);
+				pipe_ctx->mi, context->stream_count);
 	resource_unreference_clock_source(
 			&context->res_ctx, &pipe_ctx->clock_source);
 
@@ -1254,7 +1254,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 	dc->hwss.reset_hw_ctx_wrap(dc, context);
 
 	/* Skip applying if no targets */
-	if (context->target_count <= 0)
+	if (context->stream_count <= 0)
 		return DC_OK;
 
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
@@ -1761,7 +1761,7 @@ static void dce110_power_on_pipe_if_needed(
 				pipe_ctx->stream->public.timing.h_total,
 				pipe_ctx->stream->public.timing.v_total,
 				pipe_ctx->stream->public.timing.pix_clk_khz,
-				context->target_count);
+				context->stream_count);
 
 		/* TODO unhardcode*/
 		color_space_to_black_color(dc,

commit 624d7c4708b27be2dc095579394efadd80f090dd
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Jan 9 09:42:33 2017 -0500

    drm/amd/display: Pass visible flag into surface programming
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 965e47a5acfa..751dbb88c265 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1538,7 +1538,8 @@ static void set_plane_config(
 			&surface->public.plane_size,
 			surface->public.rotation,
 			NULL,
-			false);
+			false,
+			pipe_ctx->surface->public.visible);
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
@@ -1877,8 +1878,9 @@ static void dce110_program_front_end_for_pipe(
 			&surface->public.tiling_info,
 			&surface->public.plane_size,
 			surface->public.rotation,
+			NULL,
 			false,
-			false);
+			pipe_ctx->surface->public.visible);
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(

commit 4b5e7d620901778b24a2980bbc9941eff9b47f77
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Fri Jan 6 16:23:18 2017 -0500

    drm/amd/display: set blank functionality
    
    1. remove the sleep mechanism while set_blank true from
    the timing generator.
    Since Hw sequencer is the one that manages the flow
    he will be responsible for wait for blanck in a critical places.
    
    Signed-off-by: Leon Elazar <leon.elazar@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 7c27a820e5be..965e47a5acfa 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -623,7 +623,7 @@ static void program_scaler(const struct core_dc *dc,
 		&pipe_ctx->scl_data);
 }
 
-static enum dc_status prog_pixclk_crtc_otg(
+static enum dc_status dce110_prog_pixclk_crtc_otg(
 		struct pipe_ctx *pipe_ctx,
 		struct validate_context *context,
 		struct core_dc *dc)
@@ -641,6 +641,7 @@ static enum dc_status prog_pixclk_crtc_otg(
 		pipe_ctx->tg->funcs->set_blank_color(
 				pipe_ctx->tg,
 				&black_color);
+
 		/*
 		 * Must blank CRTC after disabling power gating and before any
 		 * programming, otherwise CRTC will be hung in bad state
@@ -1047,7 +1048,8 @@ static void reset_single_pipe_hw_ctx(
 		struct validate_context *context)
 {
 	core_link_disable_stream(pipe_ctx);
-	if (!pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, true)) {
+	pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, true);
+	if (!hwss_wait_for_blank_complete(pipe_ctx->tg)) {
 		dm_error("DC: failed to blank crtc!\n");
 		BREAK_TO_DEBUGGER();
 	}
@@ -1560,9 +1562,6 @@ static void update_plane_addr(const struct core_dc *dc,
 			surface->public.flip_immediate);
 
 	surface->status.requested_address = surface->public.address;
-
-	if (surface->public.visible)
-		pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, false);
 }
 
 void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)
@@ -1718,6 +1717,7 @@ static void init_hw(struct core_dc *dc)
 		/* Blank controller using driver code instead of
 		 * command table. */
 		tg->funcs->set_blank(tg, true);
+		hwss_wait_for_blank_complete(tg);
 	}
 
 	for (i = 0; i < dc->res_pool->audio_count; i++) {
@@ -2002,7 +2002,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.set_drr = set_drr,
 	.set_static_screen_control = set_static_screen_control,
 	.reset_hw_ctx_wrap = reset_hw_ctx_wrap,
-	.prog_pixclk_crtc_otg = prog_pixclk_crtc_otg,
+	.prog_pixclk_crtc_otg = dce110_prog_pixclk_crtc_otg,
 };
 
 bool dce110_hw_sequencer_construct(struct core_dc *dc)

commit b06b7680e341151c8c60b07ddc6f5e63e7392c17
Author: Leon Elazar <leon.elazar@amd.com>
Date:   Thu Jan 5 17:47:43 2017 -0500

    drm/amd/display: blank mechanism for supporting MPO
    
    blank/unblanck functionality apply_ctx_for_surface will update planes visibility
    by manipulating Blender and CRTC HW modules.
    
    Signed-off-by: Leon Elazar <leon.elazar@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 2b61fdf3f03d..7c27a820e5be 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1409,20 +1409,52 @@ static void set_default_colors(struct pipe_ctx *pipe_ctx)
 					pipe_ctx->opp, &default_adjust);
 }
 
-static void program_blender(const struct core_dc *dc,
+
+/*******************************************************************************
+ * In order to turn on/off specific surface we will program
+ * Blender + CRTC
+ *
+ * In case that we have two surfaces and they have a different visibility
+ * we can't turn off the CRTC since it will turn off the entire display
+ *
+ * |----------------------------------------------- |
+ * |bottom pipe|curr pipe  |              |         |
+ * |Surface    |Surface    | Blender      |  CRCT   |
+ * |visibility |visibility | Configuration|         |
+ * |------------------------------------------------|
+ * |   off     |    off    | CURRENT_PIPE | blank   |
+ * |   off     |    on     | CURRENT_PIPE | unblank |
+ * |   on      |    off    | OTHER_PIPE   | unblank |
+ * |   on      |    on     | BLENDING     | unblank |
+ * -------------------------------------------------|
+ *
+ ******************************************************************************/
+static void program_surface_visibility(const struct core_dc *dc,
 		struct pipe_ctx *pipe_ctx)
 {
 	enum blnd_mode blender_mode = BLND_MODE_CURRENT_PIPE;
+	bool blank_target = false;
 
 	if (pipe_ctx->bottom_pipe) {
+
+		/* For now we are supporting only two pipes */
+		ASSERT(pipe_ctx->bottom_pipe->bottom_pipe == NULL);
+
 		if (pipe_ctx->bottom_pipe->surface->public.visible) {
 			if (pipe_ctx->surface->public.visible)
 				blender_mode = BLND_MODE_BLENDING;
 			else
 				blender_mode = BLND_MODE_OTHER_PIPE;
-		}
-	}
+
+		} else if (!pipe_ctx->surface->public.visible)
+			blank_target = true;
+
+	} else if (!pipe_ctx->surface->public.visible)
+		blank_target = true;
+
 	dce_set_blender_mode(dc->hwseq, pipe_ctx->pipe_idx, blender_mode);
+	pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, blank_target);
+
 }
 
 /**
@@ -1495,7 +1527,7 @@ static void set_plane_config(
 	pipe_ctx->scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
 	program_scaler(dc, pipe_ctx);
 
-	program_blender(dc, pipe_ctx);
+	program_surface_visibility(dc, pipe_ctx);
 
 	mi->funcs->mem_input_program_surface_config(
 			mi,
@@ -1920,7 +1952,7 @@ static void dce110_apply_ctx_for_surface(
 			continue;
 
 		dce110_program_front_end_for_pipe(dc, pipe_ctx);
-		program_blender(dc, pipe_ctx);
+		program_surface_visibility(dc, pipe_ctx);
 
 	}
 }

commit e5cf325b0c21e626c402b57a055f02c478e3df40
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Jan 4 18:48:07 2017 -0500

    drm/amd/display: Fix warnings in DC
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 6a7cb3e9294a..2b61fdf3f03d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -293,7 +293,6 @@ static bool dce110_set_output_transfer_func(
 {
 	struct output_pixel_processor *opp = pipe_ctx->opp;
 	const struct core_gamma *ramp = NULL;
-	struct ipp_prescale_params prescale_params = { 0 };
 	struct pwl_params *regamma_params;
 	bool result = false;
 

commit 8c737fcc24b01ef36da5f78aace70d444485abf9
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Dec 22 13:07:11 2016 -0500

    drm/amd/display: Fixed crash caused by unnecessary clock source in split pipe.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index e4cef9da5de1..6a7cb3e9294a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1028,7 +1028,7 @@ static void switch_dp_clock_sources(
 			if (clk_src &&
 				clk_src != pipe_ctx->clock_source) {
 				resource_unreference_clock_source(
-					res_ctx, pipe_ctx->clock_source);
+					res_ctx, &pipe_ctx->clock_source);
 				pipe_ctx->clock_source = clk_src;
 				resource_reference_clock_source(res_ctx, clk_src);
 
@@ -1056,7 +1056,7 @@ static void reset_single_pipe_hw_ctx(
 	pipe_ctx->mi->funcs->free_mem_input(
 				pipe_ctx->mi, context->target_count);
 	resource_unreference_clock_source(
-			&context->res_ctx, pipe_ctx->clock_source);
+			&context->res_ctx, &pipe_ctx->clock_source);
 
 	dc->hwss.power_down_front_end((struct core_dc *)dc, pipe_ctx);
 

commit d7194cf6b8ddf0344e70834397d0b1af2cc5fe05
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Tue Dec 20 20:24:24 2016 -0500

    drm/amd/display: Implement gamma correction using input LUT
    
    The dc_gamma in dc_surface will be programmed to the input
    LUT if provided.  If dc_gamma is not provided in dc_surface
    regamma may be used to emulate gamma.
    
    Some refactor and cleanup included as well.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 2f790753b559..e4cef9da5de1 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -228,10 +228,11 @@ static void build_prescale_params(struct ipp_prescale_params *prescale_params,
 		break;
 	default:
 		ASSERT(false);
+		break;
 	}
 }
 
-static bool dce110_set_degamma(
+static bool dce110_set_input_transfer_func(
 	struct pipe_ctx *pipe_ctx,
 	const struct core_surface *surface)
 {
@@ -249,6 +250,9 @@ static bool dce110_set_degamma(
 	build_prescale_params(&prescale_params, surface);
 	ipp->funcs->ipp_program_prescale(ipp, &prescale_params);
 
+	if (surface->public.gamma_correction)
+	    ipp->funcs->ipp_program_input_lut(ipp, surface->public.gamma_correction);
+
 	if (tf == NULL) {
 		/* Default case if no input transfer function specified */
 		ipp->funcs->ipp_set_degamma(ipp,
@@ -272,6 +276,7 @@ static bool dce110_set_degamma(
 			break;
 		default:
 			result = false;
+			break;
 		}
 	} else {
 		/*TF_TYPE_DISTRIBUTED_POINTS - Not supported in DCE 11*/
@@ -303,8 +308,11 @@ static bool dce110_set_output_transfer_func(
 
 	opp->funcs->opp_power_on_regamma_lut(opp, true);
 
-	if (ramp && calculate_regamma_params(
-				regamma_params, ramp, surface, stream)) {
+	if (stream->public.out_transfer_func &&
+	    stream->public.out_transfer_func->type == TF_TYPE_PREDEFINED &&
+	    stream->public.out_transfer_func->tf == TRANSFER_FUNCTION_SRGB) {
+		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_SRGB);
+	} else if (ramp && calculate_regamma_params(regamma_params, ramp, surface, stream)) {
 		opp->funcs->opp_program_regamma_pwl(opp, regamma_params);
 		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_USER);
 	} else {
@@ -1318,7 +1326,6 @@ enum dc_status dce110_apply_ctx_to_hw(
 			* instead of per pipe.
 			*/
 			struct audio_output audio_output;
-			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 			build_audio_output(pipe_ctx, &audio_output);
 
@@ -1945,7 +1952,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.set_plane_config = set_plane_config,
 	.update_plane_addr = update_plane_addr,
 	.update_pending_status = dce110_update_pending_status,
-	.set_input_transfer_func = dce110_set_degamma,
+	.set_input_transfer_func = dce110_set_input_transfer_func,
 	.set_output_transfer_func = dce110_set_output_transfer_func,
 	.power_down = dce110_power_down,
 	.enable_accelerated_mode = dce110_enable_accelerated_mode,

commit e63d86dc9b59d72cf25c6bc75e641bceed4fcd40
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Fri Dec 16 12:12:03 2016 -0500

    drm/amd/display: Implement PQ curve based on output transfer function
    
    Refactor part 5 - Regamma programming should be dependent on Output
    transfer function type
    
    Program sRGB gamma or PQ transfer function based on output transfer
    function.
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 72017d5a8252..2f790753b559 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -303,7 +303,8 @@ static bool dce110_set_output_transfer_func(
 
 	opp->funcs->opp_power_on_regamma_lut(opp, true);
 
-	if (ramp && calculate_regamma_params(regamma_params, ramp, surface)) {
+	if (ramp && calculate_regamma_params(
+				regamma_params, ramp, surface, stream)) {
 		opp->funcs->opp_program_regamma_pwl(opp, regamma_params);
 		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_USER);
 	} else {

commit 90e508ba253c9e43711a7bf16230cdb13d0b1440
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Dec 15 12:09:46 2016 -0500

    drm/amd/display: Refactor output transfer function to stream
    
    Refactor part 3 - Moving output transfer function from surface to stream
    
    Split HWSS to program degamma and regamma separately.
    Degamma should be dependent on input transfer function.
    And Regamma should depend on the desired output transfer function.
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index f6984e9ed169..72017d5a8252 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -231,11 +231,61 @@ static void build_prescale_params(struct ipp_prescale_params *prescale_params,
 	}
 }
 
-static bool dce110_set_gamma_correction(
+static bool dce110_set_degamma(
 	struct pipe_ctx *pipe_ctx,
 	const struct core_surface *surface)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
+	const struct core_transfer_func *tf = NULL;
+	struct ipp_prescale_params prescale_params = { 0 };
+	bool result = true;
+
+	if (ipp == NULL)
+		return false;
+
+	if (surface->public.in_transfer_func)
+		tf = DC_TRANSFER_FUNC_TO_CORE(surface->public.in_transfer_func);
+
+	build_prescale_params(&prescale_params, surface);
+	ipp->funcs->ipp_program_prescale(ipp, &prescale_params);
+
+	if (tf == NULL) {
+		/* Default case if no input transfer function specified */
+		ipp->funcs->ipp_set_degamma(ipp,
+				IPP_DEGAMMA_MODE_BYPASS);
+	} else if (tf->public.type == TF_TYPE_PREDEFINED) {
+		switch (tf->public.tf) {
+		case TRANSFER_FUNCTION_SRGB:
+			ipp->funcs->ipp_set_degamma(ipp,
+					IPP_DEGAMMA_MODE_HW_sRGB);
+			break;
+		case TRANSFER_FUNCTION_BT709:
+			ipp->funcs->ipp_set_degamma(ipp,
+					IPP_DEGAMMA_MODE_HW_xvYCC);
+			break;
+		case TRANSFER_FUNCTION_LINEAR:
+			ipp->funcs->ipp_set_degamma(ipp,
+					IPP_DEGAMMA_MODE_BYPASS);
+			break;
+		case TRANSFER_FUNCTION_PQ:
+			result = false;
+			break;
+		default:
+			result = false;
+		}
+	} else {
+		/*TF_TYPE_DISTRIBUTED_POINTS - Not supported in DCE 11*/
+		result = false;
+	}
+
+	return result;
+}
+
+static bool dce110_set_output_transfer_func(
+	struct pipe_ctx *pipe_ctx,
+	const struct core_surface *surface, /* Surface - To be removed */
+	const struct core_stream *stream)
+{
 	struct output_pixel_processor *opp = pipe_ctx->opp;
 	const struct core_gamma *ramp = NULL;
 	struct ipp_prescale_params prescale_params = { 0 };
@@ -253,20 +303,10 @@ static bool dce110_set_gamma_correction(
 
 	opp->funcs->opp_power_on_regamma_lut(opp, true);
 
-	if (ipp) {
-		build_prescale_params(&prescale_params, surface);
-		ipp->funcs->ipp_program_prescale(ipp, &prescale_params);
-	}
-
 	if (ramp && calculate_regamma_params(regamma_params, ramp, surface)) {
-
 		opp->funcs->opp_program_regamma_pwl(opp, regamma_params);
-		if (ipp)
-			ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_HW_sRGB);
 		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_USER);
 	} else {
-		if (ipp)
-			ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
 		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_BYPASS);
 	}
 
@@ -1904,7 +1944,8 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.set_plane_config = set_plane_config,
 	.update_plane_addr = update_plane_addr,
 	.update_pending_status = dce110_update_pending_status,
-	.set_gamma_correction = dce110_set_gamma_correction,
+	.set_input_transfer_func = dce110_set_degamma,
+	.set_output_transfer_func = dce110_set_output_transfer_func,
 	.power_down = dce110_power_down,
 	.enable_accelerated_mode = dce110_enable_accelerated_mode,
 	.enable_timing_synchronization = dce110_enable_timing_synchronization,

commit fb735a9f29f94fcb29fee224b8da704a510a5a3a
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Dec 13 13:59:41 2016 -0500

    drm/amd/display: Add in/out transfer functions to DC
    
    Refactor part 1 of degamma/regamma programming.
    
    End goal is to have source and output transfer function in
    which dc can use to decide how to program the degamma
    and regamma HW.
    
    Gamma will be explicitly applied through
    dc_update_surfaces_for_target.
    
    Color module should build the logical curve with all
    adjustments applied and pass enough information
    for dc to program HW PWL.
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 99937facf645..f6984e9ed169 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -231,16 +231,20 @@ static void build_prescale_params(struct ipp_prescale_params *prescale_params,
 	}
 }
 
-static bool set_gamma_ramp(
-	struct input_pixel_processor *ipp,
-	struct output_pixel_processor *opp,
-	const struct core_gamma *ramp,
+static bool dce110_set_gamma_correction(
+	struct pipe_ctx *pipe_ctx,
 	const struct core_surface *surface)
 {
+	struct input_pixel_processor *ipp = pipe_ctx->ipp;
+	struct output_pixel_processor *opp = pipe_ctx->opp;
+	const struct core_gamma *ramp = NULL;
 	struct ipp_prescale_params prescale_params = { 0 };
 	struct pwl_params *regamma_params;
 	bool result = false;
 
+	if (surface->public.gamma_correction)
+		ramp = DC_GAMMA_TO_CORE(surface->public.gamma_correction);
+
 	regamma_params = dm_alloc(sizeof(struct pwl_params));
 	if (regamma_params == NULL)
 		goto regamma_alloc_fail;
@@ -1842,33 +1846,13 @@ static void dce110_program_front_end_for_pipe(
 			pipe_ctx->scl_data.recout.y);
 }
 
-
-
-static void dce110_prepare_pipe_for_surface_commit(
-		struct core_dc *dc,
-		struct pipe_ctx *pipe_ctx,
-		struct validate_context *context) {
-	struct core_gamma *gamma = NULL;
-
-	dc->hwss.increase_watermarks_for_pipe(dc, pipe_ctx, context);
-
-	if (pipe_ctx->surface->public.gamma_correction)
-		gamma = DC_GAMMA_TO_CORE(
-			pipe_ctx->surface->public.gamma_correction);
-
-	dc->hwss.set_gamma_correction(
-			pipe_ctx->ipp,
-			pipe_ctx->opp,
-			gamma, pipe_ctx->surface);
-}
-
 static void dce110_prepare_pipe_for_context(
 		struct core_dc *dc,
 		struct pipe_ctx *pipe_ctx,
 		struct validate_context *context)
 {
 	dce110_power_on_pipe_if_needed(dc, pipe_ctx, context);
-	dce110_prepare_pipe_for_surface_commit(dc, pipe_ctx, context);
+	dc->hwss.increase_watermarks_for_pipe(dc, pipe_ctx, context);
 }
 
 static void dce110_apply_ctx_for_surface(
@@ -1920,7 +1904,7 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.set_plane_config = set_plane_config,
 	.update_plane_addr = update_plane_addr,
 	.update_pending_status = dce110_update_pending_status,
-	.set_gamma_correction = set_gamma_ramp,
+	.set_gamma_correction = dce110_set_gamma_correction,
 	.power_down = dce110_power_down,
 	.enable_accelerated_mode = dce110_enable_accelerated_mode,
 	.enable_timing_synchronization = dce110_enable_timing_synchronization,

commit 9474980ac470a20d244318db9a7c12be01437805
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Dec 8 09:47:11 2016 -0500

    drm/amd/display: Added timing sync trace.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 6ad23f327631..99937facf645 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1892,7 +1892,6 @@ static void dce110_apply_ctx_for_surface(
 		program_blender(dc, pipe_ctx);
 
 	}
-
 }
 
 static void dce110_power_down_fe(struct core_dc *dc, struct pipe_ctx *pipe)

commit e9c58bb439bce021da205df09057fe6908ff54c5
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Nov 30 16:07:50 2016 -0500

    drm/amd/display: remove clocks_state enum
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index ca71509af74d..6ad23f327631 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1084,7 +1084,7 @@ static uint32_t get_max_pixel_clock_for_all_paths(
 static void apply_min_clocks(
 	struct core_dc *dc,
 	struct validate_context *context,
-	enum clocks_state *clocks_state,
+	enum dm_pp_clocks_state *clocks_state,
 	bool pre_mode_set)
 {
 	struct state_dependent_clocks req_clocks = {0};
@@ -1193,7 +1193,7 @@ enum dc_status dce110_apply_ctx_to_hw(
 	enum dc_status status;
 	int i;
 	bool programmed_audio_dto = false;
-	enum clocks_state clocks_state = CLOCKS_STATE_INVALID;
+	enum dm_pp_clocks_state clocks_state = DM_PP_CLOCKS_STATE_INVALID;
 
 	/* Reset old context */
 	/* look up the targets that have been removed since last commit */

commit 5d6d185f32eb0cce16caff13e716d08b594a6046
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Nov 30 11:03:37 2016 -0500

    drm/amd/display: restyle display clock calls part 2
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 16ee49dba97b..ca71509af74d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -1099,9 +1099,11 @@ static void apply_min_clocks(
 
 	if (!pre_mode_set) {
 		/* set clock_state without verification */
-		if (dal_display_clock_set_min_clocks_state(
-				pipe_ctx->dis_clk, *clocks_state))
+		if (pipe_ctx->dis_clk->funcs->set_min_clocks_state) {
+			pipe_ctx->dis_clk->funcs->set_min_clocks_state(
+						pipe_ctx->dis_clk, *clocks_state);
 			return;
+		}
 
 		/* TODOFPGA */
 	}
@@ -1114,9 +1116,10 @@ static void apply_min_clocks(
 	req_clocks.pixel_clk_khz = get_max_pixel_clock_for_all_paths(
 			dc, context, true);
 
-	if (dal_display_clock_get_required_clocks_state(
-				pipe_ctx->dis_clk, &req_clocks, clocks_state)) {
-		dal_display_clock_set_min_clocks_state(
+	if (pipe_ctx->dis_clk->funcs->get_required_clocks_state) {
+		*clocks_state = pipe_ctx->dis_clk->funcs->get_required_clocks_state(
+				pipe_ctx->dis_clk, &req_clocks);
+		pipe_ctx->dis_clk->funcs->set_min_clocks_state(
 			pipe_ctx->dis_clk, *clocks_state);
 	} else {
 	}

commit 1a687574a71f187dedcab3ac6012b0889c5a4e99
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Nov 30 10:49:51 2016 -0500

    drm/amd/display: restyle display clock calls part 1
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
index 1a682996b531..16ee49dba97b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -497,8 +497,8 @@ static void build_audio_output(
 	if (pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT ||
 			pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {
 		audio_output->pll_info.dp_dto_source_clock_in_khz =
-			dal_display_clock_get_dp_ref_clk_frequency(
-				pipe_ctx->dis_clk);
+				pipe_ctx->dis_clk->funcs->get_dp_ref_clk_frequency(
+						pipe_ctx->dis_clk);
 	}
 
 	audio_output->pll_info.feed_back_divider =
@@ -788,39 +788,6 @@ void dce110_enable_accelerated_mode(struct core_dc *dc)
 	bios_set_scratch_acc_mode_change(dc->ctx->dc_bios);
 }
 
-/**
- * Call display_engine_clock_dce80 to perform the Dclk programming.
- */
-void dce110_set_display_clock(struct validate_context *context)
-{
-	/* Program the display engine clock.
-	 * Check DFS bypass mode support or not. DFSbypass feature is only when
-	 * BIOS GPU info table reports support. */
-
-	if (/*dal_adapter_service_is_dfs_bypass_enabled()*/ false) {
-		/*TODO: set_display_clock_dfs_bypass(
-				hws,
-				path_set,
-				context->res_ctx.pool->display_clock,
-				context->res_ctx.min_clocks.min_dclk_khz);*/
-	} else {
-		/*
-		 * TODO: need to either port work around from DAL2 function
-		 * getActualRequiredDisplayClock or program displayclock without
-		 * calling vbios. Currently temporily work
-		 * around by increasing the displclk by 15 percent
-		 */
-		dal_display_clock_set_clock(
-				context->res_ctx.pool->display_clock,
-				context->bw_results.dispclk_khz * 115 / 100);
-	}
-
-
-	/* TODO: When changing display engine clock, DMCU WaitLoop must be
-	 * reconfigured in order to maintain the same delays within DMCU
-	 * programming sequences. */
-}
-
 static uint32_t compute_pstate_blackout_duration(
 	struct bw_fixed blackout_duration,
 	const struct core_stream *stream)
@@ -1267,8 +1234,10 @@ enum dc_status dce110_apply_ctx_to_hw(
 	apply_min_clocks(dc, context, &clocks_state, true);
 
 	if (context->bw_results.dispclk_khz
-		> dc->current_context->bw_results.dispclk_khz)
-		dc->hwss.set_display_clock(context);
+			> dc->current_context->bw_results.dispclk_khz)
+		context->res_ctx.pool->display_clock->funcs->set_clock(
+				context->res_ctx.pool->display_clock,
+				context->bw_results.dispclk_khz * 115 / 100);
 
 	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx_old =
@@ -1738,7 +1707,9 @@ static void dce110_set_bandwidth(struct core_dc *dc)
 		program_wm_for_pipe(dc, pipe_ctx, dc->current_context);
 	}
 
-	dc->hwss.set_display_clock(dc->current_context);
+	dc->current_context->res_ctx.pool->display_clock->funcs->set_clock(
+			dc->current_context->res_ctx.pool->display_clock,
+			dc->current_context->bw_results.dispclk_khz * 115 / 100);
 }
 
 static void dce110_program_front_end_for_pipe(
@@ -1959,7 +1930,6 @@ static const struct hw_sequencer_funcs dce110_funcs = {
 	.enable_display_power_gating = dce110_enable_display_power_gating,
 	.power_down_front_end = dce110_power_down_fe,
 	.pipe_control_lock = dce_pipe_control_lock,
-	.set_display_clock = dce110_set_display_clock,
 	.set_displaymarks = dce110_set_displaymarks,
 	.increase_watermarks_for_pipe = dce110_increase_watermarks_for_pipe,
 	.set_bandwidth = dce110_set_bandwidth,

commit 4562236b3bc0a28aeb6ee93b2d8a849a4c4e1c7c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 12 15:58:20 2017 -0400

    drm/amd/dc: Add dc display driver (v2)
    
    Supported DCE versions: 8.0, 10.0, 11.0, 11.2
    
    v2: rebase against 4.11
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
new file mode 100644
index 000000000000..1a682996b531
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -0,0 +1,1978 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+#include "dm_services.h"
+#include "dc.h"
+#include "dc_bios_types.h"
+#include "core_types.h"
+#include "core_status.h"
+#include "resource.h"
+#include "hw_sequencer.h"
+#include "dm_helpers.h"
+#include "dce110_hw_sequencer.h"
+#include "dce110_timing_generator.h"
+
+#include "bios/bios_parser_helper.h"
+#include "timing_generator.h"
+#include "mem_input.h"
+#include "opp.h"
+#include "ipp.h"
+#include "transform.h"
+#include "stream_encoder.h"
+#include "link_encoder.h"
+#include "clock_source.h"
+#include "gamma_calcs.h"
+#include "audio.h"
+#include "dce/dce_hwseq.h"
+
+/* include DCE11 register header files */
+#include "dce/dce_11_0_d.h"
+#include "dce/dce_11_0_sh_mask.h"
+
+struct dce110_hw_seq_reg_offsets {
+	uint32_t crtc;
+};
+
+static const struct dce110_hw_seq_reg_offsets reg_offsets[] = {
+{
+	.crtc = (mmCRTC0_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),
+},
+{
+	.crtc = (mmCRTC1_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),
+},
+{
+	.crtc = (mmCRTC2_CRTC_GSL_CONTROL - mmCRTC_GSL_CONTROL),
+},
+{
+	.crtc = (mmCRTCV_GSL_CONTROL - mmCRTC_GSL_CONTROL),
+}
+};
+
+#define HW_REG_BLND(reg, id)\
+	(reg + reg_offsets[id].blnd)
+
+#define HW_REG_CRTC(reg, id)\
+	(reg + reg_offsets[id].crtc)
+
+#define MAX_WATERMARK 0xFFFF
+#define SAFE_NBP_MARK 0x7FFF
+
+/*******************************************************************************
+ * Private definitions
+ ******************************************************************************/
+/***************************PIPE_CONTROL***********************************/
+static void dce110_init_pte(struct dc_context *ctx)
+{
+	uint32_t addr;
+	uint32_t value = 0;
+	uint32_t chunk_int = 0;
+	uint32_t chunk_mul = 0;
+
+	addr = mmUNP_DVMM_PTE_CONTROL;
+	value = dm_read_reg(ctx, addr);
+
+	set_reg_field_value(
+		value,
+		0,
+		DVMM_PTE_CONTROL,
+		DVMM_USE_SINGLE_PTE);
+
+	set_reg_field_value(
+		value,
+		1,
+		DVMM_PTE_CONTROL,
+		DVMM_PTE_BUFFER_MODE0);
+
+	set_reg_field_value(
+		value,
+		1,
+		DVMM_PTE_CONTROL,
+		DVMM_PTE_BUFFER_MODE1);
+
+	dm_write_reg(ctx, addr, value);
+
+	addr = mmDVMM_PTE_REQ;
+	value = dm_read_reg(ctx, addr);
+
+	chunk_int = get_reg_field_value(
+		value,
+		DVMM_PTE_REQ,
+		HFLIP_PTEREQ_PER_CHUNK_INT);
+
+	chunk_mul = get_reg_field_value(
+		value,
+		DVMM_PTE_REQ,
+		HFLIP_PTEREQ_PER_CHUNK_MULTIPLIER);
+
+	if (chunk_int != 0x4 || chunk_mul != 0x4) {
+
+		set_reg_field_value(
+			value,
+			255,
+			DVMM_PTE_REQ,
+			MAX_PTEREQ_TO_ISSUE);
+
+		set_reg_field_value(
+			value,
+			4,
+			DVMM_PTE_REQ,
+			HFLIP_PTEREQ_PER_CHUNK_INT);
+
+		set_reg_field_value(
+			value,
+			4,
+			DVMM_PTE_REQ,
+			HFLIP_PTEREQ_PER_CHUNK_MULTIPLIER);
+
+		dm_write_reg(ctx, addr, value);
+	}
+}
+/**************************************************************************/
+
+static void enable_display_pipe_clock_gating(
+	struct dc_context *ctx,
+	bool clock_gating)
+{
+	/*TODO*/
+}
+
+static bool dce110_enable_display_power_gating(
+	struct core_dc *dc,
+	uint8_t controller_id,
+	struct dc_bios *dcb,
+	enum pipe_gating_control power_gating)
+{
+	enum bp_result bp_result = BP_RESULT_OK;
+	enum bp_pipe_control_action cntl;
+	struct dc_context *ctx = dc->ctx;
+	unsigned int underlay_idx = dc->res_pool->underlay_pipe_index;
+
+	if (IS_FPGA_MAXIMUS_DC(ctx->dce_environment))
+		return true;
+
+	if (power_gating == PIPE_GATING_CONTROL_INIT)
+		cntl = ASIC_PIPE_INIT;
+	else if (power_gating == PIPE_GATING_CONTROL_ENABLE)
+		cntl = ASIC_PIPE_ENABLE;
+	else
+		cntl = ASIC_PIPE_DISABLE;
+
+	if (controller_id == underlay_idx)
+		controller_id = CONTROLLER_ID_UNDERLAY0 - 1;
+
+	if (power_gating != PIPE_GATING_CONTROL_INIT || controller_id == 0){
+
+		bp_result = dcb->funcs->enable_disp_power_gating(
+						dcb, controller_id + 1, cntl);
+
+		/* Revert MASTER_UPDATE_MODE to 0 because bios sets it 2
+		 * by default when command table is called
+		 *
+		 * Bios parser accepts controller_id = 6 as indicative of
+		 * underlay pipe in dce110. But we do not support more
+		 * than 3.
+		 */
+		if (controller_id < CONTROLLER_ID_MAX - 1)
+			dm_write_reg(ctx,
+				HW_REG_CRTC(mmCRTC_MASTER_UPDATE_MODE, controller_id),
+				0);
+	}
+
+	if (power_gating != PIPE_GATING_CONTROL_ENABLE)
+		dce110_init_pte(ctx);
+
+	if (bp_result == BP_RESULT_OK)
+		return true;
+	else
+		return false;
+}
+
+static void build_prescale_params(struct ipp_prescale_params *prescale_params,
+		const struct core_surface *surface)
+{
+	prescale_params->mode = IPP_PRESCALE_MODE_FIXED_UNSIGNED;
+
+	switch (surface->public.format) {
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_BGRA8888:
+		prescale_params->scale = 0x2020;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:
+		prescale_params->scale = 0x2008;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:
+		prescale_params->scale = 0x2000;
+		break;
+	default:
+		ASSERT(false);
+	}
+}
+
+static bool set_gamma_ramp(
+	struct input_pixel_processor *ipp,
+	struct output_pixel_processor *opp,
+	const struct core_gamma *ramp,
+	const struct core_surface *surface)
+{
+	struct ipp_prescale_params prescale_params = { 0 };
+	struct pwl_params *regamma_params;
+	bool result = false;
+
+	regamma_params = dm_alloc(sizeof(struct pwl_params));
+	if (regamma_params == NULL)
+		goto regamma_alloc_fail;
+
+	regamma_params->hw_points_num = GAMMA_HW_POINTS_NUM;
+
+	opp->funcs->opp_power_on_regamma_lut(opp, true);
+
+	if (ipp) {
+		build_prescale_params(&prescale_params, surface);
+		ipp->funcs->ipp_program_prescale(ipp, &prescale_params);
+	}
+
+	if (ramp && calculate_regamma_params(regamma_params, ramp, surface)) {
+
+		opp->funcs->opp_program_regamma_pwl(opp, regamma_params);
+		if (ipp)
+			ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_HW_sRGB);
+		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_USER);
+	} else {
+		if (ipp)
+			ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
+		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_BYPASS);
+	}
+
+	opp->funcs->opp_power_on_regamma_lut(opp, false);
+
+	result = true;
+
+	dm_free(regamma_params);
+
+regamma_alloc_fail:
+	return result;
+}
+
+static enum dc_status bios_parser_crtc_source_select(
+		struct pipe_ctx *pipe_ctx)
+{
+	struct dc_bios *dcb;
+	/* call VBIOS table to set CRTC source for the HW
+	 * encoder block
+	 * note: video bios clears all FMT setting here. */
+	struct bp_crtc_source_select crtc_source_select = {0};
+	const struct core_sink *sink = pipe_ctx->stream->sink;
+
+	crtc_source_select.engine_id = pipe_ctx->stream_enc->id;
+	crtc_source_select.controller_id = pipe_ctx->pipe_idx + 1;
+	/*TODO: Need to un-hardcode color depth, dp_audio and account for
+	 * the case where signal and sink signal is different (translator
+	 * encoder)*/
+	crtc_source_select.signal = pipe_ctx->stream->signal;
+	crtc_source_select.enable_dp_audio = false;
+	crtc_source_select.sink_signal = pipe_ctx->stream->signal;
+	crtc_source_select.display_output_bit_depth = PANEL_8BIT_COLOR;
+
+	dcb = sink->ctx->dc_bios;
+
+	if (BP_RESULT_OK != dcb->funcs->crtc_source_select(
+		dcb,
+		&crtc_source_select)) {
+		return DC_ERROR_UNEXPECTED;
+	}
+
+	return DC_OK;
+}
+
+void dce110_update_info_frame(struct pipe_ctx *pipe_ctx)
+{
+	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
+		pipe_ctx->stream_enc->funcs->update_hdmi_info_packets(
+			pipe_ctx->stream_enc,
+			&pipe_ctx->encoder_info_frame);
+	else if (dc_is_dp_signal(pipe_ctx->stream->signal))
+		pipe_ctx->stream_enc->funcs->update_dp_info_packets(
+			pipe_ctx->stream_enc,
+			&pipe_ctx->encoder_info_frame);
+}
+
+void dce110_enable_stream(struct pipe_ctx *pipe_ctx)
+{
+	enum dc_lane_count lane_count =
+		pipe_ctx->stream->sink->link->public.cur_link_settings.lane_count;
+
+	struct dc_crtc_timing *timing = &pipe_ctx->stream->public.timing;
+	struct core_link *link = pipe_ctx->stream->sink->link;
+
+	/* 1. update AVI info frame (HDMI, DP)
+	 * we always need to update info frame
+	*/
+	uint32_t active_total_with_borders;
+	uint32_t early_control = 0;
+	struct timing_generator *tg = pipe_ctx->tg;
+
+	/* TODOFPGA may change to hwss.update_info_frame */
+	dce110_update_info_frame(pipe_ctx);
+	/* enable early control to avoid corruption on DP monitor*/
+	active_total_with_borders =
+			timing->h_addressable
+				+ timing->h_border_left
+				+ timing->h_border_right;
+
+	if (lane_count != 0)
+		early_control = active_total_with_borders % lane_count;
+
+	if (early_control == 0)
+		early_control = lane_count;
+
+	tg->funcs->set_early_control(tg, early_control);
+
+	/* enable audio only within mode set */
+	if (pipe_ctx->audio != NULL) {
+		if (dc_is_dp_signal(pipe_ctx->stream->signal))
+			pipe_ctx->stream_enc->funcs->dp_audio_enable(pipe_ctx->stream_enc);
+	}
+
+	/* For MST, there are multiply stream go to only one link.
+	 * connect DIG back_end to front_end while enable_stream and
+	 * disconnect them during disable_stream
+	 * BY this, it is logic clean to separate stream and link */
+	 link->link_enc->funcs->connect_dig_be_to_fe(link->link_enc,
+			pipe_ctx->stream_enc->id, true);
+
+}
+
+void dce110_disable_stream(struct pipe_ctx *pipe_ctx)
+{
+	struct core_stream *stream = pipe_ctx->stream;
+	struct core_link *link = stream->sink->link;
+
+	if (pipe_ctx->audio) {
+		pipe_ctx->audio->funcs->az_disable(pipe_ctx->audio);
+
+		if (dc_is_dp_signal(pipe_ctx->stream->signal))
+			pipe_ctx->stream_enc->funcs->dp_audio_disable(
+					pipe_ctx->stream_enc);
+		else
+			pipe_ctx->stream_enc->funcs->hdmi_audio_disable(
+					pipe_ctx->stream_enc);
+
+		pipe_ctx->audio = NULL;
+
+		/* TODO: notify audio driver for if audio modes list changed
+		 * add audio mode list change flag */
+		/* dal_audio_disable_azalia_audio_jack_presence(stream->audio,
+		 * stream->stream_engine_id);
+		 */
+	}
+
+	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
+		pipe_ctx->stream_enc->funcs->stop_hdmi_info_packets(
+			pipe_ctx->stream_enc);
+
+	if (dc_is_dp_signal(pipe_ctx->stream->signal))
+		pipe_ctx->stream_enc->funcs->stop_dp_info_packets(
+			pipe_ctx->stream_enc);
+
+	pipe_ctx->stream_enc->funcs->audio_mute_control(
+			pipe_ctx->stream_enc, true);
+
+
+	/* blank at encoder level */
+	if (dc_is_dp_signal(pipe_ctx->stream->signal))
+		pipe_ctx->stream_enc->funcs->dp_blank(pipe_ctx->stream_enc);
+
+	link->link_enc->funcs->connect_dig_be_to_fe(
+			link->link_enc,
+			pipe_ctx->stream_enc->id,
+			false);
+
+}
+
+void dce110_unblank_stream(struct pipe_ctx *pipe_ctx,
+		struct dc_link_settings *link_settings)
+{
+	struct encoder_unblank_param params = { { 0 } };
+
+	/* only 3 items below are used by unblank */
+	params.crtc_timing.pixel_clock =
+		pipe_ctx->stream->public.timing.pix_clk_khz;
+	params.link_settings.link_rate = link_settings->link_rate;
+	pipe_ctx->stream_enc->funcs->dp_unblank(pipe_ctx->stream_enc, &params);
+}
+
+static enum audio_dto_source translate_to_dto_source(enum controller_id crtc_id)
+{
+	switch (crtc_id) {
+	case CONTROLLER_ID_D0:
+		return DTO_SOURCE_ID0;
+	case CONTROLLER_ID_D1:
+		return DTO_SOURCE_ID1;
+	case CONTROLLER_ID_D2:
+		return DTO_SOURCE_ID2;
+	case CONTROLLER_ID_D3:
+		return DTO_SOURCE_ID3;
+	case CONTROLLER_ID_D4:
+		return DTO_SOURCE_ID4;
+	case CONTROLLER_ID_D5:
+		return DTO_SOURCE_ID5;
+	default:
+		return DTO_SOURCE_UNKNOWN;
+	}
+}
+
+static void build_audio_output(
+	const struct pipe_ctx *pipe_ctx,
+	struct audio_output *audio_output)
+{
+	const struct core_stream *stream = pipe_ctx->stream;
+	audio_output->engine_id = pipe_ctx->stream_enc->id;
+
+	audio_output->signal = pipe_ctx->stream->signal;
+
+	/* audio_crtc_info  */
+
+	audio_output->crtc_info.h_total =
+		stream->public.timing.h_total;
+
+	/*
+	 * Audio packets are sent during actual CRTC blank physical signal, we
+	 * need to specify actual active signal portion
+	 */
+	audio_output->crtc_info.h_active =
+			stream->public.timing.h_addressable
+			+ stream->public.timing.h_border_left
+			+ stream->public.timing.h_border_right;
+
+	audio_output->crtc_info.v_active =
+			stream->public.timing.v_addressable
+			+ stream->public.timing.v_border_top
+			+ stream->public.timing.v_border_bottom;
+
+	audio_output->crtc_info.pixel_repetition = 1;
+
+	audio_output->crtc_info.interlaced =
+			stream->public.timing.flags.INTERLACE;
+
+	audio_output->crtc_info.refresh_rate =
+		(stream->public.timing.pix_clk_khz*1000)/
+		(stream->public.timing.h_total*stream->public.timing.v_total);
+
+	audio_output->crtc_info.color_depth =
+		stream->public.timing.display_color_depth;
+
+	audio_output->crtc_info.requested_pixel_clock =
+			pipe_ctx->pix_clk_params.requested_pix_clk;
+
+	/*
+	 * TODO - Investigate why calculated pixel clk has to be
+	 * requested pixel clk
+	 */
+	audio_output->crtc_info.calculated_pixel_clock =
+			pipe_ctx->pix_clk_params.requested_pix_clk;
+
+	if (pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT ||
+			pipe_ctx->stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {
+		audio_output->pll_info.dp_dto_source_clock_in_khz =
+			dal_display_clock_get_dp_ref_clk_frequency(
+				pipe_ctx->dis_clk);
+	}
+
+	audio_output->pll_info.feed_back_divider =
+			pipe_ctx->pll_settings.feedback_divider;
+
+	audio_output->pll_info.dto_source =
+		translate_to_dto_source(
+			pipe_ctx->pipe_idx + 1);
+
+	/* TODO hard code to enable for now. Need get from stream */
+	audio_output->pll_info.ss_enabled = true;
+
+	audio_output->pll_info.ss_percentage =
+			pipe_ctx->pll_settings.ss_percentage;
+}
+
+static void get_surface_visual_confirm_color(const struct pipe_ctx *pipe_ctx,
+		struct tg_color *color)
+{
+	uint32_t color_value = MAX_TG_COLOR_VALUE * (4 - pipe_ctx->pipe_idx) / 4;
+
+	switch (pipe_ctx->scl_data.format) {
+	case PIXEL_FORMAT_ARGB8888:
+		/* set boarder color to red */
+		color->color_r_cr = color_value;
+		break;
+
+	case PIXEL_FORMAT_ARGB2101010:
+		/* set boarder color to blue */
+		color->color_b_cb = color_value;
+		break;
+	case PIXEL_FORMAT_420BPP12:
+		/* set boarder color to green */
+		color->color_g_y = color_value;
+		break;
+	case PIXEL_FORMAT_FP16:
+		/* set boarder color to white */
+		color->color_r_cr = color_value;
+		color->color_b_cb = color_value;
+		color->color_g_y = color_value;
+		break;
+	default:
+		break;
+	}
+}
+
+static void program_scaler(const struct core_dc *dc,
+		const struct pipe_ctx *pipe_ctx)
+{
+	struct tg_color color = {0};
+
+	if (dc->public.debug.surface_visual_confirm)
+		get_surface_visual_confirm_color(pipe_ctx, &color);
+	else
+		color_space_to_black_color(dc,
+				pipe_ctx->stream->public.output_color_space,
+				&color);
+
+	pipe_ctx->xfm->funcs->transform_set_pixel_storage_depth(
+		pipe_ctx->xfm,
+		pipe_ctx->scl_data.lb_params.depth,
+		&pipe_ctx->stream->bit_depth_params);
+
+	if (pipe_ctx->tg->funcs->set_overscan_blank_color)
+		pipe_ctx->tg->funcs->set_overscan_blank_color(
+				pipe_ctx->tg,
+				&color);
+
+	pipe_ctx->xfm->funcs->transform_set_scaler(pipe_ctx->xfm,
+		&pipe_ctx->scl_data);
+}
+
+static enum dc_status prog_pixclk_crtc_otg(
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context,
+		struct core_dc *dc)
+{
+	struct core_stream *stream = pipe_ctx->stream;
+	struct pipe_ctx *pipe_ctx_old = &dc->current_context->res_ctx.
+			pipe_ctx[pipe_ctx->pipe_idx];
+	struct tg_color black_color = {0};
+
+	if (!pipe_ctx_old->stream) {
+
+		/* program blank color */
+		color_space_to_black_color(dc,
+				stream->public.output_color_space, &black_color);
+		pipe_ctx->tg->funcs->set_blank_color(
+				pipe_ctx->tg,
+				&black_color);
+		/*
+		 * Must blank CRTC after disabling power gating and before any
+		 * programming, otherwise CRTC will be hung in bad state
+		 */
+		pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, true);
+
+		if (false == pipe_ctx->clock_source->funcs->program_pix_clk(
+				pipe_ctx->clock_source,
+				&pipe_ctx->pix_clk_params,
+				&pipe_ctx->pll_settings)) {
+			BREAK_TO_DEBUGGER();
+			return DC_ERROR_UNEXPECTED;
+		}
+
+		pipe_ctx->tg->funcs->program_timing(
+				pipe_ctx->tg,
+				&stream->public.timing,
+				true);
+	}
+
+	if (!pipe_ctx_old->stream) {
+		if (false == pipe_ctx->tg->funcs->enable_crtc(
+				pipe_ctx->tg)) {
+			BREAK_TO_DEBUGGER();
+			return DC_ERROR_UNEXPECTED;
+		}
+	}
+
+	return DC_OK;
+}
+
+static enum dc_status apply_single_controller_ctx_to_hw(
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context,
+		struct core_dc *dc)
+{
+	struct core_stream *stream = pipe_ctx->stream;
+	struct pipe_ctx *pipe_ctx_old = &dc->current_context->res_ctx.
+			pipe_ctx[pipe_ctx->pipe_idx];
+
+	/*  */
+	dc->hwss.prog_pixclk_crtc_otg(pipe_ctx, context, dc);
+
+	pipe_ctx->opp->funcs->opp_set_dyn_expansion(
+			pipe_ctx->opp,
+			COLOR_SPACE_YCBCR601,
+			stream->public.timing.display_color_depth,
+			pipe_ctx->stream->signal);
+
+	pipe_ctx->opp->funcs->opp_program_fmt(
+			pipe_ctx->opp,
+			&stream->bit_depth_params,
+			&stream->clamping);
+
+	/* FPGA does not program backend */
+	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
+		return DC_OK;
+
+	/* TODO: move to stream encoder */
+	if (pipe_ctx->stream->signal != SIGNAL_TYPE_VIRTUAL)
+		if (DC_OK != bios_parser_crtc_source_select(pipe_ctx)) {
+			BREAK_TO_DEBUGGER();
+			return DC_ERROR_UNEXPECTED;
+		}
+
+	if (pipe_ctx->stream->signal != SIGNAL_TYPE_VIRTUAL)
+		stream->sink->link->link_enc->funcs->setup(
+			stream->sink->link->link_enc,
+			pipe_ctx->stream->signal);
+
+	if (dc_is_dp_signal(pipe_ctx->stream->signal))
+		pipe_ctx->stream_enc->funcs->dp_set_stream_attribute(
+			pipe_ctx->stream_enc,
+			&stream->public.timing,
+			stream->public.output_color_space);
+
+	if (dc_is_hdmi_signal(pipe_ctx->stream->signal))
+		pipe_ctx->stream_enc->funcs->hdmi_set_stream_attribute(
+			pipe_ctx->stream_enc,
+			&stream->public.timing,
+			stream->phy_pix_clk,
+			pipe_ctx->audio != NULL);
+
+	if (dc_is_dvi_signal(pipe_ctx->stream->signal))
+		pipe_ctx->stream_enc->funcs->dvi_set_stream_attribute(
+			pipe_ctx->stream_enc,
+			&stream->public.timing,
+			(pipe_ctx->stream->signal == SIGNAL_TYPE_DVI_DUAL_LINK) ?
+			true : false);
+
+	if (!pipe_ctx_old->stream) {
+		core_link_enable_stream(pipe_ctx);
+
+		if (dc_is_dp_signal(pipe_ctx->stream->signal))
+			dce110_unblank_stream(pipe_ctx,
+				&stream->sink->link->public.cur_link_settings);
+	}
+
+	pipe_ctx->scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
+	/* program_scaler and allocate_mem_input are not new asic */
+	if (!pipe_ctx_old || memcmp(&pipe_ctx_old->scl_data,
+				&pipe_ctx->scl_data,
+				sizeof(struct scaler_data)) != 0)
+		program_scaler(dc, pipe_ctx);
+
+	/* mst support - use total stream count */
+		pipe_ctx->mi->funcs->allocate_mem_input(
+					pipe_ctx->mi,
+					stream->public.timing.h_total,
+					stream->public.timing.v_total,
+					stream->public.timing.pix_clk_khz,
+					context->target_count);
+
+	return DC_OK;
+}
+
+/******************************************************************************/
+
+static void power_down_encoders(struct core_dc *dc)
+{
+	int i;
+
+	for (i = 0; i < dc->link_count; i++) {
+		dc->links[i]->link_enc->funcs->disable_output(
+				dc->links[i]->link_enc, SIGNAL_TYPE_NONE);
+	}
+}
+
+static void power_down_controllers(struct core_dc *dc)
+{
+	int i;
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		dc->res_pool->timing_generators[i]->funcs->disable_crtc(
+				dc->res_pool->timing_generators[i]);
+	}
+}
+
+static void power_down_clock_sources(struct core_dc *dc)
+{
+	int i;
+
+	if (dc->res_pool->dp_clock_source->funcs->cs_power_down(
+		dc->res_pool->dp_clock_source) == false)
+		dm_error("Failed to power down pll! (dp clk src)\n");
+
+	for (i = 0; i < dc->res_pool->clk_src_count; i++) {
+		if (dc->res_pool->clock_sources[i]->funcs->cs_power_down(
+				dc->res_pool->clock_sources[i]) == false)
+			dm_error("Failed to power down pll! (clk src index=%d)\n", i);
+	}
+}
+
+static void power_down_all_hw_blocks(struct core_dc *dc)
+{
+	power_down_encoders(dc);
+
+	power_down_controllers(dc);
+
+	power_down_clock_sources(dc);
+}
+
+static void disable_vga_and_power_gate_all_controllers(
+		struct core_dc *dc)
+{
+	int i;
+	struct timing_generator *tg;
+	struct dc_context *ctx = dc->ctx;
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		tg = dc->res_pool->timing_generators[i];
+
+		tg->funcs->disable_vga(tg);
+
+		/* Enable CLOCK gating for each pipe BEFORE controller
+		 * powergating. */
+		enable_display_pipe_clock_gating(ctx,
+				true);
+
+		dc->hwss.power_down_front_end(
+			dc, &dc->current_context->res_ctx.pipe_ctx[i]);
+	}
+}
+
+/**
+ * When ASIC goes from VBIOS/VGA mode to driver/accelerated mode we need:
+ *  1. Power down all DC HW blocks
+ *  2. Disable VGA engine on all controllers
+ *  3. Enable power gating for controller
+ *  4. Set acc_mode_change bit (VBIOS will clear this bit when going to FSDOS)
+ */
+void dce110_enable_accelerated_mode(struct core_dc *dc)
+{
+	power_down_all_hw_blocks(dc);
+
+	disable_vga_and_power_gate_all_controllers(dc);
+	bios_set_scratch_acc_mode_change(dc->ctx->dc_bios);
+}
+
+/**
+ * Call display_engine_clock_dce80 to perform the Dclk programming.
+ */
+void dce110_set_display_clock(struct validate_context *context)
+{
+	/* Program the display engine clock.
+	 * Check DFS bypass mode support or not. DFSbypass feature is only when
+	 * BIOS GPU info table reports support. */
+
+	if (/*dal_adapter_service_is_dfs_bypass_enabled()*/ false) {
+		/*TODO: set_display_clock_dfs_bypass(
+				hws,
+				path_set,
+				context->res_ctx.pool->display_clock,
+				context->res_ctx.min_clocks.min_dclk_khz);*/
+	} else {
+		/*
+		 * TODO: need to either port work around from DAL2 function
+		 * getActualRequiredDisplayClock or program displayclock without
+		 * calling vbios. Currently temporily work
+		 * around by increasing the displclk by 15 percent
+		 */
+		dal_display_clock_set_clock(
+				context->res_ctx.pool->display_clock,
+				context->bw_results.dispclk_khz * 115 / 100);
+	}
+
+
+	/* TODO: When changing display engine clock, DMCU WaitLoop must be
+	 * reconfigured in order to maintain the same delays within DMCU
+	 * programming sequences. */
+}
+
+static uint32_t compute_pstate_blackout_duration(
+	struct bw_fixed blackout_duration,
+	const struct core_stream *stream)
+{
+	uint32_t total_dest_line_time_ns;
+	uint32_t pstate_blackout_duration_ns;
+
+	pstate_blackout_duration_ns = 1000 * blackout_duration.value >> 24;
+
+	total_dest_line_time_ns = 1000000UL *
+		stream->public.timing.h_total /
+		stream->public.timing.pix_clk_khz +
+		pstate_blackout_duration_ns;
+
+	return total_dest_line_time_ns;
+}
+
+/* get the index of the pipe_ctx if there were no gaps in the pipe_ctx array*/
+int get_bw_result_idx(
+		struct resource_context *res_ctx,
+		int pipe_idx)
+{
+	int i, collapsed_idx;
+
+	if (res_ctx->pipe_ctx[pipe_idx].top_pipe)
+		return 3;
+
+	collapsed_idx = 0;
+	for (i = 0; i < pipe_idx; i++) {
+		if (res_ctx->pipe_ctx[i].stream)
+			collapsed_idx++;
+	}
+
+	return collapsed_idx;
+}
+
+static bool is_watermark_set_a_greater(
+		const struct bw_watermarks *set_a,
+		const struct bw_watermarks *set_b)
+{
+	if (set_a->a_mark > set_b->a_mark
+			|| set_a->b_mark > set_b->b_mark
+			|| set_a->c_mark > set_b->c_mark
+			|| set_a->d_mark > set_b->d_mark)
+		return true;
+	return false;
+}
+
+static bool did_watermarks_increase(
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context,
+		struct validate_context *old_context)
+{
+	int collapsed_pipe_idx = get_bw_result_idx(&context->res_ctx,
+			pipe_ctx->pipe_idx);
+	int old_collapsed_pipe_idx = get_bw_result_idx(&old_context->res_ctx,
+			pipe_ctx->pipe_idx);
+	struct pipe_ctx *old_pipe_ctx =  &old_context->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
+
+	if (!old_pipe_ctx->stream)
+		return true;
+
+	if (is_watermark_set_a_greater(
+			&context->bw_results.nbp_state_change_wm_ns[collapsed_pipe_idx],
+			&old_context->bw_results.nbp_state_change_wm_ns[old_collapsed_pipe_idx]))
+		return true;
+	if (is_watermark_set_a_greater(
+			&context->bw_results.stutter_exit_wm_ns[collapsed_pipe_idx],
+			&old_context->bw_results.stutter_exit_wm_ns[old_collapsed_pipe_idx]))
+		return true;
+	if (is_watermark_set_a_greater(
+			&context->bw_results.urgent_wm_ns[collapsed_pipe_idx],
+			&old_context->bw_results.urgent_wm_ns[old_collapsed_pipe_idx]))
+		return true;
+
+	return false;
+}
+
+static void program_wm_for_pipe(struct core_dc *dc,
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context)
+{
+	int total_dest_line_time_ns = compute_pstate_blackout_duration(
+			dc->bw_vbios.blackout_duration,
+			pipe_ctx->stream);
+	int bw_result_idx = get_bw_result_idx(&context->res_ctx,
+				pipe_ctx->pipe_idx);
+
+	pipe_ctx->mi->funcs->mem_input_program_display_marks(
+		pipe_ctx->mi,
+		context->bw_results.nbp_state_change_wm_ns[bw_result_idx],
+		context->bw_results.stutter_exit_wm_ns[bw_result_idx],
+		context->bw_results.urgent_wm_ns[bw_result_idx],
+		total_dest_line_time_ns);
+
+	if (pipe_ctx->top_pipe)
+		pipe_ctx->mi->funcs->mem_input_program_chroma_display_marks(
+				pipe_ctx->mi,
+				context->bw_results.nbp_state_change_wm_ns[bw_result_idx + 1],
+				context->bw_results.stutter_exit_wm_ns[bw_result_idx + 1],
+				context->bw_results.urgent_wm_ns[bw_result_idx + 1],
+				total_dest_line_time_ns);
+}
+
+void dce110_set_displaymarks(
+	const struct core_dc *dc,
+	struct validate_context *context)
+{
+	uint8_t i, num_pipes;
+	unsigned int underlay_idx = dc->res_pool->underlay_pipe_index;
+
+	for (i = 0, num_pipes = 0; i < MAX_PIPES; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+		uint32_t total_dest_line_time_ns;
+
+		if (pipe_ctx->stream == NULL)
+			continue;
+
+		total_dest_line_time_ns = compute_pstate_blackout_duration(
+			dc->bw_vbios.blackout_duration, pipe_ctx->stream);
+		pipe_ctx->mi->funcs->mem_input_program_display_marks(
+			pipe_ctx->mi,
+			context->bw_results.nbp_state_change_wm_ns[num_pipes],
+			context->bw_results.stutter_exit_wm_ns[num_pipes],
+			context->bw_results.urgent_wm_ns[num_pipes],
+			total_dest_line_time_ns);
+		if (i == underlay_idx) {
+			num_pipes++;
+			pipe_ctx->mi->funcs->mem_input_program_chroma_display_marks(
+				pipe_ctx->mi,
+				context->bw_results.nbp_state_change_wm_ns[num_pipes],
+				context->bw_results.stutter_exit_wm_ns[num_pipes],
+				context->bw_results.urgent_wm_ns[num_pipes],
+				total_dest_line_time_ns);
+		}
+		num_pipes++;
+	}
+}
+
+static void set_safe_displaymarks(struct resource_context *res_ctx)
+{
+	int i;
+	int underlay_idx = res_ctx->pool->underlay_pipe_index;
+	struct bw_watermarks max_marks = {
+		MAX_WATERMARK, MAX_WATERMARK, MAX_WATERMARK, MAX_WATERMARK };
+	struct bw_watermarks nbp_marks = {
+		SAFE_NBP_MARK, SAFE_NBP_MARK, SAFE_NBP_MARK, SAFE_NBP_MARK };
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (res_ctx->pipe_ctx[i].stream == NULL)
+			continue;
+
+		res_ctx->pipe_ctx[i].mi->funcs->mem_input_program_display_marks(
+				res_ctx->pipe_ctx[i].mi,
+				nbp_marks,
+				max_marks,
+				max_marks,
+				MAX_WATERMARK);
+		if (i == underlay_idx)
+			res_ctx->pipe_ctx[i].mi->funcs->mem_input_program_chroma_display_marks(
+				res_ctx->pipe_ctx[i].mi,
+				nbp_marks,
+				max_marks,
+				max_marks,
+				MAX_WATERMARK);
+	}
+}
+
+static void switch_dp_clock_sources(
+	const struct core_dc *dc,
+	struct resource_context *res_ctx)
+{
+	uint8_t i;
+	for (i = 0; i < MAX_PIPES; i++) {
+		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
+
+		if (pipe_ctx->stream == NULL || pipe_ctx->top_pipe)
+			continue;
+
+		if (dc_is_dp_signal(pipe_ctx->stream->signal)) {
+			struct clock_source *clk_src =
+				resource_find_used_clk_src_for_sharing(
+						res_ctx, pipe_ctx);
+
+			if (clk_src &&
+				clk_src != pipe_ctx->clock_source) {
+				resource_unreference_clock_source(
+					res_ctx, pipe_ctx->clock_source);
+				pipe_ctx->clock_source = clk_src;
+				resource_reference_clock_source(res_ctx, clk_src);
+
+				dce_crtc_switch_to_clk_src(dc->hwseq, clk_src, i);
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+ * Public functions
+ ******************************************************************************/
+
+static void reset_single_pipe_hw_ctx(
+		const struct core_dc *dc,
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context)
+{
+	core_link_disable_stream(pipe_ctx);
+	if (!pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, true)) {
+		dm_error("DC: failed to blank crtc!\n");
+		BREAK_TO_DEBUGGER();
+	}
+	pipe_ctx->tg->funcs->disable_crtc(pipe_ctx->tg);
+	pipe_ctx->mi->funcs->free_mem_input(
+				pipe_ctx->mi, context->target_count);
+	resource_unreference_clock_source(
+			&context->res_ctx, pipe_ctx->clock_source);
+
+	dc->hwss.power_down_front_end((struct core_dc *)dc, pipe_ctx);
+
+	pipe_ctx->stream = NULL;
+}
+
+static void set_drr(struct pipe_ctx **pipe_ctx,
+		int num_pipes, int vmin, int vmax)
+{
+	int i = 0;
+	struct drr_params params = {0};
+
+	params.vertical_total_max = vmax;
+	params.vertical_total_min = vmin;
+
+	/* TODO: If multiple pipes are to be supported, you need
+	 * some GSL stuff
+	 */
+
+	for (i = 0; i < num_pipes; i++) {
+		pipe_ctx[i]->tg->funcs->set_drr(pipe_ctx[i]->tg, &params);
+	}
+}
+
+static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
+		int num_pipes, int value)
+{
+	unsigned int i;
+
+	for (i = 0; i < num_pipes; i++)
+		pipe_ctx[i]->tg->funcs->
+			set_static_screen_control(pipe_ctx[i]->tg, value);
+}
+
+/* unit: in_khz before mode set, get pixel clock from context. ASIC register
+ * may not be programmed yet.
+ * TODO: after mode set, pre_mode_set = false,
+ * may read PLL register to get pixel clock
+ */
+static uint32_t get_max_pixel_clock_for_all_paths(
+	struct core_dc *dc,
+	struct validate_context *context,
+	bool pre_mode_set)
+{
+	uint32_t max_pix_clk = 0;
+	int i;
+
+	if (!pre_mode_set) {
+		/* TODO: read ASIC register to get pixel clock */
+		ASSERT(0);
+	}
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (pipe_ctx->stream == NULL)
+			continue;
+
+		/* do not check under lay */
+		if (pipe_ctx->top_pipe)
+			continue;
+
+		if (pipe_ctx->pix_clk_params.requested_pix_clk > max_pix_clk)
+			max_pix_clk =
+				pipe_ctx->pix_clk_params.requested_pix_clk;
+	}
+
+	if (max_pix_clk == 0)
+		ASSERT(0);
+
+	return max_pix_clk;
+}
+
+/*
+ * Find clock state based on clock requested. if clock value is 0, simply
+ * set clock state as requested without finding clock state by clock value
+ */
+static void apply_min_clocks(
+	struct core_dc *dc,
+	struct validate_context *context,
+	enum clocks_state *clocks_state,
+	bool pre_mode_set)
+{
+	struct state_dependent_clocks req_clocks = {0};
+	struct pipe_ctx *pipe_ctx;
+	int i;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		pipe_ctx = &context->res_ctx.pipe_ctx[i];
+		if (pipe_ctx->dis_clk != NULL)
+			break;
+	}
+
+	if (!pre_mode_set) {
+		/* set clock_state without verification */
+		if (dal_display_clock_set_min_clocks_state(
+				pipe_ctx->dis_clk, *clocks_state))
+			return;
+
+		/* TODOFPGA */
+	}
+
+	/* get the required state based on state dependent clocks:
+	 * display clock and pixel clock
+	 */
+	req_clocks.display_clk_khz = context->bw_results.dispclk_khz;
+
+	req_clocks.pixel_clk_khz = get_max_pixel_clock_for_all_paths(
+			dc, context, true);
+
+	if (dal_display_clock_get_required_clocks_state(
+				pipe_ctx->dis_clk, &req_clocks, clocks_state)) {
+		dal_display_clock_set_min_clocks_state(
+			pipe_ctx->dis_clk, *clocks_state);
+	} else {
+	}
+}
+
+static enum dc_status apply_ctx_to_hw_fpga(
+		struct core_dc *dc,
+		struct validate_context *context)
+{
+	enum dc_status status = DC_ERROR_UNEXPECTED;
+	int i;
+
+	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx_old =
+				&dc->current_context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (pipe_ctx->stream == NULL)
+			continue;
+
+		if (pipe_ctx->stream == pipe_ctx_old->stream)
+			continue;
+
+		status = apply_single_controller_ctx_to_hw(
+				pipe_ctx,
+				context,
+				dc);
+
+		if (status != DC_OK)
+			return status;
+	}
+
+	return DC_OK;
+}
+
+static void reset_hw_ctx_wrap(
+		struct core_dc *dc,
+		struct validate_context *context)
+{
+	int i;
+
+	/* Reset old context */
+	/* look up the targets that have been removed since last commit */
+	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx_old =
+			&dc->current_context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		/* Note: We need to disable output if clock sources change,
+		 * since bios does optimization and doesn't apply if changing
+		 * PHY when not already disabled.
+		 */
+
+		/* Skip underlay pipe since it will be handled in commit surface*/
+		if (!pipe_ctx_old->stream || pipe_ctx_old->top_pipe)
+			continue;
+
+		if (!pipe_ctx->stream ||
+				pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
+			reset_single_pipe_hw_ctx(
+				dc, pipe_ctx_old, dc->current_context);
+	}
+}
+
+/*TODO: const validate_context*/
+enum dc_status dce110_apply_ctx_to_hw(
+		struct core_dc *dc,
+		struct validate_context *context)
+{
+	struct dc_bios *dcb = dc->ctx->dc_bios;
+	enum dc_status status;
+	int i;
+	bool programmed_audio_dto = false;
+	enum clocks_state clocks_state = CLOCKS_STATE_INVALID;
+
+	/* Reset old context */
+	/* look up the targets that have been removed since last commit */
+	dc->hwss.reset_hw_ctx_wrap(dc, context);
+
+	/* Skip applying if no targets */
+	if (context->target_count <= 0)
+		return DC_OK;
+
+	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
+		apply_ctx_to_hw_fpga(dc, context);
+		return DC_OK;
+	}
+
+	/* Apply new context */
+	dcb->funcs->set_scratch_critical_state(dcb, true);
+
+	/* below is for real asic only */
+	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx_old =
+					&dc->current_context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (pipe_ctx->stream == NULL || pipe_ctx->top_pipe)
+			continue;
+
+		if (pipe_ctx->stream == pipe_ctx_old->stream) {
+			if (pipe_ctx_old->clock_source != pipe_ctx->clock_source)
+				dce_crtc_switch_to_clk_src(dc->hwseq,
+						pipe_ctx->clock_source, i);
+			continue;
+		}
+
+		dc->hwss.enable_display_power_gating(
+				dc, i, dc->ctx->dc_bios,
+				PIPE_GATING_CONTROL_DISABLE);
+	}
+
+	set_safe_displaymarks(&context->res_ctx);
+	/*TODO: when pplib works*/
+	apply_min_clocks(dc, context, &clocks_state, true);
+
+	if (context->bw_results.dispclk_khz
+		> dc->current_context->bw_results.dispclk_khz)
+		dc->hwss.set_display_clock(context);
+
+	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx_old =
+					&dc->current_context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (pipe_ctx->stream == NULL)
+			continue;
+
+		if (pipe_ctx->stream == pipe_ctx_old->stream)
+			continue;
+
+		if (pipe_ctx->top_pipe)
+			continue;
+
+		if (context->res_ctx.pipe_ctx[i].audio != NULL) {
+			/* Setup audio rate clock source */
+			/* Issue:
+			* Audio lag happened on DP monitor when unplug a HDMI monitor
+			*
+			* Cause:
+			* In case of DP and HDMI connected or HDMI only, DCCG_AUDIO_DTO_SEL
+			* is set to either dto0 or dto1, audio should work fine.
+			* In case of DP connected only, DCCG_AUDIO_DTO_SEL should be dto1,
+			* set to dto0 will cause audio lag.
+			*
+			* Solution:
+			* Not optimized audio wall dto setup. When mode set, iterate pipe_ctx,
+			* find first available pipe with audio, setup audio wall DTO per topology
+			* instead of per pipe.
+			*/
+			struct audio_output audio_output;
+			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+			build_audio_output(pipe_ctx, &audio_output);
+
+			if (dc_is_dp_signal(pipe_ctx->stream->signal))
+				pipe_ctx->stream_enc->funcs->dp_audio_setup(
+						pipe_ctx->stream_enc,
+						pipe_ctx->audio->inst,
+						&pipe_ctx->stream->public.audio_info);
+			else
+				pipe_ctx->stream_enc->funcs->hdmi_audio_setup(
+						pipe_ctx->stream_enc,
+						pipe_ctx->audio->inst,
+						&pipe_ctx->stream->public.audio_info,
+						&audio_output.crtc_info);
+
+			pipe_ctx->audio->funcs->az_configure(
+					pipe_ctx->audio,
+					pipe_ctx->stream->signal,
+					&audio_output.crtc_info,
+					&pipe_ctx->stream->public.audio_info);
+
+			if (!programmed_audio_dto) {
+				pipe_ctx->audio->funcs->wall_dto_setup(
+					pipe_ctx->audio,
+					pipe_ctx->stream->signal,
+					&audio_output.crtc_info,
+					&audio_output.pll_info);
+				programmed_audio_dto = true;
+			}
+		}
+
+		status = apply_single_controller_ctx_to_hw(
+				pipe_ctx,
+				context,
+				dc);
+
+		if (DC_OK != status)
+			return status;
+	}
+
+	dc->hwss.set_displaymarks(dc, context);
+
+	/* to save power */
+	apply_min_clocks(dc, context, &clocks_state, false);
+
+	dcb->funcs->set_scratch_critical_state(dcb, false);
+
+	switch_dp_clock_sources(dc, &context->res_ctx);
+
+	return DC_OK;
+}
+
+/*******************************************************************************
+ * Front End programming
+ ******************************************************************************/
+static void set_default_colors(struct pipe_ctx *pipe_ctx)
+{
+	struct default_adjustment default_adjust = { 0 };
+
+	default_adjust.force_hw_default = false;
+	if (pipe_ctx->surface == NULL)
+		default_adjust.in_color_space = COLOR_SPACE_SRGB;
+	else
+		default_adjust.in_color_space =
+				pipe_ctx->surface->public.color_space;
+	if (pipe_ctx->stream == NULL)
+		default_adjust.out_color_space = COLOR_SPACE_SRGB;
+	else
+		default_adjust.out_color_space =
+				pipe_ctx->stream->public.output_color_space;
+	default_adjust.csc_adjust_type = GRAPHICS_CSC_ADJUST_TYPE_SW;
+	default_adjust.surface_pixel_format = pipe_ctx->scl_data.format;
+
+	/* display color depth */
+	default_adjust.color_depth =
+		pipe_ctx->stream->public.timing.display_color_depth;
+
+	/* Lb color depth */
+	default_adjust.lb_color_depth = pipe_ctx->scl_data.lb_params.depth;
+
+	pipe_ctx->opp->funcs->opp_set_csc_default(
+					pipe_ctx->opp, &default_adjust);
+}
+
+static void program_blender(const struct core_dc *dc,
+		struct pipe_ctx *pipe_ctx)
+{
+	enum blnd_mode blender_mode = BLND_MODE_CURRENT_PIPE;
+
+	if (pipe_ctx->bottom_pipe) {
+		if (pipe_ctx->bottom_pipe->surface->public.visible) {
+			if (pipe_ctx->surface->public.visible)
+				blender_mode = BLND_MODE_BLENDING;
+			else
+				blender_mode = BLND_MODE_OTHER_PIPE;
+		}
+	}
+	dce_set_blender_mode(dc->hwseq, pipe_ctx->pipe_idx, blender_mode);
+}
+
+/**
+ * TODO REMOVE, USE UPDATE INSTEAD
+ */
+static void set_plane_config(
+	const struct core_dc *dc,
+	struct pipe_ctx *pipe_ctx,
+	struct resource_context *res_ctx)
+{
+	struct mem_input *mi = pipe_ctx->mi;
+	struct core_surface *surface = pipe_ctx->surface;
+	struct xfm_grph_csc_adjustment adjust;
+	struct out_csc_color_matrix tbl_entry;
+	unsigned int i;
+
+	memset(&adjust, 0, sizeof(adjust));
+	memset(&tbl_entry, 0, sizeof(tbl_entry));
+	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
+
+	dce_enable_fe_clock(dc->hwseq, pipe_ctx->pipe_idx, true);
+
+	set_default_colors(pipe_ctx);
+	if (pipe_ctx->stream->public.csc_color_matrix.enable_adjustment
+			== true) {
+		tbl_entry.color_space =
+			pipe_ctx->stream->public.output_color_space;
+
+		for (i = 0; i < 12; i++)
+			tbl_entry.regval[i] =
+			pipe_ctx->stream->public.csc_color_matrix.matrix[i];
+
+		pipe_ctx->opp->funcs->opp_set_csc_adjustment
+				(pipe_ctx->opp, &tbl_entry);
+	}
+
+	if (pipe_ctx->stream->public.gamut_remap_matrix.enable_remap == true) {
+		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
+		adjust.temperature_matrix[0] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[0];
+		adjust.temperature_matrix[1] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[1];
+		adjust.temperature_matrix[2] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[2];
+		adjust.temperature_matrix[3] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[4];
+		adjust.temperature_matrix[4] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[5];
+		adjust.temperature_matrix[5] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[6];
+		adjust.temperature_matrix[6] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[8];
+		adjust.temperature_matrix[7] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[9];
+		adjust.temperature_matrix[8] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[10];
+	}
+
+	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
+
+	pipe_ctx->scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
+	program_scaler(dc, pipe_ctx);
+
+	program_blender(dc, pipe_ctx);
+
+	mi->funcs->mem_input_program_surface_config(
+			mi,
+			surface->public.format,
+			&surface->public.tiling_info,
+			&surface->public.plane_size,
+			surface->public.rotation,
+			NULL,
+			false);
+
+	if (dc->public.config.gpu_vm_support)
+		mi->funcs->mem_input_program_pte_vm(
+				pipe_ctx->mi,
+				surface->public.format,
+				&surface->public.tiling_info,
+				surface->public.rotation);
+}
+
+static void update_plane_addr(const struct core_dc *dc,
+		struct pipe_ctx *pipe_ctx)
+{
+	struct core_surface *surface = pipe_ctx->surface;
+
+	if (surface == NULL)
+		return;
+
+	pipe_ctx->mi->funcs->mem_input_program_surface_flip_and_addr(
+			pipe_ctx->mi,
+			&surface->public.address,
+			surface->public.flip_immediate);
+
+	surface->status.requested_address = surface->public.address;
+
+	if (surface->public.visible)
+		pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, false);
+}
+
+void dce110_update_pending_status(struct pipe_ctx *pipe_ctx)
+{
+	struct core_surface *surface = pipe_ctx->surface;
+
+	if (surface == NULL)
+		return;
+
+	surface->status.is_flip_pending =
+			pipe_ctx->mi->funcs->mem_input_is_flip_pending(
+					pipe_ctx->mi);
+
+	if (surface->status.is_flip_pending && !surface->public.visible)
+		pipe_ctx->mi->current_address = pipe_ctx->mi->request_address;
+
+	surface->status.current_address = pipe_ctx->mi->current_address;
+}
+
+void dce110_power_down(struct core_dc *dc)
+{
+	power_down_all_hw_blocks(dc);
+	disable_vga_and_power_gate_all_controllers(dc);
+}
+
+static bool wait_for_reset_trigger_to_occur(
+	struct dc_context *dc_ctx,
+	struct timing_generator *tg)
+{
+	bool rc = false;
+
+	/* To avoid endless loop we wait at most
+	 * frames_to_wait_on_triggered_reset frames for the reset to occur. */
+	const uint32_t frames_to_wait_on_triggered_reset = 10;
+	uint32_t i;
+
+	for (i = 0; i < frames_to_wait_on_triggered_reset; i++) {
+
+		if (!tg->funcs->is_counter_moving(tg)) {
+			DC_ERROR("TG counter is not moving!\n");
+			break;
+		}
+
+		if (tg->funcs->did_triggered_reset_occur(tg)) {
+			rc = true;
+			/* usually occurs at i=1 */
+			DC_SYNC_INFO("GSL: reset occurred at wait count: %d\n",
+					i);
+			break;
+		}
+
+		/* Wait for one frame. */
+		tg->funcs->wait_for_state(tg, CRTC_STATE_VACTIVE);
+		tg->funcs->wait_for_state(tg, CRTC_STATE_VBLANK);
+	}
+
+	if (false == rc)
+		DC_ERROR("GSL: Timeout on reset trigger!\n");
+
+	return rc;
+}
+
+/* Enable timing synchronization for a group of Timing Generators. */
+static void dce110_enable_timing_synchronization(
+		struct core_dc *dc,
+		int group_index,
+		int group_size,
+		struct pipe_ctx *grouped_pipes[])
+{
+	struct dc_context *dc_ctx = dc->ctx;
+	struct dcp_gsl_params gsl_params = { 0 };
+	int i;
+
+	DC_SYNC_INFO("GSL: Setting-up...\n");
+
+	/* Designate a single TG in the group as a master.
+	 * Since HW doesn't care which one, we always assign
+	 * the 1st one in the group. */
+	gsl_params.gsl_group = 0;
+	gsl_params.gsl_master = grouped_pipes[0]->tg->inst;
+
+	for (i = 0; i < group_size; i++)
+		grouped_pipes[i]->tg->funcs->setup_global_swap_lock(
+					grouped_pipes[i]->tg, &gsl_params);
+
+	/* Reset slave controllers on master VSync */
+	DC_SYNC_INFO("GSL: enabling trigger-reset\n");
+
+	for (i = 1 /* skip the master */; i < group_size; i++)
+		grouped_pipes[i]->tg->funcs->enable_reset_trigger(
+					grouped_pipes[i]->tg, gsl_params.gsl_group);
+
+
+
+	for (i = 1 /* skip the master */; i < group_size; i++) {
+		DC_SYNC_INFO("GSL: waiting for reset to occur.\n");
+		wait_for_reset_trigger_to_occur(dc_ctx, grouped_pipes[i]->tg);
+		/* Regardless of success of the wait above, remove the reset or
+		 * the driver will start timing out on Display requests. */
+		DC_SYNC_INFO("GSL: disabling trigger-reset.\n");
+		grouped_pipes[i]->tg->funcs->disable_reset_trigger(grouped_pipes[i]->tg);
+	}
+
+
+	/* GSL Vblank synchronization is a one time sync mechanism, assumption
+	 * is that the sync'ed displays will not drift out of sync over time*/
+	DC_SYNC_INFO("GSL: Restoring register states.\n");
+	for (i = 0; i < group_size; i++)
+		grouped_pipes[i]->tg->funcs->tear_down_global_swap_lock(grouped_pipes[i]->tg);
+
+	DC_SYNC_INFO("GSL: Set-up complete.\n");
+}
+
+static void init_hw(struct core_dc *dc)
+{
+	int i;
+	struct dc_bios *bp;
+	struct transform *xfm;
+
+	bp = dc->ctx->dc_bios;
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		xfm = dc->res_pool->transforms[i];
+		xfm->funcs->transform_reset(xfm);
+
+		dc->hwss.enable_display_power_gating(
+				dc, i, bp,
+				PIPE_GATING_CONTROL_INIT);
+		dc->hwss.enable_display_power_gating(
+				dc, i, bp,
+				PIPE_GATING_CONTROL_DISABLE);
+		dc->hwss.enable_display_pipe_clock_gating(
+			dc->ctx,
+			true);
+	}
+
+	dce_clock_gating_power_up(dc->hwseq, false);;
+	/***************************************/
+
+	for (i = 0; i < dc->link_count; i++) {
+		/****************************************/
+		/* Power up AND update implementation according to the
+		 * required signal (which may be different from the
+		 * default signal on connector). */
+		struct core_link *link = dc->links[i];
+		link->link_enc->funcs->hw_init(link->link_enc);
+	}
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct timing_generator *tg = dc->res_pool->timing_generators[i];
+
+		tg->funcs->disable_vga(tg);
+
+		/* Blank controller using driver code instead of
+		 * command table. */
+		tg->funcs->set_blank(tg, true);
+	}
+
+	for (i = 0; i < dc->res_pool->audio_count; i++) {
+		struct audio *audio = dc->res_pool->audios[i];
+		audio->funcs->hw_init(audio);
+	}
+}
+
+/* TODO: move this to apply_ctx_tohw some how?*/
+static void dce110_power_on_pipe_if_needed(
+		struct core_dc *dc,
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context)
+{
+	struct pipe_ctx *old_pipe_ctx = &dc->current_context->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
+	struct dc_bios *dcb = dc->ctx->dc_bios;
+	struct tg_color black_color = {0};
+
+	if (!old_pipe_ctx->stream && pipe_ctx->stream) {
+		dc->hwss.enable_display_power_gating(
+				dc,
+				pipe_ctx->pipe_idx,
+				dcb, PIPE_GATING_CONTROL_DISABLE);
+
+		/*
+		 * This is for powering on underlay, so crtc does not
+		 * need to be enabled
+		 */
+
+		pipe_ctx->tg->funcs->program_timing(pipe_ctx->tg,
+				&pipe_ctx->stream->public.timing,
+				false);
+
+		pipe_ctx->tg->funcs->enable_advanced_request(
+				pipe_ctx->tg,
+				true,
+				&pipe_ctx->stream->public.timing);
+
+		pipe_ctx->mi->funcs->allocate_mem_input(pipe_ctx->mi,
+				pipe_ctx->stream->public.timing.h_total,
+				pipe_ctx->stream->public.timing.v_total,
+				pipe_ctx->stream->public.timing.pix_clk_khz,
+				context->target_count);
+
+		/* TODO unhardcode*/
+		color_space_to_black_color(dc,
+				COLOR_SPACE_YCBCR601, &black_color);
+		pipe_ctx->tg->funcs->set_blank_color(
+				pipe_ctx->tg,
+				&black_color);
+	}
+}
+
+static void dce110_increase_watermarks_for_pipe(
+		struct core_dc *dc,
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context)
+{
+	if (did_watermarks_increase(pipe_ctx, context, dc->current_context))
+		program_wm_for_pipe(dc, pipe_ctx, context);
+}
+
+static void dce110_set_bandwidth(struct core_dc *dc)
+{
+	int i;
+
+	for (i = 0; i < dc->current_context->res_ctx.pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &dc->current_context->res_ctx.pipe_ctx[i];
+
+		if (!pipe_ctx->stream)
+			continue;
+
+		program_wm_for_pipe(dc, pipe_ctx, dc->current_context);
+	}
+
+	dc->hwss.set_display_clock(dc->current_context);
+}
+
+static void dce110_program_front_end_for_pipe(
+		struct core_dc *dc, struct pipe_ctx *pipe_ctx)
+{
+	struct mem_input *mi = pipe_ctx->mi;
+	struct pipe_ctx *old_pipe = NULL;
+	struct core_surface *surface = pipe_ctx->surface;
+	struct xfm_grph_csc_adjustment adjust;
+	struct out_csc_color_matrix tbl_entry;
+	unsigned int i;
+
+	memset(&tbl_entry, 0, sizeof(tbl_entry));
+
+	if (dc->current_context)
+		old_pipe = &dc->current_context->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
+
+	memset(&adjust, 0, sizeof(adjust));
+	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
+
+	dce_enable_fe_clock(dc->hwseq, pipe_ctx->pipe_idx, true);
+
+	set_default_colors(pipe_ctx);
+	if (pipe_ctx->stream->public.csc_color_matrix.enable_adjustment
+			== true) {
+		tbl_entry.color_space =
+			pipe_ctx->stream->public.output_color_space;
+
+		for (i = 0; i < 12; i++)
+			tbl_entry.regval[i] =
+			pipe_ctx->stream->public.csc_color_matrix.matrix[i];
+
+		pipe_ctx->opp->funcs->opp_set_csc_adjustment
+				(pipe_ctx->opp, &tbl_entry);
+	}
+
+	if (pipe_ctx->stream->public.gamut_remap_matrix.enable_remap == true) {
+		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
+		adjust.temperature_matrix[0] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[0];
+		adjust.temperature_matrix[1] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[1];
+		adjust.temperature_matrix[2] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[2];
+		adjust.temperature_matrix[3] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[4];
+		adjust.temperature_matrix[4] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[5];
+		adjust.temperature_matrix[5] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[6];
+		adjust.temperature_matrix[6] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[8];
+		adjust.temperature_matrix[7] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[9];
+		adjust.temperature_matrix[8] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[10];
+	}
+
+	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
+
+	pipe_ctx->scl_data.lb_params.alpha_en = pipe_ctx->bottom_pipe != 0;
+	if (old_pipe && memcmp(&old_pipe->scl_data,
+				&pipe_ctx->scl_data,
+				sizeof(struct scaler_data)) != 0)
+		program_scaler(dc, pipe_ctx);
+
+	mi->funcs->mem_input_program_surface_config(
+			mi,
+			surface->public.format,
+			&surface->public.tiling_info,
+			&surface->public.plane_size,
+			surface->public.rotation,
+			false,
+			false);
+
+	if (dc->public.config.gpu_vm_support)
+		mi->funcs->mem_input_program_pte_vm(
+				pipe_ctx->mi,
+				surface->public.format,
+				&surface->public.tiling_info,
+				surface->public.rotation);
+
+	dm_logger_write(dc->ctx->logger, LOG_SURFACE,
+			"Pipe:%d 0x%x: addr hi:0x%x, "
+			"addr low:0x%x, "
+			"src: %d, %d, %d,"
+			" %d; dst: %d, %d, %d, %d;"
+			"clip: %d, %d, %d, %d\n",
+			pipe_ctx->pipe_idx,
+			pipe_ctx->surface,
+			pipe_ctx->surface->public.address.grph.addr.high_part,
+			pipe_ctx->surface->public.address.grph.addr.low_part,
+			pipe_ctx->surface->public.src_rect.x,
+			pipe_ctx->surface->public.src_rect.y,
+			pipe_ctx->surface->public.src_rect.width,
+			pipe_ctx->surface->public.src_rect.height,
+			pipe_ctx->surface->public.dst_rect.x,
+			pipe_ctx->surface->public.dst_rect.y,
+			pipe_ctx->surface->public.dst_rect.width,
+			pipe_ctx->surface->public.dst_rect.height,
+			pipe_ctx->surface->public.clip_rect.x,
+			pipe_ctx->surface->public.clip_rect.y,
+			pipe_ctx->surface->public.clip_rect.width,
+			pipe_ctx->surface->public.clip_rect.height);
+
+	dm_logger_write(dc->ctx->logger, LOG_SURFACE,
+			"Pipe %d: width, height, x, y\n"
+			"viewport:%d, %d, %d, %d\n"
+			"recout:  %d, %d, %d, %d\n",
+			pipe_ctx->pipe_idx,
+			pipe_ctx->scl_data.viewport.width,
+			pipe_ctx->scl_data.viewport.height,
+			pipe_ctx->scl_data.viewport.x,
+			pipe_ctx->scl_data.viewport.y,
+			pipe_ctx->scl_data.recout.width,
+			pipe_ctx->scl_data.recout.height,
+			pipe_ctx->scl_data.recout.x,
+			pipe_ctx->scl_data.recout.y);
+}
+
+
+
+static void dce110_prepare_pipe_for_surface_commit(
+		struct core_dc *dc,
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context) {
+	struct core_gamma *gamma = NULL;
+
+	dc->hwss.increase_watermarks_for_pipe(dc, pipe_ctx, context);
+
+	if (pipe_ctx->surface->public.gamma_correction)
+		gamma = DC_GAMMA_TO_CORE(
+			pipe_ctx->surface->public.gamma_correction);
+
+	dc->hwss.set_gamma_correction(
+			pipe_ctx->ipp,
+			pipe_ctx->opp,
+			gamma, pipe_ctx->surface);
+}
+
+static void dce110_prepare_pipe_for_context(
+		struct core_dc *dc,
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context)
+{
+	dce110_power_on_pipe_if_needed(dc, pipe_ctx, context);
+	dce110_prepare_pipe_for_surface_commit(dc, pipe_ctx, context);
+}
+
+static void dce110_apply_ctx_for_surface(
+		struct core_dc *dc,
+		struct core_surface *surface,
+		struct validate_context *context)
+{
+	int i;
+
+	/* TODO remove when removing the surface reset workaroud*/
+	if (!surface)
+		return;
+
+	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (pipe_ctx->surface != surface)
+			continue;
+
+		dce110_program_front_end_for_pipe(dc, pipe_ctx);
+		program_blender(dc, pipe_ctx);
+
+	}
+
+}
+
+static void dce110_power_down_fe(struct core_dc *dc, struct pipe_ctx *pipe)
+{
+	int i;
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++)
+		if (&dc->current_context->res_ctx.pipe_ctx[i] == pipe)
+			break;
+
+	if (i == dc->res_pool->pipe_count)
+		return;
+
+	dc->hwss.enable_display_power_gating(
+		dc, i, dc->ctx->dc_bios, PIPE_GATING_CONTROL_ENABLE);
+	if (pipe->xfm)
+		pipe->xfm->funcs->transform_reset(pipe->xfm);
+	memset(&pipe->scl_data, 0, sizeof(struct scaler_data));
+}
+
+static const struct hw_sequencer_funcs dce110_funcs = {
+	.init_hw = init_hw,
+	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
+	.prepare_pipe_for_context = dce110_prepare_pipe_for_context,
+	.apply_ctx_for_surface = dce110_apply_ctx_for_surface,
+	.set_plane_config = set_plane_config,
+	.update_plane_addr = update_plane_addr,
+	.update_pending_status = dce110_update_pending_status,
+	.set_gamma_correction = set_gamma_ramp,
+	.power_down = dce110_power_down,
+	.enable_accelerated_mode = dce110_enable_accelerated_mode,
+	.enable_timing_synchronization = dce110_enable_timing_synchronization,
+	.update_info_frame = dce110_update_info_frame,
+	.enable_stream = dce110_enable_stream,
+	.disable_stream = dce110_disable_stream,
+	.unblank_stream = dce110_unblank_stream,
+	.enable_display_pipe_clock_gating = enable_display_pipe_clock_gating,
+	.enable_display_power_gating = dce110_enable_display_power_gating,
+	.power_down_front_end = dce110_power_down_fe,
+	.pipe_control_lock = dce_pipe_control_lock,
+	.set_display_clock = dce110_set_display_clock,
+	.set_displaymarks = dce110_set_displaymarks,
+	.increase_watermarks_for_pipe = dce110_increase_watermarks_for_pipe,
+	.set_bandwidth = dce110_set_bandwidth,
+	.set_drr = set_drr,
+	.set_static_screen_control = set_static_screen_control,
+	.reset_hw_ctx_wrap = reset_hw_ctx_wrap,
+	.prog_pixclk_crtc_otg = prog_pixclk_crtc_otg,
+};
+
+bool dce110_hw_sequencer_construct(struct core_dc *dc)
+{
+	dc->hwss = dce110_funcs;
+
+	return true;
+}
+
