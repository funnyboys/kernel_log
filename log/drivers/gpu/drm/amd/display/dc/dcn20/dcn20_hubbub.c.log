commit 89e94bc57429305e089f149a6e7083e5f36f39c4
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Feb 14 12:55:55 2020 -0500

    drm/amd/display: optimize prgoram wm and clks
    
    [Why]
    In some display configuration like 1080P monitor playing a 1080P video,
    if user use ALT+F4 to exit Movie and TV, there is a chance clocks are
    same only water mark changed. Current clock optimization machanism will
    result in water mark keeps high after exit Movie and TV app.
    
    [How]
    Return if watermark need to be optimized when doing program watermark,
    perform the optimization after.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
index 9235f7d29454..c0b21d7450d4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
@@ -562,19 +562,23 @@ void hubbub2_get_dchub_ref_freq(struct hubbub *hubbub,
 	}
 }
 
-static void hubbub2_program_watermarks(
+static bool hubbub2_program_watermarks(
 		struct hubbub *hubbub,
 		struct dcn_watermark_set *watermarks,
 		unsigned int refclk_mhz,
 		bool safe_to_lower)
 {
 	struct dcn20_hubbub *hubbub1 = TO_DCN20_HUBBUB(hubbub);
+	bool wm_pending = false;
 	/*
 	 * Need to clamp to max of the register values (i.e. no wrap)
 	 * for dcn1, all wm registers are 21-bit wide
 	 */
-	hubbub1_program_urgent_watermarks(hubbub, watermarks, refclk_mhz, safe_to_lower);
-	hubbub1_program_stutter_watermarks(hubbub, watermarks, refclk_mhz, safe_to_lower);
+	if (hubbub1_program_urgent_watermarks(hubbub, watermarks, refclk_mhz, safe_to_lower))
+		wm_pending = true;
+
+	if (hubbub1_program_stutter_watermarks(hubbub, watermarks, refclk_mhz, safe_to_lower))
+		wm_pending = true;
 
 	/*
 	 * There's a special case when going from p-state support to p-state unsupported
@@ -592,6 +596,7 @@ static void hubbub2_program_watermarks(
 	REG_UPDATE(DCHUBBUB_ARB_DF_REQ_OUTSTAND, DCHUBBUB_ARB_MIN_REQ_OUTSTAND, 180);
 
 	hubbub->funcs->allow_self_refresh_control(hubbub, !hubbub->ctx->dc->debug.disable_stutter);
+	return wm_pending;
 }
 
 static const struct hubbub_funcs hubbub2_funcs = {

commit d905c33a43dc8014e21e2445ae16ee79e562b91f
Author: Chris Park <Chris.Park@amd.com>
Date:   Fri Dec 20 15:30:05 2019 -0500

    drm/amd/display: Add default switch case for DCC
    
    Signed-off-by: Chris Park <Chris.Park@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
index 836af0f2bbda..9235f7d29454 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
@@ -293,6 +293,9 @@ bool hubbub2_get_dcc_compression_cap(struct hubbub *hubbub,
 		output->grph.rgb.max_compressed_blk_size = 64;
 		output->grph.rgb.independent_64b_blks = true;
 		break;
+	default:
+		ASSERT(false);
+		break;
 	}
 	output->capable = true;
 	output->const_color_support = true;

commit 87f24027728f268fdf8669984f0afba599731717
Author: Martin Leung <martin.leung@amd.com>
Date:   Wed Dec 11 14:59:36 2019 -0500

    drm/amd/display: Adding forgotten hubbub func
    
    [why]
    While doing seamless boot I made some changes
    to dcn2 hubbub functions, missed a link
    
    [how]
    link hubbub1 func to hubbub2 usage. It has already
    been successfully linked in dcn1 and 3.
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Alvin Lee <Alvin.Lee2@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
index 8b8438566101..836af0f2bbda 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
@@ -601,7 +601,8 @@ static const struct hubbub_funcs hubbub2_funcs = {
 	.wm_read_state = hubbub2_wm_read_state,
 	.get_dchub_ref_freq = hubbub2_get_dchub_ref_freq,
 	.program_watermarks = hubbub2_program_watermarks,
-	.allow_self_refresh_control = hubbub1_allow_self_refresh_control
+	.is_allow_self_refresh_enabled = hubbub1_is_allow_self_refresh_enabled,
+	.allow_self_refresh_control = hubbub1_allow_self_refresh_control,
 };
 
 void hubbub2_construct(struct dcn20_hubbub *hubbub,

commit ec4388a267e09061ca401eb7c2dcf104385c1a65
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Sep 3 14:10:28 2019 -0400

    drm/amd/display: Add detile buffer size for DCN20
    
    Detile buffer size affects dcc caps and therefore needs to be
    corrected for each ip.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Chris Park <Chris.Park@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
index e0a6e30ac3e1..8b8438566101 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
@@ -186,14 +186,13 @@ static void hubbub2_get_blk256_size(unsigned int *blk256_width, unsigned int *bl
 }
 
 static void hubbub2_det_request_size(
+		unsigned int detile_buf_size,
 		unsigned int height,
 		unsigned int width,
 		unsigned int bpe,
 		bool *req128_horz_wc,
 		bool *req128_vert_wc)
 {
-	unsigned int detile_buf_size = 164 * 1024;  /* 164KB for DCN1.0 */
-
 	unsigned int blk256_height = 0;
 	unsigned int blk256_width = 0;
 	unsigned int swath_bytes_horz_wc, swath_bytes_vert_wc;
@@ -236,7 +235,8 @@ bool hubbub2_get_dcc_compression_cap(struct hubbub *hubbub,
 			&segment_order_horz, &segment_order_vert))
 		return false;
 
-	hubbub2_det_request_size(input->surface_size.height,  input->surface_size.width,
+	hubbub2_det_request_size(TO_DCN20_HUBBUB(hubbub)->detile_buf_size,
+			input->surface_size.height,  input->surface_size.width,
 			bpe, &req128_horz_wc, &req128_vert_wc);
 
 	if (!req128_horz_wc && !req128_vert_wc) {
@@ -619,4 +619,5 @@ void hubbub2_construct(struct dcn20_hubbub *hubbub,
 	hubbub->masks = hubbub_mask;
 
 	hubbub->debug_test_index_pstate = 0xB;
+	hubbub->detile_buf_size = 164 * 1024; /* 164KB for DCN2.0 */
 }

commit 7f7652ee8c8c1c21a1493171bb9996759edb8d46
Author: Martin Leung <martin.leung@amd.com>
Date:   Fri Aug 16 17:26:23 2019 -0400

    drm/amd/display: enable single dp seamless boot
    
    [why]
    seamless boot didn't work for non edp's before
    
    [how]
    removed edp-specific code, made dp read uefi-set link settings. Also fixed
    a hubbub code line to be consistent with usage of function.
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
index b83c022e2c6f..e0a6e30ac3e1 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
@@ -588,7 +588,7 @@ static void hubbub2_program_watermarks(
 			DCHUBBUB_ARB_SAT_LEVEL, 60 * refclk_mhz);
 	REG_UPDATE(DCHUBBUB_ARB_DF_REQ_OUTSTAND, DCHUBBUB_ARB_MIN_REQ_OUTSTAND, 180);
 
-	hubbub1_allow_self_refresh_control(hubbub, !hubbub->ctx->dc->debug.disable_stutter);
+	hubbub->funcs->allow_self_refresh_control(hubbub, !hubbub->ctx->dc->debug.disable_stutter);
 }
 
 static const struct hubbub_funcs hubbub2_funcs = {
@@ -600,7 +600,8 @@ static const struct hubbub_funcs hubbub2_funcs = {
 	.get_dcc_compression_cap = hubbub2_get_dcc_compression_cap,
 	.wm_read_state = hubbub2_wm_read_state,
 	.get_dchub_ref_freq = hubbub2_get_dchub_ref_freq,
-	.program_watermarks = hubbub2_program_watermarks
+	.program_watermarks = hubbub2_program_watermarks,
+	.allow_self_refresh_control = hubbub1_allow_self_refresh_control
 };
 
 void hubbub2_construct(struct dcn20_hubbub *hubbub,

commit ee80de548b47940d4519dbf9f9388a179e99d91a
Author: Jaehyun Chung <jaehyun.chung@amd.com>
Date:   Mon Jul 29 14:48:32 2019 -0400

    drm/amd/display: Add VM page fault handle implementation
    
    [How] Allocate memory for default page and program memory block addr
    into default page addr register.
    
    Signed-off-by: Jaehyun Chung <jaehyun.chung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
index f13e039f8ef4..b83c022e2c6f 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
@@ -380,6 +380,11 @@ int hubbub2_init_dchub_sys_ctx(struct hubbub *hubbub,
 	REG_SET(DCN_VM_AGP_BASE, 0,
 			AGP_BASE, pa_config->system_aperture.agp_base >> 24);
 
+	REG_SET(DCN_VM_PROTECTION_FAULT_DEFAULT_ADDR_MSB, 0,
+			DCN_VM_PROTECTION_FAULT_DEFAULT_ADDR_MSB, (pa_config->page_table_default_page_addr >> 44) & 0xF);
+	REG_SET(DCN_VM_PROTECTION_FAULT_DEFAULT_ADDR_LSB, 0,
+			DCN_VM_PROTECTION_FAULT_DEFAULT_ADDR_LSB, (pa_config->page_table_default_page_addr >> 12) & 0xFFFFFFFF);
+
 	if (pa_config->gart_config.page_table_start_addr != pa_config->gart_config.page_table_end_addr) {
 		phys_config.page_table_start_addr = pa_config->gart_config.page_table_start_addr >> 12;
 		phys_config.page_table_end_addr = pa_config->gart_config.page_table_end_addr >> 12;

commit 5fc43055b03fabe7bc86ed890636f449e6353c6a
Author: Julian Parkin <julian.parkin@amd.com>
Date:   Mon Jul 15 12:16:01 2019 -0400

    drm/amd/display: Remove duplicate interface for programming FB
    
    [Why]
    There are currently two interfaces for exactly the same thing:
    hupb_update_dchub in hupb and update_dchub in hubbub. The hubbub
    version is currently unused past dcn10, largely because the call
    from the dcn10 hardware sequencer does not call through the
    interface, so the hupb interface was used instead. This is
    confusing because of the duplicate code, the unused functions,
    and the fact that more that one block currently owns this set
    of registers.
    
    [How]
    Remove the hubp interface entirely, as well as the register
    declarations that are not longer needed because of this. Change
    the call site to always call the hubbub version through the
    interface. Fix the update_dchub function in dcn20_hubbub.c to
    program the correct registers for dcn20.
    
    Signed-off-by: Julian Parkin <julian.parkin@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
index cd101bbd8163..f13e039f8ef4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
@@ -398,54 +398,67 @@ void hubbub2_update_dchub(struct hubbub *hubbub,
 {
 	struct dcn20_hubbub *hubbub1 = TO_DCN20_HUBBUB(hubbub);
 
-	if (REG(DCHUBBUB_SDPIF_FB_TOP) == 0) {
-		ASSERT(false);
-		/*should not come here*/
+	if (REG(DCN_VM_FB_LOCATION_TOP) == 0)
 		return;
-	}
-	/* TODO: port code from dal2 */
+
 	switch (dh_data->fb_mode) {
 	case FRAME_BUFFER_MODE_ZFB_ONLY:
 		/*For ZFB case need to put DCHUB FB BASE and TOP upside down to indicate ZFB mode*/
-		REG_UPDATE(DCHUBBUB_SDPIF_FB_TOP,
-				SDPIF_FB_TOP, 0);
-
-		REG_UPDATE(DCHUBBUB_SDPIF_FB_BASE,
-				SDPIF_FB_BASE, 0x0FFFF);
-
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,
-				SDPIF_AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
-
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,
-				SDPIF_AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
-
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,
-				SDPIF_AGP_TOP, (dh_data->zfb_mc_base_addr +
-						dh_data->zfb_size_in_byte - 1) >> 22);
+		REG_UPDATE(DCN_VM_FB_LOCATION_TOP,
+				FB_TOP, 0);
+
+		REG_UPDATE(DCN_VM_FB_LOCATION_BASE,
+				FB_BASE, 0xFFFFFF);
+
+		/*This field defines the 24 MSBs, bits [47:24] of the 48 bit AGP Base*/
+		REG_UPDATE(DCN_VM_AGP_BASE,
+				AGP_BASE, dh_data->zfb_phys_addr_base >> 24);
+
+		/*This field defines the bottom range of the AGP aperture and represents the 24*/
+		/*MSBs, bits [47:24] of the 48 address bits*/
+		REG_UPDATE(DCN_VM_AGP_BOT,
+				AGP_BOT, dh_data->zfb_mc_base_addr >> 24);
+
+		/*This field defines the top range of the AGP aperture and represents the 24*/
+		/*MSBs, bits [47:24] of the 48 address bits*/
+		REG_UPDATE(DCN_VM_AGP_TOP,
+				AGP_TOP, (dh_data->zfb_mc_base_addr +
+						dh_data->zfb_size_in_byte - 1) >> 24);
 		break;
 	case FRAME_BUFFER_MODE_MIXED_ZFB_AND_LOCAL:
 		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
 
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,
-				SDPIF_AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
+		/*This field defines the 24 MSBs, bits [47:24] of the 48 bit AGP Base*/
+		REG_UPDATE(DCN_VM_AGP_BASE,
+				AGP_BASE, dh_data->zfb_phys_addr_base >> 24);
 
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,
-				SDPIF_AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
+		/*This field defines the bottom range of the AGP aperture and represents the 24*/
+		/*MSBs, bits [47:24] of the 48 address bits*/
+		REG_UPDATE(DCN_VM_AGP_BOT,
+				AGP_BOT, dh_data->zfb_mc_base_addr >> 24);
 
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,
-				SDPIF_AGP_TOP, (dh_data->zfb_mc_base_addr +
-						dh_data->zfb_size_in_byte - 1) >> 22);
+		/*This field defines the top range of the AGP aperture and represents the 24*/
+		/*MSBs, bits [47:24] of the 48 address bits*/
+		REG_UPDATE(DCN_VM_AGP_TOP,
+				AGP_TOP, (dh_data->zfb_mc_base_addr +
+						dh_data->zfb_size_in_byte - 1) >> 24);
 		break;
 	case FRAME_BUFFER_MODE_LOCAL_ONLY:
-		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,
-				SDPIF_AGP_BASE, 0);
+		/*Should not touch FB LOCATION (should be done by VBIOS)*/
+
+		/*This field defines the 24 MSBs, bits [47:24] of the 48 bit AGP Base*/
+		REG_UPDATE(DCN_VM_AGP_BASE,
+				AGP_BASE, 0);
 
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,
-				SDPIF_AGP_BOT, 0X03FFFF);
+		/*This field defines the bottom range of the AGP aperture and represents the 24*/
+		/*MSBs, bits [47:24] of the 48 address bits*/
+		REG_UPDATE(DCN_VM_AGP_BOT,
+				AGP_BOT, 0xFFFFFF);
 
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,
-				SDPIF_AGP_TOP, 0);
+		/*This field defines the top range of the AGP aperture and represents the 24*/
+		/*MSBs, bits [47:24] of the 48 address bits*/
+		REG_UPDATE(DCN_VM_AGP_TOP,
+				AGP_TOP, 0);
 		break;
 	default:
 		break;

commit 8a31820b12187c7e31c52e8a00075359d9efac52
Author: Martin Leung <martin.leung@amd.com>
Date:   Tue Jul 9 15:15:17 2019 -0400

    drm/amd/display: Make init_hw and init_pipes generic for seamless boot
    
    [Why]
    For seamless boot the init_hw sequence must be split into
    actual hardware vs pipes, in order to defer pipe initialization to set mode
    and skip of pipe-destructive sequences
    
    [How]
    made dcn10_init_hw and dcn10_init_pipes generic for future dcns to inherit
    deleted dcn20 specific versions. This is part 1 of a 2 partimplementation
    of seamless boot
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
index 31d6e79ba2b8..cd101bbd8163 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
@@ -582,7 +582,7 @@ static const struct hubbub_funcs hubbub2_funcs = {
 	.get_dcc_compression_cap = hubbub2_get_dcc_compression_cap,
 	.wm_read_state = hubbub2_wm_read_state,
 	.get_dchub_ref_freq = hubbub2_get_dchub_ref_freq,
-	.program_watermarks = hubbub2_program_watermarks,
+	.program_watermarks = hubbub2_program_watermarks
 };
 
 void hubbub2_construct(struct dcn20_hubbub *hubbub,

commit 057fc695e934a77bae0c6c7f3be01251774b61cf
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Mon Jul 8 15:15:42 2019 -0400

    drm/amd/display: support "dummy pstate"
    
    [why]
    Existing support in DC for pstate only accounts for a single latency.  This is sufficient when the
    variance of latency is small, or that pstate support isn't necessary for correct ASIC functionality.
    
    Newer ASICs violate both existing assumptions.  PState support is mandatory of correct ASIC
    functionality, but not all latencies have to be supported.  Existing code supports a "full p state" which
    allows memory clock to change, but is hard for DCN to support (as it requires very large buffers).
    New code will now fall back to a "dummy p state" support when "full p state" cannot be support.
    This easy p state support should always be allowed.
    
    [how]
    Define a new latency in socBB.  Add fallback logic to support it.  Note DML is also updated to ensure
    that fallback will always work.
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
index 6e2dbd03f9bf..31d6e79ba2b8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
@@ -26,6 +26,7 @@
 
 #include "dcn20_hubbub.h"
 #include "reg_helper.h"
+#include "clk_mgr.h"
 
 #define REG(reg)\
 	hubbub1->regs->reg
@@ -553,6 +554,16 @@ static void hubbub2_program_watermarks(
 	 */
 	hubbub1_program_urgent_watermarks(hubbub, watermarks, refclk_mhz, safe_to_lower);
 	hubbub1_program_stutter_watermarks(hubbub, watermarks, refclk_mhz, safe_to_lower);
+
+	/*
+	 * There's a special case when going from p-state support to p-state unsupported
+	 * here we are going to LOWER watermarks to go to dummy p-state only, but this has
+	 * to be done prepare_bandwidth, not optimize
+	 */
+	if (hubbub1->base.ctx->dc->clk_mgr->clks.prev_p_state_change_support == true &&
+		hubbub1->base.ctx->dc->clk_mgr->clks.p_state_change_support == false)
+		safe_to_lower = true;
+
 	hubbub1_program_pstate_watermarks(hubbub, watermarks, refclk_mhz, safe_to_lower);
 
 	REG_SET(DCHUBBUB_ARB_SAT_LEVEL, 0,

commit a6f30079b8562b659e1d06f7cb1bc30951869bbc
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Jun 4 14:48:33 2019 -0400

    drm/amd/display: Set default block_size, even in unexpected cases
    
    We're not expected to enter the default case, but not returning a
    default value here is incorrect.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
index c72a9ff57f15..6e2dbd03f9bf 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
@@ -337,6 +337,7 @@ static enum dcn_hubbub_page_table_block_size page_table_block_size_to_hw(unsigne
 		break;
 	default:
 		ASSERT(false);
+		block_size = page_table_block_size;
 		break;
 	}
 

commit b48935b3bfc1350737e759fef5e92db14a2e2fbb
Author: Jun Lei <jun.lei@amd.com>
Date:   Mon Jun 3 08:13:12 2019 -0400

    drm/amd/display: fix up HUBBUB hw programming for VM
    
    [why]
    Some values were not being converted or bit-shifted properly for
    HW registers, causing black screen
    
    [how]
    Fix up the values before programming HW
    
    Signed-off-by: Jun Lei <jun.lei@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
index ece6e136437b..c72a9ff57f15 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
@@ -366,25 +366,24 @@ int hubbub2_init_dchub_sys_ctx(struct hubbub *hubbub,
 	struct dcn_vmid_page_table_config phys_config;
 
 	REG_SET(DCN_VM_FB_LOCATION_BASE, 0,
-			FB_BASE, pa_config->system_aperture.fb_base);
+			FB_BASE, pa_config->system_aperture.fb_base >> 24);
 	REG_SET(DCN_VM_FB_LOCATION_TOP, 0,
-			FB_TOP, pa_config->system_aperture.fb_top);
+			FB_TOP, pa_config->system_aperture.fb_top >> 24);
 	REG_SET(DCN_VM_FB_OFFSET, 0,
-			FB_OFFSET, pa_config->system_aperture.fb_offset);
+			FB_OFFSET, pa_config->system_aperture.fb_offset >> 24);
 	REG_SET(DCN_VM_AGP_BOT, 0,
-			AGP_BOT, pa_config->system_aperture.agp_bot);
+			AGP_BOT, pa_config->system_aperture.agp_bot >> 24);
 	REG_SET(DCN_VM_AGP_TOP, 0,
-			AGP_TOP, pa_config->system_aperture.agp_top);
+			AGP_TOP, pa_config->system_aperture.agp_top >> 24);
 	REG_SET(DCN_VM_AGP_BASE, 0,
-			AGP_BASE, pa_config->system_aperture.agp_base);
+			AGP_BASE, pa_config->system_aperture.agp_base >> 24);
 
 	if (pa_config->gart_config.page_table_start_addr != pa_config->gart_config.page_table_end_addr) {
-		phys_config.depth = 1;
-		phys_config.block_size = 4096;
 		phys_config.page_table_start_addr = pa_config->gart_config.page_table_start_addr >> 12;
 		phys_config.page_table_end_addr = pa_config->gart_config.page_table_end_addr >> 12;
 		phys_config.page_table_base_addr = pa_config->gart_config.page_table_base_addr;
-
+		phys_config.depth = 0;
+		phys_config.block_size = 0;
 		// Init VMID 0 based on PA config
 		dcn20_vmid_setup(&hubbub1->vmid[0], &phys_config);
 	}

commit bda9afdacf8942c313a47cc95582737345a91c5e
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 22 18:05:41 2019 -0400

    drm/amd/display: move vmid determination logic to a module
    
    Currently vmid is decided internally inside dc. With the introduction
    of new asics we are required to coordinate vmid use with external
    components.
    
    This change converts vmid logic to a DAL module allowing vmid to be
    passed in as a parameter to DC.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
index 724f1c5ef614..ece6e136437b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
@@ -47,6 +47,11 @@
 #define FN(reg_name, field_name) \
 	hubbub1->shifts->field_name, hubbub1->masks->field_name
 
+#ifdef NUM_VMID
+#undef NUM_VMID
+#endif
+#define NUM_VMID 16
+
 bool hubbub2_dcc_support_swizzle(
 		enum swizzle_mode_values swizzle,
 		unsigned int bytes_per_element,
@@ -294,15 +299,6 @@ bool hubbub2_get_dcc_compression_cap(struct hubbub *hubbub,
 	return true;
 }
 
-void hubbub2_setup_vmid_ptb(struct hubbub *hubbub,
-		uint64_t ptb,
-		uint8_t vmid)
-{
-	struct dcn20_hubbub *hubbub1 = TO_DCN20_HUBBUB(hubbub);
-
-	dcn20_vmid_set_ptb(&hubbub1->vmid[vmid], ptb);
-}
-
 static enum dcn_hubbub_page_table_depth page_table_depth_to_hw(unsigned int page_table_depth)
 {
 	enum dcn_hubbub_page_table_depth depth = 0;
@@ -347,49 +343,53 @@ static enum dcn_hubbub_page_table_block_size page_table_block_size_to_hw(unsigne
 	return block_size;
 }
 
-void hubbub2_init_dchub(struct hubbub *hubbub,
-		struct hubbub_addr_config *config)
+void hubbub2_init_vm_ctx(struct hubbub *hubbub,
+		struct dcn_hubbub_virt_addr_config *va_config,
+		int vmid)
 {
-	int i;
 	struct dcn20_hubbub *hubbub1 = TO_DCN20_HUBBUB(hubbub);
-	struct dcn_vmid_page_table_config phys_config;
 	struct dcn_vmid_page_table_config virt_config;
 
+	virt_config.page_table_start_addr = va_config->page_table_start_addr >> 12;
+	virt_config.page_table_end_addr = va_config->page_table_end_addr >> 12;
+	virt_config.depth = page_table_depth_to_hw(va_config->page_table_depth);
+	virt_config.block_size = page_table_block_size_to_hw(va_config->page_table_block_size);
+	virt_config.page_table_base_addr = va_config->page_table_base_addr;
+
+	dcn20_vmid_setup(&hubbub1->vmid[vmid], &virt_config);
+}
+
+int hubbub2_init_dchub_sys_ctx(struct hubbub *hubbub,
+		struct dcn_hubbub_phys_addr_config *pa_config)
+{
+	struct dcn20_hubbub *hubbub1 = TO_DCN20_HUBBUB(hubbub);
+	struct dcn_vmid_page_table_config phys_config;
+
 	REG_SET(DCN_VM_FB_LOCATION_BASE, 0,
-			FB_BASE, config->pa_config.system_aperture.fb_base);
+			FB_BASE, pa_config->system_aperture.fb_base);
 	REG_SET(DCN_VM_FB_LOCATION_TOP, 0,
-			FB_TOP, config->pa_config.system_aperture.fb_top);
+			FB_TOP, pa_config->system_aperture.fb_top);
 	REG_SET(DCN_VM_FB_OFFSET, 0,
-			FB_OFFSET, config->pa_config.system_aperture.fb_offset);
+			FB_OFFSET, pa_config->system_aperture.fb_offset);
 	REG_SET(DCN_VM_AGP_BOT, 0,
-			AGP_BOT, config->pa_config.system_aperture.agp_bot);
+			AGP_BOT, pa_config->system_aperture.agp_bot);
 	REG_SET(DCN_VM_AGP_TOP, 0,
-			AGP_TOP, config->pa_config.system_aperture.agp_top);
+			AGP_TOP, pa_config->system_aperture.agp_top);
 	REG_SET(DCN_VM_AGP_BASE, 0,
-			AGP_BASE, config->pa_config.system_aperture.agp_base);
+			AGP_BASE, pa_config->system_aperture.agp_base);
 
-	if (config->pa_config.gart_config.page_table_start_addr != config->pa_config.gart_config.page_table_end_addr) {
+	if (pa_config->gart_config.page_table_start_addr != pa_config->gart_config.page_table_end_addr) {
 		phys_config.depth = 1;
 		phys_config.block_size = 4096;
-		phys_config.page_table_start_addr = config->pa_config.gart_config.page_table_start_addr >> 12;
-		phys_config.page_table_end_addr = config->pa_config.gart_config.page_table_end_addr >> 12;
+		phys_config.page_table_start_addr = pa_config->gart_config.page_table_start_addr >> 12;
+		phys_config.page_table_end_addr = pa_config->gart_config.page_table_end_addr >> 12;
+		phys_config.page_table_base_addr = pa_config->gart_config.page_table_base_addr;
 
 		// Init VMID 0 based on PA config
 		dcn20_vmid_setup(&hubbub1->vmid[0], &phys_config);
-		dcn20_vmid_set_ptb(&hubbub1->vmid[0], config->pa_config.gart_config.page_table_base_addr);
 	}
 
-	if (config->va_config.page_table_start_addr != config->va_config.page_table_end_addr) {
-		// Init VMID 1-15 based on VA config
-		for (i = 1; i < 16; i++) {
-			virt_config.page_table_start_addr = config->va_config.page_table_start_addr >> 12;
-			virt_config.page_table_end_addr = config->va_config.page_table_end_addr >> 12;
-			virt_config.depth = page_table_depth_to_hw(config->va_config.page_table_depth);
-			virt_config.block_size = page_table_block_size_to_hw(config->va_config.page_table_block_size);
-
-			dcn20_vmid_setup(&hubbub1->vmid[i], &virt_config);
-		}
-	}
+	return NUM_VMID;
 }
 
 void hubbub2_update_dchub(struct hubbub *hubbub,
@@ -564,8 +564,8 @@ static void hubbub2_program_watermarks(
 
 static const struct hubbub_funcs hubbub2_funcs = {
 	.update_dchub = hubbub2_update_dchub,
-	.init_dchub = hubbub2_init_dchub,
-	.setup_vmid_ptb = hubbub2_setup_vmid_ptb,
+	.init_dchub_sys_ctx = hubbub2_init_dchub_sys_ctx,
+	.init_vm_ctx = hubbub2_init_vm_ctx,
 	.dcc_support_swizzle = hubbub2_dcc_support_swizzle,
 	.dcc_support_pixel_format = hubbub2_dcc_support_pixel_format,
 	.get_dcc_compression_cap = hubbub2_get_dcc_compression_cap,

commit 3979efcec6272848fca96496c53096f6ee8aa32f
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Mon May 13 15:09:13 2019 -0400

    drm/amd/display: Add missing VM conversion from hw values
    
    [why]
    VM implemenation is missing conversion from HW values in hubbub
    DM not passing actual PTB during flip
    
    [how]
    add proper HW conversion from logical values
    fix cases where we programmed VA even though we are in PA
    plumb in PTB from DM
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
index a851574f118a..724f1c5ef614 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
@@ -303,6 +303,49 @@ void hubbub2_setup_vmid_ptb(struct hubbub *hubbub,
 	dcn20_vmid_set_ptb(&hubbub1->vmid[vmid], ptb);
 }
 
+static enum dcn_hubbub_page_table_depth page_table_depth_to_hw(unsigned int page_table_depth)
+{
+	enum dcn_hubbub_page_table_depth depth = 0;
+
+	switch (page_table_depth) {
+	case 1:
+		depth = DCN_PAGE_TABLE_DEPTH_1_LEVEL;
+		break;
+	case 2:
+		depth = DCN_PAGE_TABLE_DEPTH_2_LEVEL;
+		break;
+	case 3:
+		depth = DCN_PAGE_TABLE_DEPTH_3_LEVEL;
+		break;
+	case 4:
+		depth = DCN_PAGE_TABLE_DEPTH_4_LEVEL;
+		break;
+	default:
+		ASSERT(false);
+		break;
+	}
+
+	return depth;
+}
+
+static enum dcn_hubbub_page_table_block_size page_table_block_size_to_hw(unsigned int page_table_block_size)
+{
+	enum dcn_hubbub_page_table_block_size block_size = 0;
+
+	switch (page_table_block_size) {
+	case 4096:
+		block_size = DCN_PAGE_TABLE_BLOCK_SIZE_4KB;
+		break;
+	case 65536:
+		block_size = DCN_PAGE_TABLE_BLOCK_SIZE_64KB;
+		break;
+	default:
+		ASSERT(false);
+		break;
+	}
+
+	return block_size;
+}
 
 void hubbub2_init_dchub(struct hubbub *hubbub,
 		struct hubbub_addr_config *config)
@@ -312,11 +355,6 @@ void hubbub2_init_dchub(struct hubbub *hubbub,
 	struct dcn_vmid_page_table_config phys_config;
 	struct dcn_vmid_page_table_config virt_config;
 
-	phys_config.depth = 0; // Depth 1
-	phys_config.block_size = 0; // Block size 4KB
-	phys_config.page_table_start_addr = config->pa_config.gart_config.page_table_start_addr;
-	phys_config.page_table_end_addr = config->pa_config.gart_config.page_table_end_addr;
-
 	REG_SET(DCN_VM_FB_LOCATION_BASE, 0,
 			FB_BASE, config->pa_config.system_aperture.fb_base);
 	REG_SET(DCN_VM_FB_LOCATION_TOP, 0,
@@ -330,18 +368,27 @@ void hubbub2_init_dchub(struct hubbub *hubbub,
 	REG_SET(DCN_VM_AGP_BASE, 0,
 			AGP_BASE, config->pa_config.system_aperture.agp_base);
 
-	// Init VMID 0 based on PA config
-	dcn20_vmid_setup(&hubbub1->vmid[0], &phys_config);
-	dcn20_vmid_set_ptb(&hubbub1->vmid[0], config->pa_config.gart_config.page_table_base_addr);
+	if (config->pa_config.gart_config.page_table_start_addr != config->pa_config.gart_config.page_table_end_addr) {
+		phys_config.depth = 1;
+		phys_config.block_size = 4096;
+		phys_config.page_table_start_addr = config->pa_config.gart_config.page_table_start_addr >> 12;
+		phys_config.page_table_end_addr = config->pa_config.gart_config.page_table_end_addr >> 12;
 
-	// Init VMID 1-15 based on VA config
-	for (i = 1; i < 16; i++) {
-		virt_config.page_table_start_addr = config->va_config.page_table_start_addr;
-		virt_config.page_table_end_addr = config->va_config.page_table_end_addr;
-		virt_config.depth = config->va_config.page_table_depth;
-		virt_config.block_size = config->va_config.page_table_block_size;
+		// Init VMID 0 based on PA config
+		dcn20_vmid_setup(&hubbub1->vmid[0], &phys_config);
+		dcn20_vmid_set_ptb(&hubbub1->vmid[0], config->pa_config.gart_config.page_table_base_addr);
+	}
+
+	if (config->va_config.page_table_start_addr != config->va_config.page_table_end_addr) {
+		// Init VMID 1-15 based on VA config
+		for (i = 1; i < 16; i++) {
+			virt_config.page_table_start_addr = config->va_config.page_table_start_addr >> 12;
+			virt_config.page_table_end_addr = config->va_config.page_table_end_addr >> 12;
+			virt_config.depth = page_table_depth_to_hw(config->va_config.page_table_depth);
+			virt_config.block_size = page_table_block_size_to_hw(config->va_config.page_table_block_size);
 
-		dcn20_vmid_setup(&hubbub1->vmid[i], &virt_config);
+			dcn20_vmid_setup(&hubbub1->vmid[i], &virt_config);
+		}
 	}
 }
 

commit 040a4d63bde4bbd5fd7ae40a7b94a05b259cca06
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Apr 12 15:50:55 2019 -0400

    drm/amd/display: DCHUB requestors numbers for Navi.
    
    [Why]
    The DCHub arbiter has a mechanism to dynamically rate limit the DCHub
    request stream to the fabric. If the memory controller is fully utilized
    and the DCHub requestors are well ahead of their amortized schedule,
    then it is safe to prevent the next winner from being committed and sent
    to the fabric. The utilization of the memory controller is approximated
    by ensuring that the number of outstanding requests is greater than a
    threshold specified by the ARB_MIN_REQ_OUTSTANDING. To determine that
    the DCHub requestors are well ahead of the amortized schedule, the slack
    of the next winner is compared with the ARB_SAT_LEVEL in DLG RefClk
    cycles.
    
    [How]
    The recommended settings to enable thise dynamic limiting for Navi is
    180 requests.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
index d6705b40a57c..a851574f118a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
@@ -493,6 +493,28 @@ void hubbub2_get_dchub_ref_freq(struct hubbub *hubbub,
 	}
 }
 
+static void hubbub2_program_watermarks(
+		struct hubbub *hubbub,
+		struct dcn_watermark_set *watermarks,
+		unsigned int refclk_mhz,
+		bool safe_to_lower)
+{
+	struct dcn20_hubbub *hubbub1 = TO_DCN20_HUBBUB(hubbub);
+	/*
+	 * Need to clamp to max of the register values (i.e. no wrap)
+	 * for dcn1, all wm registers are 21-bit wide
+	 */
+	hubbub1_program_urgent_watermarks(hubbub, watermarks, refclk_mhz, safe_to_lower);
+	hubbub1_program_stutter_watermarks(hubbub, watermarks, refclk_mhz, safe_to_lower);
+	hubbub1_program_pstate_watermarks(hubbub, watermarks, refclk_mhz, safe_to_lower);
+
+	REG_SET(DCHUBBUB_ARB_SAT_LEVEL, 0,
+			DCHUBBUB_ARB_SAT_LEVEL, 60 * refclk_mhz);
+	REG_UPDATE(DCHUBBUB_ARB_DF_REQ_OUTSTAND, DCHUBBUB_ARB_MIN_REQ_OUTSTAND, 180);
+
+	hubbub1_allow_self_refresh_control(hubbub, !hubbub->ctx->dc->debug.disable_stutter);
+}
+
 static const struct hubbub_funcs hubbub2_funcs = {
 	.update_dchub = hubbub2_update_dchub,
 	.init_dchub = hubbub2_init_dchub,
@@ -502,7 +524,7 @@ static const struct hubbub_funcs hubbub2_funcs = {
 	.get_dcc_compression_cap = hubbub2_get_dcc_compression_cap,
 	.wm_read_state = hubbub2_wm_read_state,
 	.get_dchub_ref_freq = hubbub2_get_dchub_ref_freq,
-	.program_watermarks = hubbub1_program_watermarks,
+	.program_watermarks = hubbub2_program_watermarks,
 };
 
 void hubbub2_construct(struct dcn20_hubbub *hubbub,

commit 78b674573a552f046322d70b943349c133241e04
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Apr 11 14:11:47 2019 -0400

    drm/amd/display: Refactor program watermark.
    
    Refactor programming watermark function:
    Divided into urgent watermark, stutter watermark and pstate watermark.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
index b3a99b10cfbd..d6705b40a57c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
@@ -294,7 +294,7 @@ bool hubbub2_get_dcc_compression_cap(struct hubbub *hubbub,
 	return true;
 }
 
-static void hubbub2_setup_vmid_ptb(struct hubbub *hubbub,
+void hubbub2_setup_vmid_ptb(struct hubbub *hubbub,
 		uint64_t ptb,
 		uint8_t vmid)
 {

commit 0cd3262566797b3c2de5a180b32fa820808f7f1a
Author: Bob Yang <Bob.Yang@amd.com>
Date:   Mon Mar 18 11:44:52 2019 +0800

    drm/amd/display: fixed DCC corruption
    
    [Description]
    swath_bytes_horz_wc should be 256/64/64 for 2160p 32bpp surface
    
    Signed-off-by: Bob Yang <Bob.Yang@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
index 09e8d10a7a01..b3a99b10cfbd 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
@@ -194,8 +194,8 @@ static void hubbub2_det_request_size(
 
 	hubbub2_get_blk256_size(&blk256_width, &blk256_height, bpe);
 
-	swath_bytes_horz_wc = height * blk256_height * bpe;
-	swath_bytes_vert_wc = width * blk256_width * bpe;
+	swath_bytes_horz_wc = width * blk256_height * bpe;
+	swath_bytes_vert_wc = height * blk256_width * bpe;
 
 	*req128_horz_wc = (2 * swath_bytes_horz_wc <= detile_buf_size) ?
 			false : /* full 256B request */

commit bbeb64d0eb78f493323897bbb8cbd1820645501b
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue May 7 14:58:48 2019 -0500

    drm/amd/display: Add DCN2 HUBP and HUBBUB
    
    Add support to program the DCN2 HUBP (Display to data fabric interface
    pipe) and HUBBUB (DCN memory HUB interface)
    
    HW Blocks:
    
     +--------++------+
     | HUBBUB || HUBP |
     +--------++------+
            |
            v
        +--------+
        |  DPP   |
        +--------+
            |
            v
        +--------+
        |  MPC   |
        +--------+
            |
            v
        +-------+
        |  OPP  |
        +-------+
            |
            v
        +--------+
        |  OPTC  |
        +--------+
            |
            v
        +--------+       +--------+
        |  DIO   |       |  DCCG  |
        +--------+       +--------+
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
new file mode 100644
index 000000000000..09e8d10a7a01
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubbub.c
@@ -0,0 +1,523 @@
+/*
+ * Copyright 2016 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+
+#include "dcn20_hubbub.h"
+#include "reg_helper.h"
+
+#define REG(reg)\
+	hubbub1->regs->reg
+
+#define CTX \
+	hubbub1->base.ctx
+
+#undef FN
+#define FN(reg_name, field_name) \
+	hubbub1->shifts->field_name, hubbub1->masks->field_name
+
+#define REG(reg)\
+	hubbub1->regs->reg
+
+#define CTX \
+	hubbub1->base.ctx
+
+#undef FN
+#define FN(reg_name, field_name) \
+	hubbub1->shifts->field_name, hubbub1->masks->field_name
+
+bool hubbub2_dcc_support_swizzle(
+		enum swizzle_mode_values swizzle,
+		unsigned int bytes_per_element,
+		enum segment_order *segment_order_horz,
+		enum segment_order *segment_order_vert)
+{
+	bool standard_swizzle = false;
+	bool display_swizzle = false;
+	bool render_swizzle = false;
+
+	switch (swizzle) {
+	case DC_SW_4KB_S:
+	case DC_SW_64KB_S:
+	case DC_SW_VAR_S:
+	case DC_SW_4KB_S_X:
+	case DC_SW_64KB_S_X:
+	case DC_SW_VAR_S_X:
+		standard_swizzle = true;
+		break;
+	case DC_SW_64KB_R_X:
+		render_swizzle = true;
+		break;
+	case DC_SW_4KB_D:
+	case DC_SW_64KB_D:
+	case DC_SW_VAR_D:
+	case DC_SW_4KB_D_X:
+	case DC_SW_64KB_D_X:
+	case DC_SW_VAR_D_X:
+		display_swizzle = true;
+		break;
+	default:
+		break;
+	}
+
+	if (standard_swizzle) {
+		if (bytes_per_element == 1) {
+			*segment_order_horz = segment_order__contiguous;
+			*segment_order_vert = segment_order__na;
+			return true;
+		}
+		if (bytes_per_element == 2) {
+			*segment_order_horz = segment_order__non_contiguous;
+			*segment_order_vert = segment_order__contiguous;
+			return true;
+		}
+		if (bytes_per_element == 4) {
+			*segment_order_horz = segment_order__non_contiguous;
+			*segment_order_vert = segment_order__contiguous;
+			return true;
+		}
+		if (bytes_per_element == 8) {
+			*segment_order_horz = segment_order__na;
+			*segment_order_vert = segment_order__contiguous;
+			return true;
+		}
+	}
+	if (render_swizzle) {
+		if (bytes_per_element == 2) {
+			*segment_order_horz = segment_order__contiguous;
+			*segment_order_vert = segment_order__contiguous;
+			return true;
+		}
+		if (bytes_per_element == 4) {
+			*segment_order_horz = segment_order__non_contiguous;
+			*segment_order_vert = segment_order__contiguous;
+			return true;
+		}
+		if (bytes_per_element == 8) {
+			*segment_order_horz = segment_order__contiguous;
+			*segment_order_vert = segment_order__non_contiguous;
+			return true;
+		}
+	}
+	if (display_swizzle && bytes_per_element == 8) {
+		*segment_order_horz = segment_order__contiguous;
+		*segment_order_vert = segment_order__non_contiguous;
+		return true;
+	}
+
+	return false;
+}
+
+bool hubbub2_dcc_support_pixel_format(
+		enum surface_pixel_format format,
+		unsigned int *bytes_per_element)
+{
+	/* DML: get_bytes_per_element */
+	switch (format) {
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
+	case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
+		*bytes_per_element = 2;
+		return true;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:
+	case SURFACE_PIXEL_FORMAT_GRPH_RGB111110_FIX:
+	case SURFACE_PIXEL_FORMAT_GRPH_BGR101111_FIX:
+	case SURFACE_PIXEL_FORMAT_GRPH_RGB111110_FLOAT:
+	case SURFACE_PIXEL_FORMAT_GRPH_BGR101111_FLOAT:
+		*bytes_per_element = 4;
+		return true;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:
+		*bytes_per_element = 8;
+		return true;
+	default:
+		return false;
+	}
+}
+
+static void hubbub2_get_blk256_size(unsigned int *blk256_width, unsigned int *blk256_height,
+		unsigned int bytes_per_element)
+{
+	/* copied from DML.  might want to refactor DML to leverage from DML */
+	/* DML : get_blk256_size */
+	if (bytes_per_element == 1) {
+		*blk256_width = 16;
+		*blk256_height = 16;
+	} else if (bytes_per_element == 2) {
+		*blk256_width = 16;
+		*blk256_height = 8;
+	} else if (bytes_per_element == 4) {
+		*blk256_width = 8;
+		*blk256_height = 8;
+	} else if (bytes_per_element == 8) {
+		*blk256_width = 8;
+		*blk256_height = 4;
+	}
+}
+
+static void hubbub2_det_request_size(
+		unsigned int height,
+		unsigned int width,
+		unsigned int bpe,
+		bool *req128_horz_wc,
+		bool *req128_vert_wc)
+{
+	unsigned int detile_buf_size = 164 * 1024;  /* 164KB for DCN1.0 */
+
+	unsigned int blk256_height = 0;
+	unsigned int blk256_width = 0;
+	unsigned int swath_bytes_horz_wc, swath_bytes_vert_wc;
+
+	hubbub2_get_blk256_size(&blk256_width, &blk256_height, bpe);
+
+	swath_bytes_horz_wc = height * blk256_height * bpe;
+	swath_bytes_vert_wc = width * blk256_width * bpe;
+
+	*req128_horz_wc = (2 * swath_bytes_horz_wc <= detile_buf_size) ?
+			false : /* full 256B request */
+			true; /* half 128b request */
+
+	*req128_vert_wc = (2 * swath_bytes_vert_wc <= detile_buf_size) ?
+			false : /* full 256B request */
+			true; /* half 128b request */
+}
+
+bool hubbub2_get_dcc_compression_cap(struct hubbub *hubbub,
+		const struct dc_dcc_surface_param *input,
+		struct dc_surface_dcc_cap *output)
+{
+	struct dc *dc = hubbub->ctx->dc;
+	/* implement section 1.6.2.1 of DCN1_Programming_Guide.docx */
+	enum dcc_control dcc_control;
+	unsigned int bpe;
+	enum segment_order segment_order_horz, segment_order_vert;
+	bool req128_horz_wc, req128_vert_wc;
+
+	memset(output, 0, sizeof(*output));
+
+	if (dc->debug.disable_dcc == DCC_DISABLE)
+		return false;
+
+	if (!hubbub->funcs->dcc_support_pixel_format(input->format,
+			&bpe))
+		return false;
+
+	if (!hubbub->funcs->dcc_support_swizzle(input->swizzle_mode, bpe,
+			&segment_order_horz, &segment_order_vert))
+		return false;
+
+	hubbub2_det_request_size(input->surface_size.height,  input->surface_size.width,
+			bpe, &req128_horz_wc, &req128_vert_wc);
+
+	if (!req128_horz_wc && !req128_vert_wc) {
+		dcc_control = dcc_control__256_256_xxx;
+	} else if (input->scan == SCAN_DIRECTION_HORIZONTAL) {
+		if (!req128_horz_wc)
+			dcc_control = dcc_control__256_256_xxx;
+		else if (segment_order_horz == segment_order__contiguous)
+			dcc_control = dcc_control__128_128_xxx;
+		else
+			dcc_control = dcc_control__256_64_64;
+	} else if (input->scan == SCAN_DIRECTION_VERTICAL) {
+		if (!req128_vert_wc)
+			dcc_control = dcc_control__256_256_xxx;
+		else if (segment_order_vert == segment_order__contiguous)
+			dcc_control = dcc_control__128_128_xxx;
+		else
+			dcc_control = dcc_control__256_64_64;
+	} else {
+		if ((req128_horz_wc &&
+			segment_order_horz == segment_order__non_contiguous) ||
+			(req128_vert_wc &&
+			segment_order_vert == segment_order__non_contiguous))
+			/* access_dir not known, must use most constraining */
+			dcc_control = dcc_control__256_64_64;
+		else
+			/* reg128 is true for either horz and vert
+			 * but segment_order is contiguous
+			 */
+			dcc_control = dcc_control__128_128_xxx;
+	}
+
+	/* Exception for 64KB_R_X */
+	if ((bpe == 2) && (input->swizzle_mode == DC_SW_64KB_R_X))
+		dcc_control = dcc_control__128_128_xxx;
+
+	if (dc->debug.disable_dcc == DCC_HALF_REQ_DISALBE &&
+		dcc_control != dcc_control__256_256_xxx)
+		return false;
+
+	switch (dcc_control) {
+	case dcc_control__256_256_xxx:
+		output->grph.rgb.max_uncompressed_blk_size = 256;
+		output->grph.rgb.max_compressed_blk_size = 256;
+		output->grph.rgb.independent_64b_blks = false;
+		break;
+	case dcc_control__128_128_xxx:
+		output->grph.rgb.max_uncompressed_blk_size = 128;
+		output->grph.rgb.max_compressed_blk_size = 128;
+		output->grph.rgb.independent_64b_blks = false;
+		break;
+	case dcc_control__256_64_64:
+		output->grph.rgb.max_uncompressed_blk_size = 256;
+		output->grph.rgb.max_compressed_blk_size = 64;
+		output->grph.rgb.independent_64b_blks = true;
+		break;
+	}
+	output->capable = true;
+	output->const_color_support = true;
+
+	return true;
+}
+
+static void hubbub2_setup_vmid_ptb(struct hubbub *hubbub,
+		uint64_t ptb,
+		uint8_t vmid)
+{
+	struct dcn20_hubbub *hubbub1 = TO_DCN20_HUBBUB(hubbub);
+
+	dcn20_vmid_set_ptb(&hubbub1->vmid[vmid], ptb);
+}
+
+
+void hubbub2_init_dchub(struct hubbub *hubbub,
+		struct hubbub_addr_config *config)
+{
+	int i;
+	struct dcn20_hubbub *hubbub1 = TO_DCN20_HUBBUB(hubbub);
+	struct dcn_vmid_page_table_config phys_config;
+	struct dcn_vmid_page_table_config virt_config;
+
+	phys_config.depth = 0; // Depth 1
+	phys_config.block_size = 0; // Block size 4KB
+	phys_config.page_table_start_addr = config->pa_config.gart_config.page_table_start_addr;
+	phys_config.page_table_end_addr = config->pa_config.gart_config.page_table_end_addr;
+
+	REG_SET(DCN_VM_FB_LOCATION_BASE, 0,
+			FB_BASE, config->pa_config.system_aperture.fb_base);
+	REG_SET(DCN_VM_FB_LOCATION_TOP, 0,
+			FB_TOP, config->pa_config.system_aperture.fb_top);
+	REG_SET(DCN_VM_FB_OFFSET, 0,
+			FB_OFFSET, config->pa_config.system_aperture.fb_offset);
+	REG_SET(DCN_VM_AGP_BOT, 0,
+			AGP_BOT, config->pa_config.system_aperture.agp_bot);
+	REG_SET(DCN_VM_AGP_TOP, 0,
+			AGP_TOP, config->pa_config.system_aperture.agp_top);
+	REG_SET(DCN_VM_AGP_BASE, 0,
+			AGP_BASE, config->pa_config.system_aperture.agp_base);
+
+	// Init VMID 0 based on PA config
+	dcn20_vmid_setup(&hubbub1->vmid[0], &phys_config);
+	dcn20_vmid_set_ptb(&hubbub1->vmid[0], config->pa_config.gart_config.page_table_base_addr);
+
+	// Init VMID 1-15 based on VA config
+	for (i = 1; i < 16; i++) {
+		virt_config.page_table_start_addr = config->va_config.page_table_start_addr;
+		virt_config.page_table_end_addr = config->va_config.page_table_end_addr;
+		virt_config.depth = config->va_config.page_table_depth;
+		virt_config.block_size = config->va_config.page_table_block_size;
+
+		dcn20_vmid_setup(&hubbub1->vmid[i], &virt_config);
+	}
+}
+
+void hubbub2_update_dchub(struct hubbub *hubbub,
+		struct dchub_init_data *dh_data)
+{
+	struct dcn20_hubbub *hubbub1 = TO_DCN20_HUBBUB(hubbub);
+
+	if (REG(DCHUBBUB_SDPIF_FB_TOP) == 0) {
+		ASSERT(false);
+		/*should not come here*/
+		return;
+	}
+	/* TODO: port code from dal2 */
+	switch (dh_data->fb_mode) {
+	case FRAME_BUFFER_MODE_ZFB_ONLY:
+		/*For ZFB case need to put DCHUB FB BASE and TOP upside down to indicate ZFB mode*/
+		REG_UPDATE(DCHUBBUB_SDPIF_FB_TOP,
+				SDPIF_FB_TOP, 0);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_FB_BASE,
+				SDPIF_FB_BASE, 0x0FFFF);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,
+				SDPIF_AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,
+				SDPIF_AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,
+				SDPIF_AGP_TOP, (dh_data->zfb_mc_base_addr +
+						dh_data->zfb_size_in_byte - 1) >> 22);
+		break;
+	case FRAME_BUFFER_MODE_MIXED_ZFB_AND_LOCAL:
+		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,
+				SDPIF_AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,
+				SDPIF_AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,
+				SDPIF_AGP_TOP, (dh_data->zfb_mc_base_addr +
+						dh_data->zfb_size_in_byte - 1) >> 22);
+		break;
+	case FRAME_BUFFER_MODE_LOCAL_ONLY:
+		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,
+				SDPIF_AGP_BASE, 0);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,
+				SDPIF_AGP_BOT, 0X03FFFF);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,
+				SDPIF_AGP_TOP, 0);
+		break;
+	default:
+		break;
+	}
+
+	dh_data->dchub_initialzied = true;
+	dh_data->dchub_info_valid = false;
+}
+
+void hubbub2_wm_read_state(struct hubbub *hubbub,
+		struct dcn_hubbub_wm *wm)
+{
+	struct dcn20_hubbub *hubbub1 = TO_DCN20_HUBBUB(hubbub);
+
+	struct dcn_hubbub_wm_set *s;
+
+	memset(wm, 0, sizeof(struct dcn_hubbub_wm));
+
+	s = &wm->sets[0];
+	s->wm_set = 0;
+	s->data_urgent = REG_READ(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_A);
+	if (REG(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_A))
+		s->pte_meta_urgent = REG_READ(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_A);
+	if (REG(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A)) {
+		s->sr_enter = REG_READ(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A);
+		s->sr_exit = REG_READ(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_A);
+	}
+	s->dram_clk_chanage = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_A);
+
+	s = &wm->sets[1];
+	s->wm_set = 1;
+	s->data_urgent = REG_READ(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_B);
+	if (REG(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_B))
+		s->pte_meta_urgent = REG_READ(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_B);
+	if (REG(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B)) {
+		s->sr_enter = REG_READ(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B);
+		s->sr_exit = REG_READ(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_B);
+	}
+	s->dram_clk_chanage = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_B);
+
+	s = &wm->sets[2];
+	s->wm_set = 2;
+	s->data_urgent = REG_READ(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_C);
+	if (REG(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_C))
+		s->pte_meta_urgent = REG_READ(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_C);
+	if (REG(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C)) {
+		s->sr_enter = REG_READ(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C);
+		s->sr_exit = REG_READ(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_C);
+	}
+	s->dram_clk_chanage = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_C);
+
+	s = &wm->sets[3];
+	s->wm_set = 3;
+	s->data_urgent = REG_READ(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_D);
+	if (REG(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_D))
+		s->pte_meta_urgent = REG_READ(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_D);
+	if (REG(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D)) {
+		s->sr_enter = REG_READ(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D);
+		s->sr_exit = REG_READ(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_D);
+	}
+	s->dram_clk_chanage = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_D);
+}
+
+void hubbub2_get_dchub_ref_freq(struct hubbub *hubbub,
+		unsigned int dccg_ref_freq_inKhz,
+		unsigned int *dchub_ref_freq_inKhz)
+{
+	struct dcn20_hubbub *hubbub1 = TO_DCN20_HUBBUB(hubbub);
+	uint32_t ref_div = 0;
+	uint32_t ref_en = 0;
+
+	REG_GET_2(DCHUBBUB_GLOBAL_TIMER_CNTL, DCHUBBUB_GLOBAL_TIMER_REFDIV, &ref_div,
+			DCHUBBUB_GLOBAL_TIMER_ENABLE, &ref_en);
+
+	if (ref_en) {
+		if (ref_div == 2)
+			*dchub_ref_freq_inKhz = dccg_ref_freq_inKhz / 2;
+		else
+			*dchub_ref_freq_inKhz = dccg_ref_freq_inKhz;
+
+		// DC hub reference frequency must be around 50Mhz, otherwise there may be
+		// overflow/underflow issues when doing HUBBUB programming
+		if (*dchub_ref_freq_inKhz < 40000 || *dchub_ref_freq_inKhz > 60000)
+			ASSERT_CRITICAL(false);
+
+		return;
+	} else {
+		*dchub_ref_freq_inKhz = dccg_ref_freq_inKhz;
+
+		// HUBBUB global timer must be enabled.
+		ASSERT_CRITICAL(false);
+		return;
+	}
+}
+
+static const struct hubbub_funcs hubbub2_funcs = {
+	.update_dchub = hubbub2_update_dchub,
+	.init_dchub = hubbub2_init_dchub,
+	.setup_vmid_ptb = hubbub2_setup_vmid_ptb,
+	.dcc_support_swizzle = hubbub2_dcc_support_swizzle,
+	.dcc_support_pixel_format = hubbub2_dcc_support_pixel_format,
+	.get_dcc_compression_cap = hubbub2_get_dcc_compression_cap,
+	.wm_read_state = hubbub2_wm_read_state,
+	.get_dchub_ref_freq = hubbub2_get_dchub_ref_freq,
+	.program_watermarks = hubbub1_program_watermarks,
+};
+
+void hubbub2_construct(struct dcn20_hubbub *hubbub,
+	struct dc_context *ctx,
+	const struct dcn_hubbub_registers *hubbub_regs,
+	const struct dcn_hubbub_shift *hubbub_shift,
+	const struct dcn_hubbub_mask *hubbub_mask)
+{
+	hubbub->base.ctx = ctx;
+
+	hubbub->base.funcs = &hubbub2_funcs;
+
+	hubbub->regs = hubbub_regs;
+	hubbub->shifts = hubbub_shift;
+	hubbub->masks = hubbub_mask;
+
+	hubbub->debug_test_index_pstate = 0xB;
+}
