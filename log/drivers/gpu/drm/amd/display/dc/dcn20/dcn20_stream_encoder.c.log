commit 3f0940f8691a295234ed25b94cafe0467af8a50b
Author: Charlene Liu <Charlene.Liu@amd.com>
Date:   Fri Jan 10 14:52:49 2020 -0500

    drm/amd/display: add stream_enc_inst for PSP HDCP inst use
    
    [why]
    new HW engine mapping requirment use in PSP
    [how]
    report stream_enc_inst
    
    Signed-off-by: Charlene Liu <Charlene.Liu@amd.com>
    Reviewed-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
index 9b70a1e7b962..99a7ef6ab878 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -616,5 +616,6 @@ void dcn20_stream_encoder_construct(
 	enc1->regs = regs;
 	enc1->se_shift = se_shift;
 	enc1->se_mask = se_mask;
+	enc1->base.stream_enc_inst = eng_id - ENGINE_ID_DIGA;
 }
 

commit 949ffc8b3631ea0192a298109fa583b2f3a39c8f
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Mon Nov 11 18:03:59 2019 -0500

    drm/amd/display: Reset steer fifo before unblanking the stream
    
    [why]
    During mode transition steer fifo could overflow. Quite often it
    recovers by itself, but sometimes it doesn't.
    
    [how]
    Add steer fifo reset before unblanking the stream. Also add a short
    delay when resetting dig resync fifo to make sure register writes
    don't end up back-to-back, in which case the HW might miss the reset
    request.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
index be0978401476..9b70a1e7b962 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -488,15 +488,23 @@ void enc2_stream_encoder_dp_unblank(
 				DP_VID_N_MUL, n_multiply);
 	}
 
-	/* set DIG_START to 0x1 to reset FIFO */
+	/* make sure stream is disabled before resetting steer fifo */
+	REG_UPDATE(DP_VID_STREAM_CNTL, DP_VID_STREAM_ENABLE, false);
+	REG_WAIT(DP_VID_STREAM_CNTL, DP_VID_STREAM_STATUS, 0, 10, 5000);
 
+	/* set DIG_START to 0x1 to reset FIFO */
 	REG_UPDATE(DIG_FE_CNTL, DIG_START, 1);
+	udelay(1);
 
 	/* write 0 to take the FIFO out of reset */
 
 	REG_UPDATE(DIG_FE_CNTL, DIG_START, 0);
 
-	/* switch DP encoder to CRTC data */
+	/* switch DP encoder to CRTC data, but reset it the fifo first. It may happen
+	 * that it overflows during mode transition, and sometimes doesn't recover.
+	 */
+	REG_UPDATE(DP_STEER_FIFO, DP_STEER_FIFO_RESET, 1);
+	udelay(10);
 
 	REG_UPDATE(DP_STEER_FIFO, DP_STEER_FIFO_RESET, 0);
 

commit 9185e8adb4cc9aa628a2c9b47b43d193cf268ee5
Author: David (Dingchen) Zhang <dingchen.zhang@amd.com>
Date:   Thu Oct 31 14:36:51 2019 -0400

    drm/amd/display: add debugfs sdp hook up function for Navi
    
    [why]
    need to send immediate SDP message via debugfs on Navi board.
    
    [how]
    hook up the DCN1x encoder function of sending immediate sdp
    message to DCN2.
    
    Signed-off-by: David (Dingchen) Zhang <dingchen.zhang@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
index 33cc40fb9687..be0978401476 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -561,6 +561,8 @@ static const struct stream_encoder_funcs dcn20_str_enc_funcs = {
 		enc2_stream_encoder_stop_hdmi_info_packets,
 	.update_dp_info_packets =
 		enc2_stream_encoder_update_dp_info_packets,
+	.send_immediate_sdp_message =
+		enc1_stream_encoder_send_immediate_sdp_message,
 	.stop_dp_info_packets =
 		enc1_stream_encoder_stop_dp_info_packets,
 	.dp_blank =

commit 1da37801a8b0fffb024fea594c7f1d7867ed8aa0
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:38:55 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_0 and DSC_SUPPORTED
    
    [Why]
    
    DCN2 and DSC are stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup NV defninitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN2 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * dce/dce_dmcu.c: dcn20_*lock_phy()
        * dce/dce_dmcu.c: dcn20_funcs
        * dce/dce_dmcu.c: dcn20_dmcu_create()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
index 6c2d82ce43ab..33cc40fb9687 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -205,7 +205,6 @@ static void enc2_stream_encoder_stop_hdmi_info_packets(
 		HDMI_GENERIC7_LINE, 0);
 }
 
-#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 
 /* Update GSP7 SDP 128 byte long */
 static void enc2_update_gsp7_128_info_packet(
@@ -360,7 +359,6 @@ static void enc2_read_state(struct stream_encoder *enc, struct enc_state *s)
 		REG_GET(DP_SEC_CNTL, DP_SEC_STREAM_ENABLE, &s->sec_stream_enable);
 	}
 }
-#endif
 
 /* Set Dynamic Metadata-configuration.
  *   enable_dme:         TRUE: enables Dynamic Metadata Enfine, FALSE: disables DME
@@ -440,10 +438,8 @@ static bool is_two_pixels_per_containter(const struct dc_crtc_timing *timing)
 {
 	bool two_pix = timing->pixel_encoding == PIXEL_ENCODING_YCBCR420;
 
-#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 	two_pix = two_pix || (timing->flags.DSC && timing->pixel_encoding == PIXEL_ENCODING_YCBCR422
 			&& !timing->dsc_cfg.ycbcr422_simple);
-#endif
 	return two_pix;
 }
 
@@ -587,11 +583,9 @@ static const struct stream_encoder_funcs dcn20_str_enc_funcs = {
 	.dp_get_pixel_format =
 		enc1_stream_encoder_dp_get_pixel_format,
 
-#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 	.enc_read_state = enc2_read_state,
 	.dp_set_dsc_config = enc2_dp_set_dsc_config,
 	.dp_set_dsc_pps_info_packet = enc2_dp_set_dsc_pps_info_packet,
-#endif
 	.set_dynamic_metadata = enc2_set_dynamic_metadata,
 	.hdmi_reset_stream_attribute = enc1_reset_hdmi_stream_attribute,
 };

commit 5ed78cd69a1bf64e6bdb70a05c1c9bde87b209ad
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Wed Oct 16 23:44:55 2019 -0400

    drm/amd/display: set MSA MISC1 bit 6 while sending colorimetry in VSC SDP
    
    [Why]
    It is confusing to sinks if we send VSC SDP only on some format. Today we
    signal colorimetry format using MSA while in formats like sRGB.
    But when we switch to BT2020 we set the bit to ignore MSA  colorimetry and
    instead use the colorimetry information in the VSC SDP.
    
    But if sink supports signaling of colorimetry via VSC SDP we should always
    set the MSA MISC1 bit 6, instead of doing so selectively.
    
    [How]
    If sink supports signaling of colorimetry via VSC SDP, and we are sending
    the colorimetry info via VSC SDP with packet revision 05h, then always
    set MSA MISC1 bit 6.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
index 4b3401616434..6c2d82ce43ab 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -533,11 +533,16 @@ void enc2_stream_encoder_dp_set_stream_attribute(
 	struct stream_encoder *enc,
 	struct dc_crtc_timing *crtc_timing,
 	enum dc_color_space output_color_space,
+	bool use_vsc_sdp_for_colorimetry,
 	uint32_t enable_sdp_splitting)
 {
 	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
 
-	enc1_stream_encoder_dp_set_stream_attribute(enc, crtc_timing, output_color_space, enable_sdp_splitting);
+	enc1_stream_encoder_dp_set_stream_attribute(enc,
+			crtc_timing,
+			output_color_space,
+			use_vsc_sdp_for_colorimetry,
+			enable_sdp_splitting);
 
 	REG_UPDATE(DP_SEC_FRAMING4,
 		DP_SST_SDP_SPLITTING, enable_sdp_splitting);

commit 93c2340bdc24b6067a7621e71d4aacac1f85b5f2
Author: Martin Leung <martin.leung@amd.com>
Date:   Tue Sep 17 14:50:22 2019 -0400

    drm/amd/display: add more checks to validate seamless boot timing
    
    [why]
    we found using an active DP to HDMI panel that we weren't validating
    dp_pixel_format and hardware timing v_front_porch, causing screen to
    blank and/or corrupt while attempting a seamless boot.
    
    [how]
    added checks during dc_validate_seamless_boot_timing for these values
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
index 5ab9d6240498..4b3401616434 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -578,6 +578,10 @@ static const struct stream_encoder_funcs dcn20_str_enc_funcs = {
 	.set_avmute = enc1_stream_encoder_set_avmute,
 	.dig_connect_to_otg  = enc1_dig_connect_to_otg,
 	.dig_source_otg = enc1_dig_source_otg,
+
+	.dp_get_pixel_format =
+		enc1_stream_encoder_dp_get_pixel_format,
+
 #ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 	.enc_read_state = enc2_read_state,
 	.dp_set_dsc_config = enc2_dp_set_dsc_config,

commit 1f3324603e39d6a5a7f9f378c980dab390d9a1d5
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jul 31 14:08:45 2019 -0400

    drm/amd/display: fix dp stream enable
    
    A previous odm change broke stream enable by always setting
    n_multiply as if odm was on.
    
    This fixes the check for odm by making sure opp count is >1
    rather than not 0.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
index e24107ec5398..5ab9d6240498 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -460,7 +460,7 @@ void enc2_stream_encoder_dp_unblank(
 		uint64_t m_vid_l = n_vid;
 
 		/* YCbCr 4:2:0 : Computed VID_M will be 2X the input rate */
-		if (is_two_pixels_per_containter(&param->timing) || param->opp_cnt) {
+		if (is_two_pixels_per_containter(&param->timing) || param->opp_cnt > 1) {
 			/*this logic should be the same in get_pixel_clock_parameters() */
 			n_multiply = 1;
 		}

commit b1f6d01c4a3b7eeb2eb035e79d425cd6a696fa45
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Aug 6 17:17:28 2019 -0400

    drm/amd/display: re structure odm to allow 4 to 1 support
    
    Currently odm is handled using top_bottom pipe by special casing
    the differing opps to differentiate from mpc combine.
    
    Since top/bottom pipe list was made to track mpc muxing this creates
    difficulties in adding a 4 pipe odm case support.
    
    Rather than continue using mpc combine list, this change reworks odm
    to use it's own linked list to keep track of odm combine pipes. This
    also opens up options for using mpo with odm, if a practical use case
    is ever found.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
index c8ca49656d8d..e24107ec5398 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -460,7 +460,7 @@ void enc2_stream_encoder_dp_unblank(
 		uint64_t m_vid_l = n_vid;
 
 		/* YCbCr 4:2:0 : Computed VID_M will be 2X the input rate */
-		if (is_two_pixels_per_containter(&param->timing) || param->odm) {
+		if (is_two_pixels_per_containter(&param->timing) || param->opp_cnt) {
 			/*this logic should be the same in get_pixel_clock_parameters() */
 			n_multiply = 1;
 		}

commit b5d055de2bf566786243f0f3f1e838e901362478
Author: David Francis <David.Francis@amd.com>
Date:   Thu Mar 28 09:58:11 2019 -0400

    Revert "drm/amd/display: navi10 bring up skip dsc encoder config"
    
    This reverts commit ec8763486dd3d2fb585c2e6747520406e7dcef98.
    
    Re-enable enc2_dp_set_dsc_config. This function caused warnings
    due to missing register definitions. With the registers added,
    this now works
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
index aab0d21459bc..c8ca49656d8d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -279,14 +279,6 @@ static void enc2_dp_set_dsc_config(struct stream_encoder *enc,
 					uint32_t dsc_slice_width)
 {
 	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
-	uint32_t dsc_value = 0;
-
-	dsc_value = REG_READ(DP_DSC_CNTL);
-
-	/* dsc disable skip */
-	if ((dsc_value & 0x3) == 0x0)
-		return;
-
 
 	REG_UPDATE_2(DP_DSC_CNTL,
 			DP_DSC_MODE, dsc_mode,

commit 1a9e3d4569fc9a9a1cbfb14cacf3268114646ab6
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Wed Jul 17 19:02:14 2019 -0400

    drm/amd/display: Set DSC before DIG front-end is connected to its back-end
    
    [why]
    At the time DIG FE is connected to its BE, the clocks in OTG are enabled and
    PHY will also be set up. When DSC has to be used to fit the stream into the
    available bandwidth, without DSC being set DIG could get exposed to the
    higer bandwidth it (or link) could handle. This causes the HW to "reject"
    video enable setup (the register shows that video enable was attempted, but
    the status bit shows it as disabled).
    
    [how]
    - Separate DSC setup into DSC register config and DSC PPS SDP setup
    
    - Move most of the DSC setup (register config) to before
      dcn10_link_encoder_connect_dig_be_to_fe() is  called
    
    - Set up DSC PPS SDP after DIG FE is connected to its BE. This is because
      setting DSC PPS SDP before that has no effect.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
index 88428950e29c..aab0d21459bc 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -207,9 +207,8 @@ static void enc2_stream_encoder_stop_hdmi_info_packets(
 
 #ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 
-
 /* Update GSP7 SDP 128 byte long */
-static void enc2_send_gsp7_128_info_packet(
+static void enc2_update_gsp7_128_info_packet(
 	struct dcn10_stream_encoder *enc1,
 	const struct dc_info_packet_128 *info_packet)
 {
@@ -277,8 +276,7 @@ static void enc2_send_gsp7_128_info_packet(
 static void enc2_dp_set_dsc_config(struct stream_encoder *enc,
 					enum optc_dsc_mode dsc_mode,
 					uint32_t dsc_bytes_per_pixel,
-					uint32_t dsc_slice_width,
-					uint8_t *dsc_packed_pps)
+					uint32_t dsc_slice_width)
 {
 	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
 	uint32_t dsc_value = 0;
@@ -296,8 +294,16 @@ static void enc2_dp_set_dsc_config(struct stream_encoder *enc,
 
 	REG_SET(DP_DSC_BYTES_PER_PIXEL, 0,
 		DP_DSC_BYTES_PER_PIXEL, dsc_bytes_per_pixel);
+}
+
+
+static void enc2_dp_set_dsc_pps_info_packet(struct stream_encoder *enc,
+					bool enable,
+					uint8_t *dsc_packed_pps)
+{
+	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
 
-	if (dsc_mode != OPTC_DSC_DISABLED) {
+	if (enable) {
 		struct dc_info_packet_128 pps_sdp;
 
 		ASSERT(dsc_packed_pps);
@@ -309,7 +315,7 @@ static void enc2_dp_set_dsc_config(struct stream_encoder *enc,
 		pps_sdp.hb2 = 127;
 		pps_sdp.hb3 = 0;
 		memcpy(&pps_sdp.sb[0], dsc_packed_pps, sizeof(pps_sdp.sb));
-		enc2_send_gsp7_128_info_packet(enc1, &pps_sdp);
+		enc2_update_gsp7_128_info_packet(enc1, &pps_sdp);
 
 		/* Enable Generic Stream Packet 7 (GSP) transmission */
 		//REG_UPDATE(DP_SEC_CNTL,
@@ -340,9 +346,8 @@ static void enc2_dp_set_dsc_config(struct stream_encoder *enc,
 		REG_UPDATE(DP_SEC_CNTL2, DP_SEC_GSP7_PPS, 0);
 	}
 }
-#endif
 
-#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+
 /* this function read dsc related register fields to be logged later in dcn10_log_hw_state
  * into a dcn_dsc_state struct.
  */
@@ -583,10 +588,8 @@ static const struct stream_encoder_funcs dcn20_str_enc_funcs = {
 	.dig_source_otg = enc1_dig_source_otg,
 #ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 	.enc_read_state = enc2_read_state,
-#endif
-
-#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 	.dp_set_dsc_config = enc2_dp_set_dsc_config,
+	.dp_set_dsc_pps_info_packet = enc2_dp_set_dsc_pps_info_packet,
 #endif
 	.set_dynamic_metadata = enc2_set_dynamic_metadata,
 	.hdmi_reset_stream_attribute = enc1_reset_hdmi_stream_attribute,

commit 5ec43eda85506ddc2f91c3a4e28b38da3f14cf1e
Author: Martin Leung <martin.leung@amd.com>
Date:   Wed Jul 17 16:08:19 2019 -0400

    drm/amd/display: enabling seamless boot sequence for dcn2
    
    [Why]
    Seamless boot (building SW state inheriting BIOS-initialized timing) was
    enabled on DCN2, including fixes
    
    [How]
    Includes fixes for MPC, DPPCLK, and DIG FE mapping/OTG source select/
    Pixel clock.
    
    This is part 2 of 2 for seamless boot NV10
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
index 45df7f56afaf..88428950e29c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -580,6 +580,7 @@ static const struct stream_encoder_funcs dcn20_str_enc_funcs = {
 	.setup_stereo_sync  = enc1_setup_stereo_sync,
 	.set_avmute = enc1_stream_encoder_set_avmute,
 	.dig_connect_to_otg  = enc1_dig_connect_to_otg,
+	.dig_source_otg = enc1_dig_source_otg,
 #ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 	.enc_read_state = enc2_read_state,
 #endif

commit ac42fd639550b386c41d8f3f2dc657d96fde7235
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Wed Jul 10 18:35:18 2019 -0400

    drm/amd/display: reset hdmi tmds rate and data scramble on pipe reset
    
    [why]
    hdmi data scramble and tmds rate is not reset during pipe reset.
    
    [how]
    reset hdmi tmds rate and data scramble on pipe reset
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Chris Park <Chris.Park@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
index 5c2b7b54b126..45df7f56afaf 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -588,6 +588,7 @@ static const struct stream_encoder_funcs dcn20_str_enc_funcs = {
 	.dp_set_dsc_config = enc2_dp_set_dsc_config,
 #endif
 	.set_dynamic_metadata = enc2_set_dynamic_metadata,
+	.hdmi_reset_stream_attribute = enc1_reset_hdmi_stream_attribute,
 };
 
 void dcn20_stream_encoder_construct(

commit 4fb6ec466dd50fdd94a1288b27b692da67b6c23d
Author: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
Date:   Wed May 29 18:52:17 2019 -0400

    drm/amd/display: Expose enc2_set_dynamic_metadata
    
    [Why]
    Need to implement register programming for HDR dynamic
    metadata transmission and tests.
    
    Signed-off-by: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
index f5bcffc426b8..5c2b7b54b126 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -373,7 +373,7 @@ static void enc2_read_state(struct stream_encoder *enc, struct enc_state *s)
  *
  *   Ensure the OTG master update lock is set when changing DME configuration.
  */
-static void enc2_set_dynamic_metadata(struct stream_encoder *enc,
+void enc2_set_dynamic_metadata(struct stream_encoder *enc,
 		bool enable_dme,
 		uint32_t hubp_requestor_id,
 		enum dynamic_metadata_mode dmdata_mode)

commit d7929c1e13e3788e7cb741d75b5baec5e53eff21
Merge: 8ac875db0fdc 80d42db02b3a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jun 25 08:42:25 2019 -0500

    Merge branch 'drm-next' into drm-next-5.3
    
    Backmerge drm-next and fix up conflicts due to drmP.h removal.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit f82c916c41974c4e786c7311c34c33ca67373092
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Jun 3 10:53:44 2019 -0400

    drm/amd/display: add some parameters to validate bandwidth functions
    
    required for new checks.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
index 130b01801a26..791aa745efd2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -204,14 +204,7 @@ static void enc2_stream_encoder_stop_hdmi_info_packets(
 }
 
 #ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
-struct dc_info_packet_128 {
-	bool valid;
-	uint8_t hb0;
-	uint8_t hb1;
-	uint8_t hb2;
-	uint8_t hb3;
-	uint8_t sb[128];
-};
+
 
 /* Update GSP7 SDP 128 byte long */
 static void enc2_send_gsp7_128_info_packet(

commit ec8763486dd3d2fb585c2e6747520406e7dcef98
Author: hersen wu <hersenxs.wu@amd.com>
Date:   Wed Mar 13 16:25:37 2019 -0400

    drm/amd/display: navi10 bring up skip dsc encoder config
    
    not needed for bring up.
    
    Signed-off-by: hersen wu <hersenxs.wu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
index c3c218805eb1..130b01801a26 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -286,6 +286,14 @@ static void enc2_dp_set_dsc_config(struct stream_encoder *enc,
 					uint8_t *dsc_packed_pps)
 {
 	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
+	uint32_t dsc_value = 0;
+
+	dsc_value = REG_READ(DP_DSC_CNTL);
+
+	/* dsc disable skip */
+	if ((dsc_value & 0x3) == 0x0)
+		return;
+
 
 	REG_UPDATE_2(DP_DSC_CNTL,
 			DP_DSC_MODE, dsc_mode,

commit bcba830ce7cddb225fd19ecb857ce2b26ebc28b7
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Wed May 8 16:08:39 2019 -0400

    drm/amd/display: Refactor DIO stream encoder
    
    * Pull duplicate audio_clock_info struct to stream_encoder.h
    * Generalize sec_gsp7* to sec_gsp_pps*
    * Expose enc1 and enc2 stream encoder audio funcs
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
index d99b1fc8f2df..c3c218805eb1 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -351,13 +351,12 @@ static void enc2_read_state(struct stream_encoder *enc, struct enc_state *s)
 	REG_GET(DP_DSC_CNTL, DP_DSC_MODE, &s->dsc_mode);
 	if (s->dsc_mode) {
 		REG_GET(DP_DSC_CNTL, DP_DSC_SLICE_WIDTH, &s->dsc_slice_width);
-		REG_GET(DP_SEC_CNTL6, DP_SEC_GSP7_LINE_NUM, &s->sec_gsp7_line_num);
+		REG_GET(DP_SEC_CNTL6, DP_SEC_GSP7_LINE_NUM, &s->sec_gsp_pps_line_num);
 
-		REG_GET(DP_SEC_CNTL6, DP_SEC_GSP7_LINE_NUM, &s->sec_gsp7_line_num);
 		REG_GET(DP_MSA_VBID_MISC, DP_VBID6_LINE_REFERENCE, &s->vbid6_line_reference);
 		REG_GET(DP_MSA_VBID_MISC, DP_VBID6_LINE_NUM, &s->vbid6_line_num);
 
-		REG_GET(DP_SEC_CNTL, DP_SEC_GSP7_ENABLE, &s->sec_gsp7_enable);
+		REG_GET(DP_SEC_CNTL, DP_SEC_GSP7_ENABLE, &s->sec_gsp_pps_enable);
 		REG_GET(DP_SEC_CNTL, DP_SEC_STREAM_ENABLE, &s->sec_stream_enable);
 	}
 }
@@ -448,7 +447,7 @@ static bool is_two_pixels_per_containter(const struct dc_crtc_timing *timing)
 	return two_pix;
 }
 
-static void enc2_stream_encoder_dp_unblank(
+void enc2_stream_encoder_dp_unblank(
 		struct stream_encoder *enc,
 		const struct encoder_unblank_param *param)
 {
@@ -530,7 +529,7 @@ static void enc2_dp_set_odm_combine(
 	REG_UPDATE(DP_PIXEL_FORMAT, DP_PIXEL_COMBINE, odm_combine);
 }
 
-static void enc2_stream_encoder_dp_set_stream_attribute(
+void enc2_stream_encoder_dp_set_stream_attribute(
 	struct stream_encoder *enc,
 	struct dc_crtc_timing *crtc_timing,
 	enum dc_color_space output_color_space,

commit 97bda0322b8a91aa8d534763e709571b2334e585
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Feb 25 13:26:34 2019 -0500

    drm/amd/display: Add DSC support for Navi (v2)
    
    Add support for DCN2 DSC (Display Stream Compression)
    
    HW Blocks:
    
     +--------++------+       +----------+
     | HUBBUB || HUBP |  <--  | MMHUBBUB |
     +--------++------+       +----------+
            |                     ^
            v                     |
        +--------+            +--------+
        |  DPP   |            |  DWB   |
        +--------+            +--------+
            |
            v                      ^
        +--------+                 |
        |  MPC   |                 |
        +--------+                 |
            |                      |
            v                      |
        +-------+      +-------+   |
        |  OPP  | <--> |  DSC  |   |
        +-------+      +-------+   |
            |                      |
            v                      |
        +--------+                /
        |  OPTC  |  --------------
        +--------+
            |
            v
        +--------+       +--------+
        |  DIO   |       |  DCCG  |
        +--------+       +--------+
    
    v2: rebase (Alex)
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
index c38c85c8e3b9..d99b1fc8f2df 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -203,7 +203,165 @@ static void enc2_stream_encoder_stop_hdmi_info_packets(
 		HDMI_GENERIC7_LINE, 0);
 }
 
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+struct dc_info_packet_128 {
+	bool valid;
+	uint8_t hb0;
+	uint8_t hb1;
+	uint8_t hb2;
+	uint8_t hb3;
+	uint8_t sb[128];
+};
+
+/* Update GSP7 SDP 128 byte long */
+static void enc2_send_gsp7_128_info_packet(
+	struct dcn10_stream_encoder *enc1,
+	const struct dc_info_packet_128 *info_packet)
+{
+	uint32_t i;
+
+	/* TODOFPGA Figure out a proper number for max_retries polling for lock
+	 * use 50 for now.
+	 */
+	uint32_t max_retries = 50;
+	const uint32_t *content = (const uint32_t *) &info_packet->sb[0];
+
+	ASSERT(info_packet->hb1  == DC_DP_INFOFRAME_TYPE_PPS);
+
+	/* Configure for PPS packet size (128 bytes) */
+	REG_UPDATE(DP_SEC_CNTL2, DP_SEC_GSP7_PPS, 1);
+
+	/* We need turn on clock before programming AFMT block*/
+	REG_UPDATE(AFMT_CNTL, AFMT_AUDIO_CLOCK_EN, 1);
+
+	/* Poll dig_update_lock is not locked -> asic internal signal
+	 * assumes otg master lock will unlock it
+	 */
+	/*REG_WAIT(AFMT_VBI_PACKET_CONTROL, AFMT_GENERIC_LOCK_STATUS, 0, 10, max_retries);*/
 
+	/* Wait for HW/SW GSP memory access conflict to go away */
+	REG_WAIT(AFMT_VBI_PACKET_CONTROL, AFMT_GENERIC_CONFLICT,
+			0, 10, max_retries);
+
+	/* Clear HW/SW memory access conflict flag */
+	REG_UPDATE(AFMT_VBI_PACKET_CONTROL, AFMT_GENERIC_CONFLICT_CLR, 1);
+
+	/* write generic packet header */
+	REG_UPDATE(AFMT_VBI_PACKET_CONTROL, AFMT_GENERIC_INDEX, 7);
+	REG_SET_4(AFMT_GENERIC_HDR, 0,
+			AFMT_GENERIC_HB0, info_packet->hb0,
+			AFMT_GENERIC_HB1, info_packet->hb1,
+			AFMT_GENERIC_HB2, info_packet->hb2,
+			AFMT_GENERIC_HB3, info_packet->hb3);
+
+	/* Write generic packet content 128 bytes long. Four sets are used (indexes 7
+	 * through 10) to fit 128 bytes.
+	 */
+	for (i = 0; i < 4; i++) {
+		uint32_t packet_index = 7 + i;
+		REG_UPDATE(AFMT_VBI_PACKET_CONTROL, AFMT_GENERIC_INDEX, packet_index);
+
+		REG_WRITE(AFMT_GENERIC_0, *content++);
+		REG_WRITE(AFMT_GENERIC_1, *content++);
+		REG_WRITE(AFMT_GENERIC_2, *content++);
+		REG_WRITE(AFMT_GENERIC_3, *content++);
+		REG_WRITE(AFMT_GENERIC_4, *content++);
+		REG_WRITE(AFMT_GENERIC_5, *content++);
+		REG_WRITE(AFMT_GENERIC_6, *content++);
+		REG_WRITE(AFMT_GENERIC_7, *content++);
+	}
+
+	REG_UPDATE(AFMT_VBI_PACKET_CONTROL1, AFMT_GENERIC7_FRAME_UPDATE, 1);
+}
+
+/* Set DSC-related configuration.
+ *   dsc_mode: 0 disables DSC, other values enable DSC in specified format
+ *   sc_bytes_per_pixel: Bytes per pixel in u3.28 format
+ *   dsc_slice_width: Slice width in pixels
+ */
+static void enc2_dp_set_dsc_config(struct stream_encoder *enc,
+					enum optc_dsc_mode dsc_mode,
+					uint32_t dsc_bytes_per_pixel,
+					uint32_t dsc_slice_width,
+					uint8_t *dsc_packed_pps)
+{
+	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
+
+	REG_UPDATE_2(DP_DSC_CNTL,
+			DP_DSC_MODE, dsc_mode,
+			DP_DSC_SLICE_WIDTH, dsc_slice_width);
+
+	REG_SET(DP_DSC_BYTES_PER_PIXEL, 0,
+		DP_DSC_BYTES_PER_PIXEL, dsc_bytes_per_pixel);
+
+	if (dsc_mode != OPTC_DSC_DISABLED) {
+		struct dc_info_packet_128 pps_sdp;
+
+		ASSERT(dsc_packed_pps);
+
+		/* Load PPS into infoframe (SDP) registers */
+		pps_sdp.valid = true;
+		pps_sdp.hb0 = 0;
+		pps_sdp.hb1 = DC_DP_INFOFRAME_TYPE_PPS;
+		pps_sdp.hb2 = 127;
+		pps_sdp.hb3 = 0;
+		memcpy(&pps_sdp.sb[0], dsc_packed_pps, sizeof(pps_sdp.sb));
+		enc2_send_gsp7_128_info_packet(enc1, &pps_sdp);
+
+		/* Enable Generic Stream Packet 7 (GSP) transmission */
+		//REG_UPDATE(DP_SEC_CNTL,
+		//	DP_SEC_GSP7_ENABLE, 1);
+
+		/* SW should make sure VBID[6] update line number is bigger
+		 * than PPS transmit line number
+		 */
+		REG_UPDATE(DP_SEC_CNTL6,
+				DP_SEC_GSP7_LINE_NUM, 2);
+		REG_UPDATE_2(DP_MSA_VBID_MISC,
+				DP_VBID6_LINE_REFERENCE, 0,
+				DP_VBID6_LINE_NUM, 3);
+
+		/* Send PPS data at the line number specified above.
+		 * DP spec requires PPS to be sent only when it changes, however since
+		 * decoder has to be able to handle its change on every frame, we're
+		 * sending it always (i.e. on every frame) to reduce the chance it'd be
+		 * missed by decoder. If it turns out required to send PPS only when it
+		 * changes, we can use DP_SEC_GSP7_SEND register.
+		 */
+		REG_UPDATE_2(DP_SEC_CNTL,
+			DP_SEC_GSP7_ENABLE, 1,
+			DP_SEC_STREAM_ENABLE, 1);
+	} else {
+		/* Disable Generic Stream Packet 7 (GSP) transmission */
+		REG_UPDATE(DP_SEC_CNTL, DP_SEC_GSP7_ENABLE, 0);
+		REG_UPDATE(DP_SEC_CNTL2, DP_SEC_GSP7_PPS, 0);
+	}
+}
+#endif
+
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+/* this function read dsc related register fields to be logged later in dcn10_log_hw_state
+ * into a dcn_dsc_state struct.
+ */
+static void enc2_read_state(struct stream_encoder *enc, struct enc_state *s)
+{
+	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
+
+	//if dsc is enabled, continue to read
+	REG_GET(DP_DSC_CNTL, DP_DSC_MODE, &s->dsc_mode);
+	if (s->dsc_mode) {
+		REG_GET(DP_DSC_CNTL, DP_DSC_SLICE_WIDTH, &s->dsc_slice_width);
+		REG_GET(DP_SEC_CNTL6, DP_SEC_GSP7_LINE_NUM, &s->sec_gsp7_line_num);
+
+		REG_GET(DP_SEC_CNTL6, DP_SEC_GSP7_LINE_NUM, &s->sec_gsp7_line_num);
+		REG_GET(DP_MSA_VBID_MISC, DP_VBID6_LINE_REFERENCE, &s->vbid6_line_reference);
+		REG_GET(DP_MSA_VBID_MISC, DP_VBID6_LINE_NUM, &s->vbid6_line_num);
+
+		REG_GET(DP_SEC_CNTL, DP_SEC_GSP7_ENABLE, &s->sec_gsp7_enable);
+		REG_GET(DP_SEC_CNTL, DP_SEC_STREAM_ENABLE, &s->sec_stream_enable);
+	}
+}
+#endif
 
 /* Set Dynamic Metadata-configuration.
  *   enable_dme:         TRUE: enables Dynamic Metadata Enfine, FALSE: disables DME
@@ -283,6 +441,10 @@ static bool is_two_pixels_per_containter(const struct dc_crtc_timing *timing)
 {
 	bool two_pix = timing->pixel_encoding == PIXEL_ENCODING_YCBCR420;
 
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+	two_pix = two_pix || (timing->flags.DSC && timing->pixel_encoding == PIXEL_ENCODING_YCBCR422
+			&& !timing->dsc_cfg.ycbcr422_simple);
+#endif
 	return two_pix;
 }
 
@@ -416,7 +578,13 @@ static const struct stream_encoder_funcs dcn20_str_enc_funcs = {
 	.setup_stereo_sync  = enc1_setup_stereo_sync,
 	.set_avmute = enc1_stream_encoder_set_avmute,
 	.dig_connect_to_otg  = enc1_dig_connect_to_otg,
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+	.enc_read_state = enc2_read_state,
+#endif
 
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+	.dp_set_dsc_config = enc2_dp_set_dsc_config,
+#endif
 	.set_dynamic_metadata = enc2_set_dynamic_metadata,
 };
 

commit ca4d9b3a5a3b70da5af1f48d36e181cdebe77e2c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue May 7 14:50:05 2019 -0500

    drm/amd/display: Add DCN2 DIO
    
    Add support for the DIO (Display IO)  block of DCN2, which entails our
    stream and link encoders.
    
    HW Blocks:
    
        +--------+
        |  DIO   |
        +--------+
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
new file mode 100644
index 000000000000..c38c85c8e3b9
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_stream_encoder.c
@@ -0,0 +1,440 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ *  and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dc_bios_types.h"
+#include "dcn20_stream_encoder.h"
+#include "reg_helper.h"
+#include "hw_shared.h"
+
+#define DC_LOGGER \
+		enc1->base.ctx->logger
+
+
+#define REG(reg)\
+	(enc1->regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	enc1->se_shift->field_name, enc1->se_mask->field_name
+
+
+#define CTX \
+	enc1->base.ctx
+
+
+static void enc2_update_hdmi_info_packet(
+	struct dcn10_stream_encoder *enc1,
+	uint32_t packet_index,
+	const struct dc_info_packet *info_packet)
+{
+	uint32_t cont, send, line;
+
+	if (info_packet->valid) {
+		enc1_update_generic_info_packet(
+			enc1,
+			packet_index,
+			info_packet);
+
+		/* enable transmission of packet(s) -
+		 * packet transmission begins on the next frame */
+		cont = 1;
+		/* send packet(s) every frame */
+		send = 1;
+		/* select line number to send packets on */
+		line = 2;
+	} else {
+		cont = 0;
+		send = 0;
+		line = 0;
+	}
+
+	/* DP_SEC_GSP[x]_LINE_REFERENCE - keep default value REFER_TO_DP_SOF */
+
+	/* choose which generic packet control to use */
+	switch (packet_index) {
+	case 0:
+		REG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,
+				HDMI_GENERIC0_CONT, cont,
+				HDMI_GENERIC0_SEND, send);
+		REG_UPDATE(HDMI_GENERIC_PACKET_CONTROL1,
+				HDMI_GENERIC0_LINE, line);
+		break;
+	case 1:
+		REG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,
+				HDMI_GENERIC1_CONT, cont,
+				HDMI_GENERIC1_SEND, send);
+		REG_UPDATE(HDMI_GENERIC_PACKET_CONTROL1,
+				HDMI_GENERIC1_LINE, line);
+		break;
+	case 2:
+		REG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,
+				HDMI_GENERIC2_CONT, cont,
+				HDMI_GENERIC2_SEND, send);
+		REG_UPDATE(HDMI_GENERIC_PACKET_CONTROL2,
+				HDMI_GENERIC2_LINE, line);
+		break;
+	case 3:
+		REG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,
+				HDMI_GENERIC3_CONT, cont,
+				HDMI_GENERIC3_SEND, send);
+		REG_UPDATE(HDMI_GENERIC_PACKET_CONTROL2,
+				HDMI_GENERIC3_LINE, line);
+		break;
+	case 4:
+		REG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,
+				HDMI_GENERIC4_CONT, cont,
+				HDMI_GENERIC4_SEND, send);
+		REG_UPDATE(HDMI_GENERIC_PACKET_CONTROL3,
+				HDMI_GENERIC4_LINE, line);
+		break;
+	case 5:
+		REG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,
+				HDMI_GENERIC5_CONT, cont,
+				HDMI_GENERIC5_SEND, send);
+		REG_UPDATE(HDMI_GENERIC_PACKET_CONTROL3,
+				HDMI_GENERIC5_LINE, line);
+		break;
+	case 6:
+		REG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,
+				HDMI_GENERIC6_CONT, cont,
+				HDMI_GENERIC6_SEND, send);
+		REG_UPDATE(HDMI_GENERIC_PACKET_CONTROL4,
+				HDMI_GENERIC6_LINE, line);
+		break;
+	case 7:
+		REG_UPDATE_2(HDMI_GENERIC_PACKET_CONTROL0,
+				HDMI_GENERIC7_CONT, cont,
+				HDMI_GENERIC7_SEND, send);
+		REG_UPDATE(HDMI_GENERIC_PACKET_CONTROL4,
+				HDMI_GENERIC7_LINE, line);
+		break;
+	default:
+		/* invalid HW packet index */
+		DC_LOG_WARNING(
+			"Invalid HW packet index: %s()\n",
+			__func__);
+		return;
+	}
+}
+
+static void enc2_stream_encoder_update_hdmi_info_packets(
+	struct stream_encoder *enc,
+	const struct encoder_info_frame *info_frame)
+{
+	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
+
+	/* for bring up, disable dp double  TODO */
+	REG_UPDATE(HDMI_DB_CONTROL, HDMI_DB_DISABLE, 1);
+
+	/*Always add mandatory packets first followed by optional ones*/
+	enc2_update_hdmi_info_packet(enc1, 0, &info_frame->avi);
+	enc2_update_hdmi_info_packet(enc1, 5, &info_frame->hfvsif);
+	enc2_update_hdmi_info_packet(enc1, 2, &info_frame->gamut);
+	enc2_update_hdmi_info_packet(enc1, 1, &info_frame->vendor);
+	enc2_update_hdmi_info_packet(enc1, 3, &info_frame->spd);
+	enc2_update_hdmi_info_packet(enc1, 4, &info_frame->hdrsmd);
+}
+
+static void enc2_stream_encoder_stop_hdmi_info_packets(
+	struct stream_encoder *enc)
+{
+	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
+
+	/* stop generic packets 0,1 on HDMI */
+	REG_SET_4(HDMI_GENERIC_PACKET_CONTROL0, 0,
+		HDMI_GENERIC0_CONT, 0,
+		HDMI_GENERIC0_SEND, 0,
+		HDMI_GENERIC1_CONT, 0,
+		HDMI_GENERIC1_SEND, 0);
+	REG_SET_2(HDMI_GENERIC_PACKET_CONTROL1, 0,
+		HDMI_GENERIC0_LINE, 0,
+		HDMI_GENERIC1_LINE, 0);
+
+	/* stop generic packets 2,3 on HDMI */
+	REG_SET_4(HDMI_GENERIC_PACKET_CONTROL0, 0,
+		HDMI_GENERIC2_CONT, 0,
+		HDMI_GENERIC2_SEND, 0,
+		HDMI_GENERIC3_CONT, 0,
+		HDMI_GENERIC3_SEND, 0);
+	REG_SET_2(HDMI_GENERIC_PACKET_CONTROL2, 0,
+		HDMI_GENERIC2_LINE, 0,
+		HDMI_GENERIC3_LINE, 0);
+
+	/* stop generic packets 4,5 on HDMI */
+	REG_SET_4(HDMI_GENERIC_PACKET_CONTROL0, 0,
+		HDMI_GENERIC4_CONT, 0,
+		HDMI_GENERIC4_SEND, 0,
+		HDMI_GENERIC5_CONT, 0,
+		HDMI_GENERIC5_SEND, 0);
+	REG_SET_2(HDMI_GENERIC_PACKET_CONTROL3, 0,
+		HDMI_GENERIC4_LINE, 0,
+		HDMI_GENERIC5_LINE, 0);
+
+	/* stop generic packets 6,7 on HDMI */
+	REG_SET_4(HDMI_GENERIC_PACKET_CONTROL0, 0,
+		HDMI_GENERIC6_CONT, 0,
+		HDMI_GENERIC6_SEND, 0,
+		HDMI_GENERIC7_CONT, 0,
+		HDMI_GENERIC7_SEND, 0);
+	REG_SET_2(HDMI_GENERIC_PACKET_CONTROL4, 0,
+		HDMI_GENERIC6_LINE, 0,
+		HDMI_GENERIC7_LINE, 0);
+}
+
+
+
+/* Set Dynamic Metadata-configuration.
+ *   enable_dme:         TRUE: enables Dynamic Metadata Enfine, FALSE: disables DME
+ *   hubp_requestor_id:  HUBP physical instance that is the source of dynamic metadata
+ *                       only needs to be set when enable_dme is TRUE
+ *   dmdata_mode:        dynamic metadata packet type: DP, HDMI, or Dolby Vision
+ *
+ *   Ensure the OTG master update lock is set when changing DME configuration.
+ */
+static void enc2_set_dynamic_metadata(struct stream_encoder *enc,
+		bool enable_dme,
+		uint32_t hubp_requestor_id,
+		enum dynamic_metadata_mode dmdata_mode)
+{
+	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
+
+	if (enable_dme) {
+		REG_UPDATE_2(DME_CONTROL,
+				METADATA_HUBP_REQUESTOR_ID, hubp_requestor_id,
+				METADATA_STREAM_TYPE, (dmdata_mode == dmdata_dolby_vision) ? 1 : 0);
+
+		/* Use default line reference DP_SOF for bringup.
+		 * Should use OTG_SOF for DRR cases
+		 */
+		if (dmdata_mode == dmdata_dp)
+			REG_UPDATE_3(DP_SEC_METADATA_TRANSMISSION,
+					DP_SEC_METADATA_PACKET_ENABLE, 1,
+					DP_SEC_METADATA_PACKET_LINE_REFERENCE, 0,
+					DP_SEC_METADATA_PACKET_LINE, 20);
+		else {
+			REG_UPDATE_3(HDMI_METADATA_PACKET_CONTROL,
+					HDMI_METADATA_PACKET_ENABLE, 1,
+					HDMI_METADATA_PACKET_LINE_REFERENCE, 0,
+					HDMI_METADATA_PACKET_LINE, 2);
+
+			if (dmdata_mode == dmdata_dolby_vision)
+				REG_UPDATE(DIG_FE_CNTL,
+						DOLBY_VISION_EN, 1);
+		}
+
+		REG_UPDATE(DME_CONTROL,
+				METADATA_ENGINE_EN, 1);
+	} else {
+		REG_UPDATE(DME_CONTROL,
+				METADATA_ENGINE_EN, 0);
+
+		if (dmdata_mode == dmdata_dp)
+			REG_UPDATE(DP_SEC_METADATA_TRANSMISSION,
+					DP_SEC_METADATA_PACKET_ENABLE, 0);
+		else {
+			REG_UPDATE(HDMI_METADATA_PACKET_CONTROL,
+					HDMI_METADATA_PACKET_ENABLE, 0);
+			REG_UPDATE(DIG_FE_CNTL,
+					DOLBY_VISION_EN, 0);
+		}
+	}
+}
+
+static void enc2_stream_encoder_update_dp_info_packets(
+	struct stream_encoder *enc,
+	const struct encoder_info_frame *info_frame)
+{
+	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
+	uint32_t dmdata_packet_enabled = 0;
+
+	enc1_stream_encoder_update_dp_info_packets(enc, info_frame);
+
+	/* check if dynamic metadata packet transmission is enabled */
+	REG_GET(DP_SEC_METADATA_TRANSMISSION,
+			DP_SEC_METADATA_PACKET_ENABLE, &dmdata_packet_enabled);
+
+	if (dmdata_packet_enabled)
+		REG_UPDATE(DP_SEC_CNTL, DP_SEC_STREAM_ENABLE, 1);
+}
+
+static bool is_two_pixels_per_containter(const struct dc_crtc_timing *timing)
+{
+	bool two_pix = timing->pixel_encoding == PIXEL_ENCODING_YCBCR420;
+
+	return two_pix;
+}
+
+static void enc2_stream_encoder_dp_unblank(
+		struct stream_encoder *enc,
+		const struct encoder_unblank_param *param)
+{
+	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
+
+	if (param->link_settings.link_rate != LINK_RATE_UNKNOWN) {
+		uint32_t n_vid = 0x8000;
+		uint32_t m_vid;
+		uint32_t n_multiply = 0;
+		uint64_t m_vid_l = n_vid;
+
+		/* YCbCr 4:2:0 : Computed VID_M will be 2X the input rate */
+		if (is_two_pixels_per_containter(&param->timing) || param->odm) {
+			/*this logic should be the same in get_pixel_clock_parameters() */
+			n_multiply = 1;
+		}
+		/* M / N = Fstream / Flink
+		 * m_vid / n_vid = pixel rate / link rate
+		 */
+
+		m_vid_l *= param->timing.pix_clk_100hz / 10;
+		m_vid_l = div_u64(m_vid_l,
+			param->link_settings.link_rate
+				* LINK_RATE_REF_FREQ_IN_KHZ);
+
+		m_vid = (uint32_t) m_vid_l;
+
+		/* enable auto measurement */
+
+		REG_UPDATE(DP_VID_TIMING, DP_VID_M_N_GEN_EN, 0);
+
+		/* auto measurement need 1 full 0x8000 symbol cycle to kick in,
+		 * therefore program initial value for Mvid and Nvid
+		 */
+
+		REG_UPDATE(DP_VID_N, DP_VID_N, n_vid);
+
+		REG_UPDATE(DP_VID_M, DP_VID_M, m_vid);
+
+		REG_UPDATE_2(DP_VID_TIMING,
+				DP_VID_M_N_GEN_EN, 1,
+				DP_VID_N_MUL, n_multiply);
+	}
+
+	/* set DIG_START to 0x1 to reset FIFO */
+
+	REG_UPDATE(DIG_FE_CNTL, DIG_START, 1);
+
+	/* write 0 to take the FIFO out of reset */
+
+	REG_UPDATE(DIG_FE_CNTL, DIG_START, 0);
+
+	/* switch DP encoder to CRTC data */
+
+	REG_UPDATE(DP_STEER_FIFO, DP_STEER_FIFO_RESET, 0);
+
+	/* wait 100us for DIG/DP logic to prime
+	 * (i.e. a few video lines)
+	 */
+	udelay(100);
+
+	/* the hardware would start sending video at the start of the next DP
+	 * frame (i.e. rising edge of the vblank).
+	 * NOTE: We used to program DP_VID_STREAM_DIS_DEFER = 2 here, but this
+	 * register has no effect on enable transition! HW always guarantees
+	 * VID_STREAM enable at start of next frame, and this is not
+	 * programmable
+	 */
+
+	REG_UPDATE(DP_VID_STREAM_CNTL, DP_VID_STREAM_ENABLE, true);
+}
+
+static void enc2_dp_set_odm_combine(
+	struct stream_encoder *enc,
+	bool odm_combine)
+{
+	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
+
+	REG_UPDATE(DP_PIXEL_FORMAT, DP_PIXEL_COMBINE, odm_combine);
+}
+
+static void enc2_stream_encoder_dp_set_stream_attribute(
+	struct stream_encoder *enc,
+	struct dc_crtc_timing *crtc_timing,
+	enum dc_color_space output_color_space,
+	uint32_t enable_sdp_splitting)
+{
+	struct dcn10_stream_encoder *enc1 = DCN10STRENC_FROM_STRENC(enc);
+
+	enc1_stream_encoder_dp_set_stream_attribute(enc, crtc_timing, output_color_space, enable_sdp_splitting);
+
+	REG_UPDATE(DP_SEC_FRAMING4,
+		DP_SST_SDP_SPLITTING, enable_sdp_splitting);
+}
+
+static const struct stream_encoder_funcs dcn20_str_enc_funcs = {
+	.dp_set_odm_combine =
+		enc2_dp_set_odm_combine,
+	.dp_set_stream_attribute =
+		enc2_stream_encoder_dp_set_stream_attribute,
+	.hdmi_set_stream_attribute =
+		enc1_stream_encoder_hdmi_set_stream_attribute,
+	.dvi_set_stream_attribute =
+		enc1_stream_encoder_dvi_set_stream_attribute,
+	.set_mst_bandwidth =
+		enc1_stream_encoder_set_mst_bandwidth,
+	.update_hdmi_info_packets =
+		enc2_stream_encoder_update_hdmi_info_packets,
+	.stop_hdmi_info_packets =
+		enc2_stream_encoder_stop_hdmi_info_packets,
+	.update_dp_info_packets =
+		enc2_stream_encoder_update_dp_info_packets,
+	.stop_dp_info_packets =
+		enc1_stream_encoder_stop_dp_info_packets,
+	.dp_blank =
+		enc1_stream_encoder_dp_blank,
+	.dp_unblank =
+		enc2_stream_encoder_dp_unblank,
+	.audio_mute_control = enc1_se_audio_mute_control,
+
+	.dp_audio_setup = enc1_se_dp_audio_setup,
+	.dp_audio_enable = enc1_se_dp_audio_enable,
+	.dp_audio_disable = enc1_se_dp_audio_disable,
+
+	.hdmi_audio_setup = enc1_se_hdmi_audio_setup,
+	.hdmi_audio_disable = enc1_se_hdmi_audio_disable,
+	.setup_stereo_sync  = enc1_setup_stereo_sync,
+	.set_avmute = enc1_stream_encoder_set_avmute,
+	.dig_connect_to_otg  = enc1_dig_connect_to_otg,
+
+	.set_dynamic_metadata = enc2_set_dynamic_metadata,
+};
+
+void dcn20_stream_encoder_construct(
+	struct dcn10_stream_encoder *enc1,
+	struct dc_context *ctx,
+	struct dc_bios *bp,
+	enum engine_id eng_id,
+	const struct dcn10_stream_enc_registers *regs,
+	const struct dcn10_stream_encoder_shift *se_shift,
+	const struct dcn10_stream_encoder_mask *se_mask)
+{
+	enc1->base.funcs = &dcn20_str_enc_funcs;
+	enc1->base.ctx = ctx;
+	enc1->base.id = eng_id;
+	enc1->base.bp = bp;
+	enc1->regs = regs;
+	enc1->se_shift = se_shift;
+	enc1->se_mask = se_mask;
+}
+
