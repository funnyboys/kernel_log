commit a8665946f39aff519f363ebd7c1013c673cb31a1
Author: Wenjing Liu <wenjing.liu@amd.com>
Date:   Tue Mar 31 12:32:53 2020 -0400

    drm/amd/display: add optc get crc support for timings with ODM/DSC
    
    [why]
    Optc needs to know if timing is enabled with ODM or DSC before computing
    crc.  Otherwise value computed will be inaccurate. Before this change,
    the CRC computed without ODM is not equal to the CRC computed with ODM
    for the same timing. This is unexpected as we are driving the same
    timing despite of the underlaying hardware setup to achieve it. This is
    caused by missing hardware programming sequence to support it.
    
    [how]
    Add the new programming sequence based on hardware guide.
    
    Signed-off-by: Wenjing Liu <wenjing.liu@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index d875b0c38fde..8c16967fe018 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -409,6 +409,18 @@ void optc2_program_manual_trigger(struct timing_generator *optc)
 			OTG_TRIGA_MANUAL_TRIG, 1);
 }
 
+bool optc2_configure_crc(struct timing_generator *optc,
+			  const struct crc_params *params)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	REG_SET_2(OTG_CRC_CNTL2, 0,
+			OTG_CRC_DSC_MODE, params->dsc_mode,
+			OTG_CRC_DATA_STREAM_COMBINE_MODE, params->odm_mode);
+
+	return optc1_configure_crc(optc, params);
+}
+
 static struct timing_generator_funcs dcn20_tg_funcs = {
 		.validate_timing = optc1_validate_timing,
 		.program_timing = optc1_program_timing,
@@ -452,7 +464,7 @@ static struct timing_generator_funcs dcn20_tg_funcs = {
 		.clear_optc_underflow = optc1_clear_optc_underflow,
 		.setup_global_swap_lock = NULL,
 		.get_crc = optc1_get_crc,
-		.configure_crc = optc1_configure_crc,
+		.configure_crc = optc2_configure_crc,
 		.set_dsc_config = optc2_set_dsc_config,
 		.set_dwb_source = optc2_set_dwb_source,
 		.set_odm_bypass = optc2_set_odm_bypass,

commit 830806c5654bc8ef0c5b98ce0ac381e3629a894d
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Wed Dec 4 17:59:14 2019 -0500

    drm/amd/display: Fix manual trigger source for DCN2
    
    Fix manual trigger source correctly be TRIGA for DCN2
    rather than MANUAL_FLOW.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index 9b36fec549d7..d875b0c38fde 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -390,14 +390,8 @@ void optc2_setup_manual_trigger(struct timing_generator *optc)
 {
 	struct optc *optc1 = DCN10TG_FROM_TG(optc);
 
-	REG_SET(OTG_MANUAL_FLOW_CONTROL, 0,
-			MANUAL_FLOW_CONTROL, 1);
-
-	REG_SET(OTG_GLOBAL_CONTROL2, 0,
-			MANUAL_FLOW_CONTROL_SEL, optc->inst);
-
 	REG_SET_8(OTG_TRIGA_CNTL, 0,
-			OTG_TRIGA_SOURCE_SELECT, 22,
+			OTG_TRIGA_SOURCE_SELECT, 21,
 			OTG_TRIGA_SOURCE_PIPE_SELECT, optc->inst,
 			OTG_TRIGA_RISING_EDGE_DETECT_CNTL, 1,
 			OTG_TRIGA_FALLING_EDGE_DETECT_CNTL, 0,

commit ec5b356c58941bb8930858155d9ce14ceb3d30a0
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Tue Nov 26 15:18:31 2019 -0500

    drm/amd/display: Map ODM memory correctly when doing ODM combine
    
    [why]
    Up to 4 ODM memory pieces are required per ODM combine and cannot
    overlap, i.e. each ODM "session" has to use its own memory pieces.
    The ODM-memory mapping is currently broken for generic case.
    
    The maximum number of memory pieces is ASIC-dependent, but it's always
    big enough to satisfy maximum number of ODM combines. Memory pieces
    are mapped as a bit-map, i.e. one memory piece corresponds to one bit.
    The OPTC doing ODM needs to select memory pieces by setting the
    corresponding bits, making sure there's no overlap with other OPTC
    instances that might be doing ODM.
    
    The current mapping works only for OPTC instance indexes smaller than
    3. For instance indexes 3 and up it practically maps no ODM memory,
    causing black, gray or white screen in display configs that include
    ODM on OPTC instance 3 or up.
    
    [how]
    Statically map two unique ODM memory pieces for each OPTC instance
    and piece them together when programming ODM combine mode.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index 673c83e2afd4..9b36fec549d7 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -236,12 +236,13 @@ void optc2_set_odm_combine(struct timing_generator *optc, int *opp_id, int opp_c
 		struct dc_crtc_timing *timing)
 {
 	struct optc *optc1 = DCN10TG_FROM_TG(optc);
-	/* 2 pieces of memory required for up to 5120 displays, 4 for up to 8192 */
 	int mpcc_hactive = (timing->h_addressable + timing->h_border_left + timing->h_border_right)
 			/ opp_cnt;
-	int memory_mask = mpcc_hactive <= 2560 ? 0x3 : 0xf;
+	uint32_t memory_mask;
 	uint32_t data_fmt = 0;
 
+	ASSERT(opp_cnt == 2);
+
 	/* TODO: In pseudocode but does not affect maximus, delete comment if we dont need on asic
 	 * REG_SET(OTG_GLOBAL_CONTROL2, 0, GLOBAL_UPDATE_LOCK_EN, 1);
 	 * Program OTG register MASTER_UPDATE_LOCK_DB_X/Y to the position before DP frame start
@@ -249,9 +250,17 @@ void optc2_set_odm_combine(struct timing_generator *optc, int *opp_id, int opp_c
 	 *		MASTER_UPDATE_LOCK_DB_X, 160,
 	 *		MASTER_UPDATE_LOCK_DB_Y, 240);
 	 */
+
+	/* 2 pieces of memory required for up to 5120 displays, 4 for up to 8192,
+	 * however, for ODM combine we can simplify by always using 4.
+	 * To make sure there's no overlap, each instance "reserves" 2 memories and
+	 * they are uniquely combined here.
+	 */
+	memory_mask = 0x3 << (opp_id[0] * 2) | 0x3 << (opp_id[1] * 2);
+
 	if (REG(OPTC_MEMORY_CONFIG))
 		REG_SET(OPTC_MEMORY_CONFIG, 0,
-			OPTC_MEM_SEL, memory_mask << (optc->inst * 4));
+			OPTC_MEM_SEL, memory_mask);
 
 	if (timing->pixel_encoding == PIXEL_ENCODING_YCBCR422)
 		data_fmt = 1;
@@ -260,7 +269,6 @@ void optc2_set_odm_combine(struct timing_generator *optc, int *opp_id, int opp_c
 
 	REG_UPDATE(OPTC_DATA_FORMAT_CONTROL, OPTC_DATA_FORMAT, data_fmt);
 
-	ASSERT(opp_cnt == 2);
 	REG_SET_3(OPTC_DATA_SOURCE_SELECT, 0,
 			OPTC_NUM_OF_INPUT_SEGMENT, 1,
 			OPTC_SEG0_SRC_SEL, opp_id[0],

commit ad51b4ac12f785aecf39f1a8b235e0681efde84b
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Mon Nov 18 13:31:04 2019 -0500

    drm/amd/display: Extend DMCUB offload testing into dcn20/21
    
    [Why]
    To quickly validate whether DMCUB is running and accepting commands for
    offload testing we want to intercept a common sequence as part of
    modeset programming.
    
    [How]
    OTG enable will cause the most impact in terms of golden register
    changes and it's a single register write.
    
    This approach was previously done in dcn10 code when it was shared with
    dcn20 but it wasn't ported over to the dcn20 code.
    
    Port over start, execute and wait sequence into dcn20_optc.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index f5854a5d2b76..673c83e2afd4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -59,11 +59,16 @@ bool optc2_enable_crtc(struct timing_generator *optc)
 	REG_UPDATE(CONTROL,
 			VTG0_ENABLE, 1);
 
+	REG_SEQ_START();
+
 	/* Enable CRTC */
 	REG_UPDATE_2(OTG_CONTROL,
 			OTG_DISABLE_POINT_CNTL, 3,
 			OTG_MASTER_EN, 1);
 
+	REG_SEQ_SUBMIT();
+	REG_SEQ_WAIT_DONE();
+
 	return true;
 }
 

commit 78c7738211e027f122ada3f59c2c5e8a83ee3c59
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Oct 29 15:05:56 2019 -0400

    drm/amd/display: cleanup of function pointer tables
    
    [Why]
    It is becoming increasingly hard to figure out which
    function is called on the different DCN versions
    
    [How]
    1. Make function pointer table init in its own init.c file
    2. Remove other scenarios in hwseq.c file that need to
    include headers of other DCN versions. (If needed,
    it should have been done via the function pointers)
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index 0e50dc9b611a..f5854a5d2b76 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -201,11 +201,11 @@ void optc2_set_dsc_config(struct timing_generator *optc,
 		OPTC_DSC_SLICE_WIDTH, dsc_slice_width);
 }
 
-/**
- * PTI i think is already done somewhere else for 2ka
- * (opp?, please double check.
- * OPTC side only has 1 register to set for PTI_ENABLE)
- */
+/*TEMP: Need to figure out inheritance model here.*/
+bool optc2_is_two_pixels_per_containter(const struct dc_crtc_timing *timing)
+{
+	return optc1_is_two_pixels_per_containter(timing);
+}
 
 void optc2_set_odm_bypass(struct timing_generator *optc,
 		const struct dc_crtc_timing *dc_crtc_timing)
@@ -219,7 +219,7 @@ void optc2_set_odm_bypass(struct timing_generator *optc,
 			OPTC_SEG1_SRC_SEL, 0xf);
 	REG_WRITE(OTG_H_TIMING_CNTL, 0);
 
-	h_div_2 = optc1_is_two_pixels_per_containter(dc_crtc_timing);
+	h_div_2 = optc2_is_two_pixels_per_containter(dc_crtc_timing);
 	REG_UPDATE(OTG_H_TIMING_CNTL,
 			OTG_H_TIMING_DIV_BY2, h_div_2);
 	REG_SET(OPTC_MEMORY_CONFIG, 0,

commit 1da37801a8b0fffb024fea594c7f1d7867ed8aa0
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:38:55 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_0 and DSC_SUPPORTED
    
    [Why]
    
    DCN2 and DSC are stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup NV defninitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN2 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * dce/dce_dmcu.c: dcn20_*lock_phy()
        * dce/dce_dmcu.c: dcn20_funcs
        * dce/dce_dmcu.c: dcn20_dmcu_create()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index 3b613fb93ef8..0e50dc9b611a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -167,7 +167,6 @@ void optc2_set_gsl_source_select(
 	}
 }
 
-#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 /* DSC encoder frame start controls: x = h position, line_num = # of lines from vstartup */
 void optc2_set_dsc_encoder_frame_start(struct timing_generator *optc,
 					int x_position,
@@ -201,7 +200,6 @@ void optc2_set_dsc_config(struct timing_generator *optc,
 	REG_UPDATE(OPTC_WIDTH_CONTROL,
 		OPTC_DSC_SLICE_WIDTH, dsc_slice_width);
 }
-#endif
 
 /**
  * PTI i think is already done somewhere else for 2ka
@@ -448,9 +446,7 @@ static struct timing_generator_funcs dcn20_tg_funcs = {
 		.setup_global_swap_lock = NULL,
 		.get_crc = optc1_get_crc,
 		.configure_crc = optc1_configure_crc,
-#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 		.set_dsc_config = optc2_set_dsc_config,
-#endif
 		.set_dwb_source = optc2_set_dwb_source,
 		.set_odm_bypass = optc2_set_odm_bypass,
 		.set_odm_combine = optc2_set_odm_combine,

commit 93c2340bdc24b6067a7621e71d4aacac1f85b5f2
Author: Martin Leung <martin.leung@amd.com>
Date:   Tue Sep 17 14:50:22 2019 -0400

    drm/amd/display: add more checks to validate seamless boot timing
    
    [why]
    we found using an active DP to HDMI panel that we weren't validating
    dp_pixel_format and hardware timing v_front_porch, causing screen to
    blank and/or corrupt while attempting a seamless boot.
    
    [how]
    added checks during dc_validate_seamless_boot_timing for these values
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index dda90995ba93..3b613fb93ef8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -460,7 +460,7 @@ static struct timing_generator_funcs dcn20_tg_funcs = {
 		.set_vtg_params = optc1_set_vtg_params,
 		.program_manual_trigger = optc2_program_manual_trigger,
 		.setup_manual_trigger = optc2_setup_manual_trigger,
-		.is_matching_timing = optc1_is_matching_timing
+		.get_hw_timing = optc1_get_hw_timing,
 };
 
 void dcn20_timing_generator_init(struct optc *optc1)

commit 2fef0faa1cdc5d41ce3ef83f7b8f7e7ecb02d700
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Wed Aug 28 18:30:43 2019 -0400

    drm/amd/display: Set number of pipes to 1 if the second pipe was disabled
    
    [why]
    Some ODM-related register settings are inconsistently updated by VBIOS, causing
    the state in DC to be invalid, which would then end up crashing in certain
    use-cases (such as disable/enable device).
    
    [how]
    Check the enabled status of the second pipe when determining the number of
    OPTC sources. If the second pipe is disabled, set the number of sources to 1
    regardless of other settings (that may not be updated correctly).
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index 2137e2be2140..dda90995ba93 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -287,6 +287,10 @@ void optc2_get_optc_source(struct timing_generator *optc,
 		*num_of_src_opp = 2;
 	else
 		*num_of_src_opp = 1;
+
+	/* Work around VBIOS not updating OPTC_NUM_OF_INPUT_SEGMENT */
+	if (*src_opp_id_1 == 0xf)
+		*num_of_src_opp = 1;
 }
 
 void optc2_set_dwb_source(struct timing_generator *optc,

commit 4c3cfe14c04eac5e96f1aef7e2b84ce56a61e897
Author: David Francis <David.Francis@amd.com>
Date:   Thu May 23 14:06:08 2019 -0400

    Revert "drm/amd/display: add global master update lock for DCN2"
    
    This reverts commit 6c5be4ac630805d3a3b20157a0c6421ef815fe78.
    
    This commit was accidentally promoted twice
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index 99070e93020b..2137e2be2140 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -333,65 +333,6 @@ void optc2_triplebuffer_unlock(struct timing_generator *optc)
 
 }
 
-
-void optc2_setup_global_lock(struct timing_generator *optc)
-{
-	struct optc *optc1 = DCN10TG_FROM_TG(optc);
-	uint32_t v_blank_start = 0;
-	uint32_t h_blank_start = 0, h_total = 0;
-
-	REG_SET(OTG_GLOBAL_CONTROL1, 0, MASTER_UPDATE_LOCK_DB_EN, 1);
-
-	REG_SET(OTG_GLOBAL_CONTROL2, 0, DIG_UPDATE_LOCATION, 20);
-
-	REG_GET(OTG_V_BLANK_START_END, OTG_V_BLANK_START, &v_blank_start);
-
-	REG_GET(OTG_H_BLANK_START_END, OTG_H_BLANK_START, &h_blank_start);
-
-	REG_GET(OTG_H_TOTAL, OTG_H_TOTAL, &h_total);
-	REG_UPDATE_2(OTG_GLOBAL_CONTROL1,
-			MASTER_UPDATE_LOCK_DB_X,
-			h_blank_start - 200 - 1,
-			MASTER_UPDATE_LOCK_DB_Y,
-			v_blank_start - 1);
-}
-
-void optc2_lock_global(struct timing_generator *optc)
-{
-	struct optc *optc1 = DCN10TG_FROM_TG(optc);
-
-	REG_UPDATE(OTG_GLOBAL_CONTROL2, GLOBAL_UPDATE_LOCK_EN, 1);
-
-	REG_SET(OTG_GLOBAL_CONTROL0, 0,
-			OTG_MASTER_UPDATE_LOCK_SEL, optc->inst);
-	REG_SET(OTG_MASTER_UPDATE_LOCK, 0,
-			OTG_MASTER_UPDATE_LOCK, 1);
-
-	/* Should be fast, status does not update on maximus */
-	if (optc->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
-		REG_WAIT(OTG_MASTER_UPDATE_LOCK,
-				UPDATE_LOCK_STATUS, 1,
-				1, 10);
-}
-
-void optc2_lock(struct timing_generator *optc)
-{
-	struct optc *optc1 = DCN10TG_FROM_TG(optc);
-
-	REG_UPDATE(OTG_GLOBAL_CONTROL2, GLOBAL_UPDATE_LOCK_EN, 0);
-
-	REG_SET(OTG_GLOBAL_CONTROL0, 0,
-			OTG_MASTER_UPDATE_LOCK_SEL, optc->inst);
-	REG_SET(OTG_MASTER_UPDATE_LOCK, 0,
-			OTG_MASTER_UPDATE_LOCK, 1);
-
-	/* Should be fast, status does not update on maximus */
-	if (optc->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
-		REG_WAIT(OTG_MASTER_UPDATE_LOCK,
-				UPDATE_LOCK_STATUS, 1,
-				1, 10);
-}
-
 void optc2_lock_doublebuffer_enable(struct timing_generator *optc)
 {
 	struct optc *optc1 = DCN10TG_FROM_TG(optc);
@@ -486,10 +427,8 @@ static struct timing_generator_funcs dcn20_tg_funcs = {
 		.triplebuffer_lock = optc2_triplebuffer_lock,
 		.triplebuffer_unlock = optc2_triplebuffer_unlock,
 		.disable_reset_trigger = optc1_disable_reset_trigger,
-		.lock = optc2_lock,
+		.lock = optc1_lock,
 		.unlock = optc1_unlock,
-		.lock_global = optc2_lock_global,
-		.setup_global_lock = optc2_setup_global_lock,
 		.lock_doublebuffer_enable = optc2_lock_doublebuffer_enable,
 		.lock_doublebuffer_disable = optc2_lock_doublebuffer_disable,
 		.enable_optc_clock = optc1_enable_optc_clock,

commit aadeb6081b6e7ecbf6028b006b50f37c54a4e4fd
Author: David Francis <David.Francis@amd.com>
Date:   Thu Mar 28 13:52:00 2019 -0400

    Revert "drm/amd/display: skip dsc config for navi10 bring up"
    
    This reverts commit 9e14d4f17e23ce46d346a6a22a295b4a65b9d918.
    
    optc dsc config was causing warnings due to missing register
    definitions. With the registers restored, the function can
    be re-enabled
    
    The reverted commit also disabled sanity checks and dsc
    power gating. The sanity check warnings are not associated
    with dsc, and power gating on dsc still has an issue on
    non-dsc monitors where the dsc hardware block is never init
    and so cannot respond to power gating requests. Therefore,
    those are left as is
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index aedf9de1c947..99070e93020b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -191,15 +191,6 @@ void optc2_set_dsc_config(struct timing_generator *optc,
 					uint32_t dsc_slice_width)
 {
 	struct optc *optc1 = DCN10TG_FROM_TG(optc);
-	uint32_t data_format = 0;
-	/* skip if dsc mode is not changed */
-	data_format = dm_read_reg(CTX, REG(OPTC_DATA_FORMAT_CONTROL));
-
-	data_format = data_format & 0x30; /* bit5:4 */
-	data_format = data_format >> 4;
-
-	if (data_format == dsc_mode)
-		return;
 
 	REG_UPDATE(OPTC_DATA_FORMAT_CONTROL,
 		OPTC_DSC_MODE, dsc_mode);

commit 2b162fd3024997b97c95290b0a8ed08d914f115d
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jul 19 11:43:39 2019 -0400

    drm/amd/display: update optc odm interface for more than 2 opps
    
    Current optc odm interface only accepts 2 opps, we need to
    expand this to allow 4 to 1 odm combine.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index 6dede495d0fd..aedf9de1c947 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -224,7 +224,6 @@ void optc2_set_odm_bypass(struct timing_generator *optc,
 	struct optc *optc1 = DCN10TG_FROM_TG(optc);
 	uint32_t h_div_2 = 0;
 
-	optc1->comb_opp_id = 0xf;
 	REG_SET_3(OPTC_DATA_SOURCE_SELECT, 0,
 			OPTC_NUM_OF_INPUT_SEGMENT, 0,
 			OPTC_SEG0_SRC_SEL, optc->inst,
@@ -236,13 +235,16 @@ void optc2_set_odm_bypass(struct timing_generator *optc,
 			OTG_H_TIMING_DIV_BY2, h_div_2);
 	REG_SET(OPTC_MEMORY_CONFIG, 0,
 			OPTC_MEM_SEL, 0);
+	optc1->opp_count = 1;
 }
 
-void optc2_set_odm_combine(struct timing_generator *optc, int combine_opp_id,
-		int mpcc_hactive, enum dc_pixel_encoding pixel_encoding)
+void optc2_set_odm_combine(struct timing_generator *optc, int *opp_id, int opp_cnt,
+		struct dc_crtc_timing *timing)
 {
 	struct optc *optc1 = DCN10TG_FROM_TG(optc);
 	/* 2 pieces of memory required for up to 5120 displays, 4 for up to 8192 */
+	int mpcc_hactive = (timing->h_addressable + timing->h_border_left + timing->h_border_right)
+			/ opp_cnt;
 	int memory_mask = mpcc_hactive <= 2560 ? 0x3 : 0xf;
 	uint32_t data_fmt = 0;
 
@@ -257,23 +259,24 @@ void optc2_set_odm_combine(struct timing_generator *optc, int combine_opp_id,
 		REG_SET(OPTC_MEMORY_CONFIG, 0,
 			OPTC_MEM_SEL, memory_mask << (optc->inst * 4));
 
-	if (pixel_encoding == PIXEL_ENCODING_YCBCR422)
+	if (timing->pixel_encoding == PIXEL_ENCODING_YCBCR422)
 		data_fmt = 1;
-	else if (pixel_encoding == PIXEL_ENCODING_YCBCR420)
+	else if (timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)
 		data_fmt = 2;
 
 	REG_UPDATE(OPTC_DATA_FORMAT_CONTROL, OPTC_DATA_FORMAT, data_fmt);
 
+	ASSERT(opp_cnt == 2);
 	REG_SET_3(OPTC_DATA_SOURCE_SELECT, 0,
 			OPTC_NUM_OF_INPUT_SEGMENT, 1,
-			OPTC_SEG0_SRC_SEL, optc->inst,
-			OPTC_SEG1_SRC_SEL, combine_opp_id);
+			OPTC_SEG0_SRC_SEL, opp_id[0],
+			OPTC_SEG1_SRC_SEL, opp_id[1]);
 
 	REG_UPDATE(OPTC_WIDTH_CONTROL,
 			OPTC_SEGMENT_WIDTH, mpcc_hactive);
 
 	REG_SET(OTG_H_TIMING_CNTL, 0, OTG_H_TIMING_DIV_BY2, 1);
-	optc1->comb_opp_id = combine_opp_id;
+	optc1->opp_count = opp_cnt;
 }
 
 void optc2_get_optc_source(struct timing_generator *optc,
@@ -538,6 +541,5 @@ void dcn20_timing_generator_init(struct optc *optc1)
 	optc1->min_v_blank_interlace = 5;
 	optc1->min_h_sync_width = 4;//	Minimum HSYNC = 8 pixels asked By HW in the first place for no actual reason. Oculus Rift S will not light up with 8 as it's hsyncWidth is 6. Changing it to 4 to fix that issue.
 	optc1->min_v_sync_width = 1;
-	optc1->comb_opp_id = 0xf;
 }
 

commit 5ec43eda85506ddc2f91c3a4e28b38da3f14cf1e
Author: Martin Leung <martin.leung@amd.com>
Date:   Wed Jul 17 16:08:19 2019 -0400

    drm/amd/display: enabling seamless boot sequence for dcn2
    
    [Why]
    Seamless boot (building SW state inheriting BIOS-initialized timing) was
    enabled on DCN2, including fixes
    
    [How]
    Includes fixes for MPC, DPPCLK, and DIG FE mapping/OTG source select/
    Pixel clock.
    
    This is part 2 of 2 for seamless boot NV10
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index 1ae973962d53..6dede495d0fd 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -522,7 +522,8 @@ static struct timing_generator_funcs dcn20_tg_funcs = {
 		.set_gsl_source_select = optc2_set_gsl_source_select,
 		.set_vtg_params = optc1_set_vtg_params,
 		.program_manual_trigger = optc2_program_manual_trigger,
-		.setup_manual_trigger = optc2_setup_manual_trigger
+		.setup_manual_trigger = optc2_setup_manual_trigger,
+		.is_matching_timing = optc1_is_matching_timing
 };
 
 void dcn20_timing_generator_init(struct optc *optc1)

commit 09fc26c1718fe7a552866d4eda84e2cc5f9c9c78
Author: Fatemeh Darbehani <fatemeh.darbehani@amd.com>
Date:   Fri Jun 21 17:44:50 2019 -0400

    drm/amd/display: Change min_h_sync_width from 8 to 4
    
    [Why]
    Some display's hsync width is lower than the minimum dcn20 is set
    to support right now. This will cause optc1_validate_timing to fail which
    eventually will result in wrong set mode. This was set to 8 as per
    HW team's request for no valid reason.
    
    [How]
    Changing min_h_sync_width to 4 will let us validate timing for
    preffered mode and light up the headset. This change was made
    to Vega 10 before for a similar issue.
    
    Signed-off-by: Fatemeh Darbehani <fatemeh.darbehani@amd.com>
    Reviewed-by: Joshua Aberback <Joshua.Aberback@amd.com>
    Acked-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index 26a66ccf6e72..1ae973962d53 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -535,7 +535,7 @@ void dcn20_timing_generator_init(struct optc *optc1)
 	optc1->min_h_blank = 32;
 	optc1->min_v_blank = 3;
 	optc1->min_v_blank_interlace = 5;
-	optc1->min_h_sync_width = 8;
+	optc1->min_h_sync_width = 4;//	Minimum HSYNC = 8 pixels asked By HW in the first place for no actual reason. Oculus Rift S will not light up with 8 as it's hsyncWidth is 6. Changing it to 4 to fix that issue.
 	optc1->min_v_sync_width = 1;
 	optc1->comb_opp_id = 0xf;
 }

commit ce76898527cd14e9f1b04f463fd3d1cae80ed9c6
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Thu Apr 18 15:15:58 2019 -0400

    drm/amd/display: Do a reg update instead of set when writing ODM color format
    
    [why]
    If a set is done, DSC settings are zeroed out, leading to no DSC for the modes
    that require ODM, such as 8k60.
    
    This was a regression introduced by 5a4f26295176bbfc776c75aaf0f6dd8ccf806958.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index d0b317ea3a7c..26a66ccf6e72 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -262,7 +262,7 @@ void optc2_set_odm_combine(struct timing_generator *optc, int combine_opp_id,
 	else if (pixel_encoding == PIXEL_ENCODING_YCBCR420)
 		data_fmt = 2;
 
-	REG_SET(OPTC_DATA_FORMAT_CONTROL, 0, OPTC_DATA_FORMAT, data_fmt);
+	REG_UPDATE(OPTC_DATA_FORMAT_CONTROL, OPTC_DATA_FORMAT, data_fmt);
 
 	REG_SET_3(OPTC_DATA_SOURCE_SELECT, 0,
 			OPTC_NUM_OF_INPUT_SEGMENT, 1,

commit fbc9ca671f4ffbc0c873de17cf2305ca438cb09e
Author: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
Date:   Tue Apr 9 11:50:38 2019 -0400

    drm/amd/display: Fix ODM combine data format
    
    [Why]
    OPTC data format was left at its default value (444) when enabling
    ODM combine. This caused issues with FPGA capture.
    
    [How]
    Write the OPTC_DATA_FORMAT field when enabling ODM combine.
    
    Signed-off-by: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index ea6a19063b22..d0b317ea3a7c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -238,11 +238,13 @@ void optc2_set_odm_bypass(struct timing_generator *optc,
 			OPTC_MEM_SEL, 0);
 }
 
-void optc2_set_odm_combine(struct timing_generator *optc, int combine_opp_id, int mpcc_hactive)
+void optc2_set_odm_combine(struct timing_generator *optc, int combine_opp_id,
+		int mpcc_hactive, enum dc_pixel_encoding pixel_encoding)
 {
 	struct optc *optc1 = DCN10TG_FROM_TG(optc);
 	/* 2 pieces of memory required for up to 5120 displays, 4 for up to 8192 */
 	int memory_mask = mpcc_hactive <= 2560 ? 0x3 : 0xf;
+	uint32_t data_fmt = 0;
 
 	/* TODO: In pseudocode but does not affect maximus, delete comment if we dont need on asic
 	 * REG_SET(OTG_GLOBAL_CONTROL2, 0, GLOBAL_UPDATE_LOCK_EN, 1);
@@ -255,6 +257,13 @@ void optc2_set_odm_combine(struct timing_generator *optc, int combine_opp_id, in
 		REG_SET(OPTC_MEMORY_CONFIG, 0,
 			OPTC_MEM_SEL, memory_mask << (optc->inst * 4));
 
+	if (pixel_encoding == PIXEL_ENCODING_YCBCR422)
+		data_fmt = 1;
+	else if (pixel_encoding == PIXEL_ENCODING_YCBCR420)
+		data_fmt = 2;
+
+	REG_SET(OPTC_DATA_FORMAT_CONTROL, 0, OPTC_DATA_FORMAT, data_fmt);
+
 	REG_SET_3(OPTC_DATA_SOURCE_SELECT, 0,
 			OPTC_NUM_OF_INPUT_SEGMENT, 1,
 			OPTC_SEG0_SRC_SEL, optc->inst,

commit 6c5be4ac630805d3a3b20157a0c6421ef815fe78
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Tue Mar 5 19:28:10 2019 -0500

    drm/amd/display: add global master update lock for DCN2
    
    [why]
    when an update programming sequence requires both
    front end and back end pipe to be updated synchronously,
    a global update lock needs to be set to ensure that
    we don't get a frame with only front end update but
    not the back end update.
    
    [how]
    setup global lock parameters on enable_stream_timing.
    enable global lock when pipe_control_lock_global is called.
    disable global lock when pipe_control_lock is called.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index 43e71b4ab5e8..ea6a19063b22 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -330,6 +330,65 @@ void optc2_triplebuffer_unlock(struct timing_generator *optc)
 
 }
 
+
+void optc2_setup_global_lock(struct timing_generator *optc)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+	uint32_t v_blank_start = 0;
+	uint32_t h_blank_start = 0, h_total = 0;
+
+	REG_SET(OTG_GLOBAL_CONTROL1, 0, MASTER_UPDATE_LOCK_DB_EN, 1);
+
+	REG_SET(OTG_GLOBAL_CONTROL2, 0, DIG_UPDATE_LOCATION, 20);
+
+	REG_GET(OTG_V_BLANK_START_END, OTG_V_BLANK_START, &v_blank_start);
+
+	REG_GET(OTG_H_BLANK_START_END, OTG_H_BLANK_START, &h_blank_start);
+
+	REG_GET(OTG_H_TOTAL, OTG_H_TOTAL, &h_total);
+	REG_UPDATE_2(OTG_GLOBAL_CONTROL1,
+			MASTER_UPDATE_LOCK_DB_X,
+			h_blank_start - 200 - 1,
+			MASTER_UPDATE_LOCK_DB_Y,
+			v_blank_start - 1);
+}
+
+void optc2_lock_global(struct timing_generator *optc)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	REG_UPDATE(OTG_GLOBAL_CONTROL2, GLOBAL_UPDATE_LOCK_EN, 1);
+
+	REG_SET(OTG_GLOBAL_CONTROL0, 0,
+			OTG_MASTER_UPDATE_LOCK_SEL, optc->inst);
+	REG_SET(OTG_MASTER_UPDATE_LOCK, 0,
+			OTG_MASTER_UPDATE_LOCK, 1);
+
+	/* Should be fast, status does not update on maximus */
+	if (optc->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
+		REG_WAIT(OTG_MASTER_UPDATE_LOCK,
+				UPDATE_LOCK_STATUS, 1,
+				1, 10);
+}
+
+void optc2_lock(struct timing_generator *optc)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	REG_UPDATE(OTG_GLOBAL_CONTROL2, GLOBAL_UPDATE_LOCK_EN, 0);
+
+	REG_SET(OTG_GLOBAL_CONTROL0, 0,
+			OTG_MASTER_UPDATE_LOCK_SEL, optc->inst);
+	REG_SET(OTG_MASTER_UPDATE_LOCK, 0,
+			OTG_MASTER_UPDATE_LOCK, 1);
+
+	/* Should be fast, status does not update on maximus */
+	if (optc->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
+		REG_WAIT(OTG_MASTER_UPDATE_LOCK,
+				UPDATE_LOCK_STATUS, 1,
+				1, 10);
+}
+
 void optc2_lock_doublebuffer_enable(struct timing_generator *optc)
 {
 	struct optc *optc1 = DCN10TG_FROM_TG(optc);
@@ -424,8 +483,10 @@ static struct timing_generator_funcs dcn20_tg_funcs = {
 		.triplebuffer_lock = optc2_triplebuffer_lock,
 		.triplebuffer_unlock = optc2_triplebuffer_unlock,
 		.disable_reset_trigger = optc1_disable_reset_trigger,
-		.lock = optc1_lock,
+		.lock = optc2_lock,
 		.unlock = optc1_unlock,
+		.lock_global = optc2_lock_global,
+		.setup_global_lock = optc2_setup_global_lock,
 		.lock_doublebuffer_enable = optc2_lock_doublebuffer_enable,
 		.lock_doublebuffer_disable = optc2_lock_doublebuffer_disable,
 		.enable_optc_clock = optc1_enable_optc_clock,

commit db5378c1dcff3391dac42d714e6064c80702fa3d
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Thu Mar 28 11:27:05 2019 -0400

    drm/amd/display: isolate global double buffer lock programming
    
    [why]
    Global optic double buffer lock is currently disabled due to
    incorrect programming sequence that affects non global lock.
    
    [how]
    Isolate global lock programming sequence out of non global lock
    programming sequence, so it can be enabled without affecting
    non global lock.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index 34f5a7d671b2..43e71b4ab5e8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -330,64 +330,42 @@ void optc2_triplebuffer_unlock(struct timing_generator *optc)
 
 }
 
-void optc2_setup_global_lock(struct timing_generator *optc)
+void optc2_lock_doublebuffer_enable(struct timing_generator *optc)
 {
 	struct optc *optc1 = DCN10TG_FROM_TG(optc);
 	uint32_t v_blank_start = 0;
-	uint32_t h_blank_start = 0, h_total = 0;
+	uint32_t h_blank_start = 0;
 
-	REG_SET(OTG_GLOBAL_CONTROL2, 0, DIG_UPDATE_LOCATION, 20);
+	REG_UPDATE(OTG_GLOBAL_CONTROL1, MASTER_UPDATE_LOCK_DB_EN, 1);
+
+	REG_UPDATE_2(OTG_GLOBAL_CONTROL2, GLOBAL_UPDATE_LOCK_EN, 1,
+			DIG_UPDATE_LOCATION, 20);
 
 	REG_GET(OTG_V_BLANK_START_END, OTG_V_BLANK_START, &v_blank_start);
 
 	REG_GET(OTG_H_BLANK_START_END, OTG_H_BLANK_START, &h_blank_start);
 
-	REG_GET(OTG_H_TOTAL, OTG_H_TOTAL, &h_total);
 	REG_UPDATE_2(OTG_GLOBAL_CONTROL1,
 			MASTER_UPDATE_LOCK_DB_X,
-			0,
+			h_blank_start - 200 - 1,
 			MASTER_UPDATE_LOCK_DB_Y,
 			v_blank_start - 1);
 }
 
-void optc2_lock_global(struct timing_generator *optc)
+void optc2_lock_doublebuffer_disable(struct timing_generator *optc)
 {
 	struct optc *optc1 = DCN10TG_FROM_TG(optc);
 
-	REG_SET(OTG_GLOBAL_CONTROL1, 0, MASTER_UPDATE_LOCK_DB_EN, 1);
-
-	REG_UPDATE(OTG_GLOBAL_CONTROL2, GLOBAL_UPDATE_LOCK_EN, 1);
-
-	REG_SET(OTG_GLOBAL_CONTROL0, 0,
-			OTG_MASTER_UPDATE_LOCK_SEL, optc->inst);
-	REG_SET(OTG_MASTER_UPDATE_LOCK, 0,
-			OTG_MASTER_UPDATE_LOCK, 1);
-
-	/* Should be fast, status does not update on maximus */
-	if (optc->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
-		REG_WAIT(OTG_MASTER_UPDATE_LOCK,
-				UPDATE_LOCK_STATUS, 1,
-				1, 10);
-}
-
-void optc2_lock(struct timing_generator *optc)
-{
-	struct optc *optc1 = DCN10TG_FROM_TG(optc);
-
-	REG_SET(OTG_GLOBAL_CONTROL1, 0, MASTER_UPDATE_LOCK_DB_EN, 0);
+	REG_UPDATE_2(OTG_GLOBAL_CONTROL1,
+				MASTER_UPDATE_LOCK_DB_X,
+				0,
+				MASTER_UPDATE_LOCK_DB_Y,
+				0);
 
-	REG_UPDATE(OTG_GLOBAL_CONTROL2, GLOBAL_UPDATE_LOCK_EN, 0);
+	REG_UPDATE_2(OTG_GLOBAL_CONTROL2, GLOBAL_UPDATE_LOCK_EN, 0,
+				DIG_UPDATE_LOCATION, 0);
 
-	REG_SET(OTG_GLOBAL_CONTROL0, 0,
-			OTG_MASTER_UPDATE_LOCK_SEL, optc->inst);
-	REG_SET(OTG_MASTER_UPDATE_LOCK, 0,
-			OTG_MASTER_UPDATE_LOCK, 1);
-
-	/* Should be fast, status does not update on maximus */
-	if (optc->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
-		REG_WAIT(OTG_MASTER_UPDATE_LOCK,
-				UPDATE_LOCK_STATUS, 1,
-				1, 10);
+	REG_UPDATE(OTG_GLOBAL_CONTROL1, MASTER_UPDATE_LOCK_DB_EN, 0);
 }
 
 void optc2_setup_manual_trigger(struct timing_generator *optc)
@@ -446,10 +424,10 @@ static struct timing_generator_funcs dcn20_tg_funcs = {
 		.triplebuffer_lock = optc2_triplebuffer_lock,
 		.triplebuffer_unlock = optc2_triplebuffer_unlock,
 		.disable_reset_trigger = optc1_disable_reset_trigger,
-		.lock = optc2_lock,
+		.lock = optc1_lock,
 		.unlock = optc1_unlock,
-		.lock_global = optc2_lock_global,
-		.setup_global_lock = optc2_setup_global_lock,
+		.lock_doublebuffer_enable = optc2_lock_doublebuffer_enable,
+		.lock_doublebuffer_disable = optc2_lock_doublebuffer_disable,
 		.enable_optc_clock = optc1_enable_optc_clock,
 		.set_drr = optc1_set_drr,
 		.set_static_screen_control = optc1_set_static_screen_control,

commit 9e14d4f17e23ce46d346a6a22a295b4a65b9d918
Author: hersen wu <hersenxs.wu@amd.com>
Date:   Wed Mar 13 16:21:26 2019 -0400

    drm/amd/display: skip dsc config for navi10 bring up
    
    [why] we meet a bug when program dsc register even dsc mode is not
    enabled. disable dsc config for now. we will re-visit this issue.
    
    Signed-off-by: hersen wu <hersenxs.wu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index 724b5a9e47d0..34f5a7d671b2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -191,6 +191,15 @@ void optc2_set_dsc_config(struct timing_generator *optc,
 					uint32_t dsc_slice_width)
 {
 	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+	uint32_t data_format = 0;
+	/* skip if dsc mode is not changed */
+	data_format = dm_read_reg(CTX, REG(OPTC_DATA_FORMAT_CONTROL));
+
+	data_format = data_format & 0x30; /* bit5:4 */
+	data_format = data_format >> 4;
+
+	if (data_format == dsc_mode)
+		return;
 
 	REG_UPDATE(OPTC_DATA_FORMAT_CONTROL,
 		OPTC_DSC_MODE, dsc_mode);

commit ae8f425840cb642873ff97b7a6711aad42766133
Author: Eryk Brol <eryk.brol@amd.com>
Date:   Tue Apr 23 11:53:52 2019 -0400

    drm/amd/display: Ensure DRR triggers in BP
    
    [Why]
    In the previous implementation DRR event sometimes came
    in during FP2 region which is a keep-out zone. This
    would cause the frame not to latch until the next frame
    which resulted in heavy flicker. To fix this we need
    to make sure that it triggers in the BP.
    
    [How]
    1. Remove DRR programming during flip
    2. Setup manual trigger for DRR event and trigger it
    after surface programming is complete
    
    Signed-off-by: Eryk Brol <eryk.brol@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index cee1ed11ffe3..724b5a9e47d0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -381,6 +381,35 @@ void optc2_lock(struct timing_generator *optc)
 				1, 10);
 }
 
+void optc2_setup_manual_trigger(struct timing_generator *optc)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	REG_SET(OTG_MANUAL_FLOW_CONTROL, 0,
+			MANUAL_FLOW_CONTROL, 1);
+
+	REG_SET(OTG_GLOBAL_CONTROL2, 0,
+			MANUAL_FLOW_CONTROL_SEL, optc->inst);
+
+	REG_SET_8(OTG_TRIGA_CNTL, 0,
+			OTG_TRIGA_SOURCE_SELECT, 22,
+			OTG_TRIGA_SOURCE_PIPE_SELECT, optc->inst,
+			OTG_TRIGA_RISING_EDGE_DETECT_CNTL, 1,
+			OTG_TRIGA_FALLING_EDGE_DETECT_CNTL, 0,
+			OTG_TRIGA_POLARITY_SELECT, 0,
+			OTG_TRIGA_FREQUENCY_SELECT, 0,
+			OTG_TRIGA_DELAY, 0,
+			OTG_TRIGA_CLEAR, 1);
+}
+
+void optc2_program_manual_trigger(struct timing_generator *optc)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	REG_SET(OTG_TRIGA_MANUAL_TRIG, 0,
+			OTG_TRIGA_MANUAL_TRIG, 1);
+}
+
 static struct timing_generator_funcs dcn20_tg_funcs = {
 		.validate_timing = optc1_validate_timing,
 		.program_timing = optc1_program_timing,
@@ -435,6 +464,8 @@ static struct timing_generator_funcs dcn20_tg_funcs = {
 		.set_gsl = optc2_set_gsl,
 		.set_gsl_source_select = optc2_set_gsl_source_select,
 		.set_vtg_params = optc1_set_vtg_params,
+		.program_manual_trigger = optc2_program_manual_trigger,
+		.setup_manual_trigger = optc2_setup_manual_trigger
 };
 
 void dcn20_timing_generator_init(struct optc *optc1)

commit 3972c3508594310eb868f0e57c44cf0b6fccf7b2
Author: Joshua Aberback <joshua.aberback@amd.com>
Date:   Mon Apr 29 17:21:19 2019 -0400

    drm/amd/display: Program VTG params after programming Global Sync for DCN2
    
    [Why]
    VTG has a parameter FP2, which is defined as:
        if VSTARTUP is before VSYNC:
            FP2 = number of lines in between VSTARTUP and VSYNC
        else
            FP2 = 0
    Currently, FP2 is only programmed during "program_timing". However, the
    position of VSTARTUP is affected by the prefetching requirements on all pipes,
    so the position might change when we do memory request control on another pipe, so we need
    to make sure that FP2 stays up-to-date whenever we adjust VSTARTUP.
    
    [How]
     - refactor VTG_CONTROL programming into a new function "set_vtg_params"
     - call it after calling "program_global_sync"
       - make sure it's called after because it relies on the cached dlg params
    
    Signed-off-by: Joshua Aberback <joshua.aberback@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Jun Lei <Jun.Lei@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index 875b48e450f8..cee1ed11ffe3 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -434,6 +434,7 @@ static struct timing_generator_funcs dcn20_tg_funcs = {
 		.get_optc_source = optc2_get_optc_source,
 		.set_gsl = optc2_set_gsl,
 		.set_gsl_source_select = optc2_set_gsl_source_select,
+		.set_vtg_params = optc1_set_vtg_params,
 };
 
 void dcn20_timing_generator_init(struct optc *optc1)

commit 97bda0322b8a91aa8d534763e709571b2334e585
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Feb 25 13:26:34 2019 -0500

    drm/amd/display: Add DSC support for Navi (v2)
    
    Add support for DCN2 DSC (Display Stream Compression)
    
    HW Blocks:
    
     +--------++------+       +----------+
     | HUBBUB || HUBP |  <--  | MMHUBBUB |
     +--------++------+       +----------+
            |                     ^
            v                     |
        +--------+            +--------+
        |  DPP   |            |  DWB   |
        +--------+            +--------+
            |
            v                      ^
        +--------+                 |
        |  MPC   |                 |
        +--------+                 |
            |                      |
            v                      |
        +-------+      +-------+   |
        |  OPP  | <--> |  DSC  |   |
        +-------+      +-------+   |
            |                      |
            v                      |
        +--------+                /
        |  OPTC  |  --------------
        +--------+
            |
            v
        +--------+       +--------+
        |  DIO   |       |  DCCG  |
        +--------+       +--------+
    
    v2: rebase (Alex)
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
index 72d72c3a35ee..875b48e450f8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -167,6 +167,41 @@ void optc2_set_gsl_source_select(
 	}
 }
 
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+/* DSC encoder frame start controls: x = h position, line_num = # of lines from vstartup */
+void optc2_set_dsc_encoder_frame_start(struct timing_generator *optc,
+					int x_position,
+					int line_num)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	REG_SET_2(OTG_DSC_START_POSITION, 0,
+			OTG_DSC_START_POSITION_X, x_position,
+			OTG_DSC_START_POSITION_LINE_NUM, line_num);
+}
+
+/* Set DSC-related configuration.
+ *   dsc_mode: 0 disables DSC, other values enable DSC in specified format
+ *   sc_bytes_per_pixel: Bytes per pixel in u3.28 format
+ *   dsc_slice_width: Slice width in pixels
+ */
+void optc2_set_dsc_config(struct timing_generator *optc,
+					enum optc_dsc_mode dsc_mode,
+					uint32_t dsc_bytes_per_pixel,
+					uint32_t dsc_slice_width)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	REG_UPDATE(OPTC_DATA_FORMAT_CONTROL,
+		OPTC_DSC_MODE, dsc_mode);
+
+	REG_SET(OPTC_BYTES_PER_PIXEL, 0,
+		OPTC_DSC_BYTES_PER_PIXEL, dsc_bytes_per_pixel);
+
+	REG_UPDATE(OPTC_WIDTH_CONTROL,
+		OPTC_DSC_SLICE_WIDTH, dsc_slice_width);
+}
+#endif
 
 /**
  * PTI i think is already done somewhere else for 2ka
@@ -390,6 +425,9 @@ static struct timing_generator_funcs dcn20_tg_funcs = {
 		.setup_global_swap_lock = NULL,
 		.get_crc = optc1_get_crc,
 		.configure_crc = optc1_configure_crc,
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+		.set_dsc_config = optc2_set_dsc_config,
+#endif
 		.set_dwb_source = optc2_set_dwb_source,
 		.set_odm_bypass = optc2_set_odm_bypass,
 		.set_odm_combine = optc2_set_odm_combine,

commit 2d78b3a177fea66cf576a420d2ff83811643c021
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Feb 22 10:19:04 2019 -0500

    drm/amd/display: Add DCN2 OPTC
    
    Add support for programming the DCN2 OPTC (Output Timing Controller)
    
    HW Blocks:
    
        +--------+
        |  OPTC  |
        +--------+
            |
            v
        +--------+       +--------+
        |  DIO   |       |  DCCG  |
        +--------+       +--------+
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
new file mode 100644
index 000000000000..72d72c3a35ee
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_optc.c
@@ -0,0 +1,415 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "reg_helper.h"
+#include "dcn20_optc.h"
+#include "dc.h"
+
+#define REG(reg)\
+	optc1->tg_regs->reg
+
+#define CTX \
+	optc1->base.ctx
+
+#undef FN
+#define FN(reg_name, field_name) \
+	optc1->tg_shift->field_name, optc1->tg_mask->field_name
+
+/**
+ * Enable CRTC
+ * Enable CRTC - call ASIC Control Object to enable Timing generator.
+ */
+bool optc2_enable_crtc(struct timing_generator *optc)
+{
+	/* TODO FPGA wait for answer
+	 * OTG_MASTER_UPDATE_MODE != CRTC_MASTER_UPDATE_MODE
+	 * OTG_MASTER_UPDATE_LOCK != CRTC_MASTER_UPDATE_LOCK
+	 */
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	/* opp instance for OTG. For DCN1.0, ODM is remoed.
+	 * OPP and OPTC should 1:1 mapping
+	 */
+	REG_UPDATE(OPTC_DATA_SOURCE_SELECT,
+			OPTC_SEG0_SRC_SEL, optc->inst);
+
+	/* VTG enable first is for HW workaround */
+	REG_UPDATE(CONTROL,
+			VTG0_ENABLE, 1);
+
+	/* Enable CRTC */
+	REG_UPDATE_2(OTG_CONTROL,
+			OTG_DISABLE_POINT_CNTL, 3,
+			OTG_MASTER_EN, 1);
+
+	return true;
+}
+
+/**
+ * DRR double buffering control to select buffer point
+ * for V_TOTAL, H_TOTAL, VTOTAL_MIN, VTOTAL_MAX, VTOTAL_MIN_SEL and VTOTAL_MAX_SEL registers
+ * Options: anytime, start of frame, dp start of frame (range timing)
+ */
+void optc2_set_timing_db_mode(struct timing_generator *optc, bool enable)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	uint32_t blank_data_double_buffer_enable = enable ? 1 : 0;
+
+	REG_UPDATE(OTG_DOUBLE_BUFFER_CONTROL,
+		OTG_RANGE_TIMING_DBUF_UPDATE_MODE, blank_data_double_buffer_enable);
+}
+
+/**
+ *For the below, I'm not sure how your GSL parameters are stored in your env,
+ * so I will assume a gsl_params struct for now
+ */
+void optc2_set_gsl(struct timing_generator *optc,
+		   const struct gsl_params *params)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+/**
+ * There are (MAX_OPTC+1)/2 gsl groups available for use.
+ * In each group (assign an OTG to a group by setting OTG_GSLX_EN = 1,
+ * set one of the OTGs to be the master (OTG_GSL_MASTER_EN = 1) and the rest are slaves.
+ */
+	REG_UPDATE_5(OTG_GSL_CONTROL,
+		OTG_GSL0_EN, params->gsl0_en,
+		OTG_GSL1_EN, params->gsl1_en,
+		OTG_GSL2_EN, params->gsl2_en,
+		OTG_GSL_MASTER_EN, params->gsl_master_en,
+		OTG_GSL_MASTER_MODE, params->gsl_master_mode);
+}
+
+
+/* Use the gsl allow flip as the master update lock */
+void optc2_use_gsl_as_master_update_lock(struct timing_generator *optc,
+		   const struct gsl_params *params)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	REG_UPDATE(OTG_GSL_CONTROL,
+		OTG_MASTER_UPDATE_LOCK_GSL_EN, params->master_update_lock_gsl_en);
+}
+
+/* You can control the GSL timing by limiting GSL to a window (X,Y) */
+void optc2_set_gsl_window(struct timing_generator *optc,
+		   const struct gsl_params *params)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	REG_SET_2(OTG_GSL_WINDOW_X, 0,
+		OTG_GSL_WINDOW_START_X, params->gsl_window_start_x,
+		OTG_GSL_WINDOW_END_X, params->gsl_window_end_x);
+	REG_SET_2(OTG_GSL_WINDOW_Y, 0,
+		OTG_GSL_WINDOW_START_Y, params->gsl_window_start_y,
+		OTG_GSL_WINDOW_END_Y, params->gsl_window_end_y);
+}
+
+/**
+ * Vupdate keepout can be set to a window to block the update lock for that pipe from changing.
+ * Start offset begins with vstartup and goes for x number of clocks,
+ * end offset starts from end of vupdate to x number of clocks.
+ */
+void optc2_set_vupdate_keepout(struct timing_generator *optc,
+		   const struct vupdate_keepout_params *params)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	REG_SET_3(OTG_VUPDATE_KEEPOUT, 0,
+		MASTER_UPDATE_LOCK_VUPDATE_KEEPOUT_START_OFFSET, params->start_offset,
+		MASTER_UPDATE_LOCK_VUPDATE_KEEPOUT_END_OFFSET, params->end_offset,
+		OTG_MASTER_UPDATE_LOCK_VUPDATE_KEEPOUT_EN, params->enable);
+}
+
+void optc2_set_gsl_source_select(
+		struct timing_generator *optc,
+		int group_idx,
+		uint32_t gsl_ready_signal)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	switch (group_idx) {
+	case 1:
+		REG_UPDATE(GSL_SOURCE_SELECT, GSL0_READY_SOURCE_SEL, gsl_ready_signal);
+		break;
+	case 2:
+		REG_UPDATE(GSL_SOURCE_SELECT, GSL1_READY_SOURCE_SEL, gsl_ready_signal);
+		break;
+	case 3:
+		REG_UPDATE(GSL_SOURCE_SELECT, GSL2_READY_SOURCE_SEL, gsl_ready_signal);
+		break;
+	default:
+		break;
+	}
+}
+
+
+/**
+ * PTI i think is already done somewhere else for 2ka
+ * (opp?, please double check.
+ * OPTC side only has 1 register to set for PTI_ENABLE)
+ */
+
+void optc2_set_odm_bypass(struct timing_generator *optc,
+		const struct dc_crtc_timing *dc_crtc_timing)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+	uint32_t h_div_2 = 0;
+
+	optc1->comb_opp_id = 0xf;
+	REG_SET_3(OPTC_DATA_SOURCE_SELECT, 0,
+			OPTC_NUM_OF_INPUT_SEGMENT, 0,
+			OPTC_SEG0_SRC_SEL, optc->inst,
+			OPTC_SEG1_SRC_SEL, 0xf);
+	REG_WRITE(OTG_H_TIMING_CNTL, 0);
+
+	h_div_2 = optc1_is_two_pixels_per_containter(dc_crtc_timing);
+	REG_UPDATE(OTG_H_TIMING_CNTL,
+			OTG_H_TIMING_DIV_BY2, h_div_2);
+	REG_SET(OPTC_MEMORY_CONFIG, 0,
+			OPTC_MEM_SEL, 0);
+}
+
+void optc2_set_odm_combine(struct timing_generator *optc, int combine_opp_id, int mpcc_hactive)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+	/* 2 pieces of memory required for up to 5120 displays, 4 for up to 8192 */
+	int memory_mask = mpcc_hactive <= 2560 ? 0x3 : 0xf;
+
+	/* TODO: In pseudocode but does not affect maximus, delete comment if we dont need on asic
+	 * REG_SET(OTG_GLOBAL_CONTROL2, 0, GLOBAL_UPDATE_LOCK_EN, 1);
+	 * Program OTG register MASTER_UPDATE_LOCK_DB_X/Y to the position before DP frame start
+	 * REG_SET_2(OTG_GLOBAL_CONTROL1, 0,
+	 *		MASTER_UPDATE_LOCK_DB_X, 160,
+	 *		MASTER_UPDATE_LOCK_DB_Y, 240);
+	 */
+	if (REG(OPTC_MEMORY_CONFIG))
+		REG_SET(OPTC_MEMORY_CONFIG, 0,
+			OPTC_MEM_SEL, memory_mask << (optc->inst * 4));
+
+	REG_SET_3(OPTC_DATA_SOURCE_SELECT, 0,
+			OPTC_NUM_OF_INPUT_SEGMENT, 1,
+			OPTC_SEG0_SRC_SEL, optc->inst,
+			OPTC_SEG1_SRC_SEL, combine_opp_id);
+
+	REG_UPDATE(OPTC_WIDTH_CONTROL,
+			OPTC_SEGMENT_WIDTH, mpcc_hactive);
+
+	REG_SET(OTG_H_TIMING_CNTL, 0, OTG_H_TIMING_DIV_BY2, 1);
+	optc1->comb_opp_id = combine_opp_id;
+}
+
+void optc2_get_optc_source(struct timing_generator *optc,
+		uint32_t *num_of_src_opp,
+		uint32_t *src_opp_id_0,
+		uint32_t *src_opp_id_1)
+{
+	uint32_t num_of_input_segments;
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	REG_GET_3(OPTC_DATA_SOURCE_SELECT,
+			OPTC_NUM_OF_INPUT_SEGMENT, &num_of_input_segments,
+			OPTC_SEG0_SRC_SEL, src_opp_id_0,
+			OPTC_SEG1_SRC_SEL, src_opp_id_1);
+
+	if (num_of_input_segments == 1)
+		*num_of_src_opp = 2;
+	else
+		*num_of_src_opp = 1;
+}
+
+void optc2_set_dwb_source(struct timing_generator *optc,
+		uint32_t dwb_pipe_inst)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	if (dwb_pipe_inst == 0)
+		REG_UPDATE(DWB_SOURCE_SELECT,
+				OPTC_DWB0_SOURCE_SELECT, optc->inst);
+	else if (dwb_pipe_inst == 1)
+		REG_UPDATE(DWB_SOURCE_SELECT,
+				OPTC_DWB1_SOURCE_SELECT, optc->inst);
+}
+
+void optc2_triplebuffer_lock(struct timing_generator *optc)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	REG_SET(OTG_GLOBAL_CONTROL0, 0,
+		OTG_MASTER_UPDATE_LOCK_SEL, optc->inst);
+
+	REG_SET(OTG_VUPDATE_KEEPOUT, 0,
+		OTG_MASTER_UPDATE_LOCK_VUPDATE_KEEPOUT_EN, 1);
+
+	REG_SET(OTG_MASTER_UPDATE_LOCK, 0,
+		OTG_MASTER_UPDATE_LOCK, 1);
+
+	if (optc->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
+		REG_WAIT(OTG_MASTER_UPDATE_LOCK,
+				UPDATE_LOCK_STATUS, 1,
+				1, 10);
+}
+
+void optc2_triplebuffer_unlock(struct timing_generator *optc)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	REG_SET(OTG_MASTER_UPDATE_LOCK, 0,
+		OTG_MASTER_UPDATE_LOCK, 0);
+
+	REG_SET(OTG_VUPDATE_KEEPOUT, 0,
+		OTG_MASTER_UPDATE_LOCK_VUPDATE_KEEPOUT_EN, 0);
+
+}
+
+void optc2_setup_global_lock(struct timing_generator *optc)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+	uint32_t v_blank_start = 0;
+	uint32_t h_blank_start = 0, h_total = 0;
+
+	REG_SET(OTG_GLOBAL_CONTROL2, 0, DIG_UPDATE_LOCATION, 20);
+
+	REG_GET(OTG_V_BLANK_START_END, OTG_V_BLANK_START, &v_blank_start);
+
+	REG_GET(OTG_H_BLANK_START_END, OTG_H_BLANK_START, &h_blank_start);
+
+	REG_GET(OTG_H_TOTAL, OTG_H_TOTAL, &h_total);
+	REG_UPDATE_2(OTG_GLOBAL_CONTROL1,
+			MASTER_UPDATE_LOCK_DB_X,
+			0,
+			MASTER_UPDATE_LOCK_DB_Y,
+			v_blank_start - 1);
+}
+
+void optc2_lock_global(struct timing_generator *optc)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	REG_SET(OTG_GLOBAL_CONTROL1, 0, MASTER_UPDATE_LOCK_DB_EN, 1);
+
+	REG_UPDATE(OTG_GLOBAL_CONTROL2, GLOBAL_UPDATE_LOCK_EN, 1);
+
+	REG_SET(OTG_GLOBAL_CONTROL0, 0,
+			OTG_MASTER_UPDATE_LOCK_SEL, optc->inst);
+	REG_SET(OTG_MASTER_UPDATE_LOCK, 0,
+			OTG_MASTER_UPDATE_LOCK, 1);
+
+	/* Should be fast, status does not update on maximus */
+	if (optc->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
+		REG_WAIT(OTG_MASTER_UPDATE_LOCK,
+				UPDATE_LOCK_STATUS, 1,
+				1, 10);
+}
+
+void optc2_lock(struct timing_generator *optc)
+{
+	struct optc *optc1 = DCN10TG_FROM_TG(optc);
+
+	REG_SET(OTG_GLOBAL_CONTROL1, 0, MASTER_UPDATE_LOCK_DB_EN, 0);
+
+	REG_UPDATE(OTG_GLOBAL_CONTROL2, GLOBAL_UPDATE_LOCK_EN, 0);
+
+	REG_SET(OTG_GLOBAL_CONTROL0, 0,
+			OTG_MASTER_UPDATE_LOCK_SEL, optc->inst);
+	REG_SET(OTG_MASTER_UPDATE_LOCK, 0,
+			OTG_MASTER_UPDATE_LOCK, 1);
+
+	/* Should be fast, status does not update on maximus */
+	if (optc->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
+		REG_WAIT(OTG_MASTER_UPDATE_LOCK,
+				UPDATE_LOCK_STATUS, 1,
+				1, 10);
+}
+
+static struct timing_generator_funcs dcn20_tg_funcs = {
+		.validate_timing = optc1_validate_timing,
+		.program_timing = optc1_program_timing,
+		.setup_vertical_interrupt0 = optc1_setup_vertical_interrupt0,
+		.setup_vertical_interrupt1 = optc1_setup_vertical_interrupt1,
+		.setup_vertical_interrupt2 = optc1_setup_vertical_interrupt2,
+		.program_global_sync = optc1_program_global_sync,
+		.enable_crtc = optc2_enable_crtc,
+		.disable_crtc = optc1_disable_crtc,
+		/* used by enable_timing_synchronization. Not need for FPGA */
+		.is_counter_moving = optc1_is_counter_moving,
+		.get_position = optc1_get_position,
+		.get_frame_count = optc1_get_vblank_counter,
+		.get_scanoutpos = optc1_get_crtc_scanoutpos,
+		.get_otg_active_size = optc1_get_otg_active_size,
+		.set_early_control = optc1_set_early_control,
+		/* used by enable_timing_synchronization. Not need for FPGA */
+		.wait_for_state = optc1_wait_for_state,
+		.set_blank = optc1_set_blank,
+		.is_blanked = optc1_is_blanked,
+		.set_blank_color = optc1_program_blank_color,
+		.enable_reset_trigger = optc1_enable_reset_trigger,
+		.enable_crtc_reset = optc1_enable_crtc_reset,
+		.did_triggered_reset_occur = optc1_did_triggered_reset_occur,
+		.triplebuffer_lock = optc2_triplebuffer_lock,
+		.triplebuffer_unlock = optc2_triplebuffer_unlock,
+		.disable_reset_trigger = optc1_disable_reset_trigger,
+		.lock = optc2_lock,
+		.unlock = optc1_unlock,
+		.lock_global = optc2_lock_global,
+		.setup_global_lock = optc2_setup_global_lock,
+		.enable_optc_clock = optc1_enable_optc_clock,
+		.set_drr = optc1_set_drr,
+		.set_static_screen_control = optc1_set_static_screen_control,
+		.program_stereo = optc1_program_stereo,
+		.is_stereo_left_eye = optc1_is_stereo_left_eye,
+		.set_blank_data_double_buffer = optc1_set_blank_data_double_buffer,
+		.tg_init = optc1_tg_init,
+		.is_tg_enabled = optc1_is_tg_enabled,
+		.is_optc_underflow_occurred = optc1_is_optc_underflow_occurred,
+		.clear_optc_underflow = optc1_clear_optc_underflow,
+		.setup_global_swap_lock = NULL,
+		.get_crc = optc1_get_crc,
+		.configure_crc = optc1_configure_crc,
+		.set_dwb_source = optc2_set_dwb_source,
+		.set_odm_bypass = optc2_set_odm_bypass,
+		.set_odm_combine = optc2_set_odm_combine,
+		.get_optc_source = optc2_get_optc_source,
+		.set_gsl = optc2_set_gsl,
+		.set_gsl_source_select = optc2_set_gsl_source_select,
+};
+
+void dcn20_timing_generator_init(struct optc *optc1)
+{
+	optc1->base.funcs = &dcn20_tg_funcs;
+
+	optc1->max_h_total = optc1->tg_mask->OTG_H_TOTAL + 1;
+	optc1->max_v_total = optc1->tg_mask->OTG_V_TOTAL + 1;
+
+	optc1->min_h_blank = 32;
+	optc1->min_v_blank = 3;
+	optc1->min_v_blank_interlace = 5;
+	optc1->min_h_sync_width = 8;
+	optc1->min_v_sync_width = 1;
+	optc1->comb_opp_id = 0xf;
+}
+
