commit c38606ab1250aad05829e0daa8fa9a002161eb2a
Author: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
Date:   Fri Apr 24 09:53:07 2020 -0400

    drm/amd/display: Remove dml_common_def file
    
    During the rework for removing the FPU issues, I found the following
    warning:
    
     [..] dml_common_defs.o: warning: objtool: dml_round()+0x9: FPU
          instruction outside of kernel_fpu_{begin,end}()
    
    This file has a single function that does not need to be in a specific
    file. This commit drop dml_common_defs file, and move dml_round function
    to dml_inline_defs.
    
    CC: Christian KÃ¶nig <christian.koenig@amd.com>
    CC: Alexander Deucher <Alexander.Deucher@amd.com>
    CC: Peter Zijlstra <peterz@infradead.org>
    CC: Tony Cheng <tony.cheng@amd.com>
    CC: Harry Wentland <hwentlan@amd.com>
    Signed-off-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index 6a7b20927a6b..3f559e725ab1 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -27,8 +27,6 @@
 #ifndef __DML2_DISPLAY_MODE_VBA_H__
 #define __DML2_DISPLAY_MODE_VBA_H__
 
-#include "dml_common_defs.h"
-
 struct display_mode_lib;
 
 void ModeSupportAndSystemConfiguration(struct display_mode_lib *mode_lib);

commit f00889dc7157fa32d2319483b713752ed37ea0e5
Author: Alvin Lee <alvin.lee2@amd.com>
Date:   Tue Apr 21 12:29:12 2020 -0400

    drm/amd/display: Allow PState switch in VBLANK one display VACTIVE
    
    [Why]
    For certain display configurations we want to allow PSTATE
    switch when one display can switch in VACTIVE and the
    other display can switch in VBLANK
    
    [How]
    Add extra condition to dcn2 pstate support check
    
    Signed-off-by: Alvin Lee <alvin.lee2@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index a1884ffe63ae..6a7b20927a6b 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -899,6 +899,7 @@ struct vba_vars_st {
 	double BPP;
 	enum odm_combine_policy ODMCombinePolicy;
 	bool UseMinimumRequiredDCFCLK;
+	bool AllowDramClockChangeOneDisplayVactive;
 };
 
 bool CalculateMinAndMaxPrefetchMode(

commit 38a509d5d2603fef9d8867151381059bcbb3a6ca
Author: Joshua Aberback <joshua.aberback@amd.com>
Date:   Wed Apr 22 18:07:51 2020 -0400

    drm/amd/display: Add DML variable for future asics
    
    Signed-off-by: Joshua Aberback <joshua.aberback@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index 5d82fc5a7ed7..a1884ffe63ae 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -898,6 +898,7 @@ struct vba_vars_st {
 	bool dummystring[DC__NUM_DPP__MAX];
 	double BPP;
 	enum odm_combine_policy ODMCombinePolicy;
+	bool UseMinimumRequiredDCFCLK;
 };
 
 bool CalculateMinAndMaxPrefetchMode(

commit 850d15f2ec93001683b68db4e7f39957c78860d8
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Dec 16 17:50:33 2019 -0500

    drm/amd/display: remove unused dml variable
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index cb563a429590..5d82fc5a7ed7 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -389,7 +389,6 @@ struct vba_vars_st {
 
 	/* vba mode support */
 	/*inputs*/
-	bool EmbeddedPanel[DC__NUM_DPP__MAX];
 	bool SupportGFX7CompatibleTilingIn32bppAnd64bpp;
 	double MaxHSCLRatio;
 	double MaxVSCLRatio;

commit 56260cbff87dd27b33c33c50b18a056f6b8e3ba2
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Dec 11 15:16:28 2019 -0500

    drm/amd/display: update dml input population function
    
    Update dcn20_populate_dml_pipes_from_context to correctly handle odm
    when no surface is provided.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index 2875efd85467..cb563a429590 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -842,8 +842,6 @@ struct vba_vars_st {
 	double DCCRateChroma[DC__NUM_DPP__MAX];
 
 	double PHYCLKD18PerState[DC__VOLTAGE_STATES + 1];
-	int MinVoltageLevel;
-	int MaxVoltageLevel;
 
 	bool WritebackSupportInterleaveAndUsingWholeBufferForASingleStream;
 	bool NumberOfHDMIFRLSupport;
@@ -880,7 +878,6 @@ struct vba_vars_st {
 	double TotalMetaRowBandwidth[DC__VOLTAGE_STATES + 1][2];
 	double TotalVActiveCursorBandwidth[DC__VOLTAGE_STATES + 1][2];
 	double TotalVActivePixelBandwidth[DC__VOLTAGE_STATES + 1][2];
-	bool UseMinimumRequiredDCFCLK;
 	double WritebackDelayTime[DC__NUM_DPP__MAX];
 	unsigned int DCCYIndependentBlock[DC__NUM_DPP__MAX];
 	unsigned int DCCCIndependentBlock[DC__NUM_DPP__MAX];

commit 819d4b3fbfaf40b4537e80b01aef612e4140a91b
Author: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
Date:   Thu Dec 12 10:37:35 2019 -0500

    drm/amd/display: Fix DML dummyinteger types mismatch
    
    [Why]
    The types for dummyinteger1 and dummyinteger2 are unsigned
    as part of the DML spec. They should not be long.
    
    [How]
    Make them unsigned int instead of long.
    
    Signed-off-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index e7a44df676ca..2875efd85467 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -763,8 +763,8 @@ struct vba_vars_st {
 	double SwathWidthC[DC__NUM_DPP__MAX];
 	unsigned int BytePerPixelY[DC__NUM_DPP__MAX];
 	unsigned int BytePerPixelC[DC__NUM_DPP__MAX];
-	long dummyinteger1;
-	long dummyinteger2;
+	unsigned int dummyinteger1;
+	unsigned int dummyinteger2;
 	double FinalDRAMClockChangeLatency;
 	double Tdmdl_vm[DC__NUM_DPP__MAX];
 	double Tdmdl[DC__NUM_DPP__MAX];

commit 5fc11598166db9e5858164bb105c09f0350e7486
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Oct 30 15:25:19 2019 -0400

    drm/amd/display: expand dml structs
    
    Add more fields to support upcoming dml versions
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index 3eb657ed5714..e7a44df676ca 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -157,6 +157,7 @@ struct vba_vars_st {
 	bool DummyPStateCheck;
 	bool DRAMClockChangeSupportsVActive;
 	bool PrefetchModeSupported;
+	bool PrefetchAndImmediateFlipSupported;
 	enum self_refresh_affinity AllowDRAMSelfRefreshOrDRAMClockChangeInVblank; // Mode Support only
 	double XFCRemoteSurfaceFlipDelay;
 	double TInitXFill;
@@ -318,8 +319,7 @@ struct vba_vars_st {
 	unsigned int DynamicMetadataTransmittedBytes[DC__NUM_DPP__MAX];
 	double DCCRate[DC__NUM_DPP__MAX];
 	double AverageDCCCompressionRate;
-	bool ODMCombineEnabled[DC__NUM_DPP__MAX];
-	enum odm_combine_mode ODMCombineTypeEnabled[DC__NUM_DPP__MAX];
+	enum odm_combine_mode ODMCombineEnabled[DC__NUM_DPP__MAX];
 	double OutputBpp[DC__NUM_DPP__MAX];
 	bool DSCEnabled[DC__NUM_DPP__MAX];
 	unsigned int DSCInputBitPerComponent[DC__NUM_DPP__MAX];
@@ -347,6 +347,7 @@ struct vba_vars_st {
 	unsigned int EffectiveLBLatencyHidingSourceLinesChroma;
 	double BandwidthAvailableForImmediateFlip;
 	unsigned int PrefetchMode[DC__VOLTAGE_STATES + 1][2];
+	unsigned int PrefetchModePerState[DC__VOLTAGE_STATES + 1][2];
 	unsigned int MinPrefetchMode;
 	unsigned int MaxPrefetchMode;
 	bool AnyLinesForVMOrRowTooLarge;
@@ -396,6 +397,7 @@ struct vba_vars_st {
 	bool WritebackLumaAndChromaScalingSupported;
 	bool Cursor64BppSupport;
 	double DCFCLKPerState[DC__VOLTAGE_STATES + 1];
+	double DCFCLKState[DC__VOLTAGE_STATES + 1][2];
 	double FabricClockPerState[DC__VOLTAGE_STATES + 1];
 	double SOCCLKPerState[DC__VOLTAGE_STATES + 1];
 	double PHYCLKPerState[DC__VOLTAGE_STATES + 1];
@@ -444,7 +446,7 @@ struct vba_vars_st {
 	double OutputLinkDPLanes[DC__NUM_DPP__MAX];
 	double ForcedOutputLinkBPP[DC__NUM_DPP__MAX]; // Mode Support only
 	double ImmediateFlipBW[DC__NUM_DPP__MAX];
-	double MaxMaxVStartup;
+	double MaxMaxVStartup[DC__VOLTAGE_STATES + 1][2];
 
 	double WritebackLumaVExtra;
 	double WritebackChromaVExtra;
@@ -471,7 +473,7 @@ struct vba_vars_st {
 	double RoundedUpMaxSwathSizeBytesC;
 	double EffectiveDETLBLinesLuma;
 	double EffectiveDETLBLinesChroma;
-	double ProjectedDCFCLKDeepSleep;
+	double ProjectedDCFCLKDeepSleep[DC__VOLTAGE_STATES + 1][2];
 	double PDEAndMetaPTEBytesPerFrameY;
 	double PDEAndMetaPTEBytesPerFrameC;
 	unsigned int MetaRowBytesY;
@@ -489,12 +491,11 @@ struct vba_vars_st {
 	double FractionOfUrgentBandwidthImmediateFlip; // Mode Support debugging output
 
 	/* ms locals */
-	double IdealSDPPortBandwidthPerState[DC__VOLTAGE_STATES + 1];
+	double IdealSDPPortBandwidthPerState[DC__VOLTAGE_STATES + 1][2];
 	unsigned int NoOfDPP[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
 	int NoOfDPPThisState[DC__NUM_DPP__MAX];
-	bool ODMCombineEnablePerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	enum odm_combine_mode ODMCombineTypeEnablePerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	unsigned int SwathWidthYThisState[DC__NUM_DPP__MAX];
+	enum odm_combine_mode ODMCombineEnablePerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	double SwathWidthYThisState[DC__NUM_DPP__MAX];
 	unsigned int SwathHeightCPerState[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
 	unsigned int SwathHeightYThisState[DC__NUM_DPP__MAX];
 	unsigned int SwathHeightCThisState[DC__NUM_DPP__MAX];
@@ -506,7 +507,7 @@ struct vba_vars_st {
 	double RequiredDPPCLKThisState[DC__NUM_DPP__MAX];
 	bool PTEBufferSizeNotExceededY[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
 	bool PTEBufferSizeNotExceededC[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
-	bool BandwidthWithoutPrefetchSupported[DC__VOLTAGE_STATES + 1];
+	bool BandwidthWithoutPrefetchSupported[DC__VOLTAGE_STATES + 1][2];
 	bool PrefetchSupported[DC__VOLTAGE_STATES + 1][2];
 	bool VRatioInPrefetchSupported[DC__VOLTAGE_STATES + 1][2];
 	double RequiredDISPCLK[DC__VOLTAGE_STATES + 1][2];
@@ -515,22 +516,22 @@ struct vba_vars_st {
 	unsigned int TotalNumberOfActiveDPP[DC__VOLTAGE_STATES + 1][2];
 	unsigned int TotalNumberOfDCCActiveDPP[DC__VOLTAGE_STATES + 1][2];
 	bool ModeSupport[DC__VOLTAGE_STATES + 1][2];
-	double ReturnBWPerState[DC__VOLTAGE_STATES + 1];
+	double ReturnBWPerState[DC__VOLTAGE_STATES + 1][2];
 	bool DIOSupport[DC__VOLTAGE_STATES + 1];
 	bool NotEnoughDSCUnits[DC__VOLTAGE_STATES + 1];
 	bool DSCCLKRequiredMoreThanSupported[DC__VOLTAGE_STATES + 1];
 	bool DTBCLKRequiredMoreThanSupported[DC__VOLTAGE_STATES + 1];
 	double UrgentRoundTripAndOutOfOrderLatencyPerState[DC__VOLTAGE_STATES + 1];
-	bool ROBSupport[DC__VOLTAGE_STATES + 1];
+	bool ROBSupport[DC__VOLTAGE_STATES + 1][2];
 	bool PTEBufferSizeNotExceeded[DC__VOLTAGE_STATES + 1][2];
-	bool TotalVerticalActiveBandwidthSupport[DC__VOLTAGE_STATES + 1];
-	double MaxTotalVerticalActiveAvailableBandwidth[DC__VOLTAGE_STATES + 1];
+	bool TotalVerticalActiveBandwidthSupport[DC__VOLTAGE_STATES + 1][2];
+	double MaxTotalVerticalActiveAvailableBandwidth[DC__VOLTAGE_STATES + 1][2];
 	double PrefetchBW[DC__NUM_DPP__MAX];
-	double PDEAndMetaPTEBytesPerFrame[DC__NUM_DPP__MAX];
-	double MetaRowBytes[DC__NUM_DPP__MAX];
-	double DPTEBytesPerRow[DC__NUM_DPP__MAX];
-	double PrefetchLinesY[DC__NUM_DPP__MAX];
-	double PrefetchLinesC[DC__NUM_DPP__MAX];
+	double PDEAndMetaPTEBytesPerFrame[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double MetaRowBytes[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double DPTEBytesPerRow[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double PrefetchLinesY[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double PrefetchLinesC[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
 	unsigned int MaxNumSwY[DC__NUM_DPP__MAX];
 	unsigned int MaxNumSwC[DC__NUM_DPP__MAX];
 	double PrefillY[DC__NUM_DPP__MAX];
@@ -539,7 +540,7 @@ struct vba_vars_st {
 	double LinesForMetaPTE[DC__NUM_DPP__MAX];
 	double LinesForMetaAndDPTERow[DC__NUM_DPP__MAX];
 	double MinDPPCLKUsingSingleDPP[DC__NUM_DPP__MAX];
-	unsigned int SwathWidthYSingleDPP[DC__NUM_DPP__MAX];
+	double SwathWidthYSingleDPP[DC__NUM_DPP__MAX];
 	double BytePerPixelInDETY[DC__NUM_DPP__MAX];
 	double BytePerPixelInDETC[DC__NUM_DPP__MAX];
 	bool RequiresDSC[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
@@ -547,7 +548,7 @@ struct vba_vars_st {
 	double RequiresFEC[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
 	double OutputBppPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
 	double DSCDelayPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	bool ViewportSizeSupport[DC__VOLTAGE_STATES + 1];
+	bool ViewportSizeSupport[DC__VOLTAGE_STATES + 1][2];
 	unsigned int Read256BlockHeightY[DC__NUM_DPP__MAX];
 	unsigned int Read256BlockWidthY[DC__NUM_DPP__MAX];
 	unsigned int Read256BlockHeightC[DC__NUM_DPP__MAX];
@@ -562,7 +563,7 @@ struct vba_vars_st {
 	double WriteBandwidth[DC__NUM_DPP__MAX];
 	double PSCL_FACTOR[DC__NUM_DPP__MAX];
 	double PSCL_FACTOR_CHROMA[DC__NUM_DPP__MAX];
-	double MaximumVStartup[DC__NUM_DPP__MAX];
+	double MaximumVStartup[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
 	unsigned int MacroTileWidthY[DC__NUM_DPP__MAX];
 	unsigned int MacroTileWidthC[DC__NUM_DPP__MAX];
 	double AlignedDCCMetaPitch[DC__NUM_DPP__MAX];
@@ -579,7 +580,7 @@ struct vba_vars_st {
 	bool ImmediateFlipSupportedForState[DC__VOLTAGE_STATES + 1][2];
 	double WritebackDelay[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
 	unsigned int vm_group_bytes[DC__NUM_DPP__MAX];
-	long dpte_group_bytes[DC__NUM_DPP__MAX];
+	unsigned int dpte_group_bytes[DC__NUM_DPP__MAX];
 	unsigned int dpte_row_height[DC__NUM_DPP__MAX];
 	unsigned int meta_req_height[DC__NUM_DPP__MAX];
 	unsigned int meta_req_width[DC__NUM_DPP__MAX];
@@ -605,14 +606,14 @@ struct vba_vars_st {
 	double UrgentBurstFactorChroma[DC__NUM_DPP__MAX];
 	double UrgentBurstFactorChromaPre[DC__NUM_DPP__MAX];
 
+
 	bool           MPCCombine[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
 	double         SwathWidthCSingleDPP[DC__NUM_DPP__MAX];
 	double         MaximumSwathWidthInLineBufferLuma;
 	double         MaximumSwathWidthInLineBufferChroma;
 	double         MaximumSwathWidthLuma[DC__NUM_DPP__MAX];
 	double         MaximumSwathWidthChroma[DC__NUM_DPP__MAX];
-	bool odm_combine_dummy[DC__NUM_DPP__MAX];
-	enum odm_combine_mode odm_combine_mode_dummy[DC__NUM_DPP__MAX];
+	enum odm_combine_mode odm_combine_dummy[DC__NUM_DPP__MAX];
 	double         dummy1[DC__NUM_DPP__MAX];
 	double         dummy2[DC__NUM_DPP__MAX];
 	double         dummy3[DC__NUM_DPP__MAX];
@@ -622,9 +623,9 @@ struct vba_vars_st {
 	double         dummy7[DC__NUM_DPP__MAX];
 	double         dummy8[DC__NUM_DPP__MAX];
 	unsigned int        dummyinteger1ms[DC__NUM_DPP__MAX];
-	unsigned int        dummyinteger2ms[DC__NUM_DPP__MAX];
+	double        dummyinteger2ms[DC__NUM_DPP__MAX];
 	unsigned int        dummyinteger3[DC__NUM_DPP__MAX];
-	unsigned int        dummyinteger4;
+	unsigned int        dummyinteger4[DC__NUM_DPP__MAX];
 	unsigned int        dummyinteger5;
 	unsigned int        dummyinteger6;
 	unsigned int        dummyinteger7;
@@ -637,7 +638,6 @@ struct vba_vars_st {
 	unsigned int        dummyintegerarr2[DC__NUM_DPP__MAX];
 	unsigned int        dummyintegerarr3[DC__NUM_DPP__MAX];
 	unsigned int        dummyintegerarr4[DC__NUM_DPP__MAX];
-	long                dummylongarr1[DC__NUM_DPP__MAX];
 	bool           dummysinglestring;
 	bool           SingleDPPViewportSizeSupportPerPlane[DC__NUM_DPP__MAX];
 	double         PlaneRequiredDISPCLKWithODMCombine2To1;
@@ -645,20 +645,19 @@ struct vba_vars_st {
 	unsigned int   TotalNumberOfSingleDPPPlanes[DC__VOLTAGE_STATES + 1][2];
 	bool           LinkDSCEnable;
 	bool           ODMCombine4To1SupportCheckOK[DC__VOLTAGE_STATES + 1];
-	bool ODMCombineEnableThisState[DC__NUM_DPP__MAX];
-	enum odm_combine_mode ODMCombineEnableTypeThisState[DC__NUM_DPP__MAX];
-	unsigned int   SwathWidthCThisState[DC__NUM_DPP__MAX];
+	enum odm_combine_mode ODMCombineEnableThisState[DC__NUM_DPP__MAX];
+	double   SwathWidthCThisState[DC__NUM_DPP__MAX];
 	bool           ViewportSizeSupportPerPlane[DC__NUM_DPP__MAX];
 	double         AlignedDCCMetaPitchY[DC__NUM_DPP__MAX];
 	double         AlignedDCCMetaPitchC[DC__NUM_DPP__MAX];
 
 	unsigned int NotEnoughUrgentLatencyHiding;
 	unsigned int NotEnoughUrgentLatencyHidingPre;
-	long PTEBufferSizeInRequestsForLuma;
-	long PTEBufferSizeInRequestsForChroma;
+	int PTEBufferSizeInRequestsForLuma;
+	int PTEBufferSizeInRequestsForChroma;
 
 	// Missing from VBA
-	long dpte_group_bytes_chroma;
+	int dpte_group_bytes_chroma;
 	unsigned int vm_group_bytes_chroma;
 	double dst_x_after_scaler;
 	double dst_y_after_scaler;
@@ -683,8 +682,8 @@ struct vba_vars_st {
 	double MinTTUVBlank[DC__NUM_DPP__MAX];
 	double BytePerPixelDETY[DC__NUM_DPP__MAX];
 	double BytePerPixelDETC[DC__NUM_DPP__MAX];
-	unsigned int SwathWidthY[DC__NUM_DPP__MAX];
-	unsigned int SwathWidthSingleDPPY[DC__NUM_DPP__MAX];
+	double SwathWidthY[DC__NUM_DPP__MAX];
+	double SwathWidthSingleDPPY[DC__NUM_DPP__MAX];
 	double CursorRequestDeliveryTime[DC__NUM_DPP__MAX];
 	double CursorRequestDeliveryTimePrefetch[DC__NUM_DPP__MAX];
 	double ReadBandwidthPlaneLuma[DC__NUM_DPP__MAX];
@@ -760,8 +759,8 @@ struct vba_vars_st {
 	double LinesInDETY[DC__NUM_DPP__MAX];
 	double LinesInDETYRoundedDownToSwath[DC__NUM_DPP__MAX];
 
-	unsigned int SwathWidthSingleDPPC[DC__NUM_DPP__MAX];
-	unsigned int SwathWidthC[DC__NUM_DPP__MAX];
+	double SwathWidthSingleDPPC[DC__NUM_DPP__MAX];
+	double SwathWidthC[DC__NUM_DPP__MAX];
 	unsigned int BytePerPixelY[DC__NUM_DPP__MAX];
 	unsigned int BytePerPixelC[DC__NUM_DPP__MAX];
 	long dummyinteger1;
@@ -779,6 +778,7 @@ struct vba_vars_st {
 	unsigned int DCCCMaxCompressedBlock[DC__NUM_DPP__MAX];
 	unsigned int DCCCIndependent64ByteBlock[DC__NUM_DPP__MAX];
 	double VStartupMargin;
+	bool NotEnoughTimeForDynamicMetadata;
 
 	/* Missing from VBA */
 	unsigned int MaximumMaxVStartupLines;
@@ -814,7 +814,7 @@ struct vba_vars_st {
 	unsigned int ViewportHeightChroma[DC__NUM_DPP__MAX];
 	double HRatioChroma[DC__NUM_DPP__MAX];
 	double VRatioChroma[DC__NUM_DPP__MAX];
-	long WritebackSourceWidth[DC__NUM_DPP__MAX];
+	int WritebackSourceWidth[DC__NUM_DPP__MAX];
 
 	bool ModeIsSupported;
 	bool ODMCombine4To1Supported;
@@ -850,6 +850,58 @@ struct vba_vars_st {
 	unsigned int MaxNumHDMIFRLOutputs;
 	int    AudioSampleRate[DC__NUM_DPP__MAX];
 	int    AudioSampleLayout[DC__NUM_DPP__MAX];
+
+	int PercentMarginOverMinimumRequiredDCFCLK;
+	bool DynamicMetadataSupported[DC__VOLTAGE_STATES + 1][2];
+	enum immediate_flip_requirement ImmediateFlipRequirement;
+	double DETBufferSizeYThisState[DC__NUM_DPP__MAX];
+	double DETBufferSizeCThisState[DC__NUM_DPP__MAX];
+	bool NoUrgentLatencyHiding[DC__NUM_DPP__MAX];
+	bool NoUrgentLatencyHidingPre[DC__NUM_DPP__MAX];
+	int swath_width_luma_ub_this_state[DC__NUM_DPP__MAX];
+	int swath_width_chroma_ub_this_state[DC__NUM_DPP__MAX];
+	double UrgLatency[DC__VOLTAGE_STATES + 1];
+	double VActiveCursorBandwidth[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double VActivePixelBandwidth[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	bool NoTimeForPrefetch[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	bool NoTimeForDynamicMetadata[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double dpte_row_bandwidth[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double meta_row_bandwidth[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double DETBufferSizeYAllStates[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double DETBufferSizeCAllStates[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	int swath_width_luma_ub_all_states[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	int swath_width_chroma_ub_all_states[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	bool NotUrgentLatencyHiding[DC__VOLTAGE_STATES + 1][2];
+	unsigned int SwathHeightYAllStates[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	unsigned int SwathHeightCAllStates[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	unsigned int SwathWidthYAllStates[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	unsigned int SwathWidthCAllStates[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double TotalDPTERowBandwidth[DC__VOLTAGE_STATES + 1][2];
+	double TotalMetaRowBandwidth[DC__VOLTAGE_STATES + 1][2];
+	double TotalVActiveCursorBandwidth[DC__VOLTAGE_STATES + 1][2];
+	double TotalVActivePixelBandwidth[DC__VOLTAGE_STATES + 1][2];
+	bool UseMinimumRequiredDCFCLK;
+	double WritebackDelayTime[DC__NUM_DPP__MAX];
+	unsigned int DCCYIndependentBlock[DC__NUM_DPP__MAX];
+	unsigned int DCCCIndependentBlock[DC__NUM_DPP__MAX];
+	unsigned int dummyinteger15;
+	unsigned int dummyinteger16;
+	unsigned int dummyinteger17;
+	unsigned int dummyinteger18;
+	unsigned int dummyinteger19;
+	unsigned int dummyinteger20;
+	unsigned int dummyinteger21;
+	unsigned int dummyinteger22;
+	unsigned int dummyinteger23;
+	unsigned int dummyinteger24;
+	unsigned int dummyinteger25;
+	unsigned int dummyinteger26;
+	unsigned int dummyinteger27;
+	unsigned int dummyinteger28;
+	unsigned int dummyinteger29;
+	bool dummystring[DC__NUM_DPP__MAX];
+	double BPP;
+	enum odm_combine_policy ODMCombinePolicy;
 };
 
 bool CalculateMinAndMaxPrefetchMode(

commit 1da37801a8b0fffb024fea594c7f1d7867ed8aa0
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:38:55 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_0 and DSC_SUPPORTED
    
    [Why]
    
    DCN2 and DSC are stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup NV defninitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN2 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * dce/dce_dmcu.c: dcn20_*lock_phy()
        * dce/dce_dmcu.c: dcn20_funcs
        * dce/dce_dmcu.c: dcn20_dmcu_create()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index 6d8b5c61de68..3eb657ed5714 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -23,7 +23,6 @@
  *
  */
 
-#ifdef CONFIG_DRM_AMD_DC_DCN2_0
 
 #ifndef __DML2_DISPLAY_MODE_VBA_H__
 #define __DML2_DISPLAY_MODE_VBA_H__
@@ -872,4 +871,3 @@ double CalculateWriteBackDISPCLK(
 		unsigned int WritebackChromaLineBufferWidth);
 
 #endif /* _DML2_DISPLAY_MODE_VBA_H_ */
-#endif

commit 5622b2d68d0a6e2fd960f2129704dc3c561608b2
Author: David Galiffi <David.Galiffi@amd.com>
Date:   Tue Oct 1 18:29:56 2019 -0400

    drm/amd/display: Create debug option to disable v.active clock change policy.
    
    [WHY]
    It has been a useful option in debugging GFXOFF and P.State Change issues.
    May be required as for platform specific workaround.
    
    [HOW]
    Create option in enum dc_debug_options, "disable_vactive_clock_change".
    When it is set, dm_dram_clock_change_vactive, will translate into
    p_state_change_support: false.
    
    Signed-off-by: David Galiffi <David.Galiffi@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index 6c59a332093a..6d8b5c61de68 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -156,6 +156,7 @@ struct vba_vars_st {
 	unsigned int DSCFormatFactor;
 
 	bool DummyPStateCheck;
+	bool DRAMClockChangeSupportsVActive;
 	bool PrefetchModeSupported;
 	enum self_refresh_affinity AllowDRAMSelfRefreshOrDRAMClockChangeInVblank; // Mode Support only
 	double XFCRemoteSurfaceFlipDelay;

commit 47f365645a3b4a6f094fdfab080817676bfcb417
Author: David Galiffi <David.Galiffi@amd.com>
Date:   Sat Oct 12 16:18:32 2019 -0400

    drm/amd/display: Fix assert observed when performing dummy p-state check
    
    [WHY]
    V.Active dram clock change workaround need a small modification for DMLv2
    to ensure that the dummy p-state check doesn't fail.
    
    Signed-off-by: David Galiffi <David.Galiffi@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index 1540ffbe3979..6c59a332093a 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -155,6 +155,7 @@ struct vba_vars_st {
 	double UrgentLatencySupportUsChroma;
 	unsigned int DSCFormatFactor;
 
+	bool DummyPStateCheck;
 	bool PrefetchModeSupported;
 	enum self_refresh_affinity AllowDRAMSelfRefreshOrDRAMClockChangeInVblank; // Mode Support only
 	double XFCRemoteSurfaceFlipDelay;

commit d5ac4ff211a3208b343c2c4d8a8da82f3ce4e948
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Oct 1 16:08:31 2019 -0400

    drm/amd/display: add embedded flag to dml
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index 91decac50557..1540ffbe3979 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -387,6 +387,7 @@ struct vba_vars_st {
 
 	/* vba mode support */
 	/*inputs*/
+	bool EmbeddedPanel[DC__NUM_DPP__MAX];
 	bool SupportGFX7CompatibleTilingIn32bppAnd64bpp;
 	double MaxHSCLRatio;
 	double MaxVSCLRatio;

commit 92a3701c438b069ac79b55e1ddfcc7907002ad39
Author: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
Date:   Wed Jul 24 12:36:55 2019 -0400

    drm/amd/display: Fix type of ODMCombineType field
    
    The type was changed previously to better reflect possible register
    values.
    
    Signed-off-by: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index 52d2583b2f74..91decac50557 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -491,7 +491,7 @@ struct vba_vars_st {
 	unsigned int NoOfDPP[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
 	int NoOfDPPThisState[DC__NUM_DPP__MAX];
 	bool ODMCombineEnablePerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	bool ODMCombineTypeEnablePerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	enum odm_combine_mode ODMCombineTypeEnablePerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
 	unsigned int SwathWidthYThisState[DC__NUM_DPP__MAX];
 	unsigned int SwathHeightCPerState[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
 	unsigned int SwathHeightYThisState[DC__NUM_DPP__MAX];

commit 1071a0ecf4a6a1fb7c98bf8351ebf414265cb780
Author: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
Date:   Wed Jul 17 18:33:48 2019 -0400

    drm/amd/display: Update DML parameters
    
    [Why]
    Need to add DML struct members that were omitted in previous
    DML implemenations.
    
    [How]
    - Add missing enum values
    - Add missing struct members
    - Set new input values in the fetch functions
    
    Signed-off-by: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index 0347f74cda3a..52d2583b2f74 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -290,6 +290,7 @@ struct vba_vars_st {
 	double PixelClock[DC__NUM_DPP__MAX];
 	double PixelClockBackEnd[DC__NUM_DPP__MAX];
 	bool DCCEnable[DC__NUM_DPP__MAX];
+	bool FECEnable[DC__NUM_DPP__MAX];
 	unsigned int DCCMetaPitchY[DC__NUM_DPP__MAX];
 	unsigned int DCCMetaPitchC[DC__NUM_DPP__MAX];
 	enum scan_direction_class SourceScan[DC__NUM_DPP__MAX];
@@ -317,6 +318,7 @@ struct vba_vars_st {
 	double DCCRate[DC__NUM_DPP__MAX];
 	double AverageDCCCompressionRate;
 	bool ODMCombineEnabled[DC__NUM_DPP__MAX];
+	enum odm_combine_mode ODMCombineTypeEnabled[DC__NUM_DPP__MAX];
 	double OutputBpp[DC__NUM_DPP__MAX];
 	bool DSCEnabled[DC__NUM_DPP__MAX];
 	unsigned int DSCInputBitPerComponent[DC__NUM_DPP__MAX];
@@ -395,6 +397,7 @@ struct vba_vars_st {
 	double FabricClockPerState[DC__VOLTAGE_STATES + 1];
 	double SOCCLKPerState[DC__VOLTAGE_STATES + 1];
 	double PHYCLKPerState[DC__VOLTAGE_STATES + 1];
+	double DTBCLKPerState[DC__VOLTAGE_STATES + 1];
 	double MaxDppclk[DC__VOLTAGE_STATES + 1];
 	double MaxDSCCLK[DC__VOLTAGE_STATES + 1];
 	double DRAMSpeedPerState[DC__VOLTAGE_STATES + 1];
@@ -488,6 +491,7 @@ struct vba_vars_st {
 	unsigned int NoOfDPP[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
 	int NoOfDPPThisState[DC__NUM_DPP__MAX];
 	bool ODMCombineEnablePerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	bool ODMCombineTypeEnablePerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
 	unsigned int SwathWidthYThisState[DC__NUM_DPP__MAX];
 	unsigned int SwathHeightCPerState[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
 	unsigned int SwathHeightYThisState[DC__NUM_DPP__MAX];
@@ -513,6 +517,7 @@ struct vba_vars_st {
 	bool DIOSupport[DC__VOLTAGE_STATES + 1];
 	bool NotEnoughDSCUnits[DC__VOLTAGE_STATES + 1];
 	bool DSCCLKRequiredMoreThanSupported[DC__VOLTAGE_STATES + 1];
+	bool DTBCLKRequiredMoreThanSupported[DC__VOLTAGE_STATES + 1];
 	double UrgentRoundTripAndOutOfOrderLatencyPerState[DC__VOLTAGE_STATES + 1];
 	bool ROBSupport[DC__VOLTAGE_STATES + 1];
 	bool PTEBufferSizeNotExceeded[DC__VOLTAGE_STATES + 1][2];
@@ -605,6 +610,7 @@ struct vba_vars_st {
 	double         MaximumSwathWidthLuma[DC__NUM_DPP__MAX];
 	double         MaximumSwathWidthChroma[DC__NUM_DPP__MAX];
 	bool odm_combine_dummy[DC__NUM_DPP__MAX];
+	enum odm_combine_mode odm_combine_mode_dummy[DC__NUM_DPP__MAX];
 	double         dummy1[DC__NUM_DPP__MAX];
 	double         dummy2[DC__NUM_DPP__MAX];
 	double         dummy3[DC__NUM_DPP__MAX];
@@ -625,6 +631,11 @@ struct vba_vars_st {
 	unsigned int        dummyinteger10;
 	unsigned int        dummyinteger11;
 	unsigned int        dummyinteger12;
+	unsigned int        dummyintegerarr1[DC__NUM_DPP__MAX];
+	unsigned int        dummyintegerarr2[DC__NUM_DPP__MAX];
+	unsigned int        dummyintegerarr3[DC__NUM_DPP__MAX];
+	unsigned int        dummyintegerarr4[DC__NUM_DPP__MAX];
+	long                dummylongarr1[DC__NUM_DPP__MAX];
 	bool           dummysinglestring;
 	bool           SingleDPPViewportSizeSupportPerPlane[DC__NUM_DPP__MAX];
 	double         PlaneRequiredDISPCLKWithODMCombine2To1;
@@ -633,6 +644,7 @@ struct vba_vars_st {
 	bool           LinkDSCEnable;
 	bool           ODMCombine4To1SupportCheckOK[DC__VOLTAGE_STATES + 1];
 	bool ODMCombineEnableThisState[DC__NUM_DPP__MAX];
+	enum odm_combine_mode ODMCombineEnableTypeThisState[DC__NUM_DPP__MAX];
 	unsigned int   SwathWidthCThisState[DC__NUM_DPP__MAX];
 	bool           ViewportSizeSupportPerPlane[DC__NUM_DPP__MAX];
 	double         AlignedDCCMetaPitchY[DC__NUM_DPP__MAX];
@@ -641,6 +653,7 @@ struct vba_vars_st {
 	unsigned int NotEnoughUrgentLatencyHiding;
 	unsigned int NotEnoughUrgentLatencyHidingPre;
 	long PTEBufferSizeInRequestsForLuma;
+	long PTEBufferSizeInRequestsForChroma;
 
 	// Missing from VBA
 	long dpte_group_bytes_chroma;
@@ -787,6 +800,9 @@ struct vba_vars_st {
 	unsigned int PDEProcessingBufIn64KBReqs;
 
 	double MaxTotalVActiveRDBandwidth;
+	bool DoUrgentLatencyAdjustment;
+	double UrgentLatencyAdjustmentFabricClockComponent;
+	double UrgentLatencyAdjustmentFabricClockReference;
 	double MinUrgentLatencySupportUs;
 	double MinFullDETBufferingTime;
 	double AverageReadBandwidthGBytePerSecond;
@@ -801,6 +817,8 @@ struct vba_vars_st {
 	bool ModeIsSupported;
 	bool ODMCombine4To1Supported;
 
+	unsigned int SurfaceWidthY[DC__NUM_DPP__MAX];
+	unsigned int SurfaceWidthC[DC__NUM_DPP__MAX];
 	unsigned int SurfaceHeightY[DC__NUM_DPP__MAX];
 	unsigned int SurfaceHeightC[DC__NUM_DPP__MAX];
 	unsigned int WritebackHTaps[DC__NUM_DPP__MAX];

commit 4f008d931b9f4d1cfeb88f04579786b3b2c3dcf2
Author: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
Date:   Thu May 16 14:33:14 2019 -0400

    drm/amd/display: Fix incorrect vba type
    
    SwathWidthCThisState is expected to be an unsigned int array.
    
    Signed-off-by: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index faf33e77e8d4..0347f74cda3a 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -633,7 +633,7 @@ struct vba_vars_st {
 	bool           LinkDSCEnable;
 	bool           ODMCombine4To1SupportCheckOK[DC__VOLTAGE_STATES + 1];
 	bool ODMCombineEnableThisState[DC__NUM_DPP__MAX];
-	double         SwathWidthCThisState[DC__NUM_DPP__MAX];
+	unsigned int   SwathWidthCThisState[DC__NUM_DPP__MAX];
 	bool           ViewportSizeSupportPerPlane[DC__NUM_DPP__MAX];
 	double         AlignedDCCMetaPitchY[DC__NUM_DPP__MAX];
 	double         AlignedDCCMetaPitchC[DC__NUM_DPP__MAX];

commit a746a2585542179bf9ec37c5243a10a6490ba41d
Author: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
Date:   Fri May 3 12:59:35 2019 -0400

    drm/amd/display: Drive-by fixes for display_mode_vba
    
    Fixes for the following:
    - Incorrect pointer type (unsigned int instead of double)
    - Incorrect DSC number of slices setting
    
    Signed-off-by: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index 75028007095c..faf33e77e8d4 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -455,7 +455,7 @@ struct vba_vars_st {
 	double TotalNumberOfActiveOTG;
 	double FECOverhead;
 	double EffectiveFECOverhead;
-	unsigned int Outbpp;
+	double Outbpp;
 	unsigned int OutbppDSC;
 	double TotalDSCUnitsRequired;
 	double bpp;
@@ -538,7 +538,7 @@ struct vba_vars_st {
 	bool RequiresDSC[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
 	unsigned int NumberOfDSCSlice[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
 	double RequiresFEC[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	unsigned int OutputBppPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	double OutputBppPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
 	double DSCDelayPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
 	bool ViewportSizeSupport[DC__VOLTAGE_STATES + 1];
 	unsigned int Read256BlockHeightY[DC__NUM_DPP__MAX];

commit 8bb3d7e7b5de731a990af8fe6d99a30751602f15
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Fri Apr 26 00:29:13 2019 -0400

    drm/amd/display: used optimum VSTARTUP instead of MaxVStartup
    
    [Description]
    Features that are desirable for minimizing the Global Sync Period:
    DRR and lateflip
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index 4e0183dd634a..75028007095c 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -284,6 +284,8 @@ struct vba_vars_st {
 	unsigned int VTAPsChroma[DC__NUM_DPP__MAX];
 	unsigned int HTotal[DC__NUM_DPP__MAX];
 	unsigned int VTotal[DC__NUM_DPP__MAX];
+	unsigned int VTotal_Max[DC__NUM_DPP__MAX];
+	unsigned int VTotal_Min[DC__NUM_DPP__MAX];
 	int DPPPerPlane[DC__NUM_DPP__MAX];
 	double PixelClock[DC__NUM_DPP__MAX];
 	double PixelClockBackEnd[DC__NUM_DPP__MAX];

commit 776c1f569f94e39a1776c22f29137661f294ff03
Author: Leo Li <sunpeng.li@amd.com>
Date:   Mon Mar 25 21:11:07 2019 -0400

    drm/amd/display: Properly guard display_mode_vba with DCN2
    
    [Why]
    
    display_mode_vba is for DCN2 and up. When building for upstream (DCN1
    enabled only), there will be a build error, since display_mode_vba.c/h
    is stripped out.
    
    Note that building DCN1 only with internal dal-dev is still fine, since
    display_mode_vba.h is not stripped out internally - only in upstream.
    The make directives therefore stll work, and so will any #include's.
    
    [How]
    
    Since subsequent generations require DCN2 enabled anyways, guard the
    makefile directive for display_mode_vba.o with DCN2. Guard any includes
    with DCN2. In addition, guard the entire contents of display_mode_vba.h
    with DCN2, to simulate the file being stripped out in upstream.
    
    A forward declaration for 'struct display_mode_lib' also needs to be
    added in display_mode_lib.h. Previously, display_mode_vba.h contained
    the forward declaration, and display_mode_lib.h in turn included it.
    This won't work if mode_vba.h is stripped out, requring mode_lib.h to do
    so itself.
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index 38fc0ab32d7b..4e0183dd634a 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -23,6 +23,8 @@
  *
  */
 
+#ifdef CONFIG_DRM_AMD_DC_DCN2_0
+
 #ifndef __DML2_DISPLAY_MODE_VBA_H__
 #define __DML2_DISPLAY_MODE_VBA_H__
 
@@ -847,3 +849,4 @@ double CalculateWriteBackDISPCLK(
 		unsigned int WritebackChromaLineBufferWidth);
 
 #endif /* _DML2_DISPLAY_MODE_VBA_H_ */
+#endif

commit 5cb646d767bb3d1d85c9828afad505bb9ee1982a
Author: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
Date:   Fri Apr 12 16:47:08 2019 -0400

    drm/amd/display: Add writeback_config to VBA vars
    
    Adding writeback_config enum to vba_vars_st, replacing old flag.
    Initialize to dm_normal.
    
    Signed-off-by: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index d488c05131f9..38fc0ab32d7b 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -237,6 +237,7 @@ struct vba_vars_st {
 	unsigned int WritebackInterfaceLumaBufferSize;
 	unsigned int WritebackInterfaceChromaBufferSize;
 	unsigned int WritebackChromaLineBufferWidth;
+	enum writeback_config WritebackConfiguration;
 	double MaxDCHUBToPSCLThroughput;
 	double MaxPSCLToLBThroughput;
 	unsigned int PTEBufferSizeInRequestsLuma;

commit 728c06986a4f386c7ec5e5170716e30b610c6d32
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Feb 22 09:59:43 2019 -0500

    drm/amd/display: Add DCN2 changes to DML
    
    Update DML (Display Mode Lib) to support DCN2
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
new file mode 100644
index 000000000000..d488c05131f9
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -0,0 +1,848 @@
+/*
+ * Copyright 2017 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#ifndef __DML2_DISPLAY_MODE_VBA_H__
+#define __DML2_DISPLAY_MODE_VBA_H__
+
+#include "dml_common_defs.h"
+
+struct display_mode_lib;
+
+void ModeSupportAndSystemConfiguration(struct display_mode_lib *mode_lib);
+
+#define dml_get_attr_decl(attr) double get_##attr(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes)
+
+dml_get_attr_decl(clk_dcf_deepsleep);
+dml_get_attr_decl(wm_urgent);
+dml_get_attr_decl(wm_memory_trip);
+dml_get_attr_decl(wm_writeback_urgent);
+dml_get_attr_decl(wm_stutter_exit);
+dml_get_attr_decl(wm_stutter_enter_exit);
+dml_get_attr_decl(wm_dram_clock_change);
+dml_get_attr_decl(wm_writeback_dram_clock_change);
+dml_get_attr_decl(wm_xfc_underflow);
+dml_get_attr_decl(stutter_efficiency_no_vblank);
+dml_get_attr_decl(stutter_efficiency);
+dml_get_attr_decl(urgent_latency);
+dml_get_attr_decl(urgent_extra_latency);
+dml_get_attr_decl(nonurgent_latency);
+dml_get_attr_decl(dram_clock_change_latency);
+dml_get_attr_decl(dispclk_calculated);
+dml_get_attr_decl(total_data_read_bw);
+dml_get_attr_decl(return_bw);
+dml_get_attr_decl(tcalc);
+dml_get_attr_decl(fraction_of_urgent_bandwidth);
+dml_get_attr_decl(fraction_of_urgent_bandwidth_imm_flip);
+
+#define dml_get_pipe_attr_decl(attr) double get_##attr(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe)
+
+dml_get_pipe_attr_decl(dsc_delay);
+dml_get_pipe_attr_decl(dppclk_calculated);
+dml_get_pipe_attr_decl(dscclk_calculated);
+dml_get_pipe_attr_decl(min_ttu_vblank);
+dml_get_pipe_attr_decl(vratio_prefetch_l);
+dml_get_pipe_attr_decl(vratio_prefetch_c);
+dml_get_pipe_attr_decl(dst_x_after_scaler);
+dml_get_pipe_attr_decl(dst_y_after_scaler);
+dml_get_pipe_attr_decl(dst_y_per_vm_vblank);
+dml_get_pipe_attr_decl(dst_y_per_row_vblank);
+dml_get_pipe_attr_decl(dst_y_prefetch);
+dml_get_pipe_attr_decl(dst_y_per_vm_flip);
+dml_get_pipe_attr_decl(dst_y_per_row_flip);
+dml_get_pipe_attr_decl(xfc_transfer_delay);
+dml_get_pipe_attr_decl(xfc_precharge_delay);
+dml_get_pipe_attr_decl(xfc_remote_surface_flip_latency);
+dml_get_pipe_attr_decl(xfc_prefetch_margin);
+dml_get_pipe_attr_decl(refcyc_per_vm_group_vblank);
+dml_get_pipe_attr_decl(refcyc_per_vm_group_flip);
+dml_get_pipe_attr_decl(refcyc_per_vm_req_vblank);
+dml_get_pipe_attr_decl(refcyc_per_vm_req_flip);
+
+unsigned int get_vstartup_calculated(
+		struct display_mode_lib *mode_lib,
+		const display_e2e_pipe_params_st *pipes,
+		unsigned int num_pipes,
+		unsigned int which_pipe);
+
+double get_total_immediate_flip_bytes(
+		struct display_mode_lib *mode_lib,
+		const display_e2e_pipe_params_st *pipes,
+		unsigned int num_pipes);
+double get_total_immediate_flip_bw(
+		struct display_mode_lib *mode_lib,
+		const display_e2e_pipe_params_st *pipes,
+		unsigned int num_pipes);
+double get_total_prefetch_bw(
+		struct display_mode_lib *mode_lib,
+		const display_e2e_pipe_params_st *pipes,
+		unsigned int num_pipes);
+unsigned int dml_get_voltage_level(
+		struct display_mode_lib *mode_lib,
+		const display_e2e_pipe_params_st *pipes,
+		unsigned int num_pipes);
+
+void PixelClockAdjustmentForProgressiveToInterlaceUnit(struct display_mode_lib *mode_lib);
+
+bool Calculate256BBlockSizes(
+		enum source_format_class SourcePixelFormat,
+		enum dm_swizzle_mode SurfaceTiling,
+		unsigned int BytePerPixelY,
+		unsigned int BytePerPixelC,
+		unsigned int *BlockHeight256BytesY,
+		unsigned int *BlockHeight256BytesC,
+		unsigned int *BlockWidth256BytesY,
+		unsigned int *BlockWidth256BytesC);
+
+struct vba_vars_st {
+	ip_params_st ip;
+	soc_bounding_box_st soc;
+
+	int maxMpcComb;
+	bool UseMaximumVStartup;
+
+	double WritebackDISPCLK;
+	double DPPCLKUsingSingleDPPLuma;
+	double DPPCLKUsingSingleDPPChroma;
+	double DISPCLKWithRamping;
+	double DISPCLKWithoutRamping;
+	double GlobalDPPCLK;
+	double DISPCLKWithRampingRoundedToDFSGranularity;
+	double DISPCLKWithoutRampingRoundedToDFSGranularity;
+	double MaxDispclkRoundedToDFSGranularity;
+	bool DCCEnabledAnyPlane;
+	double ReturnBandwidthToDCN;
+	unsigned int TotalActiveDPP;
+	unsigned int TotalDCCActiveDPP;
+	double UrgentRoundTripAndOutOfOrderLatency;
+	double StutterPeriod;
+	double FrameTimeForMinFullDETBufferingTime;
+	double AverageReadBandwidth;
+	double TotalRowReadBandwidth;
+	double PartOfBurstThatFitsInROB;
+	double StutterBurstTime;
+	unsigned int NextPrefetchMode;
+	double NextMaxVStartup;
+	double VBlankTime;
+	double SmallestVBlank;
+	double DCFCLKDeepSleepPerPlane[DC__NUM_DPP__MAX];
+	double EffectiveDETPlusLBLinesLuma;
+	double EffectiveDETPlusLBLinesChroma;
+	double UrgentLatencySupportUsLuma;
+	double UrgentLatencySupportUsChroma;
+	unsigned int DSCFormatFactor;
+
+	bool PrefetchModeSupported;
+	enum self_refresh_affinity AllowDRAMSelfRefreshOrDRAMClockChangeInVblank; // Mode Support only
+	double XFCRemoteSurfaceFlipDelay;
+	double TInitXFill;
+	double TslvChk;
+	double SrcActiveDrainRate;
+	bool ImmediateFlipSupported;
+	enum mpc_combine_affinity WhenToDoMPCCombine; // Mode Support only
+
+	bool PrefetchERROR;
+
+	unsigned int VStartupLines;
+	unsigned int ActiveDPPs;
+	unsigned int LBLatencyHidingSourceLinesY;
+	unsigned int LBLatencyHidingSourceLinesC;
+	double ActiveDRAMClockChangeLatencyMargin[DC__NUM_DPP__MAX];
+	double MinActiveDRAMClockChangeMargin;
+	double InitFillLevel;
+	double FinalFillMargin;
+	double FinalFillLevel;
+	double RemainingFillLevel;
+	double TFinalxFill;
+
+	//
+	// SOC Bounding Box Parameters
+	//
+	double SRExitTime;
+	double SREnterPlusExitTime;
+	double UrgentLatencyPixelDataOnly;
+	double UrgentLatencyPixelMixedWithVMData;
+	double UrgentLatencyVMDataOnly;
+	double UrgentLatency; // max of the above three
+	double WritebackLatency;
+	double PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelDataOnly; // Mode Support
+	double PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyPixelMixedWithVMData; // Mode Support
+	double PercentOfIdealDRAMFabricAndSDPPortBWReceivedAfterUrgLatencyVMDataOnly; // Mode Support
+	double MaxAveragePercentOfIdealSDPPortBWDisplayCanUseInNormalSystemOperation; // Mode Support
+	double MaxAveragePercentOfIdealDRAMBWDisplayCanUseInNormalSystemOperation; // Mode Support
+	double NumberOfChannels;
+	double DRAMChannelWidth;
+	double FabricDatapathToDCNDataReturn;
+	double ReturnBusWidth;
+	double Downspreading;
+	double DISPCLKDPPCLKDSCCLKDownSpreading;
+	double DISPCLKDPPCLKVCOSpeed;
+	double RoundTripPingLatencyCycles;
+	double UrgentOutOfOrderReturnPerChannel;
+	double UrgentOutOfOrderReturnPerChannelPixelDataOnly;
+	double UrgentOutOfOrderReturnPerChannelPixelMixedWithVMData;
+	double UrgentOutOfOrderReturnPerChannelVMDataOnly;
+	unsigned int VMMPageSize;
+	double DRAMClockChangeLatency;
+	double XFCBusTransportTime;
+	bool UseUrgentBurstBandwidth;
+	double XFCXBUFLatencyTolerance;
+
+	//
+	// IP Parameters
+	//
+	unsigned int ROBBufferSizeInKByte;
+	double DETBufferSizeInKByte;
+	double DETBufferSizeInTime;
+	unsigned int DPPOutputBufferPixels;
+	unsigned int OPPOutputBufferLines;
+	unsigned int PixelChunkSizeInKByte;
+	double ReturnBW;
+	bool GPUVMEnable;
+	bool HostVMEnable;
+	unsigned int GPUVMMaxPageTableLevels;
+	unsigned int HostVMMaxPageTableLevels;
+	unsigned int HostVMCachedPageTableLevels;
+	unsigned int OverrideGPUVMPageTableLevels;
+	unsigned int OverrideHostVMPageTableLevels;
+	unsigned int MetaChunkSize;
+	double MinPixelChunkSizeBytes;
+	double MinMetaChunkSizeBytes;
+	unsigned int WritebackChunkSize;
+	bool ODMCapability;
+	unsigned int NumberOfDSC;
+	unsigned int LineBufferSize;
+	unsigned int MaxLineBufferLines;
+	unsigned int WritebackInterfaceLumaBufferSize;
+	unsigned int WritebackInterfaceChromaBufferSize;
+	unsigned int WritebackChromaLineBufferWidth;
+	double MaxDCHUBToPSCLThroughput;
+	double MaxPSCLToLBThroughput;
+	unsigned int PTEBufferSizeInRequestsLuma;
+	unsigned int PTEBufferSizeInRequestsChroma;
+	double DISPCLKRampingMargin;
+	unsigned int MaxInterDCNTileRepeaters;
+	bool XFCSupported;
+	double XFCSlvChunkSize;
+	double XFCFillBWOverhead;
+	double XFCFillConstant;
+	double XFCTSlvVupdateOffset;
+	double XFCTSlvVupdateWidth;
+	double XFCTSlvVreadyOffset;
+	double DPPCLKDelaySubtotal;
+	double DPPCLKDelaySCL;
+	double DPPCLKDelaySCLLBOnly;
+	double DPPCLKDelayCNVCFormater;
+	double DPPCLKDelayCNVCCursor;
+	double DISPCLKDelaySubtotal;
+	bool ProgressiveToInterlaceUnitInOPP;
+	// Pipe/Plane Parameters
+	int VoltageLevel;
+	double FabricClock;
+	double DRAMSpeed;
+	double DISPCLK;
+	double SOCCLK;
+	double DCFCLK;
+
+	unsigned int NumberOfActivePlanes;
+	unsigned int NumberOfDSCSlices[DC__NUM_DPP__MAX];
+	unsigned int ViewportWidth[DC__NUM_DPP__MAX];
+	unsigned int ViewportHeight[DC__NUM_DPP__MAX];
+	unsigned int ViewportYStartY[DC__NUM_DPP__MAX];
+	unsigned int ViewportYStartC[DC__NUM_DPP__MAX];
+	unsigned int PitchY[DC__NUM_DPP__MAX];
+	unsigned int PitchC[DC__NUM_DPP__MAX];
+	double HRatio[DC__NUM_DPP__MAX];
+	double VRatio[DC__NUM_DPP__MAX];
+	unsigned int htaps[DC__NUM_DPP__MAX];
+	unsigned int vtaps[DC__NUM_DPP__MAX];
+	unsigned int HTAPsChroma[DC__NUM_DPP__MAX];
+	unsigned int VTAPsChroma[DC__NUM_DPP__MAX];
+	unsigned int HTotal[DC__NUM_DPP__MAX];
+	unsigned int VTotal[DC__NUM_DPP__MAX];
+	int DPPPerPlane[DC__NUM_DPP__MAX];
+	double PixelClock[DC__NUM_DPP__MAX];
+	double PixelClockBackEnd[DC__NUM_DPP__MAX];
+	bool DCCEnable[DC__NUM_DPP__MAX];
+	unsigned int DCCMetaPitchY[DC__NUM_DPP__MAX];
+	unsigned int DCCMetaPitchC[DC__NUM_DPP__MAX];
+	enum scan_direction_class SourceScan[DC__NUM_DPP__MAX];
+	enum source_format_class SourcePixelFormat[DC__NUM_DPP__MAX];
+	bool WritebackEnable[DC__NUM_DPP__MAX];
+	unsigned int ActiveWritebacksPerPlane[DC__NUM_DPP__MAX];
+	double WritebackDestinationWidth[DC__NUM_DPP__MAX];
+	double WritebackDestinationHeight[DC__NUM_DPP__MAX];
+	double WritebackSourceHeight[DC__NUM_DPP__MAX];
+	enum source_format_class WritebackPixelFormat[DC__NUM_DPP__MAX];
+	unsigned int WritebackLumaHTaps[DC__NUM_DPP__MAX];
+	unsigned int WritebackLumaVTaps[DC__NUM_DPP__MAX];
+	unsigned int WritebackChromaHTaps[DC__NUM_DPP__MAX];
+	unsigned int WritebackChromaVTaps[DC__NUM_DPP__MAX];
+	double WritebackHRatio[DC__NUM_DPP__MAX];
+	double WritebackVRatio[DC__NUM_DPP__MAX];
+	unsigned int HActive[DC__NUM_DPP__MAX];
+	unsigned int VActive[DC__NUM_DPP__MAX];
+	bool Interlace[DC__NUM_DPP__MAX];
+	enum dm_swizzle_mode SurfaceTiling[DC__NUM_DPP__MAX];
+	unsigned int ScalerRecoutWidth[DC__NUM_DPP__MAX];
+	bool DynamicMetadataEnable[DC__NUM_DPP__MAX];
+	int DynamicMetadataLinesBeforeActiveRequired[DC__NUM_DPP__MAX];
+	unsigned int DynamicMetadataTransmittedBytes[DC__NUM_DPP__MAX];
+	double DCCRate[DC__NUM_DPP__MAX];
+	double AverageDCCCompressionRate;
+	bool ODMCombineEnabled[DC__NUM_DPP__MAX];
+	double OutputBpp[DC__NUM_DPP__MAX];
+	bool DSCEnabled[DC__NUM_DPP__MAX];
+	unsigned int DSCInputBitPerComponent[DC__NUM_DPP__MAX];
+	enum output_format_class OutputFormat[DC__NUM_DPP__MAX];
+	enum output_encoder_class Output[DC__NUM_DPP__MAX];
+	unsigned int BlendingAndTiming[DC__NUM_DPP__MAX];
+	bool SynchronizedVBlank;
+	unsigned int NumberOfCursors[DC__NUM_DPP__MAX];
+	unsigned int CursorWidth[DC__NUM_DPP__MAX][DC__NUM_CURSOR__MAX];
+	unsigned int CursorBPP[DC__NUM_DPP__MAX][DC__NUM_CURSOR__MAX];
+	bool XFCEnabled[DC__NUM_DPP__MAX];
+	bool ScalerEnabled[DC__NUM_DPP__MAX];
+
+	// Intermediates/Informational
+	bool ImmediateFlipSupport;
+	double DETBufferSizeY[DC__NUM_DPP__MAX];
+	double DETBufferSizeC[DC__NUM_DPP__MAX];
+	unsigned int SwathHeightY[DC__NUM_DPP__MAX];
+	unsigned int SwathHeightC[DC__NUM_DPP__MAX];
+	unsigned int LBBitPerPixel[DC__NUM_DPP__MAX];
+	double LastPixelOfLineExtraWatermark;
+	double TotalDataReadBandwidth;
+	unsigned int TotalActiveWriteback;
+	unsigned int EffectiveLBLatencyHidingSourceLinesLuma;
+	unsigned int EffectiveLBLatencyHidingSourceLinesChroma;
+	double BandwidthAvailableForImmediateFlip;
+	unsigned int PrefetchMode[DC__VOLTAGE_STATES + 1][2];
+	unsigned int MinPrefetchMode;
+	unsigned int MaxPrefetchMode;
+	bool AnyLinesForVMOrRowTooLarge;
+	double MaxVStartup;
+	bool IgnoreViewportPositioning;
+	bool ErrorResult[DC__NUM_DPP__MAX];
+	//
+	// Calculated dml_ml->vba.Outputs
+	//
+	double DCFCLKDeepSleep;
+	double UrgentWatermark;
+	double UrgentExtraLatency;
+	double WritebackUrgentWatermark;
+	double StutterExitWatermark;
+	double StutterEnterPlusExitWatermark;
+	double DRAMClockChangeWatermark;
+	double WritebackDRAMClockChangeWatermark;
+	double StutterEfficiency;
+	double StutterEfficiencyNotIncludingVBlank;
+	double NonUrgentLatencyTolerance;
+	double MinActiveDRAMClockChangeLatencySupported;
+
+	// These are the clocks calcuated by the library but they are not actually
+	// used explicitly. They are fetched by tests and then possibly used. The
+	// ultimate values to use are the ones specified by the parameters to DML
+	double DISPCLK_calculated;
+	double DPPCLK_calculated[DC__NUM_DPP__MAX];
+
+	unsigned int VUpdateOffsetPix[DC__NUM_DPP__MAX];
+	double VUpdateWidthPix[DC__NUM_DPP__MAX];
+	double VReadyOffsetPix[DC__NUM_DPP__MAX];
+
+	unsigned int TotImmediateFlipBytes;
+	double TCalc;
+
+	display_e2e_pipe_params_st cache_pipes[DC__NUM_DPP__MAX];
+	unsigned int cache_num_pipes;
+	unsigned int pipe_plane[DC__NUM_DPP__MAX];
+
+	/* vba mode support */
+	/*inputs*/
+	bool SupportGFX7CompatibleTilingIn32bppAnd64bpp;
+	double MaxHSCLRatio;
+	double MaxVSCLRatio;
+	unsigned int MaxNumWriteback;
+	bool WritebackLumaAndChromaScalingSupported;
+	bool Cursor64BppSupport;
+	double DCFCLKPerState[DC__VOLTAGE_STATES + 1];
+	double FabricClockPerState[DC__VOLTAGE_STATES + 1];
+	double SOCCLKPerState[DC__VOLTAGE_STATES + 1];
+	double PHYCLKPerState[DC__VOLTAGE_STATES + 1];
+	double MaxDppclk[DC__VOLTAGE_STATES + 1];
+	double MaxDSCCLK[DC__VOLTAGE_STATES + 1];
+	double DRAMSpeedPerState[DC__VOLTAGE_STATES + 1];
+	double MaxDispclk[DC__VOLTAGE_STATES + 1];
+	int VoltageOverrideLevel;
+
+	/*outputs*/
+	bool ScaleRatioAndTapsSupport;
+	bool SourceFormatPixelAndScanSupport;
+	double TotalBandwidthConsumedGBytePerSecond;
+	bool DCCEnabledInAnyPlane;
+	bool WritebackLatencySupport;
+	bool WritebackModeSupport;
+	bool Writeback10bpc420Supported;
+	bool BandwidthSupport[DC__VOLTAGE_STATES + 1];
+	unsigned int TotalNumberOfActiveWriteback;
+	double CriticalPoint;
+	double ReturnBWToDCNPerState;
+	bool IsErrorResult[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	bool prefetch_vm_bw_valid;
+	bool prefetch_row_bw_valid;
+	bool NumberOfOTGSupport;
+	bool NonsupportedDSCInputBPC;
+	bool WritebackScaleRatioAndTapsSupport;
+	bool CursorSupport;
+	bool PitchSupport;
+	enum dm_validation_status ValidationStatus[DC__VOLTAGE_STATES + 1];
+
+	double WritebackLineBufferLumaBufferSize;
+	double WritebackLineBufferChromaBufferSize;
+	double WritebackMinHSCLRatio;
+	double WritebackMinVSCLRatio;
+	double WritebackMaxHSCLRatio;
+	double WritebackMaxVSCLRatio;
+	double WritebackMaxHSCLTaps;
+	double WritebackMaxVSCLTaps;
+	unsigned int MaxNumDPP;
+	unsigned int MaxNumOTG;
+	double CursorBufferSize;
+	double CursorChunkSize;
+	unsigned int Mode;
+	double OutputLinkDPLanes[DC__NUM_DPP__MAX];
+	double ForcedOutputLinkBPP[DC__NUM_DPP__MAX]; // Mode Support only
+	double ImmediateFlipBW[DC__NUM_DPP__MAX];
+	double MaxMaxVStartup;
+
+	double WritebackLumaVExtra;
+	double WritebackChromaVExtra;
+	double WritebackRequiredDISPCLK;
+	double MaximumSwathWidthSupport;
+	double MaximumSwathWidthInDETBuffer;
+	double MaximumSwathWidthInLineBuffer;
+	double MaxDispclkRoundedDownToDFSGranularity;
+	double MaxDppclkRoundedDownToDFSGranularity;
+	double PlaneRequiredDISPCLKWithoutODMCombine;
+	double PlaneRequiredDISPCLKWithODMCombine;
+	double PlaneRequiredDISPCLK;
+	double TotalNumberOfActiveOTG;
+	double FECOverhead;
+	double EffectiveFECOverhead;
+	unsigned int Outbpp;
+	unsigned int OutbppDSC;
+	double TotalDSCUnitsRequired;
+	double bpp;
+	unsigned int slices;
+	double SwathWidthGranularityY;
+	double RoundedUpMaxSwathSizeBytesY;
+	double SwathWidthGranularityC;
+	double RoundedUpMaxSwathSizeBytesC;
+	double EffectiveDETLBLinesLuma;
+	double EffectiveDETLBLinesChroma;
+	double ProjectedDCFCLKDeepSleep;
+	double PDEAndMetaPTEBytesPerFrameY;
+	double PDEAndMetaPTEBytesPerFrameC;
+	unsigned int MetaRowBytesY;
+	unsigned int MetaRowBytesC;
+	unsigned int DPTEBytesPerRowC;
+	unsigned int DPTEBytesPerRowY;
+	double ExtraLatency;
+	double TimeCalc;
+	double TWait;
+	double MaximumReadBandwidthWithPrefetch;
+	double MaximumReadBandwidthWithoutPrefetch;
+	double total_dcn_read_bw_with_flip;
+	double total_dcn_read_bw_with_flip_no_urgent_burst;
+	double FractionOfUrgentBandwidth;
+	double FractionOfUrgentBandwidthImmediateFlip; // Mode Support debugging output
+
+	/* ms locals */
+	double IdealSDPPortBandwidthPerState[DC__VOLTAGE_STATES + 1];
+	unsigned int NoOfDPP[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	int NoOfDPPThisState[DC__NUM_DPP__MAX];
+	bool ODMCombineEnablePerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	unsigned int SwathWidthYThisState[DC__NUM_DPP__MAX];
+	unsigned int SwathHeightCPerState[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	unsigned int SwathHeightYThisState[DC__NUM_DPP__MAX];
+	unsigned int SwathHeightCThisState[DC__NUM_DPP__MAX];
+	double VRatioPreY[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double VRatioPreC[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double RequiredPrefetchPixelDataBWLuma[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double RequiredPrefetchPixelDataBWChroma[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double RequiredDPPCLK[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double RequiredDPPCLKThisState[DC__NUM_DPP__MAX];
+	bool PTEBufferSizeNotExceededY[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	bool PTEBufferSizeNotExceededC[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	bool BandwidthWithoutPrefetchSupported[DC__VOLTAGE_STATES + 1];
+	bool PrefetchSupported[DC__VOLTAGE_STATES + 1][2];
+	bool VRatioInPrefetchSupported[DC__VOLTAGE_STATES + 1][2];
+	double RequiredDISPCLK[DC__VOLTAGE_STATES + 1][2];
+	bool DISPCLK_DPPCLK_Support[DC__VOLTAGE_STATES + 1][2];
+	bool TotalAvailablePipesSupport[DC__VOLTAGE_STATES + 1][2];
+	unsigned int TotalNumberOfActiveDPP[DC__VOLTAGE_STATES + 1][2];
+	unsigned int TotalNumberOfDCCActiveDPP[DC__VOLTAGE_STATES + 1][2];
+	bool ModeSupport[DC__VOLTAGE_STATES + 1][2];
+	double ReturnBWPerState[DC__VOLTAGE_STATES + 1];
+	bool DIOSupport[DC__VOLTAGE_STATES + 1];
+	bool NotEnoughDSCUnits[DC__VOLTAGE_STATES + 1];
+	bool DSCCLKRequiredMoreThanSupported[DC__VOLTAGE_STATES + 1];
+	double UrgentRoundTripAndOutOfOrderLatencyPerState[DC__VOLTAGE_STATES + 1];
+	bool ROBSupport[DC__VOLTAGE_STATES + 1];
+	bool PTEBufferSizeNotExceeded[DC__VOLTAGE_STATES + 1][2];
+	bool TotalVerticalActiveBandwidthSupport[DC__VOLTAGE_STATES + 1];
+	double MaxTotalVerticalActiveAvailableBandwidth[DC__VOLTAGE_STATES + 1];
+	double PrefetchBW[DC__NUM_DPP__MAX];
+	double PDEAndMetaPTEBytesPerFrame[DC__NUM_DPP__MAX];
+	double MetaRowBytes[DC__NUM_DPP__MAX];
+	double DPTEBytesPerRow[DC__NUM_DPP__MAX];
+	double PrefetchLinesY[DC__NUM_DPP__MAX];
+	double PrefetchLinesC[DC__NUM_DPP__MAX];
+	unsigned int MaxNumSwY[DC__NUM_DPP__MAX];
+	unsigned int MaxNumSwC[DC__NUM_DPP__MAX];
+	double PrefillY[DC__NUM_DPP__MAX];
+	double PrefillC[DC__NUM_DPP__MAX];
+	double LineTimesForPrefetch[DC__NUM_DPP__MAX];
+	double LinesForMetaPTE[DC__NUM_DPP__MAX];
+	double LinesForMetaAndDPTERow[DC__NUM_DPP__MAX];
+	double MinDPPCLKUsingSingleDPP[DC__NUM_DPP__MAX];
+	unsigned int SwathWidthYSingleDPP[DC__NUM_DPP__MAX];
+	double BytePerPixelInDETY[DC__NUM_DPP__MAX];
+	double BytePerPixelInDETC[DC__NUM_DPP__MAX];
+	bool RequiresDSC[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	unsigned int NumberOfDSCSlice[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	double RequiresFEC[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	unsigned int OutputBppPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	double DSCDelayPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	bool ViewportSizeSupport[DC__VOLTAGE_STATES + 1];
+	unsigned int Read256BlockHeightY[DC__NUM_DPP__MAX];
+	unsigned int Read256BlockWidthY[DC__NUM_DPP__MAX];
+	unsigned int Read256BlockHeightC[DC__NUM_DPP__MAX];
+	unsigned int Read256BlockWidthC[DC__NUM_DPP__MAX];
+	double MaxSwathHeightY[DC__NUM_DPP__MAX];
+	double MaxSwathHeightC[DC__NUM_DPP__MAX];
+	double MinSwathHeightY[DC__NUM_DPP__MAX];
+	double MinSwathHeightC[DC__NUM_DPP__MAX];
+	double ReadBandwidthLuma[DC__NUM_DPP__MAX];
+	double ReadBandwidthChroma[DC__NUM_DPP__MAX];
+	double ReadBandwidth[DC__NUM_DPP__MAX];
+	double WriteBandwidth[DC__NUM_DPP__MAX];
+	double PSCL_FACTOR[DC__NUM_DPP__MAX];
+	double PSCL_FACTOR_CHROMA[DC__NUM_DPP__MAX];
+	double MaximumVStartup[DC__NUM_DPP__MAX];
+	unsigned int MacroTileWidthY[DC__NUM_DPP__MAX];
+	unsigned int MacroTileWidthC[DC__NUM_DPP__MAX];
+	double AlignedDCCMetaPitch[DC__NUM_DPP__MAX];
+	double AlignedYPitch[DC__NUM_DPP__MAX];
+	double AlignedCPitch[DC__NUM_DPP__MAX];
+	double MaximumSwathWidth[DC__NUM_DPP__MAX];
+	double cursor_bw[DC__NUM_DPP__MAX];
+	double cursor_bw_pre[DC__NUM_DPP__MAX];
+	double Tno_bw[DC__NUM_DPP__MAX];
+	double prefetch_vmrow_bw[DC__NUM_DPP__MAX];
+	double DestinationLinesToRequestVMInImmediateFlip[DC__NUM_DPP__MAX];
+	double DestinationLinesToRequestRowInImmediateFlip[DC__NUM_DPP__MAX];
+	double final_flip_bw[DC__NUM_DPP__MAX];
+	bool ImmediateFlipSupportedForState[DC__VOLTAGE_STATES + 1][2];
+	double WritebackDelay[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	unsigned int vm_group_bytes[DC__NUM_DPP__MAX];
+	long dpte_group_bytes[DC__NUM_DPP__MAX];
+	unsigned int dpte_row_height[DC__NUM_DPP__MAX];
+	unsigned int meta_req_height[DC__NUM_DPP__MAX];
+	unsigned int meta_req_width[DC__NUM_DPP__MAX];
+	unsigned int meta_row_height[DC__NUM_DPP__MAX];
+	unsigned int meta_row_width[DC__NUM_DPP__MAX];
+	unsigned int dpte_row_height_chroma[DC__NUM_DPP__MAX];
+	unsigned int meta_req_height_chroma[DC__NUM_DPP__MAX];
+	unsigned int meta_req_width_chroma[DC__NUM_DPP__MAX];
+	unsigned int meta_row_height_chroma[DC__NUM_DPP__MAX];
+	unsigned int meta_row_width_chroma[DC__NUM_DPP__MAX];
+	bool ImmediateFlipSupportedForPipe[DC__NUM_DPP__MAX];
+	double meta_row_bw[DC__NUM_DPP__MAX];
+	double dpte_row_bw[DC__NUM_DPP__MAX];
+	double DisplayPipeLineDeliveryTimeLuma[DC__NUM_DPP__MAX];                     // WM
+	double DisplayPipeLineDeliveryTimeChroma[DC__NUM_DPP__MAX];                     // WM
+	double DisplayPipeRequestDeliveryTimeLuma[DC__NUM_DPP__MAX];
+	double DisplayPipeRequestDeliveryTimeChroma[DC__NUM_DPP__MAX];
+	enum clock_change_support DRAMClockChangeSupport[DC__VOLTAGE_STATES + 1][2];
+	double UrgentBurstFactorCursor[DC__NUM_DPP__MAX];
+	double UrgentBurstFactorCursorPre[DC__NUM_DPP__MAX];
+	double UrgentBurstFactorLuma[DC__NUM_DPP__MAX];
+	double UrgentBurstFactorLumaPre[DC__NUM_DPP__MAX];
+	double UrgentBurstFactorChroma[DC__NUM_DPP__MAX];
+	double UrgentBurstFactorChromaPre[DC__NUM_DPP__MAX];
+
+	bool           MPCCombine[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double         SwathWidthCSingleDPP[DC__NUM_DPP__MAX];
+	double         MaximumSwathWidthInLineBufferLuma;
+	double         MaximumSwathWidthInLineBufferChroma;
+	double         MaximumSwathWidthLuma[DC__NUM_DPP__MAX];
+	double         MaximumSwathWidthChroma[DC__NUM_DPP__MAX];
+	bool odm_combine_dummy[DC__NUM_DPP__MAX];
+	double         dummy1[DC__NUM_DPP__MAX];
+	double         dummy2[DC__NUM_DPP__MAX];
+	double         dummy3[DC__NUM_DPP__MAX];
+	double         dummy4[DC__NUM_DPP__MAX];
+	double         dummy5;
+	double         dummy6;
+	double         dummy7[DC__NUM_DPP__MAX];
+	double         dummy8[DC__NUM_DPP__MAX];
+	unsigned int        dummyinteger1ms[DC__NUM_DPP__MAX];
+	unsigned int        dummyinteger2ms[DC__NUM_DPP__MAX];
+	unsigned int        dummyinteger3[DC__NUM_DPP__MAX];
+	unsigned int        dummyinteger4;
+	unsigned int        dummyinteger5;
+	unsigned int        dummyinteger6;
+	unsigned int        dummyinteger7;
+	unsigned int        dummyinteger8;
+	unsigned int        dummyinteger9;
+	unsigned int        dummyinteger10;
+	unsigned int        dummyinteger11;
+	unsigned int        dummyinteger12;
+	bool           dummysinglestring;
+	bool           SingleDPPViewportSizeSupportPerPlane[DC__NUM_DPP__MAX];
+	double         PlaneRequiredDISPCLKWithODMCombine2To1;
+	double         PlaneRequiredDISPCLKWithODMCombine4To1;
+	unsigned int   TotalNumberOfSingleDPPPlanes[DC__VOLTAGE_STATES + 1][2];
+	bool           LinkDSCEnable;
+	bool           ODMCombine4To1SupportCheckOK[DC__VOLTAGE_STATES + 1];
+	bool ODMCombineEnableThisState[DC__NUM_DPP__MAX];
+	double         SwathWidthCThisState[DC__NUM_DPP__MAX];
+	bool           ViewportSizeSupportPerPlane[DC__NUM_DPP__MAX];
+	double         AlignedDCCMetaPitchY[DC__NUM_DPP__MAX];
+	double         AlignedDCCMetaPitchC[DC__NUM_DPP__MAX];
+
+	unsigned int NotEnoughUrgentLatencyHiding;
+	unsigned int NotEnoughUrgentLatencyHidingPre;
+	long PTEBufferSizeInRequestsForLuma;
+
+	// Missing from VBA
+	long dpte_group_bytes_chroma;
+	unsigned int vm_group_bytes_chroma;
+	double dst_x_after_scaler;
+	double dst_y_after_scaler;
+	unsigned int VStartupRequiredWhenNotEnoughTimeForDynamicMetadata;
+
+	/* perf locals*/
+	double PrefetchBandwidth[DC__NUM_DPP__MAX];
+	double VInitPreFillY[DC__NUM_DPP__MAX];
+	double VInitPreFillC[DC__NUM_DPP__MAX];
+	unsigned int MaxNumSwathY[DC__NUM_DPP__MAX];
+	unsigned int MaxNumSwathC[DC__NUM_DPP__MAX];
+	unsigned int VStartup[DC__NUM_DPP__MAX];
+	double DSTYAfterScaler[DC__NUM_DPP__MAX];
+	double DSTXAfterScaler[DC__NUM_DPP__MAX];
+	bool AllowDRAMClockChangeDuringVBlank[DC__NUM_DPP__MAX];
+	bool AllowDRAMSelfRefreshDuringVBlank[DC__NUM_DPP__MAX];
+	double VRatioPrefetchY[DC__NUM_DPP__MAX];
+	double VRatioPrefetchC[DC__NUM_DPP__MAX];
+	double DestinationLinesForPrefetch[DC__NUM_DPP__MAX];
+	double DestinationLinesToRequestVMInVBlank[DC__NUM_DPP__MAX];
+	double DestinationLinesToRequestRowInVBlank[DC__NUM_DPP__MAX];
+	double MinTTUVBlank[DC__NUM_DPP__MAX];
+	double BytePerPixelDETY[DC__NUM_DPP__MAX];
+	double BytePerPixelDETC[DC__NUM_DPP__MAX];
+	unsigned int SwathWidthY[DC__NUM_DPP__MAX];
+	unsigned int SwathWidthSingleDPPY[DC__NUM_DPP__MAX];
+	double CursorRequestDeliveryTime[DC__NUM_DPP__MAX];
+	double CursorRequestDeliveryTimePrefetch[DC__NUM_DPP__MAX];
+	double ReadBandwidthPlaneLuma[DC__NUM_DPP__MAX];
+	double ReadBandwidthPlaneChroma[DC__NUM_DPP__MAX];
+	double DisplayPipeLineDeliveryTimeLumaPrefetch[DC__NUM_DPP__MAX];
+	double DisplayPipeLineDeliveryTimeChromaPrefetch[DC__NUM_DPP__MAX];
+	double DisplayPipeRequestDeliveryTimeLumaPrefetch[DC__NUM_DPP__MAX];
+	double DisplayPipeRequestDeliveryTimeChromaPrefetch[DC__NUM_DPP__MAX];
+	double PixelPTEBytesPerRow[DC__NUM_DPP__MAX];
+	double PDEAndMetaPTEBytesFrame[DC__NUM_DPP__MAX];
+	double MetaRowByte[DC__NUM_DPP__MAX];
+	double PrefetchSourceLinesY[DC__NUM_DPP__MAX];
+	double RequiredPrefetchPixDataBWLuma[DC__NUM_DPP__MAX];
+	double RequiredPrefetchPixDataBWChroma[DC__NUM_DPP__MAX];
+	double PrefetchSourceLinesC[DC__NUM_DPP__MAX];
+	double PSCL_THROUGHPUT_LUMA[DC__NUM_DPP__MAX];
+	double PSCL_THROUGHPUT_CHROMA[DC__NUM_DPP__MAX];
+	double DSCCLK_calculated[DC__NUM_DPP__MAX];
+	unsigned int DSCDelay[DC__NUM_DPP__MAX];
+	unsigned int MaxVStartupLines[DC__NUM_DPP__MAX];
+	double DPPCLKUsingSingleDPP[DC__NUM_DPP__MAX];
+	double DPPCLK[DC__NUM_DPP__MAX];
+	unsigned int DCCYMaxUncompressedBlock[DC__NUM_DPP__MAX];
+	unsigned int DCCYMaxCompressedBlock[DC__NUM_DPP__MAX];
+	unsigned int DCCYIndependent64ByteBlock[DC__NUM_DPP__MAX];
+	double MaximumDCCCompressionYSurface[DC__NUM_DPP__MAX];
+	unsigned int BlockHeight256BytesY[DC__NUM_DPP__MAX];
+	unsigned int BlockHeight256BytesC[DC__NUM_DPP__MAX];
+	unsigned int BlockWidth256BytesY[DC__NUM_DPP__MAX];
+	unsigned int BlockWidth256BytesC[DC__NUM_DPP__MAX];
+	double XFCSlaveVUpdateOffset[DC__NUM_DPP__MAX];
+	double XFCSlaveVupdateWidth[DC__NUM_DPP__MAX];
+	double XFCSlaveVReadyOffset[DC__NUM_DPP__MAX];
+	double XFCTransferDelay[DC__NUM_DPP__MAX];
+	double XFCPrechargeDelay[DC__NUM_DPP__MAX];
+	double XFCRemoteSurfaceFlipLatency[DC__NUM_DPP__MAX];
+	double XFCPrefetchMargin[DC__NUM_DPP__MAX];
+	unsigned int dpte_row_width_luma_ub[DC__NUM_DPP__MAX];
+	unsigned int dpte_row_width_chroma_ub[DC__NUM_DPP__MAX];
+	double FullDETBufferingTimeY[DC__NUM_DPP__MAX];                     // WM
+	double FullDETBufferingTimeC[DC__NUM_DPP__MAX];                     // WM
+	double DST_Y_PER_PTE_ROW_NOM_L[DC__NUM_DPP__MAX];
+	double DST_Y_PER_PTE_ROW_NOM_C[DC__NUM_DPP__MAX];
+	double DST_Y_PER_META_ROW_NOM_L[DC__NUM_DPP__MAX];
+	double TimePerMetaChunkNominal[DC__NUM_DPP__MAX];
+	double TimePerMetaChunkVBlank[DC__NUM_DPP__MAX];
+	double TimePerMetaChunkFlip[DC__NUM_DPP__MAX];
+	unsigned int swath_width_luma_ub[DC__NUM_DPP__MAX];
+	unsigned int swath_width_chroma_ub[DC__NUM_DPP__MAX];
+	unsigned int PixelPTEReqWidthY[DC__NUM_DPP__MAX];
+	unsigned int PixelPTEReqHeightY[DC__NUM_DPP__MAX];
+	unsigned int PTERequestSizeY[DC__NUM_DPP__MAX];
+	unsigned int PixelPTEReqWidthC[DC__NUM_DPP__MAX];
+	unsigned int PixelPTEReqHeightC[DC__NUM_DPP__MAX];
+	unsigned int PTERequestSizeC[DC__NUM_DPP__MAX];
+	double time_per_pte_group_nom_luma[DC__NUM_DPP__MAX];
+	double time_per_pte_group_nom_chroma[DC__NUM_DPP__MAX];
+	double time_per_pte_group_vblank_luma[DC__NUM_DPP__MAX];
+	double time_per_pte_group_vblank_chroma[DC__NUM_DPP__MAX];
+	double time_per_pte_group_flip_luma[DC__NUM_DPP__MAX];
+	double time_per_pte_group_flip_chroma[DC__NUM_DPP__MAX];
+	double TimePerVMGroupVBlank[DC__NUM_DPP__MAX];
+	double TimePerVMGroupFlip[DC__NUM_DPP__MAX];
+	double TimePerVMRequestVBlank[DC__NUM_DPP__MAX];
+	double TimePerVMRequestFlip[DC__NUM_DPP__MAX];
+	unsigned int dpde0_bytes_per_frame_ub_l[DC__NUM_DPP__MAX];
+	unsigned int meta_pte_bytes_per_frame_ub_l[DC__NUM_DPP__MAX];
+	unsigned int dpde0_bytes_per_frame_ub_c[DC__NUM_DPP__MAX];
+	unsigned int meta_pte_bytes_per_frame_ub_c[DC__NUM_DPP__MAX];
+	double LinesToFinishSwathTransferStutterCriticalPlane;
+	unsigned int BytePerPixelYCriticalPlane;
+	double SwathWidthYCriticalPlane;
+	double LinesInDETY[DC__NUM_DPP__MAX];
+	double LinesInDETYRoundedDownToSwath[DC__NUM_DPP__MAX];
+
+	unsigned int SwathWidthSingleDPPC[DC__NUM_DPP__MAX];
+	unsigned int SwathWidthC[DC__NUM_DPP__MAX];
+	unsigned int BytePerPixelY[DC__NUM_DPP__MAX];
+	unsigned int BytePerPixelC[DC__NUM_DPP__MAX];
+	long dummyinteger1;
+	long dummyinteger2;
+	double FinalDRAMClockChangeLatency;
+	double Tdmdl_vm[DC__NUM_DPP__MAX];
+	double Tdmdl[DC__NUM_DPP__MAX];
+	unsigned int ThisVStartup;
+	bool WritebackAllowDRAMClockChangeEndPosition[DC__NUM_DPP__MAX];
+	double DST_Y_PER_META_ROW_NOM_C[DC__NUM_DPP__MAX];
+	double TimePerChromaMetaChunkNominal[DC__NUM_DPP__MAX];
+	double TimePerChromaMetaChunkVBlank[DC__NUM_DPP__MAX];
+	double TimePerChromaMetaChunkFlip[DC__NUM_DPP__MAX];
+	unsigned int DCCCMaxUncompressedBlock[DC__NUM_DPP__MAX];
+	unsigned int DCCCMaxCompressedBlock[DC__NUM_DPP__MAX];
+	unsigned int DCCCIndependent64ByteBlock[DC__NUM_DPP__MAX];
+	double VStartupMargin;
+
+	/* Missing from VBA */
+	unsigned int MaximumMaxVStartupLines;
+	double FabricAndDRAMBandwidth;
+	double LinesInDETLuma;
+	double LinesInDETChroma;
+	unsigned int ImmediateFlipBytes[DC__NUM_DPP__MAX];
+	unsigned int LinesInDETC[DC__NUM_DPP__MAX];
+	unsigned int LinesInDETCRoundedDownToSwath[DC__NUM_DPP__MAX];
+	double UrgentLatencySupportUsPerState[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double UrgentLatencySupportUs[DC__NUM_DPP__MAX];
+	double FabricAndDRAMBandwidthPerState[DC__VOLTAGE_STATES + 1];
+	bool UrgentLatencySupport[DC__VOLTAGE_STATES + 1][2];
+	unsigned int SwathWidthYPerState[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	unsigned int SwathHeightYPerState[DC__VOLTAGE_STATES + 1][2][DC__NUM_DPP__MAX];
+	double qual_row_bw[DC__NUM_DPP__MAX];
+	double prefetch_row_bw[DC__NUM_DPP__MAX];
+	double prefetch_vm_bw[DC__NUM_DPP__MAX];
+
+	double PTEGroupSize;
+	unsigned int PDEProcessingBufIn64KBReqs;
+
+	double MaxTotalVActiveRDBandwidth;
+	double MinUrgentLatencySupportUs;
+	double MinFullDETBufferingTime;
+	double AverageReadBandwidthGBytePerSecond;
+	bool   FirstMainPlane;
+
+	unsigned int ViewportWidthChroma[DC__NUM_DPP__MAX];
+	unsigned int ViewportHeightChroma[DC__NUM_DPP__MAX];
+	double HRatioChroma[DC__NUM_DPP__MAX];
+	double VRatioChroma[DC__NUM_DPP__MAX];
+	long WritebackSourceWidth[DC__NUM_DPP__MAX];
+
+	bool ModeIsSupported;
+	bool ODMCombine4To1Supported;
+
+	unsigned int SurfaceHeightY[DC__NUM_DPP__MAX];
+	unsigned int SurfaceHeightC[DC__NUM_DPP__MAX];
+	unsigned int WritebackHTaps[DC__NUM_DPP__MAX];
+	unsigned int WritebackVTaps[DC__NUM_DPP__MAX];
+	bool DSCEnable[DC__NUM_DPP__MAX];
+
+	double DRAMClockChangeLatencyOverride;
+
+	double GPUVMMinPageSize;
+	double HostVMMinPageSize;
+
+	bool   MPCCombineEnable[DC__NUM_DPP__MAX];
+	unsigned int HostVMMaxNonCachedPageTableLevels;
+	bool   DynamicMetadataVMEnabled;
+	double       WritebackInterfaceBufferSize;
+	double       WritebackLineBufferSize;
+
+	double DCCRateLuma[DC__NUM_DPP__MAX];
+	double DCCRateChroma[DC__NUM_DPP__MAX];
+
+	double PHYCLKD18PerState[DC__VOLTAGE_STATES + 1];
+	int MinVoltageLevel;
+	int MaxVoltageLevel;
+
+	bool WritebackSupportInterleaveAndUsingWholeBufferForASingleStream;
+	bool NumberOfHDMIFRLSupport;
+	unsigned int MaxNumHDMIFRLOutputs;
+	int    AudioSampleRate[DC__NUM_DPP__MAX];
+	int    AudioSampleLayout[DC__NUM_DPP__MAX];
+};
+
+bool CalculateMinAndMaxPrefetchMode(
+		enum self_refresh_affinity AllowDRAMSelfRefreshOrDRAMClockChangeInVblank,
+		unsigned int *MinPrefetchMode,
+		unsigned int *MaxPrefetchMode);
+
+double CalculateWriteBackDISPCLK(
+		enum source_format_class WritebackPixelFormat,
+		double PixelClock,
+		double WritebackHRatio,
+		double WritebackVRatio,
+		unsigned int WritebackLumaHTaps,
+		unsigned int WritebackLumaVTaps,
+		unsigned int WritebackChromaHTaps,
+		unsigned int WritebackChromaVTaps,
+		double WritebackDestinationWidth,
+		unsigned int HTotal,
+		unsigned int WritebackChromaLineBufferWidth);
+
+#endif /* _DML2_DISPLAY_MODE_VBA_H_ */

commit a27267e01ffa377e854645548b0bb11a5051c36c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jan 18 09:54:44 2018 -0500

    drm/amd/display: dc: Remove unused display_mode_vba.c
    
    We're currently not using this.
    
    v2: More files and includes to remove.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
deleted file mode 100644
index 4112409cd974..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ /dev/null
@@ -1,598 +0,0 @@
-/*
- * Copyright 2017 Advanced Micro Devices, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: AMD
- *
- */
-
-#ifndef __DML2_DISPLAY_MODE_VBA_H__
-#define __DML2_DISPLAY_MODE_VBA_H__
-
-#include "dml_common_defs.h"
-
-struct display_mode_lib;
-
-void set_prefetch_mode(struct display_mode_lib *mode_lib,
-		bool cstate_en,
-		bool pstate_en,
-		bool ignore_viewport_pos,
-		bool immediate_flip_support);
-
-#define dml_get_attr_decl(attr) double get_##attr(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes)
-
-dml_get_attr_decl(clk_dcf_deepsleep);
-dml_get_attr_decl(wm_urgent);
-dml_get_attr_decl(wm_memory_trip);
-dml_get_attr_decl(wm_writeback_urgent);
-dml_get_attr_decl(wm_stutter_exit);
-dml_get_attr_decl(wm_stutter_enter_exit);
-dml_get_attr_decl(wm_dram_clock_change);
-dml_get_attr_decl(wm_writeback_dram_clock_change);
-dml_get_attr_decl(wm_xfc_underflow);
-dml_get_attr_decl(stutter_efficiency_no_vblank);
-dml_get_attr_decl(stutter_efficiency);
-dml_get_attr_decl(urgent_latency);
-dml_get_attr_decl(urgent_extra_latency);
-dml_get_attr_decl(nonurgent_latency);
-dml_get_attr_decl(dram_clock_change_latency);
-dml_get_attr_decl(dispclk_calculated);
-dml_get_attr_decl(total_data_read_bw);
-dml_get_attr_decl(return_bw);
-dml_get_attr_decl(tcalc);
-
-#define dml_get_pipe_attr_decl(attr) double get_##attr(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe)
-
-dml_get_pipe_attr_decl(dsc_delay);
-dml_get_pipe_attr_decl(dppclk_calculated);
-dml_get_pipe_attr_decl(dscclk_calculated);
-dml_get_pipe_attr_decl(min_ttu_vblank);
-dml_get_pipe_attr_decl(vratio_prefetch_l);
-dml_get_pipe_attr_decl(vratio_prefetch_c);
-dml_get_pipe_attr_decl(dst_x_after_scaler);
-dml_get_pipe_attr_decl(dst_y_after_scaler);
-dml_get_pipe_attr_decl(dst_y_per_vm_vblank);
-dml_get_pipe_attr_decl(dst_y_per_row_vblank);
-dml_get_pipe_attr_decl(dst_y_prefetch);
-dml_get_pipe_attr_decl(dst_y_per_vm_flip);
-dml_get_pipe_attr_decl(dst_y_per_row_flip);
-dml_get_pipe_attr_decl(xfc_transfer_delay);
-dml_get_pipe_attr_decl(xfc_precharge_delay);
-dml_get_pipe_attr_decl(xfc_remote_surface_flip_latency);
-dml_get_pipe_attr_decl(xfc_prefetch_margin);
-
-unsigned int get_vstartup_calculated(
-		struct display_mode_lib *mode_lib,
-		const display_e2e_pipe_params_st *pipes,
-		unsigned int num_pipes,
-		unsigned int which_pipe);
-
-double get_total_immediate_flip_bytes(
-		struct display_mode_lib *mode_lib,
-		const display_e2e_pipe_params_st *pipes,
-		unsigned int num_pipes);
-double get_total_immediate_flip_bw(
-		struct display_mode_lib *mode_lib,
-		const display_e2e_pipe_params_st *pipes,
-		unsigned int num_pipes);
-double get_total_prefetch_bw(
-		struct display_mode_lib *mode_lib,
-		const display_e2e_pipe_params_st *pipes,
-		unsigned int num_pipes);
-
-unsigned int dml_get_voltage_level(
-		struct display_mode_lib *mode_lib,
-		const display_e2e_pipe_params_st *pipes,
-		unsigned int num_pipes);
-
-bool Calculate256BBlockSizes(
-		enum source_format_class SourcePixelFormat,
-		enum dm_swizzle_mode SurfaceTiling,
-		unsigned int BytePerPixelY,
-		unsigned int BytePerPixelC,
-		unsigned int *BlockHeight256BytesY,
-		unsigned int *BlockHeight256BytesC,
-		unsigned int *BlockWidth256BytesY,
-		unsigned int *BlockWidth256BytesC);
-
-
-struct vba_vars_st {
-	ip_params_st	ip;
-	soc_bounding_box_st	soc;
-
-	unsigned int MaximumMaxVStartupLines;
-	double cursor_bw[DC__NUM_DPP__MAX];
-	double meta_row_bw[DC__NUM_DPP__MAX];
-	double dpte_row_bw[DC__NUM_DPP__MAX];
-	double qual_row_bw[DC__NUM_DPP__MAX];
-	double WritebackDISPCLK;
-	double PSCL_THROUGHPUT_LUMA[DC__NUM_DPP__MAX];
-	double PSCL_THROUGHPUT_CHROMA[DC__NUM_DPP__MAX];
-	double DPPCLKUsingSingleDPPLuma;
-	double DPPCLKUsingSingleDPPChroma;
-	double DPPCLKUsingSingleDPP[DC__NUM_DPP__MAX];
-	double DISPCLKWithRamping;
-	double DISPCLKWithoutRamping;
-	double GlobalDPPCLK;
-	double DISPCLKWithRampingRoundedToDFSGranularity;
-	double DISPCLKWithoutRampingRoundedToDFSGranularity;
-	double MaxDispclkRoundedToDFSGranularity;
-	bool DCCEnabledAnyPlane;
-	double ReturnBandwidthToDCN;
-	unsigned int SwathWidthY[DC__NUM_DPP__MAX];
-	unsigned int SwathWidthSingleDPPY[DC__NUM_DPP__MAX];
-	double BytePerPixelDETY[DC__NUM_DPP__MAX];
-	double BytePerPixelDETC[DC__NUM_DPP__MAX];
-	double ReadBandwidthPlaneLuma[DC__NUM_DPP__MAX];
-	double ReadBandwidthPlaneChroma[DC__NUM_DPP__MAX];
-	unsigned int TotalActiveDPP;
-	unsigned int TotalDCCActiveDPP;
-	double UrgentRoundTripAndOutOfOrderLatency;
-	double DisplayPipeLineDeliveryTimeLuma[DC__NUM_DPP__MAX];                     // WM
-	double DisplayPipeLineDeliveryTimeChroma[DC__NUM_DPP__MAX];                     // WM
-	double LinesInDETY[DC__NUM_DPP__MAX];                     // WM
-	double LinesInDETC[DC__NUM_DPP__MAX];                     // WM
-	unsigned int LinesInDETYRoundedDownToSwath[DC__NUM_DPP__MAX];                     // WM
-	unsigned int LinesInDETCRoundedDownToSwath[DC__NUM_DPP__MAX];                     // WM
-	double FullDETBufferingTimeY[DC__NUM_DPP__MAX];                     // WM
-	double FullDETBufferingTimeC[DC__NUM_DPP__MAX];                     // WM
-	double MinFullDETBufferingTime;
-	double FrameTimeForMinFullDETBufferingTime;
-	double AverageReadBandwidthGBytePerSecond;
-	double PartOfBurstThatFitsInROB;
-	double StutterBurstTime;
-	//unsigned int     NextPrefetchMode;
-	double VBlankTime;
-	double SmallestVBlank;
-	double DCFCLKDeepSleepPerPlane;
-	double EffectiveDETPlusLBLinesLuma;
-	double EffectiveDETPlusLBLinesChroma;
-	double UrgentLatencySupportUsLuma;
-	double UrgentLatencySupportUsChroma;
-	double UrgentLatencySupportUs[DC__NUM_DPP__MAX];
-	unsigned int DSCFormatFactor;
-	unsigned int BlockHeight256BytesY[DC__NUM_DPP__MAX];
-	unsigned int BlockHeight256BytesC[DC__NUM_DPP__MAX];
-	unsigned int BlockWidth256BytesY[DC__NUM_DPP__MAX];
-	unsigned int BlockWidth256BytesC[DC__NUM_DPP__MAX];
-	double VInitPreFillY[DC__NUM_DPP__MAX];
-	double VInitPreFillC[DC__NUM_DPP__MAX];
-	unsigned int MaxNumSwathY[DC__NUM_DPP__MAX];
-	unsigned int MaxNumSwathC[DC__NUM_DPP__MAX];
-	double PrefetchSourceLinesY[DC__NUM_DPP__MAX];
-	double PrefetchSourceLinesC[DC__NUM_DPP__MAX];
-	double PixelPTEBytesPerRow[DC__NUM_DPP__MAX];
-	double MetaRowByte[DC__NUM_DPP__MAX];
-	unsigned int dpte_row_height[DC__NUM_DPP__MAX];
-	unsigned int dpte_row_height_chroma[DC__NUM_DPP__MAX];
-	unsigned int meta_row_height[DC__NUM_DPP__MAX];
-	unsigned int meta_row_height_chroma[DC__NUM_DPP__MAX];
-
-	unsigned int MacroTileWidthY[DC__NUM_DPP__MAX];
-	unsigned int MacroTileWidthC[DC__NUM_DPP__MAX];
-	unsigned int MaxVStartupLines[DC__NUM_DPP__MAX];
-	double WritebackDelay[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	bool PrefetchModeSupported;
-	bool AllowDRAMClockChangeDuringVBlank[DC__NUM_DPP__MAX];
-	bool AllowDRAMSelfRefreshDuringVBlank[DC__NUM_DPP__MAX];
-	double RequiredPrefetchPixDataBW[DC__NUM_DPP__MAX];
-	double XFCRemoteSurfaceFlipDelay;
-	double TInitXFill;
-	double TslvChk;
-	double SrcActiveDrainRate;
-	double Tno_bw[DC__NUM_DPP__MAX];
-	bool ImmediateFlipSupported;
-
-	double prefetch_vm_bw[DC__NUM_DPP__MAX];
-	double prefetch_row_bw[DC__NUM_DPP__MAX];
-	bool ImmediateFlipSupportedForPipe[DC__NUM_DPP__MAX];
-	unsigned int VStartupLines;
-	double DisplayPipeLineDeliveryTimeLumaPrefetch[DC__NUM_DPP__MAX];
-	double DisplayPipeLineDeliveryTimeChromaPrefetch[DC__NUM_DPP__MAX];
-	unsigned int ActiveDPPs;
-	unsigned int LBLatencyHidingSourceLinesY;
-	unsigned int LBLatencyHidingSourceLinesC;
-	double ActiveDRAMClockChangeLatencyMargin[DC__NUM_DPP__MAX];
-	double MinActiveDRAMClockChangeMargin;
-	double XFCSlaveVUpdateOffset[DC__NUM_DPP__MAX];
-	double XFCSlaveVupdateWidth[DC__NUM_DPP__MAX];
-	double XFCSlaveVReadyOffset[DC__NUM_DPP__MAX];
-	double InitFillLevel;
-	double FinalFillMargin;
-	double FinalFillLevel;
-	double RemainingFillLevel;
-	double TFinalxFill;
-
-
-	//
-	// SOC Bounding Box Parameters
-	//
-	double SRExitTime;
-	double SREnterPlusExitTime;
-	double UrgentLatency;
-	double WritebackLatency;
-	double PercentOfIdealDRAMAndFabricBWReceivedAfterUrgLatency;
-	double NumberOfChannels;
-	double DRAMChannelWidth;
-	double FabricDatapathToDCNDataReturn;
-	double ReturnBusWidth;
-	double Downspreading;
-	double DISPCLKDPPCLKDSCCLKDownSpreading;
-	double DISPCLKDPPCLKVCOSpeed;
-	double RoundTripPingLatencyCycles;
-	double UrgentOutOfOrderReturnPerChannel;
-	unsigned int VMMPageSize;
-	double DRAMClockChangeLatency;
-	double XFCBusTransportTime;
-	double XFCXBUFLatencyTolerance;
-
-	//
-	// IP Parameters
-	//
-	unsigned int ROBBufferSizeInKByte;
-	double DETBufferSizeInKByte;
-	unsigned int DPPOutputBufferPixels;
-	unsigned int OPPOutputBufferLines;
-	unsigned int PixelChunkSizeInKByte;
-	double ReturnBW;
-	bool VirtualMemoryEnable;
-	unsigned int MaxPageTableLevels;
-	unsigned int OverridePageTableLevels;
-	unsigned int PTEChunkSize;
-	unsigned int MetaChunkSize;
-	unsigned int WritebackChunkSize;
-	bool ODMCapability;
-	unsigned int NumberOfDSC;
-	unsigned int LineBufferSize;
-	unsigned int MaxLineBufferLines;
-	unsigned int WritebackInterfaceLumaBufferSize;
-	unsigned int WritebackInterfaceChromaBufferSize;
-	unsigned int WritebackChromaLineBufferWidth;
-	double MaxDCHUBToPSCLThroughput;
-	double MaxPSCLToLBThroughput;
-	unsigned int PTEBufferSizeInRequests;
-	double DISPCLKRampingMargin;
-	unsigned int MaxInterDCNTileRepeaters;
-	bool XFCSupported;
-	double XFCSlvChunkSize;
-	double XFCFillBWOverhead;
-	double XFCFillConstant;
-	double XFCTSlvVupdateOffset;
-	double XFCTSlvVupdateWidth;
-	double XFCTSlvVreadyOffset;
-	double DPPCLKDelaySubtotal;
-	double DPPCLKDelaySCL;
-	double DPPCLKDelaySCLLBOnly;
-	double DPPCLKDelayCNVCFormater;
-	double DPPCLKDelayCNVCCursor;
-	double DISPCLKDelaySubtotal;
-	bool ProgressiveToInterlaceUnitInOPP;
-	unsigned int PDEProcessingBufIn64KBReqs;
-
-	// Pipe/Plane Parameters
-	int VoltageLevel;
-	double FabricAndDRAMBandwidth;
-	double FabricClock;
-	double DRAMSpeed;
-	double DISPCLK;
-	double SOCCLK;
-	double DCFCLK;
-
-	unsigned int NumberOfActivePlanes;
-	unsigned int ViewportWidth[DC__NUM_DPP__MAX];
-	unsigned int ViewportHeight[DC__NUM_DPP__MAX];
-	unsigned int ViewportYStartY[DC__NUM_DPP__MAX];
-	unsigned int ViewportYStartC[DC__NUM_DPP__MAX];
-	unsigned int PitchY[DC__NUM_DPP__MAX];
-	unsigned int PitchC[DC__NUM_DPP__MAX];
-	double HRatio[DC__NUM_DPP__MAX];
-	double VRatio[DC__NUM_DPP__MAX];
-	unsigned int htaps[DC__NUM_DPP__MAX];
-	unsigned int vtaps[DC__NUM_DPP__MAX];
-	unsigned int HTAPsChroma[DC__NUM_DPP__MAX];
-	unsigned int VTAPsChroma[DC__NUM_DPP__MAX];
-	unsigned int HTotal[DC__NUM_DPP__MAX];
-	unsigned int VTotal[DC__NUM_DPP__MAX];
-	unsigned int DPPPerPlane[DC__NUM_DPP__MAX];
-	double PixelClock[DC__NUM_DPP__MAX];
-	double PixelClockBackEnd[DC__NUM_DPP__MAX];
-	double DPPCLK[DC__NUM_DPP__MAX];
-	bool DCCEnable[DC__NUM_DPP__MAX];
-	unsigned int DCCMetaPitchY[DC__NUM_DPP__MAX];
-	enum scan_direction_class SourceScan[DC__NUM_DPP__MAX];
-	enum source_format_class SourcePixelFormat[DC__NUM_DPP__MAX];
-	bool WritebackEnable[DC__NUM_DPP__MAX];
-	double WritebackDestinationWidth[DC__NUM_DPP__MAX];
-	double WritebackDestinationHeight[DC__NUM_DPP__MAX];
-	double WritebackSourceHeight[DC__NUM_DPP__MAX];
-	enum source_format_class WritebackPixelFormat[DC__NUM_DPP__MAX];
-	unsigned int WritebackLumaHTaps[DC__NUM_DPP__MAX];
-	unsigned int WritebackLumaVTaps[DC__NUM_DPP__MAX];
-	unsigned int WritebackChromaHTaps[DC__NUM_DPP__MAX];
-	unsigned int WritebackChromaVTaps[DC__NUM_DPP__MAX];
-	double WritebackHRatio[DC__NUM_DPP__MAX];
-	double WritebackVRatio[DC__NUM_DPP__MAX];
-	unsigned int HActive[DC__NUM_DPP__MAX];
-	unsigned int VActive[DC__NUM_DPP__MAX];
-	bool Interlace[DC__NUM_DPP__MAX];
-	enum dm_swizzle_mode SurfaceTiling[DC__NUM_DPP__MAX];
-	unsigned int ScalerRecoutWidth[DC__NUM_DPP__MAX];
-	bool DynamicMetadataEnable[DC__NUM_DPP__MAX];
-	unsigned int DynamicMetadataLinesBeforeActiveRequired[DC__NUM_DPP__MAX];
-	unsigned int DynamicMetadataTransmittedBytes[DC__NUM_DPP__MAX];
-	double DCCRate[DC__NUM_DPP__MAX];
-	bool ODMCombineEnabled[DC__NUM_DPP__MAX];
-	double OutputBpp[DC__NUM_DPP__MAX];
-	unsigned int NumberOfDSCSlices[DC__NUM_DPP__MAX];
-	bool DSCEnabled[DC__NUM_DPP__MAX];
-	unsigned int DSCDelay[DC__NUM_DPP__MAX];
-	unsigned int DSCInputBitPerComponent[DC__NUM_DPP__MAX];
-	enum output_format_class OutputFormat[DC__NUM_DPP__MAX];
-	enum output_encoder_class Output[DC__NUM_DPP__MAX];
-	unsigned int BlendingAndTiming[DC__NUM_DPP__MAX];
-	bool SynchronizedVBlank;
-	unsigned int NumberOfCursors[DC__NUM_DPP__MAX];
-	unsigned int CursorWidth[DC__NUM_DPP__MAX][DC__NUM_CURSOR__MAX];
-	unsigned int CursorBPP[DC__NUM_DPP__MAX][DC__NUM_CURSOR__MAX];
-	bool XFCEnabled[DC__NUM_DPP__MAX];
-	bool ScalerEnabled[DC__NUM_DPP__MAX];
-
-	// Intermediates/Informational
-	bool ImmediateFlipSupport;
-	unsigned int SwathHeightY[DC__NUM_DPP__MAX];
-	unsigned int SwathHeightC[DC__NUM_DPP__MAX];
-	unsigned int DETBufferSizeY[DC__NUM_DPP__MAX];
-	unsigned int DETBufferSizeC[DC__NUM_DPP__MAX];
-	unsigned int LBBitPerPixel[DC__NUM_DPP__MAX];
-	double LastPixelOfLineExtraWatermark;
-	double TotalDataReadBandwidth;
-	unsigned int TotalActiveWriteback;
-	unsigned int EffectiveLBLatencyHidingSourceLinesLuma;
-	unsigned int EffectiveLBLatencyHidingSourceLinesChroma;
-	double BandwidthAvailableForImmediateFlip;
-	unsigned int PrefetchMode;
-	bool IgnoreViewportPositioning;
-	double PrefetchBandwidth[DC__NUM_DPP__MAX];
-	bool ErrorResult[DC__NUM_DPP__MAX];
-	double PDEAndMetaPTEBytesFrame[DC__NUM_DPP__MAX];
-
-	//
-	// Calculated dml_ml->vba.Outputs
-	//
-	double DCFClkDeepSleep;
-	double UrgentWatermark;
-	double UrgentExtraLatency;
-	double MemoryTripWatermark;
-	double WritebackUrgentWatermark;
-	double StutterExitWatermark;
-	double StutterEnterPlusExitWatermark;
-	double DRAMClockChangeWatermark;
-	double WritebackDRAMClockChangeWatermark;
-	double StutterEfficiency;
-	double StutterEfficiencyNotIncludingVBlank;
-	double MinUrgentLatencySupportUs;
-	double NonUrgentLatencyTolerance;
-	double MinActiveDRAMClockChangeLatencySupported;
-	enum clock_change_support DRAMClockChangeSupport;
-
-	// These are the clocks calcuated by the library but they are not actually
-	// used explicitly. They are fetched by tests and then possibly used. The
-	// ultimate values to use are the ones specified by the parameters to DML
-	double DISPCLK_calculated;
-	double DSCCLK_calculated[DC__NUM_DPP__MAX];
-	double DPPCLK_calculated[DC__NUM_DPP__MAX];
-
-	unsigned int VStartup[DC__NUM_DPP__MAX];
-	unsigned int VUpdateOffsetPix[DC__NUM_DPP__MAX];
-	unsigned int VUpdateWidthPix[DC__NUM_DPP__MAX];
-	unsigned int VReadyOffsetPix[DC__NUM_DPP__MAX];
-	unsigned int VStartupRequiredWhenNotEnoughTimeForDynamicMetadata;
-
-	double ImmediateFlipBW;
-	unsigned int TotImmediateFlipBytes;
-	double TCalc;
-	double MinTTUVBlank[DC__NUM_DPP__MAX];
-	double VRatioPrefetchY[DC__NUM_DPP__MAX];
-	double VRatioPrefetchC[DC__NUM_DPP__MAX];
-	double DSTXAfterScaler[DC__NUM_DPP__MAX];
-	double DSTYAfterScaler[DC__NUM_DPP__MAX];
-
-	double DestinationLinesToRequestVMInVBlank[DC__NUM_DPP__MAX];
-	double DestinationLinesToRequestRowInVBlank[DC__NUM_DPP__MAX];
-	double DestinationLinesForPrefetch[DC__NUM_DPP__MAX];
-	double DestinationLinesToRequestRowInImmediateFlip[DC__NUM_DPP__MAX];
-	double DestinationLinesToRequestVMInImmediateFlip[DC__NUM_DPP__MAX];
-
-	double XFCTransferDelay[DC__NUM_DPP__MAX];
-	double XFCPrechargeDelay[DC__NUM_DPP__MAX];
-	double XFCRemoteSurfaceFlipLatency[DC__NUM_DPP__MAX];
-	double XFCPrefetchMargin[DC__NUM_DPP__MAX];
-
-	display_e2e_pipe_params_st cache_pipes[DC__NUM_DPP__MAX];
-	unsigned int cache_num_pipes;
-	unsigned int pipe_plane[DC__NUM_DPP__MAX];
-
-	/* vba mode support */
-	/*inputs*/
-	bool SupportGFX7CompatibleTilingIn32bppAnd64bpp;
-	double MaxHSCLRatio;
-	double MaxVSCLRatio;
-	unsigned int  MaxNumWriteback;
-	bool WritebackLumaAndChromaScalingSupported;
-	bool Cursor64BppSupport;
-	double DCFCLKPerState[DC__VOLTAGE_STATES + 1];
-	double FabricClockPerState[DC__VOLTAGE_STATES + 1];
-	double SOCCLKPerState[DC__VOLTAGE_STATES + 1];
-	double PHYCLKPerState[DC__VOLTAGE_STATES + 1];
-	double MaxDppclk[DC__VOLTAGE_STATES + 1];
-	double MaxDSCCLK[DC__VOLTAGE_STATES + 1];
-	double DRAMSpeedPerState[DC__VOLTAGE_STATES + 1];
-	double MaxDispclk[DC__VOLTAGE_STATES + 1];
-
-	/*outputs*/
-	bool ScaleRatioAndTapsSupport;
-	bool SourceFormatPixelAndScanSupport;
-	unsigned int SwathWidthYSingleDPP[DC__NUM_DPP__MAX];
-	double BytePerPixelInDETY[DC__NUM_DPP__MAX];
-	double BytePerPixelInDETC[DC__NUM_DPP__MAX];
-	double TotalReadBandwidthConsumedGBytePerSecond;
-	double ReadBandwidth[DC__NUM_DPP__MAX];
-	double TotalWriteBandwidthConsumedGBytePerSecond;
-	double WriteBandwidth[DC__NUM_DPP__MAX];
-	double TotalBandwidthConsumedGBytePerSecond;
-	bool DCCEnabledInAnyPlane;
-	bool WritebackLatencySupport;
-	bool WritebackModeSupport;
-	bool Writeback10bpc420Supported;
-	bool BandwidthSupport[DC__VOLTAGE_STATES + 1];
-	unsigned int TotalNumberOfActiveWriteback;
-	double CriticalPoint;
-	double ReturnBWToDCNPerState;
-	double FabricAndDRAMBandwidthPerState[DC__VOLTAGE_STATES + 1];
-	double ReturnBWPerState[DC__VOLTAGE_STATES + 1];
-	double UrgentRoundTripAndOutOfOrderLatencyPerState[DC__VOLTAGE_STATES + 1];
-	bool ODMCombineEnablePerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	bool PTEBufferSizeNotExceededY[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	bool PTEBufferSizeNotExceededC[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	bool PrefetchSupported[DC__VOLTAGE_STATES + 1];
-	bool VRatioInPrefetchSupported[DC__VOLTAGE_STATES + 1];
-	bool DISPCLK_DPPCLK_Support[DC__VOLTAGE_STATES + 1];
-	bool TotalAvailablePipesSupport[DC__VOLTAGE_STATES + 1];
-	bool UrgentLatencySupport[DC__VOLTAGE_STATES + 1];
-	bool ModeSupport[DC__VOLTAGE_STATES + 1];
-	bool DIOSupport[DC__VOLTAGE_STATES + 1];
-	bool NotEnoughDSCUnits[DC__VOLTAGE_STATES + 1];
-	bool DSCCLKRequiredMoreThanSupported[DC__VOLTAGE_STATES + 1];
-	bool ROBSupport[DC__VOLTAGE_STATES + 1];
-	bool PTEBufferSizeNotExceeded[DC__VOLTAGE_STATES + 1];
-	bool RequiresDSC[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	bool IsErrorResult[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	bool ViewportSizeSupport[DC__VOLTAGE_STATES + 1];
-	bool prefetch_vm_bw_valid;
-	bool prefetch_row_bw_valid;
-	bool NumberOfOTGSupport;
-	bool NonsupportedDSCInputBPC;
-	bool WritebackScaleRatioAndTapsSupport;
-	bool CursorSupport;
-	bool PitchSupport;
-
-	double WritebackLineBufferLumaBufferSize;
-	double WritebackLineBufferChromaBufferSize;
-	double WritebackMinHSCLRatio;
-	double WritebackMinVSCLRatio;
-	double WritebackMaxHSCLRatio;
-	double WritebackMaxVSCLRatio;
-	double WritebackMaxHSCLTaps;
-	double WritebackMaxVSCLTaps;
-	unsigned int MaxNumDPP;
-	unsigned int MaxNumOTG;
-	double CursorBufferSize;
-	double CursorChunkSize;
-	unsigned int Mode;
-	unsigned int NoOfDPP[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	double OutputLinkDPLanes[DC__NUM_DPP__MAX];
-	double SwathWidthYPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	double SwathHeightYPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	double SwathHeightCPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	double UrgentLatencySupportUsPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	double VRatioPreY[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	double VRatioPreC[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	double RequiredPrefetchPixelDataBW[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	double RequiredDPPCLK[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	double RequiredDISPCLK[DC__VOLTAGE_STATES + 1];
-	double TotalNumberOfActiveDPP[DC__VOLTAGE_STATES + 1];
-	double TotalNumberOfDCCActiveDPP[DC__VOLTAGE_STATES + 1];
-	double PrefetchBW[DC__NUM_DPP__MAX];
-	double PDEAndMetaPTEBytesPerFrame[DC__NUM_DPP__MAX];
-	double MetaRowBytes[DC__NUM_DPP__MAX];
-	double DPTEBytesPerRow[DC__NUM_DPP__MAX];
-	double PrefetchLinesY[DC__NUM_DPP__MAX];
-	double PrefetchLinesC[DC__NUM_DPP__MAX];
-	unsigned int MaxNumSwY[DC__NUM_DPP__MAX];
-	unsigned int MaxNumSwC[DC__NUM_DPP__MAX];
-	double PrefillY[DC__NUM_DPP__MAX];
-	double PrefillC[DC__NUM_DPP__MAX];
-	double LineTimesForPrefetch[DC__NUM_DPP__MAX];
-	double LinesForMetaPTE[DC__NUM_DPP__MAX];
-	double LinesForMetaAndDPTERow[DC__NUM_DPP__MAX];
-	double MinDPPCLKUsingSingleDPP[DC__NUM_DPP__MAX];
-	double RequiresFEC[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	unsigned int OutputBppPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	double DSCDelayPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
-	unsigned int Read256BlockHeightY[DC__NUM_DPP__MAX];
-	unsigned int Read256BlockWidthY[DC__NUM_DPP__MAX];
-	unsigned int Read256BlockHeightC[DC__NUM_DPP__MAX];
-	unsigned int Read256BlockWidthC[DC__NUM_DPP__MAX];
-	unsigned int ImmediateFlipBytes[DC__NUM_DPP__MAX];
-	double MaxSwathHeightY[DC__NUM_DPP__MAX];
-	double MaxSwathHeightC[DC__NUM_DPP__MAX];
-	double MinSwathHeightY[DC__NUM_DPP__MAX];
-	double MinSwathHeightC[DC__NUM_DPP__MAX];
-	double PSCL_FACTOR[DC__NUM_DPP__MAX];
-	double PSCL_FACTOR_CHROMA[DC__NUM_DPP__MAX];
-	double MaximumVStartup[DC__NUM_DPP__MAX];
-	double AlignedDCCMetaPitch[DC__NUM_DPP__MAX];
-	double AlignedYPitch[DC__NUM_DPP__MAX];
-	double AlignedCPitch[DC__NUM_DPP__MAX];
-	double MaximumSwathWidth[DC__NUM_DPP__MAX];
-	double final_flip_bw[DC__NUM_DPP__MAX];
-	double ImmediateFlipSupportedForState[DC__VOLTAGE_STATES + 1];
-
-	double WritebackLumaVExtra;
-	double WritebackChromaVExtra;
-	double WritebackRequiredDISPCLK;
-	double MaximumSwathWidthSupport;
-	double MaximumSwathWidthInDETBuffer;
-	double MaximumSwathWidthInLineBuffer;
-	double MaxDispclkRoundedDownToDFSGranularity;
-	double MaxDppclkRoundedDownToDFSGranularity;
-	double PlaneRequiredDISPCLKWithoutODMCombine;
-	double PlaneRequiredDISPCLK;
-	double TotalNumberOfActiveOTG;
-	double FECOverhead;
-	double EffectiveFECOverhead;
-	unsigned int Outbpp;
-	unsigned int OutbppDSC;
-	double TotalDSCUnitsRequired;
-	double bpp;
-	unsigned int slices;
-	double SwathWidthGranularityY;
-	double RoundedUpMaxSwathSizeBytesY;
-	double SwathWidthGranularityC;
-	double RoundedUpMaxSwathSizeBytesC;
-	double LinesInDETLuma;
-	double LinesInDETChroma;
-	double EffectiveDETLBLinesLuma;
-	double EffectiveDETLBLinesChroma;
-	double ProjectedDCFCLKDeepSleep;
-	double PDEAndMetaPTEBytesPerFrameY;
-	double PDEAndMetaPTEBytesPerFrameC;
-	unsigned int MetaRowBytesY;
-	unsigned int MetaRowBytesC;
-	unsigned int DPTEBytesPerRowC;
-	unsigned int DPTEBytesPerRowY;
-	double ExtraLatency;
-	double TimeCalc;
-	double TWait;
-	double MaximumReadBandwidthWithPrefetch;
-	double total_dcn_read_bw_with_flip;
-};
-
-#endif /* _DML2_DISPLAY_MODE_VBA_H_ */

commit c6ca4496177d89e3f6eef7d7b6200798b19250ee
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Oct 16 22:58:18 2017 -0400

    drm/amd/display: Add bunch of missing license headers in DML
    
    All files should have MIT headers.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index c8d1a0539541..4112409cd974 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -1,8 +1,26 @@
 /*
- * display_mode_vba.h
+ * Copyright 2017 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
  *
- *  Created on: Aug 18, 2017
- *      Author: dlaktyus
  */
 
 #ifndef __DML2_DISPLAY_MODE_VBA_H__

commit 3eea71e36fcd04d0a3e735ee3cf4dbbe9934e3c8
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Oct 12 22:45:25 2017 -0400

    drm/amd/display: Minor update to DML
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index 4b8c1b911f17..c8d1a0539541 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -98,7 +98,6 @@ bool Calculate256BBlockSizes(
 struct vba_vars_st {
 	ip_params_st	ip;
 	soc_bounding_box_st	soc;
-	mode_evaluation_st me;
 
 	unsigned int MaximumMaxVStartupLines;
 	double cursor_bw[DC__NUM_DPP__MAX];

commit f63d89066fb29a47ad3e9530214de7ea87e82e57
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Oct 13 12:53:38 2017 -0400

    drm/amd/display: change dml numdpp var to uint
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index 63ad4a7bfeb5..4b8c1b911f17 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -489,7 +489,7 @@ struct vba_vars_st {
 	double CursorBufferSize;
 	double CursorChunkSize;
 	unsigned int Mode;
-	double NoOfDPP[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	unsigned int NoOfDPP[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
 	double OutputLinkDPLanes[DC__NUM_DPP__MAX];
 	double SwathWidthYPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
 	double SwathHeightYPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];

commit 09f2317be4e86a60b481ce14da84c0752f848235
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Sep 20 18:32:51 2017 -0400

    drm/amd/display: change dml vba cursor count define to correct one
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index 5758c3fd39ba..63ad4a7bfeb5 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -332,8 +332,8 @@ struct vba_vars_st {
 	unsigned int BlendingAndTiming[DC__NUM_DPP__MAX];
 	bool SynchronizedVBlank;
 	unsigned int NumberOfCursors[DC__NUM_DPP__MAX];
-	unsigned int CursorWidth[DC__NUM_DPP__MAX][DC__NUM_CURSOR];
-	unsigned int CursorBPP[DC__NUM_DPP__MAX][DC__NUM_CURSOR];
+	unsigned int CursorWidth[DC__NUM_DPP__MAX][DC__NUM_CURSOR__MAX];
+	unsigned int CursorBPP[DC__NUM_DPP__MAX][DC__NUM_CURSOR__MAX];
 	bool XFCEnabled[DC__NUM_DPP__MAX];
 	bool ScalerEnabled[DC__NUM_DPP__MAX];
 

commit c81a351ab9c054e28544f31f715ad50cfe54089d
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Sep 20 17:50:02 2017 -0400

    drm/amd/display: extract global sync params from vba
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index 346ffea843c9..5758c3fd39ba 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -383,6 +383,9 @@ struct vba_vars_st {
 	double DPPCLK_calculated[DC__NUM_DPP__MAX];
 
 	unsigned int VStartup[DC__NUM_DPP__MAX];
+	unsigned int VUpdateOffsetPix[DC__NUM_DPP__MAX];
+	unsigned int VUpdateWidthPix[DC__NUM_DPP__MAX];
+	unsigned int VReadyOffsetPix[DC__NUM_DPP__MAX];
 	unsigned int VStartupRequiredWhenNotEnoughTimeForDynamicMetadata;
 
 	double ImmediateFlipBW;

commit cb94f78e3665ef23aabfe547962748d49471cf45
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Sep 15 16:03:09 2017 -0400

    drm/amd/display: add mode support check to dml vba code
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
index a24fe9a0383d..346ffea843c9 100644
--- a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -79,6 +79,11 @@ double get_total_prefetch_bw(
 		const display_e2e_pipe_params_st *pipes,
 		unsigned int num_pipes);
 
+unsigned int dml_get_voltage_level(
+		struct display_mode_lib *mode_lib,
+		const display_e2e_pipe_params_st *pipes,
+		unsigned int num_pipes);
+
 bool Calculate256BBlockSizes(
 		enum source_format_class SourcePixelFormat,
 		enum dm_swizzle_mode SurfaceTiling,
@@ -96,42 +101,41 @@ struct vba_vars_st {
 	mode_evaluation_st me;
 
 	unsigned int MaximumMaxVStartupLines;
-	double cursor_bw[DC__NUM_PIPES__MAX];
-	double meta_row_bw[DC__NUM_PIPES__MAX];
-	double dpte_row_bw[DC__NUM_PIPES__MAX];
-	double qual_row_bw[DC__NUM_PIPES__MAX];
+	double cursor_bw[DC__NUM_DPP__MAX];
+	double meta_row_bw[DC__NUM_DPP__MAX];
+	double dpte_row_bw[DC__NUM_DPP__MAX];
+	double qual_row_bw[DC__NUM_DPP__MAX];
 	double WritebackDISPCLK;
-	double PSCL_THROUGHPUT_LUMA[DC__NUM_PIPES__MAX];
-	double PSCL_THROUGHPUT_CHROMA[DC__NUM_PIPES__MAX];
+	double PSCL_THROUGHPUT_LUMA[DC__NUM_DPP__MAX];
+	double PSCL_THROUGHPUT_CHROMA[DC__NUM_DPP__MAX];
 	double DPPCLKUsingSingleDPPLuma;
 	double DPPCLKUsingSingleDPPChroma;
-	double DPPCLKUsingSingleDPP[DC__NUM_PIPES__MAX];
+	double DPPCLKUsingSingleDPP[DC__NUM_DPP__MAX];
 	double DISPCLKWithRamping;
 	double DISPCLKWithoutRamping;
 	double GlobalDPPCLK;
-	double MaxDispclk;
 	double DISPCLKWithRampingRoundedToDFSGranularity;
 	double DISPCLKWithoutRampingRoundedToDFSGranularity;
 	double MaxDispclkRoundedToDFSGranularity;
 	bool DCCEnabledAnyPlane;
 	double ReturnBandwidthToDCN;
-	unsigned int SwathWidthY[DC__NUM_PIPES__MAX];
-	unsigned int SwathWidthSingleDPPY[DC__NUM_PIPES__MAX];
-	double BytePerPixelDETY[DC__NUM_PIPES__MAX];
-	double BytePerPixelDETC[DC__NUM_PIPES__MAX];
-	double ReadBandwidthPlaneLuma[DC__NUM_PIPES__MAX];
-	double ReadBandwidthPlaneChroma[DC__NUM_PIPES__MAX];
+	unsigned int SwathWidthY[DC__NUM_DPP__MAX];
+	unsigned int SwathWidthSingleDPPY[DC__NUM_DPP__MAX];
+	double BytePerPixelDETY[DC__NUM_DPP__MAX];
+	double BytePerPixelDETC[DC__NUM_DPP__MAX];
+	double ReadBandwidthPlaneLuma[DC__NUM_DPP__MAX];
+	double ReadBandwidthPlaneChroma[DC__NUM_DPP__MAX];
 	unsigned int TotalActiveDPP;
 	unsigned int TotalDCCActiveDPP;
 	double UrgentRoundTripAndOutOfOrderLatency;
-	double DisplayPipeLineDeliveryTimeLuma[DC__NUM_PIPES__MAX];                     // WM
-	double DisplayPipeLineDeliveryTimeChroma[DC__NUM_PIPES__MAX];                     // WM
-	double LinesInDETY[DC__NUM_PIPES__MAX];                     // WM
-	double LinesInDETC[DC__NUM_PIPES__MAX];                     // WM
-	unsigned int LinesInDETYRoundedDownToSwath[DC__NUM_PIPES__MAX];                     // WM
-	unsigned int LinesInDETCRoundedDownToSwath[DC__NUM_PIPES__MAX];                     // WM
-	double FullDETBufferingTimeY[DC__NUM_PIPES__MAX];                     // WM
-	double FullDETBufferingTimeC[DC__NUM_PIPES__MAX];                     // WM
+	double DisplayPipeLineDeliveryTimeLuma[DC__NUM_DPP__MAX];                     // WM
+	double DisplayPipeLineDeliveryTimeChroma[DC__NUM_DPP__MAX];                     // WM
+	double LinesInDETY[DC__NUM_DPP__MAX];                     // WM
+	double LinesInDETC[DC__NUM_DPP__MAX];                     // WM
+	unsigned int LinesInDETYRoundedDownToSwath[DC__NUM_DPP__MAX];                     // WM
+	unsigned int LinesInDETCRoundedDownToSwath[DC__NUM_DPP__MAX];                     // WM
+	double FullDETBufferingTimeY[DC__NUM_DPP__MAX];                     // WM
+	double FullDETBufferingTimeC[DC__NUM_DPP__MAX];                     // WM
 	double MinFullDETBufferingTime;
 	double FrameTimeForMinFullDETBufferingTime;
 	double AverageReadBandwidthGBytePerSecond;
@@ -145,55 +149,54 @@ struct vba_vars_st {
 	double EffectiveDETPlusLBLinesChroma;
 	double UrgentLatencySupportUsLuma;
 	double UrgentLatencySupportUsChroma;
-	double UrgentLatencySupportUs[DC__NUM_PIPES__MAX];
+	double UrgentLatencySupportUs[DC__NUM_DPP__MAX];
 	unsigned int DSCFormatFactor;
-	unsigned int BlockHeight256BytesY[DC__NUM_PIPES__MAX];
-	unsigned int BlockHeight256BytesC[DC__NUM_PIPES__MAX];
-	unsigned int BlockWidth256BytesY[DC__NUM_PIPES__MAX];
-	unsigned int BlockWidth256BytesC[DC__NUM_PIPES__MAX];
-	double VInitPreFillY[DC__NUM_PIPES__MAX];
-	double VInitPreFillC[DC__NUM_PIPES__MAX];
-	unsigned int MaxNumSwathY[DC__NUM_PIPES__MAX];
-	unsigned int MaxNumSwathC[DC__NUM_PIPES__MAX];
-	double PrefetchSourceLinesY[DC__NUM_PIPES__MAX];
-	double PrefetchSourceLinesC[DC__NUM_PIPES__MAX];
-	double PixelPTEBytesPerRow[DC__NUM_PIPES__MAX];
-	double MetaRowByte[DC__NUM_PIPES__MAX];
-	bool PTEBufferSizeNotExceeded; // not used
-	unsigned int dpte_row_height[DC__NUM_PIPES__MAX];
-	unsigned int dpte_row_height_chroma[DC__NUM_PIPES__MAX];
-	unsigned int meta_row_height[DC__NUM_PIPES__MAX];
-	unsigned int meta_row_height_chroma[DC__NUM_PIPES__MAX];
-
-	unsigned int MacroTileWidthY;
-	unsigned int MacroTileWidthC;
-	unsigned int MaxVStartupLines[DC__NUM_PIPES__MAX];
-	double WritebackDelay[DC__NUM_PIPES__MAX];
+	unsigned int BlockHeight256BytesY[DC__NUM_DPP__MAX];
+	unsigned int BlockHeight256BytesC[DC__NUM_DPP__MAX];
+	unsigned int BlockWidth256BytesY[DC__NUM_DPP__MAX];
+	unsigned int BlockWidth256BytesC[DC__NUM_DPP__MAX];
+	double VInitPreFillY[DC__NUM_DPP__MAX];
+	double VInitPreFillC[DC__NUM_DPP__MAX];
+	unsigned int MaxNumSwathY[DC__NUM_DPP__MAX];
+	unsigned int MaxNumSwathC[DC__NUM_DPP__MAX];
+	double PrefetchSourceLinesY[DC__NUM_DPP__MAX];
+	double PrefetchSourceLinesC[DC__NUM_DPP__MAX];
+	double PixelPTEBytesPerRow[DC__NUM_DPP__MAX];
+	double MetaRowByte[DC__NUM_DPP__MAX];
+	unsigned int dpte_row_height[DC__NUM_DPP__MAX];
+	unsigned int dpte_row_height_chroma[DC__NUM_DPP__MAX];
+	unsigned int meta_row_height[DC__NUM_DPP__MAX];
+	unsigned int meta_row_height_chroma[DC__NUM_DPP__MAX];
+
+	unsigned int MacroTileWidthY[DC__NUM_DPP__MAX];
+	unsigned int MacroTileWidthC[DC__NUM_DPP__MAX];
+	unsigned int MaxVStartupLines[DC__NUM_DPP__MAX];
+	double WritebackDelay[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
 	bool PrefetchModeSupported;
-	bool AllowDRAMClockChangeDuringVBlank[DC__NUM_PIPES__MAX];
-	bool AllowDRAMSelfRefreshDuringVBlank[DC__NUM_PIPES__MAX];
-	double RequiredPrefetchPixDataBW[DC__NUM_PIPES__MAX];
+	bool AllowDRAMClockChangeDuringVBlank[DC__NUM_DPP__MAX];
+	bool AllowDRAMSelfRefreshDuringVBlank[DC__NUM_DPP__MAX];
+	double RequiredPrefetchPixDataBW[DC__NUM_DPP__MAX];
 	double XFCRemoteSurfaceFlipDelay;
 	double TInitXFill;
 	double TslvChk;
 	double SrcActiveDrainRate;
-	double Tno_bw[DC__NUM_PIPES__MAX];
+	double Tno_bw[DC__NUM_DPP__MAX];
 	bool ImmediateFlipSupported;
 
-	double prefetch_vm_bw[DC__NUM_PIPES__MAX];
-	double prefetch_row_bw[DC__NUM_PIPES__MAX];
-	bool ImmediateFlipSupportedForPipe[DC__NUM_PIPES__MAX];
+	double prefetch_vm_bw[DC__NUM_DPP__MAX];
+	double prefetch_row_bw[DC__NUM_DPP__MAX];
+	bool ImmediateFlipSupportedForPipe[DC__NUM_DPP__MAX];
 	unsigned int VStartupLines;
-	double DisplayPipeLineDeliveryTimeLumaPrefetch[DC__NUM_PIPES__MAX];
-	double DisplayPipeLineDeliveryTimeChromaPrefetch[DC__NUM_PIPES__MAX];
+	double DisplayPipeLineDeliveryTimeLumaPrefetch[DC__NUM_DPP__MAX];
+	double DisplayPipeLineDeliveryTimeChromaPrefetch[DC__NUM_DPP__MAX];
 	unsigned int ActiveDPPs;
 	unsigned int LBLatencyHidingSourceLinesY;
 	unsigned int LBLatencyHidingSourceLinesC;
-	double ActiveDRAMClockChangeLatencyMargin[DC__NUM_PIPES__MAX];
+	double ActiveDRAMClockChangeLatencyMargin[DC__NUM_DPP__MAX];
 	double MinActiveDRAMClockChangeMargin;
-	double XFCSlaveVUpdateOffset[DC__NUM_PIPES__MAX];
-	double XFCSlaveVupdateWidth[DC__NUM_PIPES__MAX];
-	double XFCSlaveVReadyOffset[DC__NUM_PIPES__MAX];
+	double XFCSlaveVUpdateOffset[DC__NUM_DPP__MAX];
+	double XFCSlaveVupdateWidth[DC__NUM_DPP__MAX];
+	double XFCSlaveVReadyOffset[DC__NUM_DPP__MAX];
 	double InitFillLevel;
 	double FinalFillMargin;
 	double FinalFillLevel;
@@ -276,71 +279,71 @@ struct vba_vars_st {
 	double DCFCLK;
 
 	unsigned int NumberOfActivePlanes;
-	unsigned int ViewportWidth[DC__NUM_DPP];
-	unsigned int ViewportHeight[DC__NUM_DPP];
-	unsigned int ViewportYStartY[DC__NUM_DPP];
-	unsigned int ViewportYStartC[DC__NUM_DPP];
-	unsigned int PitchY[DC__NUM_DPP];
-	unsigned int PitchC[DC__NUM_DPP];
-	double HRatio[DC__NUM_DPP];
-	double VRatio[DC__NUM_DPP];
-	unsigned int htaps[DC__NUM_DPP];
-	unsigned int vtaps[DC__NUM_DPP];
-	unsigned int HTAPsChroma[DC__NUM_DPP];
-	unsigned int VTAPsChroma[DC__NUM_DPP];
-	unsigned int HTotal[DC__NUM_DPP];
-	unsigned int VTotal[DC__NUM_DPP];
-	unsigned int DPPPerPlane[DC__NUM_DPP];
-	double PixelClock[DC__NUM_DPP];
-	double PixelClockBackEnd[DC__NUM_DPP];
-	double DPPCLK[DC__NUM_DPP];
-	bool DCCEnable[DC__NUM_DPP];
-	unsigned int DCCMetaPitchY[DC__NUM_DPP];
-	enum scan_direction_class SourceScan[DC__NUM_DPP];
-	enum source_format_class SourcePixelFormat[DC__NUM_DPP];
-	bool WritebackEnable[DC__NUM_DPP];
-	double WritebackDestinationWidth[DC__NUM_DPP];
-	double WritebackDestinationHeight[DC__NUM_DPP];
-	double WritebackSourceHeight[DC__NUM_DPP];
-	enum source_format_class WritebackPixelFormat[DC__NUM_DPP];
-	unsigned int WritebackLumaHTaps[DC__NUM_DPP];
-	unsigned int WritebackLumaVTaps[DC__NUM_DPP];
-	unsigned int WritebackChromaHTaps[DC__NUM_DPP];
-	unsigned int WritebackChromaVTaps[DC__NUM_DPP];
-	double WritebackHRatio[DC__NUM_DPP];
-	double WritebackVRatio[DC__NUM_DPP];
-	unsigned int HActive[DC__NUM_DPP];
-	unsigned int VActive[DC__NUM_DPP];
-	bool Interlace[DC__NUM_DPP];
-	enum dm_swizzle_mode SurfaceTiling[DC__NUM_DPP];
-	unsigned int ScalerRecoutWidth[DC__NUM_DPP];
-	bool DynamicMetadataEnable[DC__NUM_DPP];
-	unsigned int DynamicMetadataLinesBeforeActiveRequired[DC__NUM_DPP];
-	unsigned int DynamicMetadataTransmittedBytes[DC__NUM_DPP];
-	double DCCRate[DC__NUM_DPP];
-	bool ODMCombineEnabled[DC__NUM_DPP];
-	double OutputBpp[DC__NUM_DPP];
-	unsigned int NumberOfDSCSlices[DC__NUM_DPP];
-	bool DSCEnabled[DC__NUM_DPP];
-	unsigned int DSCDelay[DC__NUM_DPP];
-	unsigned int DSCInputBitPerComponent[DC__NUM_DPP];
-	enum output_format_class OutputFormat[DC__NUM_DPP];
-	enum output_encoder_class Output[DC__NUM_DPP];
-	unsigned int BlendingAndTiming[DC__NUM_DPP];
+	unsigned int ViewportWidth[DC__NUM_DPP__MAX];
+	unsigned int ViewportHeight[DC__NUM_DPP__MAX];
+	unsigned int ViewportYStartY[DC__NUM_DPP__MAX];
+	unsigned int ViewportYStartC[DC__NUM_DPP__MAX];
+	unsigned int PitchY[DC__NUM_DPP__MAX];
+	unsigned int PitchC[DC__NUM_DPP__MAX];
+	double HRatio[DC__NUM_DPP__MAX];
+	double VRatio[DC__NUM_DPP__MAX];
+	unsigned int htaps[DC__NUM_DPP__MAX];
+	unsigned int vtaps[DC__NUM_DPP__MAX];
+	unsigned int HTAPsChroma[DC__NUM_DPP__MAX];
+	unsigned int VTAPsChroma[DC__NUM_DPP__MAX];
+	unsigned int HTotal[DC__NUM_DPP__MAX];
+	unsigned int VTotal[DC__NUM_DPP__MAX];
+	unsigned int DPPPerPlane[DC__NUM_DPP__MAX];
+	double PixelClock[DC__NUM_DPP__MAX];
+	double PixelClockBackEnd[DC__NUM_DPP__MAX];
+	double DPPCLK[DC__NUM_DPP__MAX];
+	bool DCCEnable[DC__NUM_DPP__MAX];
+	unsigned int DCCMetaPitchY[DC__NUM_DPP__MAX];
+	enum scan_direction_class SourceScan[DC__NUM_DPP__MAX];
+	enum source_format_class SourcePixelFormat[DC__NUM_DPP__MAX];
+	bool WritebackEnable[DC__NUM_DPP__MAX];
+	double WritebackDestinationWidth[DC__NUM_DPP__MAX];
+	double WritebackDestinationHeight[DC__NUM_DPP__MAX];
+	double WritebackSourceHeight[DC__NUM_DPP__MAX];
+	enum source_format_class WritebackPixelFormat[DC__NUM_DPP__MAX];
+	unsigned int WritebackLumaHTaps[DC__NUM_DPP__MAX];
+	unsigned int WritebackLumaVTaps[DC__NUM_DPP__MAX];
+	unsigned int WritebackChromaHTaps[DC__NUM_DPP__MAX];
+	unsigned int WritebackChromaVTaps[DC__NUM_DPP__MAX];
+	double WritebackHRatio[DC__NUM_DPP__MAX];
+	double WritebackVRatio[DC__NUM_DPP__MAX];
+	unsigned int HActive[DC__NUM_DPP__MAX];
+	unsigned int VActive[DC__NUM_DPP__MAX];
+	bool Interlace[DC__NUM_DPP__MAX];
+	enum dm_swizzle_mode SurfaceTiling[DC__NUM_DPP__MAX];
+	unsigned int ScalerRecoutWidth[DC__NUM_DPP__MAX];
+	bool DynamicMetadataEnable[DC__NUM_DPP__MAX];
+	unsigned int DynamicMetadataLinesBeforeActiveRequired[DC__NUM_DPP__MAX];
+	unsigned int DynamicMetadataTransmittedBytes[DC__NUM_DPP__MAX];
+	double DCCRate[DC__NUM_DPP__MAX];
+	bool ODMCombineEnabled[DC__NUM_DPP__MAX];
+	double OutputBpp[DC__NUM_DPP__MAX];
+	unsigned int NumberOfDSCSlices[DC__NUM_DPP__MAX];
+	bool DSCEnabled[DC__NUM_DPP__MAX];
+	unsigned int DSCDelay[DC__NUM_DPP__MAX];
+	unsigned int DSCInputBitPerComponent[DC__NUM_DPP__MAX];
+	enum output_format_class OutputFormat[DC__NUM_DPP__MAX];
+	enum output_encoder_class Output[DC__NUM_DPP__MAX];
+	unsigned int BlendingAndTiming[DC__NUM_DPP__MAX];
 	bool SynchronizedVBlank;
-	unsigned int NumberOfCursors[DC__NUM_DPP];
-	unsigned int CursorWidth[DC__NUM_DPP][DC__NUM_CURSOR];
-	unsigned int CursorBPP[DC__NUM_DPP][DC__NUM_CURSOR];
-	bool XFCEnabled[DC__NUM_DPP];
-	bool ScalerEnabled[DC__NUM_DPP];
+	unsigned int NumberOfCursors[DC__NUM_DPP__MAX];
+	unsigned int CursorWidth[DC__NUM_DPP__MAX][DC__NUM_CURSOR];
+	unsigned int CursorBPP[DC__NUM_DPP__MAX][DC__NUM_CURSOR];
+	bool XFCEnabled[DC__NUM_DPP__MAX];
+	bool ScalerEnabled[DC__NUM_DPP__MAX];
 
 	// Intermediates/Informational
 	bool ImmediateFlipSupport;
-	unsigned int SwathHeightY[DC__NUM_DPP];
-	unsigned int SwathHeightC[DC__NUM_DPP];
-	unsigned int DETBufferSizeY[DC__NUM_DPP];
-	unsigned int DETBufferSizeC[DC__NUM_DPP];
-	unsigned int LBBitPerPixel[DC__NUM_DPP];
+	unsigned int SwathHeightY[DC__NUM_DPP__MAX];
+	unsigned int SwathHeightC[DC__NUM_DPP__MAX];
+	unsigned int DETBufferSizeY[DC__NUM_DPP__MAX];
+	unsigned int DETBufferSizeC[DC__NUM_DPP__MAX];
+	unsigned int LBBitPerPixel[DC__NUM_DPP__MAX];
 	double LastPixelOfLineExtraWatermark;
 	double TotalDataReadBandwidth;
 	unsigned int TotalActiveWriteback;
@@ -349,9 +352,9 @@ struct vba_vars_st {
 	double BandwidthAvailableForImmediateFlip;
 	unsigned int PrefetchMode;
 	bool IgnoreViewportPositioning;
-	double PrefetchBandwidth[DC__NUM_DPP];
-	bool ErrorResult[DC__NUM_DPP];
-	double PDEAndMetaPTEBytesFrame[DC__NUM_DPP];
+	double PrefetchBandwidth[DC__NUM_DPP__MAX];
+	bool ErrorResult[DC__NUM_DPP__MAX];
+	double PDEAndMetaPTEBytesFrame[DC__NUM_DPP__MAX];
 
 	//
 	// Calculated dml_ml->vba.Outputs
@@ -376,35 +379,200 @@ struct vba_vars_st {
 	// used explicitly. They are fetched by tests and then possibly used. The
 	// ultimate values to use are the ones specified by the parameters to DML
 	double DISPCLK_calculated;
-	double DSCCLK_calculated[DC__NUM_DPP];
-	double DPPCLK_calculated[DC__NUM_DPP];
+	double DSCCLK_calculated[DC__NUM_DPP__MAX];
+	double DPPCLK_calculated[DC__NUM_DPP__MAX];
 
-	unsigned int VStartup[DC__NUM_DPP];
+	unsigned int VStartup[DC__NUM_DPP__MAX];
 	unsigned int VStartupRequiredWhenNotEnoughTimeForDynamicMetadata;
 
 	double ImmediateFlipBW;
 	unsigned int TotImmediateFlipBytes;
 	double TCalc;
-	double MinTTUVBlank[DC__NUM_DPP];
-	double VRatioPrefetchY[DC__NUM_DPP];
-	double VRatioPrefetchC[DC__NUM_DPP];
-	double DSTXAfterScaler[DC__NUM_DPP];
-	double DSTYAfterScaler[DC__NUM_DPP];
-
-	double DestinationLinesToRequestVMInVBlank[DC__NUM_DPP];
-	double DestinationLinesToRequestRowInVBlank[DC__NUM_DPP];
-	double DestinationLinesForPrefetch[DC__NUM_DPP];
-	double DestinationLinesToRequestRowInImmediateFlip[DC__NUM_DPP];
-	double DestinationLinesToRequestVMInImmediateFlip[DC__NUM_DPP];
-
-	double XFCTransferDelay[DC__NUM_DPP];
-	double XFCPrechargeDelay[DC__NUM_DPP];
-	double XFCRemoteSurfaceFlipLatency[DC__NUM_DPP];
-	double XFCPrefetchMargin[DC__NUM_DPP];
-
-	display_e2e_pipe_params_st cache_pipes[DC__NUM_DPP];
+	double MinTTUVBlank[DC__NUM_DPP__MAX];
+	double VRatioPrefetchY[DC__NUM_DPP__MAX];
+	double VRatioPrefetchC[DC__NUM_DPP__MAX];
+	double DSTXAfterScaler[DC__NUM_DPP__MAX];
+	double DSTYAfterScaler[DC__NUM_DPP__MAX];
+
+	double DestinationLinesToRequestVMInVBlank[DC__NUM_DPP__MAX];
+	double DestinationLinesToRequestRowInVBlank[DC__NUM_DPP__MAX];
+	double DestinationLinesForPrefetch[DC__NUM_DPP__MAX];
+	double DestinationLinesToRequestRowInImmediateFlip[DC__NUM_DPP__MAX];
+	double DestinationLinesToRequestVMInImmediateFlip[DC__NUM_DPP__MAX];
+
+	double XFCTransferDelay[DC__NUM_DPP__MAX];
+	double XFCPrechargeDelay[DC__NUM_DPP__MAX];
+	double XFCRemoteSurfaceFlipLatency[DC__NUM_DPP__MAX];
+	double XFCPrefetchMargin[DC__NUM_DPP__MAX];
+
+	display_e2e_pipe_params_st cache_pipes[DC__NUM_DPP__MAX];
 	unsigned int cache_num_pipes;
-	unsigned int pipe_plane[DC__NUM_PIPES__MAX];
+	unsigned int pipe_plane[DC__NUM_DPP__MAX];
+
+	/* vba mode support */
+	/*inputs*/
+	bool SupportGFX7CompatibleTilingIn32bppAnd64bpp;
+	double MaxHSCLRatio;
+	double MaxVSCLRatio;
+	unsigned int  MaxNumWriteback;
+	bool WritebackLumaAndChromaScalingSupported;
+	bool Cursor64BppSupport;
+	double DCFCLKPerState[DC__VOLTAGE_STATES + 1];
+	double FabricClockPerState[DC__VOLTAGE_STATES + 1];
+	double SOCCLKPerState[DC__VOLTAGE_STATES + 1];
+	double PHYCLKPerState[DC__VOLTAGE_STATES + 1];
+	double MaxDppclk[DC__VOLTAGE_STATES + 1];
+	double MaxDSCCLK[DC__VOLTAGE_STATES + 1];
+	double DRAMSpeedPerState[DC__VOLTAGE_STATES + 1];
+	double MaxDispclk[DC__VOLTAGE_STATES + 1];
+
+	/*outputs*/
+	bool ScaleRatioAndTapsSupport;
+	bool SourceFormatPixelAndScanSupport;
+	unsigned int SwathWidthYSingleDPP[DC__NUM_DPP__MAX];
+	double BytePerPixelInDETY[DC__NUM_DPP__MAX];
+	double BytePerPixelInDETC[DC__NUM_DPP__MAX];
+	double TotalReadBandwidthConsumedGBytePerSecond;
+	double ReadBandwidth[DC__NUM_DPP__MAX];
+	double TotalWriteBandwidthConsumedGBytePerSecond;
+	double WriteBandwidth[DC__NUM_DPP__MAX];
+	double TotalBandwidthConsumedGBytePerSecond;
+	bool DCCEnabledInAnyPlane;
+	bool WritebackLatencySupport;
+	bool WritebackModeSupport;
+	bool Writeback10bpc420Supported;
+	bool BandwidthSupport[DC__VOLTAGE_STATES + 1];
+	unsigned int TotalNumberOfActiveWriteback;
+	double CriticalPoint;
+	double ReturnBWToDCNPerState;
+	double FabricAndDRAMBandwidthPerState[DC__VOLTAGE_STATES + 1];
+	double ReturnBWPerState[DC__VOLTAGE_STATES + 1];
+	double UrgentRoundTripAndOutOfOrderLatencyPerState[DC__VOLTAGE_STATES + 1];
+	bool ODMCombineEnablePerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	bool PTEBufferSizeNotExceededY[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	bool PTEBufferSizeNotExceededC[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	bool PrefetchSupported[DC__VOLTAGE_STATES + 1];
+	bool VRatioInPrefetchSupported[DC__VOLTAGE_STATES + 1];
+	bool DISPCLK_DPPCLK_Support[DC__VOLTAGE_STATES + 1];
+	bool TotalAvailablePipesSupport[DC__VOLTAGE_STATES + 1];
+	bool UrgentLatencySupport[DC__VOLTAGE_STATES + 1];
+	bool ModeSupport[DC__VOLTAGE_STATES + 1];
+	bool DIOSupport[DC__VOLTAGE_STATES + 1];
+	bool NotEnoughDSCUnits[DC__VOLTAGE_STATES + 1];
+	bool DSCCLKRequiredMoreThanSupported[DC__VOLTAGE_STATES + 1];
+	bool ROBSupport[DC__VOLTAGE_STATES + 1];
+	bool PTEBufferSizeNotExceeded[DC__VOLTAGE_STATES + 1];
+	bool RequiresDSC[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	bool IsErrorResult[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	bool ViewportSizeSupport[DC__VOLTAGE_STATES + 1];
+	bool prefetch_vm_bw_valid;
+	bool prefetch_row_bw_valid;
+	bool NumberOfOTGSupport;
+	bool NonsupportedDSCInputBPC;
+	bool WritebackScaleRatioAndTapsSupport;
+	bool CursorSupport;
+	bool PitchSupport;
+
+	double WritebackLineBufferLumaBufferSize;
+	double WritebackLineBufferChromaBufferSize;
+	double WritebackMinHSCLRatio;
+	double WritebackMinVSCLRatio;
+	double WritebackMaxHSCLRatio;
+	double WritebackMaxVSCLRatio;
+	double WritebackMaxHSCLTaps;
+	double WritebackMaxVSCLTaps;
+	unsigned int MaxNumDPP;
+	unsigned int MaxNumOTG;
+	double CursorBufferSize;
+	double CursorChunkSize;
+	unsigned int Mode;
+	double NoOfDPP[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	double OutputLinkDPLanes[DC__NUM_DPP__MAX];
+	double SwathWidthYPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	double SwathHeightYPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	double SwathHeightCPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	double UrgentLatencySupportUsPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	double VRatioPreY[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	double VRatioPreC[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	double RequiredPrefetchPixelDataBW[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	double RequiredDPPCLK[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	double RequiredDISPCLK[DC__VOLTAGE_STATES + 1];
+	double TotalNumberOfActiveDPP[DC__VOLTAGE_STATES + 1];
+	double TotalNumberOfDCCActiveDPP[DC__VOLTAGE_STATES + 1];
+	double PrefetchBW[DC__NUM_DPP__MAX];
+	double PDEAndMetaPTEBytesPerFrame[DC__NUM_DPP__MAX];
+	double MetaRowBytes[DC__NUM_DPP__MAX];
+	double DPTEBytesPerRow[DC__NUM_DPP__MAX];
+	double PrefetchLinesY[DC__NUM_DPP__MAX];
+	double PrefetchLinesC[DC__NUM_DPP__MAX];
+	unsigned int MaxNumSwY[DC__NUM_DPP__MAX];
+	unsigned int MaxNumSwC[DC__NUM_DPP__MAX];
+	double PrefillY[DC__NUM_DPP__MAX];
+	double PrefillC[DC__NUM_DPP__MAX];
+	double LineTimesForPrefetch[DC__NUM_DPP__MAX];
+	double LinesForMetaPTE[DC__NUM_DPP__MAX];
+	double LinesForMetaAndDPTERow[DC__NUM_DPP__MAX];
+	double MinDPPCLKUsingSingleDPP[DC__NUM_DPP__MAX];
+	double RequiresFEC[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	unsigned int OutputBppPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	double DSCDelayPerState[DC__VOLTAGE_STATES + 1][DC__NUM_DPP__MAX];
+	unsigned int Read256BlockHeightY[DC__NUM_DPP__MAX];
+	unsigned int Read256BlockWidthY[DC__NUM_DPP__MAX];
+	unsigned int Read256BlockHeightC[DC__NUM_DPP__MAX];
+	unsigned int Read256BlockWidthC[DC__NUM_DPP__MAX];
+	unsigned int ImmediateFlipBytes[DC__NUM_DPP__MAX];
+	double MaxSwathHeightY[DC__NUM_DPP__MAX];
+	double MaxSwathHeightC[DC__NUM_DPP__MAX];
+	double MinSwathHeightY[DC__NUM_DPP__MAX];
+	double MinSwathHeightC[DC__NUM_DPP__MAX];
+	double PSCL_FACTOR[DC__NUM_DPP__MAX];
+	double PSCL_FACTOR_CHROMA[DC__NUM_DPP__MAX];
+	double MaximumVStartup[DC__NUM_DPP__MAX];
+	double AlignedDCCMetaPitch[DC__NUM_DPP__MAX];
+	double AlignedYPitch[DC__NUM_DPP__MAX];
+	double AlignedCPitch[DC__NUM_DPP__MAX];
+	double MaximumSwathWidth[DC__NUM_DPP__MAX];
+	double final_flip_bw[DC__NUM_DPP__MAX];
+	double ImmediateFlipSupportedForState[DC__VOLTAGE_STATES + 1];
+
+	double WritebackLumaVExtra;
+	double WritebackChromaVExtra;
+	double WritebackRequiredDISPCLK;
+	double MaximumSwathWidthSupport;
+	double MaximumSwathWidthInDETBuffer;
+	double MaximumSwathWidthInLineBuffer;
+	double MaxDispclkRoundedDownToDFSGranularity;
+	double MaxDppclkRoundedDownToDFSGranularity;
+	double PlaneRequiredDISPCLKWithoutODMCombine;
+	double PlaneRequiredDISPCLK;
+	double TotalNumberOfActiveOTG;
+	double FECOverhead;
+	double EffectiveFECOverhead;
+	unsigned int Outbpp;
+	unsigned int OutbppDSC;
+	double TotalDSCUnitsRequired;
+	double bpp;
+	unsigned int slices;
+	double SwathWidthGranularityY;
+	double RoundedUpMaxSwathSizeBytesY;
+	double SwathWidthGranularityC;
+	double RoundedUpMaxSwathSizeBytesC;
+	double LinesInDETLuma;
+	double LinesInDETChroma;
+	double EffectiveDETLBLinesLuma;
+	double EffectiveDETLBLinesChroma;
+	double ProjectedDCFCLKDeepSleep;
+	double PDEAndMetaPTEBytesPerFrameY;
+	double PDEAndMetaPTEBytesPerFrameC;
+	unsigned int MetaRowBytesY;
+	unsigned int MetaRowBytesC;
+	unsigned int DPTEBytesPerRowC;
+	unsigned int DPTEBytesPerRowY;
+	double ExtraLatency;
+	double TimeCalc;
+	double TWait;
+	double MaximumReadBandwidthWithPrefetch;
+	double total_dcn_read_bw_with_flip;
 };
 
 #endif /* _DML2_DISPLAY_MODE_VBA_H_ */

commit 6d04ee9dc10149db842d41de66eca201c9d91b60
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Aug 23 16:43:17 2017 -0400

    drm/amd/display: Restructuring and cleaning up DML
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
new file mode 100644
index 000000000000..a24fe9a0383d
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dml/display_mode_vba.h
@@ -0,0 +1,410 @@
+/*
+ * display_mode_vba.h
+ *
+ *  Created on: Aug 18, 2017
+ *      Author: dlaktyus
+ */
+
+#ifndef __DML2_DISPLAY_MODE_VBA_H__
+#define __DML2_DISPLAY_MODE_VBA_H__
+
+#include "dml_common_defs.h"
+
+struct display_mode_lib;
+
+void set_prefetch_mode(struct display_mode_lib *mode_lib,
+		bool cstate_en,
+		bool pstate_en,
+		bool ignore_viewport_pos,
+		bool immediate_flip_support);
+
+#define dml_get_attr_decl(attr) double get_##attr(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes)
+
+dml_get_attr_decl(clk_dcf_deepsleep);
+dml_get_attr_decl(wm_urgent);
+dml_get_attr_decl(wm_memory_trip);
+dml_get_attr_decl(wm_writeback_urgent);
+dml_get_attr_decl(wm_stutter_exit);
+dml_get_attr_decl(wm_stutter_enter_exit);
+dml_get_attr_decl(wm_dram_clock_change);
+dml_get_attr_decl(wm_writeback_dram_clock_change);
+dml_get_attr_decl(wm_xfc_underflow);
+dml_get_attr_decl(stutter_efficiency_no_vblank);
+dml_get_attr_decl(stutter_efficiency);
+dml_get_attr_decl(urgent_latency);
+dml_get_attr_decl(urgent_extra_latency);
+dml_get_attr_decl(nonurgent_latency);
+dml_get_attr_decl(dram_clock_change_latency);
+dml_get_attr_decl(dispclk_calculated);
+dml_get_attr_decl(total_data_read_bw);
+dml_get_attr_decl(return_bw);
+dml_get_attr_decl(tcalc);
+
+#define dml_get_pipe_attr_decl(attr) double get_##attr(struct display_mode_lib *mode_lib, const display_e2e_pipe_params_st *pipes, unsigned int num_pipes, unsigned int which_pipe)
+
+dml_get_pipe_attr_decl(dsc_delay);
+dml_get_pipe_attr_decl(dppclk_calculated);
+dml_get_pipe_attr_decl(dscclk_calculated);
+dml_get_pipe_attr_decl(min_ttu_vblank);
+dml_get_pipe_attr_decl(vratio_prefetch_l);
+dml_get_pipe_attr_decl(vratio_prefetch_c);
+dml_get_pipe_attr_decl(dst_x_after_scaler);
+dml_get_pipe_attr_decl(dst_y_after_scaler);
+dml_get_pipe_attr_decl(dst_y_per_vm_vblank);
+dml_get_pipe_attr_decl(dst_y_per_row_vblank);
+dml_get_pipe_attr_decl(dst_y_prefetch);
+dml_get_pipe_attr_decl(dst_y_per_vm_flip);
+dml_get_pipe_attr_decl(dst_y_per_row_flip);
+dml_get_pipe_attr_decl(xfc_transfer_delay);
+dml_get_pipe_attr_decl(xfc_precharge_delay);
+dml_get_pipe_attr_decl(xfc_remote_surface_flip_latency);
+dml_get_pipe_attr_decl(xfc_prefetch_margin);
+
+unsigned int get_vstartup_calculated(
+		struct display_mode_lib *mode_lib,
+		const display_e2e_pipe_params_st *pipes,
+		unsigned int num_pipes,
+		unsigned int which_pipe);
+
+double get_total_immediate_flip_bytes(
+		struct display_mode_lib *mode_lib,
+		const display_e2e_pipe_params_st *pipes,
+		unsigned int num_pipes);
+double get_total_immediate_flip_bw(
+		struct display_mode_lib *mode_lib,
+		const display_e2e_pipe_params_st *pipes,
+		unsigned int num_pipes);
+double get_total_prefetch_bw(
+		struct display_mode_lib *mode_lib,
+		const display_e2e_pipe_params_st *pipes,
+		unsigned int num_pipes);
+
+bool Calculate256BBlockSizes(
+		enum source_format_class SourcePixelFormat,
+		enum dm_swizzle_mode SurfaceTiling,
+		unsigned int BytePerPixelY,
+		unsigned int BytePerPixelC,
+		unsigned int *BlockHeight256BytesY,
+		unsigned int *BlockHeight256BytesC,
+		unsigned int *BlockWidth256BytesY,
+		unsigned int *BlockWidth256BytesC);
+
+
+struct vba_vars_st {
+	ip_params_st	ip;
+	soc_bounding_box_st	soc;
+	mode_evaluation_st me;
+
+	unsigned int MaximumMaxVStartupLines;
+	double cursor_bw[DC__NUM_PIPES__MAX];
+	double meta_row_bw[DC__NUM_PIPES__MAX];
+	double dpte_row_bw[DC__NUM_PIPES__MAX];
+	double qual_row_bw[DC__NUM_PIPES__MAX];
+	double WritebackDISPCLK;
+	double PSCL_THROUGHPUT_LUMA[DC__NUM_PIPES__MAX];
+	double PSCL_THROUGHPUT_CHROMA[DC__NUM_PIPES__MAX];
+	double DPPCLKUsingSingleDPPLuma;
+	double DPPCLKUsingSingleDPPChroma;
+	double DPPCLKUsingSingleDPP[DC__NUM_PIPES__MAX];
+	double DISPCLKWithRamping;
+	double DISPCLKWithoutRamping;
+	double GlobalDPPCLK;
+	double MaxDispclk;
+	double DISPCLKWithRampingRoundedToDFSGranularity;
+	double DISPCLKWithoutRampingRoundedToDFSGranularity;
+	double MaxDispclkRoundedToDFSGranularity;
+	bool DCCEnabledAnyPlane;
+	double ReturnBandwidthToDCN;
+	unsigned int SwathWidthY[DC__NUM_PIPES__MAX];
+	unsigned int SwathWidthSingleDPPY[DC__NUM_PIPES__MAX];
+	double BytePerPixelDETY[DC__NUM_PIPES__MAX];
+	double BytePerPixelDETC[DC__NUM_PIPES__MAX];
+	double ReadBandwidthPlaneLuma[DC__NUM_PIPES__MAX];
+	double ReadBandwidthPlaneChroma[DC__NUM_PIPES__MAX];
+	unsigned int TotalActiveDPP;
+	unsigned int TotalDCCActiveDPP;
+	double UrgentRoundTripAndOutOfOrderLatency;
+	double DisplayPipeLineDeliveryTimeLuma[DC__NUM_PIPES__MAX];                     // WM
+	double DisplayPipeLineDeliveryTimeChroma[DC__NUM_PIPES__MAX];                     // WM
+	double LinesInDETY[DC__NUM_PIPES__MAX];                     // WM
+	double LinesInDETC[DC__NUM_PIPES__MAX];                     // WM
+	unsigned int LinesInDETYRoundedDownToSwath[DC__NUM_PIPES__MAX];                     // WM
+	unsigned int LinesInDETCRoundedDownToSwath[DC__NUM_PIPES__MAX];                     // WM
+	double FullDETBufferingTimeY[DC__NUM_PIPES__MAX];                     // WM
+	double FullDETBufferingTimeC[DC__NUM_PIPES__MAX];                     // WM
+	double MinFullDETBufferingTime;
+	double FrameTimeForMinFullDETBufferingTime;
+	double AverageReadBandwidthGBytePerSecond;
+	double PartOfBurstThatFitsInROB;
+	double StutterBurstTime;
+	//unsigned int     NextPrefetchMode;
+	double VBlankTime;
+	double SmallestVBlank;
+	double DCFCLKDeepSleepPerPlane;
+	double EffectiveDETPlusLBLinesLuma;
+	double EffectiveDETPlusLBLinesChroma;
+	double UrgentLatencySupportUsLuma;
+	double UrgentLatencySupportUsChroma;
+	double UrgentLatencySupportUs[DC__NUM_PIPES__MAX];
+	unsigned int DSCFormatFactor;
+	unsigned int BlockHeight256BytesY[DC__NUM_PIPES__MAX];
+	unsigned int BlockHeight256BytesC[DC__NUM_PIPES__MAX];
+	unsigned int BlockWidth256BytesY[DC__NUM_PIPES__MAX];
+	unsigned int BlockWidth256BytesC[DC__NUM_PIPES__MAX];
+	double VInitPreFillY[DC__NUM_PIPES__MAX];
+	double VInitPreFillC[DC__NUM_PIPES__MAX];
+	unsigned int MaxNumSwathY[DC__NUM_PIPES__MAX];
+	unsigned int MaxNumSwathC[DC__NUM_PIPES__MAX];
+	double PrefetchSourceLinesY[DC__NUM_PIPES__MAX];
+	double PrefetchSourceLinesC[DC__NUM_PIPES__MAX];
+	double PixelPTEBytesPerRow[DC__NUM_PIPES__MAX];
+	double MetaRowByte[DC__NUM_PIPES__MAX];
+	bool PTEBufferSizeNotExceeded; // not used
+	unsigned int dpte_row_height[DC__NUM_PIPES__MAX];
+	unsigned int dpte_row_height_chroma[DC__NUM_PIPES__MAX];
+	unsigned int meta_row_height[DC__NUM_PIPES__MAX];
+	unsigned int meta_row_height_chroma[DC__NUM_PIPES__MAX];
+
+	unsigned int MacroTileWidthY;
+	unsigned int MacroTileWidthC;
+	unsigned int MaxVStartupLines[DC__NUM_PIPES__MAX];
+	double WritebackDelay[DC__NUM_PIPES__MAX];
+	bool PrefetchModeSupported;
+	bool AllowDRAMClockChangeDuringVBlank[DC__NUM_PIPES__MAX];
+	bool AllowDRAMSelfRefreshDuringVBlank[DC__NUM_PIPES__MAX];
+	double RequiredPrefetchPixDataBW[DC__NUM_PIPES__MAX];
+	double XFCRemoteSurfaceFlipDelay;
+	double TInitXFill;
+	double TslvChk;
+	double SrcActiveDrainRate;
+	double Tno_bw[DC__NUM_PIPES__MAX];
+	bool ImmediateFlipSupported;
+
+	double prefetch_vm_bw[DC__NUM_PIPES__MAX];
+	double prefetch_row_bw[DC__NUM_PIPES__MAX];
+	bool ImmediateFlipSupportedForPipe[DC__NUM_PIPES__MAX];
+	unsigned int VStartupLines;
+	double DisplayPipeLineDeliveryTimeLumaPrefetch[DC__NUM_PIPES__MAX];
+	double DisplayPipeLineDeliveryTimeChromaPrefetch[DC__NUM_PIPES__MAX];
+	unsigned int ActiveDPPs;
+	unsigned int LBLatencyHidingSourceLinesY;
+	unsigned int LBLatencyHidingSourceLinesC;
+	double ActiveDRAMClockChangeLatencyMargin[DC__NUM_PIPES__MAX];
+	double MinActiveDRAMClockChangeMargin;
+	double XFCSlaveVUpdateOffset[DC__NUM_PIPES__MAX];
+	double XFCSlaveVupdateWidth[DC__NUM_PIPES__MAX];
+	double XFCSlaveVReadyOffset[DC__NUM_PIPES__MAX];
+	double InitFillLevel;
+	double FinalFillMargin;
+	double FinalFillLevel;
+	double RemainingFillLevel;
+	double TFinalxFill;
+
+
+	//
+	// SOC Bounding Box Parameters
+	//
+	double SRExitTime;
+	double SREnterPlusExitTime;
+	double UrgentLatency;
+	double WritebackLatency;
+	double PercentOfIdealDRAMAndFabricBWReceivedAfterUrgLatency;
+	double NumberOfChannels;
+	double DRAMChannelWidth;
+	double FabricDatapathToDCNDataReturn;
+	double ReturnBusWidth;
+	double Downspreading;
+	double DISPCLKDPPCLKDSCCLKDownSpreading;
+	double DISPCLKDPPCLKVCOSpeed;
+	double RoundTripPingLatencyCycles;
+	double UrgentOutOfOrderReturnPerChannel;
+	unsigned int VMMPageSize;
+	double DRAMClockChangeLatency;
+	double XFCBusTransportTime;
+	double XFCXBUFLatencyTolerance;
+
+	//
+	// IP Parameters
+	//
+	unsigned int ROBBufferSizeInKByte;
+	double DETBufferSizeInKByte;
+	unsigned int DPPOutputBufferPixels;
+	unsigned int OPPOutputBufferLines;
+	unsigned int PixelChunkSizeInKByte;
+	double ReturnBW;
+	bool VirtualMemoryEnable;
+	unsigned int MaxPageTableLevels;
+	unsigned int OverridePageTableLevels;
+	unsigned int PTEChunkSize;
+	unsigned int MetaChunkSize;
+	unsigned int WritebackChunkSize;
+	bool ODMCapability;
+	unsigned int NumberOfDSC;
+	unsigned int LineBufferSize;
+	unsigned int MaxLineBufferLines;
+	unsigned int WritebackInterfaceLumaBufferSize;
+	unsigned int WritebackInterfaceChromaBufferSize;
+	unsigned int WritebackChromaLineBufferWidth;
+	double MaxDCHUBToPSCLThroughput;
+	double MaxPSCLToLBThroughput;
+	unsigned int PTEBufferSizeInRequests;
+	double DISPCLKRampingMargin;
+	unsigned int MaxInterDCNTileRepeaters;
+	bool XFCSupported;
+	double XFCSlvChunkSize;
+	double XFCFillBWOverhead;
+	double XFCFillConstant;
+	double XFCTSlvVupdateOffset;
+	double XFCTSlvVupdateWidth;
+	double XFCTSlvVreadyOffset;
+	double DPPCLKDelaySubtotal;
+	double DPPCLKDelaySCL;
+	double DPPCLKDelaySCLLBOnly;
+	double DPPCLKDelayCNVCFormater;
+	double DPPCLKDelayCNVCCursor;
+	double DISPCLKDelaySubtotal;
+	bool ProgressiveToInterlaceUnitInOPP;
+	unsigned int PDEProcessingBufIn64KBReqs;
+
+	// Pipe/Plane Parameters
+	int VoltageLevel;
+	double FabricAndDRAMBandwidth;
+	double FabricClock;
+	double DRAMSpeed;
+	double DISPCLK;
+	double SOCCLK;
+	double DCFCLK;
+
+	unsigned int NumberOfActivePlanes;
+	unsigned int ViewportWidth[DC__NUM_DPP];
+	unsigned int ViewportHeight[DC__NUM_DPP];
+	unsigned int ViewportYStartY[DC__NUM_DPP];
+	unsigned int ViewportYStartC[DC__NUM_DPP];
+	unsigned int PitchY[DC__NUM_DPP];
+	unsigned int PitchC[DC__NUM_DPP];
+	double HRatio[DC__NUM_DPP];
+	double VRatio[DC__NUM_DPP];
+	unsigned int htaps[DC__NUM_DPP];
+	unsigned int vtaps[DC__NUM_DPP];
+	unsigned int HTAPsChroma[DC__NUM_DPP];
+	unsigned int VTAPsChroma[DC__NUM_DPP];
+	unsigned int HTotal[DC__NUM_DPP];
+	unsigned int VTotal[DC__NUM_DPP];
+	unsigned int DPPPerPlane[DC__NUM_DPP];
+	double PixelClock[DC__NUM_DPP];
+	double PixelClockBackEnd[DC__NUM_DPP];
+	double DPPCLK[DC__NUM_DPP];
+	bool DCCEnable[DC__NUM_DPP];
+	unsigned int DCCMetaPitchY[DC__NUM_DPP];
+	enum scan_direction_class SourceScan[DC__NUM_DPP];
+	enum source_format_class SourcePixelFormat[DC__NUM_DPP];
+	bool WritebackEnable[DC__NUM_DPP];
+	double WritebackDestinationWidth[DC__NUM_DPP];
+	double WritebackDestinationHeight[DC__NUM_DPP];
+	double WritebackSourceHeight[DC__NUM_DPP];
+	enum source_format_class WritebackPixelFormat[DC__NUM_DPP];
+	unsigned int WritebackLumaHTaps[DC__NUM_DPP];
+	unsigned int WritebackLumaVTaps[DC__NUM_DPP];
+	unsigned int WritebackChromaHTaps[DC__NUM_DPP];
+	unsigned int WritebackChromaVTaps[DC__NUM_DPP];
+	double WritebackHRatio[DC__NUM_DPP];
+	double WritebackVRatio[DC__NUM_DPP];
+	unsigned int HActive[DC__NUM_DPP];
+	unsigned int VActive[DC__NUM_DPP];
+	bool Interlace[DC__NUM_DPP];
+	enum dm_swizzle_mode SurfaceTiling[DC__NUM_DPP];
+	unsigned int ScalerRecoutWidth[DC__NUM_DPP];
+	bool DynamicMetadataEnable[DC__NUM_DPP];
+	unsigned int DynamicMetadataLinesBeforeActiveRequired[DC__NUM_DPP];
+	unsigned int DynamicMetadataTransmittedBytes[DC__NUM_DPP];
+	double DCCRate[DC__NUM_DPP];
+	bool ODMCombineEnabled[DC__NUM_DPP];
+	double OutputBpp[DC__NUM_DPP];
+	unsigned int NumberOfDSCSlices[DC__NUM_DPP];
+	bool DSCEnabled[DC__NUM_DPP];
+	unsigned int DSCDelay[DC__NUM_DPP];
+	unsigned int DSCInputBitPerComponent[DC__NUM_DPP];
+	enum output_format_class OutputFormat[DC__NUM_DPP];
+	enum output_encoder_class Output[DC__NUM_DPP];
+	unsigned int BlendingAndTiming[DC__NUM_DPP];
+	bool SynchronizedVBlank;
+	unsigned int NumberOfCursors[DC__NUM_DPP];
+	unsigned int CursorWidth[DC__NUM_DPP][DC__NUM_CURSOR];
+	unsigned int CursorBPP[DC__NUM_DPP][DC__NUM_CURSOR];
+	bool XFCEnabled[DC__NUM_DPP];
+	bool ScalerEnabled[DC__NUM_DPP];
+
+	// Intermediates/Informational
+	bool ImmediateFlipSupport;
+	unsigned int SwathHeightY[DC__NUM_DPP];
+	unsigned int SwathHeightC[DC__NUM_DPP];
+	unsigned int DETBufferSizeY[DC__NUM_DPP];
+	unsigned int DETBufferSizeC[DC__NUM_DPP];
+	unsigned int LBBitPerPixel[DC__NUM_DPP];
+	double LastPixelOfLineExtraWatermark;
+	double TotalDataReadBandwidth;
+	unsigned int TotalActiveWriteback;
+	unsigned int EffectiveLBLatencyHidingSourceLinesLuma;
+	unsigned int EffectiveLBLatencyHidingSourceLinesChroma;
+	double BandwidthAvailableForImmediateFlip;
+	unsigned int PrefetchMode;
+	bool IgnoreViewportPositioning;
+	double PrefetchBandwidth[DC__NUM_DPP];
+	bool ErrorResult[DC__NUM_DPP];
+	double PDEAndMetaPTEBytesFrame[DC__NUM_DPP];
+
+	//
+	// Calculated dml_ml->vba.Outputs
+	//
+	double DCFClkDeepSleep;
+	double UrgentWatermark;
+	double UrgentExtraLatency;
+	double MemoryTripWatermark;
+	double WritebackUrgentWatermark;
+	double StutterExitWatermark;
+	double StutterEnterPlusExitWatermark;
+	double DRAMClockChangeWatermark;
+	double WritebackDRAMClockChangeWatermark;
+	double StutterEfficiency;
+	double StutterEfficiencyNotIncludingVBlank;
+	double MinUrgentLatencySupportUs;
+	double NonUrgentLatencyTolerance;
+	double MinActiveDRAMClockChangeLatencySupported;
+	enum clock_change_support DRAMClockChangeSupport;
+
+	// These are the clocks calcuated by the library but they are not actually
+	// used explicitly. They are fetched by tests and then possibly used. The
+	// ultimate values to use are the ones specified by the parameters to DML
+	double DISPCLK_calculated;
+	double DSCCLK_calculated[DC__NUM_DPP];
+	double DPPCLK_calculated[DC__NUM_DPP];
+
+	unsigned int VStartup[DC__NUM_DPP];
+	unsigned int VStartupRequiredWhenNotEnoughTimeForDynamicMetadata;
+
+	double ImmediateFlipBW;
+	unsigned int TotImmediateFlipBytes;
+	double TCalc;
+	double MinTTUVBlank[DC__NUM_DPP];
+	double VRatioPrefetchY[DC__NUM_DPP];
+	double VRatioPrefetchC[DC__NUM_DPP];
+	double DSTXAfterScaler[DC__NUM_DPP];
+	double DSTYAfterScaler[DC__NUM_DPP];
+
+	double DestinationLinesToRequestVMInVBlank[DC__NUM_DPP];
+	double DestinationLinesToRequestRowInVBlank[DC__NUM_DPP];
+	double DestinationLinesForPrefetch[DC__NUM_DPP];
+	double DestinationLinesToRequestRowInImmediateFlip[DC__NUM_DPP];
+	double DestinationLinesToRequestVMInImmediateFlip[DC__NUM_DPP];
+
+	double XFCTransferDelay[DC__NUM_DPP];
+	double XFCPrechargeDelay[DC__NUM_DPP];
+	double XFCRemoteSurfaceFlipLatency[DC__NUM_DPP];
+	double XFCPrefetchMargin[DC__NUM_DPP];
+
+	display_e2e_pipe_params_st cache_pipes[DC__NUM_DPP];
+	unsigned int cache_num_pipes;
+	unsigned int pipe_plane[DC__NUM_PIPES__MAX];
+};
+
+#endif /* _DML2_DISPLAY_MODE_VBA_H_ */
