commit d9eb70ae610fea5ff41b9849cc541c8d5f0146db
Author: Noah Abradjian <noah.abradjian@amd.com>
Date:   Fri Dec 13 09:31:20 2019 -0500

    drm/amd/display: Fix double buffering in dcn2 ICSC
    
    [Why]
    When rapidly adjusting video brightness, screen tearing was observed.
    This was due to overwritten values in ICSC registers. In dcn10, this issue had been
    fixed by implementing double buffering via alternating ICSC modes.
    However, the second register set used in dcn1 doesn't exist in dcn2.
    
    [How]
    Create new program_input_csc for dcn20.
    Use ICSC_B registers instead of COMA registers as second set.
    
    Signed-off-by: Noah Abradjian <noah.abradjian@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 935c892622a0..4d3f7d5e1473 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -88,26 +88,6 @@ enum dscl_mode_sel {
 	DSCL_MODE_DSCL_BYPASS = 6
 };
 
-static const struct dpp_input_csc_matrix dpp_input_csc_matrix[] = {
-	{COLOR_SPACE_SRGB,
-		{0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
-	{COLOR_SPACE_SRGB_LIMITED,
-		{0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
-	{COLOR_SPACE_YCBCR601,
-		{0x2cdd, 0x2000, 0, 0xe991, 0xe926, 0x2000, 0xf4fd, 0x10ef,
-						0, 0x2000, 0x38b4, 0xe3a6} },
-	{COLOR_SPACE_YCBCR601_LIMITED,
-		{0x3353, 0x2568, 0, 0xe400, 0xe5dc, 0x2568, 0xf367, 0x1108,
-						0, 0x2568, 0x40de, 0xdd3a} },
-	{COLOR_SPACE_YCBCR709,
-		{0x3265, 0x2000, 0, 0xe6ce, 0xf105, 0x2000, 0xfa01, 0xa7d, 0,
-						0x2000, 0x3b61, 0xe24f} },
-
-	{COLOR_SPACE_YCBCR709_LIMITED,
-		{0x39a6, 0x2568, 0, 0xe0d6, 0xeedd, 0x2568, 0xf925, 0x9a8, 0,
-						0x2568, 0x43ee, 0xdbb2} }
-};
-
 static void program_gamut_remap(
 		struct dcn10_dpp *dpp,
 		const uint16_t *regval,

commit 2853ecc6610af9e40b6686498330b64a780cb181
Author: Reza Amini <Reza.Amini@amd.com>
Date:   Thu Nov 7 10:10:45 2019 -0500

    drm/amd/display: Implement DePQ for DCN1
    
    [Why]
    Need support for more color management in 10bit
    surface.
    
    [How]
    Provide support for DePQ for 10bit surface
    
    Signed-off-by: Reza Amini <Reza.Amini@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 6b7593dd0c77..935c892622a0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -628,6 +628,9 @@ void dpp1_set_degamma(
 	case IPP_DEGAMMA_MODE_HW_xvYCC:
 		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 2);
 			break;
+	case IPP_DEGAMMA_MODE_USER_PWL:
+		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 3);
+		break;
 	default:
 		BREAK_TO_DEBUGGER();
 		break;

commit 1da37801a8b0fffb024fea594c7f1d7867ed8aa0
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:38:55 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_0 and DSC_SUPPORTED
    
    [Why]
    
    DCN2 and DSC are stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup NV defninitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN2 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * dce/dce_dmcu.c: dcn20_*lock_phy()
        * dce/dce_dmcu.c: dcn20_funcs
        * dce/dce_dmcu.c: dcn20_dmcu_create()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 6f1a312c6a5a..6b7593dd0c77 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -736,10 +736,8 @@ void dpp1_full_bypass(struct dpp *dpp_base)
 	/* COLOR_KEYER_CONTROL.COLOR_KEYER_EN = 0 this should be default */
 	if (dpp->tf_mask->CM_BYPASS_EN)
 		REG_SET(CM_CONTROL, 0, CM_BYPASS_EN, 1);
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	else
 		REG_SET(CM_CONTROL, 0, CM_BYPASS, 1);
-#endif
 
 	/* Setting degamma bypass for now */
 	REG_SET(CM_DGAM_CONTROL, 0, CM_DGAM_LUT_MODE, 0);

commit 2200eb9e1819aabb9a1c24d5f6b132f389a2e8a9
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Mon Oct 28 09:22:34 2019 -0400

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DMUB guards
    
    [Why]
    Support for DMUB only depends on support for DC. It doesn't use floating
    point so we don't need to guard it by any specific DCN revision.
    
    [How]
    Drop the guards and cleanup the newlines around each one.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 41a0e53d2ba4..6f1a312c6a5a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -352,9 +352,8 @@ void dpp1_cm_program_regamma_lut(struct dpp *dpp_base,
 	uint32_t i;
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
-#ifdef CONFIG_DRM_AMD_DC_DMUB
 	REG_SEQ_START();
-#endif
+
 	for (i = 0 ; i < num; i++) {
 		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].red_reg);
 		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].green_reg);
@@ -633,10 +632,9 @@ void dpp1_set_degamma(
 		BREAK_TO_DEBUGGER();
 		break;
 	}
-#ifdef CONFIG_DRM_AMD_DC_DMUB
+
 	REG_SEQ_SUBMIT();
 	REG_SEQ_WAIT_DONE();
-#endif
 }
 
 void dpp1_degamma_ram_select(

commit 3a1627b07385a6bb497f7ca4e2ffe1e1dbc70b68
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Fri Oct 25 15:03:58 2019 -0400

    drm/amd/display: Add DMUB support to DC
    
    DC will use DMUB for command submission and flow control during
    initialization.
    
    Register offloading as well as submitting some BIOS commands are part
    of the DC internal interface but are guarded behind debug options.
    
    It won't be functional in amdgpu_dm yet since we don't pass the
    DMUB service to DC for use.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index aa0c7a7d13a0..41a0e53d2ba4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -352,6 +352,9 @@ void dpp1_cm_program_regamma_lut(struct dpp *dpp_base,
 	uint32_t i;
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
+#ifdef CONFIG_DRM_AMD_DC_DMUB
+	REG_SEQ_START();
+#endif
 	for (i = 0 ; i < num; i++) {
 		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].red_reg);
 		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].green_reg);
@@ -630,6 +633,10 @@ void dpp1_set_degamma(
 		BREAK_TO_DEBUGGER();
 		break;
 	}
+#ifdef CONFIG_DRM_AMD_DC_DMUB
+	REG_SEQ_SUBMIT();
+	REG_SEQ_WAIT_DONE();
+#endif
 }
 
 void dpp1_degamma_ram_select(

commit f7de96ee8b5f4d0d4ef7b00b8868049a6869a10f
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Feb 22 15:50:50 2019 -0500

    drm/amd/display: Add DCN2 DPP
    
    Add support to program the DCN2 DPP (Multiple pipe and plane combine)
    
    HW Blocks:
    
        +--------+
        |  DPP   |
        +--------+
            |
            v
        +--------+
        |  MPC   |
        +--------+
            |
            v
        +-------+
        |  OPP  |
        +-------+
            |
            v
        +--------+
        |  OPTC  |
        +--------+
            |
            v
        +--------+       +--------+
        |  DIO   |       |  DCCG  |
        +--------+       +--------+
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 882bcc5a40f6..aa0c7a7d13a0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -731,6 +731,10 @@ void dpp1_full_bypass(struct dpp *dpp_base)
 	/* COLOR_KEYER_CONTROL.COLOR_KEYER_EN = 0 this should be default */
 	if (dpp->tf_mask->CM_BYPASS_EN)
 		REG_SET(CM_CONTROL, 0, CM_BYPASS_EN, 1);
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	else
+		REG_SET(CM_CONTROL, 0, CM_BYPASS, 1);
+#endif
 
 	/* Setting degamma bypass for now */
 	REG_SET(CM_DGAM_CONTROL, 0, CM_DGAM_LUT_MODE, 0);

commit e1998c8cfd59c223afabc20191c0570622583d06
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Tue Jan 29 16:20:26 2019 -0500

    drm/amd/display: Move enum gamut_remap_select to hw_shared.h
    
    This enum definition is shared, so move it to a shared location.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 41f0f4c912e7..882bcc5a40f6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -88,13 +88,6 @@ enum dscl_mode_sel {
 	DSCL_MODE_DSCL_BYPASS = 6
 };
 
-enum gamut_remap_select {
-	GAMUT_REMAP_BYPASS = 0,
-	GAMUT_REMAP_COEFF,
-	GAMUT_REMAP_COMA_COEFF,
-	GAMUT_REMAP_COMB_COEFF
-};
-
 static const struct dpp_input_csc_matrix dpp_input_csc_matrix[] = {
 	{COLOR_SPACE_SRGB,
 		{0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },

commit da1043cf22d3b9e652992e9d9a9372b90658ceb2
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Fri Nov 9 16:51:55 2018 -0500

    drm/amd/display: Fix runtime errors for diagnostic tests
    
    1) Rename and make public definition of input CSC matrix struct.
    2) Make wm_read_state() function an interface of hubbub, and check
       if watermark registers exist before read/write to them.
    3) Check if OTG_INTERLACE_CONTROL register exists before updating
    4) Add dummy functions for set_input/output_transfer function to avoid
       errors due to differences in CM registers.
    5) Added missing register field definition in header file
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 116977eb24e2..41f0f4c912e7 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -51,10 +51,6 @@
 
 #define NUM_ELEMENTS(a) (sizeof(a) / sizeof((a)[0]))
 
-struct dcn10_input_csc_matrix {
-	enum dc_color_space color_space;
-	uint16_t regval[12];
-};
 
 enum dcn10_coef_filter_type_sel {
 	SCL_COEF_LUMA_VERT_FILTER = 0,
@@ -99,7 +95,7 @@ enum gamut_remap_select {
 	GAMUT_REMAP_COMB_COEFF
 };
 
-static const struct dcn10_input_csc_matrix dcn10_input_csc_matrix[] = {
+static const struct dpp_input_csc_matrix dpp_input_csc_matrix[] = {
 	{COLOR_SPACE_SRGB,
 		{0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
 	{COLOR_SPACE_SRGB_LIMITED,
@@ -454,7 +450,7 @@ void dpp1_program_input_csc(
 {
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	int i;
-	int arr_size = sizeof(dcn10_input_csc_matrix)/sizeof(struct dcn10_input_csc_matrix);
+	int arr_size = sizeof(dpp_input_csc_matrix)/sizeof(struct dpp_input_csc_matrix);
 	const uint16_t *regval = NULL;
 	uint32_t cur_select = 0;
 	enum dcn10_input_csc_select select;
@@ -467,8 +463,8 @@ void dpp1_program_input_csc(
 
 	if (tbl_entry == NULL) {
 		for (i = 0; i < arr_size; i++)
-			if (dcn10_input_csc_matrix[i].color_space == color_space) {
-				regval = dcn10_input_csc_matrix[i].regval;
+			if (dpp_input_csc_matrix[i].color_space == color_space) {
+				regval = dpp_input_csc_matrix[i].regval;
 				break;
 			}
 

commit eb0e515464e4a1be730c7ac7a01c3ba04c98ea97
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Apr 18 11:37:53 2018 -0400

    drm/amd/display: get rid of 32.32 unsigned fixed point
    
    32.32 is redundant, 31.32 does everything we use 32.32 for
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 4f373c97804f..116977eb24e2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -811,13 +811,13 @@ void dpp1_program_input_lut(
 	REG_UPDATE(CM_IGAM_LUT_RW_INDEX, CM_IGAM_LUT_RW_INDEX, 0);
 	for (i = 0; i < gamma->num_entries; i++) {
 		REG_SET(CM_IGAM_LUT_SEQ_COLOR, 0, CM_IGAM_LUT_SEQ_COLOR,
-				dal_fixed31_32_round(
+				dc_fixpt_round(
 					gamma->entries.red[i]));
 		REG_SET(CM_IGAM_LUT_SEQ_COLOR, 0, CM_IGAM_LUT_SEQ_COLOR,
-				dal_fixed31_32_round(
+				dc_fixpt_round(
 					gamma->entries.green[i]));
 		REG_SET(CM_IGAM_LUT_SEQ_COLOR, 0, CM_IGAM_LUT_SEQ_COLOR,
-				dal_fixed31_32_round(
+				dc_fixpt_round(
 					gamma->entries.blue[i]));
 	}
 	// Power off LUT memory

commit 5813dd1c0c4e06b3321142cd2da99909a1f41707
Author: Xingyue Tao <xingyue.tao@amd.com>
Date:   Fri Mar 16 15:20:48 2018 -0400

    drm/amd/display: Add double buffer machanism to OCSC
    
    - Added double buffer mechanism to output CSC
    so that there's no tearing when adjusting brightness
    from Radeon settings
    
    Signed-off-by: Xingyue Tao <xingyue.tao@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index cc511415caee..4f373c97804f 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -216,41 +216,55 @@ static void dpp1_cm_program_color_matrix(
 		struct dcn10_dpp *dpp,
 		const uint16_t *regval)
 {
-	uint32_t mode;
+	uint32_t ocsc_mode;
+	uint32_t cur_mode;
 	struct color_matrices_reg gam_regs;
 
-	REG_GET(CM_OCSC_CONTROL, CM_OCSC_MODE, &mode);
-
 	if (regval == NULL) {
 		BREAK_TO_DEBUGGER();
 		return;
 	}
-	mode = 4;
+
+	/* determine which CSC matrix (ocsc or comb) we are using
+	 * currently.  select the alternate set to double buffer
+	 * the CSC update so CSC is updated on frame boundary
+	 */
+	REG_SET(CM_TEST_DEBUG_INDEX, 0,
+			CM_TEST_DEBUG_INDEX, 9);
+
+	REG_GET(CM_TEST_DEBUG_DATA,
+			CM_TEST_DEBUG_DATA_ID9_OCSC_MODE, &cur_mode);
+
+	if (cur_mode != 4)
+		ocsc_mode = 4;
+	else
+		ocsc_mode = 5;
+
+
 	gam_regs.shifts.csc_c11 = dpp->tf_shift->CM_OCSC_C11;
 	gam_regs.masks.csc_c11  = dpp->tf_mask->CM_OCSC_C11;
 	gam_regs.shifts.csc_c12 = dpp->tf_shift->CM_OCSC_C12;
 	gam_regs.masks.csc_c12 = dpp->tf_mask->CM_OCSC_C12;
 
-	if (mode == 4) {
+	if (ocsc_mode == 4) {
 
 		gam_regs.csc_c11_c12 = REG(CM_OCSC_C11_C12);
 		gam_regs.csc_c33_c34 = REG(CM_OCSC_C33_C34);
 
-		cm_helper_program_color_matrices(
-				dpp->base.ctx,
-				regval,
-				&gam_regs);
-
 	} else {
 
 		gam_regs.csc_c11_c12 = REG(CM_COMB_C11_C12);
 		gam_regs.csc_c33_c34 = REG(CM_COMB_C33_C34);
 
-		cm_helper_program_color_matrices(
-				dpp->base.ctx,
-				regval,
-				&gam_regs);
 	}
+
+	cm_helper_program_color_matrices(
+			dpp->base.ctx,
+			regval,
+			&gam_regs);
+
+	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
+
 }
 
 void dpp1_cm_set_output_csc_default(
@@ -260,7 +274,6 @@ void dpp1_cm_set_output_csc_default(
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	const uint16_t *regval = NULL;
 	int arr_size;
-	uint32_t ocsc_mode = 4;
 
 	regval = find_color_matrix(colorspace, &arr_size);
 	if (regval == NULL) {
@@ -269,7 +282,6 @@ void dpp1_cm_set_output_csc_default(
 	}
 
 	dpp1_cm_program_color_matrix(dpp, regval);
-	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
 }
 
 static void dpp1_cm_get_reg_field(
@@ -330,10 +342,8 @@ void dpp1_cm_set_output_csc_adjustment(
 		const uint16_t *regval)
 {
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
-	uint32_t ocsc_mode = 4;
 
 	dpp1_cm_program_color_matrix(dpp, regval);
-	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
 }
 
 void dpp1_cm_power_on_regamma_lut(struct dpp *dpp_base,

commit 7608f8569d8fee1372d4a3409aea5cca0b13b194
Author: Xingyue Tao <xingyue.tao@amd.com>
Date:   Wed Mar 14 17:57:42 2018 -0400

    drm/amd/display: Add double buffer machanism to ICSC
    
    - Video playback shows tearing when adjusting
    brightness through radeon custom settings.
    - Now added double buffer mechanism to switch
    input CSC from register buffer ICSC and COMA
    - Improved tab alignment
    
    Signed-off-by: Xingyue Tao <xingyue.tao@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index fb32975e4b67..cc511415caee 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -267,6 +267,7 @@ void dpp1_cm_set_output_csc_default(
 		BREAK_TO_DEBUGGER();
 		return;
 	}
+
 	dpp1_cm_program_color_matrix(dpp, regval);
 	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
 }
@@ -330,6 +331,7 @@ void dpp1_cm_set_output_csc_adjustment(
 {
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	uint32_t ocsc_mode = 4;
+
 	dpp1_cm_program_color_matrix(dpp, regval);
 	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
 }
@@ -437,17 +439,18 @@ void dpp1_cm_program_regamma_lutb_settings(
 void dpp1_program_input_csc(
 		struct dpp *dpp_base,
 		enum dc_color_space color_space,
-		enum dcn10_input_csc_select select,
+		enum dcn10_input_csc_select input_select,
 		const struct out_csc_color_matrix *tbl_entry)
 {
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	int i;
 	int arr_size = sizeof(dcn10_input_csc_matrix)/sizeof(struct dcn10_input_csc_matrix);
 	const uint16_t *regval = NULL;
-	uint32_t selection = 1;
+	uint32_t cur_select = 0;
+	enum dcn10_input_csc_select select;
 	struct color_matrices_reg gam_regs;
 
-	if (select == INPUT_CSC_SELECT_BYPASS) {
+	if (input_select == INPUT_CSC_SELECT_BYPASS) {
 		REG_SET(CM_ICSC_CONTROL, 0, CM_ICSC_MODE, 0);
 		return;
 	}
@@ -467,36 +470,45 @@ void dpp1_program_input_csc(
 		regval = tbl_entry->regval;
 	}
 
-	if (select == INPUT_CSC_SELECT_COMA)
-		selection = 2;
-	REG_SET(CM_ICSC_CONTROL, 0,
-			CM_ICSC_MODE, selection);
+	/* determine which CSC matrix (icsc or coma) we are using
+	 * currently.  select the alternate set to double buffer
+	 * the CSC update so CSC is updated on frame boundary
+	 */
+	REG_SET(CM_TEST_DEBUG_INDEX, 0,
+			CM_TEST_DEBUG_INDEX, 9);
+
+	REG_GET(CM_TEST_DEBUG_DATA,
+			CM_TEST_DEBUG_DATA_ID9_ICSC_MODE, &cur_select);
+
+	if (cur_select != INPUT_CSC_SELECT_ICSC)
+		select = INPUT_CSC_SELECT_ICSC;
+	else
+		select = INPUT_CSC_SELECT_COMA;
 
 	gam_regs.shifts.csc_c11 = dpp->tf_shift->CM_ICSC_C11;
 	gam_regs.masks.csc_c11  = dpp->tf_mask->CM_ICSC_C11;
 	gam_regs.shifts.csc_c12 = dpp->tf_shift->CM_ICSC_C12;
 	gam_regs.masks.csc_c12 = dpp->tf_mask->CM_ICSC_C12;
 
-
 	if (select == INPUT_CSC_SELECT_ICSC) {
 
 		gam_regs.csc_c11_c12 = REG(CM_ICSC_C11_C12);
 		gam_regs.csc_c33_c34 = REG(CM_ICSC_C33_C34);
 
-		cm_helper_program_color_matrices(
-				dpp->base.ctx,
-				regval,
-				&gam_regs);
 	} else {
 
 		gam_regs.csc_c11_c12 = REG(CM_COMA_C11_C12);
 		gam_regs.csc_c33_c34 = REG(CM_COMA_C33_C34);
 
-		cm_helper_program_color_matrices(
-				dpp->base.ctx,
-				regval,
-				&gam_regs);
 	}
+
+	cm_helper_program_color_matrices(
+			dpp->base.ctx,
+			regval,
+			&gam_regs);
+
+	REG_SET(CM_ICSC_CONTROL, 0,
+				CM_ICSC_MODE, select);
 }
 
 //keep here for now, decide multi dce support later

commit a4056c2a6344c64bd62234458a314e6aecce226f
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Fri Feb 23 17:51:33 2018 -0500

    drm/amd/display: use HW hdr mult for brightness boost
    
    In MPO scenario when playing SDR clip in HDR desktop mode, Win is
    boosting desktop and requests driver to boost MPO. But driver boosting
    is currently done in regamma which is stream property and thus shared
    between grph and video.
    
    Redesigning the boosting in RV: use CM_HDR_MULT register which was added
    for this scenario. It also has the benefit that it can be done in HIRQL.
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index bd3fcdfb79c5..fb32975e4b67 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -804,3 +804,12 @@ void dpp1_program_input_lut(
 	REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, rama_occupied ? 3 : 2);
 	REG_GET(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, &ram_num);
 }
+
+void dpp1_set_hdr_multiplier(
+		struct dpp *dpp_base,
+		uint32_t multiplier)
+{
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
+
+	REG_UPDATE(CM_HDR_MULT_COEF, CM_HDR_MULT_COEF, multiplier);
+}

commit 792474b736274fd698d39708a729b41098ae28de
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Tue Feb 6 15:06:23 2018 -0600

    drm/amd/display: De PQ implementation
    
    Some refactoring and optimizations in color module.
    Added de gamma 2.2 & 2.4, also re gamma 2.2.
    Added interface for diagnostic for de gamma & de pq.
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 2482390c1557..bd3fcdfb79c5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -298,6 +298,32 @@ static void dpp1_cm_get_reg_field(
 	reg->masks.exp_resion_start_segment = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B;
 }
 
+static void dpp1_cm_get_degamma_reg_field(
+		struct dcn10_dpp *dpp,
+		struct xfer_func_reg *reg)
+{
+	reg->shifts.exp_region0_lut_offset = dpp->tf_shift->CM_DGAM_RAMA_EXP_REGION0_LUT_OFFSET;
+	reg->masks.exp_region0_lut_offset = dpp->tf_mask->CM_DGAM_RAMA_EXP_REGION0_LUT_OFFSET;
+	reg->shifts.exp_region0_num_segments = dpp->tf_shift->CM_DGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;
+	reg->masks.exp_region0_num_segments = dpp->tf_mask->CM_DGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;
+	reg->shifts.exp_region1_lut_offset = dpp->tf_shift->CM_DGAM_RAMA_EXP_REGION1_LUT_OFFSET;
+	reg->masks.exp_region1_lut_offset = dpp->tf_mask->CM_DGAM_RAMA_EXP_REGION1_LUT_OFFSET;
+	reg->shifts.exp_region1_num_segments = dpp->tf_shift->CM_DGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;
+	reg->masks.exp_region1_num_segments = dpp->tf_mask->CM_DGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;
+
+	reg->shifts.field_region_end = dpp->tf_shift->CM_DGAM_RAMB_EXP_REGION_END_B;
+	reg->masks.field_region_end = dpp->tf_mask->CM_DGAM_RAMB_EXP_REGION_END_B;
+	reg->shifts.field_region_end_slope = dpp->tf_shift->CM_DGAM_RAMB_EXP_REGION_END_SLOPE_B;
+	reg->masks.field_region_end_slope = dpp->tf_mask->CM_DGAM_RAMB_EXP_REGION_END_SLOPE_B;
+	reg->shifts.field_region_end_base = dpp->tf_shift->CM_DGAM_RAMB_EXP_REGION_END_BASE_B;
+	reg->masks.field_region_end_base = dpp->tf_mask->CM_DGAM_RAMB_EXP_REGION_END_BASE_B;
+	reg->shifts.field_region_linear_slope = dpp->tf_shift->CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;
+	reg->masks.field_region_linear_slope = dpp->tf_mask->CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;
+	reg->shifts.exp_region_start = dpp->tf_shift->CM_DGAM_RAMB_EXP_REGION_START_B;
+	reg->masks.exp_region_start = dpp->tf_mask->CM_DGAM_RAMB_EXP_REGION_START_B;
+	reg->shifts.exp_resion_start_segment = dpp->tf_shift->CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_B;
+	reg->masks.exp_resion_start_segment = dpp->tf_mask->CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_B;
+}
 void dpp1_cm_set_output_csc_adjustment(
 		struct dpp *dpp_base,
 		const uint16_t *regval)
@@ -502,7 +528,7 @@ void dpp1_program_degamma_lutb_settings(
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	struct xfer_func_reg gam_regs;
 
-	dpp1_cm_get_reg_field(dpp, &gam_regs);
+	dpp1_cm_get_degamma_reg_field(dpp, &gam_regs);
 
 	gam_regs.start_cntl_b = REG(CM_DGAM_RAMB_START_CNTL_B);
 	gam_regs.start_cntl_g = REG(CM_DGAM_RAMB_START_CNTL_G);
@@ -531,7 +557,7 @@ void dpp1_program_degamma_luta_settings(
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	struct xfer_func_reg gam_regs;
 
-	dpp1_cm_get_reg_field(dpp, &gam_regs);
+	dpp1_cm_get_degamma_reg_field(dpp, &gam_regs);
 
 	gam_regs.start_cntl_b = REG(CM_DGAM_RAMA_START_CNTL_B);
 	gam_regs.start_cntl_g = REG(CM_DGAM_RAMA_START_CNTL_G);

commit 146a9f636824dedb6b5722bd4361cc111624d053
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Fri Dec 15 17:58:45 2017 -0500

    drm/amd/display: Pass full 3x4 remap matrix for color transform
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index a5b099023652..2482390c1557 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -193,6 +193,7 @@ void dpp1_cm_set_gamut_remap(
 	const struct dpp_grph_csc_adjustment *adjust)
 {
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
+	int i = 0;
 
 	if (adjust->gamut_adjust_type != GRAPHICS_GAMUT_ADJUST_TYPE_SW)
 		/* Bypass if type is bypass or hw */
@@ -201,20 +202,8 @@ void dpp1_cm_set_gamut_remap(
 		struct fixed31_32 arr_matrix[12];
 		uint16_t arr_reg_val[12];
 
-		arr_matrix[0] = adjust->temperature_matrix[0];
-		arr_matrix[1] = adjust->temperature_matrix[1];
-		arr_matrix[2] = adjust->temperature_matrix[2];
-		arr_matrix[3] = dal_fixed31_32_zero;
-
-		arr_matrix[4] = adjust->temperature_matrix[3];
-		arr_matrix[5] = adjust->temperature_matrix[4];
-		arr_matrix[6] = adjust->temperature_matrix[5];
-		arr_matrix[7] = dal_fixed31_32_zero;
-
-		arr_matrix[8] = adjust->temperature_matrix[6];
-		arr_matrix[9] = adjust->temperature_matrix[7];
-		arr_matrix[10] = adjust->temperature_matrix[8];
-		arr_matrix[11] = dal_fixed31_32_zero;
+		for (i = 0; i < 12; i++)
+			arr_matrix[i] = adjust->temperature_matrix[i];
 
 		convert_float_matrix(
 			arr_reg_val, arr_matrix, 12);

commit 38cb3e96e0c4362194aab662b424e89da8755561
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Fri Dec 1 11:42:18 2017 -0600

    drm/amd/display: Declare and share color space types for dcn's
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 4f5125398bbc..a5b099023652 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -225,18 +225,18 @@ void dpp1_cm_set_gamut_remap(
 
 static void dpp1_cm_program_color_matrix(
 		struct dcn10_dpp *dpp,
-		const struct out_csc_color_matrix *tbl_entry)
+		const uint16_t *regval)
 {
 	uint32_t mode;
 	struct color_matrices_reg gam_regs;
 
 	REG_GET(CM_OCSC_CONTROL, CM_OCSC_MODE, &mode);
 
-	if (tbl_entry == NULL) {
+	if (regval == NULL) {
 		BREAK_TO_DEBUGGER();
 		return;
 	}
-
+	mode = 4;
 	gam_regs.shifts.csc_c11 = dpp->tf_shift->CM_OCSC_C11;
 	gam_regs.masks.csc_c11  = dpp->tf_mask->CM_OCSC_C11;
 	gam_regs.shifts.csc_c12 = dpp->tf_shift->CM_OCSC_C12;
@@ -249,7 +249,7 @@ static void dpp1_cm_program_color_matrix(
 
 		cm_helper_program_color_matrices(
 				dpp->base.ctx,
-				tbl_entry->regval,
+				regval,
 				&gam_regs);
 
 	} else {
@@ -259,7 +259,7 @@ static void dpp1_cm_program_color_matrix(
 
 		cm_helper_program_color_matrices(
 				dpp->base.ctx,
-				tbl_entry->regval,
+				regval,
 				&gam_regs);
 	}
 }
@@ -268,24 +268,18 @@ void dpp1_cm_set_output_csc_default(
 		struct dpp *dpp_base,
 		enum dc_color_space colorspace)
 {
-
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
-	struct out_csc_color_matrix tbl_entry;
-	int i, j;
-	int arr_size = NUM_ELEMENTS(output_csc_matrix);
+	const uint16_t *regval = NULL;
+	int arr_size;
 	uint32_t ocsc_mode = 4;
 
-	tbl_entry.color_space = colorspace;
-
-	for (i = 0; i < arr_size; i++)
-		if (output_csc_matrix[i].color_space == colorspace) {
-			for (j = 0; j < 12; j++)
-				tbl_entry.regval[j] = output_csc_matrix[i].regval[j];
-			break;
-		}
-
+	regval = find_color_matrix(colorspace, &arr_size);
+	if (regval == NULL) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+	dpp1_cm_program_color_matrix(dpp, regval);
 	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
-	dpp1_cm_program_color_matrix(dpp, &tbl_entry);
 }
 
 static void dpp1_cm_get_reg_field(
@@ -317,41 +311,12 @@ static void dpp1_cm_get_reg_field(
 
 void dpp1_cm_set_output_csc_adjustment(
 		struct dpp *dpp_base,
-		const struct out_csc_color_matrix *tbl_entry)
+		const uint16_t *regval)
 {
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
-	//enum csc_color_mode config = CSC_COLOR_MODE_GRAPHICS_OUTPUT_CSC;
 	uint32_t ocsc_mode = 4;
-
-	/**
-	*if (tbl_entry != NULL) {
-	*	switch (tbl_entry->color_space) {
-	*	case COLOR_SPACE_SRGB:
-	*	case COLOR_SPACE_2020_RGB_FULLRANGE:
-	*		ocsc_mode = 0;
-	*		break;
-	*	case COLOR_SPACE_SRGB_LIMITED:
-	*	case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
-	*		ocsc_mode = 1;
-	*		break;
-	*	case COLOR_SPACE_YCBCR601:
-	*	case COLOR_SPACE_YCBCR601_LIMITED:
-	*		ocsc_mode = 2;
-	*		break;
-	*	case COLOR_SPACE_YCBCR709:
-	*	case COLOR_SPACE_YCBCR709_LIMITED:
-	*	case COLOR_SPACE_2020_YCBCR:
-	*		ocsc_mode = 3;
-	*		break;
-	*	case COLOR_SPACE_UNKNOWN:
-	*	default:
-	*		break;
-	*	}
-	*}
-	*/
-
+	dpp1_cm_program_color_matrix(dpp, regval);
 	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
-	dpp1_cm_program_color_matrix(dpp, tbl_entry);
 }
 
 void dpp1_cm_power_on_regamma_lut(struct dpp *dpp_base,

commit 493942cd250c62f459f12a3a8a45639e360f4312
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Thu Nov 23 11:32:18 2017 -0500

    drm/amd/display: dpp clean up
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 4c90043e7b8c..4f5125398bbc 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -49,6 +49,8 @@
 #define FN(reg_name, field_name) \
 	dpp->tf_shift->field_name, dpp->tf_mask->field_name
 
+#define NUM_ELEMENTS(a) (sizeof(a) / sizeof((a)[0]))
+
 struct dcn10_input_csc_matrix {
 	enum dc_color_space color_space;
 	uint16_t regval[12];
@@ -270,7 +272,7 @@ void dpp1_cm_set_output_csc_default(
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	struct out_csc_color_matrix tbl_entry;
 	int i, j;
-	int arr_size = sizeof(output_csc_matrix) / sizeof(struct output_csc_matrix);
+	int arr_size = NUM_ELEMENTS(output_csc_matrix);
 	uint32_t ocsc_mode = 4;
 
 	tbl_entry.color_space = colorspace;

commit e56dc89b3c6619bb2c4985da13d6f0dfe2711397
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Mon Nov 13 14:55:07 2017 -0500

    drm/amd/display: move csc matrix to hw_shared
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index b601a00fff74..4c90043e7b8c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -117,32 +117,6 @@ static const struct dcn10_input_csc_matrix dcn10_input_csc_matrix[] = {
 						0x2568, 0x43ee, 0xdbb2} }
 };
 
-struct output_csc_matrix {
-	enum dc_color_space color_space;
-	uint16_t regval[12];
-};
-
-static const struct output_csc_matrix output_csc_matrix[] = {
-	{ COLOR_SPACE_SRGB,
-		{ 0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
-	{ COLOR_SPACE_SRGB_LIMITED,
-		{ 0x1B67, 0, 0, 0x201, 0, 0x1B67, 0, 0x201, 0, 0, 0x1B67, 0x201} },
-	{ COLOR_SPACE_YCBCR601,
-		{ 0xE04, 0xF444, 0xFDB9, 0x1004, 0x831, 0x1016, 0x320, 0x201, 0xFB45,
-				0xF6B7, 0xE04, 0x1004} },
-	{ COLOR_SPACE_YCBCR709,
-		{ 0xE04, 0xF345, 0xFEB7, 0x1004, 0x5D3, 0x1399, 0x1FA,
-				0x201, 0xFCCA, 0xF533, 0xE04, 0x1004} },
-
-	/* TODO: correct values below */
-	{ COLOR_SPACE_YCBCR601_LIMITED,
-		{ 0xE00, 0xF447, 0xFDB9, 0x1000, 0x991,
-				0x12C9, 0x3A6, 0x200, 0xFB47, 0xF6B9, 0xE00, 0x1000} },
-	{ COLOR_SPACE_YCBCR709_LIMITED,
-		{ 0xE00, 0xF349, 0xFEB7, 0x1000, 0x6CE, 0x16E3,
-				0x24F, 0x200, 0xFCCB, 0xF535, 0xE00, 0x1000} },
-};
-
 static void program_gamut_remap(
 		struct dcn10_dpp *dpp,
 		const uint16_t *regval,

commit 4a43586bac9ae1d092d23c1cfe937cf05caa4c0d
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Thu Nov 9 17:03:00 2017 -0500

    drm/amd/display: update output csc matrix values
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index b5541985e0d8..b601a00fff74 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -123,29 +123,26 @@ struct output_csc_matrix {
 };
 
 static const struct output_csc_matrix output_csc_matrix[] = {
-		{ COLOR_SPACE_SRGB,
+	{ COLOR_SPACE_SRGB,
 		{ 0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
-		{ COLOR_SPACE_SRGB_LIMITED,
-		{ 0x1B60, 0, 0, 0x200, 0, 0x1B60, 0, 0x200, 0, 0, 0x1B60, 0x200} },
-		{ COLOR_SPACE_YCBCR601,
-		{ 0xE00, 0xF447, 0xFDB9, 0x1000, 0x82F, 0x1012, 0x31F, 0x200, 0xFB47,
-		0xF6B9, 0xE00, 0x1000} },
-		{ COLOR_SPACE_YCBCR709,
-		{ 0xE00, 0xF349, 0xFEB7, 0x1000, 0x5D2, 0x1394, 0x1FA,
-		0x200, 0xFCCB, 0xF535, 0xE00, 0x1000} },
-
-		/* TODO: correct values below */
-		{ COLOR_SPACE_YCBCR601_LIMITED,
+	{ COLOR_SPACE_SRGB_LIMITED,
+		{ 0x1B67, 0, 0, 0x201, 0, 0x1B67, 0, 0x201, 0, 0, 0x1B67, 0x201} },
+	{ COLOR_SPACE_YCBCR601,
+		{ 0xE04, 0xF444, 0xFDB9, 0x1004, 0x831, 0x1016, 0x320, 0x201, 0xFB45,
+				0xF6B7, 0xE04, 0x1004} },
+	{ COLOR_SPACE_YCBCR709,
+		{ 0xE04, 0xF345, 0xFEB7, 0x1004, 0x5D3, 0x1399, 0x1FA,
+				0x201, 0xFCCA, 0xF533, 0xE04, 0x1004} },
+
+	/* TODO: correct values below */
+	{ COLOR_SPACE_YCBCR601_LIMITED,
 		{ 0xE00, 0xF447, 0xFDB9, 0x1000, 0x991,
-		0x12C9, 0x3A6, 0x200, 0xFB47, 0xF6B9, 0xE00, 0x1000} },
-		{ COLOR_SPACE_YCBCR709_LIMITED,
+				0x12C9, 0x3A6, 0x200, 0xFB47, 0xF6B9, 0xE00, 0x1000} },
+	{ COLOR_SPACE_YCBCR709_LIMITED,
 		{ 0xE00, 0xF349, 0xFEB7, 0x1000, 0x6CE, 0x16E3,
-		0x24F, 0x200, 0xFCCB, 0xF535, 0xE00, 0x1000} },
-		{ COLOR_SPACE_UNKNOWN,
-		{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }
+				0x24F, 0x200, 0xFCCB, 0xF535, 0xE00, 0x1000} },
 };
 
-
 static void program_gamut_remap(
 		struct dcn10_dpp *dpp,
 		const uint16_t *regval,

commit afbeb2638b0a983100a5e6591bd1b76ef45bf20c
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Wed Nov 1 16:48:52 2017 -0400

    drm/amd/display: call set_mpc_output_csc from hwsequencer
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index b4892f43cd77..b5541985e0d8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -117,6 +117,33 @@ static const struct dcn10_input_csc_matrix dcn10_input_csc_matrix[] = {
 						0x2568, 0x43ee, 0xdbb2} }
 };
 
+struct output_csc_matrix {
+	enum dc_color_space color_space;
+	uint16_t regval[12];
+};
+
+static const struct output_csc_matrix output_csc_matrix[] = {
+		{ COLOR_SPACE_SRGB,
+		{ 0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
+		{ COLOR_SPACE_SRGB_LIMITED,
+		{ 0x1B60, 0, 0, 0x200, 0, 0x1B60, 0, 0x200, 0, 0, 0x1B60, 0x200} },
+		{ COLOR_SPACE_YCBCR601,
+		{ 0xE00, 0xF447, 0xFDB9, 0x1000, 0x82F, 0x1012, 0x31F, 0x200, 0xFB47,
+		0xF6B9, 0xE00, 0x1000} },
+		{ COLOR_SPACE_YCBCR709,
+		{ 0xE00, 0xF349, 0xFEB7, 0x1000, 0x5D2, 0x1394, 0x1FA,
+		0x200, 0xFCCB, 0xF535, 0xE00, 0x1000} },
+
+		/* TODO: correct values below */
+		{ COLOR_SPACE_YCBCR601_LIMITED,
+		{ 0xE00, 0xF447, 0xFDB9, 0x1000, 0x991,
+		0x12C9, 0x3A6, 0x200, 0xFB47, 0xF6B9, 0xE00, 0x1000} },
+		{ COLOR_SPACE_YCBCR709_LIMITED,
+		{ 0xE00, 0xF349, 0xFEB7, 0x1000, 0x6CE, 0x16E3,
+		0x24F, 0x200, 0xFCCB, 0xF535, 0xE00, 0x1000} },
+		{ COLOR_SPACE_UNKNOWN,
+		{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }
+};
 
 
 static void program_gamut_remap(
@@ -223,68 +250,6 @@ void dpp1_cm_set_gamut_remap(
 	}
 }
 
-void dpp1_cm_set_output_csc_default(
-		struct dpp *dpp_base,
-		enum dc_color_space colorspace)
-{
-
-	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
-	uint32_t ocsc_mode = 0;
-
-	switch (colorspace) {
-		case COLOR_SPACE_SRGB:
-		case COLOR_SPACE_2020_RGB_FULLRANGE:
-			ocsc_mode = 0;
-			break;
-		case COLOR_SPACE_SRGB_LIMITED:
-		case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
-			ocsc_mode = 1;
-			break;
-		case COLOR_SPACE_YCBCR601:
-		case COLOR_SPACE_YCBCR601_LIMITED:
-			ocsc_mode = 2;
-			break;
-		case COLOR_SPACE_YCBCR709:
-		case COLOR_SPACE_YCBCR709_LIMITED:
-		case COLOR_SPACE_2020_YCBCR:
-			ocsc_mode = 3;
-			break;
-		case COLOR_SPACE_UNKNOWN:
-		default:
-			break;
-	}
-
-	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
-
-}
-
-static void dpp1_cm_get_reg_field(
-		struct dcn10_dpp *dpp,
-		struct xfer_func_reg *reg)
-{
-	reg->shifts.exp_region0_lut_offset = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET;
-	reg->masks.exp_region0_lut_offset = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET;
-	reg->shifts.exp_region0_num_segments = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;
-	reg->masks.exp_region0_num_segments = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;
-	reg->shifts.exp_region1_lut_offset = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET;
-	reg->masks.exp_region1_lut_offset = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET;
-	reg->shifts.exp_region1_num_segments = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;
-	reg->masks.exp_region1_num_segments = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;
-
-	reg->shifts.field_region_end = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_B;
-	reg->masks.field_region_end = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_B;
-	reg->shifts.field_region_end_slope = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B;
-	reg->masks.field_region_end_slope = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B;
-	reg->shifts.field_region_end_base = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_BASE_B;
-	reg->masks.field_region_end_base = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_BASE_B;
-	reg->shifts.field_region_linear_slope = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;
-	reg->masks.field_region_linear_slope = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;
-	reg->shifts.exp_region_start = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_START_B;
-	reg->masks.exp_region_start = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_START_B;
-	reg->shifts.exp_resion_start_segment = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B;
-	reg->masks.exp_resion_start_segment = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B;
-}
-
 static void dpp1_cm_program_color_matrix(
 		struct dcn10_dpp *dpp,
 		const struct out_csc_color_matrix *tbl_entry)
@@ -326,6 +291,57 @@ static void dpp1_cm_program_color_matrix(
 	}
 }
 
+void dpp1_cm_set_output_csc_default(
+		struct dpp *dpp_base,
+		enum dc_color_space colorspace)
+{
+
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
+	struct out_csc_color_matrix tbl_entry;
+	int i, j;
+	int arr_size = sizeof(output_csc_matrix) / sizeof(struct output_csc_matrix);
+	uint32_t ocsc_mode = 4;
+
+	tbl_entry.color_space = colorspace;
+
+	for (i = 0; i < arr_size; i++)
+		if (output_csc_matrix[i].color_space == colorspace) {
+			for (j = 0; j < 12; j++)
+				tbl_entry.regval[j] = output_csc_matrix[i].regval[j];
+			break;
+		}
+
+	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
+	dpp1_cm_program_color_matrix(dpp, &tbl_entry);
+}
+
+static void dpp1_cm_get_reg_field(
+		struct dcn10_dpp *dpp,
+		struct xfer_func_reg *reg)
+{
+	reg->shifts.exp_region0_lut_offset = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET;
+	reg->masks.exp_region0_lut_offset = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET;
+	reg->shifts.exp_region0_num_segments = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;
+	reg->masks.exp_region0_num_segments = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;
+	reg->shifts.exp_region1_lut_offset = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET;
+	reg->masks.exp_region1_lut_offset = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET;
+	reg->shifts.exp_region1_num_segments = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;
+	reg->masks.exp_region1_num_segments = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;
+
+	reg->shifts.field_region_end = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_B;
+	reg->masks.field_region_end = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_B;
+	reg->shifts.field_region_end_slope = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B;
+	reg->masks.field_region_end_slope = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B;
+	reg->shifts.field_region_end_base = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_BASE_B;
+	reg->masks.field_region_end_base = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_BASE_B;
+	reg->shifts.field_region_linear_slope = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;
+	reg->masks.field_region_linear_slope = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;
+	reg->shifts.exp_region_start = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_START_B;
+	reg->masks.exp_region_start = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_START_B;
+	reg->shifts.exp_resion_start_segment = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B;
+	reg->masks.exp_resion_start_segment = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B;
+}
+
 void dpp1_cm_set_output_csc_adjustment(
 		struct dpp *dpp_base,
 		const struct out_csc_color_matrix *tbl_entry)

commit bd1be8e894e4963595a35ebeff512dc63d3ee328
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Nov 1 14:31:58 2017 -0400

    drm/amd/display: A few more color indentation changes
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index bb430c0ec1b6..b4892f43cd77 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -365,34 +365,31 @@ void dpp1_cm_set_output_csc_adjustment(
 	dpp1_cm_program_color_matrix(dpp, tbl_entry);
 }
 
-void dpp1_cm_power_on_regamma_lut(
-	struct dpp *dpp_base,
-	bool power_on)
+void dpp1_cm_power_on_regamma_lut(struct dpp *dpp_base,
+				  bool power_on)
 {
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
+
 	REG_SET(CM_MEM_PWR_CTRL, 0,
-			RGAM_MEM_PWR_FORCE, power_on == true ? 0:1);
+		RGAM_MEM_PWR_FORCE, power_on == true ? 0:1);
 
 }
 
-void dpp1_cm_program_regamma_lut(
-		struct dpp *dpp_base,
-		const struct pwl_result_data *rgb,
-		uint32_t num)
+void dpp1_cm_program_regamma_lut(struct dpp *dpp_base,
+				 const struct pwl_result_data *rgb,
+				 uint32_t num)
 {
 	uint32_t i;
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
+
 	for (i = 0 ; i < num; i++) {
 		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].red_reg);
 		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].green_reg);
 		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].blue_reg);
 
-		REG_SET(CM_RGAM_LUT_DATA, 0,
-				CM_RGAM_LUT_DATA, rgb[i].delta_red_reg);
-		REG_SET(CM_RGAM_LUT_DATA, 0,
-				CM_RGAM_LUT_DATA, rgb[i].delta_green_reg);
-		REG_SET(CM_RGAM_LUT_DATA, 0,
-				CM_RGAM_LUT_DATA, rgb[i].delta_blue_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].delta_red_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].delta_green_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].delta_blue_reg);
 
 	}
 

commit ea826d640d8f3cb5b196b41283d41a16c24c013c
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Fri Oct 27 15:28:38 2017 -0400

    drm/amd/display: call set csc_default if enable adjustment is false
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 9cb44c90e746..bb430c0ec1b6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -225,14 +225,13 @@ void dpp1_cm_set_gamut_remap(
 
 void dpp1_cm_set_output_csc_default(
 		struct dpp *dpp_base,
-		const struct default_adjustment *default_adjust)
+		enum dc_color_space colorspace)
 {
 
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	uint32_t ocsc_mode = 0;
 
-	if (default_adjust != NULL) {
-		switch (default_adjust->out_color_space) {
+	switch (colorspace) {
 		case COLOR_SPACE_SRGB:
 		case COLOR_SPACE_2020_RGB_FULLRANGE:
 			ocsc_mode = 0;
@@ -253,7 +252,6 @@ void dpp1_cm_set_output_csc_default(
 		case COLOR_SPACE_UNKNOWN:
 		default:
 			break;
-		}
 	}
 
 	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);

commit de4a2967737114d426411a79781d9d81d0ff38d2
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Thu Oct 19 13:41:30 2017 -0400

    drm/amd/display: Apply VQ adjustments in MPO case
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 40627c244bf5..9cb44c90e746 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -473,7 +473,8 @@ void dpp1_cm_program_regamma_lutb_settings(
 void dpp1_program_input_csc(
 		struct dpp *dpp_base,
 		enum dc_color_space color_space,
-		enum dcn10_input_csc_select select)
+		enum dcn10_input_csc_select select,
+		const struct out_csc_color_matrix *tbl_entry)
 {
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	int i;
@@ -487,15 +488,19 @@ void dpp1_program_input_csc(
 		return;
 	}
 
-	for (i = 0; i < arr_size; i++)
-		if (dcn10_input_csc_matrix[i].color_space == color_space) {
-			regval = dcn10_input_csc_matrix[i].regval;
-			break;
+	if (tbl_entry == NULL) {
+		for (i = 0; i < arr_size; i++)
+			if (dcn10_input_csc_matrix[i].color_space == color_space) {
+				regval = dcn10_input_csc_matrix[i].regval;
+				break;
+			}
+
+		if (regval == NULL) {
+			BREAK_TO_DEBUGGER();
+			return;
 		}
-
-	if (regval == NULL) {
-		BREAK_TO_DEBUGGER();
-		return;
+	} else {
+		regval = tbl_entry->regval;
 	}
 
 	if (select == INPUT_CSC_SELECT_COMA)
@@ -530,6 +535,27 @@ void dpp1_program_input_csc(
 	}
 }
 
+//keep here for now, decide multi dce support later
+void dpp1_program_bias_and_scale(
+	struct dpp *dpp_base,
+	struct dc_bias_and_scale *params)
+{
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
+
+	REG_SET_2(CM_BNS_VALUES_R, 0,
+		CM_BNS_SCALE_R, params->scale_red,
+		CM_BNS_BIAS_R, params->bias_red);
+
+	REG_SET_2(CM_BNS_VALUES_G, 0,
+		CM_BNS_SCALE_G, params->scale_green,
+		CM_BNS_BIAS_G, params->bias_green);
+
+	REG_SET_2(CM_BNS_VALUES_B, 0,
+		CM_BNS_SCALE_B, params->scale_blue,
+		CM_BNS_BIAS_B, params->bias_blue);
+
+}
+
 /*program de gamma RAM B*/
 void dpp1_program_degamma_lutb_settings(
 		struct dpp *dpp_base,

commit bf5563ede9f254fba083c6b56e4ca8b836babb1d
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Nov 7 05:30:47 2017 +1000

    amdgpu/dc: fix indentation warning from smatch.
    
    This fixes all the current smatch:
    warn: inconsistent indenting
    
    Reviewed-by: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 7784001c3a17..40627c244bf5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -124,7 +124,7 @@ static void program_gamut_remap(
 		const uint16_t *regval,
 		enum gamut_remap_select select)
 {
-	 uint16_t selection = 0;
+	uint16_t selection = 0;
 	struct color_matrices_reg gam_regs;
 
 	if (regval == NULL || select == GAMUT_REMAP_BYPASS) {

commit d94585a06b8197a723787c6c5502872abcff0e8e
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Thu Oct 5 16:47:49 2017 -0400

    drm/amd/display: rename transform to dpp for dcn
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index f88fd2e2e0aa..7784001c3a17 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -40,14 +40,14 @@
 #define BLACK_OFFSET_CBCR  0x8000
 
 #define REG(reg)\
-	xfm->tf_regs->reg
+	dpp->tf_regs->reg
 
 #define CTX \
-	xfm->base.ctx
+	dpp->base.ctx
 
 #undef FN
 #define FN(reg_name, field_name) \
-	xfm->tf_shift->field_name, xfm->tf_mask->field_name
+	dpp->tf_shift->field_name, dpp->tf_mask->field_name
 
 struct dcn10_input_csc_matrix {
 	enum dc_color_space color_space;
@@ -120,7 +120,7 @@ static const struct dcn10_input_csc_matrix dcn10_input_csc_matrix[] = {
 
 
 static void program_gamut_remap(
-		struct dcn10_dpp *xfm,
+		struct dcn10_dpp *dpp,
 		const uint16_t *regval,
 		enum gamut_remap_select select)
 {
@@ -146,10 +146,10 @@ static void program_gamut_remap(
 		break;
 	}
 
-	gam_regs.shifts.csc_c11 = xfm->tf_shift->CM_GAMUT_REMAP_C11;
-	gam_regs.masks.csc_c11  = xfm->tf_mask->CM_GAMUT_REMAP_C11;
-	gam_regs.shifts.csc_c12 = xfm->tf_shift->CM_GAMUT_REMAP_C12;
-	gam_regs.masks.csc_c12 = xfm->tf_mask->CM_GAMUT_REMAP_C12;
+	gam_regs.shifts.csc_c11 = dpp->tf_shift->CM_GAMUT_REMAP_C11;
+	gam_regs.masks.csc_c11  = dpp->tf_mask->CM_GAMUT_REMAP_C11;
+	gam_regs.shifts.csc_c12 = dpp->tf_shift->CM_GAMUT_REMAP_C12;
+	gam_regs.masks.csc_c12 = dpp->tf_mask->CM_GAMUT_REMAP_C12;
 
 
 	if (select == GAMUT_REMAP_COEFF) {
@@ -157,7 +157,7 @@ static void program_gamut_remap(
 		gam_regs.csc_c33_c34 = REG(CM_GAMUT_REMAP_C33_C34);
 
 		cm_helper_program_color_matrices(
-				xfm->base.ctx,
+				dpp->base.ctx,
 				regval,
 				&gam_regs);
 
@@ -167,7 +167,7 @@ static void program_gamut_remap(
 		gam_regs.csc_c33_c34 = REG(CM_COMA_C33_C34);
 
 		cm_helper_program_color_matrices(
-				xfm->base.ctx,
+				dpp->base.ctx,
 				regval,
 				&gam_regs);
 
@@ -177,7 +177,7 @@ static void program_gamut_remap(
 		gam_regs.csc_c33_c34 = REG(CM_COMB_C33_C34);
 
 		cm_helper_program_color_matrices(
-				xfm->base.ctx,
+				dpp->base.ctx,
 				regval,
 				&gam_regs);
 	}
@@ -188,15 +188,15 @@ static void program_gamut_remap(
 
 }
 
-void dcn10_dpp_cm_set_gamut_remap(
-	struct transform *xfm,
-	const struct xfm_grph_csc_adjustment *adjust)
+void dpp1_cm_set_gamut_remap(
+	struct dpp *dpp_base,
+	const struct dpp_grph_csc_adjustment *adjust)
 {
-	struct dcn10_dpp *dcn_xfm = TO_DCN10_DPP(xfm);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	if (adjust->gamut_adjust_type != GRAPHICS_GAMUT_ADJUST_TYPE_SW)
 		/* Bypass if type is bypass or hw */
-		program_gamut_remap(dcn_xfm, NULL, GAMUT_REMAP_BYPASS);
+		program_gamut_remap(dpp, NULL, GAMUT_REMAP_BYPASS);
 	else {
 		struct fixed31_32 arr_matrix[12];
 		uint16_t arr_reg_val[12];
@@ -219,16 +219,16 @@ void dcn10_dpp_cm_set_gamut_remap(
 		convert_float_matrix(
 			arr_reg_val, arr_matrix, 12);
 
-		program_gamut_remap(dcn_xfm, arr_reg_val, GAMUT_REMAP_COEFF);
+		program_gamut_remap(dpp, arr_reg_val, GAMUT_REMAP_COEFF);
 	}
 }
 
-void dcn10_dpp_cm_set_output_csc_default(
-		struct transform *xfm_base,
+void dpp1_cm_set_output_csc_default(
+		struct dpp *dpp_base,
 		const struct default_adjustment *default_adjust)
 {
 
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	uint32_t ocsc_mode = 0;
 
 	if (default_adjust != NULL) {
@@ -260,35 +260,35 @@ void dcn10_dpp_cm_set_output_csc_default(
 
 }
 
-static void dcn10_dpp_cm_get_reg_field(
-		struct dcn10_dpp *xfm,
+static void dpp1_cm_get_reg_field(
+		struct dcn10_dpp *dpp,
 		struct xfer_func_reg *reg)
 {
-	reg->shifts.exp_region0_lut_offset = xfm->tf_shift->CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET;
-	reg->masks.exp_region0_lut_offset = xfm->tf_mask->CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET;
-	reg->shifts.exp_region0_num_segments = xfm->tf_shift->CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;
-	reg->masks.exp_region0_num_segments = xfm->tf_mask->CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;
-	reg->shifts.exp_region1_lut_offset = xfm->tf_shift->CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET;
-	reg->masks.exp_region1_lut_offset = xfm->tf_mask->CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET;
-	reg->shifts.exp_region1_num_segments = xfm->tf_shift->CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;
-	reg->masks.exp_region1_num_segments = xfm->tf_mask->CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;
-
-	reg->shifts.field_region_end = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_B;
-	reg->masks.field_region_end = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_B;
-	reg->shifts.field_region_end_slope = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B;
-	reg->masks.field_region_end_slope = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B;
-	reg->shifts.field_region_end_base = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_BASE_B;
-	reg->masks.field_region_end_base = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_BASE_B;
-	reg->shifts.field_region_linear_slope = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;
-	reg->masks.field_region_linear_slope = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;
-	reg->shifts.exp_region_start = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_START_B;
-	reg->masks.exp_region_start = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_START_B;
-	reg->shifts.exp_resion_start_segment = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B;
-	reg->masks.exp_resion_start_segment = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B;
+	reg->shifts.exp_region0_lut_offset = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET;
+	reg->masks.exp_region0_lut_offset = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET;
+	reg->shifts.exp_region0_num_segments = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;
+	reg->masks.exp_region0_num_segments = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;
+	reg->shifts.exp_region1_lut_offset = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET;
+	reg->masks.exp_region1_lut_offset = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET;
+	reg->shifts.exp_region1_num_segments = dpp->tf_shift->CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;
+	reg->masks.exp_region1_num_segments = dpp->tf_mask->CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;
+
+	reg->shifts.field_region_end = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_B;
+	reg->masks.field_region_end = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_B;
+	reg->shifts.field_region_end_slope = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B;
+	reg->masks.field_region_end_slope = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B;
+	reg->shifts.field_region_end_base = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_BASE_B;
+	reg->masks.field_region_end_base = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_BASE_B;
+	reg->shifts.field_region_linear_slope = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;
+	reg->masks.field_region_linear_slope = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;
+	reg->shifts.exp_region_start = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_START_B;
+	reg->masks.exp_region_start = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_START_B;
+	reg->shifts.exp_resion_start_segment = dpp->tf_shift->CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B;
+	reg->masks.exp_resion_start_segment = dpp->tf_mask->CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B;
 }
 
-static void dcn10_dpp_cm_program_color_matrix(
-		struct dcn10_dpp *xfm,
+static void dpp1_cm_program_color_matrix(
+		struct dcn10_dpp *dpp,
 		const struct out_csc_color_matrix *tbl_entry)
 {
 	uint32_t mode;
@@ -301,10 +301,10 @@ static void dcn10_dpp_cm_program_color_matrix(
 		return;
 	}
 
-	gam_regs.shifts.csc_c11 = xfm->tf_shift->CM_OCSC_C11;
-	gam_regs.masks.csc_c11  = xfm->tf_mask->CM_OCSC_C11;
-	gam_regs.shifts.csc_c12 = xfm->tf_shift->CM_OCSC_C12;
-	gam_regs.masks.csc_c12 = xfm->tf_mask->CM_OCSC_C12;
+	gam_regs.shifts.csc_c11 = dpp->tf_shift->CM_OCSC_C11;
+	gam_regs.masks.csc_c11  = dpp->tf_mask->CM_OCSC_C11;
+	gam_regs.shifts.csc_c12 = dpp->tf_shift->CM_OCSC_C12;
+	gam_regs.masks.csc_c12 = dpp->tf_mask->CM_OCSC_C12;
 
 	if (mode == 4) {
 
@@ -312,7 +312,7 @@ static void dcn10_dpp_cm_program_color_matrix(
 		gam_regs.csc_c33_c34 = REG(CM_OCSC_C33_C34);
 
 		cm_helper_program_color_matrices(
-				xfm->base.ctx,
+				dpp->base.ctx,
 				tbl_entry->regval,
 				&gam_regs);
 
@@ -322,17 +322,17 @@ static void dcn10_dpp_cm_program_color_matrix(
 		gam_regs.csc_c33_c34 = REG(CM_COMB_C33_C34);
 
 		cm_helper_program_color_matrices(
-				xfm->base.ctx,
+				dpp->base.ctx,
 				tbl_entry->regval,
 				&gam_regs);
 	}
 }
 
-void dcn10_dpp_cm_set_output_csc_adjustment(
-		struct transform *xfm_base,
+void dpp1_cm_set_output_csc_adjustment(
+		struct dpp *dpp_base,
 		const struct out_csc_color_matrix *tbl_entry)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	//enum csc_color_mode config = CSC_COLOR_MODE_GRAPHICS_OUTPUT_CSC;
 	uint32_t ocsc_mode = 4;
 
@@ -364,26 +364,26 @@ void dcn10_dpp_cm_set_output_csc_adjustment(
 	*/
 
 	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
-	dcn10_dpp_cm_program_color_matrix(xfm, tbl_entry);
+	dpp1_cm_program_color_matrix(dpp, tbl_entry);
 }
 
-void dcn10_dpp_cm_power_on_regamma_lut(
-	struct transform *xfm_base,
+void dpp1_cm_power_on_regamma_lut(
+	struct dpp *dpp_base,
 	bool power_on)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	REG_SET(CM_MEM_PWR_CTRL, 0,
 			RGAM_MEM_PWR_FORCE, power_on == true ? 0:1);
 
 }
 
-void dcn10_dpp_cm_program_regamma_lut(
-		struct transform *xfm_base,
+void dpp1_cm_program_regamma_lut(
+		struct dpp *dpp_base,
 		const struct pwl_result_data *rgb,
 		uint32_t num)
 {
 	uint32_t i;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	for (i = 0 ; i < num; i++) {
 		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].red_reg);
 		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].green_reg);
@@ -400,11 +400,11 @@ void dcn10_dpp_cm_program_regamma_lut(
 
 }
 
-void dcn10_dpp_cm_configure_regamma_lut(
-		struct transform *xfm_base,
+void dpp1_cm_configure_regamma_lut(
+		struct dpp *dpp_base,
 		bool is_ram_a)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
 			CM_RGAM_LUT_WRITE_EN_MASK, 7);
@@ -414,14 +414,14 @@ void dcn10_dpp_cm_configure_regamma_lut(
 }
 
 /*program re gamma RAM A*/
-void dcn10_dpp_cm_program_regamma_luta_settings(
-		struct transform *xfm_base,
+void dpp1_cm_program_regamma_luta_settings(
+		struct dpp *dpp_base,
 		const struct pwl_params *params)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	struct xfer_func_reg gam_regs;
 
-	dcn10_dpp_cm_get_reg_field(xfm, &gam_regs);
+	dpp1_cm_get_reg_field(dpp, &gam_regs);
 
 	gam_regs.start_cntl_b = REG(CM_RGAM_RAMA_START_CNTL_B);
 	gam_regs.start_cntl_g = REG(CM_RGAM_RAMA_START_CNTL_G);
@@ -438,19 +438,19 @@ void dcn10_dpp_cm_program_regamma_luta_settings(
 	gam_regs.region_start = REG(CM_RGAM_RAMA_REGION_0_1);
 	gam_regs.region_end = REG(CM_RGAM_RAMA_REGION_32_33);
 
-	cm_helper_program_xfer_func(xfm->base.ctx, params, &gam_regs);
+	cm_helper_program_xfer_func(dpp->base.ctx, params, &gam_regs);
 
 }
 
 /*program re gamma RAM B*/
-void dcn10_dpp_cm_program_regamma_lutb_settings(
-		struct transform *xfm_base,
+void dpp1_cm_program_regamma_lutb_settings(
+		struct dpp *dpp_base,
 		const struct pwl_params *params)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	struct xfer_func_reg gam_regs;
 
-	dcn10_dpp_cm_get_reg_field(xfm, &gam_regs);
+	dpp1_cm_get_reg_field(dpp, &gam_regs);
 
 	gam_regs.start_cntl_b = REG(CM_RGAM_RAMB_START_CNTL_B);
 	gam_regs.start_cntl_g = REG(CM_RGAM_RAMB_START_CNTL_G);
@@ -467,15 +467,15 @@ void dcn10_dpp_cm_program_regamma_lutb_settings(
 	gam_regs.region_start = REG(CM_RGAM_RAMB_REGION_0_1);
 	gam_regs.region_end = REG(CM_RGAM_RAMB_REGION_32_33);
 
-	cm_helper_program_xfer_func(xfm->base.ctx, params, &gam_regs);
+	cm_helper_program_xfer_func(dpp->base.ctx, params, &gam_regs);
 }
 
-void ippn10_program_input_csc(
-		struct transform *xfm_base,
+void dpp1_program_input_csc(
+		struct dpp *dpp_base,
 		enum dc_color_space color_space,
 		enum dcn10_input_csc_select select)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	int i;
 	int arr_size = sizeof(dcn10_input_csc_matrix)/sizeof(struct dcn10_input_csc_matrix);
 	const uint16_t *regval = NULL;
@@ -503,10 +503,10 @@ void ippn10_program_input_csc(
 	REG_SET(CM_ICSC_CONTROL, 0,
 			CM_ICSC_MODE, selection);
 
-	gam_regs.shifts.csc_c11 = xfm->tf_shift->CM_ICSC_C11;
-	gam_regs.masks.csc_c11  = xfm->tf_mask->CM_ICSC_C11;
-	gam_regs.shifts.csc_c12 = xfm->tf_shift->CM_ICSC_C12;
-	gam_regs.masks.csc_c12 = xfm->tf_mask->CM_ICSC_C12;
+	gam_regs.shifts.csc_c11 = dpp->tf_shift->CM_ICSC_C11;
+	gam_regs.masks.csc_c11  = dpp->tf_mask->CM_ICSC_C11;
+	gam_regs.shifts.csc_c12 = dpp->tf_shift->CM_ICSC_C12;
+	gam_regs.masks.csc_c12 = dpp->tf_mask->CM_ICSC_C12;
 
 
 	if (select == INPUT_CSC_SELECT_ICSC) {
@@ -515,7 +515,7 @@ void ippn10_program_input_csc(
 		gam_regs.csc_c33_c34 = REG(CM_ICSC_C33_C34);
 
 		cm_helper_program_color_matrices(
-				xfm->base.ctx,
+				dpp->base.ctx,
 				regval,
 				&gam_regs);
 	} else {
@@ -524,21 +524,21 @@ void ippn10_program_input_csc(
 		gam_regs.csc_c33_c34 = REG(CM_COMA_C33_C34);
 
 		cm_helper_program_color_matrices(
-				xfm->base.ctx,
+				dpp->base.ctx,
 				regval,
 				&gam_regs);
 	}
 }
 
 /*program de gamma RAM B*/
-void ippn10_program_degamma_lutb_settings(
-		struct transform *xfm_base,
+void dpp1_program_degamma_lutb_settings(
+		struct dpp *dpp_base,
 		const struct pwl_params *params)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	struct xfer_func_reg gam_regs;
 
-	dcn10_dpp_cm_get_reg_field(xfm, &gam_regs);
+	dpp1_cm_get_reg_field(dpp, &gam_regs);
 
 	gam_regs.start_cntl_b = REG(CM_DGAM_RAMB_START_CNTL_B);
 	gam_regs.start_cntl_g = REG(CM_DGAM_RAMB_START_CNTL_G);
@@ -556,18 +556,18 @@ void ippn10_program_degamma_lutb_settings(
 	gam_regs.region_end = REG(CM_DGAM_RAMB_REGION_14_15);
 
 
-	cm_helper_program_xfer_func(xfm->base.ctx, params, &gam_regs);
+	cm_helper_program_xfer_func(dpp->base.ctx, params, &gam_regs);
 }
 
 /*program de gamma RAM A*/
-void ippn10_program_degamma_luta_settings(
-		struct transform *xfm_base,
+void dpp1_program_degamma_luta_settings(
+		struct dpp *dpp_base,
 		const struct pwl_params *params)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	struct xfer_func_reg gam_regs;
 
-	dcn10_dpp_cm_get_reg_field(xfm, &gam_regs);
+	dpp1_cm_get_reg_field(dpp, &gam_regs);
 
 	gam_regs.start_cntl_b = REG(CM_DGAM_RAMA_START_CNTL_B);
 	gam_regs.start_cntl_g = REG(CM_DGAM_RAMA_START_CNTL_G);
@@ -584,34 +584,35 @@ void ippn10_program_degamma_luta_settings(
 	gam_regs.region_start = REG(CM_DGAM_RAMA_REGION_0_1);
 	gam_regs.region_end = REG(CM_DGAM_RAMA_REGION_14_15);
 
-	cm_helper_program_xfer_func(xfm->base.ctx, params, &gam_regs);
+	cm_helper_program_xfer_func(dpp->base.ctx, params, &gam_regs);
 }
 
-void ippn10_power_on_degamma_lut(
-		struct transform *xfm_base,
+void dpp1_power_on_degamma_lut(
+		struct dpp *dpp_base,
 	bool power_on)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	REG_SET(CM_MEM_PWR_CTRL, 0,
 			SHARED_MEM_PWR_DIS, power_on == true ? 0:1);
 
 }
 
-static void ippn10_enable_cm_block(
-		struct transform *xfm_base)
+static void dpp1_enable_cm_block(
+		struct dpp *dpp_base)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
+
 	REG_UPDATE(CM_CMOUT_CONTROL, CM_CMOUT_ROUND_TRUNC_MODE, 8);
 	REG_UPDATE(CM_CONTROL, CM_BYPASS_EN, 0);
 }
 
-void ippn10_set_degamma(
-		struct transform *xfm_base,
+void dpp1_set_degamma(
+		struct dpp *dpp_base,
 		enum ipp_degamma_mode mode)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	ippn10_enable_cm_block(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
+	dpp1_enable_cm_block(dpp_base);
 
 	switch (mode) {
 	case IPP_DEGAMMA_MODE_BYPASS:
@@ -630,11 +631,11 @@ void ippn10_set_degamma(
 	}
 }
 
-void ippn10_degamma_ram_select(
-		struct transform *xfm_base,
+void dpp1_degamma_ram_select(
+		struct dpp *dpp_base,
 							bool use_ram_a)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	if (use_ram_a)
 		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 3);
@@ -643,13 +644,13 @@ void ippn10_degamma_ram_select(
 
 }
 
-static bool ippn10_degamma_ram_inuse(
-		struct transform *xfm_base,
+static bool dpp1_degamma_ram_inuse(
+		struct dpp *dpp_base,
 							bool *ram_a_inuse)
 {
 	bool ret = false;
 	uint32_t status_reg = 0;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	REG_GET(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_DGAM_CONFIG_STATUS,
 			&status_reg);
@@ -664,15 +665,15 @@ static bool ippn10_degamma_ram_inuse(
 	return ret;
 }
 
-void ippn10_program_degamma_lut(
-		struct transform *xfm_base,
+void dpp1_program_degamma_lut(
+		struct dpp *dpp_base,
 		const struct pwl_result_data *rgb,
 		uint32_t num,
 		bool is_ram_a)
 {
 	uint32_t i;
 
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_HOST_EN, 0);
 	REG_UPDATE(CM_DGAM_LUT_WRITE_EN_MASK,
 				   CM_DGAM_LUT_WRITE_EN_MASK, 7);
@@ -694,27 +695,27 @@ void ippn10_program_degamma_lut(
 	}
 }
 
-void ippn10_set_degamma_pwl(struct transform *xfm_base,
+void dpp1_set_degamma_pwl(struct dpp *dpp_base,
 								 const struct pwl_params *params)
 {
 	bool is_ram_a = true;
 
-	ippn10_power_on_degamma_lut(xfm_base, true);
-	ippn10_enable_cm_block(xfm_base);
-	ippn10_degamma_ram_inuse(xfm_base, &is_ram_a);
+	dpp1_power_on_degamma_lut(dpp_base, true);
+	dpp1_enable_cm_block(dpp_base);
+	dpp1_degamma_ram_inuse(dpp_base, &is_ram_a);
 	if (is_ram_a == true)
-		ippn10_program_degamma_lutb_settings(xfm_base, params);
+		dpp1_program_degamma_lutb_settings(dpp_base, params);
 	else
-		ippn10_program_degamma_luta_settings(xfm_base, params);
+		dpp1_program_degamma_luta_settings(dpp_base, params);
 
-	ippn10_program_degamma_lut(xfm_base, params->rgb_resulted,
+	dpp1_program_degamma_lut(dpp_base, params->rgb_resulted,
 							params->hw_points_num, !is_ram_a);
-	ippn10_degamma_ram_select(xfm_base, !is_ram_a);
+	dpp1_degamma_ram_select(dpp_base, !is_ram_a);
 }
 
-void ippn10_full_bypass(struct transform *xfm_base)
+void dpp1_full_bypass(struct dpp *dpp_base)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	/* Input pixel format: ARGB8888 */
 	REG_SET(CNVC_SURFACE_PIXEL_FORMAT, 0,
@@ -727,19 +728,19 @@ void ippn10_full_bypass(struct transform *xfm_base)
 			FORMAT_EXPANSION_MODE, 0);
 
 	/* COLOR_KEYER_CONTROL.COLOR_KEYER_EN = 0 this should be default */
-	if (xfm->tf_mask->CM_BYPASS_EN)
+	if (dpp->tf_mask->CM_BYPASS_EN)
 		REG_SET(CM_CONTROL, 0, CM_BYPASS_EN, 1);
 
 	/* Setting degamma bypass for now */
 	REG_SET(CM_DGAM_CONTROL, 0, CM_DGAM_LUT_MODE, 0);
 }
 
-static bool ippn10_ingamma_ram_inuse(struct transform *xfm_base,
+static bool dpp1_ingamma_ram_inuse(struct dpp *dpp_base,
 							bool *ram_a_inuse)
 {
 	bool in_use = false;
 	uint32_t status_reg = 0;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	REG_GET(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_DGAM_CONFIG_STATUS,
 				&status_reg);
@@ -765,19 +766,19 @@ static bool ippn10_ingamma_ram_inuse(struct transform *xfm_base,
  * In the future, this function should support additional input gamma methods,
  * such as piecewise linear mapping, and input gamma bypass.
  */
-void ippn10_program_input_lut(
-		struct transform *xfm_base,
+void dpp1_program_input_lut(
+		struct dpp *dpp_base,
 		const struct dc_gamma *gamma)
 {
 	int i;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	bool rama_occupied = false;
 	uint32_t ram_num;
 	// Power on LUT memory.
 	REG_SET(CM_MEM_PWR_CTRL, 0, SHARED_MEM_PWR_DIS, 1);
-	ippn10_enable_cm_block(xfm_base);
+	dpp1_enable_cm_block(dpp_base);
 	// Determine whether to use RAM A or RAM B
-	ippn10_ingamma_ram_inuse(xfm_base, &rama_occupied);
+	dpp1_ingamma_ram_inuse(dpp_base, &rama_occupied);
 	if (!rama_occupied)
 		REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_SEL, 0);
 	else

commit 3411eac1a144ac5ad5a7ab994645724130bb2996
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Thu Oct 5 10:45:50 2017 -0500

    drm/amd/display: [RV] bug in cm programming
    
    When surface bigger then 10 bpc the output pixel
    does not match to the required value.Update CRC's.
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 61e2a8919e9c..f88fd2e2e0aa 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -602,7 +602,7 @@ static void ippn10_enable_cm_block(
 		struct transform *xfm_base)
 {
 	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-
+	REG_UPDATE(CM_CMOUT_CONTROL, CM_CMOUT_ROUND_TRUNC_MODE, 8);
 	REG_UPDATE(CM_CONTROL, CM_BYPASS_EN, 0);
 }
 

commit 024f0607cfed19a9f6082e4b94267544de4fc584
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Mon Sep 11 14:30:02 2017 -0400

    drm/amd/display: Refactor dcn10_dpp_cm_helper to dcn10_cm_common
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index d0e72acfc1d5..61e2a8919e9c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -29,8 +29,8 @@
 
 #include "reg_helper.h"
 #include "dcn10_dpp.h"
-#include "dcn10_dpp_cm_helper.h"
 #include "basics/conversion.h"
+#include "dcn10_cm_common.h"
 
 #define NUM_PHASES    64
 #define HORZ_MAX_TAPS 8

commit 264efa31835dd87af4e77e3a27090e60d4fe1511
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Thu Aug 31 16:04:24 2017 -0400

    drm/amd/display: remove output_format from ipp_setup
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 840dd0346782..d0e72acfc1d5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -727,11 +727,11 @@ void ippn10_full_bypass(struct transform *xfm_base)
 			FORMAT_EXPANSION_MODE, 0);
 
 	/* COLOR_KEYER_CONTROL.COLOR_KEYER_EN = 0 this should be default */
-	REG_SET(CM_CONTROL, 0, CM_BYPASS_EN, 1);
+	if (xfm->tf_mask->CM_BYPASS_EN)
+		REG_SET(CM_CONTROL, 0, CM_BYPASS_EN, 1);
 
 	/* Setting degamma bypass for now */
 	REG_SET(CM_DGAM_CONTROL, 0, CM_DGAM_LUT_MODE, 0);
-	REG_SET(CM_IGAM_CONTROL, 0, CM_IGAM_LUT_MODE, 0);
 }
 
 static bool ippn10_ingamma_ram_inuse(struct transform *xfm_base,

commit 83524646611381c4b0e31ffc5286cb05f8818aba
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Tue Aug 29 16:54:39 2017 -0400

    drm/amd/display: seperate dpp_cm_helper functions into new file
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index d698fccdef68..840dd0346782 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -29,6 +29,7 @@
 
 #include "reg_helper.h"
 #include "dcn10_dpp.h"
+#include "dcn10_dpp_cm_helper.h"
 #include "basics/conversion.h"
 
 #define NUM_PHASES    64
@@ -116,37 +117,7 @@ static const struct dcn10_input_csc_matrix dcn10_input_csc_matrix[] = {
 						0x2568, 0x43ee, 0xdbb2} }
 };
 
-static void dpp_cm_program_color_registers(
-		struct dcn10_dpp *xfm,
-		const uint16_t *regval,
-		uint32_t cm_reg_start,
-		uint32_t cm_reg_end)
-{
-	uint32_t reg_region_cur;
-	unsigned int i = 0;
-
-#undef REG
-#define REG(reg) reg
-
-	for (reg_region_cur = cm_reg_start;
-			reg_region_cur <= cm_reg_end;
-			reg_region_cur++) {
-
-		const uint16_t *regval0 = &(regval[2 * i]);
-		const uint16_t *regval1 = &(regval[(2 * i) + 1]);
 
-		REG_SET_2(reg_region_cur, 0,
-				CM_GAMUT_REMAP_C11, *regval0,
-				CM_GAMUT_REMAP_C12, *regval1);
-
-		i++;
-	}
-
-#undef REG
-#define REG(reg)\
-	xfm->tf_regs->reg
-
-}
 
 static void program_gamut_remap(
 		struct dcn10_dpp *xfm,
@@ -154,6 +125,7 @@ static void program_gamut_remap(
 		enum gamut_remap_select select)
 {
 	 uint16_t selection = 0;
+	struct color_matrices_reg gam_regs;
 
 	if (regval == NULL || select == GAMUT_REMAP_BYPASS) {
 		REG_SET(CM_GAMUT_REMAP_CONTROL, 0,
@@ -174,30 +146,40 @@ static void program_gamut_remap(
 		break;
 	}
 
+	gam_regs.shifts.csc_c11 = xfm->tf_shift->CM_GAMUT_REMAP_C11;
+	gam_regs.masks.csc_c11  = xfm->tf_mask->CM_GAMUT_REMAP_C11;
+	gam_regs.shifts.csc_c12 = xfm->tf_shift->CM_GAMUT_REMAP_C12;
+	gam_regs.masks.csc_c12 = xfm->tf_mask->CM_GAMUT_REMAP_C12;
+
 
 	if (select == GAMUT_REMAP_COEFF) {
+		gam_regs.csc_c11_c12 = REG(CM_GAMUT_REMAP_C11_C12);
+		gam_regs.csc_c33_c34 = REG(CM_GAMUT_REMAP_C33_C34);
 
-		dpp_cm_program_color_registers(
-				xfm,
+		cm_helper_program_color_matrices(
+				xfm->base.ctx,
 				regval,
-				REG(CM_GAMUT_REMAP_C11_C12),
-				REG(CM_GAMUT_REMAP_C33_C34));
+				&gam_regs);
 
 	} else  if (select == GAMUT_REMAP_COMA_COEFF) {
 
-		dpp_cm_program_color_registers(
-				xfm,
+		gam_regs.csc_c11_c12 = REG(CM_COMA_C11_C12);
+		gam_regs.csc_c33_c34 = REG(CM_COMA_C33_C34);
+
+		cm_helper_program_color_matrices(
+				xfm->base.ctx,
 				regval,
-				REG(CM_COMA_C11_C12),
-				REG(CM_COMA_C33_C34));
+				&gam_regs);
 
 	} else {
 
-		dpp_cm_program_color_registers(
-				xfm,
+		gam_regs.csc_c11_c12 = REG(CM_COMB_C11_C12);
+		gam_regs.csc_c33_c34 = REG(CM_COMB_C33_C34);
+
+		cm_helper_program_color_matrices(
+				xfm->base.ctx,
 				regval,
-				REG(CM_COMB_C11_C12),
-				REG(CM_COMB_C33_C34));
+				&gam_regs);
 	}
 
 	REG_SET(
@@ -278,11 +260,39 @@ void dcn10_dpp_cm_set_output_csc_default(
 
 }
 
+static void dcn10_dpp_cm_get_reg_field(
+		struct dcn10_dpp *xfm,
+		struct xfer_func_reg *reg)
+{
+	reg->shifts.exp_region0_lut_offset = xfm->tf_shift->CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET;
+	reg->masks.exp_region0_lut_offset = xfm->tf_mask->CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET;
+	reg->shifts.exp_region0_num_segments = xfm->tf_shift->CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;
+	reg->masks.exp_region0_num_segments = xfm->tf_mask->CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS;
+	reg->shifts.exp_region1_lut_offset = xfm->tf_shift->CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET;
+	reg->masks.exp_region1_lut_offset = xfm->tf_mask->CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET;
+	reg->shifts.exp_region1_num_segments = xfm->tf_shift->CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;
+	reg->masks.exp_region1_num_segments = xfm->tf_mask->CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS;
+
+	reg->shifts.field_region_end = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_B;
+	reg->masks.field_region_end = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_B;
+	reg->shifts.field_region_end_slope = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B;
+	reg->masks.field_region_end_slope = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B;
+	reg->shifts.field_region_end_base = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_END_BASE_B;
+	reg->masks.field_region_end_base = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_END_BASE_B;
+	reg->shifts.field_region_linear_slope = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;
+	reg->masks.field_region_linear_slope = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B;
+	reg->shifts.exp_region_start = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_START_B;
+	reg->masks.exp_region_start = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_START_B;
+	reg->shifts.exp_resion_start_segment = xfm->tf_shift->CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B;
+	reg->masks.exp_resion_start_segment = xfm->tf_mask->CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B;
+}
+
 static void dcn10_dpp_cm_program_color_matrix(
 		struct dcn10_dpp *xfm,
 		const struct out_csc_color_matrix *tbl_entry)
 {
 	uint32_t mode;
+	struct color_matrices_reg gam_regs;
 
 	REG_GET(CM_OCSC_CONTROL, CM_OCSC_MODE, &mode);
 
@@ -291,21 +301,30 @@ static void dcn10_dpp_cm_program_color_matrix(
 		return;
 	}
 
+	gam_regs.shifts.csc_c11 = xfm->tf_shift->CM_OCSC_C11;
+	gam_regs.masks.csc_c11  = xfm->tf_mask->CM_OCSC_C11;
+	gam_regs.shifts.csc_c12 = xfm->tf_shift->CM_OCSC_C12;
+	gam_regs.masks.csc_c12 = xfm->tf_mask->CM_OCSC_C12;
+
 	if (mode == 4) {
 
-		dpp_cm_program_color_registers(
-				xfm,
+		gam_regs.csc_c11_c12 = REG(CM_OCSC_C11_C12);
+		gam_regs.csc_c33_c34 = REG(CM_OCSC_C33_C34);
+
+		cm_helper_program_color_matrices(
+				xfm->base.ctx,
 				tbl_entry->regval,
-				REG(CM_OCSC_C11_C12),
-				REG(CM_OCSC_C33_C34));
+				&gam_regs);
 
 	} else {
 
-		dpp_cm_program_color_registers(
-				xfm,
+		gam_regs.csc_c11_c12 = REG(CM_COMB_C11_C12);
+		gam_regs.csc_c33_c34 = REG(CM_COMB_C33_C34);
+
+		cm_helper_program_color_matrices(
+				xfm->base.ctx,
 				tbl_entry->regval,
-				REG(CM_COMB_C11_C12),
-				REG(CM_COMB_C33_C34));
+				&gam_regs);
 	}
 }
 
@@ -394,101 +413,15 @@ void dcn10_dpp_cm_configure_regamma_lut(
 	REG_SET(CM_RGAM_LUT_INDEX, 0, CM_RGAM_LUT_INDEX, 0);
 }
 
-struct cm_gam_ram_reg {
-	uint32_t start_cntl_b;
-	uint32_t start_cntl_g;
-	uint32_t start_cntl_r;
-	uint32_t start_slope_cntl_b;
-	uint32_t start_slope_cntl_g;
-	uint32_t start_slope_cntl_r;
-	uint32_t start_end_cntl1_b;
-	uint32_t start_end_cntl2_b;
-	uint32_t start_end_cntl1_g;
-	uint32_t start_end_cntl2_g;
-	uint32_t start_end_cntl1_r;
-	uint32_t start_end_cntl2_r;
-	uint32_t region_start;
-	uint32_t region_end;
-};
-
-static void dpp_cm_program_region_lut(
-		struct transform *xfm_base,
-		const struct pwl_params *params,
-		const struct cm_gam_ram_reg *reg)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	uint32_t reg_region_cur;
-	unsigned int i = 0;
-
-#undef REG
-#define REG(reg) reg
-
-	REG_SET_2(reg->start_cntl_b, 0,
-		CM_RGAM_RAMA_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_B, 0);
-	REG_SET_2(reg->start_cntl_g, 0,
-		CM_RGAM_RAMA_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_G, 0);
-	REG_SET_2(reg->start_cntl_r, 0,
-		CM_RGAM_RAMA_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_R, 0);
-
-	REG_SET(reg->start_slope_cntl_b, 0,
-		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
-	REG_SET(reg->start_slope_cntl_g, 0,
-		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
-	REG_SET(reg->start_slope_cntl_r, 0,
-		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
-
-	REG_SET(reg->start_end_cntl1_b, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
-	REG_SET_2(reg->start_end_cntl2_b, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMA_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
-
-	REG_SET(reg->start_end_cntl1_g, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
-	REG_SET_2(reg->start_end_cntl2_g, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMA_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
-
-	REG_SET(reg->start_end_cntl1_r, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
-	REG_SET_2(reg->start_end_cntl2_r, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMA_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
-
-	for (reg_region_cur = reg->region_start;
-			reg_region_cur <= reg->region_end;
-			reg_region_cur++) {
-
-		const struct gamma_curve *curve0 = &(params->arr_curve_points[2 * i]);
-		const struct gamma_curve *curve1 = &(params->arr_curve_points[(2 * i) + 1]);
-
-		REG_SET_4(reg_region_cur, 0,
-			CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET, curve0->offset,
-			CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, curve0->segments_num,
-			CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET, curve1->offset,
-			CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, curve1->segments_num);
-
-		i++;
-	}
-
-#undef REG
-#define REG(reg)\
-	xfm->tf_regs->reg
-
-}
-
-
-
 /*program re gamma RAM A*/
 void dcn10_dpp_cm_program_regamma_luta_settings(
 		struct transform *xfm_base,
 		const struct pwl_params *params)
 {
 	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	struct cm_gam_ram_reg gam_regs;
+	struct xfer_func_reg gam_regs;
+
+	dcn10_dpp_cm_get_reg_field(xfm, &gam_regs);
 
 	gam_regs.start_cntl_b = REG(CM_RGAM_RAMA_START_CNTL_B);
 	gam_regs.start_cntl_g = REG(CM_RGAM_RAMA_START_CNTL_G);
@@ -505,7 +438,7 @@ void dcn10_dpp_cm_program_regamma_luta_settings(
 	gam_regs.region_start = REG(CM_RGAM_RAMA_REGION_0_1);
 	gam_regs.region_end = REG(CM_RGAM_RAMA_REGION_32_33);
 
-	dpp_cm_program_region_lut(xfm_base, params, &gam_regs);
+	cm_helper_program_xfer_func(xfm->base.ctx, params, &gam_regs);
 
 }
 
@@ -515,7 +448,9 @@ void dcn10_dpp_cm_program_regamma_lutb_settings(
 		const struct pwl_params *params)
 {
 	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	struct cm_gam_ram_reg gam_regs;
+	struct xfer_func_reg gam_regs;
+
+	dcn10_dpp_cm_get_reg_field(xfm, &gam_regs);
 
 	gam_regs.start_cntl_b = REG(CM_RGAM_RAMB_START_CNTL_B);
 	gam_regs.start_cntl_g = REG(CM_RGAM_RAMB_START_CNTL_G);
@@ -532,7 +467,7 @@ void dcn10_dpp_cm_program_regamma_lutb_settings(
 	gam_regs.region_start = REG(CM_RGAM_RAMB_REGION_0_1);
 	gam_regs.region_end = REG(CM_RGAM_RAMB_REGION_32_33);
 
-	dpp_cm_program_region_lut(xfm_base, params, &gam_regs);
+	cm_helper_program_xfer_func(xfm->base.ctx, params, &gam_regs);
 }
 
 void ippn10_program_input_csc(
@@ -545,6 +480,7 @@ void ippn10_program_input_csc(
 	int arr_size = sizeof(dcn10_input_csc_matrix)/sizeof(struct dcn10_input_csc_matrix);
 	const uint16_t *regval = NULL;
 	uint32_t selection = 1;
+	struct color_matrices_reg gam_regs;
 
 	if (select == INPUT_CSC_SELECT_BYPASS) {
 		REG_SET(CM_ICSC_CONTROL, 0, CM_ICSC_MODE, 0);
@@ -567,20 +503,30 @@ void ippn10_program_input_csc(
 	REG_SET(CM_ICSC_CONTROL, 0,
 			CM_ICSC_MODE, selection);
 
+	gam_regs.shifts.csc_c11 = xfm->tf_shift->CM_ICSC_C11;
+	gam_regs.masks.csc_c11  = xfm->tf_mask->CM_ICSC_C11;
+	gam_regs.shifts.csc_c12 = xfm->tf_shift->CM_ICSC_C12;
+	gam_regs.masks.csc_c12 = xfm->tf_mask->CM_ICSC_C12;
+
+
 	if (select == INPUT_CSC_SELECT_ICSC) {
 
-		dpp_cm_program_color_registers(
-				xfm,
+		gam_regs.csc_c11_c12 = REG(CM_ICSC_C11_C12);
+		gam_regs.csc_c33_c34 = REG(CM_ICSC_C33_C34);
+
+		cm_helper_program_color_matrices(
+				xfm->base.ctx,
 				regval,
-				REG(CM_ICSC_C11_C12),
-				REG(CM_ICSC_C33_C34));
+				&gam_regs);
 	} else {
 
-		dpp_cm_program_color_registers(
-				xfm,
+		gam_regs.csc_c11_c12 = REG(CM_COMA_C11_C12);
+		gam_regs.csc_c33_c34 = REG(CM_COMA_C33_C34);
+
+		cm_helper_program_color_matrices(
+				xfm->base.ctx,
 				regval,
-				REG(CM_COMA_C11_C12),
-				REG(CM_COMA_C33_C34));
+				&gam_regs);
 	}
 }
 
@@ -590,7 +536,9 @@ void ippn10_program_degamma_lutb_settings(
 		const struct pwl_params *params)
 {
 	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	struct cm_gam_ram_reg gam_regs;
+	struct xfer_func_reg gam_regs;
+
+	dcn10_dpp_cm_get_reg_field(xfm, &gam_regs);
 
 	gam_regs.start_cntl_b = REG(CM_DGAM_RAMB_START_CNTL_B);
 	gam_regs.start_cntl_g = REG(CM_DGAM_RAMB_START_CNTL_G);
@@ -607,7 +555,8 @@ void ippn10_program_degamma_lutb_settings(
 	gam_regs.region_start = REG(CM_DGAM_RAMB_REGION_0_1);
 	gam_regs.region_end = REG(CM_DGAM_RAMB_REGION_14_15);
 
-	dpp_cm_program_region_lut(xfm_base, params, &gam_regs);
+
+	cm_helper_program_xfer_func(xfm->base.ctx, params, &gam_regs);
 }
 
 /*program de gamma RAM A*/
@@ -616,7 +565,9 @@ void ippn10_program_degamma_luta_settings(
 		const struct pwl_params *params)
 {
 	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	struct cm_gam_ram_reg gam_regs;
+	struct xfer_func_reg gam_regs;
+
+	dcn10_dpp_cm_get_reg_field(xfm, &gam_regs);
 
 	gam_regs.start_cntl_b = REG(CM_DGAM_RAMA_START_CNTL_B);
 	gam_regs.start_cntl_g = REG(CM_DGAM_RAMA_START_CNTL_G);
@@ -633,7 +584,7 @@ void ippn10_program_degamma_luta_settings(
 	gam_regs.region_start = REG(CM_DGAM_RAMA_REGION_0_1);
 	gam_regs.region_end = REG(CM_DGAM_RAMA_REGION_14_15);
 
-	dpp_cm_program_region_lut(xfm_base, params, &gam_regs);
+	cm_helper_program_xfer_func(xfm->base.ctx, params, &gam_regs);
 }
 
 void ippn10_power_on_degamma_lut(

commit 7ad124cc23172a7a70d642adf8f5c99f6c974539
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Tue Aug 29 15:01:06 2017 -0400

    drm/amd/display: clean up cm register programming functions
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 01b1c0ee0110..d698fccdef68 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -50,7 +50,7 @@
 
 struct dcn10_input_csc_matrix {
 	enum dc_color_space color_space;
-	uint32_t regval[12];
+	uint16_t regval[12];
 };
 
 enum dcn10_coef_filter_type_sel {
@@ -116,6 +116,38 @@ static const struct dcn10_input_csc_matrix dcn10_input_csc_matrix[] = {
 						0x2568, 0x43ee, 0xdbb2} }
 };
 
+static void dpp_cm_program_color_registers(
+		struct dcn10_dpp *xfm,
+		const uint16_t *regval,
+		uint32_t cm_reg_start,
+		uint32_t cm_reg_end)
+{
+	uint32_t reg_region_cur;
+	unsigned int i = 0;
+
+#undef REG
+#define REG(reg) reg
+
+	for (reg_region_cur = cm_reg_start;
+			reg_region_cur <= cm_reg_end;
+			reg_region_cur++) {
+
+		const uint16_t *regval0 = &(regval[2 * i]);
+		const uint16_t *regval1 = &(regval[(2 * i) + 1]);
+
+		REG_SET_2(reg_region_cur, 0,
+				CM_GAMUT_REMAP_C11, *regval0,
+				CM_GAMUT_REMAP_C12, *regval1);
+
+		i++;
+	}
+
+#undef REG
+#define REG(reg)\
+	xfm->tf_regs->reg
+
+}
+
 static void program_gamut_remap(
 		struct dcn10_dpp *xfm,
 		const uint16_t *regval,
@@ -145,79 +177,27 @@ static void program_gamut_remap(
 
 	if (select == GAMUT_REMAP_COEFF) {
 
-		REG_SET_2(CM_GAMUT_REMAP_C11_C12, 0,
-				CM_GAMUT_REMAP_C11, regval[0],
-				CM_GAMUT_REMAP_C12, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_GAMUT_REMAP_C13_C14, 0,
-				CM_GAMUT_REMAP_C13, regval[0],
-				CM_GAMUT_REMAP_C14, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_GAMUT_REMAP_C21_C22, 0,
-				CM_GAMUT_REMAP_C21, regval[0],
-				CM_GAMUT_REMAP_C22, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_GAMUT_REMAP_C23_C24, 0,
-				CM_GAMUT_REMAP_C23, regval[0],
-				CM_GAMUT_REMAP_C24, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_GAMUT_REMAP_C31_C32, 0,
-				CM_GAMUT_REMAP_C31, regval[0],
-				CM_GAMUT_REMAP_C32, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_GAMUT_REMAP_C33_C34, 0,
-				CM_GAMUT_REMAP_C33, regval[0],
-				CM_GAMUT_REMAP_C34, regval[1]);
+		dpp_cm_program_color_registers(
+				xfm,
+				regval,
+				REG(CM_GAMUT_REMAP_C11_C12),
+				REG(CM_GAMUT_REMAP_C33_C34));
 
 	} else  if (select == GAMUT_REMAP_COMA_COEFF) {
-		REG_SET_2(CM_COMA_C11_C12, 0,
-				CM_COMA_C11, regval[0],
-				CM_COMA_C12, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMA_C13_C14, 0,
-				CM_COMA_C13, regval[0],
-				CM_COMA_C14, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMA_C21_C22, 0,
-				CM_COMA_C21, regval[0],
-				CM_COMA_C22, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMA_C23_C24, 0,
-				CM_COMA_C23, regval[0],
-				CM_COMA_C24, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMA_C31_C32, 0,
-				CM_COMA_C31, regval[0],
-				CM_COMA_C32, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMA_C33_C34, 0,
-				CM_COMA_C33, regval[0],
-				CM_COMA_C34, regval[1]);
+
+		dpp_cm_program_color_registers(
+				xfm,
+				regval,
+				REG(CM_COMA_C11_C12),
+				REG(CM_COMA_C33_C34));
 
 	} else {
-		REG_SET_2(CM_COMB_C11_C12, 0,
-				CM_COMB_C11, regval[0],
-				CM_COMB_C12, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMB_C13_C14, 0,
-				CM_COMB_C13, regval[0],
-				CM_COMB_C14, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMB_C21_C22, 0,
-				CM_COMB_C21, regval[0],
-				CM_COMB_C22, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMB_C23_C24, 0,
-				CM_COMB_C23, regval[0],
-				CM_COMB_C24, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMB_C31_C32, 0,
-				CM_COMB_C31, regval[0],
-				CM_COMB_C32, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMB_C33_C34, 0,
-				CM_COMB_C33, regval[0],
-				CM_COMB_C34, regval[1]);
+
+		dpp_cm_program_color_registers(
+				xfm,
+				regval,
+				REG(CM_COMB_C11_C12),
+				REG(CM_COMB_C33_C34));
 	}
 
 	REG_SET(
@@ -312,59 +292,20 @@ static void dcn10_dpp_cm_program_color_matrix(
 	}
 
 	if (mode == 4) {
-		/*R*/
-		REG_SET_2(CM_OCSC_C11_C12, 0,
-			CM_OCSC_C11, tbl_entry->regval[0],
-			CM_OCSC_C12, tbl_entry->regval[1]);
-
-		REG_SET_2(CM_OCSC_C13_C14, 0,
-			CM_OCSC_C13, tbl_entry->regval[2],
-			CM_OCSC_C14, tbl_entry->regval[3]);
-
-		/*G*/
-		REG_SET_2(CM_OCSC_C21_C22, 0,
-			CM_OCSC_C21, tbl_entry->regval[4],
-			CM_OCSC_C22, tbl_entry->regval[5]);
-
-		REG_SET_2(CM_OCSC_C23_C24, 0,
-			CM_OCSC_C23, tbl_entry->regval[6],
-			CM_OCSC_C24, tbl_entry->regval[7]);
-
-		/*B*/
-		REG_SET_2(CM_OCSC_C31_C32, 0,
-			CM_OCSC_C31, tbl_entry->regval[8],
-			CM_OCSC_C32, tbl_entry->regval[9]);
-
-		REG_SET_2(CM_OCSC_C33_C34, 0,
-			CM_OCSC_C33, tbl_entry->regval[10],
-			CM_OCSC_C34, tbl_entry->regval[11]);
+
+		dpp_cm_program_color_registers(
+				xfm,
+				tbl_entry->regval,
+				REG(CM_OCSC_C11_C12),
+				REG(CM_OCSC_C33_C34));
+
 	} else {
-		/*R*/
-		REG_SET_2(CM_COMB_C11_C12, 0,
-			CM_COMB_C11, tbl_entry->regval[0],
-			CM_COMB_C12, tbl_entry->regval[1]);
-
-		REG_SET_2(CM_COMB_C13_C14, 0,
-			CM_COMB_C13, tbl_entry->regval[2],
-			CM_COMB_C14, tbl_entry->regval[3]);
-
-		/*G*/
-		REG_SET_2(CM_COMB_C21_C22, 0,
-			CM_COMB_C21, tbl_entry->regval[4],
-			CM_COMB_C22, tbl_entry->regval[5]);
-
-		REG_SET_2(CM_COMB_C23_C24, 0,
-			CM_COMB_C23, tbl_entry->regval[6],
-			CM_COMB_C24, tbl_entry->regval[7]);
-
-		/*B*/
-		REG_SET_2(CM_COMB_C31_C32, 0,
-			CM_COMB_C31, tbl_entry->regval[8],
-			CM_COMB_C32, tbl_entry->regval[9]);
-
-		REG_SET_2(CM_COMB_C33_C34, 0,
-			CM_COMB_C33, tbl_entry->regval[10],
-			CM_COMB_C34, tbl_entry->regval[11]);
+
+		dpp_cm_program_color_registers(
+				xfm,
+				tbl_entry->regval,
+				REG(CM_COMB_C11_C12),
+				REG(CM_COMB_C33_C34));
 	}
 }
 
@@ -602,7 +543,7 @@ void ippn10_program_input_csc(
 	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
 	int i;
 	int arr_size = sizeof(dcn10_input_csc_matrix)/sizeof(struct dcn10_input_csc_matrix);
-	const uint32_t *regval = NULL;
+	const uint16_t *regval = NULL;
 	uint32_t selection = 1;
 
 	if (select == INPUT_CSC_SELECT_BYPASS) {
@@ -627,59 +568,19 @@ void ippn10_program_input_csc(
 			CM_ICSC_MODE, selection);
 
 	if (select == INPUT_CSC_SELECT_ICSC) {
-		/*R*/
-		REG_SET_2(CM_ICSC_C11_C12, 0,
-			CM_ICSC_C11, regval[0],
-			CM_ICSC_C12, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_ICSC_C13_C14, 0,
-			CM_ICSC_C13, regval[0],
-			CM_ICSC_C14, regval[1]);
-		/*G*/
-		regval += 2;
-		REG_SET_2(CM_ICSC_C21_C22, 0,
-			CM_ICSC_C21, regval[0],
-			CM_ICSC_C22, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_ICSC_C23_C24, 0,
-			CM_ICSC_C23, regval[0],
-			CM_ICSC_C24, regval[1]);
-		/*B*/
-		regval += 2;
-		REG_SET_2(CM_ICSC_C31_C32, 0,
-			CM_ICSC_C31, regval[0],
-			CM_ICSC_C32, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_ICSC_C33_C34, 0,
-			CM_ICSC_C33, regval[0],
-			CM_ICSC_C34, regval[1]);
+
+		dpp_cm_program_color_registers(
+				xfm,
+				regval,
+				REG(CM_ICSC_C11_C12),
+				REG(CM_ICSC_C33_C34));
 	} else {
-		/*R*/
-		REG_SET_2(CM_COMA_C11_C12, 0,
-			CM_COMA_C11, regval[0],
-			CM_COMA_C12, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMA_C13_C14, 0,
-			CM_COMA_C13, regval[0],
-			CM_COMA_C14, regval[1]);
-		/*G*/
-		regval += 2;
-		REG_SET_2(CM_COMA_C21_C22, 0,
-			CM_COMA_C21, regval[0],
-			CM_COMA_C22, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMA_C23_C24, 0,
-			CM_COMA_C23, regval[0],
-			CM_COMA_C24, regval[1]);
-		/*B*/
-		regval += 2;
-		REG_SET_2(CM_COMA_C31_C32, 0,
-			CM_COMA_C31, regval[0],
-			CM_COMA_C32, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMA_C33_C34, 0,
-			CM_COMA_C33, regval[0],
-			CM_COMA_C34, regval[1]);
+
+		dpp_cm_program_color_registers(
+				xfm,
+				regval,
+				REG(CM_COMA_C11_C12),
+				REG(CM_COMA_C33_C34));
 	}
 }
 

commit b97a88cd569c5f1dac82654bee2efee07633921c
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Mon Aug 28 14:05:17 2017 -0400

    drm/amd/display: clean up functions in dcn10_dpp_cm
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 81620241a978..01b1c0ee0110 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -453,331 +453,145 @@ void dcn10_dpp_cm_configure_regamma_lut(
 	REG_SET(CM_RGAM_LUT_INDEX, 0, CM_RGAM_LUT_INDEX, 0);
 }
 
-/*program re gamma RAM A*/
-void dcn10_dpp_cm_program_regamma_luta_settings(
+struct cm_gam_ram_reg {
+	uint32_t start_cntl_b;
+	uint32_t start_cntl_g;
+	uint32_t start_cntl_r;
+	uint32_t start_slope_cntl_b;
+	uint32_t start_slope_cntl_g;
+	uint32_t start_slope_cntl_r;
+	uint32_t start_end_cntl1_b;
+	uint32_t start_end_cntl2_b;
+	uint32_t start_end_cntl1_g;
+	uint32_t start_end_cntl2_g;
+	uint32_t start_end_cntl1_r;
+	uint32_t start_end_cntl2_r;
+	uint32_t region_start;
+	uint32_t region_end;
+};
+
+static void dpp_cm_program_region_lut(
 		struct transform *xfm_base,
-		const struct pwl_params *params)
+		const struct pwl_params *params,
+		const struct cm_gam_ram_reg *reg)
 {
-	const struct gamma_curve *curve;
 	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	uint32_t reg_region_cur;
+	unsigned int i = 0;
+
+#undef REG
+#define REG(reg) reg
 
-	REG_SET_2(CM_RGAM_RAMA_START_CNTL_B, 0,
+	REG_SET_2(reg->start_cntl_b, 0,
 		CM_RGAM_RAMA_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
 		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_B, 0);
-	REG_SET_2(CM_RGAM_RAMA_START_CNTL_G, 0,
+	REG_SET_2(reg->start_cntl_g, 0,
 		CM_RGAM_RAMA_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
 		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_G, 0);
-	REG_SET_2(CM_RGAM_RAMA_START_CNTL_R, 0,
+	REG_SET_2(reg->start_cntl_r, 0,
 		CM_RGAM_RAMA_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
 		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_R, 0);
 
-	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_B, 0,
+	REG_SET(reg->start_slope_cntl_b, 0,
 		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
-	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_G, 0,
+	REG_SET(reg->start_slope_cntl_g, 0,
 		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
-	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_R, 0,
+	REG_SET(reg->start_slope_cntl_r, 0,
 		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
 
-	REG_SET(CM_RGAM_RAMA_END_CNTL1_B, 0,
+	REG_SET(reg->start_end_cntl1_b, 0,
 		CM_RGAM_RAMA_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_B, 0,
+	REG_SET_2(reg->start_end_cntl2_b, 0,
 		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
 		CM_RGAM_RAMA_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
 
-	REG_SET(CM_RGAM_RAMA_END_CNTL1_G, 0,
+	REG_SET(reg->start_end_cntl1_g, 0,
 		CM_RGAM_RAMA_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_G, 0,
+	REG_SET_2(reg->start_end_cntl2_g, 0,
 		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
 		CM_RGAM_RAMA_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
 
-	REG_SET(CM_RGAM_RAMA_END_CNTL1_R, 0,
+	REG_SET(reg->start_end_cntl1_r, 0,
 		CM_RGAM_RAMA_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_R, 0,
+	REG_SET_2(reg->start_end_cntl2_r, 0,
 		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
 		CM_RGAM_RAMA_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
 
-	curve = params->arr_curve_points;
-	REG_SET_4(CM_RGAM_RAMA_REGION_0_1, 0,
-		CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_2_3, 0,
-		CM_RGAM_RAMA_EXP_REGION2_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION3_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_4_5, 0,
-		CM_RGAM_RAMA_EXP_REGION4_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION5_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_6_7, 0,
-		CM_RGAM_RAMA_EXP_REGION6_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION7_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_8_9, 0,
-		CM_RGAM_RAMA_EXP_REGION8_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION9_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_10_11, 0,
-		CM_RGAM_RAMA_EXP_REGION10_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION11_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_12_13, 0,
-		CM_RGAM_RAMA_EXP_REGION12_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION13_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_14_15, 0,
-		CM_RGAM_RAMA_EXP_REGION14_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION15_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_16_17, 0,
-		CM_RGAM_RAMA_EXP_REGION16_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION17_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_18_19, 0,
-		CM_RGAM_RAMA_EXP_REGION18_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION19_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_20_21, 0,
-		CM_RGAM_RAMA_EXP_REGION20_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION21_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_22_23, 0,
-		CM_RGAM_RAMA_EXP_REGION22_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION23_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_24_25, 0,
-		CM_RGAM_RAMA_EXP_REGION24_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION25_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_26_27, 0,
-		CM_RGAM_RAMA_EXP_REGION26_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION27_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_28_29, 0,
-		CM_RGAM_RAMA_EXP_REGION28_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION29_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_30_31, 0,
-		CM_RGAM_RAMA_EXP_REGION30_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION31_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_32_33, 0,
-		CM_RGAM_RAMA_EXP_REGION32_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION33_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);
+	for (reg_region_cur = reg->region_start;
+			reg_region_cur <= reg->region_end;
+			reg_region_cur++) {
+
+		const struct gamma_curve *curve0 = &(params->arr_curve_points[2 * i]);
+		const struct gamma_curve *curve1 = &(params->arr_curve_points[(2 * i) + 1]);
+
+		REG_SET_4(reg_region_cur, 0,
+			CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET, curve0->offset,
+			CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, curve0->segments_num,
+			CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET, curve1->offset,
+			CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, curve1->segments_num);
+
+		i++;
+	}
+
+#undef REG
+#define REG(reg)\
+	xfm->tf_regs->reg
+
 }
 
-/*program re gamma RAM B*/
-void dcn10_dpp_cm_program_regamma_lutb_settings(
+
+
+/*program re gamma RAM A*/
+void dcn10_dpp_cm_program_regamma_luta_settings(
 		struct transform *xfm_base,
 		const struct pwl_params *params)
 {
-	const struct gamma_curve *curve;
 	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct cm_gam_ram_reg gam_regs;
+
+	gam_regs.start_cntl_b = REG(CM_RGAM_RAMA_START_CNTL_B);
+	gam_regs.start_cntl_g = REG(CM_RGAM_RAMA_START_CNTL_G);
+	gam_regs.start_cntl_r = REG(CM_RGAM_RAMA_START_CNTL_R);
+	gam_regs.start_slope_cntl_b = REG(CM_RGAM_RAMA_SLOPE_CNTL_B);
+	gam_regs.start_slope_cntl_g = REG(CM_RGAM_RAMA_SLOPE_CNTL_G);
+	gam_regs.start_slope_cntl_r = REG(CM_RGAM_RAMA_SLOPE_CNTL_R);
+	gam_regs.start_end_cntl1_b = REG(CM_RGAM_RAMA_END_CNTL1_B);
+	gam_regs.start_end_cntl2_b = REG(CM_RGAM_RAMA_END_CNTL2_B);
+	gam_regs.start_end_cntl1_g = REG(CM_RGAM_RAMA_END_CNTL1_G);
+	gam_regs.start_end_cntl2_g = REG(CM_RGAM_RAMA_END_CNTL2_G);
+	gam_regs.start_end_cntl1_r = REG(CM_RGAM_RAMA_END_CNTL1_R);
+	gam_regs.start_end_cntl2_r = REG(CM_RGAM_RAMA_END_CNTL2_R);
+	gam_regs.region_start = REG(CM_RGAM_RAMA_REGION_0_1);
+	gam_regs.region_end = REG(CM_RGAM_RAMA_REGION_32_33);
+
+	dpp_cm_program_region_lut(xfm_base, params, &gam_regs);
 
-	REG_SET_2(CM_RGAM_RAMB_START_CNTL_B, 0,
-		CM_RGAM_RAMB_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B, 0);
-	REG_SET_2(CM_RGAM_RAMB_START_CNTL_G, 0,
-		CM_RGAM_RAMB_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_G, 0);
-	REG_SET_2(CM_RGAM_RAMB_START_CNTL_R, 0,
-		CM_RGAM_RAMB_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_R, 0);
-
-	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_B, 0,
-		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
-	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_G, 0,
-		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
-	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_R, 0,
-		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
-
-	REG_SET(CM_RGAM_RAMB_END_CNTL1_B, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_B, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMB_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
-
-	REG_SET(CM_RGAM_RAMB_END_CNTL1_G, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_G, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMB_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
-
-	REG_SET(CM_RGAM_RAMB_END_CNTL1_R, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_R, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMB_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
-
-	curve = params->arr_curve_points;
-	REG_SET_4(CM_RGAM_RAMB_REGION_0_1, 0,
-		CM_RGAM_RAMB_EXP_REGION0_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION1_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_2_3, 0,
-		CM_RGAM_RAMB_EXP_REGION2_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION3_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_4_5, 0,
-		CM_RGAM_RAMB_EXP_REGION4_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION5_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_6_7, 0,
-		CM_RGAM_RAMB_EXP_REGION6_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION7_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_8_9, 0,
-		CM_RGAM_RAMB_EXP_REGION8_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION9_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_10_11, 0,
-		CM_RGAM_RAMB_EXP_REGION10_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION11_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_12_13, 0,
-		CM_RGAM_RAMB_EXP_REGION12_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION13_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_14_15, 0,
-		CM_RGAM_RAMB_EXP_REGION14_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION15_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_16_17, 0,
-		CM_RGAM_RAMB_EXP_REGION16_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION17_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_18_19, 0,
-		CM_RGAM_RAMB_EXP_REGION18_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION19_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_20_21, 0,
-		CM_RGAM_RAMB_EXP_REGION20_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION21_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_22_23, 0,
-		CM_RGAM_RAMB_EXP_REGION22_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION23_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_24_25, 0,
-		CM_RGAM_RAMB_EXP_REGION24_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION25_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_26_27, 0,
-		CM_RGAM_RAMB_EXP_REGION26_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION27_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_28_29, 0,
-		CM_RGAM_RAMB_EXP_REGION28_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION29_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_30_31, 0,
-		CM_RGAM_RAMB_EXP_REGION30_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION31_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_32_33, 0,
-		CM_RGAM_RAMB_EXP_REGION32_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION33_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);
+}
 
+/*program re gamma RAM B*/
+void dcn10_dpp_cm_program_regamma_lutb_settings(
+		struct transform *xfm_base,
+		const struct pwl_params *params)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct cm_gam_ram_reg gam_regs;
+
+	gam_regs.start_cntl_b = REG(CM_RGAM_RAMB_START_CNTL_B);
+	gam_regs.start_cntl_g = REG(CM_RGAM_RAMB_START_CNTL_G);
+	gam_regs.start_cntl_r = REG(CM_RGAM_RAMB_START_CNTL_R);
+	gam_regs.start_slope_cntl_b = REG(CM_RGAM_RAMB_SLOPE_CNTL_B);
+	gam_regs.start_slope_cntl_g = REG(CM_RGAM_RAMB_SLOPE_CNTL_G);
+	gam_regs.start_slope_cntl_r = REG(CM_RGAM_RAMB_SLOPE_CNTL_R);
+	gam_regs.start_end_cntl1_b = REG(CM_RGAM_RAMB_END_CNTL1_B);
+	gam_regs.start_end_cntl2_b = REG(CM_RGAM_RAMB_END_CNTL2_B);
+	gam_regs.start_end_cntl1_g = REG(CM_RGAM_RAMB_END_CNTL1_G);
+	gam_regs.start_end_cntl2_g = REG(CM_RGAM_RAMB_END_CNTL2_G);
+	gam_regs.start_end_cntl1_r = REG(CM_RGAM_RAMB_END_CNTL1_R);
+	gam_regs.start_end_cntl2_r = REG(CM_RGAM_RAMB_END_CNTL2_R);
+	gam_regs.region_start = REG(CM_RGAM_RAMB_REGION_0_1);
+	gam_regs.region_end = REG(CM_RGAM_RAMB_REGION_32_33);
+
+	dpp_cm_program_region_lut(xfm_base, params, &gam_regs);
 }
 
 void ippn10_program_input_csc(
@@ -874,106 +688,25 @@ void ippn10_program_degamma_lutb_settings(
 		struct transform *xfm_base,
 		const struct pwl_params *params)
 {
-	const struct gamma_curve *curve;
 	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-
-	REG_SET_2(CM_DGAM_RAMB_START_CNTL_B, 0,
-		CM_DGAM_RAMB_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
-		CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_B, 0);
-
-	REG_SET_2(CM_DGAM_RAMB_START_CNTL_G, 0,
-		CM_DGAM_RAMB_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
-		CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_G, 0);
-
-	REG_SET_2(CM_DGAM_RAMB_START_CNTL_R, 0,
-		CM_DGAM_RAMB_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
-		CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_R, 0);
-
-	REG_SET(CM_DGAM_RAMB_SLOPE_CNTL_B, 0,
-		CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
-
-	REG_SET(CM_DGAM_RAMB_SLOPE_CNTL_G, 0,
-		CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
-
-	REG_SET(CM_DGAM_RAMB_SLOPE_CNTL_R, 0,
-		CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
-
-	REG_SET(CM_DGAM_RAMB_END_CNTL1_B, 0,
-		CM_DGAM_RAMB_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
-
-	REG_SET_2(CM_DGAM_RAMB_END_CNTL2_B, 0,
-		CM_DGAM_RAMB_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_y,
-		CM_DGAM_RAMB_EXP_REGION_END_BASE_B, params->arr_points[2].custom_float_slope);
-
-	REG_SET(CM_DGAM_RAMB_END_CNTL1_G, 0,
-		CM_DGAM_RAMB_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
-
-	REG_SET_2(CM_DGAM_RAMB_END_CNTL2_G, 0,
-		CM_DGAM_RAMB_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_y,
-		CM_DGAM_RAMB_EXP_REGION_END_BASE_G, params->arr_points[2].custom_float_slope);
-
-	REG_SET(CM_DGAM_RAMB_END_CNTL1_R, 0,
-		CM_DGAM_RAMB_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
-
-	REG_SET_2(CM_DGAM_RAMB_END_CNTL2_R, 0,
-		CM_DGAM_RAMB_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_y,
-		CM_DGAM_RAMB_EXP_REGION_END_BASE_R, params->arr_points[2].custom_float_slope);
-
-	curve = params->arr_curve_points;
-	REG_SET_4(CM_DGAM_RAMB_REGION_0_1, 0,
-		CM_DGAM_RAMB_EXP_REGION0_LUT_OFFSET, curve[0].offset,
-		CM_DGAM_RAMB_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
-		CM_DGAM_RAMB_EXP_REGION1_LUT_OFFSET, 	curve[1].offset,
-		CM_DGAM_RAMB_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_DGAM_RAMB_REGION_2_3, 0,
-		CM_DGAM_RAMB_EXP_REGION2_LUT_OFFSET, curve[0].offset,
-		CM_DGAM_RAMB_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
-		CM_DGAM_RAMB_EXP_REGION3_LUT_OFFSET, curve[1].offset,
-		CM_DGAM_RAMB_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_DGAM_RAMB_REGION_4_5, 0,
-		CM_DGAM_RAMB_EXP_REGION4_LUT_OFFSET, curve[0].offset,
-		CM_DGAM_RAMB_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
-		CM_DGAM_RAMB_EXP_REGION5_LUT_OFFSET, curve[1].offset,
-		CM_DGAM_RAMB_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_DGAM_RAMB_REGION_6_7, 0,
-		CM_DGAM_RAMB_EXP_REGION6_LUT_OFFSET, curve[0].offset,
-		CM_DGAM_RAMB_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
-		CM_DGAM_RAMB_EXP_REGION7_LUT_OFFSET, curve[1].offset,
-		CM_DGAM_RAMB_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_DGAM_RAMB_REGION_8_9, 0,
-		CM_DGAM_RAMB_EXP_REGION8_LUT_OFFSET, curve[0].offset,
-		CM_DGAM_RAMB_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
-		CM_DGAM_RAMB_EXP_REGION9_LUT_OFFSET, curve[1].offset,
-		CM_DGAM_RAMB_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_DGAM_RAMB_REGION_10_11, 0,
-		CM_DGAM_RAMB_EXP_REGION10_LUT_OFFSET, curve[0].offset,
-		CM_DGAM_RAMB_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
-		CM_DGAM_RAMB_EXP_REGION11_LUT_OFFSET, curve[1].offset,
-		CM_DGAM_RAMB_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_DGAM_RAMB_REGION_12_13, 0,
-		CM_DGAM_RAMB_EXP_REGION12_LUT_OFFSET, curve[0].offset,
-		CM_DGAM_RAMB_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
-		CM_DGAM_RAMB_EXP_REGION13_LUT_OFFSET, curve[1].offset,
-		CM_DGAM_RAMB_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_DGAM_RAMB_REGION_14_15, 0,
-		CM_DGAM_RAMB_EXP_REGION14_LUT_OFFSET, curve[0].offset,
-		CM_DGAM_RAMB_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
-		CM_DGAM_RAMB_EXP_REGION15_LUT_OFFSET, curve[1].offset,
-		CM_DGAM_RAMB_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+	struct cm_gam_ram_reg gam_regs;
+
+	gam_regs.start_cntl_b = REG(CM_DGAM_RAMB_START_CNTL_B);
+	gam_regs.start_cntl_g = REG(CM_DGAM_RAMB_START_CNTL_G);
+	gam_regs.start_cntl_r = REG(CM_DGAM_RAMB_START_CNTL_R);
+	gam_regs.start_slope_cntl_b = REG(CM_DGAM_RAMB_SLOPE_CNTL_B);
+	gam_regs.start_slope_cntl_g = REG(CM_DGAM_RAMB_SLOPE_CNTL_G);
+	gam_regs.start_slope_cntl_r = REG(CM_DGAM_RAMB_SLOPE_CNTL_R);
+	gam_regs.start_end_cntl1_b = REG(CM_DGAM_RAMB_END_CNTL1_B);
+	gam_regs.start_end_cntl2_b = REG(CM_DGAM_RAMB_END_CNTL2_B);
+	gam_regs.start_end_cntl1_g = REG(CM_DGAM_RAMB_END_CNTL1_G);
+	gam_regs.start_end_cntl2_g = REG(CM_DGAM_RAMB_END_CNTL2_G);
+	gam_regs.start_end_cntl1_r = REG(CM_DGAM_RAMB_END_CNTL1_R);
+	gam_regs.start_end_cntl2_r = REG(CM_DGAM_RAMB_END_CNTL2_R);
+	gam_regs.region_start = REG(CM_DGAM_RAMB_REGION_0_1);
+	gam_regs.region_end = REG(CM_DGAM_RAMB_REGION_14_15);
+
+	dpp_cm_program_region_lut(xfm_base, params, &gam_regs);
 }
 
 /*program de gamma RAM A*/
@@ -981,106 +714,25 @@ void ippn10_program_degamma_luta_settings(
 		struct transform *xfm_base,
 		const struct pwl_params *params)
 {
-	const struct gamma_curve *curve;
 	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-
-	REG_SET_2(CM_DGAM_RAMA_START_CNTL_B, 0,
-		CM_DGAM_RAMA_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
-		CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_B, 0);
-
-	REG_SET_2(CM_DGAM_RAMA_START_CNTL_G, 0,
-		CM_DGAM_RAMA_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
-		CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_G, 0);
-
-	REG_SET_2(CM_DGAM_RAMA_START_CNTL_R, 0,
-		CM_DGAM_RAMA_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
-		CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_R, 0);
-
-	REG_SET(CM_DGAM_RAMA_SLOPE_CNTL_B, 0,
-		CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
-
-	REG_SET(CM_DGAM_RAMA_SLOPE_CNTL_G, 0,
-		CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
-
-	REG_SET(CM_DGAM_RAMA_SLOPE_CNTL_R, 0,
-		CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
-
-	REG_SET(CM_DGAM_RAMA_END_CNTL1_B, 0,
-		CM_DGAM_RAMA_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
-
-	REG_SET_2(CM_DGAM_RAMA_END_CNTL2_B, 0,
-		CM_DGAM_RAMA_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_y,
-		CM_DGAM_RAMA_EXP_REGION_END_BASE_B, params->arr_points[2].custom_float_slope);
-
-	REG_SET(CM_DGAM_RAMA_END_CNTL1_G, 0,
-		CM_DGAM_RAMA_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
-
-	REG_SET_2(CM_DGAM_RAMA_END_CNTL2_G, 0,
-		CM_DGAM_RAMA_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_y,
-		CM_DGAM_RAMA_EXP_REGION_END_BASE_G, params->arr_points[2].custom_float_slope);
-
-	REG_SET(CM_DGAM_RAMA_END_CNTL1_R, 0,
-		CM_DGAM_RAMA_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
-
-	REG_SET_2(CM_DGAM_RAMA_END_CNTL2_R, 0,
-		CM_DGAM_RAMA_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_y,
-		CM_DGAM_RAMA_EXP_REGION_END_BASE_R, params->arr_points[2].custom_float_slope);
-
-	curve = params->arr_curve_points;
-	REG_SET_4(CM_DGAM_RAMA_REGION_0_1, 0,
-		CM_DGAM_RAMA_EXP_REGION0_LUT_OFFSET, curve[0].offset,
-		CM_DGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
-		CM_DGAM_RAMA_EXP_REGION1_LUT_OFFSET, curve[1].offset,
-		CM_DGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_DGAM_RAMA_REGION_2_3, 0,
-		CM_DGAM_RAMA_EXP_REGION2_LUT_OFFSET, curve[0].offset,
-		CM_DGAM_RAMA_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
-		CM_DGAM_RAMA_EXP_REGION3_LUT_OFFSET, curve[1].offset,
-		CM_DGAM_RAMA_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_DGAM_RAMA_REGION_4_5, 0,
-		CM_DGAM_RAMA_EXP_REGION4_LUT_OFFSET, curve[0].offset,
-		CM_DGAM_RAMA_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
-		CM_DGAM_RAMA_EXP_REGION5_LUT_OFFSET, curve[1].offset,
-		CM_DGAM_RAMA_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_DGAM_RAMA_REGION_6_7, 0,
-		CM_DGAM_RAMA_EXP_REGION6_LUT_OFFSET, curve[0].offset,
-		CM_DGAM_RAMA_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
-		CM_DGAM_RAMA_EXP_REGION7_LUT_OFFSET, curve[1].offset,
-		CM_DGAM_RAMA_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_DGAM_RAMA_REGION_8_9, 0,
-		CM_DGAM_RAMA_EXP_REGION8_LUT_OFFSET, curve[0].offset,
-		CM_DGAM_RAMA_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
-		CM_DGAM_RAMA_EXP_REGION9_LUT_OFFSET, curve[1].offset,
-		CM_DGAM_RAMA_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_DGAM_RAMA_REGION_10_11, 0,
-		CM_DGAM_RAMA_EXP_REGION10_LUT_OFFSET, curve[0].offset,
-		CM_DGAM_RAMA_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
-		CM_DGAM_RAMA_EXP_REGION11_LUT_OFFSET, curve[1].offset,
-		CM_DGAM_RAMA_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_DGAM_RAMA_REGION_12_13, 0,
-		CM_DGAM_RAMA_EXP_REGION12_LUT_OFFSET, curve[0].offset,
-		CM_DGAM_RAMA_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
-		CM_DGAM_RAMA_EXP_REGION13_LUT_OFFSET, curve[1].offset,
-		CM_DGAM_RAMA_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_DGAM_RAMA_REGION_14_15, 0,
-		CM_DGAM_RAMA_EXP_REGION14_LUT_OFFSET, curve[0].offset,
-		CM_DGAM_RAMA_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
-		CM_DGAM_RAMA_EXP_REGION15_LUT_OFFSET, curve[1].offset,
-		CM_DGAM_RAMA_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+	struct cm_gam_ram_reg gam_regs;
+
+	gam_regs.start_cntl_b = REG(CM_DGAM_RAMA_START_CNTL_B);
+	gam_regs.start_cntl_g = REG(CM_DGAM_RAMA_START_CNTL_G);
+	gam_regs.start_cntl_r = REG(CM_DGAM_RAMA_START_CNTL_R);
+	gam_regs.start_slope_cntl_b = REG(CM_DGAM_RAMA_SLOPE_CNTL_B);
+	gam_regs.start_slope_cntl_g = REG(CM_DGAM_RAMA_SLOPE_CNTL_G);
+	gam_regs.start_slope_cntl_r = REG(CM_DGAM_RAMA_SLOPE_CNTL_R);
+	gam_regs.start_end_cntl1_b = REG(CM_DGAM_RAMA_END_CNTL1_B);
+	gam_regs.start_end_cntl2_b = REG(CM_DGAM_RAMA_END_CNTL2_B);
+	gam_regs.start_end_cntl1_g = REG(CM_DGAM_RAMA_END_CNTL1_G);
+	gam_regs.start_end_cntl2_g = REG(CM_DGAM_RAMA_END_CNTL2_G);
+	gam_regs.start_end_cntl1_r = REG(CM_DGAM_RAMA_END_CNTL1_R);
+	gam_regs.start_end_cntl2_r = REG(CM_DGAM_RAMA_END_CNTL2_R);
+	gam_regs.region_start = REG(CM_DGAM_RAMA_REGION_0_1);
+	gam_regs.region_end = REG(CM_DGAM_RAMA_REGION_14_15);
+
+	dpp_cm_program_region_lut(xfm_base, params, &gam_regs);
 }
 
 void ippn10_power_on_degamma_lut(

commit 9cffc573196bb3eea2d3dfd24893b6b9970cdfce
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Fri Aug 25 16:13:55 2017 -0400

    drm/amd/display: clean up header file includes
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 409462f29f54..81620241a978 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -27,10 +27,6 @@
 
 #include "core_types.h"
 
-#include "include/grph_object_id.h"
-#include "include/fixed31_32.h"
-#include "include/logger_interface.h"
-
 #include "reg_helper.h"
 #include "dcn10_dpp.h"
 #include "basics/conversion.h"
@@ -66,22 +62,6 @@ enum dcn10_coef_filter_type_sel {
 	SCL_COEF_ALPHA_HORZ_FILTER = 5
 };
 
-enum lb_memory_config {
-	/* Enable all 3 pieces of memory */
-	LB_MEMORY_CONFIG_0 = 0,
-
-	/* Enable only the first piece of memory */
-	LB_MEMORY_CONFIG_1 = 1,
-
-	/* Enable only the second piece of memory */
-	LB_MEMORY_CONFIG_2 = 2,
-
-	/* Only applicable in 4:2:0 mode, enable all 3 pieces of memory and the
-	 * last piece of chroma memory used for the luma storage
-	 */
-	LB_MEMORY_CONFIG_3 = 3
-};
-
 enum dscl_autocal_mode {
 	AUTOCAL_MODE_OFF = 0,
 

commit b3c340fad4643b7351a4777fae37e58925db04c9
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Sat Aug 19 16:34:36 2017 -0400

    drm/amd/display: move cm registers from ipp to dpp_cm
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 9ff283bff007..409462f29f54 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -52,6 +52,11 @@
 #define FN(reg_name, field_name) \
 	xfm->tf_shift->field_name, xfm->tf_mask->field_name
 
+struct dcn10_input_csc_matrix {
+	enum dc_color_space color_space;
+	uint32_t regval[12];
+};
+
 enum dcn10_coef_filter_type_sel {
 	SCL_COEF_LUMA_VERT_FILTER = 0,
 	SCL_COEF_LUMA_HORZ_FILTER = 1,
@@ -111,6 +116,26 @@ enum gamut_remap_select {
 	GAMUT_REMAP_COMB_COEFF
 };
 
+static const struct dcn10_input_csc_matrix dcn10_input_csc_matrix[] = {
+	{COLOR_SPACE_SRGB,
+		{0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
+	{COLOR_SPACE_SRGB_LIMITED,
+		{0x2000, 0, 0, 0, 0, 0x2000, 0, 0, 0, 0, 0x2000, 0} },
+	{COLOR_SPACE_YCBCR601,
+		{0x2cdd, 0x2000, 0, 0xe991, 0xe926, 0x2000, 0xf4fd, 0x10ef,
+						0, 0x2000, 0x38b4, 0xe3a6} },
+	{COLOR_SPACE_YCBCR601_LIMITED,
+		{0x3353, 0x2568, 0, 0xe400, 0xe5dc, 0x2568, 0xf367, 0x1108,
+						0, 0x2568, 0x40de, 0xdd3a} },
+	{COLOR_SPACE_YCBCR709,
+		{0x3265, 0x2000, 0, 0xe6ce, 0xf105, 0x2000, 0xfa01, 0xa7d, 0,
+						0x2000, 0x3b61, 0xe24f} },
+
+	{COLOR_SPACE_YCBCR709_LIMITED,
+		{0x39a6, 0x2568, 0, 0xe0d6, 0xeedd, 0x2568, 0xf925, 0x9a8, 0,
+						0x2568, 0x43ee, 0xdbb2} }
+};
+
 static void program_gamut_remap(
 		struct dcn10_dpp *xfm,
 		const uint16_t *regval,
@@ -774,3 +799,533 @@ void dcn10_dpp_cm_program_regamma_lutb_settings(
 		CM_RGAM_RAMB_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);
 
 }
+
+void ippn10_program_input_csc(
+		struct transform *xfm_base,
+		enum dc_color_space color_space,
+		enum dcn10_input_csc_select select)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	int i;
+	int arr_size = sizeof(dcn10_input_csc_matrix)/sizeof(struct dcn10_input_csc_matrix);
+	const uint32_t *regval = NULL;
+	uint32_t selection = 1;
+
+	if (select == INPUT_CSC_SELECT_BYPASS) {
+		REG_SET(CM_ICSC_CONTROL, 0, CM_ICSC_MODE, 0);
+		return;
+	}
+
+	for (i = 0; i < arr_size; i++)
+		if (dcn10_input_csc_matrix[i].color_space == color_space) {
+			regval = dcn10_input_csc_matrix[i].regval;
+			break;
+		}
+
+	if (regval == NULL) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	if (select == INPUT_CSC_SELECT_COMA)
+		selection = 2;
+	REG_SET(CM_ICSC_CONTROL, 0,
+			CM_ICSC_MODE, selection);
+
+	if (select == INPUT_CSC_SELECT_ICSC) {
+		/*R*/
+		REG_SET_2(CM_ICSC_C11_C12, 0,
+			CM_ICSC_C11, regval[0],
+			CM_ICSC_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_ICSC_C13_C14, 0,
+			CM_ICSC_C13, regval[0],
+			CM_ICSC_C14, regval[1]);
+		/*G*/
+		regval += 2;
+		REG_SET_2(CM_ICSC_C21_C22, 0,
+			CM_ICSC_C21, regval[0],
+			CM_ICSC_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_ICSC_C23_C24, 0,
+			CM_ICSC_C23, regval[0],
+			CM_ICSC_C24, regval[1]);
+		/*B*/
+		regval += 2;
+		REG_SET_2(CM_ICSC_C31_C32, 0,
+			CM_ICSC_C31, regval[0],
+			CM_ICSC_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_ICSC_C33_C34, 0,
+			CM_ICSC_C33, regval[0],
+			CM_ICSC_C34, regval[1]);
+	} else {
+		/*R*/
+		REG_SET_2(CM_COMA_C11_C12, 0,
+			CM_COMA_C11, regval[0],
+			CM_COMA_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C13_C14, 0,
+			CM_COMA_C13, regval[0],
+			CM_COMA_C14, regval[1]);
+		/*G*/
+		regval += 2;
+		REG_SET_2(CM_COMA_C21_C22, 0,
+			CM_COMA_C21, regval[0],
+			CM_COMA_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C23_C24, 0,
+			CM_COMA_C23, regval[0],
+			CM_COMA_C24, regval[1]);
+		/*B*/
+		regval += 2;
+		REG_SET_2(CM_COMA_C31_C32, 0,
+			CM_COMA_C31, regval[0],
+			CM_COMA_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C33_C34, 0,
+			CM_COMA_C33, regval[0],
+			CM_COMA_C34, regval[1]);
+	}
+}
+
+/*program de gamma RAM B*/
+void ippn10_program_degamma_lutb_settings(
+		struct transform *xfm_base,
+		const struct pwl_params *params)
+{
+	const struct gamma_curve *curve;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	REG_SET_2(CM_DGAM_RAMB_START_CNTL_B, 0,
+		CM_DGAM_RAMB_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_B, 0);
+
+	REG_SET_2(CM_DGAM_RAMB_START_CNTL_G, 0,
+		CM_DGAM_RAMB_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_G, 0);
+
+	REG_SET_2(CM_DGAM_RAMB_START_CNTL_R, 0,
+		CM_DGAM_RAMB_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMB_EXP_REGION_START_SEGMENT_R, 0);
+
+	REG_SET(CM_DGAM_RAMB_SLOPE_CNTL_B, 0,
+		CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMB_SLOPE_CNTL_G, 0,
+		CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMB_SLOPE_CNTL_R, 0,
+		CM_DGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMB_END_CNTL1_B, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMB_END_CNTL2_B, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMB_EXP_REGION_END_BASE_B, params->arr_points[2].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMB_END_CNTL1_G, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMB_END_CNTL2_G, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMB_EXP_REGION_END_BASE_G, params->arr_points[2].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMB_END_CNTL1_R, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMB_END_CNTL2_R, 0,
+		CM_DGAM_RAMB_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMB_EXP_REGION_END_BASE_R, params->arr_points[2].custom_float_slope);
+
+	curve = params->arr_curve_points;
+	REG_SET_4(CM_DGAM_RAMB_REGION_0_1, 0,
+		CM_DGAM_RAMB_EXP_REGION0_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION1_LUT_OFFSET, 	curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_2_3, 0,
+		CM_DGAM_RAMB_EXP_REGION2_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION3_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_4_5, 0,
+		CM_DGAM_RAMB_EXP_REGION4_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION5_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_6_7, 0,
+		CM_DGAM_RAMB_EXP_REGION6_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION7_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_8_9, 0,
+		CM_DGAM_RAMB_EXP_REGION8_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION9_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_10_11, 0,
+		CM_DGAM_RAMB_EXP_REGION10_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION11_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_12_13, 0,
+		CM_DGAM_RAMB_EXP_REGION12_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION13_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMB_REGION_14_15, 0,
+		CM_DGAM_RAMB_EXP_REGION14_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMB_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMB_EXP_REGION15_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMB_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+}
+
+/*program de gamma RAM A*/
+void ippn10_program_degamma_luta_settings(
+		struct transform *xfm_base,
+		const struct pwl_params *params)
+{
+	const struct gamma_curve *curve;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	REG_SET_2(CM_DGAM_RAMA_START_CNTL_B, 0,
+		CM_DGAM_RAMA_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_B, 0);
+
+	REG_SET_2(CM_DGAM_RAMA_START_CNTL_G, 0,
+		CM_DGAM_RAMA_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_G, 0);
+
+	REG_SET_2(CM_DGAM_RAMA_START_CNTL_R, 0,
+		CM_DGAM_RAMA_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
+		CM_DGAM_RAMA_EXP_REGION_START_SEGMENT_R, 0);
+
+	REG_SET(CM_DGAM_RAMA_SLOPE_CNTL_B, 0,
+		CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMA_SLOPE_CNTL_G, 0,
+		CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMA_SLOPE_CNTL_R, 0,
+		CM_DGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMA_END_CNTL1_B, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMA_END_CNTL2_B, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMA_EXP_REGION_END_BASE_B, params->arr_points[2].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMA_END_CNTL1_G, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMA_END_CNTL2_G, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMA_EXP_REGION_END_BASE_G, params->arr_points[2].custom_float_slope);
+
+	REG_SET(CM_DGAM_RAMA_END_CNTL1_R, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
+
+	REG_SET_2(CM_DGAM_RAMA_END_CNTL2_R, 0,
+		CM_DGAM_RAMA_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_y,
+		CM_DGAM_RAMA_EXP_REGION_END_BASE_R, params->arr_points[2].custom_float_slope);
+
+	curve = params->arr_curve_points;
+	REG_SET_4(CM_DGAM_RAMA_REGION_0_1, 0,
+		CM_DGAM_RAMA_EXP_REGION0_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION1_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_2_3, 0,
+		CM_DGAM_RAMA_EXP_REGION2_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION3_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_4_5, 0,
+		CM_DGAM_RAMA_EXP_REGION4_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION5_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_6_7, 0,
+		CM_DGAM_RAMA_EXP_REGION6_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION7_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_8_9, 0,
+		CM_DGAM_RAMA_EXP_REGION8_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION9_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_10_11, 0,
+		CM_DGAM_RAMA_EXP_REGION10_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION11_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_12_13, 0,
+		CM_DGAM_RAMA_EXP_REGION12_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION13_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_DGAM_RAMA_REGION_14_15, 0,
+		CM_DGAM_RAMA_EXP_REGION14_LUT_OFFSET, curve[0].offset,
+		CM_DGAM_RAMA_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
+		CM_DGAM_RAMA_EXP_REGION15_LUT_OFFSET, curve[1].offset,
+		CM_DGAM_RAMA_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+}
+
+void ippn10_power_on_degamma_lut(
+		struct transform *xfm_base,
+	bool power_on)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	REG_SET(CM_MEM_PWR_CTRL, 0,
+			SHARED_MEM_PWR_DIS, power_on == true ? 0:1);
+
+}
+
+static void ippn10_enable_cm_block(
+		struct transform *xfm_base)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	REG_UPDATE(CM_CONTROL, CM_BYPASS_EN, 0);
+}
+
+void ippn10_set_degamma(
+		struct transform *xfm_base,
+		enum ipp_degamma_mode mode)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	ippn10_enable_cm_block(xfm_base);
+
+	switch (mode) {
+	case IPP_DEGAMMA_MODE_BYPASS:
+		/* Setting de gamma bypass for now */
+		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 0);
+		break;
+	case IPP_DEGAMMA_MODE_HW_sRGB:
+		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 1);
+		break;
+	case IPP_DEGAMMA_MODE_HW_xvYCC:
+		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 2);
+			break;
+	default:
+		BREAK_TO_DEBUGGER();
+		break;
+	}
+}
+
+void ippn10_degamma_ram_select(
+		struct transform *xfm_base,
+							bool use_ram_a)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	if (use_ram_a)
+		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 3);
+	else
+		REG_UPDATE(CM_DGAM_CONTROL, CM_DGAM_LUT_MODE, 4);
+
+}
+
+static bool ippn10_degamma_ram_inuse(
+		struct transform *xfm_base,
+							bool *ram_a_inuse)
+{
+	bool ret = false;
+	uint32_t status_reg = 0;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	REG_GET(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_DGAM_CONFIG_STATUS,
+			&status_reg);
+
+	if (status_reg == 9) {
+		*ram_a_inuse = true;
+		ret = true;
+	} else if (status_reg == 10) {
+		*ram_a_inuse = false;
+		ret = true;
+	}
+	return ret;
+}
+
+void ippn10_program_degamma_lut(
+		struct transform *xfm_base,
+		const struct pwl_result_data *rgb,
+		uint32_t num,
+		bool is_ram_a)
+{
+	uint32_t i;
+
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_HOST_EN, 0);
+	REG_UPDATE(CM_DGAM_LUT_WRITE_EN_MASK,
+				   CM_DGAM_LUT_WRITE_EN_MASK, 7);
+	REG_UPDATE(CM_DGAM_LUT_WRITE_EN_MASK, CM_DGAM_LUT_WRITE_SEL,
+					is_ram_a == true ? 0:1);
+
+	REG_SET(CM_DGAM_LUT_INDEX, 0, CM_DGAM_LUT_INDEX, 0);
+	for (i = 0 ; i < num; i++) {
+		REG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].red_reg);
+		REG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].green_reg);
+		REG_SET(CM_DGAM_LUT_DATA, 0, CM_DGAM_LUT_DATA, rgb[i].blue_reg);
+
+		REG_SET(CM_DGAM_LUT_DATA, 0,
+				CM_DGAM_LUT_DATA, rgb[i].delta_red_reg);
+		REG_SET(CM_DGAM_LUT_DATA, 0,
+				CM_DGAM_LUT_DATA, rgb[i].delta_green_reg);
+		REG_SET(CM_DGAM_LUT_DATA, 0,
+				CM_DGAM_LUT_DATA, rgb[i].delta_blue_reg);
+	}
+}
+
+void ippn10_set_degamma_pwl(struct transform *xfm_base,
+								 const struct pwl_params *params)
+{
+	bool is_ram_a = true;
+
+	ippn10_power_on_degamma_lut(xfm_base, true);
+	ippn10_enable_cm_block(xfm_base);
+	ippn10_degamma_ram_inuse(xfm_base, &is_ram_a);
+	if (is_ram_a == true)
+		ippn10_program_degamma_lutb_settings(xfm_base, params);
+	else
+		ippn10_program_degamma_luta_settings(xfm_base, params);
+
+	ippn10_program_degamma_lut(xfm_base, params->rgb_resulted,
+							params->hw_points_num, !is_ram_a);
+	ippn10_degamma_ram_select(xfm_base, !is_ram_a);
+}
+
+void ippn10_full_bypass(struct transform *xfm_base)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	/* Input pixel format: ARGB8888 */
+	REG_SET(CNVC_SURFACE_PIXEL_FORMAT, 0,
+			CNVC_SURFACE_PIXEL_FORMAT, 0x8);
+
+	/* Zero expansion */
+	REG_SET_3(FORMAT_CONTROL, 0,
+			CNVC_BYPASS, 0,
+			FORMAT_CONTROL__ALPHA_EN, 0,
+			FORMAT_EXPANSION_MODE, 0);
+
+	/* COLOR_KEYER_CONTROL.COLOR_KEYER_EN = 0 this should be default */
+	REG_SET(CM_CONTROL, 0, CM_BYPASS_EN, 1);
+
+	/* Setting degamma bypass for now */
+	REG_SET(CM_DGAM_CONTROL, 0, CM_DGAM_LUT_MODE, 0);
+	REG_SET(CM_IGAM_CONTROL, 0, CM_IGAM_LUT_MODE, 0);
+}
+
+static bool ippn10_ingamma_ram_inuse(struct transform *xfm_base,
+							bool *ram_a_inuse)
+{
+	bool in_use = false;
+	uint32_t status_reg = 0;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	REG_GET(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_DGAM_CONFIG_STATUS,
+				&status_reg);
+
+	// 1 => IGAM_RAMA, 3 => IGAM_RAMA & DGAM_ROMA, 4 => IGAM_RAMA & DGAM_ROMB
+	if (status_reg == 1 || status_reg == 3 || status_reg == 4) {
+		*ram_a_inuse = true;
+		in_use = true;
+	// 2 => IGAM_RAMB, 5 => IGAM_RAMB & DGAM_ROMA, 6 => IGAM_RAMB & DGAM_ROMB
+	} else if (status_reg == 2 || status_reg == 5 || status_reg == 6) {
+		*ram_a_inuse = false;
+		in_use = true;
+	}
+	return in_use;
+}
+
+/*
+ * Input gamma LUT currently supports 256 values only. This means input color
+ * can have a maximum of 8 bits per channel (= 256 possible values) in order to
+ * have a one-to-one mapping with the LUT. Truncation will occur with color
+ * values greater than 8 bits.
+ *
+ * In the future, this function should support additional input gamma methods,
+ * such as piecewise linear mapping, and input gamma bypass.
+ */
+void ippn10_program_input_lut(
+		struct transform *xfm_base,
+		const struct dc_gamma *gamma)
+{
+	int i;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	bool rama_occupied = false;
+	uint32_t ram_num;
+	// Power on LUT memory.
+	REG_SET(CM_MEM_PWR_CTRL, 0, SHARED_MEM_PWR_DIS, 1);
+	ippn10_enable_cm_block(xfm_base);
+	// Determine whether to use RAM A or RAM B
+	ippn10_ingamma_ram_inuse(xfm_base, &rama_occupied);
+	if (!rama_occupied)
+		REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_SEL, 0);
+	else
+		REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_SEL, 1);
+	// RW mode is 256-entry LUT
+	REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_RW_MODE, 0);
+	// IGAM Input format should be 8 bits per channel.
+	REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, 0);
+	// Do not mask any R,G,B values
+	REG_UPDATE(CM_IGAM_LUT_RW_CONTROL, CM_IGAM_LUT_WRITE_EN_MASK, 7);
+	// LUT-256, unsigned, integer, new u0.12 format
+	REG_UPDATE_3(
+		CM_IGAM_CONTROL,
+		CM_IGAM_LUT_FORMAT_R, 3,
+		CM_IGAM_LUT_FORMAT_G, 3,
+		CM_IGAM_LUT_FORMAT_B, 3);
+	// Start at index 0 of IGAM LUT
+	REG_UPDATE(CM_IGAM_LUT_RW_INDEX, CM_IGAM_LUT_RW_INDEX, 0);
+	for (i = 0; i < gamma->num_entries; i++) {
+		REG_SET(CM_IGAM_LUT_SEQ_COLOR, 0, CM_IGAM_LUT_SEQ_COLOR,
+				dal_fixed31_32_round(
+					gamma->entries.red[i]));
+		REG_SET(CM_IGAM_LUT_SEQ_COLOR, 0, CM_IGAM_LUT_SEQ_COLOR,
+				dal_fixed31_32_round(
+					gamma->entries.green[i]));
+		REG_SET(CM_IGAM_LUT_SEQ_COLOR, 0, CM_IGAM_LUT_SEQ_COLOR,
+				dal_fixed31_32_round(
+					gamma->entries.blue[i]));
+	}
+	// Power off LUT memory
+	REG_SET(CM_MEM_PWR_CTRL, 0, SHARED_MEM_PWR_DIS, 0);
+	// Enable IGAM LUT on ram we just wrote to. 2 => RAMA, 3 => RAMB
+	REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, rama_occupied ? 3 : 2);
+	REG_GET(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, &ram_num);
+}

commit 58314e5812d5027edb01e0d20cf72068c95a7c10
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Sat Aug 19 12:10:28 2017 -0400

    drm/amd/display: cleanup naming of DCN DPP functions
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
index 7eb4334c30fc..9ff283bff007 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -221,7 +221,7 @@ static void program_gamut_remap(
 
 }
 
-void dcn_dpp_set_gamut_remap(
+void dcn10_dpp_cm_set_gamut_remap(
 	struct transform *xfm,
 	const struct xfm_grph_csc_adjustment *adjust)
 {
@@ -256,7 +256,7 @@ void dcn_dpp_set_gamut_remap(
 	}
 }
 
-void oppn10_set_output_csc_default(
+void dcn10_dpp_cm_set_output_csc_default(
 		struct transform *xfm_base,
 		const struct default_adjustment *default_adjust)
 {
@@ -293,7 +293,7 @@ void oppn10_set_output_csc_default(
 
 }
 
-static void oppn10_program_color_matrix(
+static void dcn10_dpp_cm_program_color_matrix(
 		struct dcn10_dpp *xfm,
 		const struct out_csc_color_matrix *tbl_entry)
 {
@@ -363,7 +363,7 @@ static void oppn10_program_color_matrix(
 	}
 }
 
-void oppn10_set_output_csc_adjustment(
+void dcn10_dpp_cm_set_output_csc_adjustment(
 		struct transform *xfm_base,
 		const struct out_csc_color_matrix *tbl_entry)
 {
@@ -399,10 +399,10 @@ void oppn10_set_output_csc_adjustment(
 	*/
 
 	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
-	oppn10_program_color_matrix(xfm, tbl_entry);
+	dcn10_dpp_cm_program_color_matrix(xfm, tbl_entry);
 }
 
-void oppn10_power_on_regamma_lut(
+void dcn10_dpp_cm_power_on_regamma_lut(
 	struct transform *xfm_base,
 	bool power_on)
 {
@@ -412,7 +412,7 @@ void oppn10_power_on_regamma_lut(
 
 }
 
-void opp_program_regamma_lut(
+void dcn10_dpp_cm_program_regamma_lut(
 		struct transform *xfm_base,
 		const struct pwl_result_data *rgb,
 		uint32_t num)
@@ -435,7 +435,7 @@ void opp_program_regamma_lut(
 
 }
 
-void opp_configure_regamma_lut(
+void dcn10_dpp_cm_configure_regamma_lut(
 		struct transform *xfm_base,
 		bool is_ram_a)
 {
@@ -449,7 +449,7 @@ void opp_configure_regamma_lut(
 }
 
 /*program re gamma RAM A*/
-void opp_program_regamma_luta_settings(
+void dcn10_dpp_cm_program_regamma_luta_settings(
 		struct transform *xfm_base,
 		const struct pwl_params *params)
 {
@@ -612,7 +612,7 @@ void opp_program_regamma_luta_settings(
 }
 
 /*program re gamma RAM B*/
-void opp_program_regamma_lutb_settings(
+void dcn10_dpp_cm_program_regamma_lutb_settings(
 		struct transform *xfm_base,
 		const struct pwl_params *params)
 {

commit dff2721bd1d777eba3917f04d4b8adede89badff
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Thu Aug 17 17:17:37 2017 -0400

    drm/amd/display: separate cm functions out from dcn10_dpp
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
new file mode 100644
index 000000000000..7eb4334c30fc
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -0,0 +1,776 @@
+/*
+ * Copyright 2016 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dm_services.h"
+
+#include "core_types.h"
+
+#include "include/grph_object_id.h"
+#include "include/fixed31_32.h"
+#include "include/logger_interface.h"
+
+#include "reg_helper.h"
+#include "dcn10_dpp.h"
+#include "basics/conversion.h"
+
+#define NUM_PHASES    64
+#define HORZ_MAX_TAPS 8
+#define VERT_MAX_TAPS 8
+
+#define BLACK_OFFSET_RGB_Y 0x0
+#define BLACK_OFFSET_CBCR  0x8000
+
+#define REG(reg)\
+	xfm->tf_regs->reg
+
+#define CTX \
+	xfm->base.ctx
+
+#undef FN
+#define FN(reg_name, field_name) \
+	xfm->tf_shift->field_name, xfm->tf_mask->field_name
+
+enum dcn10_coef_filter_type_sel {
+	SCL_COEF_LUMA_VERT_FILTER = 0,
+	SCL_COEF_LUMA_HORZ_FILTER = 1,
+	SCL_COEF_CHROMA_VERT_FILTER = 2,
+	SCL_COEF_CHROMA_HORZ_FILTER = 3,
+	SCL_COEF_ALPHA_VERT_FILTER = 4,
+	SCL_COEF_ALPHA_HORZ_FILTER = 5
+};
+
+enum lb_memory_config {
+	/* Enable all 3 pieces of memory */
+	LB_MEMORY_CONFIG_0 = 0,
+
+	/* Enable only the first piece of memory */
+	LB_MEMORY_CONFIG_1 = 1,
+
+	/* Enable only the second piece of memory */
+	LB_MEMORY_CONFIG_2 = 2,
+
+	/* Only applicable in 4:2:0 mode, enable all 3 pieces of memory and the
+	 * last piece of chroma memory used for the luma storage
+	 */
+	LB_MEMORY_CONFIG_3 = 3
+};
+
+enum dscl_autocal_mode {
+	AUTOCAL_MODE_OFF = 0,
+
+	/* Autocal calculate the scaling ratio and initial phase and the
+	 * DSCL_MODE_SEL must be set to 1
+	 */
+	AUTOCAL_MODE_AUTOSCALE = 1,
+	/* Autocal perform auto centering without replication and the
+	 * DSCL_MODE_SEL must be set to 0
+	 */
+	AUTOCAL_MODE_AUTOCENTER = 2,
+	/* Autocal perform auto centering and auto replication and the
+	 * DSCL_MODE_SEL must be set to 0
+	 */
+	AUTOCAL_MODE_AUTOREPLICATE = 3
+};
+
+enum dscl_mode_sel {
+	DSCL_MODE_SCALING_444_BYPASS = 0,
+	DSCL_MODE_SCALING_444_RGB_ENABLE = 1,
+	DSCL_MODE_SCALING_444_YCBCR_ENABLE = 2,
+	DSCL_MODE_SCALING_420_YCBCR_ENABLE = 3,
+	DSCL_MODE_SCALING_420_LUMA_BYPASS = 4,
+	DSCL_MODE_SCALING_420_CHROMA_BYPASS = 5,
+	DSCL_MODE_DSCL_BYPASS = 6
+};
+
+enum gamut_remap_select {
+	GAMUT_REMAP_BYPASS = 0,
+	GAMUT_REMAP_COEFF,
+	GAMUT_REMAP_COMA_COEFF,
+	GAMUT_REMAP_COMB_COEFF
+};
+
+static void program_gamut_remap(
+		struct dcn10_dpp *xfm,
+		const uint16_t *regval,
+		enum gamut_remap_select select)
+{
+	 uint16_t selection = 0;
+
+	if (regval == NULL || select == GAMUT_REMAP_BYPASS) {
+		REG_SET(CM_GAMUT_REMAP_CONTROL, 0,
+				CM_GAMUT_REMAP_MODE, 0);
+		return;
+	}
+	switch (select) {
+	case GAMUT_REMAP_COEFF:
+		selection = 1;
+		break;
+	case GAMUT_REMAP_COMA_COEFF:
+		selection = 2;
+		break;
+	case GAMUT_REMAP_COMB_COEFF:
+		selection = 3;
+		break;
+	default:
+		break;
+	}
+
+
+	if (select == GAMUT_REMAP_COEFF) {
+
+		REG_SET_2(CM_GAMUT_REMAP_C11_C12, 0,
+				CM_GAMUT_REMAP_C11, regval[0],
+				CM_GAMUT_REMAP_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C13_C14, 0,
+				CM_GAMUT_REMAP_C13, regval[0],
+				CM_GAMUT_REMAP_C14, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C21_C22, 0,
+				CM_GAMUT_REMAP_C21, regval[0],
+				CM_GAMUT_REMAP_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C23_C24, 0,
+				CM_GAMUT_REMAP_C23, regval[0],
+				CM_GAMUT_REMAP_C24, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C31_C32, 0,
+				CM_GAMUT_REMAP_C31, regval[0],
+				CM_GAMUT_REMAP_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C33_C34, 0,
+				CM_GAMUT_REMAP_C33, regval[0],
+				CM_GAMUT_REMAP_C34, regval[1]);
+
+	} else  if (select == GAMUT_REMAP_COMA_COEFF) {
+		REG_SET_2(CM_COMA_C11_C12, 0,
+				CM_COMA_C11, regval[0],
+				CM_COMA_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C13_C14, 0,
+				CM_COMA_C13, regval[0],
+				CM_COMA_C14, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C21_C22, 0,
+				CM_COMA_C21, regval[0],
+				CM_COMA_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C23_C24, 0,
+				CM_COMA_C23, regval[0],
+				CM_COMA_C24, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C31_C32, 0,
+				CM_COMA_C31, regval[0],
+				CM_COMA_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C33_C34, 0,
+				CM_COMA_C33, regval[0],
+				CM_COMA_C34, regval[1]);
+
+	} else {
+		REG_SET_2(CM_COMB_C11_C12, 0,
+				CM_COMB_C11, regval[0],
+				CM_COMB_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C13_C14, 0,
+				CM_COMB_C13, regval[0],
+				CM_COMB_C14, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C21_C22, 0,
+				CM_COMB_C21, regval[0],
+				CM_COMB_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C23_C24, 0,
+				CM_COMB_C23, regval[0],
+				CM_COMB_C24, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C31_C32, 0,
+				CM_COMB_C31, regval[0],
+				CM_COMB_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C33_C34, 0,
+				CM_COMB_C33, regval[0],
+				CM_COMB_C34, regval[1]);
+	}
+
+	REG_SET(
+			CM_GAMUT_REMAP_CONTROL, 0,
+			CM_GAMUT_REMAP_MODE, selection);
+
+}
+
+void dcn_dpp_set_gamut_remap(
+	struct transform *xfm,
+	const struct xfm_grph_csc_adjustment *adjust)
+{
+	struct dcn10_dpp *dcn_xfm = TO_DCN10_DPP(xfm);
+
+	if (adjust->gamut_adjust_type != GRAPHICS_GAMUT_ADJUST_TYPE_SW)
+		/* Bypass if type is bypass or hw */
+		program_gamut_remap(dcn_xfm, NULL, GAMUT_REMAP_BYPASS);
+	else {
+		struct fixed31_32 arr_matrix[12];
+		uint16_t arr_reg_val[12];
+
+		arr_matrix[0] = adjust->temperature_matrix[0];
+		arr_matrix[1] = adjust->temperature_matrix[1];
+		arr_matrix[2] = adjust->temperature_matrix[2];
+		arr_matrix[3] = dal_fixed31_32_zero;
+
+		arr_matrix[4] = adjust->temperature_matrix[3];
+		arr_matrix[5] = adjust->temperature_matrix[4];
+		arr_matrix[6] = adjust->temperature_matrix[5];
+		arr_matrix[7] = dal_fixed31_32_zero;
+
+		arr_matrix[8] = adjust->temperature_matrix[6];
+		arr_matrix[9] = adjust->temperature_matrix[7];
+		arr_matrix[10] = adjust->temperature_matrix[8];
+		arr_matrix[11] = dal_fixed31_32_zero;
+
+		convert_float_matrix(
+			arr_reg_val, arr_matrix, 12);
+
+		program_gamut_remap(dcn_xfm, arr_reg_val, GAMUT_REMAP_COEFF);
+	}
+}
+
+void oppn10_set_output_csc_default(
+		struct transform *xfm_base,
+		const struct default_adjustment *default_adjust)
+{
+
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	uint32_t ocsc_mode = 0;
+
+	if (default_adjust != NULL) {
+		switch (default_adjust->out_color_space) {
+		case COLOR_SPACE_SRGB:
+		case COLOR_SPACE_2020_RGB_FULLRANGE:
+			ocsc_mode = 0;
+			break;
+		case COLOR_SPACE_SRGB_LIMITED:
+		case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
+			ocsc_mode = 1;
+			break;
+		case COLOR_SPACE_YCBCR601:
+		case COLOR_SPACE_YCBCR601_LIMITED:
+			ocsc_mode = 2;
+			break;
+		case COLOR_SPACE_YCBCR709:
+		case COLOR_SPACE_YCBCR709_LIMITED:
+		case COLOR_SPACE_2020_YCBCR:
+			ocsc_mode = 3;
+			break;
+		case COLOR_SPACE_UNKNOWN:
+		default:
+			break;
+		}
+	}
+
+	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
+
+}
+
+static void oppn10_program_color_matrix(
+		struct dcn10_dpp *xfm,
+		const struct out_csc_color_matrix *tbl_entry)
+{
+	uint32_t mode;
+
+	REG_GET(CM_OCSC_CONTROL, CM_OCSC_MODE, &mode);
+
+	if (tbl_entry == NULL) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	if (mode == 4) {
+		/*R*/
+		REG_SET_2(CM_OCSC_C11_C12, 0,
+			CM_OCSC_C11, tbl_entry->regval[0],
+			CM_OCSC_C12, tbl_entry->regval[1]);
+
+		REG_SET_2(CM_OCSC_C13_C14, 0,
+			CM_OCSC_C13, tbl_entry->regval[2],
+			CM_OCSC_C14, tbl_entry->regval[3]);
+
+		/*G*/
+		REG_SET_2(CM_OCSC_C21_C22, 0,
+			CM_OCSC_C21, tbl_entry->regval[4],
+			CM_OCSC_C22, tbl_entry->regval[5]);
+
+		REG_SET_2(CM_OCSC_C23_C24, 0,
+			CM_OCSC_C23, tbl_entry->regval[6],
+			CM_OCSC_C24, tbl_entry->regval[7]);
+
+		/*B*/
+		REG_SET_2(CM_OCSC_C31_C32, 0,
+			CM_OCSC_C31, tbl_entry->regval[8],
+			CM_OCSC_C32, tbl_entry->regval[9]);
+
+		REG_SET_2(CM_OCSC_C33_C34, 0,
+			CM_OCSC_C33, tbl_entry->regval[10],
+			CM_OCSC_C34, tbl_entry->regval[11]);
+	} else {
+		/*R*/
+		REG_SET_2(CM_COMB_C11_C12, 0,
+			CM_COMB_C11, tbl_entry->regval[0],
+			CM_COMB_C12, tbl_entry->regval[1]);
+
+		REG_SET_2(CM_COMB_C13_C14, 0,
+			CM_COMB_C13, tbl_entry->regval[2],
+			CM_COMB_C14, tbl_entry->regval[3]);
+
+		/*G*/
+		REG_SET_2(CM_COMB_C21_C22, 0,
+			CM_COMB_C21, tbl_entry->regval[4],
+			CM_COMB_C22, tbl_entry->regval[5]);
+
+		REG_SET_2(CM_COMB_C23_C24, 0,
+			CM_COMB_C23, tbl_entry->regval[6],
+			CM_COMB_C24, tbl_entry->regval[7]);
+
+		/*B*/
+		REG_SET_2(CM_COMB_C31_C32, 0,
+			CM_COMB_C31, tbl_entry->regval[8],
+			CM_COMB_C32, tbl_entry->regval[9]);
+
+		REG_SET_2(CM_COMB_C33_C34, 0,
+			CM_COMB_C33, tbl_entry->regval[10],
+			CM_COMB_C34, tbl_entry->regval[11]);
+	}
+}
+
+void oppn10_set_output_csc_adjustment(
+		struct transform *xfm_base,
+		const struct out_csc_color_matrix *tbl_entry)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	//enum csc_color_mode config = CSC_COLOR_MODE_GRAPHICS_OUTPUT_CSC;
+	uint32_t ocsc_mode = 4;
+
+	/**
+	*if (tbl_entry != NULL) {
+	*	switch (tbl_entry->color_space) {
+	*	case COLOR_SPACE_SRGB:
+	*	case COLOR_SPACE_2020_RGB_FULLRANGE:
+	*		ocsc_mode = 0;
+	*		break;
+	*	case COLOR_SPACE_SRGB_LIMITED:
+	*	case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
+	*		ocsc_mode = 1;
+	*		break;
+	*	case COLOR_SPACE_YCBCR601:
+	*	case COLOR_SPACE_YCBCR601_LIMITED:
+	*		ocsc_mode = 2;
+	*		break;
+	*	case COLOR_SPACE_YCBCR709:
+	*	case COLOR_SPACE_YCBCR709_LIMITED:
+	*	case COLOR_SPACE_2020_YCBCR:
+	*		ocsc_mode = 3;
+	*		break;
+	*	case COLOR_SPACE_UNKNOWN:
+	*	default:
+	*		break;
+	*	}
+	*}
+	*/
+
+	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
+	oppn10_program_color_matrix(xfm, tbl_entry);
+}
+
+void oppn10_power_on_regamma_lut(
+	struct transform *xfm_base,
+	bool power_on)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	REG_SET(CM_MEM_PWR_CTRL, 0,
+			RGAM_MEM_PWR_FORCE, power_on == true ? 0:1);
+
+}
+
+void opp_program_regamma_lut(
+		struct transform *xfm_base,
+		const struct pwl_result_data *rgb,
+		uint32_t num)
+{
+	uint32_t i;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	for (i = 0 ; i < num; i++) {
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].red_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].green_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].blue_reg);
+
+		REG_SET(CM_RGAM_LUT_DATA, 0,
+				CM_RGAM_LUT_DATA, rgb[i].delta_red_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0,
+				CM_RGAM_LUT_DATA, rgb[i].delta_green_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0,
+				CM_RGAM_LUT_DATA, rgb[i].delta_blue_reg);
+
+	}
+
+}
+
+void opp_configure_regamma_lut(
+		struct transform *xfm_base,
+		bool is_ram_a)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
+			CM_RGAM_LUT_WRITE_EN_MASK, 7);
+	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
+			CM_RGAM_LUT_WRITE_SEL, is_ram_a == true ? 0:1);
+	REG_SET(CM_RGAM_LUT_INDEX, 0, CM_RGAM_LUT_INDEX, 0);
+}
+
+/*program re gamma RAM A*/
+void opp_program_regamma_luta_settings(
+		struct transform *xfm_base,
+		const struct pwl_params *params)
+{
+	const struct gamma_curve *curve;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	REG_SET_2(CM_RGAM_RAMA_START_CNTL_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_B, 0);
+	REG_SET_2(CM_RGAM_RAMA_START_CNTL_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_G, 0);
+	REG_SET_2(CM_RGAM_RAMA_START_CNTL_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_R, 0);
+
+	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_RGAM_RAMA_END_CNTL1_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMA_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMA_END_CNTL1_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMA_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMA_END_CNTL1_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMA_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
+
+	curve = params->arr_curve_points;
+	REG_SET_4(CM_RGAM_RAMA_REGION_0_1, 0,
+		CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_2_3, 0,
+		CM_RGAM_RAMA_EXP_REGION2_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION3_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_4_5, 0,
+		CM_RGAM_RAMA_EXP_REGION4_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION5_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_6_7, 0,
+		CM_RGAM_RAMA_EXP_REGION6_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION7_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_8_9, 0,
+		CM_RGAM_RAMA_EXP_REGION8_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION9_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_10_11, 0,
+		CM_RGAM_RAMA_EXP_REGION10_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION11_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_12_13, 0,
+		CM_RGAM_RAMA_EXP_REGION12_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION13_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_14_15, 0,
+		CM_RGAM_RAMA_EXP_REGION14_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION15_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_16_17, 0,
+		CM_RGAM_RAMA_EXP_REGION16_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION17_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_18_19, 0,
+		CM_RGAM_RAMA_EXP_REGION18_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION19_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_20_21, 0,
+		CM_RGAM_RAMA_EXP_REGION20_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION21_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_22_23, 0,
+		CM_RGAM_RAMA_EXP_REGION22_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION23_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_24_25, 0,
+		CM_RGAM_RAMA_EXP_REGION24_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION25_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_26_27, 0,
+		CM_RGAM_RAMA_EXP_REGION26_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION27_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_28_29, 0,
+		CM_RGAM_RAMA_EXP_REGION28_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION29_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_30_31, 0,
+		CM_RGAM_RAMA_EXP_REGION30_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION31_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_32_33, 0,
+		CM_RGAM_RAMA_EXP_REGION32_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION33_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);
+}
+
+/*program re gamma RAM B*/
+void opp_program_regamma_lutb_settings(
+		struct transform *xfm_base,
+		const struct pwl_params *params)
+{
+	const struct gamma_curve *curve;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	REG_SET_2(CM_RGAM_RAMB_START_CNTL_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B, 0);
+	REG_SET_2(CM_RGAM_RAMB_START_CNTL_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_G, 0);
+	REG_SET_2(CM_RGAM_RAMB_START_CNTL_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_R, 0);
+
+	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_RGAM_RAMB_END_CNTL1_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMB_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMB_END_CNTL1_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMB_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMB_END_CNTL1_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMB_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
+
+	curve = params->arr_curve_points;
+	REG_SET_4(CM_RGAM_RAMB_REGION_0_1, 0,
+		CM_RGAM_RAMB_EXP_REGION0_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION1_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_2_3, 0,
+		CM_RGAM_RAMB_EXP_REGION2_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION3_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_4_5, 0,
+		CM_RGAM_RAMB_EXP_REGION4_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION5_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_6_7, 0,
+		CM_RGAM_RAMB_EXP_REGION6_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION7_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_8_9, 0,
+		CM_RGAM_RAMB_EXP_REGION8_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION9_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_10_11, 0,
+		CM_RGAM_RAMB_EXP_REGION10_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION11_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_12_13, 0,
+		CM_RGAM_RAMB_EXP_REGION12_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION13_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_14_15, 0,
+		CM_RGAM_RAMB_EXP_REGION14_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION15_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_16_17, 0,
+		CM_RGAM_RAMB_EXP_REGION16_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION17_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_18_19, 0,
+		CM_RGAM_RAMB_EXP_REGION18_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION19_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_20_21, 0,
+		CM_RGAM_RAMB_EXP_REGION20_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION21_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_22_23, 0,
+		CM_RGAM_RAMB_EXP_REGION22_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION23_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_24_25, 0,
+		CM_RGAM_RAMB_EXP_REGION24_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION25_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_26_27, 0,
+		CM_RGAM_RAMB_EXP_REGION26_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION27_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_28_29, 0,
+		CM_RGAM_RAMB_EXP_REGION28_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION29_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_30_31, 0,
+		CM_RGAM_RAMB_EXP_REGION30_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION31_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_32_33, 0,
+		CM_RGAM_RAMB_EXP_REGION32_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION33_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);
+
+}
