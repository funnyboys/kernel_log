commit 1da37801a8b0fffb024fea594c7f1d7867ed8aa0
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:38:55 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_0 and DSC_SUPPORTED
    
    [Why]
    
    DCN2 and DSC are stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup NV defninitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN2 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * dce/dce_dmcu.c: dcn20_*lock_phy()
        * dce/dce_dmcu.c: dcn20_funcs
        * dce/dce_dmcu.c: dcn20_dmcu_create()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index 33a3dcdb3fd1..d79718fde5a6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -373,11 +373,9 @@ void opp1_program_oppbuf(
 	 */
 	REG_UPDATE(OPPBUF_CONTROL, OPPBUF_PIXEL_REPETITION, oppbuf->pixel_repetition);
 
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	/* Controls the number of padded pixels at the end of a segment */
 	if (REG(OPPBUF_CONTROL1))
 		REG_UPDATE(OPPBUF_CONTROL1, OPPBUF_NUM_SEGMENT_PADDED_PIXELS, oppbuf->num_segment_padded_pixels);
-#endif
 }
 
 void opp1_pipe_clock_control(struct output_pixel_processor *opp, bool enable)
@@ -404,10 +402,8 @@ static const struct opp_funcs dcn10_opp_funcs = {
 		.opp_program_bit_depth_reduction = opp1_program_bit_depth_reduction,
 		.opp_program_stereo = opp1_program_stereo,
 		.opp_pipe_clock_control = opp1_pipe_clock_control,
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 		.opp_set_disp_pattern_generator = NULL,
 		.dpg_is_blanked = NULL,
-#endif
 		.opp_destroy = opp1_destroy
 };
 

commit ae8cf9774e3a609066b277c3742c3551564fb079
Author: Leo (Hanghong) Ma <hanghong.ma@amd.com>
Date:   Fri Sep 6 09:49:19 2019 -0400

    drm/amd/display: Add some hardware status in DTN log debugfs
    
    [Why]
    For debug purpose, we need to check the following hardware status
    in DTN log debugfs:
    1.dpp & hubp clock enable;
    2.crtc blank enable;
    3.link phy status;
    
    [How]
    Add the upper information in the amdgpu_dm_dtn_log debugfs.
    
    For CRTC blanked status, since DCN2 and greater reports it on the OPP
    instead of OTG, we patch it in after calling optc1_read_otg_states.
    Ideally, this should be done in the DCN version specific function hooks.
    It has been left as a TODO item.
    
    Signed-off-by: Leo (Hanghong) Ma <hanghong.ma@amd.com>
    Reviewed-by: Mikita Lipski <Mikita.Lipski@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index 0a9ad692f541..33a3dcdb3fd1 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -406,6 +406,7 @@ static const struct opp_funcs dcn10_opp_funcs = {
 		.opp_pipe_clock_control = opp1_pipe_clock_control,
 #if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 		.opp_set_disp_pattern_generator = NULL,
+		.dpg_is_blanked = NULL,
 #endif
 		.opp_destroy = opp1_destroy
 };

commit 90d268741f74f7852ebc295c96212c6e992b2078
Author: Robin Singh <robin.singh@amd.com>
Date:   Thu Aug 22 14:42:49 2019 -0400

    drm/amd/display: Added pixel dynamic expansion control.
    
    [Why]
    To compare the crc of the framebuffer data at input of
    display pipeline with the crc of the otg, we need to
    disable pixel formatter's dynamic expansion feature during
    crc capture and keep it enable in the normal operation.
    
    [HOW]
    Expose a new interface in DM and dc for pixel formatter
    (fmt dynamic bitdepth expansion control). Interface control
    the FMT_DYNAMIC_EXP_EN  bit, during crc capture keep
    it disabled.
    
    Signed-off-by: Robin Singh <robin.singh@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index 02c8a3e0b533..0a9ad692f541 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -240,6 +240,9 @@ void opp1_set_dyn_expansion(
 			FMT_DYNAMIC_EXP_EN, 0,
 			FMT_DYNAMIC_EXP_MODE, 0);
 
+	if (opp->dyn_expansion == DYN_EXPANSION_DISABLE)
+		return;
+
 	/*00 - 10-bit -> 12-bit dynamic expansion*/
 	/*01 - 8-bit  -> 12-bit dynamic expansion*/
 	if (signal == SIGNAL_TYPE_HDMI_TYPE_A ||

commit e6d14df74064fc65c6367d4c717e016c9d99be59
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Fri Aug 9 17:16:18 2019 -0400

    drm/amd/display: Subsample mode suboptimal for YCbCr4:2:2
    
    [Why&How]
    Driver defaults to 1-tap subsample mode for 4:2:2.
    DCE11.2 added 3-tap. The policy is:
    DCE8-DCE11 - change to 2-tap, it's better than 1-tap.
    DCE11.2+ - use 3-tap
    
    Note that 4:2:0 was added in DCE11.2 and already uses 3-tap always.
    Note 2 is that DCE not covered on Linux, only DCN+
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index e9ebbbe256b4..02c8a3e0b533 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -168,7 +168,10 @@ static void opp1_set_pixel_encoding(
 		REG_UPDATE(FMT_CONTROL, FMT_PIXEL_ENCODING, 0);
 		break;
 	case PIXEL_ENCODING_YCBCR422:
-		REG_UPDATE(FMT_CONTROL, FMT_PIXEL_ENCODING, 1);
+		REG_UPDATE_3(FMT_CONTROL,
+				FMT_PIXEL_ENCODING, 1,
+				FMT_SUBSAMPLING_MODE, 2,
+				FMT_CBCR_BIT_REDUCTION_BYPASS, 0);
 		break;
 	case PIXEL_ENCODING_YCBCR420:
 		REG_UPDATE(FMT_CONTROL, FMT_PIXEL_ENCODING, 2);

commit d7929c1e13e3788e7cb741d75b5baec5e53eff21
Merge: 8ac875db0fdc 80d42db02b3a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jun 25 08:42:25 2019 -0500

    Merge branch 'drm-next' into drm-next-5.3
    
    Backmerge drm-next and fix up conflicts due to drmP.h removal.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit eb7a74a36c247bfb7cb4249df59b8cedcb0b1fff
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Feb 22 15:45:23 2019 -0500

    drm/amd/display: Add DCN2 OPP
    
    Add support to program the DCN2 OPP (Output Plane Processing)
    
    HW Blocks:
    
        +-------+
        |  OPP  |
        +-------+
            |
            v
        +--------+
        |  OPTC  |
        +--------+
            |
            v
        +--------+       +--------+
        |  DIO   |       |  DCCG  |
        +--------+       +--------+
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index ab958cff3b76..1168342c7190 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -365,6 +365,11 @@ void opp1_program_oppbuf(
 	 */
 	REG_UPDATE(OPPBUF_CONTROL, OPPBUF_PIXEL_REPETITION, oppbuf->pixel_repetition);
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	/* Controls the number of padded pixels at the end of a segment */
+	if (REG(OPPBUF_CONTROL1))
+		REG_UPDATE(OPPBUF_CONTROL1, OPPBUF_NUM_SEGMENT_PADDED_PIXELS, oppbuf->num_segment_padded_pixels);
+#endif
 }
 
 void opp1_pipe_clock_control(struct output_pixel_processor *opp, bool enable)
@@ -391,6 +396,9 @@ static const struct opp_funcs dcn10_opp_funcs = {
 		.opp_program_bit_depth_reduction = opp1_program_bit_depth_reduction,
 		.opp_program_stereo = opp1_program_stereo,
 		.opp_pipe_clock_control = opp1_pipe_clock_control,
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+		.opp_set_disp_pattern_generator = NULL,
+#endif
 		.opp_destroy = opp1_destroy
 };
 

commit 4fc4dca8320e46b067037496fde3a6d95381d60f
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:50 2019 +0200

    drm/amd: drop use of drmp.h in os_types.h
    
    Drop use of the deprecated drmP.h from display/dc/os_types.h
    
    Fix all fallout after this change.
    Most of the fixes was adding a missing include of vmalloc.h.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian KÃ¶nig" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-4-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index ab958cff3b76..cec69cecf521 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -23,6 +23,8 @@
  *
  */
 
+#include <linux/slab.h>
+
 #include "dm_services.h"
 #include "dcn10_opp.h"
 #include "reg_helper.h"

commit bd4e725084189a198ca47d369d85100216d29b7e
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Jul 6 09:49:05 2018 -0400

    drm/amd/display: Make function pointer structs const
    
    const to avoid hard-to-find bugs where some function overrides a
    function pointer.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Christian KÃ¶nig <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index 77a1a9d541a4..ab958cff3b76 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -385,7 +385,7 @@ void opp1_destroy(struct output_pixel_processor **opp)
 	*opp = NULL;
 }
 
-static struct opp_funcs dcn10_opp_funcs = {
+static const struct opp_funcs dcn10_opp_funcs = {
 		.opp_set_dyn_expansion = opp1_set_dyn_expansion,
 		.opp_program_fmt = opp1_program_fmt,
 		.opp_program_bit_depth_reduction = opp1_program_bit_depth_reduction,

commit be2f449a19a198164fbcbbe9e22c6c32ad7a2492
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Dec 22 10:19:37 2017 -0500

    drm/amd/display: Move opp reg access from hwss to opp module.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index f6ba0eef4489..77a1a9d541a4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -367,6 +367,14 @@ void opp1_program_oppbuf(
 
 }
 
+void opp1_pipe_clock_control(struct output_pixel_processor *opp, bool enable)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+	uint32_t regval = enable ? 1 : 0;
+
+	REG_UPDATE(OPP_PIPE_CONTROL, OPP_PIPE_CLOCK_EN, regval);
+}
+
 /*****************************************/
 /* Constructor, Destructor               */
 /*****************************************/
@@ -382,6 +390,7 @@ static struct opp_funcs dcn10_opp_funcs = {
 		.opp_program_fmt = opp1_program_fmt,
 		.opp_program_bit_depth_reduction = opp1_program_bit_depth_reduction,
 		.opp_program_stereo = opp1_program_stereo,
+		.opp_pipe_clock_control = opp1_pipe_clock_control,
 		.opp_destroy = opp1_destroy
 };
 

commit 72d520d4fa76e59d1882620fa34680ff4258ae6f
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Tue Dec 12 14:14:10 2017 -0500

    drm/amd/display: Update FMT and OPPBUF functions
    
    Updates to FMT and OPPBUF programming from HW team
    pseudocode review.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index 5f078868676c..f6ba0eef4489 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -296,13 +296,75 @@ void opp1_program_fmt(
 	return;
 }
 
-void opp1_set_stereo_polarity(
-		struct output_pixel_processor *opp,
-		bool enable, bool rightEyePolarity)
+void opp1_program_stereo(
+	struct output_pixel_processor *opp,
+	bool enable,
+	const struct dc_crtc_timing *timing)
 {
 	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
 
-	REG_UPDATE(FMT_CONTROL, FMT_STEREOSYNC_OVERRIDE, enable);
+	uint32_t active_width = timing->h_addressable - timing->h_border_right - timing->h_border_right;
+	uint32_t space1_size = timing->v_total - timing->v_addressable;
+	/* TODO: confirm computation of space2_size */
+	uint32_t space2_size = timing->v_total - timing->v_addressable;
+
+	if (!enable) {
+		active_width = 0;
+		space1_size = 0;
+		space2_size = 0;
+	}
+
+	/* TODO: for which cases should FMT_STEREOSYNC_OVERRIDE be set? */
+	REG_UPDATE(FMT_CONTROL, FMT_STEREOSYNC_OVERRIDE, 0);
+
+	REG_UPDATE(OPPBUF_CONTROL, OPPBUF_ACTIVE_WIDTH, active_width);
+
+	/* Program OPPBUF_3D_VACT_SPACE1_SIZE and OPPBUF_VACT_SPACE2_SIZE registers
+	 * In 3D progressive frames, Vactive space happens only in between the 2 frames,
+	 * so only need to program OPPBUF_3D_VACT_SPACE1_SIZE
+	 * In 3D alternative frames, left and right frames, top and bottom field.
+	 */
+	if (timing->timing_3d_format == TIMING_3D_FORMAT_FRAME_ALTERNATE)
+		REG_UPDATE(OPPBUF_3D_PARAMETERS_0, OPPBUF_3D_VACT_SPACE2_SIZE, space2_size);
+	else
+		REG_UPDATE(OPPBUF_3D_PARAMETERS_0, OPPBUF_3D_VACT_SPACE1_SIZE, space1_size);
+
+	/* TODO: Is programming of OPPBUF_DUMMY_DATA_R/G/B needed? */
+	/*
+	REG_UPDATE(OPPBUF_3D_PARAMETERS_0,
+			OPPBUF_DUMMY_DATA_R, data_r);
+	REG_UPDATE(OPPBUF_3D_PARAMETERS_1,
+			OPPBUF_DUMMY_DATA_G, data_g);
+	REG_UPDATE(OPPBUF_3D_PARAMETERS_1,
+			OPPBUF_DUMMY_DATA_B, _data_b);
+	*/
+}
+
+void opp1_program_oppbuf(
+	struct output_pixel_processor *opp,
+	struct oppbuf_params *oppbuf)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	/* Program the oppbuf active width to be the frame width from mpc */
+	REG_UPDATE(OPPBUF_CONTROL, OPPBUF_ACTIVE_WIDTH, oppbuf->active_width);
+
+	/* Specifies the number of segments in multi-segment mode (DP-MSO operation)
+	 * description  "In 1/2/4 segment mode, specifies the horizontal active width in pixels of the display panel.
+	 * In 4 segment split left/right mode, specifies the horizontal 1/2 active width in pixels of the display panel.
+	 * Used to determine segment boundaries in multi-segment mode. Used to determine the width of the vertical active space in 3D frame packed modes.
+	 * OPPBUF_ACTIVE_WIDTH must be integer divisible by the total number of segments."
+	 */
+	REG_UPDATE(OPPBUF_CONTROL, OPPBUF_DISPLAY_SEGMENTATION, oppbuf->mso_segmentation);
+
+	/* description  "Specifies the number of overlap pixels (1-8 overlapping pixels supported), used in multi-segment mode (DP-MSO operation)" */
+	REG_UPDATE(OPPBUF_CONTROL, OPPBUF_OVERLAP_PIXEL_NUM, oppbuf->mso_overlap_pixel_num);
+
+	/* description  "Specifies the number of times a pixel is replicated (0-15 pixel replications supported).
+	 * A value of 0 disables replication. The total number of times a pixel is output is OPPBUF_PIXEL_REPETITION + 1."
+	 */
+	REG_UPDATE(OPPBUF_CONTROL, OPPBUF_PIXEL_REPETITION, oppbuf->pixel_repetition);
+
 }
 
 /*****************************************/
@@ -319,7 +381,7 @@ static struct opp_funcs dcn10_opp_funcs = {
 		.opp_set_dyn_expansion = opp1_set_dyn_expansion,
 		.opp_program_fmt = opp1_program_fmt,
 		.opp_program_bit_depth_reduction = opp1_program_bit_depth_reduction,
-		.opp_set_stereo_polarity = opp1_set_stereo_polarity,
+		.opp_program_stereo = opp1_program_stereo,
 		.opp_destroy = opp1_destroy
 };
 

commit f23d558466cf14e58ec7f666a3af1a6708681bcc
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Fri Nov 24 17:51:34 2017 -0500

    drm/amd/display: Move OPP mpc tree initialization to hw_init
    
    Move OPP initialization of mpc tree parameters to hw_init function.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index 20d78cf46ab0..5f078868676c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -330,18 +330,11 @@ void dcn10_opp_construct(struct dcn10_opp *oppn10,
 	const struct dcn10_opp_shift *opp_shift,
 	const struct dcn10_opp_mask *opp_mask)
 {
-	int i;
 
 	oppn10->base.ctx = ctx;
 	oppn10->base.inst = inst;
 	oppn10->base.funcs = &dcn10_opp_funcs;
 
-	oppn10->base.mpc_tree_params.opp_id = inst;
-	oppn10->base.mpc_tree_params.opp_list = NULL;
-
-	for (i = 0; i < MAX_PIPES; i++)
-		oppn10->base.mpcc_disconnect_pending[i] = false;
-
 	oppn10->regs = regs;
 	oppn10->opp_shift = opp_shift;
 	oppn10->opp_mask = opp_mask;

commit feb4a3cd8eb007f4749dc8323110f42fb4682ae0
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Mon Nov 6 16:38:55 2017 -0500

    drm/amd/display: Integrating MPC pseudocode
    
    Integrating MPC pseudocode to support new blending cases
    with secondary MPCC list.
    This includes a design change to MPC data structures and
    interfaces.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index 6d6f67b7d30e..20d78cf46ab0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -330,12 +330,19 @@ void dcn10_opp_construct(struct dcn10_opp *oppn10,
 	const struct dcn10_opp_shift *opp_shift,
 	const struct dcn10_opp_mask *opp_mask)
 {
+	int i;
+
 	oppn10->base.ctx = ctx;
 	oppn10->base.inst = inst;
 	oppn10->base.funcs = &dcn10_opp_funcs;
 
+	oppn10->base.mpc_tree_params.opp_id = inst;
+	oppn10->base.mpc_tree_params.opp_list = NULL;
+
+	for (i = 0; i < MAX_PIPES; i++)
+		oppn10->base.mpcc_disconnect_pending[i] = false;
+
 	oppn10->regs = regs;
 	oppn10->opp_shift = opp_shift;
 	oppn10->opp_mask = opp_mask;
 }
-

commit 621fd3e39fc0222d7c8d95ddb5a2dff6261a0a86
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Tue Nov 14 12:40:20 2017 -0500

    drm/amd/display: Set OPP default values in init_hw
    
    On S3 resume, we do not reconstruct OPP, but we do need to
    reinitialize some of its values to the default ones.
    Therefore, move those lines out of the OPP constructor and
    into init_hw.
    
    Also reset the hubp power gated flag, since nothing is
    power gated at init_hw.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index 341210060cf7..6d6f67b7d30e 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -330,17 +330,10 @@ void dcn10_opp_construct(struct dcn10_opp *oppn10,
 	const struct dcn10_opp_shift *opp_shift,
 	const struct dcn10_opp_mask *opp_mask)
 {
-	int i;
 	oppn10->base.ctx = ctx;
 	oppn10->base.inst = inst;
 	oppn10->base.funcs = &dcn10_opp_funcs;
 
-	oppn10->base.mpc_tree.dpp[0] = inst;
-	oppn10->base.mpc_tree.mpcc[0] = inst;
-	oppn10->base.mpc_tree.num_pipes = 1;
-	for (i = 0; i < MAX_PIPES; i++)
-		oppn10->base.mpcc_disconnect_pending[i] = false;
-
 	oppn10->regs = regs;
 	oppn10->opp_shift = opp_shift;
 	oppn10->opp_mask = opp_mask;

commit e994340bfa57d96bfbd9e66bf802ea82b4ba56fc
Author: Arun Pandey <Arun.Pandey@amd.com>
Date:   Wed Nov 8 17:02:55 2017 +0800

    drm/amd/display: Added Opp and Diags Interface for P to I
    
    Signed-off-by: Arun Pandey <Arun.Pandey@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index 71385a004f52..341210060cf7 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -38,25 +38,6 @@
 	oppn10->base.ctx
 
 
-enum dpg_mode {
-	/* RGB colour block mode */
-	DPG_MODE_RGB_COLOUR_BLOCK,
-	/* YCbCr-601 colour block mode */
-	DPG_MODE_YCBCR_601_COLOUR_BLOCK,
-	/* YCbCr-709 colour block mode */
-	DPG_MODE_YCBCR_709_COLOUR_BLOCK,
-	/* Vertical bar mode */
-	DPG_MODE_VERTICAL_BAR,
-	/* Horizontal bar mode */
-	DPG_MODE_HORIZONTAL_BAR,
-	/* Single ramp mode */
-	DPG_MODE_RGB_SINGLE_RAMP,
-	/* Dual ramp mode */
-	DPG_MODE_RGB_DUAL_RAMP,
-	/* RGB XR BIAS mode */
-	DPG_MODE_RGB_XR_BIAS
-};
-
 /************* FORMATTER ************/
 
 /**
@@ -154,7 +135,7 @@ static void opp1_set_spatial_dither(
 			FMT_RGB_RANDOM_ENABLE, params->flags.RGB_RANDOM);
 }
 
-static void opp1_program_bit_depth_reduction(
+void opp1_program_bit_depth_reduction(
 	struct output_pixel_processor *opp,
 	const struct bit_depth_reduction_params *params)
 {
@@ -242,7 +223,7 @@ static void opp1_set_clamping(
 
 }
 
-static void opp1_set_dyn_expansion(
+void opp1_set_dyn_expansion(
 	struct output_pixel_processor *opp,
 	enum dc_color_space color_sp,
 	enum dc_color_depth color_dpth,
@@ -292,7 +273,7 @@ static void opp1_program_clamping_and_pixel_encoding(
 	opp1_set_pixel_encoding(oppn10, params);
 }
 
-static void opp1_program_fmt(
+void opp1_program_fmt(
 	struct output_pixel_processor *opp,
 	struct bit_depth_reduction_params *fmt_bit_depth,
 	struct clamping_and_pixel_encoding_params *clamping)
@@ -315,7 +296,7 @@ static void opp1_program_fmt(
 	return;
 }
 
-static void opp1_set_stereo_polarity(
+void opp1_set_stereo_polarity(
 		struct output_pixel_processor *opp,
 		bool enable, bool rightEyePolarity)
 {
@@ -328,7 +309,7 @@ static void opp1_set_stereo_polarity(
 /* Constructor, Destructor               */
 /*****************************************/
 
-static void opp1_destroy(struct output_pixel_processor **opp)
+void opp1_destroy(struct output_pixel_processor **opp)
 {
 	kfree(TO_DCN10_OPP(*opp));
 	*opp = NULL;

commit 6d56c5733282adb608795f1afe763988ba035218
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Tue Oct 31 11:52:25 2017 -0400

    drm/amd/display: Add OPP DPG blank function
    
    Added a function to blank data using OPP DPG.
    Clean up code to prepare for pseudocode review with HW.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index a136f70b7a3c..71385a004f52 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -38,6 +38,24 @@
 	oppn10->base.ctx
 
 
+enum dpg_mode {
+	/* RGB colour block mode */
+	DPG_MODE_RGB_COLOUR_BLOCK,
+	/* YCbCr-601 colour block mode */
+	DPG_MODE_YCBCR_601_COLOUR_BLOCK,
+	/* YCbCr-709 colour block mode */
+	DPG_MODE_YCBCR_709_COLOUR_BLOCK,
+	/* Vertical bar mode */
+	DPG_MODE_VERTICAL_BAR,
+	/* Horizontal bar mode */
+	DPG_MODE_HORIZONTAL_BAR,
+	/* Single ramp mode */
+	DPG_MODE_RGB_SINGLE_RAMP,
+	/* Dual ramp mode */
+	DPG_MODE_RGB_DUAL_RAMP,
+	/* RGB XR BIAS mode */
+	DPG_MODE_RGB_XR_BIAS
+};
 
 /************* FORMATTER ************/
 
@@ -47,7 +65,7 @@
  *	2) enable truncation
  *	3) HW remove 12bit FMT support for DCE11 power saving reason.
  */
-static void set_truncation(
+static void opp1_set_truncation(
 		struct dcn10_opp *oppn10,
 		const struct bit_depth_reduction_params *params)
 {
@@ -57,7 +75,7 @@ static void set_truncation(
 		FMT_TRUNCATE_MODE, params->flags.TRUNCATE_MODE);
 }
 
-static void set_spatial_dither(
+static void opp1_set_spatial_dither(
 	struct dcn10_opp *oppn10,
 	const struct bit_depth_reduction_params *params)
 {
@@ -136,14 +154,14 @@ static void set_spatial_dither(
 			FMT_RGB_RANDOM_ENABLE, params->flags.RGB_RANDOM);
 }
 
-static void oppn10_program_bit_depth_reduction(
+static void opp1_program_bit_depth_reduction(
 	struct output_pixel_processor *opp,
 	const struct bit_depth_reduction_params *params)
 {
 	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
 
-	set_truncation(oppn10, params);
-	set_spatial_dither(oppn10, params);
+	opp1_set_truncation(oppn10, params);
+	opp1_set_spatial_dither(oppn10, params);
 	/* TODO
 	 * set_temporal_dither(oppn10, params);
 	 */
@@ -156,7 +174,7 @@ static void oppn10_program_bit_depth_reduction(
  *		0: RGB 4:4:4 or YCbCr 4:4:4 or YOnly
  *		1: YCbCr 4:2:2
  */
-static void set_pixel_encoding(
+static void opp1_set_pixel_encoding(
 	struct dcn10_opp *oppn10,
 	const struct clamping_and_pixel_encoding_params *params)
 {
@@ -186,7 +204,7 @@ static void set_pixel_encoding(
  *		7 for programable
  *	2) Enable clamp if Limited range requested
  */
-static void opp_set_clamping(
+static void opp1_set_clamping(
 	struct dcn10_opp *oppn10,
 	const struct clamping_and_pixel_encoding_params *params)
 {
@@ -224,7 +242,7 @@ static void opp_set_clamping(
 
 }
 
-static void oppn10_set_dyn_expansion(
+static void opp1_set_dyn_expansion(
 	struct output_pixel_processor *opp,
 	enum dc_color_space color_sp,
 	enum dc_color_depth color_dpth,
@@ -264,17 +282,17 @@ static void oppn10_set_dyn_expansion(
 	}
 }
 
-static void opp_program_clamping_and_pixel_encoding(
+static void opp1_program_clamping_and_pixel_encoding(
 	struct output_pixel_processor *opp,
 	const struct clamping_and_pixel_encoding_params *params)
 {
 	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
 
-	opp_set_clamping(oppn10, params);
-	set_pixel_encoding(oppn10, params);
+	opp1_set_clamping(oppn10, params);
+	opp1_set_pixel_encoding(oppn10, params);
 }
 
-static void oppn10_program_fmt(
+static void opp1_program_fmt(
 	struct output_pixel_processor *opp,
 	struct bit_depth_reduction_params *fmt_bit_depth,
 	struct clamping_and_pixel_encoding_params *clamping)
@@ -286,20 +304,18 @@ static void oppn10_program_fmt(
 
 	/* dithering is affected by <CrtcSourceSelect>, hence should be
 	 * programmed afterwards */
-	oppn10_program_bit_depth_reduction(
+	opp1_program_bit_depth_reduction(
 		opp,
 		fmt_bit_depth);
 
-	opp_program_clamping_and_pixel_encoding(
+	opp1_program_clamping_and_pixel_encoding(
 		opp,
 		clamping);
 
 	return;
 }
 
-
-
-static void oppn10_set_stereo_polarity(
+static void opp1_set_stereo_polarity(
 		struct output_pixel_processor *opp,
 		bool enable, bool rightEyePolarity)
 {
@@ -312,18 +328,18 @@ static void oppn10_set_stereo_polarity(
 /* Constructor, Destructor               */
 /*****************************************/
 
-static void dcn10_opp_destroy(struct output_pixel_processor **opp)
+static void opp1_destroy(struct output_pixel_processor **opp)
 {
 	kfree(TO_DCN10_OPP(*opp));
 	*opp = NULL;
 }
 
 static struct opp_funcs dcn10_opp_funcs = {
-		.opp_set_dyn_expansion = oppn10_set_dyn_expansion,
-		.opp_program_fmt = oppn10_program_fmt,
-		.opp_program_bit_depth_reduction = oppn10_program_bit_depth_reduction,
-		.opp_set_stereo_polarity = oppn10_set_stereo_polarity,
-		.opp_destroy = dcn10_opp_destroy
+		.opp_set_dyn_expansion = opp1_set_dyn_expansion,
+		.opp_program_fmt = opp1_program_fmt,
+		.opp_program_bit_depth_reduction = opp1_program_bit_depth_reduction,
+		.opp_set_stereo_polarity = opp1_set_stereo_polarity,
+		.opp_destroy = opp1_destroy
 };
 
 void dcn10_opp_construct(struct dcn10_opp *oppn10,

commit 2004f45ef83f07f43f5da6ede780b08068c7583d
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Sep 27 10:53:50 2017 -0400

    drm/amd/display: Use kernel alloc/free
    
    Abstractions are frowned upon.
    
    cocci script:
    virtual context
    virtual patch
    virtual org
    virtual report
    
    @@
    expression ptr;
    @@
    
    - dm_alloc(ptr)
    + kzalloc(ptr, GFP_KERNEL)
    
    @@
    expression ptr, size;
    @@
    
    - dm_realloc(ptr, size)
    + krealloc(ptr, size, GFP_KERNEL)
    
    @@
    expression ptr;
    @@
    
    - dm_free(ptr)
    + kfree(ptr)
    
    v2: use GFP_KERNEL, not GFP_ATOMIC. add cocci script
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index 8048782ac599..a136f70b7a3c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -314,7 +314,7 @@ static void oppn10_set_stereo_polarity(
 
 static void dcn10_opp_destroy(struct output_pixel_processor **opp)
 {
-	dm_free(TO_DCN10_OPP(*opp));
+	kfree(TO_DCN10_OPP(*opp));
 	*opp = NULL;
 }
 

commit f0c4d9977ae215859ff13304ef0fc02a8b779478
Author: Corbin McElhanney <corbin.mcelhanney@amd.com>
Date:   Thu Aug 3 14:20:14 2017 -0400

    drm/amd/display: fix HDMI 12bits last two bits are zero issue
    
    (FF-158) -[FF N-1] HDMI Deep Color Mode incorrect bit depth:
    FMT_DYNAMIC_EXP_EN is being reset to 0
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index 38d15f7c2a88..8048782ac599 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -240,7 +240,8 @@ static void oppn10_set_dyn_expansion(
 	/*01 - 8-bit  -> 12-bit dynamic expansion*/
 	if (signal == SIGNAL_TYPE_HDMI_TYPE_A ||
 		signal == SIGNAL_TYPE_DISPLAY_PORT ||
-		signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {
+		signal == SIGNAL_TYPE_DISPLAY_PORT_MST ||
+		signal == SIGNAL_TYPE_VIRTUAL) {
 		switch (color_dpth) {
 		case COLOR_DEPTH_888:
 			REG_UPDATE_2(FMT_DYNAMIC_EXP_CNTL,

commit cc408d726c20f32e4fdd688f870dd2b17960d4a2
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jul 21 17:46:50 2017 -0400

    drm/amd/display: mpc block redesign
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index f8e4724a629d..38d15f7c2a88 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -337,6 +337,9 @@ void dcn10_opp_construct(struct dcn10_opp *oppn10,
 	oppn10->base.inst = inst;
 	oppn10->base.funcs = &dcn10_opp_funcs;
 
+	oppn10->base.mpc_tree.dpp[0] = inst;
+	oppn10->base.mpc_tree.mpcc[0] = inst;
+	oppn10->base.mpc_tree.num_pipes = 1;
 	for (i = 0; i < MAX_PIPES; i++)
 		oppn10->base.mpcc_disconnect_pending[i] = false;
 

commit c8d7bd8bd0c08aa9115589d264e274ed7fdf4c2e
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Sun Jul 23 12:13:37 2017 -0400

    drm/amd/display: move RGAM programming from opp to dpp
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index 5cf985e4ffa9..f8e4724a629d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -37,38 +37,7 @@
 #define CTX \
 	oppn10->base.ctx
 
-static void oppn10_set_regamma_mode(
-	struct output_pixel_processor *opp,
-	enum opp_regamma mode)
-{
-	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
-	uint32_t re_mode = 0;
-	uint32_t obuf_bypass = 0; /* need for pipe split */
-	uint32_t obuf_hupscale = 0;
-
-	switch (mode) {
-	case OPP_REGAMMA_BYPASS:
-		re_mode = 0;
-		break;
-	case OPP_REGAMMA_SRGB:
-		re_mode = 1;
-		break;
-	case OPP_REGAMMA_3_6:
-		re_mode = 2;
-		break;
-	case OPP_REGAMMA_USER:
-		re_mode = oppn10->is_write_to_ram_a_safe ? 3 : 4;
-		oppn10->is_write_to_ram_a_safe = !oppn10->is_write_to_ram_a_safe;
-		break;
-	default:
-		break;
-	}
 
-	REG_SET(CM_RGAM_CONTROL, 0, CM_RGAM_LUT_MODE, re_mode);
-	REG_UPDATE_2(OBUF_CONTROL,
-			OBUF_BYPASS, obuf_bypass,
-			OBUF_H_2X_UPSCALE_EN, obuf_hupscale);
-}
 
 /************* FORMATTER ************/
 
@@ -328,400 +297,6 @@ static void oppn10_program_fmt(
 }
 
 
-/*program re gamma RAM B*/
-static void opp_program_regamma_lutb_settings(
-		struct output_pixel_processor *opp,
-		const struct pwl_params *params)
-{
-	const struct gamma_curve *curve;
-	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
-
-	REG_SET_2(CM_RGAM_RAMB_START_CNTL_B, 0,
-		CM_RGAM_RAMB_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B, 0);
-	REG_SET_2(CM_RGAM_RAMB_START_CNTL_G, 0,
-		CM_RGAM_RAMB_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_G, 0);
-	REG_SET_2(CM_RGAM_RAMB_START_CNTL_R, 0,
-		CM_RGAM_RAMB_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_R, 0);
-
-	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_B, 0,
-		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
-	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_G, 0,
-		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
-	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_R, 0,
-		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
-
-	REG_SET(CM_RGAM_RAMB_END_CNTL1_B, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_B, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMB_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
-
-	REG_SET(CM_RGAM_RAMB_END_CNTL1_G, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_G, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMB_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
-
-	REG_SET(CM_RGAM_RAMB_END_CNTL1_R, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_R, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMB_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
-
-	curve = params->arr_curve_points;
-	REG_SET_4(CM_RGAM_RAMB_REGION_0_1, 0,
-		CM_RGAM_RAMB_EXP_REGION0_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION1_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_2_3, 0,
-		CM_RGAM_RAMB_EXP_REGION2_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION3_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_4_5, 0,
-		CM_RGAM_RAMB_EXP_REGION4_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION5_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_6_7, 0,
-		CM_RGAM_RAMB_EXP_REGION6_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION7_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_8_9, 0,
-		CM_RGAM_RAMB_EXP_REGION8_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION9_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_10_11, 0,
-		CM_RGAM_RAMB_EXP_REGION10_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION11_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_12_13, 0,
-		CM_RGAM_RAMB_EXP_REGION12_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION13_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_14_15, 0,
-		CM_RGAM_RAMB_EXP_REGION14_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION15_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_16_17, 0,
-		CM_RGAM_RAMB_EXP_REGION16_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION17_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_18_19, 0,
-		CM_RGAM_RAMB_EXP_REGION18_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION19_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_20_21, 0,
-		CM_RGAM_RAMB_EXP_REGION20_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION21_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_22_23, 0,
-		CM_RGAM_RAMB_EXP_REGION22_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION23_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_24_25, 0,
-		CM_RGAM_RAMB_EXP_REGION24_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION25_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_26_27, 0,
-		CM_RGAM_RAMB_EXP_REGION26_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION27_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_28_29, 0,
-		CM_RGAM_RAMB_EXP_REGION28_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION29_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_30_31, 0,
-		CM_RGAM_RAMB_EXP_REGION30_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION31_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_32_33, 0,
-		CM_RGAM_RAMB_EXP_REGION32_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION33_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);
-
-}
-
-/*program re gamma RAM A*/
-static void opp_program_regamma_luta_settings(
-		struct output_pixel_processor *opp,
-		const struct pwl_params *params)
-{
-	const struct gamma_curve *curve;
-	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
-
-	REG_SET_2(CM_RGAM_RAMA_START_CNTL_B, 0,
-		CM_RGAM_RAMA_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_B, 0);
-	REG_SET_2(CM_RGAM_RAMA_START_CNTL_G, 0,
-		CM_RGAM_RAMA_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_G, 0);
-	REG_SET_2(CM_RGAM_RAMA_START_CNTL_R, 0,
-		CM_RGAM_RAMA_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_R, 0);
-
-	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_B, 0,
-		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
-	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_G, 0,
-		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
-	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_R, 0,
-		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
-
-	REG_SET(CM_RGAM_RAMA_END_CNTL1_B, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_B, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMA_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
-
-	REG_SET(CM_RGAM_RAMA_END_CNTL1_G, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_G, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMA_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
-
-	REG_SET(CM_RGAM_RAMA_END_CNTL1_R, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_R, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMA_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
-
-	curve = params->arr_curve_points;
-	REG_SET_4(CM_RGAM_RAMA_REGION_0_1, 0,
-		CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_2_3, 0,
-		CM_RGAM_RAMA_EXP_REGION2_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION3_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_4_5, 0,
-		CM_RGAM_RAMA_EXP_REGION4_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION5_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_6_7, 0,
-		CM_RGAM_RAMA_EXP_REGION6_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION7_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_8_9, 0,
-		CM_RGAM_RAMA_EXP_REGION8_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION9_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_10_11, 0,
-		CM_RGAM_RAMA_EXP_REGION10_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION11_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_12_13, 0,
-		CM_RGAM_RAMA_EXP_REGION12_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION13_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_14_15, 0,
-		CM_RGAM_RAMA_EXP_REGION14_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION15_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_16_17, 0,
-		CM_RGAM_RAMA_EXP_REGION16_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION17_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_18_19, 0,
-		CM_RGAM_RAMA_EXP_REGION18_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION19_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_20_21, 0,
-		CM_RGAM_RAMA_EXP_REGION20_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION21_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_22_23, 0,
-		CM_RGAM_RAMA_EXP_REGION22_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION23_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_24_25, 0,
-		CM_RGAM_RAMA_EXP_REGION24_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION25_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_26_27, 0,
-		CM_RGAM_RAMA_EXP_REGION26_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION27_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_28_29, 0,
-		CM_RGAM_RAMA_EXP_REGION28_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION29_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_30_31, 0,
-		CM_RGAM_RAMA_EXP_REGION30_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION31_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_32_33, 0,
-		CM_RGAM_RAMA_EXP_REGION32_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION33_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);
-}
-
-static void opp_configure_regamma_lut(
-		struct output_pixel_processor *opp,
-		bool is_ram_a)
-{
-	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
-
-	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
-			CM_RGAM_LUT_WRITE_EN_MASK, 7);
-	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
-			CM_RGAM_LUT_WRITE_SEL, is_ram_a == true ? 0:1);
-	REG_SET(CM_RGAM_LUT_INDEX, 0, CM_RGAM_LUT_INDEX, 0);
-}
-
-static void oppn10_power_on_regamma_lut(
-	struct output_pixel_processor *opp,
-	bool power_on)
-{
-	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
-	REG_SET(CM_MEM_PWR_CTRL, 0,
-			RGAM_MEM_PWR_FORCE, power_on == true ? 0:1);
-
-}
-
-
-
-
-static void opp_program_regamma_lut(
-		struct output_pixel_processor *opp,
-		const struct pwl_result_data *rgb,
-		uint32_t num)
-{
-	uint32_t i;
-	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
-	for (i = 0 ; i < num; i++) {
-		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].red_reg);
-		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].green_reg);
-		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].blue_reg);
-
-		REG_SET(CM_RGAM_LUT_DATA, 0,
-				CM_RGAM_LUT_DATA, rgb[i].delta_red_reg);
-		REG_SET(CM_RGAM_LUT_DATA, 0,
-				CM_RGAM_LUT_DATA, rgb[i].delta_green_reg);
-		REG_SET(CM_RGAM_LUT_DATA, 0,
-				CM_RGAM_LUT_DATA, rgb[i].delta_blue_reg);
-
-	}
-
-}
-
-static bool oppn10_set_regamma_pwl(
-	struct output_pixel_processor *opp, const struct pwl_params *params)
-{
-	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
-
-	oppn10_power_on_regamma_lut(opp, true);
-	opp_configure_regamma_lut(opp, oppn10->is_write_to_ram_a_safe);
-
-	if (oppn10->is_write_to_ram_a_safe)
-		opp_program_regamma_luta_settings(opp, params);
-	else
-		opp_program_regamma_lutb_settings(opp, params);
-
-	opp_program_regamma_lut(
-		opp, params->rgb_resulted, params->hw_points_num);
-
-	return true;
-}
 
 static void oppn10_set_stereo_polarity(
 		struct output_pixel_processor *opp,
@@ -743,10 +318,7 @@ static void dcn10_opp_destroy(struct output_pixel_processor **opp)
 }
 
 static struct opp_funcs dcn10_opp_funcs = {
-		.opp_power_on_regamma_lut = oppn10_power_on_regamma_lut,
 		.opp_set_dyn_expansion = oppn10_set_dyn_expansion,
-		.opp_program_regamma_pwl = oppn10_set_regamma_pwl,
-		.opp_set_regamma_mode = oppn10_set_regamma_mode,
 		.opp_program_fmt = oppn10_program_fmt,
 		.opp_program_bit_depth_reduction = oppn10_program_bit_depth_reduction,
 		.opp_set_stereo_polarity = oppn10_set_stereo_polarity,

commit 7db90a6b58761577596499ddd90f3c5ace2b716d
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Sat Jul 22 21:58:08 2017 -0400

    drm/amd/display: move ocsc programming from opp to dpp
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Yuehin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index c2aa69deecc2..5cf985e4ffa9 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -327,42 +327,7 @@ static void oppn10_program_fmt(
 	return;
 }
 
-static void oppn10_set_output_csc_default(
-		struct output_pixel_processor *opp,
-		const struct default_adjustment *default_adjust)
-{
 
-	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
-	uint32_t ocsc_mode = 0;
-
-	if (default_adjust != NULL) {
-		switch (default_adjust->out_color_space) {
-		case COLOR_SPACE_SRGB:
-		case COLOR_SPACE_2020_RGB_FULLRANGE:
-			ocsc_mode = 0;
-			break;
-		case COLOR_SPACE_SRGB_LIMITED:
-		case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
-			ocsc_mode = 1;
-			break;
-		case COLOR_SPACE_YCBCR601:
-		case COLOR_SPACE_YCBCR601_LIMITED:
-			ocsc_mode = 2;
-			break;
-		case COLOR_SPACE_YCBCR709:
-		case COLOR_SPACE_YCBCR709_LIMITED:
-		case COLOR_SPACE_2020_YCBCR:
-			ocsc_mode = 3;
-			break;
-		case COLOR_SPACE_UNKNOWN:
-		default:
-			break;
-		}
-	}
-
-	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
-
-}
 /*program re gamma RAM B*/
 static void opp_program_regamma_lutb_settings(
 		struct output_pixel_processor *opp,
@@ -714,117 +679,7 @@ static void oppn10_power_on_regamma_lut(
 }
 
 
-static void oppn10_program_color_matrix(struct dcn10_opp *oppn10,
-		const struct out_csc_color_matrix *tbl_entry)
-{
-	uint32_t mode;
-
-	REG_GET(CM_OCSC_CONTROL, CM_OCSC_MODE, &mode);
-
-	if (tbl_entry == NULL) {
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-
-
-	if (mode == 4) {
-		/*R*/
-		REG_SET_2(CM_OCSC_C11_C12, 0,
-			CM_OCSC_C11, tbl_entry->regval[0],
-			CM_OCSC_C12, tbl_entry->regval[1]);
-
-		REG_SET_2(CM_OCSC_C13_C14, 0,
-			CM_OCSC_C13, tbl_entry->regval[2],
-			CM_OCSC_C14, tbl_entry->regval[3]);
 
-		/*G*/
-		REG_SET_2(CM_OCSC_C21_C22, 0,
-			CM_OCSC_C21, tbl_entry->regval[4],
-			CM_OCSC_C22, tbl_entry->regval[5]);
-
-		REG_SET_2(CM_OCSC_C23_C24, 0,
-			CM_OCSC_C23, tbl_entry->regval[6],
-			CM_OCSC_C24, tbl_entry->regval[7]);
-
-		/*B*/
-		REG_SET_2(CM_OCSC_C31_C32, 0,
-			CM_OCSC_C31, tbl_entry->regval[8],
-			CM_OCSC_C32, tbl_entry->regval[9]);
-
-		REG_SET_2(CM_OCSC_C33_C34, 0,
-			CM_OCSC_C33, tbl_entry->regval[10],
-			CM_OCSC_C34, tbl_entry->regval[11]);
-	} else {
-		/*R*/
-		REG_SET_2(CM_COMB_C11_C12, 0,
-			CM_COMB_C11, tbl_entry->regval[0],
-			CM_COMB_C12, tbl_entry->regval[1]);
-
-		REG_SET_2(CM_COMB_C13_C14, 0,
-			CM_COMB_C13, tbl_entry->regval[2],
-			CM_COMB_C14, tbl_entry->regval[3]);
-
-		/*G*/
-		REG_SET_2(CM_COMB_C21_C22, 0,
-			CM_COMB_C21, tbl_entry->regval[4],
-			CM_COMB_C22, tbl_entry->regval[5]);
-
-		REG_SET_2(CM_COMB_C23_C24, 0,
-			CM_COMB_C23, tbl_entry->regval[6],
-			CM_COMB_C24, tbl_entry->regval[7]);
-
-		/*B*/
-		REG_SET_2(CM_COMB_C31_C32, 0,
-			CM_COMB_C31, tbl_entry->regval[8],
-			CM_COMB_C32, tbl_entry->regval[9]);
-
-		REG_SET_2(CM_COMB_C33_C34, 0,
-			CM_COMB_C33, tbl_entry->regval[10],
-			CM_COMB_C34, tbl_entry->regval[11]);
-	}
-}
-
-static void oppn10_set_output_csc_adjustment(
-		struct output_pixel_processor *opp,
-		const struct out_csc_color_matrix *tbl_entry)
-{
-
-	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
-	//enum csc_color_mode config = CSC_COLOR_MODE_GRAPHICS_OUTPUT_CSC;
-
-
-	uint32_t ocsc_mode = 4;
-
-	/**
-	*if (tbl_entry != NULL) {
-	*	switch (tbl_entry->color_space) {
-	*	case COLOR_SPACE_SRGB:
-	*	case COLOR_SPACE_2020_RGB_FULLRANGE:
-	*		ocsc_mode = 0;
-	*		break;
-	*	case COLOR_SPACE_SRGB_LIMITED:
-	*	case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
-	*		ocsc_mode = 1;
-	*		break;
-	*	case COLOR_SPACE_YCBCR601:
-	*	case COLOR_SPACE_YCBCR601_LIMITED:
-	*		ocsc_mode = 2;
-	*		break;
-	*	case COLOR_SPACE_YCBCR709:
-	*	case COLOR_SPACE_YCBCR709_LIMITED:
-	*	case COLOR_SPACE_2020_YCBCR:
-	*		ocsc_mode = 3;
-	*		break;
-	*	case COLOR_SPACE_UNKNOWN:
-	*	default:
-	*		break;
-	*	}
-	*}
-	*/
-
-	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
-	oppn10_program_color_matrix(oppn10, tbl_entry);
-}
 
 static void opp_program_regamma_lut(
 		struct output_pixel_processor *opp,
@@ -889,8 +744,6 @@ static void dcn10_opp_destroy(struct output_pixel_processor **opp)
 
 static struct opp_funcs dcn10_opp_funcs = {
 		.opp_power_on_regamma_lut = oppn10_power_on_regamma_lut,
-		.opp_set_csc_adjustment = oppn10_set_output_csc_adjustment,
-		.opp_set_csc_default = oppn10_set_output_csc_default,
 		.opp_set_dyn_expansion = oppn10_set_dyn_expansion,
 		.opp_program_regamma_pwl = oppn10_set_regamma_pwl,
 		.opp_set_regamma_mode = oppn10_set_regamma_mode,

commit 8748068764e7a50ac787c1c17f402f3fbbe97ccc
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Sun Jul 23 15:18:57 2017 -0400

    drm/amd/display: add idle wait for passive surface update and modeset
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index 669ac4b67ea9..c2aa69deecc2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -907,10 +907,14 @@ void dcn10_opp_construct(struct dcn10_opp *oppn10,
 	const struct dcn10_opp_shift *opp_shift,
 	const struct dcn10_opp_mask *opp_mask)
 {
+	int i;
 	oppn10->base.ctx = ctx;
 	oppn10->base.inst = inst;
 	oppn10->base.funcs = &dcn10_opp_funcs;
 
+	for (i = 0; i < MAX_PIPES; i++)
+		oppn10->base.mpcc_disconnect_pending[i] = false;
+
 	oppn10->regs = regs;
 	oppn10->opp_shift = opp_shift;
 	oppn10->opp_mask = opp_mask;

commit 0b6ab57e7ffad05ca266fed9764119cf1807b81b
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jul 5 12:00:28 2017 -0400

    drm/amd/display: get dal1.1 to run
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index e6f2220415e8..669ac4b67ea9 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -784,7 +784,7 @@ static void oppn10_program_color_matrix(struct dcn10_opp *oppn10,
 	}
 }
 
-void oppn10_set_output_csc_adjustment(
+static void oppn10_set_output_csc_adjustment(
 		struct output_pixel_processor *opp,
 		const struct out_csc_color_matrix *tbl_entry)
 {

commit 13066f9f648084b5016cebfa7930ce4c056ab9d6
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jun 28 18:41:22 2017 -0400

    drm/amd/display: Rename DCN opp specific function prefixes to oppn10
    
    Also update relevant registers.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index a07401004f44..e6f2220415e8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -37,7 +37,7 @@
 #define CTX \
 	oppn10->base.ctx
 
-static void opp_set_regamma_mode(
+static void oppn10_set_regamma_mode(
 	struct output_pixel_processor *opp,
 	enum opp_regamma mode)
 {
@@ -167,7 +167,7 @@ static void set_spatial_dither(
 			FMT_RGB_RANDOM_ENABLE, params->flags.RGB_RANDOM);
 }
 
-static void opp_program_bit_depth_reduction(
+static void oppn10_program_bit_depth_reduction(
 	struct output_pixel_processor *opp,
 	const struct bit_depth_reduction_params *params)
 {
@@ -255,7 +255,7 @@ static void opp_set_clamping(
 
 }
 
-static void opp_set_dyn_expansion(
+static void oppn10_set_dyn_expansion(
 	struct output_pixel_processor *opp,
 	enum dc_color_space color_sp,
 	enum dc_color_depth color_dpth,
@@ -304,7 +304,7 @@ static void opp_program_clamping_and_pixel_encoding(
 	set_pixel_encoding(oppn10, params);
 }
 
-static void opp_program_fmt(
+static void oppn10_program_fmt(
 	struct output_pixel_processor *opp,
 	struct bit_depth_reduction_params *fmt_bit_depth,
 	struct clamping_and_pixel_encoding_params *clamping)
@@ -316,7 +316,7 @@ static void opp_program_fmt(
 
 	/* dithering is affected by <CrtcSourceSelect>, hence should be
 	 * programmed afterwards */
-	opp_program_bit_depth_reduction(
+	oppn10_program_bit_depth_reduction(
 		opp,
 		fmt_bit_depth);
 
@@ -327,7 +327,7 @@ static void opp_program_fmt(
 	return;
 }
 
-static void opp_set_output_csc_default(
+static void oppn10_set_output_csc_default(
 		struct output_pixel_processor *opp,
 		const struct default_adjustment *default_adjust)
 {
@@ -703,7 +703,7 @@ static void opp_configure_regamma_lut(
 	REG_SET(CM_RGAM_LUT_INDEX, 0, CM_RGAM_LUT_INDEX, 0);
 }
 
-static void opp_power_on_regamma_lut(
+static void oppn10_power_on_regamma_lut(
 	struct output_pixel_processor *opp,
 	bool power_on)
 {
@@ -713,7 +713,78 @@ static void opp_power_on_regamma_lut(
 
 }
 
-void opp_set_output_csc_adjustment(
+
+static void oppn10_program_color_matrix(struct dcn10_opp *oppn10,
+		const struct out_csc_color_matrix *tbl_entry)
+{
+	uint32_t mode;
+
+	REG_GET(CM_OCSC_CONTROL, CM_OCSC_MODE, &mode);
+
+	if (tbl_entry == NULL) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+
+	if (mode == 4) {
+		/*R*/
+		REG_SET_2(CM_OCSC_C11_C12, 0,
+			CM_OCSC_C11, tbl_entry->regval[0],
+			CM_OCSC_C12, tbl_entry->regval[1]);
+
+		REG_SET_2(CM_OCSC_C13_C14, 0,
+			CM_OCSC_C13, tbl_entry->regval[2],
+			CM_OCSC_C14, tbl_entry->regval[3]);
+
+		/*G*/
+		REG_SET_2(CM_OCSC_C21_C22, 0,
+			CM_OCSC_C21, tbl_entry->regval[4],
+			CM_OCSC_C22, tbl_entry->regval[5]);
+
+		REG_SET_2(CM_OCSC_C23_C24, 0,
+			CM_OCSC_C23, tbl_entry->regval[6],
+			CM_OCSC_C24, tbl_entry->regval[7]);
+
+		/*B*/
+		REG_SET_2(CM_OCSC_C31_C32, 0,
+			CM_OCSC_C31, tbl_entry->regval[8],
+			CM_OCSC_C32, tbl_entry->regval[9]);
+
+		REG_SET_2(CM_OCSC_C33_C34, 0,
+			CM_OCSC_C33, tbl_entry->regval[10],
+			CM_OCSC_C34, tbl_entry->regval[11]);
+	} else {
+		/*R*/
+		REG_SET_2(CM_COMB_C11_C12, 0,
+			CM_COMB_C11, tbl_entry->regval[0],
+			CM_COMB_C12, tbl_entry->regval[1]);
+
+		REG_SET_2(CM_COMB_C13_C14, 0,
+			CM_COMB_C13, tbl_entry->regval[2],
+			CM_COMB_C14, tbl_entry->regval[3]);
+
+		/*G*/
+		REG_SET_2(CM_COMB_C21_C22, 0,
+			CM_COMB_C21, tbl_entry->regval[4],
+			CM_COMB_C22, tbl_entry->regval[5]);
+
+		REG_SET_2(CM_COMB_C23_C24, 0,
+			CM_COMB_C23, tbl_entry->regval[6],
+			CM_COMB_C24, tbl_entry->regval[7]);
+
+		/*B*/
+		REG_SET_2(CM_COMB_C31_C32, 0,
+			CM_COMB_C31, tbl_entry->regval[8],
+			CM_COMB_C32, tbl_entry->regval[9]);
+
+		REG_SET_2(CM_COMB_C33_C34, 0,
+			CM_COMB_C33, tbl_entry->regval[10],
+			CM_COMB_C34, tbl_entry->regval[11]);
+	}
+}
+
+void oppn10_set_output_csc_adjustment(
 		struct output_pixel_processor *opp,
 		const struct out_csc_color_matrix *tbl_entry)
 {
@@ -752,7 +823,7 @@ void opp_set_output_csc_adjustment(
 	*/
 
 	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
-	program_color_matrix(oppn10, tbl_entry);
+	oppn10_program_color_matrix(oppn10, tbl_entry);
 }
 
 static void opp_program_regamma_lut(
@@ -778,20 +849,18 @@ static void opp_program_regamma_lut(
 
 }
 
-
-
-static bool opp_set_regamma_pwl(
+static bool oppn10_set_regamma_pwl(
 	struct output_pixel_processor *opp, const struct pwl_params *params)
 {
 	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
 
-	opp_power_on_regamma_lut(opp, true);
+	oppn10_power_on_regamma_lut(opp, true);
 	opp_configure_regamma_lut(opp, oppn10->is_write_to_ram_a_safe);
 
 	if (oppn10->is_write_to_ram_a_safe)
-		 opp_program_regamma_luta_settings(opp, params);
+		opp_program_regamma_luta_settings(opp, params);
 	else
-		 opp_program_regamma_lutb_settings(opp, params);
+		opp_program_regamma_lutb_settings(opp, params);
 
 	opp_program_regamma_lut(
 		opp, params->rgb_resulted, params->hw_points_num);
@@ -799,7 +868,7 @@ static bool opp_set_regamma_pwl(
 	return true;
 }
 
-static void opp_set_stereo_polarity(
+static void oppn10_set_stereo_polarity(
 		struct output_pixel_processor *opp,
 		bool enable, bool rightEyePolarity)
 {
@@ -819,15 +888,15 @@ static void dcn10_opp_destroy(struct output_pixel_processor **opp)
 }
 
 static struct opp_funcs dcn10_opp_funcs = {
-		.opp_power_on_regamma_lut = opp_power_on_regamma_lut,
-		.opp_set_csc_adjustment = opp_set_output_csc_adjustment,
-		.opp_set_csc_default = opp_set_output_csc_default,
-		.opp_set_dyn_expansion = opp_set_dyn_expansion,
-		.opp_program_regamma_pwl = opp_set_regamma_pwl,
-		.opp_set_regamma_mode = opp_set_regamma_mode,
-		.opp_program_fmt = opp_program_fmt,
-		.opp_program_bit_depth_reduction = opp_program_bit_depth_reduction,
-		.opp_set_stereo_polarity = opp_set_stereo_polarity,
+		.opp_power_on_regamma_lut = oppn10_power_on_regamma_lut,
+		.opp_set_csc_adjustment = oppn10_set_output_csc_adjustment,
+		.opp_set_csc_default = oppn10_set_output_csc_default,
+		.opp_set_dyn_expansion = oppn10_set_dyn_expansion,
+		.opp_program_regamma_pwl = oppn10_set_regamma_pwl,
+		.opp_set_regamma_mode = oppn10_set_regamma_mode,
+		.opp_program_fmt = oppn10_program_fmt,
+		.opp_program_bit_depth_reduction = oppn10_program_bit_depth_reduction,
+		.opp_set_stereo_polarity = oppn10_set_stereo_polarity,
 		.opp_destroy = dcn10_opp_destroy
 };
 
@@ -847,73 +916,3 @@ void dcn10_opp_construct(struct dcn10_opp *oppn10,
 	oppn10->opp_mask = opp_mask;
 }
 
-
-void program_color_matrix(struct dcn10_opp *oppn10,
-		const struct out_csc_color_matrix *tbl_entry)
-{
-	uint32_t mode;
-
-	REG_GET(CM_OCSC_CONTROL, CM_OCSC_MODE, &mode);
-
-	if (tbl_entry == NULL) {
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-
-
-	if (mode == 4) {
-		/*R*/
-		REG_SET_2(CM_OCSC_C11_C12, 0,
-			CM_OCSC_C11, tbl_entry->regval[0],
-			CM_OCSC_C12, tbl_entry->regval[1]);
-
-		REG_SET_2(CM_OCSC_C13_C14, 0,
-			CM_OCSC_C13, tbl_entry->regval[2],
-			CM_OCSC_C14, tbl_entry->regval[3]);
-
-		/*G*/
-		REG_SET_2(CM_OCSC_C21_C22, 0,
-			CM_OCSC_C21, tbl_entry->regval[4],
-			CM_OCSC_C22, tbl_entry->regval[5]);
-
-		REG_SET_2(CM_OCSC_C23_C24, 0,
-			CM_OCSC_C23, tbl_entry->regval[6],
-			CM_OCSC_C24, tbl_entry->regval[7]);
-
-		/*B*/
-		REG_SET_2(CM_OCSC_C31_C32, 0,
-			CM_OCSC_C31, tbl_entry->regval[8],
-			CM_OCSC_C32, tbl_entry->regval[9]);
-
-		REG_SET_2(CM_OCSC_C33_C34, 0,
-			CM_OCSC_C33, tbl_entry->regval[10],
-			CM_OCSC_C34, tbl_entry->regval[11]);
-	} else {
-		/*R*/
-		REG_SET_2(CM_COMB_C11_C12, 0,
-			CM_COMB_C11, tbl_entry->regval[0],
-			CM_COMB_C12, tbl_entry->regval[1]);
-
-		REG_SET_2(CM_COMB_C13_C14, 0,
-			CM_COMB_C13, tbl_entry->regval[2],
-			CM_COMB_C14, tbl_entry->regval[3]);
-
-		/*G*/
-		REG_SET_2(CM_COMB_C21_C22, 0,
-			CM_COMB_C21, tbl_entry->regval[4],
-			CM_COMB_C22, tbl_entry->regval[5]);
-
-		REG_SET_2(CM_COMB_C23_C24, 0,
-			CM_COMB_C23, tbl_entry->regval[6],
-			CM_COMB_C24, tbl_entry->regval[7]);
-
-		/*B*/
-		REG_SET_2(CM_COMB_C31_C32, 0,
-			CM_COMB_C31, tbl_entry->regval[8],
-			CM_COMB_C32, tbl_entry->regval[9]);
-
-		REG_SET_2(CM_COMB_C33_C34, 0,
-			CM_COMB_C33, tbl_entry->regval[10],
-			CM_COMB_C34, tbl_entry->regval[11]);
-	}
-}

commit abe07e80836fb25a5bcfda573413a68be82439c6
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Wed Jun 28 17:21:42 2017 -0400

    drm/amd/display: Add DC interface for custom CSC matrix
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Vitaly Prosyak <Vitaly.Prosyak@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index 148e192f5f76..a07401004f44 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -713,6 +713,48 @@ static void opp_power_on_regamma_lut(
 
 }
 
+void opp_set_output_csc_adjustment(
+		struct output_pixel_processor *opp,
+		const struct out_csc_color_matrix *tbl_entry)
+{
+
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+	//enum csc_color_mode config = CSC_COLOR_MODE_GRAPHICS_OUTPUT_CSC;
+
+
+	uint32_t ocsc_mode = 4;
+
+	/**
+	*if (tbl_entry != NULL) {
+	*	switch (tbl_entry->color_space) {
+	*	case COLOR_SPACE_SRGB:
+	*	case COLOR_SPACE_2020_RGB_FULLRANGE:
+	*		ocsc_mode = 0;
+	*		break;
+	*	case COLOR_SPACE_SRGB_LIMITED:
+	*	case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
+	*		ocsc_mode = 1;
+	*		break;
+	*	case COLOR_SPACE_YCBCR601:
+	*	case COLOR_SPACE_YCBCR601_LIMITED:
+	*		ocsc_mode = 2;
+	*		break;
+	*	case COLOR_SPACE_YCBCR709:
+	*	case COLOR_SPACE_YCBCR709_LIMITED:
+	*	case COLOR_SPACE_2020_YCBCR:
+	*		ocsc_mode = 3;
+	*		break;
+	*	case COLOR_SPACE_UNKNOWN:
+	*	default:
+	*		break;
+	*	}
+	*}
+	*/
+
+	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
+	program_color_matrix(oppn10, tbl_entry);
+}
+
 static void opp_program_regamma_lut(
 		struct output_pixel_processor *opp,
 		const struct pwl_result_data *rgb,
@@ -736,6 +778,8 @@ static void opp_program_regamma_lut(
 
 }
 
+
+
 static bool opp_set_regamma_pwl(
 	struct output_pixel_processor *opp, const struct pwl_params *params)
 {
@@ -776,7 +820,7 @@ static void dcn10_opp_destroy(struct output_pixel_processor **opp)
 
 static struct opp_funcs dcn10_opp_funcs = {
 		.opp_power_on_regamma_lut = opp_power_on_regamma_lut,
-		.opp_set_csc_adjustment = NULL,
+		.opp_set_csc_adjustment = opp_set_output_csc_adjustment,
 		.opp_set_csc_default = opp_set_output_csc_default,
 		.opp_set_dyn_expansion = opp_set_dyn_expansion,
 		.opp_program_regamma_pwl = opp_set_regamma_pwl,
@@ -802,3 +846,74 @@ void dcn10_opp_construct(struct dcn10_opp *oppn10,
 	oppn10->opp_shift = opp_shift;
 	oppn10->opp_mask = opp_mask;
 }
+
+
+void program_color_matrix(struct dcn10_opp *oppn10,
+		const struct out_csc_color_matrix *tbl_entry)
+{
+	uint32_t mode;
+
+	REG_GET(CM_OCSC_CONTROL, CM_OCSC_MODE, &mode);
+
+	if (tbl_entry == NULL) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+
+	if (mode == 4) {
+		/*R*/
+		REG_SET_2(CM_OCSC_C11_C12, 0,
+			CM_OCSC_C11, tbl_entry->regval[0],
+			CM_OCSC_C12, tbl_entry->regval[1]);
+
+		REG_SET_2(CM_OCSC_C13_C14, 0,
+			CM_OCSC_C13, tbl_entry->regval[2],
+			CM_OCSC_C14, tbl_entry->regval[3]);
+
+		/*G*/
+		REG_SET_2(CM_OCSC_C21_C22, 0,
+			CM_OCSC_C21, tbl_entry->regval[4],
+			CM_OCSC_C22, tbl_entry->regval[5]);
+
+		REG_SET_2(CM_OCSC_C23_C24, 0,
+			CM_OCSC_C23, tbl_entry->regval[6],
+			CM_OCSC_C24, tbl_entry->regval[7]);
+
+		/*B*/
+		REG_SET_2(CM_OCSC_C31_C32, 0,
+			CM_OCSC_C31, tbl_entry->regval[8],
+			CM_OCSC_C32, tbl_entry->regval[9]);
+
+		REG_SET_2(CM_OCSC_C33_C34, 0,
+			CM_OCSC_C33, tbl_entry->regval[10],
+			CM_OCSC_C34, tbl_entry->regval[11]);
+	} else {
+		/*R*/
+		REG_SET_2(CM_COMB_C11_C12, 0,
+			CM_COMB_C11, tbl_entry->regval[0],
+			CM_COMB_C12, tbl_entry->regval[1]);
+
+		REG_SET_2(CM_COMB_C13_C14, 0,
+			CM_COMB_C13, tbl_entry->regval[2],
+			CM_COMB_C14, tbl_entry->regval[3]);
+
+		/*G*/
+		REG_SET_2(CM_COMB_C21_C22, 0,
+			CM_COMB_C21, tbl_entry->regval[4],
+			CM_COMB_C22, tbl_entry->regval[5]);
+
+		REG_SET_2(CM_COMB_C23_C24, 0,
+			CM_COMB_C23, tbl_entry->regval[6],
+			CM_COMB_C24, tbl_entry->regval[7]);
+
+		/*B*/
+		REG_SET_2(CM_COMB_C31_C32, 0,
+			CM_COMB_C31, tbl_entry->regval[8],
+			CM_COMB_C32, tbl_entry->regval[9]);
+
+		REG_SET_2(CM_COMB_C33_C34, 0,
+			CM_COMB_C33, tbl_entry->regval[10],
+			CM_COMB_C34, tbl_entry->regval[11]);
+	}
+}

commit 747be97f4ea7de8078739f04e241b5819015f035
Author: Amy Zhang <Amy.Zhang@amd.com>
Date:   Thu May 11 17:13:20 2017 -0400

    drm/amd/display: Program CSC Mode For BT2020
    
    - Add BT2020 color space in the set output csc default
    
    Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
index fce08e5235e6..148e192f5f76 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -338,9 +338,11 @@ static void opp_set_output_csc_default(
 	if (default_adjust != NULL) {
 		switch (default_adjust->out_color_space) {
 		case COLOR_SPACE_SRGB:
+		case COLOR_SPACE_2020_RGB_FULLRANGE:
 			ocsc_mode = 0;
 			break;
 		case COLOR_SPACE_SRGB_LIMITED:
+		case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
 			ocsc_mode = 1;
 			break;
 		case COLOR_SPACE_YCBCR601:
@@ -349,6 +351,7 @@ static void opp_set_output_csc_default(
 			break;
 		case COLOR_SPACE_YCBCR709:
 		case COLOR_SPACE_YCBCR709_LIMITED:
+		case COLOR_SPACE_2020_YCBCR:
 			ocsc_mode = 3;
 			break;
 		case COLOR_SPACE_UNKNOWN:

commit 70ccab604049bbb995a57ab3b7fe8a3c2fdbb736
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon May 8 15:19:06 2017 -0400

    drm/amdgpu/display: Add core dc support for DCN
    
    Core display support for DCN.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
new file mode 100644
index 000000000000..fce08e5235e6
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_opp.c
@@ -0,0 +1,801 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dm_services.h"
+#include "dcn10_opp.h"
+#include "reg_helper.h"
+
+#define REG(reg) \
+	(oppn10->regs->reg)
+
+#undef FN
+#define FN(reg_name, field_name) \
+	oppn10->opp_shift->field_name, oppn10->opp_mask->field_name
+
+#define CTX \
+	oppn10->base.ctx
+
+static void opp_set_regamma_mode(
+	struct output_pixel_processor *opp,
+	enum opp_regamma mode)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+	uint32_t re_mode = 0;
+	uint32_t obuf_bypass = 0; /* need for pipe split */
+	uint32_t obuf_hupscale = 0;
+
+	switch (mode) {
+	case OPP_REGAMMA_BYPASS:
+		re_mode = 0;
+		break;
+	case OPP_REGAMMA_SRGB:
+		re_mode = 1;
+		break;
+	case OPP_REGAMMA_3_6:
+		re_mode = 2;
+		break;
+	case OPP_REGAMMA_USER:
+		re_mode = oppn10->is_write_to_ram_a_safe ? 3 : 4;
+		oppn10->is_write_to_ram_a_safe = !oppn10->is_write_to_ram_a_safe;
+		break;
+	default:
+		break;
+	}
+
+	REG_SET(CM_RGAM_CONTROL, 0, CM_RGAM_LUT_MODE, re_mode);
+	REG_UPDATE_2(OBUF_CONTROL,
+			OBUF_BYPASS, obuf_bypass,
+			OBUF_H_2X_UPSCALE_EN, obuf_hupscale);
+}
+
+/************* FORMATTER ************/
+
+/**
+ *	set_truncation
+ *	1) set truncation depth: 0 for 18 bpp or 1 for 24 bpp
+ *	2) enable truncation
+ *	3) HW remove 12bit FMT support for DCE11 power saving reason.
+ */
+static void set_truncation(
+		struct dcn10_opp *oppn10,
+		const struct bit_depth_reduction_params *params)
+{
+	REG_UPDATE_3(FMT_BIT_DEPTH_CONTROL,
+		FMT_TRUNCATE_EN, params->flags.TRUNCATE_ENABLED,
+		FMT_TRUNCATE_DEPTH, params->flags.TRUNCATE_DEPTH,
+		FMT_TRUNCATE_MODE, params->flags.TRUNCATE_MODE);
+}
+
+static void set_spatial_dither(
+	struct dcn10_opp *oppn10,
+	const struct bit_depth_reduction_params *params)
+{
+	/*Disable spatial (random) dithering*/
+	REG_UPDATE_7(FMT_BIT_DEPTH_CONTROL,
+			FMT_SPATIAL_DITHER_EN, 0,
+			FMT_SPATIAL_DITHER_MODE, 0,
+			FMT_SPATIAL_DITHER_DEPTH, 0,
+			FMT_TEMPORAL_DITHER_EN, 0,
+			FMT_HIGHPASS_RANDOM_ENABLE, 0,
+			FMT_FRAME_RANDOM_ENABLE, 0,
+			FMT_RGB_RANDOM_ENABLE, 0);
+
+
+	/* only use FRAME_COUNTER_MAX if frameRandom == 1*/
+	if (params->flags.FRAME_RANDOM == 1) {
+		if (params->flags.SPATIAL_DITHER_DEPTH == 0 || params->flags.SPATIAL_DITHER_DEPTH == 1) {
+			REG_UPDATE_2(FMT_CONTROL,
+					FMT_SPATIAL_DITHER_FRAME_COUNTER_MAX, 15,
+					FMT_SPATIAL_DITHER_FRAME_COUNTER_BIT_SWAP, 2);
+		} else if (params->flags.SPATIAL_DITHER_DEPTH == 2) {
+			REG_UPDATE_2(FMT_CONTROL,
+					FMT_SPATIAL_DITHER_FRAME_COUNTER_MAX, 3,
+					FMT_SPATIAL_DITHER_FRAME_COUNTER_BIT_SWAP, 1);
+		} else {
+			return;
+		}
+	} else {
+		REG_UPDATE_2(FMT_CONTROL,
+				FMT_SPATIAL_DITHER_FRAME_COUNTER_MAX, 0,
+				FMT_SPATIAL_DITHER_FRAME_COUNTER_BIT_SWAP, 0);
+	}
+
+	/*Set seed for random values for
+	 * spatial dithering for R,G,B channels*/
+
+	REG_SET(FMT_DITHER_RAND_R_SEED, 0,
+			FMT_RAND_R_SEED, params->r_seed_value);
+
+	REG_SET(FMT_DITHER_RAND_G_SEED, 0,
+			FMT_RAND_G_SEED, params->g_seed_value);
+
+	REG_SET(FMT_DITHER_RAND_B_SEED, 0,
+			FMT_RAND_B_SEED, params->b_seed_value);
+
+	/* FMT_OFFSET_R_Cr  31:16 0x0 Setting the zero
+	 * offset for the R/Cr channel, lower 4LSB
+	 * is forced to zeros. Typically set to 0
+	 * RGB and 0x80000 YCbCr.
+	 */
+	/* FMT_OFFSET_G_Y   31:16 0x0 Setting the zero
+	 * offset for the G/Y  channel, lower 4LSB is
+	 * forced to zeros. Typically set to 0 RGB
+	 * and 0x80000 YCbCr.
+	 */
+	/* FMT_OFFSET_B_Cb  31:16 0x0 Setting the zero
+	 * offset for the B/Cb channel, lower 4LSB is
+	 * forced to zeros. Typically set to 0 RGB and
+	 * 0x80000 YCbCr.
+	 */
+
+	REG_UPDATE_6(FMT_BIT_DEPTH_CONTROL,
+			/*Enable spatial dithering*/
+			FMT_SPATIAL_DITHER_EN, params->flags.SPATIAL_DITHER_ENABLED,
+			/* Set spatial dithering mode
+			 * (default is Seed patterrn AAAA...)
+			 */
+			FMT_SPATIAL_DITHER_MODE, params->flags.SPATIAL_DITHER_MODE,
+			/*Set spatial dithering bit depth*/
+			FMT_SPATIAL_DITHER_DEPTH, params->flags.SPATIAL_DITHER_DEPTH,
+			/*Disable High pass filter*/
+			FMT_HIGHPASS_RANDOM_ENABLE, params->flags.HIGHPASS_RANDOM,
+			/*Reset only at startup*/
+			FMT_FRAME_RANDOM_ENABLE, params->flags.FRAME_RANDOM,
+			/*Set RGB data dithered with x^28+x^3+1*/
+			FMT_RGB_RANDOM_ENABLE, params->flags.RGB_RANDOM);
+}
+
+static void opp_program_bit_depth_reduction(
+	struct output_pixel_processor *opp,
+	const struct bit_depth_reduction_params *params)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	set_truncation(oppn10, params);
+	set_spatial_dither(oppn10, params);
+	/* TODO
+	 * set_temporal_dither(oppn10, params);
+	 */
+}
+
+/**
+ *	set_pixel_encoding
+ *
+ *	Set Pixel Encoding
+ *		0: RGB 4:4:4 or YCbCr 4:4:4 or YOnly
+ *		1: YCbCr 4:2:2
+ */
+static void set_pixel_encoding(
+	struct dcn10_opp *oppn10,
+	const struct clamping_and_pixel_encoding_params *params)
+{
+	switch (params->pixel_encoding)	{
+
+	case PIXEL_ENCODING_RGB:
+	case PIXEL_ENCODING_YCBCR444:
+		REG_UPDATE(FMT_CONTROL, FMT_PIXEL_ENCODING, 0);
+		break;
+	case PIXEL_ENCODING_YCBCR422:
+		REG_UPDATE(FMT_CONTROL, FMT_PIXEL_ENCODING, 1);
+		break;
+	case PIXEL_ENCODING_YCBCR420:
+		REG_UPDATE(FMT_CONTROL, FMT_PIXEL_ENCODING, 2);
+		break;
+	default:
+		break;
+	}
+}
+
+/**
+ *	Set Clamping
+ *	1) Set clamping format based on bpc - 0 for 6bpc (No clamping)
+ *		1 for 8 bpc
+ *		2 for 10 bpc
+ *		3 for 12 bpc
+ *		7 for programable
+ *	2) Enable clamp if Limited range requested
+ */
+static void opp_set_clamping(
+	struct dcn10_opp *oppn10,
+	const struct clamping_and_pixel_encoding_params *params)
+{
+	REG_UPDATE_2(FMT_CLAMP_CNTL,
+			FMT_CLAMP_DATA_EN, 0,
+			FMT_CLAMP_COLOR_FORMAT, 0);
+
+	switch (params->clamping_level) {
+	case CLAMPING_FULL_RANGE:
+		REG_UPDATE_2(FMT_CLAMP_CNTL,
+				FMT_CLAMP_DATA_EN, 1,
+				FMT_CLAMP_COLOR_FORMAT, 0);
+		break;
+	case CLAMPING_LIMITED_RANGE_8BPC:
+		REG_UPDATE_2(FMT_CLAMP_CNTL,
+				FMT_CLAMP_DATA_EN, 1,
+				FMT_CLAMP_COLOR_FORMAT, 1);
+		break;
+	case CLAMPING_LIMITED_RANGE_10BPC:
+		REG_UPDATE_2(FMT_CLAMP_CNTL,
+				FMT_CLAMP_DATA_EN, 1,
+				FMT_CLAMP_COLOR_FORMAT, 2);
+
+		break;
+	case CLAMPING_LIMITED_RANGE_12BPC:
+		REG_UPDATE_2(FMT_CLAMP_CNTL,
+				FMT_CLAMP_DATA_EN, 1,
+				FMT_CLAMP_COLOR_FORMAT, 3);
+		break;
+	case CLAMPING_LIMITED_RANGE_PROGRAMMABLE:
+		/* TODO */
+	default:
+		break;
+	}
+
+}
+
+static void opp_set_dyn_expansion(
+	struct output_pixel_processor *opp,
+	enum dc_color_space color_sp,
+	enum dc_color_depth color_dpth,
+	enum signal_type signal)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	REG_UPDATE_2(FMT_DYNAMIC_EXP_CNTL,
+			FMT_DYNAMIC_EXP_EN, 0,
+			FMT_DYNAMIC_EXP_MODE, 0);
+
+	/*00 - 10-bit -> 12-bit dynamic expansion*/
+	/*01 - 8-bit  -> 12-bit dynamic expansion*/
+	if (signal == SIGNAL_TYPE_HDMI_TYPE_A ||
+		signal == SIGNAL_TYPE_DISPLAY_PORT ||
+		signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {
+		switch (color_dpth) {
+		case COLOR_DEPTH_888:
+			REG_UPDATE_2(FMT_DYNAMIC_EXP_CNTL,
+				FMT_DYNAMIC_EXP_EN, 1,
+				FMT_DYNAMIC_EXP_MODE, 1);
+			break;
+		case COLOR_DEPTH_101010:
+			REG_UPDATE_2(FMT_DYNAMIC_EXP_CNTL,
+				FMT_DYNAMIC_EXP_EN, 1,
+				FMT_DYNAMIC_EXP_MODE, 0);
+			break;
+		case COLOR_DEPTH_121212:
+			REG_UPDATE_2(FMT_DYNAMIC_EXP_CNTL,
+				FMT_DYNAMIC_EXP_EN, 1,/*otherwise last two bits are zero*/
+				FMT_DYNAMIC_EXP_MODE, 0);
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+static void opp_program_clamping_and_pixel_encoding(
+	struct output_pixel_processor *opp,
+	const struct clamping_and_pixel_encoding_params *params)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	opp_set_clamping(oppn10, params);
+	set_pixel_encoding(oppn10, params);
+}
+
+static void opp_program_fmt(
+	struct output_pixel_processor *opp,
+	struct bit_depth_reduction_params *fmt_bit_depth,
+	struct clamping_and_pixel_encoding_params *clamping)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	if (clamping->pixel_encoding == PIXEL_ENCODING_YCBCR420)
+		REG_UPDATE(FMT_MAP420_MEMORY_CONTROL, FMT_MAP420MEM_PWR_FORCE, 0);
+
+	/* dithering is affected by <CrtcSourceSelect>, hence should be
+	 * programmed afterwards */
+	opp_program_bit_depth_reduction(
+		opp,
+		fmt_bit_depth);
+
+	opp_program_clamping_and_pixel_encoding(
+		opp,
+		clamping);
+
+	return;
+}
+
+static void opp_set_output_csc_default(
+		struct output_pixel_processor *opp,
+		const struct default_adjustment *default_adjust)
+{
+
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+	uint32_t ocsc_mode = 0;
+
+	if (default_adjust != NULL) {
+		switch (default_adjust->out_color_space) {
+		case COLOR_SPACE_SRGB:
+			ocsc_mode = 0;
+			break;
+		case COLOR_SPACE_SRGB_LIMITED:
+			ocsc_mode = 1;
+			break;
+		case COLOR_SPACE_YCBCR601:
+		case COLOR_SPACE_YCBCR601_LIMITED:
+			ocsc_mode = 2;
+			break;
+		case COLOR_SPACE_YCBCR709:
+		case COLOR_SPACE_YCBCR709_LIMITED:
+			ocsc_mode = 3;
+			break;
+		case COLOR_SPACE_UNKNOWN:
+		default:
+			break;
+		}
+	}
+
+	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
+
+}
+/*program re gamma RAM B*/
+static void opp_program_regamma_lutb_settings(
+		struct output_pixel_processor *opp,
+		const struct pwl_params *params)
+{
+	const struct gamma_curve *curve;
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	REG_SET_2(CM_RGAM_RAMB_START_CNTL_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B, 0);
+	REG_SET_2(CM_RGAM_RAMB_START_CNTL_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_G, 0);
+	REG_SET_2(CM_RGAM_RAMB_START_CNTL_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_R, 0);
+
+	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_RGAM_RAMB_END_CNTL1_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMB_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMB_END_CNTL1_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMB_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMB_END_CNTL1_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMB_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
+
+	curve = params->arr_curve_points;
+	REG_SET_4(CM_RGAM_RAMB_REGION_0_1, 0,
+		CM_RGAM_RAMB_EXP_REGION0_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION1_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_2_3, 0,
+		CM_RGAM_RAMB_EXP_REGION2_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION3_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_4_5, 0,
+		CM_RGAM_RAMB_EXP_REGION4_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION5_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_6_7, 0,
+		CM_RGAM_RAMB_EXP_REGION6_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION7_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_8_9, 0,
+		CM_RGAM_RAMB_EXP_REGION8_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION9_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_10_11, 0,
+		CM_RGAM_RAMB_EXP_REGION10_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION11_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_12_13, 0,
+		CM_RGAM_RAMB_EXP_REGION12_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION13_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_14_15, 0,
+		CM_RGAM_RAMB_EXP_REGION14_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION15_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_16_17, 0,
+		CM_RGAM_RAMB_EXP_REGION16_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION17_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_18_19, 0,
+		CM_RGAM_RAMB_EXP_REGION18_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION19_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_20_21, 0,
+		CM_RGAM_RAMB_EXP_REGION20_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION21_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_22_23, 0,
+		CM_RGAM_RAMB_EXP_REGION22_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION23_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_24_25, 0,
+		CM_RGAM_RAMB_EXP_REGION24_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION25_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_26_27, 0,
+		CM_RGAM_RAMB_EXP_REGION26_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION27_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_28_29, 0,
+		CM_RGAM_RAMB_EXP_REGION28_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION29_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_30_31, 0,
+		CM_RGAM_RAMB_EXP_REGION30_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION31_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_32_33, 0,
+		CM_RGAM_RAMB_EXP_REGION32_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION33_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);
+
+}
+
+/*program re gamma RAM A*/
+static void opp_program_regamma_luta_settings(
+		struct output_pixel_processor *opp,
+		const struct pwl_params *params)
+{
+	const struct gamma_curve *curve;
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	REG_SET_2(CM_RGAM_RAMA_START_CNTL_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_B, 0);
+	REG_SET_2(CM_RGAM_RAMA_START_CNTL_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_G, 0);
+	REG_SET_2(CM_RGAM_RAMA_START_CNTL_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_R, 0);
+
+	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_RGAM_RAMA_END_CNTL1_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMA_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMA_END_CNTL1_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMA_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMA_END_CNTL1_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMA_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
+
+	curve = params->arr_curve_points;
+	REG_SET_4(CM_RGAM_RAMA_REGION_0_1, 0,
+		CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_2_3, 0,
+		CM_RGAM_RAMA_EXP_REGION2_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION3_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_4_5, 0,
+		CM_RGAM_RAMA_EXP_REGION4_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION5_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_6_7, 0,
+		CM_RGAM_RAMA_EXP_REGION6_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION7_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_8_9, 0,
+		CM_RGAM_RAMA_EXP_REGION8_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION9_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_10_11, 0,
+		CM_RGAM_RAMA_EXP_REGION10_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION11_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_12_13, 0,
+		CM_RGAM_RAMA_EXP_REGION12_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION13_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_14_15, 0,
+		CM_RGAM_RAMA_EXP_REGION14_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION15_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_16_17, 0,
+		CM_RGAM_RAMA_EXP_REGION16_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION17_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_18_19, 0,
+		CM_RGAM_RAMA_EXP_REGION18_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION19_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_20_21, 0,
+		CM_RGAM_RAMA_EXP_REGION20_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION21_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_22_23, 0,
+		CM_RGAM_RAMA_EXP_REGION22_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION23_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_24_25, 0,
+		CM_RGAM_RAMA_EXP_REGION24_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION25_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_26_27, 0,
+		CM_RGAM_RAMA_EXP_REGION26_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION27_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_28_29, 0,
+		CM_RGAM_RAMA_EXP_REGION28_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION29_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_30_31, 0,
+		CM_RGAM_RAMA_EXP_REGION30_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION31_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_32_33, 0,
+		CM_RGAM_RAMA_EXP_REGION32_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION33_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);
+}
+
+static void opp_configure_regamma_lut(
+		struct output_pixel_processor *opp,
+		bool is_ram_a)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
+			CM_RGAM_LUT_WRITE_EN_MASK, 7);
+	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
+			CM_RGAM_LUT_WRITE_SEL, is_ram_a == true ? 0:1);
+	REG_SET(CM_RGAM_LUT_INDEX, 0, CM_RGAM_LUT_INDEX, 0);
+}
+
+static void opp_power_on_regamma_lut(
+	struct output_pixel_processor *opp,
+	bool power_on)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+	REG_SET(CM_MEM_PWR_CTRL, 0,
+			RGAM_MEM_PWR_FORCE, power_on == true ? 0:1);
+
+}
+
+static void opp_program_regamma_lut(
+		struct output_pixel_processor *opp,
+		const struct pwl_result_data *rgb,
+		uint32_t num)
+{
+	uint32_t i;
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+	for (i = 0 ; i < num; i++) {
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].red_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].green_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].blue_reg);
+
+		REG_SET(CM_RGAM_LUT_DATA, 0,
+				CM_RGAM_LUT_DATA, rgb[i].delta_red_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0,
+				CM_RGAM_LUT_DATA, rgb[i].delta_green_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0,
+				CM_RGAM_LUT_DATA, rgb[i].delta_blue_reg);
+
+	}
+
+}
+
+static bool opp_set_regamma_pwl(
+	struct output_pixel_processor *opp, const struct pwl_params *params)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	opp_power_on_regamma_lut(opp, true);
+	opp_configure_regamma_lut(opp, oppn10->is_write_to_ram_a_safe);
+
+	if (oppn10->is_write_to_ram_a_safe)
+		 opp_program_regamma_luta_settings(opp, params);
+	else
+		 opp_program_regamma_lutb_settings(opp, params);
+
+	opp_program_regamma_lut(
+		opp, params->rgb_resulted, params->hw_points_num);
+
+	return true;
+}
+
+static void opp_set_stereo_polarity(
+		struct output_pixel_processor *opp,
+		bool enable, bool rightEyePolarity)
+{
+	struct dcn10_opp *oppn10 = TO_DCN10_OPP(opp);
+
+	REG_UPDATE(FMT_CONTROL, FMT_STEREOSYNC_OVERRIDE, enable);
+}
+
+/*****************************************/
+/* Constructor, Destructor               */
+/*****************************************/
+
+static void dcn10_opp_destroy(struct output_pixel_processor **opp)
+{
+	dm_free(TO_DCN10_OPP(*opp));
+	*opp = NULL;
+}
+
+static struct opp_funcs dcn10_opp_funcs = {
+		.opp_power_on_regamma_lut = opp_power_on_regamma_lut,
+		.opp_set_csc_adjustment = NULL,
+		.opp_set_csc_default = opp_set_output_csc_default,
+		.opp_set_dyn_expansion = opp_set_dyn_expansion,
+		.opp_program_regamma_pwl = opp_set_regamma_pwl,
+		.opp_set_regamma_mode = opp_set_regamma_mode,
+		.opp_program_fmt = opp_program_fmt,
+		.opp_program_bit_depth_reduction = opp_program_bit_depth_reduction,
+		.opp_set_stereo_polarity = opp_set_stereo_polarity,
+		.opp_destroy = dcn10_opp_destroy
+};
+
+void dcn10_opp_construct(struct dcn10_opp *oppn10,
+	struct dc_context *ctx,
+	uint32_t inst,
+	const struct dcn10_opp_registers *regs,
+	const struct dcn10_opp_shift *opp_shift,
+	const struct dcn10_opp_mask *opp_mask)
+{
+	oppn10->base.ctx = ctx;
+	oppn10->base.inst = inst;
+	oppn10->base.funcs = &dcn10_opp_funcs;
+
+	oppn10->regs = regs;
+	oppn10->opp_shift = opp_shift;
+	oppn10->opp_mask = opp_mask;
+}
