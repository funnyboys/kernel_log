commit 509c58189c8d695ef9cd12093a22ddbd6cdb8d71
Author: Zheng Bin <zhengbin13@huawei.com>
Date:   Thu Apr 30 11:40:32 2020 +0800

    drm/amd/display: remove set but not used variable 'pixel_width'
    
    Fixes gcc '-Wunused-but-set-variable' warning:
    
    drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c:137:11: warning: variable ‘pixel_width’ set but not used [-Wunused-but-set-variable]
    
    It is introduced by commit 70ccab604049 ("drm/amdgpu/display:
    Add core dc support for DCN"), but never used, so remove it.
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Zheng Bin <zhengbin13@huawei.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 0e682b5aa3eb..7f8456b9988b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -134,13 +134,6 @@ bool dpp1_get_optimal_number_of_taps(
 		struct scaler_data *scl_data,
 		const struct scaling_taps *in_taps)
 {
-	uint32_t pixel_width;
-
-	if (scl_data->viewport.width > scl_data->recout.width)
-		pixel_width = scl_data->recout.width;
-	else
-		pixel_width = scl_data->viewport.width;
-
 	/* Some ASICs does not support  FP16 scaling, so we reject modes require this*/
 	if (scl_data->format == PIXEL_FORMAT_FP16 &&
 		dpp->caps->dscl_data_proc_format == DSCL_DATA_PRCESSING_FIXED_FORMAT &&

commit 1da37801a8b0fffb024fea594c7f1d7867ed8aa0
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:38:55 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_0 and DSC_SUPPORTED
    
    [Why]
    
    DCN2 and DSC are stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup NV defninitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN2 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * dce/dce_dmcu.c: dcn20_*lock_phy()
        * dce/dce_dmcu.c: dcn20_funcs
        * dce/dce_dmcu.c: dcn20_dmcu_create()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 997e9582edc7..0e682b5aa3eb 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -290,12 +290,8 @@ void dpp1_cnv_setup (
 		enum surface_pixel_format format,
 		enum expansion_mode mode,
 		struct dc_csc_transform input_csc_color_matrix,
-#ifdef CONFIG_DRM_AMD_DC_DCN2_0
 		enum dc_color_space input_color_space,
 		struct cnv_alpha_2bit_lut *alpha_2bit_lut)
-#else
-		enum dc_color_space input_color_space)
-#endif
 {
 	uint32_t pixel_format;
 	uint32_t alpha_en;
@@ -542,11 +538,9 @@ static const struct dpp_funcs dcn10_dpp_funcs = {
 		.set_optional_cursor_attributes = dpp1_cnv_set_optional_cursor_attributes,
 		.dpp_dppclk_control = dpp1_dppclk_control,
 		.dpp_set_hdr_multiplier = dpp1_set_hdr_multiplier,
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 		.dpp_program_blnd_lut = NULL,
 		.dpp_program_shaper_lut = NULL,
 		.dpp_program_3dlut = NULL
-#endif
 };
 
 static struct dpp_caps dcn10_dpp_cap = {

commit f432f0060f059085f9d520693befb1b803b842e8
Author: Wesley Chalmers <Wesley.Chalmers@amd.com>
Date:   Fri Sep 13 13:43:36 2019 -0400

    drm/amd/display: Use dcn1 Optimal Taps Get
    
    [WHY]
    dpp2_get_optimal_number_of_taps is incorrect, and dcn2 should be using
    dpp1_get_optimal_number_of_taps instead
    
    Signed-off-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index d8b2da18db39..997e9582edc7 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -129,7 +129,7 @@ void dpp_set_gamut_remap_bypass(struct dcn10_dpp *dpp)
 
 #define IDENTITY_RATIO(ratio) (dc_fixpt_u2d19(ratio) == (1 << 19))
 
-static bool dpp_get_optimal_number_of_taps(
+bool dpp1_get_optimal_number_of_taps(
 		struct dpp *dpp,
 		struct scaler_data *scl_data,
 		const struct scaling_taps *in_taps)
@@ -521,7 +521,7 @@ static const struct dpp_funcs dcn10_dpp_funcs = {
 		.dpp_read_state = dpp_read_state,
 		.dpp_reset = dpp_reset,
 		.dpp_set_scaler = dpp1_dscl_set_scaler_manual_scale,
-		.dpp_get_optimal_number_of_taps = dpp_get_optimal_number_of_taps,
+		.dpp_get_optimal_number_of_taps = dpp1_get_optimal_number_of_taps,
 		.dpp_set_gamut_remap = dpp1_cm_set_gamut_remap,
 		.dpp_set_csc_adjustment = dpp1_cm_set_output_csc_adjustment,
 		.dpp_set_csc_default = dpp1_cm_set_output_csc_default,

commit c005762253523044c5afade490129fc0dd6f868b
Author: Jaehyun Chung <jaehyun.chung@amd.com>
Date:   Wed Aug 7 11:20:16 2019 -0400

    drm/amd/display: Enable HW rotation
    
    [Why] HW rotation is not enabled. Calculations for cursor rotation
    are wrong for the values passed to set_cursor_position.
    
    [How] Swap Src rect and height and vertically mirror surface for
    the correct surface rotation direction. Cursor position is rotated
    according to angle. Offset calculations are tweaked for non-rotated
    cursor hotspot and width/height.
    
    Signed-off-by: Jaehyun Chung <jaehyun.chung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 23b2361cec62..d8b2da18db39 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -457,6 +457,19 @@ void dpp1_set_cursor_position(
 	int src_y_offset = pos->y - pos->y_hotspot - param->viewport.y;
 	uint32_t cur_en = pos->enable ? 1 : 0;
 
+	// Cursor width/height and hotspots need to be rotated for offset calculation
+	if (param->rotation == ROTATION_ANGLE_90 || param->rotation == ROTATION_ANGLE_270) {
+		swap(width, height);
+		if (param->rotation == ROTATION_ANGLE_90) {
+			src_x_offset = pos->x - pos->y_hotspot - param->viewport.x;
+			src_y_offset = pos->y - pos->x_hotspot - param->viewport.y;
+		}
+	} else if (param->rotation == ROTATION_ANGLE_180) {
+		src_x_offset = pos->x - param->viewport.x;
+		src_y_offset = pos->y - param->viewport.y;
+	}
+
+
 	if (src_x_offset >= (int)param->viewport.width)
 		cur_en = 0;  /* not visible beyond right edge*/
 

commit 5e1613e21fc1ea5c0888f4c858aa220ff8464d53
Author: Bayan Zabihiyan <bayan.zabihiyan@amd.com>
Date:   Fri Jul 26 11:10:11 2019 -0400

    drm/amd/display: add Cursor Degamma logic for DCN2
    
    [Why]
    We need to have the ability to to tell us set degamma on the cursor.
    
    [How]
    Pass a flag down to register programming that tells us if the
    current surface format needs cursor degamma.
    
    Signed-off-by: Bayan Zabihiyan <bayan.zabihiyan@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index b95ec73fcae3..23b2361cec62 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -426,8 +426,9 @@ void dpp1_cnv_setup (
 
 void dpp1_set_cursor_attributes(
 		struct dpp *dpp_base,
-		enum dc_cursor_color_format color_format)
+		struct dc_cursor_attributes *cursor_attributes)
 {
+	enum dc_cursor_color_format color_format = cursor_attributes->color_format;
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	REG_UPDATE_2(CURSOR0_CONTROL,

commit f7de96ee8b5f4d0d4ef7b00b8868049a6869a10f
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Feb 22 15:50:50 2019 -0500

    drm/amd/display: Add DCN2 DPP
    
    Add support to program the DCN2 DPP (Multiple pipe and plane combine)
    
    HW Blocks:
    
        +--------+
        |  DPP   |
        +--------+
            |
            v
        +--------+
        |  MPC   |
        +--------+
            |
            v
        +-------+
        |  OPP  |
        +-------+
            |
            v
        +--------+
        |  OPTC  |
        +--------+
            |
            v
        +--------+       +--------+
        |  DIO   |       |  DCCG  |
        +--------+       +--------+
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 6f4b24756323..b95ec73fcae3 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -290,7 +290,12 @@ void dpp1_cnv_setup (
 		enum surface_pixel_format format,
 		enum expansion_mode mode,
 		struct dc_csc_transform input_csc_color_matrix,
+#ifdef CONFIG_DRM_AMD_DC_DCN2_0
+		enum dc_color_space input_color_space,
+		struct cnv_alpha_2bit_lut *alpha_2bit_lut)
+#else
 		enum dc_color_space input_color_space)
+#endif
 {
 	uint32_t pixel_format;
 	uint32_t alpha_en;
@@ -523,6 +528,11 @@ static const struct dpp_funcs dcn10_dpp_funcs = {
 		.set_optional_cursor_attributes = dpp1_cnv_set_optional_cursor_attributes,
 		.dpp_dppclk_control = dpp1_dppclk_control,
 		.dpp_set_hdr_multiplier = dpp1_set_hdr_multiplier,
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+		.dpp_program_blnd_lut = NULL,
+		.dpp_program_shaper_lut = NULL,
+		.dpp_program_3dlut = NULL
+#endif
 };
 
 static struct dpp_caps dcn10_dpp_cap = {

commit a1e07ba89d49581471d64c48152dbe03b42bd025
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Thu Mar 14 13:46:44 2019 -0400

    drm/amd/display: Use plane->color_space for dpp if specified
    
    [Why]
    The input color space for the plane was previously ignored even if it
    was set.
    
    If a limited range YUV format was given to DC then the
    wrong color transformation matrix was being used since DC assumed that
    it was full range instead.
    
    [How]
    Respect the given color_space format for the plane if it isn't
    COLOR_SPACE_UNKNOWN. Otherwise, use the implicit default since DM
    didn't specify.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Sun peng Li <Sunpeng.Li@amd.com>
    Acked-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index f91e4b49d211..6f4b24756323 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -385,6 +385,10 @@ void dpp1_cnv_setup (
 	default:
 		break;
 	}
+
+	/* Set default color space based on format if none is given. */
+	color_space = input_color_space ? input_color_space : color_space;
+
 	REG_SET(CNVC_SURFACE_PIXEL_FORMAT, 0,
 			CNVC_SURFACE_PIXEL_FORMAT, pixel_format);
 	REG_UPDATE(FORMAT_CONTROL, FORMAT_CONTROL__ALPHA_EN, alpha_en);
@@ -396,7 +400,7 @@ void dpp1_cnv_setup (
 		for (i = 0; i < 12; i++)
 			tbl_entry.regval[i] = input_csc_color_matrix.matrix[i];
 
-		tbl_entry.color_space = input_color_space;
+		tbl_entry.color_space = color_space;
 
 		if (color_space >= COLOR_SPACE_YCBCR601)
 			select = INPUT_CSC_SELECT_ICSC;

commit e1998c8cfd59c223afabc20191c0570622583d06
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Tue Jan 29 16:20:26 2019 -0500

    drm/amd/display: Move enum gamut_remap_select to hw_shared.h
    
    This enum definition is shared, so move it to a shared location.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index cd1ebe57ed59..f91e4b49d211 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -91,13 +91,6 @@ enum dscl_mode_sel {
 	DSCL_MODE_DSCL_BYPASS = 6
 };
 
-enum gamut_remap_select {
-	GAMUT_REMAP_BYPASS = 0,
-	GAMUT_REMAP_COEFF,
-	GAMUT_REMAP_COMA_COEFF,
-	GAMUT_REMAP_COMB_COEFF
-};
-
 void dpp_read_state(struct dpp *dpp_base,
 		struct dcn_dpp_state *s)
 {

commit 55a806d37f2e03988063036954a0959f0e4006ed
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue Dec 11 12:35:56 2018 -0500

    drm/amd/display: Fix disabled cursor on top screen edge
    
    [Why]
    The cursor vanishes when touching the top of edge of the screen for
    Raven on Linux.
    
    This occurs because the cursor height is not taken into account when
    deciding to disable the cursor.
    
    [How]
    Factor in the cursor height into the cursor calculations - and mimic
    the existing x position calculations.
    
    Fixes: 94a4ffd1d40b ("drm/amd/display: fix PIP bugs on Dal3")
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index dcb3c5530236..cd1ebe57ed59 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -463,7 +463,7 @@ void dpp1_set_cursor_position(
 	if (src_y_offset >= (int)param->viewport.height)
 		cur_en = 0;  /* not visible beyond bottom edge*/
 
-	if (src_y_offset < 0)
+	if (src_y_offset + (int)height <= 0)
 		cur_en = 0;  /* not visible beyond top edge*/
 
 	REG_UPDATE(CURSOR0_CONTROL,

commit 550db288129591c4b2f669d724f12e43a380c286
Author: Gary Kattan <gary.kattan@amd.com>
Date:   Mon Aug 20 15:12:14 2018 -0700

    drm/amd/display: Fix DAL217 tests modify DTN logs for other tests
    
    [Why]Update Code to get DTN golden log check to pass for tests run after
    DAL217 tests.
    [How]Change how dcn10_log_hw_state function prints HW state info
    (CM_GAMUT_REMAP_Cx_Cx registers) when GAMUT REMAP is in bypass mode.
    
    Signed-off-by: Gary Kattan <gary.kattan@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 5f2054a1d563..dcb3c5530236 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -116,12 +116,14 @@ void dpp_read_state(struct dpp *dpp_base,
 	REG_GET(CM_GAMUT_REMAP_CONTROL,
 			CM_GAMUT_REMAP_MODE, &s->gamut_remap_mode);
 
-	s->gamut_remap_c11_c12 = REG_READ(CM_GAMUT_REMAP_C11_C12);
-	s->gamut_remap_c13_c14 = REG_READ(CM_GAMUT_REMAP_C13_C14);
-	s->gamut_remap_c21_c22 = REG_READ(CM_GAMUT_REMAP_C21_C22);
-	s->gamut_remap_c23_c24 = REG_READ(CM_GAMUT_REMAP_C23_C24);
-	s->gamut_remap_c31_c32 = REG_READ(CM_GAMUT_REMAP_C31_C32);
-	s->gamut_remap_c33_c34 = REG_READ(CM_GAMUT_REMAP_C33_C34);
+	if (s->gamut_remap_mode) {
+		s->gamut_remap_c11_c12 = REG_READ(CM_GAMUT_REMAP_C11_C12);
+		s->gamut_remap_c13_c14 = REG_READ(CM_GAMUT_REMAP_C13_C14);
+		s->gamut_remap_c21_c22 = REG_READ(CM_GAMUT_REMAP_C21_C22);
+		s->gamut_remap_c23_c24 = REG_READ(CM_GAMUT_REMAP_C23_C24);
+		s->gamut_remap_c31_c32 = REG_READ(CM_GAMUT_REMAP_C31_C32);
+		s->gamut_remap_c33_c34 = REG_READ(CM_GAMUT_REMAP_C33_C34);
+	}
 }
 
 /* Program gamut remap in bypass mode */

commit 94a4ffd1d40b845dd19f9fdbb2cb6bf32de0946b
Author: Gloria Li <geling.li@amd.com>
Date:   Thu Jul 26 11:32:14 2018 -0400

    drm/amd/display: fix PIP bugs on Dal3
    
    [Why]
    There are outstanding bugs for PIP in Dal3:
    -Crash when toggling PIP visibility
    -Global Alpha is not working, Adjusting global alpha
     doesn’t have an effect
    -Cursor is not working with pip plane and pipe splits
    -One flash occurs when cursor enters PIP plane from
     top/bottom
    -Crash when moving PIP plane off the screen
    
    [How]
    Resolve divide by 0 error
    Implement global alpha
    Program cursor on all pipes
    Add dst rects' x and y offests into cursor position
    Disable cursor when it is beyond bottom/top edge
    
    Signed-off-by: Gloria Li <geling.li@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 1d642552c743..5f2054a1d563 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -444,10 +444,12 @@ void dpp1_set_cursor_position(
 		struct dpp *dpp_base,
 		const struct dc_cursor_position *pos,
 		const struct dc_cursor_mi_param *param,
-		uint32_t width)
+		uint32_t width,
+		uint32_t height)
 {
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	int src_x_offset = pos->x - pos->x_hotspot - param->viewport.x;
+	int src_y_offset = pos->y - pos->y_hotspot - param->viewport.y;
 	uint32_t cur_en = pos->enable ? 1 : 0;
 
 	if (src_x_offset >= (int)param->viewport.width)
@@ -456,6 +458,12 @@ void dpp1_set_cursor_position(
 	if (src_x_offset + (int)width <= 0)
 		cur_en = 0;  /* not visible beyond left edge*/
 
+	if (src_y_offset >= (int)param->viewport.height)
+		cur_en = 0;  /* not visible beyond bottom edge*/
+
+	if (src_y_offset < 0)
+		cur_en = 0;  /* not visible beyond top edge*/
+
 	REG_UPDATE(CURSOR0_CONTROL,
 			CUR0_ENABLE, cur_en);
 

commit d02e07948fcff46a7a48f8747260941d7290774b
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Thu Jul 19 14:03:14 2018 -0400

    drm/amd/display: Print DPP DTN log info only for enabled pipes
    
    [why]
    There is currently a dependency on the order in which tests are executed.
    This is because the non-relevant state info is being printed, which results
    in the output based on the state from the previous test.
    
    [how]
    Print DPP DTN log only if the pipe is enabled.
    In addition to the affected per-submission DTN golden logs, included in this
    change is also DTN golden log update for pre-submission tests.
    The other DTN golden logs affected by this change will be updated upon
    nightly test run (which will generate the updated DTN logs).
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index bf8b68f8db4f..1d642552c743 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -103,6 +103,8 @@ void dpp_read_state(struct dpp *dpp_base,
 {
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
+	REG_GET(DPP_CONTROL,
+			DPP_CLOCK_ENABLE, &s->is_enabled);
 	REG_GET(CM_IGAM_CONTROL,
 			CM_IGAM_LUT_MODE, &s->igam_lut_mode);
 	REG_GET(CM_IGAM_CONTROL,

commit 6d92b5c2d5bea1b1d0859bd8f3080344e5e3960e
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Wed Jun 27 18:23:37 2018 -0400

    drm/amd/display: Refactor SDR cursor boosting in HDR mode
    
    [Why]
    Cursor boosting is done via CNVC_CUR register which is DPP, not HUBP
    Previous commit was implementing it in HUBP functions,
    and also breaking diags tests.
    
    [How]
    1. Undo original commit as well as Eric's diags test fix, almost completely
    2. Move programming to DPP and call via new dc_stream function
    3. Also removing cur_rom_en from dpp_cursor_attributes and programming
    as part of normal cursor attributes as it depends on cursor color format
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index a558efa9b34a..bf8b68f8db4f 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -459,6 +459,18 @@ void dpp1_set_cursor_position(
 
 }
 
+void dpp1_cnv_set_optional_cursor_attributes(
+		struct dpp *dpp_base,
+		struct dpp_cursor_attributes *attr)
+{
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
+
+	if (attr) {
+		REG_UPDATE(CURSOR0_FP_SCALE_BIAS,  CUR0_FP_BIAS,  attr->bias);
+		REG_UPDATE(CURSOR0_FP_SCALE_BIAS,  CUR0_FP_SCALE, attr->scale);
+	}
+}
+
 void dpp1_dppclk_control(
 		struct dpp *dpp_base,
 		bool dppclk_div,
@@ -499,6 +511,7 @@ static const struct dpp_funcs dcn10_dpp_funcs = {
 		.dpp_full_bypass		= dpp1_full_bypass,
 		.set_cursor_attributes = dpp1_set_cursor_attributes,
 		.set_cursor_position = dpp1_set_cursor_position,
+		.set_optional_cursor_attributes = dpp1_cnv_set_optional_cursor_attributes,
 		.dpp_dppclk_control = dpp1_dppclk_control,
 		.dpp_set_hdr_multiplier = dpp1_set_hdr_multiplier,
 };

commit 39a9f4d89e123b62c8a5cc26696ea8afa98e0e88
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Jun 19 15:49:02 2018 -0400

    drm/amd/display: add additional info for cursor position programming
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 742fd497ed00..a558efa9b34a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -445,10 +445,10 @@ void dpp1_set_cursor_position(
 		uint32_t width)
 {
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
-	int src_x_offset = pos->x - pos->x_hotspot - param->viewport_x_start;
+	int src_x_offset = pos->x - pos->x_hotspot - param->viewport.x;
 	uint32_t cur_en = pos->enable ? 1 : 0;
 
-	if (src_x_offset >= (int)param->viewport_width)
+	if (src_x_offset >= (int)param->viewport.width)
 		cur_en = 0;  /* not visible beyond right edge*/
 
 	if (src_x_offset + (int)width <= 0)

commit b6c3053a8f431a032a1473dc0e0069ca7fd0b0e5
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Jun 8 13:07:53 2018 -0500

    drm/amd/display: Check scaling ration not viewports params.
    
    In case of roation, width and height in viewport is difference
    between viewport and h_active and v_active, while this is not scaling.
    The right way is check ratios in scaling data,
    to determine it is a scaling case or not.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index c69fa4bfab0a..742fd497ed00 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -145,10 +145,10 @@ static bool dpp_get_optimal_number_of_taps(
 		pixel_width = scl_data->viewport.width;
 
 	/* Some ASICs does not support  FP16 scaling, so we reject modes require this*/
-	if (scl_data->viewport.width  != scl_data->h_active &&
-		scl_data->viewport.height != scl_data->v_active &&
+	if (scl_data->format == PIXEL_FORMAT_FP16 &&
 		dpp->caps->dscl_data_proc_format == DSCL_DATA_PRCESSING_FIXED_FORMAT &&
-		scl_data->format == PIXEL_FORMAT_FP16)
+		scl_data->ratios.horz.value != dc_fixpt_one.value &&
+		scl_data->ratios.vert.value != dc_fixpt_one.value)
 		return false;
 
 	if (scl_data->viewport.width > scl_data->h_active &&

commit 0b19fdc45feffd7569c081fe32a258df3c8ebb9b
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu May 17 10:08:10 2018 -0400

    drm/amd/display: fix dscl_manual_ratio_init
    
    This change will fix wb and display scaling when ratios of
    4 or more are involved
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 46a35c7f01df..c69fa4bfab0a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -132,8 +132,7 @@ void dpp_set_gamut_remap_bypass(struct dcn10_dpp *dpp)
 
 #define IDENTITY_RATIO(ratio) (dc_fixpt_u2d19(ratio) == (1 << 19))
 
-
-bool dpp_get_optimal_number_of_taps(
+static bool dpp_get_optimal_number_of_taps(
 		struct dpp *dpp,
 		struct scaler_data *scl_data,
 		const struct scaling_taps *in_taps)

commit 8fc06ebc2bb719cddb041bcb14b5ca87adbcd57f
Author: Xingyue Tao <xingyue.tao@amd.com>
Date:   Thu Apr 19 16:23:12 2018 -0400

    drm/amd/display: Only limit VSR downscaling when actually downscaling
    
    Signed-off-by: Xingyue Tao <xingyue.tao@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 2da138904312..46a35c7f01df 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -145,18 +145,17 @@ bool dpp_get_optimal_number_of_taps(
 	else
 		pixel_width = scl_data->viewport.width;
 
+	/* Some ASICs does not support  FP16 scaling, so we reject modes require this*/
 	if (scl_data->viewport.width  != scl_data->h_active &&
-		scl_data->viewport.height != scl_data->v_active) {
-
-		/* Some ASICs does not support  FP16 scaling, so we reject modes require this*/
-		if (dpp->caps->dscl_data_proc_format == DSCL_DATA_PRCESSING_FIXED_FORMAT &&
-			scl_data->format == PIXEL_FORMAT_FP16)
-			return false;
-
-		if (dpp->ctx->dc->debug.max_downscale_src_width != 0 &&
-			scl_data->viewport.width > dpp->ctx->dc->debug.max_downscale_src_width)
-			return false;
-	}
+		scl_data->viewport.height != scl_data->v_active &&
+		dpp->caps->dscl_data_proc_format == DSCL_DATA_PRCESSING_FIXED_FORMAT &&
+		scl_data->format == PIXEL_FORMAT_FP16)
+		return false;
+
+	if (scl_data->viewport.width > scl_data->h_active &&
+		dpp->ctx->dc->debug.max_downscale_src_width != 0 &&
+		scl_data->viewport.width > dpp->ctx->dc->debug.max_downscale_src_width)
+		return false;
 
 	/* TODO: add lb check */
 

commit 3f460907be1b53441526e644019bcf150c433f59
Author: Xingyue Tao <xingyue.tao@amd.com>
Date:   Thu Apr 19 16:23:12 2018 -0400

    drm/amd/display: Add dc cap to restrict VSR downscaling src size
    
    - Adds int max_downscale_src_width in dc struct
    - Checks and does not support if downscale size is more than 4k (width > 3840)
    
    Signed-off-by: Xingyue Tao <xingyue.tao@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 20796da36de4..2da138904312 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -145,12 +145,18 @@ bool dpp_get_optimal_number_of_taps(
 	else
 		pixel_width = scl_data->viewport.width;
 
-	/* Some ASICs does not support  FP16 scaling, so we reject modes require this*/
 	if (scl_data->viewport.width  != scl_data->h_active &&
-		scl_data->viewport.height != scl_data->v_active &&
-		dpp->caps->dscl_data_proc_format == DSCL_DATA_PRCESSING_FIXED_FORMAT &&
-		scl_data->format == PIXEL_FORMAT_FP16)
-		return false;
+		scl_data->viewport.height != scl_data->v_active) {
+
+		/* Some ASICs does not support  FP16 scaling, so we reject modes require this*/
+		if (dpp->caps->dscl_data_proc_format == DSCL_DATA_PRCESSING_FIXED_FORMAT &&
+			scl_data->format == PIXEL_FORMAT_FP16)
+			return false;
+
+		if (dpp->ctx->dc->debug.max_downscale_src_width != 0 &&
+			scl_data->viewport.width > dpp->ctx->dc->debug.max_downscale_src_width)
+			return false;
+	}
 
 	/* TODO: add lb check */
 

commit eb0e515464e4a1be730c7ac7a01c3ba04c98ea97
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Apr 18 11:37:53 2018 -0400

    drm/amd/display: get rid of 32.32 unsigned fixed point
    
    32.32 is redundant, 31.32 does everything we use 32.32 for
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 8c4d9e523331..20796da36de4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -130,7 +130,7 @@ void dpp_set_gamut_remap_bypass(struct dcn10_dpp *dpp)
 	/* Gamut remap in bypass */
 }
 
-#define IDENTITY_RATIO(ratio) (dal_fixed31_32_u2d19(ratio) == (1 << 19))
+#define IDENTITY_RATIO(ratio) (dc_fixpt_u2d19(ratio) == (1 << 19))
 
 
 bool dpp_get_optimal_number_of_taps(

commit 7c91bd434e5765dc5dbcf155253f2b8c740fbef9
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Fri Apr 13 09:40:21 2018 -0400

    drm/amd/display: add some DTN logs for input and output tf
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index c008a71ebc4e..8c4d9e523331 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -98,6 +98,30 @@ enum gamut_remap_select {
 	GAMUT_REMAP_COMB_COEFF
 };
 
+void dpp_read_state(struct dpp *dpp_base,
+		struct dcn_dpp_state *s)
+{
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
+
+	REG_GET(CM_IGAM_CONTROL,
+			CM_IGAM_LUT_MODE, &s->igam_lut_mode);
+	REG_GET(CM_IGAM_CONTROL,
+			CM_IGAM_INPUT_FORMAT, &s->igam_input_format);
+	REG_GET(CM_DGAM_CONTROL,
+			CM_DGAM_LUT_MODE, &s->dgam_lut_mode);
+	REG_GET(CM_RGAM_CONTROL,
+			CM_RGAM_LUT_MODE, &s->rgam_lut_mode);
+	REG_GET(CM_GAMUT_REMAP_CONTROL,
+			CM_GAMUT_REMAP_MODE, &s->gamut_remap_mode);
+
+	s->gamut_remap_c11_c12 = REG_READ(CM_GAMUT_REMAP_C11_C12);
+	s->gamut_remap_c13_c14 = REG_READ(CM_GAMUT_REMAP_C13_C14);
+	s->gamut_remap_c21_c22 = REG_READ(CM_GAMUT_REMAP_C21_C22);
+	s->gamut_remap_c23_c24 = REG_READ(CM_GAMUT_REMAP_C23_C24);
+	s->gamut_remap_c31_c32 = REG_READ(CM_GAMUT_REMAP_C31_C32);
+	s->gamut_remap_c33_c34 = REG_READ(CM_GAMUT_REMAP_C33_C34);
+}
+
 /* Program gamut remap in bypass mode */
 void dpp_set_gamut_remap_bypass(struct dcn10_dpp *dpp)
 {
@@ -450,6 +474,7 @@ void dpp1_dppclk_control(
 }
 
 static const struct dpp_funcs dcn10_dpp_funcs = {
+		.dpp_read_state = dpp_read_state,
 		.dpp_reset = dpp_reset,
 		.dpp_set_scaler = dpp1_dscl_set_scaler_manual_scale,
 		.dpp_get_optimal_number_of_taps = dpp_get_optimal_number_of_taps,

commit 586f27a3c2b04e041c2d51c6c2374fbfa3075407
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Mon Mar 26 16:19:18 2018 -0400

    drm/amd/display: csc_transform to dc_csc_transform
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 5f40a7374c02..c008a71ebc4e 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -264,7 +264,7 @@ void dpp1_cnv_setup (
 		struct dpp *dpp_base,
 		enum surface_pixel_format format,
 		enum expansion_mode mode,
-		struct csc_transform input_csc_color_matrix,
+		struct dc_csc_transform input_csc_color_matrix,
 		enum dc_color_space input_color_space)
 {
 	uint32_t pixel_format;

commit 6133470c8e2ffdc6a5d67a1d79a9a0c1c0a94a10
Author: Julian Parkin <jparkin@amd.com>
Date:   Tue Mar 13 15:53:13 2018 -0400

    drm/amd/display: drop dc_validate_guaranteed
    
    Block FP16 scaling in validate_resources codepath.
    
    Signed-off-by: Julian Parkin <jparkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 3356125a6117..5f40a7374c02 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -121,6 +121,13 @@ bool dpp_get_optimal_number_of_taps(
 	else
 		pixel_width = scl_data->viewport.width;
 
+	/* Some ASICs does not support  FP16 scaling, so we reject modes require this*/
+	if (scl_data->viewport.width  != scl_data->h_active &&
+		scl_data->viewport.height != scl_data->v_active &&
+		dpp->caps->dscl_data_proc_format == DSCL_DATA_PRCESSING_FIXED_FORMAT &&
+		scl_data->format == PIXEL_FORMAT_FP16)
+		return false;
+
 	/* TODO: add lb check */
 
 	/* No support for programming ratio of 4, drop to 3.99999.. */

commit 35d13315957f906774013ec374ce2263b665706c
Author: Martin Tsai <martin.tsai@amd.com>
Date:   Wed Mar 7 04:22:03 2018 +0800

    drm/amd/display: correct the condition in setting cursor not visible beyond left edge
    
    Signed-off-by: Martin Tsai <martin.tsai@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index e305c28c98de..3356125a6117 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -416,7 +416,7 @@ void dpp1_set_cursor_position(
 	if (src_x_offset >= (int)param->viewport_width)
 		cur_en = 0;  /* not visible beyond right edge*/
 
-	if (src_x_offset + (int)width < 0)
+	if (src_x_offset + (int)width <= 0)
 		cur_en = 0;  /* not visible beyond left edge*/
 
 	REG_UPDATE(CURSOR0_CONTROL,

commit a4056c2a6344c64bd62234458a314e6aecce226f
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Fri Feb 23 17:51:33 2018 -0500

    drm/amd/display: use HW hdr mult for brightness boost
    
    In MPO scenario when playing SDR clip in HDR desktop mode, Win is
    boosting desktop and requests driver to boost MPO. But driver boosting
    is currently done in regamma which is stream property and thus shared
    between grph and video.
    
    Redesigning the boosting in RV: use CM_HDR_MULT register which was added
    for this scenario. It also has the benefit that it can be done in HIRQL.
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index f0b798930b51..e305c28c98de 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -464,6 +464,7 @@ static const struct dpp_funcs dcn10_dpp_funcs = {
 		.set_cursor_attributes = dpp1_set_cursor_attributes,
 		.set_cursor_position = dpp1_set_cursor_position,
 		.dpp_dppclk_control = dpp1_dppclk_control,
+		.dpp_set_hdr_multiplier = dpp1_set_hdr_multiplier,
 };
 
 static struct dpp_caps dcn10_dpp_cap = {

commit f553e6810259d8bd31a4b9ac3001cfcde7f8fb7e
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Feb 12 15:19:20 2018 -0500

    drm/amd/display: add per pipe dppclk
    
    v2: Fix commit title
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 8725cab9ec00..f0b798930b51 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -432,14 +432,12 @@ void dpp1_dppclk_control(
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	if (enable) {
-		if (dpp->tf_mask->DPPCLK_RATE_CONTROL) {
+		if (dpp->tf_mask->DPPCLK_RATE_CONTROL)
 			REG_UPDATE_2(DPP_CONTROL,
 				DPPCLK_RATE_CONTROL, dppclk_div,
 				DPP_CLOCK_ENABLE, 1);
-		} else {
-			ASSERT(dppclk_div == false);
+		else
 			REG_UPDATE(DPP_CONTROL, DPP_CLOCK_ENABLE, 1);
-		}
 	} else
 		REG_UPDATE(DPP_CONTROL, DPP_CLOCK_ENABLE, 0);
 }

commit 8f8372c7d17792f8b8b5fbf539f8f2b75dce0e15
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Fri Jan 19 17:55:26 2018 -0500

    drm/amd/display: Optimize regamma calculations
    
    There are several optimizations:
    1) Use predefined SRGB, don't calculate. This is the most common case.
    2) Precompute HW X points at boot since they're fixed in ColModule
    3) Precompute PQ - it never changes and is very CPU intensive in fixed pt.
    4) Reduce number of points in ColModule to 512 (32x16) from 1024. This also
    requires reducing some regions for legacy DCEs to 16 pts at most.
    
    Performance
    1) is super-fast, build_output_tf is 1-2us, down from 25000-30000.
    Programming also fast since only one reg write.
    2)+3) gives build_output_tf for PQ in ~100us range, down from ~80000-110000
    2) + 4) results in slightly over 50% improvement. It gives an idea of the
    savings when we can't use SRGB or PQ table (e.g. sdr white level > 80).
    
    There's also a bit of refactoring: renaming some stuff that was misleading
    and removing a lot of magic numbers that novices might not be able to
    understand where they come from and what they mean.
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 080c25383a4a..8725cab9ec00 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -196,7 +196,7 @@ static void dpp1_cm_set_regamma_pwl(
 	case OPP_REGAMMA_SRGB:
 		re_mode = 1;
 		break;
-	case OPP_REGAMMA_3_6:
+	case OPP_REGAMMA_XVYCC:
 		re_mode = 2;
 		break;
 	case OPP_REGAMMA_USER:

commit f8e413bf3c478225177ff74510ecf6bcd6160d1b
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Dec 20 17:17:40 2017 -0500

    drm/amd/display: Move dpp reg access from hwss to dpp module.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index f2a08b156cf0..080c25383a4a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -424,6 +424,26 @@ void dpp1_set_cursor_position(
 
 }
 
+void dpp1_dppclk_control(
+		struct dpp *dpp_base,
+		bool dppclk_div,
+		bool enable)
+{
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
+
+	if (enable) {
+		if (dpp->tf_mask->DPPCLK_RATE_CONTROL) {
+			REG_UPDATE_2(DPP_CONTROL,
+				DPPCLK_RATE_CONTROL, dppclk_div,
+				DPP_CLOCK_ENABLE, 1);
+		} else {
+			ASSERT(dppclk_div == false);
+			REG_UPDATE(DPP_CONTROL, DPP_CLOCK_ENABLE, 1);
+		}
+	} else
+		REG_UPDATE(DPP_CONTROL, DPP_CLOCK_ENABLE, 0);
+}
+
 static const struct dpp_funcs dcn10_dpp_funcs = {
 		.dpp_reset = dpp_reset,
 		.dpp_set_scaler = dpp1_dscl_set_scaler_manual_scale,
@@ -445,6 +465,7 @@ static const struct dpp_funcs dcn10_dpp_funcs = {
 		.dpp_full_bypass		= dpp1_full_bypass,
 		.set_cursor_attributes = dpp1_set_cursor_attributes,
 		.set_cursor_position = dpp1_set_cursor_position,
+		.dpp_dppclk_control = dpp1_dppclk_control,
 };
 
 static struct dpp_caps dcn10_dpp_cap = {

commit 51ca0b036223660e0db10e2bf6097a0689f5fa44
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Tue Nov 28 12:05:08 2017 -0500

    drm/amd/display: remove format_control from set_cursor_attributes
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 6db1839d7155..f2a08b156cf0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -400,13 +400,6 @@ void dpp1_set_cursor_attributes(
 		REG_UPDATE(CURSOR0_COLOR1,
 				CUR0_COLOR1, 0xFFFFFFFF);
 	}
-
-	/* TODO: Fixed vs float */
-
-	REG_UPDATE_3(FORMAT_CONTROL,
-				CNVC_BYPASS, 0,
-				FORMAT_CONTROL__ALPHA_EN, 1,
-				FORMAT_EXPANSION_MODE, 0);
 }
 
 

commit bce14857bd1b2d6849336f56e7a1926ab937c5ef
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Nov 13 17:03:53 2017 -0500

    drm/amd/display: set chroma taps to 1 when not scaling
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 5a95fa03bc17..6db1839d7155 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -159,11 +159,10 @@ bool dpp_get_optimal_number_of_taps(
 			scl_data->taps.h_taps = 1;
 		if (IDENTITY_RATIO(scl_data->ratios.vert))
 			scl_data->taps.v_taps = 1;
-		/*
-		 * Spreadsheet doesn't handle taps_c is one properly,
-		 * need to force Chroma to always be scaled to pass
-		 * bandwidth validation.
-		 */
+		if (IDENTITY_RATIO(scl_data->ratios.horz_c))
+			scl_data->taps.h_taps_c = 1;
+		if (IDENTITY_RATIO(scl_data->ratios.vert_c))
+			scl_data->taps.v_taps_c = 1;
 	}
 
 	return true;

commit 9a0beb3944f28d9d3d1864ca2145a940bc829295
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Tue Nov 14 12:13:27 2017 -0500

    drm/amd/display: CNVC pseudocode review follow up
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 8df3945370cf..5a95fa03bc17 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -386,10 +386,9 @@ void dpp1_cnv_setup (
 
 void dpp1_set_cursor_attributes(
 		struct dpp *dpp_base,
-		const struct dc_cursor_attributes *attr)
+		enum dc_cursor_color_format color_format)
 {
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
-	enum dc_cursor_color_format color_format = attr->color_format;
 
 	REG_UPDATE_2(CURSOR0_CONTROL,
 			CUR0_MODE, color_format,

commit bd1be8e894e4963595a35ebeff512dc63d3ee328
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Nov 1 14:31:58 2017 -0400

    drm/amd/display: A few more color indentation changes
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index d8929b31e5ba..8df3945370cf 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -213,8 +213,8 @@ static void dpp1_cm_set_regamma_pwl(
 		else
 			dpp1_cm_program_regamma_lutb_settings(dpp_base, params);
 
-		dpp1_cm_program_regamma_lut(
-				dpp_base, params->rgb_resulted, params->hw_points_num);
+		dpp1_cm_program_regamma_lut(dpp_base, params->rgb_resulted,
+					    params->hw_points_num);
 		dpp->pwl_data = *params;
 
 		re_mode = dpp->is_write_to_ram_a_safe ? 3 : 4;

commit bbe3f058ecb62bce041a0b03d76f6b9337dc81af
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Nov 2 15:07:25 2017 -0400

    drm/amd/display: fix uninitialized variable warning
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index bbf93c94a977..d8929b31e5ba 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -188,7 +188,7 @@ static void dpp1_cm_set_regamma_pwl(
 	struct dpp *dpp_base, const struct pwl_params *params, enum opp_regamma mode)
 {
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
-	uint32_t re_mode;
+	uint32_t re_mode = 0;
 
 	switch (mode) {
 	case OPP_REGAMMA_BYPASS:

commit 3e64668d7926854b084f89831ecbe4ae75600db6
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Nov 2 10:52:09 2017 -0400

    drm/amd/display: fix regamma programming
    
    When new coefficients match cached we would skip setting regamma mode
    Also, when doing a stream update we would program regamma for all pipes,
    even thos that are not yet powered on. This resulted in never setting
    regamma since we would cache before the pipe is powered.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 21eba82aba97..bbf93c94a977 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -188,9 +188,7 @@ static void dpp1_cm_set_regamma_pwl(
 	struct dpp *dpp_base, const struct pwl_params *params, enum opp_regamma mode)
 {
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
-	uint32_t re_mode = 0;
-	uint32_t obuf_bypass = 0; /* need for pipe split */
-	uint32_t obuf_hupscale = 0;
+	uint32_t re_mode;
 
 	switch (mode) {
 	case OPP_REGAMMA_BYPASS:
@@ -203,8 +201,9 @@ static void dpp1_cm_set_regamma_pwl(
 		re_mode = 2;
 		break;
 	case OPP_REGAMMA_USER:
+		re_mode = dpp->is_write_to_ram_a_safe ? 4 : 3;
 		if (memcmp(&dpp->pwl_data, params, sizeof(*params)) == 0)
-			return;
+			break;
 
 		dpp1_cm_power_on_regamma_lut(dpp_base, true);
 		dpp1_cm_configure_regamma_lut(dpp_base, dpp->is_write_to_ram_a_safe);
@@ -225,9 +224,6 @@ static void dpp1_cm_set_regamma_pwl(
 		break;
 	}
 	REG_SET(CM_RGAM_CONTROL, 0, CM_RGAM_LUT_MODE, re_mode);
-	REG_UPDATE_2(OBUF_CONTROL,
-			OBUF_BYPASS, obuf_bypass,
-			OBUF_H_2X_UPSCALE_EN, obuf_hupscale);
 }
 
 static void dpp1_setup_format_flags(enum surface_pixel_format input_format,\

commit 5fa2ec4fad366a6de324c57d51abea6dd4b52a26
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Tue Oct 31 15:23:57 2017 -0400

    drm/amd/display: renaming dpp function to follow naming convention
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Yuehin Lau <Yuehin.Lau@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index e9cf9d1514eb..21eba82aba97 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -442,20 +442,20 @@ static const struct dpp_funcs dcn10_dpp_funcs = {
 		.dpp_set_scaler = dpp1_dscl_set_scaler_manual_scale,
 		.dpp_get_optimal_number_of_taps = dpp_get_optimal_number_of_taps,
 		.dpp_set_gamut_remap = dpp1_cm_set_gamut_remap,
-		.opp_set_csc_adjustment = dpp1_cm_set_output_csc_adjustment,
-		.opp_set_csc_default = dpp1_cm_set_output_csc_default,
-		.opp_power_on_regamma_lut = dpp1_cm_power_on_regamma_lut,
-		.opp_program_regamma_lut = dpp1_cm_program_regamma_lut,
-		.opp_configure_regamma_lut = dpp1_cm_configure_regamma_lut,
-		.opp_program_regamma_lutb_settings = dpp1_cm_program_regamma_lutb_settings,
-		.opp_program_regamma_luta_settings = dpp1_cm_program_regamma_luta_settings,
-		.opp_program_regamma_pwl = dpp1_cm_set_regamma_pwl,
-		.ipp_program_bias_and_scale = dpp1_program_bias_and_scale,
-		.ipp_set_degamma = dpp1_set_degamma,
-		.ipp_program_input_lut		= dpp1_program_input_lut,
-		.ipp_program_degamma_pwl	= dpp1_set_degamma_pwl,
-		.ipp_setup			= dpp1_cnv_setup,
-		.ipp_full_bypass		= dpp1_full_bypass,
+		.dpp_set_csc_adjustment = dpp1_cm_set_output_csc_adjustment,
+		.dpp_set_csc_default = dpp1_cm_set_output_csc_default,
+		.dpp_power_on_regamma_lut = dpp1_cm_power_on_regamma_lut,
+		.dpp_program_regamma_lut = dpp1_cm_program_regamma_lut,
+		.dpp_configure_regamma_lut = dpp1_cm_configure_regamma_lut,
+		.dpp_program_regamma_lutb_settings = dpp1_cm_program_regamma_lutb_settings,
+		.dpp_program_regamma_luta_settings = dpp1_cm_program_regamma_luta_settings,
+		.dpp_program_regamma_pwl = dpp1_cm_set_regamma_pwl,
+		.dpp_program_bias_and_scale = dpp1_program_bias_and_scale,
+		.dpp_set_degamma = dpp1_set_degamma,
+		.dpp_program_input_lut		= dpp1_program_input_lut,
+		.dpp_program_degamma_pwl	= dpp1_set_degamma_pwl,
+		.dpp_setup			= dpp1_cnv_setup,
+		.dpp_full_bypass		= dpp1_full_bypass,
 		.set_cursor_attributes = dpp1_set_cursor_attributes,
 		.set_cursor_position = dpp1_set_cursor_position,
 };

commit 6334ac93a1e1ff8b99dac98bb7ef790b5786ea3c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Oct 27 17:55:03 2017 -0400

    drm/amd/display: cache pwl params and scl_data to avoid extra programming
    
    This saves us about 5000 reg writes per full update. This translates to about
    40000 writes over the course of single eDP bootup.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index c5f4d5caf976..e9cf9d1514eb 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -178,32 +178,14 @@ void dpp_reset(struct dpp *dpp_base)
 	dpp->filter_h = NULL;
 	dpp->filter_v = NULL;
 
-	/* set boundary mode to 0 */
-	REG_SET(DSCL_CONTROL, 0, SCL_BOUNDARY_MODE, 0);
+	memset(&dpp->scl_data, 0, sizeof(dpp->scl_data));
+	memset(&dpp->pwl_data, 0, sizeof(dpp->pwl_data));
 }
 
 
 
 static void dpp1_cm_set_regamma_pwl(
-	struct dpp *dpp_base, const struct pwl_params *params)
-{
-	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
-
-	dpp1_cm_power_on_regamma_lut(dpp_base, true);
-	dpp1_cm_configure_regamma_lut(dpp_base, dpp->is_write_to_ram_a_safe);
-
-	if (dpp->is_write_to_ram_a_safe)
-		dpp1_cm_program_regamma_luta_settings(dpp_base, params);
-	else
-		dpp1_cm_program_regamma_lutb_settings(dpp_base, params);
-
-	dpp1_cm_program_regamma_lut(
-			dpp_base, params->rgb_resulted, params->hw_points_num);
-}
-
-static void dpp1_cm_set_regamma_mode(
-	struct dpp *dpp_base,
-	enum opp_regamma mode)
+	struct dpp *dpp_base, const struct pwl_params *params, enum opp_regamma mode)
 {
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	uint32_t re_mode = 0;
@@ -221,13 +203,27 @@ static void dpp1_cm_set_regamma_mode(
 		re_mode = 2;
 		break;
 	case OPP_REGAMMA_USER:
+		if (memcmp(&dpp->pwl_data, params, sizeof(*params)) == 0)
+			return;
+
+		dpp1_cm_power_on_regamma_lut(dpp_base, true);
+		dpp1_cm_configure_regamma_lut(dpp_base, dpp->is_write_to_ram_a_safe);
+
+		if (dpp->is_write_to_ram_a_safe)
+			dpp1_cm_program_regamma_luta_settings(dpp_base, params);
+		else
+			dpp1_cm_program_regamma_lutb_settings(dpp_base, params);
+
+		dpp1_cm_program_regamma_lut(
+				dpp_base, params->rgb_resulted, params->hw_points_num);
+		dpp->pwl_data = *params;
+
 		re_mode = dpp->is_write_to_ram_a_safe ? 3 : 4;
 		dpp->is_write_to_ram_a_safe = !dpp->is_write_to_ram_a_safe;
 		break;
 	default:
 		break;
 	}
-
 	REG_SET(CM_RGAM_CONTROL, 0, CM_RGAM_LUT_MODE, re_mode);
 	REG_UPDATE_2(OBUF_CONTROL,
 			OBUF_BYPASS, obuf_bypass,
@@ -454,7 +450,6 @@ static const struct dpp_funcs dcn10_dpp_funcs = {
 		.opp_program_regamma_lutb_settings = dpp1_cm_program_regamma_lutb_settings,
 		.opp_program_regamma_luta_settings = dpp1_cm_program_regamma_luta_settings,
 		.opp_program_regamma_pwl = dpp1_cm_set_regamma_pwl,
-		.opp_set_regamma_mode = dpp1_cm_set_regamma_mode,
 		.ipp_program_bias_and_scale = dpp1_program_bias_and_scale,
 		.ipp_set_degamma = dpp1_set_degamma,
 		.ipp_program_input_lut		= dpp1_program_input_lut,

commit de4a2967737114d426411a79781d9d81d0ff38d2
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Thu Oct 19 13:41:30 2017 -0400

    drm/amd/display: Apply VQ adjustments in MPO case
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 74e7c82bdc76..c5f4d5caf976 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -264,8 +264,10 @@ static void dpp1_set_degamma_format_float(
 
 void dpp1_cnv_setup (
 		struct dpp *dpp_base,
-		enum surface_pixel_format input_format,
-		enum expansion_mode mode)
+		enum surface_pixel_format format,
+		enum expansion_mode mode,
+		struct csc_transform input_csc_color_matrix,
+		enum dc_color_space input_color_space)
 {
 	uint32_t pixel_format;
 	uint32_t alpha_en;
@@ -275,8 +277,10 @@ void dpp1_cnv_setup (
 	bool is_float;
 	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	bool force_disable_cursor = false;
+	struct out_csc_color_matrix tbl_entry;
+	int i = 0;
 
-	dpp1_setup_format_flags(input_format, &fmt);
+	dpp1_setup_format_flags(format, &fmt);
 	alpha_en = 1;
 	pixel_format = 0;
 	color_space = COLOR_SPACE_SRGB;
@@ -306,7 +310,7 @@ void dpp1_cnv_setup (
 
 	dpp1_set_degamma_format_float(dpp_base, is_float);
 
-	switch (input_format) {
+	switch (format) {
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
 		pixel_format = 1;
 		break;
@@ -362,7 +366,23 @@ void dpp1_cnv_setup (
 			CNVC_SURFACE_PIXEL_FORMAT, pixel_format);
 	REG_UPDATE(FORMAT_CONTROL, FORMAT_CONTROL__ALPHA_EN, alpha_en);
 
-	dpp1_program_input_csc(dpp_base, color_space, select);
+	// if input adjustments exist, program icsc with those values
+
+	if (input_csc_color_matrix.enable_adjustment
+				== true) {
+		for (i = 0; i < 12; i++)
+			tbl_entry.regval[i] = input_csc_color_matrix.matrix[i];
+
+		tbl_entry.color_space = input_color_space;
+
+		if (color_space >= COLOR_SPACE_YCBCR601)
+			select = INPUT_CSC_SELECT_ICSC;
+		else
+			select = INPUT_CSC_SELECT_BYPASS;
+
+		dpp1_program_input_csc(dpp_base, color_space, select, &tbl_entry);
+	} else
+		dpp1_program_input_csc(dpp_base, color_space, select, NULL);
 
 	if (force_disable_cursor) {
 		REG_UPDATE(CURSOR_CONTROL,
@@ -435,6 +455,7 @@ static const struct dpp_funcs dcn10_dpp_funcs = {
 		.opp_program_regamma_luta_settings = dpp1_cm_program_regamma_luta_settings,
 		.opp_program_regamma_pwl = dpp1_cm_set_regamma_pwl,
 		.opp_set_regamma_mode = dpp1_cm_set_regamma_mode,
+		.ipp_program_bias_and_scale = dpp1_program_bias_and_scale,
 		.ipp_set_degamma = dpp1_set_degamma,
 		.ipp_program_input_lut		= dpp1_program_input_lut,
 		.ipp_program_degamma_pwl	= dpp1_set_degamma_pwl,

commit dd93752b6483094ec879efbbdb854967355b91ac
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Tue Oct 10 17:58:41 2017 -0400

    drm/amd/display: rename dscl functions
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 5960e491159d..74e7c82bdc76 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -372,7 +372,7 @@ void dpp1_cnv_setup (
 	}
 }
 
-void dcn10_set_cursor_attributes(
+void dpp1_set_cursor_attributes(
 		struct dpp *dpp_base,
 		const struct dc_cursor_attributes *attr)
 {
@@ -400,7 +400,7 @@ void dcn10_set_cursor_attributes(
 }
 
 
-void dcn10_set_cursor_position(
+void dpp1_set_cursor_position(
 		struct dpp *dpp_base,
 		const struct dc_cursor_position *pos,
 		const struct dc_cursor_mi_param *param,
@@ -440,13 +440,13 @@ static const struct dpp_funcs dcn10_dpp_funcs = {
 		.ipp_program_degamma_pwl	= dpp1_set_degamma_pwl,
 		.ipp_setup			= dpp1_cnv_setup,
 		.ipp_full_bypass		= dpp1_full_bypass,
-		.set_cursor_attributes = dcn10_set_cursor_attributes,
-		.set_cursor_position = dcn10_set_cursor_position,
+		.set_cursor_attributes = dpp1_set_cursor_attributes,
+		.set_cursor_position = dpp1_set_cursor_position,
 };
 
 static struct dpp_caps dcn10_dpp_cap = {
 	.dscl_data_proc_format = DSCL_DATA_PRCESSING_FIXED_FORMAT,
-	.dscl_calc_lb_num_partitions = dscl1_calc_lb_num_partitions,
+	.dscl_calc_lb_num_partitions = dpp1_dscl_calc_lb_num_partitions,
 };
 
 /*****************************************/

commit d94585a06b8197a723787c6c5502872abcff0e8e
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Thu Oct 5 16:47:49 2017 -0400

    drm/amd/display: rename transform to dpp for dcn
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index fb3c78858ebe..5960e491159d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -39,14 +39,14 @@
 #define BLACK_OFFSET_CBCR  0x8000
 
 #define REG(reg)\
-	xfm->tf_regs->reg
+	dpp->tf_regs->reg
 
 #define CTX \
-	xfm->base.ctx
+	dpp->base.ctx
 
 #undef FN
 #define FN(reg_name, field_name) \
-	xfm->tf_shift->field_name, xfm->tf_mask->field_name
+	dpp->tf_shift->field_name, dpp->tf_mask->field_name
 
 enum pixel_format_description {
 	PIXEL_FORMAT_FIXED = 0,
@@ -99,7 +99,7 @@ enum gamut_remap_select {
 };
 
 /* Program gamut remap in bypass mode */
-void dpp_set_gamut_remap_bypass(struct dcn10_dpp *xfm)
+void dpp_set_gamut_remap_bypass(struct dcn10_dpp *dpp)
 {
 	REG_SET(CM_GAMUT_REMAP_CONTROL, 0,
 			CM_GAMUT_REMAP_MODE, 0);
@@ -110,7 +110,7 @@ void dpp_set_gamut_remap_bypass(struct dcn10_dpp *xfm)
 
 
 bool dpp_get_optimal_number_of_taps(
-		struct transform *xfm,
+		struct dpp *dpp,
 		struct scaler_data *scl_data,
 		const struct scaling_taps *in_taps)
 {
@@ -154,7 +154,7 @@ bool dpp_get_optimal_number_of_taps(
 	else
 		scl_data->taps.h_taps_c = in_taps->h_taps_c;
 
-	if (!xfm->ctx->dc->debug.always_scale) {
+	if (!dpp->ctx->dc->debug.always_scale) {
 		if (IDENTITY_RATIO(scl_data->ratios.horz))
 			scl_data->taps.h_taps = 1;
 		if (IDENTITY_RATIO(scl_data->ratios.vert))
@@ -169,14 +169,14 @@ bool dpp_get_optimal_number_of_taps(
 	return true;
 }
 
-void dpp_reset(struct transform *xfm_base)
+void dpp_reset(struct dpp *dpp_base)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
-	xfm->filter_h_c = NULL;
-	xfm->filter_v_c = NULL;
-	xfm->filter_h = NULL;
-	xfm->filter_v = NULL;
+	dpp->filter_h_c = NULL;
+	dpp->filter_v_c = NULL;
+	dpp->filter_h = NULL;
+	dpp->filter_v = NULL;
 
 	/* set boundary mode to 0 */
 	REG_SET(DSCL_CONTROL, 0, SCL_BOUNDARY_MODE, 0);
@@ -184,28 +184,28 @@ void dpp_reset(struct transform *xfm_base)
 
 
 
-static void dcn10_dpp_cm_set_regamma_pwl(
-	struct transform *xfm_base, const struct pwl_params *params)
+static void dpp1_cm_set_regamma_pwl(
+	struct dpp *dpp_base, const struct pwl_params *params)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
-	dcn10_dpp_cm_power_on_regamma_lut(xfm_base, true);
-	dcn10_dpp_cm_configure_regamma_lut(xfm_base, xfm->is_write_to_ram_a_safe);
+	dpp1_cm_power_on_regamma_lut(dpp_base, true);
+	dpp1_cm_configure_regamma_lut(dpp_base, dpp->is_write_to_ram_a_safe);
 
-	if (xfm->is_write_to_ram_a_safe)
-		dcn10_dpp_cm_program_regamma_luta_settings(xfm_base, params);
+	if (dpp->is_write_to_ram_a_safe)
+		dpp1_cm_program_regamma_luta_settings(dpp_base, params);
 	else
-		dcn10_dpp_cm_program_regamma_lutb_settings(xfm_base, params);
+		dpp1_cm_program_regamma_lutb_settings(dpp_base, params);
 
-	dcn10_dpp_cm_program_regamma_lut(
-			xfm_base, params->rgb_resulted, params->hw_points_num);
+	dpp1_cm_program_regamma_lut(
+			dpp_base, params->rgb_resulted, params->hw_points_num);
 }
 
-static void dcn10_dpp_cm_set_regamma_mode(
-	struct transform *xfm_base,
+static void dpp1_cm_set_regamma_mode(
+	struct dpp *dpp_base,
 	enum opp_regamma mode)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	uint32_t re_mode = 0;
 	uint32_t obuf_bypass = 0; /* need for pipe split */
 	uint32_t obuf_hupscale = 0;
@@ -221,8 +221,8 @@ static void dcn10_dpp_cm_set_regamma_mode(
 		re_mode = 2;
 		break;
 	case OPP_REGAMMA_USER:
-		re_mode = xfm->is_write_to_ram_a_safe ? 3 : 4;
-		xfm->is_write_to_ram_a_safe = !xfm->is_write_to_ram_a_safe;
+		re_mode = dpp->is_write_to_ram_a_safe ? 3 : 4;
+		dpp->is_write_to_ram_a_safe = !dpp->is_write_to_ram_a_safe;
 		break;
 	default:
 		break;
@@ -234,7 +234,7 @@ static void dcn10_dpp_cm_set_regamma_mode(
 			OBUF_H_2X_UPSCALE_EN, obuf_hupscale);
 }
 
-static void ippn10_setup_format_flags(enum surface_pixel_format input_format,\
+static void dpp1_setup_format_flags(enum surface_pixel_format input_format,\
 						enum pixel_format_description *fmt)
 {
 
@@ -247,11 +247,11 @@ static void ippn10_setup_format_flags(enum surface_pixel_format input_format,\
 		*fmt = PIXEL_FORMAT_FIXED;
 }
 
-static void ippn10_set_degamma_format_float(
-		struct transform *xfm_base,
+static void dpp1_set_degamma_format_float(
+		struct dpp *dpp_base,
 		bool is_float)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 
 	if (is_float) {
 		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, 3);
@@ -262,8 +262,8 @@ static void ippn10_set_degamma_format_float(
 	}
 }
 
-void ippn10_cnv_setup (
-		struct transform *xfm_base,
+void dpp1_cnv_setup (
+		struct dpp *dpp_base,
 		enum surface_pixel_format input_format,
 		enum expansion_mode mode)
 {
@@ -273,10 +273,10 @@ void ippn10_cnv_setup (
 	enum dc_color_space color_space;
 	enum dcn10_input_csc_select select;
 	bool is_float;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	bool force_disable_cursor = false;
 
-	ippn10_setup_format_flags(input_format, &fmt);
+	dpp1_setup_format_flags(input_format, &fmt);
 	alpha_en = 1;
 	pixel_format = 0;
 	color_space = COLOR_SPACE_SRGB;
@@ -304,7 +304,7 @@ void ippn10_cnv_setup (
 		break;
 	}
 
-	ippn10_set_degamma_format_float(xfm_base, is_float);
+	dpp1_set_degamma_format_float(dpp_base, is_float);
 
 	switch (input_format) {
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
@@ -362,7 +362,7 @@ void ippn10_cnv_setup (
 			CNVC_SURFACE_PIXEL_FORMAT, pixel_format);
 	REG_UPDATE(FORMAT_CONTROL, FORMAT_CONTROL__ALPHA_EN, alpha_en);
 
-	ippn10_program_input_csc(xfm_base, color_space, select);
+	dpp1_program_input_csc(dpp_base, color_space, select);
 
 	if (force_disable_cursor) {
 		REG_UPDATE(CURSOR_CONTROL,
@@ -373,10 +373,10 @@ void ippn10_cnv_setup (
 }
 
 void dcn10_set_cursor_attributes(
-		struct transform *xfm_base,
+		struct dpp *dpp_base,
 		const struct dc_cursor_attributes *attr)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	enum dc_cursor_color_format color_format = attr->color_format;
 
 	REG_UPDATE_2(CURSOR0_CONTROL,
@@ -401,12 +401,12 @@ void dcn10_set_cursor_attributes(
 
 
 void dcn10_set_cursor_position(
-		struct transform *xfm_base,
+		struct dpp *dpp_base,
 		const struct dc_cursor_position *pos,
 		const struct dc_cursor_mi_param *param,
 		uint32_t width)
 {
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
 	int src_x_offset = pos->x - pos->x_hotspot - param->viewport_x_start;
 	uint32_t cur_en = pos->enable ? 1 : 0;
 
@@ -421,25 +421,25 @@ void dcn10_set_cursor_position(
 
 }
 
-static const struct transform_funcs dcn10_dpp_funcs = {
-		.transform_reset = dpp_reset,
-		.transform_set_scaler = dcn10_dpp_dscl_set_scaler_manual_scale,
-		.transform_get_optimal_number_of_taps = dpp_get_optimal_number_of_taps,
-		.transform_set_gamut_remap = dcn10_dpp_cm_set_gamut_remap,
-		.opp_set_csc_adjustment = dcn10_dpp_cm_set_output_csc_adjustment,
-		.opp_set_csc_default = dcn10_dpp_cm_set_output_csc_default,
-		.opp_power_on_regamma_lut = dcn10_dpp_cm_power_on_regamma_lut,
-		.opp_program_regamma_lut = dcn10_dpp_cm_program_regamma_lut,
-		.opp_configure_regamma_lut = dcn10_dpp_cm_configure_regamma_lut,
-		.opp_program_regamma_lutb_settings = dcn10_dpp_cm_program_regamma_lutb_settings,
-		.opp_program_regamma_luta_settings = dcn10_dpp_cm_program_regamma_luta_settings,
-		.opp_program_regamma_pwl = dcn10_dpp_cm_set_regamma_pwl,
-		.opp_set_regamma_mode = dcn10_dpp_cm_set_regamma_mode,
-		.ipp_set_degamma = ippn10_set_degamma,
-		.ipp_program_input_lut		= ippn10_program_input_lut,
-		.ipp_program_degamma_pwl	= ippn10_set_degamma_pwl,
-		.ipp_setup			= ippn10_cnv_setup,
-		.ipp_full_bypass		= ippn10_full_bypass,
+static const struct dpp_funcs dcn10_dpp_funcs = {
+		.dpp_reset = dpp_reset,
+		.dpp_set_scaler = dpp1_dscl_set_scaler_manual_scale,
+		.dpp_get_optimal_number_of_taps = dpp_get_optimal_number_of_taps,
+		.dpp_set_gamut_remap = dpp1_cm_set_gamut_remap,
+		.opp_set_csc_adjustment = dpp1_cm_set_output_csc_adjustment,
+		.opp_set_csc_default = dpp1_cm_set_output_csc_default,
+		.opp_power_on_regamma_lut = dpp1_cm_power_on_regamma_lut,
+		.opp_program_regamma_lut = dpp1_cm_program_regamma_lut,
+		.opp_configure_regamma_lut = dpp1_cm_configure_regamma_lut,
+		.opp_program_regamma_lutb_settings = dpp1_cm_program_regamma_lutb_settings,
+		.opp_program_regamma_luta_settings = dpp1_cm_program_regamma_luta_settings,
+		.opp_program_regamma_pwl = dpp1_cm_set_regamma_pwl,
+		.opp_set_regamma_mode = dpp1_cm_set_regamma_mode,
+		.ipp_set_degamma = dpp1_set_degamma,
+		.ipp_program_input_lut		= dpp1_program_input_lut,
+		.ipp_program_degamma_pwl	= dpp1_set_degamma_pwl,
+		.ipp_setup			= dpp1_cnv_setup,
+		.ipp_full_bypass		= dpp1_full_bypass,
 		.set_cursor_attributes = dcn10_set_cursor_attributes,
 		.set_cursor_position = dcn10_set_cursor_position,
 };
@@ -453,29 +453,29 @@ static struct dpp_caps dcn10_dpp_cap = {
 /* Constructor, Destructor               */
 /*****************************************/
 
-void dcn10_dpp_construct(
-	struct dcn10_dpp *xfm,
+void dpp1_construct(
+	struct dcn10_dpp *dpp,
 	struct dc_context *ctx,
 	uint32_t inst,
 	const struct dcn_dpp_registers *tf_regs,
 	const struct dcn_dpp_shift *tf_shift,
 	const struct dcn_dpp_mask *tf_mask)
 {
-	xfm->base.ctx = ctx;
+	dpp->base.ctx = ctx;
 
-	xfm->base.inst = inst;
-	xfm->base.funcs = &dcn10_dpp_funcs;
-	xfm->base.caps = &dcn10_dpp_cap;
+	dpp->base.inst = inst;
+	dpp->base.funcs = &dcn10_dpp_funcs;
+	dpp->base.caps = &dcn10_dpp_cap;
 
-	xfm->tf_regs = tf_regs;
-	xfm->tf_shift = tf_shift;
-	xfm->tf_mask = tf_mask;
+	dpp->tf_regs = tf_regs;
+	dpp->tf_shift = tf_shift;
+	dpp->tf_mask = tf_mask;
 
-	xfm->lb_pixel_depth_supported =
+	dpp->lb_pixel_depth_supported =
 		LB_PIXEL_DEPTH_18BPP |
 		LB_PIXEL_DEPTH_24BPP |
 		LB_PIXEL_DEPTH_30BPP;
 
-	xfm->lb_bits_per_entry = LB_BITS_PER_ENTRY;
-	xfm->lb_memory_size = LB_TOTAL_NUMBER_OF_ENTRIES; /*0x1404*/
+	dpp->lb_bits_per_entry = LB_BITS_PER_ENTRY;
+	dpp->lb_memory_size = LB_TOTAL_NUMBER_OF_ENTRIES; /*0x1404*/
 }

commit 81739b7f49bfded3bbd0b29c5213e9bcbea3c58d
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Mon Oct 2 15:03:50 2017 -0400

    drm/amd/display: Add DPP capabilities
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 05df3b222945..fb3c78858ebe 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -444,6 +444,10 @@ static const struct transform_funcs dcn10_dpp_funcs = {
 		.set_cursor_position = dcn10_set_cursor_position,
 };
 
+static struct dpp_caps dcn10_dpp_cap = {
+	.dscl_data_proc_format = DSCL_DATA_PRCESSING_FIXED_FORMAT,
+	.dscl_calc_lb_num_partitions = dscl1_calc_lb_num_partitions,
+};
 
 /*****************************************/
 /* Constructor, Destructor               */
@@ -461,6 +465,7 @@ void dcn10_dpp_construct(
 
 	xfm->base.inst = inst;
 	xfm->base.funcs = &dcn10_dpp_funcs;
+	xfm->base.caps = &dcn10_dpp_cap;
 
 	xfm->tf_regs = tf_regs;
 	xfm->tf_shift = tf_shift;

commit b87d78d6aa104b207ff588d2cfd13633c2385994
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Tue Sep 19 17:29:28 2017 -0400

    drm/amd/display: moving cursor functions from ipp to mem_input
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index f9e43e68fc0c..05df3b222945 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -372,6 +372,55 @@ void ippn10_cnv_setup (
 	}
 }
 
+void dcn10_set_cursor_attributes(
+		struct transform *xfm_base,
+		const struct dc_cursor_attributes *attr)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	enum dc_cursor_color_format color_format = attr->color_format;
+
+	REG_UPDATE_2(CURSOR0_CONTROL,
+			CUR0_MODE, color_format,
+			CUR0_EXPANSION_MODE, 0);
+
+	if (color_format == CURSOR_MODE_MONO) {
+		/* todo: clarify what to program these to */
+		REG_UPDATE(CURSOR0_COLOR0,
+				CUR0_COLOR0, 0x00000000);
+		REG_UPDATE(CURSOR0_COLOR1,
+				CUR0_COLOR1, 0xFFFFFFFF);
+	}
+
+	/* TODO: Fixed vs float */
+
+	REG_UPDATE_3(FORMAT_CONTROL,
+				CNVC_BYPASS, 0,
+				FORMAT_CONTROL__ALPHA_EN, 1,
+				FORMAT_EXPANSION_MODE, 0);
+}
+
+
+void dcn10_set_cursor_position(
+		struct transform *xfm_base,
+		const struct dc_cursor_position *pos,
+		const struct dc_cursor_mi_param *param,
+		uint32_t width)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	int src_x_offset = pos->x - pos->x_hotspot - param->viewport_x_start;
+	uint32_t cur_en = pos->enable ? 1 : 0;
+
+	if (src_x_offset >= (int)param->viewport_width)
+		cur_en = 0;  /* not visible beyond right edge*/
+
+	if (src_x_offset + (int)width < 0)
+		cur_en = 0;  /* not visible beyond left edge*/
+
+	REG_UPDATE(CURSOR0_CONTROL,
+			CUR0_ENABLE, cur_en);
+
+}
+
 static const struct transform_funcs dcn10_dpp_funcs = {
 		.transform_reset = dpp_reset,
 		.transform_set_scaler = dcn10_dpp_dscl_set_scaler_manual_scale,
@@ -391,6 +440,8 @@ static const struct transform_funcs dcn10_dpp_funcs = {
 		.ipp_program_degamma_pwl	= ippn10_set_degamma_pwl,
 		.ipp_setup			= ippn10_cnv_setup,
 		.ipp_full_bypass		= ippn10_full_bypass,
+		.set_cursor_attributes = dcn10_set_cursor_attributes,
+		.set_cursor_position = dcn10_set_cursor_position,
 };
 
 

commit 5088cc98f59b922a609078c048a25e30f94b9216
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Wed Sep 6 18:56:46 2017 -0400

    drm/amd/display: Force always scale chroma, set always_scaled to false
    
    This allows us to not always have scaling on, which causes issues with
    validation and causes the text to blur slightly.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 9d9604f05095..f9e43e68fc0c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -159,10 +159,11 @@ bool dpp_get_optimal_number_of_taps(
 			scl_data->taps.h_taps = 1;
 		if (IDENTITY_RATIO(scl_data->ratios.vert))
 			scl_data->taps.v_taps = 1;
-		if (IDENTITY_RATIO(scl_data->ratios.horz_c))
-			scl_data->taps.h_taps_c = 1;
-		if (IDENTITY_RATIO(scl_data->ratios.vert_c))
-			scl_data->taps.v_taps_c = 1;
+		/*
+		 * Spreadsheet doesn't handle taps_c is one properly,
+		 * need to force Chroma to always be scaled to pass
+		 * bandwidth validation.
+		 */
 	}
 
 	return true;

commit c13b408b81f8a101501d78ca499afee98e0f0ab9
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 14:34:39 2017 +1000

    amdgpu/dc: another round of dce/dcn construct cleanups.
    
    This removes any remaining pointless return codepaths from the
    DCE code.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 8607ab2da610..9d9604f05095 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -397,7 +397,7 @@ static const struct transform_funcs dcn10_dpp_funcs = {
 /* Constructor, Destructor               */
 /*****************************************/
 
-bool dcn10_dpp_construct(
+void dcn10_dpp_construct(
 	struct dcn10_dpp *xfm,
 	struct dc_context *ctx,
 	uint32_t inst,
@@ -421,6 +421,4 @@ bool dcn10_dpp_construct(
 
 	xfm->lb_bits_per_entry = LB_BITS_PER_ENTRY;
 	xfm->lb_memory_size = LB_TOTAL_NUMBER_OF_ENTRIES; /*0x1404*/
-
-	return true;
 }

commit 4dec2aa9eb1386e592d76f380360360178c4af02
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 14:34:35 2017 +1000

    amdgpu/dc: make program_regamma_pwl return void
    
    The return value was unused.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index ac03b04f1ea5..8607ab2da610 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -183,7 +183,7 @@ void dpp_reset(struct transform *xfm_base)
 
 
 
-static bool dcn10_dpp_cm_set_regamma_pwl(
+static void dcn10_dpp_cm_set_regamma_pwl(
 	struct transform *xfm_base, const struct pwl_params *params)
 {
 	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
@@ -198,8 +198,6 @@ static bool dcn10_dpp_cm_set_regamma_pwl(
 
 	dcn10_dpp_cm_program_regamma_lut(
 			xfm_base, params->rgb_resulted, params->hw_points_num);
-
-	return true;
 }
 
 static void dcn10_dpp_cm_set_regamma_mode(

commit 395f669eb69b8b37ed2ffe0c5f67e942e9d00dc8
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 10:39:29 2017 +1000

    amdgpu/dc: constify a bunch of dc structs.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 487694125ea4..ac03b04f1ea5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -373,7 +373,7 @@ void ippn10_cnv_setup (
 	}
 }
 
-static struct transform_funcs dcn10_dpp_funcs = {
+static const struct transform_funcs dcn10_dpp_funcs = {
 		.transform_reset = dpp_reset,
 		.transform_set_scaler = dcn10_dpp_dscl_set_scaler_manual_scale,
 		.transform_get_optimal_number_of_taps = dpp_get_optimal_number_of_taps,

commit 264efa31835dd87af4e77e3a27090e60d4fe1511
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Thu Aug 31 16:04:24 2017 -0400

    drm/amd/display: remove output_format from ipp_setup
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 99caafb27b37..487694125ea4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -266,8 +266,7 @@ static void ippn10_set_degamma_format_float(
 void ippn10_cnv_setup (
 		struct transform *xfm_base,
 		enum surface_pixel_format input_format,
-		enum expansion_mode mode,
-		enum ipp_output_format cnv_out_format)
+		enum expansion_mode mode)
 {
 	uint32_t pixel_format;
 	uint32_t alpha_en;

commit 9cffc573196bb3eea2d3dfd24893b6b9970cdfce
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Fri Aug 25 16:13:55 2017 -0400

    drm/amd/display: clean up header file includes
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 20163668e2a8..99caafb27b37 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -27,10 +27,6 @@
 
 #include "core_types.h"
 
-#include "include/grph_object_id.h"
-#include "include/fixed31_32.h"
-#include "include/logger_interface.h"
-
 #include "reg_helper.h"
 #include "dcn10_dpp.h"
 #include "basics/conversion.h"
@@ -68,22 +64,6 @@ enum dcn10_coef_filter_type_sel {
 	SCL_COEF_ALPHA_HORZ_FILTER = 5
 };
 
-enum lb_memory_config {
-	/* Enable all 3 pieces of memory */
-	LB_MEMORY_CONFIG_0 = 0,
-
-	/* Enable only the first piece of memory */
-	LB_MEMORY_CONFIG_1 = 1,
-
-	/* Enable only the second piece of memory */
-	LB_MEMORY_CONFIG_2 = 2,
-
-	/* Only applicable in 4:2:0 mode, enable all 3 pieces of memory and the
-	 * last piece of chroma memory used for the luma storage
-	 */
-	LB_MEMORY_CONFIG_3 = 3
-};
-
 enum dscl_autocal_mode {
 	AUTOCAL_MODE_OFF = 0,
 

commit b3c340fad4643b7351a4777fae37e58925db04c9
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Sat Aug 19 16:34:36 2017 -0400

    drm/amd/display: move cm registers from ipp to dpp_cm
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 30722495de0a..20163668e2a8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -52,6 +52,12 @@
 #define FN(reg_name, field_name) \
 	xfm->tf_shift->field_name, xfm->tf_mask->field_name
 
+enum pixel_format_description {
+	PIXEL_FORMAT_FIXED = 0,
+	PIXEL_FORMAT_FIXED16,
+	PIXEL_FORMAT_FLOAT
+
+};
 
 enum dcn10_coef_filter_type_sel {
 	SCL_COEF_LUMA_VERT_FILTER = 0,
@@ -249,6 +255,145 @@ static void dcn10_dpp_cm_set_regamma_mode(
 			OBUF_H_2X_UPSCALE_EN, obuf_hupscale);
 }
 
+static void ippn10_setup_format_flags(enum surface_pixel_format input_format,\
+						enum pixel_format_description *fmt)
+{
+
+	if (input_format == SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F ||
+		input_format == SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F)
+		*fmt = PIXEL_FORMAT_FLOAT;
+	else if (input_format == SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616)
+		*fmt = PIXEL_FORMAT_FIXED16;
+	else
+		*fmt = PIXEL_FORMAT_FIXED;
+}
+
+static void ippn10_set_degamma_format_float(
+		struct transform *xfm_base,
+		bool is_float)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	if (is_float) {
+		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, 3);
+		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, 1);
+	} else {
+		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_INPUT_FORMAT, 2);
+		REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, 0);
+	}
+}
+
+void ippn10_cnv_setup (
+		struct transform *xfm_base,
+		enum surface_pixel_format input_format,
+		enum expansion_mode mode,
+		enum ipp_output_format cnv_out_format)
+{
+	uint32_t pixel_format;
+	uint32_t alpha_en;
+	enum pixel_format_description fmt ;
+	enum dc_color_space color_space;
+	enum dcn10_input_csc_select select;
+	bool is_float;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	bool force_disable_cursor = false;
+
+	ippn10_setup_format_flags(input_format, &fmt);
+	alpha_en = 1;
+	pixel_format = 0;
+	color_space = COLOR_SPACE_SRGB;
+	select = INPUT_CSC_SELECT_BYPASS;
+	is_float = false;
+
+	switch (fmt) {
+	case PIXEL_FORMAT_FIXED:
+	case PIXEL_FORMAT_FIXED16:
+	/*when output is float then FORMAT_CONTROL__OUTPUT_FP=1*/
+		REG_SET_3(FORMAT_CONTROL, 0,
+			CNVC_BYPASS, 0,
+			FORMAT_EXPANSION_MODE, mode,
+			OUTPUT_FP, 0);
+		break;
+	case PIXEL_FORMAT_FLOAT:
+		REG_SET_3(FORMAT_CONTROL, 0,
+			CNVC_BYPASS, 0,
+			FORMAT_EXPANSION_MODE, mode,
+			OUTPUT_FP, 1);
+		is_float = true;
+		break;
+	default:
+
+		break;
+	}
+
+	ippn10_set_degamma_format_float(xfm_base, is_float);
+
+	switch (input_format) {
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
+		pixel_format = 1;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
+		pixel_format = 3;
+		alpha_en = 0;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
+		pixel_format = 8;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:
+		pixel_format = 10;
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
+		force_disable_cursor = false;
+		pixel_format = 65;
+		color_space = COLOR_SPACE_YCBCR709;
+		select = INPUT_CSC_SELECT_ICSC;
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
+		force_disable_cursor = true;
+		pixel_format = 64;
+		color_space = COLOR_SPACE_YCBCR709;
+		select = INPUT_CSC_SELECT_ICSC;
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:
+		force_disable_cursor = true;
+		pixel_format = 67;
+		color_space = COLOR_SPACE_YCBCR709;
+		select = INPUT_CSC_SELECT_ICSC;
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:
+		force_disable_cursor = true;
+		pixel_format = 66;
+		color_space = COLOR_SPACE_YCBCR709;
+		select = INPUT_CSC_SELECT_ICSC;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
+		pixel_format = 22;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:
+		pixel_format = 24;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:
+		pixel_format = 25;
+		break;
+	default:
+		break;
+	}
+	REG_SET(CNVC_SURFACE_PIXEL_FORMAT, 0,
+			CNVC_SURFACE_PIXEL_FORMAT, pixel_format);
+	REG_UPDATE(FORMAT_CONTROL, FORMAT_CONTROL__ALPHA_EN, alpha_en);
+
+	ippn10_program_input_csc(xfm_base, color_space, select);
+
+	if (force_disable_cursor) {
+		REG_UPDATE(CURSOR_CONTROL,
+				CURSOR_ENABLE, 0);
+		REG_UPDATE(CURSOR0_CONTROL,
+				CUR0_ENABLE, 0);
+	}
+}
+
 static struct transform_funcs dcn10_dpp_funcs = {
 		.transform_reset = dpp_reset,
 		.transform_set_scaler = dcn10_dpp_dscl_set_scaler_manual_scale,
@@ -263,6 +408,11 @@ static struct transform_funcs dcn10_dpp_funcs = {
 		.opp_program_regamma_luta_settings = dcn10_dpp_cm_program_regamma_luta_settings,
 		.opp_program_regamma_pwl = dcn10_dpp_cm_set_regamma_pwl,
 		.opp_set_regamma_mode = dcn10_dpp_cm_set_regamma_mode,
+		.ipp_set_degamma = ippn10_set_degamma,
+		.ipp_program_input_lut		= ippn10_program_input_lut,
+		.ipp_program_degamma_pwl	= ippn10_set_degamma_pwl,
+		.ipp_setup			= ippn10_cnv_setup,
+		.ipp_full_bypass		= ippn10_full_bypass,
 };
 
 

commit 58314e5812d5027edb01e0d20cf72068c95a7c10
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Sat Aug 19 12:10:28 2017 -0400

    drm/amd/display: cleanup naming of DCN DPP functions
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index f0e74afc4518..30722495de0a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -123,7 +123,7 @@ void dpp_set_gamut_remap_bypass(struct dcn10_dpp *xfm)
 #define IDENTITY_RATIO(ratio) (dal_fixed31_32_u2d19(ratio) == (1 << 19))
 
 
-static bool dpp_get_optimal_number_of_taps(
+bool dpp_get_optimal_number_of_taps(
 		struct transform *xfm,
 		struct scaler_data *scl_data,
 		const struct scaling_taps *in_taps)
@@ -182,7 +182,7 @@ static bool dpp_get_optimal_number_of_taps(
 	return true;
 }
 
-static void dpp_reset(struct transform *xfm_base)
+void dpp_reset(struct transform *xfm_base)
 {
 	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
 
@@ -197,26 +197,26 @@ static void dpp_reset(struct transform *xfm_base)
 
 
 
-static bool oppn10_set_regamma_pwl(
+static bool dcn10_dpp_cm_set_regamma_pwl(
 	struct transform *xfm_base, const struct pwl_params *params)
 {
 	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
 
-	oppn10_power_on_regamma_lut(xfm_base, true);
-	opp_configure_regamma_lut(xfm_base, xfm->is_write_to_ram_a_safe);
+	dcn10_dpp_cm_power_on_regamma_lut(xfm_base, true);
+	dcn10_dpp_cm_configure_regamma_lut(xfm_base, xfm->is_write_to_ram_a_safe);
 
 	if (xfm->is_write_to_ram_a_safe)
-		opp_program_regamma_luta_settings(xfm_base, params);
+		dcn10_dpp_cm_program_regamma_luta_settings(xfm_base, params);
 	else
-		opp_program_regamma_lutb_settings(xfm_base, params);
+		dcn10_dpp_cm_program_regamma_lutb_settings(xfm_base, params);
 
-	opp_program_regamma_lut(
+	dcn10_dpp_cm_program_regamma_lut(
 			xfm_base, params->rgb_resulted, params->hw_points_num);
 
 	return true;
 }
 
-static void oppn10_set_regamma_mode(
+static void dcn10_dpp_cm_set_regamma_mode(
 	struct transform *xfm_base,
 	enum opp_regamma mode)
 {
@@ -251,20 +251,21 @@ static void oppn10_set_regamma_mode(
 
 static struct transform_funcs dcn10_dpp_funcs = {
 		.transform_reset = dpp_reset,
-		.transform_set_scaler = dcn10_dpp_set_scaler_manual_scale,
+		.transform_set_scaler = dcn10_dpp_dscl_set_scaler_manual_scale,
 		.transform_get_optimal_number_of_taps = dpp_get_optimal_number_of_taps,
-		.transform_set_gamut_remap = dcn_dpp_set_gamut_remap,
-		.opp_set_csc_adjustment = oppn10_set_output_csc_adjustment,
-		.opp_set_csc_default = oppn10_set_output_csc_default,
-		.opp_power_on_regamma_lut = oppn10_power_on_regamma_lut,
-		.opp_program_regamma_lut = opp_program_regamma_lut,
-		.opp_configure_regamma_lut = opp_configure_regamma_lut,
-		.opp_program_regamma_lutb_settings = opp_program_regamma_lutb_settings,
-		.opp_program_regamma_luta_settings = opp_program_regamma_luta_settings,
-		.opp_program_regamma_pwl = oppn10_set_regamma_pwl,
-		.opp_set_regamma_mode = oppn10_set_regamma_mode,
+		.transform_set_gamut_remap = dcn10_dpp_cm_set_gamut_remap,
+		.opp_set_csc_adjustment = dcn10_dpp_cm_set_output_csc_adjustment,
+		.opp_set_csc_default = dcn10_dpp_cm_set_output_csc_default,
+		.opp_power_on_regamma_lut = dcn10_dpp_cm_power_on_regamma_lut,
+		.opp_program_regamma_lut = dcn10_dpp_cm_program_regamma_lut,
+		.opp_configure_regamma_lut = dcn10_dpp_cm_configure_regamma_lut,
+		.opp_program_regamma_lutb_settings = dcn10_dpp_cm_program_regamma_lutb_settings,
+		.opp_program_regamma_luta_settings = dcn10_dpp_cm_program_regamma_luta_settings,
+		.opp_program_regamma_pwl = dcn10_dpp_cm_set_regamma_pwl,
+		.opp_set_regamma_mode = dcn10_dpp_cm_set_regamma_mode,
 };
 
+
 /*****************************************/
 /* Constructor, Destructor               */
 /*****************************************/

commit dff2721bd1d777eba3917f04d4b8adede89badff
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Thu Aug 17 17:17:37 2017 -0400

    drm/amd/display: separate cm functions out from dcn10_dpp
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index a841ed36c217..f0e74afc4518 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -195,669 +195,7 @@ static void dpp_reset(struct transform *xfm_base)
 	REG_SET(DSCL_CONTROL, 0, SCL_BOUNDARY_MODE, 0);
 }
 
-static void program_gamut_remap(
-		struct dcn10_dpp *xfm,
-		const uint16_t *regval,
-		enum gamut_remap_select select)
-{
-	 uint16_t selection = 0;
-
-	if (regval == NULL || select == GAMUT_REMAP_BYPASS) {
-		REG_SET(CM_GAMUT_REMAP_CONTROL, 0,
-				CM_GAMUT_REMAP_MODE, 0);
-		return;
-	}
-	switch (select) {
-	case GAMUT_REMAP_COEFF:
-		selection = 1;
-		break;
-	case GAMUT_REMAP_COMA_COEFF:
-		selection = 2;
-		break;
-	case GAMUT_REMAP_COMB_COEFF:
-		selection = 3;
-		break;
-	default:
-		break;
-	}
-
-
-	if (select == GAMUT_REMAP_COEFF) {
-
-		REG_SET_2(CM_GAMUT_REMAP_C11_C12, 0,
-				CM_GAMUT_REMAP_C11, regval[0],
-				CM_GAMUT_REMAP_C12, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_GAMUT_REMAP_C13_C14, 0,
-				CM_GAMUT_REMAP_C13, regval[0],
-				CM_GAMUT_REMAP_C14, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_GAMUT_REMAP_C21_C22, 0,
-				CM_GAMUT_REMAP_C21, regval[0],
-				CM_GAMUT_REMAP_C22, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_GAMUT_REMAP_C23_C24, 0,
-				CM_GAMUT_REMAP_C23, regval[0],
-				CM_GAMUT_REMAP_C24, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_GAMUT_REMAP_C31_C32, 0,
-				CM_GAMUT_REMAP_C31, regval[0],
-				CM_GAMUT_REMAP_C32, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_GAMUT_REMAP_C33_C34, 0,
-				CM_GAMUT_REMAP_C33, regval[0],
-				CM_GAMUT_REMAP_C34, regval[1]);
-
-	} else  if (select == GAMUT_REMAP_COMA_COEFF) {
-		REG_SET_2(CM_COMA_C11_C12, 0,
-				CM_COMA_C11, regval[0],
-				CM_COMA_C12, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMA_C13_C14, 0,
-				CM_COMA_C13, regval[0],
-				CM_COMA_C14, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMA_C21_C22, 0,
-				CM_COMA_C21, regval[0],
-				CM_COMA_C22, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMA_C23_C24, 0,
-				CM_COMA_C23, regval[0],
-				CM_COMA_C24, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMA_C31_C32, 0,
-				CM_COMA_C31, regval[0],
-				CM_COMA_C32, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMA_C33_C34, 0,
-				CM_COMA_C33, regval[0],
-				CM_COMA_C34, regval[1]);
-
-	} else {
-		REG_SET_2(CM_COMB_C11_C12, 0,
-				CM_COMB_C11, regval[0],
-				CM_COMB_C12, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMB_C13_C14, 0,
-				CM_COMB_C13, regval[0],
-				CM_COMB_C14, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMB_C21_C22, 0,
-				CM_COMB_C21, regval[0],
-				CM_COMB_C22, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMB_C23_C24, 0,
-				CM_COMB_C23, regval[0],
-				CM_COMB_C24, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMB_C31_C32, 0,
-				CM_COMB_C31, regval[0],
-				CM_COMB_C32, regval[1]);
-		regval += 2;
-		REG_SET_2(CM_COMB_C33_C34, 0,
-				CM_COMB_C33, regval[0],
-				CM_COMB_C34, regval[1]);
-	}
-
-	REG_SET(
-			CM_GAMUT_REMAP_CONTROL, 0,
-			CM_GAMUT_REMAP_MODE, selection);
-
-}
-
-static void dcn_dpp_set_gamut_remap(
-	struct transform *xfm,
-	const struct xfm_grph_csc_adjustment *adjust)
-{
-	struct dcn10_dpp *dcn_xfm = TO_DCN10_DPP(xfm);
-
-	if (adjust->gamut_adjust_type != GRAPHICS_GAMUT_ADJUST_TYPE_SW)
-		/* Bypass if type is bypass or hw */
-		program_gamut_remap(dcn_xfm, NULL, GAMUT_REMAP_BYPASS);
-	else {
-		struct fixed31_32 arr_matrix[12];
-		uint16_t arr_reg_val[12];
-
-		arr_matrix[0] = adjust->temperature_matrix[0];
-		arr_matrix[1] = adjust->temperature_matrix[1];
-		arr_matrix[2] = adjust->temperature_matrix[2];
-		arr_matrix[3] = dal_fixed31_32_zero;
-
-		arr_matrix[4] = adjust->temperature_matrix[3];
-		arr_matrix[5] = adjust->temperature_matrix[4];
-		arr_matrix[6] = adjust->temperature_matrix[5];
-		arr_matrix[7] = dal_fixed31_32_zero;
-
-		arr_matrix[8] = adjust->temperature_matrix[6];
-		arr_matrix[9] = adjust->temperature_matrix[7];
-		arr_matrix[10] = adjust->temperature_matrix[8];
-		arr_matrix[11] = dal_fixed31_32_zero;
-
-		convert_float_matrix(
-			arr_reg_val, arr_matrix, 12);
-
-		program_gamut_remap(dcn_xfm, arr_reg_val, GAMUT_REMAP_COEFF);
-	}
-}
 
-static void oppn10_set_output_csc_default(
-		struct transform *xfm_base,
-		const struct default_adjustment *default_adjust)
-{
-
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	uint32_t ocsc_mode = 0;
-
-	if (default_adjust != NULL) {
-		switch (default_adjust->out_color_space) {
-		case COLOR_SPACE_SRGB:
-		case COLOR_SPACE_2020_RGB_FULLRANGE:
-			ocsc_mode = 0;
-			break;
-		case COLOR_SPACE_SRGB_LIMITED:
-		case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
-			ocsc_mode = 1;
-			break;
-		case COLOR_SPACE_YCBCR601:
-		case COLOR_SPACE_YCBCR601_LIMITED:
-			ocsc_mode = 2;
-			break;
-		case COLOR_SPACE_YCBCR709:
-		case COLOR_SPACE_YCBCR709_LIMITED:
-		case COLOR_SPACE_2020_YCBCR:
-			ocsc_mode = 3;
-			break;
-		case COLOR_SPACE_UNKNOWN:
-		default:
-			break;
-		}
-	}
-
-	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
-
-}
-
-static void oppn10_program_color_matrix(
-		struct dcn10_dpp *xfm,
-		const struct out_csc_color_matrix *tbl_entry)
-{
-	uint32_t mode;
-
-	REG_GET(CM_OCSC_CONTROL, CM_OCSC_MODE, &mode);
-
-	if (tbl_entry == NULL) {
-		BREAK_TO_DEBUGGER();
-		return;
-	}
-
-	if (mode == 4) {
-		/*R*/
-		REG_SET_2(CM_OCSC_C11_C12, 0,
-			CM_OCSC_C11, tbl_entry->regval[0],
-			CM_OCSC_C12, tbl_entry->regval[1]);
-
-		REG_SET_2(CM_OCSC_C13_C14, 0,
-			CM_OCSC_C13, tbl_entry->regval[2],
-			CM_OCSC_C14, tbl_entry->regval[3]);
-
-		/*G*/
-		REG_SET_2(CM_OCSC_C21_C22, 0,
-			CM_OCSC_C21, tbl_entry->regval[4],
-			CM_OCSC_C22, tbl_entry->regval[5]);
-
-		REG_SET_2(CM_OCSC_C23_C24, 0,
-			CM_OCSC_C23, tbl_entry->regval[6],
-			CM_OCSC_C24, tbl_entry->regval[7]);
-
-		/*B*/
-		REG_SET_2(CM_OCSC_C31_C32, 0,
-			CM_OCSC_C31, tbl_entry->regval[8],
-			CM_OCSC_C32, tbl_entry->regval[9]);
-
-		REG_SET_2(CM_OCSC_C33_C34, 0,
-			CM_OCSC_C33, tbl_entry->regval[10],
-			CM_OCSC_C34, tbl_entry->regval[11]);
-	} else {
-		/*R*/
-		REG_SET_2(CM_COMB_C11_C12, 0,
-			CM_COMB_C11, tbl_entry->regval[0],
-			CM_COMB_C12, tbl_entry->regval[1]);
-
-		REG_SET_2(CM_COMB_C13_C14, 0,
-			CM_COMB_C13, tbl_entry->regval[2],
-			CM_COMB_C14, tbl_entry->regval[3]);
-
-		/*G*/
-		REG_SET_2(CM_COMB_C21_C22, 0,
-			CM_COMB_C21, tbl_entry->regval[4],
-			CM_COMB_C22, tbl_entry->regval[5]);
-
-		REG_SET_2(CM_COMB_C23_C24, 0,
-			CM_COMB_C23, tbl_entry->regval[6],
-			CM_COMB_C24, tbl_entry->regval[7]);
-
-		/*B*/
-		REG_SET_2(CM_COMB_C31_C32, 0,
-			CM_COMB_C31, tbl_entry->regval[8],
-			CM_COMB_C32, tbl_entry->regval[9]);
-
-		REG_SET_2(CM_COMB_C33_C34, 0,
-			CM_COMB_C33, tbl_entry->regval[10],
-			CM_COMB_C34, tbl_entry->regval[11]);
-	}
-}
-
-static void oppn10_set_output_csc_adjustment(
-		struct transform *xfm_base,
-		const struct out_csc_color_matrix *tbl_entry)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	//enum csc_color_mode config = CSC_COLOR_MODE_GRAPHICS_OUTPUT_CSC;
-	uint32_t ocsc_mode = 4;
-
-	/**
-	*if (tbl_entry != NULL) {
-	*	switch (tbl_entry->color_space) {
-	*	case COLOR_SPACE_SRGB:
-	*	case COLOR_SPACE_2020_RGB_FULLRANGE:
-	*		ocsc_mode = 0;
-	*		break;
-	*	case COLOR_SPACE_SRGB_LIMITED:
-	*	case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
-	*		ocsc_mode = 1;
-	*		break;
-	*	case COLOR_SPACE_YCBCR601:
-	*	case COLOR_SPACE_YCBCR601_LIMITED:
-	*		ocsc_mode = 2;
-	*		break;
-	*	case COLOR_SPACE_YCBCR709:
-	*	case COLOR_SPACE_YCBCR709_LIMITED:
-	*	case COLOR_SPACE_2020_YCBCR:
-	*		ocsc_mode = 3;
-	*		break;
-	*	case COLOR_SPACE_UNKNOWN:
-	*	default:
-	*		break;
-	*	}
-	*}
-	*/
-
-	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
-	oppn10_program_color_matrix(xfm, tbl_entry);
-}
-
-static void oppn10_power_on_regamma_lut(
-	struct transform *xfm_base,
-	bool power_on)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	REG_SET(CM_MEM_PWR_CTRL, 0,
-			RGAM_MEM_PWR_FORCE, power_on == true ? 0:1);
-
-}
-
-static void opp_program_regamma_lut(
-		struct transform *xfm_base,
-		const struct pwl_result_data *rgb,
-		uint32_t num)
-{
-	uint32_t i;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	for (i = 0 ; i < num; i++) {
-		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].red_reg);
-		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].green_reg);
-		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].blue_reg);
-
-		REG_SET(CM_RGAM_LUT_DATA, 0,
-				CM_RGAM_LUT_DATA, rgb[i].delta_red_reg);
-		REG_SET(CM_RGAM_LUT_DATA, 0,
-				CM_RGAM_LUT_DATA, rgb[i].delta_green_reg);
-		REG_SET(CM_RGAM_LUT_DATA, 0,
-				CM_RGAM_LUT_DATA, rgb[i].delta_blue_reg);
-
-	}
-
-}
-
-static void opp_configure_regamma_lut(
-		struct transform *xfm_base,
-		bool is_ram_a)
-{
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-
-	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
-			CM_RGAM_LUT_WRITE_EN_MASK, 7);
-	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
-			CM_RGAM_LUT_WRITE_SEL, is_ram_a == true ? 0:1);
-	REG_SET(CM_RGAM_LUT_INDEX, 0, CM_RGAM_LUT_INDEX, 0);
-}
-
-/*program re gamma RAM A*/
-static void opp_program_regamma_luta_settings(
-		struct transform *xfm_base,
-		const struct pwl_params *params)
-{
-	const struct gamma_curve *curve;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-
-	REG_SET_2(CM_RGAM_RAMA_START_CNTL_B, 0,
-		CM_RGAM_RAMA_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_B, 0);
-	REG_SET_2(CM_RGAM_RAMA_START_CNTL_G, 0,
-		CM_RGAM_RAMA_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_G, 0);
-	REG_SET_2(CM_RGAM_RAMA_START_CNTL_R, 0,
-		CM_RGAM_RAMA_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_R, 0);
-
-	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_B, 0,
-		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
-	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_G, 0,
-		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
-	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_R, 0,
-		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
-
-	REG_SET(CM_RGAM_RAMA_END_CNTL1_B, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_B, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMA_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
-
-	REG_SET(CM_RGAM_RAMA_END_CNTL1_G, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_G, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMA_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
-
-	REG_SET(CM_RGAM_RAMA_END_CNTL1_R, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_R, 0,
-		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMA_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
-
-	curve = params->arr_curve_points;
-	REG_SET_4(CM_RGAM_RAMA_REGION_0_1, 0,
-		CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_2_3, 0,
-		CM_RGAM_RAMA_EXP_REGION2_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION3_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_4_5, 0,
-		CM_RGAM_RAMA_EXP_REGION4_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION5_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_6_7, 0,
-		CM_RGAM_RAMA_EXP_REGION6_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION7_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_8_9, 0,
-		CM_RGAM_RAMA_EXP_REGION8_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION9_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_10_11, 0,
-		CM_RGAM_RAMA_EXP_REGION10_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION11_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_12_13, 0,
-		CM_RGAM_RAMA_EXP_REGION12_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION13_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_14_15, 0,
-		CM_RGAM_RAMA_EXP_REGION14_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION15_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_16_17, 0,
-		CM_RGAM_RAMA_EXP_REGION16_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION17_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_18_19, 0,
-		CM_RGAM_RAMA_EXP_REGION18_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION19_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_20_21, 0,
-		CM_RGAM_RAMA_EXP_REGION20_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION21_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_22_23, 0,
-		CM_RGAM_RAMA_EXP_REGION22_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION23_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_24_25, 0,
-		CM_RGAM_RAMA_EXP_REGION24_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION25_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_26_27, 0,
-		CM_RGAM_RAMA_EXP_REGION26_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION27_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_28_29, 0,
-		CM_RGAM_RAMA_EXP_REGION28_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION29_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_30_31, 0,
-		CM_RGAM_RAMA_EXP_REGION30_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION31_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMA_REGION_32_33, 0,
-		CM_RGAM_RAMA_EXP_REGION32_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMA_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMA_EXP_REGION33_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMA_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);
-}
-
-/*program re gamma RAM B*/
-static void opp_program_regamma_lutb_settings(
-		struct transform *xfm_base,
-		const struct pwl_params *params)
-{
-	const struct gamma_curve *curve;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-
-	REG_SET_2(CM_RGAM_RAMB_START_CNTL_B, 0,
-		CM_RGAM_RAMB_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B, 0);
-	REG_SET_2(CM_RGAM_RAMB_START_CNTL_G, 0,
-		CM_RGAM_RAMB_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_G, 0);
-	REG_SET_2(CM_RGAM_RAMB_START_CNTL_R, 0,
-		CM_RGAM_RAMB_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
-		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_R, 0);
-
-	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_B, 0,
-		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
-	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_G, 0,
-		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
-	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_R, 0,
-		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
-
-	REG_SET(CM_RGAM_RAMB_END_CNTL1_B, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_B, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMB_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
-
-	REG_SET(CM_RGAM_RAMB_END_CNTL1_G, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_G, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMB_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
-
-	REG_SET(CM_RGAM_RAMB_END_CNTL1_R, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
-	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_R, 0,
-		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
-		CM_RGAM_RAMB_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
-
-	curve = params->arr_curve_points;
-	REG_SET_4(CM_RGAM_RAMB_REGION_0_1, 0,
-		CM_RGAM_RAMB_EXP_REGION0_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION1_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_2_3, 0,
-		CM_RGAM_RAMB_EXP_REGION2_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION3_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_4_5, 0,
-		CM_RGAM_RAMB_EXP_REGION4_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION5_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_6_7, 0,
-		CM_RGAM_RAMB_EXP_REGION6_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION7_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_8_9, 0,
-		CM_RGAM_RAMB_EXP_REGION8_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION9_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_10_11, 0,
-		CM_RGAM_RAMB_EXP_REGION10_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION11_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_12_13, 0,
-		CM_RGAM_RAMB_EXP_REGION12_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION13_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_14_15, 0,
-		CM_RGAM_RAMB_EXP_REGION14_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION15_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_16_17, 0,
-		CM_RGAM_RAMB_EXP_REGION16_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION17_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_18_19, 0,
-		CM_RGAM_RAMB_EXP_REGION18_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION19_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_20_21, 0,
-		CM_RGAM_RAMB_EXP_REGION20_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION21_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_22_23, 0,
-		CM_RGAM_RAMB_EXP_REGION22_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION23_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_24_25, 0,
-		CM_RGAM_RAMB_EXP_REGION24_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION25_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_26_27, 0,
-		CM_RGAM_RAMB_EXP_REGION26_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION27_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_28_29, 0,
-		CM_RGAM_RAMB_EXP_REGION28_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION29_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_30_31, 0,
-		CM_RGAM_RAMB_EXP_REGION30_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION31_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);
-
-	curve += 2;
-	REG_SET_4(CM_RGAM_RAMB_REGION_32_33, 0,
-		CM_RGAM_RAMB_EXP_REGION32_LUT_OFFSET, curve[0].offset,
-		CM_RGAM_RAMB_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,
-		CM_RGAM_RAMB_EXP_REGION33_LUT_OFFSET, curve[1].offset,
-		CM_RGAM_RAMB_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);
-
-}
 
 static bool oppn10_set_regamma_pwl(
 	struct transform *xfm_base, const struct pwl_params *params)

commit 5e9a81b2c465557adbaeef7231834e3ab40e4102
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Tue Aug 15 17:44:19 2017 -0400

    drm/amd/display: separate scl functions out from dcn10_dpp
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index e52e1f43f67b..a841ed36c217 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -112,514 +112,6 @@ enum gamut_remap_select {
 	GAMUT_REMAP_COMB_COEFF
 };
 
-static void dpp_set_overscan(
-	struct dcn10_dpp *xfm,
-	const struct scaler_data *data)
-{
-	uint32_t left = data->recout.x;
-	uint32_t top = data->recout.y;
-
-	int right = data->h_active - data->recout.x - data->recout.width;
-	int bottom = data->v_active - data->recout.y - data->recout.height;
-
-	if (right < 0) {
-		BREAK_TO_DEBUGGER();
-		right = 0;
-	}
-	if (bottom < 0) {
-		BREAK_TO_DEBUGGER();
-		bottom = 0;
-	}
-
-	REG_SET_2(DSCL_EXT_OVERSCAN_LEFT_RIGHT, 0,
-		EXT_OVERSCAN_LEFT, left,
-		EXT_OVERSCAN_RIGHT, right);
-
-	REG_SET_2(DSCL_EXT_OVERSCAN_TOP_BOTTOM, 0,
-		EXT_OVERSCAN_BOTTOM, bottom,
-		EXT_OVERSCAN_TOP, top);
-}
-
-static void dpp_set_otg_blank(
-		struct dcn10_dpp *xfm, const struct scaler_data *data)
-{
-	uint32_t h_blank_start = data->h_active;
-	uint32_t h_blank_end = 0;
-	uint32_t v_blank_start = data->v_active;
-	uint32_t v_blank_end = 0;
-
-	REG_SET_2(OTG_H_BLANK, 0,
-			OTG_H_BLANK_START, h_blank_start,
-			OTG_H_BLANK_END, h_blank_end);
-
-	REG_SET_2(OTG_V_BLANK, 0,
-			OTG_V_BLANK_START, v_blank_start,
-			OTG_V_BLANK_END, v_blank_end);
-}
-
-static enum dscl_mode_sel get_dscl_mode(
-		const struct scaler_data *data, bool dbg_always_scale)
-{
-	const long long one = dal_fixed31_32_one.value;
-	bool ycbcr = false;
-	bool format420 = false;
-
-	if (data->format == PIXEL_FORMAT_FP16)
-		return DSCL_MODE_DSCL_BYPASS;
-
-	if (data->format >= PIXEL_FORMAT_VIDEO_BEGIN
-			&& data->format <= PIXEL_FORMAT_VIDEO_END)
-		ycbcr = true;
-
-	if (data->format == PIXEL_FORMAT_420BPP8 ||
-			data->format == PIXEL_FORMAT_420BPP10)
-		format420 = true;
-
-	if (data->ratios.horz.value == one
-			&& data->ratios.vert.value == one
-			&& data->ratios.horz_c.value == one
-			&& data->ratios.vert_c.value == one
-			&& !dbg_always_scale)
-		return DSCL_MODE_SCALING_444_BYPASS;
-
-	if (!format420) {
-		if (ycbcr)
-			return DSCL_MODE_SCALING_444_YCBCR_ENABLE;
-		else
-			return DSCL_MODE_SCALING_444_RGB_ENABLE;
-	}
-	if (data->ratios.horz.value == one && data->ratios.vert.value == one)
-		return DSCL_MODE_SCALING_420_LUMA_BYPASS;
-	if (data->ratios.horz_c.value == one && data->ratios.vert_c.value == one)
-		return DSCL_MODE_SCALING_420_CHROMA_BYPASS;
-
-	return DSCL_MODE_SCALING_420_YCBCR_ENABLE;
-}
-
-static int get_pixel_depth_val(enum lb_pixel_depth depth)
-{
-	if (depth == LB_PIXEL_DEPTH_30BPP)
-		return 0; /* 10 bpc */
-	else if (depth == LB_PIXEL_DEPTH_24BPP)
-		return 1; /* 8 bpc */
-	else if (depth == LB_PIXEL_DEPTH_18BPP)
-		return 2; /* 6 bpc */
-	else if (depth == LB_PIXEL_DEPTH_36BPP)
-		return 3; /* 12 bpc */
-	else {
-		ASSERT(0);
-		return -1; /* Unsupported */
-	}
-}
-
-static void dpp_set_lb(
-	struct dcn10_dpp *xfm,
-	const struct line_buffer_params *lb_params,
-	enum lb_memory_config mem_size_config)
-{
-	uint32_t pixel_depth = get_pixel_depth_val(lb_params->depth);
-	uint32_t dyn_pix_depth = lb_params->dynamic_pixel_depth;
-	REG_SET_7(LB_DATA_FORMAT, 0,
-		PIXEL_DEPTH, pixel_depth, /* Pixel depth stored in LB */
-		PIXEL_EXPAN_MODE, lb_params->pixel_expan_mode, /* Pixel expansion mode */
-		PIXEL_REDUCE_MODE, 1, /* Pixel reduction mode: Rounding */
-		DYNAMIC_PIXEL_DEPTH, dyn_pix_depth, /* Dynamic expansion pixel depth */
-		DITHER_EN, 0, /* Dithering enable: Disabled */
-		INTERLEAVE_EN, lb_params->interleave_en, /* Interleave source enable */
-		ALPHA_EN, lb_params->alpha_en); /* Alpha enable */
-
-	REG_SET_2(LB_MEMORY_CTRL, 0,
-		MEMORY_CONFIG, mem_size_config,
-		LB_MAX_PARTITIONS, 63);
-}
-
-static void dpp_set_scaler_filter(
-		struct dcn10_dpp *xfm,
-		uint32_t taps,
-		enum dcn10_coef_filter_type_sel filter_type,
-		const uint16_t *filter)
-{
-	const int tap_pairs = (taps + 1) / 2;
-	int phase;
-	int pair;
-	uint16_t odd_coef, even_coef;
-
-	REG_SET_3(SCL_COEF_RAM_TAP_SELECT, 0,
-		SCL_COEF_RAM_TAP_PAIR_IDX, 0,
-		SCL_COEF_RAM_PHASE, 0,
-		SCL_COEF_RAM_FILTER_TYPE, filter_type);
-
-	for (phase = 0; phase < (NUM_PHASES / 2 + 1); phase++) {
-		for (pair = 0; pair < tap_pairs; pair++) {
-			even_coef = filter[phase * taps + 2 * pair];
-			if ((pair * 2 + 1) < taps)
-				odd_coef = filter[phase * taps + 2 * pair + 1];
-			else
-				odd_coef = 0;
-
-			REG_SET_4(SCL_COEF_RAM_TAP_DATA, 0,
-				/* Even tap coefficient (bits 1:0 fixed to 0) */
-				SCL_COEF_RAM_EVEN_TAP_COEF, even_coef,
-				/* Write/read control for even coefficient */
-				SCL_COEF_RAM_EVEN_TAP_COEF_EN, 1,
-				/* Odd tap coefficient (bits 1:0 fixed to 0) */
-				SCL_COEF_RAM_ODD_TAP_COEF, odd_coef,
-				/* Write/read control for odd coefficient */
-				SCL_COEF_RAM_ODD_TAP_COEF_EN, 1);
-		}
-	}
-
-}
-
-#if 0
-bool dpp_set_pixel_storage_depth(
-	struct dpp *xfm,
-	enum lb_pixel_depth depth,
-	const struct bit_depth_reduction_params *bit_depth_params)
-{
-	struct dcn10_dpp *xfm110 = TO_DCN10_DPP(xfm);
-	bool ret = true;
-	uint32_t value;
-	enum dc_color_depth color_depth;
-
-	value = dm_read_reg(xfm->ctx, LB_REG(mmLB_DATA_FORMAT));
-	switch (depth) {
-	case LB_PIXEL_DEPTH_18BPP:
-		color_depth = COLOR_DEPTH_666;
-		set_reg_field_value(value, 2, LB_DATA_FORMAT, PIXEL_DEPTH);
-		set_reg_field_value(value, 1, LB_DATA_FORMAT, PIXEL_EXPAN_MODE);
-		break;
-	case LB_PIXEL_DEPTH_24BPP:
-		color_depth = COLOR_DEPTH_888;
-		set_reg_field_value(value, 1, LB_DATA_FORMAT, PIXEL_DEPTH);
-		set_reg_field_value(value, 1, LB_DATA_FORMAT, PIXEL_EXPAN_MODE);
-		break;
-	case LB_PIXEL_DEPTH_30BPP:
-		color_depth = COLOR_DEPTH_101010;
-		set_reg_field_value(value, 0, LB_DATA_FORMAT, PIXEL_DEPTH);
-		set_reg_field_value(value, 1, LB_DATA_FORMAT, PIXEL_EXPAN_MODE);
-		break;
-	case LB_PIXEL_DEPTH_36BPP:
-		color_depth = COLOR_DEPTH_121212;
-		set_reg_field_value(value, 3, LB_DATA_FORMAT, PIXEL_DEPTH);
-		set_reg_field_value(value, 0, LB_DATA_FORMAT, PIXEL_EXPAN_MODE);
-		break;
-	default:
-		ret = false;
-		break;
-	}
-
-	if (ret == true) {
-		set_denormalization(xfm110, color_depth);
-		ret = program_bit_depth_reduction(xfm110, color_depth,
-				bit_depth_params);
-
-		set_reg_field_value(value, 0, LB_DATA_FORMAT, ALPHA_EN);
-		dm_write_reg(xfm->ctx, LB_REG(mmLB_DATA_FORMAT), value);
-		if (!(xfm110->lb_pixel_depth_supported & depth)) {
-			/* We should use unsupported capabilities
-			 * unless it is required by w/a
-			 */
-			dm_logger_write(xfm->ctx->logger, LOG_WARNING,
-				"%s: Capability not supported",
-				__func__);
-		}
-	}
-
-	return ret;
-}
-#endif
-
-static const uint16_t *get_filter_coeffs_64p(int taps, struct fixed31_32 ratio)
-{
-	if (taps == 8)
-		return get_filter_8tap_64p(ratio);
-	else if (taps == 7)
-		return get_filter_7tap_64p(ratio);
-	else if (taps == 6)
-		return get_filter_6tap_64p(ratio);
-	else if (taps == 5)
-		return get_filter_5tap_64p(ratio);
-	else if (taps == 4)
-		return get_filter_4tap_64p(ratio);
-	else if (taps == 3)
-		return get_filter_3tap_64p(ratio);
-	else if (taps == 2)
-		return filter_2tap_64p;
-	else if (taps == 1)
-		return NULL;
-	else {
-		/* should never happen, bug */
-		BREAK_TO_DEBUGGER();
-		return NULL;
-	}
-}
-
-static void dpp_set_scl_filter(
-		struct dcn10_dpp *xfm,
-		const struct scaler_data *scl_data,
-		bool chroma_coef_mode)
-{
-	bool h_2tap_hardcode_coef_en = false;
-	bool v_2tap_hardcode_coef_en = false;
-	bool h_2tap_sharp_en = false;
-	bool v_2tap_sharp_en = false;
-	uint32_t h_2tap_sharp_factor = scl_data->sharpness.horz;
-	uint32_t v_2tap_sharp_factor = scl_data->sharpness.vert;
-	bool coef_ram_current;
-	const uint16_t *filter_h = NULL;
-	const uint16_t *filter_v = NULL;
-	const uint16_t *filter_h_c = NULL;
-	const uint16_t *filter_v_c = NULL;
-
-	h_2tap_hardcode_coef_en = scl_data->taps.h_taps < 3
-					&& scl_data->taps.h_taps_c < 3
-		&& (scl_data->taps.h_taps > 1 || scl_data->taps.h_taps_c > 1);
-	v_2tap_hardcode_coef_en = scl_data->taps.v_taps < 3
-					&& scl_data->taps.v_taps_c < 3
-		&& (scl_data->taps.v_taps > 1 || scl_data->taps.v_taps_c > 1);
-
-	h_2tap_sharp_en = h_2tap_hardcode_coef_en && h_2tap_sharp_factor != 0;
-	v_2tap_sharp_en = v_2tap_hardcode_coef_en && v_2tap_sharp_factor != 0;
-
-	REG_UPDATE_6(DSCL_2TAP_CONTROL,
-		SCL_H_2TAP_HARDCODE_COEF_EN, h_2tap_hardcode_coef_en,
-		SCL_H_2TAP_SHARP_EN, h_2tap_sharp_en,
-		SCL_H_2TAP_SHARP_FACTOR, h_2tap_sharp_factor,
-		SCL_V_2TAP_HARDCODE_COEF_EN, v_2tap_hardcode_coef_en,
-		SCL_V_2TAP_SHARP_EN, v_2tap_sharp_en,
-		SCL_V_2TAP_SHARP_FACTOR, v_2tap_sharp_factor);
-
-	if (!v_2tap_hardcode_coef_en || !h_2tap_hardcode_coef_en) {
-		bool filter_updated = false;
-
-		filter_h = get_filter_coeffs_64p(
-				scl_data->taps.h_taps, scl_data->ratios.horz);
-		filter_v = get_filter_coeffs_64p(
-				scl_data->taps.v_taps, scl_data->ratios.vert);
-
-		filter_updated = (filter_h && (filter_h != xfm->filter_h))
-				|| (filter_v && (filter_v != xfm->filter_v));
-
-		if (chroma_coef_mode) {
-			filter_h_c = get_filter_coeffs_64p(
-					scl_data->taps.h_taps_c, scl_data->ratios.horz_c);
-			filter_v_c = get_filter_coeffs_64p(
-					scl_data->taps.v_taps_c, scl_data->ratios.vert_c);
-			filter_updated = filter_updated || (filter_h_c && (filter_h_c != xfm->filter_h_c))
-							|| (filter_v_c && (filter_v_c != xfm->filter_v_c));
-		}
-
-		if (filter_updated) {
-			uint32_t scl_mode = REG_READ(SCL_MODE);
-
-			if (!h_2tap_hardcode_coef_en && filter_h) {
-				dpp_set_scaler_filter(
-					xfm, scl_data->taps.h_taps,
-					SCL_COEF_LUMA_HORZ_FILTER, filter_h);
-			}
-			xfm->filter_h = filter_h;
-			if (!v_2tap_hardcode_coef_en && filter_v) {
-				dpp_set_scaler_filter(
-					xfm, scl_data->taps.v_taps,
-					SCL_COEF_LUMA_VERT_FILTER, filter_v);
-			}
-			xfm->filter_v = filter_v;
-			if (chroma_coef_mode) {
-				if (!h_2tap_hardcode_coef_en && filter_h_c) {
-					dpp_set_scaler_filter(
-						xfm, scl_data->taps.h_taps_c,
-						SCL_COEF_CHROMA_HORZ_FILTER, filter_h_c);
-				}
-				if (!v_2tap_hardcode_coef_en && filter_v_c) {
-					dpp_set_scaler_filter(
-						xfm, scl_data->taps.v_taps_c,
-						SCL_COEF_CHROMA_VERT_FILTER, filter_v_c);
-				}
-			}
-			xfm->filter_h_c = filter_h_c;
-			xfm->filter_v_c = filter_v_c;
-
-			coef_ram_current = get_reg_field_value_ex(
-				scl_mode, xfm->tf_mask->SCL_COEF_RAM_SELECT_CURRENT,
-				xfm->tf_shift->SCL_COEF_RAM_SELECT_CURRENT);
-
-			/* Swap coefficient RAM and set chroma coefficient mode */
-			REG_SET_2(SCL_MODE, scl_mode,
-					SCL_COEF_RAM_SELECT, !coef_ram_current,
-					SCL_CHROMA_COEF_MODE, chroma_coef_mode);
-		}
-	}
-}
-
-
-static int get_lb_depth_bpc(enum lb_pixel_depth depth)
-{
-	if (depth == LB_PIXEL_DEPTH_30BPP)
-		return 10;
-	else if (depth == LB_PIXEL_DEPTH_24BPP)
-		return 8;
-	else if (depth == LB_PIXEL_DEPTH_18BPP)
-		return 6;
-	else if (depth == LB_PIXEL_DEPTH_36BPP)
-		return 12;
-	else {
-		BREAK_TO_DEBUGGER();
-		return -1; /* Unsupported */
-	}
-}
-
-static void calc_lb_num_partitions(
-		const struct scaler_data *scl_data,
-		enum lb_memory_config lb_config,
-		int *num_part_y,
-		int *num_part_c)
-{
-	int line_size = scl_data->viewport.width < scl_data->recout.width ?
-			scl_data->viewport.width : scl_data->recout.width;
-	int line_size_c = scl_data->viewport_c.width < scl_data->recout.width ?
-			scl_data->viewport_c.width : scl_data->recout.width;
-	int lb_bpc = get_lb_depth_bpc(scl_data->lb_params.depth);
-	int memory_line_size_y = (line_size * lb_bpc + 71) / 72; /* +71 to ceil */
-	int memory_line_size_c = (line_size_c * lb_bpc + 71) / 72; /* +71 to ceil */
-	int memory_line_size_a = (line_size + 5) / 6; /* +5 to ceil */
-	int lb_memory_size, lb_memory_size_c, lb_memory_size_a, num_partitions_a;
-
-	if (lb_config == LB_MEMORY_CONFIG_1) {
-		lb_memory_size = 816;
-		lb_memory_size_c = 816;
-		lb_memory_size_a = 984;
-	} else if (lb_config == LB_MEMORY_CONFIG_2) {
-		lb_memory_size = 1088;
-		lb_memory_size_c = 1088;
-		lb_memory_size_a = 1312;
-	} else if (lb_config == LB_MEMORY_CONFIG_3) {
-		lb_memory_size = 816 + 1088 + 848 + 848 + 848;
-		lb_memory_size_c = 816 + 1088;
-		lb_memory_size_a = 984 + 1312 + 456;
-	} else {
-		lb_memory_size = 816 + 1088 + 848;
-		lb_memory_size_c = 816 + 1088 + 848;
-		lb_memory_size_a = 984 + 1312 + 456;
-	}
-	*num_part_y = lb_memory_size / memory_line_size_y;
-	*num_part_c = lb_memory_size_c / memory_line_size_c;
-	num_partitions_a = lb_memory_size_a / memory_line_size_a;
-
-	if (scl_data->lb_params.alpha_en
-			&& (num_partitions_a < *num_part_y))
-		*num_part_y = num_partitions_a;
-
-	if (*num_part_y > 64)
-		*num_part_y = 64;
-	if (*num_part_c > 64)
-		*num_part_c = 64;
-
-}
-
-static bool is_lb_conf_valid(int ceil_vratio, int num_partitions, int vtaps)
-{
-	if (ceil_vratio > 2)
-		return vtaps <= (num_partitions - ceil_vratio + 2);
-	else
-		return vtaps <= num_partitions;
-}
-
-/*find first match configuration which meets the min required lb size*/
-static enum lb_memory_config find_lb_memory_config(const struct scaler_data *scl_data)
-{
-	int num_part_y, num_part_c;
-	int vtaps = scl_data->taps.v_taps;
-	int vtaps_c = scl_data->taps.v_taps_c;
-	int ceil_vratio = dal_fixed31_32_ceil(scl_data->ratios.vert);
-	int ceil_vratio_c = dal_fixed31_32_ceil(scl_data->ratios.vert_c);
-
-	calc_lb_num_partitions(
-			scl_data, LB_MEMORY_CONFIG_1, &num_part_y, &num_part_c);
-
-	if (is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
-			&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))
-		return LB_MEMORY_CONFIG_1;
-
-	calc_lb_num_partitions(
-			scl_data, LB_MEMORY_CONFIG_2, &num_part_y, &num_part_c);
-
-	if (is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
-			&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))
-		return LB_MEMORY_CONFIG_2;
-
-	if (scl_data->format == PIXEL_FORMAT_420BPP8
-			|| scl_data->format == PIXEL_FORMAT_420BPP10) {
-		calc_lb_num_partitions(
-				scl_data, LB_MEMORY_CONFIG_3, &num_part_y, &num_part_c);
-
-		if (is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
-				&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))
-			return LB_MEMORY_CONFIG_3;
-	}
-
-	calc_lb_num_partitions(
-			scl_data, LB_MEMORY_CONFIG_0, &num_part_y, &num_part_c);
-
-	/*Ensure we can support the requested number of vtaps*/
-	ASSERT(is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
-			&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c));
-
-	return LB_MEMORY_CONFIG_0;
-}
-
-void dpp_set_scaler_auto_scale(
-	struct transform *xfm_base,
-	const struct scaler_data *scl_data)
-{
-	enum lb_memory_config lb_config;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	enum dscl_mode_sel dscl_mode = get_dscl_mode(
-			scl_data, xfm_base->ctx->dc->debug.always_scale);
-	bool ycbcr = scl_data->format >= PIXEL_FORMAT_VIDEO_BEGIN
-				&& scl_data->format <= PIXEL_FORMAT_VIDEO_END;
-
-	dpp_set_overscan(xfm, scl_data);
-
-	dpp_set_otg_blank(xfm, scl_data);
-
-	REG_UPDATE(SCL_MODE, DSCL_MODE, dscl_mode);
-
-	if (dscl_mode == DSCL_MODE_DSCL_BYPASS)
-		return;
-
-	lb_config =  find_lb_memory_config(scl_data);
-	dpp_set_lb(xfm, &scl_data->lb_params, lb_config);
-
-	if (dscl_mode == DSCL_MODE_SCALING_444_BYPASS)
-		return;
-
-	/* TODO: v_min */
-	REG_SET_3(DSCL_AUTOCAL, 0,
-		AUTOCAL_MODE, AUTOCAL_MODE_AUTOSCALE,
-		AUTOCAL_NUM_PIPE, 0,
-		AUTOCAL_PIPE_ID, 0);
-
-	/* Black offsets */
-	if (ycbcr)
-		REG_SET_2(SCL_BLACK_OFFSET, 0,
-				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
-				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_CBCR);
-	else
-
-		REG_SET_2(SCL_BLACK_OFFSET, 0,
-				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
-				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_RGB_Y);
-
-	REG_SET_4(SCL_TAP_CONTROL, 0,
-		SCL_V_NUM_TAPS, scl_data->taps.v_taps - 1,
-		SCL_H_NUM_TAPS, scl_data->taps.h_taps - 1,
-		SCL_V_NUM_TAPS_C, scl_data->taps.v_taps_c - 1,
-		SCL_H_NUM_TAPS_C, scl_data->taps.h_taps_c - 1);
-
-	dpp_set_scl_filter(xfm, scl_data, ycbcr);
-}
-
 /* Program gamut remap in bypass mode */
 void dpp_set_gamut_remap_bypass(struct dcn10_dpp *xfm)
 {
@@ -628,146 +120,6 @@ void dpp_set_gamut_remap_bypass(struct dcn10_dpp *xfm)
 	/* Gamut remap in bypass */
 }
 
-static void dpp_set_recout(
-			struct dcn10_dpp *xfm, const struct rect *recout)
-{
-	REG_SET_2(RECOUT_START, 0,
-		/* First pixel of RECOUT */
-			 RECOUT_START_X, recout->x,
-		/* First line of RECOUT */
-			 RECOUT_START_Y, recout->y);
-
-	REG_SET_2(RECOUT_SIZE, 0,
-		/* Number of RECOUT horizontal pixels */
-			 RECOUT_WIDTH, recout->width,
-		/* Number of RECOUT vertical lines */
-			 RECOUT_HEIGHT, recout->height
-			 - xfm->base.ctx->dc->debug.surface_visual_confirm * 4 *
-			 (xfm->base.inst + 1));
-}
-
-static void dpp_set_manual_ratio_init(
-		struct dcn10_dpp *xfm, const struct scaler_data *data)
-{
-	uint32_t init_frac = 0;
-	uint32_t init_int = 0;
-
-	REG_SET(SCL_HORZ_FILTER_SCALE_RATIO, 0,
-			SCL_H_SCALE_RATIO, dal_fixed31_32_u2d19(data->ratios.horz) << 5);
-
-	REG_SET(SCL_VERT_FILTER_SCALE_RATIO, 0,
-			SCL_V_SCALE_RATIO, dal_fixed31_32_u2d19(data->ratios.vert) << 5);
-
-	REG_SET(SCL_HORZ_FILTER_SCALE_RATIO_C, 0,
-			SCL_H_SCALE_RATIO_C, dal_fixed31_32_u2d19(data->ratios.horz_c) << 5);
-
-	REG_SET(SCL_VERT_FILTER_SCALE_RATIO_C, 0,
-			SCL_V_SCALE_RATIO_C, dal_fixed31_32_u2d19(data->ratios.vert_c) << 5);
-
-	/*
-	 * 0.24 format for fraction, first five bits zeroed
-	 */
-	init_frac = dal_fixed31_32_u0d19(data->inits.h) << 5;
-	init_int = dal_fixed31_32_floor(data->inits.h);
-	REG_SET_2(SCL_HORZ_FILTER_INIT, 0,
-		SCL_H_INIT_FRAC, init_frac,
-		SCL_H_INIT_INT, init_int);
-
-	init_frac = dal_fixed31_32_u0d19(data->inits.h_c) << 5;
-	init_int = dal_fixed31_32_floor(data->inits.h_c);
-	REG_SET_2(SCL_HORZ_FILTER_INIT_C, 0,
-		SCL_H_INIT_FRAC_C, init_frac,
-		SCL_H_INIT_INT_C, init_int);
-
-	init_frac = dal_fixed31_32_u0d19(data->inits.v) << 5;
-	init_int = dal_fixed31_32_floor(data->inits.v);
-	REG_SET_2(SCL_VERT_FILTER_INIT, 0,
-		SCL_V_INIT_FRAC, init_frac,
-		SCL_V_INIT_INT, init_int);
-
-	init_frac = dal_fixed31_32_u0d19(data->inits.v_bot) << 5;
-	init_int = dal_fixed31_32_floor(data->inits.v_bot);
-	REG_SET_2(SCL_VERT_FILTER_INIT_BOT, 0,
-		SCL_V_INIT_FRAC_BOT, init_frac,
-		SCL_V_INIT_INT_BOT, init_int);
-
-	init_frac = dal_fixed31_32_u0d19(data->inits.v_c) << 5;
-	init_int = dal_fixed31_32_floor(data->inits.v_c);
-	REG_SET_2(SCL_VERT_FILTER_INIT_C, 0,
-		SCL_V_INIT_FRAC_C, init_frac,
-		SCL_V_INIT_INT_C, init_int);
-
-	init_frac = dal_fixed31_32_u0d19(data->inits.v_c_bot) << 5;
-	init_int = dal_fixed31_32_floor(data->inits.v_c_bot);
-	REG_SET_2(SCL_VERT_FILTER_INIT_BOT_C, 0,
-		SCL_V_INIT_FRAC_BOT_C, init_frac,
-		SCL_V_INIT_INT_BOT_C, init_int);
-}
-
-/* Main function to program scaler and line buffer in manual scaling mode */
-static void dpp_set_scaler_manual_scale(
-	struct transform *xfm_base,
-	const struct scaler_data *scl_data)
-{
-	enum lb_memory_config lb_config;
-	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
-	enum dscl_mode_sel dscl_mode = get_dscl_mode(
-			scl_data, xfm_base->ctx->dc->debug.always_scale);
-	bool ycbcr = scl_data->format >= PIXEL_FORMAT_VIDEO_BEGIN
-				&& scl_data->format <= PIXEL_FORMAT_VIDEO_END;
-
-	/* Recout */
-	dpp_set_recout(xfm, &scl_data->recout);
-
-	/* MPC Size */
-	REG_SET_2(MPC_SIZE, 0,
-		/* Number of horizontal pixels of MPC */
-			 MPC_WIDTH, scl_data->h_active,
-		/* Number of vertical lines of MPC */
-			 MPC_HEIGHT, scl_data->v_active);
-
-	/* SCL mode */
-	REG_UPDATE(SCL_MODE, DSCL_MODE, dscl_mode);
-
-	if (dscl_mode == DSCL_MODE_DSCL_BYPASS)
-		return;
-	/* LB */
-	lb_config =  find_lb_memory_config(scl_data);
-	dpp_set_lb(xfm, &scl_data->lb_params, lb_config);
-
-	if (dscl_mode == DSCL_MODE_SCALING_444_BYPASS)
-		return;
-
-	/* Autocal off */
-	REG_SET_3(DSCL_AUTOCAL, 0,
-		AUTOCAL_MODE, AUTOCAL_MODE_OFF,
-		AUTOCAL_NUM_PIPE, 0,
-		AUTOCAL_PIPE_ID, 0);
-
-	/* Black offsets */
-	if (ycbcr)
-		REG_SET_2(SCL_BLACK_OFFSET, 0,
-				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
-				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_CBCR);
-	else
-
-		REG_SET_2(SCL_BLACK_OFFSET, 0,
-				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
-				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_RGB_Y);
-
-	/* Manually calculate scale ratio and init values */
-	dpp_set_manual_ratio_init(xfm, scl_data);
-
-	/* HTaps/VTaps */
-	REG_SET_4(SCL_TAP_CONTROL, 0,
-		SCL_V_NUM_TAPS, scl_data->taps.v_taps - 1,
-		SCL_H_NUM_TAPS, scl_data->taps.h_taps - 1,
-		SCL_V_NUM_TAPS_C, scl_data->taps.v_taps_c - 1,
-		SCL_H_NUM_TAPS_C, scl_data->taps.h_taps_c - 1);
-
-	dpp_set_scl_filter(xfm, scl_data, ycbcr);
-}
-
 #define IDENTITY_RATIO(ratio) (dal_fixed31_32_u2d19(ratio) == (1 << 19))
 
 
@@ -1561,7 +913,7 @@ static void oppn10_set_regamma_mode(
 
 static struct transform_funcs dcn10_dpp_funcs = {
 		.transform_reset = dpp_reset,
-		.transform_set_scaler = dpp_set_scaler_manual_scale,
+		.transform_set_scaler = dcn10_dpp_set_scaler_manual_scale,
 		.transform_get_optimal_number_of_taps = dpp_get_optimal_number_of_taps,
 		.transform_set_gamut_remap = dcn_dpp_set_gamut_remap,
 		.opp_set_csc_adjustment = oppn10_set_output_csc_adjustment,

commit d1f69890658909fad1b3881e618a841fc3bd3d96
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Tue Jul 25 09:01:13 2017 -0500

    drm/amd/display: Add interfaces for new CM blocks
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index b6aaa95d442b..e52e1f43f67b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -1572,7 +1572,7 @@ static struct transform_funcs dcn10_dpp_funcs = {
 		.opp_program_regamma_lutb_settings = opp_program_regamma_lutb_settings,
 		.opp_program_regamma_luta_settings = opp_program_regamma_luta_settings,
 		.opp_program_regamma_pwl = oppn10_set_regamma_pwl,
-		.opp_set_regamma_mode = oppn10_set_regamma_mode
+		.opp_set_regamma_mode = oppn10_set_regamma_mode,
 };
 
 /*****************************************/

commit c8d7bd8bd0c08aa9115589d264e274ed7fdf4c2e
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Sun Jul 23 12:13:37 2017 -0400

    drm/amd/display: move RGAM programming from opp to dpp
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 0f3f1a31f10b..b6aaa95d442b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -1134,6 +1134,431 @@ static void oppn10_set_output_csc_adjustment(
 	oppn10_program_color_matrix(xfm, tbl_entry);
 }
 
+static void oppn10_power_on_regamma_lut(
+	struct transform *xfm_base,
+	bool power_on)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	REG_SET(CM_MEM_PWR_CTRL, 0,
+			RGAM_MEM_PWR_FORCE, power_on == true ? 0:1);
+
+}
+
+static void opp_program_regamma_lut(
+		struct transform *xfm_base,
+		const struct pwl_result_data *rgb,
+		uint32_t num)
+{
+	uint32_t i;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	for (i = 0 ; i < num; i++) {
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].red_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].green_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0, CM_RGAM_LUT_DATA, rgb[i].blue_reg);
+
+		REG_SET(CM_RGAM_LUT_DATA, 0,
+				CM_RGAM_LUT_DATA, rgb[i].delta_red_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0,
+				CM_RGAM_LUT_DATA, rgb[i].delta_green_reg);
+		REG_SET(CM_RGAM_LUT_DATA, 0,
+				CM_RGAM_LUT_DATA, rgb[i].delta_blue_reg);
+
+	}
+
+}
+
+static void opp_configure_regamma_lut(
+		struct transform *xfm_base,
+		bool is_ram_a)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
+			CM_RGAM_LUT_WRITE_EN_MASK, 7);
+	REG_UPDATE(CM_RGAM_LUT_WRITE_EN_MASK,
+			CM_RGAM_LUT_WRITE_SEL, is_ram_a == true ? 0:1);
+	REG_SET(CM_RGAM_LUT_INDEX, 0, CM_RGAM_LUT_INDEX, 0);
+}
+
+/*program re gamma RAM A*/
+static void opp_program_regamma_luta_settings(
+		struct transform *xfm_base,
+		const struct pwl_params *params)
+{
+	const struct gamma_curve *curve;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	REG_SET_2(CM_RGAM_RAMA_START_CNTL_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_B, 0);
+	REG_SET_2(CM_RGAM_RAMA_START_CNTL_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_G, 0);
+	REG_SET_2(CM_RGAM_RAMA_START_CNTL_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMA_EXP_REGION_START_SEGMENT_R, 0);
+
+	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMA_SLOPE_CNTL_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_RGAM_RAMA_END_CNTL1_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_B, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMA_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMA_END_CNTL1_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_G, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMA_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMA_END_CNTL1_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMA_END_CNTL2_R, 0,
+		CM_RGAM_RAMA_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMA_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
+
+	curve = params->arr_curve_points;
+	REG_SET_4(CM_RGAM_RAMA_REGION_0_1, 0,
+		CM_RGAM_RAMA_EXP_REGION0_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION1_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_2_3, 0,
+		CM_RGAM_RAMA_EXP_REGION2_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION3_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_4_5, 0,
+		CM_RGAM_RAMA_EXP_REGION4_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION5_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_6_7, 0,
+		CM_RGAM_RAMA_EXP_REGION6_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION7_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_8_9, 0,
+		CM_RGAM_RAMA_EXP_REGION8_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION9_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_10_11, 0,
+		CM_RGAM_RAMA_EXP_REGION10_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION11_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_12_13, 0,
+		CM_RGAM_RAMA_EXP_REGION12_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION13_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_14_15, 0,
+		CM_RGAM_RAMA_EXP_REGION14_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION15_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_16_17, 0,
+		CM_RGAM_RAMA_EXP_REGION16_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION17_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_18_19, 0,
+		CM_RGAM_RAMA_EXP_REGION18_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION19_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_20_21, 0,
+		CM_RGAM_RAMA_EXP_REGION20_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION21_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_22_23, 0,
+		CM_RGAM_RAMA_EXP_REGION22_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION23_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_24_25, 0,
+		CM_RGAM_RAMA_EXP_REGION24_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION25_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_26_27, 0,
+		CM_RGAM_RAMA_EXP_REGION26_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION27_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_28_29, 0,
+		CM_RGAM_RAMA_EXP_REGION28_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION29_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_30_31, 0,
+		CM_RGAM_RAMA_EXP_REGION30_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION31_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMA_REGION_32_33, 0,
+		CM_RGAM_RAMA_EXP_REGION32_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMA_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMA_EXP_REGION33_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMA_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);
+}
+
+/*program re gamma RAM B*/
+static void opp_program_regamma_lutb_settings(
+		struct transform *xfm_base,
+		const struct pwl_params *params)
+{
+	const struct gamma_curve *curve;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	REG_SET_2(CM_RGAM_RAMB_START_CNTL_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_START_B, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_B, 0);
+	REG_SET_2(CM_RGAM_RAMB_START_CNTL_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_START_G, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_G, 0);
+	REG_SET_2(CM_RGAM_RAMB_START_CNTL_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_START_R, params->arr_points[0].custom_float_x,
+		CM_RGAM_RAMB_EXP_REGION_START_SEGMENT_R, 0);
+
+	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_B, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_G, params->arr_points[0].custom_float_slope);
+	REG_SET(CM_RGAM_RAMB_SLOPE_CNTL_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_LINEAR_SLOPE_R, params->arr_points[0].custom_float_slope);
+
+	REG_SET(CM_RGAM_RAMB_END_CNTL1_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_B, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_B, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_B, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMB_EXP_REGION_END_BASE_B, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMB_END_CNTL1_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_G, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_G, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_G, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMB_EXP_REGION_END_BASE_G, params->arr_points[1].custom_float_y);
+
+	REG_SET(CM_RGAM_RAMB_END_CNTL1_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_R, params->arr_points[1].custom_float_x);
+	REG_SET_2(CM_RGAM_RAMB_END_CNTL2_R, 0,
+		CM_RGAM_RAMB_EXP_REGION_END_SLOPE_R, params->arr_points[1].custom_float_slope,
+		CM_RGAM_RAMB_EXP_REGION_END_BASE_R, params->arr_points[1].custom_float_y);
+
+	curve = params->arr_curve_points;
+	REG_SET_4(CM_RGAM_RAMB_REGION_0_1, 0,
+		CM_RGAM_RAMB_EXP_REGION0_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION0_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION1_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION1_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_2_3, 0,
+		CM_RGAM_RAMB_EXP_REGION2_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION2_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION3_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION3_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_4_5, 0,
+		CM_RGAM_RAMB_EXP_REGION4_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION4_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION5_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION5_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_6_7, 0,
+		CM_RGAM_RAMB_EXP_REGION6_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION6_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION7_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION7_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_8_9, 0,
+		CM_RGAM_RAMB_EXP_REGION8_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION8_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION9_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION9_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_10_11, 0,
+		CM_RGAM_RAMB_EXP_REGION10_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION10_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION11_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION11_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_12_13, 0,
+		CM_RGAM_RAMB_EXP_REGION12_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION12_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION13_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION13_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_14_15, 0,
+		CM_RGAM_RAMB_EXP_REGION14_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION14_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION15_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION15_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_16_17, 0,
+		CM_RGAM_RAMB_EXP_REGION16_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION16_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION17_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION17_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_18_19, 0,
+		CM_RGAM_RAMB_EXP_REGION18_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION18_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION19_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION19_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_20_21, 0,
+		CM_RGAM_RAMB_EXP_REGION20_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION20_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION21_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION21_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_22_23, 0,
+		CM_RGAM_RAMB_EXP_REGION22_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION22_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION23_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION23_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_24_25, 0,
+		CM_RGAM_RAMB_EXP_REGION24_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION24_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION25_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION25_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_26_27, 0,
+		CM_RGAM_RAMB_EXP_REGION26_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION26_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION27_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION27_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_28_29, 0,
+		CM_RGAM_RAMB_EXP_REGION28_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION28_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION29_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION29_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_30_31, 0,
+		CM_RGAM_RAMB_EXP_REGION30_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION30_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION31_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION31_NUM_SEGMENTS, curve[1].segments_num);
+
+	curve += 2;
+	REG_SET_4(CM_RGAM_RAMB_REGION_32_33, 0,
+		CM_RGAM_RAMB_EXP_REGION32_LUT_OFFSET, curve[0].offset,
+		CM_RGAM_RAMB_EXP_REGION32_NUM_SEGMENTS, curve[0].segments_num,
+		CM_RGAM_RAMB_EXP_REGION33_LUT_OFFSET, curve[1].offset,
+		CM_RGAM_RAMB_EXP_REGION33_NUM_SEGMENTS, curve[1].segments_num);
+
+}
+
+static bool oppn10_set_regamma_pwl(
+	struct transform *xfm_base, const struct pwl_params *params)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	oppn10_power_on_regamma_lut(xfm_base, true);
+	opp_configure_regamma_lut(xfm_base, xfm->is_write_to_ram_a_safe);
+
+	if (xfm->is_write_to_ram_a_safe)
+		opp_program_regamma_luta_settings(xfm_base, params);
+	else
+		opp_program_regamma_lutb_settings(xfm_base, params);
+
+	opp_program_regamma_lut(
+			xfm_base, params->rgb_resulted, params->hw_points_num);
+
+	return true;
+}
+
+static void oppn10_set_regamma_mode(
+	struct transform *xfm_base,
+	enum opp_regamma mode)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	uint32_t re_mode = 0;
+	uint32_t obuf_bypass = 0; /* need for pipe split */
+	uint32_t obuf_hupscale = 0;
+
+	switch (mode) {
+	case OPP_REGAMMA_BYPASS:
+		re_mode = 0;
+		break;
+	case OPP_REGAMMA_SRGB:
+		re_mode = 1;
+		break;
+	case OPP_REGAMMA_3_6:
+		re_mode = 2;
+		break;
+	case OPP_REGAMMA_USER:
+		re_mode = xfm->is_write_to_ram_a_safe ? 3 : 4;
+		xfm->is_write_to_ram_a_safe = !xfm->is_write_to_ram_a_safe;
+		break;
+	default:
+		break;
+	}
+
+	REG_SET(CM_RGAM_CONTROL, 0, CM_RGAM_LUT_MODE, re_mode);
+	REG_UPDATE_2(OBUF_CONTROL,
+			OBUF_BYPASS, obuf_bypass,
+			OBUF_H_2X_UPSCALE_EN, obuf_hupscale);
+}
+
 static struct transform_funcs dcn10_dpp_funcs = {
 		.transform_reset = dpp_reset,
 		.transform_set_scaler = dpp_set_scaler_manual_scale,
@@ -1141,6 +1566,13 @@ static struct transform_funcs dcn10_dpp_funcs = {
 		.transform_set_gamut_remap = dcn_dpp_set_gamut_remap,
 		.opp_set_csc_adjustment = oppn10_set_output_csc_adjustment,
 		.opp_set_csc_default = oppn10_set_output_csc_default,
+		.opp_power_on_regamma_lut = oppn10_power_on_regamma_lut,
+		.opp_program_regamma_lut = opp_program_regamma_lut,
+		.opp_configure_regamma_lut = opp_configure_regamma_lut,
+		.opp_program_regamma_lutb_settings = opp_program_regamma_lutb_settings,
+		.opp_program_regamma_luta_settings = opp_program_regamma_luta_settings,
+		.opp_program_regamma_pwl = oppn10_set_regamma_pwl,
+		.opp_set_regamma_mode = oppn10_set_regamma_mode
 };
 
 /*****************************************/

commit 7db90a6b58761577596499ddd90f3c5ace2b716d
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Sat Jul 22 21:58:08 2017 -0400

    drm/amd/display: move ocsc programming from opp to dpp
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Yuehin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index fff81a14b21c..0f3f1a31f10b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -988,11 +988,159 @@ static void dcn_dpp_set_gamut_remap(
 	}
 }
 
+static void oppn10_set_output_csc_default(
+		struct transform *xfm_base,
+		const struct default_adjustment *default_adjust)
+{
+
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	uint32_t ocsc_mode = 0;
+
+	if (default_adjust != NULL) {
+		switch (default_adjust->out_color_space) {
+		case COLOR_SPACE_SRGB:
+		case COLOR_SPACE_2020_RGB_FULLRANGE:
+			ocsc_mode = 0;
+			break;
+		case COLOR_SPACE_SRGB_LIMITED:
+		case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
+			ocsc_mode = 1;
+			break;
+		case COLOR_SPACE_YCBCR601:
+		case COLOR_SPACE_YCBCR601_LIMITED:
+			ocsc_mode = 2;
+			break;
+		case COLOR_SPACE_YCBCR709:
+		case COLOR_SPACE_YCBCR709_LIMITED:
+		case COLOR_SPACE_2020_YCBCR:
+			ocsc_mode = 3;
+			break;
+		case COLOR_SPACE_UNKNOWN:
+		default:
+			break;
+		}
+	}
+
+	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
+
+}
+
+static void oppn10_program_color_matrix(
+		struct dcn10_dpp *xfm,
+		const struct out_csc_color_matrix *tbl_entry)
+{
+	uint32_t mode;
+
+	REG_GET(CM_OCSC_CONTROL, CM_OCSC_MODE, &mode);
+
+	if (tbl_entry == NULL) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	if (mode == 4) {
+		/*R*/
+		REG_SET_2(CM_OCSC_C11_C12, 0,
+			CM_OCSC_C11, tbl_entry->regval[0],
+			CM_OCSC_C12, tbl_entry->regval[1]);
+
+		REG_SET_2(CM_OCSC_C13_C14, 0,
+			CM_OCSC_C13, tbl_entry->regval[2],
+			CM_OCSC_C14, tbl_entry->regval[3]);
+
+		/*G*/
+		REG_SET_2(CM_OCSC_C21_C22, 0,
+			CM_OCSC_C21, tbl_entry->regval[4],
+			CM_OCSC_C22, tbl_entry->regval[5]);
+
+		REG_SET_2(CM_OCSC_C23_C24, 0,
+			CM_OCSC_C23, tbl_entry->regval[6],
+			CM_OCSC_C24, tbl_entry->regval[7]);
+
+		/*B*/
+		REG_SET_2(CM_OCSC_C31_C32, 0,
+			CM_OCSC_C31, tbl_entry->regval[8],
+			CM_OCSC_C32, tbl_entry->regval[9]);
+
+		REG_SET_2(CM_OCSC_C33_C34, 0,
+			CM_OCSC_C33, tbl_entry->regval[10],
+			CM_OCSC_C34, tbl_entry->regval[11]);
+	} else {
+		/*R*/
+		REG_SET_2(CM_COMB_C11_C12, 0,
+			CM_COMB_C11, tbl_entry->regval[0],
+			CM_COMB_C12, tbl_entry->regval[1]);
+
+		REG_SET_2(CM_COMB_C13_C14, 0,
+			CM_COMB_C13, tbl_entry->regval[2],
+			CM_COMB_C14, tbl_entry->regval[3]);
+
+		/*G*/
+		REG_SET_2(CM_COMB_C21_C22, 0,
+			CM_COMB_C21, tbl_entry->regval[4],
+			CM_COMB_C22, tbl_entry->regval[5]);
+
+		REG_SET_2(CM_COMB_C23_C24, 0,
+			CM_COMB_C23, tbl_entry->regval[6],
+			CM_COMB_C24, tbl_entry->regval[7]);
+
+		/*B*/
+		REG_SET_2(CM_COMB_C31_C32, 0,
+			CM_COMB_C31, tbl_entry->regval[8],
+			CM_COMB_C32, tbl_entry->regval[9]);
+
+		REG_SET_2(CM_COMB_C33_C34, 0,
+			CM_COMB_C33, tbl_entry->regval[10],
+			CM_COMB_C34, tbl_entry->regval[11]);
+	}
+}
+
+static void oppn10_set_output_csc_adjustment(
+		struct transform *xfm_base,
+		const struct out_csc_color_matrix *tbl_entry)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	//enum csc_color_mode config = CSC_COLOR_MODE_GRAPHICS_OUTPUT_CSC;
+	uint32_t ocsc_mode = 4;
+
+	/**
+	*if (tbl_entry != NULL) {
+	*	switch (tbl_entry->color_space) {
+	*	case COLOR_SPACE_SRGB:
+	*	case COLOR_SPACE_2020_RGB_FULLRANGE:
+	*		ocsc_mode = 0;
+	*		break;
+	*	case COLOR_SPACE_SRGB_LIMITED:
+	*	case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
+	*		ocsc_mode = 1;
+	*		break;
+	*	case COLOR_SPACE_YCBCR601:
+	*	case COLOR_SPACE_YCBCR601_LIMITED:
+	*		ocsc_mode = 2;
+	*		break;
+	*	case COLOR_SPACE_YCBCR709:
+	*	case COLOR_SPACE_YCBCR709_LIMITED:
+	*	case COLOR_SPACE_2020_YCBCR:
+	*		ocsc_mode = 3;
+	*		break;
+	*	case COLOR_SPACE_UNKNOWN:
+	*	default:
+	*		break;
+	*	}
+	*}
+	*/
+
+	REG_SET(CM_OCSC_CONTROL, 0, CM_OCSC_MODE, ocsc_mode);
+	oppn10_program_color_matrix(xfm, tbl_entry);
+}
+
 static struct transform_funcs dcn10_dpp_funcs = {
 		.transform_reset = dpp_reset,
 		.transform_set_scaler = dpp_set_scaler_manual_scale,
 		.transform_get_optimal_number_of_taps = dpp_get_optimal_number_of_taps,
 		.transform_set_gamut_remap = dcn_dpp_set_gamut_remap,
+		.opp_set_csc_adjustment = oppn10_set_output_csc_adjustment,
+		.opp_set_csc_default = oppn10_set_output_csc_default,
 };
 
 /*****************************************/

commit 4bd3ae5fb5156eb47b4d7f4f12d8467d9c4a8623
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Thu Jul 13 15:42:58 2017 -0500

    drm/amd/display:  Move view port registers and programming to memory input.
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
index 85d3ca31daf5..fff81a14b21c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -452,37 +452,6 @@ static void dpp_set_scl_filter(
 	}
 }
 
-static void dpp_set_viewport(
-		struct dcn10_dpp *xfm,
-		const struct rect *viewport,
-		const struct rect *viewport_c)
-{
-	REG_SET_2(DCSURF_PRI_VIEWPORT_DIMENSION, 0,
-			PRI_VIEWPORT_WIDTH, viewport->width,
-			PRI_VIEWPORT_HEIGHT, viewport->height);
-
-	REG_SET_2(DCSURF_PRI_VIEWPORT_START, 0,
-			PRI_VIEWPORT_X_START, viewport->x,
-			PRI_VIEWPORT_Y_START, viewport->y);
-
-	/*for stereo*/
-	REG_SET_2(DCSURF_SEC_VIEWPORT_DIMENSION, 0,
-				SEC_VIEWPORT_WIDTH, viewport->width,
-				SEC_VIEWPORT_HEIGHT, viewport->height);
-
-	REG_SET_2(DCSURF_SEC_VIEWPORT_START, 0,
-				SEC_VIEWPORT_X_START, viewport->x,
-				SEC_VIEWPORT_Y_START, viewport->y);
-
-	/* DC supports NV12 only at the moment */
-	REG_SET_2(DCSURF_PRI_VIEWPORT_DIMENSION_C, 0,
-			PRI_VIEWPORT_WIDTH_C, viewport_c->width,
-			PRI_VIEWPORT_HEIGHT_C, viewport_c->height);
-
-	REG_SET_2(DCSURF_PRI_VIEWPORT_START_C, 0,
-			PRI_VIEWPORT_X_START_C, viewport_c->x,
-			PRI_VIEWPORT_Y_START_C, viewport_c->y);
-}
 
 static int get_lb_depth_bpc(enum lb_pixel_depth depth)
 {
@@ -616,8 +585,6 @@ void dpp_set_scaler_auto_scale(
 
 	REG_UPDATE(SCL_MODE, DSCL_MODE, dscl_mode);
 
-	dpp_set_viewport(xfm, &scl_data->viewport, &scl_data->viewport_c);
-
 	if (dscl_mode == DSCL_MODE_DSCL_BYPASS)
 		return;
 
@@ -762,9 +729,6 @@ static void dpp_set_scaler_manual_scale(
 	/* SCL mode */
 	REG_UPDATE(SCL_MODE, DSCL_MODE, dscl_mode);
 
-	/* Viewport */
-	dpp_set_viewport(xfm, &scl_data->viewport, &scl_data->viewport_c);
-
 	if (dscl_mode == DSCL_MODE_DSCL_BYPASS)
 		return;
 	/* LB */

commit 587cdfe9463e6b66186c3c70fe7e63790cf4d148
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Wed Jul 5 17:03:04 2017 -0500

    drm/amd/display: Rename trasnform to dpp for dcn's
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
new file mode 100644
index 000000000000..85d3ca31daf5
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -0,0 +1,1064 @@
+/*
+ * Copyright 2016 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dm_services.h"
+
+#include "core_types.h"
+
+#include "include/grph_object_id.h"
+#include "include/fixed31_32.h"
+#include "include/logger_interface.h"
+
+#include "reg_helper.h"
+#include "dcn10_dpp.h"
+#include "basics/conversion.h"
+
+#define NUM_PHASES    64
+#define HORZ_MAX_TAPS 8
+#define VERT_MAX_TAPS 8
+
+#define BLACK_OFFSET_RGB_Y 0x0
+#define BLACK_OFFSET_CBCR  0x8000
+
+#define REG(reg)\
+	xfm->tf_regs->reg
+
+#define CTX \
+	xfm->base.ctx
+
+#undef FN
+#define FN(reg_name, field_name) \
+	xfm->tf_shift->field_name, xfm->tf_mask->field_name
+
+
+enum dcn10_coef_filter_type_sel {
+	SCL_COEF_LUMA_VERT_FILTER = 0,
+	SCL_COEF_LUMA_HORZ_FILTER = 1,
+	SCL_COEF_CHROMA_VERT_FILTER = 2,
+	SCL_COEF_CHROMA_HORZ_FILTER = 3,
+	SCL_COEF_ALPHA_VERT_FILTER = 4,
+	SCL_COEF_ALPHA_HORZ_FILTER = 5
+};
+
+enum lb_memory_config {
+	/* Enable all 3 pieces of memory */
+	LB_MEMORY_CONFIG_0 = 0,
+
+	/* Enable only the first piece of memory */
+	LB_MEMORY_CONFIG_1 = 1,
+
+	/* Enable only the second piece of memory */
+	LB_MEMORY_CONFIG_2 = 2,
+
+	/* Only applicable in 4:2:0 mode, enable all 3 pieces of memory and the
+	 * last piece of chroma memory used for the luma storage
+	 */
+	LB_MEMORY_CONFIG_3 = 3
+};
+
+enum dscl_autocal_mode {
+	AUTOCAL_MODE_OFF = 0,
+
+	/* Autocal calculate the scaling ratio and initial phase and the
+	 * DSCL_MODE_SEL must be set to 1
+	 */
+	AUTOCAL_MODE_AUTOSCALE = 1,
+	/* Autocal perform auto centering without replication and the
+	 * DSCL_MODE_SEL must be set to 0
+	 */
+	AUTOCAL_MODE_AUTOCENTER = 2,
+	/* Autocal perform auto centering and auto replication and the
+	 * DSCL_MODE_SEL must be set to 0
+	 */
+	AUTOCAL_MODE_AUTOREPLICATE = 3
+};
+
+enum dscl_mode_sel {
+	DSCL_MODE_SCALING_444_BYPASS = 0,
+	DSCL_MODE_SCALING_444_RGB_ENABLE = 1,
+	DSCL_MODE_SCALING_444_YCBCR_ENABLE = 2,
+	DSCL_MODE_SCALING_420_YCBCR_ENABLE = 3,
+	DSCL_MODE_SCALING_420_LUMA_BYPASS = 4,
+	DSCL_MODE_SCALING_420_CHROMA_BYPASS = 5,
+	DSCL_MODE_DSCL_BYPASS = 6
+};
+
+enum gamut_remap_select {
+	GAMUT_REMAP_BYPASS = 0,
+	GAMUT_REMAP_COEFF,
+	GAMUT_REMAP_COMA_COEFF,
+	GAMUT_REMAP_COMB_COEFF
+};
+
+static void dpp_set_overscan(
+	struct dcn10_dpp *xfm,
+	const struct scaler_data *data)
+{
+	uint32_t left = data->recout.x;
+	uint32_t top = data->recout.y;
+
+	int right = data->h_active - data->recout.x - data->recout.width;
+	int bottom = data->v_active - data->recout.y - data->recout.height;
+
+	if (right < 0) {
+		BREAK_TO_DEBUGGER();
+		right = 0;
+	}
+	if (bottom < 0) {
+		BREAK_TO_DEBUGGER();
+		bottom = 0;
+	}
+
+	REG_SET_2(DSCL_EXT_OVERSCAN_LEFT_RIGHT, 0,
+		EXT_OVERSCAN_LEFT, left,
+		EXT_OVERSCAN_RIGHT, right);
+
+	REG_SET_2(DSCL_EXT_OVERSCAN_TOP_BOTTOM, 0,
+		EXT_OVERSCAN_BOTTOM, bottom,
+		EXT_OVERSCAN_TOP, top);
+}
+
+static void dpp_set_otg_blank(
+		struct dcn10_dpp *xfm, const struct scaler_data *data)
+{
+	uint32_t h_blank_start = data->h_active;
+	uint32_t h_blank_end = 0;
+	uint32_t v_blank_start = data->v_active;
+	uint32_t v_blank_end = 0;
+
+	REG_SET_2(OTG_H_BLANK, 0,
+			OTG_H_BLANK_START, h_blank_start,
+			OTG_H_BLANK_END, h_blank_end);
+
+	REG_SET_2(OTG_V_BLANK, 0,
+			OTG_V_BLANK_START, v_blank_start,
+			OTG_V_BLANK_END, v_blank_end);
+}
+
+static enum dscl_mode_sel get_dscl_mode(
+		const struct scaler_data *data, bool dbg_always_scale)
+{
+	const long long one = dal_fixed31_32_one.value;
+	bool ycbcr = false;
+	bool format420 = false;
+
+	if (data->format == PIXEL_FORMAT_FP16)
+		return DSCL_MODE_DSCL_BYPASS;
+
+	if (data->format >= PIXEL_FORMAT_VIDEO_BEGIN
+			&& data->format <= PIXEL_FORMAT_VIDEO_END)
+		ycbcr = true;
+
+	if (data->format == PIXEL_FORMAT_420BPP8 ||
+			data->format == PIXEL_FORMAT_420BPP10)
+		format420 = true;
+
+	if (data->ratios.horz.value == one
+			&& data->ratios.vert.value == one
+			&& data->ratios.horz_c.value == one
+			&& data->ratios.vert_c.value == one
+			&& !dbg_always_scale)
+		return DSCL_MODE_SCALING_444_BYPASS;
+
+	if (!format420) {
+		if (ycbcr)
+			return DSCL_MODE_SCALING_444_YCBCR_ENABLE;
+		else
+			return DSCL_MODE_SCALING_444_RGB_ENABLE;
+	}
+	if (data->ratios.horz.value == one && data->ratios.vert.value == one)
+		return DSCL_MODE_SCALING_420_LUMA_BYPASS;
+	if (data->ratios.horz_c.value == one && data->ratios.vert_c.value == one)
+		return DSCL_MODE_SCALING_420_CHROMA_BYPASS;
+
+	return DSCL_MODE_SCALING_420_YCBCR_ENABLE;
+}
+
+static int get_pixel_depth_val(enum lb_pixel_depth depth)
+{
+	if (depth == LB_PIXEL_DEPTH_30BPP)
+		return 0; /* 10 bpc */
+	else if (depth == LB_PIXEL_DEPTH_24BPP)
+		return 1; /* 8 bpc */
+	else if (depth == LB_PIXEL_DEPTH_18BPP)
+		return 2; /* 6 bpc */
+	else if (depth == LB_PIXEL_DEPTH_36BPP)
+		return 3; /* 12 bpc */
+	else {
+		ASSERT(0);
+		return -1; /* Unsupported */
+	}
+}
+
+static void dpp_set_lb(
+	struct dcn10_dpp *xfm,
+	const struct line_buffer_params *lb_params,
+	enum lb_memory_config mem_size_config)
+{
+	uint32_t pixel_depth = get_pixel_depth_val(lb_params->depth);
+	uint32_t dyn_pix_depth = lb_params->dynamic_pixel_depth;
+	REG_SET_7(LB_DATA_FORMAT, 0,
+		PIXEL_DEPTH, pixel_depth, /* Pixel depth stored in LB */
+		PIXEL_EXPAN_MODE, lb_params->pixel_expan_mode, /* Pixel expansion mode */
+		PIXEL_REDUCE_MODE, 1, /* Pixel reduction mode: Rounding */
+		DYNAMIC_PIXEL_DEPTH, dyn_pix_depth, /* Dynamic expansion pixel depth */
+		DITHER_EN, 0, /* Dithering enable: Disabled */
+		INTERLEAVE_EN, lb_params->interleave_en, /* Interleave source enable */
+		ALPHA_EN, lb_params->alpha_en); /* Alpha enable */
+
+	REG_SET_2(LB_MEMORY_CTRL, 0,
+		MEMORY_CONFIG, mem_size_config,
+		LB_MAX_PARTITIONS, 63);
+}
+
+static void dpp_set_scaler_filter(
+		struct dcn10_dpp *xfm,
+		uint32_t taps,
+		enum dcn10_coef_filter_type_sel filter_type,
+		const uint16_t *filter)
+{
+	const int tap_pairs = (taps + 1) / 2;
+	int phase;
+	int pair;
+	uint16_t odd_coef, even_coef;
+
+	REG_SET_3(SCL_COEF_RAM_TAP_SELECT, 0,
+		SCL_COEF_RAM_TAP_PAIR_IDX, 0,
+		SCL_COEF_RAM_PHASE, 0,
+		SCL_COEF_RAM_FILTER_TYPE, filter_type);
+
+	for (phase = 0; phase < (NUM_PHASES / 2 + 1); phase++) {
+		for (pair = 0; pair < tap_pairs; pair++) {
+			even_coef = filter[phase * taps + 2 * pair];
+			if ((pair * 2 + 1) < taps)
+				odd_coef = filter[phase * taps + 2 * pair + 1];
+			else
+				odd_coef = 0;
+
+			REG_SET_4(SCL_COEF_RAM_TAP_DATA, 0,
+				/* Even tap coefficient (bits 1:0 fixed to 0) */
+				SCL_COEF_RAM_EVEN_TAP_COEF, even_coef,
+				/* Write/read control for even coefficient */
+				SCL_COEF_RAM_EVEN_TAP_COEF_EN, 1,
+				/* Odd tap coefficient (bits 1:0 fixed to 0) */
+				SCL_COEF_RAM_ODD_TAP_COEF, odd_coef,
+				/* Write/read control for odd coefficient */
+				SCL_COEF_RAM_ODD_TAP_COEF_EN, 1);
+		}
+	}
+
+}
+
+#if 0
+bool dpp_set_pixel_storage_depth(
+	struct dpp *xfm,
+	enum lb_pixel_depth depth,
+	const struct bit_depth_reduction_params *bit_depth_params)
+{
+	struct dcn10_dpp *xfm110 = TO_DCN10_DPP(xfm);
+	bool ret = true;
+	uint32_t value;
+	enum dc_color_depth color_depth;
+
+	value = dm_read_reg(xfm->ctx, LB_REG(mmLB_DATA_FORMAT));
+	switch (depth) {
+	case LB_PIXEL_DEPTH_18BPP:
+		color_depth = COLOR_DEPTH_666;
+		set_reg_field_value(value, 2, LB_DATA_FORMAT, PIXEL_DEPTH);
+		set_reg_field_value(value, 1, LB_DATA_FORMAT, PIXEL_EXPAN_MODE);
+		break;
+	case LB_PIXEL_DEPTH_24BPP:
+		color_depth = COLOR_DEPTH_888;
+		set_reg_field_value(value, 1, LB_DATA_FORMAT, PIXEL_DEPTH);
+		set_reg_field_value(value, 1, LB_DATA_FORMAT, PIXEL_EXPAN_MODE);
+		break;
+	case LB_PIXEL_DEPTH_30BPP:
+		color_depth = COLOR_DEPTH_101010;
+		set_reg_field_value(value, 0, LB_DATA_FORMAT, PIXEL_DEPTH);
+		set_reg_field_value(value, 1, LB_DATA_FORMAT, PIXEL_EXPAN_MODE);
+		break;
+	case LB_PIXEL_DEPTH_36BPP:
+		color_depth = COLOR_DEPTH_121212;
+		set_reg_field_value(value, 3, LB_DATA_FORMAT, PIXEL_DEPTH);
+		set_reg_field_value(value, 0, LB_DATA_FORMAT, PIXEL_EXPAN_MODE);
+		break;
+	default:
+		ret = false;
+		break;
+	}
+
+	if (ret == true) {
+		set_denormalization(xfm110, color_depth);
+		ret = program_bit_depth_reduction(xfm110, color_depth,
+				bit_depth_params);
+
+		set_reg_field_value(value, 0, LB_DATA_FORMAT, ALPHA_EN);
+		dm_write_reg(xfm->ctx, LB_REG(mmLB_DATA_FORMAT), value);
+		if (!(xfm110->lb_pixel_depth_supported & depth)) {
+			/* We should use unsupported capabilities
+			 * unless it is required by w/a
+			 */
+			dm_logger_write(xfm->ctx->logger, LOG_WARNING,
+				"%s: Capability not supported",
+				__func__);
+		}
+	}
+
+	return ret;
+}
+#endif
+
+static const uint16_t *get_filter_coeffs_64p(int taps, struct fixed31_32 ratio)
+{
+	if (taps == 8)
+		return get_filter_8tap_64p(ratio);
+	else if (taps == 7)
+		return get_filter_7tap_64p(ratio);
+	else if (taps == 6)
+		return get_filter_6tap_64p(ratio);
+	else if (taps == 5)
+		return get_filter_5tap_64p(ratio);
+	else if (taps == 4)
+		return get_filter_4tap_64p(ratio);
+	else if (taps == 3)
+		return get_filter_3tap_64p(ratio);
+	else if (taps == 2)
+		return filter_2tap_64p;
+	else if (taps == 1)
+		return NULL;
+	else {
+		/* should never happen, bug */
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+}
+
+static void dpp_set_scl_filter(
+		struct dcn10_dpp *xfm,
+		const struct scaler_data *scl_data,
+		bool chroma_coef_mode)
+{
+	bool h_2tap_hardcode_coef_en = false;
+	bool v_2tap_hardcode_coef_en = false;
+	bool h_2tap_sharp_en = false;
+	bool v_2tap_sharp_en = false;
+	uint32_t h_2tap_sharp_factor = scl_data->sharpness.horz;
+	uint32_t v_2tap_sharp_factor = scl_data->sharpness.vert;
+	bool coef_ram_current;
+	const uint16_t *filter_h = NULL;
+	const uint16_t *filter_v = NULL;
+	const uint16_t *filter_h_c = NULL;
+	const uint16_t *filter_v_c = NULL;
+
+	h_2tap_hardcode_coef_en = scl_data->taps.h_taps < 3
+					&& scl_data->taps.h_taps_c < 3
+		&& (scl_data->taps.h_taps > 1 || scl_data->taps.h_taps_c > 1);
+	v_2tap_hardcode_coef_en = scl_data->taps.v_taps < 3
+					&& scl_data->taps.v_taps_c < 3
+		&& (scl_data->taps.v_taps > 1 || scl_data->taps.v_taps_c > 1);
+
+	h_2tap_sharp_en = h_2tap_hardcode_coef_en && h_2tap_sharp_factor != 0;
+	v_2tap_sharp_en = v_2tap_hardcode_coef_en && v_2tap_sharp_factor != 0;
+
+	REG_UPDATE_6(DSCL_2TAP_CONTROL,
+		SCL_H_2TAP_HARDCODE_COEF_EN, h_2tap_hardcode_coef_en,
+		SCL_H_2TAP_SHARP_EN, h_2tap_sharp_en,
+		SCL_H_2TAP_SHARP_FACTOR, h_2tap_sharp_factor,
+		SCL_V_2TAP_HARDCODE_COEF_EN, v_2tap_hardcode_coef_en,
+		SCL_V_2TAP_SHARP_EN, v_2tap_sharp_en,
+		SCL_V_2TAP_SHARP_FACTOR, v_2tap_sharp_factor);
+
+	if (!v_2tap_hardcode_coef_en || !h_2tap_hardcode_coef_en) {
+		bool filter_updated = false;
+
+		filter_h = get_filter_coeffs_64p(
+				scl_data->taps.h_taps, scl_data->ratios.horz);
+		filter_v = get_filter_coeffs_64p(
+				scl_data->taps.v_taps, scl_data->ratios.vert);
+
+		filter_updated = (filter_h && (filter_h != xfm->filter_h))
+				|| (filter_v && (filter_v != xfm->filter_v));
+
+		if (chroma_coef_mode) {
+			filter_h_c = get_filter_coeffs_64p(
+					scl_data->taps.h_taps_c, scl_data->ratios.horz_c);
+			filter_v_c = get_filter_coeffs_64p(
+					scl_data->taps.v_taps_c, scl_data->ratios.vert_c);
+			filter_updated = filter_updated || (filter_h_c && (filter_h_c != xfm->filter_h_c))
+							|| (filter_v_c && (filter_v_c != xfm->filter_v_c));
+		}
+
+		if (filter_updated) {
+			uint32_t scl_mode = REG_READ(SCL_MODE);
+
+			if (!h_2tap_hardcode_coef_en && filter_h) {
+				dpp_set_scaler_filter(
+					xfm, scl_data->taps.h_taps,
+					SCL_COEF_LUMA_HORZ_FILTER, filter_h);
+			}
+			xfm->filter_h = filter_h;
+			if (!v_2tap_hardcode_coef_en && filter_v) {
+				dpp_set_scaler_filter(
+					xfm, scl_data->taps.v_taps,
+					SCL_COEF_LUMA_VERT_FILTER, filter_v);
+			}
+			xfm->filter_v = filter_v;
+			if (chroma_coef_mode) {
+				if (!h_2tap_hardcode_coef_en && filter_h_c) {
+					dpp_set_scaler_filter(
+						xfm, scl_data->taps.h_taps_c,
+						SCL_COEF_CHROMA_HORZ_FILTER, filter_h_c);
+				}
+				if (!v_2tap_hardcode_coef_en && filter_v_c) {
+					dpp_set_scaler_filter(
+						xfm, scl_data->taps.v_taps_c,
+						SCL_COEF_CHROMA_VERT_FILTER, filter_v_c);
+				}
+			}
+			xfm->filter_h_c = filter_h_c;
+			xfm->filter_v_c = filter_v_c;
+
+			coef_ram_current = get_reg_field_value_ex(
+				scl_mode, xfm->tf_mask->SCL_COEF_RAM_SELECT_CURRENT,
+				xfm->tf_shift->SCL_COEF_RAM_SELECT_CURRENT);
+
+			/* Swap coefficient RAM and set chroma coefficient mode */
+			REG_SET_2(SCL_MODE, scl_mode,
+					SCL_COEF_RAM_SELECT, !coef_ram_current,
+					SCL_CHROMA_COEF_MODE, chroma_coef_mode);
+		}
+	}
+}
+
+static void dpp_set_viewport(
+		struct dcn10_dpp *xfm,
+		const struct rect *viewport,
+		const struct rect *viewport_c)
+{
+	REG_SET_2(DCSURF_PRI_VIEWPORT_DIMENSION, 0,
+			PRI_VIEWPORT_WIDTH, viewport->width,
+			PRI_VIEWPORT_HEIGHT, viewport->height);
+
+	REG_SET_2(DCSURF_PRI_VIEWPORT_START, 0,
+			PRI_VIEWPORT_X_START, viewport->x,
+			PRI_VIEWPORT_Y_START, viewport->y);
+
+	/*for stereo*/
+	REG_SET_2(DCSURF_SEC_VIEWPORT_DIMENSION, 0,
+				SEC_VIEWPORT_WIDTH, viewport->width,
+				SEC_VIEWPORT_HEIGHT, viewport->height);
+
+	REG_SET_2(DCSURF_SEC_VIEWPORT_START, 0,
+				SEC_VIEWPORT_X_START, viewport->x,
+				SEC_VIEWPORT_Y_START, viewport->y);
+
+	/* DC supports NV12 only at the moment */
+	REG_SET_2(DCSURF_PRI_VIEWPORT_DIMENSION_C, 0,
+			PRI_VIEWPORT_WIDTH_C, viewport_c->width,
+			PRI_VIEWPORT_HEIGHT_C, viewport_c->height);
+
+	REG_SET_2(DCSURF_PRI_VIEWPORT_START_C, 0,
+			PRI_VIEWPORT_X_START_C, viewport_c->x,
+			PRI_VIEWPORT_Y_START_C, viewport_c->y);
+}
+
+static int get_lb_depth_bpc(enum lb_pixel_depth depth)
+{
+	if (depth == LB_PIXEL_DEPTH_30BPP)
+		return 10;
+	else if (depth == LB_PIXEL_DEPTH_24BPP)
+		return 8;
+	else if (depth == LB_PIXEL_DEPTH_18BPP)
+		return 6;
+	else if (depth == LB_PIXEL_DEPTH_36BPP)
+		return 12;
+	else {
+		BREAK_TO_DEBUGGER();
+		return -1; /* Unsupported */
+	}
+}
+
+static void calc_lb_num_partitions(
+		const struct scaler_data *scl_data,
+		enum lb_memory_config lb_config,
+		int *num_part_y,
+		int *num_part_c)
+{
+	int line_size = scl_data->viewport.width < scl_data->recout.width ?
+			scl_data->viewport.width : scl_data->recout.width;
+	int line_size_c = scl_data->viewport_c.width < scl_data->recout.width ?
+			scl_data->viewport_c.width : scl_data->recout.width;
+	int lb_bpc = get_lb_depth_bpc(scl_data->lb_params.depth);
+	int memory_line_size_y = (line_size * lb_bpc + 71) / 72; /* +71 to ceil */
+	int memory_line_size_c = (line_size_c * lb_bpc + 71) / 72; /* +71 to ceil */
+	int memory_line_size_a = (line_size + 5) / 6; /* +5 to ceil */
+	int lb_memory_size, lb_memory_size_c, lb_memory_size_a, num_partitions_a;
+
+	if (lb_config == LB_MEMORY_CONFIG_1) {
+		lb_memory_size = 816;
+		lb_memory_size_c = 816;
+		lb_memory_size_a = 984;
+	} else if (lb_config == LB_MEMORY_CONFIG_2) {
+		lb_memory_size = 1088;
+		lb_memory_size_c = 1088;
+		lb_memory_size_a = 1312;
+	} else if (lb_config == LB_MEMORY_CONFIG_3) {
+		lb_memory_size = 816 + 1088 + 848 + 848 + 848;
+		lb_memory_size_c = 816 + 1088;
+		lb_memory_size_a = 984 + 1312 + 456;
+	} else {
+		lb_memory_size = 816 + 1088 + 848;
+		lb_memory_size_c = 816 + 1088 + 848;
+		lb_memory_size_a = 984 + 1312 + 456;
+	}
+	*num_part_y = lb_memory_size / memory_line_size_y;
+	*num_part_c = lb_memory_size_c / memory_line_size_c;
+	num_partitions_a = lb_memory_size_a / memory_line_size_a;
+
+	if (scl_data->lb_params.alpha_en
+			&& (num_partitions_a < *num_part_y))
+		*num_part_y = num_partitions_a;
+
+	if (*num_part_y > 64)
+		*num_part_y = 64;
+	if (*num_part_c > 64)
+		*num_part_c = 64;
+
+}
+
+static bool is_lb_conf_valid(int ceil_vratio, int num_partitions, int vtaps)
+{
+	if (ceil_vratio > 2)
+		return vtaps <= (num_partitions - ceil_vratio + 2);
+	else
+		return vtaps <= num_partitions;
+}
+
+/*find first match configuration which meets the min required lb size*/
+static enum lb_memory_config find_lb_memory_config(const struct scaler_data *scl_data)
+{
+	int num_part_y, num_part_c;
+	int vtaps = scl_data->taps.v_taps;
+	int vtaps_c = scl_data->taps.v_taps_c;
+	int ceil_vratio = dal_fixed31_32_ceil(scl_data->ratios.vert);
+	int ceil_vratio_c = dal_fixed31_32_ceil(scl_data->ratios.vert_c);
+
+	calc_lb_num_partitions(
+			scl_data, LB_MEMORY_CONFIG_1, &num_part_y, &num_part_c);
+
+	if (is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
+			&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))
+		return LB_MEMORY_CONFIG_1;
+
+	calc_lb_num_partitions(
+			scl_data, LB_MEMORY_CONFIG_2, &num_part_y, &num_part_c);
+
+	if (is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
+			&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))
+		return LB_MEMORY_CONFIG_2;
+
+	if (scl_data->format == PIXEL_FORMAT_420BPP8
+			|| scl_data->format == PIXEL_FORMAT_420BPP10) {
+		calc_lb_num_partitions(
+				scl_data, LB_MEMORY_CONFIG_3, &num_part_y, &num_part_c);
+
+		if (is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
+				&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c))
+			return LB_MEMORY_CONFIG_3;
+	}
+
+	calc_lb_num_partitions(
+			scl_data, LB_MEMORY_CONFIG_0, &num_part_y, &num_part_c);
+
+	/*Ensure we can support the requested number of vtaps*/
+	ASSERT(is_lb_conf_valid(ceil_vratio, num_part_y, vtaps)
+			&& is_lb_conf_valid(ceil_vratio_c, num_part_c, vtaps_c));
+
+	return LB_MEMORY_CONFIG_0;
+}
+
+void dpp_set_scaler_auto_scale(
+	struct transform *xfm_base,
+	const struct scaler_data *scl_data)
+{
+	enum lb_memory_config lb_config;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	enum dscl_mode_sel dscl_mode = get_dscl_mode(
+			scl_data, xfm_base->ctx->dc->debug.always_scale);
+	bool ycbcr = scl_data->format >= PIXEL_FORMAT_VIDEO_BEGIN
+				&& scl_data->format <= PIXEL_FORMAT_VIDEO_END;
+
+	dpp_set_overscan(xfm, scl_data);
+
+	dpp_set_otg_blank(xfm, scl_data);
+
+	REG_UPDATE(SCL_MODE, DSCL_MODE, dscl_mode);
+
+	dpp_set_viewport(xfm, &scl_data->viewport, &scl_data->viewport_c);
+
+	if (dscl_mode == DSCL_MODE_DSCL_BYPASS)
+		return;
+
+	lb_config =  find_lb_memory_config(scl_data);
+	dpp_set_lb(xfm, &scl_data->lb_params, lb_config);
+
+	if (dscl_mode == DSCL_MODE_SCALING_444_BYPASS)
+		return;
+
+	/* TODO: v_min */
+	REG_SET_3(DSCL_AUTOCAL, 0,
+		AUTOCAL_MODE, AUTOCAL_MODE_AUTOSCALE,
+		AUTOCAL_NUM_PIPE, 0,
+		AUTOCAL_PIPE_ID, 0);
+
+	/* Black offsets */
+	if (ycbcr)
+		REG_SET_2(SCL_BLACK_OFFSET, 0,
+				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
+				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_CBCR);
+	else
+
+		REG_SET_2(SCL_BLACK_OFFSET, 0,
+				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
+				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_RGB_Y);
+
+	REG_SET_4(SCL_TAP_CONTROL, 0,
+		SCL_V_NUM_TAPS, scl_data->taps.v_taps - 1,
+		SCL_H_NUM_TAPS, scl_data->taps.h_taps - 1,
+		SCL_V_NUM_TAPS_C, scl_data->taps.v_taps_c - 1,
+		SCL_H_NUM_TAPS_C, scl_data->taps.h_taps_c - 1);
+
+	dpp_set_scl_filter(xfm, scl_data, ycbcr);
+}
+
+/* Program gamut remap in bypass mode */
+void dpp_set_gamut_remap_bypass(struct dcn10_dpp *xfm)
+{
+	REG_SET(CM_GAMUT_REMAP_CONTROL, 0,
+			CM_GAMUT_REMAP_MODE, 0);
+	/* Gamut remap in bypass */
+}
+
+static void dpp_set_recout(
+			struct dcn10_dpp *xfm, const struct rect *recout)
+{
+	REG_SET_2(RECOUT_START, 0,
+		/* First pixel of RECOUT */
+			 RECOUT_START_X, recout->x,
+		/* First line of RECOUT */
+			 RECOUT_START_Y, recout->y);
+
+	REG_SET_2(RECOUT_SIZE, 0,
+		/* Number of RECOUT horizontal pixels */
+			 RECOUT_WIDTH, recout->width,
+		/* Number of RECOUT vertical lines */
+			 RECOUT_HEIGHT, recout->height
+			 - xfm->base.ctx->dc->debug.surface_visual_confirm * 4 *
+			 (xfm->base.inst + 1));
+}
+
+static void dpp_set_manual_ratio_init(
+		struct dcn10_dpp *xfm, const struct scaler_data *data)
+{
+	uint32_t init_frac = 0;
+	uint32_t init_int = 0;
+
+	REG_SET(SCL_HORZ_FILTER_SCALE_RATIO, 0,
+			SCL_H_SCALE_RATIO, dal_fixed31_32_u2d19(data->ratios.horz) << 5);
+
+	REG_SET(SCL_VERT_FILTER_SCALE_RATIO, 0,
+			SCL_V_SCALE_RATIO, dal_fixed31_32_u2d19(data->ratios.vert) << 5);
+
+	REG_SET(SCL_HORZ_FILTER_SCALE_RATIO_C, 0,
+			SCL_H_SCALE_RATIO_C, dal_fixed31_32_u2d19(data->ratios.horz_c) << 5);
+
+	REG_SET(SCL_VERT_FILTER_SCALE_RATIO_C, 0,
+			SCL_V_SCALE_RATIO_C, dal_fixed31_32_u2d19(data->ratios.vert_c) << 5);
+
+	/*
+	 * 0.24 format for fraction, first five bits zeroed
+	 */
+	init_frac = dal_fixed31_32_u0d19(data->inits.h) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.h);
+	REG_SET_2(SCL_HORZ_FILTER_INIT, 0,
+		SCL_H_INIT_FRAC, init_frac,
+		SCL_H_INIT_INT, init_int);
+
+	init_frac = dal_fixed31_32_u0d19(data->inits.h_c) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.h_c);
+	REG_SET_2(SCL_HORZ_FILTER_INIT_C, 0,
+		SCL_H_INIT_FRAC_C, init_frac,
+		SCL_H_INIT_INT_C, init_int);
+
+	init_frac = dal_fixed31_32_u0d19(data->inits.v) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.v);
+	REG_SET_2(SCL_VERT_FILTER_INIT, 0,
+		SCL_V_INIT_FRAC, init_frac,
+		SCL_V_INIT_INT, init_int);
+
+	init_frac = dal_fixed31_32_u0d19(data->inits.v_bot) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.v_bot);
+	REG_SET_2(SCL_VERT_FILTER_INIT_BOT, 0,
+		SCL_V_INIT_FRAC_BOT, init_frac,
+		SCL_V_INIT_INT_BOT, init_int);
+
+	init_frac = dal_fixed31_32_u0d19(data->inits.v_c) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.v_c);
+	REG_SET_2(SCL_VERT_FILTER_INIT_C, 0,
+		SCL_V_INIT_FRAC_C, init_frac,
+		SCL_V_INIT_INT_C, init_int);
+
+	init_frac = dal_fixed31_32_u0d19(data->inits.v_c_bot) << 5;
+	init_int = dal_fixed31_32_floor(data->inits.v_c_bot);
+	REG_SET_2(SCL_VERT_FILTER_INIT_BOT_C, 0,
+		SCL_V_INIT_FRAC_BOT_C, init_frac,
+		SCL_V_INIT_INT_BOT_C, init_int);
+}
+
+/* Main function to program scaler and line buffer in manual scaling mode */
+static void dpp_set_scaler_manual_scale(
+	struct transform *xfm_base,
+	const struct scaler_data *scl_data)
+{
+	enum lb_memory_config lb_config;
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+	enum dscl_mode_sel dscl_mode = get_dscl_mode(
+			scl_data, xfm_base->ctx->dc->debug.always_scale);
+	bool ycbcr = scl_data->format >= PIXEL_FORMAT_VIDEO_BEGIN
+				&& scl_data->format <= PIXEL_FORMAT_VIDEO_END;
+
+	/* Recout */
+	dpp_set_recout(xfm, &scl_data->recout);
+
+	/* MPC Size */
+	REG_SET_2(MPC_SIZE, 0,
+		/* Number of horizontal pixels of MPC */
+			 MPC_WIDTH, scl_data->h_active,
+		/* Number of vertical lines of MPC */
+			 MPC_HEIGHT, scl_data->v_active);
+
+	/* SCL mode */
+	REG_UPDATE(SCL_MODE, DSCL_MODE, dscl_mode);
+
+	/* Viewport */
+	dpp_set_viewport(xfm, &scl_data->viewport, &scl_data->viewport_c);
+
+	if (dscl_mode == DSCL_MODE_DSCL_BYPASS)
+		return;
+	/* LB */
+	lb_config =  find_lb_memory_config(scl_data);
+	dpp_set_lb(xfm, &scl_data->lb_params, lb_config);
+
+	if (dscl_mode == DSCL_MODE_SCALING_444_BYPASS)
+		return;
+
+	/* Autocal off */
+	REG_SET_3(DSCL_AUTOCAL, 0,
+		AUTOCAL_MODE, AUTOCAL_MODE_OFF,
+		AUTOCAL_NUM_PIPE, 0,
+		AUTOCAL_PIPE_ID, 0);
+
+	/* Black offsets */
+	if (ycbcr)
+		REG_SET_2(SCL_BLACK_OFFSET, 0,
+				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
+				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_CBCR);
+	else
+
+		REG_SET_2(SCL_BLACK_OFFSET, 0,
+				SCL_BLACK_OFFSET_RGB_Y, BLACK_OFFSET_RGB_Y,
+				SCL_BLACK_OFFSET_CBCR, BLACK_OFFSET_RGB_Y);
+
+	/* Manually calculate scale ratio and init values */
+	dpp_set_manual_ratio_init(xfm, scl_data);
+
+	/* HTaps/VTaps */
+	REG_SET_4(SCL_TAP_CONTROL, 0,
+		SCL_V_NUM_TAPS, scl_data->taps.v_taps - 1,
+		SCL_H_NUM_TAPS, scl_data->taps.h_taps - 1,
+		SCL_V_NUM_TAPS_C, scl_data->taps.v_taps_c - 1,
+		SCL_H_NUM_TAPS_C, scl_data->taps.h_taps_c - 1);
+
+	dpp_set_scl_filter(xfm, scl_data, ycbcr);
+}
+
+#define IDENTITY_RATIO(ratio) (dal_fixed31_32_u2d19(ratio) == (1 << 19))
+
+
+static bool dpp_get_optimal_number_of_taps(
+		struct transform *xfm,
+		struct scaler_data *scl_data,
+		const struct scaling_taps *in_taps)
+{
+	uint32_t pixel_width;
+
+	if (scl_data->viewport.width > scl_data->recout.width)
+		pixel_width = scl_data->recout.width;
+	else
+		pixel_width = scl_data->viewport.width;
+
+	/* TODO: add lb check */
+
+	/* No support for programming ratio of 4, drop to 3.99999.. */
+	if (scl_data->ratios.horz.value == (4ll << 32))
+		scl_data->ratios.horz.value--;
+	if (scl_data->ratios.vert.value == (4ll << 32))
+		scl_data->ratios.vert.value--;
+	if (scl_data->ratios.horz_c.value == (4ll << 32))
+		scl_data->ratios.horz_c.value--;
+	if (scl_data->ratios.vert_c.value == (4ll << 32))
+		scl_data->ratios.vert_c.value--;
+
+	/* Set default taps if none are provided */
+	if (in_taps->h_taps == 0)
+		scl_data->taps.h_taps = 4;
+	else
+		scl_data->taps.h_taps = in_taps->h_taps;
+	if (in_taps->v_taps == 0)
+		scl_data->taps.v_taps = 4;
+	else
+		scl_data->taps.v_taps = in_taps->v_taps;
+	if (in_taps->v_taps_c == 0)
+		scl_data->taps.v_taps_c = 2;
+	else
+		scl_data->taps.v_taps_c = in_taps->v_taps_c;
+	if (in_taps->h_taps_c == 0)
+		scl_data->taps.h_taps_c = 2;
+	/* Only 1 and even h_taps_c are supported by hw */
+	else if ((in_taps->h_taps_c % 2) != 0 && in_taps->h_taps_c != 1)
+		scl_data->taps.h_taps_c = in_taps->h_taps_c - 1;
+	else
+		scl_data->taps.h_taps_c = in_taps->h_taps_c;
+
+	if (!xfm->ctx->dc->debug.always_scale) {
+		if (IDENTITY_RATIO(scl_data->ratios.horz))
+			scl_data->taps.h_taps = 1;
+		if (IDENTITY_RATIO(scl_data->ratios.vert))
+			scl_data->taps.v_taps = 1;
+		if (IDENTITY_RATIO(scl_data->ratios.horz_c))
+			scl_data->taps.h_taps_c = 1;
+		if (IDENTITY_RATIO(scl_data->ratios.vert_c))
+			scl_data->taps.v_taps_c = 1;
+	}
+
+	return true;
+}
+
+static void dpp_reset(struct transform *xfm_base)
+{
+	struct dcn10_dpp *xfm = TO_DCN10_DPP(xfm_base);
+
+	xfm->filter_h_c = NULL;
+	xfm->filter_v_c = NULL;
+	xfm->filter_h = NULL;
+	xfm->filter_v = NULL;
+
+	/* set boundary mode to 0 */
+	REG_SET(DSCL_CONTROL, 0, SCL_BOUNDARY_MODE, 0);
+}
+
+static void program_gamut_remap(
+		struct dcn10_dpp *xfm,
+		const uint16_t *regval,
+		enum gamut_remap_select select)
+{
+	 uint16_t selection = 0;
+
+	if (regval == NULL || select == GAMUT_REMAP_BYPASS) {
+		REG_SET(CM_GAMUT_REMAP_CONTROL, 0,
+				CM_GAMUT_REMAP_MODE, 0);
+		return;
+	}
+	switch (select) {
+	case GAMUT_REMAP_COEFF:
+		selection = 1;
+		break;
+	case GAMUT_REMAP_COMA_COEFF:
+		selection = 2;
+		break;
+	case GAMUT_REMAP_COMB_COEFF:
+		selection = 3;
+		break;
+	default:
+		break;
+	}
+
+
+	if (select == GAMUT_REMAP_COEFF) {
+
+		REG_SET_2(CM_GAMUT_REMAP_C11_C12, 0,
+				CM_GAMUT_REMAP_C11, regval[0],
+				CM_GAMUT_REMAP_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C13_C14, 0,
+				CM_GAMUT_REMAP_C13, regval[0],
+				CM_GAMUT_REMAP_C14, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C21_C22, 0,
+				CM_GAMUT_REMAP_C21, regval[0],
+				CM_GAMUT_REMAP_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C23_C24, 0,
+				CM_GAMUT_REMAP_C23, regval[0],
+				CM_GAMUT_REMAP_C24, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C31_C32, 0,
+				CM_GAMUT_REMAP_C31, regval[0],
+				CM_GAMUT_REMAP_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_GAMUT_REMAP_C33_C34, 0,
+				CM_GAMUT_REMAP_C33, regval[0],
+				CM_GAMUT_REMAP_C34, regval[1]);
+
+	} else  if (select == GAMUT_REMAP_COMA_COEFF) {
+		REG_SET_2(CM_COMA_C11_C12, 0,
+				CM_COMA_C11, regval[0],
+				CM_COMA_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C13_C14, 0,
+				CM_COMA_C13, regval[0],
+				CM_COMA_C14, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C21_C22, 0,
+				CM_COMA_C21, regval[0],
+				CM_COMA_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C23_C24, 0,
+				CM_COMA_C23, regval[0],
+				CM_COMA_C24, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C31_C32, 0,
+				CM_COMA_C31, regval[0],
+				CM_COMA_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMA_C33_C34, 0,
+				CM_COMA_C33, regval[0],
+				CM_COMA_C34, regval[1]);
+
+	} else {
+		REG_SET_2(CM_COMB_C11_C12, 0,
+				CM_COMB_C11, regval[0],
+				CM_COMB_C12, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C13_C14, 0,
+				CM_COMB_C13, regval[0],
+				CM_COMB_C14, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C21_C22, 0,
+				CM_COMB_C21, regval[0],
+				CM_COMB_C22, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C23_C24, 0,
+				CM_COMB_C23, regval[0],
+				CM_COMB_C24, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C31_C32, 0,
+				CM_COMB_C31, regval[0],
+				CM_COMB_C32, regval[1]);
+		regval += 2;
+		REG_SET_2(CM_COMB_C33_C34, 0,
+				CM_COMB_C33, regval[0],
+				CM_COMB_C34, regval[1]);
+	}
+
+	REG_SET(
+			CM_GAMUT_REMAP_CONTROL, 0,
+			CM_GAMUT_REMAP_MODE, selection);
+
+}
+
+static void dcn_dpp_set_gamut_remap(
+	struct transform *xfm,
+	const struct xfm_grph_csc_adjustment *adjust)
+{
+	struct dcn10_dpp *dcn_xfm = TO_DCN10_DPP(xfm);
+
+	if (adjust->gamut_adjust_type != GRAPHICS_GAMUT_ADJUST_TYPE_SW)
+		/* Bypass if type is bypass or hw */
+		program_gamut_remap(dcn_xfm, NULL, GAMUT_REMAP_BYPASS);
+	else {
+		struct fixed31_32 arr_matrix[12];
+		uint16_t arr_reg_val[12];
+
+		arr_matrix[0] = adjust->temperature_matrix[0];
+		arr_matrix[1] = adjust->temperature_matrix[1];
+		arr_matrix[2] = adjust->temperature_matrix[2];
+		arr_matrix[3] = dal_fixed31_32_zero;
+
+		arr_matrix[4] = adjust->temperature_matrix[3];
+		arr_matrix[5] = adjust->temperature_matrix[4];
+		arr_matrix[6] = adjust->temperature_matrix[5];
+		arr_matrix[7] = dal_fixed31_32_zero;
+
+		arr_matrix[8] = adjust->temperature_matrix[6];
+		arr_matrix[9] = adjust->temperature_matrix[7];
+		arr_matrix[10] = adjust->temperature_matrix[8];
+		arr_matrix[11] = dal_fixed31_32_zero;
+
+		convert_float_matrix(
+			arr_reg_val, arr_matrix, 12);
+
+		program_gamut_remap(dcn_xfm, arr_reg_val, GAMUT_REMAP_COEFF);
+	}
+}
+
+static struct transform_funcs dcn10_dpp_funcs = {
+		.transform_reset = dpp_reset,
+		.transform_set_scaler = dpp_set_scaler_manual_scale,
+		.transform_get_optimal_number_of_taps = dpp_get_optimal_number_of_taps,
+		.transform_set_gamut_remap = dcn_dpp_set_gamut_remap,
+};
+
+/*****************************************/
+/* Constructor, Destructor               */
+/*****************************************/
+
+bool dcn10_dpp_construct(
+	struct dcn10_dpp *xfm,
+	struct dc_context *ctx,
+	uint32_t inst,
+	const struct dcn_dpp_registers *tf_regs,
+	const struct dcn_dpp_shift *tf_shift,
+	const struct dcn_dpp_mask *tf_mask)
+{
+	xfm->base.ctx = ctx;
+
+	xfm->base.inst = inst;
+	xfm->base.funcs = &dcn10_dpp_funcs;
+
+	xfm->tf_regs = tf_regs;
+	xfm->tf_shift = tf_shift;
+	xfm->tf_mask = tf_mask;
+
+	xfm->lb_pixel_depth_supported =
+		LB_PIXEL_DEPTH_18BPP |
+		LB_PIXEL_DEPTH_24BPP |
+		LB_PIXEL_DEPTH_30BPP;
+
+	xfm->lb_bits_per_entry = LB_BITS_PER_ENTRY;
+	xfm->lb_memory_size = LB_TOTAL_NUMBER_OF_ENTRIES; /*0x1404*/
+
+	return true;
+}
