commit b2a7b0ce0773bfa4406bc0a78e41979532a1edd7
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Wed Apr 22 18:08:03 2020 -0400

    drm/amd/display: Use cursor locking to prevent flip delays
    
    [Why]
    Current locking scheme for cursor can result in a flip missing
    its vsync, deferring it for one or more vsyncs.  Result is a
    potential for stuttering when cursor is moved.
    
    [How]
    Use cursor update lock so that flips are not blocked while cursor
    is being programmed.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 04f863499cfb..3fcd408e9103 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -223,6 +223,9 @@ struct mpcc *mpc1_insert_plane(
 	REG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, dpp_id);
 	REG_SET(MPCC_OPP_ID[mpcc_id], 0, MPCC_OPP_ID, tree->opp_id);
 
+	/* Configure VUPDATE lock set for this MPCC to map to the OPP */
+	REG_SET(MPCC_UPDATE_LOCK_SEL[mpcc_id], 0, MPCC_UPDATE_LOCK_SEL, tree->opp_id);
+
 	/* update mpc tree mux setting */
 	if (tree->opp_list == insert_above_mpcc) {
 		/* insert the toppest mpcc */
@@ -318,6 +321,7 @@ void mpc1_remove_mpcc(
 		REG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, 0xf);
 		REG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, 0xf);
 		REG_SET(MPCC_OPP_ID[mpcc_id],  0, MPCC_OPP_ID,  0xf);
+		REG_SET(MPCC_UPDATE_LOCK_SEL[mpcc_id], 0, MPCC_UPDATE_LOCK_SEL, 0xf);
 
 		/* mark this mpcc as not in use */
 		mpc10->mpcc_in_use_mask &= ~(1 << mpcc_id);
@@ -328,6 +332,7 @@ void mpc1_remove_mpcc(
 		REG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, 0xf);
 		REG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, 0xf);
 		REG_SET(MPCC_OPP_ID[mpcc_id],  0, MPCC_OPP_ID,  0xf);
+		REG_SET(MPCC_UPDATE_LOCK_SEL[mpcc_id], 0, MPCC_UPDATE_LOCK_SEL, 0xf);
 	}
 }
 
@@ -361,6 +366,7 @@ void mpc1_mpc_init(struct mpc *mpc)
 		REG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, 0xf);
 		REG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, 0xf);
 		REG_SET(MPCC_OPP_ID[mpcc_id],  0, MPCC_OPP_ID,  0xf);
+		REG_SET(MPCC_UPDATE_LOCK_SEL[mpcc_id], 0, MPCC_UPDATE_LOCK_SEL, 0xf);
 
 		mpc1_init_mpcc(&(mpc->mpcc_array[mpcc_id]), mpcc_id);
 	}
@@ -381,6 +387,7 @@ void mpc1_mpc_init_single_inst(struct mpc *mpc, unsigned int mpcc_id)
 	REG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, 0xf);
 	REG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, 0xf);
 	REG_SET(MPCC_OPP_ID[mpcc_id],  0, MPCC_OPP_ID,  0xf);
+	REG_SET(MPCC_UPDATE_LOCK_SEL[mpcc_id], 0, MPCC_UPDATE_LOCK_SEL, 0xf);
 
 	mpc1_init_mpcc(&(mpc->mpcc_array[mpcc_id]), mpcc_id);
 
@@ -453,6 +460,13 @@ void mpc1_read_mpcc_state(
 			MPCC_BUSY, &s->busy);
 }
 
+void mpc1_cursor_lock(struct mpc *mpc, int opp_id, bool lock)
+{
+	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
+
+	REG_SET(CUR[opp_id], 0, CUR_VUPDATE_LOCK_SET, lock ? 1 : 0);
+}
+
 static const struct mpc_funcs dcn10_mpc_funcs = {
 	.read_mpcc_state = mpc1_read_mpcc_state,
 	.insert_plane = mpc1_insert_plane,
@@ -464,6 +478,7 @@ static const struct mpc_funcs dcn10_mpc_funcs = {
 	.assert_mpcc_idle_before_connect = mpc1_assert_mpcc_idle_before_connect,
 	.init_mpcc_list_from_hw = mpc1_init_mpcc_list_from_hw,
 	.update_blending = mpc1_update_blending,
+	.cursor_lock = mpc1_cursor_lock,
 	.set_denorm = NULL,
 	.set_denorm_clamp = NULL,
 	.set_output_csc = NULL,

commit 9b265eba45d34373c7814187d9bcc8df80bffd70
Author: Hugo Hu <hugo.hu@amd.com>
Date:   Fri Oct 25 15:33:15 2019 +0800

    drm/amd/display: Update background color in bottommost mpcc
    
    [Why]
    Background color only takes effect in bottommost mpcc.
    
    [How]
    Update background color in bottommost mpcc.
    
    Signed-off-by: Hugo Hu <hugo.hu@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 220154f7911a..04f863499cfb 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -42,20 +42,27 @@ void mpc1_set_bg_color(struct mpc *mpc,
 		int mpcc_id)
 {
 	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
+	struct mpcc *bottommost_mpcc = mpc1_get_mpcc(mpc, mpcc_id);
+	uint32_t bg_r_cr, bg_g_y, bg_b_cb;
+
+	/* find bottommost mpcc. */
+	while (bottommost_mpcc->mpcc_bot) {
+		bottommost_mpcc = bottommost_mpcc->mpcc_bot;
+	}
 
 	/* mpc color is 12 bit.  tg_color is 10 bit */
 	/* todo: might want to use 16 bit to represent color and have each
 	 * hw block translate to correct color depth.
 	 */
-	uint32_t bg_r_cr = bg_color->color_r_cr << 2;
-	uint32_t bg_g_y = bg_color->color_g_y << 2;
-	uint32_t bg_b_cb = bg_color->color_b_cb << 2;
+	bg_r_cr = bg_color->color_r_cr << 2;
+	bg_g_y = bg_color->color_g_y << 2;
+	bg_b_cb = bg_color->color_b_cb << 2;
 
-	REG_SET(MPCC_BG_R_CR[mpcc_id], 0,
+	REG_SET(MPCC_BG_R_CR[bottommost_mpcc->mpcc_id], 0,
 			MPCC_BG_R_CR, bg_r_cr);
-	REG_SET(MPCC_BG_G_Y[mpcc_id], 0,
+	REG_SET(MPCC_BG_G_Y[bottommost_mpcc->mpcc_id], 0,
 			MPCC_BG_G_Y, bg_g_y);
-	REG_SET(MPCC_BG_B_CB[mpcc_id], 0,
+	REG_SET(MPCC_BG_B_CB[bottommost_mpcc->mpcc_id], 0,
 			MPCC_BG_B_CB, bg_b_cb);
 }
 

commit 1da37801a8b0fffb024fea594c7f1d7867ed8aa0
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:38:55 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_0 and DSC_SUPPORTED
    
    [Why]
    
    DCN2 and DSC are stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup NV defninitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN2 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * dce/dce_dmcu.c: dcn20_*lock_phy()
        * dce/dce_dmcu.c: dcn20_funcs
        * dce/dce_dmcu.c: dcn20_dmcu_create()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 8b2f29f6dabd..220154f7911a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -457,12 +457,10 @@ static const struct mpc_funcs dcn10_mpc_funcs = {
 	.assert_mpcc_idle_before_connect = mpc1_assert_mpcc_idle_before_connect,
 	.init_mpcc_list_from_hw = mpc1_init_mpcc_list_from_hw,
 	.update_blending = mpc1_update_blending,
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	.set_denorm = NULL,
 	.set_denorm_clamp = NULL,
 	.set_output_csc = NULL,
 	.set_output_gamma = NULL,
-#endif
 };
 
 void dcn10_mpc_construct(struct dcn10_mpc *mpc10,

commit 5ec43eda85506ddc2f91c3a4e28b38da3f14cf1e
Author: Martin Leung <martin.leung@amd.com>
Date:   Wed Jul 17 16:08:19 2019 -0400

    drm/amd/display: enabling seamless boot sequence for dcn2
    
    [Why]
    Seamless boot (building SW state inheriting BIOS-initialized timing) was
    enabled on DCN2, including fixes
    
    [How]
    Includes fixes for MPC, DPPCLK, and DIG FE mapping/OTG source select/
    Pixel clock.
    
    This is part 2 of 2 for seamless boot NV10
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 4f7a10390c57..8b2f29f6dabd 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -364,6 +364,24 @@ void mpc1_mpc_init(struct mpc *mpc)
 	}
 }
 
+void mpc1_mpc_init_single_inst(struct mpc *mpc, unsigned int mpcc_id)
+{
+	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
+	int opp_id;
+
+	REG_GET(MPCC_OPP_ID[mpcc_id], MPCC_OPP_ID, &opp_id);
+
+	REG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, 0xf);
+	REG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, 0xf);
+	REG_SET(MPCC_OPP_ID[mpcc_id],  0, MPCC_OPP_ID,  0xf);
+
+	mpc1_init_mpcc(&(mpc->mpcc_array[mpcc_id]), mpcc_id);
+
+	if (opp_id < MAX_OPP && REG(MUX[opp_id]))
+		REG_UPDATE(MUX[opp_id], MPC_OUT_MUX, 0xf);
+}
+
+
 void mpc1_init_mpcc_list_from_hw(
 	struct mpc *mpc,
 	struct mpc_tree *tree)
@@ -433,6 +451,7 @@ static const struct mpc_funcs dcn10_mpc_funcs = {
 	.insert_plane = mpc1_insert_plane,
 	.remove_mpcc = mpc1_remove_mpcc,
 	.mpc_init = mpc1_mpc_init,
+	.mpc_init_single_inst = mpc1_mpc_init_single_inst,
 	.get_mpcc_for_dpp = mpc1_get_mpcc_for_dpp,
 	.wait_for_idle = mpc1_assert_idle_mpcc,
 	.assert_mpcc_idle_before_connect = mpc1_assert_mpcc_idle_before_connect,

commit 473e0ecbb4f62e0a971b47b27ec778371653f5ac
Author: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
Date:   Wed Jun 26 14:52:46 2019 -0400

    drm/amd/display: Fixes for some MPO cases
    
    [Why]
    Alpha could be improperly applied (only affecting half the
    frame) for some source pixel formats.
    
    [How]
    Change how alpha is enabled in MPC/DPP LB and change the
    bottom plane blend mode in MPC.
    
    Signed-off-by: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 0bca011ed7c9..4f7a10390c57 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -211,7 +211,7 @@ struct mpcc *mpc1_insert_plane(
 	} else {
 		new_mpcc->mpcc_bot = NULL;
 		REG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, 0xf);
-		REG_UPDATE(MPCC_CONTROL[mpcc_id], MPCC_MODE, MPCC_BLEND_MODE_TOP_LAYER_PASSTHROUGH);
+		REG_UPDATE(MPCC_CONTROL[mpcc_id], MPCC_MODE, MPCC_BLEND_MODE_TOP_LAYER_ONLY);
 	}
 	REG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, dpp_id);
 	REG_SET(MPCC_OPP_ID[mpcc_id], 0, MPCC_OPP_ID, tree->opp_id);

commit f789b0b82bf0aee36ce2bb4270aad617d16c3b6b
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Feb 22 10:49:04 2019 -0500

    drm/amd/display: Add DCN2 MPC
    
    Add support to program the DCN2 MPC (Multiple pipe and plane combine)
    
    HW Blocks:
    
        +--------+
        |  MPC   |
        +--------+
            |
            v
        +-------+
        |  OPP  |
        +-------+
            |
            v
        +--------+
        |  OPTC  |
        +--------+
            |
            v
        +--------+       +--------+
        |  DIO   |       |  DCCG  |
        +--------+       +--------+
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 958994edf2c4..0bca011ed7c9 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -438,6 +438,12 @@ static const struct mpc_funcs dcn10_mpc_funcs = {
 	.assert_mpcc_idle_before_connect = mpc1_assert_mpcc_idle_before_connect,
 	.init_mpcc_list_from_hw = mpc1_init_mpcc_list_from_hw,
 	.update_blending = mpc1_update_blending,
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	.set_denorm = NULL,
+	.set_denorm_clamp = NULL,
+	.set_output_csc = NULL,
+	.set_output_gamma = NULL,
+#endif
 };
 
 void dcn10_mpc_construct(struct dcn10_mpc *mpc10,

commit bd4e725084189a198ca47d369d85100216d29b7e
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Jul 6 09:49:05 2018 -0400

    drm/amd/display: Make function pointer structs const
    
    const to avoid hard-to-find bugs where some function overrides a
    function pointer.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Christian KÃ¶nig <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 9ca51ae46de7..958994edf2c4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -428,7 +428,7 @@ void mpc1_read_mpcc_state(
 			MPCC_BUSY, &s->busy);
 }
 
-const struct mpc_funcs dcn10_mpc_funcs = {
+static const struct mpc_funcs dcn10_mpc_funcs = {
 	.read_mpcc_state = mpc1_read_mpcc_state,
 	.insert_plane = mpc1_insert_plane,
 	.remove_mpcc = mpc1_remove_mpcc,

commit 4173c0bdd7b79ef46161037f8845654416dbaca9
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Wed Mar 14 17:41:57 2018 -0400

    drm/amd/display: Only update mpc blend config if not full update
    
    The current mpcc insert/remove logic does not support updating
    only a single mpcc. So when pixel alpha changed but no full update
    we can mistakenly shuffle the mpcc layering order. With this change
    we will only insert/remove mpcc if there is full update.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 6f7016a2a11e..9ca51ae46de7 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -65,6 +65,7 @@ static void mpc1_update_blending(
 	int mpcc_id)
 {
 	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
+	struct mpcc *mpcc = mpc1_get_mpcc(mpc, mpcc_id);
 
 	REG_UPDATE_5(MPCC_CONTROL[mpcc_id],
 			MPCC_ALPHA_BLND_MODE,		blnd_cfg->alpha_mode,
@@ -74,6 +75,7 @@ static void mpc1_update_blending(
 			MPCC_GLOBAL_GAIN,		blnd_cfg->global_gain);
 
 	mpc1_set_bg_color(mpc, &blnd_cfg->black_color, mpcc_id);
+	mpcc->blnd_cfg = *blnd_cfg;
 }
 
 void mpc1_update_stereo_mix(
@@ -235,8 +237,7 @@ struct mpcc *mpc1_insert_plane(
 	}
 
 	/* update the blending configuration */
-	new_mpcc->blnd_cfg = *blnd_cfg;
-	mpc->funcs->update_blending(mpc, &new_mpcc->blnd_cfg, mpcc_id);
+	mpc->funcs->update_blending(mpc, blnd_cfg, mpcc_id);
 
 	/* update the stereo mix settings, if provided */
 	if (sm_cfg != NULL) {

commit a052a516de4c3e46f2e442ec118c391dbf9932e3
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Mar 13 15:00:20 2018 -0400

    drm/amd/display: align dtn logs and add mpc idle bit print
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 29e15a93a7d0..6f7016a2a11e 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -422,7 +422,9 @@ void mpc1_read_mpcc_state(
 	REG_GET_4(MPCC_CONTROL[mpcc_inst], MPCC_MODE, &s->mode,
 			MPCC_ALPHA_BLND_MODE, &s->alpha_mode,
 			MPCC_ALPHA_MULTIPLIED_MODE, &s->pre_multiplied_alpha,
-			MPCC_BLND_ACTIVE_OVERLAP_ONLY, &s->pre_multiplied_alpha);
+			MPCC_BLND_ACTIVE_OVERLAP_ONLY, &s->overlap_only);
+	REG_GET_2(MPCC_STATUS[mpcc_inst], MPCC_IDLE, &s->idle,
+			MPCC_BUSY, &s->busy);
 }
 
 const struct mpc_funcs dcn10_mpc_funcs = {

commit dfd01f299987e7ede74e27d422c43846d1326010
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jan 24 14:28:30 2018 -0500

    drm/amd/display: add mpc to dtn log
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 179890b1a8c4..29e15a93a7d0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -409,7 +409,24 @@ void mpc1_init_mpcc_list_from_hw(
 	}
 }
 
+void mpc1_read_mpcc_state(
+		struct mpc *mpc,
+		int mpcc_inst,
+		struct mpcc_state *s)
+{
+	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
+
+	REG_GET(MPCC_OPP_ID[mpcc_inst], MPCC_OPP_ID, &s->opp_id);
+	REG_GET(MPCC_TOP_SEL[mpcc_inst], MPCC_TOP_SEL, &s->dpp_id);
+	REG_GET(MPCC_BOT_SEL[mpcc_inst], MPCC_BOT_SEL, &s->bot_mpcc_id);
+	REG_GET_4(MPCC_CONTROL[mpcc_inst], MPCC_MODE, &s->mode,
+			MPCC_ALPHA_BLND_MODE, &s->alpha_mode,
+			MPCC_ALPHA_MULTIPLIED_MODE, &s->pre_multiplied_alpha,
+			MPCC_BLND_ACTIVE_OVERLAP_ONLY, &s->pre_multiplied_alpha);
+}
+
 const struct mpc_funcs dcn10_mpc_funcs = {
+	.read_mpcc_state = mpc1_read_mpcc_state,
 	.insert_plane = mpc1_insert_plane,
 	.remove_mpcc = mpc1_remove_mpcc,
 	.mpc_init = mpc1_mpc_init,

commit 043b19bdedf5d76d4a614f508baaf83aaf7c4b6e
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Mon Nov 27 10:55:52 2017 -0500

    drm/amd/display: use REG_UPDATE for MPC mux
    
    Use REG_UPDATE instead of REG_SET for programming MPC out mux.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 1e72bd42dca4..179890b1a8c4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -218,7 +218,7 @@ struct mpcc *mpc1_insert_plane(
 	if (tree->opp_list == insert_above_mpcc) {
 		/* insert the toppest mpcc */
 		tree->opp_list = new_mpcc;
-		REG_SET(MUX[tree->opp_id], 0, MPC_OUT_MUX, mpcc_id);
+		REG_UPDATE(MUX[tree->opp_id], MPC_OUT_MUX, mpcc_id);
 	} else {
 		/* find insert position */
 		struct mpcc *temp_mpcc = tree->opp_list;
@@ -275,11 +275,11 @@ void mpc1_remove_mpcc(
 		if (mpcc_to_remove->mpcc_bot) {
 			/* set the next MPCC in list to be the top MPCC */
 			tree->opp_list = mpcc_to_remove->mpcc_bot;
-			REG_SET(MUX[tree->opp_id], 0, MPC_OUT_MUX, tree->opp_list->mpcc_id);
+			REG_UPDATE(MUX[tree->opp_id], MPC_OUT_MUX, tree->opp_list->mpcc_id);
 		} else {
 			/* there are no other MPCC is list */
 			tree->opp_list = NULL;
-			REG_SET(MUX[tree->opp_id], 0, MPC_OUT_MUX, 0xf);
+			REG_UPDATE(MUX[tree->opp_id], MPC_OUT_MUX, 0xf);
 		}
 	} else {
 		/* find mpcc to remove MPCC list */
@@ -359,7 +359,7 @@ void mpc1_mpc_init(struct mpc *mpc)
 
 	for (opp_id = 0; opp_id < MAX_OPP; opp_id++) {
 		if (REG(MUX[opp_id]))
-			REG_SET(MUX[opp_id], 0, MPC_OUT_MUX, 0xf);
+			REG_UPDATE(MUX[opp_id], MPC_OUT_MUX, 0xf);
 	}
 }
 

commit 4e1c1875c79b14a05b2bab45aee9b907f805447d
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Thu Nov 16 15:34:50 2017 -0500

    drm/amd/display: Reset MPCC muxes during init
    
    During HW initialization, instead of assuming or
    detecting the existing MPCC mux configuration and
    then removing existing planes, reset all the MPCC
    muxes.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index d6606180b50a..1e72bd42dca4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -101,16 +101,6 @@ void mpc1_assert_idle_mpcc(struct mpc *mpc, int id)
 			1, 100000);
 }
 
-static int mpc1_get_opp_id(struct mpc *mpc, int mpcc_id)
-{
-	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
-	unsigned int opp_id = 0xF;
-
-	REG_GET(MPCC_OPP_ID[mpcc_id], MPCC_OPP_ID, &opp_id);
-
-	return opp_id;
-}
-
 struct mpcc *mpc1_get_mpcc(struct mpc *mpc, int mpcc_id)
 {
 	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
@@ -333,24 +323,44 @@ void mpc1_remove_mpcc(
 	}
 }
 
+static void mpc1_init_mpcc(struct mpcc *mpcc, int mpcc_inst)
+{
+	mpcc->mpcc_id = mpcc_inst;
+	mpcc->dpp_id = 0xf;
+	mpcc->mpcc_bot = NULL;
+	mpcc->blnd_cfg.overlap_only = false;
+	mpcc->blnd_cfg.global_alpha = 0xff;
+	mpcc->blnd_cfg.global_gain = 0xff;
+	mpcc->sm_cfg.enable = false;
+}
+
 /*
  * Reset the MPCC HW status by disconnecting all muxes.
  *
  * Parameters:
  * [in/out] mpc		- MPC context.
- * [in]     mpcc_id	- The MPCC physical instance to reset.
  *
  * Return:  void
  */
-void mpc1_reset_mpcc(
-	struct mpc *mpc,
-	int mpcc_id)
+void mpc1_mpc_init(struct mpc *mpc)
 {
 	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
+	int mpcc_id;
+	int opp_id;
 
-	REG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, 0xf);
-	REG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, 0xf);
-	REG_SET(MPCC_OPP_ID[mpcc_id],  0, MPCC_OPP_ID,  0xf);
+	mpc10->mpcc_in_use_mask = 0;
+	for (mpcc_id = 0; mpcc_id < mpc10->num_mpcc; mpcc_id++) {
+		REG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, 0xf);
+		REG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, 0xf);
+		REG_SET(MPCC_OPP_ID[mpcc_id],  0, MPCC_OPP_ID,  0xf);
+
+		mpc1_init_mpcc(&(mpc->mpcc_array[mpcc_id]), mpcc_id);
+	}
+
+	for (opp_id = 0; opp_id < MAX_OPP; opp_id++) {
+		if (REG(MUX[opp_id]))
+			REG_SET(MUX[opp_id], 0, MPC_OUT_MUX, 0xf);
+	}
 }
 
 void mpc1_init_mpcc_list_from_hw(
@@ -399,27 +409,15 @@ void mpc1_init_mpcc_list_from_hw(
 	}
 }
 
-static void mpc1_init_mpcc(struct mpcc *mpcc, int mpcc_inst)
-{
-	mpcc->mpcc_id = mpcc_inst;
-	mpcc->dpp_id = 0xf;
-	mpcc->mpcc_bot = NULL;
-	mpcc->blnd_cfg.overlap_only = false;
-	mpcc->blnd_cfg.global_alpha = 0xff;
-	mpcc->blnd_cfg.global_gain = 0xff;
-	mpcc->sm_cfg.enable = false;
-}
-
 const struct mpc_funcs dcn10_mpc_funcs = {
 	.insert_plane = mpc1_insert_plane,
 	.remove_mpcc = mpc1_remove_mpcc,
-	.reset_mpcc = mpc1_reset_mpcc,
+	.mpc_init = mpc1_mpc_init,
 	.get_mpcc_for_dpp = mpc1_get_mpcc_for_dpp,
 	.wait_for_idle = mpc1_assert_idle_mpcc,
 	.assert_mpcc_idle_before_connect = mpc1_assert_mpcc_idle_before_connect,
 	.init_mpcc_list_from_hw = mpc1_init_mpcc_list_from_hw,
 	.update_blending = mpc1_update_blending,
-	.get_opp_id = mpc1_get_opp_id,
 };
 
 void dcn10_mpc_construct(struct dcn10_mpc *mpc10,

commit 49fac0b46a689519c13efafba9e754525d420136
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Thu Nov 16 14:29:10 2017 -0500

    drm/amd/display: MPC updates
    
    Fix update_mpcc logic to only call assert_mpcc_idle_before_connect
    if mpcc is not already being used (and required removal).
    Update set_out_rate_control to include optional flow control parameter.
    In init_mpcc_from_hw check for case where bot_sel is same as mpcc_id.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index a13d25d1c568..d6606180b50a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -300,11 +300,11 @@ void mpc1_remove_mpcc(
 
 		if (temp_mpcc && temp_mpcc->mpcc_bot == mpcc_to_remove) {
 			found = true;
+			temp_mpcc->mpcc_bot = mpcc_to_remove->mpcc_bot;
 			if (mpcc_to_remove->mpcc_bot) {
 				/* remove MPCC in middle of list */
 				REG_SET(MPCC_BOT_SEL[temp_mpcc->mpcc_id], 0,
 						MPCC_BOT_SEL, mpcc_to_remove->mpcc_bot->mpcc_id);
-				temp_mpcc->mpcc_bot = mpcc_to_remove->mpcc_bot;
 			} else {
 				/* remove MPCC from bottom of list */
 				REG_SET(MPCC_BOT_SEL[temp_mpcc->mpcc_id], 0,
@@ -374,6 +374,9 @@ void mpc1_init_mpcc_list_from_hw(
 			REG_GET(MPCC_TOP_SEL[mpcc_id], MPCC_TOP_SEL, &top_sel);
 			REG_GET(MPCC_BOT_SEL[mpcc_id],  MPCC_BOT_SEL, &bot_sel);
 
+			if (bot_sel == mpcc_id)
+				bot_sel = 0xf;
+
 			if ((opp_id == tree->opp_id) && (top_sel != 0xf)) {
 				mpcc = mpc1_get_mpcc(mpc, mpcc_id);
 				mpcc->dpp_id = top_sel;

commit c1fba8204b909d195f9dc4a638921260ac792124
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Nov 16 12:43:59 2017 -0500

    drm/amd/display: Fixed read wrong reg to get bot_sel.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index e926c29993f9..a13d25d1c568 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -372,7 +372,7 @@ void mpc1_init_mpcc_list_from_hw(
 		for (mpcc_id = 0; mpcc_id < mpc10->num_mpcc; mpcc_id++) {
 			REG_GET(MPCC_OPP_ID[mpcc_id],  MPCC_OPP_ID,  &opp_id);
 			REG_GET(MPCC_TOP_SEL[mpcc_id], MPCC_TOP_SEL, &top_sel);
-			REG_GET(MPCC_STATUS[mpcc_id],  MPCC_BOT_SEL, &bot_sel);
+			REG_GET(MPCC_BOT_SEL[mpcc_id],  MPCC_BOT_SEL, &bot_sel);
 
 			if ((opp_id == tree->opp_id) && (top_sel != 0xf)) {
 				mpcc = mpc1_get_mpcc(mpc, mpcc_id);

commit feb4a3cd8eb007f4749dc8323110f42fb4682ae0
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Mon Nov 6 16:38:55 2017 -0500

    drm/amd/display: Integrating MPC pseudocode
    
    Integrating MPC pseudocode to support new blending cases
    with secondary MPCC list.
    This includes a design change to MPC data structures and
    interfaces.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index b016f4cbd45c..e926c29993f9 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -25,8 +25,6 @@
 
 #include "reg_helper.h"
 #include "dcn10_mpc.h"
-#include "dc.h"
-#include "mem_input.h"
 
 #define REG(reg)\
 	mpc10->mpc_regs->reg
@@ -38,17 +36,13 @@
 #define FN(reg_name, field_name) \
 	mpc10->mpc_shift->field_name, mpc10->mpc_mask->field_name
 
-#define MODE_TOP_ONLY 1
-#define MODE_BLEND 3
-#define BLND_PP_ALPHA 0
-#define BLND_GLOBAL_ALPHA 2
 
-
-static void mpc10_set_bg_color(
-		struct dcn10_mpc *mpc10,
+void mpc1_set_bg_color(struct mpc *mpc,
 		struct tg_color *bg_color,
-		int id)
+		int mpcc_id)
 {
+	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
+
 	/* mpc color is 12 bit.  tg_color is 10 bit */
 	/* todo: might want to use 16 bit to represent color and have each
 	 * hw block translate to correct color depth.
@@ -57,15 +51,47 @@ static void mpc10_set_bg_color(
 	uint32_t bg_g_y = bg_color->color_g_y << 2;
 	uint32_t bg_b_cb = bg_color->color_b_cb << 2;
 
-	REG_SET(MPCC_BG_R_CR[id], 0,
+	REG_SET(MPCC_BG_R_CR[mpcc_id], 0,
 			MPCC_BG_R_CR, bg_r_cr);
-	REG_SET(MPCC_BG_G_Y[id], 0,
+	REG_SET(MPCC_BG_G_Y[mpcc_id], 0,
 			MPCC_BG_G_Y, bg_g_y);
-	REG_SET(MPCC_BG_B_CB[id], 0,
+	REG_SET(MPCC_BG_B_CB[mpcc_id], 0,
 			MPCC_BG_B_CB, bg_b_cb);
 }
 
-void mpc10_assert_idle_mpcc(struct mpc *mpc, int id)
+static void mpc1_update_blending(
+	struct mpc *mpc,
+	struct mpcc_blnd_cfg *blnd_cfg,
+	int mpcc_id)
+{
+	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
+
+	REG_UPDATE_5(MPCC_CONTROL[mpcc_id],
+			MPCC_ALPHA_BLND_MODE,		blnd_cfg->alpha_mode,
+			MPCC_ALPHA_MULTIPLIED_MODE,	blnd_cfg->pre_multiplied_alpha,
+			MPCC_BLND_ACTIVE_OVERLAP_ONLY,	blnd_cfg->overlap_only,
+			MPCC_GLOBAL_ALPHA,		blnd_cfg->global_alpha,
+			MPCC_GLOBAL_GAIN,		blnd_cfg->global_gain);
+
+	mpc1_set_bg_color(mpc, &blnd_cfg->black_color, mpcc_id);
+}
+
+void mpc1_update_stereo_mix(
+	struct mpc *mpc,
+	struct mpcc_sm_cfg *sm_cfg,
+	int mpcc_id)
+{
+	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
+
+	REG_UPDATE_6(MPCC_SM_CONTROL[mpcc_id],
+			MPCC_SM_EN,			sm_cfg->enable,
+			MPCC_SM_MODE,			sm_cfg->sm_mode,
+			MPCC_SM_FRAME_ALT,		sm_cfg->frame_alt,
+			MPCC_SM_FIELD_ALT,		sm_cfg->field_alt,
+			MPCC_SM_FORCE_NEXT_FRAME_POL,	sm_cfg->force_next_frame_porlarity,
+			MPCC_SM_FORCE_NEXT_TOP_POL,	sm_cfg->force_next_field_polarity);
+}
+void mpc1_assert_idle_mpcc(struct mpc *mpc, int id)
 {
 	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
 
@@ -75,39 +101,62 @@ void mpc10_assert_idle_mpcc(struct mpc *mpc, int id)
 			1, 100000);
 }
 
-static int mpc10_get_idle_mpcc_id(struct dcn10_mpc *mpc10)
+static int mpc1_get_opp_id(struct mpc *mpc, int mpcc_id)
 {
-	int i;
-	int last_free_mpcc_id = -1;
+	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
+	unsigned int opp_id = 0xF;
 
-	for (i = 0; i < mpc10->num_mpcc; i++) {
-		uint32_t is_idle = 0;
+	REG_GET(MPCC_OPP_ID[mpcc_id], MPCC_OPP_ID, &opp_id);
 
-		if (mpc10->mpcc_in_use_mask & 1 << i)
-			continue;
+	return opp_id;
+}
 
-		last_free_mpcc_id = i;
-		REG_GET(MPCC_STATUS[i], MPCC_IDLE, &is_idle);
-		if (is_idle)
-			return i;
-	}
+struct mpcc *mpc1_get_mpcc(struct mpc *mpc, int mpcc_id)
+{
+	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
 
-	/* This assert should never trigger, we have mpcc leak if it does */
-	ASSERT(last_free_mpcc_id != -1);
+	ASSERT(mpcc_id < mpc10->num_mpcc);
+	return &(mpc->mpcc_array[mpcc_id]);
+}
+
+struct mpcc *mpc1_get_mpcc_for_dpp(struct mpc_tree *tree, int dpp_id)
+{
+	struct mpcc *tmp_mpcc = tree->opp_list;
+
+	while (tmp_mpcc != NULL) {
+		if (tmp_mpcc->dpp_id == dpp_id)
+			return tmp_mpcc;
+		tmp_mpcc = tmp_mpcc->mpcc_bot;
+	}
+	return NULL;
+}
 
-	mpc10_assert_idle_mpcc(&mpc10->base, last_free_mpcc_id);
-	return last_free_mpcc_id;
+bool mpc1_is_mpcc_idle(struct mpc *mpc, int mpcc_id)
+{
+	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
+	unsigned int top_sel;
+	unsigned int opp_id;
+	unsigned int idle;
+
+	REG_GET(MPCC_TOP_SEL[mpcc_id], MPCC_TOP_SEL, &top_sel);
+	REG_GET(MPCC_OPP_ID[mpcc_id],  MPCC_OPP_ID, &opp_id);
+	REG_GET(MPCC_STATUS[mpcc_id],  MPCC_IDLE,   &idle);
+	if (top_sel == 0xf && opp_id == 0xf && idle)
+		return true;
+	else
+		return false;
 }
 
-static void mpc10_assert_mpcc_idle_before_connect(struct dcn10_mpc *mpc10, int id)
+void mpc1_assert_mpcc_idle_before_connect(struct mpc *mpc, int mpcc_id)
 {
+	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
 	unsigned int top_sel, mpc_busy, mpc_idle;
 
-	REG_GET(MPCC_TOP_SEL[id],
+	REG_GET(MPCC_TOP_SEL[mpcc_id],
 			MPCC_TOP_SEL, &top_sel);
 
 	if (top_sel == 0xf) {
-		REG_GET_2(MPCC_STATUS[id],
+		REG_GET_2(MPCC_STATUS[mpcc_id],
 				MPCC_BUSY, &mpc_busy,
 				MPCC_IDLE, &mpc_idle);
 
@@ -116,241 +165,258 @@ static void mpc10_assert_mpcc_idle_before_connect(struct dcn10_mpc *mpc10, int i
 	}
 }
 
-void mpc10_mpcc_remove(
-		struct mpc *mpc,
-		struct mpc_tree_cfg *tree_cfg,
-		int opp_id,
-		int dpp_id)
-{
-	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
-	int mpcc_id, z_idx;
-
-	/* find z_idx for the dpp to be removed */
-	for (z_idx = 0; z_idx < tree_cfg->num_pipes; z_idx++)
-		if (tree_cfg->dpp[z_idx] == dpp_id)
-			break;
-
-	if (z_idx == tree_cfg->num_pipes) {
-		/* In case of resume from S3/S4, remove mpcc from bios left over */
-		REG_SET(MPCC_OPP_ID[dpp_id], 0,
-				MPCC_OPP_ID, 0xf);
-		REG_SET(MPCC_TOP_SEL[dpp_id], 0,
-				MPCC_TOP_SEL, 0xf);
-		REG_SET(MPCC_BOT_SEL[dpp_id], 0,
-				MPCC_BOT_SEL, 0xf);
-		return;
-	}
-
-	mpcc_id = tree_cfg->mpcc[z_idx];
-
-	REG_SET(MPCC_OPP_ID[mpcc_id], 0,
-			MPCC_OPP_ID, 0xf);
-	REG_SET(MPCC_TOP_SEL[mpcc_id], 0,
-			MPCC_TOP_SEL, 0xf);
-	REG_SET(MPCC_BOT_SEL[mpcc_id], 0,
-			MPCC_BOT_SEL, 0xf);
-
-	if (z_idx > 0) {
-		int top_mpcc_id = tree_cfg->mpcc[z_idx - 1];
-
-		if (z_idx + 1 < tree_cfg->num_pipes)
-			/* mpcc to be removed is in the middle of the tree */
-			REG_SET(MPCC_BOT_SEL[top_mpcc_id], 0,
-					MPCC_BOT_SEL, tree_cfg->mpcc[z_idx + 1]);
-		else {
-			/* mpcc to be removed is at the bottom of the tree */
-			REG_SET(MPCC_BOT_SEL[top_mpcc_id], 0,
-					MPCC_BOT_SEL, 0xf);
-			REG_UPDATE(MPCC_CONTROL[top_mpcc_id],
-					MPCC_MODE, MODE_TOP_ONLY);
-		}
-	} else if (tree_cfg->num_pipes > 1)
-		/* mpcc to be removed is at the top of the tree */
-		REG_SET(MUX[opp_id], 0,
-				MPC_OUT_MUX, tree_cfg->mpcc[z_idx + 1]);
-	else
-		/* mpcc to be removed is the only one in the tree */
-		REG_SET(MUX[opp_id], 0, MPC_OUT_MUX, 0xf);
-
-	/* mark this mpcc as not in use */
-	mpc10->mpcc_in_use_mask &= ~(1 << mpcc_id);
-	tree_cfg->num_pipes--;
-	for (; z_idx < tree_cfg->num_pipes; z_idx++) {
-		tree_cfg->dpp[z_idx] = tree_cfg->dpp[z_idx + 1];
-		tree_cfg->mpcc[z_idx] = tree_cfg->mpcc[z_idx + 1];
-	}
-	tree_cfg->dpp[tree_cfg->num_pipes] = 0xdeadbeef;
-	tree_cfg->mpcc[tree_cfg->num_pipes] = 0xdeadbeef;
-}
-
-static void mpc10_add_to_tree_cfg(
+/*
+ * Insert DPP into MPC tree based on specified blending position.
+ * Only used for planes that are part of blending chain for OPP output
+ *
+ * Parameters:
+ * [in/out] mpc		- MPC context.
+ * [in/out] tree	- MPC tree structure that plane will be added to.
+ * [in]	blnd_cfg	- MPCC blending configuration for the new blending layer.
+ * [in]	sm_cfg		- MPCC stereo mix configuration for the new blending layer.
+ *			  stereo mix must disable for the very bottom layer of the tree config.
+ * [in]	insert_above_mpcc - Insert new plane above this MPCC.  If NULL, insert as bottom plane.
+ * [in]	dpp_id		- DPP instance for the plane to be added.
+ * [in]	mpcc_id		- The MPCC physical instance to use for blending.
+ *
+ * Return:  struct mpcc* - MPCC that was added.
+ */
+struct mpcc *mpc1_insert_plane(
 	struct mpc *mpc,
-	struct mpcc_cfg *cfg,
+	struct mpc_tree *tree,
+	struct mpcc_blnd_cfg *blnd_cfg,
+	struct mpcc_sm_cfg *sm_cfg,
+	struct mpcc *insert_above_mpcc,
+	int dpp_id,
 	int mpcc_id)
 {
 	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
-	int mpcc_mode = MODE_TOP_ONLY;
-	int position = cfg->z_index;
-	struct mpc_tree_cfg *tree_cfg = cfg->tree_cfg;
-	int alpha_blnd_mode = cfg->per_pixel_alpha ?
-			BLND_PP_ALPHA : BLND_GLOBAL_ALPHA;
-	int z_idx;
+	struct mpcc *new_mpcc = NULL;
 
-	REG_SET(MPCC_OPP_ID[mpcc_id], 0,
-			MPCC_OPP_ID, cfg->opp_id);
+	/* sanity check parameters */
+	ASSERT(mpcc_id < mpc10->num_mpcc);
+	ASSERT(!(mpc10->mpcc_in_use_mask & 1 << mpcc_id));
 
-	REG_SET(MPCC_TOP_SEL[mpcc_id], 0,
-			MPCC_TOP_SEL, cfg->dpp_id);
+	if (insert_above_mpcc) {
+		/* check insert_above_mpcc exist in tree->opp_list */
+		struct mpcc *temp_mpcc = tree->opp_list;
 
-	if (position == 0) {
-		/* idle dpp/mpcc is added to the top layer of tree */
+		while (temp_mpcc && temp_mpcc->mpcc_bot != insert_above_mpcc)
+			temp_mpcc = temp_mpcc->mpcc_bot;
+		if (temp_mpcc == NULL)
+			return NULL;
+	}
 
-		if (tree_cfg->num_pipes > 0) {
-			/* get instance of previous top mpcc */
-			int prev_top_mpcc_id = tree_cfg->mpcc[0];
+	/* Get and update MPCC struct parameters */
+	new_mpcc = mpc1_get_mpcc(mpc, mpcc_id);
+	new_mpcc->dpp_id = dpp_id;
 
-			REG_SET(MPCC_BOT_SEL[mpcc_id], 0,
-					MPCC_BOT_SEL, prev_top_mpcc_id);
-			mpcc_mode = MODE_BLEND;
+	/* program mux and MPCC_MODE */
+	if (insert_above_mpcc) {
+		new_mpcc->mpcc_bot = insert_above_mpcc;
+		REG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, insert_above_mpcc->mpcc_id);
+		REG_UPDATE(MPCC_CONTROL[mpcc_id], MPCC_MODE, MPCC_BLEND_MODE_TOP_BOT_BLENDING);
+	} else {
+		new_mpcc->mpcc_bot = NULL;
+		REG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, 0xf);
+		REG_UPDATE(MPCC_CONTROL[mpcc_id], MPCC_MODE, MPCC_BLEND_MODE_TOP_LAYER_PASSTHROUGH);
+	}
+	REG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, dpp_id);
+	REG_SET(MPCC_OPP_ID[mpcc_id], 0, MPCC_OPP_ID, tree->opp_id);
+
+	/* update mpc tree mux setting */
+	if (tree->opp_list == insert_above_mpcc) {
+		/* insert the toppest mpcc */
+		tree->opp_list = new_mpcc;
+		REG_SET(MUX[tree->opp_id], 0, MPC_OUT_MUX, mpcc_id);
+	} else {
+		/* find insert position */
+		struct mpcc *temp_mpcc = tree->opp_list;
+
+		while (temp_mpcc && temp_mpcc->mpcc_bot != insert_above_mpcc)
+			temp_mpcc = temp_mpcc->mpcc_bot;
+		if (temp_mpcc && temp_mpcc->mpcc_bot == insert_above_mpcc) {
+			REG_SET(MPCC_BOT_SEL[temp_mpcc->mpcc_id], 0, MPCC_BOT_SEL, mpcc_id);
+			temp_mpcc->mpcc_bot = new_mpcc;
+			if (!insert_above_mpcc)
+				REG_UPDATE(MPCC_CONTROL[temp_mpcc->mpcc_id],
+						MPCC_MODE, MPCC_BLEND_MODE_TOP_BOT_BLENDING);
 		}
+	}
 
-		/* opp will get new output. from new added mpcc */
-		REG_SET(MUX[cfg->opp_id], 0, MPC_OUT_MUX, mpcc_id);
-
-	} else if (position == tree_cfg->num_pipes) {
-		/* idle dpp/mpcc is added to the bottom layer of tree */
-
-		/* get instance of previous bottom mpcc, set to middle layer */
-		int prev_bot_mpcc_id = tree_cfg->mpcc[tree_cfg->num_pipes - 1];
-
-		REG_SET(MPCC_BOT_SEL[prev_bot_mpcc_id], 0,
-				MPCC_BOT_SEL, mpcc_id);
-		REG_UPDATE(MPCC_CONTROL[prev_bot_mpcc_id],
-				MPCC_MODE, MODE_BLEND);
-
-		/* mpcc_id become new bottom mpcc*/
-		REG_SET(MPCC_BOT_SEL[mpcc_id], 0,
-				MPCC_BOT_SEL, 0xf);
+	/* update the blending configuration */
+	new_mpcc->blnd_cfg = *blnd_cfg;
+	mpc->funcs->update_blending(mpc, &new_mpcc->blnd_cfg, mpcc_id);
 
-	} else {
-		/* idle dpp/mpcc is added to middle of tree */
-		int above_mpcc_id = tree_cfg->mpcc[position - 1];
-		int below_mpcc_id = tree_cfg->mpcc[position];
-
-		/* mpcc above new mpcc_id has new bottom mux*/
-		REG_SET(MPCC_BOT_SEL[above_mpcc_id], 0,
-				MPCC_BOT_SEL, mpcc_id);
-		REG_UPDATE(MPCC_CONTROL[above_mpcc_id],
-				MPCC_MODE, MODE_BLEND);
-
-		/* mpcc_id bottom mux is from below mpcc*/
-		REG_SET(MPCC_BOT_SEL[mpcc_id], 0,
-				MPCC_BOT_SEL, below_mpcc_id);
-		mpcc_mode = MODE_BLEND;
+	/* update the stereo mix settings, if provided */
+	if (sm_cfg != NULL) {
+		new_mpcc->sm_cfg = *sm_cfg;
+		mpc1_update_stereo_mix(mpc, sm_cfg, mpcc_id);
 	}
 
-	REG_SET_4(MPCC_CONTROL[mpcc_id], 0xffffffff,
-		MPCC_MODE, mpcc_mode,
-		MPCC_ALPHA_BLND_MODE, alpha_blnd_mode,
-		MPCC_ALPHA_MULTIPLIED_MODE, cfg->pre_multiplied_alpha,
-		MPCC_BLND_ACTIVE_OVERLAP_ONLY, false);
+	/* mark this mpcc as in use */
+	mpc10->mpcc_in_use_mask |= 1 << mpcc_id;
 
-	/* update mpc_tree_cfg with new mpcc */
-	for (z_idx = tree_cfg->num_pipes; z_idx > position; z_idx--) {
-		tree_cfg->dpp[z_idx] = tree_cfg->dpp[z_idx - 1];
-		tree_cfg->mpcc[z_idx] = tree_cfg->mpcc[z_idx - 1];
-	}
-	tree_cfg->dpp[position] = cfg->dpp_id;
-	tree_cfg->mpcc[position] = mpcc_id;
-	tree_cfg->num_pipes++;
+	return new_mpcc;
 }
 
-int mpc10_mpcc_add(struct mpc *mpc, struct mpcc_cfg *cfg)
+/*
+ * Remove a specified MPCC from the MPC tree.
+ *
+ * Parameters:
+ * [in/out] mpc		- MPC context.
+ * [in/out] tree	- MPC tree structure that plane will be removed from.
+ * [in/out] mpcc	- MPCC to be removed from tree.
+ *
+ * Return:  void
+ */
+void mpc1_remove_mpcc(
+	struct mpc *mpc,
+	struct mpc_tree *tree,
+	struct mpcc *mpcc_to_remove)
 {
 	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
-	int mpcc_id, z_idx;
-
-	ASSERT(cfg->z_index < mpc10->num_mpcc);
-
-	/* check in dpp already exists in mpc tree */
-	for (z_idx = 0; z_idx < cfg->tree_cfg->num_pipes; z_idx++)
-		if (cfg->tree_cfg->dpp[z_idx] == cfg->dpp_id)
-			break;
-	if (z_idx == cfg->tree_cfg->num_pipes) {
-		ASSERT(cfg->z_index <= cfg->tree_cfg->num_pipes);
-		mpcc_id = mpc10_get_idle_mpcc_id(mpc10);
-
-		/*
-		 * TODO: remove hack
-		 * Note: currently there is a bug in init_hw such that
-		 * on resume from hibernate, BIOS sets up MPCC0, and
-		 * we do mpcc_remove but the mpcc cannot go to idle
-		 * after remove. This cause us to pick mpcc1 here,
-		 * which causes a pstate hang for yet unknown reason.
-		 */
-		mpcc_id = cfg->dpp_id;
-		/* end hack*/
-
-		ASSERT(!(mpc10->mpcc_in_use_mask & 1 << mpcc_id));
-
-		if (mpc->ctx->dc->debug.sanity_checks)
-			mpc10_assert_mpcc_idle_before_connect(mpc10, mpcc_id);
+	bool found = false;
+	int mpcc_id = mpcc_to_remove->mpcc_id;
+
+	if (tree->opp_list == mpcc_to_remove) {
+		found = true;
+		/* remove MPCC from top of tree */
+		if (mpcc_to_remove->mpcc_bot) {
+			/* set the next MPCC in list to be the top MPCC */
+			tree->opp_list = mpcc_to_remove->mpcc_bot;
+			REG_SET(MUX[tree->opp_id], 0, MPC_OUT_MUX, tree->opp_list->mpcc_id);
+		} else {
+			/* there are no other MPCC is list */
+			tree->opp_list = NULL;
+			REG_SET(MUX[tree->opp_id], 0, MPC_OUT_MUX, 0xf);
+		}
 	} else {
-		ASSERT(cfg->z_index < cfg->tree_cfg->num_pipes);
-		mpcc_id = cfg->tree_cfg->mpcc[z_idx];
-		mpc10_mpcc_remove(mpc, cfg->tree_cfg, cfg->opp_id, cfg->dpp_id);
+		/* find mpcc to remove MPCC list */
+		struct mpcc *temp_mpcc = tree->opp_list;
+
+		while (temp_mpcc && temp_mpcc->mpcc_bot != mpcc_to_remove)
+			temp_mpcc = temp_mpcc->mpcc_bot;
+
+		if (temp_mpcc && temp_mpcc->mpcc_bot == mpcc_to_remove) {
+			found = true;
+			if (mpcc_to_remove->mpcc_bot) {
+				/* remove MPCC in middle of list */
+				REG_SET(MPCC_BOT_SEL[temp_mpcc->mpcc_id], 0,
+						MPCC_BOT_SEL, mpcc_to_remove->mpcc_bot->mpcc_id);
+				temp_mpcc->mpcc_bot = mpcc_to_remove->mpcc_bot;
+			} else {
+				/* remove MPCC from bottom of list */
+				REG_SET(MPCC_BOT_SEL[temp_mpcc->mpcc_id], 0,
+						MPCC_BOT_SEL, 0xf);
+				REG_UPDATE(MPCC_CONTROL[temp_mpcc->mpcc_id],
+						MPCC_MODE, MPCC_BLEND_MODE_TOP_LAYER_PASSTHROUGH);
+			}
+		}
 	}
 
-	/* add dpp/mpcc pair to mpc_tree_cfg and update mpcc registers */
-	mpc10_add_to_tree_cfg(mpc, cfg, mpcc_id);
-
-	/* set background color */
-	mpc10_set_bg_color(mpc10, &cfg->black_color, mpcc_id);
-
-	/* mark this mpcc as in use */
-	mpc10->mpcc_in_use_mask |= 1 << mpcc_id;
+	if (found) {
+		/* turn off MPCC mux registers */
+		REG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, 0xf);
+		REG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, 0xf);
+		REG_SET(MPCC_OPP_ID[mpcc_id],  0, MPCC_OPP_ID,  0xf);
 
-	return mpcc_id;
+		/* mark this mpcc as not in use */
+		mpc10->mpcc_in_use_mask &= ~(1 << mpcc_id);
+		mpcc_to_remove->dpp_id = 0xf;
+		mpcc_to_remove->mpcc_bot = NULL;
+	} else {
+		/* In case of resume from S3/S4, remove mpcc from bios left over */
+		REG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, 0xf);
+		REG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, 0xf);
+		REG_SET(MPCC_OPP_ID[mpcc_id],  0, MPCC_OPP_ID,  0xf);
+	}
 }
 
-void mpc10_update_blend_mode(
-		struct mpc *mpc,
-		struct mpcc_cfg *cfg)
+/*
+ * Reset the MPCC HW status by disconnecting all muxes.
+ *
+ * Parameters:
+ * [in/out] mpc		- MPC context.
+ * [in]     mpcc_id	- The MPCC physical instance to reset.
+ *
+ * Return:  void
+ */
+void mpc1_reset_mpcc(
+	struct mpc *mpc,
+	int mpcc_id)
 {
 	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
-	int mpcc_id, z_idx;
-	int alpha_blnd_mode = cfg->per_pixel_alpha ?
-			BLND_PP_ALPHA : BLND_GLOBAL_ALPHA;
-
-	/* find z_idx for the dpp that requires blending mode update*/
-	for (z_idx = 0; z_idx < cfg->tree_cfg->num_pipes; z_idx++)
-		if (cfg->tree_cfg->dpp[z_idx] == cfg->dpp_id)
-			break;
 
-	ASSERT(z_idx < cfg->tree_cfg->num_pipes);
-	mpcc_id = cfg->tree_cfg->mpcc[z_idx];
-
-	REG_UPDATE_2(MPCC_CONTROL[mpcc_id],
-			MPCC_ALPHA_BLND_MODE, alpha_blnd_mode,
-			MPCC_ALPHA_MULTIPLIED_MODE, cfg->pre_multiplied_alpha);
+	REG_SET(MPCC_TOP_SEL[mpcc_id], 0, MPCC_TOP_SEL, 0xf);
+	REG_SET(MPCC_BOT_SEL[mpcc_id], 0, MPCC_BOT_SEL, 0xf);
+	REG_SET(MPCC_OPP_ID[mpcc_id],  0, MPCC_OPP_ID,  0xf);
 }
 
-int mpc10_get_opp_id(struct mpc *mpc, int mpcc_id)
+void mpc1_init_mpcc_list_from_hw(
+	struct mpc *mpc,
+	struct mpc_tree *tree)
 {
 	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
-	int opp_id = 0xF;
-
-	REG_GET(MPCC_OPP_ID[mpcc_id], MPCC_OPP_ID, &opp_id);
+	unsigned int opp_id;
+	unsigned int top_sel;
+	unsigned int bot_sel;
+	unsigned int out_mux;
+	struct mpcc *mpcc;
+	int mpcc_id;
+	int bot_mpcc_id;
+
+	REG_GET(MUX[tree->opp_id], MPC_OUT_MUX, &out_mux);
+
+	if (out_mux != 0xf) {
+		for (mpcc_id = 0; mpcc_id < mpc10->num_mpcc; mpcc_id++) {
+			REG_GET(MPCC_OPP_ID[mpcc_id],  MPCC_OPP_ID,  &opp_id);
+			REG_GET(MPCC_TOP_SEL[mpcc_id], MPCC_TOP_SEL, &top_sel);
+			REG_GET(MPCC_STATUS[mpcc_id],  MPCC_BOT_SEL, &bot_sel);
+
+			if ((opp_id == tree->opp_id) && (top_sel != 0xf)) {
+				mpcc = mpc1_get_mpcc(mpc, mpcc_id);
+				mpcc->dpp_id = top_sel;
+				mpc10->mpcc_in_use_mask |= 1 << mpcc_id;
+
+				if (out_mux == mpcc_id)
+					tree->opp_list = mpcc;
+				if (bot_sel != 0xf && bot_sel < mpc10->num_mpcc) {
+					bot_mpcc_id = bot_sel;
+					REG_GET(MPCC_OPP_ID[bot_mpcc_id],  MPCC_OPP_ID,  &opp_id);
+					REG_GET(MPCC_TOP_SEL[bot_mpcc_id], MPCC_TOP_SEL, &top_sel);
+					if ((opp_id == tree->opp_id) && (top_sel != 0xf)) {
+						struct mpcc *mpcc_bottom = mpc1_get_mpcc(mpc, bot_mpcc_id);
+
+						mpcc->mpcc_bot = mpcc_bottom;
+					}
+				}
+			}
+		}
+	}
+}
 
-	return opp_id;
+static void mpc1_init_mpcc(struct mpcc *mpcc, int mpcc_inst)
+{
+	mpcc->mpcc_id = mpcc_inst;
+	mpcc->dpp_id = 0xf;
+	mpcc->mpcc_bot = NULL;
+	mpcc->blnd_cfg.overlap_only = false;
+	mpcc->blnd_cfg.global_alpha = 0xff;
+	mpcc->blnd_cfg.global_gain = 0xff;
+	mpcc->sm_cfg.enable = false;
 }
 
 const struct mpc_funcs dcn10_mpc_funcs = {
-		.add = mpc10_mpcc_add,
-		.remove = mpc10_mpcc_remove,
-		.wait_for_idle = mpc10_assert_idle_mpcc,
-		.update_blend_mode = mpc10_update_blend_mode,
-		.get_opp_id = mpc10_get_opp_id,
+	.insert_plane = mpc1_insert_plane,
+	.remove_mpcc = mpc1_remove_mpcc,
+	.reset_mpcc = mpc1_reset_mpcc,
+	.get_mpcc_for_dpp = mpc1_get_mpcc_for_dpp,
+	.wait_for_idle = mpc1_assert_idle_mpcc,
+	.assert_mpcc_idle_before_connect = mpc1_assert_mpcc_idle_before_connect,
+	.init_mpcc_list_from_hw = mpc1_init_mpcc_list_from_hw,
+	.update_blending = mpc1_update_blending,
+	.get_opp_id = mpc1_get_opp_id,
 };
 
 void dcn10_mpc_construct(struct dcn10_mpc *mpc10,
@@ -360,6 +426,8 @@ void dcn10_mpc_construct(struct dcn10_mpc *mpc10,
 	const struct dcn_mpc_mask *mpc_mask,
 	int num_mpcc)
 {
+	int i;
+
 	mpc10->base.ctx = ctx;
 
 	mpc10->base.funcs = &dcn10_mpc_funcs;
@@ -370,5 +438,8 @@ void dcn10_mpc_construct(struct dcn10_mpc *mpc10,
 
 	mpc10->mpcc_in_use_mask = 0;
 	mpc10->num_mpcc = num_mpcc;
+
+	for (i = 0; i < MAX_MPCC; i++)
+		mpc1_init_mpcc(&mpc10->base.mpcc_array[i], i);
 }
 

commit e994340bfa57d96bfbd9e66bf802ea82b4ba56fc
Author: Arun Pandey <Arun.Pandey@amd.com>
Date:   Wed Nov 8 17:02:55 2017 +0800

    drm/amd/display: Added Opp and Diags Interface for P to I
    
    Signed-off-by: Arun Pandey <Arun.Pandey@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 5028619d4fb4..b016f4cbd45c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -335,7 +335,7 @@ void mpc10_update_blend_mode(
 			MPCC_ALPHA_MULTIPLIED_MODE, cfg->pre_multiplied_alpha);
 }
 
-static int mpc10_get_opp_id(struct mpc *mpc, int mpcc_id)
+int mpc10_get_opp_id(struct mpc *mpc, int mpcc_id)
 {
 	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
 	int opp_id = 0xF;

commit 0af4096db9ec6a7b12475bf8d21ee5464722c7a2
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Nov 2 13:24:20 2017 -0400

    drm/amd/display: Modified front end initiail in init_hw
    
    Optimized front end initial sequence, reset MPC module
    properly.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 76573e1f5b01..5028619d4fb4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -335,11 +335,22 @@ void mpc10_update_blend_mode(
 			MPCC_ALPHA_MULTIPLIED_MODE, cfg->pre_multiplied_alpha);
 }
 
+static int mpc10_get_opp_id(struct mpc *mpc, int mpcc_id)
+{
+	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
+	int opp_id = 0xF;
+
+	REG_GET(MPCC_OPP_ID[mpcc_id], MPCC_OPP_ID, &opp_id);
+
+	return opp_id;
+}
+
 const struct mpc_funcs dcn10_mpc_funcs = {
 		.add = mpc10_mpcc_add,
 		.remove = mpc10_mpcc_remove,
 		.wait_for_idle = mpc10_assert_idle_mpcc,
 		.update_blend_mode = mpc10_update_blend_mode,
+		.get_opp_id = mpc10_get_opp_id,
 };
 
 void dcn10_mpc_construct(struct dcn10_mpc *mpc10,

commit 8534575fed085a78a847f88fbc929d9c4a8c3255
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Thu Oct 5 14:27:27 2017 -0400

    drm/amd/display: Expose some MPC functions for reuse
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 334f072cea1d..76573e1f5b01 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -65,7 +65,7 @@ static void mpc10_set_bg_color(
 			MPCC_BG_B_CB, bg_b_cb);
 }
 
-static void mpc10_assert_idle_mpcc(struct mpc *mpc, int id)
+void mpc10_assert_idle_mpcc(struct mpc *mpc, int id)
 {
 	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
 
@@ -116,7 +116,7 @@ static void mpc10_assert_mpcc_idle_before_connect(struct dcn10_mpc *mpc10, int i
 	}
 }
 
-static void mpc10_mpcc_remove(
+void mpc10_mpcc_remove(
 		struct mpc *mpc,
 		struct mpc_tree_cfg *tree_cfg,
 		int opp_id,
@@ -265,7 +265,7 @@ static void mpc10_add_to_tree_cfg(
 	tree_cfg->num_pipes++;
 }
 
-static int mpc10_mpcc_add(struct mpc *mpc, struct mpcc_cfg *cfg)
+int mpc10_mpcc_add(struct mpc *mpc, struct mpcc_cfg *cfg)
 {
 	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
 	int mpcc_id, z_idx;
@@ -313,7 +313,7 @@ static int mpc10_mpcc_add(struct mpc *mpc, struct mpcc_cfg *cfg)
 	return mpcc_id;
 }
 
-static void mpc10_update_blend_mode(
+void mpc10_update_blend_mode(
 		struct mpc *mpc,
 		struct mpcc_cfg *cfg)
 {
@@ -339,8 +339,7 @@ const struct mpc_funcs dcn10_mpc_funcs = {
 		.add = mpc10_mpcc_add,
 		.remove = mpc10_mpcc_remove,
 		.wait_for_idle = mpc10_assert_idle_mpcc,
-		.set_denorm = NULL,
-		.update_blend_mode = mpc10_update_blend_mode
+		.update_blend_mode = mpc10_update_blend_mode,
 };
 
 void dcn10_mpc_construct(struct dcn10_mpc *mpc10,

commit 62bf6e9b292212b9a821bd3c24adff57ff4b4bd7
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Thu Sep 14 18:01:40 2017 -0400

    drm/amd/display: update blending mode and set output denorm
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 6e56fa3a135b..334f072cea1d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -313,10 +313,34 @@ static int mpc10_mpcc_add(struct mpc *mpc, struct mpcc_cfg *cfg)
 	return mpcc_id;
 }
 
+static void mpc10_update_blend_mode(
+		struct mpc *mpc,
+		struct mpcc_cfg *cfg)
+{
+	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
+	int mpcc_id, z_idx;
+	int alpha_blnd_mode = cfg->per_pixel_alpha ?
+			BLND_PP_ALPHA : BLND_GLOBAL_ALPHA;
+
+	/* find z_idx for the dpp that requires blending mode update*/
+	for (z_idx = 0; z_idx < cfg->tree_cfg->num_pipes; z_idx++)
+		if (cfg->tree_cfg->dpp[z_idx] == cfg->dpp_id)
+			break;
+
+	ASSERT(z_idx < cfg->tree_cfg->num_pipes);
+	mpcc_id = cfg->tree_cfg->mpcc[z_idx];
+
+	REG_UPDATE_2(MPCC_CONTROL[mpcc_id],
+			MPCC_ALPHA_BLND_MODE, alpha_blnd_mode,
+			MPCC_ALPHA_MULTIPLIED_MODE, cfg->pre_multiplied_alpha);
+}
+
 const struct mpc_funcs dcn10_mpc_funcs = {
 		.add = mpc10_mpcc_add,
 		.remove = mpc10_mpcc_remove,
-		.wait_for_idle = mpc10_assert_idle_mpcc
+		.wait_for_idle = mpc10_assert_idle_mpcc,
+		.set_denorm = NULL,
+		.update_blend_mode = mpc10_update_blend_mode
 };
 
 void dcn10_mpc_construct(struct dcn10_mpc *mpc10,
@@ -337,3 +361,4 @@ void dcn10_mpc_construct(struct dcn10_mpc *mpc10,
 	mpc10->mpcc_in_use_mask = 0;
 	mpc10->num_mpcc = num_mpcc;
 }
+

commit 904aa42e77aa7fb5f95408b4d1ffb4b2c3a805d7
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Thu Sep 14 19:03:04 2017 -0400

    drm/amd/display: add back removed hack for mpcc add
    
    A previous changed removed the hack to match mpcc_idd
    with mi instance. This causes pstate hang on resume
    from hibernate for yet unknown reason. Add the hack
    back for now to work around the issue. More debugging
    required in init_hw to root cause the hang.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 8e767c84359c..6e56fa3a135b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -279,6 +279,18 @@ static int mpc10_mpcc_add(struct mpc *mpc, struct mpcc_cfg *cfg)
 	if (z_idx == cfg->tree_cfg->num_pipes) {
 		ASSERT(cfg->z_index <= cfg->tree_cfg->num_pipes);
 		mpcc_id = mpc10_get_idle_mpcc_id(mpc10);
+
+		/*
+		 * TODO: remove hack
+		 * Note: currently there is a bug in init_hw such that
+		 * on resume from hibernate, BIOS sets up MPCC0, and
+		 * we do mpcc_remove but the mpcc cannot go to idle
+		 * after remove. This cause us to pick mpcc1 here,
+		 * which causes a pstate hang for yet unknown reason.
+		 */
+		mpcc_id = cfg->dpp_id;
+		/* end hack*/
+
 		ASSERT(!(mpc10->mpcc_in_use_mask & 1 << mpcc_id));
 
 		if (mpc->ctx->dc->debug.sanity_checks)

commit 7f4a7253b112c9ed21022e25c7a740d824c56619
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Mon Sep 11 16:56:51 2017 -0400

    drm/amd/display: update mpc add/remove functions
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 082b39a65e6a..8e767c84359c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -118,17 +118,19 @@ static void mpc10_assert_mpcc_idle_before_connect(struct dcn10_mpc *mpc10, int i
 
 static void mpc10_mpcc_remove(
 		struct mpc *mpc,
-		struct output_pixel_processor *opp,
+		struct mpc_tree_cfg *tree_cfg,
+		int opp_id,
 		int dpp_id)
 {
 	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
 	int mpcc_id, z_idx;
 
-	for (z_idx = 0; z_idx < opp->mpc_tree.num_pipes; z_idx++)
-		if (opp->mpc_tree.dpp[z_idx] == dpp_id)
+	/* find z_idx for the dpp to be removed */
+	for (z_idx = 0; z_idx < tree_cfg->num_pipes; z_idx++)
+		if (tree_cfg->dpp[z_idx] == dpp_id)
 			break;
 
-	if (z_idx == opp->mpc_tree.num_pipes) {
+	if (z_idx == tree_cfg->num_pipes) {
 		/* In case of resume from S3/S4, remove mpcc from bios left over */
 		REG_SET(MPCC_OPP_ID[dpp_id], 0,
 				MPCC_OPP_ID, 0xf);
@@ -139,7 +141,7 @@ static void mpc10_mpcc_remove(
 		return;
 	}
 
-	mpcc_id = opp->mpc_tree.mpcc[z_idx];
+	mpcc_id = tree_cfg->mpcc[z_idx];
 
 	REG_SET(MPCC_OPP_ID[mpcc_id], 0,
 			MPCC_OPP_ID, 0xf);
@@ -149,82 +151,101 @@ static void mpc10_mpcc_remove(
 			MPCC_BOT_SEL, 0xf);
 
 	if (z_idx > 0) {
-		int top_mpcc_id = opp->mpc_tree.mpcc[z_idx - 1];
+		int top_mpcc_id = tree_cfg->mpcc[z_idx - 1];
 
-		if (z_idx + 1 < opp->mpc_tree.num_pipes)
+		if (z_idx + 1 < tree_cfg->num_pipes)
+			/* mpcc to be removed is in the middle of the tree */
 			REG_SET(MPCC_BOT_SEL[top_mpcc_id], 0,
-					MPCC_BOT_SEL, opp->mpc_tree.mpcc[z_idx + 1]);
+					MPCC_BOT_SEL, tree_cfg->mpcc[z_idx + 1]);
 		else {
+			/* mpcc to be removed is at the bottom of the tree */
 			REG_SET(MPCC_BOT_SEL[top_mpcc_id], 0,
 					MPCC_BOT_SEL, 0xf);
 			REG_UPDATE(MPCC_CONTROL[top_mpcc_id],
 					MPCC_MODE, MODE_TOP_ONLY);
 		}
-	} else if (opp->mpc_tree.num_pipes > 1)
-		REG_SET(MUX[opp->inst], 0,
-				MPC_OUT_MUX, opp->mpc_tree.mpcc[z_idx + 1]);
+	} else if (tree_cfg->num_pipes > 1)
+		/* mpcc to be removed is at the top of the tree */
+		REG_SET(MUX[opp_id], 0,
+				MPC_OUT_MUX, tree_cfg->mpcc[z_idx + 1]);
 	else
-		REG_SET(MUX[opp->inst], 0, MPC_OUT_MUX, 0xf);
+		/* mpcc to be removed is the only one in the tree */
+		REG_SET(MUX[opp_id], 0, MPC_OUT_MUX, 0xf);
 
+	/* mark this mpcc as not in use */
 	mpc10->mpcc_in_use_mask &= ~(1 << mpcc_id);
-	opp->mpc_tree.num_pipes--;
-	for (; z_idx < opp->mpc_tree.num_pipes; z_idx++) {
-		opp->mpc_tree.dpp[z_idx] = opp->mpc_tree.dpp[z_idx + 1];
-		opp->mpc_tree.mpcc[z_idx] = opp->mpc_tree.mpcc[z_idx + 1];
+	tree_cfg->num_pipes--;
+	for (; z_idx < tree_cfg->num_pipes; z_idx++) {
+		tree_cfg->dpp[z_idx] = tree_cfg->dpp[z_idx + 1];
+		tree_cfg->mpcc[z_idx] = tree_cfg->mpcc[z_idx + 1];
 	}
-	opp->mpc_tree.dpp[opp->mpc_tree.num_pipes] = 0xdeadbeef;
-	opp->mpc_tree.mpcc[opp->mpc_tree.num_pipes] = 0xdeadbeef;
+	tree_cfg->dpp[tree_cfg->num_pipes] = 0xdeadbeef;
+	tree_cfg->mpcc[tree_cfg->num_pipes] = 0xdeadbeef;
 }
 
-static void mpc10_mpcc_add(struct mpc *mpc, struct mpcc_cfg *cfg)
+static void mpc10_add_to_tree_cfg(
+	struct mpc *mpc,
+	struct mpcc_cfg *cfg,
+	int mpcc_id)
 {
 	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
+	int mpcc_mode = MODE_TOP_ONLY;
+	int position = cfg->z_index;
+	struct mpc_tree_cfg *tree_cfg = cfg->tree_cfg;
 	int alpha_blnd_mode = cfg->per_pixel_alpha ?
 			BLND_PP_ALPHA : BLND_GLOBAL_ALPHA;
-	int mpcc_mode = MODE_TOP_ONLY;
-	int mpcc_id, z_idx;
+	int z_idx;
 
-	ASSERT(cfg->z_index < mpc10->num_mpcc);
+	REG_SET(MPCC_OPP_ID[mpcc_id], 0,
+			MPCC_OPP_ID, cfg->opp_id);
 
-	for (z_idx = 0; z_idx < cfg->opp->mpc_tree.num_pipes; z_idx++)
-		if (cfg->opp->mpc_tree.dpp[z_idx] == cfg->mi->inst)
-			break;
-	if (z_idx == cfg->opp->mpc_tree.num_pipes) {
-		ASSERT(cfg->z_index <= cfg->opp->mpc_tree.num_pipes);
-		mpcc_id = mpc10_get_idle_mpcc_id(mpc10);
-		/*todo: remove hack*/
-		mpcc_id = cfg->mi->inst;
-		ASSERT(!(mpc10->mpcc_in_use_mask & 1 << mpcc_id));
+	REG_SET(MPCC_TOP_SEL[mpcc_id], 0,
+			MPCC_TOP_SEL, cfg->dpp_id);
 
-		if (mpc->ctx->dc->debug.sanity_checks)
-			mpc10_assert_mpcc_idle_before_connect(mpc10, mpcc_id);
-	} else {
-		ASSERT(cfg->z_index < cfg->opp->mpc_tree.num_pipes);
-		mpcc_id = cfg->opp->mpc_tree.mpcc[z_idx];
-		mpc10_mpcc_remove(mpc, cfg->opp, cfg->mi->inst);
-	}
+	if (position == 0) {
+		/* idle dpp/mpcc is added to the top layer of tree */
 
-	REG_SET(MPCC_OPP_ID[mpcc_id], 0,
-			MPCC_OPP_ID, cfg->opp->inst);
+		if (tree_cfg->num_pipes > 0) {
+			/* get instance of previous top mpcc */
+			int prev_top_mpcc_id = tree_cfg->mpcc[0];
 
-	REG_SET(MPCC_TOP_SEL[mpcc_id], 0,
-			MPCC_TOP_SEL, cfg->mi->inst);
+			REG_SET(MPCC_BOT_SEL[mpcc_id], 0,
+					MPCC_BOT_SEL, prev_top_mpcc_id);
+			mpcc_mode = MODE_BLEND;
+		}
+
+		/* opp will get new output. from new added mpcc */
+		REG_SET(MUX[cfg->opp_id], 0, MPC_OUT_MUX, mpcc_id);
+
+	} else if (position == tree_cfg->num_pipes) {
+		/* idle dpp/mpcc is added to the bottom layer of tree */
 
-	if (cfg->z_index > 0) {
-		int top_mpcc_id = cfg->opp->mpc_tree.mpcc[cfg->z_index - 1];
+		/* get instance of previous bottom mpcc, set to middle layer */
+		int prev_bot_mpcc_id = tree_cfg->mpcc[tree_cfg->num_pipes - 1];
 
-		REG_SET(MPCC_BOT_SEL[top_mpcc_id], 0,
+		REG_SET(MPCC_BOT_SEL[prev_bot_mpcc_id], 0,
 				MPCC_BOT_SEL, mpcc_id);
-		REG_UPDATE(MPCC_CONTROL[top_mpcc_id],
+		REG_UPDATE(MPCC_CONTROL[prev_bot_mpcc_id],
 				MPCC_MODE, MODE_BLEND);
-	} else
-		REG_SET(MUX[cfg->opp->inst], 0, MPC_OUT_MUX, mpcc_id);
 
-	if (cfg->z_index < cfg->opp->mpc_tree.num_pipes) {
-		int bot_mpcc_id = cfg->opp->mpc_tree.mpcc[cfg->z_index];
+		/* mpcc_id become new bottom mpcc*/
+		REG_SET(MPCC_BOT_SEL[mpcc_id], 0,
+				MPCC_BOT_SEL, 0xf);
+
+	} else {
+		/* idle dpp/mpcc is added to middle of tree */
+		int above_mpcc_id = tree_cfg->mpcc[position - 1];
+		int below_mpcc_id = tree_cfg->mpcc[position];
+
+		/* mpcc above new mpcc_id has new bottom mux*/
+		REG_SET(MPCC_BOT_SEL[above_mpcc_id], 0,
+				MPCC_BOT_SEL, mpcc_id);
+		REG_UPDATE(MPCC_CONTROL[above_mpcc_id],
+				MPCC_MODE, MODE_BLEND);
 
+		/* mpcc_id bottom mux is from below mpcc*/
 		REG_SET(MPCC_BOT_SEL[mpcc_id], 0,
-				MPCC_BOT_SEL, bot_mpcc_id);
+				MPCC_BOT_SEL, below_mpcc_id);
 		mpcc_mode = MODE_BLEND;
 	}
 
@@ -234,18 +255,50 @@ static void mpc10_mpcc_add(struct mpc *mpc, struct mpcc_cfg *cfg)
 		MPCC_ALPHA_MULTIPLIED_MODE, cfg->pre_multiplied_alpha,
 		MPCC_BLND_ACTIVE_OVERLAP_ONLY, false);
 
+	/* update mpc_tree_cfg with new mpcc */
+	for (z_idx = tree_cfg->num_pipes; z_idx > position; z_idx--) {
+		tree_cfg->dpp[z_idx] = tree_cfg->dpp[z_idx - 1];
+		tree_cfg->mpcc[z_idx] = tree_cfg->mpcc[z_idx - 1];
+	}
+	tree_cfg->dpp[position] = cfg->dpp_id;
+	tree_cfg->mpcc[position] = mpcc_id;
+	tree_cfg->num_pipes++;
+}
+
+static int mpc10_mpcc_add(struct mpc *mpc, struct mpcc_cfg *cfg)
+{
+	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
+	int mpcc_id, z_idx;
+
+	ASSERT(cfg->z_index < mpc10->num_mpcc);
+
+	/* check in dpp already exists in mpc tree */
+	for (z_idx = 0; z_idx < cfg->tree_cfg->num_pipes; z_idx++)
+		if (cfg->tree_cfg->dpp[z_idx] == cfg->dpp_id)
+			break;
+	if (z_idx == cfg->tree_cfg->num_pipes) {
+		ASSERT(cfg->z_index <= cfg->tree_cfg->num_pipes);
+		mpcc_id = mpc10_get_idle_mpcc_id(mpc10);
+		ASSERT(!(mpc10->mpcc_in_use_mask & 1 << mpcc_id));
+
+		if (mpc->ctx->dc->debug.sanity_checks)
+			mpc10_assert_mpcc_idle_before_connect(mpc10, mpcc_id);
+	} else {
+		ASSERT(cfg->z_index < cfg->tree_cfg->num_pipes);
+		mpcc_id = cfg->tree_cfg->mpcc[z_idx];
+		mpc10_mpcc_remove(mpc, cfg->tree_cfg, cfg->opp_id, cfg->dpp_id);
+	}
+
+	/* add dpp/mpcc pair to mpc_tree_cfg and update mpcc registers */
+	mpc10_add_to_tree_cfg(mpc, cfg, mpcc_id);
+
+	/* set background color */
 	mpc10_set_bg_color(mpc10, &cfg->black_color, mpcc_id);
 
+	/* mark this mpcc as in use */
 	mpc10->mpcc_in_use_mask |= 1 << mpcc_id;
-	for (z_idx = cfg->opp->mpc_tree.num_pipes; z_idx > cfg->z_index; z_idx--) {
-		cfg->opp->mpc_tree.dpp[z_idx] = cfg->opp->mpc_tree.dpp[z_idx - 1];
-		cfg->opp->mpc_tree.mpcc[z_idx] = cfg->opp->mpc_tree.mpcc[z_idx - 1];
-	}
-	cfg->opp->mpc_tree.dpp[cfg->z_index] = cfg->mi->inst;
-	cfg->opp->mpc_tree.mpcc[cfg->z_index] = mpcc_id;
-	cfg->opp->mpc_tree.num_pipes++;
-	cfg->mi->opp_id = cfg->opp->inst;
-	cfg->mi->mpcc_id = mpcc_id;
+
+	return mpcc_id;
 }
 
 const struct mpc_funcs dcn10_mpc_funcs = {

commit d1423e6faf161e69070dbb1d6764dd5da59563a8
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Aug 22 15:03:06 2017 -0400

    drm/amd/display: Remove mpc from bios left over, keep double buffer disabled.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index ce408ccb428e..082b39a65e6a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -127,10 +127,18 @@ static void mpc10_mpcc_remove(
 	for (z_idx = 0; z_idx < opp->mpc_tree.num_pipes; z_idx++)
 		if (opp->mpc_tree.dpp[z_idx] == dpp_id)
 			break;
+
 	if (z_idx == opp->mpc_tree.num_pipes) {
-		ASSERT(0);
+		/* In case of resume from S3/S4, remove mpcc from bios left over */
+		REG_SET(MPCC_OPP_ID[dpp_id], 0,
+				MPCC_OPP_ID, 0xf);
+		REG_SET(MPCC_TOP_SEL[dpp_id], 0,
+				MPCC_TOP_SEL, 0xf);
+		REG_SET(MPCC_BOT_SEL[dpp_id], 0,
+				MPCC_BOT_SEL, 0xf);
 		return;
 	}
+
 	mpcc_id = opp->mpc_tree.mpcc[z_idx];
 
 	REG_SET(MPCC_OPP_ID[mpcc_id], 0,

commit b823defeb73aa8737006abe73844fd697ecf6983
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jul 28 08:16:27 2017 -0400

    drm/amd/display: Fixed mpc add, enable always scaler for video surface.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 52f2f2dd9a43..ce408ccb428e 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -229,9 +229,9 @@ static void mpc10_mpcc_add(struct mpc *mpc, struct mpcc_cfg *cfg)
 	mpc10_set_bg_color(mpc10, &cfg->black_color, mpcc_id);
 
 	mpc10->mpcc_in_use_mask |= 1 << mpcc_id;
-	for (z_idx = cfg->z_index; z_idx < cfg->opp->mpc_tree.num_pipes; z_idx++) {
-		cfg->opp->mpc_tree.dpp[z_idx + 1] = cfg->opp->mpc_tree.dpp[z_idx];
-		cfg->opp->mpc_tree.mpcc[z_idx + 1] = cfg->opp->mpc_tree.mpcc[z_idx];
+	for (z_idx = cfg->opp->mpc_tree.num_pipes; z_idx > cfg->z_index; z_idx--) {
+		cfg->opp->mpc_tree.dpp[z_idx] = cfg->opp->mpc_tree.dpp[z_idx - 1];
+		cfg->opp->mpc_tree.mpcc[z_idx] = cfg->opp->mpc_tree.mpcc[z_idx - 1];
 	}
 	cfg->opp->mpc_tree.dpp[cfg->z_index] = cfg->mi->inst;
 	cfg->opp->mpc_tree.mpcc[cfg->z_index] = mpcc_id;

commit 8a5d82451e297fc3864bb9ab0247b53c7ab8a022
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Thu Aug 3 21:23:04 2017 -0400

    drm/amd/display: use some sensible time out
    
    40s time out is not sensible.
    
    also make all udelay poll happen more frequently since CPU is busy anyways
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 036f161ab1c1..52f2f2dd9a43 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -72,7 +72,7 @@ static void mpc10_assert_idle_mpcc(struct mpc *mpc, int id)
 	ASSERT(!(mpc10->mpcc_in_use_mask & 1 << id));
 	REG_WAIT(MPCC_STATUS[id],
 			MPCC_IDLE, 1,
-			1000, 1000);
+			1, 100000);
 }
 
 static int mpc10_get_idle_mpcc_id(struct dcn10_mpc *mpc10)

commit cd273548e4f96508c97e5325ce0f5301aa2e3ad5
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jul 26 17:01:06 2017 -0400

    drm/amd/display: fix mpcc idle wait
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 246b60a16521..036f161ab1c1 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -71,7 +71,7 @@ static void mpc10_assert_idle_mpcc(struct mpc *mpc, int id)
 
 	ASSERT(!(mpc10->mpcc_in_use_mask & 1 << id));
 	REG_WAIT(MPCC_STATUS[id],
-			MPCC_BUSY, 0,
+			MPCC_IDLE, 1,
 			1000, 1000);
 }
 

commit cc408d726c20f32e4fdd688f870dd2b17960d4a2
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jul 21 17:46:50 2017 -0400

    drm/amd/display: mpc block redesign
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 9af288167e2e..246b60a16521 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -26,16 +26,17 @@
 #include "reg_helper.h"
 #include "dcn10_mpc.h"
 #include "dc.h"
+#include "mem_input.h"
 
 #define REG(reg)\
-	mpcc10->mpcc_regs->reg
+	mpc10->mpc_regs->reg
 
 #define CTX \
-	mpcc10->base.ctx
+	mpc10->base.ctx
 
 #undef FN
 #define FN(reg_name, field_name) \
-	mpcc10->mpcc_shift->field_name, mpcc10->mpcc_mask->field_name
+	mpc10->mpc_shift->field_name, mpc10->mpc_mask->field_name
 
 #define MODE_TOP_ONLY 1
 #define MODE_BLEND 3
@@ -43,11 +44,11 @@
 #define BLND_GLOBAL_ALPHA 2
 
 
-void dcn10_mpcc_set_bg_color(
-		struct mpcc *mpcc,
-		struct tg_color *bg_color)
+static void mpc10_set_bg_color(
+		struct dcn10_mpc *mpc10,
+		struct tg_color *bg_color,
+		int id)
 {
-	struct dcn10_mpcc *mpcc10 = TO_DCN10_MPCC(mpcc);
 	/* mpc color is 12 bit.  tg_color is 10 bit */
 	/* todo: might want to use 16 bit to represent color and have each
 	 * hw block translate to correct color depth.
@@ -56,113 +57,210 @@ void dcn10_mpcc_set_bg_color(
 	uint32_t bg_g_y = bg_color->color_g_y << 2;
 	uint32_t bg_b_cb = bg_color->color_b_cb << 2;
 
-	REG_SET(MPCC_BG_R_CR, 0,
+	REG_SET(MPCC_BG_R_CR[id], 0,
 			MPCC_BG_R_CR, bg_r_cr);
-	REG_SET(MPCC_BG_G_Y, 0,
+	REG_SET(MPCC_BG_G_Y[id], 0,
 			MPCC_BG_G_Y, bg_g_y);
-	REG_SET(MPCC_BG_B_CB, 0,
+	REG_SET(MPCC_BG_B_CB[id], 0,
 			MPCC_BG_B_CB, bg_b_cb);
 }
 
-static void set_output_mux(struct dcn10_mpcc *mpcc10, int opp_id, int mpcc_id)
+static void mpc10_assert_idle_mpcc(struct mpc *mpc, int id)
 {
-	ASSERT(mpcc10->base.opp_id == 0xf || opp_id == mpcc10->base.opp_id);
-	mpcc10->base.opp_id = opp_id;
-	REG_SET(MUX[opp_id], 0, MPC_OUT_MUX, mpcc_id);
+	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
+
+	ASSERT(!(mpc10->mpcc_in_use_mask & 1 << id));
+	REG_WAIT(MPCC_STATUS[id],
+			MPCC_BUSY, 0,
+			1000, 1000);
 }
 
-static void reset_output_mux(struct dcn10_mpcc *mpcc10)
+static int mpc10_get_idle_mpcc_id(struct dcn10_mpc *mpc10)
 {
-	REG_SET(MUX[mpcc10->base.opp_id], 0, MPC_OUT_MUX, 0xf);
-	mpcc10->base.opp_id = 0xf;
+	int i;
+	int last_free_mpcc_id = -1;
+
+	for (i = 0; i < mpc10->num_mpcc; i++) {
+		uint32_t is_idle = 0;
+
+		if (mpc10->mpcc_in_use_mask & 1 << i)
+			continue;
+
+		last_free_mpcc_id = i;
+		REG_GET(MPCC_STATUS[i], MPCC_IDLE, &is_idle);
+		if (is_idle)
+			return i;
+	}
+
+	/* This assert should never trigger, we have mpcc leak if it does */
+	ASSERT(last_free_mpcc_id != -1);
+
+	mpc10_assert_idle_mpcc(&mpc10->base, last_free_mpcc_id);
+	return last_free_mpcc_id;
 }
 
-static void assert_mpcc_idle_before_connect(struct dcn10_mpcc *mpcc10)
+static void mpc10_assert_mpcc_idle_before_connect(struct dcn10_mpc *mpc10, int id)
 {
-	unsigned int top_sel;
-	unsigned int mpcc_busy, mpcc_idle, mpcc_status;
+	unsigned int top_sel, mpc_busy, mpc_idle;
 
-	REG_GET(MPCC_TOP_SEL,
+	REG_GET(MPCC_TOP_SEL[id],
 			MPCC_TOP_SEL, &top_sel);
 
 	if (top_sel == 0xf) {
-		mpcc_status = REG_GET_2(MPCC_STATUS,
-				MPCC_BUSY, &mpcc_busy,
-				MPCC_IDLE, &mpcc_idle);
+		REG_GET_2(MPCC_STATUS[id],
+				MPCC_BUSY, &mpc_busy,
+				MPCC_IDLE, &mpc_idle);
+
+		ASSERT(mpc_busy == 0);
+		ASSERT(mpc_idle == 1);
+	}
+}
+
+static void mpc10_mpcc_remove(
+		struct mpc *mpc,
+		struct output_pixel_processor *opp,
+		int dpp_id)
+{
+	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
+	int mpcc_id, z_idx;
+
+	for (z_idx = 0; z_idx < opp->mpc_tree.num_pipes; z_idx++)
+		if (opp->mpc_tree.dpp[z_idx] == dpp_id)
+			break;
+	if (z_idx == opp->mpc_tree.num_pipes) {
+		ASSERT(0);
+		return;
+	}
+	mpcc_id = opp->mpc_tree.mpcc[z_idx];
+
+	REG_SET(MPCC_OPP_ID[mpcc_id], 0,
+			MPCC_OPP_ID, 0xf);
+	REG_SET(MPCC_TOP_SEL[mpcc_id], 0,
+			MPCC_TOP_SEL, 0xf);
+	REG_SET(MPCC_BOT_SEL[mpcc_id], 0,
+			MPCC_BOT_SEL, 0xf);
 
-		ASSERT(mpcc_busy == 0);
-		ASSERT(mpcc_idle == 1);
+	if (z_idx > 0) {
+		int top_mpcc_id = opp->mpc_tree.mpcc[z_idx - 1];
+
+		if (z_idx + 1 < opp->mpc_tree.num_pipes)
+			REG_SET(MPCC_BOT_SEL[top_mpcc_id], 0,
+					MPCC_BOT_SEL, opp->mpc_tree.mpcc[z_idx + 1]);
+		else {
+			REG_SET(MPCC_BOT_SEL[top_mpcc_id], 0,
+					MPCC_BOT_SEL, 0xf);
+			REG_UPDATE(MPCC_CONTROL[top_mpcc_id],
+					MPCC_MODE, MODE_TOP_ONLY);
+		}
+	} else if (opp->mpc_tree.num_pipes > 1)
+		REG_SET(MUX[opp->inst], 0,
+				MPC_OUT_MUX, opp->mpc_tree.mpcc[z_idx + 1]);
+	else
+		REG_SET(MUX[opp->inst], 0, MPC_OUT_MUX, 0xf);
+
+	mpc10->mpcc_in_use_mask &= ~(1 << mpcc_id);
+	opp->mpc_tree.num_pipes--;
+	for (; z_idx < opp->mpc_tree.num_pipes; z_idx++) {
+		opp->mpc_tree.dpp[z_idx] = opp->mpc_tree.dpp[z_idx + 1];
+		opp->mpc_tree.mpcc[z_idx] = opp->mpc_tree.mpcc[z_idx + 1];
 	}
+	opp->mpc_tree.dpp[opp->mpc_tree.num_pipes] = 0xdeadbeef;
+	opp->mpc_tree.mpcc[opp->mpc_tree.num_pipes] = 0xdeadbeef;
 }
 
-static void dcn10_mpcc_set(struct mpcc *mpcc, struct mpcc_cfg *cfg)
+static void mpc10_mpcc_add(struct mpc *mpc, struct mpcc_cfg *cfg)
 {
-	struct dcn10_mpcc *mpcc10 = TO_DCN10_MPCC(mpcc);
+	struct dcn10_mpc *mpc10 = TO_DCN10_MPC(mpc);
 	int alpha_blnd_mode = cfg->per_pixel_alpha ?
 			BLND_PP_ALPHA : BLND_GLOBAL_ALPHA;
-	int mpcc_mode = cfg->bot_mpcc_id != 0xf ?
-				MODE_BLEND : MODE_TOP_ONLY;
-	bool blend_active_only = cfg->top_of_tree &&
-			!mpcc->ctx->dc->debug.surface_visual_confirm;
+	int mpcc_mode = MODE_TOP_ONLY;
+	int mpcc_id, z_idx;
+
+	ASSERT(cfg->z_index < mpc10->num_mpcc);
 
-	if (mpcc->ctx->dc->debug.sanity_checks)
-		assert_mpcc_idle_before_connect(mpcc10);
+	for (z_idx = 0; z_idx < cfg->opp->mpc_tree.num_pipes; z_idx++)
+		if (cfg->opp->mpc_tree.dpp[z_idx] == cfg->mi->inst)
+			break;
+	if (z_idx == cfg->opp->mpc_tree.num_pipes) {
+		ASSERT(cfg->z_index <= cfg->opp->mpc_tree.num_pipes);
+		mpcc_id = mpc10_get_idle_mpcc_id(mpc10);
+		/*todo: remove hack*/
+		mpcc_id = cfg->mi->inst;
+		ASSERT(!(mpc10->mpcc_in_use_mask & 1 << mpcc_id));
+
+		if (mpc->ctx->dc->debug.sanity_checks)
+			mpc10_assert_mpcc_idle_before_connect(mpc10, mpcc_id);
+	} else {
+		ASSERT(cfg->z_index < cfg->opp->mpc_tree.num_pipes);
+		mpcc_id = cfg->opp->mpc_tree.mpcc[z_idx];
+		mpc10_mpcc_remove(mpc, cfg->opp, cfg->mi->inst);
+	}
 
-	REG_SET(MPCC_OPP_ID, 0,
-		MPCC_OPP_ID, cfg->opp_id);
+	REG_SET(MPCC_OPP_ID[mpcc_id], 0,
+			MPCC_OPP_ID, cfg->opp->inst);
 
-	REG_SET(MPCC_TOP_SEL, 0,
-		MPCC_TOP_SEL, cfg->top_dpp_id);
+	REG_SET(MPCC_TOP_SEL[mpcc_id], 0,
+			MPCC_TOP_SEL, cfg->mi->inst);
 
-	REG_SET(MPCC_BOT_SEL, 0,
-		MPCC_BOT_SEL, cfg->bot_mpcc_id);
+	if (cfg->z_index > 0) {
+		int top_mpcc_id = cfg->opp->mpc_tree.mpcc[cfg->z_index - 1];
+
+		REG_SET(MPCC_BOT_SEL[top_mpcc_id], 0,
+				MPCC_BOT_SEL, mpcc_id);
+		REG_UPDATE(MPCC_CONTROL[top_mpcc_id],
+				MPCC_MODE, MODE_BLEND);
+	} else
+		REG_SET(MUX[cfg->opp->inst], 0, MPC_OUT_MUX, mpcc_id);
+
+	if (cfg->z_index < cfg->opp->mpc_tree.num_pipes) {
+		int bot_mpcc_id = cfg->opp->mpc_tree.mpcc[cfg->z_index];
+
+		REG_SET(MPCC_BOT_SEL[mpcc_id], 0,
+				MPCC_BOT_SEL, bot_mpcc_id);
+		mpcc_mode = MODE_BLEND;
+	}
 
-	REG_SET_4(MPCC_CONTROL, 0xffffffff,
+	REG_SET_4(MPCC_CONTROL[mpcc_id], 0xffffffff,
 		MPCC_MODE, mpcc_mode,
 		MPCC_ALPHA_BLND_MODE, alpha_blnd_mode,
 		MPCC_ALPHA_MULTIPLIED_MODE, cfg->pre_multiplied_alpha,
-		MPCC_BLND_ACTIVE_OVERLAP_ONLY, blend_active_only);
+		MPCC_BLND_ACTIVE_OVERLAP_ONLY, false);
 
-	if (cfg->top_of_tree) {
-		if (cfg->opp_id != 0xf)
-			set_output_mux(mpcc10, cfg->opp_id, mpcc->inst);
-		else if (mpcc->opp_id != 0xf)
-			reset_output_mux(mpcc10);
-	}
-	mpcc10->base.opp_id = cfg->opp_id;
-}
-
-static void dcn10_mpcc_wait_idle(struct mpcc *mpcc)
-{
-	struct dcn10_mpcc *mpcc10 = TO_DCN10_MPCC(mpcc);
+	mpc10_set_bg_color(mpc10, &cfg->black_color, mpcc_id);
 
-	REG_WAIT(MPCC_STATUS,
-			MPCC_BUSY, 0,
-			1000, 1000);
+	mpc10->mpcc_in_use_mask |= 1 << mpcc_id;
+	for (z_idx = cfg->z_index; z_idx < cfg->opp->mpc_tree.num_pipes; z_idx++) {
+		cfg->opp->mpc_tree.dpp[z_idx + 1] = cfg->opp->mpc_tree.dpp[z_idx];
+		cfg->opp->mpc_tree.mpcc[z_idx + 1] = cfg->opp->mpc_tree.mpcc[z_idx];
+	}
+	cfg->opp->mpc_tree.dpp[cfg->z_index] = cfg->mi->inst;
+	cfg->opp->mpc_tree.mpcc[cfg->z_index] = mpcc_id;
+	cfg->opp->mpc_tree.num_pipes++;
+	cfg->mi->opp_id = cfg->opp->inst;
+	cfg->mi->mpcc_id = mpcc_id;
 }
 
-
-const struct mpcc_funcs dcn10_mpcc_funcs = {
-		.set = dcn10_mpcc_set,
-		.wait_for_idle = dcn10_mpcc_wait_idle,
-		.set_bg_color = dcn10_mpcc_set_bg_color,
+const struct mpc_funcs dcn10_mpc_funcs = {
+		.add = mpc10_mpcc_add,
+		.remove = mpc10_mpcc_remove,
+		.wait_for_idle = mpc10_assert_idle_mpcc
 };
 
-void dcn10_mpcc_construct(struct dcn10_mpcc *mpcc10,
+void dcn10_mpc_construct(struct dcn10_mpc *mpc10,
 	struct dc_context *ctx,
-	const struct dcn_mpcc_registers *mpcc_regs,
-	const struct dcn_mpcc_shift *mpcc_shift,
-	const struct dcn_mpcc_mask *mpcc_mask,
-	int inst)
+	const struct dcn_mpc_registers *mpc_regs,
+	const struct dcn_mpc_shift *mpc_shift,
+	const struct dcn_mpc_mask *mpc_mask,
+	int num_mpcc)
 {
-	mpcc10->base.ctx = ctx;
+	mpc10->base.ctx = ctx;
 
-	mpcc10->base.inst = inst;
-	mpcc10->base.funcs = &dcn10_mpcc_funcs;
+	mpc10->base.funcs = &dcn10_mpc_funcs;
 
-	mpcc10->mpcc_regs = mpcc_regs;
-	mpcc10->mpcc_shift = mpcc_shift;
-	mpcc10->mpcc_mask = mpcc_mask;
+	mpc10->mpc_regs = mpc_regs;
+	mpc10->mpc_shift = mpc_shift;
+	mpc10->mpc_mask = mpc_mask;
 
-	mpcc10->base.opp_id = inst;
+	mpc10->mpcc_in_use_mask = 0;
+	mpc10->num_mpcc = num_mpcc;
 }

commit 2b13d7d380d50811fd4fc022d135c3c5bb70a418
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Fri Jul 14 14:07:16 2017 -0400

    drm/amd/display: mpo debug sanity checks
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index de3341d572be..9af288167e2e 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -77,6 +77,24 @@ static void reset_output_mux(struct dcn10_mpcc *mpcc10)
 	mpcc10->base.opp_id = 0xf;
 }
 
+static void assert_mpcc_idle_before_connect(struct dcn10_mpcc *mpcc10)
+{
+	unsigned int top_sel;
+	unsigned int mpcc_busy, mpcc_idle, mpcc_status;
+
+	REG_GET(MPCC_TOP_SEL,
+			MPCC_TOP_SEL, &top_sel);
+
+	if (top_sel == 0xf) {
+		mpcc_status = REG_GET_2(MPCC_STATUS,
+				MPCC_BUSY, &mpcc_busy,
+				MPCC_IDLE, &mpcc_idle);
+
+		ASSERT(mpcc_busy == 0);
+		ASSERT(mpcc_idle == 1);
+	}
+}
+
 static void dcn10_mpcc_set(struct mpcc *mpcc, struct mpcc_cfg *cfg)
 {
 	struct dcn10_mpcc *mpcc10 = TO_DCN10_MPCC(mpcc);
@@ -87,6 +105,9 @@ static void dcn10_mpcc_set(struct mpcc *mpcc, struct mpcc_cfg *cfg)
 	bool blend_active_only = cfg->top_of_tree &&
 			!mpcc->ctx->dc->debug.surface_visual_confirm;
 
+	if (mpcc->ctx->dc->debug.sanity_checks)
+		assert_mpcc_idle_before_connect(mpcc10);
+
 	REG_SET(MPCC_OPP_ID, 0,
 		MPCC_OPP_ID, cfg->opp_id);
 

commit d21becbe0225de0e2582d17d4fbc73fbd103b1f7
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Wed Jul 12 11:54:10 2017 -0400

    drm/amd/display: avoid disabling opp clk before hubp is blanked.
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 9875d812e185..de3341d572be 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -68,14 +68,12 @@ static void set_output_mux(struct dcn10_mpcc *mpcc10, int opp_id, int mpcc_id)
 {
 	ASSERT(mpcc10->base.opp_id == 0xf || opp_id == mpcc10->base.opp_id);
 	mpcc10->base.opp_id = opp_id;
-	REG_UPDATE(OPP_PIPE_CONTROL[opp_id], OPP_PIPE_CLOCK_EN, 1);
 	REG_SET(MUX[opp_id], 0, MPC_OUT_MUX, mpcc_id);
 }
 
 static void reset_output_mux(struct dcn10_mpcc *mpcc10)
 {
 	REG_SET(MUX[mpcc10->base.opp_id], 0, MPC_OUT_MUX, 0xf);
-	REG_UPDATE(OPP_PIPE_CONTROL[mpcc10->base.opp_id], OPP_PIPE_CLOCK_EN, 0);
 	mpcc10->base.opp_id = 0xf;
 }
 

commit 189f73e32e9a7fc5ac62f244b66f8b41a78803c7
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Wed Jul 12 09:02:54 2017 -0400

    drm/amd/display: change order of HUBP and MPC disable according to HW guide
    
    blank hubp first before disconnect MPC
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 1c9d5e96ab55..9875d812e185 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -117,7 +117,9 @@ static void dcn10_mpcc_wait_idle(struct mpcc *mpcc)
 {
 	struct dcn10_mpcc *mpcc10 = TO_DCN10_MPCC(mpcc);
 
-	REG_WAIT(MPCC_STATUS, MPCC_BUSY, 0, 1000, 1000);
+	REG_WAIT(MPCC_STATUS,
+			MPCC_BUSY, 0,
+			1000, 1000);
 }
 
 

commit 87449a90c2545eaed5757153770346563378463b
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Jul 6 14:27:49 2017 -0400

    drm/amd/display: Fix MPO visual confirm
    
    1. Need to blend non-active area to show visual confirm borders
    2. Set number of Visual Confirm lines based on pipe instance
    3. Set Different colors representing surface format of bottom most plan
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 7af04bce3599..1c9d5e96ab55 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -25,6 +25,7 @@
 
 #include "reg_helper.h"
 #include "dcn10_mpc.h"
+#include "dc.h"
 
 #define REG(reg)\
 	mpcc10->mpcc_regs->reg
@@ -85,6 +86,8 @@ static void dcn10_mpcc_set(struct mpcc *mpcc, struct mpcc_cfg *cfg)
 			BLND_PP_ALPHA : BLND_GLOBAL_ALPHA;
 	int mpcc_mode = cfg->bot_mpcc_id != 0xf ?
 				MODE_BLEND : MODE_TOP_ONLY;
+	bool blend_active_only = cfg->top_of_tree &&
+			!mpcc->ctx->dc->debug.surface_visual_confirm;
 
 	REG_SET(MPCC_OPP_ID, 0,
 		MPCC_OPP_ID, cfg->opp_id);
@@ -99,7 +102,7 @@ static void dcn10_mpcc_set(struct mpcc *mpcc, struct mpcc_cfg *cfg)
 		MPCC_MODE, mpcc_mode,
 		MPCC_ALPHA_BLND_MODE, alpha_blnd_mode,
 		MPCC_ALPHA_MULTIPLIED_MODE, cfg->pre_multiplied_alpha,
-		MPCC_BLND_ACTIVE_OVERLAP_ONLY, cfg->top_of_tree);
+		MPCC_BLND_ACTIVE_OVERLAP_ONLY, blend_active_only);
 
 	if (cfg->top_of_tree) {
 		if (cfg->opp_id != 0xf)

commit cfe4645e17f8dbe680c35c439d000313f2648482
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jun 14 18:58:04 2017 -0400

    drm/amd/display: fix dcn pipe reset sequence
    
    This change fixes dcn10 front end reset sequence. Previously we
    would reset front end during flip which led to issues
    in certain MPO and 4k/5k scenarios. We would also never properly
    power gate our front end.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index b1c590d4f454..7af04bce3599 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -65,17 +65,17 @@ void dcn10_mpcc_set_bg_color(
 
 static void set_output_mux(struct dcn10_mpcc *mpcc10, int opp_id, int mpcc_id)
 {
-	ASSERT(mpcc10->opp_id == 0xf || opp_id == mpcc10->opp_id);
-	mpcc10->opp_id = opp_id;
+	ASSERT(mpcc10->base.opp_id == 0xf || opp_id == mpcc10->base.opp_id);
+	mpcc10->base.opp_id = opp_id;
 	REG_UPDATE(OPP_PIPE_CONTROL[opp_id], OPP_PIPE_CLOCK_EN, 1);
 	REG_SET(MUX[opp_id], 0, MPC_OUT_MUX, mpcc_id);
 }
 
 static void reset_output_mux(struct dcn10_mpcc *mpcc10)
 {
-	REG_SET(MUX[mpcc10->opp_id], 0, MPC_OUT_MUX, 0xf);
-	REG_UPDATE(OPP_PIPE_CONTROL[mpcc10->opp_id], OPP_PIPE_CLOCK_EN, 0);
-	mpcc10->opp_id = 0xf;
+	REG_SET(MUX[mpcc10->base.opp_id], 0, MPC_OUT_MUX, 0xf);
+	REG_UPDATE(OPP_PIPE_CONTROL[mpcc10->base.opp_id], OPP_PIPE_CLOCK_EN, 0);
+	mpcc10->base.opp_id = 0xf;
 }
 
 static void dcn10_mpcc_set(struct mpcc *mpcc, struct mpcc_cfg *cfg)
@@ -104,16 +104,17 @@ static void dcn10_mpcc_set(struct mpcc *mpcc, struct mpcc_cfg *cfg)
 	if (cfg->top_of_tree) {
 		if (cfg->opp_id != 0xf)
 			set_output_mux(mpcc10, cfg->opp_id, mpcc->inst);
-		else
+		else if (mpcc->opp_id != 0xf)
 			reset_output_mux(mpcc10);
 	}
+	mpcc10->base.opp_id = cfg->opp_id;
 }
 
 static void dcn10_mpcc_wait_idle(struct mpcc *mpcc)
 {
 	struct dcn10_mpcc *mpcc10 = TO_DCN10_MPCC(mpcc);
 
-	REG_WAIT(MPCC_STATUS, MPCC_IDLE, 1, 1000, 1000);
+	REG_WAIT(MPCC_STATUS, MPCC_BUSY, 0, 1000, 1000);
 }
 
 
@@ -139,5 +140,5 @@ void dcn10_mpcc_construct(struct dcn10_mpcc *mpcc10,
 	mpcc10->mpcc_shift = mpcc_shift;
 	mpcc10->mpcc_mask = mpcc_mask;
 
-	mpcc10->opp_id = inst;
+	mpcc10->base.opp_id = inst;
 }

commit ad32734699da4dd185405637459bf915a4f4cff6
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Jun 5 15:08:10 2017 -0400

    drm/amd/display: w/a for ycbcr output pre-multiplied alpha corruption
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 19af0ee86191..b1c590d4f454 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -98,7 +98,7 @@ static void dcn10_mpcc_set(struct mpcc *mpcc, struct mpcc_cfg *cfg)
 	REG_SET_4(MPCC_CONTROL, 0xffffffff,
 		MPCC_MODE, mpcc_mode,
 		MPCC_ALPHA_BLND_MODE, alpha_blnd_mode,
-		MPCC_ALPHA_MULTIPLIED_MODE, 0/*TODO: cfg->per_pixel_alpha*/,
+		MPCC_ALPHA_MULTIPLIED_MODE, cfg->pre_multiplied_alpha,
 		MPCC_BLND_ACTIVE_OVERLAP_ONLY, cfg->top_of_tree);
 
 	if (cfg->top_of_tree) {

commit f0558542a72e72919dae2ac2187847ec312c2bcb
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Jun 1 18:35:54 2017 -0400

    drm/amd/display: redesign mpc
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index 58f80114e36b..19af0ee86191 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -27,34 +27,26 @@
 #include "dcn10_mpc.h"
 
 #define REG(reg)\
-	mpc->mpc_regs->reg
+	mpcc10->mpcc_regs->reg
 
 #define CTX \
-	mpc->base.ctx
+	mpcc10->base.ctx
 
 #undef FN
 #define FN(reg_name, field_name) \
-	mpc->mpc_shift->field_name, mpc->mpc_mask->field_name
+	mpcc10->mpcc_shift->field_name, mpcc10->mpcc_mask->field_name
 
 #define MODE_TOP_ONLY 1
 #define MODE_BLEND 3
+#define BLND_PP_ALPHA 0
+#define BLND_GLOBAL_ALPHA 2
 
-/* Internal function to set mpc output mux */
-static void set_output_mux(struct dcn10_mpc *mpc,
-	uint8_t opp_id,
-	uint8_t mpcc_id)
-{
-	if (mpcc_id != 0xf)
-		REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
-				OPP_PIPE_CLOCK_EN, 1);
-
-	REG_SET(MUX[opp_id], 0, MPC_OUT_MUX, mpcc_id);
-}
 
-void dcn10_set_mpc_background_color(struct dcn10_mpc *mpc,
-	unsigned int mpcc_inst,
-	struct tg_color *bg_color)
+void dcn10_mpcc_set_bg_color(
+		struct mpcc *mpcc,
+		struct tg_color *bg_color)
 {
+	struct dcn10_mpcc *mpcc10 = TO_DCN10_MPCC(mpcc);
 	/* mpc color is 12 bit.  tg_color is 10 bit */
 	/* todo: might want to use 16 bit to represent color and have each
 	 * hw block translate to correct color depth.
@@ -63,277 +55,89 @@ void dcn10_set_mpc_background_color(struct dcn10_mpc *mpc,
 	uint32_t bg_g_y = bg_color->color_g_y << 2;
 	uint32_t bg_b_cb = bg_color->color_b_cb << 2;
 
-	REG_SET(MPCC_BG_R_CR[mpcc_inst], 0,
+	REG_SET(MPCC_BG_R_CR, 0,
 			MPCC_BG_R_CR, bg_r_cr);
-	REG_SET(MPCC_BG_G_Y[mpcc_inst], 0,
+	REG_SET(MPCC_BG_G_Y, 0,
 			MPCC_BG_G_Y, bg_g_y);
-	REG_SET(MPCC_BG_B_CB[mpcc_inst], 0,
+	REG_SET(MPCC_BG_B_CB, 0,
 			MPCC_BG_B_CB, bg_b_cb);
 }
 
-/* This function programs MPC tree configuration
- * Assume it is the initial time to setup MPC tree_configure, means
- * the instance of dpp/mpcc/opp specified in structure tree_cfg are
- * in idle status.
- * Before invoke this function, ensure that master lock of OPTC specified
- * by opp_id is set.
- *
- * tree_cfg[in] - new MPC_TREE_CFG
- */
-
-void dcn10_set_mpc_tree(struct dcn10_mpc *mpc,
-	struct mpc_tree_cfg *tree_cfg)
+static void set_output_mux(struct dcn10_mpcc *mpcc10, int opp_id, int mpcc_id)
 {
-	int i;
-
-	for (i = 0; i < tree_cfg->num_pipes; i++) {
-		uint8_t mpcc_inst = tree_cfg->mpcc[i];
-
-		REG_SET(MPCC_OPP_ID[mpcc_inst], 0,
-			MPCC_OPP_ID, tree_cfg->opp_id);
-
-		REG_SET(MPCC_TOP_SEL[mpcc_inst], 0,
-			MPCC_TOP_SEL, tree_cfg->dpp[i]);
-
-		if (i == tree_cfg->num_pipes-1) {
-			REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
-				MPCC_BOT_SEL, 0xF);
-
-			REG_UPDATE(MPCC_CONTROL[mpcc_inst],
-					MPCC_MODE, MODE_TOP_ONLY);
-		} else {
-			REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
-				MPCC_BOT_SEL, tree_cfg->dpp[i+1]);
-
-			REG_UPDATE(MPCC_CONTROL[mpcc_inst],
-					MPCC_MODE, MODE_BLEND);
-		}
-
-		if (i == 0)
-			set_output_mux(
-				mpc, tree_cfg->opp_id, mpcc_inst);
-
-		REG_UPDATE_2(MPCC_CONTROL[mpcc_inst],
-				MPCC_ALPHA_BLND_MODE,
-				tree_cfg->per_pixel_alpha[i] ? 0 : 2,
-				MPCC_ALPHA_MULTIPLIED_MODE, 0);
-	}
+	ASSERT(mpcc10->opp_id == 0xf || opp_id == mpcc10->opp_id);
+	mpcc10->opp_id = opp_id;
+	REG_UPDATE(OPP_PIPE_CONTROL[opp_id], OPP_PIPE_CLOCK_EN, 1);
+	REG_SET(MUX[opp_id], 0, MPC_OUT_MUX, mpcc_id);
 }
 
-/*
- * This is the function to remove current MPC tree specified by tree_cfg
- * Before invoke this function, ensure that master lock of OPTC specified
- * by opp_id is set.
- *
- *tree_cfg[in/out] - current MPC_TREE_CFG
- */
-void dcn10_delete_mpc_tree(struct dcn10_mpc *mpc,
-	struct mpc_tree_cfg *tree_cfg)
+static void reset_output_mux(struct dcn10_mpcc *mpcc10)
 {
-	int i;
-
-	for (i = 0; i < tree_cfg->num_pipes; i++) {
-		uint8_t mpcc_inst = tree_cfg->mpcc[i];
-
-		REG_SET(MPCC_OPP_ID[mpcc_inst], 0,
-			MPCC_OPP_ID, 0xf);
-
-		REG_SET(MPCC_TOP_SEL[mpcc_inst], 0,
-			MPCC_TOP_SEL, 0xf);
-
-		REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
-			MPCC_BOT_SEL, 0xF);
-
-		/* add remove dpp/mpcc pair into pending list
-		 * TODO FPGA AddToPendingList if empty from pseudo code
-		 */
-		tree_cfg->dpp[i] = 0xf;
-		tree_cfg->mpcc[i] = 0xf;
-		tree_cfg->per_pixel_alpha[i] = false;
-	}
-	set_output_mux(mpc, tree_cfg->opp_id, 0xf);
-	tree_cfg->opp_id = 0xf;
-	tree_cfg->num_pipes = 0;
+	REG_SET(MUX[mpcc10->opp_id], 0, MPC_OUT_MUX, 0xf);
+	REG_UPDATE(OPP_PIPE_CONTROL[mpcc10->opp_id], OPP_PIPE_CLOCK_EN, 0);
+	mpcc10->opp_id = 0xf;
 }
 
-/* TODO FPGA: how to handle DPP?
- * Function to remove one of pipe from MPC configure tree by dpp idx
- * Before invoke this function, ensure that master lock of OPTC specified
- * by opp_id is set
- * This function can be invoke multiple times to remove more than 1 dpps.
- *
- * tree_cfg[in/out] - current MPC_TREE_CFG
- * idx[in] - index of dpp from tree_cfg to be removed.
- */
-bool dcn10_remove_dpp(struct dcn10_mpc *mpc,
-	struct mpc_tree_cfg *tree_cfg,
-	uint8_t idx)
+static void dcn10_mpcc_set(struct mpcc *mpcc, struct mpcc_cfg *cfg)
 {
-	int i;
-	uint8_t mpcc_inst;
-	bool found = false;
-
-	/* find dpp_idx from dpp array of tree_cfg */
-	for (i = 0; i < tree_cfg->num_pipes; i++) {
-		if (tree_cfg->dpp[i] == idx) {
-			found = true;
-			break;
-		}
-	}
-
-	if (!found) {
-		BREAK_TO_DEBUGGER();
-		return false;
-	}
-	mpcc_inst = tree_cfg->mpcc[i];
-
-	REG_SET(MPCC_OPP_ID[mpcc_inst], 0,
-			MPCC_OPP_ID, 0xf);
-
-	REG_SET(MPCC_TOP_SEL[mpcc_inst], 0,
-			MPCC_TOP_SEL, 0xf);
-
-	REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
-			MPCC_BOT_SEL, 0xf);
-
-	if (i == 0) {
-		if (tree_cfg->num_pipes > 1)
-			set_output_mux(mpc,
-				tree_cfg->opp_id, tree_cfg->mpcc[i+1]);
+	struct dcn10_mpcc *mpcc10 = TO_DCN10_MPCC(mpcc);
+	int alpha_blnd_mode = cfg->per_pixel_alpha ?
+			BLND_PP_ALPHA : BLND_GLOBAL_ALPHA;
+	int mpcc_mode = cfg->bot_mpcc_id != 0xf ?
+				MODE_BLEND : MODE_TOP_ONLY;
+
+	REG_SET(MPCC_OPP_ID, 0,
+		MPCC_OPP_ID, cfg->opp_id);
+
+	REG_SET(MPCC_TOP_SEL, 0,
+		MPCC_TOP_SEL, cfg->top_dpp_id);
+
+	REG_SET(MPCC_BOT_SEL, 0,
+		MPCC_BOT_SEL, cfg->bot_mpcc_id);
+
+	REG_SET_4(MPCC_CONTROL, 0xffffffff,
+		MPCC_MODE, mpcc_mode,
+		MPCC_ALPHA_BLND_MODE, alpha_blnd_mode,
+		MPCC_ALPHA_MULTIPLIED_MODE, 0/*TODO: cfg->per_pixel_alpha*/,
+		MPCC_BLND_ACTIVE_OVERLAP_ONLY, cfg->top_of_tree);
+
+	if (cfg->top_of_tree) {
+		if (cfg->opp_id != 0xf)
+			set_output_mux(mpcc10, cfg->opp_id, mpcc->inst);
 		else
-			set_output_mux(mpc, tree_cfg->opp_id, 0xf);
-	} else if (i == tree_cfg->num_pipes-1) {
-		mpcc_inst = tree_cfg->mpcc[i - 1];
-
-		REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
-				MPCC_BOT_SEL, 0xF);
-
-		/* prev mpc is now last, set to top only*/
-		REG_UPDATE(MPCC_CONTROL[mpcc_inst],
-				MPCC_MODE, MODE_TOP_ONLY);
-	} else {
-		mpcc_inst = tree_cfg->mpcc[i - 1];
-
-		REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
-			MPCC_BOT_SEL, tree_cfg->mpcc[i+1]);
+			reset_output_mux(mpcc10);
 	}
-
-	/* update tree_cfg structure */
-	while (i < tree_cfg->num_pipes - 1) {
-		tree_cfg->dpp[i] = tree_cfg->dpp[i+1];
-		tree_cfg->mpcc[i] = tree_cfg->mpcc[i+1];
-		tree_cfg->per_pixel_alpha[i] = tree_cfg->per_pixel_alpha[i+1];
-		i++;
-	}
-	tree_cfg->num_pipes--;
-
-	return true;
 }
 
-/* TODO FPGA: how to handle DPP?
- * Function to add DPP/MPCC pair into MPC configure tree by position.
- * Before invoke this function, ensure that master lock of OPTC specified
- * by opp_id is set
- * This function can be invoke multiple times to add more than 1 pipes.
- *
- * tree_cfg[in/out] - current MPC_TREE_CFG
- * dpp_idx[in]	 - index of an idle dpp insatnce to be added.
- * mpcc_idx[in]	 - index of an idle mpcc instance to be added.
- * poistion[in]	 - position of dpp/mpcc pair to be added into current tree_cfg
- *                 0 means insert to the most top layer of MPC tree
- */
-void dcn10_add_dpp(struct dcn10_mpc *mpc,
-	struct mpc_tree_cfg *tree_cfg,
-	uint8_t dpp_idx,
-	uint8_t mpcc_idx,
-	uint8_t per_pixel_alpha,
-	uint8_t position)
+static void dcn10_mpcc_wait_idle(struct mpcc *mpcc)
 {
-	uint8_t prev;
-	uint8_t next;
-
-	REG_SET(MPCC_OPP_ID[mpcc_idx], 0,
-			MPCC_OPP_ID, tree_cfg->opp_id);
-	REG_SET(MPCC_TOP_SEL[mpcc_idx], 0,
-			MPCC_TOP_SEL, dpp_idx);
-
-	if (position == 0) {
-		/* idle dpp/mpcc is added to the top layer of tree */
-		REG_SET(MPCC_BOT_SEL[mpcc_idx], 0,
-				MPCC_BOT_SEL, tree_cfg->mpcc[0]);
+	struct dcn10_mpcc *mpcc10 = TO_DCN10_MPCC(mpcc);
 
-		/* bottom mpc is always top only */
-		REG_UPDATE(MPCC_CONTROL[mpcc_idx],
-				MPCC_MODE, MODE_TOP_ONLY);
-		/* opp will get new output. from new added mpcc */
-		set_output_mux(mpc, tree_cfg->opp_id, mpcc_idx);
-
-	} else if (position == tree_cfg->num_pipes) {
-		/* idle dpp/mpcc is added to the bottom layer of tree */
-
-		/* get instance of previous bottom mpcc, set to middle layer */
-		prev = tree_cfg->mpcc[position - 1];
-
-		REG_SET(MPCC_BOT_SEL[prev], 0,
-				MPCC_BOT_SEL, mpcc_idx);
-
-		/* all mpcs other than bottom need to blend */
-		REG_UPDATE(MPCC_CONTROL[prev],
-				MPCC_MODE, MODE_BLEND);
-
-		/* mpcc_idx become new bottom mpcc*/
-		REG_SET(MPCC_BOT_SEL[mpcc_idx], 0,
-				MPCC_BOT_SEL, 0xf);
-
-		/* bottom mpc is always top only */
-		REG_UPDATE(MPCC_CONTROL[mpcc_idx],
-				MPCC_MODE, MODE_TOP_ONLY);
-	} else {
-		/* idle dpp/mpcc is added to middle of tree */
-		prev = tree_cfg->mpcc[position - 1]; /* mpc a */
-		next = tree_cfg->mpcc[position]; /* mpc b */
-
-		/* connect mpc inserted below mpc a*/
-		REG_SET(MPCC_BOT_SEL[prev], 0,
-				MPCC_BOT_SEL, mpcc_idx);
+	REG_WAIT(MPCC_STATUS, MPCC_IDLE, 1, 1000, 1000);
+}
 
-		/* blend on mpc being inserted */
-		REG_UPDATE(MPCC_CONTROL[mpcc_idx],
-				MPCC_MODE, MODE_BLEND);
 
-		/* Connect mpc b below one inserted */
-		REG_SET(MPCC_BOT_SEL[mpcc_idx], 0,
-				MPCC_BOT_SEL, next);
+const struct mpcc_funcs dcn10_mpcc_funcs = {
+		.set = dcn10_mpcc_set,
+		.wait_for_idle = dcn10_mpcc_wait_idle,
+		.set_bg_color = dcn10_mpcc_set_bg_color,
+};
 
-	}
-	/* premultiplied mode only if alpha is on for the layer*/
-	REG_UPDATE_2(MPCC_CONTROL[mpcc_idx],
-			MPCC_ALPHA_BLND_MODE,
-			tree_cfg->per_pixel_alpha[position] ? 0 : 2,
-			MPCC_ALPHA_MULTIPLIED_MODE, 0);
+void dcn10_mpcc_construct(struct dcn10_mpcc *mpcc10,
+	struct dc_context *ctx,
+	const struct dcn_mpcc_registers *mpcc_regs,
+	const struct dcn_mpcc_shift *mpcc_shift,
+	const struct dcn_mpcc_mask *mpcc_mask,
+	int inst)
+{
+	mpcc10->base.ctx = ctx;
 
-	/*
-	 * iterating from the last mpc/dpp pair to the one being added, shift
-	 * them down one position
-	 */
-	for (next = tree_cfg->num_pipes; next > position; next--) {
-		tree_cfg->dpp[next] = tree_cfg->dpp[next - 1];
-		tree_cfg->mpcc[next] = tree_cfg->mpcc[next - 1];
-		tree_cfg->per_pixel_alpha[next] = tree_cfg->per_pixel_alpha[next - 1];
-	}
+	mpcc10->base.inst = inst;
+	mpcc10->base.funcs = &dcn10_mpcc_funcs;
 
-	/* insert the new mpc/dpp pair into the tree_cfg*/
-	tree_cfg->dpp[position] = dpp_idx;
-	tree_cfg->mpcc[position] = mpcc_idx;
-	tree_cfg->per_pixel_alpha[position] = per_pixel_alpha;
-	tree_cfg->num_pipes++;
-}
+	mpcc10->mpcc_regs = mpcc_regs;
+	mpcc10->mpcc_shift = mpcc_shift;
+	mpcc10->mpcc_mask = mpcc_mask;
 
-void wait_mpcc_idle(struct dcn10_mpc *mpc,
-	uint8_t mpcc_id)
-{
-	REG_WAIT(MPCC_STATUS[mpcc_id],
-			MPCC_IDLE, 1,
-			1000, 1000);
+	mpcc10->opp_id = inst;
 }
-

commit 1a2c82a2f161f68deb5f0519c315bfc92ede8e01
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jun 2 19:00:45 2017 -0400

    drm/amd/display: fix mpc alpha programming
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
index cb22cd130e1a..58f80114e36b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -36,6 +36,9 @@
 #define FN(reg_name, field_name) \
 	mpc->mpc_shift->field_name, mpc->mpc_mask->field_name
 
+#define MODE_TOP_ONLY 1
+#define MODE_BLEND 3
+
 /* Internal function to set mpc output mux */
 static void set_output_mux(struct dcn10_mpc *mpc,
 	uint8_t opp_id,
@@ -45,32 +48,7 @@ static void set_output_mux(struct dcn10_mpc *mpc,
 		REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
 				OPP_PIPE_CLOCK_EN, 1);
 
-	REG_SET(MUX[opp_id], 0,
-			MPC_OUT_MUX, mpcc_id);
-
-/*	TODO: Move to post when ready.
-   if (mpcc_id == 0xf) {
-		MPCC_REG_UPDATE(OPP_PIPE0_OPP_PIPE_CONTROL,
-				OPP_PIPE_CLOCK_EN, 0);
-	}
-*/
-}
-
-static void set_blend_mode(struct dcn10_mpc *mpc,
-	enum blend_mode mode,
-	uint8_t mpcc_id)
-{
-	/* Enable per-pixel alpha on this pipe */
-	if (mode == TOP_BLND)
-		REG_UPDATE_3(MPCC_CONTROL[mpcc_id],
-				MPCC_ALPHA_BLND_MODE, 0,
-				MPCC_ALPHA_MULTIPLIED_MODE, 0,
-				MPCC_BLND_ACTIVE_OVERLAP_ONLY, 0);
-	else
-		REG_UPDATE_3(MPCC_CONTROL[mpcc_id],
-				MPCC_ALPHA_BLND_MODE, 0,
-				MPCC_ALPHA_MULTIPLIED_MODE, 1,
-				MPCC_BLND_ACTIVE_OVERLAP_ONLY, 1);
+	REG_SET(MUX[opp_id], 0, MPC_OUT_MUX, mpcc_id);
 }
 
 void dcn10_set_mpc_background_color(struct dcn10_mpc *mpc,
@@ -121,44 +99,27 @@ void dcn10_set_mpc_tree(struct dcn10_mpc *mpc,
 			REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
 				MPCC_BOT_SEL, 0xF);
 
-			/* MPCC_CONTROL->MPCC_MODE */
 			REG_UPDATE(MPCC_CONTROL[mpcc_inst],
-					MPCC_MODE, tree_cfg->mode);
+					MPCC_MODE, MODE_TOP_ONLY);
 		} else {
 			REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
 				MPCC_BOT_SEL, tree_cfg->dpp[i+1]);
 
-			/* MPCC_CONTROL->MPCC_MODE */
 			REG_UPDATE(MPCC_CONTROL[mpcc_inst],
-					MPCC_MODE, 3);
+					MPCC_MODE, MODE_BLEND);
 		}
 
 		if (i == 0)
 			set_output_mux(
 				mpc, tree_cfg->opp_id, mpcc_inst);
 
-		set_blend_mode(mpc, tree_cfg->mode, mpcc_inst);
+		REG_UPDATE_2(MPCC_CONTROL[mpcc_inst],
+				MPCC_ALPHA_BLND_MODE,
+				tree_cfg->per_pixel_alpha[i] ? 0 : 2,
+				MPCC_ALPHA_MULTIPLIED_MODE, 0);
 	}
 }
 
-void dcn10_set_mpc_passthrough(struct dcn10_mpc *mpc,
-	uint8_t dpp_idx,
-	uint8_t mpcc_idx,
-	uint8_t opp_idx)
-{
-	struct mpc_tree_cfg tree_cfg = { 0 };
-
-	tree_cfg.num_pipes = 1;
-	tree_cfg.opp_id = opp_idx;
-	tree_cfg.mode = TOP_PASSTHRU;
-	/* TODO: FPGA bring up one MPC has only 1 DPP and 1 MPCC
-	 * For blend case, need fill mode DPP and cascade MPCC
-	 */
-	tree_cfg.dpp[0] = dpp_idx;
-	tree_cfg.mpcc[0] = mpcc_idx;
-	dcn10_set_mpc_tree(mpc, &tree_cfg);
-}
-
 /*
  * This is the function to remove current MPC tree specified by tree_cfg
  * Before invoke this function, ensure that master lock of OPTC specified
@@ -188,6 +149,7 @@ void dcn10_delete_mpc_tree(struct dcn10_mpc *mpc,
 		 */
 		tree_cfg->dpp[i] = 0xf;
 		tree_cfg->mpcc[i] = 0xf;
+		tree_cfg->per_pixel_alpha[i] = false;
 	}
 	set_output_mux(mpc, tree_cfg->opp_id, 0xf);
 	tree_cfg->opp_id = 0xf;
@@ -208,6 +170,7 @@ bool dcn10_remove_dpp(struct dcn10_mpc *mpc,
 	uint8_t idx)
 {
 	int i;
+	uint8_t mpcc_inst;
 	bool found = false;
 
 	/* find dpp_idx from dpp array of tree_cfg */
@@ -218,54 +181,53 @@ bool dcn10_remove_dpp(struct dcn10_mpc *mpc,
 		}
 	}
 
-	if (found) {
-		/* add remove dpp/mpcc pair into pending list */
+	if (!found) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+	mpcc_inst = tree_cfg->mpcc[i];
 
-		/* TODO FPGA AddToPendingList if empty from pseudo code
-		 * AddToPendingList(tree_cfg->dpp[i],tree_cfg->mpcc[i]);
-		 */
-		uint8_t mpcc_inst = tree_cfg->mpcc[i];
+	REG_SET(MPCC_OPP_ID[mpcc_inst], 0,
+			MPCC_OPP_ID, 0xf);
 
-		REG_SET(MPCC_OPP_ID[mpcc_inst], 0,
-				MPCC_OPP_ID, 0xf);
+	REG_SET(MPCC_TOP_SEL[mpcc_inst], 0,
+			MPCC_TOP_SEL, 0xf);
 
-		REG_SET(MPCC_TOP_SEL[mpcc_inst], 0,
-				MPCC_TOP_SEL, 0xf);
+	REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
+			MPCC_BOT_SEL, 0xf);
+
+	if (i == 0) {
+		if (tree_cfg->num_pipes > 1)
+			set_output_mux(mpc,
+				tree_cfg->opp_id, tree_cfg->mpcc[i+1]);
+		else
+			set_output_mux(mpc, tree_cfg->opp_id, 0xf);
+	} else if (i == tree_cfg->num_pipes-1) {
+		mpcc_inst = tree_cfg->mpcc[i - 1];
 
 		REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
 				MPCC_BOT_SEL, 0xF);
 
-		if (i == 0) {
-			if (tree_cfg->num_pipes > 1)
-				set_output_mux(mpc,
-					tree_cfg->opp_id, tree_cfg->mpcc[i+1]);
-			else
-				set_output_mux(mpc, tree_cfg->opp_id, 0xf);
-		} else if (i == tree_cfg->num_pipes-1) {
-			mpcc_inst = tree_cfg->mpcc[i - 1];
-
-			REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
-					MPCC_BOT_SEL, 0xF);
-
-			REG_UPDATE(MPCC_CONTROL[mpcc_inst],
-					MPCC_MODE, tree_cfg->mode);
-		} else {
-			mpcc_inst = tree_cfg->mpcc[i - 1];
+		/* prev mpc is now last, set to top only*/
+		REG_UPDATE(MPCC_CONTROL[mpcc_inst],
+				MPCC_MODE, MODE_TOP_ONLY);
+	} else {
+		mpcc_inst = tree_cfg->mpcc[i - 1];
 
-			REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
-				MPCC_BOT_SEL, tree_cfg->mpcc[i+1]);
-		}
-		set_blend_mode(mpc, tree_cfg->mode, mpcc_inst);
+		REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
+			MPCC_BOT_SEL, tree_cfg->mpcc[i+1]);
+	}
 
-		/* update tree_cfg structure */
-		while (i < tree_cfg->num_pipes - 1) {
-			tree_cfg->dpp[i] = tree_cfg->dpp[i+1];
-			tree_cfg->mpcc[i] = tree_cfg->mpcc[i+1];
-			i++;
-		}
-		tree_cfg->num_pipes--;
+	/* update tree_cfg structure */
+	while (i < tree_cfg->num_pipes - 1) {
+		tree_cfg->dpp[i] = tree_cfg->dpp[i+1];
+		tree_cfg->mpcc[i] = tree_cfg->mpcc[i+1];
+		tree_cfg->per_pixel_alpha[i] = tree_cfg->per_pixel_alpha[i+1];
+		i++;
 	}
-	return found;
+	tree_cfg->num_pipes--;
+
+	return true;
 }
 
 /* TODO FPGA: how to handle DPP?
@@ -284,14 +246,14 @@ void dcn10_add_dpp(struct dcn10_mpc *mpc,
 	struct mpc_tree_cfg *tree_cfg,
 	uint8_t dpp_idx,
 	uint8_t mpcc_idx,
+	uint8_t per_pixel_alpha,
 	uint8_t position)
 {
-	uint8_t temp;
-	uint8_t temp1;
+	uint8_t prev;
+	uint8_t next;
 
 	REG_SET(MPCC_OPP_ID[mpcc_idx], 0,
 			MPCC_OPP_ID, tree_cfg->opp_id);
-
 	REG_SET(MPCC_TOP_SEL[mpcc_idx], 0,
 			MPCC_TOP_SEL, dpp_idx);
 
@@ -299,70 +261,71 @@ void dcn10_add_dpp(struct dcn10_mpc *mpc,
 		/* idle dpp/mpcc is added to the top layer of tree */
 		REG_SET(MPCC_BOT_SEL[mpcc_idx], 0,
 				MPCC_BOT_SEL, tree_cfg->mpcc[0]);
-		REG_UPDATE(MPCC_CONTROL[mpcc_idx],
-				MPCC_MODE, 3);
 
+		/* bottom mpc is always top only */
+		REG_UPDATE(MPCC_CONTROL[mpcc_idx],
+				MPCC_MODE, MODE_TOP_ONLY);
 		/* opp will get new output. from new added mpcc */
 		set_output_mux(mpc, tree_cfg->opp_id, mpcc_idx);
 
-		set_blend_mode(mpc, tree_cfg->mode, mpcc_idx);
-
 	} else if (position == tree_cfg->num_pipes) {
 		/* idle dpp/mpcc is added to the bottom layer of tree */
 
 		/* get instance of previous bottom mpcc, set to middle layer */
-		temp = tree_cfg->mpcc[tree_cfg->num_pipes - 1];
+		prev = tree_cfg->mpcc[position - 1];
 
-		REG_SET(MPCC_BOT_SEL[temp], 0,
+		REG_SET(MPCC_BOT_SEL[prev], 0,
 				MPCC_BOT_SEL, mpcc_idx);
 
-		REG_UPDATE(MPCC_CONTROL[temp],
-				MPCC_MODE, 3);
+		/* all mpcs other than bottom need to blend */
+		REG_UPDATE(MPCC_CONTROL[prev],
+				MPCC_MODE, MODE_BLEND);
 
 		/* mpcc_idx become new bottom mpcc*/
 		REG_SET(MPCC_BOT_SEL[mpcc_idx], 0,
 				MPCC_BOT_SEL, 0xf);
 
+		/* bottom mpc is always top only */
 		REG_UPDATE(MPCC_CONTROL[mpcc_idx],
-				MPCC_MODE, tree_cfg->mode);
-
-		set_blend_mode(mpc, tree_cfg->mode, mpcc_idx);
+				MPCC_MODE, MODE_TOP_ONLY);
 	} else {
 		/* idle dpp/mpcc is added to middle of tree */
-		temp = tree_cfg->mpcc[position - 1];
-		temp1 = tree_cfg->mpcc[position];
+		prev = tree_cfg->mpcc[position - 1]; /* mpc a */
+		next = tree_cfg->mpcc[position]; /* mpc b */
 
-		/* new mpcc instance temp1 is added right after temp*/
-		REG_SET(MPCC_BOT_SEL[temp], 0,
+		/* connect mpc inserted below mpc a*/
+		REG_SET(MPCC_BOT_SEL[prev], 0,
 				MPCC_BOT_SEL, mpcc_idx);
 
-		/* mpcc_idx connect previous temp+1 to new mpcc */
-		REG_SET(MPCC_BOT_SEL[mpcc_idx], 0,
-				MPCC_BOT_SEL, temp1);
+		/* blend on mpc being inserted */
+		REG_UPDATE(MPCC_CONTROL[mpcc_idx],
+				MPCC_MODE, MODE_BLEND);
 
-		/* temp TODO: may not need*/
-		REG_UPDATE(MPCC_CONTROL[temp],
-				MPCC_MODE, 3);
+		/* Connect mpc b below one inserted */
+		REG_SET(MPCC_BOT_SEL[mpcc_idx], 0,
+				MPCC_BOT_SEL, next);
 
-		set_blend_mode(mpc, tree_cfg->mode, temp);
 	}
-
-	/* update tree_cfg structure */
-	temp = tree_cfg->num_pipes - 1;
+	/* premultiplied mode only if alpha is on for the layer*/
+	REG_UPDATE_2(MPCC_CONTROL[mpcc_idx],
+			MPCC_ALPHA_BLND_MODE,
+			tree_cfg->per_pixel_alpha[position] ? 0 : 2,
+			MPCC_ALPHA_MULTIPLIED_MODE, 0);
 
 	/*
 	 * iterating from the last mpc/dpp pair to the one being added, shift
 	 * them down one position
 	 */
-	while (temp > position) {
-		tree_cfg->dpp[temp + 1] = tree_cfg->dpp[temp];
-		tree_cfg->mpcc[temp + 1] = tree_cfg->mpcc[temp];
-		temp--;
+	for (next = tree_cfg->num_pipes; next > position; next--) {
+		tree_cfg->dpp[next] = tree_cfg->dpp[next - 1];
+		tree_cfg->mpcc[next] = tree_cfg->mpcc[next - 1];
+		tree_cfg->per_pixel_alpha[next] = tree_cfg->per_pixel_alpha[next - 1];
 	}
 
 	/* insert the new mpc/dpp pair into the tree_cfg*/
 	tree_cfg->dpp[position] = dpp_idx;
 	tree_cfg->mpcc[position] = mpcc_idx;
+	tree_cfg->per_pixel_alpha[position] = per_pixel_alpha;
 	tree_cfg->num_pipes++;
 }
 

commit 70ccab604049bbb995a57ab3b7fe8a3c2fdbb736
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon May 8 15:19:06 2017 -0400

    drm/amdgpu/display: Add core dc support for DCN
    
    Core display support for DCN.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
new file mode 100644
index 000000000000..cb22cd130e1a
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -0,0 +1,376 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "reg_helper.h"
+#include "dcn10_mpc.h"
+
+#define REG(reg)\
+	mpc->mpc_regs->reg
+
+#define CTX \
+	mpc->base.ctx
+
+#undef FN
+#define FN(reg_name, field_name) \
+	mpc->mpc_shift->field_name, mpc->mpc_mask->field_name
+
+/* Internal function to set mpc output mux */
+static void set_output_mux(struct dcn10_mpc *mpc,
+	uint8_t opp_id,
+	uint8_t mpcc_id)
+{
+	if (mpcc_id != 0xf)
+		REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
+				OPP_PIPE_CLOCK_EN, 1);
+
+	REG_SET(MUX[opp_id], 0,
+			MPC_OUT_MUX, mpcc_id);
+
+/*	TODO: Move to post when ready.
+   if (mpcc_id == 0xf) {
+		MPCC_REG_UPDATE(OPP_PIPE0_OPP_PIPE_CONTROL,
+				OPP_PIPE_CLOCK_EN, 0);
+	}
+*/
+}
+
+static void set_blend_mode(struct dcn10_mpc *mpc,
+	enum blend_mode mode,
+	uint8_t mpcc_id)
+{
+	/* Enable per-pixel alpha on this pipe */
+	if (mode == TOP_BLND)
+		REG_UPDATE_3(MPCC_CONTROL[mpcc_id],
+				MPCC_ALPHA_BLND_MODE, 0,
+				MPCC_ALPHA_MULTIPLIED_MODE, 0,
+				MPCC_BLND_ACTIVE_OVERLAP_ONLY, 0);
+	else
+		REG_UPDATE_3(MPCC_CONTROL[mpcc_id],
+				MPCC_ALPHA_BLND_MODE, 0,
+				MPCC_ALPHA_MULTIPLIED_MODE, 1,
+				MPCC_BLND_ACTIVE_OVERLAP_ONLY, 1);
+}
+
+void dcn10_set_mpc_background_color(struct dcn10_mpc *mpc,
+	unsigned int mpcc_inst,
+	struct tg_color *bg_color)
+{
+	/* mpc color is 12 bit.  tg_color is 10 bit */
+	/* todo: might want to use 16 bit to represent color and have each
+	 * hw block translate to correct color depth.
+	 */
+	uint32_t bg_r_cr = bg_color->color_r_cr << 2;
+	uint32_t bg_g_y = bg_color->color_g_y << 2;
+	uint32_t bg_b_cb = bg_color->color_b_cb << 2;
+
+	REG_SET(MPCC_BG_R_CR[mpcc_inst], 0,
+			MPCC_BG_R_CR, bg_r_cr);
+	REG_SET(MPCC_BG_G_Y[mpcc_inst], 0,
+			MPCC_BG_G_Y, bg_g_y);
+	REG_SET(MPCC_BG_B_CB[mpcc_inst], 0,
+			MPCC_BG_B_CB, bg_b_cb);
+}
+
+/* This function programs MPC tree configuration
+ * Assume it is the initial time to setup MPC tree_configure, means
+ * the instance of dpp/mpcc/opp specified in structure tree_cfg are
+ * in idle status.
+ * Before invoke this function, ensure that master lock of OPTC specified
+ * by opp_id is set.
+ *
+ * tree_cfg[in] - new MPC_TREE_CFG
+ */
+
+void dcn10_set_mpc_tree(struct dcn10_mpc *mpc,
+	struct mpc_tree_cfg *tree_cfg)
+{
+	int i;
+
+	for (i = 0; i < tree_cfg->num_pipes; i++) {
+		uint8_t mpcc_inst = tree_cfg->mpcc[i];
+
+		REG_SET(MPCC_OPP_ID[mpcc_inst], 0,
+			MPCC_OPP_ID, tree_cfg->opp_id);
+
+		REG_SET(MPCC_TOP_SEL[mpcc_inst], 0,
+			MPCC_TOP_SEL, tree_cfg->dpp[i]);
+
+		if (i == tree_cfg->num_pipes-1) {
+			REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
+				MPCC_BOT_SEL, 0xF);
+
+			/* MPCC_CONTROL->MPCC_MODE */
+			REG_UPDATE(MPCC_CONTROL[mpcc_inst],
+					MPCC_MODE, tree_cfg->mode);
+		} else {
+			REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
+				MPCC_BOT_SEL, tree_cfg->dpp[i+1]);
+
+			/* MPCC_CONTROL->MPCC_MODE */
+			REG_UPDATE(MPCC_CONTROL[mpcc_inst],
+					MPCC_MODE, 3);
+		}
+
+		if (i == 0)
+			set_output_mux(
+				mpc, tree_cfg->opp_id, mpcc_inst);
+
+		set_blend_mode(mpc, tree_cfg->mode, mpcc_inst);
+	}
+}
+
+void dcn10_set_mpc_passthrough(struct dcn10_mpc *mpc,
+	uint8_t dpp_idx,
+	uint8_t mpcc_idx,
+	uint8_t opp_idx)
+{
+	struct mpc_tree_cfg tree_cfg = { 0 };
+
+	tree_cfg.num_pipes = 1;
+	tree_cfg.opp_id = opp_idx;
+	tree_cfg.mode = TOP_PASSTHRU;
+	/* TODO: FPGA bring up one MPC has only 1 DPP and 1 MPCC
+	 * For blend case, need fill mode DPP and cascade MPCC
+	 */
+	tree_cfg.dpp[0] = dpp_idx;
+	tree_cfg.mpcc[0] = mpcc_idx;
+	dcn10_set_mpc_tree(mpc, &tree_cfg);
+}
+
+/*
+ * This is the function to remove current MPC tree specified by tree_cfg
+ * Before invoke this function, ensure that master lock of OPTC specified
+ * by opp_id is set.
+ *
+ *tree_cfg[in/out] - current MPC_TREE_CFG
+ */
+void dcn10_delete_mpc_tree(struct dcn10_mpc *mpc,
+	struct mpc_tree_cfg *tree_cfg)
+{
+	int i;
+
+	for (i = 0; i < tree_cfg->num_pipes; i++) {
+		uint8_t mpcc_inst = tree_cfg->mpcc[i];
+
+		REG_SET(MPCC_OPP_ID[mpcc_inst], 0,
+			MPCC_OPP_ID, 0xf);
+
+		REG_SET(MPCC_TOP_SEL[mpcc_inst], 0,
+			MPCC_TOP_SEL, 0xf);
+
+		REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
+			MPCC_BOT_SEL, 0xF);
+
+		/* add remove dpp/mpcc pair into pending list
+		 * TODO FPGA AddToPendingList if empty from pseudo code
+		 */
+		tree_cfg->dpp[i] = 0xf;
+		tree_cfg->mpcc[i] = 0xf;
+	}
+	set_output_mux(mpc, tree_cfg->opp_id, 0xf);
+	tree_cfg->opp_id = 0xf;
+	tree_cfg->num_pipes = 0;
+}
+
+/* TODO FPGA: how to handle DPP?
+ * Function to remove one of pipe from MPC configure tree by dpp idx
+ * Before invoke this function, ensure that master lock of OPTC specified
+ * by opp_id is set
+ * This function can be invoke multiple times to remove more than 1 dpps.
+ *
+ * tree_cfg[in/out] - current MPC_TREE_CFG
+ * idx[in] - index of dpp from tree_cfg to be removed.
+ */
+bool dcn10_remove_dpp(struct dcn10_mpc *mpc,
+	struct mpc_tree_cfg *tree_cfg,
+	uint8_t idx)
+{
+	int i;
+	bool found = false;
+
+	/* find dpp_idx from dpp array of tree_cfg */
+	for (i = 0; i < tree_cfg->num_pipes; i++) {
+		if (tree_cfg->dpp[i] == idx) {
+			found = true;
+			break;
+		}
+	}
+
+	if (found) {
+		/* add remove dpp/mpcc pair into pending list */
+
+		/* TODO FPGA AddToPendingList if empty from pseudo code
+		 * AddToPendingList(tree_cfg->dpp[i],tree_cfg->mpcc[i]);
+		 */
+		uint8_t mpcc_inst = tree_cfg->mpcc[i];
+
+		REG_SET(MPCC_OPP_ID[mpcc_inst], 0,
+				MPCC_OPP_ID, 0xf);
+
+		REG_SET(MPCC_TOP_SEL[mpcc_inst], 0,
+				MPCC_TOP_SEL, 0xf);
+
+		REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
+				MPCC_BOT_SEL, 0xF);
+
+		if (i == 0) {
+			if (tree_cfg->num_pipes > 1)
+				set_output_mux(mpc,
+					tree_cfg->opp_id, tree_cfg->mpcc[i+1]);
+			else
+				set_output_mux(mpc, tree_cfg->opp_id, 0xf);
+		} else if (i == tree_cfg->num_pipes-1) {
+			mpcc_inst = tree_cfg->mpcc[i - 1];
+
+			REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
+					MPCC_BOT_SEL, 0xF);
+
+			REG_UPDATE(MPCC_CONTROL[mpcc_inst],
+					MPCC_MODE, tree_cfg->mode);
+		} else {
+			mpcc_inst = tree_cfg->mpcc[i - 1];
+
+			REG_SET(MPCC_BOT_SEL[mpcc_inst], 0,
+				MPCC_BOT_SEL, tree_cfg->mpcc[i+1]);
+		}
+		set_blend_mode(mpc, tree_cfg->mode, mpcc_inst);
+
+		/* update tree_cfg structure */
+		while (i < tree_cfg->num_pipes - 1) {
+			tree_cfg->dpp[i] = tree_cfg->dpp[i+1];
+			tree_cfg->mpcc[i] = tree_cfg->mpcc[i+1];
+			i++;
+		}
+		tree_cfg->num_pipes--;
+	}
+	return found;
+}
+
+/* TODO FPGA: how to handle DPP?
+ * Function to add DPP/MPCC pair into MPC configure tree by position.
+ * Before invoke this function, ensure that master lock of OPTC specified
+ * by opp_id is set
+ * This function can be invoke multiple times to add more than 1 pipes.
+ *
+ * tree_cfg[in/out] - current MPC_TREE_CFG
+ * dpp_idx[in]	 - index of an idle dpp insatnce to be added.
+ * mpcc_idx[in]	 - index of an idle mpcc instance to be added.
+ * poistion[in]	 - position of dpp/mpcc pair to be added into current tree_cfg
+ *                 0 means insert to the most top layer of MPC tree
+ */
+void dcn10_add_dpp(struct dcn10_mpc *mpc,
+	struct mpc_tree_cfg *tree_cfg,
+	uint8_t dpp_idx,
+	uint8_t mpcc_idx,
+	uint8_t position)
+{
+	uint8_t temp;
+	uint8_t temp1;
+
+	REG_SET(MPCC_OPP_ID[mpcc_idx], 0,
+			MPCC_OPP_ID, tree_cfg->opp_id);
+
+	REG_SET(MPCC_TOP_SEL[mpcc_idx], 0,
+			MPCC_TOP_SEL, dpp_idx);
+
+	if (position == 0) {
+		/* idle dpp/mpcc is added to the top layer of tree */
+		REG_SET(MPCC_BOT_SEL[mpcc_idx], 0,
+				MPCC_BOT_SEL, tree_cfg->mpcc[0]);
+		REG_UPDATE(MPCC_CONTROL[mpcc_idx],
+				MPCC_MODE, 3);
+
+		/* opp will get new output. from new added mpcc */
+		set_output_mux(mpc, tree_cfg->opp_id, mpcc_idx);
+
+		set_blend_mode(mpc, tree_cfg->mode, mpcc_idx);
+
+	} else if (position == tree_cfg->num_pipes) {
+		/* idle dpp/mpcc is added to the bottom layer of tree */
+
+		/* get instance of previous bottom mpcc, set to middle layer */
+		temp = tree_cfg->mpcc[tree_cfg->num_pipes - 1];
+
+		REG_SET(MPCC_BOT_SEL[temp], 0,
+				MPCC_BOT_SEL, mpcc_idx);
+
+		REG_UPDATE(MPCC_CONTROL[temp],
+				MPCC_MODE, 3);
+
+		/* mpcc_idx become new bottom mpcc*/
+		REG_SET(MPCC_BOT_SEL[mpcc_idx], 0,
+				MPCC_BOT_SEL, 0xf);
+
+		REG_UPDATE(MPCC_CONTROL[mpcc_idx],
+				MPCC_MODE, tree_cfg->mode);
+
+		set_blend_mode(mpc, tree_cfg->mode, mpcc_idx);
+	} else {
+		/* idle dpp/mpcc is added to middle of tree */
+		temp = tree_cfg->mpcc[position - 1];
+		temp1 = tree_cfg->mpcc[position];
+
+		/* new mpcc instance temp1 is added right after temp*/
+		REG_SET(MPCC_BOT_SEL[temp], 0,
+				MPCC_BOT_SEL, mpcc_idx);
+
+		/* mpcc_idx connect previous temp+1 to new mpcc */
+		REG_SET(MPCC_BOT_SEL[mpcc_idx], 0,
+				MPCC_BOT_SEL, temp1);
+
+		/* temp TODO: may not need*/
+		REG_UPDATE(MPCC_CONTROL[temp],
+				MPCC_MODE, 3);
+
+		set_blend_mode(mpc, tree_cfg->mode, temp);
+	}
+
+	/* update tree_cfg structure */
+	temp = tree_cfg->num_pipes - 1;
+
+	/*
+	 * iterating from the last mpc/dpp pair to the one being added, shift
+	 * them down one position
+	 */
+	while (temp > position) {
+		tree_cfg->dpp[temp + 1] = tree_cfg->dpp[temp];
+		tree_cfg->mpcc[temp + 1] = tree_cfg->mpcc[temp];
+		temp--;
+	}
+
+	/* insert the new mpc/dpp pair into the tree_cfg*/
+	tree_cfg->dpp[position] = dpp_idx;
+	tree_cfg->mpcc[position] = mpcc_idx;
+	tree_cfg->num_pipes++;
+}
+
+void wait_mpcc_idle(struct dcn10_mpc *mpc,
+	uint8_t mpcc_id)
+{
+	REG_WAIT(MPCC_STATUS[mpcc_id],
+			MPCC_IDLE, 1,
+			1000, 1000);
+}
+
