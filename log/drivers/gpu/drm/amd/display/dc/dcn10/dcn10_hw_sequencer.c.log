commit 185082b679b4bd6dfb69764eaa89213b26f6f703
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Tue May 12 11:48:48 2020 -0400

    drm/amd/display: Fix potential integer wraparound resulting in a hang
    
    [Why]
    If VUPDATE_END is before VUPDATE_START the delay calculated can become
    very large, causing a soft hang.
    
    [How]
    Take the absolute value of the difference between START and END.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Qingqing Zhuo <qingqing.zhuo@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f59cf60fb78a..77f16921e7f0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1742,6 +1742,8 @@ static void delay_cursor_until_vupdate(struct dc *dc, struct pipe_ctx *pipe_ctx)
 		return;
 
 	/* Stall out until the cursor update completes. */
+	if (vupdate_end < vupdate_start)
+		vupdate_end += stream->timing.v_total;
 	us_vupdate = (vupdate_end - vupdate_start + 1) * us_per_line;
 	udelay(us_to_vupdate + us_vupdate);
 }

commit 63731e73dae413d535fd4cef3d8a77203c13f3f4
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Mon May 4 16:49:28 2020 -0400

    drm/amd/display: Defer cursor lock until after VUPDATE
    
    [Why]
    We dropped the delay after changed the cursor functions locking the
    entire pipe to locking just the CURSOR registers to fix page flip
    stuttering - this introduced cursor stuttering instead, and an underflow
    issue.
    
    The cursor update can be delayed indefinitely if the cursor update
    repeatedly happens right around VUPDATE.
    
    The underflow issue can happen if we do a viewport update on a pipe
    on the same frame where a cursor update happens around VUPDATE - the
    old cursor registers are retained which can be in an invalid position.
    
    This can cause a pipe hang and indefinite underflow.
    
    [How]
    The complex, ideal solution to the problem would be a software
    triple buffering mechanism from the DM layer to program only one cursor
    update per frame just before VUPDATE.
    
    The simple workaround until we have that infrastructure in place is
    this change - bring back the delay until VUPDATE before locking, but
    with some corrections to the calculations.
    
    This didn't work for all timings before because the calculation for
    VUPDATE was wrong - it was using the offset from VSTARTUP instead and
    didn't correctly handle the case where VUPDATE could be in the back
    porch.
    
    Add a new hardware sequencer function to use the existing helper to
    calculate the real VUPDATE start and VUPDATE end - VUPDATE can last
    multiple lines after all.
    
    Change the udelay to incorporate the width of VUPDATE as well.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index daf6977b5fb5..f59cf60fb78a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1683,12 +1683,79 @@ void dcn10_pipe_control_lock(
 		hws->funcs.verify_allow_pstate_change_high(dc);
 }
 
+/**
+ * delay_cursor_until_vupdate() - Delay cursor update if too close to VUPDATE.
+ *
+ * Software keepout workaround to prevent cursor update locking from stalling
+ * out cursor updates indefinitely or from old values from being retained in
+ * the case where the viewport changes in the same frame as the cursor.
+ *
+ * The idea is to calculate the remaining time from VPOS to VUPDATE. If it's
+ * too close to VUPDATE, then stall out until VUPDATE finishes.
+ *
+ * TODO: Optimize cursor programming to be once per frame before VUPDATE
+ *       to avoid the need for this workaround.
+ */
+static void delay_cursor_until_vupdate(struct dc *dc, struct pipe_ctx *pipe_ctx)
+{
+	struct dc_stream_state *stream = pipe_ctx->stream;
+	struct crtc_position position;
+	uint32_t vupdate_start, vupdate_end;
+	unsigned int lines_to_vupdate, us_to_vupdate, vpos;
+	unsigned int us_per_line, us_vupdate;
+
+	if (!dc->hwss.calc_vupdate_position || !dc->hwss.get_position)
+		return;
+
+	if (!pipe_ctx->stream_res.stream_enc || !pipe_ctx->stream_res.tg)
+		return;
+
+	dc->hwss.calc_vupdate_position(dc, pipe_ctx, &vupdate_start,
+				       &vupdate_end);
+
+	dc->hwss.get_position(&pipe_ctx, 1, &position);
+	vpos = position.vertical_count;
+
+	/* Avoid wraparound calculation issues */
+	vupdate_start += stream->timing.v_total;
+	vupdate_end += stream->timing.v_total;
+	vpos += stream->timing.v_total;
+
+	if (vpos <= vupdate_start) {
+		/* VPOS is in VACTIVE or back porch. */
+		lines_to_vupdate = vupdate_start - vpos;
+	} else if (vpos > vupdate_end) {
+		/* VPOS is in the front porch. */
+		return;
+	} else {
+		/* VPOS is in VUPDATE. */
+		lines_to_vupdate = 0;
+	}
+
+	/* Calculate time until VUPDATE in microseconds. */
+	us_per_line =
+		stream->timing.h_total * 10000u / stream->timing.pix_clk_100hz;
+	us_to_vupdate = lines_to_vupdate * us_per_line;
+
+	/* 70 us is a conservative estimate of cursor update time*/
+	if (us_to_vupdate > 70)
+		return;
+
+	/* Stall out until the cursor update completes. */
+	us_vupdate = (vupdate_end - vupdate_start + 1) * us_per_line;
+	udelay(us_to_vupdate + us_vupdate);
+}
+
 void dcn10_cursor_lock(struct dc *dc, struct pipe_ctx *pipe, bool lock)
 {
 	/* cursor lock is per MPCC tree, so only need to lock one pipe per stream */
 	if (!pipe || pipe->top_pipe)
 		return;
 
+	/* Prevent cursor lock from stalling out cursor updates. */
+	if (lock)
+		delay_cursor_until_vupdate(dc, pipe);
+
 	dc->res_pool->mpc->funcs->cursor_lock(dc->res_pool->mpc,
 			pipe->stream_res.opp->inst, lock);
 }
@@ -3302,7 +3369,7 @@ int dcn10_get_vupdate_offset_from_vsync(struct pipe_ctx *pipe_ctx)
 	return vertical_line_start;
 }
 
-static void dcn10_calc_vupdate_position(
+void dcn10_calc_vupdate_position(
 		struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
 		uint32_t *start_line,

commit 087a1ff8fbd0164bd4c4d57343c8e51411aa098e
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu May 7 09:48:06 2020 -0400

    drm/amd/display: Fix disable_stutter debug option
    
    [Why & How]
    One call was forcing stutter on instead of looking at the debug option.
    Ensure we always check the debug option unless we want to force stutter
    off.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f36d1f57b846..daf6977b5fb5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -737,7 +737,8 @@ void dcn10_bios_golden_init(struct dc *dc)
 	if (dc->res_pool->hubbub->funcs->allow_self_refresh_control)
 		if (allow_self_fresh_force_enable == false &&
 				dc->res_pool->hubbub->funcs->is_allow_self_refresh_enabled(dc->res_pool->hubbub))
-			dc->res_pool->hubbub->funcs->allow_self_refresh_control(dc->res_pool->hubbub, true);
+			dc->res_pool->hubbub->funcs->allow_self_refresh_control(dc->res_pool->hubbub,
+										!dc->res_pool->hubbub->ctx->dc->debug.disable_stutter);
 
 }
 

commit e0a3794d226a5ab30ca6d68069bf32ed48c632bf
Author: yanyan kang <Yanyan.Kang@amd.com>
Date:   Mon Apr 20 14:40:43 2020 +0800

    drm/amd/display: The external monitor will show gray screen during SUT reboot
    
    [Why]
    same with CL#1711022(correcting yuv420 black color in function dcn10_blank_pixel_data,program_scaler),
    yuv420 black color also needs to be correct when enabling HDMI stream at the resume procedure.
    
    [How]
    correcting the yuv420 black color according to the way how 420 is packed :2 channels carry Y component,
    1 channel alternate between Cb and Cr.
    
    Signed-off-by: yanyan kang <Yanyan.Kang@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index b33eafe45f76..f36d1f57b846 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -826,6 +826,14 @@ enum dc_status dcn10_enable_stream_timing(
 	color_space = stream->output_color_space;
 	color_space_to_black_color(dc, color_space, &black_color);
 
+	/*
+	 * The way 420 is packed, 2 channels carry Y component, 1 channel
+	 * alternate between Cb and Cr, so both channels need the pixel
+	 * value for Y
+	 */
+	if (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)
+		black_color.color_r_cr = black_color.color_g_y;
+
 	if (pipe_ctx->stream_res.tg->funcs->set_blank_color)
 		pipe_ctx->stream_res.tg->funcs->set_blank_color(
 				pipe_ctx->stream_res.tg,
@@ -2254,6 +2262,14 @@ void dcn10_update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
 				&blnd_cfg.black_color);
 	}
 
+	/*
+	 * The way 420 is packed, 2 channels carry Y component, 1 channel
+	 * alternate between Cb and Cr, so both channels need the pixel
+	 * value for Y
+	 */
+	if (pipe_ctx->stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)
+		blnd_cfg.black_color.color_r_cr = blnd_cfg.black_color.color_g_y;
+
 	if (per_pixel_alpha)
 		blnd_cfg.alpha_mode = MPCC_ALPHA_BLEND_MODE_PER_PIXEL_ALPHA;
 	else

commit 3ba01817365c5a2c07a8be09117f3e22e16f5c80
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Sat Apr 18 19:22:55 2020 -0400

    drm/amd/display: Move panel_cntl specific register from abm to panel_cntl.
    
    [Why]
    panel_cntl specific register should be access in panel_cntl object.
    
    [How]
    Move these register access from abm to panel_cntl.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 2eb5d0e3e425..b33eafe45f76 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -903,8 +903,7 @@ static void dcn10_reset_back_end_for_pipe(
 	if (pipe_ctx->top_pipe == NULL) {
 
 		if (pipe_ctx->stream_res.abm)
-			pipe_ctx->stream_res.abm->funcs->set_abm_immediate_disable(pipe_ctx->stream_res.abm,
-					pipe_ctx->stream->link->panel_cntl->inst);
+			dc->hwss.set_abm_immediate_disable(pipe_ctx);
 
 		pipe_ctx->stream_res.tg->funcs->disable_crtc(pipe_ctx->stream_res.tg);
 
@@ -1245,6 +1244,7 @@ void dcn10_init_hw(struct dc *dc)
 	struct dce_hwseq *hws = dc->hwseq;
 	struct dc_bios *dcb = dc->ctx->dc_bios;
 	struct resource_pool *res_pool = dc->res_pool;
+	uint32_t backlight = MAX_BACKLIGHT_LEVEL;
 
 	if (dc->clk_mgr && dc->clk_mgr->funcs->init_clocks)
 		dc->clk_mgr->funcs->init_clocks(dc->clk_mgr);
@@ -1411,11 +1411,16 @@ void dcn10_init_hw(struct dc *dc)
 		audio->funcs->hw_init(audio);
 	}
 
-	if (abm != NULL) {
-		abm->funcs->init_backlight(abm);
-		abm->funcs->abm_init(abm);
+	for (i = 0; i < dc->link_count; i++) {
+		struct dc_link *link = dc->links[i];
+
+		if (link->panel_cntl)
+			backlight = link->panel_cntl->funcs->hw_init(link->panel_cntl);
 	}
 
+	if (abm != NULL)
+		abm->funcs->abm_init(abm, backlight);
+
 	if (dmcu != NULL && !dmcu->auto_load_dmcu)
 		dmcu->funcs->dmcu_init(dmcu);
 
@@ -2490,9 +2495,7 @@ void dcn10_blank_pixel_data(
 			stream_res->abm->funcs->set_abm_level(stream_res->abm, stream->abm_level);
 		}
 	} else if (blank) {
-		if (stream_res->abm)
-			stream_res->abm->funcs->set_abm_immediate_disable(stream_res->abm,
-					stream->link->panel_cntl->inst);
+		dc->hwss.set_abm_immediate_disable(pipe_ctx);
 		if (stream_res->tg->funcs->set_blank)
 			stream_res->tg->funcs->set_blank(stream_res->tg, blank);
 	}

commit 1e461c37d1fb6712561ad682b2d67ed4f5cbd3ff
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Wed Apr 22 18:08:03 2020 -0400

    drm/amd/display: Use cursor locking to prevent flip delays
    
    [Why]
    Current locking scheme for cursor can result in a flip missing
    its vsync, deferring it for one or more vsyncs.  Result is a
    potential for stuttering when cursor is moved.
    
    [How]
    Use cursor update lock so that flips are not blocked while cursor
    is being programmed.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index bfc8578eda15..2eb5d0e3e425 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1669,6 +1669,16 @@ void dcn10_pipe_control_lock(
 		hws->funcs.verify_allow_pstate_change_high(dc);
 }
 
+void dcn10_cursor_lock(struct dc *dc, struct pipe_ctx *pipe, bool lock)
+{
+	/* cursor lock is per MPCC tree, so only need to lock one pipe per stream */
+	if (!pipe || pipe->top_pipe)
+		return;
+
+	dc->res_pool->mpc->funcs->cursor_lock(dc->res_pool->mpc,
+			pipe->stream_res.opp->inst, lock);
+}
+
 static bool wait_for_reset_trigger_to_occur(
 	struct dc_context *dc_ctx,
 	struct timing_generator *tg)

commit 18400f91c1c17777d98013ea15d620e7b4ac1cf4
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Apr 22 18:07:59 2020 -0400

    drm/amd/display: Add panel cntl id for set backlight level.
    
    [Why & How]
    Add panel cntl instance when calling set backlight.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Acked-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 0d53e1d6d6b7..bfc8578eda15 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -903,7 +903,8 @@ static void dcn10_reset_back_end_for_pipe(
 	if (pipe_ctx->top_pipe == NULL) {
 
 		if (pipe_ctx->stream_res.abm)
-			pipe_ctx->stream_res.abm->funcs->set_abm_immediate_disable(pipe_ctx->stream_res.abm);
+			pipe_ctx->stream_res.abm->funcs->set_abm_immediate_disable(pipe_ctx->stream_res.abm,
+					pipe_ctx->stream->link->panel_cntl->inst);
 
 		pipe_ctx->stream_res.tg->funcs->disable_crtc(pipe_ctx->stream_res.tg);
 
@@ -2474,12 +2475,14 @@ void dcn10_blank_pixel_data(
 		if (stream_res->tg->funcs->set_blank)
 			stream_res->tg->funcs->set_blank(stream_res->tg, blank);
 		if (stream_res->abm) {
-			stream_res->abm->funcs->set_pipe(stream_res->abm, stream_res->tg->inst + 1);
+			stream_res->abm->funcs->set_pipe(stream_res->abm, stream_res->tg->inst + 1,
+					stream->link->panel_cntl->inst);
 			stream_res->abm->funcs->set_abm_level(stream_res->abm, stream->abm_level);
 		}
 	} else if (blank) {
 		if (stream_res->abm)
-			stream_res->abm->funcs->set_abm_immediate_disable(stream_res->abm);
+			stream_res->abm->funcs->set_abm_immediate_disable(stream_res->abm,
+					stream->link->panel_cntl->inst);
 		if (stream_res->tg->funcs->set_blank)
 			stream_res->tg->funcs->set_blank(stream_res->tg, blank);
 	}

commit d0a0a00d32e93d4dfcdea0a8e504c383da5afce3
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Fri Apr 3 16:33:56 2020 -0400

    drm/amd/display: Fix HDR visual confirm
    
    Some cases were incorrectly reporting the wrong visual confirm, even
    though they were working as expected.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 4a081e544123..0d53e1d6d6b7 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2128,25 +2128,25 @@ void dcn10_get_surface_visual_confirm_color(
 
 	switch (pipe_ctx->plane_res.scl_data.format) {
 	case PIXEL_FORMAT_ARGB8888:
-		/* set boarder color to red */
+		/* set border color to red */
 		color->color_r_cr = color_value;
 		break;
 
 	case PIXEL_FORMAT_ARGB2101010:
-		/* set boarder color to blue */
+		/* set border color to blue */
 		color->color_b_cb = color_value;
 		break;
 	case PIXEL_FORMAT_420BPP8:
-		/* set boarder color to green */
+		/* set border color to green */
 		color->color_g_y = color_value;
 		break;
 	case PIXEL_FORMAT_420BPP10:
-		/* set boarder color to yellow */
+		/* set border color to yellow */
 		color->color_g_y = color_value;
 		color->color_r_cr = color_value;
 		break;
 	case PIXEL_FORMAT_FP16:
-		/* set boarder color to white */
+		/* set border color to white */
 		color->color_r_cr = color_value;
 		color->color_b_cb = color_value;
 		color->color_g_y = color_value;
@@ -2171,25 +2171,25 @@ void dcn10_get_hdr_visual_confirm_color(
 	switch (top_pipe_ctx->plane_res.scl_data.format) {
 	case PIXEL_FORMAT_ARGB2101010:
 		if (top_pipe_ctx->stream->out_transfer_func->tf == TRANSFER_FUNCTION_PQ) {
-			/* HDR10, ARGB2101010 - set boarder color to red */
+			/* HDR10, ARGB2101010 - set border color to red */
 			color->color_r_cr = color_value;
 		} else if (top_pipe_ctx->stream->out_transfer_func->tf == TRANSFER_FUNCTION_GAMMA22) {
-			/* FreeSync 2 ARGB2101010 - set boarder color to pink */
+			/* FreeSync 2 ARGB2101010 - set border color to pink */
 			color->color_r_cr = color_value;
 			color->color_b_cb = color_value;
 		}
 		break;
 	case PIXEL_FORMAT_FP16:
 		if (top_pipe_ctx->stream->out_transfer_func->tf == TRANSFER_FUNCTION_PQ) {
-			/* HDR10, FP16 - set boarder color to blue */
+			/* HDR10, FP16 - set border color to blue */
 			color->color_b_cb = color_value;
 		} else if (top_pipe_ctx->stream->out_transfer_func->tf == TRANSFER_FUNCTION_GAMMA22) {
-			/* FreeSync 2 HDR - set boarder color to green */
+			/* FreeSync 2 HDR - set border color to green */
 			color->color_g_y = color_value;
 		}
 		break;
 	default:
-		/* SDR - set boarder color to Gray */
+		/* SDR - set border color to Gray */
 		color->color_r_cr = color_value/2;
 		color->color_b_cb = color_value/2;
 		color->color_g_y = color_value/2;

commit 1c256f40bf8e9f4723c9e84c7e3a1105e1db0ad9
Author: Zhan Liu <zhan.liu@amd.com>
Date:   Thu Apr 16 14:20:56 2020 -0400

    drm/amd/display: Remove aconnector condition check for dpcd read
    
    [Why]
    Aconnector is not necessary to be NULL in order to read dpcd
    successfully.
    
    Actually if we rely on checking aconnector here, we won't be able
    to turn off all displays before doing display detection. That will
    cause some MST hubs not able to light up.
    
    [How]
    Remove aconnector check when turning off all displays at
    hardware initialization stage.
    
    Signed-off-by: Zhan Liu <zhan.liu@amd.com>
    Reviewed-by: Joseph Gravenor <joseph.gravenor@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 9f41efddc9bc..4a081e544123 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1333,30 +1333,28 @@ void dcn10_init_hw(struct dc *dc)
 				continue;
 
 			/*
-			 * core_link_read_dpcd() will invoke dm_helpers_dp_read_dpcd(),
-			 * which needs to read dpcd info with the help of aconnector.
-			 * If aconnector (dc->links[i]->prev) is NULL, then dpcd status
-			 * cannot be read.
+			 * If any of the displays are lit up turn them off.
+			 * The reason is that some MST hubs cannot be turned off
+			 * completely until we tell them to do so.
+			 * If not turned off, then displays connected to MST hub
+			 * won't light up.
 			 */
-			if (dc->links[i]->priv) {
-				/* if any of the displays are lit up turn them off */
-				status = core_link_read_dpcd(dc->links[i], DP_SET_POWER,
-								&dpcd_power_state, sizeof(dpcd_power_state));
-				if (status == DC_OK && dpcd_power_state == DP_POWER_STATE_D0) {
-					/* blank dp stream before power off receiver*/
-					if (dc->links[i]->link_enc->funcs->get_dig_frontend) {
-						unsigned int fe = dc->links[i]->link_enc->funcs->get_dig_frontend(dc->links[i]->link_enc);
-
-						for (j = 0; j < dc->res_pool->stream_enc_count; j++) {
-							if (fe == dc->res_pool->stream_enc[j]->id) {
-								dc->res_pool->stream_enc[j]->funcs->dp_blank(
-											dc->res_pool->stream_enc[j]);
-								break;
-							}
+			status = core_link_read_dpcd(dc->links[i], DP_SET_POWER,
+							&dpcd_power_state, sizeof(dpcd_power_state));
+			if (status == DC_OK && dpcd_power_state == DP_POWER_STATE_D0) {
+				/* blank dp stream before power off receiver*/
+				if (dc->links[i]->link_enc->funcs->get_dig_frontend) {
+					unsigned int fe = dc->links[i]->link_enc->funcs->get_dig_frontend(dc->links[i]->link_enc);
+
+					for (j = 0; j < dc->res_pool->stream_enc_count; j++) {
+						if (fe == dc->res_pool->stream_enc[j]->id) {
+							dc->res_pool->stream_enc[j]->funcs->dp_blank(
+										dc->res_pool->stream_enc[j]);
+							break;
 						}
 					}
-					dp_receiver_power_ctrl(dc->links[i], false);
 				}
+				dp_receiver_power_ctrl(dc->links[i], false);
 			}
 		}
 	}

commit 033baeeefbf088416b975ac1aae08a4b8e8ef914
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Sun Apr 5 16:41:08 2020 -0400

    drm/amd/display: Make cursor source translation adjustment optional
    
    [Why]
    In some usecases, like tiled display, the stream and plane configuration
    can be setup in a way where the caller expects DAL to perform the
    clipping, eg:
    
    P0:
    src_rect(0, 0, w, h)
    dst_rect(0, 0, w, h)
    
    P1:
    src_rect(w, 0, w, h)
    dst_rect(0, 0, w, h)
    
    Cursor is enabled on both streams with the same position.
    
    This can result in double cursor on tiled display, even though this
    behavior is technically correct from the DC interface point of view.
    
    We need a mechanism to control this dynamically.
    
    [How]
    This is something that should live in the DM layer based on detection
    of the specified configuration but it's not something that we really
    have enough information to deal with today.
    
    Add a flag to the cursor position state that specifies whether we
    want DC to do the translation or not and make it opt-in and let
    the DM decide when to do it.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 9ef5747e5077..9f41efddc9bc 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -3095,9 +3095,15 @@ void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 	 *
 	 * This translation isn't affected by scaling so it needs to be
 	 * done *after* we adjust the position for the scale factor.
+	 *
+	 * This is only done by opt-in for now since there are still
+	 * some usecases like tiled display that might enable the
+	 * cursor on both streams while expecting dc to clip it.
 	 */
-	x_pos += pipe_ctx->plane_state->src_rect.x;
-	y_pos += pipe_ctx->plane_state->src_rect.y;
+	if (pos_cpy.translate_by_source) {
+		x_pos += pipe_ctx->plane_state->src_rect.x;
+		y_pos += pipe_ctx->plane_state->src_rect.y;
+	}
 
 	/**
 	 * If the position is negative then we need to add to the hotspot

commit 12aec9efea952eee284dd58dc585df7948a85771
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Sun Apr 5 16:40:53 2020 -0400

    drm/amd/display: Translate cursor position by source rect
    
    [Why]
    Cursor is drawn as part of the framebuffer for a plane on AMD hardware.
    The cursor position on the framebuffer does not change even if the
    source rect viewport for the cursor does. This causes the cursor to be
    clipped.
    
    The following IGT tests fail as a result of this issue:
    
    - kms_plane_cursor@pipe-*-viewport-size-*
    
    [How]
    Offset cursor position by plane source rect viewport. If the viewport
    is unscaled then the cursor is now correctly positioned on any
    plane - primary or overlay.
    
    There is still a hardware limitation for dealing with the cursor size
    being incorrectly scaled but that's not something we can address.
    
    Add some documentation explaining some of this in the code while we're
    at it.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Zhan Liu <Zhan.Liu@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index ac133fac4dfc..9ef5747e5077 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -3066,12 +3066,44 @@ void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 	int x_pos = pos_cpy.x;
 	int y_pos = pos_cpy.y;
 
-	// translate cursor from stream space to plane space
+	/**
+	 * DC cursor is stream space, HW cursor is plane space and drawn
+	 * as part of the framebuffer.
+	 *
+	 * Cursor position can't be negative, but hotspot can be used to
+	 * shift cursor out of the plane bounds. Hotspot must be smaller
+	 * than the cursor size.
+	 */
+
+	/**
+	 * Translate cursor from stream space to plane space.
+	 *
+	 * If the cursor is scaled then we need to scale the position
+	 * to be in the approximately correct place. We can't do anything
+	 * about the actual size being incorrect, that's a limitation of
+	 * the hardware.
+	 */
 	x_pos = (x_pos - x_plane) * pipe_ctx->plane_state->src_rect.width /
 			pipe_ctx->plane_state->dst_rect.width;
 	y_pos = (y_pos - y_plane) * pipe_ctx->plane_state->src_rect.height /
 			pipe_ctx->plane_state->dst_rect.height;
 
+	/**
+	 * If the cursor's source viewport is clipped then we need to
+	 * translate the cursor to appear in the correct position on
+	 * the screen.
+	 *
+	 * This translation isn't affected by scaling so it needs to be
+	 * done *after* we adjust the position for the scale factor.
+	 */
+	x_pos += pipe_ctx->plane_state->src_rect.x;
+	y_pos += pipe_ctx->plane_state->src_rect.y;
+
+	/**
+	 * If the position is negative then we need to add to the hotspot
+	 * to shift the cursor outside the plane.
+	 */
+
 	if (x_pos < 0) {
 		pos_cpy.x_hotspot -= x_pos;
 		x_pos = 0;

commit 8d9c07b0eb099a0bda247d0206acb3a76410914d
Author: Xiaodong Yan <Xiaodong.Yan@amd.com>
Date:   Sun Apr 5 16:40:51 2020 -0400

    drm/amd/display: only blank dp stream which will be powered off
    
    [why]
    blank all dp stream would impact edp
    
    [how]
    only blank the one which will be powered off
    
    Signed-off-by: Xiaodong Yan <Xiaodong.Yan@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 6086bbec94fe..ac133fac4dfc 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1238,7 +1238,7 @@ void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 
 void dcn10_init_hw(struct dc *dc)
 {
-	int i;
+	int i, j;
 	struct abm *abm = dc->res_pool->abm;
 	struct dmcu *dmcu = dc->res_pool->dmcu;
 	struct dce_hwseq *hws = dc->hwseq;
@@ -1328,14 +1328,6 @@ void dcn10_init_hw(struct dc *dc)
 		uint8_t dpcd_power_state = '\0';
 		enum dc_status status = DC_ERROR_UNEXPECTED;
 
-		/* blank all dp streams before power off receiver,
-		 * this should only impact DP
-		 */
-		for (i = 0; i < dc->res_pool->stream_enc_count; i++) {
-			dc->res_pool->stream_enc[i]->funcs->dp_blank(
-						dc->res_pool->stream_enc[i]);
-		}
-
 		for (i = 0; i < dc->link_count; i++) {
 			if (dc->links[i]->connector_signal != SIGNAL_TYPE_DISPLAY_PORT)
 				continue;
@@ -1350,8 +1342,21 @@ void dcn10_init_hw(struct dc *dc)
 				/* if any of the displays are lit up turn them off */
 				status = core_link_read_dpcd(dc->links[i], DP_SET_POWER,
 								&dpcd_power_state, sizeof(dpcd_power_state));
-				if (status == DC_OK && dpcd_power_state == DP_POWER_STATE_D0)
+				if (status == DC_OK && dpcd_power_state == DP_POWER_STATE_D0) {
+					/* blank dp stream before power off receiver*/
+					if (dc->links[i]->link_enc->funcs->get_dig_frontend) {
+						unsigned int fe = dc->links[i]->link_enc->funcs->get_dig_frontend(dc->links[i]->link_enc);
+
+						for (j = 0; j < dc->res_pool->stream_enc_count; j++) {
+							if (fe == dc->res_pool->stream_enc[j]->id) {
+								dc->res_pool->stream_enc[j]->funcs->dp_blank(
+											dc->res_pool->stream_enc[j]);
+								break;
+							}
+						}
+					}
 					dp_receiver_power_ctrl(dc->links[i], false);
+				}
 			}
 		}
 	}

commit d5e27f072844f6097ab3305b3b7bee00709b953b
Author: Sung Lee <sung.lee@amd.com>
Date:   Sun Apr 5 16:40:48 2020 -0400

    drm/amd/display: Check power_down functions exist before calling
    
    [WHY]
    The power_down() function was only defined for specific asics and will
    crash the system if it is called by an asic with eDP connected that does
    not have it defined.
    
    [HOW]
    Add a check for the function's existence before calling it.
    
    Signed-off-by: Sung Lee <sung.lee@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 079a33a96f90..6086bbec94fe 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1378,8 +1378,11 @@ void dcn10_init_hw(struct dc *dc)
 		struct dc_link *edp_link = get_edp_link(dc);
 
 		if (edp_link &&
-			edp_link->link_enc->funcs->is_dig_enabled &&
-			edp_link->link_enc->funcs->is_dig_enabled(edp_link->link_enc)) {
+				edp_link->link_enc->funcs->is_dig_enabled &&
+				edp_link->link_enc->funcs->is_dig_enabled(edp_link->link_enc) &&
+				dc->hwss.edp_backlight_control &&
+				dc->hwss.power_down &&
+				dc->hwss.edp_power_control) {
 			dc->hwss.edp_backlight_control(edp_link, false);
 			dc->hwss.power_down(dc);
 			dc->hwss.edp_power_control(edp_link, false);

commit c5f5b9d934ba897182ba7159f4d1f1ff06234e3e
Author: Xiaodong Yan <Xiaodong.Yan@amd.com>
Date:   Sun Apr 5 16:40:46 2020 -0400

    drm/amd/display: blank dp stream before power off receiver
    
    [why]
    power off dp receiver directly cause garbage during hw init
    
    [how]
    blank dp stream and then power off receiver
    
    Signed-off-by: Xiaodong Yan <Xiaodong.Yan@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index dad95f1a7041..079a33a96f90 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1328,6 +1328,14 @@ void dcn10_init_hw(struct dc *dc)
 		uint8_t dpcd_power_state = '\0';
 		enum dc_status status = DC_ERROR_UNEXPECTED;
 
+		/* blank all dp streams before power off receiver,
+		 * this should only impact DP
+		 */
+		for (i = 0; i < dc->res_pool->stream_enc_count; i++) {
+			dc->res_pool->stream_enc[i]->funcs->dp_blank(
+						dc->res_pool->stream_enc[i]);
+		}
+
 		for (i = 0; i < dc->link_count; i++) {
 			if (dc->links[i]->connector_signal != SIGNAL_TYPE_DISPLAY_PORT)
 				continue;

commit b3a941df690f4b587ca005a4fca081f7b40be198
Author: Sung Lee <sung.lee@amd.com>
Date:   Sun Apr 5 16:40:45 2020 -0400

    drm/amd/display: Power down hw blocks on boot
    
    [WHY]
    On headless boot a DIG may be turned on by VBIOS on RN.  This leads to
    display_count being non-zero in hybrid graphics cases leading to SMU
    DISPLAY_OFF message not being sent.
    
    [HOW]
    Power down hardware on boot
    if seamless boot is not occurring
    (power_down_display_on_boot == 1)
    
    Signed-off-by: Sung Lee <sung.lee@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 0be010085575..dad95f1a7041 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1361,6 +1361,35 @@ void dcn10_init_hw(struct dc *dc)
 					!dc->res_pool->hubbub->ctx->dc->debug.disable_stutter);
 	}
 
+	/* In headless boot cases, DIG may be turned
+	 * on which causes HW/SW discrepancies.
+	 * To avoid this, power down hardware on boot
+	 * if DIG is turned on and seamless boot not enabled
+	 */
+	if (dc->config.power_down_display_on_boot) {
+		struct dc_link *edp_link = get_edp_link(dc);
+
+		if (edp_link &&
+			edp_link->link_enc->funcs->is_dig_enabled &&
+			edp_link->link_enc->funcs->is_dig_enabled(edp_link->link_enc)) {
+			dc->hwss.edp_backlight_control(edp_link, false);
+			dc->hwss.power_down(dc);
+			dc->hwss.edp_power_control(edp_link, false);
+		} else {
+			for (i = 0; i < dc->link_count; i++) {
+				struct dc_link *link = dc->links[i];
+
+				if (link->link_enc->funcs->is_dig_enabled &&
+						link->link_enc->funcs->is_dig_enabled(link->link_enc) &&
+						dc->hwss.power_down) {
+					dc->hwss.power_down(dc);
+					break;
+				}
+
+			}
+		}
+	}
+
 	for (i = 0; i < res_pool->audio_count; i++) {
 		struct audio *audio = res_pool->audios[i];
 

commit 5c41c023f8b213d425af973a4dd83f5b9bc0bfb2
Author: Stylon Wang <stylon.wang@amd.com>
Date:   Tue Mar 10 15:09:29 2020 -0400

    drm/amd/display: Support plane level CTM
    
    [Why]
    CTM was only supported at CRTC level and we need color space conversion
    in linear space at plane level.
    
    [How]
    - Add plane-level CTM to dc interface
    - Program plane-level CTM in DCN
    
    Signed-off-by: Stylon Wang <stylon.wang@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 9cc3314966bd..0be010085575 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2004,6 +2004,12 @@ void dcn10_program_gamut_remap(struct pipe_ctx *pipe_ctx)
 		for (i = 0; i < CSC_TEMPERATURE_MATRIX_SIZE; i++)
 			adjust.temperature_matrix[i] =
 				pipe_ctx->stream->gamut_remap_matrix.matrix[i];
+	} else if (pipe_ctx->plane_state &&
+		   pipe_ctx->plane_state->gamut_remap_matrix.enable_remap == true) {
+		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
+		for (i = 0; i < CSC_TEMPERATURE_MATRIX_SIZE; i++)
+			adjust.temperature_matrix[i] =
+				pipe_ctx->plane_state->gamut_remap_matrix.matrix[i];
 	}
 
 	pipe_ctx->plane_res.dpp->funcs->dpp_set_gamut_remap(pipe_ctx->plane_res.dpp, &adjust);

commit 0aa63a333ddf39b180c789c995de5319122116a0
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Mar 5 13:41:43 2020 -0500

    drm/amd/display: combine watermark change and clock change for update clocks.
    
    [Why]
    underflow happened when playing video on 1366x768 + 4K clone mode due to
    incorrect handle watermark change flag and lower down clocks to early.
    
    [How]
    Check watermark change flag when decide doing optimized, and check
    optimized required flag to do clock update.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index dad732bb34d5..9cc3314966bd 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1048,7 +1048,7 @@ void dcn10_plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	if (opp != NULL)
 		opp->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;
 
-	dc->clk_optimized_required = true;
+	dc->optimized_required = true;
 
 	if (hubp->funcs->hubp_disconnect)
 		hubp->funcs->hubp_disconnect(hubp);
@@ -1099,7 +1099,7 @@ void dcn10_plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 				false);
 
 	hubp->power_gated = true;
-	dc->clk_optimized_required = false; /* We're powering off, no need to optimize */
+	dc->optimized_required = false; /* We're powering off, no need to optimize */
 
 	hws->funcs.plane_atomic_power_down(dc,
 			pipe_ctx->plane_res.dpp,

commit a19620ea917b4a080f5e3c923e2c09420099ae3e
Author: Sung Lee <sung.lee@amd.com>
Date:   Thu Jan 30 11:54:52 2020 -0500

    drm/amd/display: Program self refresh control register on boot
    
    [WHY]
    In headless boot cases, self refresh control registers are not
    programmed on boot. In certain hybrid graphics cases this may cause
    cstate entering to get blocked causing a hang.
    
    [HOW]
    Program self refresh control register on boot.
    
    Signed-off-by: Sung Lee <sung.lee@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 21c7c1b010ec..dad732bb34d5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1356,6 +1356,9 @@ void dcn10_init_hw(struct dc *dc)
 	 */
 	if (dcb->funcs->is_accelerated_mode(dcb) || dc->config.power_down_display_on_boot) {
 		hws->funcs.init_pipes(dc, dc->current_state);
+		if (dc->res_pool->hubbub->funcs->allow_self_refresh_control)
+			dc->res_pool->hubbub->funcs->allow_self_refresh_control(dc->res_pool->hubbub,
+					!dc->res_pool->hubbub->ctx->dc->debug.disable_stutter);
 	}
 
 	for (i = 0; i < res_pool->audio_count; i++) {

commit 4c631826e0bcfaefe580faeb4ef6651e5ebe57c1
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Feb 26 14:25:29 2020 -0500

    drm/amd/display: Not check wm and clk change flag in optimized bandwidth.
    
    [Why]
    System isn't able to enter S0i3 due to not send display count 0 to smu.
    When dpms off, clk changed flag is cleared alreay, and it is checked
    when doing optimized bandwidth, and update clocks is bypassed due to the
    flag is unset.
    
    [How]
    Remove check flag incide the function since watermark values and clocks
    values are checked during update to determine whether to perform it, no
    need to check it again outside the function.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 385250e1e3fd..21c7c1b010ec 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2717,30 +2717,20 @@ void dcn10_optimize_bandwidth(
 		hws->funcs.verify_allow_pstate_change_high(dc);
 
 	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
-		if (context->stream_count == 0) {
+		if (context->stream_count == 0)
 			context->bw_ctx.bw.dcn.clk.phyclk_khz = 0;
 
-			dc->clk_mgr->funcs->update_clocks(
-					dc->clk_mgr,
-					context,
-					true);
-		} else if (dc->clk_optimized_required || IS_DIAG_DC(dc->ctx->dce_environment)) {
-			dc->clk_mgr->funcs->update_clocks(
-								dc->clk_mgr,
-								context,
-								true);
-		}
-	}
-
-	if (dc->wm_optimized_required || IS_DIAG_DC(dc->ctx->dce_environment)) {
-		hubbub->funcs->program_watermarks(hubbub,
-				&context->bw_ctx.bw.dcn.watermarks,
-				dc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000,
+		dc->clk_mgr->funcs->update_clocks(
+				dc->clk_mgr,
+				context,
 				true);
 	}
 
-	dc->clk_optimized_required = false;
-	dc->wm_optimized_required = false;
+	hubbub->funcs->program_watermarks(hubbub,
+			&context->bw_ctx.bw.dcn.watermarks,
+			dc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000,
+			true);
+
 	dcn10_stereo_hw_frame_pack_wa(dc, context);
 
 	if (dc->debug.pplib_wm_report_mode == WM_REPORT_OVERRIDE)

commit d9758768a672e9e665cba4171c022e5069b71aff
Author: George Shen <george.shen@amd.com>
Date:   Thu Jan 30 15:57:36 2020 -0500

    drm/amd/display: Temporarily disable stutter on MPO transition
    
    [Why]
    Underflow sometimes occurs during transition into MPO with stutter
    enabled.
    
    [How]
    When transitioning into MPO, disable stutter. Re-enable stutter within
    one frame.
    
    Signed-off-by: George Shen <george.shen@amd.com>
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 8e29403f963a..385250e1e3fd 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2932,6 +2932,7 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct timing_generator *tg = pipe_ctx->stream_res.tg;
 	bool flip_pending;
+	struct dc *dc = plane_state->ctx->dc;
 
 	if (plane_state == NULL)
 		return;
@@ -2949,6 +2950,19 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 		plane_state->status.is_right_eye =
 				!tg->funcs->is_stereo_left_eye(pipe_ctx->stream_res.tg);
 	}
+
+	if (dc->hwseq->wa_state.disallow_self_refresh_during_multi_plane_transition_applied) {
+		struct dce_hwseq *hwseq = dc->hwseq;
+		struct timing_generator *tg = dc->res_pool->timing_generators[0];
+		unsigned int cur_frame = tg->funcs->get_frame_count(tg);
+
+		if (cur_frame != hwseq->wa_state.disallow_self_refresh_during_multi_plane_transition_applied_on_frame) {
+			struct hubbub *hubbub = dc->res_pool->hubbub;
+
+			hubbub->funcs->allow_self_refresh_control(hubbub, !dc->debug.disable_stutter);
+			hwseq->wa_state.disallow_self_refresh_during_multi_plane_transition_applied = false;
+		}
+	}
 }
 
 void dcn10_update_dchub(struct dce_hwseq *hws, struct dchub_init_data *dh_data)

commit 89e94bc57429305e089f149a6e7083e5f36f39c4
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Feb 14 12:55:55 2020 -0500

    drm/amd/display: optimize prgoram wm and clks
    
    [Why]
    In some display configuration like 1080P monitor playing a 1080P video,
    if user use ALT+F4 to exit Movie and TV, there is a chance clocks are
    same only water mark changed. Current clock optimization machanism will
    result in water mark keeps high after exit Movie and TV app.
    
    [How]
    Return if watermark need to be optimized when doing program watermark,
    perform the optimization after.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 200510859e25..8e29403f963a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1048,7 +1048,7 @@ void dcn10_plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	if (opp != NULL)
 		opp->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;
 
-	dc->optimized_required = true;
+	dc->clk_optimized_required = true;
 
 	if (hubp->funcs->hubp_disconnect)
 		hubp->funcs->hubp_disconnect(hubp);
@@ -1099,7 +1099,7 @@ void dcn10_plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 				false);
 
 	hubp->power_gated = true;
-	dc->optimized_required = false; /* We're powering off, no need to optimize */
+	dc->clk_optimized_required = false; /* We're powering off, no need to optimize */
 
 	hws->funcs.plane_atomic_power_down(dc,
 			pipe_ctx->plane_res.dpp,
@@ -2693,7 +2693,7 @@ void dcn10_prepare_bandwidth(
 				false);
 	}
 
-	hubbub->funcs->program_watermarks(hubbub,
+	dc->wm_optimized_required = hubbub->funcs->program_watermarks(hubbub,
 			&context->bw_ctx.bw.dcn.watermarks,
 			dc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000,
 			true);
@@ -2717,19 +2717,30 @@ void dcn10_optimize_bandwidth(
 		hws->funcs.verify_allow_pstate_change_high(dc);
 
 	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
-		if (context->stream_count == 0)
+		if (context->stream_count == 0) {
 			context->bw_ctx.bw.dcn.clk.phyclk_khz = 0;
 
-		dc->clk_mgr->funcs->update_clocks(
-				dc->clk_mgr,
-				context,
+			dc->clk_mgr->funcs->update_clocks(
+					dc->clk_mgr,
+					context,
+					true);
+		} else if (dc->clk_optimized_required || IS_DIAG_DC(dc->ctx->dce_environment)) {
+			dc->clk_mgr->funcs->update_clocks(
+								dc->clk_mgr,
+								context,
+								true);
+		}
+	}
+
+	if (dc->wm_optimized_required || IS_DIAG_DC(dc->ctx->dce_environment)) {
+		hubbub->funcs->program_watermarks(hubbub,
+				&context->bw_ctx.bw.dcn.watermarks,
+				dc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000,
 				true);
 	}
 
-	hubbub->funcs->program_watermarks(hubbub,
-			&context->bw_ctx.bw.dcn.watermarks,
-			dc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000,
-			true);
+	dc->clk_optimized_required = false;
+	dc->wm_optimized_required = false;
 	dcn10_stereo_hw_frame_pack_wa(dc, context);
 
 	if (dc->debug.pplib_wm_report_mode == WM_REPORT_OVERRIDE)

commit 3ebf1468ccf8ea37929fa8b123a7b7218a49f484
Author: Peikang Zhang <peikang.zhang@amd.com>
Date:   Thu Feb 13 16:05:23 2020 -0500

    drm/amd/display: Add visual confirm support for FreeSync 2 ARGB2101010
    
    [Why]
    DalMPVisualConfirm does not support FreeSync 2 ARGB2101010 which causes
    black visual confirm bar when playing HDR video on FreeSync 2 display in
    full screen mode
    
    [How]
    Added pink color for DalMPVisualConfirm on FreeSync 2 ARGB2101010
    surface
    
    Signed-off-by: Peikang Zhang <peikang.zhang@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 53083e658fe0..200510859e25 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2121,6 +2121,10 @@ void dcn10_get_hdr_visual_confirm_color(
 		if (top_pipe_ctx->stream->out_transfer_func->tf == TRANSFER_FUNCTION_PQ) {
 			/* HDR10, ARGB2101010 - set boarder color to red */
 			color->color_r_cr = color_value;
+		} else if (top_pipe_ctx->stream->out_transfer_func->tf == TRANSFER_FUNCTION_GAMMA22) {
+			/* FreeSync 2 ARGB2101010 - set boarder color to pink */
+			color->color_r_cr = color_value;
+			color->color_b_cb = color_value;
 		}
 		break;
 	case PIXEL_FORMAT_FP16:

commit 3c9de4da021c7c2aaa421b5c37057890348bd58a
Author: Alvin Lee <alvin.lee2@amd.com>
Date:   Tue Feb 4 15:19:21 2020 -0500

    drm/amd/display: Disable PG on NV12
    
    [Why]
    According to HW team, PG is dropped for NV12, but programming
    the registers will still cause power to be consumed, so don't
    program for NV12.
    
    [How]
    Set function pointer to NULL if NV12
    
    Signed-off-by: Alvin Lee <alvin.lee2@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index af40ea5765f4..53083e658fe0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1268,7 +1268,8 @@ void dcn10_init_hw(struct dc *dc)
 		}
 
 		//Enable ability to power gate / don't force power on permanently
-		hws->funcs.enable_power_gating_plane(hws, true);
+		if (hws->funcs.enable_power_gating_plane)
+			hws->funcs.enable_power_gating_plane(hws, true);
 
 		return;
 	}
@@ -1385,8 +1386,8 @@ void dcn10_init_hw(struct dc *dc)
 
 		REG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);
 	}
-
-	hws->funcs.enable_power_gating_plane(dc->hwseq, true);
+	if (hws->funcs.enable_power_gating_plane)
+		hws->funcs.enable_power_gating_plane(dc->hwseq, true);
 
 	if (dc->clk_mgr->funcs->notify_wm_ranges)
 		dc->clk_mgr->funcs->notify_wm_ranges(dc->clk_mgr);

commit f739ce5768eddbe573c8b30d8ac109de67c57d29
Author: Zhan Liu <zhan.liu@amd.com>
Date:   Fri Feb 21 17:25:47 2020 -0500

    drm/amd/display: Add aconnector condition check for dpcd read
    
    [Why]
    core_link_read_dpcd() will invoke dm_helpers_dp_read_dpcd(),
    which needs to read dpcd info with the help of aconnector.
    If aconnector (dc->links[i]->prev) is NULL, then dpcd status
     cannot be read.
    
    As a result, dpcd read fails and a line of error will be
    printed out in dmesg.log as:
    "*ERROR* Failed to found connector for link!"
    
    [How]
    Make sure that aconnector (dc->links[i]->prev) is not NULL,
    then read dpcd status.
    
    Signed-off-by: Zhan Liu <zhan.liu@amd.com>
    Reviewed-by: Joseph Gravenor <Joseph.Gravenor@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 5f56cc13d6dc..af40ea5765f4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1328,14 +1328,21 @@ void dcn10_init_hw(struct dc *dc)
 		enum dc_status status = DC_ERROR_UNEXPECTED;
 
 		for (i = 0; i < dc->link_count; i++) {
-			if (dc->links[i]->connector_signal != SIGNAL_TYPE_DISPLAY_PORT) {
+			if (dc->links[i]->connector_signal != SIGNAL_TYPE_DISPLAY_PORT)
 				continue;
-			}
-			/* if any of the displays are lit up turn them off */
-			status = core_link_read_dpcd(dc->links[i], DP_SET_POWER,
-						     &dpcd_power_state, sizeof(dpcd_power_state));
-			if (status == DC_OK && dpcd_power_state == DP_POWER_STATE_D0) {
-				dp_receiver_power_ctrl(dc->links[i], false);
+
+			/*
+			 * core_link_read_dpcd() will invoke dm_helpers_dp_read_dpcd(),
+			 * which needs to read dpcd info with the help of aconnector.
+			 * If aconnector (dc->links[i]->prev) is NULL, then dpcd status
+			 * cannot be read.
+			 */
+			if (dc->links[i]->priv) {
+				/* if any of the displays are lit up turn them off */
+				status = core_link_read_dpcd(dc->links[i], DP_SET_POWER,
+								&dpcd_power_state, sizeof(dpcd_power_state));
+				if (status == DC_OK && dpcd_power_state == DP_POWER_STATE_D0)
+					dp_receiver_power_ctrl(dc->links[i], false);
 			}
 		}
 	}

commit db70e2c13983926d8d657db3e740264b75ad20a4
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Mon Feb 10 23:08:26 2020 +0800

    drm/amd/display: Remove set but not unused variable 'stream_status'
    
    drivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_hw_sequencer.c:
     In function dcn10_post_unlock_program_front_end:
    drivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_hw_sequencer.c:2623:29:
     warning: variable stream_status set but not used [-Wunused-but-set-variable]
    
    commit bbf5f6c3f83b ("drm/amd/display: Split program front end part that occur outside lock")
    involved this unused variable.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 87e30f60cee6..5f56cc13d6dc 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2614,7 +2614,7 @@ void dcn10_post_unlock_program_front_end(
 		struct dc *dc,
 		struct dc_state *context)
 {
-	int i, j;
+	int i;
 
 	DC_LOGGER_INIT(dc->ctx->logger);
 
@@ -2624,14 +2624,8 @@ void dcn10_post_unlock_program_front_end(
 		if (!pipe_ctx->top_pipe &&
 			!pipe_ctx->prev_odm_pipe &&
 			pipe_ctx->stream) {
-			struct dc_stream_status *stream_status = NULL;
 			struct timing_generator *tg = pipe_ctx->stream_res.tg;
 
-			for (j = 0; j < context->stream_count; j++) {
-				if (pipe_ctx->stream == context->streams[j])
-					stream_status = &context->stream_status[j];
-			}
-
 			if (context->stream_status[i].plane_count == 0)
 				false_optc_underflow_wa(dc, pipe_ctx->stream, tg);
 		}

commit 7ba99b43be6527eb9bdbf137e6829d4ec4b871c6
Author: Peikang Zhang <peikang.zhang@amd.com>
Date:   Thu Jan 30 10:49:46 2020 -0500

    drm/amd/display: Toggle VSR button cause system crash
    
    [Why]
    in dcn10_apply_ctx_for_surface(), if we hit !top_pipe_to_program,
    pipe_ctx->update_flags could not get cleared.
    
    [How]
    Moved clearing pipe_ctx->update_flags logic before if
    (!top_pipe_to_program) to gurantee pipe_ctx->update_flags get cleared.
    
    Signed-off-by: Peikang Zhang <peikang.zhang@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 42fcfee2c31b..87e30f60cee6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2540,6 +2540,12 @@ void dcn10_apply_ctx_for_surface(
 			dcn10_find_top_pipe_for_stream(dc, context, stream);
 	DC_LOGGER_INIT(dc->ctx->logger);
 
+	// Clear pipe_ctx flag
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+		pipe_ctx->update_flags.raw = 0;
+	}
+
 	if (!top_pipe_to_program)
 		return;
 
@@ -2570,8 +2576,6 @@ void dcn10_apply_ctx_for_surface(
 		struct pipe_ctx *old_pipe_ctx =
 				&dc->current_state->res_ctx.pipe_ctx[i];
 
-		pipe_ctx->update_flags.raw = 0;
-
 		if ((!pipe_ctx->plane_state ||
 		     pipe_ctx->stream_res.tg != old_pipe_ctx->stream_res.tg) &&
 		    old_pipe_ctx->plane_state &&

commit 896dace8eca843100bef9b7482c3d6243b4601fb
Author: Joseph Gravenor <joseph.gravenor@amd.com>
Date:   Tue Jan 28 10:38:22 2020 -0500

    drm/amd/display: turn off the mst hub before we do detection
    
    [why]
    not turning off the mst hub before detection on reboot
    causes us to not be able to light up displays with mst hook
    
    [how]
    on hw init, see if any displays are lit up. if so, turn them off
    
    Signed-off-by: Joseph Gravenor <joseph.gravenor@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 0225f8d8bb82..42fcfee2c31b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -48,8 +48,8 @@
 #include "dc_link_dp.h"
 #include "dccg.h"
 #include "clk_mgr.h"
-
-
+#include "link_hwss.h"
+#include "dpcd_defs.h"
 #include "dsc.h"
 
 #define DC_LOGGER_INIT(logger)
@@ -1322,6 +1322,24 @@ void dcn10_init_hw(struct dc *dc)
 		if (hws->funcs.dsc_pg_control != NULL)
 			hws->funcs.dsc_pg_control(hws, res_pool->dscs[i]->inst, false);
 
+	/* we want to turn off all dp displays before doing detection */
+	if (dc->config.power_down_display_on_boot) {
+		uint8_t dpcd_power_state = '\0';
+		enum dc_status status = DC_ERROR_UNEXPECTED;
+
+		for (i = 0; i < dc->link_count; i++) {
+			if (dc->links[i]->connector_signal != SIGNAL_TYPE_DISPLAY_PORT) {
+				continue;
+			}
+			/* if any of the displays are lit up turn them off */
+			status = core_link_read_dpcd(dc->links[i], DP_SET_POWER,
+						     &dpcd_power_state, sizeof(dpcd_power_state));
+			if (status == DC_OK && dpcd_power_state == DP_POWER_STATE_D0) {
+				dp_receiver_power_ctrl(dc->links[i], false);
+			}
+		}
+	}
+
 	/* If taking control over from VBIOS, we may want to optimize our first
 	 * mode set, so we need to skip powering down pipes until we know which
 	 * pipes we want to use.

commit 9edf202d27df185e04f348c30d19a63f0ebe18d8
Author: Jing Zhou <Jing.Zhou@amd.com>
Date:   Tue Jan 21 18:05:35 2020 +0800

    drm/amd/display: external monitor abm enabled in modern standby
    
    [why]
    Resume from modern standby, edp stream disabled
    but abm keep enabled. External monitor select OTG
    source 0 which ABM enabled.
    [how]
    Disable abm before disable crtc when reset path
    mode not call core link disable stream.
    
    Signed-off-by: Jing Zhou <Jing.Zhou@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7fc559acffcd..0225f8d8bb82 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -901,6 +901,10 @@ static void dcn10_reset_back_end_for_pipe(
 	 * parent pipe.
 	 */
 	if (pipe_ctx->top_pipe == NULL) {
+
+		if (pipe_ctx->stream_res.abm)
+			pipe_ctx->stream_res.abm->funcs->set_abm_immediate_disable(pipe_ctx->stream_res.abm);
+
 		pipe_ctx->stream_res.tg->funcs->disable_crtc(pipe_ctx->stream_res.tg);
 
 		pipe_ctx->stream_res.tg->funcs->enable_optc_clock(pipe_ctx->stream_res.tg, false);

commit 009114f6df84150a567b05537aa29b9d660e419b
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Jan 14 17:04:24 2020 -0500

    drm/amd/display: Added locking for atomic update stream and update planes
    
    [Why]
    Screen flickering when HDR switches between FP16 and ARGB2101010
    
    [How]
    Moved pipe_control_lock so stream update and plane update occur atomically
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Lucy Li <lucy.li@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index a9a5a13d5edf..7fc559acffcd 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -82,7 +82,7 @@ void print_microsec(struct dc_context *dc_ctx,
 			us_x10 % frac);
 }
 
-static void dcn10_lock_all_pipes(struct dc *dc,
+void dcn10_lock_all_pipes(struct dc *dc,
 	struct dc_state *context,
 	bool lock)
 {
@@ -93,6 +93,7 @@ static void dcn10_lock_all_pipes(struct dc *dc,
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		pipe_ctx = &context->res_ctx.pipe_ctx[i];
 		tg = pipe_ctx->stream_res.tg;
+
 		/*
 		 * Only lock the top pipe's tg to prevent redundant
 		 * (un)locking. Also skip if pipe is disabled.
@@ -103,9 +104,9 @@ static void dcn10_lock_all_pipes(struct dc *dc,
 			continue;
 
 		if (lock)
-			tg->funcs->lock(tg);
+			dc->hwss.pipe_control_lock(dc, pipe_ctx, true);
 		else
-			tg->funcs->unlock(tg);
+			dc->hwss.pipe_control_lock(dc, pipe_ctx, false);
 	}
 }
 
@@ -1576,7 +1577,7 @@ void dcn10_pipe_control_lock(
 	/* use TG master update lock to lock everything on the TG
 	 * therefore only top pipe need to lock
 	 */
-	if (pipe->top_pipe)
+	if (!pipe || pipe->top_pipe)
 		return;
 
 	if (dc->debug.sanity_checks)
@@ -2530,11 +2531,6 @@ void dcn10_apply_ctx_for_surface(
 	if (underflow_check_delay_us != 0xFFFFFFFF && hws->funcs.did_underflow_occur)
 		ASSERT(hws->funcs.did_underflow_occur(dc, top_pipe_to_program));
 
-	if (interdependent_update)
-		dcn10_lock_all_pipes(dc, context, true);
-	else
-		dcn10_pipe_control_lock(dc, top_pipe_to_program, true);
-
 	if (underflow_check_delay_us != 0xFFFFFFFF)
 		udelay(underflow_check_delay_us);
 
@@ -2554,19 +2550,6 @@ void dcn10_apply_ctx_for_surface(
 
 		pipe_ctx->update_flags.raw = 0;
 
-		/*
-		 * Powergate reused pipes that are not powergated
-		 * fairly hacky right now, using opp_id as indicator
-		 * TODO: After move dc_post to dc_update, this will
-		 * be removed.
-		 */
-		if (pipe_ctx->plane_state && !old_pipe_ctx->plane_state) {
-			if (old_pipe_ctx->stream_res.tg == tg &&
-			    old_pipe_ctx->plane_res.hubp &&
-			    old_pipe_ctx->plane_res.hubp->opp_id != OPP_ID_INVALID)
-				dc->hwss.disable_plane(dc, old_pipe_ctx);
-		}
-
 		if ((!pipe_ctx->plane_state ||
 		     pipe_ctx->stream_res.tg != old_pipe_ctx->stream_res.tg) &&
 		    old_pipe_ctx->plane_state &&
@@ -2599,11 +2582,6 @@ void dcn10_apply_ctx_for_surface(
 				&pipe_ctx->dlg_regs,
 				&pipe_ctx->ttu_regs);
 		}
-
-	if (interdependent_update)
-		dcn10_lock_all_pipes(dc, context, false);
-	else
-		dcn10_pipe_control_lock(dc, top_pipe_to_program, false);
 }
 
 void dcn10_post_unlock_program_front_end(

commit bbf5f6c3f83bedd71006473849138a446ad4d9a3
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Jan 14 16:23:31 2020 -0500

    drm/amd/display: Split program front end part that occur outside lock
    
    [Why]
    Eventually want to lock at a higher level in stack.
    To do this, we need to be able to isolate the parts that need to be done
    after pipe unlock.
    
    [How]
    Split out programming that is done post unlock.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 1008ac8a0f2a..a9a5a13d5edf 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2512,7 +2512,6 @@ void dcn10_apply_ctx_for_surface(
 	int i;
 	struct timing_generator *tg;
 	uint32_t underflow_check_delay_us;
-	bool removed_pipe[4] = { false };
 	bool interdependent_update = false;
 	struct pipe_ctx *top_pipe_to_program =
 			dcn10_find_top_pipe_for_stream(dc, context, stream);
@@ -2552,6 +2551,9 @@ void dcn10_apply_ctx_for_surface(
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *old_pipe_ctx =
 				&dc->current_state->res_ctx.pipe_ctx[i];
+
+		pipe_ctx->update_flags.raw = 0;
+
 		/*
 		 * Powergate reused pipes that are not powergated
 		 * fairly hacky right now, using opp_id as indicator
@@ -2571,7 +2573,7 @@ void dcn10_apply_ctx_for_surface(
 		    old_pipe_ctx->stream_res.tg == tg) {
 
 			hws->funcs.plane_atomic_disconnect(dc, old_pipe_ctx);
-			removed_pipe[i] = true;
+			pipe_ctx->update_flags.bits.disable = 1;
 
 			DC_LOG_DC("Reset mpcc for pipe %d\n",
 					old_pipe_ctx->pipe_idx);
@@ -2602,16 +2604,41 @@ void dcn10_apply_ctx_for_surface(
 		dcn10_lock_all_pipes(dc, context, false);
 	else
 		dcn10_pipe_control_lock(dc, top_pipe_to_program, false);
+}
+
+void dcn10_post_unlock_program_front_end(
+		struct dc *dc,
+		struct dc_state *context)
+{
+	int i, j;
+
+	DC_LOGGER_INIT(dc->ctx->logger);
 
-	if (num_planes == 0)
-		false_optc_underflow_wa(dc, stream, tg);
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (!pipe_ctx->top_pipe &&
+			!pipe_ctx->prev_odm_pipe &&
+			pipe_ctx->stream) {
+			struct dc_stream_status *stream_status = NULL;
+			struct timing_generator *tg = pipe_ctx->stream_res.tg;
+
+			for (j = 0; j < context->stream_count; j++) {
+				if (pipe_ctx->stream == context->streams[j])
+					stream_status = &context->stream_status[j];
+			}
+
+			if (context->stream_status[i].plane_count == 0)
+				false_optc_underflow_wa(dc, pipe_ctx->stream, tg);
+		}
+	}
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++)
-		if (removed_pipe[i])
+		if (context->res_ctx.pipe_ctx[i].update_flags.bits.disable)
 			dc->hwss.disable_plane(dc, &dc->current_state->res_ctx.pipe_ctx[i]);
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++)
-		if (removed_pipe[i]) {
+		if (context->res_ctx.pipe_ctx[i].update_flags.bits.disable) {
 			dc->hwss.optimize_bandwidth(dc, context);
 			break;
 		}

commit c6a228be7f440ad5c341b3039f6033d4a8f070a4
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Thu Jan 30 13:29:05 2020 -0500

    drm/amd/display: Only enable cursor on pipes that need it
    
    [Why]
    In current code we're essentially drawing the cursor on every pipe
    that contains it. This only works when the planes have the same
    scaling for src to dest rect, otherwise we'll get "double cursor" where
    one cursor is incorrectly filtered and offset from the real position.
    
    [How]
    Without dedicated cursor planes on DCN we require at least one pipe
    that matches the scaling of the current timing.
    
    This is an optimization and workaround for the most common case where
    the top-most plane is not scaled but the bottom-most plane is scaled.
    
    Whenever a pipe has a parent pipe in the blending tree whose recout
    fully contains the current pipe we can disable the pipe.
    
    This only applies when the pipe is actually visible of course.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f2127afb37b2..1008ac8a0f2a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2911,6 +2911,33 @@ void dcn10_update_dchub(struct dce_hwseq *hws, struct dchub_init_data *dh_data)
 	hubbub->funcs->update_dchub(hubbub, dh_data);
 }
 
+static bool dcn10_can_pipe_disable_cursor(struct pipe_ctx *pipe_ctx)
+{
+	struct pipe_ctx *test_pipe;
+	const struct rect *r1 = &pipe_ctx->plane_res.scl_data.recout, *r2;
+	int r1_r = r1->x + r1->width, r1_b = r1->y + r1->height, r2_r, r2_b;
+
+	/**
+	 * Disable the cursor if there's another pipe above this with a
+	 * plane that contains this pipe's viewport to prevent double cursor
+	 * and incorrect scaling artifacts.
+	 */
+	for (test_pipe = pipe_ctx->top_pipe; test_pipe;
+	     test_pipe = test_pipe->top_pipe) {
+		if (!test_pipe->plane_state->visible)
+			continue;
+
+		r2 = &test_pipe->plane_res.scl_data.recout;
+		r2_r = r2->x + r2->width;
+		r2_b = r2->y + r2->height;
+
+		if (r1->x >= r2->x && r1->y >= r2->y && r1_r <= r2_r && r1_b <= r2_b)
+			return true;
+	}
+
+	return false;
+}
+
 void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_cursor_position pos_cpy = pipe_ctx->stream->cursor_position;
@@ -2956,6 +2983,9 @@ void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 			== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)
 		pos_cpy.enable = false;
 
+	if (pos_cpy.enable && dcn10_can_pipe_disable_cursor(pipe_ctx))
+		pos_cpy.enable = false;
+
 	// Swap axis and mirror horizontally
 	if (param.rotation == ROTATION_ANGLE_90) {
 		uint32_t temp_x = pos_cpy.x;

commit 9f21f3792ffb669623cbad8b084f75aa49c98786
Author: Alvin Lee <alvin.lee2@amd.com>
Date:   Mon Dec 30 14:29:06 2019 -0500

    drm/amd/display: Enable double buffer for OTG_BLANK
    
    [Why]
    Currently if seamless boot is enabled, we will skip double buffer enable
    for OTG_BLANK. However, we need the double buffer enable in order to
    block global sync signals when OTG becomes blanked (for PSR). Blocking
    global sync signals prevent pipe from requesting data.
    
    [How]
    Move tg_init before seamless boot check.
    
    Signed-off-by: Alvin Lee <alvin.lee2@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 5347a85f10d7..f2127afb37b2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1188,8 +1188,14 @@ void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 		if (can_apply_seamless_boot &&
 			pipe_ctx->stream != NULL &&
 			pipe_ctx->stream_res.tg->funcs->is_tg_enabled(
-				pipe_ctx->stream_res.tg))
+				pipe_ctx->stream_res.tg)) {
+			// Enable double buffering for OTG_BLANK no matter if
+			// seamless boot is enabled or not to suppress global sync
+			// signals when OTG blanked. This is to prevent pipe from
+			// requesting data while in PSR.
+			tg->funcs->tg_init(tg);
 			continue;
+		}
 
 		/* Disable on the current state so the new one isn't cleared. */
 		pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];

commit 5b5abe9526073ccbf3032d27b5864520829cdd9c
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Mon Dec 9 17:26:34 2019 -0500

    drm/amd/display: make PSR static screen entry within 30 ms
    
    [Why]
    With different refresh rate panels, the PSR entry/exit time is
    different since it is dependent on 2 frame entry time today
    
    [How]
    Make static screen num frame entry time to be calculated
    such that entry time is within 30 ms instead of fixed num
    frames.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 2baff3cd0ae5..5347a85f10d7 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2704,6 +2704,8 @@ void dcn10_set_drr(struct pipe_ctx **pipe_ctx,
 	struct drr_params params = {0};
 	// DRR set trigger event mapped to OTG_TRIG_A (bit 11) for manual control flow
 	unsigned int event_triggers = 0x800;
+	// Note DRR trigger events are generated regardless of whether num frames met.
+	unsigned int num_frames = 2;
 
 	params.vertical_total_max = vmax;
 	params.vertical_total_min = vmin;
@@ -2720,7 +2722,7 @@ void dcn10_set_drr(struct pipe_ctx **pipe_ctx,
 		if (vmax != 0 && vmin != 0)
 			pipe_ctx[i]->stream_res.tg->funcs->set_static_screen_control(
 					pipe_ctx[i]->stream_res.tg,
-					event_triggers);
+					event_triggers, num_frames);
 	}
 }
 
@@ -2737,21 +2739,22 @@ void dcn10_get_position(struct pipe_ctx **pipe_ctx,
 }
 
 void dcn10_set_static_screen_control(struct pipe_ctx **pipe_ctx,
-		int num_pipes, const struct dc_static_screen_events *events)
+		int num_pipes, const struct dc_static_screen_params *params)
 {
 	unsigned int i;
-	unsigned int value = 0;
+	unsigned int triggers = 0;
 
-	if (events->surface_update)
-		value |= 0x80;
-	if (events->cursor_update)
-		value |= 0x2;
-	if (events->force_trigger)
-		value |= 0x1;
+	if (params->triggers.surface_update)
+		triggers |= 0x80;
+	if (params->triggers.cursor_update)
+		triggers |= 0x2;
+	if (params->triggers.force_trigger)
+		triggers |= 0x1;
 
 	for (i = 0; i < num_pipes; i++)
 		pipe_ctx[i]->stream_res.tg->funcs->
-			set_static_screen_control(pipe_ctx[i]->stream_res.tg, value);
+			set_static_screen_control(pipe_ctx[i]->stream_res.tg,
+					triggers, params->num_frames);
 }
 
 static void dcn10_config_stereo_parameters(

commit 0ee600a7ec3572ac2ed3f43887dc79113eb44f17
Author: zhengbin <zhengbin13@huawei.com>
Date:   Tue Dec 24 11:27:37 2019 +0800

    drm/amd/display: use true, false for bool variable in dcn10_hw_sequencer.c
    
    Fixes coccicheck warning:
    
    drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c:482:6-14: WARNING: Assignment of 0/1 to bool variable
    drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c:485:2-10: WARNING: Assignment of 0/1 to bool variable
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: zhengbin <zhengbin13@huawei.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 9c55e4897fca..2baff3cd0ae5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -479,10 +479,10 @@ void dcn10_enable_power_gating_plane(
 	struct dce_hwseq *hws,
 	bool enable)
 {
-	bool force_on = 1; /* disable power gating */
+	bool force_on = true; /* disable power gating */
 
 	if (enable)
-		force_on = 0;
+		force_on = false;
 
 	/* DCHUBP0/1/2/3 */
 	REG_UPDATE(DOMAIN0_PG_CONFIG, DOMAIN0_POWER_FORCEON, force_on);

commit 64267454273ac8203aa3f4c0a9ca71193884e862
Author: Samson Tam <Samson.Tam@amd.com>
Date:   Wed Dec 4 18:35:15 2019 -0500

    drm/amd/display: fix missing cursor on some rotated SLS displays
    
    [Why]
    Cursor disappears for some SLS displays that are rotated 180
    and 270 degrees.  This occurs when there is no pipe split being
    done ( ex. 3 or more displays ).  The cursor calculations assume
    pipe splitting is done so when it calculates the new cursor
    position in hwss.set_cursor_position(), it is out-of-bounds so
    it disables the cursor in hubp.set_cursor_position().
    
    [How]
    In non pipe split cases, calculate cursor using viewport size
    ( width or height ) instead of viewport size * 2 ( the two
    because pipe splitting divides the rectangle into two ).
    
    Signed-off-by: Samson Tam <Samson.Tam@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 9e53bbd5d2b5..9c55e4897fca 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2916,6 +2916,8 @@ void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 		.rotation = pipe_ctx->plane_state->rotation,
 		.mirror = pipe_ctx->plane_state->horizontal_mirror
 	};
+	bool pipe_split_on = (pipe_ctx->top_pipe != NULL) ||
+		(pipe_ctx->bottom_pipe != NULL);
 
 	int x_plane = pipe_ctx->plane_state->dst_rect.x;
 	int y_plane = pipe_ctx->plane_state->dst_rect.y;
@@ -2948,6 +2950,7 @@ void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 	// Swap axis and mirror horizontally
 	if (param.rotation == ROTATION_ANGLE_90) {
 		uint32_t temp_x = pos_cpy.x;
+
 		pos_cpy.x = pipe_ctx->plane_res.scl_data.viewport.width -
 				(pos_cpy.y - pipe_ctx->plane_res.scl_data.viewport.x) + pipe_ctx->plane_res.scl_data.viewport.x;
 		pos_cpy.y = temp_x;
@@ -2955,26 +2958,44 @@ void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 	// Swap axis and mirror vertically
 	else if (param.rotation == ROTATION_ANGLE_270) {
 		uint32_t temp_y = pos_cpy.y;
-		if (pos_cpy.x >  pipe_ctx->plane_res.scl_data.viewport.height) {
-			pos_cpy.x = pos_cpy.x - pipe_ctx->plane_res.scl_data.viewport.height;
-			pos_cpy.y = pipe_ctx->plane_res.scl_data.viewport.height - pos_cpy.x;
-		} else {
-			pos_cpy.y = 2 * pipe_ctx->plane_res.scl_data.viewport.height - pos_cpy.x;
-		}
+		int viewport_height =
+			pipe_ctx->plane_res.scl_data.viewport.height;
+
+		if (pipe_split_on) {
+			if (pos_cpy.x > viewport_height) {
+				pos_cpy.x = pos_cpy.x - viewport_height;
+				pos_cpy.y = viewport_height - pos_cpy.x;
+			} else {
+				pos_cpy.y = 2 * viewport_height - pos_cpy.x;
+			}
+		} else
+			pos_cpy.y = viewport_height - pos_cpy.x;
 		pos_cpy.x = temp_y;
 	}
 	// Mirror horizontally and vertically
 	else if (param.rotation == ROTATION_ANGLE_180) {
-		if (pos_cpy.x >= pipe_ctx->plane_res.scl_data.viewport.width + pipe_ctx->plane_res.scl_data.viewport.x) {
-			pos_cpy.x = 2 * pipe_ctx->plane_res.scl_data.viewport.width
-					- pos_cpy.x + 2 * pipe_ctx->plane_res.scl_data.viewport.x;
-		} else {
-			uint32_t temp_x = pos_cpy.x;
-			pos_cpy.x = 2 * pipe_ctx->plane_res.scl_data.viewport.x - pos_cpy.x;
-			if (temp_x >= pipe_ctx->plane_res.scl_data.viewport.x + (int)hubp->curs_attr.width
-					|| pos_cpy.x <= (int)hubp->curs_attr.width + pipe_ctx->plane_state->src_rect.x) {
-				pos_cpy.x = temp_x + pipe_ctx->plane_res.scl_data.viewport.width;
+		int viewport_width =
+			pipe_ctx->plane_res.scl_data.viewport.width;
+		int viewport_x =
+			pipe_ctx->plane_res.scl_data.viewport.x;
+
+		if (pipe_split_on) {
+			if (pos_cpy.x >= viewport_width + viewport_x) {
+				pos_cpy.x = 2 * viewport_width
+						- pos_cpy.x + 2 * viewport_x;
+			} else {
+				uint32_t temp_x = pos_cpy.x;
+
+				pos_cpy.x = 2 * viewport_x - pos_cpy.x;
+				if (temp_x >= viewport_x +
+					(int)hubp->curs_attr.width || pos_cpy.x
+					<= (int)hubp->curs_attr.width +
+					pipe_ctx->plane_state->src_rect.x) {
+					pos_cpy.x = temp_x + viewport_width;
+				}
 			}
+		} else {
+			pos_cpy.x = viewport_width - pos_cpy.x + 2 * viewport_x;
 		}
 		pos_cpy.y = pipe_ctx->plane_res.scl_data.viewport.height - pos_cpy.y;
 	}

commit 1380c1bf5b9c31baf820ab545bbabf6b39bfdc0d
Author: Noah Abradjian <noah.abradjian@amd.com>
Date:   Fri Nov 29 13:48:36 2019 -0500

    drm/amd/display: Remove reliance on pipe indexing
    
    [Why]
    In certain instances, there was a reliance on pipe indexing being accurate. However, this
    assumption fails with harvesting of pipes 1 or 2, which can occur in production B6 parts.
    HW hang would occur as a result.
    
    [How]
    Use hubp index for mpcc, and do mpc_init for all theoretical pipes (including disabled ones).
    
    Signed-off-by: Noah Abradjian <noah.abradjian@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index aa389dea279d..9e53bbd5d2b5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1163,7 +1163,8 @@ void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 		}
 	}
 
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+	/* num_opp will be equal to number of mpcc */
+	for (i = 0; i < dc->res_pool->res_cap->num_opp; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		/* Cannot reset the MPC mux if seamless boot */

commit efca090560815fdda03f5403e3f9cae2c8eca301
Author: Paul Hsieh <paul.hsieh@amd.com>
Date:   Thu Nov 28 10:44:39 2019 +0800

    drm/amd/display: check link status before disable stream
    
    [Why]
    1. Set second screen only then unplug external monitor
    2. Enter to S4 then plug in external monitor
    3. Resume from S4, eDP will not turn off when OS set
       second screen only
    Sometimes OS will not set eDP power up cause eDP dpms_off
    keep true then driver skipp disable stream
    
    [How]
    When drvier try to disable stream, add link status condition
    
    Signed-off-by: Paul Hsieh <paul.hsieh@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c9f7c0af58e3..aa389dea279d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -860,6 +860,7 @@ static void dcn10_reset_back_end_for_pipe(
 		struct dc_state *context)
 {
 	int i;
+	struct dc_link *link;
 	DC_LOGGER_INIT(dc->ctx->logger);
 	if (pipe_ctx->stream_res.stream_enc == NULL) {
 		pipe_ctx->stream = NULL;
@@ -867,8 +868,14 @@ static void dcn10_reset_back_end_for_pipe(
 	}
 
 	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
-		/* DPMS may already disable */
-		if (!pipe_ctx->stream->dpms_off)
+		link = pipe_ctx->stream->link;
+		/* DPMS may already disable or */
+		/* dpms_off status is incorrect due to fastboot
+		 * feature. When system resume from S4 with second
+		 * screen only, the dpms_off would be true but
+		 * VBIOS lit up eDP, so check link status too.
+		 */
+		if (!pipe_ctx->stream->dpms_off || link->link_status.link_active)
 			core_link_disable_stream(pipe_ctx);
 		else if (pipe_ctx->stream_res.audio)
 			dc->hwss.disable_audio_stream(pipe_ctx);

commit cf27a6d15d950ed1beb3926469c9eaa6907bbf88
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Mon Nov 18 15:41:19 2019 -0500

    drm/amd/display: update chroma viewport wa
    
    [Why]
    Need previously implemented chroma vp wa to work for rotation cases.
    
    [How]
    Implement rotation specific wa.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 3996fef56948..c9f7c0af58e3 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2291,8 +2291,7 @@ static void dcn10_update_dchubp_dpp(
 		hubp->funcs->mem_program_viewport(
 			hubp,
 			&pipe_ctx->plane_res.scl_data.viewport,
-			&pipe_ctx->plane_res.scl_data.viewport_c,
-			plane_state->rotation);
+			&pipe_ctx->plane_res.scl_data.viewport_c);
 	}
 
 	if (pipe_ctx->stream->cursor_attributes.address.quad_part != 0) {

commit 186a1fb79c6ce6b52eaa168c64d5f5964a3bd645
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Fri Nov 15 10:00:46 2019 -0500

    drm/amd/display: Change HDR_MULT check
    
    [Why]
    Currently we require HDR_MULT >= 1.0
    There are scenarios where we need < 1.0
    
    [How]
    Only guard against 0 - it will black-screen image.
    It is up to higher-level logic to decide what HDR_MULT
    values are allowed in each particular case.
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 61d2f1233f8c..3996fef56948 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2390,17 +2390,13 @@ void dcn10_set_hdr_multiplier(struct pipe_ctx *pipe_ctx)
 	struct fixed31_32 multiplier = pipe_ctx->plane_state->hdr_mult;
 	uint32_t hw_mult = 0x1f000; // 1.0 default multiplier
 	struct custom_float_format fmt;
-	bool mult_negative; // True if fixed31_32 sign bit indicates negative value
-	uint32_t mult_int; // int component of fixed31_32
 
 	fmt.exponenta_bits = 6;
 	fmt.mantissa_bits = 12;
 	fmt.sign = true;
 
-	mult_negative = multiplier.value >> 63 != 0;
-	mult_int = multiplier.value >> 32;
 
-	if (mult_int && !mult_negative) // Check if greater than 1
+	if (!dc_fixpt_eq(multiplier, dc_fixpt_from_int(0))) // check != 0
 		convert_to_custom_float_format(multiplier, &fmt, &hw_mult);
 
 	pipe_ctx->plane_res.dpp->funcs->dpp_set_hdr_multiplier(

commit 4ed79864de180ff2d39da26305e2a7e9c72bc38e
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Sat Nov 9 18:30:40 2019 -0500

    drm/amd/display: fix cursor positioning for multiplane cases
    
    [Why]
    Cursor position needs to take into account plane scaling as well.
    
    [How]
    Translate cursor coords from stream space to plane space.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 9551fefb9d1d..61d2f1233f8c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2913,15 +2913,30 @@ void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 		.rotation = pipe_ctx->plane_state->rotation,
 		.mirror = pipe_ctx->plane_state->horizontal_mirror
 	};
-	uint32_t x_plane = pipe_ctx->plane_state->dst_rect.x;
-	uint32_t y_plane = pipe_ctx->plane_state->dst_rect.y;
-	uint32_t x_offset = min(x_plane, pos_cpy.x);
-	uint32_t y_offset = min(y_plane, pos_cpy.y);
-
-	pos_cpy.x -= x_offset;
-	pos_cpy.y -= y_offset;
-	pos_cpy.x_hotspot += (x_plane - x_offset);
-	pos_cpy.y_hotspot += (y_plane - y_offset);
+
+	int x_plane = pipe_ctx->plane_state->dst_rect.x;
+	int y_plane = pipe_ctx->plane_state->dst_rect.y;
+	int x_pos = pos_cpy.x;
+	int y_pos = pos_cpy.y;
+
+	// translate cursor from stream space to plane space
+	x_pos = (x_pos - x_plane) * pipe_ctx->plane_state->src_rect.width /
+			pipe_ctx->plane_state->dst_rect.width;
+	y_pos = (y_pos - y_plane) * pipe_ctx->plane_state->src_rect.height /
+			pipe_ctx->plane_state->dst_rect.height;
+
+	if (x_pos < 0) {
+		pos_cpy.x_hotspot -= x_pos;
+		x_pos = 0;
+	}
+
+	if (y_pos < 0) {
+		pos_cpy.y_hotspot -= y_pos;
+		y_pos = 0;
+	}
+
+	pos_cpy.x = (uint32_t)x_pos;
+	pos_cpy.y = (uint32_t)y_pos;
 
 	if (pipe_ctx->plane_state->address.type
 			== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)

commit 2853ecc6610af9e40b6686498330b64a780cb181
Author: Reza Amini <Reza.Amini@amd.com>
Date:   Thu Nov 7 10:10:45 2019 -0500

    drm/amd/display: Implement DePQ for DCN1
    
    [Why]
    Need support for more color management in 10bit
    surface.
    
    [How]
    Provide support for DePQ for 10bit surface
    
    Signed-off-by: Reza Amini <Reza.Amini@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 2440e28493e7..9551fefb9d1d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1465,6 +1465,11 @@ bool dcn10_set_input_transfer_func(struct dc *dc, struct pipe_ctx *pipe_ctx,
 			dpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);
 			break;
 		case TRANSFER_FUNCTION_PQ:
+			dpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_USER_PWL);
+			cm_helper_translate_curve_to_degamma_hw_format(tf, &dpp_base->degamma_params);
+			dpp_base->funcs->dpp_program_degamma_pwl(dpp_base, &dpp_base->degamma_params);
+			result = true;
+			break;
 		default:
 			result = false;
 			break;

commit 1ba2a48305715f5832fac023ddc0d4ceba7a8491
Author: Michael Strauss <michael.strauss@amd.com>
Date:   Sun Nov 10 15:22:15 2019 -0500

    drm/amd/display: Disable chroma viewport w/a when rotated 180 degrees
    
    [WHY]
    Previous Renoir chroma viewport workaround fixed an MPO flicker by
    increasing the chroma viewport size. However, when the MPO plane is
    rotated 180 degrees, the viewport is read in reverse. Since the workaround
    increases viewport size, when reading in reverse it causes a vertical
    chroma offset.
    
    [HOW]
    Pass rotation value to viewport set functions
    Temporarily disable the chroma viewport w/a when hubp is rotated 180 degrees
    
    Signed-off-by: Michael Strauss <michael.strauss@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 2b3081ee0e07..2440e28493e7 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2286,7 +2286,8 @@ static void dcn10_update_dchubp_dpp(
 		hubp->funcs->mem_program_viewport(
 			hubp,
 			&pipe_ctx->plane_res.scl_data.viewport,
-			&pipe_ctx->plane_res.scl_data.viewport_c);
+			&pipe_ctx->plane_res.scl_data.viewport_c,
+			plane_state->rotation);
 	}
 
 	if (pipe_ctx->stream->cursor_attributes.address.quad_part != 0) {

commit f42ea55be1114768e36c4e8dff4400ca811309cf
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Nov 5 13:17:30 2019 -0500

    drm/amd/display: add separate of private hwss functions
    
    [Why]
    Some function pointers in the hwss function pointer table are
    meant to be hw sequencer entry points to be called from dc.
    
    However some of those function pointers are not meant to
    be entry points, but instead used as a code reuse/inheritance
    tool called directly by other hwss functions, not by dc.
    
    Therefore, we want a more clear separation of which functions
    we determine to be interface functions vs the functions we
    use within hwss.
    
    [How]
    DC interface functions will be stored in:
        struct hw_sequencer_funcs
    Functions used within HWSS will be stored in:
        struct hwseq_private_funcs
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index bd6cdb6b38f6..2b3081ee0e07 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -642,8 +642,8 @@ static void power_on_plane(
 	if (REG(DC_IP_REQUEST_CNTL)) {
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 1);
-		hws->ctx->dc->hwss.dpp_pg_control(hws, plane_id, true);
-		hws->ctx->dc->hwss.hubp_pg_control(hws, plane_id, true);
+		hws->funcs.dpp_pg_control(hws, plane_id, true);
+		hws->funcs.hubp_pg_control(hws, plane_id, true);
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 0);
 		DC_LOG_DEBUG(
@@ -664,7 +664,7 @@ static void undo_DEGVIDCN10_253_wa(struct dc *dc)
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 1);
 
-	dc->hwss.hubp_pg_control(hws, 0, false);
+	hws->funcs.hubp_pg_control(hws, 0, false);
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
 
@@ -693,7 +693,7 @@ static void apply_DEGVIDCN10_253_wa(struct dc *dc)
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 1);
 
-	dc->hwss.hubp_pg_control(hws, 0, true);
+	hws->funcs.hubp_pg_control(hws, 0, true);
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
 
@@ -703,12 +703,14 @@ static void apply_DEGVIDCN10_253_wa(struct dc *dc)
 
 void dcn10_bios_golden_init(struct dc *dc)
 {
+	struct dce_hwseq *hws = dc->hwseq;
 	struct dc_bios *bp = dc->ctx->dc_bios;
 	int i;
 	bool allow_self_fresh_force_enable = true;
 
-	if (dc->hwss.s0i3_golden_init_wa && dc->hwss.s0i3_golden_init_wa(dc))
+	if (hws->funcs.s0i3_golden_init_wa && hws->funcs.s0i3_golden_init_wa(dc))
 		return;
+
 	if (dc->res_pool->hubbub->funcs->is_allow_self_refresh_enabled)
 		allow_self_fresh_force_enable =
 				dc->res_pool->hubbub->funcs->is_allow_self_refresh_enabled(dc->res_pool->hubbub);
@@ -1015,6 +1017,7 @@ void dcn10_verify_allow_pstate_change_high(struct dc *dc)
 /* trigger HW to start disconnect plane from stream on the next vsync */
 void dcn10_plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
+	struct dce_hwseq *hws = dc->hwseq;
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	int dpp_id = pipe_ctx->plane_res.dpp->inst;
 	struct mpc *mpc = dc->res_pool->mpc;
@@ -1039,7 +1042,7 @@ void dcn10_plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 		hubp->funcs->hubp_disconnect(hubp);
 
 	if (dc->debug.sanity_checks)
-		dc->hwss.verify_allow_pstate_change_high(dc);
+		hws->funcs.verify_allow_pstate_change_high(dc);
 }
 
 void dcn10_plane_atomic_power_down(struct dc *dc,
@@ -1052,8 +1055,8 @@ void dcn10_plane_atomic_power_down(struct dc *dc,
 	if (REG(DC_IP_REQUEST_CNTL)) {
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 1);
-		dc->hwss.dpp_pg_control(hws, dpp->inst, false);
-		dc->hwss.hubp_pg_control(hws, hubp->inst, false);
+		hws->funcs.dpp_pg_control(hws, dpp->inst, false);
+		hws->funcs.hubp_pg_control(hws, hubp->inst, false);
 		dpp->funcs->dpp_reset(dpp);
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 0);
@@ -1067,6 +1070,7 @@ void dcn10_plane_atomic_power_down(struct dc *dc,
  */
 void dcn10_plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
+	struct dce_hwseq *hws = dc->hwseq;
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 	int opp_id = hubp->opp_id;
@@ -1085,7 +1089,7 @@ void dcn10_plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	hubp->power_gated = true;
 	dc->optimized_required = false; /* We're powering off, no need to optimize */
 
-	dc->hwss.plane_atomic_power_down(dc,
+	hws->funcs.plane_atomic_power_down(dc,
 			pipe_ctx->plane_res.dpp,
 			pipe_ctx->plane_res.hubp);
 
@@ -1099,12 +1103,13 @@ void dcn10_plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 
 void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
+	struct dce_hwseq *hws = dc->hwseq;
 	DC_LOGGER_INIT(dc->ctx->logger);
 
 	if (!pipe_ctx->plane_res.hubp || pipe_ctx->plane_res.hubp->power_gated)
 		return;
 
-	dc->hwss.plane_atomic_disable(dc, pipe_ctx);
+	hws->funcs.plane_atomic_disable(dc, pipe_ctx);
 
 	apply_DEGVIDCN10_253_wa(dc);
 
@@ -1115,6 +1120,7 @@ void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
 void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 {
 	int i;
+	struct dce_hwseq *hws = dc->hwseq;
 	bool can_apply_seamless_boot = false;
 
 	for (i = 0; i < context->stream_count; i++) {
@@ -1139,8 +1145,8 @@ void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 		 * command table.
 		 */
 		if (tg->funcs->is_tg_enabled(tg)) {
-			if (dc->hwss.init_blank != NULL) {
-				dc->hwss.init_blank(dc, tg);
+			if (hws->funcs.init_blank != NULL) {
+				hws->funcs.init_blank(dc, tg);
 				tg->funcs->lock(tg);
 			} else {
 				tg->funcs->lock(tg);
@@ -1197,7 +1203,7 @@ void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 		dc->res_pool->opps[i]->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;
 		pipe_ctx->stream_res.opp = dc->res_pool->opps[i];
 
-		dc->hwss.plane_atomic_disconnect(dc, pipe_ctx);
+		hws->funcs.plane_atomic_disconnect(dc, pipe_ctx);
 
 		if (tg->funcs->is_tg_enabled(tg))
 			tg->funcs->unlock(tg);
@@ -1243,15 +1249,15 @@ void dcn10_init_hw(struct dc *dc)
 		}
 
 		//Enable ability to power gate / don't force power on permanently
-		dc->hwss.enable_power_gating_plane(hws, true);
+		hws->funcs.enable_power_gating_plane(hws, true);
 
 		return;
 	}
 
 	if (!dcb->funcs->is_accelerated_mode(dcb))
-		dc->hwss.disable_vga(dc->hwseq);
+		hws->funcs.disable_vga(dc->hwseq);
 
-	dc->hwss.bios_golden_init(dc);
+	hws->funcs.bios_golden_init(dc);
 	if (dc->ctx->dc_bios->fw_info_valid) {
 		res_pool->ref_clocks.xtalin_clock_inKhz =
 				dc->ctx->dc_bios->fw_info.pll_info.crystal_frequency;
@@ -1294,8 +1300,8 @@ void dcn10_init_hw(struct dc *dc)
 
 	/* Power gate DSCs */
 	for (i = 0; i < res_pool->res_cap->num_dsc; i++)
-		if (dc->hwss.dsc_pg_control != NULL)
-			dc->hwss.dsc_pg_control(hws, res_pool->dscs[i]->inst, false);
+		if (hws->funcs.dsc_pg_control != NULL)
+			hws->funcs.dsc_pg_control(hws, res_pool->dscs[i]->inst, false);
 
 	/* If taking control over from VBIOS, we may want to optimize our first
 	 * mode set, so we need to skip powering down pipes until we know which
@@ -1304,7 +1310,7 @@ void dcn10_init_hw(struct dc *dc)
 	 * everything down.
 	 */
 	if (dcb->funcs->is_accelerated_mode(dcb) || dc->config.power_down_display_on_boot) {
-		dc->hwss.init_pipes(dc, dc->current_state);
+		hws->funcs.init_pipes(dc, dc->current_state);
 	}
 
 	for (i = 0; i < res_pool->audio_count; i++) {
@@ -1336,7 +1342,7 @@ void dcn10_init_hw(struct dc *dc)
 		REG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);
 	}
 
-	dc->hwss.enable_power_gating_plane(dc->hwseq, true);
+	hws->funcs.enable_power_gating_plane(dc->hwseq, true);
 
 	if (dc->clk_mgr->funcs->notify_wm_ranges)
 		dc->clk_mgr->funcs->notify_wm_ranges(dc->clk_mgr);
@@ -1348,6 +1354,7 @@ void dcn10_reset_hw_ctx_wrap(
 		struct dc_state *context)
 {
 	int i;
+	struct dce_hwseq *hws = dc->hwseq;
 
 	/* Reset Back End*/
 	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
@@ -1366,8 +1373,8 @@ void dcn10_reset_hw_ctx_wrap(
 			struct clock_source *old_clk = pipe_ctx_old->clock_source;
 
 			dcn10_reset_back_end_for_pipe(dc, pipe_ctx_old, dc->current_state);
-			if (dc->hwss.enable_stream_gating)
-				dc->hwss.enable_stream_gating(dc, pipe_ctx);
+			if (hws->funcs.enable_stream_gating)
+				hws->funcs.enable_stream_gating(dc, pipe_ctx);
 			if (old_clk)
 				old_clk->funcs->cs_power_down(old_clk);
 		}
@@ -1545,6 +1552,8 @@ void dcn10_pipe_control_lock(
 	struct pipe_ctx *pipe,
 	bool lock)
 {
+	struct dce_hwseq *hws = dc->hwseq;
+
 	/* use TG master update lock to lock everything on the TG
 	 * therefore only top pipe need to lock
 	 */
@@ -1552,7 +1561,7 @@ void dcn10_pipe_control_lock(
 		return;
 
 	if (dc->debug.sanity_checks)
-		dc->hwss.verify_allow_pstate_change_high(dc);
+		hws->funcs.verify_allow_pstate_change_high(dc);
 
 	if (lock)
 		pipe->stream_res.tg->funcs->lock(pipe->stream_res.tg);
@@ -1560,7 +1569,7 @@ void dcn10_pipe_control_lock(
 		pipe->stream_res.tg->funcs->unlock(pipe->stream_res.tg);
 
 	if (dc->debug.sanity_checks)
-		dc->hwss.verify_allow_pstate_change_high(dc);
+		hws->funcs.verify_allow_pstate_change_high(dc);
 }
 
 static bool wait_for_reset_trigger_to_occur(
@@ -1868,7 +1877,7 @@ static void dcn10_enable_plane(
 	struct dce_hwseq *hws = dc->hwseq;
 
 	if (dc->debug.sanity_checks) {
-		dc->hwss.verify_allow_pstate_change_high(dc);
+		hws->funcs.verify_allow_pstate_change_high(dc);
 	}
 
 	undo_DEGVIDCN10_253_wa(dc);
@@ -1925,7 +1934,7 @@ static void dcn10_enable_plane(
 		dcn10_program_pte_vm(hws, pipe_ctx->plane_res.hubp);
 
 	if (dc->debug.sanity_checks) {
-		dc->hwss.verify_allow_pstate_change_high(dc);
+		hws->funcs.verify_allow_pstate_change_high(dc);
 	}
 }
 
@@ -2102,6 +2111,7 @@ static void dcn10_update_dpp(struct dpp *dpp, struct dc_plane_state *plane_state
 
 void dcn10_update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
+	struct dce_hwseq *hws = dc->hwseq;
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	struct mpcc_blnd_cfg blnd_cfg = {{0}};
 	bool per_pixel_alpha = pipe_ctx->plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;
@@ -2111,10 +2121,10 @@ void dcn10_update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	struct mpc_tree *mpc_tree_params = &(pipe_ctx->stream_res.opp->mpc_tree_params);
 
 	if (dc->debug.visual_confirm == VISUAL_CONFIRM_HDR) {
-		dc->hwss.get_hdr_visual_confirm_color(
+		hws->funcs.get_hdr_visual_confirm_color(
 				pipe_ctx, &blnd_cfg.black_color);
 	} else if (dc->debug.visual_confirm == VISUAL_CONFIRM_SURFACE) {
-		dc->hwss.get_surface_visual_confirm_color(
+		hws->funcs.get_surface_visual_confirm_color(
 				pipe_ctx, &blnd_cfg.black_color);
 	} else {
 		color_space_to_black_color(
@@ -2201,6 +2211,7 @@ static void dcn10_update_dchubp_dpp(
 	struct pipe_ctx *pipe_ctx,
 	struct dc_state *context)
 {
+	struct dce_hwseq *hws = dc->hwseq;
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
@@ -2259,7 +2270,7 @@ static void dcn10_update_dchubp_dpp(
 	if (plane_state->update_flags.bits.full_update ||
 		plane_state->update_flags.bits.per_pixel_alpha_change ||
 		plane_state->update_flags.bits.global_alpha_change)
-		dc->hwss.update_mpcc(dc, pipe_ctx);
+		hws->funcs.update_mpcc(dc, pipe_ctx);
 
 	if (plane_state->update_flags.bits.full_update ||
 		plane_state->update_flags.bits.per_pixel_alpha_change ||
@@ -2319,7 +2330,7 @@ static void dcn10_update_dchubp_dpp(
 
 	hubp->power_gated = false;
 
-	dc->hwss.update_plane_addr(dc, pipe_ctx);
+	hws->funcs.update_plane_addr(dc, pipe_ctx);
 
 	if (is_pipe_tree_visible(pipe_ctx))
 		hubp->funcs->set_blank(hubp, false);
@@ -2395,17 +2406,19 @@ void dcn10_program_pipe(
 		struct pipe_ctx *pipe_ctx,
 		struct dc_state *context)
 {
+	struct dce_hwseq *hws = dc->hwseq;
+
 	if (pipe_ctx->plane_state->update_flags.bits.full_update)
 		dcn10_enable_plane(dc, pipe_ctx, context);
 
 	dcn10_update_dchubp_dpp(dc, pipe_ctx, context);
 
-	dc->hwss.set_hdr_multiplier(pipe_ctx);
+	hws->funcs.set_hdr_multiplier(pipe_ctx);
 
 	if (pipe_ctx->plane_state->update_flags.bits.full_update ||
 			pipe_ctx->plane_state->update_flags.bits.in_transfer_func_change ||
 			pipe_ctx->plane_state->update_flags.bits.gamma_change)
-		dc->hwss.set_input_transfer_func(dc, pipe_ctx, pipe_ctx->plane_state);
+		hws->funcs.set_input_transfer_func(dc, pipe_ctx, pipe_ctx->plane_state);
 
 	/* dcn10_translate_regamma_to_hw_format takes 750us to finish
 	 * only do gamma programming for full update.
@@ -2414,7 +2427,7 @@ void dcn10_program_pipe(
 	 * doing heavy calculation and programming
 	 */
 	if (pipe_ctx->plane_state->update_flags.bits.full_update)
-		dc->hwss.set_output_transfer_func(dc, pipe_ctx, pipe_ctx->stream);
+		hws->funcs.set_output_transfer_func(dc, pipe_ctx, pipe_ctx->stream);
 }
 
 static void dcn10_program_all_pipe_in_tree(
@@ -2422,6 +2435,8 @@ static void dcn10_program_all_pipe_in_tree(
 		struct pipe_ctx *pipe_ctx,
 		struct dc_state *context)
 {
+	struct dce_hwseq *hws = dc->hwseq;
+
 	if (pipe_ctx->top_pipe == NULL) {
 		bool blank = !is_pipe_tree_visible(pipe_ctx);
 
@@ -2435,14 +2450,14 @@ static void dcn10_program_all_pipe_in_tree(
 		pipe_ctx->stream_res.tg->funcs->set_vtg_params(
 				pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing);
 
-		if (dc->hwss.setup_vupdate_interrupt)
-			dc->hwss.setup_vupdate_interrupt(dc, pipe_ctx);
+		if (hws->funcs.setup_vupdate_interrupt)
+			hws->funcs.setup_vupdate_interrupt(dc, pipe_ctx);
 
-		dc->hwss.blank_pixel_data(dc, pipe_ctx, blank);
+		hws->funcs.blank_pixel_data(dc, pipe_ctx, blank);
 	}
 
 	if (pipe_ctx->plane_state != NULL)
-		dc->hwss.program_pipe(dc, pipe_ctx, context);
+		hws->funcs.program_pipe(dc, pipe_ctx, context);
 
 	if (pipe_ctx->bottom_pipe != NULL && pipe_ctx->bottom_pipe != pipe_ctx)
 		dcn10_program_all_pipe_in_tree(dc, pipe_ctx->bottom_pipe, context);
@@ -2478,6 +2493,7 @@ void dcn10_apply_ctx_for_surface(
 		int num_planes,
 		struct dc_state *context)
 {
+	struct dce_hwseq *hws = dc->hwseq;
 	int i;
 	struct timing_generator *tg;
 	uint32_t underflow_check_delay_us;
@@ -2497,8 +2513,8 @@ void dcn10_apply_ctx_for_surface(
 
 	underflow_check_delay_us = dc->debug.underflow_assert_delay_us;
 
-	if (underflow_check_delay_us != 0xFFFFFFFF && dc->hwss.did_underflow_occur)
-		ASSERT(dc->hwss.did_underflow_occur(dc, top_pipe_to_program));
+	if (underflow_check_delay_us != 0xFFFFFFFF && hws->funcs.did_underflow_occur)
+		ASSERT(hws->funcs.did_underflow_occur(dc, top_pipe_to_program));
 
 	if (interdependent_update)
 		dcn10_lock_all_pipes(dc, context, true);
@@ -2508,12 +2524,12 @@ void dcn10_apply_ctx_for_surface(
 	if (underflow_check_delay_us != 0xFFFFFFFF)
 		udelay(underflow_check_delay_us);
 
-	if (underflow_check_delay_us != 0xFFFFFFFF && dc->hwss.did_underflow_occur)
-		ASSERT(dc->hwss.did_underflow_occur(dc, top_pipe_to_program));
+	if (underflow_check_delay_us != 0xFFFFFFFF && hws->funcs.did_underflow_occur)
+		ASSERT(hws->funcs.did_underflow_occur(dc, top_pipe_to_program));
 
 	if (num_planes == 0) {
 		/* OTG blank before remove all front end */
-		dc->hwss.blank_pixel_data(dc, top_pipe_to_program, true);
+		hws->funcs.blank_pixel_data(dc, top_pipe_to_program, true);
 	}
 
 	/* Disconnect unused mpcc */
@@ -2539,7 +2555,7 @@ void dcn10_apply_ctx_for_surface(
 		    old_pipe_ctx->plane_state &&
 		    old_pipe_ctx->stream_res.tg == tg) {
 
-			dc->hwss.plane_atomic_disconnect(dc, old_pipe_ctx);
+			hws->funcs.plane_atomic_disconnect(dc, old_pipe_ctx);
 			removed_pipe[i] = true;
 
 			DC_LOG_DC("Reset mpcc for pipe %d\n",
@@ -2551,8 +2567,8 @@ void dcn10_apply_ctx_for_surface(
 		dcn10_program_all_pipe_in_tree(dc, top_pipe_to_program, context);
 
 	/* Program secondary blending tree and writeback pipes */
-	if ((stream->num_wb_info > 0) && (dc->hwss.program_all_writeback_pipes_in_tree))
-		dc->hwss.program_all_writeback_pipes_in_tree(dc, stream, context);
+	if ((stream->num_wb_info > 0) && (hws->funcs.program_all_writeback_pipes_in_tree))
+		hws->funcs.program_all_writeback_pipes_in_tree(dc, stream, context);
 	if (interdependent_update)
 		for (i = 0; i < dc->res_pool->pipe_count; i++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
@@ -2609,10 +2625,11 @@ void dcn10_prepare_bandwidth(
 		struct dc *dc,
 		struct dc_state *context)
 {
+	struct dce_hwseq *hws = dc->hwseq;
 	struct hubbub *hubbub = dc->res_pool->hubbub;
 
 	if (dc->debug.sanity_checks)
-		dc->hwss.verify_allow_pstate_change_high(dc);
+		hws->funcs.verify_allow_pstate_change_high(dc);
 
 	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
 		if (context->stream_count == 0)
@@ -2634,17 +2651,18 @@ void dcn10_prepare_bandwidth(
 		dcn_bw_notify_pplib_of_wm_ranges(dc);
 
 	if (dc->debug.sanity_checks)
-		dc->hwss.verify_allow_pstate_change_high(dc);
+		hws->funcs.verify_allow_pstate_change_high(dc);
 }
 
 void dcn10_optimize_bandwidth(
 		struct dc *dc,
 		struct dc_state *context)
 {
+	struct dce_hwseq *hws = dc->hwseq;
 	struct hubbub *hubbub = dc->res_pool->hubbub;
 
 	if (dc->debug.sanity_checks)
-		dc->hwss.verify_allow_pstate_change_high(dc);
+		hws->funcs.verify_allow_pstate_change_high(dc);
 
 	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
 		if (context->stream_count == 0)
@@ -2666,7 +2684,7 @@ void dcn10_optimize_bandwidth(
 		dcn_bw_notify_pplib_of_wm_ranges(dc);
 
 	if (dc->debug.sanity_checks)
-		dc->hwss.verify_allow_pstate_change_high(dc);
+		hws->funcs.verify_allow_pstate_change_high(dc);
 }
 
 void dcn10_set_drr(struct pipe_ctx **pipe_ctx,
@@ -2808,10 +2826,11 @@ void dcn10_wait_for_mpcc_disconnect(
 		struct resource_pool *res_pool,
 		struct pipe_ctx *pipe_ctx)
 {
+	struct dce_hwseq *hws = dc->hwseq;
 	int mpcc_inst;
 
 	if (dc->debug.sanity_checks) {
-		dc->hwss.verify_allow_pstate_change_high(dc);
+		hws->funcs.verify_allow_pstate_change_high(dc);
 	}
 
 	if (!pipe_ctx->stream_res.opp)
@@ -2828,7 +2847,7 @@ void dcn10_wait_for_mpcc_disconnect(
 	}
 
 	if (dc->debug.sanity_checks) {
-		dc->hwss.verify_allow_pstate_change_high(dc);
+		hws->funcs.verify_allow_pstate_change_high(dc);
 	}
 
 }
@@ -3127,6 +3146,7 @@ void dcn10_unblank_stream(struct pipe_ctx *pipe_ctx,
 	struct encoder_unblank_param params = { { 0 } };
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct dc_link *link = stream->link;
+	struct dce_hwseq *hws = link->dc->hwseq;
 
 	/* only 3 items below are used by unblank */
 	params.timing = pipe_ctx->stream->timing;
@@ -3140,7 +3160,7 @@ void dcn10_unblank_stream(struct pipe_ctx *pipe_ctx,
 	}
 
 	if (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP) {
-		link->dc->hwss.edp_backlight_control(link, true);
+		hws->funcs.edp_backlight_control(link, true);
 	}
 }
 

commit 2b77dcc5e5aa382832af93a581de8293db72d888
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Nov 5 13:04:34 2019 -0500

    drm/amd/display: rename core_dc to dc
    
    [Why]
    First, to make code more consistent
    Second, to get rid of those scenario where we create a second
    local pointer to dc when it's already passed in.
    
    [How]
    Rename core_dc to dc
    Remove duplicate local pointers to dc
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 251bb59c271a..bd6cdb6b38f6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1655,10 +1655,10 @@ void dcn10_enable_per_frame_crtc_position_reset(
 }
 
 /*static void print_rq_dlg_ttu(
-		struct dc *core_dc,
+		struct dc *dc,
 		struct pipe_ctx *pipe_ctx)
 {
-	DC_LOG_BANDWIDTH_CALCS(core_dc->ctx->logger,
+	DC_LOG_BANDWIDTH_CALCS(dc->ctx->logger,
 			"\n============== DML TTU Output parameters [%d] ==============\n"
 			"qos_level_low_wm: %d, \n"
 			"qos_level_high_wm: %d, \n"
@@ -1688,7 +1688,7 @@ void dcn10_enable_per_frame_crtc_position_reset(
 			pipe_ctx->ttu_regs.refcyc_per_req_delivery_pre_c
 			);
 
-	DC_LOG_BANDWIDTH_CALCS(core_dc->ctx->logger,
+	DC_LOG_BANDWIDTH_CALCS(dc->ctx->logger,
 			"\n============== DML DLG Output parameters [%d] ==============\n"
 			"refcyc_h_blank_end: %d, \n"
 			"dlg_vblank_end: %d, \n"
@@ -1723,7 +1723,7 @@ void dcn10_enable_per_frame_crtc_position_reset(
 			pipe_ctx->dlg_regs.refcyc_per_pte_group_nom_l
 			);
 
-	DC_LOG_BANDWIDTH_CALCS(core_dc->ctx->logger,
+	DC_LOG_BANDWIDTH_CALCS(dc->ctx->logger,
 			"\ndst_y_per_meta_row_nom_l: %d, \n"
 			"refcyc_per_meta_chunk_nom_l: %d, \n"
 			"refcyc_per_line_delivery_pre_l: %d, \n"
@@ -1753,7 +1753,7 @@ void dcn10_enable_per_frame_crtc_position_reset(
 			pipe_ctx->dlg_regs.refcyc_per_line_delivery_c
 			);
 
-	DC_LOG_BANDWIDTH_CALCS(core_dc->ctx->logger,
+	DC_LOG_BANDWIDTH_CALCS(dc->ctx->logger,
 			"\n============== DML RQ Output parameters [%d] ==============\n"
 			"chunk_size: %d \n"
 			"min_chunk_size: %d \n"

commit 78c7738211e027f122ada3f59c2c5e8a83ee3c59
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Oct 29 15:05:56 2019 -0400

    drm/amd/display: cleanup of function pointer tables
    
    [Why]
    It is becoming increasingly hard to figure out which
    function is called on the different DCN versions
    
    [How]
    1. Make function pointer table init in its own init.c file
    2. Remove other scenarios in hwseq.c file that need to
    include headers of other DCN versions. (If needed,
    it should have been done via the function pointers)
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f21a385a936f..251bb59c271a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -25,17 +25,18 @@
 
 #include <linux/delay.h>
 #include "dm_services.h"
+#include "basics/dc_common.h"
 #include "core_types.h"
 #include "resource.h"
 #include "custom_float.h"
 #include "dcn10_hw_sequencer.h"
-#include "dce110/dce110_hw_sequencer.h"
+#include "dcn10_hw_sequencer_debug.h"
 #include "dce/dce_hwseq.h"
 #include "abm.h"
 #include "dmcu.h"
 #include "dcn10_optc.h"
-#include "dcn10/dcn10_dpp.h"
-#include "dcn10/dcn10_mpc.h"
+#include "dcn10_dpp.h"
+#include "dcn10_mpc.h"
 #include "timing_generator.h"
 #include "opp.h"
 #include "ipp.h"
@@ -66,6 +67,8 @@
 #define DTN_INFO_MICRO_SEC(ref_cycle) \
 	print_microsec(dc_ctx, log_ctx, ref_cycle)
 
+#define GAMMA_HW_POINTS_NUM 256
+
 void print_microsec(struct dc_context *dc_ctx,
 	struct dc_log_buffer_ctx *log_ctx,
 	uint32_t ref_cycle)
@@ -79,6 +82,33 @@ void print_microsec(struct dc_context *dc_ctx,
 			us_x10 % frac);
 }
 
+static void dcn10_lock_all_pipes(struct dc *dc,
+	struct dc_state *context,
+	bool lock)
+{
+	struct pipe_ctx *pipe_ctx;
+	struct timing_generator *tg;
+	int i;
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		pipe_ctx = &context->res_ctx.pipe_ctx[i];
+		tg = pipe_ctx->stream_res.tg;
+		/*
+		 * Only lock the top pipe's tg to prevent redundant
+		 * (un)locking. Also skip if pipe is disabled.
+		 */
+		if (pipe_ctx->top_pipe ||
+		    !pipe_ctx->stream || !pipe_ctx->plane_state ||
+		    !tg->funcs->is_tg_enabled(tg))
+			continue;
+
+		if (lock)
+			tg->funcs->lock(tg);
+		else
+			tg->funcs->unlock(tg);
+	}
+}
+
 static void log_mpc_crc(struct dc *dc,
 	struct dc_log_buffer_ctx *log_ctx)
 {
@@ -445,7 +475,7 @@ bool dcn10_did_underflow_occur(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	return false;
 }
 
-static void dcn10_enable_power_gating_plane(
+void dcn10_enable_power_gating_plane(
 	struct dce_hwseq *hws,
 	bool enable)
 {
@@ -467,7 +497,7 @@ static void dcn10_enable_power_gating_plane(
 	REG_UPDATE(DOMAIN7_PG_CONFIG, DOMAIN7_POWER_FORCEON, force_on);
 }
 
-static void dcn10_disable_vga(
+void dcn10_disable_vga(
 	struct dce_hwseq *hws)
 {
 	unsigned int in_vga1_mode = 0;
@@ -500,7 +530,7 @@ static void dcn10_disable_vga(
 	REG_UPDATE(VGA_TEST_CONTROL, VGA_TEST_RENDER_START, 1);
 }
 
-static void dcn10_dpp_pg_control(
+void dcn10_dpp_pg_control(
 		struct dce_hwseq *hws,
 		unsigned int dpp_inst,
 		bool power_on)
@@ -552,7 +582,7 @@ static void dcn10_dpp_pg_control(
 	}
 }
 
-static void dcn10_hubp_pg_control(
+void dcn10_hubp_pg_control(
 		struct dce_hwseq *hws,
 		unsigned int hubp_inst,
 		bool power_on)
@@ -671,7 +701,7 @@ static void apply_DEGVIDCN10_253_wa(struct dc *dc)
 	hws->wa_state.DEGVIDCN10_253_applied = true;
 }
 
-static void dcn10_bios_golden_init(struct dc *dc)
+void dcn10_bios_golden_init(struct dc *dc)
 {
 	struct dc_bios *bp = dc->ctx->dc_bios;
 	int i;
@@ -737,7 +767,7 @@ static void false_optc_underflow_wa(
 		tg->funcs->clear_optc_underflow(tg);
 }
 
-static enum dc_status dcn10_enable_stream_timing(
+enum dc_status dcn10_enable_stream_timing(
 		struct pipe_ctx *pipe_ctx,
 		struct dc_state *context,
 		struct dc *dc)
@@ -983,7 +1013,7 @@ void dcn10_verify_allow_pstate_change_high(struct dc *dc)
 }
 
 /* trigger HW to start disconnect plane from stream on the next vsync */
-void hwss1_plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
+void dcn10_plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	int dpp_id = pipe_ctx->plane_res.dpp->inst;
@@ -1009,10 +1039,10 @@ void hwss1_plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 		hubp->funcs->hubp_disconnect(hubp);
 
 	if (dc->debug.sanity_checks)
-		dcn10_verify_allow_pstate_change_high(dc);
+		dc->hwss.verify_allow_pstate_change_high(dc);
 }
 
-static void dcn10_plane_atomic_power_down(struct dc *dc,
+void dcn10_plane_atomic_power_down(struct dc *dc,
 		struct dpp *dpp,
 		struct hubp *hubp)
 {
@@ -1035,7 +1065,7 @@ static void dcn10_plane_atomic_power_down(struct dc *dc,
 /* disable HW used by plane.
  * note:  cannot disable until disconnect is complete
  */
-static void dcn10_plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
+void dcn10_plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	struct dpp *dpp = pipe_ctx->plane_res.dpp;
@@ -1067,7 +1097,7 @@ static void dcn10_plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	pipe_ctx->plane_state = NULL;
 }
 
-static void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
+void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	DC_LOGGER_INIT(dc->ctx->logger);
 
@@ -1082,7 +1112,7 @@ static void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
 					pipe_ctx->pipe_idx);
 }
 
-static void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
+void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 {
 	int i;
 	bool can_apply_seamless_boot = false;
@@ -1181,7 +1211,7 @@ static void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 	}
 }
 
-static void dcn10_init_hw(struct dc *dc)
+void dcn10_init_hw(struct dc *dc)
 {
 	int i;
 	struct abm *abm = dc->res_pool->abm;
@@ -1313,7 +1343,7 @@ static void dcn10_init_hw(struct dc *dc)
 
 }
 
-static void dcn10_reset_hw_ctx_wrap(
+void dcn10_reset_hw_ctx_wrap(
 		struct dc *dc,
 		struct dc_state *context)
 {
@@ -1370,9 +1400,7 @@ static bool patch_address_for_sbs_tb_stereo(
 	return false;
 }
 
-
-
-static void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_ctx)
+void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	bool addr_patched = false;
 	PHYSICAL_ADDRESS_LOC addr;
@@ -1397,8 +1425,8 @@ static void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_c
 		pipe_ctx->plane_state->address.grph_stereo.left_addr = addr;
 }
 
-static bool dcn10_set_input_transfer_func(struct pipe_ctx *pipe_ctx,
-					  const struct dc_plane_state *plane_state)
+bool dcn10_set_input_transfer_func(struct dc *dc, struct pipe_ctx *pipe_ctx,
+			const struct dc_plane_state *plane_state)
 {
 	struct dpp *dpp_base = pipe_ctx->plane_res.dpp;
 	const struct dc_transfer_func *tf = NULL;
@@ -1475,9 +1503,8 @@ static void log_tf(struct dc_context *ctx,
 	}
 }
 
-static bool
-dcn10_set_output_transfer_func(struct pipe_ctx *pipe_ctx,
-			       const struct dc_stream_state *stream)
+bool dcn10_set_output_transfer_func(struct dc *dc, struct pipe_ctx *pipe_ctx,
+				const struct dc_stream_state *stream)
 {
 	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 
@@ -1513,7 +1540,7 @@ dcn10_set_output_transfer_func(struct pipe_ctx *pipe_ctx,
 	return true;
 }
 
-static void dcn10_pipe_control_lock(
+void dcn10_pipe_control_lock(
 	struct dc *dc,
 	struct pipe_ctx *pipe,
 	bool lock)
@@ -1525,7 +1552,7 @@ static void dcn10_pipe_control_lock(
 		return;
 
 	if (dc->debug.sanity_checks)
-		dcn10_verify_allow_pstate_change_high(dc);
+		dc->hwss.verify_allow_pstate_change_high(dc);
 
 	if (lock)
 		pipe->stream_res.tg->funcs->lock(pipe->stream_res.tg);
@@ -1533,7 +1560,7 @@ static void dcn10_pipe_control_lock(
 		pipe->stream_res.tg->funcs->unlock(pipe->stream_res.tg);
 
 	if (dc->debug.sanity_checks)
-		dcn10_verify_allow_pstate_change_high(dc);
+		dc->hwss.verify_allow_pstate_change_high(dc);
 }
 
 static bool wait_for_reset_trigger_to_occur(
@@ -1573,7 +1600,7 @@ static bool wait_for_reset_trigger_to_occur(
 	return rc;
 }
 
-static void dcn10_enable_timing_synchronization(
+void dcn10_enable_timing_synchronization(
 	struct dc *dc,
 	int group_index,
 	int group_size,
@@ -1603,7 +1630,7 @@ static void dcn10_enable_timing_synchronization(
 	DC_SYNC_INFO("Sync complete\n");
 }
 
-static void dcn10_enable_per_frame_crtc_position_reset(
+void dcn10_enable_per_frame_crtc_position_reset(
 	struct dc *dc,
 	int group_size,
 	struct pipe_ctx *grouped_pipes[])
@@ -1841,7 +1868,7 @@ static void dcn10_enable_plane(
 	struct dce_hwseq *hws = dc->hwseq;
 
 	if (dc->debug.sanity_checks) {
-		dcn10_verify_allow_pstate_change_high(dc);
+		dc->hwss.verify_allow_pstate_change_high(dc);
 	}
 
 	undo_DEGVIDCN10_253_wa(dc);
@@ -1898,11 +1925,11 @@ static void dcn10_enable_plane(
 		dcn10_program_pte_vm(hws, pipe_ctx->plane_res.hubp);
 
 	if (dc->debug.sanity_checks) {
-		dcn10_verify_allow_pstate_change_high(dc);
+		dc->hwss.verify_allow_pstate_change_high(dc);
 	}
 }
 
-static void dcn10_program_gamut_remap(struct pipe_ctx *pipe_ctx)
+void dcn10_program_gamut_remap(struct pipe_ctx *pipe_ctx)
 {
 	int i = 0;
 	struct dpp_grph_csc_adjustment adjust;
@@ -1950,7 +1977,7 @@ static void dcn10_set_csc_adjustment_rgb_mpo_fix(struct pipe_ctx *pipe_ctx, uint
 	matrix[11] = rgb_bias;
 }
 
-static void dcn10_program_output_csc(struct dc *dc,
+void dcn10_program_output_csc(struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
 		enum dc_color_space colorspace,
 		uint16_t *matrix,
@@ -1982,57 +2009,6 @@ static void dcn10_program_output_csc(struct dc *dc,
 	}
 }
 
-bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
-{
-	if (pipe_ctx->plane_state && pipe_ctx->plane_state->visible)
-		return true;
-	if (pipe_ctx->bottom_pipe && is_lower_pipe_tree_visible(pipe_ctx->bottom_pipe))
-		return true;
-	return false;
-}
-
-bool is_upper_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
-{
-	if (pipe_ctx->plane_state && pipe_ctx->plane_state->visible)
-		return true;
-	if (pipe_ctx->top_pipe && is_upper_pipe_tree_visible(pipe_ctx->top_pipe))
-		return true;
-	return false;
-}
-
-bool is_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
-{
-	if (pipe_ctx->plane_state && pipe_ctx->plane_state->visible)
-		return true;
-	if (pipe_ctx->top_pipe && is_upper_pipe_tree_visible(pipe_ctx->top_pipe))
-		return true;
-	if (pipe_ctx->bottom_pipe && is_lower_pipe_tree_visible(pipe_ctx->bottom_pipe))
-		return true;
-	return false;
-}
-
-bool is_rgb_cspace(enum dc_color_space output_color_space)
-{
-	switch (output_color_space) {
-	case COLOR_SPACE_SRGB:
-	case COLOR_SPACE_SRGB_LIMITED:
-	case COLOR_SPACE_2020_RGB_FULLRANGE:
-	case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
-	case COLOR_SPACE_ADOBERGB:
-		return true;
-	case COLOR_SPACE_YCBCR601:
-	case COLOR_SPACE_YCBCR709:
-	case COLOR_SPACE_YCBCR601_LIMITED:
-	case COLOR_SPACE_YCBCR709_LIMITED:
-	case COLOR_SPACE_2020_YCBCR:
-		return false;
-	default:
-		/* Add a case to switch */
-		BREAK_TO_DEBUGGER();
-		return false;
-	}
-}
-
 void dcn10_get_surface_visual_confirm_color(
 		const struct pipe_ctx *pipe_ctx,
 		struct tg_color *color)
@@ -2106,70 +2082,7 @@ void dcn10_get_hdr_visual_confirm_color(
 	}
 }
 
-static uint16_t fixed_point_to_int_frac(
-	struct fixed31_32 arg,
-	uint8_t integer_bits,
-	uint8_t fractional_bits)
-{
-	int32_t numerator;
-	int32_t divisor = 1 << fractional_bits;
-
-	uint16_t result;
-
-	uint16_t d = (uint16_t)dc_fixpt_floor(
-		dc_fixpt_abs(
-			arg));
-
-	if (d <= (uint16_t)(1 << integer_bits) - (1 / (uint16_t)divisor))
-		numerator = (uint16_t)dc_fixpt_floor(
-			dc_fixpt_mul_int(
-				arg,
-				divisor));
-	else {
-		numerator = dc_fixpt_floor(
-			dc_fixpt_sub(
-				dc_fixpt_from_int(
-					1LL << integer_bits),
-				dc_fixpt_recip(
-					dc_fixpt_from_int(
-						divisor))));
-	}
-
-	if (numerator >= 0)
-		result = (uint16_t)numerator;
-	else
-		result = (uint16_t)(
-		(1 << (integer_bits + fractional_bits + 1)) + numerator);
-
-	if ((result != 0) && dc_fixpt_lt(
-		arg, dc_fixpt_zero))
-		result |= 1 << (integer_bits + fractional_bits);
-
-	return result;
-}
-
-void dcn10_build_prescale_params(struct  dc_bias_and_scale *bias_and_scale,
-		const struct dc_plane_state *plane_state)
-{
-	if (plane_state->format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN
-			&& plane_state->format != SURFACE_PIXEL_FORMAT_INVALID
-			&& plane_state->input_csc_color_matrix.enable_adjustment
-			&& plane_state->coeff_reduction_factor.value != 0) {
-		bias_and_scale->scale_blue = fixed_point_to_int_frac(
-			dc_fixpt_mul(plane_state->coeff_reduction_factor,
-					dc_fixpt_from_fraction(256, 255)),
-				2,
-				13);
-		bias_and_scale->scale_red = bias_and_scale->scale_blue;
-		bias_and_scale->scale_green = bias_and_scale->scale_blue;
-	} else {
-		bias_and_scale->scale_blue = 0x2000;
-		bias_and_scale->scale_red = 0x2000;
-		bias_and_scale->scale_green = 0x2000;
-	}
-}
-
-static void update_dpp(struct dpp *dpp, struct dc_plane_state *plane_state)
+static void dcn10_update_dpp(struct dpp *dpp, struct dc_plane_state *plane_state)
 {
 	struct dc_bias_and_scale bns_params = {0};
 
@@ -2182,12 +2095,12 @@ static void update_dpp(struct dpp *dpp, struct dc_plane_state *plane_state)
 			NULL);
 
 	//set scale and bias registers
-	dcn10_build_prescale_params(&bns_params, plane_state);
+	build_prescale_params(&bns_params, plane_state);
 	if (dpp->funcs->dpp_program_bias_and_scale)
 		dpp->funcs->dpp_program_bias_and_scale(dpp, &bns_params);
 }
 
-static void dcn10_update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
+void dcn10_update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	struct mpcc_blnd_cfg blnd_cfg = {{0}};
@@ -2198,10 +2111,10 @@ static void dcn10_update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	struct mpc_tree *mpc_tree_params = &(pipe_ctx->stream_res.opp->mpc_tree_params);
 
 	if (dc->debug.visual_confirm == VISUAL_CONFIRM_HDR) {
-		dcn10_get_hdr_visual_confirm_color(
+		dc->hwss.get_hdr_visual_confirm_color(
 				pipe_ctx, &blnd_cfg.black_color);
 	} else if (dc->debug.visual_confirm == VISUAL_CONFIRM_SURFACE) {
-		dcn10_get_surface_visual_confirm_color(
+		dc->hwss.get_surface_visual_confirm_color(
 				pipe_ctx, &blnd_cfg.black_color);
 	} else {
 		color_space_to_black_color(
@@ -2283,7 +2196,7 @@ static void update_scaler(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data);
 }
 
-void update_dchubp_dpp(
+static void dcn10_update_dchubp_dpp(
 	struct dc *dc,
 	struct pipe_ctx *pipe_ctx,
 	struct dc_state *context)
@@ -2341,7 +2254,7 @@ void update_dchubp_dpp(
 
 	if (plane_state->update_flags.bits.full_update ||
 		plane_state->update_flags.bits.bpp_change)
-		update_dpp(dpp, plane_state);
+		dcn10_update_dpp(dpp, plane_state);
 
 	if (plane_state->update_flags.bits.full_update ||
 		plane_state->update_flags.bits.per_pixel_alpha_change ||
@@ -2412,7 +2325,7 @@ void update_dchubp_dpp(
 		hubp->funcs->set_blank(hubp, false);
 }
 
-static void dcn10_blank_pixel_data(
+void dcn10_blank_pixel_data(
 		struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
 		bool blank)
@@ -2455,7 +2368,7 @@ static void dcn10_blank_pixel_data(
 	}
 }
 
-void set_hdr_multiplier(struct pipe_ctx *pipe_ctx)
+void dcn10_set_hdr_multiplier(struct pipe_ctx *pipe_ctx)
 {
 	struct fixed31_32 multiplier = pipe_ctx->plane_state->hdr_mult;
 	uint32_t hw_mult = 0x1f000; // 1.0 default multiplier
@@ -2485,14 +2398,14 @@ void dcn10_program_pipe(
 	if (pipe_ctx->plane_state->update_flags.bits.full_update)
 		dcn10_enable_plane(dc, pipe_ctx, context);
 
-	update_dchubp_dpp(dc, pipe_ctx, context);
+	dcn10_update_dchubp_dpp(dc, pipe_ctx, context);
 
-	set_hdr_multiplier(pipe_ctx);
+	dc->hwss.set_hdr_multiplier(pipe_ctx);
 
 	if (pipe_ctx->plane_state->update_flags.bits.full_update ||
 			pipe_ctx->plane_state->update_flags.bits.in_transfer_func_change ||
 			pipe_ctx->plane_state->update_flags.bits.gamma_change)
-		dc->hwss.set_input_transfer_func(pipe_ctx, pipe_ctx->plane_state);
+		dc->hwss.set_input_transfer_func(dc, pipe_ctx, pipe_ctx->plane_state);
 
 	/* dcn10_translate_regamma_to_hw_format takes 750us to finish
 	 * only do gamma programming for full update.
@@ -2501,10 +2414,10 @@ void dcn10_program_pipe(
 	 * doing heavy calculation and programming
 	 */
 	if (pipe_ctx->plane_state->update_flags.bits.full_update)
-		dc->hwss.set_output_transfer_func(pipe_ctx, pipe_ctx->stream);
+		dc->hwss.set_output_transfer_func(dc, pipe_ctx, pipe_ctx->stream);
 }
 
-static void program_all_pipe_in_tree(
+static void dcn10_program_all_pipe_in_tree(
 		struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
 		struct dc_state *context)
@@ -2523,19 +2436,19 @@ static void program_all_pipe_in_tree(
 				pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing);
 
 		if (dc->hwss.setup_vupdate_interrupt)
-			dc->hwss.setup_vupdate_interrupt(pipe_ctx);
+			dc->hwss.setup_vupdate_interrupt(dc, pipe_ctx);
 
 		dc->hwss.blank_pixel_data(dc, pipe_ctx, blank);
 	}
 
 	if (pipe_ctx->plane_state != NULL)
-		dcn10_program_pipe(dc, pipe_ctx, context);
+		dc->hwss.program_pipe(dc, pipe_ctx, context);
 
 	if (pipe_ctx->bottom_pipe != NULL && pipe_ctx->bottom_pipe != pipe_ctx)
-		program_all_pipe_in_tree(dc, pipe_ctx->bottom_pipe, context);
+		dcn10_program_all_pipe_in_tree(dc, pipe_ctx->bottom_pipe, context);
 }
 
-struct pipe_ctx *find_top_pipe_for_stream(
+static struct pipe_ctx *dcn10_find_top_pipe_for_stream(
 		struct dc *dc,
 		struct dc_state *context,
 		const struct dc_stream_state *stream)
@@ -2559,7 +2472,7 @@ struct pipe_ctx *find_top_pipe_for_stream(
 	return NULL;
 }
 
-static void dcn10_apply_ctx_for_surface(
+void dcn10_apply_ctx_for_surface(
 		struct dc *dc,
 		const struct dc_stream_state *stream,
 		int num_planes,
@@ -2571,7 +2484,7 @@ static void dcn10_apply_ctx_for_surface(
 	bool removed_pipe[4] = { false };
 	bool interdependent_update = false;
 	struct pipe_ctx *top_pipe_to_program =
-			find_top_pipe_for_stream(dc, context, stream);
+			dcn10_find_top_pipe_for_stream(dc, context, stream);
 	DC_LOGGER_INIT(dc->ctx->logger);
 
 	if (!top_pipe_to_program)
@@ -2588,7 +2501,7 @@ static void dcn10_apply_ctx_for_surface(
 		ASSERT(dc->hwss.did_underflow_occur(dc, top_pipe_to_program));
 
 	if (interdependent_update)
-		lock_all_pipes(dc, context, true);
+		dcn10_lock_all_pipes(dc, context, true);
 	else
 		dcn10_pipe_control_lock(dc, top_pipe_to_program, true);
 
@@ -2635,7 +2548,7 @@ static void dcn10_apply_ctx_for_surface(
 	}
 
 	if (num_planes > 0)
-		program_all_pipe_in_tree(dc, top_pipe_to_program, context);
+		dcn10_program_all_pipe_in_tree(dc, top_pipe_to_program, context);
 
 	/* Program secondary blending tree and writeback pipes */
 	if ((stream->num_wb_info > 0) && (dc->hwss.program_all_writeback_pipes_in_tree))
@@ -2655,7 +2568,7 @@ static void dcn10_apply_ctx_for_surface(
 		}
 
 	if (interdependent_update)
-		lock_all_pipes(dc, context, false);
+		dcn10_lock_all_pipes(dc, context, false);
 	else
 		dcn10_pipe_control_lock(dc, top_pipe_to_program, false);
 
@@ -2692,14 +2605,14 @@ static void dcn10_stereo_hw_frame_pack_wa(struct dc *dc, struct dc_state *contex
 	}
 }
 
-static void dcn10_prepare_bandwidth(
+void dcn10_prepare_bandwidth(
 		struct dc *dc,
 		struct dc_state *context)
 {
 	struct hubbub *hubbub = dc->res_pool->hubbub;
 
 	if (dc->debug.sanity_checks)
-		dcn10_verify_allow_pstate_change_high(dc);
+		dc->hwss.verify_allow_pstate_change_high(dc);
 
 	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
 		if (context->stream_count == 0)
@@ -2721,17 +2634,17 @@ static void dcn10_prepare_bandwidth(
 		dcn_bw_notify_pplib_of_wm_ranges(dc);
 
 	if (dc->debug.sanity_checks)
-		dcn10_verify_allow_pstate_change_high(dc);
+		dc->hwss.verify_allow_pstate_change_high(dc);
 }
 
-static void dcn10_optimize_bandwidth(
+void dcn10_optimize_bandwidth(
 		struct dc *dc,
 		struct dc_state *context)
 {
 	struct hubbub *hubbub = dc->res_pool->hubbub;
 
 	if (dc->debug.sanity_checks)
-		dcn10_verify_allow_pstate_change_high(dc);
+		dc->hwss.verify_allow_pstate_change_high(dc);
 
 	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
 		if (context->stream_count == 0)
@@ -2753,10 +2666,10 @@ static void dcn10_optimize_bandwidth(
 		dcn_bw_notify_pplib_of_wm_ranges(dc);
 
 	if (dc->debug.sanity_checks)
-		dcn10_verify_allow_pstate_change_high(dc);
+		dc->hwss.verify_allow_pstate_change_high(dc);
 }
 
-static void dcn10_set_drr(struct pipe_ctx **pipe_ctx,
+void dcn10_set_drr(struct pipe_ctx **pipe_ctx,
 		int num_pipes, unsigned int vmin, unsigned int vmax,
 		unsigned int vmid, unsigned int vmid_frame_number)
 {
@@ -2784,7 +2697,7 @@ static void dcn10_set_drr(struct pipe_ctx **pipe_ctx,
 	}
 }
 
-static void dcn10_get_position(struct pipe_ctx **pipe_ctx,
+void dcn10_get_position(struct pipe_ctx **pipe_ctx,
 		int num_pipes,
 		struct crtc_position *position)
 {
@@ -2796,7 +2709,7 @@ static void dcn10_get_position(struct pipe_ctx **pipe_ctx,
 		pipe_ctx[i]->stream_res.tg->funcs->get_position(pipe_ctx[i]->stream_res.tg, position);
 }
 
-static void dcn10_set_static_screen_control(struct pipe_ctx **pipe_ctx,
+void dcn10_set_static_screen_control(struct pipe_ctx **pipe_ctx,
 		int num_pipes, const struct dc_static_screen_events *events)
 {
 	unsigned int i;
@@ -2851,7 +2764,7 @@ static void dcn10_config_stereo_parameters(
 	return;
 }
 
-static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct dc *dc)
+void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct dc *dc)
 {
 	struct crtc_stereo_flags flags = { 0 };
 	struct dc_stream_state *stream = pipe_ctx->stream;
@@ -2890,7 +2803,7 @@ static struct hubp *get_hubp_by_inst(struct resource_pool *res_pool, int mpcc_in
 	return NULL;
 }
 
-static void dcn10_wait_for_mpcc_disconnect(
+void dcn10_wait_for_mpcc_disconnect(
 		struct dc *dc,
 		struct resource_pool *res_pool,
 		struct pipe_ctx *pipe_ctx)
@@ -2898,7 +2811,7 @@ static void dcn10_wait_for_mpcc_disconnect(
 	int mpcc_inst;
 
 	if (dc->debug.sanity_checks) {
-		dcn10_verify_allow_pstate_change_high(dc);
+		dc->hwss.verify_allow_pstate_change_high(dc);
 	}
 
 	if (!pipe_ctx->stream_res.opp)
@@ -2915,12 +2828,12 @@ static void dcn10_wait_for_mpcc_disconnect(
 	}
 
 	if (dc->debug.sanity_checks) {
-		dcn10_verify_allow_pstate_change_high(dc);
+		dc->hwss.verify_allow_pstate_change_high(dc);
 	}
 
 }
 
-static bool dcn10_dummy_display_power_gating(
+bool dcn10_dummy_display_power_gating(
 	struct dc *dc,
 	uint8_t controller_id,
 	struct dc_bios *dcb,
@@ -2929,7 +2842,7 @@ static bool dcn10_dummy_display_power_gating(
 	return true;
 }
 
-static void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
+void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct timing_generator *tg = pipe_ctx->stream_res.tg;
@@ -2953,7 +2866,7 @@ static void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 	}
 }
 
-static void dcn10_update_dchub(struct dce_hwseq *hws, struct dchub_init_data *dh_data)
+void dcn10_update_dchub(struct dce_hwseq *hws, struct dchub_init_data *dh_data)
 {
 	struct hubbub *hubbub = hws->ctx->dc->res_pool->hubbub;
 
@@ -2961,7 +2874,7 @@ static void dcn10_update_dchub(struct dce_hwseq *hws, struct dchub_init_data *dh
 	hubbub->funcs->update_dchub(hubbub, dh_data);
 }
 
-static void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
+void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_cursor_position pos_cpy = pipe_ctx->stream->cursor_position;
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
@@ -3027,7 +2940,7 @@ static void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 	dpp->funcs->set_cursor_position(dpp, &pos_cpy, &param, hubp->curs_attr.width, hubp->curs_attr.height);
 }
 
-static void dcn10_set_cursor_attribute(struct pipe_ctx *pipe_ctx)
+void dcn10_set_cursor_attribute(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_cursor_attributes *attributes = &pipe_ctx->stream->cursor_attributes;
 
@@ -3037,7 +2950,7 @@ static void dcn10_set_cursor_attribute(struct pipe_ctx *pipe_ctx)
 		pipe_ctx->plane_res.dpp, attributes);
 }
 
-static void dcn10_set_cursor_sdr_white_level(struct pipe_ctx *pipe_ctx)
+void dcn10_set_cursor_sdr_white_level(struct pipe_ctx *pipe_ctx)
 {
 	uint32_t sdr_white_level = pipe_ctx->stream->cursor_attributes.sdr_white_level;
 	struct fixed31_32 multiplier;
@@ -3064,12 +2977,12 @@ static void dcn10_set_cursor_sdr_white_level(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->plane_res.dpp, &opt_attr);
 }
 
-/**
-* apply_front_porch_workaround  TODO FPGA still need?
-*
-* This is a workaround for a bug that has existed since R5xx and has not been
-* fixed keep Front porch at minimum 2 for Interlaced mode or 1 for progressive.
-*/
+/*
+ * apply_front_porch_workaround  TODO FPGA still need?
+ *
+ * This is a workaround for a bug that has existed since R5xx and has not been
+ * fixed keep Front porch at minimum 2 for Interlaced mode or 1 for progressive.
+ */
 static void apply_front_porch_workaround(
 	struct dc_crtc_timing *timing)
 {
@@ -3082,7 +2995,7 @@ static void apply_front_porch_workaround(
 	}
 }
 
-int get_vupdate_offset_from_vsync(struct pipe_ctx *pipe_ctx)
+int dcn10_get_vupdate_offset_from_vsync(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_crtc_timing *dc_crtc_timing = &pipe_ctx->stream->timing;
 	struct dc_crtc_timing patched_crtc_timing;
@@ -3111,34 +3024,8 @@ int get_vupdate_offset_from_vsync(struct pipe_ctx *pipe_ctx)
 	return vertical_line_start;
 }
 
-void lock_all_pipes(struct dc *dc,
-	struct dc_state *context,
-	bool lock)
-{
-	struct pipe_ctx *pipe_ctx;
-	struct timing_generator *tg;
-	int i;
-
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		pipe_ctx = &context->res_ctx.pipe_ctx[i];
-		tg = pipe_ctx->stream_res.tg;
-		/*
-		 * Only lock the top pipe's tg to prevent redundant
-		 * (un)locking. Also skip if pipe is disabled.
-		 */
-		if (pipe_ctx->top_pipe ||
-		    !pipe_ctx->stream || !pipe_ctx->plane_state ||
-		    !tg->funcs->is_tg_enabled(tg))
-			continue;
-
-		if (lock)
-			tg->funcs->lock(tg);
-		else
-			tg->funcs->unlock(tg);
-	}
-}
-
-static void calc_vupdate_position(
+static void dcn10_calc_vupdate_position(
+		struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
 		uint32_t *start_line,
 		uint32_t *end_line)
@@ -3146,7 +3033,7 @@ static void calc_vupdate_position(
 	const struct dc_crtc_timing *dc_crtc_timing = &pipe_ctx->stream->timing;
 	int vline_int_offset_from_vupdate =
 			pipe_ctx->stream->periodic_interrupt0.lines_offset;
-	int vupdate_offset_from_vsync = get_vupdate_offset_from_vsync(pipe_ctx);
+	int vupdate_offset_from_vsync = dc->hwss.get_vupdate_offset_from_vsync(pipe_ctx);
 	int start_position;
 
 	if (vline_int_offset_from_vupdate > 0)
@@ -3167,7 +3054,8 @@ static void calc_vupdate_position(
 		*end_line = 2;
 }
 
-static void cal_vline_position(
+static void dcn10_cal_vline_position(
+		struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
 		enum vline_select vline,
 		uint32_t *start_line,
@@ -3182,7 +3070,8 @@ static void cal_vline_position(
 
 	switch (ref_point) {
 	case START_V_UPDATE:
-		calc_vupdate_position(
+		dcn10_calc_vupdate_position(
+				dc,
 				pipe_ctx,
 				start_line,
 				end_line);
@@ -3196,7 +3085,8 @@ static void cal_vline_position(
 	}
 }
 
-static void dcn10_setup_periodic_interrupt(
+void dcn10_setup_periodic_interrupt(
+		struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
 		enum vline_select vline)
 {
@@ -3206,7 +3096,7 @@ static void dcn10_setup_periodic_interrupt(
 		uint32_t start_line = 0;
 		uint32_t end_line = 0;
 
-		cal_vline_position(pipe_ctx, vline, &start_line, &end_line);
+		dcn10_cal_vline_position(dc, pipe_ctx, vline, &start_line, &end_line);
 
 		tg->funcs->setup_vertical_interrupt0(tg, start_line, end_line);
 
@@ -3217,10 +3107,10 @@ static void dcn10_setup_periodic_interrupt(
 	}
 }
 
-static void dcn10_setup_vupdate_interrupt(struct pipe_ctx *pipe_ctx)
+void dcn10_setup_vupdate_interrupt(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct timing_generator *tg = pipe_ctx->stream_res.tg;
-	int start_line = get_vupdate_offset_from_vsync(pipe_ctx);
+	int start_line = dc->hwss.get_vupdate_offset_from_vsync(pipe_ctx);
 
 	if (start_line < 0) {
 		ASSERT(0);
@@ -3231,7 +3121,7 @@ static void dcn10_setup_vupdate_interrupt(struct pipe_ctx *pipe_ctx)
 		tg->funcs->setup_vertical_interrupt2(tg, start_line);
 }
 
-static void dcn10_unblank_stream(struct pipe_ctx *pipe_ctx,
+void dcn10_unblank_stream(struct pipe_ctx *pipe_ctx,
 		struct dc_link_settings *link_settings)
 {
 	struct encoder_unblank_param params = { { 0 } };
@@ -3254,7 +3144,7 @@ static void dcn10_unblank_stream(struct pipe_ctx *pipe_ctx,
 	}
 }
 
-static void dcn10_send_immediate_sdp_message(struct pipe_ctx *pipe_ctx,
+void dcn10_send_immediate_sdp_message(struct pipe_ctx *pipe_ctx,
 				const uint8_t *custom_sdp_message,
 				unsigned int sdp_message_size)
 {
@@ -3265,7 +3155,7 @@ static void dcn10_send_immediate_sdp_message(struct pipe_ctx *pipe_ctx,
 				sdp_message_size);
 	}
 }
-static enum dc_status dcn10_set_clock(struct dc *dc,
+enum dc_status dcn10_set_clock(struct dc *dc,
 			enum dc_clock_type clock_type,
 			uint32_t clk_khz,
 			uint32_t stepping)
@@ -3305,7 +3195,7 @@ static enum dc_status dcn10_set_clock(struct dc *dc,
 
 }
 
-static void dcn10_get_clock(struct dc *dc,
+void dcn10_get_clock(struct dc *dc,
 			enum dc_clock_type clock_type,
 			struct dc_clock_config *clock_cfg)
 {
@@ -3315,77 +3205,3 @@ static void dcn10_get_clock(struct dc *dc,
 				dc->clk_mgr->funcs->get_clock(dc->clk_mgr, context, clock_type, clock_cfg);
 
 }
-
-static const struct hw_sequencer_funcs dcn10_funcs = {
-	.program_gamut_remap = dcn10_program_gamut_remap,
-	.init_hw = dcn10_init_hw,
-	.init_pipes = dcn10_init_pipes,
-	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
-	.apply_ctx_for_surface = dcn10_apply_ctx_for_surface,
-	.update_plane_addr = dcn10_update_plane_addr,
-	.plane_atomic_disconnect = hwss1_plane_atomic_disconnect,
-	.update_dchub = dcn10_update_dchub,
-	.update_mpcc = dcn10_update_mpcc,
-	.update_pending_status = dcn10_update_pending_status,
-	.set_input_transfer_func = dcn10_set_input_transfer_func,
-	.set_output_transfer_func = dcn10_set_output_transfer_func,
-	.program_output_csc = dcn10_program_output_csc,
-	.power_down = dce110_power_down,
-	.enable_accelerated_mode = dce110_enable_accelerated_mode,
-	.enable_timing_synchronization = dcn10_enable_timing_synchronization,
-	.enable_per_frame_crtc_position_reset = dcn10_enable_per_frame_crtc_position_reset,
-	.update_info_frame = dce110_update_info_frame,
-	.send_immediate_sdp_message = dcn10_send_immediate_sdp_message,
-	.enable_stream = dce110_enable_stream,
-	.disable_stream = dce110_disable_stream,
-	.unblank_stream = dcn10_unblank_stream,
-	.blank_stream = dce110_blank_stream,
-	.enable_audio_stream = dce110_enable_audio_stream,
-	.disable_audio_stream = dce110_disable_audio_stream,
-	.enable_display_power_gating = dcn10_dummy_display_power_gating,
-	.disable_plane = dcn10_disable_plane,
-	.blank_pixel_data = dcn10_blank_pixel_data,
-	.pipe_control_lock = dcn10_pipe_control_lock,
-	.prepare_bandwidth = dcn10_prepare_bandwidth,
-	.optimize_bandwidth = dcn10_optimize_bandwidth,
-	.reset_hw_ctx_wrap = dcn10_reset_hw_ctx_wrap,
-	.enable_stream_timing = dcn10_enable_stream_timing,
-	.set_drr = dcn10_set_drr,
-	.get_position = dcn10_get_position,
-	.set_static_screen_control = dcn10_set_static_screen_control,
-	.setup_stereo = dcn10_setup_stereo,
-	.set_avmute = dce110_set_avmute,
-	.log_hw_state = dcn10_log_hw_state,
-	.get_hw_state = dcn10_get_hw_state,
-	.clear_status_bits = dcn10_clear_status_bits,
-	.wait_for_mpcc_disconnect = dcn10_wait_for_mpcc_disconnect,
-	.edp_backlight_control = dce110_edp_backlight_control,
-	.edp_power_control = dce110_edp_power_control,
-	.edp_wait_for_hpd_ready = dce110_edp_wait_for_hpd_ready,
-	.set_cursor_position = dcn10_set_cursor_position,
-	.set_cursor_attribute = dcn10_set_cursor_attribute,
-	.set_cursor_sdr_white_level = dcn10_set_cursor_sdr_white_level,
-	.disable_stream_gating = NULL,
-	.enable_stream_gating = NULL,
-	.setup_periodic_interrupt = dcn10_setup_periodic_interrupt,
-	.setup_vupdate_interrupt = dcn10_setup_vupdate_interrupt,
-	.set_clock = dcn10_set_clock,
-	.get_clock = dcn10_get_clock,
-	.did_underflow_occur = dcn10_did_underflow_occur,
-	.init_blank = NULL,
-	.disable_vga = dcn10_disable_vga,
-	.bios_golden_init = dcn10_bios_golden_init,
-	.plane_atomic_disable = dcn10_plane_atomic_disable,
-	.plane_atomic_power_down = dcn10_plane_atomic_power_down,
-	.enable_power_gating_plane = dcn10_enable_power_gating_plane,
-	.dpp_pg_control = dcn10_dpp_pg_control,
-	.hubp_pg_control = dcn10_hubp_pg_control,
-	.dsc_pg_control = NULL,
-};
-
-
-void dcn10_hw_sequencer_construct(struct dc *dc)
-{
-	dc->hwss = dcn10_funcs;
-}
-

commit 46250a0cba4ce9c9754b922ef89a2aa484209164
Author: Michael Strauss <michael.strauss@amd.com>
Date:   Sun Nov 3 09:35:03 2019 -0500

    drm/amd/display: Avoid conflict between HDR multiplier and 3dlut
    
    [WHY]
    There can be a conflict between OS HDR multiplier and 3dlut HDR
    multiplier, which are both sent to DC.
    
    [HOW]
    Instead of having dc determine which HDR multiplier to use, make the
    decision in dm and send only the intended value in a surface update.
    Store the current OS HDR multiplier and determine whether to use it or
    the 3dlut's multiplier before sending the surface update to dc. Send
    multiplier to dc in fixed31_32 format, dc then converts it to hw format.
    
    Signed-off-by: Michael Strauss <michael.strauss@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index adba767ccf2e..f21a385a936f 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2457,16 +2457,20 @@ static void dcn10_blank_pixel_data(
 
 void set_hdr_multiplier(struct pipe_ctx *pipe_ctx)
 {
-	struct fixed31_32 multiplier = dc_fixpt_from_fraction(
-			pipe_ctx->plane_state->sdr_white_level, 80);
+	struct fixed31_32 multiplier = pipe_ctx->plane_state->hdr_mult;
 	uint32_t hw_mult = 0x1f000; // 1.0 default multiplier
 	struct custom_float_format fmt;
+	bool mult_negative; // True if fixed31_32 sign bit indicates negative value
+	uint32_t mult_int; // int component of fixed31_32
 
 	fmt.exponenta_bits = 6;
 	fmt.mantissa_bits = 12;
 	fmt.sign = true;
 
-	if (pipe_ctx->plane_state->sdr_white_level > 80)
+	mult_negative = multiplier.value >> 63 != 0;
+	mult_int = multiplier.value >> 32;
+
+	if (mult_int && !mult_negative) // Check if greater than 1
 		convert_to_custom_float_format(multiplier, &fmt, &hw_mult);
 
 	pipe_ctx->plane_res.dpp->funcs->dpp_set_hdr_multiplier(

commit aca935c7cc866a935a61769c9e9782dd834a8502
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:44:19 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_1 flag
    
    [Why]
    
    DCN21 is stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DCN2_1 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_1 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DCN2_1 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_1 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup Renoir definitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN21 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index fc07538f00ec..adba767ccf2e 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -677,10 +677,8 @@ static void dcn10_bios_golden_init(struct dc *dc)
 	int i;
 	bool allow_self_fresh_force_enable = true;
 
-#if defined(CONFIG_DRM_AMD_DC_DCN2_1)
 	if (dc->hwss.s0i3_golden_init_wa && dc->hwss.s0i3_golden_init_wa(dc))
 		return;
-#endif
 	if (dc->res_pool->hubbub->funcs->is_allow_self_refresh_enabled)
 		allow_self_fresh_force_enable =
 				dc->res_pool->hubbub->funcs->is_allow_self_refresh_enabled(dc->res_pool->hubbub);

commit 1da37801a8b0fffb024fea594c7f1d7867ed8aa0
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:38:55 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_0 and DSC_SUPPORTED
    
    [Why]
    
    DCN2 and DSC are stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup NV defninitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN2 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * dce/dce_dmcu.c: dcn20_*lock_phy()
        * dce/dce_dmcu.c: dcn20_funcs
        * dce/dce_dmcu.c: dcn20_dmcu_create()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 0a30d97b2656..fc07538f00ec 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -49,9 +49,7 @@
 #include "clk_mgr.h"
 
 
-#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 #include "dsc.h"
-#endif
 
 #define DC_LOGGER_INIT(logger)
 
@@ -315,7 +313,6 @@ void dcn10_log_hw_state(struct dc *dc,
 		/* Read shared OTG state registers for all DCNx */
 		optc1_read_otg_state(DCN10TG_FROM_TG(tg), &s);
 
-#ifdef CONFIG_DRM_AMD_DC_DCN2_0
 		/*
 		 * For DCN2 and greater, a register on the OPP is used to
 		 * determine if the CRTC is blanked instead of the OTG. So use
@@ -327,9 +324,6 @@ void dcn10_log_hw_state(struct dc *dc,
 			s.blank_enabled = pool->opps[i]->funcs->dpg_is_blanked(pool->opps[i]);
 		else
 			s.blank_enabled = tg->funcs->is_blanked(tg);
-#else
-		s.blank_enabled = tg->funcs->is_blanked(tg);
-#endif
 
 		//only print if OTG master is enabled
 		if ((s.otg_enabled & 1) == 0)
@@ -364,7 +358,6 @@ void dcn10_log_hw_state(struct dc *dc,
 	}
 	DTN_INFO("\n");
 
-#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 	DTN_INFO("DSC: CLOCK_EN  SLICE_WIDTH  Bytes_pp\n");
 	for (i = 0; i < pool->res_cap->num_dsc; i++) {
 		struct display_stream_compressor *dsc = pool->dscs[i];
@@ -419,7 +412,6 @@ void dcn10_log_hw_state(struct dc *dc,
 		}
 	}
 	DTN_INFO("\n");
-#endif
 
 	DTN_INFO("\nCALCULATED Clocks: dcfclk_khz:%d  dcfclk_deep_sleep_khz:%d  dispclk_khz:%d\n"
 		"dppclk_khz:%d  max_supported_dppclk_khz:%d  fclk_khz:%d  socclk_khz:%d\n\n",
@@ -1273,11 +1265,9 @@ static void dcn10_init_hw(struct dc *dc)
 	}
 
 	/* Power gate DSCs */
-#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 	for (i = 0; i < res_pool->res_cap->num_dsc; i++)
 		if (dc->hwss.dsc_pg_control != NULL)
 			dc->hwss.dsc_pg_control(hws, res_pool->dscs[i]->inst, false);
-#endif
 
 	/* If taking control over from VBIOS, we may want to optimize our first
 	 * mode set, so we need to skip powering down pipes until we know which
@@ -2190,12 +2180,8 @@ static void update_dpp(struct dpp *dpp, struct dc_plane_state *plane_state)
 			plane_state->format,
 			EXPANSION_MODE_ZERO,
 			plane_state->input_csc_color_matrix,
-#ifdef CONFIG_DRM_AMD_DC_DCN2_0
 			plane_state->color_space,
 			NULL);
-#else
-			plane_state->color_space);
-#endif
 
 	//set scale and bias registers
 	dcn10_build_prescale_params(&bns_params, plane_state);
@@ -2649,11 +2635,9 @@ static void dcn10_apply_ctx_for_surface(
 	if (num_planes > 0)
 		program_all_pipe_in_tree(dc, top_pipe_to_program, context);
 
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	/* Program secondary blending tree and writeback pipes */
 	if ((stream->num_wb_info > 0) && (dc->hwss.program_all_writeback_pipes_in_tree))
 		dc->hwss.program_all_writeback_pipes_in_tree(dc, stream, context);
-#endif
 	if (interdependent_update)
 		for (i = 0; i < dc->res_pool->pipe_count; i++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];

commit ae8cf9774e3a609066b277c3742c3551564fb079
Author: Leo (Hanghong) Ma <hanghong.ma@amd.com>
Date:   Fri Sep 6 09:49:19 2019 -0400

    drm/amd/display: Add some hardware status in DTN log debugfs
    
    [Why]
    For debug purpose, we need to check the following hardware status
    in DTN log debugfs:
    1.dpp & hubp clock enable;
    2.crtc blank enable;
    3.link phy status;
    
    [How]
    Add the upper information in the amdgpu_dm_dtn_log debugfs.
    
    For CRTC blanked status, since DCN2 and greater reports it on the OPP
    instead of OTG, we patch it in after calling optc1_read_otg_states.
    Ideally, this should be done in the DCN version specific function hooks.
    It has been left as a TODO item.
    
    Signed-off-by: Leo (Hanghong) Ma <hanghong.ma@amd.com>
    Reviewed-by: Mikita Lipski <Mikita.Lipski@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 32844cd50d09..0a30d97b2656 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -129,9 +129,8 @@ static void dcn10_log_hubp_states(struct dc *dc, void *log_ctx)
 	struct resource_pool *pool = dc->res_pool;
 	int i;
 
-	DTN_INFO("HUBP:  format  addr_hi  width  height"
-			"  rot  mir  sw_mode  dcc_en  blank_en  ttu_dis  underflow"
-			"   min_ttu_vblank       qos_low_wm      qos_high_wm\n");
+	DTN_INFO(
+		"HUBP:  format  addr_hi  width  height  rot  mir  sw_mode  dcc_en  blank_en  clock_en  ttu_dis  underflow   min_ttu_vblank       qos_low_wm      qos_high_wm\n");
 	for (i = 0; i < pool->pipe_count; i++) {
 		struct hubp *hubp = pool->hubps[i];
 		struct dcn_hubp_state *s = &(TO_DCN10_HUBP(hubp)->state);
@@ -139,8 +138,7 @@ static void dcn10_log_hubp_states(struct dc *dc, void *log_ctx)
 		hubp->funcs->hubp_read_state(hubp);
 
 		if (!s->blank_en) {
-			DTN_INFO("[%2d]:  %5xh  %6xh  %5d  %6d  %2xh  %2xh  %6xh"
-					"  %6d  %8d  %7d  %8xh",
+			DTN_INFO("[%2d]:  %5xh  %6xh  %5d  %6d  %2xh  %2xh  %6xh  %6d  %8d  %8d  %7d  %8xh",
 					hubp->inst,
 					s->pixel_format,
 					s->inuse_addr_hi,
@@ -151,6 +149,7 @@ static void dcn10_log_hubp_states(struct dc *dc, void *log_ctx)
 					s->sw_mode,
 					s->dcc_en,
 					s->blank_en,
+					s->clock_en,
 					s->ttu_disable,
 					s->underflow_status);
 			DTN_INFO_MICRO_SEC(s->min_ttu_vblank);
@@ -308,21 +307,35 @@ void dcn10_log_hw_state(struct dc *dc,
 	}
 	DTN_INFO("\n");
 
-	DTN_INFO("OTG:  v_bs  v_be  v_ss  v_se  vpol  vmax  vmin  vmax_sel  vmin_sel"
-			"  h_bs  h_be  h_ss  h_se  hpol  htot  vtot  underflow\n");
+	DTN_INFO("OTG:  v_bs  v_be  v_ss  v_se  vpol  vmax  vmin  vmax_sel  vmin_sel  h_bs  h_be  h_ss  h_se  hpol  htot  vtot  underflow blank_en\n");
 
 	for (i = 0; i < pool->timing_generator_count; i++) {
 		struct timing_generator *tg = pool->timing_generators[i];
 		struct dcn_otg_state s = {0};
-
+		/* Read shared OTG state registers for all DCNx */
 		optc1_read_otg_state(DCN10TG_FROM_TG(tg), &s);
 
+#ifdef CONFIG_DRM_AMD_DC_DCN2_0
+		/*
+		 * For DCN2 and greater, a register on the OPP is used to
+		 * determine if the CRTC is blanked instead of the OTG. So use
+		 * dpg_is_blanked() if exists, otherwise fallback on otg.
+		 *
+		 * TODO: Implement DCN-specific read_otg_state hooks.
+		 */
+		if (pool->opps[i]->funcs->dpg_is_blanked)
+			s.blank_enabled = pool->opps[i]->funcs->dpg_is_blanked(pool->opps[i]);
+		else
+			s.blank_enabled = tg->funcs->is_blanked(tg);
+#else
+		s.blank_enabled = tg->funcs->is_blanked(tg);
+#endif
+
 		//only print if OTG master is enabled
 		if ((s.otg_enabled & 1) == 0)
 			continue;
 
-		DTN_INFO("[%d]: %5d %5d %5d %5d %5d %5d %5d %9d %9d %5d %5d %5d"
-				" %5d %5d %5d %5d  %9d\n",
+		DTN_INFO("[%d]: %5d %5d %5d %5d %5d %5d %5d %9d %9d %5d %5d %5d %5d %5d %5d %5d  %9d %8d\n",
 				tg->inst,
 				s.v_blank_start,
 				s.v_blank_end,
@@ -340,7 +353,8 @@ void dcn10_log_hw_state(struct dc *dc,
 				s.h_sync_a_pol,
 				s.h_total,
 				s.v_total,
-				s.underflow_occurred_status);
+				s.underflow_occurred_status,
+				s.blank_enabled);
 
 		// Clear underflow for debug purposes
 		// We want to keep underflow sticky bit on for the longevity tests outside of test environment.
@@ -387,7 +401,7 @@ void dcn10_log_hw_state(struct dc *dc,
 	}
 	DTN_INFO("\n");
 
-	DTN_INFO("L_ENC: DPHY_FEC_EN  DPHY_FEC_READY_SHADOW  DPHY_FEC_ACTIVE_STATUS\n");
+	DTN_INFO("L_ENC: DPHY_FEC_EN  DPHY_FEC_READY_SHADOW  DPHY_FEC_ACTIVE_STATUS  DP_LINK_TRAINING_COMPLETE\n");
 	for (i = 0; i < dc->link_count; i++) {
 		struct link_encoder *lenc = dc->links[i]->link_enc;
 
@@ -395,11 +409,12 @@ void dcn10_log_hw_state(struct dc *dc,
 
 		if (lenc->funcs->read_state) {
 			lenc->funcs->read_state(lenc, &s);
-			DTN_INFO("[%-3d]: %-12d %-22d %-22d\n",
+			DTN_INFO("[%-3d]: %-12d %-22d %-22d %-25d\n",
 				i,
 				s.dphy_fec_en,
 				s.dphy_fec_ready_shadow,
-				s.dphy_fec_active_status);
+				s.dphy_fec_active_status,
+				s.dp_link_training_complete);
 			DTN_INFO("\n");
 		}
 	}

commit a7e3658e9430c19bc7b87949fb826e49ec0465b4
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Sat Oct 12 16:06:19 2019 -0400

    drm/amd/display: Change dmcu init sequence for dmcub loading dmcu FW.
    
    [Why]
    DMCU isn't intiliazed properly by dmcub loading due to dmcub initialize
    sequence.
    
    [How]
    Change dmcu init sequece to meet dmcub initilize.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index eb91432621ab..32844cd50d09 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1285,7 +1285,7 @@ static void dcn10_init_hw(struct dc *dc)
 		abm->funcs->abm_init(abm);
 	}
 
-	if (dmcu != NULL)
+	if (dmcu != NULL && !dmcu->auto_load_dmcu)
 		dmcu->funcs->dmcu_init(dmcu);
 
 	if (abm != NULL && dmcu != NULL)

commit 622a88c8259e2e517e7145595715d661774c859e
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Tue Sep 24 12:02:38 2019 -0400

    drm/amd/display: move wm ranges reporting to end of init hw
    
    [Why]
    SMU does not keep the wm table across S3, S4, need to re-send
    the table. Also defer sending the cable to after DCN bave initialized
    
    [How]
    Send table at end of init hw
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index df1be8ada66d..eb91432621ab 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1304,6 +1304,10 @@ static void dcn10_init_hw(struct dc *dc)
 	}
 
 	dc->hwss.enable_power_gating_plane(dc->hwseq, true);
+
+	if (dc->clk_mgr->funcs->notify_wm_ranges)
+		dc->clk_mgr->funcs->notify_wm_ranges(dc->clk_mgr);
+
 }
 
 static void dcn10_reset_hw_ctx_wrap(

commit c0fb59a4c3f5d42776e9823579bd94f6ddec0359
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Oct 2 11:54:56 2019 -0400

    drm/amd/display: Add renoir hw_seq
    
    This change adds renoir hw_seq, needed to do renoir
    specific hw programing
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 32bf6cf09677..df1be8ada66d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -670,6 +670,10 @@ static void dcn10_bios_golden_init(struct dc *dc)
 	int i;
 	bool allow_self_fresh_force_enable = true;
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_1)
+	if (dc->hwss.s0i3_golden_init_wa && dc->hwss.s0i3_golden_init_wa(dc))
+		return;
+#endif
 	if (dc->res_pool->hubbub->funcs->is_allow_self_refresh_enabled)
 		allow_self_fresh_force_enable =
 				dc->res_pool->hubbub->funcs->is_allow_self_refresh_enabled(dc->res_pool->hubbub);

commit 1caba4e83b9d8a322375de04d2cfe23d7ccc1b89
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Fri Sep 6 16:24:54 2019 -0400

    drm/amd/display: Update V_UPDATE whenever VSTARTUP changes
    
    [Why]
    If VSTARTUP changes due to bandwidth requirements, we must
    recalculate and update VLINE2 as well for proper flip reporting.
    
    [How]
    After all calls to program_global_sync which reconfigures
    VSTARTUP, also make sure to update V_UPDATE (i.e. VLINE2 on DCNx).
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Sivapiriyan Kumarasamy <Sivapiriyan.Kumarasamy@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 2fe29526532c..32bf6cf09677 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2511,8 +2511,10 @@ static void program_all_pipe_in_tree(
 		pipe_ctx->stream_res.tg->funcs->set_vtg_params(
 				pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing);
 
-		dc->hwss.blank_pixel_data(dc, pipe_ctx, blank);
+		if (dc->hwss.setup_vupdate_interrupt)
+			dc->hwss.setup_vupdate_interrupt(pipe_ctx);
 
+		dc->hwss.blank_pixel_data(dc, pipe_ctx, blank);
 	}
 
 	if (pipe_ctx->plane_state != NULL)

commit cbc697b2e3bfcb0dacced1d3e88ba99481831c42
Author: Wyatt Wood <wyatt.wood@amd.com>
Date:   Tue Sep 3 10:29:00 2019 -0400

    drm/amd/display: Add Logging for Gamma Related information
    
    [Why]
    A recent bug showed that logging would be useful in debugging
    various gamma issues.
    
    [How]
    Fix formatting for easier graphing.
    Prevent performance hit when doing diag.
    
    Signed-off-by: Wyatt Wood <wyatt.wood@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e8214131d43c..2fe29526532c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1452,15 +1452,15 @@ static void log_tf(struct dc_context *ctx,
 	DC_LOG_ALL_TF_CHANNELS("Logging all channels...");
 
 	for (i = 0; i < hw_points_num; i++) {
-		DC_LOG_GAMMA("R\t%d\t%llu\n", i, tf->tf_pts.red[i].value);
-		DC_LOG_ALL_TF_CHANNELS("G\t%d\t%llu\n", i, tf->tf_pts.green[i].value);
-		DC_LOG_ALL_TF_CHANNELS("B\t%d\t%llu\n", i, tf->tf_pts.blue[i].value);
+		DC_LOG_GAMMA("R\t%d\t%llu", i, tf->tf_pts.red[i].value);
+		DC_LOG_ALL_TF_CHANNELS("G\t%d\t%llu", i, tf->tf_pts.green[i].value);
+		DC_LOG_ALL_TF_CHANNELS("B\t%d\t%llu", i, tf->tf_pts.blue[i].value);
 	}
 
 	for (i = hw_points_num; i < MAX_NUM_HW_POINTS; i++) {
-		DC_LOG_ALL_GAMMA("R\t%d\t%llu\n", i, tf->tf_pts.red[i].value);
-		DC_LOG_ALL_TF_CHANNELS("G\t%d\t%llu\n", i, tf->tf_pts.green[i].value);
-		DC_LOG_ALL_TF_CHANNELS("B\t%d\t%llu\n", i, tf->tf_pts.blue[i].value);
+		DC_LOG_ALL_GAMMA("R\t%d\t%llu", i, tf->tf_pts.red[i].value);
+		DC_LOG_ALL_TF_CHANNELS("G\t%d\t%llu", i, tf->tf_pts.green[i].value);
+		DC_LOG_ALL_TF_CHANNELS("B\t%d\t%llu", i, tf->tf_pts.blue[i].value);
 	}
 }
 

commit 799c5b9cb91ca759df65707d2820b5fe1ee5383c
Author: Wesley Chalmers <Wesley.Chalmers@amd.com>
Date:   Mon Aug 26 15:02:47 2019 -0400

    drm/amd/display: Revert fixup DPP programming sequence
    
    [WHY]
    This change was made because DTO programming was double-buffered, which
    is itself an issue. After deactivating the DTO double buffer, this
    change becomes unnecessary.
    
    Signed-off-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 60123db7ba02..e8214131d43c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2304,8 +2304,7 @@ void update_dchubp_dpp(
 			dc->res_pool->dccg->funcs->update_dpp_dto(
 					dc->res_pool->dccg,
 					dpp->inst,
-					pipe_ctx->plane_res.bw.dppclk_khz,
-					false);
+					pipe_ctx->plane_res.bw.dppclk_khz);
 		else
 			dc->clk_mgr->clks.dppclk_khz = should_divided_by_2 ?
 						dc->clk_mgr->clks.dispclk_khz / 2 :

commit f49cfa279b9a2214172d13e87fe6a11bd3941f67
Author: hersen wu <hersenxs.wu@amd.com>
Date:   Fri Aug 2 16:01:37 2019 -0400

    drm/amd/display: flicking observed while installing driver on Navi10 CF
    
    [WHY] value of dchub_ref_clock is decided by dchubbub global timer
    settings which is programmed by vbios command table disp_init.
    for multi-GPU case, vbios is posted only for primary GPU. without
    vbios posted for the secondary GPU, value of dchub_ref_clock is not
    set properly. this value will affect dcn bandwidth calcuation and
    cause underflow. user will see screen flicking during driver
    installation for dual GPU case.
    
    [HOW] dc init_hw always call vbios command table disp_init to
    make sure dchubbub global timer is configured and enable.
    
    Signed-off-by: hersen wu <hersenxs.wu@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index bd2a83e05625..60123db7ba02 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1209,34 +1209,34 @@ static void dcn10_init_hw(struct dc *dc)
 		return;
 	}
 
-	if (!dcb->funcs->is_accelerated_mode(dcb)) {
-		dc->hwss.bios_golden_init(dc);
-		if (dc->ctx->dc_bios->fw_info_valid) {
-			res_pool->ref_clocks.xtalin_clock_inKhz =
-					dc->ctx->dc_bios->fw_info.pll_info.crystal_frequency;
-
-			if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
-				if (res_pool->dccg && res_pool->hubbub) {
-
-					(res_pool->dccg->funcs->get_dccg_ref_freq)(res_pool->dccg,
-							dc->ctx->dc_bios->fw_info.pll_info.crystal_frequency,
-							&res_pool->ref_clocks.dccg_ref_clock_inKhz);
-
-					(res_pool->hubbub->funcs->get_dchub_ref_freq)(res_pool->hubbub,
-							res_pool->ref_clocks.dccg_ref_clock_inKhz,
-							&res_pool->ref_clocks.dchub_ref_clock_inKhz);
-				} else {
-					// Not all ASICs have DCCG sw component
-					res_pool->ref_clocks.dccg_ref_clock_inKhz =
-							res_pool->ref_clocks.xtalin_clock_inKhz;
-					res_pool->ref_clocks.dchub_ref_clock_inKhz =
-							res_pool->ref_clocks.xtalin_clock_inKhz;
-				}
-			}
-		} else
-			ASSERT_CRITICAL(false);
+	if (!dcb->funcs->is_accelerated_mode(dcb))
 		dc->hwss.disable_vga(dc->hwseq);
-	}
+
+	dc->hwss.bios_golden_init(dc);
+	if (dc->ctx->dc_bios->fw_info_valid) {
+		res_pool->ref_clocks.xtalin_clock_inKhz =
+				dc->ctx->dc_bios->fw_info.pll_info.crystal_frequency;
+
+		if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
+			if (res_pool->dccg && res_pool->hubbub) {
+
+				(res_pool->dccg->funcs->get_dccg_ref_freq)(res_pool->dccg,
+						dc->ctx->dc_bios->fw_info.pll_info.crystal_frequency,
+						&res_pool->ref_clocks.dccg_ref_clock_inKhz);
+
+				(res_pool->hubbub->funcs->get_dchub_ref_freq)(res_pool->hubbub,
+						res_pool->ref_clocks.dccg_ref_clock_inKhz,
+						&res_pool->ref_clocks.dchub_ref_clock_inKhz);
+			} else {
+				// Not all ASICs have DCCG sw component
+				res_pool->ref_clocks.dccg_ref_clock_inKhz =
+						res_pool->ref_clocks.xtalin_clock_inKhz;
+				res_pool->ref_clocks.dchub_ref_clock_inKhz =
+						res_pool->ref_clocks.xtalin_clock_inKhz;
+			}
+		}
+	} else
+		ASSERT_CRITICAL(false);
 
 	for (i = 0; i < dc->link_count; i++) {
 		/* Power up AND update implementation according to the

commit 470e2ca569bf780f832e3020ceb5afdef16a9084
Author: Bayan Zabihiyan <bayan.zabihiyan@amd.com>
Date:   Thu Aug 8 11:08:52 2019 -0400

    drm/amd/display: Expose OTG_V_TOTAL_MID for HW Diags
    
    [Why]
    Existing HW Features, HW Diags test requested that the
    registers be exposed.
    
    [How]
    Add V_TOTAL_MID to existing DC structures.
    Make sure values are passed down throughout DC
    Add Register definition.
    Program the additional registers
    Add additional Logic for V_TOTAL_CONTROL.
    
    Signed-off-by: Bayan Zabihiyan <bayan.zabihiyan@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 4970543b7f05..bd2a83e05625 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2747,7 +2747,8 @@ static void dcn10_optimize_bandwidth(
 }
 
 static void dcn10_set_drr(struct pipe_ctx **pipe_ctx,
-		int num_pipes, int vmin, int vmax)
+		int num_pipes, unsigned int vmin, unsigned int vmax,
+		unsigned int vmid, unsigned int vmid_frame_number)
 {
 	int i = 0;
 	struct drr_params params = {0};
@@ -2756,6 +2757,8 @@ static void dcn10_set_drr(struct pipe_ctx **pipe_ctx,
 
 	params.vertical_total_max = vmax;
 	params.vertical_total_min = vmin;
+	params.vertical_total_mid = vmid;
+	params.vertical_total_mid_frame_num = vmid_frame_number;
 
 	/* TODO: If multiple pipes are to be supported, you need
 	 * some GSL stuff. Static screen triggers may be programmed differently

commit 4551666f5b6c46defad645f7b7e9b4a486985df6
Author: Wyatt Wood <wyatt.wood@amd.com>
Date:   Wed Aug 7 13:48:24 2019 -0400

    drm/amd/display: Add Logging for Gamma Related information
    
    [Why]
    A recent bug showed that logging would be useful in debugging
    various gamma issues.
    
    [How]
    Add logging in dc.
    Fix formatting for easier graphing.
    
    Signed-off-by: Wyatt Wood <wyatt.wood@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 57849d51e5eb..4970543b7f05 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1452,15 +1452,15 @@ static void log_tf(struct dc_context *ctx,
 	DC_LOG_ALL_TF_CHANNELS("Logging all channels...");
 
 	for (i = 0; i < hw_points_num; i++) {
-		DC_LOG_GAMMA("R %d %llu\n", i, tf->tf_pts.red[i].value);
-		DC_LOG_ALL_TF_CHANNELS("G %d, %llu\n", i, tf->tf_pts.green[i].value);
-		DC_LOG_ALL_TF_CHANNELS("B %d, %llu\n", i, tf->tf_pts.blue[i].value);
+		DC_LOG_GAMMA("R\t%d\t%llu\n", i, tf->tf_pts.red[i].value);
+		DC_LOG_ALL_TF_CHANNELS("G\t%d\t%llu\n", i, tf->tf_pts.green[i].value);
+		DC_LOG_ALL_TF_CHANNELS("B\t%d\t%llu\n", i, tf->tf_pts.blue[i].value);
 	}
 
 	for (i = hw_points_num; i < MAX_NUM_HW_POINTS; i++) {
-		DC_LOG_ALL_GAMMA("R %d %llu\n", i, tf->tf_pts.red[i].value);
-		DC_LOG_ALL_TF_CHANNELS("G %d %llu\n", i, tf->tf_pts.green[i].value);
-		DC_LOG_ALL_TF_CHANNELS("B %d %llu\n", i, tf->tf_pts.blue[i].value);
+		DC_LOG_ALL_GAMMA("R\t%d\t%llu\n", i, tf->tf_pts.red[i].value);
+		DC_LOG_ALL_TF_CHANNELS("G\t%d\t%llu\n", i, tf->tf_pts.green[i].value);
+		DC_LOG_ALL_TF_CHANNELS("B\t%d\t%llu\n", i, tf->tf_pts.blue[i].value);
 	}
 }
 

commit c005762253523044c5afade490129fc0dd6f868b
Author: Jaehyun Chung <jaehyun.chung@amd.com>
Date:   Wed Aug 7 11:20:16 2019 -0400

    drm/amd/display: Enable HW rotation
    
    [Why] HW rotation is not enabled. Calculations for cursor rotation
    are wrong for the values passed to set_cursor_position.
    
    [How] Swap Src rect and height and vertically mirror surface for
    the correct surface rotation direction. Cursor position is rotated
    according to angle. Offset calculations are tweaked for non-rotated
    cursor hotspot and width/height.
    
    Signed-off-by: Jaehyun Chung <jaehyun.chung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 029b7b2b62dd..57849d51e5eb 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2976,6 +2976,40 @@ static void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 			== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)
 		pos_cpy.enable = false;
 
+	// Swap axis and mirror horizontally
+	if (param.rotation == ROTATION_ANGLE_90) {
+		uint32_t temp_x = pos_cpy.x;
+		pos_cpy.x = pipe_ctx->plane_res.scl_data.viewport.width -
+				(pos_cpy.y - pipe_ctx->plane_res.scl_data.viewport.x) + pipe_ctx->plane_res.scl_data.viewport.x;
+		pos_cpy.y = temp_x;
+	}
+	// Swap axis and mirror vertically
+	else if (param.rotation == ROTATION_ANGLE_270) {
+		uint32_t temp_y = pos_cpy.y;
+		if (pos_cpy.x >  pipe_ctx->plane_res.scl_data.viewport.height) {
+			pos_cpy.x = pos_cpy.x - pipe_ctx->plane_res.scl_data.viewport.height;
+			pos_cpy.y = pipe_ctx->plane_res.scl_data.viewport.height - pos_cpy.x;
+		} else {
+			pos_cpy.y = 2 * pipe_ctx->plane_res.scl_data.viewport.height - pos_cpy.x;
+		}
+		pos_cpy.x = temp_y;
+	}
+	// Mirror horizontally and vertically
+	else if (param.rotation == ROTATION_ANGLE_180) {
+		if (pos_cpy.x >= pipe_ctx->plane_res.scl_data.viewport.width + pipe_ctx->plane_res.scl_data.viewport.x) {
+			pos_cpy.x = 2 * pipe_ctx->plane_res.scl_data.viewport.width
+					- pos_cpy.x + 2 * pipe_ctx->plane_res.scl_data.viewport.x;
+		} else {
+			uint32_t temp_x = pos_cpy.x;
+			pos_cpy.x = 2 * pipe_ctx->plane_res.scl_data.viewport.x - pos_cpy.x;
+			if (temp_x >= pipe_ctx->plane_res.scl_data.viewport.x + (int)hubp->curs_attr.width
+					|| pos_cpy.x <= (int)hubp->curs_attr.width + pipe_ctx->plane_state->src_rect.x) {
+				pos_cpy.x = temp_x + pipe_ctx->plane_res.scl_data.viewport.width;
+			}
+		}
+		pos_cpy.y = pipe_ctx->plane_res.scl_data.viewport.height - pos_cpy.y;
+	}
+
 	hubp->funcs->set_cursor_position(hubp, &pos_cpy, &param);
 	dpp->funcs->set_cursor_position(dpp, &pos_cpy, &param, hubp->curs_attr.width, hubp->curs_attr.height);
 }

commit 5e1613e21fc1ea5c0888f4c858aa220ff8464d53
Author: Bayan Zabihiyan <bayan.zabihiyan@amd.com>
Date:   Fri Jul 26 11:10:11 2019 -0400

    drm/amd/display: add Cursor Degamma logic for DCN2
    
    [Why]
    We need to have the ability to to tell us set degamma on the cursor.
    
    [How]
    Pass a flag down to register programming that tells us if the
    current surface format needs cursor degamma.
    
    Signed-off-by: Bayan Zabihiyan <bayan.zabihiyan@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 81beff81a1e1..029b7b2b62dd 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2987,7 +2987,7 @@ static void dcn10_set_cursor_attribute(struct pipe_ctx *pipe_ctx)
 	pipe_ctx->plane_res.hubp->funcs->set_cursor_attributes(
 			pipe_ctx->plane_res.hubp, attributes);
 	pipe_ctx->plane_res.dpp->funcs->set_cursor_attributes(
-		pipe_ctx->plane_res.dpp, attributes->color_format);
+		pipe_ctx->plane_res.dpp, attributes);
 }
 
 static void dcn10_set_cursor_sdr_white_level(struct pipe_ctx *pipe_ctx)

commit 75a543347c6be74b2636a1fec7f4ffd1ee4525b2
Author: Martin Leung <martin.leung@amd.com>
Date:   Fri Aug 2 11:01:05 2019 -0400

    drm/amd/display: cleaned up coding error in init_hw
    
    [why]
    during a refactor a redundant code that has unknown behaviour was added.
    
    [how]
    removed old bad code
    
    Fixes: 8a31820b1218 ("drm/amd/display: Make init_hw and init_pipes generic for seamless boot")
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 51c4c62b40e1..81beff81a1e1 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1268,19 +1268,8 @@ static void dcn10_init_hw(struct dc *dc)
 	 */
 	if (dcb->funcs->is_accelerated_mode(dcb) || dc->config.power_down_display_on_boot) {
 		dc->hwss.init_pipes(dc, dc->current_state);
-		for (i = 0; i < res_pool->pipe_count; i++) {
-			struct hubp *hubp = res_pool->hubps[i];
-			struct dpp *dpp = res_pool->dpps[i];
-
-			hubp->funcs->hubp_init(hubp);
-			res_pool->opps[i]->mpc_tree_params.opp_id = res_pool->opps[i]->inst;
-			dc->hwss.plane_atomic_power_down(dc, dpp, hubp);
-		}
-
-		apply_DEGVIDCN10_253_wa(dc);
 	}
 
-
 	for (i = 0; i < res_pool->audio_count; i++) {
 		struct audio *audio = res_pool->audios[i];
 

commit ddef02de0d71d483ad4398393717cc0d53fc990a
Author: Wyatt Wood <wyatt.wood@amd.com>
Date:   Wed Jul 31 15:52:46 2019 -0400

    drm/amd/display: add null checks before logging
    
    Adding NULL checks to various parameters in log_tf, to avoid
    nullptr errors
    
    Signed-off-by: Wyatt Wood <wyatt.wood@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f61f59ac1e00..51c4c62b40e1 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1503,9 +1503,12 @@ dcn10_set_output_transfer_func(struct pipe_ctx *pipe_ctx,
 	} else
 		dpp->funcs->dpp_program_regamma_pwl(dpp, NULL, OPP_REGAMMA_BYPASS);
 
-	log_tf(stream->ctx,
-			stream->out_transfer_func,
-			dpp->regamma_params.hw_points_num);
+	if (stream != NULL && stream->ctx != NULL &&
+			stream->out_transfer_func != NULL) {
+		log_tf(stream->ctx,
+				stream->out_transfer_func,
+				dpp->regamma_params.hw_points_num);
+	}
 
 	return true;
 }

commit 574304041bb9508a4e73533e8d1702b0e713d321
Author: Su Sung Chung <Su.Chung@amd.com>
Date:   Thu Jul 25 14:43:55 2019 -0400

    drm/amd/display: fix audio endpoint not getting disabled issue
    
    [Why]
    Disable_audio_stream gets enum option as a paramenter which will decide
    if we free acquired resources or not. However checks for the option is
    guarded by the other condition which check if audio stream is getting
    diabled more than once. With both conditions combined, if we attempt to
    disable audio stream twice in a row, first with keep and second with
    free as an option, we will never free any resources, which will make
    system think there is audio endpoint connected even after we plug out
    the device
    
    [How]
    Get rid of option as parameter to disable_audio_stream and move the part
    of the code that free acquired resources to outside where to keep or to
    free resources is actually determined
    
    Signed-off-by: Su Sung Chung <Su.Chung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 283915b2c2b1..f61f59ac1e00 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -828,11 +828,23 @@ static void dcn10_reset_back_end_for_pipe(
 	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
 		/* DPMS may already disable */
 		if (!pipe_ctx->stream->dpms_off)
-			core_link_disable_stream(pipe_ctx, FREE_ACQUIRED_RESOURCE);
-		else if (pipe_ctx->stream_res.audio) {
-			dc->hwss.disable_audio_stream(pipe_ctx, FREE_ACQUIRED_RESOURCE);
+			core_link_disable_stream(pipe_ctx);
+		else if (pipe_ctx->stream_res.audio)
+			dc->hwss.disable_audio_stream(pipe_ctx);
+
+		if (pipe_ctx->stream_res.audio) {
+			/*disable az_endpoint*/
+			pipe_ctx->stream_res.audio->funcs->az_disable(pipe_ctx->stream_res.audio);
+
+			/*free audio*/
+			if (dc->caps.dynamic_audio == true) {
+				/*we have to dynamic arbitrate the audio endpoints*/
+				/*we free the resource, need reset is_audio_acquired*/
+				update_audio_usage(&dc->current_state->res_ctx, dc->res_pool,
+						pipe_ctx->stream_res.audio, false);
+				pipe_ctx->stream_res.audio = NULL;
+			}
 		}
-
 	}
 
 	/* by upper caller loop, parent pipe: pipe0, will be reset last.

commit b1f6d01c4a3b7eeb2eb035e79d425cd6a696fa45
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Aug 6 17:17:28 2019 -0400

    drm/amd/display: re structure odm to allow 4 to 1 support
    
    Currently odm is handled using top_bottom pipe by special casing
    the differing opps to differentiate from mpc combine.
    
    Since top/bottom pipe list was made to track mpc muxing this creates
    difficulties in adding a 4 pipe odm case support.
    
    Rather than continue using mpc combine list, this change reworks odm
    to use it's own linked list to keep track of odm combine pipes. This
    also opens up options for using mpo with odm, if a practical use case
    is ever found.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 2d50cfc66e92..283915b2c2b1 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2537,7 +2537,7 @@ struct pipe_ctx *find_top_pipe_for_stream(
 		if (pipe_ctx->stream != stream)
 			continue;
 
-		if (!pipe_ctx->top_pipe)
+		if (!pipe_ctx->top_pipe && !pipe_ctx->prev_odm_pipe)
 			return pipe_ctx;
 	}
 	return NULL;

commit 6d83a32d0bdd39cdcc0d70d7b719cd2ffb419268
Author: Michael Strauss <michael.strauss@amd.com>
Date:   Fri Jul 26 12:04:12 2019 -0400

    drm/amd/display: Enable MPO with pre-blend color processing (RGB)
    
    [Why]
    DCN10 performs color processing before MPC combination, causes color
    shift in RGB colorspaces when positive brightness offset is applied
    However, YCbCr is still unfixed and remains disabled
    
    [How]
    Add layerIndex to dc_plane_state and dc_plane_info structs
    Re-enable MPO when brightness is adjusted and colorspace is not YCbCr
    Set rear plane's brightness offset to 0 when front plane visible
    
    Signed-off-by: Michael Strauss <michael.strauss@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 8ed25f21316d..2d50cfc66e92 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1905,6 +1905,36 @@ static void dcn10_program_gamut_remap(struct pipe_ctx *pipe_ctx)
 	pipe_ctx->plane_res.dpp->funcs->dpp_set_gamut_remap(pipe_ctx->plane_res.dpp, &adjust);
 }
 
+
+static bool dcn10_is_rear_mpo_fix_required(struct pipe_ctx *pipe_ctx, enum dc_color_space colorspace)
+{
+	if (pipe_ctx->plane_state && pipe_ctx->plane_state->layer_index > 0 && is_rgb_cspace(colorspace)) {
+		if (pipe_ctx->top_pipe) {
+			struct pipe_ctx *top = pipe_ctx->top_pipe;
+
+			while (top->top_pipe)
+				top = top->top_pipe; // Traverse to top pipe_ctx
+			if (top->plane_state && top->plane_state->layer_index == 0)
+				return true; // Front MPO plane not hidden
+		}
+	}
+	return false;
+}
+
+static void dcn10_set_csc_adjustment_rgb_mpo_fix(struct pipe_ctx *pipe_ctx, uint16_t *matrix)
+{
+	// Override rear plane RGB bias to fix MPO brightness
+	uint16_t rgb_bias = matrix[3];
+
+	matrix[3] = 0;
+	matrix[7] = 0;
+	matrix[11] = 0;
+	pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment(pipe_ctx->plane_res.dpp, matrix);
+	matrix[3] = rgb_bias;
+	matrix[7] = rgb_bias;
+	matrix[11] = rgb_bias;
+}
+
 static void dcn10_program_output_csc(struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
 		enum dc_color_space colorspace,
@@ -1912,8 +1942,25 @@ static void dcn10_program_output_csc(struct dc *dc,
 		int opp_id)
 {
 	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment == true) {
-		if (pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment != NULL)
-			pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment(pipe_ctx->plane_res.dpp, matrix);
+		if (pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment != NULL) {
+
+			/* MPO is broken with RGB colorspaces when OCSC matrix
+			 * brightness offset >= 0 on DCN1 due to OCSC before MPC
+			 * Blending adds offsets from front + rear to rear plane
+			 *
+			 * Fix is to set RGB bias to 0 on rear plane, top plane
+			 * black value pixels add offset instead of rear + front
+			 */
+
+			int16_t rgb_bias = matrix[3];
+			// matrix[3/7/11] are all the same offset value
+
+			if (rgb_bias > 0 && dcn10_is_rear_mpo_fix_required(pipe_ctx, colorspace)) {
+				dcn10_set_csc_adjustment_rgb_mpo_fix(pipe_ctx, matrix);
+			} else {
+				pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment(pipe_ctx->plane_res.dpp, matrix);
+			}
+		}
 	} else {
 		if (pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_default != NULL)
 			pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_default(pipe_ctx->plane_res.dpp, colorspace);

commit 8221b6eacfc586b07aec101f9cad98e82867668d
Author: Wyatt Wood <wyatt.wood@amd.com>
Date:   Wed Jul 24 13:37:08 2019 -0400

    drm/amd/display: Add Logging for Gamma Related information (2/2)
    
    [Why]
    A recent bug showed that logging would be useful in debugging
    various gamma issues.
    
    [How]
    Add logging in dc.
    
    Signed-off-by: Wyatt Wood <wyatt.wood@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 5527717df3df..8ed25f21316d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1435,6 +1435,34 @@ static bool dcn10_set_input_transfer_func(struct pipe_ctx *pipe_ctx,
 	return result;
 }
 
+#define MAX_NUM_HW_POINTS 0x200
+
+static void log_tf(struct dc_context *ctx,
+				struct dc_transfer_func *tf, uint32_t hw_points_num)
+{
+	// DC_LOG_GAMMA is default logging of all hw points
+	// DC_LOG_ALL_GAMMA logs all points, not only hw points
+	// DC_LOG_ALL_TF_POINTS logs all channels of the tf
+	int i = 0;
+
+	DC_LOGGER_INIT(ctx->logger);
+	DC_LOG_GAMMA("Gamma Correction TF");
+	DC_LOG_ALL_GAMMA("Logging all tf points...");
+	DC_LOG_ALL_TF_CHANNELS("Logging all channels...");
+
+	for (i = 0; i < hw_points_num; i++) {
+		DC_LOG_GAMMA("R %d %llu\n", i, tf->tf_pts.red[i].value);
+		DC_LOG_ALL_TF_CHANNELS("G %d, %llu\n", i, tf->tf_pts.green[i].value);
+		DC_LOG_ALL_TF_CHANNELS("B %d, %llu\n", i, tf->tf_pts.blue[i].value);
+	}
+
+	for (i = hw_points_num; i < MAX_NUM_HW_POINTS; i++) {
+		DC_LOG_ALL_GAMMA("R %d %llu\n", i, tf->tf_pts.red[i].value);
+		DC_LOG_ALL_TF_CHANNELS("G %d %llu\n", i, tf->tf_pts.green[i].value);
+		DC_LOG_ALL_TF_CHANNELS("B %d %llu\n", i, tf->tf_pts.blue[i].value);
+	}
+}
+
 static bool
 dcn10_set_output_transfer_func(struct pipe_ctx *pipe_ctx,
 			       const struct dc_stream_state *stream)
@@ -1463,6 +1491,10 @@ dcn10_set_output_transfer_func(struct pipe_ctx *pipe_ctx,
 	} else
 		dpp->funcs->dpp_program_regamma_pwl(dpp, NULL, OPP_REGAMMA_BYPASS);
 
+	log_tf(stream->ctx,
+			stream->out_transfer_func,
+			dpp->regamma_params.hw_points_num);
+
 	return true;
 }
 

commit 90830e840e39df36e86dae17b41b501bc93dba49
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Fri Jul 19 16:07:33 2019 -0500

    drm/amd/display: Check if set_blank_data_double_buffer exists before call
    
    Not all ASIC types have this function implemented - check before
    calling.
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Julian Parkin <jparkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 06d7bab550e1..5527717df3df 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -721,7 +721,8 @@ static void false_optc_underflow_wa(
 		dc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, old_pipe_ctx);
 	}
 
-	tg->funcs->set_blank_data_double_buffer(tg, true);
+	if (tg->funcs->set_blank_data_double_buffer)
+		tg->funcs->set_blank_data_double_buffer(tg, true);
 
 	if (tg->funcs->is_optc_underflow_occurred(tg) && !underflow)
 		tg->funcs->clear_optc_underflow(tg);

commit 5fc43055b03fabe7bc86ed890636f449e6353c6a
Author: Julian Parkin <julian.parkin@amd.com>
Date:   Mon Jul 15 12:16:01 2019 -0400

    drm/amd/display: Remove duplicate interface for programming FB
    
    [Why]
    There are currently two interfaces for exactly the same thing:
    hupb_update_dchub in hupb and update_dchub in hubbub. The hubbub
    version is currently unused past dcn10, largely because the call
    from the dcn10 hardware sequencer does not call through the
    interface, so the hupb interface was used instead. This is
    confusing because of the duplicate code, the unused functions,
    and the fact that more that one block currently owns this set
    of registers.
    
    [How]
    Remove the hubp interface entirely, as well as the register
    declarations that are not longer needed because of this. Change
    the call site to always call the hubbub version through the
    interface. Fix the update_dchub function in dcn20_hubbub.c to
    program the correct registers for dcn20.
    
    Signed-off-by: Julian Parkin <julian.parkin@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d1697a1ffee6..06d7bab550e1 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2858,14 +2858,10 @@ static void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 
 static void dcn10_update_dchub(struct dce_hwseq *hws, struct dchub_init_data *dh_data)
 {
-	if (hws->ctx->dc->res_pool->hubbub != NULL) {
-		struct hubp *hubp = hws->ctx->dc->res_pool->hubps[0];
+	struct hubbub *hubbub = hws->ctx->dc->res_pool->hubbub;
 
-		if (hubp->funcs->hubp_update_dchub)
-			hubp->funcs->hubp_update_dchub(hubp, dh_data);
-		else
-			hubbub1_update_dchub(hws->ctx->dc->res_pool->hubbub, dh_data);
-	}
+	/* In DCN, this programming sequence is owned by the hubbub */
+	hubbub->funcs->update_dchub(hubbub, dh_data);
 }
 
 static void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)

commit 5ec43eda85506ddc2f91c3a4e28b38da3f14cf1e
Author: Martin Leung <martin.leung@amd.com>
Date:   Wed Jul 17 16:08:19 2019 -0400

    drm/amd/display: enabling seamless boot sequence for dcn2
    
    [Why]
    Seamless boot (building SW state inheriting BIOS-initialized timing) was
    enabled on DCN2, including fixes
    
    [How]
    Includes fixes for MPC, DPPCLK, and DIG FE mapping/OTG source select/
    Pixel clock.
    
    This is part 2 of 2 for seamless boot NV10
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 285a79325d62..d1697a1ffee6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1098,9 +1098,16 @@ static void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 		}
 	}
 
-	/* Cannot reset the MPC mux if seamless boot */
-	if (!can_apply_seamless_boot)
-		dc->res_pool->mpc->funcs->mpc_init(dc->res_pool->mpc);
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		/* Cannot reset the MPC mux if seamless boot */
+		if (pipe_ctx->stream != NULL && can_apply_seamless_boot)
+			continue;
+
+		dc->res_pool->mpc->funcs->mpc_init_single_inst(
+				dc->res_pool->mpc, i);
+	}
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct timing_generator *tg = dc->res_pool->timing_generators[i];

commit 39bdac36cc139dfaf4ff324250319b79c6c224b8
Author: Martin Leung <martin.leung@amd.com>
Date:   Sun Jul 28 11:09:11 2019 -0400

    drm/amd/display: fix dcn-specific clk_mgr init_clocks
    
    [Why]
    underflow seen on certain monitor setups caused by making dcnxx_init_hw
    generic
    
    [How]
    by moving dcn20_init_hw into dcn10, we added a dcn-specific clk_mgr
    init (dc->clk_mgr->funcs->init_clocks()). Thus, put old clk_mgr
    memset in an else statement so both memsets don't get set
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 9dc11a43d6d5..285a79325d62 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1291,8 +1291,6 @@ static void dcn10_init_hw(struct dc *dc)
 	}
 
 	dc->hwss.enable_power_gating_plane(dc->hwseq, true);
-
-	memset(&dc->clk_mgr->clks, 0, sizeof(dc->clk_mgr->clks));
 }
 
 static void dcn10_reset_hw_ctx_wrap(

commit 8a31820b12187c7e31c52e8a00075359d9efac52
Author: Martin Leung <martin.leung@amd.com>
Date:   Tue Jul 9 15:15:17 2019 -0400

    drm/amd/display: Make init_hw and init_pipes generic for seamless boot
    
    [Why]
    For seamless boot the init_hw sequence must be split into
    actual hardware vs pipes, in order to defer pipe initialization to set mode
    and skip of pipe-destructive sequences
    
    [How]
    made dcn10_init_hw and dcn10_init_pipes generic for future dcns to inherit
    deleted dcn20 specific versions. This is part 1 of a 2 partimplementation
    of seamless boot
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 51857cab1459..9dc11a43d6d5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -438,7 +438,7 @@ bool dcn10_did_underflow_occur(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	return false;
 }
 
-static void enable_power_gating_plane(
+static void dcn10_enable_power_gating_plane(
 	struct dce_hwseq *hws,
 	bool enable)
 {
@@ -460,7 +460,7 @@ static void enable_power_gating_plane(
 	REG_UPDATE(DOMAIN7_PG_CONFIG, DOMAIN7_POWER_FORCEON, force_on);
 }
 
-static void disable_vga(
+static void dcn10_disable_vga(
 	struct dce_hwseq *hws)
 {
 	unsigned int in_vga1_mode = 0;
@@ -493,7 +493,7 @@ static void disable_vga(
 	REG_UPDATE(VGA_TEST_CONTROL, VGA_TEST_RENDER_START, 1);
 }
 
-static void dpp_pg_control(
+static void dcn10_dpp_pg_control(
 		struct dce_hwseq *hws,
 		unsigned int dpp_inst,
 		bool power_on)
@@ -545,7 +545,7 @@ static void dpp_pg_control(
 	}
 }
 
-static void hubp_pg_control(
+static void dcn10_hubp_pg_control(
 		struct dce_hwseq *hws,
 		unsigned int hubp_inst,
 		bool power_on)
@@ -605,8 +605,8 @@ static void power_on_plane(
 	if (REG(DC_IP_REQUEST_CNTL)) {
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 1);
-		dpp_pg_control(hws, plane_id, true);
-		hubp_pg_control(hws, plane_id, true);
+		hws->ctx->dc->hwss.dpp_pg_control(hws, plane_id, true);
+		hws->ctx->dc->hwss.hubp_pg_control(hws, plane_id, true);
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 0);
 		DC_LOG_DEBUG(
@@ -627,7 +627,7 @@ static void undo_DEGVIDCN10_253_wa(struct dc *dc)
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 1);
 
-	hubp_pg_control(hws, 0, false);
+	dc->hwss.hubp_pg_control(hws, 0, false);
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
 
@@ -656,7 +656,7 @@ static void apply_DEGVIDCN10_253_wa(struct dc *dc)
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 1);
 
-	hubp_pg_control(hws, 0, true);
+	dc->hwss.hubp_pg_control(hws, 0, true);
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
 
@@ -664,10 +664,23 @@ static void apply_DEGVIDCN10_253_wa(struct dc *dc)
 	hws->wa_state.DEGVIDCN10_253_applied = true;
 }
 
-static void bios_golden_init(struct dc *dc)
+static void dcn10_bios_golden_init(struct dc *dc)
 {
 	struct dc_bios *bp = dc->ctx->dc_bios;
 	int i;
+	bool allow_self_fresh_force_enable = true;
+
+	if (dc->res_pool->hubbub->funcs->is_allow_self_refresh_enabled)
+		allow_self_fresh_force_enable =
+				dc->res_pool->hubbub->funcs->is_allow_self_refresh_enabled(dc->res_pool->hubbub);
+
+
+	/* WA for making DF sleep when idle after resume from S0i3.
+	 * DCHUBBUB_ARB_ALLOW_SELF_REFRESH_FORCE_ENABLE is set to 1 by
+	 * command table, if DCHUBBUB_ARB_ALLOW_SELF_REFRESH_FORCE_ENABLE = 0
+	 * before calling command table and it changed to 1 after,
+	 * it should be set back to 0.
+	 */
 
 	/* initialize dcn global */
 	bp->funcs->enable_disp_power_gating(bp,
@@ -678,6 +691,12 @@ static void bios_golden_init(struct dc *dc)
 		bp->funcs->enable_disp_power_gating(bp,
 				CONTROLLER_ID_D0 + i, ASIC_PIPE_DISABLE);
 	}
+
+	if (dc->res_pool->hubbub->funcs->allow_self_refresh_control)
+		if (allow_self_fresh_force_enable == false &&
+				dc->res_pool->hubbub->funcs->is_allow_self_refresh_enabled(dc->res_pool->hubbub))
+			dc->res_pool->hubbub->funcs->allow_self_refresh_control(dc->res_pool->hubbub, true);
+
 }
 
 static void false_optc_underflow_wa(
@@ -971,7 +990,7 @@ void hwss1_plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 		dcn10_verify_allow_pstate_change_high(dc);
 }
 
-static void plane_atomic_power_down(struct dc *dc,
+static void dcn10_plane_atomic_power_down(struct dc *dc,
 		struct dpp *dpp,
 		struct hubp *hubp)
 {
@@ -981,8 +1000,8 @@ static void plane_atomic_power_down(struct dc *dc,
 	if (REG(DC_IP_REQUEST_CNTL)) {
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 1);
-		dpp_pg_control(hws, dpp->inst, false);
-		hubp_pg_control(hws, hubp->inst, false);
+		dc->hwss.dpp_pg_control(hws, dpp->inst, false);
+		dc->hwss.hubp_pg_control(hws, hubp->inst, false);
 		dpp->funcs->dpp_reset(dpp);
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 0);
@@ -994,7 +1013,7 @@ static void plane_atomic_power_down(struct dc *dc,
 /* disable HW used by plane.
  * note:  cannot disable until disconnect is complete
  */
-static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
+static void dcn10_plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	struct dpp *dpp = pipe_ctx->plane_res.dpp;
@@ -1014,7 +1033,7 @@ static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	hubp->power_gated = true;
 	dc->optimized_required = false; /* We're powering off, no need to optimize */
 
-	plane_atomic_power_down(dc,
+	dc->hwss.plane_atomic_power_down(dc,
 			pipe_ctx->plane_res.dpp,
 			pipe_ctx->plane_res.hubp);
 
@@ -1033,7 +1052,7 @@ static void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	if (!pipe_ctx->plane_res.hubp || pipe_ctx->plane_res.hubp->power_gated)
 		return;
 
-	plane_atomic_disable(dc, pipe_ctx);
+	dc->hwss.plane_atomic_disable(dc, pipe_ctx);
 
 	apply_DEGVIDCN10_253_wa(dc);
 
@@ -1068,9 +1087,14 @@ static void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 		 * command table.
 		 */
 		if (tg->funcs->is_tg_enabled(tg)) {
-			tg->funcs->lock(tg);
-			tg->funcs->set_blank(tg, true);
-			hwss_wait_for_blank_complete(tg);
+			if (dc->hwss.init_blank != NULL) {
+				dc->hwss.init_blank(dc, tg);
+				tg->funcs->lock(tg);
+			} else {
+				tg->funcs->lock(tg);
+				tg->funcs->set_blank(tg, true);
+				hwss_wait_for_blank_complete(tg);
+			}
 		}
 	}
 
@@ -1114,12 +1138,12 @@ static void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 		dc->res_pool->opps[i]->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;
 		pipe_ctx->stream_res.opp = dc->res_pool->opps[i];
 
-		hwss1_plane_atomic_disconnect(dc, pipe_ctx);
+		dc->hwss.plane_atomic_disconnect(dc, pipe_ctx);
 
 		if (tg->funcs->is_tg_enabled(tg))
 			tg->funcs->unlock(tg);
 
-		dcn10_disable_plane(dc, pipe_ctx);
+		dc->hwss.disable_plane(dc, pipe_ctx);
 
 		pipe_ctx->stream_res.tg = NULL;
 		pipe_ctx->plane_res.hubp = NULL;
@@ -1135,8 +1159,17 @@ static void dcn10_init_hw(struct dc *dc)
 	struct dmcu *dmcu = dc->res_pool->dmcu;
 	struct dce_hwseq *hws = dc->hwseq;
 	struct dc_bios *dcb = dc->ctx->dc_bios;
+	struct resource_pool *res_pool = dc->res_pool;
+
+	if (dc->clk_mgr && dc->clk_mgr->funcs->init_clocks)
+		dc->clk_mgr->funcs->init_clocks(dc->clk_mgr);
+
+	// Initialize the dccg
+	if (dc->res_pool->dccg && dc->res_pool->dccg->funcs->dccg_init)
+		dc->res_pool->dccg->funcs->dccg_init(res_pool->dccg);
 
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
+
 		REG_WRITE(REFCLK_CNTL, 0);
 		REG_UPDATE(DCHUBBUB_GLOBAL_TIMER_CNTL, DCHUBBUB_GLOBAL_TIMER_ENABLE, 1);
 		REG_WRITE(DIO_MEM_PWR_CTRL, 0);
@@ -1150,30 +1183,39 @@ static void dcn10_init_hw(struct dc *dc)
 			REG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);
 		}
 
-		enable_power_gating_plane(dc->hwseq, true);
+		//Enable ability to power gate / don't force power on permanently
+		dc->hwss.enable_power_gating_plane(hws, true);
 
-		/* end of FPGA. Below if real ASIC */
 		return;
 	}
 
 	if (!dcb->funcs->is_accelerated_mode(dcb)) {
-		bool allow_self_fresh_force_enable =
-			hububu1_is_allow_self_refresh_enabled(
-						dc->res_pool->hubbub);
-
-		bios_golden_init(dc);
-
-		/* WA for making DF sleep when idle after resume from S0i3.
-		 * DCHUBBUB_ARB_ALLOW_SELF_REFRESH_FORCE_ENABLE is set to 1 by
-		 * command table, if DCHUBBUB_ARB_ALLOW_SELF_REFRESH_FORCE_ENABLE = 0
-		 * before calling command table and it changed to 1 after,
-		 * it should be set back to 0.
-		 */
-		if (allow_self_fresh_force_enable == false &&
-				hububu1_is_allow_self_refresh_enabled(dc->res_pool->hubbub))
-			hubbub1_allow_self_refresh_control(dc->res_pool->hubbub, true);
-
-		disable_vga(dc->hwseq);
+		dc->hwss.bios_golden_init(dc);
+		if (dc->ctx->dc_bios->fw_info_valid) {
+			res_pool->ref_clocks.xtalin_clock_inKhz =
+					dc->ctx->dc_bios->fw_info.pll_info.crystal_frequency;
+
+			if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
+				if (res_pool->dccg && res_pool->hubbub) {
+
+					(res_pool->dccg->funcs->get_dccg_ref_freq)(res_pool->dccg,
+							dc->ctx->dc_bios->fw_info.pll_info.crystal_frequency,
+							&res_pool->ref_clocks.dccg_ref_clock_inKhz);
+
+					(res_pool->hubbub->funcs->get_dchub_ref_freq)(res_pool->hubbub,
+							res_pool->ref_clocks.dccg_ref_clock_inKhz,
+							&res_pool->ref_clocks.dchub_ref_clock_inKhz);
+				} else {
+					// Not all ASICs have DCCG sw component
+					res_pool->ref_clocks.dccg_ref_clock_inKhz =
+							res_pool->ref_clocks.xtalin_clock_inKhz;
+					res_pool->ref_clocks.dchub_ref_clock_inKhz =
+							res_pool->ref_clocks.xtalin_clock_inKhz;
+				}
+			}
+		} else
+			ASSERT_CRITICAL(false);
+		dc->hwss.disable_vga(dc->hwseq);
 	}
 
 	for (i = 0; i < dc->link_count; i++) {
@@ -1191,6 +1233,13 @@ static void dcn10_init_hw(struct dc *dc)
 			link->link_status.link_active = true;
 	}
 
+	/* Power gate DSCs */
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+	for (i = 0; i < res_pool->res_cap->num_dsc; i++)
+		if (dc->hwss.dsc_pg_control != NULL)
+			dc->hwss.dsc_pg_control(hws, res_pool->dscs[i]->inst, false);
+#endif
+
 	/* If taking control over from VBIOS, we may want to optimize our first
 	 * mode set, so we need to skip powering down pipes until we know which
 	 * pipes we want to use.
@@ -1199,10 +1248,21 @@ static void dcn10_init_hw(struct dc *dc)
 	 */
 	if (dcb->funcs->is_accelerated_mode(dcb) || dc->config.power_down_display_on_boot) {
 		dc->hwss.init_pipes(dc, dc->current_state);
+		for (i = 0; i < res_pool->pipe_count; i++) {
+			struct hubp *hubp = res_pool->hubps[i];
+			struct dpp *dpp = res_pool->dpps[i];
+
+			hubp->funcs->hubp_init(hubp);
+			res_pool->opps[i]->mpc_tree_params.opp_id = res_pool->opps[i]->inst;
+			dc->hwss.plane_atomic_power_down(dc, dpp, hubp);
+		}
+
+		apply_DEGVIDCN10_253_wa(dc);
 	}
 
-	for (i = 0; i < dc->res_pool->audio_count; i++) {
-		struct audio *audio = dc->res_pool->audios[i];
+
+	for (i = 0; i < res_pool->audio_count; i++) {
+		struct audio *audio = res_pool->audios[i];
 
 		audio->funcs->hw_init(audio);
 	}
@@ -1230,7 +1290,7 @@ static void dcn10_init_hw(struct dc *dc)
 		REG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);
 	}
 
-	enable_power_gating_plane(dc->hwseq, true);
+	dc->hwss.enable_power_gating_plane(dc->hwseq, true);
 
 	memset(&dc->clk_mgr->clks, 0, sizeof(dc->clk_mgr->clks));
 }
@@ -1789,7 +1849,7 @@ static void dcn10_enable_plane(
 	}
 }
 
-static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
+static void dcn10_program_gamut_remap(struct pipe_ctx *pipe_ctx)
 {
 	int i = 0;
 	struct dpp_grph_csc_adjustment adjust;
@@ -2220,7 +2280,7 @@ void update_dchubp_dpp(
 
 	if (plane_state->update_flags.bits.full_update) {
 		/*gamut remap*/
-		program_gamut_remap(pipe_ctx);
+		dc->hwss.program_gamut_remap(pipe_ctx);
 
 		dc->hwss.program_output_csc(dc,
 				pipe_ctx,
@@ -2457,7 +2517,7 @@ static void dcn10_apply_ctx_for_surface(
 			if (old_pipe_ctx->stream_res.tg == tg &&
 			    old_pipe_ctx->plane_res.hubp &&
 			    old_pipe_ctx->plane_res.hubp->opp_id != OPP_ID_INVALID)
-				dcn10_disable_plane(dc, old_pipe_ctx);
+				dc->hwss.disable_plane(dc, old_pipe_ctx);
 		}
 
 		if ((!pipe_ctx->plane_state ||
@@ -2505,7 +2565,7 @@ static void dcn10_apply_ctx_for_surface(
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++)
 		if (removed_pipe[i])
-			dcn10_disable_plane(dc, &dc->current_state->res_ctx.pipe_ctx[i]);
+			dc->hwss.disable_plane(dc, &dc->current_state->res_ctx.pipe_ctx[i]);
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++)
 		if (removed_pipe[i]) {
@@ -2597,7 +2657,7 @@ static void dcn10_optimize_bandwidth(
 		dcn10_verify_allow_pstate_change_high(dc);
 }
 
-static void set_drr(struct pipe_ctx **pipe_ctx,
+static void dcn10_set_drr(struct pipe_ctx **pipe_ctx,
 		int num_pipes, int vmin, int vmax)
 {
 	int i = 0;
@@ -2622,7 +2682,7 @@ static void set_drr(struct pipe_ctx **pipe_ctx,
 	}
 }
 
-static void get_position(struct pipe_ctx **pipe_ctx,
+static void dcn10_get_position(struct pipe_ctx **pipe_ctx,
 		int num_pipes,
 		struct crtc_position *position)
 {
@@ -2634,7 +2694,7 @@ static void get_position(struct pipe_ctx **pipe_ctx,
 		pipe_ctx[i]->stream_res.tg->funcs->get_position(pipe_ctx[i]->stream_res.tg, position);
 }
 
-static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
+static void dcn10_set_static_screen_control(struct pipe_ctx **pipe_ctx,
 		int num_pipes, const struct dc_static_screen_events *events)
 {
 	unsigned int i;
@@ -3125,7 +3185,7 @@ static void dcn10_get_clock(struct dc *dc,
 }
 
 static const struct hw_sequencer_funcs dcn10_funcs = {
-	.program_gamut_remap = program_gamut_remap,
+	.program_gamut_remap = dcn10_program_gamut_remap,
 	.init_hw = dcn10_init_hw,
 	.init_pipes = dcn10_init_pipes,
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
@@ -3158,18 +3218,18 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.optimize_bandwidth = dcn10_optimize_bandwidth,
 	.reset_hw_ctx_wrap = dcn10_reset_hw_ctx_wrap,
 	.enable_stream_timing = dcn10_enable_stream_timing,
-	.set_drr = set_drr,
-	.get_position = get_position,
-	.set_static_screen_control = set_static_screen_control,
+	.set_drr = dcn10_set_drr,
+	.get_position = dcn10_get_position,
+	.set_static_screen_control = dcn10_set_static_screen_control,
 	.setup_stereo = dcn10_setup_stereo,
 	.set_avmute = dce110_set_avmute,
 	.log_hw_state = dcn10_log_hw_state,
 	.get_hw_state = dcn10_get_hw_state,
 	.clear_status_bits = dcn10_clear_status_bits,
 	.wait_for_mpcc_disconnect = dcn10_wait_for_mpcc_disconnect,
-	.edp_backlight_control = hwss_edp_backlight_control,
-	.edp_power_control = hwss_edp_power_control,
-	.edp_wait_for_hpd_ready = hwss_edp_wait_for_hpd_ready,
+	.edp_backlight_control = dce110_edp_backlight_control,
+	.edp_power_control = dce110_edp_power_control,
+	.edp_wait_for_hpd_ready = dce110_edp_wait_for_hpd_ready,
 	.set_cursor_position = dcn10_set_cursor_position,
 	.set_cursor_attribute = dcn10_set_cursor_attribute,
 	.set_cursor_sdr_white_level = dcn10_set_cursor_sdr_white_level,
@@ -3179,6 +3239,16 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.setup_vupdate_interrupt = dcn10_setup_vupdate_interrupt,
 	.set_clock = dcn10_set_clock,
 	.get_clock = dcn10_get_clock,
+	.did_underflow_occur = dcn10_did_underflow_occur,
+	.init_blank = NULL,
+	.disable_vga = dcn10_disable_vga,
+	.bios_golden_init = dcn10_bios_golden_init,
+	.plane_atomic_disable = dcn10_plane_atomic_disable,
+	.plane_atomic_power_down = dcn10_plane_atomic_power_down,
+	.enable_power_gating_plane = dcn10_enable_power_gating_plane,
+	.dpp_pg_control = dcn10_dpp_pg_control,
+	.hubp_pg_control = dcn10_hubp_pg_control,
+	.dsc_pg_control = NULL,
 };
 
 

commit f7f38ffef56b0138f902efd261a6d90680fec2d3
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Mon Jul 15 10:41:47 2019 -0400

    drm/amd/display: fixup DPP programming sequence
    
    [why]
    DC does not correct account for the fact that DPP DTO is double buffered while DPP ref is not.
    This means that when DPP ref clock is lowered when it's "safe to lower", the DPP blocks that need
    an increased divider will temporarily have actual DPP clock drop below minimum while DTO
    double buffering takes effect.  This results in temporary underflow.
    
    [how]
    To fix this, DPP clock cannot be programmed atomically, but rather be broken up into the DTO and the
    ref.  Each has a separate "safe to lower" logic.  When doing "prepare" the ref and dividers may only increase.
    When doing "optimize", both may decrease.  It is guaranteed that we won't exceed max DPP clock because
    we do not use dividers larger than 1.
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 04399c541c28..51857cab1459 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2155,7 +2155,8 @@ void update_dchubp_dpp(
 			dc->res_pool->dccg->funcs->update_dpp_dto(
 					dc->res_pool->dccg,
 					dpp->inst,
-					pipe_ctx->plane_res.bw.dppclk_khz);
+					pipe_ctx->plane_res.bw.dppclk_khz,
+					false);
 		else
 			dc->clk_mgr->clks.dppclk_khz = should_divided_by_2 ?
 						dc->clk_mgr->clks.dispclk_khz / 2 :

commit 38df070135297746804bf8537ac2e8c66bb37bd5
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Wed Jul 10 18:31:38 2019 -0400

    drm/amd/display: reset drr programming on pipe reset
    
    [why]
    drr is still enabled after driver is unloaded causing black screen
    
    [how]
    disable drr during pipe reset.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e720be6be369..04399c541c28 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -823,6 +823,9 @@ static void dcn10_reset_back_end_for_pipe(
 		pipe_ctx->stream_res.tg->funcs->disable_crtc(pipe_ctx->stream_res.tg);
 
 		pipe_ctx->stream_res.tg->funcs->enable_optc_clock(pipe_ctx->stream_res.tg, false);
+		if (pipe_ctx->stream_res.tg->funcs->set_drr)
+			pipe_ctx->stream_res.tg->funcs->set_drr(
+					pipe_ctx->stream_res.tg, NULL);
 	}
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++)

commit 12e2b2d4c65f6164830e25fcd9624519a424b182
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jul 3 16:20:42 2019 -0400

    drm/amd/display: add dcc programming for dual plane
    
    Add dual plane dcc programming support for
    surfaces.
    
    Removes unions from plane size and dcc params as they
    serve no practical purpose only making our code
    more convoluted. This results in easy dual plane
    dcc and surface size programming.
    
    Temporary diags_dm code is used to handle the interface
    change without breaking functionality as a diags change
    needs to be applied after this one.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 29db9b2d4412..e720be6be369 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2132,7 +2132,7 @@ void update_dchubp_dpp(
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
-	union plane_size size = plane_state->plane_size;
+	struct plane_size size = plane_state->plane_size;
 	unsigned int compat_level = 0;
 
 	/* depends on DML calculation, DPP clock value may change dynamically */
@@ -2178,7 +2178,7 @@ void update_dchubp_dpp(
 			&pipe_ctx->ttu_regs);
 	}
 
-	size.grph.surface_size = pipe_ctx->plane_res.scl_data.viewport;
+	size.surface_size = pipe_ctx->plane_res.scl_data.viewport;
 
 	if (plane_state->update_flags.bits.full_update ||
 		plane_state->update_flags.bits.bpp_change)

commit 925f566cb7aedbcf26005035cf894ec824e8ca2f
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Thu Jun 27 18:16:21 2019 -0400

    drm/amd/display: add set and get clock for testing purposes
    
    add dc_set_clock
    add dc_get_clock
    
    this is for testing and diagnostics to get/set DPPCLK and DISPCLK.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 89c958f00e9a..29db9b2d4412 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -3069,6 +3069,56 @@ static void dcn10_send_immediate_sdp_message(struct pipe_ctx *pipe_ctx,
 				sdp_message_size);
 	}
 }
+static enum dc_status dcn10_set_clock(struct dc *dc,
+			enum dc_clock_type clock_type,
+			uint32_t clk_khz,
+			uint32_t stepping)
+{
+	struct dc_state *context = dc->current_state;
+	struct dc_clock_config clock_cfg = {0};
+	struct dc_clocks *current_clocks = &context->bw_ctx.bw.dcn.clk;
+
+	if (dc->clk_mgr && dc->clk_mgr->funcs->get_clock)
+				dc->clk_mgr->funcs->get_clock(dc->clk_mgr,
+						context, clock_type, &clock_cfg);
+
+	if (!dc->clk_mgr->funcs->get_clock)
+		return DC_FAIL_UNSUPPORTED_1;
+
+	if (clk_khz > clock_cfg.max_clock_khz)
+		return DC_FAIL_CLK_EXCEED_MAX;
+
+	if (clk_khz < clock_cfg.min_clock_khz)
+		return DC_FAIL_CLK_BELOW_MIN;
+
+	if (clk_khz < clock_cfg.bw_requirequired_clock_khz)
+		return DC_FAIL_CLK_BELOW_CFG_REQUIRED;
+
+	/*update internal request clock for update clock use*/
+	if (clock_type == DC_CLOCK_TYPE_DISPCLK)
+		current_clocks->dispclk_khz = clk_khz;
+	else if (clock_type == DC_CLOCK_TYPE_DPPCLK)
+		current_clocks->dppclk_khz = clk_khz;
+	else
+		return DC_ERROR_UNEXPECTED;
+
+	if (dc->clk_mgr && dc->clk_mgr->funcs->update_clocks)
+				dc->clk_mgr->funcs->update_clocks(dc->clk_mgr,
+				context, true);
+	return DC_OK;
+
+}
+
+static void dcn10_get_clock(struct dc *dc,
+			enum dc_clock_type clock_type,
+			struct dc_clock_config *clock_cfg)
+{
+	struct dc_state *context = dc->current_state;
+
+	if (dc->clk_mgr && dc->clk_mgr->funcs->get_clock)
+				dc->clk_mgr->funcs->get_clock(dc->clk_mgr, context, clock_type, clock_cfg);
+
+}
 
 static const struct hw_sequencer_funcs dcn10_funcs = {
 	.program_gamut_remap = program_gamut_remap,
@@ -3123,7 +3173,8 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.enable_stream_gating = NULL,
 	.setup_periodic_interrupt = dcn10_setup_periodic_interrupt,
 	.setup_vupdate_interrupt = dcn10_setup_vupdate_interrupt,
-	.did_underflow_occur = dcn10_did_underflow_occur
+	.set_clock = dcn10_set_clock,
+	.get_clock = dcn10_get_clock,
 };
 
 

commit c2cd9d04ecf0f26fb472ffbd8274a55c05df0ffb
Author: Murton Liu <murton.liu@amd.com>
Date:   Tue Jun 25 11:15:09 2019 -0400

    drm/amd/display: Hook up calls to do stereo mux and dig programming to stereo control interface
    
    [Why]
    Implementation of stereo mux register is complete, but unused. Need to
    call functions to write relevant configs.
    
    [How]
    Add function to write stereo config for enable/disable case and call in
    stereo control interface.
    
    Signed-off-by: Murton Liu <murton.liu@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 2118ea21d7e9..89c958f00e9a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2692,6 +2692,13 @@ static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct dc *dc)
 
 	dcn10_config_stereo_parameters(stream, &flags);
 
+	if (stream->timing.timing_3d_format == TIMING_3D_FORMAT_SIDEBAND_FA) {
+		if (!dc_set_generic_gpio_for_stereo(true, dc->ctx->gpio_service))
+			dc_set_generic_gpio_for_stereo(false, dc->ctx->gpio_service);
+	} else {
+		dc_set_generic_gpio_for_stereo(false, dc->ctx->gpio_service);
+	}
+
 	pipe_ctx->stream_res.opp->funcs->opp_program_stereo(
 		pipe_ctx->stream_res.opp,
 		flags.PROGRAM_STEREO == 1 ? true:false,

commit c43f89f81cc0c54c7c460f1d6365445939069c83
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Mon Jun 24 18:18:58 2019 -0400

    drm/amd/display: put back front end initialization sequence
    
    [Why]
    Seamless boot optimization removed proper front end power off sequence.
    In driver disable enable case, this causes driver to power gate hubp
    and dpp while there is still memory fetching going on, this can cause
    invalid memory requests to be generated which will hang data fabric.
    
    [How]
    Put back proper front end power off sequence
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 0c4340404e24..2118ea21d7e9 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1195,16 +1195,7 @@ static void dcn10_init_hw(struct dc *dc)
 	 * everything down.
 	 */
 	if (dcb->funcs->is_accelerated_mode(dcb) || dc->config.power_down_display_on_boot) {
-		for (i = 0; i < dc->res_pool->pipe_count; i++) {
-			struct hubp *hubp = dc->res_pool->hubps[i];
-			struct dpp *dpp = dc->res_pool->dpps[i];
-
-			hubp->funcs->hubp_init(hubp);
-			dc->res_pool->opps[i]->mpc_tree_params.opp_id = dc->res_pool->opps[i]->inst;
-			plane_atomic_power_down(dc, dpp, hubp);
-		}
-
-		apply_DEGVIDCN10_253_wa(dc);
+		dc->hwss.init_pipes(dc, dc->current_state);
 	}
 
 	for (i = 0; i < dc->res_pool->audio_count; i++) {
@@ -1375,10 +1366,6 @@ static bool dcn10_set_input_transfer_func(struct pipe_ctx *pipe_ctx,
 	return result;
 }
 
-
-
-
-
 static bool
 dcn10_set_output_transfer_func(struct pipe_ctx *pipe_ctx,
 			       const struct dc_stream_state *stream)

commit 08d238e68989b2389afb7d0cb489386ffc43e13c
Author: Murton Liu <murton.liu@amd.com>
Date:   Mon Jun 10 17:55:28 2019 -0400

    drm/amd/display: Clock does not lower in Updateplanes
    
    [why]
    We reset the optimized_required in atomic_plane_disable
    flag immediately after it is set in atomic_plane_disconnect, causing us to
    never have flag set during next flip in UpdatePlanes.
    
    [how]
    Optimize directly after each time plane is removed.
    
    Signed-off-by: Murton Liu <murton.liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e50a696fcb5d..0c4340404e24 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2516,6 +2516,12 @@ static void dcn10_apply_ctx_for_surface(
 		if (removed_pipe[i])
 			dcn10_disable_plane(dc, &dc->current_state->res_ctx.pipe_ctx[i]);
 
+	for (i = 0; i < dc->res_pool->pipe_count; i++)
+		if (removed_pipe[i]) {
+			dc->hwss.optimize_bandwidth(dc, context);
+			break;
+		}
+
 	if (dc->hwseq->wa.DEGVIDCN10_254)
 		hubbub1_wm_change_req_wa(dc->res_pool->hubbub);
 }

commit 1a7d296d162ede31d170fdb9205ce07c8cb7dfac
Author: Thomas Lim <Thomas.Lim@amd.com>
Date:   Mon Apr 29 16:05:42 2019 -0400

    drm/amd/display: Add Underflow Asserts to dc
    
    [Why]
    For debugging underflow issues it can be useful to have asserts when the
    underflow initially occurs.
    
    [How]
    Read the underflow status registers after actions that have a high risk
    of causing underflow and assert that no underflow occurred. If underflow
    occurred, clear the bit.
    
    Signed-off-by: Thomas Lim <Thomas.Lim@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d8c54f96c366..e50a696fcb5d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -421,6 +421,23 @@ void dcn10_log_hw_state(struct dc *dc,
 	DTN_INFO_END();
 }
 
+bool dcn10_did_underflow_occur(struct dc *dc, struct pipe_ctx *pipe_ctx)
+{
+	struct hubp *hubp = pipe_ctx->plane_res.hubp;
+	struct timing_generator *tg = pipe_ctx->stream_res.tg;
+
+	if (tg->funcs->is_optc_underflow_occurred(tg)) {
+		tg->funcs->clear_optc_underflow(tg);
+		return true;
+	}
+
+	if (hubp->funcs->hubp_get_underflow_status(hubp)) {
+		hubp->funcs->hubp_clear_underflow(hubp);
+		return true;
+	}
+	return false;
+}
+
 static void enable_power_gating_plane(
 	struct dce_hwseq *hws,
 	bool enable)
@@ -2398,6 +2415,7 @@ static void dcn10_apply_ctx_for_surface(
 {
 	int i;
 	struct timing_generator *tg;
+	uint32_t underflow_check_delay_us;
 	bool removed_pipe[4] = { false };
 	bool interdependent_update = false;
 	struct pipe_ctx *top_pipe_to_program =
@@ -2412,11 +2430,22 @@ static void dcn10_apply_ctx_for_surface(
 	interdependent_update = top_pipe_to_program->plane_state &&
 		top_pipe_to_program->plane_state->update_flags.bits.full_update;
 
+	underflow_check_delay_us = dc->debug.underflow_assert_delay_us;
+
+	if (underflow_check_delay_us != 0xFFFFFFFF && dc->hwss.did_underflow_occur)
+		ASSERT(dc->hwss.did_underflow_occur(dc, top_pipe_to_program));
+
 	if (interdependent_update)
 		lock_all_pipes(dc, context, true);
 	else
 		dcn10_pipe_control_lock(dc, top_pipe_to_program, true);
 
+	if (underflow_check_delay_us != 0xFFFFFFFF)
+		udelay(underflow_check_delay_us);
+
+	if (underflow_check_delay_us != 0xFFFFFFFF && dc->hwss.did_underflow_occur)
+		ASSERT(dc->hwss.did_underflow_occur(dc, top_pipe_to_program));
+
 	if (num_planes == 0) {
 		/* OTG blank before remove all front end */
 		dc->hwss.blank_pixel_data(dc, top_pipe_to_program, true);
@@ -3093,7 +3122,8 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.disable_stream_gating = NULL,
 	.enable_stream_gating = NULL,
 	.setup_periodic_interrupt = dcn10_setup_periodic_interrupt,
-	.setup_vupdate_interrupt = dcn10_setup_vupdate_interrupt
+	.setup_vupdate_interrupt = dcn10_setup_vupdate_interrupt,
+	.did_underflow_occur = dcn10_did_underflow_occur
 };
 
 

commit bda9afdacf8942c313a47cc95582737345a91c5e
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 22 18:05:41 2019 -0400

    drm/amd/display: move vmid determination logic to a module
    
    Currently vmid is decided internally inside dc. With the introduction
    of new asics we are required to coordinate vmid use with external
    components.
    
    This change converts vmid logic to a DAL module allowing vmid to be
    passed in as a parameter to DC.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 8ad499788051..d8c54f96c366 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1297,8 +1297,7 @@ static void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_c
 	pipe_ctx->plane_res.hubp->funcs->hubp_program_surface_flip_and_addr(
 			pipe_ctx->plane_res.hubp,
 			&plane_state->address,
-			plane_state->flip_immediate,
-			0);
+			plane_state->flip_immediate);
 
 	plane_state->status.requested_address = plane_state->address;
 

commit 043f5bb630c18edaaaad9c55ee60f8828e416ff4
Author: Wesley Chalmers <Wesley.Chalmers@amd.com>
Date:   Thu May 23 11:54:12 2019 -0400

    drm/amd/display: Use macro for invalid OPP ID
    
    [WHY]
    This is meant to make it clearer that 0xf is not a valid OPP ID, and
    that code making use of OPP IDs should not accept this value.
    
    Signed-off-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 9d2437fb90a6..8ad499788051 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1086,7 +1086,7 @@ static void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 		pipe_ctx->plane_res.dpp = dpp;
 		pipe_ctx->plane_res.mpcc_inst = dpp->inst;
 		hubp->mpcc_id = dpp->inst;
-		hubp->opp_id = 0xf;
+		hubp->opp_id = OPP_ID_INVALID;
 		hubp->power_gated = false;
 
 		dc->res_pool->opps[i]->mpc_tree_params.opp_id = dc->res_pool->opps[i]->inst;
@@ -2437,7 +2437,7 @@ static void dcn10_apply_ctx_for_surface(
 		if (pipe_ctx->plane_state && !old_pipe_ctx->plane_state) {
 			if (old_pipe_ctx->stream_res.tg == tg &&
 			    old_pipe_ctx->plane_res.hubp &&
-			    old_pipe_ctx->plane_res.hubp->opp_id != 0xf)
+			    old_pipe_ctx->plane_res.hubp->opp_id != OPP_ID_INVALID)
 				dcn10_disable_plane(dc, old_pipe_ctx);
 		}
 

commit 4e0cbbbfbc37fd5a8bdf653a1ebb7b271a506e2d
Author: Leo Li <sunpeng.li@amd.com>
Date:   Wed Mar 20 09:52:14 2019 -0400

    drm/amd/display: Clean up locking in dcn*_apply_ctx_for_surface()
    
    [Why]
    
    dcn*_disable_plane() doesn't unlock the pipe anymore, making the extra
    lock unnecessary.
    
    In addition - during full plane updates - all necessary pipes should be
    locked/unlocked together when modifying hubp to avoid tearing in
    pipesplit setups.
    
    [How]
    
    Remove redundant locks, and add function to lock all pipes. If an
    interdependent pipe update is required, lock down all pipes. Otherwise,
    lock only the top pipe for the updated pipe tree.
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 8a8494207971..9d2437fb90a6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2457,6 +2457,11 @@ static void dcn10_apply_ctx_for_surface(
 	if (num_planes > 0)
 		program_all_pipe_in_tree(dc, top_pipe_to_program, context);
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	/* Program secondary blending tree and writeback pipes */
+	if ((stream->num_wb_info > 0) && (dc->hwss.program_all_writeback_pipes_in_tree))
+		dc->hwss.program_all_writeback_pipes_in_tree(dc, stream, context);
+#endif
 	if (interdependent_update)
 		for (i = 0; i < dc->res_pool->pipe_count; i++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
@@ -2471,12 +2476,6 @@ static void dcn10_apply_ctx_for_surface(
 				&pipe_ctx->ttu_regs);
 		}
 
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
-	/* Program secondary blending tree and writeback pipes */
-	if ((stream->num_wb_info > 0) && (dc->hwss.program_all_writeback_pipes_in_tree))
-		dc->hwss.program_all_writeback_pipes_in_tree(dc, stream, context);
-#endif
-
 	if (interdependent_update)
 		lock_all_pipes(dc, context, false);
 	else

commit bcba830ce7cddb225fd19ecb857ce2b26ebc28b7
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Wed May 8 16:08:39 2019 -0400

    drm/amd/display: Refactor DIO stream encoder
    
    * Pull duplicate audio_clock_info struct to stream_encoder.h
    * Generalize sec_gsp7* to sec_gsp_pps*
    * Expose enc1 and enc2 stream encoder audio funcs
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 8c6d99c61f35..8a8494207971 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -377,10 +377,10 @@ void dcn10_log_hw_state(struct dc *dc,
 			DTN_INFO("[%-3d]: %-9d %-18d %-21d %-15d %-16d %-17d\n",
 				enc->id,
 				s.dsc_mode,
-				s.sec_gsp7_line_num,
+				s.sec_gsp_pps_line_num,
 				s.vbid6_line_reference,
 				s.vbid6_line_num,
-				s.sec_gsp7_enable,
+				s.sec_gsp_pps_enable,
 				s.sec_stream_enable);
 			DTN_INFO("\n");
 		}

commit 97bda0322b8a91aa8d534763e709571b2334e585
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Feb 25 13:26:34 2019 -0500

    drm/amd/display: Add DSC support for Navi (v2)
    
    Add support for DCN2 DSC (Display Stream Compression)
    
    HW Blocks:
    
     +--------++------+       +----------+
     | HUBBUB || HUBP |  <--  | MMHUBBUB |
     +--------++------+       +----------+
            |                     ^
            v                     |
        +--------+            +--------+
        |  DPP   |            |  DWB   |
        +--------+            +--------+
            |
            v                      ^
        +--------+                 |
        |  MPC   |                 |
        +--------+                 |
            |                      |
            v                      |
        +-------+      +-------+   |
        |  OPP  | <--> |  DSC  |   |
        +-------+      +-------+   |
            |                      |
            v                      |
        +--------+                /
        |  OPTC  |  --------------
        +--------+
            |
            v
        +--------+       +--------+
        |  DIO   |       |  DCCG  |
        +--------+       +--------+
    
    v2: rebase (Alex)
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index dfa235aeed89..8c6d99c61f35 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -49,6 +49,9 @@
 #include "clk_mgr.h"
 
 
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+#include "dsc.h"
+#endif
 
 #define DC_LOGGER_INIT(logger)
 
@@ -347,6 +350,61 @@ void dcn10_log_hw_state(struct dc *dc,
 	}
 	DTN_INFO("\n");
 
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+	DTN_INFO("DSC: CLOCK_EN  SLICE_WIDTH  Bytes_pp\n");
+	for (i = 0; i < pool->res_cap->num_dsc; i++) {
+		struct display_stream_compressor *dsc = pool->dscs[i];
+		struct dcn_dsc_state s = {0};
+
+		dsc->funcs->dsc_read_state(dsc, &s);
+		DTN_INFO("[%d]: %-9d %-12d %-10d\n",
+		dsc->inst,
+			s.dsc_clock_en,
+			s.dsc_slice_width,
+			s.dsc_bytes_per_pixel);
+		DTN_INFO("\n");
+	}
+	DTN_INFO("\n");
+
+	DTN_INFO("S_ENC: DSC_MODE  SEC_GSP7_LINE_NUM"
+			"  VBID6_LINE_REFERENCE  VBID6_LINE_NUM  SEC_GSP7_ENABLE  SEC_STREAM_ENABLE\n");
+	for (i = 0; i < pool->stream_enc_count; i++) {
+		struct stream_encoder *enc = pool->stream_enc[i];
+		struct enc_state s = {0};
+
+		if (enc->funcs->enc_read_state) {
+			enc->funcs->enc_read_state(enc, &s);
+			DTN_INFO("[%-3d]: %-9d %-18d %-21d %-15d %-16d %-17d\n",
+				enc->id,
+				s.dsc_mode,
+				s.sec_gsp7_line_num,
+				s.vbid6_line_reference,
+				s.vbid6_line_num,
+				s.sec_gsp7_enable,
+				s.sec_stream_enable);
+			DTN_INFO("\n");
+		}
+	}
+	DTN_INFO("\n");
+
+	DTN_INFO("L_ENC: DPHY_FEC_EN  DPHY_FEC_READY_SHADOW  DPHY_FEC_ACTIVE_STATUS\n");
+	for (i = 0; i < dc->link_count; i++) {
+		struct link_encoder *lenc = dc->links[i]->link_enc;
+
+		struct link_enc_state s = {0};
+
+		if (lenc->funcs->read_state) {
+			lenc->funcs->read_state(lenc, &s);
+			DTN_INFO("[%-3d]: %-12d %-22d %-22d\n",
+				i,
+				s.dphy_fec_en,
+				s.dphy_fec_ready_shadow,
+				s.dphy_fec_active_status);
+			DTN_INFO("\n");
+		}
+	}
+	DTN_INFO("\n");
+#endif
 
 	DTN_INFO("\nCALCULATED Clocks: dcfclk_khz:%d  dcfclk_deep_sleep_khz:%d  dispclk_khz:%d\n"
 		"dppclk_khz:%d  max_supported_dppclk_khz:%d  fclk_khz:%d  socclk_khz:%d\n\n",

commit 7ed4e6352c16fe018864bc4e626c48e27a0cefee
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Feb 22 16:52:08 2019 -0500

    drm/amd/display: Add DCN2 HW Sequencer and Resource
    
    Add DCN2 resource definition and HW Sequencer changes.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 1673d3596305..dfa235aeed89 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -49,6 +49,7 @@
 #include "clk_mgr.h"
 
 
+
 #define DC_LOGGER_INIT(logger)
 
 #define CTX \
@@ -346,6 +347,7 @@ void dcn10_log_hw_state(struct dc *dc,
 	}
 	DTN_INFO("\n");
 
+
 	DTN_INFO("\nCALCULATED Clocks: dcfclk_khz:%d  dcfclk_deep_sleep_khz:%d  dispclk_khz:%d\n"
 		"dppclk_khz:%d  max_supported_dppclk_khz:%d  fclk_khz:%d  socclk_khz:%d\n\n",
 			dc->current_state->bw_ctx.bw.dcn.clk.dcfclk_khz,
@@ -1952,7 +1954,12 @@ static void update_dpp(struct dpp *dpp, struct dc_plane_state *plane_state)
 			plane_state->format,
 			EXPANSION_MODE_ZERO,
 			plane_state->input_csc_color_matrix,
+#ifdef CONFIG_DRM_AMD_DC_DCN2_0
+			plane_state->color_space,
+			NULL);
+#else
 			plane_state->color_space);
+#endif
 
 	//set scale and bias registers
 	dcn10_build_prescale_params(&bns_params, plane_state);
@@ -2406,6 +2413,12 @@ static void dcn10_apply_ctx_for_surface(
 				&pipe_ctx->ttu_regs);
 		}
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	/* Program secondary blending tree and writeback pipes */
+	if ((stream->num_wb_info > 0) && (dc->hwss.program_all_writeback_pipes_in_tree))
+		dc->hwss.program_all_writeback_pipes_in_tree(dc, stream, context);
+#endif
+
 	if (interdependent_update)
 		lock_all_pipes(dc, context, false);
 	else

commit 1a1da391c9e24b0102205aa2fb819643b21fdd97
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Jun 17 13:08:58 2019 -0500

    Revert "drm/amd/display: Use macro for invalid OPP ID"
    
    This reverts commit 1760bd06c8e94e1b184139ae35201856403638cf.
    
    Revert this to apply the version that includes DCN2 support.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 0921858675e7..1673d3596305 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1026,7 +1026,7 @@ static void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 		pipe_ctx->plane_res.dpp = dpp;
 		pipe_ctx->plane_res.mpcc_inst = dpp->inst;
 		hubp->mpcc_id = dpp->inst;
-		hubp->opp_id = OPP_ID_INVALID;
+		hubp->opp_id = 0xf;
 		hubp->power_gated = false;
 
 		dc->res_pool->opps[i]->mpc_tree_params.opp_id = dc->res_pool->opps[i]->inst;
@@ -2372,7 +2372,7 @@ static void dcn10_apply_ctx_for_surface(
 		if (pipe_ctx->plane_state && !old_pipe_ctx->plane_state) {
 			if (old_pipe_ctx->stream_res.tg == tg &&
 			    old_pipe_ctx->plane_res.hubp &&
-			    old_pipe_ctx->plane_res.hubp->opp_id != OPP_ID_INVALID)
+			    old_pipe_ctx->plane_res.hubp->opp_id != 0xf)
 				dcn10_disable_plane(dc, old_pipe_ctx);
 		}
 

commit f94ec6f8b8857e5792328774fa47984f7d7df194
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Jun 17 13:06:37 2019 -0500

    Revert "drm/amd/display: move vmid determination logic out of dc"
    
    This reverts commit 11cd74cdb98aa6f4d6f54a0082dd28e0d4743746.
    
    Revert this to apply the version that includes DCN2 support.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 316e0da5d6bd..0921858675e7 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1237,7 +1237,8 @@ static void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_c
 	pipe_ctx->plane_res.hubp->funcs->hubp_program_surface_flip_and_addr(
 			pipe_ctx->plane_res.hubp,
 			&plane_state->address,
-			plane_state->flip_immediate);
+			plane_state->flip_immediate,
+			0);
 
 	plane_state->status.requested_address = plane_state->address;
 

commit 0198b6e5be885fd4dfe467dd6bea45416c2cd34e
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Jun 17 13:06:19 2019 -0500

    Revert "drm/amd/display: Add Underflow Asserts to dc"
    
    This reverts commit 9ed43ef84d9d1e668acdf43c95510fb7b11f8d71.
    
    Revert this to apply the version that includes DCN2 support.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 1ac9a4f03990..316e0da5d6bd 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -361,23 +361,6 @@ void dcn10_log_hw_state(struct dc *dc,
 	DTN_INFO_END();
 }
 
-bool dcn10_did_underflow_occur(struct dc *dc, struct pipe_ctx *pipe_ctx)
-{
-	struct hubp *hubp = pipe_ctx->plane_res.hubp;
-	struct timing_generator *tg = pipe_ctx->stream_res.tg;
-
-	if (tg->funcs->is_optc_underflow_occurred(tg)) {
-		tg->funcs->clear_optc_underflow(tg);
-		return true;
-	}
-
-	if (hubp->funcs->hubp_get_underflow_status(hubp)) {
-		hubp->funcs->hubp_clear_underflow(hubp);
-		return true;
-	}
-	return false;
-}
-
 static void enable_power_gating_plane(
 	struct dce_hwseq *hws,
 	bool enable)
@@ -2350,7 +2333,6 @@ static void dcn10_apply_ctx_for_surface(
 {
 	int i;
 	struct timing_generator *tg;
-	uint32_t underflow_check_delay_us;
 	bool removed_pipe[4] = { false };
 	bool interdependent_update = false;
 	struct pipe_ctx *top_pipe_to_program =
@@ -2365,22 +2347,11 @@ static void dcn10_apply_ctx_for_surface(
 	interdependent_update = top_pipe_to_program->plane_state &&
 		top_pipe_to_program->plane_state->update_flags.bits.full_update;
 
-	underflow_check_delay_us = dc->debug.underflow_assert_delay_us;
-
-	if (underflow_check_delay_us != 0xFFFFFFFF && dc->hwss.did_underflow_occur)
-		ASSERT(dc->hwss.did_underflow_occur(dc, top_pipe_to_program));
-
 	if (interdependent_update)
 		lock_all_pipes(dc, context, true);
 	else
 		dcn10_pipe_control_lock(dc, top_pipe_to_program, true);
 
-	if (underflow_check_delay_us != 0xFFFFFFFF)
-		udelay(underflow_check_delay_us);
-
-	if (underflow_check_delay_us != 0xFFFFFFFF && dc->hwss.did_underflow_occur)
-		ASSERT(dc->hwss.did_underflow_occur(dc, top_pipe_to_program));
-
 	if (num_planes == 0) {
 		/* OTG blank before remove all front end */
 		dc->hwss.blank_pixel_data(dc, top_pipe_to_program, true);
@@ -3052,8 +3023,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.disable_stream_gating = NULL,
 	.enable_stream_gating = NULL,
 	.setup_periodic_interrupt = dcn10_setup_periodic_interrupt,
-	.setup_vupdate_interrupt = dcn10_setup_vupdate_interrupt,
-	.did_underflow_occur = dcn10_did_underflow_occur
+	.setup_vupdate_interrupt = dcn10_setup_vupdate_interrupt
 };
 
 

commit 88099f53cc3717437f5fc9cf84205c5b65118377
Author: Hariprasad Kelam <hariprasad.kelam@gmail.com>
Date:   Thu Jun 13 08:02:08 2019 +0530

    drm/amd/display: fix compilation error
    
    this patch fixes below compilation error
    
    drivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_hw_sequencer.c: In
    function dcn10_apply_ctx_for_surface:
    drivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_hw_sequencer.c:2378:3:
    error: implicit declaration of function udelay
    [-Werror=implicit-function-declaration]
       udelay(underflow_check_delay_us);
    
    Signed-off-by: Hariprasad Kelam <hariprasad.kelam@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d2352949c06e..1ac9a4f03990 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -23,6 +23,7 @@
  *
  */
 
+#include <linux/delay.h>
 #include "dm_services.h"
 #include "core_types.h"
 #include "resource.h"

commit c08264876f4da8b0ee16ab1a070cb405186ef28a
Author: Wesley Chalmers <Wesley.Chalmers@amd.com>
Date:   Wed May 29 14:38:53 2019 -0400

    drm/amd/display: Use stream opp_id instead of hubp
    
    [WHY]
    By the time output csc matrix is being programmed, stream connection to
    OPP has been established, but this information has not been relayed back
    to HUBP.
    
    Signed-off-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f334756c1ce3..d2352949c06e 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2169,7 +2169,7 @@ void update_dchubp_dpp(
 				pipe_ctx,
 				pipe_ctx->stream->output_color_space,
 				pipe_ctx->stream->csc_color_matrix.matrix,
-				hubp->opp_id);
+				pipe_ctx->stream_res.opp->inst);
 	}
 
 	if (plane_state->update_flags.bits.full_update ||

commit 9ed43ef84d9d1e668acdf43c95510fb7b11f8d71
Author: Thomas Lim <Thomas.Lim@amd.com>
Date:   Mon Apr 29 16:05:42 2019 -0400

    drm/amd/display: Add Underflow Asserts to dc
    
    [Why]
    For debugging underflow issues it can be useful to have asserts when the
    underflow initially occurs.
    
    [How]
    Read the underflow status registers after actions that have a high risk
    of causing underflow and assert that no underflow occurred. If underflow
    occurred, clear the bit.
    
    Signed-off-by: Thomas Lim <Thomas.Lim@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index be245d4fe5c2..f334756c1ce3 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -360,6 +360,23 @@ void dcn10_log_hw_state(struct dc *dc,
 	DTN_INFO_END();
 }
 
+bool dcn10_did_underflow_occur(struct dc *dc, struct pipe_ctx *pipe_ctx)
+{
+	struct hubp *hubp = pipe_ctx->plane_res.hubp;
+	struct timing_generator *tg = pipe_ctx->stream_res.tg;
+
+	if (tg->funcs->is_optc_underflow_occurred(tg)) {
+		tg->funcs->clear_optc_underflow(tg);
+		return true;
+	}
+
+	if (hubp->funcs->hubp_get_underflow_status(hubp)) {
+		hubp->funcs->hubp_clear_underflow(hubp);
+		return true;
+	}
+	return false;
+}
+
 static void enable_power_gating_plane(
 	struct dce_hwseq *hws,
 	bool enable)
@@ -2332,6 +2349,7 @@ static void dcn10_apply_ctx_for_surface(
 {
 	int i;
 	struct timing_generator *tg;
+	uint32_t underflow_check_delay_us;
 	bool removed_pipe[4] = { false };
 	bool interdependent_update = false;
 	struct pipe_ctx *top_pipe_to_program =
@@ -2346,11 +2364,22 @@ static void dcn10_apply_ctx_for_surface(
 	interdependent_update = top_pipe_to_program->plane_state &&
 		top_pipe_to_program->plane_state->update_flags.bits.full_update;
 
+	underflow_check_delay_us = dc->debug.underflow_assert_delay_us;
+
+	if (underflow_check_delay_us != 0xFFFFFFFF && dc->hwss.did_underflow_occur)
+		ASSERT(dc->hwss.did_underflow_occur(dc, top_pipe_to_program));
+
 	if (interdependent_update)
 		lock_all_pipes(dc, context, true);
 	else
 		dcn10_pipe_control_lock(dc, top_pipe_to_program, true);
 
+	if (underflow_check_delay_us != 0xFFFFFFFF)
+		udelay(underflow_check_delay_us);
+
+	if (underflow_check_delay_us != 0xFFFFFFFF && dc->hwss.did_underflow_occur)
+		ASSERT(dc->hwss.did_underflow_occur(dc, top_pipe_to_program));
+
 	if (num_planes == 0) {
 		/* OTG blank before remove all front end */
 		dc->hwss.blank_pixel_data(dc, top_pipe_to_program, true);
@@ -3022,7 +3051,8 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.disable_stream_gating = NULL,
 	.enable_stream_gating = NULL,
 	.setup_periodic_interrupt = dcn10_setup_periodic_interrupt,
-	.setup_vupdate_interrupt = dcn10_setup_vupdate_interrupt
+	.setup_vupdate_interrupt = dcn10_setup_vupdate_interrupt,
+	.did_underflow_occur = dcn10_did_underflow_occur
 };
 
 

commit 11cd74cdb98aa6f4d6f54a0082dd28e0d4743746
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 22 18:05:41 2019 -0400

    drm/amd/display: move vmid determination logic out of dc
    
    Currently vmid is decided internally inside dc. This makes it
    difficult to use vmid use with external components.
    
    This change moves vmid logic outside dc and allowing vmid to be
    passed in as a parameter to DC.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d9edf7f84cfa..be245d4fe5c2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1236,8 +1236,7 @@ static void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_c
 	pipe_ctx->plane_res.hubp->funcs->hubp_program_surface_flip_and_addr(
 			pipe_ctx->plane_res.hubp,
 			&plane_state->address,
-			plane_state->flip_immediate,
-			0);
+			plane_state->flip_immediate);
 
 	plane_state->status.requested_address = plane_state->address;
 

commit 1760bd06c8e94e1b184139ae35201856403638cf
Author: Wesley Chalmers <Wesley.Chalmers@amd.com>
Date:   Thu May 23 11:54:12 2019 -0400

    drm/amd/display: Use macro for invalid OPP ID
    
    [WHY]
    This is meant to make it clearer that 0xf is not a valid OPP ID, and
    that code making use of OPP IDs should not accept this value.
    
    Signed-off-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 821a280eb481..d9edf7f84cfa 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1025,7 +1025,7 @@ static void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 		pipe_ctx->plane_res.dpp = dpp;
 		pipe_ctx->plane_res.mpcc_inst = dpp->inst;
 		hubp->mpcc_id = dpp->inst;
-		hubp->opp_id = 0xf;
+		hubp->opp_id = OPP_ID_INVALID;
 		hubp->power_gated = false;
 
 		dc->res_pool->opps[i]->mpc_tree_params.opp_id = dc->res_pool->opps[i]->inst;
@@ -2371,7 +2371,7 @@ static void dcn10_apply_ctx_for_surface(
 		if (pipe_ctx->plane_state && !old_pipe_ctx->plane_state) {
 			if (old_pipe_ctx->stream_res.tg == tg &&
 			    old_pipe_ctx->plane_res.hubp &&
-			    old_pipe_ctx->plane_res.hubp->opp_id != 0xf)
+			    old_pipe_ctx->plane_res.hubp->opp_id != OPP_ID_INVALID)
 				dcn10_disable_plane(dc, old_pipe_ctx);
 		}
 

commit 44ab1aa84ae6fa73b9a05c0c611b0e3d2ba05917
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Fri May 10 14:57:48 2019 -0400

    drm/amd/display: do not power on eDP power rail early
    
    [Why]
    Modern Standby may toggle display adapter state between D0
    and D3 state unpredictably.
    But events that cause transition to D0 are not always resulting
    in a display light up scenario.
    
    Modern eDP panels should be able to power on panel logic
    quickly upon VDD going high. Based on spec, the T3 time
    between VDD on and HPD high can be between 0 and 80 ms.
    
    Doing any tricky sorts of optimization by powering on panel
    VDD early during D0 transition on can negatively impact other
    features due to unnecessary power drain and toggling when
    final system state does not intend for the panel to be lit up.
    
    We need OEMs to source higher end panels that have T3 time
    close to 0 if they want quick S3/Modern Standby resume times.
    
    [How]
    Remove panel VDD power on in init_hw
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c2207df62661..821a280eb481 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1102,9 +1102,6 @@ static void dcn10_init_hw(struct dc *dc)
 		 */
 		struct dc_link *link = dc->links[i];
 
-		if (link->link_enc->connector.id == CONNECTOR_ID_EDP)
-			dc->hwss.edp_power_control(link, true);
-
 		link->link_enc->funcs->hw_init(link->link_enc);
 
 		/* Check for enabled DIG to identify enabled display */

commit 70d9e8cb8b4439dcfd42bee08831ffb1c02a4805
Author: Paul Hsieh <paul.hsieh@amd.com>
Date:   Tue May 7 17:58:58 2019 +0800

    drm/amd/display: disable PSR/ABM before destroy DMCU struct
    
    [Why]
    1. DMCU is not running on some platform but driver still send ABM
       command. It may cause assert due to DMCU is not alive.
    2. To make sure PSR disable when driver disable
    
    [How]
    1. Add dmcu_is_running in ABM struct, driver can check this flag to
       determine driver should send ABM command or not.
    2. Send PSR disable command when destroy PSR
    
    Signed-off-by: Paul Hsieh <paul.hsieh@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index b5ca1764e2a2..c2207df62661 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1146,6 +1146,9 @@ static void dcn10_init_hw(struct dc *dc)
 	if (dmcu != NULL)
 		dmcu->funcs->dmcu_init(dmcu);
 
+	if (abm != NULL && dmcu != NULL)
+		abm->dmcu_is_running = dmcu->funcs->is_dmcu_initialized(dmcu);
+
 	/* power AFMT HDMI memory TODO: may move to dis/en output save power*/
 	REG_WRITE(DIO_MEM_PWR_CTRL, 0);
 

commit e63e2491ad92036e844230b6373ae07923552f6c
Author: Eryk Brol <eryk.brol@amd.com>
Date:   Tue Apr 23 11:53:52 2019 -0400

    drm/amd/display: Ensure DRR triggers in BP
    
    [Why]
    In the previous implementation DRR event sometimes came
    in during FP2 region which is a keep-out zone. This
    would cause the frame not to latch until the next frame
    which resulted in heavy flicker. To fix this we need
    to make sure that it triggers in the BP.
    
    [How]
    1. Remove DRR programming during flip
    2. Setup manual trigger for DRR event and trigger it
    after surface programming is complete
    
    Signed-off-by: Eryk Brol <eryk.brol@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7ee3c60cdc18..b5ca1764e2a2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2506,8 +2506,8 @@ static void set_drr(struct pipe_ctx **pipe_ctx,
 {
 	int i = 0;
 	struct drr_params params = {0};
-	// DRR should set trigger event to monitor surface update event
-	unsigned int event_triggers = 0x80;
+	// DRR set trigger event mapped to OTG_TRIG_A (bit 11) for manual control flow
+	unsigned int event_triggers = 0x800;
 
 	params.vertical_total_max = vmax;
 	params.vertical_total_min = vmin;

commit dc88b4a684d284a200c0ecfd8d87179d6f6c89a3
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Mon Apr 22 19:39:35 2019 -0400

    drm/amd/display: make clk mgr soc specific
    
    [Why]
    First step of refactoring clk mgr to better handle different
    ways of handling clock operations. Clock operation policies are
    soc specific and not just DCN vesion specific. It is not a hw resource,
    should not be in the resource pool.
    
    [How]
    Change clock manager creation to be based on HW internal ID, rename
    clock manager members to be more clear. Move clock manager out of
    resource.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 66bb0e7db25c..7ee3c60cdc18 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -45,6 +45,8 @@
 #include "dcn10_cm_common.h"
 #include "dc_link_dp.h"
 #include "dccg.h"
+#include "clk_mgr.h"
+
 
 #define DC_LOGGER_INIT(logger)
 
@@ -1158,7 +1160,7 @@ static void dcn10_init_hw(struct dc *dc)
 
 	enable_power_gating_plane(dc->hwseq, true);
 
-	memset(&dc->res_pool->clk_mgr->clks, 0, sizeof(dc->res_pool->clk_mgr->clks));
+	memset(&dc->clk_mgr->clks, 0, sizeof(dc->clk_mgr->clks));
 }
 
 static void dcn10_reset_hw_ctx_wrap(
@@ -2070,7 +2072,7 @@ void update_dchubp_dpp(
 	 */
 	if (plane_state->update_flags.bits.full_update) {
 		bool should_divided_by_2 = context->bw_ctx.bw.dcn.clk.dppclk_khz <=
-				dc->res_pool->clk_mgr->clks.dispclk_khz / 2;
+				dc->clk_mgr->clks.dispclk_khz / 2;
 
 		dpp->funcs->dpp_dppclk_control(
 				dpp,
@@ -2083,9 +2085,9 @@ void update_dchubp_dpp(
 					dpp->inst,
 					pipe_ctx->plane_res.bw.dppclk_khz);
 		else
-			dc->res_pool->clk_mgr->clks.dppclk_khz = should_divided_by_2 ?
-						dc->res_pool->clk_mgr->clks.dispclk_khz / 2 :
-							dc->res_pool->clk_mgr->clks.dispclk_khz;
+			dc->clk_mgr->clks.dppclk_khz = should_divided_by_2 ?
+						dc->clk_mgr->clks.dispclk_khz / 2 :
+							dc->clk_mgr->clks.dispclk_khz;
 	}
 
 	/* TODO: Need input parameter to tell current DCHUB pipe tie to which OTG
@@ -2448,8 +2450,8 @@ static void dcn10_prepare_bandwidth(
 		if (context->stream_count == 0)
 			context->bw_ctx.bw.dcn.clk.phyclk_khz = 0;
 
-		dc->res_pool->clk_mgr->funcs->update_clocks(
-				dc->res_pool->clk_mgr,
+		dc->clk_mgr->funcs->update_clocks(
+				dc->clk_mgr,
 				context,
 				false);
 	}
@@ -2480,8 +2482,8 @@ static void dcn10_optimize_bandwidth(
 		if (context->stream_count == 0)
 			context->bw_ctx.bw.dcn.clk.phyclk_khz = 0;
 
-		dc->res_pool->clk_mgr->funcs->update_clocks(
-				dc->res_pool->clk_mgr,
+		dc->clk_mgr->funcs->update_clocks(
+				dc->clk_mgr,
 				context,
 				true);
 	}

commit 6476a7c8f03156883bb52605fb84a8ec0147849f
Author: Joshua Aberback <joshua.aberback@amd.com>
Date:   Mon Apr 29 17:21:19 2019 -0400

    drm/amd/display: Program VTG params after programming Global Sync
    
    [Why]
    VTG has a parameter FP2, which is defined as:
        if VSTARTUP is before VSYNC:
            FP2 = number of lines in between VSTARTUP and VSYNC
        else
            FP2 = 0
    Currently, FP2 is only programmed during "program_timing". However, the
    position of VSTARTUP is affected by the prefetching requirements on all pipes,
    so the position might change when we do memory request control on another pipe, so we need
    to make sure that FP2 stays up-to-date whenever we adjust VSTARTUP.
    
    [How]
     - refactor VTG_CONTROL programming into a new function "set_vtg_params"
     - call it after calling "program_global_sync"
       - make sure it's called after because it relies on the cached dlg params
    
    Signed-off-by: Joshua Aberback <joshua.aberback@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Jun Lei <Jun.Lei@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index bf0db874d99f..66bb0e7db25c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2285,6 +2285,9 @@ static void program_all_pipe_in_tree(
 				pipe_ctx->pipe_dlg_param.vupdate_offset,
 				pipe_ctx->pipe_dlg_param.vupdate_width);
 
+		pipe_ctx->stream_res.tg->funcs->set_vtg_params(
+				pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing);
+
 		dc->hwss.blank_pixel_data(dc, pipe_ctx, blank);
 
 	}

commit 24c18794946ad127334138669b2aa204b2e60763
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Apr 8 14:56:29 2019 -0400

    drm/amd/display: add null checks and set update flags
    
    * add plane state null checks
    * add and set update surface flags
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c2b60b1e1a25..bf0db874d99f 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1755,7 +1755,7 @@ static void dcn10_program_output_csc(struct dc *dc,
 
 bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->plane_state->visible)
+	if (pipe_ctx->plane_state && pipe_ctx->plane_state->visible)
 		return true;
 	if (pipe_ctx->bottom_pipe && is_lower_pipe_tree_visible(pipe_ctx->bottom_pipe))
 		return true;
@@ -1764,7 +1764,7 @@ bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 
 bool is_upper_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->plane_state->visible)
+	if (pipe_ctx->plane_state && pipe_ctx->plane_state->visible)
 		return true;
 	if (pipe_ctx->top_pipe && is_upper_pipe_tree_visible(pipe_ctx->top_pipe))
 		return true;
@@ -1773,7 +1773,7 @@ bool is_upper_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 
 bool is_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->plane_state->visible)
+	if (pipe_ctx->plane_state && pipe_ctx->plane_state->visible)
 		return true;
 	if (pipe_ctx->top_pipe && is_upper_pipe_tree_visible(pipe_ctx->top_pipe))
 		return true;
@@ -1919,7 +1919,7 @@ static uint16_t fixed_point_to_int_frac(
 	return result;
 }
 
-void build_prescale_params(struct  dc_bias_and_scale *bias_and_scale,
+void dcn10_build_prescale_params(struct  dc_bias_and_scale *bias_and_scale,
 		const struct dc_plane_state *plane_state)
 {
 	if (plane_state->format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN
@@ -1952,7 +1952,7 @@ static void update_dpp(struct dpp *dpp, struct dc_plane_state *plane_state)
 			plane_state->color_space);
 
 	//set scale and bias registers
-	build_prescale_params(&bns_params, plane_state);
+	dcn10_build_prescale_params(&bns_params, plane_state);
 	if (dpp->funcs->dpp_program_bias_and_scale)
 		dpp->funcs->dpp_program_bias_and_scale(dpp, &bns_params);
 }
@@ -2641,9 +2641,6 @@ static void dcn10_wait_for_mpcc_disconnect(
 			res_pool->mpc->funcs->wait_for_idle(res_pool->mpc, mpcc_inst);
 			pipe_ctx->stream_res.opp->mpcc_disconnect_pending[mpcc_inst] = false;
 			hubp->funcs->set_blank(hubp, true);
-			/*DC_LOG_ERROR(dc->ctx->logger,
-					"[debug_mpo: wait_for_mpcc finished waiting on mpcc %d]\n",
-					i);*/
 		}
 	}
 

commit 88ccdf1d59df4d93b0591c8879316de40ef88f93
Author: Leo (Hanghong) Ma <hanghong.ma@amd.com>
Date:   Tue Apr 16 11:07:22 2019 -0400

    drm/amd/display: Expose send immediate sdp message interface
    
    [Why]
    To send sdp message immediately from a single slot.
    
    [How]
    Modify the generic SDP message interface, and use GSP4 to send immediate
    sdp message.
    
    Signed-off-by: Leo (Hanghong) Ma <hanghong.ma@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 723b2ddf9aa5..c2b60b1e1a25 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2957,6 +2957,18 @@ static void dcn10_unblank_stream(struct pipe_ctx *pipe_ctx,
 	}
 }
 
+static void dcn10_send_immediate_sdp_message(struct pipe_ctx *pipe_ctx,
+				const uint8_t *custom_sdp_message,
+				unsigned int sdp_message_size)
+{
+	if (dc_is_dp_signal(pipe_ctx->stream->signal)) {
+		pipe_ctx->stream_res.stream_enc->funcs->send_immediate_sdp_message(
+				pipe_ctx->stream_res.stream_enc,
+				custom_sdp_message,
+				sdp_message_size);
+	}
+}
+
 static const struct hw_sequencer_funcs dcn10_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.init_hw = dcn10_init_hw,
@@ -2976,6 +2988,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.enable_timing_synchronization = dcn10_enable_timing_synchronization,
 	.enable_per_frame_crtc_position_reset = dcn10_enable_per_frame_crtc_position_reset,
 	.update_info_frame = dce110_update_info_frame,
+	.send_immediate_sdp_message = dcn10_send_immediate_sdp_message,
 	.enable_stream = dce110_enable_stream,
 	.disable_stream = dce110_disable_stream,
 	.unblank_stream = dcn10_unblank_stream,

commit e7e10c464a481e9e94ae571f849d09c8820f1fdb
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Apr 8 15:49:52 2019 -0400

    drm/amd/display: stop external access to internal optc sync params
    
    These are internal otg params and should be handled as such.
    Thich change passes the params as function arguments.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c67942ae1920..723b2ddf9aa5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -658,16 +658,15 @@ static enum dc_status dcn10_enable_stream_timing(
 		BREAK_TO_DEBUGGER();
 		return DC_ERROR_UNEXPECTED;
 	}
-	pipe_ctx->stream_res.tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
-	pipe_ctx->stream_res.tg->dlg_otg_param.vstartup_start = pipe_ctx->pipe_dlg_param.vstartup_start;
-	pipe_ctx->stream_res.tg->dlg_otg_param.vupdate_offset = pipe_ctx->pipe_dlg_param.vupdate_offset;
-	pipe_ctx->stream_res.tg->dlg_otg_param.vupdate_width = pipe_ctx->pipe_dlg_param.vupdate_width;
-
-	pipe_ctx->stream_res.tg->signal =  pipe_ctx->stream->signal;
 
 	pipe_ctx->stream_res.tg->funcs->program_timing(
 			pipe_ctx->stream_res.tg,
 			&stream->timing,
+			pipe_ctx->pipe_dlg_param.vready_offset,
+			pipe_ctx->pipe_dlg_param.vstartup_start,
+			pipe_ctx->pipe_dlg_param.vupdate_offset,
+			pipe_ctx->pipe_dlg_param.vupdate_width,
+			pipe_ctx->stream->signal,
 			true);
 
 #if 0 /* move to after enable_crtc */
@@ -2279,13 +2278,12 @@ static void program_all_pipe_in_tree(
 	if (pipe_ctx->top_pipe == NULL) {
 		bool blank = !is_pipe_tree_visible(pipe_ctx);
 
-		pipe_ctx->stream_res.tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
-		pipe_ctx->stream_res.tg->dlg_otg_param.vstartup_start = pipe_ctx->pipe_dlg_param.vstartup_start;
-		pipe_ctx->stream_res.tg->dlg_otg_param.vupdate_offset = pipe_ctx->pipe_dlg_param.vupdate_offset;
-		pipe_ctx->stream_res.tg->dlg_otg_param.vupdate_width = pipe_ctx->pipe_dlg_param.vupdate_width;
-
 		pipe_ctx->stream_res.tg->funcs->program_global_sync(
-				pipe_ctx->stream_res.tg);
+				pipe_ctx->stream_res.tg,
+				pipe_ctx->pipe_dlg_param.vready_offset,
+				pipe_ctx->pipe_dlg_param.vstartup_start,
+				pipe_ctx->pipe_dlg_param.vupdate_offset,
+				pipe_ctx->pipe_dlg_param.vupdate_width);
 
 		dc->hwss.blank_pixel_data(dc, pipe_ctx, blank);
 
@@ -2789,7 +2787,6 @@ static void apply_front_porch_workaround(
 
 int get_vupdate_offset_from_vsync(struct pipe_ctx *pipe_ctx)
 {
-	struct timing_generator *optc = pipe_ctx->stream_res.tg;
 	const struct dc_crtc_timing *dc_crtc_timing = &pipe_ctx->stream->timing;
 	struct dc_crtc_timing patched_crtc_timing;
 	int vesa_sync_start;
@@ -2812,7 +2809,7 @@ int get_vupdate_offset_from_vsync(struct pipe_ctx *pipe_ctx)
 			* interlace_factor;
 
 	vertical_line_start = asic_blank_end -
-			optc->dlg_otg_param.vstartup_start + 1;
+			pipe_ctx->pipe_dlg_param.vstartup_start + 1;
 
 	return vertical_line_start;
 }

commit db819940b0ef74afdc46a48304d0b29410ed7fc4
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Apr 8 15:04:43 2019 -0400

    drm/amd/display: move signal type out of otg dlg params
    
    It makes no logical sense being there
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 33d311cea28c..c67942ae1920 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -663,7 +663,7 @@ static enum dc_status dcn10_enable_stream_timing(
 	pipe_ctx->stream_res.tg->dlg_otg_param.vupdate_offset = pipe_ctx->pipe_dlg_param.vupdate_offset;
 	pipe_ctx->stream_res.tg->dlg_otg_param.vupdate_width = pipe_ctx->pipe_dlg_param.vupdate_width;
 
-	pipe_ctx->stream_res.tg->dlg_otg_param.signal =  pipe_ctx->stream->signal;
+	pipe_ctx->stream_res.tg->signal =  pipe_ctx->stream->signal;
 
 	pipe_ctx->stream_res.tg->funcs->program_timing(
 			pipe_ctx->stream_res.tg,
@@ -2283,7 +2283,6 @@ static void program_all_pipe_in_tree(
 		pipe_ctx->stream_res.tg->dlg_otg_param.vstartup_start = pipe_ctx->pipe_dlg_param.vstartup_start;
 		pipe_ctx->stream_res.tg->dlg_otg_param.vupdate_offset = pipe_ctx->pipe_dlg_param.vupdate_offset;
 		pipe_ctx->stream_res.tg->dlg_otg_param.vupdate_width = pipe_ctx->pipe_dlg_param.vupdate_width;
-		pipe_ctx->stream_res.tg->dlg_otg_param.signal =  pipe_ctx->stream->signal;
 
 		pipe_ctx->stream_res.tg->funcs->program_global_sync(
 				pipe_ctx->stream_res.tg);

commit cc8d84132a833cc3be469c5d363da769bc69875e
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Apr 10 21:43:23 2019 -0400

    drm/amd/display: Add hubp_init entry to hubp vtable
    
    Different HW will need to init HUBP differently. For now, add a vtable
    entry, and hook a NO-OP for DCN1.
    
    In addition, future HW will need to access the HUBPREQ_DEBUG register
    for hubp_init. Add it to the reg list.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7e173c74907c..33d311cea28c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1123,6 +1123,7 @@ static void dcn10_init_hw(struct dc *dc)
 			struct hubp *hubp = dc->res_pool->hubps[i];
 			struct dpp *dpp = dc->res_pool->dpps[i];
 
+			hubp->funcs->hubp_init(hubp);
 			dc->res_pool->opps[i]->mpc_tree_params.opp_id = dc->res_pool->opps[i]->inst;
 			plane_atomic_power_down(dc, dpp, hubp);
 		}

commit 27eaa4927dc3be669ed70670241597ac73595caf
Author: Thomas Lim <Thomas.Lim@amd.com>
Date:   Wed Apr 10 17:06:07 2019 -0400

    drm/amd/display: Add power down display on boot flag
    
    [Why]
    
    Due to the generic introduction of seamless boot, the display is no
    longer blanked upon boot. However, this causes corruption on some
    systems that does not lock the memory in the non-secure boot case,
    resulting in brief corruption on boot due to garbage being written into
    the frame buffer.
    
    [How]
    Add a flag, read during DC init, to determine whether display should be
    blanked on boot. Default to true.
    
    Signed-off-by: Thomas Lim <Thomas.Lim@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 549836c60220..7e173c74907c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1118,7 +1118,7 @@ static void dcn10_init_hw(struct dc *dc)
 	 * Otherwise, if taking control is not possible, we need to power
 	 * everything down.
 	 */
-	if (dcb->funcs->is_accelerated_mode(dcb)) {
+	if (dcb->funcs->is_accelerated_mode(dcb) || dc->config.power_down_display_on_boot) {
 		for (i = 0; i < dc->res_pool->pipe_count; i++) {
 			struct hubp *hubp = dc->res_pool->hubps[i];
 			struct dpp *dpp = dc->res_pool->dpps[i];

commit 91f287566d494a4b28135f51e4698593feedc886
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Mar 29 14:36:57 2019 -0400

    drm/amd/display: Refactor watermark programming
    
    * Replace certain register writes with register sets that overwrites the
      the entire register, instead of only a field within the register.
    * Add program_watermarks() entry to hubbub vtable. Hook it up to
      existing functions that program watermarks.
    * Add additional watermark registers.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f0cc7c9c9de3..549836c60220 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2438,6 +2438,8 @@ static void dcn10_prepare_bandwidth(
 		struct dc *dc,
 		struct dc_state *context)
 {
+	struct hubbub *hubbub = dc->res_pool->hubbub;
+
 	if (dc->debug.sanity_checks)
 		dcn10_verify_allow_pstate_change_high(dc);
 
@@ -2451,7 +2453,7 @@ static void dcn10_prepare_bandwidth(
 				false);
 	}
 
-	hubbub1_program_watermarks(dc->res_pool->hubbub,
+	hubbub->funcs->program_watermarks(hubbub,
 			&context->bw_ctx.bw.dcn.watermarks,
 			dc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000,
 			true);
@@ -2468,6 +2470,8 @@ static void dcn10_optimize_bandwidth(
 		struct dc *dc,
 		struct dc_state *context)
 {
+	struct hubbub *hubbub = dc->res_pool->hubbub;
+
 	if (dc->debug.sanity_checks)
 		dcn10_verify_allow_pstate_change_high(dc);
 
@@ -2481,7 +2485,7 @@ static void dcn10_optimize_bandwidth(
 				true);
 	}
 
-	hubbub1_program_watermarks(dc->res_pool->hubbub,
+	hubbub->funcs->program_watermarks(hubbub,
 			&context->bw_ctx.bw.dcn.watermarks,
 			dc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000,
 			true);

commit 41629f02c604546e24a911413b99cd9d80e842db
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Wed Apr 3 16:59:56 2019 -0400

    drm/amd/display: Allow system to enter stutter on init
    
    [Why]
    Workaround was missing in one HW disable path,
    meaning when all pipes are power gated, stutter was
    not working
    
    [How]
    Add workaround for init_hw path for stutter
    workaround
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index dab370676bfa..f0cc7c9c9de3 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1126,6 +1126,8 @@ static void dcn10_init_hw(struct dc *dc)
 			dc->res_pool->opps[i]->mpc_tree_params.opp_id = dc->res_pool->opps[i]->inst;
 			plane_atomic_power_down(dc, dpp, hubp);
 		}
+
+		apply_DEGVIDCN10_253_wa(dc);
 	}
 
 	for (i = 0; i < dc->res_pool->audio_count; i++) {

commit c7e557ab46a7395fd28936c24e12e06f1841279c
Author: Leo Li <sunpeng.li@amd.com>
Date:   Wed Mar 20 09:52:14 2019 -0400

    drm/amd/display: Clean up locking in dcn*_apply_ctx_for_surface()
    
    [Why]
    
    dcn*_disable_plane() doesn't unlock the pipe anymore, making the extra
    lock unnecessary.
    
    In addition - during full plane updates - all necessary pipes should be
    locked/unlocked together when modifying hubp to avoid tearing in
    pipesplit setups.
    
    [How]
    
    Remove redundant locks, and add function to lock all pipes. If an
    interdependent pipe update is required, lock down all pipes. Otherwise,
    lock only the top pipe for the updated pipe tree.
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c2b93a851dc6..dab370676bfa 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2329,6 +2329,7 @@ static void dcn10_apply_ctx_for_surface(
 	int i;
 	struct timing_generator *tg;
 	bool removed_pipe[4] = { false };
+	bool interdependent_update = false;
 	struct pipe_ctx *top_pipe_to_program =
 			find_top_pipe_for_stream(dc, context, stream);
 	DC_LOGGER_INIT(dc->ctx->logger);
@@ -2338,7 +2339,13 @@ static void dcn10_apply_ctx_for_surface(
 
 	tg = top_pipe_to_program->stream_res.tg;
 
-	dcn10_pipe_control_lock(dc, top_pipe_to_program, true);
+	interdependent_update = top_pipe_to_program->plane_state &&
+		top_pipe_to_program->plane_state->update_flags.bits.full_update;
+
+	if (interdependent_update)
+		lock_all_pipes(dc, context, true);
+	else
+		dcn10_pipe_control_lock(dc, top_pipe_to_program, true);
 
 	if (num_planes == 0) {
 		/* OTG blank before remove all front end */
@@ -2358,15 +2365,9 @@ static void dcn10_apply_ctx_for_surface(
 		 */
 		if (pipe_ctx->plane_state && !old_pipe_ctx->plane_state) {
 			if (old_pipe_ctx->stream_res.tg == tg &&
-				old_pipe_ctx->plane_res.hubp &&
-				old_pipe_ctx->plane_res.hubp->opp_id != 0xf) {
+			    old_pipe_ctx->plane_res.hubp &&
+			    old_pipe_ctx->plane_res.hubp->opp_id != 0xf)
 				dcn10_disable_plane(dc, old_pipe_ctx);
-				/*
-				 * power down fe will unlock when calling reset, need
-				 * to lock it back here. Messy, need rework.
-				 */
-				pipe_ctx->stream_res.tg->funcs->lock(pipe_ctx->stream_res.tg);
-			}
 		}
 
 		if ((!pipe_ctx->plane_state ||
@@ -2385,29 +2386,25 @@ static void dcn10_apply_ctx_for_surface(
 	if (num_planes > 0)
 		program_all_pipe_in_tree(dc, top_pipe_to_program, context);
 
-	dcn10_pipe_control_lock(dc, top_pipe_to_program, false);
-
-	if (top_pipe_to_program->plane_state &&
-			top_pipe_to_program->plane_state->update_flags.bits.full_update)
+	if (interdependent_update)
 		for (i = 0; i < dc->res_pool->pipe_count; i++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-			tg = pipe_ctx->stream_res.tg;
 			/* Skip inactive pipes and ones already updated */
-			if (!pipe_ctx->stream || pipe_ctx->stream == stream
-					|| !pipe_ctx->plane_state
-					|| !tg->funcs->is_tg_enabled(tg))
+			if (!pipe_ctx->stream || pipe_ctx->stream == stream ||
+			    !pipe_ctx->plane_state || !tg->funcs->is_tg_enabled(tg))
 				continue;
 
-			tg->funcs->lock(tg);
-
 			pipe_ctx->plane_res.hubp->funcs->hubp_setup_interdependent(
 				pipe_ctx->plane_res.hubp,
 				&pipe_ctx->dlg_regs,
 				&pipe_ctx->ttu_regs);
-
-			tg->funcs->unlock(tg);
 		}
 
+	if (interdependent_update)
+		lock_all_pipes(dc, context, false);
+	else
+		dcn10_pipe_control_lock(dc, top_pipe_to_program, false);
+
 	if (num_planes == 0)
 		false_optc_underflow_wa(dc, stream, tg);
 
@@ -2814,6 +2811,33 @@ int get_vupdate_offset_from_vsync(struct pipe_ctx *pipe_ctx)
 	return vertical_line_start;
 }
 
+void lock_all_pipes(struct dc *dc,
+	struct dc_state *context,
+	bool lock)
+{
+	struct pipe_ctx *pipe_ctx;
+	struct timing_generator *tg;
+	int i;
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		pipe_ctx = &context->res_ctx.pipe_ctx[i];
+		tg = pipe_ctx->stream_res.tg;
+		/*
+		 * Only lock the top pipe's tg to prevent redundant
+		 * (un)locking. Also skip if pipe is disabled.
+		 */
+		if (pipe_ctx->top_pipe ||
+		    !pipe_ctx->stream || !pipe_ctx->plane_state ||
+		    !tg->funcs->is_tg_enabled(tg))
+			continue;
+
+		if (lock)
+			tg->funcs->lock(tg);
+		else
+			tg->funcs->unlock(tg);
+	}
+}
+
 static void calc_vupdate_position(
 		struct pipe_ctx *pipe_ctx,
 		uint32_t *start_line,

commit fbd06ec492fc6e078a62664c5b4a0d74b90285be
Author: Murton Liu <murton.liu@amd.com>
Date:   Mon Mar 25 14:51:28 2019 -0400

    drm/amd/display: HDR visual confirmation incorrectly reports black color
    
    [Why]
    Checking against a TF that is unused causes us to default to black
    
    [How]
    Check against PQ instead
    
    Signed-off-by: Murton Liu <murton.liu@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f6591488ef9b..c2b93a851dc6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1852,7 +1852,7 @@ void dcn10_get_hdr_visual_confirm_color(
 
 	switch (top_pipe_ctx->plane_res.scl_data.format) {
 	case PIXEL_FORMAT_ARGB2101010:
-		if (top_pipe_ctx->stream->out_transfer_func->tf == TRANSFER_FUNCTION_UNITY) {
+		if (top_pipe_ctx->stream->out_transfer_func->tf == TRANSFER_FUNCTION_PQ) {
 			/* HDR10, ARGB2101010 - set boarder color to red */
 			color->color_r_cr = color_value;
 		}

commit d5ca5fdbeb76ef78af9a8291846d2c9f08ae414b
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Mon Mar 25 16:11:43 2019 -0400

    drm/amd/display: fix underflow on boot
    
    [Why]
    New seamless boot sequence introduced a bug where front end is disabled
    without blanking otg.
    
    [How]
    Adjust the condition of blanking otg to match seamless boot.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index afa8648d88e1..f6591488ef9b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -979,16 +979,14 @@ static void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 		 * to non-preferred front end. If pipe_ctx->stream is not NULL,
 		 * we will use the pipe, so don't disable
 		 */
-		if (pipe_ctx->stream != NULL)
+		if (pipe_ctx->stream != NULL && can_apply_seamless_boot)
 			continue;
 
-		if (tg->funcs->is_tg_enabled(tg))
-			tg->funcs->lock(tg);
-
 		/* Blank controller using driver code instead of
 		 * command table.
 		 */
 		if (tg->funcs->is_tg_enabled(tg)) {
+			tg->funcs->lock(tg);
 			tg->funcs->set_blank(tg, true);
 			hwss_wait_for_blank_complete(tg);
 		}

commit 86eb426a0f30ef538109a7b44f86051586390125
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Mon Mar 25 14:04:30 2019 -0400

    drm/amd/display: Call hwss.set_cursor_sdr_white_level, if available
    
    [Why]
    In HDR configurations, the cursor - in SDR - needs to have it's white
    level boosted.
    
    [How]
    Program the cursor boost in update_dchubp_dpp like the other cursor
    attributes.
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Reza Amini <Reza.Amini@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 976812ae4ede..afa8648d88e1 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2138,6 +2138,9 @@ void update_dchubp_dpp(
 	if (pipe_ctx->stream->cursor_attributes.address.quad_part != 0) {
 		dc->hwss.set_cursor_position(pipe_ctx);
 		dc->hwss.set_cursor_attribute(pipe_ctx);
+
+		if (dc->hwss.set_cursor_sdr_white_level)
+			dc->hwss.set_cursor_sdr_white_level(pipe_ctx);
 	}
 
 	if (plane_state->update_flags.bits.full_update) {

commit a1e07ba89d49581471d64c48152dbe03b42bd025
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Thu Mar 14 13:46:44 2019 -0400

    drm/amd/display: Use plane->color_space for dpp if specified
    
    [Why]
    The input color space for the plane was previously ignored even if it
    was set.
    
    If a limited range YUV format was given to DC then the
    wrong color transformation matrix was being used since DC assumed that
    it was full range instead.
    
    [How]
    Respect the given color_space format for the plane if it isn't
    COLOR_SPACE_UNKNOWN. Otherwise, use the implicit default since DM
    didn't specify.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Sun peng Li <Sunpeng.Li@amd.com>
    Acked-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 4969fa5e6f1d..976812ae4ede 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1949,7 +1949,7 @@ static void update_dpp(struct dpp *dpp, struct dc_plane_state *plane_state)
 			plane_state->format,
 			EXPANSION_MODE_ZERO,
 			plane_state->input_csc_color_matrix,
-			COLOR_SPACE_YCBCR601_LIMITED);
+			plane_state->color_space);
 
 	//set scale and bias registers
 	build_prescale_params(&bns_params, plane_state);

commit 6752bea8b03e77c98be7d8d25b0a9d86a00b3cf7
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Mon Mar 11 10:33:35 2019 -0400

    drm/amd/display: Prevent cursor hotspot overflow for RV overlay planes
    
    [Why]
    The actual position for the cursor on the screen is essentially:
    
    x_out = x - x_plane - x_hotspot
    y_out = y - y_plane - y_hotspot
    
    The register values for cursor position and cursor hotspot need to be
    greater than zero when programmed, but we also need to subtract off
    the plane position to display the cursor at the correct position.
    
    Since we don't want x or y to be less than zero, we add the plane
    position as a positive value to x_hotspot or y_hotspot. However, what
    this doesn't take into account is that the hotspot registers are limited
    by the maximum cursor size.
    
    On DCN10 the cursor hotspot regitsers are masked to 0xFF, so they have
    a maximum value of 0-255. Values greater this will wrap, causing the
    cursor to display in the wrong position.
    
    In practice this means that for sufficiently large plane positions, the
    cursor will be drawn twice on the screen, and can cause screen flashes
    or p-state WARNS depending on what the wrapped value is.
    
    So we need a way to remove the value from x_plane and y_plane without
    exceeding the maximum cursor size.
    
    [How]
    Subtract as much as x_plane/y_plane as possible from x and y and place
    the remainder in the cursor hotspot register.
    
    The value for x_hotspot and y_hotspot can still wrap around but it
    won't happen in a case where the cursor is actually enabled.
    
    The cursor plane needs to intersect at least one pixel of the plane's
    rectangle to be enabled, so the cursor position + hotspot provided by
    userspace must always be strictly less than the maximum cursor size for
    the cursor to actually be enabled.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Sun peng Li <Sunpeng.Li@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 3f2ff27ff86d..4969fa5e6f1d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2710,9 +2710,15 @@ static void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 		.rotation = pipe_ctx->plane_state->rotation,
 		.mirror = pipe_ctx->plane_state->horizontal_mirror
 	};
-
-	pos_cpy.x_hotspot += pipe_ctx->plane_state->dst_rect.x;
-	pos_cpy.y_hotspot += pipe_ctx->plane_state->dst_rect.y;
+	uint32_t x_plane = pipe_ctx->plane_state->dst_rect.x;
+	uint32_t y_plane = pipe_ctx->plane_state->dst_rect.y;
+	uint32_t x_offset = min(x_plane, pos_cpy.x);
+	uint32_t y_offset = min(y_plane, pos_cpy.y);
+
+	pos_cpy.x -= x_offset;
+	pos_cpy.y -= y_offset;
+	pos_cpy.x_hotspot += (x_plane - x_offset);
+	pos_cpy.y_hotspot += (y_plane - y_offset);
 
 	if (pipe_ctx->plane_state->address.type
 			== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)

commit 813d20dccf93f84f4c16236f7c037dc34db48f10
Author: Aidan Wood <Aidan.Wood@amd.com>
Date:   Fri Feb 22 13:37:03 2019 -0500

    drm/amd/display: Fix multi-thread writing to 1 state
    
    [Why]
    Multiple threads were writing back to one global VBA in DC resulting
    in multiple threads overwriting eachother's data
    
    [How]
    Add an instance of DML (which contains VBA) to each context and
    change all calls that used dc->dml to use context->dml. Created a
    seperate copy constructor for linux in a case where there is no
    access to DC.
    
    Signed-off-by: Aidan Wood <Aidan.Wood@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 47653fe0bb2d..3f2ff27ff86d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -345,13 +345,13 @@ void dcn10_log_hw_state(struct dc *dc,
 
 	DTN_INFO("\nCALCULATED Clocks: dcfclk_khz:%d  dcfclk_deep_sleep_khz:%d  dispclk_khz:%d\n"
 		"dppclk_khz:%d  max_supported_dppclk_khz:%d  fclk_khz:%d  socclk_khz:%d\n\n",
-			dc->current_state->bw.dcn.clk.dcfclk_khz,
-			dc->current_state->bw.dcn.clk.dcfclk_deep_sleep_khz,
-			dc->current_state->bw.dcn.clk.dispclk_khz,
-			dc->current_state->bw.dcn.clk.dppclk_khz,
-			dc->current_state->bw.dcn.clk.max_supported_dppclk_khz,
-			dc->current_state->bw.dcn.clk.fclk_khz,
-			dc->current_state->bw.dcn.clk.socclk_khz);
+			dc->current_state->bw_ctx.bw.dcn.clk.dcfclk_khz,
+			dc->current_state->bw_ctx.bw.dcn.clk.dcfclk_deep_sleep_khz,
+			dc->current_state->bw_ctx.bw.dcn.clk.dispclk_khz,
+			dc->current_state->bw_ctx.bw.dcn.clk.dppclk_khz,
+			dc->current_state->bw_ctx.bw.dcn.clk.max_supported_dppclk_khz,
+			dc->current_state->bw_ctx.bw.dcn.clk.fclk_khz,
+			dc->current_state->bw_ctx.bw.dcn.clk.socclk_khz);
 
 	log_mpc_crc(dc, log_ctx);
 
@@ -2069,7 +2069,7 @@ void update_dchubp_dpp(
 	 * divided by 2
 	 */
 	if (plane_state->update_flags.bits.full_update) {
-		bool should_divided_by_2 = context->bw.dcn.clk.dppclk_khz <=
+		bool should_divided_by_2 = context->bw_ctx.bw.dcn.clk.dppclk_khz <=
 				dc->res_pool->clk_mgr->clks.dispclk_khz / 2;
 
 		dpp->funcs->dpp_dppclk_control(
@@ -2443,7 +2443,7 @@ static void dcn10_prepare_bandwidth(
 
 	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
 		if (context->stream_count == 0)
-			context->bw.dcn.clk.phyclk_khz = 0;
+			context->bw_ctx.bw.dcn.clk.phyclk_khz = 0;
 
 		dc->res_pool->clk_mgr->funcs->update_clocks(
 				dc->res_pool->clk_mgr,
@@ -2452,7 +2452,7 @@ static void dcn10_prepare_bandwidth(
 	}
 
 	hubbub1_program_watermarks(dc->res_pool->hubbub,
-			&context->bw.dcn.watermarks,
+			&context->bw_ctx.bw.dcn.watermarks,
 			dc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000,
 			true);
 	dcn10_stereo_hw_frame_pack_wa(dc, context);
@@ -2473,7 +2473,7 @@ static void dcn10_optimize_bandwidth(
 
 	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
 		if (context->stream_count == 0)
-			context->bw.dcn.clk.phyclk_khz = 0;
+			context->bw_ctx.bw.dcn.clk.phyclk_khz = 0;
 
 		dc->res_pool->clk_mgr->funcs->update_clocks(
 				dc->res_pool->clk_mgr,
@@ -2482,7 +2482,7 @@ static void dcn10_optimize_bandwidth(
 	}
 
 	hubbub1_program_watermarks(dc->res_pool->hubbub,
-			&context->bw.dcn.watermarks,
+			&context->bw_ctx.bw.dcn.watermarks,
 			dc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000,
 			true);
 	dcn10_stereo_hw_frame_pack_wa(dc, context);

commit 457109829f4ee4107e8c7108237afba21fabbb5e
Merge: b4e4538a0ab5 7a65bdc6903d
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Apr 3 11:36:52 2019 +1000

    Merge branch 'drm-next-5.2' of git://people.freedesktop.org/~agd5f/linux into drm-next
    
    amdgpu:
    - Switch to HMM for userptr (reverted until HMM fixes land)
    - New experimental SMU 11 replacement for powerplay for vega20 (not enabled by default)
    - Initial RAS support for vega20
    - BACO support for vega12
    - BACO fixes for vega20
    - Rework IH handling for page fault and retry interrupts
    - Cleanly split CPU and GPU paths for GPUVM updates
    - Powerplay fixes
    - XGMI fixes
    - Rework how DC interacts with atomic for planes
    - Clean up and simplify DC/Powerplay interfaces
    - Misc cleanups and bug fixes
    
    amdkfd:
    - Switch to HMM for userptr (reverted until HMM fixes land)
    - Add initial RAS support
    - MQD fixes
    
    ttm:
    - Unify DRM_FILE_PAGE_OFFSET handling
    - Account for kernel allocations in kernel zone only
    - Misc cleanups
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Alex Deucher <alexdeucher@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190402170820.22197-1-alexander.deucher@amd.com

commit 7fe538a4d64135d8f8e4aca8d0aedf266958025c
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Fri Mar 1 11:12:50 2019 -0500

    drm/amd/display: fix DP 422 VID_M half the rate issue.
    
    [Description]
    when programming VID_TIMING, we were using the original VESA timing for DP_VIDM/N.
    for YCbCr420 or compressed YCbCr422, using half rate as  YCbCr444.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 5fcc69c56584..eef58536a6ac 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2900,6 +2900,29 @@ static void dcn10_setup_vupdate_interrupt(struct pipe_ctx *pipe_ctx)
 		tg->funcs->setup_vertical_interrupt2(tg, start_line);
 }
 
+static void dcn10_unblank_stream(struct pipe_ctx *pipe_ctx,
+		struct dc_link_settings *link_settings)
+{
+	struct encoder_unblank_param params = { { 0 } };
+	struct dc_stream_state *stream = pipe_ctx->stream;
+	struct dc_link *link = stream->link;
+
+	/* only 3 items below are used by unblank */
+	params.timing = pipe_ctx->stream->timing;
+
+	params.link_settings.link_rate = link_settings->link_rate;
+
+	if (dc_is_dp_signal(pipe_ctx->stream->signal)) {
+		if (params.timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)
+			params.timing.pix_clk_100hz /= 2;
+		pipe_ctx->stream_res.stream_enc->funcs->dp_unblank(pipe_ctx->stream_res.stream_enc, &params);
+	}
+
+	if (link->local_sink && link->local_sink->sink_signal == SIGNAL_TYPE_EDP) {
+		link->dc->hwss.edp_backlight_control(link, true);
+	}
+}
+
 static const struct hw_sequencer_funcs dcn10_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.init_hw = dcn10_init_hw,
@@ -2921,7 +2944,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.update_info_frame = dce110_update_info_frame,
 	.enable_stream = dce110_enable_stream,
 	.disable_stream = dce110_disable_stream,
-	.unblank_stream = dce110_unblank_stream,
+	.unblank_stream = dcn10_unblank_stream,
 	.blank_stream = dce110_blank_stream,
 	.enable_audio_stream = dce110_enable_audio_stream,
 	.disable_audio_stream = dce110_disable_audio_stream,

commit 33d7598d7022eac064b48e42dd4ae3e1dc9b52cd
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Fri Feb 22 16:50:00 2019 -0500

    drm/amd/display: fix up reference clock abstractions
    
    [why]
    "reference clock" is a very overloaded variable in DC and causes confusion
    as there are multiple sources of reference clock, which may be different values
    incorrect input values to DML will cause DCHUB to be programmed improperly
    and lead to hard to debug underflow issues
    
    [how]
    instead of using ref clock everywhere, specify WHICH ref clock:
    - xtalin
    - dccg refclk
    - dchub refclk
    
    these are all distinct values which may not be equal
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: David Francis <David.Francis@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index dfa5698b4ec3..5fcc69c56584 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -65,7 +65,7 @@ void print_microsec(struct dc_context *dc_ctx,
 	struct dc_log_buffer_ctx *log_ctx,
 	uint32_t ref_cycle)
 {
-	const uint32_t ref_clk_mhz = dc_ctx->dc->res_pool->ref_clock_inKhz / 1000;
+	const uint32_t ref_clk_mhz = dc_ctx->dc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000;
 	static const unsigned int frac = 1000;
 	uint32_t us_x10 = (ref_cycle * frac) / ref_clk_mhz;
 
@@ -2453,7 +2453,7 @@ static void dcn10_prepare_bandwidth(
 
 	hubbub1_program_watermarks(dc->res_pool->hubbub,
 			&context->bw.dcn.watermarks,
-			dc->res_pool->ref_clock_inKhz / 1000,
+			dc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000,
 			true);
 	dcn10_stereo_hw_frame_pack_wa(dc, context);
 
@@ -2483,7 +2483,7 @@ static void dcn10_optimize_bandwidth(
 
 	hubbub1_program_watermarks(dc->res_pool->hubbub,
 			&context->bw.dcn.watermarks,
-			dc->res_pool->ref_clock_inKhz / 1000,
+			dc->res_pool->ref_clocks.dchub_ref_clock_inKhz / 1000,
 			true);
 	dcn10_stereo_hw_frame_pack_wa(dc, context);
 
@@ -2703,7 +2703,7 @@ static void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 	struct dc_cursor_mi_param param = {
 		.pixel_clk_khz = pipe_ctx->stream->timing.pix_clk_100hz / 10,
-		.ref_clk_khz = pipe_ctx->stream->ctx->dc->res_pool->ref_clock_inKhz,
+		.ref_clk_khz = pipe_ctx->stream->ctx->dc->res_pool->ref_clocks.dchub_ref_clock_inKhz,
 		.viewport = pipe_ctx->plane_res.scl_data.viewport,
 		.h_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.horz,
 		.v_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.vert,

commit 87d44f62d51fddce9dd7c0a7badc3e6723b30e9d
Author: Charlene Liu <Charlene.Liu@amd.com>
Date:   Wed Feb 13 19:48:31 2019 -0500

    Revert "drm/amd/display: dcn add check surface in_use"
    
    This reverts commit 6bff1cc7780cca2fd2a775aa7b18b789e2a1b608.
    
    [Description]
    Revert since this will be checked at CP side.
    
    Signed-off-by: Charlene Liu <Charlene.Liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index db67122d1384..dfa5698b4ec3 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -88,24 +88,6 @@ static void log_mpc_crc(struct dc *dc,
 		REG_READ(DPP_TOP0_DPP_CRC_VAL_B_A), REG_READ(DPP_TOP0_DPP_CRC_VAL_R_G));
 }
 
-void dcn10_wait_for_surface_safe_to_use(struct dc *dc,
-	struct pipe_ctx *pipe_ctx)
-{
-	struct hubbub *hubbub = dc->res_pool->hubbub;
-
-	if (!pipe_ctx->plane_state)
-		return;
-	if (!pipe_ctx->stream)
-		return;
-
-	if (!pipe_ctx->plane_state->visible)
-		return;
-	if (hubbub->funcs->wait_for_surf_safe_update) {
-		hubbub->funcs->wait_for_surf_safe_update(dc->res_pool->hubbub,
-			pipe_ctx->plane_res.hubp->inst);
-	}
-}
-
 void dcn10_log_hubbub_state(struct dc *dc, struct dc_log_buffer_ctx *log_ctx)
 {
 	struct dc_context *dc_ctx = dc->ctx;
@@ -2969,9 +2951,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.disable_stream_gating = NULL,
 	.enable_stream_gating = NULL,
 	.setup_periodic_interrupt = dcn10_setup_periodic_interrupt,
-	.setup_vupdate_interrupt = dcn10_setup_vupdate_interrupt,
-	.wait_surface_safe_to_update = dcn10_wait_for_surface_safe_to_use,
-
+	.setup_vupdate_interrupt = dcn10_setup_vupdate_interrupt
 };
 
 

commit 46570f090469c8c453622523ae5ccede256148f5
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Fri Feb 8 20:50:51 2019 -0500

    drm/amd/display: Keep clocks high before seamless boot done
    
    [Why]
    UEFI boot usually uses a boot profile that uses higher clocks
    and watermark settings.
    UEFI boot surface is less optimal, for example it uses linear surface
    
    [How]
    Before we finish our seamless boot sequence, keep the clock and
    watermark settings from boot.
    Update to optimal settings only after first flip away from UEFI
    frame buffer.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 18cc5d90b4d4..db67122d1384 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1026,9 +1026,10 @@ static void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 		 * to non-preferred front end. If pipe_ctx->stream is not NULL,
 		 * we will use the pipe, so don't disable
 		 */
-		if (pipe_ctx->stream != NULL &&
-		    pipe_ctx->stream_res.tg->funcs->is_tg_enabled(
-			    pipe_ctx->stream_res.tg))
+		if (can_apply_seamless_boot &&
+			pipe_ctx->stream != NULL &&
+			pipe_ctx->stream_res.tg->funcs->is_tg_enabled(
+				pipe_ctx->stream_res.tg))
 			continue;
 
 		/* Disable on the current state so the new one isn't cleared. */

commit 128c075ad4fc4139f47bcd38a5115573394a0e34
Author: Wesley Chalmers <Wesley.Chalmers@amd.com>
Date:   Wed Feb 6 13:19:08 2019 -0500

    drm/amd/display: Set flip pending for pipe split
    
    [WHY]
    When doing split pipe, if one pipe is pending on flip, the entire
    plane's status should be flip pending, otherwise corruption can occur
    when OS writes to a surface prematurely.
    
    [HOW]
    Clear the flip pending bit before checking pipes, then OR the flip
    pending bits from all pipes together to create the flip pending status
    of the entire plane.
    
    Signed-off-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Eryk Brol <Eryk.Brol@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7ba3e09ad3c9..18cc5d90b4d4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2689,7 +2689,7 @@ static void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 	flip_pending = pipe_ctx->plane_res.hubp->funcs->hubp_is_flip_pending(
 					pipe_ctx->plane_res.hubp);
 
-	plane_state->status.is_flip_pending = flip_pending;
+	plane_state->status.is_flip_pending = plane_state->status.is_flip_pending || flip_pending;
 
 	if (!flip_pending)
 		plane_state->status.current_address = plane_state->status.requested_address;

commit 4bc46da4a3aeeb4d55e83dd276cf72756e908286
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Wed Feb 6 10:18:17 2019 -0500

    drm/amd/display: Reset planes that were disabled in init_pipes
    
    [Why]
    Seamless boot tries to reuse planes that were enabled for the first
    commit applied.
    
    In the case where Raven is booting with two monitors connected and the
    first commit contains two streams the screen corruption would occur
    because the second stream was trying to re-use a tg and plane that
    weren't previously enabled.
    
    The state on the first commit looks something like the following:
    
    TG0: enabled=1
    TG1: enabled=0
    TG2: enabled=0
    TG3: enabled=0
    
    New state: pipe=0, stream=0,    plane=0,       new_tg=0
    New state: pipe=1, stream=1,    plane=1,       new_tg=1
    New state: pipe=2, stream=NULL, plane=NULL,    new_tg=NULL
    New state: pipe=3, stream=NULL, plane=NULL,    new_tg=NULL
    
    Only one plane/tg is setup before we enter accelerated mode so
    we really want to disabling everything but that first plane.
    
    [How]
    
    Check if the stream is not NULL and if the tg is enabled before
    deciding whether to skip the plane disable.
    
    Also ensure we're also disabling on the current state's pipe_ctx so
    we don't overwrite the fields in the new pending state.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f7f7ca61abdd..7ba3e09ad3c9 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1026,9 +1026,14 @@ static void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 		 * to non-preferred front end. If pipe_ctx->stream is not NULL,
 		 * we will use the pipe, so don't disable
 		 */
-		if (pipe_ctx->stream != NULL)
+		if (pipe_ctx->stream != NULL &&
+		    pipe_ctx->stream_res.tg->funcs->is_tg_enabled(
+			    pipe_ctx->stream_res.tg))
 			continue;
 
+		/* Disable on the current state so the new one isn't cleared. */
+		pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
+
 		dpp->funcs->dpp_reset(dpp);
 
 		pipe_ctx->stream_res.tg = tg;

commit 4a797d24fe0dc75063e8cfc312d20abff8a0ea99
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Feb 1 07:31:47 2019 -0500

    drm/amd/display: Allow for plane-less resource reservation
    
    This change changes dc add plane logic to allow plane-less resource
    reservation (pipe split).
    
    If a free pipe_ctx (no plane_state attached) is the head pipe, and is
    found with a bottom pipe attached, assign the plane to add on the bottom
    pipe.
    
    In addition, prepend dcn10 to dcn10-specific reset_back_end_for_pipe
    and reset_hw_ctx_wrap
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 5326bb8d5b02..f7f7ca61abdd 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -732,7 +732,7 @@ static enum dc_status dcn10_enable_stream_timing(
 	return DC_OK;
 }
 
-static void reset_back_end_for_pipe(
+static void dcn10_reset_back_end_for_pipe(
 		struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
 		struct dc_state *context)
@@ -1173,7 +1173,7 @@ static void dcn10_init_hw(struct dc *dc)
 	memset(&dc->res_pool->clk_mgr->clks, 0, sizeof(dc->res_pool->clk_mgr->clks));
 }
 
-static void reset_hw_ctx_wrap(
+static void dcn10_reset_hw_ctx_wrap(
 		struct dc *dc,
 		struct dc_state *context)
 {
@@ -1195,10 +1195,9 @@ static void reset_hw_ctx_wrap(
 				pipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {
 			struct clock_source *old_clk = pipe_ctx_old->clock_source;
 
-			reset_back_end_for_pipe(dc, pipe_ctx_old, dc->current_state);
-			if (dc->hwss.enable_stream_gating) {
+			dcn10_reset_back_end_for_pipe(dc, pipe_ctx_old, dc->current_state);
+			if (dc->hwss.enable_stream_gating)
 				dc->hwss.enable_stream_gating(dc, pipe_ctx);
-			}
 			if (old_clk)
 				old_clk->funcs->cs_power_down(old_clk);
 		}
@@ -2944,7 +2943,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.pipe_control_lock = dcn10_pipe_control_lock,
 	.prepare_bandwidth = dcn10_prepare_bandwidth,
 	.optimize_bandwidth = dcn10_optimize_bandwidth,
-	.reset_hw_ctx_wrap = reset_hw_ctx_wrap,
+	.reset_hw_ctx_wrap = dcn10_reset_hw_ctx_wrap,
 	.enable_stream_timing = dcn10_enable_stream_timing,
 	.set_drr = set_drr,
 	.get_position = get_position,

commit 2750160bccab4d7a4017197a3f0d75ee8cc4c6af
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Feb 4 14:36:13 2019 -0500

    drm/amd/display: dcn add check surface in_use
    
    Driver need to  poll the SURFACE_INUSE register to determine when to
    start the new task and write data to the checked surface.
    
    Implement the wait functions, and add the necessary hubbub registers.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 62a059d99d33..5326bb8d5b02 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -88,6 +88,24 @@ static void log_mpc_crc(struct dc *dc,
 		REG_READ(DPP_TOP0_DPP_CRC_VAL_B_A), REG_READ(DPP_TOP0_DPP_CRC_VAL_R_G));
 }
 
+void dcn10_wait_for_surface_safe_to_use(struct dc *dc,
+	struct pipe_ctx *pipe_ctx)
+{
+	struct hubbub *hubbub = dc->res_pool->hubbub;
+
+	if (!pipe_ctx->plane_state)
+		return;
+	if (!pipe_ctx->stream)
+		return;
+
+	if (!pipe_ctx->plane_state->visible)
+		return;
+	if (hubbub->funcs->wait_for_surf_safe_update) {
+		hubbub->funcs->wait_for_surf_safe_update(dc->res_pool->hubbub,
+			pipe_ctx->plane_res.hubp->inst);
+	}
+}
+
 void dcn10_log_hubbub_state(struct dc *dc, struct dc_log_buffer_ctx *log_ctx)
 {
 	struct dc_context *dc_ctx = dc->ctx;
@@ -2946,7 +2964,9 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.disable_stream_gating = NULL,
 	.enable_stream_gating = NULL,
 	.setup_periodic_interrupt = dcn10_setup_periodic_interrupt,
-	.setup_vupdate_interrupt = dcn10_setup_vupdate_interrupt
+	.setup_vupdate_interrupt = dcn10_setup_vupdate_interrupt,
+	.wait_surface_safe_to_update = dcn10_wait_for_surface_safe_to_use,
+
 };
 
 

commit 522f82f35fd0057cae326ad21a5f93a221b08b25
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Wed Jan 30 16:14:38 2019 -0500

    drm/amd/display: make seamless boot work generically
    
    [Why]
    Seamless boot code not working on all ASICs because of
    some underflow issues caused by some uninitialized HW
    state.
    
    [How]
    Keep some logical and power gating init code in hw_init.
    Move some per pipe init code to enable accelerated mode
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 8ba895c4b445..62a059d99d33 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -889,22 +889,23 @@ void hwss1_plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 		dcn10_verify_allow_pstate_change_high(dc);
 }
 
-static void plane_atomic_power_down(struct dc *dc, struct pipe_ctx *pipe_ctx)
+static void plane_atomic_power_down(struct dc *dc,
+		struct dpp *dpp,
+		struct hubp *hubp)
 {
 	struct dce_hwseq *hws = dc->hwseq;
-	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 	DC_LOGGER_INIT(dc->ctx->logger);
 
 	if (REG(DC_IP_REQUEST_CNTL)) {
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 1);
 		dpp_pg_control(hws, dpp->inst, false);
-		hubp_pg_control(hws, pipe_ctx->plane_res.hubp->inst, false);
+		hubp_pg_control(hws, hubp->inst, false);
 		dpp->funcs->dpp_reset(dpp);
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 0);
 		DC_LOG_DEBUG(
-				"Power gated front end %d\n", pipe_ctx->pipe_idx);
+				"Power gated front end %d\n", hubp->inst);
 	}
 }
 
@@ -931,7 +932,9 @@ static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	hubp->power_gated = true;
 	dc->optimized_required = false; /* We're powering off, no need to optimize */
 
-	plane_atomic_power_down(dc, pipe_ctx);
+	plane_atomic_power_down(dc,
+			pipe_ctx->plane_res.dpp,
+			pipe_ctx->plane_res.hubp);
 
 	pipe_ctx->stream = NULL;
 	memset(&pipe_ctx->stream_res, 0, sizeof(pipe_ctx->stream_res));
@@ -1001,9 +1004,6 @@ static void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 		struct dpp *dpp = dc->res_pool->dpps[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		// W/A for issue with dc_post_update_surfaces_to_stream
-		hubp->power_gated = true;
-
 		/* There is assumption that pipe_ctx is not mapping irregularly
 		 * to non-preferred front end. If pipe_ctx->stream is not NULL,
 		 * we will use the pipe, so don't disable
@@ -1108,6 +1108,22 @@ static void dcn10_init_hw(struct dc *dc)
 			link->link_status.link_active = true;
 	}
 
+	/* If taking control over from VBIOS, we may want to optimize our first
+	 * mode set, so we need to skip powering down pipes until we know which
+	 * pipes we want to use.
+	 * Otherwise, if taking control is not possible, we need to power
+	 * everything down.
+	 */
+	if (dcb->funcs->is_accelerated_mode(dcb)) {
+		for (i = 0; i < dc->res_pool->pipe_count; i++) {
+			struct hubp *hubp = dc->res_pool->hubps[i];
+			struct dpp *dpp = dc->res_pool->dpps[i];
+
+			dc->res_pool->opps[i]->mpc_tree_params.opp_id = dc->res_pool->opps[i]->inst;
+			plane_atomic_power_down(dc, dpp, hubp);
+		}
+	}
+
 	for (i = 0; i < dc->res_pool->audio_count; i++) {
 		struct audio *audio = dc->res_pool->audios[i];
 
@@ -1137,9 +1153,6 @@ static void dcn10_init_hw(struct dc *dc)
 	enable_power_gating_plane(dc->hwseq, true);
 
 	memset(&dc->res_pool->clk_mgr->clks, 0, sizeof(dc->res_pool->clk_mgr->clks));
-
-	if (dc->hwss.init_pipes)
-		dc->hwss.init_pipes(dc, dc->current_state);
 }
 
 static void reset_hw_ctx_wrap(

commit 2c3cd66f4c66b169c18a2dbebbc894681d282278
Merge: 7fbd5d784f75 1c163f4c7b3f
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Mar 4 12:02:55 2019 +1000

    Merge v5.0 into drm-next
    
    There is a really hairy resolution involving amdgpu fixes, that I'd rather confirm here.
    
    Also some misc fixes are landed by me, but the pr has them as well.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit 0921c41e19028314830b33daa681e46b46477c5e
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Fri Feb 1 09:36:59 2019 -0500

    drm/amd/display: Fix negative cursor pos programming
    
    [Why]
    If the cursor pos passed from DM is less than the plane_state->dst_rect
    top left corner then the unsigned cursor pos wraps around to a large
    positive number since cursor pos is a u32.
    
    There was an attempt to guard against this in hubp1_cursor_set_position
    by checking the src_x_offset and src_y_offset and offseting the
    cursor hotspot within hubp1_cursor_set_position.
    
    However, the cursor position itself is still being programmed
    incorrectly as a large value.
    
    This manifests itself visually as the cursor disappearing or containing
    strange artifacts near the middle of the screen on raven.
    
    [How]
    Don't subtract the destination rect top left corner from the pos but
    add it to the hotspot instead. This happens before the pos gets
    passed into hubp1_cursor_set_position.
    
    This achieves the same result but avoids the subtraction wrap around.
    With this fix the original cursor programming logic can be used again.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Murton Liu <Murton.Liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 58a12ddf12f3..41883c981789 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2658,8 +2658,8 @@ static void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 		.mirror = pipe_ctx->plane_state->horizontal_mirror
 	};
 
-	pos_cpy.x -= pipe_ctx->plane_state->dst_rect.x;
-	pos_cpy.y -= pipe_ctx->plane_state->dst_rect.y;
+	pos_cpy.x_hotspot += pipe_ctx->plane_state->dst_rect.x;
+	pos_cpy.y_hotspot += pipe_ctx->plane_state->dst_rect.y;
 
 	if (pipe_ctx->plane_state->address.type
 			== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)

commit d6001aed266391e05517ff03078c144d4b279d5d
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Jan 25 14:40:14 2019 -0500

    drm/amd/display: Refactor for setup periodic interrupt.
    
    [Why]
    Current periodic interrupt start point calc in optc
    is not clear.
    
    [How]
    1. DM convert delta time to lines number and dc will calculate the
       start position as per lines number and interrupt type.
    2. hwss calculates the start point as per line offset.
    3. optc programs vertical interrupts register as per start point
       and interrupt source.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d4dde1d86b72..8ba895c4b445 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2741,6 +2741,147 @@ static void dcn10_set_cursor_sdr_white_level(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->plane_res.dpp, &opt_attr);
 }
 
+/**
+* apply_front_porch_workaround  TODO FPGA still need?
+*
+* This is a workaround for a bug that has existed since R5xx and has not been
+* fixed keep Front porch at minimum 2 for Interlaced mode or 1 for progressive.
+*/
+static void apply_front_porch_workaround(
+	struct dc_crtc_timing *timing)
+{
+	if (timing->flags.INTERLACE == 1) {
+		if (timing->v_front_porch < 2)
+			timing->v_front_porch = 2;
+	} else {
+		if (timing->v_front_porch < 1)
+			timing->v_front_porch = 1;
+	}
+}
+
+int get_vupdate_offset_from_vsync(struct pipe_ctx *pipe_ctx)
+{
+	struct timing_generator *optc = pipe_ctx->stream_res.tg;
+	const struct dc_crtc_timing *dc_crtc_timing = &pipe_ctx->stream->timing;
+	struct dc_crtc_timing patched_crtc_timing;
+	int vesa_sync_start;
+	int asic_blank_end;
+	int interlace_factor;
+	int vertical_line_start;
+
+	patched_crtc_timing = *dc_crtc_timing;
+	apply_front_porch_workaround(&patched_crtc_timing);
+
+	interlace_factor = patched_crtc_timing.flags.INTERLACE ? 2 : 1;
+
+	vesa_sync_start = patched_crtc_timing.v_addressable +
+			patched_crtc_timing.v_border_bottom +
+			patched_crtc_timing.v_front_porch;
+
+	asic_blank_end = (patched_crtc_timing.v_total -
+			vesa_sync_start -
+			patched_crtc_timing.v_border_top)
+			* interlace_factor;
+
+	vertical_line_start = asic_blank_end -
+			optc->dlg_otg_param.vstartup_start + 1;
+
+	return vertical_line_start;
+}
+
+static void calc_vupdate_position(
+		struct pipe_ctx *pipe_ctx,
+		uint32_t *start_line,
+		uint32_t *end_line)
+{
+	const struct dc_crtc_timing *dc_crtc_timing = &pipe_ctx->stream->timing;
+	int vline_int_offset_from_vupdate =
+			pipe_ctx->stream->periodic_interrupt0.lines_offset;
+	int vupdate_offset_from_vsync = get_vupdate_offset_from_vsync(pipe_ctx);
+	int start_position;
+
+	if (vline_int_offset_from_vupdate > 0)
+		vline_int_offset_from_vupdate--;
+	else if (vline_int_offset_from_vupdate < 0)
+		vline_int_offset_from_vupdate++;
+
+	start_position = vline_int_offset_from_vupdate + vupdate_offset_from_vsync;
+
+	if (start_position >= 0)
+		*start_line = start_position;
+	else
+		*start_line = dc_crtc_timing->v_total + start_position - 1;
+
+	*end_line = *start_line + 2;
+
+	if (*end_line >= dc_crtc_timing->v_total)
+		*end_line = 2;
+}
+
+static void cal_vline_position(
+		struct pipe_ctx *pipe_ctx,
+		enum vline_select vline,
+		uint32_t *start_line,
+		uint32_t *end_line)
+{
+	enum vertical_interrupt_ref_point ref_point = INVALID_POINT;
+
+	if (vline == VLINE0)
+		ref_point = pipe_ctx->stream->periodic_interrupt0.ref_point;
+	else if (vline == VLINE1)
+		ref_point = pipe_ctx->stream->periodic_interrupt1.ref_point;
+
+	switch (ref_point) {
+	case START_V_UPDATE:
+		calc_vupdate_position(
+				pipe_ctx,
+				start_line,
+				end_line);
+		break;
+	case START_V_SYNC:
+		// Suppose to do nothing because vsync is 0;
+		break;
+	default:
+		ASSERT(0);
+		break;
+	}
+}
+
+static void dcn10_setup_periodic_interrupt(
+		struct pipe_ctx *pipe_ctx,
+		enum vline_select vline)
+{
+	struct timing_generator *tg = pipe_ctx->stream_res.tg;
+
+	if (vline == VLINE0) {
+		uint32_t start_line = 0;
+		uint32_t end_line = 0;
+
+		cal_vline_position(pipe_ctx, vline, &start_line, &end_line);
+
+		tg->funcs->setup_vertical_interrupt0(tg, start_line, end_line);
+
+	} else if (vline == VLINE1) {
+		pipe_ctx->stream_res.tg->funcs->setup_vertical_interrupt1(
+				tg,
+				pipe_ctx->stream->periodic_interrupt1.lines_offset);
+	}
+}
+
+static void dcn10_setup_vupdate_interrupt(struct pipe_ctx *pipe_ctx)
+{
+	struct timing_generator *tg = pipe_ctx->stream_res.tg;
+	int start_line = get_vupdate_offset_from_vsync(pipe_ctx);
+
+	if (start_line < 0) {
+		ASSERT(0);
+		start_line = 0;
+	}
+
+	if (tg->funcs->setup_vertical_interrupt2)
+		tg->funcs->setup_vertical_interrupt2(tg, start_line);
+}
+
 static const struct hw_sequencer_funcs dcn10_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.init_hw = dcn10_init_hw,
@@ -2790,7 +2931,9 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.set_cursor_attribute = dcn10_set_cursor_attribute,
 	.set_cursor_sdr_white_level = dcn10_set_cursor_sdr_white_level,
 	.disable_stream_gating = NULL,
-	.enable_stream_gating = NULL
+	.enable_stream_gating = NULL,
+	.setup_periodic_interrupt = dcn10_setup_periodic_interrupt,
+	.setup_vupdate_interrupt = dcn10_setup_vupdate_interrupt
 };
 
 

commit 240d09d070a7e082d9cb3c2a6112ce3c43bf5df5
Author: Gary Kattan <gary.kattan@amd.com>
Date:   Fri Jan 25 15:04:14 2019 -0800

    drm/amd/display: Ungate stream before programming registers
    
    [Why]
    Certain tests fail after a fresh reboot. This is caused by writing to
    registers prior to ungating the stream we're trying to program.
    
    [How]
    Make sure the stream is ungated before writing to its registers.
    This also enables power-gating plane resources before init_hw
    initializes them.
    Additionally, this does some refactoring to move gating/ungating
    from enable/disable_plane functions to where stream resources are
    enabled/disabled.
    
    Signed-off-by: Gary Kattan <gary.kattan@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d42fade50e18..d4dde1d86b72 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1165,11 +1165,13 @@ static void reset_hw_ctx_wrap(
 			struct clock_source *old_clk = pipe_ctx_old->clock_source;
 
 			reset_back_end_for_pipe(dc, pipe_ctx_old, dc->current_state);
+			if (dc->hwss.enable_stream_gating) {
+				dc->hwss.enable_stream_gating(dc, pipe_ctx);
+			}
 			if (old_clk)
 				old_clk->funcs->cs_power_down(old_clk);
 		}
 	}
-
 }
 
 static bool patch_address_for_sbs_tb_stereo(
@@ -2786,7 +2788,9 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.edp_wait_for_hpd_ready = hwss_edp_wait_for_hpd_ready,
 	.set_cursor_position = dcn10_set_cursor_position,
 	.set_cursor_attribute = dcn10_set_cursor_attribute,
-	.set_cursor_sdr_white_level = dcn10_set_cursor_sdr_white_level
+	.set_cursor_sdr_white_level = dcn10_set_cursor_sdr_white_level,
+	.disable_stream_gating = NULL,
+	.enable_stream_gating = NULL
 };
 
 

commit ce72741b53cdc70f9738c04920fefb93448f1f5e
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Sun Jan 20 01:54:01 2019 -0500

    drm/amd/display: remove screen flashes on seamless boot
    
    [Why]
    We want boot to desktop to be seamless
    
    [How]
    During init pipes, avoid touching the pipes where GOP has already
    enabled the HW to the state we want.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7f95808ad885..d42fade50e18 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -959,9 +959,25 @@ static void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
 static void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 {
 	int i;
+	bool can_apply_seamless_boot = false;
+
+	for (i = 0; i < context->stream_count; i++) {
+		if (context->streams[i]->apply_seamless_boot_optimization) {
+			can_apply_seamless_boot = true;
+			break;
+		}
+	}
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct timing_generator *tg = dc->res_pool->timing_generators[i];
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		/* There is assumption that pipe_ctx is not mapping irregularly
+		 * to non-preferred front end. If pipe_ctx->stream is not NULL,
+		 * we will use the pipe, so don't disable
+		 */
+		if (pipe_ctx->stream != NULL)
+			continue;
 
 		if (tg->funcs->is_tg_enabled(tg))
 			tg->funcs->lock(tg);
@@ -975,7 +991,9 @@ static void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 		}
 	}
 
-	dc->res_pool->mpc->funcs->mpc_init(dc->res_pool->mpc);
+	/* Cannot reset the MPC mux if seamless boot */
+	if (!can_apply_seamless_boot)
+		dc->res_pool->mpc->funcs->mpc_init(dc->res_pool->mpc);
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct timing_generator *tg = dc->res_pool->timing_generators[i];
@@ -983,6 +1001,16 @@ static void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 		struct dpp *dpp = dc->res_pool->dpps[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
+		// W/A for issue with dc_post_update_surfaces_to_stream
+		hubp->power_gated = true;
+
+		/* There is assumption that pipe_ctx is not mapping irregularly
+		 * to non-preferred front end. If pipe_ctx->stream is not NULL,
+		 * we will use the pipe, so don't disable
+		 */
+		if (pipe_ctx->stream != NULL)
+			continue;
+
 		dpp->funcs->dpp_reset(dpp);
 
 		pipe_ctx->stream_res.tg = tg;

commit 4dfdd0ee8529a9283bc3503919719ae69a41914e
Author: Josip Pavic <Josip.Pavic@amd.com>
Date:   Tue Jan 29 14:15:03 2019 -0500

    drm/amd/display: send pipe set command to dmcu when stream unblanks
    
    [Why]
    When stream is blanked, pipe set command is sent to dmcu to notify it
    that the abm pipe is disabled. When stream is unblanked, no notification is
    made to dmcu that the abm pipe has been enabled, resulting in abm not
    being enabled in the firmware.
    
    [How]
    When stream is unblanked, send a pipe set command to dmcu.
    
    Signed-off-by: Josip Pavic <Josip.Pavic@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 117d9d8227f7..7f95808ad885 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2162,8 +2162,10 @@ static void dcn10_blank_pixel_data(
 	if (!blank) {
 		if (stream_res->tg->funcs->set_blank)
 			stream_res->tg->funcs->set_blank(stream_res->tg, blank);
-		if (stream_res->abm)
+		if (stream_res->abm) {
+			stream_res->abm->funcs->set_pipe(stream_res->abm, stream_res->tg->inst + 1);
 			stream_res->abm->funcs->set_abm_level(stream_res->abm, stream->abm_level);
+		}
 	} else if (blank) {
 		if (stream_res->abm)
 			stream_res->abm->funcs->set_abm_immediate_disable(stream_res->abm);

commit fb55546ea4b50f04ef41c196b8ac1824e26bc48c
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Sun Jan 20 01:23:07 2019 -0500

    drm/amd/display: refactor init_hw to isolate pipe related init
    
    [Why]
    Pipe related init is possible to optimized if we know what we
    intend to program, and if we can determine it matches what is
    already programmed for the pipe.
    
    [How]
    First step is to isolate the pipe related init code
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index a03bbbf94d5d..117d9d8227f7 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -956,97 +956,34 @@ static void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
 					pipe_ctx->pipe_idx);
 }
 
-static void dcn10_init_hw(struct dc *dc)
+static void dcn10_init_pipes(struct dc *dc, struct dc_state *context)
 {
 	int i;
-	struct abm *abm = dc->res_pool->abm;
-	struct dmcu *dmcu = dc->res_pool->dmcu;
-	struct dce_hwseq *hws = dc->hwseq;
-	struct dc_bios *dcb = dc->ctx->dc_bios;
-	struct dc_state  *context = dc->current_state;
-
-	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
-		REG_WRITE(REFCLK_CNTL, 0);
-		REG_UPDATE(DCHUBBUB_GLOBAL_TIMER_CNTL, DCHUBBUB_GLOBAL_TIMER_ENABLE, 1);
-		REG_WRITE(DIO_MEM_PWR_CTRL, 0);
-
-		if (!dc->debug.disable_clock_gate) {
-			/* enable all DCN clock gating */
-			REG_WRITE(DCCG_GATE_DISABLE_CNTL, 0);
-
-			REG_WRITE(DCCG_GATE_DISABLE_CNTL2, 0);
-
-			REG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);
-		}
-
-		enable_power_gating_plane(dc->hwseq, true);
-	} else {
-
-		if (!dcb->funcs->is_accelerated_mode(dcb)) {
-			bool allow_self_fresh_force_enable =
-					hububu1_is_allow_self_refresh_enabled(dc->res_pool->hubbub);
-
-			bios_golden_init(dc);
-
-			/* WA for making DF sleep when idle after resume from S0i3.
-			 * DCHUBBUB_ARB_ALLOW_SELF_REFRESH_FORCE_ENABLE is set to 1 by
-			 * command table, if DCHUBBUB_ARB_ALLOW_SELF_REFRESH_FORCE_ENABLE = 0
-			 * before calling command table and it changed to 1 after,
-			 * it should be set back to 0.
-			 */
-			if (allow_self_fresh_force_enable == false &&
-					hububu1_is_allow_self_refresh_enabled(dc->res_pool->hubbub))
-				hubbub1_allow_self_refresh_control(dc->res_pool->hubbub, true);
-
-			disable_vga(dc->hwseq);
-		}
-
-		for (i = 0; i < dc->link_count; i++) {
-			/* Power up AND update implementation according to the
-			 * required signal (which may be different from the
-			 * default signal on connector).
-			 */
-			struct dc_link *link = dc->links[i];
-
-			if (link->link_enc->connector.id == CONNECTOR_ID_EDP)
-				dc->hwss.edp_power_control(link, true);
-
-			link->link_enc->funcs->hw_init(link->link_enc);
-
-			/* Check for enabled DIG to identify enabled display */
-			if (link->link_enc->funcs->is_dig_enabled &&
-				link->link_enc->funcs->is_dig_enabled(link->link_enc))
-				link->link_status.link_active = true;
-		}
-	}
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct timing_generator *tg = dc->res_pool->timing_generators[i];
 
 		if (tg->funcs->is_tg_enabled(tg))
 			tg->funcs->lock(tg);
-	}
-
-	/* Blank controller using driver code instead of
-	 * command table.
-	 */
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct timing_generator *tg = dc->res_pool->timing_generators[i];
 
+		/* Blank controller using driver code instead of
+		 * command table.
+		 */
 		if (tg->funcs->is_tg_enabled(tg)) {
 			tg->funcs->set_blank(tg, true);
 			hwss_wait_for_blank_complete(tg);
 		}
 	}
 
-	/* Reset all MPCC muxes */
 	dc->res_pool->mpc->funcs->mpc_init(dc->res_pool->mpc);
 
-	for (i = 0; i < dc->res_pool->timing_generator_count; i++) {
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct timing_generator *tg = dc->res_pool->timing_generators[i];
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 		struct hubp *hubp = dc->res_pool->hubps[i];
 		struct dpp *dpp = dc->res_pool->dpps[i];
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		dpp->funcs->dpp_reset(dpp);
 
 		pipe_ctx->stream_res.tg = tg;
 		pipe_ctx->pipe_idx = i;
@@ -1064,18 +1001,9 @@ static void dcn10_init_hw(struct dc *dc)
 		pipe_ctx->stream_res.opp = dc->res_pool->opps[i];
 
 		hwss1_plane_atomic_disconnect(dc, pipe_ctx);
-	}
-
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct timing_generator *tg = dc->res_pool->timing_generators[i];
 
 		if (tg->funcs->is_tg_enabled(tg))
 			tg->funcs->unlock(tg);
-	}
-
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct timing_generator *tg = dc->res_pool->timing_generators[i];
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		dcn10_disable_plane(dc, pipe_ctx);
 
@@ -1084,10 +1012,73 @@ static void dcn10_init_hw(struct dc *dc)
 
 		tg->funcs->tg_init(tg);
 	}
+}
+
+static void dcn10_init_hw(struct dc *dc)
+{
+	int i;
+	struct abm *abm = dc->res_pool->abm;
+	struct dmcu *dmcu = dc->res_pool->dmcu;
+	struct dce_hwseq *hws = dc->hwseq;
+	struct dc_bios *dcb = dc->ctx->dc_bios;
+
+	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
+		REG_WRITE(REFCLK_CNTL, 0);
+		REG_UPDATE(DCHUBBUB_GLOBAL_TIMER_CNTL, DCHUBBUB_GLOBAL_TIMER_ENABLE, 1);
+		REG_WRITE(DIO_MEM_PWR_CTRL, 0);
 
-	/* end of FPGA. Below if real ASIC */
-	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
+		if (!dc->debug.disable_clock_gate) {
+			/* enable all DCN clock gating */
+			REG_WRITE(DCCG_GATE_DISABLE_CNTL, 0);
+
+			REG_WRITE(DCCG_GATE_DISABLE_CNTL2, 0);
+
+			REG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);
+		}
+
+		enable_power_gating_plane(dc->hwseq, true);
+
+		/* end of FPGA. Below if real ASIC */
 		return;
+	}
+
+	if (!dcb->funcs->is_accelerated_mode(dcb)) {
+		bool allow_self_fresh_force_enable =
+			hububu1_is_allow_self_refresh_enabled(
+						dc->res_pool->hubbub);
+
+		bios_golden_init(dc);
+
+		/* WA for making DF sleep when idle after resume from S0i3.
+		 * DCHUBBUB_ARB_ALLOW_SELF_REFRESH_FORCE_ENABLE is set to 1 by
+		 * command table, if DCHUBBUB_ARB_ALLOW_SELF_REFRESH_FORCE_ENABLE = 0
+		 * before calling command table and it changed to 1 after,
+		 * it should be set back to 0.
+		 */
+		if (allow_self_fresh_force_enable == false &&
+				hububu1_is_allow_self_refresh_enabled(dc->res_pool->hubbub))
+			hubbub1_allow_self_refresh_control(dc->res_pool->hubbub, true);
+
+		disable_vga(dc->hwseq);
+	}
+
+	for (i = 0; i < dc->link_count; i++) {
+		/* Power up AND update implementation according to the
+		 * required signal (which may be different from the
+		 * default signal on connector).
+		 */
+		struct dc_link *link = dc->links[i];
+
+		if (link->link_enc->connector.id == CONNECTOR_ID_EDP)
+			dc->hwss.edp_power_control(link, true);
+
+		link->link_enc->funcs->hw_init(link->link_enc);
+
+		/* Check for enabled DIG to identify enabled display */
+		if (link->link_enc->funcs->is_dig_enabled &&
+			link->link_enc->funcs->is_dig_enabled(link->link_enc))
+			link->link_status.link_active = true;
+	}
 
 	for (i = 0; i < dc->res_pool->audio_count; i++) {
 		struct audio *audio = dc->res_pool->audios[i];
@@ -1118,6 +1109,9 @@ static void dcn10_init_hw(struct dc *dc)
 	enable_power_gating_plane(dc->hwseq, true);
 
 	memset(&dc->res_pool->clk_mgr->clks, 0, sizeof(dc->res_pool->clk_mgr->clks));
+
+	if (dc->hwss.init_pipes)
+		dc->hwss.init_pipes(dc, dc->current_state);
 }
 
 static void reset_hw_ctx_wrap(
@@ -2718,6 +2712,7 @@ static void dcn10_set_cursor_sdr_white_level(struct pipe_ctx *pipe_ctx)
 static const struct hw_sequencer_funcs dcn10_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.init_hw = dcn10_init_hw,
+	.init_pipes = dcn10_init_pipes,
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
 	.apply_ctx_for_surface = dcn10_apply_ctx_for_surface,
 	.update_plane_addr = dcn10_update_plane_addr,

commit 9c0fb8d45bfcf2e8f080489913db443c1fd241ed
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Sun Jan 20 01:45:36 2019 -0500

    drm/amd/display: refactor programming of DRR
    
    [Why]
    Keep enable_stream_timing programming only
    timing related stuff.
    
    [How]
    Move DRR and static screen mask programming from
    enable_stream_timing to outside in
    apply_single_controller_ctx_to_hw
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7117144d48bd..a03bbbf94d5d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -636,8 +636,6 @@ static enum dc_status dcn10_enable_stream_timing(
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	enum dc_color_space color_space;
 	struct tg_color black_color = {0};
-	struct drr_params params = {0};
-	unsigned int event_triggers = 0;
 
 	/* by upper caller loop, pipe0 is parent pipe and be called first.
 	 * back end is set up by for pipe0. Other children pipe share back end
@@ -705,19 +703,6 @@ static enum dc_status dcn10_enable_stream_timing(
 		return DC_ERROR_UNEXPECTED;
 	}
 
-	params.vertical_total_min = stream->adjust.v_total_min;
-	params.vertical_total_max = stream->adjust.v_total_max;
-	if (pipe_ctx->stream_res.tg->funcs->set_drr)
-		pipe_ctx->stream_res.tg->funcs->set_drr(
-			pipe_ctx->stream_res.tg, &params);
-
-	// DRR should set trigger event to monitor surface update event
-	if (stream->adjust.v_total_min != 0 && stream->adjust.v_total_max != 0)
-		event_triggers = 0x80;
-	if (pipe_ctx->stream_res.tg->funcs->set_static_screen_control)
-		pipe_ctx->stream_res.tg->funcs->set_static_screen_control(
-				pipe_ctx->stream_res.tg, event_triggers);
-
 	/* TODO program crtc source select for non-virtual signal*/
 	/* TODO program FMT */
 	/* TODO setup link_enc */

commit ff582b61466f14d61f3a2a54c3d673d85bcb3c76
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Sun Jan 20 01:32:55 2019 -0500

    drm/amd/display: add way to determine if link is active
    
    [Why]
    Need to understand whether link is active aside from stream state.
    This could be used to check what links are enabled by GOP.
    
    [How]
    Store link_active state in link status and initialize it by checking
    if the DIG is enabled.
    Keep it updated on every link enable and disable
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7cead0398c15..7117144d48bd 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1027,6 +1027,11 @@ static void dcn10_init_hw(struct dc *dc)
 				dc->hwss.edp_power_control(link, true);
 
 			link->link_enc->funcs->hw_init(link->link_enc);
+
+			/* Check for enabled DIG to identify enabled display */
+			if (link->link_enc->funcs->is_dig_enabled &&
+				link->link_enc->funcs->is_dig_enabled(link->link_enc))
+				link->link_status.link_active = true;
 		}
 	}
 

commit b9d4b33059b86147bcde8f53ad19b97792837f75
Author: Wesley Chalmers <Wesley.Chalmers@amd.com>
Date:   Tue Jan 22 18:57:06 2019 -0500

    drm/amd/display: Disable Stutter for Stereo 3D
    
    [WHY]
    Bandwidth calculation formulas currently do not take Stereo 3D + Stutter
    properly into account. Disable stutter feature when we detect a Stereo
    3D mode as a temporary workaround.
    
    Signed-off-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Martin Leung <Martin.Leung@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 9f23ea283838..7cead0398c15 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1011,7 +1011,7 @@ static void dcn10_init_hw(struct dc *dc)
 			 */
 			if (allow_self_fresh_force_enable == false &&
 					hububu1_is_allow_self_refresh_enabled(dc->res_pool->hubbub))
-				hubbub1_disable_allow_self_refresh(dc->res_pool->hubbub);
+				hubbub1_allow_self_refresh_control(dc->res_pool->hubbub, true);
 
 			disable_vga(dc->hwseq);
 		}
@@ -2384,6 +2384,22 @@ static void dcn10_apply_ctx_for_surface(
 		hubbub1_wm_change_req_wa(dc->res_pool->hubbub);
 }
 
+static void dcn10_stereo_hw_frame_pack_wa(struct dc *dc, struct dc_state *context)
+{
+	uint8_t i;
+
+	for (i = 0; i < context->stream_count; i++) {
+		if (context->streams[i]->timing.timing_3d_format
+				== TIMING_3D_FORMAT_HW_FRAME_PACKING) {
+			/*
+			 * Disable stutter
+			 */
+			hubbub1_allow_self_refresh_control(dc->res_pool->hubbub, false);
+			break;
+		}
+	}
+}
+
 static void dcn10_prepare_bandwidth(
 		struct dc *dc,
 		struct dc_state *context)
@@ -2405,6 +2421,7 @@ static void dcn10_prepare_bandwidth(
 			&context->bw.dcn.watermarks,
 			dc->res_pool->ref_clock_inKhz / 1000,
 			true);
+	dcn10_stereo_hw_frame_pack_wa(dc, context);
 
 	if (dc->debug.pplib_wm_report_mode == WM_REPORT_OVERRIDE)
 		dcn_bw_notify_pplib_of_wm_ranges(dc);
@@ -2434,6 +2451,7 @@ static void dcn10_optimize_bandwidth(
 			&context->bw.dcn.watermarks,
 			dc->res_pool->ref_clock_inKhz / 1000,
 			true);
+	dcn10_stereo_hw_frame_pack_wa(dc, context);
 
 	if (dc->debug.pplib_wm_report_mode == WM_REPORT_OVERRIDE)
 		dcn_bw_notify_pplib_of_wm_ranges(dc);

commit 77476360f173c127c191bfe8ca8113130ef283b8
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Wed Jan 23 13:50:17 2019 -0500

    drm/amd/display: Disconnect mpcc when changing tg
    
    [Why]
    This fixes an mpc programming error for the following sequence of
    atomic commits when pipe split is enabled:
    
    Commit 1: CRTC0 (plane 4, plane 3)
    
    Pipe 0: old_plane_state = A0, new_plane_state = A1,   new_tg = T0
    Pipe 1: old_plane_state = B0, new_plane_state = B1,   new_tg = T0
    Pipe 2: old_plane_state = A0, new_plane_state = A1,   new_tg = T0
    Pipe 3: old_plane_state = B0, new_plane_state = B1,   new_tg = T0
    
    Commit 2: CRTC0 (plane 3), CRTC1 (plane 2)
    
    Pipe 0: old_plane_state = A1, new_plane_state = A2,   new_tg = T0
    Pipe 1: old_plane_state = B1, new_plane_state = B2,   new_tg = T1
    Pipe 2: old_plane_state = A1, new_plane_state = NULL, new_tg = NULL
    Pipe 3: old_plane_state = B1, new_plane_state = NULL, new_tg = NULL
    
    In the second commit the assertion for mpcc in use is hit because
    mpcc disconnect never occurs for pipe 1. This is because the stream
    changes for pipe 1 and the opp_list is empty.
    
    This sequence occurs when running the
    "igt@kms_plane_multiple@atomic-pipe-A-tiling-none" test with two
    displays connected.
    
    [How]
    Expand the reset condition to include:
    
    "old_pipe_ctx->stream_res.tg != new_pipe_ctx->stream_res.tg"
    
    ...but only when the plane state is non-NULL for both old and new.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 9cde24dbdac8..9f23ea283838 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2334,9 +2334,10 @@ static void dcn10_apply_ctx_for_surface(
 			}
 		}
 
-		if (!pipe_ctx->plane_state &&
-			old_pipe_ctx->plane_state &&
-			old_pipe_ctx->stream_res.tg == tg) {
+		if ((!pipe_ctx->plane_state ||
+		     pipe_ctx->stream_res.tg != old_pipe_ctx->stream_res.tg) &&
+		    old_pipe_ctx->plane_state &&
+		    old_pipe_ctx->stream_res.tg == tg) {
 
 			dc->hwss.plane_atomic_disconnect(dc, old_pipe_ctx);
 			removed_pipe[i] = true;

commit b9708648766d8b15003a543ca36863e731b7b1ba
Author: Eryk Brol <eryk.brol@amd.com>
Date:   Fri Dec 7 10:25:13 2018 -0500

    drm/amd/display: Introduce DC VM interface
    
    Virtual memory allows display to support flipping to surfaces which
    are not allocated contiguously in memory with physical addresses,
    instead a 1-4 level page table is used.
    
    This is beneficial because it allows the scattering of large surfaces
    to improve memory efficiency and security.
    
    Signed-off-by: Eryk Brol <eryk.brol@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 814f5976ec9b..9cde24dbdac8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1202,7 +1202,8 @@ static void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_c
 	pipe_ctx->plane_res.hubp->funcs->hubp_program_surface_flip_and_addr(
 			pipe_ctx->plane_res.hubp,
 			&plane_state->address,
-			plane_state->flip_immediate);
+			plane_state->flip_immediate,
+			0);
 
 	plane_state->status.requested_address = plane_state->address;
 

commit f5c412ac596fbe1508514257fef3d48e263f40a7
Author: Roman Li <Roman.Li@amd.com>
Date:   Wed Dec 19 09:24:06 2018 -0500

    drm/amd/display: fix warning on raven hotplug
    
    [Why]
    Hotplug on raven results in REG_WAIT_TIMEOUT warning
    due to failing attempt to lock disabled otg for the hubp
    interdependent pipes programming.
    
    [How]
    Don't setup pipe interdependencies for disabled otg.
    Also removed the unnecessary duplicate logic checks.
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 91e015e14355..58a12ddf12f3 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2355,29 +2355,22 @@ static void dcn10_apply_ctx_for_surface(
 			top_pipe_to_program->plane_state->update_flags.bits.full_update)
 		for (i = 0; i < dc->res_pool->pipe_count; i++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-
+			tg = pipe_ctx->stream_res.tg;
 			/* Skip inactive pipes and ones already updated */
 			if (!pipe_ctx->stream || pipe_ctx->stream == stream
-					|| !pipe_ctx->plane_state)
+					|| !pipe_ctx->plane_state
+					|| !tg->funcs->is_tg_enabled(tg))
 				continue;
 
-			pipe_ctx->stream_res.tg->funcs->lock(pipe_ctx->stream_res.tg);
+			tg->funcs->lock(tg);
 
 			pipe_ctx->plane_res.hubp->funcs->hubp_setup_interdependent(
 				pipe_ctx->plane_res.hubp,
 				&pipe_ctx->dlg_regs,
 				&pipe_ctx->ttu_regs);
-		}
-
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		if (!pipe_ctx->stream || pipe_ctx->stream == stream
-				|| !pipe_ctx->plane_state)
-			continue;
-
-		dcn10_pipe_control_lock(dc, pipe_ctx, false);
-	}
+			tg->funcs->unlock(tg);
+		}
 
 	if (num_planes == 0)
 		false_optc_underflow_wa(dc, stream, tg);

commit 570744b98ca865d95bdf2da064a7a57f2655f889
Author: Roman Li <Roman.Li@amd.com>
Date:   Wed Dec 19 09:24:06 2018 -0500

    drm/amd/display: fix warning on raven hotplug
    
    [Why]
    Hotplug on raven results in REG_WAIT_TIMEOUT warning
    due to failing attempt to lock disabled otg for the hubp
    interdependent pipes programming.
    
    [How]
    Don't setup pipe interdependencies for disabled otg.
    Also removed the unnecessary duplicate logic checks.
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 93226fc37f27..814f5976ec9b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2354,29 +2354,22 @@ static void dcn10_apply_ctx_for_surface(
 			top_pipe_to_program->plane_state->update_flags.bits.full_update)
 		for (i = 0; i < dc->res_pool->pipe_count; i++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-
+			tg = pipe_ctx->stream_res.tg;
 			/* Skip inactive pipes and ones already updated */
 			if (!pipe_ctx->stream || pipe_ctx->stream == stream
-					|| !pipe_ctx->plane_state)
+					|| !pipe_ctx->plane_state
+					|| !tg->funcs->is_tg_enabled(tg))
 				continue;
 
-			pipe_ctx->stream_res.tg->funcs->lock(pipe_ctx->stream_res.tg);
+			tg->funcs->lock(tg);
 
 			pipe_ctx->plane_res.hubp->funcs->hubp_setup_interdependent(
 				pipe_ctx->plane_res.hubp,
 				&pipe_ctx->dlg_regs,
 				&pipe_ctx->ttu_regs);
-		}
-
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		if (!pipe_ctx->stream || pipe_ctx->stream == stream
-				|| !pipe_ctx->plane_state)
-			continue;
-
-		dcn10_pipe_control_lock(dc, pipe_ctx, false);
-	}
+			tg->funcs->unlock(tg);
+		}
 
 	if (num_planes == 0)
 		false_optc_underflow_wa(dc, stream, tg);

commit 785fd44c251c08c1490e20daec604f0f924dd7fc
Author: Shirish S <shirish.s@amd.com>
Date:   Thu Dec 20 16:08:02 2018 +0530

    drm/amd/display: fix compliler errors [-Werror,-Wmissing-braces]
    
    Initializing structures with { } is known to be problematic since
    it doesn't necessararily initialize all bytes, in case of padding,
    causing random failures when structures are memcmp().
    
    This patch fixes the structure initialisation related compiler
    error by memset.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index a5c4f95a677d..93226fc37f27 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -91,9 +91,10 @@ static void log_mpc_crc(struct dc *dc,
 void dcn10_log_hubbub_state(struct dc *dc, struct dc_log_buffer_ctx *log_ctx)
 {
 	struct dc_context *dc_ctx = dc->ctx;
-	struct dcn_hubbub_wm wm = {0};
+	struct dcn_hubbub_wm wm;
 	int i;
 
+	memset(&wm, 0, sizeof(struct dcn_hubbub_wm));
 	dc->res_pool->hubbub->funcs->wm_read_state(dc->res_pool->hubbub, &wm);
 
 	DTN_INFO("HUBBUB WM:      data_urgent  pte_meta_urgent"

commit 84d9d39aa166a8ea2c7687da48cdacdc0685644d
Author: Brajeswar Ghosh <brajeswar.linux@gmail.com>
Date:   Wed Dec 19 13:27:13 2018 +0530

    drm/amd/display: Remove duplicate header
    
    Remove custom_float.h which is included more than once
    
    Acked-by: Souptick Joarder <jrdr.linux@gmail.com>
    Signed-off-by: Brajeswar Ghosh <brajeswar.linux@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index afdfe3b0a1c3..a5c4f95a677d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -40,7 +40,6 @@
 #include "ipp.h"
 #include "mpc.h"
 #include "reg_helper.h"
-#include "custom_float.h"
 #include "dcn10_hubp.h"
 #include "dcn10_hubbub.h"
 #include "dcn10_cm_common.h"

commit 69338c1f4e97eac659db202c363aa2bfa4784347
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Sep 18 14:24:05 2018 -0400

    drm/amd/display: add dsclk to pipe bw struct
    
    This will allow us to program dscclk to required value
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 05c615228361..afdfe3b0a1c3 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2048,7 +2048,7 @@ void update_dchubp_dpp(
 			dc->res_pool->dccg->funcs->update_dpp_dto(
 					dc->res_pool->dccg,
 					dpp->inst,
-					pipe_ctx->plane_res.bw.calc.dppclk_khz);
+					pipe_ctx->plane_res.bw.dppclk_khz);
 		else
 			dc->res_pool->clk_mgr->clks.dppclk_khz = should_divided_by_2 ?
 						dc->res_pool->clk_mgr->clks.dispclk_khz / 2 :

commit 380604e27bc9c26ce64a83044aa1ea76ffd28caf
Author: Ken Chalmers <ken.chalmers@amd.com>
Date:   Tue Nov 6 14:24:12 2018 -0500

    drm/amd/display: Use 100 Hz precision for pipe pixel clocks
    
    [Why]
    Users would like more accurate pixel clocks, especially for fractional
    "TV" frame rates like 59.94 Hz.
    
    [How]
    Store and communicate pixel clocks with 100 Hz accuracy from
    dc_crtc_timing through to BIOS command table setpixelclock call.
    
    Signed-off-by: Ken Chalmers <ken.chalmers@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 613293d79bd7..05c615228361 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2655,7 +2655,7 @@ static void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 	struct dc_cursor_mi_param param = {
-		.pixel_clk_khz = pipe_ctx->stream->timing.pix_clk_khz,
+		.pixel_clk_khz = pipe_ctx->stream->timing.pix_clk_100hz / 10,
 		.ref_clk_khz = pipe_ctx->stream->ctx->dc->res_pool->ref_clock_inKhz,
 		.viewport = pipe_ctx->plane_res.scl_data.viewport,
 		.h_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.horz,

commit ceb3dbb4690db8377ad127a5666cd4775d9f70f4
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Fri Nov 9 09:21:21 2018 -0500

    drm/amd/display: remove sink reference in dc_stream_state
    
    [why]
    dc_stream_state containing a pointer to sink is poor design.
    Sink describes the display, and the specifications or capabilities
    it has.  That information is irrelevant for dc_stream_state, which describes
    hardware state, and is generally used for hardware programming.  It
    could further be argued that dc_sink itself is just a convenience dc
    provides, and DC should be perfectly capable of programming hardware
    without any dc_sinks (for example, emulated sinks).
    
    [how]
    Phase 1:
    Deprecate use of dc_sink pointer in dc_stream.  Most references are trivial
    to remove, but some call sites are risky (such as is_timing_changed) with
    no obvious logical replacement.  These will be removed in follow up change.
    
    Add dc_link pointer to dc_stream.  This is the typical reason DC really needed
    sink pointer, and most call sites are replaced with this.
    
    DMs also need minor updates, as all 3 DMs leverage stream->sink for
    some functionality.  this is replaced instead by a pointer to private data
    inside dc_stream_state, which is used by DMs as a quality of life improvment
    for some key functionality.  it allows DMs to set pointers have to their own objects
    which associate OS objects to dc_stream_states (such as DisplayTarget
    and amdgpu_dm_connector).  Without the private pointer, DMs would be
    forced to perform a lookup for callbacks.
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: David Francis <David.Francis@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 03835dcd28a2..613293d79bd7 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2524,7 +2524,7 @@ static void dcn10_config_stereo_parameters(
 			timing_3d_format == TIMING_3D_FORMAT_DP_HDMI_INBAND_FA ||
 			timing_3d_format == TIMING_3D_FORMAT_SIDEBAND_FA) {
 			enum display_dongle_type dongle = \
-					stream->sink->link->ddc->dongle_type;
+					stream->link->ddc->dongle_type;
 			if (dongle == DISPLAY_DONGLE_DP_VGA_CONVERTER ||
 				dongle == DISPLAY_DONGLE_DP_DVI_CONVERTER ||
 				dongle == DISPLAY_DONGLE_DP_HDMI_CONVERTER)

commit ebd084cd6509313307bc3b8fd9695f65aee8ff96
Author: Lewis Huang <Lewis.Huang@amd.com>
Date:   Fri Nov 16 19:12:46 2018 +0800

    drm/amd/display: add plane size change check condition
    
    [Why]
    Driver didn't check plane size and surface size is mismatch.
    It will cause pitch data incorrect.
    
    [How]
    Add condition to check is plane change and update surface
    
    Signed-off-by: Lewis Huang <Lewis.Huang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index edb382e1eaeb..03835dcd28a2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2125,7 +2125,8 @@ void update_dchubp_dpp(
 		plane_state->update_flags.bits.swizzle_change ||
 		plane_state->update_flags.bits.dcc_change ||
 		plane_state->update_flags.bits.bpp_change ||
-		plane_state->update_flags.bits.scaling_change) {
+		plane_state->update_flags.bits.scaling_change ||
+		plane_state->update_flags.bits.plane_size_change) {
 		hubp->funcs->hubp_program_surface_config(
 			hubp,
 			plane_state->format,

commit 630cb40ffd4a308e98c334cc9f01640a0ccb0aaa
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Nov 19 17:02:39 2018 -0500

    drm/amd/display: Remove some extra braces
    
    Remove braces around single-line conditionals
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f001eddd4180..edb382e1eaeb 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2252,13 +2252,11 @@ static void program_all_pipe_in_tree(
 
 	}
 
-	if (pipe_ctx->plane_state != NULL) {
+	if (pipe_ctx->plane_state != NULL)
 		dcn10_program_pipe(dc, pipe_ctx, context);
-	}
 
-	if (pipe_ctx->bottom_pipe != NULL && pipe_ctx->bottom_pipe != pipe_ctx) {
+	if (pipe_ctx->bottom_pipe != NULL && pipe_ctx->bottom_pipe != pipe_ctx)
 		program_all_pipe_in_tree(dc, pipe_ctx->bottom_pipe, context);
-	}
 }
 
 struct pipe_ctx *find_top_pipe_for_stream(

commit da1043cf22d3b9e652992e9d9a9372b90658ceb2
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Fri Nov 9 16:51:55 2018 -0500

    drm/amd/display: Fix runtime errors for diagnostic tests
    
    1) Rename and make public definition of input CSC matrix struct.
    2) Make wm_read_state() function an interface of hubbub, and check
       if watermark registers exist before read/write to them.
    3) Check if OTG_INTERLACE_CONTROL register exists before updating
    4) Add dummy functions for set_input/output_transfer function to avoid
       errors due to differences in CM registers.
    5) Added missing register field definition in header file
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 91e015e14355..f001eddd4180 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -95,7 +95,7 @@ void dcn10_log_hubbub_state(struct dc *dc, struct dc_log_buffer_ctx *log_ctx)
 	struct dcn_hubbub_wm wm = {0};
 	int i;
 
-	hubbub1_wm_read_state(dc->res_pool->hubbub, &wm);
+	dc->res_pool->hubbub->funcs->wm_read_state(dc->res_pool->hubbub, &wm);
 
 	DTN_INFO("HUBBUB WM:      data_urgent  pte_meta_urgent"
 			"         sr_enter          sr_exit  dram_clk_change\n");

commit 6fd3583b92318d6d8367cc3f325a81a222cdbc55
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Nov 19 16:25:23 2018 -0500

    drm/amd/display: fix surface update sequence
    
    An earlier change added update of interdependent dlg/ttu params for pipes
    not being updated in the current call. The code fails to check if the other
    pipes are actually active yet causing an assert.
    
    This change adds a check for surface presence on the pipes before updating
    the interdepenednt params.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e917bdce477a..91e015e14355 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2357,7 +2357,8 @@ static void dcn10_apply_ctx_for_surface(
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 			/* Skip inactive pipes and ones already updated */
-			if (!pipe_ctx->stream || pipe_ctx->stream == stream)
+			if (!pipe_ctx->stream || pipe_ctx->stream == stream
+					|| !pipe_ctx->plane_state)
 				continue;
 
 			pipe_ctx->stream_res.tg->funcs->lock(pipe_ctx->stream_res.tg);
@@ -2371,7 +2372,8 @@ static void dcn10_apply_ctx_for_surface(
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		if (!pipe_ctx->stream || pipe_ctx->stream == stream)
+		if (!pipe_ctx->stream || pipe_ctx->stream == stream
+				|| !pipe_ctx->plane_state)
 			continue;
 
 		dcn10_pipe_control_lock(dc, pipe_ctx, false);

commit 12750d1647f118496f1da727146f255f5e44d500
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Thu Nov 22 02:07:06 2018 -0500

    drm/amd/display: fix YCbCr420 blank color
    
    [Why]
    YCbCr420 packing format uses two chanels for luma, and 1
    channel for both chroma component. Our previous implementation
    did not account for this and results in every other pixel having
    very high luma value, showing greyish color instead of black.
    
    YCbCr444 = <Y1, Cb1, Cr1>; <Y2, Cb2, Cr2> .....
    YCbCr420 = <Y1, Y2,  Cb1>; <Y3, Y4,  Cr1> .....
    
    [How]
    Program the second channel with the black color value for luma
    as well.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Hugo Hu <Hugo.Hu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 0bd33a713836..e917bdce477a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2159,6 +2159,15 @@ static void dcn10_blank_pixel_data(
 	color_space = stream->output_color_space;
 	color_space_to_black_color(dc, color_space, &black_color);
 
+	/*
+	 * The way 420 is packed, 2 channels carry Y component, 1 channel
+	 * alternate between Cb and Cr, so both channels need the pixel
+	 * value for Y
+	 */
+	if (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)
+		black_color.color_r_cr = black_color.color_g_y;
+
+
 	if (stream_res->tg->funcs->set_blank_color)
 		stream_res->tg->funcs->set_blank_color(
 				stream_res->tg,

commit d9672a5bfbb506d3276403a309c5013b4fd7c56c
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Oct 31 16:51:40 2018 -0400

    drm/amd/display: expose surface confirm color function
    
    expose dcn10_get_surface_visual_confirm_color() to be used in the
    future
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 0dde7922ccba..0bd33a713836 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1771,7 +1771,7 @@ bool is_rgb_cspace(enum dc_color_space output_color_space)
 	}
 }
 
-static void dcn10_get_surface_visual_confirm_color(
+void dcn10_get_surface_visual_confirm_color(
 		const struct pipe_ctx *pipe_ctx,
 		struct tg_color *color)
 {
@@ -1807,7 +1807,7 @@ static void dcn10_get_surface_visual_confirm_color(
 	}
 }
 
-static void dcn10_get_hdr_visual_confirm_color(
+void dcn10_get_hdr_visual_confirm_color(
 		struct pipe_ctx *pipe_ctx,
 		struct tg_color *color)
 {

commit 1a1adf172f6a9747d5dd2d9236af28ccff8646a8
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Oct 31 07:59:54 2018 -0400

    drm/amd/display: fix pipe interdependent hubp programming
    
    A number of registers need to be updated for all active
    pipes wherever any pipe causes a change in watermarks.
    
    This change separates programming of these registers into
    a separate function call that is called for all active pipes
    during a bw update.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 84cfe709bdc2..0dde7922ccba 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2068,6 +2068,10 @@ void update_dchubp_dpp(
 			&pipe_ctx->ttu_regs,
 			&pipe_ctx->rq_regs,
 			&pipe_ctx->pipe_dlg_param);
+		hubp->funcs->hubp_setup_interdependent(
+			hubp,
+			&pipe_ctx->dlg_regs,
+			&pipe_ctx->ttu_regs);
 	}
 
 	size.grph.surface_size = pipe_ctx->plane_res.scl_data.viewport;
@@ -2338,6 +2342,32 @@ static void dcn10_apply_ctx_for_surface(
 
 	dcn10_pipe_control_lock(dc, top_pipe_to_program, false);
 
+	if (top_pipe_to_program->plane_state &&
+			top_pipe_to_program->plane_state->update_flags.bits.full_update)
+		for (i = 0; i < dc->res_pool->pipe_count; i++) {
+			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+			/* Skip inactive pipes and ones already updated */
+			if (!pipe_ctx->stream || pipe_ctx->stream == stream)
+				continue;
+
+			pipe_ctx->stream_res.tg->funcs->lock(pipe_ctx->stream_res.tg);
+
+			pipe_ctx->plane_res.hubp->funcs->hubp_setup_interdependent(
+				pipe_ctx->plane_res.hubp,
+				&pipe_ctx->dlg_regs,
+				&pipe_ctx->ttu_regs);
+		}
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (!pipe_ctx->stream || pipe_ctx->stream == stream)
+			continue;
+
+		dcn10_pipe_control_lock(dc, pipe_ctx, false);
+	}
+
 	if (num_planes == 0)
 		false_optc_underflow_wa(dc, stream, tg);
 

commit 8ce504b9389be846bcdf512ed5be8f661b3bf097
Author: Murton Liu <murton.liu@amd.com>
Date:   Wed Oct 17 14:47:45 2018 -0400

    drm/amd/display: fix gamma not being applied correctly
    
    [why]
    Gamma was always being set as identity on SDR monitor,
    leading to no changes in gamma. This caused nightlight to
    not apply correctly.
    
    [how]
    Added a default gamma structure to compare against
    in the sdr case.
    
    Signed-off-by: Murton Liu <murton.liu@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index a59b89b27583..84cfe709bdc2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1227,7 +1227,8 @@ static bool dcn10_set_input_transfer_func(struct pipe_ctx *pipe_ctx,
 		tf = plane_state->in_transfer_func;
 
 	if (plane_state->gamma_correction &&
-		!plane_state->gamma_correction->is_identity
+		!dpp_base->ctx->dc->debug.always_use_regamma
+		&& !plane_state->gamma_correction->is_identity
 			&& dce_use_lut(plane_state->format))
 		dpp_base->funcs->dpp_program_input_lut(dpp_base, plane_state->gamma_correction);
 

commit eb6b29d62841ec38665840af4c443fbef85bf2ec
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Tue Oct 23 12:12:50 2018 -0400

    drm/amd/display: make underflow status clear explicit
    
    [why]
    HUBP underflow is never cleared, which causes underflow in one
    test to fail another test, violating the independence requirements
    
    [how]
    Rather than make clearing implicit, we explicitly clear underflow
    status in DTN.
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 6b8a4da4f3c8..a59b89b27583 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2710,6 +2710,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.set_avmute = dce110_set_avmute,
 	.log_hw_state = dcn10_log_hw_state,
 	.get_hw_state = dcn10_get_hw_state,
+	.clear_status_bits = dcn10_clear_status_bits,
 	.wait_for_mpcc_disconnect = dcn10_wait_for_mpcc_disconnect,
 	.edp_backlight_control = hwss_edp_backlight_control,
 	.edp_power_control = hwss_edp_power_control,

commit 37cd85ce3322706d9d357ffbe54481fa884af9e5
Author: David Francis <David.Francis@amd.com>
Date:   Tue Oct 16 14:21:32 2018 -0400

    drm/amd/display: Remove dc_stream_state->status
    
    [Why]
    dc_state has an array of dc_stream_status that contain
    pointers to the dc_plane_state and other useful information
    
    Confusingly, dc_stream_state also contains a dc_stream_status
    called status.  This struct was partially initialized and
    used in a few places
    
    [How]
    stream->status.link has been replaced with stream->sink->link.
    If a stream does not have a sink, or a sink does not have a link,
    something has gone seriously wrong
    
    All other properties of stream->status were zeroed by kzalloc
    and never initialized, so they have been replaced by the number 0
    
    This is a refactor: no functional change is intended
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 87495dea45ec..6b8a4da4f3c8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1400,7 +1400,7 @@ static void dcn10_enable_per_frame_crtc_position_reset(
 		if (grouped_pipes[i]->stream_res.tg->funcs->enable_crtc_reset)
 			grouped_pipes[i]->stream_res.tg->funcs->enable_crtc_reset(
 					grouped_pipes[i]->stream_res.tg,
-					grouped_pipes[i]->stream->triggered_crtc_reset.event_source->status.primary_otg_inst,
+					0,
 					&grouped_pipes[i]->stream->triggered_crtc_reset);
 
 	DC_SYNC_INFO("Waiting for trigger\n");

commit 3917a470757cf55155663240481b1dda0206717b
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Fri Oct 12 17:31:58 2018 -0400

    drm/amd/display: Remove program_csc_matrix
    
    [Why] On DCN1/DCE, There are two functions programming OCSC:
    program_csc_matrix and program_output_csc. They do the same thing.
    
    [How] Consolidate to use only program_output_csc.
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e3e0fd449ad5..87495dea45ec 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1704,32 +1704,21 @@ static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 	pipe_ctx->plane_res.dpp->funcs->dpp_set_gamut_remap(pipe_ctx->plane_res.dpp, &adjust);
 }
 
-
-static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
+static void dcn10_program_output_csc(struct dc *dc,
+		struct pipe_ctx *pipe_ctx,
 		enum dc_color_space colorspace,
-		uint16_t *matrix)
+		uint16_t *matrix,
+		int opp_id)
 {
 	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment == true) {
-			if (pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment != NULL)
-				pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment(pipe_ctx->plane_res.dpp, matrix);
+		if (pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment != NULL)
+			pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment(pipe_ctx->plane_res.dpp, matrix);
 	} else {
 		if (pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_default != NULL)
 			pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_default(pipe_ctx->plane_res.dpp, colorspace);
 	}
 }
 
-static void dcn10_program_output_csc(struct dc *dc,
-		struct pipe_ctx *pipe_ctx,
-		enum dc_color_space colorspace,
-		uint16_t *matrix,
-		int opp_id)
-{
-	if (pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment != NULL)
-		program_csc_matrix(pipe_ctx,
-				colorspace,
-				matrix);
-}
-
 bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
 	if (pipe_ctx->plane_state->visible)
@@ -2684,7 +2673,6 @@ static void dcn10_set_cursor_sdr_white_level(struct pipe_ctx *pipe_ctx)
 
 static const struct hw_sequencer_funcs dcn10_funcs = {
 	.program_gamut_remap = program_gamut_remap,
-	.program_csc_matrix = program_csc_matrix,
 	.init_hw = dcn10_init_hw,
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
 	.apply_ctx_for_surface = dcn10_apply_ctx_for_surface,

commit a7d8084b589714ea08bddd3720986b657840f46b
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Mon Oct 15 16:40:38 2018 -0400

    drm/amd/display: Remove some old TODO's
    
    They are no longer relevant
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 345fc0302e4e..e3e0fd449ad5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1944,10 +1944,6 @@ static void dcn10_update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	struct mpc *mpc = dc->res_pool->mpc;
 	struct mpc_tree *mpc_tree_params = &(pipe_ctx->stream_res.opp->mpc_tree_params);
 
-
-
-	/* TODO: proper fix once fpga works */
-
 	if (dc->debug.visual_confirm == VISUAL_CONFIRM_HDR) {
 		dcn10_get_hdr_visual_confirm_color(
 				pipe_ctx, &blnd_cfg.black_color);
@@ -2027,8 +2023,6 @@ static void update_scaler(struct pipe_ctx *pipe_ctx)
 	bool per_pixel_alpha =
 			pipe_ctx->plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;
 
-	/* TODO: proper fix once fpga works */
-
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = per_pixel_alpha;
 	pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
 	/* scaler configuration */

commit 950227959b0e4bce5d1c9b93be15f977b530a717
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Oct 1 15:22:12 2018 -0400

    drm/amd/display: Check if hubp function hooks exist before calling them
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f88c440c2826..345fc0302e4e 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -787,7 +787,7 @@ static bool dcn10_hw_wa_force_recovery(struct dc *dc)
 			&dc->current_state->res_ctx.pipe_ctx[i];
 		if (pipe_ctx != NULL) {
 			hubp = pipe_ctx->plane_res.hubp;
-			if (hubp != NULL) {
+			if (hubp != NULL && hubp->funcs->hubp_get_underflow_status) {
 				if (hubp->funcs->hubp_get_underflow_status(hubp) != 0) {
 					/* one pipe underflow, we will reset all the pipes*/
 					need_recover = true;
@@ -813,7 +813,7 @@ static bool dcn10_hw_wa_force_recovery(struct dc *dc)
 		if (pipe_ctx != NULL) {
 			hubp = pipe_ctx->plane_res.hubp;
 			/*DCHUBP_CNTL:HUBP_BLANK_EN=1*/
-			if (hubp != NULL)
+			if (hubp != NULL && hubp->funcs->set_hubp_blank_en)
 				hubp->funcs->set_hubp_blank_en(hubp, true);
 		}
 	}
@@ -826,7 +826,7 @@ static bool dcn10_hw_wa_force_recovery(struct dc *dc)
 		if (pipe_ctx != NULL) {
 			hubp = pipe_ctx->plane_res.hubp;
 			/*DCHUBP_CNTL:HUBP_DISABLE=1*/
-			if (hubp != NULL)
+			if (hubp != NULL && hubp->funcs->hubp_disable_control)
 				hubp->funcs->hubp_disable_control(hubp, true);
 		}
 	}
@@ -836,7 +836,7 @@ static bool dcn10_hw_wa_force_recovery(struct dc *dc)
 		if (pipe_ctx != NULL) {
 			hubp = pipe_ctx->plane_res.hubp;
 			/*DCHUBP_CNTL:HUBP_DISABLE=0*/
-			if (hubp != NULL)
+			if (hubp != NULL && hubp->funcs->hubp_disable_control)
 				hubp->funcs->hubp_disable_control(hubp, true);
 		}
 	}
@@ -848,7 +848,7 @@ static bool dcn10_hw_wa_force_recovery(struct dc *dc)
 		if (pipe_ctx != NULL) {
 			hubp = pipe_ctx->plane_res.hubp;
 			/*DCHUBP_CNTL:HUBP_BLANK_EN=0*/
-			if (hubp != NULL)
+			if (hubp != NULL && hubp->funcs->set_hubp_blank_en)
 				hubp->funcs->set_hubp_blank_en(hubp, true);
 		}
 	}

commit ea2e8d923e2bcab51bbb3fcbdb96092d8d40270d
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Sep 28 08:42:52 2018 -0400

    drm/amd/display: add dccg block
    
    This adds the hw block as well as hooks up dppclk dto
    programming
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 5c4a4f68b8a0..f88c440c2826 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -45,6 +45,7 @@
 #include "dcn10_hubbub.h"
 #include "dcn10_cm_common.h"
 #include "dc_link_dp.h"
+#include "dccg.h"
 
 #define DC_LOGGER_INIT(logger)
 
@@ -2059,7 +2060,13 @@ void update_dchubp_dpp(
 				should_divided_by_2,
 				true);
 
-		dc->res_pool->clk_mgr->clks.dppclk_khz = should_divided_by_2 ?
+		if (dc->res_pool->dccg)
+			dc->res_pool->dccg->funcs->update_dpp_dto(
+					dc->res_pool->dccg,
+					dpp->inst,
+					pipe_ctx->plane_res.bw.calc.dppclk_khz);
+		else
+			dc->res_pool->clk_mgr->clks.dppclk_khz = should_divided_by_2 ?
 						dc->res_pool->clk_mgr->clks.dispclk_khz / 2 :
 							dc->res_pool->clk_mgr->clks.dispclk_khz;
 	}

commit 84e7fc05a92700297f1de945251fa3b14349532c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Sep 28 07:46:42 2018 -0400

    drm/amd/display: rename dccg to clk_mgr
    
    In preparation for adding the actual dccg block since the
    current implementation of dccg is mor eof a clock manager
    than a hw block
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d1f8c8e0b4c3..5c4a4f68b8a0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1126,7 +1126,7 @@ static void dcn10_init_hw(struct dc *dc)
 
 	enable_power_gating_plane(dc->hwseq, true);
 
-	memset(&dc->res_pool->dccg->clks, 0, sizeof(dc->res_pool->dccg->clks));
+	memset(&dc->res_pool->clk_mgr->clks, 0, sizeof(dc->res_pool->clk_mgr->clks));
 }
 
 static void reset_hw_ctx_wrap(
@@ -2052,16 +2052,16 @@ void update_dchubp_dpp(
 	 */
 	if (plane_state->update_flags.bits.full_update) {
 		bool should_divided_by_2 = context->bw.dcn.clk.dppclk_khz <=
-				dc->res_pool->dccg->clks.dispclk_khz / 2;
+				dc->res_pool->clk_mgr->clks.dispclk_khz / 2;
 
 		dpp->funcs->dpp_dppclk_control(
 				dpp,
 				should_divided_by_2,
 				true);
 
-		dc->res_pool->dccg->clks.dppclk_khz = should_divided_by_2 ?
-						dc->res_pool->dccg->clks.dispclk_khz / 2 :
-							dc->res_pool->dccg->clks.dispclk_khz;
+		dc->res_pool->clk_mgr->clks.dppclk_khz = should_divided_by_2 ?
+						dc->res_pool->clk_mgr->clks.dispclk_khz / 2 :
+							dc->res_pool->clk_mgr->clks.dispclk_khz;
 	}
 
 	/* TODO: Need input parameter to tell current DCHUB pipe tie to which OTG
@@ -2369,8 +2369,8 @@ static void dcn10_prepare_bandwidth(
 		if (context->stream_count == 0)
 			context->bw.dcn.clk.phyclk_khz = 0;
 
-		dc->res_pool->dccg->funcs->update_clocks(
-				dc->res_pool->dccg,
+		dc->res_pool->clk_mgr->funcs->update_clocks(
+				dc->res_pool->clk_mgr,
 				context,
 				false);
 	}
@@ -2398,8 +2398,8 @@ static void dcn10_optimize_bandwidth(
 		if (context->stream_count == 0)
 			context->bw.dcn.clk.phyclk_khz = 0;
 
-		dc->res_pool->dccg->funcs->update_clocks(
-				dc->res_pool->dccg,
+		dc->res_pool->clk_mgr->funcs->update_clocks(
+				dc->res_pool->clk_mgr,
 				context,
 				true);
 	}

commit 560a77f5f4019518ec14020f140e38141aeeb661
Author: Nevenko Stupar <Nevenko.Stupar@amd.com>
Date:   Tue Sep 25 18:18:33 2018 -0400

    drm/amd/display: expose hwseq functions and add registers
    
    Make these functions non static and define registers for future use
    
            is_lower_pipe_tree_visible();
            is_upper_pipe_tree_visible();
            is_pipe_tree_visible();
            dcn10_program_pte_vm();
            set_hdr_multiplier();
            update_dchubp_dpp()
            find_top_pipe_for_stream()
    
    Signed-off-by: Nevenko Stupar <Nevenko.Stupar@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 637524128176..d1f8c8e0b4c3 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1603,7 +1603,7 @@ static void mmhub_read_vm_context0_settings(struct dcn10_hubp *hubp1,
 }
 
 
-static void dcn10_program_pte_vm(struct dce_hwseq *hws, struct hubp *hubp)
+void dcn10_program_pte_vm(struct dce_hwseq *hws, struct hubp *hubp)
 {
 	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
 	struct vm_system_aperture_param apt = { {{ 0 } } };
@@ -1729,7 +1729,7 @@ static void dcn10_program_output_csc(struct dc *dc,
 				matrix);
 }
 
-static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
+bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
 	if (pipe_ctx->plane_state->visible)
 		return true;
@@ -1738,7 +1738,7 @@ static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 	return false;
 }
 
-static bool is_upper_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
+bool is_upper_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
 	if (pipe_ctx->plane_state->visible)
 		return true;
@@ -1747,7 +1747,7 @@ static bool is_upper_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 	return false;
 }
 
-static bool is_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
+bool is_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
 	if (pipe_ctx->plane_state->visible)
 		return true;
@@ -2035,7 +2035,7 @@ static void update_scaler(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data);
 }
 
-static void update_dchubp_dpp(
+void update_dchubp_dpp(
 	struct dc *dc,
 	struct pipe_ctx *pipe_ctx,
 	struct dc_state *context)
@@ -2182,7 +2182,7 @@ static void dcn10_blank_pixel_data(
 	}
 }
 
-static void set_hdr_multiplier(struct pipe_ctx *pipe_ctx)
+void set_hdr_multiplier(struct pipe_ctx *pipe_ctx)
 {
 	struct fixed31_32 multiplier = dc_fixpt_from_fraction(
 			pipe_ctx->plane_state->sdr_white_level, 80);
@@ -2257,7 +2257,7 @@ static void program_all_pipe_in_tree(
 	}
 }
 
-static struct pipe_ctx *find_top_pipe_for_stream(
+struct pipe_ctx *find_top_pipe_for_stream(
 		struct dc *dc,
 		struct dc_state *context,
 		const struct dc_stream_state *stream)

commit 9566b67586fb1d96c36207fd975087d68296755c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Sep 18 15:00:49 2018 -0400

    drm/amd/display: remove safe_to_lower flag from dc, use 2 functions instead
    
    This is done to keep things more readable, avoids a true/false flag
    in dc interface layer.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 4976230f78e4..637524128176 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2358,10 +2358,9 @@ static void dcn10_apply_ctx_for_surface(
 		hubbub1_wm_change_req_wa(dc->res_pool->hubbub);
 }
 
-static void dcn10_set_bandwidth(
+static void dcn10_prepare_bandwidth(
 		struct dc *dc,
-		struct dc_state *context,
-		bool safe_to_lower)
+		struct dc_state *context)
 {
 	if (dc->debug.sanity_checks)
 		dcn10_verify_allow_pstate_change_high(dc);
@@ -2373,7 +2372,36 @@ static void dcn10_set_bandwidth(
 		dc->res_pool->dccg->funcs->update_clocks(
 				dc->res_pool->dccg,
 				context,
-				safe_to_lower);
+				false);
+	}
+
+	hubbub1_program_watermarks(dc->res_pool->hubbub,
+			&context->bw.dcn.watermarks,
+			dc->res_pool->ref_clock_inKhz / 1000,
+			true);
+
+	if (dc->debug.pplib_wm_report_mode == WM_REPORT_OVERRIDE)
+		dcn_bw_notify_pplib_of_wm_ranges(dc);
+
+	if (dc->debug.sanity_checks)
+		dcn10_verify_allow_pstate_change_high(dc);
+}
+
+static void dcn10_optimize_bandwidth(
+		struct dc *dc,
+		struct dc_state *context)
+{
+	if (dc->debug.sanity_checks)
+		dcn10_verify_allow_pstate_change_high(dc);
+
+	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
+		if (context->stream_count == 0)
+			context->bw.dcn.clk.phyclk_khz = 0;
+
+		dc->res_pool->dccg->funcs->update_clocks(
+				dc->res_pool->dccg,
+				context,
+				true);
 	}
 
 	hubbub1_program_watermarks(dc->res_pool->hubbub,
@@ -2682,7 +2710,8 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.disable_plane = dcn10_disable_plane,
 	.blank_pixel_data = dcn10_blank_pixel_data,
 	.pipe_control_lock = dcn10_pipe_control_lock,
-	.set_bandwidth = dcn10_set_bandwidth,
+	.prepare_bandwidth = dcn10_prepare_bandwidth,
+	.optimize_bandwidth = dcn10_optimize_bandwidth,
 	.reset_hw_ctx_wrap = reset_hw_ctx_wrap,
 	.enable_stream_timing = dcn10_enable_stream_timing,
 	.set_drr = set_drr,

commit 24f7dd7ea98dc54fa45a0dd10c7a472e00ca01d4
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Sep 13 17:42:14 2018 -0400

    drm/amd/display: move pplib/smu notification to dccg block
    
    This is done to clear up the clock programming sequence
    since the only time we need to notify pplib is after
    clock update.
    
    This also renames the clk block to dccg, at the moment
    this block contains both clock management and dccg
    functionality.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 193184affefb..4976230f78e4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2257,46 +2257,6 @@ static void program_all_pipe_in_tree(
 	}
 }
 
-static void dcn10_pplib_apply_display_requirements(
-	struct dc *dc,
-	struct dc_state *context)
-{
-	struct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;
-
-	pp_display_cfg->min_engine_clock_khz = dc->res_pool->dccg->clks.dcfclk_khz;
-	pp_display_cfg->min_memory_clock_khz = dc->res_pool->dccg->clks.fclk_khz;
-	pp_display_cfg->min_engine_clock_deep_sleep_khz = dc->res_pool->dccg->clks.dcfclk_deep_sleep_khz;
-	pp_display_cfg->min_dcfc_deep_sleep_clock_khz = dc->res_pool->dccg->clks.dcfclk_deep_sleep_khz;
-	pp_display_cfg->min_dcfclock_khz = dc->res_pool->dccg->clks.dcfclk_khz;
-	pp_display_cfg->disp_clk_khz = dc->res_pool->dccg->clks.dispclk_khz;
-	dce110_fill_display_configs(context, pp_display_cfg);
-
-	if (memcmp(&dc->prev_display_config, pp_display_cfg, sizeof(
-			struct dm_pp_display_configuration)) !=  0)
-		dm_pp_apply_display_requirements(dc->ctx, pp_display_cfg);
-
-	dc->prev_display_config = *pp_display_cfg;
-}
-
-static void optimize_shared_resources(struct dc *dc)
-{
-	if (dc->current_state->stream_count == 0) {
-		/* S0i2 message */
-		dcn10_pplib_apply_display_requirements(dc, dc->current_state);
-	}
-
-	if (dc->debug.pplib_wm_report_mode == WM_REPORT_OVERRIDE)
-		dcn_bw_notify_pplib_of_wm_ranges(dc);
-}
-
-static void ready_shared_resources(struct dc *dc, struct dc_state *context)
-{
-	/* S0i2 message */
-	if (dc->current_state->stream_count == 0 &&
-			context->stream_count != 0)
-		dcn10_pplib_apply_display_requirements(dc, context);
-}
-
 static struct pipe_ctx *find_top_pipe_for_stream(
 		struct dc *dc,
 		struct dc_state *context,
@@ -2412,10 +2372,8 @@ static void dcn10_set_bandwidth(
 
 		dc->res_pool->dccg->funcs->update_clocks(
 				dc->res_pool->dccg,
-				&context->bw.dcn.clk,
+				context,
 				safe_to_lower);
-
-		dcn10_pplib_apply_display_requirements(dc, context);
 	}
 
 	hubbub1_program_watermarks(dc->res_pool->hubbub,
@@ -2423,6 +2381,9 @@ static void dcn10_set_bandwidth(
 			dc->res_pool->ref_clock_inKhz / 1000,
 			true);
 
+	if (dc->debug.pplib_wm_report_mode == WM_REPORT_OVERRIDE)
+		dcn_bw_notify_pplib_of_wm_ranges(dc);
+
 	if (dc->debug.sanity_checks)
 		dcn10_verify_allow_pstate_change_high(dc);
 }
@@ -2732,10 +2693,6 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.log_hw_state = dcn10_log_hw_state,
 	.get_hw_state = dcn10_get_hw_state,
 	.wait_for_mpcc_disconnect = dcn10_wait_for_mpcc_disconnect,
-	.ready_shared_resources = ready_shared_resources,
-	.optimize_shared_resources = optimize_shared_resources,
-	.pplib_apply_display_requirements =
-			dcn10_pplib_apply_display_requirements,
 	.edp_backlight_control = hwss_edp_backlight_control,
 	.edp_power_control = hwss_edp_power_control,
 	.edp_wait_for_hpd_ready = hwss_edp_wait_for_hpd_ready,

commit ceb9831dd6e5dfb79f94b205eade4ecc29e26d60
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Sep 17 10:05:51 2018 -0400

    drm/amd/display: WA for DF keeps awake after S0i3.
    
    [Why]
    DF keeps awake after S0i3 resume due to DRAM_STATE_CNTL
    is set by bios command table during dcn init_hw.
    
    [How]
    As a work around, check STATE_CNTL status before init_hw,
    if it is 0 before init_hw and set to 1 after init_hw,
    change it to 0.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index a881ff5559ec..193184affefb 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -997,7 +997,21 @@ static void dcn10_init_hw(struct dc *dc)
 	} else {
 
 		if (!dcb->funcs->is_accelerated_mode(dcb)) {
+			bool allow_self_fresh_force_enable =
+					hububu1_is_allow_self_refresh_enabled(dc->res_pool->hubbub);
+
 			bios_golden_init(dc);
+
+			/* WA for making DF sleep when idle after resume from S0i3.
+			 * DCHUBBUB_ARB_ALLOW_SELF_REFRESH_FORCE_ENABLE is set to 1 by
+			 * command table, if DCHUBBUB_ARB_ALLOW_SELF_REFRESH_FORCE_ENABLE = 0
+			 * before calling command table and it changed to 1 after,
+			 * it should be set back to 0.
+			 */
+			if (allow_self_fresh_force_enable == false &&
+					hububu1_is_allow_self_refresh_enabled(dc->res_pool->hubbub))
+				hubbub1_disable_allow_self_refresh(dc->res_pool->hubbub);
+
 			disable_vga(dc->hwseq);
 		}
 

commit aa9c4abe466ac7cd4ab8e1d81b959c3d51173745
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Thu Aug 16 14:27:11 2018 -0400

    drm/amd/display: Refactor FPGA-specific link setup
    
    FPGA doesn't program backend, so we don't need certain link settings
    (audio stream for example).
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 6bd4ec39f869..a881ff5559ec 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -44,6 +44,7 @@
 #include "dcn10_hubp.h"
 #include "dcn10_hubbub.h"
 #include "dcn10_cm_common.h"
+#include "dc_link_dp.h"
 
 #define DC_LOGGER_INIT(logger)
 

commit 46659a83e4662ed92000ec13445b8c0ca96fd2cc
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Wed Aug 15 12:00:23 2018 -0400

    drm/amd/display: Support reading hw state from debugfs file
    
    [Why]
    
    Logging hardware state can be done by triggering a write to the
    debugfs file. It would also be useful to be able to read the hardware
    state from the debugfs file to be able to generate a clean log without
    timestamps.
    
    [How]
    
    Usage: cat /sys/kernel/debug/dri/0/amdgpu_dm_dtn_log
    
    Threading is an obvious concern when dealing with multiple debugfs
    operations and blocking on global state in dm or dc seems unfavorable.
    
    Adding an extra parameter for the debugfs log context state is the
    implementation done here. Existing code that made use of DTN_INFO
    and its associated macros needed to be refactored to support this.
    
    We don't know the size of the log in advance so it reallocates the
    log string dynamically. Once the log has been generated it's copied
    into the user supplied buffer for the debugfs. This allows for seeking
    support but it's worth nothing that unlike triggering output via
    dmesg the hardware state might change in-between reads if your buffer
    size is too small.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 1c5bb148efb7..6bd4ec39f869 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -58,9 +58,11 @@
 
 /*print is 17 wide, first two characters are spaces*/
 #define DTN_INFO_MICRO_SEC(ref_cycle) \
-	print_microsec(dc_ctx, ref_cycle)
+	print_microsec(dc_ctx, log_ctx, ref_cycle)
 
-void print_microsec(struct dc_context *dc_ctx, uint32_t ref_cycle)
+void print_microsec(struct dc_context *dc_ctx,
+	struct dc_log_buffer_ctx *log_ctx,
+	uint32_t ref_cycle)
 {
 	const uint32_t ref_clk_mhz = dc_ctx->dc->res_pool->ref_clock_inKhz / 1000;
 	static const unsigned int frac = 1000;
@@ -71,7 +73,8 @@ void print_microsec(struct dc_context *dc_ctx, uint32_t ref_cycle)
 			us_x10 % frac);
 }
 
-static void log_mpc_crc(struct dc *dc)
+static void log_mpc_crc(struct dc *dc,
+	struct dc_log_buffer_ctx *log_ctx)
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	struct dce_hwseq *hws = dc->hwseq;
@@ -84,7 +87,7 @@ static void log_mpc_crc(struct dc *dc)
 		REG_READ(DPP_TOP0_DPP_CRC_VAL_B_A), REG_READ(DPP_TOP0_DPP_CRC_VAL_R_G));
 }
 
-void dcn10_log_hubbub_state(struct dc *dc)
+void dcn10_log_hubbub_state(struct dc *dc, struct dc_log_buffer_ctx *log_ctx)
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	struct dcn_hubbub_wm wm = {0};
@@ -111,7 +114,7 @@ void dcn10_log_hubbub_state(struct dc *dc)
 	DTN_INFO("\n");
 }
 
-static void dcn10_log_hubp_states(struct dc *dc)
+static void dcn10_log_hubp_states(struct dc *dc, void *log_ctx)
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	struct resource_pool *pool = dc->res_pool;
@@ -226,7 +229,8 @@ static void dcn10_log_hubp_states(struct dc *dc)
 	DTN_INFO("\n");
 }
 
-void dcn10_log_hw_state(struct dc *dc)
+void dcn10_log_hw_state(struct dc *dc,
+	struct dc_log_buffer_ctx *log_ctx)
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	struct resource_pool *pool = dc->res_pool;
@@ -234,9 +238,9 @@ void dcn10_log_hw_state(struct dc *dc)
 
 	DTN_INFO_BEGIN();
 
-	dcn10_log_hubbub_state(dc);
+	dcn10_log_hubbub_state(dc, log_ctx);
 
-	dcn10_log_hubp_states(dc);
+	dcn10_log_hubp_states(dc, log_ctx);
 
 	DTN_INFO("DPP:    IGAM format  IGAM mode    DGAM mode    RGAM mode"
 			"  GAMUT mode  C11 C12   C13 C14   C21 C22   C23 C24   "
@@ -347,7 +351,7 @@ void dcn10_log_hw_state(struct dc *dc)
 			dc->current_state->bw.dcn.clk.fclk_khz,
 			dc->current_state->bw.dcn.clk.socclk_khz);
 
-	log_mpc_crc(dc);
+	log_mpc_crc(dc, log_ctx);
 
 	DTN_INFO_END();
 }
@@ -857,7 +861,7 @@ void dcn10_verify_allow_pstate_change_high(struct dc *dc)
 
 	if (!hubbub1_verify_allow_pstate_change_high(dc->res_pool->hubbub)) {
 		if (should_log_hw_state) {
-			dcn10_log_hw_state(dc);
+			dcn10_log_hw_state(dc, NULL);
 		}
 		BREAK_TO_DEBUGGER();
 		if (dcn10_hw_wa_force_recovery(dc)) {

commit 35fb7220742b80dadd7218448b4bee5b190c9f07
Author: Wen Yang <wen.yang99@zte.com.cn>
Date:   Fri Aug 17 11:09:48 2018 +0800

    drm/amd/display: fix a compile warning
    
    Fix comile warning like,
      CC [M]  drivers/gpu/drm/i915/gvt/execlist.o
      CC [M]  drivers/gpu/drm/nouveau/nvkm/subdev/instmem/nv50.o
      CC [M]  drivers/gpu/drm/radeon/btc_dpm.o
      CC [M]  drivers/isdn/hisax/avm_a1p.o
      CC [M]  drivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_dpp.o
    drivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_hw_sequencer.c: In function dcn10_update_mpcc:
    drivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_hw_sequencer.c:1903:9: warning: missing braces around initializer [-Wmissing-braces]
      struct mpcc_blnd_cfg blnd_cfg = {0};
             ^
    drivers/gpu/drm/amd/amdgpu/../display/dc/dcn10/dcn10_hw_sequencer.c:1903:9: warning: (near initialization for blnd_cfg.black_color) [-Wmissing-braces]
    
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Wen Yang <wen.yang99@zte.com.cn>
    Reviewed-by: Jiang Biao <jiang.biao2@zte.com.cn>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 051f427868ca..1c5bb148efb7 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1917,7 +1917,7 @@ static void update_dpp(struct dpp *dpp, struct dc_plane_state *plane_state)
 static void dcn10_update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
-	struct mpcc_blnd_cfg blnd_cfg = {0};
+	struct mpcc_blnd_cfg blnd_cfg = {{0}};
 	bool per_pixel_alpha = pipe_ctx->plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;
 	int mpcc_id;
 	struct mpcc *new_mpcc;

commit dd73043534515c1b8bf31f78f0e9945f5d95e0e6
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Wed Aug 8 11:53:39 2018 -0400

    drm/amd/display: implement DPMS DTN test v2
    
    [why]
    Existing DTN infrastructure in driver is hacky.  It uses implicit log
    names, and also incorrect escape ID.
    
    [how]
    - Implement using generic DTN escape ID.
    - Move file logging functionality from driver to to script; driver now outputs to string/buffer
    - Move HWSS debug functionality to separate c file
    - Add debug functionalty for per-block logging as CSV
    - Add pretty print in python
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 4b8bedb625b4..051f427868ca 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -71,7 +71,6 @@ void print_microsec(struct dc_context *dc_ctx, uint32_t ref_cycle)
 			us_x10 % frac);
 }
 
-
 static void log_mpc_crc(struct dc *dc)
 {
 	struct dc_context *dc_ctx = dc->ctx;
@@ -2712,6 +2711,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.setup_stereo = dcn10_setup_stereo,
 	.set_avmute = dce110_set_avmute,
 	.log_hw_state = dcn10_log_hw_state,
+	.get_hw_state = dcn10_get_hw_state,
 	.wait_for_mpcc_disconnect = dcn10_wait_for_mpcc_disconnect,
 	.ready_shared_resources = ready_shared_resources,
 	.optimize_shared_resources = optimize_shared_resources,

commit 98e6436d3af5fef7ca9b59d865dd5807ede36fb9
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Aug 21 14:40:28 2018 -0500

    drm/amd/display: Refactor FreeSync module
    
    Remove dependency on internal sink map and instead
    use existing stream and plane state
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 6d27f1db3c69..4b8bedb625b4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -631,6 +631,8 @@ static enum dc_status dcn10_enable_stream_timing(
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	enum dc_color_space color_space;
 	struct tg_color black_color = {0};
+	struct drr_params params = {0};
+	unsigned int event_triggers = 0;
 
 	/* by upper caller loop, pipe0 is parent pipe and be called first.
 	 * back end is set up by for pipe0. Other children pipe share back end
@@ -698,6 +700,19 @@ static enum dc_status dcn10_enable_stream_timing(
 		return DC_ERROR_UNEXPECTED;
 	}
 
+	params.vertical_total_min = stream->adjust.v_total_min;
+	params.vertical_total_max = stream->adjust.v_total_max;
+	if (pipe_ctx->stream_res.tg->funcs->set_drr)
+		pipe_ctx->stream_res.tg->funcs->set_drr(
+			pipe_ctx->stream_res.tg, &params);
+
+	// DRR should set trigger event to monitor surface update event
+	if (stream->adjust.v_total_min != 0 && stream->adjust.v_total_max != 0)
+		event_triggers = 0x80;
+	if (pipe_ctx->stream_res.tg->funcs->set_static_screen_control)
+		pipe_ctx->stream_res.tg->funcs->set_static_screen_control(
+				pipe_ctx->stream_res.tg, event_triggers);
+
 	/* TODO program crtc source select for non-virtual signal*/
 	/* TODO program FMT */
 	/* TODO setup link_enc */
@@ -2399,15 +2414,23 @@ static void set_drr(struct pipe_ctx **pipe_ctx,
 {
 	int i = 0;
 	struct drr_params params = {0};
+	// DRR should set trigger event to monitor surface update event
+	unsigned int event_triggers = 0x80;
 
 	params.vertical_total_max = vmax;
 	params.vertical_total_min = vmin;
 
 	/* TODO: If multiple pipes are to be supported, you need
-	 * some GSL stuff
+	 * some GSL stuff. Static screen triggers may be programmed differently
+	 * as well.
 	 */
 	for (i = 0; i < num_pipes; i++) {
-		pipe_ctx[i]->stream_res.tg->funcs->set_drr(pipe_ctx[i]->stream_res.tg, &params);
+		pipe_ctx[i]->stream_res.tg->funcs->set_drr(
+			pipe_ctx[i]->stream_res.tg, &params);
+		if (vmax != 0 && vmin != 0)
+			pipe_ctx[i]->stream_res.tg->funcs->set_static_screen_control(
+					pipe_ctx[i]->stream_res.tg,
+					event_triggers);
 	}
 }
 

commit 94a4ffd1d40b845dd19f9fdbb2cb6bf32de0946b
Author: Gloria Li <geling.li@amd.com>
Date:   Thu Jul 26 11:32:14 2018 -0400

    drm/amd/display: fix PIP bugs on Dal3
    
    [Why]
    There are outstanding bugs for PIP in Dal3:
    -Crash when toggling PIP visibility
    -Global Alpha is not working, Adjusting global alpha
     doesnt have an effect
    -Cursor is not working with pip plane and pipe splits
    -One flash occurs when cursor enters PIP plane from
     top/bottom
    -Crash when moving PIP plane off the screen
    
    [How]
    Resolve divide by 0 error
    Implement global alpha
    Program cursor on all pipes
    Add dst rects' x and y offests into cursor position
    Disable cursor when it is beyond bottom/top edge
    
    Signed-off-by: Gloria Li <geling.li@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index cfd93557c428..6d27f1db3c69 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1932,9 +1932,13 @@ static void dcn10_update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
 		blnd_cfg.alpha_mode = MPCC_ALPHA_BLEND_MODE_GLOBAL_ALPHA;
 
 	blnd_cfg.overlap_only = false;
-	blnd_cfg.global_alpha = 0xff;
 	blnd_cfg.global_gain = 0xff;
 
+	if (pipe_ctx->plane_state->global_alpha)
+		blnd_cfg.global_alpha = pipe_ctx->plane_state->global_alpha_value;
+	else
+		blnd_cfg.global_alpha = 0xff;
+
 	/* DCN1.0 has output CM before MPC which seems to screw with
 	 * pre-multiplied alpha.
 	 */
@@ -2049,11 +2053,13 @@ static void update_dchubp_dpp(
 		update_dpp(dpp, plane_state);
 
 	if (plane_state->update_flags.bits.full_update ||
-		plane_state->update_flags.bits.per_pixel_alpha_change)
+		plane_state->update_flags.bits.per_pixel_alpha_change ||
+		plane_state->update_flags.bits.global_alpha_change)
 		dc->hwss.update_mpcc(dc, pipe_ctx);
 
 	if (plane_state->update_flags.bits.full_update ||
 		plane_state->update_flags.bits.per_pixel_alpha_change ||
+		plane_state->update_flags.bits.global_alpha_change ||
 		plane_state->update_flags.bits.scaling_change ||
 		plane_state->update_flags.bits.position_change) {
 		update_scaler(pipe_ctx);
@@ -2597,15 +2603,15 @@ static void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 		.mirror = pipe_ctx->plane_state->horizontal_mirror
 	};
 
+	pos_cpy.x -= pipe_ctx->plane_state->dst_rect.x;
+	pos_cpy.y -= pipe_ctx->plane_state->dst_rect.y;
+
 	if (pipe_ctx->plane_state->address.type
 			== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)
 		pos_cpy.enable = false;
 
-	if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
-		pos_cpy.enable = false;
-
 	hubp->funcs->set_cursor_position(hubp, &pos_cpy, &param);
-	dpp->funcs->set_cursor_position(dpp, &pos_cpy, &param, hubp->curs_attr.width);
+	dpp->funcs->set_cursor_position(dpp, &pos_cpy, &param, hubp->curs_attr.width, hubp->curs_attr.height);
 }
 
 static void dcn10_set_cursor_attribute(struct pipe_ctx *pipe_ctx)

commit d02e07948fcff46a7a48f8747260941d7290774b
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Thu Jul 19 14:03:14 2018 -0400

    drm/amd/display: Print DPP DTN log info only for enabled pipes
    
    [why]
    There is currently a dependency on the order in which tests are executed.
    This is because the non-relevant state info is being printed, which results
    in the output based on the state from the previous test.
    
    [how]
    Print DPP DTN log only if the pipe is enabled.
    In addition to the affected per-submission DTN golden logs, included in this
    change is also DTN golden log update for pre-submission tests.
    The other DTN golden logs affected by this change will be updated upon
    nightly test run (which will generate the updated DTN logs).
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 41f6595891f1..cfd93557c428 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -88,7 +88,7 @@ static void log_mpc_crc(struct dc *dc)
 void dcn10_log_hubbub_state(struct dc *dc)
 {
 	struct dc_context *dc_ctx = dc->ctx;
-	struct dcn_hubbub_wm wm;
+	struct dcn_hubbub_wm wm = {0};
 	int i;
 
 	hubbub1_wm_read_state(dc->res_pool->hubbub, &wm);
@@ -244,10 +244,13 @@ void dcn10_log_hw_state(struct dc *dc)
 			"C31 C32   C33 C34\n");
 	for (i = 0; i < pool->pipe_count; i++) {
 		struct dpp *dpp = pool->dpps[i];
-		struct dcn_dpp_state s;
+		struct dcn_dpp_state s = {0};
 
 		dpp->funcs->dpp_read_state(dpp, &s);
 
+		if (!s.is_enabled)
+			continue;
+
 		DTN_INFO("[%2d]:  %11xh  %-11s  %-11s  %-11s"
 				"%8x    %08xh %08xh %08xh %08xh %08xh %08xh",
 				dpp->inst,

commit a465feae60dc615d0e363ea5809b95a433b259d4
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Jul 16 14:05:11 2018 -0400

    drm/amd/display: pass compat_level to hubp
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index cfcc54f2ce65..41f6595891f1 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2004,6 +2004,7 @@ static void update_dchubp_dpp(
 	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	union plane_size size = plane_state->plane_size;
+	unsigned int compat_level = 0;
 
 	/* depends on DML calculation, DPP clock value may change dynamically */
 	/* If request max dpp clk is lower than current dispclk, no need to
@@ -2095,7 +2096,8 @@ static void update_dchubp_dpp(
 			&size,
 			plane_state->rotation,
 			&plane_state->dcc,
-			plane_state->horizontal_mirror);
+			plane_state->horizontal_mirror,
+			compat_level);
 	}
 
 	hubp->power_gated = false;

commit 99326ee3624b90d176a8f7e2aa3d15dfaa59c8f1
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Jul 26 12:17:58 2018 -0400

    drm/amd/display: program display clock on cache match
    
    [Why]
    We seem to have an issue where high enough display clock
    will not get set properly during S3 resume if we only
    call vbios once
    
    [How]
    Expand condition of display clock programming to happen
    even when cached display clock matches requested display
    clock
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f5d8242eb047..cfcc54f2ce65 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1089,6 +1089,8 @@ static void dcn10_init_hw(struct dc *dc)
 	}
 
 	enable_power_gating_plane(dc->hwseq, true);
+
+	memset(&dc->res_pool->dccg->clks, 0, sizeof(dc->res_pool->dccg->clks));
 }
 
 static void reset_hw_ctx_wrap(

commit 78e4405cec6cb0780b27b222685dde33934b38e4
Author: David Francis <David.Francis@amd.com>
Date:   Thu Jul 12 15:46:41 2018 -0400

    drm/amd/display: Implement custom degamma lut on dcn
    
    [Why]
    Custom degamma lut functions are a feature we would
    like to support on compatible hardware
    
    [How]
    In atomic check, convert from array of drm_color_lut to
    dc_transfer_func.  On hardware commit, allow for possibility
    of custom degamma.  Both are based on the equivalent
    regamma pipeline.
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c87f6e603055..f5d8242eb047 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1213,8 +1213,11 @@ static bool dcn10_set_input_transfer_func(struct pipe_ctx *pipe_ctx,
 	} else if (tf->type == TF_TYPE_BYPASS) {
 		dpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);
 	} else {
-		/*TF_TYPE_DISTRIBUTED_POINTS*/
-		result = false;
+		cm_helper_translate_curve_to_degamma_hw_format(tf,
+					&dpp_base->degamma_params);
+		dpp_base->funcs->dpp_program_degamma_pwl(dpp_base,
+				&dpp_base->degamma_params);
+		result = true;
 	}
 
 	return result;

commit 68199bd16cb56d121ade83918d5858933d07ae8a
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Sat Jul 7 15:43:07 2018 -0400

    drm/amd/display: Move address tracking out of HUBP
    
    [Why]
    We sometime require remapping of FB address space to UMA
    
    [How]
    Move address tracking up a layer before we apply address translation
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index ade74c821831..c87f6e603055 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1157,12 +1157,19 @@ static void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_c
 
 	if (plane_state == NULL)
 		return;
+
 	addr_patched = patch_address_for_sbs_tb_stereo(pipe_ctx, &addr);
+
 	pipe_ctx->plane_res.hubp->funcs->hubp_program_surface_flip_and_addr(
 			pipe_ctx->plane_res.hubp,
 			&plane_state->address,
 			plane_state->flip_immediate);
+
 	plane_state->status.requested_address = plane_state->address;
+
+	if (plane_state->flip_immediate)
+		plane_state->status.current_address = plane_state->address;
+
 	if (addr_patched)
 		pipe_ctx->plane_state->address.grph_stereo.left_addr = addr;
 }
@@ -2533,16 +2540,20 @@ static void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct timing_generator *tg = pipe_ctx->stream_res.tg;
+	bool flip_pending;
 
 	if (plane_state == NULL)
 		return;
 
-	plane_state->status.is_flip_pending =
-			pipe_ctx->plane_res.hubp->funcs->hubp_is_flip_pending(
+	flip_pending = pipe_ctx->plane_res.hubp->funcs->hubp_is_flip_pending(
 					pipe_ctx->plane_res.hubp);
 
-	plane_state->status.current_address = pipe_ctx->plane_res.hubp->current_address;
-	if (pipe_ctx->plane_res.hubp->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
+	plane_state->status.is_flip_pending = flip_pending;
+
+	if (!flip_pending)
+		plane_state->status.current_address = plane_state->status.requested_address;
+
+	if (plane_state->status.current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 			tg->funcs->is_stereo_left_eye) {
 		plane_state->status.is_right_eye =
 				!tg->funcs->is_stereo_left_eye(pipe_ctx->stream_res.tg);

commit bf53769d9fc95c89d2f1588463c268c3af987748
Author: Gloria Li <geling.li@amd.com>
Date:   Tue Jul 3 14:39:22 2018 -0400

    drm/amd/display: add HDR visual confirm
    
    [Why]
    Testing team wants a way to tell if HDR is on or not
    
    [How]
    Program the overscan color to visually indicate the HDR state of the top-most plane
    
    Signed-off-by: Gloria Li <geling.li@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 6e8127cb2e56..ade74c821831 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1768,6 +1768,43 @@ static void dcn10_get_surface_visual_confirm_color(
 	}
 }
 
+static void dcn10_get_hdr_visual_confirm_color(
+		struct pipe_ctx *pipe_ctx,
+		struct tg_color *color)
+{
+	uint32_t color_value = MAX_TG_COLOR_VALUE;
+
+	// Determine the overscan color based on the top-most (desktop) plane's context
+	struct pipe_ctx *top_pipe_ctx  = pipe_ctx;
+
+	while (top_pipe_ctx->top_pipe != NULL)
+		top_pipe_ctx = top_pipe_ctx->top_pipe;
+
+	switch (top_pipe_ctx->plane_res.scl_data.format) {
+	case PIXEL_FORMAT_ARGB2101010:
+		if (top_pipe_ctx->stream->out_transfer_func->tf == TRANSFER_FUNCTION_UNITY) {
+			/* HDR10, ARGB2101010 - set boarder color to red */
+			color->color_r_cr = color_value;
+		}
+		break;
+	case PIXEL_FORMAT_FP16:
+		if (top_pipe_ctx->stream->out_transfer_func->tf == TRANSFER_FUNCTION_PQ) {
+			/* HDR10, FP16 - set boarder color to blue */
+			color->color_b_cb = color_value;
+		} else if (top_pipe_ctx->stream->out_transfer_func->tf == TRANSFER_FUNCTION_GAMMA22) {
+			/* FreeSync 2 HDR - set boarder color to green */
+			color->color_g_y = color_value;
+		}
+		break;
+	default:
+		/* SDR - set boarder color to Gray */
+		color->color_r_cr = color_value/2;
+		color->color_b_cb = color_value/2;
+		color->color_g_y = color_value/2;
+		break;
+	}
+}
+
 static uint16_t fixed_point_to_int_frac(
 	struct fixed31_32 arg,
 	uint8_t integer_bits,
@@ -1862,13 +1899,17 @@ static void dcn10_update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
 
 	/* TODO: proper fix once fpga works */
 
-	if (dc->debug.surface_visual_confirm)
+	if (dc->debug.visual_confirm == VISUAL_CONFIRM_HDR) {
+		dcn10_get_hdr_visual_confirm_color(
+				pipe_ctx, &blnd_cfg.black_color);
+	} else if (dc->debug.visual_confirm == VISUAL_CONFIRM_SURFACE) {
 		dcn10_get_surface_visual_confirm_color(
 				pipe_ctx, &blnd_cfg.black_color);
-	else
+	} else {
 		color_space_to_black_color(
-			dc, pipe_ctx->stream->output_color_space,
-			&blnd_cfg.black_color);
+				dc, pipe_ctx->stream->output_color_space,
+				&blnd_cfg.black_color);
+	}
 
 	if (per_pixel_alpha)
 		blnd_cfg.alpha_mode = MPCC_ALPHA_BLEND_MODE_PER_PIXEL_ALPHA;
@@ -2148,6 +2189,7 @@ static void program_all_pipe_in_tree(
 				pipe_ctx->stream_res.tg);
 
 		dc->hwss.blank_pixel_data(dc, pipe_ctx, blank);
+
 	}
 
 	if (pipe_ctx->plane_state != NULL) {

commit 6d92b5c2d5bea1b1d0859bd8f3080344e5e3960e
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Wed Jun 27 18:23:37 2018 -0400

    drm/amd/display: Refactor SDR cursor boosting in HDR mode
    
    [Why]
    Cursor boosting is done via CNVC_CUR register which is DPP, not HUBP
    Previous commit was implementing it in HUBP functions,
    and also breaking diags tests.
    
    [How]
    1. Undo original commit as well as Eric's diags test fix, almost completely
    2. Move programming to DPP and call via new dc_stream function
    3. Also removing cur_rom_en from dpp_cursor_attributes and programming
    as part of normal cursor attributes as it depends on cursor color format
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 2e145aa663a4..6e8127cb2e56 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2555,6 +2555,33 @@ static void dcn10_set_cursor_attribute(struct pipe_ctx *pipe_ctx)
 		pipe_ctx->plane_res.dpp, attributes->color_format);
 }
 
+static void dcn10_set_cursor_sdr_white_level(struct pipe_ctx *pipe_ctx)
+{
+	uint32_t sdr_white_level = pipe_ctx->stream->cursor_attributes.sdr_white_level;
+	struct fixed31_32 multiplier;
+	struct dpp_cursor_attributes opt_attr = { 0 };
+	uint32_t hw_scale = 0x3c00; // 1.0 default multiplier
+	struct custom_float_format fmt;
+
+	if (!pipe_ctx->plane_res.dpp->funcs->set_optional_cursor_attributes)
+		return;
+
+	fmt.exponenta_bits = 5;
+	fmt.mantissa_bits = 10;
+	fmt.sign = true;
+
+	if (sdr_white_level > 80) {
+		multiplier = dc_fixpt_from_fraction(sdr_white_level, 80);
+		convert_to_custom_float_format(multiplier, &fmt, &hw_scale);
+	}
+
+	opt_attr.scale = hw_scale;
+	opt_attr.bias = 0;
+
+	pipe_ctx->plane_res.dpp->funcs->set_optional_cursor_attributes(
+			pipe_ctx->plane_res.dpp, &opt_attr);
+}
+
 static const struct hw_sequencer_funcs dcn10_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.program_csc_matrix = program_csc_matrix,
@@ -2602,7 +2629,8 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.edp_power_control = hwss_edp_power_control,
 	.edp_wait_for_hpd_ready = hwss_edp_wait_for_hpd_ready,
 	.set_cursor_position = dcn10_set_cursor_position,
-	.set_cursor_attribute = dcn10_set_cursor_attribute
+	.set_cursor_attribute = dcn10_set_cursor_attribute,
+	.set_cursor_sdr_white_level = dcn10_set_cursor_sdr_white_level
 };
 
 

commit 522e6b434a61f8be910560969386a2b3ce113c1b
Author: Hugo Hu <hugo.hu@amd.com>
Date:   Tue Jul 3 15:59:15 2018 -0400

    drm/amd/display: Initialize data structure for DalMpVisualConfirm.
    
    [Why] Prevent unexpected color shows if DalMpVisualConfirm enable.
    [How] Zero out color configuration data for DalMpVisualConfirm when initiating.
    
    Signed-off-by: Hugo Hu <hugo.hu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index a9942fd5f34e..2e145aa663a4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1851,7 +1851,7 @@ static void update_dpp(struct dpp *dpp, struct dc_plane_state *plane_state)
 static void dcn10_update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
-	struct mpcc_blnd_cfg blnd_cfg;
+	struct mpcc_blnd_cfg blnd_cfg = {0};
 	bool per_pixel_alpha = pipe_ctx->plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;
 	int mpcc_id;
 	struct mpcc *new_mpcc;

commit c2437b1f16d9b136c88b2c7c0254919a0e1311f6
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Wed May 16 16:19:50 2018 -0400

    drm/amd/display: Expose bunch of functions from dcn10_hw_sequencer
    
    v2: Remove spurious newline changes
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 944275a50c0a..a9942fd5f34e 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -834,7 +834,7 @@ static bool dcn10_hw_wa_force_recovery(struct dc *dc)
 }
 
 
-static void dcn10_verify_allow_pstate_change_high(struct dc *dc)
+void dcn10_verify_allow_pstate_change_high(struct dc *dc)
 {
 	static bool should_log_hw_state; /* prevent hw state log by default */
 
@@ -1848,8 +1848,7 @@ static void update_dpp(struct dpp *dpp, struct dc_plane_state *plane_state)
 		dpp->funcs->dpp_program_bias_and_scale(dpp, &bns_params);
 }
 
-
-static void update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
+static void dcn10_update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	struct mpcc_blnd_cfg blnd_cfg;
@@ -1994,7 +1993,7 @@ static void update_dchubp_dpp(
 
 	if (plane_state->update_flags.bits.full_update ||
 		plane_state->update_flags.bits.per_pixel_alpha_change)
-		update_mpcc(dc, pipe_ctx);
+		dc->hwss.update_mpcc(dc, pipe_ctx);
 
 	if (plane_state->update_flags.bits.full_update ||
 		plane_state->update_flags.bits.per_pixel_alpha_change ||
@@ -2104,6 +2103,33 @@ static void set_hdr_multiplier(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->plane_res.dpp, hw_mult);
 }
 
+void dcn10_program_pipe(
+		struct dc *dc,
+		struct pipe_ctx *pipe_ctx,
+		struct dc_state *context)
+{
+	if (pipe_ctx->plane_state->update_flags.bits.full_update)
+		dcn10_enable_plane(dc, pipe_ctx, context);
+
+	update_dchubp_dpp(dc, pipe_ctx, context);
+
+	set_hdr_multiplier(pipe_ctx);
+
+	if (pipe_ctx->plane_state->update_flags.bits.full_update ||
+			pipe_ctx->plane_state->update_flags.bits.in_transfer_func_change ||
+			pipe_ctx->plane_state->update_flags.bits.gamma_change)
+		dc->hwss.set_input_transfer_func(pipe_ctx, pipe_ctx->plane_state);
+
+	/* dcn10_translate_regamma_to_hw_format takes 750us to finish
+	 * only do gamma programming for full update.
+	 * TODO: This can be further optimized/cleaned up
+	 * Always call this for now since it does memcmp inside before
+	 * doing heavy calculation and programming
+	 */
+	if (pipe_ctx->plane_state->update_flags.bits.full_update)
+		dc->hwss.set_output_transfer_func(pipe_ctx, pipe_ctx->stream);
+}
+
 static void program_all_pipe_in_tree(
 		struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
@@ -2125,26 +2151,7 @@ static void program_all_pipe_in_tree(
 	}
 
 	if (pipe_ctx->plane_state != NULL) {
-		if (pipe_ctx->plane_state->update_flags.bits.full_update)
-			dcn10_enable_plane(dc, pipe_ctx, context);
-
-		update_dchubp_dpp(dc, pipe_ctx, context);
-
-		set_hdr_multiplier(pipe_ctx);
-
-		if (pipe_ctx->plane_state->update_flags.bits.full_update ||
-				pipe_ctx->plane_state->update_flags.bits.in_transfer_func_change ||
-				pipe_ctx->plane_state->update_flags.bits.gamma_change)
-			dc->hwss.set_input_transfer_func(pipe_ctx, pipe_ctx->plane_state);
-
-		/* dcn10_translate_regamma_to_hw_format takes 750us to finish
-		 * only do gamma programming for full update.
-		 * TODO: This can be further optimized/cleaned up
-		 * Always call this for now since it does memcmp inside before
-		 * doing heavy calculation and programming
-		 */
-		if (pipe_ctx->plane_state->update_flags.bits.full_update)
-			dc->hwss.set_output_transfer_func(pipe_ctx, pipe_ctx->stream);
+		dcn10_program_pipe(dc, pipe_ctx, context);
 	}
 
 	if (pipe_ctx->bottom_pipe != NULL && pipe_ctx->bottom_pipe != pipe_ctx) {
@@ -2269,7 +2276,7 @@ static void dcn10_apply_ctx_for_surface(
 			old_pipe_ctx->plane_state &&
 			old_pipe_ctx->stream_res.tg == tg) {
 
-			hwss1_plane_atomic_disconnect(dc, old_pipe_ctx);
+			dc->hwss.plane_atomic_disconnect(dc, old_pipe_ctx);
 			removed_pipe[i] = true;
 
 			DC_LOG_DC("Reset mpcc for pipe %d\n",
@@ -2555,7 +2562,9 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
 	.apply_ctx_for_surface = dcn10_apply_ctx_for_surface,
 	.update_plane_addr = dcn10_update_plane_addr,
+	.plane_atomic_disconnect = hwss1_plane_atomic_disconnect,
 	.update_dchub = dcn10_update_dchub,
+	.update_mpcc = dcn10_update_mpcc,
 	.update_pending_status = dcn10_update_pending_status,
 	.set_input_transfer_func = dcn10_set_input_transfer_func,
 	.set_output_transfer_func = dcn10_set_output_transfer_func,

commit 08ed681c8453c2934136bcc3b30bca4dee8a5fca
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Jun 21 13:33:41 2018 -0400

    drm/amd/display: add dcn cursor hotsport rotation and mirror support
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 2938364fd2f0..944275a50c0a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2523,7 +2523,8 @@ static void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 		.viewport = pipe_ctx->plane_res.scl_data.viewport,
 		.h_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.horz,
 		.v_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.vert,
-		.rotation = pipe_ctx->plane_state->rotation
+		.rotation = pipe_ctx->plane_state->rotation,
+		.mirror = pipe_ctx->plane_state->horizontal_mirror
 	};
 
 	if (pipe_ctx->plane_state->address.type

commit 39a9f4d89e123b62c8a5cc26696ea8afa98e0e88
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Jun 19 15:49:02 2018 -0400

    drm/amd/display: add additional info for cursor position programming
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 3b2cb2d3b8a6..2938364fd2f0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2520,9 +2520,10 @@ static void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
 	struct dc_cursor_mi_param param = {
 		.pixel_clk_khz = pipe_ctx->stream->timing.pix_clk_khz,
 		.ref_clk_khz = pipe_ctx->stream->ctx->dc->res_pool->ref_clock_inKhz,
-		.viewport_x_start = pipe_ctx->plane_res.scl_data.viewport.x,
-		.viewport_width = pipe_ctx->plane_res.scl_data.viewport.width,
-		.h_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.horz
+		.viewport = pipe_ctx->plane_res.scl_data.viewport,
+		.h_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.horz,
+		.v_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.vert,
+		.rotation = pipe_ctx->plane_state->rotation
 	};
 
 	if (pipe_ctx->plane_state->address.type

commit 7f93c1de64693dc18afe55559f14cee6b5403c6c
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Sat Jun 9 19:33:14 2018 -0400

    drm/amd/display: add valid regoffset and NULL pointer check
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 21b45e8d49f7..3b2cb2d3b8a6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -415,6 +415,8 @@ static void dpp_pg_control(
 
 	if (hws->ctx->dc->debug.disable_dpp_power_gate)
 		return;
+	if (REG(DOMAIN1_PG_CONFIG) == 0)
+		return;
 
 	switch (dpp_inst) {
 	case 0: /* DPP0 */
@@ -465,6 +467,8 @@ static void hubp_pg_control(
 
 	if (hws->ctx->dc->debug.disable_hubp_power_gate)
 		return;
+	if (REG(DOMAIN0_PG_CONFIG) == 0)
+		return;
 
 	switch (hubp_inst) {
 	case 0: /* DCHUBP0 */
@@ -865,7 +869,8 @@ void hwss1_plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 		return;
 
 	mpc->funcs->remove_mpcc(mpc, mpc_tree_params, mpcc_to_remove);
-	opp->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;
+	if (opp != NULL)
+		opp->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;
 
 	dc->optimized_required = true;
 
@@ -1343,10 +1348,11 @@ static void dcn10_enable_per_frame_crtc_position_reset(
 
 	DC_SYNC_INFO("Setting up\n");
 	for (i = 0; i < group_size; i++)
-		grouped_pipes[i]->stream_res.tg->funcs->enable_crtc_reset(
-				grouped_pipes[i]->stream_res.tg,
-				grouped_pipes[i]->stream->triggered_crtc_reset.event_source->status.primary_otg_inst,
-				&grouped_pipes[i]->stream->triggered_crtc_reset);
+		if (grouped_pipes[i]->stream_res.tg->funcs->enable_crtc_reset)
+			grouped_pipes[i]->stream_res.tg->funcs->enable_crtc_reset(
+					grouped_pipes[i]->stream_res.tg,
+					grouped_pipes[i]->stream->triggered_crtc_reset.event_source->status.primary_otg_inst,
+					&grouped_pipes[i]->stream->triggered_crtc_reset);
 
 	DC_SYNC_INFO("Waiting for trigger\n");
 
@@ -2496,8 +2502,14 @@ static void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 
 static void dcn10_update_dchub(struct dce_hwseq *hws, struct dchub_init_data *dh_data)
 {
-	if (hws->ctx->dc->res_pool->hubbub != NULL)
-		hubbub1_update_dchub(hws->ctx->dc->res_pool->hubbub, dh_data);
+	if (hws->ctx->dc->res_pool->hubbub != NULL) {
+		struct hubp *hubp = hws->ctx->dc->res_pool->hubps[0];
+
+		if (hubp->funcs->hubp_update_dchub)
+			hubp->funcs->hubp_update_dchub(hubp, dh_data);
+		else
+			hubbub1_update_dchub(hws->ctx->dc->res_pool->hubbub, dh_data);
+	}
 }
 
 static void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)

commit e21db6dbdf4327f620c5a203f7801b59dad9942e
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu May 24 14:39:01 2018 -0400

    drm/amd/display: move dcn watermark programming to set_bandwidth
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 378bb19b98de..21b45e8d49f7 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2219,8 +2219,6 @@ static void dcn10_apply_ctx_for_surface(
 	int i;
 	struct timing_generator *tg;
 	bool removed_pipe[4] = { false };
-	unsigned int ref_clk_mhz = dc->res_pool->ref_clock_inKhz/1000;
-	bool program_water_mark = false;
 	struct pipe_ctx *top_pipe_to_program =
 			find_top_pipe_for_stream(dc, context, stream);
 	DC_LOGGER_INIT(dc->ctx->logger);
@@ -2281,107 +2279,38 @@ static void dcn10_apply_ctx_for_surface(
 	if (num_planes == 0)
 		false_optc_underflow_wa(dc, stream, tg);
 
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct pipe_ctx *old_pipe_ctx =
-				&dc->current_state->res_ctx.pipe_ctx[i];
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-
-		if (pipe_ctx->stream == stream &&
-				pipe_ctx->plane_state &&
-			pipe_ctx->plane_state->update_flags.bits.full_update)
-			program_water_mark = true;
-
+	for (i = 0; i < dc->res_pool->pipe_count; i++)
 		if (removed_pipe[i])
-			dcn10_disable_plane(dc, old_pipe_ctx);
-	}
-
-	if (program_water_mark) {
-		if (dc->debug.sanity_checks) {
-			/* pstate stuck check after watermark update */
-			dcn10_verify_allow_pstate_change_high(dc);
-		}
-
-		/* watermark is for all pipes */
-		hubbub1_program_watermarks(dc->res_pool->hubbub,
-				&context->bw.dcn.watermarks, ref_clk_mhz, true);
-
-		if (dc->hwseq->wa.DEGVIDCN10_254)
-			hubbub1_wm_change_req_wa(dc->res_pool->hubbub);
+			dcn10_disable_plane(dc, &dc->current_state->res_ctx.pipe_ctx[i]);
 
-		if (dc->debug.sanity_checks) {
-			/* pstate stuck check after watermark update */
-			dcn10_verify_allow_pstate_change_high(dc);
-		}
-	}
-/*	DC_LOG_BANDWIDTH_CALCS(dc->ctx->logger,
-			"\n============== Watermark parameters ==============\n"
-			"a.urgent_ns: %d \n"
-			"a.cstate_enter_plus_exit: %d \n"
-			"a.cstate_exit: %d \n"
-			"a.pstate_change: %d \n"
-			"a.pte_meta_urgent: %d \n"
-			"b.urgent_ns: %d \n"
-			"b.cstate_enter_plus_exit: %d \n"
-			"b.cstate_exit: %d \n"
-			"b.pstate_change: %d \n"
-			"b.pte_meta_urgent: %d \n",
-			context->bw.dcn.watermarks.a.urgent_ns,
-			context->bw.dcn.watermarks.a.cstate_pstate.cstate_enter_plus_exit_ns,
-			context->bw.dcn.watermarks.a.cstate_pstate.cstate_exit_ns,
-			context->bw.dcn.watermarks.a.cstate_pstate.pstate_change_ns,
-			context->bw.dcn.watermarks.a.pte_meta_urgent_ns,
-			context->bw.dcn.watermarks.b.urgent_ns,
-			context->bw.dcn.watermarks.b.cstate_pstate.cstate_enter_plus_exit_ns,
-			context->bw.dcn.watermarks.b.cstate_pstate.cstate_exit_ns,
-			context->bw.dcn.watermarks.b.cstate_pstate.pstate_change_ns,
-			context->bw.dcn.watermarks.b.pte_meta_urgent_ns
-			);
-	DC_LOG_BANDWIDTH_CALCS(dc->ctx->logger,
-			"\nc.urgent_ns: %d \n"
-			"c.cstate_enter_plus_exit: %d \n"
-			"c.cstate_exit: %d \n"
-			"c.pstate_change: %d \n"
-			"c.pte_meta_urgent: %d \n"
-			"d.urgent_ns: %d \n"
-			"d.cstate_enter_plus_exit: %d \n"
-			"d.cstate_exit: %d \n"
-			"d.pstate_change: %d \n"
-			"d.pte_meta_urgent: %d \n"
-			"========================================================\n",
-			context->bw.dcn.watermarks.c.urgent_ns,
-			context->bw.dcn.watermarks.c.cstate_pstate.cstate_enter_plus_exit_ns,
-			context->bw.dcn.watermarks.c.cstate_pstate.cstate_exit_ns,
-			context->bw.dcn.watermarks.c.cstate_pstate.pstate_change_ns,
-			context->bw.dcn.watermarks.c.pte_meta_urgent_ns,
-			context->bw.dcn.watermarks.d.urgent_ns,
-			context->bw.dcn.watermarks.d.cstate_pstate.cstate_enter_plus_exit_ns,
-			context->bw.dcn.watermarks.d.cstate_pstate.cstate_exit_ns,
-			context->bw.dcn.watermarks.d.cstate_pstate.pstate_change_ns,
-			context->bw.dcn.watermarks.d.pte_meta_urgent_ns
-			);
-*/
+	if (dc->hwseq->wa.DEGVIDCN10_254)
+		hubbub1_wm_change_req_wa(dc->res_pool->hubbub);
 }
 
 static void dcn10_set_bandwidth(
 		struct dc *dc,
 		struct dc_state *context,
-		bool decrease_allowed)
+		bool safe_to_lower)
 {
 	if (dc->debug.sanity_checks)
 		dcn10_verify_allow_pstate_change_high(dc);
 
-	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
-		return;
+	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
+		if (context->stream_count == 0)
+			context->bw.dcn.clk.phyclk_khz = 0;
 
-	if (context->stream_count == 0)
-		context->bw.dcn.clk.phyclk_khz = 0;
+		dc->res_pool->dccg->funcs->update_clocks(
+				dc->res_pool->dccg,
+				&context->bw.dcn.clk,
+				safe_to_lower);
 
-	dc->res_pool->dccg->funcs->update_clocks(
-			dc->res_pool->dccg,
-			&context->bw.dcn.clk,
-			decrease_allowed);
+		dcn10_pplib_apply_display_requirements(dc, context);
+	}
 
-	dcn10_pplib_apply_display_requirements(dc, context);
+	hubbub1_program_watermarks(dc->res_pool->hubbub,
+			&context->bw.dcn.watermarks,
+			dc->res_pool->ref_clock_inKhz / 1000,
+			true);
 
 	if (dc->debug.sanity_checks)
 		dcn10_verify_allow_pstate_change_high(dc);

commit 7144d3cfff7d8b0d98d9d25ee42c674491e31bc9
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Jun 5 13:14:13 2018 -0400

    drm/amd/display: separate out wm change request dcn workaround
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index cc12c4757f8b..378bb19b98de 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2305,6 +2305,9 @@ static void dcn10_apply_ctx_for_surface(
 		hubbub1_program_watermarks(dc->res_pool->hubbub,
 				&context->bw.dcn.watermarks, ref_clk_mhz, true);
 
+		if (dc->hwseq->wa.DEGVIDCN10_254)
+			hubbub1_wm_change_req_wa(dc->res_pool->hubbub);
+
 		if (dc->debug.sanity_checks) {
 			/* pstate stuck check after watermark update */
 			dcn10_verify_allow_pstate_change_high(dc);

commit b9c1c67aeb8805015f02efb0a6a6ddf68ea8a4b4
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Jun 5 12:54:38 2018 -0400

    drm/amd/display: clean rq/dlg/ttu reg structs before calculations
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7d9c10b6d99b..cc12c4757f8b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -151,19 +151,23 @@ static void dcn10_log_hubp_states(struct dc *dc)
 
 	DTN_INFO("\n=========RQ========\n");
 	DTN_INFO("HUBP:  drq_exp_m  prq_exp_m  mrq_exp_m  crq_exp_m  plane1_ba  L:chunk_s  min_chu_s  meta_ch_s"
+		"  min_m_c_s  dpte_gr_s  mpte_gr_s  swath_hei  pte_row_h  C:chunk_s  min_chu_s  meta_ch_s"
 		"  min_m_c_s  dpte_gr_s  mpte_gr_s  swath_hei  pte_row_h\n");
 	for (i = 0; i < pool->pipe_count; i++) {
 		struct dcn_hubp_state *s = &(TO_DCN10_HUBP(pool->hubps[i])->state);
 		struct _vcs_dpi_display_rq_regs_st *rq_regs = &s->rq_regs;
 
 		if (!s->blank_en)
-			DTN_INFO("[%2d]:  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\n",
+			DTN_INFO("[%2d]:  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\n",
 				pool->hubps[i]->inst, rq_regs->drq_expansion_mode, rq_regs->prq_expansion_mode, rq_regs->mrq_expansion_mode,
 				rq_regs->crq_expansion_mode, rq_regs->plane1_base_address, rq_regs->rq_regs_l.chunk_size,
 				rq_regs->rq_regs_l.min_chunk_size, rq_regs->rq_regs_l.meta_chunk_size,
 				rq_regs->rq_regs_l.min_meta_chunk_size, rq_regs->rq_regs_l.dpte_group_size,
 				rq_regs->rq_regs_l.mpte_group_size, rq_regs->rq_regs_l.swath_height,
-				rq_regs->rq_regs_l.pte_row_height_linear);
+				rq_regs->rq_regs_l.pte_row_height_linear, rq_regs->rq_regs_c.chunk_size, rq_regs->rq_regs_c.min_chunk_size,
+				rq_regs->rq_regs_c.meta_chunk_size, rq_regs->rq_regs_c.min_meta_chunk_size,
+				rq_regs->rq_regs_c.dpte_group_size, rq_regs->rq_regs_c.mpte_group_size,
+				rq_regs->rq_regs_c.swath_height, rq_regs->rq_regs_c.pte_row_height_linear);
 	}
 
 	DTN_INFO("========DLG========\n");

commit d7b539d34acea44ee555a4fe35e77c23b8dc4bc4
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu May 24 15:09:40 2018 -0400

    drm/amd/display: add safe_to_lower support to dcn wm programming
    
    This will prevent watermarks from lowering when unsafe to do so.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 5b40c1c4d9e6..7d9c10b6d99b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2299,7 +2299,7 @@ static void dcn10_apply_ctx_for_surface(
 
 		/* watermark is for all pipes */
 		hubbub1_program_watermarks(dc->res_pool->hubbub,
-				&context->bw.dcn.watermarks, ref_clk_mhz);
+				&context->bw.dcn.watermarks, ref_clk_mhz, true);
 
 		if (dc->debug.sanity_checks) {
 			/* pstate stuck check after watermark update */

commit 0eebf8ca18b647024fc9a3ccc88c0184d02db534
Author: Wesley Chalmers <Wesley.Chalmers@amd.com>
Date:   Fri Jun 1 10:54:53 2018 -0400

    drm/amd/display: Temporarily remove Chroma logs
    
    To ensure tests continue to pass
    
    Signed-off-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Reviewed-by: Shahin Khayyer <Shahin.Khayyer@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 08809b0ff6bf..5b40c1c4d9e6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -151,23 +151,19 @@ static void dcn10_log_hubp_states(struct dc *dc)
 
 	DTN_INFO("\n=========RQ========\n");
 	DTN_INFO("HUBP:  drq_exp_m  prq_exp_m  mrq_exp_m  crq_exp_m  plane1_ba  L:chunk_s  min_chu_s  meta_ch_s"
-		"  min_m_c_s  dpte_gr_s  mpte_gr_s  swath_hei  pte_row_h  C:chunk_s  min_chu_s  meta_ch_s"
 		"  min_m_c_s  dpte_gr_s  mpte_gr_s  swath_hei  pte_row_h\n");
 	for (i = 0; i < pool->pipe_count; i++) {
 		struct dcn_hubp_state *s = &(TO_DCN10_HUBP(pool->hubps[i])->state);
 		struct _vcs_dpi_display_rq_regs_st *rq_regs = &s->rq_regs;
 
 		if (!s->blank_en)
-			DTN_INFO("[%2d]:  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\n",
+			DTN_INFO("[%2d]:  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\n",
 				pool->hubps[i]->inst, rq_regs->drq_expansion_mode, rq_regs->prq_expansion_mode, rq_regs->mrq_expansion_mode,
 				rq_regs->crq_expansion_mode, rq_regs->plane1_base_address, rq_regs->rq_regs_l.chunk_size,
 				rq_regs->rq_regs_l.min_chunk_size, rq_regs->rq_regs_l.meta_chunk_size,
 				rq_regs->rq_regs_l.min_meta_chunk_size, rq_regs->rq_regs_l.dpte_group_size,
 				rq_regs->rq_regs_l.mpte_group_size, rq_regs->rq_regs_l.swath_height,
-				rq_regs->rq_regs_l.pte_row_height_linear, rq_regs->rq_regs_c.chunk_size, rq_regs->rq_regs_c.min_chunk_size,
-				rq_regs->rq_regs_c.meta_chunk_size, rq_regs->rq_regs_c.min_meta_chunk_size,
-				rq_regs->rq_regs_c.dpte_group_size, rq_regs->rq_regs_c.mpte_group_size,
-				rq_regs->rq_regs_c.swath_height, rq_regs->rq_regs_c.pte_row_height_linear);
+				rq_regs->rq_regs_l.pte_row_height_linear);
 	}
 
 	DTN_INFO("========DLG========\n");

commit c910a717dac6540a636a57c1a34261c6d84fc0eb
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 23 18:39:21 2018 -0400

    drm/amd/display: clean up set_bandwidth usage
    
    This removes redundant set_bandwidth calls as well
    as fixes a bug in post_set_address_update where dcn1
    would never get to lower clocks.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 60e99477930b..08809b0ff6bf 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2268,8 +2268,7 @@ static void dcn10_apply_ctx_for_surface(
 			hwss1_plane_atomic_disconnect(dc, old_pipe_ctx);
 			removed_pipe[i] = true;
 
-			DC_LOG_DC(
-					"Reset mpcc for pipe %d\n",
+			DC_LOG_DC("Reset mpcc for pipe %d\n",
 					old_pipe_ctx->pipe_idx);
 		}
 	}
@@ -2365,9 +2364,8 @@ static void dcn10_set_bandwidth(
 		struct dc_state *context,
 		bool decrease_allowed)
 {
-	if (dc->debug.sanity_checks) {
+	if (dc->debug.sanity_checks)
 		dcn10_verify_allow_pstate_change_high(dc);
-	}
 
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
 		return;
@@ -2382,11 +2380,8 @@ static void dcn10_set_bandwidth(
 
 	dcn10_pplib_apply_display_requirements(dc, context);
 
-	if (dc->debug.sanity_checks) {
+	if (dc->debug.sanity_checks)
 		dcn10_verify_allow_pstate_change_high(dc);
-	}
-
-	/* need to fix this function.  not doing the right thing here */
 }
 
 static void set_drr(struct pipe_ctx **pipe_ctx,

commit 12c3130dd6f391437a60c765912a30b4cbb77247
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 23 18:18:50 2018 -0400

    drm/amd/display: move dcn1 dispclk programming to dccg
    
    No functional change.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 6ab00615c4c5..60e99477930b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2360,101 +2360,6 @@ static void dcn10_apply_ctx_for_surface(
 */
 }
 
-static int determine_dppclk_threshold(struct dc *dc, struct dc_state *context)
-{
-	bool request_dpp_div = context->bw.dcn.clk.dispclk_khz >
-			context->bw.dcn.clk.dppclk_khz;
-	bool dispclk_increase = context->bw.dcn.clk.dispclk_khz >
-			dc->res_pool->dccg->clks.dispclk_khz;
-	int disp_clk_threshold = context->bw.dcn.clk.max_supported_dppclk_khz;
-	bool cur_dpp_div = dc->res_pool->dccg->clks.dispclk_khz >
-			dc->res_pool->dccg->clks.dppclk_khz;
-
-	/* increase clock, looking for div is 0 for current, request div is 1*/
-	if (dispclk_increase) {
-		/* already divided by 2, no need to reach target clk with 2 steps*/
-		if (cur_dpp_div)
-			return context->bw.dcn.clk.dispclk_khz;
-
-		/* request disp clk is lower than maximum supported dpp clk,
-		 * no need to reach target clk with two steps.
-		 */
-		if (context->bw.dcn.clk.dispclk_khz <= disp_clk_threshold)
-			return context->bw.dcn.clk.dispclk_khz;
-
-		/* target dpp clk not request divided by 2, still within threshold */
-		if (!request_dpp_div)
-			return context->bw.dcn.clk.dispclk_khz;
-
-	} else {
-		/* decrease clock, looking for current dppclk divided by 2,
-		 * request dppclk not divided by 2.
-		 */
-
-		/* current dpp clk not divided by 2, no need to ramp*/
-		if (!cur_dpp_div)
-			return context->bw.dcn.clk.dispclk_khz;
-
-		/* current disp clk is lower than current maximum dpp clk,
-		 * no need to ramp
-		 */
-		if (dc->res_pool->dccg->clks.dispclk_khz <= disp_clk_threshold)
-			return context->bw.dcn.clk.dispclk_khz;
-
-		/* request dpp clk need to be divided by 2 */
-		if (request_dpp_div)
-			return context->bw.dcn.clk.dispclk_khz;
-	}
-
-	return disp_clk_threshold;
-}
-
-static void ramp_up_dispclk_with_dpp(struct dc *dc, struct dc_state *context)
-{
-	int i;
-	bool request_dpp_div = context->bw.dcn.clk.dispclk_khz >
-				context->bw.dcn.clk.dppclk_khz;
-
-	int dispclk_to_dpp_threshold = determine_dppclk_threshold(dc, context);
-
-	/* set disp clk to dpp clk threshold */
-	dc->res_pool->dccg->funcs->set_dispclk(
-			dc->res_pool->dccg,
-			dispclk_to_dpp_threshold);
-
-	/* update request dpp clk division option */
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct pipe_ctx *pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
-
-		if (!pipe_ctx->plane_state)
-			continue;
-
-		pipe_ctx->plane_res.dpp->funcs->dpp_dppclk_control(
-				pipe_ctx->plane_res.dpp,
-				request_dpp_div,
-				true);
-	}
-
-	/* If target clk not same as dppclk threshold, set to target clock */
-	if (dispclk_to_dpp_threshold != context->bw.dcn.clk.dispclk_khz) {
-		dc->res_pool->dccg->funcs->set_dispclk(
-				dc->res_pool->dccg,
-				context->bw.dcn.clk.dispclk_khz);
-	}
-
-	dc->res_pool->dccg->clks.dispclk_khz =
-			context->bw.dcn.clk.dispclk_khz;
-	dc->res_pool->dccg->clks.dppclk_khz =
-			context->bw.dcn.clk.dppclk_khz;
-	dc->res_pool->dccg->clks.max_supported_dppclk_khz =
-			context->bw.dcn.clk.max_supported_dppclk_khz;
-}
-
-static inline bool should_set_clock(bool safe_to_lower, int calc_clk, int cur_clk)
-{
-	return ((safe_to_lower && calc_clk < cur_clk) || calc_clk > cur_clk);
-}
-
 static void dcn10_set_bandwidth(
 		struct dc *dc,
 		struct dc_state *context,
@@ -2475,17 +2380,6 @@ static void dcn10_set_bandwidth(
 			&context->bw.dcn.clk,
 			decrease_allowed);
 
-	/* make sure dcf clk is before dpp clk to
-	 * make sure we have enough voltage to run dpp clk
-	 */
-	if (should_set_clock(
-			decrease_allowed,
-			context->bw.dcn.clk.dispclk_khz,
-			dc->res_pool->dccg->clks.dispclk_khz)) {
-
-		ramp_up_dispclk_with_dpp(dc, context);
-	}
-
 	dcn10_pplib_apply_display_requirements(dc, context);
 
 	if (dc->debug.sanity_checks) {

commit d578839ca014e5f4e6d540caadc0b84d50a8977f
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 23 18:02:27 2018 -0400

    drm/amd/display: get rid of cur_clks from dcn_bw_output
    
    Cleans up dcn_bw_output to only contain calculated info,
    actual programmed values will now be stored in respective blocks.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 64ca503cab42..6ab00615c4c5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -337,13 +337,13 @@ void dcn10_log_hw_state(struct dc *dc)
 
 	DTN_INFO("\nCALCULATED Clocks: dcfclk_khz:%d  dcfclk_deep_sleep_khz:%d  dispclk_khz:%d\n"
 		"dppclk_khz:%d  max_supported_dppclk_khz:%d  fclk_khz:%d  socclk_khz:%d\n\n",
-			dc->current_state->bw.dcn.calc_clk.dcfclk_khz,
-			dc->current_state->bw.dcn.calc_clk.dcfclk_deep_sleep_khz,
-			dc->current_state->bw.dcn.calc_clk.dispclk_khz,
-			dc->current_state->bw.dcn.calc_clk.dppclk_khz,
-			dc->current_state->bw.dcn.calc_clk.max_supported_dppclk_khz,
-			dc->current_state->bw.dcn.calc_clk.fclk_khz,
-			dc->current_state->bw.dcn.calc_clk.socclk_khz);
+			dc->current_state->bw.dcn.clk.dcfclk_khz,
+			dc->current_state->bw.dcn.clk.dcfclk_deep_sleep_khz,
+			dc->current_state->bw.dcn.clk.dispclk_khz,
+			dc->current_state->bw.dcn.clk.dppclk_khz,
+			dc->current_state->bw.dcn.clk.max_supported_dppclk_khz,
+			dc->current_state->bw.dcn.clk.fclk_khz,
+			dc->current_state->bw.dcn.clk.socclk_khz);
 
 	log_mpc_crc(dc);
 
@@ -1952,18 +1952,17 @@ static void update_dchubp_dpp(
 	 * divided by 2
 	 */
 	if (plane_state->update_flags.bits.full_update) {
-		bool should_divided_by_2 = context->bw.dcn.calc_clk.dppclk_khz <=
-				context->bw.dcn.cur_clk.dispclk_khz / 2;
+		bool should_divided_by_2 = context->bw.dcn.clk.dppclk_khz <=
+				dc->res_pool->dccg->clks.dispclk_khz / 2;
 
 		dpp->funcs->dpp_dppclk_control(
 				dpp,
 				should_divided_by_2,
 				true);
 
-		dc->current_state->bw.dcn.cur_clk.dppclk_khz =
-				should_divided_by_2 ?
-				context->bw.dcn.cur_clk.dispclk_khz / 2 :
-				context->bw.dcn.cur_clk.dispclk_khz;
+		dc->res_pool->dccg->clks.dppclk_khz = should_divided_by_2 ?
+						dc->res_pool->dccg->clks.dispclk_khz / 2 :
+							dc->res_pool->dccg->clks.dispclk_khz;
 	}
 
 	/* TODO: Need input parameter to tell current DCHUB pipe tie to which OTG
@@ -2158,7 +2157,7 @@ static void dcn10_pplib_apply_display_requirements(
 	pp_display_cfg->min_engine_clock_deep_sleep_khz = dc->res_pool->dccg->clks.dcfclk_deep_sleep_khz;
 	pp_display_cfg->min_dcfc_deep_sleep_clock_khz = dc->res_pool->dccg->clks.dcfclk_deep_sleep_khz;
 	pp_display_cfg->min_dcfclock_khz = dc->res_pool->dccg->clks.dcfclk_khz;
-	pp_display_cfg->disp_clk_khz = context->bw.dcn.cur_clk.dispclk_khz;
+	pp_display_cfg->disp_clk_khz = dc->res_pool->dccg->clks.dispclk_khz;
 	dce110_fill_display_configs(context, pp_display_cfg);
 
 	if (memcmp(&dc->prev_display_config, pp_display_cfg, sizeof(
@@ -2363,29 +2362,29 @@ static void dcn10_apply_ctx_for_surface(
 
 static int determine_dppclk_threshold(struct dc *dc, struct dc_state *context)
 {
-	bool request_dpp_div = context->bw.dcn.calc_clk.dispclk_khz >
-			context->bw.dcn.calc_clk.dppclk_khz;
-	bool dispclk_increase = context->bw.dcn.calc_clk.dispclk_khz >
-			context->bw.dcn.cur_clk.dispclk_khz;
-	int disp_clk_threshold = context->bw.dcn.calc_clk.max_supported_dppclk_khz;
-	bool cur_dpp_div = context->bw.dcn.cur_clk.dispclk_khz >
-			context->bw.dcn.cur_clk.dppclk_khz;
+	bool request_dpp_div = context->bw.dcn.clk.dispclk_khz >
+			context->bw.dcn.clk.dppclk_khz;
+	bool dispclk_increase = context->bw.dcn.clk.dispclk_khz >
+			dc->res_pool->dccg->clks.dispclk_khz;
+	int disp_clk_threshold = context->bw.dcn.clk.max_supported_dppclk_khz;
+	bool cur_dpp_div = dc->res_pool->dccg->clks.dispclk_khz >
+			dc->res_pool->dccg->clks.dppclk_khz;
 
 	/* increase clock, looking for div is 0 for current, request div is 1*/
 	if (dispclk_increase) {
 		/* already divided by 2, no need to reach target clk with 2 steps*/
 		if (cur_dpp_div)
-			return context->bw.dcn.calc_clk.dispclk_khz;
+			return context->bw.dcn.clk.dispclk_khz;
 
 		/* request disp clk is lower than maximum supported dpp clk,
 		 * no need to reach target clk with two steps.
 		 */
-		if (context->bw.dcn.calc_clk.dispclk_khz <= disp_clk_threshold)
-			return context->bw.dcn.calc_clk.dispclk_khz;
+		if (context->bw.dcn.clk.dispclk_khz <= disp_clk_threshold)
+			return context->bw.dcn.clk.dispclk_khz;
 
 		/* target dpp clk not request divided by 2, still within threshold */
 		if (!request_dpp_div)
-			return context->bw.dcn.calc_clk.dispclk_khz;
+			return context->bw.dcn.clk.dispclk_khz;
 
 	} else {
 		/* decrease clock, looking for current dppclk divided by 2,
@@ -2394,17 +2393,17 @@ static int determine_dppclk_threshold(struct dc *dc, struct dc_state *context)
 
 		/* current dpp clk not divided by 2, no need to ramp*/
 		if (!cur_dpp_div)
-			return context->bw.dcn.calc_clk.dispclk_khz;
+			return context->bw.dcn.clk.dispclk_khz;
 
 		/* current disp clk is lower than current maximum dpp clk,
 		 * no need to ramp
 		 */
-		if (context->bw.dcn.cur_clk.dispclk_khz <= disp_clk_threshold)
-			return context->bw.dcn.calc_clk.dispclk_khz;
+		if (dc->res_pool->dccg->clks.dispclk_khz <= disp_clk_threshold)
+			return context->bw.dcn.clk.dispclk_khz;
 
 		/* request dpp clk need to be divided by 2 */
 		if (request_dpp_div)
-			return context->bw.dcn.calc_clk.dispclk_khz;
+			return context->bw.dcn.clk.dispclk_khz;
 	}
 
 	return disp_clk_threshold;
@@ -2413,8 +2412,8 @@ static int determine_dppclk_threshold(struct dc *dc, struct dc_state *context)
 static void ramp_up_dispclk_with_dpp(struct dc *dc, struct dc_state *context)
 {
 	int i;
-	bool request_dpp_div = context->bw.dcn.calc_clk.dispclk_khz >
-				context->bw.dcn.calc_clk.dppclk_khz;
+	bool request_dpp_div = context->bw.dcn.clk.dispclk_khz >
+				context->bw.dcn.clk.dppclk_khz;
 
 	int dispclk_to_dpp_threshold = determine_dppclk_threshold(dc, context);
 
@@ -2437,18 +2436,18 @@ static void ramp_up_dispclk_with_dpp(struct dc *dc, struct dc_state *context)
 	}
 
 	/* If target clk not same as dppclk threshold, set to target clock */
-	if (dispclk_to_dpp_threshold != context->bw.dcn.calc_clk.dispclk_khz) {
+	if (dispclk_to_dpp_threshold != context->bw.dcn.clk.dispclk_khz) {
 		dc->res_pool->dccg->funcs->set_dispclk(
 				dc->res_pool->dccg,
-				context->bw.dcn.calc_clk.dispclk_khz);
+				context->bw.dcn.clk.dispclk_khz);
 	}
 
-	context->bw.dcn.cur_clk.dispclk_khz =
-			context->bw.dcn.calc_clk.dispclk_khz;
-	context->bw.dcn.cur_clk.dppclk_khz =
-			context->bw.dcn.calc_clk.dppclk_khz;
-	context->bw.dcn.cur_clk.max_supported_dppclk_khz =
-			context->bw.dcn.calc_clk.max_supported_dppclk_khz;
+	dc->res_pool->dccg->clks.dispclk_khz =
+			context->bw.dcn.clk.dispclk_khz;
+	dc->res_pool->dccg->clks.dppclk_khz =
+			context->bw.dcn.clk.dppclk_khz;
+	dc->res_pool->dccg->clks.max_supported_dppclk_khz =
+			context->bw.dcn.clk.max_supported_dppclk_khz;
 }
 
 static inline bool should_set_clock(bool safe_to_lower, int calc_clk, int cur_clk)
@@ -2469,11 +2468,11 @@ static void dcn10_set_bandwidth(
 		return;
 
 	if (context->stream_count == 0)
-		context->bw.dcn.calc_clk.phyclk_khz = 0;
+		context->bw.dcn.clk.phyclk_khz = 0;
 
 	dc->res_pool->dccg->funcs->update_clocks(
 			dc->res_pool->dccg,
-			&context->bw.dcn.calc_clk,
+			&context->bw.dcn.clk,
 			decrease_allowed);
 
 	/* make sure dcf clk is before dpp clk to
@@ -2481,8 +2480,8 @@ static void dcn10_set_bandwidth(
 	 */
 	if (should_set_clock(
 			decrease_allowed,
-			context->bw.dcn.calc_clk.dispclk_khz,
-			dc->current_state->bw.dcn.cur_clk.dispclk_khz)) {
+			context->bw.dcn.clk.dispclk_khz,
+			dc->res_pool->dccg->clks.dispclk_khz)) {
 
 		ramp_up_dispclk_with_dpp(dc, context);
 	}

commit 0d8be24134eddaf5acc937f59d58e62d869f0a6f
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue May 29 07:18:27 2018 -0700

    drm/amd/display: Use tg count for opp init.
    
    In case of tg count not equal to FE pipe count, if use pipe count to iterate
    the tgs, it will cause BSOD.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 09c7007868e8..64ca503cab42 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1010,7 +1010,7 @@ static void dcn10_init_hw(struct dc *dc)
 	/* Reset all MPCC muxes */
 	dc->res_pool->mpc->funcs->mpc_init(dc->res_pool->mpc);
 
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+	for (i = 0; i < dc->res_pool->timing_generator_count; i++) {
 		struct timing_generator *tg = dc->res_pool->timing_generators[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 		struct hubp *hubp = dc->res_pool->hubps[i];

commit e2e0a1dcd3229eec32ded439f69438a25ec817d6
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 23 17:52:04 2018 -0400

    drm/amd/display: move clock programming from set_bandwidth to dccg
    
    This change moves dcn clock programming(with exception of dispclk)
    into dccg. This should have no functional effect.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f519b98f4b23..09c7007868e8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2153,11 +2153,11 @@ static void dcn10_pplib_apply_display_requirements(
 {
 	struct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;
 
-	pp_display_cfg->min_engine_clock_khz = context->bw.dcn.cur_clk.dcfclk_khz;
-	pp_display_cfg->min_memory_clock_khz = context->bw.dcn.cur_clk.fclk_khz;
-	pp_display_cfg->min_engine_clock_deep_sleep_khz = context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz;
-	pp_display_cfg->min_dcfc_deep_sleep_clock_khz = context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz;
-	pp_display_cfg->min_dcfclock_khz = context->bw.dcn.cur_clk.dcfclk_khz;
+	pp_display_cfg->min_engine_clock_khz = dc->res_pool->dccg->clks.dcfclk_khz;
+	pp_display_cfg->min_memory_clock_khz = dc->res_pool->dccg->clks.fclk_khz;
+	pp_display_cfg->min_engine_clock_deep_sleep_khz = dc->res_pool->dccg->clks.dcfclk_deep_sleep_khz;
+	pp_display_cfg->min_dcfc_deep_sleep_clock_khz = dc->res_pool->dccg->clks.dcfclk_deep_sleep_khz;
+	pp_display_cfg->min_dcfclock_khz = dc->res_pool->dccg->clks.dcfclk_khz;
 	pp_display_cfg->disp_clk_khz = context->bw.dcn.cur_clk.dispclk_khz;
 	dce110_fill_display_configs(context, pp_display_cfg);
 
@@ -2361,11 +2361,6 @@ static void dcn10_apply_ctx_for_surface(
 */
 }
 
-static inline bool should_set_clock(bool decrease_allowed, int calc_clk, int cur_clk)
-{
-	return ((decrease_allowed && calc_clk < cur_clk) || calc_clk > cur_clk);
-}
-
 static int determine_dppclk_threshold(struct dc *dc, struct dc_state *context)
 {
 	bool request_dpp_div = context->bw.dcn.calc_clk.dispclk_khz >
@@ -2456,16 +2451,16 @@ static void ramp_up_dispclk_with_dpp(struct dc *dc, struct dc_state *context)
 			context->bw.dcn.calc_clk.max_supported_dppclk_khz;
 }
 
+static inline bool should_set_clock(bool safe_to_lower, int calc_clk, int cur_clk)
+{
+	return ((safe_to_lower && calc_clk < cur_clk) || calc_clk > cur_clk);
+}
+
 static void dcn10_set_bandwidth(
 		struct dc *dc,
 		struct dc_state *context,
 		bool decrease_allowed)
 {
-	struct pp_smu_display_requirement_rv *smu_req_cur =
-			&dc->res_pool->pp_smu_req;
-	struct pp_smu_display_requirement_rv smu_req = *smu_req_cur;
-	struct pp_smu_funcs_rv *pp_smu = dc->res_pool->pp_smu;
-
 	if (dc->debug.sanity_checks) {
 		dcn10_verify_allow_pstate_change_high(dc);
 	}
@@ -2473,45 +2468,14 @@ static void dcn10_set_bandwidth(
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
 		return;
 
+	if (context->stream_count == 0)
+		context->bw.dcn.calc_clk.phyclk_khz = 0;
+
 	dc->res_pool->dccg->funcs->update_clocks(
 			dc->res_pool->dccg,
 			&context->bw.dcn.calc_clk,
 			decrease_allowed);
 
-	if (should_set_clock(
-			decrease_allowed,
-			context->bw.dcn.calc_clk.dcfclk_khz,
-			dc->current_state->bw.dcn.cur_clk.dcfclk_khz)) {
-		context->bw.dcn.cur_clk.dcfclk_khz =
-				context->bw.dcn.calc_clk.dcfclk_khz;
-		smu_req.hard_min_dcefclk_khz =
-				context->bw.dcn.calc_clk.dcfclk_khz;
-	}
-
-	if (should_set_clock(
-			decrease_allowed,
-			context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz,
-			dc->current_state->bw.dcn.cur_clk.dcfclk_deep_sleep_khz)) {
-		context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz =
-				context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
-	}
-
-	if (should_set_clock(
-			decrease_allowed,
-			context->bw.dcn.calc_clk.fclk_khz,
-			dc->current_state->bw.dcn.cur_clk.fclk_khz)) {
-		context->bw.dcn.cur_clk.fclk_khz =
-				context->bw.dcn.calc_clk.fclk_khz;
-		smu_req.hard_min_fclk_khz = context->bw.dcn.calc_clk.fclk_khz;
-	}
-
-	smu_req.display_count = context->stream_count;
-
-	if (pp_smu->set_display_requirement)
-		pp_smu->set_display_requirement(&pp_smu->pp_smu, &smu_req);
-
-	*smu_req_cur = smu_req;
-
 	/* make sure dcf clk is before dpp clk to
 	 * make sure we have enough voltage to run dpp clk
 	 */

commit 6ca11246180a6e5e6b5b668545c2575b304c9f7f
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 23 16:44:26 2018 -0400

    drm/amd/display: rename display clock block to dccg
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7f1a7ec9ff5f..f519b98f4b23 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2424,8 +2424,8 @@ static void ramp_up_dispclk_with_dpp(struct dc *dc, struct dc_state *context)
 	int dispclk_to_dpp_threshold = determine_dppclk_threshold(dc, context);
 
 	/* set disp clk to dpp clk threshold */
-	dc->res_pool->display_clock->funcs->set_dispclk(
-			dc->res_pool->display_clock,
+	dc->res_pool->dccg->funcs->set_dispclk(
+			dc->res_pool->dccg,
 			dispclk_to_dpp_threshold);
 
 	/* update request dpp clk division option */
@@ -2443,8 +2443,8 @@ static void ramp_up_dispclk_with_dpp(struct dc *dc, struct dc_state *context)
 
 	/* If target clk not same as dppclk threshold, set to target clock */
 	if (dispclk_to_dpp_threshold != context->bw.dcn.calc_clk.dispclk_khz) {
-		dc->res_pool->display_clock->funcs->set_dispclk(
-				dc->res_pool->display_clock,
+		dc->res_pool->dccg->funcs->set_dispclk(
+				dc->res_pool->dccg,
 				context->bw.dcn.calc_clk.dispclk_khz);
 	}
 
@@ -2473,8 +2473,8 @@ static void dcn10_set_bandwidth(
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
 		return;
 
-	dc->res_pool->display_clock->funcs->update_clocks(
-			dc->res_pool->display_clock,
+	dc->res_pool->dccg->funcs->update_clocks(
+			dc->res_pool->dccg,
 			&context->bw.dcn.calc_clk,
 			decrease_allowed);
 

commit fab55d61b9f04693abc6fdbc92e3fdf3872915b1
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 23 16:21:54 2018 -0400

    drm/amd/display: redesign dce/dcn clock voltage update request
    
    The goal of this change is to move clock programming and voltage
    requests to a single function. As of this change only dce is affected.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 03eb736a312f..7f1a7ec9ff5f 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2424,7 +2424,7 @@ static void ramp_up_dispclk_with_dpp(struct dc *dc, struct dc_state *context)
 	int dispclk_to_dpp_threshold = determine_dppclk_threshold(dc, context);
 
 	/* set disp clk to dpp clk threshold */
-	dc->res_pool->display_clock->funcs->set_clock(
+	dc->res_pool->display_clock->funcs->set_dispclk(
 			dc->res_pool->display_clock,
 			dispclk_to_dpp_threshold);
 
@@ -2443,7 +2443,7 @@ static void ramp_up_dispclk_with_dpp(struct dc *dc, struct dc_state *context)
 
 	/* If target clk not same as dppclk threshold, set to target clock */
 	if (dispclk_to_dpp_threshold != context->bw.dcn.calc_clk.dispclk_khz) {
-		dc->res_pool->display_clock->funcs->set_clock(
+		dc->res_pool->display_clock->funcs->set_dispclk(
 				dc->res_pool->display_clock,
 				context->bw.dcn.calc_clk.dispclk_khz);
 	}
@@ -2473,6 +2473,11 @@ static void dcn10_set_bandwidth(
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
 		return;
 
+	dc->res_pool->display_clock->funcs->update_clocks(
+			dc->res_pool->display_clock,
+			&context->bw.dcn.calc_clk,
+			decrease_allowed);
+
 	if (should_set_clock(
 			decrease_allowed,
 			context->bw.dcn.calc_clk.dcfclk_khz,

commit 1a05873f21d6192575382afd2feb18df935e46f0
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu May 10 14:21:47 2018 -0400

    drm/amd/display: Refactor audio programming
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 52924ef50db6..03eb736a312f 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -719,19 +719,7 @@ static void reset_back_end_for_pipe(
 		if (!pipe_ctx->stream->dpms_off)
 			core_link_disable_stream(pipe_ctx, FREE_ACQUIRED_RESOURCE);
 		else if (pipe_ctx->stream_res.audio) {
-			/*
-			 * if stream is already disabled outside of commit streams path,
-			 * audio disable was skipped. Need to do it here
-			 */
-			pipe_ctx->stream_res.audio->funcs->az_disable(pipe_ctx->stream_res.audio);
-
-			if (dc->caps.dynamic_audio == true) {
-				/*we have to dynamic arbitrate the audio endpoints*/
-				pipe_ctx->stream_res.audio = NULL;
-				/*we free the resource, need reset is_audio_acquired*/
-				update_audio_usage(&dc->current_state->res_ctx, dc->res_pool, pipe_ctx->stream_res.audio, false);
-			}
-
+			dc->hwss.disable_audio_stream(pipe_ctx, FREE_ACQUIRED_RESOURCE);
 		}
 
 	}
@@ -2778,6 +2766,8 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.disable_stream = dce110_disable_stream,
 	.unblank_stream = dce110_unblank_stream,
 	.blank_stream = dce110_blank_stream,
+	.enable_audio_stream = dce110_enable_audio_stream,
+	.disable_audio_stream = dce110_disable_audio_stream,
 	.enable_display_power_gating = dcn10_dummy_display_power_gating,
 	.disable_plane = dcn10_disable_plane,
 	.blank_pixel_data = dcn10_blank_pixel_data,

commit ea4a202053c94b1be0e056b66032961523cc9aa3
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Tue May 1 15:21:42 2018 -0400

    drm/amd/display: pass pipe_ctx straight to blank_pixel_data
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f8e0576af6e0..52924ef50db6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2063,12 +2063,13 @@ static void update_dchubp_dpp(
 
 static void dcn10_blank_pixel_data(
 		struct dc *dc,
-		struct stream_resource *stream_res,
-		struct dc_stream_state *stream,
+		struct pipe_ctx *pipe_ctx,
 		bool blank)
 {
 	enum dc_color_space color_space;
 	struct tg_color black_color = {0};
+	struct stream_resource *stream_res = &pipe_ctx->stream_res;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 
 	/* program otg blank color */
 	color_space = stream->output_color_space;
@@ -2127,8 +2128,7 @@ static void program_all_pipe_in_tree(
 		pipe_ctx->stream_res.tg->funcs->program_global_sync(
 				pipe_ctx->stream_res.tg);
 
-		dc->hwss.blank_pixel_data(dc, &pipe_ctx->stream_res,
-				pipe_ctx->stream, blank);
+		dc->hwss.blank_pixel_data(dc, pipe_ctx, blank);
 	}
 
 	if (pipe_ctx->plane_state != NULL) {
@@ -2247,7 +2247,7 @@ static void dcn10_apply_ctx_for_surface(
 
 	if (num_planes == 0) {
 		/* OTG blank before remove all front end */
-		dc->hwss.blank_pixel_data(dc, &top_pipe_to_program->stream_res, top_pipe_to_program->stream, true);
+		dc->hwss.blank_pixel_data(dc, top_pipe_to_program, true);
 	}
 
 	/* Disconnect unused mpcc */

commit a944744ba517256fcc9311e12c083563cbbe7c88
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Fri Apr 27 17:26:25 2018 -0400

    drm/amd/display: Clear underflow status for debug purposes
    
    We want to keep underflow sticky bit on for the longevity tests outside
    of test environment. For debug purposes it is, however, useful to clear
    underflow status after the test that caused it so that the following
    tests are not affected. This change fullfils both requirements by clearing
    the underflow only from within Windows or Diags test environment.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c452972bf1c3..f8e0576af6e0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -326,6 +326,12 @@ void dcn10_log_hw_state(struct dc *dc)
 				s.h_total,
 				s.v_total,
 				s.underflow_occurred_status);
+
+		// Clear underflow for debug purposes
+		// We want to keep underflow sticky bit on for the longevity tests outside of test environment.
+		// This function is called only from Windows or Diags test environment, hence it's safe to clear
+		// it from here without affecting the original intent.
+		tg->funcs->clear_optc_underflow(tg);
 	}
 	DTN_INFO("\n");
 

commit a3cb1c1c8e5e494f7630349fbebb79b1787128a1
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Mon Apr 23 15:55:36 2018 -0400

    drm/amd/display: Log DTN only after the atomic commit in Diag
    
    Also print HUBP info only if pipe enabled. This fixes having different
    DTN logs for different test sequences.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 24bcc5e58720..c452972bf1c3 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -127,24 +127,26 @@ static void dcn10_log_hubp_states(struct dc *dc)
 
 		hubp->funcs->hubp_read_state(hubp);
 
-		DTN_INFO("[%2d]:  %5xh  %6xh  %5d  %6d  %2xh  %2xh  %6xh"
-				"  %6d  %8d  %7d  %8xh",
-				hubp->inst,
-				s->pixel_format,
-				s->inuse_addr_hi,
-				s->viewport_width,
-				s->viewport_height,
-				s->rotation_angle,
-				s->h_mirror_en,
-				s->sw_mode,
-				s->dcc_en,
-				s->blank_en,
-				s->ttu_disable,
-				s->underflow_status);
-		DTN_INFO_MICRO_SEC(s->min_ttu_vblank);
-		DTN_INFO_MICRO_SEC(s->qos_level_low_wm);
-		DTN_INFO_MICRO_SEC(s->qos_level_high_wm);
-		DTN_INFO("\n");
+		if (!s->blank_en) {
+			DTN_INFO("[%2d]:  %5xh  %6xh  %5d  %6d  %2xh  %2xh  %6xh"
+					"  %6d  %8d  %7d  %8xh",
+					hubp->inst,
+					s->pixel_format,
+					s->inuse_addr_hi,
+					s->viewport_width,
+					s->viewport_height,
+					s->rotation_angle,
+					s->h_mirror_en,
+					s->sw_mode,
+					s->dcc_en,
+					s->blank_en,
+					s->ttu_disable,
+					s->underflow_status);
+			DTN_INFO_MICRO_SEC(s->min_ttu_vblank);
+			DTN_INFO_MICRO_SEC(s->qos_level_low_wm);
+			DTN_INFO_MICRO_SEC(s->qos_level_high_wm);
+			DTN_INFO("\n");
+		}
 	}
 
 	DTN_INFO("\n=========RQ========\n");
@@ -155,16 +157,17 @@ static void dcn10_log_hubp_states(struct dc *dc)
 		struct dcn_hubp_state *s = &(TO_DCN10_HUBP(pool->hubps[i])->state);
 		struct _vcs_dpi_display_rq_regs_st *rq_regs = &s->rq_regs;
 
-		DTN_INFO("[%2d]:  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\n",
-			i, rq_regs->drq_expansion_mode, rq_regs->prq_expansion_mode, rq_regs->mrq_expansion_mode,
-			rq_regs->crq_expansion_mode, rq_regs->plane1_base_address, rq_regs->rq_regs_l.chunk_size,
-			rq_regs->rq_regs_l.min_chunk_size, rq_regs->rq_regs_l.meta_chunk_size,
-			rq_regs->rq_regs_l.min_meta_chunk_size, rq_regs->rq_regs_l.dpte_group_size,
-			rq_regs->rq_regs_l.mpte_group_size, rq_regs->rq_regs_l.swath_height,
-			rq_regs->rq_regs_l.pte_row_height_linear, rq_regs->rq_regs_c.chunk_size, rq_regs->rq_regs_c.min_chunk_size,
-			rq_regs->rq_regs_c.meta_chunk_size, rq_regs->rq_regs_c.min_meta_chunk_size,
-			rq_regs->rq_regs_c.dpte_group_size, rq_regs->rq_regs_c.mpte_group_size,
-			rq_regs->rq_regs_c.swath_height, rq_regs->rq_regs_c.pte_row_height_linear);
+		if (!s->blank_en)
+			DTN_INFO("[%2d]:  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\n",
+				pool->hubps[i]->inst, rq_regs->drq_expansion_mode, rq_regs->prq_expansion_mode, rq_regs->mrq_expansion_mode,
+				rq_regs->crq_expansion_mode, rq_regs->plane1_base_address, rq_regs->rq_regs_l.chunk_size,
+				rq_regs->rq_regs_l.min_chunk_size, rq_regs->rq_regs_l.meta_chunk_size,
+				rq_regs->rq_regs_l.min_meta_chunk_size, rq_regs->rq_regs_l.dpte_group_size,
+				rq_regs->rq_regs_l.mpte_group_size, rq_regs->rq_regs_l.swath_height,
+				rq_regs->rq_regs_l.pte_row_height_linear, rq_regs->rq_regs_c.chunk_size, rq_regs->rq_regs_c.min_chunk_size,
+				rq_regs->rq_regs_c.meta_chunk_size, rq_regs->rq_regs_c.min_meta_chunk_size,
+				rq_regs->rq_regs_c.dpte_group_size, rq_regs->rq_regs_c.mpte_group_size,
+				rq_regs->rq_regs_c.swath_height, rq_regs->rq_regs_c.pte_row_height_linear);
 	}
 
 	DTN_INFO("========DLG========\n");
@@ -179,27 +182,28 @@ static void dcn10_log_hubp_states(struct dc *dc)
 		struct dcn_hubp_state *s = &(TO_DCN10_HUBP(pool->hubps[i])->state);
 		struct _vcs_dpi_display_dlg_regs_st *dlg_regs = &s->dlg_attr;
 
-		DTN_INFO("[%2d]:  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh"
-			"%  8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh"
-			"  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\n",
-			i, dlg_regs->refcyc_h_blank_end, dlg_regs->dlg_vblank_end, dlg_regs->min_dst_y_next_start,
-			dlg_regs->refcyc_per_htotal, dlg_regs->refcyc_x_after_scaler, dlg_regs->dst_y_after_scaler,
-			dlg_regs->dst_y_prefetch, dlg_regs->dst_y_per_vm_vblank, dlg_regs->dst_y_per_row_vblank,
-			dlg_regs->dst_y_per_vm_flip, dlg_regs->dst_y_per_row_flip, dlg_regs->ref_freq_to_pix_freq,
-			dlg_regs->vratio_prefetch, dlg_regs->vratio_prefetch_c, dlg_regs->refcyc_per_pte_group_vblank_l,
-			dlg_regs->refcyc_per_pte_group_vblank_c, dlg_regs->refcyc_per_meta_chunk_vblank_l,
-			dlg_regs->refcyc_per_meta_chunk_vblank_c, dlg_regs->refcyc_per_pte_group_flip_l,
-			dlg_regs->refcyc_per_pte_group_flip_c, dlg_regs->refcyc_per_meta_chunk_flip_l,
-			dlg_regs->refcyc_per_meta_chunk_flip_c, dlg_regs->dst_y_per_pte_row_nom_l,
-			dlg_regs->dst_y_per_pte_row_nom_c, dlg_regs->refcyc_per_pte_group_nom_l,
-			dlg_regs->refcyc_per_pte_group_nom_c, dlg_regs->dst_y_per_meta_row_nom_l,
-			dlg_regs->dst_y_per_meta_row_nom_c, dlg_regs->refcyc_per_meta_chunk_nom_l,
-			dlg_regs->refcyc_per_meta_chunk_nom_c, dlg_regs->refcyc_per_line_delivery_pre_l,
-			dlg_regs->refcyc_per_line_delivery_pre_c, dlg_regs->refcyc_per_line_delivery_l,
-			dlg_regs->refcyc_per_line_delivery_c, dlg_regs->chunk_hdl_adjust_cur0, dlg_regs->dst_y_offset_cur1,
-			dlg_regs->chunk_hdl_adjust_cur1, dlg_regs->vready_after_vcount0, dlg_regs->dst_y_delta_drq_limit,
-			dlg_regs->xfc_reg_transfer_delay, dlg_regs->xfc_reg_precharge_delay,
-			dlg_regs->xfc_reg_remote_surface_flip_latency);
+		if (!s->blank_en)
+			DTN_INFO("[%2d]:  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh"
+				"%  8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh"
+				"  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\n",
+				pool->hubps[i]->inst, dlg_regs->refcyc_h_blank_end, dlg_regs->dlg_vblank_end, dlg_regs->min_dst_y_next_start,
+				dlg_regs->refcyc_per_htotal, dlg_regs->refcyc_x_after_scaler, dlg_regs->dst_y_after_scaler,
+				dlg_regs->dst_y_prefetch, dlg_regs->dst_y_per_vm_vblank, dlg_regs->dst_y_per_row_vblank,
+				dlg_regs->dst_y_per_vm_flip, dlg_regs->dst_y_per_row_flip, dlg_regs->ref_freq_to_pix_freq,
+				dlg_regs->vratio_prefetch, dlg_regs->vratio_prefetch_c, dlg_regs->refcyc_per_pte_group_vblank_l,
+				dlg_regs->refcyc_per_pte_group_vblank_c, dlg_regs->refcyc_per_meta_chunk_vblank_l,
+				dlg_regs->refcyc_per_meta_chunk_vblank_c, dlg_regs->refcyc_per_pte_group_flip_l,
+				dlg_regs->refcyc_per_pte_group_flip_c, dlg_regs->refcyc_per_meta_chunk_flip_l,
+				dlg_regs->refcyc_per_meta_chunk_flip_c, dlg_regs->dst_y_per_pte_row_nom_l,
+				dlg_regs->dst_y_per_pte_row_nom_c, dlg_regs->refcyc_per_pte_group_nom_l,
+				dlg_regs->refcyc_per_pte_group_nom_c, dlg_regs->dst_y_per_meta_row_nom_l,
+				dlg_regs->dst_y_per_meta_row_nom_c, dlg_regs->refcyc_per_meta_chunk_nom_l,
+				dlg_regs->refcyc_per_meta_chunk_nom_c, dlg_regs->refcyc_per_line_delivery_pre_l,
+				dlg_regs->refcyc_per_line_delivery_pre_c, dlg_regs->refcyc_per_line_delivery_l,
+				dlg_regs->refcyc_per_line_delivery_c, dlg_regs->chunk_hdl_adjust_cur0, dlg_regs->dst_y_offset_cur1,
+				dlg_regs->chunk_hdl_adjust_cur1, dlg_regs->vready_after_vcount0, dlg_regs->dst_y_delta_drq_limit,
+				dlg_regs->xfc_reg_transfer_delay, dlg_regs->xfc_reg_precharge_delay,
+				dlg_regs->xfc_reg_remote_surface_flip_latency);
 	}
 
 	DTN_INFO("========TTU========\n");
@@ -210,14 +214,15 @@ static void dcn10_log_hubp_states(struct dc *dc)
 		struct dcn_hubp_state *s = &(TO_DCN10_HUBP(pool->hubps[i])->state);
 		struct _vcs_dpi_display_ttu_regs_st *ttu_regs = &s->ttu_attr;
 
-		DTN_INFO("[%2d]:  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\n",
-			i, ttu_regs->qos_level_low_wm, ttu_regs->qos_level_high_wm, ttu_regs->min_ttu_vblank,
-			ttu_regs->qos_level_flip, ttu_regs->refcyc_per_req_delivery_pre_l, ttu_regs->refcyc_per_req_delivery_l,
-			ttu_regs->refcyc_per_req_delivery_pre_c, ttu_regs->refcyc_per_req_delivery_c, ttu_regs->refcyc_per_req_delivery_cur0,
-			ttu_regs->refcyc_per_req_delivery_pre_cur0, ttu_regs->refcyc_per_req_delivery_cur1,
-			ttu_regs->refcyc_per_req_delivery_pre_cur1, ttu_regs->qos_level_fixed_l, ttu_regs->qos_ramp_disable_l,
-			ttu_regs->qos_level_fixed_c, ttu_regs->qos_ramp_disable_c, ttu_regs->qos_level_fixed_cur0,
-			ttu_regs->qos_ramp_disable_cur0, ttu_regs->qos_level_fixed_cur1, ttu_regs->qos_ramp_disable_cur1);
+		if (!s->blank_en)
+			DTN_INFO("[%2d]:  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\n",
+				pool->hubps[i]->inst, ttu_regs->qos_level_low_wm, ttu_regs->qos_level_high_wm, ttu_regs->min_ttu_vblank,
+				ttu_regs->qos_level_flip, ttu_regs->refcyc_per_req_delivery_pre_l, ttu_regs->refcyc_per_req_delivery_l,
+				ttu_regs->refcyc_per_req_delivery_pre_c, ttu_regs->refcyc_per_req_delivery_c, ttu_regs->refcyc_per_req_delivery_cur0,
+				ttu_regs->refcyc_per_req_delivery_pre_cur0, ttu_regs->refcyc_per_req_delivery_cur1,
+				ttu_regs->refcyc_per_req_delivery_pre_cur1, ttu_regs->qos_level_fixed_l, ttu_regs->qos_ramp_disable_l,
+				ttu_regs->qos_level_fixed_c, ttu_regs->qos_ramp_disable_c, ttu_regs->qos_level_fixed_cur0,
+				ttu_regs->qos_ramp_disable_cur0, ttu_regs->qos_level_fixed_cur1, ttu_regs->qos_ramp_disable_cur1);
 	}
 	DTN_INFO("\n");
 }

commit 6b8e1eb7c6e059d8bb52f24b13081205242fded9
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Tue Apr 17 16:50:28 2018 -0400

    drm/amd/display: Update HW sequencer initialization
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index be8820d8a2e6..24bcc5e58720 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -849,7 +849,7 @@ static void dcn10_verify_allow_pstate_change_high(struct dc *dc)
 }
 
 /* trigger HW to start disconnect plane from stream on the next vsync */
-static void plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
+void hwss1_plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	int dpp_id = pipe_ctx->plane_res.dpp->inst;
@@ -1032,7 +1032,7 @@ static void dcn10_init_hw(struct dc *dc)
 		dc->res_pool->opps[i]->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;
 		pipe_ctx->stream_res.opp = dc->res_pool->opps[i];
 
-		plane_atomic_disconnect(dc, pipe_ctx);
+		hwss1_plane_atomic_disconnect(dc, pipe_ctx);
 	}
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
@@ -2267,7 +2267,7 @@ static void dcn10_apply_ctx_for_surface(
 			old_pipe_ctx->plane_state &&
 			old_pipe_ctx->stream_res.tg == tg) {
 
-			plane_atomic_disconnect(dc, old_pipe_ctx);
+			hwss1_plane_atomic_disconnect(dc, old_pipe_ctx);
 			removed_pipe[i] = true;
 
 			DC_LOG_DC(

commit 3ba43a59927fbde07414393dfc2b6753cb233e00
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Apr 18 14:31:41 2018 -0400

    drm/amd/display: underflow/blankscreen recovery
    
    [Description]
    for any reason, if driver detects HUBP underflow,
    if a debug option enabled to enable recovery.
    it will kick in a sequence of recovery.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 50bd7548e230..be8820d8a2e6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -747,6 +747,90 @@ static void reset_back_end_for_pipe(
 					pipe_ctx->pipe_idx, pipe_ctx->stream_res.tg->inst);
 }
 
+static bool dcn10_hw_wa_force_recovery(struct dc *dc)
+{
+	struct hubp *hubp ;
+	unsigned int i;
+	bool need_recover = true;
+
+	if (!dc->debug.recovery_enabled)
+		return false;
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx =
+			&dc->current_state->res_ctx.pipe_ctx[i];
+		if (pipe_ctx != NULL) {
+			hubp = pipe_ctx->plane_res.hubp;
+			if (hubp != NULL) {
+				if (hubp->funcs->hubp_get_underflow_status(hubp) != 0) {
+					/* one pipe underflow, we will reset all the pipes*/
+					need_recover = true;
+				}
+			}
+		}
+	}
+	if (!need_recover)
+		return false;
+	/*
+	DCHUBP_CNTL:HUBP_BLANK_EN=1
+	DCHUBBUB_SOFT_RESET:DCHUBBUB_GLOBAL_SOFT_RESET=1
+	DCHUBP_CNTL:HUBP_DISABLE=1
+	DCHUBP_CNTL:HUBP_DISABLE=0
+	DCHUBBUB_SOFT_RESET:DCHUBBUB_GLOBAL_SOFT_RESET=0
+	DCSURF_PRIMARY_SURFACE_ADDRESS
+	DCHUBP_CNTL:HUBP_BLANK_EN=0
+	*/
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx =
+			&dc->current_state->res_ctx.pipe_ctx[i];
+		if (pipe_ctx != NULL) {
+			hubp = pipe_ctx->plane_res.hubp;
+			/*DCHUBP_CNTL:HUBP_BLANK_EN=1*/
+			if (hubp != NULL)
+				hubp->funcs->set_hubp_blank_en(hubp, true);
+		}
+	}
+	/*DCHUBBUB_SOFT_RESET:DCHUBBUB_GLOBAL_SOFT_RESET=1*/
+	hubbub1_soft_reset(dc->res_pool->hubbub, true);
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx =
+			&dc->current_state->res_ctx.pipe_ctx[i];
+		if (pipe_ctx != NULL) {
+			hubp = pipe_ctx->plane_res.hubp;
+			/*DCHUBP_CNTL:HUBP_DISABLE=1*/
+			if (hubp != NULL)
+				hubp->funcs->hubp_disable_control(hubp, true);
+		}
+	}
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx =
+			&dc->current_state->res_ctx.pipe_ctx[i];
+		if (pipe_ctx != NULL) {
+			hubp = pipe_ctx->plane_res.hubp;
+			/*DCHUBP_CNTL:HUBP_DISABLE=0*/
+			if (hubp != NULL)
+				hubp->funcs->hubp_disable_control(hubp, true);
+		}
+	}
+	/*DCHUBBUB_SOFT_RESET:DCHUBBUB_GLOBAL_SOFT_RESET=0*/
+	hubbub1_soft_reset(dc->res_pool->hubbub, false);
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx =
+			&dc->current_state->res_ctx.pipe_ctx[i];
+		if (pipe_ctx != NULL) {
+			hubp = pipe_ctx->plane_res.hubp;
+			/*DCHUBP_CNTL:HUBP_BLANK_EN=0*/
+			if (hubp != NULL)
+				hubp->funcs->set_hubp_blank_en(hubp, true);
+		}
+	}
+	return true;
+
+}
+
+
 static void dcn10_verify_allow_pstate_change_high(struct dc *dc)
 {
 	static bool should_log_hw_state; /* prevent hw state log by default */
@@ -755,8 +839,12 @@ static void dcn10_verify_allow_pstate_change_high(struct dc *dc)
 		if (should_log_hw_state) {
 			dcn10_log_hw_state(dc);
 		}
-
 		BREAK_TO_DEBUGGER();
+		if (dcn10_hw_wa_force_recovery(dc)) {
+		/*check again*/
+			if (!hubbub1_verify_allow_pstate_change_high(dc->res_pool->hubbub))
+				BREAK_TO_DEBUGGER();
+		}
 	}
 }
 

commit eb0e515464e4a1be730c7ac7a01c3ba04c98ea97
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Apr 18 11:37:53 2018 -0400

    drm/amd/display: get rid of 32.32 unsigned fixed point
    
    32.32 is redundant, 31.32 does everything we use 32.32 for
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 8adb8dc44af5..50bd7548e230 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1685,22 +1685,22 @@ static uint16_t fixed_point_to_int_frac(
 
 	uint16_t result;
 
-	uint16_t d = (uint16_t)dal_fixed31_32_floor(
-		dal_fixed31_32_abs(
+	uint16_t d = (uint16_t)dc_fixpt_floor(
+		dc_fixpt_abs(
 			arg));
 
 	if (d <= (uint16_t)(1 << integer_bits) - (1 / (uint16_t)divisor))
-		numerator = (uint16_t)dal_fixed31_32_floor(
-			dal_fixed31_32_mul_int(
+		numerator = (uint16_t)dc_fixpt_floor(
+			dc_fixpt_mul_int(
 				arg,
 				divisor));
 	else {
-		numerator = dal_fixed31_32_floor(
-			dal_fixed31_32_sub(
-				dal_fixed31_32_from_int(
+		numerator = dc_fixpt_floor(
+			dc_fixpt_sub(
+				dc_fixpt_from_int(
 					1LL << integer_bits),
-				dal_fixed31_32_recip(
-					dal_fixed31_32_from_int(
+				dc_fixpt_recip(
+					dc_fixpt_from_int(
 						divisor))));
 	}
 
@@ -1710,8 +1710,8 @@ static uint16_t fixed_point_to_int_frac(
 		result = (uint16_t)(
 		(1 << (integer_bits + fractional_bits + 1)) + numerator);
 
-	if ((result != 0) && dal_fixed31_32_lt(
-		arg, dal_fixed31_32_zero))
+	if ((result != 0) && dc_fixpt_lt(
+		arg, dc_fixpt_zero))
 		result |= 1 << (integer_bits + fractional_bits);
 
 	return result;
@@ -1725,8 +1725,8 @@ void build_prescale_params(struct  dc_bias_and_scale *bias_and_scale,
 			&& plane_state->input_csc_color_matrix.enable_adjustment
 			&& plane_state->coeff_reduction_factor.value != 0) {
 		bias_and_scale->scale_blue = fixed_point_to_int_frac(
-			dal_fixed31_32_mul(plane_state->coeff_reduction_factor,
-					dal_fixed31_32_from_fraction(256, 255)),
+			dc_fixpt_mul(plane_state->coeff_reduction_factor,
+					dc_fixpt_from_fraction(256, 255)),
 				2,
 				13);
 		bias_and_scale->scale_red = bias_and_scale->scale_blue;
@@ -1995,7 +1995,7 @@ static void dcn10_blank_pixel_data(
 
 static void set_hdr_multiplier(struct pipe_ctx *pipe_ctx)
 {
-	struct fixed31_32 multiplier = dal_fixed31_32_from_fraction(
+	struct fixed31_32 multiplier = dc_fixpt_from_fraction(
 			pipe_ctx->plane_state->sdr_white_level, 80);
 	uint32_t hw_mult = 0x1f000; // 1.0 default multiplier
 	struct custom_float_format fmt;

commit b79655c37b209315d3b533f6d63a3d6f5fcb6f84
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Apr 12 22:40:02 2018 -0400

    drm/amd/display: Cleanup unused SetPlaneConfig
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 572fa601a0eb..8adb8dc44af5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2487,15 +2487,6 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
 			set_static_screen_control(pipe_ctx[i]->stream_res.tg, value);
 }
 
-static void set_plane_config(
-	const struct dc *dc,
-	struct pipe_ctx *pipe_ctx,
-	struct resource_context *res_ctx)
-{
-	/* TODO */
-	program_gamut_remap(pipe_ctx);
-}
-
 static void dcn10_config_stereo_parameters(
 		struct dc_stream_state *stream, struct crtc_stereo_flags *flags)
 {
@@ -2673,7 +2664,6 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.init_hw = dcn10_init_hw,
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
 	.apply_ctx_for_surface = dcn10_apply_ctx_for_surface,
-	.set_plane_config = set_plane_config,
 	.update_plane_addr = dcn10_update_plane_addr,
 	.update_dchub = dcn10_update_dchub,
 	.update_pending_status = dcn10_update_pending_status,

commit 34cb6b3860a4aecafaae0df8fa84b6fc784f507c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Apr 11 11:51:32 2018 -0400

    drm/amd/display: compact the rq/dlg/ttu log
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 574d37cdfa20..572fa601a0eb 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -112,143 +112,127 @@ void dcn10_log_hubbub_state(struct dc *dc)
 	DTN_INFO("\n");
 }
 
-static void print_rq_dlg_ttu_regs(struct dc_context *dc_ctx, struct dcn_hubp_state *s)
-{
-	struct _vcs_dpi_display_dlg_regs_st *dlg_regs = &s->dlg_attr;
-	struct _vcs_dpi_display_ttu_regs_st *ttu_regs = &s->ttu_attr;
-	struct _vcs_dpi_display_rq_regs_st *rq_regs = &s->rq_regs;
-
-	DTN_INFO("========Requester========\n");
-	DTN_INFO("drq_expansion_mode      = 0x%0x\n", rq_regs->drq_expansion_mode);
-	DTN_INFO("prq_expansion_mode      = 0x%0x\n", rq_regs->prq_expansion_mode);
-	DTN_INFO("mrq_expansion_mode      = 0x%0x\n", rq_regs->mrq_expansion_mode);
-	DTN_INFO("crq_expansion_mode      = 0x%0x\n", rq_regs->crq_expansion_mode);
-	DTN_INFO("plane1_base_address     = 0x%0x\n", rq_regs->plane1_base_address);
-	DTN_INFO("==<LUMA>==\n");
-	DTN_INFO("chunk_size              = 0x%0x\n", rq_regs->rq_regs_l.chunk_size);
-	DTN_INFO("min_chunk_size          = 0x%0x\n", rq_regs->rq_regs_l.min_chunk_size);
-	DTN_INFO("meta_chunk_size         = 0x%0x\n", rq_regs->rq_regs_l.meta_chunk_size);
-	DTN_INFO("min_meta_chunk_size     = 0x%0x\n", rq_regs->rq_regs_l.min_meta_chunk_size);
-	DTN_INFO("dpte_group_size         = 0x%0x\n", rq_regs->rq_regs_l.dpte_group_size);
-	DTN_INFO("mpte_group_size         = 0x%0x\n", rq_regs->rq_regs_l.mpte_group_size);
-	DTN_INFO("swath_height            = 0x%0x\n", rq_regs->rq_regs_l.swath_height);
-	DTN_INFO("pte_row_height_linear   = 0x%0x\n", rq_regs->rq_regs_l.pte_row_height_linear);
-	DTN_INFO("==<CHROMA>==\n");
-	DTN_INFO("chunk_size              = 0x%0x\n", rq_regs->rq_regs_c.chunk_size);
-	DTN_INFO("min_chunk_size          = 0x%0x\n", rq_regs->rq_regs_c.min_chunk_size);
-	DTN_INFO("meta_chunk_size         = 0x%0x\n", rq_regs->rq_regs_c.meta_chunk_size);
-	DTN_INFO("min_meta_chunk_size     = 0x%0x\n", rq_regs->rq_regs_c.min_meta_chunk_size);
-	DTN_INFO("dpte_group_size         = 0x%0x\n", rq_regs->rq_regs_c.dpte_group_size);
-	DTN_INFO("mpte_group_size         = 0x%0x\n", rq_regs->rq_regs_c.mpte_group_size);
-	DTN_INFO("swath_height            = 0x%0x\n", rq_regs->rq_regs_c.swath_height);
-	DTN_INFO("pte_row_height_linear   = 0x%0x\n", rq_regs->rq_regs_c.pte_row_height_linear);
-
-	DTN_INFO("========DLG========\n");
-	DTN_INFO("refcyc_h_blank_end                  = 0x%0x\n", dlg_regs->refcyc_h_blank_end);
-	DTN_INFO("dlg_vblank_end                      = 0x%0x\n", dlg_regs->dlg_vblank_end);
-	DTN_INFO("min_dst_y_next_start                = 0x%0x\n", dlg_regs->min_dst_y_next_start);
-	DTN_INFO("refcyc_per_htotal                   = 0x%0x\n", dlg_regs->refcyc_per_htotal);
-	DTN_INFO("refcyc_x_after_scaler               = 0x%0x\n", dlg_regs->refcyc_x_after_scaler);
-	DTN_INFO("dst_y_after_scaler                  = 0x%0x\n", dlg_regs->dst_y_after_scaler);
-	DTN_INFO("dst_y_prefetch                      = 0x%0x\n", dlg_regs->dst_y_prefetch);
-	DTN_INFO("dst_y_per_vm_vblank                 = 0x%0x\n", dlg_regs->dst_y_per_vm_vblank);
-	DTN_INFO("dst_y_per_row_vblank                = 0x%0x\n", dlg_regs->dst_y_per_row_vblank);
-	DTN_INFO("dst_y_per_vm_flip                   = 0x%0x\n", dlg_regs->dst_y_per_vm_flip);
-	DTN_INFO("dst_y_per_row_flip                  = 0x%0x\n", dlg_regs->dst_y_per_row_flip);
-	DTN_INFO("ref_freq_to_pix_freq                = 0x%0x\n", dlg_regs->ref_freq_to_pix_freq);
-	DTN_INFO("vratio_prefetch                     = 0x%0x\n", dlg_regs->vratio_prefetch);
-	DTN_INFO("vratio_prefetch_c                   = 0x%0x\n", dlg_regs->vratio_prefetch_c);
-	DTN_INFO("refcyc_per_pte_group_vblank_l       = 0x%0x\n", dlg_regs->refcyc_per_pte_group_vblank_l);
-	DTN_INFO("refcyc_per_pte_group_vblank_c       = 0x%0x\n", dlg_regs->refcyc_per_pte_group_vblank_c);
-	DTN_INFO("refcyc_per_meta_chunk_vblank_l      = 0x%0x\n", dlg_regs->refcyc_per_meta_chunk_vblank_l);
-	DTN_INFO("refcyc_per_meta_chunk_vblank_c      = 0x%0x\n", dlg_regs->refcyc_per_meta_chunk_vblank_c);
-	DTN_INFO("refcyc_per_pte_group_flip_l         = 0x%0x\n", dlg_regs->refcyc_per_pte_group_flip_l);
-	DTN_INFO("refcyc_per_pte_group_flip_c         = 0x%0x\n", dlg_regs->refcyc_per_pte_group_flip_c);
-	DTN_INFO("refcyc_per_meta_chunk_flip_l        = 0x%0x\n", dlg_regs->refcyc_per_meta_chunk_flip_l);
-	DTN_INFO("refcyc_per_meta_chunk_flip_c        = 0x%0x\n", dlg_regs->refcyc_per_meta_chunk_flip_c);
-	DTN_INFO("dst_y_per_pte_row_nom_l             = 0x%0x\n", dlg_regs->dst_y_per_pte_row_nom_l);
-	DTN_INFO("dst_y_per_pte_row_nom_c             = 0x%0x\n", dlg_regs->dst_y_per_pte_row_nom_c);
-	DTN_INFO("refcyc_per_pte_group_nom_l          = 0x%0x\n", dlg_regs->refcyc_per_pte_group_nom_l);
-	DTN_INFO("refcyc_per_pte_group_nom_c          = 0x%0x\n", dlg_regs->refcyc_per_pte_group_nom_c);
-	DTN_INFO("dst_y_per_meta_row_nom_l            = 0x%0x\n", dlg_regs->dst_y_per_meta_row_nom_l);
-	DTN_INFO("dst_y_per_meta_row_nom_c            = 0x%0x\n", dlg_regs->dst_y_per_meta_row_nom_c);
-	DTN_INFO("refcyc_per_meta_chunk_nom_l         = 0x%0x\n", dlg_regs->refcyc_per_meta_chunk_nom_l);
-	DTN_INFO("refcyc_per_meta_chunk_nom_c         = 0x%0x\n", dlg_regs->refcyc_per_meta_chunk_nom_c);
-	DTN_INFO("refcyc_per_line_delivery_pre_l      = 0x%0x\n", dlg_regs->refcyc_per_line_delivery_pre_l);
-	DTN_INFO("refcyc_per_line_delivery_pre_c      = 0x%0x\n", dlg_regs->refcyc_per_line_delivery_pre_c);
-	DTN_INFO("refcyc_per_line_delivery_l          = 0x%0x\n", dlg_regs->refcyc_per_line_delivery_l);
-	DTN_INFO("refcyc_per_line_delivery_c          = 0x%0x\n", dlg_regs->refcyc_per_line_delivery_c);
-	DTN_INFO("chunk_hdl_adjust_cur0               = 0x%0x\n", dlg_regs->chunk_hdl_adjust_cur0);
-	DTN_INFO("dst_y_offset_cur1                   = 0x%0x\n", dlg_regs->dst_y_offset_cur1);
-	DTN_INFO("chunk_hdl_adjust_cur1               = 0x%0x\n", dlg_regs->chunk_hdl_adjust_cur1);
-	DTN_INFO("vready_after_vcount0                = 0x%0x\n", dlg_regs->vready_after_vcount0);
-	DTN_INFO("dst_y_delta_drq_limit               = 0x%0x\n", dlg_regs->dst_y_delta_drq_limit);
-	DTN_INFO("xfc_reg_transfer_delay              = 0x%0x\n", dlg_regs->xfc_reg_transfer_delay);
-	DTN_INFO("xfc_reg_precharge_delay             = 0x%0x\n", dlg_regs->xfc_reg_precharge_delay);
-	DTN_INFO("xfc_reg_remote_surface_flip_latency = 0x%0x\n", dlg_regs->xfc_reg_remote_surface_flip_latency);
-
-	DTN_INFO("========TTU========\n");
-	DTN_INFO("qos_level_low_wm                  = 0x%0x\n", ttu_regs->qos_level_low_wm);
-	DTN_INFO("qos_level_high_wm                 = 0x%0x\n", ttu_regs->qos_level_high_wm);
-	DTN_INFO("min_ttu_vblank                    = 0x%0x\n", ttu_regs->min_ttu_vblank);
-	DTN_INFO("qos_level_flip                    = 0x%0x\n", ttu_regs->qos_level_flip);
-	DTN_INFO("refcyc_per_req_delivery_pre_l     = 0x%0x\n", ttu_regs->refcyc_per_req_delivery_pre_l);
-	DTN_INFO("refcyc_per_req_delivery_l         = 0x%0x\n", ttu_regs->refcyc_per_req_delivery_l);
-	DTN_INFO("refcyc_per_req_delivery_pre_c     = 0x%0x\n", ttu_regs->refcyc_per_req_delivery_pre_c);
-	DTN_INFO("refcyc_per_req_delivery_c         = 0x%0x\n", ttu_regs->refcyc_per_req_delivery_c);
-	DTN_INFO("refcyc_per_req_delivery_cur0      = 0x%0x\n", ttu_regs->refcyc_per_req_delivery_cur0);
-	DTN_INFO("refcyc_per_req_delivery_pre_cur0  = 0x%0x\n", ttu_regs->refcyc_per_req_delivery_pre_cur0);
-	DTN_INFO("refcyc_per_req_delivery_cur1      = 0x%0x\n", ttu_regs->refcyc_per_req_delivery_cur1);
-	DTN_INFO("refcyc_per_req_delivery_pre_cur1  = 0x%0x\n", ttu_regs->refcyc_per_req_delivery_pre_cur1);
-	DTN_INFO("qos_level_fixed_l                 = 0x%0x\n", ttu_regs->qos_level_fixed_l);
-	DTN_INFO("qos_ramp_disable_l                = 0x%0x\n", ttu_regs->qos_ramp_disable_l);
-	DTN_INFO("qos_level_fixed_c                 = 0x%0x\n", ttu_regs->qos_level_fixed_c);
-	DTN_INFO("qos_ramp_disable_c                = 0x%0x\n", ttu_regs->qos_ramp_disable_c);
-	DTN_INFO("qos_level_fixed_cur0              = 0x%0x\n", ttu_regs->qos_level_fixed_cur0);
-	DTN_INFO("qos_ramp_disable_cur0             = 0x%0x\n", ttu_regs->qos_ramp_disable_cur0);
-	DTN_INFO("qos_level_fixed_cur1              = 0x%0x\n", ttu_regs->qos_level_fixed_cur1);
-	DTN_INFO("qos_ramp_disable_cur1             = 0x%0x\n", ttu_regs->qos_ramp_disable_cur1);
-}
-
-void dcn10_log_hw_state(struct dc *dc)
+static void dcn10_log_hubp_states(struct dc *dc)
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	struct resource_pool *pool = dc->res_pool;
 	int i;
 
-	DTN_INFO_BEGIN();
-
-	dcn10_log_hubbub_state(dc);
-
 	DTN_INFO("HUBP:  format  addr_hi  width  height"
 			"  rot  mir  sw_mode  dcc_en  blank_en  ttu_dis  underflow"
 			"   min_ttu_vblank       qos_low_wm      qos_high_wm\n");
 	for (i = 0; i < pool->pipe_count; i++) {
 		struct hubp *hubp = pool->hubps[i];
-		struct dcn_hubp_state s;
+		struct dcn_hubp_state *s = &(TO_DCN10_HUBP(hubp)->state);
 
-		hubp->funcs->hubp_read_state(hubp, &s);
+		hubp->funcs->hubp_read_state(hubp);
 
 		DTN_INFO("[%2d]:  %5xh  %6xh  %5d  %6d  %2xh  %2xh  %6xh"
 				"  %6d  %8d  %7d  %8xh",
 				hubp->inst,
-				s.pixel_format,
-				s.inuse_addr_hi,
-				s.viewport_width,
-				s.viewport_height,
-				s.rotation_angle,
-				s.h_mirror_en,
-				s.sw_mode,
-				s.dcc_en,
-				s.blank_en,
-				s.ttu_disable,
-				s.underflow_status);
-		DTN_INFO_MICRO_SEC(s.min_ttu_vblank);
-		DTN_INFO_MICRO_SEC(s.qos_level_low_wm);
-		DTN_INFO_MICRO_SEC(s.qos_level_high_wm);
+				s->pixel_format,
+				s->inuse_addr_hi,
+				s->viewport_width,
+				s->viewport_height,
+				s->rotation_angle,
+				s->h_mirror_en,
+				s->sw_mode,
+				s->dcc_en,
+				s->blank_en,
+				s->ttu_disable,
+				s->underflow_status);
+		DTN_INFO_MICRO_SEC(s->min_ttu_vblank);
+		DTN_INFO_MICRO_SEC(s->qos_level_low_wm);
+		DTN_INFO_MICRO_SEC(s->qos_level_high_wm);
 		DTN_INFO("\n");
 	}
+
+	DTN_INFO("\n=========RQ========\n");
+	DTN_INFO("HUBP:  drq_exp_m  prq_exp_m  mrq_exp_m  crq_exp_m  plane1_ba  L:chunk_s  min_chu_s  meta_ch_s"
+		"  min_m_c_s  dpte_gr_s  mpte_gr_s  swath_hei  pte_row_h  C:chunk_s  min_chu_s  meta_ch_s"
+		"  min_m_c_s  dpte_gr_s  mpte_gr_s  swath_hei  pte_row_h\n");
+	for (i = 0; i < pool->pipe_count; i++) {
+		struct dcn_hubp_state *s = &(TO_DCN10_HUBP(pool->hubps[i])->state);
+		struct _vcs_dpi_display_rq_regs_st *rq_regs = &s->rq_regs;
+
+		DTN_INFO("[%2d]:  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\n",
+			i, rq_regs->drq_expansion_mode, rq_regs->prq_expansion_mode, rq_regs->mrq_expansion_mode,
+			rq_regs->crq_expansion_mode, rq_regs->plane1_base_address, rq_regs->rq_regs_l.chunk_size,
+			rq_regs->rq_regs_l.min_chunk_size, rq_regs->rq_regs_l.meta_chunk_size,
+			rq_regs->rq_regs_l.min_meta_chunk_size, rq_regs->rq_regs_l.dpte_group_size,
+			rq_regs->rq_regs_l.mpte_group_size, rq_regs->rq_regs_l.swath_height,
+			rq_regs->rq_regs_l.pte_row_height_linear, rq_regs->rq_regs_c.chunk_size, rq_regs->rq_regs_c.min_chunk_size,
+			rq_regs->rq_regs_c.meta_chunk_size, rq_regs->rq_regs_c.min_meta_chunk_size,
+			rq_regs->rq_regs_c.dpte_group_size, rq_regs->rq_regs_c.mpte_group_size,
+			rq_regs->rq_regs_c.swath_height, rq_regs->rq_regs_c.pte_row_height_linear);
+	}
+
+	DTN_INFO("========DLG========\n");
+	DTN_INFO("HUBP:  rc_hbe     dlg_vbe    min_d_y_n  rc_per_ht  rc_x_a_s "
+			"  dst_y_a_s  dst_y_pf   dst_y_vvb  dst_y_rvb  dst_y_vfl  dst_y_rfl  rf_pix_fq"
+			"  vratio_pf  vrat_pf_c  rc_pg_vbl  rc_pg_vbc  rc_mc_vbl  rc_mc_vbc  rc_pg_fll"
+			"  rc_pg_flc  rc_mc_fll  rc_mc_flc  pr_nom_l   pr_nom_c   rc_pg_nl   rc_pg_nc "
+			"  mr_nom_l   mr_nom_c   rc_mc_nl   rc_mc_nc   rc_ld_pl   rc_ld_pc   rc_ld_l  "
+			"  rc_ld_c    cha_cur0   ofst_cur1  cha_cur1   vr_af_vc0  ddrq_limt  x_rt_dlay"
+			"  x_rp_dlay  x_rr_sfl\n");
+	for (i = 0; i < pool->pipe_count; i++) {
+		struct dcn_hubp_state *s = &(TO_DCN10_HUBP(pool->hubps[i])->state);
+		struct _vcs_dpi_display_dlg_regs_st *dlg_regs = &s->dlg_attr;
+
+		DTN_INFO("[%2d]:  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh"
+			"%  8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh"
+			"  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\n",
+			i, dlg_regs->refcyc_h_blank_end, dlg_regs->dlg_vblank_end, dlg_regs->min_dst_y_next_start,
+			dlg_regs->refcyc_per_htotal, dlg_regs->refcyc_x_after_scaler, dlg_regs->dst_y_after_scaler,
+			dlg_regs->dst_y_prefetch, dlg_regs->dst_y_per_vm_vblank, dlg_regs->dst_y_per_row_vblank,
+			dlg_regs->dst_y_per_vm_flip, dlg_regs->dst_y_per_row_flip, dlg_regs->ref_freq_to_pix_freq,
+			dlg_regs->vratio_prefetch, dlg_regs->vratio_prefetch_c, dlg_regs->refcyc_per_pte_group_vblank_l,
+			dlg_regs->refcyc_per_pte_group_vblank_c, dlg_regs->refcyc_per_meta_chunk_vblank_l,
+			dlg_regs->refcyc_per_meta_chunk_vblank_c, dlg_regs->refcyc_per_pte_group_flip_l,
+			dlg_regs->refcyc_per_pte_group_flip_c, dlg_regs->refcyc_per_meta_chunk_flip_l,
+			dlg_regs->refcyc_per_meta_chunk_flip_c, dlg_regs->dst_y_per_pte_row_nom_l,
+			dlg_regs->dst_y_per_pte_row_nom_c, dlg_regs->refcyc_per_pte_group_nom_l,
+			dlg_regs->refcyc_per_pte_group_nom_c, dlg_regs->dst_y_per_meta_row_nom_l,
+			dlg_regs->dst_y_per_meta_row_nom_c, dlg_regs->refcyc_per_meta_chunk_nom_l,
+			dlg_regs->refcyc_per_meta_chunk_nom_c, dlg_regs->refcyc_per_line_delivery_pre_l,
+			dlg_regs->refcyc_per_line_delivery_pre_c, dlg_regs->refcyc_per_line_delivery_l,
+			dlg_regs->refcyc_per_line_delivery_c, dlg_regs->chunk_hdl_adjust_cur0, dlg_regs->dst_y_offset_cur1,
+			dlg_regs->chunk_hdl_adjust_cur1, dlg_regs->vready_after_vcount0, dlg_regs->dst_y_delta_drq_limit,
+			dlg_regs->xfc_reg_transfer_delay, dlg_regs->xfc_reg_precharge_delay,
+			dlg_regs->xfc_reg_remote_surface_flip_latency);
+	}
+
+	DTN_INFO("========TTU========\n");
+	DTN_INFO("HUBP:  qos_ll_wm  qos_lh_wm  mn_ttu_vb  qos_l_flp  rc_rd_p_l  rc_rd_l    rc_rd_p_c"
+			"  rc_rd_c    rc_rd_c0   rc_rd_pc0  rc_rd_c1   rc_rd_pc1  qos_lf_l   qos_rds_l"
+			"  qos_lf_c   qos_rds_c  qos_lf_c0  qos_rds_c0 qos_lf_c1  qos_rds_c1\n");
+	for (i = 0; i < pool->pipe_count; i++) {
+		struct dcn_hubp_state *s = &(TO_DCN10_HUBP(pool->hubps[i])->state);
+		struct _vcs_dpi_display_ttu_regs_st *ttu_regs = &s->ttu_attr;
+
+		DTN_INFO("[%2d]:  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh  %8xh\n",
+			i, ttu_regs->qos_level_low_wm, ttu_regs->qos_level_high_wm, ttu_regs->min_ttu_vblank,
+			ttu_regs->qos_level_flip, ttu_regs->refcyc_per_req_delivery_pre_l, ttu_regs->refcyc_per_req_delivery_l,
+			ttu_regs->refcyc_per_req_delivery_pre_c, ttu_regs->refcyc_per_req_delivery_c, ttu_regs->refcyc_per_req_delivery_cur0,
+			ttu_regs->refcyc_per_req_delivery_pre_cur0, ttu_regs->refcyc_per_req_delivery_cur1,
+			ttu_regs->refcyc_per_req_delivery_pre_cur1, ttu_regs->qos_level_fixed_l, ttu_regs->qos_ramp_disable_l,
+			ttu_regs->qos_level_fixed_c, ttu_regs->qos_ramp_disable_c, ttu_regs->qos_level_fixed_cur0,
+			ttu_regs->qos_ramp_disable_cur0, ttu_regs->qos_level_fixed_cur1, ttu_regs->qos_ramp_disable_cur1);
+	}
 	DTN_INFO("\n");
+}
+
+void dcn10_log_hw_state(struct dc *dc)
+{
+	struct dc_context *dc_ctx = dc->ctx;
+	struct resource_pool *pool = dc->res_pool;
+	int i;
+
+	DTN_INFO_BEGIN();
+
+	dcn10_log_hubbub_state(dc);
+
+	dcn10_log_hubp_states(dc);
 
 	DTN_INFO("DPP:    IGAM format  IGAM mode    DGAM mode    RGAM mode"
 			"  GAMUT mode  C11 C12   C13 C14   C21 C22   C23 C24   "
@@ -340,19 +324,6 @@ void dcn10_log_hw_state(struct dc *dc)
 	}
 	DTN_INFO("\n");
 
-	for (i = 0; i < pool->pipe_count; i++) {
-		struct hubp *hubp = pool->hubps[i];
-		struct dcn_hubp_state s = {0};
-
-		if (!dc->current_state->res_ctx.pipe_ctx[i].stream)
-			continue;
-
-		hubp->funcs->hubp_read_state(hubp, &s);
-		DTN_INFO("RQ-DLG-TTU registers for HUBP%d:\n", i);
-		print_rq_dlg_ttu_regs(dc_ctx, &s);
-		DTN_INFO("\n");
-	}
-
 	DTN_INFO("\nCALCULATED Clocks: dcfclk_khz:%d  dcfclk_deep_sleep_khz:%d  dispclk_khz:%d\n"
 		"dppclk_khz:%d  max_supported_dppclk_khz:%d  fclk_khz:%d  socclk_khz:%d\n\n",
 			dc->current_state->bw.dcn.calc_clk.dcfclk_khz,

commit 7b265fd96cbfa03630a2db90b3891b8397bf2208
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Apr 17 12:12:56 2018 -0400

    drm/amd/display: update dtn logging and goldens
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 9a642116f2ef..574d37cdfa20 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -260,7 +260,7 @@ void dcn10_log_hw_state(struct dc *dc)
 		dpp->funcs->dpp_read_state(dpp, &s);
 
 		DTN_INFO("[%2d]:  %11xh  %-11s  %-11s  %-11s"
-				"%08xh   %08xh %08xh %08xh %08xh %08xh %08xh",
+				"%8x    %08xh %08xh %08xh %08xh %08xh %08xh",
 				dpp->inst,
 				s.igam_input_format,
 				(s.igam_lut_mode == 0) ? "BypassFixed" :

commit 7c91bd434e5765dc5dbcf155253f2b8c740fbef9
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Fri Apr 13 09:40:21 2018 -0400

    drm/amd/display: add some DTN logs for input and output tf
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 8eea38b9e32b..9a642116f2ef 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -250,6 +250,47 @@ void dcn10_log_hw_state(struct dc *dc)
 	}
 	DTN_INFO("\n");
 
+	DTN_INFO("DPP:    IGAM format  IGAM mode    DGAM mode    RGAM mode"
+			"  GAMUT mode  C11 C12   C13 C14   C21 C22   C23 C24   "
+			"C31 C32   C33 C34\n");
+	for (i = 0; i < pool->pipe_count; i++) {
+		struct dpp *dpp = pool->dpps[i];
+		struct dcn_dpp_state s;
+
+		dpp->funcs->dpp_read_state(dpp, &s);
+
+		DTN_INFO("[%2d]:  %11xh  %-11s  %-11s  %-11s"
+				"%08xh   %08xh %08xh %08xh %08xh %08xh %08xh",
+				dpp->inst,
+				s.igam_input_format,
+				(s.igam_lut_mode == 0) ? "BypassFixed" :
+					((s.igam_lut_mode == 1) ? "BypassFloat" :
+					((s.igam_lut_mode == 2) ? "RAM" :
+					((s.igam_lut_mode == 3) ? "RAM" :
+								 "Unknown"))),
+				(s.dgam_lut_mode == 0) ? "Bypass" :
+					((s.dgam_lut_mode == 1) ? "sRGB" :
+					((s.dgam_lut_mode == 2) ? "Ycc" :
+					((s.dgam_lut_mode == 3) ? "RAM" :
+					((s.dgam_lut_mode == 4) ? "RAM" :
+								 "Unknown")))),
+				(s.rgam_lut_mode == 0) ? "Bypass" :
+					((s.rgam_lut_mode == 1) ? "sRGB" :
+					((s.rgam_lut_mode == 2) ? "Ycc" :
+					((s.rgam_lut_mode == 3) ? "RAM" :
+					((s.rgam_lut_mode == 4) ? "RAM" :
+								 "Unknown")))),
+				s.gamut_remap_mode,
+				s.gamut_remap_c11_c12,
+				s.gamut_remap_c13_c14,
+				s.gamut_remap_c21_c22,
+				s.gamut_remap_c23_c24,
+				s.gamut_remap_c31_c32,
+				s.gamut_remap_c33_c34);
+		DTN_INFO("\n");
+	}
+	DTN_INFO("\n");
+
 	DTN_INFO("MPCC:  OPP  DPP  MPCCBOT  MODE  ALPHA_MODE  PREMULT  OVERLAP_ONLY  IDLE\n");
 	for (i = 0; i < pool->pipe_count; i++) {
 		struct mpcc_state s = {0};

commit 3158223efde597521505b586a88a6d43c8f2324f
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Mon Apr 9 17:19:27 2018 -0400

    drm/amd/display: Refactor otg_blank sequence
    
    Also rename otg_blank to blank_pixel_data.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7cecab0ce297..8eea38b9e32b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -593,7 +593,7 @@ static void false_optc_underflow_wa(
 		tg->funcs->clear_optc_underflow(tg);
 }
 
-static enum dc_status dcn10_prog_pixclk_crtc_otg(
+static enum dc_status dcn10_enable_stream_timing(
 		struct pipe_ctx *pipe_ctx,
 		struct dc_state *context,
 		struct dc *dc)
@@ -1950,9 +1950,9 @@ static void update_dchubp_dpp(
 		hubp->funcs->set_blank(hubp, false);
 }
 
-static void dcn10_otg_blank(
+static void dcn10_blank_pixel_data(
 		struct dc *dc,
-		struct stream_resource stream_res,
+		struct stream_resource *stream_res,
 		struct dc_stream_state *stream,
 		bool blank)
 {
@@ -1963,21 +1963,21 @@ static void dcn10_otg_blank(
 	color_space = stream->output_color_space;
 	color_space_to_black_color(dc, color_space, &black_color);
 
-	if (stream_res.tg->funcs->set_blank_color)
-		stream_res.tg->funcs->set_blank_color(
-				stream_res.tg,
+	if (stream_res->tg->funcs->set_blank_color)
+		stream_res->tg->funcs->set_blank_color(
+				stream_res->tg,
 				&black_color);
 
 	if (!blank) {
-		if (stream_res.tg->funcs->set_blank)
-			stream_res.tg->funcs->set_blank(stream_res.tg, blank);
-		if (stream_res.abm)
-			stream_res.abm->funcs->set_abm_level(stream_res.abm, stream->abm_level);
+		if (stream_res->tg->funcs->set_blank)
+			stream_res->tg->funcs->set_blank(stream_res->tg, blank);
+		if (stream_res->abm)
+			stream_res->abm->funcs->set_abm_level(stream_res->abm, stream->abm_level);
 	} else if (blank) {
-		if (stream_res.abm)
-			stream_res.abm->funcs->set_abm_immediate_disable(stream_res.abm);
-		if (stream_res.tg->funcs->set_blank)
-			stream_res.tg->funcs->set_blank(stream_res.tg, blank);
+		if (stream_res->abm)
+			stream_res->abm->funcs->set_abm_immediate_disable(stream_res->abm);
+		if (stream_res->tg->funcs->set_blank)
+			stream_res->tg->funcs->set_blank(stream_res->tg, blank);
 	}
 }
 
@@ -2016,7 +2016,7 @@ static void program_all_pipe_in_tree(
 		pipe_ctx->stream_res.tg->funcs->program_global_sync(
 				pipe_ctx->stream_res.tg);
 
-		dcn10_otg_blank(dc, pipe_ctx->stream_res,
+		dc->hwss.blank_pixel_data(dc, &pipe_ctx->stream_res,
 				pipe_ctx->stream, blank);
 	}
 
@@ -2136,7 +2136,7 @@ static void dcn10_apply_ctx_for_surface(
 
 	if (num_planes == 0) {
 		/* OTG blank before remove all front end */
-		dcn10_otg_blank(dc, top_pipe_to_program->stream_res, top_pipe_to_program->stream, true);
+		dc->hwss.blank_pixel_data(dc, &top_pipe_to_program->stream_res, top_pipe_to_program->stream, true);
 	}
 
 	/* Disconnect unused mpcc */
@@ -2679,10 +2679,11 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.blank_stream = dce110_blank_stream,
 	.enable_display_power_gating = dcn10_dummy_display_power_gating,
 	.disable_plane = dcn10_disable_plane,
+	.blank_pixel_data = dcn10_blank_pixel_data,
 	.pipe_control_lock = dcn10_pipe_control_lock,
 	.set_bandwidth = dcn10_set_bandwidth,
 	.reset_hw_ctx_wrap = reset_hw_ctx_wrap,
-	.prog_pixclk_crtc_otg = dcn10_prog_pixclk_crtc_otg,
+	.enable_stream_timing = dcn10_enable_stream_timing,
 	.set_drr = set_drr,
 	.get_position = get_position,
 	.set_static_screen_control = set_static_screen_control,

commit 8e357610ca0cc44a875df68f608a756fa56b1797
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Mon Apr 9 15:47:42 2018 -0400

    drm/amd/display: Make program_output_csc HWSS interface function
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e547f46d3516..7cecab0ce297 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1564,7 +1564,7 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 	}
 }
 
-static void program_output_csc(struct dc *dc,
+static void dcn10_program_output_csc(struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
 		enum dc_color_space colorspace,
 		uint16_t *matrix,
@@ -1917,7 +1917,7 @@ static void update_dchubp_dpp(
 		/*gamut remap*/
 		program_gamut_remap(pipe_ctx);
 
-		program_output_csc(dc,
+		dc->hwss.program_output_csc(dc,
 				pipe_ctx,
 				pipe_ctx->stream->output_color_space,
 				pipe_ctx->stream->csc_color_matrix.matrix,
@@ -2667,6 +2667,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.update_pending_status = dcn10_update_pending_status,
 	.set_input_transfer_func = dcn10_set_input_transfer_func,
 	.set_output_transfer_func = dcn10_set_output_transfer_func,
+	.program_output_csc = dcn10_program_output_csc,
 	.power_down = dce110_power_down,
 	.enable_accelerated_mode = dce110_enable_accelerated_mode,
 	.enable_timing_synchronization = dcn10_enable_timing_synchronization,

commit a47654633596a63f14a9035b9c762f8aaf1e00a3
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Apr 4 16:03:38 2018 -0400

    drm/amd/display: add calculated clock logging to DTN
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7dd130d15a67..e547f46d3516 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -311,7 +311,16 @@ void dcn10_log_hw_state(struct dc *dc)
 		print_rq_dlg_ttu_regs(dc_ctx, &s);
 		DTN_INFO("\n");
 	}
-	DTN_INFO("\n");
+
+	DTN_INFO("\nCALCULATED Clocks: dcfclk_khz:%d  dcfclk_deep_sleep_khz:%d  dispclk_khz:%d\n"
+		"dppclk_khz:%d  max_supported_dppclk_khz:%d  fclk_khz:%d  socclk_khz:%d\n\n",
+			dc->current_state->bw.dcn.calc_clk.dcfclk_khz,
+			dc->current_state->bw.dcn.calc_clk.dcfclk_deep_sleep_khz,
+			dc->current_state->bw.dcn.calc_clk.dispclk_khz,
+			dc->current_state->bw.dcn.calc_clk.dppclk_khz,
+			dc->current_state->bw.dcn.calc_clk.max_supported_dppclk_khz,
+			dc->current_state->bw.dcn.calc_clk.fclk_khz,
+			dc->current_state->bw.dcn.calc_clk.socclk_khz);
 
 	log_mpc_crc(dc);
 

commit 0a93dc7f595f43b621277ecfc05a44ed0c719a5f
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Mar 29 08:43:02 2018 -0400

    drm/amd/display: add rq/dlg/ttu to dtn log
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index a6cf9ade9131..7dd130d15a67 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -112,6 +112,104 @@ void dcn10_log_hubbub_state(struct dc *dc)
 	DTN_INFO("\n");
 }
 
+static void print_rq_dlg_ttu_regs(struct dc_context *dc_ctx, struct dcn_hubp_state *s)
+{
+	struct _vcs_dpi_display_dlg_regs_st *dlg_regs = &s->dlg_attr;
+	struct _vcs_dpi_display_ttu_regs_st *ttu_regs = &s->ttu_attr;
+	struct _vcs_dpi_display_rq_regs_st *rq_regs = &s->rq_regs;
+
+	DTN_INFO("========Requester========\n");
+	DTN_INFO("drq_expansion_mode      = 0x%0x\n", rq_regs->drq_expansion_mode);
+	DTN_INFO("prq_expansion_mode      = 0x%0x\n", rq_regs->prq_expansion_mode);
+	DTN_INFO("mrq_expansion_mode      = 0x%0x\n", rq_regs->mrq_expansion_mode);
+	DTN_INFO("crq_expansion_mode      = 0x%0x\n", rq_regs->crq_expansion_mode);
+	DTN_INFO("plane1_base_address     = 0x%0x\n", rq_regs->plane1_base_address);
+	DTN_INFO("==<LUMA>==\n");
+	DTN_INFO("chunk_size              = 0x%0x\n", rq_regs->rq_regs_l.chunk_size);
+	DTN_INFO("min_chunk_size          = 0x%0x\n", rq_regs->rq_regs_l.min_chunk_size);
+	DTN_INFO("meta_chunk_size         = 0x%0x\n", rq_regs->rq_regs_l.meta_chunk_size);
+	DTN_INFO("min_meta_chunk_size     = 0x%0x\n", rq_regs->rq_regs_l.min_meta_chunk_size);
+	DTN_INFO("dpte_group_size         = 0x%0x\n", rq_regs->rq_regs_l.dpte_group_size);
+	DTN_INFO("mpte_group_size         = 0x%0x\n", rq_regs->rq_regs_l.mpte_group_size);
+	DTN_INFO("swath_height            = 0x%0x\n", rq_regs->rq_regs_l.swath_height);
+	DTN_INFO("pte_row_height_linear   = 0x%0x\n", rq_regs->rq_regs_l.pte_row_height_linear);
+	DTN_INFO("==<CHROMA>==\n");
+	DTN_INFO("chunk_size              = 0x%0x\n", rq_regs->rq_regs_c.chunk_size);
+	DTN_INFO("min_chunk_size          = 0x%0x\n", rq_regs->rq_regs_c.min_chunk_size);
+	DTN_INFO("meta_chunk_size         = 0x%0x\n", rq_regs->rq_regs_c.meta_chunk_size);
+	DTN_INFO("min_meta_chunk_size     = 0x%0x\n", rq_regs->rq_regs_c.min_meta_chunk_size);
+	DTN_INFO("dpte_group_size         = 0x%0x\n", rq_regs->rq_regs_c.dpte_group_size);
+	DTN_INFO("mpte_group_size         = 0x%0x\n", rq_regs->rq_regs_c.mpte_group_size);
+	DTN_INFO("swath_height            = 0x%0x\n", rq_regs->rq_regs_c.swath_height);
+	DTN_INFO("pte_row_height_linear   = 0x%0x\n", rq_regs->rq_regs_c.pte_row_height_linear);
+
+	DTN_INFO("========DLG========\n");
+	DTN_INFO("refcyc_h_blank_end                  = 0x%0x\n", dlg_regs->refcyc_h_blank_end);
+	DTN_INFO("dlg_vblank_end                      = 0x%0x\n", dlg_regs->dlg_vblank_end);
+	DTN_INFO("min_dst_y_next_start                = 0x%0x\n", dlg_regs->min_dst_y_next_start);
+	DTN_INFO("refcyc_per_htotal                   = 0x%0x\n", dlg_regs->refcyc_per_htotal);
+	DTN_INFO("refcyc_x_after_scaler               = 0x%0x\n", dlg_regs->refcyc_x_after_scaler);
+	DTN_INFO("dst_y_after_scaler                  = 0x%0x\n", dlg_regs->dst_y_after_scaler);
+	DTN_INFO("dst_y_prefetch                      = 0x%0x\n", dlg_regs->dst_y_prefetch);
+	DTN_INFO("dst_y_per_vm_vblank                 = 0x%0x\n", dlg_regs->dst_y_per_vm_vblank);
+	DTN_INFO("dst_y_per_row_vblank                = 0x%0x\n", dlg_regs->dst_y_per_row_vblank);
+	DTN_INFO("dst_y_per_vm_flip                   = 0x%0x\n", dlg_regs->dst_y_per_vm_flip);
+	DTN_INFO("dst_y_per_row_flip                  = 0x%0x\n", dlg_regs->dst_y_per_row_flip);
+	DTN_INFO("ref_freq_to_pix_freq                = 0x%0x\n", dlg_regs->ref_freq_to_pix_freq);
+	DTN_INFO("vratio_prefetch                     = 0x%0x\n", dlg_regs->vratio_prefetch);
+	DTN_INFO("vratio_prefetch_c                   = 0x%0x\n", dlg_regs->vratio_prefetch_c);
+	DTN_INFO("refcyc_per_pte_group_vblank_l       = 0x%0x\n", dlg_regs->refcyc_per_pte_group_vblank_l);
+	DTN_INFO("refcyc_per_pte_group_vblank_c       = 0x%0x\n", dlg_regs->refcyc_per_pte_group_vblank_c);
+	DTN_INFO("refcyc_per_meta_chunk_vblank_l      = 0x%0x\n", dlg_regs->refcyc_per_meta_chunk_vblank_l);
+	DTN_INFO("refcyc_per_meta_chunk_vblank_c      = 0x%0x\n", dlg_regs->refcyc_per_meta_chunk_vblank_c);
+	DTN_INFO("refcyc_per_pte_group_flip_l         = 0x%0x\n", dlg_regs->refcyc_per_pte_group_flip_l);
+	DTN_INFO("refcyc_per_pte_group_flip_c         = 0x%0x\n", dlg_regs->refcyc_per_pte_group_flip_c);
+	DTN_INFO("refcyc_per_meta_chunk_flip_l        = 0x%0x\n", dlg_regs->refcyc_per_meta_chunk_flip_l);
+	DTN_INFO("refcyc_per_meta_chunk_flip_c        = 0x%0x\n", dlg_regs->refcyc_per_meta_chunk_flip_c);
+	DTN_INFO("dst_y_per_pte_row_nom_l             = 0x%0x\n", dlg_regs->dst_y_per_pte_row_nom_l);
+	DTN_INFO("dst_y_per_pte_row_nom_c             = 0x%0x\n", dlg_regs->dst_y_per_pte_row_nom_c);
+	DTN_INFO("refcyc_per_pte_group_nom_l          = 0x%0x\n", dlg_regs->refcyc_per_pte_group_nom_l);
+	DTN_INFO("refcyc_per_pte_group_nom_c          = 0x%0x\n", dlg_regs->refcyc_per_pte_group_nom_c);
+	DTN_INFO("dst_y_per_meta_row_nom_l            = 0x%0x\n", dlg_regs->dst_y_per_meta_row_nom_l);
+	DTN_INFO("dst_y_per_meta_row_nom_c            = 0x%0x\n", dlg_regs->dst_y_per_meta_row_nom_c);
+	DTN_INFO("refcyc_per_meta_chunk_nom_l         = 0x%0x\n", dlg_regs->refcyc_per_meta_chunk_nom_l);
+	DTN_INFO("refcyc_per_meta_chunk_nom_c         = 0x%0x\n", dlg_regs->refcyc_per_meta_chunk_nom_c);
+	DTN_INFO("refcyc_per_line_delivery_pre_l      = 0x%0x\n", dlg_regs->refcyc_per_line_delivery_pre_l);
+	DTN_INFO("refcyc_per_line_delivery_pre_c      = 0x%0x\n", dlg_regs->refcyc_per_line_delivery_pre_c);
+	DTN_INFO("refcyc_per_line_delivery_l          = 0x%0x\n", dlg_regs->refcyc_per_line_delivery_l);
+	DTN_INFO("refcyc_per_line_delivery_c          = 0x%0x\n", dlg_regs->refcyc_per_line_delivery_c);
+	DTN_INFO("chunk_hdl_adjust_cur0               = 0x%0x\n", dlg_regs->chunk_hdl_adjust_cur0);
+	DTN_INFO("dst_y_offset_cur1                   = 0x%0x\n", dlg_regs->dst_y_offset_cur1);
+	DTN_INFO("chunk_hdl_adjust_cur1               = 0x%0x\n", dlg_regs->chunk_hdl_adjust_cur1);
+	DTN_INFO("vready_after_vcount0                = 0x%0x\n", dlg_regs->vready_after_vcount0);
+	DTN_INFO("dst_y_delta_drq_limit               = 0x%0x\n", dlg_regs->dst_y_delta_drq_limit);
+	DTN_INFO("xfc_reg_transfer_delay              = 0x%0x\n", dlg_regs->xfc_reg_transfer_delay);
+	DTN_INFO("xfc_reg_precharge_delay             = 0x%0x\n", dlg_regs->xfc_reg_precharge_delay);
+	DTN_INFO("xfc_reg_remote_surface_flip_latency = 0x%0x\n", dlg_regs->xfc_reg_remote_surface_flip_latency);
+
+	DTN_INFO("========TTU========\n");
+	DTN_INFO("qos_level_low_wm                  = 0x%0x\n", ttu_regs->qos_level_low_wm);
+	DTN_INFO("qos_level_high_wm                 = 0x%0x\n", ttu_regs->qos_level_high_wm);
+	DTN_INFO("min_ttu_vblank                    = 0x%0x\n", ttu_regs->min_ttu_vblank);
+	DTN_INFO("qos_level_flip                    = 0x%0x\n", ttu_regs->qos_level_flip);
+	DTN_INFO("refcyc_per_req_delivery_pre_l     = 0x%0x\n", ttu_regs->refcyc_per_req_delivery_pre_l);
+	DTN_INFO("refcyc_per_req_delivery_l         = 0x%0x\n", ttu_regs->refcyc_per_req_delivery_l);
+	DTN_INFO("refcyc_per_req_delivery_pre_c     = 0x%0x\n", ttu_regs->refcyc_per_req_delivery_pre_c);
+	DTN_INFO("refcyc_per_req_delivery_c         = 0x%0x\n", ttu_regs->refcyc_per_req_delivery_c);
+	DTN_INFO("refcyc_per_req_delivery_cur0      = 0x%0x\n", ttu_regs->refcyc_per_req_delivery_cur0);
+	DTN_INFO("refcyc_per_req_delivery_pre_cur0  = 0x%0x\n", ttu_regs->refcyc_per_req_delivery_pre_cur0);
+	DTN_INFO("refcyc_per_req_delivery_cur1      = 0x%0x\n", ttu_regs->refcyc_per_req_delivery_cur1);
+	DTN_INFO("refcyc_per_req_delivery_pre_cur1  = 0x%0x\n", ttu_regs->refcyc_per_req_delivery_pre_cur1);
+	DTN_INFO("qos_level_fixed_l                 = 0x%0x\n", ttu_regs->qos_level_fixed_l);
+	DTN_INFO("qos_ramp_disable_l                = 0x%0x\n", ttu_regs->qos_ramp_disable_l);
+	DTN_INFO("qos_level_fixed_c                 = 0x%0x\n", ttu_regs->qos_level_fixed_c);
+	DTN_INFO("qos_ramp_disable_c                = 0x%0x\n", ttu_regs->qos_ramp_disable_c);
+	DTN_INFO("qos_level_fixed_cur0              = 0x%0x\n", ttu_regs->qos_level_fixed_cur0);
+	DTN_INFO("qos_ramp_disable_cur0             = 0x%0x\n", ttu_regs->qos_ramp_disable_cur0);
+	DTN_INFO("qos_level_fixed_cur1              = 0x%0x\n", ttu_regs->qos_level_fixed_cur1);
+	DTN_INFO("qos_ramp_disable_cur1             = 0x%0x\n", ttu_regs->qos_ramp_disable_cur1);
+}
+
 void dcn10_log_hw_state(struct dc *dc)
 {
 	struct dc_context *dc_ctx = dc->ctx;
@@ -129,7 +227,7 @@ void dcn10_log_hw_state(struct dc *dc)
 		struct hubp *hubp = pool->hubps[i];
 		struct dcn_hubp_state s;
 
-		hubp1_read_state(TO_DCN10_HUBP(hubp), &s);
+		hubp->funcs->hubp_read_state(hubp, &s);
 
 		DTN_INFO("[%2d]:  %5xh  %6xh  %5d  %6d  %2xh  %2xh  %6xh"
 				"  %6d  %8d  %7d  %8xh",
@@ -201,6 +299,20 @@ void dcn10_log_hw_state(struct dc *dc)
 	}
 	DTN_INFO("\n");
 
+	for (i = 0; i < pool->pipe_count; i++) {
+		struct hubp *hubp = pool->hubps[i];
+		struct dcn_hubp_state s = {0};
+
+		if (!dc->current_state->res_ctx.pipe_ctx[i].stream)
+			continue;
+
+		hubp->funcs->hubp_read_state(hubp, &s);
+		DTN_INFO("RQ-DLG-TTU registers for HUBP%d:\n", i);
+		print_rq_dlg_ttu_regs(dc_ctx, &s);
+		DTN_INFO("\n");
+	}
+	DTN_INFO("\n");
+
 	log_mpc_crc(dc);
 
 	DTN_INFO_END();

commit e43a432c018a9a2c2641e1f8c08a836cc83982cd
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Mar 27 16:43:56 2018 -0400

    drm/amd/display: Have DC manage its own allocation of gamma
    
    Creating plane will also allocate gamma and input TF
    Creating stream will also allocate outputTF
    
    Fix issue with gamma not applied
    OS may call SetGamma before surface committed, so need to store
    in target and apply later.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f3341a2399fa..a6cf9ade9131 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -956,9 +956,8 @@ static bool dcn10_set_input_transfer_func(struct pipe_ctx *pipe_ctx,
 		tf = plane_state->in_transfer_func;
 
 	if (plane_state->gamma_correction &&
-		plane_state->gamma_correction->is_identity)
-		dpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);
-	else if (plane_state->gamma_correction && dce_use_lut(plane_state->format))
+		!plane_state->gamma_correction->is_identity
+			&& dce_use_lut(plane_state->format))
 		dpp_base->funcs->dpp_program_input_lut(dpp_base, plane_state->gamma_correction);
 
 	if (tf == NULL)

commit 01fe3e4876d3799b37e6c712dcfed7cc2cafa3f0
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Mar 15 13:34:16 2018 -0400

    drm/amd/display: Add vmax/min_sel prints to dcn10_log_hw_state
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index de5293dc4db3..f3341a2399fa 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -165,7 +165,7 @@ void dcn10_log_hw_state(struct dc *dc)
 	}
 	DTN_INFO("\n");
 
-	DTN_INFO("OTG:  v_bs  v_be  v_ss  v_se  vpol  vmax  vmin"
+	DTN_INFO("OTG:  v_bs  v_be  v_ss  v_se  vpol  vmax  vmin  vmax_sel  vmin_sel"
 			"  h_bs  h_be  h_ss  h_se  hpol  htot  vtot  underflow\n");
 
 	for (i = 0; i < pool->timing_generator_count; i++) {
@@ -178,7 +178,7 @@ void dcn10_log_hw_state(struct dc *dc)
 		if ((s.otg_enabled & 1) == 0)
 			continue;
 
-		DTN_INFO("[%d]: %5d %5d %5d %5d %5d %5d %5d %5d %5d %5d"
+		DTN_INFO("[%d]: %5d %5d %5d %5d %5d %5d %5d %9d %9d %5d %5d %5d"
 				" %5d %5d %5d %5d  %9d\n",
 				tg->inst,
 				s.v_blank_start,
@@ -188,6 +188,8 @@ void dcn10_log_hw_state(struct dc *dc)
 				s.v_sync_a_pol,
 				s.v_total_max,
 				s.v_total_min,
+				s.v_total_max_sel,
+				s.v_total_min_sel,
 				s.h_blank_start,
 				s.h_blank_end,
 				s.h_sync_a_start,

commit 5d4b05ddd826d877327ecabf987b7c61ec3cb0c5
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Thu Mar 15 13:01:46 2018 -0400

    drm/amd/display: Add Dynamic debug prints
    
    Created Macros for DC_LOG_XXX to pr_debug() & DRM_DEBUG_KMS.
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e21458169d15..de5293dc4db3 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -45,8 +45,8 @@
 #include "dcn10_hubbub.h"
 #include "dcn10_cm_common.h"
 
-#define DC_LOGGER \
-	ctx->logger
+#define DC_LOGGER_INIT(logger)
+
 #define CTX \
 	hws->ctx
 #define REG(reg)\
@@ -363,7 +363,7 @@ static void power_on_plane(
 	struct dce_hwseq *hws,
 	int plane_id)
 {
-	struct dc_context *ctx = hws->ctx;
+	DC_LOGGER_INIT(hws->ctx->logger);
 	if (REG(DC_IP_REQUEST_CNTL)) {
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 1);
@@ -562,7 +562,7 @@ static void reset_back_end_for_pipe(
 		struct dc_state *context)
 {
 	int i;
-	struct dc_context *ctx = dc->ctx;
+	DC_LOGGER_INIT(dc->ctx->logger);
 	if (pipe_ctx->stream_res.stream_enc == NULL) {
 		pipe_ctx->stream = NULL;
 		return;
@@ -658,7 +658,7 @@ static void plane_atomic_power_down(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct dpp *dpp = pipe_ctx->plane_res.dpp;
-	struct dc_context *ctx = dc->ctx;
+	DC_LOGGER_INIT(dc->ctx->logger);
 
 	if (REG(DC_IP_REQUEST_CNTL)) {
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
@@ -708,7 +708,7 @@ static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 
 static void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
-	struct dc_context *ctx = dc->ctx;
+	DC_LOGGER_INIT(dc->ctx->logger);
 
 	if (!pipe_ctx->plane_res.hubp || pipe_ctx->plane_res.hubp->power_gated)
 		return;
@@ -2001,9 +2001,9 @@ static void dcn10_apply_ctx_for_surface(
 	bool removed_pipe[4] = { false };
 	unsigned int ref_clk_mhz = dc->res_pool->ref_clock_inKhz/1000;
 	bool program_water_mark = false;
-	struct dc_context *ctx = dc->ctx;
 	struct pipe_ctx *top_pipe_to_program =
 			find_top_pipe_for_stream(dc, context, stream);
+	DC_LOGGER_INIT(dc->ctx->logger);
 
 	if (!top_pipe_to_program)
 		return;

commit 1ba2faf207b47e23b1d756e7be25e980724214a7
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Mar 15 10:25:43 2018 -0400

    drm/amd/display: hide inconsistent mpcc programming from dtn log
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 27ae88e3a373..e21458169d15 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -157,10 +157,11 @@ void dcn10_log_hw_state(struct dc *dc)
 		struct mpcc_state s = {0};
 
 		pool->mpc->funcs->read_mpcc_state(pool->mpc, i, &s);
-		DTN_INFO("[%2d]:  %2xh  %2xh  %6xh  %4d  %10d  %7d  %12d  %4d\n",
-			i, s.opp_id, s.dpp_id, s.bot_mpcc_id,
-			s.mode, s.alpha_mode, s.pre_multiplied_alpha, s.overlap_only,
-			s.idle);
+		if (s.opp_id != 0xf)
+			DTN_INFO("[%2d]:  %2xh  %2xh  %6xh  %4d  %10d  %7d  %12d  %4d\n",
+				i, s.opp_id, s.dpp_id, s.bot_mpcc_id,
+				s.mode, s.alpha_mode, s.pre_multiplied_alpha, s.overlap_only,
+				s.idle);
 	}
 	DTN_INFO("\n");
 

commit 4173c0bdd7b79ef46161037f8845654416dbaca9
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Wed Mar 14 17:41:57 2018 -0400

    drm/amd/display: Only update mpc blend config if not full update
    
    The current mpcc insert/remove logic does not support updating
    only a single mpcc. So when pixel alpha changed but no full update
    we can mistakenly shuffle the mpcc layering order. With this change
    we will only insert/remove mpcc if there is full update.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 675a81a87099..27ae88e3a373 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1631,6 +1631,8 @@ static void update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	struct mpc *mpc = dc->res_pool->mpc;
 	struct mpc_tree *mpc_tree_params = &(pipe_ctx->stream_res.opp->mpc_tree_params);
 
+
+
 	/* TODO: proper fix once fpga works */
 
 	if (dc->debug.surface_visual_confirm)
@@ -1657,6 +1659,7 @@ static void update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
 			pipe_ctx->stream->output_color_space)
 					&& per_pixel_alpha;
 
+
 	/*
 	 * TODO: remove hack
 	 * Note: currently there is a bug in init_hw such that
@@ -1667,6 +1670,12 @@ static void update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	 */
 	mpcc_id = hubp->inst;
 
+	/* If there is no full update, don't need to touch MPC tree*/
+	if (!pipe_ctx->plane_state->update_flags.bits.full_update) {
+		mpc->funcs->update_blending(mpc, &blnd_cfg, mpcc_id);
+		return;
+	}
+
 	/* check if this MPCC is already being used */
 	new_mpcc = mpc->funcs->get_mpcc_for_dpp(mpc_tree_params, mpcc_id);
 	/* remove MPCC if being used */

commit a052a516de4c3e46f2e442ec118c391dbf9932e3
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Mar 13 15:00:20 2018 -0400

    drm/amd/display: align dtn logs and add mpc idle bit print
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 999190aa8a08..675a81a87099 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -56,16 +56,17 @@
 #define FN(reg_name, field_name) \
 	hws->shifts->field_name, hws->masks->field_name
 
+/*print is 17 wide, first two characters are spaces*/
 #define DTN_INFO_MICRO_SEC(ref_cycle) \
 	print_microsec(dc_ctx, ref_cycle)
 
 void print_microsec(struct dc_context *dc_ctx, uint32_t ref_cycle)
 {
-	static const uint32_t ref_clk_mhz = 48;
-	static const unsigned int frac = 10;
+	const uint32_t ref_clk_mhz = dc_ctx->dc->res_pool->ref_clock_inKhz / 1000;
+	static const unsigned int frac = 1000;
 	uint32_t us_x10 = (ref_cycle * frac) / ref_clk_mhz;
 
-	DTN_INFO("%d.%d \t ",
+	DTN_INFO("  %11d.%03d",
 			us_x10 / frac,
 			us_x10 % frac);
 }
@@ -92,14 +93,14 @@ void dcn10_log_hubbub_state(struct dc *dc)
 
 	hubbub1_wm_read_state(dc->res_pool->hubbub, &wm);
 
-	DTN_INFO("HUBBUB WM: \t data_urgent \t pte_meta_urgent \t "
-			"sr_enter \t sr_exit \t dram_clk_change \n");
+	DTN_INFO("HUBBUB WM:      data_urgent  pte_meta_urgent"
+			"         sr_enter          sr_exit  dram_clk_change\n");
 
 	for (i = 0; i < 4; i++) {
 		struct dcn_hubbub_wm_set *s;
 
 		s = &wm.sets[i];
-		DTN_INFO("WM_Set[%d]:\t ", s->wm_set);
+		DTN_INFO("WM_Set[%d]:", s->wm_set);
 		DTN_INFO_MICRO_SEC(s->data_urgent);
 		DTN_INFO_MICRO_SEC(s->pte_meta_urgent);
 		DTN_INFO_MICRO_SEC(s->sr_enter);
@@ -121,19 +122,17 @@ void dcn10_log_hw_state(struct dc *dc)
 
 	dcn10_log_hubbub_state(dc);
 
-	DTN_INFO("HUBP:  format  addr_hi  width  height  "
-			"rotation  mirror  sw_mode  "
-			"dcc_en  blank_en  ttu_dis  underflow  "
-			"min_ttu_vblank  qos_low_wm  qos_high_wm\n");
+	DTN_INFO("HUBP:  format  addr_hi  width  height"
+			"  rot  mir  sw_mode  dcc_en  blank_en  ttu_dis  underflow"
+			"   min_ttu_vblank       qos_low_wm      qos_high_wm\n");
 	for (i = 0; i < pool->pipe_count; i++) {
 		struct hubp *hubp = pool->hubps[i];
 		struct dcn_hubp_state s;
 
 		hubp1_read_state(TO_DCN10_HUBP(hubp), &s);
 
-		DTN_INFO("[%-2d]:  %5xh  %6xh  %5d  %6d  "
-				"%7xh  %5xh  %6xh  "
-				"%6d  %8d  %7d  %8xh \t",
+		DTN_INFO("[%2d]:  %5xh  %6xh  %5d  %6d  %2xh  %2xh  %6xh"
+				"  %6d  %8d  %7d  %8xh",
 				hubp->inst,
 				s.pixel_format,
 				s.inuse_addr_hi,
@@ -152,25 +151,21 @@ void dcn10_log_hw_state(struct dc *dc)
 		DTN_INFO("\n");
 	}
 	DTN_INFO("\n");
+
+	DTN_INFO("MPCC:  OPP  DPP  MPCCBOT  MODE  ALPHA_MODE  PREMULT  OVERLAP_ONLY  IDLE\n");
 	for (i = 0; i < pool->pipe_count; i++) {
-		struct output_pixel_processor *opp = pool->opps[i];
-		struct mpcc *mpcc = opp->mpc_tree_params.opp_list;
 		struct mpcc_state s = {0};
 
-		while (mpcc) {
-			ASSERT(opp->mpc_tree_params.opp_id == opp->inst);
-			pool->mpc->funcs->read_mpcc_state(pool->mpc, mpcc->mpcc_id, &s);
-			DTN_INFO("[OPP%d - MPCC%d]: DPP%d MPCCBOT%x MODE:%d ALPHA_MODE:%d PREMULT:%d OVERLAP_ONLY:%d\n",
-				s.opp_id, mpcc->mpcc_id, s.dpp_id, s.bot_mpcc_id,
-				s.mode, s.alpha_mode, s.pre_multiplied_alpha, s.overlap_only);
-			mpcc = mpcc->mpcc_bot;
-			ASSERT(!mpcc || mpcc->mpcc_id == s.bot_mpcc_id);
-		}
+		pool->mpc->funcs->read_mpcc_state(pool->mpc, i, &s);
+		DTN_INFO("[%2d]:  %2xh  %2xh  %6xh  %4d  %10d  %7d  %12d  %4d\n",
+			i, s.opp_id, s.dpp_id, s.bot_mpcc_id,
+			s.mode, s.alpha_mode, s.pre_multiplied_alpha, s.overlap_only,
+			s.idle);
 	}
 	DTN_INFO("\n");
 
-	DTN_INFO("OTG:\t v_bs \t v_be \t v_ss \t v_se \t vpol \t vmax \t vmin \t "
-			"h_bs \t h_be \t h_ss \t h_se \t hpol \t htot \t vtot \t underflow\n");
+	DTN_INFO("OTG:  v_bs  v_be  v_ss  v_se  vpol  vmax  vmin"
+			"  h_bs  h_be  h_ss  h_se  hpol  htot  vtot  underflow\n");
 
 	for (i = 0; i < pool->timing_generator_count; i++) {
 		struct timing_generator *tg = pool->timing_generators[i];
@@ -182,9 +177,8 @@ void dcn10_log_hw_state(struct dc *dc)
 		if ((s.otg_enabled & 1) == 0)
 			continue;
 
-		DTN_INFO("[%d]:\t %d \t %d \t %d \t %d \t "
-				"%d \t %d \t %d \t %d \t %d \t %d \t "
-				"%d \t %d \t %d \t %d \t %d \t ",
+		DTN_INFO("[%d]: %5d %5d %5d %5d %5d %5d %5d %5d %5d %5d"
+				" %5d %5d %5d %5d  %9d\n",
 				tg->inst,
 				s.v_blank_start,
 				s.v_blank_end,
@@ -201,7 +195,6 @@ void dcn10_log_hw_state(struct dc *dc)
 				s.h_total,
 				s.v_total,
 				s.underflow_occurred_status);
-		DTN_INFO("\n");
 	}
 	DTN_INFO("\n");
 

commit dfd01f299987e7ede74e27d422c43846d1326010
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jan 24 14:28:30 2018 -0500

    drm/amd/display: add mpc to dtn log
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 8b0f6b8a5627..999190aa8a08 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -121,20 +121,19 @@ void dcn10_log_hw_state(struct dc *dc)
 
 	dcn10_log_hubbub_state(dc);
 
-	DTN_INFO("HUBP:\t format \t addr_hi \t width \t height \t "
-			"rotation \t mirror \t  sw_mode \t "
-			"dcc_en \t blank_en \t ttu_dis \t underflow \t "
-			"min_ttu_vblank \t qos_low_wm \t qos_high_wm \n");
-
+	DTN_INFO("HUBP:  format  addr_hi  width  height  "
+			"rotation  mirror  sw_mode  "
+			"dcc_en  blank_en  ttu_dis  underflow  "
+			"min_ttu_vblank  qos_low_wm  qos_high_wm\n");
 	for (i = 0; i < pool->pipe_count; i++) {
 		struct hubp *hubp = pool->hubps[i];
 		struct dcn_hubp_state s;
 
 		hubp1_read_state(TO_DCN10_HUBP(hubp), &s);
 
-		DTN_INFO("[%d]:\t %xh \t %xh \t %d \t %d \t "
-				"%xh \t %xh \t %xh \t "
-				"%d \t %d \t %d \t %xh \t",
+		DTN_INFO("[%-2d]:  %5xh  %6xh  %5d  %6d  "
+				"%7xh  %5xh  %6xh  "
+				"%6d  %8d  %7d  %8xh \t",
 				hubp->inst,
 				s.pixel_format,
 				s.inuse_addr_hi,
@@ -153,6 +152,22 @@ void dcn10_log_hw_state(struct dc *dc)
 		DTN_INFO("\n");
 	}
 	DTN_INFO("\n");
+	for (i = 0; i < pool->pipe_count; i++) {
+		struct output_pixel_processor *opp = pool->opps[i];
+		struct mpcc *mpcc = opp->mpc_tree_params.opp_list;
+		struct mpcc_state s = {0};
+
+		while (mpcc) {
+			ASSERT(opp->mpc_tree_params.opp_id == opp->inst);
+			pool->mpc->funcs->read_mpcc_state(pool->mpc, mpcc->mpcc_id, &s);
+			DTN_INFO("[OPP%d - MPCC%d]: DPP%d MPCCBOT%x MODE:%d ALPHA_MODE:%d PREMULT:%d OVERLAP_ONLY:%d\n",
+				s.opp_id, mpcc->mpcc_id, s.dpp_id, s.bot_mpcc_id,
+				s.mode, s.alpha_mode, s.pre_multiplied_alpha, s.overlap_only);
+			mpcc = mpcc->mpcc_bot;
+			ASSERT(!mpcc || mpcc->mpcc_id == s.bot_mpcc_id);
+		}
+	}
+	DTN_INFO("\n");
 
 	DTN_INFO("OTG:\t v_bs \t v_be \t v_ss \t v_se \t vpol \t vmax \t vmin \t "
 			"h_bs \t h_be \t h_ss \t h_se \t hpol \t htot \t vtot \t underflow\n");

commit 5e9a4f0873fd357bdec29b3b96667ef0cea64c46
Author: Clark Zheng <clark.zheng@amd.com>
Date:   Thu Mar 15 14:02:06 2018 +0800

    drm/amd/display: Refine disable VGA
    
    bad case won't follow normal sense, it will not enable vga1 as usual, but vga2,3,4 is on.
    
    Signed-off-by: Clark Zheng <clark.zheng@amd.com>
    Reviewed-by: Tony Cheng <tony.cheng@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 4365906b14ee..8b0f6b8a5627 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -220,14 +220,24 @@ static void enable_power_gating_plane(
 static void disable_vga(
 	struct dce_hwseq *hws)
 {
-	unsigned int in_vga_mode = 0;
-
-	REG_GET(D1VGA_CONTROL, D1VGA_MODE_ENABLE, &in_vga_mode);
-
-	if (in_vga_mode == 0)
+	unsigned int in_vga1_mode = 0;
+	unsigned int in_vga2_mode = 0;
+	unsigned int in_vga3_mode = 0;
+	unsigned int in_vga4_mode = 0;
+
+	REG_GET(D1VGA_CONTROL, D1VGA_MODE_ENABLE, &in_vga1_mode);
+	REG_GET(D2VGA_CONTROL, D2VGA_MODE_ENABLE, &in_vga2_mode);
+	REG_GET(D3VGA_CONTROL, D3VGA_MODE_ENABLE, &in_vga3_mode);
+	REG_GET(D4VGA_CONTROL, D4VGA_MODE_ENABLE, &in_vga4_mode);
+
+	if (in_vga1_mode == 0 && in_vga2_mode == 0 &&
+			in_vga3_mode == 0 && in_vga4_mode == 0)
 		return;
 
 	REG_WRITE(D1VGA_CONTROL, 0);
+	REG_WRITE(D2VGA_CONTROL, 0);
+	REG_WRITE(D3VGA_CONTROL, 0);
+	REG_WRITE(D4VGA_CONTROL, 0);
 
 	/* HW Engineer's Notes:
 	 *  During switch from vga->extended, if we set the VGA_TEST_ENABLE and

commit 17ac50368f83ead67f9e3c9b9704f927f214da9d
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Feb 16 13:18:59 2018 -0500

    drm/amd/display: clean up dcn pplib notification call
    
    We have unused variables being populated when notifying pplib.
    This change amends that.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 9f9b910b7f6d..4365906b14ee 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1703,7 +1703,7 @@ static void update_dchubp_dpp(
 	 * divided by 2
 	 */
 	if (plane_state->update_flags.bits.full_update) {
-		bool should_divided_by_2 = context->bw.dcn.calc_clk.max_dppclk_khz <=
+		bool should_divided_by_2 = context->bw.dcn.calc_clk.dppclk_khz <=
 				context->bw.dcn.cur_clk.dispclk_khz / 2;
 
 		dpp->funcs->dpp_dppclk_control(
@@ -1711,7 +1711,7 @@ static void update_dchubp_dpp(
 				should_divided_by_2,
 				true);
 
-		dc->current_state->bw.dcn.cur_clk.max_dppclk_khz =
+		dc->current_state->bw.dcn.cur_clk.dppclk_khz =
 				should_divided_by_2 ?
 				context->bw.dcn.cur_clk.dispclk_khz / 2 :
 				context->bw.dcn.cur_clk.dispclk_khz;
@@ -1904,16 +1904,10 @@ static void dcn10_pplib_apply_display_requirements(
 {
 	struct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;
 
-	pp_display_cfg->all_displays_in_sync = false;/*todo*/
-	pp_display_cfg->nb_pstate_switch_disable = false;
 	pp_display_cfg->min_engine_clock_khz = context->bw.dcn.cur_clk.dcfclk_khz;
 	pp_display_cfg->min_memory_clock_khz = context->bw.dcn.cur_clk.fclk_khz;
 	pp_display_cfg->min_engine_clock_deep_sleep_khz = context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz;
 	pp_display_cfg->min_dcfc_deep_sleep_clock_khz = context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz;
-	pp_display_cfg->avail_mclk_switch_time_us =
-			context->bw.dcn.cur_clk.dram_ccm_us > 0 ? context->bw.dcn.cur_clk.dram_ccm_us : 0;
-	pp_display_cfg->avail_mclk_switch_time_in_disp_active_us =
-			context->bw.dcn.cur_clk.min_active_dram_ccm_us > 0 ? context->bw.dcn.cur_clk.min_active_dram_ccm_us : 0;
 	pp_display_cfg->min_dcfclock_khz = context->bw.dcn.cur_clk.dcfclk_khz;
 	pp_display_cfg->disp_clk_khz = context->bw.dcn.cur_clk.dispclk_khz;
 	dce110_fill_display_configs(context, pp_display_cfg);
@@ -2126,12 +2120,12 @@ static inline bool should_set_clock(bool decrease_allowed, int calc_clk, int cur
 static int determine_dppclk_threshold(struct dc *dc, struct dc_state *context)
 {
 	bool request_dpp_div = context->bw.dcn.calc_clk.dispclk_khz >
-			context->bw.dcn.calc_clk.max_dppclk_khz;
+			context->bw.dcn.calc_clk.dppclk_khz;
 	bool dispclk_increase = context->bw.dcn.calc_clk.dispclk_khz >
 			context->bw.dcn.cur_clk.dispclk_khz;
 	int disp_clk_threshold = context->bw.dcn.calc_clk.max_supported_dppclk_khz;
 	bool cur_dpp_div = context->bw.dcn.cur_clk.dispclk_khz >
-			context->bw.dcn.cur_clk.max_dppclk_khz;
+			context->bw.dcn.cur_clk.dppclk_khz;
 
 	/* increase clock, looking for div is 0 for current, request div is 1*/
 	if (dispclk_increase) {
@@ -2176,7 +2170,7 @@ static void ramp_up_dispclk_with_dpp(struct dc *dc, struct dc_state *context)
 {
 	int i;
 	bool request_dpp_div = context->bw.dcn.calc_clk.dispclk_khz >
-				context->bw.dcn.calc_clk.max_dppclk_khz;
+				context->bw.dcn.calc_clk.dppclk_khz;
 
 	int dispclk_to_dpp_threshold = determine_dppclk_threshold(dc, context);
 
@@ -2207,8 +2201,8 @@ static void ramp_up_dispclk_with_dpp(struct dc *dc, struct dc_state *context)
 
 	context->bw.dcn.cur_clk.dispclk_khz =
 			context->bw.dcn.calc_clk.dispclk_khz;
-	context->bw.dcn.cur_clk.max_dppclk_khz =
-			context->bw.dcn.calc_clk.max_dppclk_khz;
+	context->bw.dcn.cur_clk.dppclk_khz =
+			context->bw.dcn.calc_clk.dppclk_khz;
 	context->bw.dcn.cur_clk.max_supported_dppclk_khz =
 			context->bw.dcn.calc_clk.max_supported_dppclk_khz;
 }
@@ -2275,21 +2269,6 @@ static void dcn10_set_bandwidth(
 		ramp_up_dispclk_with_dpp(dc, context);
 	}
 
-	/* Decrease in freq is increase in period so opposite comparison for dram_ccm */
-	if ((decrease_allowed && context->bw.dcn.calc_clk.dram_ccm_us
-			> dc->current_state->bw.dcn.cur_clk.dram_ccm_us) ||
-		context->bw.dcn.calc_clk.dram_ccm_us
-			< dc->current_state->bw.dcn.cur_clk.dram_ccm_us) {
-		context->bw.dcn.cur_clk.dram_ccm_us =
-				context->bw.dcn.calc_clk.dram_ccm_us;
-	}
-	if ((decrease_allowed && context->bw.dcn.calc_clk.min_active_dram_ccm_us
-			> dc->current_state->bw.dcn.cur_clk.min_active_dram_ccm_us) ||
-		context->bw.dcn.calc_clk.min_active_dram_ccm_us
-			< dc->current_state->bw.dcn.cur_clk.min_active_dram_ccm_us) {
-		context->bw.dcn.cur_clk.min_active_dram_ccm_us =
-				context->bw.dcn.calc_clk.min_active_dram_ccm_us;
-	}
 	dcn10_pplib_apply_display_requirements(dc, context);
 
 	if (dc->debug.sanity_checks) {

commit 45bb8dd696eaff9c96afd2b210f0d8cf5025dd65
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Feb 28 17:14:50 2018 -0500

    drm/amd/display: Set disp clk in a safe way to avoid over high dpp clk. (v2)
    
    Increase clock, if current dpp div is 0 and request dpp div is 1, request clk is
    higher than maximum dpp clk as per dpm table.
            set dispclk to the value of maximum supported dpp clk
            set div to 1
            set dispclk to request value.
    Decrease clock, currrent dpp div is 1 and request dpp div is 0, current clk is
    higher than maximum dpp clk as per dpm table.
            set dispclk to the value of maximum supported dpp clk
            set div to 0
            set dispclk to request value.
    
    v2: squash in !DCN build fix
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 50088b674795..9f9b910b7f6d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1699,16 +1699,22 @@ static void update_dchubp_dpp(
 	union plane_size size = plane_state->plane_size;
 
 	/* depends on DML calculation, DPP clock value may change dynamically */
+	/* If request max dpp clk is lower than current dispclk, no need to
+	 * divided by 2
+	 */
 	if (plane_state->update_flags.bits.full_update) {
+		bool should_divided_by_2 = context->bw.dcn.calc_clk.max_dppclk_khz <=
+				context->bw.dcn.cur_clk.dispclk_khz / 2;
+
 		dpp->funcs->dpp_dppclk_control(
 				dpp,
-				context->bw.dcn.calc_clk.max_dppclk_khz <
-						context->bw.dcn.calc_clk.dispclk_khz,
+				should_divided_by_2,
 				true);
 
 		dc->current_state->bw.dcn.cur_clk.max_dppclk_khz =
-				context->bw.dcn.calc_clk.max_dppclk_khz;
-		context->bw.dcn.cur_clk.max_dppclk_khz = context->bw.dcn.calc_clk.max_dppclk_khz;
+				should_divided_by_2 ?
+				context->bw.dcn.cur_clk.dispclk_khz / 2 :
+				context->bw.dcn.cur_clk.dispclk_khz;
 	}
 
 	/* TODO: Need input parameter to tell current DCHUB pipe tie to which OTG
@@ -2117,6 +2123,96 @@ static inline bool should_set_clock(bool decrease_allowed, int calc_clk, int cur
 	return ((decrease_allowed && calc_clk < cur_clk) || calc_clk > cur_clk);
 }
 
+static int determine_dppclk_threshold(struct dc *dc, struct dc_state *context)
+{
+	bool request_dpp_div = context->bw.dcn.calc_clk.dispclk_khz >
+			context->bw.dcn.calc_clk.max_dppclk_khz;
+	bool dispclk_increase = context->bw.dcn.calc_clk.dispclk_khz >
+			context->bw.dcn.cur_clk.dispclk_khz;
+	int disp_clk_threshold = context->bw.dcn.calc_clk.max_supported_dppclk_khz;
+	bool cur_dpp_div = context->bw.dcn.cur_clk.dispclk_khz >
+			context->bw.dcn.cur_clk.max_dppclk_khz;
+
+	/* increase clock, looking for div is 0 for current, request div is 1*/
+	if (dispclk_increase) {
+		/* already divided by 2, no need to reach target clk with 2 steps*/
+		if (cur_dpp_div)
+			return context->bw.dcn.calc_clk.dispclk_khz;
+
+		/* request disp clk is lower than maximum supported dpp clk,
+		 * no need to reach target clk with two steps.
+		 */
+		if (context->bw.dcn.calc_clk.dispclk_khz <= disp_clk_threshold)
+			return context->bw.dcn.calc_clk.dispclk_khz;
+
+		/* target dpp clk not request divided by 2, still within threshold */
+		if (!request_dpp_div)
+			return context->bw.dcn.calc_clk.dispclk_khz;
+
+	} else {
+		/* decrease clock, looking for current dppclk divided by 2,
+		 * request dppclk not divided by 2.
+		 */
+
+		/* current dpp clk not divided by 2, no need to ramp*/
+		if (!cur_dpp_div)
+			return context->bw.dcn.calc_clk.dispclk_khz;
+
+		/* current disp clk is lower than current maximum dpp clk,
+		 * no need to ramp
+		 */
+		if (context->bw.dcn.cur_clk.dispclk_khz <= disp_clk_threshold)
+			return context->bw.dcn.calc_clk.dispclk_khz;
+
+		/* request dpp clk need to be divided by 2 */
+		if (request_dpp_div)
+			return context->bw.dcn.calc_clk.dispclk_khz;
+	}
+
+	return disp_clk_threshold;
+}
+
+static void ramp_up_dispclk_with_dpp(struct dc *dc, struct dc_state *context)
+{
+	int i;
+	bool request_dpp_div = context->bw.dcn.calc_clk.dispclk_khz >
+				context->bw.dcn.calc_clk.max_dppclk_khz;
+
+	int dispclk_to_dpp_threshold = determine_dppclk_threshold(dc, context);
+
+	/* set disp clk to dpp clk threshold */
+	dc->res_pool->display_clock->funcs->set_clock(
+			dc->res_pool->display_clock,
+			dispclk_to_dpp_threshold);
+
+	/* update request dpp clk division option */
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
+
+		if (!pipe_ctx->plane_state)
+			continue;
+
+		pipe_ctx->plane_res.dpp->funcs->dpp_dppclk_control(
+				pipe_ctx->plane_res.dpp,
+				request_dpp_div,
+				true);
+	}
+
+	/* If target clk not same as dppclk threshold, set to target clock */
+	if (dispclk_to_dpp_threshold != context->bw.dcn.calc_clk.dispclk_khz) {
+		dc->res_pool->display_clock->funcs->set_clock(
+				dc->res_pool->display_clock,
+				context->bw.dcn.calc_clk.dispclk_khz);
+	}
+
+	context->bw.dcn.cur_clk.dispclk_khz =
+			context->bw.dcn.calc_clk.dispclk_khz;
+	context->bw.dcn.cur_clk.max_dppclk_khz =
+			context->bw.dcn.calc_clk.max_dppclk_khz;
+	context->bw.dcn.cur_clk.max_supported_dppclk_khz =
+			context->bw.dcn.calc_clk.max_supported_dppclk_khz;
+}
+
 static void dcn10_set_bandwidth(
 		struct dc *dc,
 		struct dc_state *context,
@@ -2134,17 +2230,6 @@ static void dcn10_set_bandwidth(
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
 		return;
 
-	if (should_set_clock(
-			decrease_allowed,
-			context->bw.dcn.calc_clk.dispclk_khz,
-			dc->current_state->bw.dcn.cur_clk.dispclk_khz)) {
-		dc->res_pool->display_clock->funcs->set_clock(
-				dc->res_pool->display_clock,
-				context->bw.dcn.calc_clk.dispclk_khz);
-		context->bw.dcn.cur_clk.dispclk_khz =
-				context->bw.dcn.calc_clk.dispclk_khz;
-	}
-
 	if (should_set_clock(
 			decrease_allowed,
 			context->bw.dcn.calc_clk.dcfclk_khz,
@@ -2155,6 +2240,14 @@ static void dcn10_set_bandwidth(
 				context->bw.dcn.calc_clk.dcfclk_khz;
 	}
 
+	if (should_set_clock(
+			decrease_allowed,
+			context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz,
+			dc->current_state->bw.dcn.cur_clk.dcfclk_deep_sleep_khz)) {
+		context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz =
+				context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
+	}
+
 	if (should_set_clock(
 			decrease_allowed,
 			context->bw.dcn.calc_clk.fclk_khz,
@@ -2164,14 +2257,6 @@ static void dcn10_set_bandwidth(
 		smu_req.hard_min_fclk_khz = context->bw.dcn.calc_clk.fclk_khz;
 	}
 
-	if (should_set_clock(
-			decrease_allowed,
-			context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz,
-			dc->current_state->bw.dcn.cur_clk.dcfclk_deep_sleep_khz)) {
-		context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz =
-				context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
-	}
-
 	smu_req.display_count = context->stream_count;
 
 	if (pp_smu->set_display_requirement)
@@ -2179,6 +2264,17 @@ static void dcn10_set_bandwidth(
 
 	*smu_req_cur = smu_req;
 
+	/* make sure dcf clk is before dpp clk to
+	 * make sure we have enough voltage to run dpp clk
+	 */
+	if (should_set_clock(
+			decrease_allowed,
+			context->bw.dcn.calc_clk.dispclk_khz,
+			dc->current_state->bw.dcn.cur_clk.dispclk_khz)) {
+
+		ramp_up_dispclk_with_dpp(dc, context);
+	}
+
 	/* Decrease in freq is increase in period so opposite comparison for dram_ccm */
 	if ((decrease_allowed && context->bw.dcn.calc_clk.dram_ccm_us
 			> dc->current_state->bw.dcn.cur_clk.dram_ccm_us) ||

commit e18d3086733bd150f87594a754ae983329fb0ba1
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Wed Feb 28 14:45:36 2018 -0500

    drm/amd/display: early return if not in vga mode in disable_vga
    
    The work around for hw bug causes S3 resume failure. Don't execute
    disable vga logic if not in vga mode.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 0874d4a3fd72..50088b674795 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -220,10 +220,14 @@ static void enable_power_gating_plane(
 static void disable_vga(
 	struct dce_hwseq *hws)
 {
+	unsigned int in_vga_mode = 0;
+
+	REG_GET(D1VGA_CONTROL, D1VGA_MODE_ENABLE, &in_vga_mode);
+
+	if (in_vga_mode == 0)
+		return;
+
 	REG_WRITE(D1VGA_CONTROL, 0);
-	REG_WRITE(D2VGA_CONTROL, 0);
-	REG_WRITE(D3VGA_CONTROL, 0);
-	REG_WRITE(D4VGA_CONTROL, 0);
 
 	/* HW Engineer's Notes:
 	 *  During switch from vga->extended, if we set the VGA_TEST_ENABLE and

commit a4056c2a6344c64bd62234458a314e6aecce226f
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Fri Feb 23 17:51:33 2018 -0500

    drm/amd/display: use HW hdr mult for brightness boost
    
    In MPO scenario when playing SDR clip in HDR desktop mode, Win is
    boosting desktop and requests driver to boost MPO. But driver boosting
    is currently done in regamma which is stream property and thus shared
    between grph and video.
    
    Redesigning the boosting in RV: use CM_HDR_MULT register which was added
    for this scenario. It also has the benefit that it can be done in HIRQL.
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 5257f32c965b..0874d4a3fd72 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1821,6 +1821,24 @@ static void dcn10_otg_blank(
 	}
 }
 
+static void set_hdr_multiplier(struct pipe_ctx *pipe_ctx)
+{
+	struct fixed31_32 multiplier = dal_fixed31_32_from_fraction(
+			pipe_ctx->plane_state->sdr_white_level, 80);
+	uint32_t hw_mult = 0x1f000; // 1.0 default multiplier
+	struct custom_float_format fmt;
+
+	fmt.exponenta_bits = 6;
+	fmt.mantissa_bits = 12;
+	fmt.sign = true;
+
+	if (pipe_ctx->plane_state->sdr_white_level > 80)
+		convert_to_custom_float_format(multiplier, &fmt, &hw_mult);
+
+	pipe_ctx->plane_res.dpp->funcs->dpp_set_hdr_multiplier(
+			pipe_ctx->plane_res.dpp, hw_mult);
+}
+
 static void program_all_pipe_in_tree(
 		struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
@@ -1848,6 +1866,8 @@ static void program_all_pipe_in_tree(
 
 		update_dchubp_dpp(dc, pipe_ctx, context);
 
+		set_hdr_multiplier(pipe_ctx);
+
 		if (pipe_ctx->plane_state->update_flags.bits.full_update ||
 				pipe_ctx->plane_state->update_flags.bits.in_transfer_func_change ||
 				pipe_ctx->plane_state->update_flags.bits.gamma_change)

commit 8e437c799158be80aa1ae27f362e30081e2a1e9f
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Feb 27 15:06:31 2018 -0500

    drm/amd/display: Modified set bandwidth sequence.
    
    This change make sure bandwidth is set properly.
    For increase bandwidth, set bandwidth before backend
    and front end programming.
    For decrease bandwidth, set bandwidth after.
    To avoid smu hang when reboot and dpms due to 0 disp clk,
    keep min disp clock as 100Mhz.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f1990c3c893d..5257f32c965b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2088,6 +2088,11 @@ static void dcn10_apply_ctx_for_surface(
 */
 }
 
+static inline bool should_set_clock(bool decrease_allowed, int calc_clk, int cur_clk)
+{
+	return ((decrease_allowed && calc_clk < cur_clk) || calc_clk > cur_clk);
+}
+
 static void dcn10_set_bandwidth(
 		struct dc *dc,
 		struct dc_state *context,
@@ -2105,29 +2110,40 @@ static void dcn10_set_bandwidth(
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
 		return;
 
-	if (decrease_allowed || context->bw.dcn.calc_clk.dispclk_khz
-			> dc->current_state->bw.dcn.cur_clk.dispclk_khz) {
+	if (should_set_clock(
+			decrease_allowed,
+			context->bw.dcn.calc_clk.dispclk_khz,
+			dc->current_state->bw.dcn.cur_clk.dispclk_khz)) {
 		dc->res_pool->display_clock->funcs->set_clock(
 				dc->res_pool->display_clock,
 				context->bw.dcn.calc_clk.dispclk_khz);
 		context->bw.dcn.cur_clk.dispclk_khz =
 				context->bw.dcn.calc_clk.dispclk_khz;
 	}
-	if (decrease_allowed || context->bw.dcn.calc_clk.dcfclk_khz
-			> dc->current_state->bw.dcn.cur_clk.dcfclk_khz) {
+
+	if (should_set_clock(
+			decrease_allowed,
+			context->bw.dcn.calc_clk.dcfclk_khz,
+			dc->current_state->bw.dcn.cur_clk.dcfclk_khz)) {
 		context->bw.dcn.cur_clk.dcfclk_khz =
 				context->bw.dcn.calc_clk.dcfclk_khz;
 		smu_req.hard_min_dcefclk_khz =
 				context->bw.dcn.calc_clk.dcfclk_khz;
 	}
-	if (decrease_allowed || context->bw.dcn.calc_clk.fclk_khz
-			> dc->current_state->bw.dcn.cur_clk.fclk_khz) {
+
+	if (should_set_clock(
+			decrease_allowed,
+			context->bw.dcn.calc_clk.fclk_khz,
+			dc->current_state->bw.dcn.cur_clk.fclk_khz)) {
 		context->bw.dcn.cur_clk.fclk_khz =
 				context->bw.dcn.calc_clk.fclk_khz;
 		smu_req.hard_min_fclk_khz = context->bw.dcn.calc_clk.fclk_khz;
 	}
-	if (decrease_allowed || context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz
-			> dc->current_state->bw.dcn.cur_clk.dcfclk_deep_sleep_khz) {
+
+	if (should_set_clock(
+			decrease_allowed,
+			context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz,
+			dc->current_state->bw.dcn.cur_clk.dcfclk_deep_sleep_khz)) {
 		context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz =
 				context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
 	}
@@ -2140,12 +2156,16 @@ static void dcn10_set_bandwidth(
 	*smu_req_cur = smu_req;
 
 	/* Decrease in freq is increase in period so opposite comparison for dram_ccm */
-	if (decrease_allowed || context->bw.dcn.calc_clk.dram_ccm_us
+	if ((decrease_allowed && context->bw.dcn.calc_clk.dram_ccm_us
+			> dc->current_state->bw.dcn.cur_clk.dram_ccm_us) ||
+		context->bw.dcn.calc_clk.dram_ccm_us
 			< dc->current_state->bw.dcn.cur_clk.dram_ccm_us) {
 		context->bw.dcn.cur_clk.dram_ccm_us =
 				context->bw.dcn.calc_clk.dram_ccm_us;
 	}
-	if (decrease_allowed || context->bw.dcn.calc_clk.min_active_dram_ccm_us
+	if ((decrease_allowed && context->bw.dcn.calc_clk.min_active_dram_ccm_us
+			> dc->current_state->bw.dcn.cur_clk.min_active_dram_ccm_us) ||
+		context->bw.dcn.calc_clk.min_active_dram_ccm_us
 			< dc->current_state->bw.dcn.cur_clk.min_active_dram_ccm_us) {
 		context->bw.dcn.cur_clk.min_active_dram_ccm_us =
 				context->bw.dcn.calc_clk.min_active_dram_ccm_us;

commit 90e3103e1966c5553b2a0ba9e699b9bf2fdb5ae7
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Feb 27 12:12:46 2018 -0500

    drm/amd/display: Fix takover from VGA mode
    
    HW Engineer's Notes:
     During switch from vga->extended, if we set the VGA_TEST_ENABLE and then
     hit the VGA_TEST_RENDER_START, then the DCHUBP timing gets updated correctly.
     Then vBIOS will have it poll for the VGA_TEST_RENDER_DONE and unset
     VGA_TEST_ENABLE, to leave it in the same state as before.
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c1a07ecd2927..f1990c3c893d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -224,6 +224,16 @@ static void disable_vga(
 	REG_WRITE(D2VGA_CONTROL, 0);
 	REG_WRITE(D3VGA_CONTROL, 0);
 	REG_WRITE(D4VGA_CONTROL, 0);
+
+	/* HW Engineer's Notes:
+	 *  During switch from vga->extended, if we set the VGA_TEST_ENABLE and
+	 *  then hit the VGA_TEST_RENDER_START, then the DCHUBP timing gets updated correctly.
+	 *
+	 *  Then vBIOS will have it poll for the VGA_TEST_RENDER_DONE and unset
+	 *  VGA_TEST_ENABLE, to leave it in the same state as before.
+	 */
+	REG_UPDATE(VGA_TEST_CONTROL, VGA_TEST_ENABLE, 1);
+	REG_UPDATE(VGA_TEST_CONTROL, VGA_TEST_RENDER_START, 1);
 }
 
 static void dpp_pg_control(

commit 9aef1a31709076660f7d5f638ab5ecadea4ca856
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Fri Feb 23 13:04:13 2018 -0500

    drm/amd/display: Varibright fix bug and review comments
    
    Fix bug and make changes from review 132656
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c434e38e6e46..c1a07ecd2927 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1781,20 +1781,31 @@ static void update_dchubp_dpp(
 }
 
 static void dcn10_otg_blank(
+		struct dc *dc,
 		struct stream_resource stream_res,
-		struct abm *abm,
 		struct dc_stream_state *stream,
 		bool blank)
 {
+	enum dc_color_space color_space;
+	struct tg_color black_color = {0};
+
+	/* program otg blank color */
+	color_space = stream->output_color_space;
+	color_space_to_black_color(dc, color_space, &black_color);
+
+	if (stream_res.tg->funcs->set_blank_color)
+		stream_res.tg->funcs->set_blank_color(
+				stream_res.tg,
+				&black_color);
 
 	if (!blank) {
 		if (stream_res.tg->funcs->set_blank)
 			stream_res.tg->funcs->set_blank(stream_res.tg, blank);
-		if (abm)
-			abm->funcs->set_abm_level(abm, stream->abm_settings.abm_level);
+		if (stream_res.abm)
+			stream_res.abm->funcs->set_abm_level(stream_res.abm, stream->abm_level);
 	} else if (blank) {
-		if (abm)
-			abm->funcs->set_abm_immediate_disable(abm);
+		if (stream_res.abm)
+			stream_res.abm->funcs->set_abm_immediate_disable(stream_res.abm);
 		if (stream_res.tg->funcs->set_blank)
 			stream_res.tg->funcs->set_blank(stream_res.tg, blank);
 	}
@@ -1817,7 +1828,7 @@ static void program_all_pipe_in_tree(
 		pipe_ctx->stream_res.tg->funcs->program_global_sync(
 				pipe_ctx->stream_res.tg);
 
-		dcn10_otg_blank(pipe_ctx->stream_res, dc->res_pool->abm,
+		dcn10_otg_blank(dc, pipe_ctx->stream_res,
 				pipe_ctx->stream, blank);
 	}
 
@@ -1941,7 +1952,7 @@ static void dcn10_apply_ctx_for_surface(
 
 	if (num_planes == 0) {
 		/* OTG blank before remove all front end */
-		dcn10_otg_blank(top_pipe_to_program->stream_res, dc->res_pool->abm, top_pipe_to_program->stream, true);
+		dcn10_otg_blank(dc, top_pipe_to_program->stream_res, top_pipe_to_program->stream, true);
 	}
 
 	/* Disconnect unused mpcc */

commit aa5a5777304228819a52562d346bc3eb1b4873fa
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Tue Feb 13 17:37:23 2018 -0500

    drm/amd/display: Vari-bright looks disabled near end of MM14
    
    Avoid hanging DMCU by setting abm level only when OTG unblanked
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 1907ade1574a..c434e38e6e46 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1780,14 +1780,33 @@ static void update_dchubp_dpp(
 		hubp->funcs->set_blank(hubp, false);
 }
 
+static void dcn10_otg_blank(
+		struct stream_resource stream_res,
+		struct abm *abm,
+		struct dc_stream_state *stream,
+		bool blank)
+{
+
+	if (!blank) {
+		if (stream_res.tg->funcs->set_blank)
+			stream_res.tg->funcs->set_blank(stream_res.tg, blank);
+		if (abm)
+			abm->funcs->set_abm_level(abm, stream->abm_settings.abm_level);
+	} else if (blank) {
+		if (abm)
+			abm->funcs->set_abm_immediate_disable(abm);
+		if (stream_res.tg->funcs->set_blank)
+			stream_res.tg->funcs->set_blank(stream_res.tg, blank);
+	}
+}
 
 static void program_all_pipe_in_tree(
 		struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
 		struct dc_state *context)
 {
-
 	if (pipe_ctx->top_pipe == NULL) {
+		bool blank = !is_pipe_tree_visible(pipe_ctx);
 
 		pipe_ctx->stream_res.tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
 		pipe_ctx->stream_res.tg->dlg_otg_param.vstartup_start = pipe_ctx->pipe_dlg_param.vstartup_start;
@@ -1798,10 +1817,8 @@ static void program_all_pipe_in_tree(
 		pipe_ctx->stream_res.tg->funcs->program_global_sync(
 				pipe_ctx->stream_res.tg);
 
-		if (pipe_ctx->stream_res.tg->funcs->set_blank)
-			pipe_ctx->stream_res.tg->funcs->set_blank(
-					pipe_ctx->stream_res.tg,
-					!is_pipe_tree_visible(pipe_ctx));
+		dcn10_otg_blank(pipe_ctx->stream_res, dc->res_pool->abm,
+				pipe_ctx->stream, blank);
 	}
 
 	if (pipe_ctx->plane_state != NULL) {
@@ -1908,29 +1925,23 @@ static void dcn10_apply_ctx_for_surface(
 {
 	int i;
 	struct timing_generator *tg;
-	struct output_pixel_processor *opp;
 	bool removed_pipe[4] = { false };
 	unsigned int ref_clk_mhz = dc->res_pool->ref_clock_inKhz/1000;
 	bool program_water_mark = false;
 	struct dc_context *ctx = dc->ctx;
-
 	struct pipe_ctx *top_pipe_to_program =
 			find_top_pipe_for_stream(dc, context, stream);
 
 	if (!top_pipe_to_program)
 		return;
 
-	opp = top_pipe_to_program->stream_res.opp;
-
 	tg = top_pipe_to_program->stream_res.tg;
 
 	dcn10_pipe_control_lock(dc, top_pipe_to_program, true);
 
 	if (num_planes == 0) {
-
 		/* OTG blank before remove all front end */
-		if (tg->funcs->set_blank)
-			tg->funcs->set_blank(tg, true);
+		dcn10_otg_blank(top_pipe_to_program->stream_res, dc->res_pool->abm, top_pipe_to_program->stream, true);
 	}
 
 	/* Disconnect unused mpcc */

commit 1296423bf23c7a58133970e223b1f47ec6570308
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Feb 20 17:42:50 2018 -0500

    drm/amd/display: define DC_LOGGER for logger
    
    Created a DC_LOGGER define. This is used to
    pass the logger into the macros.
    
    Anywhere we need to use the logger we need to define
    DC_LOGGER
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index aa5516539c95..1907ade1574a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -45,6 +45,8 @@
 #include "dcn10_hubbub.h"
 #include "dcn10_cm_common.h"
 
+#define DC_LOGGER \
+	ctx->logger
 #define CTX \
 	hws->ctx
 #define REG(reg)\
@@ -328,6 +330,7 @@ static void power_on_plane(
 	struct dce_hwseq *hws,
 	int plane_id)
 {
+	struct dc_context *ctx = hws->ctx;
 	if (REG(DC_IP_REQUEST_CNTL)) {
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 1);
@@ -335,7 +338,7 @@ static void power_on_plane(
 		hubp_pg_control(hws, plane_id, true);
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 0);
-		DC_LOG_DEBUG(hws->ctx->logger,
+		DC_LOG_DEBUG(
 				"Un-gated front end for pipe %d\n", plane_id);
 	}
 }
@@ -526,7 +529,7 @@ static void reset_back_end_for_pipe(
 		struct dc_state *context)
 {
 	int i;
-
+	struct dc_context *ctx = dc->ctx;
 	if (pipe_ctx->stream_res.stream_enc == NULL) {
 		pipe_ctx->stream = NULL;
 		return;
@@ -572,8 +575,7 @@ static void reset_back_end_for_pipe(
 		return;
 
 	pipe_ctx->stream = NULL;
-	DC_LOG_DEBUG(dc->ctx->logger,
-					"Reset back end for pipe %d, tg:%d\n",
+	DC_LOG_DEBUG("Reset back end for pipe %d, tg:%d\n",
 					pipe_ctx->pipe_idx, pipe_ctx->stream_res.tg->inst);
 }
 
@@ -623,6 +625,7 @@ static void plane_atomic_power_down(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct dpp *dpp = pipe_ctx->plane_res.dpp;
+	struct dc_context *ctx = dc->ctx;
 
 	if (REG(DC_IP_REQUEST_CNTL)) {
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
@@ -632,7 +635,7 @@ static void plane_atomic_power_down(struct dc *dc, struct pipe_ctx *pipe_ctx)
 		dpp->funcs->dpp_reset(dpp);
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 0);
-		DC_LOG_DEBUG(dc->ctx->logger,
+		DC_LOG_DEBUG(
 				"Power gated front end %d\n", pipe_ctx->pipe_idx);
 	}
 }
@@ -672,6 +675,8 @@ static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 
 static void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
+	struct dc_context *ctx = dc->ctx;
+
 	if (!pipe_ctx->plane_res.hubp || pipe_ctx->plane_res.hubp->power_gated)
 		return;
 
@@ -679,8 +684,7 @@ static void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
 
 	apply_DEGVIDCN10_253_wa(dc);
 
-	DC_LOG_DC(dc->ctx->logger,
-					"Power down front end %d\n",
+	DC_LOG_DC("Power down front end %d\n",
 					pipe_ctx->pipe_idx);
 }
 
@@ -1908,6 +1912,7 @@ static void dcn10_apply_ctx_for_surface(
 	bool removed_pipe[4] = { false };
 	unsigned int ref_clk_mhz = dc->res_pool->ref_clock_inKhz/1000;
 	bool program_water_mark = false;
+	struct dc_context *ctx = dc->ctx;
 
 	struct pipe_ctx *top_pipe_to_program =
 			find_top_pipe_for_stream(dc, context, stream);
@@ -1959,7 +1964,7 @@ static void dcn10_apply_ctx_for_surface(
 			plane_atomic_disconnect(dc, old_pipe_ctx);
 			removed_pipe[i] = true;
 
-			DC_LOG_DC(dc->ctx->logger,
+			DC_LOG_DC(
 					"Reset mpcc for pipe %d\n",
 					old_pipe_ctx->pipe_idx);
 		}

commit 2f3fd67a8af25f5b4d549c3e9cc515dbf1839ffc
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Fri Feb 16 13:57:42 2018 -0500

    drm/amd/display: Use MACROS instead of dm_logger
    
    Created MACROS for all log levels. Also Replaced
    usage of dm_logger_write to the defined MACROS
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index b4a6b6729e62..aa5516539c95 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -335,7 +335,7 @@ static void power_on_plane(
 		hubp_pg_control(hws, plane_id, true);
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 0);
-		dm_logger_write(hws->ctx->logger, LOG_DEBUG,
+		DC_LOG_DEBUG(hws->ctx->logger,
 				"Un-gated front end for pipe %d\n", plane_id);
 	}
 }
@@ -572,7 +572,7 @@ static void reset_back_end_for_pipe(
 		return;
 
 	pipe_ctx->stream = NULL;
-	dm_logger_write(dc->ctx->logger, LOG_DEBUG,
+	DC_LOG_DEBUG(dc->ctx->logger,
 					"Reset back end for pipe %d, tg:%d\n",
 					pipe_ctx->pipe_idx, pipe_ctx->stream_res.tg->inst);
 }
@@ -632,7 +632,7 @@ static void plane_atomic_power_down(struct dc *dc, struct pipe_ctx *pipe_ctx)
 		dpp->funcs->dpp_reset(dpp);
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 0);
-		dm_logger_write(dc->ctx->logger, LOG_DEBUG,
+		DC_LOG_DEBUG(dc->ctx->logger,
 				"Power gated front end %d\n", pipe_ctx->pipe_idx);
 	}
 }
@@ -679,7 +679,7 @@ static void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
 
 	apply_DEGVIDCN10_253_wa(dc);
 
-	dm_logger_write(dc->ctx->logger, LOG_DC,
+	DC_LOG_DC(dc->ctx->logger,
 					"Power down front end %d\n",
 					pipe_ctx->pipe_idx);
 }
@@ -1102,7 +1102,7 @@ static void dcn10_enable_per_frame_crtc_position_reset(
 		struct dc *core_dc,
 		struct pipe_ctx *pipe_ctx)
 {
-	dm_logger_write(core_dc->ctx->logger, LOG_BANDWIDTH_CALCS,
+	DC_LOG_BANDWIDTH_CALCS(core_dc->ctx->logger,
 			"\n============== DML TTU Output parameters [%d] ==============\n"
 			"qos_level_low_wm: %d, \n"
 			"qos_level_high_wm: %d, \n"
@@ -1132,7 +1132,7 @@ static void dcn10_enable_per_frame_crtc_position_reset(
 			pipe_ctx->ttu_regs.refcyc_per_req_delivery_pre_c
 			);
 
-	dm_logger_write(core_dc->ctx->logger, LOG_BANDWIDTH_CALCS,
+	DC_LOG_BANDWIDTH_CALCS(core_dc->ctx->logger,
 			"\n============== DML DLG Output parameters [%d] ==============\n"
 			"refcyc_h_blank_end: %d, \n"
 			"dlg_vblank_end: %d, \n"
@@ -1167,7 +1167,7 @@ static void dcn10_enable_per_frame_crtc_position_reset(
 			pipe_ctx->dlg_regs.refcyc_per_pte_group_nom_l
 			);
 
-	dm_logger_write(core_dc->ctx->logger, LOG_BANDWIDTH_CALCS,
+	DC_LOG_BANDWIDTH_CALCS(core_dc->ctx->logger,
 			"\ndst_y_per_meta_row_nom_l: %d, \n"
 			"refcyc_per_meta_chunk_nom_l: %d, \n"
 			"refcyc_per_line_delivery_pre_l: %d, \n"
@@ -1197,7 +1197,7 @@ static void dcn10_enable_per_frame_crtc_position_reset(
 			pipe_ctx->dlg_regs.refcyc_per_line_delivery_c
 			);
 
-	dm_logger_write(core_dc->ctx->logger, LOG_BANDWIDTH_CALCS,
+	DC_LOG_BANDWIDTH_CALCS(core_dc->ctx->logger,
 			"\n============== DML RQ Output parameters [%d] ==============\n"
 			"chunk_size: %d \n"
 			"min_chunk_size: %d \n"
@@ -1330,7 +1330,7 @@ static void dcn10_enable_plane(
 
 /* TODO: enable/disable in dm as per update type.
 	if (plane_state) {
-		dm_logger_write(dc->ctx->logger, LOG_DC,
+		DC_LOG_DC(dc->ctx->logger,
 				"Pipe:%d 0x%x: addr hi:0x%x, "
 				"addr low:0x%x, "
 				"src: %d, %d, %d,"
@@ -1348,7 +1348,7 @@ static void dcn10_enable_plane(
 				plane_state->dst_rect.width,
 				plane_state->dst_rect.height);
 
-		dm_logger_write(dc->ctx->logger, LOG_DC,
+		DC_LOG_DC(dc->ctx->logger,
 				"Pipe %d: width, height, x, y         format:%d\n"
 				"viewport:%d, %d, %d, %d\n"
 				"recout:  %d, %d, %d, %d\n",
@@ -1959,7 +1959,7 @@ static void dcn10_apply_ctx_for_surface(
 			plane_atomic_disconnect(dc, old_pipe_ctx);
 			removed_pipe[i] = true;
 
-			dm_logger_write(dc->ctx->logger, LOG_DC,
+			DC_LOG_DC(dc->ctx->logger,
 					"Reset mpcc for pipe %d\n",
 					old_pipe_ctx->pipe_idx);
 		}
@@ -2002,7 +2002,7 @@ static void dcn10_apply_ctx_for_surface(
 			dcn10_verify_allow_pstate_change_high(dc);
 		}
 	}
-/*	dm_logger_write(dc->ctx->logger, LOG_BANDWIDTH_CALCS,
+/*	DC_LOG_BANDWIDTH_CALCS(dc->ctx->logger,
 			"\n============== Watermark parameters ==============\n"
 			"a.urgent_ns: %d \n"
 			"a.cstate_enter_plus_exit: %d \n"
@@ -2025,7 +2025,7 @@ static void dcn10_apply_ctx_for_surface(
 			context->bw.dcn.watermarks.b.cstate_pstate.pstate_change_ns,
 			context->bw.dcn.watermarks.b.pte_meta_urgent_ns
 			);
-	dm_logger_write(dc->ctx->logger, LOG_BANDWIDTH_CALCS,
+	DC_LOG_BANDWIDTH_CALCS(dc->ctx->logger,
 			"\nc.urgent_ns: %d \n"
 			"c.cstate_enter_plus_exit: %d \n"
 			"c.cstate_exit: %d \n"
@@ -2268,7 +2268,7 @@ static void dcn10_wait_for_mpcc_disconnect(
 			res_pool->mpc->funcs->wait_for_idle(res_pool->mpc, mpcc_inst);
 			pipe_ctx->stream_res.opp->mpcc_disconnect_pending[mpcc_inst] = false;
 			hubp->funcs->set_blank(hubp, true);
-			/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
+			/*DC_LOG_ERROR(dc->ctx->logger,
 					"[debug_mpo: wait_for_mpcc finished waiting on mpcc %d]\n",
 					i);*/
 		}

commit aef5f5237beded4cbe197aedfc03fceed7f9b7da
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Fri Feb 16 17:46:54 2018 -0500

    drm/amd/display: Fix DAL surface change test
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 759e925439ce..b4a6b6729e62 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1943,7 +1943,7 @@ static void dcn10_apply_ctx_for_surface(
 			if (old_pipe_ctx->stream_res.tg == tg &&
 				old_pipe_ctx->plane_res.hubp &&
 				old_pipe_ctx->plane_res.hubp->opp_id != 0xf) {
-				dcn10_disable_plane(dc, pipe_ctx);
+				dcn10_disable_plane(dc, old_pipe_ctx);
 				/*
 				 * power down fe will unlock when calling reset, need
 				 * to lock it back here. Messy, need rework.

commit f553e6810259d8bd31a4b9ac3001cfcde7f8fb7e
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Feb 12 15:19:20 2018 -0500

    drm/amd/display: add per pipe dppclk
    
    v2: Fix commit title
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7a1b2deaf3d7..759e925439ce 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1684,12 +1684,13 @@ static void update_dchubp_dpp(
 	if (plane_state->update_flags.bits.full_update) {
 		dpp->funcs->dpp_dppclk_control(
 				dpp,
-				context->bw.dcn.calc_clk.dppclk_div,
+				context->bw.dcn.calc_clk.max_dppclk_khz <
+						context->bw.dcn.calc_clk.dispclk_khz,
 				true);
 
-		dc->current_state->bw.dcn.cur_clk.dppclk_div =
-				context->bw.dcn.calc_clk.dppclk_div;
-		context->bw.dcn.cur_clk.dppclk_div = context->bw.dcn.calc_clk.dppclk_div;
+		dc->current_state->bw.dcn.cur_clk.max_dppclk_khz =
+				context->bw.dcn.calc_clk.max_dppclk_khz;
+		context->bw.dcn.cur_clk.max_dppclk_khz = context->bw.dcn.calc_clk.max_dppclk_khz;
 	}
 
 	/* TODO: Need input parameter to tell current DCHUB pipe tie to which OTG

commit 8ff15a8fcc5862c1edfc0d149aaafaf35fa3569f
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jan 17 17:40:16 2018 -0500

    drm/amd/display: Update DCN OPTC registers
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 4adb2d311d4e..7a1b2deaf3d7 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1584,6 +1584,7 @@ static void update_dpp(struct dpp *dpp, struct dc_plane_state *plane_state)
 		dpp->funcs->dpp_program_bias_and_scale(dpp, &bns_params);
 }
 
+
 static void update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
@@ -1819,8 +1820,9 @@ static void program_all_pipe_in_tree(
 			dc->hwss.set_output_transfer_func(pipe_ctx, pipe_ctx->stream);
 	}
 
-	if (pipe_ctx->bottom_pipe != NULL && pipe_ctx->bottom_pipe != pipe_ctx)
+	if (pipe_ctx->bottom_pipe != NULL && pipe_ctx->bottom_pipe != pipe_ctx) {
 		program_all_pipe_in_tree(dc, pipe_ctx->bottom_pipe, context);
+	}
 }
 
 static void dcn10_pplib_apply_display_requirements(

commit ea7ea2a8cac1ae7224022b55dcafd51321474ad7
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Thu Feb 15 15:55:31 2018 -0500

    drm/amd/display: fix missing az disable in reset backend
    
    Optimization in reset backend skips disable stream if it is
    already done in dc_stream_set_dpms. However that path does
    not disable az in order to prevent audio from toggling
    between internal and external displays. This still need to
    be done.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 0384aefd79b6..4adb2d311d4e 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -536,6 +536,22 @@ static void reset_back_end_for_pipe(
 		/* DPMS may already disable */
 		if (!pipe_ctx->stream->dpms_off)
 			core_link_disable_stream(pipe_ctx, FREE_ACQUIRED_RESOURCE);
+		else if (pipe_ctx->stream_res.audio) {
+			/*
+			 * if stream is already disabled outside of commit streams path,
+			 * audio disable was skipped. Need to do it here
+			 */
+			pipe_ctx->stream_res.audio->funcs->az_disable(pipe_ctx->stream_res.audio);
+
+			if (dc->caps.dynamic_audio == true) {
+				/*we have to dynamic arbitrate the audio endpoints*/
+				pipe_ctx->stream_res.audio = NULL;
+				/*we free the resource, need reset is_audio_acquired*/
+				update_audio_usage(&dc->current_state->res_ctx, dc->res_pool, pipe_ctx->stream_res.audio, false);
+			}
+
+		}
+
 	}
 
 	/* by upper caller loop, parent pipe: pipe0, will be reset last.

commit 3d53f424796b05b4dfd287d034357f0e19e36c9e
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Mon Feb 12 17:43:19 2018 -0500

    drm/amd/display: update cur_clock correctly within set bandwidth
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 29dc37fbdb26..0384aefd79b6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2054,22 +2054,24 @@ static void dcn10_set_bandwidth(
 		dc->res_pool->display_clock->funcs->set_clock(
 				dc->res_pool->display_clock,
 				context->bw.dcn.calc_clk.dispclk_khz);
-		dc->current_state->bw.dcn.cur_clk.dispclk_khz =
+		context->bw.dcn.cur_clk.dispclk_khz =
 				context->bw.dcn.calc_clk.dispclk_khz;
 	}
 	if (decrease_allowed || context->bw.dcn.calc_clk.dcfclk_khz
 			> dc->current_state->bw.dcn.cur_clk.dcfclk_khz) {
+		context->bw.dcn.cur_clk.dcfclk_khz =
+				context->bw.dcn.calc_clk.dcfclk_khz;
 		smu_req.hard_min_dcefclk_khz =
 				context->bw.dcn.calc_clk.dcfclk_khz;
 	}
 	if (decrease_allowed || context->bw.dcn.calc_clk.fclk_khz
 			> dc->current_state->bw.dcn.cur_clk.fclk_khz) {
+		context->bw.dcn.cur_clk.fclk_khz =
+				context->bw.dcn.calc_clk.fclk_khz;
 		smu_req.hard_min_fclk_khz = context->bw.dcn.calc_clk.fclk_khz;
 	}
 	if (decrease_allowed || context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz
 			> dc->current_state->bw.dcn.cur_clk.dcfclk_deep_sleep_khz) {
-		dc->current_state->bw.dcn.calc_clk.dcfclk_deep_sleep_khz =
-				context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
 		context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz =
 				context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
 	}
@@ -2084,15 +2086,11 @@ static void dcn10_set_bandwidth(
 	/* Decrease in freq is increase in period so opposite comparison for dram_ccm */
 	if (decrease_allowed || context->bw.dcn.calc_clk.dram_ccm_us
 			< dc->current_state->bw.dcn.cur_clk.dram_ccm_us) {
-		dc->current_state->bw.dcn.calc_clk.dram_ccm_us =
-				context->bw.dcn.calc_clk.dram_ccm_us;
 		context->bw.dcn.cur_clk.dram_ccm_us =
 				context->bw.dcn.calc_clk.dram_ccm_us;
 	}
 	if (decrease_allowed || context->bw.dcn.calc_clk.min_active_dram_ccm_us
 			< dc->current_state->bw.dcn.cur_clk.min_active_dram_ccm_us) {
-		dc->current_state->bw.dcn.calc_clk.min_active_dram_ccm_us =
-				context->bw.dcn.calc_clk.min_active_dram_ccm_us;
 		context->bw.dcn.cur_clk.min_active_dram_ccm_us =
 				context->bw.dcn.calc_clk.min_active_dram_ccm_us;
 	}

commit ed8462acafaf428e319548f63a0d808e436c8ea3
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Thu Feb 1 15:16:20 2018 -0500

    drm/amd/display: add force_trigger even to static screen control
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 5d3dedfbc69e..29dc37fbdb26 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2144,6 +2144,8 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
 		value |= 0x80;
 	if (events->cursor_update)
 		value |= 0x2;
+	if (events->force_trigger)
+		value |= 0x1;
 
 	for (i = 0; i < num_pipes; i++)
 		pipe_ctx[i]->stream_res.tg->funcs->

commit b3a1cbc0c5463b27e9c616c9aea342d90c992c8f
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Mon Jan 15 16:23:59 2018 -0500

    drm/amd/display: Expose is_rgb_cspace function in hw_sequencer
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index a17b0b7859fb..5d3dedfbc69e 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1430,7 +1430,7 @@ static bool is_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 	return false;
 }
 
-static bool is_rgb_cspace(enum dc_color_space output_color_space)
+bool is_rgb_cspace(enum dc_color_space output_color_space)
 {
 	switch (output_color_space) {
 	case COLOR_SPACE_SRGB:

commit 33fd17d9125c008143c3df166e01f2e9f89f48ce
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Thu Jan 18 19:07:54 2018 -0500

    drm/amd/display: fix cursor related Pstate hang
    
    Move cursor programming to inside the OTG_MASTER_UPDATE_LOCK
    
    If graphics plane go from 1 pipe to hsplit, the cursor updates
    after mpc programming and unlock. Which means there is a window
    of time where cursor is enabled on the wrong pipe if it's on
    the right side of the screen (i.e. case where cursor need to
    move from pipe 0 to pipe 3 post split). This will cause pstate hang.
    
    Solution is to program the cursor while still locked.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e6f822761b37..a17b0b7859fb 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1716,6 +1716,11 @@ static void update_dchubp_dpp(
 			&pipe_ctx->plane_res.scl_data.viewport_c);
 	}
 
+	if (pipe_ctx->stream->cursor_attributes.address.quad_part != 0) {
+		dc->hwss.set_cursor_position(pipe_ctx);
+		dc->hwss.set_cursor_attribute(pipe_ctx);
+	}
+
 	if (plane_state->update_flags.bits.full_update) {
 		/*gamut remap*/
 		program_gamut_remap(pipe_ctx);
@@ -2265,7 +2270,7 @@ static bool dcn10_dummy_display_power_gating(
 	return true;
 }
 
-void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
+static void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct timing_generator *tg = pipe_ctx->stream_res.tg;
@@ -2285,12 +2290,46 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 	}
 }
 
-void dcn10_update_dchub(struct dce_hwseq *hws, struct dchub_init_data *dh_data)
+static void dcn10_update_dchub(struct dce_hwseq *hws, struct dchub_init_data *dh_data)
 {
 	if (hws->ctx->dc->res_pool->hubbub != NULL)
 		hubbub1_update_dchub(hws->ctx->dc->res_pool->hubbub, dh_data);
 }
 
+static void dcn10_set_cursor_position(struct pipe_ctx *pipe_ctx)
+{
+	struct dc_cursor_position pos_cpy = pipe_ctx->stream->cursor_position;
+	struct hubp *hubp = pipe_ctx->plane_res.hubp;
+	struct dpp *dpp = pipe_ctx->plane_res.dpp;
+	struct dc_cursor_mi_param param = {
+		.pixel_clk_khz = pipe_ctx->stream->timing.pix_clk_khz,
+		.ref_clk_khz = pipe_ctx->stream->ctx->dc->res_pool->ref_clock_inKhz,
+		.viewport_x_start = pipe_ctx->plane_res.scl_data.viewport.x,
+		.viewport_width = pipe_ctx->plane_res.scl_data.viewport.width,
+		.h_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.horz
+	};
+
+	if (pipe_ctx->plane_state->address.type
+			== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)
+		pos_cpy.enable = false;
+
+	if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
+		pos_cpy.enable = false;
+
+	hubp->funcs->set_cursor_position(hubp, &pos_cpy, &param);
+	dpp->funcs->set_cursor_position(dpp, &pos_cpy, &param, hubp->curs_attr.width);
+}
+
+static void dcn10_set_cursor_attribute(struct pipe_ctx *pipe_ctx)
+{
+	struct dc_cursor_attributes *attributes = &pipe_ctx->stream->cursor_attributes;
+
+	pipe_ctx->plane_res.hubp->funcs->set_cursor_attributes(
+			pipe_ctx->plane_res.hubp, attributes);
+	pipe_ctx->plane_res.dpp->funcs->set_cursor_attributes(
+		pipe_ctx->plane_res.dpp, attributes->color_format);
+}
+
 static const struct hw_sequencer_funcs dcn10_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.program_csc_matrix = program_csc_matrix,
@@ -2332,6 +2371,8 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.edp_backlight_control = hwss_edp_backlight_control,
 	.edp_power_control = hwss_edp_power_control,
 	.edp_wait_for_hpd_ready = hwss_edp_wait_for_hpd_ready,
+	.set_cursor_position = dcn10_set_cursor_position,
+	.set_cursor_attribute = dcn10_set_cursor_attribute
 };
 
 

commit f9549850a4cd3114fa1faeb97264cdad5c656edf
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Jan 19 11:59:16 2018 -0500

    drm/amd/display: Null check for gamma correction.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index a3f84dc851a1..e6f822761b37 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -900,7 +900,8 @@ static bool dcn10_set_input_transfer_func(struct pipe_ctx *pipe_ctx,
 	if (plane_state->in_transfer_func)
 		tf = plane_state->in_transfer_func;
 
-	if (plane_state->gamma_correction->is_identity)
+	if (plane_state->gamma_correction &&
+		plane_state->gamma_correction->is_identity)
 		dpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);
 	else if (plane_state->gamma_correction && dce_use_lut(plane_state->format))
 		dpp_base->funcs->dpp_program_input_lut(dpp_base, plane_state->gamma_correction);

commit 24a30505f312287b2978f8f9180a3bc2da4fd80c
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Jan 18 14:51:28 2018 -0500

    drm/amd/display: Check hubp in pipe_ctx not in res_pool.
    
    When disable plane, check power gate flag in hubp with pipe_ctx,
    not with res_pool.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 8ce9a4e70793..a3f84dc851a1 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -656,7 +656,7 @@ static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 
 static void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
-	if (dc->res_pool->hubps[pipe_ctx->pipe_idx]->power_gated)
+	if (!pipe_ctx->plane_res.hubp || pipe_ctx->plane_res.hubp->power_gated)
 		return;
 
 	plane_atomic_disable(dc, pipe_ctx);

commit 3e5df76ae51f2955796d9c10105a92b7f7f660e0
Author: John Barberiz <jbarberi@amd.com>
Date:   Thu Jan 18 12:22:11 2018 -0500

    drm/amd/display: Bypass gamma set if not standard type
    
    If non-standard gamma type detected set identity matrix flag
    so that we can bypass the gamma mode.
    
    Signed-off-by: John Barberiz <jbarberi@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f261c7cfb003..8ce9a4e70793 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -900,7 +900,9 @@ static bool dcn10_set_input_transfer_func(struct pipe_ctx *pipe_ctx,
 	if (plane_state->in_transfer_func)
 		tf = plane_state->in_transfer_func;
 
-	if (plane_state->gamma_correction && dce_use_lut(plane_state->format))
+	if (plane_state->gamma_correction->is_identity)
+		dpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);
+	else if (plane_state->gamma_correction && dce_use_lut(plane_state->format))
 		dpp_base->funcs->dpp_program_input_lut(dpp_base, plane_state->gamma_correction);
 
 	if (tf == NULL)

commit 41b497421a1f07ab99814da740984f907747120b
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Thu Jan 11 15:31:26 2018 -0500

    drm/amd/display: eDP sequence BL off first then DP blank.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e1a8ebae3714..f261c7cfb003 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2308,6 +2308,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.enable_stream = dce110_enable_stream,
 	.disable_stream = dce110_disable_stream,
 	.unblank_stream = dce110_unblank_stream,
+	.blank_stream = dce110_blank_stream,
 	.enable_display_power_gating = dcn10_dummy_display_power_gating,
 	.disable_plane = dcn10_disable_plane,
 	.pipe_control_lock = dcn10_pipe_control_lock,

commit 3be1406a72b08e3122660f7ea2a41a129fe5e266
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Jan 5 13:53:06 2018 -0500

    drm/amd/display: Add timing generator count to resource pool.
    
    Use tg count in resource pool for further reference.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c6a4fa2f17c2..e1a8ebae3714 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -133,7 +133,7 @@ void dcn10_log_hw_state(struct dc *dc)
 		DTN_INFO("[%d]:\t %xh \t %xh \t %d \t %d \t "
 				"%xh \t %xh \t %xh \t "
 				"%d \t %d \t %d \t %xh \t",
-				i,
+				hubp->inst,
 				s.pixel_format,
 				s.inuse_addr_hi,
 				s.viewport_width,
@@ -155,7 +155,7 @@ void dcn10_log_hw_state(struct dc *dc)
 	DTN_INFO("OTG:\t v_bs \t v_be \t v_ss \t v_se \t vpol \t vmax \t vmin \t "
 			"h_bs \t h_be \t h_ss \t h_se \t hpol \t htot \t vtot \t underflow\n");
 
-	for (i = 0; i < pool->res_cap->num_timing_generator; i++) {
+	for (i = 0; i < pool->timing_generator_count; i++) {
 		struct timing_generator *tg = pool->timing_generators[i];
 		struct dcn_otg_state s = {0};
 
@@ -168,7 +168,7 @@ void dcn10_log_hw_state(struct dc *dc)
 		DTN_INFO("[%d]:\t %d \t %d \t %d \t %d \t "
 				"%d \t %d \t %d \t %d \t %d \t %d \t "
 				"%d \t %d \t %d \t %d \t %d \t ",
-				i,
+				tg->inst,
 				s.v_blank_start,
 				s.v_blank_end,
 				s.v_sync_a_start,

commit 3aa0caddf6997a62e08e19bbaf6f5d61067c1196
Author: Duke Du <Duke.Du@amd.com>
Date:   Thu Jan 4 09:32:06 2018 +0800

    drm/amd/display: Update the register GRPH_SWAP_CNTL if surface pixel format changed.
    
    Signed-off-by: Duke Du <Duke.Du@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7e99d788f0e0..c6a4fa2f17c2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1725,6 +1725,7 @@ static void update_dchubp_dpp(
 	}
 
 	if (plane_state->update_flags.bits.full_update ||
+		plane_state->update_flags.bits.pixel_format_change ||
 		plane_state->update_flags.bits.horizontal_mirror_change ||
 		plane_state->update_flags.bits.rotation_change ||
 		plane_state->update_flags.bits.swizzle_change ||

commit 529c690ba8ef2da093ea84a64df72bdb8123479f
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Tue Jan 2 17:04:55 2018 -0500

    drm/amd/display: Update dcn10_init_hw for FPGA
    
    Update dcn10_init_hw such that initialization of relevant
    HW blocks for Maximus FPGA are also initialized (and not skipped).
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 8b6c2499453f..7e99d788f0e0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -692,26 +692,25 @@ static void dcn10_init_hw(struct dc *dc)
 		}
 
 		enable_power_gating_plane(dc->hwseq, true);
-		return;
-	}
-	/* end of FPGA. Below if real ASIC */
+	} else {
 
-	if (!dcb->funcs->is_accelerated_mode(dcb)) {
-		bios_golden_init(dc);
-		disable_vga(dc->hwseq);
-	}
+		if (!dcb->funcs->is_accelerated_mode(dcb)) {
+			bios_golden_init(dc);
+			disable_vga(dc->hwseq);
+		}
 
-	for (i = 0; i < dc->link_count; i++) {
-		/* Power up AND update implementation according to the
-		 * required signal (which may be different from the
-		 * default signal on connector).
-		 */
-		struct dc_link *link = dc->links[i];
+		for (i = 0; i < dc->link_count; i++) {
+			/* Power up AND update implementation according to the
+			 * required signal (which may be different from the
+			 * default signal on connector).
+			 */
+			struct dc_link *link = dc->links[i];
 
-		if (link->link_enc->connector.id == CONNECTOR_ID_EDP)
-			dc->hwss.edp_power_control(link, true);
+			if (link->link_enc->connector.id == CONNECTOR_ID_EDP)
+				dc->hwss.edp_power_control(link, true);
 
-		link->link_enc->funcs->hw_init(link->link_enc);
+			link->link_enc->funcs->hw_init(link->link_enc);
+		}
 	}
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
@@ -779,6 +778,10 @@ static void dcn10_init_hw(struct dc *dc)
 		tg->funcs->tg_init(tg);
 	}
 
+	/* end of FPGA. Below if real ASIC */
+	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
+		return;
+
 	for (i = 0; i < dc->res_pool->audio_count; i++) {
 		struct audio *audio = dc->res_pool->audios[i];
 

commit 365acbaf4664b99e42a6fc7ed031df2e840879cc
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Dec 22 12:05:25 2017 -0500

    drm/amd/display: Refactor remove mpcc processing.
    
    No need to use loop find opp, use opp in stream_res.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index b03ffff9135b..8b6c2499453f 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -580,26 +580,19 @@ static void plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	int dpp_id = pipe_ctx->plane_res.dpp->inst;
 	struct mpc *mpc = dc->res_pool->mpc;
-	int pipe_idx;
 	struct mpc_tree *mpc_tree_params;
 	struct mpcc *mpcc_to_remove = NULL;
+	struct output_pixel_processor *opp = pipe_ctx->stream_res.opp;
 
-	/* look at tree rather than mi here to know if we already reset */
-	for (pipe_idx = 0; pipe_idx < dc->res_pool->pipe_count; pipe_idx++) {
-		struct output_pixel_processor *opp = dc->res_pool->opps[pipe_idx];
-
-		mpc_tree_params = &(opp->mpc_tree_params);
-		mpcc_to_remove = mpc->funcs->get_mpcc_for_dpp(mpc_tree_params, dpp_id);
-		if (mpcc_to_remove != NULL)
-			break;
-	}
+	mpc_tree_params = &(opp->mpc_tree_params);
+	mpcc_to_remove = mpc->funcs->get_mpcc_for_dpp(mpc_tree_params, dpp_id);
 
 	/*Already reset*/
-	if (pipe_idx == dc->res_pool->pipe_count)
+	if (mpcc_to_remove == NULL)
 		return;
 
 	mpc->funcs->remove_mpcc(mpc, mpc_tree_params, mpcc_to_remove);
-	dc->res_pool->opps[pipe_idx]->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;
+	opp->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;
 
 	dc->optimized_required = true;
 
@@ -975,8 +968,6 @@ static void dcn10_pipe_control_lock(
 	struct pipe_ctx *pipe,
 	bool lock)
 {
-	struct hubp *hubp = NULL;
-	hubp = dc->res_pool->hubps[pipe->pipe_idx];
 	/* use TG master update lock to lock everything on the TG
 	 * therefore only top pipe need to lock
 	 */

commit be2f449a19a198164fbcbbe9e22c6c32ad7a2492
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Dec 22 10:19:37 2017 -0500

    drm/amd/display: Move opp reg access from hwss to opp module.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 5431de7419b3..b03ffff9135b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -633,7 +633,6 @@ static void plane_atomic_power_down(struct dc *dc, struct pipe_ctx *pipe_ctx)
  */
 static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
-	struct dce_hwseq *hws = dc->hwseq;
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 	int opp_id = hubp->opp_id;
@@ -645,8 +644,9 @@ static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	dpp->funcs->dpp_dppclk_control(dpp, false, false);
 
 	if (opp_id != 0xf && pipe_ctx->stream_res.opp->mpc_tree_params.opp_list == NULL)
-		REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
-				OPP_PIPE_CLOCK_EN, 0);
+		pipe_ctx->stream_res.opp->funcs->opp_pipe_clock_control(
+				pipe_ctx->stream_res.opp,
+				false);
 
 	hubp->power_gated = true;
 	dc->optimized_required = false; /* We're powering off, no need to optimize */
@@ -1311,8 +1311,9 @@ static void dcn10_enable_plane(
 	pipe_ctx->plane_res.hubp->funcs->hubp_clk_cntl(pipe_ctx->plane_res.hubp, true);
 
 	/* make sure OPP_PIPE_CLOCK_EN = 1 */
-	REG_UPDATE(OPP_PIPE_CONTROL[pipe_ctx->stream_res.tg->inst],
-			OPP_PIPE_CLOCK_EN, 1);
+	pipe_ctx->stream_res.opp->funcs->opp_pipe_clock_control(
+			pipe_ctx->stream_res.opp,
+			true);
 
 /* TODO: enable/disable in dm as per update type.
 	if (plane_state) {

commit f8e413bf3c478225177ff74510ecf6bcd6160d1b
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Dec 20 17:17:40 2017 -0500

    drm/amd/display: Move dpp reg access from hwss to dpp module.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 4fedd7b68062..5431de7419b3 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -193,26 +193,6 @@ void dcn10_log_hw_state(struct dc *dc)
 	DTN_INFO_END();
 }
 
-static void enable_dppclk(
-	struct dce_hwseq *hws,
-	uint8_t plane_id,
-	uint32_t requested_pix_clk,
-	bool dppclk_div)
-{
-	dm_logger_write(hws->ctx->logger, LOG_SURFACE,
-			"dppclk_rate_control for pipe %d programed to %d\n",
-			plane_id,
-			dppclk_div);
-
-	if (hws->shifts->DPPCLK_RATE_CONTROL)
-		REG_UPDATE_2(DPP_CONTROL[plane_id],
-			DPPCLK_RATE_CONTROL, dppclk_div,
-			DPP_CLOCK_ENABLE, 1);
-	else
-		REG_UPDATE(DPP_CONTROL[plane_id],
-			DPP_CLOCK_ENABLE, 1);
-}
-
 static void enable_power_gating_plane(
 	struct dce_hwseq *hws,
 	bool enable)
@@ -655,15 +635,14 @@ static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
+	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 	int opp_id = hubp->opp_id;
-	int dpp_id = pipe_ctx->plane_res.dpp->inst;
 
 	dc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe_ctx);
 
 	hubp->funcs->hubp_clk_cntl(hubp, false);
 
-	REG_UPDATE(DPP_CONTROL[dpp_id],
-			DPP_CLOCK_ENABLE, 0);
+	dpp->funcs->dpp_dppclk_control(dpp, false, false);
 
 	if (opp_id != 0xf && pipe_ctx->stream_res.opp->mpc_tree_params.opp_list == NULL)
 		REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
@@ -1688,11 +1667,11 @@ static void update_dchubp_dpp(
 
 	/* depends on DML calculation, DPP clock value may change dynamically */
 	if (plane_state->update_flags.bits.full_update) {
-		enable_dppclk(
-			dc->hwseq,
-			pipe_ctx->plane_res.dpp->inst,
-			pipe_ctx->stream_res.pix_clk_params.requested_pix_clk,
-			context->bw.dcn.calc_clk.dppclk_div);
+		dpp->funcs->dpp_dppclk_control(
+				dpp,
+				context->bw.dcn.calc_clk.dppclk_div,
+				true);
+
 		dc->current_state->bw.dcn.cur_clk.dppclk_div =
 				context->bw.dcn.calc_clk.dppclk_div;
 		context->bw.dcn.cur_clk.dppclk_div = context->bw.dcn.calc_clk.dppclk_div;

commit 2e9d6a571cb7e5a9218e3f43f1c6de5649b4e373
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Dec 21 15:38:31 2017 -0500

    drm/amd/display: Check opplist in pipe ctx not in res pool.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 5f9094c803cc..4fedd7b68062 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -600,13 +600,13 @@ static void plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	int dpp_id = pipe_ctx->plane_res.dpp->inst;
 	struct mpc *mpc = dc->res_pool->mpc;
-	int opp_id;
+	int pipe_idx;
 	struct mpc_tree *mpc_tree_params;
 	struct mpcc *mpcc_to_remove = NULL;
 
 	/* look at tree rather than mi here to know if we already reset */
-	for (opp_id = 0; opp_id < dc->res_pool->pipe_count; opp_id++) {
-		struct output_pixel_processor *opp = dc->res_pool->opps[opp_id];
+	for (pipe_idx = 0; pipe_idx < dc->res_pool->pipe_count; pipe_idx++) {
+		struct output_pixel_processor *opp = dc->res_pool->opps[pipe_idx];
 
 		mpc_tree_params = &(opp->mpc_tree_params);
 		mpcc_to_remove = mpc->funcs->get_mpcc_for_dpp(mpc_tree_params, dpp_id);
@@ -615,11 +615,11 @@ static void plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	}
 
 	/*Already reset*/
-	if (opp_id == dc->res_pool->pipe_count)
+	if (pipe_idx == dc->res_pool->pipe_count)
 		return;
 
 	mpc->funcs->remove_mpcc(mpc, mpc_tree_params, mpcc_to_remove);
-	dc->res_pool->opps[opp_id]->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;
+	dc->res_pool->opps[pipe_idx]->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;
 
 	dc->optimized_required = true;
 
@@ -665,7 +665,7 @@ static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	REG_UPDATE(DPP_CONTROL[dpp_id],
 			DPP_CLOCK_ENABLE, 0);
 
-	if (opp_id != 0xf && dc->res_pool->opps[opp_id]->mpc_tree_params.opp_list == NULL)
+	if (opp_id != 0xf && pipe_ctx->stream_res.opp->mpc_tree_params.opp_list == NULL)
 		REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
 				OPP_PIPE_CLOCK_EN, 0);
 

commit 405c50a07d3f67971d3e01cec83dbdcd5bdd529e
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Wed Dec 20 10:07:42 2017 -0500

    drm/amd/display: Fix check for setting input TF
    
    We no longer change the plane state pointer for full updates, and as
    such, we weren't setting the input transfer function and programming the
    degamma registers when we are supposed to. Check for a full update, an
    input TF change, or a gamma change in the update flags instead to correct
    this.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index ad772230869a..5f9094c803cc 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -925,7 +925,7 @@ static bool dcn10_set_input_transfer_func(struct pipe_ctx *pipe_ctx,
 	if (plane_state->in_transfer_func)
 		tf = plane_state->in_transfer_func;
 
-	if (plane_state->gamma_correction && dce_use_lut(plane_state))
+	if (plane_state->gamma_correction && dce_use_lut(plane_state->format))
 		dpp_base->funcs->dpp_program_input_lut(dpp_base, plane_state->gamma_correction);
 
 	if (tf == NULL)
@@ -1800,15 +1800,14 @@ static void program_all_pipe_in_tree(
 	}
 
 	if (pipe_ctx->plane_state != NULL) {
-		struct pipe_ctx *cur_pipe_ctx =
-				&dc->current_state->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
-
 		if (pipe_ctx->plane_state->update_flags.bits.full_update)
 			dcn10_enable_plane(dc, pipe_ctx, context);
 
 		update_dchubp_dpp(dc, pipe_ctx, context);
 
-		if (cur_pipe_ctx->plane_state != pipe_ctx->plane_state)
+		if (pipe_ctx->plane_state->update_flags.bits.full_update ||
+				pipe_ctx->plane_state->update_flags.bits.in_transfer_func_change ||
+				pipe_ctx->plane_state->update_flags.bits.gamma_change)
 			dc->hwss.set_input_transfer_func(pipe_ctx, pipe_ctx->plane_state);
 
 		/* dcn10_translate_regamma_to_hw_format takes 750us to finish

commit e07f541f50a31541f761300aa8bf6e3008ac448b
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Dec 19 16:47:02 2017 -0500

    drm/amd/display: Use real BE and FE index to program regs.
    
    In case of some pipes are fused, pipe_idx should not
    be used to program pipe regs. Instead of that, BE and FE
    inst number should be used for reg index.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 0e5818516795..ad772230869a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -597,8 +597,8 @@ static void dcn10_verify_allow_pstate_change_high(struct dc *dc)
 /* trigger HW to start disconnect plane from stream on the next vsync */
 static void plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
-	int fe_idx = pipe_ctx->pipe_idx;
-	struct hubp *hubp = dc->res_pool->hubps[fe_idx];
+	struct hubp *hubp = pipe_ctx->plane_res.hubp;
+	int dpp_id = pipe_ctx->plane_res.dpp->inst;
 	struct mpc *mpc = dc->res_pool->mpc;
 	int opp_id;
 	struct mpc_tree *mpc_tree_params;
@@ -609,7 +609,7 @@ static void plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 		struct output_pixel_processor *opp = dc->res_pool->opps[opp_id];
 
 		mpc_tree_params = &(opp->mpc_tree_params);
-		mpcc_to_remove = mpc->funcs->get_mpcc_for_dpp(mpc_tree_params, fe_idx);
+		mpcc_to_remove = mpc->funcs->get_mpcc_for_dpp(mpc_tree_params, dpp_id);
 		if (mpcc_to_remove != NULL)
 			break;
 	}
@@ -619,7 +619,7 @@ static void plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 		return;
 
 	mpc->funcs->remove_mpcc(mpc, mpc_tree_params, mpcc_to_remove);
-	dc->res_pool->opps[opp_id]->mpcc_disconnect_pending[fe_idx] = true;
+	dc->res_pool->opps[opp_id]->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;
 
 	dc->optimized_required = true;
 
@@ -630,21 +630,21 @@ static void plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 		dcn10_verify_allow_pstate_change_high(dc);
 }
 
-static void plane_atomic_power_down(struct dc *dc, int fe_idx)
+static void plane_atomic_power_down(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
-	struct dpp *dpp = dc->res_pool->dpps[fe_idx];
+	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 
 	if (REG(DC_IP_REQUEST_CNTL)) {
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 1);
-		dpp_pg_control(hws, fe_idx, false);
-		hubp_pg_control(hws, fe_idx, false);
+		dpp_pg_control(hws, dpp->inst, false);
+		hubp_pg_control(hws, pipe_ctx->plane_res.hubp->inst, false);
 		dpp->funcs->dpp_reset(dpp);
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 0);
 		dm_logger_write(dc->ctx->logger, LOG_DEBUG,
-				"Power gated front end %d\n", fe_idx);
+				"Power gated front end %d\n", pipe_ctx->pipe_idx);
 	}
 }
 
@@ -653,16 +653,16 @@ static void plane_atomic_power_down(struct dc *dc, int fe_idx)
  */
 static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
-	int fe_idx = pipe_ctx->pipe_idx;
 	struct dce_hwseq *hws = dc->hwseq;
-	struct hubp *hubp = dc->res_pool->hubps[fe_idx];
+	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	int opp_id = hubp->opp_id;
+	int dpp_id = pipe_ctx->plane_res.dpp->inst;
 
 	dc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe_ctx);
 
 	hubp->funcs->hubp_clk_cntl(hubp, false);
 
-	REG_UPDATE(DPP_CONTROL[fe_idx],
+	REG_UPDATE(DPP_CONTROL[dpp_id],
 			DPP_CLOCK_ENABLE, 0);
 
 	if (opp_id != 0xf && dc->res_pool->opps[opp_id]->mpc_tree_params.opp_list == NULL)
@@ -672,7 +672,7 @@ static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	hubp->power_gated = true;
 	dc->optimized_required = false; /* We're powering off, no need to optimize */
 
-	plane_atomic_power_down(dc, fe_idx);
+	plane_atomic_power_down(dc, pipe_ctx);
 
 	pipe_ctx->stream = NULL;
 	memset(&pipe_ctx->stream_res, 0, sizeof(pipe_ctx->stream_res));
@@ -768,18 +768,21 @@ static void dcn10_init_hw(struct dc *dc)
 		struct timing_generator *tg = dc->res_pool->timing_generators[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 		struct hubp *hubp = dc->res_pool->hubps[i];
+		struct dpp *dpp = dc->res_pool->dpps[i];
 
 		pipe_ctx->stream_res.tg = tg;
 		pipe_ctx->pipe_idx = i;
 
 		pipe_ctx->plane_res.hubp = hubp;
-		hubp->mpcc_id = i;
+		pipe_ctx->plane_res.dpp = dpp;
+		pipe_ctx->plane_res.mpcc_inst = dpp->inst;
+		hubp->mpcc_id = dpp->inst;
 		hubp->opp_id = 0xf;
 		hubp->power_gated = false;
 
 		dc->res_pool->opps[i]->mpc_tree_params.opp_id = dc->res_pool->opps[i]->inst;
 		dc->res_pool->opps[i]->mpc_tree_params.opp_list = NULL;
-		dc->res_pool->opps[i]->mpcc_disconnect_pending[i] = true;
+		dc->res_pool->opps[i]->mpcc_disconnect_pending[pipe_ctx->plane_res.mpcc_inst] = true;
 		pipe_ctx->stream_res.opp = dc->res_pool->opps[i];
 
 		plane_atomic_disconnect(dc, pipe_ctx);
@@ -1323,7 +1326,7 @@ static void dcn10_enable_plane(
 	undo_DEGVIDCN10_253_wa(dc);
 
 	power_on_plane(dc->hwseq,
-		pipe_ctx->pipe_idx);
+		pipe_ctx->plane_res.hubp->inst);
 
 	/* enable DCFCLK current DCHUB */
 	pipe_ctx->plane_res.hubp->funcs->hubp_clk_cntl(pipe_ctx->plane_res.hubp, true);
@@ -1687,7 +1690,7 @@ static void update_dchubp_dpp(
 	if (plane_state->update_flags.bits.full_update) {
 		enable_dppclk(
 			dc->hwseq,
-			pipe_ctx->pipe_idx,
+			pipe_ctx->plane_res.dpp->inst,
 			pipe_ctx->stream_res.pix_clk_params.requested_pix_clk,
 			context->bw.dcn.calc_clk.dppclk_div);
 		dc->current_state->bw.dcn.cur_clk.dppclk_div =
@@ -2231,12 +2234,24 @@ static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct dc *dc)
 	return;
 }
 
+static struct hubp *get_hubp_by_inst(struct resource_pool *res_pool, int mpcc_inst)
+{
+	int i;
+
+	for (i = 0; i < res_pool->pipe_count; i++) {
+		if (res_pool->hubps[i]->inst == mpcc_inst)
+			return res_pool->hubps[i];
+	}
+	ASSERT(false);
+	return NULL;
+}
+
 static void dcn10_wait_for_mpcc_disconnect(
 		struct dc *dc,
 		struct resource_pool *res_pool,
 		struct pipe_ctx *pipe_ctx)
 {
-	int i;
+	int mpcc_inst;
 
 	if (dc->debug.sanity_checks) {
 		dcn10_verify_allow_pstate_change_high(dc);
@@ -2245,11 +2260,13 @@ static void dcn10_wait_for_mpcc_disconnect(
 	if (!pipe_ctx->stream_res.opp)
 		return;
 
-	for (i = 0; i < MAX_PIPES; i++) {
-		if (pipe_ctx->stream_res.opp->mpcc_disconnect_pending[i]) {
-			res_pool->mpc->funcs->wait_for_idle(res_pool->mpc, i);
-			pipe_ctx->stream_res.opp->mpcc_disconnect_pending[i] = false;
-			res_pool->hubps[i]->funcs->set_blank(res_pool->hubps[i], true);
+	for (mpcc_inst = 0; mpcc_inst < MAX_PIPES; mpcc_inst++) {
+		if (pipe_ctx->stream_res.opp->mpcc_disconnect_pending[mpcc_inst]) {
+			struct hubp *hubp = get_hubp_by_inst(res_pool, mpcc_inst);
+
+			res_pool->mpc->funcs->wait_for_idle(res_pool->mpc, mpcc_inst);
+			pipe_ctx->stream_res.opp->mpcc_disconnect_pending[mpcc_inst] = false;
+			hubp->funcs->set_blank(hubp, true);
 			/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
 					"[debug_mpo: wait_for_mpcc finished waiting on mpcc %d]\n",
 					i);*/

commit c8242b9858ae7b79c7b45987bfe179eeb93e67df
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Dec 18 14:09:19 2017 -0500

    drm/amd/display: Move hubp reg access from hwss to hubp module.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 77c4376a7d44..0e5818516795 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -660,8 +660,8 @@ static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 
 	dc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe_ctx);
 
-	REG_UPDATE(HUBP_CLK_CNTL[fe_idx],
-			HUBP_CLOCK_ENABLE, 0);
+	hubp->funcs->hubp_clk_cntl(hubp, false);
+
 	REG_UPDATE(DPP_CONTROL[fe_idx],
 			DPP_CLOCK_ENABLE, 0);
 
@@ -1326,8 +1326,7 @@ static void dcn10_enable_plane(
 		pipe_ctx->pipe_idx);
 
 	/* enable DCFCLK current DCHUB */
-	REG_UPDATE(HUBP_CLK_CNTL[pipe_ctx->pipe_idx],
-			HUBP_CLOCK_ENABLE, 1);
+	pipe_ctx->plane_res.hubp->funcs->hubp_clk_cntl(pipe_ctx->plane_res.hubp, true);
 
 	/* make sure OPP_PIPE_CLOCK_EN = 1 */
 	REG_UPDATE(OPP_PIPE_CONTROL[pipe_ctx->stream_res.tg->inst],
@@ -1679,7 +1678,6 @@ static void update_dchubp_dpp(
 	struct pipe_ctx *pipe_ctx,
 	struct dc_state *context)
 {
-	struct dce_hwseq *hws = dc->hwseq;
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
@@ -1702,7 +1700,7 @@ static void update_dchubp_dpp(
 	 * VTG is 1:1 mapping with OTG. Each pipe HUBP will select which VTG
 	 */
 	if (plane_state->update_flags.bits.full_update) {
-		REG_UPDATE(DCHUBP_CNTL[pipe_ctx->pipe_idx], HUBP_VTG_SEL, pipe_ctx->stream_res.tg->inst);
+		hubp->funcs->hubp_vtg_sel(hubp, pipe_ctx->stream_res.tg->inst);
 
 		hubp->funcs->hubp_setup(
 			hubp,

commit 146a9f636824dedb6b5722bd4361cc111624d053
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Fri Dec 15 17:58:45 2017 -0500

    drm/amd/display: Pass full 3x4 remap matrix for color transform
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 0f5a22e3a491..77c4376a7d44 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1380,6 +1380,7 @@ static void dcn10_enable_plane(
 
 static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 {
+	int i = 0;
 	struct dpp_grph_csc_adjustment adjust;
 	memset(&adjust, 0, sizeof(adjust));
 	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
@@ -1387,33 +1388,9 @@ static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 
 	if (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {
 		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
-		adjust.temperature_matrix[0] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[0];
-		adjust.temperature_matrix[1] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[1];
-		adjust.temperature_matrix[2] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[2];
-		adjust.temperature_matrix[3] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[4];
-		adjust.temperature_matrix[4] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[5];
-		adjust.temperature_matrix[5] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[6];
-		adjust.temperature_matrix[6] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[8];
-		adjust.temperature_matrix[7] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[9];
-		adjust.temperature_matrix[8] =
-				pipe_ctx->stream->
-				gamut_remap_matrix.matrix[10];
+		for (i = 0; i < CSC_TEMPERATURE_MATRIX_SIZE; i++)
+			adjust.temperature_matrix[i] =
+				pipe_ctx->stream->gamut_remap_matrix.matrix[i];
 	}
 
 	pipe_ctx->plane_res.dpp->funcs->dpp_set_gamut_remap(pipe_ctx->plane_res.dpp, &adjust);

commit 03736f4cf83cb03aa6bdbc768941a4148d9b929c
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Mon Dec 18 10:34:56 2017 -0500

    drm/amd/display: Prevent master programming in multisync
    
    Verify that the stream is master - and program only the slave displays
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 52e31e798921..0f5a22e3a491 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1097,7 +1097,7 @@ static void dcn10_enable_per_frame_crtc_position_reset(
 
 	DC_SYNC_INFO("Waiting for trigger\n");
 
-	for (i = 1; i < group_size; i++)
+	for (i = 0; i < group_size; i++)
 		wait_for_reset_trigger_to_occur(dc_ctx, grouped_pipes[i]->stream_res.tg);
 
 	DC_SYNC_INFO("Multi-display sync is complete\n");

commit 8d6a741bf60005465fd4517393b5e431f68c3f60
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Dec 15 10:26:13 2017 -0500

    drm/amd/display: Use pipe_control_lock instead of tg lock.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 82572863acab..52e31e798921 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1940,7 +1940,7 @@ static void dcn10_apply_ctx_for_surface(
 
 	tg = top_pipe_to_program->stream_res.tg;
 
-	tg->funcs->lock(tg);
+	dcn10_pipe_control_lock(dc, top_pipe_to_program, true);
 
 	if (num_planes == 0) {
 
@@ -1989,7 +1989,7 @@ static void dcn10_apply_ctx_for_surface(
 	if (num_planes > 0)
 		program_all_pipe_in_tree(dc, top_pipe_to_program, context);
 
-	tg->funcs->unlock(tg);
+	dcn10_pipe_control_lock(dc, top_pipe_to_program, false);
 
 	if (num_planes == 0)
 		false_optc_underflow_wa(dc, stream, tg);

commit 72d520d4fa76e59d1882620fa34680ff4258ae6f
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Tue Dec 12 14:14:10 2017 -0500

    drm/amd/display: Update FMT and OPPBUF functions
    
    Updates to FMT and OPPBUF programming from HW team
    pseudocode review.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 2ca364f30e1d..82572863acab 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -462,9 +462,6 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	enum dc_color_space color_space;
 	struct tg_color black_color = {0};
-	bool enableStereo    = stream->timing.timing_3d_format == TIMING_3D_FORMAT_NONE ?
-			false:true;
-	bool rightEyePolarity = stream->timing.flags.RIGHT_EYE_3D_POLARITY;
 
 	/* by upper caller loop, pipe0 is parent pipe and be called first.
 	 * back end is set up by for pipe0. Other children pipe share back end
@@ -499,11 +496,6 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 			&stream->timing,
 			true);
 
-	pipe_ctx->stream_res.opp->funcs->opp_set_stereo_polarity(
-				pipe_ctx->stream_res.opp,
-				enableStereo,
-				rightEyePolarity);
-
 #if 0 /* move to after enable_crtc */
 	/* TODO: OPP FMT, ABM. etc. should be done here. */
 	/* or FPGA now. instance 0 only. TODO: move to opp.c */
@@ -2251,10 +2243,10 @@ static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct dc *dc)
 
 	dcn10_config_stereo_parameters(stream, &flags);
 
-	pipe_ctx->stream_res.opp->funcs->opp_set_stereo_polarity(
+	pipe_ctx->stream_res.opp->funcs->opp_program_stereo(
 		pipe_ctx->stream_res.opp,
 		flags.PROGRAM_STEREO == 1 ? true:false,
-		stream->timing.flags.RIGHT_EYE_3D_POLARITY == 1 ? true:false);
+		&stream->timing);
 
 	pipe_ctx->stream_res.tg->funcs->program_stereo(
 		pipe_ctx->stream_res.tg,

commit e7899002cf202057378d2fd3ffd7a85029e21689
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Dec 12 10:48:50 2017 -0500

    drm/amd/display: Fix unused variable warnings.
    
    ... since linux kernel compile treats warnings as errors.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c9d717cc7e47..2ca364f30e1d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -465,8 +465,6 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 	bool enableStereo    = stream->timing.timing_3d_format == TIMING_3D_FORMAT_NONE ?
 			false:true;
 	bool rightEyePolarity = stream->timing.flags.RIGHT_EYE_3D_POLARITY;
-	int width = stream->timing.h_addressable + stream->timing.h_border_left + stream->timing.h_border_right;
-	int height = stream->timing.v_addressable + stream->timing.v_border_bottom + stream->timing.v_border_top;
 
 	/* by upper caller loop, pipe0 is parent pipe and be called first.
 	 * back end is set up by for pipe0. Other children pipe share back end
@@ -1813,9 +1811,6 @@ static void program_all_pipe_in_tree(
 		struct pipe_ctx *pipe_ctx,
 		struct dc_state *context)
 {
-	struct dc_stream_state *stream = pipe_ctx->stream;
-	int width = stream->timing.h_addressable + stream->timing.h_border_left + stream->timing.h_border_right;
-	int height = stream->timing.v_addressable + stream->timing.v_border_bottom + stream->timing.v_border_top;
 
 	if (pipe_ctx->top_pipe == NULL) {
 
@@ -1942,8 +1937,6 @@ static void dcn10_apply_ctx_for_surface(
 	bool removed_pipe[4] = { false };
 	unsigned int ref_clk_mhz = dc->res_pool->ref_clock_inKhz/1000;
 	bool program_water_mark = false;
-	int width = stream->timing.h_addressable + stream->timing.h_border_left + stream->timing.h_border_right;
-	int height = stream->timing.v_addressable + stream->timing.v_border_bottom + stream->timing.v_border_top;
 
 	struct pipe_ctx *top_pipe_to_program =
 			find_top_pipe_for_stream(dc, context, stream);

commit b51adc77e220ddc659db7c46270596717f50cf5c
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Mon Dec 4 16:58:11 2017 -0500

    drm/amd/display: Only blank DCN when we have set_blank implementation
    
    Also rename timing_generator to optc
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 824de3630889..c9d717cc7e47 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -32,7 +32,7 @@
 #include "dce/dce_hwseq.h"
 #include "abm.h"
 #include "dmcu.h"
-#include "dcn10/dcn10_timing_generator.h"
+#include "dcn10_optc.h"
 #include "dcn10/dcn10_dpp.h"
 #include "dcn10/dcn10_mpc.h"
 #include "timing_generator.h"
@@ -465,6 +465,8 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 	bool enableStereo    = stream->timing.timing_3d_format == TIMING_3D_FORMAT_NONE ?
 			false:true;
 	bool rightEyePolarity = stream->timing.flags.RIGHT_EYE_3D_POLARITY;
+	int width = stream->timing.h_addressable + stream->timing.h_border_left + stream->timing.h_border_right;
+	int height = stream->timing.v_addressable + stream->timing.v_border_bottom + stream->timing.v_border_top;
 
 	/* by upper caller loop, pipe0 is parent pipe and be called first.
 	 * back end is set up by for pipe0. Other children pipe share back end
@@ -518,11 +520,14 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 	/* program otg blank color */
 	color_space = stream->output_color_space;
 	color_space_to_black_color(dc, color_space, &black_color);
-	pipe_ctx->stream_res.tg->funcs->set_blank_color(
-			pipe_ctx->stream_res.tg,
-			&black_color);
 
-	if (!pipe_ctx->stream_res.tg->funcs->is_blanked(pipe_ctx->stream_res.tg)) {
+	if (pipe_ctx->stream_res.tg->funcs->set_blank_color)
+		pipe_ctx->stream_res.tg->funcs->set_blank_color(
+				pipe_ctx->stream_res.tg,
+				&black_color);
+
+	if (pipe_ctx->stream_res.tg->funcs->is_blanked &&
+			!pipe_ctx->stream_res.tg->funcs->is_blanked(pipe_ctx->stream_res.tg)) {
 		pipe_ctx->stream_res.tg->funcs->set_blank(pipe_ctx->stream_res.tg, true);
 		hwss_wait_for_blank_complete(pipe_ctx->stream_res.tg);
 		false_optc_underflow_wa(dc, pipe_ctx->stream, pipe_ctx->stream_res.tg);
@@ -1808,6 +1813,10 @@ static void program_all_pipe_in_tree(
 		struct pipe_ctx *pipe_ctx,
 		struct dc_state *context)
 {
+	struct dc_stream_state *stream = pipe_ctx->stream;
+	int width = stream->timing.h_addressable + stream->timing.h_border_left + stream->timing.h_border_right;
+	int height = stream->timing.v_addressable + stream->timing.v_border_bottom + stream->timing.v_border_top;
+
 	if (pipe_ctx->top_pipe == NULL) {
 
 		pipe_ctx->stream_res.tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
@@ -1818,7 +1827,11 @@ static void program_all_pipe_in_tree(
 
 		pipe_ctx->stream_res.tg->funcs->program_global_sync(
 				pipe_ctx->stream_res.tg);
-		pipe_ctx->stream_res.tg->funcs->set_blank(pipe_ctx->stream_res.tg, !is_pipe_tree_visible(pipe_ctx));
+
+		if (pipe_ctx->stream_res.tg->funcs->set_blank)
+			pipe_ctx->stream_res.tg->funcs->set_blank(
+					pipe_ctx->stream_res.tg,
+					!is_pipe_tree_visible(pipe_ctx));
 	}
 
 	if (pipe_ctx->plane_state != NULL) {
@@ -1925,9 +1938,12 @@ static void dcn10_apply_ctx_for_surface(
 {
 	int i;
 	struct timing_generator *tg;
+	struct output_pixel_processor *opp;
 	bool removed_pipe[4] = { false };
 	unsigned int ref_clk_mhz = dc->res_pool->ref_clock_inKhz/1000;
 	bool program_water_mark = false;
+	int width = stream->timing.h_addressable + stream->timing.h_border_left + stream->timing.h_border_right;
+	int height = stream->timing.v_addressable + stream->timing.v_border_bottom + stream->timing.v_border_top;
 
 	struct pipe_ctx *top_pipe_to_program =
 			find_top_pipe_for_stream(dc, context, stream);
@@ -1935,6 +1951,8 @@ static void dcn10_apply_ctx_for_surface(
 	if (!top_pipe_to_program)
 		return;
 
+	opp = top_pipe_to_program->stream_res.opp;
+
 	tg = top_pipe_to_program->stream_res.tg;
 
 	tg->funcs->lock(tg);
@@ -1942,7 +1960,8 @@ static void dcn10_apply_ctx_for_surface(
 	if (num_planes == 0) {
 
 		/* OTG blank before remove all front end */
-		tg->funcs->set_blank(tg, true);
+		if (tg->funcs->set_blank)
+			tg->funcs->set_blank(tg, true);
 	}
 
 	/* Disconnect unused mpcc */

commit f8668c099e71bdd2c4e8bfd3d79178e243a99835
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Thu Dec 7 10:42:33 2017 -0500

    drm/amd/display: reprogram surface config on scaling change
    
    When plane size changes, we need to reprogram surface pitch in addition
    to viewport and scaler. This change is a conservative way to make this happen.
    However it could be more optimized to move pitch programming into
    mem_program_viewport.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index ee057de68ed2..824de3630889 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1782,7 +1782,8 @@ static void update_dchubp_dpp(
 		plane_state->update_flags.bits.rotation_change ||
 		plane_state->update_flags.bits.swizzle_change ||
 		plane_state->update_flags.bits.dcc_change ||
-		plane_state->update_flags.bits.bpp_change) {
+		plane_state->update_flags.bits.bpp_change ||
+		plane_state->update_flags.bits.scaling_change) {
 		hubp->funcs->hubp_program_surface_config(
 			hubp,
 			plane_state->format,

commit 38cb3e96e0c4362194aab662b424e89da8755561
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Fri Dec 1 11:42:18 2017 -0600

    drm/amd/display: Declare and share color space types for dcn's
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 31fd6ae8f61f..ee057de68ed2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1429,22 +1429,9 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 		enum dc_color_space colorspace,
 		uint16_t *matrix)
 {
-	int i;
-	struct out_csc_color_matrix tbl_entry;
-
 	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment == true) {
-			enum dc_color_space color_space =
-				pipe_ctx->stream->output_color_space;
-
-			//uint16_t matrix[12];
-			for (i = 0; i < 12; i++)
-				tbl_entry.regval[i] = pipe_ctx->stream->csc_color_matrix.matrix[i];
-
-			tbl_entry.color_space = color_space;
-			//tbl_entry.regval = matrix;
-
 			if (pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment != NULL)
-				pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment(pipe_ctx->plane_res.dpp, &tbl_entry);
+				pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment(pipe_ctx->plane_res.dpp, matrix);
 	} else {
 		if (pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_default != NULL)
 			pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_default(pipe_ctx->plane_res.dpp, colorspace);

commit 904623ee5936e2226009b2f238f28781aecd2565
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Nov 24 16:31:03 2017 -0500

    drm/amd/display: Move wait for hpd ready out from edp power control.
    
    It may take over 200ms for wait hpd ready. To optimize the resume time,
    we can power on eDP in init_hw, wait for hpd ready when doing link
    training.
    
    also create separate eDP enable function to make sure eDP is powered up
    before doing and DPCD access, as HPD low will result in DPDC transaction
    failure.
    
    After optimization,
    setpowerstate 145ms -> 9.8ms,
    DPMS 387ms -> 18.9ms
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f0be2b872668..31fd6ae8f61f 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2368,7 +2368,8 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.pplib_apply_display_requirements =
 			dcn10_pplib_apply_display_requirements,
 	.edp_backlight_control = hwss_edp_backlight_control,
-	.edp_power_control = hwss_edp_power_control
+	.edp_power_control = hwss_edp_power_control,
+	.edp_wait_for_hpd_ready = hwss_edp_wait_for_hpd_ready,
 };
 
 

commit f23d558466cf14e58ec7f666a3af1a6708681bcc
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Fri Nov 24 17:51:34 2017 -0500

    drm/amd/display: Move OPP mpc tree initialization to hw_init
    
    Move OPP initialization of mpc tree parameters to hw_init function.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7ec87fcb22be..f0be2b872668 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -782,6 +782,8 @@ static void dcn10_init_hw(struct dc *dc)
 		hubp->opp_id = 0xf;
 		hubp->power_gated = false;
 
+		dc->res_pool->opps[i]->mpc_tree_params.opp_id = dc->res_pool->opps[i]->inst;
+		dc->res_pool->opps[i]->mpc_tree_params.opp_list = NULL;
 		dc->res_pool->opps[i]->mpcc_disconnect_pending[i] = true;
 		pipe_ctx->stream_res.opp = dc->res_pool->opps[i];
 

commit 40e045a9733f3c032ff957d9663c106c82fd5343
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Wed Nov 22 16:48:35 2017 -0500

    drm/amd/display: OPTC cleanup/implementation
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 39a4d1a86583..7ec87fcb22be 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -159,7 +159,7 @@ void dcn10_log_hw_state(struct dc *dc)
 		struct timing_generator *tg = pool->timing_generators[i];
 		struct dcn_otg_state s = {0};
 
-		tgn10_read_otg_state(DCN10TG_FROM_TG(tg), &s);
+		optc1_read_otg_state(DCN10TG_FROM_TG(tg), &s);
 
 		//only print if OTG master is enabled
 		if ((s.otg_enabled & 1) == 0)

commit 96d923887994eb7c97b44afceaeac6640ba22653
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Nov 14 11:52:11 2017 -0500

    drm/amd/display: Add dppclk to dcn_bw_clocks
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index a4d756c1b97a..39a4d1a86583 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1335,7 +1335,6 @@ static void dcn10_enable_plane(
 	/* make sure OPP_PIPE_CLOCK_EN = 1 */
 	REG_UPDATE(OPP_PIPE_CONTROL[pipe_ctx->stream_res.tg->inst],
 			OPP_PIPE_CLOCK_EN, 1);
-	/*TODO: REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DPPCLK_WDIVIDER, 0x1f);*/
 
 /* TODO: enable/disable in dm as per update type.
 	if (plane_state) {

commit cc55b1f5c31aba89c9b504b7400d0e247e8ce1da
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Tue Nov 21 17:51:50 2017 -0500

    drm/amd/display: Set mpcc_disconnect_pending during MPC reset
    
    This prevents an issue where the MPCC will not go to idle due to us not
    waiting for it to become idle during disable plane.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7846534cd6d5..a4d756c1b97a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -782,8 +782,8 @@ static void dcn10_init_hw(struct dc *dc)
 		hubp->opp_id = 0xf;
 		hubp->power_gated = false;
 
-		if (hubp->opp_id != 0xf)
-			pipe_ctx->stream_res.opp = dc->res_pool->opps[hubp->opp_id];
+		dc->res_pool->opps[i]->mpcc_disconnect_pending[i] = true;
+		pipe_ctx->stream_res.opp = dc->res_pool->opps[i];
 
 		plane_atomic_disconnect(dc, pipe_ctx);
 	}

commit 16a29dd3bb18ea23d9676e6a3b1c6464dba620c3
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Tue Nov 21 15:59:42 2017 -0500

    drm/amd/display: Refine update flags usage in update_dchubp_dpp
    
    - Only update DPP clock if it's a full update.
    - Program viewport on position change. This caused SLS regressions.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e9ecbcb66e80..7846534cd6d5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1726,7 +1726,7 @@ static void update_dchubp_dpp(
 	union plane_size size = plane_state->plane_size;
 
 	/* depends on DML calculation, DPP clock value may change dynamically */
-	if (pipe_ctx->plane_state->update_flags.raw != 0) {
+	if (plane_state->update_flags.bits.full_update) {
 		enable_dppclk(
 			dc->hwseq,
 			pipe_ctx->pipe_idx,
@@ -1770,7 +1770,8 @@ static void update_dchubp_dpp(
 	}
 
 	if (plane_state->update_flags.bits.full_update ||
-		plane_state->update_flags.bits.scaling_change) {
+		plane_state->update_flags.bits.scaling_change ||
+		plane_state->update_flags.bits.position_change) {
 		hubp->funcs->mem_program_viewport(
 			hubp,
 			&pipe_ctx->plane_res.scl_data.viewport,

commit 457fbe76ecc5a28072aeb0d17d3ea6c8a9c2a304
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Nov 21 15:42:17 2017 -0500

    drm/amd/display: Program cursor regs after context swapped.
    
    Cursor is abnormal after pipe_ctx is changed in context.
    Cause: cursor attributes is programmed right after front end
    programming, but it use old pipe_ctx to program which is not
    updated yet.
    Solution:
    Program cursor regs after context swapped.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e29111eb64e4..e9ecbcb66e80 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1992,22 +1992,9 @@ static void dcn10_apply_ctx_for_surface(
 		}
 	}
 
-	if (num_planes > 0) {
+	if (num_planes > 0)
 		program_all_pipe_in_tree(dc, top_pipe_to_program, context);
 
-		/* TODO: this is a hack w/a for switching from mpo to pipe split */
-		if (stream->cursor_attributes.address.quad_part != 0) {
-			struct dc_cursor_position position = { 0 };
-
-			dc_stream_set_cursor_position(
-				(struct dc_stream_state *)stream,
-				&position);
-			dc_stream_set_cursor_attributes(
-				(struct dc_stream_state *)stream,
-				&stream->cursor_attributes);
-		}
-	}
-
 	tg->funcs->unlock(tg);
 
 	if (num_planes == 0)

commit b629596072e5fa901c84f9e88d845a696ee32942
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Tue Nov 14 17:12:52 2017 -0600

    drm/amd/display: Build unity lut for shaper
    
    Add color module to diagnostic compilation
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7376514a162e..e29111eb64e4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -43,6 +43,7 @@
 #include "custom_float.h"
 #include "dcn10_hubp.h"
 #include "dcn10_hubbub.h"
+#include "dcn10_cm_common.h"
 
 #define CTX \
 	hws->ctx
@@ -954,280 +955,10 @@ static bool dcn10_set_input_transfer_func(struct pipe_ctx *pipe_ctx,
 
 	return result;
 }
-/*modify the method to handle rgb for arr_points*/
-static bool convert_to_custom_float(
-		struct pwl_result_data *rgb_resulted,
-		struct curve_points *arr_points,
-		uint32_t hw_points_num)
-{
-	struct custom_float_format fmt;
-
-	struct pwl_result_data *rgb = rgb_resulted;
-
-	uint32_t i = 0;
-
-	fmt.exponenta_bits = 6;
-	fmt.mantissa_bits = 12;
-	fmt.sign = false;
-
-	if (!convert_to_custom_float_format(arr_points[0].x, &fmt,
-					    &arr_points[0].custom_float_x)) {
-		BREAK_TO_DEBUGGER();
-		return false;
-	}
-
-	if (!convert_to_custom_float_format(arr_points[0].offset, &fmt,
-					    &arr_points[0].custom_float_offset)) {
-		BREAK_TO_DEBUGGER();
-		return false;
-	}
 
-	if (!convert_to_custom_float_format(arr_points[0].slope, &fmt,
-					    &arr_points[0].custom_float_slope)) {
-		BREAK_TO_DEBUGGER();
-		return false;
-	}
 
-	fmt.mantissa_bits = 10;
-	fmt.sign = false;
 
-	if (!convert_to_custom_float_format(arr_points[1].x, &fmt,
-					    &arr_points[1].custom_float_x)) {
-		BREAK_TO_DEBUGGER();
-		return false;
-	}
-
-	if (!convert_to_custom_float_format(arr_points[1].y, &fmt,
-					    &arr_points[1].custom_float_y)) {
-		BREAK_TO_DEBUGGER();
-		return false;
-	}
 
-	if (!convert_to_custom_float_format(arr_points[1].slope, &fmt,
-					    &arr_points[1].custom_float_slope)) {
-		BREAK_TO_DEBUGGER();
-		return false;
-	}
-
-	fmt.mantissa_bits = 12;
-	fmt.sign = true;
-
-	while (i != hw_points_num) {
-		if (!convert_to_custom_float_format(rgb->red, &fmt,
-						    &rgb->red_reg)) {
-			BREAK_TO_DEBUGGER();
-			return false;
-		}
-
-		if (!convert_to_custom_float_format(rgb->green, &fmt,
-						    &rgb->green_reg)) {
-			BREAK_TO_DEBUGGER();
-			return false;
-		}
-
-		if (!convert_to_custom_float_format(rgb->blue, &fmt,
-						    &rgb->blue_reg)) {
-			BREAK_TO_DEBUGGER();
-			return false;
-		}
-
-		if (!convert_to_custom_float_format(rgb->delta_red, &fmt,
-						    &rgb->delta_red_reg)) {
-			BREAK_TO_DEBUGGER();
-			return false;
-		}
-
-		if (!convert_to_custom_float_format(rgb->delta_green, &fmt,
-						    &rgb->delta_green_reg)) {
-			BREAK_TO_DEBUGGER();
-			return false;
-		}
-
-		if (!convert_to_custom_float_format(rgb->delta_blue, &fmt,
-						    &rgb->delta_blue_reg)) {
-			BREAK_TO_DEBUGGER();
-			return false;
-		}
-
-		++rgb;
-		++i;
-	}
-
-	return true;
-}
-#define MAX_REGIONS_NUMBER 34
-#define MAX_LOW_POINT      25
-#define NUMBER_SEGMENTS    32
-
-static bool
-dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
-				     struct pwl_params *regamma_params)
-{
-	struct curve_points *arr_points;
-	struct pwl_result_data *rgb_resulted;
-	struct pwl_result_data *rgb;
-	struct pwl_result_data *rgb_plus_1;
-	struct fixed31_32 y_r;
-	struct fixed31_32 y_g;
-	struct fixed31_32 y_b;
-	struct fixed31_32 y1_min;
-	struct fixed31_32 y3_max;
-
-	int32_t segment_start, segment_end;
-	int32_t i;
-	uint32_t j, k, seg_distr[MAX_REGIONS_NUMBER], increment, start_index, hw_points;
-
-	if (output_tf == NULL || regamma_params == NULL || output_tf->type == TF_TYPE_BYPASS)
-		return false;
-
-	PERF_TRACE();
-
-	arr_points = regamma_params->arr_points;
-	rgb_resulted = regamma_params->rgb_resulted;
-	hw_points = 0;
-
-	memset(regamma_params, 0, sizeof(struct pwl_params));
-	memset(seg_distr, 0, sizeof(seg_distr));
-
-	if (output_tf->tf == TRANSFER_FUNCTION_PQ) {
-		/* 32 segments
-		 * segments are from 2^-25 to 2^7
-		 */
-		for (i = 0; i < 32 ; i++)
-			seg_distr[i] = 3;
-
-		segment_start = -25;
-		segment_end   = 7;
-	} else {
-		/* 10 segments
-		 * segment is from 2^-10 to 2^0
-		 * There are less than 256 points, for optimization
-		 */
-		seg_distr[0] = 3;
-		seg_distr[1] = 4;
-		seg_distr[2] = 4;
-		seg_distr[3] = 4;
-		seg_distr[4] = 4;
-		seg_distr[5] = 4;
-		seg_distr[6] = 4;
-		seg_distr[7] = 4;
-		seg_distr[8] = 5;
-		seg_distr[9] = 5;
-
-		segment_start = -10;
-		segment_end = 0;
-	}
-
-	for (i = segment_end - segment_start; i < MAX_REGIONS_NUMBER ; i++)
-		seg_distr[i] = -1;
-
-	for (k = 0; k < MAX_REGIONS_NUMBER; k++) {
-		if (seg_distr[k] != -1)
-			hw_points += (1 << seg_distr[k]);
-	}
-
-	j = 0;
-	for (k = 0; k < (segment_end - segment_start); k++) {
-		increment = NUMBER_SEGMENTS / (1 << seg_distr[k]);
-		start_index = (segment_start + k + MAX_LOW_POINT) * NUMBER_SEGMENTS;
-		for (i = start_index; i < start_index + NUMBER_SEGMENTS; i += increment) {
-			if (j == hw_points - 1)
-				break;
-			rgb_resulted[j].red = output_tf->tf_pts.red[i];
-			rgb_resulted[j].green = output_tf->tf_pts.green[i];
-			rgb_resulted[j].blue = output_tf->tf_pts.blue[i];
-			j++;
-		}
-	}
-
-	/* last point */
-	start_index = (segment_end + MAX_LOW_POINT) * NUMBER_SEGMENTS;
-	rgb_resulted[hw_points - 1].red = output_tf->tf_pts.red[start_index];
-	rgb_resulted[hw_points - 1].green = output_tf->tf_pts.green[start_index];
-	rgb_resulted[hw_points - 1].blue = output_tf->tf_pts.blue[start_index];
-
-	arr_points[0].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
-					     dal_fixed31_32_from_int(segment_start));
-	arr_points[1].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
-					     dal_fixed31_32_from_int(segment_end));
-
-	y_r = rgb_resulted[0].red;
-	y_g = rgb_resulted[0].green;
-	y_b = rgb_resulted[0].blue;
-
-	y1_min = dal_fixed31_32_min(y_r, dal_fixed31_32_min(y_g, y_b));
-
-	arr_points[0].y = y1_min;
-	arr_points[0].slope = dal_fixed31_32_div(arr_points[0].y, arr_points[0].x);
-	y_r = rgb_resulted[hw_points - 1].red;
-	y_g = rgb_resulted[hw_points - 1].green;
-	y_b = rgb_resulted[hw_points - 1].blue;
-
-	/* see comment above, m_arrPoints[1].y should be the Y value for the
-	 * region end (m_numOfHwPoints), not last HW point(m_numOfHwPoints - 1)
-	 */
-	y3_max = dal_fixed31_32_max(y_r, dal_fixed31_32_max(y_g, y_b));
-
-	arr_points[1].y = y3_max;
-
-	arr_points[1].slope = dal_fixed31_32_zero;
-
-	if (output_tf->tf == TRANSFER_FUNCTION_PQ) {
-		/* for PQ, we want to have a straight line from last HW X point,
-		 * and the slope to be such that we hit 1.0 at 10000 nits.
-		 */
-		const struct fixed31_32 end_value =
-				dal_fixed31_32_from_int(125);
-
-		arr_points[1].slope = dal_fixed31_32_div(
-			dal_fixed31_32_sub(dal_fixed31_32_one, arr_points[1].y),
-			dal_fixed31_32_sub(end_value, arr_points[1].x));
-	}
-
-	regamma_params->hw_points_num = hw_points;
-
-	i = 1;
-	for (k = 0; k < MAX_REGIONS_NUMBER && i < MAX_REGIONS_NUMBER; k++) {
-		if (seg_distr[k] != -1) {
-			regamma_params->arr_curve_points[k].segments_num =
-					seg_distr[k];
-			regamma_params->arr_curve_points[i].offset =
-					regamma_params->arr_curve_points[k].offset + (1 << seg_distr[k]);
-		}
-		i++;
-	}
-
-	if (seg_distr[k] != -1)
-		regamma_params->arr_curve_points[k].segments_num = seg_distr[k];
-
-	rgb = rgb_resulted;
-	rgb_plus_1 = rgb_resulted + 1;
-
-	i = 1;
-
-	while (i != hw_points + 1) {
-		if (dal_fixed31_32_lt(rgb_plus_1->red, rgb->red))
-			rgb_plus_1->red = rgb->red;
-		if (dal_fixed31_32_lt(rgb_plus_1->green, rgb->green))
-			rgb_plus_1->green = rgb->green;
-		if (dal_fixed31_32_lt(rgb_plus_1->blue, rgb->blue))
-			rgb_plus_1->blue = rgb->blue;
-
-		rgb->delta_red = dal_fixed31_32_sub(rgb_plus_1->red, rgb->red);
-		rgb->delta_green = dal_fixed31_32_sub(rgb_plus_1->green, rgb->green);
-		rgb->delta_blue = dal_fixed31_32_sub(rgb_plus_1->blue, rgb->blue);
-
-		++rgb_plus_1;
-		++rgb;
-		++i;
-	}
-
-	convert_to_custom_float(rgb_resulted, arr_points, hw_points);
-
-	PERF_TRACE();
-
-	return true;
-}
 
 static bool
 dcn10_set_output_transfer_func(struct pipe_ctx *pipe_ctx,
@@ -1248,9 +979,9 @@ dcn10_set_output_transfer_func(struct pipe_ctx *pipe_ctx,
 	/* dcn10_translate_regamma_to_hw_format takes 750us, only do it when full
 	 * update.
 	 */
-	else if (dcn10_translate_regamma_to_hw_format(
+	else if (cm_helper_translate_curve_to_hw_format(
 			stream->out_transfer_func,
-			&dpp->regamma_params)) {
+			&dpp->regamma_params, false)) {
 		dpp->funcs->dpp_program_regamma_pwl(
 				dpp,
 				&dpp->regamma_params, OPP_REGAMMA_USER);

commit 4e1c1875c79b14a05b2bab45aee9b907f805447d
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Thu Nov 16 15:34:50 2017 -0500

    drm/amd/display: Reset MPCC muxes during init
    
    During HW initialization, instead of assuming or
    detecting the existing MPCC mux configuration and
    then removing existing planes, reset all the MPCC
    muxes.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d542e4db5495..7376514a162e 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -702,7 +702,7 @@ static void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
 
 static void dcn10_init_hw(struct dc *dc)
 {
-	int i, opp_id;
+	int i;
 	struct abm *abm = dc->res_pool->abm;
 	struct dmcu *dmcu = dc->res_pool->dmcu;
 	struct dce_hwseq *hws = dc->hwseq;
@@ -765,13 +765,8 @@ static void dcn10_init_hw(struct dc *dc)
 		}
 	}
 
-	/* Initialize MPC tree based on HW values */
-	for (opp_id = 0; opp_id < dc->res_pool->pipe_count; opp_id++) {
-		struct output_pixel_processor *opp = dc->res_pool->opps[opp_id];
-		struct mpc_tree *mpc_tree_params = &(opp->mpc_tree_params);
-
-		dc->res_pool->mpc->funcs->init_mpcc_list_from_hw(dc->res_pool->mpc, mpc_tree_params);
-	}
+	/* Reset all MPCC muxes */
+	dc->res_pool->mpc->funcs->mpc_init(dc->res_pool->mpc);
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct timing_generator *tg = dc->res_pool->timing_generators[i];
@@ -783,7 +778,7 @@ static void dcn10_init_hw(struct dc *dc)
 
 		pipe_ctx->plane_res.hubp = hubp;
 		hubp->mpcc_id = i;
-		hubp->opp_id = dc->res_pool->mpc->funcs->get_opp_id(dc->res_pool->mpc, i);
+		hubp->opp_id = 0xf;
 		hubp->power_gated = false;
 
 		if (hubp->opp_id != 0xf)

commit 8e504bccc11663c3b334ef1a7698e18a967de920
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Nov 17 10:44:15 2017 -0500

    drm/amd/display: Disable plane right after disconnected
    
    HDR display playing video underflow is observed when switching
    to full screen due to program a lower watermark right after unlock otg.
    
    Instead of disable plane in next flip coming, if there is a
    plane disconnected, after otg unlock wait for mpcc idle and disable
    the plane, then program watermark. So there is enough warter mark to make
    sure current frame data pass through.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 1ebe980bfb6d..d542e4db5495 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2297,7 +2297,7 @@ static void dcn10_apply_ctx_for_surface(
 			pipe_ctx->plane_state->update_flags.bits.full_update)
 			program_water_mark = true;
 
-		if (removed_pipe[i] && num_planes == 0)
+		if (removed_pipe[i])
 			dcn10_disable_plane(dc, old_pipe_ctx);
 	}
 
@@ -2306,6 +2306,7 @@ static void dcn10_apply_ctx_for_surface(
 			/* pstate stuck check after watermark update */
 			dcn10_verify_allow_pstate_change_high(dc);
 		}
+
 		/* watermark is for all pipes */
 		hubbub1_program_watermarks(dc->res_pool->hubbub,
 				&context->bw.dcn.watermarks, ref_clk_mhz);

commit e9dd9223c6d633a33fd2125ed1b1ec9d5bcbb5a7
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Thu Nov 16 17:08:44 2017 -0500

    drm/amd/display: Add dcc_change surface update flag
    
    Program the DCC registers when dcc_change is true.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 8e2520ba6bed..1ebe980bfb6d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2066,6 +2066,7 @@ static void update_dchubp_dpp(
 		plane_state->update_flags.bits.horizontal_mirror_change ||
 		plane_state->update_flags.bits.rotation_change ||
 		plane_state->update_flags.bits.swizzle_change ||
+		plane_state->update_flags.bits.dcc_change ||
 		plane_state->update_flags.bits.bpp_change) {
 		hubp->funcs->hubp_program_surface_config(
 			hubp,

commit 5cc2687c13eecd36a66e8e22948f281dbfc38970
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Nov 15 16:21:34 2017 -0500

    drm/amd/display: Implement work around for optc underflow.
    
    Work around for a hw bug causing optc underflow if blank data
    double buffer disable and remove mpcc.
    Checking optc status after otg unlock, after wait mpcc idle
    check status again, if optc underflow just happens after wait
    mpcc idle, clear underflow status and enable blank data double
    buffer.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e08808b7e2d6..8e2520ba6bed 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -425,6 +425,34 @@ static void bios_golden_init(struct dc *dc)
 	}
 }
 
+static void false_optc_underflow_wa(
+		struct dc *dc,
+		const struct dc_stream_state *stream,
+		struct timing_generator *tg)
+{
+	int i;
+	bool underflow;
+
+	if (!dc->hwseq->wa.false_optc_underflow)
+		return;
+
+	underflow = tg->funcs->is_optc_underflow_occurred(tg);
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *old_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
+
+		if (old_pipe_ctx->stream != stream)
+			continue;
+
+		dc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, old_pipe_ctx);
+	}
+
+	tg->funcs->set_blank_data_double_buffer(tg, true);
+
+	if (tg->funcs->is_optc_underflow_occurred(tg) && !underflow)
+		tg->funcs->clear_optc_underflow(tg);
+}
+
 static enum dc_status dcn10_prog_pixclk_crtc_otg(
 		struct pipe_ctx *pipe_ctx,
 		struct dc_state *context,
@@ -493,8 +521,11 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 			pipe_ctx->stream_res.tg,
 			&black_color);
 
-	pipe_ctx->stream_res.tg->funcs->set_blank(pipe_ctx->stream_res.tg, true);
-	hwss_wait_for_blank_complete(pipe_ctx->stream_res.tg);
+	if (!pipe_ctx->stream_res.tg->funcs->is_blanked(pipe_ctx->stream_res.tg)) {
+		pipe_ctx->stream_res.tg->funcs->set_blank(pipe_ctx->stream_res.tg, true);
+		hwss_wait_for_blank_complete(pipe_ctx->stream_res.tg);
+		false_optc_underflow_wa(dc, pipe_ctx->stream, pipe_ctx->stream_res.tg);
+	}
 
 	/* VTG is  within DCHUB command block. DCFCLK is always on */
 	if (false == pipe_ctx->stream_res.tg->funcs->enable_crtc(pipe_ctx->stream_res.tg)) {
@@ -2252,6 +2283,9 @@ static void dcn10_apply_ctx_for_surface(
 
 	tg->funcs->unlock(tg);
 
+	if (num_planes == 0)
+		false_optc_underflow_wa(dc, stream, tg);
+
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *old_pipe_ctx =
 				&dc->current_state->res_ctx.pipe_ctx[i];

commit 82c026d14fd2b8b0a56168227c81386a3bc0e3e1
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Thu Nov 16 15:51:21 2017 -0500

    drm/amd/display: Change optimized_required logic
    
    Rather than setting it every time there's a full update with surface
    count > 0, set it when we need to do plane_atomic_disconnect. Also make
    sure that we unset the flag in plane_atomic_disable, so that in the
    event we run through a sequence where we do disconnect followed by an
    immediate disable, we do not do unnecessarily request a passive flip to
    do the optimization.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d41f571ad8b6..e08808b7e2d6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -594,6 +594,8 @@ static void plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	mpc->funcs->remove_mpcc(mpc, mpc_tree_params, mpcc_to_remove);
 	dc->res_pool->opps[opp_id]->mpcc_disconnect_pending[fe_idx] = true;
 
+	dc->optimized_required = true;
+
 	if (hubp->funcs->hubp_disconnect)
 		hubp->funcs->hubp_disconnect(hubp);
 
@@ -641,6 +643,7 @@ static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 				OPP_PIPE_CLOCK_EN, 0);
 
 	hubp->power_gated = true;
+	dc->optimized_required = false; /* We're powering off, no need to optimize */
 
 	plane_atomic_power_down(dc, fe_idx);
 

commit 1ccda80ff4547dafd14ad20dd401d0aa08a9852a
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Nov 15 16:12:19 2017 -0500

    drm/amd/display: Use same wait mpcc idle function.
    
    There is already wait mpcc idle function. It is better
    to use the same function for all wait mpcc idle.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 14d1cffa84d9..d41f571ad8b6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -592,19 +592,13 @@ static void plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 		return;
 
 	mpc->funcs->remove_mpcc(mpc, mpc_tree_params, mpcc_to_remove);
+	dc->res_pool->opps[opp_id]->mpcc_disconnect_pending[fe_idx] = true;
 
 	if (hubp->funcs->hubp_disconnect)
 		hubp->funcs->hubp_disconnect(hubp);
 
 	if (dc->debug.sanity_checks)
 		dcn10_verify_allow_pstate_change_high(dc);
-
-	pipe_ctx->stream = NULL;
-	memset(&pipe_ctx->stream_res, 0, sizeof(pipe_ctx->stream_res));
-	memset(&pipe_ctx->plane_res, 0, sizeof(pipe_ctx->plane_res));
-	pipe_ctx->top_pipe = NULL;
-	pipe_ctx->bottom_pipe = NULL;
-	pipe_ctx->plane_state = NULL;
 }
 
 static void plane_atomic_power_down(struct dc *dc, int fe_idx)
@@ -633,16 +627,9 @@ static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	int fe_idx = pipe_ctx->pipe_idx;
 	struct dce_hwseq *hws = dc->hwseq;
 	struct hubp *hubp = dc->res_pool->hubps[fe_idx];
-	struct mpc *mpc = dc->res_pool->mpc;
 	int opp_id = hubp->opp_id;
-	struct output_pixel_processor *opp;
 
-	if (opp_id != 0xf) {
-		mpc->funcs->wait_for_idle(mpc, hubp->mpcc_id);
-		opp = dc->res_pool->opps[hubp->opp_id];
-		opp->mpcc_disconnect_pending[hubp->mpcc_id] = false;
-		hubp->funcs->set_blank(hubp, true);
-	}
+	dc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe_ctx);
 
 	REG_UPDATE(HUBP_CLK_CNTL[fe_idx],
 			HUBP_CLOCK_ENABLE, 0);
@@ -656,6 +643,13 @@ static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	hubp->power_gated = true;
 
 	plane_atomic_power_down(dc, fe_idx);
+
+	pipe_ctx->stream = NULL;
+	memset(&pipe_ctx->stream_res, 0, sizeof(pipe_ctx->stream_res));
+	memset(&pipe_ctx->plane_res, 0, sizeof(pipe_ctx->plane_res));
+	pipe_ctx->top_pipe = NULL;
+	pipe_ctx->bottom_pipe = NULL;
+	pipe_ctx->plane_state = NULL;
 }
 
 static void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
@@ -758,6 +752,9 @@ static void dcn10_init_hw(struct dc *dc)
 		hubp->opp_id = dc->res_pool->mpc->funcs->get_opp_id(dc->res_pool->mpc, i);
 		hubp->power_gated = false;
 
+		if (hubp->opp_id != 0xf)
+			pipe_ctx->stream_res.opp = dc->res_pool->opps[hubp->opp_id];
+
 		plane_atomic_disconnect(dc, pipe_ctx);
 	}
 

commit 49fac0b46a689519c13efafba9e754525d420136
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Thu Nov 16 14:29:10 2017 -0500

    drm/amd/display: MPC updates
    
    Fix update_mpcc logic to only call assert_mpcc_idle_before_connect
    if mpcc is not already being used (and required removal).
    Update set_out_rate_control to include optional flow control parameter.
    In init_mpcc_from_hw check for case where bot_sel is same as mpcc_id.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 3abd6d92aae0..14d1cffa84d9 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1923,10 +1923,10 @@ static void update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	/* remove MPCC if being used */
 	if (new_mpcc != NULL)
 		mpc->funcs->remove_mpcc(mpc, mpc_tree_params, new_mpcc);
-
-	if (dc->debug.sanity_checks)
-		mpc->funcs->assert_mpcc_idle_before_connect(
-				dc->res_pool->mpc, mpcc_id);
+	else
+		if (dc->debug.sanity_checks)
+			mpc->funcs->assert_mpcc_idle_before_connect(
+					dc->res_pool->mpc, mpcc_id);
 
 	/* Call MPC to insert new plane */
 	new_mpcc = mpc->funcs->insert_plane(dc->res_pool->mpc,

commit feb4a3cd8eb007f4749dc8323110f42fb4682ae0
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Mon Nov 6 16:38:55 2017 -0500

    drm/amd/display: Integrating MPC pseudocode
    
    Integrating MPC pseudocode to support new blending cases
    with secondary MPCC list.
    This includes a design change to MPC data structures and
    interfaces.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 8e2ddbc2129c..3abd6d92aae0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -573,28 +573,25 @@ static void plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	int fe_idx = pipe_ctx->pipe_idx;
 	struct hubp *hubp = dc->res_pool->hubps[fe_idx];
 	struct mpc *mpc = dc->res_pool->mpc;
-	int opp_id, z_idx;
-	int mpcc_id = -1;
+	int opp_id;
+	struct mpc_tree *mpc_tree_params;
+	struct mpcc *mpcc_to_remove = NULL;
 
 	/* look at tree rather than mi here to know if we already reset */
 	for (opp_id = 0; opp_id < dc->res_pool->pipe_count; opp_id++) {
 		struct output_pixel_processor *opp = dc->res_pool->opps[opp_id];
 
-		for (z_idx = 0; z_idx < opp->mpc_tree.num_pipes; z_idx++) {
-			if (opp->mpc_tree.dpp[z_idx] == fe_idx) {
-				mpcc_id = opp->mpc_tree.mpcc[z_idx];
-				break;
-			}
-		}
-		if (mpcc_id != -1)
+		mpc_tree_params = &(opp->mpc_tree_params);
+		mpcc_to_remove = mpc->funcs->get_mpcc_for_dpp(mpc_tree_params, fe_idx);
+		if (mpcc_to_remove != NULL)
 			break;
 	}
+
 	/*Already reset*/
 	if (opp_id == dc->res_pool->pipe_count)
 		return;
 
-	mpc->funcs->remove(mpc, &(dc->res_pool->opps[opp_id]->mpc_tree),
-					dc->res_pool->opps[opp_id]->inst, fe_idx);
+	mpc->funcs->remove_mpcc(mpc, mpc_tree_params, mpcc_to_remove);
 
 	if (hubp->funcs->hubp_disconnect)
 		hubp->funcs->hubp_disconnect(hubp);
@@ -652,7 +649,7 @@ static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	REG_UPDATE(DPP_CONTROL[fe_idx],
 			DPP_CLOCK_ENABLE, 0);
 
-	if (opp_id != 0xf && dc->res_pool->opps[opp_id]->mpc_tree.num_pipes == 0)
+	if (opp_id != 0xf && dc->res_pool->opps[opp_id]->mpc_tree_params.opp_list == NULL)
 		REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
 				OPP_PIPE_CLOCK_EN, 0);
 
@@ -677,7 +674,7 @@ static void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
 
 static void dcn10_init_hw(struct dc *dc)
 {
-	int i;
+	int i, opp_id;
 	struct abm *abm = dc->res_pool->abm;
 	struct dmcu *dmcu = dc->res_pool->dmcu;
 	struct dce_hwseq *hws = dc->hwseq;
@@ -740,17 +737,19 @@ static void dcn10_init_hw(struct dc *dc)
 		}
 	}
 
+	/* Initialize MPC tree based on HW values */
+	for (opp_id = 0; opp_id < dc->res_pool->pipe_count; opp_id++) {
+		struct output_pixel_processor *opp = dc->res_pool->opps[opp_id];
+		struct mpc_tree *mpc_tree_params = &(opp->mpc_tree_params);
+
+		dc->res_pool->mpc->funcs->init_mpcc_list_from_hw(dc->res_pool->mpc, mpc_tree_params);
+	}
+
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct timing_generator *tg = dc->res_pool->timing_generators[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-		struct output_pixel_processor *opp = dc->res_pool->opps[i];
-		struct mpc_tree_cfg *mpc_tree = &opp->mpc_tree;
 		struct hubp *hubp = dc->res_pool->hubps[i];
 
-		mpc_tree->dpp[0] = i;
-		mpc_tree->mpcc[0] = i;
-		mpc_tree->num_pipes = 1;
-
 		pipe_ctx->stream_res.tg = tg;
 		pipe_ctx->pipe_idx = i;
 
@@ -1694,38 +1693,6 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 	}
 }
 
-static void set_mpc_output_csc(struct dc *dc,
-		struct pipe_ctx *pipe_ctx,
-		enum dc_color_space colorspace,
-		uint16_t *matrix,
-		int opp_id)
-{
-	struct mpc *mpc = dc->res_pool->mpc;
-	int i;
-	struct out_csc_color_matrix tbl_entry;
-	enum mpc_output_csc_mode ocsc_mode = MPC_OUTPUT_CSC_COEF_A;
-
-
-	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment == true) {
-		//uint16_t matrix[12];
-		for (i = 0; i < 12; i++)
-			tbl_entry.regval[i] = matrix[i];
-		tbl_entry.color_space = colorspace;
-
-		if (mpc->funcs->set_output_csc != NULL)
-			mpc->funcs->set_output_csc(mpc,
-					opp_id,
-					&tbl_entry,
-					ocsc_mode);
-	} else {
-		if (mpc->funcs->set_ocsc_default != NULL)
-			mpc->funcs->set_ocsc_default(mpc,
-					opp_id,
-					colorspace,
-					ocsc_mode);
-	}
-}
-
 static void program_output_csc(struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
 		enum dc_color_space colorspace,
@@ -1736,13 +1703,6 @@ static void program_output_csc(struct dc *dc,
 		program_csc_matrix(pipe_ctx,
 				colorspace,
 				matrix);
-	else
-		set_mpc_output_csc(dc,
-			pipe_ctx,
-			colorspace,
-			matrix,
-			opp_id);
-
 }
 
 static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
@@ -1914,35 +1874,73 @@ static void update_dpp(struct dpp *dpp, struct dc_plane_state *plane_state)
 
 static void update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
-	struct mpcc_cfg mpcc_cfg = {0};
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
-	struct pipe_ctx *top_pipe;
-	bool per_pixel_alpha =
-			pipe_ctx->plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;
+	struct mpcc_blnd_cfg blnd_cfg;
+	bool per_pixel_alpha = pipe_ctx->plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;
+	int mpcc_id;
+	struct mpcc *new_mpcc;
+	struct mpc *mpc = dc->res_pool->mpc;
+	struct mpc_tree *mpc_tree_params = &(pipe_ctx->stream_res.opp->mpc_tree_params);
 
 	/* TODO: proper fix once fpga works */
 
-	mpcc_cfg.dpp_id = hubp->inst;
-	mpcc_cfg.opp_id = pipe_ctx->stream_res.opp->inst;
-	mpcc_cfg.tree_cfg = &(pipe_ctx->stream_res.opp->mpc_tree);
-	for (top_pipe = pipe_ctx->top_pipe; top_pipe; top_pipe = top_pipe->top_pipe)
-		mpcc_cfg.z_index++;
 	if (dc->debug.surface_visual_confirm)
 		dcn10_get_surface_visual_confirm_color(
-				pipe_ctx, &mpcc_cfg.black_color);
+				pipe_ctx, &blnd_cfg.black_color);
 	else
 		color_space_to_black_color(
 			dc, pipe_ctx->stream->output_color_space,
-			&mpcc_cfg.black_color);
-	mpcc_cfg.per_pixel_alpha = per_pixel_alpha;
+			&blnd_cfg.black_color);
+
+	if (per_pixel_alpha)
+		blnd_cfg.alpha_mode = MPCC_ALPHA_BLEND_MODE_PER_PIXEL_ALPHA;
+	else
+		blnd_cfg.alpha_mode = MPCC_ALPHA_BLEND_MODE_GLOBAL_ALPHA;
+
+	blnd_cfg.overlap_only = false;
+	blnd_cfg.global_alpha = 0xff;
+	blnd_cfg.global_gain = 0xff;
+
 	/* DCN1.0 has output CM before MPC which seems to screw with
 	 * pre-multiplied alpha.
 	 */
-	mpcc_cfg.pre_multiplied_alpha = is_rgb_cspace(
+	blnd_cfg.pre_multiplied_alpha = is_rgb_cspace(
 			pipe_ctx->stream->output_color_space)
 					&& per_pixel_alpha;
-	hubp->mpcc_id = dc->res_pool->mpc->funcs->add(dc->res_pool->mpc, &mpcc_cfg);
-	hubp->opp_id = mpcc_cfg.opp_id;
+
+	/*
+	 * TODO: remove hack
+	 * Note: currently there is a bug in init_hw such that
+	 * on resume from hibernate, BIOS sets up MPCC0, and
+	 * we do mpcc_remove but the mpcc cannot go to idle
+	 * after remove. This cause us to pick mpcc1 here,
+	 * which causes a pstate hang for yet unknown reason.
+	 */
+	mpcc_id = hubp->inst;
+
+	/* check if this MPCC is already being used */
+	new_mpcc = mpc->funcs->get_mpcc_for_dpp(mpc_tree_params, mpcc_id);
+	/* remove MPCC if being used */
+	if (new_mpcc != NULL)
+		mpc->funcs->remove_mpcc(mpc, mpc_tree_params, new_mpcc);
+
+	if (dc->debug.sanity_checks)
+		mpc->funcs->assert_mpcc_idle_before_connect(
+				dc->res_pool->mpc, mpcc_id);
+
+	/* Call MPC to insert new plane */
+	new_mpcc = mpc->funcs->insert_plane(dc->res_pool->mpc,
+			mpc_tree_params,
+			&blnd_cfg,
+			NULL,
+			NULL,
+			hubp->inst,
+			mpcc_id);
+
+	ASSERT(new_mpcc != NULL);
+
+	hubp->opp_id = pipe_ctx->stream_res.opp->inst;
+	hubp->mpcc_id = mpcc_id;
 }
 
 static void update_scaler(struct pipe_ctx *pipe_ctx)

commit 621fd3e39fc0222d7c8d95ddb5a2dff6261a0a86
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Tue Nov 14 12:40:20 2017 -0500

    drm/amd/display: Set OPP default values in init_hw
    
    On S3 resume, we do not reconstruct OPP, but we do need to
    reinitialize some of its values to the default ones.
    Therefore, move those lines out of the OPP constructor and
    into init_hw.
    
    Also reset the hubp power gated flag, since nothing is
    power gated at init_hw.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 522adceaf5d0..8e2ddbc2129c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -743,13 +743,21 @@ static void dcn10_init_hw(struct dc *dc)
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct timing_generator *tg = dc->res_pool->timing_generators[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+		struct output_pixel_processor *opp = dc->res_pool->opps[i];
+		struct mpc_tree_cfg *mpc_tree = &opp->mpc_tree;
+		struct hubp *hubp = dc->res_pool->hubps[i];
+
+		mpc_tree->dpp[0] = i;
+		mpc_tree->mpcc[0] = i;
+		mpc_tree->num_pipes = 1;
 
 		pipe_ctx->stream_res.tg = tg;
 		pipe_ctx->pipe_idx = i;
-		pipe_ctx->plane_res.hubp = dc->res_pool->hubps[i];
-		pipe_ctx->plane_res.hubp->mpcc_id = i;
-		pipe_ctx->plane_res.hubp->opp_id =
-				dc->res_pool->mpc->funcs->get_opp_id(dc->res_pool->mpc, i);
+
+		pipe_ctx->plane_res.hubp = hubp;
+		hubp->mpcc_id = i;
+		hubp->opp_id = dc->res_pool->mpc->funcs->get_opp_id(dc->res_pool->mpc, i);
+		hubp->power_gated = false;
 
 		plane_atomic_disconnect(dc, pipe_ctx);
 	}

commit 8980aa3c9ed63f703fd5e0bff6a53b6ba1356ae1
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Nov 13 17:22:17 2017 -0500

    drm/amd/display: Only program watermark for full update.
    
    For scaling and position change, it isn't necessary to program
    watermark and check P-State as well.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 9641b36cbad4..522adceaf5d0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2056,11 +2056,6 @@ static void program_all_pipe_in_tree(
 {
 	if (pipe_ctx->top_pipe == NULL) {
 
-		if (dc->debug.sanity_checks) {
-			/* pstate stuck check after watermark update */
-			dcn10_verify_allow_pstate_change_high(dc);
-		}
-
 		pipe_ctx->stream_res.tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
 		pipe_ctx->stream_res.tg->dlg_otg_param.vstartup_start = pipe_ctx->pipe_dlg_param.vstartup_start;
 		pipe_ctx->stream_res.tg->dlg_otg_param.vupdate_offset = pipe_ctx->pipe_dlg_param.vupdate_offset;
@@ -2094,11 +2089,6 @@ static void program_all_pipe_in_tree(
 			dc->hwss.set_output_transfer_func(pipe_ctx, pipe_ctx->stream);
 	}
 
-	if (dc->debug.sanity_checks) {
-		/* pstate stuck check after each pipe is programmed */
-		dcn10_verify_allow_pstate_change_high(dc);
-	}
-
 	if (pipe_ctx->bottom_pipe != NULL && pipe_ctx->bottom_pipe != pipe_ctx)
 		program_all_pipe_in_tree(dc, pipe_ctx->bottom_pipe, context);
 }
@@ -2183,6 +2173,7 @@ static void dcn10_apply_ctx_for_surface(
 	struct timing_generator *tg;
 	bool removed_pipe[4] = { false };
 	unsigned int ref_clk_mhz = dc->res_pool->ref_clock_inKhz/1000;
+	bool program_water_mark = false;
 
 	struct pipe_ctx *top_pipe_to_program =
 			find_top_pipe_for_stream(dc, context, stream);
@@ -2192,9 +2183,6 @@ static void dcn10_apply_ctx_for_surface(
 
 	tg = top_pipe_to_program->stream_res.tg;
 
-	if (dc->debug.sanity_checks)
-		dcn10_verify_allow_pstate_change_high(dc);
-
 	tg->funcs->lock(tg);
 
 	if (num_planes == 0) {
@@ -2261,24 +2249,31 @@ static void dcn10_apply_ctx_for_surface(
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *old_pipe_ctx =
 				&dc->current_state->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (pipe_ctx->stream == stream &&
+				pipe_ctx->plane_state &&
+			pipe_ctx->plane_state->update_flags.bits.full_update)
+			program_water_mark = true;
 
 		if (removed_pipe[i] && num_planes == 0)
 			dcn10_disable_plane(dc, old_pipe_ctx);
 	}
 
-	if (dc->debug.sanity_checks) {
-		/* pstate stuck check after watermark update */
-		dcn10_verify_allow_pstate_change_high(dc);
-	}
-	/* watermark is for all pipes */
-	hubbub1_program_watermarks(dc->res_pool->hubbub,
-			&context->bw.dcn.watermarks, ref_clk_mhz);
+	if (program_water_mark) {
+		if (dc->debug.sanity_checks) {
+			/* pstate stuck check after watermark update */
+			dcn10_verify_allow_pstate_change_high(dc);
+		}
+		/* watermark is for all pipes */
+		hubbub1_program_watermarks(dc->res_pool->hubbub,
+				&context->bw.dcn.watermarks, ref_clk_mhz);
 
-	if (dc->debug.sanity_checks) {
-		/* pstate stuck check after watermark update */
-		dcn10_verify_allow_pstate_change_high(dc);
+		if (dc->debug.sanity_checks) {
+			/* pstate stuck check after watermark update */
+			dcn10_verify_allow_pstate_change_high(dc);
+		}
 	}
-
 /*	dm_logger_write(dc->ctx->logger, LOG_BANDWIDTH_CALCS,
 			"\n============== Watermark parameters ==============\n"
 			"a.urgent_ns: %d \n"
@@ -2326,9 +2321,6 @@ static void dcn10_apply_ctx_for_surface(
 			context->bw.dcn.watermarks.d.pte_meta_urgent_ns
 			);
 */
-
-	if (dc->debug.sanity_checks)
-		dcn10_verify_allow_pstate_change_high(dc);
 }
 
 static void dcn10_set_bandwidth(

commit 4a43586bac9ae1d092d23c1cfe937cf05caa4c0d
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Thu Nov 9 17:03:00 2017 -0500

    drm/amd/display: update output csc matrix values
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 39869d379e3f..9641b36cbad4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1686,7 +1686,6 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 	}
 }
 
-//program ocsc matrix for dcn 2
 static void set_mpc_output_csc(struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
 		enum dc_color_space colorspace,
@@ -1710,9 +1709,7 @@ static void set_mpc_output_csc(struct dc *dc,
 					opp_id,
 					&tbl_entry,
 					ocsc_mode);
-	}
-
-	else {
+	} else {
 		if (mpc->funcs->set_ocsc_default != NULL)
 			mpc->funcs->set_ocsc_default(mpc,
 					opp_id,

commit 675634c5aba341b2fee890fb93b3d3649ac5ce0b
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Nov 10 15:40:52 2017 -0500

    drm/amd/display: Only update output transfer function for full type.
    
    dcn10_translate_regamma_to_hw_format costs 750us to run, it cannot be
    called within isr, check update flag before calling, only do it for
    full update.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index ad0e3b9be055..39869d379e3f 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1211,9 +1211,17 @@ dcn10_set_output_transfer_func(struct pipe_ctx *pipe_ctx,
 	    stream->out_transfer_func->type == TF_TYPE_PREDEFINED &&
 	    stream->out_transfer_func->tf == TRANSFER_FUNCTION_SRGB)
 		dpp->funcs->dpp_program_regamma_pwl(dpp, NULL, OPP_REGAMMA_SRGB);
-	else if (dcn10_translate_regamma_to_hw_format(stream->out_transfer_func, &dpp->regamma_params))
-		dpp->funcs->dpp_program_regamma_pwl(dpp, &dpp->regamma_params, OPP_REGAMMA_USER);
-	else
+
+	/* dcn10_translate_regamma_to_hw_format takes 750us, only do it when full
+	 * update.
+	 */
+	else if (dcn10_translate_regamma_to_hw_format(
+			stream->out_transfer_func,
+			&dpp->regamma_params)) {
+		dpp->funcs->dpp_program_regamma_pwl(
+				dpp,
+				&dpp->regamma_params, OPP_REGAMMA_USER);
+	} else
 		dpp->funcs->dpp_program_regamma_pwl(dpp, NULL, OPP_REGAMMA_BYPASS);
 
 	return true;
@@ -2076,16 +2084,17 @@ static void program_all_pipe_in_tree(
 
 		update_dchubp_dpp(dc, pipe_ctx, context);
 
-		if (cur_pipe_ctx->plane_state != pipe_ctx->plane_state) {
+		if (cur_pipe_ctx->plane_state != pipe_ctx->plane_state)
 			dc->hwss.set_input_transfer_func(pipe_ctx, pipe_ctx->plane_state);
-		}
 
-		/*
+		/* dcn10_translate_regamma_to_hw_format takes 750us to finish
+		 * only do gamma programming for full update.
 		 * TODO: This can be further optimized/cleaned up
 		 * Always call this for now since it does memcmp inside before
 		 * doing heavy calculation and programming
 		 */
-		dc->hwss.set_output_transfer_func(pipe_ctx, pipe_ctx->stream);
+		if (pipe_ctx->plane_state->update_flags.bits.full_update)
+			dc->hwss.set_output_transfer_func(pipe_ctx, pipe_ctx->stream);
 	}
 
 	if (dc->debug.sanity_checks) {

commit dce46c53208f90cf5a401b62b17bbe2bc629c069
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Wed Nov 8 16:07:53 2017 -0500

    drm/amd/display: performance profiling instrumentation
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c92eba0f0df8..ad0e3b9be055 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1047,6 +1047,8 @@ dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
 	if (output_tf == NULL || regamma_params == NULL || output_tf->type == TF_TYPE_BYPASS)
 		return false;
 
+	PERF_TRACE();
+
 	arr_points = regamma_params->arr_points;
 	rgb_resulted = regamma_params->rgb_resulted;
 	hw_points = 0;
@@ -1189,6 +1191,8 @@ dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
 
 	convert_to_custom_float(rgb_resulted, arr_points, hw_points);
 
+	PERF_TRACE();
+
 	return true;
 }
 

commit 480bd0cf450bdabeca49f135e6f1c2a58d1bb957
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Nov 8 17:24:54 2017 -0500

    drm/amd/display: Update dchub and dpp as per update flags.
    
    Check update flags and update dchub and dpp as per flags,
    reduce reg access from 347 to 200, duration time reduce
    to 170us.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e08ad585b7b9..c92eba0f0df8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1878,47 +1878,10 @@ void build_prescale_params(struct  dc_bias_and_scale *bias_and_scale,
 	}
 }
 
-static void update_dchubp_dpp(
-	struct dc *dc,
-	struct pipe_ctx *pipe_ctx,
-	struct dc_state *context)
+static void update_dpp(struct dpp *dpp, struct dc_plane_state *plane_state)
 {
-	struct dce_hwseq *hws = dc->hwseq;
-	struct hubp *hubp = pipe_ctx->plane_res.hubp;
-	struct dpp *dpp = pipe_ctx->plane_res.dpp;
-	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
-	union plane_size size = plane_state->plane_size;
-	struct mpcc_cfg mpcc_cfg = {0};
-	struct pipe_ctx *top_pipe;
-	bool per_pixel_alpha = plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;
 	struct dc_bias_and_scale bns_params = {0};
 
-	/* TODO: proper fix once fpga works */
-	/* depends on DML calculation, DPP clock value may change dynamically */
-	enable_dppclk(
-		dc->hwseq,
-		pipe_ctx->pipe_idx,
-		pipe_ctx->stream_res.pix_clk_params.requested_pix_clk,
-		context->bw.dcn.calc_clk.dppclk_div);
-	dc->current_state->bw.dcn.cur_clk.dppclk_div =
-			context->bw.dcn.calc_clk.dppclk_div;
-	context->bw.dcn.cur_clk.dppclk_div = context->bw.dcn.calc_clk.dppclk_div;
-
-	/* TODO: Need input parameter to tell current DCHUB pipe tie to which OTG
-	 * VTG is within DCHUBBUB which is commond block share by each pipe HUBP.
-	 * VTG is 1:1 mapping with OTG. Each pipe HUBP will select which VTG
-	 */
-	REG_UPDATE(DCHUBP_CNTL[pipe_ctx->pipe_idx], HUBP_VTG_SEL, pipe_ctx->stream_res.tg->inst);
-
-	hubp->funcs->hubp_setup(
-		hubp,
-		&pipe_ctx->dlg_regs,
-		&pipe_ctx->ttu_regs,
-		&pipe_ctx->rq_regs,
-		&pipe_ctx->pipe_dlg_param);
-
-	size.grph.surface_size = pipe_ctx->plane_res.scl_data.viewport;
-
 	// program the input csc
 	dpp->funcs->dpp_setup(dpp,
 			plane_state->format,
@@ -1930,6 +1893,17 @@ static void update_dchubp_dpp(
 	build_prescale_params(&bns_params, plane_state);
 	if (dpp->funcs->dpp_program_bias_and_scale)
 		dpp->funcs->dpp_program_bias_and_scale(dpp, &bns_params);
+}
+
+static void update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx)
+{
+	struct mpcc_cfg mpcc_cfg = {0};
+	struct hubp *hubp = pipe_ctx->plane_res.hubp;
+	struct pipe_ctx *top_pipe;
+	bool per_pixel_alpha =
+			pipe_ctx->plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;
+
+	/* TODO: proper fix once fpga works */
 
 	mpcc_cfg.dpp_id = hubp->inst;
 	mpcc_cfg.opp_id = pipe_ctx->stream_res.opp->inst;
@@ -1952,33 +1926,110 @@ static void update_dchubp_dpp(
 					&& per_pixel_alpha;
 	hubp->mpcc_id = dc->res_pool->mpc->funcs->add(dc->res_pool->mpc, &mpcc_cfg);
 	hubp->opp_id = mpcc_cfg.opp_id;
+}
+
+static void update_scaler(struct pipe_ctx *pipe_ctx)
+{
+	bool per_pixel_alpha =
+			pipe_ctx->plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;
+
+	/* TODO: proper fix once fpga works */
 
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = per_pixel_alpha;
 	pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
 	/* scaler configuration */
 	pipe_ctx->plane_res.dpp->funcs->dpp_set_scaler(
 			pipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data);
+}
 
-	hubp->funcs->mem_program_viewport(hubp,
-			&pipe_ctx->plane_res.scl_data.viewport, &pipe_ctx->plane_res.scl_data.viewport_c);
+static void update_dchubp_dpp(
+	struct dc *dc,
+	struct pipe_ctx *pipe_ctx,
+	struct dc_state *context)
+{
+	struct dce_hwseq *hws = dc->hwseq;
+	struct hubp *hubp = pipe_ctx->plane_res.hubp;
+	struct dpp *dpp = pipe_ctx->plane_res.dpp;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
+	union plane_size size = plane_state->plane_size;
 
-	/*gamut remap*/
-	program_gamut_remap(pipe_ctx);
+	/* depends on DML calculation, DPP clock value may change dynamically */
+	if (pipe_ctx->plane_state->update_flags.raw != 0) {
+		enable_dppclk(
+			dc->hwseq,
+			pipe_ctx->pipe_idx,
+			pipe_ctx->stream_res.pix_clk_params.requested_pix_clk,
+			context->bw.dcn.calc_clk.dppclk_div);
+		dc->current_state->bw.dcn.cur_clk.dppclk_div =
+				context->bw.dcn.calc_clk.dppclk_div;
+		context->bw.dcn.cur_clk.dppclk_div = context->bw.dcn.calc_clk.dppclk_div;
+	}
 
-	program_output_csc(dc,
-			pipe_ctx,
-			pipe_ctx->stream->output_color_space,
-			pipe_ctx->stream->csc_color_matrix.matrix,
-			mpcc_cfg.opp_id);
-
-	hubp->funcs->hubp_program_surface_config(
-		hubp,
-		plane_state->format,
-		&plane_state->tiling_info,
-		&size,
-		plane_state->rotation,
-		&plane_state->dcc,
-		plane_state->horizontal_mirror);
+	/* TODO: Need input parameter to tell current DCHUB pipe tie to which OTG
+	 * VTG is within DCHUBBUB which is commond block share by each pipe HUBP.
+	 * VTG is 1:1 mapping with OTG. Each pipe HUBP will select which VTG
+	 */
+	if (plane_state->update_flags.bits.full_update) {
+		REG_UPDATE(DCHUBP_CNTL[pipe_ctx->pipe_idx], HUBP_VTG_SEL, pipe_ctx->stream_res.tg->inst);
+
+		hubp->funcs->hubp_setup(
+			hubp,
+			&pipe_ctx->dlg_regs,
+			&pipe_ctx->ttu_regs,
+			&pipe_ctx->rq_regs,
+			&pipe_ctx->pipe_dlg_param);
+	}
+
+	size.grph.surface_size = pipe_ctx->plane_res.scl_data.viewport;
+
+	if (plane_state->update_flags.bits.full_update ||
+		plane_state->update_flags.bits.bpp_change)
+		update_dpp(dpp, plane_state);
+
+	if (plane_state->update_flags.bits.full_update ||
+		plane_state->update_flags.bits.per_pixel_alpha_change)
+		update_mpcc(dc, pipe_ctx);
+
+	if (plane_state->update_flags.bits.full_update ||
+		plane_state->update_flags.bits.per_pixel_alpha_change ||
+		plane_state->update_flags.bits.scaling_change ||
+		plane_state->update_flags.bits.position_change) {
+		update_scaler(pipe_ctx);
+	}
+
+	if (plane_state->update_flags.bits.full_update ||
+		plane_state->update_flags.bits.scaling_change) {
+		hubp->funcs->mem_program_viewport(
+			hubp,
+			&pipe_ctx->plane_res.scl_data.viewport,
+			&pipe_ctx->plane_res.scl_data.viewport_c);
+	}
+
+	if (plane_state->update_flags.bits.full_update) {
+		/*gamut remap*/
+		program_gamut_remap(pipe_ctx);
+
+		program_output_csc(dc,
+				pipe_ctx,
+				pipe_ctx->stream->output_color_space,
+				pipe_ctx->stream->csc_color_matrix.matrix,
+				hubp->opp_id);
+	}
+
+	if (plane_state->update_flags.bits.full_update ||
+		plane_state->update_flags.bits.horizontal_mirror_change ||
+		plane_state->update_flags.bits.rotation_change ||
+		plane_state->update_flags.bits.swizzle_change ||
+		plane_state->update_flags.bits.bpp_change) {
+		hubp->funcs->hubp_program_surface_config(
+			hubp,
+			plane_state->format,
+			&plane_state->tiling_info,
+			&size,
+			plane_state->rotation,
+			&plane_state->dcc,
+			plane_state->horizontal_mirror);
+	}
 
 	hubp->power_gated = false;
 
@@ -2019,8 +2070,7 @@ static void program_all_pipe_in_tree(
 		if (pipe_ctx->plane_state->update_flags.bits.full_update)
 			dcn10_enable_plane(dc, pipe_ctx, context);
 
-		if (pipe_ctx->plane_state->update_flags.raw != 0)
-			update_dchubp_dpp(dc, pipe_ctx, context);
+		update_dchubp_dpp(dc, pipe_ctx, context);
 
 		if (cur_pipe_ctx->plane_state != pipe_ctx->plane_state) {
 			dc->hwss.set_input_transfer_func(pipe_ctx, pipe_ctx->plane_state);
@@ -2181,26 +2231,18 @@ static void dcn10_apply_ctx_for_surface(
 	}
 
 	if (num_planes > 0) {
-		struct dc_stream_state *stream_for_cursor = NULL;
-
 		program_all_pipe_in_tree(dc, top_pipe_to_program, context);
 
-		for (i = 0; i < dc->res_pool->pipe_count; i++) {
-			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-
-			if (stream == pipe_ctx->stream) {
-				stream_for_cursor = pipe_ctx->stream;
-				break;
-			}
-		}
-
 		/* TODO: this is a hack w/a for switching from mpo to pipe split */
-		if (stream_for_cursor->cursor_attributes.address.quad_part != 0) {
+		if (stream->cursor_attributes.address.quad_part != 0) {
 			struct dc_cursor_position position = { 0 };
 
-			dc_stream_set_cursor_position(stream_for_cursor, &position);
-			dc_stream_set_cursor_attributes(stream_for_cursor,
-				&stream_for_cursor->cursor_attributes);
+			dc_stream_set_cursor_position(
+				(struct dc_stream_state *)stream,
+				&position);
+			dc_stream_set_cursor_attributes(
+				(struct dc_stream_state *)stream,
+				&stream->cursor_attributes);
 		}
 	}
 
@@ -2227,7 +2269,7 @@ static void dcn10_apply_ctx_for_surface(
 		dcn10_verify_allow_pstate_change_high(dc);
 	}
 
-	dm_logger_write(dc->ctx->logger, LOG_BANDWIDTH_CALCS,
+/*	dm_logger_write(dc->ctx->logger, LOG_BANDWIDTH_CALCS,
 			"\n============== Watermark parameters ==============\n"
 			"a.urgent_ns: %d \n"
 			"a.cstate_enter_plus_exit: %d \n"
@@ -2273,6 +2315,7 @@ static void dcn10_apply_ctx_for_surface(
 			context->bw.dcn.watermarks.d.cstate_pstate.pstate_change_ns,
 			context->bw.dcn.watermarks.d.pte_meta_urgent_ns
 			);
+*/
 
 	if (dc->debug.sanity_checks)
 		dcn10_verify_allow_pstate_change_high(dc);

commit afbeb2638b0a983100a5e6591bd1b76ef45bf20c
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Wed Nov 1 16:48:52 2017 -0400

    drm/amd/display: call set_mpc_output_csc from hwsequencer
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index b5d048b364a4..e08ad585b7b9 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1666,12 +1666,68 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 			tbl_entry.color_space = color_space;
 			//tbl_entry.regval = matrix;
 
-			pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment(pipe_ctx->plane_res.dpp, &tbl_entry);
+			if (pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment != NULL)
+				pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment(pipe_ctx->plane_res.dpp, &tbl_entry);
 	} else {
-		pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_default(pipe_ctx->plane_res.dpp, colorspace);
+		if (pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_default != NULL)
+			pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_default(pipe_ctx->plane_res.dpp, colorspace);
 	}
 }
 
+//program ocsc matrix for dcn 2
+static void set_mpc_output_csc(struct dc *dc,
+		struct pipe_ctx *pipe_ctx,
+		enum dc_color_space colorspace,
+		uint16_t *matrix,
+		int opp_id)
+{
+	struct mpc *mpc = dc->res_pool->mpc;
+	int i;
+	struct out_csc_color_matrix tbl_entry;
+	enum mpc_output_csc_mode ocsc_mode = MPC_OUTPUT_CSC_COEF_A;
+
+
+	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment == true) {
+		//uint16_t matrix[12];
+		for (i = 0; i < 12; i++)
+			tbl_entry.regval[i] = matrix[i];
+		tbl_entry.color_space = colorspace;
+
+		if (mpc->funcs->set_output_csc != NULL)
+			mpc->funcs->set_output_csc(mpc,
+					opp_id,
+					&tbl_entry,
+					ocsc_mode);
+	}
+
+	else {
+		if (mpc->funcs->set_ocsc_default != NULL)
+			mpc->funcs->set_ocsc_default(mpc,
+					opp_id,
+					colorspace,
+					ocsc_mode);
+	}
+}
+
+static void program_output_csc(struct dc *dc,
+		struct pipe_ctx *pipe_ctx,
+		enum dc_color_space colorspace,
+		uint16_t *matrix,
+		int opp_id)
+{
+	if (pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment != NULL)
+		program_csc_matrix(pipe_ctx,
+				colorspace,
+				matrix);
+	else
+		set_mpc_output_csc(dc,
+			pipe_ctx,
+			colorspace,
+			matrix,
+			opp_id);
+
+}
+
 static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
 	if (pipe_ctx->plane_state->visible)
@@ -1909,10 +1965,11 @@ static void update_dchubp_dpp(
 	/*gamut remap*/
 	program_gamut_remap(pipe_ctx);
 
-	program_csc_matrix(pipe_ctx,
+	program_output_csc(dc,
+			pipe_ctx,
 			pipe_ctx->stream->output_color_space,
-			pipe_ctx->stream->csc_color_matrix.matrix);
-
+			pipe_ctx->stream->csc_color_matrix.matrix,
+			mpcc_cfg.opp_id);
 
 	hubp->funcs->hubp_program_surface_config(
 		hubp,

commit 671b00e26c6ca40f90789b0af59fafd44a096be9
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Wed Nov 8 15:30:19 2017 -0500

    drm/amd/display: Fix use before initialize warning
    
    on stream_for_cursor. Initialize to NULL.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 30f458701f9c..b5d048b364a4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2124,7 +2124,7 @@ static void dcn10_apply_ctx_for_surface(
 	}
 
 	if (num_planes > 0) {
-		struct dc_stream_state *stream_for_cursor;
+		struct dc_stream_state *stream_for_cursor = NULL;
 
 		program_all_pipe_in_tree(dc, top_pipe_to_program, context);
 

commit a4e6d14ebe80ee53e295540c51dfb1352d7069a8
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Nov 8 14:50:06 2017 -0500

    drm/amd/display: Optimize front end programming.
    
    for video scaling changes,
    Reduce reg access count from 1044 to 447, duration time
    from 4.6ms to 3ms.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d0f46e13efca..30f458701f9c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1453,6 +1453,89 @@ static void dcn10_enable_per_frame_crtc_position_reset(
 }
 */
 
+static void mmhub_read_vm_system_aperture_settings(struct dcn10_hubp *hubp1,
+		struct vm_system_aperture_param *apt,
+		struct dce_hwseq *hws)
+{
+	PHYSICAL_ADDRESS_LOC physical_page_number;
+	uint32_t logical_addr_low;
+	uint32_t logical_addr_high;
+
+	REG_GET(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB,
+			PHYSICAL_PAGE_NUMBER_MSB, &physical_page_number.high_part);
+	REG_GET(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB,
+			PHYSICAL_PAGE_NUMBER_LSB, &physical_page_number.low_part);
+
+	REG_GET(MC_VM_SYSTEM_APERTURE_LOW_ADDR,
+			LOGICAL_ADDR, &logical_addr_low);
+
+	REG_GET(MC_VM_SYSTEM_APERTURE_HIGH_ADDR,
+			LOGICAL_ADDR, &logical_addr_high);
+
+	apt->sys_default.quad_part =  physical_page_number.quad_part << 12;
+	apt->sys_low.quad_part =  (int64_t)logical_addr_low << 18;
+	apt->sys_high.quad_part =  (int64_t)logical_addr_high << 18;
+}
+
+/* Temporary read settings, future will get values from kmd directly */
+static void mmhub_read_vm_context0_settings(struct dcn10_hubp *hubp1,
+		struct vm_context0_param *vm0,
+		struct dce_hwseq *hws)
+{
+	PHYSICAL_ADDRESS_LOC fb_base;
+	PHYSICAL_ADDRESS_LOC fb_offset;
+	uint32_t fb_base_value;
+	uint32_t fb_offset_value;
+
+	REG_GET(DCHUBBUB_SDPIF_FB_BASE, SDPIF_FB_BASE, &fb_base_value);
+	REG_GET(DCHUBBUB_SDPIF_FB_OFFSET, SDPIF_FB_OFFSET, &fb_offset_value);
+
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32,
+			PAGE_DIRECTORY_ENTRY_HI32, &vm0->pte_base.high_part);
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32,
+			PAGE_DIRECTORY_ENTRY_LO32, &vm0->pte_base.low_part);
+
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_START_ADDR_HI32,
+			LOGICAL_PAGE_NUMBER_HI4, &vm0->pte_start.high_part);
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_START_ADDR_LO32,
+			LOGICAL_PAGE_NUMBER_LO32, &vm0->pte_start.low_part);
+
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_END_ADDR_HI32,
+			LOGICAL_PAGE_NUMBER_HI4, &vm0->pte_end.high_part);
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_END_ADDR_LO32,
+			LOGICAL_PAGE_NUMBER_LO32, &vm0->pte_end.low_part);
+
+	REG_GET(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_HI32,
+			PHYSICAL_PAGE_ADDR_HI4, &vm0->fault_default.high_part);
+	REG_GET(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_LO32,
+			PHYSICAL_PAGE_ADDR_LO32, &vm0->fault_default.low_part);
+
+	/*
+	 * The values in VM_CONTEXT0_PAGE_TABLE_BASE_ADDR is in UMA space.
+	 * Therefore we need to do
+	 * DCN_VM_CONTEXT0_PAGE_TABLE_BASE_ADDR = VM_CONTEXT0_PAGE_TABLE_BASE_ADDR
+	 * - DCHUBBUB_SDPIF_FB_OFFSET + DCHUBBUB_SDPIF_FB_BASE
+	 */
+	fb_base.quad_part = (uint64_t)fb_base_value << 24;
+	fb_offset.quad_part = (uint64_t)fb_offset_value << 24;
+	vm0->pte_base.quad_part += fb_base.quad_part;
+	vm0->pte_base.quad_part -= fb_offset.quad_part;
+}
+
+
+static void dcn10_program_pte_vm(struct dce_hwseq *hws, struct hubp *hubp)
+{
+	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
+	struct vm_system_aperture_param apt = { {{ 0 } } };
+	struct vm_context0_param vm0 = { { { 0 } } };
+
+	mmhub_read_vm_system_aperture_settings(hubp1, &apt, hws);
+	mmhub_read_vm_context0_settings(hubp1, &vm0, hws);
+
+	hubp->funcs->hubp_set_vm_system_aperture_settings(hubp, &apt);
+	hubp->funcs->hubp_set_vm_context0_settings(hubp, &vm0);
+}
+
 static void dcn10_enable_plane(
 	struct dc *dc,
 	struct pipe_ctx *pipe_ctx,
@@ -1515,6 +1598,8 @@ static void dcn10_enable_plane(
 		print_rq_dlg_ttu(dc, pipe_ctx);
 	}
 */
+	if (dc->config.gpu_vm_support)
+		dcn10_program_pte_vm(hws, pipe_ctx->plane_res.hubp);
 
 	if (dc->debug.sanity_checks) {
 		dcn10_verify_allow_pstate_change_high(dc);
@@ -1737,93 +1822,6 @@ void build_prescale_params(struct  dc_bias_and_scale *bias_and_scale,
 	}
 }
 
-static void mmhub_read_vm_system_aperture_settings(struct dcn10_hubp *hubp1,
-		struct vm_system_aperture_param *apt,
-		struct dce_hwseq *hws)
-{
-	PHYSICAL_ADDRESS_LOC physical_page_number;
-	uint32_t logical_addr_low;
-	uint32_t logical_addr_high;
-
-	REG_GET(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB,
-			PHYSICAL_PAGE_NUMBER_MSB, &physical_page_number.high_part);
-	REG_GET(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB,
-			PHYSICAL_PAGE_NUMBER_LSB, &physical_page_number.low_part);
-
-	REG_GET(MC_VM_SYSTEM_APERTURE_LOW_ADDR,
-			LOGICAL_ADDR, &logical_addr_low);
-
-	REG_GET(MC_VM_SYSTEM_APERTURE_HIGH_ADDR,
-			LOGICAL_ADDR, &logical_addr_high);
-
-	apt->sys_default.quad_part =  physical_page_number.quad_part << 12;
-	apt->sys_low.quad_part =  (int64_t)logical_addr_low << 18;
-	apt->sys_high.quad_part =  (int64_t)logical_addr_high << 18;
-}
-
-/* Temporary read settings, future will get values from kmd directly */
-static void mmhub_read_vm_context0_settings(struct dcn10_hubp *hubp1,
-		struct vm_context0_param *vm0,
-		struct dce_hwseq *hws)
-{
-	PHYSICAL_ADDRESS_LOC fb_base;
-	PHYSICAL_ADDRESS_LOC fb_offset;
-	uint32_t fb_base_value;
-	uint32_t fb_offset_value;
-
-	REG_GET(DCHUBBUB_SDPIF_FB_BASE, SDPIF_FB_BASE, &fb_base_value);
-	REG_GET(DCHUBBUB_SDPIF_FB_OFFSET, SDPIF_FB_OFFSET, &fb_offset_value);
-
-	REG_GET(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32,
-			PAGE_DIRECTORY_ENTRY_HI32, &vm0->pte_base.high_part);
-	REG_GET(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32,
-			PAGE_DIRECTORY_ENTRY_LO32, &vm0->pte_base.low_part);
-
-	REG_GET(VM_CONTEXT0_PAGE_TABLE_START_ADDR_HI32,
-			LOGICAL_PAGE_NUMBER_HI4, &vm0->pte_start.high_part);
-	REG_GET(VM_CONTEXT0_PAGE_TABLE_START_ADDR_LO32,
-			LOGICAL_PAGE_NUMBER_LO32, &vm0->pte_start.low_part);
-
-	REG_GET(VM_CONTEXT0_PAGE_TABLE_END_ADDR_HI32,
-			LOGICAL_PAGE_NUMBER_HI4, &vm0->pte_end.high_part);
-	REG_GET(VM_CONTEXT0_PAGE_TABLE_END_ADDR_LO32,
-			LOGICAL_PAGE_NUMBER_LO32, &vm0->pte_end.low_part);
-
-	REG_GET(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_HI32,
-			PHYSICAL_PAGE_ADDR_HI4, &vm0->fault_default.high_part);
-	REG_GET(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_LO32,
-			PHYSICAL_PAGE_ADDR_LO32, &vm0->fault_default.low_part);
-
-	/*
-	 * The values in VM_CONTEXT0_PAGE_TABLE_BASE_ADDR is in UMA space.
-	 * Therefore we need to do
-	 * DCN_VM_CONTEXT0_PAGE_TABLE_BASE_ADDR = VM_CONTEXT0_PAGE_TABLE_BASE_ADDR
-	 * - DCHUBBUB_SDPIF_FB_OFFSET + DCHUBBUB_SDPIF_FB_BASE
-	 */
-	fb_base.quad_part = (uint64_t)fb_base_value << 24;
-	fb_offset.quad_part = (uint64_t)fb_offset_value << 24;
-	vm0->pte_base.quad_part += fb_base.quad_part;
-	vm0->pte_base.quad_part -= fb_offset.quad_part;
-}
-
-static void dcn10_program_pte_vm(struct hubp *hubp,
-		enum surface_pixel_format format,
-		union dc_tiling_info *tiling_info,
-		enum dc_rotation_angle rotation,
-		struct dce_hwseq *hws)
-{
-	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
-	struct vm_system_aperture_param apt = { {{ 0 } } };
-	struct vm_context0_param vm0 = { { { 0 } } };
-
-
-	mmhub_read_vm_system_aperture_settings(hubp1, &apt, hws);
-	mmhub_read_vm_context0_settings(hubp1, &vm0, hws);
-
-	hubp->funcs->hubp_set_vm_system_aperture_settings(hubp, &apt);
-	hubp->funcs->hubp_set_vm_context0_settings(hubp, &vm0);
-}
-
 static void update_dchubp_dpp(
 	struct dc *dc,
 	struct pipe_ctx *pipe_ctx,
@@ -1865,15 +1863,6 @@ static void update_dchubp_dpp(
 
 	size.grph.surface_size = pipe_ctx->plane_res.scl_data.viewport;
 
-	if (dc->config.gpu_vm_support)
-		dcn10_program_pte_vm(
-				pipe_ctx->plane_res.hubp,
-				plane_state->format,
-				&plane_state->tiling_info,
-				plane_state->rotation,
-				hws
-				);
-
 	// program the input csc
 	dpp->funcs->dpp_setup(dpp,
 			plane_state->format,
@@ -1970,18 +1959,11 @@ static void program_all_pipe_in_tree(
 		struct pipe_ctx *cur_pipe_ctx =
 				&dc->current_state->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
 
-		dcn10_enable_plane(dc, pipe_ctx, context);
+		if (pipe_ctx->plane_state->update_flags.bits.full_update)
+			dcn10_enable_plane(dc, pipe_ctx, context);
 
-		update_dchubp_dpp(dc, pipe_ctx, context);
-
-		/* TODO: this is a hack w/a for switching from mpo to pipe split */
-		if (pipe_ctx->stream->cursor_attributes.address.quad_part != 0) {
-			struct dc_cursor_position position = { 0 };
-
-			dc_stream_set_cursor_position(pipe_ctx->stream, &position);
-			dc_stream_set_cursor_attributes(pipe_ctx->stream,
-				&pipe_ctx->stream->cursor_attributes);
-		}
+		if (pipe_ctx->plane_state->update_flags.raw != 0)
+			update_dchubp_dpp(dc, pipe_ctx, context);
 
 		if (cur_pipe_ctx->plane_state != pipe_ctx->plane_state) {
 			dc->hwss.set_input_transfer_func(pipe_ctx, pipe_ctx->plane_state);
@@ -2141,9 +2123,30 @@ static void dcn10_apply_ctx_for_surface(
 		}
 	}
 
-	if (num_planes > 0)
+	if (num_planes > 0) {
+		struct dc_stream_state *stream_for_cursor;
+
 		program_all_pipe_in_tree(dc, top_pipe_to_program, context);
 
+		for (i = 0; i < dc->res_pool->pipe_count; i++) {
+			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+			if (stream == pipe_ctx->stream) {
+				stream_for_cursor = pipe_ctx->stream;
+				break;
+			}
+		}
+
+		/* TODO: this is a hack w/a for switching from mpo to pipe split */
+		if (stream_for_cursor->cursor_attributes.address.quad_part != 0) {
+			struct dc_cursor_position position = { 0 };
+
+			dc_stream_set_cursor_position(stream_for_cursor, &position);
+			dc_stream_set_cursor_attributes(stream_for_cursor,
+				&stream_for_cursor->cursor_attributes);
+		}
+	}
+
 	tg->funcs->unlock(tg);
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {

commit 105f6ab86cc26eaa3ee9b4845d90c8b6a0571534
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Wed Nov 8 12:00:51 2017 -0500

    drm/amd/display: Fix unused variable warning
    
    'struct mpc *mpc' is not used.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 0bc1cb889992..d0f46e13efca 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -431,7 +431,6 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 		struct dc *dc)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
-	struct mpc *mpc = dc->res_pool->mpc;
 	enum dc_color_space color_space;
 	struct tg_color black_color = {0};
 	bool enableStereo    = stream->timing.timing_3d_format == TIMING_3D_FORMAT_NONE ?

commit e994340bfa57d96bfbd9e66bf802ea82b4ba56fc
Author: Arun Pandey <Arun.Pandey@amd.com>
Date:   Wed Nov 8 17:02:55 2017 +0800

    drm/amd/display: Added Opp and Diags Interface for P to I
    
    Signed-off-by: Arun Pandey <Arun.Pandey@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index ffce33fb5540..0bc1cb889992 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -431,13 +431,13 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 		struct dc *dc)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
+	struct mpc *mpc = dc->res_pool->mpc;
 	enum dc_color_space color_space;
 	struct tg_color black_color = {0};
 	bool enableStereo    = stream->timing.timing_3d_format == TIMING_3D_FORMAT_NONE ?
 			false:true;
 	bool rightEyePolarity = stream->timing.flags.RIGHT_EYE_3D_POLARITY;
 
-
 	/* by upper caller loop, pipe0 is parent pipe and be called first.
 	 * back end is set up by for pipe0. Other children pipe share back end
 	 * with pipe 0. No program is needed.

commit b8fce2c9d773e178380cfeb659ebe453a8216f4b
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Nov 7 11:01:34 2017 -0500

    drm/amd/display: Optimize programming front end
    
    In case of update type is medium, optimize squence,
    reduce programing time.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7d1821fb3607..ffce33fb5540 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -555,7 +555,7 @@ static void reset_back_end_for_pipe(
 					pipe_ctx->pipe_idx, pipe_ctx->stream_res.tg->inst);
 }
 
-void dcn10_verify_allow_pstate_change_high(struct dc *dc)
+static void dcn10_verify_allow_pstate_change_high(struct dc *dc)
 {
 	static bool should_log_hw_state; /* prevent hw state log by default */
 
@@ -1331,7 +1331,7 @@ static void dcn10_enable_per_frame_crtc_position_reset(
 	DC_SYNC_INFO("Multi-display sync is complete\n");
 }
 
-static void print_rq_dlg_ttu(
+/*static void print_rq_dlg_ttu(
 		struct dc *core_dc,
 		struct pipe_ctx *pipe_ctx)
 {
@@ -1452,13 +1452,13 @@ static void print_rq_dlg_ttu(
 			pipe_ctx->rq_regs.rq_regs_l.pte_row_height_linear
 			);
 }
+*/
 
 static void dcn10_enable_plane(
 	struct dc *dc,
 	struct pipe_ctx *pipe_ctx,
 	struct dc_state *context)
 {
-	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct dce_hwseq *hws = dc->hwseq;
 
 	if (dc->debug.sanity_checks) {
@@ -1479,6 +1479,7 @@ static void dcn10_enable_plane(
 			OPP_PIPE_CLOCK_EN, 1);
 	/*TODO: REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DPPCLK_WDIVIDER, 0x1f);*/
 
+/* TODO: enable/disable in dm as per update type.
 	if (plane_state) {
 		dm_logger_write(dc->ctx->logger, LOG_DC,
 				"Pipe:%d 0x%x: addr hi:0x%x, "
@@ -1514,6 +1515,7 @@ static void dcn10_enable_plane(
 				pipe_ctx->plane_res.scl_data.recout.y);
 		print_rq_dlg_ttu(dc, pipe_ctx);
 	}
+*/
 
 	if (dc->debug.sanity_checks) {
 		dcn10_verify_allow_pstate_change_high(dc);
@@ -1947,16 +1949,8 @@ static void program_all_pipe_in_tree(
 		struct pipe_ctx *pipe_ctx,
 		struct dc_state *context)
 {
-	unsigned int ref_clk_mhz = dc->res_pool->ref_clock_inKhz/1000;
-
 	if (pipe_ctx->top_pipe == NULL) {
 
-		/* lock otg_master_update to process all pipes associated with
-		 * this OTG. this is done only one time.
-		 */
-		/* watermark is for all pipes */
-		hubbub1_program_watermarks(dc->res_pool->hubbub, &context->bw.dcn.watermarks, ref_clk_mhz);
-
 		if (dc->debug.sanity_checks) {
 			/* pstate stuck check after watermark update */
 			dcn10_verify_allow_pstate_change_high(dc);
@@ -1979,17 +1973,6 @@ static void program_all_pipe_in_tree(
 
 		dcn10_enable_plane(dc, pipe_ctx, context);
 
-		/* temporary dcn1 wa:
-		 *   watermark update requires toggle after a/b/c/d sets are programmed
-		 *   if hubp is pg then wm value doesn't get properaged to hubp
-		 *   need to toggle after ungate to ensure wm gets to hubp.
-		 *
-		 * final solution:  we need to get SMU to do the toggle as
-		 * DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST is owned by SMU we should have
-		 * both driver and fw accessing same register
-		 */
-		hubbub1_toggle_watermark_change_req(dc->res_pool->hubbub);
-
 		update_dchubp_dpp(dc, pipe_ctx, context);
 
 		/* TODO: this is a hack w/a for switching from mpo to pipe split */
@@ -2101,6 +2084,7 @@ static void dcn10_apply_ctx_for_surface(
 	int i;
 	struct timing_generator *tg;
 	bool removed_pipe[4] = { false };
+	unsigned int ref_clk_mhz = dc->res_pool->ref_clock_inKhz/1000;
 
 	struct pipe_ctx *top_pipe_to_program =
 			find_top_pipe_for_stream(dc, context, stream);
@@ -2163,7 +2147,6 @@ static void dcn10_apply_ctx_for_surface(
 
 	tg->funcs->unlock(tg);
 
-
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *old_pipe_ctx =
 				&dc->current_state->res_ctx.pipe_ctx[i];
@@ -2172,6 +2155,19 @@ static void dcn10_apply_ctx_for_surface(
 			dcn10_disable_plane(dc, old_pipe_ctx);
 	}
 
+	if (dc->debug.sanity_checks) {
+		/* pstate stuck check after watermark update */
+		dcn10_verify_allow_pstate_change_high(dc);
+	}
+	/* watermark is for all pipes */
+	hubbub1_program_watermarks(dc->res_pool->hubbub,
+			&context->bw.dcn.watermarks, ref_clk_mhz);
+
+	if (dc->debug.sanity_checks) {
+		/* pstate stuck check after watermark update */
+		dcn10_verify_allow_pstate_change_high(dc);
+	}
+
 	dm_logger_write(dc->ctx->logger, LOG_BANDWIDTH_CALCS,
 			"\n============== Watermark parameters ==============\n"
 			"a.urgent_ns: %d \n"

commit 7f914a62c94fb29b96a88d72c9a2688db95275cf
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Nov 6 14:40:31 2017 -0500

    drm/amd/display: Apply work around for stutter.
    
    Power on one plane after disable all the planes, for
    a hw bug work around to resolve stutter efficiency issue.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index cb73d25aca4c..7d1821fb3607 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -363,11 +363,8 @@ static void undo_DEGVIDCN10_253_wa(struct dc *dc)
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct hubp *hubp = dc->res_pool->hubps[0];
-	int pwr_status = 0;
 
-	REG_GET(DOMAIN0_PG_STATUS, DOMAIN0_PGFSM_PWR_STATUS, &pwr_status);
-	/* Don't need to blank if hubp is power gated*/
-	if (pwr_status == 2)
+	if (!hws->wa_state.DEGVIDCN10_253_applied)
 		return;
 
 	hubp->funcs->set_blank(hubp, true);
@@ -378,16 +375,29 @@ static void undo_DEGVIDCN10_253_wa(struct dc *dc)
 	hubp_pg_control(hws, 0, false);
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
+
+	hws->wa_state.DEGVIDCN10_253_applied = false;
 }
 
 static void apply_DEGVIDCN10_253_wa(struct dc *dc)
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct hubp *hubp = dc->res_pool->hubps[0];
+	int i;
 
 	if (dc->debug.disable_stutter)
 		return;
 
+	if (!hws->wa.DEGVIDCN10_253)
+		return;
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		if (!dc->res_pool->hubps[i]->power_gated)
+			return;
+	}
+
+	/* all pipe power gated, apply work around to enable stutter. */
+
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 1);
 
@@ -396,6 +406,7 @@ static void apply_DEGVIDCN10_253_wa(struct dc *dc)
 			IP_REQUEST_EN, 0);
 
 	hubp->funcs->set_hubp_blank_en(hubp, false);
+	hws->wa_state.DEGVIDCN10_253_applied = true;
 }
 
 static void bios_golden_init(struct dc *dc)
@@ -592,61 +603,14 @@ static void plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	if (dc->debug.sanity_checks)
 		dcn10_verify_allow_pstate_change_high(dc);
 
-	if (pipe_ctx->top_pipe) {
-		pipe_ctx->top_pipe->bottom_pipe = NULL;
-		pipe_ctx->top_pipe = NULL;
-		pipe_ctx->stream = NULL;
-		memset(&pipe_ctx->stream_res, 0, sizeof(pipe_ctx->stream_res));
-		memset(&pipe_ctx->plane_res, 0, sizeof(pipe_ctx->plane_res));
-	}
-
-	if (pipe_ctx->bottom_pipe) {
-		pipe_ctx->bottom_pipe->top_pipe = NULL;
-		pipe_ctx->bottom_pipe = NULL;
-	}
+	pipe_ctx->stream = NULL;
+	memset(&pipe_ctx->stream_res, 0, sizeof(pipe_ctx->stream_res));
+	memset(&pipe_ctx->plane_res, 0, sizeof(pipe_ctx->plane_res));
+	pipe_ctx->top_pipe = NULL;
+	pipe_ctx->bottom_pipe = NULL;
 	pipe_ctx->plane_state = NULL;
 }
 
-/* disable HW used by plane.
- * note:  cannot disable until disconnect is complete */
-static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
-{
-	int fe_idx = pipe_ctx->pipe_idx;
-	struct dce_hwseq *hws = dc->hwseq;
-	struct hubp *hubp = dc->res_pool->hubps[fe_idx];
-	struct mpc *mpc = dc->res_pool->mpc;
-	int opp_id = hubp->opp_id;
-
-	if (opp_id == 0xf)
-		return;
-
-	mpc->funcs->wait_for_idle(mpc, hubp->mpcc_id);
-	dc->res_pool->opps[hubp->opp_id]->mpcc_disconnect_pending[hubp->mpcc_id] = false;
-	/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
-			"[debug_mpo: atomic disable finished on mpcc %d]\n",
-			fe_idx);*/
-
-	hubp->funcs->set_blank(hubp, true);
-
-	if (dc->debug.sanity_checks)
-		dcn10_verify_allow_pstate_change_high(dc);
-
-	REG_UPDATE(HUBP_CLK_CNTL[fe_idx],
-			HUBP_CLOCK_ENABLE, 0);
-	REG_UPDATE(DPP_CONTROL[fe_idx],
-			DPP_CLOCK_ENABLE, 0);
-
-	if (dc->res_pool->opps[opp_id]->mpc_tree.num_pipes == 0)
-		REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
-				OPP_PIPE_CLOCK_EN, 0);
-
-	if (dc->debug.sanity_checks)
-		dcn10_verify_allow_pstate_change_high(dc);
-}
-
-/* kill power to plane hw
- * note: cannot power down until plane is disable
- */
 static void plane_atomic_power_down(struct dc *dc, int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
@@ -665,29 +629,51 @@ static void plane_atomic_power_down(struct dc *dc, int fe_idx)
 	}
 }
 
-static void dcn10_power_down_fe(struct dc *dc, struct pipe_ctx *pipe_ctx)
+/* disable HW used by plane.
+ * note:  cannot disable until disconnect is complete
+ */
+static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	int fe_idx = pipe_ctx->pipe_idx;
-	struct timing_generator *tg = pipe_ctx->stream_res.tg;
-
-	if (tg != NULL) {
-		tg->funcs->lock(tg);
+	struct dce_hwseq *hws = dc->hwseq;
+	struct hubp *hubp = dc->res_pool->hubps[fe_idx];
+	struct mpc *mpc = dc->res_pool->mpc;
+	int opp_id = hubp->opp_id;
+	struct output_pixel_processor *opp;
 
-		plane_atomic_disconnect(dc, pipe_ctx);
+	if (opp_id != 0xf) {
+		mpc->funcs->wait_for_idle(mpc, hubp->mpcc_id);
+		opp = dc->res_pool->opps[hubp->opp_id];
+		opp->mpcc_disconnect_pending[hubp->mpcc_id] = false;
+		hubp->funcs->set_blank(hubp, true);
+	}
 
-		tg->funcs->unlock(tg);
+	REG_UPDATE(HUBP_CLK_CNTL[fe_idx],
+			HUBP_CLOCK_ENABLE, 0);
+	REG_UPDATE(DPP_CONTROL[fe_idx],
+			DPP_CLOCK_ENABLE, 0);
 
-		if (dc->debug.sanity_checks)
-			dcn10_verify_allow_pstate_change_high(dc);
+	if (opp_id != 0xf && dc->res_pool->opps[opp_id]->mpc_tree.num_pipes == 0)
+		REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
+				OPP_PIPE_CLOCK_EN, 0);
 
-		plane_atomic_disable(dc, pipe_ctx);
-	}
+	hubp->power_gated = true;
 
 	plane_atomic_power_down(dc, fe_idx);
+}
+
+static void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
+{
+	if (dc->res_pool->hubps[pipe_ctx->pipe_idx]->power_gated)
+		return;
+
+	plane_atomic_disable(dc, pipe_ctx);
+
+	apply_DEGVIDCN10_253_wa(dc);
 
 	dm_logger_write(dc->ctx->logger, LOG_DC,
-					"Reset front end %d\n",
-					fe_idx);
+					"Power down front end %d\n",
+					pipe_ctx->pipe_idx);
 }
 
 static void dcn10_init_hw(struct dc *dc)
@@ -780,8 +766,7 @@ static void dcn10_init_hw(struct dc *dc)
 		struct timing_generator *tg = dc->res_pool->timing_generators[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		plane_atomic_disable(dc, pipe_ctx);
-		plane_atomic_power_down(dc, i);
+		dcn10_disable_plane(dc, pipe_ctx);
 
 		pipe_ctx->stream_res.tg = NULL;
 		pipe_ctx->plane_res.hubp = NULL;
@@ -1468,7 +1453,7 @@ static void print_rq_dlg_ttu(
 			);
 }
 
-static void dcn10_power_on_fe(
+static void dcn10_enable_plane(
 	struct dc *dc,
 	struct pipe_ctx *pipe_ctx,
 	struct dc_state *context)
@@ -1480,6 +1465,8 @@ static void dcn10_power_on_fe(
 		dcn10_verify_allow_pstate_change_high(dc);
 	}
 
+	undo_DEGVIDCN10_253_wa(dc);
+
 	power_on_plane(dc->hwseq,
 		pipe_ctx->pipe_idx);
 
@@ -1946,6 +1933,8 @@ static void update_dchubp_dpp(
 		&plane_state->dcc,
 		plane_state->horizontal_mirror);
 
+	hubp->power_gated = false;
+
 	dc->hwss.update_plane_addr(dc, pipe_ctx);
 
 	if (is_pipe_tree_visible(pipe_ctx))
@@ -1988,7 +1977,7 @@ static void program_all_pipe_in_tree(
 		struct pipe_ctx *cur_pipe_ctx =
 				&dc->current_state->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
 
-		dcn10_power_on_fe(dc, pipe_ctx, context);
+		dcn10_enable_plane(dc, pipe_ctx, context);
 
 		/* temporary dcn1 wa:
 		 *   watermark update requires toggle after a/b/c/d sets are programmed
@@ -2063,7 +2052,6 @@ static void dcn10_pplib_apply_display_requirements(
 static void optimize_shared_resources(struct dc *dc)
 {
 	if (dc->current_state->stream_count == 0) {
-		apply_DEGVIDCN10_253_wa(dc);
 		/* S0i2 message */
 		dcn10_pplib_apply_display_requirements(dc, dc->current_state);
 	}
@@ -2074,10 +2062,6 @@ static void optimize_shared_resources(struct dc *dc)
 
 static void ready_shared_resources(struct dc *dc, struct dc_state *context)
 {
-	if (dc->current_state->stream_count == 0 &&
-			!dc->debug.disable_stutter)
-		undo_DEGVIDCN10_253_wa(dc);
-
 	/* S0i2 message */
 	if (dc->current_state->stream_count == 0 &&
 			context->stream_count != 0)
@@ -2152,7 +2136,7 @@ static void dcn10_apply_ctx_for_surface(
 			if (old_pipe_ctx->stream_res.tg == tg &&
 				old_pipe_ctx->plane_res.hubp &&
 				old_pipe_ctx->plane_res.hubp->opp_id != 0xf) {
-				dcn10_power_down_fe(dc, pipe_ctx);
+				dcn10_disable_plane(dc, pipe_ctx);
 				/*
 				 * power down fe will unlock when calling reset, need
 				 * to lock it back here. Messy, need rework.
@@ -2184,14 +2168,10 @@ static void dcn10_apply_ctx_for_surface(
 		struct pipe_ctx *old_pipe_ctx =
 				&dc->current_state->res_ctx.pipe_ctx[i];
 
-		if (removed_pipe[i]) {
-			plane_atomic_disable(dc, old_pipe_ctx);
-			if (num_planes == 0)
-				plane_atomic_power_down(dc, i);
-		}
+		if (removed_pipe[i] && num_planes == 0)
+			dcn10_disable_plane(dc, old_pipe_ctx);
 	}
 
-
 	dm_logger_write(dc->ctx->logger, LOG_BANDWIDTH_CALCS,
 			"\n============== Watermark parameters ==============\n"
 			"a.urgent_ns: %d \n"
@@ -2514,8 +2494,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.disable_stream = dce110_disable_stream,
 	.unblank_stream = dce110_unblank_stream,
 	.enable_display_power_gating = dcn10_dummy_display_power_gating,
-	.power_down_front_end = dcn10_power_down_fe,
-	.power_on_front_end = dcn10_power_on_fe,
+	.disable_plane = dcn10_disable_plane,
 	.pipe_control_lock = dcn10_pipe_control_lock,
 	.set_bandwidth = dcn10_set_bandwidth,
 	.reset_hw_ctx_wrap = reset_hw_ctx_wrap,

commit bd1be8e894e4963595a35ebeff512dc63d3ee328
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Nov 1 14:31:58 2017 -0400

    drm/amd/display: A few more color indentation changes
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c4a6ad3f7e25..cb73d25aca4c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -953,26 +953,20 @@ static bool convert_to_custom_float(
 	fmt.mantissa_bits = 12;
 	fmt.sign = false;
 
-	if (!convert_to_custom_float_format(
-		arr_points[0].x,
-		&fmt,
-		&arr_points[0].custom_float_x)) {
+	if (!convert_to_custom_float_format(arr_points[0].x, &fmt,
+					    &arr_points[0].custom_float_x)) {
 		BREAK_TO_DEBUGGER();
 		return false;
 	}
 
-	if (!convert_to_custom_float_format(
-		arr_points[0].offset,
-		&fmt,
-		&arr_points[0].custom_float_offset)) {
+	if (!convert_to_custom_float_format(arr_points[0].offset, &fmt,
+					    &arr_points[0].custom_float_offset)) {
 		BREAK_TO_DEBUGGER();
 		return false;
 	}
 
-	if (!convert_to_custom_float_format(
-		arr_points[0].slope,
-		&fmt,
-		&arr_points[0].custom_float_slope)) {
+	if (!convert_to_custom_float_format(arr_points[0].slope, &fmt,
+					    &arr_points[0].custom_float_slope)) {
 		BREAK_TO_DEBUGGER();
 		return false;
 	}
@@ -980,26 +974,20 @@ static bool convert_to_custom_float(
 	fmt.mantissa_bits = 10;
 	fmt.sign = false;
 
-	if (!convert_to_custom_float_format(
-		arr_points[1].x,
-		&fmt,
-		&arr_points[1].custom_float_x)) {
+	if (!convert_to_custom_float_format(arr_points[1].x, &fmt,
+					    &arr_points[1].custom_float_x)) {
 		BREAK_TO_DEBUGGER();
 		return false;
 	}
 
-	if (!convert_to_custom_float_format(
-		arr_points[1].y,
-		&fmt,
-		&arr_points[1].custom_float_y)) {
+	if (!convert_to_custom_float_format(arr_points[1].y, &fmt,
+					    &arr_points[1].custom_float_y)) {
 		BREAK_TO_DEBUGGER();
 		return false;
 	}
 
-	if (!convert_to_custom_float_format(
-		arr_points[1].slope,
-		&fmt,
-		&arr_points[1].custom_float_slope)) {
+	if (!convert_to_custom_float_format(arr_points[1].slope, &fmt,
+					    &arr_points[1].custom_float_slope)) {
 		BREAK_TO_DEBUGGER();
 		return false;
 	}
@@ -1008,50 +996,38 @@ static bool convert_to_custom_float(
 	fmt.sign = true;
 
 	while (i != hw_points_num) {
-		if (!convert_to_custom_float_format(
-			rgb->red,
-			&fmt,
-			&rgb->red_reg)) {
+		if (!convert_to_custom_float_format(rgb->red, &fmt,
+						    &rgb->red_reg)) {
 			BREAK_TO_DEBUGGER();
 			return false;
 		}
 
-		if (!convert_to_custom_float_format(
-			rgb->green,
-			&fmt,
-			&rgb->green_reg)) {
+		if (!convert_to_custom_float_format(rgb->green, &fmt,
+						    &rgb->green_reg)) {
 			BREAK_TO_DEBUGGER();
 			return false;
 		}
 
-		if (!convert_to_custom_float_format(
-			rgb->blue,
-			&fmt,
-			&rgb->blue_reg)) {
+		if (!convert_to_custom_float_format(rgb->blue, &fmt,
+						    &rgb->blue_reg)) {
 			BREAK_TO_DEBUGGER();
 			return false;
 		}
 
-		if (!convert_to_custom_float_format(
-			rgb->delta_red,
-			&fmt,
-			&rgb->delta_red_reg)) {
+		if (!convert_to_custom_float_format(rgb->delta_red, &fmt,
+						    &rgb->delta_red_reg)) {
 			BREAK_TO_DEBUGGER();
 			return false;
 		}
 
-		if (!convert_to_custom_float_format(
-			rgb->delta_green,
-			&fmt,
-			&rgb->delta_green_reg)) {
+		if (!convert_to_custom_float_format(rgb->delta_green, &fmt,
+						    &rgb->delta_green_reg)) {
 			BREAK_TO_DEBUGGER();
 			return false;
 		}
 
-		if (!convert_to_custom_float_format(
-			rgb->delta_blue,
-			&fmt,
-			&rgb->delta_blue_reg)) {
+		if (!convert_to_custom_float_format(rgb->delta_blue, &fmt,
+						    &rgb->delta_blue_reg)) {
 			BREAK_TO_DEBUGGER();
 			return false;
 		}
@@ -1066,8 +1042,9 @@ static bool convert_to_custom_float(
 #define MAX_LOW_POINT      25
 #define NUMBER_SEGMENTS    32
 
-static bool dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func
-		*output_tf, struct pwl_params *regamma_params)
+static bool
+dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func *output_tf,
+				     struct pwl_params *regamma_params)
 {
 	struct curve_points *arr_points;
 	struct pwl_result_data *rgb_resulted;
@@ -1083,8 +1060,7 @@ static bool dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func
 	int32_t i;
 	uint32_t j, k, seg_distr[MAX_REGIONS_NUMBER], increment, start_index, hw_points;
 
-	if (output_tf == NULL || regamma_params == NULL ||
-			output_tf->type == TF_TYPE_BYPASS)
+	if (output_tf == NULL || regamma_params == NULL || output_tf->type == TF_TYPE_BYPASS)
 		return false;
 
 	arr_points = regamma_params->arr_points;
@@ -1147,17 +1123,14 @@ static bool dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func
 
 	/* last point */
 	start_index = (segment_end + MAX_LOW_POINT) * NUMBER_SEGMENTS;
-	rgb_resulted[hw_points - 1].red =
-			output_tf->tf_pts.red[start_index];
-	rgb_resulted[hw_points - 1].green =
-			output_tf->tf_pts.green[start_index];
-	rgb_resulted[hw_points - 1].blue =
-			output_tf->tf_pts.blue[start_index];
+	rgb_resulted[hw_points - 1].red = output_tf->tf_pts.red[start_index];
+	rgb_resulted[hw_points - 1].green = output_tf->tf_pts.green[start_index];
+	rgb_resulted[hw_points - 1].blue = output_tf->tf_pts.blue[start_index];
 
 	arr_points[0].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
-			dal_fixed31_32_from_int(segment_start));
+					     dal_fixed31_32_from_int(segment_start));
 	arr_points[1].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
-			dal_fixed31_32_from_int(segment_end));
+					     dal_fixed31_32_from_int(segment_end));
 
 	y_r = rgb_resulted[0].red;
 	y_g = rgb_resulted[0].green;
@@ -1166,9 +1139,7 @@ static bool dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func
 	y1_min = dal_fixed31_32_min(y_r, dal_fixed31_32_min(y_g, y_b));
 
 	arr_points[0].y = y1_min;
-	arr_points[0].slope = dal_fixed31_32_div(
-					arr_points[0].y,
-					arr_points[0].x);
+	arr_points[0].slope = dal_fixed31_32_div(arr_points[0].y, arr_points[0].x);
 	y_r = rgb_resulted[hw_points - 1].red;
 	y_g = rgb_resulted[hw_points - 1].green;
 	y_b = rgb_resulted[hw_points - 1].blue;
@@ -1202,15 +1173,13 @@ static bool dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func
 			regamma_params->arr_curve_points[k].segments_num =
 					seg_distr[k];
 			regamma_params->arr_curve_points[i].offset =
-					regamma_params->arr_curve_points[k].
-					offset + (1 << seg_distr[k]);
+					regamma_params->arr_curve_points[k].offset + (1 << seg_distr[k]);
 		}
 		i++;
 	}
 
 	if (seg_distr[k] != -1)
-		regamma_params->arr_curve_points[k].segments_num =
-				seg_distr[k];
+		regamma_params->arr_curve_points[k].segments_num = seg_distr[k];
 
 	rgb = rgb_resulted;
 	rgb_plus_1 = rgb_resulted + 1;
@@ -1225,15 +1194,9 @@ static bool dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func
 		if (dal_fixed31_32_lt(rgb_plus_1->blue, rgb->blue))
 			rgb_plus_1->blue = rgb->blue;
 
-		rgb->delta_red = dal_fixed31_32_sub(
-			rgb_plus_1->red,
-			rgb->red);
-		rgb->delta_green = dal_fixed31_32_sub(
-			rgb_plus_1->green,
-			rgb->green);
-		rgb->delta_blue = dal_fixed31_32_sub(
-			rgb_plus_1->blue,
-			rgb->blue);
+		rgb->delta_red = dal_fixed31_32_sub(rgb_plus_1->red, rgb->red);
+		rgb->delta_green = dal_fixed31_32_sub(rgb_plus_1->green, rgb->green);
+		rgb->delta_blue = dal_fixed31_32_sub(rgb_plus_1->blue, rgb->blue);
 
 		++rgb_plus_1;
 		++rgb;

commit 97110c98a0fa2091190dc3068734ef9f1c12b588
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Oct 31 14:41:41 2017 -0400

    drm/amd/display: Remove extra arr_points element
    
    arr_points[1] and [2] were duplicated. Remove the extra
    one. If we ever need more points we can add them but the
    current state of affairs is confusing.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 666c6c0f882a..c4a6ad3f7e25 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1158,8 +1158,6 @@ static bool dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func
 			dal_fixed31_32_from_int(segment_start));
 	arr_points[1].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
 			dal_fixed31_32_from_int(segment_end));
-	arr_points[2].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
-			dal_fixed31_32_from_int(segment_end));
 
 	y_r = rgb_resulted[0].red;
 	y_g = rgb_resulted[0].green;
@@ -1181,10 +1179,8 @@ static bool dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func
 	y3_max = dal_fixed31_32_max(y_r, dal_fixed31_32_max(y_g, y_b));
 
 	arr_points[1].y = y3_max;
-	arr_points[2].y = y3_max;
 
 	arr_points[1].slope = dal_fixed31_32_zero;
-	arr_points[2].slope = dal_fixed31_32_zero;
 
 	if (output_tf->tf == TRANSFER_FUNCTION_PQ) {
 		/* for PQ, we want to have a straight line from last HW X point,
@@ -1196,9 +1192,6 @@ static bool dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func
 		arr_points[1].slope = dal_fixed31_32_div(
 			dal_fixed31_32_sub(dal_fixed31_32_one, arr_points[1].y),
 			dal_fixed31_32_sub(end_value, arr_points[1].x));
-		arr_points[2].slope = dal_fixed31_32_div(
-			dal_fixed31_32_sub(dal_fixed31_32_one, arr_points[1].y),
-			dal_fixed31_32_sub(end_value, arr_points[1].x));
 	}
 
 	regamma_params->hw_points_num = hw_points;

commit 35b71a3f6e5f81fe494e0ed8e82deb640ecfc6ec
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Fri Nov 3 16:21:37 2017 -0400

    drm/amd/display: always call set output tf
    
    Temporary solution to fix gamma adjustment not
    working.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 73e7afb360b1..666c6c0f882a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2058,8 +2058,14 @@ static void program_all_pipe_in_tree(
 
 		if (cur_pipe_ctx->plane_state != pipe_ctx->plane_state) {
 			dc->hwss.set_input_transfer_func(pipe_ctx, pipe_ctx->plane_state);
-			dc->hwss.set_output_transfer_func(pipe_ctx, pipe_ctx->stream);
 		}
+
+		/*
+		 * TODO: This can be further optimized/cleaned up
+		 * Always call this for now since it does memcmp inside before
+		 * doing heavy calculation and programming
+		 */
+		dc->hwss.set_output_transfer_func(pipe_ctx, pipe_ctx->stream);
 	}
 
 	if (dc->debug.sanity_checks) {

commit 631aaa0af4be3de8f0184095075650afaa023334
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Tue Oct 31 15:55:15 2017 -0400

    drm/amd/display: send display_count msg so SMU can enter S0i2
    
    SMU can future lower voltages in long idle case when all display is off.
    
    If all display output is turned off via DPMS, send display_count = 0
    after all output are turned off.
    
    otherwise send display_count msg before turning on display to make sure
    SMU exit S0i2 state.  before is not neccessary as we are out of S0i2
    when driver execute code, but send message before anyways for correctness.
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 5d1fb1c297a3..73e7afb360b1 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2567,6 +2567,8 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.wait_for_mpcc_disconnect = dcn10_wait_for_mpcc_disconnect,
 	.ready_shared_resources = ready_shared_resources,
 	.optimize_shared_resources = optimize_shared_resources,
+	.pplib_apply_display_requirements =
+			dcn10_pplib_apply_display_requirements,
 	.edp_backlight_control = hwss_edp_backlight_control,
 	.edp_power_control = hwss_edp_power_control
 };

commit 0af4096db9ec6a7b12475bf8d21ee5464722c7a2
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Nov 2 13:24:20 2017 -0400

    drm/amd/display: Modified front end initiail in init_hw
    
    Optimized front end initial sequence, reset MPC module
    properly.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index bd30d49e574a..5d1fb1c297a3 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -616,10 +616,6 @@ static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	struct hubp *hubp = dc->res_pool->hubps[fe_idx];
 	struct mpc *mpc = dc->res_pool->mpc;
 	int opp_id = hubp->opp_id;
-	struct timing_generator *tg = pipe_ctx->stream_res.tg;
-
-	if (tg == NULL)
-		return;
 
 	if (opp_id == 0xf)
 		return;
@@ -700,6 +696,8 @@ static void dcn10_init_hw(struct dc *dc)
 	struct abm *abm = dc->res_pool->abm;
 	struct dmcu *dmcu = dc->res_pool->dmcu;
 	struct dce_hwseq *hws = dc->hwseq;
+	struct dc_bios *dcb = dc->ctx->dc_bios;
+	struct dc_state  *context = dc->current_state;
 
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
 		REG_WRITE(REFCLK_CNTL, 0);
@@ -720,9 +718,10 @@ static void dcn10_init_hw(struct dc *dc)
 	}
 	/* end of FPGA. Below if real ASIC */
 
-	bios_golden_init(dc);
-
-	disable_vga(dc->hwseq);
+	if (!dcb->funcs->is_accelerated_mode(dcb)) {
+		bios_golden_init(dc);
+		disable_vga(dc->hwseq);
+	}
 
 	for (i = 0; i < dc->link_count; i++) {
 		/* Power up AND update implementation according to the
@@ -738,22 +737,55 @@ static void dcn10_init_hw(struct dc *dc)
 	}
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct dpp *dpp = dc->res_pool->dpps[i];
 		struct timing_generator *tg = dc->res_pool->timing_generators[i];
 
-		dpp->funcs->dpp_reset(dpp);
-		dc->res_pool->mpc->funcs->remove(
-				dc->res_pool->mpc, &(dc->res_pool->opps[i]->mpc_tree),
-				dc->res_pool->opps[i]->inst, i);
+		if (tg->funcs->is_tg_enabled(tg))
+			tg->funcs->lock(tg);
+	}
 
-		/* Blank controller using driver code instead of
-		 * command table.
-		 */
-		tg->funcs->set_blank(tg, true);
-		hwss_wait_for_blank_complete(tg);
+	/* Blank controller using driver code instead of
+	 * command table.
+	 */
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct timing_generator *tg = dc->res_pool->timing_generators[i];
+
+		if (tg->funcs->is_tg_enabled(tg)) {
+			tg->funcs->set_blank(tg, true);
+			hwss_wait_for_blank_complete(tg);
+		}
+	}
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct timing_generator *tg = dc->res_pool->timing_generators[i];
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		pipe_ctx->stream_res.tg = tg;
+		pipe_ctx->pipe_idx = i;
+		pipe_ctx->plane_res.hubp = dc->res_pool->hubps[i];
+		pipe_ctx->plane_res.hubp->mpcc_id = i;
+		pipe_ctx->plane_res.hubp->opp_id =
+				dc->res_pool->mpc->funcs->get_opp_id(dc->res_pool->mpc, i);
+
+		plane_atomic_disconnect(dc, pipe_ctx);
+	}
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct timing_generator *tg = dc->res_pool->timing_generators[i];
 
+		if (tg->funcs->is_tg_enabled(tg))
+			tg->funcs->unlock(tg);
+	}
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct timing_generator *tg = dc->res_pool->timing_generators[i];
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		plane_atomic_disable(dc, pipe_ctx);
 		plane_atomic_power_down(dc, i);
 
+		pipe_ctx->stream_res.tg = NULL;
+		pipe_ctx->plane_res.hubp = NULL;
+
 		tg->funcs->tg_init(tg);
 	}
 

commit 33af27bb114ff886c151d1c5a52e40b1cfbc4053
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Oct 31 18:05:31 2017 -0400

    drm/amd/display: remove unnecessary waits in dcn10
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 26452b6b38dd..bd30d49e574a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -565,8 +565,6 @@ static void plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	struct mpc *mpc = dc->res_pool->mpc;
 	int opp_id, z_idx;
 	int mpcc_id = -1;
-	struct timing_generator *tg = pipe_ctx->stream_res.tg;
-	struct dce_hwseq *hws = dc->hwseq;
 
 	/* look at tree rather than mi here to know if we already reset */
 	for (opp_id = 0; opp_id < dc->res_pool->pipe_count; opp_id++) {
@@ -586,7 +584,7 @@ static void plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 		return;
 
 	mpc->funcs->remove(mpc, &(dc->res_pool->opps[opp_id]->mpc_tree),
-					   dc->res_pool->opps[opp_id]->inst, fe_idx);
+					dc->res_pool->opps[opp_id]->inst, fe_idx);
 
 	if (hubp->funcs->hubp_disconnect)
 		hubp->funcs->hubp_disconnect(hubp);
@@ -607,10 +605,6 @@ static void plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 		pipe_ctx->bottom_pipe = NULL;
 	}
 	pipe_ctx->plane_state = NULL;
-
-	/* TODO: Move to tg. */
-	REG_UPDATE(OTG_GLOBAL_SYNC_STATUS[tg->inst],
-			VUPDATE_NO_LOCK_EVENT_CLEAR, 1);
 }
 
 /* disable HW used by plane.
@@ -630,11 +624,6 @@ static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 	if (opp_id == 0xf)
 		return;
 
-	if (tg->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
-		REG_WAIT(OTG_GLOBAL_SYNC_STATUS[tg->inst],
-				VUPDATE_NO_LOCK_EVENT_OCCURRED, 1,
-				1, 100000);
-
 	mpc->funcs->wait_for_idle(mpc, hubp->mpcc_id);
 	dc->res_pool->opps[hubp->opp_id]->mpcc_disconnect_pending[hubp->mpcc_id] = false;
 	/*dm_logger_write(dc->ctx->logger, LOG_ERROR,

commit 3e64668d7926854b084f89831ecbe4ae75600db6
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Nov 2 10:52:09 2017 -0400

    drm/amd/display: fix regamma programming
    
    When new coefficients match cached we would skip setting regamma mode
    Also, when doing a stream update we would program regamma for all pipes,
    even thos that are not yet powered on. This resulted in never setting
    regamma since we would cache before the pipe is powered.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 99f478c52421..26452b6b38dd 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -820,7 +820,6 @@ static void reset_hw_ctx_wrap(
 			struct clock_source *old_clk = pipe_ctx_old->clock_source;
 
 			reset_back_end_for_pipe(dc, pipe_ctx_old, dc->current_state);
-
 			if (old_clk)
 				old_clk->funcs->cs_power_down(old_clk);
 		}

commit a6114e854c55c928b9b8bcf7014eb205bd112c68
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Oct 31 16:27:59 2017 -0400

    drm/amd/display: Fix some more color indentations
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 1c536884c080..99f478c52421 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -874,8 +874,8 @@ static void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_c
 		pipe_ctx->plane_state->address.grph_stereo.left_addr = addr;
 }
 
-static bool dcn10_set_input_transfer_func(
-	struct pipe_ctx *pipe_ctx, const struct dc_plane_state *plane_state)
+static bool dcn10_set_input_transfer_func(struct pipe_ctx *pipe_ctx,
+					  const struct dc_plane_state *plane_state)
 {
 	struct dpp *dpp_base = pipe_ctx->plane_res.dpp;
 	const struct dc_transfer_func *tf = NULL;
@@ -888,28 +888,22 @@ static bool dcn10_set_input_transfer_func(
 		tf = plane_state->in_transfer_func;
 
 	if (plane_state->gamma_correction && dce_use_lut(plane_state))
-		dpp_base->funcs->dpp_program_input_lut(dpp_base,
-				plane_state->gamma_correction);
+		dpp_base->funcs->dpp_program_input_lut(dpp_base, plane_state->gamma_correction);
 
 	if (tf == NULL)
 		dpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);
 	else if (tf->type == TF_TYPE_PREDEFINED) {
 		switch (tf->tf) {
 		case TRANSFER_FUNCTION_SRGB:
-			dpp_base->funcs->dpp_set_degamma(dpp_base,
-					IPP_DEGAMMA_MODE_HW_sRGB);
+			dpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_HW_sRGB);
 			break;
 		case TRANSFER_FUNCTION_BT709:
-			dpp_base->funcs->dpp_set_degamma(dpp_base,
-					IPP_DEGAMMA_MODE_HW_xvYCC);
+			dpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_HW_xvYCC);
 			break;
 		case TRANSFER_FUNCTION_LINEAR:
-			dpp_base->funcs->dpp_set_degamma(dpp_base,
-					IPP_DEGAMMA_MODE_BYPASS);
+			dpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);
 			break;
 		case TRANSFER_FUNCTION_PQ:
-			result = false;
-			break;
 		default:
 			result = false;
 			break;
@@ -1238,9 +1232,9 @@ static bool dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func
 	return true;
 }
 
-static bool dcn10_set_output_transfer_func(
-	struct pipe_ctx *pipe_ctx,
-	const struct dc_stream_state *stream)
+static bool
+dcn10_set_output_transfer_func(struct pipe_ctx *pipe_ctx,
+			       const struct dc_stream_state *stream)
 {
 	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 
@@ -1250,17 +1244,13 @@ static bool dcn10_set_output_transfer_func(
 	dpp->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
 
 	if (stream->out_transfer_func &&
-		stream->out_transfer_func->type ==
-			TF_TYPE_PREDEFINED &&
-		stream->out_transfer_func->tf ==
-			TRANSFER_FUNCTION_SRGB) {
+	    stream->out_transfer_func->type == TF_TYPE_PREDEFINED &&
+	    stream->out_transfer_func->tf == TRANSFER_FUNCTION_SRGB)
 		dpp->funcs->dpp_program_regamma_pwl(dpp, NULL, OPP_REGAMMA_SRGB);
-	} else if (dcn10_translate_regamma_to_hw_format(
-				stream->out_transfer_func, &dpp->regamma_params)) {
-			dpp->funcs->dpp_program_regamma_pwl(dpp, &dpp->regamma_params, OPP_REGAMMA_USER);
-	} else {
+	else if (dcn10_translate_regamma_to_hw_format(stream->out_transfer_func, &dpp->regamma_params))
+		dpp->funcs->dpp_program_regamma_pwl(dpp, &dpp->regamma_params, OPP_REGAMMA_USER);
+	else
 		dpp->funcs->dpp_program_regamma_pwl(dpp, NULL, OPP_REGAMMA_BYPASS);
-	}
 
 	return true;
 }
@@ -2047,10 +2037,8 @@ static void program_all_pipe_in_tree(
 		}
 
 		if (cur_pipe_ctx->plane_state != pipe_ctx->plane_state) {
-			dc->hwss.set_input_transfer_func(
-					pipe_ctx, pipe_ctx->plane_state);
-			dc->hwss.set_output_transfer_func(
-					pipe_ctx, pipe_ctx->stream);
+			dc->hwss.set_input_transfer_func(pipe_ctx, pipe_ctx->plane_state);
+			dc->hwss.set_output_transfer_func(pipe_ctx, pipe_ctx->stream);
 		}
 	}
 

commit e6c258cb4e6fbc7500c493df22f52e1046c575b0
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Oct 30 17:32:14 2017 -0400

    drm/amd/display: Refactor disable front end pipes.
    
    There are different code to disable front end, it is
    difficult to debug and adding new process.
    This refactor makes all disable front end call the same
    functions.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 680aabda3277..1c536884c080 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -558,13 +558,15 @@ void dcn10_verify_allow_pstate_change_high(struct dc *dc)
 }
 
 /* trigger HW to start disconnect plane from stream on the next vsync */
-static void plane_atomic_disconnect(struct dc *dc,
-		int fe_idx)
+static void plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
+	int fe_idx = pipe_ctx->pipe_idx;
 	struct hubp *hubp = dc->res_pool->hubps[fe_idx];
 	struct mpc *mpc = dc->res_pool->mpc;
 	int opp_id, z_idx;
 	int mpcc_id = -1;
+	struct timing_generator *tg = pipe_ctx->stream_res.tg;
+	struct dce_hwseq *hws = dc->hwseq;
 
 	/* look at tree rather than mi here to know if we already reset */
 	for (opp_id = 0; opp_id < dc->res_pool->pipe_count; opp_id++) {
@@ -583,29 +585,56 @@ static void plane_atomic_disconnect(struct dc *dc,
 	if (opp_id == dc->res_pool->pipe_count)
 		return;
 
-	if (dc->debug.sanity_checks)
-		dcn10_verify_allow_pstate_change_high(dc);
-	hubp->funcs->dcc_control(hubp, false, false);
+	mpc->funcs->remove(mpc, &(dc->res_pool->opps[opp_id]->mpc_tree),
+					   dc->res_pool->opps[opp_id]->inst, fe_idx);
+
+	if (hubp->funcs->hubp_disconnect)
+		hubp->funcs->hubp_disconnect(hubp);
+
 	if (dc->debug.sanity_checks)
 		dcn10_verify_allow_pstate_change_high(dc);
 
-	mpc->funcs->remove(mpc, &(dc->res_pool->opps[opp_id]->mpc_tree),
-			dc->res_pool->opps[opp_id]->inst, fe_idx);
+	if (pipe_ctx->top_pipe) {
+		pipe_ctx->top_pipe->bottom_pipe = NULL;
+		pipe_ctx->top_pipe = NULL;
+		pipe_ctx->stream = NULL;
+		memset(&pipe_ctx->stream_res, 0, sizeof(pipe_ctx->stream_res));
+		memset(&pipe_ctx->plane_res, 0, sizeof(pipe_ctx->plane_res));
+	}
+
+	if (pipe_ctx->bottom_pipe) {
+		pipe_ctx->bottom_pipe->top_pipe = NULL;
+		pipe_ctx->bottom_pipe = NULL;
+	}
+	pipe_ctx->plane_state = NULL;
+
+	/* TODO: Move to tg. */
+	REG_UPDATE(OTG_GLOBAL_SYNC_STATUS[tg->inst],
+			VUPDATE_NO_LOCK_EVENT_CLEAR, 1);
 }
 
 /* disable HW used by plane.
  * note:  cannot disable until disconnect is complete */
-static void plane_atomic_disable(struct dc *dc,
-		int fe_idx)
+static void plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
+	int fe_idx = pipe_ctx->pipe_idx;
 	struct dce_hwseq *hws = dc->hwseq;
 	struct hubp *hubp = dc->res_pool->hubps[fe_idx];
 	struct mpc *mpc = dc->res_pool->mpc;
 	int opp_id = hubp->opp_id;
+	struct timing_generator *tg = pipe_ctx->stream_res.tg;
+
+	if (tg == NULL)
+		return;
 
 	if (opp_id == 0xf)
 		return;
 
+	if (tg->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
+		REG_WAIT(OTG_GLOBAL_SYNC_STATUS[tg->inst],
+				VUPDATE_NO_LOCK_EVENT_OCCURRED, 1,
+				1, 100000);
+
 	mpc->funcs->wait_for_idle(mpc, hubp->mpcc_id);
 	dc->res_pool->opps[hubp->opp_id]->mpcc_disconnect_pending[hubp->mpcc_id] = false;
 	/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
@@ -630,62 +659,52 @@ static void plane_atomic_disable(struct dc *dc,
 		dcn10_verify_allow_pstate_change_high(dc);
 }
 
-static void reset_front_end(
-		struct dc *dc,
-		int fe_idx)
+/* kill power to plane hw
+ * note: cannot power down until plane is disable
+ */
+static void plane_atomic_power_down(struct dc *dc, int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
-	struct timing_generator *tg;
-	int opp_id = dc->res_pool->hubps[fe_idx]->opp_id;
+	struct dpp *dpp = dc->res_pool->dpps[fe_idx];
 
-	/*Already reset*/
-	if (opp_id == 0xf)
-		return;
+	if (REG(DC_IP_REQUEST_CNTL)) {
+		REG_SET(DC_IP_REQUEST_CNTL, 0,
+				IP_REQUEST_EN, 1);
+		dpp_pg_control(hws, fe_idx, false);
+		hubp_pg_control(hws, fe_idx, false);
+		dpp->funcs->dpp_reset(dpp);
+		REG_SET(DC_IP_REQUEST_CNTL, 0,
+				IP_REQUEST_EN, 0);
+		dm_logger_write(dc->ctx->logger, LOG_DEBUG,
+				"Power gated front end %d\n", fe_idx);
+	}
+}
 
-	tg = dc->res_pool->timing_generators[opp_id];
-	tg->funcs->lock(tg);
+static void dcn10_power_down_fe(struct dc *dc, struct pipe_ctx *pipe_ctx)
+{
+	int fe_idx = pipe_ctx->pipe_idx;
+	struct timing_generator *tg = pipe_ctx->stream_res.tg;
 
-	plane_atomic_disconnect(dc, fe_idx);
+	if (tg != NULL) {
+		tg->funcs->lock(tg);
 
-	REG_UPDATE(OTG_GLOBAL_SYNC_STATUS[tg->inst], VUPDATE_NO_LOCK_EVENT_CLEAR, 1);
-	tg->funcs->unlock(tg);
+		plane_atomic_disconnect(dc, pipe_ctx);
 
-	if (dc->debug.sanity_checks)
-		dcn10_verify_allow_pstate_change_high(dc);
+		tg->funcs->unlock(tg);
 
-	if (tg->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
-		REG_WAIT(OTG_GLOBAL_SYNC_STATUS[tg->inst],
-				VUPDATE_NO_LOCK_EVENT_OCCURRED, 1,
-				1, 100000);
+		if (dc->debug.sanity_checks)
+			dcn10_verify_allow_pstate_change_high(dc);
 
-	plane_atomic_disable(dc, fe_idx);
+		plane_atomic_disable(dc, pipe_ctx);
+	}
+
+	plane_atomic_power_down(dc, fe_idx);
 
 	dm_logger_write(dc->ctx->logger, LOG_DC,
 					"Reset front end %d\n",
 					fe_idx);
 }
 
-static void dcn10_power_down_fe(struct dc *dc, int fe_idx)
-{
-	struct dce_hwseq *hws = dc->hwseq;
-	struct dpp *dpp = dc->res_pool->dpps[fe_idx];
-
-	reset_front_end(dc, fe_idx);
-
-	REG_SET(DC_IP_REQUEST_CNTL, 0,
-			IP_REQUEST_EN, 1);
-	dpp_pg_control(hws, fe_idx, false);
-	hubp_pg_control(hws, fe_idx, false);
-	dpp->funcs->dpp_reset(dpp);
-	REG_SET(DC_IP_REQUEST_CNTL, 0,
-			IP_REQUEST_EN, 0);
-	dm_logger_write(dc->ctx->logger, LOG_DEBUG,
-			"Power gated front end %d\n", fe_idx);
-
-	if (dc->debug.sanity_checks)
-		dcn10_verify_allow_pstate_change_high(dc);
-}
-
 static void dcn10_init_hw(struct dc *dc)
 {
 	int i;
@@ -744,7 +763,7 @@ static void dcn10_init_hw(struct dc *dc)
 		tg->funcs->set_blank(tg, true);
 		hwss_wait_for_blank_complete(tg);
 
-		dcn10_power_down_fe(dc, i);
+		plane_atomic_power_down(dc, i);
 
 		tg->funcs->tg_init(tg);
 	}
@@ -1988,8 +2007,6 @@ static void program_all_pipe_in_tree(
 			dcn10_verify_allow_pstate_change_high(dc);
 		}
 
-		pipe_ctx->stream_res.tg->funcs->lock(pipe_ctx->stream_res.tg);
-
 		pipe_ctx->stream_res.tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
 		pipe_ctx->stream_res.tg->dlg_otg_param.vstartup_start = pipe_ctx->pipe_dlg_param.vstartup_start;
 		pipe_ctx->stream_res.tg->dlg_otg_param.vupdate_offset = pipe_ctx->pipe_dlg_param.vupdate_offset;
@@ -2097,62 +2114,75 @@ static void ready_shared_resources(struct dc *dc, struct dc_state *context)
 		dcn10_pplib_apply_display_requirements(dc, context);
 }
 
+static struct pipe_ctx *find_top_pipe_for_stream(
+		struct dc *dc,
+		struct dc_state *context,
+		const struct dc_stream_state *stream)
+{
+	int i;
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *old_pipe_ctx =
+				&dc->current_state->res_ctx.pipe_ctx[i];
+
+		if (!pipe_ctx->plane_state && !old_pipe_ctx->plane_state)
+			continue;
+
+		if (pipe_ctx->stream != stream)
+			continue;
+
+		if (!pipe_ctx->top_pipe)
+			return pipe_ctx;
+	}
+	return NULL;
+}
+
 static void dcn10_apply_ctx_for_surface(
 		struct dc *dc,
 		const struct dc_stream_state *stream,
 		int num_planes,
 		struct dc_state *context)
 {
-	int i, be_idx;
+	int i;
+	struct timing_generator *tg;
+	bool removed_pipe[4] = { false };
+
+	struct pipe_ctx *top_pipe_to_program =
+			find_top_pipe_for_stream(dc, context, stream);
+
+	if (!top_pipe_to_program)
+		return;
+
+	tg = top_pipe_to_program->stream_res.tg;
 
 	if (dc->debug.sanity_checks)
 		dcn10_verify_allow_pstate_change_high(dc);
 
-	be_idx = -1;
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		if (stream == context->res_ctx.pipe_ctx[i].stream) {
-			be_idx = context->res_ctx.pipe_ctx[i].stream_res.tg->inst;
-			break;
-		}
-	}
-
-	ASSERT(be_idx != -1);
+	tg->funcs->lock(tg);
 
 	if (num_planes == 0) {
-		for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
-			struct pipe_ctx *old_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
 
-			if (old_pipe_ctx->stream_res.tg && old_pipe_ctx->stream_res.tg->inst == be_idx) {
-				old_pipe_ctx->stream_res.tg->funcs->set_blank(old_pipe_ctx->stream_res.tg, true);
-				dcn10_power_down_fe(dc, old_pipe_ctx->pipe_idx);
-			}
-		}
-		return;
+		/* OTG blank before remove all front end */
+		tg->funcs->set_blank(tg, true);
 	}
 
-	/* reset unused mpcc */
+	/* Disconnect unused mpcc */
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *old_pipe_ctx =
 				&dc->current_state->res_ctx.pipe_ctx[i];
-		struct hubp *hubp = dc->res_pool->hubps[i];
-
-		if (!pipe_ctx->plane_state && !old_pipe_ctx->plane_state)
-			continue;
-
-		if (pipe_ctx->stream_res.tg &&
-			pipe_ctx->stream_res.tg->inst == be_idx &&
-			!pipe_ctx->top_pipe)
-			pipe_ctx->stream_res.tg->funcs->lock(pipe_ctx->stream_res.tg);
-
 		/*
 		 * Powergate reused pipes that are not powergated
 		 * fairly hacky right now, using opp_id as indicator
+		 * TODO: After move dc_post to dc_update, this will
+		 * be removed.
 		 */
-
 		if (pipe_ctx->plane_state && !old_pipe_ctx->plane_state) {
-			if (pipe_ctx->plane_res.hubp->opp_id != 0xf && pipe_ctx->stream_res.tg->inst == be_idx) {
-				dcn10_power_down_fe(dc, pipe_ctx->pipe_idx);
+			if (old_pipe_ctx->stream_res.tg == tg &&
+				old_pipe_ctx->plane_res.hubp &&
+				old_pipe_ctx->plane_res.hubp->opp_id != 0xf) {
+				dcn10_power_down_fe(dc, pipe_ctx);
 				/*
 				 * power down fe will unlock when calling reset, need
 				 * to lock it back here. Messy, need rework.
@@ -2161,39 +2191,12 @@ static void dcn10_apply_ctx_for_surface(
 			}
 		}
 
+		if (!pipe_ctx->plane_state &&
+			old_pipe_ctx->plane_state &&
+			old_pipe_ctx->stream_res.tg == tg) {
 
-		if ((!pipe_ctx->plane_state && old_pipe_ctx->plane_state)
-				|| (!pipe_ctx->stream && old_pipe_ctx->stream)) {
-			if (old_pipe_ctx->stream_res.tg->inst != be_idx)
-				continue;
-
-			if (!old_pipe_ctx->top_pipe) {
-				ASSERT(0);
-				continue;
-			}
-
-			/* reset mpc */
-			dc->res_pool->mpc->funcs->remove(
-					dc->res_pool->mpc,
-					&(old_pipe_ctx->stream_res.opp->mpc_tree),
-					old_pipe_ctx->stream_res.opp->inst,
-					old_pipe_ctx->pipe_idx);
-			old_pipe_ctx->stream_res.opp->mpcc_disconnect_pending[old_pipe_ctx->plane_res.hubp->mpcc_id] = true;
-
-			/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
-					"[debug_mpo: apply_ctx disconnect pending on mpcc %d]\n",
-					old_pipe_ctx->mpcc->inst);*/
-
-			if (hubp->funcs->hubp_disconnect)
-				hubp->funcs->hubp_disconnect(hubp);
-
-			if (dc->debug.sanity_checks)
-				dcn10_verify_allow_pstate_change_high(dc);
-
-			old_pipe_ctx->top_pipe = NULL;
-			old_pipe_ctx->bottom_pipe = NULL;
-			old_pipe_ctx->plane_state = NULL;
-			old_pipe_ctx->stream = NULL;
+			plane_atomic_disconnect(dc, old_pipe_ctx);
+			removed_pipe[i] = true;
 
 			dm_logger_write(dc->ctx->logger, LOG_DC,
 					"Reset mpcc for pipe %d\n",
@@ -2201,23 +2204,24 @@ static void dcn10_apply_ctx_for_surface(
 		}
 	}
 
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-		struct pipe_ctx *old_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
+	if (num_planes > 0)
+		program_all_pipe_in_tree(dc, top_pipe_to_program, context);
+
+	tg->funcs->unlock(tg);
 
-		if (pipe_ctx->stream != stream)
-			continue;
 
-		/* looking for top pipe to program */
-		if (!pipe_ctx->top_pipe) {
-			program_all_pipe_in_tree(dc, pipe_ctx, context);
-			if (pipe_ctx->stream_res.tg &&
-				pipe_ctx->stream_res.tg->inst == be_idx &&
-				(pipe_ctx->plane_state || old_pipe_ctx->plane_state))
-				pipe_ctx->stream_res.tg->funcs->unlock(pipe_ctx->stream_res.tg);
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *old_pipe_ctx =
+				&dc->current_state->res_ctx.pipe_ctx[i];
+
+		if (removed_pipe[i]) {
+			plane_atomic_disable(dc, old_pipe_ctx);
+			if (num_planes == 0)
+				plane_atomic_power_down(dc, i);
 		}
 	}
 
+
 	dm_logger_write(dc->ctx->logger, LOG_BANDWIDTH_CALCS,
 			"\n============== Watermark parameters ==============\n"
 			"a.urgent_ns: %d \n"

commit 5fa2ec4fad366a6de324c57d51abea6dd4b52a26
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Tue Oct 31 15:23:57 2017 -0400

    drm/amd/display: renaming dpp function to follow naming convention
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Yuehin Lau <Yuehin.Lau@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 280476c42600..680aabda3277 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -869,23 +869,23 @@ static bool dcn10_set_input_transfer_func(
 		tf = plane_state->in_transfer_func;
 
 	if (plane_state->gamma_correction && dce_use_lut(plane_state))
-		dpp_base->funcs->ipp_program_input_lut(dpp_base,
+		dpp_base->funcs->dpp_program_input_lut(dpp_base,
 				plane_state->gamma_correction);
 
 	if (tf == NULL)
-		dpp_base->funcs->ipp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);
+		dpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);
 	else if (tf->type == TF_TYPE_PREDEFINED) {
 		switch (tf->tf) {
 		case TRANSFER_FUNCTION_SRGB:
-			dpp_base->funcs->ipp_set_degamma(dpp_base,
+			dpp_base->funcs->dpp_set_degamma(dpp_base,
 					IPP_DEGAMMA_MODE_HW_sRGB);
 			break;
 		case TRANSFER_FUNCTION_BT709:
-			dpp_base->funcs->ipp_set_degamma(dpp_base,
+			dpp_base->funcs->dpp_set_degamma(dpp_base,
 					IPP_DEGAMMA_MODE_HW_xvYCC);
 			break;
 		case TRANSFER_FUNCTION_LINEAR:
-			dpp_base->funcs->ipp_set_degamma(dpp_base,
+			dpp_base->funcs->dpp_set_degamma(dpp_base,
 					IPP_DEGAMMA_MODE_BYPASS);
 			break;
 		case TRANSFER_FUNCTION_PQ:
@@ -896,7 +896,7 @@ static bool dcn10_set_input_transfer_func(
 			break;
 		}
 	} else if (tf->type == TF_TYPE_BYPASS) {
-		dpp_base->funcs->ipp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);
+		dpp_base->funcs->dpp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);
 	} else {
 		/*TF_TYPE_DISTRIBUTED_POINTS*/
 		result = false;
@@ -1235,12 +1235,12 @@ static bool dcn10_set_output_transfer_func(
 			TF_TYPE_PREDEFINED &&
 		stream->out_transfer_func->tf ==
 			TRANSFER_FUNCTION_SRGB) {
-		dpp->funcs->opp_program_regamma_pwl(dpp, NULL, OPP_REGAMMA_SRGB);
+		dpp->funcs->dpp_program_regamma_pwl(dpp, NULL, OPP_REGAMMA_SRGB);
 	} else if (dcn10_translate_regamma_to_hw_format(
 				stream->out_transfer_func, &dpp->regamma_params)) {
-			dpp->funcs->opp_program_regamma_pwl(dpp, &dpp->regamma_params, OPP_REGAMMA_USER);
+			dpp->funcs->dpp_program_regamma_pwl(dpp, &dpp->regamma_params, OPP_REGAMMA_USER);
 	} else {
-		dpp->funcs->opp_program_regamma_pwl(dpp, NULL, OPP_REGAMMA_BYPASS);
+		dpp->funcs->dpp_program_regamma_pwl(dpp, NULL, OPP_REGAMMA_BYPASS);
 	}
 
 	return true;
@@ -1607,9 +1607,10 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 
 			tbl_entry.color_space = color_space;
 			//tbl_entry.regval = matrix;
-			pipe_ctx->plane_res.dpp->funcs->opp_set_csc_adjustment(pipe_ctx->plane_res.dpp, &tbl_entry);
+
+			pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_adjustment(pipe_ctx->plane_res.dpp, &tbl_entry);
 	} else {
-		pipe_ctx->plane_res.dpp->funcs->opp_set_csc_default(pipe_ctx->plane_res.dpp, colorspace);
+		pipe_ctx->plane_res.dpp->funcs->dpp_set_csc_default(pipe_ctx->plane_res.dpp, colorspace);
 	}
 }
 
@@ -1901,7 +1902,7 @@ static void update_dchubp_dpp(
 				);
 
 	// program the input csc
-	dpp->funcs->ipp_setup(dpp,
+	dpp->funcs->dpp_setup(dpp,
 			plane_state->format,
 			EXPANSION_MODE_ZERO,
 			plane_state->input_csc_color_matrix,
@@ -1909,8 +1910,8 @@ static void update_dchubp_dpp(
 
 	//set scale and bias registers
 	build_prescale_params(&bns_params, plane_state);
-	if (dpp->funcs->ipp_program_bias_and_scale)
-		dpp->funcs->ipp_program_bias_and_scale(dpp, &bns_params);
+	if (dpp->funcs->dpp_program_bias_and_scale)
+		dpp->funcs->dpp_program_bias_and_scale(dpp, &bns_params);
 
 	mpcc_cfg.dpp_id = hubp->inst;
 	mpcc_cfg.opp_id = pipe_ctx->stream_res.opp->inst;

commit ea826d640d8f3cb5b196b41283d41a16c24c013c
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Fri Oct 27 15:28:38 2017 -0400

    drm/amd/display: call set csc_default if enable adjustment is false
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7bc88f423b3e..280476c42600 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1608,6 +1608,8 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 			tbl_entry.color_space = color_space;
 			//tbl_entry.regval = matrix;
 			pipe_ctx->plane_res.dpp->funcs->opp_set_csc_adjustment(pipe_ctx->plane_res.dpp, &tbl_entry);
+	} else {
+		pipe_ctx->plane_res.dpp->funcs->opp_set_csc_default(pipe_ctx->plane_res.dpp, colorspace);
 	}
 }
 

commit 6334ac93a1e1ff8b99dac98bb7ef790b5786ea3c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Oct 27 17:55:03 2017 -0400

    drm/amd/display: cache pwl params and scl_data to avoid extra programming
    
    This saves us about 5000 reg writes per full update. This translates to about
    40000 writes over the course of single eDP bootup.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 43d4bfd47ec8..7bc88f423b3e 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1235,13 +1235,12 @@ static bool dcn10_set_output_transfer_func(
 			TF_TYPE_PREDEFINED &&
 		stream->out_transfer_func->tf ==
 			TRANSFER_FUNCTION_SRGB) {
-		dpp->funcs->opp_set_regamma_mode(dpp, OPP_REGAMMA_SRGB);
+		dpp->funcs->opp_program_regamma_pwl(dpp, NULL, OPP_REGAMMA_SRGB);
 	} else if (dcn10_translate_regamma_to_hw_format(
 				stream->out_transfer_func, &dpp->regamma_params)) {
-			dpp->funcs->opp_program_regamma_pwl(dpp, &dpp->regamma_params);
-			dpp->funcs->opp_set_regamma_mode(dpp, OPP_REGAMMA_USER);
+			dpp->funcs->opp_program_regamma_pwl(dpp, &dpp->regamma_params, OPP_REGAMMA_USER);
 	} else {
-		dpp->funcs->opp_set_regamma_mode(dpp, OPP_REGAMMA_BYPASS);
+		dpp->funcs->opp_program_regamma_pwl(dpp, NULL, OPP_REGAMMA_BYPASS);
 	}
 
 	return true;
@@ -2118,8 +2117,7 @@ static void dcn10_apply_ctx_for_surface(
 
 	if (num_planes == 0) {
 		for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
-			struct pipe_ctx *old_pipe_ctx =
-							&dc->current_state->res_ctx.pipe_ctx[i];
+			struct pipe_ctx *old_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
 
 			if (old_pipe_ctx->stream_res.tg && old_pipe_ctx->stream_res.tg->inst == be_idx) {
 				old_pipe_ctx->stream_res.tg->funcs->set_blank(old_pipe_ctx->stream_res.tg, true);

commit 069d418f412ec4b33056dc7d84b63c80c2e50abf
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Tue Sep 26 19:45:43 2017 -0400

    drm/amd/display: Don't use dc_link in link_encoder
    
    dc_link is at a higher level than link_encoder, and we only want
    higher-level components to be able to access lower-level ones,
    not the other way around.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index bb4446eecb39..43d4bfd47ec8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -723,6 +723,9 @@ static void dcn10_init_hw(struct dc *dc)
 		 */
 		struct dc_link *link = dc->links[i];
 
+		if (link->link_enc->connector.id == CONNECTOR_ID_EDP)
+			dc->hwss.edp_power_control(link, true);
+
 		link->link_enc->funcs->hw_init(link->link_enc);
 	}
 

commit 073a45e824db22f47940e203dc63ad081e53e9df
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Oct 30 13:35:04 2017 -0400

    drm/amd/display: Add tg_init interface.
    
    Clear OPTC underflow status when init_hw.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 9b37f65f86f5..bb4446eecb39 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -742,6 +742,8 @@ static void dcn10_init_hw(struct dc *dc)
 		hwss_wait_for_blank_complete(tg);
 
 		dcn10_power_down_fe(dc, i);
+
+		tg->funcs->tg_init(tg);
 	}
 
 	for (i = 0; i < dc->res_pool->audio_count; i++) {

commit 8a4cf458a84dfd3ed87ed69c0fdf7b39f20e1c06
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Thu Oct 26 16:30:44 2017 -0400

    drm/amd/display: Only update dchub if hubbub is available
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 75feb4788b6b..9b37f65f86f5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2509,7 +2509,8 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 
 void dcn10_update_dchub(struct dce_hwseq *hws, struct dchub_init_data *dh_data)
 {
-	hubbub1_update_dchub(hws->ctx->dc->res_pool->hubbub, dh_data);
+	if (hws->ctx->dc->res_pool->hubbub != NULL)
+		hubbub1_update_dchub(hws->ctx->dc->res_pool->hubbub, dh_data);
 }
 
 static const struct hw_sequencer_funcs dcn10_funcs = {

commit bc71a20db2858739724715e5096a98692320e69f
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Thu Oct 26 18:13:36 2017 -0400

    drm/amd/display: Call ipp_program_bias_and_scale only if available
    
    Also move some register definitions to common DCN regs.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 90f1f54ade61..75feb4788b6b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1903,7 +1903,8 @@ static void update_dchubp_dpp(
 
 	//set scale and bias registers
 	build_prescale_params(&bns_params, plane_state);
-	dpp->funcs->ipp_program_bias_and_scale(dpp, &bns_params);
+	if (dpp->funcs->ipp_program_bias_and_scale)
+		dpp->funcs->ipp_program_bias_and_scale(dpp, &bns_params);
 
 	mpcc_cfg.dpp_id = hubp->inst;
 	mpcc_cfg.opp_id = pipe_ctx->stream_res.opp->inst;

commit e70fe3b1f06fb12c5fb181c06bab745d0bad3fa5
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Thu Oct 26 11:29:54 2017 -0400

    drm/amd/display: hubbub function flipping true and false
    
    no logic change
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index fe236a9fd147..90f1f54ade61 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -548,7 +548,7 @@ void dcn10_verify_allow_pstate_change_high(struct dc *dc)
 {
 	static bool should_log_hw_state; /* prevent hw state log by default */
 
-	if (hubbub1_verify_allow_pstate_change_high(dc->res_pool->hubbub)) {
+	if (!hubbub1_verify_allow_pstate_change_high(dc->res_pool->hubbub)) {
 		if (should_log_hw_state) {
 			dcn10_log_hw_state(dc);
 		}

commit ea00f2979bc5a8c3389db0c88335a077d59eb4b6
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Tue Oct 24 15:16:38 2017 -0400

    drm/amd/display: function renaming for hubbub
    
    following the naming convention with correct prefix
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 24c840405c8d..fe236a9fd147 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -544,6 +544,19 @@ static void reset_back_end_for_pipe(
 					pipe_ctx->pipe_idx, pipe_ctx->stream_res.tg->inst);
 }
 
+void dcn10_verify_allow_pstate_change_high(struct dc *dc)
+{
+	static bool should_log_hw_state; /* prevent hw state log by default */
+
+	if (hubbub1_verify_allow_pstate_change_high(dc->res_pool->hubbub)) {
+		if (should_log_hw_state) {
+			dcn10_log_hw_state(dc);
+		}
+
+		BREAK_TO_DEBUGGER();
+	}
+}
+
 /* trigger HW to start disconnect plane from stream on the next vsync */
 static void plane_atomic_disconnect(struct dc *dc,
 		int fe_idx)
@@ -571,10 +584,10 @@ static void plane_atomic_disconnect(struct dc *dc,
 		return;
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->res_pool->hubbub);
+		dcn10_verify_allow_pstate_change_high(dc);
 	hubp->funcs->dcc_control(hubp, false, false);
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->res_pool->hubbub);
+		dcn10_verify_allow_pstate_change_high(dc);
 
 	mpc->funcs->remove(mpc, &(dc->res_pool->opps[opp_id]->mpc_tree),
 			dc->res_pool->opps[opp_id]->inst, fe_idx);
@@ -602,7 +615,7 @@ static void plane_atomic_disable(struct dc *dc,
 	hubp->funcs->set_blank(hubp, true);
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->res_pool->hubbub);
+		dcn10_verify_allow_pstate_change_high(dc);
 
 	REG_UPDATE(HUBP_CLK_CNTL[fe_idx],
 			HUBP_CLOCK_ENABLE, 0);
@@ -614,7 +627,7 @@ static void plane_atomic_disable(struct dc *dc,
 				OPP_PIPE_CLOCK_EN, 0);
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->res_pool->hubbub);
+		dcn10_verify_allow_pstate_change_high(dc);
 }
 
 static void reset_front_end(
@@ -638,7 +651,7 @@ static void reset_front_end(
 	tg->funcs->unlock(tg);
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->res_pool->hubbub);
+		dcn10_verify_allow_pstate_change_high(dc);
 
 	if (tg->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
 		REG_WAIT(OTG_GLOBAL_SYNC_STATUS[tg->inst],
@@ -670,7 +683,7 @@ static void dcn10_power_down_fe(struct dc *dc, int fe_idx)
 			"Power gated front end %d\n", fe_idx);
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->res_pool->hubbub);
+		dcn10_verify_allow_pstate_change_high(dc);
 }
 
 static void dcn10_init_hw(struct dc *dc)
@@ -1243,7 +1256,7 @@ static void dcn10_pipe_control_lock(
 		return;
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->res_pool->hubbub);
+		dcn10_verify_allow_pstate_change_high(dc);
 
 	if (lock)
 		pipe->stream_res.tg->funcs->lock(pipe->stream_res.tg);
@@ -1251,7 +1264,7 @@ static void dcn10_pipe_control_lock(
 		pipe->stream_res.tg->funcs->unlock(pipe->stream_res.tg);
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->res_pool->hubbub);
+		dcn10_verify_allow_pstate_change_high(dc);
 }
 
 static bool wait_for_reset_trigger_to_occur(
@@ -1475,7 +1488,7 @@ static void dcn10_power_on_fe(
 	struct dce_hwseq *hws = dc->hwseq;
 
 	if (dc->debug.sanity_checks) {
-		verify_allow_pstate_change_high(dc->res_pool->hubbub);
+		dcn10_verify_allow_pstate_change_high(dc);
 	}
 
 	power_on_plane(dc->hwseq,
@@ -1527,7 +1540,7 @@ static void dcn10_power_on_fe(
 	}
 
 	if (dc->debug.sanity_checks) {
-		verify_allow_pstate_change_high(dc->res_pool->hubbub);
+		dcn10_verify_allow_pstate_change_high(dc);
 	}
 }
 
@@ -1960,11 +1973,11 @@ static void program_all_pipe_in_tree(
 		 * this OTG. this is done only one time.
 		 */
 		/* watermark is for all pipes */
-		program_watermarks(dc->res_pool->hubbub, &context->bw.dcn.watermarks, ref_clk_mhz);
+		hubbub1_program_watermarks(dc->res_pool->hubbub, &context->bw.dcn.watermarks, ref_clk_mhz);
 
 		if (dc->debug.sanity_checks) {
 			/* pstate stuck check after watermark update */
-			verify_allow_pstate_change_high(dc->res_pool->hubbub);
+			dcn10_verify_allow_pstate_change_high(dc);
 		}
 
 		pipe_ctx->stream_res.tg->funcs->lock(pipe_ctx->stream_res.tg);
@@ -1995,7 +2008,7 @@ static void program_all_pipe_in_tree(
 		 * DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST is owned by SMU we should have
 		 * both driver and fw accessing same register
 		 */
-		toggle_watermark_change_req(dc->res_pool->hubbub);
+		hubbub1_toggle_watermark_change_req(dc->res_pool->hubbub);
 
 		update_dchubp_dpp(dc, pipe_ctx, context);
 
@@ -2018,7 +2031,7 @@ static void program_all_pipe_in_tree(
 
 	if (dc->debug.sanity_checks) {
 		/* pstate stuck check after each pipe is programmed */
-		verify_allow_pstate_change_high(dc->res_pool->hubbub);
+		dcn10_verify_allow_pstate_change_high(dc);
 	}
 
 	if (pipe_ctx->bottom_pipe != NULL && pipe_ctx->bottom_pipe != pipe_ctx)
@@ -2085,7 +2098,7 @@ static void dcn10_apply_ctx_for_surface(
 	int i, be_idx;
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->res_pool->hubbub);
+		dcn10_verify_allow_pstate_change_high(dc);
 
 	be_idx = -1;
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
@@ -2168,7 +2181,7 @@ static void dcn10_apply_ctx_for_surface(
 				hubp->funcs->hubp_disconnect(hubp);
 
 			if (dc->debug.sanity_checks)
-				verify_allow_pstate_change_high(dc->res_pool->hubbub);
+				dcn10_verify_allow_pstate_change_high(dc);
 
 			old_pipe_ctx->top_pipe = NULL;
 			old_pipe_ctx->bottom_pipe = NULL;
@@ -2246,7 +2259,7 @@ static void dcn10_apply_ctx_for_surface(
 			);
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->res_pool->hubbub);
+		dcn10_verify_allow_pstate_change_high(dc);
 }
 
 static void dcn10_set_bandwidth(
@@ -2260,7 +2273,7 @@ static void dcn10_set_bandwidth(
 	struct pp_smu_funcs_rv *pp_smu = dc->res_pool->pp_smu;
 
 	if (dc->debug.sanity_checks) {
-		verify_allow_pstate_change_high(dc->res_pool->hubbub);
+		dcn10_verify_allow_pstate_change_high(dc);
 	}
 
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
@@ -2316,7 +2329,7 @@ static void dcn10_set_bandwidth(
 	dcn10_pplib_apply_display_requirements(dc, context);
 
 	if (dc->debug.sanity_checks) {
-		verify_allow_pstate_change_high(dc->res_pool->hubbub);
+		dcn10_verify_allow_pstate_change_high(dc);
 	}
 
 	/* need to fix this function.  not doing the right thing here */
@@ -2441,7 +2454,7 @@ static void dcn10_wait_for_mpcc_disconnect(
 	int i;
 
 	if (dc->debug.sanity_checks) {
-		verify_allow_pstate_change_high(dc->res_pool->hubbub);
+		dcn10_verify_allow_pstate_change_high(dc);
 	}
 
 	if (!pipe_ctx->stream_res.opp)
@@ -2459,7 +2472,7 @@ static void dcn10_wait_for_mpcc_disconnect(
 	}
 
 	if (dc->debug.sanity_checks) {
-		verify_allow_pstate_change_high(dc->res_pool->hubbub);
+		dcn10_verify_allow_pstate_change_high(dc);
 	}
 
 }

commit afa9104b04fc34ef23c25cb605906e7c0c7be47b
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Tue Oct 24 14:13:16 2017 -0400

    drm/amd/display: create new function prototype update_dchub for dcn
    
    dcn version of update_dchub now uses hubbub instead of hwseq
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 762af17485e0..24c840405c8d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2493,7 +2493,10 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 	}
 }
 
-
+void dcn10_update_dchub(struct dce_hwseq *hws, struct dchub_init_data *dh_data)
+{
+	hubbub1_update_dchub(hws->ctx->dc->res_pool->hubbub, dh_data);
+}
 
 static const struct hw_sequencer_funcs dcn10_funcs = {
 	.program_gamut_remap = program_gamut_remap,
@@ -2503,6 +2506,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.apply_ctx_for_surface = dcn10_apply_ctx_for_surface,
 	.set_plane_config = set_plane_config,
 	.update_plane_addr = dcn10_update_plane_addr,
+	.update_dchub = dcn10_update_dchub,
 	.update_pending_status = dcn10_update_pending_status,
 	.set_input_transfer_func = dcn10_set_input_transfer_func,
 	.set_output_transfer_func = dcn10_set_output_transfer_func,

commit fa2123dbccdc881fae02aaf8b05758db53d62955
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Tue Oct 17 15:29:22 2017 -0400

    drm/amd/display: Multi display synchronization logic
    
    This feature synchronizes multiple displays with various timings
    to a display with the highest refresh rate
    it is enabled if edid caps flag multi_display_sync is set to one
    
    There are limitations on refresh rates allowed
    that can be synchronized. That would
    prevent from underflow and other potential
    corruptions.
    
    Multi display synchronization is using the
    same functions as timing_sync in order to minimize
    redunduncy and decision to disable synchronization is
    based on trigger parametre set in DM
    
    Feature is developed for DCN1 and DCE11
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Mikita Lipski <Mikita.Lipski@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index adabd2ad5594..762af17485e0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1304,14 +1304,15 @@ static void dcn10_enable_timing_synchronization(
 
 	for (i = 1; i < group_size; i++)
 		grouped_pipes[i]->stream_res.tg->funcs->enable_reset_trigger(
-				grouped_pipes[i]->stream_res.tg, grouped_pipes[0]->stream_res.tg->inst);
-
+				grouped_pipes[i]->stream_res.tg,
+				grouped_pipes[0]->stream_res.tg->inst);
 
 	DC_SYNC_INFO("Waiting for trigger\n");
 
 	/* Need to get only check 1 pipe for having reset as all the others are
 	 * synchronized. Look at last pipe programmed to reset.
 	 */
+
 	wait_for_reset_trigger_to_occur(dc_ctx, grouped_pipes[1]->stream_res.tg);
 	for (i = 1; i < group_size; i++)
 		grouped_pipes[i]->stream_res.tg->funcs->disable_reset_trigger(
@@ -1320,6 +1321,29 @@ static void dcn10_enable_timing_synchronization(
 	DC_SYNC_INFO("Sync complete\n");
 }
 
+static void dcn10_enable_per_frame_crtc_position_reset(
+	struct dc *dc,
+	int group_size,
+	struct pipe_ctx *grouped_pipes[])
+{
+	struct dc_context *dc_ctx = dc->ctx;
+	int i;
+
+	DC_SYNC_INFO("Setting up\n");
+	for (i = 0; i < group_size; i++)
+		grouped_pipes[i]->stream_res.tg->funcs->enable_crtc_reset(
+				grouped_pipes[i]->stream_res.tg,
+				grouped_pipes[i]->stream->triggered_crtc_reset.event_source->status.primary_otg_inst,
+				&grouped_pipes[i]->stream->triggered_crtc_reset);
+
+	DC_SYNC_INFO("Waiting for trigger\n");
+
+	for (i = 1; i < group_size; i++)
+		wait_for_reset_trigger_to_occur(dc_ctx, grouped_pipes[i]->stream_res.tg);
+
+	DC_SYNC_INFO("Multi-display sync is complete\n");
+}
+
 static void print_rq_dlg_ttu(
 		struct dc *core_dc,
 		struct pipe_ctx *pipe_ctx)
@@ -2485,6 +2509,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.power_down = dce110_power_down,
 	.enable_accelerated_mode = dce110_enable_accelerated_mode,
 	.enable_timing_synchronization = dcn10_enable_timing_synchronization,
+	.enable_per_frame_crtc_position_reset = dcn10_enable_per_frame_crtc_position_reset,
 	.update_info_frame = dce110_update_info_frame,
 	.enable_stream = dce110_enable_stream,
 	.disable_stream = dce110_disable_stream,

commit 56ef6ed9faf35b9057630dd12aeca134f98214ec
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Mon Oct 23 17:02:02 2017 -0400

    drm/amd/display: Move hdr_metadata from plane to stream
    
    Need to move HDR Metadata from Surface to Stream since there is only one
    infoframe possible per stream.
    
    Also cleaning up some duplicate definitions.
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index cf594fb44328..adabd2ad5594 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1556,8 +1556,7 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 	int i;
 	struct out_csc_color_matrix tbl_entry;
 
-	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment
-				== true) {
+	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment == true) {
 			enum dc_color_space color_space =
 				pipe_ctx->stream->output_color_space;
 

commit de4a2967737114d426411a79781d9d81d0ff38d2
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Thu Oct 19 13:41:30 2017 -0400

    drm/amd/display: Apply VQ adjustments in MPO case
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 163b40dad3f3..cf594fb44328 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1570,6 +1570,7 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 			pipe_ctx->plane_res.dpp->funcs->opp_set_csc_adjustment(pipe_ctx->plane_res.dpp, &tbl_entry);
 	}
 }
+
 static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
 	if (pipe_ctx->plane_state->visible)
@@ -1657,6 +1658,69 @@ static void dcn10_get_surface_visual_confirm_color(
 	}
 }
 
+static uint16_t fixed_point_to_int_frac(
+	struct fixed31_32 arg,
+	uint8_t integer_bits,
+	uint8_t fractional_bits)
+{
+	int32_t numerator;
+	int32_t divisor = 1 << fractional_bits;
+
+	uint16_t result;
+
+	uint16_t d = (uint16_t)dal_fixed31_32_floor(
+		dal_fixed31_32_abs(
+			arg));
+
+	if (d <= (uint16_t)(1 << integer_bits) - (1 / (uint16_t)divisor))
+		numerator = (uint16_t)dal_fixed31_32_floor(
+			dal_fixed31_32_mul_int(
+				arg,
+				divisor));
+	else {
+		numerator = dal_fixed31_32_floor(
+			dal_fixed31_32_sub(
+				dal_fixed31_32_from_int(
+					1LL << integer_bits),
+				dal_fixed31_32_recip(
+					dal_fixed31_32_from_int(
+						divisor))));
+	}
+
+	if (numerator >= 0)
+		result = (uint16_t)numerator;
+	else
+		result = (uint16_t)(
+		(1 << (integer_bits + fractional_bits + 1)) + numerator);
+
+	if ((result != 0) && dal_fixed31_32_lt(
+		arg, dal_fixed31_32_zero))
+		result |= 1 << (integer_bits + fractional_bits);
+
+	return result;
+}
+
+void build_prescale_params(struct  dc_bias_and_scale *bias_and_scale,
+		const struct dc_plane_state *plane_state)
+{
+	if (plane_state->format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN
+			&& plane_state->format != SURFACE_PIXEL_FORMAT_INVALID
+			&& plane_state->input_csc_color_matrix.enable_adjustment
+			&& plane_state->coeff_reduction_factor.value != 0) {
+		bias_and_scale->scale_blue = fixed_point_to_int_frac(
+			dal_fixed31_32_mul(plane_state->coeff_reduction_factor,
+					dal_fixed31_32_from_fraction(256, 255)),
+				2,
+				13);
+		bias_and_scale->scale_red = bias_and_scale->scale_blue;
+		bias_and_scale->scale_green = bias_and_scale->scale_blue;
+	} else {
+		bias_and_scale->scale_blue = 0x2000;
+		bias_and_scale->scale_red = 0x2000;
+		bias_and_scale->scale_green = 0x2000;
+	}
+}
+
 static void mmhub_read_vm_system_aperture_settings(struct dcn10_hubp *hubp1,
 		struct vm_system_aperture_param *apt,
 		struct dce_hwseq *hws)
@@ -1757,6 +1821,7 @@ static void update_dchubp_dpp(
 	struct mpcc_cfg mpcc_cfg = {0};
 	struct pipe_ctx *top_pipe;
 	bool per_pixel_alpha = plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;
+	struct dc_bias_and_scale bns_params = {0};
 
 	/* TODO: proper fix once fpga works */
 	/* depends on DML calculation, DPP clock value may change dynamically */
@@ -1793,9 +1858,16 @@ static void update_dchubp_dpp(
 				hws
 				);
 
+	// program the input csc
 	dpp->funcs->ipp_setup(dpp,
 			plane_state->format,
-			EXPANSION_MODE_ZERO);
+			EXPANSION_MODE_ZERO,
+			plane_state->input_csc_color_matrix,
+			COLOR_SPACE_YCBCR601_LIMITED);
+
+	//set scale and bias registers
+	build_prescale_params(&bns_params, plane_state);
+	dpp->funcs->ipp_program_bias_and_scale(dpp, &bns_params);
 
 	mpcc_cfg.dpp_id = hubp->inst;
 	mpcc_cfg.opp_id = pipe_ctx->stream_res.opp->inst;
@@ -1835,6 +1907,7 @@ static void update_dchubp_dpp(
 			pipe_ctx->stream->output_color_space,
 			pipe_ctx->stream->csc_color_matrix.matrix);
 
+
 	hubp->funcs->hubp_program_surface_config(
 		hubp,
 		plane_state->format,

commit c9ef081df08d0ad5bae7f6fb9d7d63422b109b62
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Mon Oct 23 16:01:36 2017 -0400

    drm/amd/display: create new structure for hubbub
    
    instantiating new structure hubbub in resource.c
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index b3e587f273e8..163b40dad3f3 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -87,7 +87,7 @@ void dcn10_log_hubbub_state(struct dc *dc)
 	struct dcn_hubbub_wm wm;
 	int i;
 
-	dcn10_hubbub_wm_read_state(dc->hwseq, &wm);
+	hubbub1_wm_read_state(dc->res_pool->hubbub, &wm);
 
 	DTN_INFO("HUBBUB WM: \t data_urgent \t pte_meta_urgent \t "
 			"sr_enter \t sr_exit \t dram_clk_change \n");
@@ -571,10 +571,10 @@ static void plane_atomic_disconnect(struct dc *dc,
 		return;
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->hwseq);
+		verify_allow_pstate_change_high(dc->res_pool->hubbub);
 	hubp->funcs->dcc_control(hubp, false, false);
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->hwseq);
+		verify_allow_pstate_change_high(dc->res_pool->hubbub);
 
 	mpc->funcs->remove(mpc, &(dc->res_pool->opps[opp_id]->mpc_tree),
 			dc->res_pool->opps[opp_id]->inst, fe_idx);
@@ -602,7 +602,7 @@ static void plane_atomic_disable(struct dc *dc,
 	hubp->funcs->set_blank(hubp, true);
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->hwseq);
+		verify_allow_pstate_change_high(dc->res_pool->hubbub);
 
 	REG_UPDATE(HUBP_CLK_CNTL[fe_idx],
 			HUBP_CLOCK_ENABLE, 0);
@@ -614,7 +614,7 @@ static void plane_atomic_disable(struct dc *dc,
 				OPP_PIPE_CLOCK_EN, 0);
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->hwseq);
+		verify_allow_pstate_change_high(dc->res_pool->hubbub);
 }
 
 static void reset_front_end(
@@ -638,7 +638,7 @@ static void reset_front_end(
 	tg->funcs->unlock(tg);
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(hws);
+		verify_allow_pstate_change_high(dc->res_pool->hubbub);
 
 	if (tg->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
 		REG_WAIT(OTG_GLOBAL_SYNC_STATUS[tg->inst],
@@ -670,7 +670,7 @@ static void dcn10_power_down_fe(struct dc *dc, int fe_idx)
 			"Power gated front end %d\n", fe_idx);
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->hwseq);
+		verify_allow_pstate_change_high(dc->res_pool->hubbub);
 }
 
 static void dcn10_init_hw(struct dc *dc)
@@ -1243,7 +1243,7 @@ static void dcn10_pipe_control_lock(
 		return;
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->hwseq);
+		verify_allow_pstate_change_high(dc->res_pool->hubbub);
 
 	if (lock)
 		pipe->stream_res.tg->funcs->lock(pipe->stream_res.tg);
@@ -1251,7 +1251,7 @@ static void dcn10_pipe_control_lock(
 		pipe->stream_res.tg->funcs->unlock(pipe->stream_res.tg);
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->hwseq);
+		verify_allow_pstate_change_high(dc->res_pool->hubbub);
 }
 
 static bool wait_for_reset_trigger_to_occur(
@@ -1451,7 +1451,7 @@ static void dcn10_power_on_fe(
 	struct dce_hwseq *hws = dc->hwseq;
 
 	if (dc->debug.sanity_checks) {
-		verify_allow_pstate_change_high(dc->hwseq);
+		verify_allow_pstate_change_high(dc->res_pool->hubbub);
 	}
 
 	power_on_plane(dc->hwseq,
@@ -1503,7 +1503,7 @@ static void dcn10_power_on_fe(
 	}
 
 	if (dc->debug.sanity_checks) {
-		verify_allow_pstate_change_high(dc->hwseq);
+		verify_allow_pstate_change_high(dc->res_pool->hubbub);
 	}
 }
 
@@ -1864,11 +1864,11 @@ static void program_all_pipe_in_tree(
 		 * this OTG. this is done only one time.
 		 */
 		/* watermark is for all pipes */
-		program_watermarks(dc->hwseq, &context->bw.dcn.watermarks, ref_clk_mhz);
+		program_watermarks(dc->res_pool->hubbub, &context->bw.dcn.watermarks, ref_clk_mhz);
 
 		if (dc->debug.sanity_checks) {
 			/* pstate stuck check after watermark update */
-			verify_allow_pstate_change_high(dc->hwseq);
+			verify_allow_pstate_change_high(dc->res_pool->hubbub);
 		}
 
 		pipe_ctx->stream_res.tg->funcs->lock(pipe_ctx->stream_res.tg);
@@ -1899,7 +1899,7 @@ static void program_all_pipe_in_tree(
 		 * DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST is owned by SMU we should have
 		 * both driver and fw accessing same register
 		 */
-		toggle_watermark_change_req(dc->hwseq);
+		toggle_watermark_change_req(dc->res_pool->hubbub);
 
 		update_dchubp_dpp(dc, pipe_ctx, context);
 
@@ -1922,7 +1922,7 @@ static void program_all_pipe_in_tree(
 
 	if (dc->debug.sanity_checks) {
 		/* pstate stuck check after each pipe is programmed */
-		verify_allow_pstate_change_high(dc->hwseq);
+		verify_allow_pstate_change_high(dc->res_pool->hubbub);
 	}
 
 	if (pipe_ctx->bottom_pipe != NULL && pipe_ctx->bottom_pipe != pipe_ctx)
@@ -1989,7 +1989,7 @@ static void dcn10_apply_ctx_for_surface(
 	int i, be_idx;
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->hwseq);
+		verify_allow_pstate_change_high(dc->res_pool->hubbub);
 
 	be_idx = -1;
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
@@ -2072,7 +2072,7 @@ static void dcn10_apply_ctx_for_surface(
 				hubp->funcs->hubp_disconnect(hubp);
 
 			if (dc->debug.sanity_checks)
-				verify_allow_pstate_change_high(dc->hwseq);
+				verify_allow_pstate_change_high(dc->res_pool->hubbub);
 
 			old_pipe_ctx->top_pipe = NULL;
 			old_pipe_ctx->bottom_pipe = NULL;
@@ -2150,7 +2150,7 @@ static void dcn10_apply_ctx_for_surface(
 			);
 
 	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->hwseq);
+		verify_allow_pstate_change_high(dc->res_pool->hubbub);
 }
 
 static void dcn10_set_bandwidth(
@@ -2164,7 +2164,7 @@ static void dcn10_set_bandwidth(
 	struct pp_smu_funcs_rv *pp_smu = dc->res_pool->pp_smu;
 
 	if (dc->debug.sanity_checks) {
-		verify_allow_pstate_change_high(dc->hwseq);
+		verify_allow_pstate_change_high(dc->res_pool->hubbub);
 	}
 
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
@@ -2220,7 +2220,7 @@ static void dcn10_set_bandwidth(
 	dcn10_pplib_apply_display_requirements(dc, context);
 
 	if (dc->debug.sanity_checks) {
-		verify_allow_pstate_change_high(dc->hwseq);
+		verify_allow_pstate_change_high(dc->res_pool->hubbub);
 	}
 
 	/* need to fix this function.  not doing the right thing here */
@@ -2345,7 +2345,7 @@ static void dcn10_wait_for_mpcc_disconnect(
 	int i;
 
 	if (dc->debug.sanity_checks) {
-		verify_allow_pstate_change_high(dc->hwseq);
+		verify_allow_pstate_change_high(dc->res_pool->hubbub);
 	}
 
 	if (!pipe_ctx->stream_res.opp)
@@ -2363,7 +2363,7 @@ static void dcn10_wait_for_mpcc_disconnect(
 	}
 
 	if (dc->debug.sanity_checks) {
-		verify_allow_pstate_change_high(dc->hwseq);
+		verify_allow_pstate_change_high(dc->res_pool->hubbub);
 	}
 
 }
@@ -2407,7 +2407,6 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.apply_ctx_for_surface = dcn10_apply_ctx_for_surface,
 	.set_plane_config = set_plane_config,
 	.update_plane_addr = dcn10_update_plane_addr,
-	.update_dchub = dcn10_update_dchub,
 	.update_pending_status = dcn10_update_pending_status,
 	.set_input_transfer_func = dcn10_set_input_transfer_func,
 	.set_output_transfer_func = dcn10_set_output_transfer_func,

commit 1dbac201be8c48806aaad074475e2e6ba07f35b2
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Sat Oct 21 15:52:40 2017 -0400

    drm/amd/display: Added disconnect dchub.
    
    Add disable ttu interface to dcn10, when remove
    mpc, disable ttu as well.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f7434ae4aec2..b3e587f273e8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2019,6 +2019,7 @@ static void dcn10_apply_ctx_for_surface(
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *old_pipe_ctx =
 				&dc->current_state->res_ctx.pipe_ctx[i];
+		struct hubp *hubp = dc->res_pool->hubps[i];
 
 		if (!pipe_ctx->plane_state && !old_pipe_ctx->plane_state)
 			continue;
@@ -2067,6 +2068,9 @@ static void dcn10_apply_ctx_for_surface(
 					"[debug_mpo: apply_ctx disconnect pending on mpcc %d]\n",
 					old_pipe_ctx->mpcc->inst);*/
 
+			if (hubp->funcs->hubp_disconnect)
+				hubp->funcs->hubp_disconnect(hubp);
+
 			if (dc->debug.sanity_checks)
 				verify_allow_pstate_change_high(dc->hwseq);
 

commit 74707de3365a0ab1244e0253842e5b10d32c4a01
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Oct 17 14:24:28 2017 -0400

    drm/amd/display: Not reset front end when program back end.
    
    Since front end is programmed before back end programming,
    no need to reset front end in back end programming.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 3891e9118485..f7434ae4aec2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -617,32 +617,6 @@ static void plane_atomic_disable(struct dc *dc,
 		verify_allow_pstate_change_high(dc->hwseq);
 }
 
-/*
- * kill power to plane hw
- * note: cannot power down until plane is disable
- */
-static void plane_atomic_power_down(struct dc *dc, int fe_idx)
-{
-	struct dce_hwseq *hws = dc->hwseq;
-	struct dpp *dpp = dc->res_pool->dpps[fe_idx];
-
-	if (REG(DC_IP_REQUEST_CNTL)) {
-		REG_SET(DC_IP_REQUEST_CNTL, 0,
-				IP_REQUEST_EN, 1);
-		dpp_pg_control(hws, fe_idx, false);
-		hubp_pg_control(hws, fe_idx, false);
-		dpp->funcs->dpp_reset(dpp);
-		REG_SET(DC_IP_REQUEST_CNTL, 0,
-				IP_REQUEST_EN, 0);
-		dm_logger_write(dc->ctx->logger, LOG_DEBUG,
-				"Power gated front end %d\n", fe_idx);
-
-		if (dc->debug.sanity_checks)
-			verify_allow_pstate_change_high(dc->hwseq);
-	}
-}
-
-
 static void reset_front_end(
 		struct dc *dc,
 		int fe_idx)
@@ -792,56 +766,6 @@ static void reset_hw_ctx_wrap(
 {
 	int i;
 
-	/* Reset Front End*/
-	/* Lock*/
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct pipe_ctx *cur_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
-		struct timing_generator *tg = cur_pipe_ctx->stream_res.tg;
-
-		if (cur_pipe_ctx->stream)
-			tg->funcs->lock(tg);
-	}
-	/* Disconnect*/
-	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
-		struct pipe_ctx *pipe_ctx_old =
-			&dc->current_state->res_ctx.pipe_ctx[i];
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-
-		if (!pipe_ctx->stream ||
-				!pipe_ctx->plane_state ||
-				pipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {
-
-			plane_atomic_disconnect(dc, i);
-		}
-	}
-	/* Unlock*/
-	for (i = dc->res_pool->pipe_count - 1; i >= 0; i--) {
-		struct pipe_ctx *cur_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
-		struct timing_generator *tg = cur_pipe_ctx->stream_res.tg;
-
-		if (cur_pipe_ctx->stream)
-			tg->funcs->unlock(tg);
-	}
-
-	/* Disable and Powerdown*/
-	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
-		struct pipe_ctx *pipe_ctx_old =
-			&dc->current_state->res_ctx.pipe_ctx[i];
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-
-		/*if (!pipe_ctx_old->stream)
-			continue;*/
-
-		if (pipe_ctx->stream && pipe_ctx->plane_state
-				&& !pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
-			continue;
-
-		plane_atomic_disable(dc, i);
-
-		if (!pipe_ctx->stream || !pipe_ctx->plane_state)
-			plane_atomic_power_down(dc, i);
-	}
-
 	/* Reset Back End*/
 	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
 		struct pipe_ctx *pipe_ctx_old =

commit 7a5086a71e8228a91ed5e8c7ae73e64799b12b66
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Oct 20 14:12:35 2017 -0400

    drm/amd/display: Power down front end in init_hw.
    
    front end is initialized during init_hw, but not
    power gated. There are some left over valuse and will
    cause some diags test failed. Power gated all front
    end pipes will make sure every test has same starting
    point.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 8d554e63dc7a..3891e9118485 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -414,91 +414,6 @@ static void bios_golden_init(struct dc *dc)
 	}
 }
 
-static void dcn10_init_hw(struct dc *dc)
-{
-	int i;
-	struct abm *abm = dc->res_pool->abm;
-	struct dmcu *dmcu = dc->res_pool->dmcu;
-	struct dce_hwseq *hws = dc->hwseq;
-
-	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
-		REG_WRITE(REFCLK_CNTL, 0);
-		REG_UPDATE(DCHUBBUB_GLOBAL_TIMER_CNTL, DCHUBBUB_GLOBAL_TIMER_ENABLE, 1);
-		REG_WRITE(DIO_MEM_PWR_CTRL, 0);
-
-		if (!dc->debug.disable_clock_gate) {
-			/* enable all DCN clock gating */
-			REG_WRITE(DCCG_GATE_DISABLE_CNTL, 0);
-
-			REG_WRITE(DCCG_GATE_DISABLE_CNTL2, 0);
-
-			REG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);
-		}
-
-		enable_power_gating_plane(dc->hwseq, true);
-		return;
-	}
-	/* end of FPGA. Below if real ASIC */
-
-	bios_golden_init(dc);
-
-	disable_vga(dc->hwseq);
-
-	for (i = 0; i < dc->link_count; i++) {
-		/* Power up AND update implementation according to the
-		 * required signal (which may be different from the
-		 * default signal on connector).
-		 */
-		struct dc_link *link = dc->links[i];
-
-		link->link_enc->funcs->hw_init(link->link_enc);
-	}
-
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct dpp *dpp = dc->res_pool->dpps[i];
-		struct timing_generator *tg = dc->res_pool->timing_generators[i];
-
-		dpp->funcs->dpp_reset(dpp);
-		dc->res_pool->mpc->funcs->remove(
-				dc->res_pool->mpc, &(dc->res_pool->opps[i]->mpc_tree),
-				dc->res_pool->opps[i]->inst, i);
-
-		/* Blank controller using driver code instead of
-		 * command table.
-		 */
-		tg->funcs->set_blank(tg, true);
-		hwss_wait_for_blank_complete(tg);
-	}
-
-	for (i = 0; i < dc->res_pool->audio_count; i++) {
-		struct audio *audio = dc->res_pool->audios[i];
-
-		audio->funcs->hw_init(audio);
-	}
-
-	if (abm != NULL) {
-		abm->funcs->init_backlight(abm);
-		abm->funcs->abm_init(abm);
-	}
-
-	if (dmcu != NULL)
-		dmcu->funcs->dmcu_init(dmcu);
-
-	/* power AFMT HDMI memory TODO: may move to dis/en output save power*/
-	REG_WRITE(DIO_MEM_PWR_CTRL, 0);
-
-	if (!dc->debug.disable_clock_gate) {
-		/* enable all DCN clock gating */
-		REG_WRITE(DCCG_GATE_DISABLE_CNTL, 0);
-
-		REG_WRITE(DCCG_GATE_DISABLE_CNTL2, 0);
-
-		REG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);
-	}
-
-	enable_power_gating_plane(dc->hwseq, true);
-}
-
 static enum dc_status dcn10_prog_pixclk_crtc_otg(
 		struct pipe_ctx *pipe_ctx,
 		struct dc_state *context,
@@ -784,6 +699,93 @@ static void dcn10_power_down_fe(struct dc *dc, int fe_idx)
 		verify_allow_pstate_change_high(dc->hwseq);
 }
 
+static void dcn10_init_hw(struct dc *dc)
+{
+	int i;
+	struct abm *abm = dc->res_pool->abm;
+	struct dmcu *dmcu = dc->res_pool->dmcu;
+	struct dce_hwseq *hws = dc->hwseq;
+
+	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
+		REG_WRITE(REFCLK_CNTL, 0);
+		REG_UPDATE(DCHUBBUB_GLOBAL_TIMER_CNTL, DCHUBBUB_GLOBAL_TIMER_ENABLE, 1);
+		REG_WRITE(DIO_MEM_PWR_CTRL, 0);
+
+		if (!dc->debug.disable_clock_gate) {
+			/* enable all DCN clock gating */
+			REG_WRITE(DCCG_GATE_DISABLE_CNTL, 0);
+
+			REG_WRITE(DCCG_GATE_DISABLE_CNTL2, 0);
+
+			REG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);
+		}
+
+		enable_power_gating_plane(dc->hwseq, true);
+		return;
+	}
+	/* end of FPGA. Below if real ASIC */
+
+	bios_golden_init(dc);
+
+	disable_vga(dc->hwseq);
+
+	for (i = 0; i < dc->link_count; i++) {
+		/* Power up AND update implementation according to the
+		 * required signal (which may be different from the
+		 * default signal on connector).
+		 */
+		struct dc_link *link = dc->links[i];
+
+		link->link_enc->funcs->hw_init(link->link_enc);
+	}
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct dpp *dpp = dc->res_pool->dpps[i];
+		struct timing_generator *tg = dc->res_pool->timing_generators[i];
+
+		dpp->funcs->dpp_reset(dpp);
+		dc->res_pool->mpc->funcs->remove(
+				dc->res_pool->mpc, &(dc->res_pool->opps[i]->mpc_tree),
+				dc->res_pool->opps[i]->inst, i);
+
+		/* Blank controller using driver code instead of
+		 * command table.
+		 */
+		tg->funcs->set_blank(tg, true);
+		hwss_wait_for_blank_complete(tg);
+
+		dcn10_power_down_fe(dc, i);
+	}
+
+	for (i = 0; i < dc->res_pool->audio_count; i++) {
+		struct audio *audio = dc->res_pool->audios[i];
+
+		audio->funcs->hw_init(audio);
+	}
+
+	if (abm != NULL) {
+		abm->funcs->init_backlight(abm);
+		abm->funcs->abm_init(abm);
+	}
+
+	if (dmcu != NULL)
+		dmcu->funcs->dmcu_init(dmcu);
+
+	/* power AFMT HDMI memory TODO: may move to dis/en output save power*/
+	REG_WRITE(DIO_MEM_PWR_CTRL, 0);
+
+	if (!dc->debug.disable_clock_gate) {
+		/* enable all DCN clock gating */
+		REG_WRITE(DCCG_GATE_DISABLE_CNTL, 0);
+
+		REG_WRITE(DCCG_GATE_DISABLE_CNTL2, 0);
+
+		REG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);
+	}
+
+	enable_power_gating_plane(dc->hwseq, true);
+}
+
 static void reset_hw_ctx_wrap(
 		struct dc *dc,
 		struct dc_state *context)

commit 62d591a8e00cc349e6a9efb87efac9548f178624
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Wed Oct 18 11:59:42 2017 -0400

    drm/amd/display: create new files for hubbub functions
    
    moving hubbub functions to new file
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index cd9e5484738d..8d554e63dc7a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -42,6 +42,7 @@
 #include "reg_helper.h"
 #include "custom_float.h"
 #include "dcn10_hubp.h"
+#include "dcn10_hubbub.h"
 
 #define CTX \
 	hws->ctx
@@ -52,18 +53,8 @@
 #define FN(reg_name, field_name) \
 	hws->shifts->field_name, hws->masks->field_name
 
-static void log_mpc_crc(struct dc *dc)
-{
-	struct dc_context *dc_ctx = dc->ctx;
-	struct dce_hwseq *hws = dc->hwseq;
-
-	if (REG(MPC_CRC_RESULT_GB))
-		DTN_INFO("MPC_CRC_RESULT_GB:%d MPC_CRC_RESULT_C:%d MPC_CRC_RESULT_AR:%d\n",
-		REG_READ(MPC_CRC_RESULT_GB), REG_READ(MPC_CRC_RESULT_C), REG_READ(MPC_CRC_RESULT_AR));
-	if (REG(DPP_TOP0_DPP_CRC_VAL_B_A))
-		DTN_INFO("DPP_TOP0_DPP_CRC_VAL_B_A:%d DPP_TOP0_DPP_CRC_VAL_R_G:%d\n",
-		REG_READ(DPP_TOP0_DPP_CRC_VAL_B_A), REG_READ(DPP_TOP0_DPP_CRC_VAL_R_G));
-}
+#define DTN_INFO_MICRO_SEC(ref_cycle) \
+	print_microsec(dc_ctx, ref_cycle)
 
 void print_microsec(struct dc_context *dc_ctx, uint32_t ref_cycle)
 {
@@ -76,61 +67,21 @@ void print_microsec(struct dc_context *dc_ctx, uint32_t ref_cycle)
 			us_x10 % frac);
 }
 
-#define DTN_INFO_MICRO_SEC(ref_cycle) \
-	print_microsec(dc_ctx, ref_cycle)
-
-struct dcn_hubbub_wm_set {
-	uint32_t wm_set;
-	uint32_t data_urgent;
-	uint32_t pte_meta_urgent;
-	uint32_t sr_enter;
-	uint32_t sr_exit;
-	uint32_t dram_clk_chanage;
-};
 
-struct dcn_hubbub_wm {
-	struct dcn_hubbub_wm_set sets[4];
-};
-
-static void dcn10_hubbub_wm_read_state(struct dce_hwseq *hws,
-		struct dcn_hubbub_wm *wm)
+static void log_mpc_crc(struct dc *dc)
 {
-	struct dcn_hubbub_wm_set *s;
-
-	s = &wm->sets[0];
-	s->wm_set = 0;
-	s->data_urgent = REG_READ(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_A);
-	s->pte_meta_urgent = REG_READ(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_A);
-	s->sr_enter = REG_READ(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A);
-	s->sr_exit = REG_READ(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_A);
-	s->dram_clk_chanage = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_A);
-
-	s = &wm->sets[1];
-	s->wm_set = 1;
-	s->data_urgent = REG_READ(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_B);
-	s->pte_meta_urgent = REG_READ(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_B);
-	s->sr_enter = REG_READ(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B);
-	s->sr_exit = REG_READ(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_B);
-	s->dram_clk_chanage = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_B);
-
-	s = &wm->sets[2];
-	s->wm_set = 2;
-	s->data_urgent = REG_READ(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_C);
-	s->pte_meta_urgent = REG_READ(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_C);
-	s->sr_enter = REG_READ(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C);
-	s->sr_exit = REG_READ(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_C);
-	s->dram_clk_chanage = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_C);
-
-	s = &wm->sets[3];
-	s->wm_set = 3;
-	s->data_urgent = REG_READ(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_D);
-	s->pte_meta_urgent = REG_READ(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_D);
-	s->sr_enter = REG_READ(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D);
-	s->sr_exit = REG_READ(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_D);
-	s->dram_clk_chanage = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_D);
+	struct dc_context *dc_ctx = dc->ctx;
+	struct dce_hwseq *hws = dc->hwseq;
+
+	if (REG(MPC_CRC_RESULT_GB))
+		DTN_INFO("MPC_CRC_RESULT_GB:%d MPC_CRC_RESULT_C:%d MPC_CRC_RESULT_AR:%d\n",
+		REG_READ(MPC_CRC_RESULT_GB), REG_READ(MPC_CRC_RESULT_C), REG_READ(MPC_CRC_RESULT_AR));
+	if (REG(DPP_TOP0_DPP_CRC_VAL_B_A))
+		DTN_INFO("DPP_TOP0_DPP_CRC_VAL_B_A:%d DPP_TOP0_DPP_CRC_VAL_R_G:%d\n",
+		REG_READ(DPP_TOP0_DPP_CRC_VAL_B_A), REG_READ(DPP_TOP0_DPP_CRC_VAL_R_G));
 }
 
-static void dcn10_log_hubbub_state(struct dc *dc)
+void dcn10_log_hubbub_state(struct dc *dc)
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	struct dcn_hubbub_wm wm;
@@ -157,7 +108,7 @@ static void dcn10_log_hubbub_state(struct dc *dc)
 	DTN_INFO("\n");
 }
 
-static void dcn10_log_hw_state(struct dc *dc)
+void dcn10_log_hw_state(struct dc *dc)
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	struct resource_pool *pool = dc->res_pool;
@@ -241,97 +192,6 @@ static void dcn10_log_hw_state(struct dc *dc)
 	DTN_INFO_END();
 }
 
-static void verify_allow_pstate_change_high(
-	struct dce_hwseq *hws)
-{
-	/* pstate latency is ~20us so if we wait over 40us and pstate allow
-	 * still not asserted, we are probably stuck and going to hang
-	 *
-	 * TODO: Figure out why it takes ~100us on linux
-	 * pstate takes around ~100us on linux. Unknown currently as to
-	 * why it takes that long on linux
-	 */
-	static unsigned int pstate_wait_timeout_us = 200;
-	static unsigned int pstate_wait_expected_timeout_us = 40;
-	static unsigned int max_sampled_pstate_wait_us; /* data collection */
-	static bool forced_pstate_allow; /* help with revert wa */
-	static bool should_log_hw_state; /* prevent hw state log by default */
-
-	unsigned int debug_index = 0x7;
-	unsigned int debug_data;
-	unsigned int i;
-
-	if (forced_pstate_allow) {
-		/* we hacked to force pstate allow to prevent hang last time
-		 * we verify_allow_pstate_change_high.  so disable force
-		 * here so we can check status
-		 */
-		REG_UPDATE_2(DCHUBBUB_ARB_DRAM_STATE_CNTL,
-			     DCHUBBUB_ARB_ALLOW_PSTATE_CHANGE_FORCE_VALUE, 0,
-			     DCHUBBUB_ARB_ALLOW_PSTATE_CHANGE_FORCE_ENABLE, 0);
-		forced_pstate_allow = false;
-	}
-
-	/* description "3-0:   Pipe0 cursor0 QOS
-	 * 7-4:   Pipe1 cursor0 QOS
-	 * 11-8:  Pipe2 cursor0 QOS
-	 * 15-12: Pipe3 cursor0 QOS
-	 * 16:    Pipe0 Plane0 Allow Pstate Change
-	 * 17:    Pipe1 Plane0 Allow Pstate Change
-	 * 18:    Pipe2 Plane0 Allow Pstate Change
-	 * 19:    Pipe3 Plane0 Allow Pstate Change
-	 * 20:    Pipe0 Plane1 Allow Pstate Change
-	 * 21:    Pipe1 Plane1 Allow Pstate Change
-	 * 22:    Pipe2 Plane1 Allow Pstate Change
-	 * 23:    Pipe3 Plane1 Allow Pstate Change
-	 * 24:    Pipe0 cursor0 Allow Pstate Change
-	 * 25:    Pipe1 cursor0 Allow Pstate Change
-	 * 26:    Pipe2 cursor0 Allow Pstate Change
-	 * 27:    Pipe3 cursor0 Allow Pstate Change
-	 * 28:    WB0 Allow Pstate Change
-	 * 29:    WB1 Allow Pstate Change
-	 * 30:    Arbiter's allow_pstate_change
-	 * 31:    SOC pstate change request
-	 */
-
-	REG_WRITE(DCHUBBUB_TEST_DEBUG_INDEX, debug_index);
-
-	for (i = 0; i < pstate_wait_timeout_us; i++) {
-		debug_data = REG_READ(DCHUBBUB_TEST_DEBUG_DATA);
-
-		if (debug_data & (1 << 30)) {
-
-			if (i > pstate_wait_expected_timeout_us)
-				dm_logger_write(hws->ctx->logger, LOG_WARNING,
-						"pstate took longer than expected ~%dus\n",
-						i);
-
-			return;
-		}
-		if (max_sampled_pstate_wait_us < i)
-			max_sampled_pstate_wait_us = i;
-
-		udelay(1);
-	}
-
-	/* force pstate allow to prevent system hang
-	 * and break to debugger to investigate
-	 */
-	REG_UPDATE_2(DCHUBBUB_ARB_DRAM_STATE_CNTL,
-		     DCHUBBUB_ARB_ALLOW_PSTATE_CHANGE_FORCE_VALUE, 1,
-		     DCHUBBUB_ARB_ALLOW_PSTATE_CHANGE_FORCE_ENABLE, 1);
-	forced_pstate_allow = true;
-
-	if (should_log_hw_state) {
-		dcn10_log_hw_state(hws->ctx->dc);
-	}
-
-	dm_logger_write(hws->ctx->logger, LOG_WARNING,
-			"pstate TEST_DEBUG_DATA: 0x%X\n",
-			debug_data);
-	BREAK_TO_DEBUGGER();
-}
-
 static void enable_dppclk(
 	struct dce_hwseq *hws,
 	uint8_t plane_id,
@@ -433,312 +293,6 @@ static void dpp_pg_control(
 	}
 }
 
-static uint32_t convert_and_clamp(
-	uint32_t wm_ns,
-	uint32_t refclk_mhz,
-	uint32_t clamp_value)
-{
-	uint32_t ret_val = 0;
-	ret_val = wm_ns * refclk_mhz;
-	ret_val /= 1000;
-
-	if (ret_val > clamp_value)
-		ret_val = clamp_value;
-
-	return ret_val;
-}
-
-static void program_watermarks(
-		struct dce_hwseq *hws,
-		struct dcn_watermark_set *watermarks,
-		unsigned int refclk_mhz)
-{
-	uint32_t force_en = hws->ctx->dc->debug.disable_stutter ? 1 : 0;
-	/*
-	 * Need to clamp to max of the register values (i.e. no wrap)
-	 * for dcn1, all wm registers are 21-bit wide
-	 */
-	uint32_t prog_wm_value;
-
-	REG_UPDATE(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,
-			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, 0);
-
-	/* Repeat for water mark set A, B, C and D. */
-	/* clock state A */
-	prog_wm_value = convert_and_clamp(watermarks->a.urgent_ns,
-			refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_A, prog_wm_value);
-
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"URGENCY_WATERMARK_A calculated =%d\n"
-		"HW register value = 0x%x\n",
-		watermarks->a.urgent_ns, prog_wm_value);
-
-	prog_wm_value = convert_and_clamp(watermarks->a.pte_meta_urgent_ns,
-			refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_A, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"PTE_META_URGENCY_WATERMARK_A calculated =%d\n"
-		"HW register value = 0x%x\n",
-		watermarks->a.pte_meta_urgent_ns, prog_wm_value);
-
-	if (REG(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A)) {
-		prog_wm_value = convert_and_clamp(
-				watermarks->a.cstate_pstate.cstate_enter_plus_exit_ns,
-				refclk_mhz, 0x1fffff);
-		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A, prog_wm_value);
-		dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-			"SR_ENTER_EXIT_WATERMARK_A calculated =%d\n"
-			"HW register value = 0x%x\n",
-			watermarks->a.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
-
-
-		prog_wm_value = convert_and_clamp(
-				watermarks->a.cstate_pstate.cstate_exit_ns,
-				refclk_mhz, 0x1fffff);
-		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_A, prog_wm_value);
-		dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-			"SR_EXIT_WATERMARK_A calculated =%d\n"
-			"HW register value = 0x%x\n",
-			watermarks->a.cstate_pstate.cstate_exit_ns, prog_wm_value);
-	}
-
-	prog_wm_value = convert_and_clamp(
-			watermarks->a.cstate_pstate.pstate_change_ns,
-			refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_A, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"DRAM_CLK_CHANGE_WATERMARK_A calculated =%d\n"
-		"HW register value = 0x%x\n\n",
-		watermarks->a.cstate_pstate.pstate_change_ns, prog_wm_value);
-
-
-	/* clock state B */
-	prog_wm_value = convert_and_clamp(
-			watermarks->b.urgent_ns, refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_B, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"URGENCY_WATERMARK_B calculated =%d\n"
-		"HW register value = 0x%x\n",
-		watermarks->b.urgent_ns, prog_wm_value);
-
-
-	prog_wm_value = convert_and_clamp(
-			watermarks->b.pte_meta_urgent_ns,
-			refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_B, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"PTE_META_URGENCY_WATERMARK_B calculated =%d\n"
-		"HW register value = 0x%x\n",
-		watermarks->b.pte_meta_urgent_ns, prog_wm_value);
-
-
-	if (REG(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B)) {
-		prog_wm_value = convert_and_clamp(
-				watermarks->b.cstate_pstate.cstate_enter_plus_exit_ns,
-				refclk_mhz, 0x1fffff);
-		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B, prog_wm_value);
-		dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-			"SR_ENTER_WATERMARK_B calculated =%d\n"
-			"HW register value = 0x%x\n",
-			watermarks->b.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
-
-
-		prog_wm_value = convert_and_clamp(
-				watermarks->b.cstate_pstate.cstate_exit_ns,
-				refclk_mhz, 0x1fffff);
-		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_B, prog_wm_value);
-		dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-			"SR_EXIT_WATERMARK_B calculated =%d\n"
-			"HW register value = 0x%x\n",
-			watermarks->b.cstate_pstate.cstate_exit_ns, prog_wm_value);
-	}
-
-	prog_wm_value = convert_and_clamp(
-			watermarks->b.cstate_pstate.pstate_change_ns,
-			refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_B, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"DRAM_CLK_CHANGE_WATERMARK_B calculated =%d\n\n"
-		"HW register value = 0x%x\n",
-		watermarks->b.cstate_pstate.pstate_change_ns, prog_wm_value);
-
-	/* clock state C */
-	prog_wm_value = convert_and_clamp(
-			watermarks->c.urgent_ns, refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_C, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"URGENCY_WATERMARK_C calculated =%d\n"
-		"HW register value = 0x%x\n",
-		watermarks->c.urgent_ns, prog_wm_value);
-
-
-	prog_wm_value = convert_and_clamp(
-			watermarks->c.pte_meta_urgent_ns,
-			refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_C, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"PTE_META_URGENCY_WATERMARK_C calculated =%d\n"
-		"HW register value = 0x%x\n",
-		watermarks->c.pte_meta_urgent_ns, prog_wm_value);
-
-
-	if (REG(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C)) {
-		prog_wm_value = convert_and_clamp(
-				watermarks->c.cstate_pstate.cstate_enter_plus_exit_ns,
-				refclk_mhz, 0x1fffff);
-		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C, prog_wm_value);
-		dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-			"SR_ENTER_WATERMARK_C calculated =%d\n"
-			"HW register value = 0x%x\n",
-			watermarks->c.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
-
-
-		prog_wm_value = convert_and_clamp(
-				watermarks->c.cstate_pstate.cstate_exit_ns,
-				refclk_mhz, 0x1fffff);
-		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_C, prog_wm_value);
-		dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-			"SR_EXIT_WATERMARK_C calculated =%d\n"
-			"HW register value = 0x%x\n",
-			watermarks->c.cstate_pstate.cstate_exit_ns, prog_wm_value);
-	}
-
-	prog_wm_value = convert_and_clamp(
-			watermarks->c.cstate_pstate.pstate_change_ns,
-			refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_C, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"DRAM_CLK_CHANGE_WATERMARK_C calculated =%d\n\n"
-		"HW register value = 0x%x\n",
-		watermarks->c.cstate_pstate.pstate_change_ns, prog_wm_value);
-
-	/* clock state D */
-	prog_wm_value = convert_and_clamp(
-			watermarks->d.urgent_ns, refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_D, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"URGENCY_WATERMARK_D calculated =%d\n"
-		"HW register value = 0x%x\n",
-		watermarks->d.urgent_ns, prog_wm_value);
-
-	prog_wm_value = convert_and_clamp(
-			watermarks->d.pte_meta_urgent_ns,
-			refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_D, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"PTE_META_URGENCY_WATERMARK_D calculated =%d\n"
-		"HW register value = 0x%x\n",
-		watermarks->d.pte_meta_urgent_ns, prog_wm_value);
-
-
-	if (REG(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D)) {
-		prog_wm_value = convert_and_clamp(
-				watermarks->d.cstate_pstate.cstate_enter_plus_exit_ns,
-				refclk_mhz, 0x1fffff);
-		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D, prog_wm_value);
-		dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-			"SR_ENTER_WATERMARK_D calculated =%d\n"
-			"HW register value = 0x%x\n",
-			watermarks->d.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
-
-
-		prog_wm_value = convert_and_clamp(
-				watermarks->d.cstate_pstate.cstate_exit_ns,
-				refclk_mhz, 0x1fffff);
-		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_D, prog_wm_value);
-		dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-			"SR_EXIT_WATERMARK_D calculated =%d\n"
-			"HW register value = 0x%x\n",
-			watermarks->d.cstate_pstate.cstate_exit_ns, prog_wm_value);
-	}
-
-
-	prog_wm_value = convert_and_clamp(
-			watermarks->d.cstate_pstate.pstate_change_ns,
-			refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_D, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"DRAM_CLK_CHANGE_WATERMARK_D calculated =%d\n"
-		"HW register value = 0x%x\n\n",
-		watermarks->d.cstate_pstate.pstate_change_ns, prog_wm_value);
-
-	REG_UPDATE(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,
-			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, 1);
-
-	REG_UPDATE(DCHUBBUB_ARB_SAT_LEVEL,
-			DCHUBBUB_ARB_SAT_LEVEL, 60 * refclk_mhz);
-	REG_UPDATE(DCHUBBUB_ARB_DF_REQ_OUTSTAND,
-			DCHUBBUB_ARB_MIN_REQ_OUTSTAND, 68);
-
-	REG_UPDATE_2(DCHUBBUB_ARB_DRAM_STATE_CNTL,
-			DCHUBBUB_ARB_ALLOW_SELF_REFRESH_FORCE_VALUE, 0,
-			DCHUBBUB_ARB_ALLOW_SELF_REFRESH_FORCE_ENABLE, force_en);
-
-#if 0
-	REG_UPDATE_2(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,
-			DCHUBBUB_ARB_WATERMARK_CHANGE_DONE_INTERRUPT_DISABLE, 1,
-			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, 1);
-#endif
-}
-
-
-static void dcn10_update_dchub(
-	struct dce_hwseq *hws,
-	struct dchub_init_data *dh_data)
-{
-	/* TODO: port code from dal2 */
-	switch (dh_data->fb_mode) {
-	case FRAME_BUFFER_MODE_ZFB_ONLY:
-		/*For ZFB case need to put DCHUB FB BASE and TOP upside down to indicate ZFB mode*/
-		REG_UPDATE(DCHUBBUB_SDPIF_FB_TOP,
-				SDPIF_FB_TOP, 0);
-
-		REG_UPDATE(DCHUBBUB_SDPIF_FB_BASE,
-				SDPIF_FB_BASE, 0x0FFFF);
-
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,
-				SDPIF_AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
-
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,
-				SDPIF_AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
-
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,
-				SDPIF_AGP_TOP, (dh_data->zfb_mc_base_addr +
-						dh_data->zfb_size_in_byte - 1) >> 22);
-		break;
-	case FRAME_BUFFER_MODE_MIXED_ZFB_AND_LOCAL:
-		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
-
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,
-				SDPIF_AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
-
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,
-				SDPIF_AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
-
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,
-				SDPIF_AGP_TOP, (dh_data->zfb_mc_base_addr +
-						dh_data->zfb_size_in_byte - 1) >> 22);
-		break;
-	case FRAME_BUFFER_MODE_LOCAL_ONLY:
-		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,
-				SDPIF_AGP_BASE, 0);
-
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,
-				SDPIF_AGP_BOT, 0X03FFFF);
-
-		REG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,
-				SDPIF_AGP_TOP, 0);
-		break;
-	default:
-		break;
-	}
-
-	dh_data->dchub_initialzied = true;
-	dh_data->dchub_info_valid = false;
-}
-
 static void hubp_pg_control(
 		struct dce_hwseq *hws,
 		unsigned int hubp_inst,
@@ -1337,21 +891,7 @@ static bool patch_address_for_sbs_tb_stereo(
 	return false;
 }
 
-static void toggle_watermark_change_req(struct dce_hwseq *hws)
-{
-	uint32_t watermark_change_req;
-
-	REG_GET(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,
-			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, &watermark_change_req);
 
-	if (watermark_change_req)
-		watermark_change_req = 0;
-	else
-		watermark_change_req = 1;
-
-	REG_UPDATE(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,
-			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, watermark_change_req);
-}
 
 static void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_ctx)
 {

commit 4952d4c584ba769919866c27b442c4239ef20a12
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Wed Oct 18 16:14:40 2017 -0400

    drm/amd/display: DMCU FW loading from PSP
    
    Update the programming sequence to allow DMCU firmware to be loaded by
    PSP. This code detects whether the firmware is loaded and does a check
    to verify the expected interface version and checks for correct response
    from micro controller.
    
    Added registry key method to allow force loading of firmware from kernel
    mode driver for test purposes. This is old method of firmware loading
    without PSP.
    
    Moved some init sequences into dc/dmcu.
    
    Changed loading sequence to initialize IRAM after firmware completely
    loaded. Firmware will now disable features that use IRAM
    until initialized.
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 40178d8251b8..cd9e5484738d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -31,6 +31,7 @@
 #include "dce110/dce110_hw_sequencer.h"
 #include "dce/dce_hwseq.h"
 #include "abm.h"
+#include "dmcu.h"
 #include "dcn10/dcn10_timing_generator.h"
 #include "dcn10/dcn10_dpp.h"
 #include "dcn10/dcn10_mpc.h"
@@ -863,6 +864,7 @@ static void dcn10_init_hw(struct dc *dc)
 {
 	int i;
 	struct abm *abm = dc->res_pool->abm;
+	struct dmcu *dmcu = dc->res_pool->dmcu;
 	struct dce_hwseq *hws = dc->hwseq;
 
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
@@ -925,6 +927,9 @@ static void dcn10_init_hw(struct dc *dc)
 		abm->funcs->abm_init(abm);
 	}
 
+	if (dmcu != NULL)
+		dmcu->funcs->dmcu_init(dmcu);
+
 	/* power AFMT HDMI memory TODO: may move to dis/en output save power*/
 	REG_WRITE(DIO_MEM_PWR_CTRL, 0);
 

commit 7d2638a61ad16aa7145cd3b68ae5757ab988ccab
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Oct 18 11:59:13 2017 -0400

    drm/amd/display: Set cursor position as per address.
    
    In case of pipe split, cursor position should also be
    programmed as per cursor address.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index b477a6508db4..40178d8251b8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2414,7 +2414,6 @@ static void program_all_pipe_in_tree(
 	}
 
 	if (pipe_ctx->plane_state != NULL) {
-		struct dc_cursor_position position = { 0 };
 		struct pipe_ctx *cur_pipe_ctx =
 				&dc->current_state->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
 
@@ -2434,11 +2433,13 @@ static void program_all_pipe_in_tree(
 		update_dchubp_dpp(dc, pipe_ctx, context);
 
 		/* TODO: this is a hack w/a for switching from mpo to pipe split */
-		dc_stream_set_cursor_position(pipe_ctx->stream, &position);
+		if (pipe_ctx->stream->cursor_attributes.address.quad_part != 0) {
+			struct dc_cursor_position position = { 0 };
 
-		if (pipe_ctx->stream->cursor_attributes.address.quad_part != 0)
+			dc_stream_set_cursor_position(pipe_ctx->stream, &position);
 			dc_stream_set_cursor_attributes(pipe_ctx->stream,
 				&pipe_ctx->stream->cursor_attributes);
+		}
 
 		if (cur_pipe_ctx->plane_state != pipe_ctx->plane_state) {
 			dc->hwss.set_input_transfer_func(

commit 4c7d45fae841a7f3e2d129185acf66f1c7ae37e5
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Oct 17 14:54:58 2017 -0400

    drm/amd/display: Check cursor address before program.
    
    Program cursor attributes during set mode is only needed
    in case of pipe slipt, bottom pipe should be programmed
    same as top pipe. Need to program if address is 0.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index ac731c46419d..b477a6508db4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2436,7 +2436,8 @@ static void program_all_pipe_in_tree(
 		/* TODO: this is a hack w/a for switching from mpo to pipe split */
 		dc_stream_set_cursor_position(pipe_ctx->stream, &position);
 
-		dc_stream_set_cursor_attributes(pipe_ctx->stream,
+		if (pipe_ctx->stream->cursor_attributes.address.quad_part != 0)
+			dc_stream_set_cursor_attributes(pipe_ctx->stream,
 				&pipe_ctx->stream->cursor_attributes);
 
 		if (cur_pipe_ctx->plane_state != pipe_ctx->plane_state) {

commit 3dc780ec3473200ef870eae9b19169445d76be4c
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Oct 17 14:48:11 2017 -0400

    drm/amd/display: Move lock to front end program.
    
    Moved lock and unlock to apply_ctx_to_surface, since all
    the front end programming is within apply_ctx_to_surface.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 961ad5c3b454..ac731c46419d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2550,6 +2550,11 @@ static void dcn10_apply_ctx_for_surface(
 		if (!pipe_ctx->plane_state && !old_pipe_ctx->plane_state)
 			continue;
 
+		if (pipe_ctx->stream_res.tg &&
+			pipe_ctx->stream_res.tg->inst == be_idx &&
+			!pipe_ctx->top_pipe)
+			pipe_ctx->stream_res.tg->funcs->lock(pipe_ctx->stream_res.tg);
+
 		/*
 		 * Powergate reused pipes that are not powergated
 		 * fairly hacky right now, using opp_id as indicator
@@ -2605,13 +2610,19 @@ static void dcn10_apply_ctx_for_surface(
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *old_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->stream != stream)
 			continue;
 
 		/* looking for top pipe to program */
-		if (!pipe_ctx->top_pipe)
+		if (!pipe_ctx->top_pipe) {
 			program_all_pipe_in_tree(dc, pipe_ctx, context);
+			if (pipe_ctx->stream_res.tg &&
+				pipe_ctx->stream_res.tg->inst == be_idx &&
+				(pipe_ctx->plane_state || old_pipe_ctx->plane_state))
+				pipe_ctx->stream_res.tg->funcs->unlock(pipe_ctx->stream_res.tg);
+		}
 	}
 
 	dm_logger_write(dc->ctx->logger, LOG_BANDWIDTH_CALCS,

commit e99a30de13822685110cfc843a07a035d4aa6253
Author: Ken Chalmers <ken.chalmers@amd.com>
Date:   Thu Nov 2 10:45:12 2017 -0400

    drm/amd/display: use num_timing_generator instead of pipe_count
    
    The two are not necessarily the same.
    
    Signed-off-by: Ken Chalmers <ken.chalmers@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 63c2f5266142..961ad5c3b454 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -202,7 +202,7 @@ static void dcn10_log_hw_state(struct dc *dc)
 	DTN_INFO("OTG:\t v_bs \t v_be \t v_ss \t v_se \t vpol \t vmax \t vmin \t "
 			"h_bs \t h_be \t h_ss \t h_se \t hpol \t htot \t vtot \t underflow\n");
 
-	for (i = 0; i < pool->pipe_count; i++) {
+	for (i = 0; i < pool->res_cap->num_timing_generator; i++) {
 		struct timing_generator *tg = pool->timing_generators[i];
 		struct dcn_otg_state s = {0};
 

commit 3eea71e36fcd04d0a3e735ee3cf4dbbe9934e3c8
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Oct 12 22:45:25 2017 -0400

    drm/amd/display: Minor update to DML
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 741b5e06d314..63c2f5266142 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2015,10 +2015,11 @@ static void dcn10_power_on_fe(
 				plane_state->dst_rect.height);
 
 		dm_logger_write(dc->ctx->logger, LOG_DC,
-				"Pipe %d: width, height, x, y\n"
+				"Pipe %d: width, height, x, y         format:%d\n"
 				"viewport:%d, %d, %d, %d\n"
 				"recout:  %d, %d, %d, %d\n",
 				pipe_ctx->pipe_idx,
+				plane_state->format,
 				pipe_ctx->plane_res.scl_data.viewport.width,
 				pipe_ctx->plane_res.scl_data.viewport.height,
 				pipe_ctx->plane_res.scl_data.viewport.x,

commit 9a5bcd47ea0eb40c8a9e00f6797453c90fbd74d1
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Wed Oct 11 15:14:46 2017 -0400

    drm/amd/display: check SR_WATERMARK regs prior to write
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 6e2cec643f31..741b5e06d314 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -481,27 +481,26 @@ static void program_watermarks(
 		"HW register value = 0x%x\n",
 		watermarks->a.pte_meta_urgent_ns, prog_wm_value);
 
-
-	prog_wm_value = convert_and_clamp(
-			watermarks->a.cstate_pstate.cstate_enter_plus_exit_ns,
-			refclk_mhz, 0x1fffff);
-
-	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"SR_ENTER_EXIT_WATERMARK_A calculated =%d\n"
-		"HW register value = 0x%x\n",
-		watermarks->a.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
-
-
-	prog_wm_value = convert_and_clamp(
-			watermarks->a.cstate_pstate.cstate_exit_ns,
-			refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_A, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"SR_EXIT_WATERMARK_A calculated =%d\n"
-		"HW register value = 0x%x\n",
-		watermarks->a.cstate_pstate.cstate_exit_ns, prog_wm_value);
-
+	if (REG(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A)) {
+		prog_wm_value = convert_and_clamp(
+				watermarks->a.cstate_pstate.cstate_enter_plus_exit_ns,
+				refclk_mhz, 0x1fffff);
+		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A, prog_wm_value);
+		dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
+			"SR_ENTER_EXIT_WATERMARK_A calculated =%d\n"
+			"HW register value = 0x%x\n",
+			watermarks->a.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
+
+
+		prog_wm_value = convert_and_clamp(
+				watermarks->a.cstate_pstate.cstate_exit_ns,
+				refclk_mhz, 0x1fffff);
+		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_A, prog_wm_value);
+		dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
+			"SR_EXIT_WATERMARK_A calculated =%d\n"
+			"HW register value = 0x%x\n",
+			watermarks->a.cstate_pstate.cstate_exit_ns, prog_wm_value);
+	}
 
 	prog_wm_value = convert_and_clamp(
 			watermarks->a.cstate_pstate.pstate_change_ns,
@@ -533,24 +532,26 @@ static void program_watermarks(
 		watermarks->b.pte_meta_urgent_ns, prog_wm_value);
 
 
-	prog_wm_value = convert_and_clamp(
-			watermarks->b.cstate_pstate.cstate_enter_plus_exit_ns,
-			refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"SR_ENTER_WATERMARK_B calculated =%d\n"
-		"HW register value = 0x%x\n",
-		watermarks->b.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
+	if (REG(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B)) {
+		prog_wm_value = convert_and_clamp(
+				watermarks->b.cstate_pstate.cstate_enter_plus_exit_ns,
+				refclk_mhz, 0x1fffff);
+		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B, prog_wm_value);
+		dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
+			"SR_ENTER_WATERMARK_B calculated =%d\n"
+			"HW register value = 0x%x\n",
+			watermarks->b.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
 
 
-	prog_wm_value = convert_and_clamp(
-			watermarks->b.cstate_pstate.cstate_exit_ns,
-			refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_B, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"SR_EXIT_WATERMARK_B calculated =%d\n"
-		"HW register value = 0x%x\n",
-		watermarks->b.cstate_pstate.cstate_exit_ns, prog_wm_value);
+		prog_wm_value = convert_and_clamp(
+				watermarks->b.cstate_pstate.cstate_exit_ns,
+				refclk_mhz, 0x1fffff);
+		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_B, prog_wm_value);
+		dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
+			"SR_EXIT_WATERMARK_B calculated =%d\n"
+			"HW register value = 0x%x\n",
+			watermarks->b.cstate_pstate.cstate_exit_ns, prog_wm_value);
+	}
 
 	prog_wm_value = convert_and_clamp(
 			watermarks->b.cstate_pstate.pstate_change_ns,
@@ -581,25 +582,26 @@ static void program_watermarks(
 		watermarks->c.pte_meta_urgent_ns, prog_wm_value);
 
 
-	prog_wm_value = convert_and_clamp(
-			watermarks->c.cstate_pstate.cstate_enter_plus_exit_ns,
-			refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"SR_ENTER_WATERMARK_C calculated =%d\n"
-		"HW register value = 0x%x\n",
-		watermarks->c.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
+	if (REG(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C)) {
+		prog_wm_value = convert_and_clamp(
+				watermarks->c.cstate_pstate.cstate_enter_plus_exit_ns,
+				refclk_mhz, 0x1fffff);
+		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C, prog_wm_value);
+		dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
+			"SR_ENTER_WATERMARK_C calculated =%d\n"
+			"HW register value = 0x%x\n",
+			watermarks->c.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
 
 
-	prog_wm_value = convert_and_clamp(
-			watermarks->c.cstate_pstate.cstate_exit_ns,
-			refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_C, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"SR_EXIT_WATERMARK_C calculated =%d\n"
-		"HW register value = 0x%x\n",
-		watermarks->c.cstate_pstate.cstate_exit_ns, prog_wm_value);
-
+		prog_wm_value = convert_and_clamp(
+				watermarks->c.cstate_pstate.cstate_exit_ns,
+				refclk_mhz, 0x1fffff);
+		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_C, prog_wm_value);
+		dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
+			"SR_EXIT_WATERMARK_C calculated =%d\n"
+			"HW register value = 0x%x\n",
+			watermarks->c.cstate_pstate.cstate_exit_ns, prog_wm_value);
+	}
 
 	prog_wm_value = convert_and_clamp(
 			watermarks->c.cstate_pstate.pstate_change_ns,
@@ -629,24 +631,26 @@ static void program_watermarks(
 		watermarks->d.pte_meta_urgent_ns, prog_wm_value);
 
 
-	prog_wm_value = convert_and_clamp(
-			watermarks->d.cstate_pstate.cstate_enter_plus_exit_ns,
-			refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"SR_ENTER_WATERMARK_D calculated =%d\n"
-		"HW register value = 0x%x\n",
-		watermarks->d.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
+	if (REG(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D)) {
+		prog_wm_value = convert_and_clamp(
+				watermarks->d.cstate_pstate.cstate_enter_plus_exit_ns,
+				refclk_mhz, 0x1fffff);
+		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D, prog_wm_value);
+		dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
+			"SR_ENTER_WATERMARK_D calculated =%d\n"
+			"HW register value = 0x%x\n",
+			watermarks->d.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
 
 
-	prog_wm_value = convert_and_clamp(
-			watermarks->d.cstate_pstate.cstate_exit_ns,
-			refclk_mhz, 0x1fffff);
-	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_D, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
-		"SR_EXIT_WATERMARK_D calculated =%d\n"
-		"HW register value = 0x%x\n",
-		watermarks->d.cstate_pstate.cstate_exit_ns, prog_wm_value);
+		prog_wm_value = convert_and_clamp(
+				watermarks->d.cstate_pstate.cstate_exit_ns,
+				refclk_mhz, 0x1fffff);
+		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_D, prog_wm_value);
+		dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
+			"SR_EXIT_WATERMARK_D calculated =%d\n"
+			"HW register value = 0x%x\n",
+			watermarks->d.cstate_pstate.cstate_exit_ns, prog_wm_value);
+	}
 
 
 	prog_wm_value = convert_and_clamp(

commit 215a6f05bcc18ffcd953a8527639ea1f571f4d81
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Oct 6 15:40:07 2017 -0400

    drm/amd/display: add performance trace macro to dc
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index b69884549fc5..6e2cec643f31 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -468,7 +468,7 @@ static void program_watermarks(
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_A, prog_wm_value);
 
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"URGENCY_WATERMARK_A calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->a.urgent_ns, prog_wm_value);
@@ -476,7 +476,7 @@ static void program_watermarks(
 	prog_wm_value = convert_and_clamp(watermarks->a.pte_meta_urgent_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_A, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"PTE_META_URGENCY_WATERMARK_A calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->a.pte_meta_urgent_ns, prog_wm_value);
@@ -487,7 +487,7 @@ static void program_watermarks(
 			refclk_mhz, 0x1fffff);
 
 	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"SR_ENTER_EXIT_WATERMARK_A calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->a.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
@@ -497,7 +497,7 @@ static void program_watermarks(
 			watermarks->a.cstate_pstate.cstate_exit_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_A, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"SR_EXIT_WATERMARK_A calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->a.cstate_pstate.cstate_exit_ns, prog_wm_value);
@@ -507,7 +507,7 @@ static void program_watermarks(
 			watermarks->a.cstate_pstate.pstate_change_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_A, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"DRAM_CLK_CHANGE_WATERMARK_A calculated =%d\n"
 		"HW register value = 0x%x\n\n",
 		watermarks->a.cstate_pstate.pstate_change_ns, prog_wm_value);
@@ -517,7 +517,7 @@ static void program_watermarks(
 	prog_wm_value = convert_and_clamp(
 			watermarks->b.urgent_ns, refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_B, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"URGENCY_WATERMARK_B calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->b.urgent_ns, prog_wm_value);
@@ -527,7 +527,7 @@ static void program_watermarks(
 			watermarks->b.pte_meta_urgent_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_B, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"PTE_META_URGENCY_WATERMARK_B calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->b.pte_meta_urgent_ns, prog_wm_value);
@@ -537,7 +537,7 @@ static void program_watermarks(
 			watermarks->b.cstate_pstate.cstate_enter_plus_exit_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"SR_ENTER_WATERMARK_B calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->b.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
@@ -547,7 +547,7 @@ static void program_watermarks(
 			watermarks->b.cstate_pstate.cstate_exit_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_B, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"SR_EXIT_WATERMARK_B calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->b.cstate_pstate.cstate_exit_ns, prog_wm_value);
@@ -556,7 +556,7 @@ static void program_watermarks(
 			watermarks->b.cstate_pstate.pstate_change_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_B, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"DRAM_CLK_CHANGE_WATERMARK_B calculated =%d\n\n"
 		"HW register value = 0x%x\n",
 		watermarks->b.cstate_pstate.pstate_change_ns, prog_wm_value);
@@ -565,7 +565,7 @@ static void program_watermarks(
 	prog_wm_value = convert_and_clamp(
 			watermarks->c.urgent_ns, refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_C, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"URGENCY_WATERMARK_C calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->c.urgent_ns, prog_wm_value);
@@ -575,7 +575,7 @@ static void program_watermarks(
 			watermarks->c.pte_meta_urgent_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_C, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"PTE_META_URGENCY_WATERMARK_C calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->c.pte_meta_urgent_ns, prog_wm_value);
@@ -585,7 +585,7 @@ static void program_watermarks(
 			watermarks->c.cstate_pstate.cstate_enter_plus_exit_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"SR_ENTER_WATERMARK_C calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->c.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
@@ -595,7 +595,7 @@ static void program_watermarks(
 			watermarks->c.cstate_pstate.cstate_exit_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_C, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"SR_EXIT_WATERMARK_C calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->c.cstate_pstate.cstate_exit_ns, prog_wm_value);
@@ -605,7 +605,7 @@ static void program_watermarks(
 			watermarks->c.cstate_pstate.pstate_change_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_C, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"DRAM_CLK_CHANGE_WATERMARK_C calculated =%d\n\n"
 		"HW register value = 0x%x\n",
 		watermarks->c.cstate_pstate.pstate_change_ns, prog_wm_value);
@@ -614,7 +614,7 @@ static void program_watermarks(
 	prog_wm_value = convert_and_clamp(
 			watermarks->d.urgent_ns, refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_D, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"URGENCY_WATERMARK_D calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->d.urgent_ns, prog_wm_value);
@@ -623,7 +623,7 @@ static void program_watermarks(
 			watermarks->d.pte_meta_urgent_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_D, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"PTE_META_URGENCY_WATERMARK_D calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->d.pte_meta_urgent_ns, prog_wm_value);
@@ -633,7 +633,7 @@ static void program_watermarks(
 			watermarks->d.cstate_pstate.cstate_enter_plus_exit_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"SR_ENTER_WATERMARK_D calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->d.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
@@ -643,7 +643,7 @@ static void program_watermarks(
 			watermarks->d.cstate_pstate.cstate_exit_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_D, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"SR_EXIT_WATERMARK_D calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->d.cstate_pstate.cstate_exit_ns, prog_wm_value);
@@ -653,7 +653,7 @@ static void program_watermarks(
 			watermarks->d.cstate_pstate.pstate_change_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_D, prog_wm_value);
-	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+	dm_logger_write(hws->ctx->logger, LOG_BANDWIDTH_CALCS,
 		"DRAM_CLK_CHANGE_WATERMARK_D calculated =%d\n"
 		"HW register value = 0x%x\n\n",
 		watermarks->d.cstate_pstate.pstate_change_ns, prog_wm_value);

commit d94585a06b8197a723787c6c5502872abcff0e8e
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Thu Oct 5 16:47:49 2017 -0400

    drm/amd/display: rename transform to dpp for dcn
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 6b866b169985..b69884549fc5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -895,10 +895,10 @@ static void dcn10_init_hw(struct dc *dc)
 	}
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct transform *xfm = dc->res_pool->transforms[i];
+		struct dpp *dpp = dc->res_pool->dpps[i];
 		struct timing_generator *tg = dc->res_pool->timing_generators[i];
 
-		xfm->funcs->transform_reset(xfm);
+		dpp->funcs->dpp_reset(dpp);
 		dc->res_pool->mpc->funcs->remove(
 				dc->res_pool->mpc, &(dc->res_pool->opps[i]->mpc_tree),
 				dc->res_pool->opps[i]->inst, i);
@@ -1146,14 +1146,14 @@ static void plane_atomic_disable(struct dc *dc,
 static void plane_atomic_power_down(struct dc *dc, int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
-	struct transform *xfm = dc->res_pool->transforms[fe_idx];
+	struct dpp *dpp = dc->res_pool->dpps[fe_idx];
 
 	if (REG(DC_IP_REQUEST_CNTL)) {
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 1);
 		dpp_pg_control(hws, fe_idx, false);
 		hubp_pg_control(hws, fe_idx, false);
-		xfm->funcs->transform_reset(xfm);
+		dpp->funcs->dpp_reset(dpp);
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 0);
 		dm_logger_write(dc->ctx->logger, LOG_DEBUG,
@@ -1203,7 +1203,7 @@ static void reset_front_end(
 static void dcn10_power_down_fe(struct dc *dc, int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
-	struct transform *xfm = dc->res_pool->transforms[fe_idx];
+	struct dpp *dpp = dc->res_pool->dpps[fe_idx];
 
 	reset_front_end(dc, fe_idx);
 
@@ -1211,7 +1211,7 @@ static void dcn10_power_down_fe(struct dc *dc, int fe_idx)
 			IP_REQUEST_EN, 1);
 	dpp_pg_control(hws, fe_idx, false);
 	hubp_pg_control(hws, fe_idx, false);
-	xfm->funcs->transform_reset(xfm);
+	dpp->funcs->dpp_reset(dpp);
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
 	dm_logger_write(dc->ctx->logger, LOG_DEBUG,
@@ -1365,34 +1365,34 @@ static void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_c
 static bool dcn10_set_input_transfer_func(
 	struct pipe_ctx *pipe_ctx, const struct dc_plane_state *plane_state)
 {
-	struct transform *xfm_base = pipe_ctx->plane_res.xfm;
+	struct dpp *dpp_base = pipe_ctx->plane_res.dpp;
 	const struct dc_transfer_func *tf = NULL;
 	bool result = true;
 
-	if (xfm_base == NULL)
+	if (dpp_base == NULL)
 		return false;
 
 	if (plane_state->in_transfer_func)
 		tf = plane_state->in_transfer_func;
 
 	if (plane_state->gamma_correction && dce_use_lut(plane_state))
-		xfm_base->funcs->ipp_program_input_lut(xfm_base,
+		dpp_base->funcs->ipp_program_input_lut(dpp_base,
 				plane_state->gamma_correction);
 
 	if (tf == NULL)
-		xfm_base->funcs->ipp_set_degamma(xfm_base, IPP_DEGAMMA_MODE_BYPASS);
+		dpp_base->funcs->ipp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);
 	else if (tf->type == TF_TYPE_PREDEFINED) {
 		switch (tf->tf) {
 		case TRANSFER_FUNCTION_SRGB:
-			xfm_base->funcs->ipp_set_degamma(xfm_base,
+			dpp_base->funcs->ipp_set_degamma(dpp_base,
 					IPP_DEGAMMA_MODE_HW_sRGB);
 			break;
 		case TRANSFER_FUNCTION_BT709:
-			xfm_base->funcs->ipp_set_degamma(xfm_base,
+			dpp_base->funcs->ipp_set_degamma(dpp_base,
 					IPP_DEGAMMA_MODE_HW_xvYCC);
 			break;
 		case TRANSFER_FUNCTION_LINEAR:
-			xfm_base->funcs->ipp_set_degamma(xfm_base,
+			dpp_base->funcs->ipp_set_degamma(dpp_base,
 					IPP_DEGAMMA_MODE_BYPASS);
 			break;
 		case TRANSFER_FUNCTION_PQ:
@@ -1403,7 +1403,7 @@ static bool dcn10_set_input_transfer_func(
 			break;
 		}
 	} else if (tf->type == TF_TYPE_BYPASS) {
-		xfm_base->funcs->ipp_set_degamma(xfm_base, IPP_DEGAMMA_MODE_BYPASS);
+		dpp_base->funcs->ipp_set_degamma(dpp_base, IPP_DEGAMMA_MODE_BYPASS);
 	} else {
 		/*TF_TYPE_DISTRIBUTED_POINTS*/
 		result = false;
@@ -1730,25 +1730,25 @@ static bool dcn10_set_output_transfer_func(
 	struct pipe_ctx *pipe_ctx,
 	const struct dc_stream_state *stream)
 {
-	struct transform *xfm = pipe_ctx->plane_res.xfm;
+	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 
-	if (xfm == NULL)
+	if (dpp == NULL)
 		return false;
 
-	xfm->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
+	dpp->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
 
 	if (stream->out_transfer_func &&
 		stream->out_transfer_func->type ==
 			TF_TYPE_PREDEFINED &&
 		stream->out_transfer_func->tf ==
 			TRANSFER_FUNCTION_SRGB) {
-		xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_SRGB);
+		dpp->funcs->opp_set_regamma_mode(dpp, OPP_REGAMMA_SRGB);
 	} else if (dcn10_translate_regamma_to_hw_format(
-				stream->out_transfer_func, &xfm->regamma_params)) {
-			xfm->funcs->opp_program_regamma_pwl(xfm, &xfm->regamma_params);
-			xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_USER);
+				stream->out_transfer_func, &dpp->regamma_params)) {
+			dpp->funcs->opp_program_regamma_pwl(dpp, &dpp->regamma_params);
+			dpp->funcs->opp_set_regamma_mode(dpp, OPP_REGAMMA_USER);
 	} else {
-		xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_BYPASS);
+		dpp->funcs->opp_set_regamma_mode(dpp, OPP_REGAMMA_BYPASS);
 	}
 
 	return true;
@@ -2033,7 +2033,7 @@ static void dcn10_power_on_fe(
 
 static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 {
-	struct xfm_grph_csc_adjustment adjust;
+	struct dpp_grph_csc_adjustment adjust;
 	memset(&adjust, 0, sizeof(adjust));
 	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
 
@@ -2069,7 +2069,7 @@ static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 				gamut_remap_matrix.matrix[10];
 	}
 
-	pipe_ctx->plane_res.xfm->funcs->transform_set_gamut_remap(pipe_ctx->plane_res.xfm, &adjust);
+	pipe_ctx->plane_res.dpp->funcs->dpp_set_gamut_remap(pipe_ctx->plane_res.dpp, &adjust);
 }
 
 
@@ -2091,7 +2091,7 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 
 			tbl_entry.color_space = color_space;
 			//tbl_entry.regval = matrix;
-			pipe_ctx->plane_res.xfm->funcs->opp_set_csc_adjustment(pipe_ctx->plane_res.xfm, &tbl_entry);
+			pipe_ctx->plane_res.dpp->funcs->opp_set_csc_adjustment(pipe_ctx->plane_res.dpp, &tbl_entry);
 	}
 }
 static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
@@ -2275,7 +2275,7 @@ static void update_dchubp_dpp(
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct hubp *hubp = pipe_ctx->plane_res.hubp;
-	struct transform *xfm = pipe_ctx->plane_res.xfm;
+	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	union plane_size size = plane_state->plane_size;
 	struct mpcc_cfg mpcc_cfg = {0};
@@ -2317,7 +2317,7 @@ static void update_dchubp_dpp(
 				hws
 				);
 
-	xfm->funcs->ipp_setup(xfm,
+	dpp->funcs->ipp_setup(dpp,
 			plane_state->format,
 			EXPANSION_MODE_ZERO);
 
@@ -2346,8 +2346,9 @@ static void update_dchubp_dpp(
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = per_pixel_alpha;
 	pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
 	/* scaler configuration */
-	pipe_ctx->plane_res.xfm->funcs->transform_set_scaler(
-			pipe_ctx->plane_res.xfm, &pipe_ctx->plane_res.scl_data);
+	pipe_ctx->plane_res.dpp->funcs->dpp_set_scaler(
+			pipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data);
+
 	hubp->funcs->mem_program_viewport(hubp,
 			&pipe_ctx->plane_res.scl_data.viewport, &pipe_ctx->plane_res.scl_data.viewport_c);
 

commit 86be9a0495c6b4ca8ec37b652152df947c155848
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Thu Oct 5 12:30:14 2017 -0400

    drm/amd/display: renaming filename for hubp
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 059da7882a68..6b866b169985 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -31,7 +31,6 @@
 #include "dce110/dce110_hw_sequencer.h"
 #include "dce/dce_hwseq.h"
 #include "abm.h"
-#include "dcn10/dcn10_mem_input.h"
 #include "dcn10/dcn10_timing_generator.h"
 #include "dcn10/dcn10_dpp.h"
 #include "dcn10/dcn10_mpc.h"
@@ -41,6 +40,7 @@
 #include "mpc.h"
 #include "reg_helper.h"
 #include "custom_float.h"
+#include "dcn10_hubp.h"
 
 #define CTX \
 	hws->ctx

commit e66a575508b5a11df7a670265c91981e4d735749
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Wed Oct 4 14:10:16 2017 -0400

    drm/amd/display: Add missing newlines in pstate wait debug messages
    
    These were spamming the debugger logs.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c34dbcd1fba4..059da7882a68 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -302,7 +302,7 @@ static void verify_allow_pstate_change_high(
 
 			if (i > pstate_wait_expected_timeout_us)
 				dm_logger_write(hws->ctx->logger, LOG_WARNING,
-						"pstate took longer than expected ~%dus",
+						"pstate took longer than expected ~%dus\n",
 						i);
 
 			return;
@@ -326,7 +326,7 @@ static void verify_allow_pstate_change_high(
 	}
 
 	dm_logger_write(hws->ctx->logger, LOG_WARNING,
-			"pstate TEST_DEBUG_DATA: 0x%X",
+			"pstate TEST_DEBUG_DATA: 0x%X\n",
 			debug_data);
 	BREAK_TO_DEBUGGER();
 }

commit 8feabd03d34e4555c119e69269dae28f52e0d86c
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Mon Oct 2 14:39:42 2017 -0400

    drm/amd/display: rename struct mem_input to hubp for dcn
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index ee63155c1895..c34dbcd1fba4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -172,10 +172,10 @@ static void dcn10_log_hw_state(struct dc *dc)
 			"min_ttu_vblank \t qos_low_wm \t qos_high_wm \n");
 
 	for (i = 0; i < pool->pipe_count; i++) {
-		struct mem_input *mi = pool->mis[i];
+		struct hubp *hubp = pool->hubps[i];
 		struct dcn_hubp_state s;
 
-		dcn10_mem_input_read_state(TO_DCN10_MEM_INPUT(mi), &s);
+		hubp1_read_state(TO_DCN10_HUBP(hubp), &s);
 
 		DTN_INFO("[%d]:\t %xh \t %xh \t %d \t %d \t "
 				"%xh \t %xh \t %xh \t "
@@ -803,7 +803,7 @@ static void power_on_plane(
 static void undo_DEGVIDCN10_253_wa(struct dc *dc)
 {
 	struct dce_hwseq *hws = dc->hwseq;
-	struct mem_input *mi = dc->res_pool->mis[0];
+	struct hubp *hubp = dc->res_pool->hubps[0];
 	int pwr_status = 0;
 
 	REG_GET(DOMAIN0_PG_STATUS, DOMAIN0_PGFSM_PWR_STATUS, &pwr_status);
@@ -811,7 +811,7 @@ static void undo_DEGVIDCN10_253_wa(struct dc *dc)
 	if (pwr_status == 2)
 		return;
 
-	mi->funcs->set_blank(mi, true);
+	hubp->funcs->set_blank(hubp, true);
 
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 1);
@@ -824,7 +824,7 @@ static void undo_DEGVIDCN10_253_wa(struct dc *dc)
 static void apply_DEGVIDCN10_253_wa(struct dc *dc)
 {
 	struct dce_hwseq *hws = dc->hwseq;
-	struct mem_input *mi = dc->res_pool->mis[0];
+	struct hubp *hubp = dc->res_pool->hubps[0];
 
 	if (dc->debug.disable_stutter)
 		return;
@@ -836,7 +836,7 @@ static void apply_DEGVIDCN10_253_wa(struct dc *dc)
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
 
-	mi->funcs->set_hubp_blank_en(mi, false);
+	hubp->funcs->set_hubp_blank_en(hubp, false);
 }
 
 static void bios_golden_init(struct dc *dc)
@@ -1070,7 +1070,7 @@ static void reset_back_end_for_pipe(
 static void plane_atomic_disconnect(struct dc *dc,
 		int fe_idx)
 {
-	struct mem_input *mi = dc->res_pool->mis[fe_idx];
+	struct hubp *hubp = dc->res_pool->hubps[fe_idx];
 	struct mpc *mpc = dc->res_pool->mpc;
 	int opp_id, z_idx;
 	int mpcc_id = -1;
@@ -1094,7 +1094,7 @@ static void plane_atomic_disconnect(struct dc *dc,
 
 	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
-	mi->funcs->dcc_control(mi, false, false);
+	hubp->funcs->dcc_control(hubp, false, false);
 	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
@@ -1108,20 +1108,20 @@ static void plane_atomic_disable(struct dc *dc,
 		int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
-	struct mem_input *mi = dc->res_pool->mis[fe_idx];
+	struct hubp *hubp = dc->res_pool->hubps[fe_idx];
 	struct mpc *mpc = dc->res_pool->mpc;
-	int opp_id = mi->opp_id;
+	int opp_id = hubp->opp_id;
 
 	if (opp_id == 0xf)
 		return;
 
-	mpc->funcs->wait_for_idle(mpc, mi->mpcc_id);
-	dc->res_pool->opps[mi->opp_id]->mpcc_disconnect_pending[mi->mpcc_id] = false;
+	mpc->funcs->wait_for_idle(mpc, hubp->mpcc_id);
+	dc->res_pool->opps[hubp->opp_id]->mpcc_disconnect_pending[hubp->mpcc_id] = false;
 	/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
 			"[debug_mpo: atomic disable finished on mpcc %d]\n",
 			fe_idx);*/
 
-	mi->funcs->set_blank(mi, true);
+	hubp->funcs->set_blank(hubp, true);
 
 	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
@@ -1171,7 +1171,7 @@ static void reset_front_end(
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct timing_generator *tg;
-	int opp_id = dc->res_pool->mis[fe_idx]->opp_id;
+	int opp_id = dc->res_pool->hubps[fe_idx]->opp_id;
 
 	/*Already reset*/
 	if (opp_id == 0xf)
@@ -1353,8 +1353,8 @@ static void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_c
 	if (plane_state == NULL)
 		return;
 	addr_patched = patch_address_for_sbs_tb_stereo(pipe_ctx, &addr);
-	pipe_ctx->plane_res.mi->funcs->mem_input_program_surface_flip_and_addr(
-			pipe_ctx->plane_res.mi,
+	pipe_ctx->plane_res.hubp->funcs->hubp_program_surface_flip_and_addr(
+			pipe_ctx->plane_res.hubp,
 			&plane_state->address,
 			plane_state->flip_immediate);
 	plane_state->status.requested_address = plane_state->address;
@@ -1759,8 +1759,8 @@ static void dcn10_pipe_control_lock(
 	struct pipe_ctx *pipe,
 	bool lock)
 {
-	struct mem_input *mi = NULL;
-	mi = dc->res_pool->mis[pipe->pipe_idx];
+	struct hubp *hubp = NULL;
+	hubp = dc->res_pool->hubps[pipe->pipe_idx];
 	/* use TG master update lock to lock everything on the TG
 	 * therefore only top pipe need to lock
 	 */
@@ -2181,7 +2181,7 @@ static void dcn10_get_surface_visual_confirm_color(
 	}
 }
 
-static void mmhub_read_vm_system_aperture_settings(struct dcn10_mem_input *mi,
+static void mmhub_read_vm_system_aperture_settings(struct dcn10_hubp *hubp1,
 		struct vm_system_aperture_param *apt,
 		struct dce_hwseq *hws)
 {
@@ -2206,7 +2206,7 @@ static void mmhub_read_vm_system_aperture_settings(struct dcn10_mem_input *mi,
 }
 
 /* Temporary read settings, future will get values from kmd directly */
-static void mmhub_read_vm_context0_settings(struct dcn10_mem_input *mi,
+static void mmhub_read_vm_context0_settings(struct dcn10_hubp *hubp1,
 		struct vm_context0_param *vm0,
 		struct dce_hwseq *hws)
 {
@@ -2250,22 +2250,22 @@ static void mmhub_read_vm_context0_settings(struct dcn10_mem_input *mi,
 	vm0->pte_base.quad_part -= fb_offset.quad_part;
 }
 
-static void dcn10_program_pte_vm(struct mem_input *mem_input,
+static void dcn10_program_pte_vm(struct hubp *hubp,
 		enum surface_pixel_format format,
 		union dc_tiling_info *tiling_info,
 		enum dc_rotation_angle rotation,
 		struct dce_hwseq *hws)
 {
-	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);
 	struct vm_system_aperture_param apt = { {{ 0 } } };
 	struct vm_context0_param vm0 = { { { 0 } } };
 
 
-	mmhub_read_vm_system_aperture_settings(mi, &apt, hws);
-	mmhub_read_vm_context0_settings(mi, &vm0, hws);
+	mmhub_read_vm_system_aperture_settings(hubp1, &apt, hws);
+	mmhub_read_vm_context0_settings(hubp1, &vm0, hws);
 
-	mem_input->funcs->mem_input_set_vm_system_aperture_settings(mem_input, &apt);
-	mem_input->funcs->mem_input_set_vm_context0_settings(mem_input, &vm0);
+	hubp->funcs->hubp_set_vm_system_aperture_settings(hubp, &apt);
+	hubp->funcs->hubp_set_vm_context0_settings(hubp, &vm0);
 }
 
 static void update_dchubp_dpp(
@@ -2274,7 +2274,7 @@ static void update_dchubp_dpp(
 	struct dc_state *context)
 {
 	struct dce_hwseq *hws = dc->hwseq;
-	struct mem_input *mi = pipe_ctx->plane_res.mi;
+	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 	struct transform *xfm = pipe_ctx->plane_res.xfm;
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	union plane_size size = plane_state->plane_size;
@@ -2299,8 +2299,8 @@ static void update_dchubp_dpp(
 	 */
 	REG_UPDATE(DCHUBP_CNTL[pipe_ctx->pipe_idx], HUBP_VTG_SEL, pipe_ctx->stream_res.tg->inst);
 
-	mi->funcs->mem_input_setup(
-		mi,
+	hubp->funcs->hubp_setup(
+		hubp,
 		&pipe_ctx->dlg_regs,
 		&pipe_ctx->ttu_regs,
 		&pipe_ctx->rq_regs,
@@ -2310,7 +2310,7 @@ static void update_dchubp_dpp(
 
 	if (dc->config.gpu_vm_support)
 		dcn10_program_pte_vm(
-				pipe_ctx->plane_res.mi,
+				pipe_ctx->plane_res.hubp,
 				plane_state->format,
 				&plane_state->tiling_info,
 				plane_state->rotation,
@@ -2321,7 +2321,7 @@ static void update_dchubp_dpp(
 			plane_state->format,
 			EXPANSION_MODE_ZERO);
 
-	mpcc_cfg.dpp_id = mi->inst;
+	mpcc_cfg.dpp_id = hubp->inst;
 	mpcc_cfg.opp_id = pipe_ctx->stream_res.opp->inst;
 	mpcc_cfg.tree_cfg = &(pipe_ctx->stream_res.opp->mpc_tree);
 	for (top_pipe = pipe_ctx->top_pipe; top_pipe; top_pipe = top_pipe->top_pipe)
@@ -2340,15 +2340,15 @@ static void update_dchubp_dpp(
 	mpcc_cfg.pre_multiplied_alpha = is_rgb_cspace(
 			pipe_ctx->stream->output_color_space)
 					&& per_pixel_alpha;
-	mi->mpcc_id = dc->res_pool->mpc->funcs->add(dc->res_pool->mpc, &mpcc_cfg);
-	mi->opp_id = mpcc_cfg.opp_id;
+	hubp->mpcc_id = dc->res_pool->mpc->funcs->add(dc->res_pool->mpc, &mpcc_cfg);
+	hubp->opp_id = mpcc_cfg.opp_id;
 
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = per_pixel_alpha;
 	pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
 	/* scaler configuration */
 	pipe_ctx->plane_res.xfm->funcs->transform_set_scaler(
 			pipe_ctx->plane_res.xfm, &pipe_ctx->plane_res.scl_data);
-	mi->funcs->mem_program_viewport(mi,
+	hubp->funcs->mem_program_viewport(hubp,
 			&pipe_ctx->plane_res.scl_data.viewport, &pipe_ctx->plane_res.scl_data.viewport_c);
 
 	/*gamut remap*/
@@ -2358,8 +2358,8 @@ static void update_dchubp_dpp(
 			pipe_ctx->stream->output_color_space,
 			pipe_ctx->stream->csc_color_matrix.matrix);
 
-	mi->funcs->mem_input_program_surface_config(
-		mi,
+	hubp->funcs->hubp_program_surface_config(
+		hubp,
 		plane_state->format,
 		&plane_state->tiling_info,
 		&size,
@@ -2370,7 +2370,7 @@ static void update_dchubp_dpp(
 	dc->hwss.update_plane_addr(dc, pipe_ctx);
 
 	if (is_pipe_tree_visible(pipe_ctx))
-		mi->funcs->set_blank(mi, false);
+		hubp->funcs->set_blank(hubp, false);
 }
 
 
@@ -2550,7 +2550,7 @@ static void dcn10_apply_ctx_for_surface(
 		 */
 
 		if (pipe_ctx->plane_state && !old_pipe_ctx->plane_state) {
-			if (pipe_ctx->plane_res.mi->opp_id != 0xf && pipe_ctx->stream_res.tg->inst == be_idx) {
+			if (pipe_ctx->plane_res.hubp->opp_id != 0xf && pipe_ctx->stream_res.tg->inst == be_idx) {
 				dcn10_power_down_fe(dc, pipe_ctx->pipe_idx);
 				/*
 				 * power down fe will unlock when calling reset, need
@@ -2577,7 +2577,7 @@ static void dcn10_apply_ctx_for_surface(
 					&(old_pipe_ctx->stream_res.opp->mpc_tree),
 					old_pipe_ctx->stream_res.opp->inst,
 					old_pipe_ctx->pipe_idx);
-			old_pipe_ctx->stream_res.opp->mpcc_disconnect_pending[old_pipe_ctx->plane_res.mi->mpcc_id] = true;
+			old_pipe_ctx->stream_res.opp->mpcc_disconnect_pending[old_pipe_ctx->plane_res.hubp->mpcc_id] = true;
 
 			/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
 					"[debug_mpo: apply_ctx disconnect pending on mpcc %d]\n",
@@ -2861,7 +2861,7 @@ static void dcn10_wait_for_mpcc_disconnect(
 		if (pipe_ctx->stream_res.opp->mpcc_disconnect_pending[i]) {
 			res_pool->mpc->funcs->wait_for_idle(res_pool->mpc, i);
 			pipe_ctx->stream_res.opp->mpcc_disconnect_pending[i] = false;
-			res_pool->mis[i]->funcs->set_blank(res_pool->mis[i], true);
+			res_pool->hubps[i]->funcs->set_blank(res_pool->hubps[i], true);
 			/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
 					"[debug_mpo: wait_for_mpcc finished waiting on mpcc %d]\n",
 					i);*/
@@ -2892,11 +2892,11 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 		return;
 
 	plane_state->status.is_flip_pending =
-			pipe_ctx->plane_res.mi->funcs->mem_input_is_flip_pending(
-					pipe_ctx->plane_res.mi);
+			pipe_ctx->plane_res.hubp->funcs->hubp_is_flip_pending(
+					pipe_ctx->plane_res.hubp);
 
-	plane_state->status.current_address = pipe_ctx->plane_res.mi->current_address;
-	if (pipe_ctx->plane_res.mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
+	plane_state->status.current_address = pipe_ctx->plane_res.hubp->current_address;
+	if (pipe_ctx->plane_res.hubp->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 			tg->funcs->is_stereo_left_eye) {
 		plane_state->status.is_right_eye =
 				!tg->funcs->is_stereo_left_eye(pipe_ctx->stream_res.tg);

commit 067c878a220cbe6198b3cfdc7f372adab4762ad8
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Oct 3 15:03:49 2017 -0400

    drm/amd/display: Fixed switching mode half screen gamma incorrect.
    
            Half screen gamma setting and cursor are incorrect
            when switching mode through win+p due to wrong programming
            gamma sequence (In case of bottom pipe, gamma and cursor are
            programmed before front end programmed, pipe is power gated).
    
            change:
            1. Cache curor attributes to stream
            2. Move set gamma and cursor inside front end
               programming.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 494f833208f9..ee63155c1895 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2408,6 +2408,10 @@ static void program_all_pipe_in_tree(
 	}
 
 	if (pipe_ctx->plane_state != NULL) {
+		struct dc_cursor_position position = { 0 };
+		struct pipe_ctx *cur_pipe_ctx =
+				&dc->current_state->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
+
 		dcn10_power_on_fe(dc, pipe_ctx, context);
 
 		/* temporary dcn1 wa:
@@ -2422,6 +2426,19 @@ static void program_all_pipe_in_tree(
 		toggle_watermark_change_req(dc->hwseq);
 
 		update_dchubp_dpp(dc, pipe_ctx, context);
+
+		/* TODO: this is a hack w/a for switching from mpo to pipe split */
+		dc_stream_set_cursor_position(pipe_ctx->stream, &position);
+
+		dc_stream_set_cursor_attributes(pipe_ctx->stream,
+				&pipe_ctx->stream->cursor_attributes);
+
+		if (cur_pipe_ctx->plane_state != pipe_ctx->plane_state) {
+			dc->hwss.set_input_transfer_func(
+					pipe_ctx, pipe_ctx->plane_state);
+			dc->hwss.set_output_transfer_func(
+					pipe_ctx, pipe_ctx->stream);
+		}
 	}
 
 	if (dc->debug.sanity_checks) {

commit d050f8ed14494ea23c6e10b5893010946ef0f78b
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Fri Sep 29 16:36:34 2017 -0400

    drm/amd/display: add dpms state to DC
    
    - avoid eDP screen flash 4 times when resume from s3
    - improve s3 and boot time
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 012ba7c9ca8d..494f833208f9 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1037,12 +1037,11 @@ static void reset_back_end_for_pipe(
 		return;
 	}
 
-	/* TODOFPGA break core_link_disable_stream into 2 functions:
-	 * disable_stream and disable_link. disable_link will disable PHYPLL
-	 * which is used by otg. Move disable_link after disable_crtc
-	 */
-	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
-		core_link_disable_stream(pipe_ctx, FREE_ACQUIRED_RESOURCE);
+	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
+		/* DPMS may already disable */
+		if (!pipe_ctx->stream->dpms_off)
+			core_link_disable_stream(pipe_ctx, FREE_ACQUIRED_RESOURCE);
+	}
 
 	/* by upper caller loop, parent pipe: pipe0, will be reset last.
 	 * back end share by all pipes and will be disable only when disable

commit ff79cbdccea94935ff9d2111458e439e28c86e74
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Mon Oct 2 13:40:02 2017 -0400

    drm/amd/display: increase pstate wait timeout
    
    For linux it takes longer than 40us so increasing it to
    200us. Also added debug prints regarding the change
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index db774b3c3721..012ba7c9ca8d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -245,8 +245,13 @@ static void verify_allow_pstate_change_high(
 {
 	/* pstate latency is ~20us so if we wait over 40us and pstate allow
 	 * still not asserted, we are probably stuck and going to hang
+	 *
+	 * TODO: Figure out why it takes ~100us on linux
+	 * pstate takes around ~100us on linux. Unknown currently as to
+	 * why it takes that long on linux
 	 */
-	static unsigned int pstate_wait_timeout_us = 40;
+	static unsigned int pstate_wait_timeout_us = 200;
+	static unsigned int pstate_wait_expected_timeout_us = 40;
 	static unsigned int max_sampled_pstate_wait_us; /* data collection */
 	static bool forced_pstate_allow; /* help with revert wa */
 	static bool should_log_hw_state; /* prevent hw state log by default */
@@ -293,9 +298,15 @@ static void verify_allow_pstate_change_high(
 	for (i = 0; i < pstate_wait_timeout_us; i++) {
 		debug_data = REG_READ(DCHUBBUB_TEST_DEBUG_DATA);
 
-		if (debug_data & (1 << 30))
-			return;
+		if (debug_data & (1 << 30)) {
+
+			if (i > pstate_wait_expected_timeout_us)
+				dm_logger_write(hws->ctx->logger, LOG_WARNING,
+						"pstate took longer than expected ~%dus",
+						i);
 
+			return;
+		}
 		if (max_sampled_pstate_wait_us < i)
 			max_sampled_pstate_wait_us = i;
 
@@ -314,6 +325,9 @@ static void verify_allow_pstate_change_high(
 		dcn10_log_hw_state(hws->ctx->dc);
 	}
 
+	dm_logger_write(hws->ctx->logger, LOG_WARNING,
+			"pstate TEST_DEBUG_DATA: 0x%X",
+			debug_data);
 	BREAK_TO_DEBUGGER();
 }
 

commit 458e9d03875ec6cb2ee37b64cf201bc80401bf92
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Mon Oct 2 12:00:24 2017 -0400

    drm/amd/display: fix re-enabling stutter for raven
    
    We were overwriting the whole register which was re-enabling
    stutter for raven. Now we are reading the register then setting
    the values only for pstate.
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 072c48188b79..db774b3c3721 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -253,7 +253,6 @@ static void verify_allow_pstate_change_high(
 
 	unsigned int debug_index = 0x7;
 	unsigned int debug_data;
-	unsigned int force_allow_pstate = 0x30;
 	unsigned int i;
 
 	if (forced_pstate_allow) {
@@ -261,7 +260,9 @@ static void verify_allow_pstate_change_high(
 		 * we verify_allow_pstate_change_high.  so disable force
 		 * here so we can check status
 		 */
-		REG_WRITE(DCHUBBUB_ARB_DRAM_STATE_CNTL, 0);
+		REG_UPDATE_2(DCHUBBUB_ARB_DRAM_STATE_CNTL,
+			     DCHUBBUB_ARB_ALLOW_PSTATE_CHANGE_FORCE_VALUE, 0,
+			     DCHUBBUB_ARB_ALLOW_PSTATE_CHANGE_FORCE_ENABLE, 0);
 		forced_pstate_allow = false;
 	}
 
@@ -304,7 +305,9 @@ static void verify_allow_pstate_change_high(
 	/* force pstate allow to prevent system hang
 	 * and break to debugger to investigate
 	 */
-	REG_WRITE(DCHUBBUB_ARB_DRAM_STATE_CNTL, force_allow_pstate);
+	REG_UPDATE_2(DCHUBBUB_ARB_DRAM_STATE_CNTL,
+		     DCHUBBUB_ARB_ALLOW_PSTATE_CHANGE_FORCE_VALUE, 1,
+		     DCHUBBUB_ARB_ALLOW_PSTATE_CHANGE_FORCE_ENABLE, 1);
 	forced_pstate_allow = true;
 
 	if (should_log_hw_state) {

commit 4176664b1fc8aa052f886037590cac4fb0dd8afb
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Sep 27 23:23:16 2017 -0400

    drm/amd/display: audio dynamic resource acquired related
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 84d9d202d3b5..072c48188b79 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1025,7 +1025,7 @@ static void reset_back_end_for_pipe(
 	 * which is used by otg. Move disable_link after disable_crtc
 	 */
 	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
-		core_link_disable_stream(pipe_ctx);
+		core_link_disable_stream(pipe_ctx, FREE_ACQUIRED_RESOURCE);
 
 	/* by upper caller loop, parent pipe: pipe0, will be reset last.
 	 * back end share by all pipes and will be disable only when disable

commit 50d4cfdc118122f58ffdb09607a57c621e24d777
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Sep 28 10:40:10 2017 -0400

    drm/amd/display: Program front end first when set mode.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 86cfab33feea..84d9d202d3b5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2283,8 +2283,6 @@ static void update_dchubp_dpp(
 	 */
 	REG_UPDATE(DCHUBP_CNTL[pipe_ctx->pipe_idx], HUBP_VTG_SEL, pipe_ctx->stream_res.tg->inst);
 
-	dc->hwss.update_plane_addr(dc, pipe_ctx);
-
 	mi->funcs->mem_input_setup(
 		mi,
 		&pipe_ctx->dlg_regs,
@@ -2353,6 +2351,8 @@ static void update_dchubp_dpp(
 		&plane_state->dcc,
 		plane_state->horizontal_mirror);
 
+	dc->hwss.update_plane_addr(dc, pipe_ctx);
+
 	if (is_pipe_tree_visible(pipe_ctx))
 		mi->funcs->set_blank(mi, false);
 }
@@ -2556,6 +2556,7 @@ static void dcn10_apply_ctx_for_surface(
 			old_pipe_ctx->top_pipe = NULL;
 			old_pipe_ctx->bottom_pipe = NULL;
 			old_pipe_ctx->plane_state = NULL;
+			old_pipe_ctx->stream = NULL;
 
 			dm_logger_write(dc->ctx->logger, LOG_DC,
 					"Reset mpcc for pipe %d\n",

commit 441ad741739e9092f6af231a539781118e23d6df
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Wed Sep 27 11:44:43 2017 -0400

    drm/amd/display: Add override for reporting wm ranges
    
    For verification of watermark select with SMU team, proper
    implementation will follow
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index efa3f6f97baf..86cfab33feea 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2451,6 +2451,9 @@ static void optimize_shared_resources(struct dc *dc)
 		/* S0i2 message */
 		dcn10_pplib_apply_display_requirements(dc, dc->current_state);
 	}
+
+	if (dc->debug.pplib_wm_report_mode == WM_REPORT_OVERRIDE)
+		dcn_bw_notify_pplib_of_wm_ranges(dc);
 }
 
 static void ready_shared_resources(struct dc *dc, struct dc_state *context)

commit 8740196935625dfb171ab115120315060e4a8a41
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Mon Sep 25 18:03:14 2017 -0400

    drm/amd/display: Move power control from link encoder to hwsequencer
    
    A recent commit moved the backlight control code along with the register
    defines, but did not move the power control code. This along with
    remnant fields in the dce110_link_enc_registers struct made it so that
    the code still compiled, but any attempts to access the
    LVTMA_PWRSEQ_STATE register led to reading from an address of 0. This
    patch corrects that.
    
    Also, rename blacklight_control to edp_backlight_control (Typo fix).
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 014911ebdbd6..efa3f6f97baf 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2903,7 +2903,8 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.wait_for_mpcc_disconnect = dcn10_wait_for_mpcc_disconnect,
 	.ready_shared_resources = ready_shared_resources,
 	.optimize_shared_resources = optimize_shared_resources,
-	.backlight_control = hwss_blacklight_control
+	.edp_backlight_control = hwss_edp_backlight_control,
+	.edp_power_control = hwss_edp_power_control
 };
 
 

commit 56e6ed4561f2962d1220c16bbd2709ced7a84be8
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Sep 22 16:06:04 2017 -0400

    drm/amd/display: Only reset top pipe back end.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 4e4f20ba5643..014911ebdbd6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1270,6 +1270,9 @@ static void reset_hw_ctx_wrap(
 		if (!pipe_ctx_old->stream)
 			continue;
 
+		if (pipe_ctx_old->top_pipe)
+			continue;
+
 		if (!pipe_ctx->stream ||
 				pipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {
 			struct clock_source *old_clk = pipe_ctx_old->clock_source;

commit 69b516c91cbf459e5fd4b8b6e97cfdfa7ea25126
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Fri Sep 22 12:48:54 2017 -0400

    drm/amd/display: Program stream's csc matrix instead of using default
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index cdaed0c0a70c..4e4f20ba5643 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2259,7 +2259,6 @@ static void update_dchubp_dpp(
 	struct transform *xfm = pipe_ctx->plane_res.xfm;
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	union plane_size size = plane_state->plane_size;
-	struct default_adjustment ocsc = {0};
 	struct mpcc_cfg mpcc_cfg = {0};
 	struct pipe_ctx *top_pipe;
 	bool per_pixel_alpha = plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;
@@ -2338,9 +2337,9 @@ static void update_dchubp_dpp(
 	/*gamut remap*/
 	program_gamut_remap(pipe_ctx);
 
-	/*TODO add adjustments parameters*/
-	ocsc.out_color_space = pipe_ctx->stream->output_color_space;
-	pipe_ctx->plane_res.xfm->funcs->opp_set_csc_default(pipe_ctx->plane_res.xfm, &ocsc);
+	program_csc_matrix(pipe_ctx,
+			pipe_ctx->stream->output_color_space,
+			pipe_ctx->stream->csc_color_matrix.matrix);
 
 	mi->funcs->mem_input_program_surface_config(
 		mi,

commit 5df921d4c0e3e2065b961ac8d4269be68f80801d
Author: Ken Chalmers <ken.chalmers@amd.com>
Date:   Wed Sep 20 11:48:47 2017 -0400

    drm/amd/display: fix ASSERT() caused by missing registers.
    
    Signed-off-by: Ken Chalmers <ken.chalmers@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index bf5c9243ba7a..cdaed0c0a70c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -771,14 +771,16 @@ static void power_on_plane(
 	struct dce_hwseq *hws,
 	int plane_id)
 {
-	REG_SET(DC_IP_REQUEST_CNTL, 0,
-			IP_REQUEST_EN, 1);
-	dpp_pg_control(hws, plane_id, true);
-	hubp_pg_control(hws, plane_id, true);
-	REG_SET(DC_IP_REQUEST_CNTL, 0,
-			IP_REQUEST_EN, 0);
-	dm_logger_write(hws->ctx->logger, LOG_DEBUG,
-			"Un-gated front end for pipe %d\n", plane_id);
+	if (REG(DC_IP_REQUEST_CNTL)) {
+		REG_SET(DC_IP_REQUEST_CNTL, 0,
+				IP_REQUEST_EN, 1);
+		dpp_pg_control(hws, plane_id, true);
+		hubp_pg_control(hws, plane_id, true);
+		REG_SET(DC_IP_REQUEST_CNTL, 0,
+				IP_REQUEST_EN, 0);
+		dm_logger_write(hws->ctx->logger, LOG_DEBUG,
+				"Un-gated front end for pipe %d\n", plane_id);
+	}
 }
 
 static void undo_DEGVIDCN10_253_wa(struct dc *dc)
@@ -1130,18 +1132,20 @@ static void plane_atomic_power_down(struct dc *dc, int fe_idx)
 	struct dce_hwseq *hws = dc->hwseq;
 	struct transform *xfm = dc->res_pool->transforms[fe_idx];
 
-	REG_SET(DC_IP_REQUEST_CNTL, 0,
-			IP_REQUEST_EN, 1);
-	dpp_pg_control(hws, fe_idx, false);
-	hubp_pg_control(hws, fe_idx, false);
-	xfm->funcs->transform_reset(xfm);
-	REG_SET(DC_IP_REQUEST_CNTL, 0,
-			IP_REQUEST_EN, 0);
-	dm_logger_write(dc->ctx->logger, LOG_DEBUG,
-			"Power gated front end %d\n", fe_idx);
+	if (REG(DC_IP_REQUEST_CNTL)) {
+		REG_SET(DC_IP_REQUEST_CNTL, 0,
+				IP_REQUEST_EN, 1);
+		dpp_pg_control(hws, fe_idx, false);
+		hubp_pg_control(hws, fe_idx, false);
+		xfm->funcs->transform_reset(xfm);
+		REG_SET(DC_IP_REQUEST_CNTL, 0,
+				IP_REQUEST_EN, 0);
+		dm_logger_write(dc->ctx->logger, LOG_DEBUG,
+				"Power gated front end %d\n", fe_idx);
 
-	if (dc->debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->hwseq);
+		if (dc->debug.sanity_checks)
+			verify_allow_pstate_change_high(dc->hwseq);
+	}
 }
 
 

commit dbaed8037c6c606456c182f5fc327f9d405a7ffe
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Tue Sep 19 11:35:23 2017 -0400

    drm/amd/display: edp backlight regression fix
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 82a985a981be..bf5c9243ba7a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2897,6 +2897,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.wait_for_mpcc_disconnect = dcn10_wait_for_mpcc_disconnect,
 	.ready_shared_resources = ready_shared_resources,
 	.optimize_shared_resources = optimize_shared_resources,
+	.backlight_control = hwss_blacklight_control
 };
 
 

commit 7f4a7253b112c9ed21022e25c7a740d824c56619
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Mon Sep 11 16:56:51 2017 -0400

    drm/amd/display: update mpc add/remove functions
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e60be00abcf2..82a985a981be 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -881,7 +881,8 @@ static void dcn10_init_hw(struct dc *dc)
 
 		xfm->funcs->transform_reset(xfm);
 		dc->res_pool->mpc->funcs->remove(
-				dc->res_pool->mpc, dc->res_pool->opps[i], i);
+				dc->res_pool->mpc, &(dc->res_pool->opps[i]->mpc_tree),
+				dc->res_pool->opps[i]->inst, i);
 
 		/* Blank controller using driver code instead of
 		 * command table.
@@ -1079,7 +1080,8 @@ static void plane_atomic_disconnect(struct dc *dc,
 	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
-	mpc->funcs->remove(mpc, dc->res_pool->opps[opp_id], fe_idx);
+	mpc->funcs->remove(mpc, &(dc->res_pool->opps[opp_id]->mpc_tree),
+			dc->res_pool->opps[opp_id]->inst, fe_idx);
 }
 
 /* disable HW used by plane.
@@ -2299,8 +2301,9 @@ static void update_dchubp_dpp(
 			plane_state->format,
 			EXPANSION_MODE_ZERO);
 
-	mpcc_cfg.mi = mi;
-	mpcc_cfg.opp = pipe_ctx->stream_res.opp;
+	mpcc_cfg.dpp_id = mi->inst;
+	mpcc_cfg.opp_id = pipe_ctx->stream_res.opp->inst;
+	mpcc_cfg.tree_cfg = &(pipe_ctx->stream_res.opp->mpc_tree);
 	for (top_pipe = pipe_ctx->top_pipe; top_pipe; top_pipe = top_pipe->top_pipe)
 		mpcc_cfg.z_index++;
 	if (dc->debug.surface_visual_confirm)
@@ -2317,7 +2320,8 @@ static void update_dchubp_dpp(
 	mpcc_cfg.pre_multiplied_alpha = is_rgb_cspace(
 			pipe_ctx->stream->output_color_space)
 					&& per_pixel_alpha;
-	dc->res_pool->mpc->funcs->add(dc->res_pool->mpc, &mpcc_cfg);
+	mi->mpcc_id = dc->res_pool->mpc->funcs->add(dc->res_pool->mpc, &mpcc_cfg);
+	mi->opp_id = mpcc_cfg.opp_id;
 
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = per_pixel_alpha;
 	pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
@@ -2528,7 +2532,8 @@ static void dcn10_apply_ctx_for_surface(
 			/* reset mpc */
 			dc->res_pool->mpc->funcs->remove(
 					dc->res_pool->mpc,
-					old_pipe_ctx->stream_res.opp,
+					&(old_pipe_ctx->stream_res.opp->mpc_tree),
+					old_pipe_ctx->stream_res.opp->inst,
 					old_pipe_ctx->pipe_idx);
 			old_pipe_ctx->stream_res.opp->mpcc_disconnect_pending[old_pipe_ctx->plane_res.mi->mpcc_id] = true;
 

commit 6bf520280f3621d458e2ef3bd3c48acb89a39af7
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Tue Sep 5 12:20:39 2017 -0400

    drm/amd/display: Driver message to SMU to indicate display off
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d3fee15aeb79..e60be00abcf2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -802,18 +802,14 @@ static void undo_DEGVIDCN10_253_wa(struct dc *dc)
 			IP_REQUEST_EN, 0);
 }
 
-static void ready_shared_resources(struct dc *dc)
-{
-	if (dc->current_state->stream_count == 0 &&
-			!dc->debug.disable_stutter)
-		undo_DEGVIDCN10_253_wa(dc);
-}
-
 static void apply_DEGVIDCN10_253_wa(struct dc *dc)
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct mem_input *mi = dc->res_pool->mis[0];
 
+	if (dc->debug.disable_stutter)
+		return;
+
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 1);
 
@@ -824,13 +820,6 @@ static void apply_DEGVIDCN10_253_wa(struct dc *dc)
 	mi->funcs->set_hubp_blank_en(mi, false);
 }
 
-static void optimize_shared_resources(struct dc *dc)
-{
-	if (dc->current_state->stream_count == 0 &&
-			!dc->debug.disable_stutter)
-		apply_DEGVIDCN10_253_wa(dc);
-}
-
 static void bios_golden_init(struct dc *dc)
 {
 	struct dc_bios *bp = dc->ctx->dc_bios;
@@ -2445,6 +2434,27 @@ static void dcn10_pplib_apply_display_requirements(
 	dc->prev_display_config = *pp_display_cfg;
 }
 
+static void optimize_shared_resources(struct dc *dc)
+{
+	if (dc->current_state->stream_count == 0) {
+		apply_DEGVIDCN10_253_wa(dc);
+		/* S0i2 message */
+		dcn10_pplib_apply_display_requirements(dc, dc->current_state);
+	}
+}
+
+static void ready_shared_resources(struct dc *dc, struct dc_state *context)
+{
+	if (dc->current_state->stream_count == 0 &&
+			!dc->debug.disable_stutter)
+		undo_DEGVIDCN10_253_wa(dc);
+
+	/* S0i2 message */
+	if (dc->current_state->stream_count == 0 &&
+			context->stream_count != 0)
+		dcn10_pplib_apply_display_requirements(dc, context);
+}
+
 static void dcn10_apply_ctx_for_surface(
 		struct dc *dc,
 		const struct dc_stream_state *stream,

commit 5667ff5c117f2d8735f27a267bc68a0811c55075
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Oct 3 14:27:13 2017 +1000

    amdgpu/dc: fix a bunch of misc whitespace.
    
    This just aligns a few things with kernel style.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c4875c3a0d93..d3fee15aeb79 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2396,14 +2396,14 @@ static void program_all_pipe_in_tree(
 		dcn10_power_on_fe(dc, pipe_ctx, context);
 
 		/* temporary dcn1 wa:
-                 *   watermark update requires toggle after a/b/c/d sets are programmed
-                 *   if hubp is pg then wm value doesn't get properaged to hubp
-                 *   need to toggle after ungate to ensure wm gets to hubp.
-                 *
-                 * final solution:  we need to get SMU to do the toggle as
-                 * DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST is owned by SMU we should have 
-                 * both driver and fw accessing same register
-                 */
+		 *   watermark update requires toggle after a/b/c/d sets are programmed
+		 *   if hubp is pg then wm value doesn't get properaged to hubp
+		 *   need to toggle after ungate to ensure wm gets to hubp.
+		 *
+		 * final solution:  we need to get SMU to do the toggle as
+		 * DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST is owned by SMU we should have
+		 * both driver and fw accessing same register
+		 */
 		toggle_watermark_change_req(dc->hwseq);
 
 		update_dchubp_dpp(dc, pipe_ctx, context);

commit a6def44598eb6b82992ffd696cfd7f027940e2cd
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Sep 8 10:25:25 2017 -0400

    drm/amd/display: Update include to bring in line with internal tree
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c8c4b951ee1d..c4875c3a0d93 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -40,6 +40,7 @@
 #include "ipp.h"
 #include "mpc.h"
 #include "reg_helper.h"
+#include "custom_float.h"
 
 #define CTX \
 	hws->ctx

commit 21e67d4d52ca8688feb8c4f6e6d29b2d16d578ad
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 5 15:50:48 2017 -0400

    drm/amd/display: No need to keep track of unreffed clk sources
    
    This simplifies clock source reprogramming a bit.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 6fee6957c1a6..c8c4b951ee1d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1265,22 +1265,6 @@ static void reset_hw_ctx_wrap(
 			plane_atomic_power_down(dc, i);
 	}
 
-	/* power down changed clock sources */
-	for (i = 0; i < dc->res_pool->clk_src_count; i++)
-		if (context->res_ctx.clock_source_changed[i]) {
-			struct clock_source *clk = dc->res_pool->clock_sources[i];
-
-			clk->funcs->cs_power_down(clk);
-			context->res_ctx.clock_source_changed[i] = false;
-		}
-
-	if (context->res_ctx.dp_clock_source_changed) {
-		struct clock_source *clk = dc->res_pool->dp_clock_source;
-
-		clk->funcs->cs_power_down(clk);
-		context->res_ctx.dp_clock_source_changed = false;
-	}
-
 	/* Reset Back End*/
 	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
 		struct pipe_ctx *pipe_ctx_old =
@@ -1291,9 +1275,16 @@ static void reset_hw_ctx_wrap(
 			continue;
 
 		if (!pipe_ctx->stream ||
-				pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
+				pipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {
+			struct clock_source *old_clk = pipe_ctx_old->clock_source;
+
 			reset_back_end_for_pipe(dc, pipe_ctx_old, dc->current_state);
+
+			if (old_clk)
+				old_clk->funcs->cs_power_down(old_clk);
+		}
 	}
+
 }
 
 static bool patch_address_for_sbs_tb_stereo(

commit 264efa31835dd87af4e77e3a27090e60d4fe1511
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Thu Aug 31 16:04:24 2017 -0400

    drm/amd/display: remove output_format from ipp_setup
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index a1f4a00e5e04..6fee6957c1a6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2316,8 +2316,7 @@ static void update_dchubp_dpp(
 
 	xfm->funcs->ipp_setup(xfm,
 			plane_state->format,
-			1,
-			IPP_OUTPUT_FORMAT_12_BIT_FIX);
+			EXPANSION_MODE_ZERO);
 
 	mpcc_cfg.mi = mi;
 	mpcc_cfg.opp = pipe_ctx->stream_res.opp;

commit 9d0dcecd93e4997c65b18404f1ab2fce2ab79010
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Aug 28 19:05:17 2017 -0400

    drm/amd/display: Power down clock source at commit
    
    Still one more in dc_validate_global
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7460560fbefc..a1f4a00e5e04 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1044,14 +1044,6 @@ static void reset_back_end_for_pipe(
 		pipe_ctx->stream_res.tg->funcs->enable_optc_clock(pipe_ctx->stream_res.tg, false);
 	}
 
-	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
-		if (resource_unreference_clock_source(&context->res_ctx,
-		    dc->res_pool, pipe_ctx->clock_source)) {
-			pipe_ctx->clock_source->funcs->cs_power_down(pipe_ctx->clock_source);
-			pipe_ctx->clock_source = NULL;
-		}
-
-
 	for (i = 0; i < dc->res_pool->pipe_count; i++)
 		if (&dc->current_state->res_ctx.pipe_ctx[i] == pipe_ctx)
 			break;
@@ -1273,6 +1265,22 @@ static void reset_hw_ctx_wrap(
 			plane_atomic_power_down(dc, i);
 	}
 
+	/* power down changed clock sources */
+	for (i = 0; i < dc->res_pool->clk_src_count; i++)
+		if (context->res_ctx.clock_source_changed[i]) {
+			struct clock_source *clk = dc->res_pool->clock_sources[i];
+
+			clk->funcs->cs_power_down(clk);
+			context->res_ctx.clock_source_changed[i] = false;
+		}
+
+	if (context->res_ctx.dp_clock_source_changed) {
+		struct clock_source *clk = dc->res_pool->dp_clock_source;
+
+		clk->funcs->cs_power_down(clk);
+		context->res_ctx.dp_clock_source_changed = false;
+	}
+
 	/* Reset Back End*/
 	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
 		struct pipe_ctx *pipe_ctx_old =

commit 4a6295361c737a80e9f079952ac863a3b0c26acf
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Aug 28 18:43:45 2017 -0400

    drm/amd/display: Don't reset clock source at unref
    
    Powering down the clock source during unref is unsafe as we might want
    to unref during atomic_check
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 6b76fc417456..7460560fbefc 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1045,9 +1045,12 @@ static void reset_back_end_for_pipe(
 	}
 
 	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
-		resource_unreference_clock_source(
-			&context->res_ctx, dc->res_pool,
-			&pipe_ctx->clock_source);
+		if (resource_unreference_clock_source(&context->res_ctx,
+		    dc->res_pool, pipe_ctx->clock_source)) {
+			pipe_ctx->clock_source->funcs->cs_power_down(pipe_ctx->clock_source);
+			pipe_ctx->clock_source = NULL;
+		}
+
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++)
 		if (&dc->current_state->res_ctx.pipe_ctx[i] == pipe_ctx)

commit 61a44fc6265dd3bb86c35bcdfb62a225891ada59
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Aug 31 16:08:51 2017 -0400

    drm/amd/display: Enable dcn10_power_on_fe log by default
    
    This should only happen on full update. If this ever happens
    on regular pageflips it needs to be debugged.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index a6015c2c20c6..6b76fc417456 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1975,7 +1975,7 @@ static void dcn10_power_on_fe(
 	/*TODO: REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DPPCLK_WDIVIDER, 0x1f);*/
 
 	if (plane_state) {
-		dm_logger_write(dc->ctx->logger, LOG_DEBUG,
+		dm_logger_write(dc->ctx->logger, LOG_DC,
 				"Pipe:%d 0x%x: addr hi:0x%x, "
 				"addr low:0x%x, "
 				"src: %d, %d, %d,"
@@ -1993,7 +1993,7 @@ static void dcn10_power_on_fe(
 				plane_state->dst_rect.width,
 				plane_state->dst_rect.height);
 
-		dm_logger_write(dc->ctx->logger, LOG_DEBUG,
+		dm_logger_write(dc->ctx->logger, LOG_DC,
 				"Pipe %d: width, height, x, y\n"
 				"viewport:%d, %d, %d, %d\n"
 				"recout:  %d, %d, %d, %d\n",

commit 890db270a5763ccacda8df7cbfac674ade78744a
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Aug 30 14:29:40 2017 -0400

    drm/amd/display: Remove sanity check.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 4fa856e9a872..a6015c2c20c6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2828,12 +2828,6 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct timing_generator *tg = pipe_ctx->stream_res.tg;
 
-	if (plane_state->ctx->dc->debug.sanity_checks) {
-		struct dc *dc = plane_state->ctx->dc;
-
-		verify_allow_pstate_change_high(dc->hwseq);
-	}
-
 	if (plane_state == NULL)
 		return;
 

commit 6f54d0b1d82194116fcb8a3683827c9d8eb8cb9b
Author: Logatharshan Thothiralingam <logatharshan.thothiralingam@amd.com>
Date:   Fri Aug 18 19:09:57 2017 -0400

    drm/amd/display: Get OTG info if OTG master enabled
    
    Signed-off-by: Logatharshan Thothiralingam <logatharshan.thothiralingam@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7ea274475598..4fa856e9a872 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -203,10 +203,14 @@ static void dcn10_log_hw_state(struct dc *dc)
 
 	for (i = 0; i < pool->pipe_count; i++) {
 		struct timing_generator *tg = pool->timing_generators[i];
-		struct dcn_otg_state s;
+		struct dcn_otg_state s = {0};
 
 		tgn10_read_otg_state(DCN10TG_FROM_TG(tg), &s);
 
+		//only print if OTG master is enabled
+		if ((s.otg_enabled & 1) == 0)
+			continue;
+
 		DTN_INFO("[%d]:\t %d \t %d \t %d \t %d \t "
 				"%d \t %d \t %d \t %d \t %d \t %d \t "
 				"%d \t %d \t %d \t %d \t %d \t ",

commit c9bb686b597d30935d6e05aaade51fc765d1ca5b
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Mon Aug 28 16:50:17 2017 -0400

    drm/amd/display: Fix time out on boot
    
    On boot, hubp 0 is powergated during enable accel mode, so we time out
    when we try to blank in undo wa.
    
    Fix: Check power gate status before set blank
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 71ff1cedbdf4..7ea274475598 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -780,6 +780,12 @@ static void undo_DEGVIDCN10_253_wa(struct dc *dc)
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct mem_input *mi = dc->res_pool->mis[0];
+	int pwr_status = 0;
+
+	REG_GET(DOMAIN0_PG_STATUS, DOMAIN0_PGFSM_PWR_STATUS, &pwr_status);
+	/* Don't need to blank if hubp is power gated*/
+	if (pwr_status == 2)
+		return;
 
 	mi->funcs->set_blank(mi, true);
 

commit 608ac7bb3924178d7bfa8b88d79d3d9d72b8f485
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Fri Aug 25 16:16:10 2017 -0400

    drm/amd/display: Rename dc validate_context and current_context
    
    Rename all the dc validate_context to dc_stateand
    dc current_context to current_state.
    
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 9c54cae28997..71ff1cedbdf4 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -793,7 +793,7 @@ static void undo_DEGVIDCN10_253_wa(struct dc *dc)
 
 static void ready_shared_resources(struct dc *dc)
 {
-	if (dc->current_context->stream_count == 0 &&
+	if (dc->current_state->stream_count == 0 &&
 			!dc->debug.disable_stutter)
 		undo_DEGVIDCN10_253_wa(dc);
 }
@@ -815,7 +815,7 @@ static void apply_DEGVIDCN10_253_wa(struct dc *dc)
 
 static void optimize_shared_resources(struct dc *dc)
 {
-	if (dc->current_context->stream_count == 0 &&
+	if (dc->current_state->stream_count == 0 &&
 			!dc->debug.disable_stutter)
 		apply_DEGVIDCN10_253_wa(dc);
 }
@@ -918,7 +918,7 @@ static void dcn10_init_hw(struct dc *dc)
 
 static enum dc_status dcn10_prog_pixclk_crtc_otg(
 		struct pipe_ctx *pipe_ctx,
-		struct validate_context *context,
+		struct dc_state *context,
 		struct dc *dc)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
@@ -1008,7 +1008,7 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 static void reset_back_end_for_pipe(
 		struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	int i;
 
@@ -1040,7 +1040,7 @@ static void reset_back_end_for_pipe(
 			&pipe_ctx->clock_source);
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++)
-		if (&dc->current_context->res_ctx.pipe_ctx[i] == pipe_ctx)
+		if (&dc->current_state->res_ctx.pipe_ctx[i] == pipe_ctx)
 			break;
 
 	if (i == dc->res_pool->pipe_count)
@@ -1206,14 +1206,14 @@ static void dcn10_power_down_fe(struct dc *dc, int fe_idx)
 
 static void reset_hw_ctx_wrap(
 		struct dc *dc,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	int i;
 
 	/* Reset Front End*/
 	/* Lock*/
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct pipe_ctx *cur_pipe_ctx = &dc->current_context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *cur_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
 		struct timing_generator *tg = cur_pipe_ctx->stream_res.tg;
 
 		if (cur_pipe_ctx->stream)
@@ -1222,7 +1222,7 @@ static void reset_hw_ctx_wrap(
 	/* Disconnect*/
 	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
 		struct pipe_ctx *pipe_ctx_old =
-			&dc->current_context->res_ctx.pipe_ctx[i];
+			&dc->current_state->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (!pipe_ctx->stream ||
@@ -1234,7 +1234,7 @@ static void reset_hw_ctx_wrap(
 	}
 	/* Unlock*/
 	for (i = dc->res_pool->pipe_count - 1; i >= 0; i--) {
-		struct pipe_ctx *cur_pipe_ctx = &dc->current_context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *cur_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
 		struct timing_generator *tg = cur_pipe_ctx->stream_res.tg;
 
 		if (cur_pipe_ctx->stream)
@@ -1244,7 +1244,7 @@ static void reset_hw_ctx_wrap(
 	/* Disable and Powerdown*/
 	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
 		struct pipe_ctx *pipe_ctx_old =
-			&dc->current_context->res_ctx.pipe_ctx[i];
+			&dc->current_state->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		/*if (!pipe_ctx_old->stream)
@@ -1263,7 +1263,7 @@ static void reset_hw_ctx_wrap(
 	/* Reset Back End*/
 	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
 		struct pipe_ctx *pipe_ctx_old =
-			&dc->current_context->res_ctx.pipe_ctx[i];
+			&dc->current_state->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (!pipe_ctx_old->stream)
@@ -1271,7 +1271,7 @@ static void reset_hw_ctx_wrap(
 
 		if (!pipe_ctx->stream ||
 				pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
-			reset_back_end_for_pipe(dc, pipe_ctx_old, dc->current_context);
+			reset_back_end_for_pipe(dc, pipe_ctx_old, dc->current_state);
 	}
 }
 
@@ -1943,7 +1943,7 @@ static void print_rq_dlg_ttu(
 static void dcn10_power_on_fe(
 	struct dc *dc,
 	struct pipe_ctx *pipe_ctx,
-	struct validate_context *context)
+	struct dc_state *context)
 {
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct dce_hwseq *hws = dc->hwseq;
@@ -2244,7 +2244,7 @@ static void dcn10_program_pte_vm(struct mem_input *mem_input,
 static void update_dchubp_dpp(
 	struct dc *dc,
 	struct pipe_ctx *pipe_ctx,
-	struct validate_context *context)
+	struct dc_state *context)
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct mem_input *mi = pipe_ctx->plane_res.mi;
@@ -2263,7 +2263,7 @@ static void update_dchubp_dpp(
 		pipe_ctx->pipe_idx,
 		pipe_ctx->stream_res.pix_clk_params.requested_pix_clk,
 		context->bw.dcn.calc_clk.dppclk_div);
-	dc->current_context->bw.dcn.cur_clk.dppclk_div =
+	dc->current_state->bw.dcn.cur_clk.dppclk_div =
 			context->bw.dcn.calc_clk.dppclk_div;
 	context->bw.dcn.cur_clk.dppclk_div = context->bw.dcn.calc_clk.dppclk_div;
 
@@ -2350,7 +2350,7 @@ static void update_dchubp_dpp(
 static void program_all_pipe_in_tree(
 		struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	unsigned int ref_clk_mhz = dc->res_pool->ref_clock_inKhz/1000;
 
@@ -2408,7 +2408,7 @@ static void program_all_pipe_in_tree(
 
 static void dcn10_pplib_apply_display_requirements(
 	struct dc *dc,
-	struct validate_context *context)
+	struct dc_state *context)
 {
 	struct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;
 
@@ -2437,7 +2437,7 @@ static void dcn10_apply_ctx_for_surface(
 		struct dc *dc,
 		const struct dc_stream_state *stream,
 		int num_planes,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	int i, be_idx;
 
@@ -2457,7 +2457,7 @@ static void dcn10_apply_ctx_for_surface(
 	if (num_planes == 0) {
 		for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
 			struct pipe_ctx *old_pipe_ctx =
-							&dc->current_context->res_ctx.pipe_ctx[i];
+							&dc->current_state->res_ctx.pipe_ctx[i];
 
 			if (old_pipe_ctx->stream_res.tg && old_pipe_ctx->stream_res.tg->inst == be_idx) {
 				old_pipe_ctx->stream_res.tg->funcs->set_blank(old_pipe_ctx->stream_res.tg, true);
@@ -2471,7 +2471,7 @@ static void dcn10_apply_ctx_for_surface(
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *old_pipe_ctx =
-				&dc->current_context->res_ctx.pipe_ctx[i];
+				&dc->current_state->res_ctx.pipe_ctx[i];
 
 		if (!pipe_ctx->plane_state && !old_pipe_ctx->plane_state)
 			continue;
@@ -2591,7 +2591,7 @@ static void dcn10_apply_ctx_for_surface(
 
 static void dcn10_set_bandwidth(
 		struct dc *dc,
-		struct validate_context *context,
+		struct dc_state *context,
 		bool decrease_allowed)
 {
 	struct pp_smu_display_requirement_rv *smu_req_cur =
@@ -2607,25 +2607,25 @@ static void dcn10_set_bandwidth(
 		return;
 
 	if (decrease_allowed || context->bw.dcn.calc_clk.dispclk_khz
-			> dc->current_context->bw.dcn.cur_clk.dispclk_khz) {
+			> dc->current_state->bw.dcn.cur_clk.dispclk_khz) {
 		dc->res_pool->display_clock->funcs->set_clock(
 				dc->res_pool->display_clock,
 				context->bw.dcn.calc_clk.dispclk_khz);
-		dc->current_context->bw.dcn.cur_clk.dispclk_khz =
+		dc->current_state->bw.dcn.cur_clk.dispclk_khz =
 				context->bw.dcn.calc_clk.dispclk_khz;
 	}
 	if (decrease_allowed || context->bw.dcn.calc_clk.dcfclk_khz
-			> dc->current_context->bw.dcn.cur_clk.dcfclk_khz) {
+			> dc->current_state->bw.dcn.cur_clk.dcfclk_khz) {
 		smu_req.hard_min_dcefclk_khz =
 				context->bw.dcn.calc_clk.dcfclk_khz;
 	}
 	if (decrease_allowed || context->bw.dcn.calc_clk.fclk_khz
-			> dc->current_context->bw.dcn.cur_clk.fclk_khz) {
+			> dc->current_state->bw.dcn.cur_clk.fclk_khz) {
 		smu_req.hard_min_fclk_khz = context->bw.dcn.calc_clk.fclk_khz;
 	}
 	if (decrease_allowed || context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz
-			> dc->current_context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz) {
-		dc->current_context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz =
+			> dc->current_state->bw.dcn.cur_clk.dcfclk_deep_sleep_khz) {
+		dc->current_state->bw.dcn.calc_clk.dcfclk_deep_sleep_khz =
 				context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
 		context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz =
 				context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
@@ -2640,15 +2640,15 @@ static void dcn10_set_bandwidth(
 
 	/* Decrease in freq is increase in period so opposite comparison for dram_ccm */
 	if (decrease_allowed || context->bw.dcn.calc_clk.dram_ccm_us
-			< dc->current_context->bw.dcn.cur_clk.dram_ccm_us) {
-		dc->current_context->bw.dcn.calc_clk.dram_ccm_us =
+			< dc->current_state->bw.dcn.cur_clk.dram_ccm_us) {
+		dc->current_state->bw.dcn.calc_clk.dram_ccm_us =
 				context->bw.dcn.calc_clk.dram_ccm_us;
 		context->bw.dcn.cur_clk.dram_ccm_us =
 				context->bw.dcn.calc_clk.dram_ccm_us;
 	}
 	if (decrease_allowed || context->bw.dcn.calc_clk.min_active_dram_ccm_us
-			< dc->current_context->bw.dcn.cur_clk.min_active_dram_ccm_us) {
-		dc->current_context->bw.dcn.calc_clk.min_active_dram_ccm_us =
+			< dc->current_state->bw.dcn.cur_clk.min_active_dram_ccm_us) {
+		dc->current_state->bw.dcn.calc_clk.min_active_dram_ccm_us =
 				context->bw.dcn.calc_clk.min_active_dram_ccm_us;
 		context->bw.dcn.cur_clk.min_active_dram_ccm_us =
 				context->bw.dcn.calc_clk.min_active_dram_ccm_us;

commit 41f97c0773aed681ad65fa27ee88b503fbdcd298
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Thu Aug 24 17:40:00 2017 -0400

    drm/amd/display: DF C-state entry blocked when DPMS
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 4a24893486e8..9c54cae28997 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -776,6 +776,50 @@ static void power_on_plane(
 			"Un-gated front end for pipe %d\n", plane_id);
 }
 
+static void undo_DEGVIDCN10_253_wa(struct dc *dc)
+{
+	struct dce_hwseq *hws = dc->hwseq;
+	struct mem_input *mi = dc->res_pool->mis[0];
+
+	mi->funcs->set_blank(mi, true);
+
+	REG_SET(DC_IP_REQUEST_CNTL, 0,
+			IP_REQUEST_EN, 1);
+
+	hubp_pg_control(hws, 0, false);
+	REG_SET(DC_IP_REQUEST_CNTL, 0,
+			IP_REQUEST_EN, 0);
+}
+
+static void ready_shared_resources(struct dc *dc)
+{
+	if (dc->current_context->stream_count == 0 &&
+			!dc->debug.disable_stutter)
+		undo_DEGVIDCN10_253_wa(dc);
+}
+
+static void apply_DEGVIDCN10_253_wa(struct dc *dc)
+{
+	struct dce_hwseq *hws = dc->hwseq;
+	struct mem_input *mi = dc->res_pool->mis[0];
+
+	REG_SET(DC_IP_REQUEST_CNTL, 0,
+			IP_REQUEST_EN, 1);
+
+	hubp_pg_control(hws, 0, true);
+	REG_SET(DC_IP_REQUEST_CNTL, 0,
+			IP_REQUEST_EN, 0);
+
+	mi->funcs->set_hubp_blank_en(mi, false);
+}
+
+static void optimize_shared_resources(struct dc *dc)
+{
+	if (dc->current_context->stream_count == 0 &&
+			!dc->debug.disable_stutter)
+		apply_DEGVIDCN10_253_wa(dc);
+}
+
 static void bios_golden_init(struct dc *dc)
 {
 	struct dc_bios *bp = dc->ctx->dc_bios;
@@ -2829,7 +2873,9 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.setup_stereo = dcn10_setup_stereo,
 	.set_avmute = dce110_set_avmute,
 	.log_hw_state = dcn10_log_hw_state,
-	.wait_for_mpcc_disconnect = dcn10_wait_for_mpcc_disconnect
+	.wait_for_mpcc_disconnect = dcn10_wait_for_mpcc_disconnect,
+	.ready_shared_resources = ready_shared_resources,
+	.optimize_shared_resources = optimize_shared_resources,
 };
 
 

commit b3c340fad4643b7351a4777fae37e58925db04c9
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Sat Aug 19 16:34:36 2017 -0400

    drm/amd/display: move cm registers from ipp to dpp_cm
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 498680a9b996..4a24893486e8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1294,34 +1294,34 @@ static void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_c
 static bool dcn10_set_input_transfer_func(
 	struct pipe_ctx *pipe_ctx, const struct dc_plane_state *plane_state)
 {
-	struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
+	struct transform *xfm_base = pipe_ctx->plane_res.xfm;
 	const struct dc_transfer_func *tf = NULL;
 	bool result = true;
 
-	if (ipp == NULL)
+	if (xfm_base == NULL)
 		return false;
 
 	if (plane_state->in_transfer_func)
 		tf = plane_state->in_transfer_func;
 
 	if (plane_state->gamma_correction && dce_use_lut(plane_state))
-		ipp->funcs->ipp_program_input_lut(ipp,
+		xfm_base->funcs->ipp_program_input_lut(xfm_base,
 				plane_state->gamma_correction);
 
 	if (tf == NULL)
-		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
+		xfm_base->funcs->ipp_set_degamma(xfm_base, IPP_DEGAMMA_MODE_BYPASS);
 	else if (tf->type == TF_TYPE_PREDEFINED) {
 		switch (tf->tf) {
 		case TRANSFER_FUNCTION_SRGB:
-			ipp->funcs->ipp_set_degamma(ipp,
+			xfm_base->funcs->ipp_set_degamma(xfm_base,
 					IPP_DEGAMMA_MODE_HW_sRGB);
 			break;
 		case TRANSFER_FUNCTION_BT709:
-			ipp->funcs->ipp_set_degamma(ipp,
+			xfm_base->funcs->ipp_set_degamma(xfm_base,
 					IPP_DEGAMMA_MODE_HW_xvYCC);
 			break;
 		case TRANSFER_FUNCTION_LINEAR:
-			ipp->funcs->ipp_set_degamma(ipp,
+			xfm_base->funcs->ipp_set_degamma(xfm_base,
 					IPP_DEGAMMA_MODE_BYPASS);
 			break;
 		case TRANSFER_FUNCTION_PQ:
@@ -1332,7 +1332,7 @@ static bool dcn10_set_input_transfer_func(
 			break;
 		}
 	} else if (tf->type == TF_TYPE_BYPASS) {
-		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
+		xfm_base->funcs->ipp_set_degamma(xfm_base, IPP_DEGAMMA_MODE_BYPASS);
 	} else {
 		/*TF_TYPE_DISTRIBUTED_POINTS*/
 		result = false;
@@ -2204,7 +2204,7 @@ static void update_dchubp_dpp(
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct mem_input *mi = pipe_ctx->plane_res.mi;
-	struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
+	struct transform *xfm = pipe_ctx->plane_res.xfm;
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	union plane_size size = plane_state->plane_size;
 	struct default_adjustment ocsc = {0};
@@ -2249,7 +2249,7 @@ static void update_dchubp_dpp(
 				hws
 				);
 
-	ipp->funcs->ipp_setup(ipp,
+	xfm->funcs->ipp_setup(xfm,
 			plane_state->format,
 			1,
 			IPP_OUTPUT_FORMAT_12_BIT_FIX);

commit e1b522bff39d4834f4cfedc557857bb4d50f3946
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Aug 24 17:29:24 2017 -0400

    drm/amd/display: work around for 8k sleep crash
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index bd023299e2af..498680a9b996 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2358,7 +2358,7 @@ static void program_all_pipe_in_tree(
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
 
-	if (pipe_ctx->bottom_pipe != NULL)
+	if (pipe_ctx->bottom_pipe != NULL && pipe_ctx->bottom_pipe != pipe_ctx)
 		program_all_pipe_in_tree(dc, pipe_ctx->bottom_pipe, context);
 }
 

commit 39902db0343e0e4f335324d22d6707303be24448
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Mon Aug 21 11:46:17 2017 -0400

    drm/amd/display: Change log level for DCN powergatting
    
    Change log level from LOG_DC to LOG_DEBUG
    LOG_DC spams dmesg on linux when hotpluging
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 20c4164a59d0..bd023299e2af 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -772,7 +772,7 @@ static void power_on_plane(
 	hubp_pg_control(hws, plane_id, true);
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
-	dm_logger_write(hws->ctx->logger, LOG_DC,
+	dm_logger_write(hws->ctx->logger, LOG_DEBUG,
 			"Un-gated front end for pipe %d\n", plane_id);
 }
 
@@ -1003,7 +1003,7 @@ static void reset_back_end_for_pipe(
 		return;
 
 	pipe_ctx->stream = NULL;
-	dm_logger_write(dc->ctx->logger, LOG_DC,
+	dm_logger_write(dc->ctx->logger, LOG_DEBUG,
 					"Reset back end for pipe %d, tg:%d\n",
 					pipe_ctx->pipe_idx, pipe_ctx->stream_res.tg->inst);
 }
@@ -1096,7 +1096,7 @@ static void plane_atomic_power_down(struct dc *dc, int fe_idx)
 	xfm->funcs->transform_reset(xfm);
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
-	dm_logger_write(dc->ctx->logger, LOG_DC,
+	dm_logger_write(dc->ctx->logger, LOG_DEBUG,
 			"Power gated front end %d\n", fe_idx);
 
 	if (dc->debug.sanity_checks)
@@ -1153,7 +1153,7 @@ static void dcn10_power_down_fe(struct dc *dc, int fe_idx)
 	xfm->funcs->transform_reset(xfm);
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
-	dm_logger_write(dc->ctx->logger, LOG_DC,
+	dm_logger_write(dc->ctx->logger, LOG_DEBUG,
 			"Power gated front end %d\n", fe_idx);
 
 	if (dc->debug.sanity_checks)
@@ -1921,7 +1921,7 @@ static void dcn10_power_on_fe(
 	/*TODO: REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DPPCLK_WDIVIDER, 0x1f);*/
 
 	if (plane_state) {
-		dm_logger_write(dc->ctx->logger, LOG_DC,
+		dm_logger_write(dc->ctx->logger, LOG_DEBUG,
 				"Pipe:%d 0x%x: addr hi:0x%x, "
 				"addr low:0x%x, "
 				"src: %d, %d, %d,"
@@ -1939,7 +1939,7 @@ static void dcn10_power_on_fe(
 				plane_state->dst_rect.width,
 				plane_state->dst_rect.height);
 
-		dm_logger_write(dc->ctx->logger, LOG_HW_SET_MODE,
+		dm_logger_write(dc->ctx->logger, LOG_DEBUG,
 				"Pipe %d: width, height, x, y\n"
 				"viewport:%d, %d, %d, %d\n"
 				"recout:  %d, %d, %d, %d\n",

commit 5f06b3cf90d252160352442a789cad410eb6696e
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Sun Aug 20 14:25:19 2017 -0400

    drm/amd/display: retire dm_pp_apply_clock_for_voltage_request
    
    set dcfclk and fclk req with pp_smu_display_requirement_rv
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 54e37b10ffbf..20c4164a59d0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2550,7 +2550,10 @@ static void dcn10_set_bandwidth(
 		struct validate_context *context,
 		bool decrease_allowed)
 {
-	struct dm_pp_clock_for_voltage_req clock;
+	struct pp_smu_display_requirement_rv *smu_req_cur =
+			&dc->res_pool->pp_smu_req;
+	struct pp_smu_display_requirement_rv smu_req = *smu_req_cur;
+	struct pp_smu_funcs_rv *pp_smu = dc->res_pool->pp_smu;
 
 	if (dc->debug.sanity_checks) {
 		verify_allow_pstate_change_high(dc->hwseq);
@@ -2569,19 +2572,12 @@ static void dcn10_set_bandwidth(
 	}
 	if (decrease_allowed || context->bw.dcn.calc_clk.dcfclk_khz
 			> dc->current_context->bw.dcn.cur_clk.dcfclk_khz) {
-		clock.clk_type = DM_PP_CLOCK_TYPE_DCFCLK;
-		clock.clocks_in_khz = context->bw.dcn.calc_clk.dcfclk_khz;
-		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
-		dc->current_context->bw.dcn.cur_clk.dcfclk_khz = clock.clocks_in_khz;
-		context->bw.dcn.cur_clk.dcfclk_khz = clock.clocks_in_khz;
+		smu_req.hard_min_dcefclk_khz =
+				context->bw.dcn.calc_clk.dcfclk_khz;
 	}
 	if (decrease_allowed || context->bw.dcn.calc_clk.fclk_khz
 			> dc->current_context->bw.dcn.cur_clk.fclk_khz) {
-		clock.clk_type = DM_PP_CLOCK_TYPE_FCLK;
-		clock.clocks_in_khz = context->bw.dcn.calc_clk.fclk_khz;
-		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
-		dc->current_context->bw.dcn.calc_clk.fclk_khz = clock.clocks_in_khz;
-		context->bw.dcn.cur_clk.fclk_khz = clock.clocks_in_khz;
+		smu_req.hard_min_fclk_khz = context->bw.dcn.calc_clk.fclk_khz;
 	}
 	if (decrease_allowed || context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz
 			> dc->current_context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz) {
@@ -2590,6 +2586,14 @@ static void dcn10_set_bandwidth(
 		context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz =
 				context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
 	}
+
+	smu_req.display_count = context->stream_count;
+
+	if (pp_smu->set_display_requirement)
+		pp_smu->set_display_requirement(&pp_smu->pp_smu, &smu_req);
+
+	*smu_req_cur = smu_req;
+
 	/* Decrease in freq is increase in period so opposite comparison for dram_ccm */
 	if (decrease_allowed || context->bw.dcn.calc_clk.dram_ccm_us
 			< dc->current_context->bw.dcn.cur_clk.dram_ccm_us) {

commit 0045b749bdedc60ca46a7801cb9b5ae967bea669
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Aug 22 10:29:23 2017 -0400

    drm/amd/display: dc: Remove unneeded includes in DCN
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 69f67f6e27b1..54e37b10ffbf 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -39,9 +39,6 @@
 #include "opp.h"
 #include "ipp.h"
 #include "mpc.h"
-#include "raven1/DCN/dcn_1_0_offset.h"
-#include "raven1/DCN/dcn_1_0_sh_mask.h"
-#include "vega10/soc15ip.h"
 #include "reg_helper.h"
 
 #define CTX \

commit 8eb5def95762dc1cd9e516510925a95060452c5a
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jul 28 08:16:27 2017 -0400

    drm/amd/display: fix hubp mpcc and opp tracking
    
    This should be handled by mi and mpc only
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index ddfa6a8d087b..69f67f6e27b1 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1066,9 +1066,6 @@ static void plane_atomic_disable(struct dc *dc,
 			fe_idx);*/
 
 	mi->funcs->set_blank(mi, true);
-	/*todo: unhack this*/
-	mi->opp_id = 0xf;
-	mi->mpcc_id = 0xf;
 
 	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
@@ -2304,7 +2301,8 @@ static void update_dchubp_dpp(
 		&plane_state->dcc,
 		plane_state->horizontal_mirror);
 
-	mi->funcs->set_blank(mi, !is_pipe_tree_visible(pipe_ctx));
+	if (is_pipe_tree_visible(pipe_ctx))
+		mi->funcs->set_blank(mi, false);
 }
 
 

commit 214435ff1369a9d48c194c7a75d918130c53bab2
Author: Corbin McElhanney <corbin.mcelhanney@amd.com>
Date:   Wed Aug 16 11:49:07 2017 -0400

    drm/amd/display: Log OTG registers with dcn10 hw state
    
    Signed-off-by: Corbin McElhanney <corbin.mcelhanney@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f0e49d16019c..ddfa6a8d087b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -32,6 +32,7 @@
 #include "dce/dce_hwseq.h"
 #include "abm.h"
 #include "dcn10/dcn10_mem_input.h"
+#include "dcn10/dcn10_timing_generator.h"
 #include "dcn10/dcn10_dpp.h"
 #include "dcn10/dcn10_mpc.h"
 #include "timing_generator.h"
@@ -200,6 +201,38 @@ static void dcn10_log_hw_state(struct dc *dc)
 	}
 	DTN_INFO("\n");
 
+	DTN_INFO("OTG:\t v_bs \t v_be \t v_ss \t v_se \t vpol \t vmax \t vmin \t "
+			"h_bs \t h_be \t h_ss \t h_se \t hpol \t htot \t vtot \t underflow\n");
+
+	for (i = 0; i < pool->pipe_count; i++) {
+		struct timing_generator *tg = pool->timing_generators[i];
+		struct dcn_otg_state s;
+
+		tgn10_read_otg_state(DCN10TG_FROM_TG(tg), &s);
+
+		DTN_INFO("[%d]:\t %d \t %d \t %d \t %d \t "
+				"%d \t %d \t %d \t %d \t %d \t %d \t "
+				"%d \t %d \t %d \t %d \t %d \t ",
+				i,
+				s.v_blank_start,
+				s.v_blank_end,
+				s.v_sync_a_start,
+				s.v_sync_a_end,
+				s.v_sync_a_pol,
+				s.v_total_max,
+				s.v_total_min,
+				s.h_blank_start,
+				s.h_blank_end,
+				s.h_sync_a_start,
+				s.h_sync_a_end,
+				s.h_sync_a_pol,
+				s.h_total,
+				s.v_total,
+				s.underflow_occurred_status);
+		DTN_INFO("\n");
+	}
+	DTN_INFO("\n");
+
 	log_mpc_crc(dc);
 
 	DTN_INFO_END();

commit 0cb8a88122ecfaa183ede19748269cb4fb5c739c
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Mon Aug 14 18:17:01 2017 -0400

    drm/amd/display: move vm registers to hwsequencer
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 23aa6e1242c5..f0e49d16019c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2083,6 +2083,93 @@ static void dcn10_get_surface_visual_confirm_color(
 	}
 }
 
+static void mmhub_read_vm_system_aperture_settings(struct dcn10_mem_input *mi,
+		struct vm_system_aperture_param *apt,
+		struct dce_hwseq *hws)
+{
+	PHYSICAL_ADDRESS_LOC physical_page_number;
+	uint32_t logical_addr_low;
+	uint32_t logical_addr_high;
+
+	REG_GET(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB,
+			PHYSICAL_PAGE_NUMBER_MSB, &physical_page_number.high_part);
+	REG_GET(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB,
+			PHYSICAL_PAGE_NUMBER_LSB, &physical_page_number.low_part);
+
+	REG_GET(MC_VM_SYSTEM_APERTURE_LOW_ADDR,
+			LOGICAL_ADDR, &logical_addr_low);
+
+	REG_GET(MC_VM_SYSTEM_APERTURE_HIGH_ADDR,
+			LOGICAL_ADDR, &logical_addr_high);
+
+	apt->sys_default.quad_part =  physical_page_number.quad_part << 12;
+	apt->sys_low.quad_part =  (int64_t)logical_addr_low << 18;
+	apt->sys_high.quad_part =  (int64_t)logical_addr_high << 18;
+}
+
+/* Temporary read settings, future will get values from kmd directly */
+static void mmhub_read_vm_context0_settings(struct dcn10_mem_input *mi,
+		struct vm_context0_param *vm0,
+		struct dce_hwseq *hws)
+{
+	PHYSICAL_ADDRESS_LOC fb_base;
+	PHYSICAL_ADDRESS_LOC fb_offset;
+	uint32_t fb_base_value;
+	uint32_t fb_offset_value;
+
+	REG_GET(DCHUBBUB_SDPIF_FB_BASE, SDPIF_FB_BASE, &fb_base_value);
+	REG_GET(DCHUBBUB_SDPIF_FB_OFFSET, SDPIF_FB_OFFSET, &fb_offset_value);
+
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_HI32,
+			PAGE_DIRECTORY_ENTRY_HI32, &vm0->pte_base.high_part);
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR_LO32,
+			PAGE_DIRECTORY_ENTRY_LO32, &vm0->pte_base.low_part);
+
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_START_ADDR_HI32,
+			LOGICAL_PAGE_NUMBER_HI4, &vm0->pte_start.high_part);
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_START_ADDR_LO32,
+			LOGICAL_PAGE_NUMBER_LO32, &vm0->pte_start.low_part);
+
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_END_ADDR_HI32,
+			LOGICAL_PAGE_NUMBER_HI4, &vm0->pte_end.high_part);
+	REG_GET(VM_CONTEXT0_PAGE_TABLE_END_ADDR_LO32,
+			LOGICAL_PAGE_NUMBER_LO32, &vm0->pte_end.low_part);
+
+	REG_GET(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_HI32,
+			PHYSICAL_PAGE_ADDR_HI4, &vm0->fault_default.high_part);
+	REG_GET(VM_L2_PROTECTION_FAULT_DEFAULT_ADDR_LO32,
+			PHYSICAL_PAGE_ADDR_LO32, &vm0->fault_default.low_part);
+
+	/*
+	 * The values in VM_CONTEXT0_PAGE_TABLE_BASE_ADDR is in UMA space.
+	 * Therefore we need to do
+	 * DCN_VM_CONTEXT0_PAGE_TABLE_BASE_ADDR = VM_CONTEXT0_PAGE_TABLE_BASE_ADDR
+	 * - DCHUBBUB_SDPIF_FB_OFFSET + DCHUBBUB_SDPIF_FB_BASE
+	 */
+	fb_base.quad_part = (uint64_t)fb_base_value << 24;
+	fb_offset.quad_part = (uint64_t)fb_offset_value << 24;
+	vm0->pte_base.quad_part += fb_base.quad_part;
+	vm0->pte_base.quad_part -= fb_offset.quad_part;
+}
+
+static void dcn10_program_pte_vm(struct mem_input *mem_input,
+		enum surface_pixel_format format,
+		union dc_tiling_info *tiling_info,
+		enum dc_rotation_angle rotation,
+		struct dce_hwseq *hws)
+{
+	struct dcn10_mem_input *mi = TO_DCN10_MEM_INPUT(mem_input);
+	struct vm_system_aperture_param apt = { {{ 0 } } };
+	struct vm_context0_param vm0 = { { { 0 } } };
+
+
+	mmhub_read_vm_system_aperture_settings(mi, &apt, hws);
+	mmhub_read_vm_context0_settings(mi, &vm0, hws);
+
+	mem_input->funcs->mem_input_set_vm_system_aperture_settings(mem_input, &apt);
+	mem_input->funcs->mem_input_set_vm_context0_settings(mem_input, &vm0);
+}
+
 static void update_dchubp_dpp(
 	struct dc *dc,
 	struct pipe_ctx *pipe_ctx,
@@ -2127,11 +2214,13 @@ static void update_dchubp_dpp(
 	size.grph.surface_size = pipe_ctx->plane_res.scl_data.viewport;
 
 	if (dc->config.gpu_vm_support)
-		mi->funcs->mem_input_program_pte_vm(
+		dcn10_program_pte_vm(
 				pipe_ctx->plane_res.mi,
 				plane_state->format,
 				&plane_state->tiling_info,
-				plane_state->rotation);
+				plane_state->rotation,
+				hws
+				);
 
 	ipp->funcs->ipp_setup(ipp,
 			plane_state->format,
@@ -2674,6 +2763,8 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 	}
 }
 
+
+
 static const struct hw_sequencer_funcs dcn10_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.program_csc_matrix = program_csc_matrix,

commit 992fe94c1b6afdf6f09ada61d4a1ecc5df52fe5f
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Thu Aug 3 08:49:41 2017 -0400

    drm/amd/display: remove fake address reporting when blank
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index ce48d81c4442..23aa6e1242c5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2666,14 +2666,6 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->plane_res.mi->funcs->mem_input_is_flip_pending(
 					pipe_ctx->plane_res.mi);
 
-	/* DCN we read INUSE address in MI, do we still need this wa? */
-	if (plane_state->status.is_flip_pending &&
-			!plane_state->visible) {
-		pipe_ctx->plane_res.mi->current_address =
-				pipe_ctx->plane_res.mi->request_address;
-		BREAK_TO_DEBUGGER();
-	}
-
 	plane_state->status.current_address = pipe_ctx->plane_res.mi->current_address;
 	if (pipe_ctx->plane_res.mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 			tg->funcs->is_stereo_left_eye) {

commit 4e772ae5f99a1595a2e064a70d2eab4946e5c08d
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Aug 11 11:23:30 2017 -0400

    drm/amd/display: blank otg before power gate front end.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d5d2398d92b8..ce48d81c4442 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2298,8 +2298,10 @@ static void dcn10_apply_ctx_for_surface(
 			struct pipe_ctx *old_pipe_ctx =
 							&dc->current_context->res_ctx.pipe_ctx[i];
 
-			if (old_pipe_ctx->stream_res.tg && old_pipe_ctx->stream_res.tg->inst == be_idx)
+			if (old_pipe_ctx->stream_res.tg && old_pipe_ctx->stream_res.tg->inst == be_idx) {
+				old_pipe_ctx->stream_res.tg->funcs->set_blank(old_pipe_ctx->stream_res.tg, true);
 				dcn10_power_down_fe(dc, old_pipe_ctx->pipe_idx);
+			}
 		}
 		return;
 	}

commit fb3466a450cc4684654367ae2f47fc3fc7846574
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Aug 1 15:00:25 2017 -0400

    drm/amd/display: Flattening core_dc to dc
    
    -Flattening core_dc to dc
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 184627c8685e..d5d2398d92b8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -52,7 +52,7 @@
 #define FN(reg_name, field_name) \
 	hws->shifts->field_name, hws->masks->field_name
 
-static void log_mpc_crc(struct core_dc *dc)
+static void log_mpc_crc(struct dc *dc)
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	struct dce_hwseq *hws = dc->hwseq;
@@ -130,7 +130,7 @@ static void dcn10_hubbub_wm_read_state(struct dce_hwseq *hws,
 	s->dram_clk_chanage = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_D);
 }
 
-static void dcn10_log_hubbub_state(struct core_dc *dc)
+static void dcn10_log_hubbub_state(struct dc *dc)
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	struct dcn_hubbub_wm wm;
@@ -157,7 +157,7 @@ static void dcn10_log_hubbub_state(struct core_dc *dc)
 	DTN_INFO("\n");
 }
 
-static void dcn10_log_hw_state(struct core_dc *dc)
+static void dcn10_log_hw_state(struct dc *dc)
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	struct resource_pool *pool = dc->res_pool;
@@ -273,7 +273,7 @@ static void verify_allow_pstate_change_high(
 	forced_pstate_allow = true;
 
 	if (should_log_hw_state) {
-		dcn10_log_hw_state(DC_TO_CORE(hws->ctx->dc));
+		dcn10_log_hw_state(hws->ctx->dc);
 	}
 
 	BREAK_TO_DEBUGGER();
@@ -746,7 +746,7 @@ static void power_on_plane(
 			"Un-gated front end for pipe %d\n", plane_id);
 }
 
-static void bios_golden_init(struct core_dc *dc)
+static void bios_golden_init(struct dc *dc)
 {
 	struct dc_bios *bp = dc->ctx->dc_bios;
 	int i;
@@ -762,7 +762,7 @@ static void bios_golden_init(struct core_dc *dc)
 	}
 }
 
-static void dcn10_init_hw(struct core_dc *dc)
+static void dcn10_init_hw(struct dc *dc)
 {
 	int i;
 	struct abm *abm = dc->res_pool->abm;
@@ -773,7 +773,7 @@ static void dcn10_init_hw(struct core_dc *dc)
 		REG_UPDATE(DCHUBBUB_GLOBAL_TIMER_CNTL, DCHUBBUB_GLOBAL_TIMER_ENABLE, 1);
 		REG_WRITE(DIO_MEM_PWR_CTRL, 0);
 
-		if (!dc->public.debug.disable_clock_gate) {
+		if (!dc->debug.disable_clock_gate) {
 			/* enable all DCN clock gating */
 			REG_WRITE(DCCG_GATE_DISABLE_CNTL, 0);
 
@@ -830,7 +830,7 @@ static void dcn10_init_hw(struct core_dc *dc)
 	/* power AFMT HDMI memory TODO: may move to dis/en output save power*/
 	REG_WRITE(DIO_MEM_PWR_CTRL, 0);
 
-	if (!dc->public.debug.disable_clock_gate) {
+	if (!dc->debug.disable_clock_gate) {
 		/* enable all DCN clock gating */
 		REG_WRITE(DCCG_GATE_DISABLE_CNTL, 0);
 
@@ -845,7 +845,7 @@ static void dcn10_init_hw(struct core_dc *dc)
 static enum dc_status dcn10_prog_pixclk_crtc_otg(
 		struct pipe_ctx *pipe_ctx,
 		struct validate_context *context,
-		struct core_dc *dc)
+		struct dc *dc)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	enum dc_color_space color_space;
@@ -932,7 +932,7 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 }
 
 static void reset_back_end_for_pipe(
-		struct core_dc *dc,
+		struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
 		struct validate_context *context)
 {
@@ -979,7 +979,7 @@ static void reset_back_end_for_pipe(
 }
 
 /* trigger HW to start disconnect plane from stream on the next vsync */
-static void plane_atomic_disconnect(struct core_dc *dc,
+static void plane_atomic_disconnect(struct dc *dc,
 		int fe_idx)
 {
 	struct mem_input *mi = dc->res_pool->mis[fe_idx];
@@ -1004,10 +1004,10 @@ static void plane_atomic_disconnect(struct core_dc *dc,
 	if (opp_id == dc->res_pool->pipe_count)
 		return;
 
-	if (dc->public.debug.sanity_checks)
+	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 	mi->funcs->dcc_control(mi, false, false);
-	if (dc->public.debug.sanity_checks)
+	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
 	mpc->funcs->remove(mpc, dc->res_pool->opps[opp_id], fe_idx);
@@ -1015,7 +1015,7 @@ static void plane_atomic_disconnect(struct core_dc *dc,
 
 /* disable HW used by plane.
  * note:  cannot disable until disconnect is complete */
-static void plane_atomic_disable(struct core_dc *dc,
+static void plane_atomic_disable(struct dc *dc,
 		int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
@@ -1037,7 +1037,7 @@ static void plane_atomic_disable(struct core_dc *dc,
 	mi->opp_id = 0xf;
 	mi->mpcc_id = 0xf;
 
-	if (dc->public.debug.sanity_checks)
+	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
 	REG_UPDATE(HUBP_CLK_CNTL[fe_idx],
@@ -1049,7 +1049,7 @@ static void plane_atomic_disable(struct core_dc *dc,
 		REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
 				OPP_PIPE_CLOCK_EN, 0);
 
-	if (dc->public.debug.sanity_checks)
+	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 }
 
@@ -1057,7 +1057,7 @@ static void plane_atomic_disable(struct core_dc *dc,
  * kill power to plane hw
  * note: cannot power down until plane is disable
  */
-static void plane_atomic_power_down(struct core_dc *dc, int fe_idx)
+static void plane_atomic_power_down(struct dc *dc, int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct transform *xfm = dc->res_pool->transforms[fe_idx];
@@ -1072,13 +1072,13 @@ static void plane_atomic_power_down(struct core_dc *dc, int fe_idx)
 	dm_logger_write(dc->ctx->logger, LOG_DC,
 			"Power gated front end %d\n", fe_idx);
 
-	if (dc->public.debug.sanity_checks)
+	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 }
 
 
 static void reset_front_end(
-		struct core_dc *dc,
+		struct dc *dc,
 		int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
@@ -1097,7 +1097,7 @@ static void reset_front_end(
 	REG_UPDATE(OTG_GLOBAL_SYNC_STATUS[tg->inst], VUPDATE_NO_LOCK_EVENT_CLEAR, 1);
 	tg->funcs->unlock(tg);
 
-	if (dc->public.debug.sanity_checks)
+	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(hws);
 
 	if (tg->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
@@ -1112,7 +1112,7 @@ static void reset_front_end(
 					fe_idx);
 }
 
-static void dcn10_power_down_fe(struct core_dc *dc, int fe_idx)
+static void dcn10_power_down_fe(struct dc *dc, int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct transform *xfm = dc->res_pool->transforms[fe_idx];
@@ -1129,12 +1129,12 @@ static void dcn10_power_down_fe(struct core_dc *dc, int fe_idx)
 	dm_logger_write(dc->ctx->logger, LOG_DC,
 			"Power gated front end %d\n", fe_idx);
 
-	if (dc->public.debug.sanity_checks)
+	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 }
 
 static void reset_hw_ctx_wrap(
-		struct core_dc *dc,
+		struct dc *dc,
 		struct validate_context *context)
 {
 	int i;
@@ -1246,7 +1246,7 @@ static void toggle_watermark_change_req(struct dce_hwseq *hws)
 			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, watermark_change_req);
 }
 
-static void dcn10_update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ctx)
+static void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	bool addr_patched = false;
 	PHYSICAL_ADDRESS_LOC addr;
@@ -1657,7 +1657,7 @@ static bool dcn10_set_output_transfer_func(
 }
 
 static void dcn10_pipe_control_lock(
-	struct core_dc *dc,
+	struct dc *dc,
 	struct pipe_ctx *pipe,
 	bool lock)
 {
@@ -1669,7 +1669,7 @@ static void dcn10_pipe_control_lock(
 	if (pipe->top_pipe)
 		return;
 
-	if (dc->public.debug.sanity_checks)
+	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
 	if (lock)
@@ -1677,7 +1677,7 @@ static void dcn10_pipe_control_lock(
 	else
 		pipe->stream_res.tg->funcs->unlock(pipe->stream_res.tg);
 
-	if (dc->public.debug.sanity_checks)
+	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 }
 
@@ -1719,7 +1719,7 @@ static bool wait_for_reset_trigger_to_occur(
 }
 
 static void dcn10_enable_timing_synchronization(
-	struct core_dc *dc,
+	struct dc *dc,
 	int group_index,
 	int group_size,
 	struct pipe_ctx *grouped_pipes[])
@@ -1748,7 +1748,7 @@ static void dcn10_enable_timing_synchronization(
 }
 
 static void print_rq_dlg_ttu(
-		struct core_dc *core_dc,
+		struct dc *core_dc,
 		struct pipe_ctx *pipe_ctx)
 {
 	dm_logger_write(core_dc->ctx->logger, LOG_BANDWIDTH_CALCS,
@@ -1870,14 +1870,14 @@ static void print_rq_dlg_ttu(
 }
 
 static void dcn10_power_on_fe(
-	struct core_dc *dc,
+	struct dc *dc,
 	struct pipe_ctx *pipe_ctx,
 	struct validate_context *context)
 {
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct dce_hwseq *hws = dc->hwseq;
 
-	if (dc->public.debug.sanity_checks) {
+	if (dc->debug.sanity_checks) {
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
 
@@ -1928,7 +1928,7 @@ static void dcn10_power_on_fe(
 		print_rq_dlg_ttu(dc, pipe_ctx);
 	}
 
-	if (dc->public.debug.sanity_checks) {
+	if (dc->debug.sanity_checks) {
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
 }
@@ -2084,7 +2084,7 @@ static void dcn10_get_surface_visual_confirm_color(
 }
 
 static void update_dchubp_dpp(
-	struct core_dc *dc,
+	struct dc *dc,
 	struct pipe_ctx *pipe_ctx,
 	struct validate_context *context)
 {
@@ -2126,7 +2126,7 @@ static void update_dchubp_dpp(
 
 	size.grph.surface_size = pipe_ctx->plane_res.scl_data.viewport;
 
-	if (dc->public.config.gpu_vm_support)
+	if (dc->config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->plane_res.mi,
 				plane_state->format,
@@ -2142,7 +2142,7 @@ static void update_dchubp_dpp(
 	mpcc_cfg.opp = pipe_ctx->stream_res.opp;
 	for (top_pipe = pipe_ctx->top_pipe; top_pipe; top_pipe = top_pipe->top_pipe)
 		mpcc_cfg.z_index++;
-	if (dc->public.debug.surface_visual_confirm)
+	if (dc->debug.surface_visual_confirm)
 		dcn10_get_surface_visual_confirm_color(
 				pipe_ctx, &mpcc_cfg.black_color);
 	else
@@ -2187,7 +2187,7 @@ static void update_dchubp_dpp(
 
 
 static void program_all_pipe_in_tree(
-		struct core_dc *dc,
+		struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
 		struct validate_context *context)
 {
@@ -2201,7 +2201,7 @@ static void program_all_pipe_in_tree(
 		/* watermark is for all pipes */
 		program_watermarks(dc->hwseq, &context->bw.dcn.watermarks, ref_clk_mhz);
 
-		if (dc->public.debug.sanity_checks) {
+		if (dc->debug.sanity_checks) {
 			/* pstate stuck check after watermark update */
 			verify_allow_pstate_change_high(dc->hwseq);
 		}
@@ -2236,7 +2236,7 @@ static void program_all_pipe_in_tree(
 		update_dchubp_dpp(dc, pipe_ctx, context);
 	}
 
-	if (dc->public.debug.sanity_checks) {
+	if (dc->debug.sanity_checks) {
 		/* pstate stuck check after each pipe is programmed */
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
@@ -2246,7 +2246,7 @@ static void program_all_pipe_in_tree(
 }
 
 static void dcn10_pplib_apply_display_requirements(
-	struct core_dc *dc,
+	struct dc *dc,
 	struct validate_context *context)
 {
 	struct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;
@@ -2273,14 +2273,14 @@ static void dcn10_pplib_apply_display_requirements(
 }
 
 static void dcn10_apply_ctx_for_surface(
-		struct core_dc *dc,
+		struct dc *dc,
 		const struct dc_stream_state *stream,
 		int num_planes,
 		struct validate_context *context)
 {
 	int i, be_idx;
 
-	if (dc->public.debug.sanity_checks)
+	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
 	be_idx = -1;
@@ -2351,7 +2351,7 @@ static void dcn10_apply_ctx_for_surface(
 					"[debug_mpo: apply_ctx disconnect pending on mpcc %d]\n",
 					old_pipe_ctx->mpcc->inst);*/
 
-			if (dc->public.debug.sanity_checks)
+			if (dc->debug.sanity_checks)
 				verify_allow_pstate_change_high(dc->hwseq);
 
 			old_pipe_ctx->top_pipe = NULL;
@@ -2422,18 +2422,18 @@ static void dcn10_apply_ctx_for_surface(
 			context->bw.dcn.watermarks.d.pte_meta_urgent_ns
 			);
 
-	if (dc->public.debug.sanity_checks)
+	if (dc->debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 }
 
 static void dcn10_set_bandwidth(
-		struct core_dc *dc,
+		struct dc *dc,
 		struct validate_context *context,
 		bool decrease_allowed)
 {
 	struct dm_pp_clock_for_voltage_req clock;
 
-	if (dc->public.debug.sanity_checks) {
+	if (dc->debug.sanity_checks) {
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
 
@@ -2488,7 +2488,7 @@ static void dcn10_set_bandwidth(
 	}
 	dcn10_pplib_apply_display_requirements(dc, context);
 
-	if (dc->public.debug.sanity_checks) {
+	if (dc->debug.sanity_checks) {
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
 
@@ -2541,7 +2541,7 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
 }
 
 static void set_plane_config(
-	const struct core_dc *dc,
+	const struct dc *dc,
 	struct pipe_ctx *pipe_ctx,
 	struct resource_context *res_ctx)
 {
@@ -2586,7 +2586,7 @@ static void dcn10_config_stereo_parameters(
 	return;
 }
 
-static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct core_dc *dc)
+static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct dc *dc)
 {
 	struct crtc_stereo_flags flags = { 0 };
 	struct dc_stream_state *stream = pipe_ctx->stream;
@@ -2607,13 +2607,13 @@ static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct core_dc *dc)
 }
 
 static void dcn10_wait_for_mpcc_disconnect(
-		struct core_dc *dc,
+		struct dc *dc,
 		struct resource_pool *res_pool,
 		struct pipe_ctx *pipe_ctx)
 {
 	int i;
 
-	if (dc->public.debug.sanity_checks) {
+	if (dc->debug.sanity_checks) {
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
 
@@ -2631,14 +2631,14 @@ static void dcn10_wait_for_mpcc_disconnect(
 		}
 	}
 
-	if (dc->public.debug.sanity_checks) {
+	if (dc->debug.sanity_checks) {
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
 
 }
 
 static bool dcn10_dummy_display_power_gating(
-	struct core_dc *dc,
+	struct dc *dc,
 	uint8_t controller_id,
 	struct dc_bios *dcb,
 	enum pipe_gating_control power_gating)
@@ -2652,7 +2652,7 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 	struct timing_generator *tg = pipe_ctx->stream_res.tg;
 
 	if (plane_state->ctx->dc->debug.sanity_checks) {
-		struct core_dc *dc = DC_TO_CORE(plane_state->ctx->dc);
+		struct dc *dc = plane_state->ctx->dc;
 
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
@@ -2716,7 +2716,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 };
 
 
-void dcn10_hw_sequencer_construct(struct core_dc *dc)
+void dcn10_hw_sequencer_construct(struct dc *dc)
 {
 	dc->hwss = dcn10_funcs;
 }

commit 503a7c6f2518be909fa61276ee002846524b588b
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Aug 3 10:19:58 2017 -0400

    drm/amd/display: Use function pointer for update_plane_addr
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7b943e1837ce..184627c8685e 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1246,7 +1246,7 @@ static void toggle_watermark_change_req(struct dce_hwseq *hws)
 			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, watermark_change_req);
 }
 
-static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ctx)
+static void dcn10_update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	bool addr_patched = false;
 	PHYSICAL_ADDRESS_LOC addr;
@@ -2115,7 +2115,7 @@ static void update_dchubp_dpp(
 	 */
 	REG_UPDATE(DCHUBP_CNTL[pipe_ctx->pipe_idx], HUBP_VTG_SEL, pipe_ctx->stream_res.tg->inst);
 
-	update_plane_addr(dc, pipe_ctx);
+	dc->hwss.update_plane_addr(dc, pipe_ctx);
 
 	mi->funcs->mem_input_setup(
 		mi,
@@ -2687,7 +2687,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
 	.apply_ctx_for_surface = dcn10_apply_ctx_for_surface,
 	.set_plane_config = set_plane_config,
-	.update_plane_addr = update_plane_addr,
+	.update_plane_addr = dcn10_update_plane_addr,
 	.update_dchub = dcn10_update_dchub,
 	.update_pending_status = dcn10_update_pending_status,
 	.set_input_transfer_func = dcn10_set_input_transfer_func,

commit 233dcd2092f9f9786ff019174b1d38f288231f2c
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Thu Aug 3 23:21:46 2017 -0400

    drm/amd/display: log watermarks
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index b07ca5693cb6..7b943e1837ce 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -79,6 +79,84 @@ void print_microsec(struct dc_context *dc_ctx, uint32_t ref_cycle)
 #define DTN_INFO_MICRO_SEC(ref_cycle) \
 	print_microsec(dc_ctx, ref_cycle)
 
+struct dcn_hubbub_wm_set {
+	uint32_t wm_set;
+	uint32_t data_urgent;
+	uint32_t pte_meta_urgent;
+	uint32_t sr_enter;
+	uint32_t sr_exit;
+	uint32_t dram_clk_chanage;
+};
+
+struct dcn_hubbub_wm {
+	struct dcn_hubbub_wm_set sets[4];
+};
+
+static void dcn10_hubbub_wm_read_state(struct dce_hwseq *hws,
+		struct dcn_hubbub_wm *wm)
+{
+	struct dcn_hubbub_wm_set *s;
+
+	s = &wm->sets[0];
+	s->wm_set = 0;
+	s->data_urgent = REG_READ(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_A);
+	s->pte_meta_urgent = REG_READ(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_A);
+	s->sr_enter = REG_READ(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A);
+	s->sr_exit = REG_READ(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_A);
+	s->dram_clk_chanage = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_A);
+
+	s = &wm->sets[1];
+	s->wm_set = 1;
+	s->data_urgent = REG_READ(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_B);
+	s->pte_meta_urgent = REG_READ(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_B);
+	s->sr_enter = REG_READ(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B);
+	s->sr_exit = REG_READ(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_B);
+	s->dram_clk_chanage = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_B);
+
+	s = &wm->sets[2];
+	s->wm_set = 2;
+	s->data_urgent = REG_READ(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_C);
+	s->pte_meta_urgent = REG_READ(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_C);
+	s->sr_enter = REG_READ(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C);
+	s->sr_exit = REG_READ(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_C);
+	s->dram_clk_chanage = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_C);
+
+	s = &wm->sets[3];
+	s->wm_set = 3;
+	s->data_urgent = REG_READ(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_D);
+	s->pte_meta_urgent = REG_READ(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_D);
+	s->sr_enter = REG_READ(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D);
+	s->sr_exit = REG_READ(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_D);
+	s->dram_clk_chanage = REG_READ(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_D);
+}
+
+static void dcn10_log_hubbub_state(struct core_dc *dc)
+{
+	struct dc_context *dc_ctx = dc->ctx;
+	struct dcn_hubbub_wm wm;
+	int i;
+
+	dcn10_hubbub_wm_read_state(dc->hwseq, &wm);
+
+	DTN_INFO("HUBBUB WM: \t data_urgent \t pte_meta_urgent \t "
+			"sr_enter \t sr_exit \t dram_clk_change \n");
+
+	for (i = 0; i < 4; i++) {
+		struct dcn_hubbub_wm_set *s;
+
+		s = &wm.sets[i];
+		DTN_INFO("WM_Set[%d]:\t ", s->wm_set);
+		DTN_INFO_MICRO_SEC(s->data_urgent);
+		DTN_INFO_MICRO_SEC(s->pte_meta_urgent);
+		DTN_INFO_MICRO_SEC(s->sr_enter);
+		DTN_INFO_MICRO_SEC(s->sr_exit);
+		DTN_INFO_MICRO_SEC(s->dram_clk_chanage);
+		DTN_INFO("\n");
+	}
+
+	DTN_INFO("\n");
+}
+
 static void dcn10_log_hw_state(struct core_dc *dc)
 {
 	struct dc_context *dc_ctx = dc->ctx;
@@ -87,6 +165,8 @@ static void dcn10_log_hw_state(struct core_dc *dc)
 
 	DTN_INFO_BEGIN();
 
+	dcn10_log_hubbub_state(dc);
+
 	DTN_INFO("HUBP:\t format \t addr_hi \t width \t height \t "
 			"rotation \t mirror \t  sw_mode \t "
 			"dcc_en \t blank_en \t ttu_dis \t underflow \t "

commit 9d6f264b5653e1fe5e9646c7075cfc81445b25cd
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Aug 4 15:42:36 2017 -0400

    drm/amd/display: Workaround for underflow.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 2fd9c33dbf1c..b07ca5693cb6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1150,6 +1150,22 @@ static bool patch_address_for_sbs_tb_stereo(
 	return false;
 }
 
+static void toggle_watermark_change_req(struct dce_hwseq *hws)
+{
+	uint32_t watermark_change_req;
+
+	REG_GET(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,
+			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, &watermark_change_req);
+
+	if (watermark_change_req)
+		watermark_change_req = 0;
+	else
+		watermark_change_req = 1;
+
+	REG_UPDATE(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,
+			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, watermark_change_req);
+}
+
 static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ctx)
 {
 	bool addr_patched = false;
@@ -2089,6 +2105,7 @@ static void update_dchubp_dpp(
 	mi->funcs->set_blank(mi, !is_pipe_tree_visible(pipe_ctx));
 }
 
+
 static void program_all_pipe_in_tree(
 		struct core_dc *dc,
 		struct pipe_ctx *pipe_ctx,
@@ -2124,6 +2141,18 @@ static void program_all_pipe_in_tree(
 
 	if (pipe_ctx->plane_state != NULL) {
 		dcn10_power_on_fe(dc, pipe_ctx, context);
+
+		/* temporary dcn1 wa:
+                 *   watermark update requires toggle after a/b/c/d sets are programmed
+                 *   if hubp is pg then wm value doesn't get properaged to hubp
+                 *   need to toggle after ungate to ensure wm gets to hubp.
+                 *
+                 * final solution:  we need to get SMU to do the toggle as
+                 * DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST is owned by SMU we should have 
+                 * both driver and fw accessing same register
+                 */
+		toggle_watermark_change_req(dc->hwseq);
+
 		update_dchubp_dpp(dc, pipe_ctx, context);
 	}
 

commit 08b8ccfbcb511aa64efd8fa211f785597890af9e
Author: Corbin McElhanney <corbin.mcelhanney@amd.com>
Date:   Fri Aug 4 15:30:45 2017 -0400

    drm/amd/display: Fix hw state logging regression
    
    Signed-off-by: Corbin McElhanney <corbin.mcelhanney@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 292dfef91c9d..2fd9c33dbf1c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -134,6 +134,7 @@ static void verify_allow_pstate_change_high(
 	static unsigned int pstate_wait_timeout_us = 40;
 	static unsigned int max_sampled_pstate_wait_us; /* data collection */
 	static bool forced_pstate_allow; /* help with revert wa */
+	static bool should_log_hw_state; /* prevent hw state log by default */
 
 	unsigned int debug_index = 0x7;
 	unsigned int debug_data;
@@ -191,7 +192,9 @@ static void verify_allow_pstate_change_high(
 	REG_WRITE(DCHUBBUB_ARB_DRAM_STATE_CNTL, force_allow_pstate);
 	forced_pstate_allow = true;
 
-	dcn10_log_hw_state(DC_TO_CORE(hws->ctx->dc));
+	if (should_log_hw_state) {
+		dcn10_log_hw_state(DC_TO_CORE(hws->ctx->dc));
+	}
 
 	BREAK_TO_DEBUGGER();
 }

commit 8a5d82451e297fc3864bb9ab0247b53c7ab8a022
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Thu Aug 3 21:23:04 2017 -0400

    drm/amd/display: use some sensible time out
    
    40s time out is not sensible.
    
    also make all udelay poll happen more frequently since CPU is busy anyways
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 9165dc80cd22..292dfef91c9d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -264,28 +264,32 @@ static void dpp_pg_control(
 				DOMAIN1_POWER_GATE, power_gate);
 
 		REG_WAIT(DOMAIN1_PG_STATUS,
-				DOMAIN1_PGFSM_PWR_STATUS, pwr_status, 20000, 200000);
+				DOMAIN1_PGFSM_PWR_STATUS, pwr_status,
+				1, 1000);
 		break;
 	case 1: /* DPP1 */
 		REG_UPDATE(DOMAIN3_PG_CONFIG,
 				DOMAIN3_POWER_GATE, power_gate);
 
 		REG_WAIT(DOMAIN3_PG_STATUS,
-				DOMAIN3_PGFSM_PWR_STATUS, pwr_status, 20000, 200000);
+				DOMAIN3_PGFSM_PWR_STATUS, pwr_status,
+				1, 1000);
 		break;
 	case 2: /* DPP2 */
 		REG_UPDATE(DOMAIN5_PG_CONFIG,
 				DOMAIN5_POWER_GATE, power_gate);
 
 		REG_WAIT(DOMAIN5_PG_STATUS,
-				DOMAIN5_PGFSM_PWR_STATUS, pwr_status, 20000, 200000);
+				DOMAIN5_PGFSM_PWR_STATUS, pwr_status,
+				1, 1000);
 		break;
 	case 3: /* DPP3 */
 		REG_UPDATE(DOMAIN7_PG_CONFIG,
 				DOMAIN7_POWER_GATE, power_gate);
 
 		REG_WAIT(DOMAIN7_PG_STATUS,
-				DOMAIN7_PGFSM_PWR_STATUS, pwr_status, 20000, 200000);
+				DOMAIN7_PGFSM_PWR_STATUS, pwr_status,
+				1, 1000);
 		break;
 	default:
 		BREAK_TO_DEBUGGER();
@@ -612,28 +616,32 @@ static void hubp_pg_control(
 				DOMAIN0_POWER_GATE, power_gate);
 
 		REG_WAIT(DOMAIN0_PG_STATUS,
-				DOMAIN0_PGFSM_PWR_STATUS, pwr_status, 20000, 200000);
+				DOMAIN0_PGFSM_PWR_STATUS, pwr_status,
+				1, 1000);
 		break;
 	case 1: /* DCHUBP1 */
 		REG_UPDATE(DOMAIN2_PG_CONFIG,
 				DOMAIN2_POWER_GATE, power_gate);
 
 		REG_WAIT(DOMAIN2_PG_STATUS,
-				DOMAIN2_PGFSM_PWR_STATUS, pwr_status, 20000, 200000);
+				DOMAIN2_PGFSM_PWR_STATUS, pwr_status,
+				1, 1000);
 		break;
 	case 2: /* DCHUBP2 */
 		REG_UPDATE(DOMAIN4_PG_CONFIG,
 				DOMAIN4_POWER_GATE, power_gate);
 
 		REG_WAIT(DOMAIN4_PG_STATUS,
-				DOMAIN4_PGFSM_PWR_STATUS, pwr_status, 20000, 200000);
+				DOMAIN4_PGFSM_PWR_STATUS, pwr_status,
+				1, 1000);
 		break;
 	case 3: /* DCHUBP3 */
 		REG_UPDATE(DOMAIN6_PG_CONFIG,
 				DOMAIN6_POWER_GATE, power_gate);
 
 		REG_WAIT(DOMAIN6_PG_STATUS,
-				DOMAIN6_PGFSM_PWR_STATUS, pwr_status, 20000, 200000);
+				DOMAIN6_PGFSM_PWR_STATUS, pwr_status,
+				1, 1000);
 		break;
 	default:
 		BREAK_TO_DEBUGGER();
@@ -1011,7 +1019,8 @@ static void reset_front_end(
 
 	if (tg->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
 		REG_WAIT(OTG_GLOBAL_SYNC_STATUS[tg->inst],
-				VUPDATE_NO_LOCK_EVENT_OCCURRED, 1, 20000, 200000);
+				VUPDATE_NO_LOCK_EVENT_OCCURRED, 1,
+				1, 100000);
 
 	plane_atomic_disable(dc, fe_idx);
 

commit cbb4d72e290df8fedc764c7abb823cae938a45aa
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Aug 3 15:46:10 2017 -0400

    drm/amd/display: Clear water mark change request bit before programing.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 948aaeb73122..9165dc80cd22 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -320,6 +320,9 @@ static void program_watermarks(
 	 */
 	uint32_t prog_wm_value;
 
+	REG_UPDATE(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,
+			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, 0);
+
 	/* Repeat for water mark set A, B, C and D. */
 	/* clock state A */
 	prog_wm_value = convert_and_clamp(watermarks->a.urgent_ns,
@@ -518,8 +521,7 @@ static void program_watermarks(
 
 	REG_UPDATE(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,
 			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, 1);
-	REG_UPDATE(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,
-			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, 0);
+
 	REG_UPDATE(DCHUBBUB_ARB_SAT_LEVEL,
 			DCHUBBUB_ARB_SAT_LEVEL, 60 * refclk_mhz);
 	REG_UPDATE(DCHUBBUB_ARB_DF_REQ_OUTSTAND,

commit 3e9ad6164b98f82ff4b191980c502f09fee4deef
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Thu Aug 3 00:22:25 2017 -0400

    drm/amd/display: add programming for 0 plane case
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 114dd279fe47..948aaeb73122 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2151,7 +2151,8 @@ static void dcn10_pplib_apply_display_requirements(
 
 static void dcn10_apply_ctx_for_surface(
 		struct core_dc *dc,
-		const struct dc_plane_state *plane_state,
+		const struct dc_stream_state *stream,
+		int num_planes,
 		struct validate_context *context)
 {
 	int i, be_idx;
@@ -2159,12 +2160,26 @@ static void dcn10_apply_ctx_for_surface(
 	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
-	if (!plane_state)
-		return;
-
-	for (be_idx = 0; be_idx < dc->res_pool->pipe_count; be_idx++)
-		if (plane_state == context->res_ctx.pipe_ctx[be_idx].plane_state)
+	be_idx = -1;
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		if (stream == context->res_ctx.pipe_ctx[i].stream) {
+			be_idx = context->res_ctx.pipe_ctx[i].stream_res.tg->inst;
 			break;
+		}
+	}
+
+	ASSERT(be_idx != -1);
+
+	if (num_planes == 0) {
+		for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
+			struct pipe_ctx *old_pipe_ctx =
+							&dc->current_context->res_ctx.pipe_ctx[i];
+
+			if (old_pipe_ctx->stream_res.tg && old_pipe_ctx->stream_res.tg->inst == be_idx)
+				dcn10_power_down_fe(dc, old_pipe_ctx->pipe_idx);
+		}
+		return;
+	}
 
 	/* reset unused mpcc */
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
@@ -2229,7 +2244,7 @@ static void dcn10_apply_ctx_for_surface(
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		if (pipe_ctx->plane_state != plane_state)
+		if (pipe_ctx->stream != stream)
 			continue;
 
 		/* looking for top pipe to program */

commit 665da60f23d8c6bda5431529a73be49b3b9d97cb
Author: Corbin McElhanney <corbin.mcelhanney@amd.com>
Date:   Thu Aug 3 14:20:14 2017 -0400

    drm/amd/display: Add more pstate sanity checks
    
    Signed-off-by: Corbin McElhanney <corbin.mcelhanney@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index a4c0c338285d..114dd279fe47 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1767,6 +1767,10 @@ static void dcn10_power_on_fe(
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct dce_hwseq *hws = dc->hwseq;
 
+	if (dc->public.debug.sanity_checks) {
+		verify_allow_pstate_change_high(dc->hwseq);
+	}
+
 	power_on_plane(dc->hwseq,
 		pipe_ctx->pipe_idx);
 
@@ -1813,6 +1817,10 @@ static void dcn10_power_on_fe(
 				pipe_ctx->plane_res.scl_data.recout.y);
 		print_rq_dlg_ttu(dc, pipe_ctx);
 	}
+
+	if (dc->public.debug.sanity_checks) {
+		verify_allow_pstate_change_high(dc->hwseq);
+	}
 }
 
 static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
@@ -2287,6 +2295,10 @@ static void dcn10_set_bandwidth(
 {
 	struct dm_pp_clock_for_voltage_req clock;
 
+	if (dc->public.debug.sanity_checks) {
+		verify_allow_pstate_change_high(dc->hwseq);
+	}
+
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
 		return;
 
@@ -2338,6 +2350,10 @@ static void dcn10_set_bandwidth(
 	}
 	dcn10_pplib_apply_display_requirements(dc, context);
 
+	if (dc->public.debug.sanity_checks) {
+		verify_allow_pstate_change_high(dc->hwseq);
+	}
+
 	/* need to fix this function.  not doing the right thing here */
 }
 
@@ -2459,6 +2475,10 @@ static void dcn10_wait_for_mpcc_disconnect(
 {
 	int i;
 
+	if (dc->public.debug.sanity_checks) {
+		verify_allow_pstate_change_high(dc->hwseq);
+	}
+
 	if (!pipe_ctx->stream_res.opp)
 		return;
 
@@ -2473,6 +2493,10 @@ static void dcn10_wait_for_mpcc_disconnect(
 		}
 	}
 
+	if (dc->public.debug.sanity_checks) {
+		verify_allow_pstate_change_high(dc->hwseq);
+	}
+
 }
 
 static bool dcn10_dummy_display_power_gating(

commit eb4e33b7c98a4d69d84d783fd0a7918e5ad011da
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Thu Aug 3 09:22:14 2017 -0400

    drm/amd/display: log underflow
    
    as well as convert output in ref_cycle to nano sec
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Logatharshan Thothiralingam <Logatharshan.Thothiralingam@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 30ddf920b270..a4c0c338285d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -65,6 +65,20 @@ static void log_mpc_crc(struct core_dc *dc)
 		REG_READ(DPP_TOP0_DPP_CRC_VAL_B_A), REG_READ(DPP_TOP0_DPP_CRC_VAL_R_G));
 }
 
+void print_microsec(struct dc_context *dc_ctx, uint32_t ref_cycle)
+{
+	static const uint32_t ref_clk_mhz = 48;
+	static const unsigned int frac = 10;
+	uint32_t us_x10 = (ref_cycle * frac) / ref_clk_mhz;
+
+	DTN_INFO("%d.%d \t ",
+			us_x10 / frac,
+			us_x10 % frac);
+}
+
+#define DTN_INFO_MICRO_SEC(ref_cycle) \
+	print_microsec(dc_ctx, ref_cycle)
+
 static void dcn10_log_hw_state(struct core_dc *dc)
 {
 	struct dc_context *dc_ctx = dc->ctx;
@@ -73,8 +87,9 @@ static void dcn10_log_hw_state(struct core_dc *dc)
 
 	DTN_INFO_BEGIN();
 
-	DTN_INFO("HUBP:\t format \t addr_hi \t width \t height \t rotation \t"
-			"mirror \t  sw_mode \t dcc_en \t blank_en \t ttu_dis \t"
+	DTN_INFO("HUBP:\t format \t addr_hi \t width \t height \t "
+			"rotation \t mirror \t  sw_mode \t "
+			"dcc_en \t blank_en \t ttu_dis \t underflow \t "
 			"min_ttu_vblank \t qos_low_wm \t qos_high_wm \n");
 
 	for (i = 0; i < pool->pipe_count; i++) {
@@ -83,9 +98,9 @@ static void dcn10_log_hw_state(struct core_dc *dc)
 
 		dcn10_mem_input_read_state(TO_DCN10_MEM_INPUT(mi), &s);
 
-		DTN_INFO("[%d]:\t %xh \t %xh \t %d \t %d \t %xh \t %xh \t "
-				"%d \t %d \t %d \t %d \t"
-				"%d \t %d \t %d \n",
+		DTN_INFO("[%d]:\t %xh \t %xh \t %d \t %d \t "
+				"%xh \t %xh \t %xh \t "
+				"%d \t %d \t %d \t %xh \t",
 				i,
 				s.pixel_format,
 				s.inuse_addr_hi,
@@ -97,9 +112,11 @@ static void dcn10_log_hw_state(struct core_dc *dc)
 				s.dcc_en,
 				s.blank_en,
 				s.ttu_disable,
-				s.min_ttu_vblank,
-				s.qos_level_low_wm,
-				s.qos_level_high_wm);
+				s.underflow_status);
+		DTN_INFO_MICRO_SEC(s.min_ttu_vblank);
+		DTN_INFO_MICRO_SEC(s.qos_level_low_wm);
+		DTN_INFO_MICRO_SEC(s.qos_level_high_wm);
+		DTN_INFO("\n");
 	}
 	DTN_INFO("\n");
 

commit 713950115bc5f964e65f79a7684468c41ed41654
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Thu Aug 3 08:59:12 2017 -0400

    drm/amd/display: log HW state when we about to encounter DF DPM hang
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e69839802889..30ddf920b270 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -52,6 +52,61 @@
 #define FN(reg_name, field_name) \
 	hws->shifts->field_name, hws->masks->field_name
 
+static void log_mpc_crc(struct core_dc *dc)
+{
+	struct dc_context *dc_ctx = dc->ctx;
+	struct dce_hwseq *hws = dc->hwseq;
+
+	if (REG(MPC_CRC_RESULT_GB))
+		DTN_INFO("MPC_CRC_RESULT_GB:%d MPC_CRC_RESULT_C:%d MPC_CRC_RESULT_AR:%d\n",
+		REG_READ(MPC_CRC_RESULT_GB), REG_READ(MPC_CRC_RESULT_C), REG_READ(MPC_CRC_RESULT_AR));
+	if (REG(DPP_TOP0_DPP_CRC_VAL_B_A))
+		DTN_INFO("DPP_TOP0_DPP_CRC_VAL_B_A:%d DPP_TOP0_DPP_CRC_VAL_R_G:%d\n",
+		REG_READ(DPP_TOP0_DPP_CRC_VAL_B_A), REG_READ(DPP_TOP0_DPP_CRC_VAL_R_G));
+}
+
+static void dcn10_log_hw_state(struct core_dc *dc)
+{
+	struct dc_context *dc_ctx = dc->ctx;
+	struct resource_pool *pool = dc->res_pool;
+	int i;
+
+	DTN_INFO_BEGIN();
+
+	DTN_INFO("HUBP:\t format \t addr_hi \t width \t height \t rotation \t"
+			"mirror \t  sw_mode \t dcc_en \t blank_en \t ttu_dis \t"
+			"min_ttu_vblank \t qos_low_wm \t qos_high_wm \n");
+
+	for (i = 0; i < pool->pipe_count; i++) {
+		struct mem_input *mi = pool->mis[i];
+		struct dcn_hubp_state s;
+
+		dcn10_mem_input_read_state(TO_DCN10_MEM_INPUT(mi), &s);
+
+		DTN_INFO("[%d]:\t %xh \t %xh \t %d \t %d \t %xh \t %xh \t "
+				"%d \t %d \t %d \t %d \t"
+				"%d \t %d \t %d \n",
+				i,
+				s.pixel_format,
+				s.inuse_addr_hi,
+				s.viewport_width,
+				s.viewport_height,
+				s.rotation_angle,
+				s.h_mirror_en,
+				s.sw_mode,
+				s.dcc_en,
+				s.blank_en,
+				s.ttu_disable,
+				s.min_ttu_vblank,
+				s.qos_level_low_wm,
+				s.qos_level_high_wm);
+	}
+	DTN_INFO("\n");
+
+	log_mpc_crc(dc);
+
+	DTN_INFO_END();
+}
 
 static void verify_allow_pstate_change_high(
 	struct dce_hwseq *hws)
@@ -118,6 +173,9 @@ static void verify_allow_pstate_change_high(
 	 */
 	REG_WRITE(DCHUBBUB_ARB_DRAM_STATE_CNTL, force_allow_pstate);
 	forced_pstate_allow = true;
+
+	dcn10_log_hw_state(DC_TO_CORE(hws->ctx->dc));
+
 	BREAK_TO_DEBUGGER();
 }
 
@@ -2377,63 +2435,6 @@ static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct core_dc *dc)
 	return;
 }
 
-
-static void log_mpc_crc(struct core_dc *dc)
-{
-	struct dc_context *dc_ctx = dc->ctx;
-	struct dce_hwseq *hws = dc->hwseq;
-
-	if (REG(MPC_CRC_RESULT_GB))
-		DTN_INFO("MPC_CRC_RESULT_GB:%d MPC_CRC_RESULT_C:%d MPC_CRC_RESULT_AR:%d\n",
-		REG_READ(MPC_CRC_RESULT_GB), REG_READ(MPC_CRC_RESULT_C), REG_READ(MPC_CRC_RESULT_AR));
-	if (REG(DPP_TOP0_DPP_CRC_VAL_B_A))
-		DTN_INFO("DPP_TOP0_DPP_CRC_VAL_B_A:%d DPP_TOP0_DPP_CRC_VAL_R_G:%d\n",
-		REG_READ(DPP_TOP0_DPP_CRC_VAL_B_A), REG_READ(DPP_TOP0_DPP_CRC_VAL_R_G));
-}
-
-static void dcn10_log_hw_state(struct core_dc *dc)
-{
-	struct dc_context *dc_ctx = dc->ctx;
-	struct resource_pool *pool = dc->res_pool;
-	int i;
-
-	DTN_INFO_BEGIN();
-
-	DTN_INFO("HUBP:\t format \t addr_hi \t width \t height \t rotation \t"
-			"mirror \t  sw_mode \t dcc_en \t blank_en \t ttu_dis \t"
-			"min_ttu_vblank \t qos_low_wm \t qos_high_wm \n");
-
-	for (i = 0; i < pool->pipe_count; i++) {
-		struct mem_input *mi = pool->mis[i];
-		struct dcn_hubp_state s;
-
-		dcn10_mem_input_read_state(TO_DCN10_MEM_INPUT(mi), &s);
-
-		DTN_INFO("[%d]:\t %xh \t %xh \t %d \t %d \t %xh \t %xh \t "
-				"%d \t %d \t %d \t %d \t"
-				"%d \t %d \t %d \n",
-				i,
-				s.pixel_format,
-				s.inuse_addr_hi,
-				s.viewport_width,
-				s.viewport_height,
-				s.rotation_angle,
-				s.h_mirror_en,
-				s.sw_mode,
-				s.dcc_en,
-				s.blank_en,
-				s.ttu_disable,
-				s.min_ttu_vblank,
-				s.qos_level_low_wm,
-				s.qos_level_high_wm);
-	}
-	DTN_INFO("\n");
-
-	log_mpc_crc(dc);
-
-	DTN_INFO_END();
-}
-
 static void dcn10_wait_for_mpcc_disconnect(
 		struct core_dc *dc,
 		struct resource_pool *res_pool,

commit 10688217e3af3ec73892139bed3d23a6e1170a14
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 15:17:43 2017 -0400

    drm/amd/display: Move pix_clk_params into stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipes->pix_clk_params/pipes->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipe_with_clk_src->pix_clk_params/pipe_with_clk_src->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/ctx->pix_clk_params->/ctx->stream_res\.pix_clk_params->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->pix_clk_params/pipe->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipe_ctx->pix_clk_params/pipe_ctx->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[pipe_offset\]\.pix_clk_params/pipe_ctx\[pipe_offset\]\.stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[i\]->pix_clk_params/grouped_pipes\[i\]->stream_^Cs\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[0\]->pix_clk_params/grouped_pipes\[0\]->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[1\]->pix_clk_params/grouped_pipes\[1\]->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]->pix_clk_params/pipe_ctx\[i\]->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx_old->pix_clk_params/pipe_ctx_old->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_set\[j\]->pix_clk_params/pipe_set\[j\]->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]\.pix_clk_params/pipe_ctx\[i\]\.stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipes\[i\]\.pix_clk_params/pipes\[i\]\.stream_res\.pix_clk_params/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 16ac96358620..e69839802889 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -703,7 +703,7 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 
 	if (false == pipe_ctx->clock_source->funcs->program_pix_clk(
 			pipe_ctx->clock_source,
-			&pipe_ctx->pix_clk_params,
+			&pipe_ctx->stream_res.pix_clk_params,
 			&pipe_ctx->pll_settings)) {
 		BREAK_TO_DEBUGGER();
 		return DC_ERROR_UNEXPECTED;
@@ -1910,7 +1910,7 @@ static void update_dchubp_dpp(
 	enable_dppclk(
 		dc->hwseq,
 		pipe_ctx->pipe_idx,
-		pipe_ctx->pix_clk_params.requested_pix_clk,
+		pipe_ctx->stream_res.pix_clk_params.requested_pix_clk,
 		context->bw.dcn.calc_clk.dppclk_div);
 	dc->current_context->bw.dcn.cur_clk.dppclk_div =
 			context->bw.dcn.calc_clk.dppclk_div;

commit 8e9c4c8cf35ff23aafc69f9ef4c9cc471dac4094
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 14:36:12 2017 -0400

    drm/amd/display: Move stream_enc to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipes->stream_enc/pipes->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/ctx->stream_enc->/ctx->stream_res\.stream_enc->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->stream_enc/pipe->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx->stream_enc/pipe_ctx->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[pipe_offset\]\.stream_enc/pipe_ctx\[pipe_offset\]\.stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[i\]->stream_enc/grouped_pipes\[i\]->stream_^Cs\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[0\]->stream_enc/grouped_pipes\[0\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[1\]->stream_enc/grouped_pipes\[1\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]->stream_enc/pipe_ctx\[i\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx_old->stream_enc/pipe_ctx_old->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_set\[j\]->stream_enc/pipe_set\[j\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]\.stream_enc/pipe_ctx\[i\]\.stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipes\[i\]\.stream_enc/pipes\[i\]\.stream_res\.stream_enc/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 99ef0f25492c..16ac96358620 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -770,7 +770,7 @@ static void reset_back_end_for_pipe(
 {
 	int i;
 
-	if (pipe_ctx->stream_enc == NULL) {
+	if (pipe_ctx->stream_res.stream_enc == NULL) {
 		pipe_ctx->stream = NULL;
 		return;
 	}

commit 6b670fa965b620bf0131a0a339a388a0581bc466
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 13:59:26 2017 -0400

    drm/amd/display: Move TG to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipes->tg/pipes->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/ctx->tg->/ctx->stream_res\.tg->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->tg/pipe->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx->tg/pipe_ctx->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[pipe_offset\]\.tg/pipe_ctx\[pipe_offset\]\.stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/grouped_pipes\[i\]->tg/grouped_pipes\[i\]->stream_^Cs\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/grouped_pipes\[0\]->tg/grouped_pipes\[0\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/grouped_pipes\[1\]->tg/grouped_pipes\[1\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx\[i\]->tg/pipe_ctx\[i\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx_old->tg/pipe_ctx_old->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_set\[j\]->tg/pipe_set\[j\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx\[i\]\.tg/pipe_ctx\[i\]\.stream_res\.tg/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 2db6b46baa6c..99ef0f25492c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -699,7 +699,7 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 	/* HW program guide assume display already disable
 	 * by unplug sequence. OTG assume stop.
 	 */
-	pipe_ctx->tg->funcs->enable_optc_clock(pipe_ctx->tg, true);
+	pipe_ctx->stream_res.tg->funcs->enable_optc_clock(pipe_ctx->stream_res.tg, true);
 
 	if (false == pipe_ctx->clock_source->funcs->program_pix_clk(
 			pipe_ctx->clock_source,
@@ -708,15 +708,15 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 		BREAK_TO_DEBUGGER();
 		return DC_ERROR_UNEXPECTED;
 	}
-	pipe_ctx->tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
-	pipe_ctx->tg->dlg_otg_param.vstartup_start = pipe_ctx->pipe_dlg_param.vstartup_start;
-	pipe_ctx->tg->dlg_otg_param.vupdate_offset = pipe_ctx->pipe_dlg_param.vupdate_offset;
-	pipe_ctx->tg->dlg_otg_param.vupdate_width = pipe_ctx->pipe_dlg_param.vupdate_width;
+	pipe_ctx->stream_res.tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
+	pipe_ctx->stream_res.tg->dlg_otg_param.vstartup_start = pipe_ctx->pipe_dlg_param.vstartup_start;
+	pipe_ctx->stream_res.tg->dlg_otg_param.vupdate_offset = pipe_ctx->pipe_dlg_param.vupdate_offset;
+	pipe_ctx->stream_res.tg->dlg_otg_param.vupdate_width = pipe_ctx->pipe_dlg_param.vupdate_width;
 
-	pipe_ctx->tg->dlg_otg_param.signal =  pipe_ctx->stream->signal;
+	pipe_ctx->stream_res.tg->dlg_otg_param.signal =  pipe_ctx->stream->signal;
 
-	pipe_ctx->tg->funcs->program_timing(
-			pipe_ctx->tg,
+	pipe_ctx->stream_res.tg->funcs->program_timing(
+			pipe_ctx->stream_res.tg,
 			&stream->timing,
 			true);
 
@@ -729,7 +729,7 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 	/* TODO: OPP FMT, ABM. etc. should be done here. */
 	/* or FPGA now. instance 0 only. TODO: move to opp.c */
 
-	inst_offset = reg_offsets[pipe_ctx->tg->inst].fmt;
+	inst_offset = reg_offsets[pipe_ctx->stream_res.tg->inst].fmt;
 
 	pipe_ctx->stream_res.opp->funcs->opp_program_fmt(
 				pipe_ctx->stream_res.opp,
@@ -739,15 +739,15 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 	/* program otg blank color */
 	color_space = stream->output_color_space;
 	color_space_to_black_color(dc, color_space, &black_color);
-	pipe_ctx->tg->funcs->set_blank_color(
-			pipe_ctx->tg,
+	pipe_ctx->stream_res.tg->funcs->set_blank_color(
+			pipe_ctx->stream_res.tg,
 			&black_color);
 
-	pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, true);
-	hwss_wait_for_blank_complete(pipe_ctx->tg);
+	pipe_ctx->stream_res.tg->funcs->set_blank(pipe_ctx->stream_res.tg, true);
+	hwss_wait_for_blank_complete(pipe_ctx->stream_res.tg);
 
 	/* VTG is  within DCHUB command block. DCFCLK is always on */
-	if (false == pipe_ctx->tg->funcs->enable_crtc(pipe_ctx->tg)) {
+	if (false == pipe_ctx->stream_res.tg->funcs->enable_crtc(pipe_ctx->stream_res.tg)) {
 		BREAK_TO_DEBUGGER();
 		return DC_ERROR_UNEXPECTED;
 	}
@@ -787,9 +787,9 @@ static void reset_back_end_for_pipe(
 	 * parent pipe.
 	 */
 	if (pipe_ctx->top_pipe == NULL) {
-		pipe_ctx->tg->funcs->disable_crtc(pipe_ctx->tg);
+		pipe_ctx->stream_res.tg->funcs->disable_crtc(pipe_ctx->stream_res.tg);
 
-		pipe_ctx->tg->funcs->enable_optc_clock(pipe_ctx->tg, false);
+		pipe_ctx->stream_res.tg->funcs->enable_optc_clock(pipe_ctx->stream_res.tg, false);
 	}
 
 	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
@@ -807,7 +807,7 @@ static void reset_back_end_for_pipe(
 	pipe_ctx->stream = NULL;
 	dm_logger_write(dc->ctx->logger, LOG_DC,
 					"Reset back end for pipe %d, tg:%d\n",
-					pipe_ctx->pipe_idx, pipe_ctx->tg->inst);
+					pipe_ctx->pipe_idx, pipe_ctx->stream_res.tg->inst);
 }
 
 /* trigger HW to start disconnect plane from stream on the next vsync */
@@ -974,7 +974,7 @@ static void reset_hw_ctx_wrap(
 	/* Lock*/
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *cur_pipe_ctx = &dc->current_context->res_ctx.pipe_ctx[i];
-		struct timing_generator *tg = cur_pipe_ctx->tg;
+		struct timing_generator *tg = cur_pipe_ctx->stream_res.tg;
 
 		if (cur_pipe_ctx->stream)
 			tg->funcs->lock(tg);
@@ -995,7 +995,7 @@ static void reset_hw_ctx_wrap(
 	/* Unlock*/
 	for (i = dc->res_pool->pipe_count - 1; i >= 0; i--) {
 		struct pipe_ctx *cur_pipe_ctx = &dc->current_context->res_ctx.pipe_ctx[i];
-		struct timing_generator *tg = cur_pipe_ctx->tg;
+		struct timing_generator *tg = cur_pipe_ctx->stream_res.tg;
 
 		if (cur_pipe_ctx->stream)
 			tg->funcs->unlock(tg);
@@ -1488,9 +1488,9 @@ static void dcn10_pipe_control_lock(
 		verify_allow_pstate_change_high(dc->hwseq);
 
 	if (lock)
-		pipe->tg->funcs->lock(pipe->tg);
+		pipe->stream_res.tg->funcs->lock(pipe->stream_res.tg);
 	else
-		pipe->tg->funcs->unlock(pipe->tg);
+		pipe->stream_res.tg->funcs->unlock(pipe->stream_res.tg);
 
 	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
@@ -1545,8 +1545,8 @@ static void dcn10_enable_timing_synchronization(
 	DC_SYNC_INFO("Setting up OTG reset trigger\n");
 
 	for (i = 1; i < group_size; i++)
-		grouped_pipes[i]->tg->funcs->enable_reset_trigger(
-				grouped_pipes[i]->tg, grouped_pipes[0]->tg->inst);
+		grouped_pipes[i]->stream_res.tg->funcs->enable_reset_trigger(
+				grouped_pipes[i]->stream_res.tg, grouped_pipes[0]->stream_res.tg->inst);
 
 
 	DC_SYNC_INFO("Waiting for trigger\n");
@@ -1554,10 +1554,10 @@ static void dcn10_enable_timing_synchronization(
 	/* Need to get only check 1 pipe for having reset as all the others are
 	 * synchronized. Look at last pipe programmed to reset.
 	 */
-	wait_for_reset_trigger_to_occur(dc_ctx, grouped_pipes[1]->tg);
+	wait_for_reset_trigger_to_occur(dc_ctx, grouped_pipes[1]->stream_res.tg);
 	for (i = 1; i < group_size; i++)
-		grouped_pipes[i]->tg->funcs->disable_reset_trigger(
-				grouped_pipes[i]->tg);
+		grouped_pipes[i]->stream_res.tg->funcs->disable_reset_trigger(
+				grouped_pipes[i]->stream_res.tg);
 
 	DC_SYNC_INFO("Sync complete\n");
 }
@@ -1700,7 +1700,7 @@ static void dcn10_power_on_fe(
 			HUBP_CLOCK_ENABLE, 1);
 
 	/* make sure OPP_PIPE_CLOCK_EN = 1 */
-	REG_UPDATE(OPP_PIPE_CONTROL[pipe_ctx->tg->inst],
+	REG_UPDATE(OPP_PIPE_CONTROL[pipe_ctx->stream_res.tg->inst],
 			OPP_PIPE_CLOCK_EN, 1);
 	/*TODO: REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DPPCLK_WDIVIDER, 0x1f);*/
 
@@ -1920,7 +1920,7 @@ static void update_dchubp_dpp(
 	 * VTG is within DCHUBBUB which is commond block share by each pipe HUBP.
 	 * VTG is 1:1 mapping with OTG. Each pipe HUBP will select which VTG
 	 */
-	REG_UPDATE(DCHUBP_CNTL[pipe_ctx->pipe_idx], HUBP_VTG_SEL, pipe_ctx->tg->inst);
+	REG_UPDATE(DCHUBP_CNTL[pipe_ctx->pipe_idx], HUBP_VTG_SEL, pipe_ctx->stream_res.tg->inst);
 
 	update_plane_addr(dc, pipe_ctx);
 
@@ -2012,17 +2012,17 @@ static void program_all_pipe_in_tree(
 			verify_allow_pstate_change_high(dc->hwseq);
 		}
 
-		pipe_ctx->tg->funcs->lock(pipe_ctx->tg);
+		pipe_ctx->stream_res.tg->funcs->lock(pipe_ctx->stream_res.tg);
 
-		pipe_ctx->tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
-		pipe_ctx->tg->dlg_otg_param.vstartup_start = pipe_ctx->pipe_dlg_param.vstartup_start;
-		pipe_ctx->tg->dlg_otg_param.vupdate_offset = pipe_ctx->pipe_dlg_param.vupdate_offset;
-		pipe_ctx->tg->dlg_otg_param.vupdate_width = pipe_ctx->pipe_dlg_param.vupdate_width;
-		pipe_ctx->tg->dlg_otg_param.signal =  pipe_ctx->stream->signal;
+		pipe_ctx->stream_res.tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
+		pipe_ctx->stream_res.tg->dlg_otg_param.vstartup_start = pipe_ctx->pipe_dlg_param.vstartup_start;
+		pipe_ctx->stream_res.tg->dlg_otg_param.vupdate_offset = pipe_ctx->pipe_dlg_param.vupdate_offset;
+		pipe_ctx->stream_res.tg->dlg_otg_param.vupdate_width = pipe_ctx->pipe_dlg_param.vupdate_width;
+		pipe_ctx->stream_res.tg->dlg_otg_param.signal =  pipe_ctx->stream->signal;
 
-		pipe_ctx->tg->funcs->program_global_sync(
-				pipe_ctx->tg);
-		pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, !is_pipe_tree_visible(pipe_ctx));
+		pipe_ctx->stream_res.tg->funcs->program_global_sync(
+				pipe_ctx->stream_res.tg);
+		pipe_ctx->stream_res.tg->funcs->set_blank(pipe_ctx->stream_res.tg, !is_pipe_tree_visible(pipe_ctx));
 	}
 
 	if (pipe_ctx->plane_state != NULL) {
@@ -2098,20 +2098,20 @@ static void dcn10_apply_ctx_for_surface(
 		 */
 
 		if (pipe_ctx->plane_state && !old_pipe_ctx->plane_state) {
-			if (pipe_ctx->plane_res.mi->opp_id != 0xf && pipe_ctx->tg->inst == be_idx) {
+			if (pipe_ctx->plane_res.mi->opp_id != 0xf && pipe_ctx->stream_res.tg->inst == be_idx) {
 				dcn10_power_down_fe(dc, pipe_ctx->pipe_idx);
 				/*
 				 * power down fe will unlock when calling reset, need
 				 * to lock it back here. Messy, need rework.
 				 */
-				pipe_ctx->tg->funcs->lock(pipe_ctx->tg);
+				pipe_ctx->stream_res.tg->funcs->lock(pipe_ctx->stream_res.tg);
 			}
 		}
 
 
 		if ((!pipe_ctx->plane_state && old_pipe_ctx->plane_state)
 				|| (!pipe_ctx->stream && old_pipe_ctx->stream)) {
-			if (old_pipe_ctx->tg->inst != be_idx)
+			if (old_pipe_ctx->stream_res.tg->inst != be_idx)
 				continue;
 
 			if (!old_pipe_ctx->top_pipe) {
@@ -2279,7 +2279,7 @@ static void set_drr(struct pipe_ctx **pipe_ctx,
 	 * some GSL stuff
 	 */
 	for (i = 0; i < num_pipes; i++) {
-		pipe_ctx[i]->tg->funcs->set_drr(pipe_ctx[i]->tg, &params);
+		pipe_ctx[i]->stream_res.tg->funcs->set_drr(pipe_ctx[i]->stream_res.tg, &params);
 	}
 }
 
@@ -2292,7 +2292,7 @@ static void get_position(struct pipe_ctx **pipe_ctx,
 	/* TODO: handle pipes > 1
 	 */
 	for (i = 0; i < num_pipes; i++)
-		pipe_ctx[i]->tg->funcs->get_position(pipe_ctx[i]->tg, position);
+		pipe_ctx[i]->stream_res.tg->funcs->get_position(pipe_ctx[i]->stream_res.tg, position);
 }
 
 static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
@@ -2307,8 +2307,8 @@ static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
 		value |= 0x2;
 
 	for (i = 0; i < num_pipes; i++)
-		pipe_ctx[i]->tg->funcs->
-			set_static_screen_control(pipe_ctx[i]->tg, value);
+		pipe_ctx[i]->stream_res.tg->funcs->
+			set_static_screen_control(pipe_ctx[i]->stream_res.tg, value);
 }
 
 static void set_plane_config(
@@ -2369,8 +2369,8 @@ static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct core_dc *dc)
 		flags.PROGRAM_STEREO == 1 ? true:false,
 		stream->timing.flags.RIGHT_EYE_3D_POLARITY == 1 ? true:false);
 
-	pipe_ctx->tg->funcs->program_stereo(
-		pipe_ctx->tg,
+	pipe_ctx->stream_res.tg->funcs->program_stereo(
+		pipe_ctx->stream_res.tg,
 		&stream->timing,
 		&flags);
 
@@ -2469,7 +2469,7 @@ static bool dcn10_dummy_display_power_gating(
 void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 {
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
-	struct timing_generator *tg = pipe_ctx->tg;
+	struct timing_generator *tg = pipe_ctx->stream_res.tg;
 
 	if (plane_state->ctx->dc->debug.sanity_checks) {
 		struct core_dc *dc = DC_TO_CORE(plane_state->ctx->dc);
@@ -2496,7 +2496,7 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 	if (pipe_ctx->plane_res.mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 			tg->funcs->is_stereo_left_eye) {
 		plane_state->status.is_right_eye =
-				!tg->funcs->is_stereo_left_eye(pipe_ctx->tg);
+				!tg->funcs->is_stereo_left_eye(pipe_ctx->stream_res.tg);
 	}
 }
 

commit a6a6cb349e39ef23a341a17752eebf69a5c0d7ff
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 13:55:28 2017 -0400

    drm/amd/display: Move OPP to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipes->opp/pipes->stream_res\.opp/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/ctx->opp->/ctx->stream_res\.opp->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->opp/pipe->stream_res\.opp/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx->opp/pipe_ctx->stream_res\.opp/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 1cf672d4a1ee..2db6b46baa6c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -720,8 +720,8 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 			&stream->timing,
 			true);
 
-	pipe_ctx->opp->funcs->opp_set_stereo_polarity(
-				pipe_ctx->opp,
+	pipe_ctx->stream_res.opp->funcs->opp_set_stereo_polarity(
+				pipe_ctx->stream_res.opp,
 				enableStereo,
 				rightEyePolarity);
 
@@ -731,8 +731,8 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 
 	inst_offset = reg_offsets[pipe_ctx->tg->inst].fmt;
 
-	pipe_ctx->opp->funcs->opp_program_fmt(
-				pipe_ctx->opp,
+	pipe_ctx->stream_res.opp->funcs->opp_program_fmt(
+				pipe_ctx->stream_res.opp,
 				&stream->bit_depth_params,
 				&stream->clamping);
 #endif
@@ -1946,7 +1946,7 @@ static void update_dchubp_dpp(
 			IPP_OUTPUT_FORMAT_12_BIT_FIX);
 
 	mpcc_cfg.mi = mi;
-	mpcc_cfg.opp = pipe_ctx->opp;
+	mpcc_cfg.opp = pipe_ctx->stream_res.opp;
 	for (top_pipe = pipe_ctx->top_pipe; top_pipe; top_pipe = top_pipe->top_pipe)
 		mpcc_cfg.z_index++;
 	if (dc->public.debug.surface_visual_confirm)
@@ -2122,9 +2122,9 @@ static void dcn10_apply_ctx_for_surface(
 			/* reset mpc */
 			dc->res_pool->mpc->funcs->remove(
 					dc->res_pool->mpc,
-					old_pipe_ctx->opp,
+					old_pipe_ctx->stream_res.opp,
 					old_pipe_ctx->pipe_idx);
-			old_pipe_ctx->opp->mpcc_disconnect_pending[old_pipe_ctx->plane_res.mi->mpcc_id] = true;
+			old_pipe_ctx->stream_res.opp->mpcc_disconnect_pending[old_pipe_ctx->plane_res.mi->mpcc_id] = true;
 
 			/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
 					"[debug_mpo: apply_ctx disconnect pending on mpcc %d]\n",
@@ -2364,8 +2364,8 @@ static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct core_dc *dc)
 
 	dcn10_config_stereo_parameters(stream, &flags);
 
-	pipe_ctx->opp->funcs->opp_set_stereo_polarity(
-		pipe_ctx->opp,
+	pipe_ctx->stream_res.opp->funcs->opp_set_stereo_polarity(
+		pipe_ctx->stream_res.opp,
 		flags.PROGRAM_STEREO == 1 ? true:false,
 		stream->timing.flags.RIGHT_EYE_3D_POLARITY == 1 ? true:false);
 
@@ -2441,13 +2441,13 @@ static void dcn10_wait_for_mpcc_disconnect(
 {
 	int i;
 
-	if (!pipe_ctx->opp)
+	if (!pipe_ctx->stream_res.opp)
 		return;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (pipe_ctx->opp->mpcc_disconnect_pending[i]) {
+		if (pipe_ctx->stream_res.opp->mpcc_disconnect_pending[i]) {
 			res_pool->mpc->funcs->wait_for_idle(res_pool->mpc, i);
-			pipe_ctx->opp->mpcc_disconnect_pending[i] = false;
+			pipe_ctx->stream_res.opp->mpcc_disconnect_pending[i] = false;
 			res_pool->mis[i]->funcs->set_blank(res_pool->mis[i], true);
 			/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
 					"[debug_mpo: wait_for_mpcc finished waiting on mpcc %d]\n",

commit 86a66c4eb7365c96230bca218634439f7b057306
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 11:55:55 2017 -0400

    drm/amd/display: Move mi, ipp, xfm to plane_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.mi/\.plane_res.mi/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->mi/->plane_res.mi/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.ipp/\.plane_res.ipp/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->ipp/->plane_res.ipp/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.xfm/\.plane_res.xfm/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->xfm/->plane_res.xfm/g'
    
    To clean up bad renames:
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.min/\.min/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.min/->min/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mic/->mic/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.mis/\.mis/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mid/->mid/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.mid/\.mid/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mis/->mis/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.min/\.min/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.min/->min/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mic/->mic/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.mis/\.mis/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mid/->mid/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.mid/\.mid/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mis/->mis/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.ipps/\.ipps/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/mpcc_cfg\.plane_res\.mi/mpcc_cfg\.mi/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/mi->plane_res\./mi->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/cfg->plane_res\./cfg->/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 314d7645a898..1cf672d4a1ee 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1070,8 +1070,8 @@ static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ct
 	if (plane_state == NULL)
 		return;
 	addr_patched = patch_address_for_sbs_tb_stereo(pipe_ctx, &addr);
-	pipe_ctx->mi->funcs->mem_input_program_surface_flip_and_addr(
-			pipe_ctx->mi,
+	pipe_ctx->plane_res.mi->funcs->mem_input_program_surface_flip_and_addr(
+			pipe_ctx->plane_res.mi,
 			&plane_state->address,
 			plane_state->flip_immediate);
 	plane_state->status.requested_address = plane_state->address;
@@ -1082,7 +1082,7 @@ static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ct
 static bool dcn10_set_input_transfer_func(
 	struct pipe_ctx *pipe_ctx, const struct dc_plane_state *plane_state)
 {
-	struct input_pixel_processor *ipp = pipe_ctx->ipp;
+	struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
 	const struct dc_transfer_func *tf = NULL;
 	bool result = true;
 
@@ -1447,7 +1447,7 @@ static bool dcn10_set_output_transfer_func(
 	struct pipe_ctx *pipe_ctx,
 	const struct dc_stream_state *stream)
 {
-	struct transform *xfm = pipe_ctx->xfm;
+	struct transform *xfm = pipe_ctx->plane_res.xfm;
 
 	if (xfm == NULL)
 		return false;
@@ -1778,7 +1778,7 @@ static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 				gamut_remap_matrix.matrix[10];
 	}
 
-	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
+	pipe_ctx->plane_res.xfm->funcs->transform_set_gamut_remap(pipe_ctx->plane_res.xfm, &adjust);
 }
 
 
@@ -1800,7 +1800,7 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 
 			tbl_entry.color_space = color_space;
 			//tbl_entry.regval = matrix;
-			pipe_ctx->xfm->funcs->opp_set_csc_adjustment(pipe_ctx->xfm, &tbl_entry);
+			pipe_ctx->plane_res.xfm->funcs->opp_set_csc_adjustment(pipe_ctx->plane_res.xfm, &tbl_entry);
 	}
 }
 static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
@@ -1896,8 +1896,8 @@ static void update_dchubp_dpp(
 	struct validate_context *context)
 {
 	struct dce_hwseq *hws = dc->hwseq;
-	struct mem_input *mi = pipe_ctx->mi;
-	struct input_pixel_processor *ipp = pipe_ctx->ipp;
+	struct mem_input *mi = pipe_ctx->plane_res.mi;
+	struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
 	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	union plane_size size = plane_state->plane_size;
 	struct default_adjustment ocsc = {0};
@@ -1935,7 +1935,7 @@ static void update_dchubp_dpp(
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
-				pipe_ctx->mi,
+				pipe_ctx->plane_res.mi,
 				plane_state->format,
 				&plane_state->tiling_info,
 				plane_state->rotation);
@@ -1968,8 +1968,8 @@ static void update_dchubp_dpp(
 	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = per_pixel_alpha;
 	pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
 	/* scaler configuration */
-	pipe_ctx->xfm->funcs->transform_set_scaler(
-			pipe_ctx->xfm, &pipe_ctx->plane_res.scl_data);
+	pipe_ctx->plane_res.xfm->funcs->transform_set_scaler(
+			pipe_ctx->plane_res.xfm, &pipe_ctx->plane_res.scl_data);
 	mi->funcs->mem_program_viewport(mi,
 			&pipe_ctx->plane_res.scl_data.viewport, &pipe_ctx->plane_res.scl_data.viewport_c);
 
@@ -1978,7 +1978,7 @@ static void update_dchubp_dpp(
 
 	/*TODO add adjustments parameters*/
 	ocsc.out_color_space = pipe_ctx->stream->output_color_space;
-	pipe_ctx->xfm->funcs->opp_set_csc_default(pipe_ctx->xfm, &ocsc);
+	pipe_ctx->plane_res.xfm->funcs->opp_set_csc_default(pipe_ctx->plane_res.xfm, &ocsc);
 
 	mi->funcs->mem_input_program_surface_config(
 		mi,
@@ -2098,7 +2098,7 @@ static void dcn10_apply_ctx_for_surface(
 		 */
 
 		if (pipe_ctx->plane_state && !old_pipe_ctx->plane_state) {
-			if (pipe_ctx->mi->opp_id != 0xf && pipe_ctx->tg->inst == be_idx) {
+			if (pipe_ctx->plane_res.mi->opp_id != 0xf && pipe_ctx->tg->inst == be_idx) {
 				dcn10_power_down_fe(dc, pipe_ctx->pipe_idx);
 				/*
 				 * power down fe will unlock when calling reset, need
@@ -2124,7 +2124,7 @@ static void dcn10_apply_ctx_for_surface(
 					dc->res_pool->mpc,
 					old_pipe_ctx->opp,
 					old_pipe_ctx->pipe_idx);
-			old_pipe_ctx->opp->mpcc_disconnect_pending[old_pipe_ctx->mi->mpcc_id] = true;
+			old_pipe_ctx->opp->mpcc_disconnect_pending[old_pipe_ctx->plane_res.mi->mpcc_id] = true;
 
 			/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
 					"[debug_mpo: apply_ctx disconnect pending on mpcc %d]\n",
@@ -2481,19 +2481,19 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 		return;
 
 	plane_state->status.is_flip_pending =
-			pipe_ctx->mi->funcs->mem_input_is_flip_pending(
-					pipe_ctx->mi);
+			pipe_ctx->plane_res.mi->funcs->mem_input_is_flip_pending(
+					pipe_ctx->plane_res.mi);
 
 	/* DCN we read INUSE address in MI, do we still need this wa? */
 	if (plane_state->status.is_flip_pending &&
 			!plane_state->visible) {
-		pipe_ctx->mi->current_address =
-				pipe_ctx->mi->request_address;
+		pipe_ctx->plane_res.mi->current_address =
+				pipe_ctx->plane_res.mi->request_address;
 		BREAK_TO_DEBUGGER();
 	}
 
-	plane_state->status.current_address = pipe_ctx->mi->current_address;
-	if (pipe_ctx->mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
+	plane_state->status.current_address = pipe_ctx->plane_res.mi->current_address;
+	if (pipe_ctx->plane_res.mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 			tg->funcs->is_stereo_left_eye) {
 		plane_state->status.is_right_eye =
 				!tg->funcs->is_stereo_left_eye(pipe_ctx->tg);

commit 6702a9ac53f88a373a9969b4dee292f4c5f023f5
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 11:51:21 2017 -0400

    drm/amd/display: Move scl_data to plane_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.scl_data/\.plane_res.scl_data/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->scl_data/->plane_res.scl_data/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 5922cf8272f5..314d7645a898 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1728,14 +1728,14 @@ static void dcn10_power_on_fe(
 				"viewport:%d, %d, %d, %d\n"
 				"recout:  %d, %d, %d, %d\n",
 				pipe_ctx->pipe_idx,
-				pipe_ctx->scl_data.viewport.width,
-				pipe_ctx->scl_data.viewport.height,
-				pipe_ctx->scl_data.viewport.x,
-				pipe_ctx->scl_data.viewport.y,
-				pipe_ctx->scl_data.recout.width,
-				pipe_ctx->scl_data.recout.height,
-				pipe_ctx->scl_data.recout.x,
-				pipe_ctx->scl_data.recout.y);
+				pipe_ctx->plane_res.scl_data.viewport.width,
+				pipe_ctx->plane_res.scl_data.viewport.height,
+				pipe_ctx->plane_res.scl_data.viewport.x,
+				pipe_ctx->plane_res.scl_data.viewport.y,
+				pipe_ctx->plane_res.scl_data.recout.width,
+				pipe_ctx->plane_res.scl_data.recout.height,
+				pipe_ctx->plane_res.scl_data.recout.x,
+				pipe_ctx->plane_res.scl_data.recout.y);
 		print_rq_dlg_ttu(dc, pipe_ctx);
 	}
 }
@@ -1860,7 +1860,7 @@ static void dcn10_get_surface_visual_confirm_color(
 {
 	uint32_t color_value = MAX_TG_COLOR_VALUE;
 
-	switch (pipe_ctx->scl_data.format) {
+	switch (pipe_ctx->plane_res.scl_data.format) {
 	case PIXEL_FORMAT_ARGB8888:
 		/* set boarder color to red */
 		color->color_r_cr = color_value;
@@ -1931,7 +1931,7 @@ static void update_dchubp_dpp(
 		&pipe_ctx->rq_regs,
 		&pipe_ctx->pipe_dlg_param);
 
-	size.grph.surface_size = pipe_ctx->scl_data.viewport;
+	size.grph.surface_size = pipe_ctx->plane_res.scl_data.viewport;
 
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
@@ -1965,13 +1965,13 @@ static void update_dchubp_dpp(
 					&& per_pixel_alpha;
 	dc->res_pool->mpc->funcs->add(dc->res_pool->mpc, &mpcc_cfg);
 
-	pipe_ctx->scl_data.lb_params.alpha_en = per_pixel_alpha;
-	pipe_ctx->scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
+	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = per_pixel_alpha;
+	pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
 	/* scaler configuration */
 	pipe_ctx->xfm->funcs->transform_set_scaler(
-			pipe_ctx->xfm, &pipe_ctx->scl_data);
+			pipe_ctx->xfm, &pipe_ctx->plane_res.scl_data);
 	mi->funcs->mem_program_viewport(mi,
-			&pipe_ctx->scl_data.viewport, &pipe_ctx->scl_data.viewport_c);
+			&pipe_ctx->plane_res.scl_data.viewport, &pipe_ctx->plane_res.scl_data.viewport_c);
 
 	/*gamut remap*/
 	program_gamut_remap(pipe_ctx);

commit 3be5262e353b8ab97c528bfc7d0dd3c820e4ba27
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:55:38 2017 -0400

    drm/amd/display: Rename more dc_surface stuff to plane_state
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 866f63d1259d..5922cf8272f5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -986,7 +986,7 @@ static void reset_hw_ctx_wrap(
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (!pipe_ctx->stream ||
-				!pipe_ctx->surface ||
+				!pipe_ctx->plane_state ||
 				pipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {
 
 			plane_atomic_disconnect(dc, i);
@@ -1010,13 +1010,13 @@ static void reset_hw_ctx_wrap(
 		/*if (!pipe_ctx_old->stream)
 			continue;*/
 
-		if (pipe_ctx->stream && pipe_ctx->surface
+		if (pipe_ctx->stream && pipe_ctx->plane_state
 				&& !pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
 			continue;
 
 		plane_atomic_disable(dc, i);
 
-		if (!pipe_ctx->stream || !pipe_ctx->surface)
+		if (!pipe_ctx->stream || !pipe_ctx->plane_state)
 			plane_atomic_power_down(dc, i);
 	}
 
@@ -1038,24 +1038,24 @@ static void reset_hw_ctx_wrap(
 static bool patch_address_for_sbs_tb_stereo(
 		struct pipe_ctx *pipe_ctx, PHYSICAL_ADDRESS_LOC *addr)
 {
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	bool sec_split = pipe_ctx->top_pipe &&
-			pipe_ctx->top_pipe->surface == pipe_ctx->surface;
-	if (sec_split && surface->address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
+			pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state;
+	if (sec_split && plane_state->address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 		(pipe_ctx->stream->timing.timing_3d_format ==
 		 TIMING_3D_FORMAT_SIDE_BY_SIDE ||
 		 pipe_ctx->stream->timing.timing_3d_format ==
 		 TIMING_3D_FORMAT_TOP_AND_BOTTOM)) {
-		*addr = surface->address.grph_stereo.left_addr;
-		surface->address.grph_stereo.left_addr =
-		surface->address.grph_stereo.right_addr;
+		*addr = plane_state->address.grph_stereo.left_addr;
+		plane_state->address.grph_stereo.left_addr =
+		plane_state->address.grph_stereo.right_addr;
 		return true;
 	} else {
 		if (pipe_ctx->stream->view_format != VIEW_3D_FORMAT_NONE &&
-			surface->address.type != PLN_ADDR_TYPE_GRPH_STEREO) {
-			surface->address.type = PLN_ADDR_TYPE_GRPH_STEREO;
-			surface->address.grph_stereo.right_addr =
-			surface->address.grph_stereo.left_addr;
+			plane_state->address.type != PLN_ADDR_TYPE_GRPH_STEREO) {
+			plane_state->address.type = PLN_ADDR_TYPE_GRPH_STEREO;
+			plane_state->address.grph_stereo.right_addr =
+			plane_state->address.grph_stereo.left_addr;
 		}
 	}
 	return false;
@@ -1065,22 +1065,22 @@ static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ct
 {
 	bool addr_patched = false;
 	PHYSICAL_ADDRESS_LOC addr;
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 
-	if (surface == NULL)
+	if (plane_state == NULL)
 		return;
 	addr_patched = patch_address_for_sbs_tb_stereo(pipe_ctx, &addr);
 	pipe_ctx->mi->funcs->mem_input_program_surface_flip_and_addr(
 			pipe_ctx->mi,
-			&surface->address,
-			surface->flip_immediate);
-	surface->status.requested_address = surface->address;
+			&plane_state->address,
+			plane_state->flip_immediate);
+	plane_state->status.requested_address = plane_state->address;
 	if (addr_patched)
-		pipe_ctx->surface->address.grph_stereo.left_addr = addr;
+		pipe_ctx->plane_state->address.grph_stereo.left_addr = addr;
 }
 
 static bool dcn10_set_input_transfer_func(
-	struct pipe_ctx *pipe_ctx, const struct dc_plane_state *surface)
+	struct pipe_ctx *pipe_ctx, const struct dc_plane_state *plane_state)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
 	const struct dc_transfer_func *tf = NULL;
@@ -1089,12 +1089,12 @@ static bool dcn10_set_input_transfer_func(
 	if (ipp == NULL)
 		return false;
 
-	if (surface->in_transfer_func)
-		tf = surface->in_transfer_func;
+	if (plane_state->in_transfer_func)
+		tf = plane_state->in_transfer_func;
 
-	if (surface->gamma_correction && dce_use_lut(surface))
+	if (plane_state->gamma_correction && dce_use_lut(plane_state))
 		ipp->funcs->ipp_program_input_lut(ipp,
-				surface->gamma_correction);
+				plane_state->gamma_correction);
 
 	if (tf == NULL)
 		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
@@ -1689,7 +1689,7 @@ static void dcn10_power_on_fe(
 	struct pipe_ctx *pipe_ctx,
 	struct validate_context *context)
 {
-	struct dc_plane_state *dc_surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct dce_hwseq *hws = dc->hwseq;
 
 	power_on_plane(dc->hwseq,
@@ -1704,24 +1704,24 @@ static void dcn10_power_on_fe(
 			OPP_PIPE_CLOCK_EN, 1);
 	/*TODO: REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DPPCLK_WDIVIDER, 0x1f);*/
 
-	if (dc_surface) {
+	if (plane_state) {
 		dm_logger_write(dc->ctx->logger, LOG_DC,
 				"Pipe:%d 0x%x: addr hi:0x%x, "
 				"addr low:0x%x, "
 				"src: %d, %d, %d,"
 				" %d; dst: %d, %d, %d, %d;\n",
 				pipe_ctx->pipe_idx,
-				dc_surface,
-				dc_surface->address.grph.addr.high_part,
-				dc_surface->address.grph.addr.low_part,
-				dc_surface->src_rect.x,
-				dc_surface->src_rect.y,
-				dc_surface->src_rect.width,
-				dc_surface->src_rect.height,
-				dc_surface->dst_rect.x,
-				dc_surface->dst_rect.y,
-				dc_surface->dst_rect.width,
-				dc_surface->dst_rect.height);
+				plane_state,
+				plane_state->address.grph.addr.high_part,
+				plane_state->address.grph.addr.low_part,
+				plane_state->src_rect.x,
+				plane_state->src_rect.y,
+				plane_state->src_rect.width,
+				plane_state->src_rect.height,
+				plane_state->dst_rect.x,
+				plane_state->dst_rect.y,
+				plane_state->dst_rect.width,
+				plane_state->dst_rect.height);
 
 		dm_logger_write(dc->ctx->logger, LOG_HW_SET_MODE,
 				"Pipe %d: width, height, x, y\n"
@@ -1805,7 +1805,7 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 }
 static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->surface->visible)
+	if (pipe_ctx->plane_state->visible)
 		return true;
 	if (pipe_ctx->bottom_pipe && is_lower_pipe_tree_visible(pipe_ctx->bottom_pipe))
 		return true;
@@ -1814,7 +1814,7 @@ static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 
 static bool is_upper_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->surface->visible)
+	if (pipe_ctx->plane_state->visible)
 		return true;
 	if (pipe_ctx->top_pipe && is_upper_pipe_tree_visible(pipe_ctx->top_pipe))
 		return true;
@@ -1823,7 +1823,7 @@ static bool is_upper_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 
 static bool is_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->surface->visible)
+	if (pipe_ctx->plane_state->visible)
 		return true;
 	if (pipe_ctx->top_pipe && is_upper_pipe_tree_visible(pipe_ctx->top_pipe))
 		return true;
@@ -1898,12 +1898,12 @@ static void update_dchubp_dpp(
 	struct dce_hwseq *hws = dc->hwseq;
 	struct mem_input *mi = pipe_ctx->mi;
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
-	struct dc_plane_state *surface = pipe_ctx->surface;
-	union plane_size size = surface->plane_size;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
+	union plane_size size = plane_state->plane_size;
 	struct default_adjustment ocsc = {0};
 	struct mpcc_cfg mpcc_cfg = {0};
 	struct pipe_ctx *top_pipe;
-	bool per_pixel_alpha = surface->per_pixel_alpha && pipe_ctx->bottom_pipe;
+	bool per_pixel_alpha = plane_state->per_pixel_alpha && pipe_ctx->bottom_pipe;
 
 	/* TODO: proper fix once fpga works */
 	/* depends on DML calculation, DPP clock value may change dynamically */
@@ -1936,12 +1936,12 @@ static void update_dchubp_dpp(
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->mi,
-				surface->format,
-				&surface->tiling_info,
-				surface->rotation);
+				plane_state->format,
+				&plane_state->tiling_info,
+				plane_state->rotation);
 
 	ipp->funcs->ipp_setup(ipp,
-			surface->format,
+			plane_state->format,
 			1,
 			IPP_OUTPUT_FORMAT_12_BIT_FIX);
 
@@ -1982,12 +1982,12 @@ static void update_dchubp_dpp(
 
 	mi->funcs->mem_input_program_surface_config(
 		mi,
-		surface->format,
-		&surface->tiling_info,
+		plane_state->format,
+		&plane_state->tiling_info,
 		&size,
-		surface->rotation,
-		&surface->dcc,
-		surface->horizontal_mirror);
+		plane_state->rotation,
+		&plane_state->dcc,
+		plane_state->horizontal_mirror);
 
 	mi->funcs->set_blank(mi, !is_pipe_tree_visible(pipe_ctx));
 }
@@ -2025,7 +2025,7 @@ static void program_all_pipe_in_tree(
 		pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, !is_pipe_tree_visible(pipe_ctx));
 	}
 
-	if (pipe_ctx->surface != NULL) {
+	if (pipe_ctx->plane_state != NULL) {
 		dcn10_power_on_fe(dc, pipe_ctx, context);
 		update_dchubp_dpp(dc, pipe_ctx, context);
 	}
@@ -2068,7 +2068,7 @@ static void dcn10_pplib_apply_display_requirements(
 
 static void dcn10_apply_ctx_for_surface(
 		struct core_dc *dc,
-		const struct dc_plane_state *surface,
+		const struct dc_plane_state *plane_state,
 		struct validate_context *context)
 {
 	int i, be_idx;
@@ -2076,11 +2076,11 @@ static void dcn10_apply_ctx_for_surface(
 	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
-	if (!surface)
+	if (!plane_state)
 		return;
 
 	for (be_idx = 0; be_idx < dc->res_pool->pipe_count; be_idx++)
-		if (surface == context->res_ctx.pipe_ctx[be_idx].surface)
+		if (plane_state == context->res_ctx.pipe_ctx[be_idx].plane_state)
 			break;
 
 	/* reset unused mpcc */
@@ -2089,7 +2089,7 @@ static void dcn10_apply_ctx_for_surface(
 		struct pipe_ctx *old_pipe_ctx =
 				&dc->current_context->res_ctx.pipe_ctx[i];
 
-		if (!pipe_ctx->surface && !old_pipe_ctx->surface)
+		if (!pipe_ctx->plane_state && !old_pipe_ctx->plane_state)
 			continue;
 
 		/*
@@ -2097,7 +2097,7 @@ static void dcn10_apply_ctx_for_surface(
 		 * fairly hacky right now, using opp_id as indicator
 		 */
 
-		if (pipe_ctx->surface && !old_pipe_ctx->surface) {
+		if (pipe_ctx->plane_state && !old_pipe_ctx->plane_state) {
 			if (pipe_ctx->mi->opp_id != 0xf && pipe_ctx->tg->inst == be_idx) {
 				dcn10_power_down_fe(dc, pipe_ctx->pipe_idx);
 				/*
@@ -2109,7 +2109,7 @@ static void dcn10_apply_ctx_for_surface(
 		}
 
 
-		if ((!pipe_ctx->surface && old_pipe_ctx->surface)
+		if ((!pipe_ctx->plane_state && old_pipe_ctx->plane_state)
 				|| (!pipe_ctx->stream && old_pipe_ctx->stream)) {
 			if (old_pipe_ctx->tg->inst != be_idx)
 				continue;
@@ -2135,7 +2135,7 @@ static void dcn10_apply_ctx_for_surface(
 
 			old_pipe_ctx->top_pipe = NULL;
 			old_pipe_ctx->bottom_pipe = NULL;
-			old_pipe_ctx->surface = NULL;
+			old_pipe_ctx->plane_state = NULL;
 
 			dm_logger_write(dc->ctx->logger, LOG_DC,
 					"Reset mpcc for pipe %d\n",
@@ -2146,7 +2146,7 @@ static void dcn10_apply_ctx_for_surface(
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		if (pipe_ctx->surface != surface)
+		if (pipe_ctx->plane_state != plane_state)
 			continue;
 
 		/* looking for top pipe to program */
@@ -2468,34 +2468,34 @@ static bool dcn10_dummy_display_power_gating(
 
 void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 {
-	struct dc_plane_state *surface = pipe_ctx->surface;
+	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct timing_generator *tg = pipe_ctx->tg;
 
-	if (surface->ctx->dc->debug.sanity_checks) {
-		struct core_dc *dc = DC_TO_CORE(surface->ctx->dc);
+	if (plane_state->ctx->dc->debug.sanity_checks) {
+		struct core_dc *dc = DC_TO_CORE(plane_state->ctx->dc);
 
 		verify_allow_pstate_change_high(dc->hwseq);
 	}
 
-	if (surface == NULL)
+	if (plane_state == NULL)
 		return;
 
-	surface->status.is_flip_pending =
+	plane_state->status.is_flip_pending =
 			pipe_ctx->mi->funcs->mem_input_is_flip_pending(
 					pipe_ctx->mi);
 
 	/* DCN we read INUSE address in MI, do we still need this wa? */
-	if (surface->status.is_flip_pending &&
-			!surface->visible) {
+	if (plane_state->status.is_flip_pending &&
+			!plane_state->visible) {
 		pipe_ctx->mi->current_address =
 				pipe_ctx->mi->request_address;
 		BREAK_TO_DEBUGGER();
 	}
 
-	surface->status.current_address = pipe_ctx->mi->current_address;
+	plane_state->status.current_address = pipe_ctx->mi->current_address;
 	if (pipe_ctx->mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 			tg->funcs->is_stereo_left_eye) {
-		surface->status.is_right_eye =
+		plane_state->status.is_right_eye =
 				!tg->funcs->is_stereo_left_eye(pipe_ctx->tg);
 	}
 }

commit 0971c40e180696c3512b9a63ca7ca5161cbfce32
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:33:33 2017 -0400

    drm/amd/display: Rename dc_stream to dc_stream_state
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream/struct dc_stream_state/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream_state_update/struct dc_stream_update/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream_state_status/struct dc_stream_status/g'
    
    Plus some manual changes
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 3979cb03cf8d..866f63d1259d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -679,7 +679,7 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 		struct validate_context *context,
 		struct core_dc *dc)
 {
-	struct dc_stream *stream = pipe_ctx->stream;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 	enum dc_color_space color_space;
 	struct tg_color black_color = {0};
 	bool enableStereo    = stream->timing.timing_3d_format == TIMING_3D_FORMAT_NONE ?
@@ -1445,7 +1445,7 @@ static bool dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func
 
 static bool dcn10_set_output_transfer_func(
 	struct pipe_ctx *pipe_ctx,
-	const struct dc_stream *stream)
+	const struct dc_stream_state *stream)
 {
 	struct transform *xfm = pipe_ctx->xfm;
 
@@ -2321,7 +2321,7 @@ static void set_plane_config(
 }
 
 static void dcn10_config_stereo_parameters(
-		struct dc_stream *stream, struct crtc_stereo_flags *flags)
+		struct dc_stream_state *stream, struct crtc_stereo_flags *flags)
 {
 	enum view_3d_format view_format = stream->view_format;
 	enum dc_timing_3d_format timing_3d_format =\
@@ -2360,7 +2360,7 @@ static void dcn10_config_stereo_parameters(
 static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct core_dc *dc)
 {
 	struct crtc_stereo_flags flags = { 0 };
-	struct dc_stream *stream = pipe_ctx->stream;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 
 	dcn10_config_stereo_parameters(stream, &flags);
 

commit c9614aeb12f80fa7a787e608d75b707175997edd
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:24:04 2017 -0400

    drm/amd/display: Rename dc_surface to dc_plane_state
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_surface/struct dc_plane_state/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_update/struct dc_surface_update/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_status/struct dc_surface_status/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_dcc_cap/struct dc_surface_dcc_cap/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index fa19c6b92f29..3979cb03cf8d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1038,7 +1038,7 @@ static void reset_hw_ctx_wrap(
 static bool patch_address_for_sbs_tb_stereo(
 		struct pipe_ctx *pipe_ctx, PHYSICAL_ADDRESS_LOC *addr)
 {
-	struct dc_surface *surface = pipe_ctx->surface;
+	struct dc_plane_state *surface = pipe_ctx->surface;
 	bool sec_split = pipe_ctx->top_pipe &&
 			pipe_ctx->top_pipe->surface == pipe_ctx->surface;
 	if (sec_split && surface->address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
@@ -1065,7 +1065,7 @@ static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ct
 {
 	bool addr_patched = false;
 	PHYSICAL_ADDRESS_LOC addr;
-	struct dc_surface *surface = pipe_ctx->surface;
+	struct dc_plane_state *surface = pipe_ctx->surface;
 
 	if (surface == NULL)
 		return;
@@ -1080,7 +1080,7 @@ static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ct
 }
 
 static bool dcn10_set_input_transfer_func(
-	struct pipe_ctx *pipe_ctx, const struct dc_surface *surface)
+	struct pipe_ctx *pipe_ctx, const struct dc_plane_state *surface)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
 	const struct dc_transfer_func *tf = NULL;
@@ -1689,7 +1689,7 @@ static void dcn10_power_on_fe(
 	struct pipe_ctx *pipe_ctx,
 	struct validate_context *context)
 {
-	struct dc_surface *dc_surface = pipe_ctx->surface;
+	struct dc_plane_state *dc_surface = pipe_ctx->surface;
 	struct dce_hwseq *hws = dc->hwseq;
 
 	power_on_plane(dc->hwseq,
@@ -1898,7 +1898,7 @@ static void update_dchubp_dpp(
 	struct dce_hwseq *hws = dc->hwseq;
 	struct mem_input *mi = pipe_ctx->mi;
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
-	struct dc_surface *surface = pipe_ctx->surface;
+	struct dc_plane_state *surface = pipe_ctx->surface;
 	union plane_size size = surface->plane_size;
 	struct default_adjustment ocsc = {0};
 	struct mpcc_cfg mpcc_cfg = {0};
@@ -2068,7 +2068,7 @@ static void dcn10_pplib_apply_display_requirements(
 
 static void dcn10_apply_ctx_for_surface(
 		struct core_dc *dc,
-		const struct dc_surface *surface,
+		const struct dc_plane_state *surface,
 		struct validate_context *context)
 {
 	int i, be_idx;
@@ -2468,7 +2468,7 @@ static bool dcn10_dummy_display_power_gating(
 
 void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 {
-	struct dc_surface *surface = pipe_ctx->surface;
+	struct dc_plane_state *surface = pipe_ctx->surface;
 	struct timing_generator *tg = pipe_ctx->tg;
 
 	if (surface->ctx->dc->debug.sanity_checks) {

commit e75504b1292f3a9a173789a06a674fb3ba04450f
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jul 28 14:16:13 2017 -0400

    drm/amd/display: fix dcn fe reset memory access error
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e1298d7029e6..fa19c6b92f29 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -853,8 +853,9 @@ static void plane_atomic_disable(struct core_dc *dc,
 	struct dce_hwseq *hws = dc->hwseq;
 	struct mem_input *mi = dc->res_pool->mis[fe_idx];
 	struct mpc *mpc = dc->res_pool->mpc;
+	int opp_id = mi->opp_id;
 
-	if (mi->opp_id == 0xf)
+	if (opp_id == 0xf)
 		return;
 
 	mpc->funcs->wait_for_idle(mpc, mi->mpcc_id);
@@ -876,8 +877,8 @@ static void plane_atomic_disable(struct core_dc *dc,
 	REG_UPDATE(DPP_CONTROL[fe_idx],
 			DPP_CLOCK_ENABLE, 0);
 
-	if (dc->res_pool->opps[mi->opp_id]->mpc_tree.num_pipes == 0)
-		REG_UPDATE(OPP_PIPE_CONTROL[mi->opp_id],
+	if (dc->res_pool->opps[opp_id]->mpc_tree.num_pipes == 0)
+		REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
 				OPP_PIPE_CLOCK_EN, 0);
 
 	if (dc->public.debug.sanity_checks)

commit 49baf95740b4f233ea286ebbe7c1066c03f5dd3b
Author: Vikrant Mhaske <Vikrant.Mhaske@amd.com>
Date:   Thu Jul 27 17:30:52 2017 +0800

    drm/amd/display: Fix DCN compile errors
    
    Fix for DCN compiler errors caused due to various submits
    
    Signed-off-by: Charlene Liu <Charlene.Liu@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 2299bdaca376..e1298d7029e6 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1475,6 +1475,8 @@ static void dcn10_pipe_control_lock(
 	struct pipe_ctx *pipe,
 	bool lock)
 {
+	struct mem_input *mi = NULL;
+	mi = dc->res_pool->mis[pipe->pipe_idx];
 	/* use TG master update lock to lock everything on the TG
 	 * therefore only top pipe need to lock
 	 */

commit cc408d726c20f32e4fdd688f870dd2b17960d4a2
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jul 21 17:46:50 2017 -0400

    drm/amd/display: mpc block redesign
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 1531b52e61c2..2299bdaca376 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -636,15 +636,10 @@ static void dcn10_init_hw(struct core_dc *dc)
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct transform *xfm = dc->res_pool->transforms[i];
 		struct timing_generator *tg = dc->res_pool->timing_generators[i];
-		struct mpcc *mpcc = dc->res_pool->mpcc[i];
-		struct mpcc_cfg mpcc_cfg;
 
 		xfm->funcs->transform_reset(xfm);
-		mpcc_cfg.opp_id = 0xf;
-		mpcc_cfg.top_dpp_id = 0xf;
-		mpcc_cfg.bot_mpcc_id = 0xf;
-		mpcc_cfg.top_of_tree = true;
-		mpcc->funcs->set(mpcc, &mpcc_cfg);
+		dc->res_pool->mpc->funcs->remove(
+				dc->res_pool->mpc, dc->res_pool->opps[i], i);
 
 		/* Blank controller using driver code instead of
 		 * command table.
@@ -819,45 +814,35 @@ static void reset_back_end_for_pipe(
 static void plane_atomic_disconnect(struct core_dc *dc,
 		int fe_idx)
 {
-	struct mpcc_cfg mpcc_cfg;
 	struct mem_input *mi = dc->res_pool->mis[fe_idx];
-	struct transform *xfm = dc->res_pool->transforms[fe_idx];
-	struct mpcc *mpcc = dc->res_pool->mpcc[fe_idx];
-	struct timing_generator *tg = dc->res_pool->timing_generators[mpcc->opp_id];
-	unsigned int opp_id = mpcc->opp_id;
-	int opp_id_cached = mpcc->opp_id;
+	struct mpc *mpc = dc->res_pool->mpc;
+	int opp_id, z_idx;
+	int mpcc_id = -1;
+
+	/* look at tree rather than mi here to know if we already reset */
+	for (opp_id = 0; opp_id < dc->res_pool->pipe_count; opp_id++) {
+		struct output_pixel_processor *opp = dc->res_pool->opps[opp_id];
 
+		for (z_idx = 0; z_idx < opp->mpc_tree.num_pipes; z_idx++) {
+			if (opp->mpc_tree.dpp[z_idx] == fe_idx) {
+				mpcc_id = opp->mpc_tree.mpcc[z_idx];
+				break;
+			}
+		}
+		if (mpcc_id != -1)
+			break;
+	}
 	/*Already reset*/
-	if (opp_id == 0xf)
+	if (opp_id == dc->res_pool->pipe_count)
 		return;
 
 	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
-
 	mi->funcs->dcc_control(mi, false, false);
-
 	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
-	mpcc_cfg.opp_id = 0xf;
-	mpcc_cfg.top_dpp_id = 0xf;
-	mpcc_cfg.bot_mpcc_id = 0xf;
-	mpcc_cfg.top_of_tree = tg->inst == mpcc->inst;
-	mpcc->funcs->set(mpcc, &mpcc_cfg);
-
-	/*
-	 * Hack to preserve old opp_id for plane_atomic_disable
-	 * to find the correct otg
-	 */
-	mpcc->opp_id = opp_id_cached;
-
-	/* todo:call remove pipe from tree */
-	/* flag mpcc idle pending */
-
-	/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
-			"[debug_mpo: plane_atomic_disconnect pending on mpcc %d]\n",
-			fe_idx);*/
-	xfm->funcs->transform_reset(xfm);
+	mpc->funcs->remove(mpc, dc->res_pool->opps[opp_id], fe_idx);
 }
 
 /* disable HW used by plane.
@@ -867,20 +852,21 @@ static void plane_atomic_disable(struct core_dc *dc,
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct mem_input *mi = dc->res_pool->mis[fe_idx];
-	struct mpcc *mpcc = dc->res_pool->mpcc[fe_idx];
-	struct timing_generator *tg = dc->res_pool->timing_generators[mpcc->opp_id];
-	unsigned int opp_id = mpcc->opp_id;
+	struct mpc *mpc = dc->res_pool->mpc;
 
-	if (opp_id == 0xf)
+	if (mi->opp_id == 0xf)
 		return;
 
-	mpcc->funcs->wait_for_idle(mpcc);
-	dc->res_pool->opps[opp_id]->mpcc_disconnect_pending[mpcc->inst] = false;
+	mpc->funcs->wait_for_idle(mpc, mi->mpcc_id);
+	dc->res_pool->opps[mi->opp_id]->mpcc_disconnect_pending[mi->mpcc_id] = false;
 	/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
 			"[debug_mpo: atomic disable finished on mpcc %d]\n",
 			fe_idx);*/
 
 	mi->funcs->set_blank(mi, true);
+	/*todo: unhack this*/
+	mi->opp_id = 0xf;
+	mi->mpcc_id = 0xf;
 
 	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
@@ -890,12 +876,10 @@ static void plane_atomic_disable(struct core_dc *dc,
 	REG_UPDATE(DPP_CONTROL[fe_idx],
 			DPP_CLOCK_ENABLE, 0);
 
-	if (tg->inst == mpcc->inst)
-		REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
+	if (dc->res_pool->opps[mi->opp_id]->mpc_tree.num_pipes == 0)
+		REG_UPDATE(OPP_PIPE_CONTROL[mi->opp_id],
 				OPP_PIPE_CLOCK_EN, 0);
 
-	mpcc->opp_id = 0xf;
-
 	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 }
@@ -907,11 +891,13 @@ static void plane_atomic_disable(struct core_dc *dc,
 static void plane_atomic_power_down(struct core_dc *dc, int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
+	struct transform *xfm = dc->res_pool->transforms[fe_idx];
 
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 1);
 	dpp_pg_control(hws, fe_idx, false);
 	hubp_pg_control(hws, fe_idx, false);
+	xfm->funcs->transform_reset(xfm);
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
 	dm_logger_write(dc->ctx->logger, LOG_DC,
@@ -927,14 +913,14 @@ static void reset_front_end(
 		int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
-	struct mpcc *mpcc = dc->res_pool->mpcc[fe_idx];
-	struct timing_generator *tg = dc->res_pool->timing_generators[mpcc->opp_id];
-	unsigned int opp_id = mpcc->opp_id;
+	struct timing_generator *tg;
+	int opp_id = dc->res_pool->mis[fe_idx]->opp_id;
 
 	/*Already reset*/
 	if (opp_id == 0xf)
 		return;
 
+	tg = dc->res_pool->timing_generators[opp_id];
 	tg->funcs->lock(tg);
 
 	plane_atomic_disconnect(dc, fe_idx);
@@ -943,7 +929,7 @@ static void reset_front_end(
 	tg->funcs->unlock(tg);
 
 	if (dc->public.debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->hwseq);
+		verify_allow_pstate_change_high(hws);
 
 	if (tg->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
 		REG_WAIT(OTG_GLOBAL_SYNC_STATUS[tg->inst],
@@ -959,6 +945,7 @@ static void reset_front_end(
 static void dcn10_power_down_fe(struct core_dc *dc, int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
+	struct transform *xfm = dc->res_pool->transforms[fe_idx];
 
 	reset_front_end(dc, fe_idx);
 
@@ -966,6 +953,7 @@ static void dcn10_power_down_fe(struct core_dc *dc, int fe_idx)
 			IP_REQUEST_EN, 1);
 	dpp_pg_control(hws, fe_idx, false);
 	hubp_pg_control(hws, fe_idx, false);
+	xfm->funcs->transform_reset(xfm);
 	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
 	dm_logger_write(dc->ctx->logger, LOG_DC,
@@ -1910,8 +1898,8 @@ static void update_dchubp_dpp(
 	struct dc_surface *surface = pipe_ctx->surface;
 	union plane_size size = surface->plane_size;
 	struct default_adjustment ocsc = {0};
-	struct tg_color black_color = {0};
-	struct mpcc_cfg mpcc_cfg;
+	struct mpcc_cfg mpcc_cfg = {0};
+	struct pipe_ctx *top_pipe;
 	bool per_pixel_alpha = surface->per_pixel_alpha && pipe_ctx->bottom_pipe;
 
 	/* TODO: proper fix once fpga works */
@@ -1954,14 +1942,17 @@ static void update_dchubp_dpp(
 			1,
 			IPP_OUTPUT_FORMAT_12_BIT_FIX);
 
-	pipe_ctx->scl_data.lb_params.alpha_en = per_pixel_alpha;
-	mpcc_cfg.top_dpp_id = pipe_ctx->pipe_idx;
-	if (pipe_ctx->bottom_pipe)
-		mpcc_cfg.bot_mpcc_id = pipe_ctx->bottom_pipe->mpcc->inst;
+	mpcc_cfg.mi = mi;
+	mpcc_cfg.opp = pipe_ctx->opp;
+	for (top_pipe = pipe_ctx->top_pipe; top_pipe; top_pipe = top_pipe->top_pipe)
+		mpcc_cfg.z_index++;
+	if (dc->public.debug.surface_visual_confirm)
+		dcn10_get_surface_visual_confirm_color(
+				pipe_ctx, &mpcc_cfg.black_color);
 	else
-		mpcc_cfg.bot_mpcc_id = 0xf;
-	mpcc_cfg.opp_id = pipe_ctx->tg->inst;
-	mpcc_cfg.top_of_tree = pipe_ctx->pipe_idx == pipe_ctx->tg->inst;
+		color_space_to_black_color(
+			dc, pipe_ctx->stream->output_color_space,
+			&mpcc_cfg.black_color);
 	mpcc_cfg.per_pixel_alpha = per_pixel_alpha;
 	/* DCN1.0 has output CM before MPC which seems to screw with
 	 * pre-multiplied alpha.
@@ -1969,17 +1960,9 @@ static void update_dchubp_dpp(
 	mpcc_cfg.pre_multiplied_alpha = is_rgb_cspace(
 			pipe_ctx->stream->output_color_space)
 					&& per_pixel_alpha;
-	pipe_ctx->mpcc->funcs->set(pipe_ctx->mpcc, &mpcc_cfg);
-
-	if (dc->public.debug.surface_visual_confirm) {
-		dcn10_get_surface_visual_confirm_color(pipe_ctx, &black_color);
-	} else {
-		color_space_to_black_color(
-			dc, pipe_ctx->stream->output_color_space,
-			&black_color);
-	}
-	pipe_ctx->mpcc->funcs->set_bg_color(pipe_ctx->mpcc, &black_color);
+	dc->res_pool->mpc->funcs->add(dc->res_pool->mpc, &mpcc_cfg);
 
+	pipe_ctx->scl_data.lb_params.alpha_en = per_pixel_alpha;
 	pipe_ctx->scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
 	/* scaler configuration */
 	pipe_ctx->xfm->funcs->transform_set_scaler(
@@ -2112,7 +2095,7 @@ static void dcn10_apply_ctx_for_surface(
 		 */
 
 		if (pipe_ctx->surface && !old_pipe_ctx->surface) {
-			if (pipe_ctx->mpcc->opp_id != 0xf && pipe_ctx->tg->inst == be_idx) {
+			if (pipe_ctx->mi->opp_id != 0xf && pipe_ctx->tg->inst == be_idx) {
 				dcn10_power_down_fe(dc, pipe_ctx->pipe_idx);
 				/*
 				 * power down fe will unlock when calling reset, need
@@ -2125,9 +2108,6 @@ static void dcn10_apply_ctx_for_surface(
 
 		if ((!pipe_ctx->surface && old_pipe_ctx->surface)
 				|| (!pipe_ctx->stream && old_pipe_ctx->stream)) {
-			struct mpcc_cfg mpcc_cfg;
-			int opp_id_cached = old_pipe_ctx->mpcc->opp_id;
-
 			if (old_pipe_ctx->tg->inst != be_idx)
 				continue;
 
@@ -2137,12 +2117,11 @@ static void dcn10_apply_ctx_for_surface(
 			}
 
 			/* reset mpc */
-			mpcc_cfg.opp_id = 0xf;
-			mpcc_cfg.top_dpp_id = 0xf;
-			mpcc_cfg.bot_mpcc_id = 0xf;
-			mpcc_cfg.top_of_tree = !old_pipe_ctx->top_pipe;
-			old_pipe_ctx->mpcc->funcs->set(old_pipe_ctx->mpcc, &mpcc_cfg);
-			old_pipe_ctx->top_pipe->opp->mpcc_disconnect_pending[old_pipe_ctx->mpcc->inst] = true;
+			dc->res_pool->mpc->funcs->remove(
+					dc->res_pool->mpc,
+					old_pipe_ctx->opp,
+					old_pipe_ctx->pipe_idx);
+			old_pipe_ctx->opp->mpcc_disconnect_pending[old_pipe_ctx->mi->mpcc_id] = true;
 
 			/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
 					"[debug_mpo: apply_ctx disconnect pending on mpcc %d]\n",
@@ -2151,13 +2130,6 @@ static void dcn10_apply_ctx_for_surface(
 			if (dc->public.debug.sanity_checks)
 				verify_allow_pstate_change_high(dc->hwseq);
 
-			/*
-			 * the mpcc is the only thing that keeps track of the mpcc
-			 * mapping for reset front end right now. Might need some
-			 * rework.
-			 */
-			old_pipe_ctx->mpcc->opp_id = opp_id_cached;
-
 			old_pipe_ctx->top_pipe = NULL;
 			old_pipe_ctx->bottom_pipe = NULL;
 			old_pipe_ctx->surface = NULL;
@@ -2466,12 +2438,12 @@ static void dcn10_wait_for_mpcc_disconnect(
 {
 	int i;
 
-	if (!pipe_ctx->opp || !pipe_ctx->mpcc)
+	if (!pipe_ctx->opp)
 		return;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (pipe_ctx->opp->mpcc_disconnect_pending[i]) {
-			pipe_ctx->mpcc->funcs->wait_for_idle(res_pool->mpcc[i]);
+			res_pool->mpc->funcs->wait_for_idle(res_pool->mpc, i);
 			pipe_ctx->opp->mpcc_disconnect_pending[i] = false;
 			res_pool->mis[i]->funcs->set_blank(res_pool->mis[i], true);
 			/*dm_logger_write(dc->ctx->logger, LOG_ERROR,

commit 4fa086b9b6640818c053c79d4d7104790ba76cb7
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Jul 25 20:51:26 2017 -0400

    drm/amd/display: Roll core_stream into dc_stream
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index e738387d8ba3..1531b52e61c2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -684,12 +684,12 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 		struct validate_context *context,
 		struct core_dc *dc)
 {
-	struct core_stream *stream = pipe_ctx->stream;
+	struct dc_stream *stream = pipe_ctx->stream;
 	enum dc_color_space color_space;
 	struct tg_color black_color = {0};
-	bool enableStereo    = stream->public.timing.timing_3d_format == TIMING_3D_FORMAT_NONE ?
+	bool enableStereo    = stream->timing.timing_3d_format == TIMING_3D_FORMAT_NONE ?
 			false:true;
-	bool rightEyePolarity = stream->public.timing.flags.RIGHT_EYE_3D_POLARITY;
+	bool rightEyePolarity = stream->timing.flags.RIGHT_EYE_3D_POLARITY;
 
 
 	/* by upper caller loop, pipe0 is parent pipe and be called first.
@@ -722,7 +722,7 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 
 	pipe_ctx->tg->funcs->program_timing(
 			pipe_ctx->tg,
-			&stream->public.timing,
+			&stream->timing,
 			true);
 
 	pipe_ctx->opp->funcs->opp_set_stereo_polarity(
@@ -742,7 +742,7 @@ static enum dc_status dcn10_prog_pixclk_crtc_otg(
 				&stream->clamping);
 #endif
 	/* program otg blank color */
-	color_space = stream->public.output_color_space;
+	color_space = stream->output_color_space;
 	color_space_to_black_color(dc, color_space, &black_color);
 	pipe_ctx->tg->funcs->set_blank_color(
 			pipe_ctx->tg,
@@ -1053,16 +1053,16 @@ static bool patch_address_for_sbs_tb_stereo(
 	bool sec_split = pipe_ctx->top_pipe &&
 			pipe_ctx->top_pipe->surface == pipe_ctx->surface;
 	if (sec_split && surface->address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
-		(pipe_ctx->stream->public.timing.timing_3d_format ==
+		(pipe_ctx->stream->timing.timing_3d_format ==
 		 TIMING_3D_FORMAT_SIDE_BY_SIDE ||
-		 pipe_ctx->stream->public.timing.timing_3d_format ==
+		 pipe_ctx->stream->timing.timing_3d_format ==
 		 TIMING_3D_FORMAT_TOP_AND_BOTTOM)) {
 		*addr = surface->address.grph_stereo.left_addr;
 		surface->address.grph_stereo.left_addr =
 		surface->address.grph_stereo.right_addr;
 		return true;
 	} else {
-		if (pipe_ctx->stream->public.view_format != VIEW_3D_FORMAT_NONE &&
+		if (pipe_ctx->stream->view_format != VIEW_3D_FORMAT_NONE &&
 			surface->address.type != PLN_ADDR_TYPE_GRPH_STEREO) {
 			surface->address.type = PLN_ADDR_TYPE_GRPH_STEREO;
 			surface->address.grph_stereo.right_addr =
@@ -1456,7 +1456,7 @@ static bool dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func
 
 static bool dcn10_set_output_transfer_func(
 	struct pipe_ctx *pipe_ctx,
-	const struct core_stream *stream)
+	const struct dc_stream *stream)
 {
 	struct transform *xfm = pipe_ctx->xfm;
 
@@ -1465,14 +1465,14 @@ static bool dcn10_set_output_transfer_func(
 
 	xfm->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
 
-	if (stream->public.out_transfer_func &&
-		stream->public.out_transfer_func->type ==
+	if (stream->out_transfer_func &&
+		stream->out_transfer_func->type ==
 			TF_TYPE_PREDEFINED &&
-		stream->public.out_transfer_func->tf ==
+		stream->out_transfer_func->tf ==
 			TRANSFER_FUNCTION_SRGB) {
 		xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_SRGB);
 	} else if (dcn10_translate_regamma_to_hw_format(
-				stream->public.out_transfer_func, &xfm->regamma_params)) {
+				stream->out_transfer_func, &xfm->regamma_params)) {
 			xfm->funcs->opp_program_regamma_pwl(xfm, &xfm->regamma_params);
 			xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_USER);
 	} else {
@@ -1756,35 +1756,35 @@ static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
 
 
-	if (pipe_ctx->stream->public.gamut_remap_matrix.enable_remap == true) {
+	if (pipe_ctx->stream->gamut_remap_matrix.enable_remap == true) {
 		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
 		adjust.temperature_matrix[0] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[0];
+				gamut_remap_matrix.matrix[0];
 		adjust.temperature_matrix[1] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[1];
+				gamut_remap_matrix.matrix[1];
 		adjust.temperature_matrix[2] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[2];
+				gamut_remap_matrix.matrix[2];
 		adjust.temperature_matrix[3] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[4];
+				gamut_remap_matrix.matrix[4];
 		adjust.temperature_matrix[4] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[5];
+				gamut_remap_matrix.matrix[5];
 		adjust.temperature_matrix[5] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[6];
+				gamut_remap_matrix.matrix[6];
 		adjust.temperature_matrix[6] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[8];
+				gamut_remap_matrix.matrix[8];
 		adjust.temperature_matrix[7] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[9];
+				gamut_remap_matrix.matrix[9];
 		adjust.temperature_matrix[8] =
 				pipe_ctx->stream->
-				public.gamut_remap_matrix.matrix[10];
+				gamut_remap_matrix.matrix[10];
 	}
 
 	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
@@ -1798,14 +1798,14 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 	int i;
 	struct out_csc_color_matrix tbl_entry;
 
-	if (pipe_ctx->stream->public.csc_color_matrix.enable_adjustment
+	if (pipe_ctx->stream->csc_color_matrix.enable_adjustment
 				== true) {
 			enum dc_color_space color_space =
-				pipe_ctx->stream->public.output_color_space;
+				pipe_ctx->stream->output_color_space;
 
 			//uint16_t matrix[12];
 			for (i = 0; i < 12; i++)
-				tbl_entry.regval[i] = pipe_ctx->stream->public.csc_color_matrix.matrix[i];
+				tbl_entry.regval[i] = pipe_ctx->stream->csc_color_matrix.matrix[i];
 
 			tbl_entry.color_space = color_space;
 			//tbl_entry.regval = matrix;
@@ -1967,7 +1967,7 @@ static void update_dchubp_dpp(
 	 * pre-multiplied alpha.
 	 */
 	mpcc_cfg.pre_multiplied_alpha = is_rgb_cspace(
-			pipe_ctx->stream->public.output_color_space)
+			pipe_ctx->stream->output_color_space)
 					&& per_pixel_alpha;
 	pipe_ctx->mpcc->funcs->set(pipe_ctx->mpcc, &mpcc_cfg);
 
@@ -1975,7 +1975,7 @@ static void update_dchubp_dpp(
 		dcn10_get_surface_visual_confirm_color(pipe_ctx, &black_color);
 	} else {
 		color_space_to_black_color(
-			dc, pipe_ctx->stream->public.output_color_space,
+			dc, pipe_ctx->stream->output_color_space,
 			&black_color);
 	}
 	pipe_ctx->mpcc->funcs->set_bg_color(pipe_ctx->mpcc, &black_color);
@@ -1991,7 +1991,7 @@ static void update_dchubp_dpp(
 	program_gamut_remap(pipe_ctx);
 
 	/*TODO add adjustments parameters*/
-	ocsc.out_color_space = pipe_ctx->stream->public.output_color_space;
+	ocsc.out_color_space = pipe_ctx->stream->output_color_space;
 	pipe_ctx->xfm->funcs->opp_set_csc_default(pipe_ctx->xfm, &ocsc);
 
 	mi->funcs->mem_input_program_surface_config(
@@ -2346,11 +2346,11 @@ static void set_plane_config(
 }
 
 static void dcn10_config_stereo_parameters(
-		struct core_stream *stream, struct crtc_stereo_flags *flags)
+		struct dc_stream *stream, struct crtc_stereo_flags *flags)
 {
-	enum view_3d_format view_format = stream->public.view_format;
+	enum view_3d_format view_format = stream->view_format;
 	enum dc_timing_3d_format timing_3d_format =\
-			stream->public.timing.timing_3d_format;
+			stream->timing.timing_3d_format;
 	bool non_stereo_timing = false;
 
 	if (timing_3d_format == TIMING_3D_FORMAT_NONE ||
@@ -2374,7 +2374,7 @@ static void dcn10_config_stereo_parameters(
 				flags->DISABLE_STEREO_DP_SYNC = 1;
 		}
 		flags->RIGHT_EYE_POLARITY =\
-				stream->public.timing.flags.RIGHT_EYE_3D_POLARITY;
+				stream->timing.flags.RIGHT_EYE_3D_POLARITY;
 		if (timing_3d_format == TIMING_3D_FORMAT_HW_FRAME_PACKING)
 			flags->FRAME_PACKED = 1;
 	}
@@ -2385,18 +2385,18 @@ static void dcn10_config_stereo_parameters(
 static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct core_dc *dc)
 {
 	struct crtc_stereo_flags flags = { 0 };
-	struct core_stream *stream = pipe_ctx->stream;
+	struct dc_stream *stream = pipe_ctx->stream;
 
 	dcn10_config_stereo_parameters(stream, &flags);
 
 	pipe_ctx->opp->funcs->opp_set_stereo_polarity(
 		pipe_ctx->opp,
 		flags.PROGRAM_STEREO == 1 ? true:false,
-		stream->public.timing.flags.RIGHT_EYE_3D_POLARITY == 1 ? true:false);
+		stream->timing.flags.RIGHT_EYE_3D_POLARITY == 1 ? true:false);
 
 	pipe_ctx->tg->funcs->program_stereo(
 		pipe_ctx->tg,
-		&stream->public.timing,
+		&stream->timing,
 		&flags);
 
 	return;

commit 2248eb6b4f1fdd7aded987d178a95b021d3a1d91
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Tue Jul 25 22:52:45 2017 -0400

    drm/amd/display: log HUBP using DTN logging
    
    also simplify DTN INFO.  all we need is a way to have DC log register states
    some where we can compare with golden.  going through connectivity is overkill.
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 03f404808a1c..e738387d8ba3 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -31,9 +31,9 @@
 #include "dce110/dce110_hw_sequencer.h"
 #include "dce/dce_hwseq.h"
 #include "abm.h"
+#include "dcn10/dcn10_mem_input.h"
 #include "dcn10/dcn10_dpp.h"
 #include "dcn10/dcn10_mpc.h"
-#include "mem_input.h"
 #include "timing_generator.h"
 #include "opp.h"
 #include "ipp.h"
@@ -2402,22 +2402,61 @@ static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct core_dc *dc)
 	return;
 }
 
-static void dcn10_log_hw_state(struct core_dc *dc)
+
+static void log_mpc_crc(struct core_dc *dc)
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	struct dce_hwseq *hws = dc->hwseq;
 
-	DTN_INFO("Hello World");
-
 	if (REG(MPC_CRC_RESULT_GB))
 		DTN_INFO("MPC_CRC_RESULT_GB:%d MPC_CRC_RESULT_C:%d MPC_CRC_RESULT_AR:%d\n",
 		REG_READ(MPC_CRC_RESULT_GB), REG_READ(MPC_CRC_RESULT_C), REG_READ(MPC_CRC_RESULT_AR));
 	if (REG(DPP_TOP0_DPP_CRC_VAL_B_A))
 		DTN_INFO("DPP_TOP0_DPP_CRC_VAL_B_A:%d DPP_TOP0_DPP_CRC_VAL_R_G:%d\n",
 		REG_READ(DPP_TOP0_DPP_CRC_VAL_B_A), REG_READ(DPP_TOP0_DPP_CRC_VAL_R_G));
-	/* todo: add meaningful register reads and print out HW state
-	 *
-	 */
+}
+
+static void dcn10_log_hw_state(struct core_dc *dc)
+{
+	struct dc_context *dc_ctx = dc->ctx;
+	struct resource_pool *pool = dc->res_pool;
+	int i;
+
+	DTN_INFO_BEGIN();
+
+	DTN_INFO("HUBP:\t format \t addr_hi \t width \t height \t rotation \t"
+			"mirror \t  sw_mode \t dcc_en \t blank_en \t ttu_dis \t"
+			"min_ttu_vblank \t qos_low_wm \t qos_high_wm \n");
+
+	for (i = 0; i < pool->pipe_count; i++) {
+		struct mem_input *mi = pool->mis[i];
+		struct dcn_hubp_state s;
+
+		dcn10_mem_input_read_state(TO_DCN10_MEM_INPUT(mi), &s);
+
+		DTN_INFO("[%d]:\t %xh \t %xh \t %d \t %d \t %xh \t %xh \t "
+				"%d \t %d \t %d \t %d \t"
+				"%d \t %d \t %d \n",
+				i,
+				s.pixel_format,
+				s.inuse_addr_hi,
+				s.viewport_width,
+				s.viewport_height,
+				s.rotation_angle,
+				s.h_mirror_en,
+				s.sw_mode,
+				s.dcc_en,
+				s.blank_en,
+				s.ttu_disable,
+				s.min_ttu_vblank,
+				s.qos_level_low_wm,
+				s.qos_level_high_wm);
+	}
+	DTN_INFO("\n");
+
+	log_mpc_crc(dc);
+
+	DTN_INFO_END();
 }
 
 static void dcn10_wait_for_mpcc_disconnect(

commit 8d6a615a16d6fd75c455561914e71b903df73aa4
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Jul 25 17:11:26 2017 -0400

    drm/amd/display: Disable timestamp and entry heading
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 7c24e8f43bb1..03f404808a1c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -2407,7 +2407,7 @@ static void dcn10_log_hw_state(struct core_dc *dc)
 	struct dc_context *dc_ctx = dc->ctx;
 	struct dce_hwseq *hws = dc->hwseq;
 
-	DTN_INFO("%s: Hello World", __func__);
+	DTN_INFO("Hello World");
 
 	if (REG(MPC_CRC_RESULT_GB))
 		DTN_INFO("MPC_CRC_RESULT_GB:%d MPC_CRC_RESULT_C:%d MPC_CRC_RESULT_AR:%d\n",

commit f4d5abf56b03e55f83d300324e5bf5f32431171c
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Tue Jul 25 16:02:33 2017 -0400

    drm/amd/display: move ocsc programming from opp to dpp
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index bbe3e8705405..7c24e8f43bb1 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1809,7 +1809,7 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 
 			tbl_entry.color_space = color_space;
 			//tbl_entry.regval = matrix;
-			pipe_ctx->opp->funcs->opp_set_csc_adjustment(pipe_ctx->opp, &tbl_entry);
+			pipe_ctx->xfm->funcs->opp_set_csc_adjustment(pipe_ctx->xfm, &tbl_entry);
 	}
 }
 static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)

commit 6be425f3dc16bac797f300136b976bce46229784
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Mon Jul 24 10:47:02 2017 -0400

    drm/amd/display: break up plane disable and disconnect in set mode
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 3a0fcaad84c2..bbe3e8705405 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -831,21 +831,32 @@ static void plane_atomic_disconnect(struct core_dc *dc,
 	if (opp_id == 0xf)
 		return;
 
+	if (dc->public.debug.sanity_checks)
+		verify_allow_pstate_change_high(dc->hwseq);
+
 	mi->funcs->dcc_control(mi, false, false);
 
+	if (dc->public.debug.sanity_checks)
+		verify_allow_pstate_change_high(dc->hwseq);
+
 	mpcc_cfg.opp_id = 0xf;
 	mpcc_cfg.top_dpp_id = 0xf;
 	mpcc_cfg.bot_mpcc_id = 0xf;
 	mpcc_cfg.top_of_tree = tg->inst == mpcc->inst;
 	mpcc->funcs->set(mpcc, &mpcc_cfg);
 
-	/* Hack to preserve old opp_id for plane_atomic_disable
-	 * to find the correct otg */
+	/*
+	 * Hack to preserve old opp_id for plane_atomic_disable
+	 * to find the correct otg
+	 */
 	mpcc->opp_id = opp_id_cached;
 
 	/* todo:call remove pipe from tree */
 	/* flag mpcc idle pending */
 
+	/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
+			"[debug_mpo: plane_atomic_disconnect pending on mpcc %d]\n",
+			fe_idx);*/
 	xfm->funcs->transform_reset(xfm);
 }
 
@@ -864,6 +875,10 @@ static void plane_atomic_disable(struct core_dc *dc,
 		return;
 
 	mpcc->funcs->wait_for_idle(mpcc);
+	dc->res_pool->opps[opp_id]->mpcc_disconnect_pending[mpcc->inst] = false;
+	/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
+			"[debug_mpo: atomic disable finished on mpcc %d]\n",
+			fe_idx);*/
 
 	mi->funcs->set_blank(mi, true);
 
@@ -885,13 +900,27 @@ static void plane_atomic_disable(struct core_dc *dc,
 		verify_allow_pstate_change_high(dc->hwseq);
 }
 
-/* kill power to plane hw
+/*
+ * kill power to plane hw
  * note: cannot power down until plane is disable
-static void plane_atomic_power_down()
+ */
+static void plane_atomic_power_down(struct core_dc *dc, int fe_idx)
 {
+	struct dce_hwseq *hws = dc->hwseq;
+
+	REG_SET(DC_IP_REQUEST_CNTL, 0,
+			IP_REQUEST_EN, 1);
+	dpp_pg_control(hws, fe_idx, false);
+	hubp_pg_control(hws, fe_idx, false);
+	REG_SET(DC_IP_REQUEST_CNTL, 0,
+			IP_REQUEST_EN, 0);
+	dm_logger_write(dc->ctx->logger, LOG_DC,
+			"Power gated front end %d\n", fe_idx);
 
+	if (dc->public.debug.sanity_checks)
+		verify_allow_pstate_change_high(dc->hwseq);
 }
-*/
+
 
 static void reset_front_end(
 		struct core_dc *dc,
@@ -953,6 +982,37 @@ static void reset_hw_ctx_wrap(
 	int i;
 
 	/* Reset Front End*/
+	/* Lock*/
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *cur_pipe_ctx = &dc->current_context->res_ctx.pipe_ctx[i];
+		struct timing_generator *tg = cur_pipe_ctx->tg;
+
+		if (cur_pipe_ctx->stream)
+			tg->funcs->lock(tg);
+	}
+	/* Disconnect*/
+	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
+		struct pipe_ctx *pipe_ctx_old =
+			&dc->current_context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (!pipe_ctx->stream ||
+				!pipe_ctx->surface ||
+				pipe_need_reprogram(pipe_ctx_old, pipe_ctx)) {
+
+			plane_atomic_disconnect(dc, i);
+		}
+	}
+	/* Unlock*/
+	for (i = dc->res_pool->pipe_count - 1; i >= 0; i--) {
+		struct pipe_ctx *cur_pipe_ctx = &dc->current_context->res_ctx.pipe_ctx[i];
+		struct timing_generator *tg = cur_pipe_ctx->tg;
+
+		if (cur_pipe_ctx->stream)
+			tg->funcs->unlock(tg);
+	}
+
+	/* Disable and Powerdown*/
 	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
 		struct pipe_ctx *pipe_ctx_old =
 			&dc->current_context->res_ctx.pipe_ctx[i];
@@ -961,11 +1021,16 @@ static void reset_hw_ctx_wrap(
 		/*if (!pipe_ctx_old->stream)
 			continue;*/
 
+		if (pipe_ctx->stream && pipe_ctx->surface
+				&& !pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
+			continue;
+
+		plane_atomic_disable(dc, i);
+
 		if (!pipe_ctx->stream || !pipe_ctx->surface)
-			dcn10_power_down_fe(dc, i);
-		else if (pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
-			reset_front_end(dc, i);
+			plane_atomic_power_down(dc, i);
 	}
+
 	/* Reset Back End*/
 	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
 		struct pipe_ctx *pipe_ctx_old =
@@ -2079,6 +2144,10 @@ static void dcn10_apply_ctx_for_surface(
 			old_pipe_ctx->mpcc->funcs->set(old_pipe_ctx->mpcc, &mpcc_cfg);
 			old_pipe_ctx->top_pipe->opp->mpcc_disconnect_pending[old_pipe_ctx->mpcc->inst] = true;
 
+			/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
+					"[debug_mpo: apply_ctx disconnect pending on mpcc %d]\n",
+					old_pipe_ctx->mpcc->inst);*/
+
 			if (dc->public.debug.sanity_checks)
 				verify_allow_pstate_change_high(dc->hwseq);
 
@@ -2351,18 +2420,27 @@ static void dcn10_log_hw_state(struct core_dc *dc)
 	 */
 }
 
-static void dcn10_wait_for_mpcc_disconnect(struct resource_pool *res_pool, struct pipe_ctx *pipe_ctx)
+static void dcn10_wait_for_mpcc_disconnect(
+		struct core_dc *dc,
+		struct resource_pool *res_pool,
+		struct pipe_ctx *pipe_ctx)
 {
 	int i;
-	for (i = 0; i < MAX_PIPES; i++) {
-		if (!pipe_ctx->opp || !pipe_ctx->mpcc)
-			continue;
 
+	if (!pipe_ctx->opp || !pipe_ctx->mpcc)
+		return;
+
+	for (i = 0; i < MAX_PIPES; i++) {
 		if (pipe_ctx->opp->mpcc_disconnect_pending[i]) {
 			pipe_ctx->mpcc->funcs->wait_for_idle(res_pool->mpcc[i]);
 			pipe_ctx->opp->mpcc_disconnect_pending[i] = false;
+			res_pool->mis[i]->funcs->set_blank(res_pool->mis[i], true);
+			/*dm_logger_write(dc->ctx->logger, LOG_ERROR,
+					"[debug_mpo: wait_for_mpcc finished waiting on mpcc %d]\n",
+					i);*/
 		}
 	}
+
 }
 
 static bool dcn10_dummy_display_power_gating(

commit a74b27341e46aad3eb48a8c5eadc38b71f79cbce
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Sun Jul 23 15:22:47 2017 -0400

    drm/amd/display: separate plane disable sequence
    
    - disconnect:  trigger hw to disconnect plane on next vsync
    - disable: disables HW block and disable clocks
    - power_down: kill power
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c25a39214111..3a0fcaad84c2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -815,8 +815,8 @@ static void reset_back_end_for_pipe(
 					pipe_ctx->pipe_idx, pipe_ctx->tg->inst);
 }
 
-static void plane_atomic_stop(
-		struct core_dc *dc,
+/* trigger HW to start disconnect plane from stream on the next vsync */
+static void plane_atomic_disconnect(struct core_dc *dc,
 		int fe_idx)
 {
 	struct mpcc_cfg mpcc_cfg;
@@ -824,6 +824,12 @@ static void plane_atomic_stop(
 	struct transform *xfm = dc->res_pool->transforms[fe_idx];
 	struct mpcc *mpcc = dc->res_pool->mpcc[fe_idx];
 	struct timing_generator *tg = dc->res_pool->timing_generators[mpcc->opp_id];
+	unsigned int opp_id = mpcc->opp_id;
+	int opp_id_cached = mpcc->opp_id;
+
+	/*Already reset*/
+	if (opp_id == 0xf)
+		return;
 
 	mi->funcs->dcc_control(mi, false, false);
 
@@ -833,11 +839,19 @@ static void plane_atomic_stop(
 	mpcc_cfg.top_of_tree = tg->inst == mpcc->inst;
 	mpcc->funcs->set(mpcc, &mpcc_cfg);
 
+	/* Hack to preserve old opp_id for plane_atomic_disable
+	 * to find the correct otg */
+	mpcc->opp_id = opp_id_cached;
+
+	/* todo:call remove pipe from tree */
+	/* flag mpcc idle pending */
+
 	xfm->funcs->transform_reset(xfm);
 }
 
-static void reset_front_end(
-		struct core_dc *dc,
+/* disable HW used by plane.
+ * note:  cannot disable until disconnect is complete */
+static void plane_atomic_disable(struct core_dc *dc,
 		int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;
@@ -846,24 +860,9 @@ static void reset_front_end(
 	struct timing_generator *tg = dc->res_pool->timing_generators[mpcc->opp_id];
 	unsigned int opp_id = mpcc->opp_id;
 
-	/*Already reset*/
 	if (opp_id == 0xf)
 		return;
 
-	tg->funcs->lock(tg);
-
-	plane_atomic_stop(dc, fe_idx);
-
-	REG_UPDATE(OTG_GLOBAL_SYNC_STATUS[tg->inst], VUPDATE_NO_LOCK_EVENT_CLEAR, 1);
-	tg->funcs->unlock(tg);
-
-	if (dc->public.debug.sanity_checks)
-		verify_allow_pstate_change_high(dc->hwseq);
-
-	if (tg->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
-		REG_WAIT(OTG_GLOBAL_SYNC_STATUS[tg->inst],
-				VUPDATE_NO_LOCK_EVENT_OCCURRED, 1, 20000, 200000);
-
 	mpcc->funcs->wait_for_idle(mpcc);
 
 	mi->funcs->set_blank(mi, true);
@@ -880,14 +879,54 @@ static void reset_front_end(
 		REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
 				OPP_PIPE_CLOCK_EN, 0);
 
-	dm_logger_write(dc->ctx->logger, LOG_DC,
-					"Reset front end %d\n",
-					fe_idx);
+	mpcc->opp_id = 0xf;
 
 	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 }
 
+/* kill power to plane hw
+ * note: cannot power down until plane is disable
+static void plane_atomic_power_down()
+{
+
+}
+*/
+
+static void reset_front_end(
+		struct core_dc *dc,
+		int fe_idx)
+{
+	struct dce_hwseq *hws = dc->hwseq;
+	struct mpcc *mpcc = dc->res_pool->mpcc[fe_idx];
+	struct timing_generator *tg = dc->res_pool->timing_generators[mpcc->opp_id];
+	unsigned int opp_id = mpcc->opp_id;
+
+	/*Already reset*/
+	if (opp_id == 0xf)
+		return;
+
+	tg->funcs->lock(tg);
+
+	plane_atomic_disconnect(dc, fe_idx);
+
+	REG_UPDATE(OTG_GLOBAL_SYNC_STATUS[tg->inst], VUPDATE_NO_LOCK_EVENT_CLEAR, 1);
+	tg->funcs->unlock(tg);
+
+	if (dc->public.debug.sanity_checks)
+		verify_allow_pstate_change_high(dc->hwseq);
+
+	if (tg->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
+		REG_WAIT(OTG_GLOBAL_SYNC_STATUS[tg->inst],
+				VUPDATE_NO_LOCK_EVENT_OCCURRED, 1, 20000, 200000);
+
+	plane_atomic_disable(dc, fe_idx);
+
+	dm_logger_write(dc->ctx->logger, LOG_DC,
+					"Reset front end %d\n",
+					fe_idx);
+}
+
 static void dcn10_power_down_fe(struct core_dc *dc, int fe_idx)
 {
 	struct dce_hwseq *hws = dc->hwseq;

commit d0778ebfd58f5650de17531296ee5ecdde39ba68
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sat Jul 22 20:05:20 2017 -0400

    drm/amd/display: Roll core_link into dc_link
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 4390023ca6dc..c25a39214111 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -628,7 +628,7 @@ static void dcn10_init_hw(struct core_dc *dc)
 		 * required signal (which may be different from the
 		 * default signal on connector).
 		 */
-		struct core_link *link = dc->links[i];
+		struct dc_link *link = dc->links[i];
 
 		link->link_enc->funcs->hw_init(link->link_enc);
 	}
@@ -2259,7 +2259,7 @@ static void dcn10_config_stereo_parameters(
 			timing_3d_format == TIMING_3D_FORMAT_DP_HDMI_INBAND_FA ||
 			timing_3d_format == TIMING_3D_FORMAT_SIDEBAND_FA) {
 			enum display_dongle_type dongle = \
-					stream->sink->link->public.ddc->dongle_type;
+					stream->sink->link->ddc->dongle_type;
 			if (dongle == DISPLAY_DONGLE_DP_VGA_CONVERTER ||
 				dongle == DISPLAY_DONGLE_DP_DVI_CONVERTER ||
 				dongle == DISPLAY_DONGLE_DP_HDMI_CONVERTER)

commit e12cfcb1d447cc937d1abc6f4aab8bbe5f88542e
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 20 11:43:32 2017 -0400

    drm/amd/display: Roll core_surface into dc_surface
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index b7940876c761..4390023ca6dc 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -945,24 +945,24 @@ static void reset_hw_ctx_wrap(
 static bool patch_address_for_sbs_tb_stereo(
 		struct pipe_ctx *pipe_ctx, PHYSICAL_ADDRESS_LOC *addr)
 {
-	struct core_surface *surface = pipe_ctx->surface;
+	struct dc_surface *surface = pipe_ctx->surface;
 	bool sec_split = pipe_ctx->top_pipe &&
 			pipe_ctx->top_pipe->surface == pipe_ctx->surface;
-	if (sec_split && surface->public.address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
+	if (sec_split && surface->address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
 		(pipe_ctx->stream->public.timing.timing_3d_format ==
 		 TIMING_3D_FORMAT_SIDE_BY_SIDE ||
 		 pipe_ctx->stream->public.timing.timing_3d_format ==
 		 TIMING_3D_FORMAT_TOP_AND_BOTTOM)) {
-		*addr = surface->public.address.grph_stereo.left_addr;
-		surface->public.address.grph_stereo.left_addr =
-		surface->public.address.grph_stereo.right_addr;
+		*addr = surface->address.grph_stereo.left_addr;
+		surface->address.grph_stereo.left_addr =
+		surface->address.grph_stereo.right_addr;
 		return true;
 	} else {
 		if (pipe_ctx->stream->public.view_format != VIEW_3D_FORMAT_NONE &&
-			surface->public.address.type != PLN_ADDR_TYPE_GRPH_STEREO) {
-			surface->public.address.type = PLN_ADDR_TYPE_GRPH_STEREO;
-			surface->public.address.grph_stereo.right_addr =
-			surface->public.address.grph_stereo.left_addr;
+			surface->address.type != PLN_ADDR_TYPE_GRPH_STEREO) {
+			surface->address.type = PLN_ADDR_TYPE_GRPH_STEREO;
+			surface->address.grph_stereo.right_addr =
+			surface->address.grph_stereo.left_addr;
 		}
 	}
 	return false;
@@ -972,22 +972,22 @@ static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ct
 {
 	bool addr_patched = false;
 	PHYSICAL_ADDRESS_LOC addr;
-	struct core_surface *surface = pipe_ctx->surface;
+	struct dc_surface *surface = pipe_ctx->surface;
 
 	if (surface == NULL)
 		return;
 	addr_patched = patch_address_for_sbs_tb_stereo(pipe_ctx, &addr);
 	pipe_ctx->mi->funcs->mem_input_program_surface_flip_and_addr(
 			pipe_ctx->mi,
-			&surface->public.address,
-			surface->public.flip_immediate);
-	surface->status.requested_address = surface->public.address;
+			&surface->address,
+			surface->flip_immediate);
+	surface->status.requested_address = surface->address;
 	if (addr_patched)
-		pipe_ctx->surface->public.address.grph_stereo.left_addr = addr;
+		pipe_ctx->surface->address.grph_stereo.left_addr = addr;
 }
 
 static bool dcn10_set_input_transfer_func(
-	struct pipe_ctx *pipe_ctx, const struct core_surface *surface)
+	struct pipe_ctx *pipe_ctx, const struct dc_surface *surface)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
 	const struct dc_transfer_func *tf = NULL;
@@ -996,12 +996,12 @@ static bool dcn10_set_input_transfer_func(
 	if (ipp == NULL)
 		return false;
 
-	if (surface->public.in_transfer_func)
-		tf = surface->public.in_transfer_func;
+	if (surface->in_transfer_func)
+		tf = surface->in_transfer_func;
 
-	if (surface->public.gamma_correction && dce_use_lut(surface))
+	if (surface->gamma_correction && dce_use_lut(surface))
 		ipp->funcs->ipp_program_input_lut(ipp,
-				surface->public.gamma_correction);
+				surface->gamma_correction);
 
 	if (tf == NULL)
 		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
@@ -1594,7 +1594,7 @@ static void dcn10_power_on_fe(
 	struct pipe_ctx *pipe_ctx,
 	struct validate_context *context)
 {
-	struct dc_surface *dc_surface = &pipe_ctx->surface->public;
+	struct dc_surface *dc_surface = pipe_ctx->surface;
 	struct dce_hwseq *hws = dc->hwseq;
 
 	power_on_plane(dc->hwseq,
@@ -1710,7 +1710,7 @@ static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
 }
 static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->surface->public.visible)
+	if (pipe_ctx->surface->visible)
 		return true;
 	if (pipe_ctx->bottom_pipe && is_lower_pipe_tree_visible(pipe_ctx->bottom_pipe))
 		return true;
@@ -1719,7 +1719,7 @@ static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 
 static bool is_upper_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->surface->public.visible)
+	if (pipe_ctx->surface->visible)
 		return true;
 	if (pipe_ctx->top_pipe && is_upper_pipe_tree_visible(pipe_ctx->top_pipe))
 		return true;
@@ -1728,7 +1728,7 @@ static bool is_upper_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 
 static bool is_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
-	if (pipe_ctx->surface->public.visible)
+	if (pipe_ctx->surface->visible)
 		return true;
 	if (pipe_ctx->top_pipe && is_upper_pipe_tree_visible(pipe_ctx->top_pipe))
 		return true;
@@ -1803,12 +1803,12 @@ static void update_dchubp_dpp(
 	struct dce_hwseq *hws = dc->hwseq;
 	struct mem_input *mi = pipe_ctx->mi;
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
-	struct core_surface *surface = pipe_ctx->surface;
-	union plane_size size = surface->public.plane_size;
+	struct dc_surface *surface = pipe_ctx->surface;
+	union plane_size size = surface->plane_size;
 	struct default_adjustment ocsc = {0};
 	struct tg_color black_color = {0};
 	struct mpcc_cfg mpcc_cfg;
-	bool per_pixel_alpha = surface->public.per_pixel_alpha && pipe_ctx->bottom_pipe;
+	bool per_pixel_alpha = surface->per_pixel_alpha && pipe_ctx->bottom_pipe;
 
 	/* TODO: proper fix once fpga works */
 	/* depends on DML calculation, DPP clock value may change dynamically */
@@ -1841,12 +1841,12 @@ static void update_dchubp_dpp(
 	if (dc->public.config.gpu_vm_support)
 		mi->funcs->mem_input_program_pte_vm(
 				pipe_ctx->mi,
-				surface->public.format,
-				&surface->public.tiling_info,
-				surface->public.rotation);
+				surface->format,
+				&surface->tiling_info,
+				surface->rotation);
 
 	ipp->funcs->ipp_setup(ipp,
-			surface->public.format,
+			surface->format,
 			1,
 			IPP_OUTPUT_FORMAT_12_BIT_FIX);
 
@@ -1892,12 +1892,12 @@ static void update_dchubp_dpp(
 
 	mi->funcs->mem_input_program_surface_config(
 		mi,
-		surface->public.format,
-		&surface->public.tiling_info,
+		surface->format,
+		&surface->tiling_info,
 		&size,
-		surface->public.rotation,
-		&surface->public.dcc,
-		surface->public.horizontal_mirror);
+		surface->rotation,
+		&surface->dcc,
+		surface->horizontal_mirror);
 
 	mi->funcs->set_blank(mi, !is_pipe_tree_visible(pipe_ctx));
 }
@@ -1978,7 +1978,7 @@ static void dcn10_pplib_apply_display_requirements(
 
 static void dcn10_apply_ctx_for_surface(
 		struct core_dc *dc,
-		struct core_surface *surface,
+		const struct dc_surface *surface,
 		struct validate_context *context)
 {
 	int i, be_idx;
@@ -2337,7 +2337,7 @@ static bool dcn10_dummy_display_power_gating(
 
 void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 {
-	struct core_surface *surface = pipe_ctx->surface;
+	struct dc_surface *surface = pipe_ctx->surface;
 	struct timing_generator *tg = pipe_ctx->tg;
 
 	if (surface->ctx->dc->debug.sanity_checks) {
@@ -2355,7 +2355,7 @@ void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
 
 	/* DCN we read INUSE address in MI, do we still need this wa? */
 	if (surface->status.is_flip_pending &&
-			!surface->public.visible) {
+			!surface->visible) {
 		pipe_ctx->mi->current_address =
 				pipe_ctx->mi->request_address;
 		BREAK_TO_DEBUGGER();

commit 08b1688620426ad3e09fc7a98aabc28dda30cde6
Author: Zeyu Fan <Zeyu.Fan@amd.com>
Date:   Sun Jul 23 18:30:15 2017 -0400

    drm/amd/display: Move DCHUBBUB block from MemInput to HW sequencer.
    
    Signed-off-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d61b63df16b8..b7940876c761 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -218,6 +218,306 @@ static void dpp_pg_control(
 	}
 }
 
+static uint32_t convert_and_clamp(
+	uint32_t wm_ns,
+	uint32_t refclk_mhz,
+	uint32_t clamp_value)
+{
+	uint32_t ret_val = 0;
+	ret_val = wm_ns * refclk_mhz;
+	ret_val /= 1000;
+
+	if (ret_val > clamp_value)
+		ret_val = clamp_value;
+
+	return ret_val;
+}
+
+static void program_watermarks(
+		struct dce_hwseq *hws,
+		struct dcn_watermark_set *watermarks,
+		unsigned int refclk_mhz)
+{
+	uint32_t force_en = hws->ctx->dc->debug.disable_stutter ? 1 : 0;
+	/*
+	 * Need to clamp to max of the register values (i.e. no wrap)
+	 * for dcn1, all wm registers are 21-bit wide
+	 */
+	uint32_t prog_wm_value;
+
+	/* Repeat for water mark set A, B, C and D. */
+	/* clock state A */
+	prog_wm_value = convert_and_clamp(watermarks->a.urgent_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_A, prog_wm_value);
+
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"URGENCY_WATERMARK_A calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->a.urgent_ns, prog_wm_value);
+
+	prog_wm_value = convert_and_clamp(watermarks->a.pte_meta_urgent_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_A, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"PTE_META_URGENCY_WATERMARK_A calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->a.pte_meta_urgent_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->a.cstate_pstate.cstate_enter_plus_exit_ns,
+			refclk_mhz, 0x1fffff);
+
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"SR_ENTER_EXIT_WATERMARK_A calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->a.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->a.cstate_pstate.cstate_exit_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_A, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"SR_EXIT_WATERMARK_A calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->a.cstate_pstate.cstate_exit_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->a.cstate_pstate.pstate_change_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_A, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"DRAM_CLK_CHANGE_WATERMARK_A calculated =%d\n"
+		"HW register value = 0x%x\n\n",
+		watermarks->a.cstate_pstate.pstate_change_ns, prog_wm_value);
+
+
+	/* clock state B */
+	prog_wm_value = convert_and_clamp(
+			watermarks->b.urgent_ns, refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_B, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"URGENCY_WATERMARK_B calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->b.urgent_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->b.pte_meta_urgent_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_B, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"PTE_META_URGENCY_WATERMARK_B calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->b.pte_meta_urgent_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->b.cstate_pstate.cstate_enter_plus_exit_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"SR_ENTER_WATERMARK_B calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->b.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->b.cstate_pstate.cstate_exit_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_B, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"SR_EXIT_WATERMARK_B calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->b.cstate_pstate.cstate_exit_ns, prog_wm_value);
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->b.cstate_pstate.pstate_change_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_B, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"DRAM_CLK_CHANGE_WATERMARK_B calculated =%d\n\n"
+		"HW register value = 0x%x\n",
+		watermarks->b.cstate_pstate.pstate_change_ns, prog_wm_value);
+
+	/* clock state C */
+	prog_wm_value = convert_and_clamp(
+			watermarks->c.urgent_ns, refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_C, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"URGENCY_WATERMARK_C calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->c.urgent_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->c.pte_meta_urgent_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_C, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"PTE_META_URGENCY_WATERMARK_C calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->c.pte_meta_urgent_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->c.cstate_pstate.cstate_enter_plus_exit_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"SR_ENTER_WATERMARK_C calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->c.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->c.cstate_pstate.cstate_exit_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_C, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"SR_EXIT_WATERMARK_C calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->c.cstate_pstate.cstate_exit_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->c.cstate_pstate.pstate_change_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_C, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"DRAM_CLK_CHANGE_WATERMARK_C calculated =%d\n\n"
+		"HW register value = 0x%x\n",
+		watermarks->c.cstate_pstate.pstate_change_ns, prog_wm_value);
+
+	/* clock state D */
+	prog_wm_value = convert_and_clamp(
+			watermarks->d.urgent_ns, refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_D, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"URGENCY_WATERMARK_D calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->d.urgent_ns, prog_wm_value);
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->d.pte_meta_urgent_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_D, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"PTE_META_URGENCY_WATERMARK_D calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->d.pte_meta_urgent_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->d.cstate_pstate.cstate_enter_plus_exit_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"SR_ENTER_WATERMARK_D calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->d.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->d.cstate_pstate.cstate_exit_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_D, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"SR_EXIT_WATERMARK_D calculated =%d\n"
+		"HW register value = 0x%x\n",
+		watermarks->d.cstate_pstate.cstate_exit_ns, prog_wm_value);
+
+
+	prog_wm_value = convert_and_clamp(
+			watermarks->d.cstate_pstate.pstate_change_ns,
+			refclk_mhz, 0x1fffff);
+	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_D, prog_wm_value);
+	dm_logger_write(hws->ctx->logger, LOG_HW_MARKS,
+		"DRAM_CLK_CHANGE_WATERMARK_D calculated =%d\n"
+		"HW register value = 0x%x\n\n",
+		watermarks->d.cstate_pstate.pstate_change_ns, prog_wm_value);
+
+	REG_UPDATE(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,
+			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, 1);
+	REG_UPDATE(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,
+			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, 0);
+	REG_UPDATE(DCHUBBUB_ARB_SAT_LEVEL,
+			DCHUBBUB_ARB_SAT_LEVEL, 60 * refclk_mhz);
+	REG_UPDATE(DCHUBBUB_ARB_DF_REQ_OUTSTAND,
+			DCHUBBUB_ARB_MIN_REQ_OUTSTAND, 68);
+
+	REG_UPDATE_2(DCHUBBUB_ARB_DRAM_STATE_CNTL,
+			DCHUBBUB_ARB_ALLOW_SELF_REFRESH_FORCE_VALUE, 0,
+			DCHUBBUB_ARB_ALLOW_SELF_REFRESH_FORCE_ENABLE, force_en);
+
+#if 0
+	REG_UPDATE_2(DCHUBBUB_ARB_WATERMARK_CHANGE_CNTL,
+			DCHUBBUB_ARB_WATERMARK_CHANGE_DONE_INTERRUPT_DISABLE, 1,
+			DCHUBBUB_ARB_WATERMARK_CHANGE_REQUEST, 1);
+#endif
+}
+
+
+static void dcn10_update_dchub(
+	struct dce_hwseq *hws,
+	struct dchub_init_data *dh_data)
+{
+	/* TODO: port code from dal2 */
+	switch (dh_data->fb_mode) {
+	case FRAME_BUFFER_MODE_ZFB_ONLY:
+		/*For ZFB case need to put DCHUB FB BASE and TOP upside down to indicate ZFB mode*/
+		REG_UPDATE(DCHUBBUB_SDPIF_FB_TOP,
+				SDPIF_FB_TOP, 0);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_FB_BASE,
+				SDPIF_FB_BASE, 0x0FFFF);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,
+				SDPIF_AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,
+				SDPIF_AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,
+				SDPIF_AGP_TOP, (dh_data->zfb_mc_base_addr +
+						dh_data->zfb_size_in_byte - 1) >> 22);
+		break;
+	case FRAME_BUFFER_MODE_MIXED_ZFB_AND_LOCAL:
+		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,
+				SDPIF_AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,
+				SDPIF_AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,
+				SDPIF_AGP_TOP, (dh_data->zfb_mc_base_addr +
+						dh_data->zfb_size_in_byte - 1) >> 22);
+		break;
+	case FRAME_BUFFER_MODE_LOCAL_ONLY:
+		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BASE,
+				SDPIF_AGP_BASE, 0);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_BOT,
+				SDPIF_AGP_BOT, 0X03FFFF);
+
+		REG_UPDATE(DCHUBBUB_SDPIF_AGP_TOP,
+				SDPIF_AGP_TOP, 0);
+		break;
+	default:
+		break;
+	}
+
+	dh_data->dchub_initialzied = true;
+	dh_data->dchub_info_valid = false;
+}
+
 static void hubp_pg_control(
 		struct dce_hwseq *hws,
 		unsigned int hubp_inst,
@@ -1615,8 +1915,7 @@ static void program_all_pipe_in_tree(
 		 * this OTG. this is done only one time.
 		 */
 		/* watermark is for all pipes */
-		pipe_ctx->mi->funcs->program_watermarks(
-				pipe_ctx->mi, &context->bw.dcn.watermarks, ref_clk_mhz);
+		program_watermarks(dc->hwseq, &context->bw.dcn.watermarks, ref_clk_mhz);
 
 		if (dc->public.debug.sanity_checks) {
 			/* pstate stuck check after watermark update */
@@ -2078,6 +2377,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.apply_ctx_for_surface = dcn10_apply_ctx_for_surface,
 	.set_plane_config = set_plane_config,
 	.update_plane_addr = update_plane_addr,
+	.update_dchub = dcn10_update_dchub,
 	.update_pending_status = dcn10_update_pending_status,
 	.set_input_transfer_func = dcn10_set_input_transfer_func,
 	.set_output_transfer_func = dcn10_set_output_transfer_func,

commit c8d7bd8bd0c08aa9115589d264e274ed7fdf4c2e
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Sun Jul 23 12:13:37 2017 -0400

    drm/amd/display: move RGAM programming from opp to dpp
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 4cbca15e1cc5..d61b63df16b8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1054,25 +1054,25 @@ static bool dcn10_set_output_transfer_func(
 	struct pipe_ctx *pipe_ctx,
 	const struct core_stream *stream)
 {
-	struct output_pixel_processor *opp = pipe_ctx->opp;
+	struct transform *xfm = pipe_ctx->xfm;
 
-	if (opp == NULL)
+	if (xfm == NULL)
 		return false;
 
-	opp->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
+	xfm->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
 
 	if (stream->public.out_transfer_func &&
 		stream->public.out_transfer_func->type ==
 			TF_TYPE_PREDEFINED &&
 		stream->public.out_transfer_func->tf ==
 			TRANSFER_FUNCTION_SRGB) {
-		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_SRGB);
+		xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_SRGB);
 	} else if (dcn10_translate_regamma_to_hw_format(
-				stream->public.out_transfer_func, &opp->regamma_params)) {
-			opp->funcs->opp_program_regamma_pwl(opp, &opp->regamma_params);
-			opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_USER);
+				stream->public.out_transfer_func, &xfm->regamma_params)) {
+			xfm->funcs->opp_program_regamma_pwl(xfm, &xfm->regamma_params);
+			xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_USER);
 	} else {
-		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_BYPASS);
+		xfm->funcs->opp_set_regamma_mode(xfm, OPP_REGAMMA_BYPASS);
 	}
 
 	return true;

commit 7db90a6b58761577596499ddd90f3c5ace2b716d
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Sat Jul 22 21:58:08 2017 -0400

    drm/amd/display: move ocsc programming from opp to dpp
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Yuehin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 633d858caf6f..4cbca15e1cc5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1588,7 +1588,7 @@ static void update_dchubp_dpp(
 
 	/*TODO add adjustments parameters*/
 	ocsc.out_color_space = pipe_ctx->stream->public.output_color_space;
-	pipe_ctx->opp->funcs->opp_set_csc_default(pipe_ctx->opp, &ocsc);
+	pipe_ctx->xfm->funcs->opp_set_csc_default(pipe_ctx->xfm, &ocsc);
 
 	mi->funcs->mem_input_program_surface_config(
 		mi,

commit 8748068764e7a50ac787c1c17f402f3fbbe97ccc
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Sun Jul 23 15:18:57 2017 -0400

    drm/amd/display: add idle wait for passive surface update and modeset
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 64f2fd0d539e..633d858caf6f 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1739,6 +1739,7 @@ static void dcn10_apply_ctx_for_surface(
 			mpcc_cfg.bot_mpcc_id = 0xf;
 			mpcc_cfg.top_of_tree = !old_pipe_ctx->top_pipe;
 			old_pipe_ctx->mpcc->funcs->set(old_pipe_ctx->mpcc, &mpcc_cfg);
+			old_pipe_ctx->top_pipe->opp->mpcc_disconnect_pending[old_pipe_ctx->mpcc->inst] = true;
 
 			if (dc->public.debug.sanity_checks)
 				verify_allow_pstate_change_high(dc->hwseq);
@@ -2012,6 +2013,20 @@ static void dcn10_log_hw_state(struct core_dc *dc)
 	 */
 }
 
+static void dcn10_wait_for_mpcc_disconnect(struct resource_pool *res_pool, struct pipe_ctx *pipe_ctx)
+{
+	int i;
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (!pipe_ctx->opp || !pipe_ctx->mpcc)
+			continue;
+
+		if (pipe_ctx->opp->mpcc_disconnect_pending[i]) {
+			pipe_ctx->mpcc->funcs->wait_for_idle(res_pool->mpcc[i]);
+			pipe_ctx->opp->mpcc_disconnect_pending[i] = false;
+		}
+	}
+}
+
 static bool dcn10_dummy_display_power_gating(
 	struct core_dc *dc,
 	uint8_t controller_id,
@@ -2085,7 +2100,8 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.set_static_screen_control = set_static_screen_control,
 	.setup_stereo = dcn10_setup_stereo,
 	.set_avmute = dce110_set_avmute,
-	.log_hw_state = dcn10_log_hw_state
+	.log_hw_state = dcn10_log_hw_state,
+	.wait_for_mpcc_disconnect = dcn10_wait_for_mpcc_disconnect
 };
 
 

commit 0a87425a37b4c1f06d75949ea39e60455a2b0a4f
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Wed Jul 12 22:35:52 2017 -0400

    drm/amd/display: move VGA to HWSS from TG
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index ce7da8864507..64f2fd0d539e 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -163,6 +163,15 @@ static void enable_power_gating_plane(
 	REG_UPDATE(DOMAIN7_PG_CONFIG, DOMAIN7_POWER_FORCEON, force_on);
 }
 
+static void disable_vga(
+	struct dce_hwseq *hws)
+{
+	REG_WRITE(D1VGA_CONTROL, 0);
+	REG_WRITE(D2VGA_CONTROL, 0);
+	REG_WRITE(D3VGA_CONTROL, 0);
+	REG_WRITE(D4VGA_CONTROL, 0);
+}
+
 static void dpp_pg_control(
 		struct dce_hwseq *hws,
 		unsigned int dpp_inst,
@@ -312,6 +321,8 @@ static void dcn10_init_hw(struct core_dc *dc)
 
 	bios_golden_init(dc);
 
+	disable_vga(dc->hwseq);
+
 	for (i = 0; i < dc->link_count; i++) {
 		/* Power up AND update implementation according to the
 		 * required signal (which may be different from the
@@ -335,7 +346,6 @@ static void dcn10_init_hw(struct core_dc *dc)
 		mpcc_cfg.top_of_tree = true;
 		mpcc->funcs->set(mpcc, &mpcc_cfg);
 
-		tg->funcs->disable_vga(tg);
 		/* Blank controller using driver code instead of
 		 * command table.
 		 */

commit 516666318fe1f427ab81e2ebe45d116a9667c3b5
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jul 21 17:35:16 2017 -0400

    drm/amd/display: support for updated register headers on DCN
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 6db78d9f8e3b..ce7da8864507 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -550,7 +550,9 @@ static void reset_front_end(
 	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
-	REG_WAIT(OTG_GLOBAL_SYNC_STATUS[tg->inst], VUPDATE_NO_LOCK_EVENT_OCCURRED, 1, 20000, 200000);
+	if (tg->ctx->dce_environment != DCE_ENV_FPGA_MAXIMUS)
+		REG_WAIT(OTG_GLOBAL_SYNC_STATUS[tg->inst],
+				VUPDATE_NO_LOCK_EVENT_OCCURRED, 1, 20000, 200000);
 
 	mpcc->funcs->wait_for_idle(mpcc);
 
@@ -1295,6 +1297,7 @@ static void dcn10_power_on_fe(
 	/* make sure OPP_PIPE_CLOCK_EN = 1 */
 	REG_UPDATE(OPP_PIPE_CONTROL[pipe_ctx->tg->inst],
 			OPP_PIPE_CLOCK_EN, 1);
+	/*TODO: REG_UPDATE(DENTIST_DISPCLK_CNTL, DENTIST_DPPCLK_WDIVIDER, 0x1f);*/
 
 	if (dc_surface) {
 		dm_logger_write(dc->ctx->logger, LOG_DC,
@@ -1984,9 +1987,16 @@ static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct core_dc *dc)
 static void dcn10_log_hw_state(struct core_dc *dc)
 {
 	struct dc_context *dc_ctx = dc->ctx;
+	struct dce_hwseq *hws = dc->hwseq;
 
 	DTN_INFO("%s: Hello World", __func__);
 
+	if (REG(MPC_CRC_RESULT_GB))
+		DTN_INFO("MPC_CRC_RESULT_GB:%d MPC_CRC_RESULT_C:%d MPC_CRC_RESULT_AR:%d\n",
+		REG_READ(MPC_CRC_RESULT_GB), REG_READ(MPC_CRC_RESULT_C), REG_READ(MPC_CRC_RESULT_AR));
+	if (REG(DPP_TOP0_DPP_CRC_VAL_B_A))
+		DTN_INFO("DPP_TOP0_DPP_CRC_VAL_B_A:%d DPP_TOP0_DPP_CRC_VAL_R_G:%d\n",
+		REG_READ(DPP_TOP0_DPP_CRC_VAL_B_A), REG_READ(DPP_TOP0_DPP_CRC_VAL_R_G));
 	/* todo: add meaningful register reads and print out HW state
 	 *
 	 */
@@ -2065,7 +2075,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.set_static_screen_control = set_static_screen_control,
 	.setup_stereo = dcn10_setup_stereo,
 	.set_avmute = dce110_set_avmute,
-	.log_hw_state = dcn10_log_hw_state,
+	.log_hw_state = dcn10_log_hw_state
 };
 
 

commit aa9850705fc05b7e7f44558e30705ac54579e724
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Thu Jul 20 16:17:17 2017 -0400

    drm/amd/display: fix locking in apply_ctx_for_surface
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d607ca94bd13..6db78d9f8e3b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1696,8 +1696,14 @@ static void dcn10_apply_ctx_for_surface(
 		 */
 
 		if (pipe_ctx->surface && !old_pipe_ctx->surface) {
-			if (pipe_ctx->mpcc->opp_id != 0xf && pipe_ctx->tg->inst == be_idx)
+			if (pipe_ctx->mpcc->opp_id != 0xf && pipe_ctx->tg->inst == be_idx) {
 				dcn10_power_down_fe(dc, pipe_ctx->pipe_idx);
+				/*
+				 * power down fe will unlock when calling reset, need
+				 * to lock it back here. Messy, need rework.
+				 */
+				pipe_ctx->tg->funcs->lock(pipe_ctx->tg);
+			}
 		}
 
 

commit 7f10f3c2a761ddf3dc18be45d4ccf60db5fe10cf
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Wed Jul 19 20:22:22 2017 -0400

    drm/amd/display: mpcc disconnect and pipe pg in multi-display
    
    still quite hacky.  but this address not properly shutdown pipe video underlay
    + enable another display case, as well as mode changes with video overlay.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index b5a925362c8c..d607ca94bd13 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1669,30 +1669,46 @@ static void dcn10_apply_ctx_for_surface(
 		struct core_surface *surface,
 		struct validate_context *context)
 {
-	int i;
+	int i, be_idx;
 
 	if (dc->public.debug.sanity_checks)
 		verify_allow_pstate_change_high(dc->hwseq);
 
+	if (!surface)
+		return;
+
+	for (be_idx = 0; be_idx < dc->res_pool->pipe_count; be_idx++)
+		if (surface == context->res_ctx.pipe_ctx[be_idx].surface)
+			break;
+
 	/* reset unused mpcc */
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *old_pipe_ctx =
 				&dc->current_context->res_ctx.pipe_ctx[i];
+
+		if (!pipe_ctx->surface && !old_pipe_ctx->surface)
+			continue;
+
 		/*
 		 * Powergate reused pipes that are not powergated
 		 * fairly hacky right now, using opp_id as indicator
 		 */
+
 		if (pipe_ctx->surface && !old_pipe_ctx->surface) {
-			if (pipe_ctx->mpcc->opp_id != 0xf)
+			if (pipe_ctx->mpcc->opp_id != 0xf && pipe_ctx->tg->inst == be_idx)
 				dcn10_power_down_fe(dc, pipe_ctx->pipe_idx);
 		}
 
+
 		if ((!pipe_ctx->surface && old_pipe_ctx->surface)
 				|| (!pipe_ctx->stream && old_pipe_ctx->stream)) {
 			struct mpcc_cfg mpcc_cfg;
 			int opp_id_cached = old_pipe_ctx->mpcc->opp_id;
 
+			if (old_pipe_ctx->tg->inst != be_idx)
+				continue;
+
 			if (!old_pipe_ctx->top_pipe) {
 				ASSERT(0);
 				continue;
@@ -1725,9 +1741,6 @@ static void dcn10_apply_ctx_for_surface(
 		}
 	}
 
-	if (!surface)
-		return;
-
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 

commit 2b13d7d380d50811fd4fc022d135c3c5bb70a418
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Fri Jul 14 14:07:16 2017 -0400

    drm/amd/display: mpo debug sanity checks
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index c0aa32b71ad1..b5a925362c8c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -52,6 +52,75 @@
 #define FN(reg_name, field_name) \
 	hws->shifts->field_name, hws->masks->field_name
 
+
+static void verify_allow_pstate_change_high(
+	struct dce_hwseq *hws)
+{
+	/* pstate latency is ~20us so if we wait over 40us and pstate allow
+	 * still not asserted, we are probably stuck and going to hang
+	 */
+	static unsigned int pstate_wait_timeout_us = 40;
+	static unsigned int max_sampled_pstate_wait_us; /* data collection */
+	static bool forced_pstate_allow; /* help with revert wa */
+
+	unsigned int debug_index = 0x7;
+	unsigned int debug_data;
+	unsigned int force_allow_pstate = 0x30;
+	unsigned int i;
+
+	if (forced_pstate_allow) {
+		/* we hacked to force pstate allow to prevent hang last time
+		 * we verify_allow_pstate_change_high.  so disable force
+		 * here so we can check status
+		 */
+		REG_WRITE(DCHUBBUB_ARB_DRAM_STATE_CNTL, 0);
+		forced_pstate_allow = false;
+	}
+
+	/* description "3-0:   Pipe0 cursor0 QOS
+	 * 7-4:   Pipe1 cursor0 QOS
+	 * 11-8:  Pipe2 cursor0 QOS
+	 * 15-12: Pipe3 cursor0 QOS
+	 * 16:    Pipe0 Plane0 Allow Pstate Change
+	 * 17:    Pipe1 Plane0 Allow Pstate Change
+	 * 18:    Pipe2 Plane0 Allow Pstate Change
+	 * 19:    Pipe3 Plane0 Allow Pstate Change
+	 * 20:    Pipe0 Plane1 Allow Pstate Change
+	 * 21:    Pipe1 Plane1 Allow Pstate Change
+	 * 22:    Pipe2 Plane1 Allow Pstate Change
+	 * 23:    Pipe3 Plane1 Allow Pstate Change
+	 * 24:    Pipe0 cursor0 Allow Pstate Change
+	 * 25:    Pipe1 cursor0 Allow Pstate Change
+	 * 26:    Pipe2 cursor0 Allow Pstate Change
+	 * 27:    Pipe3 cursor0 Allow Pstate Change
+	 * 28:    WB0 Allow Pstate Change
+	 * 29:    WB1 Allow Pstate Change
+	 * 30:    Arbiter's allow_pstate_change
+	 * 31:    SOC pstate change request
+	 */
+
+	REG_WRITE(DCHUBBUB_TEST_DEBUG_INDEX, debug_index);
+
+	for (i = 0; i < pstate_wait_timeout_us; i++) {
+		debug_data = REG_READ(DCHUBBUB_TEST_DEBUG_DATA);
+
+		if (debug_data & (1 << 30))
+			return;
+
+		if (max_sampled_pstate_wait_us < i)
+			max_sampled_pstate_wait_us = i;
+
+		udelay(1);
+	}
+
+	/* force pstate allow to prevent system hang
+	 * and break to debugger to investigate
+	 */
+	REG_WRITE(DCHUBBUB_ARB_DRAM_STATE_CNTL, force_allow_pstate);
+	forced_pstate_allow = true;
+	BREAK_TO_DEBUGGER();
+}
+
 static void enable_dppclk(
 	struct dce_hwseq *hws,
 	uint8_t plane_id,
@@ -477,12 +546,19 @@ static void reset_front_end(
 
 	REG_UPDATE(OTG_GLOBAL_SYNC_STATUS[tg->inst], VUPDATE_NO_LOCK_EVENT_CLEAR, 1);
 	tg->funcs->unlock(tg);
+
+	if (dc->public.debug.sanity_checks)
+		verify_allow_pstate_change_high(dc->hwseq);
+
 	REG_WAIT(OTG_GLOBAL_SYNC_STATUS[tg->inst], VUPDATE_NO_LOCK_EVENT_OCCURRED, 1, 20000, 200000);
 
 	mpcc->funcs->wait_for_idle(mpcc);
 
 	mi->funcs->set_blank(mi, true);
 
+	if (dc->public.debug.sanity_checks)
+		verify_allow_pstate_change_high(dc->hwseq);
+
 	REG_UPDATE(HUBP_CLK_CNTL[fe_idx],
 			HUBP_CLOCK_ENABLE, 0);
 	REG_UPDATE(DPP_CONTROL[fe_idx],
@@ -495,6 +571,9 @@ static void reset_front_end(
 	dm_logger_write(dc->ctx->logger, LOG_DC,
 					"Reset front end %d\n",
 					fe_idx);
+
+	if (dc->public.debug.sanity_checks)
+		verify_allow_pstate_change_high(dc->hwseq);
 }
 
 static void dcn10_power_down_fe(struct core_dc *dc, int fe_idx)
@@ -511,6 +590,9 @@ static void dcn10_power_down_fe(struct core_dc *dc, int fe_idx)
 			IP_REQUEST_EN, 0);
 	dm_logger_write(dc->ctx->logger, LOG_DC,
 			"Power gated front end %d\n", fe_idx);
+
+	if (dc->public.debug.sanity_checks)
+		verify_allow_pstate_change_high(dc->hwseq);
 }
 
 static void reset_hw_ctx_wrap(
@@ -995,10 +1077,16 @@ static void dcn10_pipe_control_lock(
 	if (pipe->top_pipe)
 		return;
 
+	if (dc->public.debug.sanity_checks)
+		verify_allow_pstate_change_high(dc->hwseq);
+
 	if (lock)
 		pipe->tg->funcs->lock(pipe->tg);
 	else
 		pipe->tg->funcs->unlock(pipe->tg);
+
+	if (dc->public.debug.sanity_checks)
+		verify_allow_pstate_change_high(dc->hwseq);
 }
 
 static bool wait_for_reset_trigger_to_occur(
@@ -1516,6 +1604,12 @@ static void program_all_pipe_in_tree(
 		/* watermark is for all pipes */
 		pipe_ctx->mi->funcs->program_watermarks(
 				pipe_ctx->mi, &context->bw.dcn.watermarks, ref_clk_mhz);
+
+		if (dc->public.debug.sanity_checks) {
+			/* pstate stuck check after watermark update */
+			verify_allow_pstate_change_high(dc->hwseq);
+		}
+
 		pipe_ctx->tg->funcs->lock(pipe_ctx->tg);
 
 		pipe_ctx->tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
@@ -1534,6 +1628,11 @@ static void program_all_pipe_in_tree(
 		update_dchubp_dpp(dc, pipe_ctx, context);
 	}
 
+	if (dc->public.debug.sanity_checks) {
+		/* pstate stuck check after each pipe is programmed */
+		verify_allow_pstate_change_high(dc->hwseq);
+	}
+
 	if (pipe_ctx->bottom_pipe != NULL)
 		program_all_pipe_in_tree(dc, pipe_ctx->bottom_pipe, context);
 }
@@ -1572,6 +1671,9 @@ static void dcn10_apply_ctx_for_surface(
 {
 	int i;
 
+	if (dc->public.debug.sanity_checks)
+		verify_allow_pstate_change_high(dc->hwseq);
+
 	/* reset unused mpcc */
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
@@ -1602,6 +1704,10 @@ static void dcn10_apply_ctx_for_surface(
 			mpcc_cfg.bot_mpcc_id = 0xf;
 			mpcc_cfg.top_of_tree = !old_pipe_ctx->top_pipe;
 			old_pipe_ctx->mpcc->funcs->set(old_pipe_ctx->mpcc, &mpcc_cfg);
+
+			if (dc->public.debug.sanity_checks)
+				verify_allow_pstate_change_high(dc->hwseq);
+
 			/*
 			 * the mpcc is the only thing that keeps track of the mpcc
 			 * mapping for reset front end right now. Might need some
@@ -1679,6 +1785,9 @@ static void dcn10_apply_ctx_for_surface(
 			context->bw.dcn.watermarks.d.cstate_pstate.pstate_change_ns,
 			context->bw.dcn.watermarks.d.pte_meta_urgent_ns
 			);
+
+	if (dc->public.debug.sanity_checks)
+		verify_allow_pstate_change_high(dc->hwseq);
 }
 
 static void dcn10_set_bandwidth(
@@ -1738,6 +1847,8 @@ static void dcn10_set_bandwidth(
 				context->bw.dcn.calc_clk.min_active_dram_ccm_us;
 	}
 	dcn10_pplib_apply_display_requirements(dc, context);
+
+	/* need to fix this function.  not doing the right thing here */
 }
 
 static void set_drr(struct pipe_ctx **pipe_ctx,
@@ -1866,7 +1977,44 @@ static bool dcn10_dummy_display_power_gating(
 	struct core_dc *dc,
 	uint8_t controller_id,
 	struct dc_bios *dcb,
-	enum pipe_gating_control power_gating) {return true; }
+	enum pipe_gating_control power_gating)
+{
+	return true;
+}
+
+void dcn10_update_pending_status(struct pipe_ctx *pipe_ctx)
+{
+	struct core_surface *surface = pipe_ctx->surface;
+	struct timing_generator *tg = pipe_ctx->tg;
+
+	if (surface->ctx->dc->debug.sanity_checks) {
+		struct core_dc *dc = DC_TO_CORE(surface->ctx->dc);
+
+		verify_allow_pstate_change_high(dc->hwseq);
+	}
+
+	if (surface == NULL)
+		return;
+
+	surface->status.is_flip_pending =
+			pipe_ctx->mi->funcs->mem_input_is_flip_pending(
+					pipe_ctx->mi);
+
+	/* DCN we read INUSE address in MI, do we still need this wa? */
+	if (surface->status.is_flip_pending &&
+			!surface->public.visible) {
+		pipe_ctx->mi->current_address =
+				pipe_ctx->mi->request_address;
+		BREAK_TO_DEBUGGER();
+	}
+
+	surface->status.current_address = pipe_ctx->mi->current_address;
+	if (pipe_ctx->mi->current_address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
+			tg->funcs->is_stereo_left_eye) {
+		surface->status.is_right_eye =
+				!tg->funcs->is_stereo_left_eye(pipe_ctx->tg);
+	}
+}
 
 static const struct hw_sequencer_funcs dcn10_funcs = {
 	.program_gamut_remap = program_gamut_remap,
@@ -1876,7 +2024,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.apply_ctx_for_surface = dcn10_apply_ctx_for_surface,
 	.set_plane_config = set_plane_config,
 	.update_plane_addr = update_plane_addr,
-	.update_pending_status = dce110_update_pending_status,
+	.update_pending_status = dcn10_update_pending_status,
 	.set_input_transfer_func = dcn10_set_input_transfer_func,
 	.set_output_transfer_func = dcn10_set_output_transfer_func,
 	.power_down = dce110_power_down,

commit 6d244be884d20b1e9c912291a242dccedd6d9040
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Thu Jul 20 00:12:20 2017 -0400

    drm/amd/display: plumbing to allow easy print of HW state for DTN
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 6543027469af..c0aa32b71ad1 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1851,6 +1851,17 @@ static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct core_dc *dc)
 	return;
 }
 
+static void dcn10_log_hw_state(struct core_dc *dc)
+{
+	struct dc_context *dc_ctx = dc->ctx;
+
+	DTN_INFO("%s: Hello World", __func__);
+
+	/* todo: add meaningful register reads and print out HW state
+	 *
+	 */
+}
+
 static bool dcn10_dummy_display_power_gating(
 	struct core_dc *dc,
 	uint8_t controller_id,
@@ -1887,6 +1898,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.set_static_screen_control = set_static_screen_control,
 	.setup_stereo = dcn10_setup_stereo,
 	.set_avmute = dce110_set_avmute,
+	.log_hw_state = dcn10_log_hw_state,
 };
 
 

commit 4bdbab3efda297b2432ae4e722385deaa0089315
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Tue Jul 18 15:50:47 2017 -0400

    drm/amd/display: powergate fe of reused pipes to reset ttu
    
    When we exit MPO, disconnected pipes cannot be immediately powergated
    because registers are double buffered, and actual disconnection does
    not happen until VUPDATE. So it is differred for many flips.
    However in the case of exiting full screen, the transition from MPO
    to grph only back to MPO is very fast and also involves increasing of
    watermarks. Since the underlay pipe is never powergated in this
    scenario, it keeps its old TTU counter, which causes allowPstateSwitch
    signal to be de-asserted when compared to the new increased watermark.
    Since the new pipe is not enabled yet, the signal will be continously
    de-asserted and hangs SMU, who's waiting for the signal to do pstate
    switching.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index adf3d2990687..6543027469af 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1577,6 +1577,14 @@ static void dcn10_apply_ctx_for_surface(
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *old_pipe_ctx =
 				&dc->current_context->res_ctx.pipe_ctx[i];
+		/*
+		 * Powergate reused pipes that are not powergated
+		 * fairly hacky right now, using opp_id as indicator
+		 */
+		if (pipe_ctx->surface && !old_pipe_ctx->surface) {
+			if (pipe_ctx->mpcc->opp_id != 0xf)
+				dcn10_power_down_fe(dc, pipe_ctx->pipe_idx);
+		}
 
 		if ((!pipe_ctx->surface && old_pipe_ctx->surface)
 				|| (!pipe_ctx->stream && old_pipe_ctx->stream)) {
@@ -1588,6 +1596,7 @@ static void dcn10_apply_ctx_for_surface(
 				continue;
 			}
 
+			/* reset mpc */
 			mpcc_cfg.opp_id = 0xf;
 			mpcc_cfg.top_dpp_id = 0xf;
 			mpcc_cfg.bot_mpcc_id = 0xf;

commit d65359d571aa33dee9ddae659e92d1cb09ffbb2a
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Fri Jul 14 13:42:23 2017 -0400

    drm/amd/display: revert order change of HUBP and MPC disable
    
    - root cause was we disable opp clk in MPC disconnect
    - hubp_blank is not double buffered, so we can't blank until MPC disconnect or we have risk of underflow
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 8284837898d2..adf3d2990687 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -436,29 +436,17 @@ static void reset_back_end_for_pipe(
 					pipe_ctx->pipe_idx, pipe_ctx->tg->inst);
 }
 
-static void reset_front_end(
+static void plane_atomic_stop(
 		struct core_dc *dc,
 		int fe_idx)
 {
-	struct dce_hwseq *hws = dc->hwseq;
 	struct mpcc_cfg mpcc_cfg;
 	struct mem_input *mi = dc->res_pool->mis[fe_idx];
 	struct transform *xfm = dc->res_pool->transforms[fe_idx];
 	struct mpcc *mpcc = dc->res_pool->mpcc[fe_idx];
 	struct timing_generator *tg = dc->res_pool->timing_generators[mpcc->opp_id];
-	unsigned int opp_id = mpcc->opp_id;
-
-	/*Already reset*/
-	if (opp_id == 0xf)
-		return;
-
-	tg->funcs->lock(tg);
 
 	mi->funcs->dcc_control(mi, false, false);
-	mi->funcs->set_blank(mi, true);
-	REG_WAIT(DCHUBP_CNTL[fe_idx],
-			HUBP_NO_OUTSTANDING_REQ, 1,
-			1, 200);
 
 	mpcc_cfg.opp_id = 0xf;
 	mpcc_cfg.top_dpp_id = 0xf;
@@ -466,23 +454,44 @@ static void reset_front_end(
 	mpcc_cfg.top_of_tree = tg->inst == mpcc->inst;
 	mpcc->funcs->set(mpcc, &mpcc_cfg);
 
+	xfm->funcs->transform_reset(xfm);
+}
+
+static void reset_front_end(
+		struct core_dc *dc,
+		int fe_idx)
+{
+	struct dce_hwseq *hws = dc->hwseq;
+	struct mem_input *mi = dc->res_pool->mis[fe_idx];
+	struct mpcc *mpcc = dc->res_pool->mpcc[fe_idx];
+	struct timing_generator *tg = dc->res_pool->timing_generators[mpcc->opp_id];
+	unsigned int opp_id = mpcc->opp_id;
+
+	/*Already reset*/
+	if (opp_id == 0xf)
+		return;
+
+	tg->funcs->lock(tg);
+
+	plane_atomic_stop(dc, fe_idx);
+
 	REG_UPDATE(OTG_GLOBAL_SYNC_STATUS[tg->inst], VUPDATE_NO_LOCK_EVENT_CLEAR, 1);
 	tg->funcs->unlock(tg);
 	REG_WAIT(OTG_GLOBAL_SYNC_STATUS[tg->inst], VUPDATE_NO_LOCK_EVENT_OCCURRED, 1, 20000, 200000);
 
 	mpcc->funcs->wait_for_idle(mpcc);
 
+	mi->funcs->set_blank(mi, true);
+
 	REG_UPDATE(HUBP_CLK_CNTL[fe_idx],
 			HUBP_CLOCK_ENABLE, 0);
 	REG_UPDATE(DPP_CONTROL[fe_idx],
 			DPP_CLOCK_ENABLE, 0);
 
-	if (mpcc_cfg.top_of_tree)
+	if (tg->inst == mpcc->inst)
 		REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
 				OPP_PIPE_CLOCK_EN, 0);
 
-	xfm->funcs->transform_reset(xfm);
-
 	dm_logger_write(dc->ctx->logger, LOG_DC,
 					"Reset front end %d\n",
 					fe_idx);

commit 15e173352eeae76286e0d018f9eec6b55726caa4
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Jul 17 16:04:02 2017 -0400

    drm/amd/display: fix aviInfoFrame bar Info and add set_avMute
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index cadc940e7c0e..8284837898d2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1867,7 +1867,8 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.set_drr = set_drr,
 	.get_position = get_position,
 	.set_static_screen_control = set_static_screen_control,
-	.setup_stereo = dcn10_setup_stereo
+	.setup_stereo = dcn10_setup_stereo,
+	.set_avmute = dce110_set_avmute,
 };
 
 

commit 1674d35bf57b0546577b87af266e45de3ccf45c0
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Mon Jul 17 10:22:05 2017 -0400

    drm/amd/display: properly turn off unused mpc before front end programming
    
    MPCC_OPP_ID must be programmed to 0xf to properly turn off the mpcc.
    However the software state of the mpcc must keep track of the opp that
    the mpcc is attached to for reset to properly happen. This is kinda
    hacky right now, but a good solution may involve a lot of work.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d714422ef979..cadc940e7c0e 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1572,17 +1572,24 @@ static void dcn10_apply_ctx_for_surface(
 		if ((!pipe_ctx->surface && old_pipe_ctx->surface)
 				|| (!pipe_ctx->stream && old_pipe_ctx->stream)) {
 			struct mpcc_cfg mpcc_cfg;
+			int opp_id_cached = old_pipe_ctx->mpcc->opp_id;
 
 			if (!old_pipe_ctx->top_pipe) {
 				ASSERT(0);
 				continue;
 			}
 
-			mpcc_cfg.opp_id = old_pipe_ctx->mpcc->opp_id;
+			mpcc_cfg.opp_id = 0xf;
 			mpcc_cfg.top_dpp_id = 0xf;
 			mpcc_cfg.bot_mpcc_id = 0xf;
 			mpcc_cfg.top_of_tree = !old_pipe_ctx->top_pipe;
 			old_pipe_ctx->mpcc->funcs->set(old_pipe_ctx->mpcc, &mpcc_cfg);
+			/*
+			 * the mpcc is the only thing that keeps track of the mpcc
+			 * mapping for reset front end right now. Might need some
+			 * rework.
+			 */
+			old_pipe_ctx->mpcc->opp_id = opp_id_cached;
 
 			old_pipe_ctx->top_pipe = NULL;
 			old_pipe_ctx->bottom_pipe = NULL;

commit 4bd3ae5fb5156eb47b4d7f4f12d8467d9c4a8623
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Thu Jul 13 15:42:58 2017 -0500

    drm/amd/display:  Move view port registers and programming to memory input.
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index eca0d53eedff..d714422ef979 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1470,6 +1470,8 @@ static void update_dchubp_dpp(
 	/* scaler configuration */
 	pipe_ctx->xfm->funcs->transform_set_scaler(
 			pipe_ctx->xfm, &pipe_ctx->scl_data);
+	mi->funcs->mem_program_viewport(mi,
+			&pipe_ctx->scl_data.viewport, &pipe_ctx->scl_data.viewport_c);
 
 	/*gamut remap*/
 	program_gamut_remap(pipe_ctx);

commit b02c3b055fe27cb37969c68cd81db767a16af43b
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jul 7 17:21:45 2017 -0400

    drm/amd/display: hwseq init sequence update
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index fc46c84aea67..eca0d53eedff 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -24,11 +24,9 @@
  */
 
 #include "dm_services.h"
-#include "dc.h"
-#include "core_dc.h"
 #include "core_types.h"
-#include "core_status.h"
 #include "resource.h"
+#include "custom_float.h"
 #include "dcn10_hw_sequencer.h"
 #include "dce110/dce110_hw_sequencer.h"
 #include "dce/dce_hwseq.h"
@@ -39,11 +37,10 @@
 #include "timing_generator.h"
 #include "opp.h"
 #include "ipp.h"
-#include "dc_bios_types.h"
+#include "mpc.h"
 #include "raven1/DCN/dcn_1_0_offset.h"
 #include "raven1/DCN/dcn_1_0_sh_mask.h"
 #include "vega10/soc15ip.h"
-#include "custom_float.h"
 #include "reg_helper.h"
 
 #define CTX \
@@ -219,31 +216,15 @@ static void bios_golden_init(struct core_dc *dc)
 	}
 }
 
-/*
- * This should be done within BIOS, we are doing it for maximus only
- */
-static void dchubup_setup_timer(struct dce_hwseq *hws)
-{
-	REG_WRITE(REFCLK_CNTL, 0);
-
-	REG_UPDATE(DCHUBBUB_GLOBAL_TIMER_CNTL, DCHUBBUB_GLOBAL_TIMER_ENABLE, 1);
-}
-
-static void init_hw(struct core_dc *dc)
+static void dcn10_init_hw(struct core_dc *dc)
 {
 	int i;
-	struct transform *xfm;
-	struct abm *abm;
+	struct abm *abm = dc->res_pool->abm;
 	struct dce_hwseq *hws = dc->hwseq;
 
-#if 1
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
-		dchubup_setup_timer(dc->hwseq);
-
-		/* TODO: dchubp_map_fb_to_mc will be moved to dchub interface
-		 * between dc and kmd
-		 */
-		/*dchubp_map_fb_to_mc(dc->hwseq);*/
+		REG_WRITE(REFCLK_CNTL, 0);
+		REG_UPDATE(DCHUBBUB_GLOBAL_TIMER_CNTL, DCHUBBUB_GLOBAL_TIMER_ENABLE, 1);
 		REG_WRITE(DIO_MEM_PWR_CTRL, 0);
 
 		if (!dc->public.debug.disable_clock_gate) {
@@ -259,15 +240,9 @@ static void init_hw(struct core_dc *dc)
 		return;
 	}
 	/* end of FPGA. Below if real ASIC */
-#endif
 
 	bios_golden_init(dc);
 
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		xfm = dc->res_pool->transforms[i];
-		xfm->funcs->transform_reset(xfm);
-	}
-
 	for (i = 0; i < dc->link_count; i++) {
 		/* Power up AND update implementation according to the
 		 * required signal (which may be different from the
@@ -279,12 +254,12 @@ static void init_hw(struct core_dc *dc)
 	}
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct timing_generator *tg =
-				dc->res_pool->timing_generators[i];
-		struct mpcc *mpcc =
-				dc->res_pool->mpcc[i];
+		struct transform *xfm = dc->res_pool->transforms[i];
+		struct timing_generator *tg = dc->res_pool->timing_generators[i];
+		struct mpcc *mpcc = dc->res_pool->mpcc[i];
 		struct mpcc_cfg mpcc_cfg;
 
+		xfm->funcs->transform_reset(xfm);
 		mpcc_cfg.opp_id = 0xf;
 		mpcc_cfg.top_dpp_id = 0xf;
 		mpcc_cfg.bot_mpcc_id = 0xf;
@@ -305,7 +280,6 @@ static void init_hw(struct core_dc *dc)
 		audio->funcs->hw_init(audio);
 	}
 
-	abm = dc->res_pool->abm;
 	if (abm != NULL) {
 		abm->funcs->init_backlight(abm);
 		abm->funcs->abm_init(abm);
@@ -1859,7 +1833,7 @@ static bool dcn10_dummy_display_power_gating(
 static const struct hw_sequencer_funcs dcn10_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.program_csc_matrix = program_csc_matrix,
-	.init_hw = init_hw,
+	.init_hw = dcn10_init_hw,
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
 	.apply_ctx_for_surface = dcn10_apply_ctx_for_surface,
 	.set_plane_config = set_plane_config,
@@ -1888,9 +1862,8 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 };
 
 
-bool dcn10_hw_sequencer_construct(struct core_dc *dc)
+void dcn10_hw_sequencer_construct(struct core_dc *dc)
 {
 	dc->hwss = dcn10_funcs;
-	return true;
 }
 

commit 587cdfe9463e6b66186c3c70fe7e63790cf4d148
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Wed Jul 5 17:03:04 2017 -0500

    drm/amd/display: Rename trasnform to dpp for dcn's
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index dbf9cea2e418..fc46c84aea67 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -33,6 +33,8 @@
 #include "dce110/dce110_hw_sequencer.h"
 #include "dce/dce_hwseq.h"
 #include "abm.h"
+#include "dcn10/dcn10_dpp.h"
+#include "dcn10/dcn10_mpc.h"
 #include "mem_input.h"
 #include "timing_generator.h"
 #include "opp.h"

commit 71a2f23e9101887de251ef1dcd35219d4e4f5e93
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Wed Jul 12 18:38:04 2017 -0400

    drm/amd/display: fix mpo exit hang
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 82a96de2843f..dbf9cea2e418 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -500,8 +500,10 @@ static void reset_front_end(
 			HUBP_CLOCK_ENABLE, 0);
 	REG_UPDATE(DPP_CONTROL[fe_idx],
 			DPP_CLOCK_ENABLE, 0);
-	REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
-			OPP_PIPE_CLOCK_EN, 0);
+
+	if (mpcc_cfg.top_of_tree)
+		REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
+				OPP_PIPE_CLOCK_EN, 0);
 
 	xfm->funcs->transform_reset(xfm);
 
@@ -1584,7 +1586,7 @@ static void dcn10_apply_ctx_for_surface(
 	int i;
 
 	/* reset unused mpcc */
-	/*for (i = 0; i < dc->res_pool->pipe_count; i++) {
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 		struct pipe_ctx *old_pipe_ctx =
 				&dc->current_context->res_ctx.pipe_ctx[i];
@@ -1593,7 +1595,12 @@ static void dcn10_apply_ctx_for_surface(
 				|| (!pipe_ctx->stream && old_pipe_ctx->stream)) {
 			struct mpcc_cfg mpcc_cfg;
 
-			mpcc_cfg.opp_id = 0xf;
+			if (!old_pipe_ctx->top_pipe) {
+				ASSERT(0);
+				continue;
+			}
+
+			mpcc_cfg.opp_id = old_pipe_ctx->mpcc->opp_id;
 			mpcc_cfg.top_dpp_id = 0xf;
 			mpcc_cfg.bot_mpcc_id = 0xf;
 			mpcc_cfg.top_of_tree = !old_pipe_ctx->top_pipe;
@@ -1607,7 +1614,7 @@ static void dcn10_apply_ctx_for_surface(
 					"Reset mpcc for pipe %d\n",
 					old_pipe_ctx->pipe_idx);
 		}
-	}*/
+	}
 
 	if (!surface)
 		return;

commit 38917a1eb2748021fc0fd2ed4fd9b7f583713916
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Wed Jul 12 09:00:14 2017 -0400

    drm/amd/display: ensure OTG is locked before proceeding
    
    also remove tg lock at init_hw as not all OTG is running
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 18686be20004..82a96de2843f 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -283,13 +283,11 @@ static void init_hw(struct core_dc *dc)
 				dc->res_pool->mpcc[i];
 		struct mpcc_cfg mpcc_cfg;
 
-		tg->funcs->lock(tg);
 		mpcc_cfg.opp_id = 0xf;
 		mpcc_cfg.top_dpp_id = 0xf;
 		mpcc_cfg.bot_mpcc_id = 0xf;
 		mpcc_cfg.top_of_tree = true;
 		mpcc->funcs->set(mpcc, &mpcc_cfg);
-		tg->funcs->unlock(tg);
 
 		tg->funcs->disable_vga(tg);
 		/* Blank controller using driver code instead of

commit d21becbe0225de0e2582d17d4fbc73fbd103b1f7
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Wed Jul 12 11:54:10 2017 -0400

    drm/amd/display: avoid disabling opp clk before hubp is blanked.
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 0e90e6cc4930..18686be20004 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -472,9 +472,10 @@ static void reset_front_end(
 	struct transform *xfm = dc->res_pool->transforms[fe_idx];
 	struct mpcc *mpcc = dc->res_pool->mpcc[fe_idx];
 	struct timing_generator *tg = dc->res_pool->timing_generators[mpcc->opp_id];
+	unsigned int opp_id = mpcc->opp_id;
 
 	/*Already reset*/
-	if (mpcc->opp_id == 0xf)
+	if (opp_id == 0xf)
 		return;
 
 	tg->funcs->lock(tg);
@@ -497,8 +498,12 @@ static void reset_front_end(
 
 	mpcc->funcs->wait_for_idle(mpcc);
 
-	REG_UPDATE(HUBP_CLK_CNTL[fe_idx], HUBP_CLOCK_ENABLE, 0);
-	REG_UPDATE(DPP_CONTROL[fe_idx], DPP_CLOCK_ENABLE, 0);
+	REG_UPDATE(HUBP_CLK_CNTL[fe_idx],
+			HUBP_CLOCK_ENABLE, 0);
+	REG_UPDATE(DPP_CONTROL[fe_idx],
+			DPP_CLOCK_ENABLE, 0);
+	REG_UPDATE(OPP_PIPE_CONTROL[opp_id],
+			OPP_PIPE_CLOCK_EN, 0);
 
 	xfm->funcs->transform_reset(xfm);
 
@@ -1211,7 +1216,12 @@ static void dcn10_power_on_fe(
 		pipe_ctx->pipe_idx);
 
 	/* enable DCFCLK current DCHUB */
-	REG_UPDATE(HUBP_CLK_CNTL[pipe_ctx->pipe_idx], HUBP_CLOCK_ENABLE, 1);
+	REG_UPDATE(HUBP_CLK_CNTL[pipe_ctx->pipe_idx],
+			HUBP_CLOCK_ENABLE, 1);
+
+	/* make sure OPP_PIPE_CLOCK_EN = 1 */
+	REG_UPDATE(OPP_PIPE_CONTROL[pipe_ctx->tg->inst],
+			OPP_PIPE_CLOCK_EN, 1);
 
 	if (dc_surface) {
 		dm_logger_write(dc->ctx->logger, LOG_DC,

commit 189f73e32e9a7fc5ac62f244b66f8b41a78803c7
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Wed Jul 12 09:02:54 2017 -0400

    drm/amd/display: change order of HUBP and MPC disable according to HW guide
    
    blank hubp first before disconnect MPC
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index ac0d62c10da2..0e90e6cc4930 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -477,9 +477,14 @@ static void reset_front_end(
 	if (mpcc->opp_id == 0xf)
 		return;
 
-	mi->funcs->dcc_control(mi, false, false);
 	tg->funcs->lock(tg);
 
+	mi->funcs->dcc_control(mi, false, false);
+	mi->funcs->set_blank(mi, true);
+	REG_WAIT(DCHUBP_CNTL[fe_idx],
+			HUBP_NO_OUTSTANDING_REQ, 1,
+			1, 200);
+
 	mpcc_cfg.opp_id = 0xf;
 	mpcc_cfg.top_dpp_id = 0xf;
 	mpcc_cfg.bot_mpcc_id = 0xf;
@@ -491,8 +496,7 @@ static void reset_front_end(
 	REG_WAIT(OTG_GLOBAL_SYNC_STATUS[tg->inst], VUPDATE_NO_LOCK_EVENT_OCCURRED, 1, 20000, 200000);
 
 	mpcc->funcs->wait_for_idle(mpcc);
-	mi->funcs->set_blank(mi, true);
-	REG_WAIT(DCHUBP_CNTL[fe_idx], HUBP_NO_OUTSTANDING_REQ, 1, 20000, 200000);
+
 	REG_UPDATE(HUBP_CLK_CNTL[fe_idx], HUBP_CLOCK_ENABLE, 0);
 	REG_UPDATE(DPP_CONTROL[fe_idx], DPP_CLOCK_ENABLE, 0);
 

commit 7b0c470fcb44b7dbe63db5b5fb52b6123ebe335f
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Mon Jul 10 14:04:21 2017 -0400

    drm/amd/display: Flattening to dc_transfer_func
    
    Flattening dc transfer functions in the following manner:
    transfer_func > core_transfer_func > dc_transfer_func
    
    References to deleted structs are updated as needed.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 4c39bf052d08..ac0d62c10da2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -602,14 +602,14 @@ static bool dcn10_set_input_transfer_func(
 	struct pipe_ctx *pipe_ctx, const struct core_surface *surface)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
-	const struct core_transfer_func *tf = NULL;
+	const struct dc_transfer_func *tf = NULL;
 	bool result = true;
 
 	if (ipp == NULL)
 		return false;
 
 	if (surface->public.in_transfer_func)
-		tf = DC_TRANSFER_FUNC_TO_CORE(surface->public.in_transfer_func);
+		tf = surface->public.in_transfer_func;
 
 	if (surface->public.gamma_correction && dce_use_lut(surface))
 		ipp->funcs->ipp_program_input_lut(ipp,
@@ -617,8 +617,8 @@ static bool dcn10_set_input_transfer_func(
 
 	if (tf == NULL)
 		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
-	else if (tf->public.type == TF_TYPE_PREDEFINED) {
-		switch (tf->public.tf) {
+	else if (tf->type == TF_TYPE_PREDEFINED) {
+		switch (tf->tf) {
 		case TRANSFER_FUNCTION_SRGB:
 			ipp->funcs->ipp_set_degamma(ipp,
 					IPP_DEGAMMA_MODE_HW_sRGB);
@@ -638,7 +638,7 @@ static bool dcn10_set_input_transfer_func(
 			result = false;
 			break;
 		}
-	} else if (tf->public.type == TF_TYPE_BYPASS) {
+	} else if (tf->type == TF_TYPE_BYPASS) {
 		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
 	} else {
 		/*TF_TYPE_DISTRIBUTED_POINTS*/

commit 4e5095ca06a00fda50e2fcc721b1f923478778a8
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jul 7 11:24:13 2017 -0400

    drm/amd/display: dal1.1 hwseq prog update
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 223bb79bc8b8..4c39bf052d08 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -64,17 +64,13 @@ static void enable_dppclk(
 			plane_id,
 			dppclk_div);
 
-	if (dppclk_div) {
-		/* 1/2 DISPCLK*/
+	if (hws->shifts->DPPCLK_RATE_CONTROL)
 		REG_UPDATE_2(DPP_CONTROL[plane_id],
-			DPPCLK_RATE_CONTROL, 1,
+			DPPCLK_RATE_CONTROL, dppclk_div,
 			DPP_CLOCK_ENABLE, 1);
-	} else {
-		/* DISPCLK */
-		REG_UPDATE_2(DPP_CONTROL[plane_id],
-			DPPCLK_RATE_CONTROL, 0,
+	else
+		REG_UPDATE(DPP_CONTROL[plane_id],
 			DPP_CLOCK_ENABLE, 1);
-	}
 }
 
 static void enable_power_gating_plane(

commit 4fac6da2cb93cd6cabfaeb6de2eb0401bbcc805b
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Jul 6 15:42:04 2017 -0400

    drm/amd/display: minor dcn10_hwseq clean up/refactor
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 5e275239341d..223bb79bc8b8 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -53,15 +53,6 @@
 #define FN(reg_name, field_name) \
 	hws->shifts->field_name, hws->masks->field_name
 
-static void disable_clocks(
-	struct dce_hwseq *hws,
-	uint8_t plane_id)
-{
-	REG_UPDATE(HUBP_CLK_CNTL[plane_id], HUBP_CLOCK_ENABLE, 0);
-
-	REG_UPDATE(DPP_CONTROL[plane_id], DPP_CLOCK_ENABLE, 0);
-}
-
 static void enable_dppclk(
 	struct dce_hwseq *hws,
 	uint8_t plane_id,
@@ -214,25 +205,6 @@ static void power_on_plane(
 			"Un-gated front end for pipe %d\n", plane_id);
 }
 
-/* fully check bios enabledisplaypowergating table. dal only need dce init
- * other power, clock gate register will be handle by dal itself.
- * further may be put within init_hw
- */
-static bool dcn10_enable_display_power_gating(
-	struct core_dc *dc,
-	uint8_t controller_id,
-	struct dc_bios *dcb,
-	enum pipe_gating_control power_gating)
-{
-	/* TODOFPGA */
-#if 0
-	if (power_gating != PIPE_GATING_CONTROL_ENABLE)
-		dce110_init_pte(ctx);
-#endif
-
-	return true;
-}
-
 static void bios_golden_init(struct core_dc *dc)
 {
 	struct dc_bios *bp = dc->ctx->dc_bios;
@@ -525,7 +497,8 @@ static void reset_front_end(
 	mpcc->funcs->wait_for_idle(mpcc);
 	mi->funcs->set_blank(mi, true);
 	REG_WAIT(DCHUBP_CNTL[fe_idx], HUBP_NO_OUTSTANDING_REQ, 1, 20000, 200000);
-	disable_clocks(dc->hwseq, fe_idx);
+	REG_UPDATE(HUBP_CLK_CNTL[fe_idx], HUBP_CLOCK_ENABLE, 0);
+	REG_UPDATE(DPP_CONTROL[fe_idx], DPP_CLOCK_ENABLE, 0);
 
 	xfm->funcs->transform_reset(xfm);
 
@@ -1803,8 +1776,8 @@ static void set_plane_config(
 	program_gamut_remap(pipe_ctx);
 }
 
-static void dcn10_config_stereo_parameters(struct core_stream *stream,\
-										   struct crtc_stereo_flags *flags)
+static void dcn10_config_stereo_parameters(
+		struct core_stream *stream, struct crtc_stereo_flags *flags)
 {
 	enum view_3d_format view_format = stream->public.view_format;
 	enum dc_timing_3d_format timing_3d_format =\
@@ -1840,8 +1813,7 @@ static void dcn10_config_stereo_parameters(struct core_stream *stream,\
 	return;
 }
 
-static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx,
-								struct core_dc *dc)
+static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx, struct core_dc *dc)
 {
 	struct crtc_stereo_flags flags = { 0 };
 	struct core_stream *stream = pipe_ctx->stream;
@@ -1858,11 +1830,15 @@ static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx,
 		&stream->public.timing,
 		&flags);
 
-
-
 	return;
 }
 
+static bool dcn10_dummy_display_power_gating(
+	struct core_dc *dc,
+	uint8_t controller_id,
+	struct dc_bios *dcb,
+	enum pipe_gating_control power_gating) {return true; }
+
 static const struct hw_sequencer_funcs dcn10_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.program_csc_matrix = program_csc_matrix,
@@ -1881,8 +1857,7 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.enable_stream = dce110_enable_stream,
 	.disable_stream = dce110_disable_stream,
 	.unblank_stream = dce110_unblank_stream,
-	.enable_display_pipe_clock_gating = NULL, /* TODOFPGA */
-	.enable_display_power_gating = dcn10_enable_display_power_gating,
+	.enable_display_power_gating = dcn10_dummy_display_power_gating,
 	.power_down_front_end = dcn10_power_down_fe,
 	.power_on_front_end = dcn10_power_on_fe,
 	.pipe_control_lock = dcn10_pipe_control_lock,

commit 87449a90c2545eaed5757153770346563378463b
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Jul 6 14:27:49 2017 -0400

    drm/amd/display: Fix MPO visual confirm
    
    1. Need to blend non-active area to show visual confirm borders
    2. Set number of Visual Confirm lines based on pipe instance
    3. Set Different colors representing surface format of bottom most plan
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index fb326316b08b..5e275239341d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1390,6 +1390,42 @@ static bool is_rgb_cspace(enum dc_color_space output_color_space)
 	}
 }
 
+static void dcn10_get_surface_visual_confirm_color(
+		const struct pipe_ctx *pipe_ctx,
+		struct tg_color *color)
+{
+	uint32_t color_value = MAX_TG_COLOR_VALUE;
+
+	switch (pipe_ctx->scl_data.format) {
+	case PIXEL_FORMAT_ARGB8888:
+		/* set boarder color to red */
+		color->color_r_cr = color_value;
+		break;
+
+	case PIXEL_FORMAT_ARGB2101010:
+		/* set boarder color to blue */
+		color->color_b_cb = color_value;
+		break;
+	case PIXEL_FORMAT_420BPP8:
+		/* set boarder color to green */
+		color->color_g_y = color_value;
+		break;
+	case PIXEL_FORMAT_420BPP10:
+		/* set boarder color to yellow */
+		color->color_g_y = color_value;
+		color->color_r_cr = color_value;
+		break;
+	case PIXEL_FORMAT_FP16:
+		/* set boarder color to white */
+		color->color_r_cr = color_value;
+		color->color_b_cb = color_value;
+		color->color_g_y = color_value;
+		break;
+	default:
+		break;
+	}
+}
+
 static void update_dchubp_dpp(
 	struct core_dc *dc,
 	struct pipe_ctx *pipe_ctx,
@@ -1462,8 +1498,13 @@ static void update_dchubp_dpp(
 					&& per_pixel_alpha;
 	pipe_ctx->mpcc->funcs->set(pipe_ctx->mpcc, &mpcc_cfg);
 
-	color_space_to_black_color(
-		dc, pipe_ctx->stream->public.output_color_space, &black_color);
+	if (dc->public.debug.surface_visual_confirm) {
+		dcn10_get_surface_visual_confirm_color(pipe_ctx, &black_color);
+	} else {
+		color_space_to_black_color(
+			dc, pipe_ctx->stream->public.output_color_space,
+			&black_color);
+	}
 	pipe_ctx->mpcc->funcs->set_bg_color(pipe_ctx->mpcc, &black_color);
 
 	pipe_ctx->scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;

commit 184debdbd80bd9d47eb68304417adb6580ff09e4
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jul 5 06:57:49 2017 -0400

    drm/amd/display: refactor dcn10 hw_sequencer to new reg access style
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d38570e6d4d2..fb326316b08b 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -33,381 +33,120 @@
 #include "dce110/dce110_hw_sequencer.h"
 #include "dce/dce_hwseq.h"
 #include "abm.h"
-
-#include "dcn10/dcn10_transform.h"
-#include "dcn10/dcn10_mpc.h"
-#include "dcn10/dcn10_timing_generator.h"
-
 #include "mem_input.h"
 #include "timing_generator.h"
 #include "opp.h"
 #include "ipp.h"
-
 #include "dc_bios_types.h"
-
 #include "raven1/DCN/dcn_1_0_offset.h"
 #include "raven1/DCN/dcn_1_0_sh_mask.h"
 #include "vega10/soc15ip.h"
-
 #include "custom_float.h"
+#include "reg_helper.h"
 
+#define CTX \
+	hws->ctx
+#define REG(reg)\
+	hws->regs->reg
 
-struct dcn10_hwseq_reg_offsets {
-	uint32_t dchubp;
-	uint32_t dpp;
-	uint32_t otg;
-	uint32_t vtg;
-	uint32_t fmt;
-};
-
-/* TODO: move to resource */
-static const struct dcn10_hwseq_reg_offsets reg_offsets[] = {
-	{
-		.dchubp = (mmHUBP0_DCHUBP_CNTL - mmHUBP0_DCHUBP_CNTL),
-		.dpp = (mmCM0_CM_DGAM_CONTROL - mmCM0_CM_DGAM_CONTROL),
-		.otg = (mmOTG0_OTG_CONTROL - mmOTG0_OTG_CONTROL),
-		.vtg = (mmVTG0_CONTROL - mmVTG0_CONTROL),
-		.fmt = (mmFMT0_FMT_BIT_DEPTH_CONTROL -
-				mmFMT0_FMT_BIT_DEPTH_CONTROL),
-	},
-	{
-		.dchubp = (mmHUBP1_DCHUBP_CNTL - mmHUBP0_DCHUBP_CNTL),
-		.dpp = (mmCM1_CM_DGAM_CONTROL - mmCM0_CM_DGAM_CONTROL),
-		.otg = (mmOTG1_OTG_CONTROL - mmOTG0_OTG_CONTROL),
-		.vtg = (mmVTG1_CONTROL - mmVTG0_CONTROL),
-		.fmt = (mmFMT1_FMT_BIT_DEPTH_CONTROL -
-				mmFMT0_FMT_BIT_DEPTH_CONTROL),
-	},
-	{
-		.dchubp = (mmHUBP2_DCHUBP_CNTL - mmHUBP0_DCHUBP_CNTL),
-		.dpp = (mmCM2_CM_DGAM_CONTROL - mmCM0_CM_DGAM_CONTROL),
-		.otg = (mmOTG2_OTG_CONTROL - mmOTG0_OTG_CONTROL),
-		.vtg = (mmVTG2_CONTROL - mmVTG0_CONTROL),
-		.fmt = (mmFMT2_FMT_BIT_DEPTH_CONTROL -
-				mmFMT0_FMT_BIT_DEPTH_CONTROL),
-	},
-	{
-		.dchubp = (mmHUBP3_DCHUBP_CNTL - mmHUBP0_DCHUBP_CNTL),
-		.dpp = (mmCM3_CM_DGAM_CONTROL - mmCM0_CM_DGAM_CONTROL),
-		.otg = (mmOTG3_OTG_CONTROL - mmOTG0_OTG_CONTROL),
-		.vtg = (mmVTG3_CONTROL - mmVTG0_CONTROL),
-		.fmt = (mmFMT3_FMT_BIT_DEPTH_CONTROL -
-				mmFMT0_FMT_BIT_DEPTH_CONTROL),
-	}
-};
-
-#define HWSEQ_REG_UPDATE_N(reg_name, n, ...)	\
-		generic_reg_update_soc15(ctx, inst_offset, reg_name, n, __VA_ARGS__)
-
-#define HWSEQ_REG_SET_N(reg_name, n, ...)	\
-		generic_reg_set_soc15(ctx, inst_offset, reg_name, n, __VA_ARGS__)
-
-#define HWSEQ_REG_UPDATE(reg, field, val)	\
-		HWSEQ_REG_UPDATE_N(reg, 1, FD(reg##__##field), val)
-
-#define HWSEQ_REG_UPDATE_2(reg, field1, val1, field2, val2)	\
-		HWSEQ_REG_UPDATE_N(reg, 2, FD(reg##__##field1), val1, FD(reg##__##field2), val2)
-
-#define HWSEQ_REG_UPDATE_3(reg, field1, val1, field2, val2, field3, val3)	\
-		HWSEQ_REG_UPDATE_N(reg, 2, FD(reg##__##field1), val1, FD(reg##__##field2), val2, FD(reg##__##field3), val3)
-
-
-#define HWSEQ_REG_SET(reg, field, val)	\
-		HWSEQ_REG_SET_N(reg, 1, FD(reg##__##field), val)
-
-/* TODO should be moved to OTG */
-
-static bool unlock_master_tg_and_wait(
-	struct dc_context *ctx,
-	uint8_t inst)
-{
-	uint32_t inst_offset = reg_offsets[inst].otg;
-
-	HWSEQ_REG_UPDATE(OTG0_OTG_GLOBAL_SYNC_STATUS,
-			VUPDATE_NO_LOCK_EVENT_CLEAR, 1);
-	HWSEQ_REG_UPDATE(OTG0_OTG_MASTER_UPDATE_LOCK, OTG_MASTER_UPDATE_LOCK, 0);
-
-	if (!wait_reg(ctx, inst_offset, OTG0_OTG_GLOBAL_SYNC_STATUS, VUPDATE_NO_LOCK_EVENT_OCCURRED, 1)) {
-		dm_logger_write(ctx->logger, LOG_ERROR,
-				"wait for VUPDATE_NO_LOCK_EVENT_OCCURRED failed\n");
-		BREAK_TO_DEBUGGER();
-		return false;
-	}
-	return true;
-}
-
-static void wait_no_outstanding_request(
-	struct dc_context *ctx,
-	uint8_t plane_id)
-{
-	uint32_t inst_offset = reg_offsets[plane_id].dchubp;
-
-	if (!wait_reg(ctx, inst_offset, HUBP0_DCHUBP_CNTL, HUBP_NO_OUTSTANDING_REQ, 1))
-				BREAK_TO_DEBUGGER();
-}
+#undef FN
+#define FN(reg_name, field_name) \
+	hws->shifts->field_name, hws->masks->field_name
 
 static void disable_clocks(
-	struct dc_context *ctx,
+	struct dce_hwseq *hws,
 	uint8_t plane_id)
 {
-	uint32_t inst_offset = reg_offsets[plane_id].dchubp;
-
-	generic_reg_update_soc15(ctx, inst_offset, HUBP0_HUBP_CLK_CNTL, 1,
-			FD(HUBP0_HUBP_CLK_CNTL__HUBP_CLOCK_ENABLE), 0);
+	REG_UPDATE(HUBP_CLK_CNTL[plane_id], HUBP_CLOCK_ENABLE, 0);
 
-	inst_offset = reg_offsets[plane_id].dpp;
-	generic_reg_update_soc15(ctx, inst_offset, DPP_TOP0_DPP_CONTROL, 1,
-				FD(DPP_TOP0_DPP_CONTROL__DPP_CLOCK_ENABLE), 0);
-}
-
-/* TODO: This is one time program during system boot up,
- * this should be done within BIOS or CAIL
- */
-static void dchubp_map_fb_to_mc(struct dc_context *ctx)
-{
-	/* TODO: do not know where to program
-	 * DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB
-	 */
-	/*
-	 * TODO: For real ASIC, FB_OFFSET may be need change to the same value
-	 * as FB_BASE. Need re-visit this for real ASIC.
-	 */
-	dm_write_reg_soc15(ctx, mmDCHUBBUB_SDPIF_FB_BASE, 0, 0x80);
-	dm_write_reg_soc15(ctx, mmDCHUBBUB_SDPIF_FB_OFFSET, 0, 0);
-	dm_write_reg_soc15(ctx, mmDCHUBBUB_SDPIF_FB_TOP, 0, 0xFF);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_CFG0, 7,
-			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_DATA_RESPONSE_STATUS_CLEAR), 0,
-			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_REQ_CREDIT_ERROR_CLEAR), 0,
-			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_FLUSH_REQ_CREDIT_EN), 0,
-			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_REQ_CREDIT_EN), 0,
-			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_PORT_CONTROL), 1,
-			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_UNIT_ID_BITMASK), 0xd3,
-			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_CREDIT_DISCONNECT_DELAY), 0xc);
-
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_CFG1, 4,
-			FD(DCHUBBUB_SDPIF_CFG1__SDPIF_INSIDE_FB_IO), 0,
-			FD(DCHUBBUB_SDPIF_CFG1__SDPIF_INSIDE_FB_VC), 6,
-			FD(DCHUBBUB_SDPIF_CFG1__SDPIF_OUTSIDE_FB_IO), 1,
-			FD(DCHUBBUB_SDPIF_CFG1__SDPIF_OUTSIDE_FB_VC), 6);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_FB_BASE, 1,
-			FD(DCHUBBUB_SDPIF_FB_BASE__SDPIF_FB_BASE), 0x000080);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_FB_TOP, 1,
-			FD(DCHUBBUB_SDPIF_FB_TOP__SDPIF_FB_TOP), 0x0000ff);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_AGP_BOT, 1,
-			FD(DCHUBBUB_SDPIF_AGP_BOT__SDPIF_AGP_BOT), 0x0000040);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_AGP_TOP, 1,
-			FD(DCHUBBUB_SDPIF_AGP_TOP__SDPIF_AGP_TOP), 0x00001ff);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_AGP_BASE, 1,
-			FD(DCHUBBUB_SDPIF_AGP_BASE__SDPIF_AGP_BASE), 0x0000080);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_APER_TOP, 1,
-			FD(DCHUBBUB_SDPIF_APER_TOP__SDPIF_APER_TOP), 0x00007ff);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_APER_DEF_0, 1,
-			FD(DCHUBBUB_SDPIF_APER_DEF_0__SDPIF_APER_DEF_0), 0xdeadbeef);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_RELOC_LO_0, 2,
-			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_0__SDPIF_MARC_EN_0), 0,
-			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_0__SDPIF_MARC_RELOC_LO_0), 0x90000);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_LENGTH_LO_0, 1,
-			FD(DCHUBBUB_SDPIF_MARC_LENGTH_LO_0__SDPIF_MARC_LENGTH_LO_0), 0x10000);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_BASE_LO_1, 1,
-			FD(DCHUBBUB_SDPIF_MARC_BASE_LO_1__SDPIF_MARC_BASE_LO_1), 0x10000);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_RELOC_LO_1, 2,
-			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_1__SDPIF_MARC_EN_1), 0,
-			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_1__SDPIF_MARC_RELOC_LO_1), 0xa0000);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_LENGTH_LO_1, 1,
-			FD(DCHUBBUB_SDPIF_MARC_LENGTH_LO_1__SDPIF_MARC_LENGTH_LO_1), 0x10000);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_BASE_LO_2, 1,
-			FD(DCHUBBUB_SDPIF_MARC_BASE_LO_2__SDPIF_MARC_BASE_LO_2), 0x20000);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_RELOC_LO_2, 2,
-			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_2__SDPIF_MARC_EN_2), 0,
-			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_2__SDPIF_MARC_RELOC_LO_2), 0xb0000);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_LENGTH_LO_2, 1,
-			FD(DCHUBBUB_SDPIF_MARC_LENGTH_LO_2__SDPIF_MARC_LENGTH_LO_2), 0x10000);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_BASE_LO_3, 1,
-			FD(DCHUBBUB_SDPIF_MARC_BASE_LO_3__SDPIF_MARC_BASE_LO_3), 0x30000);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_RELOC_LO_3, 2,
-			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_3__SDPIF_MARC_EN_3), 0,
-			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_3__SDPIF_MARC_RELOC_LO_3), 0xc0000);
-
-	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_LENGTH_LO_3, 1,
-			FD(DCHUBBUB_SDPIF_MARC_LENGTH_LO_3__SDPIF_MARC_LENGTH_LO_3), 0x10000);
-
-	/* TODO: Is DCN_VM_SYSTEM_APERTURE address one time programming?
-	 * Are all 4 hubp programmed with the same address?
-	 */
-	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB, 0, 0x80000);
-	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_MSB, 0, 0);
-	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, 0, 0x100000);
-	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB, 0, 0);
-	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, 0, 0x80000);
-	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, 0, 0);
-
-	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB, 0, 0x80000);
-	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_MSB, 0, 0);
-	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, 0, 0x100000);
-	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB, 0, 0);
-	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, 0, 0x80000);
-	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, 0, 0);
-
-	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB, 0, 0x80000);
-	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_MSB, 0, 0);
-	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, 0, 0x100000);
-	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB, 0, 0);
-	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, 0, 0x80000);
-	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, 0, 0);
-
-	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB, 0, 0x80000);
-	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_MSB, 0, 0);
-	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, 0, 0x100000);
-	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB, 0, 0);
-	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, 0, 0x80000);
-	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, 0, 0);
-}
-
-/* TODO: This is one time program during system boot up,
- * this should be done within BIOS
- */
-static void dchubup_setup_timer(struct dc_context *ctx)
-{
-	dm_write_reg_soc15(ctx, mmREFCLK_CNTL, 0, 0);
-
-	generic_reg_update_soc15(ctx, 0, DCHUBBUB_GLOBAL_TIMER_CNTL, 1,
-			FD(DCHUBBUB_GLOBAL_TIMER_CNTL__DCHUBBUB_GLOBAL_TIMER_ENABLE), 1);
-}
-
-/* TODO: Need input parameter to tell current DCHUB pipe tie to which OTG
- * VTG is within DCHUBBUB which is commond block share by each pipe HUBP.
- * VTG is 1:1 mapping with OTG. Each pipe HUBP will select which VTG
- */
-static void select_vtg(
-	struct dc_context *ctx,
-	uint8_t plane_id,
-	uint8_t inst)
-{
-	uint32_t inst_offset = reg_offsets[plane_id].dchubp;
-
-	HWSEQ_REG_UPDATE(HUBP0_DCHUBP_CNTL, HUBP_VTG_SEL, inst);
-}
-
-static void enable_dcfclk(
-	struct dc_context *ctx,
-	uint8_t plane_id,
-	uint32_t requested_pix_clk,
-	bool dppclk_div)
-{
-	uint32_t inst_offset = reg_offsets[plane_id].dchubp;
-
-	HWSEQ_REG_UPDATE(HUBP0_HUBP_CLK_CNTL, HUBP_CLOCK_ENABLE, 1);
+	REG_UPDATE(DPP_CONTROL[plane_id], DPP_CLOCK_ENABLE, 0);
 }
 
 static void enable_dppclk(
-	struct dc_context *ctx,
+	struct dce_hwseq *hws,
 	uint8_t plane_id,
 	uint32_t requested_pix_clk,
 	bool dppclk_div)
 {
-	uint32_t inst_offset = reg_offsets[plane_id].dpp;
-
-	dm_logger_write(ctx->logger, LOG_SURFACE,
+	dm_logger_write(hws->ctx->logger, LOG_SURFACE,
 			"dppclk_rate_control for pipe %d programed to %d\n",
 			plane_id,
 			dppclk_div);
 
-	/* TODO: find condition for DPP clock to DISPCLK or 1/2 DISPCLK */
 	if (dppclk_div) {
 		/* 1/2 DISPCLK*/
-		HWSEQ_REG_UPDATE_2(DPP_TOP0_DPP_CONTROL,
+		REG_UPDATE_2(DPP_CONTROL[plane_id],
 			DPPCLK_RATE_CONTROL, 1,
 			DPP_CLOCK_ENABLE, 1);
 	} else {
 		/* DISPCLK */
-		HWSEQ_REG_UPDATE_2(DPP_TOP0_DPP_CONTROL,
+		REG_UPDATE_2(DPP_CONTROL[plane_id],
 			DPPCLK_RATE_CONTROL, 0,
 			DPP_CLOCK_ENABLE, 1);
 	}
 }
 
 static void enable_power_gating_plane(
-	struct dc_context *ctx,
+	struct dce_hwseq *hws,
 	bool enable)
 {
-	uint32_t inst_offset = 0; /* each register only has one instance */
 	bool force_on = 1; /* disable power gating */
 
 	if (enable)
 		force_on = 0;
 
 	/* DCHUBP0/1/2/3 */
-	HWSEQ_REG_UPDATE(DOMAIN0_PG_CONFIG, DOMAIN0_POWER_FORCEON, force_on);
-	HWSEQ_REG_UPDATE(DOMAIN2_PG_CONFIG, DOMAIN2_POWER_FORCEON, force_on);
-	HWSEQ_REG_UPDATE(DOMAIN4_PG_CONFIG, DOMAIN4_POWER_FORCEON, force_on);
-	HWSEQ_REG_UPDATE(DOMAIN6_PG_CONFIG, DOMAIN6_POWER_FORCEON, force_on);
+	REG_UPDATE(DOMAIN0_PG_CONFIG, DOMAIN0_POWER_FORCEON, force_on);
+	REG_UPDATE(DOMAIN2_PG_CONFIG, DOMAIN2_POWER_FORCEON, force_on);
+	REG_UPDATE(DOMAIN4_PG_CONFIG, DOMAIN4_POWER_FORCEON, force_on);
+	REG_UPDATE(DOMAIN6_PG_CONFIG, DOMAIN6_POWER_FORCEON, force_on);
 
 	/* DPP0/1/2/3 */
-	HWSEQ_REG_UPDATE(DOMAIN1_PG_CONFIG, DOMAIN1_POWER_FORCEON, force_on);
-	HWSEQ_REG_UPDATE(DOMAIN3_PG_CONFIG, DOMAIN3_POWER_FORCEON, force_on);
-	HWSEQ_REG_UPDATE(DOMAIN5_PG_CONFIG, DOMAIN5_POWER_FORCEON, force_on);
-	HWSEQ_REG_UPDATE(DOMAIN7_PG_CONFIG, DOMAIN7_POWER_FORCEON, force_on);
+	REG_UPDATE(DOMAIN1_PG_CONFIG, DOMAIN1_POWER_FORCEON, force_on);
+	REG_UPDATE(DOMAIN3_PG_CONFIG, DOMAIN3_POWER_FORCEON, force_on);
+	REG_UPDATE(DOMAIN5_PG_CONFIG, DOMAIN5_POWER_FORCEON, force_on);
+	REG_UPDATE(DOMAIN7_PG_CONFIG, DOMAIN7_POWER_FORCEON, force_on);
 }
 
 static void dpp_pg_control(
-		struct dc_context *ctx,
+		struct dce_hwseq *hws,
 		unsigned int dpp_inst,
 		bool power_on)
 {
-	uint32_t inst_offset = 0;
 	uint32_t power_gate = power_on ? 0 : 1;
 	uint32_t pwr_status = power_on ? 0 : 2;
 
-	if (ctx->dc->debug.disable_dpp_power_gate)
+	if (hws->ctx->dc->debug.disable_dpp_power_gate)
 		return;
 
 	switch (dpp_inst) {
 	case 0: /* DPP0 */
-		HWSEQ_REG_UPDATE(DOMAIN1_PG_CONFIG,
+		REG_UPDATE(DOMAIN1_PG_CONFIG,
 				DOMAIN1_POWER_GATE, power_gate);
 
-		wait_reg(ctx, 0, DOMAIN1_PG_STATUS,
-				DOMAIN1_PGFSM_PWR_STATUS, pwr_status);
+		REG_WAIT(DOMAIN1_PG_STATUS,
+				DOMAIN1_PGFSM_PWR_STATUS, pwr_status, 20000, 200000);
 		break;
 	case 1: /* DPP1 */
-		HWSEQ_REG_UPDATE(DOMAIN3_PG_CONFIG,
+		REG_UPDATE(DOMAIN3_PG_CONFIG,
 				DOMAIN3_POWER_GATE, power_gate);
 
-		wait_reg(ctx, 0, DOMAIN3_PG_STATUS,
-				DOMAIN3_PGFSM_PWR_STATUS, pwr_status);
+		REG_WAIT(DOMAIN3_PG_STATUS,
+				DOMAIN3_PGFSM_PWR_STATUS, pwr_status, 20000, 200000);
 		break;
 	case 2: /* DPP2 */
-		HWSEQ_REG_UPDATE(DOMAIN5_PG_CONFIG,
+		REG_UPDATE(DOMAIN5_PG_CONFIG,
 				DOMAIN5_POWER_GATE, power_gate);
 
-		wait_reg(ctx, 0, DOMAIN5_PG_STATUS,
-				DOMAIN5_PGFSM_PWR_STATUS, pwr_status);
+		REG_WAIT(DOMAIN5_PG_STATUS,
+				DOMAIN5_PGFSM_PWR_STATUS, pwr_status, 20000, 200000);
 		break;
 	case 3: /* DPP3 */
-		HWSEQ_REG_UPDATE(DOMAIN7_PG_CONFIG,
+		REG_UPDATE(DOMAIN7_PG_CONFIG,
 				DOMAIN7_POWER_GATE, power_gate);
 
-		wait_reg(ctx, 0, DOMAIN7_PG_STATUS,
-				DOMAIN7_PGFSM_PWR_STATUS, pwr_status);
+		REG_WAIT(DOMAIN7_PG_STATUS,
+				DOMAIN7_PGFSM_PWR_STATUS, pwr_status, 20000, 200000);
 		break;
 	default:
 		BREAK_TO_DEBUGGER();
@@ -416,45 +155,44 @@ static void dpp_pg_control(
 }
 
 static void hubp_pg_control(
-		struct dc_context *ctx,
+		struct dce_hwseq *hws,
 		unsigned int hubp_inst,
 		bool power_on)
 {
-	uint32_t inst_offset = 0;
 	uint32_t power_gate = power_on ? 0 : 1;
 	uint32_t pwr_status = power_on ? 0 : 2;
 
-	if (ctx->dc->debug.disable_hubp_power_gate)
+	if (hws->ctx->dc->debug.disable_hubp_power_gate)
 		return;
 
 	switch (hubp_inst) {
 	case 0: /* DCHUBP0 */
-		HWSEQ_REG_UPDATE(DOMAIN0_PG_CONFIG,
+		REG_UPDATE(DOMAIN0_PG_CONFIG,
 				DOMAIN0_POWER_GATE, power_gate);
 
-		wait_reg(ctx, 0, DOMAIN0_PG_STATUS,
-				DOMAIN0_PGFSM_PWR_STATUS, pwr_status);
+		REG_WAIT(DOMAIN0_PG_STATUS,
+				DOMAIN0_PGFSM_PWR_STATUS, pwr_status, 20000, 200000);
 		break;
 	case 1: /* DCHUBP1 */
-		HWSEQ_REG_UPDATE(DOMAIN2_PG_CONFIG,
+		REG_UPDATE(DOMAIN2_PG_CONFIG,
 				DOMAIN2_POWER_GATE, power_gate);
 
-		wait_reg(ctx, 0, DOMAIN2_PG_STATUS,
-				DOMAIN2_PGFSM_PWR_STATUS, pwr_status);
+		REG_WAIT(DOMAIN2_PG_STATUS,
+				DOMAIN2_PGFSM_PWR_STATUS, pwr_status, 20000, 200000);
 		break;
 	case 2: /* DCHUBP2 */
-		HWSEQ_REG_UPDATE(DOMAIN4_PG_CONFIG,
+		REG_UPDATE(DOMAIN4_PG_CONFIG,
 				DOMAIN4_POWER_GATE, power_gate);
 
-		wait_reg(ctx, 0, DOMAIN4_PG_STATUS,
-				DOMAIN4_PGFSM_PWR_STATUS, pwr_status);
+		REG_WAIT(DOMAIN4_PG_STATUS,
+				DOMAIN4_PGFSM_PWR_STATUS, pwr_status, 20000, 200000);
 		break;
 	case 3: /* DCHUBP3 */
-		HWSEQ_REG_UPDATE(DOMAIN6_PG_CONFIG,
+		REG_UPDATE(DOMAIN6_PG_CONFIG,
 				DOMAIN6_POWER_GATE, power_gate);
 
-		wait_reg(ctx, 0, DOMAIN6_PG_STATUS,
-				DOMAIN6_PGFSM_PWR_STATUS, pwr_status);
+		REG_WAIT(DOMAIN6_PG_STATUS,
+				DOMAIN6_PGFSM_PWR_STATUS, pwr_status, 20000, 200000);
 		break;
 	default:
 		BREAK_TO_DEBUGGER();
@@ -463,18 +201,16 @@ static void hubp_pg_control(
 }
 
 static void power_on_plane(
-	struct dc_context *ctx,
+	struct dce_hwseq *hws,
 	int plane_id)
 {
-	uint32_t inst_offset = 0;
-
-	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
+	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 1);
-	dpp_pg_control(ctx, plane_id, true);
-	hubp_pg_control(ctx, plane_id, true);
-	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
+	dpp_pg_control(hws, plane_id, true);
+	hubp_pg_control(hws, plane_id, true);
+	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
-	dm_logger_write(ctx->logger, LOG_DC,
+	dm_logger_write(hws->ctx->logger, LOG_DC,
 			"Un-gated front end for pipe %d\n", plane_id);
 }
 
@@ -513,47 +249,54 @@ static void bios_golden_init(struct core_dc *dc)
 	}
 }
 
+/*
+ * This should be done within BIOS, we are doing it for maximus only
+ */
+static void dchubup_setup_timer(struct dce_hwseq *hws)
+{
+	REG_WRITE(REFCLK_CNTL, 0);
+
+	REG_UPDATE(DCHUBBUB_GLOBAL_TIMER_CNTL, DCHUBBUB_GLOBAL_TIMER_ENABLE, 1);
+}
+
 static void init_hw(struct core_dc *dc)
 {
 	int i;
-	struct dc_bios *bp;
 	struct transform *xfm;
 	struct abm *abm;
+	struct dce_hwseq *hws = dc->hwseq;
 
-	bp = dc->ctx->dc_bios;
-
+#if 1
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
-		/* TODO: this will be moved to Diag or BIOS */
-		dchubup_setup_timer(dc->ctx);
+		dchubup_setup_timer(dc->hwseq);
 
 		/* TODO: dchubp_map_fb_to_mc will be moved to dchub interface
 		 * between dc and kmd
 		 */
-		dchubp_map_fb_to_mc(dc->ctx);
+		/*dchubp_map_fb_to_mc(dc->hwseq);*/
+		REG_WRITE(DIO_MEM_PWR_CTRL, 0);
+
+		if (!dc->public.debug.disable_clock_gate) {
+			/* enable all DCN clock gating */
+			REG_WRITE(DCCG_GATE_DISABLE_CNTL, 0);
 
-		enable_power_gating_plane(dc->ctx, true);
+			REG_WRITE(DCCG_GATE_DISABLE_CNTL2, 0);
+
+			REG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);
+		}
+
+		enable_power_gating_plane(dc->hwseq, true);
 		return;
 	}
 	/* end of FPGA. Below if real ASIC */
+#endif
 
 	bios_golden_init(dc);
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		xfm = dc->res_pool->transforms[i];
 		xfm->funcs->transform_reset(xfm);
-
-		/* TODOFPGA: may need later */
-#if 0
-		xfm->funcs->transform_power_up(xfm);
-		dc->hwss.enable_display_pipe_clock_gating(
-			dc->ctx,
-			true);
-#endif
 	}
-	/* TODOFPGA: light sleep */
-#if 0
-	dc->hwss.clock_gating_power_up(dc->ctx, false);
-#endif
 
 	for (i = 0; i < dc->link_count; i++) {
 		/* Power up AND update implementation according to the
@@ -601,67 +344,18 @@ static void init_hw(struct core_dc *dc)
 	}
 
 	/* power AFMT HDMI memory TODO: may move to dis/en output save power*/
-	generic_reg_set_soc15(dc->ctx, 0, DIO_MEM_PWR_CTRL, 7,
-			FD(DIO_MEM_PWR_CTRL__HDMI0_MEM_PWR_FORCE), 0,
-			FD(DIO_MEM_PWR_CTRL__HDMI1_MEM_PWR_FORCE), 0,
-			FD(DIO_MEM_PWR_CTRL__HDMI2_MEM_PWR_FORCE), 0,
-			FD(DIO_MEM_PWR_CTRL__HDMI3_MEM_PWR_FORCE), 0,
-			FD(DIO_MEM_PWR_CTRL__HDMI4_MEM_PWR_FORCE), 0,
-			FD(DIO_MEM_PWR_CTRL__HDMI5_MEM_PWR_FORCE), 0,
-			FD(DIO_MEM_PWR_CTRL__HDMI6_MEM_PWR_FORCE), 0);
+	REG_WRITE(DIO_MEM_PWR_CTRL, 0);
 
 	if (!dc->public.debug.disable_clock_gate) {
 		/* enable all DCN clock gating */
-		generic_reg_set_soc15(dc->ctx, 0, DCCG_GATE_DISABLE_CNTL, 19,
-				FD(DCCG_GATE_DISABLE_CNTL__DISPCLK_DCCG_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__DISPCLK_R_DCCG_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__SOCCLK_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__DPREFCLK_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__DACACLK_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__DVOACLK_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__DPREFCLK_R_DCCG_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__DPPCLK_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__AOMCLK0_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__AOMCLK1_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__AOMCLK2_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__AUDIO_DTO2_CLK_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__DPREFCLK_GTC_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__UNB_DB_CLK_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__REFCLK_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__REFCLK_R_DIG_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__DSICLK_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__BYTECLK_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL__ESCCLK_GATE_DISABLE), 0);
-
-		generic_reg_set_soc15(dc->ctx, 0, DCCG_GATE_DISABLE_CNTL2, 14,
-				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKA_FE_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKB_FE_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKC_FE_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKD_FE_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKE_FE_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKF_FE_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKG_FE_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKA_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKB_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKC_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKD_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKE_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKF_GATE_DISABLE), 0,
-				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKG_GATE_DISABLE), 0);
-
-		generic_reg_update_soc15(dc->ctx, 0, DCFCLK_CNTL, 1,
-				FD(DCFCLK_CNTL__DCFCLK_GATE_DIS), 0);
-	}
+		REG_WRITE(DCCG_GATE_DISABLE_CNTL, 0);
 
-	/* This power gating should be one-time program for DAL.
-	 * It can only change by registry key
-	 * TODO: new task will for this.
-	 * if power gating is disable, power_on_plane and power_off_plane
-	 * should be skip. Otherwise, hand will be met in power_off_plane
-	 */
-	enable_power_gating_plane(dc->ctx, true);
+		REG_WRITE(DCCG_GATE_DISABLE_CNTL2, 0);
 
+		REG_UPDATE(DCFCLK_CNTL, DCFCLK_GATE_DIS, 0);
+	}
 
+	enable_power_gating_plane(dc->hwseq, true);
 }
 
 static enum dc_status dcn10_prog_pixclk_crtc_otg(
@@ -759,9 +453,6 @@ static void reset_back_end_for_pipe(
 		struct validate_context *context)
 {
 	int i;
-	struct dc_bios *bp;
-
-	bp = dc->ctx->dc_bios;
 
 	if (pipe_ctx->stream_enc == NULL) {
 		pipe_ctx->stream = NULL;
@@ -807,6 +498,7 @@ static void reset_front_end(
 		struct core_dc *dc,
 		int fe_idx)
 {
+	struct dce_hwseq *hws = dc->hwseq;
 	struct mpcc_cfg mpcc_cfg;
 	struct mem_input *mi = dc->res_pool->mis[fe_idx];
 	struct transform *xfm = dc->res_pool->transforms[fe_idx];
@@ -826,11 +518,14 @@ static void reset_front_end(
 	mpcc_cfg.top_of_tree = tg->inst == mpcc->inst;
 	mpcc->funcs->set(mpcc, &mpcc_cfg);
 
-	unlock_master_tg_and_wait(dc->ctx, tg->inst);
+	REG_UPDATE(OTG_GLOBAL_SYNC_STATUS[tg->inst], VUPDATE_NO_LOCK_EVENT_CLEAR, 1);
+	tg->funcs->unlock(tg);
+	REG_WAIT(OTG_GLOBAL_SYNC_STATUS[tg->inst], VUPDATE_NO_LOCK_EVENT_OCCURRED, 1, 20000, 200000);
+
 	mpcc->funcs->wait_for_idle(mpcc);
 	mi->funcs->set_blank(mi, true);
-	wait_no_outstanding_request(dc->ctx, fe_idx);
-	disable_clocks(dc->ctx, fe_idx);
+	REG_WAIT(DCHUBP_CNTL[fe_idx], HUBP_NO_OUTSTANDING_REQ, 1, 20000, 200000);
+	disable_clocks(dc->hwseq, fe_idx);
 
 	xfm->funcs->transform_reset(xfm);
 
@@ -841,16 +536,15 @@ static void reset_front_end(
 
 static void dcn10_power_down_fe(struct core_dc *dc, int fe_idx)
 {
-	struct dc_context *ctx = dc->ctx;
-	uint32_t inst_offset = 0;
+	struct dce_hwseq *hws = dc->hwseq;
 
 	reset_front_end(dc, fe_idx);
 
-	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
+	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 1);
-	dpp_pg_control(ctx, fe_idx, false);
-	hubp_pg_control(ctx, fe_idx, false);
-	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
+	dpp_pg_control(hws, fe_idx, false);
+	hubp_pg_control(hws, fe_idx, false);
+	REG_SET(DC_IP_REQUEST_CNTL, 0,
 			IP_REQUEST_EN, 0);
 	dm_logger_write(dc->ctx->logger, LOG_DC,
 			"Power gated front end %d\n", fe_idx);
@@ -1538,18 +1232,13 @@ static void dcn10_power_on_fe(
 	struct validate_context *context)
 {
 	struct dc_surface *dc_surface = &pipe_ctx->surface->public;
+	struct dce_hwseq *hws = dc->hwseq;
 
-	power_on_plane(dc->ctx,
+	power_on_plane(dc->hwseq,
 		pipe_ctx->pipe_idx);
 
 	/* enable DCFCLK current DCHUB */
-	enable_dcfclk(dc->ctx,
-			pipe_ctx->pipe_idx,
-			pipe_ctx->pix_clk_params.requested_pix_clk,
-			context->bw.dcn.calc_clk.dppclk_div);
-	dc->current_context->bw.dcn.cur_clk.dppclk_div =
-			context->bw.dcn.calc_clk.dppclk_div;
-	context->bw.dcn.cur_clk.dppclk_div = context->bw.dcn.calc_clk.dppclk_div;
+	REG_UPDATE(HUBP_CLK_CNTL[pipe_ctx->pipe_idx], HUBP_CLOCK_ENABLE, 1);
 
 	if (dc_surface) {
 		dm_logger_write(dc->ctx->logger, LOG_DC,
@@ -1706,6 +1395,7 @@ static void update_dchubp_dpp(
 	struct pipe_ctx *pipe_ctx,
 	struct validate_context *context)
 {
+	struct dce_hwseq *hws = dc->hwseq;
 	struct mem_input *mi = pipe_ctx->mi;
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
 	struct core_surface *surface = pipe_ctx->surface;
@@ -1718,7 +1408,7 @@ static void update_dchubp_dpp(
 	/* TODO: proper fix once fpga works */
 	/* depends on DML calculation, DPP clock value may change dynamically */
 	enable_dppclk(
-		dc->ctx,
+		dc->hwseq,
 		pipe_ctx->pipe_idx,
 		pipe_ctx->pix_clk_params.requested_pix_clk,
 		context->bw.dcn.calc_clk.dppclk_div);
@@ -1726,7 +1416,11 @@ static void update_dchubp_dpp(
 			context->bw.dcn.calc_clk.dppclk_div;
 	context->bw.dcn.cur_clk.dppclk_div = context->bw.dcn.calc_clk.dppclk_div;
 
-	select_vtg(dc->ctx, pipe_ctx->pipe_idx, pipe_ctx->tg->inst);
+	/* TODO: Need input parameter to tell current DCHUB pipe tie to which OTG
+	 * VTG is within DCHUBBUB which is commond block share by each pipe HUBP.
+	 * VTG is 1:1 mapping with OTG. Each pipe HUBP will select which VTG
+	 */
+	REG_UPDATE(DCHUBP_CNTL[pipe_ctx->pipe_idx], HUBP_VTG_SEL, pipe_ctx->tg->inst);
 
 	update_plane_addr(dc, pipe_ctx);
 

commit cdc5e04888cec337e44049f9b51d8894364ad52a
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Wed Jun 28 13:36:25 2017 -0500

    drm/amd/display: Fix for hdmi frame pack stereo
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index cc67707b56d0..d38570e6d4d2 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -891,7 +891,6 @@ static void reset_hw_ctx_wrap(
 	}
 }
 
-
 static bool patch_address_for_sbs_tb_stereo(
 		struct pipe_ctx *pipe_ctx, PHYSICAL_ADDRESS_LOC *addr)
 {
@@ -904,11 +903,17 @@ static bool patch_address_for_sbs_tb_stereo(
 		 pipe_ctx->stream->public.timing.timing_3d_format ==
 		 TIMING_3D_FORMAT_TOP_AND_BOTTOM)) {
 		*addr = surface->public.address.grph_stereo.left_addr;
-		surface->public.address.grph_stereo.left_addr =\
+		surface->public.address.grph_stereo.left_addr =
 		surface->public.address.grph_stereo.right_addr;
 		return true;
+	} else {
+		if (pipe_ctx->stream->public.view_format != VIEW_3D_FORMAT_NONE &&
+			surface->public.address.type != PLN_ADDR_TYPE_GRPH_STEREO) {
+			surface->public.address.type = PLN_ADDR_TYPE_GRPH_STEREO;
+			surface->public.address.grph_stereo.right_addr =
+			surface->public.address.grph_stereo.left_addr;
+		}
 	}
-
 	return false;
 }
 

commit 46239f739aa64c797938e9a14b03fd2c1b8ce0e6
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Thu Jun 29 20:25:23 2017 -0400

    drm/amd/display: Enabling VSR on 4K display causes black screen
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f404e4e5e4ea..cc67707b56d0 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1819,7 +1819,7 @@ static void program_all_pipe_in_tree(
 		pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, !is_pipe_tree_visible(pipe_ctx));
 	}
 
-	if (pipe_ctx->surface->public.visible) {
+	if (pipe_ctx->surface != NULL) {
 		dcn10_power_on_fe(dc, pipe_ctx, context);
 		update_dchubp_dpp(dc, pipe_ctx, context);
 	}

commit abe07e80836fb25a5bcfda573413a68be82439c6
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Wed Jun 28 17:21:42 2017 -0400

    drm/amd/display: Add DC interface for custom CSC matrix
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Vitaly Prosyak <Vitaly.Prosyak@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index d0bddfd64c67..f404e4e5e4ea 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1623,6 +1623,28 @@ static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
 }
 
+
+static void program_csc_matrix(struct pipe_ctx *pipe_ctx,
+		enum dc_color_space colorspace,
+		uint16_t *matrix)
+{
+	int i;
+	struct out_csc_color_matrix tbl_entry;
+
+	if (pipe_ctx->stream->public.csc_color_matrix.enable_adjustment
+				== true) {
+			enum dc_color_space color_space =
+				pipe_ctx->stream->public.output_color_space;
+
+			//uint16_t matrix[12];
+			for (i = 0; i < 12; i++)
+				tbl_entry.regval[i] = pipe_ctx->stream->public.csc_color_matrix.matrix[i];
+
+			tbl_entry.color_space = color_space;
+			//tbl_entry.regval = matrix;
+			pipe_ctx->opp->funcs->opp_set_csc_adjustment(pipe_ctx->opp, &tbl_entry);
+	}
+}
 static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 {
 	if (pipe_ctx->surface->public.visible)
@@ -2103,6 +2125,7 @@ static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx,
 
 static const struct hw_sequencer_funcs dcn10_funcs = {
 	.program_gamut_remap = program_gamut_remap,
+	.program_csc_matrix = program_csc_matrix,
 	.init_hw = init_hw,
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
 	.apply_ctx_for_surface = dcn10_apply_ctx_for_surface,

commit cfe4645e17f8dbe680c35c439d000313f2648482
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jun 14 18:58:04 2017 -0400

    drm/amd/display: fix dcn pipe reset sequence
    
    This change fixes dcn10 front end reset sequence. Previously we
    would reset front end during flip which led to issues
    in certain MPO and 4k/5k scenarios. We would also never properly
    power gate our front end.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index edcd7369cf9d..d0bddfd64c67 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -116,18 +116,6 @@ static const struct dcn10_hwseq_reg_offsets reg_offsets[] = {
 		HWSEQ_REG_SET_N(reg, 1, FD(reg##__##field), val)
 
 /* TODO should be moved to OTG */
-static void lock_otg_master_update(
-	struct dc_context *ctx,
-	uint8_t inst)
-{
-	uint32_t inst_offset = reg_offsets[inst].otg;
-
-	HWSEQ_REG_UPDATE(OTG0_OTG_GLOBAL_CONTROL0,
-			OTG_MASTER_UPDATE_LOCK_SEL, inst);
-
-	HWSEQ_REG_UPDATE(OTG0_OTG_MASTER_UPDATE_LOCK,
-			OTG_MASTER_UPDATE_LOCK, 1);
-}
 
 static bool unlock_master_tg_and_wait(
 	struct dc_context *ctx,
@@ -148,19 +136,6 @@ static bool unlock_master_tg_and_wait(
 	return true;
 }
 
-/* TODO: should be  moved to OTG ? */
-static void unlock_otg_master(
-	struct dc_context *ctx,
-	uint8_t inst)
-{
-	uint32_t inst_offset = reg_offsets[inst].otg;
-
-	/* unlock master locker */
-	HWSEQ_REG_UPDATE(OTG0_OTG_MASTER_UPDATE_LOCK,
-			OTG_MASTER_UPDATE_LOCK, 0);
-}
-
-
 static void wait_no_outstanding_request(
 	struct dc_context *ctx,
 	uint8_t plane_id)
@@ -489,8 +464,7 @@ static void hubp_pg_control(
 
 static void power_on_plane(
 	struct dc_context *ctx,
-	uint8_t plane_id,
-	uint8_t inst)
+	int plane_id)
 {
 	uint32_t inst_offset = 0;
 
@@ -500,6 +474,8 @@ static void power_on_plane(
 	hubp_pg_control(ctx, plane_id, true);
 	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
 			IP_REQUEST_EN, 0);
+	dm_logger_write(ctx->logger, LOG_DC,
+			"Un-gated front end for pipe %d\n", plane_id);
 }
 
 /* fully check bios enabledisplaypowergating table. dal only need dce init
@@ -596,13 +572,13 @@ static void init_hw(struct core_dc *dc)
 				dc->res_pool->mpcc[i];
 		struct mpcc_cfg mpcc_cfg;
 
-		lock_otg_master_update(dc->ctx, tg->inst);
+		tg->funcs->lock(tg);
 		mpcc_cfg.opp_id = 0xf;
 		mpcc_cfg.top_dpp_id = 0xf;
 		mpcc_cfg.bot_mpcc_id = 0xf;
 		mpcc_cfg.top_of_tree = true;
 		mpcc->funcs->set(mpcc, &mpcc_cfg);
-		unlock_otg_master(dc->ctx, tg->inst);
+		tg->funcs->unlock(tg);
 
 		tg->funcs->disable_vga(tg);
 		/* Blank controller using driver code instead of
@@ -822,56 +798,85 @@ static void reset_back_end_for_pipe(
 		return;
 
 	pipe_ctx->stream = NULL;
+	dm_logger_write(dc->ctx->logger, LOG_DC,
+					"Reset back end for pipe %d, tg:%d\n",
+					pipe_ctx->pipe_idx, pipe_ctx->tg->inst);
 }
 
-static void reset_front_end_for_pipe(
+static void reset_front_end(
 		struct core_dc *dc,
-		struct pipe_ctx *pipe_ctx,
-		struct validate_context *context)
+		int fe_idx)
 {
 	struct mpcc_cfg mpcc_cfg;
+	struct mem_input *mi = dc->res_pool->mis[fe_idx];
+	struct transform *xfm = dc->res_pool->transforms[fe_idx];
+	struct mpcc *mpcc = dc->res_pool->mpcc[fe_idx];
+	struct timing_generator *tg = dc->res_pool->timing_generators[mpcc->opp_id];
 
-	if (!pipe_ctx->surface)
+	/*Already reset*/
+	if (mpcc->opp_id == 0xf)
 		return;
 
-	pipe_ctx->mi->funcs->dcc_control(pipe_ctx->mi, false, false);
-
-	lock_otg_master_update(dc->ctx, pipe_ctx->tg->inst);
+	mi->funcs->dcc_control(mi, false, false);
+	tg->funcs->lock(tg);
 
 	mpcc_cfg.opp_id = 0xf;
 	mpcc_cfg.top_dpp_id = 0xf;
 	mpcc_cfg.bot_mpcc_id = 0xf;
-	mpcc_cfg.top_of_tree = !pipe_ctx->top_pipe;
-	pipe_ctx->mpcc->funcs->set(pipe_ctx->mpcc, &mpcc_cfg);
-
-	pipe_ctx->top_pipe = NULL;
-	pipe_ctx->bottom_pipe = NULL;
+	mpcc_cfg.top_of_tree = tg->inst == mpcc->inst;
+	mpcc->funcs->set(mpcc, &mpcc_cfg);
 
-	unlock_master_tg_and_wait(dc->ctx, pipe_ctx->tg->inst);
+	unlock_master_tg_and_wait(dc->ctx, tg->inst);
+	mpcc->funcs->wait_for_idle(mpcc);
+	mi->funcs->set_blank(mi, true);
+	wait_no_outstanding_request(dc->ctx, fe_idx);
+	disable_clocks(dc->ctx, fe_idx);
 
-	pipe_ctx->mi->funcs->set_blank(pipe_ctx->mi, true);
+	xfm->funcs->transform_reset(xfm);
 
-	wait_no_outstanding_request(dc->ctx, pipe_ctx->pipe_idx);
+	dm_logger_write(dc->ctx->logger, LOG_DC,
+					"Reset front end %d\n",
+					fe_idx);
+}
 
-	disable_clocks(dc->ctx, pipe_ctx->pipe_idx);
+static void dcn10_power_down_fe(struct core_dc *dc, int fe_idx)
+{
+	struct dc_context *ctx = dc->ctx;
+	uint32_t inst_offset = 0;
 
-	pipe_ctx->xfm->funcs->transform_reset(pipe_ctx->xfm);
+	reset_front_end(dc, fe_idx);
 
+	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
+			IP_REQUEST_EN, 1);
+	dpp_pg_control(ctx, fe_idx, false);
+	hubp_pg_control(ctx, fe_idx, false);
+	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
+			IP_REQUEST_EN, 0);
 	dm_logger_write(dc->ctx->logger, LOG_DC,
-					"Reset front end for pipe %d\n",
-					pipe_ctx->pipe_idx);
-
-	pipe_ctx->surface = NULL;
+			"Power gated front end %d\n", fe_idx);
 }
 
-static void reset_hw_ctx(struct core_dc *dc,
-		struct validate_context *context,
-		void (*reset)(struct core_dc *dc,
-				struct pipe_ctx *pipe_ctx,
-				struct validate_context *context))
+static void reset_hw_ctx_wrap(
+		struct core_dc *dc,
+		struct validate_context *context)
 {
 	int i;
 
+	/* Reset Front End*/
+	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
+		struct pipe_ctx *pipe_ctx_old =
+			&dc->current_context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		/*if (!pipe_ctx_old->stream)
+			continue;*/
+
+		if (!pipe_ctx->stream || !pipe_ctx->surface)
+			dcn10_power_down_fe(dc, i);
+		else if (pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
+			reset_front_end(dc, i);
+	}
+	/* Reset Back End*/
 	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
 		struct pipe_ctx *pipe_ctx_old =
 			&dc->current_context->res_ctx.pipe_ctx[i];
@@ -882,23 +887,13 @@ static void reset_hw_ctx(struct core_dc *dc,
 
 		if (!pipe_ctx->stream ||
 				pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
-			reset(dc, pipe_ctx_old, dc->current_context);
+			reset_back_end_for_pipe(dc, pipe_ctx_old, dc->current_context);
 	}
 }
 
-static void reset_hw_ctx_wrap(
-		struct core_dc *dc,
-		struct validate_context *context)
-{
-	/* Reset Front End*/
-	reset_hw_ctx(dc, context, reset_front_end_for_pipe);
-	/* Reset Back End*/
-	reset_hw_ctx(dc, context, reset_back_end_for_pipe);
-}
-
 
-static bool patch_address_for_sbs_tb_stereo(struct pipe_ctx *pipe_ctx,
-											PHYSICAL_ADDRESS_LOC *addr)
+static bool patch_address_for_sbs_tb_stereo(
+		struct pipe_ctx *pipe_ctx, PHYSICAL_ADDRESS_LOC *addr)
 {
 	struct core_surface *surface = pipe_ctx->surface;
 	bool sec_split = pipe_ctx->top_pipe &&
@@ -936,8 +931,7 @@ static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ct
 }
 
 static bool dcn10_set_input_transfer_func(
-	struct pipe_ctx *pipe_ctx,
-	const struct core_surface *surface)
+	struct pipe_ctx *pipe_ctx, const struct core_surface *surface)
 {
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
 	const struct core_transfer_func *tf = NULL;
@@ -950,8 +944,8 @@ static bool dcn10_set_input_transfer_func(
 		tf = DC_TRANSFER_FUNC_TO_CORE(surface->public.in_transfer_func);
 
 	if (surface->public.gamma_correction && dce_use_lut(surface))
-	    ipp->funcs->ipp_program_input_lut(ipp,
-			    surface->public.gamma_correction);
+		ipp->funcs->ipp_program_input_lut(ipp,
+				surface->public.gamma_correction);
 
 	if (tf == NULL)
 		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
@@ -1333,8 +1327,6 @@ static void dcn10_pipe_control_lock(
 	struct pipe_ctx *pipe,
 	bool lock)
 {
-	struct dce_hwseq *hws = hws = dc->hwseq;
-
 	/* use TG master update lock to lock everything on the TG
 	 * therefore only top pipe need to lock
 	 */
@@ -1342,9 +1334,9 @@ static void dcn10_pipe_control_lock(
 		return;
 
 	if (lock)
-		dcn10_lock(pipe->tg);
+		pipe->tg->funcs->lock(pipe->tg);
 	else
-		dcn10_unlock(pipe->tg);
+		pipe->tg->funcs->unlock(pipe->tg);
 }
 
 static bool wait_for_reset_trigger_to_occur(
@@ -1543,7 +1535,7 @@ static void dcn10_power_on_fe(
 	struct dc_surface *dc_surface = &pipe_ctx->surface->public;
 
 	power_on_plane(dc->ctx,
-		pipe_ctx->pipe_idx, pipe_ctx->tg->inst);
+		pipe_ctx->pipe_idx);
 
 	/* enable DCFCLK current DCHUB */
 	enable_dcfclk(dc->ctx,
@@ -1694,7 +1686,6 @@ static void update_dchubp_dpp(
 	struct default_adjustment ocsc = {0};
 	struct tg_color black_color = {0};
 	struct mpcc_cfg mpcc_cfg;
-	struct pipe_ctx *top_pipe;
 	bool per_pixel_alpha = surface->public.per_pixel_alpha && pipe_ctx->bottom_pipe;
 
 	/* TODO: proper fix once fpga works */
@@ -1734,14 +1725,13 @@ static void update_dchubp_dpp(
 			IPP_OUTPUT_FORMAT_12_BIT_FIX);
 
 	pipe_ctx->scl_data.lb_params.alpha_en = per_pixel_alpha;
-	for (top_pipe = pipe_ctx; top_pipe != NULL; top_pipe = top_pipe->top_pipe)
-		mpcc_cfg.opp_id = top_pipe->opp->inst;
 	mpcc_cfg.top_dpp_id = pipe_ctx->pipe_idx;
 	if (pipe_ctx->bottom_pipe)
 		mpcc_cfg.bot_mpcc_id = pipe_ctx->bottom_pipe->mpcc->inst;
 	else
 		mpcc_cfg.bot_mpcc_id = 0xf;
-	mpcc_cfg.top_of_tree = !pipe_ctx->top_pipe;
+	mpcc_cfg.opp_id = pipe_ctx->tg->inst;
+	mpcc_cfg.top_of_tree = pipe_ctx->pipe_idx == pipe_ctx->tg->inst;
 	mpcc_cfg.per_pixel_alpha = per_pixel_alpha;
 	/* DCN1.0 has output CM before MPC which seems to screw with
 	 * pre-multiplied alpha.
@@ -1749,8 +1739,6 @@ static void update_dchubp_dpp(
 	mpcc_cfg.pre_multiplied_alpha = is_rgb_cspace(
 			pipe_ctx->stream->public.output_color_space)
 					&& per_pixel_alpha;
-	if (!dc->current_context->res_ctx.pipe_ctx[pipe_ctx->pipe_idx].surface)
-		pipe_ctx->mpcc->funcs->wait_for_idle(pipe_ctx->mpcc);
 	pipe_ctx->mpcc->funcs->set(pipe_ctx->mpcc, &mpcc_cfg);
 
 	color_space_to_black_color(
@@ -1796,7 +1784,7 @@ static void program_all_pipe_in_tree(
 		/* watermark is for all pipes */
 		pipe_ctx->mi->funcs->program_watermarks(
 				pipe_ctx->mi, &context->bw.dcn.watermarks, ref_clk_mhz);
-		lock_otg_master_update(dc->ctx, pipe_ctx->tg->inst);
+		pipe_ctx->tg->funcs->lock(pipe_ctx->tg);
 
 		pipe_ctx->tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
 		pipe_ctx->tg->dlg_otg_param.vstartup_start = pipe_ctx->pipe_dlg_param.vstartup_start;
@@ -1852,13 +1840,41 @@ static void dcn10_apply_ctx_for_surface(
 {
 	int i;
 
+	/* reset unused mpcc */
+	/*for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *old_pipe_ctx =
+				&dc->current_context->res_ctx.pipe_ctx[i];
+
+		if ((!pipe_ctx->surface && old_pipe_ctx->surface)
+				|| (!pipe_ctx->stream && old_pipe_ctx->stream)) {
+			struct mpcc_cfg mpcc_cfg;
+
+			mpcc_cfg.opp_id = 0xf;
+			mpcc_cfg.top_dpp_id = 0xf;
+			mpcc_cfg.bot_mpcc_id = 0xf;
+			mpcc_cfg.top_of_tree = !old_pipe_ctx->top_pipe;
+			old_pipe_ctx->mpcc->funcs->set(old_pipe_ctx->mpcc, &mpcc_cfg);
+
+			old_pipe_ctx->top_pipe = NULL;
+			old_pipe_ctx->bottom_pipe = NULL;
+			old_pipe_ctx->surface = NULL;
+
+			dm_logger_write(dc->ctx->logger, LOG_DC,
+					"Reset mpcc for pipe %d\n",
+					old_pipe_ctx->pipe_idx);
+		}
+	}*/
+
+	if (!surface)
+		return;
+
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		if (!pipe_ctx->surface || pipe_ctx->surface != surface)
+		if (pipe_ctx->surface != surface)
 			continue;
 
-
 		/* looking for top pipe to program */
 		if (!pipe_ctx->top_pipe)
 			program_all_pipe_in_tree(dc, pipe_ctx, context);
@@ -1910,27 +1926,6 @@ static void dcn10_apply_ctx_for_surface(
 			context->bw.dcn.watermarks.d.cstate_pstate.pstate_change_ns,
 			context->bw.dcn.watermarks.d.pte_meta_urgent_ns
 			);
-
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-
-		if (!pipe_ctx->surface || pipe_ctx->top_pipe)
-			continue;
-
-		/* unlock master update lock */
-		unlock_otg_master(dc->ctx, pipe_ctx->tg->inst);
-	}
-
-	/* reset unused pipe */
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-		struct pipe_ctx *old_pipe_ctx =
-				&dc->current_context->res_ctx.pipe_ctx[i];
-
-		if ((!pipe_ctx->surface && old_pipe_ctx->surface)
-				|| (!pipe_ctx->stream && old_pipe_ctx->stream))
-			reset_front_end_for_pipe(dc, old_pipe_ctx, dc->current_context);
-	}
 }
 
 static void dcn10_set_bandwidth(
@@ -1992,23 +1987,6 @@ static void dcn10_set_bandwidth(
 	dcn10_pplib_apply_display_requirements(dc, context);
 }
 
-static void dcn10_power_down_fe(struct core_dc *dc, struct pipe_ctx *pipe)
-{
-	struct dc_context *ctx = dc->ctx;
-	uint32_t inst_offset = 0;
-
-	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
-			IP_REQUEST_EN, 1);
-	dpp_pg_control(ctx, pipe->pipe_idx, false);
-	hubp_pg_control(ctx, pipe->pipe_idx, false);
-	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
-			IP_REQUEST_EN, 0);
-
-	if (pipe->xfm)
-		pipe->xfm->funcs->transform_reset(pipe->xfm);
-	memset(&pipe->scl_data, 0, sizeof(pipe->scl_data));
-}
-
 static void set_drr(struct pipe_ctx **pipe_ctx,
 		int num_pipes, int vmin, int vmax)
 {

commit 7f5c22d1652327b64375e88b184b0df502c7bdc7
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Thu Jun 8 15:55:02 2017 -0500

    drm/amd/display: RV stereo support
    
    HDMI frame pack and DP frame alternate in band
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f41230013309..edcd7369cf9d 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -896,8 +896,9 @@ static void reset_hw_ctx_wrap(
 	reset_hw_ctx(dc, context, reset_back_end_for_pipe);
 }
 
-static bool patch_address_for_sbs_tb_stereo(
-		struct pipe_ctx *pipe_ctx, PHYSICAL_ADDRESS_LOC *addr)
+
+static bool patch_address_for_sbs_tb_stereo(struct pipe_ctx *pipe_ctx,
+											PHYSICAL_ADDRESS_LOC *addr)
 {
 	struct core_surface *surface = pipe_ctx->surface;
 	bool sec_split = pipe_ctx->top_pipe &&
@@ -912,6 +913,7 @@ static bool patch_address_for_sbs_tb_stereo(
 		surface->public.address.grph_stereo.right_addr;
 		return true;
 	}
+
 	return false;
 }
 
@@ -2061,6 +2063,66 @@ static void set_plane_config(
 	program_gamut_remap(pipe_ctx);
 }
 
+static void dcn10_config_stereo_parameters(struct core_stream *stream,\
+										   struct crtc_stereo_flags *flags)
+{
+	enum view_3d_format view_format = stream->public.view_format;
+	enum dc_timing_3d_format timing_3d_format =\
+			stream->public.timing.timing_3d_format;
+	bool non_stereo_timing = false;
+
+	if (timing_3d_format == TIMING_3D_FORMAT_NONE ||
+		timing_3d_format == TIMING_3D_FORMAT_SIDE_BY_SIDE ||
+		timing_3d_format == TIMING_3D_FORMAT_TOP_AND_BOTTOM)
+		non_stereo_timing = true;
+
+	if (non_stereo_timing == false &&
+		view_format == VIEW_3D_FORMAT_FRAME_SEQUENTIAL) {
+
+		flags->PROGRAM_STEREO         = 1;
+		flags->PROGRAM_POLARITY       = 1;
+		if (timing_3d_format == TIMING_3D_FORMAT_INBAND_FA ||
+			timing_3d_format == TIMING_3D_FORMAT_DP_HDMI_INBAND_FA ||
+			timing_3d_format == TIMING_3D_FORMAT_SIDEBAND_FA) {
+			enum display_dongle_type dongle = \
+					stream->sink->link->public.ddc->dongle_type;
+			if (dongle == DISPLAY_DONGLE_DP_VGA_CONVERTER ||
+				dongle == DISPLAY_DONGLE_DP_DVI_CONVERTER ||
+				dongle == DISPLAY_DONGLE_DP_HDMI_CONVERTER)
+				flags->DISABLE_STEREO_DP_SYNC = 1;
+		}
+		flags->RIGHT_EYE_POLARITY =\
+				stream->public.timing.flags.RIGHT_EYE_3D_POLARITY;
+		if (timing_3d_format == TIMING_3D_FORMAT_HW_FRAME_PACKING)
+			flags->FRAME_PACKED = 1;
+	}
+
+	return;
+}
+
+static void dcn10_setup_stereo(struct pipe_ctx *pipe_ctx,
+								struct core_dc *dc)
+{
+	struct crtc_stereo_flags flags = { 0 };
+	struct core_stream *stream = pipe_ctx->stream;
+
+	dcn10_config_stereo_parameters(stream, &flags);
+
+	pipe_ctx->opp->funcs->opp_set_stereo_polarity(
+		pipe_ctx->opp,
+		flags.PROGRAM_STEREO == 1 ? true:false,
+		stream->public.timing.flags.RIGHT_EYE_3D_POLARITY == 1 ? true:false);
+
+	pipe_ctx->tg->funcs->program_stereo(
+		pipe_ctx->tg,
+		&stream->public.timing,
+		&flags);
+
+
+
+	return;
+}
+
 static const struct hw_sequencer_funcs dcn10_funcs = {
 	.program_gamut_remap = program_gamut_remap,
 	.init_hw = init_hw,
@@ -2088,7 +2150,8 @@ static const struct hw_sequencer_funcs dcn10_funcs = {
 	.prog_pixclk_crtc_otg = dcn10_prog_pixclk_crtc_otg,
 	.set_drr = set_drr,
 	.get_position = get_position,
-	.set_static_screen_control = set_static_screen_control
+	.set_static_screen_control = set_static_screen_control,
+	.setup_stereo = dcn10_setup_stereo
 };
 
 

commit ad32734699da4dd185405637459bf915a4f4cff6
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Jun 5 15:08:10 2017 -0400

    drm/amd/display: w/a for ycbcr output pre-multiplied alpha corruption
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f509dfd97f23..f41230013309 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1658,6 +1658,28 @@ static bool is_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
 	return false;
 }
 
+static bool is_rgb_cspace(enum dc_color_space output_color_space)
+{
+	switch (output_color_space) {
+	case COLOR_SPACE_SRGB:
+	case COLOR_SPACE_SRGB_LIMITED:
+	case COLOR_SPACE_2020_RGB_FULLRANGE:
+	case COLOR_SPACE_2020_RGB_LIMITEDRANGE:
+	case COLOR_SPACE_ADOBERGB:
+		return true;
+	case COLOR_SPACE_YCBCR601:
+	case COLOR_SPACE_YCBCR709:
+	case COLOR_SPACE_YCBCR601_LIMITED:
+	case COLOR_SPACE_YCBCR709_LIMITED:
+	case COLOR_SPACE_2020_YCBCR:
+		return false;
+	default:
+		/* Add a case to switch */
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+}
+
 static void update_dchubp_dpp(
 	struct core_dc *dc,
 	struct pipe_ctx *pipe_ctx,
@@ -1719,6 +1741,12 @@ static void update_dchubp_dpp(
 		mpcc_cfg.bot_mpcc_id = 0xf;
 	mpcc_cfg.top_of_tree = !pipe_ctx->top_pipe;
 	mpcc_cfg.per_pixel_alpha = per_pixel_alpha;
+	/* DCN1.0 has output CM before MPC which seems to screw with
+	 * pre-multiplied alpha.
+	 */
+	mpcc_cfg.pre_multiplied_alpha = is_rgb_cspace(
+			pipe_ctx->stream->public.output_color_space)
+					&& per_pixel_alpha;
 	if (!dc->current_context->res_ctx.pipe_ctx[pipe_ctx->pipe_idx].surface)
 		pipe_ctx->mpcc->funcs->wait_for_idle(pipe_ctx->mpcc);
 	pipe_ctx->mpcc->funcs->set(pipe_ctx->mpcc, &mpcc_cfg);

commit f0558542a72e72919dae2ac2187847ec312c2bcb
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Jun 1 18:35:54 2017 -0400

    drm/amd/display: redesign mpc
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f2b581faa9b7..f509dfd97f23 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -592,9 +592,19 @@ static void init_hw(struct core_dc *dc)
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct timing_generator *tg =
 				dc->res_pool->timing_generators[i];
+		struct mpcc *mpcc =
+				dc->res_pool->mpcc[i];
+		struct mpcc_cfg mpcc_cfg;
+
+		lock_otg_master_update(dc->ctx, tg->inst);
+		mpcc_cfg.opp_id = 0xf;
+		mpcc_cfg.top_dpp_id = 0xf;
+		mpcc_cfg.bot_mpcc_id = 0xf;
+		mpcc_cfg.top_of_tree = true;
+		mpcc->funcs->set(mpcc, &mpcc_cfg);
+		unlock_otg_master(dc->ctx, tg->inst);
 
 		tg->funcs->disable_vga(tg);
-
 		/* Blank controller using driver code instead of
 		 * command table.
 		 */
@@ -819,8 +829,7 @@ static void reset_front_end_for_pipe(
 		struct pipe_ctx *pipe_ctx,
 		struct validate_context *context)
 {
-	struct dcn10_mpc *mpc = TO_DCN10_MPC(dc->res_pool->mpc);
-	struct mpc_tree_cfg *tree_cfg = NULL;
+	struct mpcc_cfg mpcc_cfg;
 
 	if (!pipe_ctx->surface)
 		return;
@@ -829,20 +838,14 @@ static void reset_front_end_for_pipe(
 
 	lock_otg_master_update(dc->ctx, pipe_ctx->tg->inst);
 
-	/* TODO: build stream pipes group id. For now, use stream otg
-	 * id as pipe group id
-	 */
-	tree_cfg = &dc->current_context->res_ctx.mpc_tree[pipe_ctx->mpc_idx];
-
-	if (!dcn10_remove_dpp(mpc, tree_cfg, pipe_ctx->pipe_idx)) {
-		dm_logger_write(dc->ctx->logger, LOG_RESOURCE,
-			"%s: failed to find dpp to be removed!\n",
-			__func__);
-	}
+	mpcc_cfg.opp_id = 0xf;
+	mpcc_cfg.top_dpp_id = 0xf;
+	mpcc_cfg.bot_mpcc_id = 0xf;
+	mpcc_cfg.top_of_tree = !pipe_ctx->top_pipe;
+	pipe_ctx->mpcc->funcs->set(pipe_ctx->mpcc, &mpcc_cfg);
 
 	pipe_ctx->top_pipe = NULL;
 	pipe_ctx->bottom_pipe = NULL;
-	pipe_ctx->mpc_idx = -1;
 
 	unlock_master_tg_and_wait(dc->ctx, pipe_ctx->tg->inst);
 
@@ -850,8 +853,6 @@ static void reset_front_end_for_pipe(
 
 	wait_no_outstanding_request(dc->ctx, pipe_ctx->pipe_idx);
 
-	wait_mpcc_idle(mpc, pipe_ctx->pipe_idx);
-
 	disable_clocks(dc->ctx, pipe_ctx->pipe_idx);
 
 	pipe_ctx->xfm->funcs->transform_reset(pipe_ctx->xfm);
@@ -893,14 +894,10 @@ static void reset_hw_ctx_wrap(
 	reset_hw_ctx(dc, context, reset_front_end_for_pipe);
 	/* Reset Back End*/
 	reset_hw_ctx(dc, context, reset_back_end_for_pipe);
-
-	memcpy(context->res_ctx.mpc_tree,
-			dc->current_context->res_ctx.mpc_tree,
-			sizeof(struct mpc_tree_cfg) * dc->res_pool->pipe_count);
 }
 
-static bool patch_address_for_sbs_tb_stereo(struct pipe_ctx *pipe_ctx,
-											PHYSICAL_ADDRESS_LOC *addr)
+static bool patch_address_for_sbs_tb_stereo(
+		struct pipe_ctx *pipe_ctx, PHYSICAL_ADDRESS_LOC *addr)
 {
 	struct core_surface *surface = pipe_ctx->surface;
 	bool sec_split = pipe_ctx->top_pipe &&
@@ -1670,14 +1667,10 @@ static void update_dchubp_dpp(
 	struct input_pixel_processor *ipp = pipe_ctx->ipp;
 	struct core_surface *surface = pipe_ctx->surface;
 	union plane_size size = surface->public.plane_size;
-	struct mpc_tree_cfg *tree_cfg = NULL;
 	struct default_adjustment ocsc = {0};
-	enum dc_color_space color_space;
 	struct tg_color black_color = {0};
-	struct dcn10_mpc *mpc = TO_DCN10_MPC(dc->res_pool->mpc);
-	struct pipe_ctx *temp_pipe;
-	int i;
-	int tree_pos = 0;
+	struct mpcc_cfg mpcc_cfg;
+	struct pipe_ctx *top_pipe;
 	bool per_pixel_alpha = surface->public.per_pixel_alpha && pipe_ctx->bottom_pipe;
 
 	/* TODO: proper fix once fpga works */
@@ -1716,39 +1709,23 @@ static void update_dchubp_dpp(
 			1,
 			IPP_OUTPUT_FORMAT_12_BIT_FIX);
 
-	/* mpc TODO un-hardcode object ids
-	 * for pseudo code pipe_move.c :
-	 * add_plane_mpcc(added_plane_inst, mpcc_inst, ...);
-	 * Do we want to cache the tree_cfg?
-	 */
-
-	/* TODO: build stream pipes group id. For now, use stream otg
-	 * id as pipe group id
-	 */
 	pipe_ctx->scl_data.lb_params.alpha_en = per_pixel_alpha;
-	pipe_ctx->mpc_idx = pipe_ctx->tg->inst;
-	tree_cfg = &context->res_ctx.mpc_tree[pipe_ctx->mpc_idx];
-	if (tree_cfg->num_pipes == 0) {
-		tree_cfg->opp_id = pipe_ctx->tg->inst;
-		for (i = 0; i < MAX_PIPES; i++) {
-			tree_cfg->dpp[i] = 0xf;
-			tree_cfg->mpcc[i] = 0xf;
-		}
-	}
-
-	for (temp_pipe = pipe_ctx->top_pipe;
-			temp_pipe != NULL; temp_pipe = temp_pipe->top_pipe)
-		tree_pos++;
-
-	tree_cfg->dpp[tree_pos] = pipe_ctx->pipe_idx;
-	tree_cfg->mpcc[tree_pos] = pipe_ctx->pipe_idx;
-	tree_cfg->per_pixel_alpha[tree_pos] = per_pixel_alpha;
-	tree_cfg->num_pipes = tree_pos + 1;
-	dcn10_set_mpc_tree(mpc, tree_cfg);
+	for (top_pipe = pipe_ctx; top_pipe != NULL; top_pipe = top_pipe->top_pipe)
+		mpcc_cfg.opp_id = top_pipe->opp->inst;
+	mpcc_cfg.top_dpp_id = pipe_ctx->pipe_idx;
+	if (pipe_ctx->bottom_pipe)
+		mpcc_cfg.bot_mpcc_id = pipe_ctx->bottom_pipe->mpcc->inst;
+	else
+		mpcc_cfg.bot_mpcc_id = 0xf;
+	mpcc_cfg.top_of_tree = !pipe_ctx->top_pipe;
+	mpcc_cfg.per_pixel_alpha = per_pixel_alpha;
+	if (!dc->current_context->res_ctx.pipe_ctx[pipe_ctx->pipe_idx].surface)
+		pipe_ctx->mpcc->funcs->wait_for_idle(pipe_ctx->mpcc);
+	pipe_ctx->mpcc->funcs->set(pipe_ctx->mpcc, &mpcc_cfg);
 
-	color_space = pipe_ctx->stream->public.output_color_space;
-	color_space_to_black_color(dc, color_space, &black_color);
-	dcn10_set_mpc_background_color(mpc, pipe_ctx->pipe_idx, &black_color);
+	color_space_to_black_color(
+		dc, pipe_ctx->stream->public.output_color_space, &black_color);
+	pipe_ctx->mpcc->funcs->set_bg_color(pipe_ctx->mpcc, &black_color);
 
 	pipe_ctx->scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
 	/* scaler configuration */
@@ -1853,13 +1830,8 @@ static void dcn10_apply_ctx_for_surface(
 
 
 		/* looking for top pipe to program */
-		if (!pipe_ctx->top_pipe) {
-			memcpy(context->res_ctx.mpc_tree,
-					dc->current_context->res_ctx.mpc_tree,
-					sizeof(struct mpc_tree_cfg) * dc->res_pool->pipe_count);
-
+		if (!pipe_ctx->top_pipe)
 			program_all_pipe_in_tree(dc, pipe_ctx, context);
-		}
 	}
 
 	dm_logger_write(dc->ctx->logger, LOG_BANDWIDTH_CALCS,
@@ -1927,8 +1899,7 @@ static void dcn10_apply_ctx_for_surface(
 
 		if ((!pipe_ctx->surface && old_pipe_ctx->surface)
 				|| (!pipe_ctx->stream && old_pipe_ctx->stream))
-			reset_front_end_for_pipe(dc,
-					old_pipe_ctx, dc->current_context);
+			reset_front_end_for_pipe(dc, old_pipe_ctx, dc->current_context);
 	}
 }
 

commit 4c6e75989e8edd2bf9c22a70b2a838547cc6c6f3
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Jun 8 14:26:40 2017 -0400

    drm/amd/display: disable dcc when reset front end.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 93a34e2ef175..f2b581faa9b7 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -825,6 +825,8 @@ static void reset_front_end_for_pipe(
 	if (!pipe_ctx->surface)
 		return;
 
+	pipe_ctx->mi->funcs->dcc_control(pipe_ctx->mi, false, false);
+
 	lock_otg_master_update(dc->ctx, pipe_ctx->tg->inst);
 
 	/* TODO: build stream pipes group id. For now, use stream otg

commit c9742685c24acd6d71cdda3067bfc2f512fe2b7c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jun 7 13:53:30 2017 -0400

    drm/amd/display: add bw logging for dcn
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 0a346aafacce..93a34e2ef175 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1412,6 +1412,128 @@ static void dcn10_enable_timing_synchronization(
 	DC_SYNC_INFO("Sync complete\n");
 }
 
+static void print_rq_dlg_ttu(
+		struct core_dc *core_dc,
+		struct pipe_ctx *pipe_ctx)
+{
+	dm_logger_write(core_dc->ctx->logger, LOG_BANDWIDTH_CALCS,
+			"\n============== DML TTU Output parameters [%d] ==============\n"
+			"qos_level_low_wm: %d, \n"
+			"qos_level_high_wm: %d, \n"
+			"min_ttu_vblank: %d, \n"
+			"qos_level_flip: %d, \n"
+			"refcyc_per_req_delivery_l: %d, \n"
+			"qos_level_fixed_l: %d, \n"
+			"qos_ramp_disable_l: %d, \n"
+			"refcyc_per_req_delivery_pre_l: %d, \n"
+			"refcyc_per_req_delivery_c: %d, \n"
+			"qos_level_fixed_c: %d, \n"
+			"qos_ramp_disable_c: %d, \n"
+			"refcyc_per_req_delivery_pre_c: %d\n"
+			"=============================================================\n",
+			pipe_ctx->pipe_idx,
+			pipe_ctx->ttu_regs.qos_level_low_wm,
+			pipe_ctx->ttu_regs.qos_level_high_wm,
+			pipe_ctx->ttu_regs.min_ttu_vblank,
+			pipe_ctx->ttu_regs.qos_level_flip,
+			pipe_ctx->ttu_regs.refcyc_per_req_delivery_l,
+			pipe_ctx->ttu_regs.qos_level_fixed_l,
+			pipe_ctx->ttu_regs.qos_ramp_disable_l,
+			pipe_ctx->ttu_regs.refcyc_per_req_delivery_pre_l,
+			pipe_ctx->ttu_regs.refcyc_per_req_delivery_c,
+			pipe_ctx->ttu_regs.qos_level_fixed_c,
+			pipe_ctx->ttu_regs.qos_ramp_disable_c,
+			pipe_ctx->ttu_regs.refcyc_per_req_delivery_pre_c
+			);
+
+	dm_logger_write(core_dc->ctx->logger, LOG_BANDWIDTH_CALCS,
+			"\n============== DML DLG Output parameters [%d] ==============\n"
+			"refcyc_h_blank_end: %d, \n"
+			"dlg_vblank_end: %d, \n"
+			"min_dst_y_next_start: %d, \n"
+			"refcyc_per_htotal: %d, \n"
+			"refcyc_x_after_scaler: %d, \n"
+			"dst_y_after_scaler: %d, \n"
+			"dst_y_prefetch: %d, \n"
+			"dst_y_per_vm_vblank: %d, \n"
+			"dst_y_per_row_vblank: %d, \n"
+			"ref_freq_to_pix_freq: %d, \n"
+			"vratio_prefetch: %d, \n"
+			"refcyc_per_pte_group_vblank_l: %d, \n"
+			"refcyc_per_meta_chunk_vblank_l: %d, \n"
+			"dst_y_per_pte_row_nom_l: %d, \n"
+			"refcyc_per_pte_group_nom_l: %d, \n",
+			pipe_ctx->pipe_idx,
+			pipe_ctx->dlg_regs.refcyc_h_blank_end,
+			pipe_ctx->dlg_regs.dlg_vblank_end,
+			pipe_ctx->dlg_regs.min_dst_y_next_start,
+			pipe_ctx->dlg_regs.refcyc_per_htotal,
+			pipe_ctx->dlg_regs.refcyc_x_after_scaler,
+			pipe_ctx->dlg_regs.dst_y_after_scaler,
+			pipe_ctx->dlg_regs.dst_y_prefetch,
+			pipe_ctx->dlg_regs.dst_y_per_vm_vblank,
+			pipe_ctx->dlg_regs.dst_y_per_row_vblank,
+			pipe_ctx->dlg_regs.ref_freq_to_pix_freq,
+			pipe_ctx->dlg_regs.vratio_prefetch,
+			pipe_ctx->dlg_regs.refcyc_per_pte_group_vblank_l,
+			pipe_ctx->dlg_regs.refcyc_per_meta_chunk_vblank_l,
+			pipe_ctx->dlg_regs.dst_y_per_pte_row_nom_l,
+			pipe_ctx->dlg_regs.refcyc_per_pte_group_nom_l
+			);
+
+	dm_logger_write(core_dc->ctx->logger, LOG_BANDWIDTH_CALCS,
+			"\ndst_y_per_meta_row_nom_l: %d, \n"
+			"refcyc_per_meta_chunk_nom_l: %d, \n"
+			"refcyc_per_line_delivery_pre_l: %d, \n"
+			"refcyc_per_line_delivery_l: %d, \n"
+			"vratio_prefetch_c: %d, \n"
+			"refcyc_per_pte_group_vblank_c: %d, \n"
+			"refcyc_per_meta_chunk_vblank_c: %d, \n"
+			"dst_y_per_pte_row_nom_c: %d, \n"
+			"refcyc_per_pte_group_nom_c: %d, \n"
+			"dst_y_per_meta_row_nom_c: %d, \n"
+			"refcyc_per_meta_chunk_nom_c: %d, \n"
+			"refcyc_per_line_delivery_pre_c: %d, \n"
+			"refcyc_per_line_delivery_c: %d \n"
+			"========================================================\n",
+			pipe_ctx->dlg_regs.dst_y_per_meta_row_nom_l,
+			pipe_ctx->dlg_regs.refcyc_per_meta_chunk_nom_l,
+			pipe_ctx->dlg_regs.refcyc_per_line_delivery_pre_l,
+			pipe_ctx->dlg_regs.refcyc_per_line_delivery_l,
+			pipe_ctx->dlg_regs.vratio_prefetch_c,
+			pipe_ctx->dlg_regs.refcyc_per_pte_group_vblank_c,
+			pipe_ctx->dlg_regs.refcyc_per_meta_chunk_vblank_c,
+			pipe_ctx->dlg_regs.dst_y_per_pte_row_nom_c,
+			pipe_ctx->dlg_regs.refcyc_per_pte_group_nom_c,
+			pipe_ctx->dlg_regs.dst_y_per_meta_row_nom_c,
+			pipe_ctx->dlg_regs.refcyc_per_meta_chunk_nom_c,
+			pipe_ctx->dlg_regs.refcyc_per_line_delivery_pre_c,
+			pipe_ctx->dlg_regs.refcyc_per_line_delivery_c
+			);
+
+	dm_logger_write(core_dc->ctx->logger, LOG_BANDWIDTH_CALCS,
+			"\n============== DML RQ Output parameters [%d] ==============\n"
+			"chunk_size: %d \n"
+			"min_chunk_size: %d \n"
+			"meta_chunk_size: %d \n"
+			"min_meta_chunk_size: %d \n"
+			"dpte_group_size: %d \n"
+			"mpte_group_size: %d \n"
+			"swath_height: %d \n"
+			"pte_row_height_linear: %d \n"
+			"========================================================\n",
+			pipe_ctx->pipe_idx,
+			pipe_ctx->rq_regs.rq_regs_l.chunk_size,
+			pipe_ctx->rq_regs.rq_regs_l.min_chunk_size,
+			pipe_ctx->rq_regs.rq_regs_l.meta_chunk_size,
+			pipe_ctx->rq_regs.rq_regs_l.min_meta_chunk_size,
+			pipe_ctx->rq_regs.rq_regs_l.dpte_group_size,
+			pipe_ctx->rq_regs.rq_regs_l.mpte_group_size,
+			pipe_ctx->rq_regs.rq_regs_l.swath_height,
+			pipe_ctx->rq_regs.rq_regs_l.pte_row_height_linear
+			);
+}
+
 static void dcn10_power_on_fe(
 	struct core_dc *dc,
 	struct pipe_ctx *pipe_ctx,
@@ -1419,57 +1541,52 @@ static void dcn10_power_on_fe(
 {
 	struct dc_surface *dc_surface = &pipe_ctx->surface->public;
 
-	/* power up DCHUP and DPP from pseudo code pipe_move.c */
-	 /*TODO: function: power_on_plane. If already power up, skip
-	 */
-	{
-		power_on_plane(dc->ctx,
-			pipe_ctx->pipe_idx, pipe_ctx->tg->inst);
+	power_on_plane(dc->ctx,
+		pipe_ctx->pipe_idx, pipe_ctx->tg->inst);
 
-		/* enable DCFCLK current DCHUB */
-		enable_dcfclk(dc->ctx,
+	/* enable DCFCLK current DCHUB */
+	enable_dcfclk(dc->ctx,
+			pipe_ctx->pipe_idx,
+			pipe_ctx->pix_clk_params.requested_pix_clk,
+			context->bw.dcn.calc_clk.dppclk_div);
+	dc->current_context->bw.dcn.cur_clk.dppclk_div =
+			context->bw.dcn.calc_clk.dppclk_div;
+	context->bw.dcn.cur_clk.dppclk_div = context->bw.dcn.calc_clk.dppclk_div;
+
+	if (dc_surface) {
+		dm_logger_write(dc->ctx->logger, LOG_DC,
+				"Pipe:%d 0x%x: addr hi:0x%x, "
+				"addr low:0x%x, "
+				"src: %d, %d, %d,"
+				" %d; dst: %d, %d, %d, %d;\n",
 				pipe_ctx->pipe_idx,
-				pipe_ctx->pix_clk_params.requested_pix_clk,
-				context->bw.dcn.calc_clk.dppclk_div);
-		dc->current_context->bw.dcn.cur_clk.dppclk_div =
-				context->bw.dcn.calc_clk.dppclk_div;
-		context->bw.dcn.cur_clk.dppclk_div = context->bw.dcn.calc_clk.dppclk_div;
-
-		if (dc_surface) {
-			dm_logger_write(dc->ctx->logger, LOG_DC,
-					"Pipe:%d 0x%x: addr hi:0x%x, "
-					"addr low:0x%x, "
-					"src: %d, %d, %d,"
-					" %d; dst: %d, %d, %d, %d;\n",
-					pipe_ctx->pipe_idx,
-					dc_surface,
-					dc_surface->address.grph.addr.high_part,
-					dc_surface->address.grph.addr.low_part,
-					dc_surface->src_rect.x,
-					dc_surface->src_rect.y,
-					dc_surface->src_rect.width,
-					dc_surface->src_rect.height,
-					dc_surface->dst_rect.x,
-					dc_surface->dst_rect.y,
-					dc_surface->dst_rect.width,
-					dc_surface->dst_rect.height);
-
-			dm_logger_write(dc->ctx->logger, LOG_HW_SET_MODE,
-					"Pipe %d: width, height, x, y\n"
-					"viewport:%d, %d, %d, %d\n"
-					"recout:  %d, %d, %d, %d\n",
-					pipe_ctx->pipe_idx,
-					pipe_ctx->scl_data.viewport.width,
-					pipe_ctx->scl_data.viewport.height,
-					pipe_ctx->scl_data.viewport.x,
-					pipe_ctx->scl_data.viewport.y,
-					pipe_ctx->scl_data.recout.width,
-					pipe_ctx->scl_data.recout.height,
-					pipe_ctx->scl_data.recout.x,
-					pipe_ctx->scl_data.recout.y);
-		}
+				dc_surface,
+				dc_surface->address.grph.addr.high_part,
+				dc_surface->address.grph.addr.low_part,
+				dc_surface->src_rect.x,
+				dc_surface->src_rect.y,
+				dc_surface->src_rect.width,
+				dc_surface->src_rect.height,
+				dc_surface->dst_rect.x,
+				dc_surface->dst_rect.y,
+				dc_surface->dst_rect.width,
+				dc_surface->dst_rect.height);
+
+		dm_logger_write(dc->ctx->logger, LOG_HW_SET_MODE,
+				"Pipe %d: width, height, x, y\n"
+				"viewport:%d, %d, %d, %d\n"
+				"recout:  %d, %d, %d, %d\n",
+				pipe_ctx->pipe_idx,
+				pipe_ctx->scl_data.viewport.width,
+				pipe_ctx->scl_data.viewport.height,
+				pipe_ctx->scl_data.viewport.x,
+				pipe_ctx->scl_data.viewport.y,
+				pipe_ctx->scl_data.recout.width,
+				pipe_ctx->scl_data.recout.height,
+				pipe_ctx->scl_data.recout.x,
+				pipe_ctx->scl_data.recout.y);
+		print_rq_dlg_ttu(dc, pipe_ctx);
 	}
-
 }
 
 static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
@@ -1743,6 +1860,53 @@ static void dcn10_apply_ctx_for_surface(
 		}
 	}
 
+	dm_logger_write(dc->ctx->logger, LOG_BANDWIDTH_CALCS,
+			"\n============== Watermark parameters ==============\n"
+			"a.urgent_ns: %d \n"
+			"a.cstate_enter_plus_exit: %d \n"
+			"a.cstate_exit: %d \n"
+			"a.pstate_change: %d \n"
+			"a.pte_meta_urgent: %d \n"
+			"b.urgent_ns: %d \n"
+			"b.cstate_enter_plus_exit: %d \n"
+			"b.cstate_exit: %d \n"
+			"b.pstate_change: %d \n"
+			"b.pte_meta_urgent: %d \n",
+			context->bw.dcn.watermarks.a.urgent_ns,
+			context->bw.dcn.watermarks.a.cstate_pstate.cstate_enter_plus_exit_ns,
+			context->bw.dcn.watermarks.a.cstate_pstate.cstate_exit_ns,
+			context->bw.dcn.watermarks.a.cstate_pstate.pstate_change_ns,
+			context->bw.dcn.watermarks.a.pte_meta_urgent_ns,
+			context->bw.dcn.watermarks.b.urgent_ns,
+			context->bw.dcn.watermarks.b.cstate_pstate.cstate_enter_plus_exit_ns,
+			context->bw.dcn.watermarks.b.cstate_pstate.cstate_exit_ns,
+			context->bw.dcn.watermarks.b.cstate_pstate.pstate_change_ns,
+			context->bw.dcn.watermarks.b.pte_meta_urgent_ns
+			);
+	dm_logger_write(dc->ctx->logger, LOG_BANDWIDTH_CALCS,
+			"\nc.urgent_ns: %d \n"
+			"c.cstate_enter_plus_exit: %d \n"
+			"c.cstate_exit: %d \n"
+			"c.pstate_change: %d \n"
+			"c.pte_meta_urgent: %d \n"
+			"d.urgent_ns: %d \n"
+			"d.cstate_enter_plus_exit: %d \n"
+			"d.cstate_exit: %d \n"
+			"d.pstate_change: %d \n"
+			"d.pte_meta_urgent: %d \n"
+			"========================================================\n",
+			context->bw.dcn.watermarks.c.urgent_ns,
+			context->bw.dcn.watermarks.c.cstate_pstate.cstate_enter_plus_exit_ns,
+			context->bw.dcn.watermarks.c.cstate_pstate.cstate_exit_ns,
+			context->bw.dcn.watermarks.c.cstate_pstate.pstate_change_ns,
+			context->bw.dcn.watermarks.c.pte_meta_urgent_ns,
+			context->bw.dcn.watermarks.d.urgent_ns,
+			context->bw.dcn.watermarks.d.cstate_pstate.cstate_enter_plus_exit_ns,
+			context->bw.dcn.watermarks.d.cstate_pstate.cstate_exit_ns,
+			context->bw.dcn.watermarks.d.cstate_pstate.pstate_change_ns,
+			context->bw.dcn.watermarks.d.pte_meta_urgent_ns
+			);
+
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 

commit ba326a9185f1c56d86e51dd89589e4eff42f02eb
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jun 2 19:01:37 2017 -0400

    drm/amd/display: propagate surface alpha setting from OS to DC
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 107f82df3053..0a346aafacce 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1559,7 +1559,9 @@ static void update_dchubp_dpp(
 	struct pipe_ctx *temp_pipe;
 	int i;
 	int tree_pos = 0;
+	bool per_pixel_alpha = surface->public.per_pixel_alpha && pipe_ctx->bottom_pipe;
 
+	/* TODO: proper fix once fpga works */
 	/* depends on DML calculation, DPP clock value may change dynamically */
 	enable_dppclk(
 		dc->ctx,
@@ -1604,11 +1606,7 @@ static void update_dchubp_dpp(
 	/* TODO: build stream pipes group id. For now, use stream otg
 	 * id as pipe group id
 	 */
-	/*pipe_ctx->scl_data.lb_params.alpha_en = pipe_ctx->surface->public.per_pixel_alpha;*/
-	if (pipe_ctx->bottom_pipe && surface != pipe_ctx->bottom_pipe->surface)
-		pipe_ctx->scl_data.lb_params.alpha_en = 1;
-	else
-		pipe_ctx->scl_data.lb_params.alpha_en = 0;
+	pipe_ctx->scl_data.lb_params.alpha_en = per_pixel_alpha;
 	pipe_ctx->mpc_idx = pipe_ctx->tg->inst;
 	tree_cfg = &context->res_ctx.mpc_tree[pipe_ctx->mpc_idx];
 	if (tree_cfg->num_pipes == 0) {
@@ -1625,7 +1623,7 @@ static void update_dchubp_dpp(
 
 	tree_cfg->dpp[tree_pos] = pipe_ctx->pipe_idx;
 	tree_cfg->mpcc[tree_pos] = pipe_ctx->pipe_idx;
-	tree_cfg->per_pixel_alpha[tree_pos] = pipe_ctx->scl_data.lb_params.alpha_en;
+	tree_cfg->per_pixel_alpha[tree_pos] = per_pixel_alpha;
 	tree_cfg->num_pipes = tree_pos + 1;
 	dcn10_set_mpc_tree(mpc, tree_cfg);
 

commit 1bf56e62cc4fbff6d701b798da05a91f78aa12e9
Author: Zeyu Fan <Zeyu.Fan@amd.com>
Date:   Fri Jun 2 17:25:49 2017 -0400

    drm/amd/display: Call program_gamut explicitly instead of entire set_plane
    
    This fixes on boot crush on Vega, Polaris with Dal3.
    
    Signed-off-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 447f6bf4644c..107f82df3053 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1899,6 +1899,7 @@ static void set_plane_config(
 }
 
 static const struct hw_sequencer_funcs dcn10_funcs = {
+	.program_gamut_remap = program_gamut_remap,
 	.init_hw = init_hw,
 	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
 	.apply_ctx_for_surface = dcn10_apply_ctx_for_surface,

commit 1a2c82a2f161f68deb5f0519c315bfc92ede8e01
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jun 2 19:00:45 2017 -0400

    drm/amd/display: fix mpc alpha programming
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 0e677f9db96a..447f6bf4644c 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -125,14 +125,8 @@ static void lock_otg_master_update(
 	HWSEQ_REG_UPDATE(OTG0_OTG_GLOBAL_CONTROL0,
 			OTG_MASTER_UPDATE_LOCK_SEL, inst);
 
-	/* unlock master locker */
 	HWSEQ_REG_UPDATE(OTG0_OTG_MASTER_UPDATE_LOCK,
 			OTG_MASTER_UPDATE_LOCK, 1);
-
-	/* wait for unlock happens */
-	if (!wait_reg(ctx, inst_offset, OTG0_OTG_MASTER_UPDATE_LOCK, UPDATE_LOCK_STATUS, 1))
-			BREAK_TO_DEBUGGER();
-
 }
 
 static bool unlock_master_tg_and_wait(
@@ -1562,8 +1556,9 @@ static void update_dchubp_dpp(
 	enum dc_color_space color_space;
 	struct tg_color black_color = {0};
 	struct dcn10_mpc *mpc = TO_DCN10_MPC(dc->res_pool->mpc);
-
-	struct pipe_ctx *cur_pipe_ctx = &dc->current_context->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
+	struct pipe_ctx *temp_pipe;
+	int i;
+	int tree_pos = 0;
 
 	/* depends on DML calculation, DPP clock value may change dynamically */
 	enable_dppclk(
@@ -1609,41 +1604,30 @@ static void update_dchubp_dpp(
 	/* TODO: build stream pipes group id. For now, use stream otg
 	 * id as pipe group id
 	 */
-	pipe_ctx->mpc_idx = pipe_ctx->tg->inst;
-	tree_cfg = &context->res_ctx.mpc_tree[pipe_ctx->mpc_idx];
-
-	/* enable when bottom pipe is present and
-	 * it does not share a surface with current pipe
-	 */
-	if (pipe_ctx->bottom_pipe && surface != pipe_ctx->bottom_pipe->surface) {
+	/*pipe_ctx->scl_data.lb_params.alpha_en = pipe_ctx->surface->public.per_pixel_alpha;*/
+	if (pipe_ctx->bottom_pipe && surface != pipe_ctx->bottom_pipe->surface)
 		pipe_ctx->scl_data.lb_params.alpha_en = 1;
-		tree_cfg->mode = TOP_BLND;
-	} else {
+	else
 		pipe_ctx->scl_data.lb_params.alpha_en = 0;
-		tree_cfg->mode = TOP_PASSTHRU;
-	}
-	if (!pipe_ctx->top_pipe && !cur_pipe_ctx->bottom_pipe) {
-		/* primary pipe, set mpc tree index 0 only */
-		tree_cfg->num_pipes = 1;
+	pipe_ctx->mpc_idx = pipe_ctx->tg->inst;
+	tree_cfg = &context->res_ctx.mpc_tree[pipe_ctx->mpc_idx];
+	if (tree_cfg->num_pipes == 0) {
 		tree_cfg->opp_id = pipe_ctx->tg->inst;
-		tree_cfg->dpp[0] = pipe_ctx->pipe_idx;
-		tree_cfg->mpcc[0] = pipe_ctx->pipe_idx;
+		for (i = 0; i < MAX_PIPES; i++) {
+			tree_cfg->dpp[i] = 0xf;
+			tree_cfg->mpcc[i] = 0xf;
+		}
 	}
 
-	if (!cur_pipe_ctx->top_pipe && !pipe_ctx->top_pipe) {
-
-		if (!cur_pipe_ctx->bottom_pipe)
-			dcn10_set_mpc_tree(mpc, tree_cfg);
-
-	} else if (!cur_pipe_ctx->top_pipe && pipe_ctx->top_pipe) {
-
-		dcn10_add_dpp(mpc, tree_cfg,
-			pipe_ctx->pipe_idx, pipe_ctx->pipe_idx, 1);
-	} else {
-		/* nothing to be done here */
-		ASSERT(cur_pipe_ctx->top_pipe && pipe_ctx->top_pipe);
-	}
+	for (temp_pipe = pipe_ctx->top_pipe;
+			temp_pipe != NULL; temp_pipe = temp_pipe->top_pipe)
+		tree_pos++;
 
+	tree_cfg->dpp[tree_pos] = pipe_ctx->pipe_idx;
+	tree_cfg->mpcc[tree_pos] = pipe_ctx->pipe_idx;
+	tree_cfg->per_pixel_alpha[tree_pos] = pipe_ctx->scl_data.lb_params.alpha_en;
+	tree_cfg->num_pipes = tree_pos + 1;
+	dcn10_set_mpc_tree(mpc, tree_cfg);
 
 	color_space = pipe_ctx->stream->public.output_color_space;
 	color_space_to_black_color(dc, color_space, &black_color);
@@ -1680,18 +1664,15 @@ static void program_all_pipe_in_tree(
 {
 	unsigned int ref_clk_mhz = dc->res_pool->ref_clock_inKhz/1000;
 
-	if (pipe_ctx->surface->public.visible || pipe_ctx->top_pipe == NULL) {
-		dcn10_power_on_fe(dc, pipe_ctx, context);
+	if (pipe_ctx->top_pipe == NULL) {
 
 		/* lock otg_master_update to process all pipes associated with
 		 * this OTG. this is done only one time.
 		 */
-		if (pipe_ctx->top_pipe == NULL) {
-			/* watermark is for all pipes */
-			pipe_ctx->mi->funcs->program_watermarks(
-					pipe_ctx->mi, &context->bw.dcn.watermarks, ref_clk_mhz);
-			lock_otg_master_update(dc->ctx, pipe_ctx->tg->inst);
-		}
+		/* watermark is for all pipes */
+		pipe_ctx->mi->funcs->program_watermarks(
+				pipe_ctx->mi, &context->bw.dcn.watermarks, ref_clk_mhz);
+		lock_otg_master_update(dc->ctx, pipe_ctx->tg->inst);
 
 		pipe_ctx->tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
 		pipe_ctx->tg->dlg_otg_param.vstartup_start = pipe_ctx->pipe_dlg_param.vstartup_start;
@@ -1702,12 +1683,11 @@ static void program_all_pipe_in_tree(
 		pipe_ctx->tg->funcs->program_global_sync(
 				pipe_ctx->tg);
 		pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, !is_pipe_tree_visible(pipe_ctx));
+	}
 
-
-
+	if (pipe_ctx->surface->public.visible) {
+		dcn10_power_on_fe(dc, pipe_ctx, context);
 		update_dchubp_dpp(dc, pipe_ctx, context);
-
-		/* Only support one plane for now. */
 	}
 
 	if (pipe_ctx->bottom_pipe != NULL)

commit 1e25ed30796b89140653c60ac20ea1c8254c9e91
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Thu Jun 1 15:49:16 2017 -0400

    drm/amd/display: remove disable_clk_gate debug flag for DCN
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 877e2b6a7dd5..0e677f9db96a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -397,19 +397,6 @@ static void enable_power_gating_plane(
 	HWSEQ_REG_UPDATE(DOMAIN3_PG_CONFIG, DOMAIN3_POWER_FORCEON, force_on);
 	HWSEQ_REG_UPDATE(DOMAIN5_PG_CONFIG, DOMAIN5_POWER_FORCEON, force_on);
 	HWSEQ_REG_UPDATE(DOMAIN7_PG_CONFIG, DOMAIN7_POWER_FORCEON, force_on);
-
-	if (ctx->dc->debug.disable_clock_gate) {
-		/* probably better to just write entire register to 0xffff to
-		 * ensure all clock gating is disabled
-		 */
-		HWSEQ_REG_UPDATE_3(DCCG_GATE_DISABLE_CNTL,
-				DISPCLK_R_DCCG_GATE_DISABLE, 1,
-				DPREFCLK_R_DCCG_GATE_DISABLE, 1,
-				REFCLK_R_DIG_GATE_DISABLE, 1);
-		HWSEQ_REG_UPDATE(DCFCLK_CNTL,
-				DCFCLK_GATE_DIS, 1);
-	}
-
 }
 
 static void dpp_pg_control(
@@ -513,29 +500,12 @@ static void power_on_plane(
 {
 	uint32_t inst_offset = 0;
 
-	/* disable clock power gating */
-
-	/* DCCG_GATE_DISABLE_CNTL only has one instance */
-	if (ctx->dc->debug.disable_clock_gate) {
-		HWSEQ_REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL,
-				DISPCLK_DCCG_GATE_DISABLE, 1,
-				DPPCLK_GATE_DISABLE, 1);
-		/* DCFCLK_CNTL only has one instance */
-		HWSEQ_REG_UPDATE(DCFCLK_CNTL,
-				DCFCLK_GATE_DIS, 1);
-	}
-
 	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
 			IP_REQUEST_EN, 1);
 	dpp_pg_control(ctx, plane_id, true);
 	hubp_pg_control(ctx, plane_id, true);
 	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
 			IP_REQUEST_EN, 0);
-
-	if (ctx->dc->debug.disable_clock_gate) {
-		HWSEQ_REG_UPDATE(DCCG_GATE_DISABLE_CNTL,
-				DISPCLK_DCCG_GATE_DISABLE, 0);
-	}
 }
 
 /* fully check bios enabledisplaypowergating table. dal only need dce init

commit dcf6c1456ef555c4a1c0d28326a7bac2fc6923de
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Jun 1 12:27:00 2017 -0400

    drm/amd/display: clean up mpc programing during fe reset
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 24c1a0f5febe..877e2b6a7dd5 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -868,16 +868,10 @@ static void reset_front_end_for_pipe(
 	 */
 	tree_cfg = &dc->current_context->res_ctx.mpc_tree[pipe_ctx->mpc_idx];
 
-	if (pipe_ctx->top_pipe == NULL)
-		dcn10_delete_mpc_tree(mpc, tree_cfg);
-	else {
-		if (dcn10_remove_dpp(mpc, tree_cfg, pipe_ctx->pipe_idx))
-			pipe_ctx->top_pipe->bottom_pipe = NULL;
-		else {
-			dm_logger_write(dc->ctx->logger, LOG_RESOURCE,
-				"%s: failed to find dpp to be removed!\n",
-				__func__);
-		}
+	if (!dcn10_remove_dpp(mpc, tree_cfg, pipe_ctx->pipe_idx)) {
+		dm_logger_write(dc->ctx->logger, LOG_RESOURCE,
+			"%s: failed to find dpp to be removed!\n",
+			__func__);
 	}
 
 	pipe_ctx->top_pipe = NULL;

commit 5970f2aecc558ce2e04565ff082d9b78144fc714
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Tue May 30 15:26:14 2017 -0400

    drm/amd/display: Enable DCN clock gating
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 62a77f48d437..24c1a0f5febe 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -516,12 +516,14 @@ static void power_on_plane(
 	/* disable clock power gating */
 
 	/* DCCG_GATE_DISABLE_CNTL only has one instance */
-	HWSEQ_REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL,
-			DISPCLK_DCCG_GATE_DISABLE, 1,
-			DPPCLK_GATE_DISABLE, 1);
-	/* DCFCLK_CNTL only has one instance */
-	HWSEQ_REG_UPDATE(DCFCLK_CNTL,
-			DCFCLK_GATE_DIS, 1);
+	if (ctx->dc->debug.disable_clock_gate) {
+		HWSEQ_REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL,
+				DISPCLK_DCCG_GATE_DISABLE, 1,
+				DPPCLK_GATE_DISABLE, 1);
+		/* DCFCLK_CNTL only has one instance */
+		HWSEQ_REG_UPDATE(DCFCLK_CNTL,
+				DCFCLK_GATE_DIS, 1);
+	}
 
 	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
 			IP_REQUEST_EN, 1);
@@ -533,14 +535,6 @@ static void power_on_plane(
 	if (ctx->dc->debug.disable_clock_gate) {
 		HWSEQ_REG_UPDATE(DCCG_GATE_DISABLE_CNTL,
 				DISPCLK_DCCG_GATE_DISABLE, 0);
-	} else {
-		/* DCCG_GATE_DISABLE_CNTL only has one instance. inst_offset = 0 */
-		HWSEQ_REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL,
-				DISPCLK_DCCG_GATE_DISABLE, 0,
-				DPPCLK_GATE_DISABLE, 0);
-		/* DCFCLK_CNTL only has one instance. inst_offset = 0 */
-		HWSEQ_REG_UPDATE(DCFCLK_CNTL,
-				DCFCLK_GATE_DIS, 0);
 	}
 }
 
@@ -666,14 +660,58 @@ static void init_hw(struct core_dc *dc)
 			FD(DIO_MEM_PWR_CTRL__HDMI5_MEM_PWR_FORCE), 0,
 			FD(DIO_MEM_PWR_CTRL__HDMI6_MEM_PWR_FORCE), 0);
 
+	if (!dc->public.debug.disable_clock_gate) {
+		/* enable all DCN clock gating */
+		generic_reg_set_soc15(dc->ctx, 0, DCCG_GATE_DISABLE_CNTL, 19,
+				FD(DCCG_GATE_DISABLE_CNTL__DISPCLK_DCCG_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__DISPCLK_R_DCCG_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__SOCCLK_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__DPREFCLK_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__DACACLK_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__DVOACLK_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__DPREFCLK_R_DCCG_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__DPPCLK_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__AOMCLK0_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__AOMCLK1_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__AOMCLK2_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__AUDIO_DTO2_CLK_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__DPREFCLK_GTC_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__UNB_DB_CLK_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__REFCLK_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__REFCLK_R_DIG_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__DSICLK_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__BYTECLK_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL__ESCCLK_GATE_DISABLE), 0);
+
+		generic_reg_set_soc15(dc->ctx, 0, DCCG_GATE_DISABLE_CNTL2, 14,
+				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKA_FE_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKB_FE_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKC_FE_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKD_FE_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKE_FE_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKF_FE_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKG_FE_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKA_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKB_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKC_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKD_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKE_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKF_GATE_DISABLE), 0,
+				FD(DCCG_GATE_DISABLE_CNTL2__SYMCLKG_GATE_DISABLE), 0);
+
+		generic_reg_update_soc15(dc->ctx, 0, DCFCLK_CNTL, 1,
+				FD(DCFCLK_CNTL__DCFCLK_GATE_DIS), 0);
+	}
+
 	/* This power gating should be one-time program for DAL.
 	 * It can only change by registry key
 	 * TODO: new task will for this.
 	 * if power gating is disable, power_on_plane and power_off_plane
 	 * should be skip. Otherwise, hand will be met in power_off_plane
 	 */
-
 	enable_power_gating_plane(dc->ctx, true);
+
+
 }
 
 static enum dc_status dcn10_prog_pixclk_crtc_otg(

commit 5aff86c1b3259f1443e0b35b74eb6dfd5b35791b
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue May 16 16:07:30 2017 -0400

    drm/amd/display: Implement input gamma LUT
    
    1. Implemented dcn10_ipp_program_input_lut(), following the existing
       interface.
    2. Added missing registers as needed
    3. Change to REG_GET for *ram_select() funcs.
    4. Removed gamma table init from DiagsDM::make_surface() for resolving
       CRC errors. Reason: Legacy LUT will be deprecated soon for Raven in
       favor of degamma/regamma.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 28b47bed72cf..62a77f48d437 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -29,9 +29,9 @@
 #include "core_types.h"
 #include "core_status.h"
 #include "resource.h"
-#include "hw_sequencer.h"
 #include "dcn10_hw_sequencer.h"
 #include "dce110/dce110_hw_sequencer.h"
+#include "dce/dce_hwseq.h"
 #include "abm.h"
 
 #include "dcn10/dcn10_transform.h"
@@ -952,6 +952,10 @@ static bool dcn10_set_input_transfer_func(
 	if (surface->public.in_transfer_func)
 		tf = DC_TRANSFER_FUNC_TO_CORE(surface->public.in_transfer_func);
 
+	if (surface->public.gamma_correction && dce_use_lut(surface))
+	    ipp->funcs->ipp_program_input_lut(ipp,
+			    surface->public.gamma_correction);
+
 	if (tf == NULL)
 		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
 	else if (tf->public.type == TF_TYPE_PREDEFINED) {

commit 4b28b76bfe14430a91de74a5cf9215f3c108acf9
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu May 11 17:15:14 2017 -0400

    drm/amd/display: fix mpo blanking out on one of planes being set not visible
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 6cb3924225da..28b47bed72cf 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -848,7 +848,7 @@ static void reset_front_end_for_pipe(
 
 	unlock_master_tg_and_wait(dc->ctx, pipe_ctx->tg->inst);
 
-	pipe_ctx->mi->funcs->disable_request(pipe_ctx->mi);
+	pipe_ctx->mi->funcs->set_blank(pipe_ctx->mi, true);
 
 	wait_no_outstanding_request(dc->ctx, pipe_ctx->pipe_idx);
 
@@ -1513,6 +1513,35 @@ static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
 	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
 }
 
+static bool is_lower_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
+{
+	if (pipe_ctx->surface->public.visible)
+		return true;
+	if (pipe_ctx->bottom_pipe && is_lower_pipe_tree_visible(pipe_ctx->bottom_pipe))
+		return true;
+	return false;
+}
+
+static bool is_upper_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
+{
+	if (pipe_ctx->surface->public.visible)
+		return true;
+	if (pipe_ctx->top_pipe && is_upper_pipe_tree_visible(pipe_ctx->top_pipe))
+		return true;
+	return false;
+}
+
+static bool is_pipe_tree_visible(struct pipe_ctx *pipe_ctx)
+{
+	if (pipe_ctx->surface->public.visible)
+		return true;
+	if (pipe_ctx->top_pipe && is_upper_pipe_tree_visible(pipe_ctx->top_pipe))
+		return true;
+	if (pipe_ctx->bottom_pipe && is_lower_pipe_tree_visible(pipe_ctx->bottom_pipe))
+		return true;
+	return false;
+}
+
 static void update_dchubp_dpp(
 	struct core_dc *dc,
 	struct pipe_ctx *pipe_ctx,
@@ -1633,12 +1662,9 @@ static void update_dchubp_dpp(
 		&size,
 		surface->public.rotation,
 		&surface->public.dcc,
-		surface->public.horizontal_mirror,
-		surface->public.visible);
-
-	/* Only support one plane for now. */
-	pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, !surface->public.visible);
+		surface->public.horizontal_mirror);
 
+	mi->funcs->set_blank(mi, !is_pipe_tree_visible(pipe_ctx));
 }
 
 static void program_all_pipe_in_tree(
@@ -1669,10 +1695,13 @@ static void program_all_pipe_in_tree(
 
 		pipe_ctx->tg->funcs->program_global_sync(
 				pipe_ctx->tg);
+		pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, !is_pipe_tree_visible(pipe_ctx));
 
 
 
 		update_dchubp_dpp(dc, pipe_ctx, context);
+
+		/* Only support one plane for now. */
 	}
 
 	if (pipe_ctx->bottom_pipe != NULL)

commit f46661dd42f3648b92eca73ba2c48f5d9a418b1b
Author: Amy Zhang <Amy.Zhang@amd.com>
Date:   Tue May 9 14:45:54 2017 -0400

    drm/amd/display: Move output transfer function to stream updates
    
    Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index f5638ad6e9fc..6cb3924225da 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1301,11 +1301,13 @@ static bool dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func
 
 static bool dcn10_set_output_transfer_func(
 	struct pipe_ctx *pipe_ctx,
-	const struct core_surface *surface,
 	const struct core_stream *stream)
 {
 	struct output_pixel_processor *opp = pipe_ctx->opp;
 
+	if (opp == NULL)
+		return false;
+
 	opp->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
 
 	if (stream->public.out_transfer_func &&

commit c66a54dc4a8403ab269568b3f964b0efd4052932
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 3 11:40:40 2017 -0400

    drm/amd/display: switch to using calc_clk and cur_clk for dcn bw setting
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index a62c4e72f21a..f5638ad6e9fc 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1429,6 +1429,9 @@ static void dcn10_power_on_fe(
 				pipe_ctx->pipe_idx,
 				pipe_ctx->pix_clk_params.requested_pix_clk,
 				context->bw.dcn.calc_clk.dppclk_div);
+		dc->current_context->bw.dcn.cur_clk.dppclk_div =
+				context->bw.dcn.calc_clk.dppclk_div;
+		context->bw.dcn.cur_clk.dppclk_div = context->bw.dcn.calc_clk.dppclk_div;
 
 		if (dc_surface) {
 			dm_logger_write(dc->ctx->logger, LOG_DC,
@@ -1531,6 +1534,9 @@ static void update_dchubp_dpp(
 		pipe_ctx->pipe_idx,
 		pipe_ctx->pix_clk_params.requested_pix_clk,
 		context->bw.dcn.calc_clk.dppclk_div);
+	dc->current_context->bw.dcn.cur_clk.dppclk_div =
+			context->bw.dcn.calc_clk.dppclk_div;
+	context->bw.dcn.cur_clk.dppclk_div = context->bw.dcn.calc_clk.dppclk_div;
 
 	select_vtg(dc->ctx, pipe_ctx->pipe_idx, pipe_ctx->tg->inst);
 
@@ -1679,16 +1685,16 @@ static void dcn10_pplib_apply_display_requirements(
 
 	pp_display_cfg->all_displays_in_sync = false;/*todo*/
 	pp_display_cfg->nb_pstate_switch_disable = false;
-	pp_display_cfg->min_engine_clock_khz = context->bw.dcn.calc_clk.dcfclk_khz;
-	pp_display_cfg->min_memory_clock_khz = context->bw.dcn.calc_clk.fclk_khz;
-	pp_display_cfg->min_engine_clock_deep_sleep_khz = context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
-	pp_display_cfg->min_dcfc_deep_sleep_clock_khz = context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
+	pp_display_cfg->min_engine_clock_khz = context->bw.dcn.cur_clk.dcfclk_khz;
+	pp_display_cfg->min_memory_clock_khz = context->bw.dcn.cur_clk.fclk_khz;
+	pp_display_cfg->min_engine_clock_deep_sleep_khz = context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz;
+	pp_display_cfg->min_dcfc_deep_sleep_clock_khz = context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz;
 	pp_display_cfg->avail_mclk_switch_time_us =
-			context->bw.dcn.calc_clk.dram_ccm_us > 0 ? context->bw.dcn.calc_clk.dram_ccm_us : 0;
+			context->bw.dcn.cur_clk.dram_ccm_us > 0 ? context->bw.dcn.cur_clk.dram_ccm_us : 0;
 	pp_display_cfg->avail_mclk_switch_time_in_disp_active_us =
-			context->bw.dcn.calc_clk.min_active_dram_ccm_us > 0 ? context->bw.dcn.calc_clk.min_active_dram_ccm_us : 0;
-	pp_display_cfg->min_dcfclock_khz = context->bw.dcn.calc_clk.dcfclk_khz;
-	pp_display_cfg->disp_clk_khz = context->bw.dcn.calc_clk.dispclk_khz;
+			context->bw.dcn.cur_clk.min_active_dram_ccm_us > 0 ? context->bw.dcn.cur_clk.min_active_dram_ccm_us : 0;
+	pp_display_cfg->min_dcfclock_khz = context->bw.dcn.cur_clk.dcfclk_khz;
+	pp_display_cfg->disp_clk_khz = context->bw.dcn.cur_clk.dispclk_khz;
 	dce110_fill_display_configs(context, pp_display_cfg);
 
 	if (memcmp(&dc->prev_display_config, pp_display_cfg, sizeof(
@@ -1755,22 +1761,51 @@ static void dcn10_set_bandwidth(
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
 		return;
 
-	if (decrease_allowed || context->bw.dcn.calc_clk.dispclk_khz > dc->current_context->bw.dcn.calc_clk.dispclk_khz) {
+	if (decrease_allowed || context->bw.dcn.calc_clk.dispclk_khz
+			> dc->current_context->bw.dcn.cur_clk.dispclk_khz) {
 		dc->res_pool->display_clock->funcs->set_clock(
 				dc->res_pool->display_clock,
 				context->bw.dcn.calc_clk.dispclk_khz);
-		dc->current_context->bw.dcn.calc_clk.dispclk_khz = context->bw.dcn.calc_clk.dispclk_khz;
+		dc->current_context->bw.dcn.cur_clk.dispclk_khz =
+				context->bw.dcn.calc_clk.dispclk_khz;
 	}
-	if (decrease_allowed || context->bw.dcn.calc_clk.dcfclk_khz > dc->current_context->bw.dcn.calc_clk.dcfclk_khz) {
+	if (decrease_allowed || context->bw.dcn.calc_clk.dcfclk_khz
+			> dc->current_context->bw.dcn.cur_clk.dcfclk_khz) {
 		clock.clk_type = DM_PP_CLOCK_TYPE_DCFCLK;
 		clock.clocks_in_khz = context->bw.dcn.calc_clk.dcfclk_khz;
 		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
+		dc->current_context->bw.dcn.cur_clk.dcfclk_khz = clock.clocks_in_khz;
+		context->bw.dcn.cur_clk.dcfclk_khz = clock.clocks_in_khz;
 	}
-	if (decrease_allowed || context->bw.dcn.calc_clk.fclk_khz > dc->current_context->bw.dcn.calc_clk.fclk_khz) {
+	if (decrease_allowed || context->bw.dcn.calc_clk.fclk_khz
+			> dc->current_context->bw.dcn.cur_clk.fclk_khz) {
 		clock.clk_type = DM_PP_CLOCK_TYPE_FCLK;
 		clock.clocks_in_khz = context->bw.dcn.calc_clk.fclk_khz;
 		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
 		dc->current_context->bw.dcn.calc_clk.fclk_khz = clock.clocks_in_khz;
+		context->bw.dcn.cur_clk.fclk_khz = clock.clocks_in_khz;
+	}
+	if (decrease_allowed || context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz
+			> dc->current_context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz) {
+		dc->current_context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz =
+				context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
+		context->bw.dcn.cur_clk.dcfclk_deep_sleep_khz =
+				context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
+	}
+	/* Decrease in freq is increase in period so opposite comparison for dram_ccm */
+	if (decrease_allowed || context->bw.dcn.calc_clk.dram_ccm_us
+			< dc->current_context->bw.dcn.cur_clk.dram_ccm_us) {
+		dc->current_context->bw.dcn.calc_clk.dram_ccm_us =
+				context->bw.dcn.calc_clk.dram_ccm_us;
+		context->bw.dcn.cur_clk.dram_ccm_us =
+				context->bw.dcn.calc_clk.dram_ccm_us;
+	}
+	if (decrease_allowed || context->bw.dcn.calc_clk.min_active_dram_ccm_us
+			< dc->current_context->bw.dcn.cur_clk.min_active_dram_ccm_us) {
+		dc->current_context->bw.dcn.calc_clk.min_active_dram_ccm_us =
+				context->bw.dcn.calc_clk.min_active_dram_ccm_us;
+		context->bw.dcn.cur_clk.min_active_dram_ccm_us =
+				context->bw.dcn.calc_clk.min_active_dram_ccm_us;
 	}
 	dcn10_pplib_apply_display_requirements(dc, context);
 }

commit 9037d802a97812cb8d614b48f817a5532cf1558c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue May 2 17:29:48 2017 -0400

    drm/amd/display: refactor bw related variable structure in val_ctx
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 41a6fa507982..a62c4e72f21a 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1428,7 +1428,7 @@ static void dcn10_power_on_fe(
 		enable_dcfclk(dc->ctx,
 				pipe_ctx->pipe_idx,
 				pipe_ctx->pix_clk_params.requested_pix_clk,
-				context->dppclk_div);
+				context->bw.dcn.calc_clk.dppclk_div);
 
 		if (dc_surface) {
 			dm_logger_write(dc->ctx->logger, LOG_DC,
@@ -1530,7 +1530,7 @@ static void update_dchubp_dpp(
 		dc->ctx,
 		pipe_ctx->pipe_idx,
 		pipe_ctx->pix_clk_params.requested_pix_clk,
-		context->dppclk_div);
+		context->bw.dcn.calc_clk.dppclk_div);
 
 	select_vtg(dc->ctx, pipe_ctx->pipe_idx, pipe_ctx->tg->inst);
 
@@ -1649,7 +1649,7 @@ static void program_all_pipe_in_tree(
 		if (pipe_ctx->top_pipe == NULL) {
 			/* watermark is for all pipes */
 			pipe_ctx->mi->funcs->program_watermarks(
-					pipe_ctx->mi, &context->watermarks, ref_clk_mhz);
+					pipe_ctx->mi, &context->bw.dcn.watermarks, ref_clk_mhz);
 			lock_otg_master_update(dc->ctx, pipe_ctx->tg->inst);
 		}
 
@@ -1679,16 +1679,16 @@ static void dcn10_pplib_apply_display_requirements(
 
 	pp_display_cfg->all_displays_in_sync = false;/*todo*/
 	pp_display_cfg->nb_pstate_switch_disable = false;
-	pp_display_cfg->min_engine_clock_khz = context->dcfclk_khz;
-	pp_display_cfg->min_memory_clock_khz = context->fclk_khz;
-	pp_display_cfg->min_engine_clock_deep_sleep_khz = context->dcfclk_deep_sleep_khz;
-	pp_display_cfg->min_dcfc_deep_sleep_clock_khz = context->dcfclk_deep_sleep_khz;
+	pp_display_cfg->min_engine_clock_khz = context->bw.dcn.calc_clk.dcfclk_khz;
+	pp_display_cfg->min_memory_clock_khz = context->bw.dcn.calc_clk.fclk_khz;
+	pp_display_cfg->min_engine_clock_deep_sleep_khz = context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
+	pp_display_cfg->min_dcfc_deep_sleep_clock_khz = context->bw.dcn.calc_clk.dcfclk_deep_sleep_khz;
 	pp_display_cfg->avail_mclk_switch_time_us =
-			context->dram_ccm_us > 0 ? context->dram_ccm_us : 0;
+			context->bw.dcn.calc_clk.dram_ccm_us > 0 ? context->bw.dcn.calc_clk.dram_ccm_us : 0;
 	pp_display_cfg->avail_mclk_switch_time_in_disp_active_us =
-			context->min_active_dram_ccm_us > 0 ? context->min_active_dram_ccm_us : 0;
-	pp_display_cfg->min_dcfclock_khz = context->dcfclk_khz;
-	pp_display_cfg->disp_clk_khz = context->dispclk_khz;
+			context->bw.dcn.calc_clk.min_active_dram_ccm_us > 0 ? context->bw.dcn.calc_clk.min_active_dram_ccm_us : 0;
+	pp_display_cfg->min_dcfclock_khz = context->bw.dcn.calc_clk.dcfclk_khz;
+	pp_display_cfg->disp_clk_khz = context->bw.dcn.calc_clk.dispclk_khz;
 	dce110_fill_display_configs(context, pp_display_cfg);
 
 	if (memcmp(&dc->prev_display_config, pp_display_cfg, sizeof(
@@ -1755,22 +1755,22 @@ static void dcn10_set_bandwidth(
 	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
 		return;
 
-	if (decrease_allowed || context->dispclk_khz > dc->current_context->dispclk_khz) {
+	if (decrease_allowed || context->bw.dcn.calc_clk.dispclk_khz > dc->current_context->bw.dcn.calc_clk.dispclk_khz) {
 		dc->res_pool->display_clock->funcs->set_clock(
 				dc->res_pool->display_clock,
-				context->dispclk_khz);
-		dc->current_context->dispclk_khz = context->dispclk_khz;
+				context->bw.dcn.calc_clk.dispclk_khz);
+		dc->current_context->bw.dcn.calc_clk.dispclk_khz = context->bw.dcn.calc_clk.dispclk_khz;
 	}
-	if (decrease_allowed || context->dcfclk_khz > dc->current_context->dcfclk_khz) {
+	if (decrease_allowed || context->bw.dcn.calc_clk.dcfclk_khz > dc->current_context->bw.dcn.calc_clk.dcfclk_khz) {
 		clock.clk_type = DM_PP_CLOCK_TYPE_DCFCLK;
-		clock.clocks_in_khz = context->dcfclk_khz;
+		clock.clocks_in_khz = context->bw.dcn.calc_clk.dcfclk_khz;
 		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
 	}
-	if (decrease_allowed || context->fclk_khz > dc->current_context->fclk_khz) {
+	if (decrease_allowed || context->bw.dcn.calc_clk.fclk_khz > dc->current_context->bw.dcn.calc_clk.fclk_khz) {
 		clock.clk_type = DM_PP_CLOCK_TYPE_FCLK;
-		clock.clocks_in_khz = context->fclk_khz;
+		clock.clocks_in_khz = context->bw.dcn.calc_clk.fclk_khz;
 		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
-		dc->current_context->fclk_khz = clock.clocks_in_khz ;
+		dc->current_context->bw.dcn.calc_clk.fclk_khz = clock.clocks_in_khz;
 	}
 	dcn10_pplib_apply_display_requirements(dc, context);
 }

commit cbfd33fd976eb2679c154e44fa34428a43ac8b44
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Tue May 2 17:01:10 2017 -0400

    drm/amd/display: do not set_mpc_tree if tree is already setup
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index ece8c96f3636..41a6fa507982 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -828,7 +828,7 @@ static void reset_front_end_for_pipe(
 	/* TODO: build stream pipes group id. For now, use stream otg
 	 * id as pipe group id
 	 */
-	tree_cfg = &context->res_ctx.mpc_tree[pipe_ctx->mpc_idx];
+	tree_cfg = &dc->current_context->res_ctx.mpc_tree[pipe_ctx->mpc_idx];
 
 	if (pipe_ctx->top_pipe == NULL)
 		dcn10_delete_mpc_tree(mpc, tree_cfg);
@@ -1523,6 +1523,8 @@ static void update_dchubp_dpp(
 	struct tg_color black_color = {0};
 	struct dcn10_mpc *mpc = TO_DCN10_MPC(dc->res_pool->mpc);
 
+	struct pipe_ctx *cur_pipe_ctx = &dc->current_context->res_ctx.pipe_ctx[pipe_ctx->pipe_idx];
+
 	/* depends on DML calculation, DPP clock value may change dynamically */
 	enable_dppclk(
 		dc->ctx,
@@ -1566,6 +1568,7 @@ static void update_dchubp_dpp(
 	 */
 	pipe_ctx->mpc_idx = pipe_ctx->tg->inst;
 	tree_cfg = &context->res_ctx.mpc_tree[pipe_ctx->mpc_idx];
+
 	/* enable when bottom pipe is present and
 	 * it does not share a surface with current pipe
 	 */
@@ -1576,21 +1579,29 @@ static void update_dchubp_dpp(
 		pipe_ctx->scl_data.lb_params.alpha_en = 0;
 		tree_cfg->mode = TOP_PASSTHRU;
 	}
-	if (!pipe_ctx->top_pipe) {
+	if (!pipe_ctx->top_pipe && !cur_pipe_ctx->bottom_pipe) {
 		/* primary pipe, set mpc tree index 0 only */
 		tree_cfg->num_pipes = 1;
 		tree_cfg->opp_id = pipe_ctx->tg->inst;
 		tree_cfg->dpp[0] = pipe_ctx->pipe_idx;
 		tree_cfg->mpcc[0] = pipe_ctx->pipe_idx;
-		dcn10_set_mpc_tree(mpc, tree_cfg);
-	} else {
-		/* TODO: add position is hard code to 1 for now
-		 * If more than 2 pipes are supported, calculate position
-		 */
+	}
+
+	if (!cur_pipe_ctx->top_pipe && !pipe_ctx->top_pipe) {
+
+		if (!cur_pipe_ctx->bottom_pipe)
+			dcn10_set_mpc_tree(mpc, tree_cfg);
+
+	} else if (!cur_pipe_ctx->top_pipe && pipe_ctx->top_pipe) {
+
 		dcn10_add_dpp(mpc, tree_cfg,
 			pipe_ctx->pipe_idx, pipe_ctx->pipe_idx, 1);
+	} else {
+		/* nothing to be done here */
+		ASSERT(cur_pipe_ctx->top_pipe && pipe_ctx->top_pipe);
 	}
 
+
 	color_space = pipe_ctx->stream->public.output_color_space;
 	color_space_to_black_color(dc, color_space, &black_color);
 	dcn10_set_mpc_background_color(mpc, pipe_ctx->pipe_idx, &black_color);
@@ -1641,13 +1652,18 @@ static void program_all_pipe_in_tree(
 					pipe_ctx->mi, &context->watermarks, ref_clk_mhz);
 			lock_otg_master_update(dc->ctx, pipe_ctx->tg->inst);
 		}
+
 		pipe_ctx->tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
 		pipe_ctx->tg->dlg_otg_param.vstartup_start = pipe_ctx->pipe_dlg_param.vstartup_start;
 		pipe_ctx->tg->dlg_otg_param.vupdate_offset = pipe_ctx->pipe_dlg_param.vupdate_offset;
 		pipe_ctx->tg->dlg_otg_param.vupdate_width = pipe_ctx->pipe_dlg_param.vupdate_width;
 		pipe_ctx->tg->dlg_otg_param.signal =  pipe_ctx->stream->signal;
+
 		pipe_ctx->tg->funcs->program_global_sync(
 				pipe_ctx->tg);
+
+
+
 		update_dchubp_dpp(dc, pipe_ctx, context);
 	}
 

commit 8d1b404744d0040d2d85c1ff7737a38f29770826
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed May 3 10:25:51 2017 -0400

    drm/amd/display: Only apply ctx for specific surface.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index fb4eb4364bc7..ece8c96f3636 100644
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1689,19 +1689,21 @@ static void dcn10_apply_ctx_for_surface(
 {
 	int i;
 
-	memcpy(context->res_ctx.mpc_tree,
-			dc->current_context->res_ctx.mpc_tree,
-			sizeof(struct mpc_tree_cfg) * dc->res_pool->pipe_count);
-
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		if (!pipe_ctx->surface)
+		if (!pipe_ctx->surface || pipe_ctx->surface != surface)
 			continue;
 
+
 		/* looking for top pipe to program */
-		if (!pipe_ctx->top_pipe)
+		if (!pipe_ctx->top_pipe) {
+			memcpy(context->res_ctx.mpc_tree,
+					dc->current_context->res_ctx.mpc_tree,
+					sizeof(struct mpc_tree_cfg) * dc->res_pool->pipe_count);
+
 			program_all_pipe_in_tree(dc, pipe_ctx, context);
+		}
 	}
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {

commit 70ccab604049bbb995a57ab3b7fe8a3c2fdbb736
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon May 8 15:19:06 2017 -0400

    drm/amdgpu/display: Add core dc support for DCN
    
    Core display support for DCN.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
new file mode 100644
index 000000000000..fb4eb4364bc7
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -0,0 +1,1866 @@
+/*
+ * Copyright 2016 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dm_services.h"
+#include "dc.h"
+#include "core_dc.h"
+#include "core_types.h"
+#include "core_status.h"
+#include "resource.h"
+#include "hw_sequencer.h"
+#include "dcn10_hw_sequencer.h"
+#include "dce110/dce110_hw_sequencer.h"
+#include "abm.h"
+
+#include "dcn10/dcn10_transform.h"
+#include "dcn10/dcn10_mpc.h"
+#include "dcn10/dcn10_timing_generator.h"
+
+#include "mem_input.h"
+#include "timing_generator.h"
+#include "opp.h"
+#include "ipp.h"
+
+#include "dc_bios_types.h"
+
+#include "raven1/DCN/dcn_1_0_offset.h"
+#include "raven1/DCN/dcn_1_0_sh_mask.h"
+#include "vega10/soc15ip.h"
+
+#include "custom_float.h"
+
+
+struct dcn10_hwseq_reg_offsets {
+	uint32_t dchubp;
+	uint32_t dpp;
+	uint32_t otg;
+	uint32_t vtg;
+	uint32_t fmt;
+};
+
+/* TODO: move to resource */
+static const struct dcn10_hwseq_reg_offsets reg_offsets[] = {
+	{
+		.dchubp = (mmHUBP0_DCHUBP_CNTL - mmHUBP0_DCHUBP_CNTL),
+		.dpp = (mmCM0_CM_DGAM_CONTROL - mmCM0_CM_DGAM_CONTROL),
+		.otg = (mmOTG0_OTG_CONTROL - mmOTG0_OTG_CONTROL),
+		.vtg = (mmVTG0_CONTROL - mmVTG0_CONTROL),
+		.fmt = (mmFMT0_FMT_BIT_DEPTH_CONTROL -
+				mmFMT0_FMT_BIT_DEPTH_CONTROL),
+	},
+	{
+		.dchubp = (mmHUBP1_DCHUBP_CNTL - mmHUBP0_DCHUBP_CNTL),
+		.dpp = (mmCM1_CM_DGAM_CONTROL - mmCM0_CM_DGAM_CONTROL),
+		.otg = (mmOTG1_OTG_CONTROL - mmOTG0_OTG_CONTROL),
+		.vtg = (mmVTG1_CONTROL - mmVTG0_CONTROL),
+		.fmt = (mmFMT1_FMT_BIT_DEPTH_CONTROL -
+				mmFMT0_FMT_BIT_DEPTH_CONTROL),
+	},
+	{
+		.dchubp = (mmHUBP2_DCHUBP_CNTL - mmHUBP0_DCHUBP_CNTL),
+		.dpp = (mmCM2_CM_DGAM_CONTROL - mmCM0_CM_DGAM_CONTROL),
+		.otg = (mmOTG2_OTG_CONTROL - mmOTG0_OTG_CONTROL),
+		.vtg = (mmVTG2_CONTROL - mmVTG0_CONTROL),
+		.fmt = (mmFMT2_FMT_BIT_DEPTH_CONTROL -
+				mmFMT0_FMT_BIT_DEPTH_CONTROL),
+	},
+	{
+		.dchubp = (mmHUBP3_DCHUBP_CNTL - mmHUBP0_DCHUBP_CNTL),
+		.dpp = (mmCM3_CM_DGAM_CONTROL - mmCM0_CM_DGAM_CONTROL),
+		.otg = (mmOTG3_OTG_CONTROL - mmOTG0_OTG_CONTROL),
+		.vtg = (mmVTG3_CONTROL - mmVTG0_CONTROL),
+		.fmt = (mmFMT3_FMT_BIT_DEPTH_CONTROL -
+				mmFMT0_FMT_BIT_DEPTH_CONTROL),
+	}
+};
+
+#define HWSEQ_REG_UPDATE_N(reg_name, n, ...)	\
+		generic_reg_update_soc15(ctx, inst_offset, reg_name, n, __VA_ARGS__)
+
+#define HWSEQ_REG_SET_N(reg_name, n, ...)	\
+		generic_reg_set_soc15(ctx, inst_offset, reg_name, n, __VA_ARGS__)
+
+#define HWSEQ_REG_UPDATE(reg, field, val)	\
+		HWSEQ_REG_UPDATE_N(reg, 1, FD(reg##__##field), val)
+
+#define HWSEQ_REG_UPDATE_2(reg, field1, val1, field2, val2)	\
+		HWSEQ_REG_UPDATE_N(reg, 2, FD(reg##__##field1), val1, FD(reg##__##field2), val2)
+
+#define HWSEQ_REG_UPDATE_3(reg, field1, val1, field2, val2, field3, val3)	\
+		HWSEQ_REG_UPDATE_N(reg, 2, FD(reg##__##field1), val1, FD(reg##__##field2), val2, FD(reg##__##field3), val3)
+
+
+#define HWSEQ_REG_SET(reg, field, val)	\
+		HWSEQ_REG_SET_N(reg, 1, FD(reg##__##field), val)
+
+/* TODO should be moved to OTG */
+static void lock_otg_master_update(
+	struct dc_context *ctx,
+	uint8_t inst)
+{
+	uint32_t inst_offset = reg_offsets[inst].otg;
+
+	HWSEQ_REG_UPDATE(OTG0_OTG_GLOBAL_CONTROL0,
+			OTG_MASTER_UPDATE_LOCK_SEL, inst);
+
+	/* unlock master locker */
+	HWSEQ_REG_UPDATE(OTG0_OTG_MASTER_UPDATE_LOCK,
+			OTG_MASTER_UPDATE_LOCK, 1);
+
+	/* wait for unlock happens */
+	if (!wait_reg(ctx, inst_offset, OTG0_OTG_MASTER_UPDATE_LOCK, UPDATE_LOCK_STATUS, 1))
+			BREAK_TO_DEBUGGER();
+
+}
+
+static bool unlock_master_tg_and_wait(
+	struct dc_context *ctx,
+	uint8_t inst)
+{
+	uint32_t inst_offset = reg_offsets[inst].otg;
+
+	HWSEQ_REG_UPDATE(OTG0_OTG_GLOBAL_SYNC_STATUS,
+			VUPDATE_NO_LOCK_EVENT_CLEAR, 1);
+	HWSEQ_REG_UPDATE(OTG0_OTG_MASTER_UPDATE_LOCK, OTG_MASTER_UPDATE_LOCK, 0);
+
+	if (!wait_reg(ctx, inst_offset, OTG0_OTG_GLOBAL_SYNC_STATUS, VUPDATE_NO_LOCK_EVENT_OCCURRED, 1)) {
+		dm_logger_write(ctx->logger, LOG_ERROR,
+				"wait for VUPDATE_NO_LOCK_EVENT_OCCURRED failed\n");
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+	return true;
+}
+
+/* TODO: should be  moved to OTG ? */
+static void unlock_otg_master(
+	struct dc_context *ctx,
+	uint8_t inst)
+{
+	uint32_t inst_offset = reg_offsets[inst].otg;
+
+	/* unlock master locker */
+	HWSEQ_REG_UPDATE(OTG0_OTG_MASTER_UPDATE_LOCK,
+			OTG_MASTER_UPDATE_LOCK, 0);
+}
+
+
+static void wait_no_outstanding_request(
+	struct dc_context *ctx,
+	uint8_t plane_id)
+{
+	uint32_t inst_offset = reg_offsets[plane_id].dchubp;
+
+	if (!wait_reg(ctx, inst_offset, HUBP0_DCHUBP_CNTL, HUBP_NO_OUTSTANDING_REQ, 1))
+				BREAK_TO_DEBUGGER();
+}
+
+static void disable_clocks(
+	struct dc_context *ctx,
+	uint8_t plane_id)
+{
+	uint32_t inst_offset = reg_offsets[plane_id].dchubp;
+
+	generic_reg_update_soc15(ctx, inst_offset, HUBP0_HUBP_CLK_CNTL, 1,
+			FD(HUBP0_HUBP_CLK_CNTL__HUBP_CLOCK_ENABLE), 0);
+
+	inst_offset = reg_offsets[plane_id].dpp;
+	generic_reg_update_soc15(ctx, inst_offset, DPP_TOP0_DPP_CONTROL, 1,
+				FD(DPP_TOP0_DPP_CONTROL__DPP_CLOCK_ENABLE), 0);
+}
+
+/* TODO: This is one time program during system boot up,
+ * this should be done within BIOS or CAIL
+ */
+static void dchubp_map_fb_to_mc(struct dc_context *ctx)
+{
+	/* TODO: do not know where to program
+	 * DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB
+	 */
+	/*
+	 * TODO: For real ASIC, FB_OFFSET may be need change to the same value
+	 * as FB_BASE. Need re-visit this for real ASIC.
+	 */
+	dm_write_reg_soc15(ctx, mmDCHUBBUB_SDPIF_FB_BASE, 0, 0x80);
+	dm_write_reg_soc15(ctx, mmDCHUBBUB_SDPIF_FB_OFFSET, 0, 0);
+	dm_write_reg_soc15(ctx, mmDCHUBBUB_SDPIF_FB_TOP, 0, 0xFF);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_CFG0, 7,
+			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_DATA_RESPONSE_STATUS_CLEAR), 0,
+			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_REQ_CREDIT_ERROR_CLEAR), 0,
+			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_FLUSH_REQ_CREDIT_EN), 0,
+			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_REQ_CREDIT_EN), 0,
+			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_PORT_CONTROL), 1,
+			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_UNIT_ID_BITMASK), 0xd3,
+			FD(DCHUBBUB_SDPIF_CFG0__SDPIF_CREDIT_DISCONNECT_DELAY), 0xc);
+
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_CFG1, 4,
+			FD(DCHUBBUB_SDPIF_CFG1__SDPIF_INSIDE_FB_IO), 0,
+			FD(DCHUBBUB_SDPIF_CFG1__SDPIF_INSIDE_FB_VC), 6,
+			FD(DCHUBBUB_SDPIF_CFG1__SDPIF_OUTSIDE_FB_IO), 1,
+			FD(DCHUBBUB_SDPIF_CFG1__SDPIF_OUTSIDE_FB_VC), 6);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_FB_BASE, 1,
+			FD(DCHUBBUB_SDPIF_FB_BASE__SDPIF_FB_BASE), 0x000080);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_FB_TOP, 1,
+			FD(DCHUBBUB_SDPIF_FB_TOP__SDPIF_FB_TOP), 0x0000ff);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_AGP_BOT, 1,
+			FD(DCHUBBUB_SDPIF_AGP_BOT__SDPIF_AGP_BOT), 0x0000040);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_AGP_TOP, 1,
+			FD(DCHUBBUB_SDPIF_AGP_TOP__SDPIF_AGP_TOP), 0x00001ff);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_AGP_BASE, 1,
+			FD(DCHUBBUB_SDPIF_AGP_BASE__SDPIF_AGP_BASE), 0x0000080);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_APER_TOP, 1,
+			FD(DCHUBBUB_SDPIF_APER_TOP__SDPIF_APER_TOP), 0x00007ff);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_APER_DEF_0, 1,
+			FD(DCHUBBUB_SDPIF_APER_DEF_0__SDPIF_APER_DEF_0), 0xdeadbeef);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_RELOC_LO_0, 2,
+			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_0__SDPIF_MARC_EN_0), 0,
+			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_0__SDPIF_MARC_RELOC_LO_0), 0x90000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_LENGTH_LO_0, 1,
+			FD(DCHUBBUB_SDPIF_MARC_LENGTH_LO_0__SDPIF_MARC_LENGTH_LO_0), 0x10000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_BASE_LO_1, 1,
+			FD(DCHUBBUB_SDPIF_MARC_BASE_LO_1__SDPIF_MARC_BASE_LO_1), 0x10000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_RELOC_LO_1, 2,
+			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_1__SDPIF_MARC_EN_1), 0,
+			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_1__SDPIF_MARC_RELOC_LO_1), 0xa0000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_LENGTH_LO_1, 1,
+			FD(DCHUBBUB_SDPIF_MARC_LENGTH_LO_1__SDPIF_MARC_LENGTH_LO_1), 0x10000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_BASE_LO_2, 1,
+			FD(DCHUBBUB_SDPIF_MARC_BASE_LO_2__SDPIF_MARC_BASE_LO_2), 0x20000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_RELOC_LO_2, 2,
+			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_2__SDPIF_MARC_EN_2), 0,
+			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_2__SDPIF_MARC_RELOC_LO_2), 0xb0000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_LENGTH_LO_2, 1,
+			FD(DCHUBBUB_SDPIF_MARC_LENGTH_LO_2__SDPIF_MARC_LENGTH_LO_2), 0x10000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_BASE_LO_3, 1,
+			FD(DCHUBBUB_SDPIF_MARC_BASE_LO_3__SDPIF_MARC_BASE_LO_3), 0x30000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_RELOC_LO_3, 2,
+			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_3__SDPIF_MARC_EN_3), 0,
+			FD(DCHUBBUB_SDPIF_MARC_RELOC_LO_3__SDPIF_MARC_RELOC_LO_3), 0xc0000);
+
+	generic_reg_set_soc15(ctx, 0, DCHUBBUB_SDPIF_MARC_LENGTH_LO_3, 1,
+			FD(DCHUBBUB_SDPIF_MARC_LENGTH_LO_3__SDPIF_MARC_LENGTH_LO_3), 0x10000);
+
+	/* TODO: Is DCN_VM_SYSTEM_APERTURE address one time programming?
+	 * Are all 4 hubp programmed with the same address?
+	 */
+	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB, 0, 0x80000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_MSB, 0, 0);
+	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, 0, 0x100000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB, 0, 0);
+	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, 0, 0x80000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ0_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, 0, 0);
+
+	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB, 0, 0x80000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_MSB, 0, 0);
+	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, 0, 0x100000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB, 0, 0);
+	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, 0, 0x80000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ1_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, 0, 0);
+
+	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB, 0, 0x80000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_MSB, 0, 0);
+	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, 0, 0x100000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB, 0, 0);
+	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, 0, 0x80000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ2_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, 0, 0);
+
+	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_LSB, 0, 0x80000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_LOW_ADDR_MSB, 0, 0);
+	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_LSB, 0, 0x100000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_HIGH_ADDR_MSB, 0, 0);
+	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_LSB, 0, 0x80000);
+	dm_write_reg_soc15(ctx, mmHUBPREQ3_DCN_VM_SYSTEM_APERTURE_DEFAULT_ADDR_MSB, 0, 0);
+}
+
+/* TODO: This is one time program during system boot up,
+ * this should be done within BIOS
+ */
+static void dchubup_setup_timer(struct dc_context *ctx)
+{
+	dm_write_reg_soc15(ctx, mmREFCLK_CNTL, 0, 0);
+
+	generic_reg_update_soc15(ctx, 0, DCHUBBUB_GLOBAL_TIMER_CNTL, 1,
+			FD(DCHUBBUB_GLOBAL_TIMER_CNTL__DCHUBBUB_GLOBAL_TIMER_ENABLE), 1);
+}
+
+/* TODO: Need input parameter to tell current DCHUB pipe tie to which OTG
+ * VTG is within DCHUBBUB which is commond block share by each pipe HUBP.
+ * VTG is 1:1 mapping with OTG. Each pipe HUBP will select which VTG
+ */
+static void select_vtg(
+	struct dc_context *ctx,
+	uint8_t plane_id,
+	uint8_t inst)
+{
+	uint32_t inst_offset = reg_offsets[plane_id].dchubp;
+
+	HWSEQ_REG_UPDATE(HUBP0_DCHUBP_CNTL, HUBP_VTG_SEL, inst);
+}
+
+static void enable_dcfclk(
+	struct dc_context *ctx,
+	uint8_t plane_id,
+	uint32_t requested_pix_clk,
+	bool dppclk_div)
+{
+	uint32_t inst_offset = reg_offsets[plane_id].dchubp;
+
+	HWSEQ_REG_UPDATE(HUBP0_HUBP_CLK_CNTL, HUBP_CLOCK_ENABLE, 1);
+}
+
+static void enable_dppclk(
+	struct dc_context *ctx,
+	uint8_t plane_id,
+	uint32_t requested_pix_clk,
+	bool dppclk_div)
+{
+	uint32_t inst_offset = reg_offsets[plane_id].dpp;
+
+	dm_logger_write(ctx->logger, LOG_SURFACE,
+			"dppclk_rate_control for pipe %d programed to %d\n",
+			plane_id,
+			dppclk_div);
+
+	/* TODO: find condition for DPP clock to DISPCLK or 1/2 DISPCLK */
+	if (dppclk_div) {
+		/* 1/2 DISPCLK*/
+		HWSEQ_REG_UPDATE_2(DPP_TOP0_DPP_CONTROL,
+			DPPCLK_RATE_CONTROL, 1,
+			DPP_CLOCK_ENABLE, 1);
+	} else {
+		/* DISPCLK */
+		HWSEQ_REG_UPDATE_2(DPP_TOP0_DPP_CONTROL,
+			DPPCLK_RATE_CONTROL, 0,
+			DPP_CLOCK_ENABLE, 1);
+	}
+}
+
+static void enable_power_gating_plane(
+	struct dc_context *ctx,
+	bool enable)
+{
+	uint32_t inst_offset = 0; /* each register only has one instance */
+	bool force_on = 1; /* disable power gating */
+
+	if (enable)
+		force_on = 0;
+
+	/* DCHUBP0/1/2/3 */
+	HWSEQ_REG_UPDATE(DOMAIN0_PG_CONFIG, DOMAIN0_POWER_FORCEON, force_on);
+	HWSEQ_REG_UPDATE(DOMAIN2_PG_CONFIG, DOMAIN2_POWER_FORCEON, force_on);
+	HWSEQ_REG_UPDATE(DOMAIN4_PG_CONFIG, DOMAIN4_POWER_FORCEON, force_on);
+	HWSEQ_REG_UPDATE(DOMAIN6_PG_CONFIG, DOMAIN6_POWER_FORCEON, force_on);
+
+	/* DPP0/1/2/3 */
+	HWSEQ_REG_UPDATE(DOMAIN1_PG_CONFIG, DOMAIN1_POWER_FORCEON, force_on);
+	HWSEQ_REG_UPDATE(DOMAIN3_PG_CONFIG, DOMAIN3_POWER_FORCEON, force_on);
+	HWSEQ_REG_UPDATE(DOMAIN5_PG_CONFIG, DOMAIN5_POWER_FORCEON, force_on);
+	HWSEQ_REG_UPDATE(DOMAIN7_PG_CONFIG, DOMAIN7_POWER_FORCEON, force_on);
+
+	if (ctx->dc->debug.disable_clock_gate) {
+		/* probably better to just write entire register to 0xffff to
+		 * ensure all clock gating is disabled
+		 */
+		HWSEQ_REG_UPDATE_3(DCCG_GATE_DISABLE_CNTL,
+				DISPCLK_R_DCCG_GATE_DISABLE, 1,
+				DPREFCLK_R_DCCG_GATE_DISABLE, 1,
+				REFCLK_R_DIG_GATE_DISABLE, 1);
+		HWSEQ_REG_UPDATE(DCFCLK_CNTL,
+				DCFCLK_GATE_DIS, 1);
+	}
+
+}
+
+static void dpp_pg_control(
+		struct dc_context *ctx,
+		unsigned int dpp_inst,
+		bool power_on)
+{
+	uint32_t inst_offset = 0;
+	uint32_t power_gate = power_on ? 0 : 1;
+	uint32_t pwr_status = power_on ? 0 : 2;
+
+	if (ctx->dc->debug.disable_dpp_power_gate)
+		return;
+
+	switch (dpp_inst) {
+	case 0: /* DPP0 */
+		HWSEQ_REG_UPDATE(DOMAIN1_PG_CONFIG,
+				DOMAIN1_POWER_GATE, power_gate);
+
+		wait_reg(ctx, 0, DOMAIN1_PG_STATUS,
+				DOMAIN1_PGFSM_PWR_STATUS, pwr_status);
+		break;
+	case 1: /* DPP1 */
+		HWSEQ_REG_UPDATE(DOMAIN3_PG_CONFIG,
+				DOMAIN3_POWER_GATE, power_gate);
+
+		wait_reg(ctx, 0, DOMAIN3_PG_STATUS,
+				DOMAIN3_PGFSM_PWR_STATUS, pwr_status);
+		break;
+	case 2: /* DPP2 */
+		HWSEQ_REG_UPDATE(DOMAIN5_PG_CONFIG,
+				DOMAIN5_POWER_GATE, power_gate);
+
+		wait_reg(ctx, 0, DOMAIN5_PG_STATUS,
+				DOMAIN5_PGFSM_PWR_STATUS, pwr_status);
+		break;
+	case 3: /* DPP3 */
+		HWSEQ_REG_UPDATE(DOMAIN7_PG_CONFIG,
+				DOMAIN7_POWER_GATE, power_gate);
+
+		wait_reg(ctx, 0, DOMAIN7_PG_STATUS,
+				DOMAIN7_PGFSM_PWR_STATUS, pwr_status);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		break;
+	}
+}
+
+static void hubp_pg_control(
+		struct dc_context *ctx,
+		unsigned int hubp_inst,
+		bool power_on)
+{
+	uint32_t inst_offset = 0;
+	uint32_t power_gate = power_on ? 0 : 1;
+	uint32_t pwr_status = power_on ? 0 : 2;
+
+	if (ctx->dc->debug.disable_hubp_power_gate)
+		return;
+
+	switch (hubp_inst) {
+	case 0: /* DCHUBP0 */
+		HWSEQ_REG_UPDATE(DOMAIN0_PG_CONFIG,
+				DOMAIN0_POWER_GATE, power_gate);
+
+		wait_reg(ctx, 0, DOMAIN0_PG_STATUS,
+				DOMAIN0_PGFSM_PWR_STATUS, pwr_status);
+		break;
+	case 1: /* DCHUBP1 */
+		HWSEQ_REG_UPDATE(DOMAIN2_PG_CONFIG,
+				DOMAIN2_POWER_GATE, power_gate);
+
+		wait_reg(ctx, 0, DOMAIN2_PG_STATUS,
+				DOMAIN2_PGFSM_PWR_STATUS, pwr_status);
+		break;
+	case 2: /* DCHUBP2 */
+		HWSEQ_REG_UPDATE(DOMAIN4_PG_CONFIG,
+				DOMAIN4_POWER_GATE, power_gate);
+
+		wait_reg(ctx, 0, DOMAIN4_PG_STATUS,
+				DOMAIN4_PGFSM_PWR_STATUS, pwr_status);
+		break;
+	case 3: /* DCHUBP3 */
+		HWSEQ_REG_UPDATE(DOMAIN6_PG_CONFIG,
+				DOMAIN6_POWER_GATE, power_gate);
+
+		wait_reg(ctx, 0, DOMAIN6_PG_STATUS,
+				DOMAIN6_PGFSM_PWR_STATUS, pwr_status);
+		break;
+	default:
+		BREAK_TO_DEBUGGER();
+		break;
+	}
+}
+
+static void power_on_plane(
+	struct dc_context *ctx,
+	uint8_t plane_id,
+	uint8_t inst)
+{
+	uint32_t inst_offset = 0;
+
+	/* disable clock power gating */
+
+	/* DCCG_GATE_DISABLE_CNTL only has one instance */
+	HWSEQ_REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL,
+			DISPCLK_DCCG_GATE_DISABLE, 1,
+			DPPCLK_GATE_DISABLE, 1);
+	/* DCFCLK_CNTL only has one instance */
+	HWSEQ_REG_UPDATE(DCFCLK_CNTL,
+			DCFCLK_GATE_DIS, 1);
+
+	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
+			IP_REQUEST_EN, 1);
+	dpp_pg_control(ctx, plane_id, true);
+	hubp_pg_control(ctx, plane_id, true);
+	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
+			IP_REQUEST_EN, 0);
+
+	if (ctx->dc->debug.disable_clock_gate) {
+		HWSEQ_REG_UPDATE(DCCG_GATE_DISABLE_CNTL,
+				DISPCLK_DCCG_GATE_DISABLE, 0);
+	} else {
+		/* DCCG_GATE_DISABLE_CNTL only has one instance. inst_offset = 0 */
+		HWSEQ_REG_UPDATE_2(DCCG_GATE_DISABLE_CNTL,
+				DISPCLK_DCCG_GATE_DISABLE, 0,
+				DPPCLK_GATE_DISABLE, 0);
+		/* DCFCLK_CNTL only has one instance. inst_offset = 0 */
+		HWSEQ_REG_UPDATE(DCFCLK_CNTL,
+				DCFCLK_GATE_DIS, 0);
+	}
+}
+
+/* fully check bios enabledisplaypowergating table. dal only need dce init
+ * other power, clock gate register will be handle by dal itself.
+ * further may be put within init_hw
+ */
+static bool dcn10_enable_display_power_gating(
+	struct core_dc *dc,
+	uint8_t controller_id,
+	struct dc_bios *dcb,
+	enum pipe_gating_control power_gating)
+{
+	/* TODOFPGA */
+#if 0
+	if (power_gating != PIPE_GATING_CONTROL_ENABLE)
+		dce110_init_pte(ctx);
+#endif
+
+	return true;
+}
+
+static void bios_golden_init(struct core_dc *dc)
+{
+	struct dc_bios *bp = dc->ctx->dc_bios;
+	int i;
+
+	/* initialize dcn global */
+	bp->funcs->enable_disp_power_gating(bp,
+			CONTROLLER_ID_D0, ASIC_PIPE_INIT);
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		/* initialize dcn per pipe */
+		bp->funcs->enable_disp_power_gating(bp,
+				CONTROLLER_ID_D0 + i, ASIC_PIPE_DISABLE);
+	}
+}
+
+static void init_hw(struct core_dc *dc)
+{
+	int i;
+	struct dc_bios *bp;
+	struct transform *xfm;
+	struct abm *abm;
+
+	bp = dc->ctx->dc_bios;
+
+	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
+		/* TODO: this will be moved to Diag or BIOS */
+		dchubup_setup_timer(dc->ctx);
+
+		/* TODO: dchubp_map_fb_to_mc will be moved to dchub interface
+		 * between dc and kmd
+		 */
+		dchubp_map_fb_to_mc(dc->ctx);
+
+		enable_power_gating_plane(dc->ctx, true);
+		return;
+	}
+	/* end of FPGA. Below if real ASIC */
+
+	bios_golden_init(dc);
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		xfm = dc->res_pool->transforms[i];
+		xfm->funcs->transform_reset(xfm);
+
+		/* TODOFPGA: may need later */
+#if 0
+		xfm->funcs->transform_power_up(xfm);
+		dc->hwss.enable_display_pipe_clock_gating(
+			dc->ctx,
+			true);
+#endif
+	}
+	/* TODOFPGA: light sleep */
+#if 0
+	dc->hwss.clock_gating_power_up(dc->ctx, false);
+#endif
+
+	for (i = 0; i < dc->link_count; i++) {
+		/* Power up AND update implementation according to the
+		 * required signal (which may be different from the
+		 * default signal on connector).
+		 */
+		struct core_link *link = dc->links[i];
+
+		link->link_enc->funcs->hw_init(link->link_enc);
+	}
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct timing_generator *tg =
+				dc->res_pool->timing_generators[i];
+
+		tg->funcs->disable_vga(tg);
+
+		/* Blank controller using driver code instead of
+		 * command table.
+		 */
+		tg->funcs->set_blank(tg, true);
+		hwss_wait_for_blank_complete(tg);
+	}
+
+	for (i = 0; i < dc->res_pool->audio_count; i++) {
+		struct audio *audio = dc->res_pool->audios[i];
+
+		audio->funcs->hw_init(audio);
+	}
+
+	abm = dc->res_pool->abm;
+	if (abm != NULL) {
+		abm->funcs->init_backlight(abm);
+		abm->funcs->abm_init(abm);
+	}
+
+	/* power AFMT HDMI memory TODO: may move to dis/en output save power*/
+	generic_reg_set_soc15(dc->ctx, 0, DIO_MEM_PWR_CTRL, 7,
+			FD(DIO_MEM_PWR_CTRL__HDMI0_MEM_PWR_FORCE), 0,
+			FD(DIO_MEM_PWR_CTRL__HDMI1_MEM_PWR_FORCE), 0,
+			FD(DIO_MEM_PWR_CTRL__HDMI2_MEM_PWR_FORCE), 0,
+			FD(DIO_MEM_PWR_CTRL__HDMI3_MEM_PWR_FORCE), 0,
+			FD(DIO_MEM_PWR_CTRL__HDMI4_MEM_PWR_FORCE), 0,
+			FD(DIO_MEM_PWR_CTRL__HDMI5_MEM_PWR_FORCE), 0,
+			FD(DIO_MEM_PWR_CTRL__HDMI6_MEM_PWR_FORCE), 0);
+
+	/* This power gating should be one-time program for DAL.
+	 * It can only change by registry key
+	 * TODO: new task will for this.
+	 * if power gating is disable, power_on_plane and power_off_plane
+	 * should be skip. Otherwise, hand will be met in power_off_plane
+	 */
+
+	enable_power_gating_plane(dc->ctx, true);
+}
+
+static enum dc_status dcn10_prog_pixclk_crtc_otg(
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context,
+		struct core_dc *dc)
+{
+	struct core_stream *stream = pipe_ctx->stream;
+	enum dc_color_space color_space;
+	struct tg_color black_color = {0};
+	bool enableStereo    = stream->public.timing.timing_3d_format == TIMING_3D_FORMAT_NONE ?
+			false:true;
+	bool rightEyePolarity = stream->public.timing.flags.RIGHT_EYE_3D_POLARITY;
+
+
+	/* by upper caller loop, pipe0 is parent pipe and be called first.
+	 * back end is set up by for pipe0. Other children pipe share back end
+	 * with pipe 0. No program is needed.
+	 */
+	if (pipe_ctx->top_pipe != NULL)
+		return DC_OK;
+
+	/* TODO check if timing_changed, disable stream if timing changed */
+
+	/* HW program guide assume display already disable
+	 * by unplug sequence. OTG assume stop.
+	 */
+	pipe_ctx->tg->funcs->enable_optc_clock(pipe_ctx->tg, true);
+
+	if (false == pipe_ctx->clock_source->funcs->program_pix_clk(
+			pipe_ctx->clock_source,
+			&pipe_ctx->pix_clk_params,
+			&pipe_ctx->pll_settings)) {
+		BREAK_TO_DEBUGGER();
+		return DC_ERROR_UNEXPECTED;
+	}
+	pipe_ctx->tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
+	pipe_ctx->tg->dlg_otg_param.vstartup_start = pipe_ctx->pipe_dlg_param.vstartup_start;
+	pipe_ctx->tg->dlg_otg_param.vupdate_offset = pipe_ctx->pipe_dlg_param.vupdate_offset;
+	pipe_ctx->tg->dlg_otg_param.vupdate_width = pipe_ctx->pipe_dlg_param.vupdate_width;
+
+	pipe_ctx->tg->dlg_otg_param.signal =  pipe_ctx->stream->signal;
+
+	pipe_ctx->tg->funcs->program_timing(
+			pipe_ctx->tg,
+			&stream->public.timing,
+			true);
+
+	pipe_ctx->opp->funcs->opp_set_stereo_polarity(
+				pipe_ctx->opp,
+				enableStereo,
+				rightEyePolarity);
+
+#if 0 /* move to after enable_crtc */
+	/* TODO: OPP FMT, ABM. etc. should be done here. */
+	/* or FPGA now. instance 0 only. TODO: move to opp.c */
+
+	inst_offset = reg_offsets[pipe_ctx->tg->inst].fmt;
+
+	pipe_ctx->opp->funcs->opp_program_fmt(
+				pipe_ctx->opp,
+				&stream->bit_depth_params,
+				&stream->clamping);
+#endif
+	/* program otg blank color */
+	color_space = stream->public.output_color_space;
+	color_space_to_black_color(dc, color_space, &black_color);
+	pipe_ctx->tg->funcs->set_blank_color(
+			pipe_ctx->tg,
+			&black_color);
+
+	pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, true);
+	hwss_wait_for_blank_complete(pipe_ctx->tg);
+
+	/* VTG is  within DCHUB command block. DCFCLK is always on */
+	if (false == pipe_ctx->tg->funcs->enable_crtc(pipe_ctx->tg)) {
+		BREAK_TO_DEBUGGER();
+		return DC_ERROR_UNEXPECTED;
+	}
+
+	/* TODO program crtc source select for non-virtual signal*/
+	/* TODO program FMT */
+	/* TODO setup link_enc */
+	/* TODO set stream attributes */
+	/* TODO program audio */
+	/* TODO enable stream if timing changed */
+	/* TODO unblank stream if DP */
+
+	return DC_OK;
+}
+
+static void reset_back_end_for_pipe(
+		struct core_dc *dc,
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context)
+{
+	int i;
+	struct dc_bios *bp;
+
+	bp = dc->ctx->dc_bios;
+
+	if (pipe_ctx->stream_enc == NULL) {
+		pipe_ctx->stream = NULL;
+		return;
+	}
+
+	/* TODOFPGA break core_link_disable_stream into 2 functions:
+	 * disable_stream and disable_link. disable_link will disable PHYPLL
+	 * which is used by otg. Move disable_link after disable_crtc
+	 */
+	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
+		core_link_disable_stream(pipe_ctx);
+
+	/* by upper caller loop, parent pipe: pipe0, will be reset last.
+	 * back end share by all pipes and will be disable only when disable
+	 * parent pipe.
+	 */
+	if (pipe_ctx->top_pipe == NULL) {
+		pipe_ctx->tg->funcs->disable_crtc(pipe_ctx->tg);
+
+		pipe_ctx->tg->funcs->enable_optc_clock(pipe_ctx->tg, false);
+	}
+
+	if (!IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
+		resource_unreference_clock_source(
+			&context->res_ctx, dc->res_pool,
+			&pipe_ctx->clock_source);
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++)
+		if (&dc->current_context->res_ctx.pipe_ctx[i] == pipe_ctx)
+			break;
+
+	if (i == dc->res_pool->pipe_count)
+		return;
+
+	pipe_ctx->stream = NULL;
+}
+
+static void reset_front_end_for_pipe(
+		struct core_dc *dc,
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context)
+{
+	struct dcn10_mpc *mpc = TO_DCN10_MPC(dc->res_pool->mpc);
+	struct mpc_tree_cfg *tree_cfg = NULL;
+
+	if (!pipe_ctx->surface)
+		return;
+
+	lock_otg_master_update(dc->ctx, pipe_ctx->tg->inst);
+
+	/* TODO: build stream pipes group id. For now, use stream otg
+	 * id as pipe group id
+	 */
+	tree_cfg = &context->res_ctx.mpc_tree[pipe_ctx->mpc_idx];
+
+	if (pipe_ctx->top_pipe == NULL)
+		dcn10_delete_mpc_tree(mpc, tree_cfg);
+	else {
+		if (dcn10_remove_dpp(mpc, tree_cfg, pipe_ctx->pipe_idx))
+			pipe_ctx->top_pipe->bottom_pipe = NULL;
+		else {
+			dm_logger_write(dc->ctx->logger, LOG_RESOURCE,
+				"%s: failed to find dpp to be removed!\n",
+				__func__);
+		}
+	}
+
+	pipe_ctx->top_pipe = NULL;
+	pipe_ctx->bottom_pipe = NULL;
+	pipe_ctx->mpc_idx = -1;
+
+	unlock_master_tg_and_wait(dc->ctx, pipe_ctx->tg->inst);
+
+	pipe_ctx->mi->funcs->disable_request(pipe_ctx->mi);
+
+	wait_no_outstanding_request(dc->ctx, pipe_ctx->pipe_idx);
+
+	wait_mpcc_idle(mpc, pipe_ctx->pipe_idx);
+
+	disable_clocks(dc->ctx, pipe_ctx->pipe_idx);
+
+	pipe_ctx->xfm->funcs->transform_reset(pipe_ctx->xfm);
+
+	dm_logger_write(dc->ctx->logger, LOG_DC,
+					"Reset front end for pipe %d\n",
+					pipe_ctx->pipe_idx);
+
+	pipe_ctx->surface = NULL;
+}
+
+static void reset_hw_ctx(struct core_dc *dc,
+		struct validate_context *context,
+		void (*reset)(struct core_dc *dc,
+				struct pipe_ctx *pipe_ctx,
+				struct validate_context *context))
+{
+	int i;
+
+	for (i = dc->res_pool->pipe_count - 1; i >= 0 ; i--) {
+		struct pipe_ctx *pipe_ctx_old =
+			&dc->current_context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (!pipe_ctx_old->stream)
+			continue;
+
+		if (!pipe_ctx->stream ||
+				pipe_need_reprogram(pipe_ctx_old, pipe_ctx))
+			reset(dc, pipe_ctx_old, dc->current_context);
+	}
+}
+
+static void reset_hw_ctx_wrap(
+		struct core_dc *dc,
+		struct validate_context *context)
+{
+	/* Reset Front End*/
+	reset_hw_ctx(dc, context, reset_front_end_for_pipe);
+	/* Reset Back End*/
+	reset_hw_ctx(dc, context, reset_back_end_for_pipe);
+
+	memcpy(context->res_ctx.mpc_tree,
+			dc->current_context->res_ctx.mpc_tree,
+			sizeof(struct mpc_tree_cfg) * dc->res_pool->pipe_count);
+}
+
+static bool patch_address_for_sbs_tb_stereo(struct pipe_ctx *pipe_ctx,
+											PHYSICAL_ADDRESS_LOC *addr)
+{
+	struct core_surface *surface = pipe_ctx->surface;
+	bool sec_split = pipe_ctx->top_pipe &&
+			pipe_ctx->top_pipe->surface == pipe_ctx->surface;
+	if (sec_split && surface->public.address.type == PLN_ADDR_TYPE_GRPH_STEREO &&
+		(pipe_ctx->stream->public.timing.timing_3d_format ==
+		 TIMING_3D_FORMAT_SIDE_BY_SIDE ||
+		 pipe_ctx->stream->public.timing.timing_3d_format ==
+		 TIMING_3D_FORMAT_TOP_AND_BOTTOM)) {
+		*addr = surface->public.address.grph_stereo.left_addr;
+		surface->public.address.grph_stereo.left_addr =\
+		surface->public.address.grph_stereo.right_addr;
+		return true;
+	}
+	return false;
+}
+
+static void update_plane_addr(const struct core_dc *dc, struct pipe_ctx *pipe_ctx)
+{
+	bool addr_patched = false;
+	PHYSICAL_ADDRESS_LOC addr;
+	struct core_surface *surface = pipe_ctx->surface;
+
+	if (surface == NULL)
+		return;
+	addr_patched = patch_address_for_sbs_tb_stereo(pipe_ctx, &addr);
+	pipe_ctx->mi->funcs->mem_input_program_surface_flip_and_addr(
+			pipe_ctx->mi,
+			&surface->public.address,
+			surface->public.flip_immediate);
+	surface->status.requested_address = surface->public.address;
+	if (addr_patched)
+		pipe_ctx->surface->public.address.grph_stereo.left_addr = addr;
+}
+
+static bool dcn10_set_input_transfer_func(
+	struct pipe_ctx *pipe_ctx,
+	const struct core_surface *surface)
+{
+	struct input_pixel_processor *ipp = pipe_ctx->ipp;
+	const struct core_transfer_func *tf = NULL;
+	bool result = true;
+
+	if (ipp == NULL)
+		return false;
+
+	if (surface->public.in_transfer_func)
+		tf = DC_TRANSFER_FUNC_TO_CORE(surface->public.in_transfer_func);
+
+	if (tf == NULL)
+		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
+	else if (tf->public.type == TF_TYPE_PREDEFINED) {
+		switch (tf->public.tf) {
+		case TRANSFER_FUNCTION_SRGB:
+			ipp->funcs->ipp_set_degamma(ipp,
+					IPP_DEGAMMA_MODE_HW_sRGB);
+			break;
+		case TRANSFER_FUNCTION_BT709:
+			ipp->funcs->ipp_set_degamma(ipp,
+					IPP_DEGAMMA_MODE_HW_xvYCC);
+			break;
+		case TRANSFER_FUNCTION_LINEAR:
+			ipp->funcs->ipp_set_degamma(ipp,
+					IPP_DEGAMMA_MODE_BYPASS);
+			break;
+		case TRANSFER_FUNCTION_PQ:
+			result = false;
+			break;
+		default:
+			result = false;
+			break;
+		}
+	} else if (tf->public.type == TF_TYPE_BYPASS) {
+		ipp->funcs->ipp_set_degamma(ipp, IPP_DEGAMMA_MODE_BYPASS);
+	} else {
+		/*TF_TYPE_DISTRIBUTED_POINTS*/
+		result = false;
+	}
+
+	return result;
+}
+/*modify the method to handle rgb for arr_points*/
+static bool convert_to_custom_float(
+		struct pwl_result_data *rgb_resulted,
+		struct curve_points *arr_points,
+		uint32_t hw_points_num)
+{
+	struct custom_float_format fmt;
+
+	struct pwl_result_data *rgb = rgb_resulted;
+
+	uint32_t i = 0;
+
+	fmt.exponenta_bits = 6;
+	fmt.mantissa_bits = 12;
+	fmt.sign = false;
+
+	if (!convert_to_custom_float_format(
+		arr_points[0].x,
+		&fmt,
+		&arr_points[0].custom_float_x)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	if (!convert_to_custom_float_format(
+		arr_points[0].offset,
+		&fmt,
+		&arr_points[0].custom_float_offset)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	if (!convert_to_custom_float_format(
+		arr_points[0].slope,
+		&fmt,
+		&arr_points[0].custom_float_slope)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	fmt.mantissa_bits = 10;
+	fmt.sign = false;
+
+	if (!convert_to_custom_float_format(
+		arr_points[1].x,
+		&fmt,
+		&arr_points[1].custom_float_x)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	if (!convert_to_custom_float_format(
+		arr_points[1].y,
+		&fmt,
+		&arr_points[1].custom_float_y)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	if (!convert_to_custom_float_format(
+		arr_points[1].slope,
+		&fmt,
+		&arr_points[1].custom_float_slope)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	fmt.mantissa_bits = 12;
+	fmt.sign = true;
+
+	while (i != hw_points_num) {
+		if (!convert_to_custom_float_format(
+			rgb->red,
+			&fmt,
+			&rgb->red_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		if (!convert_to_custom_float_format(
+			rgb->green,
+			&fmt,
+			&rgb->green_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		if (!convert_to_custom_float_format(
+			rgb->blue,
+			&fmt,
+			&rgb->blue_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		if (!convert_to_custom_float_format(
+			rgb->delta_red,
+			&fmt,
+			&rgb->delta_red_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		if (!convert_to_custom_float_format(
+			rgb->delta_green,
+			&fmt,
+			&rgb->delta_green_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		if (!convert_to_custom_float_format(
+			rgb->delta_blue,
+			&fmt,
+			&rgb->delta_blue_reg)) {
+			BREAK_TO_DEBUGGER();
+			return false;
+		}
+
+		++rgb;
+		++i;
+	}
+
+	return true;
+}
+#define MAX_REGIONS_NUMBER 34
+#define MAX_LOW_POINT      25
+#define NUMBER_SEGMENTS    32
+
+static bool dcn10_translate_regamma_to_hw_format(const struct dc_transfer_func
+		*output_tf, struct pwl_params *regamma_params)
+{
+	struct curve_points *arr_points;
+	struct pwl_result_data *rgb_resulted;
+	struct pwl_result_data *rgb;
+	struct pwl_result_data *rgb_plus_1;
+	struct fixed31_32 y_r;
+	struct fixed31_32 y_g;
+	struct fixed31_32 y_b;
+	struct fixed31_32 y1_min;
+	struct fixed31_32 y3_max;
+
+	int32_t segment_start, segment_end;
+	int32_t i;
+	uint32_t j, k, seg_distr[MAX_REGIONS_NUMBER], increment, start_index, hw_points;
+
+	if (output_tf == NULL || regamma_params == NULL ||
+			output_tf->type == TF_TYPE_BYPASS)
+		return false;
+
+	arr_points = regamma_params->arr_points;
+	rgb_resulted = regamma_params->rgb_resulted;
+	hw_points = 0;
+
+	memset(regamma_params, 0, sizeof(struct pwl_params));
+	memset(seg_distr, 0, sizeof(seg_distr));
+
+	if (output_tf->tf == TRANSFER_FUNCTION_PQ) {
+		/* 32 segments
+		 * segments are from 2^-25 to 2^7
+		 */
+		for (i = 0; i < 32 ; i++)
+			seg_distr[i] = 3;
+
+		segment_start = -25;
+		segment_end   = 7;
+	} else {
+		/* 10 segments
+		 * segment is from 2^-10 to 2^0
+		 * There are less than 256 points, for optimization
+		 */
+		seg_distr[0] = 3;
+		seg_distr[1] = 4;
+		seg_distr[2] = 4;
+		seg_distr[3] = 4;
+		seg_distr[4] = 4;
+		seg_distr[5] = 4;
+		seg_distr[6] = 4;
+		seg_distr[7] = 4;
+		seg_distr[8] = 5;
+		seg_distr[9] = 5;
+
+		segment_start = -10;
+		segment_end = 0;
+	}
+
+	for (i = segment_end - segment_start; i < MAX_REGIONS_NUMBER ; i++)
+		seg_distr[i] = -1;
+
+	for (k = 0; k < MAX_REGIONS_NUMBER; k++) {
+		if (seg_distr[k] != -1)
+			hw_points += (1 << seg_distr[k]);
+	}
+
+	j = 0;
+	for (k = 0; k < (segment_end - segment_start); k++) {
+		increment = NUMBER_SEGMENTS / (1 << seg_distr[k]);
+		start_index = (segment_start + k + MAX_LOW_POINT) * NUMBER_SEGMENTS;
+		for (i = start_index; i < start_index + NUMBER_SEGMENTS; i += increment) {
+			if (j == hw_points - 1)
+				break;
+			rgb_resulted[j].red = output_tf->tf_pts.red[i];
+			rgb_resulted[j].green = output_tf->tf_pts.green[i];
+			rgb_resulted[j].blue = output_tf->tf_pts.blue[i];
+			j++;
+		}
+	}
+
+	/* last point */
+	start_index = (segment_end + MAX_LOW_POINT) * NUMBER_SEGMENTS;
+	rgb_resulted[hw_points - 1].red =
+			output_tf->tf_pts.red[start_index];
+	rgb_resulted[hw_points - 1].green =
+			output_tf->tf_pts.green[start_index];
+	rgb_resulted[hw_points - 1].blue =
+			output_tf->tf_pts.blue[start_index];
+
+	arr_points[0].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
+			dal_fixed31_32_from_int(segment_start));
+	arr_points[1].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
+			dal_fixed31_32_from_int(segment_end));
+	arr_points[2].x = dal_fixed31_32_pow(dal_fixed31_32_from_int(2),
+			dal_fixed31_32_from_int(segment_end));
+
+	y_r = rgb_resulted[0].red;
+	y_g = rgb_resulted[0].green;
+	y_b = rgb_resulted[0].blue;
+
+	y1_min = dal_fixed31_32_min(y_r, dal_fixed31_32_min(y_g, y_b));
+
+	arr_points[0].y = y1_min;
+	arr_points[0].slope = dal_fixed31_32_div(
+					arr_points[0].y,
+					arr_points[0].x);
+	y_r = rgb_resulted[hw_points - 1].red;
+	y_g = rgb_resulted[hw_points - 1].green;
+	y_b = rgb_resulted[hw_points - 1].blue;
+
+	/* see comment above, m_arrPoints[1].y should be the Y value for the
+	 * region end (m_numOfHwPoints), not last HW point(m_numOfHwPoints - 1)
+	 */
+	y3_max = dal_fixed31_32_max(y_r, dal_fixed31_32_max(y_g, y_b));
+
+	arr_points[1].y = y3_max;
+	arr_points[2].y = y3_max;
+
+	arr_points[1].slope = dal_fixed31_32_zero;
+	arr_points[2].slope = dal_fixed31_32_zero;
+
+	if (output_tf->tf == TRANSFER_FUNCTION_PQ) {
+		/* for PQ, we want to have a straight line from last HW X point,
+		 * and the slope to be such that we hit 1.0 at 10000 nits.
+		 */
+		const struct fixed31_32 end_value =
+				dal_fixed31_32_from_int(125);
+
+		arr_points[1].slope = dal_fixed31_32_div(
+			dal_fixed31_32_sub(dal_fixed31_32_one, arr_points[1].y),
+			dal_fixed31_32_sub(end_value, arr_points[1].x));
+		arr_points[2].slope = dal_fixed31_32_div(
+			dal_fixed31_32_sub(dal_fixed31_32_one, arr_points[1].y),
+			dal_fixed31_32_sub(end_value, arr_points[1].x));
+	}
+
+	regamma_params->hw_points_num = hw_points;
+
+	i = 1;
+	for (k = 0; k < MAX_REGIONS_NUMBER && i < MAX_REGIONS_NUMBER; k++) {
+		if (seg_distr[k] != -1) {
+			regamma_params->arr_curve_points[k].segments_num =
+					seg_distr[k];
+			regamma_params->arr_curve_points[i].offset =
+					regamma_params->arr_curve_points[k].
+					offset + (1 << seg_distr[k]);
+		}
+		i++;
+	}
+
+	if (seg_distr[k] != -1)
+		regamma_params->arr_curve_points[k].segments_num =
+				seg_distr[k];
+
+	rgb = rgb_resulted;
+	rgb_plus_1 = rgb_resulted + 1;
+
+	i = 1;
+
+	while (i != hw_points + 1) {
+		if (dal_fixed31_32_lt(rgb_plus_1->red, rgb->red))
+			rgb_plus_1->red = rgb->red;
+		if (dal_fixed31_32_lt(rgb_plus_1->green, rgb->green))
+			rgb_plus_1->green = rgb->green;
+		if (dal_fixed31_32_lt(rgb_plus_1->blue, rgb->blue))
+			rgb_plus_1->blue = rgb->blue;
+
+		rgb->delta_red = dal_fixed31_32_sub(
+			rgb_plus_1->red,
+			rgb->red);
+		rgb->delta_green = dal_fixed31_32_sub(
+			rgb_plus_1->green,
+			rgb->green);
+		rgb->delta_blue = dal_fixed31_32_sub(
+			rgb_plus_1->blue,
+			rgb->blue);
+
+		++rgb_plus_1;
+		++rgb;
+		++i;
+	}
+
+	convert_to_custom_float(rgb_resulted, arr_points, hw_points);
+
+	return true;
+}
+
+static bool dcn10_set_output_transfer_func(
+	struct pipe_ctx *pipe_ctx,
+	const struct core_surface *surface,
+	const struct core_stream *stream)
+{
+	struct output_pixel_processor *opp = pipe_ctx->opp;
+
+	opp->regamma_params.hw_points_num = GAMMA_HW_POINTS_NUM;
+
+	if (stream->public.out_transfer_func &&
+		stream->public.out_transfer_func->type ==
+			TF_TYPE_PREDEFINED &&
+		stream->public.out_transfer_func->tf ==
+			TRANSFER_FUNCTION_SRGB) {
+		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_SRGB);
+	} else if (dcn10_translate_regamma_to_hw_format(
+				stream->public.out_transfer_func, &opp->regamma_params)) {
+			opp->funcs->opp_program_regamma_pwl(opp, &opp->regamma_params);
+			opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_USER);
+	} else {
+		opp->funcs->opp_set_regamma_mode(opp, OPP_REGAMMA_BYPASS);
+	}
+
+	return true;
+}
+
+static void dcn10_pipe_control_lock(
+	struct core_dc *dc,
+	struct pipe_ctx *pipe,
+	bool lock)
+{
+	struct dce_hwseq *hws = hws = dc->hwseq;
+
+	/* use TG master update lock to lock everything on the TG
+	 * therefore only top pipe need to lock
+	 */
+	if (pipe->top_pipe)
+		return;
+
+	if (lock)
+		dcn10_lock(pipe->tg);
+	else
+		dcn10_unlock(pipe->tg);
+}
+
+static bool wait_for_reset_trigger_to_occur(
+	struct dc_context *dc_ctx,
+	struct timing_generator *tg)
+{
+	bool rc = false;
+
+	/* To avoid endless loop we wait at most
+	 * frames_to_wait_on_triggered_reset frames for the reset to occur. */
+	const uint32_t frames_to_wait_on_triggered_reset = 10;
+	int i;
+
+	for (i = 0; i < frames_to_wait_on_triggered_reset; i++) {
+
+		if (!tg->funcs->is_counter_moving(tg)) {
+			DC_ERROR("TG counter is not moving!\n");
+			break;
+		}
+
+		if (tg->funcs->did_triggered_reset_occur(tg)) {
+			rc = true;
+			/* usually occurs at i=1 */
+			DC_SYNC_INFO("GSL: reset occurred at wait count: %d\n",
+					i);
+			break;
+		}
+
+		/* Wait for one frame. */
+		tg->funcs->wait_for_state(tg, CRTC_STATE_VACTIVE);
+		tg->funcs->wait_for_state(tg, CRTC_STATE_VBLANK);
+	}
+
+	if (false == rc)
+		DC_ERROR("GSL: Timeout on reset trigger!\n");
+
+	return rc;
+}
+
+static void dcn10_enable_timing_synchronization(
+	struct core_dc *dc,
+	int group_index,
+	int group_size,
+	struct pipe_ctx *grouped_pipes[])
+{
+	struct dc_context *dc_ctx = dc->ctx;
+	int i;
+
+	DC_SYNC_INFO("Setting up OTG reset trigger\n");
+
+	for (i = 1; i < group_size; i++)
+		grouped_pipes[i]->tg->funcs->enable_reset_trigger(
+				grouped_pipes[i]->tg, grouped_pipes[0]->tg->inst);
+
+
+	DC_SYNC_INFO("Waiting for trigger\n");
+
+	/* Need to get only check 1 pipe for having reset as all the others are
+	 * synchronized. Look at last pipe programmed to reset.
+	 */
+	wait_for_reset_trigger_to_occur(dc_ctx, grouped_pipes[1]->tg);
+	for (i = 1; i < group_size; i++)
+		grouped_pipes[i]->tg->funcs->disable_reset_trigger(
+				grouped_pipes[i]->tg);
+
+	DC_SYNC_INFO("Sync complete\n");
+}
+
+static void dcn10_power_on_fe(
+	struct core_dc *dc,
+	struct pipe_ctx *pipe_ctx,
+	struct validate_context *context)
+{
+	struct dc_surface *dc_surface = &pipe_ctx->surface->public;
+
+	/* power up DCHUP and DPP from pseudo code pipe_move.c */
+	 /*TODO: function: power_on_plane. If already power up, skip
+	 */
+	{
+		power_on_plane(dc->ctx,
+			pipe_ctx->pipe_idx, pipe_ctx->tg->inst);
+
+		/* enable DCFCLK current DCHUB */
+		enable_dcfclk(dc->ctx,
+				pipe_ctx->pipe_idx,
+				pipe_ctx->pix_clk_params.requested_pix_clk,
+				context->dppclk_div);
+
+		if (dc_surface) {
+			dm_logger_write(dc->ctx->logger, LOG_DC,
+					"Pipe:%d 0x%x: addr hi:0x%x, "
+					"addr low:0x%x, "
+					"src: %d, %d, %d,"
+					" %d; dst: %d, %d, %d, %d;\n",
+					pipe_ctx->pipe_idx,
+					dc_surface,
+					dc_surface->address.grph.addr.high_part,
+					dc_surface->address.grph.addr.low_part,
+					dc_surface->src_rect.x,
+					dc_surface->src_rect.y,
+					dc_surface->src_rect.width,
+					dc_surface->src_rect.height,
+					dc_surface->dst_rect.x,
+					dc_surface->dst_rect.y,
+					dc_surface->dst_rect.width,
+					dc_surface->dst_rect.height);
+
+			dm_logger_write(dc->ctx->logger, LOG_HW_SET_MODE,
+					"Pipe %d: width, height, x, y\n"
+					"viewport:%d, %d, %d, %d\n"
+					"recout:  %d, %d, %d, %d\n",
+					pipe_ctx->pipe_idx,
+					pipe_ctx->scl_data.viewport.width,
+					pipe_ctx->scl_data.viewport.height,
+					pipe_ctx->scl_data.viewport.x,
+					pipe_ctx->scl_data.viewport.y,
+					pipe_ctx->scl_data.recout.width,
+					pipe_ctx->scl_data.recout.height,
+					pipe_ctx->scl_data.recout.x,
+					pipe_ctx->scl_data.recout.y);
+		}
+	}
+
+}
+
+static void program_gamut_remap(struct pipe_ctx *pipe_ctx)
+{
+	struct xfm_grph_csc_adjustment adjust;
+	memset(&adjust, 0, sizeof(adjust));
+	adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_BYPASS;
+
+
+	if (pipe_ctx->stream->public.gamut_remap_matrix.enable_remap == true) {
+		adjust.gamut_adjust_type = GRAPHICS_GAMUT_ADJUST_TYPE_SW;
+		adjust.temperature_matrix[0] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[0];
+		adjust.temperature_matrix[1] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[1];
+		adjust.temperature_matrix[2] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[2];
+		adjust.temperature_matrix[3] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[4];
+		adjust.temperature_matrix[4] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[5];
+		adjust.temperature_matrix[5] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[6];
+		adjust.temperature_matrix[6] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[8];
+		adjust.temperature_matrix[7] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[9];
+		adjust.temperature_matrix[8] =
+				pipe_ctx->stream->
+				public.gamut_remap_matrix.matrix[10];
+	}
+
+	pipe_ctx->xfm->funcs->transform_set_gamut_remap(pipe_ctx->xfm, &adjust);
+}
+
+static void update_dchubp_dpp(
+	struct core_dc *dc,
+	struct pipe_ctx *pipe_ctx,
+	struct validate_context *context)
+{
+	struct mem_input *mi = pipe_ctx->mi;
+	struct input_pixel_processor *ipp = pipe_ctx->ipp;
+	struct core_surface *surface = pipe_ctx->surface;
+	union plane_size size = surface->public.plane_size;
+	struct mpc_tree_cfg *tree_cfg = NULL;
+	struct default_adjustment ocsc = {0};
+	enum dc_color_space color_space;
+	struct tg_color black_color = {0};
+	struct dcn10_mpc *mpc = TO_DCN10_MPC(dc->res_pool->mpc);
+
+	/* depends on DML calculation, DPP clock value may change dynamically */
+	enable_dppclk(
+		dc->ctx,
+		pipe_ctx->pipe_idx,
+		pipe_ctx->pix_clk_params.requested_pix_clk,
+		context->dppclk_div);
+
+	select_vtg(dc->ctx, pipe_ctx->pipe_idx, pipe_ctx->tg->inst);
+
+	update_plane_addr(dc, pipe_ctx);
+
+	mi->funcs->mem_input_setup(
+		mi,
+		&pipe_ctx->dlg_regs,
+		&pipe_ctx->ttu_regs,
+		&pipe_ctx->rq_regs,
+		&pipe_ctx->pipe_dlg_param);
+
+	size.grph.surface_size = pipe_ctx->scl_data.viewport;
+
+	if (dc->public.config.gpu_vm_support)
+		mi->funcs->mem_input_program_pte_vm(
+				pipe_ctx->mi,
+				surface->public.format,
+				&surface->public.tiling_info,
+				surface->public.rotation);
+
+	ipp->funcs->ipp_setup(ipp,
+			surface->public.format,
+			1,
+			IPP_OUTPUT_FORMAT_12_BIT_FIX);
+
+	/* mpc TODO un-hardcode object ids
+	 * for pseudo code pipe_move.c :
+	 * add_plane_mpcc(added_plane_inst, mpcc_inst, ...);
+	 * Do we want to cache the tree_cfg?
+	 */
+
+	/* TODO: build stream pipes group id. For now, use stream otg
+	 * id as pipe group id
+	 */
+	pipe_ctx->mpc_idx = pipe_ctx->tg->inst;
+	tree_cfg = &context->res_ctx.mpc_tree[pipe_ctx->mpc_idx];
+	/* enable when bottom pipe is present and
+	 * it does not share a surface with current pipe
+	 */
+	if (pipe_ctx->bottom_pipe && surface != pipe_ctx->bottom_pipe->surface) {
+		pipe_ctx->scl_data.lb_params.alpha_en = 1;
+		tree_cfg->mode = TOP_BLND;
+	} else {
+		pipe_ctx->scl_data.lb_params.alpha_en = 0;
+		tree_cfg->mode = TOP_PASSTHRU;
+	}
+	if (!pipe_ctx->top_pipe) {
+		/* primary pipe, set mpc tree index 0 only */
+		tree_cfg->num_pipes = 1;
+		tree_cfg->opp_id = pipe_ctx->tg->inst;
+		tree_cfg->dpp[0] = pipe_ctx->pipe_idx;
+		tree_cfg->mpcc[0] = pipe_ctx->pipe_idx;
+		dcn10_set_mpc_tree(mpc, tree_cfg);
+	} else {
+		/* TODO: add position is hard code to 1 for now
+		 * If more than 2 pipes are supported, calculate position
+		 */
+		dcn10_add_dpp(mpc, tree_cfg,
+			pipe_ctx->pipe_idx, pipe_ctx->pipe_idx, 1);
+	}
+
+	color_space = pipe_ctx->stream->public.output_color_space;
+	color_space_to_black_color(dc, color_space, &black_color);
+	dcn10_set_mpc_background_color(mpc, pipe_ctx->pipe_idx, &black_color);
+
+	pipe_ctx->scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
+	/* scaler configuration */
+	pipe_ctx->xfm->funcs->transform_set_scaler(
+			pipe_ctx->xfm, &pipe_ctx->scl_data);
+
+	/*gamut remap*/
+	program_gamut_remap(pipe_ctx);
+
+	/*TODO add adjustments parameters*/
+	ocsc.out_color_space = pipe_ctx->stream->public.output_color_space;
+	pipe_ctx->opp->funcs->opp_set_csc_default(pipe_ctx->opp, &ocsc);
+
+	mi->funcs->mem_input_program_surface_config(
+		mi,
+		surface->public.format,
+		&surface->public.tiling_info,
+		&size,
+		surface->public.rotation,
+		&surface->public.dcc,
+		surface->public.horizontal_mirror,
+		surface->public.visible);
+
+	/* Only support one plane for now. */
+	pipe_ctx->tg->funcs->set_blank(pipe_ctx->tg, !surface->public.visible);
+
+}
+
+static void program_all_pipe_in_tree(
+		struct core_dc *dc,
+		struct pipe_ctx *pipe_ctx,
+		struct validate_context *context)
+{
+	unsigned int ref_clk_mhz = dc->res_pool->ref_clock_inKhz/1000;
+
+	if (pipe_ctx->surface->public.visible || pipe_ctx->top_pipe == NULL) {
+		dcn10_power_on_fe(dc, pipe_ctx, context);
+
+		/* lock otg_master_update to process all pipes associated with
+		 * this OTG. this is done only one time.
+		 */
+		if (pipe_ctx->top_pipe == NULL) {
+			/* watermark is for all pipes */
+			pipe_ctx->mi->funcs->program_watermarks(
+					pipe_ctx->mi, &context->watermarks, ref_clk_mhz);
+			lock_otg_master_update(dc->ctx, pipe_ctx->tg->inst);
+		}
+		pipe_ctx->tg->dlg_otg_param.vready_offset = pipe_ctx->pipe_dlg_param.vready_offset;
+		pipe_ctx->tg->dlg_otg_param.vstartup_start = pipe_ctx->pipe_dlg_param.vstartup_start;
+		pipe_ctx->tg->dlg_otg_param.vupdate_offset = pipe_ctx->pipe_dlg_param.vupdate_offset;
+		pipe_ctx->tg->dlg_otg_param.vupdate_width = pipe_ctx->pipe_dlg_param.vupdate_width;
+		pipe_ctx->tg->dlg_otg_param.signal =  pipe_ctx->stream->signal;
+		pipe_ctx->tg->funcs->program_global_sync(
+				pipe_ctx->tg);
+		update_dchubp_dpp(dc, pipe_ctx, context);
+	}
+
+	if (pipe_ctx->bottom_pipe != NULL)
+		program_all_pipe_in_tree(dc, pipe_ctx->bottom_pipe, context);
+}
+
+static void dcn10_pplib_apply_display_requirements(
+	struct core_dc *dc,
+	struct validate_context *context)
+{
+	struct dm_pp_display_configuration *pp_display_cfg = &context->pp_display_cfg;
+
+	pp_display_cfg->all_displays_in_sync = false;/*todo*/
+	pp_display_cfg->nb_pstate_switch_disable = false;
+	pp_display_cfg->min_engine_clock_khz = context->dcfclk_khz;
+	pp_display_cfg->min_memory_clock_khz = context->fclk_khz;
+	pp_display_cfg->min_engine_clock_deep_sleep_khz = context->dcfclk_deep_sleep_khz;
+	pp_display_cfg->min_dcfc_deep_sleep_clock_khz = context->dcfclk_deep_sleep_khz;
+	pp_display_cfg->avail_mclk_switch_time_us =
+			context->dram_ccm_us > 0 ? context->dram_ccm_us : 0;
+	pp_display_cfg->avail_mclk_switch_time_in_disp_active_us =
+			context->min_active_dram_ccm_us > 0 ? context->min_active_dram_ccm_us : 0;
+	pp_display_cfg->min_dcfclock_khz = context->dcfclk_khz;
+	pp_display_cfg->disp_clk_khz = context->dispclk_khz;
+	dce110_fill_display_configs(context, pp_display_cfg);
+
+	if (memcmp(&dc->prev_display_config, pp_display_cfg, sizeof(
+			struct dm_pp_display_configuration)) !=  0)
+		dm_pp_apply_display_requirements(dc->ctx, pp_display_cfg);
+
+	dc->prev_display_config = *pp_display_cfg;
+}
+
+static void dcn10_apply_ctx_for_surface(
+		struct core_dc *dc,
+		struct core_surface *surface,
+		struct validate_context *context)
+{
+	int i;
+
+	memcpy(context->res_ctx.mpc_tree,
+			dc->current_context->res_ctx.mpc_tree,
+			sizeof(struct mpc_tree_cfg) * dc->res_pool->pipe_count);
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (!pipe_ctx->surface)
+			continue;
+
+		/* looking for top pipe to program */
+		if (!pipe_ctx->top_pipe)
+			program_all_pipe_in_tree(dc, pipe_ctx, context);
+	}
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (!pipe_ctx->surface || pipe_ctx->top_pipe)
+			continue;
+
+		/* unlock master update lock */
+		unlock_otg_master(dc->ctx, pipe_ctx->tg->inst);
+	}
+
+	/* reset unused pipe */
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *old_pipe_ctx =
+				&dc->current_context->res_ctx.pipe_ctx[i];
+
+		if ((!pipe_ctx->surface && old_pipe_ctx->surface)
+				|| (!pipe_ctx->stream && old_pipe_ctx->stream))
+			reset_front_end_for_pipe(dc,
+					old_pipe_ctx, dc->current_context);
+	}
+}
+
+static void dcn10_set_bandwidth(
+		struct core_dc *dc,
+		struct validate_context *context,
+		bool decrease_allowed)
+{
+	struct dm_pp_clock_for_voltage_req clock;
+
+	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
+		return;
+
+	if (decrease_allowed || context->dispclk_khz > dc->current_context->dispclk_khz) {
+		dc->res_pool->display_clock->funcs->set_clock(
+				dc->res_pool->display_clock,
+				context->dispclk_khz);
+		dc->current_context->dispclk_khz = context->dispclk_khz;
+	}
+	if (decrease_allowed || context->dcfclk_khz > dc->current_context->dcfclk_khz) {
+		clock.clk_type = DM_PP_CLOCK_TYPE_DCFCLK;
+		clock.clocks_in_khz = context->dcfclk_khz;
+		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
+	}
+	if (decrease_allowed || context->fclk_khz > dc->current_context->fclk_khz) {
+		clock.clk_type = DM_PP_CLOCK_TYPE_FCLK;
+		clock.clocks_in_khz = context->fclk_khz;
+		dm_pp_apply_clock_for_voltage_request(dc->ctx, &clock);
+		dc->current_context->fclk_khz = clock.clocks_in_khz ;
+	}
+	dcn10_pplib_apply_display_requirements(dc, context);
+}
+
+static void dcn10_power_down_fe(struct core_dc *dc, struct pipe_ctx *pipe)
+{
+	struct dc_context *ctx = dc->ctx;
+	uint32_t inst_offset = 0;
+
+	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
+			IP_REQUEST_EN, 1);
+	dpp_pg_control(ctx, pipe->pipe_idx, false);
+	hubp_pg_control(ctx, pipe->pipe_idx, false);
+	HWSEQ_REG_SET(DC_IP_REQUEST_CNTL,
+			IP_REQUEST_EN, 0);
+
+	if (pipe->xfm)
+		pipe->xfm->funcs->transform_reset(pipe->xfm);
+	memset(&pipe->scl_data, 0, sizeof(pipe->scl_data));
+}
+
+static void set_drr(struct pipe_ctx **pipe_ctx,
+		int num_pipes, int vmin, int vmax)
+{
+	int i = 0;
+	struct drr_params params = {0};
+
+	params.vertical_total_max = vmax;
+	params.vertical_total_min = vmin;
+
+	/* TODO: If multiple pipes are to be supported, you need
+	 * some GSL stuff
+	 */
+	for (i = 0; i < num_pipes; i++) {
+		pipe_ctx[i]->tg->funcs->set_drr(pipe_ctx[i]->tg, &params);
+	}
+}
+
+static void get_position(struct pipe_ctx **pipe_ctx,
+		int num_pipes,
+		struct crtc_position *position)
+{
+	int i = 0;
+
+	/* TODO: handle pipes > 1
+	 */
+	for (i = 0; i < num_pipes; i++)
+		pipe_ctx[i]->tg->funcs->get_position(pipe_ctx[i]->tg, position);
+}
+
+static void set_static_screen_control(struct pipe_ctx **pipe_ctx,
+		int num_pipes, const struct dc_static_screen_events *events)
+{
+	unsigned int i;
+	unsigned int value = 0;
+
+	if (events->surface_update)
+		value |= 0x80;
+	if (events->cursor_update)
+		value |= 0x2;
+
+	for (i = 0; i < num_pipes; i++)
+		pipe_ctx[i]->tg->funcs->
+			set_static_screen_control(pipe_ctx[i]->tg, value);
+}
+
+static void set_plane_config(
+	const struct core_dc *dc,
+	struct pipe_ctx *pipe_ctx,
+	struct resource_context *res_ctx)
+{
+	/* TODO */
+	program_gamut_remap(pipe_ctx);
+}
+
+static const struct hw_sequencer_funcs dcn10_funcs = {
+	.init_hw = init_hw,
+	.apply_ctx_to_hw = dce110_apply_ctx_to_hw,
+	.apply_ctx_for_surface = dcn10_apply_ctx_for_surface,
+	.set_plane_config = set_plane_config,
+	.update_plane_addr = update_plane_addr,
+	.update_pending_status = dce110_update_pending_status,
+	.set_input_transfer_func = dcn10_set_input_transfer_func,
+	.set_output_transfer_func = dcn10_set_output_transfer_func,
+	.power_down = dce110_power_down,
+	.enable_accelerated_mode = dce110_enable_accelerated_mode,
+	.enable_timing_synchronization = dcn10_enable_timing_synchronization,
+	.update_info_frame = dce110_update_info_frame,
+	.enable_stream = dce110_enable_stream,
+	.disable_stream = dce110_disable_stream,
+	.unblank_stream = dce110_unblank_stream,
+	.enable_display_pipe_clock_gating = NULL, /* TODOFPGA */
+	.enable_display_power_gating = dcn10_enable_display_power_gating,
+	.power_down_front_end = dcn10_power_down_fe,
+	.power_on_front_end = dcn10_power_on_fe,
+	.pipe_control_lock = dcn10_pipe_control_lock,
+	.set_bandwidth = dcn10_set_bandwidth,
+	.reset_hw_ctx_wrap = reset_hw_ctx_wrap,
+	.prog_pixclk_crtc_otg = dcn10_prog_pixclk_crtc_otg,
+	.set_drr = set_drr,
+	.get_position = get_position,
+	.set_static_screen_control = set_static_screen_control
+};
+
+
+bool dcn10_hw_sequencer_construct(struct core_dc *dc)
+{
+	dc->hwss = dcn10_funcs;
+	return true;
+}
+
