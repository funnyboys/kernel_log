commit 5ae9c378c3d88b40af72f8e8f961808e29f3e70b
Author: Stylon Wang <stylon.wang@amd.com>
Date:   Mon Jun 1 16:12:09 2020 +0800

    drm/amd/display: Enable output_bpc property on all outputs
    
    [Why]
    Connector property output_bpc is available on DP/eDP only. New IGT tests
    would benifit if this property works on HDMI.
    
    [How]
    Enable this read-only property on all types of connectors.
    
    Signed-off-by: Stylon Wang <stylon.wang@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 076af267b488..1d692f4f42f3 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -1058,7 +1058,6 @@ static const struct {
 		{"link_settings", &dp_link_settings_debugfs_fops},
 		{"phy_settings", &dp_phy_settings_debugfs_fop},
 		{"test_pattern", &dp_phy_test_pattern_fops},
-		{"output_bpc", &output_bpc_fops},
 		{"vrr_range", &vrr_range_fops},
 #ifdef CONFIG_DRM_AMD_DC_HDCP
 		{"hdcp_sink_capability", &hdcp_sink_capability_fops},
@@ -1142,6 +1141,9 @@ void connector_debugfs_init(struct amdgpu_dm_connector *connector)
 	debugfs_create_file_unsafe("force_yuv420_output", 0644, dir, connector,
 				   &force_yuv420_output_fops);
 
+	debugfs_create_file("output_bpc", 0644, dir, connector,
+			    &output_bpc_fops);
+
 	connector->debugfs_dpcd_address = 0;
 	connector->debugfs_dpcd_size = 0;
 

commit cdca3f218d9bbe086b0df9bc95b4f0c0d1011415
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Apr 21 22:01:58 2020 -0400

    drm/amd/display: move location of dmub_srv.h file
    
    [Why]
    Make a separation of what belongs in the differen dmub
    headers
    
    dmub_srv.h is for exposing dmub srv interface to rest of
    driver.
    
    other headers inside dmub/inc exposes cmds and definitions
    that are owned by the firmware
    
    [How]
    keep firmware owned definitions in dmub/inc
    
    move stuff that is purely driver interface headers to dmub/
    since those are interface calls that are defined for rest of
    driver to use
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index b3b7efd973ca..076af267b488 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -32,7 +32,7 @@
 #include "amdgpu_dm.h"
 #include "amdgpu_dm_debugfs.h"
 #include "dm_helpers.h"
-#include "dmub/inc/dmub_srv.h"
+#include "dmub/dmub_srv.h"
 
 struct dmub_debugfs_trace_header {
 	uint32_t entry_count;

commit fefe92fe747ca74c6f127833188d4ff02d6f4e11
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Fri Mar 27 18:23:16 2020 -0400

    drm/amd/display: make all backlight calls link based
    
    [Why]
    Backlight adjustment is tied to a specific display.  So make the calls
    target a link rather than making it a global state.
    
    [How]
    make all backlight calls link based
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 4b695f6a80c6..b3b7efd973ca 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -1228,8 +1228,9 @@ static int current_backlight_read(struct seq_file *m, void *data)
 	struct drm_info_node *node = (struct drm_info_node *)m->private;
 	struct drm_device *dev = node->minor->dev;
 	struct amdgpu_device *adev = dev->dev_private;
-	struct dc *dc = adev->dm.dc;
-	unsigned int backlight = dc_get_current_backlight_pwm(dc);
+	struct amdgpu_display_manager *dm = &adev->dm;
+
+	unsigned int backlight = dc_link_get_backlight_level(dm->backlight_link);
 
 	seq_printf(m, "0x%x\n", backlight);
 	return 0;
@@ -1245,8 +1246,9 @@ static int target_backlight_read(struct seq_file *m, void *data)
 	struct drm_info_node *node = (struct drm_info_node *)m->private;
 	struct drm_device *dev = node->minor->dev;
 	struct amdgpu_device *adev = dev->dev_private;
-	struct dc *dc = adev->dm.dc;
-	unsigned int backlight = dc_get_target_backlight_pwm(dc);
+	struct amdgpu_display_manager *dm = &adev->dm;
+
+	unsigned int backlight = dc_link_get_target_backlight_pwm(dm->backlight_link);
 
 	seq_printf(m, "0x%x\n", backlight);
 	return 0;

commit 5f8693796c06ded7d88bf1d9009cdc406e31f3b1
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Mon Feb 24 14:55:53 2020 -0500

    drm/amd/display: add HDCP caps debugfs
    
    Add debugfs to get HDCP capability. This is also useful for
    kms_content_protection igt test.
    
    Use:
            cat /sys/kernel/debug/dri/0/DP-1/hdcp_sink_capability
            cat /sys/kernel/debug/dri/0/HDMI-A-1/hdcp_sink_capability
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 0461fecd68db..4b695f6a80c6 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -838,6 +838,44 @@ static int vrr_range_show(struct seq_file *m, void *data)
 	return 0;
 }
 
+#ifdef CONFIG_DRM_AMD_DC_HDCP
+/*
+ * Returns the HDCP capability of the Display (1.4 for now).
+ *
+ * NOTE* Not all HDMI displays report their HDCP caps even when they are capable.
+ * Since its rare for a display to not be HDCP 1.4 capable, we set HDMI as always capable.
+ *
+ * Example usage: cat /sys/kernel/debug/dri/0/DP-1/hdcp_sink_capability
+ *		or cat /sys/kernel/debug/dri/0/HDMI-A-1/hdcp_sink_capability
+ */
+static int hdcp_sink_capability_show(struct seq_file *m, void *data)
+{
+	struct drm_connector *connector = m->private;
+	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
+	bool hdcp_cap, hdcp2_cap;
+
+	if (connector->status != connector_status_connected)
+		return -ENODEV;
+
+	seq_printf(m, "%s:%d HDCP version: ", connector->name, connector->base.id);
+
+	hdcp_cap = dc_link_is_hdcp14(aconnector->dc_link);
+	hdcp2_cap = dc_link_is_hdcp22(aconnector->dc_link);
+
+
+	if (hdcp_cap)
+		seq_printf(m, "%s ", "HDCP1.4");
+	if (hdcp2_cap)
+		seq_printf(m, "%s ", "HDCP2.2");
+
+	if (!hdcp_cap && !hdcp2_cap)
+		seq_printf(m, "%s ", "None");
+
+	seq_puts(m, "\n");
+
+	return 0;
+}
+#endif
 /* function description
  *
  * generic SDP message access for testing
@@ -964,6 +1002,9 @@ DEFINE_SHOW_ATTRIBUTE(dmub_fw_state);
 DEFINE_SHOW_ATTRIBUTE(dmub_tracebuffer);
 DEFINE_SHOW_ATTRIBUTE(output_bpc);
 DEFINE_SHOW_ATTRIBUTE(vrr_range);
+#ifdef CONFIG_DRM_AMD_DC_HDCP
+DEFINE_SHOW_ATTRIBUTE(hdcp_sink_capability);
+#endif
 
 static const struct file_operations dp_link_settings_debugfs_fops = {
 	.owner = THIS_MODULE,
@@ -1019,12 +1060,23 @@ static const struct {
 		{"test_pattern", &dp_phy_test_pattern_fops},
 		{"output_bpc", &output_bpc_fops},
 		{"vrr_range", &vrr_range_fops},
+#ifdef CONFIG_DRM_AMD_DC_HDCP
+		{"hdcp_sink_capability", &hdcp_sink_capability_fops},
+#endif
 		{"sdp_message", &sdp_message_fops},
 		{"aux_dpcd_address", &dp_dpcd_address_debugfs_fops},
 		{"aux_dpcd_size", &dp_dpcd_size_debugfs_fops},
 		{"aux_dpcd_data", &dp_dpcd_data_debugfs_fops}
 };
 
+#ifdef CONFIG_DRM_AMD_DC_HDCP
+static const struct {
+	char *name;
+	const struct file_operations *fops;
+} hdmi_debugfs_entries[] = {
+		{"hdcp_sink_capability", &hdcp_sink_capability_fops}
+};
+#endif
 /*
  * Force YUV420 output if available from the given mode
  */
@@ -1093,6 +1145,15 @@ void connector_debugfs_init(struct amdgpu_dm_connector *connector)
 	connector->debugfs_dpcd_address = 0;
 	connector->debugfs_dpcd_size = 0;
 
+#ifdef CONFIG_DRM_AMD_DC_HDCP
+	if (connector->base.connector_type == DRM_MODE_CONNECTOR_HDMIA) {
+		for (i = 0; i < ARRAY_SIZE(hdmi_debugfs_entries); i++) {
+			debugfs_create_file(hdmi_debugfs_entries[i].name,
+					    0644, dir, connector,
+					    hdmi_debugfs_entries[i].fops);
+		}
+	}
+#endif
 }
 
 /*

commit 7b99330c8f084abf4957a7abb7b2061be035b2a2
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Feb 4 17:07:39 2020 -0500

    drm/amd/display: move dpcd debugfs members setup
    
    Into the function that creates the debugfs files rather
    than setting them explicitly in the callers.
    
    Tested-by: Thomas Zimmermann <tzimmermann@suse.de>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Christian KÃ¶nig <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 8ec3b4335c69..0461fecd68db 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -1090,6 +1090,9 @@ void connector_debugfs_init(struct amdgpu_dm_connector *connector)
 	debugfs_create_file_unsafe("force_yuv420_output", 0644, dir, connector,
 				   &force_yuv420_output_fops);
 
+	connector->debugfs_dpcd_address = 0;
+	connector->debugfs_dpcd_size = 0;
+
 }
 
 /*

commit 2364076772b11c1ab07fdb62cae4222999c9217f
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue Feb 11 09:48:18 2020 -0500

    drm/amd/display: Add DMUB firmware state debugfs
    
    [Why]
    Firmware state helps to debug sequence issues and hangs for DMCUB
    commands and we don't have an easy mechanism to dump it from the driver.
    
    [How]
    Add a debugfs entry to dump the current firmware state.
    Example usage:
    
    cat /sys/kernel/debug/dri/0/amdgpu_dm_dmub_fw_state
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index ead5c05eec92..8ec3b4335c69 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -732,6 +732,29 @@ static int dmub_tracebuffer_show(struct seq_file *m, void *data)
 	return 0;
 }
 
+/**
+ * Returns the DMCUB firmware state contents.
+ * Example usage: cat /sys/kernel/debug/dri/0/amdgpu_dm_dmub_fw_state
+ */
+static int dmub_fw_state_show(struct seq_file *m, void *data)
+{
+	struct amdgpu_device *adev = m->private;
+	struct dmub_srv_fb_info *fb_info = adev->dm.dmub_fb_info;
+	uint8_t *state_base;
+	uint32_t state_size;
+
+	if (!fb_info)
+		return 0;
+
+	state_base = (uint8_t *)fb_info->fb[DMUB_WINDOW_6_FW_STATE].cpu_addr;
+	if (!state_base)
+		return 0;
+
+	state_size = fb_info->fb[DMUB_WINDOW_6_FW_STATE].size;
+
+	return seq_write(m, state_base, state_size);
+}
+
 /*
  * Returns the current and maximum output bpc for the connector.
  * Example usage: cat /sys/kernel/debug/dri/0/DP-1/output_bpc
@@ -937,6 +960,7 @@ static ssize_t dp_dpcd_data_read(struct file *f, char __user *buf,
 	return read_size - r;
 }
 
+DEFINE_SHOW_ATTRIBUTE(dmub_fw_state);
 DEFINE_SHOW_ATTRIBUTE(dmub_tracebuffer);
 DEFINE_SHOW_ATTRIBUTE(output_bpc);
 DEFINE_SHOW_ATTRIBUTE(vrr_range);
@@ -1249,5 +1273,8 @@ int dtn_debugfs_init(struct amdgpu_device *adev)
 	debugfs_create_file_unsafe("amdgpu_dm_dmub_tracebuffer", 0644, root,
 				   adev, &dmub_tracebuffer_fops);
 
+	debugfs_create_file_unsafe("amdgpu_dm_dmub_fw_state", 0644, root,
+				   adev, &dmub_fw_state_fops);
+
 	return 0;
 }

commit 60ec1b5633afaf624290c1d62145285f005634bd
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Wed Jan 15 14:39:52 2020 -0500

    drm/amd/display: Add DMUB tracebuffer debugfs
    
    [Why]
    The DMUB tracebuffer is useful for understanding DMCUB execution state.
    
    [How]
    Add a "show" attribute debugfs so we can loop through the buffer
    and print the entries.
    
    The structs for the entry format are defined in the debugfs since
    the tracebuffer header no longer exists in the DMUB service.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index f81d3439ee8c..ead5c05eec92 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -32,6 +32,19 @@
 #include "amdgpu_dm.h"
 #include "amdgpu_dm_debugfs.h"
 #include "dm_helpers.h"
+#include "dmub/inc/dmub_srv.h"
+
+struct dmub_debugfs_trace_header {
+	uint32_t entry_count;
+	uint32_t reserved[3];
+};
+
+struct dmub_debugfs_trace_entry {
+	uint32_t trace_code;
+	uint32_t tick_count;
+	uint32_t param0;
+	uint32_t param1;
+};
 
 /* function description
  * get/ set DP configuration: lane_count, link_rate, spread_spectrum
@@ -675,6 +688,50 @@ static ssize_t dp_phy_test_pattern_debugfs_write(struct file *f, const char __us
 	return bytes_from_user;
 }
 
+/**
+ * Returns the DMCUB tracebuffer contents.
+ * Example usage: cat /sys/kernel/debug/dri/0/amdgpu_dm_dmub_tracebuffer
+ */
+static int dmub_tracebuffer_show(struct seq_file *m, void *data)
+{
+	struct amdgpu_device *adev = m->private;
+	struct dmub_srv_fb_info *fb_info = adev->dm.dmub_fb_info;
+	struct dmub_debugfs_trace_entry *entries;
+	uint8_t *tbuf_base;
+	uint32_t tbuf_size, max_entries, num_entries, i;
+
+	if (!fb_info)
+		return 0;
+
+	tbuf_base = (uint8_t *)fb_info->fb[DMUB_WINDOW_5_TRACEBUFF].cpu_addr;
+	if (!tbuf_base)
+		return 0;
+
+	tbuf_size = fb_info->fb[DMUB_WINDOW_5_TRACEBUFF].size;
+	max_entries = (tbuf_size - sizeof(struct dmub_debugfs_trace_header)) /
+		      sizeof(struct dmub_debugfs_trace_entry);
+
+	num_entries =
+		((struct dmub_debugfs_trace_header *)tbuf_base)->entry_count;
+
+	num_entries = min(num_entries, max_entries);
+
+	entries = (struct dmub_debugfs_trace_entry
+			   *)(tbuf_base +
+			      sizeof(struct dmub_debugfs_trace_header));
+
+	for (i = 0; i < num_entries; ++i) {
+		struct dmub_debugfs_trace_entry *entry = &entries[i];
+
+		seq_printf(m,
+			   "trace_code=%u tick_count=%u param0=%u param1=%u\n",
+			   entry->trace_code, entry->tick_count, entry->param0,
+			   entry->param1);
+	}
+
+	return 0;
+}
+
 /*
  * Returns the current and maximum output bpc for the connector.
  * Example usage: cat /sys/kernel/debug/dri/0/DP-1/output_bpc
@@ -880,6 +937,7 @@ static ssize_t dp_dpcd_data_read(struct file *f, char __user *buf,
 	return read_size - r;
 }
 
+DEFINE_SHOW_ATTRIBUTE(dmub_tracebuffer);
 DEFINE_SHOW_ATTRIBUTE(output_bpc);
 DEFINE_SHOW_ATTRIBUTE(vrr_range);
 
@@ -1188,5 +1246,8 @@ int dtn_debugfs_init(struct amdgpu_device *adev)
 	debugfs_create_file_unsafe("amdgpu_dm_visual_confirm", 0644, root, adev,
 				   &visual_confirm_fops);
 
+	debugfs_create_file_unsafe("amdgpu_dm_dmub_tracebuffer", 0644, root,
+				   adev, &dmub_tracebuffer_fops);
+
 	return 0;
 }

commit 2057b7e1cf77bdf090a3571a8d2ca00a76f34a9e
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Tue Oct 15 15:12:57 2019 -0400

    drm/amd/display: add color space option when sending link test pattern
    
    [why]
    In the TEST_MSIC dpcd register field definition, the test equipment
    has the option to choose between YCbCr601 or YCbCr709.
    We will apply corresponding YCbCr coefficient based on this test
    request.
    
    [how]
    Add a new input parameter in dc_link_dp_set_test_pattern to allow the
    selection between different color space.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index bdb37e611015..f81d3439ee8c 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -657,6 +657,7 @@ static ssize_t dp_phy_test_pattern_debugfs_write(struct file *f, const char __us
 	dc_link_set_test_pattern(
 		link,
 		test_pattern,
+		DP_TEST_PATTERN_COLOR_SPACE_RGB,
 		&link_training_settings,
 		custom_pattern,
 		10);

commit e0d08a40a63bd43f373937084f4c3bfab68f6afc
Author: Roman Li <Roman.Li@amd.com>
Date:   Fri Aug 30 10:44:48 2019 -0400

    drm/amd/display: Add debugfs entry for reading psr state
    
    [Why]
    For upcoming PSR stupport it's useful to have debug entry
    to verify psr state.
    
    [How]
     - Enable psr dc api for Linux
     - Add psr_state file to eDP connector debugfs
    usage e.g.: cat /sys/kernel/debug/dri/0/DP-1/psr_state
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index e29c6314f98c..bdb37e611015 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -969,6 +969,25 @@ static int force_yuv420_output_get(void *data, u64 *val)
 DEFINE_DEBUGFS_ATTRIBUTE(force_yuv420_output_fops, force_yuv420_output_get,
 			 force_yuv420_output_set, "%llu\n");
 
+/*
+ *  Read PSR state
+ */
+static int psr_get(void *data, u64 *val)
+{
+	struct amdgpu_dm_connector *connector = data;
+	struct dc_link *link = connector->dc_link;
+	uint32_t psr_state = 0;
+
+	dc_link_get_psr_state(link, &psr_state);
+
+	*val = psr_state;
+
+	return 0;
+}
+
+
+DEFINE_DEBUGFS_ATTRIBUTE(psr_fops, psr_get, NULL, "%llu\n");
+
 void connector_debugfs_init(struct amdgpu_dm_connector *connector)
 {
 	int i;
@@ -982,6 +1001,8 @@ void connector_debugfs_init(struct amdgpu_dm_connector *connector)
 					    dp_debugfs_entries[i].fops);
 		}
 	}
+	if (connector->base.connector_type == DRM_MODE_CONNECTOR_eDP)
+		debugfs_create_file_unsafe("psr_state", 0444, dir, connector, &psr_fops);
 
 	debugfs_create_file_unsafe("force_yuv420_output", 0644, dir, connector,
 				   &force_yuv420_output_fops);

commit d4252eee1f7cde7f8b1673626d1b49498c1d4f77
Author: Stylon Wang <stylon.wang@amd.com>
Date:   Tue Aug 20 14:48:37 2019 -0400

    drm/amd/display: Add debugfs entry to force YUV420 output
    
    [Why]
    Even if YUV420 is available for video mode, YUV444 is still
    automatically selected. This poses a problem for compliance tests.
    
    [How]
    Add a per-connector debugfs entry "force_yuv420_output" to force
    selection of YUV420 mode.
    
    Signed-off-by: Stylon Wang <stylon.wang@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index f3dfb2887ae0..e29c6314f98c 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -942,6 +942,33 @@ static const struct {
 		{"aux_dpcd_data", &dp_dpcd_data_debugfs_fops}
 };
 
+/*
+ * Force YUV420 output if available from the given mode
+ */
+static int force_yuv420_output_set(void *data, u64 val)
+{
+	struct amdgpu_dm_connector *connector = data;
+
+	connector->force_yuv420_output = (bool)val;
+
+	return 0;
+}
+
+/*
+ * Check if YUV420 is forced when available from the given mode
+ */
+static int force_yuv420_output_get(void *data, u64 *val)
+{
+	struct amdgpu_dm_connector *connector = data;
+
+	*val = connector->force_yuv420_output;
+
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(force_yuv420_output_fops, force_yuv420_output_get,
+			 force_yuv420_output_set, "%llu\n");
+
 void connector_debugfs_init(struct amdgpu_dm_connector *connector)
 {
 	int i;
@@ -955,6 +982,10 @@ void connector_debugfs_init(struct amdgpu_dm_connector *connector)
 					    dp_debugfs_entries[i].fops);
 		}
 	}
+
+	debugfs_create_file_unsafe("force_yuv420_output", 0644, dir, connector,
+				   &force_yuv420_output_fops);
+
 }
 
 /*

commit 0ec7d06b225663d62e8867951114375a512e56c4
Author: David Francis <David.Francis@amd.com>
Date:   Thu Jul 25 15:22:16 2019 -0400

    drm/amd/display: MST topology debugfs
    
    DRM provides drm_dp_mst_dump_topology, which prints
    useful information about MST devices
    
    Hook this up to a debugfs file named amdgpu_mst_topology
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 36a1d794b4af..f3dfb2887ae0 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -1053,9 +1053,33 @@ static int target_backlight_read(struct seq_file *m, void *data)
 	return 0;
 }
 
+static int mst_topo(struct seq_file *m, void *unused)
+{
+	struct drm_info_node *node = (struct drm_info_node *)m->private;
+	struct drm_device *dev = node->minor->dev;
+	struct drm_connector *connector;
+	struct drm_connector_list_iter conn_iter;
+	struct amdgpu_dm_connector *aconnector;
+
+	drm_connector_list_iter_begin(dev, &conn_iter);
+	drm_for_each_connector_iter(connector, &conn_iter) {
+		if (connector->connector_type != DRM_MODE_CONNECTOR_DisplayPort)
+			continue;
+
+		aconnector = to_amdgpu_dm_connector(connector);
+
+		seq_printf(m, "\nMST topology for connector %d\n", aconnector->connector_id);
+		drm_dp_mst_dump_topology(m, &aconnector->mst_mgr);
+	}
+	drm_connector_list_iter_end(&conn_iter);
+
+	return 0;
+}
+
 static const struct drm_info_list amdgpu_dm_debugfs_list[] = {
 	{"amdgpu_current_backlight_pwm", &current_backlight_read},
 	{"amdgpu_target_backlight_pwm", &target_backlight_read},
+	{"amdgpu_mst_topology", &mst_topo},
 };
 
 /*

commit d7929c1e13e3788e7cb741d75b5baec5e53eff21
Merge: 8ac875db0fdc 80d42db02b3a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jun 25 08:42:25 2019 -0500

    Merge branch 'drm-next' into drm-next-5.3
    
    Backmerge drm-next and fix up conflicts due to drmP.h removal.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit 4be8be78b7d848544b7c4b0191791c7e5c2e2236
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jun 13 15:20:12 2019 +0200

    amdgpu_dm: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    Cc: Harry Wentland <harry.wentland@amd.com>
    Cc: Leo Li <sunpeng.li@amd.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian KÃ¶nig" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Cc: David Francis <David.Francis@amd.com>
    Cc: Mario Kleiner <mario.kleiner.de@gmail.com>
    Cc: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Cc: Anthony Koo <Anthony.Koo@amd.com>
    Cc: hersen wu <hersenxs.wu@amd.com>
    Cc: "Leo (Hanghong) Ma" <hanghong.ma@amd.com>
    Cc: amd-gfx@lists.freedesktop.org
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index a3e362fa6747..406129e67e79 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -940,25 +940,19 @@ static const struct {
 		{"aux_dpcd_data", &dp_dpcd_data_debugfs_fops}
 };
 
-int connector_debugfs_init(struct amdgpu_dm_connector *connector)
+void connector_debugfs_init(struct amdgpu_dm_connector *connector)
 {
 	int i;
-	struct dentry *ent, *dir = connector->base.debugfs_entry;
+	struct dentry *dir = connector->base.debugfs_entry;
 
 	if (connector->base.connector_type == DRM_MODE_CONNECTOR_DisplayPort ||
 	    connector->base.connector_type == DRM_MODE_CONNECTOR_eDP) {
 		for (i = 0; i < ARRAY_SIZE(dp_debugfs_entries); i++) {
-			ent = debugfs_create_file(dp_debugfs_entries[i].name,
-						  0644,
-						  dir,
-						  connector,
-						  dp_debugfs_entries[i].fops);
-			if (IS_ERR(ent))
-				return PTR_ERR(ent);
+			debugfs_create_file(dp_debugfs_entries[i].name,
+					    0644, dir, connector,
+					    dp_debugfs_entries[i].fops);
 		}
 	}
-
-	return 0;
 }
 
 /*
@@ -1101,7 +1095,7 @@ int dtn_debugfs_init(struct amdgpu_device *adev)
 	};
 
 	struct drm_minor *minor = adev->ddev->primary;
-	struct dentry *ent, *root = minor->debugfs_root;
+	struct dentry *root = minor->debugfs_root;
 	int ret;
 
 	ret = amdgpu_debugfs_add_files(adev, amdgpu_dm_debugfs_list,
@@ -1109,20 +1103,11 @@ int dtn_debugfs_init(struct amdgpu_device *adev)
 	if (ret)
 		return ret;
 
-	ent = debugfs_create_file(
-		"amdgpu_dm_dtn_log",
-		0644,
-		root,
-		adev,
-		&dtn_log_fops);
-
-	if (IS_ERR(ent))
-		return PTR_ERR(ent);
+	debugfs_create_file("amdgpu_dm_dtn_log", 0644, root, adev,
+			    &dtn_log_fops);
 
-	ent = debugfs_create_file_unsafe("amdgpu_dm_visual_confirm", 0644, root,
-					 adev, &visual_confirm_fops);
-	if (IS_ERR(ent))
-		return PTR_ERR(ent);
+	debugfs_create_file_unsafe("amdgpu_dm_visual_confirm", 0644, root, adev,
+				   &visual_confirm_fops);
 
 	return 0;
 }

commit 4b7ef85cc65e7ae137c43a0269365289f1b5ee68
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Mon Jun 3 13:44:37 2019 -0400

    drm/amd/display: Add connector debugfs for "output_bpc"
    
    [Why]
    This will be useful for verifying whether we enter the correct output
    color depth from IGT.
    
    [How]
    Locks the connector and associated CRTC if available and outputs
    the current and maximum output bpc values.
    
    Example:
    
    cat /sys/kernel/debug/dri/0/DP-1/output_bpc
    Current: 8
    Maximum: 10
    
    v2: Drop unneeded connector status check
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: David Francis <David.Francis@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 1d5fc5ad3bee..a3e362fa6747 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -672,6 +672,71 @@ static ssize_t dp_phy_test_pattern_debugfs_write(struct file *f, const char __us
 	return bytes_from_user;
 }
 
+/*
+ * Returns the current and maximum output bpc for the connector.
+ * Example usage: cat /sys/kernel/debug/dri/0/DP-1/output_bpc
+ */
+static int output_bpc_show(struct seq_file *m, void *data)
+{
+	struct drm_connector *connector = m->private;
+	struct drm_device *dev = connector->dev;
+	struct drm_crtc *crtc = NULL;
+	struct dm_crtc_state *dm_crtc_state = NULL;
+	int res = -ENODEV;
+	unsigned int bpc;
+
+	mutex_lock(&dev->mode_config.mutex);
+	drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
+
+	if (connector->state == NULL)
+		goto unlock;
+
+	crtc = connector->state->crtc;
+	if (crtc == NULL)
+		goto unlock;
+
+	drm_modeset_lock(&crtc->mutex, NULL);
+	if (crtc->state == NULL)
+		goto unlock;
+
+	dm_crtc_state = to_dm_crtc_state(crtc->state);
+	if (dm_crtc_state->stream == NULL)
+		goto unlock;
+
+	switch (dm_crtc_state->stream->timing.display_color_depth) {
+	case COLOR_DEPTH_666:
+		bpc = 6;
+		break;
+	case COLOR_DEPTH_888:
+		bpc = 8;
+		break;
+	case COLOR_DEPTH_101010:
+		bpc = 10;
+		break;
+	case COLOR_DEPTH_121212:
+		bpc = 12;
+		break;
+	case COLOR_DEPTH_161616:
+		bpc = 16;
+		break;
+	default:
+		goto unlock;
+	}
+
+	seq_printf(m, "Current: %u\n", bpc);
+	seq_printf(m, "Maximum: %u\n", connector->display_info.bpc);
+	res = 0;
+
+unlock:
+	if (crtc)
+		drm_modeset_unlock(&crtc->mutex);
+
+	drm_modeset_unlock(&dev->mode_config.connection_mutex);
+	mutex_unlock(&dev->mode_config.mutex);
+
+	return res;
+}
+
 /*
  * Returns the min and max vrr vfreq through the connector's debugfs file.
  * Example usage: cat /sys/kernel/debug/dri/0/DP-1/vrr_range
@@ -730,8 +795,6 @@ static ssize_t dp_sdp_message_debugfs_write(struct file *f, const char __user *b
 	return write_size;
 }
 
-DEFINE_SHOW_ATTRIBUTE(vrr_range);
-
 static ssize_t dp_dpcd_address_write(struct file *f, const char __user *buf,
 				 size_t size, loff_t *pos)
 {
@@ -814,6 +877,9 @@ static ssize_t dp_dpcd_data_read(struct file *f, char __user *buf,
 	return read_size - r;
 }
 
+DEFINE_SHOW_ATTRIBUTE(output_bpc);
+DEFINE_SHOW_ATTRIBUTE(vrr_range);
+
 static const struct file_operations dp_link_settings_debugfs_fops = {
 	.owner = THIS_MODULE,
 	.read = dp_link_settings_read,
@@ -866,6 +932,7 @@ static const struct {
 		{"link_settings", &dp_link_settings_debugfs_fops},
 		{"phy_settings", &dp_phy_settings_debugfs_fop},
 		{"test_pattern", &dp_phy_test_pattern_fops},
+		{"output_bpc", &output_bpc_fops},
 		{"vrr_range", &vrr_range_fops},
 		{"sdp_message", &sdp_message_fops},
 		{"aux_dpcd_address", &dp_dpcd_address_debugfs_fops},

commit f867723b41f871c88388462c007976bb9a4c72da
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:51 2019 +0200

    drm/amd: drop use of drmP.h in amdgpu.h
    
    Delete the unused drmP.h from amdgpu.h.
    Fix fallout in various files.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian KÃ¶nig" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-5-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 1d5fc5ad3bee..e611b5376d8c 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -23,7 +23,9 @@
  *
  */
 
-#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+
+#include <drm/drm_debugfs.h>
 
 #include "dc.h"
 #include "amdgpu.h"

commit b62f95d1625100edfa473387fc250d666cf05998
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Fri Mar 22 10:11:14 2019 -0400

    drm/amd/display: Add debugfs entry for amdgpu_dm_visual_confirm
    
    [Why]
    DC provides a few visual confirmation debug options that can be
    dynamically changed at runtime to help debug surface programming issues
    but we don't have any way to access it from userspace.
    
    [How]
    Add the amdgpu_dm_visual_confirm debugfs entry.
    It accepts a string containing the DC visual confirm enum value using
    the debugfs attribute helpers.
    
    The debugfs_create_file_unsafe can be used instead of
    debugfs_create_file as per the documentation.
    
    v2: Use debugfs helpers for getting and setting the value (Christian)
    
    Cc: Leo Li <sunpeng.li@amd.com>
    Cc: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 1a9e3d3dfa38..1d5fc5ad3bee 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -995,6 +995,35 @@ static const struct drm_info_list amdgpu_dm_debugfs_list[] = {
 	{"amdgpu_target_backlight_pwm", &target_backlight_read},
 };
 
+/*
+ * Sets the DC visual confirm debug option from the given string.
+ * Example usage: echo 1 > /sys/kernel/debug/dri/0/amdgpu_visual_confirm
+ */
+static int visual_confirm_set(void *data, u64 val)
+{
+	struct amdgpu_device *adev = data;
+
+	adev->dm.dc->debug.visual_confirm = (enum visual_confirm)val;
+
+	return 0;
+}
+
+/*
+ * Reads the DC visual confirm debug option value into the given buffer.
+ * Example usage: cat /sys/kernel/debug/dri/0/amdgpu_dm_visual_confirm
+ */
+static int visual_confirm_get(void *data, u64 *val)
+{
+	struct amdgpu_device *adev = data;
+
+	*val = adev->dm.dc->debug.visual_confirm;
+
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(visual_confirm_fops, visual_confirm_get,
+			 visual_confirm_set, "%llu\n");
+
 int dtn_debugfs_init(struct amdgpu_device *adev)
 {
 	static const struct file_operations dtn_log_fops = {
@@ -1020,5 +1049,13 @@ int dtn_debugfs_init(struct amdgpu_device *adev)
 		adev,
 		&dtn_log_fops);
 
-	return PTR_ERR_OR_ZERO(ent);
+	if (IS_ERR(ent))
+		return PTR_ERR(ent);
+
+	ent = debugfs_create_file_unsafe("amdgpu_dm_visual_confirm", 0644, root,
+					 adev, &visual_confirm_fops);
+	if (IS_ERR(ent))
+		return PTR_ERR(ent);
+
+	return 0;
 }

commit f258fee6c3c076a406be3388d4099f1b1a45b39c
Author: David Francis <David.Francis@amd.com>
Date:   Tue Mar 5 10:04:15 2019 -0500

    drm/amd/display: Add debugfs dpcd interface
    
    [Why]
    We need arbitrary read/write over DP AUX DPCD
    for debugging
    
    [How]
    Three debugfs entries
    
    Set the target address by writing to
    "aux_dpcd_address"
    (The first four bytes written are used)
    
    Set the transaction size in bytes by writing to
    "aux_dpcd_size"
    (The first four bytes written are used)
    
    Start a transaction by reading/writing
    "aux_dpcd_data"
    
    Do note: there is no concerrency protection at all
    Accessing these entries in quick succession can lead
    to strange behaviour
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 842ddd37fb81..1a9e3d3dfa38 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -29,6 +29,7 @@
 #include "amdgpu.h"
 #include "amdgpu_dm.h"
 #include "amdgpu_dm_debugfs.h"
+#include "dm_helpers.h"
 
 /* function description
  * get/ set DP configuration: lane_count, link_rate, spread_spectrum
@@ -731,6 +732,88 @@ static ssize_t dp_sdp_message_debugfs_write(struct file *f, const char __user *b
 
 DEFINE_SHOW_ATTRIBUTE(vrr_range);
 
+static ssize_t dp_dpcd_address_write(struct file *f, const char __user *buf,
+				 size_t size, loff_t *pos)
+{
+	int r;
+	struct amdgpu_dm_connector *connector = file_inode(f)->i_private;
+
+	if (size < sizeof(connector->debugfs_dpcd_address))
+		return 0;
+
+	r = copy_from_user(&connector->debugfs_dpcd_address,
+			buf, sizeof(connector->debugfs_dpcd_address));
+
+	return size - r;
+}
+
+static ssize_t dp_dpcd_size_write(struct file *f, const char __user *buf,
+				 size_t size, loff_t *pos)
+{
+	int r;
+	struct amdgpu_dm_connector *connector = file_inode(f)->i_private;
+
+	if (size < sizeof(connector->debugfs_dpcd_size))
+		return 0;
+
+	r = copy_from_user(&connector->debugfs_dpcd_size,
+			buf, sizeof(connector->debugfs_dpcd_size));
+
+	if (connector->debugfs_dpcd_size > 256)
+		connector->debugfs_dpcd_size = 0;
+
+	return size - r;
+}
+
+static ssize_t dp_dpcd_data_write(struct file *f, const char __user *buf,
+				 size_t size, loff_t *pos)
+{
+	int r;
+	char *data;
+	struct amdgpu_dm_connector *connector = file_inode(f)->i_private;
+	struct dc_link *link = connector->dc_link;
+	uint32_t write_size = connector->debugfs_dpcd_size;
+
+	if (size < write_size)
+		return 0;
+
+	data = kzalloc(write_size, GFP_KERNEL);
+	if (!data)
+		return 0;
+
+	r = copy_from_user(data, buf, write_size);
+
+	dm_helpers_dp_write_dpcd(link->ctx, link,
+			connector->debugfs_dpcd_address, data, write_size - r);
+	kfree(data);
+	return write_size - r;
+}
+
+static ssize_t dp_dpcd_data_read(struct file *f, char __user *buf,
+				 size_t size, loff_t *pos)
+{
+	int r;
+	char *data;
+	struct amdgpu_dm_connector *connector = file_inode(f)->i_private;
+	struct dc_link *link = connector->dc_link;
+	uint32_t read_size = connector->debugfs_dpcd_size;
+
+	if (size < read_size)
+		return 0;
+
+	data = kzalloc(read_size, GFP_KERNEL);
+	if (!data)
+		return 0;
+
+	dm_helpers_dp_read_dpcd(link->ctx, link,
+			connector->debugfs_dpcd_address, data, read_size);
+
+	r = copy_to_user(buf, data, read_size);
+
+	kfree(data);
+	return read_size - r;
+}
+
 static const struct file_operations dp_link_settings_debugfs_fops = {
 	.owner = THIS_MODULE,
 	.read = dp_link_settings_read,
@@ -757,6 +840,25 @@ static const struct file_operations sdp_message_fops = {
 	.llseek = default_llseek
 };
 
+static const struct file_operations dp_dpcd_address_debugfs_fops = {
+	.owner = THIS_MODULE,
+	.write = dp_dpcd_address_write,
+	.llseek = default_llseek
+};
+
+static const struct file_operations dp_dpcd_size_debugfs_fops = {
+	.owner = THIS_MODULE,
+	.write = dp_dpcd_size_write,
+	.llseek = default_llseek
+};
+
+static const struct file_operations dp_dpcd_data_debugfs_fops = {
+	.owner = THIS_MODULE,
+	.read = dp_dpcd_data_read,
+	.write = dp_dpcd_data_write,
+	.llseek = default_llseek
+};
+
 static const struct {
 	char *name;
 	const struct file_operations *fops;
@@ -765,7 +867,10 @@ static const struct {
 		{"phy_settings", &dp_phy_settings_debugfs_fop},
 		{"test_pattern", &dp_phy_test_pattern_fops},
 		{"vrr_range", &vrr_range_fops},
-		{"sdp_message", &sdp_message_fops}
+		{"sdp_message", &sdp_message_fops},
+		{"aux_dpcd_address", &dp_dpcd_address_debugfs_fops},
+		{"aux_dpcd_size", &dp_dpcd_size_debugfs_fops},
+		{"aux_dpcd_data", &dp_dpcd_data_debugfs_fops}
 };
 
 int connector_debugfs_init(struct amdgpu_dm_connector *connector)

commit c7ba3653e9773256b2b08508a2ed2ca28ea7566b
Author: Leo (Hanghong) Ma <hanghong.ma@amd.com>
Date:   Thu Mar 7 16:18:12 2019 -0500

    drm/amd/display: Generic SDP message access in amdgpu
    
    [Why]
    We need to add DP SDP message test debugfs to make sdp message test
    more convenient and efficient.
    
    [How]
    Add sdp_message debugfs entry in amdgpu.
    
    Signed-off-by: Leo (Hanghong) Ma <hanghong.ma@amd.com>
    Reviewed-by: Sun peng Li <Sunpeng.Li@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 4a55cde027cf..842ddd37fb81 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -688,6 +688,47 @@ static int vrr_range_show(struct seq_file *m, void *data)
 
 	return 0;
 }
+
+/* function description
+ *
+ * generic SDP message access for testing
+ *
+ * debugfs sdp_message is located at /syskernel/debug/dri/0/DP-x
+ *
+ * SDP header
+ * Hb0 : Secondary-Data Packet ID
+ * Hb1 : Secondary-Data Packet type
+ * Hb2 : Secondary-Data-packet-specific header, Byte 0
+ * Hb3 : Secondary-Data-packet-specific header, Byte 1
+ *
+ * for using custom sdp message: input 4 bytes SDP header and 32 bytes raw data
+ */
+static ssize_t dp_sdp_message_debugfs_write(struct file *f, const char __user *buf,
+				 size_t size, loff_t *pos)
+{
+	int r;
+	uint8_t data[36];
+	struct amdgpu_dm_connector *connector = file_inode(f)->i_private;
+	struct dm_crtc_state *acrtc_state;
+	uint32_t write_size = 36;
+
+	if (connector->base.status != connector_status_connected)
+		return -ENODEV;
+
+	if (size == 0)
+		return 0;
+
+	acrtc_state = to_dm_crtc_state(connector->base.state->crtc->state);
+
+	r = copy_from_user(data, buf, write_size);
+
+	write_size -= r;
+
+	dc_stream_send_dp_sdp(acrtc_state->stream, data, write_size);
+
+	return write_size;
+}
+
 DEFINE_SHOW_ATTRIBUTE(vrr_range);
 
 static const struct file_operations dp_link_settings_debugfs_fops = {
@@ -710,6 +751,12 @@ static const struct file_operations dp_phy_test_pattern_fops = {
 	.llseek = default_llseek
 };
 
+static const struct file_operations sdp_message_fops = {
+	.owner = THIS_MODULE,
+	.write = dp_sdp_message_debugfs_write,
+	.llseek = default_llseek
+};
+
 static const struct {
 	char *name;
 	const struct file_operations *fops;
@@ -717,7 +764,8 @@ static const struct {
 		{"link_settings", &dp_link_settings_debugfs_fops},
 		{"phy_settings", &dp_phy_settings_debugfs_fop},
 		{"test_pattern", &dp_phy_test_pattern_fops},
-		{"vrr_range", &vrr_range_fops}
+		{"vrr_range", &vrr_range_fops},
+		{"sdp_message", &sdp_message_fops}
 };
 
 int connector_debugfs_init(struct amdgpu_dm_connector *connector)

commit c06de56121e3ac0f0f1f4a081c041654ffcacd62
Merge: 8d451a4b6e9f a3b22b9f11d9
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Feb 18 13:27:15 2019 +1000

    Merge v5.0-rc7 into drm-next
    
    Backmerging for nouveau and imx that needed some fixes for next pulls.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit 727962f030c23422a01e8b22d0f463815fb15ec4
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Thu Jan 24 12:06:00 2019 -0500

    drm/amd/display: Expose connector VRR range via debugfs
    
    [Why]
    It's useful to know the min and max vrr range for IGT testing.
    
    [How]
    Expose the min and max vfreq for the connector via a debugfs file
    on the connector, "vrr_range".
    
    Example usage: cat /sys/kernel/debug/dri/0/DP-1/vrr_range
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 9a7ac58eb18e..ddd75a4d8ba5 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -671,6 +671,25 @@ static ssize_t dp_phy_test_pattern_debugfs_write(struct file *f, const char __us
 	return bytes_from_user;
 }
 
+/*
+ * Returns the min and max vrr vfreq through the connector's debugfs file.
+ * Example usage: cat /sys/kernel/debug/dri/0/DP-1/vrr_range
+ */
+static int vrr_range_show(struct seq_file *m, void *data)
+{
+	struct drm_connector *connector = m->private;
+	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
+
+	if (connector->status != connector_status_connected)
+		return -ENODEV;
+
+	seq_printf(m, "Min: %u\n", (unsigned int)aconnector->min_vfreq);
+	seq_printf(m, "Max: %u\n", (unsigned int)aconnector->max_vfreq);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(vrr_range);
+
 static const struct file_operations dp_link_settings_debugfs_fops = {
 	.owner = THIS_MODULE,
 	.read = dp_link_settings_read,
@@ -697,7 +716,8 @@ static const struct {
 } dp_debugfs_entries[] = {
 		{"link_settings", &dp_link_settings_debugfs_fops},
 		{"phy_settings", &dp_phy_settings_debugfs_fop},
-		{"test_pattern", &dp_phy_test_pattern_fops}
+		{"test_pattern", &dp_phy_test_pattern_fops},
+		{"vrr_range", &vrr_range_fops}
 };
 
 int connector_debugfs_init(struct amdgpu_dm_connector *connector)

commit f284975ef2bcec6eb5ab51f61ea67f460ca49a03
Author: David Francis <David.Francis@amd.com>
Date:   Tue Nov 13 10:37:16 2018 -0500

    drm/amd/display: Add backlight pwm debugfs
    
    [Why]
    ABM enablement testing can be automated if a way of reading
    target and current hardware backlight is available
    
    [How]
    Expand debugfs interface with two new entries.
    Hook directly into dc interface.  Units are as
    a fraction of 0x1000 = 100%
    
    Use the built-in amdgpu function for creating
    read-only debugfs files
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 9a7ac58eb18e..cca3e16cda4f 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -783,6 +783,45 @@ static ssize_t dtn_log_write(
 	return size;
 }
 
+/*
+ * Backlight at this moment.  Read only.
+ * As written to display, taking ABM and backlight lut into account.
+ * Ranges from 0x0 to 0x10000 (= 100% PWM)
+ */
+static int current_backlight_read(struct seq_file *m, void *data)
+{
+	struct drm_info_node *node = (struct drm_info_node *)m->private;
+	struct drm_device *dev = node->minor->dev;
+	struct amdgpu_device *adev = dev->dev_private;
+	struct dc *dc = adev->dm.dc;
+	unsigned int backlight = dc_get_current_backlight_pwm(dc);
+
+	seq_printf(m, "0x%x\n", backlight);
+	return 0;
+}
+
+/*
+ * Backlight value that is being approached.  Read only.
+ * As written to display, taking ABM and backlight lut into account.
+ * Ranges from 0x0 to 0x10000 (= 100% PWM)
+ */
+static int target_backlight_read(struct seq_file *m, void *data)
+{
+	struct drm_info_node *node = (struct drm_info_node *)m->private;
+	struct drm_device *dev = node->minor->dev;
+	struct amdgpu_device *adev = dev->dev_private;
+	struct dc *dc = adev->dm.dc;
+	unsigned int backlight = dc_get_target_backlight_pwm(dc);
+
+	seq_printf(m, "0x%x\n", backlight);
+	return 0;
+}
+
+static const struct drm_info_list amdgpu_dm_debugfs_list[] = {
+	{"amdgpu_current_backlight_pwm", &current_backlight_read},
+	{"amdgpu_target_backlight_pwm", &target_backlight_read},
+};
+
 int dtn_debugfs_init(struct amdgpu_device *adev)
 {
 	static const struct file_operations dtn_log_fops = {
@@ -793,9 +832,15 @@ int dtn_debugfs_init(struct amdgpu_device *adev)
 	};
 
 	struct drm_minor *minor = adev->ddev->primary;
-	struct dentry *root = minor->debugfs_root;
+	struct dentry *ent, *root = minor->debugfs_root;
+	int ret;
+
+	ret = amdgpu_debugfs_add_files(adev, amdgpu_dm_debugfs_list,
+				ARRAY_SIZE(amdgpu_dm_debugfs_list));
+	if (ret)
+		return ret;
 
-	struct dentry *ent = debugfs_create_file(
+	ent = debugfs_create_file(
 		"amdgpu_dm_dtn_log",
 		0644,
 		root,

commit 8c6259bedab1681382b7829b1e8fc4f12fc4a215
Author: hersen wu <hersenxs.wu@amd.com>
Date:   Thu Oct 4 09:28:20 2018 -0400

    drm/amdgpu/display: dm/amdgpu: make dp phy debugfs for eDP
    
    [WHY] dp debugfs file does not exist for eDP under
          /sys/kernel/debug/dri/0/eDP-1. the root is phy debugfs
          is created for dp connector only.
    [HOW] for eDP connector, create phy debugfs too.
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: David Francis <David.Francis@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 0ef4a40d2247..9a7ac58eb18e 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -705,7 +705,8 @@ int connector_debugfs_init(struct amdgpu_dm_connector *connector)
 	int i;
 	struct dentry *ent, *dir = connector->base.debugfs_entry;
 
-	if (connector->base.connector_type == DRM_MODE_CONNECTOR_DisplayPort) {
+	if (connector->base.connector_type == DRM_MODE_CONNECTOR_DisplayPort ||
+	    connector->base.connector_type == DRM_MODE_CONNECTOR_eDP) {
 		for (i = 0; i < ARRAY_SIZE(dp_debugfs_entries); i++) {
 			ent = debugfs_create_file(dp_debugfs_entries[i].name,
 						  0644,

commit 8901a65f080ad6f4d7c3ef9f23c6f3a0e3e194aa
Author: kbuild test robot <fengguang.wu@intel.com>
Date:   Wed Sep 12 08:59:07 2018 +0800

    drm/amd/display: fix ptr_ret.cocci warnings
    
    drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c:771:1-3: WARNING: PTR_ERR_OR_ZERO can be used
    
     Use PTR_ERR_OR_ZERO rather than if(IS_ERR(...)) + PTR_ERR
    
    Generated by: scripts/coccinelle/api/ptr_ret.cocci
    
    Fixes: e498eb713604 ("drm/amd/display: Add support for hw_state logging via debugfs")
    CC: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Signed-off-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 35ca732f7ffe..0ef4a40d2247 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -801,8 +801,5 @@ int dtn_debugfs_init(struct amdgpu_device *adev)
 		adev,
 		&dtn_log_fops);
 
-	if (IS_ERR(ent))
-		return PTR_ERR(ent);
-
-	return 0;
+	return PTR_ERR_OR_ZERO(ent);
 }

commit 46659a83e4662ed92000ec13445b8c0ca96fd2cc
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Wed Aug 15 12:00:23 2018 -0400

    drm/amd/display: Support reading hw state from debugfs file
    
    [Why]
    
    Logging hardware state can be done by triggering a write to the
    debugfs file. It would also be useful to be able to read the hardware
    state from the debugfs file to be able to generate a clean log without
    timestamps.
    
    [How]
    
    Usage: cat /sys/kernel/debug/dri/0/amdgpu_dm_dtn_log
    
    Threading is an obvious concern when dealing with multiple debugfs
    operations and blocking on global state in dm or dc seems unfavorable.
    
    Adding an extra parameter for the debugfs log context state is the
    implementation done here. Existing code that made use of DTN_INFO
    and its associated macros needed to be refactored to support this.
    
    We don't know the size of the log in advance so it reallocates the
    log string dynamically. Once the log has been generated it's copied
    into the user supplied buffer for the debugfs. This allows for seeking
    support but it's worth nothing that unlike triggering output via
    dmesg the hardware state might change in-between reads if your buffer
    size is too small.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index e79ac1e2c460..35ca732f7ffe 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -720,16 +720,49 @@ int connector_debugfs_init(struct amdgpu_dm_connector *connector)
 	return 0;
 }
 
+/*
+ * Writes DTN log state to the user supplied buffer.
+ * Example usage: cat /sys/kernel/debug/dri/0/amdgpu_dm_dtn_log
+ */
 static ssize_t dtn_log_read(
 	struct file *f,
 	char __user *buf,
 	size_t size,
 	loff_t *pos)
 {
-	/* TODO: Write log output to the user supplied buffer. */
-	return 0;
+	struct amdgpu_device *adev = file_inode(f)->i_private;
+	struct dc *dc = adev->dm.dc;
+	struct dc_log_buffer_ctx log_ctx = { 0 };
+	ssize_t result = 0;
+
+	if (!buf || !size)
+		return -EINVAL;
+
+	if (!dc->hwss.log_hw_state)
+		return 0;
+
+	dc->hwss.log_hw_state(dc, &log_ctx);
+
+	if (*pos < log_ctx.pos) {
+		size_t to_copy = log_ctx.pos - *pos;
+
+		to_copy = min(to_copy, size);
+
+		if (!copy_to_user(buf, log_ctx.buf + *pos, to_copy)) {
+			*pos += to_copy;
+			result = to_copy;
+		}
+	}
+
+	kfree(log_ctx.buf);
+
+	return result;
 }
 
+/*
+ * Writes DTN log state to dmesg when triggered via a write.
+ * Example usage: echo 1 > /sys/kernel/debug/dri/0/amdgpu_dm_dtn_log
+ */
 static ssize_t dtn_log_write(
 	struct file *f,
 	const char __user *buf,
@@ -744,7 +777,7 @@ static ssize_t dtn_log_write(
 		return 0;
 
 	if (dc->hwss.log_hw_state)
-		dc->hwss.log_hw_state(dc);
+		dc->hwss.log_hw_state(dc, NULL);
 
 	return size;
 }

commit e498eb7136042aa9a352b1039c678537f4694158
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue Aug 14 15:40:57 2018 -0400

    drm/amd/display: Add support for hw_state logging via debugfs
    
    [Why]
    
    We have logging methods for printing hardware state for newer ASICs
    but no way to trigger the log output.
    
    [How]
    
    Add support for triggering the output via writing to a debugfs file
    entry. Log output currently goes into dmesg for convenience, but
    accessing via a read should be possible later.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 0d9e410ca01e..e79ac1e2c460 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -720,3 +720,56 @@ int connector_debugfs_init(struct amdgpu_dm_connector *connector)
 	return 0;
 }
 
+static ssize_t dtn_log_read(
+	struct file *f,
+	char __user *buf,
+	size_t size,
+	loff_t *pos)
+{
+	/* TODO: Write log output to the user supplied buffer. */
+	return 0;
+}
+
+static ssize_t dtn_log_write(
+	struct file *f,
+	const char __user *buf,
+	size_t size,
+	loff_t *pos)
+{
+	struct amdgpu_device *adev = file_inode(f)->i_private;
+	struct dc *dc = adev->dm.dc;
+
+	/* Write triggers log output via dmesg. */
+	if (size == 0)
+		return 0;
+
+	if (dc->hwss.log_hw_state)
+		dc->hwss.log_hw_state(dc);
+
+	return size;
+}
+
+int dtn_debugfs_init(struct amdgpu_device *adev)
+{
+	static const struct file_operations dtn_log_fops = {
+		.owner = THIS_MODULE,
+		.read = dtn_log_read,
+		.write = dtn_log_write,
+		.llseek = default_llseek
+	};
+
+	struct drm_minor *minor = adev->ddev->primary;
+	struct dentry *root = minor->debugfs_root;
+
+	struct dentry *ent = debugfs_create_file(
+		"amdgpu_dm_dtn_log",
+		0644,
+		root,
+		adev,
+		&dtn_log_fops);
+
+	if (IS_ERR(ent))
+		return PTR_ERR(ent);
+
+	return 0;
+}

commit 245524d9b827e184de1a23aff24c7872fed04cdb
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Wed Jun 27 13:03:04 2018 -0400

    drm/amd/display: dp debugfs allow link rate lane count greater than dp rx reported caps
    
    [Why]
    when hw team does phy parameters tuning, there is need to force dp
    link rate or lane count grater than the values from dp receiver to
    check dp tx. current debufs limit link rate, lane count no more
    than rx caps.
    
    [How] remove force settings less than rx caps check
    
    v2: Fix typo in title
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 0276e09d0b82..0d9e410ca01e 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -214,8 +214,7 @@ static ssize_t dp_link_settings_write(struct file *f, const char __user *buf,
 		break;
 	}
 
-	if (!valid_input || (param[0] > link->reported_link_cap.lane_count) ||
-			(param[1] > link->reported_link_cap.link_rate)) {
+	if (!valid_input) {
 		kfree(wr_buf);
 		DRM_DEBUG_DRIVER("Invalid Input value No HW will be programmed\n");
 		return bytes_from_user;

commit 53a599de5560b95bf76bc12d17b93406c33e9f75
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Fri Jun 22 13:06:01 2018 -0400

    drm/amd/display: Linux hook test pattern through debufs
    
    bug fix: phy test PLTAT is special 80bit test pattern. The 80bit
    data should be hard coded within driver so that user does not
    need input the deata. previous driver does not have hard coded
    80 bits pattern data for PLTPAT. Other than this PLTPAT, user
    has to input 80 bits pattern data. In case user input less than
    10 bytes data, un-input data byte will be filled by 0x00.
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index f20ba9d1c9e2..0276e09d0b82 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -483,16 +483,22 @@ static ssize_t dp_phy_test_pattern_debugfs_write(struct file *f, const char __us
 	char *wr_buf = NULL;
 	char *wr_buf_ptr = NULL;
 	uint32_t wr_buf_size = 100;
+	uint32_t wr_buf_count = 0;
 	int r;
 	int bytes_from_user;
-	char *sub_str;
+	char *sub_str = NULL;
 	uint8_t param_index = 0;
-	long param[11];
+	uint8_t param_nums = 0;
+	long param[11] = {0x0};
 	const char delimiter[3] = {' ', '\n', '\0'};
 	enum dp_test_pattern test_pattern = DP_TEST_PATTERN_UNSUPPORTED;
 	bool disable_hpd = false;
 	bool valid_test_pattern = false;
-	uint8_t custom_pattern[10] = {0};
+	/* init with defalut 80bit custom pattern */
+	uint8_t custom_pattern[10] = {
+			0x1f, 0x7c, 0xf0, 0xc1, 0x07,
+			0x1f, 0x7c, 0xf0, 0xc1, 0x07
+			};
 	struct dc_link_settings prefer_link_settings = {LANE_COUNT_UNKNOWN,
 			LINK_RATE_UNKNOWN, LINK_SPREAD_DISABLED};
 	struct dc_link_settings cur_link_settings = {LANE_COUNT_UNKNOWN,
@@ -519,25 +525,51 @@ static ssize_t dp_phy_test_pattern_debugfs_write(struct file *f, const char __us
 
 	bytes_from_user = wr_buf_size - r;
 
-	while (isspace(*wr_buf_ptr))
+	/* check number of parameters. isspace could not differ space and \n */
+	while ((*wr_buf_ptr != 0xa) && (wr_buf_count < wr_buf_size)) {
+		/* skip space*/
+		while (isspace(*wr_buf_ptr) && (wr_buf_count < wr_buf_size)) {
+			wr_buf_ptr++;
+			wr_buf_count++;
+			}
+
+		if (wr_buf_count == wr_buf_size)
+			break;
+
+		/* skip non-space*/
+		while ((!isspace(*wr_buf_ptr)) && (wr_buf_count < wr_buf_size)) {
+			wr_buf_ptr++;
+			wr_buf_count++;
+			}
+
+		param_nums++;
+
+		if (wr_buf_count == wr_buf_size)
+			break;
+	}
+
+	/* max 11 parameters */
+	if (param_nums > 11)
+		param_nums = 11;
+
+	wr_buf_ptr = wr_buf; /* reset buf pinter */
+	wr_buf_count = 0; /* number of char already checked */
+
+	while (isspace(*wr_buf_ptr) && (wr_buf_count < wr_buf_size)) {
 		wr_buf_ptr++;
+		wr_buf_count++;
+	}
 
-	while ((*wr_buf_ptr != '\0') && (param_index < 1)) {
+	while (param_index < param_nums) {
+		/* after strsep, wr_buf_ptr will be moved to after space */
 		sub_str = strsep(&wr_buf_ptr, delimiter);
+
 		r = kstrtol(sub_str, 16, &param[param_index]);
 
 		if (r)
 			DRM_DEBUG_DRIVER("string to int convert error code: %d\n", r);
 
 		param_index++;
-		while (isspace(*wr_buf_ptr))
-			wr_buf_ptr++;
-
-		/* DP_TEST_PATTERN_80BIT_CUSTOM need extra 80 bits
-		 * whci are 10 bytes separte by space
-		 */
-		if (param[0] != 0x4)
-			break;
 	}
 
 	test_pattern = param[0];
@@ -575,8 +607,16 @@ static ssize_t dp_phy_test_pattern_debugfs_write(struct file *f, const char __us
 	}
 
 	if (test_pattern == DP_TEST_PATTERN_80BIT_CUSTOM) {
-		for (i = 0; i < 10; i++)
-			custom_pattern[i] = (uint8_t) param[i + 1];
+		for (i = 0; i < 10; i++) {
+			if ((uint8_t) param[i + 1] != 0x0)
+				break;
+		}
+
+		if (i < 10) {
+			/* not use default value */
+			for (i = 0; i < 10; i++)
+				custom_pattern[i] = (uint8_t) param[i + 1];
+		}
 	}
 
 	/* Usage: set DP physical test pattern using debugfs with normal DP

commit f8ac2cf78f276b4d9fc0bc6b90f5e3560caa11de
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Fri Jun 15 10:32:50 2018 -0400

    drm/amd/display: Linux set/read lane settings through debugfs
    
     function: get current DP PHY settings: voltage swing, pre-emphasis,
     post-cursor2 (defined by VESA DP specification)
    
     valid values:  voltage swing: 0,1,2,3  pre-emphasis : 0,1,2,3
     post cursor2 : 0,1,2,3
    
     debugfs file phy_setings is located at  /sys/kernel/debug/dri/0/DP-x
    
     there will be directories, like DP-1, DP-2,DP-3, etc. for DP display
    
     --- to figure out which DP-x is the display for DP to be check,
     cd DP-x
     ls -ll
     There should be debugfs file, like link_settings, phy_settings.
     cat link_settings
     from lane_count, link_rate to figure which DP-x is for display to be
     worked on
    
     --- to get current DP PHY settings,
     cat phy_settings
    
     --- to change DP PHY settings,
     echo <voltage_swing> <pre-emphasis> <post_cursor2> > phy_settings
    
     for examle, to change voltage swing to 2, pre-emphasis to 3,
     post_cursor2 to 0,
     echo 2 3 0 > phy_settings
    
     ---  to check if change be applied, get current phy settings by
     cat phy_settings
    
     ---  in case invalid values are set by user, like
     echo 1 4 0 > phy_settings
    
     HW will NOT be programmed by these settings.
    
    cat phy_settings will show the previous valid settings.
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 8ddbf219dd23..f20ba9d1c9e2 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -26,7 +26,6 @@
 #include <linux/debugfs.h>
 
 #include "dc.h"
-
 #include "amdgpu.h"
 #include "amdgpu_dm.h"
 #include "amdgpu_dm_debugfs.h"
@@ -46,7 +45,7 @@
  *
  * --- to get dp configuration
  *
- * xxd -l 300 phy_settings
+ * cat link_settings
  *
  * It will list current, verified, reported, preferred dp configuration.
  * current -- for current video mode
@@ -56,7 +55,7 @@
  *
  * --- set (or force) dp configuration
  *
- * echo <lane_count>  <link_rate>
+ * echo <lane_count>  <link_rate> > link_settings
  *
  * for example, to force to  2 lane, 2.7GHz,
  * echo 4 0xa > link_settings
@@ -67,7 +66,7 @@
  * done. please check link settings after force operation to see if HW get
  * programming.
  *
- * xxd -l 300 link_settings
+ * cat link_settings
  *
  * check current and preferred settings.
  *
@@ -79,13 +78,13 @@ static ssize_t dp_link_settings_read(struct file *f, char __user *buf,
 	struct dc_link *link = connector->dc_link;
 	char *rd_buf = NULL;
 	char *rd_buf_ptr = NULL;
-	uint32_t rd_buf_size = 320;
-	int bytes_to_user;
+	const uint32_t rd_buf_size = 100;
+	uint32_t result = 0;
 	uint8_t str_len = 0;
 	int r;
 
-	if (size == 0)
-		return 0;
+	if (*pos & 3 || size & 3)
+		return -EINVAL;
 
 	rd_buf = kcalloc(rd_buf_size, sizeof(char), GFP_KERNEL);
 	if (!rd_buf)
@@ -98,39 +97,44 @@ static ssize_t dp_link_settings_read(struct file *f, char __user *buf,
 			link->cur_link_settings.lane_count,
 			link->cur_link_settings.link_rate,
 			link->cur_link_settings.link_spread);
-	rd_buf_ptr = rd_buf_ptr + str_len;
+	rd_buf_ptr += str_len;
 
 	str_len = strlen("Verified:  %d  %d  %d  ");
 	snprintf(rd_buf_ptr, str_len, "Verified:  %d  %d  %d  ",
 			link->verified_link_cap.lane_count,
 			link->verified_link_cap.link_rate,
 			link->verified_link_cap.link_spread);
-	rd_buf_ptr = rd_buf_ptr + str_len;
+	rd_buf_ptr += str_len;
 
 	str_len = strlen("Reported:  %d  %d  %d  ");
 	snprintf(rd_buf_ptr, str_len, "Reported:  %d  %d  %d  ",
 			link->reported_link_cap.lane_count,
 			link->reported_link_cap.link_rate,
 			link->reported_link_cap.link_spread);
-	rd_buf_ptr = rd_buf_ptr + str_len;
+	rd_buf_ptr += str_len;
 
 	str_len = strlen("Preferred:  %d  %d  %d  ");
-	snprintf(rd_buf_ptr, str_len, "Preferred:  %d  %d  %d  ",
+	snprintf(rd_buf_ptr, str_len, "Preferred:  %d  %d  %d\n",
 			link->preferred_link_setting.lane_count,
 			link->preferred_link_setting.link_rate,
 			link->preferred_link_setting.link_spread);
 
-	r = copy_to_user(buf, rd_buf, rd_buf_size);
+	while (size) {
+		if (*pos >= rd_buf_size)
+			break;
 
-	bytes_to_user = rd_buf_size - r;
+		r = put_user(*(rd_buf + result), buf);
+		if (r)
+			return r; /* r = -EFAULT */
 
-	if (r > rd_buf_size) {
-		bytes_to_user = 0;
-		DRM_DEBUG_DRIVER("data not copy to user");
+		buf += 1;
+		size -= 1;
+		*pos += 1;
+		result += 1;
 	}
 
 	kfree(rd_buf);
-	return bytes_to_user;
+	return result;
 }
 
 static ssize_t dp_link_settings_write(struct file *f, const char __user *buf,
@@ -142,7 +146,7 @@ static ssize_t dp_link_settings_write(struct file *f, const char __user *buf,
 	struct dc_link_settings prefer_link_settings;
 	char *wr_buf = NULL;
 	char *wr_buf_ptr = NULL;
-	uint32_t wr_buf_size = 40;
+	const uint32_t wr_buf_size = 40;
 	int r;
 	int bytes_from_user;
 	char *sub_str;
@@ -153,11 +157,11 @@ static ssize_t dp_link_settings_write(struct file *f, const char __user *buf,
 	bool valid_input = false;
 
 	if (size == 0)
-		return 0;
+		return -EINVAL;
 
 	wr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);
 	if (!wr_buf)
-		return 0;
+		return -EINVAL;
 	wr_buf_ptr = wr_buf;
 
 	r = copy_from_user(wr_buf_ptr, buf, wr_buf_size);
@@ -166,7 +170,7 @@ static ssize_t dp_link_settings_write(struct file *f, const char __user *buf,
 	if (r >= wr_buf_size) {
 		kfree(wr_buf);
 		DRM_DEBUG_DRIVER("user data not read\n");
-		return 0;
+		return -EINVAL;
 	}
 
 	bytes_from_user = wr_buf_size - r;
@@ -181,16 +185,13 @@ static ssize_t dp_link_settings_write(struct file *f, const char __user *buf,
 		r = kstrtol(sub_str, 16, &param[param_index]);
 
 		if (r)
-			DRM_DEBUG_DRIVER(" -EINVAL convert error happens!\n");
+			DRM_DEBUG_DRIVER("string to int convert error code: %d\n", r);
 
 		param_index++;
 		while (isspace(*wr_buf_ptr))
 			wr_buf_ptr++;
 	}
 
-	DRM_DEBUG_DRIVER("Lane_count:  %lx\n", param[0]);
-	DRM_DEBUG_DRIVER("link_rate:  %lx\n", param[1]);
-
 	switch (param[0]) {
 	case LANE_COUNT_ONE:
 	case LANE_COUNT_TWO:
@@ -213,9 +214,10 @@ static ssize_t dp_link_settings_write(struct file *f, const char __user *buf,
 		break;
 	}
 
-	if (!valid_input) {
+	if (!valid_input || (param[0] > link->reported_link_cap.lane_count) ||
+			(param[1] > link->reported_link_cap.link_rate)) {
 		kfree(wr_buf);
-		DRM_DEBUG_DRIVER("Invalid Input value  exceed  No HW will be programmed\n");
+		DRM_DEBUG_DRIVER("Invalid Input value No HW will be programmed\n");
 		return bytes_from_user;
 	}
 
@@ -229,36 +231,190 @@ static ssize_t dp_link_settings_write(struct file *f, const char __user *buf,
 	dc_link_set_preferred_link_settings(dc, &prefer_link_settings, link);
 
 	kfree(wr_buf);
-
 	return bytes_from_user;
 }
 
-static ssize_t dp_voltage_swing_debugfs_read(struct file *f, char __user *buf,
+/* function: get current DP PHY settings: voltage swing, pre-emphasis,
+ * post-cursor2 (defined by VESA DP specification)
+ *
+ * valid values
+ * voltage swing: 0,1,2,3
+ * pre-emphasis : 0,1,2,3
+ * post cursor2 : 0,1,2,3
+ *
+ *
+ * how to use this debugfs
+ *
+ * debugfs is located at /sys/kernel/debug/dri/0/DP-x
+ *
+ * there will be directories, like DP-1, DP-2,DP-3, etc. for DP display
+ *
+ * To figure out which DP-x is the display for DP to be check,
+ * cd DP-x
+ * ls -ll
+ * There should be debugfs file, like link_settings, phy_settings.
+ * cat link_settings
+ * from lane_count, link_rate to figure which DP-x is for display to be worked
+ * on
+ *
+ * To get current DP PHY settings,
+ * cat phy_settings
+ *
+ * To change DP PHY settings,
+ * echo <voltage_swing> <pre-emphasis> <post_cursor2> > phy_settings
+ * for examle, to change voltage swing to 2, pre-emphasis to 3, post_cursor2 to
+ * 0,
+ * echo 2 3 0 > phy_settings
+ *
+ * To check if change be applied, get current phy settings by
+ * cat phy_settings
+ *
+ * In case invalid values are set by user, like
+ * echo 1 4 0 > phy_settings
+ *
+ * HW will NOT be programmed by these settings.
+ * cat phy_settings will show the previous valid settings.
+ */
+static ssize_t dp_phy_settings_read(struct file *f, char __user *buf,
 				 size_t size, loff_t *pos)
 {
-	/* TODO: create method to read voltage swing */
-	return 1;
-}
+	struct amdgpu_dm_connector *connector = file_inode(f)->i_private;
+	struct dc_link *link = connector->dc_link;
+	char *rd_buf = NULL;
+	const uint32_t rd_buf_size = 20;
+	uint32_t result = 0;
+	int r;
 
-static ssize_t dp_voltage_swing_debugfs_write(struct file *f, const char __user *buf,
-				 size_t size, loff_t *pos)
-{
-	/* TODO: create method to write voltage swing */
-	return 1;
-}
+	if (*pos & 3 || size & 3)
+		return -EINVAL;
 
-static ssize_t dp_pre_emphasis_debugfs_read(struct file *f, char __user *buf,
-				 size_t size, loff_t *pos)
-{
-	/* TODO: create method to read pre-emphasis */
-	return 1;
+	rd_buf = kcalloc(rd_buf_size, sizeof(char), GFP_KERNEL);
+	if (!rd_buf)
+		return -EINVAL;
+
+	snprintf(rd_buf, rd_buf_size, "  %d  %d  %d  ",
+			link->cur_lane_setting.VOLTAGE_SWING,
+			link->cur_lane_setting.PRE_EMPHASIS,
+			link->cur_lane_setting.POST_CURSOR2);
+
+	while (size) {
+		if (*pos >= rd_buf_size)
+			break;
+
+		r = put_user((*(rd_buf + result)), buf);
+		if (r)
+			return r; /* r = -EFAULT */
+
+		buf += 1;
+		size -= 1;
+		*pos += 1;
+		result += 1;
+	}
+
+	kfree(rd_buf);
+	return result;
 }
 
-static ssize_t dp_pre_emphasis_debugfs_write(struct file *f, const char __user *buf,
+static ssize_t dp_phy_settings_write(struct file *f, const char __user *buf,
 				 size_t size, loff_t *pos)
 {
-	/* TODO: create method to write pre-emphasis */
-	return 1;
+	struct amdgpu_dm_connector *connector = file_inode(f)->i_private;
+	struct dc_link *link = connector->dc_link;
+	struct dc *dc = (struct dc *)link->dc;
+	char *wr_buf = NULL;
+	char *wr_buf_ptr = NULL;
+	uint32_t wr_buf_size = 40;
+	int r;
+	int bytes_from_user;
+	char *sub_str;
+	uint8_t param_index = 0;
+	long param[3];
+	const char delimiter[3] = {' ', '\n', '\0'};
+	bool use_prefer_link_setting;
+	struct link_training_settings link_lane_settings;
+
+	if (size == 0)
+		return 0;
+
+	wr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);
+	if (!wr_buf)
+		return 0;
+	wr_buf_ptr = wr_buf;
+
+	r = copy_from_user(wr_buf_ptr, buf, wr_buf_size);
+
+	/* r is bytes not be copied */
+	if (r >= wr_buf_size) {
+		kfree(wr_buf);
+		DRM_DEBUG_DRIVER("user data not be read\n");
+		return 0;
+	}
+
+	bytes_from_user = wr_buf_size - r;
+
+	while (isspace(*wr_buf_ptr))
+		wr_buf_ptr++;
+
+	while ((*wr_buf_ptr != '\0') && (param_index < 3)) {
+
+		sub_str = strsep(&wr_buf_ptr, delimiter);
+
+		r = kstrtol(sub_str, 16, &param[param_index]);
+
+		if (r)
+			DRM_DEBUG_DRIVER("string to int convert error code: %d\n", r);
+
+		param_index++;
+		while (isspace(*wr_buf_ptr))
+			wr_buf_ptr++;
+	}
+
+	if ((param[0] > VOLTAGE_SWING_MAX_LEVEL) ||
+			(param[1] > PRE_EMPHASIS_MAX_LEVEL) ||
+			(param[2] > POST_CURSOR2_MAX_LEVEL)) {
+		kfree(wr_buf);
+		DRM_DEBUG_DRIVER("Invalid Input No HW will be programmed\n");
+		return bytes_from_user;
+	}
+
+	/* get link settings: lane count, link rate */
+	use_prefer_link_setting =
+		((link->preferred_link_setting.link_rate != LINK_RATE_UNKNOWN) &&
+		(link->test_pattern_enabled));
+
+	memset(&link_lane_settings, 0, sizeof(link_lane_settings));
+
+	if (use_prefer_link_setting) {
+		link_lane_settings.link_settings.lane_count =
+				link->preferred_link_setting.lane_count;
+		link_lane_settings.link_settings.link_rate =
+				link->preferred_link_setting.link_rate;
+		link_lane_settings.link_settings.link_spread =
+				link->preferred_link_setting.link_spread;
+	} else {
+		link_lane_settings.link_settings.lane_count =
+				link->cur_link_settings.lane_count;
+		link_lane_settings.link_settings.link_rate =
+				link->cur_link_settings.link_rate;
+		link_lane_settings.link_settings.link_spread =
+				link->cur_link_settings.link_spread;
+	}
+
+	/* apply phy settings from user */
+	for (r = 0; r < link_lane_settings.link_settings.lane_count; r++) {
+		link_lane_settings.lane_settings[r].VOLTAGE_SWING =
+				(enum dc_voltage_swing) (param[0]);
+		link_lane_settings.lane_settings[r].PRE_EMPHASIS =
+				(enum dc_pre_emphasis) (param[1]);
+		link_lane_settings.lane_settings[r].POST_CURSOR2 =
+				(enum dc_post_cursor2) (param[2]);
+	}
+
+	/* program ASIC registers and DPCD registers */
+	dc_link_set_drive_settings(dc, &link_lane_settings, link);
+
+	kfree(wr_buf);
+	return bytes_from_user;
 }
 
 /* function description
@@ -483,17 +639,10 @@ static const struct file_operations dp_link_settings_debugfs_fops = {
 	.llseek = default_llseek
 };
 
-static const struct file_operations dp_voltage_swing_fops = {
-	.owner = THIS_MODULE,
-	.read = dp_voltage_swing_debugfs_read,
-	.write = dp_voltage_swing_debugfs_write,
-	.llseek = default_llseek
-};
-
-static const struct file_operations dp_pre_emphasis_fops = {
+static const struct file_operations dp_phy_settings_debugfs_fop = {
 	.owner = THIS_MODULE,
-	.read = dp_pre_emphasis_debugfs_read,
-	.write = dp_pre_emphasis_debugfs_write,
+	.read = dp_phy_settings_read,
+	.write = dp_phy_settings_write,
 	.llseek = default_llseek
 };
 
@@ -508,8 +657,7 @@ static const struct {
 	const struct file_operations *fops;
 } dp_debugfs_entries[] = {
 		{"link_settings", &dp_link_settings_debugfs_fops},
-		{"voltage_swing", &dp_voltage_swing_fops},
-		{"pre_emphasis", &dp_pre_emphasis_fops},
+		{"phy_settings", &dp_phy_settings_debugfs_fop},
 		{"test_pattern", &dp_phy_test_pattern_fops}
 };
 

commit 0a1d56599b9bb58464a8bf1243191eb32b36b694
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Tue Jun 19 12:14:29 2018 -0400

    drm/amd/display: hook dp test pattern through debugfs
    
     set PHY layer or Link layer test pattern
     PHY test pattern is used for PHY SI check.
     Link layer test will not affect PHY SI.
    
     - normal video mode
      0 = DP_TEST_PATTERN_VIDEO_MODE
    
     - PHY test pattern supported
      1 = DP_TEST_PATTERN_D102
      2 = DP_TEST_PATTERN_SYMBOL_ERROR
      3 = DP_TEST_PATTERN_PRBS7
      4 = DP_TEST_PATTERN_80BIT_CUSTOM
      5 = DP_TEST_PATTERN_CP2520_1
      6 = DP_TEST_PATTERN_CP2520_2 = DP_TEST_PATTERN_HBR2_COMPLIANCE_EYE
      7 = DP_TEST_PATTERN_CP2520_3
    
     - DP PHY Link Training Patterns
      8 = DP_TEST_PATTERN_TRAINING_PATTERN1
      9 = DP_TEST_PATTERN_TRAINING_PATTERN2
      0xa = DP_TEST_PATTERN_TRAINING_PATTERN3
      0xb = DP_TEST_PATTERN_TRAINING_PATTERN4
    
     - DP Link Layer Test pattern
      0xc = DP_TEST_PATTERN_COLOR_SQUARES
      0xd = DP_TEST_PATTERN_COLOR_SQUARES_CEA
      0xe = DP_TEST_PATTERN_VERTICAL_BARS
      0xf = DP_TEST_PATTERN_HORIZONTAL_BARS
      0x10= DP_TEST_PATTERN_COLOR_RAMP
    
     debugfs phy_test_pattern is located at /syskernel/debug/dri/0/DP-x
    
     --- set test pattern
      echo <test pattern #> > test_pattern
    
     - custom test pattern
      If test pattern # is not supported, NO HW programming will be done
      for DP_TEST_PATTERN_80BIT_CUSTOM, it needs extra 10 bytes of data
      for the user pattern. input 10 bytes data are separated by space
    
      echo 0x4 0x11 0x22 0x33 0x44 0x55 0x66 0x77 0x88 0x99 0xaa >
      test_pattern
    
     --- reset test pattern
      echo 0 > test_pattern
    
     --- HPD detection is disabled when set PHY test pattern
    
      when PHY test pattern (pattern # within [1,7]) is set, HPD pin of
      HW ASIC is disable. User could unplug DP display from DP connected
      and plug scope to check test pattern PHY SI.
      If there is need unplug scope and plug DP display back, do steps
      below:
      echo 0 > phy_test_pattern
      unplug scope
      plug DP display.
    
      "echo 0 > phy_test_pattern" will re-enable HPD pin again so that
      video sw driver could detect "unplug scope" and "plug DP display"
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 9ff8833b52c4..8ddbf219dd23 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -261,18 +261,219 @@ static ssize_t dp_pre_emphasis_debugfs_write(struct file *f, const char __user *
 	return 1;
 }
 
-static ssize_t dp_phy_test_pattern_debugfs_read(struct file *f, char __user *buf,
-				 size_t size, loff_t *pos)
-{
-	/* TODO: create method to read PHY test pattern */
-	return 1;
-}
-
+/* function description
+ *
+ * set PHY layer or Link layer test pattern
+ * PHY test pattern is used for PHY SI check.
+ * Link layer test will not affect PHY SI.
+ *
+ * Reset Test Pattern:
+ * 0 = DP_TEST_PATTERN_VIDEO_MODE
+ *
+ * PHY test pattern supported:
+ * 1 = DP_TEST_PATTERN_D102
+ * 2 = DP_TEST_PATTERN_SYMBOL_ERROR
+ * 3 = DP_TEST_PATTERN_PRBS7
+ * 4 = DP_TEST_PATTERN_80BIT_CUSTOM
+ * 5 = DP_TEST_PATTERN_CP2520_1
+ * 6 = DP_TEST_PATTERN_CP2520_2 = DP_TEST_PATTERN_HBR2_COMPLIANCE_EYE
+ * 7 = DP_TEST_PATTERN_CP2520_3
+ *
+ * DP PHY Link Training Patterns
+ * 8 = DP_TEST_PATTERN_TRAINING_PATTERN1
+ * 9 = DP_TEST_PATTERN_TRAINING_PATTERN2
+ * a = DP_TEST_PATTERN_TRAINING_PATTERN3
+ * b = DP_TEST_PATTERN_TRAINING_PATTERN4
+ *
+ * DP Link Layer Test pattern
+ * c = DP_TEST_PATTERN_COLOR_SQUARES
+ * d = DP_TEST_PATTERN_COLOR_SQUARES_CEA
+ * e = DP_TEST_PATTERN_VERTICAL_BARS
+ * f = DP_TEST_PATTERN_HORIZONTAL_BARS
+ * 10= DP_TEST_PATTERN_COLOR_RAMP
+ *
+ * debugfs phy_test_pattern is located at /syskernel/debug/dri/0/DP-x
+ *
+ * --- set test pattern
+ * echo <test pattern #> > test_pattern
+ *
+ * If test pattern # is not supported, NO HW programming will be done.
+ * for DP_TEST_PATTERN_80BIT_CUSTOM, it needs extra 10 bytes of data
+ * for the user pattern. input 10 bytes data are separated by space
+ *
+ * echo 0x4 0x11 0x22 0x33 0x44 0x55 0x66 0x77 0x88 0x99 0xaa > test_pattern
+ *
+ * --- reset test pattern
+ * echo 0 > test_pattern
+ *
+ * --- HPD detection is disabled when set PHY test pattern
+ *
+ * when PHY test pattern (pattern # within [1,7]) is set, HPD pin of HW ASIC
+ * is disable. User could unplug DP display from DP connected and plug scope to
+ * check test pattern PHY SI.
+ * If there is need unplug scope and plug DP display back, do steps below:
+ * echo 0 > phy_test_pattern
+ * unplug scope
+ * plug DP display.
+ *
+ * "echo 0 > phy_test_pattern" will re-enable HPD pin again so that video sw
+ * driver could detect "unplug scope" and "plug DP display"
+ */
 static ssize_t dp_phy_test_pattern_debugfs_write(struct file *f, const char __user *buf,
 				 size_t size, loff_t *pos)
 {
-	/* TODO: create method to write PHY test pattern */
-	return 1;
+	struct amdgpu_dm_connector *connector = file_inode(f)->i_private;
+	struct dc_link *link = connector->dc_link;
+	char *wr_buf = NULL;
+	char *wr_buf_ptr = NULL;
+	uint32_t wr_buf_size = 100;
+	int r;
+	int bytes_from_user;
+	char *sub_str;
+	uint8_t param_index = 0;
+	long param[11];
+	const char delimiter[3] = {' ', '\n', '\0'};
+	enum dp_test_pattern test_pattern = DP_TEST_PATTERN_UNSUPPORTED;
+	bool disable_hpd = false;
+	bool valid_test_pattern = false;
+	uint8_t custom_pattern[10] = {0};
+	struct dc_link_settings prefer_link_settings = {LANE_COUNT_UNKNOWN,
+			LINK_RATE_UNKNOWN, LINK_SPREAD_DISABLED};
+	struct dc_link_settings cur_link_settings = {LANE_COUNT_UNKNOWN,
+			LINK_RATE_UNKNOWN, LINK_SPREAD_DISABLED};
+	struct link_training_settings link_training_settings;
+	int i;
+
+	if (size == 0)
+		return 0;
+
+	wr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);
+	if (!wr_buf)
+		return 0;
+	wr_buf_ptr = wr_buf;
+
+	r = copy_from_user(wr_buf_ptr, buf, wr_buf_size);
+
+	/* r is bytes not be copied */
+	if (r >= wr_buf_size) {
+		kfree(wr_buf);
+		DRM_DEBUG_DRIVER("user data not be read\n");
+		return 0;
+	}
+
+	bytes_from_user = wr_buf_size - r;
+
+	while (isspace(*wr_buf_ptr))
+		wr_buf_ptr++;
+
+	while ((*wr_buf_ptr != '\0') && (param_index < 1)) {
+		sub_str = strsep(&wr_buf_ptr, delimiter);
+		r = kstrtol(sub_str, 16, &param[param_index]);
+
+		if (r)
+			DRM_DEBUG_DRIVER("string to int convert error code: %d\n", r);
+
+		param_index++;
+		while (isspace(*wr_buf_ptr))
+			wr_buf_ptr++;
+
+		/* DP_TEST_PATTERN_80BIT_CUSTOM need extra 80 bits
+		 * whci are 10 bytes separte by space
+		 */
+		if (param[0] != 0x4)
+			break;
+	}
+
+	test_pattern = param[0];
+
+	switch (test_pattern) {
+	case DP_TEST_PATTERN_VIDEO_MODE:
+	case DP_TEST_PATTERN_COLOR_SQUARES:
+	case DP_TEST_PATTERN_COLOR_SQUARES_CEA:
+	case DP_TEST_PATTERN_VERTICAL_BARS:
+	case DP_TEST_PATTERN_HORIZONTAL_BARS:
+	case DP_TEST_PATTERN_COLOR_RAMP:
+		valid_test_pattern = true;
+		break;
+
+	case DP_TEST_PATTERN_D102:
+	case DP_TEST_PATTERN_SYMBOL_ERROR:
+	case DP_TEST_PATTERN_PRBS7:
+	case DP_TEST_PATTERN_80BIT_CUSTOM:
+	case DP_TEST_PATTERN_HBR2_COMPLIANCE_EYE:
+	case DP_TEST_PATTERN_TRAINING_PATTERN4:
+		disable_hpd = true;
+		valid_test_pattern = true;
+		break;
+
+	default:
+		valid_test_pattern = false;
+		test_pattern = DP_TEST_PATTERN_UNSUPPORTED;
+		break;
+	}
+
+	if (!valid_test_pattern) {
+		kfree(wr_buf);
+		DRM_DEBUG_DRIVER("Invalid Test Pattern Parameters\n");
+		return bytes_from_user;
+	}
+
+	if (test_pattern == DP_TEST_PATTERN_80BIT_CUSTOM) {
+		for (i = 0; i < 10; i++)
+			custom_pattern[i] = (uint8_t) param[i + 1];
+	}
+
+	/* Usage: set DP physical test pattern using debugfs with normal DP
+	 * panel. Then plug out DP panel and connect a scope to measure
+	 * For normal video mode and test pattern generated from CRCT,
+	 * they are visibile to user. So do not disable HPD.
+	 * Video Mode is also set to clear the test pattern, so enable HPD
+	 * because it might have been disabled after a test pattern was set.
+	 * AUX depends on HPD * sequence dependent, do not move!
+	 */
+	if (!disable_hpd)
+		dc_link_enable_hpd(link);
+
+	prefer_link_settings.lane_count = link->verified_link_cap.lane_count;
+	prefer_link_settings.link_rate = link->verified_link_cap.link_rate;
+	prefer_link_settings.link_spread = link->verified_link_cap.link_spread;
+
+	cur_link_settings.lane_count = link->cur_link_settings.lane_count;
+	cur_link_settings.link_rate = link->cur_link_settings.link_rate;
+	cur_link_settings.link_spread = link->cur_link_settings.link_spread;
+
+	link_training_settings.link_settings = cur_link_settings;
+
+
+	if (test_pattern != DP_TEST_PATTERN_VIDEO_MODE) {
+		if (prefer_link_settings.lane_count != LANE_COUNT_UNKNOWN &&
+			prefer_link_settings.link_rate !=  LINK_RATE_UNKNOWN &&
+			(prefer_link_settings.lane_count != cur_link_settings.lane_count ||
+			prefer_link_settings.link_rate != cur_link_settings.link_rate))
+			link_training_settings.link_settings = prefer_link_settings;
+	}
+
+	for (i = 0; i < (unsigned int)(link_training_settings.link_settings.lane_count); i++)
+		link_training_settings.lane_settings[i] = link->cur_lane_setting;
+
+	dc_link_set_test_pattern(
+		link,
+		test_pattern,
+		&link_training_settings,
+		custom_pattern,
+		10);
+
+	/* Usage: Set DP physical test pattern using AMDDP with normal DP panel
+	 * Then plug out DP panel and connect a scope to measure DP PHY signal.
+	 * Need disable interrupt to avoid SW driver disable DP output. This is
+	 * done after the test pattern is set.
+	 */
+	if (valid_test_pattern && disable_hpd)
+		dc_link_disable_hpd(link);
+
+	kfree(wr_buf);
+
+	return bytes_from_user;
 }
 
 static const struct file_operations dp_link_settings_debugfs_fops = {
@@ -298,7 +499,6 @@ static const struct file_operations dp_pre_emphasis_fops = {
 
 static const struct file_operations dp_phy_test_pattern_fops = {
 	.owner = THIS_MODULE,
-	.read = dp_phy_test_pattern_debugfs_read,
 	.write = dp_phy_test_pattern_debugfs_write,
 	.llseek = default_llseek
 };
@@ -310,7 +510,7 @@ static const struct {
 		{"link_settings", &dp_link_settings_debugfs_fops},
 		{"voltage_swing", &dp_voltage_swing_fops},
 		{"pre_emphasis", &dp_pre_emphasis_fops},
-		{"phy_test_pattern", &dp_phy_test_pattern_fops}
+		{"test_pattern", &dp_phy_test_pattern_fops}
 };
 
 int connector_debugfs_init(struct amdgpu_dm_connector *connector)

commit 41db5f1931ec73f2d909752e09ffb691fecdaaa1
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Fri Jun 15 14:25:48 2018 -0400

    drm/amd/display: set-read link rate and lane count through debugfs
    
     function description
     get/ set DP configuration: lane_count, link_rate, spread_spectrum
    
      valid lane count value: 1, 2, 4
      valid link rate value:
      06h = 1.62Gbps per lane
      0Ah = 2.7Gbps per lane
      0Ch = 3.24Gbps per lane
      14h = 5.4Gbps per lane
      1Eh = 8.1Gbps per lane
    
      debugfs is located at /sys/kernel/debug/dri/0/DP-x/link_settings
    
      --- to get dp configuration
    
      xxd -l 300 phy_settings
    
      It will list current, verified, reported, preferred dp configuration.
      current -- for current video mode
      verified --- maximum configuration which pass link training
      reported --- DP rx report caps (DPCD register offset 0, 1 2)
      preferred --- user force settings
    
      --- set (or force) dp configuration
    
      echo <lane_count>  <link_rate>
    
      for example, to force to  2 lane, 2.7GHz,
      echo 4 0xa > link_settings
    
      spread_spectrum could not be changed dynamically.
    
      in case invalid lane count, link rate are force, no hw programming will be
      done. please check link settings after force operation to see if HW get
      programming.
    
      xxd -l 300 link_settings
    
      check current and preferred settings.
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index cf5ea69e46ad..9ff8833b52c4 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -26,38 +26,211 @@
 #include <linux/debugfs.h>
 
 #include "dc.h"
-#include "dc_link.h"
 
 #include "amdgpu.h"
 #include "amdgpu_dm.h"
 #include "amdgpu_dm_debugfs.h"
 
-static ssize_t dp_link_rate_debugfs_read(struct file *f, char __user *buf,
+/* function description
+ * get/ set DP configuration: lane_count, link_rate, spread_spectrum
+ *
+ * valid lane count value: 1, 2, 4
+ * valid link rate value:
+ * 06h = 1.62Gbps per lane
+ * 0Ah = 2.7Gbps per lane
+ * 0Ch = 3.24Gbps per lane
+ * 14h = 5.4Gbps per lane
+ * 1Eh = 8.1Gbps per lane
+ *
+ * debugfs is located at /sys/kernel/debug/dri/0/DP-x/link_settings
+ *
+ * --- to get dp configuration
+ *
+ * xxd -l 300 phy_settings
+ *
+ * It will list current, verified, reported, preferred dp configuration.
+ * current -- for current video mode
+ * verified --- maximum configuration which pass link training
+ * reported --- DP rx report caps (DPCD register offset 0, 1 2)
+ * preferred --- user force settings
+ *
+ * --- set (or force) dp configuration
+ *
+ * echo <lane_count>  <link_rate>
+ *
+ * for example, to force to  2 lane, 2.7GHz,
+ * echo 4 0xa > link_settings
+ *
+ * spread_spectrum could not be changed dynamically.
+ *
+ * in case invalid lane count, link rate are force, no hw programming will be
+ * done. please check link settings after force operation to see if HW get
+ * programming.
+ *
+ * xxd -l 300 link_settings
+ *
+ * check current and preferred settings.
+ *
+ */
+static ssize_t dp_link_settings_read(struct file *f, char __user *buf,
 				 size_t size, loff_t *pos)
 {
-	/* TODO: create method to read link rate */
-	return 1;
-}
+	struct amdgpu_dm_connector *connector = file_inode(f)->i_private;
+	struct dc_link *link = connector->dc_link;
+	char *rd_buf = NULL;
+	char *rd_buf_ptr = NULL;
+	uint32_t rd_buf_size = 320;
+	int bytes_to_user;
+	uint8_t str_len = 0;
+	int r;
 
-static ssize_t dp_link_rate_debugfs_write(struct file *f, const char __user *buf,
-				 size_t size, loff_t *pos)
-{
-	/* TODO: create method to write link rate */
-	return 1;
-}
+	if (size == 0)
+		return 0;
 
-static ssize_t dp_lane_count_debugfs_read(struct file *f, char __user *buf,
-				 size_t size, loff_t *pos)
-{
-	/* TODO: create method to read lane count */
-	return 1;
+	rd_buf = kcalloc(rd_buf_size, sizeof(char), GFP_KERNEL);
+	if (!rd_buf)
+		return 0;
+
+	rd_buf_ptr = rd_buf;
+
+	str_len = strlen("Current:  %d  %d  %d  ");
+	snprintf(rd_buf_ptr, str_len, "Current:  %d  %d  %d  ",
+			link->cur_link_settings.lane_count,
+			link->cur_link_settings.link_rate,
+			link->cur_link_settings.link_spread);
+	rd_buf_ptr = rd_buf_ptr + str_len;
+
+	str_len = strlen("Verified:  %d  %d  %d  ");
+	snprintf(rd_buf_ptr, str_len, "Verified:  %d  %d  %d  ",
+			link->verified_link_cap.lane_count,
+			link->verified_link_cap.link_rate,
+			link->verified_link_cap.link_spread);
+	rd_buf_ptr = rd_buf_ptr + str_len;
+
+	str_len = strlen("Reported:  %d  %d  %d  ");
+	snprintf(rd_buf_ptr, str_len, "Reported:  %d  %d  %d  ",
+			link->reported_link_cap.lane_count,
+			link->reported_link_cap.link_rate,
+			link->reported_link_cap.link_spread);
+	rd_buf_ptr = rd_buf_ptr + str_len;
+
+	str_len = strlen("Preferred:  %d  %d  %d  ");
+	snprintf(rd_buf_ptr, str_len, "Preferred:  %d  %d  %d  ",
+			link->preferred_link_setting.lane_count,
+			link->preferred_link_setting.link_rate,
+			link->preferred_link_setting.link_spread);
+
+	r = copy_to_user(buf, rd_buf, rd_buf_size);
+
+	bytes_to_user = rd_buf_size - r;
+
+	if (r > rd_buf_size) {
+		bytes_to_user = 0;
+		DRM_DEBUG_DRIVER("data not copy to user");
+	}
+
+	kfree(rd_buf);
+	return bytes_to_user;
 }
 
-static ssize_t dp_lane_count_debugfs_write(struct file *f, const char __user *buf,
+static ssize_t dp_link_settings_write(struct file *f, const char __user *buf,
 				 size_t size, loff_t *pos)
 {
-	/* TODO: create method to write lane count */
-	return 1;
+	struct amdgpu_dm_connector *connector = file_inode(f)->i_private;
+	struct dc_link *link = connector->dc_link;
+	struct dc *dc = (struct dc *)link->dc;
+	struct dc_link_settings prefer_link_settings;
+	char *wr_buf = NULL;
+	char *wr_buf_ptr = NULL;
+	uint32_t wr_buf_size = 40;
+	int r;
+	int bytes_from_user;
+	char *sub_str;
+	/* 0: lane_count; 1: link_rate */
+	uint8_t param_index = 0;
+	long param[2];
+	const char delimiter[3] = {' ', '\n', '\0'};
+	bool valid_input = false;
+
+	if (size == 0)
+		return 0;
+
+	wr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);
+	if (!wr_buf)
+		return 0;
+	wr_buf_ptr = wr_buf;
+
+	r = copy_from_user(wr_buf_ptr, buf, wr_buf_size);
+
+	/* r is bytes not be copied */
+	if (r >= wr_buf_size) {
+		kfree(wr_buf);
+		DRM_DEBUG_DRIVER("user data not read\n");
+		return 0;
+	}
+
+	bytes_from_user = wr_buf_size - r;
+
+	while (isspace(*wr_buf_ptr))
+		wr_buf_ptr++;
+
+	while ((*wr_buf_ptr != '\0') && (param_index < 2)) {
+
+		sub_str = strsep(&wr_buf_ptr, delimiter);
+
+		r = kstrtol(sub_str, 16, &param[param_index]);
+
+		if (r)
+			DRM_DEBUG_DRIVER(" -EINVAL convert error happens!\n");
+
+		param_index++;
+		while (isspace(*wr_buf_ptr))
+			wr_buf_ptr++;
+	}
+
+	DRM_DEBUG_DRIVER("Lane_count:  %lx\n", param[0]);
+	DRM_DEBUG_DRIVER("link_rate:  %lx\n", param[1]);
+
+	switch (param[0]) {
+	case LANE_COUNT_ONE:
+	case LANE_COUNT_TWO:
+	case LANE_COUNT_FOUR:
+		valid_input = true;
+		break;
+	default:
+		break;
+	}
+
+	switch (param[1]) {
+	case LINK_RATE_LOW:
+	case LINK_RATE_HIGH:
+	case LINK_RATE_RBR2:
+	case LINK_RATE_HIGH2:
+	case LINK_RATE_HIGH3:
+		valid_input = true;
+		break;
+	default:
+		break;
+	}
+
+	if (!valid_input) {
+		kfree(wr_buf);
+		DRM_DEBUG_DRIVER("Invalid Input value  exceed  No HW will be programmed\n");
+		return bytes_from_user;
+	}
+
+	/* save user force lane_count, link_rate to preferred settings
+	 * spread spectrum will not be changed
+	 */
+	prefer_link_settings.link_spread = link->cur_link_settings.link_spread;
+	prefer_link_settings.lane_count = param[0];
+	prefer_link_settings.link_rate = param[1];
+
+	dc_link_set_preferred_link_settings(dc, &prefer_link_settings, link);
+
+	kfree(wr_buf);
+
+	return bytes_from_user;
 }
 
 static ssize_t dp_voltage_swing_debugfs_read(struct file *f, char __user *buf,
@@ -102,17 +275,10 @@ static ssize_t dp_phy_test_pattern_debugfs_write(struct file *f, const char __us
 	return 1;
 }
 
-static const struct file_operations dp_link_rate_fops = {
-	.owner = THIS_MODULE,
-	.read = dp_link_rate_debugfs_read,
-	.write = dp_link_rate_debugfs_write,
-	.llseek = default_llseek
-};
-
-static const struct file_operations dp_lane_count_fops = {
+static const struct file_operations dp_link_settings_debugfs_fops = {
 	.owner = THIS_MODULE,
-	.read = dp_lane_count_debugfs_read,
-	.write = dp_lane_count_debugfs_write,
+	.read = dp_link_settings_read,
+	.write = dp_link_settings_write,
 	.llseek = default_llseek
 };
 
@@ -141,8 +307,7 @@ static const struct {
 	char *name;
 	const struct file_operations *fops;
 } dp_debugfs_entries[] = {
-		{"link_rate", &dp_link_rate_fops},
-		{"lane_count", &dp_lane_count_fops},
+		{"link_settings", &dp_link_settings_debugfs_fops},
 		{"voltage_swing", &dp_voltage_swing_fops},
 		{"pre_emphasis", &dp_pre_emphasis_fops},
 		{"phy_test_pattern", &dp_phy_test_pattern_fops}

commit dc38fd9dac3e15538c7c238c4dfb98ceb408fa19
Author: David Francis <David.Francis@amd.com>
Date:   Fri Jun 1 09:49:06 2018 -0400

    drm/amd/display: Add front end for dp debugfs files
    
    As part of hardware certification, read-write access to
    the link rate, lane count, voltage swing, pre-emphasis,
    and PHY test pattern of DP connectors is required.  This commit
    adds debugfs files that will correspond to these values.
    The file operations are not yet implemented: currently
    writing or reading them does nothing.
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
new file mode 100644
index 000000000000..cf5ea69e46ad
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -0,0 +1,170 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include <linux/debugfs.h>
+
+#include "dc.h"
+#include "dc_link.h"
+
+#include "amdgpu.h"
+#include "amdgpu_dm.h"
+#include "amdgpu_dm_debugfs.h"
+
+static ssize_t dp_link_rate_debugfs_read(struct file *f, char __user *buf,
+				 size_t size, loff_t *pos)
+{
+	/* TODO: create method to read link rate */
+	return 1;
+}
+
+static ssize_t dp_link_rate_debugfs_write(struct file *f, const char __user *buf,
+				 size_t size, loff_t *pos)
+{
+	/* TODO: create method to write link rate */
+	return 1;
+}
+
+static ssize_t dp_lane_count_debugfs_read(struct file *f, char __user *buf,
+				 size_t size, loff_t *pos)
+{
+	/* TODO: create method to read lane count */
+	return 1;
+}
+
+static ssize_t dp_lane_count_debugfs_write(struct file *f, const char __user *buf,
+				 size_t size, loff_t *pos)
+{
+	/* TODO: create method to write lane count */
+	return 1;
+}
+
+static ssize_t dp_voltage_swing_debugfs_read(struct file *f, char __user *buf,
+				 size_t size, loff_t *pos)
+{
+	/* TODO: create method to read voltage swing */
+	return 1;
+}
+
+static ssize_t dp_voltage_swing_debugfs_write(struct file *f, const char __user *buf,
+				 size_t size, loff_t *pos)
+{
+	/* TODO: create method to write voltage swing */
+	return 1;
+}
+
+static ssize_t dp_pre_emphasis_debugfs_read(struct file *f, char __user *buf,
+				 size_t size, loff_t *pos)
+{
+	/* TODO: create method to read pre-emphasis */
+	return 1;
+}
+
+static ssize_t dp_pre_emphasis_debugfs_write(struct file *f, const char __user *buf,
+				 size_t size, loff_t *pos)
+{
+	/* TODO: create method to write pre-emphasis */
+	return 1;
+}
+
+static ssize_t dp_phy_test_pattern_debugfs_read(struct file *f, char __user *buf,
+				 size_t size, loff_t *pos)
+{
+	/* TODO: create method to read PHY test pattern */
+	return 1;
+}
+
+static ssize_t dp_phy_test_pattern_debugfs_write(struct file *f, const char __user *buf,
+				 size_t size, loff_t *pos)
+{
+	/* TODO: create method to write PHY test pattern */
+	return 1;
+}
+
+static const struct file_operations dp_link_rate_fops = {
+	.owner = THIS_MODULE,
+	.read = dp_link_rate_debugfs_read,
+	.write = dp_link_rate_debugfs_write,
+	.llseek = default_llseek
+};
+
+static const struct file_operations dp_lane_count_fops = {
+	.owner = THIS_MODULE,
+	.read = dp_lane_count_debugfs_read,
+	.write = dp_lane_count_debugfs_write,
+	.llseek = default_llseek
+};
+
+static const struct file_operations dp_voltage_swing_fops = {
+	.owner = THIS_MODULE,
+	.read = dp_voltage_swing_debugfs_read,
+	.write = dp_voltage_swing_debugfs_write,
+	.llseek = default_llseek
+};
+
+static const struct file_operations dp_pre_emphasis_fops = {
+	.owner = THIS_MODULE,
+	.read = dp_pre_emphasis_debugfs_read,
+	.write = dp_pre_emphasis_debugfs_write,
+	.llseek = default_llseek
+};
+
+static const struct file_operations dp_phy_test_pattern_fops = {
+	.owner = THIS_MODULE,
+	.read = dp_phy_test_pattern_debugfs_read,
+	.write = dp_phy_test_pattern_debugfs_write,
+	.llseek = default_llseek
+};
+
+static const struct {
+	char *name;
+	const struct file_operations *fops;
+} dp_debugfs_entries[] = {
+		{"link_rate", &dp_link_rate_fops},
+		{"lane_count", &dp_lane_count_fops},
+		{"voltage_swing", &dp_voltage_swing_fops},
+		{"pre_emphasis", &dp_pre_emphasis_fops},
+		{"phy_test_pattern", &dp_phy_test_pattern_fops}
+};
+
+int connector_debugfs_init(struct amdgpu_dm_connector *connector)
+{
+	int i;
+	struct dentry *ent, *dir = connector->base.debugfs_entry;
+
+	if (connector->base.connector_type == DRM_MODE_CONNECTOR_DisplayPort) {
+		for (i = 0; i < ARRAY_SIZE(dp_debugfs_entries); i++) {
+			ent = debugfs_create_file(dp_debugfs_entries[i].name,
+						  0644,
+						  dir,
+						  connector,
+						  dp_debugfs_entries[i].fops);
+			if (IS_ERR(ent))
+				return PTR_ERR(ent);
+		}
+	}
+
+	return 0;
+}
+
