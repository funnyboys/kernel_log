commit 3168470142e0a82b5732c04ed4c031a9322ae170
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Jul 10 17:50:00 2020 -0400

    drm/amdgpu/display: create fake mst encoders ahead of time (v4)
    
    Prevents a warning in the MST create connector case.
    
    v2: create global fake encoders rather per connector fake encoders
    to avoid running out of encoder indices.
    
    v3: use the actual number of crtcs on the asic rather than the max
    to conserve encoders.
    
    v4: v3 plus missing hunk I forgot to git add.
    
    Bug: https://gitlab.freedesktop.org/drm/amd/-/issues/1108
    Fixes: c6385e503aeaf9 ("drm/amdgpu: drop legacy drm load and unload callbacks")
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org # 5.7.x

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index ae0a7ef1d595..e5ecc5affa1e 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -95,7 +95,6 @@ dm_dp_mst_connector_destroy(struct drm_connector *connector)
 {
 	struct amdgpu_dm_connector *aconnector =
 		to_amdgpu_dm_connector(connector);
-	struct amdgpu_encoder *amdgpu_encoder = aconnector->mst_encoder;
 
 	if (aconnector->dc_sink) {
 		dc_link_remove_remote_sink(aconnector->dc_link,
@@ -105,8 +104,6 @@ dm_dp_mst_connector_destroy(struct drm_connector *connector)
 
 	kfree(aconnector->edid);
 
-	drm_encoder_cleanup(&amdgpu_encoder->base);
-	kfree(amdgpu_encoder);
 	drm_connector_cleanup(connector);
 	drm_dp_mst_put_port_malloc(aconnector->port);
 	kfree(aconnector);
@@ -243,7 +240,11 @@ static struct drm_encoder *
 dm_mst_atomic_best_encoder(struct drm_connector *connector,
 			   struct drm_connector_state *connector_state)
 {
-	return &to_amdgpu_dm_connector(connector)->mst_encoder->base;
+	struct drm_device *dev = connector->dev;
+	struct amdgpu_device *adev = dev->dev_private;
+	struct amdgpu_crtc *acrtc = to_amdgpu_crtc(connector_state->crtc);
+
+	return &adev->dm.mst_encoders[acrtc->crtc_id].base;
 }
 
 static int
@@ -306,31 +307,27 @@ static const struct drm_encoder_funcs amdgpu_dm_encoder_funcs = {
 	.destroy = amdgpu_dm_encoder_destroy,
 };
 
-static struct amdgpu_encoder *
-dm_dp_create_fake_mst_encoder(struct amdgpu_dm_connector *connector)
+void
+dm_dp_create_fake_mst_encoders(struct amdgpu_device *adev)
 {
-	struct drm_device *dev = connector->base.dev;
-	struct amdgpu_device *adev = dev->dev_private;
-	struct amdgpu_encoder *amdgpu_encoder;
-	struct drm_encoder *encoder;
-
-	amdgpu_encoder = kzalloc(sizeof(*amdgpu_encoder), GFP_KERNEL);
-	if (!amdgpu_encoder)
-		return NULL;
+	struct drm_device *dev = adev->ddev;
+	int i;
 
-	encoder = &amdgpu_encoder->base;
-	encoder->possible_crtcs = amdgpu_dm_get_encoder_crtc_mask(adev);
+	for (i = 0; i < adev->dm.display_indexes_num; i++) {
+		struct amdgpu_encoder *amdgpu_encoder = &adev->dm.mst_encoders[i];
+		struct drm_encoder *encoder = &amdgpu_encoder->base;
 
-	drm_encoder_init(
-		dev,
-		&amdgpu_encoder->base,
-		&amdgpu_dm_encoder_funcs,
-		DRM_MODE_ENCODER_DPMST,
-		NULL);
+		encoder->possible_crtcs = amdgpu_dm_get_encoder_crtc_mask(adev);
 
-	drm_encoder_helper_add(encoder, &amdgpu_dm_encoder_helper_funcs);
+		drm_encoder_init(
+			dev,
+			&amdgpu_encoder->base,
+			&amdgpu_dm_encoder_funcs,
+			DRM_MODE_ENCODER_DPMST,
+			NULL);
 
-	return amdgpu_encoder;
+		drm_encoder_helper_add(encoder, &amdgpu_dm_encoder_helper_funcs);
+	}
 }
 
 static struct drm_connector *
@@ -343,6 +340,7 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 	struct amdgpu_device *adev = dev->dev_private;
 	struct amdgpu_dm_connector *aconnector;
 	struct drm_connector *connector;
+	int i;
 
 	aconnector = kzalloc(sizeof(*aconnector), GFP_KERNEL);
 	if (!aconnector)
@@ -369,9 +367,10 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 		master->dc_link,
 		master->connector_id);
 
-	aconnector->mst_encoder = dm_dp_create_fake_mst_encoder(master);
-	drm_connector_attach_encoder(&aconnector->base,
-				     &aconnector->mst_encoder->base);
+	for (i = 0; i < adev->dm.display_indexes_num; i++) {
+		drm_connector_attach_encoder(&aconnector->base,
+					     &adev->dm.mst_encoders[i].base);
+	}
 
 	connector->max_bpc_property = master->base.max_bpc_property;
 	if (connector->max_bpc_property)

commit 937eea297e26effac6809a0bf8c20e6ca9d90b9a
Merge: 126a34061eec e748f07d00c1
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Apr 30 11:08:54 2020 +1000

    Merge tag 'amd-drm-next-5.8-2020-04-24' of git://people.freedesktop.org/~agd5f/linux into drm-next
    
    amd-drm-next-5.8-2020-04-24:
    
    amdgpu:
    - Documentation improvements
    - Enable FRU chip access on boards that support it
    - RAS updates
    - SR-IOV updates
    - Powerplay locking fixes for older SMU versions
    - VCN DPG (dynamic powergating) cleanup
    - VCN 2.5 DPG enablement
    - Rework GPU scheduler handling
    - Improve scheduler priority handling
    - Add SPM (streaming performance monitor) golden settings for navi
    - GFX10 clockgating fixes
    - DC ABM (automatic backlight modulation) fixes
    - DC cursor and plane fixes
    - DC watermark fixes
    - DC clock handling fixes
    - DC color management fixes
    - GPU reset fixes
    - Clean up MMIO access macros
    - EEPROM access fixes
    - Misc code cleanups
    
    amdkfd:
    - Misc code cleanups
    
    radeon:
    - Clean up safe reg list generation
    - Misc code cleanups
    
    From: Alex Deucher <alexdeucher@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200424190827.4542-1-alexander.deucher@amd.com

commit 9f65693577d976792e6dbad9ad42105b129259c6
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Apr 16 14:44:52 2020 -0400

    drm/amdgpu/display: give aux i2c buses more meaningful names
    
    Mirror what we do for i2c display buses.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 7d28b0482127..69056660672d 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -429,9 +429,12 @@ static const struct drm_dp_mst_topology_cbs dm_mst_cbs = {
 };
 
 void amdgpu_dm_initialize_dp_connector(struct amdgpu_display_manager *dm,
-				       struct amdgpu_dm_connector *aconnector)
+				       struct amdgpu_dm_connector *aconnector,
+				       int link_index)
 {
-	aconnector->dm_dp_aux.aux.name = "dmdc";
+	aconnector->dm_dp_aux.aux.name =
+		kasprintf(GFP_KERNEL, "AMDGPU DM aux hw bus %d",
+			  link_index);
 	aconnector->dm_dp_aux.aux.transfer = dm_dp_aux_transfer;
 	aconnector->dm_dp_aux.ddc_service = aconnector->dc_link->ddc;
 

commit bdb9fbc6bae07c610048b23ca6709e035597e7ae
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Apr 16 14:20:58 2020 -0400

    drm/amdgpu/display: fix aux registration (v2)
    
    We were registering the aux device in the MST late_register
    rather than the regular one.
    
    v2: handle eDP as well
    
    Fixes: 405a1f9090d1ac ("drm/amdgpu/display: split dp connector registration (v4)")
    Bug: https://gitlab.freedesktop.org/drm/amd/-/issues/1100
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index cb49f13c1548..7d28b0482127 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -113,16 +113,16 @@ amdgpu_dm_mst_connector_late_register(struct drm_connector *connector)
 		to_amdgpu_dm_connector(connector);
 	int r;
 
-	amdgpu_dm_connector->dm_dp_aux.aux.dev = connector->kdev;
-	r = drm_dp_aux_register(&amdgpu_dm_connector->dm_dp_aux.aux);
-	if (r)
+	r = drm_dp_mst_connector_late_register(connector,
+					       amdgpu_dm_connector->port);
+	if (r < 0)
 		return r;
 
 #if defined(CONFIG_DEBUG_FS)
 	connector_debugfs_init(amdgpu_dm_connector);
 #endif
 
-	return r;
+	return 0;
 }
 
 static void

commit 1aa63ddf726ea049279989b93b69b57ce6efd75b
Merge: 774f1eeb18b0 14d0066b8477
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Apr 22 10:40:34 2020 +1000

    Merge tag 'drm-misc-next-2020-04-14' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.8:
    
    UAPI Changes:
    
      - drm: error out with EBUSY when device has existing master
      - drm: rework SET_MASTER and DROP_MASTER perm handling
    
    Cross-subsystem Changes:
    
      - mm: export two symbols from slub/slob
      - fbdev: savage: fix -Wextra build warning
      - video: omap2: Use scnprintf() for avoiding potential buffer overflow
    
    Core Changes:
    
      - Remove drm_pci.h
      - drm_pci_{alloc/free)() are now legacy
      - Introduce managed DRM resourcesA
      - Allow drivers to subclass struct drm_framebuffer
      - Introduce struct drm_afbc_framebuffer and helpers
      - fbdev: remove return value from generic fbdev setup
      - Introduce simple-encoder helper
      - vram-helpers: set fence on plane
      - dp_mst: ACT timeout improvements
      - dp_mst: Remove drm_dp_mst_has_audio()
      - TTM: ttm_trace_dma_{map/unmap}() cleanups
      - dma-buf: add flag for PCIP2P support
      - EDID: Various improvements
      - Encoder: cleanup semantics of possible_clones and possible_crtcs
      - VBLANK documentation updates
      - Writeback documentation updates
    
    Driver Changes:
    
      - Convert several drivers to i2c_new_client_device()
      - Drop explicit drm_mode_config_cleanup() calls from drivers
      - Auto-release device structures with drmm_add_final_kfree()
      - Init bfdev console after registering DRM device
      - Make various .debugfs functions return 0 unconditionally; ignore errors
      - video: Use scnprintf() to avoid buffer overflows
      - Convert drivers to simple encoders
    
      - drm/amdgpu: note that we can handle peer2peer DMA-buf
      - drm/amdgpu: add support for exporting VRAM using DMA-buf v3
      - drm/kirin: Revert change to register connectors
      - drm/lima: Add optional devfreq and cooling device support
      - drm/lima: Various improvements wrt. task handling
      - drm/panel: nt39016: Support multiple modes and 50Hz
      - drm/panel: Support Leadtek LTK050H3146W
      - drm/rockchip: Add support for afbc
      - drm/virtio: Various cleanups
      - drm/hisilicon/hibmc: Enforce 128-byte stride alignment
      - drm/qxl: Fix notify port address of cursor ring buffer
      - drm/sun4i: Improvements to format handling
      - drm/bridge: dw-hdmi: Various improvements
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Thomas Zimmermann <tzimmermann@suse.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200414090738.GA16827@linux-uq9g

commit b754c07a39b11cc20586ef55374846605360915b
Author: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
Date:   Sun Apr 5 16:41:09 2020 -0400

    drm/amd/display: Avoid create MST prop after registration
    
    [Why]
    Prop are created at boot stage, and not allowed to create new prop
    after device registration.
    
    [How]
    Reuse the connector property from SST if exist.
    
    Signed-off-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 7f2293016446..cb49f13c1548 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -367,6 +367,14 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 	drm_connector_attach_encoder(&aconnector->base,
 				     &aconnector->mst_encoder->base);
 
+	connector->max_bpc_property = master->base.max_bpc_property;
+	if (connector->max_bpc_property)
+		drm_connector_attach_max_bpc_property(connector, 8, 16);
+
+	connector->vrr_capable_property = master->base.vrr_capable_property;
+	if (connector->vrr_capable_property)
+		drm_connector_attach_vrr_capable_property(connector);
+
 	drm_object_attach_property(
 		&connector->base,
 		dev->mode_config.path_property,

commit 8c61b31e3c3f7dd843ebbf1cc02ca352b66f123f
Author: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
Date:   Sun Apr 5 16:41:09 2020 -0400

    drm/amd/display: Avoid create MST prop after registration
    
    [Why]
    Prop are created at boot stage, and not allowed to create new prop
    after device registration.
    
    [How]
    Reuse the connector property from SST if exist.
    
    Signed-off-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index e8208df420d9..fabbe78d5aef 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -410,6 +410,14 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 	drm_connector_attach_encoder(&aconnector->base,
 				     &aconnector->mst_encoder->base);
 
+	connector->max_bpc_property = master->base.max_bpc_property;
+	if (connector->max_bpc_property)
+		drm_connector_attach_max_bpc_property(connector, 8, 16);
+
+	connector->vrr_capable_property = master->base.vrr_capable_property;
+	if (connector->vrr_capable_property)
+		drm_connector_attach_vrr_capable_property(connector);
+
 	drm_object_attach_property(
 		&connector->base,
 		dev->mode_config.path_property,

commit eefc9589512484b531a181a7db13e9864cbd8c35
Author: Lyude Paul <lyude@redhat.com>
Date:   Tue Mar 31 16:57:36 2020 -0400

    drm/amd/amdgpu_dm/mst: Stop printing extra messages in dm_dp_add_mst_connector()
    
    You can already trace the creation and destruction of connectors using
    DRM, and we definitely don't need to be printing info messages on
    connector hotplugs as well. So, get rid of these.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200331205740.135525-4-lyude@redhat.com
    Reviewed-by: Alex Deucher <alexdeucher@gmail.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 09025ccc68ca..d56b758bcce5 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -433,13 +433,8 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 	 */
 	amdgpu_dm_connector_funcs_reset(connector);
 
-	DRM_INFO("DM_MST: added connector: %p [id: %d] [master: %p]\n",
-		 aconnector, connector->base.id, aconnector->mst_port);
-
 	drm_dp_mst_get_port_malloc(port);
 
-	DRM_DEBUG_KMS(":%d\n", connector->base.id);
-
 	return connector;
 }
 

commit 09b974e8983a4b163d4a406b46d50bf869da3073
Author: Lyude Paul <lyude@redhat.com>
Date:   Tue Mar 31 16:57:35 2020 -0400

    drm/amd/amdgpu_dm/mst: Remove ->destroy_connector() callback
    
    Pankaj Bharadiya started cleaning up the MST connector callbacks a while
    ago, as I pointed out that they are the same across every driver and
    don't serve much purpose. There was one callback that was left over
    though from amdgpu, that we delayed removing due to not being completely
    sure as to whether or not it was needed.
    
    So, I've read through said callback and can confirm it's not at all
    needed. Pretty much all of the work that is done in
    dm_dp_destroy_mst_connector() can be done in
    dm_dp_mst_connector_destroy(). Additionally, I've removed some bits that
    didn't actually do anything:
    
    * Removed DRM_INFO message we were printing, this shouldn't be info
      level and there's more appropriate drm debugging flags that should be
      used instead
    * Removed amdgpu_dm_update_freesync_caps() - reading into this function,
      it doesn't actually do anything important and I'm not sure why it was
      ever being called here
    * Stop clearing aconnector->dc_sink - this also doesn't do anything
    * Stop clearing link settings in dc_link - this also doesn't do anything
    * Also, use shorter variable
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Cc: Pankaj Bharadiya <pankaj.laxminarayan.bharadiya@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200331205740.135525-3-lyude@redhat.com
    Reviewed-by: Alex Deucher <alexdeucher@gmail.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 7b3303efb1ff..09025ccc68ca 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -136,16 +136,23 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 static void
 dm_dp_mst_connector_destroy(struct drm_connector *connector)
 {
-	struct amdgpu_dm_connector *amdgpu_dm_connector = to_amdgpu_dm_connector(connector);
-	struct amdgpu_encoder *amdgpu_encoder = amdgpu_dm_connector->mst_encoder;
+	struct amdgpu_dm_connector *aconnector =
+		to_amdgpu_dm_connector(connector);
+	struct amdgpu_encoder *amdgpu_encoder = aconnector->mst_encoder;
 
-	kfree(amdgpu_dm_connector->edid);
+	if (aconnector->dc_sink) {
+		dc_link_remove_remote_sink(aconnector->dc_link,
+					   aconnector->dc_sink);
+		dc_sink_release(aconnector->dc_sink);
+	}
+
+	kfree(aconnector->edid);
 
 	drm_encoder_cleanup(&amdgpu_encoder->base);
 	kfree(amdgpu_encoder);
 	drm_connector_cleanup(connector);
-	drm_dp_mst_put_port_malloc(amdgpu_dm_connector->port);
-	kfree(amdgpu_dm_connector);
+	drm_dp_mst_put_port_malloc(aconnector->port);
+	kfree(aconnector);
 }
 
 static int
@@ -436,30 +443,8 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 	return connector;
 }
 
-static void dm_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
-					struct drm_connector *connector)
-{
-	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
-
-	DRM_INFO("DM_MST: Disabling connector: %p [id: %d] [master: %p]\n",
-		 aconnector, connector->base.id, aconnector->mst_port);
-
-	if (aconnector->dc_sink) {
-		amdgpu_dm_update_freesync_caps(connector, NULL);
-		dc_link_remove_remote_sink(aconnector->dc_link,
-					   aconnector->dc_sink);
-		dc_sink_release(aconnector->dc_sink);
-		aconnector->dc_sink = NULL;
-		aconnector->dc_link->cur_link_settings.lane_count = 0;
-	}
-
-	drm_connector_unregister(connector);
-	drm_connector_put(connector);
-}
-
 static const struct drm_dp_mst_topology_cbs dm_mst_cbs = {
 	.add_connector = dm_dp_add_mst_connector,
-	.destroy_connector = dm_dp_destroy_mst_connector,
 };
 
 void amdgpu_dm_initialize_dp_connector(struct amdgpu_display_manager *dm,

commit e75405bcd8f3dc88a66be75dd0cbd31dd6de9b0e
Author: Lyude Paul <lyude@redhat.com>
Date:   Tue Mar 31 16:57:34 2020 -0400

    drm/amd/amdgpu_dm/mst: Remove unneeded edid assignment when destroying connectors
    
    Doesn't do anything, noticed this while cleaning up some unrelated
    stuff.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200331205740.135525-2-lyude@redhat.com
    Reviewed-by: Alex Deucher <alexdeucher@gmail.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index e8208df420d9..7b3303efb1ff 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -140,7 +140,6 @@ dm_dp_mst_connector_destroy(struct drm_connector *connector)
 	struct amdgpu_encoder *amdgpu_encoder = amdgpu_dm_connector->mst_encoder;
 
 	kfree(amdgpu_dm_connector->edid);
-	amdgpu_dm_connector->edid = NULL;
 
 	drm_encoder_cleanup(&amdgpu_encoder->base);
 	kfree(amdgpu_encoder);

commit a98c4cd926903ff2aa452b6dbf5be6411a2fbe60
Author: Lyude Paul <lyude@redhat.com>
Date:   Tue Mar 31 17:22:23 2020 -0400

    drm/amd/amdgpu_dm/mst: Remove useless sideband tracing
    
    We already trace DPCD reads/writes on both MST and SST, there's no
    reason to have this code here (plus, toggling these things with a
    define at the top of the file isn't how we do things in the kernel).
    
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index e8208df420d9..7f2293016446 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -41,53 +41,10 @@
 #include "amdgpu_dm_debugfs.h"
 #endif
 
-
 #if defined(CONFIG_DRM_AMD_DC_DCN)
 #include "dc/dcn20/dcn20_resource.h"
 #endif
 
-/* #define TRACE_DPCD */
-
-#ifdef TRACE_DPCD
-#define SIDE_BAND_MSG(address) (address >= DP_SIDEBAND_MSG_DOWN_REQ_BASE && address < DP_SINK_COUNT_ESI)
-
-static inline char *side_band_msg_type_to_str(uint32_t address)
-{
-	static char str[10] = {0};
-
-	if (address < DP_SIDEBAND_MSG_UP_REP_BASE)
-		strcpy(str, "DOWN_REQ");
-	else if (address < DP_SIDEBAND_MSG_DOWN_REP_BASE)
-		strcpy(str, "UP_REP");
-	else if (address < DP_SIDEBAND_MSG_UP_REQ_BASE)
-		strcpy(str, "DOWN_REP");
-	else
-		strcpy(str, "UP_REQ");
-
-	return str;
-}
-
-static void log_dpcd(uint8_t type,
-		     uint32_t address,
-		     uint8_t *data,
-		     uint32_t size,
-		     bool res)
-{
-	DRM_DEBUG_KMS("Op: %s, addr: %04x, SideBand Msg: %s, Op res: %s\n",
-			(type == DP_AUX_NATIVE_READ) ||
-			(type == DP_AUX_I2C_READ) ?
-					"Read" : "Write",
-			address,
-			SIDE_BAND_MSG(address) ?
-					side_band_msg_type_to_str(address) : "Nop",
-			res ? "OK" : "Fail");
-
-	if (res) {
-		print_hex_dump(KERN_INFO, "Body: ", DUMP_PREFIX_NONE, 16, 1, data, size, false);
-	}
-}
-#endif
-
 static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 				  struct drm_dp_aux_msg *msg)
 {

commit d5152d359505407ff648954b068fc912978f306b
Merge: 71fa42fac5d6 6afe6929964b
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Mar 19 11:00:48 2020 +1000

    Merge tag 'drm-misc-next-2020-03-17' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.7:
    
    UAPI Changes:
    
    Cross-subsystem Changes:
    
    Core Changes:
      - dp-mst: Remove register_connector callback, add drm_dp_destroy_connector
      - Changes to scnprintf on multiple instances
    
    Driver Changes:
      - meson: Support for YUV420
      - panel: Support Ortustech COM37H3M, idk-1110wr and idk-2121wr,
               multiple dotclock fixes
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Maxime Ripard <maxime@cerno.tech>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200317082858.lubmvlmvoprn2tuh@gilmour.lan

commit 51b8479ab20ba3804348824c63abdb3f35b0aaeb
Merge: 6afe6929964b 69ddce0970d9
Author: Maxime Ripard <maxime@cerno.tech>
Date:   Tue Mar 17 09:29:11 2020 +0100

    Merge drm/drm-next into drm-misc-next
    
    Jernej needs some patches that got merged in -rc5.
    
    Signed-off-by: Maxime Ripard <maxime@cerno.tech>

commit 69ddce0970d9d1de63bed9c24eefa0814db29a5a
Merge: 9e12da086e5e 5d11e37c021f
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Mar 13 09:09:11 2020 +1000

    Merge tag 'amd-drm-next-5.7-2020-03-10' of git://people.freedesktop.org/~agd5f/linux into drm-next
    
    amd-drm-next-5.7-2020-03-10:
    
    amdgpu:
    - SR-IOV fixes
    - Fix up fallout from drm load/unload callback removal
    - Navi, renoir power management watermark fixes
    - Refactor smu parameter handling
    - Display FEC fixes
    - Display DCC fixes
    - HDCP fixes
    - Add support for USB-C PD firmware updates
    - Pollock detection fix
    - Rework compute ring priority handling
    - RAS fixes
    - Misc cleanups
    
    amdkfd:
    - Consolidate more gfx config details in amdgpu
    - Consolidate bo alloc flags
    - Improve code comments
    - SDMA MQD fixes
    - Misc cleanups
    
    gpu scheduler:
    - Add suport for modifying the sched list
    
    uapi:
    - Clarify comments about GEM_CREATE flags that are not used by userspace.
      The kernel driver has always prevented userspace from using these.
      They are only used internally in the kernel driver.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Alex Deucher <alexdeucher@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200310212748.4519-1-alexander.deucher@amd.com

commit 9e12da086e5e38f7b4f8d6e02a82447f4165fbee
Merge: d3bd37f587b4 bc1a4130fc03
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Mar 12 12:42:41 2020 +1000

    Merge tag 'drm-misc-next-2020-03-09' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.7:
    
    UAPI Changes:
    
    Cross-subsystem Changes:
    
    Core Changes:
    
    Driver Changes:
     - fb-helper: Remove drm_fb_helper_{add,add_all,remove}_one_connector
     - fbdev: some cleanups and dead-code removal
     - Conversions to simple-encoder
     - zero-length array removal
     - Panel: panel-dpi support in panel-simple, Novatek NT35510, Elida
       KD35T133,
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Maxime Ripard <maxime@cerno.tech>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200309135439.dicfnbo4ikj4tkz7@gilmour

commit 615eff35d4278a7701ea36a7808ff5ba2f3d8bac
Author: Pankaj Bharadiya <pankaj.laxminarayan.bharadiya@intel.com>
Date:   Sat Mar 7 14:00:20 2020 +0530

    drm: Remove dp mst register connector callbacks
    
    drm_dp_mst_port_add_connector() directly calls the
    drm_connector_register() now and
    drm_dp_mst_topology_mgr_cbs.register_connector callback is not getting
    called anymore.
    
    Hence remove all drm_dp_mst_topology_mgr_cbs.register_connector
    callbacks.
    
    This is the preparatory step for removing the
    drm_dp_mst_topology_mgr_cbs.register_connector callback hook.
    
    The removal is done with below sementic patch:
    
    @r1@
    identifier func, E;
    @@
    struct drm_dp_mst_topology_cbs E = {
            ...,
    -        .register_connector = func
    };
    
    @delete depends on r1@
    identifier r1.func;
    @@
    - static void func(...){...}
    
    Signed-off-by: Pankaj Bharadiya <pankaj.laxminarayan.bharadiya@intel.com>
    Suggested-by: Emil Velikov <emil.velikov@collabora.com>
    Suggested-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200307083023.76498-3-pankaj.laxminarayan.bharadiya@intel.com
    Reviewed-by: Lyude Paul <lyude@redhat.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 0c4faba8ed28..4c5755633bfd 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -457,15 +457,9 @@ static void dm_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 	drm_connector_put(connector);
 }
 
-static void dm_dp_mst_register_connector(struct drm_connector *connector)
-{
-	drm_connector_register(connector);
-}
-
 static const struct drm_dp_mst_topology_cbs dm_mst_cbs = {
 	.add_connector = dm_dp_add_mst_connector,
 	.destroy_connector = dm_dp_destroy_mst_connector,
-	.register_connector = dm_dp_mst_register_connector
 };
 
 void amdgpu_dm_initialize_dp_connector(struct amdgpu_display_manager *dm,

commit d3bd37f587b4438d47751d0f1d5aaae3d39bd416
Merge: 60347451ddb0 2c523b344dfa
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Mar 11 07:27:21 2020 +1000

    Merge v5.6-rc5 into drm-next
    
    Requested my mripard for some misc patches that need this as a base.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit e6b11b43cd565cbf69dd67b85ff3dbed18b4d491
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Mon Feb 24 17:19:02 2020 -0500

    drm/amd/display: separate FEC capability from fec debug flag
    
    [why]
    FEC capability query should not be affected by debugging decision on
    whether to disable FEC. We should not determine if display supports FEC
    by checking debug option.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Ashley Thomas <Ashley.Thomas2@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 4837640530ad..cc1b52b72c0b 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -207,7 +207,7 @@ static bool validate_dsc_caps_on_connector(struct amdgpu_dm_connector *aconnecto
 
 	if (!dc_dsc_parse_dsc_dpcd(aconnector->dc_link->ctx->dc,
 				   dsc_caps, NULL,
-				   &dc_sink->sink_dsc_caps.dsc_dec_caps))
+				   &dc_sink->dsc_caps.dsc_dec_caps))
 		return false;
 
 	return true;
@@ -262,8 +262,8 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 
 #if defined(CONFIG_DRM_AMD_DC_DCN)
 			if (!validate_dsc_caps_on_connector(aconnector))
-				memset(&aconnector->dc_sink->sink_dsc_caps,
-				       0, sizeof(aconnector->dc_sink->sink_dsc_caps));
+				memset(&aconnector->dc_sink->dsc_caps,
+				       0, sizeof(aconnector->dc_sink->dsc_caps));
 #endif
 		}
 	}
@@ -550,7 +550,7 @@ static void set_dsc_configs_from_fairness_vars(struct dsc_mst_fairness_params *p
 		memset(&params[i].timing->dsc_cfg, 0, sizeof(params[i].timing->dsc_cfg));
 		if (vars[i].dsc_enabled && dc_dsc_compute_config(
 					params[i].sink->ctx->dc->res_pool->dscs[0],
-					&params[i].sink->sink_dsc_caps.dsc_dec_caps,
+					&params[i].sink->dsc_caps.dsc_dec_caps,
 					params[i].sink->ctx->dc->debug.dsc_min_slice_height_override,
 					0,
 					params[i].timing,
@@ -571,7 +571,7 @@ static int bpp_x16_from_pbn(struct dsc_mst_fairness_params param, int pbn)
 	kbps = div_u64((u64)pbn * 994 * 8 * 54, 64);
 	dc_dsc_compute_config(
 			param.sink->ctx->dc->res_pool->dscs[0],
-			&param.sink->sink_dsc_caps.dsc_dec_caps,
+			&param.sink->dsc_caps.dsc_dec_caps,
 			param.sink->ctx->dc->debug.dsc_min_slice_height_override,
 			(int) kbps, param.timing, &dsc_config);
 
@@ -768,14 +768,14 @@ static bool compute_mst_dsc_configs_for_link(struct drm_atomic_state *state,
 		params[count].sink = stream->sink;
 		aconnector = (struct amdgpu_dm_connector *)stream->dm_stream_context;
 		params[count].port = aconnector->port;
-		params[count].compression_possible = stream->sink->sink_dsc_caps.dsc_dec_caps.is_dsc_supported;
+		params[count].compression_possible = stream->sink->dsc_caps.dsc_dec_caps.is_dsc_supported;
 		dc_dsc_get_policy_for_timing(params[count].timing, &dsc_policy);
 		if (!dc_dsc_compute_bandwidth_range(
 				stream->sink->ctx->dc->res_pool->dscs[0],
 				stream->sink->ctx->dc->debug.dsc_min_slice_height_override,
 				dsc_policy.min_target_bpp,
 				dsc_policy.max_target_bpp,
-				&stream->sink->sink_dsc_caps.dsc_dec_caps,
+				&stream->sink->dsc_caps.dsc_dec_caps,
 				&stream->timing, &params[count].bw_range))
 			params[count].bw_range.stream_kbps = dc_bandwidth_in_kbps_from_timing(&stream->timing);
 
@@ -857,7 +857,7 @@ bool compute_mst_dsc_configs_for_state(struct drm_atomic_state *state,
 		if (!aconnector || !aconnector->dc_sink)
 			continue;
 
-		if (!aconnector->dc_sink->sink_dsc_caps.dsc_dec_caps.is_dsc_supported)
+		if (!aconnector->dc_sink->dsc_caps.dsc_dec_caps.is_dsc_supported)
 			continue;
 
 		if (computed_streams[i])

commit 439490f6cc9b4e4b0dd0eaf24e78ada781640a5d
Author: Pankaj Bharadiya <pankaj.laxminarayan.bharadiya@intel.com>
Date:   Thu Mar 5 17:34:30 2020 +0530

    drm/amdgpu: Remove drm_fb_helper_{add,remove}_one_connector calls
    
    drm_fb_helper_{add,remove}_one_connector() are dummy functions now
    and serve no purpose. Hence remove their calls.
    
    This is the preparatory step for removing the
    drm_fb_helper_{add,remove}_one_connector() functions from
    drm_fb_helper.h
    
    Signed-off-by: Pankaj Bharadiya <pankaj.laxminarayan.bharadiya@intel.com>
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200305120434.111091-4-pankaj.laxminarayan.bharadiya@intel.com

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 0ef0eeb16778..0c4faba8ed28 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -440,9 +440,6 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 static void dm_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 					struct drm_connector *connector)
 {
-	struct amdgpu_dm_connector *master = container_of(mgr, struct amdgpu_dm_connector, mst_mgr);
-	struct drm_device *dev = master->base.dev;
-	struct amdgpu_device *adev = dev->dev_private;
 	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
 
 	DRM_INFO("DM_MST: Disabling connector: %p [id: %d] [master: %p]\n",
@@ -457,21 +454,11 @@ static void dm_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 	}
 
 	drm_connector_unregister(connector);
-	if (adev->mode_info.rfbdev)
-		drm_fb_helper_remove_one_connector(&adev->mode_info.rfbdev->helper, connector);
 	drm_connector_put(connector);
 }
 
 static void dm_dp_mst_register_connector(struct drm_connector *connector)
 {
-	struct drm_device *dev = connector->dev;
-	struct amdgpu_device *adev = dev->dev_private;
-
-	if (adev->mode_info.rfbdev)
-		drm_fb_helper_add_one_connector(&adev->mode_info.rfbdev->helper, connector);
-	else
-		DRM_ERROR("adev->mode_info.rfbdev is NULL\n");
-
 	drm_connector_register(connector);
 }
 

commit 5ac7fd2f597b88ee81f4748ee50cab06192a8dc3
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Thu Feb 20 11:16:14 2020 -0500

    drm/amd/display: Clear link settings on MST disable connector
    
    [Why]
    If we have a single MST display and we disconnect it, we dont disable that
    link. This causes the old link settings to still exist
    
    Now on a replug for MST we think its a link loss and will try to reallocate
    mst payload which will fail, throwing warning below.
    
    [  129.374192] [drm] Failed to updateMST allocation table forpipe idx:0
    [  129.374206] ------------[ cut here ]------------
    [  129.374284] WARNING: CPU: 14 PID: 1710 at
    drivers/gpu/drm/amd/amdgpu/../dal-dev/dc/core/dc_link.c:3153
    dc_link_allocate_mst_payload+0x1f7/0x220 [amdgpu]
    
    [  129.374285] Modules linked in: amdgpu(OE) amd_iommu_v2 gpu_sched ttm
    drm_kms_helper drm fb_sys_fops syscopyarea sysfillrect sysimgblt
    binfmt_misc nls_iso8859_1 edac_mce_amd snd_hda_codec_realtek
    snd_hda_codec_generic ledtrig_audio kvm snd_hda_codec_hdmi snd_hda_intel
    snd_intel_nhlt snd_hda_codec irqbypass snd_hda_core snd_hwdep snd_pcm
    snd_seq_midi snd_seq_midi_event snd_rawmidi crct10dif_pclmul snd_seq
    crc32_pclmul ghash_clmulni_intel snd_seq_device snd_timer snd aesni_intel
    eeepc_wmi crypto_simd asus_wmi joydev cryptd sparse_keymap input_leds
    soundcore video glue_helper wmi_bmof mxm_wmi k10temp ccp mac_hid
    sch_fq_codel parport_pc ppdev lp parport ip_tables x_tables autofs4
    hid_generic usbhid hid igb i2c_algo_bit ahci dca i2c_piix4 libahci
    gpio_amdpt wmi gpio_generic
    
    [  129.374318] CPU: 14 PID: 1710 Comm: kworker/14:2 Tainted: G        W  OE     5.4.0-rc7bhawan+ #480
    [  129.374318] Hardware name: System manufacturer System Product Name/PRIME X370-PRO, BIOS 0515 03/30/2017
    [  129.374397] Workqueue: events dm_irq_work_func [amdgpu]
    [  129.374468] RIP: 0010:dc_link_allocate_mst_payload+0x1f7/0x220 [amdgpu]
    [  129.374470] Code: 52 20 e8 1c 63 ad f4 48 8b 5d d0 65 48 33 1c 25 28 00
    00 00 b8 01 00 00 00 75 16 48 8d 65 d8 5b 41 5c 41 5d 41 5e 41 5f 5d c3
    <0f> 0b e9 fa fe ff ff e8 ed 5b d6 f3 41 0f b6 b6 c4 02 00 00 48 c7
    [  129.374471] RSP: 0018:ffff9f9141e7fcc0 EFLAGS: 00010246
    [  129.374472] RAX: 0000000000000000 RBX: ffff91ef0762f800 RCX: 0000000000000000
    [  129.374473] RDX: 0000000000000005 RSI: ffffffffc0c4a988 RDI: 0000000000000004
    [  129.374474] RBP: ffff9f9141e7fd10 R08: 0000000000000005 R09: 0000000000000000
    [  129.374475] R10: 0000000000000002 R11: 0000000000000001 R12: ffff91eebd510c00
    [  129.374475] R13: ffff91eebd510e58 R14: ffff91ef052c01b8 R15: 0000000000000006
    [  129.374476] FS:  0000000000000000(0000) GS:ffff91ef0ef80000(0000) knlGS:0000000000000000
    [  129.374477] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  129.374478] CR2: 000055623ea01d50 CR3: 0000000408a8c000 CR4: 00000000003406e0
    [  129.374479] Call Trace:
    [  129.374550]  dc_link_reallocate_mst_payload+0x12e/0x150 [amdgpu]
    [  129.374617]  dc_link_handle_hpd_rx_irq+0x6d4/0x6e0 [amdgpu]
    [  129.374693]  handle_hpd_rx_irq+0x77/0x310 [amdgpu]
    [  129.374768]  dm_irq_work_func+0x53/0x70 [amdgpu]
    [  129.374774]  process_one_work+0x1fd/0x3f0
    [  129.374776]  worker_thread+0x255/0x410
    [  129.374778]  kthread+0x121/0x140
    [  129.374780]  ? process_one_work+0x3f0/0x3f0
    [  129.374781]  ? kthread_park+0x90/0x90
    [  129.374785]  ret_from_fork+0x22/0x40
    
    [How]
    when we disable MST we should clear the cur link settings (lane_count=0 is
    good enough). This will cause us to not reallocate payloads earlier than
    expected and not throw the warning
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 5672f7765919..da73161043d5 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -451,6 +451,7 @@ static void dm_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 					   aconnector->dc_sink);
 		dc_sink_release(aconnector->dc_sink);
 		aconnector->dc_sink = NULL;
+		aconnector->dc_link->cur_link_settings.lane_count = 0;
 	}
 
 	drm_connector_unregister(connector);

commit 6d0d6456084e21ece83b5265a3b26e8bb9077e31
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Thu Feb 20 11:16:14 2020 -0500

    drm/amd/display: Clear link settings on MST disable connector
    
    [Why]
    If we have a single MST display and we disconnect it, we dont disable that
    link. This causes the old link settings to still exist
    
    Now on a replug for MST we think its a link loss and will try to reallocate
    mst payload which will fail, throwing warning below.
    
    [  129.374192] [drm] Failed to updateMST allocation table forpipe idx:0
    [  129.374206] ------------[ cut here ]------------
    [  129.374284] WARNING: CPU: 14 PID: 1710 at
    drivers/gpu/drm/amd/amdgpu/../dal-dev/dc/core/dc_link.c:3153
    dc_link_allocate_mst_payload+0x1f7/0x220 [amdgpu]
    
    [  129.374285] Modules linked in: amdgpu(OE) amd_iommu_v2 gpu_sched ttm
    drm_kms_helper drm fb_sys_fops syscopyarea sysfillrect sysimgblt
    binfmt_misc nls_iso8859_1 edac_mce_amd snd_hda_codec_realtek
    snd_hda_codec_generic ledtrig_audio kvm snd_hda_codec_hdmi snd_hda_intel
    snd_intel_nhlt snd_hda_codec irqbypass snd_hda_core snd_hwdep snd_pcm
    snd_seq_midi snd_seq_midi_event snd_rawmidi crct10dif_pclmul snd_seq
    crc32_pclmul ghash_clmulni_intel snd_seq_device snd_timer snd aesni_intel
    eeepc_wmi crypto_simd asus_wmi joydev cryptd sparse_keymap input_leds
    soundcore video glue_helper wmi_bmof mxm_wmi k10temp ccp mac_hid
    sch_fq_codel parport_pc ppdev lp parport ip_tables x_tables autofs4
    hid_generic usbhid hid igb i2c_algo_bit ahci dca i2c_piix4 libahci
    gpio_amdpt wmi gpio_generic
    
    [  129.374318] CPU: 14 PID: 1710 Comm: kworker/14:2 Tainted: G        W  OE     5.4.0-rc7bhawan+ #480
    [  129.374318] Hardware name: System manufacturer System Product Name/PRIME X370-PRO, BIOS 0515 03/30/2017
    [  129.374397] Workqueue: events dm_irq_work_func [amdgpu]
    [  129.374468] RIP: 0010:dc_link_allocate_mst_payload+0x1f7/0x220 [amdgpu]
    [  129.374470] Code: 52 20 e8 1c 63 ad f4 48 8b 5d d0 65 48 33 1c 25 28 00
    00 00 b8 01 00 00 00 75 16 48 8d 65 d8 5b 41 5c 41 5d 41 5e 41 5f 5d c3
    <0f> 0b e9 fa fe ff ff e8 ed 5b d6 f3 41 0f b6 b6 c4 02 00 00 48 c7
    [  129.374471] RSP: 0018:ffff9f9141e7fcc0 EFLAGS: 00010246
    [  129.374472] RAX: 0000000000000000 RBX: ffff91ef0762f800 RCX: 0000000000000000
    [  129.374473] RDX: 0000000000000005 RSI: ffffffffc0c4a988 RDI: 0000000000000004
    [  129.374474] RBP: ffff9f9141e7fd10 R08: 0000000000000005 R09: 0000000000000000
    [  129.374475] R10: 0000000000000002 R11: 0000000000000001 R12: ffff91eebd510c00
    [  129.374475] R13: ffff91eebd510e58 R14: ffff91ef052c01b8 R15: 0000000000000006
    [  129.374476] FS:  0000000000000000(0000) GS:ffff91ef0ef80000(0000) knlGS:0000000000000000
    [  129.374477] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  129.374478] CR2: 000055623ea01d50 CR3: 0000000408a8c000 CR4: 00000000003406e0
    [  129.374479] Call Trace:
    [  129.374550]  dc_link_reallocate_mst_payload+0x12e/0x150 [amdgpu]
    [  129.374617]  dc_link_handle_hpd_rx_irq+0x6d4/0x6e0 [amdgpu]
    [  129.374693]  handle_hpd_rx_irq+0x77/0x310 [amdgpu]
    [  129.374768]  dm_irq_work_func+0x53/0x70 [amdgpu]
    [  129.374774]  process_one_work+0x1fd/0x3f0
    [  129.374776]  worker_thread+0x255/0x410
    [  129.374778]  kthread+0x121/0x140
    [  129.374780]  ? process_one_work+0x3f0/0x3f0
    [  129.374781]  ? kthread_park+0x90/0x90
    [  129.374785]  ret_from_fork+0x22/0x40
    
    [How]
    when we disable MST we should clear the cur link settings (lane_count=0 is
    good enough). This will cause us to not reallocate payloads earlier than
    expected and not throw the warning
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 0ef0eeb16778..4837640530ad 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -454,6 +454,7 @@ static void dm_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 					   aconnector->dc_sink);
 		dc_sink_release(aconnector->dc_sink);
 		aconnector->dc_sink = NULL;
+		aconnector->dc_link->cur_link_settings.lane_count = 0;
 	}
 
 	drm_connector_unregister(connector);

commit d95665c70844dd97aa3e900fd110cd1db68ede1a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Feb 25 13:39:44 2020 -0500

    drm/amdgpu/display: don't call drm_dp_mst_connector_late_register (v2)
    
    Nothing else calls it.  Not sure it's necessary.
    
    v2: remove unused port variable.
    
    Reviewed-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index d7a7dc0c256e..0ef0eeb16778 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -154,7 +154,6 @@ amdgpu_dm_mst_connector_late_register(struct drm_connector *connector)
 {
 	struct amdgpu_dm_connector *amdgpu_dm_connector =
 		to_amdgpu_dm_connector(connector);
-	struct drm_dp_mst_port *port = amdgpu_dm_connector->port;
 	int r;
 
 	amdgpu_dm_connector->dm_dp_aux.aux.dev = connector->kdev;
@@ -166,7 +165,7 @@ amdgpu_dm_mst_connector_late_register(struct drm_connector *connector)
 	connector_debugfs_init(amdgpu_dm_connector);
 #endif
 
-	return drm_dp_mst_connector_late_register(connector, port);
+	return r;
 }
 
 static void

commit 405a1f9090d1acec75aeb86569da60beca9fe68f
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Feb 5 10:18:04 2020 -0500

    drm/amdgpu/display: split dp connector registration (v4)
    
    Split into init and register functions to avoid a segfault
    in some configs when the load/unload callbacks are removed.
    
    v2:
    - add back accidently dropped has_aux setting
    - set dev in late_register
    
    v3:
    - fix dp cec ordering
    
    v4:
    - squash in kdev reference fix
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Tested-by: Thomas Zimmermann <tzimmermann@suse.de>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 3959c942c88b..d7a7dc0c256e 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -155,6 +155,12 @@ amdgpu_dm_mst_connector_late_register(struct drm_connector *connector)
 	struct amdgpu_dm_connector *amdgpu_dm_connector =
 		to_amdgpu_dm_connector(connector);
 	struct drm_dp_mst_port *port = amdgpu_dm_connector->port;
+	int r;
+
+	amdgpu_dm_connector->dm_dp_aux.aux.dev = connector->kdev;
+	r = drm_dp_aux_register(&amdgpu_dm_connector->dm_dp_aux.aux);
+	if (r)
+		return r;
 
 #if defined(CONFIG_DEBUG_FS)
 	connector_debugfs_init(amdgpu_dm_connector);
@@ -480,11 +486,10 @@ void amdgpu_dm_initialize_dp_connector(struct amdgpu_display_manager *dm,
 				       struct amdgpu_dm_connector *aconnector)
 {
 	aconnector->dm_dp_aux.aux.name = "dmdc";
-	aconnector->dm_dp_aux.aux.dev = aconnector->base.kdev;
 	aconnector->dm_dp_aux.aux.transfer = dm_dp_aux_transfer;
 	aconnector->dm_dp_aux.ddc_service = aconnector->dc_link->ddc;
 
-	drm_dp_aux_register(&aconnector->dm_dp_aux.aux);
+	drm_dp_aux_init(&aconnector->dm_dp_aux.aux);
 	drm_dp_cec_register_connector(&aconnector->dm_dp_aux.aux,
 				      &aconnector->base);
 

commit 7b99330c8f084abf4957a7abb7b2061be035b2a2
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Feb 4 17:07:39 2020 -0500

    drm/amd/display: move dpcd debugfs members setup
    
    Into the function that creates the debugfs files rather
    than setting them explicitly in the callers.
    
    Tested-by: Thomas Zimmermann <tzimmermann@suse.de>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Christian KÃ¶nig <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 5672f7765919..3959c942c88b 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -158,8 +158,6 @@ amdgpu_dm_mst_connector_late_register(struct drm_connector *connector)
 
 #if defined(CONFIG_DEBUG_FS)
 	connector_debugfs_init(amdgpu_dm_connector);
-	amdgpu_dm_connector->debugfs_dpcd_address = 0;
-	amdgpu_dm_connector->debugfs_dpcd_size = 0;
 #endif
 
 	return drm_dp_mst_connector_late_register(connector, port);

commit 47eed65178e8fa626097648eb90cb6b31952efbc
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Fri Jan 31 09:51:23 2020 -0500

    drm/amd/display: Fix a typo when computing dsc configuration
    
    [why]
    Remove a backslash symbol accidentally left in increase bpp function
    when computing mst dsc configuration.
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Zhan Liu <zhan.liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 96b391e4b3e7..5672f7765919 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -632,7 +632,7 @@ static void increase_dsc_bpp(struct drm_atomic_state *state,
 			if (drm_dp_atomic_find_vcpi_slots(state,
 							  params[next_index].port->mgr,
 							  params[next_index].port,
-							  vars[next_index].pbn,\
+							  vars[next_index].pbn,
 							  dm_mst_get_pbn_divider(dc_link)) < 0)
 				return;
 			if (!drm_dp_mst_atomic_check(state)) {

commit 1fc636c9b3b251d065dbf04eb2293fb6de9fdcf9
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Mon Jan 13 08:15:19 2020 -0500

    drm/amdgpu/display: Use u64 divide macro for round up division
    
    [why]
    Fix compilation warnings on i386 architecture:
    undefined reference to `__udivdi3'
    [how]
    Switch DIV_ROUND_UP to DIV64_U64_ROUND_UP
    
    Reported-by: Randy Dunlap <rdunlap@infradead.org>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 52fb207393ef..96b391e4b3e7 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -534,7 +534,7 @@ static int kbps_to_peak_pbn(int kbps)
 
 	peak_kbps *= 1006;
 	peak_kbps = div_u64(peak_kbps, 1000);
-	return (int) DIV_ROUND_UP(peak_kbps * 64, (54 * 8 * 1000));
+	return (int) DIV64_U64_ROUND_UP(peak_kbps * 64, (54 * 8 * 1000));
 }
 
 static void set_dsc_configs_from_fairness_vars(struct dsc_mst_fairness_params *params,

commit 485b747ea6ecf491bf07c69a4ea36c0ccf3c8435
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Fri Jan 10 14:31:52 2020 -0500

    drm/amd/display: Fix compilation warnings on i386
    
    [why]
    Compilation error "undefined reference to `__udivdi3'" was
    thrown on i386 architecture.
    
    [how]
    Use div_u64 for unsigned long division instead of a divide operator.
    
    Reported-by: Randy Dunlap <rdunlap@infradead.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 5a476028ee37..52fb207393ef 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -533,7 +533,7 @@ static int kbps_to_peak_pbn(int kbps)
 	u64 peak_kbps = kbps;
 
 	peak_kbps *= 1006;
-	peak_kbps /= 1000;
+	peak_kbps = div_u64(peak_kbps, 1000);
 	return (int) DIV_ROUND_UP(peak_kbps * 64, (54 * 8 * 1000));
 }
 
@@ -565,7 +565,7 @@ static int bpp_x16_from_pbn(struct dsc_mst_fairness_params param, int pbn)
 	struct dc_dsc_config dsc_config;
 	u64 kbps;
 
-	kbps = (u64)pbn * 994 * 8 * 54 / 64;
+	kbps = div_u64((u64)pbn * 994 * 8 * 54, 64);
 	dc_dsc_compute_config(
 			param.sink->ctx->dc->res_pool->dscs[0],
 			&param.sink->sink_dsc_caps.dsc_dec_caps,

commit d9fe1a4c560b70547e3f47520310f6d57d4d1626
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jan 7 23:04:04 2020 -0500

    drm/amdgpu/display: protect new DSC code with CONFIG_DRM_AMD_DC_DCN
    
    Otherwise we get undefined symbols.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 7911c5dac424..5a476028ee37 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -42,7 +42,9 @@
 #endif
 
 
+#if defined(CONFIG_DRM_AMD_DC_DCN)
 #include "dc/dcn20/dcn20_resource.h"
+#endif
 
 /* #define TRACE_DPCD */
 
@@ -185,6 +187,7 @@ static const struct drm_connector_funcs dm_dp_mst_connector_funcs = {
 	.early_unregister = amdgpu_dm_mst_connector_early_unregister,
 };
 
+#if defined(CONFIG_DRM_AMD_DC_DCN)
 static bool validate_dsc_caps_on_connector(struct amdgpu_dm_connector *aconnector)
 {
 	struct dc_sink *dc_sink = aconnector->dc_sink;
@@ -206,6 +209,7 @@ static bool validate_dsc_caps_on_connector(struct amdgpu_dm_connector *aconnecto
 
 	return true;
 }
+#endif
 
 static int dm_dp_mst_get_modes(struct drm_connector *connector)
 {
@@ -253,9 +257,11 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 			amdgpu_dm_update_freesync_caps(
 					connector, aconnector->edid);
 
+#if defined(CONFIG_DRM_AMD_DC_DCN)
 			if (!validate_dsc_caps_on_connector(aconnector))
 				memset(&aconnector->dc_sink->sink_dsc_caps,
 				       0, sizeof(aconnector->dc_sink->sink_dsc_caps));
+#endif
 		}
 	}
 
@@ -506,6 +512,8 @@ int dm_mst_get_pbn_divider(struct dc_link *link)
 			dc_link_get_link_cap(link)) / (8 * 1000 * 54);
 }
 
+#if defined(CONFIG_DRM_AMD_DC_DCN)
+
 struct dsc_mst_fairness_params {
 	struct dc_crtc_timing *timing;
 	struct dc_sink *sink;
@@ -874,3 +882,5 @@ bool compute_mst_dsc_configs_for_state(struct drm_atomic_state *state,
 
 	return true;
 }
+
+#endif

commit 34d95c3d5f687e4de8266bcdceb8b4694fe7105a
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Tue Jan 7 11:25:54 2020 -0500

    drm/amd/display: Check return value of drm helper
    
    If driver fails to update update VCPI allocation during
    compute_mst_dsc_configs_for_state - fail the function
    by return early.
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 35c8b1469f4c..7911c5dac424 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -621,37 +621,41 @@ static void increase_dsc_bpp(struct drm_atomic_state *state,
 
 		if (initial_slack[next_index] > fair_pbn_alloc) {
 			vars[next_index].pbn += fair_pbn_alloc;
-			drm_dp_atomic_find_vcpi_slots(state,
-						      params[next_index].port->mgr,
-						      params[next_index].port,
-						      vars[next_index].pbn,
-						      dm_mst_get_pbn_divider(dc_link));
+			if (drm_dp_atomic_find_vcpi_slots(state,
+							  params[next_index].port->mgr,
+							  params[next_index].port,
+							  vars[next_index].pbn,\
+							  dm_mst_get_pbn_divider(dc_link)) < 0)
+				return;
 			if (!drm_dp_mst_atomic_check(state)) {
 				vars[next_index].bpp_x16 = bpp_x16_from_pbn(params[next_index], vars[next_index].pbn);
 			} else {
 				vars[next_index].pbn -= fair_pbn_alloc;
-				drm_dp_atomic_find_vcpi_slots(state,
-						      params[next_index].port->mgr,
-						      params[next_index].port,
-						      vars[next_index].pbn,
-						      dm_mst_get_pbn_divider(dc_link));
+				if (drm_dp_atomic_find_vcpi_slots(state,
+								  params[next_index].port->mgr,
+								  params[next_index].port,
+								  vars[next_index].pbn,
+								  dm_mst_get_pbn_divider(dc_link)) < 0)
+					return;
 			}
 		} else {
 			vars[next_index].pbn += initial_slack[next_index];
-			drm_dp_atomic_find_vcpi_slots(state,
-						      params[next_index].port->mgr,
-						      params[next_index].port,
-						      vars[next_index].pbn,
-						      dm_mst_get_pbn_divider(dc_link));
+			if (drm_dp_atomic_find_vcpi_slots(state,
+							  params[next_index].port->mgr,
+							  params[next_index].port,
+							  vars[next_index].pbn,
+							  dm_mst_get_pbn_divider(dc_link)) < 0)
+				return;
 			if (!drm_dp_mst_atomic_check(state)) {
 				vars[next_index].bpp_x16 = params[next_index].bw_range.max_target_bpp_x16;
 			} else {
 				vars[next_index].pbn -= initial_slack[next_index];
-				drm_dp_atomic_find_vcpi_slots(state,
-						      params[next_index].port->mgr,
-						      params[next_index].port,
-						      vars[next_index].pbn,
-						      dm_mst_get_pbn_divider(dc_link));
+				if (drm_dp_atomic_find_vcpi_slots(state,
+								  params[next_index].port->mgr,
+								  params[next_index].port,
+								  vars[next_index].pbn,
+								  dm_mst_get_pbn_divider(dc_link)) < 0)
+					return;
 			}
 		}
 
@@ -700,22 +704,24 @@ static void try_disable_dsc(struct drm_atomic_state *state,
 			break;
 
 		vars[next_index].pbn = kbps_to_peak_pbn(params[next_index].bw_range.stream_kbps);
-		drm_dp_atomic_find_vcpi_slots(state,
-					      params[next_index].port->mgr,
-					      params[next_index].port,
-					      vars[next_index].pbn,
-					      0);
+		if (drm_dp_atomic_find_vcpi_slots(state,
+						  params[next_index].port->mgr,
+						  params[next_index].port,
+						  vars[next_index].pbn,
+						  0) < 0)
+			return;
 
 		if (!drm_dp_mst_atomic_check(state)) {
 			vars[next_index].dsc_enabled = false;
 			vars[next_index].bpp_x16 = 0;
 		} else {
 			vars[next_index].pbn = kbps_to_peak_pbn(params[next_index].bw_range.max_kbps);
-			drm_dp_atomic_find_vcpi_slots(state,
-					      params[next_index].port->mgr,
-					      params[next_index].port,
-					      vars[next_index].pbn,
-					      dm_mst_get_pbn_divider(dc_link));
+			if (drm_dp_atomic_find_vcpi_slots(state,
+							  params[next_index].port->mgr,
+							  params[next_index].port,
+							  vars[next_index].pbn,
+							  dm_mst_get_pbn_divider(dc_link)) < 0)
+				return;
 		}
 
 		tried[next_index] = true;
@@ -769,11 +775,12 @@ static bool compute_mst_dsc_configs_for_link(struct drm_atomic_state *state,
 		vars[i].pbn = kbps_to_peak_pbn(params[i].bw_range.stream_kbps);
 		vars[i].dsc_enabled = false;
 		vars[i].bpp_x16 = 0;
-		drm_dp_atomic_find_vcpi_slots(state,
-					      params[i].port->mgr,
-					      params[i].port,
-					      vars[i].pbn,
-					      0);
+		if (drm_dp_atomic_find_vcpi_slots(state,
+						 params[i].port->mgr,
+						 params[i].port,
+						 vars[i].pbn,
+						 0) < 0)
+			return false;
 	}
 	if (!drm_dp_mst_atomic_check(state)) {
 		set_dsc_configs_from_fairness_vars(params, vars, count);
@@ -786,20 +793,22 @@ static bool compute_mst_dsc_configs_for_link(struct drm_atomic_state *state,
 			vars[i].pbn = kbps_to_peak_pbn(params[i].bw_range.min_kbps);
 			vars[i].dsc_enabled = true;
 			vars[i].bpp_x16 = params[i].bw_range.min_target_bpp_x16;
-			drm_dp_atomic_find_vcpi_slots(state,
-					      params[i].port->mgr,
-					      params[i].port,
-					      vars[i].pbn,
-					      dm_mst_get_pbn_divider(dc_link));
+			if (drm_dp_atomic_find_vcpi_slots(state,
+							  params[i].port->mgr,
+							  params[i].port,
+							  vars[i].pbn,
+							  dm_mst_get_pbn_divider(dc_link)) < 0)
+				return false;
 		} else {
 			vars[i].pbn = kbps_to_peak_pbn(params[i].bw_range.stream_kbps);
 			vars[i].dsc_enabled = false;
 			vars[i].bpp_x16 = 0;
-			drm_dp_atomic_find_vcpi_slots(state,
-					      params[i].port->mgr,
-					      params[i].port,
-					      vars[i].pbn,
-					      0);
+			if (drm_dp_atomic_find_vcpi_slots(state,
+							  params[i].port->mgr,
+							  params[i].port,
+							  vars[i].pbn,
+							  0) < 0)
+				return false;
 		}
 	}
 	if (drm_dp_mst_atomic_check(state))

commit 8c20a1ed9b4ff25c67f6c1771a4e1195b5221cce
Author: David Francis <David.Francis@amd.com>
Date:   Wed Jun 19 14:49:19 2019 -0400

    drm/amd/display: MST DSC compute fair share
    
    If there is limited link bandwidth on a MST network,
    it must be divided fairly between the streams on that network
    
    Implement an algorithm to determine the correct DSC config
    for each stream
    
    The algorithm:
    This
         [                   ]          ( )
    represents the range of bandwidths possible for a given stream.
    The [] area represents the range of DSC configs, and the ()
    represents no DSC. The bandwidth used increases from left to right.
    
    First, try disabling DSC on all streams
         [                  ]          (|)
         [                     ]            (|)
    Check this against the bandwidth limits of the link and each branch
    (including each endpoint). If it passes, the job is done
    
    Second, try maximum DSC compression on all streams
    that support DSC
         [|         ]        ( )
         [|                ]         ( )
    If this does not pass, then enabling this combination of streams
    is impossible
    
    Otherwise, divide the remaining bandwidth evenly amongst the streams
         [        |  ]         ( )
         [        |      ]        ( )
    
    If one or more of the streams reach minimum compression, evenly
    divide the reamining bandwidth amongst the remaining streams
         [    |] ( )
         [       |]   ( )
         [                 |   ]               ( )
         [                 |      ]                  ( )
    
    If all streams can reach minimum compression, disable compression
    greedily
         [      |]  ( )
         [        |]    ( )
         [                 ]                                (|)
    
    Perform this algorithm on each full update, on each MST link
    with at least one DSC stream on it
    
    After the configs are computed, call
    dcn20_add_dsc_to_stream_resource on each stream with DSC enabled.
    It is only after all streams are created that we can know which
    of them will need DSC.
    
    Do all of this at the end of amdgpu atomic check.  If it fails,
    fail check; This combination of timings cannot be supported.
    
    v2: Use drm_dp_mst_atomic_check to validate bw for certain dsc
    configurations
    
    v3: Use dc_dsc_policy structure to get min and max bpp rate
    for DSC configuration
    
    Acked-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Signed-off-by: David Francis <David.Francis@amd.com>
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 9c6c2815c7a1..35c8b1469f4c 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -40,6 +40,10 @@
 #if defined(CONFIG_DEBUG_FS)
 #include "amdgpu_dm_debugfs.h"
 #endif
+
+
+#include "dc/dcn20/dcn20_resource.h"
+
 /* #define TRACE_DPCD */
 
 #ifdef TRACE_DPCD
@@ -501,3 +505,363 @@ int dm_mst_get_pbn_divider(struct dc_link *link)
 	return dc_link_bandwidth_kbps(link,
 			dc_link_get_link_cap(link)) / (8 * 1000 * 54);
 }
+
+struct dsc_mst_fairness_params {
+	struct dc_crtc_timing *timing;
+	struct dc_sink *sink;
+	struct dc_dsc_bw_range bw_range;
+	bool compression_possible;
+	struct drm_dp_mst_port *port;
+};
+
+struct dsc_mst_fairness_vars {
+	int pbn;
+	bool dsc_enabled;
+	int bpp_x16;
+};
+
+static int kbps_to_peak_pbn(int kbps)
+{
+	u64 peak_kbps = kbps;
+
+	peak_kbps *= 1006;
+	peak_kbps /= 1000;
+	return (int) DIV_ROUND_UP(peak_kbps * 64, (54 * 8 * 1000));
+}
+
+static void set_dsc_configs_from_fairness_vars(struct dsc_mst_fairness_params *params,
+		struct dsc_mst_fairness_vars *vars,
+		int count)
+{
+	int i;
+
+	for (i = 0; i < count; i++) {
+		memset(&params[i].timing->dsc_cfg, 0, sizeof(params[i].timing->dsc_cfg));
+		if (vars[i].dsc_enabled && dc_dsc_compute_config(
+					params[i].sink->ctx->dc->res_pool->dscs[0],
+					&params[i].sink->sink_dsc_caps.dsc_dec_caps,
+					params[i].sink->ctx->dc->debug.dsc_min_slice_height_override,
+					0,
+					params[i].timing,
+					&params[i].timing->dsc_cfg)) {
+			params[i].timing->flags.DSC = 1;
+			params[i].timing->dsc_cfg.bits_per_pixel = vars[i].bpp_x16;
+		} else {
+			params[i].timing->flags.DSC = 0;
+		}
+	}
+}
+
+static int bpp_x16_from_pbn(struct dsc_mst_fairness_params param, int pbn)
+{
+	struct dc_dsc_config dsc_config;
+	u64 kbps;
+
+	kbps = (u64)pbn * 994 * 8 * 54 / 64;
+	dc_dsc_compute_config(
+			param.sink->ctx->dc->res_pool->dscs[0],
+			&param.sink->sink_dsc_caps.dsc_dec_caps,
+			param.sink->ctx->dc->debug.dsc_min_slice_height_override,
+			(int) kbps, param.timing, &dsc_config);
+
+	return dsc_config.bits_per_pixel;
+}
+
+static void increase_dsc_bpp(struct drm_atomic_state *state,
+			     struct dc_link *dc_link,
+			     struct dsc_mst_fairness_params *params,
+			     struct dsc_mst_fairness_vars *vars,
+			     int count)
+{
+	int i;
+	bool bpp_increased[MAX_PIPES];
+	int initial_slack[MAX_PIPES];
+	int min_initial_slack;
+	int next_index;
+	int remaining_to_increase = 0;
+	int pbn_per_timeslot;
+	int link_timeslots_used;
+	int fair_pbn_alloc;
+
+	for (i = 0; i < count; i++) {
+		if (vars[i].dsc_enabled) {
+			initial_slack[i] = kbps_to_peak_pbn(params[i].bw_range.max_kbps) - vars[i].pbn;
+			bpp_increased[i] = false;
+			remaining_to_increase += 1;
+		} else {
+			initial_slack[i] = 0;
+			bpp_increased[i] = true;
+		}
+	}
+
+	pbn_per_timeslot = dc_link_bandwidth_kbps(dc_link,
+			dc_link_get_link_cap(dc_link)) / (8 * 1000 * 54);
+
+	while (remaining_to_increase) {
+		next_index = -1;
+		min_initial_slack = -1;
+		for (i = 0; i < count; i++) {
+			if (!bpp_increased[i]) {
+				if (min_initial_slack == -1 || min_initial_slack > initial_slack[i]) {
+					min_initial_slack = initial_slack[i];
+					next_index = i;
+				}
+			}
+		}
+
+		if (next_index == -1)
+			break;
+
+		link_timeslots_used = 0;
+
+		for (i = 0; i < count; i++)
+			link_timeslots_used += DIV_ROUND_UP(vars[i].pbn, pbn_per_timeslot);
+
+		fair_pbn_alloc = (63 - link_timeslots_used) / remaining_to_increase * pbn_per_timeslot;
+
+		if (initial_slack[next_index] > fair_pbn_alloc) {
+			vars[next_index].pbn += fair_pbn_alloc;
+			drm_dp_atomic_find_vcpi_slots(state,
+						      params[next_index].port->mgr,
+						      params[next_index].port,
+						      vars[next_index].pbn,
+						      dm_mst_get_pbn_divider(dc_link));
+			if (!drm_dp_mst_atomic_check(state)) {
+				vars[next_index].bpp_x16 = bpp_x16_from_pbn(params[next_index], vars[next_index].pbn);
+			} else {
+				vars[next_index].pbn -= fair_pbn_alloc;
+				drm_dp_atomic_find_vcpi_slots(state,
+						      params[next_index].port->mgr,
+						      params[next_index].port,
+						      vars[next_index].pbn,
+						      dm_mst_get_pbn_divider(dc_link));
+			}
+		} else {
+			vars[next_index].pbn += initial_slack[next_index];
+			drm_dp_atomic_find_vcpi_slots(state,
+						      params[next_index].port->mgr,
+						      params[next_index].port,
+						      vars[next_index].pbn,
+						      dm_mst_get_pbn_divider(dc_link));
+			if (!drm_dp_mst_atomic_check(state)) {
+				vars[next_index].bpp_x16 = params[next_index].bw_range.max_target_bpp_x16;
+			} else {
+				vars[next_index].pbn -= initial_slack[next_index];
+				drm_dp_atomic_find_vcpi_slots(state,
+						      params[next_index].port->mgr,
+						      params[next_index].port,
+						      vars[next_index].pbn,
+						      dm_mst_get_pbn_divider(dc_link));
+			}
+		}
+
+		bpp_increased[next_index] = true;
+		remaining_to_increase--;
+	}
+}
+
+static void try_disable_dsc(struct drm_atomic_state *state,
+			    struct dc_link *dc_link,
+			    struct dsc_mst_fairness_params *params,
+			    struct dsc_mst_fairness_vars *vars,
+			    int count)
+{
+	int i;
+	bool tried[MAX_PIPES];
+	int kbps_increase[MAX_PIPES];
+	int max_kbps_increase;
+	int next_index;
+	int remaining_to_try = 0;
+
+	for (i = 0; i < count; i++) {
+		if (vars[i].dsc_enabled && vars[i].bpp_x16 == params[i].bw_range.max_target_bpp_x16) {
+			kbps_increase[i] = params[i].bw_range.stream_kbps - params[i].bw_range.max_kbps;
+			tried[i] = false;
+			remaining_to_try += 1;
+		} else {
+			kbps_increase[i] = 0;
+			tried[i] = true;
+		}
+	}
+
+	while (remaining_to_try) {
+		next_index = -1;
+		max_kbps_increase = -1;
+		for (i = 0; i < count; i++) {
+			if (!tried[i]) {
+				if (max_kbps_increase == -1 || max_kbps_increase < kbps_increase[i]) {
+					max_kbps_increase = kbps_increase[i];
+					next_index = i;
+				}
+			}
+		}
+
+		if (next_index == -1)
+			break;
+
+		vars[next_index].pbn = kbps_to_peak_pbn(params[next_index].bw_range.stream_kbps);
+		drm_dp_atomic_find_vcpi_slots(state,
+					      params[next_index].port->mgr,
+					      params[next_index].port,
+					      vars[next_index].pbn,
+					      0);
+
+		if (!drm_dp_mst_atomic_check(state)) {
+			vars[next_index].dsc_enabled = false;
+			vars[next_index].bpp_x16 = 0;
+		} else {
+			vars[next_index].pbn = kbps_to_peak_pbn(params[next_index].bw_range.max_kbps);
+			drm_dp_atomic_find_vcpi_slots(state,
+					      params[next_index].port->mgr,
+					      params[next_index].port,
+					      vars[next_index].pbn,
+					      dm_mst_get_pbn_divider(dc_link));
+		}
+
+		tried[next_index] = true;
+		remaining_to_try--;
+	}
+}
+
+static bool compute_mst_dsc_configs_for_link(struct drm_atomic_state *state,
+					     struct dc_state *dc_state,
+					     struct dc_link *dc_link)
+{
+	int i;
+	struct dc_stream_state *stream;
+	struct dsc_mst_fairness_params params[MAX_PIPES];
+	struct dsc_mst_fairness_vars vars[MAX_PIPES];
+	struct amdgpu_dm_connector *aconnector;
+	int count = 0;
+
+	memset(params, 0, sizeof(params));
+
+	/* Set up params */
+	for (i = 0; i < dc_state->stream_count; i++) {
+		struct dc_dsc_policy dsc_policy = {0};
+
+		stream = dc_state->streams[i];
+
+		if (stream->link != dc_link)
+			continue;
+
+		stream->timing.flags.DSC = 0;
+
+		params[count].timing = &stream->timing;
+		params[count].sink = stream->sink;
+		aconnector = (struct amdgpu_dm_connector *)stream->dm_stream_context;
+		params[count].port = aconnector->port;
+		params[count].compression_possible = stream->sink->sink_dsc_caps.dsc_dec_caps.is_dsc_supported;
+		dc_dsc_get_policy_for_timing(params[count].timing, &dsc_policy);
+		if (!dc_dsc_compute_bandwidth_range(
+				stream->sink->ctx->dc->res_pool->dscs[0],
+				stream->sink->ctx->dc->debug.dsc_min_slice_height_override,
+				dsc_policy.min_target_bpp,
+				dsc_policy.max_target_bpp,
+				&stream->sink->sink_dsc_caps.dsc_dec_caps,
+				&stream->timing, &params[count].bw_range))
+			params[count].bw_range.stream_kbps = dc_bandwidth_in_kbps_from_timing(&stream->timing);
+
+		count++;
+	}
+	/* Try no compression */
+	for (i = 0; i < count; i++) {
+		vars[i].pbn = kbps_to_peak_pbn(params[i].bw_range.stream_kbps);
+		vars[i].dsc_enabled = false;
+		vars[i].bpp_x16 = 0;
+		drm_dp_atomic_find_vcpi_slots(state,
+					      params[i].port->mgr,
+					      params[i].port,
+					      vars[i].pbn,
+					      0);
+	}
+	if (!drm_dp_mst_atomic_check(state)) {
+		set_dsc_configs_from_fairness_vars(params, vars, count);
+		return true;
+	}
+
+	/* Try max compression */
+	for (i = 0; i < count; i++) {
+		if (params[i].compression_possible) {
+			vars[i].pbn = kbps_to_peak_pbn(params[i].bw_range.min_kbps);
+			vars[i].dsc_enabled = true;
+			vars[i].bpp_x16 = params[i].bw_range.min_target_bpp_x16;
+			drm_dp_atomic_find_vcpi_slots(state,
+					      params[i].port->mgr,
+					      params[i].port,
+					      vars[i].pbn,
+					      dm_mst_get_pbn_divider(dc_link));
+		} else {
+			vars[i].pbn = kbps_to_peak_pbn(params[i].bw_range.stream_kbps);
+			vars[i].dsc_enabled = false;
+			vars[i].bpp_x16 = 0;
+			drm_dp_atomic_find_vcpi_slots(state,
+					      params[i].port->mgr,
+					      params[i].port,
+					      vars[i].pbn,
+					      0);
+		}
+	}
+	if (drm_dp_mst_atomic_check(state))
+		return false;
+
+	/* Optimize degree of compression */
+	increase_dsc_bpp(state, dc_link, params, vars, count);
+
+	try_disable_dsc(state, dc_link, params, vars, count);
+
+	set_dsc_configs_from_fairness_vars(params, vars, count);
+
+	return true;
+}
+
+bool compute_mst_dsc_configs_for_state(struct drm_atomic_state *state,
+				       struct dc_state *dc_state)
+{
+	int i, j;
+	struct dc_stream_state *stream;
+	bool computed_streams[MAX_PIPES];
+	struct amdgpu_dm_connector *aconnector;
+
+	for (i = 0; i < dc_state->stream_count; i++)
+		computed_streams[i] = false;
+
+	for (i = 0; i < dc_state->stream_count; i++) {
+		stream = dc_state->streams[i];
+
+		if (stream->signal != SIGNAL_TYPE_DISPLAY_PORT_MST)
+			continue;
+
+		aconnector = (struct amdgpu_dm_connector *)stream->dm_stream_context;
+
+		if (!aconnector || !aconnector->dc_sink)
+			continue;
+
+		if (!aconnector->dc_sink->sink_dsc_caps.dsc_dec_caps.is_dsc_supported)
+			continue;
+
+		if (computed_streams[i])
+			continue;
+
+		mutex_lock(&aconnector->mst_mgr.lock);
+		if (!compute_mst_dsc_configs_for_link(state, dc_state, stream->link)) {
+			mutex_unlock(&aconnector->mst_mgr.lock);
+			return false;
+		}
+		mutex_unlock(&aconnector->mst_mgr.lock);
+
+		for (j = 0; j < dc_state->stream_count; j++) {
+			if (dc_state->streams[j]->link == stream->link)
+				computed_streams[j] = true;
+		}
+	}
+
+	for (i = 0; i < dc_state->stream_count; i++) {
+		stream = dc_state->streams[i];
+
+		if (stream->timing.flags.DSC == 1)
+			dcn20_add_dsc_to_stream_resource(stream->ctx->dc, dc_state, stream);
+	}
+
+	return true;
+}

commit dcade880e342407fb76bdf4529b886c3ebedc6b3
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Sat Nov 16 15:45:37 2019 -0500

    drm/amd/display: Add PBN per slot calculation for DSC
    
    [why]
    Need to calculate VCPI slots differently for DSC
    to take in account current link rate, link count
    and FEC.
    [how]
    Add helper to get pbn_div from dc_link
    
    Acked-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 6b33a01dbba2..9c6c2815c7a1 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -493,3 +493,11 @@ void amdgpu_dm_initialize_dp_connector(struct amdgpu_display_manager *dm,
 		aconnector->connector_id);
 }
 
+int dm_mst_get_pbn_divider(struct dc_link *link)
+{
+	if (!link)
+		return 0;
+
+	return dc_link_bandwidth_kbps(link,
+			dc_link_get_link_cap(link)) / (8 * 1000 * 54);
+}

commit ec0ca697dd0e573657d7070d1d392faba44acd4d
Author: David Francis <David.Francis@amd.com>
Date:   Wed Jun 19 14:47:33 2019 -0400

    drm/amd/display: Validate DSC caps on MST endpoints
    
    During MST mode enumeration, if a new dc_sink is created,
    populate it with dsc caps as appropriate.
    
    Use drm_dp_mst_dsc_aux_for_port to get the raw caps,
    then parse them onto dc_sink with dc_dsc_parse_dsc_dpcd.
    
    Reviewed-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Signed-off-by: David Francis <David.Francis@amd.com>
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 81367c869134..6b33a01dbba2 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -25,6 +25,7 @@
 
 #include <linux/version.h>
 #include <drm/drm_atomic_helper.h>
+#include <drm/drm_dp_mst_helper.h>
 #include "dm_services.h"
 #include "amdgpu.h"
 #include "amdgpu_dm.h"
@@ -180,6 +181,28 @@ static const struct drm_connector_funcs dm_dp_mst_connector_funcs = {
 	.early_unregister = amdgpu_dm_mst_connector_early_unregister,
 };
 
+static bool validate_dsc_caps_on_connector(struct amdgpu_dm_connector *aconnector)
+{
+	struct dc_sink *dc_sink = aconnector->dc_sink;
+	struct drm_dp_mst_port *port = aconnector->port;
+	u8 dsc_caps[16] = { 0 };
+
+	aconnector->dsc_aux = drm_dp_mst_dsc_aux_for_port(port);
+
+	if (!aconnector->dsc_aux)
+		return false;
+
+	if (drm_dp_dpcd_read(aconnector->dsc_aux, DP_DSC_SUPPORT, dsc_caps, 16) < 0)
+		return false;
+
+	if (!dc_dsc_parse_dsc_dpcd(aconnector->dc_link->ctx->dc,
+				   dsc_caps, NULL,
+				   &dc_sink->sink_dsc_caps.dsc_dec_caps))
+		return false;
+
+	return true;
+}
+
 static int dm_dp_mst_get_modes(struct drm_connector *connector)
 {
 	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
@@ -222,10 +245,14 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 		/* dc_link_add_remote_sink returns a new reference */
 		aconnector->dc_sink = dc_sink;
 
-		if (aconnector->dc_sink)
+		if (aconnector->dc_sink) {
 			amdgpu_dm_update_freesync_caps(
 					connector, aconnector->edid);
 
+			if (!validate_dsc_caps_on_connector(aconnector))
+				memset(&aconnector->dc_sink->sink_dsc_caps,
+				       0, sizeof(aconnector->dc_sink->sink_dsc_caps));
+		}
 	}
 
 	drm_connector_update_edid_property(

commit 5111195ad61791bb22d8650ad7431344d9a00036
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Tue Nov 12 09:13:20 2019 -0500

    drm/amd/display: Fix coding error in connector atomic check
    
    [why]
    For MST connector atomic check we have to check a new CRTC state
    instead of an old one, when checking if CRTC is disabled to
    release VCPI slots allocated.
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 205531ca686f..81367c869134 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -273,7 +273,7 @@ static int dm_dp_mst_atomic_check(struct drm_connector *connector,
 		return 0;
 
 	if (new_conn_state->crtc) {
-		new_crtc_state = drm_atomic_get_old_crtc_state(state, new_conn_state->crtc);
+		new_crtc_state = drm_atomic_get_new_crtc_state(state, new_conn_state->crtc);
 		if (!new_crtc_state ||
 		    !drm_atomic_crtc_needs_modeset(new_crtc_state) ||
 		    new_crtc_state->enable)

commit 03527f0d0056f5605863d894615a0533afc34c7c
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Thu Oct 31 16:09:01 2019 -0400

    drm/amd/display: Fix debugfs on MST connectors
    
    [why]
    Previous patch allowed to initialize debugfs entries on both MST
    and SST connectors, but MST connectors get registered much later
    which exposed an issue of debugfs entries being initialized in the
    same folder.
    
    [how]
    Return SST debugfs entries' initialization back to where it was.
    For MST connectors we should initialize debugfs entries in connector
    register function after the connector is registered.
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index ba508a897263..205531ca686f 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -36,7 +36,9 @@
 #include "dc_link_ddc.h"
 
 #include "i2caux_interface.h"
-
+#if defined(CONFIG_DEBUG_FS)
+#include "amdgpu_dm_debugfs.h"
+#endif
 /* #define TRACE_DPCD */
 
 #ifdef TRACE_DPCD
@@ -147,6 +149,12 @@ amdgpu_dm_mst_connector_late_register(struct drm_connector *connector)
 		to_amdgpu_dm_connector(connector);
 	struct drm_dp_mst_port *port = amdgpu_dm_connector->port;
 
+#if defined(CONFIG_DEBUG_FS)
+	connector_debugfs_init(amdgpu_dm_connector);
+	amdgpu_dm_connector->debugfs_dpcd_address = 0;
+	amdgpu_dm_connector->debugfs_dpcd_size = 0;
+#endif
+
 	return drm_dp_mst_connector_late_register(connector, port);
 }
 

commit 3261e013c0cad780a9a70176569e5ba9aba6e9b0
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Wed Nov 6 14:23:55 2019 -0500

    drm/amd/display: Add MST atomic routines
    
    - Adding encoder atomic check to find vcpi slots for a connector
    - Using DRM helper functions to calculate PBN
    - Adding connector atomic check to release vcpi slots if connector
    loses CRTC
    - Calculate  PBN and VCPI slots only once during atomic
    check and store them on crtc_state to eliminate
    redundant calculation
    - Call drm_dp_mst_atomic_check to verify validity of MST topology
    during state atomic check
    
    v2: squashed previous 3 separate patches, removed DSC PBN calculation,
    and added PBN and VCPI slots properties to amdgpu connector
    
    v3:
    - moved vcpi_slots and pbn properties to dm_crtc_state and dc_stream_state
    - updates stream's vcpi_slots and pbn on commit
    - separated patch from the DSC MST series
    
    v4:
    - set vcpi_slots and pbn properties to dm_connector_state
    - copy porperties from connector state on to crtc state
    
    v5:
    - keep the pbn and vcpi values only on connnector state
    - added a void pointer to the stream state instead on two ints,
    because dc_stream_state is OS agnostic. Pointer points to the
    current dm_connector_state.
    
    v6:
    - Remove new param from stream
    
    v7:
    - Fix error with using max capable bpc
    
    v8:
    - squash in fix from Gustavo A. R. Silva
    
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 49cf39711dfc..ba508a897263 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -246,11 +246,43 @@ dm_dp_mst_detect(struct drm_connector *connector,
 				      aconnector->port);
 }
 
+static int dm_dp_mst_atomic_check(struct drm_connector *connector,
+				struct drm_atomic_state *state)
+{
+	struct drm_connector_state *new_conn_state =
+			drm_atomic_get_new_connector_state(state, connector);
+	struct drm_connector_state *old_conn_state =
+			drm_atomic_get_old_connector_state(state, connector);
+	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
+	struct drm_crtc_state *new_crtc_state;
+	struct drm_dp_mst_topology_mgr *mst_mgr;
+	struct drm_dp_mst_port *mst_port;
+
+	mst_port = aconnector->port;
+	mst_mgr = &aconnector->mst_port->mst_mgr;
+
+	if (!old_conn_state->crtc)
+		return 0;
+
+	if (new_conn_state->crtc) {
+		new_crtc_state = drm_atomic_get_old_crtc_state(state, new_conn_state->crtc);
+		if (!new_crtc_state ||
+		    !drm_atomic_crtc_needs_modeset(new_crtc_state) ||
+		    new_crtc_state->enable)
+			return 0;
+		}
+
+	return drm_dp_atomic_release_vcpi_slots(state,
+						mst_mgr,
+						mst_port);
+}
+
 static const struct drm_connector_helper_funcs dm_dp_mst_connector_helper_funcs = {
 	.get_modes = dm_dp_mst_get_modes,
 	.mode_valid = amdgpu_dm_connector_mode_valid,
 	.atomic_best_encoder = dm_mst_atomic_best_encoder,
 	.detect_ctx = dm_dp_mst_detect,
+	.atomic_check = dm_dp_mst_atomic_check,
 };
 
 static void amdgpu_dm_encoder_destroy(struct drm_encoder *encoder)

commit 8a86b00a437ec06b298477463c7a9b8774570507
Merge: 2ef4144d1ea8 5ab5e4e60acc
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Nov 4 10:22:53 2019 +1000

    Merge tag 'drm-next-5.5-2019-11-01' of git://people.freedesktop.org/~agd5f/linux into drm-next
    
    drm-next-5.5-2019-11-01:
    
    amdgpu:
    - Add EEPROM support for Arcturus
    - Enable VCN encode support for Arcturus
    - Misc PSP fixes
    - Misc DC fixes
    - swSMU cleanup
    
    amdkfd:
    - Misc cleanups
    - Fix typo in cu bitmap parsing
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    From: Alex Deucher <alexdeucher@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191101190607.3763-1-alexander.deucher@amd.com

commit 57c2af791b6c8087b6d8b56046838427d2ec0d73
Merge: 8c84b43f17cb 12a280c72868
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Oct 30 09:01:28 2019 +1000

    Merge tag 'topic/mst-suspend-resume-reprobe-2019-10-29-2' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    UAPI Changes:
    
    Cross-subsystem Changes:
    
    Core Changes:
    * Handle UP requests asynchronously in the DP MST helpers, fixing
      hotplug notifications and allowing us to implement suspend/resume
      reprobing
    * Add basic suspend/resume reprobing to the DP MST helpers
    * Improve locking for link address reprobing and connection status
      request handling in the DP MST helpers
    * Miscellaneous refactoring in the DP MST helpers
    * Add a Kconfig option to the DP MST helpers to enable tracking of
      gets/puts for topology references for debugging purposes
    
    Driver Changes:
    * nouveau: Resume hotplug interrupts earlier, so that sideband
      messages may be transmitted during resume and thus allow
      suspend/resume reprobing for DP MST to work
    * nouveau: Avoid grabbing runtime PM references when handling short DP
      pulses, so that handling sideband messages in resume codepaths with the
      DP MST helpers doesn't deadlock us
    * i915, nouveau, amdgpu, radeon: Use detect_ctx for probing MST
      connectors, so that we can grab the topology manager's atomic lock
    
    Note: there's some amdgpu patches that I didn't realize were pushed
    upstream already when creating this topic branch. When they fail to
    apply, you can just ignore and skip them.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Lyude Paul <lyude@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/a74c6446bc960190d195a751cb6d8a00a98f3974.camel@redhat.com

commit e9c93e5af395022eb52923ae84e29b9b0b6d7073
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Wed Oct 2 12:22:29 2019 -0400

    drm/amd/display: Proper return of result when aux engine acquire fails
    
    [Why]
    When aux engine acquire fails, we missed populating the operation_result
    that describes the failure reason.
    
    [How]
    Set operation_result to new type:
    AUX_CHANNEL_OPERATION_FAILED_ENGINE_ACQUIRE
    in the case aux engine acquire has failed.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 3af2b429ff1b..779d0b60cac9 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -113,6 +113,7 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 			result = -EIO;
 			break;
 		case AUX_CHANNEL_OPERATION_FAILED_INVALID_REPLY:
+		case AUX_CHANNEL_OPERATION_FAILED_ENGINE_ACQUIRE:
 			result = -EBUSY;
 			break;
 		case AUX_CHANNEL_OPERATION_FAILED_TIMEOUT:

commit 3275a71e76fac5bc276f0d60e027b18c2e8d7a5b
Merge: 2e79e22e092a 1cd4d9eead73
Author: Dave Airlie <airlied@redhat.com>
Date:   Sat Oct 26 05:56:57 2019 +1000

    Merge tag 'drm-next-5.5-2019-10-09' of git://people.freedesktop.org/~agd5f/linux into drm-next
    
    drm-next-5.5-2019-10-09:
    
    amdgpu:
    - Additional RAS enablement for vega20
    - RAS page retirement and bad page storage in EEPROM
    - No GPU reset with unrecoverable RAS errors
    - Reserve vram for page tables rather than trying to evict
    - Fix issues with GPU reset and xgmi hives
    - DC i2c over aux fixes
    - Direct submission for clears, PTE/PDE updates
    - Improvements to help support recoverable GPU page faults
    - Silence harmless SAD block messages
    - Clean up code for creating a bo at a fixed location
    - Initial DC HDCP support
    - Lots of documentation fixes
    - GPU reset for renoir
    - Add IH clockgating support for soc15 asics
    - Powerplay improvements
    - DC MST cleanups
    - Add support for MSI-X
    - Misc cleanups and bug fixes
    
    amdkfd:
    - Query KFD device info by asic type rather than pci ids
    - Add navi14 support
    - Add renoir support
    - Add navi12 support
    - gfx10 trap handler improvements
    - pasid cleanups
    - Check against device cgroup
    
    ttm:
    - Return -EBUSY with pipelining with no_gpu_wait
    
    radeon:
    - Silence harmless SAD block messages
    
    device_cgroup:
    - Export devcgroup_check_permission
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Alex Deucher <alexdeucher@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191010041713.3412-1-alexander.deucher@amd.com

commit 3f9b3f02dda501ea1889d773d547dcff12a3f7bb
Author: Lyude Paul <lyude@redhat.com>
Date:   Mon Jun 17 17:59:29 2019 -0400

    drm/dp_mst: Protect drm_dp_mst_port members with locking
    
    This is a complicated one. Essentially, there's currently a problem in the MST
    core that hasn't really caused any issues that we're aware of (emphasis on "that
    we're aware of"): locking.
    
    When we go through and probe the link addresses and path resources in a
    topology, we hold no locks when updating ports with said information. The
    members I'm referring to in particular are:
    
    - ldps
    - ddps
    - mcs
    - pdt
    - dpcd_rev
    - num_sdp_streams
    - num_sdp_stream_sinks
    - available_pbn
    - input
    - connector
    
    Now that we're handling UP requests asynchronously and will be using some of
    the struct members mentioned above in atomic modesetting in the future for
    features such as PBN validation, this is going to become a lot more important.
    As well, the next few commits that prepare us for and introduce suspend/resume
    reprobing will also need clear locking in order to prevent from additional
    racing hilarities that we never could have hit in the past.
    
    So, let's solve this issue by using &mgr->base.lock, the modesetting
    lock which currently only protects &mgr->base.state. This works
    perfectly because it allows us to avoid blocking connection_mutex
    unnecessarily, and we can grab this in connector detection paths since
    it's a ww mutex. We start by having drm_dp_mst_handle_up_req() hold this
    when updating ports. For drm_dp_mst_handle_link_address_port() things
    are a bit more complicated. As I've learned the hard way, we can grab
    &mgr->lock.base for everything except for port->connector. See, our
    normal driver probing paths end up generating this rather obvious
    lockdep chain:
    
    &drm->mode_config.mutex
      -> crtc_ww_class_mutex/crtc_ww_class_acquire
        -> &connector->mutex
    
    However, sysfs grabs &drm->mode_config.mutex in order to protect itself
    from connector state changing under it. Because this entails grabbing
    kn->count, e.g. the lock that the kernel provides for protecting sysfs
    contexts, we end up grabbing kn->count followed by
    &drm->mode_config.mutex. This ends up creating an extremely rude chain:
    
    &kn->count
      -> &drm->mode_config.mutex
        -> crtc_ww_class_mutex/crtc_ww_class_acquire
          -> &connector->mutex
    
    I mean, look at that thing! It's just evil!!! This gross thing ends up
    making any calls to drm_connector_register()/drm_connector_unregister()
    impossible when holding any kind of modesetting lock. This is annoying
    because ideally, we always want to ensure that
    drm_dp_mst_port->connector never changes when doing an atomic commit or
    check that would affect the atomic topology state so that it can
    reliably and easily be used from future DRM DP MST helpers to assist
    with tasks such as scanning through the current VCPI allocations and
    adding connectors which need to have their allocations updated in
    response to a bandwidth change or the like.
    
    Being able to hold &mgr->base.lock throughout the entire link probe
    process would have been _great_, since we could prevent userspace from
    ever seeing any states in-between individual port changes and as a
    result likely end up with a much faster probe and more consistent
    results from said probes. But without some rework of how we handle
    connector probing in sysfs it's not at all currently possible. In the
    future, maybe we can try using the sysfs locks to protect updates to
    connector probing state and fix this mess.
    
    So for now, to protect everything other than port->connector under
    &mgr->base.lock and ensure that we still have the guarantee that atomic
    check/commit contexts will never see port->connector change we use a
    silly trick. See: port->connector only needs to change in order to
    ensure that input ports (see the MST spec) never have a ghost connector
    associated with them. But, there's nothing stopping us from simply
    throwing the entire port out and creating a new one in order to maintain
    that requirement while still keeping port->connector consistent across
    the lifetime of the port in atomic check/commit contexts. For all
    intended purposes this works fine, as we validate ports in any contexts
    we care about before using them and as such will end up reporting the
    connector as disconnected until it's port's destruction finalizes. So,
    we just do that in cases where we detect port->input has transitioned
    from true->false. We don't need to worry about the other direction,
    since a port without a connector isn't visible to userspace and as such
    doesn't need to be protected by &mgr->base.lock until we finish
    registering a connector for it.
    
    For updating members of drm_dp_mst_port other than port->connector, we
    simply grab &mgr->base.lock in drm_dp_mst_link_probe_work() for already
    registered ports, update said members and drop the lock before
    potentially registering a connector and probing the link address of it's
    children.
    
    Finally, we modify drm_dp_mst_detect_port() to take a modesetting lock
    acquisition context in order to acquire &mgr->base.lock under
    &connection_mutex and convert all it's users over to using the
    .detect_ctx probe hooks.
    
    With that, we finally have well defined locking.
    
    Changes since v4:
    * Get rid of port->mutex, stop using connection_mutex and just use our own
      modesetting lock - mgr->base.lock. Also, add a probe_lock that comes
      before this patch.
    * Just throw out ports that get changed from an output to an input, and
      replace them with new ports. This lets us ensure that modesetting
      contexts never see port->connector go from having a connector to being
      NULL.
    * Write an extremely detailed explanation of what problems this is
      trying to fix, since there's a _lot_ of context here and I honestly
      forgot some of it myself a couple times.
    * Don't grab mgr->lock when reading port->mstb in
      drm_dp_mst_handle_link_address_port(). It's not needed.
    
    Cc: Juston Li <juston.li@intel.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Cc: Ville SyrjÃ¤lÃ¤ <ville.syrjala@linux.intel.com>
    Cc: Harry Wentland <hwentlan@amd.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Sean Paul <sean@poorly.run>
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191022023641.8026-7-lyude@redhat.com

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 5ec14efd4d8c..f8214acf70b3 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -123,21 +123,6 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 	return result;
 }
 
-static enum drm_connector_status
-dm_dp_mst_detect(struct drm_connector *connector, bool force)
-{
-	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
-	struct amdgpu_dm_connector *master = aconnector->mst_port;
-
-	enum drm_connector_status status =
-		drm_dp_mst_detect_port(
-			connector,
-			&master->mst_mgr,
-			aconnector->port);
-
-	return status;
-}
-
 static void
 dm_dp_mst_connector_destroy(struct drm_connector *connector)
 {
@@ -177,7 +162,6 @@ amdgpu_dm_mst_connector_early_unregister(struct drm_connector *connector)
 }
 
 static const struct drm_connector_funcs dm_dp_mst_connector_funcs = {
-	.detect = dm_dp_mst_detect,
 	.fill_modes = drm_helper_probe_single_connector_modes,
 	.destroy = dm_dp_mst_connector_destroy,
 	.reset = amdgpu_dm_connector_funcs_reset,
@@ -252,10 +236,22 @@ static struct drm_encoder *dm_mst_best_encoder(struct drm_connector *connector)
 	return &amdgpu_dm_connector->mst_encoder->base;
 }
 
+static int
+dm_dp_mst_detect(struct drm_connector *connector,
+		 struct drm_modeset_acquire_ctx *ctx, bool force)
+{
+	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
+	struct amdgpu_dm_connector *master = aconnector->mst_port;
+
+	return drm_dp_mst_detect_port(connector, ctx, &master->mst_mgr,
+				      aconnector->port);
+}
+
 static const struct drm_connector_helper_funcs dm_dp_mst_connector_helper_funcs = {
 	.get_modes = dm_dp_mst_get_modes,
 	.mode_valid = amdgpu_dm_connector_mode_valid,
 	.best_encoder = dm_mst_best_encoder,
+	.detect_ctx = dm_dp_mst_detect,
 };
 
 static void amdgpu_dm_encoder_destroy(struct drm_encoder *encoder)

commit b96ec4a4e4b29914b948660aed4498f1a9cf62ea
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Sep 26 18:51:05 2019 -0400

    drm/amdgpu/dm/mst: Use ->atomic_best_encoder
    
    We are supposed to be atomic after all. We'll need this in a moment for
    the next commit.
    
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index caa241141aab..3af2b429ff1b 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -243,17 +243,17 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 	return ret;
 }
 
-static struct drm_encoder *dm_mst_best_encoder(struct drm_connector *connector)
+static struct drm_encoder *
+dm_mst_atomic_best_encoder(struct drm_connector *connector,
+			   struct drm_connector_state *connector_state)
 {
-	struct amdgpu_dm_connector *amdgpu_dm_connector = to_amdgpu_dm_connector(connector);
-
-	return &amdgpu_dm_connector->mst_encoder->base;
+	return &to_amdgpu_dm_connector(connector)->mst_encoder->base;
 }
 
 static const struct drm_connector_helper_funcs dm_dp_mst_connector_helper_funcs = {
 	.get_modes = dm_dp_mst_get_modes,
 	.mode_valid = amdgpu_dm_connector_mode_valid,
-	.best_encoder = dm_mst_best_encoder,
+	.atomic_best_encoder = dm_mst_atomic_best_encoder,
 };
 
 static void amdgpu_dm_encoder_destroy(struct drm_encoder *encoder)

commit 2f232cf29e033271b626b865071dc842102de23e
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Sep 26 18:51:03 2019 -0400

    drm/amdgpu/dm/mst: Don't create MST topology managers for eDP ports
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 357a7ff20b2b..caa241141aab 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -415,6 +415,10 @@ void amdgpu_dm_initialize_dp_connector(struct amdgpu_display_manager *dm,
 	drm_dp_aux_register(&aconnector->dm_dp_aux.aux);
 	drm_dp_cec_register_connector(&aconnector->dm_dp_aux.aux,
 				      aconnector->base.name, dm->adev->dev);
+
+	if (aconnector->base.connector_type == DRM_MODE_CONNECTOR_eDP)
+		return;
+
 	aconnector->mst_mgr.cbs = &dm_mst_cbs;
 	drm_dp_mst_topology_mgr_init(
 		&aconnector->mst_mgr,

commit d7a1b559f3c812816151deba595bb72e04795633
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Sep 26 18:51:04 2019 -0400

    drm/amdgpu/dm/mst: Remove unnecessary NULL check
    
    kfree() checks this automatically.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 16218a202b59..357a7ff20b2b 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -144,10 +144,8 @@ dm_dp_mst_connector_destroy(struct drm_connector *connector)
 	struct amdgpu_dm_connector *amdgpu_dm_connector = to_amdgpu_dm_connector(connector);
 	struct amdgpu_encoder *amdgpu_encoder = amdgpu_dm_connector->mst_encoder;
 
-	if (amdgpu_dm_connector->edid) {
-		kfree(amdgpu_dm_connector->edid);
-		amdgpu_dm_connector->edid = NULL;
-	}
+	kfree(amdgpu_dm_connector->edid);
+	amdgpu_dm_connector->edid = NULL;
 
 	drm_encoder_cleanup(&amdgpu_encoder->base);
 	kfree(amdgpu_encoder);

commit ae85b0df124f6928709f6707db55457f369bcb27
Author: Dariusz Marcinkiewicz <darekm@google.com>
Date:   Wed Aug 14 12:44:59 2019 +0200

    drm_dp_cec: add connector info support.
    
    Pass the connector info to the CEC adapter. This makes it possible
    to associate the CEC adapter with the corresponding drm connector.
    
    Signed-off-by: Dariusz Marcinkiewicz <darekm@google.com>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Tested-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190814104520.6001-2-darekm@google.com

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 16218a202b59..5ec14efd4d8c 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -416,7 +416,7 @@ void amdgpu_dm_initialize_dp_connector(struct amdgpu_display_manager *dm,
 
 	drm_dp_aux_register(&aconnector->dm_dp_aux.aux);
 	drm_dp_cec_register_connector(&aconnector->dm_dp_aux.aux,
-				      aconnector->base.name, dm->adev->dev);
+				      &aconnector->base);
 	aconnector->mst_mgr.cbs = &dm_mst_cbs;
 	drm_dp_mst_topology_mgr_init(
 		&aconnector->mst_mgr,

commit a1b27e99229a448075abc3ca006043d4785f14a4
Author: Leo Li <sunpeng.li@amd.com>
Date:   Tue Jul 23 19:28:08 2019 -0400

    drm/amd/display: Implement MST Aux device registration
    
    Implement late_register and early_unregister hooks for MST connectors.
    Call drm helpers for MST connector registration, which registers the
    AUX devices.
    
    Cc: Jerry Zuo <Jerry.Zuo@amd.com>
    Cc: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Cc: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190723232808.28128-10-sunpeng.li@amd.com

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 53d2cfe62e13..16218a202b59 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -156,6 +156,26 @@ dm_dp_mst_connector_destroy(struct drm_connector *connector)
 	kfree(amdgpu_dm_connector);
 }
 
+static int
+amdgpu_dm_mst_connector_late_register(struct drm_connector *connector)
+{
+	struct amdgpu_dm_connector *amdgpu_dm_connector =
+		to_amdgpu_dm_connector(connector);
+	struct drm_dp_mst_port *port = amdgpu_dm_connector->port;
+
+	return drm_dp_mst_connector_late_register(connector, port);
+}
+
+static void
+amdgpu_dm_mst_connector_early_unregister(struct drm_connector *connector)
+{
+	struct amdgpu_dm_connector *amdgpu_dm_connector =
+		to_amdgpu_dm_connector(connector);
+	struct drm_dp_mst_port *port = amdgpu_dm_connector->port;
+
+	drm_dp_mst_connector_early_unregister(connector, port);
+}
+
 static const struct drm_connector_funcs dm_dp_mst_connector_funcs = {
 	.detect = dm_dp_mst_detect,
 	.fill_modes = drm_helper_probe_single_connector_modes,
@@ -164,7 +184,9 @@ static const struct drm_connector_funcs dm_dp_mst_connector_funcs = {
 	.atomic_duplicate_state = amdgpu_dm_connector_atomic_duplicate_state,
 	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
 	.atomic_set_property = amdgpu_dm_connector_atomic_set_property,
-	.atomic_get_property = amdgpu_dm_connector_atomic_get_property
+	.atomic_get_property = amdgpu_dm_connector_atomic_get_property,
+	.late_register = amdgpu_dm_mst_connector_late_register,
+	.early_unregister = amdgpu_dm_mst_connector_early_unregister,
 };
 
 static int dm_dp_mst_get_modes(struct drm_connector *connector)

commit db432cd0960cd32d02ac8ef64deeed6dfe75b7cd
Author: Leo Li <sunpeng.li@amd.com>
Date:   Tue Jul 23 19:28:04 2019 -0400

    drm/amd/display: Use connector kdev as aux device parent
    
    Set the connector's kernel device as the parent for the aux kernel
    device. This allows udev rules to access connector attributes when
    creating symlinks to aux devices.
    
    For example, the following udev rule:
    
    SUBSYSTEM=="drm_dp_aux_dev", SUBSYSTEMS=="drm", ATTRS{edid}=="*",
            SYMLINK+="drm_dp_aux/by-name/$id"
    
    Will create the following symlinks using the connector's name:
    
    $ ls /dev/drm_dp_aux/by-name/
    card0-DP-1  card0-DP-2  card0-DP-3
    
    Cc: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Cc: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Cc: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190723232808.28128-6-sunpeng.li@amd.com

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 6e205ee36ac3..53d2cfe62e13 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -388,7 +388,7 @@ void amdgpu_dm_initialize_dp_connector(struct amdgpu_display_manager *dm,
 				       struct amdgpu_dm_connector *aconnector)
 {
 	aconnector->dm_dp_aux.aux.name = "dmdc";
-	aconnector->dm_dp_aux.aux.dev = dm->adev->dev;
+	aconnector->dm_dp_aux.aux.dev = aconnector->base.kdev;
 	aconnector->dm_dp_aux.aux.transfer = dm_dp_aux_transfer;
 	aconnector->dm_dp_aux.ddc_service = aconnector->dc_link->ddc;
 

commit 8ae5b1d78d4acbe9755570f26703962877f9108a
Author: Thomas Lim <Thomas.Lim@amd.com>
Date:   Wed Jan 16 15:56:56 2019 -0500

    drm/amd/display: Respect aux return values
    
    [Why]
    The new aux implementation was not up to spec. This caused us to fail DP
    compliance as well as introduced serious delays during system resume.
    
    [How]
    Make dce_aux_transfer_raw return the operation result
    
    Make dce_aux_transfer_with_retries delay with udelay instead
    of msleep, and only on invalid reply.  Also fail on the second
    invalid reply, third timeout, or first of any other error
    
    Convert return values to drm error codes in amdgpu_dm
    
    As the two aux transfer functions are now noticeably
    different, change the names to better reflect their
    functionality and document.
    
    There was one last call to dc_link_aux_transfer that
    should have retries, fix that
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Signed-off-by: Thomas Lim <Thomas.Lim@amd.com>
    Reviewed-by: David Francis <David.Francis@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Eric Yang <eric.yang2@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index c4ea3a91f17a..6e205ee36ac3 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -84,6 +84,7 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 {
 	ssize_t result = 0;
 	struct aux_payload payload;
+	enum aux_channel_operation_result operation_result;
 
 	if (WARN_ON(msg->size > 16))
 		return -E2BIG;
@@ -97,13 +98,27 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 	payload.mot = (msg->request & DP_AUX_I2C_MOT) != 0;
 	payload.defer_delay = 0;
 
-	result = dc_link_aux_transfer(TO_DM_AUX(aux)->ddc_service, &payload);
+	result = dc_link_aux_transfer_raw(TO_DM_AUX(aux)->ddc_service, &payload,
+				      &operation_result);
 
 	if (payload.write)
 		result = msg->size;
 
-	if (result < 0) /* DC doesn't know about kernel error codes */
-		result = -EIO;
+	if (result < 0)
+		switch (operation_result) {
+		case AUX_CHANNEL_OPERATION_SUCCEEDED:
+			break;
+		case AUX_CHANNEL_OPERATION_FAILED_HPD_DISCON:
+		case AUX_CHANNEL_OPERATION_FAILED_REASON_UNKNOWN:
+			result = -EIO;
+			break;
+		case AUX_CHANNEL_OPERATION_FAILED_INVALID_REPLY:
+			result = -EBUSY;
+			break;
+		case AUX_CHANNEL_OPERATION_FAILED_TIMEOUT:
+			result = -ETIMEDOUT;
+			break;
+		}
 
 	return result;
 }

commit dcd5fb82ffb484124203aa339733663ac0b059f3
Author: Mathias FrÃ¶hlich <Mathias.Froehlich@web.de>
Date:   Sun Feb 10 11:13:01 2019 +0100

    drm/amd/display: Fix reference counting for struct dc_sink.
    
    Reference counting in amdgpu_dm_connector for amdgpu_dm_connector::dc_sink
    and amdgpu_dm_connector::dc_em_sink as well as in dc_link::local_sink seems
    to be out of shape. Thus make reference counting consistent for these
    members and just plain increment the reference count when the variable
    gets assigned and decrement when the pointer is set to zero or replaced.
    Also simplify reference counting in selected function sopes to be sure the
    reference is released in any case. In some cases add NULL pointer check
    before dereferencing.
    At a hand full of places a comment is placed to stat that the reference
    increment happened already somewhere else.
    
    This actually fixes the following kernel bug on my system when enabling
    display core in amdgpu. There are some more similar bug reports around,
    so it probably helps at more places.
    
       kernel BUG at mm/slub.c:294!
       invalid opcode: 0000 [#1] SMP PTI
       CPU: 9 PID: 1180 Comm: Xorg Not tainted 5.0.0-rc1+ #2
       Hardware name: Supermicro X10DAi/X10DAI, BIOS 3.0a 02/05/2018
       RIP: 0010:__slab_free+0x1e2/0x3d0
       Code: 8b 54 24 30 48 89 4c 24 28 e8 da fb ff ff 4c 8b 54 24 28 85 c0 0f 85 67 fe ff ff 48 8d 65 d8 5b 41 5c 41 5d 41 5e 41 5f 5d c3 <0f> 0b 49 3b 5c 24 28 75 ab 48 8b 44 24 30 49 89 4c 24 28 49 89 44
       RSP: 0018:ffffb0978589fa90 EFLAGS: 00010246
       RAX: ffff92f12806c400 RBX: 0000000080200019 RCX: ffff92f12806c400
       RDX: ffff92f12806c400 RSI: ffffdd6421a01a00 RDI: ffff92ed2f406e80
       RBP: ffffb0978589fb40 R08: 0000000000000001 R09: ffffffffc0ee4748
       R10: ffff92f12806c400 R11: 0000000000000001 R12: ffffdd6421a01a00
       R13: ffff92f12806c400 R14: ffff92ed2f406e80 R15: ffffdd6421a01a20
       FS:  00007f4170be0ac0(0000) GS:ffff92ed2fb40000(0000) knlGS:0000000000000000
       CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
       CR2: 0000562818aaa000 CR3: 000000045745a002 CR4: 00000000003606e0
       DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
       DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
       Call Trace:
        ? drm_dbg+0x87/0x90 [drm]
        dc_stream_release+0x28/0x50 [amdgpu]
        amdgpu_dm_connector_mode_valid+0xb4/0x1f0 [amdgpu]
        drm_helper_probe_single_connector_modes+0x492/0x6b0 [drm_kms_helper]
        drm_mode_getconnector+0x457/0x490 [drm]
        ? drm_connector_property_set_ioctl+0x60/0x60 [drm]
        drm_ioctl_kernel+0xa9/0xf0 [drm]
        drm_ioctl+0x201/0x3a0 [drm]
        ? drm_connector_property_set_ioctl+0x60/0x60 [drm]
        amdgpu_drm_ioctl+0x49/0x80 [amdgpu]
        do_vfs_ioctl+0xa4/0x630
        ? __sys_recvmsg+0x83/0xa0
        ksys_ioctl+0x60/0x90
        __x64_sys_ioctl+0x16/0x20
        do_syscall_64+0x5b/0x160
        entry_SYSCALL_64_after_hwframe+0x44/0xa9
       RIP: 0033:0x7f417110809b
       Code: 0f 1e fa 48 8b 05 ed bd 0c 00 64 c7 00 26 00 00 00 48 c7 c0 ff ff ff ff c3 66 0f 1f 44 00 00 f3 0f 1e fa b8 10 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d bd bd 0c 00 f7 d8 64 89 01 48
       RSP: 002b:00007ffdd8d1c268 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
       RAX: ffffffffffffffda RBX: 0000562818a8ebc0 RCX: 00007f417110809b
       RDX: 00007ffdd8d1c2a0 RSI: 00000000c05064a7 RDI: 0000000000000012
       RBP: 00007ffdd8d1c2a0 R08: 0000562819012280 R09: 0000000000000007
       R10: 0000000000000000 R11: 0000000000000246 R12: 00000000c05064a7
       R13: 0000000000000012 R14: 0000000000000012 R15: 00007ffdd8d1c2a0
       Modules linked in: nfsv4 dns_resolver nfs lockd grace fscache fuse vfat fat amdgpu intel_rapl sb_edac x86_pkg_temp_thermal intel_powerclamp coretemp kvm_intel kvm irqbypass crct10dif_pclmul chash gpu_sched crc32_pclmul snd_hda_codec_realtek ghash_clmulni_intel amd_iommu_v2 iTCO_wdt iTCO_vendor_support ttm snd_hda_codec_generic snd_hda_codec_hdmi ledtrig_audio snd_hda_intel drm_kms_helper snd_hda_codec intel_cstate snd_hda_core drm snd_hwdep snd_seq snd_seq_device intel_uncore snd_pcm intel_rapl_perf snd_timer snd soundcore ioatdma pcspkr intel_wmi_thunderbolt mxm_wmi i2c_i801 lpc_ich pcc_cpufreq auth_rpcgss sunrpc igb crc32c_intel i2c_algo_bit dca wmi hid_cherry analog gameport joydev
    
    This patch is based on agd5f/drm-next-5.1-wip. This patch does not require
    all of that, but agd5f/drm-next-5.1-wip contains at least one more dc_sink
    counting fix that I could spot.
    
    Signed-off-by: Mathias FrÃ¶hlich <Mathias.Froehlich@web.de>
    Reviewed-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index f51d52eb52e6..c4ea3a91f17a 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -191,6 +191,7 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 			&init_params);
 
 		dc_sink->priv = aconnector;
+		/* dc_link_add_remote_sink returns a new reference */
 		aconnector->dc_sink = dc_sink;
 
 		if (aconnector->dc_sink)

commit f4bc54b532a62d8bee421ca06adb6d1b3e7ffaa9
Merge: 5ea3998d5634 0461221316ec
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Feb 11 14:04:05 2019 +1000

    Merge branch 'drm-next-5.1' of git://people.freedesktop.org/~agd5f/linux into drm-next
    
    Updates for 5.1:
    - GDS fixes
    - Add AMDGPU_CHUNK_ID_SCHEDULED_DEPENDENCIES interface
    - GPUVM fixes
    - PCIE DPM switching fixes for vega20
    - Vega10 uclk DPM regression fix
    - DC Freesync fixes
    - DC ABM fixes
    - Various DC cleanups
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    From: Alex Deucher <alexdeucher@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190208210214.27666-1-alexander.deucher@amd.com

commit 3f01f098a4e2ef30ef628497c43a3d568e720376
Author: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
Date:   Thu Jan 24 11:46:49 2019 -0500

    drm/amd/display: Clear dc_sink after it gets released
    
    [Why]
    The dc_sink was released but the pointer on the aconnector was
    not cleared.
    
    [How]
    Clear it.
    
    Signed-off-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 73f8e8fa6edb..44c1a02e6452 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -173,8 +173,10 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 		aconnector->edid = edid;
 	}
 
-	if (aconnector->dc_sink && aconnector->dc_sink->sink_signal == SIGNAL_TYPE_VIRTUAL)
+	if (aconnector->dc_sink && aconnector->dc_sink->sink_signal == SIGNAL_TYPE_VIRTUAL) {
 		dc_sink_release(aconnector->dc_sink);
+		aconnector->dc_sink = NULL;
+	}
 
 	if (!aconnector->dc_sink) {
 		struct dc_sink *dc_sink;

commit e3fa5c4cf1b93205d64e3d472d049fe5d8e88e94
Author: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
Date:   Wed Jan 23 11:41:18 2019 -0500

    drm/amd/display: Apply fake sink back to MST sequence
    
    [Why]
    It fixes the failure to create stream for sink in the scenario
    when hotplug SST and MST in sequence, and disconnect MST.
    
    [How]
    Add the fake sink back after the majority of MST rework is done.
    
    Signed-off-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 60da1222afaa..73f8e8fa6edb 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -173,6 +173,9 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 		aconnector->edid = edid;
 	}
 
+	if (aconnector->dc_sink && aconnector->dc_sink->sink_signal == SIGNAL_TYPE_VIRTUAL)
+		dc_sink_release(aconnector->dc_sink);
+
 	if (!aconnector->dc_sink) {
 		struct dc_sink *dc_sink;
 		struct dc_sink_init_data init_params = {

commit e09191d360ab54c7ac7a9b09287dcab81c30d8e3
Merge: f91168f48556 10117450735c
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jan 31 14:19:45 2019 +1000

    Merge branch 'drm-next-5.1' of git://people.freedesktop.org/~agd5f/linux into drm-next
    
    New stuff for 5.1.
    amdgpu:
    - DC bandwidth formula updates
    - Support for DCC on scanout surfaces
    - Support for multiple IH rings on soc15 asics
    - Fix xgmi locking
    - Add sysfs interface to get pcie usage stats
    - Simplify DC i2c/aux code
    - Initial support for BACO on vega10/20
    - New runtime SMU feature debug interface
    - Expand existing sysfs power interfaces to new clock domains
    - Handle kexec properly
    - Simplify IH programming
    - Rework doorbell handling across asics
    - Drop old CI DPM implementation
    - DC page flipping fixes
    - Misc SR-IOV fixes
    
    amdkfd:
    - Simplify the interfaces between amdkfd and amdgpu
    
    ttm:
    - Add a callback to notify the driver when the lru changes
    
    sched:
    - Refactor mirror list handling
    - Rework hw fence processing
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    From: Alex Deucher <alexdeucher@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190125231517.26268-1-alexander.deucher@amd.com

commit ad6756b4d773aae68430a7d8b3c35c6717de5a15
Author: David Francis <David.Francis@amd.com>
Date:   Thu Nov 29 13:40:03 2018 -0500

    drm/amd/display: Shift dc link aux to aux_payload
    
    [Why]
    aux_payload should be the struct used inside dc to start
    aux transactions.  This will allow the old aux interface
    to be seamlessly replaced.
    
    [How]
    Add three fields to aux_payload: reply, mot, defer_delay
    This will mean that aux_payload has all data required
    to submit a request.  Shift dc_link to use this struct
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 5e7ca1f3a8d1..60da1222afaa 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -35,6 +35,8 @@
 
 #include "dc_link_ddc.h"
 
+#include "i2caux_interface.h"
+
 /* #define TRACE_DPCD */
 
 #ifdef TRACE_DPCD
@@ -81,80 +83,24 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 				  struct drm_dp_aux_msg *msg)
 {
 	ssize_t result = 0;
-	enum i2caux_transaction_action action;
-	enum aux_transaction_type type;
+	struct aux_payload payload;
 
 	if (WARN_ON(msg->size > 16))
 		return -E2BIG;
 
-	switch (msg->request & ~DP_AUX_I2C_MOT) {
-	case DP_AUX_NATIVE_READ:
-		type = AUX_TRANSACTION_TYPE_DP;
-		action = I2CAUX_TRANSACTION_ACTION_DP_READ;
-
-		result = dc_link_aux_transfer(TO_DM_AUX(aux)->ddc_service,
-					      msg->address,
-					      &msg->reply,
-					      msg->buffer,
-					      msg->size,
-					      type,
-					      action);
-		break;
-	case DP_AUX_NATIVE_WRITE:
-		type = AUX_TRANSACTION_TYPE_DP;
-		action = I2CAUX_TRANSACTION_ACTION_DP_WRITE;
-
-		dc_link_aux_transfer(TO_DM_AUX(aux)->ddc_service,
-				     msg->address,
-				     &msg->reply,
-				     msg->buffer,
-				     msg->size,
-				     type,
-				     action);
-		result = msg->size;
-		break;
-	case DP_AUX_I2C_READ:
-		type = AUX_TRANSACTION_TYPE_I2C;
-		if (msg->request & DP_AUX_I2C_MOT)
-			action = I2CAUX_TRANSACTION_ACTION_I2C_READ_MOT;
-		else
-			action = I2CAUX_TRANSACTION_ACTION_I2C_READ;
-
-		result = dc_link_aux_transfer(TO_DM_AUX(aux)->ddc_service,
-					      msg->address,
-					      &msg->reply,
-					      msg->buffer,
-					      msg->size,
-					      type,
-					      action);
-		break;
-	case DP_AUX_I2C_WRITE:
-		type = AUX_TRANSACTION_TYPE_I2C;
-		if (msg->request & DP_AUX_I2C_MOT)
-			action = I2CAUX_TRANSACTION_ACTION_I2C_WRITE_MOT;
-		else
-			action = I2CAUX_TRANSACTION_ACTION_I2C_WRITE;
-
-		dc_link_aux_transfer(TO_DM_AUX(aux)->ddc_service,
-				     msg->address,
-				     &msg->reply,
-				     msg->buffer,
-				     msg->size,
-				     type,
-				     action);
-		result = msg->size;
-		break;
-	default:
-		return -EINVAL;
-	}
+	payload.address = msg->address;
+	payload.data = msg->buffer;
+	payload.length = msg->size;
+	payload.reply = &msg->reply;
+	payload.i2c_over_aux = (msg->request & DP_AUX_NATIVE_WRITE) == 0;
+	payload.write = (msg->request & DP_AUX_I2C_READ) == 0;
+	payload.mot = (msg->request & DP_AUX_I2C_MOT) != 0;
+	payload.defer_delay = 0;
 
-#ifdef TRACE_DPCD
-	log_dpcd(msg->request,
-		 msg->address,
-		 msg->buffer,
-		 msg->size,
-		 r == DDC_RESULT_SUCESSFULL);
-#endif
+	result = dc_link_aux_transfer(TO_DM_AUX(aux)->ddc_service, &payload);
+
+	if (payload.write)
+		result = msg->size;
 
 	if (result < 0) /* DC doesn't know about kernel error codes */
 		result = -EIO;

commit 23d19ba06b9c5614d6457f5fed349ec8f6d4dac9
Merge: 7d0250ed8e69 e3d093070eb0
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Fri Jan 11 16:32:10 2019 +0100

    Merge drm/drm-next into drm-misc-next
    
    drm-next has been forwarded to 5.0-rc1, and we need it to apply the damage
    helper for dirtyfb series from Noralf TrÃ¸nnes.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>

commit d25689760b747287c6ca03cfe0729da63e0717f4
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Jan 10 19:53:34 2019 -0500

    drm/amdgpu/display: Keep malloc ref to MST port
    
    Just like i915 and nouveau, it's a good idea for us to hold a malloc
    reference to the port here so that we never pass a freed pointer to any
    of the DP MST helper functions.
    
    Also, we stop unsetting aconnector->port in
    dm_dp_destroy_mst_connector(). There's literally no point to that
    assignment that I can see anyway.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: David Airlie <airlied@redhat.com>
    Cc: Jerry Zuo <Jerry.Zuo@amd.com>
    Cc: Juston Li <juston.li@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190111005343.17443-12-lyude@redhat.com

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 9fdeca096407..24665795b1ad 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -191,6 +191,7 @@ dm_dp_mst_connector_destroy(struct drm_connector *connector)
 	drm_encoder_cleanup(&amdgpu_encoder->base);
 	kfree(amdgpu_encoder);
 	drm_connector_cleanup(connector);
+	drm_dp_mst_put_port_malloc(amdgpu_dm_connector->port);
 	kfree(amdgpu_dm_connector);
 }
 
@@ -364,7 +365,9 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 	amdgpu_dm_connector_funcs_reset(connector);
 
 	DRM_INFO("DM_MST: added connector: %p [id: %d] [master: %p]\n",
-			aconnector, connector->base.id, aconnector->mst_port);
+		 aconnector, connector->base.id, aconnector->mst_port);
+
+	drm_dp_mst_get_port_malloc(port);
 
 	DRM_DEBUG_KMS(":%d\n", connector->base.id);
 
@@ -380,12 +383,12 @@ static void dm_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
 
 	DRM_INFO("DM_MST: Disabling connector: %p [id: %d] [master: %p]\n",
-				aconnector, connector->base.id, aconnector->mst_port);
+		 aconnector, connector->base.id, aconnector->mst_port);
 
-	aconnector->port = NULL;
 	if (aconnector->dc_sink) {
 		amdgpu_dm_update_freesync_caps(connector, NULL);
-		dc_link_remove_remote_sink(aconnector->dc_link, aconnector->dc_sink);
+		dc_link_remove_remote_sink(aconnector->dc_link,
+					   aconnector->dc_sink);
 		dc_sink_release(aconnector->dc_sink);
 		aconnector->dc_sink = NULL;
 	}

commit 8c1a765bc62c93be2803f4541363a1c06355243e
Merge: bfeffd155283 1c95f662fcee
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jan 10 05:53:51 2019 +1000

    Merge tag 'drm-misc-next-2019-01-07-1' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.1:
    
    UAPI Changes:
    
    Cross-subsystem Changes:
      - Turn dma-buf fence sequence numbers into 64 bit numbers
    
    Core Changes:
      - Move to a common helper for the DP MST hotplug for radeon, i915 and
        amdgpu
      - i2c improvements for drm_dp_mst
      - Removal of drm_syncobj_cb
      - Introduction of an helper to create and attach the TV margin properties
    
    Driver Changes:
      - Improve cache flushes for v3d
      - Reflection support for vc4
      - HDMI overscan support for vc4
      - Add implicit fencing support for rockchip and sun4i
      - Switch to generic fbdev emulation for virtio
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    [airlied: applied amdgpu merge fixup]
    From: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190107180333.amklwycudbsub3s5@flea

commit 16bff572cc660f19e58c99941368dea050b36a05
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Nov 28 23:12:34 2018 +0100

    drm/dp-mst-helper: Remove hotplug callback
    
    When everyone implements it exactly the same way, among all 4
    implementations, there's not really a need to overwrite this at all.
    
    Aside: drm_kms_helper_hotplug_event is pretty much core functionality
    at this point. Probably should move it there.
    
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181128221234.15054-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index d02c32a1039c..9fdeca096407 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -396,14 +396,6 @@ static void dm_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 	drm_connector_put(connector);
 }
 
-static void dm_dp_mst_hotplug(struct drm_dp_mst_topology_mgr *mgr)
-{
-	struct amdgpu_dm_connector *master = container_of(mgr, struct amdgpu_dm_connector, mst_mgr);
-	struct drm_device *dev = master->base.dev;
-
-	drm_kms_helper_hotplug_event(dev);
-}
-
 static void dm_dp_mst_register_connector(struct drm_connector *connector)
 {
 	struct drm_device *dev = connector->dev;
@@ -420,7 +412,6 @@ static void dm_dp_mst_register_connector(struct drm_connector *connector)
 static const struct drm_dp_mst_topology_cbs dm_mst_cbs = {
 	.add_connector = dm_dp_add_mst_connector,
 	.destroy_connector = dm_dp_destroy_mst_connector,
-	.hotplug = dm_dp_mst_hotplug,
 	.register_connector = dm_dp_mst_register_connector
 };
 

commit 04ac4b0ed412f65230b456fcd9aa07e13befff89
Author: Lyude Paul <lyude@redhat.com>
Date:   Mon Nov 19 19:44:55 2018 +0000

    drm/amd/dm: Understand why attaching path/tile properties are needed
    
    Path property is used for userspace to know what MST connector goes to what actual DRM DisplayPort connector, the tiling property is for tiling configurations. Not sure what else there is to figure out.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Cc: Stable <stable@vger.kernel.org>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 0cca1809fdcd..1b0d209d8367 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -345,9 +345,6 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 	drm_connector_attach_encoder(&aconnector->base,
 				     &aconnector->mst_encoder->base);
 
-	/*
-	 * TODO: understand why this one is needed
-	 */
 	drm_object_attach_property(
 		&connector->base,
 		dev->mode_config.path_property,

commit c9e0ab86b2e03154bb898cd2f851827783224727
Author: Lyude Paul <lyude@redhat.com>
Date:   Mon Nov 19 15:00:10 2018 +0000

    drm/amd/dm: Don't forget to attach MST encoders
    
    The change fixed huge delay in SST daisy chain and S3 soft hang
    observed in 4.19 kernel rebase.
    
    Regression point in drm:
    drm/fb-helper: Eliminate the .best_encoder() usage
    
    The aux sequence is altered due to the failure in
    drm_connector_for_each_possible_encoder(). The failure is
    caused by missing attached encoder in the process of adding
    MST connector.
    Â 
    drm_dp_send_enum_path_resources() aux transaction is pushed after
    mode probe, which causes conflict to drm_dp_mst_i2c_xfer(),
    leading to the transaction timeout.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Cc: Stable <stable@vger.kernel.org>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index d02c32a1039c..0cca1809fdcd 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -342,6 +342,8 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 		master->connector_id);
 
 	aconnector->mst_encoder = dm_dp_create_fake_mst_encoder(master);
+	drm_connector_attach_encoder(&aconnector->base,
+				     &aconnector->mst_encoder->base);
 
 	/*
 	 * TODO: understand why this one is needed

commit 63237f8748bdf46dccf79ef8f98f05e9fe799162
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Nov 1 21:51:49 2018 -0400

    drm/amd/amdgpu/dm: Fix dm_dp_create_fake_mst_encoder()
    
    [why]
    Removing connector reusage from DM to match the rest of the tree ended
    up revealing an issue that was surprisingly subtle. The original amdgpu
    code for DC that was submitted appears to have left a chunk in
    dm_dp_create_fake_mst_encoder() that tries to find a "master encoder",
    the likes of which isn't actually used or stored anywhere. It does so at
    the wrong time as well by trying to access parts of the drm_connector
    from the encoder init before it's actually been initialized. This
    results in a NULL pointer deref on MST hotplugs:
    
    [  160.696613] BUG: unable to handle kernel NULL pointer dereference at 0000000000000000
    [  160.697234] PGD 0 P4D 0
    [  160.697814] Oops: 0010 [#1] SMP PTI
    [  160.698430] CPU: 2 PID: 64 Comm: kworker/2:1 Kdump: loaded Tainted: G           O      4.19.0Lyude-Test+ #2
    [  160.699020] Hardware name: HP HP ZBook 15 G4/8275, BIOS P70 Ver. 01.22 05/17/2018
    [  160.699672] Workqueue: events_long drm_dp_mst_link_probe_work [drm_kms_helper]
    [  160.700322] RIP: 0010:          (null)
    [  160.700920] Code: Bad RIP value.
    [  160.701541] RSP: 0018:ffffc9000029fc78 EFLAGS: 00010206
    [  160.702183] RAX: 0000000000000000 RBX: ffff8804440ed468 RCX: ffff8804440e9158
    [  160.702778] RDX: 0000000000000000 RSI: ffff8804556c5700 RDI: ffff8804440ed000
    [  160.703408] RBP: ffff880458e21800 R08: 0000000000000002 R09: 000000005fca0a25
    [  160.704002] R10: ffff88045a077a3d R11: ffff88045a077a3c R12: ffff8804440ed000
    [  160.704614] R13: ffff880458e21800 R14: ffff8804440e9000 R15: ffff8804440e9000
    [  160.705260] FS:  0000000000000000(0000) GS:ffff88045f280000(0000) knlGS:0000000000000000
    [  160.705854] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  160.706478] CR2: ffffffffffffffd6 CR3: 000000000200a001 CR4: 00000000003606e0
    [  160.707124] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  160.707724] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [  160.708372] Call Trace:
    [  160.708998]  ? dm_dp_add_mst_connector+0xed/0x1d0 [amdgpu]
    [  160.709625]  ? drm_dp_add_port+0x2fa/0x470 [drm_kms_helper]
    [  160.710284]  ? wake_up_q+0x54/0x70
    [  160.710877]  ? __mutex_unlock_slowpath.isra.18+0xb3/0x110
    [  160.711512]  ? drm_dp_dpcd_access+0xe7/0x110 [drm_kms_helper]
    [  160.712161]  ? drm_dp_send_link_address+0x155/0x1e0 [drm_kms_helper]
    [  160.712762]  ? drm_dp_check_and_send_link_address+0xa3/0xd0 [drm_kms_helper]
    [  160.713408]  ? drm_dp_mst_link_probe_work+0x4b/0x80 [drm_kms_helper]
    [  160.714013]  ? process_one_work+0x1a1/0x3a0
    [  160.714667]  ? worker_thread+0x30/0x380
    [  160.715326]  ? wq_update_unbound_numa+0x10/0x10
    [  160.715939]  ? kthread+0x112/0x130
    [  160.716591]  ? kthread_create_worker_on_cpu+0x70/0x70
    [  160.717262]  ? ret_from_fork+0x35/0x40
    [  160.717886] Modules linked in: amdgpu(O) vfat fat snd_hda_codec_generic joydev i915 chash gpu_sched ttm i2c_algo_bit drm_kms_helper snd_hda_codec_hdmi hp_wmi syscopyarea iTCO_wdt sysfillrect sparse_keymap sysimgblt fb_sys_fops snd_hda_intel usbhid wmi_bmof drm snd_hda_codec btusb snd_hda_core intel_rapl btrtl x86_pkg_temp_thermal btbcm btintel coretemp snd_pcm crc32_pclmul bluetooth psmouse snd_timer snd pcspkr i2c_i801 mei_me i2c_core soundcore mei tpm_tis wmi tpm_tis_core hp_accel ecdh_generic lis3lv02d tpm video rfkill acpi_pad input_polldev hp_wireless pcc_cpufreq crc32c_intel serio_raw tg3 xhci_pci xhci_hcd [last unloaded: amdgpu]
    [  160.720141] CR2: 0000000000000000
    
    Somehow the connector reusage DM was using for MST connectors managed to
    paper over this issue entirely; hence why this was never caught until
    now.
    
    [how]
    Since this code isn't used anywhere and seems useless anyway, we can
    just drop it entirely. This appears to fix the issue on my HP ZBook with
    an AMD WX4150.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 31126eb23a74..d02c32a1039c 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -285,12 +285,7 @@ dm_dp_create_fake_mst_encoder(struct amdgpu_dm_connector *connector)
 	struct amdgpu_device *adev = dev->dev_private;
 	struct amdgpu_encoder *amdgpu_encoder;
 	struct drm_encoder *encoder;
-	const struct drm_connector_helper_funcs *connector_funcs =
-		connector->base.helper_private;
-	struct drm_encoder *enc_master =
-		connector_funcs->best_encoder(&connector->base);
 
-	DRM_DEBUG_KMS("enc master is %p\n", enc_master);
 	amdgpu_encoder = kzalloc(sizeof(*amdgpu_encoder), GFP_KERNEL);
 	if (!amdgpu_encoder)
 		return NULL;

commit 0e6613e46fed29316f33acf86e1d1568288638b5
Author: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
Date:   Tue Oct 30 14:37:16 2018 -0400

    drm/amd/display: Drop reusing drm connector for MST
    
    [why]
    It is not safe to keep existing connector while entire topology
    has been removed. Could lead potential impact to uapi.
    Entirely unregister all the connectors on the topology,
    and use a new set of connectors when the topology is plugged back
    on.
    
    [How]
    Remove the drm connector entirely each time when the
    corresponding MST topology is gone.
    When hotunplug a connector (e.g., DP2)
    1. Remove connector from userspace.
    2. Drop it's reference.
    When hotplug back on:
    1. Detect new topology, and create new connectors.
    2. Notify userspace with sysfs hotplug event.
    3. Reprobe new connectors, and reassign CRTC from old (e.g., DP2)
    to new (e.g., DP3) connector.
    
    Signed-off-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 03e98967d6c2..31126eb23a74 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -320,25 +320,6 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 	struct amdgpu_device *adev = dev->dev_private;
 	struct amdgpu_dm_connector *aconnector;
 	struct drm_connector *connector;
-	struct drm_connector_list_iter conn_iter;
-
-	drm_connector_list_iter_begin(dev, &conn_iter);
-	drm_for_each_connector_iter(connector, &conn_iter) {
-		aconnector = to_amdgpu_dm_connector(connector);
-		if (aconnector->mst_port == master
-				&& !aconnector->port) {
-			DRM_INFO("DM_MST: reusing connector: %p [id: %d] [master: %p]\n",
-						aconnector, connector->base.id, aconnector->mst_port);
-
-			aconnector->port = port;
-			drm_connector_set_path_property(connector, pathprop);
-
-			drm_connector_list_iter_end(&conn_iter);
-			aconnector->mst_connected = true;
-			return &aconnector->base;
-		}
-	}
-	drm_connector_list_iter_end(&conn_iter);
 
 	aconnector = kzalloc(sizeof(*aconnector), GFP_KERNEL);
 	if (!aconnector)
@@ -387,8 +368,6 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 	 */
 	amdgpu_dm_connector_funcs_reset(connector);
 
-	aconnector->mst_connected = true;
-
 	DRM_INFO("DM_MST: added connector: %p [id: %d] [master: %p]\n",
 			aconnector, connector->base.id, aconnector->mst_port);
 
@@ -400,6 +379,9 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 static void dm_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 					struct drm_connector *connector)
 {
+	struct amdgpu_dm_connector *master = container_of(mgr, struct amdgpu_dm_connector, mst_mgr);
+	struct drm_device *dev = master->base.dev;
+	struct amdgpu_device *adev = dev->dev_private;
 	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
 
 	DRM_INFO("DM_MST: Disabling connector: %p [id: %d] [master: %p]\n",
@@ -413,7 +395,10 @@ static void dm_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 		aconnector->dc_sink = NULL;
 	}
 
-	aconnector->mst_connected = false;
+	drm_connector_unregister(connector);
+	if (adev->mode_info.rfbdev)
+		drm_fb_helper_remove_one_connector(&adev->mode_info.rfbdev->helper, connector);
+	drm_connector_put(connector);
 }
 
 static void dm_dp_mst_hotplug(struct drm_dp_mst_topology_mgr *mgr)
@@ -424,18 +409,10 @@ static void dm_dp_mst_hotplug(struct drm_dp_mst_topology_mgr *mgr)
 	drm_kms_helper_hotplug_event(dev);
 }
 
-static void dm_dp_mst_link_status_reset(struct drm_connector *connector)
-{
-	mutex_lock(&connector->dev->mode_config.mutex);
-	drm_connector_set_link_status_property(connector, DRM_MODE_LINK_STATUS_BAD);
-	mutex_unlock(&connector->dev->mode_config.mutex);
-}
-
 static void dm_dp_mst_register_connector(struct drm_connector *connector)
 {
 	struct drm_device *dev = connector->dev;
 	struct amdgpu_device *adev = dev->dev_private;
-	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
 
 	if (adev->mode_info.rfbdev)
 		drm_fb_helper_add_one_connector(&adev->mode_info.rfbdev->helper, connector);
@@ -443,9 +420,6 @@ static void dm_dp_mst_register_connector(struct drm_connector *connector)
 		DRM_ERROR("adev->mode_info.rfbdev is NULL\n");
 
 	drm_connector_register(connector);
-
-	if (aconnector->mst_connected)
-		dm_dp_mst_link_status_reset(connector);
 }
 
 static const struct drm_dp_mst_topology_cbs dm_mst_cbs = {

commit 8be17ac95f8451b51f636622d8d4b8674334f468
Author: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
Date:   Tue Oct 30 14:28:49 2018 -0400

    drm/amd/display: Cleanup MST non-atomic code workaround
    
    [why]
    It is not correct to touch aconnector within atomic_check.
    
    [How]
    It was added as workaround before, and no longer needed.
    
    Signed-off-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 03601d717fed..03e98967d6c2 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -205,40 +205,6 @@ static const struct drm_connector_funcs dm_dp_mst_connector_funcs = {
 	.atomic_get_property = amdgpu_dm_connector_atomic_get_property
 };
 
-void dm_dp_mst_dc_sink_create(struct drm_connector *connector)
-{
-	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
-	struct dc_sink *dc_sink;
-	struct dc_sink_init_data init_params = {
-			.link = aconnector->dc_link,
-			.sink_signal = SIGNAL_TYPE_DISPLAY_PORT_MST };
-
-	/* FIXME none of this is safe. we shouldn't touch aconnector here in
-	 * atomic_check
-	 */
-
-	/*
-	 * TODO: Need to further figure out why ddc.algo is NULL while MST port exists
-	 */
-	if (!aconnector->port || !aconnector->port->aux.ddc.algo)
-		return;
-
-	ASSERT(aconnector->edid);
-
-	dc_sink = dc_link_add_remote_sink(
-		aconnector->dc_link,
-		(uint8_t *)aconnector->edid,
-		(aconnector->edid->extensions + 1) * EDID_LENGTH,
-		&init_params);
-
-	dc_sink->priv = aconnector;
-	aconnector->dc_sink = dc_sink;
-
-	if (aconnector->dc_sink)
-		amdgpu_dm_update_freesync_caps(
-				connector, aconnector->edid);
-}
-
 static int dm_dp_mst_get_modes(struct drm_connector *connector)
 {
 	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);

commit 36c9c3c91128e2b892c9be0dd9ee9bd82cbe82ad
Merge: 0320ac5188ea 846311ae68f3
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 21 09:52:34 2018 +1000

    Merge branch 'drm-next-4.20' of git://people.freedesktop.org/~agd5f/linux into drm-next
    
    This is a new pull for drm-next on top of last weeks with the following
    changes:
    - Fixed 64 bit divide
    - Fixed vram type on vega20
    - Misc vega20 fixes
    - Misc DC fixes
    - Fix GDS/GWS/OA domain handling
    
    Previous changes from last week:
    amdgpu/kfd:
    - Picasso (new APU) support
    - Raven2 (new APU) support
    - Vega20 enablement
    - ACP powergating improvements
    - Add ABGR/XBGR display support
    - VCN JPEG engine support
    - Initial xGMI support
    - Use load balancing for engine scheduling
    - Lots of new documentation
    - Rework and clean up i2c and aux handling in DC
    - Add DP YCbCr 4:2:0 support in DC
    - Add DMCU firmware loading for Raven (used for ABM and PSR)
    - New debugfs features in DC
    - LVDS support in DC
    - Implement wave kill for gfx/compute (light weight reset for shaders)
    - Use AGP aperture to avoid gart mappings when possible
    - GPUVM performance improvements
    - Bulk moves for more efficient GPUVM LRU handling
    - Merge amdgpu and amdkfd into one module
    - Enable gfxoff and stutter mode on Raven
    - Misc cleanups
    
    Scheduler:
    - Load balancing support
    - Bug fixes
    
    ttm:
    - Bulk move functionality
    - Bug fixes
    
    radeon:
    - Misc cleanups
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Alex Deucher <alexdeucher@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180920150438.12693-1-alexander.deucher@amd.com

commit e86e894751f0420fbe05d834e02a6777c4b4ac3f
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Mon Aug 27 10:08:18 2018 +0200

    drm/amdgpu: add DisplayPort CEC-Tunneling-over-AUX support
    
    Add DisplayPort CEC-Tunneling-over-AUX support to amdgpu.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/de9586bb-151e-bae9-b8e3-14db107a60df@xs4all.nl

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 9a300732ba37..18a3a6e5ffa0 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -496,6 +496,8 @@ void amdgpu_dm_initialize_dp_connector(struct amdgpu_display_manager *dm,
 	aconnector->dm_dp_aux.ddc_service = aconnector->dc_link->ddc;
 
 	drm_dp_aux_register(&aconnector->dm_dp_aux.aux);
+	drm_dp_cec_register_connector(&aconnector->dm_dp_aux.aux,
+				      aconnector->base.name, dm->adev->dev);
 	aconnector->mst_mgr.cbs = &dm_mst_cbs;
 	drm_dp_mst_topology_mgr_init(
 		&aconnector->mst_mgr,

commit 98e6436d3af5fef7ca9b59d865dd5807ede36fb9
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Aug 21 14:40:28 2018 -0500

    drm/amd/display: Refactor FreeSync module
    
    Remove dependency on internal sink map and instead
    use existing stream and plane state
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 9a300732ba37..67683645ce2c 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -234,8 +234,9 @@ void dm_dp_mst_dc_sink_create(struct drm_connector *connector)
 	dc_sink->priv = aconnector;
 	aconnector->dc_sink = dc_sink;
 
-	amdgpu_dm_add_sink_to_freesync_module(
-			connector, aconnector->edid);
+	if (aconnector->dc_sink)
+		amdgpu_dm_update_freesync_caps(
+				connector, aconnector->edid);
 }
 
 static int dm_dp_mst_get_modes(struct drm_connector *connector)
@@ -275,8 +276,9 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 		aconnector->dc_sink = dc_sink;
 
 		if (aconnector->dc_sink)
-			amdgpu_dm_add_sink_to_freesync_module(
+			amdgpu_dm_update_freesync_caps(
 					connector, aconnector->edid);
+
 	}
 
 	drm_connector_update_edid_property(
@@ -439,7 +441,7 @@ static void dm_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 
 	aconnector->port = NULL;
 	if (aconnector->dc_sink) {
-		amdgpu_dm_remove_sink_from_freesync_module(connector);
+		amdgpu_dm_update_freesync_caps(connector, NULL);
 		dc_link_remove_remote_sink(aconnector->dc_link, aconnector->dc_sink);
 		dc_sink_release(aconnector->dc_sink);
 		aconnector->dc_sink = NULL;

commit 500775074f88d9cf5416bed2ca19592812d62c41
Merge: ef8e0ff97ae8 5c675bf2c67c
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jul 20 14:30:18 2018 +1000

    Merge branch 'drm-next-4.19' of git://people.freedesktop.org/~agd5f/linux into drm-next
    
    More features for 4.19:
    - Map processes to vmids for debugging GPUVM faults
    - Raven gfxoff fixes
    - Initial gfxoff support for vega12
    - Use defines for interrupt sources rather than magic numbers
    - DC aux fixes
    - Finish DC logging TODO
    - Add more DC debugfs interfaces for conformance testing
    - Add CRC support for DCN
    - Scheduler rework in preparation for load balancing
    - Unify common smu9 code
    - Clean up UVD instancing support
    - ttm cleanups
    - Misc fixes and cleanups
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180719194001.3488-1-alexander.deucher@amd.com

commit 084b3765ec4baf8b7de57e7dc1e1ba1b6905e9d9
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed May 9 16:26:17 2018 -0400

    drm/amd/display: Return aux replies directly to DRM
    
    Currently we still go through DC code that does error checking, retries,
    etc. There's no need for that since DRM already does that for us. This
    simplifies the code a bit and makes it easier to debug.
    
    This also ensures we correctly tell DRM how many bytes have actually
    been read, as we should. This allows DRM to correctly read the EDID on
    the Chamelium DP port.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index c74105758815..8348d4d46b30 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -80,52 +80,72 @@ static void log_dpcd(uint8_t type,
 static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 				  struct drm_dp_aux_msg *msg)
 {
-	enum i2c_mot_mode mot = (msg->request & DP_AUX_I2C_MOT) ?
-		I2C_MOT_TRUE : I2C_MOT_FALSE;
-	enum ddc_result res;
+	ssize_t result = 0;
+	enum i2caux_transaction_action action;
+	enum aux_transaction_type type;
 
 	if (WARN_ON(msg->size > 16))
 		return -E2BIG;
 
 	switch (msg->request & ~DP_AUX_I2C_MOT) {
 	case DP_AUX_NATIVE_READ:
-		res = dal_ddc_service_read_dpcd_data(
-				TO_DM_AUX(aux)->ddc_service,
-				false,
-				I2C_MOT_UNDEF,
-				msg->address,
-				msg->buffer,
-				msg->size);
+		type = AUX_TRANSACTION_TYPE_DP;
+		action = I2CAUX_TRANSACTION_ACTION_DP_READ;
+
+		result = dc_link_aux_transfer(TO_DM_AUX(aux)->ddc_service,
+					      msg->address,
+					      &msg->reply,
+					      msg->buffer,
+					      msg->size,
+					      type,
+					      action);
 		break;
 	case DP_AUX_NATIVE_WRITE:
-		res = dal_ddc_service_write_dpcd_data(
-				TO_DM_AUX(aux)->ddc_service,
-				false,
-				I2C_MOT_UNDEF,
-				msg->address,
-				msg->buffer,
-				msg->size);
+		type = AUX_TRANSACTION_TYPE_DP;
+		action = I2CAUX_TRANSACTION_ACTION_DP_WRITE;
+
+		dc_link_aux_transfer(TO_DM_AUX(aux)->ddc_service,
+				     msg->address,
+				     &msg->reply,
+				     msg->buffer,
+				     msg->size,
+				     type,
+				     action);
+		result = msg->size;
 		break;
 	case DP_AUX_I2C_READ:
-		res = dal_ddc_service_read_dpcd_data(
-				TO_DM_AUX(aux)->ddc_service,
-				true,
-				mot,
-				msg->address,
-				msg->buffer,
-				msg->size);
+		type = AUX_TRANSACTION_TYPE_I2C;
+		if (msg->request & DP_AUX_I2C_MOT)
+			action = I2CAUX_TRANSACTION_ACTION_I2C_READ_MOT;
+		else
+			action = I2CAUX_TRANSACTION_ACTION_I2C_READ;
+
+		result = dc_link_aux_transfer(TO_DM_AUX(aux)->ddc_service,
+					      msg->address,
+					      &msg->reply,
+					      msg->buffer,
+					      msg->size,
+					      type,
+					      action);
 		break;
 	case DP_AUX_I2C_WRITE:
-		res = dal_ddc_service_write_dpcd_data(
-				TO_DM_AUX(aux)->ddc_service,
-				true,
-				mot,
-				msg->address,
-				msg->buffer,
-				msg->size);
+		type = AUX_TRANSACTION_TYPE_I2C;
+		if (msg->request & DP_AUX_I2C_MOT)
+			action = I2CAUX_TRANSACTION_ACTION_I2C_WRITE_MOT;
+		else
+			action = I2CAUX_TRANSACTION_ACTION_I2C_WRITE;
+
+		dc_link_aux_transfer(TO_DM_AUX(aux)->ddc_service,
+				     msg->address,
+				     &msg->reply,
+				     msg->buffer,
+				     msg->size,
+				     type,
+				     action);
+		result = msg->size;
 		break;
 	default:
-		return 0;
+		return -EINVAL;
 	}
 
 #ifdef TRACE_DPCD
@@ -136,7 +156,10 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 		 r == DDC_RESULT_SUCESSFULL);
 #endif
 
-	return msg->size;
+	if (result < 0) /* DC doesn't know about kernel error codes */
+		result = -EIO;
+
+	return result;
 }
 
 static enum drm_connector_status

commit 013fc06ea4260574755541773ece1a76a8017de6
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Jul 6 10:54:33 2018 -0400

    Revert "drm/amd/display: make dm_dp_aux_transfer return payload bytes instead of size"
    
    This reverts commit cc195141133ac3e767d930bedd8294ceebf1f10b.
    
    This commit was problematic on other OSes. The real solution is to
    leave all the error checking to DRM and don't do it in DC, which is
    addressed by "Return aux replies directly to DRM" later in this patchset.
    
    v2: Add reason for revert.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index ace9ad578ca0..c74105758815 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -83,21 +83,20 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 	enum i2c_mot_mode mot = (msg->request & DP_AUX_I2C_MOT) ?
 		I2C_MOT_TRUE : I2C_MOT_FALSE;
 	enum ddc_result res;
-	ssize_t read_bytes;
 
 	if (WARN_ON(msg->size > 16))
 		return -E2BIG;
 
 	switch (msg->request & ~DP_AUX_I2C_MOT) {
 	case DP_AUX_NATIVE_READ:
-		read_bytes = dal_ddc_service_read_dpcd_data(
+		res = dal_ddc_service_read_dpcd_data(
 				TO_DM_AUX(aux)->ddc_service,
 				false,
 				I2C_MOT_UNDEF,
 				msg->address,
 				msg->buffer,
 				msg->size);
-		return read_bytes;
+		break;
 	case DP_AUX_NATIVE_WRITE:
 		res = dal_ddc_service_write_dpcd_data(
 				TO_DM_AUX(aux)->ddc_service,
@@ -108,14 +107,14 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 				msg->size);
 		break;
 	case DP_AUX_I2C_READ:
-		read_bytes = dal_ddc_service_read_dpcd_data(
+		res = dal_ddc_service_read_dpcd_data(
 				TO_DM_AUX(aux)->ddc_service,
 				true,
 				mot,
 				msg->address,
 				msg->buffer,
 				msg->size);
-		return read_bytes;
+		break;
 	case DP_AUX_I2C_WRITE:
 		res = dal_ddc_service_write_dpcd_data(
 				TO_DM_AUX(aux)->ddc_service,

commit 37b5fcfde879652bac7fc4b18c5f242f2544e9ea
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Jul 6 10:54:18 2018 -0400

    Revert "drm/amd/display: Don't return ddc result and read_bytes in same return value"
    
    This reverts commit 8a61bc085ffab3071c59efcbeff4044c034e7490.
    
    Need to revert "make dm_dp_aux_transfer return payload bytes instead of
    size", which this commit is based on. That commit was problematic on
    other OSes. The real solution is to leave all the error checking to DRM
    and don't do it in DC, which is addressed by "Return aux replies
    directly to DRM" later in this patchset.
    
    v2: Add reason for revert.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 4304d9e408b8..ace9ad578ca0 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -83,22 +83,21 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 	enum i2c_mot_mode mot = (msg->request & DP_AUX_I2C_MOT) ?
 		I2C_MOT_TRUE : I2C_MOT_FALSE;
 	enum ddc_result res;
-	uint32_t read_bytes = msg->size;
+	ssize_t read_bytes;
 
 	if (WARN_ON(msg->size > 16))
 		return -E2BIG;
 
 	switch (msg->request & ~DP_AUX_I2C_MOT) {
 	case DP_AUX_NATIVE_READ:
-		res = dal_ddc_service_read_dpcd_data(
+		read_bytes = dal_ddc_service_read_dpcd_data(
 				TO_DM_AUX(aux)->ddc_service,
 				false,
 				I2C_MOT_UNDEF,
 				msg->address,
 				msg->buffer,
-				msg->size,
-				&read_bytes);
-		break;
+				msg->size);
+		return read_bytes;
 	case DP_AUX_NATIVE_WRITE:
 		res = dal_ddc_service_write_dpcd_data(
 				TO_DM_AUX(aux)->ddc_service,
@@ -109,15 +108,14 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 				msg->size);
 		break;
 	case DP_AUX_I2C_READ:
-		res = dal_ddc_service_read_dpcd_data(
+		read_bytes = dal_ddc_service_read_dpcd_data(
 				TO_DM_AUX(aux)->ddc_service,
 				true,
 				mot,
 				msg->address,
 				msg->buffer,
-				msg->size,
-				&read_bytes);
-		break;
+				msg->size);
+		return read_bytes;
 	case DP_AUX_I2C_WRITE:
 		res = dal_ddc_service_write_dpcd_data(
 				TO_DM_AUX(aux)->ddc_service,
@@ -139,9 +137,7 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 		 r == DDC_RESULT_SUCESSFULL);
 #endif
 
-	if (res != DDC_RESULT_SUCESSFULL)
-		return -EIO;
-	return read_bytes;
+	return msg->size;
 }
 
 static enum drm_connector_status

commit 97e14fbeb53fe060c5f6a7a07e37fd24c087ed0c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jul 9 10:40:08 2018 +0200

    drm: drop _mode_ from remaining connector functions
    
    Since there's very few callers of these I've decided to do them all in
    one patch. With this the unecessarily long drm_mode_connector_ prefix
    is gone from the codebase! The only exception being struct
    drm_mode_connector_set_property, which is part of the uapi so can't be
    renamed.
    
    Again done with sed+some manual fixups for indent issues.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180709084016.23750-8-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 581bb75d08eb..65f210d3497b 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -345,7 +345,7 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 						aconnector, connector->base.id, aconnector->mst_port);
 
 			aconnector->port = port;
-			drm_mode_connector_set_path_property(connector, pathprop);
+			drm_connector_set_path_property(connector, pathprop);
 
 			drm_connector_list_iter_end(&conn_iter);
 			aconnector->mst_connected = true;
@@ -393,7 +393,7 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 		dev->mode_config.tile_property,
 		0);
 
-	drm_mode_connector_set_path_property(connector, pathprop);
+	drm_connector_set_path_property(connector, pathprop);
 
 	/*
 	 * Initialize connector state before adding the connectror to drm and
@@ -441,7 +441,7 @@ static void dm_dp_mst_hotplug(struct drm_dp_mst_topology_mgr *mgr)
 static void dm_dp_mst_link_status_reset(struct drm_connector *connector)
 {
 	mutex_lock(&connector->dev->mode_config.mutex);
-	drm_mode_connector_set_link_status_property(connector, DRM_MODE_LINK_STATUS_BAD);
+	drm_connector_set_link_status_property(connector, DRM_MODE_LINK_STATUS_BAD);
 	mutex_unlock(&connector->dev->mode_config.mutex);
 }
 

commit c555f02371c338b06752577aebf738dbdb6907bd
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jul 9 10:40:06 2018 +0200

    drm: drop _mode_ from update_edit_property()
    
    Just makes it longer, and for most things in drm_connector.[hc] we
    just use the drm_connector_ prefix. Done with sed + a bit of manual
    fixup for the indenting.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180709084016.23750-6-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 4304d9e408b8..581bb75d08eb 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -233,7 +233,7 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 		edid = drm_dp_mst_get_edid(connector, &aconnector->mst_port->mst_mgr, aconnector->port);
 
 		if (!edid) {
-			drm_mode_connector_update_edid_property(
+			drm_connector_update_edid_property(
 				&aconnector->base,
 				NULL);
 			return ret;
@@ -261,7 +261,7 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 					connector, aconnector->edid);
 	}
 
-	drm_mode_connector_update_edid_property(
+	drm_connector_update_edid_property(
 					&aconnector->base, aconnector->edid);
 
 	ret = drm_add_edid_modes(connector, aconnector->edid);

commit 018d82e5f02ef3583411bcaa4e00c69786f46f19
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Apr 24 10:49:20 2018 -0400

    drm/amd/display: Don't return ddc result and read_bytes in same return value
    
    The two ranges overlap.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index ace9ad578ca0..4304d9e408b8 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -83,21 +83,22 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 	enum i2c_mot_mode mot = (msg->request & DP_AUX_I2C_MOT) ?
 		I2C_MOT_TRUE : I2C_MOT_FALSE;
 	enum ddc_result res;
-	ssize_t read_bytes;
+	uint32_t read_bytes = msg->size;
 
 	if (WARN_ON(msg->size > 16))
 		return -E2BIG;
 
 	switch (msg->request & ~DP_AUX_I2C_MOT) {
 	case DP_AUX_NATIVE_READ:
-		read_bytes = dal_ddc_service_read_dpcd_data(
+		res = dal_ddc_service_read_dpcd_data(
 				TO_DM_AUX(aux)->ddc_service,
 				false,
 				I2C_MOT_UNDEF,
 				msg->address,
 				msg->buffer,
-				msg->size);
-		return read_bytes;
+				msg->size,
+				&read_bytes);
+		break;
 	case DP_AUX_NATIVE_WRITE:
 		res = dal_ddc_service_write_dpcd_data(
 				TO_DM_AUX(aux)->ddc_service,
@@ -108,14 +109,15 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 				msg->size);
 		break;
 	case DP_AUX_I2C_READ:
-		read_bytes = dal_ddc_service_read_dpcd_data(
+		res = dal_ddc_service_read_dpcd_data(
 				TO_DM_AUX(aux)->ddc_service,
 				true,
 				mot,
 				msg->address,
 				msg->buffer,
-				msg->size);
-		return read_bytes;
+				msg->size,
+				&read_bytes);
+		break;
 	case DP_AUX_I2C_WRITE:
 		res = dal_ddc_service_write_dpcd_data(
 				TO_DM_AUX(aux)->ddc_service,
@@ -137,7 +139,9 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 		 r == DDC_RESULT_SUCESSFULL);
 #endif
 
-	return msg->size;
+	if (res != DDC_RESULT_SUCESSFULL)
+		return -EIO;
+	return read_bytes;
 }
 
 static enum drm_connector_status

commit 7ad35721e7d5a5b56a4eddcdd9920c3c1e51ae4c
Author: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
Date:   Tue Apr 17 14:39:09 2018 -0400

    drm/amd/display: Check dc_sink every time in MST hotplug
    
    Extended fix to: "Don't read EDID in atomic_check"
    
    Fix issue of missing dc_sink in .mode_valid in hot plug routine.
    
    Need to check dc_sink everytime in .get_modes hook after checking
    edid, since edid is not getting removed in hot unplug but dc_sink
    doesn't.
    
    Signed-off-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 8c1d084429dc..ace9ad578ca0 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -226,10 +226,6 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 
 	if (!aconnector->edid) {
 		struct edid *edid;
-		struct dc_sink *dc_sink;
-		struct dc_sink_init_data init_params = {
-				.link = aconnector->dc_link,
-				.sink_signal = SIGNAL_TYPE_DISPLAY_PORT_MST };
 		edid = drm_dp_mst_get_edid(connector, &aconnector->mst_port->mst_mgr, aconnector->port);
 
 		if (!edid) {
@@ -240,11 +236,17 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 		}
 
 		aconnector->edid = edid;
+	}
 
+	if (!aconnector->dc_sink) {
+		struct dc_sink *dc_sink;
+		struct dc_sink_init_data init_params = {
+				.link = aconnector->dc_link,
+				.sink_signal = SIGNAL_TYPE_DISPLAY_PORT_MST };
 		dc_sink = dc_link_add_remote_sink(
 			aconnector->dc_link,
-			(uint8_t *)edid,
-			(edid->extensions + 1) * EDID_LENGTH,
+			(uint8_t *)aconnector->edid,
+			(aconnector->edid->extensions + 1) * EDID_LENGTH,
 			&init_params);
 
 		dc_sink->priv = aconnector;
@@ -252,7 +254,7 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 
 		if (aconnector->dc_sink)
 			amdgpu_dm_add_sink_to_freesync_module(
-					connector, edid);
+					connector, aconnector->edid);
 	}
 
 	drm_mode_connector_update_edid_property(

commit d973f8535f033fac1599bd5eae6835e6bb304da3
Author: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
Date:   Tue Apr 17 13:49:48 2018 -0400

    drm/amd/display: Update MST edid property every time
    
    Extended fix to: "Don't read EDID in atomic_check"
    
    Fix display property not observed in GUI display after hot plug.
    
    Call drm_mode_connector_update_edid_property every time in
    .get_modes hook, due to the fact that edid property is getting
    removed from usermode ioctl DRM_IOCTL_MODE_GETCONNECTOR each time
    in hot unplug.
    
    Signed-off-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 305292a9ff80..8c1d084429dc 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -253,11 +253,11 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 		if (aconnector->dc_sink)
 			amdgpu_dm_add_sink_to_freesync_module(
 					connector, edid);
-
-		drm_mode_connector_update_edid_property(
-						&aconnector->base, edid);
 	}
 
+	drm_mode_connector_update_edid_property(
+					&aconnector->base, aconnector->edid);
+
 	ret = drm_add_edid_modes(connector, aconnector->edid);
 
 	return ret;

commit c7b8de00384be49dc1617a838b0ce89a0235f319
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Mar 8 22:05:35 2018 -0500

    drm/amd/display: Don't read EDID in atomic_check
    
    We shouldn't attempt to read EDID in atomic_check. We really shouldn't
    even be modifying the connector object, or any other non-state object,
    but this is a start at least.
    
    Moving EDID cleanup to dm_dp_mst_connector_destroy from
    dm_dp_destroy_mst_connector to ensure the EDID is still available for
    headless mode.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 8291d74f26bc..305292a9ff80 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -161,6 +161,11 @@ dm_dp_mst_connector_destroy(struct drm_connector *connector)
 	struct amdgpu_dm_connector *amdgpu_dm_connector = to_amdgpu_dm_connector(connector);
 	struct amdgpu_encoder *amdgpu_encoder = amdgpu_dm_connector->mst_encoder;
 
+	if (amdgpu_dm_connector->edid) {
+		kfree(amdgpu_dm_connector->edid);
+		amdgpu_dm_connector->edid = NULL;
+	}
+
 	drm_encoder_cleanup(&amdgpu_encoder->base);
 	kfree(amdgpu_encoder);
 	drm_connector_cleanup(connector);
@@ -181,28 +186,22 @@ static const struct drm_connector_funcs dm_dp_mst_connector_funcs = {
 void dm_dp_mst_dc_sink_create(struct drm_connector *connector)
 {
 	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
-	struct edid *edid;
 	struct dc_sink *dc_sink;
 	struct dc_sink_init_data init_params = {
 			.link = aconnector->dc_link,
 			.sink_signal = SIGNAL_TYPE_DISPLAY_PORT_MST };
 
+	/* FIXME none of this is safe. we shouldn't touch aconnector here in
+	 * atomic_check
+	 */
+
 	/*
 	 * TODO: Need to further figure out why ddc.algo is NULL while MST port exists
 	 */
 	if (!aconnector->port || !aconnector->port->aux.ddc.algo)
 		return;
 
-	edid = drm_dp_mst_get_edid(connector, &aconnector->mst_port->mst_mgr, aconnector->port);
-
-	if (!edid) {
-		drm_mode_connector_update_edid_property(
-			&aconnector->base,
-			NULL);
-		return;
-	}
-
-	aconnector->edid = edid;
+	ASSERT(aconnector->edid);
 
 	dc_sink = dc_link_add_remote_sink(
 		aconnector->dc_link,
@@ -215,9 +214,6 @@ void dm_dp_mst_dc_sink_create(struct drm_connector *connector)
 
 	amdgpu_dm_add_sink_to_freesync_module(
 			connector, aconnector->edid);
-
-	drm_mode_connector_update_edid_property(
-					&aconnector->base, aconnector->edid);
 }
 
 static int dm_dp_mst_get_modes(struct drm_connector *connector)
@@ -424,14 +420,6 @@ static void dm_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 		dc_sink_release(aconnector->dc_sink);
 		aconnector->dc_sink = NULL;
 	}
-	if (aconnector->edid) {
-		kfree(aconnector->edid);
-		aconnector->edid = NULL;
-	}
-
-	drm_mode_connector_update_edid_property(
-			&aconnector->base,
-			NULL);
 
 	aconnector->mst_connected = false;
 }

commit 2a7b58293dd0f188d27491a8d07b145a9487e172
Author: Shirish S <shirish.s@amd.com>
Date:   Tue Mar 13 11:55:11 2018 +0530

    drm/amd/display: Check msg->size before starting aux transfer
    
    This patch adds an essential check related to the size of the
    payload to be transferred via aux channel.
    
    Without this check dal_ddc_service_read_dpcd_data() is fed with
    inappropriate payload size leading to deadlocks.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 39cfe0fbf1b9..8291d74f26bc 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -85,6 +85,9 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 	enum ddc_result res;
 	ssize_t read_bytes;
 
+	if (WARN_ON(msg->size > 16))
+		return -E2BIG;
+
 	switch (msg->request & ~DP_AUX_I2C_MOT) {
 	case DP_AUX_NATIVE_READ:
 		read_bytes = dal_ddc_service_read_dpcd_data(

commit cc195141133ac3e767d930bedd8294ceebf1f10b
Author: Shirish S <shirish.s@amd.com>
Date:   Fri Feb 23 16:10:13 2018 +0530

    drm/amd/display: make dm_dp_aux_transfer return payload bytes instead of size
    
    The drm layer expects aux->transfer() to return the payload bytes read.
    Currently dm_dp_aux_transfer() returns the payload size which does not
    gets updated during the read, hence not giving the right data for the
    drm layer to pars edid. This leads to the drm layer to conclude as the
    edid is BAD and hence some monitors/devices dont get detected properly.
    
    This patch changes the return type of dm_dp_aux_transfer() to actual
    bytes read during DP_AUX_NATIVE_READ & DP_AUX_I2C_READ.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 1e8a21b67df7..39cfe0fbf1b9 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -83,17 +83,18 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 	enum i2c_mot_mode mot = (msg->request & DP_AUX_I2C_MOT) ?
 		I2C_MOT_TRUE : I2C_MOT_FALSE;
 	enum ddc_result res;
+	ssize_t read_bytes;
 
 	switch (msg->request & ~DP_AUX_I2C_MOT) {
 	case DP_AUX_NATIVE_READ:
-		res = dal_ddc_service_read_dpcd_data(
+		read_bytes = dal_ddc_service_read_dpcd_data(
 				TO_DM_AUX(aux)->ddc_service,
 				false,
 				I2C_MOT_UNDEF,
 				msg->address,
 				msg->buffer,
 				msg->size);
-		break;
+		return read_bytes;
 	case DP_AUX_NATIVE_WRITE:
 		res = dal_ddc_service_write_dpcd_data(
 				TO_DM_AUX(aux)->ddc_service,
@@ -104,14 +105,14 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
 				msg->size);
 		break;
 	case DP_AUX_I2C_READ:
-		res = dal_ddc_service_read_dpcd_data(
+		read_bytes = dal_ddc_service_read_dpcd_data(
 				TO_DM_AUX(aux)->ddc_service,
 				true,
 				mot,
 				msg->address,
 				msg->buffer,
 				msg->size);
-		break;
+		return read_bytes;
 	case DP_AUX_I2C_WRITE:
 		res = dal_ddc_service_write_dpcd_data(
 				TO_DM_AUX(aux)->ddc_service,

commit 978cc9728f42287c3144cc6524f095bf2c964a81
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Dec 13 15:41:50 2017 -0500

    drm/amd/display: Drop dm_connector_update_modes
    
    It's unused since the drm_edid_to_eld cleanup
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 93421dad21bd..1e8a21b67df7 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -174,12 +174,6 @@ static const struct drm_connector_funcs dm_dp_mst_connector_funcs = {
 	.atomic_get_property = amdgpu_dm_connector_atomic_get_property
 };
 
-static int dm_connector_update_modes(struct drm_connector *connector,
-				struct edid *edid)
-{
-	return drm_add_edid_modes(connector, edid);
-}
-
 void dm_dp_mst_dc_sink_create(struct drm_connector *connector)
 {
 	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
@@ -228,7 +222,7 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 	int ret = 0;
 
 	if (!aconnector)
-		return dm_connector_update_modes(connector, NULL);
+		return drm_add_edid_modes(connector, NULL);
 
 	if (!aconnector->edid) {
 		struct edid *edid;
@@ -264,7 +258,7 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 						&aconnector->base, edid);
 	}
 
-	ret = dm_connector_update_modes(connector, aconnector->edid);
+	ret = drm_add_edid_modes(connector, aconnector->edid);
 
 	return ret;
 }

commit 7deff5454a8c482e30faf3dc5b5cf92d9b686b49
Author: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
Date:   Tue Dec 12 17:33:57 2017 -0500

    drm/amd/display: Fix topology change issue in MST rehook
    
    When topology changed and rehook up MST display to the same DP
    connector, need to take care of drm_dp_mst_port object.
    
    Due to the topology is changed, drm_dp_mst_port and corresponding
    i2c_algorithm object could be NULL in such situation.
    
    Signed-off-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index f3d87f418d2e..93421dad21bd 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -189,6 +189,12 @@ void dm_dp_mst_dc_sink_create(struct drm_connector *connector)
 			.link = aconnector->dc_link,
 			.sink_signal = SIGNAL_TYPE_DISPLAY_PORT_MST };
 
+	/*
+	 * TODO: Need to further figure out why ddc.algo is NULL while MST port exists
+	 */
+	if (!aconnector->port || !aconnector->port->aux.ddc.algo)
+		return;
+
 	edid = drm_dp_mst_get_edid(connector, &aconnector->mst_port->mst_mgr, aconnector->port);
 
 	if (!edid) {

commit 391ef035200f8c3c808fcb91deb86e605419caa7
Author: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
Date:   Fri Dec 1 13:26:05 2017 -0500

    drm/amd/display: Fix rehook MST display not light back on
    
    Original applied dm_restore_drm_connector_state() has got removed.
    Set link status to BAD before hotplug() event could trigger
    another modeset from userspace.
    
    The fix "Fix MST daisy chain SST not light up" commit makes so it is trying
    to create a stream prior to dc_sink. That makes dc_sink is not present in
    create_stream_for_sink().
    
    Signed-off-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 707928b88448..f3d87f418d2e 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -180,6 +180,42 @@ static int dm_connector_update_modes(struct drm_connector *connector,
 	return drm_add_edid_modes(connector, edid);
 }
 
+void dm_dp_mst_dc_sink_create(struct drm_connector *connector)
+{
+	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
+	struct edid *edid;
+	struct dc_sink *dc_sink;
+	struct dc_sink_init_data init_params = {
+			.link = aconnector->dc_link,
+			.sink_signal = SIGNAL_TYPE_DISPLAY_PORT_MST };
+
+	edid = drm_dp_mst_get_edid(connector, &aconnector->mst_port->mst_mgr, aconnector->port);
+
+	if (!edid) {
+		drm_mode_connector_update_edid_property(
+			&aconnector->base,
+			NULL);
+		return;
+	}
+
+	aconnector->edid = edid;
+
+	dc_sink = dc_link_add_remote_sink(
+		aconnector->dc_link,
+		(uint8_t *)aconnector->edid,
+		(aconnector->edid->extensions + 1) * EDID_LENGTH,
+		&init_params);
+
+	dc_sink->priv = aconnector;
+	aconnector->dc_sink = dc_sink;
+
+	amdgpu_dm_add_sink_to_freesync_module(
+			connector, aconnector->edid);
+
+	drm_mode_connector_update_edid_property(
+					&aconnector->base, aconnector->edid);
+}
+
 static int dm_dp_mst_get_modes(struct drm_connector *connector)
 {
 	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
@@ -306,6 +342,7 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 			drm_mode_connector_set_path_property(connector, pathprop);
 
 			drm_connector_list_iter_end(&conn_iter);
+			aconnector->mst_connected = true;
 			return &aconnector->base;
 		}
 	}
@@ -358,6 +395,8 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 	 */
 	amdgpu_dm_connector_funcs_reset(connector);
 
+	aconnector->mst_connected = true;
+
 	DRM_INFO("DM_MST: added connector: %p [id: %d] [master: %p]\n",
 			aconnector, connector->base.id, aconnector->mst_port);
 
@@ -389,6 +428,8 @@ static void dm_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 	drm_mode_connector_update_edid_property(
 			&aconnector->base,
 			NULL);
+
+	aconnector->mst_connected = false;
 }
 
 static void dm_dp_mst_hotplug(struct drm_dp_mst_topology_mgr *mgr)
@@ -399,10 +440,18 @@ static void dm_dp_mst_hotplug(struct drm_dp_mst_topology_mgr *mgr)
 	drm_kms_helper_hotplug_event(dev);
 }
 
+static void dm_dp_mst_link_status_reset(struct drm_connector *connector)
+{
+	mutex_lock(&connector->dev->mode_config.mutex);
+	drm_mode_connector_set_link_status_property(connector, DRM_MODE_LINK_STATUS_BAD);
+	mutex_unlock(&connector->dev->mode_config.mutex);
+}
+
 static void dm_dp_mst_register_connector(struct drm_connector *connector)
 {
 	struct drm_device *dev = connector->dev;
 	struct amdgpu_device *adev = dev->dev_private;
+	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
 
 	if (adev->mode_info.rfbdev)
 		drm_fb_helper_add_one_connector(&adev->mode_info.rfbdev->helper, connector);
@@ -411,6 +460,8 @@ static void dm_dp_mst_register_connector(struct drm_connector *connector)
 
 	drm_connector_register(connector);
 
+	if (aconnector->mst_connected)
+		dm_dp_mst_link_status_reset(connector);
 }
 
 static const struct drm_dp_mst_topology_cbs dm_mst_cbs = {

commit 2c1c55cb75a9c72f9726fabb8c3607947711a8df
Merge: ae64f9bd1d36 2f51be0945b9
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Dec 4 05:38:52 2017 +1000

    Merge tag 'drm-misc-next-2017-11-30' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    Cross-subsystem Changes:
    
    - device tree doc for the Mitsubishi AA070MC01 and Tianma TM070RVHG71
    panels (Lukasz Majewski) and for a 2nd endpoint on stm32 (Philippe Cornu)
    
    Core Changes:
    
    The most important changes are:
    
    - Add drm_driver .last_close and .output_poll_changed helpers to reduce
    fbdev emulation footprint in drivers (Noralf)
    - Fix plane clipping in core and for vmwgfx (Ville)
    
    Then we have a bunch of of improvement for print and debug such as the
    addition of a framebuffer debugfs file. ELD connector, HDMI and
    improvements.  And a bunch of misc improvements, clean ups and style
    changes and doc updates
    
    [airlied: drop eld bits from amdgpu_dm]
    
    Driver Changes:
    
    - sii8620: filter unsupported modes and add DVI mode support (Maciej Purski)
    - rockchip: analogix_dp: Remove unnecessary init code (Jeffy Chen)
    - virtio, cirrus: add fb create_handle support to enable screenshots(Lepton Wu)
    - virtio: replace reference/unreference with get/put (Aastha Gupta)
    - vc4, gma500: Convert timers to use timer_setup() (Kees Cook)
    - vc4: Reject HDMI modes with too high of clocks (Eric)
    - vc4: Add support for more pixel formats (Dave Stevenson)
    - stm: dsi: Rename driver name to "stm32-display-dsi" (Philippe Cornu)
    - stm: ltdc: add a 2nd endpoint (Philippe Cornu)
    - via: use monotonic time for VIA_WAIT_IRQ (Arnd Bergmann)
    
    * tag 'drm-misc-next-2017-11-30' of git://anongit.freedesktop.org/drm/drm-misc: (96 commits)
      drm/bridge: tc358767: add copyright lines
      MAINTAINERS: change maintainer for Rockchip drm drivers
      drm/vblank: Fix vblank timestamp debugs
      drm/via: use monotonic time for VIA_WAIT_IRQ
      dma-buf: Fix ifnullfree.cocci warnings
      drm/printer: Add drm_vprintf()
      drm/edid: Allow HDMI infoframe without VIC or S3D
      video/hdmi: Allow "empty" HDMI infoframes
      dma-buf/fence: Fix lock inversion within dma-fence-array
      drm/sti: Handle return value of platform_get_irq_byname
      drm/vc4: Add support for NV21 and NV61.
      drm/vc4: Use .pixel_order instead of custom .flip_cbcr
      drm/vc4: Add support for DRM_FORMAT_RGB888 and DRM_FORMAT_BGR888
      drm: Move drm_plane_helper_check_state() into drm_atomic_helper.c
      drm: Check crtc_state->enable rather than crtc->enabled in drm_plane_helper_check_state()
      drm/vmwgfx: Try to fix plane clipping
      drm/vmwgfx: Use drm_plane_helper_check_state()
      drm/vmwgfx: Remove bogus crtc coords vs fb size check
      gpu: gma500: remove unneeded DRIVER_LICENSE #define
      drm: don't link DP aux i2c adapter to the hardware device node
      ...

commit 4fc6f65965481bd2cdb8827a6fd991ed076b1006
Author: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
Date:   Fri Nov 3 14:19:06 2017 -0400

    drm/amd/display: Miss register MST encoder cbs
    
    It is to fix: MST display failed to resume from S3
    
    Need to properly setup MST encoder cbs. Otherwise drm_device
    encoder doesn't register its own cbs, leading to NULL
    encoder->funcs in drm_atomic_helper_resume().
    
    Signed-off-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 3b05da7a90e8..f8efb98b1fa7 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -245,6 +245,16 @@ static const struct drm_connector_helper_funcs dm_dp_mst_connector_helper_funcs
 	.best_encoder = dm_mst_best_encoder,
 };
 
+static void amdgpu_dm_encoder_destroy(struct drm_encoder *encoder)
+{
+	drm_encoder_cleanup(encoder);
+	kfree(encoder);
+}
+
+static const struct drm_encoder_funcs amdgpu_dm_encoder_funcs = {
+	.destroy = amdgpu_dm_encoder_destroy,
+};
+
 static struct amdgpu_encoder *
 dm_dp_create_fake_mst_encoder(struct amdgpu_dm_connector *connector)
 {
@@ -268,7 +278,7 @@ dm_dp_create_fake_mst_encoder(struct amdgpu_dm_connector *connector)
 	drm_encoder_init(
 		dev,
 		&amdgpu_encoder->base,
-		NULL,
+		&amdgpu_dm_encoder_funcs,
 		DRM_MODE_ENCODER_DPMST,
 		NULL);
 

commit 365c7c975dcd1a2158ed33dab76c1d308f9f9906
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Thu Sep 28 16:58:32 2017 -0400

    drm/amd/display: Remove drm_modeset_lock in MST code
    
    Locks are no longer needed since the drm framework takes care of
    correct locking.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 382f499cb60d..3b05da7a90e8 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -287,9 +287,10 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 	struct amdgpu_device *adev = dev->dev_private;
 	struct amdgpu_dm_connector *aconnector;
 	struct drm_connector *connector;
+	struct drm_connector_list_iter conn_iter;
 
-	drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
-	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+	drm_connector_list_iter_begin(dev, &conn_iter);
+	drm_for_each_connector_iter(connector, &conn_iter) {
 		aconnector = to_amdgpu_dm_connector(connector);
 		if (aconnector->mst_port == master
 				&& !aconnector->port) {
@@ -299,11 +300,11 @@ dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
 			aconnector->port = port;
 			drm_mode_connector_set_path_property(connector, pathprop);
 
-			drm_modeset_unlock(&dev->mode_config.connection_mutex);
+			drm_connector_list_iter_end(&conn_iter);
 			return &aconnector->base;
 		}
 	}
-	drm_modeset_unlock(&dev->mode_config.connection_mutex);
+	drm_connector_list_iter_end(&conn_iter);
 
 	aconnector = kzalloc(sizeof(*aconnector), GFP_KERNEL);
 	if (!aconnector)
@@ -398,14 +399,11 @@ static void dm_dp_mst_register_connector(struct drm_connector *connector)
 	struct drm_device *dev = connector->dev;
 	struct amdgpu_device *adev = dev->dev_private;
 
-	drm_modeset_lock_all(dev);
 	if (adev->mode_info.rfbdev)
 		drm_fb_helper_add_one_connector(&adev->mode_info.rfbdev->helper, connector);
 	else
 		DRM_ERROR("adev->mode_info.rfbdev is NULL\n");
 
-	drm_modeset_unlock_all(dev);
-
 	drm_connector_register(connector);
 
 }

commit 4bd29c34988be0c24759d5d58df424f861a8bf24
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Thu Sep 28 16:20:30 2017 -0400

    drm/amd/display: Do not access fbdev helper members
    
    Original code is no longer needed and tested without loop.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 610375b2a04b..382f499cb60d 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -397,21 +397,10 @@ static void dm_dp_mst_register_connector(struct drm_connector *connector)
 {
 	struct drm_device *dev = connector->dev;
 	struct amdgpu_device *adev = dev->dev_private;
-	int i;
 
 	drm_modeset_lock_all(dev);
-	if (adev->mode_info.rfbdev) {
-		/*Do not add if already registered in past*/
-		for (i = 0; i < adev->mode_info.rfbdev->helper.connector_count; i++) {
-			if (adev->mode_info.rfbdev->helper.connector_info[i]->connector
-					== connector) {
-				drm_modeset_unlock_all(dev);
-				return;
-			}
-		}
-
+	if (adev->mode_info.rfbdev)
 		drm_fb_helper_add_one_connector(&adev->mode_info.rfbdev->helper, connector);
-	}
 	else
 		DRM_ERROR("adev->mode_info.rfbdev is NULL\n");
 

commit 544276514760f293eadb68461f1b45b6ccec073e
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Wed Sep 20 15:04:52 2017 -0400

    drm/amd/display: Fix MST daisy chain SST not light up
    
    In SST daisy chain scenario, edid is getting read in mst hotplug
    routine. It is getting conflict with drm send_enum_path_resources
    kernel thread in terms of i2c bus which is getting locked up in
    such case.
    
    Have edid being read in get_mode hook, instead of in hotplug
    routine.
    
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index dfcfb5a722e0..610375b2a04b 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -174,14 +174,60 @@ static const struct drm_connector_funcs dm_dp_mst_connector_funcs = {
 	.atomic_get_property = amdgpu_dm_connector_atomic_get_property
 };
 
+static int dm_connector_update_modes(struct drm_connector *connector,
+				struct edid *edid)
+{
+	int ret;
+
+	ret = drm_add_edid_modes(connector, edid);
+	drm_edid_to_eld(connector, edid);
+
+	return ret;
+}
+
 static int dm_dp_mst_get_modes(struct drm_connector *connector)
 {
 	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
 	int ret = 0;
 
-	ret = drm_add_edid_modes(&aconnector->base, aconnector->edid);
+	if (!aconnector)
+		return dm_connector_update_modes(connector, NULL);
+
+	if (!aconnector->edid) {
+		struct edid *edid;
+		struct dc_sink *dc_sink;
+		struct dc_sink_init_data init_params = {
+				.link = aconnector->dc_link,
+				.sink_signal = SIGNAL_TYPE_DISPLAY_PORT_MST };
+		edid = drm_dp_mst_get_edid(connector, &aconnector->mst_port->mst_mgr, aconnector->port);
 
-	drm_edid_to_eld(&aconnector->base, aconnector->edid);
+		if (!edid) {
+			drm_mode_connector_update_edid_property(
+				&aconnector->base,
+				NULL);
+			return ret;
+		}
+
+		aconnector->edid = edid;
+
+		dc_sink = dc_link_add_remote_sink(
+			aconnector->dc_link,
+			(uint8_t *)edid,
+			(edid->extensions + 1) * EDID_LENGTH,
+			&init_params);
+
+		dc_sink->priv = aconnector;
+		aconnector->dc_sink = dc_sink;
+
+		if (aconnector->dc_sink)
+			amdgpu_dm_add_sink_to_freesync_module(
+					connector, edid);
+
+		drm_mode_connector_update_edid_property(
+						&aconnector->base, edid);
+	}
+
+	ret = dm_connector_update_modes(connector, aconnector->edid);
 
 	return ret;
 }
@@ -343,66 +389,8 @@ static void dm_dp_mst_hotplug(struct drm_dp_mst_topology_mgr *mgr)
 {
 	struct amdgpu_dm_connector *master = container_of(mgr, struct amdgpu_dm_connector, mst_mgr);
 	struct drm_device *dev = master->base.dev;
-	struct amdgpu_device *adev = dev->dev_private;
-	struct drm_connector *connector;
-	struct amdgpu_dm_connector *aconnector;
-	struct edid *edid;
-	struct dc_sink *dc_sink;
-
-	drm_modeset_lock_all(dev);
-	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
-		aconnector = to_amdgpu_dm_connector(connector);
-		if (aconnector->port &&
-				aconnector->port->pdt != DP_PEER_DEVICE_NONE &&
-				aconnector->port->pdt != DP_PEER_DEVICE_MST_BRANCHING &&
-				!aconnector->dc_sink) {
-			/*
-			 * This is plug in case, where port has been created but
-			 * sink hasn't been created yet
-			 */
-			if (!aconnector->edid) {
-				struct dc_sink_init_data init_params = {
-						.link = aconnector->dc_link,
-						.sink_signal = SIGNAL_TYPE_DISPLAY_PORT_MST};
-				edid = drm_dp_mst_get_edid(connector, &aconnector->mst_port->mst_mgr, aconnector->port);
-
-				if (!edid) {
-					drm_mode_connector_update_edid_property(
-						&aconnector->base,
-						NULL);
-					continue;
-				}
-
-				aconnector->edid = edid;
-
-				dc_sink = dc_link_add_remote_sink(
-					aconnector->dc_link,
-					(uint8_t *)edid,
-					(edid->extensions + 1) * EDID_LENGTH,
-					&init_params);
-
-				dc_sink->priv = aconnector;
-				aconnector->dc_sink = dc_sink;
-
-				if (aconnector->dc_sink)
-					amdgpu_dm_add_sink_to_freesync_module(
-							connector,
-							edid);
-
-				dm_restore_drm_connector_state(connector->dev, connector);
-			} else
-				edid = aconnector->edid;
-
-			DRM_DEBUG_KMS("edid retrieved %p\n", edid);
-
-			drm_mode_connector_update_edid_property(
-				&aconnector->base,
-				aconnector->edid);
-		}
-	}
-	drm_modeset_unlock_all(dev);
 
-	schedule_work(&adev->dm.mst_hotplug_work);
+	drm_kms_helper_hotplug_event(dev);
 }
 
 static void dm_dp_mst_register_connector(struct drm_connector *connector)

commit 6563617fbbbe273be4ce99f15000a63eca789d6a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Oct 11 09:47:04 2017 -0400

    drm/amd/display: make log_dpcd static
    
    It's only used in this file.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index eed316a8b096..dfcfb5a722e0 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -56,11 +56,11 @@ static inline char *side_band_msg_type_to_str(uint32_t address)
 	return str;
 }
 
-void log_dpcd(uint8_t type,
-	      uint32_t address,
-	      uint8_t *data,
-	      uint32_t size,
-	      bool res)
+static void log_dpcd(uint8_t type,
+		     uint32_t address,
+		     uint8_t *data,
+		     uint32_t size,
+		     bool res)
 {
 	DRM_DEBUG_KMS("Op: %s, addr: %04x, SideBand Msg: %s, Op res: %s\n",
 			(type == DP_AUX_NATIVE_READ) ||

commit aaa6346d75e2eaee715f36dd3b88a2a865663235
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Oct 11 09:44:50 2017 -0400

    drm/amd/display: whitespace cleanup in amdgpu_dm_mst_types.c/h
    
    To match kernel standards.  No intended functional change.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 343645e4070b..eed316a8b096 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -57,10 +57,10 @@ static inline char *side_band_msg_type_to_str(uint32_t address)
 }
 
 void log_dpcd(uint8_t type,
-		uint32_t address,
-		uint8_t *data,
-		uint32_t size,
-		bool res)
+	      uint32_t address,
+	      uint8_t *data,
+	      uint32_t size,
+	      bool res)
 {
 	DRM_DEBUG_KMS("Op: %s, addr: %04x, SideBand Msg: %s, Op res: %s\n",
 			(type == DP_AUX_NATIVE_READ) ||
@@ -77,9 +77,11 @@ void log_dpcd(uint8_t type,
 }
 #endif
 
-static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
+static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux,
+				  struct drm_dp_aux_msg *msg)
 {
-	enum i2c_mot_mode mot = (msg->request & DP_AUX_I2C_MOT) ? I2C_MOT_TRUE : I2C_MOT_FALSE;
+	enum i2c_mot_mode mot = (msg->request & DP_AUX_I2C_MOT) ?
+		I2C_MOT_TRUE : I2C_MOT_FALSE;
 	enum ddc_result res;
 
 	switch (msg->request & ~DP_AUX_I2C_MOT) {
@@ -125,10 +127,10 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux, struct drm_dp_aux_msg
 
 #ifdef TRACE_DPCD
 	log_dpcd(msg->request,
-			msg->address,
-			msg->buffer,
-			msg->size,
-			r == DDC_RESULT_SUCESSFULL);
+		 msg->address,
+		 msg->buffer,
+		 msg->size,
+		 r == DDC_RESULT_SUCESSFULL);
 #endif
 
 	return msg->size;
@@ -229,9 +231,10 @@ dm_dp_create_fake_mst_encoder(struct amdgpu_dm_connector *connector)
 	return amdgpu_encoder;
 }
 
-static struct drm_connector *dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
-							 struct drm_dp_mst_port *port,
-							 const char *pathprop)
+static struct drm_connector *
+dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
+			struct drm_dp_mst_port *port,
+			const char *pathprop)
 {
 	struct amdgpu_dm_connector *master = container_of(mgr, struct amdgpu_dm_connector, mst_mgr);
 	struct drm_device *dev = master->base.dev;
@@ -311,9 +314,8 @@ static struct drm_connector *dm_dp_add_mst_connector(struct drm_dp_mst_topology_
 	return connector;
 }
 
-static void dm_dp_destroy_mst_connector(
-	struct drm_dp_mst_topology_mgr *mgr,
-	struct drm_connector *connector)
+static void dm_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
+					struct drm_connector *connector)
 {
 	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
 
@@ -438,9 +440,8 @@ static const struct drm_dp_mst_topology_cbs dm_mst_cbs = {
 	.register_connector = dm_dp_mst_register_connector
 };
 
-void amdgpu_dm_initialize_dp_connector(
-	struct amdgpu_display_manager *dm,
-	struct amdgpu_dm_connector *aconnector)
+void amdgpu_dm_initialize_dp_connector(struct amdgpu_display_manager *dm,
+				       struct amdgpu_dm_connector *aconnector)
 {
 	aconnector->dm_dp_aux.aux.name = "dmdc";
 	aconnector->dm_dp_aux.aux.dev = dm->adev->dev;

commit c84dec2fe8837facf4ccaffd2afae9b157719327
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 5 14:16:09 2017 -0400

    drm/amd/display: Break out amdgpu_dm_connector
    
    Stop using amdgpu_connector and roll our own. There is no overlap
    with amdgpu.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 82e4d49fb184..343645e4070b 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -137,8 +137,8 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux, struct drm_dp_aux_msg
 static enum drm_connector_status
 dm_dp_mst_detect(struct drm_connector *connector, bool force)
 {
-	struct amdgpu_connector *aconnector = to_amdgpu_connector(connector);
-	struct amdgpu_connector *master = aconnector->mst_port;
+	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
+	struct amdgpu_dm_connector *master = aconnector->mst_port;
 
 	enum drm_connector_status status =
 		drm_dp_mst_detect_port(
@@ -152,13 +152,13 @@ dm_dp_mst_detect(struct drm_connector *connector, bool force)
 static void
 dm_dp_mst_connector_destroy(struct drm_connector *connector)
 {
-	struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
-	struct amdgpu_encoder *amdgpu_encoder = amdgpu_connector->mst_encoder;
+	struct amdgpu_dm_connector *amdgpu_dm_connector = to_amdgpu_dm_connector(connector);
+	struct amdgpu_encoder *amdgpu_encoder = amdgpu_dm_connector->mst_encoder;
 
 	drm_encoder_cleanup(&amdgpu_encoder->base);
 	kfree(amdgpu_encoder);
 	drm_connector_cleanup(connector);
-	kfree(amdgpu_connector);
+	kfree(amdgpu_dm_connector);
 }
 
 static const struct drm_connector_funcs dm_dp_mst_connector_funcs = {
@@ -174,7 +174,7 @@ static const struct drm_connector_funcs dm_dp_mst_connector_funcs = {
 
 static int dm_dp_mst_get_modes(struct drm_connector *connector)
 {
-	struct amdgpu_connector *aconnector = to_amdgpu_connector(connector);
+	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
 	int ret = 0;
 
 	ret = drm_add_edid_modes(&aconnector->base, aconnector->edid);
@@ -186,9 +186,9 @@ static int dm_dp_mst_get_modes(struct drm_connector *connector)
 
 static struct drm_encoder *dm_mst_best_encoder(struct drm_connector *connector)
 {
-	struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
+	struct amdgpu_dm_connector *amdgpu_dm_connector = to_amdgpu_dm_connector(connector);
 
-	return &amdgpu_connector->mst_encoder->base;
+	return &amdgpu_dm_connector->mst_encoder->base;
 }
 
 static const struct drm_connector_helper_funcs dm_dp_mst_connector_helper_funcs = {
@@ -198,7 +198,7 @@ static const struct drm_connector_helper_funcs dm_dp_mst_connector_helper_funcs
 };
 
 static struct amdgpu_encoder *
-dm_dp_create_fake_mst_encoder(struct amdgpu_connector *connector)
+dm_dp_create_fake_mst_encoder(struct amdgpu_dm_connector *connector)
 {
 	struct drm_device *dev = connector->base.dev;
 	struct amdgpu_device *adev = dev->dev_private;
@@ -233,15 +233,15 @@ static struct drm_connector *dm_dp_add_mst_connector(struct drm_dp_mst_topology_
 							 struct drm_dp_mst_port *port,
 							 const char *pathprop)
 {
-	struct amdgpu_connector *master = container_of(mgr, struct amdgpu_connector, mst_mgr);
+	struct amdgpu_dm_connector *master = container_of(mgr, struct amdgpu_dm_connector, mst_mgr);
 	struct drm_device *dev = master->base.dev;
 	struct amdgpu_device *adev = dev->dev_private;
-	struct amdgpu_connector *aconnector;
+	struct amdgpu_dm_connector *aconnector;
 	struct drm_connector *connector;
 
 	drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
-		aconnector = to_amdgpu_connector(connector);
+		aconnector = to_amdgpu_dm_connector(connector);
 		if (aconnector->mst_port == master
 				&& !aconnector->port) {
 			DRM_INFO("DM_MST: reusing connector: %p [id: %d] [master: %p]\n",
@@ -315,7 +315,7 @@ static void dm_dp_destroy_mst_connector(
 	struct drm_dp_mst_topology_mgr *mgr,
 	struct drm_connector *connector)
 {
-	struct amdgpu_connector *aconnector = to_amdgpu_connector(connector);
+	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
 
 	DRM_INFO("DM_MST: Disabling connector: %p [id: %d] [master: %p]\n",
 				aconnector, connector->base.id, aconnector->mst_port);
@@ -339,17 +339,17 @@ static void dm_dp_destroy_mst_connector(
 
 static void dm_dp_mst_hotplug(struct drm_dp_mst_topology_mgr *mgr)
 {
-	struct amdgpu_connector *master = container_of(mgr, struct amdgpu_connector, mst_mgr);
+	struct amdgpu_dm_connector *master = container_of(mgr, struct amdgpu_dm_connector, mst_mgr);
 	struct drm_device *dev = master->base.dev;
 	struct amdgpu_device *adev = dev->dev_private;
 	struct drm_connector *connector;
-	struct amdgpu_connector *aconnector;
+	struct amdgpu_dm_connector *aconnector;
 	struct edid *edid;
 	struct dc_sink *dc_sink;
 
 	drm_modeset_lock_all(dev);
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
-		aconnector = to_amdgpu_connector(connector);
+		aconnector = to_amdgpu_dm_connector(connector);
 		if (aconnector->port &&
 				aconnector->port->pdt != DP_PEER_DEVICE_NONE &&
 				aconnector->port->pdt != DP_PEER_DEVICE_MST_BRANCHING &&
@@ -440,7 +440,7 @@ static const struct drm_dp_mst_topology_cbs dm_mst_cbs = {
 
 void amdgpu_dm_initialize_dp_connector(
 	struct amdgpu_display_manager *dm,
-	struct amdgpu_connector *aconnector)
+	struct amdgpu_dm_connector *aconnector)
 {
 	aconnector->dm_dp_aux.aux.name = "dmdc";
 	aconnector->dm_dp_aux.aux.dev = dm->adev->dev;

commit e7b07ceef2a650e5ed8ca37997689e086c680daf
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Aug 10 13:29:07 2017 -0400

    drm/amd/display: Merge amdgpu_dm_types and amdgpu_dm
    
    This separation stopped making sense a long time ago.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index ec91a52c002f..82e4d49fb184 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -27,7 +27,7 @@
 #include <drm/drm_atomic_helper.h>
 #include "dm_services.h"
 #include "amdgpu.h"
-#include "amdgpu_dm_types.h"
+#include "amdgpu_dm.h"
 #include "amdgpu_dm_mst_types.h"
 
 #include "dc.h"

commit 80c62d3a112af59ada6c3a5fc1de16021d7ad790
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Mon Jun 19 11:38:15 2017 -0400

    drm/amd/display: MST atomic_get_property missing.
    
    Missing function implementation was leading to EINVAL
    in UMD thus not adding MST connector to X topology
    and hence not getting set mode for it.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 77907baa522a..ec91a52c002f 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -168,7 +168,8 @@ static const struct drm_connector_funcs dm_dp_mst_connector_funcs = {
 	.reset = amdgpu_dm_connector_funcs_reset,
 	.atomic_duplicate_state = amdgpu_dm_connector_atomic_duplicate_state,
 	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
-	.atomic_set_property = amdgpu_dm_connector_atomic_set_property
+	.atomic_set_property = amdgpu_dm_connector_atomic_set_property,
+	.atomic_get_property = amdgpu_dm_connector_atomic_get_property
 };
 
 static int dm_dp_mst_get_modes(struct drm_connector *connector)

commit 46df790c6b569faffb4cc93889745a7827283749
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Sun Apr 30 09:20:55 2017 -0400

    drm/amd/display: i2c/aux Remove link index.
    
    Link index is an unnecessery level of inderection when
    calling from kernel i2c/aux transfer into DAL.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 187464ac27b3..77907baa522a 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -33,6 +33,8 @@
 #include "dc.h"
 #include "dm_helpers.h"
 
+#include "dc_link_ddc.h"
+
 /* #define TRACE_DPCD */
 
 #ifdef TRACE_DPCD
@@ -77,43 +79,41 @@ void log_dpcd(uint8_t type,
 
 static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
 {
-	struct pci_dev *pdev = to_pci_dev(aux->dev);
-	struct drm_device *drm_dev = pci_get_drvdata(pdev);
-	struct amdgpu_device *adev = drm_dev->dev_private;
-	struct dc *dc = adev->dm.dc;
 	enum i2c_mot_mode mot = (msg->request & DP_AUX_I2C_MOT) ? I2C_MOT_TRUE : I2C_MOT_FALSE;
-	bool res;
+	enum ddc_result res;
 
 	switch (msg->request & ~DP_AUX_I2C_MOT) {
 	case DP_AUX_NATIVE_READ:
-		res = dc_read_aux_dpcd(
-				dc,
-				TO_DM_AUX(aux)->link_index,
+		res = dal_ddc_service_read_dpcd_data(
+				TO_DM_AUX(aux)->ddc_service,
+				false,
+				I2C_MOT_UNDEF,
 				msg->address,
 				msg->buffer,
 				msg->size);
 		break;
 	case DP_AUX_NATIVE_WRITE:
-		res = dc_write_aux_dpcd(
-				dc,
-				TO_DM_AUX(aux)->link_index,
+		res = dal_ddc_service_write_dpcd_data(
+				TO_DM_AUX(aux)->ddc_service,
+				false,
+				I2C_MOT_UNDEF,
 				msg->address,
 				msg->buffer,
 				msg->size);
 		break;
 	case DP_AUX_I2C_READ:
-		res = dc_read_aux_i2c(
-				dc,
-				TO_DM_AUX(aux)->link_index,
+		res = dal_ddc_service_read_dpcd_data(
+				TO_DM_AUX(aux)->ddc_service,
+				true,
 				mot,
 				msg->address,
 				msg->buffer,
 				msg->size);
 		break;
 	case DP_AUX_I2C_WRITE:
-		res = dc_write_aux_i2c(
-				dc,
-				TO_DM_AUX(aux)->link_index,
+		res = dal_ddc_service_write_dpcd_data(
+				TO_DM_AUX(aux)->ddc_service,
+				true,
 				mot,
 				msg->address,
 				msg->buffer,
@@ -128,7 +128,7 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux, struct drm_dp_aux_msg
 			msg->address,
 			msg->buffer,
 			msg->size,
-			res);
+			r == DDC_RESULT_SUCESSFULL);
 #endif
 
 	return msg->size;
@@ -444,7 +444,7 @@ void amdgpu_dm_initialize_dp_connector(
 	aconnector->dm_dp_aux.aux.name = "dmdc";
 	aconnector->dm_dp_aux.aux.dev = dm->adev->dev;
 	aconnector->dm_dp_aux.aux.transfer = dm_dp_aux_transfer;
-	aconnector->dm_dp_aux.link_index = aconnector->connector_id;
+	aconnector->dm_dp_aux.ddc_service = aconnector->dc_link->ddc;
 
 	drm_dp_aux_register(&aconnector->dm_dp_aux.aux);
 	aconnector->mst_mgr.cbs = &dm_mst_cbs;

commit 7c7f5b15be6528b33d825ead6acb739d7d061a2e
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Tue Mar 28 16:57:52 2017 -0400

    drm/amd/display: Refactor edid read.
    
    Allow Linux to use DRM provided EDID read functioality
    by moving  DAL edid implementation to module hence
    removing this code from DC by this cleaning up DC
    code for upstream.
    
    v2: Removing ddc_service. No more need for it.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 069511bb6fab..187464ac27b3 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -81,24 +81,43 @@ static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux, struct drm_dp_aux_msg
 	struct drm_device *drm_dev = pci_get_drvdata(pdev);
 	struct amdgpu_device *adev = drm_dev->dev_private;
 	struct dc *dc = adev->dm.dc;
+	enum i2c_mot_mode mot = (msg->request & DP_AUX_I2C_MOT) ? I2C_MOT_TRUE : I2C_MOT_FALSE;
 	bool res;
 
-	switch (msg->request) {
+	switch (msg->request & ~DP_AUX_I2C_MOT) {
 	case DP_AUX_NATIVE_READ:
-		res = dc_read_dpcd(
-			dc,
-			TO_DM_AUX(aux)->link_index,
-			msg->address,
-			msg->buffer,
-			msg->size);
+		res = dc_read_aux_dpcd(
+				dc,
+				TO_DM_AUX(aux)->link_index,
+				msg->address,
+				msg->buffer,
+				msg->size);
 		break;
 	case DP_AUX_NATIVE_WRITE:
-		res = dc_write_dpcd(
-			dc,
-			TO_DM_AUX(aux)->link_index,
-			msg->address,
-			msg->buffer,
-			msg->size);
+		res = dc_write_aux_dpcd(
+				dc,
+				TO_DM_AUX(aux)->link_index,
+				msg->address,
+				msg->buffer,
+				msg->size);
+		break;
+	case DP_AUX_I2C_READ:
+		res = dc_read_aux_i2c(
+				dc,
+				TO_DM_AUX(aux)->link_index,
+				mot,
+				msg->address,
+				msg->buffer,
+				msg->size);
+		break;
+	case DP_AUX_I2C_WRITE:
+		res = dc_write_aux_i2c(
+				dc,
+				TO_DM_AUX(aux)->link_index,
+				mot,
+				msg->address,
+				msg->buffer,
+				msg->size);
 		break;
 	default:
 		return 0;
@@ -418,7 +437,7 @@ static const struct drm_dp_mst_topology_cbs dm_mst_cbs = {
 	.register_connector = dm_dp_mst_register_connector
 };
 
-void amdgpu_dm_initialize_mst_connector(
+void amdgpu_dm_initialize_dp_connector(
 	struct amdgpu_display_manager *dm,
 	struct amdgpu_connector *aconnector)
 {

commit 5c4e9806435d7da665af08b3071446b9617eb9cb
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Tue Feb 14 15:47:24 2017 -0500

    drm/amd/display: Remove get_connector_for_sink.
    
    Keep 1:1 relation between MST sink and it's MST connector.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index 41988c89d471..069511bb6fab 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -325,6 +325,7 @@ static void dm_dp_mst_hotplug(struct drm_dp_mst_topology_mgr *mgr)
 	struct drm_connector *connector;
 	struct amdgpu_connector *aconnector;
 	struct edid *edid;
+	struct dc_sink *dc_sink;
 
 	drm_modeset_lock_all(dev);
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
@@ -352,11 +353,15 @@ static void dm_dp_mst_hotplug(struct drm_dp_mst_topology_mgr *mgr)
 
 				aconnector->edid = edid;
 
-				aconnector->dc_sink = dc_link_add_remote_sink(
+				dc_sink = dc_link_add_remote_sink(
 					aconnector->dc_link,
 					(uint8_t *)edid,
 					(edid->extensions + 1) * EDID_LENGTH,
 					&init_params);
+
+				dc_sink->priv = aconnector;
+				aconnector->dc_sink = dc_sink;
+
 				if (aconnector->dc_sink)
 					amdgpu_dm_add_sink_to_freesync_module(
 							connector,

commit a2b763cbd69e59854ed3ff9f79b7e8471748ea69
Author: Krzysztof Nowicki <krzysztof.a.nowicki@gmail.com>
Date:   Fri Jan 27 18:58:27 2017 +0100

    drm/amd/display: Fix MST physical ports always disconnected
    
    Remove a false assumption that a cached EDID will be present whenever
    the connector is in a connected state as this will only be true for
    logical MST ports. For physical ports the EDID will never be cached,
    which will cause them to always appear as disconnected.
    
    This reverts commit 4ff8a88888de271bfb7750b2a5c68163848e2bf1
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
index e4d94d4c215d..41988c89d471 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -127,14 +127,6 @@ dm_dp_mst_detect(struct drm_connector *connector, bool force)
 			&master->mst_mgr,
 			aconnector->port);
 
-	/*
-	 * we do not want to make this connector connected until we have edid on
-	 * it
-	 */
-	if (status == connector_status_connected &&
-		!aconnector->port->cached_edid)
-		status = connector_status_disconnected;
-
 	return status;
 }
 

commit 4562236b3bc0a28aeb6ee93b2d8a849a4c4e1c7c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 12 15:58:20 2017 -0400

    drm/amd/dc: Add dc display driver (v2)
    
    Supported DCE versions: 8.0, 10.0, 11.0, 11.2
    
    v2: rebase against 4.11
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
new file mode 100644
index 000000000000..e4d94d4c215d
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c
@@ -0,0 +1,443 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include <linux/version.h>
+#include <drm/drm_atomic_helper.h>
+#include "dm_services.h"
+#include "amdgpu.h"
+#include "amdgpu_dm_types.h"
+#include "amdgpu_dm_mst_types.h"
+
+#include "dc.h"
+#include "dm_helpers.h"
+
+/* #define TRACE_DPCD */
+
+#ifdef TRACE_DPCD
+#define SIDE_BAND_MSG(address) (address >= DP_SIDEBAND_MSG_DOWN_REQ_BASE && address < DP_SINK_COUNT_ESI)
+
+static inline char *side_band_msg_type_to_str(uint32_t address)
+{
+	static char str[10] = {0};
+
+	if (address < DP_SIDEBAND_MSG_UP_REP_BASE)
+		strcpy(str, "DOWN_REQ");
+	else if (address < DP_SIDEBAND_MSG_DOWN_REP_BASE)
+		strcpy(str, "UP_REP");
+	else if (address < DP_SIDEBAND_MSG_UP_REQ_BASE)
+		strcpy(str, "DOWN_REP");
+	else
+		strcpy(str, "UP_REQ");
+
+	return str;
+}
+
+void log_dpcd(uint8_t type,
+		uint32_t address,
+		uint8_t *data,
+		uint32_t size,
+		bool res)
+{
+	DRM_DEBUG_KMS("Op: %s, addr: %04x, SideBand Msg: %s, Op res: %s\n",
+			(type == DP_AUX_NATIVE_READ) ||
+			(type == DP_AUX_I2C_READ) ?
+					"Read" : "Write",
+			address,
+			SIDE_BAND_MSG(address) ?
+					side_band_msg_type_to_str(address) : "Nop",
+			res ? "OK" : "Fail");
+
+	if (res) {
+		print_hex_dump(KERN_INFO, "Body: ", DUMP_PREFIX_NONE, 16, 1, data, size, false);
+	}
+}
+#endif
+
+static ssize_t dm_dp_aux_transfer(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
+{
+	struct pci_dev *pdev = to_pci_dev(aux->dev);
+	struct drm_device *drm_dev = pci_get_drvdata(pdev);
+	struct amdgpu_device *adev = drm_dev->dev_private;
+	struct dc *dc = adev->dm.dc;
+	bool res;
+
+	switch (msg->request) {
+	case DP_AUX_NATIVE_READ:
+		res = dc_read_dpcd(
+			dc,
+			TO_DM_AUX(aux)->link_index,
+			msg->address,
+			msg->buffer,
+			msg->size);
+		break;
+	case DP_AUX_NATIVE_WRITE:
+		res = dc_write_dpcd(
+			dc,
+			TO_DM_AUX(aux)->link_index,
+			msg->address,
+			msg->buffer,
+			msg->size);
+		break;
+	default:
+		return 0;
+	}
+
+#ifdef TRACE_DPCD
+	log_dpcd(msg->request,
+			msg->address,
+			msg->buffer,
+			msg->size,
+			res);
+#endif
+
+	return msg->size;
+}
+
+static enum drm_connector_status
+dm_dp_mst_detect(struct drm_connector *connector, bool force)
+{
+	struct amdgpu_connector *aconnector = to_amdgpu_connector(connector);
+	struct amdgpu_connector *master = aconnector->mst_port;
+
+	enum drm_connector_status status =
+		drm_dp_mst_detect_port(
+			connector,
+			&master->mst_mgr,
+			aconnector->port);
+
+	/*
+	 * we do not want to make this connector connected until we have edid on
+	 * it
+	 */
+	if (status == connector_status_connected &&
+		!aconnector->port->cached_edid)
+		status = connector_status_disconnected;
+
+	return status;
+}
+
+static void
+dm_dp_mst_connector_destroy(struct drm_connector *connector)
+{
+	struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
+	struct amdgpu_encoder *amdgpu_encoder = amdgpu_connector->mst_encoder;
+
+	drm_encoder_cleanup(&amdgpu_encoder->base);
+	kfree(amdgpu_encoder);
+	drm_connector_cleanup(connector);
+	kfree(amdgpu_connector);
+}
+
+static const struct drm_connector_funcs dm_dp_mst_connector_funcs = {
+	.detect = dm_dp_mst_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = dm_dp_mst_connector_destroy,
+	.reset = amdgpu_dm_connector_funcs_reset,
+	.atomic_duplicate_state = amdgpu_dm_connector_atomic_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+	.atomic_set_property = amdgpu_dm_connector_atomic_set_property
+};
+
+static int dm_dp_mst_get_modes(struct drm_connector *connector)
+{
+	struct amdgpu_connector *aconnector = to_amdgpu_connector(connector);
+	int ret = 0;
+
+	ret = drm_add_edid_modes(&aconnector->base, aconnector->edid);
+
+	drm_edid_to_eld(&aconnector->base, aconnector->edid);
+
+	return ret;
+}
+
+static struct drm_encoder *dm_mst_best_encoder(struct drm_connector *connector)
+{
+	struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
+
+	return &amdgpu_connector->mst_encoder->base;
+}
+
+static const struct drm_connector_helper_funcs dm_dp_mst_connector_helper_funcs = {
+	.get_modes = dm_dp_mst_get_modes,
+	.mode_valid = amdgpu_dm_connector_mode_valid,
+	.best_encoder = dm_mst_best_encoder,
+};
+
+static struct amdgpu_encoder *
+dm_dp_create_fake_mst_encoder(struct amdgpu_connector *connector)
+{
+	struct drm_device *dev = connector->base.dev;
+	struct amdgpu_device *adev = dev->dev_private;
+	struct amdgpu_encoder *amdgpu_encoder;
+	struct drm_encoder *encoder;
+	const struct drm_connector_helper_funcs *connector_funcs =
+		connector->base.helper_private;
+	struct drm_encoder *enc_master =
+		connector_funcs->best_encoder(&connector->base);
+
+	DRM_DEBUG_KMS("enc master is %p\n", enc_master);
+	amdgpu_encoder = kzalloc(sizeof(*amdgpu_encoder), GFP_KERNEL);
+	if (!amdgpu_encoder)
+		return NULL;
+
+	encoder = &amdgpu_encoder->base;
+	encoder->possible_crtcs = amdgpu_dm_get_encoder_crtc_mask(adev);
+
+	drm_encoder_init(
+		dev,
+		&amdgpu_encoder->base,
+		NULL,
+		DRM_MODE_ENCODER_DPMST,
+		NULL);
+
+	drm_encoder_helper_add(encoder, &amdgpu_dm_encoder_helper_funcs);
+
+	return amdgpu_encoder;
+}
+
+static struct drm_connector *dm_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
+							 struct drm_dp_mst_port *port,
+							 const char *pathprop)
+{
+	struct amdgpu_connector *master = container_of(mgr, struct amdgpu_connector, mst_mgr);
+	struct drm_device *dev = master->base.dev;
+	struct amdgpu_device *adev = dev->dev_private;
+	struct amdgpu_connector *aconnector;
+	struct drm_connector *connector;
+
+	drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
+	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+		aconnector = to_amdgpu_connector(connector);
+		if (aconnector->mst_port == master
+				&& !aconnector->port) {
+			DRM_INFO("DM_MST: reusing connector: %p [id: %d] [master: %p]\n",
+						aconnector, connector->base.id, aconnector->mst_port);
+
+			aconnector->port = port;
+			drm_mode_connector_set_path_property(connector, pathprop);
+
+			drm_modeset_unlock(&dev->mode_config.connection_mutex);
+			return &aconnector->base;
+		}
+	}
+	drm_modeset_unlock(&dev->mode_config.connection_mutex);
+
+	aconnector = kzalloc(sizeof(*aconnector), GFP_KERNEL);
+	if (!aconnector)
+		return NULL;
+
+	connector = &aconnector->base;
+	aconnector->port = port;
+	aconnector->mst_port = master;
+
+	if (drm_connector_init(
+		dev,
+		connector,
+		&dm_dp_mst_connector_funcs,
+		DRM_MODE_CONNECTOR_DisplayPort)) {
+		kfree(aconnector);
+		return NULL;
+	}
+	drm_connector_helper_add(connector, &dm_dp_mst_connector_helper_funcs);
+
+	amdgpu_dm_connector_init_helper(
+		&adev->dm,
+		aconnector,
+		DRM_MODE_CONNECTOR_DisplayPort,
+		master->dc_link,
+		master->connector_id);
+
+	aconnector->mst_encoder = dm_dp_create_fake_mst_encoder(master);
+
+	/*
+	 * TODO: understand why this one is needed
+	 */
+	drm_object_attach_property(
+		&connector->base,
+		dev->mode_config.path_property,
+		0);
+	drm_object_attach_property(
+		&connector->base,
+		dev->mode_config.tile_property,
+		0);
+
+	drm_mode_connector_set_path_property(connector, pathprop);
+
+	/*
+	 * Initialize connector state before adding the connectror to drm and
+	 * framebuffer lists
+	 */
+	amdgpu_dm_connector_funcs_reset(connector);
+
+	DRM_INFO("DM_MST: added connector: %p [id: %d] [master: %p]\n",
+			aconnector, connector->base.id, aconnector->mst_port);
+
+	DRM_DEBUG_KMS(":%d\n", connector->base.id);
+
+	return connector;
+}
+
+static void dm_dp_destroy_mst_connector(
+	struct drm_dp_mst_topology_mgr *mgr,
+	struct drm_connector *connector)
+{
+	struct amdgpu_connector *aconnector = to_amdgpu_connector(connector);
+
+	DRM_INFO("DM_MST: Disabling connector: %p [id: %d] [master: %p]\n",
+				aconnector, connector->base.id, aconnector->mst_port);
+
+	aconnector->port = NULL;
+	if (aconnector->dc_sink) {
+		amdgpu_dm_remove_sink_from_freesync_module(connector);
+		dc_link_remove_remote_sink(aconnector->dc_link, aconnector->dc_sink);
+		dc_sink_release(aconnector->dc_sink);
+		aconnector->dc_sink = NULL;
+	}
+	if (aconnector->edid) {
+		kfree(aconnector->edid);
+		aconnector->edid = NULL;
+	}
+
+	drm_mode_connector_update_edid_property(
+			&aconnector->base,
+			NULL);
+}
+
+static void dm_dp_mst_hotplug(struct drm_dp_mst_topology_mgr *mgr)
+{
+	struct amdgpu_connector *master = container_of(mgr, struct amdgpu_connector, mst_mgr);
+	struct drm_device *dev = master->base.dev;
+	struct amdgpu_device *adev = dev->dev_private;
+	struct drm_connector *connector;
+	struct amdgpu_connector *aconnector;
+	struct edid *edid;
+
+	drm_modeset_lock_all(dev);
+	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+		aconnector = to_amdgpu_connector(connector);
+		if (aconnector->port &&
+				aconnector->port->pdt != DP_PEER_DEVICE_NONE &&
+				aconnector->port->pdt != DP_PEER_DEVICE_MST_BRANCHING &&
+				!aconnector->dc_sink) {
+			/*
+			 * This is plug in case, where port has been created but
+			 * sink hasn't been created yet
+			 */
+			if (!aconnector->edid) {
+				struct dc_sink_init_data init_params = {
+						.link = aconnector->dc_link,
+						.sink_signal = SIGNAL_TYPE_DISPLAY_PORT_MST};
+				edid = drm_dp_mst_get_edid(connector, &aconnector->mst_port->mst_mgr, aconnector->port);
+
+				if (!edid) {
+					drm_mode_connector_update_edid_property(
+						&aconnector->base,
+						NULL);
+					continue;
+				}
+
+				aconnector->edid = edid;
+
+				aconnector->dc_sink = dc_link_add_remote_sink(
+					aconnector->dc_link,
+					(uint8_t *)edid,
+					(edid->extensions + 1) * EDID_LENGTH,
+					&init_params);
+				if (aconnector->dc_sink)
+					amdgpu_dm_add_sink_to_freesync_module(
+							connector,
+							edid);
+
+				dm_restore_drm_connector_state(connector->dev, connector);
+			} else
+				edid = aconnector->edid;
+
+			DRM_DEBUG_KMS("edid retrieved %p\n", edid);
+
+			drm_mode_connector_update_edid_property(
+				&aconnector->base,
+				aconnector->edid);
+		}
+	}
+	drm_modeset_unlock_all(dev);
+
+	schedule_work(&adev->dm.mst_hotplug_work);
+}
+
+static void dm_dp_mst_register_connector(struct drm_connector *connector)
+{
+	struct drm_device *dev = connector->dev;
+	struct amdgpu_device *adev = dev->dev_private;
+	int i;
+
+	drm_modeset_lock_all(dev);
+	if (adev->mode_info.rfbdev) {
+		/*Do not add if already registered in past*/
+		for (i = 0; i < adev->mode_info.rfbdev->helper.connector_count; i++) {
+			if (adev->mode_info.rfbdev->helper.connector_info[i]->connector
+					== connector) {
+				drm_modeset_unlock_all(dev);
+				return;
+			}
+		}
+
+		drm_fb_helper_add_one_connector(&adev->mode_info.rfbdev->helper, connector);
+	}
+	else
+		DRM_ERROR("adev->mode_info.rfbdev is NULL\n");
+
+	drm_modeset_unlock_all(dev);
+
+	drm_connector_register(connector);
+
+}
+
+static const struct drm_dp_mst_topology_cbs dm_mst_cbs = {
+	.add_connector = dm_dp_add_mst_connector,
+	.destroy_connector = dm_dp_destroy_mst_connector,
+	.hotplug = dm_dp_mst_hotplug,
+	.register_connector = dm_dp_mst_register_connector
+};
+
+void amdgpu_dm_initialize_mst_connector(
+	struct amdgpu_display_manager *dm,
+	struct amdgpu_connector *aconnector)
+{
+	aconnector->dm_dp_aux.aux.name = "dmdc";
+	aconnector->dm_dp_aux.aux.dev = dm->adev->dev;
+	aconnector->dm_dp_aux.aux.transfer = dm_dp_aux_transfer;
+	aconnector->dm_dp_aux.link_index = aconnector->connector_id;
+
+	drm_dp_aux_register(&aconnector->dm_dp_aux.aux);
+	aconnector->mst_mgr.cbs = &dm_mst_cbs;
+	drm_dp_mst_topology_mgr_init(
+		&aconnector->mst_mgr,
+		dm->adev->ddev,
+		&aconnector->dm_dp_aux.aux,
+		16,
+		4,
+		aconnector->connector_id);
+}
+
