commit 90d268741f74f7852ebc295c96212c6e992b2078
Author: Robin Singh <robin.singh@amd.com>
Date:   Thu Aug 22 14:42:49 2019 -0400

    drm/amd/display: Added pixel dynamic expansion control.
    
    [Why]
    To compare the crc of the framebuffer data at input of
    display pipeline with the crc of the otg, we need to
    disable pixel formatter's dynamic expansion feature during
    crc capture and keep it enable in the normal operation.
    
    [HOW]
    Expose a new interface in DM and dc for pixel formatter
    (fmt dynamic bitdepth expansion control). Interface control
    the FMT_DYNAMIC_EXP_EN  bit, during crc capture keep
    it disabled.
    
    Signed-off-by: Robin Singh <robin.singh@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index a549c7c717dd..eaad9099bc0b 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -122,11 +122,16 @@ int amdgpu_dm_crtc_configure_crc_source(struct drm_crtc *crtc,
 	}
 
 	/* Configure dithering */
-	if (!dm_need_crc_dither(source))
+	if (!dm_need_crc_dither(source)) {
 		dc_stream_set_dither_option(stream_state, DITHER_OPTION_TRUN8);
-	else
+		dc_stream_set_dyn_expansion(stream_state->ctx->dc, stream_state,
+					    DYN_EXPANSION_DISABLE);
+	} else {
 		dc_stream_set_dither_option(stream_state,
 					    DITHER_OPTION_DEFAULT);
+		dc_stream_set_dyn_expansion(stream_state->ctx->dc, stream_state,
+					    DYN_EXPANSION_AUTO);
+	}
 
 unlock:
 	mutex_unlock(&adev->dm.dc_lock);

commit 452575c5703cd7d0cf285ef7a97de52af9a3d70d
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue Aug 20 13:15:25 2019 -0400

    drm/amd/display: Lock the CRTC when setting CRC source
    
    [Why]
    We need to ensure that we're holding the lock on the CRTC when setting
    the CRC source since we're modifying the CRTC state directly.
    
    We also need to wait for any outstanding non-blocking commits to finish
    so they aren't reading state that's potentially being modified -
    non-blocking commits don't hold the CRTC lock while doing commit tail
    work.
    
    [How]
    Lock the CRTC using its mutex. While holding the lock check if there's
    any commit active on the CRTC - if there is, it's non-blocking and
    we should wait until it's finished by waiting for hw_done to be
    signaled since that's the last point where we touch CRTC state.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: David Francis <David.Francis@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index d2cdf3002365..a549c7c717dd 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -136,13 +136,13 @@ int amdgpu_dm_crtc_configure_crc_source(struct drm_crtc *crtc,
 
 int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 {
-	struct dm_crtc_state *crtc_state = to_dm_crtc_state(crtc->state);
+	enum amdgpu_dm_pipe_crc_source source = dm_parse_crc_source(src_name);
+	struct drm_crtc_commit *commit;
+	struct dm_crtc_state *crtc_state;
 	struct drm_dp_aux *aux = NULL;
 	bool enable = false;
 	bool enabled = false;
-	int ret;
-
-	enum amdgpu_dm_pipe_crc_source source = dm_parse_crc_source(src_name);
+	int ret = 0;
 
 	if (source < 0) {
 		DRM_DEBUG_DRIVER("Unknown CRC source %s for CRTC%d\n",
@@ -150,7 +150,33 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 		return -EINVAL;
 	}
 
+	ret = drm_modeset_lock(&crtc->mutex, NULL);
+	if (ret)
+		return ret;
+
+	spin_lock(&crtc->commit_lock);
+	commit = list_first_entry_or_null(&crtc->commit_list,
+					  struct drm_crtc_commit, commit_entry);
+	if (commit)
+		drm_crtc_commit_get(commit);
+	spin_unlock(&crtc->commit_lock);
+
+	if (commit) {
+		/*
+		 * Need to wait for all outstanding programming to complete
+		 * in commit tail since it can modify CRC related fields and
+		 * hardware state. Since we're holding the CRTC lock we're
+		 * guaranteed that no other commit work can be queued off
+		 * before we modify the state below.
+		 */
+		ret = wait_for_completion_interruptible_timeout(
+			&commit->hw_done, 10 * HZ);
+		if (ret)
+			goto cleanup;
+	}
+
 	enable = amdgpu_dm_is_valid_crc_source(source);
+	crtc_state = to_dm_crtc_state(crtc->state);
 
 	/*
 	 * USER REQ SRC | CURRENT SRC | BEHAVIOR
@@ -184,19 +210,23 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 
 		if (!aconn) {
 			DRM_DEBUG_DRIVER("No amd connector matching CRTC-%d\n", crtc->index);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto cleanup;
 		}
 
 		aux = &aconn->dm_dp_aux.aux;
 
 		if (!aux) {
 			DRM_DEBUG_DRIVER("No dp aux for amd connector\n");
-			return -EINVAL;
+			ret = -EINVAL;
+			goto cleanup;
 		}
 	}
 
-	if (amdgpu_dm_crtc_configure_crc_source(crtc, crtc_state, source))
-		return -EINVAL;
+	if (amdgpu_dm_crtc_configure_crc_source(crtc, crtc_state, source)) {
+		ret = -EINVAL;
+		goto cleanup;
+	}
 
 	/*
 	 * Reading the CRC requires the vblank interrupt handler to be
@@ -206,12 +236,13 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 	if (!enabled && enable) {
 		ret = drm_crtc_vblank_get(crtc);
 		if (ret)
-			return ret;
+			goto cleanup;
 
 		if (dm_is_crc_source_dprx(source)) {
 			if (drm_dp_start_crc(aux, crtc)) {
 				DRM_DEBUG_DRIVER("dp start crc failed\n");
-				return -EINVAL;
+				ret = -EINVAL;
+				goto cleanup;
 			}
 		}
 	} else if (enabled && !enable) {
@@ -219,7 +250,8 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 		if (dm_is_crc_source_dprx(source)) {
 			if (drm_dp_stop_crc(aux)) {
 				DRM_DEBUG_DRIVER("dp stop crc failed\n");
-				return -EINVAL;
+				ret = -EINVAL;
+				goto cleanup;
 			}
 		}
 	}
@@ -228,7 +260,14 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 
 	/* Reset crc_skipped on dm state */
 	crtc_state->crc_skip_count = 0;
-	return 0;
+
+cleanup:
+	if (commit)
+		drm_crtc_commit_put(commit);
+
+	drm_modeset_unlock(&crtc->mutex);
+
+	return ret;
 }
 
 /**

commit 57638021b711de052df781001bd6fd35804c3646
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue Aug 20 10:16:14 2019 -0400

    drm/amd/display: Split out DC programming for CRC capture
    
    [Why]
    Calling amdgpu_dm_crtc_set_crc_source in amdgpu_dm directly has the
    consequence of adding additional vblank references or starting DPRX
    CRC capture more than once without calling stop first.
    
    Vblank references for CRC capture should be managed entirely by opening
    and closing the CRC file from userspace.
    
    Stream state also shouldn't be required on the CRC so we can close the
    file after the CRTC has been disabled.
    
    [How]
    Do DC programming required for configuring CRC capture separately from
    setting the source. Whenever we re-enable or reset a CRC this
    programming should be reapplied.
    
    CRC vblank reference handling in amdgpu_dm can be entirely dropped after
    this.
    
    Stream state also no longer needs to be required since we can just defer
    the programming to when the stream is actually enabled.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: David Francis <David.Francis@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index 513e40667f8f..d2cdf3002365 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -97,11 +97,46 @@ amdgpu_dm_crtc_verify_crc_source(struct drm_crtc *crtc, const char *src_name,
 	return 0;
 }
 
-int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
+int amdgpu_dm_crtc_configure_crc_source(struct drm_crtc *crtc,
+					struct dm_crtc_state *dm_crtc_state,
+					enum amdgpu_dm_pipe_crc_source source)
 {
 	struct amdgpu_device *adev = crtc->dev->dev_private;
+	struct dc_stream_state *stream_state = dm_crtc_state->stream;
+	bool enable = amdgpu_dm_is_valid_crc_source(source);
+	int ret = 0;
+
+	/* Configuration will be deferred to stream enable. */
+	if (!stream_state)
+		return 0;
+
+	mutex_lock(&adev->dm.dc_lock);
+
+	/* Enable CRTC CRC generation if necessary. */
+	if (dm_is_crc_source_crtc(source)) {
+		if (!dc_stream_configure_crc(stream_state->ctx->dc,
+					     stream_state, enable, enable)) {
+			ret = -EINVAL;
+			goto unlock;
+		}
+	}
+
+	/* Configure dithering */
+	if (!dm_need_crc_dither(source))
+		dc_stream_set_dither_option(stream_state, DITHER_OPTION_TRUN8);
+	else
+		dc_stream_set_dither_option(stream_state,
+					    DITHER_OPTION_DEFAULT);
+
+unlock:
+	mutex_unlock(&adev->dm.dc_lock);
+
+	return ret;
+}
+
+int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
+{
 	struct dm_crtc_state *crtc_state = to_dm_crtc_state(crtc->state);
-	struct dc_stream_state *stream_state = crtc_state->stream;
 	struct drm_dp_aux *aux = NULL;
 	bool enable = false;
 	bool enabled = false;
@@ -115,14 +150,8 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 		return -EINVAL;
 	}
 
-	if (!stream_state) {
-		DRM_ERROR("No stream state for CRTC%d\n", crtc->index);
-		return -EINVAL;
-	}
-
 	enable = amdgpu_dm_is_valid_crc_source(source);
 
-	mutex_lock(&adev->dm.dc_lock);
 	/*
 	 * USER REQ SRC | CURRENT SRC | BEHAVIOR
 	 * -----------------------------
@@ -155,7 +184,6 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 
 		if (!aconn) {
 			DRM_DEBUG_DRIVER("No amd connector matching CRTC-%d\n", crtc->index);
-			mutex_unlock(&adev->dm.dc_lock);
 			return -EINVAL;
 		}
 
@@ -163,24 +191,12 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 
 		if (!aux) {
 			DRM_DEBUG_DRIVER("No dp aux for amd connector\n");
-			mutex_unlock(&adev->dm.dc_lock);
-			return -EINVAL;
-		}
-	} else if (dm_is_crc_source_crtc(source)) {
-		if (!dc_stream_configure_crc(stream_state->ctx->dc, stream_state,
-					     enable, enable)) {
-			mutex_unlock(&adev->dm.dc_lock);
 			return -EINVAL;
 		}
 	}
 
-	/* configure dithering */
-	if (!dm_need_crc_dither(source))
-		dc_stream_set_dither_option(stream_state, DITHER_OPTION_TRUN8);
-	else if (!dm_need_crc_dither(crtc_state->crc_src))
-		dc_stream_set_dither_option(stream_state, DITHER_OPTION_DEFAULT);
-
-	mutex_unlock(&adev->dm.dc_lock);
+	if (amdgpu_dm_crtc_configure_crc_source(crtc, crtc_state, source))
+		return -EINVAL;
 
 	/*
 	 * Reading the CRC requires the vblank interrupt handler to be

commit df61eae4b87ac4dfb9c4fceea2f223a29466507b
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue Aug 20 10:10:08 2019 -0400

    drm/amd/display: Use connector list for finding DPRX CRC aux
    
    [Why]
    This change is a refactor in preparation for adding locking and removing
    the requirement for a stream state on the CRTC for enabling CRC capture
    to fix igt@kms_plane_multiple@* warnings.
    
    [How]
    We can get the aux by finding the matching connector for the CRTC
    with the assumption that we're not doing cloning.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: David Francis <David.Francis@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index eb114e377233..513e40667f8f 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -102,7 +102,6 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 	struct amdgpu_device *adev = crtc->dev->dev_private;
 	struct dm_crtc_state *crtc_state = to_dm_crtc_state(crtc->state);
 	struct dc_stream_state *stream_state = crtc_state->stream;
-	struct amdgpu_dm_connector *aconn;
 	struct drm_dp_aux *aux = NULL;
 	bool enable = false;
 	bool enabled = false;
@@ -138,9 +137,21 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 	 * DPRX DITHER  | XXXX        | Enable DPRX CRC, need 'aux', set dither
 	 */
 	if (dm_is_crc_source_dprx(source) ||
-		(source == AMDGPU_DM_PIPE_CRC_SOURCE_NONE &&
-		 dm_is_crc_source_dprx(crtc_state->crc_src))) {
-		aconn = stream_state->link->priv;
+	    (source == AMDGPU_DM_PIPE_CRC_SOURCE_NONE &&
+	     dm_is_crc_source_dprx(crtc_state->crc_src))) {
+		struct amdgpu_dm_connector *aconn = NULL;
+		struct drm_connector *connector;
+		struct drm_connector_list_iter conn_iter;
+
+		drm_connector_list_iter_begin(crtc->dev, &conn_iter);
+		drm_for_each_connector_iter(connector, &conn_iter) {
+			if (!connector->state || connector->state->crtc != crtc)
+				continue;
+
+			aconn = to_amdgpu_dm_connector(connector);
+			break;
+		}
+		drm_connector_list_iter_end(&conn_iter);
 
 		if (!aconn) {
 			DRM_DEBUG_DRIVER("No amd connector matching CRTC-%d\n", crtc->index);

commit 7a235125959cffa28c20059ff1cb8725571fcf9f
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue Aug 20 12:58:37 2019 -0400

    drm/amd/display: Check return code for CRC drm_crtc_vblank_get
    
    [Why]
    The call to drm_crtc_vblank_get can fail if vblank is disabled and
    we try to increment the reference.
    
    Since drm_crtc_vblank_get internally drops the reference when it fails
    it means the subsequent drm_crtc_vblank_put(...) when closing the file
    drops a zero reference.
    
    This was found via igt@kms_plane@pixel-format-pipe-A-planes.
    
    [How]
    Check the return code and return it on failure.
    
    We wouldn't have been able to enable CRC reading anyway since vblank
    wasn't enabled.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: David Francis <David.Francis@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index 365aaef3ecaf..eb114e377233 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -106,6 +106,7 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 	struct drm_dp_aux *aux = NULL;
 	bool enable = false;
 	bool enabled = false;
+	int ret;
 
 	enum amdgpu_dm_pipe_crc_source source = dm_parse_crc_source(src_name);
 
@@ -176,7 +177,10 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 	 */
 	enabled = amdgpu_dm_is_valid_crc_source(crtc_state->crc_src);
 	if (!enabled && enable) {
-		drm_crtc_vblank_get(crtc);
+		ret = drm_crtc_vblank_get(crtc);
+		if (ret)
+			return ret;
+
 		if (dm_is_crc_source_dprx(source)) {
 			if (drm_dp_start_crc(aux, crtc)) {
 				DRM_DEBUG_DRIVER("dp start crc failed\n");

commit f1cdc98fd9d9bb0eb4b6599825b52ce25757eb9f
Author: Dingchen Zhang <dingchen.zhang@amd.com>
Date:   Fri Jun 28 17:23:24 2019 -0400

    drm/amd/display: add pipe CRC sources without disabling dithering.
    
    [Why]
    need to verify the impact of spatial dithering on 8bpc bypass mode.
    
    [How]
    added CRC sources and configure dihter option from dc stream.
    
    Signed-off-by: Dingchen Zhang <dingchen.zhang@amd.com>
    Reviewed-by: Hanghong Ma <Hanghong.Ma@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index b966e1410484..365aaef3ecaf 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -33,7 +33,9 @@
 static const char *const pipe_crc_sources[] = {
 	"none",
 	"crtc",
+	"crtc dither",
 	"dprx",
+	"dprx dither",
 	"auto",
 };
 
@@ -45,10 +47,33 @@ static enum amdgpu_dm_pipe_crc_source dm_parse_crc_source(const char *source)
 		return AMDGPU_DM_PIPE_CRC_SOURCE_CRTC;
 	if (!strcmp(source, "dprx"))
 		return AMDGPU_DM_PIPE_CRC_SOURCE_DPRX;
+	if (!strcmp(source, "crtc dither"))
+		return AMDGPU_DM_PIPE_CRC_SOURCE_CRTC_DITHER;
+	if (!strcmp(source, "dprx dither"))
+		return AMDGPU_DM_PIPE_CRC_SOURCE_DPRX_DITHER;
 
 	return AMDGPU_DM_PIPE_CRC_SOURCE_INVALID;
 }
 
+static bool dm_is_crc_source_crtc(enum amdgpu_dm_pipe_crc_source src)
+{
+	return (src == AMDGPU_DM_PIPE_CRC_SOURCE_CRTC) ||
+	       (src == AMDGPU_DM_PIPE_CRC_SOURCE_CRTC_DITHER);
+}
+
+static bool dm_is_crc_source_dprx(enum amdgpu_dm_pipe_crc_source src)
+{
+	return (src == AMDGPU_DM_PIPE_CRC_SOURCE_DPRX) ||
+	       (src == AMDGPU_DM_PIPE_CRC_SOURCE_DPRX_DITHER);
+}
+
+static bool dm_need_crc_dither(enum amdgpu_dm_pipe_crc_source src)
+{
+	return (src == AMDGPU_DM_PIPE_CRC_SOURCE_CRTC_DITHER) ||
+	       (src == AMDGPU_DM_PIPE_CRC_SOURCE_DPRX_DITHER) ||
+	       (src == AMDGPU_DM_PIPE_CRC_SOURCE_NONE);
+}
+
 const char *const *amdgpu_dm_crtc_get_crc_sources(struct drm_crtc *crtc,
 						  size_t *count)
 {
@@ -102,14 +127,18 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 	 * USER REQ SRC | CURRENT SRC | BEHAVIOR
 	 * -----------------------------
 	 * None         | None        | Do nothing
-	 * None         | CRTC        | Disable CRTC CRC
-	 * None         | DPRX        | Disable DPRX CRC, need 'aux'
-	 * CRTC         | XXXX        | Enable CRTC CRC, configure DC strm
-	 * DPRX         | XXXX        | Enable DPRX CRC, need 'aux'
+	 * None         | CRTC        | Disable CRTC CRC, set default to dither
+	 * None         | DPRX        | Disable DPRX CRC, need 'aux', set default to dither
+	 * None         | CRTC DITHER | Disable CRTC CRC
+	 * None         | DPRX DITHER | Disable DPRX CRC, need 'aux'
+	 * CRTC         | XXXX        | Enable CRTC CRC, no dither
+	 * DPRX         | XXXX        | Enable DPRX CRC, need 'aux', no dither
+	 * CRTC DITHER  | XXXX        | Enable CRTC CRC, set dither
+	 * DPRX DITHER  | XXXX        | Enable DPRX CRC, need 'aux', set dither
 	 */
-	if (source == AMDGPU_DM_PIPE_CRC_SOURCE_DPRX ||
+	if (dm_is_crc_source_dprx(source) ||
 		(source == AMDGPU_DM_PIPE_CRC_SOURCE_NONE &&
-		 crtc_state->crc_src == AMDGPU_DM_PIPE_CRC_SOURCE_DPRX)) {
+		 dm_is_crc_source_dprx(crtc_state->crc_src))) {
 		aconn = stream_state->link->priv;
 
 		if (!aconn) {
@@ -125,7 +154,7 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 			mutex_unlock(&adev->dm.dc_lock);
 			return -EINVAL;
 		}
-	} else if (source == AMDGPU_DM_PIPE_CRC_SOURCE_CRTC) {
+	} else if (dm_is_crc_source_crtc(source)) {
 		if (!dc_stream_configure_crc(stream_state->ctx->dc, stream_state,
 					     enable, enable)) {
 			mutex_unlock(&adev->dm.dc_lock);
@@ -133,10 +162,11 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 		}
 	}
 
-	/* When enabling CRC, we should also disable dithering. */
-	dc_stream_set_dither_option(stream_state,
-				    enable ? DITHER_OPTION_TRUN8
-					   : DITHER_OPTION_DEFAULT);
+	/* configure dithering */
+	if (!dm_need_crc_dither(source))
+		dc_stream_set_dither_option(stream_state, DITHER_OPTION_TRUN8);
+	else if (!dm_need_crc_dither(crtc_state->crc_src))
+		dc_stream_set_dither_option(stream_state, DITHER_OPTION_DEFAULT);
 
 	mutex_unlock(&adev->dm.dc_lock);
 
@@ -147,7 +177,7 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 	enabled = amdgpu_dm_is_valid_crc_source(crtc_state->crc_src);
 	if (!enabled && enable) {
 		drm_crtc_vblank_get(crtc);
-		if (source == AMDGPU_DM_PIPE_CRC_SOURCE_DPRX) {
+		if (dm_is_crc_source_dprx(source)) {
 			if (drm_dp_start_crc(aux, crtc)) {
 				DRM_DEBUG_DRIVER("dp start crc failed\n");
 				return -EINVAL;
@@ -155,7 +185,7 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 		}
 	} else if (enabled && !enable) {
 		drm_crtc_vblank_put(crtc);
-		if (crtc_state->crc_src == AMDGPU_DM_PIPE_CRC_SOURCE_DPRX) {
+		if (dm_is_crc_source_dprx(source)) {
 			if (drm_dp_stop_crc(aux)) {
 				DRM_DEBUG_DRIVER("dp stop crc failed\n");
 				return -EINVAL;
@@ -204,7 +234,7 @@ void amdgpu_dm_crtc_handle_crc_irq(struct drm_crtc *crtc)
 		return;
 	}
 
-	if (crtc_state->crc_src == AMDGPU_DM_PIPE_CRC_SOURCE_CRTC) {
+	if (dm_is_crc_source_crtc(crtc_state->crc_src)) {
 		if (!dc_stream_get_crc(stream_state->ctx->dc, stream_state,
 				       &crcs[0], &crcs[1], &crcs[2]))
 			return;

commit 8fb843d179a6fff1bfe037601b06980ba9a56167
Author: Dingchen Zhang <dingchen.zhang@amd.com>
Date:   Wed May 29 18:52:52 2019 -0400

    drm/amd/display: add functionality to get pipe CRC source.
    
    [Why]
    We need to check the pipe crc source through debugfs for bypass mode test.
    
    [How]
    add implementation of amdgpu_dm_crtc_get_crc_sources and hook into drm_crtc
    callback get_crc_sources.
    
    Signed-off-by: Dingchen Zhang <dingchen.zhang@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index 9af270161a0e..b966e1410484 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -30,6 +30,13 @@
 #include "amdgpu_dm.h"
 #include "dc.h"
 
+static const char *const pipe_crc_sources[] = {
+	"none",
+	"crtc",
+	"dprx",
+	"auto",
+};
+
 static enum amdgpu_dm_pipe_crc_source dm_parse_crc_source(const char *source)
 {
 	if (!source || !strcmp(source, "none"))
@@ -42,6 +49,13 @@ static enum amdgpu_dm_pipe_crc_source dm_parse_crc_source(const char *source)
 	return AMDGPU_DM_PIPE_CRC_SOURCE_INVALID;
 }
 
+const char *const *amdgpu_dm_crtc_get_crc_sources(struct drm_crtc *crtc,
+						  size_t *count)
+{
+	*count = ARRAY_SIZE(pipe_crc_sources);
+	return pipe_crc_sources;
+}
+
 int
 amdgpu_dm_crtc_verify_crc_source(struct drm_crtc *crtc, const char *src_name,
 				 size_t *values_cnt)

commit 14b2584636c66efbb9a8dd1c702d5da73ecf620d
Author: Dingchen Zhang <dingchen.zhang@amd.com>
Date:   Wed May 15 17:15:05 2019 -0400

    drm/amd/display: add functionality to grab DPRX CRC entries.
    
    [Why]
    We need to compare DPRX CRCs with framebuffer CRCs for digital bypass mode.
    
    [How]
    Hook into DRM to grab DP receiver CRCs through drm_dp_start_crc.
    
    Signed-off-by: Dingchen Zhang <dingchen.zhang@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index bc67e6502733..9af270161a0e 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -30,19 +30,14 @@
 #include "amdgpu_dm.h"
 #include "dc.h"
 
-enum amdgpu_dm_pipe_crc_source {
-	AMDGPU_DM_PIPE_CRC_SOURCE_NONE = 0,
-	AMDGPU_DM_PIPE_CRC_SOURCE_AUTO,
-	AMDGPU_DM_PIPE_CRC_SOURCE_MAX,
-	AMDGPU_DM_PIPE_CRC_SOURCE_INVALID = -1,
-};
-
 static enum amdgpu_dm_pipe_crc_source dm_parse_crc_source(const char *source)
 {
 	if (!source || !strcmp(source, "none"))
 		return AMDGPU_DM_PIPE_CRC_SOURCE_NONE;
-	if (!strcmp(source, "auto"))
-		return AMDGPU_DM_PIPE_CRC_SOURCE_AUTO;
+	if (!strcmp(source, "auto") || !strcmp(source, "crtc"))
+		return AMDGPU_DM_PIPE_CRC_SOURCE_CRTC;
+	if (!strcmp(source, "dprx"))
+		return AMDGPU_DM_PIPE_CRC_SOURCE_DPRX;
 
 	return AMDGPU_DM_PIPE_CRC_SOURCE_INVALID;
 }
@@ -68,7 +63,10 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 	struct amdgpu_device *adev = crtc->dev->dev_private;
 	struct dm_crtc_state *crtc_state = to_dm_crtc_state(crtc->state);
 	struct dc_stream_state *stream_state = crtc_state->stream;
-	bool enable;
+	struct amdgpu_dm_connector *aconn;
+	struct drm_dp_aux *aux = NULL;
+	bool enable = false;
+	bool enabled = false;
 
 	enum amdgpu_dm_pipe_crc_source source = dm_parse_crc_source(src_name);
 
@@ -83,13 +81,42 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 		return -EINVAL;
 	}
 
-	enable = (source == AMDGPU_DM_PIPE_CRC_SOURCE_AUTO);
+	enable = amdgpu_dm_is_valid_crc_source(source);
 
 	mutex_lock(&adev->dm.dc_lock);
-	if (!dc_stream_configure_crc(stream_state->ctx->dc, stream_state,
-				     enable, enable)) {
-		mutex_unlock(&adev->dm.dc_lock);
-		return -EINVAL;
+	/*
+	 * USER REQ SRC | CURRENT SRC | BEHAVIOR
+	 * -----------------------------
+	 * None         | None        | Do nothing
+	 * None         | CRTC        | Disable CRTC CRC
+	 * None         | DPRX        | Disable DPRX CRC, need 'aux'
+	 * CRTC         | XXXX        | Enable CRTC CRC, configure DC strm
+	 * DPRX         | XXXX        | Enable DPRX CRC, need 'aux'
+	 */
+	if (source == AMDGPU_DM_PIPE_CRC_SOURCE_DPRX ||
+		(source == AMDGPU_DM_PIPE_CRC_SOURCE_NONE &&
+		 crtc_state->crc_src == AMDGPU_DM_PIPE_CRC_SOURCE_DPRX)) {
+		aconn = stream_state->link->priv;
+
+		if (!aconn) {
+			DRM_DEBUG_DRIVER("No amd connector matching CRTC-%d\n", crtc->index);
+			mutex_unlock(&adev->dm.dc_lock);
+			return -EINVAL;
+		}
+
+		aux = &aconn->dm_dp_aux.aux;
+
+		if (!aux) {
+			DRM_DEBUG_DRIVER("No dp aux for amd connector\n");
+			mutex_unlock(&adev->dm.dc_lock);
+			return -EINVAL;
+		}
+	} else if (source == AMDGPU_DM_PIPE_CRC_SOURCE_CRTC) {
+		if (!dc_stream_configure_crc(stream_state->ctx->dc, stream_state,
+					     enable, enable)) {
+			mutex_unlock(&adev->dm.dc_lock);
+			return -EINVAL;
+		}
 	}
 
 	/* When enabling CRC, we should also disable dithering. */
@@ -103,12 +130,26 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 	 * Reading the CRC requires the vblank interrupt handler to be
 	 * enabled. Keep a reference until CRC capture stops.
 	 */
-	if (!crtc_state->crc_enabled && enable)
+	enabled = amdgpu_dm_is_valid_crc_source(crtc_state->crc_src);
+	if (!enabled && enable) {
 		drm_crtc_vblank_get(crtc);
-	else if (crtc_state->crc_enabled && !enable)
+		if (source == AMDGPU_DM_PIPE_CRC_SOURCE_DPRX) {
+			if (drm_dp_start_crc(aux, crtc)) {
+				DRM_DEBUG_DRIVER("dp start crc failed\n");
+				return -EINVAL;
+			}
+		}
+	} else if (enabled && !enable) {
 		drm_crtc_vblank_put(crtc);
+		if (crtc_state->crc_src == AMDGPU_DM_PIPE_CRC_SOURCE_DPRX) {
+			if (drm_dp_stop_crc(aux)) {
+				DRM_DEBUG_DRIVER("dp stop crc failed\n");
+				return -EINVAL;
+			}
+		}
+	}
 
-	crtc_state->crc_enabled = enable;
+	crtc_state->crc_src = source;
 
 	/* Reset crc_skipped on dm state */
 	crtc_state->crc_skip_count = 0;
@@ -135,7 +176,7 @@ void amdgpu_dm_crtc_handle_crc_irq(struct drm_crtc *crtc)
 	stream_state = crtc_state->stream;
 
 	/* Early return if CRC capture is not enabled. */
-	if (!crtc_state->crc_enabled)
+	if (!amdgpu_dm_is_valid_crc_source(crtc_state->crc_src))
 		return;
 
 	/*
@@ -149,10 +190,12 @@ void amdgpu_dm_crtc_handle_crc_irq(struct drm_crtc *crtc)
 		return;
 	}
 
-	if (!dc_stream_get_crc(stream_state->ctx->dc, stream_state,
-			       &crcs[0], &crcs[1], &crcs[2]))
-		return;
+	if (crtc_state->crc_src == AMDGPU_DM_PIPE_CRC_SOURCE_CRTC) {
+		if (!dc_stream_get_crc(stream_state->ctx->dc, stream_state,
+				       &crcs[0], &crcs[1], &crcs[2]))
+			return;
 
-	drm_crtc_add_crc_entry(crtc, true,
-			       drm_crtc_accurate_vblank_count(crtc), crcs);
+		drm_crtc_add_crc_entry(crtc, true,
+				       drm_crtc_accurate_vblank_count(crtc), crcs);
+	}
 }

commit f867723b41f871c88388462c007976bb9a4c72da
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:51 2019 +0200

    drm/amd: drop use of drmP.h in amdgpu.h
    
    Delete the unused drmP.h from amdgpu.h.
    Fix fallout in various files.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-5-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index a10e3a50d9ef..bc67e6502733 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -24,6 +24,7 @@
  */
 
 #include <drm/drm_crtc.h>
+#include <drm/drm_vblank.h>
 
 #include "amdgpu.h"
 #include "amdgpu_dm.h"

commit 43a6a02eb3558d1f3a0618f9bf02328662fb06e3
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue Jan 15 10:33:58 2019 -0500

    drm/amd/display: Re-enable CRC capture following modeset
    
    [Why]
    During any modeset the CRTC stream is removed and a new stream is added.
    This new stream doesn't carry over CRC capture state if it was
    previously set.
    
    [How]
    Re-program the stream for CRC capture. The existing DRM callback can
    be re-used here for the most part - the only modification needed is
    additional locking now that it's called from within commit tail.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Sun peng Li <Sunpeng.Li@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index 26b651148c67..a10e3a50d9ef 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -64,6 +64,7 @@ amdgpu_dm_crtc_verify_crc_source(struct drm_crtc *crtc, const char *src_name,
 
 int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 {
+	struct amdgpu_device *adev = crtc->dev->dev_private;
 	struct dm_crtc_state *crtc_state = to_dm_crtc_state(crtc->state);
 	struct dc_stream_state *stream_state = crtc_state->stream;
 	bool enable;
@@ -83,15 +84,20 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 
 	enable = (source == AMDGPU_DM_PIPE_CRC_SOURCE_AUTO);
 
+	mutex_lock(&adev->dm.dc_lock);
 	if (!dc_stream_configure_crc(stream_state->ctx->dc, stream_state,
-				     enable, enable))
+				     enable, enable)) {
+		mutex_unlock(&adev->dm.dc_lock);
 		return -EINVAL;
+	}
 
 	/* When enabling CRC, we should also disable dithering. */
 	dc_stream_set_dither_option(stream_state,
 				    enable ? DITHER_OPTION_TRUN8
 					   : DITHER_OPTION_DEFAULT);
 
+	mutex_unlock(&adev->dm.dc_lock);
+
 	/*
 	 * Reading the CRC requires the vblank interrupt handler to be
 	 * enabled. Keep a reference until CRC capture stops.

commit 428da2bdb05d76c48d0bd8fbfa2e4c102685be08
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Mon Jan 14 16:04:10 2019 -0500

    drm/amd/display: Enable vblank interrupt during CRC capture
    
    [Why]
    In order to read CRC events when CRC capture is enabled the vblank
    interrput handler needs to be running for the CRTC. The handler is
    enabled while there is an active vblank reference.
    
    When running IGT tests there will often be no active vblank reference
    but the test expects to read a CRC value. This is valid usage (and
    works on i915 since they have a CRC interrupt handler) so the reference
    to the vblank should be grabbed while capture is active.
    
    This issue was found running:
    
    igt@kms_plane_multiple@atomic-pipe-b-tiling-none
    
    The pipe-b is the only one in the initial commit and was not previously
    active so no vblank reference is grabbed. The vblank interrupt is
    not enabled and the test times out.
    
    [How]
    Keep a reference to the vblank as long as CRC capture is enabled.
    If userspace never explicitly disables it then the reference is
    also dropped when removing the CRTC from the context (stream = NULL).
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Sun peng Li <Sunpeng.Li@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index f088ac585978..26b651148c67 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -66,6 +66,7 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 {
 	struct dm_crtc_state *crtc_state = to_dm_crtc_state(crtc->state);
 	struct dc_stream_state *stream_state = crtc_state->stream;
+	bool enable;
 
 	enum amdgpu_dm_pipe_crc_source source = dm_parse_crc_source(src_name);
 
@@ -80,28 +81,27 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 		return -EINVAL;
 	}
 
+	enable = (source == AMDGPU_DM_PIPE_CRC_SOURCE_AUTO);
+
+	if (!dc_stream_configure_crc(stream_state->ctx->dc, stream_state,
+				     enable, enable))
+		return -EINVAL;
+
 	/* When enabling CRC, we should also disable dithering. */
-	if (source == AMDGPU_DM_PIPE_CRC_SOURCE_AUTO) {
-		if (dc_stream_configure_crc(stream_state->ctx->dc,
-					    stream_state,
-					    true, true)) {
-			crtc_state->crc_enabled = true;
-			dc_stream_set_dither_option(stream_state,
-						    DITHER_OPTION_TRUN8);
-		}
-		else
-			return -EINVAL;
-	} else {
-		if (dc_stream_configure_crc(stream_state->ctx->dc,
-					    stream_state,
-					    false, false)) {
-			crtc_state->crc_enabled = false;
-			dc_stream_set_dither_option(stream_state,
-						    DITHER_OPTION_DEFAULT);
-		}
-		else
-			return -EINVAL;
-	}
+	dc_stream_set_dither_option(stream_state,
+				    enable ? DITHER_OPTION_TRUN8
+					   : DITHER_OPTION_DEFAULT);
+
+	/*
+	 * Reading the CRC requires the vblank interrupt handler to be
+	 * enabled. Keep a reference until CRC capture stops.
+	 */
+	if (!crtc_state->crc_enabled && enable)
+		drm_crtc_vblank_get(crtc);
+	else if (crtc_state->crc_enabled && !enable)
+		drm_crtc_vblank_put(crtc);
+
+	crtc_state->crc_enabled = enable;
 
 	/* Reset crc_skipped on dm state */
 	crtc_state->crc_skip_count = 0;

commit f41a895026b8cb6f765190de7d2e7bc3ccbbd183
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Thu Oct 18 15:49:41 2018 -0400

    drm/amd/display: Guard against null stream_state in set_crc_source
    
    [Why]
    
    The igt@kms_plane@pixel-format-pipe tests can create a sequence where
    stream_state is NULL during amdgpu_dm_crtc_set_crc_source which results
    in a null pointer dereference.
    
    [How]
    
    Guard against stream_state being NULL before accessing its fields. This
    doesn't fix the root cause of the issue so a DRM_ERROR is generated
    to still fail the tests.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: David Francis <David.Francis@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index 01fc5717b657..f088ac585978 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -75,6 +75,11 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 		return -EINVAL;
 	}
 
+	if (!stream_state) {
+		DRM_ERROR("No stream state for CRTC%d\n", crtc->index);
+		return -EINVAL;
+	}
+
 	/* When enabling CRC, we should also disable dithering. */
 	if (source == AMDGPU_DM_PIPE_CRC_SOURCE_AUTO) {
 		if (dc_stream_configure_crc(stream_state->ctx->dc,

commit bc537a9cc47eec7f4e32b8164c494ddc35dca8ac
Merge: a5ec8332d428 5b394b2ddf03
Author: Sean Paul <seanpaul@chromium.org>
Date:   Mon Aug 27 10:00:03 2018 -0400

    Merge drm/drm-next into drm-misc-next
    
    Now that 4.19-rc1 is cut, backmerge it into -misc-next.
    
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

commit c0811a7d5befe34a17772760100e26b09a561c0e
Author: Mahesh Kumar <mahesh1.kumar@intel.com>
Date:   Tue Aug 21 14:08:56 2018 +0530

    drm/crc: Cleanup crtc_crc_open function
    
    This patch make changes to allocate crc-entries buffer before
    enabling CRC generation.
    It moves all the failure check early in the function before setting
    the source or memory allocation.
    Now set_crc_source takes only two variable inputs, values_cnt we
    already gets as part of verify_crc_source.
    
    Changes since V1:
     - refactor code to use single spin lock
    Changes since V2:
     - rebase
    Changes since V3:
     - rebase on top of VKMS driver
    
    Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
    Cc: dri-devel@lists.freedesktop.org
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Haneen Mohammed <hamohammed.sa@gmail.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Acked-by: Leo Li <sunpeng.li@amd.com> (V2)
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com> (V3)
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180821083858.26275-3-mahesh1.kumar@intel.com

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index dfcca594d52a..e7ad528f5853 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -62,8 +62,7 @@ amdgpu_dm_crtc_verify_crc_source(struct drm_crtc *crtc, const char *src_name,
 	return 0;
 }
 
-int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name,
-			   size_t *values_cnt)
+int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name)
 {
 	struct dm_crtc_state *crtc_state = to_dm_crtc_state(crtc->state);
 	struct dc_stream_state *stream_state = crtc_state->stream;
@@ -99,7 +98,6 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name,
 			return -EINVAL;
 	}
 
-	*values_cnt = 3;
 	/* Reset crc_skipped on dm state */
 	crtc_state->crc_skip_count = 0;
 	return 0;

commit dddc0557e3a02499ce336b1e2e67f5afaecccc80
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Fri Aug 3 10:40:20 2018 -0400

    drm/amd/display: Guard against null crtc in CRC IRQ
    
    [Why]
    
    A null pointer deference can occur if crtc is null in
    amdgpu_dm_crtc_handle_crc_irq. This can happen if get_crtc_by_otg_inst
    returns NULL during dm_crtc_high_irq, leading to a hang in some IGT
    test cases.
    
    [How]
    
    Check that CRTC is non-null before accessing its fields.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Sun peng Li <Sunpeng.Li@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index 52f2c01349e3..9bfb040352e9 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -98,10 +98,16 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name,
  */
 void amdgpu_dm_crtc_handle_crc_irq(struct drm_crtc *crtc)
 {
-	struct dm_crtc_state *crtc_state = to_dm_crtc_state(crtc->state);
-	struct dc_stream_state *stream_state = crtc_state->stream;
+	struct dm_crtc_state *crtc_state;
+	struct dc_stream_state *stream_state;
 	uint32_t crcs[3];
 
+	if (crtc == NULL)
+		return;
+
+	crtc_state = to_dm_crtc_state(crtc->state);
+	stream_state = crtc_state->stream;
+
 	/* Early return if CRC capture is not enabled. */
 	if (!crtc_state->crc_enabled)
 		return;

commit 3b3b8448ebd1e54927bf7a77be9d6eac11441bfd
Author: Mahesh Kumar <mahesh1.kumar@intel.com>
Date:   Fri Jul 13 19:29:36 2018 +0530

    drm/amdgpu_dm/crc: Implement verify_crc_source callback
    
    This patch implements "verify_crc_source" callback function for
    AMD drm driver.
    
    Signed-off-by: Mahesh Kumar <mahesh1.kumar@intel.com>
    Cc: dri-devel@lists.freedesktop.org
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180713135942.25061-5-mahesh1.kumar@intel.com

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index 52f2c01349e3..dfcca594d52a 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -46,6 +46,22 @@ static enum amdgpu_dm_pipe_crc_source dm_parse_crc_source(const char *source)
 	return AMDGPU_DM_PIPE_CRC_SOURCE_INVALID;
 }
 
+int
+amdgpu_dm_crtc_verify_crc_source(struct drm_crtc *crtc, const char *src_name,
+				 size_t *values_cnt)
+{
+	enum amdgpu_dm_pipe_crc_source source = dm_parse_crc_source(src_name);
+
+	if (source < 0) {
+		DRM_DEBUG_DRIVER("Unknown CRC source %s for CRTC%d\n",
+				 src_name, crtc->index);
+		return -EINVAL;
+	}
+
+	*values_cnt = 3;
+	return 0;
+}
+
 int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name,
 			   size_t *values_cnt)
 {

commit a0a31ec4ce6a8c8bc4f4b8619b537e4a9a0ddaf1
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Feb 6 10:20:46 2018 -0500

    drm/amd/display: Skip 2 frames when first reading CRC
    
    Skipping the first frame will prevent uncoooked values most of the time.
    However, in some unlikely cases, the second frame will be uncooked as
    well.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index 55aa379cfcbe..52f2c01349e3 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -84,8 +84,8 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name,
 	}
 
 	*values_cnt = 3;
-	/* Reset crc_skipped flag on dm state */
-	crtc_state->crc_first_skipped = false;
+	/* Reset crc_skipped on dm state */
+	crtc_state->crc_skip_count = 0;
 	return 0;
 }
 
@@ -109,11 +109,11 @@ void amdgpu_dm_crtc_handle_crc_irq(struct drm_crtc *crtc)
 	/*
 	 * Since flipping and crc enablement happen asynchronously, we - more
 	 * often than not - will be returning an 'uncooked' crc on first frame.
-	 * Probably because hw isn't ready yet. Simply skip the first crc
-	 * value.
+	 * Probably because hw isn't ready yet. For added security, skip the
+	 * first two CRC values.
 	 */
-	if (!crtc_state->crc_first_skipped) {
-		crtc_state->crc_first_skipped = true;
+	if (crtc_state->crc_skip_count < 2) {
+		crtc_state->crc_skip_count += 1;
 		return;
 	}
 

commit aed7b06e49d2a4ceec6e71a33a2365576fc9c4da
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Jan 23 17:43:37 2018 -0500

    drm/amd/display: When enabling CRC, disable dither & enable truncation
    
    When user-mode is using 8bpc, the hardware represents it internally
    using a higher bit depth. This causes problems when comparing CRCs for
    color managment tests.
    
    We need to disable dithering as well, since it makes CRC values
    non-deterministic.
    
    It's easy to see why dithering needs to be disabled, The reason why
    truncation also needs to be enabled is better described with an example.
    Consider the folowing which tests the color transform matrix (CTM):
    
    Expected CRC = FB_A -> Degamma (Bypassed) -> CTM (Bypassed)
                                                      |
                                                      v
                                Obtain CRC  <- Regamma(Bypassed)
    
    Actual CRC = FB_B -> Degamma (Bypassed) -> CTM (0.5*Identity)
                                                      |
                                                      v
                                Obtain CRC  <- Regamma(Bypassed)
    
    FB_A contains a solid red color at half intensity (127 @ 8bpc)
    FB_B contains a solid red color at full intensity (255 @ 8bpc)
    
    We expect that Expected CRC = Actual CRC, but that's not the case. When
    the CTM is applied, the output is at half intensity, but also at a
    higher bit depth within hardware. i.e. 255/2 = 127.5: not representable
    in 8bpc, but can be at 10bpc. This causes the two CRC's to be different.
    
    The solution is to truncate the output bit depth to the same as input
    when enabling CRC capture. Since Linux only supports 8bpc, hard code
    that for now.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index e5fb53a56b73..55aa379cfcbe 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -60,18 +60,25 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name,
 		return -EINVAL;
 	}
 
+	/* When enabling CRC, we should also disable dithering. */
 	if (source == AMDGPU_DM_PIPE_CRC_SOURCE_AUTO) {
 		if (dc_stream_configure_crc(stream_state->ctx->dc,
 					    stream_state,
-					    true, true))
+					    true, true)) {
 			crtc_state->crc_enabled = true;
+			dc_stream_set_dither_option(stream_state,
+						    DITHER_OPTION_TRUN8);
+		}
 		else
 			return -EINVAL;
 	} else {
 		if (dc_stream_configure_crc(stream_state->ctx->dc,
 					    stream_state,
-					    false, false))
+					    false, false)) {
 			crtc_state->crc_enabled = false;
+			dc_stream_set_dither_option(stream_state,
+						    DITHER_OPTION_DEFAULT);
+		}
 		else
 			return -EINVAL;
 	}

commit d1bd7d61bc668a11224768cd77bb9d403ad04ffd
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Wed Jan 3 13:04:21 2018 -0500

    drm/amd/display: Early return on crc get
    
    If crc is disabled, early return when getting crc's. That way, we avoid
    reading extra registers within the pflip high irq.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
index 5768103803fe..e5fb53a56b73 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -51,7 +51,6 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name,
 {
 	struct dm_crtc_state *crtc_state = to_dm_crtc_state(crtc->state);
 	struct dc_stream_state *stream_state = crtc_state->stream;
-	bool ret;
 
 	enum amdgpu_dm_pipe_crc_source source = dm_parse_crc_source(src_name);
 
@@ -62,22 +61,25 @@ int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name,
 	}
 
 	if (source == AMDGPU_DM_PIPE_CRC_SOURCE_AUTO) {
-		ret = dc_stream_configure_crc(stream_state->ctx->dc,
-					      stream_state,
-					      true, true);
+		if (dc_stream_configure_crc(stream_state->ctx->dc,
+					    stream_state,
+					    true, true))
+			crtc_state->crc_enabled = true;
+		else
+			return -EINVAL;
 	} else {
-		ret = dc_stream_configure_crc(stream_state->ctx->dc,
-					      stream_state,
-					      false, false);
+		if (dc_stream_configure_crc(stream_state->ctx->dc,
+					    stream_state,
+					    false, false))
+			crtc_state->crc_enabled = false;
+		else
+			return -EINVAL;
 	}
 
-	if (ret) {
-		*values_cnt = 3;
-		/* Reset crc_skipped flag on dm state */
-		crtc_state->crc_first_skipped = false;
-		return 0;
-	}
-	return -EINVAL;
+	*values_cnt = 3;
+	/* Reset crc_skipped flag on dm state */
+	crtc_state->crc_first_skipped = false;
+	return 0;
 }
 
 /**
@@ -93,6 +95,10 @@ void amdgpu_dm_crtc_handle_crc_irq(struct drm_crtc *crtc)
 	struct dc_stream_state *stream_state = crtc_state->stream;
 	uint32_t crcs[3];
 
+	/* Early return if CRC capture is not enabled. */
+	if (!crtc_state->crc_enabled)
+		return;
+
 	/*
 	 * Since flipping and crc enablement happen asynchronously, we - more
 	 * often than not - will be returning an 'uncooked' crc on first frame.

commit 31aec354f92ca811df79439233130dbd232162a9
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Mon Dec 18 14:20:39 2017 -0500

    drm/amd/display: Implement interface for CRC on CRTC
    
    Add interfaces in DC for per CRTC CRC configuration and fetching.
    Also implement amdgpu_dm functions to hook onto DRM.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
new file mode 100644
index 000000000000..5768103803fe
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crc.c
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include <drm/drm_crtc.h>
+
+#include "amdgpu.h"
+#include "amdgpu_dm.h"
+#include "dc.h"
+
+enum amdgpu_dm_pipe_crc_source {
+	AMDGPU_DM_PIPE_CRC_SOURCE_NONE = 0,
+	AMDGPU_DM_PIPE_CRC_SOURCE_AUTO,
+	AMDGPU_DM_PIPE_CRC_SOURCE_MAX,
+	AMDGPU_DM_PIPE_CRC_SOURCE_INVALID = -1,
+};
+
+static enum amdgpu_dm_pipe_crc_source dm_parse_crc_source(const char *source)
+{
+	if (!source || !strcmp(source, "none"))
+		return AMDGPU_DM_PIPE_CRC_SOURCE_NONE;
+	if (!strcmp(source, "auto"))
+		return AMDGPU_DM_PIPE_CRC_SOURCE_AUTO;
+
+	return AMDGPU_DM_PIPE_CRC_SOURCE_INVALID;
+}
+
+int amdgpu_dm_crtc_set_crc_source(struct drm_crtc *crtc, const char *src_name,
+			   size_t *values_cnt)
+{
+	struct dm_crtc_state *crtc_state = to_dm_crtc_state(crtc->state);
+	struct dc_stream_state *stream_state = crtc_state->stream;
+	bool ret;
+
+	enum amdgpu_dm_pipe_crc_source source = dm_parse_crc_source(src_name);
+
+	if (source < 0) {
+		DRM_DEBUG_DRIVER("Unknown CRC source %s for CRTC%d\n",
+				 src_name, crtc->index);
+		return -EINVAL;
+	}
+
+	if (source == AMDGPU_DM_PIPE_CRC_SOURCE_AUTO) {
+		ret = dc_stream_configure_crc(stream_state->ctx->dc,
+					      stream_state,
+					      true, true);
+	} else {
+		ret = dc_stream_configure_crc(stream_state->ctx->dc,
+					      stream_state,
+					      false, false);
+	}
+
+	if (ret) {
+		*values_cnt = 3;
+		/* Reset crc_skipped flag on dm state */
+		crtc_state->crc_first_skipped = false;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+/**
+ * amdgpu_dm_crtc_handle_crc_irq: Report to DRM the CRC on given CRTC.
+ * @crtc: DRM CRTC object.
+ *
+ * This function should be called at the end of a vblank, when the fb has been
+ * fully processed through the pipe.
+ */
+void amdgpu_dm_crtc_handle_crc_irq(struct drm_crtc *crtc)
+{
+	struct dm_crtc_state *crtc_state = to_dm_crtc_state(crtc->state);
+	struct dc_stream_state *stream_state = crtc_state->stream;
+	uint32_t crcs[3];
+
+	/*
+	 * Since flipping and crc enablement happen asynchronously, we - more
+	 * often than not - will be returning an 'uncooked' crc on first frame.
+	 * Probably because hw isn't ready yet. Simply skip the first crc
+	 * value.
+	 */
+	if (!crtc_state->crc_first_skipped) {
+		crtc_state->crc_first_skipped = true;
+		return;
+	}
+
+	if (!dc_stream_get_crc(stream_state->ctx->dc, stream_state,
+			       &crcs[0], &crcs[1], &crcs[2]))
+		return;
+
+	drm_crtc_add_crc_entry(crtc, true,
+			       drm_crtc_accurate_vblank_count(crtc), crcs);
+}
