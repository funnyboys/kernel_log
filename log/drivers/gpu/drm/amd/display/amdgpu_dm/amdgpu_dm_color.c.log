commit a8bf7164908827178fe31fb21d2646c404c1990d
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Wed Apr 22 18:08:02 2020 -0400

    drm/amd/display: Internal refactoring to abstract color caps
    
    [Why&How]
    modules/color calculates various colour operations which are translated
    to abstracted HW. DCE 5-12 had almost no important changes, but
    starting with DCN1, every new generation comes with fairly major
    differences in color pipeline.
    We would hack it with some DCN checks, but a better approach is to
    abstract color pipe capabilities so modules/DM can decide mapping to
    HW block based on logical capabilities,
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index 838f35668f12..4dfb6b55bb2e 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -239,7 +239,8 @@ static int __set_output_tf(struct dc_transfer_func *func,
 		 * instead to simulate this.
 		 */
 		gamma->type = GAMMA_CUSTOM;
-		res = mod_color_calculate_degamma_params(func, gamma, true);
+		res = mod_color_calculate_degamma_params(NULL, func,
+							gamma, true);
 	} else {
 		/*
 		 * Assume sRGB. The actual mapping will depend on whether the
@@ -271,7 +272,7 @@ static int __set_input_tf(struct dc_transfer_func *func,
 
 	__drm_lut_to_dc_gamma(lut, gamma, false);
 
-	res = mod_color_calculate_degamma_params(func, gamma, true);
+	res = mod_color_calculate_degamma_params(NULL, func, gamma, true);
 	dc_gamma_release(&gamma);
 
 	return res ? 0 : -ENOMEM;
@@ -485,7 +486,7 @@ int amdgpu_dm_update_plane_color_mgmt(struct dm_crtc_state *crtc,
 		dc_plane_state->in_transfer_func->tf = tf;
 
 		if (tf != TRANSFER_FUNCTION_SRGB &&
-		    !mod_color_calculate_degamma_params(
+		    !mod_color_calculate_degamma_params(NULL,
 			    dc_plane_state->in_transfer_func, NULL, false))
 			return -ENOMEM;
 	} else {

commit e49233873604519dd38c57109d8814aaa319d509
Author: Stylon Wang <stylon.wang@amd.com>
Date:   Thu Apr 9 22:37:47 2020 +0800

    drm/amd/display: Adjust refactored dm for color management only
    
    [Why]
    Commit cdde482caabf2adad47d23f0d1e235db2c4f2b7d is causing regression
    from changing the order of call sequence.
    
    [How]
    Keep the call sequence and take in extra dm state only if plane-level
    color management is enabled.
    
    Fixes: cdde482caabf2a ("drm/amd/display: Refactor color management to take dm plane state")
    Signed-off-by: Stylon Wang <stylon.wang@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index d0554082f0dc..838f35668f12 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -416,10 +416,9 @@ int amdgpu_dm_update_crtc_color_mgmt(struct dm_crtc_state *crtc)
  * Returns 0 on success.
  */
 int amdgpu_dm_update_plane_color_mgmt(struct dm_crtc_state *crtc,
-				      struct dm_plane_state *plane)
+				      struct dc_plane_state *dc_plane_state)
 {
 	const struct drm_color_lut *degamma_lut;
-	struct dc_plane_state *dc_plane_state = plane->dc_state;
 	enum dc_transfer_func_predefined tf = TRANSFER_FUNCTION_SRGB;
 	uint32_t degamma_size;
 	int r;

commit 2059fc5e8c7f93442d18f9bcc82592fb089199e2
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue Mar 31 16:50:12 2020 -0400

    drm/amd/display: Use the correct input TF for video formats
    
    [Why]
    Color blending for NV12 formats is incorrect because we're using the
    predefined SRGB degamma.
    
    [How]
    Calculate the correct input transfer function for degamma from the color
    module depending on what the actual surface format is.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Zhan Liu <Zhan.Liu@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index 6b58761e4b04..d0554082f0dc 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -420,9 +420,21 @@ int amdgpu_dm_update_plane_color_mgmt(struct dm_crtc_state *crtc,
 {
 	const struct drm_color_lut *degamma_lut;
 	struct dc_plane_state *dc_plane_state = plane->dc_state;
+	enum dc_transfer_func_predefined tf = TRANSFER_FUNCTION_SRGB;
 	uint32_t degamma_size;
 	int r;
 
+	/* Get the correct base transfer function for implicit degamma. */
+	switch (dc_plane_state->format) {
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
+		/* DC doesn't have a transfer function for BT601 specifically. */
+		tf = TRANSFER_FUNCTION_BT709;
+		break;
+	default:
+		break;
+	}
+
 	if (crtc->cm_has_degamma) {
 		degamma_lut = __extract_blob_lut(crtc->base.degamma_lut,
 						 &degamma_size);
@@ -456,8 +468,7 @@ int amdgpu_dm_update_plane_color_mgmt(struct dm_crtc_state *crtc,
 		 * map these to the atomic one instead.
 		 */
 		if (crtc->cm_is_degamma_srgb)
-			dc_plane_state->in_transfer_func->tf =
-				TRANSFER_FUNCTION_SRGB;
+			dc_plane_state->in_transfer_func->tf = tf;
 		else
 			dc_plane_state->in_transfer_func->tf =
 				TRANSFER_FUNCTION_LINEAR;
@@ -472,7 +483,12 @@ int amdgpu_dm_update_plane_color_mgmt(struct dm_crtc_state *crtc,
 		 * in linear space. Assume that the input is sRGB.
 		 */
 		dc_plane_state->in_transfer_func->type = TF_TYPE_PREDEFINED;
-		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
+		dc_plane_state->in_transfer_func->tf = tf;
+
+		if (tf != TRANSFER_FUNCTION_SRGB &&
+		    !mod_color_calculate_degamma_params(
+			    dc_plane_state->in_transfer_func, NULL, false))
+			return -ENOMEM;
 	} else {
 		/* ...Otherwise we can just bypass the DGM block. */
 		dc_plane_state->in_transfer_func->type = TF_TYPE_BYPASS;

commit cdde482caabf2adad47d23f0d1e235db2c4f2b7d
Author: Stylon Wang <stylon.wang@amd.com>
Date:   Sun Apr 5 16:41:04 2020 -0400

    drm/amd/display: Refactor color management to take dm plane state
    
    [Why]
    - In amdgpu_dm_update_plane_color_mgmt() it is inconsistent in taking in
    dm_crtc_state and dc_plane_state.
    - Makes supporting plane-level color management with proper guard more
    complicated than necessary.
    
    [How]
    Pass in dm_plane_state in place of dc_plane_state in
    amdgpu_dm_update_plane_color_mgmt().
    
    Signed-off-by: Stylon Wang <stylon.wang@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index 2233d293a707..6b58761e4b04 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -416,9 +416,10 @@ int amdgpu_dm_update_crtc_color_mgmt(struct dm_crtc_state *crtc)
  * Returns 0 on success.
  */
 int amdgpu_dm_update_plane_color_mgmt(struct dm_crtc_state *crtc,
-				      struct dc_plane_state *dc_plane_state)
+				      struct dm_plane_state *plane)
 {
 	const struct drm_color_lut *degamma_lut;
+	struct dc_plane_state *dc_plane_state = plane->dc_state;
 	uint32_t degamma_size;
 	int r;
 

commit 0e3a7c2ec93b15f43a2653e52e9608484391aeaf
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Fri Oct 11 12:26:10 2019 -0400

    drm/amd/display: Free gamma after calculating legacy transfer function
    
    [Why]
    We're leaking memory by not freeing the gamma used to calculate the
    transfer function for legacy gamma.
    
    [How]
    Release the gamma after we're done with it.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index b43bb7f90e4e..2233d293a707 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -210,6 +210,8 @@ static int __set_legacy_tf(struct dc_transfer_func *func,
 	res = mod_color_calculate_regamma_params(func, gamma, true, has_rom,
 						 NULL);
 
+	dc_gamma_release(&gamma);
+
 	return res ? 0 : -ENOMEM;
 }
 

commit cf020d49b3c4ef6ab6f26be3dbf2f36b3df9f797
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Thu May 9 12:14:58 2019 -0400

    drm/amd/display: Rework CRTC color management
    
    [Why]
    To prepare for the upcoming DRM plane color management properties
    we need to correct a lot of wrong behavior and assumptions made for
    CRTC color management.
    
    The documentation added by this commit in amdgpu_dm_color explains
    how the HW color pipeline works and its limitations with the DRM
    interface.
    
    The current implementation does the following wrong:
    - Implicit sRGB DGM when no CRTC DGM is set
    - Implicit sRGB RGM when no CRTC RGM is set
    - No way to specify a non-linear DGM matrix that produces correct output
    - No way to specify a correct RGM when a linear DGM is used
    
    We had workarounds for passing kms_color tests but not all of the
    behavior we had wrong was covered by these tests (especially when
    it comes to non-linear DGM). Testing both DGM and RGM at the same time
    isn't something kms_color tests well either.
    
    [How]
    The specifics for how color management works in AMDGPU and the new
    behavior can be found by reading the documentation added to
    amdgpu_dm_color.c from this patch.
    
    All of the incorrect cases from the old implementation have been
    addressed for the atomic interface, but there still a few TODOs for
    the legacy one.
    
    Note: this does cause regressions for kms_color@pipe-a-ctm-* over HDMI.
    
    The result looks correct from visual inspection but the CRC no longer
    matches. For reference, the test was previously doing the following:
    
    linear degamma -> CTM -> sRGB regamma -> RGB to YUV (709) -> ...
    
    Now the test is doing:
    
    linear degamma -> CTM -> linear regamma -> RGB to YUV (709) -> ...
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Sun peng Li <Sunpeng.Li@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index 75b6a2ac910b..b43bb7f90e4e 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -27,6 +27,47 @@
 #include "amdgpu_dm.h"
 #include "dc.h"
 #include "modules/color/color_gamma.h"
+#include "basics/conversion.h"
+
+/*
+ * The DC interface to HW gives us the following color management blocks
+ * per pipe (surface):
+ *
+ * - Input gamma LUT (de-normalized)
+ * - Input CSC (normalized)
+ * - Surface degamma LUT (normalized)
+ * - Surface CSC (normalized)
+ * - Surface regamma LUT (normalized)
+ * - Output CSC (normalized)
+ *
+ * But these aren't a direct mapping to DRM color properties. The current DRM
+ * interface exposes CRTC degamma, CRTC CTM and CRTC regamma while our hardware
+ * is essentially giving:
+ *
+ * Plane CTM -> Plane degamma -> Plane CTM -> Plane regamma -> Plane CTM
+ *
+ * The input gamma LUT block isn't really applicable here since it operates
+ * on the actual input data itself rather than the HW fp representation. The
+ * input and output CSC blocks are technically available to use as part of
+ * the DC interface but are typically used internally by DC for conversions
+ * between color spaces. These could be blended together with user
+ * adjustments in the future but for now these should remain untouched.
+ *
+ * The pipe blending also happens after these blocks so we don't actually
+ * support any CRTC props with correct blending with multiple planes - but we
+ * can still support CRTC color management properties in DM in most single
+ * plane cases correctly with clever management of the DC interface in DM.
+ *
+ * As per DRM documentation, blocks should be in hardware bypass when their
+ * respective property is set to NULL. A linear DGM/RGM LUT should also
+ * considered as putting the respective block into bypass mode.
+ *
+ * This means that the following
+ * configuration is assumed to be the default:
+ *
+ * Plane DGM Bypass -> Plane CTM Bypass -> Plane RGM Bypass -> ...
+ * CRTC DGM Bypass -> CRTC CTM Bypass -> CRTC RGM Bypass
+ */
 
 #define MAX_DRM_LUT_VALUE 0xFFFF
 
@@ -41,6 +82,13 @@ void amdgpu_dm_init_color_mod(void)
 	setup_x_points_distribution();
 }
 
+/* Extracts the DRM lut and lut size from a blob. */
+static const struct drm_color_lut *
+__extract_blob_lut(const struct drm_property_blob *blob, uint32_t *size)
+{
+	*size = blob ? drm_color_lut_size(blob) : 0;
+	return blob ? (struct drm_color_lut *)blob->data : NULL;
+}
 
 /*
  * Return true if the given lut is a linear mapping of values, i.e. it acts
@@ -50,7 +98,7 @@ void amdgpu_dm_init_color_mod(void)
  * f(a) = (0xFF00/MAX_COLOR_LUT_ENTRIES-1)a; for integer a in
  *                                           [0, MAX_COLOR_LUT_ENTRIES)
  */
-static bool __is_lut_linear(struct drm_color_lut *lut, uint32_t size)
+static bool __is_lut_linear(const struct drm_color_lut *lut, uint32_t size)
 {
 	int i;
 	uint32_t expected;
@@ -75,9 +123,8 @@ static bool __is_lut_linear(struct drm_color_lut *lut, uint32_t size)
  * Convert the drm_color_lut to dc_gamma. The conversion depends on the size
  * of the lut - whether or not it's legacy.
  */
-static void __drm_lut_to_dc_gamma(struct drm_color_lut *lut,
-				  struct dc_gamma *gamma,
-				  bool is_legacy)
+static void __drm_lut_to_dc_gamma(const struct drm_color_lut *lut,
+				  struct dc_gamma *gamma, bool is_legacy)
 {
 	uint32_t r, g, b;
 	int i;
@@ -107,103 +154,16 @@ static void __drm_lut_to_dc_gamma(struct drm_color_lut *lut,
 	}
 }
 
-/**
- * amdgpu_dm_set_regamma_lut: Set regamma lut for the given CRTC.
- * @crtc: amdgpu_dm crtc state
- *
- * Update the underlying dc_stream_state's output transfer function (OTF) in
- * preparation for hardware commit. If no lut is specified by user, we default
- * to SRGB.
- *
- * RETURNS:
- * 0 on success, -ENOMEM if memory cannot be allocated to calculate the OTF.
- */
-int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
-{
-	struct drm_property_blob *blob = crtc->base.gamma_lut;
-	struct dc_stream_state *stream = crtc->stream;
-	struct amdgpu_device *adev = (struct amdgpu_device *)
-		crtc->base.state->dev->dev_private;
-	struct drm_color_lut *lut;
-	uint32_t lut_size;
-	struct dc_gamma *gamma = NULL;
-	enum dc_transfer_func_type old_type = stream->out_transfer_func->type;
-
-	bool ret;
-
-	if (!blob && adev->asic_type <= CHIP_RAVEN) {
-		/* By default, use the SRGB predefined curve.*/
-		stream->out_transfer_func->type = TF_TYPE_PREDEFINED;
-		stream->out_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
-		return 0;
-	}
-
-	if (blob) {
-		lut = (struct drm_color_lut *)blob->data;
-		lut_size = blob->length / sizeof(struct drm_color_lut);
-
-		gamma = dc_create_gamma();
-		if (!gamma)
-			return -ENOMEM;
-
-		gamma->num_entries = lut_size;
-		if (gamma->num_entries == MAX_COLOR_LEGACY_LUT_ENTRIES)
-			gamma->type = GAMMA_RGB_256;
-		else if (gamma->num_entries == MAX_COLOR_LUT_ENTRIES)
-			gamma->type = GAMMA_CS_TFM_1D;
-		else {
-			/* Invalid lut size */
-			dc_gamma_release(&gamma);
-			return -EINVAL;
-		}
-
-		/* Convert drm_lut into dc_gamma */
-		__drm_lut_to_dc_gamma(lut, gamma, gamma->type == GAMMA_RGB_256);
-	}
-
-	/* predefined gamma ROM only exist for RAVEN and pre-RAVEN ASIC,
-	 * set canRomBeUsed accordingly
-	 */
-	stream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
-	ret = mod_color_calculate_regamma_params(stream->out_transfer_func,
-			gamma, true, adev->asic_type <= CHIP_NAVI10, NULL);
-
-	if (gamma)
-		dc_gamma_release(&gamma);
-
-	if (!ret) {
-		stream->out_transfer_func->type = old_type;
-		DRM_ERROR("Out of memory when calculating regamma params\n");
-		return -ENOMEM;
-	}
-
-	return 0;
-}
-
-/**
- * amdgpu_dm_set_ctm: Set the color transform matrix for the given CRTC.
- * @crtc: amdgpu_dm crtc state
- *
- * Update the underlying dc_stream_state's gamut remap matrix in preparation
- * for hardware commit. If no matrix is specified by user, gamut remap will be
- * disabled.
+/*
+ * Converts a DRM CTM to a DC CSC float matrix.
+ * The matrix needs to be a 3x4 (12 entry) matrix.
  */
-void amdgpu_dm_set_ctm(struct dm_crtc_state *crtc)
+static void __drm_ctm_to_dc_matrix(const struct drm_color_ctm *ctm,
+				   struct fixed31_32 *matrix)
 {
-
-	struct drm_property_blob *blob = crtc->base.ctm;
-	struct dc_stream_state *stream = crtc->stream;
-	struct drm_color_ctm *ctm;
 	int64_t val;
 	int i;
 
-	if (!blob) {
-		stream->gamut_remap_matrix.enable_remap = false;
-		return;
-	}
-
-	stream->gamut_remap_matrix.enable_remap = true;
-	ctm = (struct drm_color_ctm *)blob->data;
 	/*
 	 * DRM gives a 3x3 matrix, but DC wants 3x4. Assuming we're operating
 	 * with homogeneous coordinates, augment the matrix with 0's.
@@ -215,83 +175,306 @@ void amdgpu_dm_set_ctm(struct dm_crtc_state *crtc)
 	for (i = 0; i < 12; i++) {
 		/* Skip 4th element */
 		if (i % 4 == 3) {
-			stream->gamut_remap_matrix.matrix[i] = dc_fixpt_zero;
+			matrix[i] = dc_fixpt_zero;
 			continue;
 		}
 
 		/* gamut_remap_matrix[i] = ctm[i - floor(i/4)] */
-		val = ctm->matrix[i - (i/4)];
+		val = ctm->matrix[i - (i / 4)];
 		/* If negative, convert to 2's complement. */
 		if (val & (1ULL << 63))
 			val = -(val & ~(1ULL << 63));
 
-		stream->gamut_remap_matrix.matrix[i].value = val;
+		matrix[i].value = val;
 	}
 }
 
+/* Calculates the legacy transfer function - only for sRGB input space. */
+static int __set_legacy_tf(struct dc_transfer_func *func,
+			   const struct drm_color_lut *lut, uint32_t lut_size,
+			   bool has_rom)
+{
+	struct dc_gamma *gamma = NULL;
+	bool res;
 
-/**
- * amdgpu_dm_set_degamma_lut: Set degamma lut for the given CRTC.
- * @crtc: amdgpu_dm crtc state
- *
- * Update the underlying dc_stream_state's input transfer function (ITF) in
- * preparation for hardware commit. If no lut is specified by user, we default
- * to SRGB degamma.
- *
- * We support degamma bypass, predefined SRGB, and custom degamma
- *
- * RETURNS:
- * 0 on success
- * -EINVAL if crtc_state has a degamma_lut of invalid size
- * -ENOMEM if gamma allocation fails
- */
-int amdgpu_dm_set_degamma_lut(struct drm_crtc_state *crtc_state,
-			      struct dc_plane_state *dc_plane_state)
+	ASSERT(lut && lut_size == MAX_COLOR_LEGACY_LUT_ENTRIES);
+
+	gamma = dc_create_gamma();
+	if (!gamma)
+		return -ENOMEM;
+
+	gamma->type = GAMMA_RGB_256;
+	gamma->num_entries = lut_size;
+	__drm_lut_to_dc_gamma(lut, gamma, true);
+
+	res = mod_color_calculate_regamma_params(func, gamma, true, has_rom,
+						 NULL);
+
+	return res ? 0 : -ENOMEM;
+}
+
+/* Calculates the output transfer function based on expected input space. */
+static int __set_output_tf(struct dc_transfer_func *func,
+			   const struct drm_color_lut *lut, uint32_t lut_size,
+			   bool has_rom)
 {
-	struct drm_property_blob *blob = crtc_state->degamma_lut;
-	struct drm_color_lut *lut;
-	uint32_t lut_size;
-	struct dc_gamma *gamma;
-	bool ret;
-
-	if (!blob) {
-		/* Default to SRGB */
-		dc_plane_state->in_transfer_func->type = TF_TYPE_PREDEFINED;
-		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
-		return 0;
-	}
+	struct dc_gamma *gamma = NULL;
+	bool res;
 
-	lut = (struct drm_color_lut *)blob->data;
-	if (__is_lut_linear(lut, MAX_COLOR_LUT_ENTRIES)) {
-		dc_plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
-		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
-		return 0;
-	}
+	ASSERT(lut && lut_size == MAX_COLOR_LUT_ENTRIES);
 
 	gamma = dc_create_gamma();
 	if (!gamma)
 		return -ENOMEM;
 
-	lut_size = blob->length / sizeof(struct drm_color_lut);
 	gamma->num_entries = lut_size;
-	if (gamma->num_entries == MAX_COLOR_LUT_ENTRIES)
+	__drm_lut_to_dc_gamma(lut, gamma, false);
+
+	if (func->tf == TRANSFER_FUNCTION_LINEAR) {
+		/*
+		 * Color module doesn't like calculating regamma params
+		 * on top of a linear input. But degamma params can be used
+		 * instead to simulate this.
+		 */
 		gamma->type = GAMMA_CUSTOM;
-	else {
-		dc_gamma_release(&gamma);
-		return -EINVAL;
+		res = mod_color_calculate_degamma_params(func, gamma, true);
+	} else {
+		/*
+		 * Assume sRGB. The actual mapping will depend on whether the
+		 * input was legacy or not.
+		 */
+		gamma->type = GAMMA_CS_TFM_1D;
+		res = mod_color_calculate_regamma_params(func, gamma, false,
+							 has_rom, NULL);
 	}
 
+	dc_gamma_release(&gamma);
+
+	return res ? 0 : -ENOMEM;
+}
+
+/* Caculates the input transfer function based on expected input space. */
+static int __set_input_tf(struct dc_transfer_func *func,
+			  const struct drm_color_lut *lut, uint32_t lut_size)
+{
+	struct dc_gamma *gamma = NULL;
+	bool res;
+
+	gamma = dc_create_gamma();
+	if (!gamma)
+		return -ENOMEM;
+
+	gamma->type = GAMMA_CUSTOM;
+	gamma->num_entries = lut_size;
+
 	__drm_lut_to_dc_gamma(lut, gamma, false);
 
-	dc_plane_state->in_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
-	ret = mod_color_calculate_degamma_params(dc_plane_state->in_transfer_func, gamma, true);
+	res = mod_color_calculate_degamma_params(func, gamma, true);
 	dc_gamma_release(&gamma);
-	if (!ret) {
-		dc_plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
-		DRM_ERROR("Out of memory when calculating degamma params\n");
-		return -ENOMEM;
+
+	return res ? 0 : -ENOMEM;
+}
+
+/**
+ * amdgpu_dm_update_crtc_color_mgmt: Maps DRM color management to DC stream.
+ * @crtc: amdgpu_dm crtc state
+ *
+ * With no plane level color management properties we're free to use any
+ * of the HW blocks as long as the CRTC CTM always comes before the
+ * CRTC RGM and after the CRTC DGM.
+ *
+ * The CRTC RGM block will be placed in the RGM LUT block if it is non-linear.
+ * The CRTC DGM block will be placed in the DGM LUT block if it is non-linear.
+ * The CRTC CTM will be placed in the gamut remap block if it is non-linear.
+ *
+ * The RGM block is typically more fully featured and accurate across
+ * all ASICs - DCE can't support a custom non-linear CRTC DGM.
+ *
+ * For supporting both plane level color management and CRTC level color
+ * management at once we have to either restrict the usage of CRTC properties
+ * or blend adjustments together.
+ *
+ * Returns 0 on success.
+ */
+int amdgpu_dm_update_crtc_color_mgmt(struct dm_crtc_state *crtc)
+{
+	struct dc_stream_state *stream = crtc->stream;
+	struct amdgpu_device *adev =
+		(struct amdgpu_device *)crtc->base.state->dev->dev_private;
+	bool has_rom = adev->asic_type <= CHIP_RAVEN;
+	struct drm_color_ctm *ctm = NULL;
+	const struct drm_color_lut *degamma_lut, *regamma_lut;
+	uint32_t degamma_size, regamma_size;
+	bool has_regamma, has_degamma;
+	bool is_legacy;
+	int r;
+
+	degamma_lut = __extract_blob_lut(crtc->base.degamma_lut, &degamma_size);
+	if (degamma_lut && degamma_size != MAX_COLOR_LUT_ENTRIES)
+		return -EINVAL;
+
+	regamma_lut = __extract_blob_lut(crtc->base.gamma_lut, &regamma_size);
+	if (regamma_lut && regamma_size != MAX_COLOR_LUT_ENTRIES &&
+	    regamma_size != MAX_COLOR_LEGACY_LUT_ENTRIES)
+		return -EINVAL;
+
+	has_degamma =
+		degamma_lut && !__is_lut_linear(degamma_lut, degamma_size);
+
+	has_regamma =
+		regamma_lut && !__is_lut_linear(regamma_lut, regamma_size);
+
+	is_legacy = regamma_size == MAX_COLOR_LEGACY_LUT_ENTRIES;
+
+	/* Reset all adjustments. */
+	crtc->cm_has_degamma = false;
+	crtc->cm_is_degamma_srgb = false;
+
+	/* Setup regamma and degamma. */
+	if (is_legacy) {
+		/*
+		 * Legacy regamma forces us to use the sRGB RGM as a base.
+		 * This also means we can't use linear DGM since DGM needs
+		 * to use sRGB as a base as well, resulting in incorrect CRTC
+		 * DGM and CRTC CTM.
+		 *
+		 * TODO: Just map this to the standard regamma interface
+		 * instead since this isn't really right. One of the cases
+		 * where this setup currently fails is trying to do an
+		 * inverse color ramp in legacy userspace.
+		 */
+		crtc->cm_is_degamma_srgb = true;
+		stream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
+		stream->out_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
+
+		r = __set_legacy_tf(stream->out_transfer_func, regamma_lut,
+				    regamma_size, has_rom);
+		if (r)
+			return r;
+	} else if (has_regamma) {
+		/* CRTC RGM goes into RGM LUT. */
+		stream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
+		stream->out_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
+
+		r = __set_output_tf(stream->out_transfer_func, regamma_lut,
+				    regamma_size, has_rom);
+		if (r)
+			return r;
+	} else {
+		/*
+		 * No CRTC RGM means we can just put the block into bypass
+		 * since we don't have any plane level adjustments using it.
+		 */
+		stream->out_transfer_func->type = TF_TYPE_BYPASS;
+		stream->out_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
+	}
+
+	/*
+	 * CRTC DGM goes into DGM LUT. It would be nice to place it
+	 * into the RGM since it's a more featured block but we'd
+	 * have to place the CTM in the OCSC in that case.
+	 */
+	crtc->cm_has_degamma = has_degamma;
+
+	/* Setup CRTC CTM. */
+	if (crtc->base.ctm) {
+		ctm = (struct drm_color_ctm *)crtc->base.ctm->data;
+
+		/*
+		 * Gamut remapping must be used for gamma correction
+		 * since it comes before the regamma correction.
+		 *
+		 * OCSC could be used for gamma correction, but we'd need to
+		 * blend the adjustments together with the required output
+		 * conversion matrix - so just use the gamut remap block
+		 * for now.
+		 */
+		__drm_ctm_to_dc_matrix(ctm, stream->gamut_remap_matrix.matrix);
+
+		stream->gamut_remap_matrix.enable_remap = true;
+		stream->csc_color_matrix.enable_adjustment = false;
+	} else {
+		/* Bypass CTM. */
+		stream->gamut_remap_matrix.enable_remap = false;
+		stream->csc_color_matrix.enable_adjustment = false;
 	}
 
 	return 0;
 }
 
+/**
+ * amdgpu_dm_update_plane_color_mgmt: Maps DRM color management to DC plane.
+ * @crtc: amdgpu_dm crtc state
+ * @ dc_plane_state: target DC surface
+ *
+ * Update the underlying dc_stream_state's input transfer function (ITF) in
+ * preparation for hardware commit. The transfer function used depends on
+ * the prepartion done on the stream for color management.
+ *
+ * Returns 0 on success.
+ */
+int amdgpu_dm_update_plane_color_mgmt(struct dm_crtc_state *crtc,
+				      struct dc_plane_state *dc_plane_state)
+{
+	const struct drm_color_lut *degamma_lut;
+	uint32_t degamma_size;
+	int r;
+
+	if (crtc->cm_has_degamma) {
+		degamma_lut = __extract_blob_lut(crtc->base.degamma_lut,
+						 &degamma_size);
+		ASSERT(degamma_size == MAX_COLOR_LUT_ENTRIES);
+
+		dc_plane_state->in_transfer_func->type =
+			TF_TYPE_DISTRIBUTED_POINTS;
+
+		/*
+		 * This case isn't fully correct, but also fairly
+		 * uncommon. This is userspace trying to use a
+		 * legacy gamma LUT + atomic degamma LUT
+		 * at the same time.
+		 *
+		 * Legacy gamma requires the input to be in linear
+		 * space, so that means we need to apply an sRGB
+		 * degamma. But color module also doesn't support
+		 * a user ramp in this case so the degamma will
+		 * be lost.
+		 *
+		 * Even if we did support it, it's still not right:
+		 *
+		 * Input -> CRTC DGM -> sRGB DGM -> CRTC CTM ->
+		 * sRGB RGM -> CRTC RGM -> Output
+		 *
+		 * The CSC will be done in the wrong space since
+		 * we're applying an sRGB DGM on top of the CRTC
+		 * DGM.
+		 *
+		 * TODO: Don't use the legacy gamma interface and just
+		 * map these to the atomic one instead.
+		 */
+		if (crtc->cm_is_degamma_srgb)
+			dc_plane_state->in_transfer_func->tf =
+				TRANSFER_FUNCTION_SRGB;
+		else
+			dc_plane_state->in_transfer_func->tf =
+				TRANSFER_FUNCTION_LINEAR;
+
+		r = __set_input_tf(dc_plane_state->in_transfer_func,
+				   degamma_lut, degamma_size);
+		if (r)
+			return r;
+	} else if (crtc->cm_is_degamma_srgb) {
+		/*
+		 * For legacy gamma support we need the regamma input
+		 * in linear space. Assume that the input is sRGB.
+		 */
+		dc_plane_state->in_transfer_func->type = TF_TYPE_PREDEFINED;
+		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
+	} else {
+		/* ...Otherwise we can just bypass the DGM block. */
+		dc_plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
+		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
+	}
+
+	return 0;
+}

commit 476e955dd679673c81c35f383ffff8f7dbd70d97
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Feb 22 16:52:52 2019 -0500

    drm/amd/display: Hook DCN2 into amdgpu_dm and expose as config (v2)
    
    Enable DCN2 support in DM (Display Manager).
    
    v2: fix spurious raven change (Alex)
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index 7258c992a2bf..75b6a2ac910b 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -166,7 +166,7 @@ int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
 	 */
 	stream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
 	ret = mod_color_calculate_regamma_params(stream->out_transfer_func,
-			gamma, true, adev->asic_type <= CHIP_RAVEN, NULL);
+			gamma, true, adev->asic_type <= CHIP_NAVI10, NULL);
 
 	if (gamma)
 		dc_gamma_release(&gamma);

commit ecbc382c9fdf19b4e0e1ee4702923a39133b864e
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Jun 17 13:08:40 2019 -0500

    Revert "drm/amd/display: Rework CRTC color management"
    
    This reverts commit 7cd4b70091a5cfa1f58d3a529535304a116acc95.
    
    Revert this to apply the version that includes DCN2 support.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index b43bb7f90e4e..7258c992a2bf 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -27,47 +27,6 @@
 #include "amdgpu_dm.h"
 #include "dc.h"
 #include "modules/color/color_gamma.h"
-#include "basics/conversion.h"
-
-/*
- * The DC interface to HW gives us the following color management blocks
- * per pipe (surface):
- *
- * - Input gamma LUT (de-normalized)
- * - Input CSC (normalized)
- * - Surface degamma LUT (normalized)
- * - Surface CSC (normalized)
- * - Surface regamma LUT (normalized)
- * - Output CSC (normalized)
- *
- * But these aren't a direct mapping to DRM color properties. The current DRM
- * interface exposes CRTC degamma, CRTC CTM and CRTC regamma while our hardware
- * is essentially giving:
- *
- * Plane CTM -> Plane degamma -> Plane CTM -> Plane regamma -> Plane CTM
- *
- * The input gamma LUT block isn't really applicable here since it operates
- * on the actual input data itself rather than the HW fp representation. The
- * input and output CSC blocks are technically available to use as part of
- * the DC interface but are typically used internally by DC for conversions
- * between color spaces. These could be blended together with user
- * adjustments in the future but for now these should remain untouched.
- *
- * The pipe blending also happens after these blocks so we don't actually
- * support any CRTC props with correct blending with multiple planes - but we
- * can still support CRTC color management properties in DM in most single
- * plane cases correctly with clever management of the DC interface in DM.
- *
- * As per DRM documentation, blocks should be in hardware bypass when their
- * respective property is set to NULL. A linear DGM/RGM LUT should also
- * considered as putting the respective block into bypass mode.
- *
- * This means that the following
- * configuration is assumed to be the default:
- *
- * Plane DGM Bypass -> Plane CTM Bypass -> Plane RGM Bypass -> ...
- * CRTC DGM Bypass -> CRTC CTM Bypass -> CRTC RGM Bypass
- */
 
 #define MAX_DRM_LUT_VALUE 0xFFFF
 
@@ -82,13 +41,6 @@ void amdgpu_dm_init_color_mod(void)
 	setup_x_points_distribution();
 }
 
-/* Extracts the DRM lut and lut size from a blob. */
-static const struct drm_color_lut *
-__extract_blob_lut(const struct drm_property_blob *blob, uint32_t *size)
-{
-	*size = blob ? drm_color_lut_size(blob) : 0;
-	return blob ? (struct drm_color_lut *)blob->data : NULL;
-}
 
 /*
  * Return true if the given lut is a linear mapping of values, i.e. it acts
@@ -98,7 +50,7 @@ __extract_blob_lut(const struct drm_property_blob *blob, uint32_t *size)
  * f(a) = (0xFF00/MAX_COLOR_LUT_ENTRIES-1)a; for integer a in
  *                                           [0, MAX_COLOR_LUT_ENTRIES)
  */
-static bool __is_lut_linear(const struct drm_color_lut *lut, uint32_t size)
+static bool __is_lut_linear(struct drm_color_lut *lut, uint32_t size)
 {
 	int i;
 	uint32_t expected;
@@ -123,8 +75,9 @@ static bool __is_lut_linear(const struct drm_color_lut *lut, uint32_t size)
  * Convert the drm_color_lut to dc_gamma. The conversion depends on the size
  * of the lut - whether or not it's legacy.
  */
-static void __drm_lut_to_dc_gamma(const struct drm_color_lut *lut,
-				  struct dc_gamma *gamma, bool is_legacy)
+static void __drm_lut_to_dc_gamma(struct drm_color_lut *lut,
+				  struct dc_gamma *gamma,
+				  bool is_legacy)
 {
 	uint32_t r, g, b;
 	int i;
@@ -154,16 +107,103 @@ static void __drm_lut_to_dc_gamma(const struct drm_color_lut *lut,
 	}
 }
 
-/*
- * Converts a DRM CTM to a DC CSC float matrix.
- * The matrix needs to be a 3x4 (12 entry) matrix.
+/**
+ * amdgpu_dm_set_regamma_lut: Set regamma lut for the given CRTC.
+ * @crtc: amdgpu_dm crtc state
+ *
+ * Update the underlying dc_stream_state's output transfer function (OTF) in
+ * preparation for hardware commit. If no lut is specified by user, we default
+ * to SRGB.
+ *
+ * RETURNS:
+ * 0 on success, -ENOMEM if memory cannot be allocated to calculate the OTF.
  */
-static void __drm_ctm_to_dc_matrix(const struct drm_color_ctm *ctm,
-				   struct fixed31_32 *matrix)
+int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
 {
+	struct drm_property_blob *blob = crtc->base.gamma_lut;
+	struct dc_stream_state *stream = crtc->stream;
+	struct amdgpu_device *adev = (struct amdgpu_device *)
+		crtc->base.state->dev->dev_private;
+	struct drm_color_lut *lut;
+	uint32_t lut_size;
+	struct dc_gamma *gamma = NULL;
+	enum dc_transfer_func_type old_type = stream->out_transfer_func->type;
+
+	bool ret;
+
+	if (!blob && adev->asic_type <= CHIP_RAVEN) {
+		/* By default, use the SRGB predefined curve.*/
+		stream->out_transfer_func->type = TF_TYPE_PREDEFINED;
+		stream->out_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
+		return 0;
+	}
+
+	if (blob) {
+		lut = (struct drm_color_lut *)blob->data;
+		lut_size = blob->length / sizeof(struct drm_color_lut);
+
+		gamma = dc_create_gamma();
+		if (!gamma)
+			return -ENOMEM;
+
+		gamma->num_entries = lut_size;
+		if (gamma->num_entries == MAX_COLOR_LEGACY_LUT_ENTRIES)
+			gamma->type = GAMMA_RGB_256;
+		else if (gamma->num_entries == MAX_COLOR_LUT_ENTRIES)
+			gamma->type = GAMMA_CS_TFM_1D;
+		else {
+			/* Invalid lut size */
+			dc_gamma_release(&gamma);
+			return -EINVAL;
+		}
+
+		/* Convert drm_lut into dc_gamma */
+		__drm_lut_to_dc_gamma(lut, gamma, gamma->type == GAMMA_RGB_256);
+	}
+
+	/* predefined gamma ROM only exist for RAVEN and pre-RAVEN ASIC,
+	 * set canRomBeUsed accordingly
+	 */
+	stream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
+	ret = mod_color_calculate_regamma_params(stream->out_transfer_func,
+			gamma, true, adev->asic_type <= CHIP_RAVEN, NULL);
+
+	if (gamma)
+		dc_gamma_release(&gamma);
+
+	if (!ret) {
+		stream->out_transfer_func->type = old_type;
+		DRM_ERROR("Out of memory when calculating regamma params\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+/**
+ * amdgpu_dm_set_ctm: Set the color transform matrix for the given CRTC.
+ * @crtc: amdgpu_dm crtc state
+ *
+ * Update the underlying dc_stream_state's gamut remap matrix in preparation
+ * for hardware commit. If no matrix is specified by user, gamut remap will be
+ * disabled.
+ */
+void amdgpu_dm_set_ctm(struct dm_crtc_state *crtc)
+{
+
+	struct drm_property_blob *blob = crtc->base.ctm;
+	struct dc_stream_state *stream = crtc->stream;
+	struct drm_color_ctm *ctm;
 	int64_t val;
 	int i;
 
+	if (!blob) {
+		stream->gamut_remap_matrix.enable_remap = false;
+		return;
+	}
+
+	stream->gamut_remap_matrix.enable_remap = true;
+	ctm = (struct drm_color_ctm *)blob->data;
 	/*
 	 * DRM gives a 3x3 matrix, but DC wants 3x4. Assuming we're operating
 	 * with homogeneous coordinates, augment the matrix with 0's.
@@ -175,306 +215,83 @@ static void __drm_ctm_to_dc_matrix(const struct drm_color_ctm *ctm,
 	for (i = 0; i < 12; i++) {
 		/* Skip 4th element */
 		if (i % 4 == 3) {
-			matrix[i] = dc_fixpt_zero;
+			stream->gamut_remap_matrix.matrix[i] = dc_fixpt_zero;
 			continue;
 		}
 
 		/* gamut_remap_matrix[i] = ctm[i - floor(i/4)] */
-		val = ctm->matrix[i - (i / 4)];
+		val = ctm->matrix[i - (i/4)];
 		/* If negative, convert to 2's complement. */
 		if (val & (1ULL << 63))
 			val = -(val & ~(1ULL << 63));
 
-		matrix[i].value = val;
+		stream->gamut_remap_matrix.matrix[i].value = val;
 	}
 }
 
-/* Calculates the legacy transfer function - only for sRGB input space. */
-static int __set_legacy_tf(struct dc_transfer_func *func,
-			   const struct drm_color_lut *lut, uint32_t lut_size,
-			   bool has_rom)
-{
-	struct dc_gamma *gamma = NULL;
-	bool res;
-
-	ASSERT(lut && lut_size == MAX_COLOR_LEGACY_LUT_ENTRIES);
 
-	gamma = dc_create_gamma();
-	if (!gamma)
-		return -ENOMEM;
-
-	gamma->type = GAMMA_RGB_256;
-	gamma->num_entries = lut_size;
-	__drm_lut_to_dc_gamma(lut, gamma, true);
-
-	res = mod_color_calculate_regamma_params(func, gamma, true, has_rom,
-						 NULL);
-
-	return res ? 0 : -ENOMEM;
-}
-
-/* Calculates the output transfer function based on expected input space. */
-static int __set_output_tf(struct dc_transfer_func *func,
-			   const struct drm_color_lut *lut, uint32_t lut_size,
-			   bool has_rom)
+/**
+ * amdgpu_dm_set_degamma_lut: Set degamma lut for the given CRTC.
+ * @crtc: amdgpu_dm crtc state
+ *
+ * Update the underlying dc_stream_state's input transfer function (ITF) in
+ * preparation for hardware commit. If no lut is specified by user, we default
+ * to SRGB degamma.
+ *
+ * We support degamma bypass, predefined SRGB, and custom degamma
+ *
+ * RETURNS:
+ * 0 on success
+ * -EINVAL if crtc_state has a degamma_lut of invalid size
+ * -ENOMEM if gamma allocation fails
+ */
+int amdgpu_dm_set_degamma_lut(struct drm_crtc_state *crtc_state,
+			      struct dc_plane_state *dc_plane_state)
 {
-	struct dc_gamma *gamma = NULL;
-	bool res;
+	struct drm_property_blob *blob = crtc_state->degamma_lut;
+	struct drm_color_lut *lut;
+	uint32_t lut_size;
+	struct dc_gamma *gamma;
+	bool ret;
+
+	if (!blob) {
+		/* Default to SRGB */
+		dc_plane_state->in_transfer_func->type = TF_TYPE_PREDEFINED;
+		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
+		return 0;
+	}
 
-	ASSERT(lut && lut_size == MAX_COLOR_LUT_ENTRIES);
+	lut = (struct drm_color_lut *)blob->data;
+	if (__is_lut_linear(lut, MAX_COLOR_LUT_ENTRIES)) {
+		dc_plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
+		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
+		return 0;
+	}
 
 	gamma = dc_create_gamma();
 	if (!gamma)
 		return -ENOMEM;
 
+	lut_size = blob->length / sizeof(struct drm_color_lut);
 	gamma->num_entries = lut_size;
-	__drm_lut_to_dc_gamma(lut, gamma, false);
-
-	if (func->tf == TRANSFER_FUNCTION_LINEAR) {
-		/*
-		 * Color module doesn't like calculating regamma params
-		 * on top of a linear input. But degamma params can be used
-		 * instead to simulate this.
-		 */
+	if (gamma->num_entries == MAX_COLOR_LUT_ENTRIES)
 		gamma->type = GAMMA_CUSTOM;
-		res = mod_color_calculate_degamma_params(func, gamma, true);
-	} else {
-		/*
-		 * Assume sRGB. The actual mapping will depend on whether the
-		 * input was legacy or not.
-		 */
-		gamma->type = GAMMA_CS_TFM_1D;
-		res = mod_color_calculate_regamma_params(func, gamma, false,
-							 has_rom, NULL);
+	else {
+		dc_gamma_release(&gamma);
+		return -EINVAL;
 	}
 
-	dc_gamma_release(&gamma);
-
-	return res ? 0 : -ENOMEM;
-}
-
-/* Caculates the input transfer function based on expected input space. */
-static int __set_input_tf(struct dc_transfer_func *func,
-			  const struct drm_color_lut *lut, uint32_t lut_size)
-{
-	struct dc_gamma *gamma = NULL;
-	bool res;
-
-	gamma = dc_create_gamma();
-	if (!gamma)
-		return -ENOMEM;
-
-	gamma->type = GAMMA_CUSTOM;
-	gamma->num_entries = lut_size;
-
 	__drm_lut_to_dc_gamma(lut, gamma, false);
 
-	res = mod_color_calculate_degamma_params(func, gamma, true);
+	dc_plane_state->in_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
+	ret = mod_color_calculate_degamma_params(dc_plane_state->in_transfer_func, gamma, true);
 	dc_gamma_release(&gamma);
-
-	return res ? 0 : -ENOMEM;
-}
-
-/**
- * amdgpu_dm_update_crtc_color_mgmt: Maps DRM color management to DC stream.
- * @crtc: amdgpu_dm crtc state
- *
- * With no plane level color management properties we're free to use any
- * of the HW blocks as long as the CRTC CTM always comes before the
- * CRTC RGM and after the CRTC DGM.
- *
- * The CRTC RGM block will be placed in the RGM LUT block if it is non-linear.
- * The CRTC DGM block will be placed in the DGM LUT block if it is non-linear.
- * The CRTC CTM will be placed in the gamut remap block if it is non-linear.
- *
- * The RGM block is typically more fully featured and accurate across
- * all ASICs - DCE can't support a custom non-linear CRTC DGM.
- *
- * For supporting both plane level color management and CRTC level color
- * management at once we have to either restrict the usage of CRTC properties
- * or blend adjustments together.
- *
- * Returns 0 on success.
- */
-int amdgpu_dm_update_crtc_color_mgmt(struct dm_crtc_state *crtc)
-{
-	struct dc_stream_state *stream = crtc->stream;
-	struct amdgpu_device *adev =
-		(struct amdgpu_device *)crtc->base.state->dev->dev_private;
-	bool has_rom = adev->asic_type <= CHIP_RAVEN;
-	struct drm_color_ctm *ctm = NULL;
-	const struct drm_color_lut *degamma_lut, *regamma_lut;
-	uint32_t degamma_size, regamma_size;
-	bool has_regamma, has_degamma;
-	bool is_legacy;
-	int r;
-
-	degamma_lut = __extract_blob_lut(crtc->base.degamma_lut, &degamma_size);
-	if (degamma_lut && degamma_size != MAX_COLOR_LUT_ENTRIES)
-		return -EINVAL;
-
-	regamma_lut = __extract_blob_lut(crtc->base.gamma_lut, &regamma_size);
-	if (regamma_lut && regamma_size != MAX_COLOR_LUT_ENTRIES &&
-	    regamma_size != MAX_COLOR_LEGACY_LUT_ENTRIES)
-		return -EINVAL;
-
-	has_degamma =
-		degamma_lut && !__is_lut_linear(degamma_lut, degamma_size);
-
-	has_regamma =
-		regamma_lut && !__is_lut_linear(regamma_lut, regamma_size);
-
-	is_legacy = regamma_size == MAX_COLOR_LEGACY_LUT_ENTRIES;
-
-	/* Reset all adjustments. */
-	crtc->cm_has_degamma = false;
-	crtc->cm_is_degamma_srgb = false;
-
-	/* Setup regamma and degamma. */
-	if (is_legacy) {
-		/*
-		 * Legacy regamma forces us to use the sRGB RGM as a base.
-		 * This also means we can't use linear DGM since DGM needs
-		 * to use sRGB as a base as well, resulting in incorrect CRTC
-		 * DGM and CRTC CTM.
-		 *
-		 * TODO: Just map this to the standard regamma interface
-		 * instead since this isn't really right. One of the cases
-		 * where this setup currently fails is trying to do an
-		 * inverse color ramp in legacy userspace.
-		 */
-		crtc->cm_is_degamma_srgb = true;
-		stream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
-		stream->out_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
-
-		r = __set_legacy_tf(stream->out_transfer_func, regamma_lut,
-				    regamma_size, has_rom);
-		if (r)
-			return r;
-	} else if (has_regamma) {
-		/* CRTC RGM goes into RGM LUT. */
-		stream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
-		stream->out_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
-
-		r = __set_output_tf(stream->out_transfer_func, regamma_lut,
-				    regamma_size, has_rom);
-		if (r)
-			return r;
-	} else {
-		/*
-		 * No CRTC RGM means we can just put the block into bypass
-		 * since we don't have any plane level adjustments using it.
-		 */
-		stream->out_transfer_func->type = TF_TYPE_BYPASS;
-		stream->out_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
-	}
-
-	/*
-	 * CRTC DGM goes into DGM LUT. It would be nice to place it
-	 * into the RGM since it's a more featured block but we'd
-	 * have to place the CTM in the OCSC in that case.
-	 */
-	crtc->cm_has_degamma = has_degamma;
-
-	/* Setup CRTC CTM. */
-	if (crtc->base.ctm) {
-		ctm = (struct drm_color_ctm *)crtc->base.ctm->data;
-
-		/*
-		 * Gamut remapping must be used for gamma correction
-		 * since it comes before the regamma correction.
-		 *
-		 * OCSC could be used for gamma correction, but we'd need to
-		 * blend the adjustments together with the required output
-		 * conversion matrix - so just use the gamut remap block
-		 * for now.
-		 */
-		__drm_ctm_to_dc_matrix(ctm, stream->gamut_remap_matrix.matrix);
-
-		stream->gamut_remap_matrix.enable_remap = true;
-		stream->csc_color_matrix.enable_adjustment = false;
-	} else {
-		/* Bypass CTM. */
-		stream->gamut_remap_matrix.enable_remap = false;
-		stream->csc_color_matrix.enable_adjustment = false;
-	}
-
-	return 0;
-}
-
-/**
- * amdgpu_dm_update_plane_color_mgmt: Maps DRM color management to DC plane.
- * @crtc: amdgpu_dm crtc state
- * @ dc_plane_state: target DC surface
- *
- * Update the underlying dc_stream_state's input transfer function (ITF) in
- * preparation for hardware commit. The transfer function used depends on
- * the prepartion done on the stream for color management.
- *
- * Returns 0 on success.
- */
-int amdgpu_dm_update_plane_color_mgmt(struct dm_crtc_state *crtc,
-				      struct dc_plane_state *dc_plane_state)
-{
-	const struct drm_color_lut *degamma_lut;
-	uint32_t degamma_size;
-	int r;
-
-	if (crtc->cm_has_degamma) {
-		degamma_lut = __extract_blob_lut(crtc->base.degamma_lut,
-						 &degamma_size);
-		ASSERT(degamma_size == MAX_COLOR_LUT_ENTRIES);
-
-		dc_plane_state->in_transfer_func->type =
-			TF_TYPE_DISTRIBUTED_POINTS;
-
-		/*
-		 * This case isn't fully correct, but also fairly
-		 * uncommon. This is userspace trying to use a
-		 * legacy gamma LUT + atomic degamma LUT
-		 * at the same time.
-		 *
-		 * Legacy gamma requires the input to be in linear
-		 * space, so that means we need to apply an sRGB
-		 * degamma. But color module also doesn't support
-		 * a user ramp in this case so the degamma will
-		 * be lost.
-		 *
-		 * Even if we did support it, it's still not right:
-		 *
-		 * Input -> CRTC DGM -> sRGB DGM -> CRTC CTM ->
-		 * sRGB RGM -> CRTC RGM -> Output
-		 *
-		 * The CSC will be done in the wrong space since
-		 * we're applying an sRGB DGM on top of the CRTC
-		 * DGM.
-		 *
-		 * TODO: Don't use the legacy gamma interface and just
-		 * map these to the atomic one instead.
-		 */
-		if (crtc->cm_is_degamma_srgb)
-			dc_plane_state->in_transfer_func->tf =
-				TRANSFER_FUNCTION_SRGB;
-		else
-			dc_plane_state->in_transfer_func->tf =
-				TRANSFER_FUNCTION_LINEAR;
-
-		r = __set_input_tf(dc_plane_state->in_transfer_func,
-				   degamma_lut, degamma_size);
-		if (r)
-			return r;
-	} else if (crtc->cm_is_degamma_srgb) {
-		/*
-		 * For legacy gamma support we need the regamma input
-		 * in linear space. Assume that the input is sRGB.
-		 */
-		dc_plane_state->in_transfer_func->type = TF_TYPE_PREDEFINED;
-		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
-	} else {
-		/* ...Otherwise we can just bypass the DGM block. */
+	if (!ret) {
 		dc_plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
-		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
+		DRM_ERROR("Out of memory when calculating degamma params\n");
+		return -ENOMEM;
 	}
 
 	return 0;
 }
+

commit 7cd4b70091a5cfa1f58d3a529535304a116acc95
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Thu May 9 12:14:58 2019 -0400

    drm/amd/display: Rework CRTC color management
    
    [Why]
    To prepare for the upcoming DRM plane color management properties
    we need to correct a lot of wrong behavior and assumptions made for
    CRTC color management.
    
    The documentation added by this commit in amdgpu_dm_color explains
    how the HW color pipeline works and its limitations with the DRM
    interface.
    
    The current implementation does the following wrong:
    - Implicit sRGB DGM when no CRTC DGM is set
    - Implicit sRGB RGM when no CRTC RGM is set
    - No way to specify a non-linear DGM matrix that produces correct output
    - No way to specify a correct RGM when a linear DGM is used
    
    We had workarounds for passing kms_color tests but not all of the
    behavior we had wrong was covered by these tests (especially when
    it comes to non-linear DGM). Testing both DGM and RGM at the same time
    isn't something kms_color tests well either.
    
    [How]
    The specifics for how color management works in AMDGPU and the new
    behavior can be found by reading the documentation added to
    amdgpu_dm_color.c from this patch.
    
    All of the incorrect cases from the old implementation have been
    addressed for the atomic interface, but there still a few TODOs for
    the legacy one.
    
    Note: this does cause regressions for kms_color@pipe-a-ctm-* over HDMI.
    
    The result looks correct from visual inspection but the CRC no longer
    matches. For reference, the test was previously doing the following:
    
    linear degamma -> CTM -> sRGB regamma -> RGB to YUV (709) -> ...
    
    Now the test is doing:
    
    linear degamma -> CTM -> linear regamma -> RGB to YUV (709) -> ...
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Sun peng Li <Sunpeng.Li@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index 7258c992a2bf..b43bb7f90e4e 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -27,6 +27,47 @@
 #include "amdgpu_dm.h"
 #include "dc.h"
 #include "modules/color/color_gamma.h"
+#include "basics/conversion.h"
+
+/*
+ * The DC interface to HW gives us the following color management blocks
+ * per pipe (surface):
+ *
+ * - Input gamma LUT (de-normalized)
+ * - Input CSC (normalized)
+ * - Surface degamma LUT (normalized)
+ * - Surface CSC (normalized)
+ * - Surface regamma LUT (normalized)
+ * - Output CSC (normalized)
+ *
+ * But these aren't a direct mapping to DRM color properties. The current DRM
+ * interface exposes CRTC degamma, CRTC CTM and CRTC regamma while our hardware
+ * is essentially giving:
+ *
+ * Plane CTM -> Plane degamma -> Plane CTM -> Plane regamma -> Plane CTM
+ *
+ * The input gamma LUT block isn't really applicable here since it operates
+ * on the actual input data itself rather than the HW fp representation. The
+ * input and output CSC blocks are technically available to use as part of
+ * the DC interface but are typically used internally by DC for conversions
+ * between color spaces. These could be blended together with user
+ * adjustments in the future but for now these should remain untouched.
+ *
+ * The pipe blending also happens after these blocks so we don't actually
+ * support any CRTC props with correct blending with multiple planes - but we
+ * can still support CRTC color management properties in DM in most single
+ * plane cases correctly with clever management of the DC interface in DM.
+ *
+ * As per DRM documentation, blocks should be in hardware bypass when their
+ * respective property is set to NULL. A linear DGM/RGM LUT should also
+ * considered as putting the respective block into bypass mode.
+ *
+ * This means that the following
+ * configuration is assumed to be the default:
+ *
+ * Plane DGM Bypass -> Plane CTM Bypass -> Plane RGM Bypass -> ...
+ * CRTC DGM Bypass -> CRTC CTM Bypass -> CRTC RGM Bypass
+ */
 
 #define MAX_DRM_LUT_VALUE 0xFFFF
 
@@ -41,6 +82,13 @@ void amdgpu_dm_init_color_mod(void)
 	setup_x_points_distribution();
 }
 
+/* Extracts the DRM lut and lut size from a blob. */
+static const struct drm_color_lut *
+__extract_blob_lut(const struct drm_property_blob *blob, uint32_t *size)
+{
+	*size = blob ? drm_color_lut_size(blob) : 0;
+	return blob ? (struct drm_color_lut *)blob->data : NULL;
+}
 
 /*
  * Return true if the given lut is a linear mapping of values, i.e. it acts
@@ -50,7 +98,7 @@ void amdgpu_dm_init_color_mod(void)
  * f(a) = (0xFF00/MAX_COLOR_LUT_ENTRIES-1)a; for integer a in
  *                                           [0, MAX_COLOR_LUT_ENTRIES)
  */
-static bool __is_lut_linear(struct drm_color_lut *lut, uint32_t size)
+static bool __is_lut_linear(const struct drm_color_lut *lut, uint32_t size)
 {
 	int i;
 	uint32_t expected;
@@ -75,9 +123,8 @@ static bool __is_lut_linear(struct drm_color_lut *lut, uint32_t size)
  * Convert the drm_color_lut to dc_gamma. The conversion depends on the size
  * of the lut - whether or not it's legacy.
  */
-static void __drm_lut_to_dc_gamma(struct drm_color_lut *lut,
-				  struct dc_gamma *gamma,
-				  bool is_legacy)
+static void __drm_lut_to_dc_gamma(const struct drm_color_lut *lut,
+				  struct dc_gamma *gamma, bool is_legacy)
 {
 	uint32_t r, g, b;
 	int i;
@@ -107,103 +154,16 @@ static void __drm_lut_to_dc_gamma(struct drm_color_lut *lut,
 	}
 }
 
-/**
- * amdgpu_dm_set_regamma_lut: Set regamma lut for the given CRTC.
- * @crtc: amdgpu_dm crtc state
- *
- * Update the underlying dc_stream_state's output transfer function (OTF) in
- * preparation for hardware commit. If no lut is specified by user, we default
- * to SRGB.
- *
- * RETURNS:
- * 0 on success, -ENOMEM if memory cannot be allocated to calculate the OTF.
- */
-int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
-{
-	struct drm_property_blob *blob = crtc->base.gamma_lut;
-	struct dc_stream_state *stream = crtc->stream;
-	struct amdgpu_device *adev = (struct amdgpu_device *)
-		crtc->base.state->dev->dev_private;
-	struct drm_color_lut *lut;
-	uint32_t lut_size;
-	struct dc_gamma *gamma = NULL;
-	enum dc_transfer_func_type old_type = stream->out_transfer_func->type;
-
-	bool ret;
-
-	if (!blob && adev->asic_type <= CHIP_RAVEN) {
-		/* By default, use the SRGB predefined curve.*/
-		stream->out_transfer_func->type = TF_TYPE_PREDEFINED;
-		stream->out_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
-		return 0;
-	}
-
-	if (blob) {
-		lut = (struct drm_color_lut *)blob->data;
-		lut_size = blob->length / sizeof(struct drm_color_lut);
-
-		gamma = dc_create_gamma();
-		if (!gamma)
-			return -ENOMEM;
-
-		gamma->num_entries = lut_size;
-		if (gamma->num_entries == MAX_COLOR_LEGACY_LUT_ENTRIES)
-			gamma->type = GAMMA_RGB_256;
-		else if (gamma->num_entries == MAX_COLOR_LUT_ENTRIES)
-			gamma->type = GAMMA_CS_TFM_1D;
-		else {
-			/* Invalid lut size */
-			dc_gamma_release(&gamma);
-			return -EINVAL;
-		}
-
-		/* Convert drm_lut into dc_gamma */
-		__drm_lut_to_dc_gamma(lut, gamma, gamma->type == GAMMA_RGB_256);
-	}
-
-	/* predefined gamma ROM only exist for RAVEN and pre-RAVEN ASIC,
-	 * set canRomBeUsed accordingly
-	 */
-	stream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
-	ret = mod_color_calculate_regamma_params(stream->out_transfer_func,
-			gamma, true, adev->asic_type <= CHIP_RAVEN, NULL);
-
-	if (gamma)
-		dc_gamma_release(&gamma);
-
-	if (!ret) {
-		stream->out_transfer_func->type = old_type;
-		DRM_ERROR("Out of memory when calculating regamma params\n");
-		return -ENOMEM;
-	}
-
-	return 0;
-}
-
-/**
- * amdgpu_dm_set_ctm: Set the color transform matrix for the given CRTC.
- * @crtc: amdgpu_dm crtc state
- *
- * Update the underlying dc_stream_state's gamut remap matrix in preparation
- * for hardware commit. If no matrix is specified by user, gamut remap will be
- * disabled.
+/*
+ * Converts a DRM CTM to a DC CSC float matrix.
+ * The matrix needs to be a 3x4 (12 entry) matrix.
  */
-void amdgpu_dm_set_ctm(struct dm_crtc_state *crtc)
+static void __drm_ctm_to_dc_matrix(const struct drm_color_ctm *ctm,
+				   struct fixed31_32 *matrix)
 {
-
-	struct drm_property_blob *blob = crtc->base.ctm;
-	struct dc_stream_state *stream = crtc->stream;
-	struct drm_color_ctm *ctm;
 	int64_t val;
 	int i;
 
-	if (!blob) {
-		stream->gamut_remap_matrix.enable_remap = false;
-		return;
-	}
-
-	stream->gamut_remap_matrix.enable_remap = true;
-	ctm = (struct drm_color_ctm *)blob->data;
 	/*
 	 * DRM gives a 3x3 matrix, but DC wants 3x4. Assuming we're operating
 	 * with homogeneous coordinates, augment the matrix with 0's.
@@ -215,83 +175,306 @@ void amdgpu_dm_set_ctm(struct dm_crtc_state *crtc)
 	for (i = 0; i < 12; i++) {
 		/* Skip 4th element */
 		if (i % 4 == 3) {
-			stream->gamut_remap_matrix.matrix[i] = dc_fixpt_zero;
+			matrix[i] = dc_fixpt_zero;
 			continue;
 		}
 
 		/* gamut_remap_matrix[i] = ctm[i - floor(i/4)] */
-		val = ctm->matrix[i - (i/4)];
+		val = ctm->matrix[i - (i / 4)];
 		/* If negative, convert to 2's complement. */
 		if (val & (1ULL << 63))
 			val = -(val & ~(1ULL << 63));
 
-		stream->gamut_remap_matrix.matrix[i].value = val;
+		matrix[i].value = val;
 	}
 }
 
+/* Calculates the legacy transfer function - only for sRGB input space. */
+static int __set_legacy_tf(struct dc_transfer_func *func,
+			   const struct drm_color_lut *lut, uint32_t lut_size,
+			   bool has_rom)
+{
+	struct dc_gamma *gamma = NULL;
+	bool res;
 
-/**
- * amdgpu_dm_set_degamma_lut: Set degamma lut for the given CRTC.
- * @crtc: amdgpu_dm crtc state
- *
- * Update the underlying dc_stream_state's input transfer function (ITF) in
- * preparation for hardware commit. If no lut is specified by user, we default
- * to SRGB degamma.
- *
- * We support degamma bypass, predefined SRGB, and custom degamma
- *
- * RETURNS:
- * 0 on success
- * -EINVAL if crtc_state has a degamma_lut of invalid size
- * -ENOMEM if gamma allocation fails
- */
-int amdgpu_dm_set_degamma_lut(struct drm_crtc_state *crtc_state,
-			      struct dc_plane_state *dc_plane_state)
+	ASSERT(lut && lut_size == MAX_COLOR_LEGACY_LUT_ENTRIES);
+
+	gamma = dc_create_gamma();
+	if (!gamma)
+		return -ENOMEM;
+
+	gamma->type = GAMMA_RGB_256;
+	gamma->num_entries = lut_size;
+	__drm_lut_to_dc_gamma(lut, gamma, true);
+
+	res = mod_color_calculate_regamma_params(func, gamma, true, has_rom,
+						 NULL);
+
+	return res ? 0 : -ENOMEM;
+}
+
+/* Calculates the output transfer function based on expected input space. */
+static int __set_output_tf(struct dc_transfer_func *func,
+			   const struct drm_color_lut *lut, uint32_t lut_size,
+			   bool has_rom)
 {
-	struct drm_property_blob *blob = crtc_state->degamma_lut;
-	struct drm_color_lut *lut;
-	uint32_t lut_size;
-	struct dc_gamma *gamma;
-	bool ret;
-
-	if (!blob) {
-		/* Default to SRGB */
-		dc_plane_state->in_transfer_func->type = TF_TYPE_PREDEFINED;
-		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
-		return 0;
-	}
+	struct dc_gamma *gamma = NULL;
+	bool res;
 
-	lut = (struct drm_color_lut *)blob->data;
-	if (__is_lut_linear(lut, MAX_COLOR_LUT_ENTRIES)) {
-		dc_plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
-		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
-		return 0;
-	}
+	ASSERT(lut && lut_size == MAX_COLOR_LUT_ENTRIES);
 
 	gamma = dc_create_gamma();
 	if (!gamma)
 		return -ENOMEM;
 
-	lut_size = blob->length / sizeof(struct drm_color_lut);
 	gamma->num_entries = lut_size;
-	if (gamma->num_entries == MAX_COLOR_LUT_ENTRIES)
+	__drm_lut_to_dc_gamma(lut, gamma, false);
+
+	if (func->tf == TRANSFER_FUNCTION_LINEAR) {
+		/*
+		 * Color module doesn't like calculating regamma params
+		 * on top of a linear input. But degamma params can be used
+		 * instead to simulate this.
+		 */
 		gamma->type = GAMMA_CUSTOM;
-	else {
-		dc_gamma_release(&gamma);
-		return -EINVAL;
+		res = mod_color_calculate_degamma_params(func, gamma, true);
+	} else {
+		/*
+		 * Assume sRGB. The actual mapping will depend on whether the
+		 * input was legacy or not.
+		 */
+		gamma->type = GAMMA_CS_TFM_1D;
+		res = mod_color_calculate_regamma_params(func, gamma, false,
+							 has_rom, NULL);
 	}
 
+	dc_gamma_release(&gamma);
+
+	return res ? 0 : -ENOMEM;
+}
+
+/* Caculates the input transfer function based on expected input space. */
+static int __set_input_tf(struct dc_transfer_func *func,
+			  const struct drm_color_lut *lut, uint32_t lut_size)
+{
+	struct dc_gamma *gamma = NULL;
+	bool res;
+
+	gamma = dc_create_gamma();
+	if (!gamma)
+		return -ENOMEM;
+
+	gamma->type = GAMMA_CUSTOM;
+	gamma->num_entries = lut_size;
+
 	__drm_lut_to_dc_gamma(lut, gamma, false);
 
-	dc_plane_state->in_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
-	ret = mod_color_calculate_degamma_params(dc_plane_state->in_transfer_func, gamma, true);
+	res = mod_color_calculate_degamma_params(func, gamma, true);
 	dc_gamma_release(&gamma);
-	if (!ret) {
-		dc_plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
-		DRM_ERROR("Out of memory when calculating degamma params\n");
-		return -ENOMEM;
+
+	return res ? 0 : -ENOMEM;
+}
+
+/**
+ * amdgpu_dm_update_crtc_color_mgmt: Maps DRM color management to DC stream.
+ * @crtc: amdgpu_dm crtc state
+ *
+ * With no plane level color management properties we're free to use any
+ * of the HW blocks as long as the CRTC CTM always comes before the
+ * CRTC RGM and after the CRTC DGM.
+ *
+ * The CRTC RGM block will be placed in the RGM LUT block if it is non-linear.
+ * The CRTC DGM block will be placed in the DGM LUT block if it is non-linear.
+ * The CRTC CTM will be placed in the gamut remap block if it is non-linear.
+ *
+ * The RGM block is typically more fully featured and accurate across
+ * all ASICs - DCE can't support a custom non-linear CRTC DGM.
+ *
+ * For supporting both plane level color management and CRTC level color
+ * management at once we have to either restrict the usage of CRTC properties
+ * or blend adjustments together.
+ *
+ * Returns 0 on success.
+ */
+int amdgpu_dm_update_crtc_color_mgmt(struct dm_crtc_state *crtc)
+{
+	struct dc_stream_state *stream = crtc->stream;
+	struct amdgpu_device *adev =
+		(struct amdgpu_device *)crtc->base.state->dev->dev_private;
+	bool has_rom = adev->asic_type <= CHIP_RAVEN;
+	struct drm_color_ctm *ctm = NULL;
+	const struct drm_color_lut *degamma_lut, *regamma_lut;
+	uint32_t degamma_size, regamma_size;
+	bool has_regamma, has_degamma;
+	bool is_legacy;
+	int r;
+
+	degamma_lut = __extract_blob_lut(crtc->base.degamma_lut, &degamma_size);
+	if (degamma_lut && degamma_size != MAX_COLOR_LUT_ENTRIES)
+		return -EINVAL;
+
+	regamma_lut = __extract_blob_lut(crtc->base.gamma_lut, &regamma_size);
+	if (regamma_lut && regamma_size != MAX_COLOR_LUT_ENTRIES &&
+	    regamma_size != MAX_COLOR_LEGACY_LUT_ENTRIES)
+		return -EINVAL;
+
+	has_degamma =
+		degamma_lut && !__is_lut_linear(degamma_lut, degamma_size);
+
+	has_regamma =
+		regamma_lut && !__is_lut_linear(regamma_lut, regamma_size);
+
+	is_legacy = regamma_size == MAX_COLOR_LEGACY_LUT_ENTRIES;
+
+	/* Reset all adjustments. */
+	crtc->cm_has_degamma = false;
+	crtc->cm_is_degamma_srgb = false;
+
+	/* Setup regamma and degamma. */
+	if (is_legacy) {
+		/*
+		 * Legacy regamma forces us to use the sRGB RGM as a base.
+		 * This also means we can't use linear DGM since DGM needs
+		 * to use sRGB as a base as well, resulting in incorrect CRTC
+		 * DGM and CRTC CTM.
+		 *
+		 * TODO: Just map this to the standard regamma interface
+		 * instead since this isn't really right. One of the cases
+		 * where this setup currently fails is trying to do an
+		 * inverse color ramp in legacy userspace.
+		 */
+		crtc->cm_is_degamma_srgb = true;
+		stream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
+		stream->out_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
+
+		r = __set_legacy_tf(stream->out_transfer_func, regamma_lut,
+				    regamma_size, has_rom);
+		if (r)
+			return r;
+	} else if (has_regamma) {
+		/* CRTC RGM goes into RGM LUT. */
+		stream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
+		stream->out_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
+
+		r = __set_output_tf(stream->out_transfer_func, regamma_lut,
+				    regamma_size, has_rom);
+		if (r)
+			return r;
+	} else {
+		/*
+		 * No CRTC RGM means we can just put the block into bypass
+		 * since we don't have any plane level adjustments using it.
+		 */
+		stream->out_transfer_func->type = TF_TYPE_BYPASS;
+		stream->out_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
+	}
+
+	/*
+	 * CRTC DGM goes into DGM LUT. It would be nice to place it
+	 * into the RGM since it's a more featured block but we'd
+	 * have to place the CTM in the OCSC in that case.
+	 */
+	crtc->cm_has_degamma = has_degamma;
+
+	/* Setup CRTC CTM. */
+	if (crtc->base.ctm) {
+		ctm = (struct drm_color_ctm *)crtc->base.ctm->data;
+
+		/*
+		 * Gamut remapping must be used for gamma correction
+		 * since it comes before the regamma correction.
+		 *
+		 * OCSC could be used for gamma correction, but we'd need to
+		 * blend the adjustments together with the required output
+		 * conversion matrix - so just use the gamut remap block
+		 * for now.
+		 */
+		__drm_ctm_to_dc_matrix(ctm, stream->gamut_remap_matrix.matrix);
+
+		stream->gamut_remap_matrix.enable_remap = true;
+		stream->csc_color_matrix.enable_adjustment = false;
+	} else {
+		/* Bypass CTM. */
+		stream->gamut_remap_matrix.enable_remap = false;
+		stream->csc_color_matrix.enable_adjustment = false;
 	}
 
 	return 0;
 }
 
+/**
+ * amdgpu_dm_update_plane_color_mgmt: Maps DRM color management to DC plane.
+ * @crtc: amdgpu_dm crtc state
+ * @ dc_plane_state: target DC surface
+ *
+ * Update the underlying dc_stream_state's input transfer function (ITF) in
+ * preparation for hardware commit. The transfer function used depends on
+ * the prepartion done on the stream for color management.
+ *
+ * Returns 0 on success.
+ */
+int amdgpu_dm_update_plane_color_mgmt(struct dm_crtc_state *crtc,
+				      struct dc_plane_state *dc_plane_state)
+{
+	const struct drm_color_lut *degamma_lut;
+	uint32_t degamma_size;
+	int r;
+
+	if (crtc->cm_has_degamma) {
+		degamma_lut = __extract_blob_lut(crtc->base.degamma_lut,
+						 &degamma_size);
+		ASSERT(degamma_size == MAX_COLOR_LUT_ENTRIES);
+
+		dc_plane_state->in_transfer_func->type =
+			TF_TYPE_DISTRIBUTED_POINTS;
+
+		/*
+		 * This case isn't fully correct, but also fairly
+		 * uncommon. This is userspace trying to use a
+		 * legacy gamma LUT + atomic degamma LUT
+		 * at the same time.
+		 *
+		 * Legacy gamma requires the input to be in linear
+		 * space, so that means we need to apply an sRGB
+		 * degamma. But color module also doesn't support
+		 * a user ramp in this case so the degamma will
+		 * be lost.
+		 *
+		 * Even if we did support it, it's still not right:
+		 *
+		 * Input -> CRTC DGM -> sRGB DGM -> CRTC CTM ->
+		 * sRGB RGM -> CRTC RGM -> Output
+		 *
+		 * The CSC will be done in the wrong space since
+		 * we're applying an sRGB DGM on top of the CRTC
+		 * DGM.
+		 *
+		 * TODO: Don't use the legacy gamma interface and just
+		 * map these to the atomic one instead.
+		 */
+		if (crtc->cm_is_degamma_srgb)
+			dc_plane_state->in_transfer_func->tf =
+				TRANSFER_FUNCTION_SRGB;
+		else
+			dc_plane_state->in_transfer_func->tf =
+				TRANSFER_FUNCTION_LINEAR;
+
+		r = __set_input_tf(dc_plane_state->in_transfer_func,
+				   degamma_lut, degamma_size);
+		if (r)
+			return r;
+	} else if (crtc->cm_is_degamma_srgb) {
+		/*
+		 * For legacy gamma support we need the regamma input
+		 * in linear space. Assume that the input is sRGB.
+		 */
+		dc_plane_state->in_transfer_func->type = TF_TYPE_PREDEFINED;
+		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
+	} else {
+		/* ...Otherwise we can just bypass the DGM block. */
+		dc_plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
+		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
+	}
+
+	return 0;
+}

commit 3ae42acde349e0f983945da5901282de9352d929
Author: hersen wu <hersenxs.wu@amd.com>
Date:   Fri Mar 1 11:54:02 2019 -0500

    drm/amd/display: program default output gamma
    
    program default output gamma if no user specific gamma
    parameters passed.
    
    Signed-off-by: hersen wu <hersenxs.wu@amd.com>
    Reviewed-by: Sun peng Li <Sunpeng.Li@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index 216e48cec716..7258c992a2bf 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -126,46 +126,51 @@ int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
 		crtc->base.state->dev->dev_private;
 	struct drm_color_lut *lut;
 	uint32_t lut_size;
-	struct dc_gamma *gamma;
+	struct dc_gamma *gamma = NULL;
 	enum dc_transfer_func_type old_type = stream->out_transfer_func->type;
 
 	bool ret;
 
-	if (!blob) {
+	if (!blob && adev->asic_type <= CHIP_RAVEN) {
 		/* By default, use the SRGB predefined curve.*/
 		stream->out_transfer_func->type = TF_TYPE_PREDEFINED;
 		stream->out_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
 		return 0;
 	}
 
-	lut = (struct drm_color_lut *)blob->data;
-	lut_size = blob->length / sizeof(struct drm_color_lut);
-
-	gamma = dc_create_gamma();
-	if (!gamma)
-		return -ENOMEM;
+	if (blob) {
+		lut = (struct drm_color_lut *)blob->data;
+		lut_size = blob->length / sizeof(struct drm_color_lut);
+
+		gamma = dc_create_gamma();
+		if (!gamma)
+			return -ENOMEM;
+
+		gamma->num_entries = lut_size;
+		if (gamma->num_entries == MAX_COLOR_LEGACY_LUT_ENTRIES)
+			gamma->type = GAMMA_RGB_256;
+		else if (gamma->num_entries == MAX_COLOR_LUT_ENTRIES)
+			gamma->type = GAMMA_CS_TFM_1D;
+		else {
+			/* Invalid lut size */
+			dc_gamma_release(&gamma);
+			return -EINVAL;
+		}
 
-	gamma->num_entries = lut_size;
-	if (gamma->num_entries == MAX_COLOR_LEGACY_LUT_ENTRIES)
-		gamma->type = GAMMA_RGB_256;
-	else if (gamma->num_entries == MAX_COLOR_LUT_ENTRIES)
-		gamma->type = GAMMA_CS_TFM_1D;
-	else {
-		/* Invalid lut size */
-		dc_gamma_release(&gamma);
-		return -EINVAL;
+		/* Convert drm_lut into dc_gamma */
+		__drm_lut_to_dc_gamma(lut, gamma, gamma->type == GAMMA_RGB_256);
 	}
 
-	/* Convert drm_lut into dc_gamma */
-	__drm_lut_to_dc_gamma(lut, gamma, gamma->type == GAMMA_RGB_256);
-
-	/* Call color module to translate into something DC understands. Namely
-	 * a transfer function.
+	/* predefined gamma ROM only exist for RAVEN and pre-RAVEN ASIC,
+	 * set canRomBeUsed accordingly
 	 */
 	stream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
 	ret = mod_color_calculate_regamma_params(stream->out_transfer_func,
-						 gamma, true, adev->asic_type <= CHIP_RAVEN, NULL);
-	dc_gamma_release(&gamma);
+			gamma, true, adev->asic_type <= CHIP_RAVEN, NULL);
+
+	if (gamma)
+		dc_gamma_release(&gamma);
+
 	if (!ret) {
 		stream->out_transfer_func->type = old_type;
 		DRM_ERROR("Out of memory when calculating regamma params\n");

commit e1e8a020c6b88931d541ccd44043285ab93324d3
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Tue Sep 11 17:48:07 2018 -0400

    drm/amd/display: Add support for Freesync 2 HDR and Content to Display Mapping
    
    [Why]
    Freesync 2 HDR and support for HDR content
    outside the range of the HDR display
    require implementation on Dal 3 to better match
    Dal2.
    
    [How]
    Add support for Freesync HDR and mapping
    of source content to display ranges for better
    representation of HDR content.
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index be19e6861189..216e48cec716 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -164,7 +164,7 @@ int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
 	 */
 	stream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
 	ret = mod_color_calculate_regamma_params(stream->out_transfer_func,
-						 gamma, true, adev->asic_type <= CHIP_RAVEN);
+						 gamma, true, adev->asic_type <= CHIP_RAVEN, NULL);
 	dc_gamma_release(&gamma);
 	if (!ret) {
 		stream->out_transfer_func->type = old_type;

commit dc6c981d202733fd5718d4db627f7d85fee651eb
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Wed Jul 18 15:10:10 2018 -0500

    drm/amd/display: Use DGAM ROM or RAM
    
    [Why]
    Optimize gamma programming
    
    [How]
    Use ROM for optimization when it is possible.
    Use RAM only when it is necessary.
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index 326f6fb7e0bc..be19e6861189 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -22,7 +22,7 @@
  * Authors: AMD
  *
  */
-
+#include "amdgpu.h"
 #include "amdgpu_mode.h"
 #include "amdgpu_dm.h"
 #include "dc.h"
@@ -122,6 +122,8 @@ int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
 {
 	struct drm_property_blob *blob = crtc->base.gamma_lut;
 	struct dc_stream_state *stream = crtc->stream;
+	struct amdgpu_device *adev = (struct amdgpu_device *)
+		crtc->base.state->dev->dev_private;
 	struct drm_color_lut *lut;
 	uint32_t lut_size;
 	struct dc_gamma *gamma;
@@ -162,7 +164,7 @@ int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
 	 */
 	stream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
 	ret = mod_color_calculate_regamma_params(stream->out_transfer_func,
-						 gamma, true);
+						 gamma, true, adev->asic_type <= CHIP_RAVEN);
 	dc_gamma_release(&gamma);
 	if (!ret) {
 		stream->out_transfer_func->type = old_type;

commit 78e4405cec6cb0780b27b222685dde33934b38e4
Author: David Francis <David.Francis@amd.com>
Date:   Thu Jul 12 15:46:41 2018 -0400

    drm/amd/display: Implement custom degamma lut on dcn
    
    [Why]
    Custom degamma lut functions are a feature we would
    like to support on compatible hardware
    
    [How]
    In atomic check, convert from array of drm_color_lut to
    dc_transfer_func.  On hardware commit, allow for possibility
    of custom degamma.  Both are based on the equivalent
    regamma pipeline.
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index b329393307e5..326f6fb7e0bc 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -231,18 +231,21 @@ void amdgpu_dm_set_ctm(struct dm_crtc_state *crtc)
  * preparation for hardware commit. If no lut is specified by user, we default
  * to SRGB degamma.
  *
- * Currently, we only support degamma bypass, or preprogrammed SRGB degamma.
- * Programmable degamma is not supported, and an attempt to do so will return
- * -EINVAL.
+ * We support degamma bypass, predefined SRGB, and custom degamma
  *
  * RETURNS:
- * 0 on success, -EINVAL if custom degamma curve is given.
+ * 0 on success
+ * -EINVAL if crtc_state has a degamma_lut of invalid size
+ * -ENOMEM if gamma allocation fails
  */
 int amdgpu_dm_set_degamma_lut(struct drm_crtc_state *crtc_state,
 			      struct dc_plane_state *dc_plane_state)
 {
 	struct drm_property_blob *blob = crtc_state->degamma_lut;
 	struct drm_color_lut *lut;
+	uint32_t lut_size;
+	struct dc_gamma *gamma;
+	bool ret;
 
 	if (!blob) {
 		/* Default to SRGB */
@@ -258,11 +261,30 @@ int amdgpu_dm_set_degamma_lut(struct drm_crtc_state *crtc_state,
 		return 0;
 	}
 
-	/* Otherwise, assume SRGB, since programmable degamma is not
-	 * supported.
-	 */
-	dc_plane_state->in_transfer_func->type = TF_TYPE_PREDEFINED;
-	dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
-	return -EINVAL;
+	gamma = dc_create_gamma();
+	if (!gamma)
+		return -ENOMEM;
+
+	lut_size = blob->length / sizeof(struct drm_color_lut);
+	gamma->num_entries = lut_size;
+	if (gamma->num_entries == MAX_COLOR_LUT_ENTRIES)
+		gamma->type = GAMMA_CUSTOM;
+	else {
+		dc_gamma_release(&gamma);
+		return -EINVAL;
+	}
+
+	__drm_lut_to_dc_gamma(lut, gamma, false);
+
+	dc_plane_state->in_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
+	ret = mod_color_calculate_degamma_params(dc_plane_state->in_transfer_func, gamma, true);
+	dc_gamma_release(&gamma);
+	if (!ret) {
+		dc_plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
+		DRM_ERROR("Out of memory when calculating degamma params\n");
+		return -ENOMEM;
+	}
+
+	return 0;
 }
 

commit eb0e515464e4a1be730c7ac7a01c3ba04c98ea97
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Apr 18 11:37:53 2018 -0400

    drm/amd/display: get rid of 32.32 unsigned fixed point
    
    32.32 is redundant, 31.32 does everything we use 32.32 for
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index e3d90e918d1b..b329393307e5 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -88,9 +88,9 @@ static void __drm_lut_to_dc_gamma(struct drm_color_lut *lut,
 			g = drm_color_lut_extract(lut[i].green, 16);
 			b = drm_color_lut_extract(lut[i].blue, 16);
 
-			gamma->entries.red[i] = dal_fixed31_32_from_int(r);
-			gamma->entries.green[i] = dal_fixed31_32_from_int(g);
-			gamma->entries.blue[i] = dal_fixed31_32_from_int(b);
+			gamma->entries.red[i] = dc_fixpt_from_int(r);
+			gamma->entries.green[i] = dc_fixpt_from_int(g);
+			gamma->entries.blue[i] = dc_fixpt_from_int(b);
 		}
 		return;
 	}
@@ -101,9 +101,9 @@ static void __drm_lut_to_dc_gamma(struct drm_color_lut *lut,
 		g = drm_color_lut_extract(lut[i].green, 16);
 		b = drm_color_lut_extract(lut[i].blue, 16);
 
-		gamma->entries.red[i] = dal_fixed31_32_from_fraction(r, MAX_DRM_LUT_VALUE);
-		gamma->entries.green[i] = dal_fixed31_32_from_fraction(g, MAX_DRM_LUT_VALUE);
-		gamma->entries.blue[i] = dal_fixed31_32_from_fraction(b, MAX_DRM_LUT_VALUE);
+		gamma->entries.red[i] = dc_fixpt_from_fraction(r, MAX_DRM_LUT_VALUE);
+		gamma->entries.green[i] = dc_fixpt_from_fraction(g, MAX_DRM_LUT_VALUE);
+		gamma->entries.blue[i] = dc_fixpt_from_fraction(b, MAX_DRM_LUT_VALUE);
 	}
 }
 
@@ -208,7 +208,7 @@ void amdgpu_dm_set_ctm(struct dm_crtc_state *crtc)
 	for (i = 0; i < 12; i++) {
 		/* Skip 4th element */
 		if (i % 4 == 3) {
-			stream->gamut_remap_matrix.matrix[i] = dal_fixed31_32_zero;
+			stream->gamut_remap_matrix.matrix[i] = dc_fixpt_zero;
 			continue;
 		}
 

commit c2f84e03a01ad09f18f9f132f8b1e78f699a5494
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Apr 12 16:37:09 2018 -0400

    drm/amd/display: Don't program bypass on linear regamma LUT
    
    Even though this is required for degamma since DCE HW only supports a
    couple predefined LUTs we can just program the LUT directly for regamma.
    
    This fixes dark screens which occurs when we program regamma to bypass
    while degamma is using srgb LUT.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Leo Li <sunpeng.li@amd.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index ef5fad8c5aac..e3d90e918d1b 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -139,13 +139,6 @@ int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
 	lut = (struct drm_color_lut *)blob->data;
 	lut_size = blob->length / sizeof(struct drm_color_lut);
 
-	if (__is_lut_linear(lut, lut_size)) {
-		/* Set to bypass if lut is set to linear */
-		stream->out_transfer_func->type = TF_TYPE_BYPASS;
-		stream->out_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
-		return 0;
-	}
-
 	gamma = dc_create_gamma();
 	if (!gamma)
 		return -ENOMEM;

commit c99c7d6ef9f610145308577ae5845cd6e14051e2
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Fri Mar 30 13:05:44 2018 +0800

    drm/amd/display: Disentangle dc.h include from amdgpu.h
    
    Use forward declaration in amdgpu_dm.h for struct dc instand
    of include dc.h to make header files more standalone
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index f6cb502c303f..ef5fad8c5aac 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -25,6 +25,7 @@
 
 #include "amdgpu_mode.h"
 #include "amdgpu_dm.h"
+#include "dc.h"
 #include "modules/color/color_gamma.h"
 
 #define MAX_DRM_LUT_VALUE 0xFFFF

commit 5e3e341cee51a755b81a660806bfcad3fdcfc906
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Fri Feb 23 12:59:03 2018 -0500

    drm/amd/display: Convert CTM to 2's complement
    
    DRM's documentation for the color transform matrix does not specify
    whether the values are in signed-magnitude, or 2's complement.
    Therefore, it was assumed to use 2's complement.
    
    However, existing usermode implementations use signed-magnitude.
    Therefore, conform to existing standards, and convert to 2's complement
    internally.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index e845c511656e..f6cb502c303f 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -193,6 +193,7 @@ void amdgpu_dm_set_ctm(struct dm_crtc_state *crtc)
 	struct drm_property_blob *blob = crtc->base.ctm;
 	struct dc_stream_state *stream = crtc->stream;
 	struct drm_color_ctm *ctm;
+	int64_t val;
 	int i;
 
 	if (!blob) {
@@ -206,7 +207,9 @@ void amdgpu_dm_set_ctm(struct dm_crtc_state *crtc)
 	 * DRM gives a 3x3 matrix, but DC wants 3x4. Assuming we're operating
 	 * with homogeneous coordinates, augment the matrix with 0's.
 	 *
-	 * The format provided is S31.32, which is the same as our fixed31_32.
+	 * The format provided is S31.32, using signed-magnitude representation.
+	 * Our fixed31_32 is also S31.32, but is using 2's complement. We have
+	 * to convert from signed-magnitude to 2's complement.
 	 */
 	for (i = 0; i < 12; i++) {
 		/* Skip 4th element */
@@ -214,8 +217,14 @@ void amdgpu_dm_set_ctm(struct dm_crtc_state *crtc)
 			stream->gamut_remap_matrix.matrix[i] = dal_fixed31_32_zero;
 			continue;
 		}
-		/* csc[i] = ctm[i - floor(i/4)] */
-		stream->gamut_remap_matrix.matrix[i].value = ctm->matrix[i - (i/4)];
+
+		/* gamut_remap_matrix[i] = ctm[i - floor(i/4)] */
+		val = ctm->matrix[i - (i/4)];
+		/* If negative, convert to 2's complement. */
+		if (val & (1ULL << 63))
+			val = -(val & ~(1ULL << 63));
+
+		stream->gamut_remap_matrix.matrix[i].value = val;
 	}
 }
 

commit 086247a4b2fba49800b27807f22bb894cd8363fb
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Mon Feb 12 13:20:56 2018 -0500

    drm/amd/display: Use 4096 lut entries
    
    Points in the DRM LUT are spaced linearly. Points in hardware are spaced
    exponentially, with greater density towards 0. To maintain low-end
    accuracy in hardware when sampling the DRM LUT, more points are needed.
    
    However, X doesn't seem to play with legacy LUTs of such size.
    Therefore, check for legacy lut when updating DC states, and update
    accordingly.
    
    v2: Use a macro for the maximum drm LUT value.
    
    v3: Update commit to reflect that this does not map 1-1 to HW
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index 62bb72fe9aa5..e845c511656e 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -27,6 +27,8 @@
 #include "amdgpu_dm.h"
 #include "modules/color/color_gamma.h"
 
+#define MAX_DRM_LUT_VALUE 0xFFFF
+
 /*
  * Initialize the color module.
  *
@@ -47,19 +49,18 @@ void amdgpu_dm_init_color_mod(void)
  * f(a) = (0xFF00/MAX_COLOR_LUT_ENTRIES-1)a; for integer a in
  *                                           [0, MAX_COLOR_LUT_ENTRIES)
  */
-static bool __is_lut_linear(struct drm_color_lut *lut)
+static bool __is_lut_linear(struct drm_color_lut *lut, uint32_t size)
 {
 	int i;
-	uint32_t max_os = 0xFF00;
 	uint32_t expected;
 	int delta;
 
-	for (i = 0; i < MAX_COLOR_LUT_ENTRIES; i++) {
+	for (i = 0; i < size; i++) {
 		/* All color values should equal */
 		if ((lut[i].red != lut[i].green) || (lut[i].green != lut[i].blue))
 			return false;
 
-		expected = i * max_os / (MAX_COLOR_LUT_ENTRIES-1);
+		expected = i * MAX_DRM_LUT_VALUE / (size-1);
 
 		/* Allow a +/-1 error. */
 		delta = lut[i].red - expected;
@@ -69,6 +70,42 @@ static bool __is_lut_linear(struct drm_color_lut *lut)
 	return true;
 }
 
+/**
+ * Convert the drm_color_lut to dc_gamma. The conversion depends on the size
+ * of the lut - whether or not it's legacy.
+ */
+static void __drm_lut_to_dc_gamma(struct drm_color_lut *lut,
+				  struct dc_gamma *gamma,
+				  bool is_legacy)
+{
+	uint32_t r, g, b;
+	int i;
+
+	if (is_legacy) {
+		for (i = 0; i < MAX_COLOR_LEGACY_LUT_ENTRIES; i++) {
+			r = drm_color_lut_extract(lut[i].red, 16);
+			g = drm_color_lut_extract(lut[i].green, 16);
+			b = drm_color_lut_extract(lut[i].blue, 16);
+
+			gamma->entries.red[i] = dal_fixed31_32_from_int(r);
+			gamma->entries.green[i] = dal_fixed31_32_from_int(g);
+			gamma->entries.blue[i] = dal_fixed31_32_from_int(b);
+		}
+		return;
+	}
+
+	/* else */
+	for (i = 0; i < MAX_COLOR_LUT_ENTRIES; i++) {
+		r = drm_color_lut_extract(lut[i].red, 16);
+		g = drm_color_lut_extract(lut[i].green, 16);
+		b = drm_color_lut_extract(lut[i].blue, 16);
+
+		gamma->entries.red[i] = dal_fixed31_32_from_fraction(r, MAX_DRM_LUT_VALUE);
+		gamma->entries.green[i] = dal_fixed31_32_from_fraction(g, MAX_DRM_LUT_VALUE);
+		gamma->entries.blue[i] = dal_fixed31_32_from_fraction(b, MAX_DRM_LUT_VALUE);
+	}
+}
+
 /**
  * amdgpu_dm_set_regamma_lut: Set regamma lut for the given CRTC.
  * @crtc: amdgpu_dm crtc state
@@ -85,11 +122,10 @@ int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
 	struct drm_property_blob *blob = crtc->base.gamma_lut;
 	struct dc_stream_state *stream = crtc->stream;
 	struct drm_color_lut *lut;
+	uint32_t lut_size;
 	struct dc_gamma *gamma;
 	enum dc_transfer_func_type old_type = stream->out_transfer_func->type;
 
-	uint32_t r, g, b;
-	int i;
 	bool ret;
 
 	if (!blob) {
@@ -100,8 +136,9 @@ int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
 	}
 
 	lut = (struct drm_color_lut *)blob->data;
+	lut_size = blob->length / sizeof(struct drm_color_lut);
 
-	if (__is_lut_linear(lut)) {
+	if (__is_lut_linear(lut, lut_size)) {
 		/* Set to bypass if lut is set to linear */
 		stream->out_transfer_func->type = TF_TYPE_BYPASS;
 		stream->out_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
@@ -112,20 +149,20 @@ int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
 	if (!gamma)
 		return -ENOMEM;
 
-	gamma->num_entries = MAX_COLOR_LUT_ENTRIES;
-	gamma->type = GAMMA_RGB_256;
-
-	/* Truncate, and store in dc_gamma for output tf calculation */
-	for (i = 0; i < gamma->num_entries; i++) {
-		r = drm_color_lut_extract(lut[i].red, 16);
-		g = drm_color_lut_extract(lut[i].green, 16);
-		b = drm_color_lut_extract(lut[i].blue, 16);
-
-		gamma->entries.red[i] = dal_fixed31_32_from_int(r);
-		gamma->entries.green[i] = dal_fixed31_32_from_int(g);
-		gamma->entries.blue[i] = dal_fixed31_32_from_int(b);
+	gamma->num_entries = lut_size;
+	if (gamma->num_entries == MAX_COLOR_LEGACY_LUT_ENTRIES)
+		gamma->type = GAMMA_RGB_256;
+	else if (gamma->num_entries == MAX_COLOR_LUT_ENTRIES)
+		gamma->type = GAMMA_CS_TFM_1D;
+	else {
+		/* Invalid lut size */
+		dc_gamma_release(&gamma);
+		return -EINVAL;
 	}
 
+	/* Convert drm_lut into dc_gamma */
+	__drm_lut_to_dc_gamma(lut, gamma, gamma->type == GAMMA_RGB_256);
+
 	/* Call color module to translate into something DC understands. Namely
 	 * a transfer function.
 	 */
@@ -212,7 +249,7 @@ int amdgpu_dm_set_degamma_lut(struct drm_crtc_state *crtc_state,
 	}
 
 	lut = (struct drm_color_lut *)blob->data;
-	if (__is_lut_linear(lut)) {
+	if (__is_lut_linear(lut, MAX_COLOR_LUT_ENTRIES)) {
 		dc_plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
 		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
 		return 0;

commit 236d0e4f6f1eaac500261660e35ededcfbd66eeb
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Jan 30 11:14:27 2018 -0500

    drm/amd/display: Refactor max color lut entries into a macro.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index d7bc1b7dd152..62bb72fe9aa5 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -39,14 +39,13 @@ void amdgpu_dm_init_color_mod(void)
 }
 
 
-#define MAX_LUT_ENTRIES 256
-
 /*
  * Return true if the given lut is a linear mapping of values, i.e. it acts
  * like a bypass LUT.
  *
  * It is considered linear if the lut represents:
- * f(a) = (0xFF00/MAX_LUT_ENTRIES-1)a; for integer a in [0, MAX_LUT_ENTRIES)
+ * f(a) = (0xFF00/MAX_COLOR_LUT_ENTRIES-1)a; for integer a in
+ *                                           [0, MAX_COLOR_LUT_ENTRIES)
  */
 static bool __is_lut_linear(struct drm_color_lut *lut)
 {
@@ -55,12 +54,12 @@ static bool __is_lut_linear(struct drm_color_lut *lut)
 	uint32_t expected;
 	int delta;
 
-	for (i = 0; i < MAX_LUT_ENTRIES; i++) {
+	for (i = 0; i < MAX_COLOR_LUT_ENTRIES; i++) {
 		/* All color values should equal */
 		if ((lut[i].red != lut[i].green) || (lut[i].green != lut[i].blue))
 			return false;
 
-		expected = i * max_os / (MAX_LUT_ENTRIES-1);
+		expected = i * max_os / (MAX_COLOR_LUT_ENTRIES-1);
 
 		/* Allow a +/-1 error. */
 		delta = lut[i].red - expected;
@@ -113,7 +112,7 @@ int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
 	if (!gamma)
 		return -ENOMEM;
 
-	gamma->num_entries = MAX_LUT_ENTRIES;
+	gamma->num_entries = MAX_COLOR_LUT_ENTRIES;
 	gamma->type = GAMMA_RGB_256;
 
 	/* Truncate, and store in dc_gamma for output tf calculation */

commit e277adc5a06cfc95ad3e1a6b80bcd97ab4b01ea6
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Fri Feb 2 10:18:56 2018 -0500

    drm/amd/display: Hookup color management functions
    
    Hookup new color management functions into amdgpu_dm:
    
    - Notify DRM that we support CRTC color management during CRTC init
    - Call color management functions within atomic check to update dc
      states in preparation for a commit
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index cc3ee0748a70..d7bc1b7dd152 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -27,6 +27,17 @@
 #include "amdgpu_dm.h"
 #include "modules/color/color_gamma.h"
 
+/*
+ * Initialize the color module.
+ *
+ * We're not using the full color module, only certain components.
+ * Only call setup functions for components that we need.
+ */
+void amdgpu_dm_init_color_mod(void)
+{
+	setup_x_points_distribution();
+}
+
 
 #define MAX_LUT_ENTRIES 256
 

commit 303afd2dbf1b556bf9c5d3220c167c925b06a2c7
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Fri Feb 2 10:18:05 2018 -0500

    drm/amd/display: Implement color management
    
    Implement color management functionalities within amdgpu_dm_color, and
    expose functions within amdgpu_dm.h.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
new file mode 100644
index 000000000000..cc3ee0748a70
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -0,0 +1,218 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "amdgpu_mode.h"
+#include "amdgpu_dm.h"
+#include "modules/color/color_gamma.h"
+
+
+#define MAX_LUT_ENTRIES 256
+
+/*
+ * Return true if the given lut is a linear mapping of values, i.e. it acts
+ * like a bypass LUT.
+ *
+ * It is considered linear if the lut represents:
+ * f(a) = (0xFF00/MAX_LUT_ENTRIES-1)a; for integer a in [0, MAX_LUT_ENTRIES)
+ */
+static bool __is_lut_linear(struct drm_color_lut *lut)
+{
+	int i;
+	uint32_t max_os = 0xFF00;
+	uint32_t expected;
+	int delta;
+
+	for (i = 0; i < MAX_LUT_ENTRIES; i++) {
+		/* All color values should equal */
+		if ((lut[i].red != lut[i].green) || (lut[i].green != lut[i].blue))
+			return false;
+
+		expected = i * max_os / (MAX_LUT_ENTRIES-1);
+
+		/* Allow a +/-1 error. */
+		delta = lut[i].red - expected;
+		if (delta < -1 || 1 < delta)
+			return false;
+	}
+	return true;
+}
+
+/**
+ * amdgpu_dm_set_regamma_lut: Set regamma lut for the given CRTC.
+ * @crtc: amdgpu_dm crtc state
+ *
+ * Update the underlying dc_stream_state's output transfer function (OTF) in
+ * preparation for hardware commit. If no lut is specified by user, we default
+ * to SRGB.
+ *
+ * RETURNS:
+ * 0 on success, -ENOMEM if memory cannot be allocated to calculate the OTF.
+ */
+int amdgpu_dm_set_regamma_lut(struct dm_crtc_state *crtc)
+{
+	struct drm_property_blob *blob = crtc->base.gamma_lut;
+	struct dc_stream_state *stream = crtc->stream;
+	struct drm_color_lut *lut;
+	struct dc_gamma *gamma;
+	enum dc_transfer_func_type old_type = stream->out_transfer_func->type;
+
+	uint32_t r, g, b;
+	int i;
+	bool ret;
+
+	if (!blob) {
+		/* By default, use the SRGB predefined curve.*/
+		stream->out_transfer_func->type = TF_TYPE_PREDEFINED;
+		stream->out_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
+		return 0;
+	}
+
+	lut = (struct drm_color_lut *)blob->data;
+
+	if (__is_lut_linear(lut)) {
+		/* Set to bypass if lut is set to linear */
+		stream->out_transfer_func->type = TF_TYPE_BYPASS;
+		stream->out_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
+		return 0;
+	}
+
+	gamma = dc_create_gamma();
+	if (!gamma)
+		return -ENOMEM;
+
+	gamma->num_entries = MAX_LUT_ENTRIES;
+	gamma->type = GAMMA_RGB_256;
+
+	/* Truncate, and store in dc_gamma for output tf calculation */
+	for (i = 0; i < gamma->num_entries; i++) {
+		r = drm_color_lut_extract(lut[i].red, 16);
+		g = drm_color_lut_extract(lut[i].green, 16);
+		b = drm_color_lut_extract(lut[i].blue, 16);
+
+		gamma->entries.red[i] = dal_fixed31_32_from_int(r);
+		gamma->entries.green[i] = dal_fixed31_32_from_int(g);
+		gamma->entries.blue[i] = dal_fixed31_32_from_int(b);
+	}
+
+	/* Call color module to translate into something DC understands. Namely
+	 * a transfer function.
+	 */
+	stream->out_transfer_func->type = TF_TYPE_DISTRIBUTED_POINTS;
+	ret = mod_color_calculate_regamma_params(stream->out_transfer_func,
+						 gamma, true);
+	dc_gamma_release(&gamma);
+	if (!ret) {
+		stream->out_transfer_func->type = old_type;
+		DRM_ERROR("Out of memory when calculating regamma params\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+/**
+ * amdgpu_dm_set_ctm: Set the color transform matrix for the given CRTC.
+ * @crtc: amdgpu_dm crtc state
+ *
+ * Update the underlying dc_stream_state's gamut remap matrix in preparation
+ * for hardware commit. If no matrix is specified by user, gamut remap will be
+ * disabled.
+ */
+void amdgpu_dm_set_ctm(struct dm_crtc_state *crtc)
+{
+
+	struct drm_property_blob *blob = crtc->base.ctm;
+	struct dc_stream_state *stream = crtc->stream;
+	struct drm_color_ctm *ctm;
+	int i;
+
+	if (!blob) {
+		stream->gamut_remap_matrix.enable_remap = false;
+		return;
+	}
+
+	stream->gamut_remap_matrix.enable_remap = true;
+	ctm = (struct drm_color_ctm *)blob->data;
+	/*
+	 * DRM gives a 3x3 matrix, but DC wants 3x4. Assuming we're operating
+	 * with homogeneous coordinates, augment the matrix with 0's.
+	 *
+	 * The format provided is S31.32, which is the same as our fixed31_32.
+	 */
+	for (i = 0; i < 12; i++) {
+		/* Skip 4th element */
+		if (i % 4 == 3) {
+			stream->gamut_remap_matrix.matrix[i] = dal_fixed31_32_zero;
+			continue;
+		}
+		/* csc[i] = ctm[i - floor(i/4)] */
+		stream->gamut_remap_matrix.matrix[i].value = ctm->matrix[i - (i/4)];
+	}
+}
+
+
+/**
+ * amdgpu_dm_set_degamma_lut: Set degamma lut for the given CRTC.
+ * @crtc: amdgpu_dm crtc state
+ *
+ * Update the underlying dc_stream_state's input transfer function (ITF) in
+ * preparation for hardware commit. If no lut is specified by user, we default
+ * to SRGB degamma.
+ *
+ * Currently, we only support degamma bypass, or preprogrammed SRGB degamma.
+ * Programmable degamma is not supported, and an attempt to do so will return
+ * -EINVAL.
+ *
+ * RETURNS:
+ * 0 on success, -EINVAL if custom degamma curve is given.
+ */
+int amdgpu_dm_set_degamma_lut(struct drm_crtc_state *crtc_state,
+			      struct dc_plane_state *dc_plane_state)
+{
+	struct drm_property_blob *blob = crtc_state->degamma_lut;
+	struct drm_color_lut *lut;
+
+	if (!blob) {
+		/* Default to SRGB */
+		dc_plane_state->in_transfer_func->type = TF_TYPE_PREDEFINED;
+		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
+		return 0;
+	}
+
+	lut = (struct drm_color_lut *)blob->data;
+	if (__is_lut_linear(lut)) {
+		dc_plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
+		dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_LINEAR;
+		return 0;
+	}
+
+	/* Otherwise, assume SRGB, since programmable degamma is not
+	 * supported.
+	 */
+	dc_plane_state->in_transfer_func->type = TF_TYPE_PREDEFINED;
+	dc_plane_state->in_transfer_func->tf = TRANSFER_FUNCTION_SRGB;
+	return -EINVAL;
+}
+
