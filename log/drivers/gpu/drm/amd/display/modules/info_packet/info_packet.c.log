commit cdca3f218d9bbe086b0df9bc95b4f0c0d1011415
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Apr 21 22:01:58 2020 -0400

    drm/amd/display: move location of dmub_srv.h file
    
    [Why]
    Make a separation of what belongs in the differen dmub
    headers
    
    dmub_srv.h is for exposing dmub srv interface to rest of
    driver.
    
    other headers inside dmub/inc exposes cmds and definitions
    that are owned by the firmware
    
    [How]
    keep firmware owned definitions in dmub/inc
    
    move stuff that is purely driver interface headers to dmub/
    since those are interface calls that are defined for rest of
    driver to use
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
index 20c30daa374c..7cd8a43d1889 100644
--- a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
+++ b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
@@ -29,7 +29,6 @@
 #include "mod_shared.h"
 #include "mod_freesync.h"
 #include "dc.h"
-#include "dmub/inc/dmub_cmd_dal.h"
 
 enum vsc_packet_revision {
 	vsc_packet_undefined = 0,

commit 1cfbbddead0abd8551ad2da5630cefea0a4289a6
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Apr 21 22:01:30 2020 -0400

    drm/amd/display: add addition dc type to translate to dmub fw type
    
    [Why]
    For a type like PSR version, it makes sense for most of the code
    to include a dc type, instead of having this a fw type define since
    this is a capability and type exposed by dc.
    
    Especially if it doesn't even need to communicate with the fw.
    
    The code that is packing the firmware command message
    should be the one who needs to translate the psr version
    into a command that the firmware understands.
    
    [How]
    Add a dc_psr_version enum.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
index 22a5484d9f28..20c30daa374c 100644
--- a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
+++ b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
@@ -145,7 +145,7 @@ void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 	}
 
 	/*VSC packet set to 2 when DP revision >= 1.2*/
-	if (stream->link->psr_settings.psr_version != PSR_VERSION_UNSUPPORTED)
+	if (stream->link->psr_settings.psr_version != DC_PSR_VERSION_UNSUPPORTED)
 		vsc_packet_revision = vsc_packet_rev2;
 
 	/* Update to revision 5 for extended colorimetry support */

commit d1ebfdd8d0fc30ff65b85a4bf3fa9e5e35006466
Author: Wyatt Wood <wyatt.wood@amd.com>
Date:   Tue Mar 31 09:31:16 2020 -0400

    drm/amd/display: Unify psr feature flags
    
    [Why]
    As it stands, psr has feature flags in dm, stream, and link. Most are
    not defined well enough, and different dm layers have different uses for
    these same flags.
    
    [How]
    We define a new structure called psr_settings in dc_link that will hold
    the following psr feature flags:
    
    psr_feature_enable - psr is supported
    psr_allow_active - psr is currently active
    psr_version - internal psr version supported
    psr_frame_capture_indication_req
    psr_sdp_transmit_line_num_deadline
    The last two flags were moved out of the power module
    for the purposes of consolidating psr flags.
    Their use is already well-defined.
    
    Psr caps reported by sink will also be stored in dc_link,
    in dpcd_caps.psr_caps.
    
    Signed-off-by: Wyatt Wood <wyatt.wood@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
index cff3ab15fc0c..22a5484d9f28 100644
--- a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
+++ b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
@@ -29,6 +29,7 @@
 #include "mod_shared.h"
 #include "mod_freesync.h"
 #include "dc.h"
+#include "dmub/inc/dmub_cmd_dal.h"
 
 enum vsc_packet_revision {
 	vsc_packet_undefined = 0,
@@ -144,7 +145,7 @@ void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 	}
 
 	/*VSC packet set to 2 when DP revision >= 1.2*/
-	if (stream->psr_version != 0)
+	if (stream->link->psr_settings.psr_version != PSR_VERSION_UNSUPPORTED)
 		vsc_packet_revision = vsc_packet_rev2;
 
 	/* Update to revision 5 for extended colorimetry support */

commit c38cc6770fd5f78a0918ed0b01af14de31aba5cb
Author: Martin Tsai <martin.tsai@amd.com>
Date:   Tue Mar 3 10:04:08 2020 +0800

    drm/amd/display: differentiate vsc sdp colorimetry use criteria between MST and SST
    
    [Why]
    We should check MST BU support capability on output port before building
    vsc info packet.
    
    [How]
    Add a new definition for port and sink capability check.
    
    Signed-off-by: Martin Tsai <martin.tsai@amd.com>
    Reviewed-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
index 6a8a056424b8..cff3ab15fc0c 100644
--- a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
+++ b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
@@ -130,8 +130,7 @@ enum ColorimetryYCCDP {
 };
 
 void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
-		struct dc_info_packet *info_packet,
-		bool *use_vsc_sdp_for_colorimetry)
+		struct dc_info_packet *info_packet)
 {
 	unsigned int vsc_packet_revision = vsc_packet_undefined;
 	unsigned int i;
@@ -139,11 +138,6 @@ void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 	unsigned int colorimetryFormat = 0;
 	bool stereo3dSupport = false;
 
-	/* Initialize first, later if infopacket is valid determine if VSC SDP
-	 * should be used to signal colorimetry format and pixel encoding.
-	 */
-	*use_vsc_sdp_for_colorimetry = false;
-
 	if (stream->timing.timing_3d_format != TIMING_3D_FORMAT_NONE && stream->view_format != VIEW_3D_FORMAT_NONE) {
 		vsc_packet_revision = vsc_packet_rev1;
 		stereo3dSupport = true;
@@ -153,9 +147,8 @@ void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 	if (stream->psr_version != 0)
 		vsc_packet_revision = vsc_packet_rev2;
 
-	/* Update to revision 5 for extended colorimetry support for DPCD 1.4+ */
-	if (stream->link->dpcd_caps.dpcd_rev.raw >= 0x14 &&
-			stream->link->dpcd_caps.dprx_feature.bits.VSC_SDP_COLORIMETRY_SUPPORTED)
+	/* Update to revision 5 for extended colorimetry support */
+	if (stream->use_vsc_sdp_for_colorimetry)
 		vsc_packet_revision = vsc_packet_rev5;
 
 	/* VSC packet not needed based on the features
@@ -269,13 +262,6 @@ void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 
 		info_packet->valid = true;
 
-		/* If we are using VSC SDP revision 05h, use this to signal for
-		 * colorimetry format and pixel encoding. HW should later be
-		 * programmed to set MSA MISC1 bit 6 to indicate ignore
-		 * colorimetry format and pixel encoding in the MSA.
-		 */
-		*use_vsc_sdp_for_colorimetry = true;
-
 		/* Set VSC SDP fields for pixel encoding and colorimetry format from DP 1.3 specs
 		 * Data Bytes DB 18~16
 		 * Bits 3:0 (Colorimetry Format)        |  Bits 7:4 (Pixel Encoding)

commit 5ed78cd69a1bf64e6bdb70a05c1c9bde87b209ad
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Wed Oct 16 23:44:55 2019 -0400

    drm/amd/display: set MSA MISC1 bit 6 while sending colorimetry in VSC SDP
    
    [Why]
    It is confusing to sinks if we send VSC SDP only on some format. Today we
    signal colorimetry format using MSA while in formats like sRGB.
    But when we switch to BT2020 we set the bit to ignore MSA  colorimetry and
    instead use the colorimetry information in the VSC SDP.
    
    But if sink supports signaling of colorimetry via VSC SDP we should always
    set the MSA MISC1 bit 6, instead of doing so selectively.
    
    [How]
    If sink supports signaling of colorimetry via VSC SDP, and we are sending
    the colorimetry info via VSC SDP with packet revision 05h, then always
    set MSA MISC1 bit 6.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
index db6b08f6d093..6a8a056424b8 100644
--- a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
+++ b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
@@ -30,6 +30,20 @@
 #include "mod_freesync.h"
 #include "dc.h"
 
+enum vsc_packet_revision {
+	vsc_packet_undefined = 0,
+	//01h = VSC SDP supports only 3D stereo.
+	vsc_packet_rev1 = 1,
+	//02h = 3D stereo + PSR.
+	vsc_packet_rev2 = 2,
+	//03h = 3D stereo + PSR2.
+	vsc_packet_rev3 = 3,
+	//04h = 3D stereo + PSR/PSR2 + Y-coordinate.
+	vsc_packet_rev4 = 4,
+	//05h = 3D stereo + PSR/PSR2 + Y-coordinate + Pixel Encoding/Colorimetry Format
+	vsc_packet_rev5 = 5,
+};
+
 #define HDMI_INFOFRAME_TYPE_VENDOR 0x81
 #define HF_VSIF_VERSION 1
 
@@ -116,35 +130,41 @@ enum ColorimetryYCCDP {
 };
 
 void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
-		struct dc_info_packet *info_packet)
+		struct dc_info_packet *info_packet,
+		bool *use_vsc_sdp_for_colorimetry)
 {
-	unsigned int vscPacketRevision = 0;
+	unsigned int vsc_packet_revision = vsc_packet_undefined;
 	unsigned int i;
 	unsigned int pixelEncoding = 0;
 	unsigned int colorimetryFormat = 0;
 	bool stereo3dSupport = false;
 
+	/* Initialize first, later if infopacket is valid determine if VSC SDP
+	 * should be used to signal colorimetry format and pixel encoding.
+	 */
+	*use_vsc_sdp_for_colorimetry = false;
+
 	if (stream->timing.timing_3d_format != TIMING_3D_FORMAT_NONE && stream->view_format != VIEW_3D_FORMAT_NONE) {
-		vscPacketRevision = 1;
+		vsc_packet_revision = vsc_packet_rev1;
 		stereo3dSupport = true;
 	}
 
 	/*VSC packet set to 2 when DP revision >= 1.2*/
 	if (stream->psr_version != 0)
-		vscPacketRevision = 2;
+		vsc_packet_revision = vsc_packet_rev2;
 
 	/* Update to revision 5 for extended colorimetry support for DPCD 1.4+ */
 	if (stream->link->dpcd_caps.dpcd_rev.raw >= 0x14 &&
 			stream->link->dpcd_caps.dprx_feature.bits.VSC_SDP_COLORIMETRY_SUPPORTED)
-		vscPacketRevision = 5;
+		vsc_packet_revision = vsc_packet_rev5;
 
 	/* VSC packet not needed based on the features
 	 * supported by this DP display
 	 */
-	if (vscPacketRevision == 0)
+	if (vsc_packet_revision == vsc_packet_undefined)
 		return;
 
-	if (vscPacketRevision == 0x2) {
+	if (vsc_packet_revision == vsc_packet_rev2) {
 		/* Secondary-data Packet ID = 0*/
 		info_packet->hb0 = 0x00;
 		/* 07h - Packet Type Value indicating Video
@@ -166,7 +186,7 @@ void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 		info_packet->valid = true;
 	}
 
-	if (vscPacketRevision == 0x1) {
+	if (vsc_packet_revision == vsc_packet_rev1) {
 
 		info_packet->hb0 = 0x00;	// Secondary-data Packet ID = 0
 		info_packet->hb1 = 0x07;	// 07h = Packet Type Value indicating Video Stream Configuration packet
@@ -237,7 +257,7 @@ void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 	 *   the Pixel Encoding/Colorimetry Format and that a Sink device must ignore MISC1, bit 7, and
 	 *   MISC0, bits 7:1 (MISC1, bit 7. and MISC0, bits 7:1 become "don't care").)
 	 */
-	if (vscPacketRevision == 0x5) {
+	if (vsc_packet_revision == vsc_packet_rev5) {
 		/* Secondary-data Packet ID = 0 */
 		info_packet->hb0 = 0x00;
 		/* 07h - Packet Type Value indicating Video Stream Configuration packet */
@@ -249,6 +269,13 @@ void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 
 		info_packet->valid = true;
 
+		/* If we are using VSC SDP revision 05h, use this to signal for
+		 * colorimetry format and pixel encoding. HW should later be
+		 * programmed to set MSA MISC1 bit 6 to indicate ignore
+		 * colorimetry format and pixel encoding in the MSA.
+		 */
+		*use_vsc_sdp_for_colorimetry = true;
+
 		/* Set VSC SDP fields for pixel encoding and colorimetry format from DP 1.3 specs
 		 * Data Bytes DB 18~16
 		 * Bits 3:0 (Colorimetry Format)        |  Bits 7:4 (Pixel Encoding)
@@ -393,7 +420,6 @@ void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 		 */
 		info_packet->sb[18] = 0;
 	}
-
 }
 
 /**

commit 3c2381b92cba739b19be9beecdcb49d4730a42f2
Author: Wayne Lin <Wayne.Lin@amd.com>
Date:   Wed Sep 4 05:18:31 2019 +0800

    drm/amd/display: add support for VSIP info packet
    
    [Why]
    The vendor specific infoframe is needed for HDMI while displaying
    specific modes.
    DC supports sending it, but we aren't currently building it
    
    [How]
    Add mod_build_hf_vsif_infopacket() to build the vendor specific
    info packet.
    
    Signed-off-by: Wayne Lin <Wayne.Lin@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
index d885d642ed7f..db6b08f6d093 100644
--- a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
+++ b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
@@ -31,6 +31,7 @@
 #include "dc.h"
 
 #define HDMI_INFOFRAME_TYPE_VENDOR 0x81
+#define HF_VSIF_VERSION 1
 
 // VTEM Byte Offset
 #define VTEM_PB0		0
@@ -395,3 +396,100 @@ void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 
 }
 
+/**
+ *****************************************************************************
+ *  Function: mod_build_hf_vsif_infopacket
+ *
+ *  @brief
+ *     Prepare HDMI Vendor Specific info frame.
+ *     Follows HDMI Spec to build up Vendor Specific info frame
+ *
+ *  @param [in] stream: contains data we may need to construct VSIF (i.e. timing_3d_format, etc.)
+ *  @param [out] info_packet:   output structure where to store VSIF
+ *****************************************************************************
+ */
+void mod_build_hf_vsif_infopacket(const struct dc_stream_state *stream,
+		struct dc_info_packet *info_packet, int ALLMEnabled, int ALLMValue)
+{
+		unsigned int length = 5;
+		bool hdmi_vic_mode = false;
+		uint8_t checksum = 0;
+		uint32_t i = 0;
+		enum dc_timing_3d_format format;
+		bool bALLM = (bool)ALLMEnabled;
+		bool bALLMVal = (bool)ALLMValue;
+
+		info_packet->valid = false;
+		format = stream->timing.timing_3d_format;
+		if (stream->view_format == VIEW_3D_FORMAT_NONE)
+			format = TIMING_3D_FORMAT_NONE;
+
+		if (stream->timing.hdmi_vic != 0
+				&& stream->timing.h_total >= 3840
+				&& stream->timing.v_total >= 2160
+				&& format == TIMING_3D_FORMAT_NONE)
+			hdmi_vic_mode = true;
+
+		if ((format == TIMING_3D_FORMAT_NONE) && !hdmi_vic_mode && !bALLM)
+			return;
+
+		info_packet->sb[1] = 0x03;
+		info_packet->sb[2] = 0x0C;
+		info_packet->sb[3] = 0x00;
+
+		if (bALLM) {
+			info_packet->sb[1] = 0xD8;
+			info_packet->sb[2] = 0x5D;
+			info_packet->sb[3] = 0xC4;
+			info_packet->sb[4] = HF_VSIF_VERSION;
+		}
+
+		if (format != TIMING_3D_FORMAT_NONE)
+			info_packet->sb[4] = (2 << 5);
+
+		else if (hdmi_vic_mode)
+			info_packet->sb[4] = (1 << 5);
+
+		switch (format) {
+		case TIMING_3D_FORMAT_HW_FRAME_PACKING:
+		case TIMING_3D_FORMAT_SW_FRAME_PACKING:
+			info_packet->sb[5] = (0x0 << 4);
+			break;
+
+		case TIMING_3D_FORMAT_SIDE_BY_SIDE:
+		case TIMING_3D_FORMAT_SBS_SW_PACKED:
+			info_packet->sb[5] = (0x8 << 4);
+			length = 6;
+			break;
+
+		case TIMING_3D_FORMAT_TOP_AND_BOTTOM:
+		case TIMING_3D_FORMAT_TB_SW_PACKED:
+			info_packet->sb[5] = (0x6 << 4);
+			break;
+
+		default:
+			break;
+		}
+
+		if (hdmi_vic_mode)
+			info_packet->sb[5] = stream->timing.hdmi_vic;
+
+		info_packet->hb0 = HDMI_INFOFRAME_TYPE_VENDOR;
+		info_packet->hb1 = 0x01;
+		info_packet->hb2 = (uint8_t) (length);
+
+		if (bALLM)
+			info_packet->sb[5] = (info_packet->sb[5] & ~0x02) | (bALLMVal << 1);
+
+		checksum += info_packet->hb0;
+		checksum += info_packet->hb1;
+		checksum += info_packet->hb2;
+
+		for (i = 1; i <= length; i++)
+			checksum += info_packet->sb[i];
+
+		info_packet->sb[0] = (uint8_t) (0x100 - checksum);
+
+		info_packet->valid = true;
+}
+

commit b202c0ff184a6203779e32aeb46b50e32e92d7ee
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Tue Aug 27 15:09:25 2019 +0800

    drm/amd/display: remove unused function setFieldWithMask
    
    After commit a9f54ce3c603 ("drm/amd/display: Refactoring VTEM"),
    there is no caller in tree.
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
index 5f4b98df3d92..d885d642ed7f 100644
--- a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
+++ b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
@@ -114,25 +114,6 @@ enum ColorimetryYCCDP {
 	ColorimetryYCC_DP_ITU2020YCbCr  = 7,
 };
 
-void setFieldWithMask(unsigned char *dest, unsigned int mask, unsigned int value)
-{
-	unsigned int shift = 0;
-
-	if (!mask || !dest)
-		return;
-
-	while (!((mask >> shift) & 1))
-		shift++;
-
-	//reset
-	*dest = *dest & ~mask;
-	//set
-	//dont let value span past mask
-	value = value & (mask >> shift);
-	//insert value
-	*dest = *dest | (value << shift);
-}
-
 void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 		struct dc_info_packet *info_packet)
 {

commit a9f54ce3c6032361d2b69910114b6e8baf9bdf49
Author: Ahmad Othman <ahmad.othman@amd.com>
Date:   Thu Aug 1 15:05:27 2019 -0400

    drm/amd/display: Refactoring VTEM
    
    [Why]
    Video Timing Extended Metadata packet (VTEM) is not
    specific to freesync. So move it out of freesync module
    
    [How]
    - Moved VTEM from freesync module to info_packet module
    - Created new structure for VTEM parameters that can be used for VRR
    and FVA
    
    Signed-off-by: Ahmad Othman <ahmad.othman@amd.com>
    Reviewed-by: Chris Park <Chris.Park@amd.com>
    Acked-by: Ahmad Othman <Ahmad.Othman@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
index bc13c552797f..5f4b98df3d92 100644
--- a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
+++ b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
@@ -27,9 +27,78 @@
 #include "core_types.h"
 #include "dc_types.h"
 #include "mod_shared.h"
+#include "mod_freesync.h"
+#include "dc.h"
 
 #define HDMI_INFOFRAME_TYPE_VENDOR 0x81
 
+// VTEM Byte Offset
+#define VTEM_PB0		0
+#define VTEM_PB1		1
+#define VTEM_PB2		2
+#define VTEM_PB3		3
+#define VTEM_PB4		4
+#define VTEM_PB5		5
+#define VTEM_PB6		6
+
+#define VTEM_MD0		7
+#define VTEM_MD1		8
+#define VTEM_MD2		9
+#define VTEM_MD3		10
+
+
+// VTEM Byte Masks
+//PB0
+#define MASK_VTEM_PB0__RESERVED0  0x01
+#define MASK_VTEM_PB0__SYNC       0x02
+#define MASK_VTEM_PB0__VFR        0x04
+#define MASK_VTEM_PB0__AFR        0x08
+#define MASK_VTEM_PB0__DS_TYPE    0x30
+	//0: Periodic pseudo-static EM Data Set
+	//1: Periodic dynamic EM Data Set
+	//2: Unique EM Data Set
+	//3: Reserved
+#define MASK_VTEM_PB0__END        0x40
+#define MASK_VTEM_PB0__NEW        0x80
+
+//PB1
+#define MASK_VTEM_PB1__RESERVED1 0xFF
+
+//PB2
+#define MASK_VTEM_PB2__ORGANIZATION_ID 0xFF
+	//0: This is a Vendor Specific EM Data Set
+	//1: This EM Data Set is defined by This Specification (HDMI 2.1 r102.clean)
+	//2: This EM Data Set is defined by CTA-861-G
+	//3: This EM Data Set is defined by VESA
+//PB3
+#define MASK_VTEM_PB3__DATA_SET_TAG_MSB    0xFF
+//PB4
+#define MASK_VTEM_PB4__DATA_SET_TAG_LSB    0xFF
+//PB5
+#define MASK_VTEM_PB5__DATA_SET_LENGTH_MSB 0xFF
+//PB6
+#define MASK_VTEM_PB6__DATA_SET_LENGTH_LSB 0xFF
+
+
+
+//PB7-27 (20 bytes):
+//PB7 = MD0
+#define MASK_VTEM_MD0__VRR_EN         0x01
+#define MASK_VTEM_MD0__M_CONST        0x02
+#define MASK_VTEM_MD0__RESERVED2      0x0C
+#define MASK_VTEM_MD0__FVA_FACTOR_M1  0xF0
+
+//MD1
+#define MASK_VTEM_MD1__BASE_VFRONT    0xFF
+
+//MD2
+#define MASK_VTEM_MD2__BASE_REFRESH_RATE_98  0x03
+#define MASK_VTEM_MD2__RB                    0x04
+#define MASK_VTEM_MD2__RESERVED3             0xF8
+
+//MD3
+#define MASK_VTEM_MD3__BASE_REFRESH_RATE_07  0xFF
+
 enum ColorimetryRGBDP {
 	ColorimetryRGB_DP_sRGB               = 0,
 	ColorimetryRGB_DP_AdobeRGB           = 3,
@@ -45,6 +114,25 @@ enum ColorimetryYCCDP {
 	ColorimetryYCC_DP_ITU2020YCbCr  = 7,
 };
 
+void setFieldWithMask(unsigned char *dest, unsigned int mask, unsigned int value)
+{
+	unsigned int shift = 0;
+
+	if (!mask || !dest)
+		return;
+
+	while (!((mask >> shift) & 1))
+		shift++;
+
+	//reset
+	*dest = *dest & ~mask;
+	//set
+	//dont let value span past mask
+	value = value & (mask >> shift);
+	//insert value
+	*dest = *dest | (value << shift);
+}
+
 void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 		struct dc_info_packet *info_packet)
 {

commit b33171ccaabeffa40df9744656d8d523ceb2b612
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Wed May 1 17:05:05 2019 -0400

    drm/amd/display: Use VCP for extended colorimetry
    
    DPRX should send the VCP extended colorimetry packet if the
    sink supports DPCD rev1.4 and reports the extended colorimetry
    bit.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
index db06fab2ad5c..bc13c552797f 100644
--- a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
+++ b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
@@ -63,7 +63,9 @@ void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 	if (stream->psr_version != 0)
 		vscPacketRevision = 2;
 
-	if (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)
+	/* Update to revision 5 for extended colorimetry support for DPCD 1.4+ */
+	if (stream->link->dpcd_caps.dpcd_rev.raw >= 0x14 &&
+			stream->link->dpcd_caps.dprx_feature.bits.VSC_SDP_COLORIMETRY_SUPPORTED)
 		vscPacketRevision = 5;
 
 	/* VSC packet not needed based on the features

commit ecd0136bfdb5a28b8a869c305823df9d663e85ee
Author: Harmanprit Tatla <Harmanprit.Tatla@amd.com>
Date:   Mon Nov 5 17:55:53 2018 -0500

    drm/amd/display: Info frame cleanup
    
    * Use provided infopacket in stream (if valid) instead of reconstructing
      in set_vendor_info_packet()
    * Use proper format for enums
    * Use dc info packet struct instead
    
    Signed-off-by: Harmanprit Tatla <Harmanprit.Tatla@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
index ff8bfb9b43b0..db06fab2ad5c 100644
--- a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
+++ b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
@@ -25,6 +25,10 @@
 
 #include "mod_info_packet.h"
 #include "core_types.h"
+#include "dc_types.h"
+#include "mod_shared.h"
+
+#define HDMI_INFOFRAME_TYPE_VENDOR 0x81
 
 enum ColorimetryRGBDP {
 	ColorimetryRGB_DP_sRGB               = 0,
@@ -41,7 +45,7 @@ enum ColorimetryYCCDP {
 	ColorimetryYCC_DP_ITU2020YCbCr  = 7,
 };
 
-static void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
+void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 		struct dc_info_packet *info_packet)
 {
 	unsigned int vscPacketRevision = 0;
@@ -159,7 +163,7 @@ static void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 	 *   DPCD register is exposed in the new Extended Receiver Capability field for DPCD Rev. 1.4
 	 *   (and higher). When MISC1. bit 6. is Set to 1, a Source device uses a VSC SDP to indicate
 	 *   the Pixel Encoding/Colorimetry Format and that a Sink device must ignore MISC1, bit 7, and
-	 *   MISC0, bits 7:1 (MISC1, bit 7. and MISC0, bits 7:1 become “don’t care”).)
+	 *   MISC0, bits 7:1 (MISC1, bit 7. and MISC0, bits 7:1 become "don't care").)
 	 */
 	if (vscPacketRevision == 0x5) {
 		/* Secondary-data Packet ID = 0 */
@@ -320,10 +324,3 @@ static void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 
 }
 
-void mod_build_infopackets(struct info_packet_inputs *inputs,
-		struct info_packets *info_packets)
-{
-	if (info_packets->pVscInfoPacket != NULL)
-		mod_build_vsc_infopacket(inputs->pStream, info_packets->pVscInfoPacket);
-}
-

commit 99267ce71a1faabce9d8063d37e1ee7dd240b6eb
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Mon Sep 10 10:11:01 2018 -0400

    drm/amd/display: Stereo 3D support in VSC
    
    [Why]
    Need to add strere 3D information in VSC
    
    [How]
    Update mod_build_vsc_infopacket with stereo info
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
index 52378fc69079..ff8bfb9b43b0 100644
--- a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
+++ b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
@@ -48,9 +48,12 @@ static void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 	unsigned int i;
 	unsigned int pixelEncoding = 0;
 	unsigned int colorimetryFormat = 0;
+	bool stereo3dSupport = false;
 
-	if (stream->timing.timing_3d_format != TIMING_3D_FORMAT_NONE && stream->view_format != VIEW_3D_FORMAT_NONE)
+	if (stream->timing.timing_3d_format != TIMING_3D_FORMAT_NONE && stream->view_format != VIEW_3D_FORMAT_NONE) {
 		vscPacketRevision = 1;
+		stereo3dSupport = true;
+	}
 
 	/*VSC packet set to 2 when DP revision >= 1.2*/
 	if (stream->psr_version != 0)
@@ -94,12 +97,59 @@ static void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 		info_packet->hb2 = 0x01;	// 01h = Revision number. VSC SDP supporting 3D stereo only
 		info_packet->hb3 = 0x01;	// 01h = VSC SDP supporting 3D stereo only (HB2 = 01h).
 
-		if (stream->timing.timing_3d_format == TIMING_3D_FORMAT_INBAND_FA)
-			info_packet->sb[0] = 0x1;
-
 		info_packet->valid = true;
 	}
 
+	if (stereo3dSupport) {
+		/* ==============================================================================================================|
+		 * A. STEREO 3D
+		 * ==============================================================================================================|
+		 * VSC Payload (1 byte) From DP1.2 spec
+		 *
+		 * Bits 3:0 (Stereo Interface Method Code)  |  Bits 7:4 (Stereo Interface Method Specific Parameter)
+		 * -----------------------------------------------------------------------------------------------------
+		 * 0 = Non Stereo Video                     |  Must be set to 0x0
+		 * -----------------------------------------------------------------------------------------------------
+		 * 1 = Frame/Field Sequential               |  0x0: L + R view indication based on MISC1 bit 2:1
+		 *                                          |  0x1: Right when Stereo Signal = 1
+		 *                                          |  0x2: Left when Stereo Signal = 1
+		 *                                          |  (others reserved)
+		 * -----------------------------------------------------------------------------------------------------
+		 * 2 = Stacked Frame                        |  0x0: Left view is on top and right view on bottom
+		 *                                          |  (others reserved)
+		 * -----------------------------------------------------------------------------------------------------
+		 * 3 = Pixel Interleaved                    |  0x0: horiz interleaved, right view pixels on even lines
+		 *                                          |  0x1: horiz interleaved, right view pixels on odd lines
+		 *                                          |  0x2: checker board, start with left view pixel
+		 *                                          |  0x3: vertical interleaved, start with left view pixels
+		 *                                          |  0x4: vertical interleaved, start with right view pixels
+		 *                                          |  (others reserved)
+		 * -----------------------------------------------------------------------------------------------------
+		 * 4 = Side-by-side                         |  0x0: left half represents left eye view
+		 *                                          |  0x1: left half represents right eye view
+		 */
+		switch (stream->timing.timing_3d_format) {
+		case TIMING_3D_FORMAT_HW_FRAME_PACKING:
+		case TIMING_3D_FORMAT_SW_FRAME_PACKING:
+		case TIMING_3D_FORMAT_TOP_AND_BOTTOM:
+		case TIMING_3D_FORMAT_TB_SW_PACKED:
+			info_packet->sb[0] = 0x02; // Stacked Frame, Left view is on top and right view on bottom.
+			break;
+		case TIMING_3D_FORMAT_DP_HDMI_INBAND_FA:
+		case TIMING_3D_FORMAT_INBAND_FA:
+			info_packet->sb[0] = 0x01; // Frame/Field Sequential, L + R view indication based on MISC1 bit 2:1
+			break;
+		case TIMING_3D_FORMAT_SIDE_BY_SIDE:
+		case TIMING_3D_FORMAT_SBS_SW_PACKED:
+			info_packet->sb[0] = 0x04; // Side-by-side
+			break;
+		default:
+			info_packet->sb[0] = 0x00; // No Stereo Video, Shall be cleared to 0x0.
+			break;
+		}
+
+	}
+
 	/* 05h = VSC SDP supporting 3D stereo, PSR2, and Pixel Encoding/Colorimetry Format indication.
 	 *   Added in DP1.3, a DP Source device is allowed to indicate the pixel encoding/colorimetry
 	 *   format to the DP Sink device with VSC SDP only when the DP Sink device supports it

commit 182388fcc4c820b34038f474c1a47e9700cd3c09
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Thu May 24 15:50:27 2018 -0400

    drm/amd/display: Add DP YCbCr 4:2:0 support
    
    [Why]
    For supporting DP YCbCr 4:2:0 output.
    
    [How]
    Update mod_build_vsc_infopacket to support Pixel
    Encoding/Colorimetry Format indication for VSC SDP rev5.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
index 24b6cc1dfc64..52378fc69079 100644
--- a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
+++ b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
@@ -26,20 +26,38 @@
 #include "mod_info_packet.h"
 #include "core_types.h"
 
+enum ColorimetryRGBDP {
+	ColorimetryRGB_DP_sRGB               = 0,
+	ColorimetryRGB_DP_AdobeRGB           = 3,
+	ColorimetryRGB_DP_P3                 = 4,
+	ColorimetryRGB_DP_CustomColorProfile = 5,
+	ColorimetryRGB_DP_ITU_R_BT2020RGB    = 6,
+};
+enum ColorimetryYCCDP {
+	ColorimetryYCC_DP_ITU601        = 0,
+	ColorimetryYCC_DP_ITU709        = 1,
+	ColorimetryYCC_DP_AdobeYCC      = 5,
+	ColorimetryYCC_DP_ITU2020YCC    = 6,
+	ColorimetryYCC_DP_ITU2020YCbCr  = 7,
+};
+
 static void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 		struct dc_info_packet *info_packet)
 {
 	unsigned int vscPacketRevision = 0;
 	unsigned int i;
+	unsigned int pixelEncoding = 0;
+	unsigned int colorimetryFormat = 0;
 
 	if (stream->timing.timing_3d_format != TIMING_3D_FORMAT_NONE && stream->view_format != VIEW_3D_FORMAT_NONE)
 		vscPacketRevision = 1;
 
-
 	/*VSC packet set to 2 when DP revision >= 1.2*/
 	if (stream->psr_version != 0)
 		vscPacketRevision = 2;
 
+	if (stream->timing.pixel_encoding == PIXEL_ENCODING_YCBCR420)
+		vscPacketRevision = 5;
 
 	/* VSC packet not needed based on the features
 	 * supported by this DP display
@@ -81,6 +99,175 @@ static void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
 
 		info_packet->valid = true;
 	}
+
+	/* 05h = VSC SDP supporting 3D stereo, PSR2, and Pixel Encoding/Colorimetry Format indication.
+	 *   Added in DP1.3, a DP Source device is allowed to indicate the pixel encoding/colorimetry
+	 *   format to the DP Sink device with VSC SDP only when the DP Sink device supports it
+	 *   (i.e., VSC_SDP_EXTENSION_FOR_COLORIMETRY_SUPPORTED bit in the DPRX_FEATURE_ENUMERATION_LIST
+	 *   register (DPCD Address 02210h, bit 3) is set to 1).
+	 *   (Requires VSC_SDP_EXTENSION_FOR_COLORIMETRY_SUPPORTED bit set to 1 in DPCD 02210h. This
+	 *   DPCD register is exposed in the new Extended Receiver Capability field for DPCD Rev. 1.4
+	 *   (and higher). When MISC1. bit 6. is Set to 1, a Source device uses a VSC SDP to indicate
+	 *   the Pixel Encoding/Colorimetry Format and that a Sink device must ignore MISC1, bit 7, and
+	 *   MISC0, bits 7:1 (MISC1, bit 7. and MISC0, bits 7:1 become “don’t care”).)
+	 */
+	if (vscPacketRevision == 0x5) {
+		/* Secondary-data Packet ID = 0 */
+		info_packet->hb0 = 0x00;
+		/* 07h - Packet Type Value indicating Video Stream Configuration packet */
+		info_packet->hb1 = 0x07;
+		/* 05h = VSC SDP supporting 3D stereo, PSR2, and Pixel Encoding/Colorimetry Format indication. */
+		info_packet->hb2 = 0x05;
+		/* 13h = VSC SDP supporting 3D stereo, + PSR2, + Pixel Encoding/Colorimetry Format indication (HB2 = 05h). */
+		info_packet->hb3 = 0x13;
+
+		info_packet->valid = true;
+
+		/* Set VSC SDP fields for pixel encoding and colorimetry format from DP 1.3 specs
+		 * Data Bytes DB 18~16
+		 * Bits 3:0 (Colorimetry Format)        |  Bits 7:4 (Pixel Encoding)
+		 * ----------------------------------------------------------------------------------------------------
+		 * 0x0 = sRGB                           |  0 = RGB
+		 * 0x1 = RGB Wide Gamut Fixed Point
+		 * 0x2 = RGB Wide Gamut Floating Point
+		 * 0x3 = AdobeRGB
+		 * 0x4 = DCI-P3
+		 * 0x5 = CustomColorProfile
+		 * (others reserved)
+		 * ----------------------------------------------------------------------------------------------------
+		 * 0x0 = ITU-R BT.601                   |  1 = YCbCr444
+		 * 0x1 = ITU-R BT.709
+		 * 0x2 = xvYCC601
+		 * 0x3 = xvYCC709
+		 * 0x4 = sYCC601
+		 * 0x5 = AdobeYCC601
+		 * 0x6 = ITU-R BT.2020 Y'cC'bcC'rc
+		 * 0x7 = ITU-R BT.2020 Y'C'bC'r
+		 * (others reserved)
+		 * ----------------------------------------------------------------------------------------------------
+		 * 0x0 = ITU-R BT.601                   |  2 = YCbCr422
+		 * 0x1 = ITU-R BT.709
+		 * 0x2 = xvYCC601
+		 * 0x3 = xvYCC709
+		 * 0x4 = sYCC601
+		 * 0x5 = AdobeYCC601
+		 * 0x6 = ITU-R BT.2020 Y'cC'bcC'rc
+		 * 0x7 = ITU-R BT.2020 Y'C'bC'r
+		 * (others reserved)
+		 * ----------------------------------------------------------------------------------------------------
+		 * 0x0 = ITU-R BT.601                   |  3 = YCbCr420
+		 * 0x1 = ITU-R BT.709
+		 * 0x2 = xvYCC601
+		 * 0x3 = xvYCC709
+		 * 0x4 = sYCC601
+		 * 0x5 = AdobeYCC601
+		 * 0x6 = ITU-R BT.2020 Y'cC'bcC'rc
+		 * 0x7 = ITU-R BT.2020 Y'C'bC'r
+		 * (others reserved)
+		 * ----------------------------------------------------------------------------------------------------
+		 * 0x0 =DICOM Part14 Grayscale          |  4 = Yonly
+		 * Display Function
+		 * (others reserved)
+		 */
+
+		/* Set Pixel Encoding */
+		switch (stream->timing.pixel_encoding) {
+		case PIXEL_ENCODING_RGB:
+			pixelEncoding = 0x0;  /* RGB = 0h */
+			break;
+		case PIXEL_ENCODING_YCBCR444:
+			pixelEncoding = 0x1;  /* YCbCr444 = 1h */
+			break;
+		case PIXEL_ENCODING_YCBCR422:
+			pixelEncoding = 0x2;  /* YCbCr422 = 2h */
+			break;
+		case PIXEL_ENCODING_YCBCR420:
+			pixelEncoding = 0x3;  /* YCbCr420 = 3h */
+			break;
+		default:
+			pixelEncoding = 0x0;  /* default RGB = 0h */
+			break;
+		}
+
+		/* Set Colorimetry format based on pixel encoding */
+		switch (stream->timing.pixel_encoding) {
+		case PIXEL_ENCODING_RGB:
+			if ((stream->output_color_space == COLOR_SPACE_SRGB) ||
+					(stream->output_color_space == COLOR_SPACE_SRGB_LIMITED))
+				colorimetryFormat = ColorimetryRGB_DP_sRGB;
+			else if (stream->output_color_space == COLOR_SPACE_ADOBERGB)
+				colorimetryFormat = ColorimetryRGB_DP_AdobeRGB;
+			else if ((stream->output_color_space == COLOR_SPACE_2020_RGB_FULLRANGE) ||
+					(stream->output_color_space == COLOR_SPACE_2020_RGB_LIMITEDRANGE))
+				colorimetryFormat = ColorimetryRGB_DP_ITU_R_BT2020RGB;
+			break;
+
+		case PIXEL_ENCODING_YCBCR444:
+		case PIXEL_ENCODING_YCBCR422:
+		case PIXEL_ENCODING_YCBCR420:
+			/* Note: xvYCC probably not supported correctly here on DP since colorspace translation
+			 * loses distinction between BT601 vs xvYCC601 in translation
+			 */
+			if (stream->output_color_space == COLOR_SPACE_YCBCR601)
+				colorimetryFormat = ColorimetryYCC_DP_ITU601;
+			else if (stream->output_color_space == COLOR_SPACE_YCBCR709)
+				colorimetryFormat = ColorimetryYCC_DP_ITU709;
+			else if (stream->output_color_space == COLOR_SPACE_ADOBERGB)
+				colorimetryFormat = ColorimetryYCC_DP_AdobeYCC;
+			else if (stream->output_color_space == COLOR_SPACE_2020_YCBCR)
+				colorimetryFormat = ColorimetryYCC_DP_ITU2020YCbCr;
+			break;
+
+		default:
+			colorimetryFormat = ColorimetryRGB_DP_sRGB;
+			break;
+		}
+
+		info_packet->sb[16] = (pixelEncoding << 4) | colorimetryFormat;
+
+		/* Set color depth */
+		switch (stream->timing.display_color_depth) {
+		case COLOR_DEPTH_666:
+			/* NOTE: This is actually not valid for YCbCr pixel encoding to have 6 bpc
+			 *       as of DP1.4 spec, but value of 0 probably reserved here for potential future use.
+			 */
+			info_packet->sb[17] = 0;
+			break;
+		case COLOR_DEPTH_888:
+			info_packet->sb[17] = 1;
+			break;
+		case COLOR_DEPTH_101010:
+			info_packet->sb[17] = 2;
+			break;
+		case COLOR_DEPTH_121212:
+			info_packet->sb[17] = 3;
+			break;
+		/*case COLOR_DEPTH_141414: -- NO SUCH FORMAT IN DP SPEC */
+		case COLOR_DEPTH_161616:
+			info_packet->sb[17] = 4;
+			break;
+		default:
+			info_packet->sb[17] = 0;
+			break;
+		}
+
+		/* all YCbCr are always limited range */
+		if ((stream->output_color_space == COLOR_SPACE_SRGB_LIMITED) ||
+				(stream->output_color_space == COLOR_SPACE_2020_RGB_LIMITEDRANGE) ||
+				(pixelEncoding != 0x0)) {
+			info_packet->sb[17] |= 0x80; /* DB17 bit 7 set to 1 for CEA timing. */
+		}
+
+		/* Content Type (Bits 2:0)
+		 *  0 = Not defined.
+		 *  1 = Graphics.
+		 *  2 = Photo.
+		 *  3 = Video.
+		 *  4 = Game.
+		 */
+		info_packet->sb[18] = 0;
+	}
+
 }
 
 void mod_build_infopackets(struct info_packet_inputs *inputs,

commit 1336926f43ccadf2a152ea89a27de725c4d17f62
Author: Alvin lee <alvin.lee3@amd.com>
Date:   Mon Jun 4 17:31:25 2018 -0400

    drm/amd/display: Enable Stereo in Dal3
    
    - program infoframe for Stereo
    - program stereo flip control registers properly
    
    v2: Add missing license headers
    
    Signed-off-by: Alvin lee <alvin.lee3@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
new file mode 100644
index 000000000000..24b6cc1dfc64
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/modules/info_packet/info_packet.c
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "mod_info_packet.h"
+#include "core_types.h"
+
+static void mod_build_vsc_infopacket(const struct dc_stream_state *stream,
+		struct dc_info_packet *info_packet)
+{
+	unsigned int vscPacketRevision = 0;
+	unsigned int i;
+
+	if (stream->timing.timing_3d_format != TIMING_3D_FORMAT_NONE && stream->view_format != VIEW_3D_FORMAT_NONE)
+		vscPacketRevision = 1;
+
+
+	/*VSC packet set to 2 when DP revision >= 1.2*/
+	if (stream->psr_version != 0)
+		vscPacketRevision = 2;
+
+
+	/* VSC packet not needed based on the features
+	 * supported by this DP display
+	 */
+	if (vscPacketRevision == 0)
+		return;
+
+	if (vscPacketRevision == 0x2) {
+		/* Secondary-data Packet ID = 0*/
+		info_packet->hb0 = 0x00;
+		/* 07h - Packet Type Value indicating Video
+		 * Stream Configuration packet
+		 */
+		info_packet->hb1 = 0x07;
+		/* 02h = VSC SDP supporting 3D stereo and PSR
+		 * (applies to eDP v1.3 or higher).
+		 */
+		info_packet->hb2 = 0x02;
+		/* 08h = VSC packet supporting 3D stereo + PSR
+		 * (HB2 = 02h).
+		 */
+		info_packet->hb3 = 0x08;
+
+		for (i = 0; i < 28; i++)
+			info_packet->sb[i] = 0;
+
+		info_packet->valid = true;
+	}
+
+	if (vscPacketRevision == 0x1) {
+
+		info_packet->hb0 = 0x00;	// Secondary-data Packet ID = 0
+		info_packet->hb1 = 0x07;	// 07h = Packet Type Value indicating Video Stream Configuration packet
+		info_packet->hb2 = 0x01;	// 01h = Revision number. VSC SDP supporting 3D stereo only
+		info_packet->hb3 = 0x01;	// 01h = VSC SDP supporting 3D stereo only (HB2 = 01h).
+
+		if (stream->timing.timing_3d_format == TIMING_3D_FORMAT_INBAND_FA)
+			info_packet->sb[0] = 0x1;
+
+		info_packet->valid = true;
+	}
+}
+
+void mod_build_infopackets(struct info_packet_inputs *inputs,
+		struct info_packets *info_packets)
+{
+	if (info_packets->pVscInfoPacket != NULL)
+		mod_build_vsc_infopacket(inputs->pStream, info_packets->pVscInfoPacket);
+}
+
