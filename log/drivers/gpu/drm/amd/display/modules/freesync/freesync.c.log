commit d2bacc38f6caa96e6d67d2e3e2bd0aee36de6954
Author: Haiyi Zhou <haiyi.zhou@amd.com>
Date:   Fri Apr 3 10:00:58 2020 -0400

    drm/amd/display: Change infopacket type programming
    
    [Why]
    Certain displays may experience blanking if infopacket max range does
    not equal nominal refresh rate.
    
    [How]
    Add additional infopacket versions to program range to full or forced
    range in freesync states.
    This does not change the vrr logic.
    
    Signed-off-by: Haiyi Zhou <haiyi.zhou@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index c33454a9e0b4..eb7421e83b86 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -443,7 +443,7 @@ static bool vrr_settings_require_update(struct core_freesync *core_freesync,
 		return true;
 	} else if (in_vrr->state == VRR_STATE_ACTIVE_FIXED &&
 			in_vrr->fixed.target_refresh_in_uhz !=
-					in_config->min_refresh_in_uhz) {
+					in_config->fixed_refresh_in_uhz) {
 		return true;
 	} else if (in_vrr->min_refresh_in_uhz != min_refresh_in_uhz) {
 		return true;
@@ -491,7 +491,7 @@ bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
 	return false;
 }
 
-static void build_vrr_infopacket_data(const struct mod_vrr_params *vrr,
+static void build_vrr_infopacket_data_v1(const struct mod_vrr_params *vrr,
 		struct dc_info_packet *infopacket)
 {
 	/* PB1 = 0x1A (24bit AMD IEEE OUI (0x00001A) - Byte 0) */
@@ -523,14 +523,74 @@ static void build_vrr_infopacket_data(const struct mod_vrr_params *vrr,
 			vrr->state == VRR_STATE_ACTIVE_FIXED)
 		infopacket->sb[6] |= 0x04;
 
+	// For v1 & 2 infoframes program nominal if non-fs mode, otherwise full range
 	/* PB7 = FreeSync Minimum refresh rate (Hz) */
-	infopacket->sb[7] = (unsigned char)((vrr->min_refresh_in_uhz + 500000) / 1000000);
+	if (vrr->state == VRR_STATE_ACTIVE_VARIABLE ||
+			vrr->state == VRR_STATE_ACTIVE_FIXED) {
+		infopacket->sb[7] = (unsigned char)((vrr->min_refresh_in_uhz + 500000) / 1000000);
+	} else {
+		infopacket->sb[7] = (unsigned char)((vrr->max_refresh_in_uhz + 500000) / 1000000);
+	}
 
 	/* PB8 = FreeSync Maximum refresh rate (Hz)
 	 * Note: We should never go above the field rate of the mode timing set.
 	 */
 	infopacket->sb[8] = (unsigned char)((vrr->max_refresh_in_uhz + 500000) / 1000000);
 
+	//FreeSync HDR
+	infopacket->sb[9] = 0;
+	infopacket->sb[10] = 0;
+}
+
+static void build_vrr_infopacket_data_v3(const struct mod_vrr_params *vrr,
+		struct dc_info_packet *infopacket)
+{
+	/* PB1 = 0x1A (24bit AMD IEEE OUI (0x00001A) - Byte 0) */
+	infopacket->sb[1] = 0x1A;
+
+	/* PB2 = 0x00 (24bit AMD IEEE OUI (0x00001A) - Byte 1) */
+	infopacket->sb[2] = 0x00;
+
+	/* PB3 = 0x00 (24bit AMD IEEE OUI (0x00001A) - Byte 2) */
+	infopacket->sb[3] = 0x00;
+
+	/* PB4 = Reserved */
+
+	/* PB5 = Reserved */
+
+	/* PB6 = [Bits 7:3 = Reserved] */
+
+	/* PB6 = [Bit 0 = FreeSync Supported] */
+	if (vrr->state != VRR_STATE_UNSUPPORTED)
+		infopacket->sb[6] |= 0x01;
+
+	/* PB6 = [Bit 1 = FreeSync Enabled] */
+	if (vrr->state != VRR_STATE_DISABLED &&
+			vrr->state != VRR_STATE_UNSUPPORTED)
+		infopacket->sb[6] |= 0x02;
+
+	/* PB6 = [Bit 2 = FreeSync Active] */
+	if (vrr->state == VRR_STATE_ACTIVE_VARIABLE ||
+			vrr->state == VRR_STATE_ACTIVE_FIXED)
+		infopacket->sb[6] |= 0x04;
+
+	if (vrr->state == VRR_STATE_ACTIVE_FIXED) {
+		/* PB7 = FreeSync Minimum refresh rate (Hz) */
+		infopacket->sb[7] = (unsigned char)((vrr->fixed_refresh_in_uhz + 500000) / 1000000);
+		/* PB8 = FreeSync Maximum refresh rate (Hz) */
+		infopacket->sb[8] = (unsigned char)((vrr->fixed_refresh_in_uhz + 500000) / 1000000);
+	} else if (vrr->state == VRR_STATE_ACTIVE_VARIABLE) {
+		/* PB7 = FreeSync Minimum refresh rate (Hz) */
+		infopacket->sb[7] = (unsigned char)((vrr->min_refresh_in_uhz + 500000) / 1000000);
+		/* PB8 = FreeSync Maximum refresh rate (Hz) */
+		infopacket->sb[8] = (unsigned char)((vrr->max_refresh_in_uhz + 500000) / 1000000);
+	} else {
+		// Non-fs case, program nominal range
+		/* PB7 = FreeSync Minimum refresh rate (Hz) */
+		infopacket->sb[7] = (unsigned char)((vrr->max_refresh_in_uhz + 500000) / 1000000);
+		/* PB8 = FreeSync Maximum refresh rate (Hz) */
+		infopacket->sb[8] = (unsigned char)((vrr->max_refresh_in_uhz + 500000) / 1000000);
+	}
 
 	//FreeSync HDR
 	infopacket->sb[9] = 0;
@@ -678,7 +738,7 @@ static void build_vrr_infopacket_v1(enum signal_type signal,
 	unsigned int payload_size = 0;
 
 	build_vrr_infopacket_header_v1(signal, infopacket, &payload_size);
-	build_vrr_infopacket_data(vrr, infopacket);
+	build_vrr_infopacket_data_v1(vrr, infopacket);
 	build_vrr_infopacket_checksum(&payload_size, infopacket);
 
 	infopacket->valid = true;
@@ -692,7 +752,24 @@ static void build_vrr_infopacket_v2(enum signal_type signal,
 	unsigned int payload_size = 0;
 
 	build_vrr_infopacket_header_v2(signal, infopacket, &payload_size);
-	build_vrr_infopacket_data(vrr, infopacket);
+	build_vrr_infopacket_data_v1(vrr, infopacket);
+
+	build_vrr_infopacket_fs2_data(app_tf, infopacket);
+
+	build_vrr_infopacket_checksum(&payload_size, infopacket);
+
+	infopacket->valid = true;
+}
+
+static void build_vrr_infopacket_v3(enum signal_type signal,
+		const struct mod_vrr_params *vrr,
+		enum color_transfer_func app_tf,
+		struct dc_info_packet *infopacket)
+{
+	unsigned int payload_size = 0;
+
+	build_vrr_infopacket_header_v2(signal, infopacket, &payload_size);
+	build_vrr_infopacket_data_v3(vrr, infopacket);
 
 	build_vrr_infopacket_fs2_data(app_tf, infopacket);
 
@@ -717,11 +794,14 @@ void mod_freesync_build_vrr_infopacket(struct mod_freesync *mod_freesync,
 		return;
 
 	switch (packet_type) {
-	case PACKET_TYPE_FS2:
+	case PACKET_TYPE_FS_V3:
+		build_vrr_infopacket_v3(stream->signal, vrr, app_tf, infopacket);
+		break;
+	case PACKET_TYPE_FS_V2:
 		build_vrr_infopacket_v2(stream->signal, vrr, app_tf, infopacket);
 		break;
 	case PACKET_TYPE_VRR:
-	case PACKET_TYPE_FS1:
+	case PACKET_TYPE_FS_V1:
 	default:
 		build_vrr_infopacket_v1(stream->signal, vrr, infopacket);
 	}
@@ -793,6 +873,11 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 				calc_duration_in_us_from_refresh_in_uhz(
 						(unsigned int)max_refresh_in_uhz);
 
+		if (in_config->state == VRR_STATE_ACTIVE_FIXED)
+			in_out_vrr->fixed_refresh_in_uhz = in_config->fixed_refresh_in_uhz;
+		else
+			in_out_vrr->fixed_refresh_in_uhz = 0;
+
 		refresh_range = in_out_vrr->max_refresh_in_uhz -
 				in_out_vrr->min_refresh_in_uhz;
 
@@ -843,7 +928,7 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 				in_out_vrr->min_refresh_in_uhz);
 	} else if (in_out_vrr->state == VRR_STATE_ACTIVE_FIXED) {
 		in_out_vrr->fixed.target_refresh_in_uhz =
-				in_out_vrr->min_refresh_in_uhz;
+				in_out_vrr->fixed_refresh_in_uhz;
 		if (in_out_vrr->fixed.ramping_active &&
 				in_out_vrr->fixed.fixed_active) {
 			/* Do not update vtotals if ramping is already active

commit 5a6b5458699d8e6fdb5ae09d950935a48b79f8c7
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Wed Mar 11 18:10:20 2020 -0400

    drm/amd/display: LFC not working on 2.0x range monitors (v2)
    
    [Why]
    Nominal pixel clock and EDID information differ in precision so although
    monitor reports maximum refresh is 2x minimum, LFC was not being
    enabled.
    
    [How]
    Use minimum refresh rate as nominal/2 when EDID dictates that min
    refresh = max refresh/2.
    
    v2: squash in 64 bit divide fix
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 4e542826cd26..c33454a9e0b4 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -734,6 +734,7 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 {
 	struct core_freesync *core_freesync = NULL;
 	unsigned long long nominal_field_rate_in_uhz = 0;
+	unsigned long long rounded_nominal_in_uhz = 0;
 	unsigned int refresh_range = 0;
 	unsigned long long min_refresh_in_uhz = 0;
 	unsigned long long max_refresh_in_uhz = 0;
@@ -750,17 +751,20 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 	min_refresh_in_uhz = in_config->min_refresh_in_uhz;
 	max_refresh_in_uhz = in_config->max_refresh_in_uhz;
 
-	// Don't allow min > max
-	if (min_refresh_in_uhz > max_refresh_in_uhz)
-		min_refresh_in_uhz = max_refresh_in_uhz;
-
 	// Full range may be larger than current video timing, so cap at nominal
 	if (max_refresh_in_uhz > nominal_field_rate_in_uhz)
 		max_refresh_in_uhz = nominal_field_rate_in_uhz;
 
 	// Full range may be larger than current video timing, so cap at nominal
-	if (min_refresh_in_uhz > nominal_field_rate_in_uhz)
-		min_refresh_in_uhz = nominal_field_rate_in_uhz;
+	if (min_refresh_in_uhz > max_refresh_in_uhz)
+		min_refresh_in_uhz = max_refresh_in_uhz;
+
+	// If a monitor reports exactly max refresh of 2x of min, enforce it on nominal
+	rounded_nominal_in_uhz =
+			div_u64(nominal_field_rate_in_uhz + 50000, 100000) * 100000;
+	if (in_config->max_refresh_in_uhz == (2 * in_config->min_refresh_in_uhz) &&
+		in_config->max_refresh_in_uhz == rounded_nominal_in_uhz)
+		min_refresh_in_uhz = div_u64(nominal_field_rate_in_uhz, 2);
 
 	if (!vrr_settings_require_update(core_freesync,
 			in_config, (unsigned int)min_refresh_in_uhz, (unsigned int)max_refresh_in_uhz,
@@ -792,11 +796,6 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 		refresh_range = in_out_vrr->max_refresh_in_uhz -
 				in_out_vrr->min_refresh_in_uhz;
 
-		in_out_vrr->btr.margin_in_us = in_out_vrr->max_duration_in_us -
-				2 * in_out_vrr->min_duration_in_us;
-		if (in_out_vrr->btr.margin_in_us > BTR_MAX_MARGIN)
-			in_out_vrr->btr.margin_in_us = BTR_MAX_MARGIN;
-
 		in_out_vrr->supported = true;
 	}
 
@@ -804,9 +803,14 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 
 	in_out_vrr->btr.btr_enabled = in_config->btr;
 
-	if (in_out_vrr->max_refresh_in_uhz <
-			2 * in_out_vrr->min_refresh_in_uhz)
+	if (in_out_vrr->max_refresh_in_uhz < (2 * in_out_vrr->min_refresh_in_uhz))
 		in_out_vrr->btr.btr_enabled = false;
+	else {
+		in_out_vrr->btr.margin_in_us = in_out_vrr->max_duration_in_us -
+				2 * in_out_vrr->min_duration_in_us;
+		if (in_out_vrr->btr.margin_in_us > BTR_MAX_MARGIN)
+			in_out_vrr->btr.margin_in_us = BTR_MAX_MARGIN;
+	}
 
 	in_out_vrr->btr.btr_active = false;
 	in_out_vrr->btr.inserted_duration_in_us = 0;
@@ -1008,8 +1012,8 @@ unsigned long long mod_freesync_calc_nominal_field_rate(
 	unsigned int total = stream->timing.h_total * stream->timing.v_total;
 
 	/* Calculate nominal field rate for stream, rounded up to nearest integer */
-	nominal_field_rate_in_uhz = stream->timing.pix_clk_100hz / 10;
-	nominal_field_rate_in_uhz *= 1000ULL * 1000ULL * 1000ULL;
+	nominal_field_rate_in_uhz = stream->timing.pix_clk_100hz;
+	nominal_field_rate_in_uhz *= 100000000ULL;
 
 	nominal_field_rate_in_uhz =	div_u64(nominal_field_rate_in_uhz, total);
 

commit 3fc6376ed6f2f67bc9fb0c7a3cf07967d6aa6216
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Sun Feb 9 12:31:25 2020 -0500

    drm/amd/display: Only round InfoFrame refresh rates
    
    [Why]
    When calculating nominal refresh rates, don't round.
    Only the VSIF needs to be rounded.
    
    [How]
    Revert rounding change for nominal and just round when forming the
    FreeSync VSIF.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index b9992ebf77a6..4e542826cd26 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -524,12 +524,12 @@ static void build_vrr_infopacket_data(const struct mod_vrr_params *vrr,
 		infopacket->sb[6] |= 0x04;
 
 	/* PB7 = FreeSync Minimum refresh rate (Hz) */
-	infopacket->sb[7] = (unsigned char)(vrr->min_refresh_in_uhz / 1000000);
+	infopacket->sb[7] = (unsigned char)((vrr->min_refresh_in_uhz + 500000) / 1000000);
 
 	/* PB8 = FreeSync Maximum refresh rate (Hz)
 	 * Note: We should never go above the field rate of the mode timing set.
 	 */
-	infopacket->sb[8] = (unsigned char)(vrr->max_refresh_in_uhz / 1000000);
+	infopacket->sb[8] = (unsigned char)((vrr->max_refresh_in_uhz + 500000) / 1000000);
 
 
 	//FreeSync HDR
@@ -747,10 +747,6 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 	nominal_field_rate_in_uhz =
 			mod_freesync_calc_nominal_field_rate(stream);
 
-	/* Rounded to the nearest Hz */
-	nominal_field_rate_in_uhz = 1000000ULL *
-			div_u64(nominal_field_rate_in_uhz + 500000, 1000000);
-
 	min_refresh_in_uhz = in_config->min_refresh_in_uhz;
 	max_refresh_in_uhz = in_config->max_refresh_in_uhz;
 

commit 5ea3985098048ba6850547c816208e5c2a40bef4
Author: Haiyi Zhou <haiyi.zhou@amd.com>
Date:   Thu Jan 9 11:08:33 2020 -0500

    drm/amd/display: Fixed comment styling
    
    Switched to C-style comments for consistency
    
    Signed-off-by: Haiyi Zhou <haiyi.zhou@amd.com>
    Reviewed-by: Reza Amini <Reza.Amini@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 6e5ecefe7d9d..b9992ebf77a6 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -381,7 +381,7 @@ static void apply_fixed_refresh(struct core_freesync *core_freesync,
 	bool update = false;
 	unsigned int max_render_time_in_us = in_out_vrr->max_duration_in_us;
 
-	//Compute the exit refresh rate and exit frame duration
+	/* Compute the exit refresh rate and exit frame duration */
 	unsigned int exit_refresh_rate_in_milli_hz = ((1000000000/max_render_time_in_us)
 			+ (1000*FIXED_REFRESH_EXIT_MARGIN_IN_HZ));
 	unsigned int exit_frame_duration_in_us = 1000000000/exit_refresh_rate_in_milli_hz;

commit 1075735ecce96b34ba9aee529dd2253da6d21ceb
Author: Alvin Lee <alvin.lee2@amd.com>
Date:   Thu Dec 5 17:12:17 2019 -0500

    drm/amd/display: Fix 300Hz Freesync bug
    
    Needed to reprogram vblank_start in dml properly in order to get the
    correct dlg params to program VTG.
    
    Signed-off-by: Alvin Lee <alvin.lee2@amd.com>
    Reviewed-by: Martin Leung <Martin.Leung@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 832bc9b3b7d8..6e5ecefe7d9d 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -812,11 +812,12 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 			2 * in_out_vrr->min_refresh_in_uhz)
 		in_out_vrr->btr.btr_enabled = false;
 
-	in_out_vrr->fixed.fixed_active = false;
 	in_out_vrr->btr.btr_active = false;
 	in_out_vrr->btr.inserted_duration_in_us = 0;
 	in_out_vrr->btr.frames_to_insert = 0;
 	in_out_vrr->btr.frame_counter = 0;
+	in_out_vrr->fixed.fixed_active = false;
+	in_out_vrr->fixed.target_refresh_in_uhz = 0;
 
 	in_out_vrr->btr.mid_point_in_us =
 				(in_out_vrr->min_duration_in_us +

commit 6f8f76444baf405bacb0591d97549a71a9aaa1ac
Author: Amanda Liu <amanda.liu@amd.com>
Date:   Fri Dec 6 15:12:30 2019 -0500

    drm/amd/display: Clear state after exiting fixed active VRR state
    
    [why]
    Upon exiting a fixed active VRR state, the state isn't cleared. This
    leads to the variable VRR range to be calculated incorrectly.
    
    [how]
    Set fixed active state to false when updating vrr params
    
    Signed-off-by: Amanda Liu <amanda.liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index fa57885503d4..832bc9b3b7d8 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -812,6 +812,7 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 			2 * in_out_vrr->min_refresh_in_uhz)
 		in_out_vrr->btr.btr_enabled = false;
 
+	in_out_vrr->fixed.fixed_active = false;
 	in_out_vrr->btr.btr_active = false;
 	in_out_vrr->btr.inserted_duration_in_us = 0;
 	in_out_vrr->btr.frames_to_insert = 0;
@@ -832,6 +833,7 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 		in_out_vrr->adjust.v_total_max = stream->timing.v_total;
 	} else if (in_out_vrr->state == VRR_STATE_ACTIVE_VARIABLE &&
 			refresh_range >= MIN_REFRESH_RANGE_IN_US) {
+
 		in_out_vrr->adjust.v_total_min =
 			calc_v_total_from_refresh(stream,
 				in_out_vrr->max_refresh_in_uhz);

commit ded6119e825aaf0bfc7f2a578b549d610da852a7
Author: Amanda Liu <amanda.liu@amd.com>
Date:   Thu Nov 21 16:06:57 2019 -0500

    drm/amd/display: Reinstate LFC optimization
    
    [why]
    We want to streamline the calculations made when entering LFC.
    Previously, the optimizations led to screen tearing and were backed out
    to unblock development.
    
    [how]
    Integrate other calculations parameters, as well as screen tearing,
    fixes with the original LFC calculation optimizations.
    
    Signed-off-by: Amanda Liu <amanda.liu@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index a94700940fd6..fa57885503d4 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -37,8 +37,8 @@
 #define STATIC_SCREEN_RAMP_DELTA_REFRESH_RATE_PER_FRAME ((1000 / 60) * 65)
 /* Number of elements in the render times cache array */
 #define RENDER_TIMES_MAX_COUNT 10
-/* Threshold to exit BTR (to avoid frequent enter-exits at the lower limit) */
-#define BTR_EXIT_MARGIN 2000
+/* Threshold to exit/exit BTR (to avoid frequent enter-exits at the lower limit) */
+#define BTR_MAX_MARGIN 2500
 /* Threshold to change BTR multiplier (to avoid frequent changes) */
 #define BTR_DRIFT_MARGIN 2000
 /*Threshold to exit fixed refresh rate*/
@@ -254,24 +254,22 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 	unsigned int delta_from_mid_point_in_us_1 = 0xFFFFFFFF;
 	unsigned int delta_from_mid_point_in_us_2 = 0xFFFFFFFF;
 	unsigned int frames_to_insert = 0;
-	unsigned int min_frame_duration_in_ns = 0;
-	unsigned int max_render_time_in_us = in_out_vrr->max_duration_in_us;
 	unsigned int delta_from_mid_point_delta_in_us;
-
-	min_frame_duration_in_ns = ((unsigned int) (div64_u64(
-		(1000000000ULL * 1000000),
-		in_out_vrr->max_refresh_in_uhz)));
+	unsigned int max_render_time_in_us =
+			in_out_vrr->max_duration_in_us - in_out_vrr->btr.margin_in_us;
 
 	/* Program BTR */
-	if (last_render_time_in_us + BTR_EXIT_MARGIN < max_render_time_in_us) {
+	if ((last_render_time_in_us + in_out_vrr->btr.margin_in_us / 2) < max_render_time_in_us) {
 		/* Exit Below the Range */
 		if (in_out_vrr->btr.btr_active) {
 			in_out_vrr->btr.frame_counter = 0;
 			in_out_vrr->btr.btr_active = false;
 		}
-	} else if (last_render_time_in_us > max_render_time_in_us) {
+	} else if (last_render_time_in_us > (max_render_time_in_us + in_out_vrr->btr.margin_in_us / 2)) {
 		/* Enter Below the Range */
-		in_out_vrr->btr.btr_active = true;
+		if (!in_out_vrr->btr.btr_active) {
+			in_out_vrr->btr.btr_active = true;
+		}
 	}
 
 	/* BTR set to "not active" so disengage */
@@ -327,7 +325,9 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 		/* Choose number of frames to insert based on how close it
 		 * can get to the mid point of the variable range.
 		 */
-		if (delta_from_mid_point_in_us_1 < delta_from_mid_point_in_us_2) {
+		if ((frame_time_in_us / mid_point_frames_ceil) > in_out_vrr->min_duration_in_us &&
+				(delta_from_mid_point_in_us_1 < delta_from_mid_point_in_us_2 ||
+						mid_point_frames_floor < 2)) {
 			frames_to_insert = mid_point_frames_ceil;
 			delta_from_mid_point_delta_in_us = delta_from_mid_point_in_us_2 -
 					delta_from_mid_point_in_us_1;
@@ -343,7 +343,7 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 		if (in_out_vrr->btr.frames_to_insert != 0 &&
 				delta_from_mid_point_delta_in_us < BTR_DRIFT_MARGIN) {
 			if (((last_render_time_in_us / in_out_vrr->btr.frames_to_insert) <
-					in_out_vrr->max_duration_in_us) &&
+					max_render_time_in_us) &&
 				((last_render_time_in_us / in_out_vrr->btr.frames_to_insert) >
 					in_out_vrr->min_duration_in_us))
 				frames_to_insert = in_out_vrr->btr.frames_to_insert;
@@ -796,6 +796,11 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 		refresh_range = in_out_vrr->max_refresh_in_uhz -
 				in_out_vrr->min_refresh_in_uhz;
 
+		in_out_vrr->btr.margin_in_us = in_out_vrr->max_duration_in_us -
+				2 * in_out_vrr->min_duration_in_us;
+		if (in_out_vrr->btr.margin_in_us > BTR_MAX_MARGIN)
+			in_out_vrr->btr.margin_in_us = BTR_MAX_MARGIN;
+
 		in_out_vrr->supported = true;
 	}
 
@@ -811,6 +816,7 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 	in_out_vrr->btr.inserted_duration_in_us = 0;
 	in_out_vrr->btr.frames_to_insert = 0;
 	in_out_vrr->btr.frame_counter = 0;
+
 	in_out_vrr->btr.mid_point_in_us =
 				(in_out_vrr->min_duration_in_us +
 				 in_out_vrr->max_duration_in_us) / 2;

commit 00853a4f7dd52e4529f681a685073f1533e1ed19
Author: Amanda Liu <amanda.liu@amd.com>
Date:   Fri Nov 15 17:07:27 2019 -0500

    drm/amd/display: Fix screen tearing on vrr tests
    
    [Why]
    Screen tearing is present in tests when setting the frame rate to
    certain fps
    
    [How]
    Revert previous optimizations for low frame rates.
    
    Signed-off-by: Amanda Liu <amanda.liu@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index fa57885503d4..a94700940fd6 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -37,8 +37,8 @@
 #define STATIC_SCREEN_RAMP_DELTA_REFRESH_RATE_PER_FRAME ((1000 / 60) * 65)
 /* Number of elements in the render times cache array */
 #define RENDER_TIMES_MAX_COUNT 10
-/* Threshold to exit/exit BTR (to avoid frequent enter-exits at the lower limit) */
-#define BTR_MAX_MARGIN 2500
+/* Threshold to exit BTR (to avoid frequent enter-exits at the lower limit) */
+#define BTR_EXIT_MARGIN 2000
 /* Threshold to change BTR multiplier (to avoid frequent changes) */
 #define BTR_DRIFT_MARGIN 2000
 /*Threshold to exit fixed refresh rate*/
@@ -254,22 +254,24 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 	unsigned int delta_from_mid_point_in_us_1 = 0xFFFFFFFF;
 	unsigned int delta_from_mid_point_in_us_2 = 0xFFFFFFFF;
 	unsigned int frames_to_insert = 0;
+	unsigned int min_frame_duration_in_ns = 0;
+	unsigned int max_render_time_in_us = in_out_vrr->max_duration_in_us;
 	unsigned int delta_from_mid_point_delta_in_us;
-	unsigned int max_render_time_in_us =
-			in_out_vrr->max_duration_in_us - in_out_vrr->btr.margin_in_us;
+
+	min_frame_duration_in_ns = ((unsigned int) (div64_u64(
+		(1000000000ULL * 1000000),
+		in_out_vrr->max_refresh_in_uhz)));
 
 	/* Program BTR */
-	if ((last_render_time_in_us + in_out_vrr->btr.margin_in_us / 2) < max_render_time_in_us) {
+	if (last_render_time_in_us + BTR_EXIT_MARGIN < max_render_time_in_us) {
 		/* Exit Below the Range */
 		if (in_out_vrr->btr.btr_active) {
 			in_out_vrr->btr.frame_counter = 0;
 			in_out_vrr->btr.btr_active = false;
 		}
-	} else if (last_render_time_in_us > (max_render_time_in_us + in_out_vrr->btr.margin_in_us / 2)) {
+	} else if (last_render_time_in_us > max_render_time_in_us) {
 		/* Enter Below the Range */
-		if (!in_out_vrr->btr.btr_active) {
-			in_out_vrr->btr.btr_active = true;
-		}
+		in_out_vrr->btr.btr_active = true;
 	}
 
 	/* BTR set to "not active" so disengage */
@@ -325,9 +327,7 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 		/* Choose number of frames to insert based on how close it
 		 * can get to the mid point of the variable range.
 		 */
-		if ((frame_time_in_us / mid_point_frames_ceil) > in_out_vrr->min_duration_in_us &&
-				(delta_from_mid_point_in_us_1 < delta_from_mid_point_in_us_2 ||
-						mid_point_frames_floor < 2)) {
+		if (delta_from_mid_point_in_us_1 < delta_from_mid_point_in_us_2) {
 			frames_to_insert = mid_point_frames_ceil;
 			delta_from_mid_point_delta_in_us = delta_from_mid_point_in_us_2 -
 					delta_from_mid_point_in_us_1;
@@ -343,7 +343,7 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 		if (in_out_vrr->btr.frames_to_insert != 0 &&
 				delta_from_mid_point_delta_in_us < BTR_DRIFT_MARGIN) {
 			if (((last_render_time_in_us / in_out_vrr->btr.frames_to_insert) <
-					max_render_time_in_us) &&
+					in_out_vrr->max_duration_in_us) &&
 				((last_render_time_in_us / in_out_vrr->btr.frames_to_insert) >
 					in_out_vrr->min_duration_in_us))
 				frames_to_insert = in_out_vrr->btr.frames_to_insert;
@@ -796,11 +796,6 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 		refresh_range = in_out_vrr->max_refresh_in_uhz -
 				in_out_vrr->min_refresh_in_uhz;
 
-		in_out_vrr->btr.margin_in_us = in_out_vrr->max_duration_in_us -
-				2 * in_out_vrr->min_duration_in_us;
-		if (in_out_vrr->btr.margin_in_us > BTR_MAX_MARGIN)
-			in_out_vrr->btr.margin_in_us = BTR_MAX_MARGIN;
-
 		in_out_vrr->supported = true;
 	}
 
@@ -816,7 +811,6 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 	in_out_vrr->btr.inserted_duration_in_us = 0;
 	in_out_vrr->btr.frames_to_insert = 0;
 	in_out_vrr->btr.frame_counter = 0;
-
 	in_out_vrr->btr.mid_point_in_us =
 				(in_out_vrr->min_duration_in_us +
 				 in_out_vrr->max_duration_in_us) / 2;

commit a501e22c8e36934b2d901b039b1c59c948886c90
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Dec 2 15:47:38 2019 +0000

    drm/amd/display: remove redundant assignment to variable v_total
    
    The variable v_total is being initialized with a value that is never
    read and it is being updated later with a new value.  The initialization
    is redundant and can be removed.
    
    Addresses-Coverity: ("Unused value")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 16e69bbc69aa..fa57885503d4 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -122,7 +122,7 @@ static unsigned int calc_v_total_from_refresh(
 		const struct dc_stream_state *stream,
 		unsigned int refresh_in_uhz)
 {
-	unsigned int v_total = stream->timing.v_total;
+	unsigned int v_total;
 	unsigned int frame_duration_in_ns;
 
 	frame_duration_in_ns =

commit 8396745da8f059048f6b01222c933e8ca4ea0597
Author: Jaehyun Chung <jaehyun.chung@amd.com>
Date:   Mon Sep 23 10:00:57 2019 -0400

    drm/amd/display: Add capability check for static ramp calc
    
    [Why]
    Static ramp to max refresh rate does not have capability check on
    calculated v_total. Programming a lower v_total_min and max than the
    total causes continuous spurious HPDs.
    
    [How]
    Add a capability check after v_total calculation similar to calculate
    v_total helper functions.
    
    Signed-off-by: Jaehyun Chung <jaehyun.chung@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index ee89bd2f7fe4..16e69bbc69aa 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -234,6 +234,10 @@ static void update_v_total_for_static_ramp(
 			current_duration_in_us) * (stream->timing.pix_clk_100hz / 10)),
 				stream->timing.h_total), 1000);
 
+	/* v_total cannot be less than nominal */
+	if (v_total < stream->timing.v_total)
+		v_total = stream->timing.v_total;
+
 	in_out_vrr->adjust.v_total_min = v_total;
 	in_out_vrr->adjust.v_total_max = v_total;
 }

commit c59802313e84bede954235b3a5dd0dd5325f49c5
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Wed Sep 11 16:17:08 2019 -0400

    drm/amd/display: Properly round nominal frequency for SPD
    
    [Why]
    Some displays rely on the SPD verticle frequency maximum value.
    Must round the calculated refresh rate to the nearest integer.
    
    [How]
    Round the nominal calculated refresh rate to the nearest whole
    integer.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 237dda751380..ee89bd2f7fe4 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -743,6 +743,10 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 	nominal_field_rate_in_uhz =
 			mod_freesync_calc_nominal_field_rate(stream);
 
+	/* Rounded to the nearest Hz */
+	nominal_field_rate_in_uhz = 1000000ULL *
+			div_u64(nominal_field_rate_in_uhz + 500000, 1000000);
+
 	min_refresh_in_uhz = in_config->min_refresh_in_uhz;
 	max_refresh_in_uhz = in_config->max_refresh_in_uhz;
 
@@ -998,14 +1002,13 @@ unsigned long long mod_freesync_calc_nominal_field_rate(
 			const struct dc_stream_state *stream)
 {
 	unsigned long long nominal_field_rate_in_uhz = 0;
+	unsigned int total = stream->timing.h_total * stream->timing.v_total;
 
-	/* Calculate nominal field rate for stream */
+	/* Calculate nominal field rate for stream, rounded up to nearest integer */
 	nominal_field_rate_in_uhz = stream->timing.pix_clk_100hz / 10;
 	nominal_field_rate_in_uhz *= 1000ULL * 1000ULL * 1000ULL;
-	nominal_field_rate_in_uhz = div_u64(nominal_field_rate_in_uhz,
-						stream->timing.h_total);
-	nominal_field_rate_in_uhz = div_u64(nominal_field_rate_in_uhz,
-						stream->timing.v_total);
+
+	nominal_field_rate_in_uhz =	div_u64(nominal_field_rate_in_uhz, total);
 
 	return nominal_field_rate_in_uhz;
 }

commit 72caac6b62c291a095948a80995b9c40c3956796
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Sun Oct 6 18:57:35 2019 +0800

    drm/amd/display: remove set but not used variable 'core_freesync'
    
    Fixes gcc '-Wunused-but-set-variable' warning:
    
    rivers/gpu/drm/amd/amdgpu/../display/modules/freesync/freesync.c:
     In function mod_freesync_get_settings:
    drivers/gpu/drm/amd/amdgpu/../display/modules/freesync/freesync.c:984:24:
     warning: variable core_freesync set but not used [-Wunused-but-set-variable]
    
    It is not used since commit 98e6436d3af5 ("drm/amd/display: Refactor FreeSync module")
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 9ce56a8f027d..237dda751380 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -981,13 +981,9 @@ void mod_freesync_get_settings(struct mod_freesync *mod_freesync,
 		unsigned int *inserted_frames,
 		unsigned int *inserted_duration_in_us)
 {
-	struct core_freesync *core_freesync = NULL;
-
 	if (mod_freesync == NULL)
 		return;
 
-	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-
 	if (vrr->supported) {
 		*v_total_min = vrr->adjust.v_total_min;
 		*v_total_max = vrr->adjust.v_total_max;

commit bb2746ac9143fe57adab57c30d19718dbaed7901
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Tue Sep 3 18:18:08 2019 -0400

    drm/amd/display: Improve LFC behaviour
    
    [Why]
    There can be some unsynchronized frames when entering/exiting
    LFC.  This may cause tearing or stuttering at such transitions.
    
    [How]
    Add a enter/exit margin to algorithm to smoothly transition into
    and out of LFC without desynchronizing frames.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Reza Amini <Reza.Amini@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Sivapiriyan Kumarasamy <Sivapiriyan.Kumarasamy@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index ec70c9b12e1a..9ce56a8f027d 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -37,8 +37,8 @@
 #define STATIC_SCREEN_RAMP_DELTA_REFRESH_RATE_PER_FRAME ((1000 / 60) * 65)
 /* Number of elements in the render times cache array */
 #define RENDER_TIMES_MAX_COUNT 10
-/* Threshold to exit BTR (to avoid frequent enter-exits at the lower limit) */
-#define BTR_EXIT_MARGIN 2000
+/* Threshold to exit/exit BTR (to avoid frequent enter-exits at the lower limit) */
+#define BTR_MAX_MARGIN 2500
 /* Threshold to change BTR multiplier (to avoid frequent changes) */
 #define BTR_DRIFT_MARGIN 2000
 /*Threshold to exit fixed refresh rate*/
@@ -250,24 +250,22 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 	unsigned int delta_from_mid_point_in_us_1 = 0xFFFFFFFF;
 	unsigned int delta_from_mid_point_in_us_2 = 0xFFFFFFFF;
 	unsigned int frames_to_insert = 0;
-	unsigned int min_frame_duration_in_ns = 0;
-	unsigned int max_render_time_in_us = in_out_vrr->max_duration_in_us;
 	unsigned int delta_from_mid_point_delta_in_us;
-
-	min_frame_duration_in_ns = ((unsigned int) (div64_u64(
-		(1000000000ULL * 1000000),
-		in_out_vrr->max_refresh_in_uhz)));
+	unsigned int max_render_time_in_us =
+			in_out_vrr->max_duration_in_us - in_out_vrr->btr.margin_in_us;
 
 	/* Program BTR */
-	if (last_render_time_in_us + BTR_EXIT_MARGIN < max_render_time_in_us) {
+	if ((last_render_time_in_us + in_out_vrr->btr.margin_in_us / 2) < max_render_time_in_us) {
 		/* Exit Below the Range */
 		if (in_out_vrr->btr.btr_active) {
 			in_out_vrr->btr.frame_counter = 0;
 			in_out_vrr->btr.btr_active = false;
 		}
-	} else if (last_render_time_in_us > max_render_time_in_us) {
+	} else if (last_render_time_in_us > (max_render_time_in_us + in_out_vrr->btr.margin_in_us / 2)) {
 		/* Enter Below the Range */
-		in_out_vrr->btr.btr_active = true;
+		if (!in_out_vrr->btr.btr_active) {
+			in_out_vrr->btr.btr_active = true;
+		}
 	}
 
 	/* BTR set to "not active" so disengage */
@@ -323,7 +321,9 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 		/* Choose number of frames to insert based on how close it
 		 * can get to the mid point of the variable range.
 		 */
-		if (delta_from_mid_point_in_us_1 < delta_from_mid_point_in_us_2) {
+		if ((frame_time_in_us / mid_point_frames_ceil) > in_out_vrr->min_duration_in_us &&
+				(delta_from_mid_point_in_us_1 < delta_from_mid_point_in_us_2 ||
+						mid_point_frames_floor < 2)) {
 			frames_to_insert = mid_point_frames_ceil;
 			delta_from_mid_point_delta_in_us = delta_from_mid_point_in_us_2 -
 					delta_from_mid_point_in_us_1;
@@ -339,7 +339,7 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 		if (in_out_vrr->btr.frames_to_insert != 0 &&
 				delta_from_mid_point_delta_in_us < BTR_DRIFT_MARGIN) {
 			if (((last_render_time_in_us / in_out_vrr->btr.frames_to_insert) <
-					in_out_vrr->max_duration_in_us) &&
+					max_render_time_in_us) &&
 				((last_render_time_in_us / in_out_vrr->btr.frames_to_insert) >
 					in_out_vrr->min_duration_in_us))
 				frames_to_insert = in_out_vrr->btr.frames_to_insert;
@@ -788,6 +788,11 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 		refresh_range = in_out_vrr->max_refresh_in_uhz -
 				in_out_vrr->min_refresh_in_uhz;
 
+		in_out_vrr->btr.margin_in_us = in_out_vrr->max_duration_in_us -
+				2 * in_out_vrr->min_duration_in_us;
+		if (in_out_vrr->btr.margin_in_us > BTR_MAX_MARGIN)
+			in_out_vrr->btr.margin_in_us = BTR_MAX_MARGIN;
+
 		in_out_vrr->supported = true;
 	}
 
@@ -803,6 +808,7 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 	in_out_vrr->btr.inserted_duration_in_us = 0;
 	in_out_vrr->btr.frames_to_insert = 0;
 	in_out_vrr->btr.frame_counter = 0;
+
 	in_out_vrr->btr.mid_point_in_us =
 				(in_out_vrr->min_duration_in_us +
 				 in_out_vrr->max_duration_in_us) / 2;

commit a9f54ce3c6032361d2b69910114b6e8baf9bdf49
Author: Ahmad Othman <ahmad.othman@amd.com>
Date:   Thu Aug 1 15:05:27 2019 -0400

    drm/amd/display: Refactoring VTEM
    
    [Why]
    Video Timing Extended Metadata packet (VTEM) is not
    specific to freesync. So move it out of freesync module
    
    [How]
    - Moved VTEM from freesync module to info_packet module
    - Created new structure for VTEM parameters that can be used for VRR
    and FVA
    
    Signed-off-by: Ahmad Othman <ahmad.othman@amd.com>
    Reviewed-by: Chris Park <Chris.Park@amd.com>
    Acked-by: Ahmad Othman <Ahmad.Othman@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index a53666ff6cf8..ec70c9b12e1a 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -52,93 +52,6 @@ struct core_freesync {
 	struct dc *dc;
 };
 
-void setFieldWithMask(unsigned char *dest, unsigned int mask, unsigned int value)
-{
-	unsigned int shift = 0;
-
-	if (!mask || !dest)
-		return;
-
-	while (!((mask >> shift) & 1))
-		shift++;
-
-	//reset
-	*dest = *dest & ~mask;
-	//set
-	//dont let value span past mask
-	value = value & (mask >> shift);
-	//insert value
-	*dest = *dest | (value << shift);
-}
-
-// VTEM Byte Offset
-#define VRR_VTEM_PB0		0
-#define VRR_VTEM_PB1		1
-#define VRR_VTEM_PB2		2
-#define VRR_VTEM_PB3		3
-#define VRR_VTEM_PB4		4
-#define VRR_VTEM_PB5		5
-#define VRR_VTEM_PB6		6
-
-#define VRR_VTEM_MD0		7
-#define VRR_VTEM_MD1		8
-#define VRR_VTEM_MD2		9
-#define VRR_VTEM_MD3		10
-
-
-// VTEM Byte Masks
-//PB0
-#define MASK__VRR_VTEM_PB0__RESERVED0  0x01
-#define MASK__VRR_VTEM_PB0__SYNC       0x02
-#define MASK__VRR_VTEM_PB0__VFR        0x04
-#define MASK__VRR_VTEM_PB0__AFR        0x08
-#define MASK__VRR_VTEM_PB0__DS_TYPE    0x30
-	//0: Periodic pseudo-static EM Data Set
-	//1: Periodic dynamic EM Data Set
-	//2: Unique EM Data Set
-	//3: Reserved
-#define MASK__VRR_VTEM_PB0__END        0x40
-#define MASK__VRR_VTEM_PB0__NEW        0x80
-
-//PB1
-#define MASK__VRR_VTEM_PB1__RESERVED1 0xFF
-
-//PB2
-#define MASK__VRR_VTEM_PB2__ORGANIZATION_ID 0xFF
-	//0: This is a Vendor Specific EM Data Set
-	//1: This EM Data Set is defined by This Specification (HDMI 2.1 r102.clean)
-	//2: This EM Data Set is defined by CTA-861-G
-	//3: This EM Data Set is defined by VESA
-//PB3
-#define MASK__VRR_VTEM_PB3__DATA_SET_TAG_MSB    0xFF
-//PB4
-#define MASK__VRR_VTEM_PB4__DATA_SET_TAG_LSB    0xFF
-//PB5
-#define MASK__VRR_VTEM_PB5__DATA_SET_LENGTH_MSB 0xFF
-//PB6
-#define MASK__VRR_VTEM_PB6__DATA_SET_LENGTH_LSB 0xFF
-
-
-
-//PB7-27 (20 bytes):
-//PB7 = MD0
-#define MASK__VRR_VTEM_MD0__VRR_EN         0x01
-#define MASK__VRR_VTEM_MD0__M_CONST        0x02
-#define MASK__VRR_VTEM_MD0__RESERVED2      0x0C
-#define MASK__VRR_VTEM_MD0__FVA_FACTOR_M1  0xF0
-
-//MD1
-#define MASK__VRR_VTEM_MD1__BASE_VFRONT    0xFF
-
-//MD2
-#define MASK__VRR_VTEM_MD2__BASE_REFRESH_RATE_98  0x03
-#define MASK__VRR_VTEM_MD2__RB                    0x04
-#define MASK__VRR_VTEM_MD2__RESERVED3             0xF8
-
-//MD3
-#define MASK__VRR_VTEM_MD3__BASE_REFRESH_RATE_07  0xFF
-
-
 #define MOD_FREESYNC_TO_CORE(mod_freesync)\
 		container_of(mod_freesync, struct core_freesync, public)
 
@@ -574,22 +487,64 @@ bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
 	return false;
 }
 
-static void build_vrr_infopacket_header_vtem(enum signal_type signal,
+static void build_vrr_infopacket_data(const struct mod_vrr_params *vrr,
 		struct dc_info_packet *infopacket)
 {
-	// HEADER
-
-	// HB0, HB1, HB2 indicates PacketType VTEMPacket
-	infopacket->hb0 = 0x7F;
-	infopacket->hb1 = 0xC0;
-	infopacket->hb2 = 0x00; //sequence_index
-
-	setFieldWithMask(&infopacket->sb[VRR_VTEM_PB0], MASK__VRR_VTEM_PB0__VFR, 1);
-	setFieldWithMask(&infopacket->sb[VRR_VTEM_PB2], MASK__VRR_VTEM_PB2__ORGANIZATION_ID, 1);
-	setFieldWithMask(&infopacket->sb[VRR_VTEM_PB3], MASK__VRR_VTEM_PB3__DATA_SET_TAG_MSB, 0);
-	setFieldWithMask(&infopacket->sb[VRR_VTEM_PB4], MASK__VRR_VTEM_PB4__DATA_SET_TAG_LSB, 1);
-	setFieldWithMask(&infopacket->sb[VRR_VTEM_PB5], MASK__VRR_VTEM_PB5__DATA_SET_LENGTH_MSB, 0);
-	setFieldWithMask(&infopacket->sb[VRR_VTEM_PB6], MASK__VRR_VTEM_PB6__DATA_SET_LENGTH_LSB, 4);
+	/* PB1 = 0x1A (24bit AMD IEEE OUI (0x00001A) - Byte 0) */
+	infopacket->sb[1] = 0x1A;
+
+	/* PB2 = 0x00 (24bit AMD IEEE OUI (0x00001A) - Byte 1) */
+	infopacket->sb[2] = 0x00;
+
+	/* PB3 = 0x00 (24bit AMD IEEE OUI (0x00001A) - Byte 2) */
+	infopacket->sb[3] = 0x00;
+
+	/* PB4 = Reserved */
+
+	/* PB5 = Reserved */
+
+	/* PB6 = [Bits 7:3 = Reserved] */
+
+	/* PB6 = [Bit 0 = FreeSync Supported] */
+	if (vrr->state != VRR_STATE_UNSUPPORTED)
+		infopacket->sb[6] |= 0x01;
+
+	/* PB6 = [Bit 1 = FreeSync Enabled] */
+	if (vrr->state != VRR_STATE_DISABLED &&
+			vrr->state != VRR_STATE_UNSUPPORTED)
+		infopacket->sb[6] |= 0x02;
+
+	/* PB6 = [Bit 2 = FreeSync Active] */
+	if (vrr->state == VRR_STATE_ACTIVE_VARIABLE ||
+			vrr->state == VRR_STATE_ACTIVE_FIXED)
+		infopacket->sb[6] |= 0x04;
+
+	/* PB7 = FreeSync Minimum refresh rate (Hz) */
+	infopacket->sb[7] = (unsigned char)(vrr->min_refresh_in_uhz / 1000000);
+
+	/* PB8 = FreeSync Maximum refresh rate (Hz)
+	 * Note: We should never go above the field rate of the mode timing set.
+	 */
+	infopacket->sb[8] = (unsigned char)(vrr->max_refresh_in_uhz / 1000000);
+
+
+	//FreeSync HDR
+	infopacket->sb[9] = 0;
+	infopacket->sb[10] = 0;
+}
+
+static void build_vrr_infopacket_fs2_data(enum color_transfer_func app_tf,
+		struct dc_info_packet *infopacket)
+{
+	if (app_tf != TRANSFER_FUNC_UNKNOWN) {
+		infopacket->valid = true;
+
+		infopacket->sb[6] |= 0x08;  // PB6 = [Bit 3 = Native Color Active]
+
+		if (app_tf == TRANSFER_FUNC_GAMMA_22) {
+			infopacket->sb[9] |= 0x04;  // PB6 = [Bit 2 = Gamma 2.2 EOTF Active]
+		}
+	}
 }
 
 static void build_vrr_infopacket_header_v1(enum signal_type signal,
@@ -690,105 +645,6 @@ static void build_vrr_infopacket_header_v2(enum signal_type signal,
 	}
 }
 
-static void build_vrr_vtem_infopacket_data(const struct dc_stream_state *stream,
-		const struct mod_vrr_params *vrr,
-		struct dc_info_packet *infopacket)
-{
-	unsigned int fieldRateInHz;
-
-	if (vrr->state == VRR_STATE_ACTIVE_VARIABLE ||
-				vrr->state == VRR_STATE_ACTIVE_FIXED) {
-		setFieldWithMask(&infopacket->sb[VRR_VTEM_MD0], MASK__VRR_VTEM_MD0__VRR_EN, 1);
-	} else {
-		setFieldWithMask(&infopacket->sb[VRR_VTEM_MD0], MASK__VRR_VTEM_MD0__VRR_EN, 0);
-	}
-
-	if (!stream->timing.vic) {
-		setFieldWithMask(&infopacket->sb[VRR_VTEM_MD1], MASK__VRR_VTEM_MD1__BASE_VFRONT,
-				stream->timing.v_front_porch);
-
-
-		/* TODO: In dal2, we check mode flags for a reduced blanking timing.
-		 * Need a way to relay that information to this function.
-		 * if("ReducedBlanking")
-		 * {
-		 *   setFieldWithMask(&infopacket->sb[VRR_VTEM_MD2], MASK__VRR_VTEM_MD2__RB, 1;
-		 * }
-		 */
-
-		//TODO: DAL2 does FixPoint and rounding. Here we might need to account for that
-		fieldRateInHz = (stream->timing.pix_clk_100hz * 100)/
-			(stream->timing.h_total * stream->timing.v_total);
-
-		setFieldWithMask(&infopacket->sb[VRR_VTEM_MD2],  MASK__VRR_VTEM_MD2__BASE_REFRESH_RATE_98,
-				fieldRateInHz >> 8);
-		setFieldWithMask(&infopacket->sb[VRR_VTEM_MD3], MASK__VRR_VTEM_MD3__BASE_REFRESH_RATE_07,
-				fieldRateInHz);
-
-	}
-	infopacket->valid = true;
-}
-
-static void build_vrr_infopacket_data(const struct mod_vrr_params *vrr,
-		struct dc_info_packet *infopacket)
-{
-	/* PB1 = 0x1A (24bit AMD IEEE OUI (0x00001A) - Byte 0) */
-	infopacket->sb[1] = 0x1A;
-
-	/* PB2 = 0x00 (24bit AMD IEEE OUI (0x00001A) - Byte 1) */
-	infopacket->sb[2] = 0x00;
-
-	/* PB3 = 0x00 (24bit AMD IEEE OUI (0x00001A) - Byte 2) */
-	infopacket->sb[3] = 0x00;
-
-	/* PB4 = Reserved */
-
-	/* PB5 = Reserved */
-
-	/* PB6 = [Bits 7:3 = Reserved] */
-
-	/* PB6 = [Bit 0 = FreeSync Supported] */
-	if (vrr->state != VRR_STATE_UNSUPPORTED)
-		infopacket->sb[6] |= 0x01;
-
-	/* PB6 = [Bit 1 = FreeSync Enabled] */
-	if (vrr->state != VRR_STATE_DISABLED &&
-			vrr->state != VRR_STATE_UNSUPPORTED)
-		infopacket->sb[6] |= 0x02;
-
-	/* PB6 = [Bit 2 = FreeSync Active] */
-	if (vrr->state == VRR_STATE_ACTIVE_VARIABLE ||
-			vrr->state == VRR_STATE_ACTIVE_FIXED)
-		infopacket->sb[6] |= 0x04;
-
-	/* PB7 = FreeSync Minimum refresh rate (Hz) */
-	infopacket->sb[7] = (unsigned char)(vrr->min_refresh_in_uhz / 1000000);
-
-	/* PB8 = FreeSync Maximum refresh rate (Hz)
-	 * Note: We should never go above the field rate of the mode timing set.
-	 */
-	infopacket->sb[8] = (unsigned char)(vrr->max_refresh_in_uhz / 1000000);
-
-
-	//FreeSync HDR
-	infopacket->sb[9] = 0;
-	infopacket->sb[10] = 0;
-}
-
-static void build_vrr_infopacket_fs2_data(enum color_transfer_func app_tf,
-		struct dc_info_packet *infopacket)
-{
-	if (app_tf != TRANSFER_FUNC_UNKNOWN) {
-		infopacket->valid = true;
-
-		infopacket->sb[6] |= 0x08;  // PB6 = [Bit 3 = Native Color Active]
-
-		if (app_tf == TRANSFER_FUNC_GAMMA_22) {
-			infopacket->sb[9] |= 0x04;  // PB6 = [Bit 2 = Gamma 2.2 EOTF Active]
-		}
-	}
-}
-
 static void build_vrr_infopacket_checksum(unsigned int *payload_size,
 		struct dc_info_packet *infopacket)
 {
@@ -841,21 +697,6 @@ static void build_vrr_infopacket_v2(enum signal_type signal,
 	infopacket->valid = true;
 }
 
-static void build_vrr_infopacket_vtem(const struct dc_stream_state *stream,
-		const struct mod_vrr_params *vrr,
-		struct dc_info_packet *infopacket)
-{
-	//VTEM info packet for HdmiVrr
-
-	memset(infopacket, 0, sizeof(struct dc_info_packet));
-
-	//VTEM Packet is structured differently
-	build_vrr_infopacket_header_vtem(stream->signal, infopacket);
-	build_vrr_vtem_infopacket_data(stream, vrr, infopacket);
-
-	infopacket->valid = true;
-}
-
 void mod_freesync_build_vrr_infopacket(struct mod_freesync *mod_freesync,
 		const struct dc_stream_state *stream,
 		const struct mod_vrr_params *vrr,
@@ -868,16 +709,13 @@ void mod_freesync_build_vrr_infopacket(struct mod_freesync *mod_freesync,
 	 * Check if Freesync is supported. Return if false. If true,
 	 * set the corresponding bit in the info packet
 	 */
-	if (!vrr->supported || (!vrr->send_info_frame && packet_type != PACKET_TYPE_VTEM))
+	if (!vrr->supported || (!vrr->send_info_frame))
 		return;
 
 	switch (packet_type) {
 	case PACKET_TYPE_FS2:
 		build_vrr_infopacket_v2(stream->signal, vrr, app_tf, infopacket);
 		break;
-	case PACKET_TYPE_VTEM:
-		build_vrr_infopacket_vtem(stream, vrr, infopacket);
-		break;
 	case PACKET_TYPE_VRR:
 	case PACKET_TYPE_FS1:
 	default:

commit a463b263032f7c98c5912207db43be1aa34a6438
Author: Bayan Zabihiyan <bayan.zabihiyan@amd.com>
Date:   Wed Jul 10 16:00:53 2019 -0400

    drm/amd/display: Fix frames_to_insert math
    
    [Why]
    The math on deciding on how many
    "frames to insert" sometimes sent us over the max refresh rate.
    Also integer overflow can occur if we have high refresh rates.
    
    [How]
    Instead of clipping the  frame duration such that it doesnâ€™t go below the min,
    just remove a frame from the number of frames to insert. +
    Use unsigned long long for intermediate calculations to prevent
    integer overflow.
    
    Signed-off-by: Bayan Zabihiyan <bayan.zabihiyan@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 7c20171a3b6d..a53666ff6cf8 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -435,6 +435,12 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 		/* Either we've calculated the number of frames to insert,
 		 * or we need to insert min duration frames
 		 */
+		if (last_render_time_in_us / frames_to_insert <
+				in_out_vrr->min_duration_in_us){
+			frames_to_insert -= (frames_to_insert > 1) ?
+					1 : 0;
+		}
+
 		if (frames_to_insert > 0)
 			inserted_frame_duration_in_us = last_render_time_in_us /
 							frames_to_insert;
@@ -887,8 +893,8 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 	struct core_freesync *core_freesync = NULL;
 	unsigned long long nominal_field_rate_in_uhz = 0;
 	unsigned int refresh_range = 0;
-	unsigned int min_refresh_in_uhz = 0;
-	unsigned int max_refresh_in_uhz = 0;
+	unsigned long long min_refresh_in_uhz = 0;
+	unsigned long long max_refresh_in_uhz = 0;
 
 	if (mod_freesync == NULL)
 		return;
@@ -915,7 +921,7 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 		min_refresh_in_uhz = nominal_field_rate_in_uhz;
 
 	if (!vrr_settings_require_update(core_freesync,
-			in_config, min_refresh_in_uhz, max_refresh_in_uhz,
+			in_config, (unsigned int)min_refresh_in_uhz, (unsigned int)max_refresh_in_uhz,
 			in_out_vrr))
 		return;
 
@@ -931,15 +937,15 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 		return;
 
 	} else {
-		in_out_vrr->min_refresh_in_uhz = min_refresh_in_uhz;
+		in_out_vrr->min_refresh_in_uhz = (unsigned int)min_refresh_in_uhz;
 		in_out_vrr->max_duration_in_us =
 				calc_duration_in_us_from_refresh_in_uhz(
-						min_refresh_in_uhz);
+						(unsigned int)min_refresh_in_uhz);
 
-		in_out_vrr->max_refresh_in_uhz = max_refresh_in_uhz;
+		in_out_vrr->max_refresh_in_uhz = (unsigned int)max_refresh_in_uhz;
 		in_out_vrr->min_duration_in_us =
 				calc_duration_in_us_from_refresh_in_uhz(
-						max_refresh_in_uhz);
+						(unsigned int)max_refresh_in_uhz);
 
 		refresh_range = in_out_vrr->max_refresh_in_uhz -
 				in_out_vrr->min_refresh_in_uhz;
@@ -950,17 +956,18 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 	in_out_vrr->fixed.ramping_active = in_config->ramping;
 
 	in_out_vrr->btr.btr_enabled = in_config->btr;
+
 	if (in_out_vrr->max_refresh_in_uhz <
 			2 * in_out_vrr->min_refresh_in_uhz)
 		in_out_vrr->btr.btr_enabled = false;
+
 	in_out_vrr->btr.btr_active = false;
 	in_out_vrr->btr.inserted_duration_in_us = 0;
 	in_out_vrr->btr.frames_to_insert = 0;
 	in_out_vrr->btr.frame_counter = 0;
 	in_out_vrr->btr.mid_point_in_us =
-			in_out_vrr->min_duration_in_us +
-				(in_out_vrr->max_duration_in_us -
-				in_out_vrr->min_duration_in_us) / 2;
+				(in_out_vrr->min_duration_in_us +
+				 in_out_vrr->max_duration_in_us) / 2;
 
 	if (in_out_vrr->state == VRR_STATE_UNSUPPORTED) {
 		in_out_vrr->adjust.v_total_min = stream->timing.v_total;

commit 4fc4dca8320e46b067037496fde3a6d95381d60f
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:50 2019 +0200

    drm/amd: drop use of drmp.h in os_types.h
    
    Drop use of the deprecated drmP.h from display/dc/os_types.h
    
    Fix all fallout after this change.
    Most of the fixes was adding a missing include of vmalloc.h.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian KÃ¶nig" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-4-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 19b1eaebe484..7c20171a3b6d 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -23,6 +23,8 @@
  *
  */
 
+#include <linux/slab.h>
+
 #include "dm_services.h"
 #include "dc.h"
 #include "mod_freesync.h"

commit dc4a9049f023cff6f3c7f0765a706595444c4bd2
Author: Mario Kleiner <mario.kleiner.de@gmail.com>
Date:   Fri Apr 26 23:40:14 2019 +0200

    drm/amd/display: Fix and simplify apply_below_the_range()
    
    The comparison of inserted_frame_duration_in_us against a
    duration calculated from max_refresh_in_uhz is both wrong
    in its math and not needed, as the min_duration_in_us value
    is already cached in in_out_vrr for reuse. No need to
    recalculate it wrongly at each invocation.
    
    Signed-off-by: Mario Kleiner <mario.kleiner.de@gmail.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 3d867e34f8b3..19b1eaebe484 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -437,10 +437,8 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 			inserted_frame_duration_in_us = last_render_time_in_us /
 							frames_to_insert;
 
-		if (inserted_frame_duration_in_us <
-			(1000000 / in_out_vrr->max_refresh_in_uhz))
-			inserted_frame_duration_in_us =
-				(1000000 / in_out_vrr->max_refresh_in_uhz);
+		if (inserted_frame_duration_in_us < in_out_vrr->min_duration_in_us)
+			inserted_frame_duration_in_us = in_out_vrr->min_duration_in_us;
 
 		/* Cache the calculated variables */
 		in_out_vrr->btr.inserted_duration_in_us =

commit e03868ec0cdc508e270e9f1c2d8c97ee4163dd47
Author: Reza Amini <Reza.Amini@amd.com>
Date:   Thu Mar 7 17:36:29 2019 -0500

    drm/amd/display: Fix VTEM InfoPacket programming
    
    Refactor setting bit fields. Correcting the offset of MD0.
    Initializing the InfoPacket header fields. Defining the field offsets
    and masks.
    
    Signed-off-by: Reza Amini <Reza.Amini@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 8f6f744fb2be..3d867e34f8b3 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -50,6 +50,93 @@ struct core_freesync {
 	struct dc *dc;
 };
 
+void setFieldWithMask(unsigned char *dest, unsigned int mask, unsigned int value)
+{
+	unsigned int shift = 0;
+
+	if (!mask || !dest)
+		return;
+
+	while (!((mask >> shift) & 1))
+		shift++;
+
+	//reset
+	*dest = *dest & ~mask;
+	//set
+	//dont let value span past mask
+	value = value & (mask >> shift);
+	//insert value
+	*dest = *dest | (value << shift);
+}
+
+// VTEM Byte Offset
+#define VRR_VTEM_PB0		0
+#define VRR_VTEM_PB1		1
+#define VRR_VTEM_PB2		2
+#define VRR_VTEM_PB3		3
+#define VRR_VTEM_PB4		4
+#define VRR_VTEM_PB5		5
+#define VRR_VTEM_PB6		6
+
+#define VRR_VTEM_MD0		7
+#define VRR_VTEM_MD1		8
+#define VRR_VTEM_MD2		9
+#define VRR_VTEM_MD3		10
+
+
+// VTEM Byte Masks
+//PB0
+#define MASK__VRR_VTEM_PB0__RESERVED0  0x01
+#define MASK__VRR_VTEM_PB0__SYNC       0x02
+#define MASK__VRR_VTEM_PB0__VFR        0x04
+#define MASK__VRR_VTEM_PB0__AFR        0x08
+#define MASK__VRR_VTEM_PB0__DS_TYPE    0x30
+	//0: Periodic pseudo-static EM Data Set
+	//1: Periodic dynamic EM Data Set
+	//2: Unique EM Data Set
+	//3: Reserved
+#define MASK__VRR_VTEM_PB0__END        0x40
+#define MASK__VRR_VTEM_PB0__NEW        0x80
+
+//PB1
+#define MASK__VRR_VTEM_PB1__RESERVED1 0xFF
+
+//PB2
+#define MASK__VRR_VTEM_PB2__ORGANIZATION_ID 0xFF
+	//0: This is a Vendor Specific EM Data Set
+	//1: This EM Data Set is defined by This Specification (HDMI 2.1 r102.clean)
+	//2: This EM Data Set is defined by CTA-861-G
+	//3: This EM Data Set is defined by VESA
+//PB3
+#define MASK__VRR_VTEM_PB3__DATA_SET_TAG_MSB    0xFF
+//PB4
+#define MASK__VRR_VTEM_PB4__DATA_SET_TAG_LSB    0xFF
+//PB5
+#define MASK__VRR_VTEM_PB5__DATA_SET_LENGTH_MSB 0xFF
+//PB6
+#define MASK__VRR_VTEM_PB6__DATA_SET_LENGTH_LSB 0xFF
+
+
+
+//PB7-27 (20 bytes):
+//PB7 = MD0
+#define MASK__VRR_VTEM_MD0__VRR_EN         0x01
+#define MASK__VRR_VTEM_MD0__M_CONST        0x02
+#define MASK__VRR_VTEM_MD0__RESERVED2      0x0C
+#define MASK__VRR_VTEM_MD0__FVA_FACTOR_M1  0xF0
+
+//MD1
+#define MASK__VRR_VTEM_MD1__BASE_VFRONT    0xFF
+
+//MD2
+#define MASK__VRR_VTEM_MD2__BASE_REFRESH_RATE_98  0x03
+#define MASK__VRR_VTEM_MD2__RB                    0x04
+#define MASK__VRR_VTEM_MD2__RESERVED3             0xF8
+
+//MD3
+#define MASK__VRR_VTEM_MD3__BASE_REFRESH_RATE_07  0xFF
+
+
 #define MOD_FREESYNC_TO_CORE(mod_freesync)\
 		container_of(mod_freesync, struct core_freesync, public)
 
@@ -489,16 +576,14 @@ static void build_vrr_infopacket_header_vtem(enum signal_type signal,
 	// HB0, HB1, HB2 indicates PacketType VTEMPacket
 	infopacket->hb0 = 0x7F;
 	infopacket->hb1 = 0xC0;
-	infopacket->hb2 = 0x00;
-	/* HB3 Bit Fields
-	 * Reserved :1 = 0
-	 * Sync     :1 = 0
-	 * VFR      :1 = 1
-	 * Ds_Type  :2 = 0
-	 * End      :1 = 0
-	 * New      :1 = 0
-	 */
-	infopacket->hb3 = 0x20;
+	infopacket->hb2 = 0x00; //sequence_index
+
+	setFieldWithMask(&infopacket->sb[VRR_VTEM_PB0], MASK__VRR_VTEM_PB0__VFR, 1);
+	setFieldWithMask(&infopacket->sb[VRR_VTEM_PB2], MASK__VRR_VTEM_PB2__ORGANIZATION_ID, 1);
+	setFieldWithMask(&infopacket->sb[VRR_VTEM_PB3], MASK__VRR_VTEM_PB3__DATA_SET_TAG_MSB, 0);
+	setFieldWithMask(&infopacket->sb[VRR_VTEM_PB4], MASK__VRR_VTEM_PB4__DATA_SET_TAG_LSB, 1);
+	setFieldWithMask(&infopacket->sb[VRR_VTEM_PB5], MASK__VRR_VTEM_PB5__DATA_SET_LENGTH_MSB, 0);
+	setFieldWithMask(&infopacket->sb[VRR_VTEM_PB6], MASK__VRR_VTEM_PB6__DATA_SET_LENGTH_LSB, 4);
 }
 
 static void build_vrr_infopacket_header_v1(enum signal_type signal,
@@ -603,45 +688,36 @@ static void build_vrr_vtem_infopacket_data(const struct dc_stream_state *stream,
 		const struct mod_vrr_params *vrr,
 		struct dc_info_packet *infopacket)
 {
-	/* dc_info_packet to VtemPacket Translation of Bit-fields,
-	 * SB[6]
-	 * unsigned char VRR_EN        :1
-	 * unsigned char M_CONST       :1
-	 * unsigned char Reserved2     :2
-	 * unsigned char FVA_Factor_M1 :4
-	 * SB[7]
-	 * unsigned char Base_Vfront   :8
-	 * SB[8]
-	 * unsigned char Base_Refresh_Rate_98 :2
-	 * unsigned char RB                   :1
-	 * unsigned char Reserved3            :5
-	 * SB[9]
-	 * unsigned char Base_RefreshRate_07  :8
-	 */
 	unsigned int fieldRateInHz;
 
 	if (vrr->state == VRR_STATE_ACTIVE_VARIABLE ||
-				vrr->state == VRR_STATE_ACTIVE_FIXED){
-		infopacket->sb[6] |= 0x01; //VRR_EN Bit = 1
+				vrr->state == VRR_STATE_ACTIVE_FIXED) {
+		setFieldWithMask(&infopacket->sb[VRR_VTEM_MD0], MASK__VRR_VTEM_MD0__VRR_EN, 1);
 	} else {
-		infopacket->sb[6] &= 0xFE; //VRR_EN Bit = 0
+		setFieldWithMask(&infopacket->sb[VRR_VTEM_MD0], MASK__VRR_VTEM_MD0__VRR_EN, 0);
 	}
 
 	if (!stream->timing.vic) {
-		infopacket->sb[7] = stream->timing.v_front_porch;
+		setFieldWithMask(&infopacket->sb[VRR_VTEM_MD1], MASK__VRR_VTEM_MD1__BASE_VFRONT,
+				stream->timing.v_front_porch);
+
 
 		/* TODO: In dal2, we check mode flags for a reduced blanking timing.
 		 * Need a way to relay that information to this function.
 		 * if("ReducedBlanking")
 		 * {
-		 *   infopacket->sb[8] |= 0x20; //Set 3rd bit to 1
+		 *   setFieldWithMask(&infopacket->sb[VRR_VTEM_MD2], MASK__VRR_VTEM_MD2__RB, 1;
 		 * }
 		 */
+
+		//TODO: DAL2 does FixPoint and rounding. Here we might need to account for that
 		fieldRateInHz = (stream->timing.pix_clk_100hz * 100)/
-				(stream->timing.h_total * stream->timing.v_total);
+			(stream->timing.h_total * stream->timing.v_total);
 
-		infopacket->sb[8] |= ((fieldRateInHz & 0x300) >> 2);
-		infopacket->sb[9] |= fieldRateInHz & 0xFF;
+		setFieldWithMask(&infopacket->sb[VRR_VTEM_MD2],  MASK__VRR_VTEM_MD2__BASE_REFRESH_RATE_98,
+				fieldRateInHz >> 8);
+		setFieldWithMask(&infopacket->sb[VRR_VTEM_MD3], MASK__VRR_VTEM_MD3__BASE_REFRESH_RATE_07,
+				fieldRateInHz);
 
 	}
 	infopacket->valid = true;
@@ -765,6 +841,8 @@ static void build_vrr_infopacket_vtem(const struct dc_stream_state *stream,
 {
 	//VTEM info packet for HdmiVrr
 
+	memset(infopacket, 0, sizeof(struct dc_info_packet));
+
 	//VTEM Packet is structured differently
 	build_vrr_infopacket_header_vtem(stream->signal, infopacket);
 	build_vrr_vtem_infopacket_data(stream, vrr, infopacket);

commit 3d5cc272319d6b7bf2e7d8aa9b1c3b0fe3e85b3f
Author: Hugo Hu <hugo.hu@amd.com>
Date:   Wed Feb 27 15:18:08 2019 +0800

    drm/amd/display: Programming correct VRR_EN bit in VTEM structure
    
    [Why]
    In HDMI plugfest, MTK report our EMP with VRR_EN bit = 0.
    VRR_EN bit is EMP-MD0-bit 0. Currently driver set 1 to bit 3.
    
    [How]
    Programming correct VRR_EN bit in EMP-MD0-bit0.
    
    Signed-off-by: Hugo Hu <hugo.hu@amd.com>
    Reviewed-by: Reza Amini <Reza.Amini@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 5f493e9d6bbb..8f6f744fb2be 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -622,9 +622,9 @@ static void build_vrr_vtem_infopacket_data(const struct dc_stream_state *stream,
 
 	if (vrr->state == VRR_STATE_ACTIVE_VARIABLE ||
 				vrr->state == VRR_STATE_ACTIVE_FIXED){
-		infopacket->sb[6] |= 0x80; //VRR_EN Bit = 1
+		infopacket->sb[6] |= 0x01; //VRR_EN Bit = 1
 	} else {
-		infopacket->sb[6] &= 0x7F; //VRR_EN Bit = 0
+		infopacket->sb[6] &= 0xFE; //VRR_EN Bit = 0
 	}
 
 	if (!stream->timing.vic) {

commit 9070d18f89a8c7c839bc2dd3b1c6fbc8864c1be5
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Fri Mar 1 10:24:37 2019 -0500

    drm/amd/display: Add a hysteresis to BTR frame multiplier
    
    [Why]
    Flickering is observed on some displays when the number of inserted BTR
    frames changes frequently.
    
    [How]
    Add in a margin of drift to prevent the inserted number of frames from
    jumping around too frequently.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index bfd27f10879e..5f493e9d6bbb 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -37,6 +37,8 @@
 #define RENDER_TIMES_MAX_COUNT 10
 /* Threshold to exit BTR (to avoid frequent enter-exits at the lower limit) */
 #define BTR_EXIT_MARGIN 2000
+/* Threshold to change BTR multiplier (to avoid frequent changes) */
+#define BTR_DRIFT_MARGIN 2000
 /*Threshold to exit fixed refresh rate*/
 #define FIXED_REFRESH_EXIT_MARGIN_IN_HZ 4
 /* Number of consecutive frames to check before entering/exiting fixed refresh*/
@@ -248,6 +250,7 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 	unsigned int frames_to_insert = 0;
 	unsigned int min_frame_duration_in_ns = 0;
 	unsigned int max_render_time_in_us = in_out_vrr->max_duration_in_us;
+	unsigned int delta_from_mid_point_delta_in_us;
 
 	min_frame_duration_in_ns = ((unsigned int) (div64_u64(
 		(1000000000ULL * 1000000),
@@ -318,10 +321,27 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 		/* Choose number of frames to insert based on how close it
 		 * can get to the mid point of the variable range.
 		 */
-		if (delta_from_mid_point_in_us_1 < delta_from_mid_point_in_us_2)
+		if (delta_from_mid_point_in_us_1 < delta_from_mid_point_in_us_2) {
 			frames_to_insert = mid_point_frames_ceil;
-		else
+			delta_from_mid_point_delta_in_us = delta_from_mid_point_in_us_2 -
+					delta_from_mid_point_in_us_1;
+		} else {
 			frames_to_insert = mid_point_frames_floor;
+			delta_from_mid_point_delta_in_us = delta_from_mid_point_in_us_1 -
+					delta_from_mid_point_in_us_2;
+		}
+
+		/* Prefer current frame multiplier when BTR is enabled unless it drifts
+		 * too far from the midpoint
+		 */
+		if (in_out_vrr->btr.frames_to_insert != 0 &&
+				delta_from_mid_point_delta_in_us < BTR_DRIFT_MARGIN) {
+			if (((last_render_time_in_us / in_out_vrr->btr.frames_to_insert) <
+					in_out_vrr->max_duration_in_us) &&
+				((last_render_time_in_us / in_out_vrr->btr.frames_to_insert) >
+					in_out_vrr->min_duration_in_us))
+				frames_to_insert = in_out_vrr->btr.frames_to_insert;
+		}
 
 		/* Either we've calculated the number of frames to insert,
 		 * or we need to insert min duration frames

commit 672e78cab819ebe31e3b9b8abac367be8a110472
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Mon Dec 10 16:42:01 2018 -0700

    drm/amd/display: Pass app_tf by value rather than by reference
    
    Clang warns when an expression that equals zero is used as a null
    pointer constant (in lieu of NULL):
    
    drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm.c:4435:3:
    warning: expression which evaluates to zero treated as a null pointer
    constant of type 'const enum color_transfer_func *'
    [-Wnon-literal-null-conversion]
                    TRANSFER_FUNC_UNKNOWN,
                    ^~~~~~~~~~~~~~~~~~~~~
    1 warning generated.
    
    This warning is caused by commit bb47de736661 ("drm/amdgpu: Set FreeSync
    state using drm VRR properties") and it could be solved by using NULL
    instead of TRANSFER_FUNC_UNKNOWN or casting TRANSFER_FUNC_UNKNOWN as a
    pointer. However, after looking into it, there doesn't appear to be a
    good reason to pass app_tf by reference as it is never mutated along the
    way. This is the only code path in which app_tf is used:
    
    mod_freesync_build_vrr_infopacket ->
        build_vrr_infopacket_v2 ->
            build_vrr_infopacket_fs2_data
    
    Neither mod_freesync_build_vrr_infopacket or build_vrr_infopacket_v2
    modify app_tf's value and build_vrr_infopacket_fs2_data expects just
    the value so we can avoid dereferencing anything by just passing in
    app_tf's value to mod_freesync_build_vrr_infopacket and
    build_vrr_infopacket_v2.
    
    There is no functional change because build_vrr_infopacket_fs2_data
    doesn't do anything if TRANSFER_FUNC_UNKNOWN is passed to it, the same
    as not calling build_vrr_infopacket_fs2_data at all like before this
    change when NULL was used for app_tf.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 94a84bc57c7a..bfd27f10879e 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -724,7 +724,7 @@ static void build_vrr_infopacket_v1(enum signal_type signal,
 
 static void build_vrr_infopacket_v2(enum signal_type signal,
 		const struct mod_vrr_params *vrr,
-		const enum color_transfer_func *app_tf,
+		enum color_transfer_func app_tf,
 		struct dc_info_packet *infopacket)
 {
 	unsigned int payload_size = 0;
@@ -732,8 +732,7 @@ static void build_vrr_infopacket_v2(enum signal_type signal,
 	build_vrr_infopacket_header_v2(signal, infopacket, &payload_size);
 	build_vrr_infopacket_data(vrr, infopacket);
 
-	if (app_tf != NULL)
-		build_vrr_infopacket_fs2_data(*app_tf, infopacket);
+	build_vrr_infopacket_fs2_data(app_tf, infopacket);
 
 	build_vrr_infopacket_checksum(&payload_size, infopacket);
 
@@ -757,7 +756,7 @@ void mod_freesync_build_vrr_infopacket(struct mod_freesync *mod_freesync,
 		const struct dc_stream_state *stream,
 		const struct mod_vrr_params *vrr,
 		enum vrr_packet_type packet_type,
-		const enum color_transfer_func *app_tf,
+		enum color_transfer_func app_tf,
 		struct dc_info_packet *infopacket)
 {
 	/* SPD info packet for FreeSync

commit ca35899c4e3a173c0d6d4619dc62e836a9487cb2
Author: Bayan Zabihiyan <Bayan.Zabihiyan@amd.com>
Date:   Thu Dec 27 08:43:45 2018 -0500

    drm/amd/display: Add new infopacket definition
    
    Modify freesync module to build VTEM infopackets when in HdmiVRR mode
    
    Signed-off-by: Bayan Zabihiyan <Bayan.Zabihiyan@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index d967ac001f59..94a84bc57c7a 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -461,6 +461,26 @@ bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
 	return false;
 }
 
+static void build_vrr_infopacket_header_vtem(enum signal_type signal,
+		struct dc_info_packet *infopacket)
+{
+	// HEADER
+
+	// HB0, HB1, HB2 indicates PacketType VTEMPacket
+	infopacket->hb0 = 0x7F;
+	infopacket->hb1 = 0xC0;
+	infopacket->hb2 = 0x00;
+	/* HB3 Bit Fields
+	 * Reserved :1 = 0
+	 * Sync     :1 = 0
+	 * VFR      :1 = 1
+	 * Ds_Type  :2 = 0
+	 * End      :1 = 0
+	 * New      :1 = 0
+	 */
+	infopacket->hb3 = 0x20;
+}
+
 static void build_vrr_infopacket_header_v1(enum signal_type signal,
 		struct dc_info_packet *infopacket,
 		unsigned int *payload_size)
@@ -559,6 +579,54 @@ static void build_vrr_infopacket_header_v2(enum signal_type signal,
 	}
 }
 
+static void build_vrr_vtem_infopacket_data(const struct dc_stream_state *stream,
+		const struct mod_vrr_params *vrr,
+		struct dc_info_packet *infopacket)
+{
+	/* dc_info_packet to VtemPacket Translation of Bit-fields,
+	 * SB[6]
+	 * unsigned char VRR_EN        :1
+	 * unsigned char M_CONST       :1
+	 * unsigned char Reserved2     :2
+	 * unsigned char FVA_Factor_M1 :4
+	 * SB[7]
+	 * unsigned char Base_Vfront   :8
+	 * SB[8]
+	 * unsigned char Base_Refresh_Rate_98 :2
+	 * unsigned char RB                   :1
+	 * unsigned char Reserved3            :5
+	 * SB[9]
+	 * unsigned char Base_RefreshRate_07  :8
+	 */
+	unsigned int fieldRateInHz;
+
+	if (vrr->state == VRR_STATE_ACTIVE_VARIABLE ||
+				vrr->state == VRR_STATE_ACTIVE_FIXED){
+		infopacket->sb[6] |= 0x80; //VRR_EN Bit = 1
+	} else {
+		infopacket->sb[6] &= 0x7F; //VRR_EN Bit = 0
+	}
+
+	if (!stream->timing.vic) {
+		infopacket->sb[7] = stream->timing.v_front_porch;
+
+		/* TODO: In dal2, we check mode flags for a reduced blanking timing.
+		 * Need a way to relay that information to this function.
+		 * if("ReducedBlanking")
+		 * {
+		 *   infopacket->sb[8] |= 0x20; //Set 3rd bit to 1
+		 * }
+		 */
+		fieldRateInHz = (stream->timing.pix_clk_100hz * 100)/
+				(stream->timing.h_total * stream->timing.v_total);
+
+		infopacket->sb[8] |= ((fieldRateInHz & 0x300) >> 2);
+		infopacket->sb[9] |= fieldRateInHz & 0xFF;
+
+	}
+	infopacket->valid = true;
+}
+
 static void build_vrr_infopacket_data(const struct mod_vrr_params *vrr,
 		struct dc_info_packet *infopacket)
 {
@@ -672,6 +740,19 @@ static void build_vrr_infopacket_v2(enum signal_type signal,
 	infopacket->valid = true;
 }
 
+static void build_vrr_infopacket_vtem(const struct dc_stream_state *stream,
+		const struct mod_vrr_params *vrr,
+		struct dc_info_packet *infopacket)
+{
+	//VTEM info packet for HdmiVrr
+
+	//VTEM Packet is structured differently
+	build_vrr_infopacket_header_vtem(stream->signal, infopacket);
+	build_vrr_vtem_infopacket_data(stream, vrr, infopacket);
+
+	infopacket->valid = true;
+}
+
 void mod_freesync_build_vrr_infopacket(struct mod_freesync *mod_freesync,
 		const struct dc_stream_state *stream,
 		const struct mod_vrr_params *vrr,
@@ -679,18 +760,21 @@ void mod_freesync_build_vrr_infopacket(struct mod_freesync *mod_freesync,
 		const enum color_transfer_func *app_tf,
 		struct dc_info_packet *infopacket)
 {
-	/* SPD info packet for FreeSync */
-
-	/* Check if Freesync is supported. Return if false. If true,
+	/* SPD info packet for FreeSync
+	 * VTEM info packet for HdmiVRR
+	 * Check if Freesync is supported. Return if false. If true,
 	 * set the corresponding bit in the info packet
 	 */
-	if (!vrr->supported || !vrr->send_vsif)
+	if (!vrr->supported || (!vrr->send_info_frame && packet_type != PACKET_TYPE_VTEM))
 		return;
 
 	switch (packet_type) {
 	case PACKET_TYPE_FS2:
 		build_vrr_infopacket_v2(stream->signal, vrr, app_tf, infopacket);
 		break;
+	case PACKET_TYPE_VTEM:
+		build_vrr_infopacket_vtem(stream, vrr, infopacket);
+		break;
 	case PACKET_TYPE_VRR:
 	case PACKET_TYPE_FS1:
 	default:
@@ -739,7 +823,7 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 		return;
 
 	in_out_vrr->state = in_config->state;
-	in_out_vrr->send_vsif = in_config->vsif_supported;
+	in_out_vrr->send_info_frame = in_config->vsif_supported;
 
 	if (in_config->state == VRR_STATE_UNSUPPORTED) {
 		in_out_vrr->state = VRR_STATE_UNSUPPORTED;

commit 380604e27bc9c26ce64a83044aa1ea76ffd28caf
Author: Ken Chalmers <ken.chalmers@amd.com>
Date:   Tue Nov 6 14:24:12 2018 -0500

    drm/amd/display: Use 100 Hz precision for pipe pixel clocks
    
    [Why]
    Users would like more accurate pixel clocks, especially for fractional
    "TV" frame rates like 59.94 Hz.
    
    [How]
    Store and communicate pixel clocks with 100 Hz accuracy from
    dc_crtc_timing through to BIOS command table setpixelclock call.
    
    Signed-off-by: Ken Chalmers <ken.chalmers@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 1544ed3f1747..d967ac001f59 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -108,8 +108,8 @@ static unsigned int calc_duration_in_us_from_v_total(
 {
 	unsigned int duration_in_us =
 			(unsigned int)(div64_u64(((unsigned long long)(v_total)
-				* 1000) * stream->timing.h_total,
-					stream->timing.pix_clk_khz));
+				* 10000) * stream->timing.h_total,
+					stream->timing.pix_clk_100hz));
 
 	return duration_in_us;
 }
@@ -126,7 +126,7 @@ static unsigned int calc_v_total_from_refresh(
 					refresh_in_uhz)));
 
 	v_total = div64_u64(div64_u64(((unsigned long long)(
-			frame_duration_in_ns) * stream->timing.pix_clk_khz),
+			frame_duration_in_ns) * (stream->timing.pix_clk_100hz / 10)),
 			stream->timing.h_total), 1000000);
 
 	/* v_total cannot be less than nominal */
@@ -152,7 +152,7 @@ static unsigned int calc_v_total_from_duration(
 		duration_in_us = vrr->max_duration_in_us;
 
 	v_total = div64_u64(div64_u64(((unsigned long long)(
-				duration_in_us) * stream->timing.pix_clk_khz),
+				duration_in_us) * (stream->timing.pix_clk_100hz / 10)),
 				stream->timing.h_total), 1000);
 
 	/* v_total cannot be less than nominal */
@@ -227,7 +227,7 @@ static void update_v_total_for_static_ramp(
 	}
 
 	v_total = div64_u64(div64_u64(((unsigned long long)(
-			current_duration_in_us) * stream->timing.pix_clk_khz),
+			current_duration_in_us) * (stream->timing.pix_clk_100hz / 10)),
 				stream->timing.h_total), 1000);
 
 	in_out_vrr->adjust.v_total_min = v_total;
@@ -972,7 +972,7 @@ unsigned long long mod_freesync_calc_nominal_field_rate(
 	unsigned long long nominal_field_rate_in_uhz = 0;
 
 	/* Calculate nominal field rate for stream */
-	nominal_field_rate_in_uhz = stream->timing.pix_clk_khz;
+	nominal_field_rate_in_uhz = stream->timing.pix_clk_100hz / 10;
 	nominal_field_rate_in_uhz *= 1000ULL * 1000ULL * 1000ULL;
 	nominal_field_rate_in_uhz = div_u64(nominal_field_rate_in_uhz,
 						stream->timing.h_total);

commit ecd0136bfdb5a28b8a869c305823df9d663e85ee
Author: Harmanprit Tatla <Harmanprit.Tatla@amd.com>
Date:   Mon Nov 5 17:55:53 2018 -0500

    drm/amd/display: Info frame cleanup
    
    * Use provided infopacket in stream (if valid) instead of reconstructing
      in set_vendor_info_packet()
    * Use proper format for enums
    * Use dc info packet struct instead
    
    Signed-off-by: Harmanprit Tatla <Harmanprit.Tatla@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 620a171620ee..1544ed3f1747 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -608,12 +608,12 @@ static void build_vrr_infopacket_data(const struct mod_vrr_params *vrr,
 static void build_vrr_infopacket_fs2_data(enum color_transfer_func app_tf,
 		struct dc_info_packet *infopacket)
 {
-	if (app_tf != transfer_func_unknown) {
+	if (app_tf != TRANSFER_FUNC_UNKNOWN) {
 		infopacket->valid = true;
 
 		infopacket->sb[6] |= 0x08;  // PB6 = [Bit 3 = Native Color Active]
 
-		if (app_tf == transfer_func_gamma_22) {
+		if (app_tf == TRANSFER_FUNC_GAMMA_22) {
 			infopacket->sb[9] |= 0x04;  // PB6 = [Bit 2 = Gamma 2.2 EOTF Active]
 		}
 	}
@@ -688,11 +688,11 @@ void mod_freesync_build_vrr_infopacket(struct mod_freesync *mod_freesync,
 		return;
 
 	switch (packet_type) {
-	case packet_type_fs2:
+	case PACKET_TYPE_FS2:
 		build_vrr_infopacket_v2(stream->signal, vrr, app_tf, infopacket);
 		break;
-	case packet_type_vrr:
-	case packet_type_fs1:
+	case PACKET_TYPE_VRR:
+	case PACKET_TYPE_FS1:
 	default:
 		build_vrr_infopacket_v1(stream->signal, vrr, infopacket);
 	}

commit de801062bf2c4216c1884d3707ff3f1f3533c4d9
Author: Harmanprit Tatla <htatla@amd.com>
Date:   Mon Sep 24 16:46:38 2018 -0400

    drm/amd/display: Freesync does not engage on some displays
    
    [Why]
    Current render margin time is not sufficient to compute exit frame
    time for most monitors.
    
    [How]
    Declared  render margin in FPS to compute a exit frame rate that is
    4 FPS above the minimum FPS required to engage FreeSync.
     Also did code clean-up to remove redundancies.
    
    Signed-off-by: Harmanprit Tatla <htatla@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 4018c7180d00..620a171620ee 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -37,6 +37,8 @@
 #define RENDER_TIMES_MAX_COUNT 10
 /* Threshold to exit BTR (to avoid frequent enter-exits at the lower limit) */
 #define BTR_EXIT_MARGIN 2000
+/*Threshold to exit fixed refresh rate*/
+#define FIXED_REFRESH_EXIT_MARGIN_IN_HZ 4
 /* Number of consecutive frames to check before entering/exiting fixed refresh*/
 #define FIXED_REFRESH_ENTER_FRAME_COUNT 5
 #define FIXED_REFRESH_EXIT_FRAME_COUNT 5
@@ -257,40 +259,14 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 		if (in_out_vrr->btr.btr_active) {
 			in_out_vrr->btr.frame_counter = 0;
 			in_out_vrr->btr.btr_active = false;
-
-		/* Exit Fixed Refresh mode */
-		} else if (in_out_vrr->fixed.fixed_active) {
-
-			in_out_vrr->fixed.frame_counter++;
-
-			if (in_out_vrr->fixed.frame_counter >
-					FIXED_REFRESH_EXIT_FRAME_COUNT) {
-				in_out_vrr->fixed.frame_counter = 0;
-				in_out_vrr->fixed.fixed_active = false;
-			}
 		}
 	} else if (last_render_time_in_us > max_render_time_in_us) {
 		/* Enter Below the Range */
-		if (!in_out_vrr->btr.btr_active &&
-				in_out_vrr->btr.btr_enabled) {
-			in_out_vrr->btr.btr_active = true;
-
-		/* Enter Fixed Refresh mode */
-		} else if (!in_out_vrr->fixed.fixed_active &&
-				!in_out_vrr->btr.btr_enabled) {
-			in_out_vrr->fixed.frame_counter++;
-
-			if (in_out_vrr->fixed.frame_counter >
-					FIXED_REFRESH_ENTER_FRAME_COUNT) {
-				in_out_vrr->fixed.frame_counter = 0;
-				in_out_vrr->fixed.fixed_active = true;
-			}
-		}
+		in_out_vrr->btr.btr_active = true;
 	}
 
 	/* BTR set to "not active" so disengage */
 	if (!in_out_vrr->btr.btr_active) {
-		in_out_vrr->btr.btr_active = false;
 		in_out_vrr->btr.inserted_duration_in_us = 0;
 		in_out_vrr->btr.frames_to_insert = 0;
 		in_out_vrr->btr.frame_counter = 0;
@@ -375,7 +351,12 @@ static void apply_fixed_refresh(struct core_freesync *core_freesync,
 	bool update = false;
 	unsigned int max_render_time_in_us = in_out_vrr->max_duration_in_us;
 
-	if (last_render_time_in_us + BTR_EXIT_MARGIN < max_render_time_in_us) {
+	//Compute the exit refresh rate and exit frame duration
+	unsigned int exit_refresh_rate_in_milli_hz = ((1000000000/max_render_time_in_us)
+			+ (1000*FIXED_REFRESH_EXIT_MARGIN_IN_HZ));
+	unsigned int exit_frame_duration_in_us = 1000000000/exit_refresh_rate_in_milli_hz;
+
+	if (last_render_time_in_us < exit_frame_duration_in_us) {
 		/* Exit Fixed Refresh mode */
 		if (in_out_vrr->fixed.fixed_active) {
 			in_out_vrr->fixed.frame_counter++;

commit c2791297013e531d1b7d8e17722bebec69386ab2
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Thu Aug 30 09:37:22 2018 -0400

    drm/amd/display: Add color bit info to freesync infoframe
    
    Parse the native color bit and send it to freesync module for future
    use
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index e1688902a1b0..4018c7180d00 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -480,22 +480,11 @@ bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
 	return false;
 }
 
-void mod_freesync_build_vrr_infopacket(struct mod_freesync *mod_freesync,
-		const struct dc_stream_state *stream,
-		const struct mod_vrr_params *vrr,
-		struct dc_info_packet *infopacket)
+static void build_vrr_infopacket_header_v1(enum signal_type signal,
+		struct dc_info_packet *infopacket,
+		unsigned int *payload_size)
 {
-	/* SPD info packet for FreeSync */
-	unsigned char checksum = 0;
-	unsigned int idx, payload_size = 0;
-
-	/* Check if Freesync is supported. Return if false. If true,
-	 * set the corresponding bit in the info packet
-	 */
-	if (!vrr->supported || !vrr->send_vsif)
-		return;
-
-	if (dc_is_hdmi_signal(stream->signal)) {
+	if (dc_is_hdmi_signal(signal)) {
 
 		/* HEADER */
 
@@ -510,9 +499,9 @@ void mod_freesync_build_vrr_infopacket(struct mod_freesync *mod_freesync,
 		/* HB2  = [Bits 7:5 = 0] [Bits 4:0 = Length = 0x08] */
 		infopacket->hb2 = 0x08;
 
-		payload_size = 0x08;
+		*payload_size = 0x08;
 
-	} else if (dc_is_dp_signal(stream->signal)) {
+	} else if (dc_is_dp_signal(signal)) {
 
 		/* HEADER */
 
@@ -536,9 +525,62 @@ void mod_freesync_build_vrr_infopacket(struct mod_freesync *mod_freesync,
 		 */
 		infopacket->hb3 = 0x04;
 
-		payload_size = 0x1B;
+		*payload_size = 0x1B;
 	}
+}
+
+static void build_vrr_infopacket_header_v2(enum signal_type signal,
+		struct dc_info_packet *infopacket,
+		unsigned int *payload_size)
+{
+	if (dc_is_hdmi_signal(signal)) {
+
+		/* HEADER */
+
+		/* HB0  = Packet Type = 0x83 (Source Product
+		 *	  Descriptor InfoFrame)
+		 */
+		infopacket->hb0 = DC_HDMI_INFOFRAME_TYPE_SPD;
+
+		/* HB1  = Version = 0x02 */
+		infopacket->hb1 = 0x02;
+
+		/* HB2  = [Bits 7:5 = 0] [Bits 4:0 = Length = 0x09] */
+		infopacket->hb2 = 0x09;
+
+		*payload_size = 0x0A;
 
+	} else if (dc_is_dp_signal(signal)) {
+
+		/* HEADER */
+
+		/* HB0  = Secondary-data Packet ID = 0 - Only non-zero
+		 *	  when used to associate audio related info packets
+		 */
+		infopacket->hb0 = 0x00;
+
+		/* HB1  = Packet Type = 0x83 (Source Product
+		 *	  Descriptor InfoFrame)
+		 */
+		infopacket->hb1 = DC_HDMI_INFOFRAME_TYPE_SPD;
+
+		/* HB2  = [Bits 7:0 = Least significant eight bits -
+		 *	  For INFOFRAME, the value must be 1Bh]
+		 */
+		infopacket->hb2 = 0x1B;
+
+		/* HB3  = [Bits 7:2 = INFOFRAME SDP Version Number = 0x2]
+		 *	  [Bits 1:0 = Most significant two bits = 0x00]
+		 */
+		infopacket->hb3 = 0x08;
+
+		*payload_size = 0x1B;
+	}
+}
+
+static void build_vrr_infopacket_data(const struct mod_vrr_params *vrr,
+		struct dc_info_packet *infopacket)
+{
 	/* PB1 = 0x1A (24bit AMD IEEE OUI (0x00001A) - Byte 0) */
 	infopacket->sb[1] = 0x1A;
 
@@ -576,15 +618,39 @@ void mod_freesync_build_vrr_infopacket(struct mod_freesync *mod_freesync,
 	 */
 	infopacket->sb[8] = (unsigned char)(vrr->max_refresh_in_uhz / 1000000);
 
-	/* PB9 - PB27  = Reserved */
 
+	//FreeSync HDR
+	infopacket->sb[9] = 0;
+	infopacket->sb[10] = 0;
+}
+
+static void build_vrr_infopacket_fs2_data(enum color_transfer_func app_tf,
+		struct dc_info_packet *infopacket)
+{
+	if (app_tf != transfer_func_unknown) {
+		infopacket->valid = true;
+
+		infopacket->sb[6] |= 0x08;  // PB6 = [Bit 3 = Native Color Active]
+
+		if (app_tf == transfer_func_gamma_22) {
+			infopacket->sb[9] |= 0x04;  // PB6 = [Bit 2 = Gamma 2.2 EOTF Active]
+		}
+	}
+}
+
+static void build_vrr_infopacket_checksum(unsigned int *payload_size,
+		struct dc_info_packet *infopacket)
+{
 	/* Calculate checksum */
+	unsigned int idx = 0;
+	unsigned char checksum = 0;
+
 	checksum += infopacket->hb0;
 	checksum += infopacket->hb1;
 	checksum += infopacket->hb2;
 	checksum += infopacket->hb3;
 
-	for (idx = 1; idx <= payload_size; idx++)
+	for (idx = 1; idx <= *payload_size; idx++)
 		checksum += infopacket->sb[idx];
 
 	/* PB0 = Checksum (one byte complement) */
@@ -593,6 +659,64 @@ void mod_freesync_build_vrr_infopacket(struct mod_freesync *mod_freesync,
 	infopacket->valid = true;
 }
 
+static void build_vrr_infopacket_v1(enum signal_type signal,
+		const struct mod_vrr_params *vrr,
+		struct dc_info_packet *infopacket)
+{
+	/* SPD info packet for FreeSync */
+	unsigned int payload_size = 0;
+
+	build_vrr_infopacket_header_v1(signal, infopacket, &payload_size);
+	build_vrr_infopacket_data(vrr, infopacket);
+	build_vrr_infopacket_checksum(&payload_size, infopacket);
+
+	infopacket->valid = true;
+}
+
+static void build_vrr_infopacket_v2(enum signal_type signal,
+		const struct mod_vrr_params *vrr,
+		const enum color_transfer_func *app_tf,
+		struct dc_info_packet *infopacket)
+{
+	unsigned int payload_size = 0;
+
+	build_vrr_infopacket_header_v2(signal, infopacket, &payload_size);
+	build_vrr_infopacket_data(vrr, infopacket);
+
+	if (app_tf != NULL)
+		build_vrr_infopacket_fs2_data(*app_tf, infopacket);
+
+	build_vrr_infopacket_checksum(&payload_size, infopacket);
+
+	infopacket->valid = true;
+}
+
+void mod_freesync_build_vrr_infopacket(struct mod_freesync *mod_freesync,
+		const struct dc_stream_state *stream,
+		const struct mod_vrr_params *vrr,
+		enum vrr_packet_type packet_type,
+		const enum color_transfer_func *app_tf,
+		struct dc_info_packet *infopacket)
+{
+	/* SPD info packet for FreeSync */
+
+	/* Check if Freesync is supported. Return if false. If true,
+	 * set the corresponding bit in the info packet
+	 */
+	if (!vrr->supported || !vrr->send_vsif)
+		return;
+
+	switch (packet_type) {
+	case packet_type_fs2:
+		build_vrr_infopacket_v2(stream->signal, vrr, app_tf, infopacket);
+		break;
+	case packet_type_vrr:
+	case packet_type_fs1:
+	default:
+		build_vrr_infopacket_v1(stream->signal, vrr, infopacket);
+	}
+}
+
 void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 		const struct dc_stream_state *stream,
 		struct mod_freesync_config *in_config,

commit 69ff884526742fcb00b7509461bf8e41c87d9b10
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue May 8 17:09:49 2018 -0400

    drm/amd/display: add config for sending VSIF
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 769f46777a1d..e1688902a1b0 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -492,7 +492,7 @@ void mod_freesync_build_vrr_infopacket(struct mod_freesync *mod_freesync,
 	/* Check if Freesync is supported. Return if false. If true,
 	 * set the corresponding bit in the info packet
 	 */
-	if (!vrr->supported)
+	if (!vrr->supported || !vrr->send_vsif)
 		return;
 
 	if (dc_is_hdmi_signal(stream->signal)) {
@@ -634,6 +634,7 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 		return;
 
 	in_out_vrr->state = in_config->state;
+	in_out_vrr->send_vsif = in_config->vsif_supported;
 
 	if (in_config->state == VRR_STATE_UNSUPPORTED) {
 		in_out_vrr->state = VRR_STATE_UNSUPPORTED;

commit bf2af91cb3a4ef1c5f9132687b9818f33d6a389f
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Apr 17 11:40:31 2018 -0400

    drm/amd/display: Correct rounding calcs in mod_freesync_is_valid_range
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 349387eb9fe6..769f46777a1d 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -887,12 +887,41 @@ bool mod_freesync_is_valid_range(struct mod_freesync *mod_freesync,
 	unsigned long long nominal_field_rate_in_uhz =
 			mod_freesync_calc_nominal_field_rate(stream);
 
-	/* Allow for some rounding error of actual video timing by taking ceil.
-	 * For example, 144 Hz mode timing may actually be 143.xxx Hz when
-	 * calculated from pixel rate and vertical/horizontal totals, but
-	 * this should be allowed instead of blocking FreeSync.
+	/* Typically nominal refresh calculated can have some fractional part.
+	 * Allow for some rounding error of actual video timing by taking floor
+	 * of caps and request. Round the nominal refresh rate.
+	 *
+	 * Dividing will convert everything to units in Hz although input
+	 * variable name is in uHz!
+	 *
+	 * Also note, this takes care of rounding error on the nominal refresh
+	 * so by rounding error we only expect it to be off by a small amount,
+	 * such as < 0.1 Hz. i.e. 143.9xxx or 144.1xxx.
+	 *
+	 * Example 1. Caps    Min = 40 Hz, Max = 144 Hz
+	 *            Request Min = 40 Hz, Max = 144 Hz
+	 *                    Nominal = 143.5x Hz rounded to 144 Hz
+	 *            This function should allow this as valid request
+	 *
+	 * Example 2. Caps    Min = 40 Hz, Max = 144 Hz
+	 *            Request Min = 40 Hz, Max = 144 Hz
+	 *                    Nominal = 144.4x Hz rounded to 144 Hz
+	 *            This function should allow this as valid request
+	 *
+	 * Example 3. Caps    Min = 40 Hz, Max = 144 Hz
+	 *            Request Min = 40 Hz, Max = 144 Hz
+	 *                    Nominal = 120.xx Hz rounded to 120 Hz
+	 *            This function should return NOT valid since the requested
+	 *            max is greater than current timing's nominal
+	 *
+	 * Example 4. Caps    Min = 40 Hz, Max = 120 Hz
+	 *            Request Min = 40 Hz, Max = 120 Hz
+	 *                    Nominal = 144.xx Hz rounded to 144 Hz
+	 *            This function should return NOT valid since the nominal
+	 *            is greater than the capability's max refresh
 	 */
-	nominal_field_rate_in_uhz = div_u64(nominal_field_rate_in_uhz, 1000000);
+	nominal_field_rate_in_uhz =
+			div_u64(nominal_field_rate_in_uhz + 500000, 1000000);
 	min_refresh_cap_in_uhz /= 1000000;
 	max_refresh_cap_in_uhz /= 1000000;
 	min_refresh_request_in_uhz /= 1000000;

commit 953c2901c860da16963b48db8344bf0fd5b03040
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Fri Apr 6 13:55:39 2018 -0400

    drm/amd/display: refactor vupdate interrupt registration
    
    We only need to register once OS calls the interrupt control.
    Also, if we are entering static screen mode, disable after ramping is done.
    Disable shall be done via timer of 2 seconds regardless of ramping
    complete or not, just to simplify.
    
    Also, ramp to mid instead of min, due to better flicker performance...
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index daad60ec1ce3..349387eb9fe6 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -109,12 +109,6 @@ static unsigned int calc_duration_in_us_from_v_total(
 				* 1000) * stream->timing.h_total,
 					stream->timing.pix_clk_khz));
 
-	if (duration_in_us < in_vrr->min_duration_in_us)
-		duration_in_us = in_vrr->min_duration_in_us;
-
-	if (duration_in_us > in_vrr->max_duration_in_us)
-		duration_in_us = in_vrr->max_duration_in_us;
-
 	return duration_in_us;
 }
 
@@ -230,10 +224,9 @@ static void update_v_total_for_static_ramp(
 		}
 	}
 
-	v_total = calc_v_total_from_duration(stream,
-			in_out_vrr,
-			current_duration_in_us);
-
+	v_total = div64_u64(div64_u64(((unsigned long long)(
+			current_duration_in_us) * stream->timing.pix_clk_khz),
+				stream->timing.h_total), 1000);
 
 	in_out_vrr->adjust.v_total_min = v_total;
 	in_out_vrr->adjust.v_total_max = v_total;
@@ -702,7 +695,11 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 	} else if (in_out_vrr->state == VRR_STATE_ACTIVE_FIXED) {
 		in_out_vrr->fixed.target_refresh_in_uhz =
 				in_out_vrr->min_refresh_in_uhz;
-		if (in_out_vrr->fixed.ramping_active) {
+		if (in_out_vrr->fixed.ramping_active &&
+				in_out_vrr->fixed.fixed_active) {
+			/* Do not update vtotals if ramping is already active
+			 * in order to continue ramp from current refresh.
+			 */
 			in_out_vrr->fixed.fixed_active = true;
 		} else {
 			in_out_vrr->fixed.fixed_active = true;

commit 9410a3776bbf1e172cfdb9f8b771a5ce64081a51
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Fri Apr 6 12:12:06 2018 -0400

    drm/amd/display: fix LFC tearing at top of screen
    
    Tearing occurred because new VTOTAL MIN/MAX was being programmed
    too early.
    The flip can happen within the VUPDATE high region, and the new min/max
    would take effect immediately. But this means that frame is not variable
    anymore, and tearing would occur when the flip actually happens.
    
    The fixed insert duration should be programmed on the first VUPDATE
    interrupt instead.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index abd5c9374eb3..daad60ec1ce3 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -371,12 +371,6 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 			inserted_frame_duration_in_us;
 		in_out_vrr->btr.frames_to_insert = frames_to_insert;
 		in_out_vrr->btr.frame_counter = frames_to_insert;
-
-		in_out_vrr->adjust.v_total_min =
-			calc_v_total_from_duration(stream, in_out_vrr,
-				in_out_vrr->btr.inserted_duration_in_us);
-		in_out_vrr->adjust.v_total_max =
-				in_out_vrr->adjust.v_total_min;
 	}
 }
 

commit be922ff750e40b292824959577aa914388ff6c8b
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Apr 5 15:20:15 2018 -0400

    drm/amd/display: Add back code to allow for rounding error
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 4887c888bbe7..abd5c9374eb3 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -896,6 +896,17 @@ bool mod_freesync_is_valid_range(struct mod_freesync *mod_freesync,
 	unsigned long long nominal_field_rate_in_uhz =
 			mod_freesync_calc_nominal_field_rate(stream);
 
+	/* Allow for some rounding error of actual video timing by taking ceil.
+	 * For example, 144 Hz mode timing may actually be 143.xxx Hz when
+	 * calculated from pixel rate and vertical/horizontal totals, but
+	 * this should be allowed instead of blocking FreeSync.
+	 */
+	nominal_field_rate_in_uhz = div_u64(nominal_field_rate_in_uhz, 1000000);
+	min_refresh_cap_in_uhz /= 1000000;
+	max_refresh_cap_in_uhz /= 1000000;
+	min_refresh_request_in_uhz /= 1000000;
+	max_refresh_request_in_uhz /= 1000000;
+
 	// Check nominal is within range
 	if (nominal_field_rate_in_uhz > max_refresh_cap_in_uhz ||
 		nominal_field_rate_in_uhz < min_refresh_cap_in_uhz)
@@ -921,7 +932,7 @@ bool mod_freesync_is_valid_range(struct mod_freesync *mod_freesync,
 
 	// For variable range, check for at least 10 Hz range
 	if ((max_refresh_request_in_uhz != min_refresh_request_in_uhz) &&
-		(max_refresh_request_in_uhz - min_refresh_request_in_uhz < 10000000))
+		(max_refresh_request_in_uhz - min_refresh_request_in_uhz < 10))
 		return false;
 
 	return true;

commit 050790cc59732cd99789235cb118df23e9b42911
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Wed Apr 4 21:04:42 2018 -0400

    drm/amd/display: Fix bug that causes black screen
    
    Ignore MSA bit on DP display is usually set during SetTimings, but
    there was a case where the module thought refresh rate was not valid
    and ignore MSA bit was not set.
    
    Later, a valid refresh rate range was requested but since ignore MSA bit
    not set, it caused black screen.
    
    Issue if with how the module checked for VRR support. Fix up that logic.
    DM should call new valid_range function to determine if timing is supported.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index be6a6c63b4cc..4887c888bbe7 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -613,7 +613,6 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 {
 	struct core_freesync *core_freesync = NULL;
 	unsigned long long nominal_field_rate_in_uhz = 0;
-	bool nominal_field_rate_in_range = true;
 	unsigned int refresh_range = 0;
 	unsigned int min_refresh_in_uhz = 0;
 	unsigned int max_refresh_in_uhz = 0;
@@ -638,15 +637,6 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 	if (max_refresh_in_uhz > nominal_field_rate_in_uhz)
 		max_refresh_in_uhz = nominal_field_rate_in_uhz;
 
-	/* Allow for some rounding error of actual video timing by taking ceil.
-	 * For example, 144 Hz mode timing may actually be 143.xxx Hz when
-	 * calculated from pixel rate and vertical/horizontal totals, but
-	 * this should be allowed instead of blocking FreeSync.
-	 */
-	if ((min_refresh_in_uhz / 1000000) >
-			((nominal_field_rate_in_uhz + 1000000 - 1) / 1000000))
-		nominal_field_rate_in_range = false;
-
 	// Full range may be larger than current video timing, so cap at nominal
 	if (min_refresh_in_uhz > nominal_field_rate_in_uhz)
 		min_refresh_in_uhz = nominal_field_rate_in_uhz;
@@ -658,10 +648,14 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 
 	in_out_vrr->state = in_config->state;
 
-	if ((in_config->state == VRR_STATE_UNSUPPORTED) ||
-				(!nominal_field_rate_in_range)) {
+	if (in_config->state == VRR_STATE_UNSUPPORTED) {
 		in_out_vrr->state = VRR_STATE_UNSUPPORTED;
 		in_out_vrr->supported = false;
+		in_out_vrr->adjust.v_total_min = stream->timing.v_total;
+		in_out_vrr->adjust.v_total_max = stream->timing.v_total;
+
+		return;
+
 	} else {
 		in_out_vrr->min_refresh_in_uhz = min_refresh_in_uhz;
 		in_out_vrr->max_duration_in_us =

commit ff6014d63a87d9a801ddd9ddd10359b2dead6943
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Wed Apr 4 21:01:21 2018 -0400

    drm/amd/display: Fix bug where refresh rate becomes fixed
    
    This issue occurs if refresh rate range is very small and lfc is not used.
    When frame spikes occur, refresh rate becomes fixed and will not restore properly
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 4af73a72b9a9..be6a6c63b4cc 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -168,21 +168,6 @@ static unsigned int calc_v_total_from_duration(
 	return v_total;
 }
 
-static unsigned long long calc_nominal_field_rate(const struct dc_stream_state *stream)
-{
-	unsigned long long nominal_field_rate_in_uhz = 0;
-
-	/* Calculate nominal field rate for stream */
-	nominal_field_rate_in_uhz = stream->timing.pix_clk_khz;
-	nominal_field_rate_in_uhz *= 1000ULL * 1000ULL * 1000ULL;
-	nominal_field_rate_in_uhz = div_u64(nominal_field_rate_in_uhz,
-						stream->timing.h_total);
-	nominal_field_rate_in_uhz = div_u64(nominal_field_rate_in_uhz,
-						stream->timing.v_total);
-
-	return nominal_field_rate_in_uhz;
-}
-
 static void update_v_total_for_static_ramp(
 		struct core_freesync *core_freesync,
 		const struct dc_stream_state *stream,
@@ -441,10 +426,11 @@ static void apply_fixed_refresh(struct core_freesync *core_freesync,
 					in_out_vrr->adjust.v_total_min;
 		} else {
 			in_out_vrr->adjust.v_total_min =
-				calc_v_total_from_refresh(
-				stream, in_out_vrr->max_refresh_in_uhz);
+				calc_v_total_from_refresh(stream,
+					in_out_vrr->max_refresh_in_uhz);
 			in_out_vrr->adjust.v_total_max =
-				in_out_vrr->adjust.v_total_min;
+				calc_v_total_from_refresh(stream,
+					in_out_vrr->min_refresh_in_uhz);
 		}
 	}
 }
@@ -638,7 +624,8 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
 
 	/* Calculate nominal field rate for stream */
-	nominal_field_rate_in_uhz = calc_nominal_field_rate(stream);
+	nominal_field_rate_in_uhz =
+			mod_freesync_calc_nominal_field_rate(stream);
 
 	min_refresh_in_uhz = in_config->min_refresh_in_uhz;
 	max_refresh_in_uhz = in_config->max_refresh_in_uhz;
@@ -888,6 +875,22 @@ void mod_freesync_get_settings(struct mod_freesync *mod_freesync,
 	}
 }
 
+unsigned long long mod_freesync_calc_nominal_field_rate(
+			const struct dc_stream_state *stream)
+{
+	unsigned long long nominal_field_rate_in_uhz = 0;
+
+	/* Calculate nominal field rate for stream */
+	nominal_field_rate_in_uhz = stream->timing.pix_clk_khz;
+	nominal_field_rate_in_uhz *= 1000ULL * 1000ULL * 1000ULL;
+	nominal_field_rate_in_uhz = div_u64(nominal_field_rate_in_uhz,
+						stream->timing.h_total);
+	nominal_field_rate_in_uhz = div_u64(nominal_field_rate_in_uhz,
+						stream->timing.v_total);
+
+	return nominal_field_rate_in_uhz;
+}
+
 bool mod_freesync_is_valid_range(struct mod_freesync *mod_freesync,
 		const struct dc_stream_state *stream,
 		uint32_t min_refresh_cap_in_uhz,
@@ -897,7 +900,7 @@ bool mod_freesync_is_valid_range(struct mod_freesync *mod_freesync,
 {
 	/* Calculate nominal field rate for stream */
 	unsigned long long nominal_field_rate_in_uhz =
-			calc_nominal_field_rate(stream);
+			mod_freesync_calc_nominal_field_rate(stream);
 
 	// Check nominal is within range
 	if (nominal_field_rate_in_uhz > max_refresh_cap_in_uhz ||

commit e80e9446084168c4f186f502dd15e6241bf454a1
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Wed Apr 4 20:59:43 2018 -0400

    drm/amd/display: add method to check for supported range
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 5e12e463c06a..4af73a72b9a9 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -168,6 +168,21 @@ static unsigned int calc_v_total_from_duration(
 	return v_total;
 }
 
+static unsigned long long calc_nominal_field_rate(const struct dc_stream_state *stream)
+{
+	unsigned long long nominal_field_rate_in_uhz = 0;
+
+	/* Calculate nominal field rate for stream */
+	nominal_field_rate_in_uhz = stream->timing.pix_clk_khz;
+	nominal_field_rate_in_uhz *= 1000ULL * 1000ULL * 1000ULL;
+	nominal_field_rate_in_uhz = div_u64(nominal_field_rate_in_uhz,
+						stream->timing.h_total);
+	nominal_field_rate_in_uhz = div_u64(nominal_field_rate_in_uhz,
+						stream->timing.v_total);
+
+	return nominal_field_rate_in_uhz;
+}
+
 static void update_v_total_for_static_ramp(
 		struct core_freesync *core_freesync,
 		const struct dc_stream_state *stream,
@@ -623,12 +638,7 @@ void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
 	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
 
 	/* Calculate nominal field rate for stream */
-	nominal_field_rate_in_uhz = stream->timing.pix_clk_khz;
-	nominal_field_rate_in_uhz *= 1000ULL * 1000ULL * 1000ULL;
-	nominal_field_rate_in_uhz = div_u64(nominal_field_rate_in_uhz,
-						stream->timing.h_total);
-	nominal_field_rate_in_uhz = div_u64(nominal_field_rate_in_uhz,
-						stream->timing.v_total);
+	nominal_field_rate_in_uhz = calc_nominal_field_rate(stream);
 
 	min_refresh_in_uhz = in_config->min_refresh_in_uhz;
 	max_refresh_in_uhz = in_config->max_refresh_in_uhz;
@@ -878,3 +888,45 @@ void mod_freesync_get_settings(struct mod_freesync *mod_freesync,
 	}
 }
 
+bool mod_freesync_is_valid_range(struct mod_freesync *mod_freesync,
+		const struct dc_stream_state *stream,
+		uint32_t min_refresh_cap_in_uhz,
+		uint32_t max_refresh_cap_in_uhz,
+		uint32_t min_refresh_request_in_uhz,
+		uint32_t max_refresh_request_in_uhz)
+{
+	/* Calculate nominal field rate for stream */
+	unsigned long long nominal_field_rate_in_uhz =
+			calc_nominal_field_rate(stream);
+
+	// Check nominal is within range
+	if (nominal_field_rate_in_uhz > max_refresh_cap_in_uhz ||
+		nominal_field_rate_in_uhz < min_refresh_cap_in_uhz)
+		return false;
+
+	// If nominal is less than max, limit the max allowed refresh rate
+	if (nominal_field_rate_in_uhz < max_refresh_cap_in_uhz)
+		max_refresh_cap_in_uhz = nominal_field_rate_in_uhz;
+
+	// Don't allow min > max
+	if (min_refresh_request_in_uhz > max_refresh_request_in_uhz)
+		return false;
+
+	// Check min is within range
+	if (min_refresh_request_in_uhz > max_refresh_cap_in_uhz ||
+		min_refresh_request_in_uhz < min_refresh_cap_in_uhz)
+		return false;
+
+	// Check max is within range
+	if (max_refresh_request_in_uhz > max_refresh_cap_in_uhz ||
+		max_refresh_request_in_uhz < min_refresh_cap_in_uhz)
+		return false;
+
+	// For variable range, check for at least 10 Hz range
+	if ((max_refresh_request_in_uhz != min_refresh_request_in_uhz) &&
+		(max_refresh_request_in_uhz - min_refresh_request_in_uhz < 10000000))
+		return false;
+
+	return true;
+}
+

commit 98e6436d3af5fef7ca9b59d865dd5807ede36fb9
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Aug 21 14:40:28 2018 -0500

    drm/amd/display: Refactor FreeSync module
    
    Remove dependency on internal sink map and instead
    use existing stream and plane state
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index fa344ceafc17..5e12e463c06a 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -30,6 +30,7 @@
 
 #define MOD_FREESYNC_MAX_CONCURRENT_STREAMS  32
 
+#define MIN_REFRESH_RANGE_IN_US 10000000
 /* Refresh rate ramp at a fixed rate of 65 Hz/second */
 #define STATIC_SCREEN_RAMP_DELTA_REFRESH_RATE_PER_FRAME ((1000 / 60) * 65)
 /* Number of elements in the render times cache array */
@@ -40,103 +41,9 @@
 #define FIXED_REFRESH_ENTER_FRAME_COUNT 5
 #define FIXED_REFRESH_EXIT_FRAME_COUNT 5
 
-#define FREESYNC_REGISTRY_NAME "freesync_v1"
-
-#define FREESYNC_NO_STATIC_FOR_EXTERNAL_DP_REGKEY "DalFreeSyncNoStaticForExternalDp"
-
-#define FREESYNC_NO_STATIC_FOR_INTERNAL_REGKEY "DalFreeSyncNoStaticForInternal"
-
-#define FREESYNC_DEFAULT_REGKEY "LCDFreeSyncDefault"
-
-struct gradual_static_ramp {
-	bool ramp_is_active;
-	bool ramp_direction_is_up;
-	unsigned int ramp_current_frame_duration_in_ns;
-};
-
-struct freesync_time {
-	/* video (48Hz feature) related */
-	unsigned int update_duration_in_ns;
-
-	/* BTR/fixed refresh related */
-	unsigned int prev_time_stamp_in_us;
-
-	unsigned int min_render_time_in_us;
-	unsigned int max_render_time_in_us;
-
-	unsigned int render_times_index;
-	unsigned int render_times[RENDER_TIMES_MAX_COUNT];
-
-	unsigned int min_window;
-	unsigned int max_window;
-};
-
-struct below_the_range {
-	bool btr_active;
-	bool program_btr;
-
-	unsigned int mid_point_in_us;
-
-	unsigned int inserted_frame_duration_in_us;
-	unsigned int frames_to_insert;
-	unsigned int frame_counter;
-};
-
-struct fixed_refresh {
-	bool fixed_active;
-	bool program_fixed;
-	unsigned int frame_counter;
-};
-
-struct freesync_range {
-	unsigned int min_refresh;
-	unsigned int max_frame_duration;
-	unsigned int vmax;
-
-	unsigned int max_refresh;
-	unsigned int min_frame_duration;
-	unsigned int vmin;
-};
-
-struct freesync_state {
-	bool fullscreen;
-	bool static_screen;
-	bool video;
-
-	unsigned int vmin;
-	unsigned int vmax;
-
-	struct freesync_time time;
-
-	unsigned int nominal_refresh_rate_in_micro_hz;
-	bool windowed_fullscreen;
-
-	struct gradual_static_ramp static_ramp;
-	struct below_the_range btr;
-	struct fixed_refresh fixed_refresh;
-	struct freesync_range freesync_range;
-};
-
-struct freesync_entity {
-	struct dc_stream_state *stream;
-	struct mod_freesync_caps *caps;
-	struct freesync_state state;
-	struct mod_freesync_user_enable user_enable;
-};
-
-struct freesync_registry_options {
-	bool drr_external_supported;
-	bool drr_internal_supported;
-	bool lcd_freesync_default_set;
-	int lcd_freesync_default_value;
-};
-
 struct core_freesync {
 	struct mod_freesync public;
 	struct dc *dc;
-	struct freesync_registry_options opts;
-	struct freesync_entity *map;
-	int num_entities;
 };
 
 #define MOD_FREESYNC_TO_CORE(mod_freesync)\
@@ -147,69 +54,16 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 	struct core_freesync *core_freesync =
 			kzalloc(sizeof(struct core_freesync), GFP_KERNEL);
 
-
-	struct persistent_data_flag flag;
-
-	int i, data = 0;
-
 	if (core_freesync == NULL)
 		goto fail_alloc_context;
 
-	core_freesync->map = kcalloc(MOD_FREESYNC_MAX_CONCURRENT_STREAMS,
-					sizeof(struct freesync_entity),
-					GFP_KERNEL);
-
-	if (core_freesync->map == NULL)
-		goto fail_alloc_map;
-
-	for (i = 0; i < MOD_FREESYNC_MAX_CONCURRENT_STREAMS; i++)
-		core_freesync->map[i].stream = NULL;
-
-	core_freesync->num_entities = 0;
-
 	if (dc == NULL)
 		goto fail_construct;
 
 	core_freesync->dc = dc;
-
-	/* Create initial module folder in registry for freesync enable data */
-	flag.save_per_edid = true;
-	flag.save_per_link = false;
-	dm_write_persistent_data(dc->ctx, NULL, FREESYNC_REGISTRY_NAME,
-			NULL, NULL, 0, &flag);
-	flag.save_per_edid = false;
-	flag.save_per_link = false;
-
-	if (dm_read_persistent_data(dc->ctx, NULL, NULL,
-			FREESYNC_NO_STATIC_FOR_INTERNAL_REGKEY,
-			&data, sizeof(data), &flag)) {
-		core_freesync->opts.drr_internal_supported =
-			(data & 1) ? false : true;
-	}
-
-	if (dm_read_persistent_data(dc->ctx, NULL, NULL,
-			FREESYNC_NO_STATIC_FOR_EXTERNAL_DP_REGKEY,
-			&data, sizeof(data), &flag)) {
-		core_freesync->opts.drr_external_supported =
-				(data & 1) ? false : true;
-	}
-
-	if (dm_read_persistent_data(dc->ctx, NULL, NULL,
-			FREESYNC_DEFAULT_REGKEY,
-			&data, sizeof(data), &flag)) {
-		core_freesync->opts.lcd_freesync_default_set = true;
-		core_freesync->opts.lcd_freesync_default_value = data;
-	} else {
-		core_freesync->opts.lcd_freesync_default_set = false;
-		core_freesync->opts.lcd_freesync_default_value = 0;
-	}
-
 	return &core_freesync->public;
 
 fail_construct:
-	kfree(core_freesync->map);
-
-fail_alloc_map:
 	kfree(core_freesync);
 
 fail_alloc_context:
@@ -218,968 +72,396 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 
 void mod_freesync_destroy(struct mod_freesync *mod_freesync)
 {
-	if (mod_freesync != NULL) {
-		int i;
-		struct core_freesync *core_freesync =
-				MOD_FREESYNC_TO_CORE(mod_freesync);
-
-		for (i = 0; i < core_freesync->num_entities; i++)
-			if (core_freesync->map[i].stream)
-				dc_stream_release(core_freesync->map[i].stream);
-
-		kfree(core_freesync->map);
-
-		kfree(core_freesync);
-	}
-}
-
-/* Given a specific dc_stream* this function finds its equivalent
- * on the core_freesync->map and returns the corresponding index
- */
-static unsigned int map_index_from_stream(struct core_freesync *core_freesync,
-		struct dc_stream_state *stream)
-{
-	unsigned int index = 0;
-
-	for (index = 0; index < core_freesync->num_entities; index++) {
-		if (core_freesync->map[index].stream == stream) {
-			return index;
-		}
-	}
-	/* Could not find stream requested */
-	ASSERT(false);
-	return index;
-}
-
-bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
-		struct dc_stream_state *stream, struct mod_freesync_caps *caps)
-{
-	struct dc  *dc = NULL;
 	struct core_freesync *core_freesync = NULL;
-	int persistent_freesync_enable = 0;
-	struct persistent_data_flag flag;
-	unsigned int nom_refresh_rate_uhz;
-	unsigned long long temp;
-
 	if (mod_freesync == NULL)
-		return false;
-
+		return;
 	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	dc = core_freesync->dc;
-
-	flag.save_per_edid = true;
-	flag.save_per_link = false;
-
-	if (core_freesync->num_entities < MOD_FREESYNC_MAX_CONCURRENT_STREAMS) {
-
-		dc_stream_retain(stream);
-
-		temp = stream->timing.pix_clk_khz;
-		temp *= 1000ULL * 1000ULL * 1000ULL;
-		temp = div_u64(temp, stream->timing.h_total);
-		temp = div_u64(temp, stream->timing.v_total);
-
-		nom_refresh_rate_uhz = (unsigned int) temp;
-
-		core_freesync->map[core_freesync->num_entities].stream = stream;
-		core_freesync->map[core_freesync->num_entities].caps = caps;
-
-		core_freesync->map[core_freesync->num_entities].state.
-			fullscreen = false;
-		core_freesync->map[core_freesync->num_entities].state.
-			static_screen = false;
-		core_freesync->map[core_freesync->num_entities].state.
-			video = false;
-		core_freesync->map[core_freesync->num_entities].state.time.
-			update_duration_in_ns = 0;
-		core_freesync->map[core_freesync->num_entities].state.
-			static_ramp.ramp_is_active = false;
-
-		/* get persistent data from registry */
-		if (dm_read_persistent_data(dc->ctx, stream->sink,
-					FREESYNC_REGISTRY_NAME,
-					"userenable", &persistent_freesync_enable,
-					sizeof(int), &flag)) {
-			core_freesync->map[core_freesync->num_entities].user_enable.
-				enable_for_gaming =
-				(persistent_freesync_enable & 1) ? true : false;
-			core_freesync->map[core_freesync->num_entities].user_enable.
-				enable_for_static =
-				(persistent_freesync_enable & 2) ? true : false;
-			core_freesync->map[core_freesync->num_entities].user_enable.
-				enable_for_video =
-				(persistent_freesync_enable & 4) ? true : false;
-		/* If FreeSync display and LCDFreeSyncDefault is set, use as default values write back to userenable */
-		} else if (caps->supported && (core_freesync->opts.lcd_freesync_default_set)) {
-			core_freesync->map[core_freesync->num_entities].user_enable.enable_for_gaming =
-				(core_freesync->opts.lcd_freesync_default_value & 1) ? true : false;
-			core_freesync->map[core_freesync->num_entities].user_enable.enable_for_static =
-				(core_freesync->opts.lcd_freesync_default_value & 2) ? true : false;
-			core_freesync->map[core_freesync->num_entities].user_enable.enable_for_video =
-				(core_freesync->opts.lcd_freesync_default_value & 4) ? true : false;
-			dm_write_persistent_data(dc->ctx, stream->sink,
-						FREESYNC_REGISTRY_NAME,
-						"userenable", &core_freesync->opts.lcd_freesync_default_value,
-						sizeof(int), &flag);
-		} else {
-			core_freesync->map[core_freesync->num_entities].user_enable.
-					enable_for_gaming = false;
-			core_freesync->map[core_freesync->num_entities].user_enable.
-					enable_for_static = false;
-			core_freesync->map[core_freesync->num_entities].user_enable.
-					enable_for_video = false;
-		}
-
-		if (caps->supported &&
-			nom_refresh_rate_uhz >= caps->min_refresh_in_micro_hz &&
-			nom_refresh_rate_uhz <= caps->max_refresh_in_micro_hz)
-			stream->ignore_msa_timing_param = 1;
-
-		core_freesync->num_entities++;
-		return true;
-	}
-	return false;
+	kfree(core_freesync);
 }
 
-bool mod_freesync_remove_stream(struct mod_freesync *mod_freesync,
-		struct dc_stream_state *stream)
+#if 0 /* unused currently */
+static unsigned int calc_refresh_in_uhz_from_duration(
+		unsigned int duration_in_ns)
 {
-	int i = 0;
-	struct core_freesync *core_freesync = NULL;
-	unsigned int index = 0;
-
-	if (mod_freesync == NULL)
-		return false;
+	unsigned int refresh_in_uhz =
+			((unsigned int)(div64_u64((1000000000ULL * 1000000),
+					duration_in_ns)));
+	return refresh_in_uhz;
+}
+#endif
 
-	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	index = map_index_from_stream(core_freesync, stream);
-
-	dc_stream_release(core_freesync->map[index].stream);
-	core_freesync->map[index].stream = NULL;
-	/* To remove this entity, shift everything after down */
-	for (i = index; i < core_freesync->num_entities - 1; i++)
-		core_freesync->map[i] = core_freesync->map[i + 1];
-	core_freesync->num_entities--;
-	return true;
+static unsigned int calc_duration_in_us_from_refresh_in_uhz(
+		unsigned int refresh_in_uhz)
+{
+	unsigned int duration_in_us =
+			((unsigned int)(div64_u64((1000000000ULL * 1000),
+					refresh_in_uhz)));
+	return duration_in_us;
 }
 
-static void adjust_vmin_vmax(struct core_freesync *core_freesync,
-				struct dc_stream_state **streams,
-				int num_streams,
-				int map_index,
-				unsigned int v_total_min,
-				unsigned int v_total_max)
+static unsigned int calc_duration_in_us_from_v_total(
+		const struct dc_stream_state *stream,
+		const struct mod_vrr_params *in_vrr,
+		unsigned int v_total)
 {
-	if (num_streams == 0 || streams == NULL || num_streams > 1)
-		return;
+	unsigned int duration_in_us =
+			(unsigned int)(div64_u64(((unsigned long long)(v_total)
+				* 1000) * stream->timing.h_total,
+					stream->timing.pix_clk_khz));
 
-	core_freesync->map[map_index].state.vmin = v_total_min;
-	core_freesync->map[map_index].state.vmax = v_total_max;
+	if (duration_in_us < in_vrr->min_duration_in_us)
+		duration_in_us = in_vrr->min_duration_in_us;
 
-	dc_stream_adjust_vmin_vmax(core_freesync->dc, streams,
-				num_streams, v_total_min,
-				v_total_max);
-}
+	if (duration_in_us > in_vrr->max_duration_in_us)
+		duration_in_us = in_vrr->max_duration_in_us;
 
+	return duration_in_us;
+}
 
-static void update_stream_freesync_context(struct core_freesync *core_freesync,
-		struct dc_stream_state *stream)
+static unsigned int calc_v_total_from_refresh(
+		const struct dc_stream_state *stream,
+		unsigned int refresh_in_uhz)
 {
-	unsigned int index;
-	struct freesync_context *ctx;
+	unsigned int v_total = stream->timing.v_total;
+	unsigned int frame_duration_in_ns;
 
-	ctx = &stream->freesync_ctx;
+	frame_duration_in_ns =
+			((unsigned int)(div64_u64((1000000000ULL * 1000000),
+					refresh_in_uhz)));
 
-	index = map_index_from_stream(core_freesync, stream);
+	v_total = div64_u64(div64_u64(((unsigned long long)(
+			frame_duration_in_ns) * stream->timing.pix_clk_khz),
+			stream->timing.h_total), 1000000);
 
-	ctx->supported = core_freesync->map[index].caps->supported;
-	ctx->enabled = (core_freesync->map[index].user_enable.enable_for_gaming ||
-		core_freesync->map[index].user_enable.enable_for_video ||
-		core_freesync->map[index].user_enable.enable_for_static);
-	ctx->active = (core_freesync->map[index].state.fullscreen ||
-		core_freesync->map[index].state.video ||
-		core_freesync->map[index].state.static_ramp.ramp_is_active);
-	ctx->min_refresh_in_micro_hz =
-			core_freesync->map[index].caps->min_refresh_in_micro_hz;
-	ctx->nominal_refresh_in_micro_hz = core_freesync->
-		map[index].state.nominal_refresh_rate_in_micro_hz;
+	/* v_total cannot be less than nominal */
+	if (v_total < stream->timing.v_total) {
+		ASSERT(v_total < stream->timing.v_total);
+		v_total = stream->timing.v_total;
+	}
 
+	return v_total;
 }
 
-static void update_stream(struct core_freesync *core_freesync,
-		struct dc_stream_state *stream)
+static unsigned int calc_v_total_from_duration(
+		const struct dc_stream_state *stream,
+		const struct mod_vrr_params *vrr,
+		unsigned int duration_in_us)
 {
-	unsigned int index = map_index_from_stream(core_freesync, stream);
-	if (core_freesync->map[index].caps->supported) {
-		stream->ignore_msa_timing_param = 1;
-		update_stream_freesync_context(core_freesync, stream);
-	}
-}
+	unsigned int v_total = 0;
 
-static void calc_freesync_range(struct core_freesync *core_freesync,
-		struct dc_stream_state *stream,
-		struct freesync_state *state,
-		unsigned int min_refresh_in_uhz,
-		unsigned int max_refresh_in_uhz)
-{
-	unsigned int min_frame_duration_in_ns = 0, max_frame_duration_in_ns = 0;
-	unsigned int index = map_index_from_stream(core_freesync, stream);
-	uint32_t vtotal = stream->timing.v_total;
-
-	if ((min_refresh_in_uhz == 0) || (max_refresh_in_uhz == 0)) {
-		state->freesync_range.min_refresh =
-				state->nominal_refresh_rate_in_micro_hz;
-		state->freesync_range.max_refresh =
-				state->nominal_refresh_rate_in_micro_hz;
+	if (duration_in_us < vrr->min_duration_in_us)
+		duration_in_us = vrr->min_duration_in_us;
 
-		state->freesync_range.max_frame_duration = 0;
-		state->freesync_range.min_frame_duration = 0;
+	if (duration_in_us > vrr->max_duration_in_us)
+		duration_in_us = vrr->max_duration_in_us;
 
-		state->freesync_range.vmax = vtotal;
-		state->freesync_range.vmin = vtotal;
-
-		return;
-	}
+	v_total = div64_u64(div64_u64(((unsigned long long)(
+				duration_in_us) * stream->timing.pix_clk_khz),
+				stream->timing.h_total), 1000);
 
-	min_frame_duration_in_ns = ((unsigned int) (div64_u64(
-					(1000000000ULL * 1000000),
-					max_refresh_in_uhz)));
-	max_frame_duration_in_ns = ((unsigned int) (div64_u64(
-		(1000000000ULL * 1000000),
-		min_refresh_in_uhz)));
-
-	state->freesync_range.min_refresh = min_refresh_in_uhz;
-	state->freesync_range.max_refresh = max_refresh_in_uhz;
-
-	state->freesync_range.max_frame_duration = max_frame_duration_in_ns;
-	state->freesync_range.min_frame_duration = min_frame_duration_in_ns;
-
-	state->freesync_range.vmax = div64_u64(div64_u64(((unsigned long long)(
-		max_frame_duration_in_ns) * stream->timing.pix_clk_khz),
-		stream->timing.h_total), 1000000);
-	state->freesync_range.vmin = div64_u64(div64_u64(((unsigned long long)(
-		min_frame_duration_in_ns) * stream->timing.pix_clk_khz),
-		stream->timing.h_total), 1000000);
-
-	/* vmin/vmax cannot be less than vtotal */
-	if (state->freesync_range.vmin < vtotal) {
-		/* Error of 1 is permissible */
-		ASSERT((state->freesync_range.vmin + 1) >= vtotal);
-		state->freesync_range.vmin = vtotal;
+	/* v_total cannot be less than nominal */
+	if (v_total < stream->timing.v_total) {
+		ASSERT(v_total < stream->timing.v_total);
+		v_total = stream->timing.v_total;
 	}
 
-	if (state->freesync_range.vmax < vtotal) {
-		/* Error of 1 is permissible */
-		ASSERT((state->freesync_range.vmax + 1) >= vtotal);
-		state->freesync_range.vmax = vtotal;
-	}
-
-	/* Determine whether BTR can be supported */
-	if (max_frame_duration_in_ns >=
-			2 * min_frame_duration_in_ns)
-		core_freesync->map[index].caps->btr_supported = true;
-	else
-		core_freesync->map[index].caps->btr_supported = false;
-
-	/* Cache the time variables */
-	state->time.max_render_time_in_us =
-		max_frame_duration_in_ns / 1000;
-	state->time.min_render_time_in_us =
-		min_frame_duration_in_ns / 1000;
-	state->btr.mid_point_in_us =
-		(max_frame_duration_in_ns +
-		min_frame_duration_in_ns) / 2000;
+	return v_total;
 }
 
-static void calc_v_total_from_duration(struct dc_stream_state *stream,
-		unsigned int duration_in_ns, int *v_total_nominal)
+static void update_v_total_for_static_ramp(
+		struct core_freesync *core_freesync,
+		const struct dc_stream_state *stream,
+		struct mod_vrr_params *in_out_vrr)
 {
-	*v_total_nominal = div64_u64(div64_u64(((unsigned long long)(
-				duration_in_ns) * stream->timing.pix_clk_khz),
-				stream->timing.h_total), 1000000);
-}
-
-static void calc_v_total_for_static_ramp(struct core_freesync *core_freesync,
-		struct dc_stream_state *stream,
-		unsigned int index, int *v_total)
-{
-	unsigned int frame_duration = 0;
-
-	struct gradual_static_ramp *static_ramp_variables =
-				&core_freesync->map[index].state.static_ramp;
+	unsigned int v_total = 0;
+	unsigned int current_duration_in_us =
+			calc_duration_in_us_from_v_total(
+				stream, in_out_vrr,
+				in_out_vrr->adjust.v_total_max);
+	unsigned int target_duration_in_us =
+			calc_duration_in_us_from_refresh_in_uhz(
+				in_out_vrr->fixed.target_refresh_in_uhz);
+	bool ramp_direction_is_up = (current_duration_in_us >
+				target_duration_in_us) ? true : false;
 
 	/* Calc ratio between new and current frame duration with 3 digit */
 	unsigned int frame_duration_ratio = div64_u64(1000000,
 		(1000 +  div64_u64(((unsigned long long)(
 		STATIC_SCREEN_RAMP_DELTA_REFRESH_RATE_PER_FRAME) *
-		static_ramp_variables->ramp_current_frame_duration_in_ns),
-		1000000000)));
+		current_duration_in_us),
+		1000000)));
 
-	/* Calculate delta between new and current frame duration in ns */
+	/* Calculate delta between new and current frame duration in us */
 	unsigned int frame_duration_delta = div64_u64(((unsigned long long)(
-		static_ramp_variables->ramp_current_frame_duration_in_ns) *
+		current_duration_in_us) *
 		(1000 - frame_duration_ratio)), 1000);
 
 	/* Adjust frame duration delta based on ratio between current and
 	 * standard frame duration (frame duration at 60 Hz refresh rate).
 	 */
 	unsigned int ramp_rate_interpolated = div64_u64(((unsigned long long)(
-		frame_duration_delta) * static_ramp_variables->
-		ramp_current_frame_duration_in_ns), 16666666);
+		frame_duration_delta) * current_duration_in_us), 16666);
 
 	/* Going to a higher refresh rate (lower frame duration) */
-	if (static_ramp_variables->ramp_direction_is_up) {
+	if (ramp_direction_is_up) {
 		/* reduce frame duration */
-		static_ramp_variables->ramp_current_frame_duration_in_ns -=
-			ramp_rate_interpolated;
-
-		/* min frame duration */
-		frame_duration = ((unsigned int) (div64_u64(
-			(1000000000ULL * 1000000),
-			core_freesync->map[index].state.
-			nominal_refresh_rate_in_micro_hz)));
+		current_duration_in_us -= ramp_rate_interpolated;
 
 		/* adjust for frame duration below min */
-		if (static_ramp_variables->ramp_current_frame_duration_in_ns <=
-			frame_duration) {
-
-			static_ramp_variables->ramp_is_active = false;
-			static_ramp_variables->
-				ramp_current_frame_duration_in_ns =
-				frame_duration;
+		if (current_duration_in_us <= target_duration_in_us) {
+			in_out_vrr->fixed.ramping_active = false;
+			in_out_vrr->fixed.ramping_done = true;
+			current_duration_in_us =
+				calc_duration_in_us_from_refresh_in_uhz(
+				in_out_vrr->fixed.target_refresh_in_uhz);
 		}
 	/* Going to a lower refresh rate (larger frame duration) */
 	} else {
 		/* increase frame duration */
-		static_ramp_variables->ramp_current_frame_duration_in_ns +=
-			ramp_rate_interpolated;
-
-		/* max frame duration */
-		frame_duration = ((unsigned int) (div64_u64(
-			(1000000000ULL * 1000000),
-			core_freesync->map[index].caps->min_refresh_in_micro_hz)));
+		current_duration_in_us += ramp_rate_interpolated;
 
 		/* adjust for frame duration above max */
-		if (static_ramp_variables->ramp_current_frame_duration_in_ns >=
-			frame_duration) {
-
-			static_ramp_variables->ramp_is_active = false;
-			static_ramp_variables->
-				ramp_current_frame_duration_in_ns =
-				frame_duration;
+		if (current_duration_in_us >= target_duration_in_us) {
+			in_out_vrr->fixed.ramping_active = false;
+			in_out_vrr->fixed.ramping_done = true;
+			current_duration_in_us =
+				calc_duration_in_us_from_refresh_in_uhz(
+				in_out_vrr->fixed.target_refresh_in_uhz);
 		}
 	}
 
-	calc_v_total_from_duration(stream, static_ramp_variables->
-		ramp_current_frame_duration_in_ns, v_total);
-}
-
-static void reset_freesync_state_variables(struct freesync_state* state)
-{
-	state->static_ramp.ramp_is_active = false;
-	if (state->nominal_refresh_rate_in_micro_hz)
-		state->static_ramp.ramp_current_frame_duration_in_ns =
-			((unsigned int) (div64_u64(
-			(1000000000ULL * 1000000),
-			state->nominal_refresh_rate_in_micro_hz)));
-
-	state->btr.btr_active = false;
-	state->btr.frame_counter = 0;
-	state->btr.frames_to_insert = 0;
-	state->btr.inserted_frame_duration_in_us = 0;
-	state->btr.program_btr = false;
-
-	state->fixed_refresh.fixed_active = false;
-	state->fixed_refresh.program_fixed = false;
-}
-/*
- * Sets freesync mode on a stream depending on current freesync state.
- */
-static bool set_freesync_on_streams(struct core_freesync *core_freesync,
-		struct dc_stream_state **streams, int num_streams)
-{
-	int v_total_nominal = 0, v_total_min = 0, v_total_max = 0;
-	unsigned int stream_idx, map_index = 0;
-	struct freesync_state *state;
+	v_total = calc_v_total_from_duration(stream,
+			in_out_vrr,
+			current_duration_in_us);
 
-	if (num_streams == 0 || streams == NULL || num_streams > 1)
-		return false;
 
-	for (stream_idx = 0; stream_idx < num_streams; stream_idx++) {
-
-		map_index = map_index_from_stream(core_freesync,
-				streams[stream_idx]);
-
-		state = &core_freesync->map[map_index].state;
-
-		if (core_freesync->map[map_index].caps->supported) {
-
-			/* Fullscreen has the topmost priority. If the
-			 * fullscreen bit is set, we are in a fullscreen
-			 * application where it should not matter if it is
-			 * static screen. We should not check the static_screen
-			 * or video bit.
-			 *
-			 * Special cases of fullscreen include btr and fixed
-			 * refresh. We program btr on every flip and involves
-			 * programming full range right before the last inserted frame.
-			 * However, we do not want to program the full freesync range
-			 * when fixed refresh is active, because we only program
-			 * that logic once and this will override it.
-			 */
-			if (core_freesync->map[map_index].user_enable.
-				enable_for_gaming == true &&
-				state->fullscreen == true &&
-				state->fixed_refresh.fixed_active == false) {
-				/* Enable freesync */
-
-				v_total_min = state->freesync_range.vmin;
-				v_total_max = state->freesync_range.vmax;
-
-				/* Update the freesync context for the stream */
-				update_stream_freesync_context(core_freesync,
-						streams[stream_idx]);
-
-				adjust_vmin_vmax(core_freesync, streams,
-						num_streams, map_index,
-						v_total_min,
-						v_total_max);
-
-				return true;
-
-			} else if (core_freesync->map[map_index].user_enable.
-				enable_for_video && state->video == true) {
-				/* Enable 48Hz feature */
-
-				calc_v_total_from_duration(streams[stream_idx],
-					state->time.update_duration_in_ns,
-					&v_total_nominal);
-
-				/* Program only if v_total_nominal is in range*/
-				if (v_total_nominal >=
-					streams[stream_idx]->timing.v_total) {
-
-					/* Update the freesync context for
-					 * the stream
-					 */
-					update_stream_freesync_context(
-						core_freesync,
-						streams[stream_idx]);
-
-					adjust_vmin_vmax(
-						core_freesync, streams,
-						num_streams, map_index,
-						v_total_nominal,
-						v_total_nominal);
-				}
-				return true;
-
-			} else {
-				/* Disable freesync */
-				v_total_nominal = streams[stream_idx]->
-					timing.v_total;
-
-				/* Update the freesync context for
-				 * the stream
-				 */
-				update_stream_freesync_context(
-					core_freesync,
-					streams[stream_idx]);
-
-				adjust_vmin_vmax(core_freesync, streams,
-						num_streams, map_index,
-						v_total_nominal,
-						v_total_nominal);
-
-				/* Reset the cached variables */
-				reset_freesync_state_variables(state);
-
-				return true;
-			}
-		} else {
-			/* Disable freesync */
-			v_total_nominal = streams[stream_idx]->
-				timing.v_total;
-			/*
-			 * we have to reset drr always even sink does
-			 * not support freesync because a former stream has
-			 * be programmed
-			 */
-			adjust_vmin_vmax(core_freesync, streams,
-						num_streams, map_index,
-						v_total_nominal,
-						v_total_nominal);
-			/* Reset the cached variables */
-			reset_freesync_state_variables(state);
-		}
-
-	}
-
-	return false;
+	in_out_vrr->adjust.v_total_min = v_total;
+	in_out_vrr->adjust.v_total_max = v_total;
 }
 
-static void set_static_ramp_variables(struct core_freesync *core_freesync,
-		unsigned int index, bool enable_static_screen)
-{
-	unsigned int frame_duration = 0;
-	unsigned int nominal_refresh_rate = core_freesync->map[index].state.
-			nominal_refresh_rate_in_micro_hz;
-	unsigned int min_refresh_rate= core_freesync->map[index].caps->
-			min_refresh_in_micro_hz;
-	struct gradual_static_ramp *static_ramp_variables =
-			&core_freesync->map[index].state.static_ramp;
-
-	/* If we are ENABLING static screen, refresh rate should go DOWN.
-	 * If we are DISABLING static screen, refresh rate should go UP.
-	 */
-	if (enable_static_screen)
-		static_ramp_variables->ramp_direction_is_up = false;
-	else
-		static_ramp_variables->ramp_direction_is_up = true;
-
-	/* If ramp is not active, set initial frame duration depending on
-	 * whether we are enabling/disabling static screen mode. If the ramp is
-	 * already active, ramp should continue in the opposite direction
-	 * starting with the current frame duration
-	 */
-	if (!static_ramp_variables->ramp_is_active) {
-		if (enable_static_screen == true) {
-			/* Going to lower refresh rate, so start from max
-			 * refresh rate (min frame duration)
-			 */
-			frame_duration = ((unsigned int) (div64_u64(
-				(1000000000ULL * 1000000),
-				nominal_refresh_rate)));
-		} else {
-			/* Going to higher refresh rate, so start from min
-			 * refresh rate (max frame duration)
-			 */
-			frame_duration = ((unsigned int) (div64_u64(
-				(1000000000ULL * 1000000),
-				min_refresh_rate)));
-		}
-		static_ramp_variables->
-			ramp_current_frame_duration_in_ns = frame_duration;
-
-		static_ramp_variables->ramp_is_active = true;
-	}
-}
-
-void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
-		struct dc_stream_state **streams, int num_streams)
+static void apply_below_the_range(struct core_freesync *core_freesync,
+		const struct dc_stream_state *stream,
+		unsigned int last_render_time_in_us,
+		struct mod_vrr_params *in_out_vrr)
 {
-	unsigned int index, v_total, inserted_frame_v_total = 0;
-	unsigned int min_frame_duration_in_ns, vmax, vmin = 0;
-	struct freesync_state *state;
-	struct core_freesync *core_freesync = NULL;
-	struct dc_static_screen_events triggers = {0};
-
-	if (mod_freesync == NULL)
-		return;
-
-	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-
-	if (core_freesync->num_entities == 0)
-		return;
-
-	index = map_index_from_stream(core_freesync,
-		streams[0]);
-
-	if (core_freesync->map[index].caps->supported == false)
-		return;
-
-	state = &core_freesync->map[index].state;
-
-	/* Below the Range Logic */
-
-	/* Only execute if in fullscreen mode */
-	if (state->fullscreen == true &&
-		core_freesync->map[index].user_enable.enable_for_gaming &&
-		core_freesync->map[index].caps->btr_supported &&
-		state->btr.btr_active) {
+	unsigned int inserted_frame_duration_in_us = 0;
+	unsigned int mid_point_frames_ceil = 0;
+	unsigned int mid_point_frames_floor = 0;
+	unsigned int frame_time_in_us = 0;
+	unsigned int delta_from_mid_point_in_us_1 = 0xFFFFFFFF;
+	unsigned int delta_from_mid_point_in_us_2 = 0xFFFFFFFF;
+	unsigned int frames_to_insert = 0;
+	unsigned int min_frame_duration_in_ns = 0;
+	unsigned int max_render_time_in_us = in_out_vrr->max_duration_in_us;
 
-		/* TODO: pass in flag for Pre-DCE12 ASIC
-		 * in order for frame variable duration to take affect,
-		 * it needs to be done one VSYNC early, which is at
-		 * frameCounter == 1.
-		 * For DCE12 and newer updates to V_TOTAL_MIN/MAX
-		 * will take affect on current frame
-		 */
-		if (state->btr.frames_to_insert == state->btr.frame_counter) {
+	min_frame_duration_in_ns = ((unsigned int) (div64_u64(
+		(1000000000ULL * 1000000),
+		in_out_vrr->max_refresh_in_uhz)));
 
-			min_frame_duration_in_ns = ((unsigned int) (div64_u64(
-					(1000000000ULL * 1000000),
-					state->nominal_refresh_rate_in_micro_hz)));
+	/* Program BTR */
+	if (last_render_time_in_us + BTR_EXIT_MARGIN < max_render_time_in_us) {
+		/* Exit Below the Range */
+		if (in_out_vrr->btr.btr_active) {
+			in_out_vrr->btr.frame_counter = 0;
+			in_out_vrr->btr.btr_active = false;
 
-			vmin = state->freesync_range.vmin;
+		/* Exit Fixed Refresh mode */
+		} else if (in_out_vrr->fixed.fixed_active) {
 
-			inserted_frame_v_total = vmin;
+			in_out_vrr->fixed.frame_counter++;
 
-			if (min_frame_duration_in_ns / 1000)
-				inserted_frame_v_total =
-					state->btr.inserted_frame_duration_in_us *
-					vmin / (min_frame_duration_in_ns / 1000);
+			if (in_out_vrr->fixed.frame_counter >
+					FIXED_REFRESH_EXIT_FRAME_COUNT) {
+				in_out_vrr->fixed.frame_counter = 0;
+				in_out_vrr->fixed.fixed_active = false;
+			}
+		}
+	} else if (last_render_time_in_us > max_render_time_in_us) {
+		/* Enter Below the Range */
+		if (!in_out_vrr->btr.btr_active &&
+				in_out_vrr->btr.btr_enabled) {
+			in_out_vrr->btr.btr_active = true;
 
-			/* Set length of inserted frames as v_total_max*/
-			vmax = inserted_frame_v_total;
-			vmin = inserted_frame_v_total;
+		/* Enter Fixed Refresh mode */
+		} else if (!in_out_vrr->fixed.fixed_active &&
+				!in_out_vrr->btr.btr_enabled) {
+			in_out_vrr->fixed.frame_counter++;
 
-			/* Program V_TOTAL */
-			adjust_vmin_vmax(core_freesync, streams,
-						num_streams, index,
-						vmin, vmax);
+			if (in_out_vrr->fixed.frame_counter >
+					FIXED_REFRESH_ENTER_FRAME_COUNT) {
+				in_out_vrr->fixed.frame_counter = 0;
+				in_out_vrr->fixed.fixed_active = true;
+			}
 		}
+	}
 
-		if (state->btr.frame_counter > 0)
-			state->btr.frame_counter--;
+	/* BTR set to "not active" so disengage */
+	if (!in_out_vrr->btr.btr_active) {
+		in_out_vrr->btr.btr_active = false;
+		in_out_vrr->btr.inserted_duration_in_us = 0;
+		in_out_vrr->btr.frames_to_insert = 0;
+		in_out_vrr->btr.frame_counter = 0;
 
 		/* Restore FreeSync */
-		if (state->btr.frame_counter == 0)
-			set_freesync_on_streams(core_freesync, streams, num_streams);
-	}
-
-	/* If in fullscreen freesync mode or in video, do not program
-	 * static screen ramp values
-	 */
-	if (state->fullscreen == true || state->video == true) {
+		in_out_vrr->adjust.v_total_min =
+			calc_v_total_from_refresh(stream,
+				in_out_vrr->max_refresh_in_uhz);
+		in_out_vrr->adjust.v_total_max =
+			calc_v_total_from_refresh(stream,
+				in_out_vrr->min_refresh_in_uhz);
+	/* BTR set to "active" so engage */
+	} else {
 
-		state->static_ramp.ramp_is_active = false;
+		/* Calculate number of midPoint frames that could fit within
+		 * the render time interval- take ceil of this value
+		 */
+		mid_point_frames_ceil = (last_render_time_in_us +
+				in_out_vrr->btr.mid_point_in_us - 1) /
+					in_out_vrr->btr.mid_point_in_us;
 
-		return;
-	}
+		if (mid_point_frames_ceil > 0) {
+			frame_time_in_us = last_render_time_in_us /
+				mid_point_frames_ceil;
+			delta_from_mid_point_in_us_1 =
+				(in_out_vrr->btr.mid_point_in_us >
+				frame_time_in_us) ?
+				(in_out_vrr->btr.mid_point_in_us - frame_time_in_us) :
+				(frame_time_in_us - in_out_vrr->btr.mid_point_in_us);
+		}
 
-	/* Gradual Static Screen Ramping Logic */
+		/* Calculate number of midPoint frames that could fit within
+		 * the render time interval- take floor of this value
+		 */
+		mid_point_frames_floor = last_render_time_in_us /
+				in_out_vrr->btr.mid_point_in_us;
 
-	/* Execute if ramp is active and user enabled freesync static screen*/
-	if (state->static_ramp.ramp_is_active &&
-		core_freesync->map[index].user_enable.enable_for_static) {
+		if (mid_point_frames_floor > 0) {
 
-		calc_v_total_for_static_ramp(core_freesync, streams[0],
-				index, &v_total);
+			frame_time_in_us = last_render_time_in_us /
+				mid_point_frames_floor;
+			delta_from_mid_point_in_us_2 =
+				(in_out_vrr->btr.mid_point_in_us >
+				frame_time_in_us) ?
+				(in_out_vrr->btr.mid_point_in_us - frame_time_in_us) :
+				(frame_time_in_us - in_out_vrr->btr.mid_point_in_us);
+		}
 
-		/* Update the freesync context for the stream */
-		update_stream_freesync_context(core_freesync, streams[0]);
+		/* Choose number of frames to insert based on how close it
+		 * can get to the mid point of the variable range.
+		 */
+		if (delta_from_mid_point_in_us_1 < delta_from_mid_point_in_us_2)
+			frames_to_insert = mid_point_frames_ceil;
+		else
+			frames_to_insert = mid_point_frames_floor;
 
-		/* Program static screen ramp values */
-		adjust_vmin_vmax(core_freesync, streams,
-					num_streams, index,
-					v_total,
-					v_total);
+		/* Either we've calculated the number of frames to insert,
+		 * or we need to insert min duration frames
+		 */
+		if (frames_to_insert > 0)
+			inserted_frame_duration_in_us = last_render_time_in_us /
+							frames_to_insert;
 
-		triggers.overlay_update = true;
-		triggers.surface_update = true;
+		if (inserted_frame_duration_in_us <
+			(1000000 / in_out_vrr->max_refresh_in_uhz))
+			inserted_frame_duration_in_us =
+				(1000000 / in_out_vrr->max_refresh_in_uhz);
 
-		dc_stream_set_static_screen_events(core_freesync->dc, streams,
-						   num_streams, &triggers);
+		/* Cache the calculated variables */
+		in_out_vrr->btr.inserted_duration_in_us =
+			inserted_frame_duration_in_us;
+		in_out_vrr->btr.frames_to_insert = frames_to_insert;
+		in_out_vrr->btr.frame_counter = frames_to_insert;
+
+		in_out_vrr->adjust.v_total_min =
+			calc_v_total_from_duration(stream, in_out_vrr,
+				in_out_vrr->btr.inserted_duration_in_us);
+		in_out_vrr->adjust.v_total_max =
+				in_out_vrr->adjust.v_total_min;
 	}
 }
 
-void mod_freesync_update_state(struct mod_freesync *mod_freesync,
-		struct dc_stream_state **streams, int num_streams,
-		struct mod_freesync_params *freesync_params)
+static void apply_fixed_refresh(struct core_freesync *core_freesync,
+		const struct dc_stream_state *stream,
+		unsigned int last_render_time_in_us,
+		struct mod_vrr_params *in_out_vrr)
 {
-	bool freesync_program_required = false;
-	unsigned int stream_index;
-	struct freesync_state *state;
-	struct core_freesync *core_freesync = NULL;
-	struct dc_static_screen_events triggers = {0};
+	bool update = false;
+	unsigned int max_render_time_in_us = in_out_vrr->max_duration_in_us;
 
-	if (mod_freesync == NULL)
-		return;
-
-	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-
-	if (core_freesync->num_entities == 0)
-		return;
+	if (last_render_time_in_us + BTR_EXIT_MARGIN < max_render_time_in_us) {
+		/* Exit Fixed Refresh mode */
+		if (in_out_vrr->fixed.fixed_active) {
+			in_out_vrr->fixed.frame_counter++;
 
-	for(stream_index = 0; stream_index < num_streams; stream_index++) {
-
-		unsigned int map_index = map_index_from_stream(core_freesync,
-				streams[stream_index]);
-
-		bool is_embedded = dc_is_embedded_signal(
-				streams[stream_index]->sink->sink_signal);
-
-		struct freesync_registry_options *opts = &core_freesync->opts;
-
-		state = &core_freesync->map[map_index].state;
-
-		switch (freesync_params->state){
-		case FREESYNC_STATE_FULLSCREEN:
-			state->fullscreen = freesync_params->enable;
-			freesync_program_required = true;
-			state->windowed_fullscreen =
-					freesync_params->windowed_fullscreen;
-			break;
-		case FREESYNC_STATE_STATIC_SCREEN:
-			/* Static screen ramp is disabled by default, but can
-			 * be enabled through regkey.
-			 */
-			if ((is_embedded && opts->drr_internal_supported) ||
-				(!is_embedded && opts->drr_external_supported))
-
-				if (state->static_screen !=
-						freesync_params->enable) {
-
-					/* Change the state flag */
-					state->static_screen =
-							freesync_params->enable;
-
-					/* Update static screen ramp */
-					set_static_ramp_variables(core_freesync,
-						map_index,
-						freesync_params->enable);
-				}
-			/* We program the ramp starting next VUpdate */
-			break;
-		case FREESYNC_STATE_VIDEO:
-			/* Change core variables only if there is a change*/
-			if(freesync_params->update_duration_in_ns !=
-				state->time.update_duration_in_ns) {
-
-				state->video = freesync_params->enable;
-				state->time.update_duration_in_ns =
-					freesync_params->update_duration_in_ns;
-
-				freesync_program_required = true;
+			if (in_out_vrr->fixed.frame_counter >
+					FIXED_REFRESH_EXIT_FRAME_COUNT) {
+				in_out_vrr->fixed.frame_counter = 0;
+				in_out_vrr->fixed.fixed_active = false;
+				in_out_vrr->fixed.target_refresh_in_uhz = 0;
+				update = true;
 			}
-			break;
-		case FREESYNC_STATE_NONE:
-			/* handle here to avoid warning */
-			break;
 		}
-	}
-
-	/* Update mask */
-	triggers.overlay_update = true;
-	triggers.surface_update = true;
-
-	dc_stream_set_static_screen_events(core_freesync->dc, streams,
-					   num_streams, &triggers);
-
-	if (freesync_program_required)
-		/* Program freesync according to current state*/
-		set_freesync_on_streams(core_freesync, streams, num_streams);
-}
-
-
-bool mod_freesync_get_state(struct mod_freesync *mod_freesync,
-		struct dc_stream_state *stream,
-		struct mod_freesync_params *freesync_params)
-{
-	unsigned int index = 0;
-	struct core_freesync *core_freesync = NULL;
-
-	if (mod_freesync == NULL)
-		return false;
+	} else if (last_render_time_in_us > max_render_time_in_us) {
+		/* Enter Fixed Refresh mode */
+		if (!in_out_vrr->fixed.fixed_active) {
+			in_out_vrr->fixed.frame_counter++;
 
-	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	index = map_index_from_stream(core_freesync, stream);
-
-	if (core_freesync->map[index].state.fullscreen) {
-		freesync_params->state = FREESYNC_STATE_FULLSCREEN;
-		freesync_params->enable = true;
-	} else if (core_freesync->map[index].state.static_screen) {
-		freesync_params->state = FREESYNC_STATE_STATIC_SCREEN;
-		freesync_params->enable = true;
-	} else if (core_freesync->map[index].state.video) {
-		freesync_params->state = FREESYNC_STATE_VIDEO;
-		freesync_params->enable = true;
-	} else {
-		freesync_params->state = FREESYNC_STATE_NONE;
-		freesync_params->enable = false;
+			if (in_out_vrr->fixed.frame_counter >
+					FIXED_REFRESH_ENTER_FRAME_COUNT) {
+				in_out_vrr->fixed.frame_counter = 0;
+				in_out_vrr->fixed.fixed_active = true;
+				in_out_vrr->fixed.target_refresh_in_uhz =
+						in_out_vrr->max_refresh_in_uhz;
+				update = true;
+			}
+		}
 	}
 
-	freesync_params->update_duration_in_ns =
-		core_freesync->map[index].state.time.update_duration_in_ns;
-
-	freesync_params->windowed_fullscreen =
-			core_freesync->map[index].state.windowed_fullscreen;
-
-	return true;
-}
-
-bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
-		struct dc_stream_state **streams, int num_streams,
-		struct mod_freesync_user_enable *user_enable)
-{
-	unsigned int stream_index, map_index;
-	int persistent_data = 0;
-	struct persistent_data_flag flag;
-	struct dc  *dc = NULL;
-	struct core_freesync *core_freesync = NULL;
-
-	if (mod_freesync == NULL)
-		return false;
-
-	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	dc = core_freesync->dc;
-
-	flag.save_per_edid = true;
-	flag.save_per_link = false;
-
-	for(stream_index = 0; stream_index < num_streams;
-			stream_index++){
-
-		map_index = map_index_from_stream(core_freesync,
-				streams[stream_index]);
-
-		core_freesync->map[map_index].user_enable = *user_enable;
-
-		/* Write persistent data in registry*/
-		if (core_freesync->map[map_index].user_enable.
-				enable_for_gaming)
-			persistent_data = persistent_data | 1;
-		if (core_freesync->map[map_index].user_enable.
-				enable_for_static)
-			persistent_data = persistent_data | 2;
-		if (core_freesync->map[map_index].user_enable.
-				enable_for_video)
-			persistent_data = persistent_data | 4;
-
-		dm_write_persistent_data(dc->ctx,
-					streams[stream_index]->sink,
-					FREESYNC_REGISTRY_NAME,
-					"userenable",
-					&persistent_data,
-					sizeof(int),
-					&flag);
+	if (update) {
+		if (in_out_vrr->fixed.fixed_active) {
+			in_out_vrr->adjust.v_total_min =
+				calc_v_total_from_refresh(
+				stream, in_out_vrr->max_refresh_in_uhz);
+			in_out_vrr->adjust.v_total_max =
+					in_out_vrr->adjust.v_total_min;
+		} else {
+			in_out_vrr->adjust.v_total_min =
+				calc_v_total_from_refresh(
+				stream, in_out_vrr->max_refresh_in_uhz);
+			in_out_vrr->adjust.v_total_max =
+				in_out_vrr->adjust.v_total_min;
+		}
 	}
-
-	set_freesync_on_streams(core_freesync, streams, num_streams);
-
-	return true;
 }
 
-bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
-		struct dc_stream_state *stream,
-		struct mod_freesync_user_enable *user_enable)
-{
-	unsigned int index = 0;
-	struct core_freesync *core_freesync = NULL;
-
-	if (mod_freesync == NULL)
-		return false;
-
-	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	index = map_index_from_stream(core_freesync, stream);
-
-	*user_enable = core_freesync->map[index].user_enable;
-
-	return true;
-}
-
-bool mod_freesync_get_static_ramp_active(struct mod_freesync *mod_freesync,
-		struct dc_stream_state *stream,
-		bool *is_ramp_active)
-{
-	unsigned int index = 0;
-	struct core_freesync *core_freesync = NULL;
-
-	if (mod_freesync == NULL)
-		return false;
-
-	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	index = map_index_from_stream(core_freesync, stream);
-
-	*is_ramp_active =
-		core_freesync->map[index].state.static_ramp.ramp_is_active;
-
-	return true;
-}
-
-bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
-		struct dc_stream_state *streams,
-		unsigned int min_refresh,
-		unsigned int max_refresh,
-		struct mod_freesync_caps *caps)
+static bool vrr_settings_require_update(struct core_freesync *core_freesync,
+		struct mod_freesync_config *in_config,
+		unsigned int min_refresh_in_uhz,
+		unsigned int max_refresh_in_uhz,
+		struct mod_vrr_params *in_vrr)
 {
-	unsigned int index = 0;
-	struct core_freesync *core_freesync;
-	struct freesync_state *state;
-
-	if (mod_freesync == NULL)
-		return false;
-
-	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	index = map_index_from_stream(core_freesync, streams);
-	state = &core_freesync->map[index].state;
-
-	if (max_refresh == 0)
-		max_refresh = state->nominal_refresh_rate_in_micro_hz;
-
-	if (min_refresh == 0) {
-		/* Restore defaults */
-		calc_freesync_range(core_freesync, streams, state,
-			core_freesync->map[index].caps->
-			min_refresh_in_micro_hz,
-			state->nominal_refresh_rate_in_micro_hz);
-	} else {
-		calc_freesync_range(core_freesync, streams,
-				state,
-				min_refresh,
-				max_refresh);
-
-		/* Program vtotal min/max */
-		adjust_vmin_vmax(core_freesync, &streams, 1, index,
-				state->freesync_range.vmin,
-				state->freesync_range.vmax);
-	}
-
-	if (min_refresh != 0 &&
-			dc_is_embedded_signal(streams->sink->sink_signal) &&
-			(max_refresh - min_refresh >= 10000000)) {
-		caps->supported = true;
-		caps->min_refresh_in_micro_hz = min_refresh;
-		caps->max_refresh_in_micro_hz = max_refresh;
+	if (in_vrr->state != in_config->state) {
+		return true;
+	} else if (in_vrr->state == VRR_STATE_ACTIVE_FIXED &&
+			in_vrr->fixed.target_refresh_in_uhz !=
+					in_config->min_refresh_in_uhz) {
+		return true;
+	} else if (in_vrr->min_refresh_in_uhz != min_refresh_in_uhz) {
+		return true;
+	} else if (in_vrr->max_refresh_in_uhz != max_refresh_in_uhz) {
+		return true;
 	}
 
-	/* Update the stream */
-	update_stream(core_freesync, streams);
-
-	return true;
-}
-
-bool mod_freesync_get_min_max(struct mod_freesync *mod_freesync,
-		struct dc_stream_state *stream,
-		unsigned int *min_refresh,
-		unsigned int *max_refresh)
-{
-	unsigned int index = 0;
-	struct core_freesync *core_freesync = NULL;
-
-	if (mod_freesync == NULL)
-		return false;
-
-	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	index = map_index_from_stream(core_freesync, stream);
-
-	*min_refresh =
-		core_freesync->map[index].state.freesync_range.min_refresh;
-	*max_refresh =
-		core_freesync->map[index].state.freesync_range.max_refresh;
-
-	return true;
+	return false;
 }
 
 bool mod_freesync_get_vmin_vmax(struct mod_freesync *mod_freesync,
-		struct dc_stream_state *stream,
+		const struct dc_stream_state *stream,
 		unsigned int *vmin,
 		unsigned int *vmax)
 {
-	unsigned int index = 0;
-	struct core_freesync *core_freesync = NULL;
-
-	if (mod_freesync == NULL)
-		return false;
-
-	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	index = map_index_from_stream(core_freesync, stream);
-
-	*vmin =
-		core_freesync->map[index].state.freesync_range.vmin;
-	*vmax =
-		core_freesync->map[index].state.freesync_range.vmax;
+	*vmin = stream->adjust.v_total_min;
+	*vmax = stream->adjust.v_total_max;
 
 	return true;
 }
@@ -1189,7 +471,6 @@ bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
 		unsigned int *nom_v_pos,
 		unsigned int *v_pos)
 {
-	unsigned int index = 0;
 	struct core_freesync *core_freesync = NULL;
 	struct crtc_position position;
 
@@ -1197,7 +478,6 @@ bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
 		return false;
 
 	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	index = map_index_from_stream(core_freesync, stream);
 
 	if (dc_stream_get_crtc_position(core_freesync->dc, &stream, 1,
 					&position.vertical_count,
@@ -1212,310 +492,368 @@ bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
 	return false;
 }
 
-void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
-		struct dc_stream_state **streams, int num_streams)
+void mod_freesync_build_vrr_infopacket(struct mod_freesync *mod_freesync,
+		const struct dc_stream_state *stream,
+		const struct mod_vrr_params *vrr,
+		struct dc_info_packet *infopacket)
 {
-	unsigned int stream_index, map_index;
-	struct freesync_state *state;
-	struct core_freesync *core_freesync = NULL;
-	struct dc_static_screen_events triggers = {0};
-	unsigned long long temp = 0;
+	/* SPD info packet for FreeSync */
+	unsigned char checksum = 0;
+	unsigned int idx, payload_size = 0;
 
-	if (mod_freesync == NULL)
+	/* Check if Freesync is supported. Return if false. If true,
+	 * set the corresponding bit in the info packet
+	 */
+	if (!vrr->supported)
 		return;
 
-	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
+	if (dc_is_hdmi_signal(stream->signal)) {
 
-	for (stream_index = 0; stream_index < num_streams; stream_index++) {
-		map_index = map_index_from_stream(core_freesync,
-				streams[stream_index]);
-
-		state = &core_freesync->map[map_index].state;
-
-		/* Update the field rate for new timing */
-		temp = streams[stream_index]->timing.pix_clk_khz;
-		temp *= 1000ULL * 1000ULL * 1000ULL;
-		temp = div_u64(temp,
-				streams[stream_index]->timing.h_total);
-		temp = div_u64(temp,
-				streams[stream_index]->timing.v_total);
-		state->nominal_refresh_rate_in_micro_hz =
-				(unsigned int) temp;
-
-		if (core_freesync->map[map_index].caps->supported) {
-
-			/* Update the stream */
-			update_stream(core_freesync, streams[stream_index]);
-
-			/* Calculate vmin/vmax and refresh rate for
-			 * current mode
-			 */
-			calc_freesync_range(core_freesync, *streams, state,
-				core_freesync->map[map_index].caps->
-				min_refresh_in_micro_hz,
-				state->nominal_refresh_rate_in_micro_hz);
-
-			/* Update mask */
-			triggers.overlay_update = true;
-			triggers.surface_update = true;
-
-			dc_stream_set_static_screen_events(core_freesync->dc,
-							   streams, num_streams,
-							   &triggers);
-		}
-	}
+		/* HEADER */
 
-	/* Program freesync according to current state*/
-	set_freesync_on_streams(core_freesync, streams, num_streams);
-}
+		/* HB0  = Packet Type = 0x83 (Source Product
+		 *	  Descriptor InfoFrame)
+		 */
+		infopacket->hb0 = DC_HDMI_INFOFRAME_TYPE_SPD;
 
-/* Add the timestamps to the cache and determine whether BTR programming
- * is required, depending on the times calculated
- */
-static void update_timestamps(struct core_freesync *core_freesync,
-		const struct dc_stream_state *stream, unsigned int map_index,
-		unsigned int last_render_time_in_us)
-{
-	struct freesync_state *state = &core_freesync->map[map_index].state;
+		/* HB1  = Version = 0x01 */
+		infopacket->hb1 = 0x01;
 
-	state->time.render_times[state->time.render_times_index] =
-			last_render_time_in_us;
-	state->time.render_times_index++;
+		/* HB2  = [Bits 7:5 = 0] [Bits 4:0 = Length = 0x08] */
+		infopacket->hb2 = 0x08;
 
-	if (state->time.render_times_index >= RENDER_TIMES_MAX_COUNT)
-		state->time.render_times_index = 0;
+		payload_size = 0x08;
 
-	if (last_render_time_in_us + BTR_EXIT_MARGIN <
-		state->time.max_render_time_in_us) {
+	} else if (dc_is_dp_signal(stream->signal)) {
 
-		/* Exit Below the Range */
-		if (state->btr.btr_active) {
+		/* HEADER */
 
-			state->btr.program_btr = true;
-			state->btr.btr_active = false;
-			state->btr.frame_counter = 0;
+		/* HB0  = Secondary-data Packet ID = 0 - Only non-zero
+		 *	  when used to associate audio related info packets
+		 */
+		infopacket->hb0 = 0x00;
 
-		/* Exit Fixed Refresh mode */
-		} else if (state->fixed_refresh.fixed_active) {
+		/* HB1  = Packet Type = 0x83 (Source Product
+		 *	  Descriptor InfoFrame)
+		 */
+		infopacket->hb1 = DC_HDMI_INFOFRAME_TYPE_SPD;
 
-			state->fixed_refresh.frame_counter++;
+		/* HB2  = [Bits 7:0 = Least significant eight bits -
+		 *	  For INFOFRAME, the value must be 1Bh]
+		 */
+		infopacket->hb2 = 0x1B;
 
-			if (state->fixed_refresh.frame_counter >
-					FIXED_REFRESH_EXIT_FRAME_COUNT) {
-				state->fixed_refresh.frame_counter = 0;
-				state->fixed_refresh.program_fixed = true;
-				state->fixed_refresh.fixed_active = false;
-			}
-		}
+		/* HB3  = [Bits 7:2 = INFOFRAME SDP Version Number = 0x1]
+		 *	  [Bits 1:0 = Most significant two bits = 0x00]
+		 */
+		infopacket->hb3 = 0x04;
 
-	} else if (last_render_time_in_us > state->time.max_render_time_in_us) {
+		payload_size = 0x1B;
+	}
 
-		/* Enter Below the Range */
-		if (!state->btr.btr_active &&
-			core_freesync->map[map_index].caps->btr_supported) {
+	/* PB1 = 0x1A (24bit AMD IEEE OUI (0x00001A) - Byte 0) */
+	infopacket->sb[1] = 0x1A;
 
-			state->btr.program_btr = true;
-			state->btr.btr_active = true;
+	/* PB2 = 0x00 (24bit AMD IEEE OUI (0x00001A) - Byte 1) */
+	infopacket->sb[2] = 0x00;
 
-		/* Enter Fixed Refresh mode */
-		} else if (!state->fixed_refresh.fixed_active &&
-			!core_freesync->map[map_index].caps->btr_supported) {
+	/* PB3 = 0x00 (24bit AMD IEEE OUI (0x00001A) - Byte 2) */
+	infopacket->sb[3] = 0x00;
 
-			state->fixed_refresh.frame_counter++;
+	/* PB4 = Reserved */
 
-			if (state->fixed_refresh.frame_counter >
-					FIXED_REFRESH_ENTER_FRAME_COUNT) {
-				state->fixed_refresh.frame_counter = 0;
-				state->fixed_refresh.program_fixed = true;
-				state->fixed_refresh.fixed_active = true;
-			}
-		}
-	}
+	/* PB5 = Reserved */
 
-	/* When Below the Range is active, must react on every frame */
-	if (state->btr.btr_active)
-		state->btr.program_btr = true;
-}
+	/* PB6 = [Bits 7:3 = Reserved] */
 
-static void apply_below_the_range(struct core_freesync *core_freesync,
-		struct dc_stream_state *stream, unsigned int map_index,
-		unsigned int last_render_time_in_us)
-{
-	unsigned int inserted_frame_duration_in_us = 0;
-	unsigned int mid_point_frames_ceil = 0;
-	unsigned int mid_point_frames_floor = 0;
-	unsigned int frame_time_in_us = 0;
-	unsigned int delta_from_mid_point_in_us_1 = 0xFFFFFFFF;
-	unsigned int delta_from_mid_point_in_us_2 = 0xFFFFFFFF;
-	unsigned int frames_to_insert = 0;
-	unsigned int min_frame_duration_in_ns = 0;
-	struct freesync_state *state = &core_freesync->map[map_index].state;
+	/* PB6 = [Bit 0 = FreeSync Supported] */
+	if (vrr->state != VRR_STATE_UNSUPPORTED)
+		infopacket->sb[6] |= 0x01;
 
-	if (!state->btr.program_btr)
-		return;
+	/* PB6 = [Bit 1 = FreeSync Enabled] */
+	if (vrr->state != VRR_STATE_DISABLED &&
+			vrr->state != VRR_STATE_UNSUPPORTED)
+		infopacket->sb[6] |= 0x02;
 
-	state->btr.program_btr = false;
+	/* PB6 = [Bit 2 = FreeSync Active] */
+	if (vrr->state == VRR_STATE_ACTIVE_VARIABLE ||
+			vrr->state == VRR_STATE_ACTIVE_FIXED)
+		infopacket->sb[6] |= 0x04;
 
-	min_frame_duration_in_ns = ((unsigned int) (div64_u64(
-		(1000000000ULL * 1000000),
-		state->nominal_refresh_rate_in_micro_hz)));
+	/* PB7 = FreeSync Minimum refresh rate (Hz) */
+	infopacket->sb[7] = (unsigned char)(vrr->min_refresh_in_uhz / 1000000);
 
-	/* Program BTR */
+	/* PB8 = FreeSync Maximum refresh rate (Hz)
+	 * Note: We should never go above the field rate of the mode timing set.
+	 */
+	infopacket->sb[8] = (unsigned char)(vrr->max_refresh_in_uhz / 1000000);
 
-	/* BTR set to "not active" so disengage */
-	if (!state->btr.btr_active)
+	/* PB9 - PB27  = Reserved */
 
-		/* Restore FreeSync */
-		set_freesync_on_streams(core_freesync, &stream, 1);
+	/* Calculate checksum */
+	checksum += infopacket->hb0;
+	checksum += infopacket->hb1;
+	checksum += infopacket->hb2;
+	checksum += infopacket->hb3;
 
-	/* BTR set to "active" so engage */
-	else {
+	for (idx = 1; idx <= payload_size; idx++)
+		checksum += infopacket->sb[idx];
 
-		/* Calculate number of midPoint frames that could fit within
-		 * the render time interval- take ceil of this value
-		 */
-		mid_point_frames_ceil = (last_render_time_in_us +
-			state->btr.mid_point_in_us- 1) /
-			state->btr.mid_point_in_us;
+	/* PB0 = Checksum (one byte complement) */
+	infopacket->sb[0] = (unsigned char)(0x100 - checksum);
 
-		if (mid_point_frames_ceil > 0) {
+	infopacket->valid = true;
+}
 
-			frame_time_in_us = last_render_time_in_us /
-				mid_point_frames_ceil;
-			delta_from_mid_point_in_us_1 =
-				(state->btr.mid_point_in_us >
-				frame_time_in_us) ?
-				(state->btr.mid_point_in_us - frame_time_in_us):
-				(frame_time_in_us - state->btr.mid_point_in_us);
-		}
+void mod_freesync_build_vrr_params(struct mod_freesync *mod_freesync,
+		const struct dc_stream_state *stream,
+		struct mod_freesync_config *in_config,
+		struct mod_vrr_params *in_out_vrr)
+{
+	struct core_freesync *core_freesync = NULL;
+	unsigned long long nominal_field_rate_in_uhz = 0;
+	bool nominal_field_rate_in_range = true;
+	unsigned int refresh_range = 0;
+	unsigned int min_refresh_in_uhz = 0;
+	unsigned int max_refresh_in_uhz = 0;
 
-		/* Calculate number of midPoint frames that could fit within
-		 * the render time interval- take floor of this value
-		 */
-		mid_point_frames_floor = last_render_time_in_us /
-			state->btr.mid_point_in_us;
+	if (mod_freesync == NULL)
+		return;
 
-		if (mid_point_frames_floor > 0) {
+	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
 
-			frame_time_in_us = last_render_time_in_us /
-				mid_point_frames_floor;
-			delta_from_mid_point_in_us_2 =
-				(state->btr.mid_point_in_us >
-				frame_time_in_us) ?
-				(state->btr.mid_point_in_us - frame_time_in_us):
-				(frame_time_in_us - state->btr.mid_point_in_us);
-		}
+	/* Calculate nominal field rate for stream */
+	nominal_field_rate_in_uhz = stream->timing.pix_clk_khz;
+	nominal_field_rate_in_uhz *= 1000ULL * 1000ULL * 1000ULL;
+	nominal_field_rate_in_uhz = div_u64(nominal_field_rate_in_uhz,
+						stream->timing.h_total);
+	nominal_field_rate_in_uhz = div_u64(nominal_field_rate_in_uhz,
+						stream->timing.v_total);
+
+	min_refresh_in_uhz = in_config->min_refresh_in_uhz;
+	max_refresh_in_uhz = in_config->max_refresh_in_uhz;
+
+	// Don't allow min > max
+	if (min_refresh_in_uhz > max_refresh_in_uhz)
+		min_refresh_in_uhz = max_refresh_in_uhz;
+
+	// Full range may be larger than current video timing, so cap at nominal
+	if (max_refresh_in_uhz > nominal_field_rate_in_uhz)
+		max_refresh_in_uhz = nominal_field_rate_in_uhz;
+
+	/* Allow for some rounding error of actual video timing by taking ceil.
+	 * For example, 144 Hz mode timing may actually be 143.xxx Hz when
+	 * calculated from pixel rate and vertical/horizontal totals, but
+	 * this should be allowed instead of blocking FreeSync.
+	 */
+	if ((min_refresh_in_uhz / 1000000) >
+			((nominal_field_rate_in_uhz + 1000000 - 1) / 1000000))
+		nominal_field_rate_in_range = false;
 
-		/* Choose number of frames to insert based on how close it
-		 * can get to the mid point of the variable range.
-		 */
-		if (delta_from_mid_point_in_us_1 < delta_from_mid_point_in_us_2)
-			frames_to_insert = mid_point_frames_ceil;
-		else
-			frames_to_insert = mid_point_frames_floor;
+	// Full range may be larger than current video timing, so cap at nominal
+	if (min_refresh_in_uhz > nominal_field_rate_in_uhz)
+		min_refresh_in_uhz = nominal_field_rate_in_uhz;
 
-		/* Either we've calculated the number of frames to insert,
-		 * or we need to insert min duration frames
-		 */
-		if (frames_to_insert > 0)
-			inserted_frame_duration_in_us = last_render_time_in_us /
-							frames_to_insert;
+	if (!vrr_settings_require_update(core_freesync,
+			in_config, min_refresh_in_uhz, max_refresh_in_uhz,
+			in_out_vrr))
+		return;
 
-		if (inserted_frame_duration_in_us <
-			state->time.min_render_time_in_us)
+	in_out_vrr->state = in_config->state;
 
-			inserted_frame_duration_in_us =
-				state->time.min_render_time_in_us;
+	if ((in_config->state == VRR_STATE_UNSUPPORTED) ||
+				(!nominal_field_rate_in_range)) {
+		in_out_vrr->state = VRR_STATE_UNSUPPORTED;
+		in_out_vrr->supported = false;
+	} else {
+		in_out_vrr->min_refresh_in_uhz = min_refresh_in_uhz;
+		in_out_vrr->max_duration_in_us =
+				calc_duration_in_us_from_refresh_in_uhz(
+						min_refresh_in_uhz);
 
-		/* Cache the calculated variables */
-		state->btr.inserted_frame_duration_in_us =
-			inserted_frame_duration_in_us;
-		state->btr.frames_to_insert = frames_to_insert;
-		state->btr.frame_counter = frames_to_insert;
+		in_out_vrr->max_refresh_in_uhz = max_refresh_in_uhz;
+		in_out_vrr->min_duration_in_us =
+				calc_duration_in_us_from_refresh_in_uhz(
+						max_refresh_in_uhz);
 
+		refresh_range = in_out_vrr->max_refresh_in_uhz -
+				in_out_vrr->min_refresh_in_uhz;
+
+		in_out_vrr->supported = true;
+	}
+
+	in_out_vrr->fixed.ramping_active = in_config->ramping;
+
+	in_out_vrr->btr.btr_enabled = in_config->btr;
+	if (in_out_vrr->max_refresh_in_uhz <
+			2 * in_out_vrr->min_refresh_in_uhz)
+		in_out_vrr->btr.btr_enabled = false;
+	in_out_vrr->btr.btr_active = false;
+	in_out_vrr->btr.inserted_duration_in_us = 0;
+	in_out_vrr->btr.frames_to_insert = 0;
+	in_out_vrr->btr.frame_counter = 0;
+	in_out_vrr->btr.mid_point_in_us =
+			in_out_vrr->min_duration_in_us +
+				(in_out_vrr->max_duration_in_us -
+				in_out_vrr->min_duration_in_us) / 2;
+
+	if (in_out_vrr->state == VRR_STATE_UNSUPPORTED) {
+		in_out_vrr->adjust.v_total_min = stream->timing.v_total;
+		in_out_vrr->adjust.v_total_max = stream->timing.v_total;
+	} else if (in_out_vrr->state == VRR_STATE_DISABLED) {
+		in_out_vrr->adjust.v_total_min = stream->timing.v_total;
+		in_out_vrr->adjust.v_total_max = stream->timing.v_total;
+	} else if (in_out_vrr->state == VRR_STATE_INACTIVE) {
+		in_out_vrr->adjust.v_total_min = stream->timing.v_total;
+		in_out_vrr->adjust.v_total_max = stream->timing.v_total;
+	} else if (in_out_vrr->state == VRR_STATE_ACTIVE_VARIABLE &&
+			refresh_range >= MIN_REFRESH_RANGE_IN_US) {
+		in_out_vrr->adjust.v_total_min =
+			calc_v_total_from_refresh(stream,
+				in_out_vrr->max_refresh_in_uhz);
+		in_out_vrr->adjust.v_total_max =
+			calc_v_total_from_refresh(stream,
+				in_out_vrr->min_refresh_in_uhz);
+	} else if (in_out_vrr->state == VRR_STATE_ACTIVE_FIXED) {
+		in_out_vrr->fixed.target_refresh_in_uhz =
+				in_out_vrr->min_refresh_in_uhz;
+		if (in_out_vrr->fixed.ramping_active) {
+			in_out_vrr->fixed.fixed_active = true;
+		} else {
+			in_out_vrr->fixed.fixed_active = true;
+			in_out_vrr->adjust.v_total_min =
+				calc_v_total_from_refresh(stream,
+					in_out_vrr->fixed.target_refresh_in_uhz);
+			in_out_vrr->adjust.v_total_max =
+				in_out_vrr->adjust.v_total_min;
+		}
+	} else {
+		in_out_vrr->state = VRR_STATE_INACTIVE;
+		in_out_vrr->adjust.v_total_min = stream->timing.v_total;
+		in_out_vrr->adjust.v_total_max = stream->timing.v_total;
 	}
 }
 
-static void apply_fixed_refresh(struct core_freesync *core_freesync,
-		struct dc_stream_state *stream, unsigned int map_index)
+void mod_freesync_handle_preflip(struct mod_freesync *mod_freesync,
+		const struct dc_plane_state *plane,
+		const struct dc_stream_state *stream,
+		unsigned int curr_time_stamp_in_us,
+		struct mod_vrr_params *in_out_vrr)
 {
-	unsigned int vmin = 0, vmax = 0;
-	struct freesync_state *state = &core_freesync->map[map_index].state;
+	struct core_freesync *core_freesync = NULL;
+	unsigned int last_render_time_in_us = 0;
+	unsigned int average_render_time_in_us = 0;
 
-	if (!state->fixed_refresh.program_fixed)
+	if (mod_freesync == NULL)
 		return;
 
-	state->fixed_refresh.program_fixed = false;
+	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
 
-	/* Program Fixed Refresh */
+	if (in_out_vrr->supported &&
+			in_out_vrr->state == VRR_STATE_ACTIVE_VARIABLE) {
+		unsigned int i = 0;
+		unsigned int oldest_index = plane->time.index + 1;
 
-	/* Fixed Refresh set to "not active" so disengage */
-	if (!state->fixed_refresh.fixed_active) {
-		set_freesync_on_streams(core_freesync, &stream, 1);
+		if (oldest_index >= DC_PLANE_UPDATE_TIMES_MAX)
+			oldest_index = 0;
 
-	/* Fixed Refresh set to "active" so engage (fix to max) */
-	} else {
+		last_render_time_in_us = curr_time_stamp_in_us -
+				plane->time.prev_update_time_in_us;
+
+		// Sum off all entries except oldest one
+		for (i = 0; i < DC_PLANE_UPDATE_TIMES_MAX; i++) {
+			average_render_time_in_us +=
+					plane->time.time_elapsed_in_us[i];
+		}
+		average_render_time_in_us -=
+				plane->time.time_elapsed_in_us[oldest_index];
+
+		// Add render time for current flip
+		average_render_time_in_us += last_render_time_in_us;
+		average_render_time_in_us /= DC_PLANE_UPDATE_TIMES_MAX;
+
+		if (in_out_vrr->btr.btr_enabled) {
+			apply_below_the_range(core_freesync,
+					stream,
+					last_render_time_in_us,
+					in_out_vrr);
+		} else {
+			apply_fixed_refresh(core_freesync,
+				stream,
+				last_render_time_in_us,
+				in_out_vrr);
+		}
 
-		vmin = state->freesync_range.vmin;
-		vmax = vmin;
-		adjust_vmin_vmax(core_freesync, &stream, map_index,
-					1, vmin, vmax);
 	}
 }
 
-void mod_freesync_pre_update_plane_addresses(struct mod_freesync *mod_freesync,
-		struct dc_stream_state **streams, int num_streams,
-		unsigned int curr_time_stamp_in_us)
+void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
+		const struct dc_stream_state *stream,
+		struct mod_vrr_params *in_out_vrr)
 {
-	unsigned int stream_index, map_index, last_render_time_in_us = 0;
 	struct core_freesync *core_freesync = NULL;
 
-	if (mod_freesync == NULL)
+	if ((mod_freesync == NULL) || (stream == NULL) || (in_out_vrr == NULL))
 		return;
 
 	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
 
-	for (stream_index = 0; stream_index < num_streams; stream_index++) {
-
-		map_index = map_index_from_stream(core_freesync,
-						streams[stream_index]);
-
-		if (core_freesync->map[map_index].caps->supported) {
-
-			last_render_time_in_us = curr_time_stamp_in_us -
-					core_freesync->map[map_index].state.time.
-					prev_time_stamp_in_us;
-
-			/* Add the timestamps to the cache and determine
-			 * whether BTR program is required
-			 */
-			update_timestamps(core_freesync, streams[stream_index],
-					map_index, last_render_time_in_us);
+	if (in_out_vrr->supported == false)
+		return;
 
-			if (core_freesync->map[map_index].state.fullscreen &&
-				core_freesync->map[map_index].user_enable.
-				enable_for_gaming) {
+	/* Below the Range Logic */
 
-				if (core_freesync->map[map_index].caps->btr_supported) {
+	/* Only execute if in fullscreen mode */
+	if (in_out_vrr->state == VRR_STATE_ACTIVE_VARIABLE &&
+					in_out_vrr->btr.btr_active) {
+		/* TODO: pass in flag for Pre-DCE12 ASIC
+		 * in order for frame variable duration to take affect,
+		 * it needs to be done one VSYNC early, which is at
+		 * frameCounter == 1.
+		 * For DCE12 and newer updates to V_TOTAL_MIN/MAX
+		 * will take affect on current frame
+		 */
+		if (in_out_vrr->btr.frames_to_insert ==
+				in_out_vrr->btr.frame_counter) {
+			in_out_vrr->adjust.v_total_min =
+				calc_v_total_from_duration(stream,
+				in_out_vrr,
+				in_out_vrr->btr.inserted_duration_in_us);
+			in_out_vrr->adjust.v_total_max =
+				in_out_vrr->adjust.v_total_min;
+		}
 
-					apply_below_the_range(core_freesync,
-						streams[stream_index], map_index,
-						last_render_time_in_us);
-				} else {
-					apply_fixed_refresh(core_freesync,
-						streams[stream_index], map_index);
-				}
-			}
+		if (in_out_vrr->btr.frame_counter > 0)
+			in_out_vrr->btr.frame_counter--;
 
-			core_freesync->map[map_index].state.time.
-				prev_time_stamp_in_us = curr_time_stamp_in_us;
+		/* Restore FreeSync */
+		if (in_out_vrr->btr.frame_counter == 0) {
+			in_out_vrr->adjust.v_total_min =
+				calc_v_total_from_refresh(stream,
+				in_out_vrr->max_refresh_in_uhz);
+			in_out_vrr->adjust.v_total_max =
+				calc_v_total_from_refresh(stream,
+				in_out_vrr->min_refresh_in_uhz);
 		}
+	}
+
+	/* If in fullscreen freesync mode or in video, do not program
+	 * static screen ramp values
+	 */
+	if (in_out_vrr->state == VRR_STATE_ACTIVE_VARIABLE)
+		in_out_vrr->fixed.ramping_active = false;
 
+	/* Gradual Static Screen Ramping Logic */
+	/* Execute if ramp is active and user enabled freesync static screen*/
+	if (in_out_vrr->state == VRR_STATE_ACTIVE_FIXED &&
+				in_out_vrr->fixed.ramping_active) {
+		update_v_total_for_static_ramp(
+				core_freesync, stream, in_out_vrr);
 	}
 }
 
 void mod_freesync_get_settings(struct mod_freesync *mod_freesync,
-		struct dc_stream_state **streams, int num_streams,
+		const struct mod_vrr_params *vrr,
 		unsigned int *v_total_min, unsigned int *v_total_max,
 		unsigned int *event_triggers,
 		unsigned int *window_min, unsigned int *window_max,
@@ -1523,7 +861,6 @@ void mod_freesync_get_settings(struct mod_freesync *mod_freesync,
 		unsigned int *inserted_frames,
 		unsigned int *inserted_duration_in_us)
 {
-	unsigned int stream_index, map_index;
 	struct core_freesync *core_freesync = NULL;
 
 	if (mod_freesync == NULL)
@@ -1531,25 +868,13 @@ void mod_freesync_get_settings(struct mod_freesync *mod_freesync,
 
 	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
 
-	for (stream_index = 0; stream_index < num_streams; stream_index++) {
-
-		map_index = map_index_from_stream(core_freesync,
-						streams[stream_index]);
-
-		if (core_freesync->map[map_index].caps->supported) {
-			struct freesync_state state =
-					core_freesync->map[map_index].state;
-			*v_total_min = state.vmin;
-			*v_total_max = state.vmax;
-			*event_triggers = 0;
-			*window_min = state.time.min_window;
-			*window_max = state.time.max_window;
-			*lfc_mid_point_in_us = state.btr.mid_point_in_us;
-			*inserted_frames = state.btr.frames_to_insert;
-			*inserted_duration_in_us =
-					state.btr.inserted_frame_duration_in_us;
-		}
-
+	if (vrr->supported) {
+		*v_total_min = vrr->adjust.v_total_min;
+		*v_total_max = vrr->adjust.v_total_max;
+		*event_triggers = 0;
+		*lfc_mid_point_in_us = vrr->btr.mid_point_in_us;
+		*inserted_frames = vrr->btr.frames_to_insert;
+		*inserted_duration_in_us = vrr->btr.inserted_duration_in_us;
 	}
 }
 

commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 27d4003aa2c7..fa344ceafc17 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -155,7 +155,8 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 	if (core_freesync == NULL)
 		goto fail_alloc_context;
 
-	core_freesync->map = kzalloc(sizeof(struct freesync_entity) * MOD_FREESYNC_MAX_CONCURRENT_STREAMS,
+	core_freesync->map = kcalloc(MOD_FREESYNC_MAX_CONCURRENT_STREAMS,
+					sizeof(struct freesync_entity),
 					GFP_KERNEL);
 
 	if (core_freesync->map == NULL)

commit 5231f5d1124eef853573cb3d2e3dc3c4ddc43e22
Author: Samson Tam <Samson.Tam@amd.com>
Date:   Thu Mar 1 11:06:34 2018 -0500

    drm/amd/display: add support for regkey "LCDFreeSyncDefault"
    
    Signed-off-by: Samson Tam <Samson.Tam@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index e849b704f2f6..27d4003aa2c7 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -46,6 +46,8 @@
 
 #define FREESYNC_NO_STATIC_FOR_INTERNAL_REGKEY "DalFreeSyncNoStaticForInternal"
 
+#define FREESYNC_DEFAULT_REGKEY "LCDFreeSyncDefault"
+
 struct gradual_static_ramp {
 	bool ramp_is_active;
 	bool ramp_direction_is_up;
@@ -125,6 +127,8 @@ struct freesync_entity {
 struct freesync_registry_options {
 	bool drr_external_supported;
 	bool drr_internal_supported;
+	bool lcd_freesync_default_set;
+	int lcd_freesync_default_value;
 };
 
 struct core_freesync {
@@ -189,6 +193,16 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 				(data & 1) ? false : true;
 	}
 
+	if (dm_read_persistent_data(dc->ctx, NULL, NULL,
+			FREESYNC_DEFAULT_REGKEY,
+			&data, sizeof(data), &flag)) {
+		core_freesync->opts.lcd_freesync_default_set = true;
+		core_freesync->opts.lcd_freesync_default_value = data;
+	} else {
+		core_freesync->opts.lcd_freesync_default_set = false;
+		core_freesync->opts.lcd_freesync_default_value = 0;
+	}
+
 	return &core_freesync->public;
 
 fail_construct:
@@ -294,6 +308,18 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 			core_freesync->map[core_freesync->num_entities].user_enable.
 				enable_for_video =
 				(persistent_freesync_enable & 4) ? true : false;
+		/* If FreeSync display and LCDFreeSyncDefault is set, use as default values write back to userenable */
+		} else if (caps->supported && (core_freesync->opts.lcd_freesync_default_set)) {
+			core_freesync->map[core_freesync->num_entities].user_enable.enable_for_gaming =
+				(core_freesync->opts.lcd_freesync_default_value & 1) ? true : false;
+			core_freesync->map[core_freesync->num_entities].user_enable.enable_for_static =
+				(core_freesync->opts.lcd_freesync_default_value & 2) ? true : false;
+			core_freesync->map[core_freesync->num_entities].user_enable.enable_for_video =
+				(core_freesync->opts.lcd_freesync_default_value & 4) ? true : false;
+			dm_write_persistent_data(dc->ctx, stream->sink,
+						FREESYNC_REGISTRY_NAME,
+						"userenable", &core_freesync->opts.lcd_freesync_default_value,
+						sizeof(int), &flag);
 		} else {
 			core_freesync->map[core_freesync->num_entities].user_enable.
 					enable_for_gaming = false;

commit a3e1737ed61c8b6ea078f477eee612e26f9d2561
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Feb 22 09:50:25 2018 -0500

    drm/amd/display: Implement stats logging
    
    Stats will be used for debug purposes
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index b4723af368a5..e849b704f2f6 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -33,7 +33,7 @@
 /* Refresh rate ramp at a fixed rate of 65 Hz/second */
 #define STATIC_SCREEN_RAMP_DELTA_REFRESH_RATE_PER_FRAME ((1000 / 60) * 65)
 /* Number of elements in the render times cache array */
-#define RENDER_TIMES_MAX_COUNT 20
+#define RENDER_TIMES_MAX_COUNT 10
 /* Threshold to exit BTR (to avoid frequent enter-exits at the lower limit) */
 #define BTR_EXIT_MARGIN 2000
 /* Number of consecutive frames to check before entering/exiting fixed refresh*/
@@ -52,7 +52,7 @@ struct gradual_static_ramp {
 	unsigned int ramp_current_frame_duration_in_ns;
 };
 
-struct time_cache {
+struct freesync_time {
 	/* video (48Hz feature) related */
 	unsigned int update_duration_in_ns;
 
@@ -64,6 +64,9 @@ struct time_cache {
 
 	unsigned int render_times_index;
 	unsigned int render_times[RENDER_TIMES_MAX_COUNT];
+
+	unsigned int min_window;
+	unsigned int max_window;
 };
 
 struct below_the_range {
@@ -98,11 +101,14 @@ struct freesync_state {
 	bool static_screen;
 	bool video;
 
+	unsigned int vmin;
+	unsigned int vmax;
+
+	struct freesync_time time;
+
 	unsigned int nominal_refresh_rate_in_micro_hz;
 	bool windowed_fullscreen;
 
-	struct time_cache time;
-
 	struct gradual_static_ramp static_ramp;
 	struct below_the_range btr;
 	struct fixed_refresh fixed_refresh;
@@ -124,9 +130,9 @@ struct freesync_registry_options {
 struct core_freesync {
 	struct mod_freesync public;
 	struct dc *dc;
+	struct freesync_registry_options opts;
 	struct freesync_entity *map;
 	int num_entities;
-	struct freesync_registry_options opts;
 };
 
 #define MOD_FREESYNC_TO_CORE(mod_freesync)\
@@ -146,7 +152,7 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 		goto fail_alloc_context;
 
 	core_freesync->map = kzalloc(sizeof(struct freesync_entity) * MOD_FREESYNC_MAX_CONCURRENT_STREAMS,
-				     GFP_KERNEL);
+					GFP_KERNEL);
 
 	if (core_freesync->map == NULL)
 		goto fail_alloc_map;
@@ -330,6 +336,25 @@ bool mod_freesync_remove_stream(struct mod_freesync *mod_freesync,
 	return true;
 }
 
+static void adjust_vmin_vmax(struct core_freesync *core_freesync,
+				struct dc_stream_state **streams,
+				int num_streams,
+				int map_index,
+				unsigned int v_total_min,
+				unsigned int v_total_max)
+{
+	if (num_streams == 0 || streams == NULL || num_streams > 1)
+		return;
+
+	core_freesync->map[map_index].state.vmin = v_total_min;
+	core_freesync->map[map_index].state.vmax = v_total_max;
+
+	dc_stream_adjust_vmin_vmax(core_freesync->dc, streams,
+				num_streams, v_total_min,
+				v_total_max);
+}
+
+
 static void update_stream_freesync_context(struct core_freesync *core_freesync,
 		struct dc_stream_state *stream)
 {
@@ -588,9 +613,10 @@ static bool set_freesync_on_streams(struct core_freesync *core_freesync,
 				update_stream_freesync_context(core_freesync,
 						streams[stream_idx]);
 
-				dc_stream_adjust_vmin_vmax(core_freesync->dc, streams,
-							   num_streams, v_total_min,
-							   v_total_max);
+				adjust_vmin_vmax(core_freesync, streams,
+						num_streams, map_index,
+						v_total_min,
+						v_total_max);
 
 				return true;
 
@@ -613,9 +639,10 @@ static bool set_freesync_on_streams(struct core_freesync *core_freesync,
 						core_freesync,
 						streams[stream_idx]);
 
-					dc_stream_adjust_vmin_vmax(
-						core_freesync->dc, streams,
-						num_streams, v_total_nominal,
+					adjust_vmin_vmax(
+						core_freesync, streams,
+						num_streams, map_index,
+						v_total_nominal,
 						v_total_nominal);
 				}
 				return true;
@@ -632,9 +659,10 @@ static bool set_freesync_on_streams(struct core_freesync *core_freesync,
 					core_freesync,
 					streams[stream_idx]);
 
-				dc_stream_adjust_vmin_vmax(core_freesync->dc, streams,
-							   num_streams, v_total_nominal,
-							   v_total_nominal);
+				adjust_vmin_vmax(core_freesync, streams,
+						num_streams, map_index,
+						v_total_nominal,
+						v_total_nominal);
 
 				/* Reset the cached variables */
 				reset_freesync_state_variables(state);
@@ -650,9 +678,10 @@ static bool set_freesync_on_streams(struct core_freesync *core_freesync,
 			 * not support freesync because a former stream has
 			 * be programmed
 			 */
-			dc_stream_adjust_vmin_vmax(core_freesync->dc, streams,
-						   num_streams, v_total_nominal,
-						   v_total_nominal);
+			adjust_vmin_vmax(core_freesync, streams,
+						num_streams, map_index,
+						v_total_nominal,
+						v_total_nominal);
 			/* Reset the cached variables */
 			reset_freesync_state_variables(state);
 		}
@@ -769,8 +798,9 @@ void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
 			vmin = inserted_frame_v_total;
 
 			/* Program V_TOTAL */
-			dc_stream_adjust_vmin_vmax(core_freesync->dc, streams,
-						   num_streams, vmin, vmax);
+			adjust_vmin_vmax(core_freesync, streams,
+						num_streams, index,
+						vmin, vmax);
 		}
 
 		if (state->btr.frame_counter > 0)
@@ -804,9 +834,10 @@ void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
 		update_stream_freesync_context(core_freesync, streams[0]);
 
 		/* Program static screen ramp values */
-		dc_stream_adjust_vmin_vmax(core_freesync->dc, streams,
-					   num_streams, v_total,
-					   v_total);
+		adjust_vmin_vmax(core_freesync, streams,
+					num_streams, index,
+					v_total,
+					v_total);
 
 		triggers.overlay_update = true;
 		triggers.surface_update = true;
@@ -1063,9 +1094,9 @@ bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
 				max_refresh);
 
 		/* Program vtotal min/max */
-		dc_stream_adjust_vmin_vmax(core_freesync->dc, &streams, 1,
-					   state->freesync_range.vmin,
-					   state->freesync_range.vmax);
+		adjust_vmin_vmax(core_freesync, &streams, 1, index,
+				state->freesync_range.vmin,
+				state->freesync_range.vmax);
 	}
 
 	if (min_refresh != 0 &&
@@ -1399,11 +1430,9 @@ static void apply_fixed_refresh(struct core_freesync *core_freesync,
 	} else {
 
 		vmin = state->freesync_range.vmin;
-
 		vmax = vmin;
-
-		dc_stream_adjust_vmin_vmax(core_freesync->dc, &stream,
-					   1, vmin, vmax);
+		adjust_vmin_vmax(core_freesync, &stream, map_index,
+					1, vmin, vmax);
 	}
 }
 
@@ -1457,3 +1486,43 @@ void mod_freesync_pre_update_plane_addresses(struct mod_freesync *mod_freesync,
 
 	}
 }
+
+void mod_freesync_get_settings(struct mod_freesync *mod_freesync,
+		struct dc_stream_state **streams, int num_streams,
+		unsigned int *v_total_min, unsigned int *v_total_max,
+		unsigned int *event_triggers,
+		unsigned int *window_min, unsigned int *window_max,
+		unsigned int *lfc_mid_point_in_us,
+		unsigned int *inserted_frames,
+		unsigned int *inserted_duration_in_us)
+{
+	unsigned int stream_index, map_index;
+	struct core_freesync *core_freesync = NULL;
+
+	if (mod_freesync == NULL)
+		return;
+
+	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
+
+	for (stream_index = 0; stream_index < num_streams; stream_index++) {
+
+		map_index = map_index_from_stream(core_freesync,
+						streams[stream_index]);
+
+		if (core_freesync->map[map_index].caps->supported) {
+			struct freesync_state state =
+					core_freesync->map[map_index].state;
+			*v_total_min = state.vmin;
+			*v_total_max = state.vmax;
+			*event_triggers = 0;
+			*window_min = state.time.min_window;
+			*window_max = state.time.max_window;
+			*lfc_mid_point_in_us = state.btr.mid_point_in_us;
+			*inserted_frames = state.btr.frames_to_insert;
+			*inserted_duration_in_us =
+					state.btr.inserted_frame_duration_in_us;
+		}
+
+	}
+}
+

commit 2a06e0a5a491f306e22eb5a5239a6bd8ce0f1ac6
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Nov 1 11:43:36 2017 -0400

    drm/amd/display: Remove unnecessary dc_stream vtable
    
    There's no need to have this as a vtable. The vtable was initially
    used for stream_adjust_vmin_vmax but the condition checked here
    (set_drr) is always true, hence we don't need to assign this
    dynamically anymore.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 4d7db4aa28e0..b4723af368a5 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -132,14 +132,6 @@ struct core_freesync {
 #define MOD_FREESYNC_TO_CORE(mod_freesync)\
 		container_of(mod_freesync, struct core_freesync, public)
 
-static bool check_dc_support(const struct dc *dc)
-{
-	if (dc->stream_funcs.adjust_vmin_vmax == NULL)
-		return false;
-
-	return true;
-}
-
 struct mod_freesync *mod_freesync_create(struct dc *dc)
 {
 	struct core_freesync *core_freesync =
@@ -169,9 +161,6 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 
 	core_freesync->dc = dc;
 
-	if (!check_dc_support(dc))
-		goto fail_construct;
-
 	/* Create initial module folder in registry for freesync enable data */
 	flag.save_per_edid = true;
 	flag.save_per_link = false;
@@ -599,10 +588,9 @@ static bool set_freesync_on_streams(struct core_freesync *core_freesync,
 				update_stream_freesync_context(core_freesync,
 						streams[stream_idx]);
 
-				core_freesync->dc->stream_funcs.
-				adjust_vmin_vmax(core_freesync->dc, streams,
-						num_streams, v_total_min,
-						v_total_max);
+				dc_stream_adjust_vmin_vmax(core_freesync->dc, streams,
+							   num_streams, v_total_min,
+							   v_total_max);
 
 				return true;
 
@@ -625,8 +613,7 @@ static bool set_freesync_on_streams(struct core_freesync *core_freesync,
 						core_freesync,
 						streams[stream_idx]);
 
-					core_freesync->dc->stream_funcs.
-					adjust_vmin_vmax(
+					dc_stream_adjust_vmin_vmax(
 						core_freesync->dc, streams,
 						num_streams, v_total_nominal,
 						v_total_nominal);
@@ -645,11 +632,9 @@ static bool set_freesync_on_streams(struct core_freesync *core_freesync,
 					core_freesync,
 					streams[stream_idx]);
 
-				core_freesync->dc->stream_funcs.
-						adjust_vmin_vmax(
-						core_freesync->dc, streams,
-						num_streams, v_total_nominal,
-						v_total_nominal);
+				dc_stream_adjust_vmin_vmax(core_freesync->dc, streams,
+							   num_streams, v_total_nominal,
+							   v_total_nominal);
 
 				/* Reset the cached variables */
 				reset_freesync_state_variables(state);
@@ -665,11 +650,9 @@ static bool set_freesync_on_streams(struct core_freesync *core_freesync,
 			 * not support freesync because a former stream has
 			 * be programmed
 			 */
-			core_freesync->dc->stream_funcs.
-					adjust_vmin_vmax(
-					core_freesync->dc, streams,
-					num_streams, v_total_nominal,
-					v_total_nominal);
+			dc_stream_adjust_vmin_vmax(core_freesync->dc, streams,
+						   num_streams, v_total_nominal,
+						   v_total_nominal);
 			/* Reset the cached variables */
 			reset_freesync_state_variables(state);
 		}
@@ -786,9 +769,8 @@ void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
 			vmin = inserted_frame_v_total;
 
 			/* Program V_TOTAL */
-			core_freesync->dc->stream_funcs.adjust_vmin_vmax(
-				core_freesync->dc, streams,
-				num_streams, vmin, vmax);
+			dc_stream_adjust_vmin_vmax(core_freesync->dc, streams,
+						   num_streams, vmin, vmax);
 		}
 
 		if (state->btr.frame_counter > 0)
@@ -822,17 +804,15 @@ void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
 		update_stream_freesync_context(core_freesync, streams[0]);
 
 		/* Program static screen ramp values */
-		core_freesync->dc->stream_funcs.adjust_vmin_vmax(
-					core_freesync->dc, streams,
-					num_streams, v_total,
-					v_total);
+		dc_stream_adjust_vmin_vmax(core_freesync->dc, streams,
+					   num_streams, v_total,
+					   v_total);
 
 		triggers.overlay_update = true;
 		triggers.surface_update = true;
 
-		core_freesync->dc->stream_funcs.set_static_screen_events(
-					core_freesync->dc, streams,	num_streams,
-					&triggers);
+		dc_stream_set_static_screen_events(core_freesync->dc, streams,
+						   num_streams, &triggers);
 	}
 }
 
@@ -916,9 +896,8 @@ void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 	triggers.overlay_update = true;
 	triggers.surface_update = true;
 
-	core_freesync->dc->stream_funcs.set_static_screen_events(
-		core_freesync->dc, streams, num_streams,
-		&triggers);
+	dc_stream_set_static_screen_events(core_freesync->dc, streams,
+					   num_streams, &triggers);
 
 	if (freesync_program_required)
 		/* Program freesync according to current state*/
@@ -1084,10 +1063,9 @@ bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
 				max_refresh);
 
 		/* Program vtotal min/max */
-		core_freesync->dc->stream_funcs.adjust_vmin_vmax(
-			core_freesync->dc, &streams, 1,
-			state->freesync_range.vmin,
-			state->freesync_range.vmax);
+		dc_stream_adjust_vmin_vmax(core_freesync->dc, &streams, 1,
+					   state->freesync_range.vmin,
+					   state->freesync_range.vmax);
 	}
 
 	if (min_refresh != 0 &&
@@ -1163,9 +1141,9 @@ bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
 	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
 	index = map_index_from_stream(core_freesync, stream);
 
-	if (core_freesync->dc->stream_funcs.get_crtc_position(
-			core_freesync->dc, &stream, 1,
-			&position.vertical_count, &position.nominal_vcount)) {
+	if (dc_stream_get_crtc_position(core_freesync->dc, &stream, 1,
+					&position.vertical_count,
+					&position.nominal_vcount)) {
 
 		*nom_v_pos = position.nominal_vcount;
 		*v_pos = position.vertical_count;
@@ -1223,9 +1201,9 @@ void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
 			triggers.overlay_update = true;
 			triggers.surface_update = true;
 
-			core_freesync->dc->stream_funcs.set_static_screen_events(
-				core_freesync->dc, streams, num_streams,
-				&triggers);
+			dc_stream_set_static_screen_events(core_freesync->dc,
+							   streams, num_streams,
+							   &triggers);
 		}
 	}
 
@@ -1424,10 +1402,8 @@ static void apply_fixed_refresh(struct core_freesync *core_freesync,
 
 		vmax = vmin;
 
-		core_freesync->dc->stream_funcs.adjust_vmin_vmax(
-				core_freesync->dc, &stream,
-				1, vmin,
-				vmax);
+		dc_stream_adjust_vmin_vmax(core_freesync->dc, &stream,
+					   1, vmin, vmax);
 	}
 }
 

commit 2004f45ef83f07f43f5da6ede780b08068c7583d
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Sep 27 10:53:50 2017 -0400

    drm/amd/display: Use kernel alloc/free
    
    Abstractions are frowned upon.
    
    cocci script:
    virtual context
    virtual patch
    virtual org
    virtual report
    
    @@
    expression ptr;
    @@
    
    - dm_alloc(ptr)
    + kzalloc(ptr, GFP_KERNEL)
    
    @@
    expression ptr, size;
    @@
    
    - dm_realloc(ptr, size)
    + krealloc(ptr, size, GFP_KERNEL)
    
    @@
    expression ptr;
    @@
    
    - dm_free(ptr)
    + kfree(ptr)
    
    v2: use GFP_KERNEL, not GFP_ATOMIC. add cocci script
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 52350d0e68d0..4d7db4aa28e0 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -143,7 +143,7 @@ static bool check_dc_support(const struct dc *dc)
 struct mod_freesync *mod_freesync_create(struct dc *dc)
 {
 	struct core_freesync *core_freesync =
-			dm_alloc(sizeof(struct core_freesync));
+			kzalloc(sizeof(struct core_freesync), GFP_KERNEL);
 
 
 	struct persistent_data_flag flag;
@@ -153,8 +153,8 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 	if (core_freesync == NULL)
 		goto fail_alloc_context;
 
-	core_freesync->map = dm_alloc(sizeof(struct freesync_entity) *
-			MOD_FREESYNC_MAX_CONCURRENT_STREAMS);
+	core_freesync->map = kzalloc(sizeof(struct freesync_entity) * MOD_FREESYNC_MAX_CONCURRENT_STREAMS,
+				     GFP_KERNEL);
 
 	if (core_freesync->map == NULL)
 		goto fail_alloc_map;
@@ -197,10 +197,10 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 	return &core_freesync->public;
 
 fail_construct:
-	dm_free(core_freesync->map);
+	kfree(core_freesync->map);
 
 fail_alloc_map:
-	dm_free(core_freesync);
+	kfree(core_freesync);
 
 fail_alloc_context:
 	return NULL;
@@ -217,9 +217,9 @@ void mod_freesync_destroy(struct mod_freesync *mod_freesync)
 			if (core_freesync->map[i].stream)
 				dc_stream_release(core_freesync->map[i].stream);
 
-		dm_free(core_freesync->map);
+		kfree(core_freesync->map);
 
-		dm_free(core_freesync);
+		kfree(core_freesync);
 	}
 }
 

commit 156590454259a19d1709fab2ff7d59870574e822
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Aug 23 15:44:42 2017 -0400

    drm/amd/display: Clean up flattening core_dc to dc
    
    Clean up some code related to flattening core_dc commit
    (Remove redundent dc = dc, which was the result of removing
    DC_TO_CORE() macro)
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index f49203b3eb94..52350d0e68d0 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -145,7 +145,6 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 	struct core_freesync *core_freesync =
 			dm_alloc(sizeof(struct core_freesync));
 
-	struct dc  *core_dc = dc;
 
 	struct persistent_data_flag flag;
 
@@ -176,19 +175,19 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 	/* Create initial module folder in registry for freesync enable data */
 	flag.save_per_edid = true;
 	flag.save_per_link = false;
-	dm_write_persistent_data(core_dc->ctx, NULL, FREESYNC_REGISTRY_NAME,
+	dm_write_persistent_data(dc->ctx, NULL, FREESYNC_REGISTRY_NAME,
 			NULL, NULL, 0, &flag);
 	flag.save_per_edid = false;
 	flag.save_per_link = false;
 
-	if (dm_read_persistent_data(core_dc->ctx, NULL, NULL,
+	if (dm_read_persistent_data(dc->ctx, NULL, NULL,
 			FREESYNC_NO_STATIC_FOR_INTERNAL_REGKEY,
 			&data, sizeof(data), &flag)) {
 		core_freesync->opts.drr_internal_supported =
 			(data & 1) ? false : true;
 	}
 
-	if (dm_read_persistent_data(core_dc->ctx, NULL, NULL,
+	if (dm_read_persistent_data(dc->ctx, NULL, NULL,
 			FREESYNC_NO_STATIC_FOR_EXTERNAL_DP_REGKEY,
 			&data, sizeof(data), &flag)) {
 		core_freesync->opts.drr_external_supported =
@@ -245,7 +244,7 @@ static unsigned int map_index_from_stream(struct core_freesync *core_freesync,
 bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 		struct dc_stream_state *stream, struct mod_freesync_caps *caps)
 {
-	struct dc  *core_dc = NULL;
+	struct dc  *dc = NULL;
 	struct core_freesync *core_freesync = NULL;
 	int persistent_freesync_enable = 0;
 	struct persistent_data_flag flag;
@@ -256,7 +255,7 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 		return false;
 
 	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	core_dc = core_freesync->dc;
+	dc = core_freesync->dc;
 
 	flag.save_per_edid = true;
 	flag.save_per_link = false;
@@ -287,7 +286,7 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 			static_ramp.ramp_is_active = false;
 
 		/* get persistent data from registry */
-		if (dm_read_persistent_data(core_dc->ctx, stream->sink,
+		if (dm_read_persistent_data(dc->ctx, stream->sink,
 					FREESYNC_REGISTRY_NAME,
 					"userenable", &persistent_freesync_enable,
 					sizeof(int), &flag)) {
@@ -970,14 +969,14 @@ bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
 	unsigned int stream_index, map_index;
 	int persistent_data = 0;
 	struct persistent_data_flag flag;
-	struct dc  *core_dc = NULL;
+	struct dc  *dc = NULL;
 	struct core_freesync *core_freesync = NULL;
 
 	if (mod_freesync == NULL)
 		return false;
 
 	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	core_dc = core_freesync->dc;
+	dc = core_freesync->dc;
 
 	flag.save_per_edid = true;
 	flag.save_per_link = false;
@@ -1001,7 +1000,7 @@ bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
 				enable_for_video)
 			persistent_data = persistent_data | 4;
 
-		dm_write_persistent_data(core_dc->ctx,
+		dm_write_persistent_data(dc->ctx,
 					streams[stream_index]->sink,
 					FREESYNC_REGISTRY_NAME,
 					"userenable",

commit fb3466a450cc4684654367ae2f47fc3fc7846574
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Aug 1 15:00:25 2017 -0400

    drm/amd/display: Flattening core_dc to dc
    
    -Flattening core_dc to dc
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index f0a3e4332a09..f49203b3eb94 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -27,7 +27,6 @@
 #include "dc.h"
 #include "mod_freesync.h"
 #include "core_types.h"
-#include "core_dc.h"
 
 #define MOD_FREESYNC_MAX_CONCURRENT_STREAMS  32
 
@@ -146,7 +145,7 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 	struct core_freesync *core_freesync =
 			dm_alloc(sizeof(struct core_freesync));
 
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 
 	struct persistent_data_flag flag;
 
@@ -246,7 +245,7 @@ static unsigned int map_index_from_stream(struct core_freesync *core_freesync,
 bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 		struct dc_stream_state *stream, struct mod_freesync_caps *caps)
 {
-	struct core_dc *core_dc = NULL;
+	struct dc  *core_dc = NULL;
 	struct core_freesync *core_freesync = NULL;
 	int persistent_freesync_enable = 0;
 	struct persistent_data_flag flag;
@@ -257,7 +256,7 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 		return false;
 
 	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	core_dc = DC_TO_CORE(core_freesync->dc);
+	core_dc = core_freesync->dc;
 
 	flag.save_per_edid = true;
 	flag.save_per_link = false;
@@ -971,14 +970,14 @@ bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
 	unsigned int stream_index, map_index;
 	int persistent_data = 0;
 	struct persistent_data_flag flag;
-	struct core_dc *core_dc = NULL;
+	struct dc  *core_dc = NULL;
 	struct core_freesync *core_freesync = NULL;
 
 	if (mod_freesync == NULL)
 		return false;
 
 	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	core_dc = DC_TO_CORE(core_freesync->dc);
+	core_dc = core_freesync->dc;
 
 	flag.save_per_edid = true;
 	flag.save_per_link = false;

commit 0971c40e180696c3512b9a63ca7ca5161cbfce32
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:33:33 2017 -0400

    drm/amd/display: Rename dc_stream to dc_stream_state
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream/struct dc_stream_state/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream_state_update/struct dc_stream_update/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream_state_status/struct dc_stream_status/g'
    
    Plus some manual changes
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 358f8a855a59..f0a3e4332a09 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -111,7 +111,7 @@ struct freesync_state {
 };
 
 struct freesync_entity {
-	struct dc_stream *stream;
+	struct dc_stream_state *stream;
 	struct mod_freesync_caps *caps;
 	struct freesync_state state;
 	struct mod_freesync_user_enable user_enable;
@@ -229,7 +229,7 @@ void mod_freesync_destroy(struct mod_freesync *mod_freesync)
  * on the core_freesync->map and returns the corresponding index
  */
 static unsigned int map_index_from_stream(struct core_freesync *core_freesync,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	unsigned int index = 0;
 
@@ -244,7 +244,7 @@ static unsigned int map_index_from_stream(struct core_freesync *core_freesync,
 }
 
 bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream, struct mod_freesync_caps *caps)
+		struct dc_stream_state *stream, struct mod_freesync_caps *caps)
 {
 	struct core_dc *core_dc = NULL;
 	struct core_freesync *core_freesync = NULL;
@@ -322,7 +322,7 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_remove_stream(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	int i = 0;
 	struct core_freesync *core_freesync = NULL;
@@ -344,7 +344,7 @@ bool mod_freesync_remove_stream(struct mod_freesync *mod_freesync,
 }
 
 static void update_stream_freesync_context(struct core_freesync *core_freesync,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	unsigned int index;
 	struct freesync_context *ctx;
@@ -368,7 +368,7 @@ static void update_stream_freesync_context(struct core_freesync *core_freesync,
 }
 
 static void update_stream(struct core_freesync *core_freesync,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	unsigned int index = map_index_from_stream(core_freesync, stream);
 	if (core_freesync->map[index].caps->supported) {
@@ -378,7 +378,7 @@ static void update_stream(struct core_freesync *core_freesync,
 }
 
 static void calc_freesync_range(struct core_freesync *core_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		struct freesync_state *state,
 		unsigned int min_refresh_in_uhz,
 		unsigned int max_refresh_in_uhz)
@@ -452,7 +452,7 @@ static void calc_freesync_range(struct core_freesync *core_freesync,
 		min_frame_duration_in_ns) / 2000;
 }
 
-static void calc_v_total_from_duration(struct dc_stream *stream,
+static void calc_v_total_from_duration(struct dc_stream_state *stream,
 		unsigned int duration_in_ns, int *v_total_nominal)
 {
 	*v_total_nominal = div64_u64(div64_u64(((unsigned long long)(
@@ -461,7 +461,7 @@ static void calc_v_total_from_duration(struct dc_stream *stream,
 }
 
 static void calc_v_total_for_static_ramp(struct core_freesync *core_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		unsigned int index, int *v_total)
 {
 	unsigned int frame_duration = 0;
@@ -557,7 +557,7 @@ static void reset_freesync_state_variables(struct freesync_state* state)
  * Sets freesync mode on a stream depending on current freesync state.
  */
 static bool set_freesync_on_streams(struct core_freesync *core_freesync,
-		struct dc_stream **streams, int num_streams)
+		struct dc_stream_state **streams, int num_streams)
 {
 	int v_total_nominal = 0, v_total_min = 0, v_total_max = 0;
 	unsigned int stream_idx, map_index = 0;
@@ -729,7 +729,7 @@ static void set_static_ramp_variables(struct core_freesync *core_freesync,
 }
 
 void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
-		struct dc_stream **streams, int num_streams)
+		struct dc_stream_state **streams, int num_streams)
 {
 	unsigned int index, v_total, inserted_frame_v_total = 0;
 	unsigned int min_frame_duration_in_ns, vmax, vmin = 0;
@@ -839,7 +839,7 @@ void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
 }
 
 void mod_freesync_update_state(struct mod_freesync *mod_freesync,
-		struct dc_stream **streams, int num_streams,
+		struct dc_stream_state **streams, int num_streams,
 		struct mod_freesync_params *freesync_params)
 {
 	bool freesync_program_required = false;
@@ -929,7 +929,7 @@ void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 
 
 bool mod_freesync_get_state(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		struct mod_freesync_params *freesync_params)
 {
 	unsigned int index = 0;
@@ -965,7 +965,7 @@ bool mod_freesync_get_state(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
-		struct dc_stream **streams, int num_streams,
+		struct dc_stream_state **streams, int num_streams,
 		struct mod_freesync_user_enable *user_enable)
 {
 	unsigned int stream_index, map_index;
@@ -1017,7 +1017,7 @@ bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		struct mod_freesync_user_enable *user_enable)
 {
 	unsigned int index = 0;
@@ -1035,7 +1035,7 @@ bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_static_ramp_active(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		bool *is_ramp_active)
 {
 	unsigned int index = 0;
@@ -1054,7 +1054,7 @@ bool mod_freesync_get_static_ramp_active(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
-		struct dc_stream *streams,
+		struct dc_stream_state *streams,
 		unsigned int min_refresh,
 		unsigned int max_refresh,
 		struct mod_freesync_caps *caps)
@@ -1107,7 +1107,7 @@ bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_min_max(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		unsigned int *min_refresh,
 		unsigned int *max_refresh)
 {
@@ -1129,7 +1129,7 @@ bool mod_freesync_get_min_max(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_vmin_vmax(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		unsigned int *vmin,
 		unsigned int *vmax)
 {
@@ -1151,7 +1151,7 @@ bool mod_freesync_get_vmin_vmax(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		unsigned int *nom_v_pos,
 		unsigned int *v_pos)
 {
@@ -1179,7 +1179,7 @@ bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
 }
 
 void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
-		struct dc_stream **streams, int num_streams)
+		struct dc_stream_state **streams, int num_streams)
 {
 	unsigned int stream_index, map_index;
 	struct freesync_state *state;
@@ -1239,7 +1239,7 @@ void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
  * is required, depending on the times calculated
  */
 static void update_timestamps(struct core_freesync *core_freesync,
-		const struct dc_stream *stream, unsigned int map_index,
+		const struct dc_stream_state *stream, unsigned int map_index,
 		unsigned int last_render_time_in_us)
 {
 	struct freesync_state *state = &core_freesync->map[map_index].state;
@@ -1304,7 +1304,7 @@ static void update_timestamps(struct core_freesync *core_freesync,
 }
 
 static void apply_below_the_range(struct core_freesync *core_freesync,
-		struct dc_stream *stream, unsigned int map_index,
+		struct dc_stream_state *stream, unsigned int map_index,
 		unsigned int last_render_time_in_us)
 {
 	unsigned int inserted_frame_duration_in_us = 0;
@@ -1403,7 +1403,7 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 }
 
 static void apply_fixed_refresh(struct core_freesync *core_freesync,
-		struct dc_stream *stream, unsigned int map_index)
+		struct dc_stream_state *stream, unsigned int map_index)
 {
 	unsigned int vmin = 0, vmax = 0;
 	struct freesync_state *state = &core_freesync->map[map_index].state;
@@ -1434,7 +1434,7 @@ static void apply_fixed_refresh(struct core_freesync *core_freesync,
 }
 
 void mod_freesync_pre_update_plane_addresses(struct mod_freesync *mod_freesync,
-		struct dc_stream **streams, int num_streams,
+		struct dc_stream_state **streams, int num_streams,
 		unsigned int curr_time_stamp_in_us)
 {
 	unsigned int stream_index, map_index, last_render_time_in_us = 0;

commit 4fa086b9b6640818c053c79d4d7104790ba76cb7
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Jul 25 20:51:26 2017 -0400

    drm/amd/display: Roll core_stream into dc_stream
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index a989d5de9f3c..358f8a855a59 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -111,7 +111,7 @@ struct freesync_state {
 };
 
 struct freesync_entity {
-	const struct dc_stream *stream;
+	struct dc_stream *stream;
 	struct mod_freesync_caps *caps;
 	struct freesync_state state;
 	struct mod_freesync_user_enable user_enable;
@@ -229,7 +229,7 @@ void mod_freesync_destroy(struct mod_freesync *mod_freesync)
  * on the core_freesync->map and returns the corresponding index
  */
 static unsigned int map_index_from_stream(struct core_freesync *core_freesync,
-		const struct dc_stream *stream)
+		struct dc_stream *stream)
 {
 	unsigned int index = 0;
 
@@ -244,9 +244,8 @@ static unsigned int map_index_from_stream(struct core_freesync *core_freesync,
 }
 
 bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream, struct mod_freesync_caps *caps)
+		struct dc_stream *stream, struct mod_freesync_caps *caps)
 {
-	struct core_stream *core_stream = NULL;
 	struct core_dc *core_dc = NULL;
 	struct core_freesync *core_freesync = NULL;
 	int persistent_freesync_enable = 0;
@@ -258,7 +257,6 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 		return false;
 
 	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
-	core_stream = DC_STREAM_TO_CORE(stream);
 	core_dc = DC_TO_CORE(core_freesync->dc);
 
 	flag.save_per_edid = true;
@@ -315,7 +313,7 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 		if (caps->supported &&
 			nom_refresh_rate_uhz >= caps->min_refresh_in_micro_hz &&
 			nom_refresh_rate_uhz <= caps->max_refresh_in_micro_hz)
-			core_stream->public.ignore_msa_timing_param = 1;
+			stream->ignore_msa_timing_param = 1;
 
 		core_freesync->num_entities++;
 		return true;
@@ -324,7 +322,7 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_remove_stream(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream)
+		struct dc_stream *stream)
 {
 	int i = 0;
 	struct core_freesync *core_freesync = NULL;
@@ -346,14 +344,12 @@ bool mod_freesync_remove_stream(struct mod_freesync *mod_freesync,
 }
 
 static void update_stream_freesync_context(struct core_freesync *core_freesync,
-		const struct dc_stream *stream)
+		struct dc_stream *stream)
 {
 	unsigned int index;
 	struct freesync_context *ctx;
-	struct core_stream *core_stream;
 
-	core_stream = DC_STREAM_TO_CORE(stream);
-	ctx = &core_stream->public.freesync_ctx;
+	ctx = &stream->freesync_ctx;
 
 	index = map_index_from_stream(core_freesync, stream);
 
@@ -372,19 +368,17 @@ static void update_stream_freesync_context(struct core_freesync *core_freesync,
 }
 
 static void update_stream(struct core_freesync *core_freesync,
-		const struct dc_stream *stream)
+		struct dc_stream *stream)
 {
-	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
-
 	unsigned int index = map_index_from_stream(core_freesync, stream);
 	if (core_freesync->map[index].caps->supported) {
-		core_stream->public.ignore_msa_timing_param = 1;
+		stream->ignore_msa_timing_param = 1;
 		update_stream_freesync_context(core_freesync, stream);
 	}
 }
 
 static void calc_freesync_range(struct core_freesync *core_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		struct freesync_state *state,
 		unsigned int min_refresh_in_uhz,
 		unsigned int max_refresh_in_uhz)
@@ -458,7 +452,7 @@ static void calc_freesync_range(struct core_freesync *core_freesync,
 		min_frame_duration_in_ns) / 2000;
 }
 
-static void calc_v_total_from_duration(const struct dc_stream *stream,
+static void calc_v_total_from_duration(struct dc_stream *stream,
 		unsigned int duration_in_ns, int *v_total_nominal)
 {
 	*v_total_nominal = div64_u64(div64_u64(((unsigned long long)(
@@ -467,7 +461,7 @@ static void calc_v_total_from_duration(const struct dc_stream *stream,
 }
 
 static void calc_v_total_for_static_ramp(struct core_freesync *core_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		unsigned int index, int *v_total)
 {
 	unsigned int frame_duration = 0;
@@ -563,7 +557,7 @@ static void reset_freesync_state_variables(struct freesync_state* state)
  * Sets freesync mode on a stream depending on current freesync state.
  */
 static bool set_freesync_on_streams(struct core_freesync *core_freesync,
-		const struct dc_stream **streams, int num_streams)
+		struct dc_stream **streams, int num_streams)
 {
 	int v_total_nominal = 0, v_total_min = 0, v_total_max = 0;
 	unsigned int stream_idx, map_index = 0;
@@ -735,7 +729,7 @@ static void set_static_ramp_variables(struct core_freesync *core_freesync,
 }
 
 void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
-		const struct dc_stream **streams, int num_streams)
+		struct dc_stream **streams, int num_streams)
 {
 	unsigned int index, v_total, inserted_frame_v_total = 0;
 	unsigned int min_frame_duration_in_ns, vmax, vmin = 0;
@@ -845,7 +839,7 @@ void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
 }
 
 void mod_freesync_update_state(struct mod_freesync *mod_freesync,
-		const struct dc_stream **streams, int num_streams,
+		struct dc_stream **streams, int num_streams,
 		struct mod_freesync_params *freesync_params)
 {
 	bool freesync_program_required = false;
@@ -935,7 +929,7 @@ void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 
 
 bool mod_freesync_get_state(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		struct mod_freesync_params *freesync_params)
 {
 	unsigned int index = 0;
@@ -971,7 +965,7 @@ bool mod_freesync_get_state(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
-		const struct dc_stream **streams, int num_streams,
+		struct dc_stream **streams, int num_streams,
 		struct mod_freesync_user_enable *user_enable)
 {
 	unsigned int stream_index, map_index;
@@ -1023,7 +1017,7 @@ bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		struct mod_freesync_user_enable *user_enable)
 {
 	unsigned int index = 0;
@@ -1041,7 +1035,7 @@ bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_static_ramp_active(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		bool *is_ramp_active)
 {
 	unsigned int index = 0;
@@ -1060,7 +1054,7 @@ bool mod_freesync_get_static_ramp_active(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
-		const struct dc_stream *streams,
+		struct dc_stream *streams,
 		unsigned int min_refresh,
 		unsigned int max_refresh,
 		struct mod_freesync_caps *caps)
@@ -1113,7 +1107,7 @@ bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_min_max(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		unsigned int *min_refresh,
 		unsigned int *max_refresh)
 {
@@ -1135,7 +1129,7 @@ bool mod_freesync_get_min_max(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_vmin_vmax(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		unsigned int *vmin,
 		unsigned int *vmax)
 {
@@ -1157,7 +1151,7 @@ bool mod_freesync_get_vmin_vmax(struct mod_freesync *mod_freesync,
 }
 
 bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
-		const struct dc_stream *stream,
+		struct dc_stream *stream,
 		unsigned int *nom_v_pos,
 		unsigned int *v_pos)
 {
@@ -1185,7 +1179,7 @@ bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
 }
 
 void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
-		const struct dc_stream **streams, int num_streams)
+		struct dc_stream **streams, int num_streams)
 {
 	unsigned int stream_index, map_index;
 	struct freesync_state *state;
@@ -1310,7 +1304,7 @@ static void update_timestamps(struct core_freesync *core_freesync,
 }
 
 static void apply_below_the_range(struct core_freesync *core_freesync,
-		const struct dc_stream *stream, unsigned int map_index,
+		struct dc_stream *stream, unsigned int map_index,
 		unsigned int last_render_time_in_us)
 {
 	unsigned int inserted_frame_duration_in_us = 0;
@@ -1409,7 +1403,7 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 }
 
 static void apply_fixed_refresh(struct core_freesync *core_freesync,
-		const struct dc_stream *stream, unsigned int map_index)
+		struct dc_stream *stream, unsigned int map_index)
 {
 	unsigned int vmin = 0, vmax = 0;
 	struct freesync_state *state = &core_freesync->map[map_index].state;
@@ -1440,7 +1434,7 @@ static void apply_fixed_refresh(struct core_freesync *core_freesync,
 }
 
 void mod_freesync_pre_update_plane_addresses(struct mod_freesync *mod_freesync,
-		const struct dc_stream **streams, int num_streams,
+		struct dc_stream **streams, int num_streams,
 		unsigned int curr_time_stamp_in_us)
 {
 	unsigned int stream_index, map_index, last_render_time_in_us = 0;

commit 2233ec72b350fb8480f67b83f6a71ea422af60a3
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Jul 18 10:21:43 2017 -0400

    drm/amd/display: Add regkey for DRR control for internal panel
    
    Also need to change default to off
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 4df79f7147f8..a989d5de9f3c 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -43,6 +43,10 @@
 
 #define FREESYNC_REGISTRY_NAME "freesync_v1"
 
+#define FREESYNC_NO_STATIC_FOR_EXTERNAL_DP_REGKEY "DalFreeSyncNoStaticForExternalDp"
+
+#define FREESYNC_NO_STATIC_FOR_INTERNAL_REGKEY "DalFreeSyncNoStaticForInternal"
+
 struct gradual_static_ramp {
 	bool ramp_is_active;
 	bool ramp_direction_is_up;
@@ -114,7 +118,8 @@ struct freesync_entity {
 };
 
 struct freesync_registry_options {
-	unsigned int min_refresh_from_edid;
+	bool drr_external_supported;
+	bool drr_internal_supported;
 };
 
 struct core_freesync {
@@ -176,9 +181,19 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 			NULL, NULL, 0, &flag);
 	flag.save_per_edid = false;
 	flag.save_per_link = false;
+
 	if (dm_read_persistent_data(core_dc->ctx, NULL, NULL,
-			"DalDrrSupport", &data, sizeof(data), &flag)) {
-		core_freesync->opts.min_refresh_from_edid = data;
+			FREESYNC_NO_STATIC_FOR_INTERNAL_REGKEY,
+			&data, sizeof(data), &flag)) {
+		core_freesync->opts.drr_internal_supported =
+			(data & 1) ? false : true;
+	}
+
+	if (dm_read_persistent_data(core_dc->ctx, NULL, NULL,
+			FREESYNC_NO_STATIC_FOR_EXTERNAL_DP_REGKEY,
+			&data, sizeof(data), &flag)) {
+		core_freesync->opts.drr_external_supported =
+				(data & 1) ? false : true;
 	}
 
 	return &core_freesync->public;
@@ -236,7 +251,7 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 	struct core_freesync *core_freesync = NULL;
 	int persistent_freesync_enable = 0;
 	struct persistent_data_flag flag;
-	unsigned int nom_refresh_rate_micro_hz;
+	unsigned int nom_refresh_rate_uhz;
 	unsigned long long temp;
 
 	if (mod_freesync == NULL)
@@ -258,20 +273,7 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 		temp = div_u64(temp, stream->timing.h_total);
 		temp = div_u64(temp, stream->timing.v_total);
 
-		nom_refresh_rate_micro_hz = (unsigned int) temp;
-
-		if (core_freesync->opts.min_refresh_from_edid != 0 &&
-				dc_is_embedded_signal(stream->sink->sink_signal)
-				&& (nom_refresh_rate_micro_hz -
-				core_freesync->opts.min_refresh_from_edid *
-				1000000) >= 10000000) {
-			caps->supported = true;
-			caps->min_refresh_in_micro_hz =
-				core_freesync->opts.min_refresh_from_edid *
-					1000000;
-			caps->max_refresh_in_micro_hz =
-					nom_refresh_rate_micro_hz;
-		}
+		nom_refresh_rate_uhz = (unsigned int) temp;
 
 		core_freesync->map[core_freesync->num_entities].stream = stream;
 		core_freesync->map[core_freesync->num_entities].caps = caps;
@@ -311,8 +313,8 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 		}
 
 		if (caps->supported &&
-		    nom_refresh_rate_micro_hz >= caps->min_refresh_in_micro_hz &&
-		    nom_refresh_rate_micro_hz <= caps->max_refresh_in_micro_hz)
+			nom_refresh_rate_uhz >= caps->min_refresh_in_micro_hz &&
+			nom_refresh_rate_uhz <= caps->max_refresh_in_micro_hz)
 			core_stream->public.ignore_msa_timing_param = 1;
 
 		core_freesync->num_entities++;
@@ -865,6 +867,11 @@ void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 		unsigned int map_index = map_index_from_stream(core_freesync,
 				streams[stream_index]);
 
+		bool is_embedded = dc_is_embedded_signal(
+				streams[stream_index]->sink->sink_signal);
+
+		struct freesync_registry_options *opts = &core_freesync->opts;
+
 		state = &core_freesync->map[map_index].state;
 
 		switch (freesync_params->state){
@@ -875,25 +882,24 @@ void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 					freesync_params->windowed_fullscreen;
 			break;
 		case FREESYNC_STATE_STATIC_SCREEN:
-			/* Static screen ramp is only enabled for embedded
-			 * panels. Also change core variables only if there
-			 * is a change.
+			/* Static screen ramp is disabled by default, but can
+			 * be enabled through regkey.
 			 */
-			if ((dc_is_embedded_signal(
-				streams[stream_index]->sink->sink_signal) ||
-				core_freesync->map[map_index].caps->
-				no_static_for_external_dp == false) &&
-				state->static_screen !=
-				freesync_params->enable) {
+			if ((is_embedded && opts->drr_internal_supported) ||
+				(!is_embedded && opts->drr_external_supported))
 
-				/* Change the state flag */
-				state->static_screen = freesync_params->enable;
+				if (state->static_screen !=
+						freesync_params->enable) {
 
-				/* Change static screen ramp variables */
-				set_static_ramp_variables(core_freesync,
+					/* Change the state flag */
+					state->static_screen =
+							freesync_params->enable;
+
+					/* Update static screen ramp */
+					set_static_ramp_variables(core_freesync,
 						map_index,
 						freesync_params->enable);
-			}
+				}
 			/* We program the ramp starting next VUpdate */
 			break;
 		case FREESYNC_STATE_VIDEO:

commit 1a87fbfee0a0f96e8b482c2ac7eae113c9ca2497
Author: Amy Zhang <Amy.Zhang@amd.com>
Date:   Wed Jun 28 18:14:09 2017 -0400

    drm/amd/display: Re-enable Vsync Interrupts for Gradual Refresh Ramp
    
    - Make sure Vsync interrupts are disabled in static screen case
      and enabled when not to save power
    - Create no_static_for_external_dp debug option
    
    Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index c7da90f2d8e7..4df79f7147f8 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -440,14 +440,11 @@ static void calc_freesync_range(struct core_freesync *core_freesync,
 	}
 
 	/* Determine whether BTR can be supported */
-	//if (max_frame_duration_in_ns >=
-	//		2 * min_frame_duration_in_ns)
-	//	core_freesync->map[index].caps->btr_supported = true;
-	//else
-	//	core_freesync->map[index].caps->btr_supported = false;
-
-	/* Temp, keep btr disabled */
-	core_freesync->map[index].caps->btr_supported = false;
+	if (max_frame_duration_in_ns >=
+			2 * min_frame_duration_in_ns)
+		core_freesync->map[index].caps->btr_supported = true;
+	else
+		core_freesync->map[index].caps->btr_supported = false;
 
 	/* Cache the time variables */
 	state->time.max_render_time_in_us =
@@ -882,8 +879,10 @@ void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 			 * panels. Also change core variables only if there
 			 * is a change.
 			 */
-			if (dc_is_embedded_signal(
-				streams[stream_index]->sink->sink_signal) &&
+			if ((dc_is_embedded_signal(
+				streams[stream_index]->sink->sink_signal) ||
+				core_freesync->map[map_index].caps->
+				no_static_for_external_dp == false) &&
 				state->static_screen !=
 				freesync_params->enable) {
 
@@ -1035,6 +1034,25 @@ bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
 	return true;
 }
 
+bool mod_freesync_get_static_ramp_active(struct mod_freesync *mod_freesync,
+		const struct dc_stream *stream,
+		bool *is_ramp_active)
+{
+	unsigned int index = 0;
+	struct core_freesync *core_freesync = NULL;
+
+	if (mod_freesync == NULL)
+		return false;
+
+	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
+	index = map_index_from_stream(core_freesync, stream);
+
+	*is_ramp_active =
+		core_freesync->map[index].state.static_ramp.ramp_is_active;
+
+	return true;
+}
+
 bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
 		const struct dc_stream *streams,
 		unsigned int min_refresh,

commit d09fec0f94376b1c0048215e14838295730ed6d3
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Jun 27 13:27:00 2017 -0400

    drm/amd/display: add hyst frames for fixed refresh
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 7109742bd67c..c7da90f2d8e7 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -37,6 +37,9 @@
 #define RENDER_TIMES_MAX_COUNT 20
 /* Threshold to exit BTR (to avoid frequent enter-exits at the lower limit) */
 #define BTR_EXIT_MARGIN 2000
+/* Number of consecutive frames to check before entering/exiting fixed refresh*/
+#define FIXED_REFRESH_ENTER_FRAME_COUNT 5
+#define FIXED_REFRESH_EXIT_FRAME_COUNT 5
 
 #define FREESYNC_REGISTRY_NAME "freesync_v1"
 
@@ -72,8 +75,9 @@ struct below_the_range {
 };
 
 struct fixed_refresh {
-	bool fixed_refresh_active;
-	bool program_fixed_refresh;
+	bool fixed_active;
+	bool program_fixed;
+	unsigned int frame_counter;
 };
 
 struct freesync_range {
@@ -168,8 +172,8 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 	/* Create initial module folder in registry for freesync enable data */
 	flag.save_per_edid = true;
 	flag.save_per_link = false;
-	dm_write_persistent_data(core_dc->ctx, NULL, FREESYNC_REGISTRY_NAME, NULL, NULL,
-					0, &flag);
+	dm_write_persistent_data(core_dc->ctx, NULL, FREESYNC_REGISTRY_NAME,
+			NULL, NULL, 0, &flag);
 	flag.save_per_edid = false;
 	flag.save_per_link = false;
 	if (dm_read_persistent_data(core_dc->ctx, NULL, NULL,
@@ -422,7 +426,7 @@ static void calc_freesync_range(struct core_freesync *core_freesync,
 		min_frame_duration_in_ns) * stream->timing.pix_clk_khz),
 		stream->timing.h_total), 1000000);
 
-	/* In case of 4k free sync monitor, vmin or vmax cannot be less than vtotal */
+	/* vmin/vmax cannot be less than vtotal */
 	if (state->freesync_range.vmin < vtotal) {
 		/* Error of 1 is permissible */
 		ASSERT((state->freesync_range.vmin + 1) >= vtotal);
@@ -553,8 +557,8 @@ static void reset_freesync_state_variables(struct freesync_state* state)
 	state->btr.inserted_frame_duration_in_us = 0;
 	state->btr.program_btr = false;
 
-	state->fixed_refresh.fixed_refresh_active = false;
-	state->fixed_refresh.program_fixed_refresh = false;
+	state->fixed_refresh.fixed_active = false;
+	state->fixed_refresh.program_fixed = false;
 }
 /*
  * Sets freesync mode on a stream depending on current freesync state.
@@ -594,7 +598,7 @@ static bool set_freesync_on_streams(struct core_freesync *core_freesync,
 			if (core_freesync->map[map_index].user_enable.
 				enable_for_gaming == true &&
 				state->fullscreen == true &&
-				state->fixed_refresh.fixed_refresh_active == false) {
+				state->fixed_refresh.fixed_active == false) {
 				/* Enable freesync */
 
 				v_total_min = state->freesync_range.vmin;
@@ -1240,29 +1244,39 @@ static void update_timestamps(struct core_freesync *core_freesync,
 			state->btr.frame_counter = 0;
 
 		/* Exit Fixed Refresh mode */
-		} else if (state->fixed_refresh.fixed_refresh_active) {
+		} else if (state->fixed_refresh.fixed_active) {
 
-			state->fixed_refresh.program_fixed_refresh = true;
-			state->fixed_refresh.fixed_refresh_active = false;
+			state->fixed_refresh.frame_counter++;
 
+			if (state->fixed_refresh.frame_counter >
+					FIXED_REFRESH_EXIT_FRAME_COUNT) {
+				state->fixed_refresh.frame_counter = 0;
+				state->fixed_refresh.program_fixed = true;
+				state->fixed_refresh.fixed_active = false;
+			}
 		}
 
 	} else if (last_render_time_in_us > state->time.max_render_time_in_us) {
 
 		/* Enter Below the Range */
 		if (!state->btr.btr_active &&
-				core_freesync->map[map_index].caps->btr_supported) {
+			core_freesync->map[map_index].caps->btr_supported) {
 
 			state->btr.program_btr = true;
 			state->btr.btr_active = true;
 
 		/* Enter Fixed Refresh mode */
-		} else if (!state->fixed_refresh.fixed_refresh_active &&
+		} else if (!state->fixed_refresh.fixed_active &&
 			!core_freesync->map[map_index].caps->btr_supported) {
 
-			state->fixed_refresh.program_fixed_refresh = true;
-			state->fixed_refresh.fixed_refresh_active = true;
+			state->fixed_refresh.frame_counter++;
 
+			if (state->fixed_refresh.frame_counter >
+					FIXED_REFRESH_ENTER_FRAME_COUNT) {
+				state->fixed_refresh.frame_counter = 0;
+				state->fixed_refresh.program_fixed = true;
+				state->fixed_refresh.fixed_active = true;
+			}
 		}
 	}
 
@@ -1316,7 +1330,8 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 
 			frame_time_in_us = last_render_time_in_us /
 				mid_point_frames_ceil;
-			delta_from_mid_point_in_us_1 = (state->btr.mid_point_in_us >
+			delta_from_mid_point_in_us_1 =
+				(state->btr.mid_point_in_us >
 				frame_time_in_us) ?
 				(state->btr.mid_point_in_us - frame_time_in_us):
 				(frame_time_in_us - state->btr.mid_point_in_us);
@@ -1332,7 +1347,8 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 
 			frame_time_in_us = last_render_time_in_us /
 				mid_point_frames_floor;
-			delta_from_mid_point_in_us_2 = (state->btr.mid_point_in_us >
+			delta_from_mid_point_in_us_2 =
+				(state->btr.mid_point_in_us >
 				frame_time_in_us) ?
 				(state->btr.mid_point_in_us - frame_time_in_us):
 				(frame_time_in_us - state->btr.mid_point_in_us);
@@ -1374,15 +1390,15 @@ static void apply_fixed_refresh(struct core_freesync *core_freesync,
 	unsigned int vmin = 0, vmax = 0;
 	struct freesync_state *state = &core_freesync->map[map_index].state;
 
-	if (!state->fixed_refresh.program_fixed_refresh)
+	if (!state->fixed_refresh.program_fixed)
 		return;
 
-	state->fixed_refresh.program_fixed_refresh = false;
+	state->fixed_refresh.program_fixed = false;
 
 	/* Program Fixed Refresh */
 
 	/* Fixed Refresh set to "not active" so disengage */
-	if (!state->fixed_refresh.fixed_refresh_active) {
+	if (!state->fixed_refresh.fixed_active) {
 		set_freesync_on_streams(core_freesync, &stream, 1);
 
 	/* Fixed Refresh set to "active" so engage (fix to max) */

commit fea0f581ab529e194d424452a6f7ecd88c5a2116
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Jun 6 16:30:51 2017 -0400

    drm/amd/display: Temporary disable BTR FreeSync support for now
    
    Reduce timer tick interval for the static screen
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index f79c47951f90..7109742bd67c 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -436,11 +436,14 @@ static void calc_freesync_range(struct core_freesync *core_freesync,
 	}
 
 	/* Determine whether BTR can be supported */
-	if (max_frame_duration_in_ns >=
-			2 * min_frame_duration_in_ns)
-		core_freesync->map[index].caps->btr_supported = true;
-	else
-		core_freesync->map[index].caps->btr_supported = false;
+	//if (max_frame_duration_in_ns >=
+	//		2 * min_frame_duration_in_ns)
+	//	core_freesync->map[index].caps->btr_supported = true;
+	//else
+	//	core_freesync->map[index].caps->btr_supported = false;
+
+	/* Temp, keep btr disabled */
+	core_freesync->map[index].caps->btr_supported = false;
 
 	/* Cache the time variables */
 	state->time.max_render_time_in_us =

commit fc82c5cb306d6f201cdee2c4c092ff49c6929634
Author: Amy Zhang <Amy.Zhang@amd.com>
Date:   Fri Jun 2 16:33:47 2017 -0400

    drm/amd/display: Fix DRR Enable on Desktop
    
    - Block PSR in Full screen apps to prevent incorrect static screen curser events
    - Reprogram static screen events when update freesync state
    - Program static ramp variable active after other values are programmed
    - Correct wrong assigning of the nominal and current vcount
    
    Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 9a073bc55144..f79c47951f90 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -257,8 +257,10 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 		nom_refresh_rate_micro_hz = (unsigned int) temp;
 
 		if (core_freesync->opts.min_refresh_from_edid != 0 &&
-				dc_is_embedded_signal(
-					stream->sink->sink_signal)) {
+				dc_is_embedded_signal(stream->sink->sink_signal)
+				&& (nom_refresh_rate_micro_hz -
+				core_freesync->opts.min_refresh_from_edid *
+				1000000) >= 10000000) {
 			caps->supported = true;
 			caps->min_refresh_in_micro_hz =
 				core_freesync->opts.min_refresh_from_edid *
@@ -683,44 +685,47 @@ static void set_static_ramp_variables(struct core_freesync *core_freesync,
 		unsigned int index, bool enable_static_screen)
 {
 	unsigned int frame_duration = 0;
-
+	unsigned int nominal_refresh_rate = core_freesync->map[index].state.
+			nominal_refresh_rate_in_micro_hz;
+	unsigned int min_refresh_rate= core_freesync->map[index].caps->
+			min_refresh_in_micro_hz;
 	struct gradual_static_ramp *static_ramp_variables =
 			&core_freesync->map[index].state.static_ramp;
 
+	/* If we are ENABLING static screen, refresh rate should go DOWN.
+	 * If we are DISABLING static screen, refresh rate should go UP.
+	 */
+	if (enable_static_screen)
+		static_ramp_variables->ramp_direction_is_up = false;
+	else
+		static_ramp_variables->ramp_direction_is_up = true;
+
 	/* If ramp is not active, set initial frame duration depending on
 	 * whether we are enabling/disabling static screen mode. If the ramp is
 	 * already active, ramp should continue in the opposite direction
 	 * starting with the current frame duration
 	 */
 	if (!static_ramp_variables->ramp_is_active) {
-
-		static_ramp_variables->ramp_is_active = true;
-
 		if (enable_static_screen == true) {
 			/* Going to lower refresh rate, so start from max
 			 * refresh rate (min frame duration)
 			 */
 			frame_duration = ((unsigned int) (div64_u64(
 				(1000000000ULL * 1000000),
-				core_freesync->map[index].state.
-				nominal_refresh_rate_in_micro_hz)));
+				nominal_refresh_rate)));
 		} else {
 			/* Going to higher refresh rate, so start from min
 			 * refresh rate (max frame duration)
 			 */
 			frame_duration = ((unsigned int) (div64_u64(
 				(1000000000ULL * 1000000),
-				core_freesync->map[index].caps->min_refresh_in_micro_hz)));
+				min_refresh_rate)));
 		}
-
 		static_ramp_variables->
 			ramp_current_frame_duration_in_ns = frame_duration;
-	}
 
-	/* If we are ENABLING static screen, refresh rate should go DOWN.
-	 * If we are DISABLING static screen, refresh rate should go UP.
-	 */
-	static_ramp_variables->ramp_direction_is_up = !enable_static_screen;
+		static_ramp_variables->ramp_is_active = true;
+	}
 }
 
 void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
@@ -841,6 +846,7 @@ void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 	unsigned int stream_index;
 	struct freesync_state *state;
 	struct core_freesync *core_freesync = NULL;
+	struct dc_static_screen_events triggers = {0};
 
 	if (mod_freesync == NULL)
 		return;
@@ -902,6 +908,14 @@ void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 		}
 	}
 
+	/* Update mask */
+	triggers.overlay_update = true;
+	triggers.surface_update = true;
+
+	core_freesync->dc->stream_funcs.set_static_screen_events(
+		core_freesync->dc, streams, num_streams,
+		&triggers);
+
 	if (freesync_program_required)
 		/* Program freesync according to current state*/
 		set_freesync_on_streams(core_freesync, streams, num_streams);
@@ -1017,7 +1031,8 @@ bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
 bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
 		const struct dc_stream *streams,
 		unsigned int min_refresh,
-		unsigned int max_refresh)
+		unsigned int max_refresh,
+		struct mod_freesync_caps *caps)
 {
 	unsigned int index = 0;
 	struct core_freesync *core_freesync;
@@ -1030,7 +1045,10 @@ bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
 	index = map_index_from_stream(core_freesync, streams);
 	state = &core_freesync->map[index].state;
 
-	if (min_refresh == 0 || max_refresh == 0) {
+	if (max_refresh == 0)
+		max_refresh = state->nominal_refresh_rate_in_micro_hz;
+
+	if (min_refresh == 0) {
 		/* Restore defaults */
 		calc_freesync_range(core_freesync, streams, state,
 			core_freesync->map[index].caps->
@@ -1049,6 +1067,17 @@ bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
 			state->freesync_range.vmax);
 	}
 
+	if (min_refresh != 0 &&
+			dc_is_embedded_signal(streams->sink->sink_signal) &&
+			(max_refresh - min_refresh >= 10000000)) {
+		caps->supported = true;
+		caps->min_refresh_in_micro_hz = min_refresh;
+		caps->max_refresh_in_micro_hz = max_refresh;
+	}
+
+	/* Update the stream */
+	update_stream(core_freesync, streams);
+
 	return true;
 }
 
@@ -1115,8 +1144,8 @@ bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
 			core_freesync->dc, &stream, 1,
 			&position.vertical_count, &position.nominal_vcount)) {
 
-		*nom_v_pos = position.vertical_count;
-		*v_pos = position.nominal_vcount;
+		*nom_v_pos = position.nominal_vcount;
+		*v_pos = position.vertical_count;
 
 		return true;
 	}
@@ -1131,6 +1160,7 @@ void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
 	struct freesync_state *state;
 	struct core_freesync *core_freesync = NULL;
 	struct dc_static_screen_events triggers = {0};
+	unsigned long long temp = 0;
 
 	if (mod_freesync == NULL)
 		return;
@@ -1143,22 +1173,21 @@ void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
 
 		state = &core_freesync->map[map_index].state;
 
+		/* Update the field rate for new timing */
+		temp = streams[stream_index]->timing.pix_clk_khz;
+		temp *= 1000ULL * 1000ULL * 1000ULL;
+		temp = div_u64(temp,
+				streams[stream_index]->timing.h_total);
+		temp = div_u64(temp,
+				streams[stream_index]->timing.v_total);
+		state->nominal_refresh_rate_in_micro_hz =
+				(unsigned int) temp;
+
 		if (core_freesync->map[map_index].caps->supported) {
-			/* Update the field rate for new timing */
-			unsigned long long temp;
-			temp = streams[stream_index]->timing.pix_clk_khz;
-			temp *= 1000ULL * 1000ULL * 1000ULL;
-			temp = div_u64(temp,
-					streams[stream_index]->timing.h_total);
-			temp = div_u64(temp,
-					streams[stream_index]->timing.v_total);
-			state->nominal_refresh_rate_in_micro_hz =
-					(unsigned int) temp;
 
 			/* Update the stream */
 			update_stream(core_freesync, streams[stream_index]);
 
-
 			/* Calculate vmin/vmax and refresh rate for
 			 * current mode
 			 */

commit 6838161c723d061c85e20057dbf0a2a9378c4e59
Author: Corbin McElhanney <corbin.mcelhanney@amd.com>
Date:   Tue May 9 12:00:24 2017 -0400

    drm/amd/display: fix freesync not working on raven
    
    Signed-off-by: Corbin McElhanney <corbin.mcelhanney@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 05a086c7b31a..9a073bc55144 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -1130,6 +1130,7 @@ void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
 	unsigned int stream_index, map_index;
 	struct freesync_state *state;
 	struct core_freesync *core_freesync = NULL;
+	struct dc_static_screen_events triggers = {0};
 
 	if (mod_freesync == NULL)
 		return;
@@ -1157,6 +1158,7 @@ void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
 			/* Update the stream */
 			update_stream(core_freesync, streams[stream_index]);
 
+
 			/* Calculate vmin/vmax and refresh rate for
 			 * current mode
 			 */
@@ -1164,6 +1166,14 @@ void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
 				core_freesync->map[map_index].caps->
 				min_refresh_in_micro_hz,
 				state->nominal_refresh_rate_in_micro_hz);
+
+			/* Update mask */
+			triggers.overlay_update = true;
+			triggers.surface_update = true;
+
+			core_freesync->dc->stream_funcs.set_static_screen_events(
+				core_freesync->dc, streams, num_streams,
+				&triggers);
 		}
 	}
 

commit ac5c294719909bd5d2d3f8c74f894bdda5744916
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri May 5 15:07:55 2017 -0400

    drm/amd/display: prevent assert on error of 1 in calc_freesync_range
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index c5330f3cc1de..05a086c7b31a 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -422,12 +422,14 @@ static void calc_freesync_range(struct core_freesync *core_freesync,
 
 	/* In case of 4k free sync monitor, vmin or vmax cannot be less than vtotal */
 	if (state->freesync_range.vmin < vtotal) {
-		ASSERT(false);
+		/* Error of 1 is permissible */
+		ASSERT((state->freesync_range.vmin + 1) >= vtotal);
 		state->freesync_range.vmin = vtotal;
 	}
 
 	if (state->freesync_range.vmax < vtotal) {
-		ASSERT(false);
+		/* Error of 1 is permissible */
+		ASSERT((state->freesync_range.vmax + 1) >= vtotal);
 		state->freesync_range.vmax = vtotal;
 	}
 

commit ba624cddbc002816e376d588290a48f77ff4b06f
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed May 3 13:58:45 2017 -0400

    drm/amd/display: Assign stream to map before we need it
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 82086a129a3b..c5330f3cc1de 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -230,7 +230,7 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 	struct core_stream *core_stream = NULL;
 	struct core_dc *core_dc = NULL;
 	struct core_freesync *core_freesync = NULL;
-	int persistent_freesync_enable, stream_index = 0;
+	int persistent_freesync_enable = 0;
 	struct persistent_data_flag flag;
 	unsigned int nom_refresh_rate_micro_hz;
 	unsigned long long temp;
@@ -249,8 +249,6 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 
 		dc_stream_retain(stream);
 
-		stream_index = map_index_from_stream(core_freesync, stream);
-
 		temp = stream->timing.pix_clk_khz;
 		temp *= 1000ULL * 1000ULL * 1000ULL;
 		temp = div_u64(temp, stream->timing.h_total);
@@ -260,7 +258,7 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 
 		if (core_freesync->opts.min_refresh_from_edid != 0 &&
 				dc_is_embedded_signal(
-					stream[stream_index].sink->sink_signal)) {
+					stream->sink->sink_signal)) {
 			caps->supported = true;
 			caps->min_refresh_in_micro_hz =
 				core_freesync->opts.min_refresh_from_edid *

commit 9e594f4c3f30c8ba43a1601268e82177fbd737c1
Author: Eric Cook <Eric.Cook@amd.com>
Date:   Thu Apr 27 12:20:34 2017 -0400

    drm/amd/display: Add support for FreeSync on eDP to module
    
    Signed-off-by: Eric <eric.cook@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 009cb797bcfa..82086a129a3b 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -109,11 +109,16 @@ struct freesync_entity {
 	struct mod_freesync_user_enable user_enable;
 };
 
+struct freesync_registry_options {
+	unsigned int min_refresh_from_edid;
+};
+
 struct core_freesync {
 	struct mod_freesync public;
 	struct dc *dc;
 	struct freesync_entity *map;
 	int num_entities;
+	struct freesync_registry_options opts;
 };
 
 #define MOD_FREESYNC_TO_CORE(mod_freesync)\
@@ -136,7 +141,7 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 
 	struct persistent_data_flag flag;
 
-	int i = 0;
+	int i, data = 0;
 
 	if (core_freesync == NULL)
 		goto fail_alloc_context;
@@ -165,6 +170,12 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 	flag.save_per_link = false;
 	dm_write_persistent_data(core_dc->ctx, NULL, FREESYNC_REGISTRY_NAME, NULL, NULL,
 					0, &flag);
+	flag.save_per_edid = false;
+	flag.save_per_link = false;
+	if (dm_read_persistent_data(core_dc->ctx, NULL, NULL,
+			"DalDrrSupport", &data, sizeof(data), &flag)) {
+		core_freesync->opts.min_refresh_from_edid = data;
+	}
 
 	return &core_freesync->public;
 
@@ -219,7 +230,7 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 	struct core_stream *core_stream = NULL;
 	struct core_dc *core_dc = NULL;
 	struct core_freesync *core_freesync = NULL;
-	int persistent_freesync_enable = 0;
+	int persistent_freesync_enable, stream_index = 0;
 	struct persistent_data_flag flag;
 	unsigned int nom_refresh_rate_micro_hz;
 	unsigned long long temp;
@@ -238,6 +249,26 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 
 		dc_stream_retain(stream);
 
+		stream_index = map_index_from_stream(core_freesync, stream);
+
+		temp = stream->timing.pix_clk_khz;
+		temp *= 1000ULL * 1000ULL * 1000ULL;
+		temp = div_u64(temp, stream->timing.h_total);
+		temp = div_u64(temp, stream->timing.v_total);
+
+		nom_refresh_rate_micro_hz = (unsigned int) temp;
+
+		if (core_freesync->opts.min_refresh_from_edid != 0 &&
+				dc_is_embedded_signal(
+					stream[stream_index].sink->sink_signal)) {
+			caps->supported = true;
+			caps->min_refresh_in_micro_hz =
+				core_freesync->opts.min_refresh_from_edid *
+					1000000;
+			caps->max_refresh_in_micro_hz =
+					nom_refresh_rate_micro_hz;
+		}
+
 		core_freesync->map[core_freesync->num_entities].stream = stream;
 		core_freesync->map[core_freesync->num_entities].caps = caps;
 
@@ -275,13 +306,6 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 					enable_for_video = false;
 		}
 
-		temp = stream->timing.pix_clk_khz;
-		temp *= 1000ULL * 1000ULL * 1000ULL;
-		temp = div_u64(temp, stream->timing.h_total);
-		temp = div_u64(temp, stream->timing.v_total);
-
-		nom_refresh_rate_micro_hz = (unsigned int) temp;
-
 		if (caps->supported &&
 		    nom_refresh_rate_micro_hz >= caps->min_refresh_in_micro_hz &&
 		    nom_refresh_rate_micro_hz <= caps->max_refresh_in_micro_hz)

commit 7cc9e7a68abef8d1303700bac6f58ab76bc9db7b
Author: Eric Cook <Eric.Cook@amd.com>
Date:   Wed Apr 26 11:51:38 2017 -0400

    drm/amd/display: Check for Zero Range in FreeSync Calc
    
    -check for min/max range in freesync calculation and handle it accordingly
    
    Signed-off-by: Eric <eric.cook@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index d3d57008271b..009cb797bcfa 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -363,6 +363,21 @@ static void calc_freesync_range(struct core_freesync *core_freesync,
 	unsigned int index = map_index_from_stream(core_freesync, stream);
 	uint32_t vtotal = stream->timing.v_total;
 
+	if ((min_refresh_in_uhz == 0) || (max_refresh_in_uhz == 0)) {
+		state->freesync_range.min_refresh =
+				state->nominal_refresh_rate_in_micro_hz;
+		state->freesync_range.max_refresh =
+				state->nominal_refresh_rate_in_micro_hz;
+
+		state->freesync_range.max_frame_duration = 0;
+		state->freesync_range.min_frame_duration = 0;
+
+		state->freesync_range.vmax = vtotal;
+		state->freesync_range.vmin = vtotal;
+
+		return;
+	}
+
 	min_frame_duration_in_ns = ((unsigned int) (div64_u64(
 					(1000000000ULL * 1000000),
 					max_refresh_in_uhz)));

commit 1c29313b96fbe9606ecaab540800d20f2ae88adc
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Apr 26 10:54:45 2017 -0400

    drm/amd/display: fix crash caused by incorrect index being used for array
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index f6223e6b3536..d3d57008271b 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -1122,7 +1122,7 @@ void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
 			 * current mode
 			 */
 			calc_freesync_range(core_freesync, *streams, state,
-				core_freesync->map[stream_index].caps->
+				core_freesync->map[map_index].caps->
 				min_refresh_in_micro_hz,
 				state->nominal_refresh_rate_in_micro_hz);
 		}

commit 72ada5f76939ed00c07c584be7691a29d3c2c3da
Author: Eric Cook <Eric.Cook@amd.com>
Date:   Tue Apr 18 15:24:50 2017 -0400

    drm/amd/display: FreeSync Auto Sweep Support
    
    Implement core support to allow for FreeSync Auto Sweep to work
    
    Signed-off-by: Eric Cook <Eric.Cook@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 78b4f28d862c..f6223e6b3536 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -76,6 +76,16 @@ struct fixed_refresh {
 	bool program_fixed_refresh;
 };
 
+struct freesync_range {
+	unsigned int min_refresh;
+	unsigned int max_frame_duration;
+	unsigned int vmax;
+
+	unsigned int max_refresh;
+	unsigned int min_frame_duration;
+	unsigned int vmin;
+};
+
 struct freesync_state {
 	bool fullscreen;
 	bool static_screen;
@@ -89,6 +99,7 @@ struct freesync_state {
 	struct gradual_static_ramp static_ramp;
 	struct below_the_range btr;
 	struct fixed_refresh fixed_refresh;
+	struct freesync_range freesync_range;
 };
 
 struct freesync_entity {
@@ -342,8 +353,11 @@ static void update_stream(struct core_freesync *core_freesync,
 	}
 }
 
-static void calc_vmin_vmax(struct core_freesync *core_freesync,
-		const struct dc_stream *stream, int *vmin, int *vmax)
+static void calc_freesync_range(struct core_freesync *core_freesync,
+		const struct dc_stream *stream,
+		struct freesync_state *state,
+		unsigned int min_refresh_in_uhz,
+		unsigned int max_refresh_in_uhz)
 {
 	unsigned int min_frame_duration_in_ns = 0, max_frame_duration_in_ns = 0;
 	unsigned int index = map_index_from_stream(core_freesync, stream);
@@ -351,29 +365,50 @@ static void calc_vmin_vmax(struct core_freesync *core_freesync,
 
 	min_frame_duration_in_ns = ((unsigned int) (div64_u64(
 					(1000000000ULL * 1000000),
-					core_freesync->map[index].state.
-					nominal_refresh_rate_in_micro_hz)));
+					max_refresh_in_uhz)));
 	max_frame_duration_in_ns = ((unsigned int) (div64_u64(
-					(1000000000ULL * 1000000),
-					core_freesync->map[index].caps->min_refresh_in_micro_hz)));
+		(1000000000ULL * 1000000),
+		min_refresh_in_uhz)));
+
+	state->freesync_range.min_refresh = min_refresh_in_uhz;
+	state->freesync_range.max_refresh = max_refresh_in_uhz;
 
-	*vmax = div64_u64(div64_u64(((unsigned long long)(
-			max_frame_duration_in_ns) * stream->timing.pix_clk_khz),
-			stream->timing.h_total), 1000000);
-	*vmin = div64_u64(div64_u64(((unsigned long long)(
-			min_frame_duration_in_ns) * stream->timing.pix_clk_khz),
-			stream->timing.h_total), 1000000);
+	state->freesync_range.max_frame_duration = max_frame_duration_in_ns;
+	state->freesync_range.min_frame_duration = min_frame_duration_in_ns;
+
+	state->freesync_range.vmax = div64_u64(div64_u64(((unsigned long long)(
+		max_frame_duration_in_ns) * stream->timing.pix_clk_khz),
+		stream->timing.h_total), 1000000);
+	state->freesync_range.vmin = div64_u64(div64_u64(((unsigned long long)(
+		min_frame_duration_in_ns) * stream->timing.pix_clk_khz),
+		stream->timing.h_total), 1000000);
 
 	/* In case of 4k free sync monitor, vmin or vmax cannot be less than vtotal */
-	if (*vmin < vtotal) {
+	if (state->freesync_range.vmin < vtotal) {
 		ASSERT(false);
-		*vmin = vtotal;
+		state->freesync_range.vmin = vtotal;
 	}
 
-	if (*vmax < vtotal) {
+	if (state->freesync_range.vmax < vtotal) {
 		ASSERT(false);
-		*vmax = vtotal;
+		state->freesync_range.vmax = vtotal;
 	}
+
+	/* Determine whether BTR can be supported */
+	if (max_frame_duration_in_ns >=
+			2 * min_frame_duration_in_ns)
+		core_freesync->map[index].caps->btr_supported = true;
+	else
+		core_freesync->map[index].caps->btr_supported = false;
+
+	/* Cache the time variables */
+	state->time.max_render_time_in_us =
+		max_frame_duration_in_ns / 1000;
+	state->time.min_render_time_in_us =
+		min_frame_duration_in_ns / 1000;
+	state->btr.mid_point_in_us =
+		(max_frame_duration_in_ns +
+		min_frame_duration_in_ns) / 2000;
 }
 
 static void calc_v_total_from_duration(const struct dc_stream *stream,
@@ -518,9 +553,8 @@ static bool set_freesync_on_streams(struct core_freesync *core_freesync,
 				state->fixed_refresh.fixed_refresh_active == false) {
 				/* Enable freesync */
 
-				calc_vmin_vmax(core_freesync,
-						streams[stream_idx],
-						&v_total_min, &v_total_max);
+				v_total_min = state->freesync_range.vmin;
+				v_total_max = state->freesync_range.vmax;
 
 				/* Update the freesync context for the stream */
 				update_stream_freesync_context(core_freesync,
@@ -696,7 +730,7 @@ void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
 					(1000000000ULL * 1000000),
 					state->nominal_refresh_rate_in_micro_hz)));
 
-			calc_vmin_vmax(core_freesync, *streams, &vmin, &vmax);
+			vmin = state->freesync_range.vmin;
 
 			inserted_frame_v_total = vmin;
 
@@ -941,11 +975,120 @@ bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
 	return true;
 }
 
+bool mod_freesync_override_min_max(struct mod_freesync *mod_freesync,
+		const struct dc_stream *streams,
+		unsigned int min_refresh,
+		unsigned int max_refresh)
+{
+	unsigned int index = 0;
+	struct core_freesync *core_freesync;
+	struct freesync_state *state;
+
+	if (mod_freesync == NULL)
+		return false;
+
+	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
+	index = map_index_from_stream(core_freesync, streams);
+	state = &core_freesync->map[index].state;
+
+	if (min_refresh == 0 || max_refresh == 0) {
+		/* Restore defaults */
+		calc_freesync_range(core_freesync, streams, state,
+			core_freesync->map[index].caps->
+			min_refresh_in_micro_hz,
+			state->nominal_refresh_rate_in_micro_hz);
+	} else {
+		calc_freesync_range(core_freesync, streams,
+				state,
+				min_refresh,
+				max_refresh);
+
+		/* Program vtotal min/max */
+		core_freesync->dc->stream_funcs.adjust_vmin_vmax(
+			core_freesync->dc, &streams, 1,
+			state->freesync_range.vmin,
+			state->freesync_range.vmax);
+	}
+
+	return true;
+}
+
+bool mod_freesync_get_min_max(struct mod_freesync *mod_freesync,
+		const struct dc_stream *stream,
+		unsigned int *min_refresh,
+		unsigned int *max_refresh)
+{
+	unsigned int index = 0;
+	struct core_freesync *core_freesync = NULL;
+
+	if (mod_freesync == NULL)
+		return false;
+
+	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
+	index = map_index_from_stream(core_freesync, stream);
+
+	*min_refresh =
+		core_freesync->map[index].state.freesync_range.min_refresh;
+	*max_refresh =
+		core_freesync->map[index].state.freesync_range.max_refresh;
+
+	return true;
+}
+
+bool mod_freesync_get_vmin_vmax(struct mod_freesync *mod_freesync,
+		const struct dc_stream *stream,
+		unsigned int *vmin,
+		unsigned int *vmax)
+{
+	unsigned int index = 0;
+	struct core_freesync *core_freesync = NULL;
+
+	if (mod_freesync == NULL)
+		return false;
+
+	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
+	index = map_index_from_stream(core_freesync, stream);
+
+	*vmin =
+		core_freesync->map[index].state.freesync_range.vmin;
+	*vmax =
+		core_freesync->map[index].state.freesync_range.vmax;
+
+	return true;
+}
+
+bool mod_freesync_get_v_position(struct mod_freesync *mod_freesync,
+		const struct dc_stream *stream,
+		unsigned int *nom_v_pos,
+		unsigned int *v_pos)
+{
+	unsigned int index = 0;
+	struct core_freesync *core_freesync = NULL;
+	struct crtc_position position;
+
+	if (mod_freesync == NULL)
+		return false;
+
+	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
+	index = map_index_from_stream(core_freesync, stream);
+
+	if (core_freesync->dc->stream_funcs.get_crtc_position(
+			core_freesync->dc, &stream, 1,
+			&position.vertical_count, &position.nominal_vcount)) {
+
+		*nom_v_pos = position.vertical_count;
+		*v_pos = position.nominal_vcount;
+
+		return true;
+	}
+
+	return false;
+}
+
 void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
 		const struct dc_stream **streams, int num_streams)
 {
 	unsigned int stream_index, map_index;
-	unsigned min_frame_duration_in_ns, max_frame_duration_in_ns;
 	struct freesync_state *state;
 	struct core_freesync *core_freesync = NULL;
 
@@ -965,37 +1108,23 @@ void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
 			unsigned long long temp;
 			temp = streams[stream_index]->timing.pix_clk_khz;
 			temp *= 1000ULL * 1000ULL * 1000ULL;
-			temp = div_u64(temp, streams[stream_index]->timing.h_total);
-			temp = div_u64(temp, streams[stream_index]->timing.v_total);
-			state->nominal_refresh_rate_in_micro_hz = (unsigned int) temp;
+			temp = div_u64(temp,
+					streams[stream_index]->timing.h_total);
+			temp = div_u64(temp,
+					streams[stream_index]->timing.v_total);
+			state->nominal_refresh_rate_in_micro_hz =
+					(unsigned int) temp;
 
 			/* Update the stream */
 			update_stream(core_freesync, streams[stream_index]);
 
-			/* Determine whether BTR can be supported */
-			min_frame_duration_in_ns = ((unsigned int) (div64_u64(
-					(1000000000ULL * 1000000),
-					state->nominal_refresh_rate_in_micro_hz)));
-
-			max_frame_duration_in_ns = ((unsigned int) (div64_u64(
-					(1000000000ULL * 1000000),
-					core_freesync->map[map_index].caps->min_refresh_in_micro_hz)));
-
-			if (max_frame_duration_in_ns >=
-					2 * min_frame_duration_in_ns)
-				core_freesync->map[map_index].caps->btr_supported = true;
-			else
-				core_freesync->map[map_index].caps->btr_supported = false;
-
-			/* Cache the time variables */
-			state->time.max_render_time_in_us =
-				max_frame_duration_in_ns / 1000;
-			state->time.min_render_time_in_us =
-				min_frame_duration_in_ns / 1000;
-			state->btr.mid_point_in_us =
-				(max_frame_duration_in_ns +
-				min_frame_duration_in_ns) / 2000;
-
+			/* Calculate vmin/vmax and refresh rate for
+			 * current mode
+			 */
+			calc_freesync_range(core_freesync, *streams, state,
+				core_freesync->map[stream_index].caps->
+				min_refresh_in_micro_hz,
+				state->nominal_refresh_rate_in_micro_hz);
 		}
 	}
 
@@ -1178,7 +1307,7 @@ static void apply_fixed_refresh(struct core_freesync *core_freesync,
 	/* Fixed Refresh set to "active" so engage (fix to max) */
 	} else {
 
-		calc_vmin_vmax(core_freesync, stream, &vmin, &vmax);
+		vmin = state->freesync_range.vmin;
 
 		vmax = vmin;
 

commit 94267b3df7ee00f21fa0ff7d618ca7e0574db5ed
Author: Sylvia Tsai <sylvia.tsai@amd.com>
Date:   Fri Apr 21 15:29:55 2017 -0400

    drm/amd/display: PSR Refactor
    
    - Refacotr PSR to follow correct module pattern
    - fix eDP only working on sink index 0.
    
    Signed-off-by: Sylvia Tsai <sylvia.tsai@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 5c6de723da5d..78b4f28d862c 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -264,10 +264,10 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 					enable_for_video = false;
 		}
 
-		temp = core_stream->public.timing.pix_clk_khz;
+		temp = stream->timing.pix_clk_khz;
 		temp *= 1000ULL * 1000ULL * 1000ULL;
-		temp = div_u64(temp, core_stream->public.timing.h_total);
-		temp = div_u64(temp, core_stream->public.timing.v_total);
+		temp = div_u64(temp, stream->timing.h_total);
+		temp = div_u64(temp, stream->timing.v_total);
 
 		nom_refresh_rate_micro_hz = (unsigned int) temp;
 
@@ -657,6 +657,7 @@ void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
 	unsigned int min_frame_duration_in_ns, vmax, vmin = 0;
 	struct freesync_state *state;
 	struct core_freesync *core_freesync = NULL;
+	struct dc_static_screen_events triggers = {0};
 
 	if (mod_freesync == NULL)
 		return;
@@ -749,6 +750,13 @@ void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
 					core_freesync->dc, streams,
 					num_streams, v_total,
 					v_total);
+
+		triggers.overlay_update = true;
+		triggers.surface_update = true;
+
+		core_freesync->dc->stream_funcs.set_static_screen_events(
+					core_freesync->dc, streams,	num_streams,
+					&triggers);
 	}
 }
 

commit 6c626ffb1bfa2705e71376fe20bcdc6b89aace85
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Apr 21 11:00:43 2017 -0400

    drm/amd/display: Make sure v_total_min and max not less than v_total.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 94566c0a0e62..5c6de723da5d 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -347,6 +347,7 @@ static void calc_vmin_vmax(struct core_freesync *core_freesync,
 {
 	unsigned int min_frame_duration_in_ns = 0, max_frame_duration_in_ns = 0;
 	unsigned int index = map_index_from_stream(core_freesync, stream);
+	uint32_t vtotal = stream->timing.v_total;
 
 	min_frame_duration_in_ns = ((unsigned int) (div64_u64(
 					(1000000000ULL * 1000000),
@@ -362,6 +363,17 @@ static void calc_vmin_vmax(struct core_freesync *core_freesync,
 	*vmin = div64_u64(div64_u64(((unsigned long long)(
 			min_frame_duration_in_ns) * stream->timing.pix_clk_khz),
 			stream->timing.h_total), 1000000);
+
+	/* In case of 4k free sync monitor, vmin or vmax cannot be less than vtotal */
+	if (*vmin < vtotal) {
+		ASSERT(false);
+		*vmin = vtotal;
+	}
+
+	if (*vmax < vtotal) {
+		ASSERT(false);
+		*vmax = vtotal;
+	}
 }
 
 static void calc_v_total_from_duration(const struct dc_stream *stream,

commit 09e2d07f9d4d30f7d219b562d656d7c7611e2b65
Author: Eric Cook <Eric.Cook@amd.com>
Date:   Wed Apr 12 11:05:08 2017 -0400

    drm/amd/display: FreeSync LFC MIN/MAX update on current frame
    
    - Update BTR/LFC logic so that V_TOTAL_MIN/MAX will take affect on current frame
    - Add in FreeSync update to MPO code path
    
    Signed-off-by: Eric Cook <Eric.Cook@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 7a0731e2dbb0..94566c0a0e62 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -641,7 +641,8 @@ static void set_static_ramp_variables(struct core_freesync *core_freesync,
 void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
 		const struct dc_stream **streams, int num_streams)
 {
-	unsigned int index, v_total = 0;
+	unsigned int index, v_total, inserted_frame_v_total = 0;
+	unsigned int min_frame_duration_in_ns, vmax, vmin = 0;
 	struct freesync_state *state;
 	struct core_freesync *core_freesync = NULL;
 
@@ -665,19 +666,48 @@ void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
 
 	/* Only execute if in fullscreen mode */
 	if (state->fullscreen == true &&
-		core_freesync->map[index].user_enable.enable_for_gaming) {
+		core_freesync->map[index].user_enable.enable_for_gaming &&
+		core_freesync->map[index].caps->btr_supported &&
+		state->btr.btr_active) {
+
+		/* TODO: pass in flag for Pre-DCE12 ASIC
+		 * in order for frame variable duration to take affect,
+		 * it needs to be done one VSYNC early, which is at
+		 * frameCounter == 1.
+		 * For DCE12 and newer updates to V_TOTAL_MIN/MAX
+		 * will take affect on current frame
+		 */
+		if (state->btr.frames_to_insert == state->btr.frame_counter) {
+
+			min_frame_duration_in_ns = ((unsigned int) (div64_u64(
+					(1000000000ULL * 1000000),
+					state->nominal_refresh_rate_in_micro_hz)));
+
+			calc_vmin_vmax(core_freesync, *streams, &vmin, &vmax);
 
-		if (state->btr.btr_active)
-			if (state->btr.frame_counter > 0)
+			inserted_frame_v_total = vmin;
 
-				state->btr.frame_counter--;
+			if (min_frame_duration_in_ns / 1000)
+				inserted_frame_v_total =
+					state->btr.inserted_frame_duration_in_us *
+					vmin / (min_frame_duration_in_ns / 1000);
 
-		if (state->btr.frame_counter == 1) {
+			/* Set length of inserted frames as v_total_max*/
+			vmax = inserted_frame_v_total;
+			vmin = inserted_frame_v_total;
 
-			/* Restore FreeSync */
-			set_freesync_on_streams(core_freesync, streams,
-					num_streams);
+			/* Program V_TOTAL */
+			core_freesync->dc->stream_funcs.adjust_vmin_vmax(
+				core_freesync->dc, streams,
+				num_streams, vmin, vmax);
 		}
+
+		if (state->btr.frame_counter > 0)
+			state->btr.frame_counter--;
+
+		/* Restore FreeSync */
+		if (state->btr.frame_counter == 0)
+			set_freesync_on_streams(core_freesync, streams, num_streams);
 	}
 
 	/* If in fullscreen freesync mode or in video, do not program
@@ -1022,8 +1052,6 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 	unsigned int delta_from_mid_point_in_us_1 = 0xFFFFFFFF;
 	unsigned int delta_from_mid_point_in_us_2 = 0xFFFFFFFF;
 	unsigned int frames_to_insert = 0;
-	unsigned int inserted_frame_v_total = 0;
-	unsigned int vmin = 0, vmax = 0;
 	unsigned int min_frame_duration_in_ns = 0;
 	struct freesync_state *state = &core_freesync->map[map_index].state;
 
@@ -1101,23 +1129,6 @@ static void apply_below_the_range(struct core_freesync *core_freesync,
 			inserted_frame_duration_in_us =
 				state->time.min_render_time_in_us;
 
-		/* We need the v_total_min from capability */
-		calc_vmin_vmax(core_freesync, stream, &vmin, &vmax);
-
-		inserted_frame_v_total = vmin;
-		if (min_frame_duration_in_ns / 1000)
-			inserted_frame_v_total = inserted_frame_duration_in_us *
-				vmin / (min_frame_duration_in_ns / 1000);
-
-		/* Set length of inserted frames as v_total_max*/
-		vmax = inserted_frame_v_total;
-
-		/* Program V_TOTAL */
-		core_freesync->dc->stream_funcs.adjust_vmin_vmax(
-			core_freesync->dc, &stream,
-			1, vmin,
-			vmax);
-
 		/* Cache the calculated variables */
 		state->btr.inserted_frame_duration_in_us =
 			inserted_frame_duration_in_us;

commit 3e337d15bf211ce1fe388d00a7f6a955550b3edf
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Mar 1 18:20:58 2017 -0500

    drm/amd/display: sometime VtotalMin less than VTotal (rounding issue)
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 2026ef34b11b..7a0731e2dbb0 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -905,7 +905,6 @@ void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
 	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
 
 	for (stream_index = 0; stream_index < num_streams; stream_index++) {
-
 		map_index = map_index_from_stream(core_freesync,
 				streams[stream_index]);
 
@@ -913,11 +912,12 @@ void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
 
 		if (core_freesync->map[map_index].caps->supported) {
 			/* Update the field rate for new timing */
-			state->nominal_refresh_rate_in_micro_hz = 1000000 *
-				div64_u64(div64_u64((streams[stream_index]->
-				timing.pix_clk_khz * 1000),
-				streams[stream_index]->timing.v_total),
-				streams[stream_index]->timing.h_total);
+			unsigned long long temp;
+			temp = streams[stream_index]->timing.pix_clk_khz;
+			temp *= 1000ULL * 1000ULL * 1000ULL;
+			temp = div_u64(temp, streams[stream_index]->timing.h_total);
+			temp = div_u64(temp, streams[stream_index]->timing.v_total);
+			state->nominal_refresh_rate_in_micro_hz = (unsigned int) temp;
 
 			/* Update the stream */
 			update_stream(core_freesync, streams[stream_index]);

commit 4a9054dda6df8e94b6a54a181277e25d189198c4
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Feb 14 14:51:06 2017 -0500

    drm/amd/display: Fix 64-bit division, yet again
    
    Also make the code somewhat more readable.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index b00b1df71f3e..2026ef34b11b 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -210,6 +210,8 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 	struct core_freesync *core_freesync = NULL;
 	int persistent_freesync_enable = 0;
 	struct persistent_data_flag flag;
+	unsigned int nom_refresh_rate_micro_hz;
+	unsigned long long temp;
 
 	if (mod_freesync == NULL)
 		return false;
@@ -262,11 +264,16 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 					enable_for_video = false;
 		}
 
-		unsigned int nom_refresh_rate_micro_hz = (unsigned int)
-				(((unsigned long long) core_stream->public.timing.pix_clk_khz) * 1000ULL * 1000ULL * 1000ULL
-				/ core_stream->public.timing.h_total / core_stream->public.timing.v_total);
+		temp = core_stream->public.timing.pix_clk_khz;
+		temp *= 1000ULL * 1000ULL * 1000ULL;
+		temp = div_u64(temp, core_stream->public.timing.h_total);
+		temp = div_u64(temp, core_stream->public.timing.v_total);
 
-		if (caps->supported && nom_refresh_rate_micro_hz >= caps->min_refresh_in_micro_hz && nom_refresh_rate_micro_hz <= caps->max_refresh_in_micro_hz)
+		nom_refresh_rate_micro_hz = (unsigned int) temp;
+
+		if (caps->supported &&
+		    nom_refresh_rate_micro_hz >= caps->min_refresh_in_micro_hz &&
+		    nom_refresh_rate_micro_hz <= caps->max_refresh_in_micro_hz)
 			core_stream->public.ignore_msa_timing_param = 1;
 
 		core_freesync->num_entities++;

commit 8f16f28936afcf68b92625d331a8ca760a386139
Author: Sylvia Tsai <sylvia.tsai@amd.com>
Date:   Thu Feb 9 16:35:39 2017 -0500

    drm/amd/display: Set ignore_msa_timing flag for freesync modes
    
    - Set ignore_msa_timing_param to 1 only for modes that can support freesync
    
    Signed-off-by: Sylvia Tsai <sylvia.tsai@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 1ee732768f6e..b00b1df71f3e 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -262,7 +262,11 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 					enable_for_video = false;
 		}
 
-		if (caps->supported)
+		unsigned int nom_refresh_rate_micro_hz = (unsigned int)
+				(((unsigned long long) core_stream->public.timing.pix_clk_khz) * 1000ULL * 1000ULL * 1000ULL
+				/ core_stream->public.timing.h_total / core_stream->public.timing.v_total);
+
+		if (caps->supported && nom_refresh_rate_micro_hz >= caps->min_refresh_in_micro_hz && nom_refresh_rate_micro_hz <= caps->max_refresh_in_micro_hz)
 			core_stream->public.ignore_msa_timing_param = 1;
 
 		core_freesync->num_entities++;

commit c7141c47d371fbe6dfbdadf92cd4abb750111a62
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Wed Jan 25 09:31:45 2017 -0500

    drm/amd/display: Fix compile warnings
    
    1. Fix init of integer
    2. Fix mixed declarations
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index e0703c588e47..1ee732768f6e 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -208,6 +208,8 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 	struct core_stream *core_stream = NULL;
 	struct core_dc *core_dc = NULL;
 	struct core_freesync *core_freesync = NULL;
+	int persistent_freesync_enable = 0;
+	struct persistent_data_flag flag;
 
 	if (mod_freesync == NULL)
 		return false;
@@ -216,9 +218,6 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 	core_stream = DC_STREAM_TO_CORE(stream);
 	core_dc = DC_TO_CORE(core_freesync->dc);
 
-	int persistent_freesync_enable = 0;
-	struct persistent_data_flag flag;
-
 	flag.save_per_edid = true;
 	flag.save_per_link = false;
 
@@ -779,7 +778,7 @@ bool mod_freesync_get_state(struct mod_freesync *mod_freesync,
 		const struct dc_stream *stream,
 		struct mod_freesync_params *freesync_params)
 {
-	unsigned int index = NULL;
+	unsigned int index = 0;
 	struct core_freesync *core_freesync = NULL;
 
 	if (mod_freesync == NULL)

commit 7a1c37e00a660b380fe258fed54fd5af6735814e
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Jan 12 14:24:11 2017 -0500

    drm/amd/display: Disable Modules at Runtime
    
    Add NULL check in modules
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 6f4d169f4e4e..e0703c588e47 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -205,11 +205,16 @@ static unsigned int map_index_from_stream(struct core_freesync *core_freesync,
 bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 		const struct dc_stream *stream, struct mod_freesync_caps *caps)
 {
-	struct core_freesync *core_freesync =
-			MOD_FREESYNC_TO_CORE(mod_freesync);
-	struct core_stream *core_stream =
-			DC_STREAM_TO_CORE(stream);
-	struct core_dc *core_dc = DC_TO_CORE(core_freesync->dc);
+	struct core_stream *core_stream = NULL;
+	struct core_dc *core_dc = NULL;
+	struct core_freesync *core_freesync = NULL;
+
+	if (mod_freesync == NULL)
+		return false;
+
+	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
+	core_stream = DC_STREAM_TO_CORE(stream);
+	core_dc = DC_TO_CORE(core_freesync->dc);
 
 	int persistent_freesync_enable = 0;
 	struct persistent_data_flag flag;
@@ -270,11 +275,16 @@ bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
 bool mod_freesync_remove_stream(struct mod_freesync *mod_freesync,
 		const struct dc_stream *stream)
 {
-	struct core_freesync *core_freesync =
-			MOD_FREESYNC_TO_CORE(mod_freesync);
-
 	int i = 0;
-	unsigned int index = map_index_from_stream(core_freesync, stream);
+	struct core_freesync *core_freesync = NULL;
+	unsigned int index = 0;
+
+	if (mod_freesync == NULL)
+		return false;
+
+	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
+	index = map_index_from_stream(core_freesync, stream);
+
 	dc_stream_release(core_freesync->map[index].stream);
 	core_freesync->map[index].stream = NULL;
 	/* To remove this entity, shift everything after down */
@@ -621,11 +631,14 @@ static void set_static_ramp_variables(struct core_freesync *core_freesync,
 void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
 		const struct dc_stream **streams, int num_streams)
 {
-	struct core_freesync *core_freesync =
-			MOD_FREESYNC_TO_CORE(mod_freesync);
-
 	unsigned int index, v_total = 0;
 	struct freesync_state *state;
+	struct core_freesync *core_freesync = NULL;
+
+	if (mod_freesync == NULL)
+		return;
+
+	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
 
 	if (core_freesync->num_entities == 0)
 		return;
@@ -691,11 +704,15 @@ void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 		const struct dc_stream **streams, int num_streams,
 		struct mod_freesync_params *freesync_params)
 {
-	struct core_freesync *core_freesync =
-			MOD_FREESYNC_TO_CORE(mod_freesync);
 	bool freesync_program_required = false;
 	unsigned int stream_index;
 	struct freesync_state *state;
+	struct core_freesync *core_freesync = NULL;
+
+	if (mod_freesync == NULL)
+		return;
+
+	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
 
 	if (core_freesync->num_entities == 0)
 		return;
@@ -762,10 +779,14 @@ bool mod_freesync_get_state(struct mod_freesync *mod_freesync,
 		const struct dc_stream *stream,
 		struct mod_freesync_params *freesync_params)
 {
-	struct core_freesync *core_freesync =
-				MOD_FREESYNC_TO_CORE(mod_freesync);
+	unsigned int index = NULL;
+	struct core_freesync *core_freesync = NULL;
 
-	unsigned int index = map_index_from_stream(core_freesync, stream);
+	if (mod_freesync == NULL)
+		return false;
+
+	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
+	index = map_index_from_stream(core_freesync, stream);
 
 	if (core_freesync->map[index].state.fullscreen) {
 		freesync_params->state = FREESYNC_STATE_FULLSCREEN;
@@ -794,13 +815,17 @@ bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
 		const struct dc_stream **streams, int num_streams,
 		struct mod_freesync_user_enable *user_enable)
 {
-	struct core_freesync *core_freesync =
-			MOD_FREESYNC_TO_CORE(mod_freesync);
-	struct core_dc *core_dc = DC_TO_CORE(core_freesync->dc);
-
 	unsigned int stream_index, map_index;
 	int persistent_data = 0;
 	struct persistent_data_flag flag;
+	struct core_dc *core_dc = NULL;
+	struct core_freesync *core_freesync = NULL;
+
+	if (mod_freesync == NULL)
+		return false;
+
+	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
+	core_dc = DC_TO_CORE(core_freesync->dc);
 
 	flag.save_per_edid = true;
 	flag.save_per_link = false;
@@ -842,10 +867,14 @@ bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
 		const struct dc_stream *stream,
 		struct mod_freesync_user_enable *user_enable)
 {
-	struct core_freesync *core_freesync =
-			MOD_FREESYNC_TO_CORE(mod_freesync);
+	unsigned int index = 0;
+	struct core_freesync *core_freesync = NULL;
 
-	unsigned int index = map_index_from_stream(core_freesync, stream);
+	if (mod_freesync == NULL)
+		return false;
+
+	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
+	index = map_index_from_stream(core_freesync, stream);
 
 	*user_enable = core_freesync->map[index].user_enable;
 
@@ -855,12 +884,15 @@ bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
 void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
 		const struct dc_stream **streams, int num_streams)
 {
-	struct core_freesync *core_freesync =
-			MOD_FREESYNC_TO_CORE(mod_freesync);
-
 	unsigned int stream_index, map_index;
 	unsigned min_frame_duration_in_ns, max_frame_duration_in_ns;
 	struct freesync_state *state;
+	struct core_freesync *core_freesync = NULL;
+
+	if (mod_freesync == NULL)
+		return;
+
+	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
 
 	for (stream_index = 0; stream_index < num_streams; stream_index++) {
 
@@ -1121,8 +1153,12 @@ void mod_freesync_pre_update_plane_addresses(struct mod_freesync *mod_freesync,
 		unsigned int curr_time_stamp_in_us)
 {
 	unsigned int stream_index, map_index, last_render_time_in_us = 0;
-	struct core_freesync *core_freesync =
-			MOD_FREESYNC_TO_CORE(mod_freesync);
+	struct core_freesync *core_freesync = NULL;
+
+	if (mod_freesync == NULL)
+		return;
+
+	core_freesync = MOD_FREESYNC_TO_CORE(mod_freesync);
 
 	for (stream_index = 0; stream_index < num_streams; stream_index++) {
 

commit 4b5752c7422f36664cea2ed300b698b4755b6dc5
Author: Andrew Wong <andrew.wong1@amd.com>
Date:   Mon Dec 12 11:47:47 2016 -0500

    drm/amd/display: Retrieve windowed fullscreen state
    
    - Retrieve windowed fullscreen state when getting freesync params.
    
    Signed-off-by: Andrew Wong <andrew.wong1@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 8892e8bec7c3..6f4d169f4e4e 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -784,6 +784,9 @@ bool mod_freesync_get_state(struct mod_freesync *mod_freesync,
 	freesync_params->update_duration_in_ns =
 		core_freesync->map[index].state.time.update_duration_in_ns;
 
+	freesync_params->windowed_fullscreen =
+			core_freesync->map[index].state.windowed_fullscreen;
+
 	return true;
 }
 

commit eaf9094475504effe1a798199a1a118299cf0f74
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Dec 6 12:01:23 2016 -0500

    drm/amd/display: Fix warning in freesync module
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index eb912baa0169..8892e8bec7c3 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -746,6 +746,9 @@ void mod_freesync_update_state(struct mod_freesync *mod_freesync,
 				freesync_program_required = true;
 			}
 			break;
+		case FREESYNC_STATE_NONE:
+			/* handle here to avoid warning */
+			break;
 		}
 	}
 

commit 4562236b3bc0a28aeb6ee93b2d8a849a4c4e1c7c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 12 15:58:20 2017 -0400

    drm/amd/dc: Add dc display driver (v2)
    
    Supported DCE versions: 8.0, 10.0, 11.0, 11.2
    
    v2: rebase against 4.11
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
new file mode 100644
index 000000000000..eb912baa0169
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -0,0 +1,1158 @@
+/*
+ * Copyright 2016 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dm_services.h"
+#include "dc.h"
+#include "mod_freesync.h"
+#include "core_types.h"
+#include "core_dc.h"
+
+#define MOD_FREESYNC_MAX_CONCURRENT_STREAMS  32
+
+/* Refresh rate ramp at a fixed rate of 65 Hz/second */
+#define STATIC_SCREEN_RAMP_DELTA_REFRESH_RATE_PER_FRAME ((1000 / 60) * 65)
+/* Number of elements in the render times cache array */
+#define RENDER_TIMES_MAX_COUNT 20
+/* Threshold to exit BTR (to avoid frequent enter-exits at the lower limit) */
+#define BTR_EXIT_MARGIN 2000
+
+#define FREESYNC_REGISTRY_NAME "freesync_v1"
+
+struct gradual_static_ramp {
+	bool ramp_is_active;
+	bool ramp_direction_is_up;
+	unsigned int ramp_current_frame_duration_in_ns;
+};
+
+struct time_cache {
+	/* video (48Hz feature) related */
+	unsigned int update_duration_in_ns;
+
+	/* BTR/fixed refresh related */
+	unsigned int prev_time_stamp_in_us;
+
+	unsigned int min_render_time_in_us;
+	unsigned int max_render_time_in_us;
+
+	unsigned int render_times_index;
+	unsigned int render_times[RENDER_TIMES_MAX_COUNT];
+};
+
+struct below_the_range {
+	bool btr_active;
+	bool program_btr;
+
+	unsigned int mid_point_in_us;
+
+	unsigned int inserted_frame_duration_in_us;
+	unsigned int frames_to_insert;
+	unsigned int frame_counter;
+};
+
+struct fixed_refresh {
+	bool fixed_refresh_active;
+	bool program_fixed_refresh;
+};
+
+struct freesync_state {
+	bool fullscreen;
+	bool static_screen;
+	bool video;
+
+	unsigned int nominal_refresh_rate_in_micro_hz;
+	bool windowed_fullscreen;
+
+	struct time_cache time;
+
+	struct gradual_static_ramp static_ramp;
+	struct below_the_range btr;
+	struct fixed_refresh fixed_refresh;
+};
+
+struct freesync_entity {
+	const struct dc_stream *stream;
+	struct mod_freesync_caps *caps;
+	struct freesync_state state;
+	struct mod_freesync_user_enable user_enable;
+};
+
+struct core_freesync {
+	struct mod_freesync public;
+	struct dc *dc;
+	struct freesync_entity *map;
+	int num_entities;
+};
+
+#define MOD_FREESYNC_TO_CORE(mod_freesync)\
+		container_of(mod_freesync, struct core_freesync, public)
+
+static bool check_dc_support(const struct dc *dc)
+{
+	if (dc->stream_funcs.adjust_vmin_vmax == NULL)
+		return false;
+
+	return true;
+}
+
+struct mod_freesync *mod_freesync_create(struct dc *dc)
+{
+	struct core_freesync *core_freesync =
+			dm_alloc(sizeof(struct core_freesync));
+
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+	struct persistent_data_flag flag;
+
+	int i = 0;
+
+	if (core_freesync == NULL)
+		goto fail_alloc_context;
+
+	core_freesync->map = dm_alloc(sizeof(struct freesync_entity) *
+			MOD_FREESYNC_MAX_CONCURRENT_STREAMS);
+
+	if (core_freesync->map == NULL)
+		goto fail_alloc_map;
+
+	for (i = 0; i < MOD_FREESYNC_MAX_CONCURRENT_STREAMS; i++)
+		core_freesync->map[i].stream = NULL;
+
+	core_freesync->num_entities = 0;
+
+	if (dc == NULL)
+		goto fail_construct;
+
+	core_freesync->dc = dc;
+
+	if (!check_dc_support(dc))
+		goto fail_construct;
+
+	/* Create initial module folder in registry for freesync enable data */
+	flag.save_per_edid = true;
+	flag.save_per_link = false;
+	dm_write_persistent_data(core_dc->ctx, NULL, FREESYNC_REGISTRY_NAME, NULL, NULL,
+					0, &flag);
+
+	return &core_freesync->public;
+
+fail_construct:
+	dm_free(core_freesync->map);
+
+fail_alloc_map:
+	dm_free(core_freesync);
+
+fail_alloc_context:
+	return NULL;
+}
+
+void mod_freesync_destroy(struct mod_freesync *mod_freesync)
+{
+	if (mod_freesync != NULL) {
+		int i;
+		struct core_freesync *core_freesync =
+				MOD_FREESYNC_TO_CORE(mod_freesync);
+
+		for (i = 0; i < core_freesync->num_entities; i++)
+			if (core_freesync->map[i].stream)
+				dc_stream_release(core_freesync->map[i].stream);
+
+		dm_free(core_freesync->map);
+
+		dm_free(core_freesync);
+	}
+}
+
+/* Given a specific dc_stream* this function finds its equivalent
+ * on the core_freesync->map and returns the corresponding index
+ */
+static unsigned int map_index_from_stream(struct core_freesync *core_freesync,
+		const struct dc_stream *stream)
+{
+	unsigned int index = 0;
+
+	for (index = 0; index < core_freesync->num_entities; index++) {
+		if (core_freesync->map[index].stream == stream) {
+			return index;
+		}
+	}
+	/* Could not find stream requested */
+	ASSERT(false);
+	return index;
+}
+
+bool mod_freesync_add_stream(struct mod_freesync *mod_freesync,
+		const struct dc_stream *stream, struct mod_freesync_caps *caps)
+{
+	struct core_freesync *core_freesync =
+			MOD_FREESYNC_TO_CORE(mod_freesync);
+	struct core_stream *core_stream =
+			DC_STREAM_TO_CORE(stream);
+	struct core_dc *core_dc = DC_TO_CORE(core_freesync->dc);
+
+	int persistent_freesync_enable = 0;
+	struct persistent_data_flag flag;
+
+	flag.save_per_edid = true;
+	flag.save_per_link = false;
+
+	if (core_freesync->num_entities < MOD_FREESYNC_MAX_CONCURRENT_STREAMS) {
+
+		dc_stream_retain(stream);
+
+		core_freesync->map[core_freesync->num_entities].stream = stream;
+		core_freesync->map[core_freesync->num_entities].caps = caps;
+
+		core_freesync->map[core_freesync->num_entities].state.
+			fullscreen = false;
+		core_freesync->map[core_freesync->num_entities].state.
+			static_screen = false;
+		core_freesync->map[core_freesync->num_entities].state.
+			video = false;
+		core_freesync->map[core_freesync->num_entities].state.time.
+			update_duration_in_ns = 0;
+		core_freesync->map[core_freesync->num_entities].state.
+			static_ramp.ramp_is_active = false;
+
+		/* get persistent data from registry */
+		if (dm_read_persistent_data(core_dc->ctx, stream->sink,
+					FREESYNC_REGISTRY_NAME,
+					"userenable", &persistent_freesync_enable,
+					sizeof(int), &flag)) {
+			core_freesync->map[core_freesync->num_entities].user_enable.
+				enable_for_gaming =
+				(persistent_freesync_enable & 1) ? true : false;
+			core_freesync->map[core_freesync->num_entities].user_enable.
+				enable_for_static =
+				(persistent_freesync_enable & 2) ? true : false;
+			core_freesync->map[core_freesync->num_entities].user_enable.
+				enable_for_video =
+				(persistent_freesync_enable & 4) ? true : false;
+		} else {
+			core_freesync->map[core_freesync->num_entities].user_enable.
+					enable_for_gaming = false;
+			core_freesync->map[core_freesync->num_entities].user_enable.
+					enable_for_static = false;
+			core_freesync->map[core_freesync->num_entities].user_enable.
+					enable_for_video = false;
+		}
+
+		if (caps->supported)
+			core_stream->public.ignore_msa_timing_param = 1;
+
+		core_freesync->num_entities++;
+		return true;
+	}
+	return false;
+}
+
+bool mod_freesync_remove_stream(struct mod_freesync *mod_freesync,
+		const struct dc_stream *stream)
+{
+	struct core_freesync *core_freesync =
+			MOD_FREESYNC_TO_CORE(mod_freesync);
+
+	int i = 0;
+	unsigned int index = map_index_from_stream(core_freesync, stream);
+	dc_stream_release(core_freesync->map[index].stream);
+	core_freesync->map[index].stream = NULL;
+	/* To remove this entity, shift everything after down */
+	for (i = index; i < core_freesync->num_entities - 1; i++)
+		core_freesync->map[i] = core_freesync->map[i + 1];
+	core_freesync->num_entities--;
+	return true;
+}
+
+static void update_stream_freesync_context(struct core_freesync *core_freesync,
+		const struct dc_stream *stream)
+{
+	unsigned int index;
+	struct freesync_context *ctx;
+	struct core_stream *core_stream;
+
+	core_stream = DC_STREAM_TO_CORE(stream);
+	ctx = &core_stream->public.freesync_ctx;
+
+	index = map_index_from_stream(core_freesync, stream);
+
+	ctx->supported = core_freesync->map[index].caps->supported;
+	ctx->enabled = (core_freesync->map[index].user_enable.enable_for_gaming ||
+		core_freesync->map[index].user_enable.enable_for_video ||
+		core_freesync->map[index].user_enable.enable_for_static);
+	ctx->active = (core_freesync->map[index].state.fullscreen ||
+		core_freesync->map[index].state.video ||
+		core_freesync->map[index].state.static_ramp.ramp_is_active);
+	ctx->min_refresh_in_micro_hz =
+			core_freesync->map[index].caps->min_refresh_in_micro_hz;
+	ctx->nominal_refresh_in_micro_hz = core_freesync->
+		map[index].state.nominal_refresh_rate_in_micro_hz;
+
+}
+
+static void update_stream(struct core_freesync *core_freesync,
+		const struct dc_stream *stream)
+{
+	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
+
+	unsigned int index = map_index_from_stream(core_freesync, stream);
+	if (core_freesync->map[index].caps->supported) {
+		core_stream->public.ignore_msa_timing_param = 1;
+		update_stream_freesync_context(core_freesync, stream);
+	}
+}
+
+static void calc_vmin_vmax(struct core_freesync *core_freesync,
+		const struct dc_stream *stream, int *vmin, int *vmax)
+{
+	unsigned int min_frame_duration_in_ns = 0, max_frame_duration_in_ns = 0;
+	unsigned int index = map_index_from_stream(core_freesync, stream);
+
+	min_frame_duration_in_ns = ((unsigned int) (div64_u64(
+					(1000000000ULL * 1000000),
+					core_freesync->map[index].state.
+					nominal_refresh_rate_in_micro_hz)));
+	max_frame_duration_in_ns = ((unsigned int) (div64_u64(
+					(1000000000ULL * 1000000),
+					core_freesync->map[index].caps->min_refresh_in_micro_hz)));
+
+	*vmax = div64_u64(div64_u64(((unsigned long long)(
+			max_frame_duration_in_ns) * stream->timing.pix_clk_khz),
+			stream->timing.h_total), 1000000);
+	*vmin = div64_u64(div64_u64(((unsigned long long)(
+			min_frame_duration_in_ns) * stream->timing.pix_clk_khz),
+			stream->timing.h_total), 1000000);
+}
+
+static void calc_v_total_from_duration(const struct dc_stream *stream,
+		unsigned int duration_in_ns, int *v_total_nominal)
+{
+	*v_total_nominal = div64_u64(div64_u64(((unsigned long long)(
+				duration_in_ns) * stream->timing.pix_clk_khz),
+				stream->timing.h_total), 1000000);
+}
+
+static void calc_v_total_for_static_ramp(struct core_freesync *core_freesync,
+		const struct dc_stream *stream,
+		unsigned int index, int *v_total)
+{
+	unsigned int frame_duration = 0;
+
+	struct gradual_static_ramp *static_ramp_variables =
+				&core_freesync->map[index].state.static_ramp;
+
+	/* Calc ratio between new and current frame duration with 3 digit */
+	unsigned int frame_duration_ratio = div64_u64(1000000,
+		(1000 +  div64_u64(((unsigned long long)(
+		STATIC_SCREEN_RAMP_DELTA_REFRESH_RATE_PER_FRAME) *
+		static_ramp_variables->ramp_current_frame_duration_in_ns),
+		1000000000)));
+
+	/* Calculate delta between new and current frame duration in ns */
+	unsigned int frame_duration_delta = div64_u64(((unsigned long long)(
+		static_ramp_variables->ramp_current_frame_duration_in_ns) *
+		(1000 - frame_duration_ratio)), 1000);
+
+	/* Adjust frame duration delta based on ratio between current and
+	 * standard frame duration (frame duration at 60 Hz refresh rate).
+	 */
+	unsigned int ramp_rate_interpolated = div64_u64(((unsigned long long)(
+		frame_duration_delta) * static_ramp_variables->
+		ramp_current_frame_duration_in_ns), 16666666);
+
+	/* Going to a higher refresh rate (lower frame duration) */
+	if (static_ramp_variables->ramp_direction_is_up) {
+		/* reduce frame duration */
+		static_ramp_variables->ramp_current_frame_duration_in_ns -=
+			ramp_rate_interpolated;
+
+		/* min frame duration */
+		frame_duration = ((unsigned int) (div64_u64(
+			(1000000000ULL * 1000000),
+			core_freesync->map[index].state.
+			nominal_refresh_rate_in_micro_hz)));
+
+		/* adjust for frame duration below min */
+		if (static_ramp_variables->ramp_current_frame_duration_in_ns <=
+			frame_duration) {
+
+			static_ramp_variables->ramp_is_active = false;
+			static_ramp_variables->
+				ramp_current_frame_duration_in_ns =
+				frame_duration;
+		}
+	/* Going to a lower refresh rate (larger frame duration) */
+	} else {
+		/* increase frame duration */
+		static_ramp_variables->ramp_current_frame_duration_in_ns +=
+			ramp_rate_interpolated;
+
+		/* max frame duration */
+		frame_duration = ((unsigned int) (div64_u64(
+			(1000000000ULL * 1000000),
+			core_freesync->map[index].caps->min_refresh_in_micro_hz)));
+
+		/* adjust for frame duration above max */
+		if (static_ramp_variables->ramp_current_frame_duration_in_ns >=
+			frame_duration) {
+
+			static_ramp_variables->ramp_is_active = false;
+			static_ramp_variables->
+				ramp_current_frame_duration_in_ns =
+				frame_duration;
+		}
+	}
+
+	calc_v_total_from_duration(stream, static_ramp_variables->
+		ramp_current_frame_duration_in_ns, v_total);
+}
+
+static void reset_freesync_state_variables(struct freesync_state* state)
+{
+	state->static_ramp.ramp_is_active = false;
+	if (state->nominal_refresh_rate_in_micro_hz)
+		state->static_ramp.ramp_current_frame_duration_in_ns =
+			((unsigned int) (div64_u64(
+			(1000000000ULL * 1000000),
+			state->nominal_refresh_rate_in_micro_hz)));
+
+	state->btr.btr_active = false;
+	state->btr.frame_counter = 0;
+	state->btr.frames_to_insert = 0;
+	state->btr.inserted_frame_duration_in_us = 0;
+	state->btr.program_btr = false;
+
+	state->fixed_refresh.fixed_refresh_active = false;
+	state->fixed_refresh.program_fixed_refresh = false;
+}
+/*
+ * Sets freesync mode on a stream depending on current freesync state.
+ */
+static bool set_freesync_on_streams(struct core_freesync *core_freesync,
+		const struct dc_stream **streams, int num_streams)
+{
+	int v_total_nominal = 0, v_total_min = 0, v_total_max = 0;
+	unsigned int stream_idx, map_index = 0;
+	struct freesync_state *state;
+
+	if (num_streams == 0 || streams == NULL || num_streams > 1)
+		return false;
+
+	for (stream_idx = 0; stream_idx < num_streams; stream_idx++) {
+
+		map_index = map_index_from_stream(core_freesync,
+				streams[stream_idx]);
+
+		state = &core_freesync->map[map_index].state;
+
+		if (core_freesync->map[map_index].caps->supported) {
+
+			/* Fullscreen has the topmost priority. If the
+			 * fullscreen bit is set, we are in a fullscreen
+			 * application where it should not matter if it is
+			 * static screen. We should not check the static_screen
+			 * or video bit.
+			 *
+			 * Special cases of fullscreen include btr and fixed
+			 * refresh. We program btr on every flip and involves
+			 * programming full range right before the last inserted frame.
+			 * However, we do not want to program the full freesync range
+			 * when fixed refresh is active, because we only program
+			 * that logic once and this will override it.
+			 */
+			if (core_freesync->map[map_index].user_enable.
+				enable_for_gaming == true &&
+				state->fullscreen == true &&
+				state->fixed_refresh.fixed_refresh_active == false) {
+				/* Enable freesync */
+
+				calc_vmin_vmax(core_freesync,
+						streams[stream_idx],
+						&v_total_min, &v_total_max);
+
+				/* Update the freesync context for the stream */
+				update_stream_freesync_context(core_freesync,
+						streams[stream_idx]);
+
+				core_freesync->dc->stream_funcs.
+				adjust_vmin_vmax(core_freesync->dc, streams,
+						num_streams, v_total_min,
+						v_total_max);
+
+				return true;
+
+			} else if (core_freesync->map[map_index].user_enable.
+				enable_for_video && state->video == true) {
+				/* Enable 48Hz feature */
+
+				calc_v_total_from_duration(streams[stream_idx],
+					state->time.update_duration_in_ns,
+					&v_total_nominal);
+
+				/* Program only if v_total_nominal is in range*/
+				if (v_total_nominal >=
+					streams[stream_idx]->timing.v_total) {
+
+					/* Update the freesync context for
+					 * the stream
+					 */
+					update_stream_freesync_context(
+						core_freesync,
+						streams[stream_idx]);
+
+					core_freesync->dc->stream_funcs.
+					adjust_vmin_vmax(
+						core_freesync->dc, streams,
+						num_streams, v_total_nominal,
+						v_total_nominal);
+				}
+				return true;
+
+			} else {
+				/* Disable freesync */
+				v_total_nominal = streams[stream_idx]->
+					timing.v_total;
+
+				/* Update the freesync context for
+				 * the stream
+				 */
+				update_stream_freesync_context(
+					core_freesync,
+					streams[stream_idx]);
+
+				core_freesync->dc->stream_funcs.
+						adjust_vmin_vmax(
+						core_freesync->dc, streams,
+						num_streams, v_total_nominal,
+						v_total_nominal);
+
+				/* Reset the cached variables */
+				reset_freesync_state_variables(state);
+
+				return true;
+			}
+		} else {
+			/* Disable freesync */
+			v_total_nominal = streams[stream_idx]->
+				timing.v_total;
+			/*
+			 * we have to reset drr always even sink does
+			 * not support freesync because a former stream has
+			 * be programmed
+			 */
+			core_freesync->dc->stream_funcs.
+					adjust_vmin_vmax(
+					core_freesync->dc, streams,
+					num_streams, v_total_nominal,
+					v_total_nominal);
+			/* Reset the cached variables */
+			reset_freesync_state_variables(state);
+		}
+
+	}
+
+	return false;
+}
+
+static void set_static_ramp_variables(struct core_freesync *core_freesync,
+		unsigned int index, bool enable_static_screen)
+{
+	unsigned int frame_duration = 0;
+
+	struct gradual_static_ramp *static_ramp_variables =
+			&core_freesync->map[index].state.static_ramp;
+
+	/* If ramp is not active, set initial frame duration depending on
+	 * whether we are enabling/disabling static screen mode. If the ramp is
+	 * already active, ramp should continue in the opposite direction
+	 * starting with the current frame duration
+	 */
+	if (!static_ramp_variables->ramp_is_active) {
+
+		static_ramp_variables->ramp_is_active = true;
+
+		if (enable_static_screen == true) {
+			/* Going to lower refresh rate, so start from max
+			 * refresh rate (min frame duration)
+			 */
+			frame_duration = ((unsigned int) (div64_u64(
+				(1000000000ULL * 1000000),
+				core_freesync->map[index].state.
+				nominal_refresh_rate_in_micro_hz)));
+		} else {
+			/* Going to higher refresh rate, so start from min
+			 * refresh rate (max frame duration)
+			 */
+			frame_duration = ((unsigned int) (div64_u64(
+				(1000000000ULL * 1000000),
+				core_freesync->map[index].caps->min_refresh_in_micro_hz)));
+		}
+
+		static_ramp_variables->
+			ramp_current_frame_duration_in_ns = frame_duration;
+	}
+
+	/* If we are ENABLING static screen, refresh rate should go DOWN.
+	 * If we are DISABLING static screen, refresh rate should go UP.
+	 */
+	static_ramp_variables->ramp_direction_is_up = !enable_static_screen;
+}
+
+void mod_freesync_handle_v_update(struct mod_freesync *mod_freesync,
+		const struct dc_stream **streams, int num_streams)
+{
+	struct core_freesync *core_freesync =
+			MOD_FREESYNC_TO_CORE(mod_freesync);
+
+	unsigned int index, v_total = 0;
+	struct freesync_state *state;
+
+	if (core_freesync->num_entities == 0)
+		return;
+
+	index = map_index_from_stream(core_freesync,
+		streams[0]);
+
+	if (core_freesync->map[index].caps->supported == false)
+		return;
+
+	state = &core_freesync->map[index].state;
+
+	/* Below the Range Logic */
+
+	/* Only execute if in fullscreen mode */
+	if (state->fullscreen == true &&
+		core_freesync->map[index].user_enable.enable_for_gaming) {
+
+		if (state->btr.btr_active)
+			if (state->btr.frame_counter > 0)
+
+				state->btr.frame_counter--;
+
+		if (state->btr.frame_counter == 1) {
+
+			/* Restore FreeSync */
+			set_freesync_on_streams(core_freesync, streams,
+					num_streams);
+		}
+	}
+
+	/* If in fullscreen freesync mode or in video, do not program
+	 * static screen ramp values
+	 */
+	if (state->fullscreen == true || state->video == true) {
+
+		state->static_ramp.ramp_is_active = false;
+
+		return;
+	}
+
+	/* Gradual Static Screen Ramping Logic */
+
+	/* Execute if ramp is active and user enabled freesync static screen*/
+	if (state->static_ramp.ramp_is_active &&
+		core_freesync->map[index].user_enable.enable_for_static) {
+
+		calc_v_total_for_static_ramp(core_freesync, streams[0],
+				index, &v_total);
+
+		/* Update the freesync context for the stream */
+		update_stream_freesync_context(core_freesync, streams[0]);
+
+		/* Program static screen ramp values */
+		core_freesync->dc->stream_funcs.adjust_vmin_vmax(
+					core_freesync->dc, streams,
+					num_streams, v_total,
+					v_total);
+	}
+}
+
+void mod_freesync_update_state(struct mod_freesync *mod_freesync,
+		const struct dc_stream **streams, int num_streams,
+		struct mod_freesync_params *freesync_params)
+{
+	struct core_freesync *core_freesync =
+			MOD_FREESYNC_TO_CORE(mod_freesync);
+	bool freesync_program_required = false;
+	unsigned int stream_index;
+	struct freesync_state *state;
+
+	if (core_freesync->num_entities == 0)
+		return;
+
+	for(stream_index = 0; stream_index < num_streams; stream_index++) {
+
+		unsigned int map_index = map_index_from_stream(core_freesync,
+				streams[stream_index]);
+
+		state = &core_freesync->map[map_index].state;
+
+		switch (freesync_params->state){
+		case FREESYNC_STATE_FULLSCREEN:
+			state->fullscreen = freesync_params->enable;
+			freesync_program_required = true;
+			state->windowed_fullscreen =
+					freesync_params->windowed_fullscreen;
+			break;
+		case FREESYNC_STATE_STATIC_SCREEN:
+			/* Static screen ramp is only enabled for embedded
+			 * panels. Also change core variables only if there
+			 * is a change.
+			 */
+			if (dc_is_embedded_signal(
+				streams[stream_index]->sink->sink_signal) &&
+				state->static_screen !=
+				freesync_params->enable) {
+
+				/* Change the state flag */
+				state->static_screen = freesync_params->enable;
+
+				/* Change static screen ramp variables */
+				set_static_ramp_variables(core_freesync,
+						map_index,
+						freesync_params->enable);
+			}
+			/* We program the ramp starting next VUpdate */
+			break;
+		case FREESYNC_STATE_VIDEO:
+			/* Change core variables only if there is a change*/
+			if(freesync_params->update_duration_in_ns !=
+				state->time.update_duration_in_ns) {
+
+				state->video = freesync_params->enable;
+				state->time.update_duration_in_ns =
+					freesync_params->update_duration_in_ns;
+
+				freesync_program_required = true;
+			}
+			break;
+		}
+	}
+
+	if (freesync_program_required)
+		/* Program freesync according to current state*/
+		set_freesync_on_streams(core_freesync, streams, num_streams);
+}
+
+
+bool mod_freesync_get_state(struct mod_freesync *mod_freesync,
+		const struct dc_stream *stream,
+		struct mod_freesync_params *freesync_params)
+{
+	struct core_freesync *core_freesync =
+				MOD_FREESYNC_TO_CORE(mod_freesync);
+
+	unsigned int index = map_index_from_stream(core_freesync, stream);
+
+	if (core_freesync->map[index].state.fullscreen) {
+		freesync_params->state = FREESYNC_STATE_FULLSCREEN;
+		freesync_params->enable = true;
+	} else if (core_freesync->map[index].state.static_screen) {
+		freesync_params->state = FREESYNC_STATE_STATIC_SCREEN;
+		freesync_params->enable = true;
+	} else if (core_freesync->map[index].state.video) {
+		freesync_params->state = FREESYNC_STATE_VIDEO;
+		freesync_params->enable = true;
+	} else {
+		freesync_params->state = FREESYNC_STATE_NONE;
+		freesync_params->enable = false;
+	}
+
+	freesync_params->update_duration_in_ns =
+		core_freesync->map[index].state.time.update_duration_in_ns;
+
+	return true;
+}
+
+bool mod_freesync_set_user_enable(struct mod_freesync *mod_freesync,
+		const struct dc_stream **streams, int num_streams,
+		struct mod_freesync_user_enable *user_enable)
+{
+	struct core_freesync *core_freesync =
+			MOD_FREESYNC_TO_CORE(mod_freesync);
+	struct core_dc *core_dc = DC_TO_CORE(core_freesync->dc);
+
+	unsigned int stream_index, map_index;
+	int persistent_data = 0;
+	struct persistent_data_flag flag;
+
+	flag.save_per_edid = true;
+	flag.save_per_link = false;
+
+	for(stream_index = 0; stream_index < num_streams;
+			stream_index++){
+
+		map_index = map_index_from_stream(core_freesync,
+				streams[stream_index]);
+
+		core_freesync->map[map_index].user_enable = *user_enable;
+
+		/* Write persistent data in registry*/
+		if (core_freesync->map[map_index].user_enable.
+				enable_for_gaming)
+			persistent_data = persistent_data | 1;
+		if (core_freesync->map[map_index].user_enable.
+				enable_for_static)
+			persistent_data = persistent_data | 2;
+		if (core_freesync->map[map_index].user_enable.
+				enable_for_video)
+			persistent_data = persistent_data | 4;
+
+		dm_write_persistent_data(core_dc->ctx,
+					streams[stream_index]->sink,
+					FREESYNC_REGISTRY_NAME,
+					"userenable",
+					&persistent_data,
+					sizeof(int),
+					&flag);
+	}
+
+	set_freesync_on_streams(core_freesync, streams, num_streams);
+
+	return true;
+}
+
+bool mod_freesync_get_user_enable(struct mod_freesync *mod_freesync,
+		const struct dc_stream *stream,
+		struct mod_freesync_user_enable *user_enable)
+{
+	struct core_freesync *core_freesync =
+			MOD_FREESYNC_TO_CORE(mod_freesync);
+
+	unsigned int index = map_index_from_stream(core_freesync, stream);
+
+	*user_enable = core_freesync->map[index].user_enable;
+
+	return true;
+}
+
+void mod_freesync_notify_mode_change(struct mod_freesync *mod_freesync,
+		const struct dc_stream **streams, int num_streams)
+{
+	struct core_freesync *core_freesync =
+			MOD_FREESYNC_TO_CORE(mod_freesync);
+
+	unsigned int stream_index, map_index;
+	unsigned min_frame_duration_in_ns, max_frame_duration_in_ns;
+	struct freesync_state *state;
+
+	for (stream_index = 0; stream_index < num_streams; stream_index++) {
+
+		map_index = map_index_from_stream(core_freesync,
+				streams[stream_index]);
+
+		state = &core_freesync->map[map_index].state;
+
+		if (core_freesync->map[map_index].caps->supported) {
+			/* Update the field rate for new timing */
+			state->nominal_refresh_rate_in_micro_hz = 1000000 *
+				div64_u64(div64_u64((streams[stream_index]->
+				timing.pix_clk_khz * 1000),
+				streams[stream_index]->timing.v_total),
+				streams[stream_index]->timing.h_total);
+
+			/* Update the stream */
+			update_stream(core_freesync, streams[stream_index]);
+
+			/* Determine whether BTR can be supported */
+			min_frame_duration_in_ns = ((unsigned int) (div64_u64(
+					(1000000000ULL * 1000000),
+					state->nominal_refresh_rate_in_micro_hz)));
+
+			max_frame_duration_in_ns = ((unsigned int) (div64_u64(
+					(1000000000ULL * 1000000),
+					core_freesync->map[map_index].caps->min_refresh_in_micro_hz)));
+
+			if (max_frame_duration_in_ns >=
+					2 * min_frame_duration_in_ns)
+				core_freesync->map[map_index].caps->btr_supported = true;
+			else
+				core_freesync->map[map_index].caps->btr_supported = false;
+
+			/* Cache the time variables */
+			state->time.max_render_time_in_us =
+				max_frame_duration_in_ns / 1000;
+			state->time.min_render_time_in_us =
+				min_frame_duration_in_ns / 1000;
+			state->btr.mid_point_in_us =
+				(max_frame_duration_in_ns +
+				min_frame_duration_in_ns) / 2000;
+
+		}
+	}
+
+	/* Program freesync according to current state*/
+	set_freesync_on_streams(core_freesync, streams, num_streams);
+}
+
+/* Add the timestamps to the cache and determine whether BTR programming
+ * is required, depending on the times calculated
+ */
+static void update_timestamps(struct core_freesync *core_freesync,
+		const struct dc_stream *stream, unsigned int map_index,
+		unsigned int last_render_time_in_us)
+{
+	struct freesync_state *state = &core_freesync->map[map_index].state;
+
+	state->time.render_times[state->time.render_times_index] =
+			last_render_time_in_us;
+	state->time.render_times_index++;
+
+	if (state->time.render_times_index >= RENDER_TIMES_MAX_COUNT)
+		state->time.render_times_index = 0;
+
+	if (last_render_time_in_us + BTR_EXIT_MARGIN <
+		state->time.max_render_time_in_us) {
+
+		/* Exit Below the Range */
+		if (state->btr.btr_active) {
+
+			state->btr.program_btr = true;
+			state->btr.btr_active = false;
+			state->btr.frame_counter = 0;
+
+		/* Exit Fixed Refresh mode */
+		} else if (state->fixed_refresh.fixed_refresh_active) {
+
+			state->fixed_refresh.program_fixed_refresh = true;
+			state->fixed_refresh.fixed_refresh_active = false;
+
+		}
+
+	} else if (last_render_time_in_us > state->time.max_render_time_in_us) {
+
+		/* Enter Below the Range */
+		if (!state->btr.btr_active &&
+				core_freesync->map[map_index].caps->btr_supported) {
+
+			state->btr.program_btr = true;
+			state->btr.btr_active = true;
+
+		/* Enter Fixed Refresh mode */
+		} else if (!state->fixed_refresh.fixed_refresh_active &&
+			!core_freesync->map[map_index].caps->btr_supported) {
+
+			state->fixed_refresh.program_fixed_refresh = true;
+			state->fixed_refresh.fixed_refresh_active = true;
+
+		}
+	}
+
+	/* When Below the Range is active, must react on every frame */
+	if (state->btr.btr_active)
+		state->btr.program_btr = true;
+}
+
+static void apply_below_the_range(struct core_freesync *core_freesync,
+		const struct dc_stream *stream, unsigned int map_index,
+		unsigned int last_render_time_in_us)
+{
+	unsigned int inserted_frame_duration_in_us = 0;
+	unsigned int mid_point_frames_ceil = 0;
+	unsigned int mid_point_frames_floor = 0;
+	unsigned int frame_time_in_us = 0;
+	unsigned int delta_from_mid_point_in_us_1 = 0xFFFFFFFF;
+	unsigned int delta_from_mid_point_in_us_2 = 0xFFFFFFFF;
+	unsigned int frames_to_insert = 0;
+	unsigned int inserted_frame_v_total = 0;
+	unsigned int vmin = 0, vmax = 0;
+	unsigned int min_frame_duration_in_ns = 0;
+	struct freesync_state *state = &core_freesync->map[map_index].state;
+
+	if (!state->btr.program_btr)
+		return;
+
+	state->btr.program_btr = false;
+
+	min_frame_duration_in_ns = ((unsigned int) (div64_u64(
+		(1000000000ULL * 1000000),
+		state->nominal_refresh_rate_in_micro_hz)));
+
+	/* Program BTR */
+
+	/* BTR set to "not active" so disengage */
+	if (!state->btr.btr_active)
+
+		/* Restore FreeSync */
+		set_freesync_on_streams(core_freesync, &stream, 1);
+
+	/* BTR set to "active" so engage */
+	else {
+
+		/* Calculate number of midPoint frames that could fit within
+		 * the render time interval- take ceil of this value
+		 */
+		mid_point_frames_ceil = (last_render_time_in_us +
+			state->btr.mid_point_in_us- 1) /
+			state->btr.mid_point_in_us;
+
+		if (mid_point_frames_ceil > 0) {
+
+			frame_time_in_us = last_render_time_in_us /
+				mid_point_frames_ceil;
+			delta_from_mid_point_in_us_1 = (state->btr.mid_point_in_us >
+				frame_time_in_us) ?
+				(state->btr.mid_point_in_us - frame_time_in_us):
+				(frame_time_in_us - state->btr.mid_point_in_us);
+		}
+
+		/* Calculate number of midPoint frames that could fit within
+		 * the render time interval- take floor of this value
+		 */
+		mid_point_frames_floor = last_render_time_in_us /
+			state->btr.mid_point_in_us;
+
+		if (mid_point_frames_floor > 0) {
+
+			frame_time_in_us = last_render_time_in_us /
+				mid_point_frames_floor;
+			delta_from_mid_point_in_us_2 = (state->btr.mid_point_in_us >
+				frame_time_in_us) ?
+				(state->btr.mid_point_in_us - frame_time_in_us):
+				(frame_time_in_us - state->btr.mid_point_in_us);
+		}
+
+		/* Choose number of frames to insert based on how close it
+		 * can get to the mid point of the variable range.
+		 */
+		if (delta_from_mid_point_in_us_1 < delta_from_mid_point_in_us_2)
+			frames_to_insert = mid_point_frames_ceil;
+		else
+			frames_to_insert = mid_point_frames_floor;
+
+		/* Either we've calculated the number of frames to insert,
+		 * or we need to insert min duration frames
+		 */
+		if (frames_to_insert > 0)
+			inserted_frame_duration_in_us = last_render_time_in_us /
+							frames_to_insert;
+
+		if (inserted_frame_duration_in_us <
+			state->time.min_render_time_in_us)
+
+			inserted_frame_duration_in_us =
+				state->time.min_render_time_in_us;
+
+		/* We need the v_total_min from capability */
+		calc_vmin_vmax(core_freesync, stream, &vmin, &vmax);
+
+		inserted_frame_v_total = vmin;
+		if (min_frame_duration_in_ns / 1000)
+			inserted_frame_v_total = inserted_frame_duration_in_us *
+				vmin / (min_frame_duration_in_ns / 1000);
+
+		/* Set length of inserted frames as v_total_max*/
+		vmax = inserted_frame_v_total;
+
+		/* Program V_TOTAL */
+		core_freesync->dc->stream_funcs.adjust_vmin_vmax(
+			core_freesync->dc, &stream,
+			1, vmin,
+			vmax);
+
+		/* Cache the calculated variables */
+		state->btr.inserted_frame_duration_in_us =
+			inserted_frame_duration_in_us;
+		state->btr.frames_to_insert = frames_to_insert;
+		state->btr.frame_counter = frames_to_insert;
+
+	}
+}
+
+static void apply_fixed_refresh(struct core_freesync *core_freesync,
+		const struct dc_stream *stream, unsigned int map_index)
+{
+	unsigned int vmin = 0, vmax = 0;
+	struct freesync_state *state = &core_freesync->map[map_index].state;
+
+	if (!state->fixed_refresh.program_fixed_refresh)
+		return;
+
+	state->fixed_refresh.program_fixed_refresh = false;
+
+	/* Program Fixed Refresh */
+
+	/* Fixed Refresh set to "not active" so disengage */
+	if (!state->fixed_refresh.fixed_refresh_active) {
+		set_freesync_on_streams(core_freesync, &stream, 1);
+
+	/* Fixed Refresh set to "active" so engage (fix to max) */
+	} else {
+
+		calc_vmin_vmax(core_freesync, stream, &vmin, &vmax);
+
+		vmax = vmin;
+
+		core_freesync->dc->stream_funcs.adjust_vmin_vmax(
+				core_freesync->dc, &stream,
+				1, vmin,
+				vmax);
+	}
+}
+
+void mod_freesync_pre_update_plane_addresses(struct mod_freesync *mod_freesync,
+		const struct dc_stream **streams, int num_streams,
+		unsigned int curr_time_stamp_in_us)
+{
+	unsigned int stream_index, map_index, last_render_time_in_us = 0;
+	struct core_freesync *core_freesync =
+			MOD_FREESYNC_TO_CORE(mod_freesync);
+
+	for (stream_index = 0; stream_index < num_streams; stream_index++) {
+
+		map_index = map_index_from_stream(core_freesync,
+						streams[stream_index]);
+
+		if (core_freesync->map[map_index].caps->supported) {
+
+			last_render_time_in_us = curr_time_stamp_in_us -
+					core_freesync->map[map_index].state.time.
+					prev_time_stamp_in_us;
+
+			/* Add the timestamps to the cache and determine
+			 * whether BTR program is required
+			 */
+			update_timestamps(core_freesync, streams[stream_index],
+					map_index, last_render_time_in_us);
+
+			if (core_freesync->map[map_index].state.fullscreen &&
+				core_freesync->map[map_index].user_enable.
+				enable_for_gaming) {
+
+				if (core_freesync->map[map_index].caps->btr_supported) {
+
+					apply_below_the_range(core_freesync,
+						streams[stream_index], map_index,
+						last_render_time_in_us);
+				} else {
+					apply_fixed_refresh(core_freesync,
+						streams[stream_index], map_index);
+				}
+			}
+
+			core_freesync->map[map_index].state.time.
+				prev_time_stamp_in_us = curr_time_stamp_in_us;
+		}
+
+	}
+}
