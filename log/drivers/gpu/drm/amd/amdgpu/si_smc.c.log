commit 47b757fba2a382d5f818d1884fe87c4014818088
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:57 2019 +0200

    drm/amd: drop use of drmP.h in remaining files
    
    With this commit drm/amd/ has no longer any uses of
    the deprecated drmP.h header file.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-11-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/amdgpu/si_smc.c b/drivers/gpu/drm/amd/amdgpu/si_smc.c
index 4a2fd8b61940..8f994ffa9cd1 100644
--- a/drivers/gpu/drm/amd/amdgpu/si_smc.c
+++ b/drivers/gpu/drm/amd/amdgpu/si_smc.c
@@ -23,7 +23,7 @@
  */
 
 #include <linux/firmware.h>
-#include <drm/drmP.h>
+
 #include "amdgpu.h"
 #include "sid.h"
 #include "ppsmc.h"

commit 248a1d6f1ac410d3ed3907c1be2502e286f59bb8
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Apr 24 13:50:21 2017 +0900

    drm/amd: fix include notation and remove -Iinclude/drm flag
    
    Include <drm/*.h> instead of relative path from include/drm, then
    remove the -Iinclude/drm compiler flag.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Michel Dänzer <michel.daenzer@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1493009447-31524-4-git-send-email-yamada.masahiro@socionext.com

diff --git a/drivers/gpu/drm/amd/amdgpu/si_smc.c b/drivers/gpu/drm/amd/amdgpu/si_smc.c
index 0726bc3b6f90..4a2fd8b61940 100644
--- a/drivers/gpu/drm/amd/amdgpu/si_smc.c
+++ b/drivers/gpu/drm/amd/amdgpu/si_smc.c
@@ -23,7 +23,7 @@
  */
 
 #include <linux/firmware.h>
-#include "drmP.h"
+#include <drm/drmP.h>
 #include "amdgpu.h"
 #include "sid.h"
 #include "ppsmc.h"

commit 689957b12b6315c63bd8cce879e2b259a8a4b666
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jan 24 18:00:57 2017 -0500

    drm/amdgpu: move misc si headers into amdgpu
    
    Move these to the amdgpu directory to match what we
    do for other asics.
    
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/si_smc.c b/drivers/gpu/drm/amd/amdgpu/si_smc.c
index 668ba99d6c05..0726bc3b6f90 100644
--- a/drivers/gpu/drm/amd/amdgpu/si_smc.c
+++ b/drivers/gpu/drm/amd/amdgpu/si_smc.c
@@ -25,7 +25,7 @@
 #include <linux/firmware.h>
 #include "drmP.h"
 #include "amdgpu.h"
-#include "si/sid.h"
+#include "sid.h"
 #include "ppsmc.h"
 #include "amdgpu_ucode.h"
 #include "sislands_smc.h"

commit 6861c837e28e1b1300a1b24ddab748c8ee50da3b
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Sep 13 00:06:07 2016 -0400

    drm/amdgpu/si/dpm: fix symbol conflicts with radeon
    
    Acked-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Edward O'Callaghan <funfunctor@folklore1984.net>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/si_smc.c b/drivers/gpu/drm/amd/amdgpu/si_smc.c
index 47bbb40e7014..668ba99d6c05 100644
--- a/drivers/gpu/drm/amd/amdgpu/si_smc.c
+++ b/drivers/gpu/drm/amd/amdgpu/si_smc.c
@@ -44,9 +44,9 @@ static int si_set_smc_sram_address(struct amdgpu_device *adev,
 	return 0;
 }
 
-int si_copy_bytes_to_smc(struct amdgpu_device *adev,
-			 u32 smc_start_address,
-			 const u8 *src, u32 byte_count, u32 limit)
+int amdgpu_si_copy_bytes_to_smc(struct amdgpu_device *adev,
+				u32 smc_start_address,
+				const u8 *src, u32 byte_count, u32 limit)
 {
 	unsigned long flags;
 	int ret = 0;
@@ -108,7 +108,7 @@ int si_copy_bytes_to_smc(struct amdgpu_device *adev,
 	return ret;
 }
 
-void si_start_smc(struct amdgpu_device *adev)
+void amdgpu_si_start_smc(struct amdgpu_device *adev)
 {
 	u32 tmp = RREG32_SMC(SMC_SYSCON_RESET_CNTL);
 
@@ -117,7 +117,7 @@ void si_start_smc(struct amdgpu_device *adev)
 	WREG32_SMC(SMC_SYSCON_RESET_CNTL, tmp);
 }
 
-void si_reset_smc(struct amdgpu_device *adev)
+void amdgpu_si_reset_smc(struct amdgpu_device *adev)
 {
 	u32 tmp;
 
@@ -131,14 +131,14 @@ void si_reset_smc(struct amdgpu_device *adev)
 	WREG32_SMC(SMC_SYSCON_RESET_CNTL, tmp);
 }
 
-int si_program_jump_on_start(struct amdgpu_device *adev)
+int amdgpu_si_program_jump_on_start(struct amdgpu_device *adev)
 {
 	static const u8 data[] = { 0x0E, 0x00, 0x40, 0x40 };
 
-	return si_copy_bytes_to_smc(adev, 0x0, data, 4, sizeof(data)+1);
+	return amdgpu_si_copy_bytes_to_smc(adev, 0x0, data, 4, sizeof(data)+1);
 }
 
-void si_smc_clock(struct amdgpu_device *adev, bool enable)
+void amdgpu_si_smc_clock(struct amdgpu_device *adev, bool enable)
 {
 	u32 tmp = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);
 
@@ -150,7 +150,7 @@ void si_smc_clock(struct amdgpu_device *adev, bool enable)
 	WREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0, tmp);
 }
 
-bool si_is_smc_running(struct amdgpu_device *adev)
+bool amdgpu_si_is_smc_running(struct amdgpu_device *adev)
 {
 	u32 rst = RREG32_SMC(SMC_SYSCON_RESET_CNTL);
 	u32 clk = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);
@@ -161,12 +161,13 @@ bool si_is_smc_running(struct amdgpu_device *adev)
 	return false;
 }
 
-PPSMC_Result si_send_msg_to_smc(struct amdgpu_device *adev, PPSMC_Msg msg)
+PPSMC_Result amdgpu_si_send_msg_to_smc(struct amdgpu_device *adev,
+				       PPSMC_Msg msg)
 {
 	u32 tmp;
 	int i;
 
-	if (!si_is_smc_running(adev))
+	if (!amdgpu_si_is_smc_running(adev))
 		return PPSMC_Result_Failed;
 
 	WREG32(SMC_MESSAGE_0, msg);
@@ -181,12 +182,12 @@ PPSMC_Result si_send_msg_to_smc(struct amdgpu_device *adev, PPSMC_Msg msg)
 	return (PPSMC_Result)RREG32(SMC_RESP_0);
 }
 
-PPSMC_Result si_wait_for_smc_inactive(struct amdgpu_device *adev)
+PPSMC_Result amdgpu_si_wait_for_smc_inactive(struct amdgpu_device *adev)
 {
 	u32 tmp;
 	int i;
 
-	if (!si_is_smc_running(adev))
+	if (!amdgpu_si_is_smc_running(adev))
 		return PPSMC_Result_OK;
 
 	for (i = 0; i < adev->usec_timeout; i++) {
@@ -199,7 +200,7 @@ PPSMC_Result si_wait_for_smc_inactive(struct amdgpu_device *adev)
 	return PPSMC_Result_OK;
 }
 
-int si_load_smc_ucode(struct amdgpu_device *adev, u32 limit)
+int amdgpu_si_load_smc_ucode(struct amdgpu_device *adev, u32 limit)
 {
 	const struct smc_firmware_header_v1_0 *hdr;
 	unsigned long flags;
@@ -241,8 +242,8 @@ int si_load_smc_ucode(struct amdgpu_device *adev, u32 limit)
 	return 0;
 }
 
-int si_read_smc_sram_dword(struct amdgpu_device *adev, u32 smc_address,
-			   u32 *value, u32 limit)
+int amdgpu_si_read_smc_sram_dword(struct amdgpu_device *adev, u32 smc_address,
+				  u32 *value, u32 limit)
 {
 	unsigned long flags;
 	int ret;
@@ -256,8 +257,8 @@ int si_read_smc_sram_dword(struct amdgpu_device *adev, u32 smc_address,
 	return ret;
 }
 
-int si_write_smc_sram_dword(struct amdgpu_device *adev, u32 smc_address,
-			    u32 value, u32 limit)
+int amdgpu_si_write_smc_sram_dword(struct amdgpu_device *adev, u32 smc_address,
+				   u32 value, u32 limit)
 {
 	unsigned long flags;
 	int ret;

commit f80c738c614e4410c3c343141c0edabfea421862
Author: Tom St Denis <tom.stdenis@amd.com>
Date:   Tue Sep 6 11:56:42 2016 -0400

    drm/amd/amdgpu: Tidy up SI SMC code (v2)
    
    As well as merge SMC clock functions into one to reduce LOC.
    
    v2: Fix swapped ck enable bit
    bug: https://bugs.freedesktop.org/show_bug.cgi?id=97801
    
    Signed-off-by: Tom St Denis <tom.stdenis@amd.com>
    Reviewed-by: Edward O'Callaghan <funfunctor@folklore1984.net>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/si_smc.c b/drivers/gpu/drm/amd/amdgpu/si_smc.c
index c1c259464ae7..47bbb40e7014 100644
--- a/drivers/gpu/drm/amd/amdgpu/si_smc.c
+++ b/drivers/gpu/drm/amd/amdgpu/si_smc.c
@@ -84,7 +84,6 @@ int si_copy_bytes_to_smc(struct amdgpu_device *adev,
 			goto done;
 
 		original_data = RREG32(SMC_IND_DATA_0);
-
 		extra_shift = 8 * (4 - byte_count);
 
 		while (byte_count > 0) {
@@ -94,7 +93,6 @@ int si_copy_bytes_to_smc(struct amdgpu_device *adev,
 		}
 
 		data <<= extra_shift;
-
 		data |= (original_data & ~((~0UL) << extra_shift));
 
 		ret = si_set_smc_sram_address(adev, addr, limit);
@@ -128,8 +126,8 @@ void si_reset_smc(struct amdgpu_device *adev)
 	RREG32(CB_CGTT_SCLK_CTRL);
 	RREG32(CB_CGTT_SCLK_CTRL);
 
-	tmp = RREG32_SMC(SMC_SYSCON_RESET_CNTL);
-	tmp |= RST_REG;
+	tmp = RREG32_SMC(SMC_SYSCON_RESET_CNTL) |
+	      RST_REG;
 	WREG32_SMC(SMC_SYSCON_RESET_CNTL, tmp);
 }
 
@@ -140,20 +138,14 @@ int si_program_jump_on_start(struct amdgpu_device *adev)
 	return si_copy_bytes_to_smc(adev, 0x0, data, 4, sizeof(data)+1);
 }
 
-void si_stop_smc_clock(struct amdgpu_device *adev)
-{
-	u32 tmp = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);
-
-	tmp |= CK_DISABLE;
-
-	WREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0, tmp);
-}
-
-void si_start_smc_clock(struct amdgpu_device *adev)
+void si_smc_clock(struct amdgpu_device *adev, bool enable)
 {
 	u32 tmp = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);
 
-	tmp &= ~CK_DISABLE;
+	if (enable)
+		tmp &= ~CK_DISABLE;
+	else
+		tmp |= CK_DISABLE;
 
 	WREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0, tmp);
 }
@@ -185,9 +177,8 @@ PPSMC_Result si_send_msg_to_smc(struct amdgpu_device *adev, PPSMC_Msg msg)
 			break;
 		udelay(1);
 	}
-	tmp = RREG32(SMC_RESP_0);
 
-	return (PPSMC_Result)tmp;
+	return (PPSMC_Result)RREG32(SMC_RESP_0);
 }
 
 PPSMC_Result si_wait_for_smc_inactive(struct amdgpu_device *adev)

commit 841686df9f7d2942cfd94d024b8591fa3f74ef7c
Author: Maruthi Bayyavarapu <maruthi.bayyavarapu@amd.com>
Date:   Mon Aug 1 12:42:32 2016 -0400

    drm/amdgpu: add SI DPM support (v4)
    
    v2: corrected register offset shift
    v3: rebase fixes
    v4: fix firmware paths
        add SI smc firmware versions for sysfs dump
        remove unused function forward define
        fix the tahiti specific value of DEEP_SLEEP_CLK_SEL field
        fix to miss adding thermal controller
        use vram_type instead of checking mem_gddr5 flag
        fix incorrect index of CG_FFCT_0 register
        fix incorrect reading method at si_get_current_pcie_speed
    
    Signed-off-by: Maruthi Bayyavarapu <maruthi.bayyavarapu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/si_smc.c b/drivers/gpu/drm/amd/amdgpu/si_smc.c
index 214f37c3b688..c1c259464ae7 100644
--- a/drivers/gpu/drm/amd/amdgpu/si_smc.c
+++ b/drivers/gpu/drm/amd/amdgpu/si_smc.c
@@ -224,6 +224,7 @@ int si_load_smc_ucode(struct amdgpu_device *adev, u32 limit)
 
 	amdgpu_ucode_print_smc_hdr(&hdr->header);
 
+	adev->pm.fw_version = le32_to_cpu(hdr->header.ucode_version);
 	ucode_start_address = le32_to_cpu(hdr->ucode_start_addr);
 	ucode_size = le32_to_cpu(hdr->header.ucode_size_bytes);
 	src = (const u8 *)

commit 0c34f45368422dc34545a56a60f3884ffc3a4a3b
Author: Maruthi Srinivas Bayyavarapu <Maruthi.Bayyavarapu@amd.com>
Date:   Tue Apr 26 20:31:54 2016 +0530

    drm/amdgpu: add SI SMC support
    
    Signed-off-by: Maruthi Bayyavarapu <maruthi.bayyavarapu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/si_smc.c b/drivers/gpu/drm/amd/amdgpu/si_smc.c
new file mode 100644
index 000000000000..214f37c3b688
--- /dev/null
+++ b/drivers/gpu/drm/amd/amdgpu/si_smc.c
@@ -0,0 +1,280 @@
+/*
+ * Copyright 2011 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Alex Deucher
+ */
+
+#include <linux/firmware.h>
+#include "drmP.h"
+#include "amdgpu.h"
+#include "si/sid.h"
+#include "ppsmc.h"
+#include "amdgpu_ucode.h"
+#include "sislands_smc.h"
+
+static int si_set_smc_sram_address(struct amdgpu_device *adev,
+				   u32 smc_address, u32 limit)
+{
+	if (smc_address & 3)
+		return -EINVAL;
+	if ((smc_address + 3) > limit)
+		return -EINVAL;
+
+	WREG32(SMC_IND_INDEX_0, smc_address);
+	WREG32_P(SMC_IND_ACCESS_CNTL, 0, ~AUTO_INCREMENT_IND_0);
+
+	return 0;
+}
+
+int si_copy_bytes_to_smc(struct amdgpu_device *adev,
+			 u32 smc_start_address,
+			 const u8 *src, u32 byte_count, u32 limit)
+{
+	unsigned long flags;
+	int ret = 0;
+	u32 data, original_data, addr, extra_shift;
+
+	if (smc_start_address & 3)
+		return -EINVAL;
+	if ((smc_start_address + byte_count) > limit)
+		return -EINVAL;
+
+	addr = smc_start_address;
+
+	spin_lock_irqsave(&adev->smc_idx_lock, flags);
+	while (byte_count >= 4) {
+		/* SMC address space is BE */
+		data = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
+
+		ret = si_set_smc_sram_address(adev, addr, limit);
+		if (ret)
+			goto done;
+
+		WREG32(SMC_IND_DATA_0, data);
+
+		src += 4;
+		byte_count -= 4;
+		addr += 4;
+	}
+
+	/* RMW for the final bytes */
+	if (byte_count > 0) {
+		data = 0;
+
+		ret = si_set_smc_sram_address(adev, addr, limit);
+		if (ret)
+			goto done;
+
+		original_data = RREG32(SMC_IND_DATA_0);
+
+		extra_shift = 8 * (4 - byte_count);
+
+		while (byte_count > 0) {
+			/* SMC address space is BE */
+			data = (data << 8) + *src++;
+			byte_count--;
+		}
+
+		data <<= extra_shift;
+
+		data |= (original_data & ~((~0UL) << extra_shift));
+
+		ret = si_set_smc_sram_address(adev, addr, limit);
+		if (ret)
+			goto done;
+
+		WREG32(SMC_IND_DATA_0, data);
+	}
+
+done:
+	spin_unlock_irqrestore(&adev->smc_idx_lock, flags);
+
+	return ret;
+}
+
+void si_start_smc(struct amdgpu_device *adev)
+{
+	u32 tmp = RREG32_SMC(SMC_SYSCON_RESET_CNTL);
+
+	tmp &= ~RST_REG;
+
+	WREG32_SMC(SMC_SYSCON_RESET_CNTL, tmp);
+}
+
+void si_reset_smc(struct amdgpu_device *adev)
+{
+	u32 tmp;
+
+	RREG32(CB_CGTT_SCLK_CTRL);
+	RREG32(CB_CGTT_SCLK_CTRL);
+	RREG32(CB_CGTT_SCLK_CTRL);
+	RREG32(CB_CGTT_SCLK_CTRL);
+
+	tmp = RREG32_SMC(SMC_SYSCON_RESET_CNTL);
+	tmp |= RST_REG;
+	WREG32_SMC(SMC_SYSCON_RESET_CNTL, tmp);
+}
+
+int si_program_jump_on_start(struct amdgpu_device *adev)
+{
+	static const u8 data[] = { 0x0E, 0x00, 0x40, 0x40 };
+
+	return si_copy_bytes_to_smc(adev, 0x0, data, 4, sizeof(data)+1);
+}
+
+void si_stop_smc_clock(struct amdgpu_device *adev)
+{
+	u32 tmp = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);
+
+	tmp |= CK_DISABLE;
+
+	WREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0, tmp);
+}
+
+void si_start_smc_clock(struct amdgpu_device *adev)
+{
+	u32 tmp = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);
+
+	tmp &= ~CK_DISABLE;
+
+	WREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0, tmp);
+}
+
+bool si_is_smc_running(struct amdgpu_device *adev)
+{
+	u32 rst = RREG32_SMC(SMC_SYSCON_RESET_CNTL);
+	u32 clk = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);
+
+	if (!(rst & RST_REG) && !(clk & CK_DISABLE))
+		return true;
+
+	return false;
+}
+
+PPSMC_Result si_send_msg_to_smc(struct amdgpu_device *adev, PPSMC_Msg msg)
+{
+	u32 tmp;
+	int i;
+
+	if (!si_is_smc_running(adev))
+		return PPSMC_Result_Failed;
+
+	WREG32(SMC_MESSAGE_0, msg);
+
+	for (i = 0; i < adev->usec_timeout; i++) {
+		tmp = RREG32(SMC_RESP_0);
+		if (tmp != 0)
+			break;
+		udelay(1);
+	}
+	tmp = RREG32(SMC_RESP_0);
+
+	return (PPSMC_Result)tmp;
+}
+
+PPSMC_Result si_wait_for_smc_inactive(struct amdgpu_device *adev)
+{
+	u32 tmp;
+	int i;
+
+	if (!si_is_smc_running(adev))
+		return PPSMC_Result_OK;
+
+	for (i = 0; i < adev->usec_timeout; i++) {
+		tmp = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);
+		if ((tmp & CKEN) == 0)
+			break;
+		udelay(1);
+	}
+
+	return PPSMC_Result_OK;
+}
+
+int si_load_smc_ucode(struct amdgpu_device *adev, u32 limit)
+{
+	const struct smc_firmware_header_v1_0 *hdr;
+	unsigned long flags;
+	u32 ucode_start_address;
+	u32 ucode_size;
+	const u8 *src;
+	u32 data;
+
+	if (!adev->pm.fw)
+		return -EINVAL;
+
+	hdr = (const struct smc_firmware_header_v1_0 *)adev->pm.fw->data;
+
+	amdgpu_ucode_print_smc_hdr(&hdr->header);
+
+	ucode_start_address = le32_to_cpu(hdr->ucode_start_addr);
+	ucode_size = le32_to_cpu(hdr->header.ucode_size_bytes);
+	src = (const u8 *)
+		(adev->pm.fw->data + le32_to_cpu(hdr->header.ucode_array_offset_bytes));
+	if (ucode_size & 3)
+		return -EINVAL;
+
+	spin_lock_irqsave(&adev->smc_idx_lock, flags);
+	WREG32(SMC_IND_INDEX_0, ucode_start_address);
+	WREG32_P(SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, ~AUTO_INCREMENT_IND_0);
+	while (ucode_size >= 4) {
+		/* SMC address space is BE */
+		data = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
+
+		WREG32(SMC_IND_DATA_0, data);
+
+		src += 4;
+		ucode_size -= 4;
+	}
+	WREG32_P(SMC_IND_ACCESS_CNTL, 0, ~AUTO_INCREMENT_IND_0);
+	spin_unlock_irqrestore(&adev->smc_idx_lock, flags);
+
+	return 0;
+}
+
+int si_read_smc_sram_dword(struct amdgpu_device *adev, u32 smc_address,
+			   u32 *value, u32 limit)
+{
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&adev->smc_idx_lock, flags);
+	ret = si_set_smc_sram_address(adev, smc_address, limit);
+	if (ret == 0)
+		*value = RREG32(SMC_IND_DATA_0);
+	spin_unlock_irqrestore(&adev->smc_idx_lock, flags);
+
+	return ret;
+}
+
+int si_write_smc_sram_dword(struct amdgpu_device *adev, u32 smc_address,
+			    u32 value, u32 limit)
+{
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&adev->smc_idx_lock, flags);
+	ret = si_set_smc_sram_address(adev, smc_address, limit);
+	if (ret == 0)
+		WREG32(SMC_IND_DATA_0, value);
+	spin_unlock_irqrestore(&adev->smc_idx_lock, flags);
+
+	return ret;
+}
