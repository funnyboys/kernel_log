commit e0c116c1906618823e6fa823a8a727bcea04ac18
Author: Hawking Zhang <Hawking.Zhang@amd.com>
Date:   Tue Mar 31 15:20:49 2020 -0400

    drm/amdgpu: re-structue members for ip discovery
    
    This is to prepare for initializing discovery tmr size per
    ASIC type
    
    Signed-off-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Reviewed-by: Likun Gao <Likun.Gao@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
index 43bb22ad8add..b5d6274952a5 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
@@ -133,9 +133,10 @@ static int hw_id_map[MAX_HWIP] = {
 static int amdgpu_discovery_read_binary(struct amdgpu_device *adev, uint8_t *binary)
 {
 	uint64_t vram_size = (uint64_t)RREG32(mmRCC_CONFIG_MEMSIZE) << 20;
-	uint64_t pos = vram_size - DISCOVERY_TMR_SIZE;
+	uint64_t pos = vram_size - adev->discovery_tmr_size;
 
-	amdgpu_device_vram_access(adev, pos, (uint32_t *)binary, DISCOVERY_TMR_SIZE, false);
+	amdgpu_device_vram_access(adev, pos, (uint32_t *)binary,
+				  adev->discovery_tmr_size, false);
 	return 0;
 }
 
@@ -167,17 +168,18 @@ static int amdgpu_discovery_init(struct amdgpu_device *adev)
 	uint16_t checksum;
 	int r;
 
-	adev->discovery = kzalloc(DISCOVERY_TMR_SIZE, GFP_KERNEL);
-	if (!adev->discovery)
+	adev->discovery_tmr_size = DISCOVERY_TMR_SIZE;
+	adev->discovery_bin = kzalloc(adev->discovery_tmr_size, GFP_KERNEL);
+	if (!adev->discovery_bin)
 		return -ENOMEM;
 
-	r = amdgpu_discovery_read_binary(adev, adev->discovery);
+	r = amdgpu_discovery_read_binary(adev, adev->discovery_bin);
 	if (r) {
 		DRM_ERROR("failed to read ip discovery binary\n");
 		goto out;
 	}
 
-	bhdr = (struct binary_header *)adev->discovery;
+	bhdr = (struct binary_header *)adev->discovery_bin;
 
 	if (le32_to_cpu(bhdr->binary_signature) != BINARY_SIGNATURE) {
 		DRM_ERROR("invalid ip discovery binary signature\n");
@@ -190,7 +192,7 @@ static int amdgpu_discovery_init(struct amdgpu_device *adev)
 	size = bhdr->binary_size - offset;
 	checksum = bhdr->binary_checksum;
 
-	if (!amdgpu_discovery_verify_checksum(adev->discovery + offset,
+	if (!amdgpu_discovery_verify_checksum(adev->discovery_bin + offset,
 					      size, checksum)) {
 		DRM_ERROR("invalid ip discovery binary checksum\n");
 		r = -EINVAL;
@@ -200,7 +202,7 @@ static int amdgpu_discovery_init(struct amdgpu_device *adev)
 	info = &bhdr->table_list[IP_DISCOVERY];
 	offset = le16_to_cpu(info->offset);
 	checksum = le16_to_cpu(info->checksum);
-	ihdr = (struct ip_discovery_header *)(adev->discovery + offset);
+	ihdr = (struct ip_discovery_header *)(adev->discovery_bin + offset);
 
 	if (le32_to_cpu(ihdr->signature) != DISCOVERY_TABLE_SIGNATURE) {
 		DRM_ERROR("invalid ip discovery data table signature\n");
@@ -208,7 +210,7 @@ static int amdgpu_discovery_init(struct amdgpu_device *adev)
 		goto out;
 	}
 
-	if (!amdgpu_discovery_verify_checksum(adev->discovery + offset,
+	if (!amdgpu_discovery_verify_checksum(adev->discovery_bin + offset,
 					      ihdr->size, checksum)) {
 		DRM_ERROR("invalid ip discovery data table checksum\n");
 		r = -EINVAL;
@@ -218,9 +220,9 @@ static int amdgpu_discovery_init(struct amdgpu_device *adev)
 	info = &bhdr->table_list[GC];
 	offset = le16_to_cpu(info->offset);
 	checksum = le16_to_cpu(info->checksum);
-	ghdr = (struct gpu_info_header *)(adev->discovery + offset);
+	ghdr = (struct gpu_info_header *)(adev->discovery_bin + offset);
 
-	if (!amdgpu_discovery_verify_checksum(adev->discovery + offset,
+	if (!amdgpu_discovery_verify_checksum(adev->discovery_bin + offset,
 				              ghdr->size, checksum)) {
 		DRM_ERROR("invalid gc data table checksum\n");
 		r = -EINVAL;
@@ -230,16 +232,16 @@ static int amdgpu_discovery_init(struct amdgpu_device *adev)
 	return 0;
 
 out:
-	kfree(adev->discovery);
-	adev->discovery = NULL;
+	kfree(adev->discovery_bin);
+	adev->discovery_bin = NULL;
 
 	return r;
 }
 
 void amdgpu_discovery_fini(struct amdgpu_device *adev)
 {
-	kfree(adev->discovery);
-	adev->discovery = NULL;
+	kfree(adev->discovery_bin);
+	adev->discovery_bin = NULL;
 }
 
 int amdgpu_discovery_reg_base_init(struct amdgpu_device *adev)
@@ -263,8 +265,8 @@ int amdgpu_discovery_reg_base_init(struct amdgpu_device *adev)
 		return r;
 	}
 
-	bhdr = (struct binary_header *)adev->discovery;
-	ihdr = (struct ip_discovery_header *)(adev->discovery +
+	bhdr = (struct binary_header *)adev->discovery_bin;
+	ihdr = (struct ip_discovery_header *)(adev->discovery_bin +
 			le16_to_cpu(bhdr->table_list[IP_DISCOVERY].offset));
 	num_dies = le16_to_cpu(ihdr->num_dies);
 
@@ -272,7 +274,7 @@ int amdgpu_discovery_reg_base_init(struct amdgpu_device *adev)
 
 	for (i = 0; i < num_dies; i++) {
 		die_offset = le16_to_cpu(ihdr->die_info[i].die_offset);
-		dhdr = (struct die_header *)(adev->discovery + die_offset);
+		dhdr = (struct die_header *)(adev->discovery_bin + die_offset);
 		num_ips = le16_to_cpu(dhdr->num_ips);
 		ip_offset = die_offset + sizeof(*dhdr);
 
@@ -286,7 +288,7 @@ int amdgpu_discovery_reg_base_init(struct amdgpu_device *adev)
 				le16_to_cpu(dhdr->die_id), num_ips);
 
 		for (j = 0; j < num_ips; j++) {
-			ip = (struct ip *)(adev->discovery + ip_offset);
+			ip = (struct ip *)(adev->discovery_bin + ip_offset);
 			num_base_address = ip->num_base_address;
 
 			DRM_DEBUG("%s(%d) #%d v%d.%d.%d:\n",
@@ -335,24 +337,24 @@ int amdgpu_discovery_get_ip_version(struct amdgpu_device *adev, int hw_id,
 	uint16_t num_ips;
 	int i, j;
 
-	if (!adev->discovery) {
+	if (!adev->discovery_bin) {
 		DRM_ERROR("ip discovery uninitialized\n");
 		return -EINVAL;
 	}
 
-	bhdr = (struct binary_header *)adev->discovery;
-	ihdr = (struct ip_discovery_header *)(adev->discovery +
+	bhdr = (struct binary_header *)adev->discovery_bin;
+	ihdr = (struct ip_discovery_header *)(adev->discovery_bin +
 			le16_to_cpu(bhdr->table_list[IP_DISCOVERY].offset));
 	num_dies = le16_to_cpu(ihdr->num_dies);
 
 	for (i = 0; i < num_dies; i++) {
 		die_offset = le16_to_cpu(ihdr->die_info[i].die_offset);
-		dhdr = (struct die_header *)(adev->discovery + die_offset);
+		dhdr = (struct die_header *)(adev->discovery_bin + die_offset);
 		num_ips = le16_to_cpu(dhdr->num_ips);
 		ip_offset = die_offset + sizeof(*dhdr);
 
 		for (j = 0; j < num_ips; j++) {
-			ip = (struct ip *)(adev->discovery + ip_offset);
+			ip = (struct ip *)(adev->discovery_bin + ip_offset);
 
 			if (le16_to_cpu(ip->hw_id) == hw_id) {
 				if (major)
@@ -375,13 +377,13 @@ int amdgpu_discovery_get_gfx_info(struct amdgpu_device *adev)
 	struct binary_header *bhdr;
 	struct gc_info_v1_0 *gc_info;
 
-	if (!adev->discovery) {
+	if (!adev->discovery_bin) {
 		DRM_ERROR("ip discovery uninitialized\n");
 		return -EINVAL;
 	}
 
-	bhdr = (struct binary_header *)adev->discovery;
-	gc_info = (struct gc_info_v1_0 *)(adev->discovery +
+	bhdr = (struct binary_header *)adev->discovery_bin;
+	gc_info = (struct gc_info_v1_0 *)(adev->discovery_bin +
 			le16_to_cpu(bhdr->table_list[GC].offset));
 
 	adev->gfx.config.max_shader_engines = le32_to_cpu(gc_info->gc_num_se);

commit dffa11b4f74b1572341a667ec7a006420dc48626
Author: Monk Liu <Monk.Liu@amd.com>
Date:   Wed Mar 4 21:33:27 2020 +0800

    drm/amdgpu: adjust sequence of ip_discovery init and timeout_setting
    
    what:
    1)move timtout setting before ip_early_init to reduce exclusive mode
    cost for SRIOV
    
    2)move ip_discovery_init() to inside of amdgpu_discovery_reg_base_init()
    it is a prepare for the later upcoming patches.
    
    why:
    in later upcoming patches we would use a new mailbox event --
    "req_gpu_init_data", which is a callback hooked in adev->virt.ops and
    this callback send a new event "REQ_GPU_INIT_DAT" to host to notify
    host to do some preparation like "IP discovery/vbios on the VF FB"
    and this callback must be:
    
    A) invoked after set_ip_block() because virt.ops is configured during
    set_ip_block()
    
    B) invoked before ip_discovery_init() becausen ip_discovery_init()
    need host side prepares everything in VF FB first.
    
    current place of ip_discovery_init() is before we can invoke callback
    of adev->virt.ops, thus we must move ip_discovery_init() to a place
    after the adev->virt.ops all settle done, and the perfect place is in
    amdgpu_discovery_reg_base_init()
    
    Signed-off-by: Monk Liu <Monk.Liu@amd.com>
    Reviewed-by: Emily Deng <Emily.Deng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
index 37e1fcf970b8..43bb22ad8add 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
@@ -156,7 +156,7 @@ static inline bool amdgpu_discovery_verify_checksum(uint8_t *data, uint32_t size
 	return !!(amdgpu_discovery_calculate_checksum(data, size) == expected);
 }
 
-int amdgpu_discovery_init(struct amdgpu_device *adev)
+static int amdgpu_discovery_init(struct amdgpu_device *adev)
 {
 	struct table_info *info;
 	struct binary_header *bhdr;
@@ -255,10 +255,12 @@ int amdgpu_discovery_reg_base_init(struct amdgpu_device *adev)
 	uint8_t num_base_address;
 	int hw_ip;
 	int i, j, k;
+	int r;
 
-	if (!adev->discovery) {
-		DRM_ERROR("ip discovery uninitialized\n");
-		return -EINVAL;
+	r = amdgpu_discovery_init(adev);
+	if (r) {
+		DRM_ERROR("amdgpu_discovery_init failed\n");
+		return r;
 	}
 
 	bhdr = (struct binary_header *)adev->discovery;

commit 8884532a6e0fb3f76affd26b0c57e58a5833c072
Author: Monk Liu <Monk.Liu@amd.com>
Date:   Wed Mar 4 13:46:09 2020 +0800

    drm/amdgpu: purge ip_discovery headers
    
    those two headers are not needed for ip discovery
    
    Signed-off-by: Monk Liu <Monk.Liu@amd.com>
    Reviewed-by: Emily Deng <Emily.Deng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
index 27d8ae19a7a4..37e1fcf970b8 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
@@ -23,9 +23,7 @@
 
 #include "amdgpu.h"
 #include "amdgpu_discovery.h"
-#include "soc15_common.h"
 #include "soc15_hw_ip.h"
-#include "nbio/nbio_2_3_offset.h"
 #include "discovery.h"
 
 #define mmRCC_CONFIG_MEMSIZE	0xde3

commit 91aeda1811665a4ed781e7882912ef129e1705fa
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Feb 19 13:46:27 2020 -0500

    drm/amdgpu/discovery: make the discovery code less chatty
    
    Make the IP block base output debug only.
    
    Reviewed-by: Xiaojie Yuan <xiaojie.yuan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
index f95092741c38..27d8ae19a7a4 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
@@ -307,7 +307,7 @@ int amdgpu_discovery_reg_base_init(struct amdgpu_device *adev)
 
 			for (hw_ip = 0; hw_ip < MAX_HWIP; hw_ip++) {
 				if (hw_id_map[hw_ip] == le16_to_cpu(ip->hw_id)) {
-					DRM_INFO("set register base offset for %s\n",
+					DRM_DEBUG("set register base offset for %s\n",
 							hw_id_names[le16_to_cpu(ip->hw_id)]);
 					adev->reg_offset[hw_ip][ip->number_instance] =
 						ip->base_address;

commit e35e2b117f4dba2761d96e378c28734f6807f227
Author: Tianci.Yin <tianci.yin@amd.com>
Date:   Mon Sep 30 13:33:50 2019 +0800

    drm/amdgpu: add a generic fb accessing helper function(v3)
    
    add a generic helper function for accessing framebuffer via MMIO
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Luben Tuikov <luben.tuikov@amd.com>
    Signed-off-by: Tianci.Yin <tianci.yin@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
index ddd8364102a2..f95092741c38 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
@@ -134,20 +134,10 @@ static int hw_id_map[MAX_HWIP] = {
 
 static int amdgpu_discovery_read_binary(struct amdgpu_device *adev, uint8_t *binary)
 {
-	uint32_t *p = (uint32_t *)binary;
 	uint64_t vram_size = (uint64_t)RREG32(mmRCC_CONFIG_MEMSIZE) << 20;
 	uint64_t pos = vram_size - DISCOVERY_TMR_SIZE;
-	unsigned long flags;
-
-	while (pos < vram_size) {
-		spin_lock_irqsave(&adev->mmio_idx_lock, flags);
-		WREG32_NO_KIQ(mmMM_INDEX, ((uint32_t)pos) | 0x80000000);
-		WREG32_NO_KIQ(mmMM_INDEX_HI, pos >> 31);
-		*p++ = RREG32_NO_KIQ(mmMM_DATA);
-		spin_unlock_irqrestore(&adev->mmio_idx_lock, flags);
-		pos += 4;
-	}
 
+	amdgpu_device_vram_access(adev, pos, (uint32_t *)binary, DISCOVERY_TMR_SIZE, false);
 	return 0;
 }
 

commit 45cf454e4c0fa34d33980063408095179369c5f0
Author: Tianci.Yin <tianci.yin@amd.com>
Date:   Mon Sep 30 13:10:03 2019 +0800

    drm/amdgpu: update amdgpu_discovery to handle revision
    
    update amdgpu_discovery to get IP revision.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Luben Tuikov <luben.tuikov@amd.com>
    Signed-off-by: Tianci.Yin <tianci.yin@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
index 71198c5318e1..ddd8364102a2 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
@@ -333,7 +333,7 @@ int amdgpu_discovery_reg_base_init(struct amdgpu_device *adev)
 }
 
 int amdgpu_discovery_get_ip_version(struct amdgpu_device *adev, int hw_id,
-				    int *major, int *minor)
+				    int *major, int *minor, int *revision)
 {
 	struct binary_header *bhdr;
 	struct ip_discovery_header *ihdr;
@@ -369,6 +369,8 @@ int amdgpu_discovery_get_ip_version(struct amdgpu_device *adev, int hw_id,
 					*major = ip->major;
 				if (minor)
 					*minor = ip->minor;
+				if (revision)
+					*revision = ip->revision;
 				return 0;
 			}
 			ip_offset += sizeof(*ip) + 4 * (ip->num_base_address - 1);

commit 5f6a556f98de425fcb7928456839a06f02156633
Author: Xiaojie Yuan <xiaojie.yuan@amd.com>
Date:   Thu Oct 10 20:44:20 2019 +0800

    drm/amdgpu/discovery: reserve discovery data at the top of VRAM
    
    IP Discovery data is TMR fenced by the latest PSP BL,
    so we need to reserve this region.
    
    Tested on navi10/12/14 with VBIOS integrated with latest PSP BL.
    
    v2: use DISCOVERY_TMR_SIZE macro as bo size
        use amdgpu_bo_create_kernel_at() to allocate bo
    
    Signed-off-by: Xiaojie Yuan <xiaojie.yuan@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
index 1481899f86c1..71198c5318e1 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
@@ -136,7 +136,7 @@ static int amdgpu_discovery_read_binary(struct amdgpu_device *adev, uint8_t *bin
 {
 	uint32_t *p = (uint32_t *)binary;
 	uint64_t vram_size = (uint64_t)RREG32(mmRCC_CONFIG_MEMSIZE) << 20;
-	uint64_t pos = vram_size - BINARY_MAX_SIZE;
+	uint64_t pos = vram_size - DISCOVERY_TMR_SIZE;
 	unsigned long flags;
 
 	while (pos < vram_size) {
@@ -179,7 +179,7 @@ int amdgpu_discovery_init(struct amdgpu_device *adev)
 	uint16_t checksum;
 	int r;
 
-	adev->discovery = kzalloc(BINARY_MAX_SIZE, GFP_KERNEL);
+	adev->discovery = kzalloc(DISCOVERY_TMR_SIZE, GFP_KERNEL);
 	if (!adev->discovery)
 		return -ENOMEM;
 

commit a349b39253d597a83f3d5eb85e129da429652583
Author: tiancyin <tianci.yin@amd.com>
Date:   Thu Jul 11 14:09:50 2019 +0800

    drm/amdgpu/discovery: fix DCE_HWIP mapping error in hw_id_map array
    
    ID of DCE_HWIP from vbios is DMU_HWID,
    mismatch cause null pointer crash in navi10 modprobe.
    
    Reviewed-by: Feifei Xu <Feifei.Xu@amd.com>
    Reviewed-by: Xiaojie Yuan <xiaojie.yuan@amd.com>
    Signed-off-by: tiancyin <tianci.yin@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
index e049ae6a76fb..1481899f86c1 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
@@ -123,7 +123,7 @@ static int hw_id_map[MAX_HWIP] = {
 	[UVD_HWIP]	= UVD_HWID,
 	[VCE_HWIP]	= VCE_HWID,
 	[DF_HWIP]	= DF_HWID,
-	[DCE_HWIP]	= DCEAZ_HWID,
+	[DCE_HWIP]	= DMU_HWID,
 	[OSSSYS_HWIP]	= OSSSYS_HWID,
 	[SMUIO_HWIP]	= SMUIO_HWID,
 	[PWR_HWIP]	= PWR_HWID,

commit 437298b833996de86a94d53e4051461cac25010d
Author: Xiaojie Yuan <xiaojie.yuan@amd.com>
Date:   Wed Mar 27 17:58:25 2019 +0800

    drm/amdgpu/discovery: refactor ip list traversal
    
    for each ip, check whether it is needed by amdgpu driver,
    if yes, record its base addresses
    
    v2: change some DRM_INFO to DRM_DEBUG
    v3: remove unused variable (Alex)
    
    Signed-off-by: Xiaojie Yuan <xiaojie.yuan@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
index 697800c4741f..e049ae6a76fb 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
@@ -266,7 +266,6 @@ int amdgpu_discovery_reg_base_init(struct amdgpu_device *adev)
 	uint16_t num_ips;
 	uint8_t num_base_address;
 	int hw_ip;
-	int hw_id;
 	int i, j, k;
 
 	if (!adev->discovery) {
@@ -279,40 +278,54 @@ int amdgpu_discovery_reg_base_init(struct amdgpu_device *adev)
 			le16_to_cpu(bhdr->table_list[IP_DISCOVERY].offset));
 	num_dies = le16_to_cpu(ihdr->num_dies);
 
-	for (hw_ip = 0; hw_ip < MAX_HWIP; hw_ip++) {
-		hw_id = hw_id_map[hw_ip];
-
-		for (i = 0; i < num_dies; i++) {
-			die_offset = le16_to_cpu(ihdr->die_info[i].die_offset);
-			dhdr = (struct die_header *)(adev->discovery + die_offset);
-			num_ips = le16_to_cpu(dhdr->num_ips);
-			ip_offset = die_offset + sizeof(*dhdr);
-
-			for (j = 0; j < num_ips; j++) {
-				ip = (struct ip *)(adev->discovery + ip_offset);
-				num_base_address = ip->num_base_address;
-
-				if (le16_to_cpu(ip->hw_id) == hw_id) {
-					DRM_DEBUG("%s(%d) v%d.%d.%d:\n",
-						  hw_id_names[hw_id], hw_id,
-						  ip->major, ip->minor,
-						  ip->revision);
-
-					for (k = 0; k < num_base_address; k++) {
-						/*
-						 * convert the endianness of base addresses in place,
-						 * so that we don't need to convert them when accessing adev->reg_offset.
-						 */
-						ip->base_address[k] = le32_to_cpu(ip->base_address[k]);
-						DRM_DEBUG("\t0x%08x\n", ip->base_address[k]);
-					}
+	DRM_DEBUG("number of dies: %d\n", num_dies);
 
+	for (i = 0; i < num_dies; i++) {
+		die_offset = le16_to_cpu(ihdr->die_info[i].die_offset);
+		dhdr = (struct die_header *)(adev->discovery + die_offset);
+		num_ips = le16_to_cpu(dhdr->num_ips);
+		ip_offset = die_offset + sizeof(*dhdr);
+
+		if (le16_to_cpu(dhdr->die_id) != i) {
+			DRM_ERROR("invalid die id %d, expected %d\n",
+					le16_to_cpu(dhdr->die_id), i);
+			return -EINVAL;
+		}
+
+		DRM_DEBUG("number of hardware IPs on die%d: %d\n",
+				le16_to_cpu(dhdr->die_id), num_ips);
+
+		for (j = 0; j < num_ips; j++) {
+			ip = (struct ip *)(adev->discovery + ip_offset);
+			num_base_address = ip->num_base_address;
+
+			DRM_DEBUG("%s(%d) #%d v%d.%d.%d:\n",
+				  hw_id_names[le16_to_cpu(ip->hw_id)],
+				  le16_to_cpu(ip->hw_id),
+				  ip->number_instance,
+				  ip->major, ip->minor,
+				  ip->revision);
+
+			for (k = 0; k < num_base_address; k++) {
+				/*
+				 * convert the endianness of base addresses in place,
+				 * so that we don't need to convert them when accessing adev->reg_offset.
+				 */
+				ip->base_address[k] = le32_to_cpu(ip->base_address[k]);
+				DRM_DEBUG("\t0x%08x\n", ip->base_address[k]);
+			}
+
+			for (hw_ip = 0; hw_ip < MAX_HWIP; hw_ip++) {
+				if (hw_id_map[hw_ip] == le16_to_cpu(ip->hw_id)) {
+					DRM_INFO("set register base offset for %s\n",
+							hw_id_names[le16_to_cpu(ip->hw_id)]);
 					adev->reg_offset[hw_ip][ip->number_instance] =
 						ip->base_address;
 				}
 
-				ip_offset += sizeof(*ip) + 4 * (ip->num_base_address - 1);
 			}
+
+			ip_offset += sizeof(*ip) + 4 * (ip->num_base_address - 1);
 		}
 	}
 

commit 966f1d8fd05fd1e3b7c35f4cf657ceb3bfbdfc7a
Author: Xiaojie Yuan <xiaojie.yuan@amd.com>
Date:   Wed Mar 27 20:27:20 2019 +0800

    drm/amdgpu/discovery: stop converting the units of base addresses
    
    the unit is already in dword
    
    Signed-off-by: Xiaojie Yuan <xiaojie.yuan@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
index 5f967ae8d4ed..697800c4741f 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
@@ -300,11 +300,11 @@ int amdgpu_discovery_reg_base_init(struct amdgpu_device *adev)
 
 					for (k = 0; k < num_base_address; k++) {
 						/*
-						 * convert the endianness and unit (in dword) of base addresses in place,
+						 * convert the endianness of base addresses in place,
 						 * so that we don't need to convert them when accessing adev->reg_offset.
 						 */
-						ip->base_address[k] = le32_to_cpu(ip->base_address[k]) >> 2;
-						DRM_DEBUG("\t0x%08x\n", ip->base_address[k] << 2);
+						ip->base_address[k] = le32_to_cpu(ip->base_address[k]);
+						DRM_DEBUG("\t0x%08x\n", ip->base_address[k]);
 					}
 
 					adev->reg_offset[hw_ip][ip->number_instance] =

commit 8e84aa1bf2af81346cc8a3aaab630bc86a4af681
Author: Xiaojie Yuan <xiaojie.yuan@amd.com>
Date:   Wed Mar 27 12:21:40 2019 +0800

    drm/amdgpu/discovery: stop taking psp header into account
    
    psp will write a header to vram, but the value exposed in
    RCC_CONFIG_MEMSIZE does not include the memory that this header is
    written to. Therefore, the interpretation of the table does not need to
    take the psp header into account.
    
    Signed-off-by: Xiaojie Yuan <xiaojie.yuan@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
index ec14fd1350e2..5f967ae8d4ed 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
@@ -189,7 +189,7 @@ int amdgpu_discovery_init(struct amdgpu_device *adev)
 		goto out;
 	}
 
-	bhdr = (struct binary_header *)(adev->discovery + PSP_HEADER_SIZE);
+	bhdr = (struct binary_header *)adev->discovery;
 
 	if (le32_to_cpu(bhdr->binary_signature) != BINARY_SIGNATURE) {
 		DRM_ERROR("invalid ip discovery binary signature\n");
@@ -197,8 +197,7 @@ int amdgpu_discovery_init(struct amdgpu_device *adev)
 		goto out;
 	}
 
-	offset = PSP_HEADER_SIZE +
-		offsetof(struct binary_header, binary_checksum) +
+	offset = offsetof(struct binary_header, binary_checksum) +
 		sizeof(bhdr->binary_checksum);
 	size = bhdr->binary_size - offset;
 	checksum = bhdr->binary_checksum;
@@ -275,7 +274,7 @@ int amdgpu_discovery_reg_base_init(struct amdgpu_device *adev)
 		return -EINVAL;
 	}
 
-	bhdr = (struct binary_header *)(adev->discovery + PSP_HEADER_SIZE);
+	bhdr = (struct binary_header *)adev->discovery;
 	ihdr = (struct ip_discovery_header *)(adev->discovery +
 			le16_to_cpu(bhdr->table_list[IP_DISCOVERY].offset));
 	num_dies = le16_to_cpu(ihdr->num_dies);
@@ -338,7 +337,7 @@ int amdgpu_discovery_get_ip_version(struct amdgpu_device *adev, int hw_id,
 		return -EINVAL;
 	}
 
-	bhdr = (struct binary_header *)(adev->discovery + PSP_HEADER_SIZE);
+	bhdr = (struct binary_header *)adev->discovery;
 	ihdr = (struct ip_discovery_header *)(adev->discovery +
 			le16_to_cpu(bhdr->table_list[IP_DISCOVERY].offset));
 	num_dies = le16_to_cpu(ihdr->num_dies);
@@ -376,7 +375,7 @@ int amdgpu_discovery_get_gfx_info(struct amdgpu_device *adev)
 		return -EINVAL;
 	}
 
-	bhdr = (struct binary_header *)(adev->discovery + PSP_HEADER_SIZE);
+	bhdr = (struct binary_header *)adev->discovery;
 	gc_info = (struct gc_info_v1_0 *)(adev->discovery +
 			le16_to_cpu(bhdr->table_list[GC].offset));
 

commit 2de00413761d7d66cb00001c00240474f222b603
Author: Xiaojie Yuan <xiaojie.yuan@amd.com>
Date:   Wed Mar 27 12:19:20 2019 +0800

    drm/amdgpu/discovery: fix hwid for nbio
    
    Properly set this.
    
    Signed-off-by: Xiaojie Yuan <xiaojie.yuan@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
index ac065ab91c4b..ec14fd1350e2 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
@@ -117,7 +117,7 @@ static int hw_id_map[MAX_HWIP] = {
 	[SDMA1_HWIP]	= SDMA1_HWID,
 	[MMHUB_HWIP]	= MMHUB_HWID,
 	[ATHUB_HWIP]	= ATHUB_HWID,
-	[NBIO_HWIP]	= DBGU_NBIO_HWID,
+	[NBIO_HWIP]	= NBIF_HWID,
 	[MP0_HWIP]	= MP0_HWID,
 	[MP1_HWIP]	= MP1_HWID,
 	[UVD_HWIP]	= UVD_HWID,

commit 85f267a7078f4e0da8513ff1fd3e8a9bc082e44d
Author: Xiaojie Yuan <xiaojie.yuan@amd.com>
Date:   Wed Mar 27 12:29:49 2019 +0800

    drm/amdgpu/discovery: use hardcoded mmRCC_CONFIG_MEMSIZE
    
    register base offset of nbio is not known before IP Discovery table is
    parsed, so hardcode this value.
    
    Signed-off-by: Xiaojie Yuan <xiaojie.yuan@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
index f61eb8542c4d..ac065ab91c4b 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
@@ -28,10 +28,11 @@
 #include "nbio/nbio_2_3_offset.h"
 #include "discovery.h"
 
-#define mmMM_INDEX	0x0
-#define mmMM_INDEX_HI	0x6
-#define mmMM_DATA	0x1
-#define HW_ID_MAX	300
+#define mmRCC_CONFIG_MEMSIZE	0xde3
+#define mmMM_INDEX		0x0
+#define mmMM_INDEX_HI		0x6
+#define mmMM_DATA		0x1
+#define HW_ID_MAX		300
 
 const char *hw_id_names[HW_ID_MAX] = {
 	[MP1_HWID]		= "MP1",
@@ -134,8 +135,7 @@ static int hw_id_map[MAX_HWIP] = {
 static int amdgpu_discovery_read_binary(struct amdgpu_device *adev, uint8_t *binary)
 {
 	uint32_t *p = (uint32_t *)binary;
-	uint64_t vram_size = RREG32_SOC15(NBIO, 0,
-			mmRCC_DEV0_EPF0_RCC_CONFIG_MEMSIZE) * 1024 * 1024;
+	uint64_t vram_size = (uint64_t)RREG32(mmRCC_CONFIG_MEMSIZE) << 20;
 	uint64_t pos = vram_size - BINARY_MAX_SIZE;
 	unsigned long flags;
 

commit 987da7294bdf71fb1b4456cccb13e5cb2469f1aa
Author: Xiaojie Yuan <xiaojie.yuan@amd.com>
Date:   Thu Feb 21 14:05:47 2019 +0800

    drm/amdgpu/discovery: fix calculations of some gfx info
    
    fix gfx info table handling.
    
    Signed-off-by: Xiaojie Yuan <xiaojie.yuan@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
index 7b58273e2ed5..f61eb8542c4d 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
@@ -381,8 +381,9 @@ int amdgpu_discovery_get_gfx_info(struct amdgpu_device *adev)
 			le16_to_cpu(bhdr->table_list[GC].offset));
 
 	adev->gfx.config.max_shader_engines = le32_to_cpu(gc_info->gc_num_se);
-	adev->gfx.config.max_cu_per_sh = le32_to_cpu(gc_info->gc_num_wgp0_per_sa);
-	adev->gfx.config.max_sh_per_se = le32_to_cpu(gc_info->gc_num_wgp1_per_sa);
+	adev->gfx.config.max_cu_per_sh = 2 * (le32_to_cpu(gc_info->gc_num_wgp0_per_sa) +
+					      le32_to_cpu(gc_info->gc_num_wgp1_per_sa));
+	adev->gfx.config.max_sh_per_se = le32_to_cpu(gc_info->gc_num_sa_per_se);
 	adev->gfx.config.max_backends_per_se = le32_to_cpu(gc_info->gc_num_rb_per_se);
 	adev->gfx.config.max_texture_channel_caches = le32_to_cpu(gc_info->gc_num_gl2c);
 	adev->gfx.config.max_gprs = le32_to_cpu(gc_info->gc_num_gprs);
@@ -394,8 +395,9 @@ int amdgpu_discovery_get_gfx_info(struct amdgpu_device *adev)
 	adev->gfx.cu_info.max_waves_per_simd = le32_to_cpu(gc_info->gc_max_waves_per_simd);
 	adev->gfx.cu_info.max_scratch_slots_per_cu = le32_to_cpu(gc_info->gc_max_scratch_slots_per_cu);
 	adev->gfx.cu_info.lds_size = le32_to_cpu(gc_info->gc_lds_size);
-	adev->gfx.config.num_sc_per_sh = le32_to_cpu(gc_info->gc_num_sc_per_se);
-	adev->gfx.config.num_packer_per_sc = le32_to_cpu(gc_info->gc_num_sa_per_se);
+	adev->gfx.config.num_sc_per_sh = le32_to_cpu(gc_info->gc_num_sc_per_se) /
+					 le32_to_cpu(gc_info->gc_num_sa_per_se);
+	adev->gfx.config.num_packer_per_sc = le32_to_cpu(gc_info->gc_num_packer_per_sc);
 
 	return 0;
 }

commit f39f5bb1c9d68d557ff1539fea7adfe7c4d4ed7a
Author: Xiaojie Yuan <xiaojie.yuan@amd.com>
Date:   Thu Jun 20 10:18:50 2019 -0500

    drm/amdgpu/discovery: add ip discovery initial support
    
    The IP discovery table lists is populated by the psp at power on
    and includes all of the hw details on the board:
    - List of IPs and MMIO offsets
    - IP harvest details
    - IP configuration details
    
    v2: prefix struct and function names with 'amdgpu'
    v3: read table binary from vram using mmMM_INDEX and mmMM_DATA
        update TABLE_BINARY_MAX_SIZE to 64kb (1 TMR)
        add 'instance_number' field per ip info
        consider endianness and replace uint8/16/32_t with u8/16/32
        initialize register base addresses
        initialize adev->gfx.config and adev->gfx.cu_info to replace gpu info fw
        get major and minor version using a single api
        don't expose internal data structures in amdgpu_discovery.h
    v4: RCC_CONFIG_MEMSIZE is in MB units
        hold mmio_idx_lock while reading ip discovery binary
    v5: pick out discovery.h as a cross-OS header
        do structure pointer cast directly
        consider endianness while using the member of structure
        convert base addresses to dword
    
    at boot up, PSP BL copies ip discovery binary from VBIOS(SPIROM) image to the
    top of the frame buffer (just below the reserved regions for PSP & SMU).
    
    ip discovery data table includes the collection of each ip's identification
    number, base addresses, version number, and harvest setting placeholder.
    
    gc data table includes gfx info structure.
    
    Signed-off-by: Xiaojie Yuan <xiaojie.yuan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
new file mode 100644
index 000000000000..7b58273e2ed5
--- /dev/null
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c
@@ -0,0 +1,401 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include "amdgpu.h"
+#include "amdgpu_discovery.h"
+#include "soc15_common.h"
+#include "soc15_hw_ip.h"
+#include "nbio/nbio_2_3_offset.h"
+#include "discovery.h"
+
+#define mmMM_INDEX	0x0
+#define mmMM_INDEX_HI	0x6
+#define mmMM_DATA	0x1
+#define HW_ID_MAX	300
+
+const char *hw_id_names[HW_ID_MAX] = {
+	[MP1_HWID]		= "MP1",
+	[MP2_HWID]		= "MP2",
+	[THM_HWID]		= "THM",
+	[SMUIO_HWID]		= "SMUIO",
+	[FUSE_HWID]		= "FUSE",
+	[CLKA_HWID]		= "CLKA",
+	[PWR_HWID]		= "PWR",
+	[GC_HWID]		= "GC",
+	[UVD_HWID]		= "UVD",
+	[AUDIO_AZ_HWID]		= "AUDIO_AZ",
+	[ACP_HWID]		= "ACP",
+	[DCI_HWID]		= "DCI",
+	[DMU_HWID]		= "DMU",
+	[DCO_HWID]		= "DCO",
+	[DIO_HWID]		= "DIO",
+	[XDMA_HWID]		= "XDMA",
+	[DCEAZ_HWID]		= "DCEAZ",
+	[DAZ_HWID]		= "DAZ",
+	[SDPMUX_HWID]		= "SDPMUX",
+	[NTB_HWID]		= "NTB",
+	[IOHC_HWID]		= "IOHC",
+	[L2IMU_HWID]		= "L2IMU",
+	[VCE_HWID]		= "VCE",
+	[MMHUB_HWID]		= "MMHUB",
+	[ATHUB_HWID]		= "ATHUB",
+	[DBGU_NBIO_HWID]	= "DBGU_NBIO",
+	[DFX_HWID]		= "DFX",
+	[DBGU0_HWID]		= "DBGU0",
+	[DBGU1_HWID]		= "DBGU1",
+	[OSSSYS_HWID]		= "OSSSYS",
+	[HDP_HWID]		= "HDP",
+	[SDMA0_HWID]		= "SDMA0",
+	[SDMA1_HWID]		= "SDMA1",
+	[ISP_HWID]		= "ISP",
+	[DBGU_IO_HWID]		= "DBGU_IO",
+	[DF_HWID]		= "DF",
+	[CLKB_HWID]		= "CLKB",
+	[FCH_HWID]		= "FCH",
+	[DFX_DAP_HWID]		= "DFX_DAP",
+	[L1IMU_PCIE_HWID]	= "L1IMU_PCIE",
+	[L1IMU_NBIF_HWID]	= "L1IMU_NBIF",
+	[L1IMU_IOAGR_HWID]	= "L1IMU_IOAGR",
+	[L1IMU3_HWID]		= "L1IMU3",
+	[L1IMU4_HWID]		= "L1IMU4",
+	[L1IMU5_HWID]		= "L1IMU5",
+	[L1IMU6_HWID]		= "L1IMU6",
+	[L1IMU7_HWID]		= "L1IMU7",
+	[L1IMU8_HWID]		= "L1IMU8",
+	[L1IMU9_HWID]		= "L1IMU9",
+	[L1IMU10_HWID]		= "L1IMU10",
+	[L1IMU11_HWID]		= "L1IMU11",
+	[L1IMU12_HWID]		= "L1IMU12",
+	[L1IMU13_HWID]		= "L1IMU13",
+	[L1IMU14_HWID]		= "L1IMU14",
+	[L1IMU15_HWID]		= "L1IMU15",
+	[WAFLC_HWID]		= "WAFLC",
+	[FCH_USB_PD_HWID]	= "FCH_USB_PD",
+	[PCIE_HWID]		= "PCIE",
+	[PCS_HWID]		= "PCS",
+	[DDCL_HWID]		= "DDCL",
+	[SST_HWID]		= "SST",
+	[IOAGR_HWID]		= "IOAGR",
+	[NBIF_HWID]		= "NBIF",
+	[IOAPIC_HWID]		= "IOAPIC",
+	[SYSTEMHUB_HWID]	= "SYSTEMHUB",
+	[NTBCCP_HWID]		= "NTBCCP",
+	[UMC_HWID]		= "UMC",
+	[SATA_HWID]		= "SATA",
+	[USB_HWID]		= "USB",
+	[CCXSEC_HWID]		= "CCXSEC",
+	[XGMI_HWID]		= "XGMI",
+	[XGBE_HWID]		= "XGBE",
+	[MP0_HWID]		= "MP0",
+};
+
+static int hw_id_map[MAX_HWIP] = {
+	[GC_HWIP]	= GC_HWID,
+	[HDP_HWIP]	= HDP_HWID,
+	[SDMA0_HWIP]	= SDMA0_HWID,
+	[SDMA1_HWIP]	= SDMA1_HWID,
+	[MMHUB_HWIP]	= MMHUB_HWID,
+	[ATHUB_HWIP]	= ATHUB_HWID,
+	[NBIO_HWIP]	= DBGU_NBIO_HWID,
+	[MP0_HWIP]	= MP0_HWID,
+	[MP1_HWIP]	= MP1_HWID,
+	[UVD_HWIP]	= UVD_HWID,
+	[VCE_HWIP]	= VCE_HWID,
+	[DF_HWIP]	= DF_HWID,
+	[DCE_HWIP]	= DCEAZ_HWID,
+	[OSSSYS_HWIP]	= OSSSYS_HWID,
+	[SMUIO_HWIP]	= SMUIO_HWID,
+	[PWR_HWIP]	= PWR_HWID,
+	[NBIF_HWIP]	= NBIF_HWID,
+	[THM_HWIP]	= THM_HWID,
+	[CLK_HWIP]	= CLKA_HWID,
+};
+
+static int amdgpu_discovery_read_binary(struct amdgpu_device *adev, uint8_t *binary)
+{
+	uint32_t *p = (uint32_t *)binary;
+	uint64_t vram_size = RREG32_SOC15(NBIO, 0,
+			mmRCC_DEV0_EPF0_RCC_CONFIG_MEMSIZE) * 1024 * 1024;
+	uint64_t pos = vram_size - BINARY_MAX_SIZE;
+	unsigned long flags;
+
+	while (pos < vram_size) {
+		spin_lock_irqsave(&adev->mmio_idx_lock, flags);
+		WREG32_NO_KIQ(mmMM_INDEX, ((uint32_t)pos) | 0x80000000);
+		WREG32_NO_KIQ(mmMM_INDEX_HI, pos >> 31);
+		*p++ = RREG32_NO_KIQ(mmMM_DATA);
+		spin_unlock_irqrestore(&adev->mmio_idx_lock, flags);
+		pos += 4;
+	}
+
+	return 0;
+}
+
+static uint16_t amdgpu_discovery_calculate_checksum(uint8_t *data, uint32_t size)
+{
+	uint16_t checksum = 0;
+	int i;
+
+	for (i = 0; i < size; i++)
+		checksum += data[i];
+
+	return checksum;
+}
+
+static inline bool amdgpu_discovery_verify_checksum(uint8_t *data, uint32_t size,
+						    uint16_t expected)
+{
+	return !!(amdgpu_discovery_calculate_checksum(data, size) == expected);
+}
+
+int amdgpu_discovery_init(struct amdgpu_device *adev)
+{
+	struct table_info *info;
+	struct binary_header *bhdr;
+	struct ip_discovery_header *ihdr;
+	struct gpu_info_header *ghdr;
+	uint16_t offset;
+	uint16_t size;
+	uint16_t checksum;
+	int r;
+
+	adev->discovery = kzalloc(BINARY_MAX_SIZE, GFP_KERNEL);
+	if (!adev->discovery)
+		return -ENOMEM;
+
+	r = amdgpu_discovery_read_binary(adev, adev->discovery);
+	if (r) {
+		DRM_ERROR("failed to read ip discovery binary\n");
+		goto out;
+	}
+
+	bhdr = (struct binary_header *)(adev->discovery + PSP_HEADER_SIZE);
+
+	if (le32_to_cpu(bhdr->binary_signature) != BINARY_SIGNATURE) {
+		DRM_ERROR("invalid ip discovery binary signature\n");
+		r = -EINVAL;
+		goto out;
+	}
+
+	offset = PSP_HEADER_SIZE +
+		offsetof(struct binary_header, binary_checksum) +
+		sizeof(bhdr->binary_checksum);
+	size = bhdr->binary_size - offset;
+	checksum = bhdr->binary_checksum;
+
+	if (!amdgpu_discovery_verify_checksum(adev->discovery + offset,
+					      size, checksum)) {
+		DRM_ERROR("invalid ip discovery binary checksum\n");
+		r = -EINVAL;
+		goto out;
+	}
+
+	info = &bhdr->table_list[IP_DISCOVERY];
+	offset = le16_to_cpu(info->offset);
+	checksum = le16_to_cpu(info->checksum);
+	ihdr = (struct ip_discovery_header *)(adev->discovery + offset);
+
+	if (le32_to_cpu(ihdr->signature) != DISCOVERY_TABLE_SIGNATURE) {
+		DRM_ERROR("invalid ip discovery data table signature\n");
+		r = -EINVAL;
+		goto out;
+	}
+
+	if (!amdgpu_discovery_verify_checksum(adev->discovery + offset,
+					      ihdr->size, checksum)) {
+		DRM_ERROR("invalid ip discovery data table checksum\n");
+		r = -EINVAL;
+		goto out;
+	}
+
+	info = &bhdr->table_list[GC];
+	offset = le16_to_cpu(info->offset);
+	checksum = le16_to_cpu(info->checksum);
+	ghdr = (struct gpu_info_header *)(adev->discovery + offset);
+
+	if (!amdgpu_discovery_verify_checksum(adev->discovery + offset,
+				              ghdr->size, checksum)) {
+		DRM_ERROR("invalid gc data table checksum\n");
+		r = -EINVAL;
+		goto out;
+	}
+
+	return 0;
+
+out:
+	kfree(adev->discovery);
+	adev->discovery = NULL;
+
+	return r;
+}
+
+void amdgpu_discovery_fini(struct amdgpu_device *adev)
+{
+	kfree(adev->discovery);
+	adev->discovery = NULL;
+}
+
+int amdgpu_discovery_reg_base_init(struct amdgpu_device *adev)
+{
+	struct binary_header *bhdr;
+	struct ip_discovery_header *ihdr;
+	struct die_header *dhdr;
+	struct ip *ip;
+	uint16_t die_offset;
+	uint16_t ip_offset;
+	uint16_t num_dies;
+	uint16_t num_ips;
+	uint8_t num_base_address;
+	int hw_ip;
+	int hw_id;
+	int i, j, k;
+
+	if (!adev->discovery) {
+		DRM_ERROR("ip discovery uninitialized\n");
+		return -EINVAL;
+	}
+
+	bhdr = (struct binary_header *)(adev->discovery + PSP_HEADER_SIZE);
+	ihdr = (struct ip_discovery_header *)(adev->discovery +
+			le16_to_cpu(bhdr->table_list[IP_DISCOVERY].offset));
+	num_dies = le16_to_cpu(ihdr->num_dies);
+
+	for (hw_ip = 0; hw_ip < MAX_HWIP; hw_ip++) {
+		hw_id = hw_id_map[hw_ip];
+
+		for (i = 0; i < num_dies; i++) {
+			die_offset = le16_to_cpu(ihdr->die_info[i].die_offset);
+			dhdr = (struct die_header *)(adev->discovery + die_offset);
+			num_ips = le16_to_cpu(dhdr->num_ips);
+			ip_offset = die_offset + sizeof(*dhdr);
+
+			for (j = 0; j < num_ips; j++) {
+				ip = (struct ip *)(adev->discovery + ip_offset);
+				num_base_address = ip->num_base_address;
+
+				if (le16_to_cpu(ip->hw_id) == hw_id) {
+					DRM_DEBUG("%s(%d) v%d.%d.%d:\n",
+						  hw_id_names[hw_id], hw_id,
+						  ip->major, ip->minor,
+						  ip->revision);
+
+					for (k = 0; k < num_base_address; k++) {
+						/*
+						 * convert the endianness and unit (in dword) of base addresses in place,
+						 * so that we don't need to convert them when accessing adev->reg_offset.
+						 */
+						ip->base_address[k] = le32_to_cpu(ip->base_address[k]) >> 2;
+						DRM_DEBUG("\t0x%08x\n", ip->base_address[k] << 2);
+					}
+
+					adev->reg_offset[hw_ip][ip->number_instance] =
+						ip->base_address;
+				}
+
+				ip_offset += sizeof(*ip) + 4 * (ip->num_base_address - 1);
+			}
+		}
+	}
+
+	return 0;
+}
+
+int amdgpu_discovery_get_ip_version(struct amdgpu_device *adev, int hw_id,
+				    int *major, int *minor)
+{
+	struct binary_header *bhdr;
+	struct ip_discovery_header *ihdr;
+	struct die_header *dhdr;
+	struct ip *ip;
+	uint16_t die_offset;
+	uint16_t ip_offset;
+	uint16_t num_dies;
+	uint16_t num_ips;
+	int i, j;
+
+	if (!adev->discovery) {
+		DRM_ERROR("ip discovery uninitialized\n");
+		return -EINVAL;
+	}
+
+	bhdr = (struct binary_header *)(adev->discovery + PSP_HEADER_SIZE);
+	ihdr = (struct ip_discovery_header *)(adev->discovery +
+			le16_to_cpu(bhdr->table_list[IP_DISCOVERY].offset));
+	num_dies = le16_to_cpu(ihdr->num_dies);
+
+	for (i = 0; i < num_dies; i++) {
+		die_offset = le16_to_cpu(ihdr->die_info[i].die_offset);
+		dhdr = (struct die_header *)(adev->discovery + die_offset);
+		num_ips = le16_to_cpu(dhdr->num_ips);
+		ip_offset = die_offset + sizeof(*dhdr);
+
+		for (j = 0; j < num_ips; j++) {
+			ip = (struct ip *)(adev->discovery + ip_offset);
+
+			if (le16_to_cpu(ip->hw_id) == hw_id) {
+				if (major)
+					*major = ip->major;
+				if (minor)
+					*minor = ip->minor;
+				return 0;
+			}
+			ip_offset += sizeof(*ip) + 4 * (ip->num_base_address - 1);
+		}
+	}
+
+	return -EINVAL;
+}
+
+int amdgpu_discovery_get_gfx_info(struct amdgpu_device *adev)
+{
+	struct binary_header *bhdr;
+	struct gc_info_v1_0 *gc_info;
+
+	if (!adev->discovery) {
+		DRM_ERROR("ip discovery uninitialized\n");
+		return -EINVAL;
+	}
+
+	bhdr = (struct binary_header *)(adev->discovery + PSP_HEADER_SIZE);
+	gc_info = (struct gc_info_v1_0 *)(adev->discovery +
+			le16_to_cpu(bhdr->table_list[GC].offset));
+
+	adev->gfx.config.max_shader_engines = le32_to_cpu(gc_info->gc_num_se);
+	adev->gfx.config.max_cu_per_sh = le32_to_cpu(gc_info->gc_num_wgp0_per_sa);
+	adev->gfx.config.max_sh_per_se = le32_to_cpu(gc_info->gc_num_wgp1_per_sa);
+	adev->gfx.config.max_backends_per_se = le32_to_cpu(gc_info->gc_num_rb_per_se);
+	adev->gfx.config.max_texture_channel_caches = le32_to_cpu(gc_info->gc_num_gl2c);
+	adev->gfx.config.max_gprs = le32_to_cpu(gc_info->gc_num_gprs);
+	adev->gfx.config.max_gs_threads = le32_to_cpu(gc_info->gc_num_max_gs_thds);
+	adev->gfx.config.gs_vgt_table_depth = le32_to_cpu(gc_info->gc_gs_table_depth);
+	adev->gfx.config.gs_prim_buffer_depth = le32_to_cpu(gc_info->gc_gsprim_buff_depth);
+	adev->gfx.config.double_offchip_lds_buf = le32_to_cpu(gc_info->gc_double_offchip_lds_buffer);
+	adev->gfx.cu_info.wave_front_size = le32_to_cpu(gc_info->gc_wave_size);
+	adev->gfx.cu_info.max_waves_per_simd = le32_to_cpu(gc_info->gc_max_waves_per_simd);
+	adev->gfx.cu_info.max_scratch_slots_per_cu = le32_to_cpu(gc_info->gc_max_scratch_slots_per_cu);
+	adev->gfx.cu_info.lds_size = le32_to_cpu(gc_info->gc_lds_size);
+	adev->gfx.config.num_sc_per_sh = le32_to_cpu(gc_info->gc_num_sc_per_se);
+	adev->gfx.config.num_packer_per_sc = le32_to_cpu(gc_info->gc_num_sa_per_se);
+
+	return 0;
+}
