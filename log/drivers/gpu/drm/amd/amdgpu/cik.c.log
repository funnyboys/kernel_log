commit dadce777e0947b9b6839f06f360882e54ba2a154
Author: Evan Quan <evan.quan@amd.com>
Date:   Fri Apr 10 15:38:44 2020 +0800

    drm/amdgpu: fix wrong vram lost counter increment V2
    
    Vram lost counter is wrongly increased by two during baco reset.
    
    V2: assumed vram lost for mode1 reset on all ASICs
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index db68ffa27984..fe306d0f73f7 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1358,8 +1358,6 @@ static int cik_asic_reset(struct amdgpu_device *adev)
 	int r;
 
 	if (cik_asic_reset_method(adev) == AMD_RESET_METHOD_BACO) {
-		if (!adev->in_suspend)
-			amdgpu_inc_vram_lost(adev);
 		r = amdgpu_dpm_baco_reset(adev);
 	} else {
 		r = cik_asic_pci_config_reset(adev);

commit 3aa0115d238c71423d0e212138678a8cf51d4361
Author: Monk Liu <Monk.Liu@amd.com>
Date:   Wed Mar 4 14:02:55 2020 +0800

    drm/amdgpu: cleanup all virtualization detection routine
    
    we need to move virt detection much earlier because:
    1) HW team confirms us that RCC_IOV_FUNC_IDENTIFIER will always
    be at DE5 (dw) mmio offset from vega10, this way there is no
    need to implement detect_hw_virt() routine in each nbio/chip file.
    for VI SRIOV chip (tonga & fiji), the BIF_IOV_FUNC_IDENTIFIER is at
    0x1503
    
    2) we need to acknowledged we are SRIOV VF before we do IP discovery because
    the IP discovery content will be updated by host everytime after it recieved
    a new coming "REQ_GPU_INIT_DATA" request from guest (there will be patches
    for this new handshake soon).
    
    Signed-off-by: Monk Liu <Monk.Liu@amd.com>
    Reviewed-by: Emily Deng <Emily.Deng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 006f21ef7ddf..db68ffa27984 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1811,12 +1811,6 @@ static uint32_t cik_get_rev_id(struct amdgpu_device *adev)
 		>> CC_DRM_ID_STRAPS__ATI_REV_ID__SHIFT;
 }
 
-static void cik_detect_hw_virtualization(struct amdgpu_device *adev)
-{
-	if (is_virtual_machine()) /* passthrough mode */
-		adev->virt.caps |= AMDGPU_PASSTHROUGH_MODE;
-}
-
 static void cik_flush_hdp(struct amdgpu_device *adev, struct amdgpu_ring *ring)
 {
 	if (!ring || !ring->funcs->emit_wreg) {
@@ -2179,8 +2173,6 @@ static const struct amdgpu_ip_block_version cik_common_ip_block =
 
 int cik_set_ip_blocks(struct amdgpu_device *adev)
 {
-	cik_detect_hw_virtualization(adev);
-
 	switch (adev->asic_type) {
 	case CHIP_BONAIRE:
 		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);

commit 9530273ec90cc0614f6ac56d0c024e2f39886419
Author: Evan Quan <evan.quan@amd.com>
Date:   Tue Jan 7 16:57:39 2020 +0800

    drm/amd/powerplay: cover the powerplay implementation details V3
    
    This can save users much troubles. As they do not
    actually need to care whether swSMU or traditional
    powerplay routine should be used.
    
    V2: apply the fixes to vi.c and cik.c also
    V3: squash in oops fix
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index e9822ea8bb19..006f21ef7ddf 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1312,19 +1312,13 @@ static int cik_asic_pci_config_reset(struct amdgpu_device *adev)
 
 static bool cik_asic_supports_baco(struct amdgpu_device *adev)
 {
-	bool baco_support;
-
 	switch (adev->asic_type) {
 	case CHIP_BONAIRE:
 	case CHIP_HAWAII:
-		smu7_asic_get_baco_capability(adev, &baco_support);
-		break;
+		return amdgpu_dpm_is_baco_supported(adev);
 	default:
-		baco_support = false;
-		break;
+		return false;
 	}
-
-	return baco_support;
 }
 
 static enum amd_reset_method
@@ -1366,7 +1360,7 @@ static int cik_asic_reset(struct amdgpu_device *adev)
 	if (cik_asic_reset_method(adev) == AMD_RESET_METHOD_BACO) {
 		if (!adev->in_suspend)
 			amdgpu_inc_vram_lost(adev);
-		r = smu7_asic_baco_reset(adev);
+		r = amdgpu_dpm_baco_reset(adev);
 	} else {
 		r = cik_asic_pci_config_reset(adev);
 	}

commit be452c4e8d1434a0095a9baa6523bb9772258d59
Merge: d2e532286d4f ad808910be68
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Dec 17 18:47:46 2019 +0100

    Merge tag 'drm-next-5.6-2019-12-11' of git://people.freedesktop.org/~agd5f/linux into drm-next
    
    drm-next-5.6-2019-12-11:
    
    amdgpu:
    - Add MST atomic routines
    - Add support for DMCUB (new helper microengine for displays)
    - Add OEM i2c support in DC
    - Use vstartup for vblank events on DCN
    - Simplify Kconfig for DC
    - Renoir fixes for DC
    - Clean up function pointers in DC
    - Initial support for HDCP 2.x
    - Misc code cleanups
    - GFX10 fixes
    - Rework JPEG engine handling for VCN
    - Add clock and power gating support for JPEG
    - BACO support for Arcturus
    - Cleanup PSP ring handling
    - Add framework for using BACO with runtime pm to save power
    - Move core pci state handling out of the driver for pm ops
    - Allow guest power control in 1 VF case with SR-IOV
    - SR-IOV fixes
    - RAS fixes
    - Support for power metrics on renoir
    - Golden settings updates for gfx10
    - Enable gfxoff on supported navi10 skus
    - Update MAINTAINERS
    
    amdkfd:
    - Clean up generational gfx code
    - Fixes for gfx10
    - DIQ fixes
    - Share more code with amdgpu
    
    radeon:
    - PPC DMA fix
    - Register checker fixes for r1xx/r2xx
    - Misc cleanups
    
    From: Alex Deucher <alexdeucher@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191211223020.7510-1-alexander.deucher@amd.com

commit 7ada90eb9c7ae4a8eb066f8e9b4d80122f0363db
Merge: 9feb1af97e73 9c1867d730a6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 6 10:28:09 2019 -0800

    Merge tag 'drm-next-2019-12-06' of git://anongit.freedesktop.org/drm/drm
    
    Pull more drm updates from Dave Airlie:
     "Rob pointed out I missed his pull request for msm-next, it's been in
      next for a while outside of my tree so shouldn't cause any unexpected
      issues, it has some OCMEM support in drivers/soc that is acked by
      other maintainers as it's outside my tree.
    
      Otherwise it's a usual fixes pull, i915, amdgpu, the main ones, with
      some tegra, omap, mgag200 and one core fix.
    
      Summary:
    
      msm-next:
       - OCMEM support for a3xx and a4xx GPUs.
       - a510 support + display support
    
      core:
       - mst payload deletion fix
    
      i915:
       - uapi alignment fix
       - fix for power usage regression due to security fixes
       - change default preemption timeout to 640ms from 100ms
       - EHL voltage level display fixes
       - TGL DGL PHY fix
       - gvt - MI_ATOMIC cmd parser fix, CFL non-priv warning
       - CI spotted deadlock fix
       - EHL port D programming fix
    
      amdgpu:
       - VRAM lost fixes on BACO for CI/VI
       - navi14 DC fixes
       - misc SR-IOV, gfx10 fixes
       - XGMI fixes for arcturus
       - SRIOV fixes
    
      amdkfd:
       - KFD on ppc64le enabled
       - page table optimisations
    
      radeon:
       - fix for r1xx/2xx register checker.
    
      tegra:
       - displayport regression fixes
       - DMA API regression fixes
    
      mgag200:
       - fix devices that can't scanout except at 0 addr
    
      omap:
       - fix dma_addr refcounting"
    
    * tag 'drm-next-2019-12-06' of git://anongit.freedesktop.org/drm/drm: (100 commits)
      drm/dp_mst: Correct the bug in drm_dp_update_payload_part1()
      drm/omap: fix dma_addr refcounting
      drm/tegra: Run hub cleanup on ->remove()
      drm/tegra: sor: Make the +5V HDMI supply optional
      drm/tegra: Silence expected errors on IOMMU attach
      drm/tegra: vic: Export module device table
      drm/tegra: sor: Implement system suspend/resume
      drm/tegra: Use proper IOVA address for cursor image
      drm/tegra: gem: Remove premature import restrictions
      drm/tegra: gem: Properly pin imported buffers
      drm/tegra: hub: Remove bogus connection mutex check
      ia64: agp: Replace empty define with do while
      agp: Add bridge parameter documentation
      agp: remove unused variable num_segments
      agp: move AGPGART_MINOR to include/linux/miscdevice.h
      agp: remove unused variable size in agp_generic_create_gatt_table
      drm/dp_mst: Fix build on systems with STACKTRACE_SUPPORT=n
      drm/radeon: fix r1xx/r2xx register checker for POT textures
      drm/amdgpu: fix GFX10 missing CSIB set(v3)
      drm/amdgpu: should stop GFX ring in hw_fini
      ...

commit c3bed3b20e40ab44b98ac5f0471a5bd92a802f5a
Merge: 4672c2f2026d 7e124c405172
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 3 13:58:22 2019 -0800

    Merge tag 'pci-v5.5-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Enumeration:
    
       - Warn if a host bridge has no NUMA info (Yunsheng Lin)
    
       - Add PCI_STD_NUM_BARS for the number of standard BARs (Denis
         Efremov)
    
      Resource management:
    
       - Fix boot-time Embedded Controller GPE storm caused by incorrect
         resource assignment after ACPI Bus Check Notification (Mika
         Westerberg)
    
       - Protect pci_reassign_bridge_resources() against concurrent
         addition/removal (Benjamin Herrenschmidt)
    
       - Fix bridge dma_ranges resource list cleanup (Rob Herring)
    
       - Add "pci=hpmmiosize" and "pci=hpmmioprefsize" parameters to control
         the MMIO and prefetchable MMIO window sizes of hotplug bridges
         independently (Nicholas Johnson)
    
       - Fix MMIO/MMIO_PREF window assignment that assigned more space than
         desired (Nicholas Johnson)
    
       - Only enforce bus numbers from bridge EA if the bridge has EA
         devices downstream (Subbaraya Sundeep)
    
       - Consolidate DT "dma-ranges" parsing and convert all host drivers to
         use shared parsing (Rob Herring)
    
      Error reporting:
    
       - Restore AER capability after resume (Mayurkumar Patel)
    
       - Add PoisonTLPBlocked AER counter (Rajat Jain)
    
       - Use for_each_set_bit() to simplify AER code (Andy Shevchenko)
    
       - Fix AER kernel-doc (Andy Shevchenko)
    
       - Add "pcie_ports=dpc-native" parameter to allow native use of DPC
         even if platform didn't grant control over AER (Olof Johansson)
    
      Hotplug:
    
       - Avoid returning prematurely from sysfs requests to enable or
         disable a PCIe hotplug slot (Lukas Wunner)
    
       - Don't disable interrupts twice when suspending hotplug ports (Mika
         Westerberg)
    
       - Fix deadlocks when PCIe ports are hot-removed while suspended (Mika
         Westerberg)
    
      Power management:
    
       - Remove unnecessary ASPM locking (Bjorn Helgaas)
    
       - Add support for disabling L1 PM Substates (Heiner Kallweit)
    
       - Allow re-enabling Clock PM after it has been disabled (Heiner
         Kallweit)
    
       - Add sysfs attributes for controlling ASPM link states (Heiner
         Kallweit)
    
       - Remove CONFIG_PCIEASPM_DEBUG, including "link_state" and "clk_ctl"
         sysfs files (Heiner Kallweit)
    
       - Avoid AMD FCH XHCI USB PME# from D0 defect that prevents wakeup on
         USB 2.0 or 1.1 connect events (Kai-Heng Feng)
    
       - Move power state check out of pci_msi_supported() (Bjorn Helgaas)
    
       - Fix incorrect MSI-X masking on resume and revert related nvme quirk
         for Kingston NVME SSD running FW E8FK11.T (Jian-Hong Pan)
    
       - Always return devices to D0 when thawing to fix hibernation with
         drivers like mlx4 that used legacy power management (previously we
         only did it for drivers with new power management ops) (Dexuan Cui)
    
       - Clear PCIe PME Status even for legacy power management (Bjorn
         Helgaas)
    
       - Fix PCI PM documentation errors (Bjorn Helgaas)
    
       - Use dev_printk() for more power management messages (Bjorn Helgaas)
    
       - Apply D2 delay as milliseconds, not microseconds (Bjorn Helgaas)
    
       - Convert xen-platform from legacy to generic power management (Bjorn
         Helgaas)
    
       - Removed unused .resume_early() and .suspend_late() legacy power
         management hooks (Bjorn Helgaas)
    
       - Rearrange power management code for clarity (Rafael J. Wysocki)
    
       - Decode power states more clearly ("4" or "D4" really refers to
         "D3cold") (Bjorn Helgaas)
    
       - Notice when reading PM Control register returns an error (~0)
         instead of interpreting it as being in D3hot (Bjorn Helgaas)
    
       - Add missing link delays required by the PCIe spec (Mika Westerberg)
    
      Virtualization:
    
       - Move pci_prg_resp_pasid_required() to CONFIG_PCI_PRI (Bjorn
         Helgaas)
    
       - Allow VFs to use PRI (the PF PRI is shared by the VFs, but the code
         previously didn't recognize that) (Kuppuswamy Sathyanarayanan)
    
       - Allow VFs to use PASID (the PF PASID capability is shared by the
         VFs, but the code previously didn't recognize that) (Kuppuswamy
         Sathyanarayanan)
    
       - Disconnect PF and VF ATS enablement, since ATS in PFs and
         associated VFs can be enabled independently (Kuppuswamy
         Sathyanarayanan)
    
       - Cache PRI and PASID capability offsets (Kuppuswamy Sathyanarayanan)
    
       - Cache the PRI PRG Response PASID Required bit (Bjorn Helgaas)
    
       - Consolidate ATS declarations in linux/pci-ats.h (Krzysztof
         Wilczynski)
    
       - Remove unused PRI and PASID stubs (Bjorn Helgaas)
    
       - Removed unnecessary EXPORT_SYMBOL_GPL() from ATS, PRI, and PASID
         interfaces that are only used by built-in IOMMU drivers (Bjorn
         Helgaas)
    
       - Hide PRI and PASID state restoration functions used only inside the
         PCI core (Bjorn Helgaas)
    
       - Add a DMA alias quirk for the Intel VCA NTB (Slawomir Pawlowski)
    
       - Serialize sysfs sriov_numvfs reads vs writes (Pierre Crégut)
    
       - Update Cavium ACS quirk for ThunderX2 and ThunderX3 (George
         Cherian)
    
       - Fix the UPDCR register address in the Intel ACS quirk (Steffen
         Liebergeld)
    
       - Unify ACS quirk implementations (Bjorn Helgaas)
    
      Amlogic Meson host bridge driver:
    
       - Fix meson PERST# GPIO polarity problem (Remi Pommarel)
    
       - Add DT bindings for Amlogic Meson G12A (Neil Armstrong)
    
       - Fix meson clock names to match DT bindings (Neil Armstrong)
    
       - Add meson support for Amlogic G12A SoC with separate shared PHY
         (Neil Armstrong)
    
       - Add meson extended PCIe PHY functions for Amlogic G12A USB3+PCIe
         combo PHY (Neil Armstrong)
    
       - Add arm64 DT for Amlogic G12A PCIe controller node (Neil Armstrong)
    
       - Add commented-out description of VIM3 USB3/PCIe mux in arm64 DT
         (Neil Armstrong)
    
      Broadcom iProc host bridge driver:
    
       - Invalidate iProc PAXB address mapping before programming it
         (Abhishek Shah)
    
       - Fix iproc-msi and mvebu __iomem annotations (Ben Dooks)
    
      Cadence host bridge driver:
    
       - Refactor Cadence PCIe host controller to use as a library for both
         host and endpoint (Tom Joseph)
    
      Freescale Layerscape host bridge driver:
    
       - Add layerscape LS1028a support (Xiaowei Bao)
    
      Intel VMD host bridge driver:
    
       - Add VMD bus 224-255 restriction decode (Jon Derrick)
    
       - Add VMD 8086:9A0B device ID (Jon Derrick)
    
       - Remove Keith from VMD maintainer list (Keith Busch)
    
      Marvell ARMADA 3700 / Aardvark host bridge driver:
    
       - Use LTSSM state to build link training flag since Aardvark doesn't
         implement the Link Training bit (Remi Pommarel)
    
       - Delay before training Aardvark link in case PERST# was asserted
         before the driver probe (Remi Pommarel)
    
       - Fix Aardvark issues with Root Control reads and writes (Remi
         Pommarel)
    
       - Don't rely on jiffies in Aardvark config access path since
         interrupts may be disabled (Remi Pommarel)
    
       - Fix Aardvark big-endian support (Grzegorz Jaszczyk)
    
      Marvell ARMADA 370 / XP host bridge driver:
    
       - Make mvebu_pci_bridge_emul_ops static (Ben Dooks)
    
      Microsoft Hyper-V host bridge driver:
    
       - Add hibernation support for Hyper-V virtual PCI devices (Dexuan
         Cui)
    
       - Track Hyper-V pci_protocol_version per-hbus, not globally (Dexuan
         Cui)
    
       - Avoid kmemleak false positive on hv hbus buffer (Dexuan Cui)
    
      Mobiveil host bridge driver:
    
       - Change mobiveil csr_read()/write() function names that conflict
         with riscv arch functions (Kefeng Wang)
    
      NVIDIA Tegra host bridge driver:
    
       - Fix Tegra CLKREQ dependency programming (Vidya Sagar)
    
      Renesas R-Car host bridge driver:
    
       - Remove unnecessary header include from rcar (Andrew Murray)
    
       - Tighten register index checking for rcar inbound range programming
         (Marek Vasut)
    
       - Fix rcar inbound range alignment calculation to improve packing of
         multiple entries (Marek Vasut)
    
       - Update rcar MACCTLR setting to match documentation (Yoshihiro
         Shimoda)
    
       - Clear bit 0 of MACCTLR before PCIETCTLR.CFINIT per manual
         (Yoshihiro Shimoda)
    
       - Add Marek Vasut and Yoshihiro Shimoda as R-Car maintainers (Simon
         Horman)
    
      Rockchip host bridge driver:
    
       - Make rockchip 0V9 and 1V8 power regulators non-optional (Robin
         Murphy)
    
      Socionext UniPhier host bridge driver:
    
       - Set uniphier to host (RC) mode always (Kunihiko Hayashi)
    
      Endpoint drivers:
    
       - Fix endpoint driver sign extension problem when shifting page
         number to phys_addr_t (Alan Mikhak)
    
      Misc:
    
       - Add NumaChip SPDX header (Krzysztof Wilczynski)
    
       - Replace EXTRA_CFLAGS with ccflags-y (Krzysztof Wilczynski)
    
       - Remove unused includes (Krzysztof Wilczynski)
    
       - Removed unused sysfs attribute groups (Ben Dooks)
    
       - Remove PTM and ASPM dependencies on PCIEPORTBUS (Bjorn Helgaas)
    
       - Add PCIe Link Control 2 register field definitions to replace magic
         numbers in AMDGPU and Radeon CIK/SI (Bjorn Helgaas)
    
       - Fix incorrect Link Control 2 Transmit Margin usage in AMDGPU and
         Radeon CIK/SI PCIe Gen3 link training (Bjorn Helgaas)
    
       - Use pcie_capability_read_word() instead of pci_read_config_word()
         in AMDGPU and Radeon CIK/SI (Frederick Lawler)
    
       - Remove unused pci_irq_get_node() Greg Kroah-Hartman)
    
       - Make asm/msi.h mandatory and simplify PCI_MSI_IRQ_DOMAIN Kconfig
         (Palmer Dabbelt, Michal Simek)
    
       - Read all 64 bits of Switchtec part_event_bitmap (Logan Gunthorpe)
    
       - Fix erroneous intel-iommu dependency on CONFIG_AMD_IOMMU (Bjorn
         Helgaas)
    
       - Fix bridge emulation big-endian support (Grzegorz Jaszczyk)
    
       - Fix dwc find_next_bit() usage (Niklas Cassel)
    
       - Fix pcitest.c fd leak (Hewenliang)
    
       - Fix typos and comments (Bjorn Helgaas)
    
       - Fix Kconfig whitespace errors (Krzysztof Kozlowski)"
    
    * tag 'pci-v5.5-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (160 commits)
      PCI: Remove PCI_MSI_IRQ_DOMAIN architecture whitelist
      asm-generic: Make msi.h a mandatory include/asm header
      Revert "nvme: Add quirk for Kingston NVME SSD running FW E8FK11.T"
      PCI/MSI: Fix incorrect MSI-X masking on resume
      PCI/MSI: Move power state check out of pci_msi_supported()
      PCI/MSI: Remove unused pci_irq_get_node()
      PCI: hv: Avoid a kmemleak false positive caused by the hbus buffer
      PCI: hv: Change pci_protocol_version to per-hbus
      PCI: hv: Add hibernation support
      PCI: hv: Reorganize the code in preparation of hibernation
      MAINTAINERS: Remove Keith from VMD maintainer
      PCI/ASPM: Remove PCIEASPM_DEBUG Kconfig option and related code
      PCI/ASPM: Add sysfs attributes for controlling ASPM link states
      PCI: Fix indentation
      drm/radeon: Prefer pcie_capability_read_word()
      drm/radeon: Replace numbers with PCI_EXP_LNKCTL2 definitions
      drm/radeon: Correct Transmit Margin masks
      drm/amdgpu: Prefer pcie_capability_read_word()
      PCI: uniphier: Set mode register to host mode
      drm/amdgpu: Replace numbers with PCI_EXP_LNKCTL2 definitions
      ...

commit 5149f08275de88ed6aade660e6ec5620962fa7a6
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Nov 25 11:11:18 2019 -0500

    drm/amdgpu: flag vram lost on baco reset for VI/CIK
    
    VI/CIK BACO was inflight when this fix landed for SOC15/NV.
    Add the fix to VI/CIK as well.
    
    Acked-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 968bc706b94d..1dfe4a1337cf 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1363,10 +1363,13 @@ static int cik_asic_reset(struct amdgpu_device *adev)
 {
 	int r;
 
-	if (cik_asic_reset_method(adev) == AMD_RESET_METHOD_BACO)
+	if (cik_asic_reset_method(adev) == AMD_RESET_METHOD_BACO) {
+		if (!adev->in_suspend)
+			amdgpu_inc_vram_lost(adev);
 		r = smu7_asic_baco_reset(adev);
-	else
+	} else {
 		r = cik_asic_pci_config_reset(adev);
+	}
 
 	return r;
 }

commit dea8b900293df57b6545bc195b50bbb649fe9741
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Nov 25 11:11:18 2019 -0500

    drm/amdgpu: flag vram lost on baco reset for VI/CIK
    
    VI/CIK BACO was inflight when this fix landed for SOC15/NV.
    Add the fix to VI/CIK as well.
    
    Acked-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 2d64d270725d..b22a10b2d201 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1346,10 +1346,13 @@ static int cik_asic_reset(struct amdgpu_device *adev)
 {
 	int r;
 
-	if (cik_asic_reset_method(adev) == AMD_RESET_METHOD_BACO)
+	if (cik_asic_reset_method(adev) == AMD_RESET_METHOD_BACO) {
+		if (!adev->in_suspend)
+			amdgpu_inc_vram_lost(adev);
 		r = smu7_asic_baco_reset(adev);
-	else
+	} else {
 		r = cik_asic_pci_config_reset(adev);
+	}
 
 	return r;
 }

commit 88027c89ea146e32485251f1c2dddcde43c8d04e
Author: Frederick Lawler <fred@fredlawl.com>
Date:   Sun Nov 17 18:35:13 2019 -0600

    drm/amdgpu: Prefer pcie_capability_read_word()
    
    Commit 8c0d3a02c130 ("PCI: Add accessors for PCI Express Capability")
    added accessors for the PCI Express Capability so that drivers didn't
    need to be aware of differences between v1 and v2 of the PCI
    Express Capability.
    
    Replace pci_read_config_word() and pci_write_config_word() calls with
    pcie_capability_read_word() and pcie_capability_write_word().
    
    [bhelgaas: fix a couple remaining instances in cik.c]
    Link: https://lore.kernel.org/r/20191118003513.10852-1-fred@fredlawl.com
    Signed-off-by: Frederick Lawler <fred@fredlawl.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 3067bb874032..38b06ae6357a 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1384,7 +1384,6 @@ static int cik_set_vce_clocks(struct amdgpu_device *adev, u32 evclk, u32 ecclk)
 static void cik_pcie_gen3_enable(struct amdgpu_device *adev)
 {
 	struct pci_dev *root = adev->pdev->bus->self;
-	int bridge_pos, gpu_pos;
 	u32 speed_cntl, current_data_rate;
 	int i;
 	u16 tmp16;
@@ -1419,12 +1418,7 @@ static void cik_pcie_gen3_enable(struct amdgpu_device *adev)
 		DRM_INFO("enabling PCIE gen 2 link speeds, disable with amdgpu.pcie_gen2=0\n");
 	}
 
-	bridge_pos = pci_pcie_cap(root);
-	if (!bridge_pos)
-		return;
-
-	gpu_pos = pci_pcie_cap(adev->pdev);
-	if (!gpu_pos)
+	if (!pci_is_pcie(root) || !pci_is_pcie(adev->pdev))
 		return;
 
 	if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN3) {
@@ -1434,14 +1428,17 @@ static void cik_pcie_gen3_enable(struct amdgpu_device *adev)
 			u16 bridge_cfg2, gpu_cfg2;
 			u32 max_lw, current_lw, tmp;
 
-			pci_read_config_word(root, bridge_pos + PCI_EXP_LNKCTL, &bridge_cfg);
-			pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL, &gpu_cfg);
+			pcie_capability_read_word(root, PCI_EXP_LNKCTL,
+						  &bridge_cfg);
+			pcie_capability_read_word(adev->pdev, PCI_EXP_LNKCTL,
+						  &gpu_cfg);
 
 			tmp16 = bridge_cfg | PCI_EXP_LNKCTL_HAWD;
-			pci_write_config_word(root, bridge_pos + PCI_EXP_LNKCTL, tmp16);
+			pcie_capability_write_word(root, PCI_EXP_LNKCTL, tmp16);
 
 			tmp16 = gpu_cfg | PCI_EXP_LNKCTL_HAWD;
-			pci_write_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL, tmp16);
+			pcie_capability_write_word(adev->pdev, PCI_EXP_LNKCTL,
+						   tmp16);
 
 			tmp = RREG32_PCIE(ixPCIE_LC_STATUS1);
 			max_lw = (tmp & PCIE_LC_STATUS1__LC_DETECTED_LINK_WIDTH_MASK) >>
@@ -1465,15 +1462,23 @@ static void cik_pcie_gen3_enable(struct amdgpu_device *adev)
 
 			for (i = 0; i < 10; i++) {
 				/* check status */
-				pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_DEVSTA, &tmp16);
+				pcie_capability_read_word(adev->pdev,
+							  PCI_EXP_DEVSTA,
+							  &tmp16);
 				if (tmp16 & PCI_EXP_DEVSTA_TRPND)
 					break;
 
-				pci_read_config_word(root, bridge_pos + PCI_EXP_LNKCTL, &bridge_cfg);
-				pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL, &gpu_cfg);
+				pcie_capability_read_word(root, PCI_EXP_LNKCTL,
+							  &bridge_cfg);
+				pcie_capability_read_word(adev->pdev,
+							  PCI_EXP_LNKCTL,
+							  &gpu_cfg);
 
-				pci_read_config_word(root, bridge_pos + PCI_EXP_LNKCTL2, &bridge_cfg2);
-				pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL2, &gpu_cfg2);
+				pcie_capability_read_word(root, PCI_EXP_LNKCTL2,
+							  &bridge_cfg2);
+				pcie_capability_read_word(adev->pdev,
+							  PCI_EXP_LNKCTL2,
+							  &gpu_cfg2);
 
 				tmp = RREG32_PCIE(ixPCIE_LC_CNTL4);
 				tmp |= PCIE_LC_CNTL4__LC_SET_QUIESCE_MASK;
@@ -1486,32 +1491,45 @@ static void cik_pcie_gen3_enable(struct amdgpu_device *adev)
 				msleep(100);
 
 				/* linkctl */
-				pci_read_config_word(root, bridge_pos + PCI_EXP_LNKCTL, &tmp16);
+				pcie_capability_read_word(root, PCI_EXP_LNKCTL,
+							  &tmp16);
 				tmp16 &= ~PCI_EXP_LNKCTL_HAWD;
 				tmp16 |= (bridge_cfg & PCI_EXP_LNKCTL_HAWD);
-				pci_write_config_word(root, bridge_pos + PCI_EXP_LNKCTL, tmp16);
+				pcie_capability_write_word(root, PCI_EXP_LNKCTL,
+							   tmp16);
 
-				pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL, &tmp16);
+				pcie_capability_read_word(adev->pdev,
+							  PCI_EXP_LNKCTL,
+							  &tmp16);
 				tmp16 &= ~PCI_EXP_LNKCTL_HAWD;
 				tmp16 |= (gpu_cfg & PCI_EXP_LNKCTL_HAWD);
-				pci_write_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL, tmp16);
+				pcie_capability_write_word(adev->pdev,
+							   PCI_EXP_LNKCTL,
+							   tmp16);
 
 				/* linkctl2 */
-				pci_read_config_word(root, bridge_pos + PCI_EXP_LNKCTL2, &tmp16);
+				pcie_capability_read_word(root, PCI_EXP_LNKCTL2,
+							  &tmp16);
 				tmp16 &= ~(PCI_EXP_LNKCTL2_ENTER_COMP |
 					   PCI_EXP_LNKCTL2_TX_MARGIN);
 				tmp16 |= (bridge_cfg2 &
 					  (PCI_EXP_LNKCTL2_ENTER_COMP |
 					   PCI_EXP_LNKCTL2_TX_MARGIN));
-				pci_write_config_word(root, bridge_pos + PCI_EXP_LNKCTL2, tmp16);
+				pcie_capability_write_word(root,
+							   PCI_EXP_LNKCTL2,
+							   tmp16);
 
-				pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL2, &tmp16);
+				pcie_capability_read_word(adev->pdev,
+							  PCI_EXP_LNKCTL2,
+							  &tmp16);
 				tmp16 &= ~(PCI_EXP_LNKCTL2_ENTER_COMP |
 					   PCI_EXP_LNKCTL2_TX_MARGIN);
 				tmp16 |= (gpu_cfg2 &
 					  (PCI_EXP_LNKCTL2_ENTER_COMP |
 					   PCI_EXP_LNKCTL2_TX_MARGIN));
-				pci_write_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL2, tmp16);
+				pcie_capability_write_word(adev->pdev,
+							   PCI_EXP_LNKCTL2,
+							   tmp16);
 
 				tmp = RREG32_PCIE(ixPCIE_LC_CNTL4);
 				tmp &= ~PCIE_LC_CNTL4__LC_SET_QUIESCE_MASK;
@@ -1526,15 +1544,16 @@ static void cik_pcie_gen3_enable(struct amdgpu_device *adev)
 	speed_cntl &= ~PCIE_LC_SPEED_CNTL__LC_FORCE_DIS_SW_SPEED_CHANGE_MASK;
 	WREG32_PCIE(ixPCIE_LC_SPEED_CNTL, speed_cntl);
 
-	pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL2, &tmp16);
+	pcie_capability_read_word(adev->pdev, PCI_EXP_LNKCTL2, &tmp16);
 	tmp16 &= ~PCI_EXP_LNKCTL2_TLS;
+
 	if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN3)
 		tmp16 |= PCI_EXP_LNKCTL2_TLS_8_0GT; /* gen3 */
 	else if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN2)
 		tmp16 |= PCI_EXP_LNKCTL2_TLS_5_0GT; /* gen2 */
 	else
 		tmp16 |= PCI_EXP_LNKCTL2_TLS_2_5GT; /* gen1 */
-	pci_write_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL2, tmp16);
+	pcie_capability_write_word(adev->pdev, PCI_EXP_LNKCTL2, tmp16);
 
 	speed_cntl = RREG32_PCIE(ixPCIE_LC_SPEED_CNTL);
 	speed_cntl |= PCIE_LC_SPEED_CNTL__LC_INITIATE_LINK_SPEED_CHANGE_MASK;

commit 35e768e296729ac96a8c33b7810b6cb1673ae961
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 21 07:23:41 2019 -0600

    drm/amdgpu: Replace numbers with PCI_EXP_LNKCTL2 definitions
    
    Replace hard-coded magic numbers with the descriptive PCI_EXP_LNKCTL2
    definitions.  No functional change intended.
    
    Link: https://lore.kernel.org/r/20191112173503.176611-4-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 13a5696d2a6a..3067bb874032 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1498,13 +1498,19 @@ static void cik_pcie_gen3_enable(struct amdgpu_device *adev)
 
 				/* linkctl2 */
 				pci_read_config_word(root, bridge_pos + PCI_EXP_LNKCTL2, &tmp16);
-				tmp16 &= ~((1 << 4) | (7 << 7));
-				tmp16 |= (bridge_cfg2 & ((1 << 4) | (7 << 7)));
+				tmp16 &= ~(PCI_EXP_LNKCTL2_ENTER_COMP |
+					   PCI_EXP_LNKCTL2_TX_MARGIN);
+				tmp16 |= (bridge_cfg2 &
+					  (PCI_EXP_LNKCTL2_ENTER_COMP |
+					   PCI_EXP_LNKCTL2_TX_MARGIN));
 				pci_write_config_word(root, bridge_pos + PCI_EXP_LNKCTL2, tmp16);
 
 				pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL2, &tmp16);
-				tmp16 &= ~((1 << 4) | (7 << 7));
-				tmp16 |= (gpu_cfg2 & ((1 << 4) | (7 << 7)));
+				tmp16 &= ~(PCI_EXP_LNKCTL2_ENTER_COMP |
+					   PCI_EXP_LNKCTL2_TX_MARGIN);
+				tmp16 |= (gpu_cfg2 &
+					  (PCI_EXP_LNKCTL2_ENTER_COMP |
+					   PCI_EXP_LNKCTL2_TX_MARGIN));
 				pci_write_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL2, tmp16);
 
 				tmp = RREG32_PCIE(ixPCIE_LC_CNTL4);
@@ -1521,13 +1527,13 @@ static void cik_pcie_gen3_enable(struct amdgpu_device *adev)
 	WREG32_PCIE(ixPCIE_LC_SPEED_CNTL, speed_cntl);
 
 	pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL2, &tmp16);
-	tmp16 &= ~0xf;
+	tmp16 &= ~PCI_EXP_LNKCTL2_TLS;
 	if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN3)
-		tmp16 |= 3; /* gen3 */
+		tmp16 |= PCI_EXP_LNKCTL2_TLS_8_0GT; /* gen3 */
 	else if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN2)
-		tmp16 |= 2; /* gen2 */
+		tmp16 |= PCI_EXP_LNKCTL2_TLS_5_0GT; /* gen2 */
 	else
-		tmp16 |= 1; /* gen1 */
+		tmp16 |= PCI_EXP_LNKCTL2_TLS_2_5GT; /* gen1 */
 	pci_write_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL2, tmp16);
 
 	speed_cntl = RREG32_PCIE(ixPCIE_LC_SPEED_CNTL);

commit 19d7a95a8ba66b198f759cf610cc935ce9840d5b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Nov 20 17:52:48 2019 -0600

    drm/amdgpu: Correct Transmit Margin masks
    
    Previously we masked PCIe Link Control 2 register values with "7 << 9",
    which was apparently intended to be the Transmit Margin field, but instead
    was the high order bit of Transmit Margin, the Enter Modified Compliance
    bit, and the Compliance SOS bit.
    
    Correct the mask to "7 << 7", which is the Transmit Margin field.
    
    Link: https://lore.kernel.org/r/20191112173503.176611-3-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index b81bb414fcb3..13a5696d2a6a 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1498,13 +1498,13 @@ static void cik_pcie_gen3_enable(struct amdgpu_device *adev)
 
 				/* linkctl2 */
 				pci_read_config_word(root, bridge_pos + PCI_EXP_LNKCTL2, &tmp16);
-				tmp16 &= ~((1 << 4) | (7 << 9));
-				tmp16 |= (bridge_cfg2 & ((1 << 4) | (7 << 9)));
+				tmp16 &= ~((1 << 4) | (7 << 7));
+				tmp16 |= (bridge_cfg2 & ((1 << 4) | (7 << 7)));
 				pci_write_config_word(root, bridge_pos + PCI_EXP_LNKCTL2, tmp16);
 
 				pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL2, &tmp16);
-				tmp16 &= ~((1 << 4) | (7 << 9));
-				tmp16 |= (gpu_cfg2 & ((1 << 4) | (7 << 9)));
+				tmp16 &= ~((1 << 4) | (7 << 7));
+				tmp16 |= (gpu_cfg2 & ((1 << 4) | (7 << 7)));
 				pci_write_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL2, tmp16);
 
 				tmp = RREG32_PCIE(ixPCIE_LC_CNTL4);

commit 0d0c07ee0794ed4a0b14a334d39a692df3e984e5
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Oct 4 10:16:15 2019 -0500

    drm/amdgpu: add supports_baco callback for CIK asics.
    
    BACO - Bus Active, Chip Off
    
    Check the BACO capabilities from the powerplay table.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 2d64d270725d..968bc706b94d 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1310,6 +1310,23 @@ static int cik_asic_pci_config_reset(struct amdgpu_device *adev)
 	return r;
 }
 
+static bool cik_asic_supports_baco(struct amdgpu_device *adev)
+{
+	bool baco_support;
+
+	switch (adev->asic_type) {
+	case CHIP_BONAIRE:
+	case CHIP_HAWAII:
+		smu7_asic_get_baco_capability(adev, &baco_support);
+		break;
+	default:
+		baco_support = false;
+		break;
+	}
+
+	return baco_support;
+}
+
 static enum amd_reset_method
 cik_asic_reset_method(struct amdgpu_device *adev)
 {
@@ -1899,6 +1916,7 @@ static const struct amdgpu_asic_funcs cik_asic_funcs =
 	.get_pcie_usage = &cik_get_pcie_usage,
 	.need_reset_on_init = &cik_need_reset_on_init,
 	.get_pcie_replay_count = &cik_get_pcie_replay_count,
+	.supports_baco = &cik_asic_supports_baco,
 };
 
 static int cik_common_early_init(void *handle)

commit 664fe85a2d9283c30044d821c708860999c52f28
Author: Marek Olšák <marek.olsak@amd.com>
Date:   Tue Oct 22 17:22:38 2019 -0400

    drm/amdgpu: Allow reading more status registers on si/cik
    
    Allow userspace to read the same status registers for every family.
    Based on commit c7890fea, added any of these registers if defined in
    the include files of each architecture.
    
    Signed-off-by: Marek Olšák <marek.olsak@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index fc8b34480f66..2d64d270725d 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -966,6 +966,25 @@ static bool cik_read_bios_from_rom(struct amdgpu_device *adev,
 
 static const struct amdgpu_allowed_register_entry cik_allowed_read_registers[] = {
 	{mmGRBM_STATUS},
+	{mmGRBM_STATUS2},
+	{mmGRBM_STATUS_SE0},
+	{mmGRBM_STATUS_SE1},
+	{mmGRBM_STATUS_SE2},
+	{mmGRBM_STATUS_SE3},
+	{mmSRBM_STATUS},
+	{mmSRBM_STATUS2},
+	{mmSDMA0_STATUS_REG + SDMA0_REGISTER_OFFSET},
+	{mmSDMA0_STATUS_REG + SDMA1_REGISTER_OFFSET},
+	{mmCP_STAT},
+	{mmCP_STALLED_STAT1},
+	{mmCP_STALLED_STAT2},
+	{mmCP_STALLED_STAT3},
+	{mmCP_CPF_BUSY_STAT},
+	{mmCP_CPF_STALLED_STAT1},
+	{mmCP_CPF_STATUS},
+	{mmCP_CPC_BUSY_STAT},
+	{mmCP_CPC_STALLED_STAT1},
+	{mmCP_CPC_STATUS},
 	{mmGB_ADDR_CONFIG},
 	{mmMC_ARB_RAMCFG},
 	{mmGB_TILE_MODE0},

commit 97c002be4113e50ddca424c7ebbfd4840402605f
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Mar 11 18:05:12 2019 -0500

    drm/amdgpu: enable BACO reset for SMU7 based dGPUs (v2)
    
    Use BACO to reset the GPU if supported on SMU7 based
    dGPUs.
    
    v2: don't use baco on CI parts
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index b81bb414fcb3..fc8b34480f66 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1270,15 +1270,15 @@ static int cik_gpu_pci_config_reset(struct amdgpu_device *adev)
 }
 
 /**
- * cik_asic_reset - soft reset GPU
+ * cik_asic_pci_config_reset - soft reset GPU
  *
  * @adev: amdgpu_device pointer
  *
- * Look up which blocks are hung and attempt
- * to reset them.
+ * Use PCI Config method to reset the GPU.
+ *
  * Returns 0 for success.
  */
-static int cik_asic_reset(struct amdgpu_device *adev)
+static int cik_asic_pci_config_reset(struct amdgpu_device *adev)
 {
 	int r;
 
@@ -1294,7 +1294,45 @@ static int cik_asic_reset(struct amdgpu_device *adev)
 static enum amd_reset_method
 cik_asic_reset_method(struct amdgpu_device *adev)
 {
-	return AMD_RESET_METHOD_LEGACY;
+	bool baco_reset;
+
+	switch (adev->asic_type) {
+	case CHIP_BONAIRE:
+	case CHIP_HAWAII:
+		/* disable baco reset until it works */
+		/* smu7_asic_get_baco_capability(adev, &baco_reset); */
+		baco_reset = false;
+		break;
+	default:
+		baco_reset = false;
+		break;
+	}
+
+	if (baco_reset)
+		return AMD_RESET_METHOD_BACO;
+	else
+		return AMD_RESET_METHOD_LEGACY;
+}
+
+/**
+ * cik_asic_reset - soft reset GPU
+ *
+ * @adev: amdgpu_device pointer
+ *
+ * Look up which blocks are hung and attempt
+ * to reset them.
+ * Returns 0 for success.
+ */
+static int cik_asic_reset(struct amdgpu_device *adev)
+{
+	int r;
+
+	if (cik_asic_reset_method(adev) == AMD_RESET_METHOD_BACO)
+		r = smu7_asic_baco_reset(adev);
+	else
+		r = cik_asic_pci_config_reset(adev);
+
+	return r;
 }
 
 static u32 cik_get_config_memsize(struct amdgpu_device *adev)

commit 6d0f50dafed4771121f674aef2db2c13ef526ad0
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jul 23 23:45:39 2019 -0500

    drm/amdgpu: add reset_method asic callback for cik
    
    CIK always uses the legacy pci based reset.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 1ffbc0d3d7a1..b81bb414fcb3 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1291,6 +1291,12 @@ static int cik_asic_reset(struct amdgpu_device *adev)
 	return r;
 }
 
+static enum amd_reset_method
+cik_asic_reset_method(struct amdgpu_device *adev)
+{
+	return AMD_RESET_METHOD_LEGACY;
+}
+
 static u32 cik_get_config_memsize(struct amdgpu_device *adev)
 {
 	return RREG32(mmCONFIG_MEMSIZE);
@@ -1823,6 +1829,7 @@ static const struct amdgpu_asic_funcs cik_asic_funcs =
 	.read_bios_from_rom = &cik_read_bios_from_rom,
 	.read_register = &cik_read_register,
 	.reset = &cik_asic_reset,
+	.reset_method = &cik_asic_reset_method,
 	.set_vga_state = &cik_vga_set_state,
 	.get_xclk = &cik_get_xclk,
 	.set_uvd_clocks = &cik_set_uvd_clocks,

commit 2454fcea338ad821a39d471bc7db5a58ba41b742
Merge: 561564bea324 51e857af9f3f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jun 14 11:31:13 2019 +0200

    Merge tag 'drm-misc-next-2019-06-14' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for v5.3:
    
    UAPI Changes:
    
    Cross-subsystem Changes:
    - Add code to signal all dma-fences when freed with pending signals.
    - Annotate reservation object access in CONFIG_DEBUG_MUTEXES
    
    Core Changes:
    - Assorted documentation fixes.
    - Use irqsave/restore spinlock to add crc entry.
    - Move code around to drm_client, for internal modeset clients.
    - Make drm_crtc.h and drm_debugfs.h self-contained.
    - Remove drm_fb_helper_connector.
    - Add bootsplash to todo.
    - Fix lock ordering in pan_display_legacy.
    - Support pinning buffers to current location in gem-vram.
    - Remove the now unused locking functions from gem-vram.
    - Remove the now unused kmap-object argument from vram helpers.
    - Stop checking return value of debugfs_create.
    - Add atomic encoder enable/disable helpers.
    - pass drm_atomic_state to atomic connector check.
    - Add atomic support for bridge enable/disable.
    - Add self refresh helpers to core.
    
    Driver Changes:
    - Add extra delay to make MTP SDM845 work.
    - Small fixes to virtio, vkms, sii902x, sii9234, ast, mcde, analogix, rockchip.
    - Add zpos and ?BGR8888 support to meson.
    - More removals of drm_os_linux and drmP headers for amd, radeon, sti, r128, r128, savage, sis.
    - Allow synopsis to unwedge the i2c hdmi bus.
    - Add orientation quirks for GPD panels.
    - Edid cleanups and fixing handling for edid < 1.2.
    - Add runtime pm to stm.
    - Handle s/r in dw-hdmi.
    - Add hooks for power on/off to dsi for stm.
    - Remove virtio dirty tracking code, done in drm core.
    - Rework BO handling in ast and mgag200.
    
    Tiny conflict in drivers/gpu/drm/amd/display/dc/clk_mgr/clk_mgr.c,
    needed #include <linux/slab.h> to make it compile.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    From: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/0e01de30-9797-853c-732f-4a5bd6e61445@linux.intel.com

commit 47b757fba2a382d5f818d1884fe87c4014818088
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:57 2019 +0200

    drm/amd: drop use of drmP.h in remaining files
    
    With this commit drm/amd/ has no longer any uses of
    the deprecated drmP.h header file.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-11-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 07c1f239e9c3..a316ce8eec98 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -24,7 +24,8 @@
 #include <linux/firmware.h>
 #include <linux/slab.h>
 #include <linux/module.h>
-#include <drm/drmP.h>
+#include <linux/pci.h>
+
 #include "amdgpu.h"
 #include "amdgpu_atombios.h"
 #include "amdgpu_ih.h"

commit dcea6e65d41f4696571d5d391d3a760cfbb8ee00
Author: Kent Russell <kent.russell@amd.com>
Date:   Tue Apr 30 06:43:33 2019 -0400

    drm/amdgpu: Add PCIe replay count sysfs file
    
    Add a sysfs file for reporting the number of PCIe replays (NAKs). This
    returns the sum of NAKs received and NAKs generated
    
    Signed-off-by: Kent Russell <kent.russell@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 07c1f239e9c3..3a4f20766a39 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1804,6 +1804,18 @@ static bool cik_need_reset_on_init(struct amdgpu_device *adev)
 	return false;
 }
 
+static uint64_t cik_get_pcie_replay_count(struct amdgpu_device *adev)
+{
+	uint64_t nak_r, nak_g;
+
+	/* Get the number of NAKs received and generated */
+	nak_r = RREG32_PCIE(ixPCIE_RX_NUM_NAK);
+	nak_g = RREG32_PCIE(ixPCIE_RX_NUM_NAK_GENERATED);
+
+	/* Add the total number of NAKs, i.e the number of replays */
+	return (nak_r + nak_g);
+}
+
 static const struct amdgpu_asic_funcs cik_asic_funcs =
 {
 	.read_disabled_bios = &cik_read_disabled_bios,
@@ -1821,6 +1833,7 @@ static const struct amdgpu_asic_funcs cik_asic_funcs =
 	.init_doorbell_index = &legacy_doorbell_index_init,
 	.get_pcie_usage = &cik_get_pcie_usage,
 	.need_reset_on_init = &cik_need_reset_on_init,
+	.get_pcie_replay_count = &cik_get_pcie_replay_count,
 };
 
 static int cik_common_early_init(void *handle)

commit bc4b539e38508839a6c85d5c5ff52d32f6471fab
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Jan 16 11:55:04 2019 -0500

    drm/amdgpu: remove old CI DPM implementation
    
    The power smu7 powerplay code is much more robust and has
    been the default for a while now.  Remove the old code.
    
    Acked-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index b1b7abed7dab..07c1f239e9c3 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -2070,10 +2070,7 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
 		amdgpu_device_ip_block_add(adev, &gfx_v7_2_ip_block);
 		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
-		if (amdgpu_dpm == -1)
-			amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
-		else
-			amdgpu_device_ip_block_add(adev, &ci_smu_ip_block);
+		amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
 		if (adev->enable_virtual_display)
 			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
 #if defined(CONFIG_DRM_AMD_DC)
@@ -2091,10 +2088,7 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
 		amdgpu_device_ip_block_add(adev, &gfx_v7_3_ip_block);
 		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
-		if (amdgpu_dpm == -1)
-			amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
-		else
-			amdgpu_device_ip_block_add(adev, &ci_smu_ip_block);
+		amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
 		if (adev->enable_virtual_display)
 			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
 #if defined(CONFIG_DRM_AMD_DC)

commit 3fcc10d73d611e929fec00ed58d8b048df5c25bd
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Oct 31 23:58:56 2018 -0500

    drm/amdgpu/cik: add need_reset_on_init asic callback for CIK (v2)
    
    CIK chips require a reset if the driver was previously loaded
    because the SMU can only be loaded once between each reset.
    
    v2: rebase
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Felix Kuehling <Felix.Kuehling@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 6277de51483f..b1b7abed7dab 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1787,6 +1787,23 @@ static void cik_get_pcie_usage(struct amdgpu_device *adev, uint64_t *count0,
 	*count1 = RREG32_PCIE(ixPCIE_PERF_COUNT1_TXCLK) | (cnt1_of << 32);
 }
 
+static bool cik_need_reset_on_init(struct amdgpu_device *adev)
+{
+	u32 clock_cntl, pc;
+
+	if (adev->flags & AMD_IS_APU)
+		return false;
+
+	/* check if the SMC is already running */
+	clock_cntl = RREG32_SMC(ixSMC_SYSCON_CLOCK_CNTL_0);
+	pc = RREG32_SMC(ixSMC_PC_C);
+	if ((0 == REG_GET_FIELD(clock_cntl, SMC_SYSCON_CLOCK_CNTL_0, ck_disable)) &&
+	    (0x20100 <= pc))
+		return true;
+
+	return false;
+}
+
 static const struct amdgpu_asic_funcs cik_asic_funcs =
 {
 	.read_disabled_bios = &cik_read_disabled_bios,
@@ -1803,6 +1820,7 @@ static const struct amdgpu_asic_funcs cik_asic_funcs =
 	.need_full_reset = &cik_need_full_reset,
 	.init_doorbell_index = &legacy_doorbell_index_init,
 	.get_pcie_usage = &cik_get_pcie_usage,
+	.need_reset_on_init = &cik_need_reset_on_init,
 };
 
 static int cik_common_early_init(void *handle)

commit b45e18acd394954c24943762ada5d8dada75f2b9
Author: Kent Russell <kent.russell@amd.com>
Date:   Thu Jan 3 08:12:39 2019 -0500

    drm/amdgpu: Add sysfs file for PCIe usage v5
    
    Add a sysfs file that reports the number of bytes transmitted and
    received in the last second. This can be used to approximate the PCIe
    bandwidth usage over the last second.
    
    v2: Clarify use of mps as estimation of bandwidth
    v3: Don't make the file on APUs
    v4: Early exit for APUs in the read function, change output to
        display "packets-received packets-sent mps"
    v5: fix missing header for si (Alex)
    
    Signed-off-by: Kent Russell <kent.russell@amd.com>
    Reviewed-by: Felix Kuehling <Felix.Kuehling@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 71c50d8900e3..6277de51483f 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1741,6 +1741,52 @@ static bool cik_need_full_reset(struct amdgpu_device *adev)
 	return true;
 }
 
+static void cik_get_pcie_usage(struct amdgpu_device *adev, uint64_t *count0,
+			       uint64_t *count1)
+{
+	uint32_t perfctr = 0;
+	uint64_t cnt0_of, cnt1_of;
+	int tmp;
+
+	/* This reports 0 on APUs, so return to avoid writing/reading registers
+	 * that may or may not be different from their GPU counterparts
+	 */
+	if (adev->flags & AMD_IS_APU)
+		return;
+
+	/* Set the 2 events that we wish to watch, defined above */
+	/* Reg 40 is # received msgs, Reg 104 is # of posted requests sent */
+	perfctr = REG_SET_FIELD(perfctr, PCIE_PERF_CNTL_TXCLK, EVENT0_SEL, 40);
+	perfctr = REG_SET_FIELD(perfctr, PCIE_PERF_CNTL_TXCLK, EVENT1_SEL, 104);
+
+	/* Write to enable desired perf counters */
+	WREG32_PCIE(ixPCIE_PERF_CNTL_TXCLK, perfctr);
+	/* Zero out and enable the perf counters
+	 * Write 0x5:
+	 * Bit 0 = Start all counters(1)
+	 * Bit 2 = Global counter reset enable(1)
+	 */
+	WREG32_PCIE(ixPCIE_PERF_COUNT_CNTL, 0x00000005);
+
+	msleep(1000);
+
+	/* Load the shadow and disable the perf counters
+	 * Write 0x2:
+	 * Bit 0 = Stop counters(0)
+	 * Bit 1 = Load the shadow counters(1)
+	 */
+	WREG32_PCIE(ixPCIE_PERF_COUNT_CNTL, 0x00000002);
+
+	/* Read register values to get any >32bit overflow */
+	tmp = RREG32_PCIE(ixPCIE_PERF_CNTL_TXCLK);
+	cnt0_of = REG_GET_FIELD(tmp, PCIE_PERF_CNTL_TXCLK, COUNTER0_UPPER);
+	cnt1_of = REG_GET_FIELD(tmp, PCIE_PERF_CNTL_TXCLK, COUNTER1_UPPER);
+
+	/* Get the values and add the overflow */
+	*count0 = RREG32_PCIE(ixPCIE_PERF_COUNT0_TXCLK) | (cnt0_of << 32);
+	*count1 = RREG32_PCIE(ixPCIE_PERF_COUNT1_TXCLK) | (cnt1_of << 32);
+}
+
 static const struct amdgpu_asic_funcs cik_asic_funcs =
 {
 	.read_disabled_bios = &cik_read_disabled_bios,
@@ -1756,6 +1802,7 @@ static const struct amdgpu_asic_funcs cik_asic_funcs =
 	.invalidate_hdp = &cik_invalidate_hdp,
 	.need_full_reset = &cik_need_full_reset,
 	.init_doorbell_index = &legacy_doorbell_index_init,
+	.get_pcie_usage = &cik_get_pcie_usage,
 };
 
 static int cik_common_early_init(void *handle)

commit 4e2c1ac2027d1ad99109b676450db8759779222c
Author: Oak Zeng <ozeng@amd.com>
Date:   Mon Nov 19 09:51:20 2018 -0600

    drm/amdgpu: Doorbell index initialization for ASICs before vega10
    
    Initialize doorbell index for asics vi and cik
    
    v2: Use enum definition instead of hardcoded number
    
    Signed-off-by: Oak Zeng <ozeng@amd.com>
    Suggested-by: Felix Kuehling <Felix.Kuehling@amd.com>
    Suggested-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index f41f5f57e9f3..71c50d8900e3 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1755,6 +1755,7 @@ static const struct amdgpu_asic_funcs cik_asic_funcs =
 	.flush_hdp = &cik_flush_hdp,
 	.invalidate_hdp = &cik_invalidate_hdp,
 	.need_full_reset = &cik_need_full_reset,
+	.init_doorbell_index = &legacy_doorbell_index_init,
 };
 
 static int cik_common_early_init(void *handle)

commit 3089aa2248943e62a875840862c0103b47e8420c
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Sun Sep 30 17:32:36 2018 +0800

    drm/amdgpu: Change SI/CI gfx/sdma/smu init sequence
    
    initialize gfx/sdma before dpm features enabled.
    
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 78ab939ae5d8..f41f5f57e9f3 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -2002,6 +2002,8 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
 		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
 		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
+		amdgpu_device_ip_block_add(adev, &gfx_v7_2_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
 		if (amdgpu_dpm == -1)
 			amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
 		else
@@ -2014,8 +2016,6 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 #endif
 		else
 			amdgpu_device_ip_block_add(adev, &dce_v8_2_ip_block);
-		amdgpu_device_ip_block_add(adev, &gfx_v7_2_ip_block);
-		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
 		amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block);
 		amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block);
 		break;
@@ -2023,6 +2023,8 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
 		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
 		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
+		amdgpu_device_ip_block_add(adev, &gfx_v7_3_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
 		if (amdgpu_dpm == -1)
 			amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
 		else
@@ -2035,8 +2037,6 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 #endif
 		else
 			amdgpu_device_ip_block_add(adev, &dce_v8_5_ip_block);
-		amdgpu_device_ip_block_add(adev, &gfx_v7_3_ip_block);
-		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
 		amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block);
 		amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block);
 		break;
@@ -2044,6 +2044,8 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
 		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
 		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
+		amdgpu_device_ip_block_add(adev, &gfx_v7_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
 		amdgpu_device_ip_block_add(adev, &kv_smu_ip_block);
 		if (adev->enable_virtual_display)
 			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
@@ -2053,8 +2055,7 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 #endif
 		else
 			amdgpu_device_ip_block_add(adev, &dce_v8_1_ip_block);
-		amdgpu_device_ip_block_add(adev, &gfx_v7_1_ip_block);
-		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
+
 		amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block);
 		amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block);
 		break;
@@ -2063,6 +2064,8 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
 		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
 		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
+		amdgpu_device_ip_block_add(adev, &gfx_v7_2_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
 		amdgpu_device_ip_block_add(adev, &kv_smu_ip_block);
 		if (adev->enable_virtual_display)
 			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
@@ -2072,8 +2075,6 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 #endif
 		else
 			amdgpu_device_ip_block_add(adev, &dce_v8_3_ip_block);
-		amdgpu_device_ip_block_add(adev, &gfx_v7_2_ip_block);
-		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
 		amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block);
 		amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block);
 		break;

commit 586092ab4b768b01b3184d9a2541e2cf9a8d9740
Author: Jia-Ju Bai <baijiaju1990@gmail.com>
Date:   Mon Jul 23 22:29:56 2018 +0800

    gpu: drm: amdgpu: Replace mdelay with msleep in cik_pcie_gen3_enable()
    
    cik_pcie_gen3_enable() is only called by cik_common_hw_init(), which is
    never called in atomic context.
    cik_pcie_gen3_enable() calls mdelay() to busily wait, which is not
    necessary.
    mdelay() can be replaced with msleep().
    
    This is found by a static analysis tool named DCNS written by myself.
    
    Signed-off-by: Jia-Ju Bai <baijiaju1990@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 702e257a483f..78ab939ae5d8 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1476,7 +1476,7 @@ static void cik_pcie_gen3_enable(struct amdgpu_device *adev)
 				tmp |= PCIE_LC_CNTL4__LC_REDO_EQ_MASK;
 				WREG32_PCIE(ixPCIE_LC_CNTL4, tmp);
 
-				mdelay(100);
+				msleep(100);
 
 				/* linkctl */
 				pci_read_config_word(root, bridge_pos + PCI_EXP_LNKCTL, &tmp16);

commit 3120e2a390a9322a8247d7e9b8be52a7efc26dab
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu May 31 12:46:08 2018 -0500

    drm/amdgpu/pp: switch the default dpm implementation for CI
    
    Switch hawaii and bonaire to use powerplay rather than the old
    dpm implementation.  Powerplay supports more features and is
    better maintained.  Ultimately, we can drop the older dpm
    implementation like we did for other older asics.
    
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Rex Zhu <rezhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 8ff4c60d1b59..702e257a483f 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -2003,9 +2003,9 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
 		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
 		if (amdgpu_dpm == -1)
-			amdgpu_device_ip_block_add(adev, &ci_smu_ip_block);
-		else
 			amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
+		else
+			amdgpu_device_ip_block_add(adev, &ci_smu_ip_block);
 		if (adev->enable_virtual_display)
 			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
 #if defined(CONFIG_DRM_AMD_DC)
@@ -2024,9 +2024,9 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
 		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
 		if (amdgpu_dpm == -1)
-			amdgpu_device_ip_block_add(adev, &ci_smu_ip_block);
-		else
 			amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
+		else
+			amdgpu_device_ip_block_add(adev, &ci_smu_ip_block);
 		if (adev->enable_virtual_display)
 			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
 #if defined(CONFIG_DRM_AMD_DC)

commit b7acb46f210b92005b8db16380eac6b3a4c61431
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Mar 29 14:39:10 2018 -0500

    drm/amdgpu/cik: implement asic need_full_reset callback
    
    Used to check on a per SoC basis whether the SoC needs
    a full reset of a per IP soft reset.
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 0df22030e713..8ff4c60d1b59 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1735,6 +1735,12 @@ static void cik_invalidate_hdp(struct amdgpu_device *adev,
 	}
 }
 
+static bool cik_need_full_reset(struct amdgpu_device *adev)
+{
+	/* change this when we support soft reset */
+	return true;
+}
+
 static const struct amdgpu_asic_funcs cik_asic_funcs =
 {
 	.read_disabled_bios = &cik_read_disabled_bios,
@@ -1748,6 +1754,7 @@ static const struct amdgpu_asic_funcs cik_asic_funcs =
 	.get_config_memsize = &cik_get_config_memsize,
 	.flush_hdp = &cik_flush_hdp,
 	.invalidate_hdp = &cik_invalidate_hdp,
+	.need_full_reset = &cik_need_full_reset,
 };
 
 static int cik_common_early_init(void *handle)

commit b905090d2bae2e6189511714a7b88691b439c5a1
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Mon Mar 12 19:52:23 2018 +0800

    drm/amdgpu: Remove wrapper layer of smu ip functions
    
    1. delete amdgpu_powerplay.c used for wrapping smu ip functions
    2. delete struct pp_instance,
    3. make struct hwmgr as the smu hw handle.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 71b35623b32d..0df22030e713 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -67,7 +67,6 @@
 
 #include "amdgpu_dm.h"
 #include "amdgpu_amdkfd.h"
-#include "amdgpu_powerplay.h"
 #include "dce_virtual.h"
 
 /*
@@ -1996,7 +1995,10 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
 		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
 		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
-		amdgpu_device_ip_block_add(adev, &amdgpu_pp_ip_block);
+		if (amdgpu_dpm == -1)
+			amdgpu_device_ip_block_add(adev, &ci_smu_ip_block);
+		else
+			amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
 		if (adev->enable_virtual_display)
 			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
 #if defined(CONFIG_DRM_AMD_DC)
@@ -2014,7 +2016,10 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
 		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
 		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
-		amdgpu_device_ip_block_add(adev, &amdgpu_pp_ip_block);
+		if (amdgpu_dpm == -1)
+			amdgpu_device_ip_block_add(adev, &ci_smu_ip_block);
+		else
+			amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
 		if (adev->enable_virtual_display)
 			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
 #if defined(CONFIG_DRM_AMD_DC)
@@ -2032,7 +2037,7 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
 		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
 		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
-		amdgpu_device_ip_block_add(adev, &amdgpu_pp_ip_block);
+		amdgpu_device_ip_block_add(adev, &kv_smu_ip_block);
 		if (adev->enable_virtual_display)
 			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
 #if defined(CONFIG_DRM_AMD_DC)
@@ -2051,7 +2056,7 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
 		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
 		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
-		amdgpu_device_ip_block_add(adev, &amdgpu_pp_ip_block);
+		amdgpu_device_ip_block_add(adev, &kv_smu_ip_block);
 		if (adev->enable_virtual_display)
 			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
 #if defined(CONFIG_DRM_AMD_DC)

commit 5494d8640ffc1df6096fd37943948ab46a152850
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Mar 9 15:14:11 2018 -0500

    drm/amdgpu: move getting pcie info to common code
    
    No need to replicate it in several places.
    
    Reviewed-by: Rex Zhu <rezhu@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index f14dd1b073e9..71b35623b32d 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1887,8 +1887,6 @@ static int cik_common_early_init(void *handle)
 		return -EINVAL;
 	}
 
-	amdgpu_device_get_pcie_info(adev);
-
 	return 0;
 }
 

commit 19aede779138c0514b8e96c24473f22aaf21be65
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Mar 9 15:06:35 2018 -0500

    drm/amdgpu: move firmware loading type setup to common code
    
    No need to replicate it in several places.
    
    Reviewed-by: Rex Zhu <rezhu@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 4324184996a5..f14dd1b073e9 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1887,8 +1887,6 @@ static int cik_common_early_init(void *handle)
 		return -EINVAL;
 	}
 
-	adev->firmware.load_type = amdgpu_ucode_get_load_type(adev, amdgpu_fw_load_type);
-
 	amdgpu_device_get_pcie_info(adev);
 
 	return 0;

commit 698825653fdf1a696e1b9458ed9fc4aa2c6587d4
Author: Christian König <christian.koenig@amd.com>
Date:   Fri Jan 19 14:17:40 2018 +0100

    drm/amdgpu: add optional ring to *_hdp callbacks
    
    This adds an optional ring to the invalidate_hdp and flush_hdp
    callbacks. If the ring isn't specified or the emit_wreg function not
    available the HDP operation will be done with the CPU otherwise by
    writing on the ring.
    
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Acked-by: Chunming Zhou <david1.zhou@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 204ce807372c..4324184996a5 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1715,16 +1715,25 @@ static void cik_detect_hw_virtualization(struct amdgpu_device *adev)
 		adev->virt.caps |= AMDGPU_PASSTHROUGH_MODE;
 }
 
-static void cik_flush_hdp(struct amdgpu_device *adev)
+static void cik_flush_hdp(struct amdgpu_device *adev, struct amdgpu_ring *ring)
 {
-	WREG32(mmHDP_MEM_COHERENCY_FLUSH_CNTL, 1);
-	RREG32(mmHDP_MEM_COHERENCY_FLUSH_CNTL);
+	if (!ring || !ring->funcs->emit_wreg) {
+		WREG32(mmHDP_MEM_COHERENCY_FLUSH_CNTL, 1);
+		RREG32(mmHDP_MEM_COHERENCY_FLUSH_CNTL);
+	} else {
+		amdgpu_ring_emit_wreg(ring, mmHDP_MEM_COHERENCY_FLUSH_CNTL, 1);
+	}
 }
 
-static void cik_invalidate_hdp(struct amdgpu_device *adev)
+static void cik_invalidate_hdp(struct amdgpu_device *adev,
+			       struct amdgpu_ring *ring)
 {
-	WREG32(mmHDP_DEBUG0, 1);
-	RREG32(mmHDP_DEBUG0);
+	if (!ring || !ring->funcs->emit_wreg) {
+		WREG32(mmHDP_DEBUG0, 1);
+		RREG32(mmHDP_DEBUG0);
+	} else {
+		amdgpu_ring_emit_wreg(ring, mmHDP_DEBUG0, 1);
+	}
 }
 
 static const struct amdgpu_asic_funcs cik_asic_funcs =

commit 13854c60d7753cbb2bb1db6463df220164ec001a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Sep 6 18:06:01 2017 -0400

    drm/amdgpu: add HDP asic callbacks for CIK
    
    Needed to flush and invalidate the HDP block using the CPU.
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Samuel Li <Samuel.Li@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 8e59e65efd44..204ce807372c 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1715,6 +1715,18 @@ static void cik_detect_hw_virtualization(struct amdgpu_device *adev)
 		adev->virt.caps |= AMDGPU_PASSTHROUGH_MODE;
 }
 
+static void cik_flush_hdp(struct amdgpu_device *adev)
+{
+	WREG32(mmHDP_MEM_COHERENCY_FLUSH_CNTL, 1);
+	RREG32(mmHDP_MEM_COHERENCY_FLUSH_CNTL);
+}
+
+static void cik_invalidate_hdp(struct amdgpu_device *adev)
+{
+	WREG32(mmHDP_DEBUG0, 1);
+	RREG32(mmHDP_DEBUG0);
+}
+
 static const struct amdgpu_asic_funcs cik_asic_funcs =
 {
 	.read_disabled_bios = &cik_read_disabled_bios,
@@ -1726,6 +1738,8 @@ static const struct amdgpu_asic_funcs cik_asic_funcs =
 	.set_uvd_clocks = &cik_set_uvd_clocks,
 	.set_vce_clocks = &cik_set_vce_clocks,
 	.get_config_memsize = &cik_get_config_memsize,
+	.flush_hdp = &cik_flush_hdp,
+	.invalidate_hdp = &cik_invalidate_hdp,
 };
 
 static int cik_common_early_init(void *handle)

commit 041d9d93b5dba8fa41134a4e5fc7a432b76fa308
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Dec 15 16:49:33 2017 -0500

    drm/amdgpu: rename amdgpu_get_pcie_info
    
    add device to the name for consistency.
    
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 6a92abc736e0..8e59e65efd44 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1866,7 +1866,7 @@ static int cik_common_early_init(void *handle)
 
 	adev->firmware.load_type = amdgpu_ucode_get_load_type(adev, amdgpu_fw_load_type);
 
-	amdgpu_get_pcie_info(adev);
+	amdgpu_device_get_pcie_info(adev);
 
 	return 0;
 }

commit 2990a1fc012e1bb4523a54d2c27eebc21a2c7e7e
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Dec 15 16:18:00 2017 -0500

    drm/amdgpu: rename ip block helper functions
    
    add device to the name for consistency.
    
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 132ba226f289..6a92abc736e0 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1974,77 +1974,77 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 
 	switch (adev->asic_type) {
 	case CHIP_BONAIRE:
-		amdgpu_ip_block_add(adev, &cik_common_ip_block);
-		amdgpu_ip_block_add(adev, &gmc_v7_0_ip_block);
-		amdgpu_ip_block_add(adev, &cik_ih_ip_block);
-		amdgpu_ip_block_add(adev, &amdgpu_pp_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
+		amdgpu_device_ip_block_add(adev, &amdgpu_pp_ip_block);
 		if (adev->enable_virtual_display)
-			amdgpu_ip_block_add(adev, &dce_virtual_ip_block);
+			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
 #if defined(CONFIG_DRM_AMD_DC)
 		else if (amdgpu_device_has_dc_support(adev))
-			amdgpu_ip_block_add(adev, &dm_ip_block);
+			amdgpu_device_ip_block_add(adev, &dm_ip_block);
 #endif
 		else
-			amdgpu_ip_block_add(adev, &dce_v8_2_ip_block);
-		amdgpu_ip_block_add(adev, &gfx_v7_2_ip_block);
-		amdgpu_ip_block_add(adev, &cik_sdma_ip_block);
-		amdgpu_ip_block_add(adev, &uvd_v4_2_ip_block);
-		amdgpu_ip_block_add(adev, &vce_v2_0_ip_block);
+			amdgpu_device_ip_block_add(adev, &dce_v8_2_ip_block);
+		amdgpu_device_ip_block_add(adev, &gfx_v7_2_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
+		amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block);
+		amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block);
 		break;
 	case CHIP_HAWAII:
-		amdgpu_ip_block_add(adev, &cik_common_ip_block);
-		amdgpu_ip_block_add(adev, &gmc_v7_0_ip_block);
-		amdgpu_ip_block_add(adev, &cik_ih_ip_block);
-		amdgpu_ip_block_add(adev, &amdgpu_pp_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
+		amdgpu_device_ip_block_add(adev, &amdgpu_pp_ip_block);
 		if (adev->enable_virtual_display)
-			amdgpu_ip_block_add(adev, &dce_virtual_ip_block);
+			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
 #if defined(CONFIG_DRM_AMD_DC)
 		else if (amdgpu_device_has_dc_support(adev))
-			amdgpu_ip_block_add(adev, &dm_ip_block);
+			amdgpu_device_ip_block_add(adev, &dm_ip_block);
 #endif
 		else
-			amdgpu_ip_block_add(adev, &dce_v8_5_ip_block);
-		amdgpu_ip_block_add(adev, &gfx_v7_3_ip_block);
-		amdgpu_ip_block_add(adev, &cik_sdma_ip_block);
-		amdgpu_ip_block_add(adev, &uvd_v4_2_ip_block);
-		amdgpu_ip_block_add(adev, &vce_v2_0_ip_block);
+			amdgpu_device_ip_block_add(adev, &dce_v8_5_ip_block);
+		amdgpu_device_ip_block_add(adev, &gfx_v7_3_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
+		amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block);
+		amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block);
 		break;
 	case CHIP_KAVERI:
-		amdgpu_ip_block_add(adev, &cik_common_ip_block);
-		amdgpu_ip_block_add(adev, &gmc_v7_0_ip_block);
-		amdgpu_ip_block_add(adev, &cik_ih_ip_block);
-		amdgpu_ip_block_add(adev, &amdgpu_pp_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
+		amdgpu_device_ip_block_add(adev, &amdgpu_pp_ip_block);
 		if (adev->enable_virtual_display)
-			amdgpu_ip_block_add(adev, &dce_virtual_ip_block);
+			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
 #if defined(CONFIG_DRM_AMD_DC)
 		else if (amdgpu_device_has_dc_support(adev))
-			amdgpu_ip_block_add(adev, &dm_ip_block);
+			amdgpu_device_ip_block_add(adev, &dm_ip_block);
 #endif
 		else
-			amdgpu_ip_block_add(adev, &dce_v8_1_ip_block);
-		amdgpu_ip_block_add(adev, &gfx_v7_1_ip_block);
-		amdgpu_ip_block_add(adev, &cik_sdma_ip_block);
-		amdgpu_ip_block_add(adev, &uvd_v4_2_ip_block);
-		amdgpu_ip_block_add(adev, &vce_v2_0_ip_block);
+			amdgpu_device_ip_block_add(adev, &dce_v8_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &gfx_v7_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
+		amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block);
+		amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block);
 		break;
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
-		amdgpu_ip_block_add(adev, &cik_common_ip_block);
-		amdgpu_ip_block_add(adev, &gmc_v7_0_ip_block);
-		amdgpu_ip_block_add(adev, &cik_ih_ip_block);
-		amdgpu_ip_block_add(adev, &amdgpu_pp_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
+		amdgpu_device_ip_block_add(adev, &amdgpu_pp_ip_block);
 		if (adev->enable_virtual_display)
-			amdgpu_ip_block_add(adev, &dce_virtual_ip_block);
+			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
 #if defined(CONFIG_DRM_AMD_DC)
 		else if (amdgpu_device_has_dc_support(adev))
-			amdgpu_ip_block_add(adev, &dm_ip_block);
+			amdgpu_device_ip_block_add(adev, &dm_ip_block);
 #endif
 		else
-			amdgpu_ip_block_add(adev, &dce_v8_3_ip_block);
-		amdgpu_ip_block_add(adev, &gfx_v7_2_ip_block);
-		amdgpu_ip_block_add(adev, &cik_sdma_ip_block);
-		amdgpu_ip_block_add(adev, &uvd_v4_2_ip_block);
-		amdgpu_ip_block_add(adev, &vce_v2_0_ip_block);
+			amdgpu_device_ip_block_add(adev, &dce_v8_3_ip_block);
+		amdgpu_device_ip_block_add(adev, &gfx_v7_2_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
+		amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block);
+		amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block);
 		break;
 	default:
 		/* FIXME: not supported yet */

commit 8111c387275f64aae972d5717d32b0f756bb6e5f
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Dec 14 16:22:53 2017 -0500

    drm/amdgpu: rename amdgpu_pci_config_reset
    
    add device for consistency with other functions in this file.
    
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 39d49712f8c9..132ba226f289 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1246,7 +1246,7 @@ static int cik_gpu_pci_config_reset(struct amdgpu_device *adev)
 	/* disable BM */
 	pci_clear_master(adev->pdev);
 	/* reset */
-	amdgpu_pci_config_reset(adev);
+	amdgpu_device_pci_config_reset(adev);
 
 	udelay(100);
 

commit 9c3f2b54746f764e1b695797c78bc46b8713f067
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Dec 14 16:20:19 2017 -0500

    drm/amdgpu: rename amdgpu_program_register_sequence
    
    add device for consistency with other functions in this file.
    
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 8ba056a2a5da..39d49712f8c9 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -755,74 +755,74 @@ static void cik_init_golden_registers(struct amdgpu_device *adev)
 
 	switch (adev->asic_type) {
 	case CHIP_BONAIRE:
-		amdgpu_program_register_sequence(adev,
-						 bonaire_mgcg_cgcg_init,
-						 ARRAY_SIZE(bonaire_mgcg_cgcg_init));
-		amdgpu_program_register_sequence(adev,
-						 bonaire_golden_registers,
-						 ARRAY_SIZE(bonaire_golden_registers));
-		amdgpu_program_register_sequence(adev,
-						 bonaire_golden_common_registers,
-						 ARRAY_SIZE(bonaire_golden_common_registers));
-		amdgpu_program_register_sequence(adev,
-						 bonaire_golden_spm_registers,
-						 ARRAY_SIZE(bonaire_golden_spm_registers));
+		amdgpu_device_program_register_sequence(adev,
+							bonaire_mgcg_cgcg_init,
+							ARRAY_SIZE(bonaire_mgcg_cgcg_init));
+		amdgpu_device_program_register_sequence(adev,
+							bonaire_golden_registers,
+							ARRAY_SIZE(bonaire_golden_registers));
+		amdgpu_device_program_register_sequence(adev,
+							bonaire_golden_common_registers,
+							ARRAY_SIZE(bonaire_golden_common_registers));
+		amdgpu_device_program_register_sequence(adev,
+							bonaire_golden_spm_registers,
+							ARRAY_SIZE(bonaire_golden_spm_registers));
 		break;
 	case CHIP_KABINI:
-		amdgpu_program_register_sequence(adev,
-						 kalindi_mgcg_cgcg_init,
-						 ARRAY_SIZE(kalindi_mgcg_cgcg_init));
-		amdgpu_program_register_sequence(adev,
-						 kalindi_golden_registers,
-						 ARRAY_SIZE(kalindi_golden_registers));
-		amdgpu_program_register_sequence(adev,
-						 kalindi_golden_common_registers,
-						 ARRAY_SIZE(kalindi_golden_common_registers));
-		amdgpu_program_register_sequence(adev,
-						 kalindi_golden_spm_registers,
-						 ARRAY_SIZE(kalindi_golden_spm_registers));
+		amdgpu_device_program_register_sequence(adev,
+							kalindi_mgcg_cgcg_init,
+							ARRAY_SIZE(kalindi_mgcg_cgcg_init));
+		amdgpu_device_program_register_sequence(adev,
+							kalindi_golden_registers,
+							ARRAY_SIZE(kalindi_golden_registers));
+		amdgpu_device_program_register_sequence(adev,
+							kalindi_golden_common_registers,
+							ARRAY_SIZE(kalindi_golden_common_registers));
+		amdgpu_device_program_register_sequence(adev,
+							kalindi_golden_spm_registers,
+							ARRAY_SIZE(kalindi_golden_spm_registers));
 		break;
 	case CHIP_MULLINS:
-		amdgpu_program_register_sequence(adev,
-						 kalindi_mgcg_cgcg_init,
-						 ARRAY_SIZE(kalindi_mgcg_cgcg_init));
-		amdgpu_program_register_sequence(adev,
-						 godavari_golden_registers,
-						 ARRAY_SIZE(godavari_golden_registers));
-		amdgpu_program_register_sequence(adev,
-						 kalindi_golden_common_registers,
-						 ARRAY_SIZE(kalindi_golden_common_registers));
-		amdgpu_program_register_sequence(adev,
-						 kalindi_golden_spm_registers,
-						 ARRAY_SIZE(kalindi_golden_spm_registers));
+		amdgpu_device_program_register_sequence(adev,
+							kalindi_mgcg_cgcg_init,
+							ARRAY_SIZE(kalindi_mgcg_cgcg_init));
+		amdgpu_device_program_register_sequence(adev,
+							godavari_golden_registers,
+							ARRAY_SIZE(godavari_golden_registers));
+		amdgpu_device_program_register_sequence(adev,
+							kalindi_golden_common_registers,
+							ARRAY_SIZE(kalindi_golden_common_registers));
+		amdgpu_device_program_register_sequence(adev,
+							kalindi_golden_spm_registers,
+							ARRAY_SIZE(kalindi_golden_spm_registers));
 		break;
 	case CHIP_KAVERI:
-		amdgpu_program_register_sequence(adev,
-						 spectre_mgcg_cgcg_init,
-						 ARRAY_SIZE(spectre_mgcg_cgcg_init));
-		amdgpu_program_register_sequence(adev,
-						 spectre_golden_registers,
-						 ARRAY_SIZE(spectre_golden_registers));
-		amdgpu_program_register_sequence(adev,
-						 spectre_golden_common_registers,
-						 ARRAY_SIZE(spectre_golden_common_registers));
-		amdgpu_program_register_sequence(adev,
-						 spectre_golden_spm_registers,
-						 ARRAY_SIZE(spectre_golden_spm_registers));
+		amdgpu_device_program_register_sequence(adev,
+							spectre_mgcg_cgcg_init,
+							ARRAY_SIZE(spectre_mgcg_cgcg_init));
+		amdgpu_device_program_register_sequence(adev,
+							spectre_golden_registers,
+							ARRAY_SIZE(spectre_golden_registers));
+		amdgpu_device_program_register_sequence(adev,
+							spectre_golden_common_registers,
+							ARRAY_SIZE(spectre_golden_common_registers));
+		amdgpu_device_program_register_sequence(adev,
+							spectre_golden_spm_registers,
+							ARRAY_SIZE(spectre_golden_spm_registers));
 		break;
 	case CHIP_HAWAII:
-		amdgpu_program_register_sequence(adev,
-						 hawaii_mgcg_cgcg_init,
-						 ARRAY_SIZE(hawaii_mgcg_cgcg_init));
-		amdgpu_program_register_sequence(adev,
-						 hawaii_golden_registers,
-						 ARRAY_SIZE(hawaii_golden_registers));
-		amdgpu_program_register_sequence(adev,
-						 hawaii_golden_common_registers,
-						 ARRAY_SIZE(hawaii_golden_common_registers));
-		amdgpu_program_register_sequence(adev,
-						 hawaii_golden_spm_registers,
-						 ARRAY_SIZE(hawaii_golden_spm_registers));
+		amdgpu_device_program_register_sequence(adev,
+							hawaii_mgcg_cgcg_init,
+							ARRAY_SIZE(hawaii_mgcg_cgcg_init));
+		amdgpu_device_program_register_sequence(adev,
+							hawaii_golden_registers,
+							ARRAY_SIZE(hawaii_golden_registers));
+		amdgpu_device_program_register_sequence(adev,
+							hawaii_golden_common_registers,
+							ARRAY_SIZE(hawaii_golden_common_registers));
+		amdgpu_device_program_register_sequence(adev,
+							hawaii_golden_spm_registers,
+							ARRAY_SIZE(hawaii_golden_spm_registers));
 		break;
 	default:
 		break;

commit c47b41a79ab5e8faec9aea6c4a06c4d1e4d1132f
Author: Christian König <christian.koenig@amd.com>
Date:   Fri Nov 3 15:59:25 2017 +0100

    drm/amdgpu: remove nonsense const u32 cast on ARRAY_SIZE result
    
    Not sure what that should originally been good for, but it doesn't seem
    to make any sense any more.
    
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index a296f7bbe57c..8ba056a2a5da 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -757,72 +757,72 @@ static void cik_init_golden_registers(struct amdgpu_device *adev)
 	case CHIP_BONAIRE:
 		amdgpu_program_register_sequence(adev,
 						 bonaire_mgcg_cgcg_init,
-						 (const u32)ARRAY_SIZE(bonaire_mgcg_cgcg_init));
+						 ARRAY_SIZE(bonaire_mgcg_cgcg_init));
 		amdgpu_program_register_sequence(adev,
 						 bonaire_golden_registers,
-						 (const u32)ARRAY_SIZE(bonaire_golden_registers));
+						 ARRAY_SIZE(bonaire_golden_registers));
 		amdgpu_program_register_sequence(adev,
 						 bonaire_golden_common_registers,
-						 (const u32)ARRAY_SIZE(bonaire_golden_common_registers));
+						 ARRAY_SIZE(bonaire_golden_common_registers));
 		amdgpu_program_register_sequence(adev,
 						 bonaire_golden_spm_registers,
-						 (const u32)ARRAY_SIZE(bonaire_golden_spm_registers));
+						 ARRAY_SIZE(bonaire_golden_spm_registers));
 		break;
 	case CHIP_KABINI:
 		amdgpu_program_register_sequence(adev,
 						 kalindi_mgcg_cgcg_init,
-						 (const u32)ARRAY_SIZE(kalindi_mgcg_cgcg_init));
+						 ARRAY_SIZE(kalindi_mgcg_cgcg_init));
 		amdgpu_program_register_sequence(adev,
 						 kalindi_golden_registers,
-						 (const u32)ARRAY_SIZE(kalindi_golden_registers));
+						 ARRAY_SIZE(kalindi_golden_registers));
 		amdgpu_program_register_sequence(adev,
 						 kalindi_golden_common_registers,
-						 (const u32)ARRAY_SIZE(kalindi_golden_common_registers));
+						 ARRAY_SIZE(kalindi_golden_common_registers));
 		amdgpu_program_register_sequence(adev,
 						 kalindi_golden_spm_registers,
-						 (const u32)ARRAY_SIZE(kalindi_golden_spm_registers));
+						 ARRAY_SIZE(kalindi_golden_spm_registers));
 		break;
 	case CHIP_MULLINS:
 		amdgpu_program_register_sequence(adev,
 						 kalindi_mgcg_cgcg_init,
-						 (const u32)ARRAY_SIZE(kalindi_mgcg_cgcg_init));
+						 ARRAY_SIZE(kalindi_mgcg_cgcg_init));
 		amdgpu_program_register_sequence(adev,
 						 godavari_golden_registers,
-						 (const u32)ARRAY_SIZE(godavari_golden_registers));
+						 ARRAY_SIZE(godavari_golden_registers));
 		amdgpu_program_register_sequence(adev,
 						 kalindi_golden_common_registers,
-						 (const u32)ARRAY_SIZE(kalindi_golden_common_registers));
+						 ARRAY_SIZE(kalindi_golden_common_registers));
 		amdgpu_program_register_sequence(adev,
 						 kalindi_golden_spm_registers,
-						 (const u32)ARRAY_SIZE(kalindi_golden_spm_registers));
+						 ARRAY_SIZE(kalindi_golden_spm_registers));
 		break;
 	case CHIP_KAVERI:
 		amdgpu_program_register_sequence(adev,
 						 spectre_mgcg_cgcg_init,
-						 (const u32)ARRAY_SIZE(spectre_mgcg_cgcg_init));
+						 ARRAY_SIZE(spectre_mgcg_cgcg_init));
 		amdgpu_program_register_sequence(adev,
 						 spectre_golden_registers,
-						 (const u32)ARRAY_SIZE(spectre_golden_registers));
+						 ARRAY_SIZE(spectre_golden_registers));
 		amdgpu_program_register_sequence(adev,
 						 spectre_golden_common_registers,
-						 (const u32)ARRAY_SIZE(spectre_golden_common_registers));
+						 ARRAY_SIZE(spectre_golden_common_registers));
 		amdgpu_program_register_sequence(adev,
 						 spectre_golden_spm_registers,
-						 (const u32)ARRAY_SIZE(spectre_golden_spm_registers));
+						 ARRAY_SIZE(spectre_golden_spm_registers));
 		break;
 	case CHIP_HAWAII:
 		amdgpu_program_register_sequence(adev,
 						 hawaii_mgcg_cgcg_init,
-						 (const u32)ARRAY_SIZE(hawaii_mgcg_cgcg_init));
+						 ARRAY_SIZE(hawaii_mgcg_cgcg_init));
 		amdgpu_program_register_sequence(adev,
 						 hawaii_golden_registers,
-						 (const u32)ARRAY_SIZE(hawaii_golden_registers));
+						 ARRAY_SIZE(hawaii_golden_registers));
 		amdgpu_program_register_sequence(adev,
 						 hawaii_golden_common_registers,
-						 (const u32)ARRAY_SIZE(hawaii_golden_common_registers));
+						 ARRAY_SIZE(hawaii_golden_common_registers));
 		amdgpu_program_register_sequence(adev,
 						 hawaii_golden_spm_registers,
-						 (const u32)ARRAY_SIZE(hawaii_golden_spm_registers));
+						 ARRAY_SIZE(hawaii_golden_spm_registers));
 		break;
 	default:
 		break;

commit aca31681b1a594dd1a25a51ff2c58f4f4a165446
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Nov 21 13:53:29 2017 -0500

    drm/amdgpu: used cached gca values for cik_read_register
    
    Using the cached values has less latency for bare metal and
    prevents reading back bogus values if the engine is powergated.
    
    This was implemented for VI and SI, but somehow CIK got missed.
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 793b1470284d..a296f7bbe57c 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1023,22 +1023,101 @@ static const struct amdgpu_allowed_register_entry cik_allowed_read_registers[] =
 	{mmPA_SC_RASTER_CONFIG_1, true},
 };
 
-static uint32_t cik_read_indexed_register(struct amdgpu_device *adev,
-					  u32 se_num, u32 sh_num,
-					  u32 reg_offset)
+
+static uint32_t cik_get_register_value(struct amdgpu_device *adev,
+				       bool indexed, u32 se_num,
+				       u32 sh_num, u32 reg_offset)
 {
-	uint32_t val;
+	if (indexed) {
+		uint32_t val;
+		unsigned se_idx = (se_num == 0xffffffff) ? 0 : se_num;
+		unsigned sh_idx = (sh_num == 0xffffffff) ? 0 : sh_num;
+
+		switch (reg_offset) {
+		case mmCC_RB_BACKEND_DISABLE:
+			return adev->gfx.config.rb_config[se_idx][sh_idx].rb_backend_disable;
+		case mmGC_USER_RB_BACKEND_DISABLE:
+			return adev->gfx.config.rb_config[se_idx][sh_idx].user_rb_backend_disable;
+		case mmPA_SC_RASTER_CONFIG:
+			return adev->gfx.config.rb_config[se_idx][sh_idx].raster_config;
+		case mmPA_SC_RASTER_CONFIG_1:
+			return adev->gfx.config.rb_config[se_idx][sh_idx].raster_config_1;
+		}
 
-	mutex_lock(&adev->grbm_idx_mutex);
-	if (se_num != 0xffffffff || sh_num != 0xffffffff)
-		amdgpu_gfx_select_se_sh(adev, se_num, sh_num, 0xffffffff);
+		mutex_lock(&adev->grbm_idx_mutex);
+		if (se_num != 0xffffffff || sh_num != 0xffffffff)
+			amdgpu_gfx_select_se_sh(adev, se_num, sh_num, 0xffffffff);
 
-	val = RREG32(reg_offset);
+		val = RREG32(reg_offset);
 
-	if (se_num != 0xffffffff || sh_num != 0xffffffff)
-		amdgpu_gfx_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff);
-	mutex_unlock(&adev->grbm_idx_mutex);
-	return val;
+		if (se_num != 0xffffffff || sh_num != 0xffffffff)
+			amdgpu_gfx_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff);
+		mutex_unlock(&adev->grbm_idx_mutex);
+		return val;
+	} else {
+		unsigned idx;
+
+		switch (reg_offset) {
+		case mmGB_ADDR_CONFIG:
+			return adev->gfx.config.gb_addr_config;
+		case mmMC_ARB_RAMCFG:
+			return adev->gfx.config.mc_arb_ramcfg;
+		case mmGB_TILE_MODE0:
+		case mmGB_TILE_MODE1:
+		case mmGB_TILE_MODE2:
+		case mmGB_TILE_MODE3:
+		case mmGB_TILE_MODE4:
+		case mmGB_TILE_MODE5:
+		case mmGB_TILE_MODE6:
+		case mmGB_TILE_MODE7:
+		case mmGB_TILE_MODE8:
+		case mmGB_TILE_MODE9:
+		case mmGB_TILE_MODE10:
+		case mmGB_TILE_MODE11:
+		case mmGB_TILE_MODE12:
+		case mmGB_TILE_MODE13:
+		case mmGB_TILE_MODE14:
+		case mmGB_TILE_MODE15:
+		case mmGB_TILE_MODE16:
+		case mmGB_TILE_MODE17:
+		case mmGB_TILE_MODE18:
+		case mmGB_TILE_MODE19:
+		case mmGB_TILE_MODE20:
+		case mmGB_TILE_MODE21:
+		case mmGB_TILE_MODE22:
+		case mmGB_TILE_MODE23:
+		case mmGB_TILE_MODE24:
+		case mmGB_TILE_MODE25:
+		case mmGB_TILE_MODE26:
+		case mmGB_TILE_MODE27:
+		case mmGB_TILE_MODE28:
+		case mmGB_TILE_MODE29:
+		case mmGB_TILE_MODE30:
+		case mmGB_TILE_MODE31:
+			idx = (reg_offset - mmGB_TILE_MODE0);
+			return adev->gfx.config.tile_mode_array[idx];
+		case mmGB_MACROTILE_MODE0:
+		case mmGB_MACROTILE_MODE1:
+		case mmGB_MACROTILE_MODE2:
+		case mmGB_MACROTILE_MODE3:
+		case mmGB_MACROTILE_MODE4:
+		case mmGB_MACROTILE_MODE5:
+		case mmGB_MACROTILE_MODE6:
+		case mmGB_MACROTILE_MODE7:
+		case mmGB_MACROTILE_MODE8:
+		case mmGB_MACROTILE_MODE9:
+		case mmGB_MACROTILE_MODE10:
+		case mmGB_MACROTILE_MODE11:
+		case mmGB_MACROTILE_MODE12:
+		case mmGB_MACROTILE_MODE13:
+		case mmGB_MACROTILE_MODE14:
+		case mmGB_MACROTILE_MODE15:
+			idx = (reg_offset - mmGB_MACROTILE_MODE0);
+			return adev->gfx.config.macrotile_mode_array[idx];
+		default:
+			return RREG32(reg_offset);
+		}
+	}
 }
 
 static int cik_read_register(struct amdgpu_device *adev, u32 se_num,
@@ -1048,13 +1127,13 @@ static int cik_read_register(struct amdgpu_device *adev, u32 se_num,
 
 	*value = 0;
 	for (i = 0; i < ARRAY_SIZE(cik_allowed_read_registers); i++) {
+		bool indexed = cik_allowed_read_registers[i].grbm_indexed;
+
 		if (reg_offset != cik_allowed_read_registers[i].reg_offset)
 			continue;
 
-		*value = cik_allowed_read_registers[i].grbm_indexed ?
-			 cik_read_indexed_register(adev, se_num,
-						   sh_num, reg_offset) :
-			 RREG32(reg_offset);
+		*value = cik_get_register_value(adev, indexed, se_num, sh_num,
+						reg_offset);
 		return 0;
 	}
 	return -EINVAL;

commit 9355c0e8519f3b0d61278b5ab9dee68321494351
Author: Alex Deucher <alexdeucher@gmail.com>
Date:   Thu Aug 10 14:39:52 2017 -0400

    drm/amdgpu/cik: add IP modules for DC for APUs
    
    Enable DC for DCE8 APUs.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index af3b66f6f47c..793b1470284d 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1937,6 +1937,10 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_ip_block_add(adev, &amdgpu_pp_ip_block);
 		if (adev->enable_virtual_display)
 			amdgpu_ip_block_add(adev, &dce_virtual_ip_block);
+#if defined(CONFIG_DRM_AMD_DC)
+		else if (amdgpu_device_has_dc_support(adev))
+			amdgpu_ip_block_add(adev, &dm_ip_block);
+#endif
 		else
 			amdgpu_ip_block_add(adev, &dce_v8_1_ip_block);
 		amdgpu_ip_block_add(adev, &gfx_v7_1_ip_block);
@@ -1952,6 +1956,10 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_ip_block_add(adev, &amdgpu_pp_ip_block);
 		if (adev->enable_virtual_display)
 			amdgpu_ip_block_add(adev, &dce_virtual_ip_block);
+#if defined(CONFIG_DRM_AMD_DC)
+		else if (amdgpu_device_has_dc_support(adev))
+			amdgpu_ip_block_add(adev, &dm_ip_block);
+#endif
 		else
 			amdgpu_ip_block_add(adev, &dce_v8_3_ip_block);
 		amdgpu_ip_block_add(adev, &gfx_v7_2_ip_block);

commit 4562236b3bc0a28aeb6ee93b2d8a849a4c4e1c7c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 12 15:58:20 2017 -0400

    drm/amd/dc: Add dc display driver (v2)
    
    Supported DCE versions: 8.0, 10.0, 11.0, 11.2
    
    v2: rebase against 4.11
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 567c4a5cf90c..af3b66f6f47c 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -65,6 +65,7 @@
 #include "oss/oss_2_0_d.h"
 #include "oss/oss_2_0_sh_mask.h"
 
+#include "amdgpu_dm.h"
 #include "amdgpu_amdkfd.h"
 #include "amdgpu_powerplay.h"
 #include "dce_virtual.h"
@@ -1900,6 +1901,10 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_ip_block_add(adev, &amdgpu_pp_ip_block);
 		if (adev->enable_virtual_display)
 			amdgpu_ip_block_add(adev, &dce_virtual_ip_block);
+#if defined(CONFIG_DRM_AMD_DC)
+		else if (amdgpu_device_has_dc_support(adev))
+			amdgpu_ip_block_add(adev, &dm_ip_block);
+#endif
 		else
 			amdgpu_ip_block_add(adev, &dce_v8_2_ip_block);
 		amdgpu_ip_block_add(adev, &gfx_v7_2_ip_block);
@@ -1914,6 +1919,10 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_ip_block_add(adev, &amdgpu_pp_ip_block);
 		if (adev->enable_virtual_display)
 			amdgpu_ip_block_add(adev, &dce_virtual_ip_block);
+#if defined(CONFIG_DRM_AMD_DC)
+		else if (amdgpu_device_has_dc_support(adev))
+			amdgpu_ip_block_add(adev, &dm_ip_block);
+#endif
 		else
 			amdgpu_ip_block_add(adev, &dce_v8_5_ip_block);
 		amdgpu_ip_block_add(adev, &gfx_v7_3_ip_block);

commit ba997709a6135355a1f311336c7c4a6c0e37dfe9
Author: Yong Zhao <yong.zhao@amd.com>
Date:   Mon Nov 9 17:21:45 2015 -0500

    drm/amdgpu: Correctly establish the suspend/resume hook for amdkfd
    
    Signed-off-by: Yong Zhao <yong.zhao@amd.com>
    Reviewed-by: Felix Kuehling <Felix.Kuehling@amd.com>
    Reviewed-by: Oded Gabbay <oded.gabbay@gmail.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 37a499ab30eb..567c4a5cf90c 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1824,21 +1824,14 @@ static int cik_common_suspend(void *handle)
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
-	amdgpu_amdkfd_suspend(adev);
-
 	return cik_common_hw_fini(adev);
 }
 
 static int cik_common_resume(void *handle)
 {
-	int r;
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
-	r = cik_common_hw_init(adev);
-	if (r)
-		return r;
-
-	return amdgpu_amdkfd_resume(adev);
+	return cik_common_hw_init(adev);
 }
 
 static bool cik_common_is_idle(void *handle)

commit 04d4fb5fa63876d8e7cf67f2788aecfafc6a28a7
Merge: bfda9aa15317 a1924005a2e9
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jun 16 09:54:02 2017 +1000

    Merge branch 'drm-next-4.13' of git://people.freedesktop.org/~agd5f/linux into drm-next
    
    New radeon and amdgpu features for 4.13:
    - Lots of Vega10 bug fixes
    - Preliminary Raven support
    - KIQ support for compute rings
    - MEC queue management rework from Andres
    - Audio support for DCE6
    - SR-IOV improvements
    - Improved module parameters for controlling radeon vs amdgpu support
      for SI and CIK
    - Bug fixes
    - General code cleanups
    
    [airlied: dropped drmP.h header from one file was needed and build broke]
    
    * 'drm-next-4.13' of git://people.freedesktop.org/~agd5f/linux: (362 commits)
      drm/amdgpu: Fix compiler warnings
      drm/amdgpu: vm_update_ptes remove code duplication
      drm/amd/amdgpu: Port VCN over to new SOC15 macros
      drm/amd/amdgpu: Port PSP v10.0 over to new SOC15 macros
      drm/amd/amdgpu: Port PSP v3.1 over to new SOC15 macros
      drm/amd/amdgpu: Port NBIO v7.0 driver over to new SOC15 macros
      drm/amd/amdgpu: Port NBIO v6.1 driver over to new SOC15 macros
      drm/amd/amdgpu: Port UVD 7.0 over to new SOC15 macros
      drm/amd/amdgpu: Port MMHUB over to new SOC15 macros
      drm/amd/amdgpu: Cleanup gfxhub read-modify-write patterns
      drm/amd/amdgpu: Port GFXHUB over to new SOC15 macros
      drm/amd/amdgpu: Add offset variant to SOC15 macros
      drm/amd/powerplay: add avfs control for Vega10
      drm/amdgpu: add virtual display support for raven
      drm/amdgpu/gfx9: fix compute ring doorbell index
      drm/amd/amdgpu: Rename KIQ ring to avoid spaces
      drm/amd/amdgpu: gfx9 tidy ups (v2)
      drm/amdgpu: add contiguous flag in ucode bo create
      drm/amdgpu: fix missed gpu info firmware when cache firmware during S3
      drm/amdgpu: export test ib debugfs interface
      ...

commit 97fcc76b67b8366633971fd5841a4606d040b67b
Author: Christian König <christian.koenig@amd.com>
Date:   Wed Apr 12 12:49:54 2017 +0200

    drm/amdgpu: drop support for untouched registers
    
    I couldn't figure out what this was original good for, but we
    don't use it any more.
    
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 9d33e5641419..581d432765d4 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -964,62 +964,62 @@ static bool cik_read_bios_from_rom(struct amdgpu_device *adev,
 }
 
 static const struct amdgpu_allowed_register_entry cik_allowed_read_registers[] = {
-	{mmGRBM_STATUS, false},
-	{mmGB_ADDR_CONFIG, false},
-	{mmMC_ARB_RAMCFG, false},
-	{mmGB_TILE_MODE0, false},
-	{mmGB_TILE_MODE1, false},
-	{mmGB_TILE_MODE2, false},
-	{mmGB_TILE_MODE3, false},
-	{mmGB_TILE_MODE4, false},
-	{mmGB_TILE_MODE5, false},
-	{mmGB_TILE_MODE6, false},
-	{mmGB_TILE_MODE7, false},
-	{mmGB_TILE_MODE8, false},
-	{mmGB_TILE_MODE9, false},
-	{mmGB_TILE_MODE10, false},
-	{mmGB_TILE_MODE11, false},
-	{mmGB_TILE_MODE12, false},
-	{mmGB_TILE_MODE13, false},
-	{mmGB_TILE_MODE14, false},
-	{mmGB_TILE_MODE15, false},
-	{mmGB_TILE_MODE16, false},
-	{mmGB_TILE_MODE17, false},
-	{mmGB_TILE_MODE18, false},
-	{mmGB_TILE_MODE19, false},
-	{mmGB_TILE_MODE20, false},
-	{mmGB_TILE_MODE21, false},
-	{mmGB_TILE_MODE22, false},
-	{mmGB_TILE_MODE23, false},
-	{mmGB_TILE_MODE24, false},
-	{mmGB_TILE_MODE25, false},
-	{mmGB_TILE_MODE26, false},
-	{mmGB_TILE_MODE27, false},
-	{mmGB_TILE_MODE28, false},
-	{mmGB_TILE_MODE29, false},
-	{mmGB_TILE_MODE30, false},
-	{mmGB_TILE_MODE31, false},
-	{mmGB_MACROTILE_MODE0, false},
-	{mmGB_MACROTILE_MODE1, false},
-	{mmGB_MACROTILE_MODE2, false},
-	{mmGB_MACROTILE_MODE3, false},
-	{mmGB_MACROTILE_MODE4, false},
-	{mmGB_MACROTILE_MODE5, false},
-	{mmGB_MACROTILE_MODE6, false},
-	{mmGB_MACROTILE_MODE7, false},
-	{mmGB_MACROTILE_MODE8, false},
-	{mmGB_MACROTILE_MODE9, false},
-	{mmGB_MACROTILE_MODE10, false},
-	{mmGB_MACROTILE_MODE11, false},
-	{mmGB_MACROTILE_MODE12, false},
-	{mmGB_MACROTILE_MODE13, false},
-	{mmGB_MACROTILE_MODE14, false},
-	{mmGB_MACROTILE_MODE15, false},
-	{mmCC_RB_BACKEND_DISABLE, false, true},
-	{mmGC_USER_RB_BACKEND_DISABLE, false, true},
-	{mmGB_BACKEND_MAP, false, false},
-	{mmPA_SC_RASTER_CONFIG, false, true},
-	{mmPA_SC_RASTER_CONFIG_1, false, true},
+	{mmGRBM_STATUS},
+	{mmGB_ADDR_CONFIG},
+	{mmMC_ARB_RAMCFG},
+	{mmGB_TILE_MODE0},
+	{mmGB_TILE_MODE1},
+	{mmGB_TILE_MODE2},
+	{mmGB_TILE_MODE3},
+	{mmGB_TILE_MODE4},
+	{mmGB_TILE_MODE5},
+	{mmGB_TILE_MODE6},
+	{mmGB_TILE_MODE7},
+	{mmGB_TILE_MODE8},
+	{mmGB_TILE_MODE9},
+	{mmGB_TILE_MODE10},
+	{mmGB_TILE_MODE11},
+	{mmGB_TILE_MODE12},
+	{mmGB_TILE_MODE13},
+	{mmGB_TILE_MODE14},
+	{mmGB_TILE_MODE15},
+	{mmGB_TILE_MODE16},
+	{mmGB_TILE_MODE17},
+	{mmGB_TILE_MODE18},
+	{mmGB_TILE_MODE19},
+	{mmGB_TILE_MODE20},
+	{mmGB_TILE_MODE21},
+	{mmGB_TILE_MODE22},
+	{mmGB_TILE_MODE23},
+	{mmGB_TILE_MODE24},
+	{mmGB_TILE_MODE25},
+	{mmGB_TILE_MODE26},
+	{mmGB_TILE_MODE27},
+	{mmGB_TILE_MODE28},
+	{mmGB_TILE_MODE29},
+	{mmGB_TILE_MODE30},
+	{mmGB_TILE_MODE31},
+	{mmGB_MACROTILE_MODE0},
+	{mmGB_MACROTILE_MODE1},
+	{mmGB_MACROTILE_MODE2},
+	{mmGB_MACROTILE_MODE3},
+	{mmGB_MACROTILE_MODE4},
+	{mmGB_MACROTILE_MODE5},
+	{mmGB_MACROTILE_MODE6},
+	{mmGB_MACROTILE_MODE7},
+	{mmGB_MACROTILE_MODE8},
+	{mmGB_MACROTILE_MODE9},
+	{mmGB_MACROTILE_MODE10},
+	{mmGB_MACROTILE_MODE11},
+	{mmGB_MACROTILE_MODE12},
+	{mmGB_MACROTILE_MODE13},
+	{mmGB_MACROTILE_MODE14},
+	{mmGB_MACROTILE_MODE15},
+	{mmCC_RB_BACKEND_DISABLE, true},
+	{mmGC_USER_RB_BACKEND_DISABLE, true},
+	{mmGB_BACKEND_MAP, false},
+	{mmPA_SC_RASTER_CONFIG, true},
+	{mmPA_SC_RASTER_CONFIG_1, true},
 };
 
 static uint32_t cik_read_indexed_register(struct amdgpu_device *adev,
@@ -1050,11 +1050,10 @@ static int cik_read_register(struct amdgpu_device *adev, u32 se_num,
 		if (reg_offset != cik_allowed_read_registers[i].reg_offset)
 			continue;
 
-		if (!cik_allowed_read_registers[i].untouched)
-			*value = cik_allowed_read_registers[i].grbm_indexed ?
-				 cik_read_indexed_register(adev, se_num,
-							   sh_num, reg_offset) :
-				 RREG32(reg_offset);
+		*value = cik_allowed_read_registers[i].grbm_indexed ?
+			 cik_read_indexed_register(adev, se_num,
+						   sh_num, reg_offset) :
+			 RREG32(reg_offset);
 		return 0;
 	}
 	return -EINVAL;

commit 248a1d6f1ac410d3ed3907c1be2502e286f59bb8
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Apr 24 13:50:21 2017 +0900

    drm/amd: fix include notation and remove -Iinclude/drm flag
    
    Include <drm/*.h> instead of relative path from include/drm, then
    remove the -Iinclude/drm compiler flag.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Michel Dänzer <michel.daenzer@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1493009447-31524-4-git-send-email-yamada.masahiro@socionext.com

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 9d33e5641419..6b2034533f68 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -24,7 +24,7 @@
 #include <linux/firmware.h>
 #include <linux/slab.h>
 #include <linux/module.h>
-#include "drmP.h"
+#include <drm/drmP.h>
 #include "amdgpu.h"
 #include "amdgpu_atombios.h"
 #include "amdgpu_ih.h"

commit e635ee07456ac686b3c26ab3c5735936faebfb2e
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Nov 1 15:35:38 2016 +0800

    drm/amdgpu: use new flag to handle different firmware loading method
    
    This patch introduces a new flag named "amdgpu_firmware_load_type" to
    handle different firmware loading method. Since Vega10, there are
    three ways to load firmware. It would be better to use a flag and a
    fw_load_type kernel parameter to configure it.
    
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index dbaedb4f2a6b..9d33e5641419 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1785,6 +1785,8 @@ static int cik_common_early_init(void *handle)
 		return -EINVAL;
 	}
 
+	adev->firmware.load_type = amdgpu_ucode_get_load_type(adev, amdgpu_fw_load_type);
+
 	amdgpu_get_pcie_info(adev);
 
 	return 0;

commit bbf282d884793f95b89dc35059f8703eaf48ca00
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Mar 3 17:26:10 2017 -0500

    drm/amdgpu: add asic callback to get memsize register
    
    Newer asics use different registers so abstract it.
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index c4d4b35e54ec..dbaedb4f2a6b 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1212,6 +1212,11 @@ static int cik_asic_reset(struct amdgpu_device *adev)
 	return r;
 }
 
+static u32 cik_get_config_memsize(struct amdgpu_device *adev)
+{
+	return RREG32(mmCONFIG_MEMSIZE);
+}
+
 static int cik_set_uvd_clock(struct amdgpu_device *adev, u32 clock,
 			      u32 cntl_reg, u32 status_reg)
 {
@@ -1641,6 +1646,7 @@ static const struct amdgpu_asic_funcs cik_asic_funcs =
 	.get_xclk = &cik_get_xclk,
 	.set_uvd_clocks = &cik_set_uvd_clocks,
 	.set_vce_clocks = &cik_set_vce_clocks,
+	.get_config_memsize = &cik_get_config_memsize,
 };
 
 static int cik_common_early_init(void *handle)

commit c836fec5ce8eb0d0c08fa0ea5fb71df3290d1601
Author: Jim Qu <Jim.Qu@amd.com>
Date:   Fri Feb 10 15:59:59 2017 +0800

    drm/amd/amdgpu: post card if there is real hw resetting performed
    
    Check whether we need to post rather than whether the asic is
    posted.  There are some cases (e.g., GPU reset or resume from
    hibernate) where we need to force post even if the asic has
    been posted.
    
    Signed-off-by: Jim Qu <Jim.Qu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 7c39b538dc0e..c4d4b35e54ec 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1176,6 +1176,7 @@ static int cik_gpu_pci_config_reset(struct amdgpu_device *adev)
 		if (RREG32(mmCONFIG_MEMSIZE) != 0xffffffff) {
 			/* enable BM */
 			pci_set_master(adev->pdev);
+			adev->has_hw_reset = true;
 			r = 0;
 			break;
 		}

commit ca6d35031ff08eb2faf7b28115641dc3904609cd
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Wed Jan 25 16:50:15 2017 +0800

    drm/amdgpu: enable vce pg feature on Kv.
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 7da688b0d27d..7c39b538dc0e 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1722,8 +1722,8 @@ static int cik_common_early_init(void *handle)
 			  AMD_PG_SUPPORT_GFX_SMG |
 			  AMD_PG_SUPPORT_GFX_DMG |*/
 			AMD_PG_SUPPORT_UVD |
-			/*AMD_PG_SUPPORT_VCE |
-			  AMD_PG_SUPPORT_CP |
+			AMD_PG_SUPPORT_VCE |
+			/*  AMD_PG_SUPPORT_CP |
 			  AMD_PG_SUPPORT_GDS |
 			  AMD_PG_SUPPORT_RLC_SMU_HS |
 			  AMD_PG_SUPPORT_ACP |

commit c8394f38fa2362385fd34f7034a2276b458c640e
Author: Xiangliang Yu <Xiangliang.Yu@amd.com>
Date:   Mon Jan 9 11:53:14 2017 +0800

    drm/amdgpu: remove detect_hw_virtualization interface
    
    Call detection function driectly, so remove the interface.
    
    V2: ci and si also need to call the detect function.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Monk Liu <monk.liu@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Xiangliang Yu <Xiangliang.Yu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 84d5affce56b..7da688b0d27d 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1634,7 +1634,6 @@ static const struct amdgpu_asic_funcs cik_asic_funcs =
 {
 	.read_disabled_bios = &cik_read_disabled_bios,
 	.read_bios_from_rom = &cik_read_bios_from_rom,
-	.detect_hw_virtualization = cik_detect_hw_virtualization,
 	.read_register = &cik_read_register,
 	.reset = &cik_asic_reset,
 	.set_vga_state = &cik_vga_set_state,
@@ -1890,6 +1889,8 @@ static const struct amdgpu_ip_block_version cik_common_ip_block =
 
 int cik_set_ip_blocks(struct amdgpu_device *adev)
 {
+	cik_detect_hw_virtualization(adev);
+
 	switch (adev->asic_type) {
 	case CHIP_BONAIRE:
 		amdgpu_ip_block_add(adev, &cik_common_ip_block);

commit 5a5099cbf4d8e68bde0554cf6f61bd4adf9fa243
Author: Xiangliang Yu <Xiangliang.Yu@amd.com>
Date:   Mon Jan 9 18:06:57 2017 -0500

    drm/amdgpu/virt: rename fieldes of virtualization structure
    
    Use acronym to rename fields to make easy to spell out.
    
    Signed-off-by: Xiangliang Yu <Xiangliang.Yu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 302df85893ab..84d5affce56b 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1627,7 +1627,7 @@ static uint32_t cik_get_rev_id(struct amdgpu_device *adev)
 static void cik_detect_hw_virtualization(struct amdgpu_device *adev)
 {
 	if (is_virtual_machine()) /* passthrough mode */
-		adev->virtualization.virtual_caps |= AMDGPU_PASSTHROUGH_MODE;
+		adev->virt.caps |= AMDGPU_PASSTHROUGH_MODE;
 }
 
 static const struct amdgpu_asic_funcs cik_asic_funcs =

commit 72a57438d1b4a17dc2f3743fcbb8f0b473a63373
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Oct 21 15:45:22 2016 -0400

    drm/amdgpu: consolidate atom scratch reg handling for hangs
    
    Move from asic specific code to common atom code.
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 1b70f8fa4280..302df85893ab 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1189,18 +1189,6 @@ static int cik_gpu_pci_config_reset(struct amdgpu_device *adev)
 	return r;
 }
 
-static void cik_set_bios_scratch_engine_hung(struct amdgpu_device *adev, bool hung)
-{
-	u32 tmp = RREG32(mmBIOS_SCRATCH_3);
-
-	if (hung)
-		tmp |= ATOM_S3_ASIC_GUI_ENGINE_HUNG;
-	else
-		tmp &= ~ATOM_S3_ASIC_GUI_ENGINE_HUNG;
-
-	WREG32(mmBIOS_SCRATCH_3, tmp);
-}
-
 /**
  * cik_asic_reset - soft reset GPU
  *
@@ -1213,11 +1201,12 @@ static void cik_set_bios_scratch_engine_hung(struct amdgpu_device *adev, bool hu
 static int cik_asic_reset(struct amdgpu_device *adev)
 {
 	int r;
-	cik_set_bios_scratch_engine_hung(adev, true);
+
+	amdgpu_atombios_scratch_regs_engine_hung(adev, true);
 
 	r = cik_gpu_pci_config_reset(adev);
 
-	cik_set_bios_scratch_engine_hung(adev, false);
+	amdgpu_atombios_scratch_regs_engine_hung(adev, false);
 
 	return r;
 }

commit a12551072126758ecb0743147054f22bf233bb7d
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Oct 13 17:41:13 2016 -0400

    drm/amdgpu: rework IP block registration (v2)
    
    This makes it easier to replace specific IP blocks on
    asics for handling virtual_dce, DAL, etc. and for building
    IP lists for hw or tables.  This also stored the status
    information in the same structure.
    
    v2: split out spelling fix into a separate patch
        add a function to add IPs to the list
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index a845b6a93b79..1b70f8fa4280 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1641,745 +1641,6 @@ static void cik_detect_hw_virtualization(struct amdgpu_device *adev)
 		adev->virtualization.virtual_caps |= AMDGPU_PASSTHROUGH_MODE;
 }
 
-static const struct amdgpu_ip_block_version bonaire_ip_blocks[] =
-{
-	/* ORDER MATTERS! */
-	{
-		.type = AMD_IP_BLOCK_TYPE_COMMON,
-		.major = 1,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_common_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &gmc_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_IH,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_ih_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &amdgpu_pp_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_DCE,
-		.major = 8,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &dce_v8_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GFX,
-		.major = 7,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &gfx_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SDMA,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_sdma_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_UVD,
-		.major = 4,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &uvd_v4_2_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_VCE,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &vce_v2_0_ip_funcs,
-	},
-};
-
-static const struct amdgpu_ip_block_version bonaire_ip_blocks_vd[] =
-{
-	/* ORDER MATTERS! */
-	{
-		.type = AMD_IP_BLOCK_TYPE_COMMON,
-		.major = 1,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_common_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &gmc_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_IH,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_ih_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &amdgpu_pp_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_DCE,
-		.major = 8,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &dce_virtual_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GFX,
-		.major = 7,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &gfx_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SDMA,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_sdma_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_UVD,
-		.major = 4,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &uvd_v4_2_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_VCE,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &vce_v2_0_ip_funcs,
-	},
-};
-
-static const struct amdgpu_ip_block_version hawaii_ip_blocks[] =
-{
-	/* ORDER MATTERS! */
-	{
-		.type = AMD_IP_BLOCK_TYPE_COMMON,
-		.major = 1,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_common_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &gmc_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_IH,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_ih_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &amdgpu_pp_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_DCE,
-		.major = 8,
-		.minor = 5,
-		.rev = 0,
-		.funcs = &dce_v8_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GFX,
-		.major = 7,
-		.minor = 3,
-		.rev = 0,
-		.funcs = &gfx_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SDMA,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_sdma_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_UVD,
-		.major = 4,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &uvd_v4_2_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_VCE,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &vce_v2_0_ip_funcs,
-	},
-};
-
-static const struct amdgpu_ip_block_version hawaii_ip_blocks_vd[] =
-{
-	/* ORDER MATTERS! */
-	{
-		.type = AMD_IP_BLOCK_TYPE_COMMON,
-		.major = 1,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_common_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &gmc_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_IH,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_ih_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &amdgpu_pp_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_DCE,
-		.major = 8,
-		.minor = 5,
-		.rev = 0,
-		.funcs = &dce_virtual_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GFX,
-		.major = 7,
-		.minor = 3,
-		.rev = 0,
-		.funcs = &gfx_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SDMA,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_sdma_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_UVD,
-		.major = 4,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &uvd_v4_2_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_VCE,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &vce_v2_0_ip_funcs,
-	},
-};
-
-static const struct amdgpu_ip_block_version kabini_ip_blocks[] =
-{
-	/* ORDER MATTERS! */
-	{
-		.type = AMD_IP_BLOCK_TYPE_COMMON,
-		.major = 1,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_common_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &gmc_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_IH,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_ih_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &amdgpu_pp_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_DCE,
-		.major = 8,
-		.minor = 3,
-		.rev = 0,
-		.funcs = &dce_v8_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GFX,
-		.major = 7,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &gfx_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SDMA,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_sdma_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_UVD,
-		.major = 4,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &uvd_v4_2_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_VCE,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &vce_v2_0_ip_funcs,
-	},
-};
-
-static const struct amdgpu_ip_block_version kabini_ip_blocks_vd[] =
-{
-	/* ORDER MATTERS! */
-	{
-		.type = AMD_IP_BLOCK_TYPE_COMMON,
-		.major = 1,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_common_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &gmc_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_IH,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_ih_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &amdgpu_pp_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_DCE,
-		.major = 8,
-		.minor = 3,
-		.rev = 0,
-		.funcs = &dce_virtual_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GFX,
-		.major = 7,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &gfx_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SDMA,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_sdma_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_UVD,
-		.major = 4,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &uvd_v4_2_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_VCE,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &vce_v2_0_ip_funcs,
-	},
-};
-
-static const struct amdgpu_ip_block_version mullins_ip_blocks[] =
-{
-	/* ORDER MATTERS! */
-	{
-		.type = AMD_IP_BLOCK_TYPE_COMMON,
-		.major = 1,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_common_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &gmc_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_IH,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_ih_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &amdgpu_pp_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_DCE,
-		.major = 8,
-		.minor = 3,
-		.rev = 0,
-		.funcs = &dce_v8_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GFX,
-		.major = 7,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &gfx_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SDMA,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_sdma_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_UVD,
-		.major = 4,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &uvd_v4_2_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_VCE,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &vce_v2_0_ip_funcs,
-	},
-};
-
-static const struct amdgpu_ip_block_version mullins_ip_blocks_vd[] =
-{
-	/* ORDER MATTERS! */
-	{
-		.type = AMD_IP_BLOCK_TYPE_COMMON,
-		.major = 1,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_common_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &gmc_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_IH,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_ih_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &amdgpu_pp_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_DCE,
-		.major = 8,
-		.minor = 3,
-		.rev = 0,
-		.funcs = &dce_virtual_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GFX,
-		.major = 7,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &gfx_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SDMA,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_sdma_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_UVD,
-		.major = 4,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &uvd_v4_2_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_VCE,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &vce_v2_0_ip_funcs,
-	},
-};
-
-static const struct amdgpu_ip_block_version kaveri_ip_blocks[] =
-{
-	/* ORDER MATTERS! */
-	{
-		.type = AMD_IP_BLOCK_TYPE_COMMON,
-		.major = 1,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_common_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &gmc_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_IH,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_ih_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &amdgpu_pp_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_DCE,
-		.major = 8,
-		.minor = 1,
-		.rev = 0,
-		.funcs = &dce_v8_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GFX,
-		.major = 7,
-		.minor = 1,
-		.rev = 0,
-		.funcs = &gfx_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SDMA,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_sdma_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_UVD,
-		.major = 4,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &uvd_v4_2_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_VCE,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &vce_v2_0_ip_funcs,
-	},
-};
-
-static const struct amdgpu_ip_block_version kaveri_ip_blocks_vd[] =
-{
-	/* ORDER MATTERS! */
-	{
-		.type = AMD_IP_BLOCK_TYPE_COMMON,
-		.major = 1,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_common_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &gmc_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_IH,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_ih_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SMC,
-		.major = 7,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &amdgpu_pp_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_DCE,
-		.major = 8,
-		.minor = 1,
-		.rev = 0,
-		.funcs = &dce_virtual_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_GFX,
-		.major = 7,
-		.minor = 1,
-		.rev = 0,
-		.funcs = &gfx_v7_0_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_SDMA,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &cik_sdma_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_UVD,
-		.major = 4,
-		.minor = 2,
-		.rev = 0,
-		.funcs = &uvd_v4_2_ip_funcs,
-	},
-	{
-		.type = AMD_IP_BLOCK_TYPE_VCE,
-		.major = 2,
-		.minor = 0,
-		.rev = 0,
-		.funcs = &vce_v2_0_ip_funcs,
-	},
-};
-
-int cik_set_ip_blocks(struct amdgpu_device *adev)
-{
-	if (adev->enable_virtual_display) {
-		switch (adev->asic_type) {
-		case CHIP_BONAIRE:
-			adev->ip_blocks = bonaire_ip_blocks_vd;
-			adev->num_ip_blocks = ARRAY_SIZE(bonaire_ip_blocks_vd);
-			break;
-		case CHIP_HAWAII:
-			adev->ip_blocks = hawaii_ip_blocks_vd;
-			adev->num_ip_blocks = ARRAY_SIZE(hawaii_ip_blocks_vd);
-			break;
-		case CHIP_KAVERI:
-			adev->ip_blocks = kaveri_ip_blocks_vd;
-			adev->num_ip_blocks = ARRAY_SIZE(kaveri_ip_blocks_vd);
-			break;
-		case CHIP_KABINI:
-			adev->ip_blocks = kabini_ip_blocks_vd;
-			adev->num_ip_blocks = ARRAY_SIZE(kabini_ip_blocks_vd);
-			break;
-		case CHIP_MULLINS:
-			adev->ip_blocks = mullins_ip_blocks_vd;
-			adev->num_ip_blocks = ARRAY_SIZE(mullins_ip_blocks_vd);
-			break;
-		default:
-			/* FIXME: not supported yet */
-			return -EINVAL;
-		}
-	} else {
-		switch (adev->asic_type) {
-		case CHIP_BONAIRE:
-			adev->ip_blocks = bonaire_ip_blocks;
-			adev->num_ip_blocks = ARRAY_SIZE(bonaire_ip_blocks);
-			break;
-		case CHIP_HAWAII:
-			adev->ip_blocks = hawaii_ip_blocks;
-			adev->num_ip_blocks = ARRAY_SIZE(hawaii_ip_blocks);
-			break;
-		case CHIP_KAVERI:
-			adev->ip_blocks = kaveri_ip_blocks;
-			adev->num_ip_blocks = ARRAY_SIZE(kaveri_ip_blocks);
-			break;
-		case CHIP_KABINI:
-			adev->ip_blocks = kabini_ip_blocks;
-			adev->num_ip_blocks = ARRAY_SIZE(kabini_ip_blocks);
-			break;
-		case CHIP_MULLINS:
-			adev->ip_blocks = mullins_ip_blocks;
-			adev->num_ip_blocks = ARRAY_SIZE(mullins_ip_blocks);
-			break;
-		default:
-			/* FIXME: not supported yet */
-			return -EINVAL;
-		}
-	}
-
-	return 0;
-}
-
 static const struct amdgpu_asic_funcs cik_asic_funcs =
 {
 	.read_disabled_bios = &cik_read_disabled_bios,
@@ -2612,7 +1873,7 @@ static int cik_common_set_powergating_state(void *handle,
 	return 0;
 }
 
-const struct amd_ip_funcs cik_common_ip_funcs = {
+static const struct amd_ip_funcs cik_common_ip_funcs = {
 	.name = "cik_common",
 	.early_init = cik_common_early_init,
 	.late_init = NULL,
@@ -2628,3 +1889,79 @@ const struct amd_ip_funcs cik_common_ip_funcs = {
 	.set_clockgating_state = cik_common_set_clockgating_state,
 	.set_powergating_state = cik_common_set_powergating_state,
 };
+
+static const struct amdgpu_ip_block_version cik_common_ip_block =
+{
+	.type = AMD_IP_BLOCK_TYPE_COMMON,
+	.major = 1,
+	.minor = 0,
+	.rev = 0,
+	.funcs = &cik_common_ip_funcs,
+};
+
+int cik_set_ip_blocks(struct amdgpu_device *adev)
+{
+	switch (adev->asic_type) {
+	case CHIP_BONAIRE:
+		amdgpu_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_ip_block_add(adev, &cik_ih_ip_block);
+		amdgpu_ip_block_add(adev, &amdgpu_pp_ip_block);
+		if (adev->enable_virtual_display)
+			amdgpu_ip_block_add(adev, &dce_virtual_ip_block);
+		else
+			amdgpu_ip_block_add(adev, &dce_v8_2_ip_block);
+		amdgpu_ip_block_add(adev, &gfx_v7_2_ip_block);
+		amdgpu_ip_block_add(adev, &cik_sdma_ip_block);
+		amdgpu_ip_block_add(adev, &uvd_v4_2_ip_block);
+		amdgpu_ip_block_add(adev, &vce_v2_0_ip_block);
+		break;
+	case CHIP_HAWAII:
+		amdgpu_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_ip_block_add(adev, &cik_ih_ip_block);
+		amdgpu_ip_block_add(adev, &amdgpu_pp_ip_block);
+		if (adev->enable_virtual_display)
+			amdgpu_ip_block_add(adev, &dce_virtual_ip_block);
+		else
+			amdgpu_ip_block_add(adev, &dce_v8_5_ip_block);
+		amdgpu_ip_block_add(adev, &gfx_v7_3_ip_block);
+		amdgpu_ip_block_add(adev, &cik_sdma_ip_block);
+		amdgpu_ip_block_add(adev, &uvd_v4_2_ip_block);
+		amdgpu_ip_block_add(adev, &vce_v2_0_ip_block);
+		break;
+	case CHIP_KAVERI:
+		amdgpu_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_ip_block_add(adev, &cik_ih_ip_block);
+		amdgpu_ip_block_add(adev, &amdgpu_pp_ip_block);
+		if (adev->enable_virtual_display)
+			amdgpu_ip_block_add(adev, &dce_virtual_ip_block);
+		else
+			amdgpu_ip_block_add(adev, &dce_v8_1_ip_block);
+		amdgpu_ip_block_add(adev, &gfx_v7_1_ip_block);
+		amdgpu_ip_block_add(adev, &cik_sdma_ip_block);
+		amdgpu_ip_block_add(adev, &uvd_v4_2_ip_block);
+		amdgpu_ip_block_add(adev, &vce_v2_0_ip_block);
+		break;
+	case CHIP_KABINI:
+	case CHIP_MULLINS:
+		amdgpu_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_ip_block_add(adev, &cik_ih_ip_block);
+		amdgpu_ip_block_add(adev, &amdgpu_pp_ip_block);
+		if (adev->enable_virtual_display)
+			amdgpu_ip_block_add(adev, &dce_virtual_ip_block);
+		else
+			amdgpu_ip_block_add(adev, &dce_v8_3_ip_block);
+		amdgpu_ip_block_add(adev, &gfx_v7_2_ip_block);
+		amdgpu_ip_block_add(adev, &cik_sdma_ip_block);
+		amdgpu_ip_block_add(adev, &uvd_v4_2_ip_block);
+		amdgpu_ip_block_add(adev, &vce_v2_0_ip_block);
+		break;
+	default:
+		/* FIXME: not supported yet */
+		return -EINVAL;
+	}
+	return 0;
+}

commit 4e99a44e37bfed8c4f25c94687e8e4ac4ae65086
Author: Monk Liu <Monk.Liu@amd.com>
Date:   Thu Mar 31 13:26:59 2016 +0800

    drm/amdgpu:changes of virtualization cases probe (v3)
    
    1,Changes on virtualization detections
    2,Don't load smu & mc firmware if using sr-iov bios
    3,skip vPost for sriov & force vPost if dev pass-through
    
    v2: agd: squash in Rays's fix for the missed SI case
    v3: agd: squash in additional fixes for CIK, SI, cleanup
    
    Signed-off-by: Monk Liu <Monk.Liu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 825de800b798..a845b6a93b79 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -963,12 +963,6 @@ static bool cik_read_bios_from_rom(struct amdgpu_device *adev,
 	return true;
 }
 
-static u32 cik_get_virtual_caps(struct amdgpu_device *adev)
-{
-	/* CIK does not support SR-IOV */
-	return 0;
-}
-
 static const struct amdgpu_allowed_register_entry cik_allowed_read_registers[] = {
 	{mmGRBM_STATUS, false},
 	{mmGB_ADDR_CONFIG, false},
@@ -1641,6 +1635,12 @@ static uint32_t cik_get_rev_id(struct amdgpu_device *adev)
 		>> CC_DRM_ID_STRAPS__ATI_REV_ID__SHIFT;
 }
 
+static void cik_detect_hw_virtualization(struct amdgpu_device *adev)
+{
+	if (is_virtual_machine()) /* passthrough mode */
+		adev->virtualization.virtual_caps |= AMDGPU_PASSTHROUGH_MODE;
+}
+
 static const struct amdgpu_ip_block_version bonaire_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
@@ -2384,13 +2384,13 @@ static const struct amdgpu_asic_funcs cik_asic_funcs =
 {
 	.read_disabled_bios = &cik_read_disabled_bios,
 	.read_bios_from_rom = &cik_read_bios_from_rom,
+	.detect_hw_virtualization = cik_detect_hw_virtualization,
 	.read_register = &cik_read_register,
 	.reset = &cik_asic_reset,
 	.set_vga_state = &cik_vga_set_state,
 	.get_xclk = &cik_get_xclk,
 	.set_uvd_clocks = &cik_set_uvd_clocks,
 	.set_vce_clocks = &cik_set_vce_clocks,
-	.get_virtual_caps = &cik_get_virtual_caps,
 };
 
 static int cik_common_early_init(void *handle)

commit 9accf2fd33e969862c55be0c20dbfb9b0890bbb8
Author: Emily Deng <Emily.Deng@amd.com>
Date:   Wed Aug 10 16:01:25 2016 +0800

    drm/amdgpu: Change the virtual_display type from int to char*.
    
    For virtual display feature, as there may be multiple GPUs,
    for user could choose whiche GPU need to enable this feature, change
    the type of virtual_display from int to char*. The variable will be set
    like this virtual_display="xxxx:xx:xx.x;xxxx:xx:xx.x;".
    
    Signed-off-by: Emily Deng <Emily.Deng@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index e539b28dbef7..825de800b798 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -2323,7 +2323,7 @@ static const struct amdgpu_ip_block_version kaveri_ip_blocks_vd[] =
 
 int cik_set_ip_blocks(struct amdgpu_device *adev)
 {
-	if (amdgpu_virtual_display) {
+	if (adev->enable_virtual_display) {
 		switch (adev->asic_type) {
 		case CHIP_BONAIRE:
 			adev->ip_blocks = bonaire_ip_blocks_vd;

commit d06b7e1cf0fa4552fd725111b46df1ed0b649b15
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Aug 8 14:35:55 2016 -0400

    drm/amdgpu: move vsync_timer_enabled setup to dce virtual early_init
    
    Put it in one place.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 15200b1b77d6..e539b28dbef7 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -2324,7 +2324,6 @@ static const struct amdgpu_ip_block_version kaveri_ip_blocks_vd[] =
 int cik_set_ip_blocks(struct amdgpu_device *adev)
 {
 	if (amdgpu_virtual_display) {
-		adev->mode_info.vsync_timer_enabled = AMDGPU_IRQ_STATE_DISABLE;
 		switch (adev->asic_type) {
 		case CHIP_BONAIRE:
 			adev->ip_blocks = bonaire_ip_blocks_vd;

commit a6be7570518f85ce94ca9d6540543e00725828d3
Author: Emily Deng <Emily.Deng@amd.com>
Date:   Mon Aug 8 11:37:50 2016 +0800

    drm/amdgpu: Set ip_blocks according variable amdgpu_virtual_display.
    
    For virtual display feature, if user set the option "amdgpu.virtual_display=1"
    when load amdgpu.ko. Then need to set the ip_blocks with virtual display ip
    blocks. And when enable virtual display, the amdgpu_dal need to be set to zero.
    
    Signed-off-by: Emily Deng <Emily.Deng@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index edcc14287d2d..15200b1b77d6 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -2323,30 +2323,59 @@ static const struct amdgpu_ip_block_version kaveri_ip_blocks_vd[] =
 
 int cik_set_ip_blocks(struct amdgpu_device *adev)
 {
-	switch (adev->asic_type) {
-	case CHIP_BONAIRE:
-		adev->ip_blocks = bonaire_ip_blocks;
-		adev->num_ip_blocks = ARRAY_SIZE(bonaire_ip_blocks);
-		break;
-	case CHIP_HAWAII:
-		adev->ip_blocks = hawaii_ip_blocks;
-		adev->num_ip_blocks = ARRAY_SIZE(hawaii_ip_blocks);
-		break;
-	case CHIP_KAVERI:
-		adev->ip_blocks = kaveri_ip_blocks;
-		adev->num_ip_blocks = ARRAY_SIZE(kaveri_ip_blocks);
-		break;
-	case CHIP_KABINI:
-		adev->ip_blocks = kabini_ip_blocks;
-		adev->num_ip_blocks = ARRAY_SIZE(kabini_ip_blocks);
-		break;
-	case CHIP_MULLINS:
-		adev->ip_blocks = mullins_ip_blocks;
-		adev->num_ip_blocks = ARRAY_SIZE(mullins_ip_blocks);
-		break;
-	default:
-		/* FIXME: not supported yet */
-		return -EINVAL;
+	if (amdgpu_virtual_display) {
+		adev->mode_info.vsync_timer_enabled = AMDGPU_IRQ_STATE_DISABLE;
+		switch (adev->asic_type) {
+		case CHIP_BONAIRE:
+			adev->ip_blocks = bonaire_ip_blocks_vd;
+			adev->num_ip_blocks = ARRAY_SIZE(bonaire_ip_blocks_vd);
+			break;
+		case CHIP_HAWAII:
+			adev->ip_blocks = hawaii_ip_blocks_vd;
+			adev->num_ip_blocks = ARRAY_SIZE(hawaii_ip_blocks_vd);
+			break;
+		case CHIP_KAVERI:
+			adev->ip_blocks = kaveri_ip_blocks_vd;
+			adev->num_ip_blocks = ARRAY_SIZE(kaveri_ip_blocks_vd);
+			break;
+		case CHIP_KABINI:
+			adev->ip_blocks = kabini_ip_blocks_vd;
+			adev->num_ip_blocks = ARRAY_SIZE(kabini_ip_blocks_vd);
+			break;
+		case CHIP_MULLINS:
+			adev->ip_blocks = mullins_ip_blocks_vd;
+			adev->num_ip_blocks = ARRAY_SIZE(mullins_ip_blocks_vd);
+			break;
+		default:
+			/* FIXME: not supported yet */
+			return -EINVAL;
+		}
+	} else {
+		switch (adev->asic_type) {
+		case CHIP_BONAIRE:
+			adev->ip_blocks = bonaire_ip_blocks;
+			adev->num_ip_blocks = ARRAY_SIZE(bonaire_ip_blocks);
+			break;
+		case CHIP_HAWAII:
+			adev->ip_blocks = hawaii_ip_blocks;
+			adev->num_ip_blocks = ARRAY_SIZE(hawaii_ip_blocks);
+			break;
+		case CHIP_KAVERI:
+			adev->ip_blocks = kaveri_ip_blocks;
+			adev->num_ip_blocks = ARRAY_SIZE(kaveri_ip_blocks);
+			break;
+		case CHIP_KABINI:
+			adev->ip_blocks = kabini_ip_blocks;
+			adev->num_ip_blocks = ARRAY_SIZE(kabini_ip_blocks);
+			break;
+		case CHIP_MULLINS:
+			adev->ip_blocks = mullins_ip_blocks;
+			adev->num_ip_blocks = ARRAY_SIZE(mullins_ip_blocks);
+			break;
+		default:
+			/* FIXME: not supported yet */
+			return -EINVAL;
+		}
 	}
 
 	return 0;

commit e9ed3a67cd1bfd8d0d0dc4968a36f6ea4db2d45a
Author: Emily Deng <Emily.Deng@amd.com>
Date:   Mon Aug 8 11:36:45 2016 +0800

    drm/amdgpu: Define virtual display ip blocks.
    
    For virtual display feature, define virtual display ip blocks, and set
    dce_virtual_ip_funcs to DCE block.
    
    Signed-off-by: Emily Deng <Emily.Deng@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 4efc901f658c..edcc14287d2d 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -67,6 +67,7 @@
 
 #include "amdgpu_amdkfd.h"
 #include "amdgpu_powerplay.h"
+#include "dce_virtual.h"
 
 /*
  * Indirect registers accessor
@@ -1708,6 +1709,74 @@ static const struct amdgpu_ip_block_version bonaire_ip_blocks[] =
 	},
 };
 
+static const struct amdgpu_ip_block_version bonaire_ip_blocks_vd[] =
+{
+	/* ORDER MATTERS! */
+	{
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
+		.major = 1,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_common_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_GMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &gmc_v7_0_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_IH,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_ih_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_SMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &amdgpu_pp_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_DCE,
+		.major = 8,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &dce_virtual_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_GFX,
+		.major = 7,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &gfx_v7_0_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_sdma_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_UVD,
+		.major = 4,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &uvd_v4_2_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_VCE,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &vce_v2_0_ip_funcs,
+	},
+};
+
 static const struct amdgpu_ip_block_version hawaii_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
@@ -1776,6 +1845,74 @@ static const struct amdgpu_ip_block_version hawaii_ip_blocks[] =
 	},
 };
 
+static const struct amdgpu_ip_block_version hawaii_ip_blocks_vd[] =
+{
+	/* ORDER MATTERS! */
+	{
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
+		.major = 1,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_common_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_GMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &gmc_v7_0_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_IH,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_ih_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_SMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &amdgpu_pp_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_DCE,
+		.major = 8,
+		.minor = 5,
+		.rev = 0,
+		.funcs = &dce_virtual_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_GFX,
+		.major = 7,
+		.minor = 3,
+		.rev = 0,
+		.funcs = &gfx_v7_0_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_sdma_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_UVD,
+		.major = 4,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &uvd_v4_2_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_VCE,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &vce_v2_0_ip_funcs,
+	},
+};
+
 static const struct amdgpu_ip_block_version kabini_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
@@ -1844,6 +1981,74 @@ static const struct amdgpu_ip_block_version kabini_ip_blocks[] =
 	},
 };
 
+static const struct amdgpu_ip_block_version kabini_ip_blocks_vd[] =
+{
+	/* ORDER MATTERS! */
+	{
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
+		.major = 1,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_common_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_GMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &gmc_v7_0_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_IH,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_ih_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_SMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &amdgpu_pp_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_DCE,
+		.major = 8,
+		.minor = 3,
+		.rev = 0,
+		.funcs = &dce_virtual_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_GFX,
+		.major = 7,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &gfx_v7_0_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_sdma_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_UVD,
+		.major = 4,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &uvd_v4_2_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_VCE,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &vce_v2_0_ip_funcs,
+	},
+};
+
 static const struct amdgpu_ip_block_version mullins_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
@@ -1912,6 +2117,74 @@ static const struct amdgpu_ip_block_version mullins_ip_blocks[] =
 	},
 };
 
+static const struct amdgpu_ip_block_version mullins_ip_blocks_vd[] =
+{
+	/* ORDER MATTERS! */
+	{
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
+		.major = 1,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_common_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_GMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &gmc_v7_0_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_IH,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_ih_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_SMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &amdgpu_pp_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_DCE,
+		.major = 8,
+		.minor = 3,
+		.rev = 0,
+		.funcs = &dce_virtual_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_GFX,
+		.major = 7,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &gfx_v7_0_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_sdma_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_UVD,
+		.major = 4,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &uvd_v4_2_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_VCE,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &vce_v2_0_ip_funcs,
+	},
+};
+
 static const struct amdgpu_ip_block_version kaveri_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
@@ -1980,6 +2253,74 @@ static const struct amdgpu_ip_block_version kaveri_ip_blocks[] =
 	},
 };
 
+static const struct amdgpu_ip_block_version kaveri_ip_blocks_vd[] =
+{
+	/* ORDER MATTERS! */
+	{
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
+		.major = 1,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_common_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_GMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &gmc_v7_0_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_IH,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_ih_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_SMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &amdgpu_pp_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_DCE,
+		.major = 8,
+		.minor = 1,
+		.rev = 0,
+		.funcs = &dce_virtual_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_GFX,
+		.major = 7,
+		.minor = 1,
+		.rev = 0,
+		.funcs = &gfx_v7_0_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_sdma_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_UVD,
+		.major = 4,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &uvd_v4_2_ip_funcs,
+	},
+	{
+		.type = AMD_IP_BLOCK_TYPE_VCE,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &vce_v2_0_ip_funcs,
+	},
+};
+
 int cik_set_ip_blocks(struct amdgpu_device *adev)
 {
 	switch (adev->asic_type) {

commit 004e29ccf034ea1fb08e77b76106891bb88fae6f
Author: Edward O'Callaghan <funfunctor@folklore1984.net>
Date:   Tue Jul 12 10:17:53 2016 +1000

    drivers/amdgpu: Use canonical form in branch predicates
    
    Found-by: Coccinelle
    Signed-off-by: Edward O'Callaghan <funfunctor@folklore1984.net>
    Reviewed-by: Tom St Denis <tom.stdenis@amd.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index a7de4d18ac94..4efc901f658c 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -879,7 +879,7 @@ static void cik_vga_set_state(struct amdgpu_device *adev, bool state)
 	uint32_t tmp;
 
 	tmp = RREG32(mmCONFIG_CNTL);
-	if (state == false)
+	if (!state)
 		tmp |= CONFIG_CNTL__VGA_DIS_MASK;
 	else
 		tmp &= ~CONFIG_CNTL__VGA_DIS_MASK;

commit 9559ef5b1287aaffd8fcb5a5d4bbebaee5c1dd4e
Author: Tom St Denis <tom.stdenis@amd.com>
Date:   Tue Jun 28 10:26:48 2016 -0400

    drm/amd/gfx: add instance field to select_se_sh (v3)
    
    Add ability to specify instance in select_se_sh callback.
    Defaults to 0xffffffff all over the driver.
    
    (v2) Don't enable INSTANCE_BROADCAST by default
    (v3) Style changes
    
    Signed-off-by: Tom St Denis <tom.stdenis@amd.com>
    Reviewed-by: Nicolai Hähnle <nicolai.haehnle@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 7513710fe8fb..a7de4d18ac94 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1035,12 +1035,12 @@ static uint32_t cik_read_indexed_register(struct amdgpu_device *adev,
 
 	mutex_lock(&adev->grbm_idx_mutex);
 	if (se_num != 0xffffffff || sh_num != 0xffffffff)
-		amdgpu_gfx_select_se_sh(adev, se_num, sh_num);
+		amdgpu_gfx_select_se_sh(adev, se_num, sh_num, 0xffffffff);
 
 	val = RREG32(reg_offset);
 
 	if (se_num != 0xffffffff || sh_num != 0xffffffff)
-		amdgpu_gfx_select_se_sh(adev, 0xffffffff, 0xffffffff);
+		amdgpu_gfx_select_se_sh(adev, 0xffffffff, 0xffffffff, 0xffffffff);
 	mutex_unlock(&adev->grbm_idx_mutex);
 	return val;
 }

commit 05fb7291fd8044857812a06055cc94d7d374fd74
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jun 21 12:00:55 2016 -0400

    drm/amdgpu: move select_se_sh into the gfx struct
    
    It's gfx IP specific, not asic specific, so move to a
    gfx callback.
    
    Reviewed-by: Chunming Zhou <david1.zhou@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 207fdfcd6261..7513710fe8fb 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1035,12 +1035,12 @@ static uint32_t cik_read_indexed_register(struct amdgpu_device *adev,
 
 	mutex_lock(&adev->grbm_idx_mutex);
 	if (se_num != 0xffffffff || sh_num != 0xffffffff)
-		gfx_v7_0_select_se_sh(adev, se_num, sh_num);
+		amdgpu_gfx_select_se_sh(adev, se_num, sh_num);
 
 	val = RREG32(reg_offset);
 
 	if (se_num != 0xffffffff || sh_num != 0xffffffff)
-		gfx_v7_0_select_se_sh(adev, 0xffffffff, 0xffffffff);
+		amdgpu_gfx_select_se_sh(adev, 0xffffffff, 0xffffffff);
 	mutex_unlock(&adev->grbm_idx_mutex);
 	return val;
 }

commit b95e31fddabbc38f96c8e991dd7132cea252bf7d
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Jul 7 15:01:42 2016 -0400

    drm/amdgpu: move get_gpu_clock_counter into the gfx struct
    
    It's gfx IP specific, not asic specific, so move to a
    gfx callback.
    
    Reviewed-by: Chunming Zhou <david1.zhou@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index c90bfeec3048..207fdfcd6261 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -2022,8 +2022,6 @@ static const struct amdgpu_asic_funcs cik_asic_funcs =
 	.set_uvd_clocks = &cik_set_uvd_clocks,
 	.set_vce_clocks = &cik_set_vce_clocks,
 	.get_virtual_caps = &cik_get_virtual_caps,
-	/* these should be moved to their own ip modules */
-	.get_gpu_clock_counter = &gfx_v7_0_get_gpu_clock_counter,
 };
 
 static int cik_common_early_init(void *handle)

commit 4b7d97ac835ee96e46538a1fea38021988440301
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jun 21 11:35:36 2016 -0400

    drm/amdgpu: drop wait_for_mc_idle asic callback
    
    Only used in the gmc IP modules so just call the local
    function directly.
    
    Reviewed-by: Chunming Zhou <david1.zhou@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 4c80338992ad..c90bfeec3048 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -2024,7 +2024,6 @@ static const struct amdgpu_asic_funcs cik_asic_funcs =
 	.get_virtual_caps = &cik_get_virtual_caps,
 	/* these should be moved to their own ip modules */
 	.get_gpu_clock_counter = &gfx_v7_0_get_gpu_clock_counter,
-	.wait_for_mc_idle = &gmc_v7_0_mc_wait_for_idle,
 };
 
 static int cik_common_early_init(void *handle)

commit b314f9a997dd1d1e1fb607b68387c1e92e914e66
Author: Chunming Zhou <David1.Zhou@amd.com>
Date:   Mon Jun 6 13:50:18 2016 +0800

    drm/amdgpu: enable BUS master after pci reset
    
    Re-enable bus mastering after GPU reset. We disable it
    at the top of these functions, so balance them by
    re-enabling it.
    
    Signed-off-by: Chunming Zhou <David1.Zhou@amd.com>
    eviewed-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 4c21c881ef41..4c80338992ad 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1179,6 +1179,8 @@ static int cik_gpu_pci_config_reset(struct amdgpu_device *adev)
 	/* wait for asic to come out of reset */
 	for (i = 0; i < adev->usec_timeout; i++) {
 		if (RREG32(mmCONFIG_MEMSIZE) != 0xffffffff) {
+			/* enable BM */
+			pci_set_master(adev->pdev);
 			r = 0;
 			break;
 		}

commit 89a31827374b9301f549d5ce40dc3529b5b757fd
Author: Chunming Zhou <David1.Zhou@amd.com>
Date:   Mon Jun 6 13:06:45 2016 +0800

    drm/amdgpu: add return value for pci config reset
    
    So we know whether or not the reset succeeded.
    
    Signed-off-by: Chunming Zhou <David1.Zhou@amd.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 910431808542..4c21c881ef41 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1158,10 +1158,11 @@ static void kv_restore_regs_for_reset(struct amdgpu_device *adev,
 	WREG32(mmGMCON_RENG_EXECUTE, save->gmcon_reng_execute);
 }
 
-static void cik_gpu_pci_config_reset(struct amdgpu_device *adev)
+static int cik_gpu_pci_config_reset(struct amdgpu_device *adev)
 {
 	struct kv_reset_save_regs kv_save = { 0 };
 	u32 i;
+	int r = -EINVAL;
 
 	dev_info(adev->dev, "GPU pci config reset\n");
 
@@ -1177,14 +1178,18 @@ static void cik_gpu_pci_config_reset(struct amdgpu_device *adev)
 
 	/* wait for asic to come out of reset */
 	for (i = 0; i < adev->usec_timeout; i++) {
-		if (RREG32(mmCONFIG_MEMSIZE) != 0xffffffff)
+		if (RREG32(mmCONFIG_MEMSIZE) != 0xffffffff) {
+			r = 0;
 			break;
+		}
 		udelay(1);
 	}
 
 	/* does asic init need to be run first??? */
 	if (adev->flags & AMD_IS_APU)
 		kv_restore_regs_for_reset(adev, &kv_save);
+
+	return r;
 }
 
 static void cik_set_bios_scratch_engine_hung(struct amdgpu_device *adev, bool hung)
@@ -1210,13 +1215,14 @@ static void cik_set_bios_scratch_engine_hung(struct amdgpu_device *adev, bool hu
  */
 static int cik_asic_reset(struct amdgpu_device *adev)
 {
+	int r;
 	cik_set_bios_scratch_engine_hung(adev, true);
 
-	cik_gpu_pci_config_reset(adev);
+	r = cik_gpu_pci_config_reset(adev);
 
 	cik_set_bios_scratch_engine_hung(adev, false);
 
-	return 0;
+	return r;
 }
 
 static int cik_set_uvd_clock(struct amdgpu_device *adev, u32 clock,

commit 048765ad5af7c8939603b4c6cb96293ffa05e00d
Author: Andres Rodriguez <andres.rodriguez@amd.com>
Date:   Sat Jun 11 02:51:32 2016 -0400

    amdgpu: fix asic initialization for virtualized environments (v2)
    
    When executing in a PCI passthrough based virtuzliation environemnt, the
    hypervisor will usually attempt to send a PCIe bus reset signal to the
    ASIC when the VM reboots. In this scenario, the card is not correctly
    initialized, but we still consider it to be posted. Therefore, in a
    passthrough based environemnt we should always post the card to guarantee
    it is in a good state for driver initialization.
    
    However, if we are operating in SR-IOV mode it is up to the GIM driver
    to manage the asic state, therefore we should not post the card (and
    shouldn't be able to do it either).
    
    v2: add missing semi-colon
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Andres Rodriguez <andres.rodriguez@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 07bc795a4ca9..910431808542 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -962,6 +962,12 @@ static bool cik_read_bios_from_rom(struct amdgpu_device *adev,
 	return true;
 }
 
+static u32 cik_get_virtual_caps(struct amdgpu_device *adev)
+{
+	/* CIK does not support SR-IOV */
+	return 0;
+}
+
 static const struct amdgpu_allowed_register_entry cik_allowed_read_registers[] = {
 	{mmGRBM_STATUS, false},
 	{mmGB_ADDR_CONFIG, false},
@@ -2007,6 +2013,7 @@ static const struct amdgpu_asic_funcs cik_asic_funcs =
 	.get_xclk = &cik_get_xclk,
 	.set_uvd_clocks = &cik_set_uvd_clocks,
 	.set_vce_clocks = &cik_set_vce_clocks,
+	.get_virtual_caps = &cik_get_virtual_caps,
 	/* these should be moved to their own ip modules */
 	.get_gpu_clock_counter = &gfx_v7_0_get_gpu_clock_counter,
 	.wait_for_mc_idle = &gmc_v7_0_mc_wait_for_idle,

commit 88a907d67c03e80a71c49681bbccf3bfebe74ab4
Author: Tom St Denis <tom.stdenis@amd.com>
Date:   Wed May 4 14:28:35 2016 -0400

    drm/amd/amdgpu: Add name field to amd_ip_funcs (v2)
    
    Add name that we can print out in kernel messages
    to aid in debugging.
    
    v2: drop DAL changes for upstream
    
    Signed-off-by: Tom St Denis <tom.stdenis@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 68e569853c95..07bc795a4ca9 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -2232,6 +2232,7 @@ static int cik_common_set_powergating_state(void *handle,
 }
 
 const struct amd_ip_funcs cik_common_ip_funcs = {
+	.name = "cik_common",
 	.early_init = cik_common_early_init,
 	.late_init = NULL,
 	.sw_init = cik_common_sw_init,

commit 7dae69a2905c34a97678645c8e4c95095f5390b8
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue May 3 16:25:53 2016 -0400

    drm/amdgpu: fetch cu_info once at init
    
    Fetch this info once at init and just store the results
    for future requests.
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index c6127d66de11..68e569853c95 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -2007,7 +2007,6 @@ static const struct amdgpu_asic_funcs cik_asic_funcs =
 	.get_xclk = &cik_get_xclk,
 	.set_uvd_clocks = &cik_set_uvd_clocks,
 	.set_vce_clocks = &cik_set_vce_clocks,
-	.get_cu_info = &gfx_v7_0_get_cu_info,
 	/* these should be moved to their own ip modules */
 	.get_gpu_clock_counter = &gfx_v7_0_get_gpu_clock_counter,
 	.wait_for_mc_idle = &gmc_v7_0_mc_wait_for_idle,

commit 16a7989ac62a4d491d44a295577a7e75b7e3b0bb
Author: Tom St Denis <tom.stdenis@amd.com>
Date:   Mon Mar 28 08:21:52 2016 -0400

    drm/amd/amdgpu: Drop print_status callbacks.
    
    First patch in series to move to user mode
    debug tools we're removing the print_status callbacks.
    
    These functions were unused at the moment anyway.
    
    Signed-off-by: Tom St Denis <tom.stdenis@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 009598bc4df8..c6127d66de11 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -2214,11 +2214,6 @@ static int cik_common_wait_for_idle(void *handle)
 	return 0;
 }
 
-static void cik_common_print_status(void *handle)
-{
-
-}
-
 static int cik_common_soft_reset(void *handle)
 {
 	/* XXX hard reset?? */
@@ -2249,7 +2244,6 @@ const struct amd_ip_funcs cik_common_ip_funcs = {
 	.is_idle = cik_common_is_idle,
 	.wait_for_idle = cik_common_wait_for_idle,
 	.soft_reset = cik_common_soft_reset,
-	.print_status = cik_common_print_status,
 	.set_clockgating_state = cik_common_set_clockgating_state,
 	.set_powergating_state = cik_common_set_powergating_state,
 };

commit eca2240fb044e30276ecbb43eab47a46f96c05c4
Author: Nils Wallménius <nils.wallmenius@gmail.com>
Date:   Sat Mar 19 16:12:17 2016 +0100

    drm/amdgpu: mark amdgpu_allowed_register_entry tables as 'const'
    
    Signed-off-by: Nils Wallménius <nils.wallmenius@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index bddc9ba11495..009598bc4df8 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -962,7 +962,7 @@ static bool cik_read_bios_from_rom(struct amdgpu_device *adev,
 	return true;
 }
 
-static struct amdgpu_allowed_register_entry cik_allowed_read_registers[] = {
+static const struct amdgpu_allowed_register_entry cik_allowed_read_registers[] = {
 	{mmGRBM_STATUS, false},
 	{mmGB_ADDR_CONFIG, false},
 	{mmMC_ARB_RAMCFG, false},

commit 9f443bf53b5699835e0132d62d1e6c99a1eaeee8
Merge: 70a09f36d025 00b7c4ff7d48
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Mar 17 08:25:04 2016 +1000

    Merge branch 'drm-next-4.6' of git://people.freedesktop.org/~agd5f/linux into drm-next
    
    A few more fixes and cleanups for 4.6:
    - DCE code cleanups
    - HDP flush/invalidation fixes
    - GPUVM fixes
    - switch to drm_vblank_[on|off]
    - PX fixes
    - misc bug fixes
    
    * 'drm-next-4.6' of git://people.freedesktop.org/~agd5f/linux: (50 commits)
      drm/amdgpu: split pipeline sync out of SDMA vm_flush() as well
      drm/amdgpu: Revert "add mutex for ba_va->valids/invalids"
      drm/amdgpu: Revert "add lock for interval tree in vm"
      drm/amdgpu: Revert "add spin lock to protect freed list in vm (v3)"
      drm/amdgpu: reserve the PD during unmap and remove
      drm/amdgpu: Fix two bugs in amdgpu_vm_bo_split_mapping
      drm/radeon: Don't drop DP 2.7 Ghz link setup on some cards.
      MAINTAINERS: update radeon entry to include amdgpu as well
      drm/amdgpu: disable runtime pm on PX laptops without dGPU power control
      drm/radeon: disable runtime pm on PX laptops without dGPU power control
      drm/amd/amdgpu: Fix indentation in do_set_base() (DCEv8)
      drm/amd/amdgpu: make afmt_init cleanup if alloc fails (DCEv8)
      drm/amd/amdgpu: Move config init flag to bottom of sw_init (DCEv8)
      drm/amd/amdgpu: Don't proceed into audio_fini if audio is disabled (DCEv8)
      drm/amd/amdgpu: Fix identation in do_set_base() (DCEv10)
      drm/amd/amdgpu: Make afmt_init cleanup if alloc fails (DCEv10)
      drm/amd/amdgpu: Move initialized flag to bottom of sw_init (DCEv10)
      drm/amd/amdgpu: Don't proceed in audio_fini if disabled (DCEv10)
      drm/amd/amdgpu: Fix indentation in dce_v11_0_crtc_do_set_base()
      drm/amd/amdgpu: Make afmt_init() cleanup if alloc fails (DCEv11)
      ...

commit 9b61c0fcdf0cfd20a85d9856d46142e7f297de0a
Merge: 550e3b23a53c 125234dc8b1c
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Mar 14 09:42:34 2016 +1000

    Merge drm-fixes into drm-next.
    
    Nouveau wanted this to avoid some worse conflicts when I merge that.

commit 0bf5df3b58e152ba2a50f9918f31a9c15b479b64
Author: Nils Wallménius <nils.wallmenius@gmail.com>
Date:   Sat Mar 5 06:59:51 2016 +0100

    drm/amdgpu: delete set-but-not-read member has_uvd from amdgpu_device
    
    Clean up leftover from radeon code.
    
    Signed-off-by: Nils Wallménius <nils.wallmenius@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 6b1f0539ce9d..5da14a3005b4 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -2025,8 +2025,6 @@ static int cik_common_early_init(void *handle)
 
 	adev->asic_funcs = &cik_asic_funcs;
 
-	adev->has_uvd = true;
-
 	adev->rev_id = cik_get_rev_id(adev);
 	adev->external_rev_id = 0xFF;
 	switch (adev->asic_type) {

commit ceb5bc861ef57d0007db93d2c48c4790dd39fde6
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Oct 14 09:43:58 2015 -0400

    drm/amdgpu: clean up asic level reset for CI
    
    Drop soft reset, always use pci config reset.
    
    Reviewed-by: Junwei Zhang <Jerry.Zhang@amd.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Ken Wang <Qingqing.Wang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index fd9c9588ef46..6b1f0539ce9d 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1059,257 +1059,6 @@ static int cik_read_register(struct amdgpu_device *adev, u32 se_num,
 	return -EINVAL;
 }
 
-static void cik_print_gpu_status_regs(struct amdgpu_device *adev)
-{
-	dev_info(adev->dev, "  GRBM_STATUS=0x%08X\n",
-		RREG32(mmGRBM_STATUS));
-	dev_info(adev->dev, "  GRBM_STATUS2=0x%08X\n",
-		RREG32(mmGRBM_STATUS2));
-	dev_info(adev->dev, "  GRBM_STATUS_SE0=0x%08X\n",
-		RREG32(mmGRBM_STATUS_SE0));
-	dev_info(adev->dev, "  GRBM_STATUS_SE1=0x%08X\n",
-		RREG32(mmGRBM_STATUS_SE1));
-	dev_info(adev->dev, "  GRBM_STATUS_SE2=0x%08X\n",
-		RREG32(mmGRBM_STATUS_SE2));
-	dev_info(adev->dev, "  GRBM_STATUS_SE3=0x%08X\n",
-		RREG32(mmGRBM_STATUS_SE3));
-	dev_info(adev->dev, "  SRBM_STATUS=0x%08X\n",
-		RREG32(mmSRBM_STATUS));
-	dev_info(adev->dev, "  SRBM_STATUS2=0x%08X\n",
-		RREG32(mmSRBM_STATUS2));
-	dev_info(adev->dev, "  SDMA0_STATUS_REG   = 0x%08X\n",
-		RREG32(mmSDMA0_STATUS_REG + SDMA0_REGISTER_OFFSET));
-	dev_info(adev->dev, "  SDMA1_STATUS_REG   = 0x%08X\n",
-		 RREG32(mmSDMA0_STATUS_REG + SDMA1_REGISTER_OFFSET));
-	dev_info(adev->dev, "  CP_STAT = 0x%08x\n", RREG32(mmCP_STAT));
-	dev_info(adev->dev, "  CP_STALLED_STAT1 = 0x%08x\n",
-		 RREG32(mmCP_STALLED_STAT1));
-	dev_info(adev->dev, "  CP_STALLED_STAT2 = 0x%08x\n",
-		 RREG32(mmCP_STALLED_STAT2));
-	dev_info(adev->dev, "  CP_STALLED_STAT3 = 0x%08x\n",
-		 RREG32(mmCP_STALLED_STAT3));
-	dev_info(adev->dev, "  CP_CPF_BUSY_STAT = 0x%08x\n",
-		 RREG32(mmCP_CPF_BUSY_STAT));
-	dev_info(adev->dev, "  CP_CPF_STALLED_STAT1 = 0x%08x\n",
-		 RREG32(mmCP_CPF_STALLED_STAT1));
-	dev_info(adev->dev, "  CP_CPF_STATUS = 0x%08x\n", RREG32(mmCP_CPF_STATUS));
-	dev_info(adev->dev, "  CP_CPC_BUSY_STAT = 0x%08x\n", RREG32(mmCP_CPC_BUSY_STAT));
-	dev_info(adev->dev, "  CP_CPC_STALLED_STAT1 = 0x%08x\n",
-		 RREG32(mmCP_CPC_STALLED_STAT1));
-	dev_info(adev->dev, "  CP_CPC_STATUS = 0x%08x\n", RREG32(mmCP_CPC_STATUS));
-}
-
-/**
- * cik_gpu_check_soft_reset - check which blocks are busy
- *
- * @adev: amdgpu_device pointer
- *
- * Check which blocks are busy and return the relevant reset
- * mask to be used by cik_gpu_soft_reset().
- * Returns a mask of the blocks to be reset.
- */
-u32 amdgpu_cik_gpu_check_soft_reset(struct amdgpu_device *adev)
-{
-	u32 reset_mask = 0;
-	u32 tmp;
-
-	/* GRBM_STATUS */
-	tmp = RREG32(mmGRBM_STATUS);
-	if (tmp & (GRBM_STATUS__PA_BUSY_MASK | GRBM_STATUS__SC_BUSY_MASK |
-		   GRBM_STATUS__BCI_BUSY_MASK | GRBM_STATUS__SX_BUSY_MASK |
-		   GRBM_STATUS__TA_BUSY_MASK | GRBM_STATUS__VGT_BUSY_MASK |
-		   GRBM_STATUS__DB_BUSY_MASK | GRBM_STATUS__CB_BUSY_MASK |
-		   GRBM_STATUS__GDS_BUSY_MASK | GRBM_STATUS__SPI_BUSY_MASK |
-		   GRBM_STATUS__IA_BUSY_MASK | GRBM_STATUS__IA_BUSY_NO_DMA_MASK))
-		reset_mask |= AMDGPU_RESET_GFX;
-
-	if (tmp & (GRBM_STATUS__CP_BUSY_MASK | GRBM_STATUS__CP_COHERENCY_BUSY_MASK))
-		reset_mask |= AMDGPU_RESET_CP;
-
-	/* GRBM_STATUS2 */
-	tmp = RREG32(mmGRBM_STATUS2);
-	if (tmp & GRBM_STATUS2__RLC_BUSY_MASK)
-		reset_mask |= AMDGPU_RESET_RLC;
-
-	/* SDMA0_STATUS_REG */
-	tmp = RREG32(mmSDMA0_STATUS_REG + SDMA0_REGISTER_OFFSET);
-	if (!(tmp & SDMA0_STATUS_REG__IDLE_MASK))
-		reset_mask |= AMDGPU_RESET_DMA;
-
-	/* SDMA1_STATUS_REG */
-	tmp = RREG32(mmSDMA0_STATUS_REG + SDMA1_REGISTER_OFFSET);
-	if (!(tmp & SDMA0_STATUS_REG__IDLE_MASK))
-		reset_mask |= AMDGPU_RESET_DMA1;
-
-	/* SRBM_STATUS2 */
-	tmp = RREG32(mmSRBM_STATUS2);
-	if (tmp & SRBM_STATUS2__SDMA_BUSY_MASK)
-		reset_mask |= AMDGPU_RESET_DMA;
-
-	if (tmp & SRBM_STATUS2__SDMA1_BUSY_MASK)
-		reset_mask |= AMDGPU_RESET_DMA1;
-
-	/* SRBM_STATUS */
-	tmp = RREG32(mmSRBM_STATUS);
-
-	if (tmp & SRBM_STATUS__IH_BUSY_MASK)
-		reset_mask |= AMDGPU_RESET_IH;
-
-	if (tmp & SRBM_STATUS__SEM_BUSY_MASK)
-		reset_mask |= AMDGPU_RESET_SEM;
-
-	if (tmp & SRBM_STATUS__GRBM_RQ_PENDING_MASK)
-		reset_mask |= AMDGPU_RESET_GRBM;
-
-	if (tmp & SRBM_STATUS__VMC_BUSY_MASK)
-		reset_mask |= AMDGPU_RESET_VMC;
-
-	if (tmp & (SRBM_STATUS__MCB_BUSY_MASK | SRBM_STATUS__MCB_NON_DISPLAY_BUSY_MASK |
-		   SRBM_STATUS__MCC_BUSY_MASK | SRBM_STATUS__MCD_BUSY_MASK))
-		reset_mask |= AMDGPU_RESET_MC;
-
-	if (amdgpu_display_is_display_hung(adev))
-		reset_mask |= AMDGPU_RESET_DISPLAY;
-
-	/* Skip MC reset as it's mostly likely not hung, just busy */
-	if (reset_mask & AMDGPU_RESET_MC) {
-		DRM_DEBUG("MC busy: 0x%08X, clearing.\n", reset_mask);
-		reset_mask &= ~AMDGPU_RESET_MC;
-	}
-
-	return reset_mask;
-}
-
-/**
- * cik_gpu_soft_reset - soft reset GPU
- *
- * @adev: amdgpu_device pointer
- * @reset_mask: mask of which blocks to reset
- *
- * Soft reset the blocks specified in @reset_mask.
- */
-static void cik_gpu_soft_reset(struct amdgpu_device *adev, u32 reset_mask)
-{
-	struct amdgpu_mode_mc_save save;
-	u32 grbm_soft_reset = 0, srbm_soft_reset = 0;
-	u32 tmp;
-
-	if (reset_mask == 0)
-		return;
-
-	dev_info(adev->dev, "GPU softreset: 0x%08X\n", reset_mask);
-
-	cik_print_gpu_status_regs(adev);
-	dev_info(adev->dev, "  VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x%08X\n",
-		 RREG32(mmVM_CONTEXT1_PROTECTION_FAULT_ADDR));
-	dev_info(adev->dev, "  VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x%08X\n",
-		 RREG32(mmVM_CONTEXT1_PROTECTION_FAULT_STATUS));
-
-	/* disable CG/PG */
-
-	/* stop the rlc */
-	gfx_v7_0_rlc_stop(adev);
-
-	/* Disable GFX parsing/prefetching */
-	WREG32(mmCP_ME_CNTL, CP_ME_CNTL__ME_HALT_MASK | CP_ME_CNTL__PFP_HALT_MASK | CP_ME_CNTL__CE_HALT_MASK);
-
-	/* Disable MEC parsing/prefetching */
-	WREG32(mmCP_MEC_CNTL, CP_MEC_CNTL__MEC_ME1_HALT_MASK | CP_MEC_CNTL__MEC_ME2_HALT_MASK);
-
-	if (reset_mask & AMDGPU_RESET_DMA) {
-		/* sdma0 */
-		tmp = RREG32(mmSDMA0_F32_CNTL + SDMA0_REGISTER_OFFSET);
-		tmp |= SDMA0_F32_CNTL__HALT_MASK;
-		WREG32(mmSDMA0_F32_CNTL + SDMA0_REGISTER_OFFSET, tmp);
-	}
-	if (reset_mask & AMDGPU_RESET_DMA1) {
-		/* sdma1 */
-		tmp = RREG32(mmSDMA0_F32_CNTL + SDMA1_REGISTER_OFFSET);
-		tmp |= SDMA0_F32_CNTL__HALT_MASK;
-		WREG32(mmSDMA0_F32_CNTL + SDMA1_REGISTER_OFFSET, tmp);
-	}
-
-	gmc_v7_0_mc_stop(adev, &save);
-	if (amdgpu_asic_wait_for_mc_idle(adev)) {
-		dev_warn(adev->dev, "Wait for MC idle timedout !\n");
-	}
-
-	if (reset_mask & (AMDGPU_RESET_GFX | AMDGPU_RESET_COMPUTE | AMDGPU_RESET_CP))
-		grbm_soft_reset = GRBM_SOFT_RESET__SOFT_RESET_CP_MASK |
-			GRBM_SOFT_RESET__SOFT_RESET_GFX_MASK;
-
-	if (reset_mask & AMDGPU_RESET_CP) {
-		grbm_soft_reset |= GRBM_SOFT_RESET__SOFT_RESET_CP_MASK;
-
-		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_GRBM_MASK;
-	}
-
-	if (reset_mask & AMDGPU_RESET_DMA)
-		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_SDMA_MASK;
-
-	if (reset_mask & AMDGPU_RESET_DMA1)
-		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_SDMA1_MASK;
-
-	if (reset_mask & AMDGPU_RESET_DISPLAY)
-		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_DC_MASK;
-
-	if (reset_mask & AMDGPU_RESET_RLC)
-		grbm_soft_reset |= GRBM_SOFT_RESET__SOFT_RESET_RLC_MASK;
-
-	if (reset_mask & AMDGPU_RESET_SEM)
-		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_SEM_MASK;
-
-	if (reset_mask & AMDGPU_RESET_IH)
-		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_IH_MASK;
-
-	if (reset_mask & AMDGPU_RESET_GRBM)
-		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_GRBM_MASK;
-
-	if (reset_mask & AMDGPU_RESET_VMC)
-		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_VMC_MASK;
-
-	if (!(adev->flags & AMD_IS_APU)) {
-		if (reset_mask & AMDGPU_RESET_MC)
-			srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_MC_MASK;
-	}
-
-	if (grbm_soft_reset) {
-		tmp = RREG32(mmGRBM_SOFT_RESET);
-		tmp |= grbm_soft_reset;
-		dev_info(adev->dev, "GRBM_SOFT_RESET=0x%08X\n", tmp);
-		WREG32(mmGRBM_SOFT_RESET, tmp);
-		tmp = RREG32(mmGRBM_SOFT_RESET);
-
-		udelay(50);
-
-		tmp &= ~grbm_soft_reset;
-		WREG32(mmGRBM_SOFT_RESET, tmp);
-		tmp = RREG32(mmGRBM_SOFT_RESET);
-	}
-
-	if (srbm_soft_reset) {
-		tmp = RREG32(mmSRBM_SOFT_RESET);
-		tmp |= srbm_soft_reset;
-		dev_info(adev->dev, "SRBM_SOFT_RESET=0x%08X\n", tmp);
-		WREG32(mmSRBM_SOFT_RESET, tmp);
-		tmp = RREG32(mmSRBM_SOFT_RESET);
-
-		udelay(50);
-
-		tmp &= ~srbm_soft_reset;
-		WREG32(mmSRBM_SOFT_RESET, tmp);
-		tmp = RREG32(mmSRBM_SOFT_RESET);
-	}
-
-	/* Wait a little for things to settle down */
-	udelay(50);
-
-	gmc_v7_0_mc_resume(adev, &save);
-	udelay(50);
-
-	cik_print_gpu_status_regs(adev);
-}
-
 struct kv_reset_save_regs {
 	u32 gmcon_reng_execute;
 	u32 gmcon_misc;
@@ -1405,45 +1154,11 @@ static void kv_restore_regs_for_reset(struct amdgpu_device *adev,
 
 static void cik_gpu_pci_config_reset(struct amdgpu_device *adev)
 {
-	struct amdgpu_mode_mc_save save;
 	struct kv_reset_save_regs kv_save = { 0 };
-	u32 tmp, i;
+	u32 i;
 
 	dev_info(adev->dev, "GPU pci config reset\n");
 
-	/* disable dpm? */
-
-	/* disable cg/pg */
-
-	/* Disable GFX parsing/prefetching */
-	WREG32(mmCP_ME_CNTL, CP_ME_CNTL__ME_HALT_MASK |
-		CP_ME_CNTL__PFP_HALT_MASK | CP_ME_CNTL__CE_HALT_MASK);
-
-	/* Disable MEC parsing/prefetching */
-	WREG32(mmCP_MEC_CNTL,
-			CP_MEC_CNTL__MEC_ME1_HALT_MASK | CP_MEC_CNTL__MEC_ME2_HALT_MASK);
-
-	/* sdma0 */
-	tmp = RREG32(mmSDMA0_F32_CNTL + SDMA0_REGISTER_OFFSET);
-	tmp |= SDMA0_F32_CNTL__HALT_MASK;
-	WREG32(mmSDMA0_F32_CNTL + SDMA0_REGISTER_OFFSET, tmp);
-	/* sdma1 */
-	tmp = RREG32(mmSDMA0_F32_CNTL + SDMA1_REGISTER_OFFSET);
-	tmp |= SDMA0_F32_CNTL__HALT_MASK;
-	WREG32(mmSDMA0_F32_CNTL + SDMA1_REGISTER_OFFSET, tmp);
-	/* XXX other engines? */
-
-	/* halt the rlc, disable cp internal ints */
-	gfx_v7_0_rlc_stop(adev);
-
-	udelay(50);
-
-	/* disable mem access */
-	gmc_v7_0_mc_stop(adev, &save);
-	if (amdgpu_asic_wait_for_mc_idle(adev)) {
-		dev_warn(adev->dev, "Wait for MC idle timed out !\n");
-	}
-
 	if (adev->flags & AMD_IS_APU)
 		kv_save_regs_for_reset(adev, &kv_save);
 
@@ -1489,26 +1204,11 @@ static void cik_set_bios_scratch_engine_hung(struct amdgpu_device *adev, bool hu
  */
 static int cik_asic_reset(struct amdgpu_device *adev)
 {
-	u32 reset_mask;
-
-	reset_mask = amdgpu_cik_gpu_check_soft_reset(adev);
-
-	if (reset_mask)
-		cik_set_bios_scratch_engine_hung(adev, true);
-
-	/* try soft reset */
-	cik_gpu_soft_reset(adev, reset_mask);
-
-	reset_mask = amdgpu_cik_gpu_check_soft_reset(adev);
-
-	/* try pci config reset */
-	if (reset_mask && amdgpu_hard_reset)
-		cik_gpu_pci_config_reset(adev);
+	cik_set_bios_scratch_engine_hung(adev, true);
 
-	reset_mask = amdgpu_cik_gpu_check_soft_reset(adev);
+	cik_gpu_pci_config_reset(adev);
 
-	if (!reset_mask)
-		cik_set_bios_scratch_engine_hung(adev, false);
+	cik_set_bios_scratch_engine_hung(adev, false);
 
 	return 0;
 }

commit e3b04bc790ecd6d08d4699bc60b4f5a76f7f7b6b
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Feb 5 10:56:22 2016 -0500

    drma/dmgpu: move cg and pg flags into shared headers
    
    So they can be used by powerplay.
    
    Reviewed-by: Eric Huang <JinHuiEric.Huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 5c978e064f47..155965ed14a3 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -2335,72 +2335,72 @@ static int cik_common_early_init(void *handle)
 	switch (adev->asic_type) {
 	case CHIP_BONAIRE:
 		adev->cg_flags =
-			AMDGPU_CG_SUPPORT_GFX_MGCG |
-			AMDGPU_CG_SUPPORT_GFX_MGLS |
-			/*AMDGPU_CG_SUPPORT_GFX_CGCG |*/
-			AMDGPU_CG_SUPPORT_GFX_CGLS |
-			AMDGPU_CG_SUPPORT_GFX_CGTS |
-			AMDGPU_CG_SUPPORT_GFX_CGTS_LS |
-			AMDGPU_CG_SUPPORT_GFX_CP_LS |
-			AMDGPU_CG_SUPPORT_MC_LS |
-			AMDGPU_CG_SUPPORT_MC_MGCG |
-			AMDGPU_CG_SUPPORT_SDMA_MGCG |
-			AMDGPU_CG_SUPPORT_SDMA_LS |
-			AMDGPU_CG_SUPPORT_BIF_LS |
-			AMDGPU_CG_SUPPORT_VCE_MGCG |
-			AMDGPU_CG_SUPPORT_UVD_MGCG |
-			AMDGPU_CG_SUPPORT_HDP_LS |
-			AMDGPU_CG_SUPPORT_HDP_MGCG;
+			AMD_CG_SUPPORT_GFX_MGCG |
+			AMD_CG_SUPPORT_GFX_MGLS |
+			/*AMD_CG_SUPPORT_GFX_CGCG |*/
+			AMD_CG_SUPPORT_GFX_CGLS |
+			AMD_CG_SUPPORT_GFX_CGTS |
+			AMD_CG_SUPPORT_GFX_CGTS_LS |
+			AMD_CG_SUPPORT_GFX_CP_LS |
+			AMD_CG_SUPPORT_MC_LS |
+			AMD_CG_SUPPORT_MC_MGCG |
+			AMD_CG_SUPPORT_SDMA_MGCG |
+			AMD_CG_SUPPORT_SDMA_LS |
+			AMD_CG_SUPPORT_BIF_LS |
+			AMD_CG_SUPPORT_VCE_MGCG |
+			AMD_CG_SUPPORT_UVD_MGCG |
+			AMD_CG_SUPPORT_HDP_LS |
+			AMD_CG_SUPPORT_HDP_MGCG;
 		adev->pg_flags = 0;
 		adev->external_rev_id = adev->rev_id + 0x14;
 		break;
 	case CHIP_HAWAII:
 		adev->cg_flags =
-			AMDGPU_CG_SUPPORT_GFX_MGCG |
-			AMDGPU_CG_SUPPORT_GFX_MGLS |
-			/*AMDGPU_CG_SUPPORT_GFX_CGCG |*/
-			AMDGPU_CG_SUPPORT_GFX_CGLS |
-			AMDGPU_CG_SUPPORT_GFX_CGTS |
-			AMDGPU_CG_SUPPORT_GFX_CP_LS |
-			AMDGPU_CG_SUPPORT_MC_LS |
-			AMDGPU_CG_SUPPORT_MC_MGCG |
-			AMDGPU_CG_SUPPORT_SDMA_MGCG |
-			AMDGPU_CG_SUPPORT_SDMA_LS |
-			AMDGPU_CG_SUPPORT_BIF_LS |
-			AMDGPU_CG_SUPPORT_VCE_MGCG |
-			AMDGPU_CG_SUPPORT_UVD_MGCG |
-			AMDGPU_CG_SUPPORT_HDP_LS |
-			AMDGPU_CG_SUPPORT_HDP_MGCG;
+			AMD_CG_SUPPORT_GFX_MGCG |
+			AMD_CG_SUPPORT_GFX_MGLS |
+			/*AMD_CG_SUPPORT_GFX_CGCG |*/
+			AMD_CG_SUPPORT_GFX_CGLS |
+			AMD_CG_SUPPORT_GFX_CGTS |
+			AMD_CG_SUPPORT_GFX_CP_LS |
+			AMD_CG_SUPPORT_MC_LS |
+			AMD_CG_SUPPORT_MC_MGCG |
+			AMD_CG_SUPPORT_SDMA_MGCG |
+			AMD_CG_SUPPORT_SDMA_LS |
+			AMD_CG_SUPPORT_BIF_LS |
+			AMD_CG_SUPPORT_VCE_MGCG |
+			AMD_CG_SUPPORT_UVD_MGCG |
+			AMD_CG_SUPPORT_HDP_LS |
+			AMD_CG_SUPPORT_HDP_MGCG;
 		adev->pg_flags = 0;
 		adev->external_rev_id = 0x28;
 		break;
 	case CHIP_KAVERI:
 		adev->cg_flags =
-			AMDGPU_CG_SUPPORT_GFX_MGCG |
-			AMDGPU_CG_SUPPORT_GFX_MGLS |
-			/*AMDGPU_CG_SUPPORT_GFX_CGCG |*/
-			AMDGPU_CG_SUPPORT_GFX_CGLS |
-			AMDGPU_CG_SUPPORT_GFX_CGTS |
-			AMDGPU_CG_SUPPORT_GFX_CGTS_LS |
-			AMDGPU_CG_SUPPORT_GFX_CP_LS |
-			AMDGPU_CG_SUPPORT_SDMA_MGCG |
-			AMDGPU_CG_SUPPORT_SDMA_LS |
-			AMDGPU_CG_SUPPORT_BIF_LS |
-			AMDGPU_CG_SUPPORT_VCE_MGCG |
-			AMDGPU_CG_SUPPORT_UVD_MGCG |
-			AMDGPU_CG_SUPPORT_HDP_LS |
-			AMDGPU_CG_SUPPORT_HDP_MGCG;
+			AMD_CG_SUPPORT_GFX_MGCG |
+			AMD_CG_SUPPORT_GFX_MGLS |
+			/*AMD_CG_SUPPORT_GFX_CGCG |*/
+			AMD_CG_SUPPORT_GFX_CGLS |
+			AMD_CG_SUPPORT_GFX_CGTS |
+			AMD_CG_SUPPORT_GFX_CGTS_LS |
+			AMD_CG_SUPPORT_GFX_CP_LS |
+			AMD_CG_SUPPORT_SDMA_MGCG |
+			AMD_CG_SUPPORT_SDMA_LS |
+			AMD_CG_SUPPORT_BIF_LS |
+			AMD_CG_SUPPORT_VCE_MGCG |
+			AMD_CG_SUPPORT_UVD_MGCG |
+			AMD_CG_SUPPORT_HDP_LS |
+			AMD_CG_SUPPORT_HDP_MGCG;
 		adev->pg_flags =
-			/*AMDGPU_PG_SUPPORT_GFX_PG |
-			  AMDGPU_PG_SUPPORT_GFX_SMG |
-			  AMDGPU_PG_SUPPORT_GFX_DMG |*/
-			AMDGPU_PG_SUPPORT_UVD |
-			/*AMDGPU_PG_SUPPORT_VCE |
-			  AMDGPU_PG_SUPPORT_CP |
-			  AMDGPU_PG_SUPPORT_GDS |
-			  AMDGPU_PG_SUPPORT_RLC_SMU_HS |
-			  AMDGPU_PG_SUPPORT_ACP |
-			  AMDGPU_PG_SUPPORT_SAMU |*/
+			/*AMD_PG_SUPPORT_GFX_PG |
+			  AMD_PG_SUPPORT_GFX_SMG |
+			  AMD_PG_SUPPORT_GFX_DMG |*/
+			AMD_PG_SUPPORT_UVD |
+			/*AMD_PG_SUPPORT_VCE |
+			  AMD_PG_SUPPORT_CP |
+			  AMD_PG_SUPPORT_GDS |
+			  AMD_PG_SUPPORT_RLC_SMU_HS |
+			  AMD_PG_SUPPORT_ACP |
+			  AMD_PG_SUPPORT_SAMU |*/
 			0;
 		if (adev->pdev->device == 0x1312 ||
 			adev->pdev->device == 0x1316 ||
@@ -2412,29 +2412,29 @@ static int cik_common_early_init(void *handle)
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
 		adev->cg_flags =
-			AMDGPU_CG_SUPPORT_GFX_MGCG |
-			AMDGPU_CG_SUPPORT_GFX_MGLS |
-			/*AMDGPU_CG_SUPPORT_GFX_CGCG |*/
-			AMDGPU_CG_SUPPORT_GFX_CGLS |
-			AMDGPU_CG_SUPPORT_GFX_CGTS |
-			AMDGPU_CG_SUPPORT_GFX_CGTS_LS |
-			AMDGPU_CG_SUPPORT_GFX_CP_LS |
-			AMDGPU_CG_SUPPORT_SDMA_MGCG |
-			AMDGPU_CG_SUPPORT_SDMA_LS |
-			AMDGPU_CG_SUPPORT_BIF_LS |
-			AMDGPU_CG_SUPPORT_VCE_MGCG |
-			AMDGPU_CG_SUPPORT_UVD_MGCG |
-			AMDGPU_CG_SUPPORT_HDP_LS |
-			AMDGPU_CG_SUPPORT_HDP_MGCG;
+			AMD_CG_SUPPORT_GFX_MGCG |
+			AMD_CG_SUPPORT_GFX_MGLS |
+			/*AMD_CG_SUPPORT_GFX_CGCG |*/
+			AMD_CG_SUPPORT_GFX_CGLS |
+			AMD_CG_SUPPORT_GFX_CGTS |
+			AMD_CG_SUPPORT_GFX_CGTS_LS |
+			AMD_CG_SUPPORT_GFX_CP_LS |
+			AMD_CG_SUPPORT_SDMA_MGCG |
+			AMD_CG_SUPPORT_SDMA_LS |
+			AMD_CG_SUPPORT_BIF_LS |
+			AMD_CG_SUPPORT_VCE_MGCG |
+			AMD_CG_SUPPORT_UVD_MGCG |
+			AMD_CG_SUPPORT_HDP_LS |
+			AMD_CG_SUPPORT_HDP_MGCG;
 		adev->pg_flags =
-			/*AMDGPU_PG_SUPPORT_GFX_PG |
-			  AMDGPU_PG_SUPPORT_GFX_SMG | */
-			AMDGPU_PG_SUPPORT_UVD |
-			/*AMDGPU_PG_SUPPORT_VCE |
-			  AMDGPU_PG_SUPPORT_CP |
-			  AMDGPU_PG_SUPPORT_GDS |
-			  AMDGPU_PG_SUPPORT_RLC_SMU_HS |
-			  AMDGPU_PG_SUPPORT_SAMU |*/
+			/*AMD_PG_SUPPORT_GFX_PG |
+			  AMD_PG_SUPPORT_GFX_SMG | */
+			AMD_PG_SUPPORT_UVD |
+			/*AMD_PG_SUPPORT_VCE |
+			  AMD_PG_SUPPORT_CP |
+			  AMD_PG_SUPPORT_GDS |
+			  AMD_PG_SUPPORT_RLC_SMU_HS |
+			  AMD_PG_SUPPORT_SAMU |*/
 			0;
 		if (adev->asic_type == CHIP_KABINI) {
 			if (adev->rev_id == 0)

commit 76ecb2c75bc772050f2e0462b9cf0163cc43046e
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Feb 4 10:33:59 2016 -0500

    drm/amdgpu/cik: don't mess with aspm if gpu is root bus
    
    Pcie registers may not be available in a virtualized
    environment.
    
    Reviewed-by: monk liu <monk.liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index fd9c9588ef46..5c978e064f47 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1762,6 +1762,9 @@ static void cik_program_aspm(struct amdgpu_device *adev)
 	if (amdgpu_aspm == 0)
 		return;
 
+	if (pci_is_root_bus(adev->pdev->bus))
+		return;
+
 	/* XXX double check APUs */
 	if (adev->flags & AMD_IS_APU)
 		return;

commit d0dd7f0cc345fc8757148004639e1993ba183bd6
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Nov 11 19:45:06 2015 -0500

    drm/amdgpu: store pcie gen mask and link width
    
    We'll need this later for pcie dpm.
    
    Reviewed-by: Jammy Zhou <Jammy.Zhou@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index c7c298b88170..fd9c9588ef46 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -32,6 +32,7 @@
 #include "amdgpu_vce.h"
 #include "cikd.h"
 #include "atom.h"
+#include "amd_pcie.h"
 
 #include "cik.h"
 #include "gmc_v7_0.h"
@@ -1595,8 +1596,8 @@ static void cik_pcie_gen3_enable(struct amdgpu_device *adev)
 {
 	struct pci_dev *root = adev->pdev->bus->self;
 	int bridge_pos, gpu_pos;
-	u32 speed_cntl, mask, current_data_rate;
-	int ret, i;
+	u32 speed_cntl, current_data_rate;
+	int i;
 	u16 tmp16;
 
 	if (pci_is_root_bus(adev->pdev->bus))
@@ -1608,23 +1609,20 @@ static void cik_pcie_gen3_enable(struct amdgpu_device *adev)
 	if (adev->flags & AMD_IS_APU)
 		return;
 
-	ret = drm_pcie_get_speed_cap_mask(adev->ddev, &mask);
-	if (ret != 0)
-		return;
-
-	if (!(mask & (DRM_PCIE_SPEED_50 | DRM_PCIE_SPEED_80)))
+	if (!(adev->pm.pcie_gen_mask & (CAIL_PCIE_LINK_SPEED_SUPPORT_GEN2 |
+					CAIL_PCIE_LINK_SPEED_SUPPORT_GEN3)))
 		return;
 
 	speed_cntl = RREG32_PCIE(ixPCIE_LC_SPEED_CNTL);
 	current_data_rate = (speed_cntl & PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE_MASK) >>
 		PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE__SHIFT;
-	if (mask & DRM_PCIE_SPEED_80) {
+	if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN3) {
 		if (current_data_rate == 2) {
 			DRM_INFO("PCIE gen 3 link speeds already enabled\n");
 			return;
 		}
 		DRM_INFO("enabling PCIE gen 3 link speeds, disable with amdgpu.pcie_gen2=0\n");
-	} else if (mask & DRM_PCIE_SPEED_50) {
+	} else if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN2) {
 		if (current_data_rate == 1) {
 			DRM_INFO("PCIE gen 2 link speeds already enabled\n");
 			return;
@@ -1640,7 +1638,7 @@ static void cik_pcie_gen3_enable(struct amdgpu_device *adev)
 	if (!gpu_pos)
 		return;
 
-	if (mask & DRM_PCIE_SPEED_80) {
+	if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN3) {
 		/* re-try equalization if gen3 is not already enabled */
 		if (current_data_rate != 2) {
 			u16 bridge_cfg, gpu_cfg;
@@ -1735,9 +1733,9 @@ static void cik_pcie_gen3_enable(struct amdgpu_device *adev)
 
 	pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL2, &tmp16);
 	tmp16 &= ~0xf;
-	if (mask & DRM_PCIE_SPEED_80)
+	if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN3)
 		tmp16 |= 3; /* gen3 */
-	else if (mask & DRM_PCIE_SPEED_50)
+	else if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN2)
 		tmp16 |= 2; /* gen2 */
 	else
 		tmp16 |= 1; /* gen1 */
@@ -2450,6 +2448,8 @@ static int cik_common_early_init(void *handle)
 		return -EINVAL;
 	}
 
+	amdgpu_get_pcie_info(adev);
+
 	return 0;
 }
 

commit 1f7371b2a5faf139465f0af386cccbb54b832534
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Dec 2 17:46:21 2015 -0500

    drm/amd/powerplay: add basic powerplay framework
    
    amdgpu_pp_ip_funcs is introduced to handle the two code paths,
    the legacy one and the new powerplay implementation.
    
    CONFIG_DRM_AMD_POWERPLAY kernel configuration option is
    introduced for the powerplay component.
    
    v4: squash in fixes
    v3: register debugfs file when powerplay module enable
    v2: add amdgpu_ucode_init_bo in hw init when amdgpu_powerplay enable.
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Jammy Zhou <Jammy.Zhou@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 61689f094ba8..c7c298b88170 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -65,6 +65,7 @@
 #include "oss/oss_2_0_sh_mask.h"
 
 #include "amdgpu_amdkfd.h"
+#include "amdgpu_powerplay.h"
 
 /*
  * Indirect registers accessor
@@ -1953,7 +1954,7 @@ static const struct amdgpu_ip_block_version bonaire_ip_blocks[] =
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
-		.funcs = &ci_dpm_ip_funcs,
+		.funcs = &amdgpu_pp_ip_funcs,
 	},
 	{
 		.type = AMD_IP_BLOCK_TYPE_DCE,
@@ -2021,7 +2022,7 @@ static const struct amdgpu_ip_block_version hawaii_ip_blocks[] =
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
-		.funcs = &ci_dpm_ip_funcs,
+		.funcs = &amdgpu_pp_ip_funcs,
 	},
 	{
 		.type = AMD_IP_BLOCK_TYPE_DCE,
@@ -2089,7 +2090,7 @@ static const struct amdgpu_ip_block_version kabini_ip_blocks[] =
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
-		.funcs = &kv_dpm_ip_funcs,
+		.funcs = &amdgpu_pp_ip_funcs,
 	},
 	{
 		.type = AMD_IP_BLOCK_TYPE_DCE,
@@ -2157,7 +2158,7 @@ static const struct amdgpu_ip_block_version mullins_ip_blocks[] =
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
-		.funcs = &kv_dpm_ip_funcs,
+		.funcs = &amdgpu_pp_ip_funcs,
 	},
 	{
 		.type = AMD_IP_BLOCK_TYPE_DCE,
@@ -2225,7 +2226,7 @@ static const struct amdgpu_ip_block_version kaveri_ip_blocks[] =
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
-		.funcs = &kv_dpm_ip_funcs,
+		.funcs = &amdgpu_pp_ip_funcs,
 	},
 	{
 		.type = AMD_IP_BLOCK_TYPE_DCE,

commit 1eb22bd38ac58a1be6e7e0ae6dd4ab6d604a27d6
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Nov 24 10:34:45 2015 -0500

    drm/amdgpu: add read_bios_from_rom callback for CI parts
    
    Read the vbios image directly from the rom.
    
    Reviewed-by: Jammy Zhou <Jammy.Zhou@amd.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Monk Liu <monk.liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 484710cfdf82..61689f094ba8 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -929,6 +929,37 @@ static bool cik_read_disabled_bios(struct amdgpu_device *adev)
 	return r;
 }
 
+static bool cik_read_bios_from_rom(struct amdgpu_device *adev,
+				   u8 *bios, u32 length_bytes)
+{
+	u32 *dw_ptr;
+	unsigned long flags;
+	u32 i, length_dw;
+
+	if (bios == NULL)
+		return false;
+	if (length_bytes == 0)
+		return false;
+	/* APU vbios image is part of sbios image */
+	if (adev->flags & AMD_IS_APU)
+		return false;
+
+	dw_ptr = (u32 *)bios;
+	length_dw = ALIGN(length_bytes, 4) / 4;
+	/* take the smc lock since we are using the smc index */
+	spin_lock_irqsave(&adev->smc_idx_lock, flags);
+	/* set rom index to 0 */
+	WREG32(mmSMC_IND_INDEX_0, ixROM_INDEX);
+	WREG32(mmSMC_IND_DATA_0, 0);
+	/* set index to data for continous read */
+	WREG32(mmSMC_IND_INDEX_0, ixROM_DATA);
+	for (i = 0; i < length_dw; i++)
+		dw_ptr[i] = RREG32(mmSMC_IND_DATA_0);
+	spin_unlock_irqrestore(&adev->smc_idx_lock, flags);
+
+	return true;
+}
+
 static struct amdgpu_allowed_register_entry cik_allowed_read_registers[] = {
 	{mmGRBM_STATUS, false},
 	{mmGB_ADDR_CONFIG, false},
@@ -2267,6 +2298,7 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 static const struct amdgpu_asic_funcs cik_asic_funcs =
 {
 	.read_disabled_bios = &cik_read_disabled_bios,
+	.read_bios_from_rom = &cik_read_bios_from_rom,
 	.read_register = &cik_read_register,
 	.reset = &cik_asic_reset,
 	.set_vga_state = &cik_vga_set_state,

commit e79d5c0870eedce94e5f5a2ffab30511e48fa144
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Oct 6 09:38:45 2015 -0400

    drm/amdgpu: check before checking pci bridge registers
    
    Make sure we are not the root device before attempting to
    read the pcie bridge registers to check the pcie gen speeed.
    
    Fixes a crash when the device is passed through to a VM.
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 4b6ce74753cd..484710cfdf82 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1567,6 +1567,9 @@ static void cik_pcie_gen3_enable(struct amdgpu_device *adev)
 	int ret, i;
 	u16 tmp16;
 
+	if (pci_is_root_bus(adev->pdev->bus))
+		return;
+
 	if (amdgpu_pcie_gen2 == 0)
 		return;
 

commit 2f7d10b393c83acd3eedc3d6ab94dce29ac6a890
Author: Jammy Zhou <Jammy.Zhou@amd.com>
Date:   Wed Jul 22 11:29:01 2015 +0800

    drm/amdgpu: merge amdgpu_family.h into amd_shared.h (v2)
    
    Make the definitions common for all driver components
    
    v2: fix kfd
    
    Signed-off-by: Jammy Zhou <Jammy.Zhou@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index b3b66a0d5ff7..4b6ce74753cd 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -838,7 +838,7 @@ static u32 cik_get_xclk(struct amdgpu_device *adev)
 {
 	u32 reference_clock = adev->clock.spll.reference_freq;
 
-	if (adev->flags & AMDGPU_IS_APU) {
+	if (adev->flags & AMD_IS_APU) {
 		if (RREG32_SMC(ixGENERAL_PWRMGT) & GENERAL_PWRMGT__GPU_COUNTER_CLK_MASK)
 			return reference_clock / 2;
 	} else {
@@ -1235,7 +1235,7 @@ static void cik_gpu_soft_reset(struct amdgpu_device *adev, u32 reset_mask)
 	if (reset_mask & AMDGPU_RESET_VMC)
 		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_VMC_MASK;
 
-	if (!(adev->flags & AMDGPU_IS_APU)) {
+	if (!(adev->flags & AMD_IS_APU)) {
 		if (reset_mask & AMDGPU_RESET_MC)
 			srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_MC_MASK;
 	}
@@ -1411,7 +1411,7 @@ static void cik_gpu_pci_config_reset(struct amdgpu_device *adev)
 		dev_warn(adev->dev, "Wait for MC idle timed out !\n");
 	}
 
-	if (adev->flags & AMDGPU_IS_APU)
+	if (adev->flags & AMD_IS_APU)
 		kv_save_regs_for_reset(adev, &kv_save);
 
 	/* disable BM */
@@ -1429,7 +1429,7 @@ static void cik_gpu_pci_config_reset(struct amdgpu_device *adev)
 	}
 
 	/* does asic init need to be run first??? */
-	if (adev->flags & AMDGPU_IS_APU)
+	if (adev->flags & AMD_IS_APU)
 		kv_restore_regs_for_reset(adev, &kv_save);
 }
 
@@ -1570,7 +1570,7 @@ static void cik_pcie_gen3_enable(struct amdgpu_device *adev)
 	if (amdgpu_pcie_gen2 == 0)
 		return;
 
-	if (adev->flags & AMDGPU_IS_APU)
+	if (adev->flags & AMD_IS_APU)
 		return;
 
 	ret = drm_pcie_get_speed_cap_mask(adev->ddev, &mask);
@@ -1730,7 +1730,7 @@ static void cik_program_aspm(struct amdgpu_device *adev)
 		return;
 
 	/* XXX double check APUs */
-	if (adev->flags & AMDGPU_IS_APU)
+	if (adev->flags & AMD_IS_APU)
 		return;
 
 	orig = data = RREG32_PCIE(ixPCIE_LC_N_FTS_CNTL);

commit 130e0371b7d454bb4a861253c822b9f911ad5d19
Author: Oded Gabbay <oded.gabbay@gmail.com>
Date:   Fri Jun 12 21:35:14 2015 +0300

    drm/amdgpu: Add H/W agnostic amdgpu <--> amdkfd interface
    
    This patch adds an interface file between amdgpu and amdkfd. This
    interface file is H/W agnostic, thus containing functions that
    operate the same for any AMD APU/GPU H/W generation.
    
    The functions in this interface mirror (some) of the functions in
    radeon_kfd.c (the radeon<-->amdkfd interface file). The main functions
    are:
    
    - amdgpu_amdkfd_init - initialize the amdkfd module
    - amdgpu_amdkfd_load_interface - load the H/W interface according to the
      currently probed device
    - amdgpu_amdkfd_device_probe - probe the device in amdkfd
    - amdgpu_amdkfd_device_init - initialize the device in amdkfd
    - amdgpu_amdkfd_interrupt - call the ISR of amdkfd
    - amdgpu_amdkfd_suspend - suspend callback from amdgpu
    - amdgpu_amdkfd_resume - resume callback from amdgpu
    
    This patch also modifies the relevant amdgpu files, to use this new
    interface.
    
    Signed-off-by: Oded Gabbay <oded.gabbay@gmail.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 341c56681841..b3b66a0d5ff7 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -64,6 +64,8 @@
 #include "oss/oss_2_0_d.h"
 #include "oss/oss_2_0_sh_mask.h"
 
+#include "amdgpu_amdkfd.h"
+
 /*
  * Indirect registers accessor
  */
@@ -2448,14 +2450,21 @@ static int cik_common_suspend(void *handle)
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
+	amdgpu_amdkfd_suspend(adev);
+
 	return cik_common_hw_fini(adev);
 }
 
 static int cik_common_resume(void *handle)
 {
+	int r;
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
-	return cik_common_hw_init(adev);
+	r = cik_common_hw_init(adev);
+	if (r)
+		return r;
+
+	return amdgpu_amdkfd_resume(adev);
 }
 
 static bool cik_common_is_idle(void *handle)

commit d8d090b711bc56e095e59f9b536ed3c73c47b36d
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Jun 26 13:02:57 2015 -0400

    drm/amdgpu: allocate ip_block_enabled memory in common code
    
    Remove duplication across asic families and make it symmetric
    with the freeing of the code in amdgpu_device.c
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 5dab578d6462..341c56681841 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -2256,10 +2256,6 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		return -EINVAL;
 	}
 
-	adev->ip_block_enabled = kcalloc(adev->num_ip_blocks, sizeof(bool), GFP_KERNEL);
-	if (adev->ip_block_enabled == NULL)
-		return -ENOMEM;
-
 	return 0;
 }
 

commit 5fc3aeeb9e553a20ce62544f7176c6c4aca52d71
Author: yanyang1 <young.yang@amd.com>
Date:   Fri May 22 14:39:35 2015 -0400

    drm/amdgpu: rename amdgpu_ip_funcs to amd_ip_funcs (v2)
    
    The structure is renamed and moved to amd_shared.h to make
    the component independent.  This makes it easier to add
    new components in the future.
    
    v2: fix include path
    
    Reviewed-by: Jammy Zhou <Jammy.Zhou@amd.com>
    Signed-off-by: yanyang1 <young.yang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index 74ce0be2fbb7..5dab578d6462 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -1892,63 +1892,63 @@ static const struct amdgpu_ip_block_version bonaire_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
 		.major = 1,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_common_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.type = AMD_IP_BLOCK_TYPE_GMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &gmc_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.type = AMD_IP_BLOCK_TYPE_IH,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_ih_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.type = AMD_IP_BLOCK_TYPE_SMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &ci_dpm_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_DCE,
+		.type = AMD_IP_BLOCK_TYPE_DCE,
 		.major = 8,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &dce_v8_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.type = AMD_IP_BLOCK_TYPE_GFX,
 		.major = 7,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &gfx_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_sdma_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_UVD,
+		.type = AMD_IP_BLOCK_TYPE_UVD,
 		.major = 4,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &uvd_v4_2_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_VCE,
+		.type = AMD_IP_BLOCK_TYPE_VCE,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
@@ -1960,63 +1960,63 @@ static const struct amdgpu_ip_block_version hawaii_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
 		.major = 1,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_common_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.type = AMD_IP_BLOCK_TYPE_GMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &gmc_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.type = AMD_IP_BLOCK_TYPE_IH,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_ih_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.type = AMD_IP_BLOCK_TYPE_SMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &ci_dpm_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_DCE,
+		.type = AMD_IP_BLOCK_TYPE_DCE,
 		.major = 8,
 		.minor = 5,
 		.rev = 0,
 		.funcs = &dce_v8_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.type = AMD_IP_BLOCK_TYPE_GFX,
 		.major = 7,
 		.minor = 3,
 		.rev = 0,
 		.funcs = &gfx_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_sdma_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_UVD,
+		.type = AMD_IP_BLOCK_TYPE_UVD,
 		.major = 4,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &uvd_v4_2_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_VCE,
+		.type = AMD_IP_BLOCK_TYPE_VCE,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
@@ -2028,63 +2028,63 @@ static const struct amdgpu_ip_block_version kabini_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
 		.major = 1,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_common_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.type = AMD_IP_BLOCK_TYPE_GMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &gmc_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.type = AMD_IP_BLOCK_TYPE_IH,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_ih_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.type = AMD_IP_BLOCK_TYPE_SMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &kv_dpm_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_DCE,
+		.type = AMD_IP_BLOCK_TYPE_DCE,
 		.major = 8,
 		.minor = 3,
 		.rev = 0,
 		.funcs = &dce_v8_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.type = AMD_IP_BLOCK_TYPE_GFX,
 		.major = 7,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &gfx_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_sdma_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_UVD,
+		.type = AMD_IP_BLOCK_TYPE_UVD,
 		.major = 4,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &uvd_v4_2_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_VCE,
+		.type = AMD_IP_BLOCK_TYPE_VCE,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
@@ -2096,63 +2096,63 @@ static const struct amdgpu_ip_block_version mullins_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
 		.major = 1,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_common_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.type = AMD_IP_BLOCK_TYPE_GMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &gmc_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.type = AMD_IP_BLOCK_TYPE_IH,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_ih_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.type = AMD_IP_BLOCK_TYPE_SMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &kv_dpm_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_DCE,
+		.type = AMD_IP_BLOCK_TYPE_DCE,
 		.major = 8,
 		.minor = 3,
 		.rev = 0,
 		.funcs = &dce_v8_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.type = AMD_IP_BLOCK_TYPE_GFX,
 		.major = 7,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &gfx_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_sdma_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_UVD,
+		.type = AMD_IP_BLOCK_TYPE_UVD,
 		.major = 4,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &uvd_v4_2_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_VCE,
+		.type = AMD_IP_BLOCK_TYPE_VCE,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
@@ -2164,63 +2164,63 @@ static const struct amdgpu_ip_block_version kaveri_ip_blocks[] =
 {
 	/* ORDER MATTERS! */
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.type = AMD_IP_BLOCK_TYPE_COMMON,
 		.major = 1,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_common_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.type = AMD_IP_BLOCK_TYPE_GMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &gmc_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.type = AMD_IP_BLOCK_TYPE_IH,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_ih_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.type = AMD_IP_BLOCK_TYPE_SMC,
 		.major = 7,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &kv_dpm_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_DCE,
+		.type = AMD_IP_BLOCK_TYPE_DCE,
 		.major = 8,
 		.minor = 1,
 		.rev = 0,
 		.funcs = &dce_v8_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.type = AMD_IP_BLOCK_TYPE_GFX,
 		.major = 7,
 		.minor = 1,
 		.rev = 0,
 		.funcs = &gfx_v7_0_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.type = AMD_IP_BLOCK_TYPE_SDMA,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
 		.funcs = &cik_sdma_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_UVD,
+		.type = AMD_IP_BLOCK_TYPE_UVD,
 		.major = 4,
 		.minor = 2,
 		.rev = 0,
 		.funcs = &uvd_v4_2_ip_funcs,
 	},
 	{
-		.type = AMDGPU_IP_BLOCK_TYPE_VCE,
+		.type = AMD_IP_BLOCK_TYPE_VCE,
 		.major = 2,
 		.minor = 0,
 		.rev = 0,
@@ -2278,8 +2278,10 @@ static const struct amdgpu_asic_funcs cik_asic_funcs =
 	.wait_for_mc_idle = &gmc_v7_0_mc_wait_for_idle,
 };
 
-static int cik_common_early_init(struct amdgpu_device *adev)
+static int cik_common_early_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	adev->smc_rreg = &cik_smc_rreg;
 	adev->smc_wreg = &cik_smc_wreg;
 	adev->pcie_rreg = &cik_pcie_rreg;
@@ -2417,18 +2419,20 @@ static int cik_common_early_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int cik_common_sw_init(struct amdgpu_device *adev)
+static int cik_common_sw_init(void *handle)
 {
 	return 0;
 }
 
-static int cik_common_sw_fini(struct amdgpu_device *adev)
+static int cik_common_sw_fini(void *handle)
 {
 	return 0;
 }
 
-static int cik_common_hw_init(struct amdgpu_device *adev)
+static int cik_common_hw_init(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	/* move the golden regs per IP block */
 	cik_init_golden_registers(adev);
 	/* enable pcie gen2/3 link */
@@ -2439,55 +2443,59 @@ static int cik_common_hw_init(struct amdgpu_device *adev)
 	return 0;
 }
 
-static int cik_common_hw_fini(struct amdgpu_device *adev)
+static int cik_common_hw_fini(void *handle)
 {
 	return 0;
 }
 
-static int cik_common_suspend(struct amdgpu_device *adev)
+static int cik_common_suspend(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return cik_common_hw_fini(adev);
 }
 
-static int cik_common_resume(struct amdgpu_device *adev)
+static int cik_common_resume(void *handle)
 {
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
 	return cik_common_hw_init(adev);
 }
 
-static bool cik_common_is_idle(struct amdgpu_device *adev)
+static bool cik_common_is_idle(void *handle)
 {
 	return true;
 }
 
-static int cik_common_wait_for_idle(struct amdgpu_device *adev)
+static int cik_common_wait_for_idle(void *handle)
 {
 	return 0;
 }
 
-static void cik_common_print_status(struct amdgpu_device *adev)
+static void cik_common_print_status(void *handle)
 {
 
 }
 
-static int cik_common_soft_reset(struct amdgpu_device *adev)
+static int cik_common_soft_reset(void *handle)
 {
 	/* XXX hard reset?? */
 	return 0;
 }
 
-static int cik_common_set_clockgating_state(struct amdgpu_device *adev,
-					    enum amdgpu_clockgating_state state)
+static int cik_common_set_clockgating_state(void *handle,
+					    enum amd_clockgating_state state)
 {
 	return 0;
 }
 
-static int cik_common_set_powergating_state(struct amdgpu_device *adev,
-					    enum amdgpu_powergating_state state)
+static int cik_common_set_powergating_state(void *handle,
+					    enum amd_powergating_state state)
 {
 	return 0;
 }
 
-const struct amdgpu_ip_funcs cik_common_ip_funcs = {
+const struct amd_ip_funcs cik_common_ip_funcs = {
 	.early_init = cik_common_early_init,
 	.late_init = NULL,
 	.sw_init = cik_common_sw_init,

commit a2e73f56fa6282481927ec43aa9362c03c2e2104
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Apr 20 17:09:27 2015 -0400

    drm/amdgpu: Add support for CIK parts
    
    This patch adds support for CIK parts.  These parts
    are also supported by radeon which is the preferred
    option, so there is a config option to enable support
    for CIK parts in amdgpu for testing.
    
    Acked-by: Christian König <christian.koenig@amd.com>
    Acked-by: Jammy Zhou <Jammy.Zhou@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
new file mode 100644
index 000000000000..74ce0be2fbb7
--- /dev/null
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -0,0 +1,2505 @@
+/*
+ * Copyright 2012 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Alex Deucher
+ */
+#include <linux/firmware.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include "drmP.h"
+#include "amdgpu.h"
+#include "amdgpu_atombios.h"
+#include "amdgpu_ih.h"
+#include "amdgpu_uvd.h"
+#include "amdgpu_vce.h"
+#include "cikd.h"
+#include "atom.h"
+
+#include "cik.h"
+#include "gmc_v7_0.h"
+#include "cik_ih.h"
+#include "dce_v8_0.h"
+#include "gfx_v7_0.h"
+#include "cik_sdma.h"
+#include "uvd_v4_2.h"
+#include "vce_v2_0.h"
+#include "cik_dpm.h"
+
+#include "uvd/uvd_4_2_d.h"
+
+#include "smu/smu_7_0_1_d.h"
+#include "smu/smu_7_0_1_sh_mask.h"
+
+#include "dce/dce_8_0_d.h"
+#include "dce/dce_8_0_sh_mask.h"
+
+#include "bif/bif_4_1_d.h"
+#include "bif/bif_4_1_sh_mask.h"
+
+#include "gca/gfx_7_2_d.h"
+#include "gca/gfx_7_2_enum.h"
+#include "gca/gfx_7_2_sh_mask.h"
+
+#include "gmc/gmc_7_1_d.h"
+#include "gmc/gmc_7_1_sh_mask.h"
+
+#include "oss/oss_2_0_d.h"
+#include "oss/oss_2_0_sh_mask.h"
+
+/*
+ * Indirect registers accessor
+ */
+static u32 cik_pcie_rreg(struct amdgpu_device *adev, u32 reg)
+{
+	unsigned long flags;
+	u32 r;
+
+	spin_lock_irqsave(&adev->pcie_idx_lock, flags);
+	WREG32(mmPCIE_INDEX, reg);
+	(void)RREG32(mmPCIE_INDEX);
+	r = RREG32(mmPCIE_DATA);
+	spin_unlock_irqrestore(&adev->pcie_idx_lock, flags);
+	return r;
+}
+
+static void cik_pcie_wreg(struct amdgpu_device *adev, u32 reg, u32 v)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&adev->pcie_idx_lock, flags);
+	WREG32(mmPCIE_INDEX, reg);
+	(void)RREG32(mmPCIE_INDEX);
+	WREG32(mmPCIE_DATA, v);
+	(void)RREG32(mmPCIE_DATA);
+	spin_unlock_irqrestore(&adev->pcie_idx_lock, flags);
+}
+
+static u32 cik_smc_rreg(struct amdgpu_device *adev, u32 reg)
+{
+	unsigned long flags;
+	u32 r;
+
+	spin_lock_irqsave(&adev->smc_idx_lock, flags);
+	WREG32(mmSMC_IND_INDEX_0, (reg));
+	r = RREG32(mmSMC_IND_DATA_0);
+	spin_unlock_irqrestore(&adev->smc_idx_lock, flags);
+	return r;
+}
+
+static void cik_smc_wreg(struct amdgpu_device *adev, u32 reg, u32 v)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&adev->smc_idx_lock, flags);
+	WREG32(mmSMC_IND_INDEX_0, (reg));
+	WREG32(mmSMC_IND_DATA_0, (v));
+	spin_unlock_irqrestore(&adev->smc_idx_lock, flags);
+}
+
+static u32 cik_uvd_ctx_rreg(struct amdgpu_device *adev, u32 reg)
+{
+	unsigned long flags;
+	u32 r;
+
+	spin_lock_irqsave(&adev->uvd_ctx_idx_lock, flags);
+	WREG32(mmUVD_CTX_INDEX, ((reg) & 0x1ff));
+	r = RREG32(mmUVD_CTX_DATA);
+	spin_unlock_irqrestore(&adev->uvd_ctx_idx_lock, flags);
+	return r;
+}
+
+static void cik_uvd_ctx_wreg(struct amdgpu_device *adev, u32 reg, u32 v)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&adev->uvd_ctx_idx_lock, flags);
+	WREG32(mmUVD_CTX_INDEX, ((reg) & 0x1ff));
+	WREG32(mmUVD_CTX_DATA, (v));
+	spin_unlock_irqrestore(&adev->uvd_ctx_idx_lock, flags);
+}
+
+static u32 cik_didt_rreg(struct amdgpu_device *adev, u32 reg)
+{
+	unsigned long flags;
+	u32 r;
+
+	spin_lock_irqsave(&adev->didt_idx_lock, flags);
+	WREG32(mmDIDT_IND_INDEX, (reg));
+	r = RREG32(mmDIDT_IND_DATA);
+	spin_unlock_irqrestore(&adev->didt_idx_lock, flags);
+	return r;
+}
+
+static void cik_didt_wreg(struct amdgpu_device *adev, u32 reg, u32 v)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&adev->didt_idx_lock, flags);
+	WREG32(mmDIDT_IND_INDEX, (reg));
+	WREG32(mmDIDT_IND_DATA, (v));
+	spin_unlock_irqrestore(&adev->didt_idx_lock, flags);
+}
+
+static const u32 bonaire_golden_spm_registers[] =
+{
+	0xc200, 0xe0ffffff, 0xe0000000
+};
+
+static const u32 bonaire_golden_common_registers[] =
+{
+	0x31dc, 0xffffffff, 0x00000800,
+	0x31dd, 0xffffffff, 0x00000800,
+	0x31e6, 0xffffffff, 0x00007fbf,
+	0x31e7, 0xffffffff, 0x00007faf
+};
+
+static const u32 bonaire_golden_registers[] =
+{
+	0xcd5, 0x00000333, 0x00000333,
+	0xcd4, 0x000c0fc0, 0x00040200,
+	0x2684, 0x00010000, 0x00058208,
+	0xf000, 0xffff1fff, 0x00140000,
+	0xf080, 0xfdfc0fff, 0x00000100,
+	0xf08d, 0x40000000, 0x40000200,
+	0x260c, 0xffffffff, 0x00000000,
+	0x260d, 0xf00fffff, 0x00000400,
+	0x260e, 0x0002021c, 0x00020200,
+	0x31e, 0x00000080, 0x00000000,
+	0x16ec, 0x000000f0, 0x00000070,
+	0x16f0, 0xf0311fff, 0x80300000,
+	0x263e, 0x73773777, 0x12010001,
+	0xd43, 0x00810000, 0x408af000,
+	0x1c0c, 0x31000111, 0x00000011,
+	0xbd2, 0x73773777, 0x12010001,
+	0x883, 0x00007fb6, 0x0021a1b1,
+	0x884, 0x00007fb6, 0x002021b1,
+	0x860, 0x00007fb6, 0x00002191,
+	0x886, 0x00007fb6, 0x002121b1,
+	0x887, 0x00007fb6, 0x002021b1,
+	0x877, 0x00007fb6, 0x00002191,
+	0x878, 0x00007fb6, 0x00002191,
+	0xd8a, 0x0000003f, 0x0000000a,
+	0xd8b, 0x0000003f, 0x0000000a,
+	0xab9, 0x00073ffe, 0x000022a2,
+	0x903, 0x000007ff, 0x00000000,
+	0x2285, 0xf000003f, 0x00000007,
+	0x22fc, 0x00002001, 0x00000001,
+	0x22c9, 0xffffffff, 0x00ffffff,
+	0xc281, 0x0000ff0f, 0x00000000,
+	0xa293, 0x07ffffff, 0x06000000,
+	0x136, 0x00000fff, 0x00000100,
+	0xf9e, 0x00000001, 0x00000002,
+	0x2440, 0x03000000, 0x0362c688,
+	0x2300, 0x000000ff, 0x00000001,
+	0x390, 0x00001fff, 0x00001fff,
+	0x2418, 0x0000007f, 0x00000020,
+	0x2542, 0x00010000, 0x00010000,
+	0x2b05, 0x000003ff, 0x000000f3,
+	0x2b03, 0xffffffff, 0x00001032
+};
+
+static const u32 bonaire_mgcg_cgcg_init[] =
+{
+	0x3108, 0xffffffff, 0xfffffffc,
+	0xc200, 0xffffffff, 0xe0000000,
+	0xf0a8, 0xffffffff, 0x00000100,
+	0xf082, 0xffffffff, 0x00000100,
+	0xf0b0, 0xffffffff, 0xc0000100,
+	0xf0b2, 0xffffffff, 0xc0000100,
+	0xf0b1, 0xffffffff, 0xc0000100,
+	0x1579, 0xffffffff, 0x00600100,
+	0xf0a0, 0xffffffff, 0x00000100,
+	0xf085, 0xffffffff, 0x06000100,
+	0xf088, 0xffffffff, 0x00000100,
+	0xf086, 0xffffffff, 0x06000100,
+	0xf081, 0xffffffff, 0x00000100,
+	0xf0b8, 0xffffffff, 0x00000100,
+	0xf089, 0xffffffff, 0x00000100,
+	0xf080, 0xffffffff, 0x00000100,
+	0xf08c, 0xffffffff, 0x00000100,
+	0xf08d, 0xffffffff, 0x00000100,
+	0xf094, 0xffffffff, 0x00000100,
+	0xf095, 0xffffffff, 0x00000100,
+	0xf096, 0xffffffff, 0x00000100,
+	0xf097, 0xffffffff, 0x00000100,
+	0xf098, 0xffffffff, 0x00000100,
+	0xf09f, 0xffffffff, 0x00000100,
+	0xf09e, 0xffffffff, 0x00000100,
+	0xf084, 0xffffffff, 0x06000100,
+	0xf0a4, 0xffffffff, 0x00000100,
+	0xf09d, 0xffffffff, 0x00000100,
+	0xf0ad, 0xffffffff, 0x00000100,
+	0xf0ac, 0xffffffff, 0x00000100,
+	0xf09c, 0xffffffff, 0x00000100,
+	0xc200, 0xffffffff, 0xe0000000,
+	0xf008, 0xffffffff, 0x00010000,
+	0xf009, 0xffffffff, 0x00030002,
+	0xf00a, 0xffffffff, 0x00040007,
+	0xf00b, 0xffffffff, 0x00060005,
+	0xf00c, 0xffffffff, 0x00090008,
+	0xf00d, 0xffffffff, 0x00010000,
+	0xf00e, 0xffffffff, 0x00030002,
+	0xf00f, 0xffffffff, 0x00040007,
+	0xf010, 0xffffffff, 0x00060005,
+	0xf011, 0xffffffff, 0x00090008,
+	0xf012, 0xffffffff, 0x00010000,
+	0xf013, 0xffffffff, 0x00030002,
+	0xf014, 0xffffffff, 0x00040007,
+	0xf015, 0xffffffff, 0x00060005,
+	0xf016, 0xffffffff, 0x00090008,
+	0xf017, 0xffffffff, 0x00010000,
+	0xf018, 0xffffffff, 0x00030002,
+	0xf019, 0xffffffff, 0x00040007,
+	0xf01a, 0xffffffff, 0x00060005,
+	0xf01b, 0xffffffff, 0x00090008,
+	0xf01c, 0xffffffff, 0x00010000,
+	0xf01d, 0xffffffff, 0x00030002,
+	0xf01e, 0xffffffff, 0x00040007,
+	0xf01f, 0xffffffff, 0x00060005,
+	0xf020, 0xffffffff, 0x00090008,
+	0xf021, 0xffffffff, 0x00010000,
+	0xf022, 0xffffffff, 0x00030002,
+	0xf023, 0xffffffff, 0x00040007,
+	0xf024, 0xffffffff, 0x00060005,
+	0xf025, 0xffffffff, 0x00090008,
+	0xf026, 0xffffffff, 0x00010000,
+	0xf027, 0xffffffff, 0x00030002,
+	0xf028, 0xffffffff, 0x00040007,
+	0xf029, 0xffffffff, 0x00060005,
+	0xf02a, 0xffffffff, 0x00090008,
+	0xf000, 0xffffffff, 0x96e00200,
+	0x21c2, 0xffffffff, 0x00900100,
+	0x3109, 0xffffffff, 0x0020003f,
+	0xe, 0xffffffff, 0x0140001c,
+	0xf, 0x000f0000, 0x000f0000,
+	0x88, 0xffffffff, 0xc060000c,
+	0x89, 0xc0000fff, 0x00000100,
+	0x3e4, 0xffffffff, 0x00000100,
+	0x3e6, 0x00000101, 0x00000000,
+	0x82a, 0xffffffff, 0x00000104,
+	0x1579, 0xff000fff, 0x00000100,
+	0xc33, 0xc0000fff, 0x00000104,
+	0x3079, 0x00000001, 0x00000001,
+	0x3403, 0xff000ff0, 0x00000100,
+	0x3603, 0xff000ff0, 0x00000100
+};
+
+static const u32 spectre_golden_spm_registers[] =
+{
+	0xc200, 0xe0ffffff, 0xe0000000
+};
+
+static const u32 spectre_golden_common_registers[] =
+{
+	0x31dc, 0xffffffff, 0x00000800,
+	0x31dd, 0xffffffff, 0x00000800,
+	0x31e6, 0xffffffff, 0x00007fbf,
+	0x31e7, 0xffffffff, 0x00007faf
+};
+
+static const u32 spectre_golden_registers[] =
+{
+	0xf000, 0xffff1fff, 0x96940200,
+	0xf003, 0xffff0001, 0xff000000,
+	0xf080, 0xfffc0fff, 0x00000100,
+	0x1bb6, 0x00010101, 0x00010000,
+	0x260d, 0xf00fffff, 0x00000400,
+	0x260e, 0xfffffffc, 0x00020200,
+	0x16ec, 0x000000f0, 0x00000070,
+	0x16f0, 0xf0311fff, 0x80300000,
+	0x263e, 0x73773777, 0x12010001,
+	0x26df, 0x00ff0000, 0x00fc0000,
+	0xbd2, 0x73773777, 0x12010001,
+	0x2285, 0xf000003f, 0x00000007,
+	0x22c9, 0xffffffff, 0x00ffffff,
+	0xa0d4, 0x3f3f3fff, 0x00000082,
+	0xa0d5, 0x0000003f, 0x00000000,
+	0xf9e, 0x00000001, 0x00000002,
+	0x244f, 0xffff03df, 0x00000004,
+	0x31da, 0x00000008, 0x00000008,
+	0x2300, 0x000008ff, 0x00000800,
+	0x2542, 0x00010000, 0x00010000,
+	0x2b03, 0xffffffff, 0x54763210,
+	0x853e, 0x01ff01ff, 0x00000002,
+	0x8526, 0x007ff800, 0x00200000,
+	0x8057, 0xffffffff, 0x00000f40,
+	0xc24d, 0xffffffff, 0x00000001
+};
+
+static const u32 spectre_mgcg_cgcg_init[] =
+{
+	0x3108, 0xffffffff, 0xfffffffc,
+	0xc200, 0xffffffff, 0xe0000000,
+	0xf0a8, 0xffffffff, 0x00000100,
+	0xf082, 0xffffffff, 0x00000100,
+	0xf0b0, 0xffffffff, 0x00000100,
+	0xf0b2, 0xffffffff, 0x00000100,
+	0xf0b1, 0xffffffff, 0x00000100,
+	0x1579, 0xffffffff, 0x00600100,
+	0xf0a0, 0xffffffff, 0x00000100,
+	0xf085, 0xffffffff, 0x06000100,
+	0xf088, 0xffffffff, 0x00000100,
+	0xf086, 0xffffffff, 0x06000100,
+	0xf081, 0xffffffff, 0x00000100,
+	0xf0b8, 0xffffffff, 0x00000100,
+	0xf089, 0xffffffff, 0x00000100,
+	0xf080, 0xffffffff, 0x00000100,
+	0xf08c, 0xffffffff, 0x00000100,
+	0xf08d, 0xffffffff, 0x00000100,
+	0xf094, 0xffffffff, 0x00000100,
+	0xf095, 0xffffffff, 0x00000100,
+	0xf096, 0xffffffff, 0x00000100,
+	0xf097, 0xffffffff, 0x00000100,
+	0xf098, 0xffffffff, 0x00000100,
+	0xf09f, 0xffffffff, 0x00000100,
+	0xf09e, 0xffffffff, 0x00000100,
+	0xf084, 0xffffffff, 0x06000100,
+	0xf0a4, 0xffffffff, 0x00000100,
+	0xf09d, 0xffffffff, 0x00000100,
+	0xf0ad, 0xffffffff, 0x00000100,
+	0xf0ac, 0xffffffff, 0x00000100,
+	0xf09c, 0xffffffff, 0x00000100,
+	0xc200, 0xffffffff, 0xe0000000,
+	0xf008, 0xffffffff, 0x00010000,
+	0xf009, 0xffffffff, 0x00030002,
+	0xf00a, 0xffffffff, 0x00040007,
+	0xf00b, 0xffffffff, 0x00060005,
+	0xf00c, 0xffffffff, 0x00090008,
+	0xf00d, 0xffffffff, 0x00010000,
+	0xf00e, 0xffffffff, 0x00030002,
+	0xf00f, 0xffffffff, 0x00040007,
+	0xf010, 0xffffffff, 0x00060005,
+	0xf011, 0xffffffff, 0x00090008,
+	0xf012, 0xffffffff, 0x00010000,
+	0xf013, 0xffffffff, 0x00030002,
+	0xf014, 0xffffffff, 0x00040007,
+	0xf015, 0xffffffff, 0x00060005,
+	0xf016, 0xffffffff, 0x00090008,
+	0xf017, 0xffffffff, 0x00010000,
+	0xf018, 0xffffffff, 0x00030002,
+	0xf019, 0xffffffff, 0x00040007,
+	0xf01a, 0xffffffff, 0x00060005,
+	0xf01b, 0xffffffff, 0x00090008,
+	0xf01c, 0xffffffff, 0x00010000,
+	0xf01d, 0xffffffff, 0x00030002,
+	0xf01e, 0xffffffff, 0x00040007,
+	0xf01f, 0xffffffff, 0x00060005,
+	0xf020, 0xffffffff, 0x00090008,
+	0xf021, 0xffffffff, 0x00010000,
+	0xf022, 0xffffffff, 0x00030002,
+	0xf023, 0xffffffff, 0x00040007,
+	0xf024, 0xffffffff, 0x00060005,
+	0xf025, 0xffffffff, 0x00090008,
+	0xf026, 0xffffffff, 0x00010000,
+	0xf027, 0xffffffff, 0x00030002,
+	0xf028, 0xffffffff, 0x00040007,
+	0xf029, 0xffffffff, 0x00060005,
+	0xf02a, 0xffffffff, 0x00090008,
+	0xf02b, 0xffffffff, 0x00010000,
+	0xf02c, 0xffffffff, 0x00030002,
+	0xf02d, 0xffffffff, 0x00040007,
+	0xf02e, 0xffffffff, 0x00060005,
+	0xf02f, 0xffffffff, 0x00090008,
+	0xf000, 0xffffffff, 0x96e00200,
+	0x21c2, 0xffffffff, 0x00900100,
+	0x3109, 0xffffffff, 0x0020003f,
+	0xe, 0xffffffff, 0x0140001c,
+	0xf, 0x000f0000, 0x000f0000,
+	0x88, 0xffffffff, 0xc060000c,
+	0x89, 0xc0000fff, 0x00000100,
+	0x3e4, 0xffffffff, 0x00000100,
+	0x3e6, 0x00000101, 0x00000000,
+	0x82a, 0xffffffff, 0x00000104,
+	0x1579, 0xff000fff, 0x00000100,
+	0xc33, 0xc0000fff, 0x00000104,
+	0x3079, 0x00000001, 0x00000001,
+	0x3403, 0xff000ff0, 0x00000100,
+	0x3603, 0xff000ff0, 0x00000100
+};
+
+static const u32 kalindi_golden_spm_registers[] =
+{
+	0xc200, 0xe0ffffff, 0xe0000000
+};
+
+static const u32 kalindi_golden_common_registers[] =
+{
+	0x31dc, 0xffffffff, 0x00000800,
+	0x31dd, 0xffffffff, 0x00000800,
+	0x31e6, 0xffffffff, 0x00007fbf,
+	0x31e7, 0xffffffff, 0x00007faf
+};
+
+static const u32 kalindi_golden_registers[] =
+{
+	0xf000, 0xffffdfff, 0x6e944040,
+	0x1579, 0xff607fff, 0xfc000100,
+	0xf088, 0xff000fff, 0x00000100,
+	0xf089, 0xff000fff, 0x00000100,
+	0xf080, 0xfffc0fff, 0x00000100,
+	0x1bb6, 0x00010101, 0x00010000,
+	0x260c, 0xffffffff, 0x00000000,
+	0x260d, 0xf00fffff, 0x00000400,
+	0x16ec, 0x000000f0, 0x00000070,
+	0x16f0, 0xf0311fff, 0x80300000,
+	0x263e, 0x73773777, 0x12010001,
+	0x263f, 0xffffffff, 0x00000010,
+	0x26df, 0x00ff0000, 0x00fc0000,
+	0x200c, 0x00001f0f, 0x0000100a,
+	0xbd2, 0x73773777, 0x12010001,
+	0x902, 0x000fffff, 0x000c007f,
+	0x2285, 0xf000003f, 0x00000007,
+	0x22c9, 0x3fff3fff, 0x00ffcfff,
+	0xc281, 0x0000ff0f, 0x00000000,
+	0xa293, 0x07ffffff, 0x06000000,
+	0x136, 0x00000fff, 0x00000100,
+	0xf9e, 0x00000001, 0x00000002,
+	0x31da, 0x00000008, 0x00000008,
+	0x2300, 0x000000ff, 0x00000003,
+	0x853e, 0x01ff01ff, 0x00000002,
+	0x8526, 0x007ff800, 0x00200000,
+	0x8057, 0xffffffff, 0x00000f40,
+	0x2231, 0x001f3ae3, 0x00000082,
+	0x2235, 0x0000001f, 0x00000010,
+	0xc24d, 0xffffffff, 0x00000000
+};
+
+static const u32 kalindi_mgcg_cgcg_init[] =
+{
+	0x3108, 0xffffffff, 0xfffffffc,
+	0xc200, 0xffffffff, 0xe0000000,
+	0xf0a8, 0xffffffff, 0x00000100,
+	0xf082, 0xffffffff, 0x00000100,
+	0xf0b0, 0xffffffff, 0x00000100,
+	0xf0b2, 0xffffffff, 0x00000100,
+	0xf0b1, 0xffffffff, 0x00000100,
+	0x1579, 0xffffffff, 0x00600100,
+	0xf0a0, 0xffffffff, 0x00000100,
+	0xf085, 0xffffffff, 0x06000100,
+	0xf088, 0xffffffff, 0x00000100,
+	0xf086, 0xffffffff, 0x06000100,
+	0xf081, 0xffffffff, 0x00000100,
+	0xf0b8, 0xffffffff, 0x00000100,
+	0xf089, 0xffffffff, 0x00000100,
+	0xf080, 0xffffffff, 0x00000100,
+	0xf08c, 0xffffffff, 0x00000100,
+	0xf08d, 0xffffffff, 0x00000100,
+	0xf094, 0xffffffff, 0x00000100,
+	0xf095, 0xffffffff, 0x00000100,
+	0xf096, 0xffffffff, 0x00000100,
+	0xf097, 0xffffffff, 0x00000100,
+	0xf098, 0xffffffff, 0x00000100,
+	0xf09f, 0xffffffff, 0x00000100,
+	0xf09e, 0xffffffff, 0x00000100,
+	0xf084, 0xffffffff, 0x06000100,
+	0xf0a4, 0xffffffff, 0x00000100,
+	0xf09d, 0xffffffff, 0x00000100,
+	0xf0ad, 0xffffffff, 0x00000100,
+	0xf0ac, 0xffffffff, 0x00000100,
+	0xf09c, 0xffffffff, 0x00000100,
+	0xc200, 0xffffffff, 0xe0000000,
+	0xf008, 0xffffffff, 0x00010000,
+	0xf009, 0xffffffff, 0x00030002,
+	0xf00a, 0xffffffff, 0x00040007,
+	0xf00b, 0xffffffff, 0x00060005,
+	0xf00c, 0xffffffff, 0x00090008,
+	0xf00d, 0xffffffff, 0x00010000,
+	0xf00e, 0xffffffff, 0x00030002,
+	0xf00f, 0xffffffff, 0x00040007,
+	0xf010, 0xffffffff, 0x00060005,
+	0xf011, 0xffffffff, 0x00090008,
+	0xf000, 0xffffffff, 0x96e00200,
+	0x21c2, 0xffffffff, 0x00900100,
+	0x3109, 0xffffffff, 0x0020003f,
+	0xe, 0xffffffff, 0x0140001c,
+	0xf, 0x000f0000, 0x000f0000,
+	0x88, 0xffffffff, 0xc060000c,
+	0x89, 0xc0000fff, 0x00000100,
+	0x82a, 0xffffffff, 0x00000104,
+	0x1579, 0xff000fff, 0x00000100,
+	0xc33, 0xc0000fff, 0x00000104,
+	0x3079, 0x00000001, 0x00000001,
+	0x3403, 0xff000ff0, 0x00000100,
+	0x3603, 0xff000ff0, 0x00000100
+};
+
+static const u32 hawaii_golden_spm_registers[] =
+{
+	0xc200, 0xe0ffffff, 0xe0000000
+};
+
+static const u32 hawaii_golden_common_registers[] =
+{
+	0xc200, 0xffffffff, 0xe0000000,
+	0xa0d4, 0xffffffff, 0x3a00161a,
+	0xa0d5, 0xffffffff, 0x0000002e,
+	0x2684, 0xffffffff, 0x00018208,
+	0x263e, 0xffffffff, 0x12011003
+};
+
+static const u32 hawaii_golden_registers[] =
+{
+	0xcd5, 0x00000333, 0x00000333,
+	0x2684, 0x00010000, 0x00058208,
+	0x260c, 0xffffffff, 0x00000000,
+	0x260d, 0xf00fffff, 0x00000400,
+	0x260e, 0x0002021c, 0x00020200,
+	0x31e, 0x00000080, 0x00000000,
+	0x16ec, 0x000000f0, 0x00000070,
+	0x16f0, 0xf0311fff, 0x80300000,
+	0xd43, 0x00810000, 0x408af000,
+	0x1c0c, 0x31000111, 0x00000011,
+	0xbd2, 0x73773777, 0x12010001,
+	0x848, 0x0000007f, 0x0000001b,
+	0x877, 0x00007fb6, 0x00002191,
+	0xd8a, 0x0000003f, 0x0000000a,
+	0xd8b, 0x0000003f, 0x0000000a,
+	0xab9, 0x00073ffe, 0x000022a2,
+	0x903, 0x000007ff, 0x00000000,
+	0x22fc, 0x00002001, 0x00000001,
+	0x22c9, 0xffffffff, 0x00ffffff,
+	0xc281, 0x0000ff0f, 0x00000000,
+	0xa293, 0x07ffffff, 0x06000000,
+	0xf9e, 0x00000001, 0x00000002,
+	0x31da, 0x00000008, 0x00000008,
+	0x31dc, 0x00000f00, 0x00000800,
+	0x31dd, 0x00000f00, 0x00000800,
+	0x31e6, 0x00ffffff, 0x00ff7fbf,
+	0x31e7, 0x00ffffff, 0x00ff7faf,
+	0x2300, 0x000000ff, 0x00000800,
+	0x390, 0x00001fff, 0x00001fff,
+	0x2418, 0x0000007f, 0x00000020,
+	0x2542, 0x00010000, 0x00010000,
+	0x2b80, 0x00100000, 0x000ff07c,
+	0x2b05, 0x000003ff, 0x0000000f,
+	0x2b04, 0xffffffff, 0x7564fdec,
+	0x2b03, 0xffffffff, 0x3120b9a8,
+	0x2b02, 0x20000000, 0x0f9c0000
+};
+
+static const u32 hawaii_mgcg_cgcg_init[] =
+{
+	0x3108, 0xffffffff, 0xfffffffd,
+	0xc200, 0xffffffff, 0xe0000000,
+	0xf0a8, 0xffffffff, 0x00000100,
+	0xf082, 0xffffffff, 0x00000100,
+	0xf0b0, 0xffffffff, 0x00000100,
+	0xf0b2, 0xffffffff, 0x00000100,
+	0xf0b1, 0xffffffff, 0x00000100,
+	0x1579, 0xffffffff, 0x00200100,
+	0xf0a0, 0xffffffff, 0x00000100,
+	0xf085, 0xffffffff, 0x06000100,
+	0xf088, 0xffffffff, 0x00000100,
+	0xf086, 0xffffffff, 0x06000100,
+	0xf081, 0xffffffff, 0x00000100,
+	0xf0b8, 0xffffffff, 0x00000100,
+	0xf089, 0xffffffff, 0x00000100,
+	0xf080, 0xffffffff, 0x00000100,
+	0xf08c, 0xffffffff, 0x00000100,
+	0xf08d, 0xffffffff, 0x00000100,
+	0xf094, 0xffffffff, 0x00000100,
+	0xf095, 0xffffffff, 0x00000100,
+	0xf096, 0xffffffff, 0x00000100,
+	0xf097, 0xffffffff, 0x00000100,
+	0xf098, 0xffffffff, 0x00000100,
+	0xf09f, 0xffffffff, 0x00000100,
+	0xf09e, 0xffffffff, 0x00000100,
+	0xf084, 0xffffffff, 0x06000100,
+	0xf0a4, 0xffffffff, 0x00000100,
+	0xf09d, 0xffffffff, 0x00000100,
+	0xf0ad, 0xffffffff, 0x00000100,
+	0xf0ac, 0xffffffff, 0x00000100,
+	0xf09c, 0xffffffff, 0x00000100,
+	0xc200, 0xffffffff, 0xe0000000,
+	0xf008, 0xffffffff, 0x00010000,
+	0xf009, 0xffffffff, 0x00030002,
+	0xf00a, 0xffffffff, 0x00040007,
+	0xf00b, 0xffffffff, 0x00060005,
+	0xf00c, 0xffffffff, 0x00090008,
+	0xf00d, 0xffffffff, 0x00010000,
+	0xf00e, 0xffffffff, 0x00030002,
+	0xf00f, 0xffffffff, 0x00040007,
+	0xf010, 0xffffffff, 0x00060005,
+	0xf011, 0xffffffff, 0x00090008,
+	0xf012, 0xffffffff, 0x00010000,
+	0xf013, 0xffffffff, 0x00030002,
+	0xf014, 0xffffffff, 0x00040007,
+	0xf015, 0xffffffff, 0x00060005,
+	0xf016, 0xffffffff, 0x00090008,
+	0xf017, 0xffffffff, 0x00010000,
+	0xf018, 0xffffffff, 0x00030002,
+	0xf019, 0xffffffff, 0x00040007,
+	0xf01a, 0xffffffff, 0x00060005,
+	0xf01b, 0xffffffff, 0x00090008,
+	0xf01c, 0xffffffff, 0x00010000,
+	0xf01d, 0xffffffff, 0x00030002,
+	0xf01e, 0xffffffff, 0x00040007,
+	0xf01f, 0xffffffff, 0x00060005,
+	0xf020, 0xffffffff, 0x00090008,
+	0xf021, 0xffffffff, 0x00010000,
+	0xf022, 0xffffffff, 0x00030002,
+	0xf023, 0xffffffff, 0x00040007,
+	0xf024, 0xffffffff, 0x00060005,
+	0xf025, 0xffffffff, 0x00090008,
+	0xf026, 0xffffffff, 0x00010000,
+	0xf027, 0xffffffff, 0x00030002,
+	0xf028, 0xffffffff, 0x00040007,
+	0xf029, 0xffffffff, 0x00060005,
+	0xf02a, 0xffffffff, 0x00090008,
+	0xf02b, 0xffffffff, 0x00010000,
+	0xf02c, 0xffffffff, 0x00030002,
+	0xf02d, 0xffffffff, 0x00040007,
+	0xf02e, 0xffffffff, 0x00060005,
+	0xf02f, 0xffffffff, 0x00090008,
+	0xf030, 0xffffffff, 0x00010000,
+	0xf031, 0xffffffff, 0x00030002,
+	0xf032, 0xffffffff, 0x00040007,
+	0xf033, 0xffffffff, 0x00060005,
+	0xf034, 0xffffffff, 0x00090008,
+	0xf035, 0xffffffff, 0x00010000,
+	0xf036, 0xffffffff, 0x00030002,
+	0xf037, 0xffffffff, 0x00040007,
+	0xf038, 0xffffffff, 0x00060005,
+	0xf039, 0xffffffff, 0x00090008,
+	0xf03a, 0xffffffff, 0x00010000,
+	0xf03b, 0xffffffff, 0x00030002,
+	0xf03c, 0xffffffff, 0x00040007,
+	0xf03d, 0xffffffff, 0x00060005,
+	0xf03e, 0xffffffff, 0x00090008,
+	0x30c6, 0xffffffff, 0x00020200,
+	0xcd4, 0xffffffff, 0x00000200,
+	0x570, 0xffffffff, 0x00000400,
+	0x157a, 0xffffffff, 0x00000000,
+	0xbd4, 0xffffffff, 0x00000902,
+	0xf000, 0xffffffff, 0x96940200,
+	0x21c2, 0xffffffff, 0x00900100,
+	0x3109, 0xffffffff, 0x0020003f,
+	0xe, 0xffffffff, 0x0140001c,
+	0xf, 0x000f0000, 0x000f0000,
+	0x88, 0xffffffff, 0xc060000c,
+	0x89, 0xc0000fff, 0x00000100,
+	0x3e4, 0xffffffff, 0x00000100,
+	0x3e6, 0x00000101, 0x00000000,
+	0x82a, 0xffffffff, 0x00000104,
+	0x1579, 0xff000fff, 0x00000100,
+	0xc33, 0xc0000fff, 0x00000104,
+	0x3079, 0x00000001, 0x00000001,
+	0x3403, 0xff000ff0, 0x00000100,
+	0x3603, 0xff000ff0, 0x00000100
+};
+
+static const u32 godavari_golden_registers[] =
+{
+	0x1579, 0xff607fff, 0xfc000100,
+	0x1bb6, 0x00010101, 0x00010000,
+	0x260c, 0xffffffff, 0x00000000,
+	0x260c0, 0xf00fffff, 0x00000400,
+	0x184c, 0xffffffff, 0x00010000,
+	0x16ec, 0x000000f0, 0x00000070,
+	0x16f0, 0xf0311fff, 0x80300000,
+	0x263e, 0x73773777, 0x12010001,
+	0x263f, 0xffffffff, 0x00000010,
+	0x200c, 0x00001f0f, 0x0000100a,
+	0xbd2, 0x73773777, 0x12010001,
+	0x902, 0x000fffff, 0x000c007f,
+	0x2285, 0xf000003f, 0x00000007,
+	0x22c9, 0xffffffff, 0x00ff0fff,
+	0xc281, 0x0000ff0f, 0x00000000,
+	0xa293, 0x07ffffff, 0x06000000,
+	0x136, 0x00000fff, 0x00000100,
+	0x3405, 0x00010000, 0x00810001,
+	0x3605, 0x00010000, 0x00810001,
+	0xf9e, 0x00000001, 0x00000002,
+	0x31da, 0x00000008, 0x00000008,
+	0x31dc, 0x00000f00, 0x00000800,
+	0x31dd, 0x00000f00, 0x00000800,
+	0x31e6, 0x00ffffff, 0x00ff7fbf,
+	0x31e7, 0x00ffffff, 0x00ff7faf,
+	0x2300, 0x000000ff, 0x00000001,
+	0x853e, 0x01ff01ff, 0x00000002,
+	0x8526, 0x007ff800, 0x00200000,
+	0x8057, 0xffffffff, 0x00000f40,
+	0x2231, 0x001f3ae3, 0x00000082,
+	0x2235, 0x0000001f, 0x00000010,
+	0xc24d, 0xffffffff, 0x00000000
+};
+
+static void cik_init_golden_registers(struct amdgpu_device *adev)
+{
+	/* Some of the registers might be dependent on GRBM_GFX_INDEX */
+	mutex_lock(&adev->grbm_idx_mutex);
+
+	switch (adev->asic_type) {
+	case CHIP_BONAIRE:
+		amdgpu_program_register_sequence(adev,
+						 bonaire_mgcg_cgcg_init,
+						 (const u32)ARRAY_SIZE(bonaire_mgcg_cgcg_init));
+		amdgpu_program_register_sequence(adev,
+						 bonaire_golden_registers,
+						 (const u32)ARRAY_SIZE(bonaire_golden_registers));
+		amdgpu_program_register_sequence(adev,
+						 bonaire_golden_common_registers,
+						 (const u32)ARRAY_SIZE(bonaire_golden_common_registers));
+		amdgpu_program_register_sequence(adev,
+						 bonaire_golden_spm_registers,
+						 (const u32)ARRAY_SIZE(bonaire_golden_spm_registers));
+		break;
+	case CHIP_KABINI:
+		amdgpu_program_register_sequence(adev,
+						 kalindi_mgcg_cgcg_init,
+						 (const u32)ARRAY_SIZE(kalindi_mgcg_cgcg_init));
+		amdgpu_program_register_sequence(adev,
+						 kalindi_golden_registers,
+						 (const u32)ARRAY_SIZE(kalindi_golden_registers));
+		amdgpu_program_register_sequence(adev,
+						 kalindi_golden_common_registers,
+						 (const u32)ARRAY_SIZE(kalindi_golden_common_registers));
+		amdgpu_program_register_sequence(adev,
+						 kalindi_golden_spm_registers,
+						 (const u32)ARRAY_SIZE(kalindi_golden_spm_registers));
+		break;
+	case CHIP_MULLINS:
+		amdgpu_program_register_sequence(adev,
+						 kalindi_mgcg_cgcg_init,
+						 (const u32)ARRAY_SIZE(kalindi_mgcg_cgcg_init));
+		amdgpu_program_register_sequence(adev,
+						 godavari_golden_registers,
+						 (const u32)ARRAY_SIZE(godavari_golden_registers));
+		amdgpu_program_register_sequence(adev,
+						 kalindi_golden_common_registers,
+						 (const u32)ARRAY_SIZE(kalindi_golden_common_registers));
+		amdgpu_program_register_sequence(adev,
+						 kalindi_golden_spm_registers,
+						 (const u32)ARRAY_SIZE(kalindi_golden_spm_registers));
+		break;
+	case CHIP_KAVERI:
+		amdgpu_program_register_sequence(adev,
+						 spectre_mgcg_cgcg_init,
+						 (const u32)ARRAY_SIZE(spectre_mgcg_cgcg_init));
+		amdgpu_program_register_sequence(adev,
+						 spectre_golden_registers,
+						 (const u32)ARRAY_SIZE(spectre_golden_registers));
+		amdgpu_program_register_sequence(adev,
+						 spectre_golden_common_registers,
+						 (const u32)ARRAY_SIZE(spectre_golden_common_registers));
+		amdgpu_program_register_sequence(adev,
+						 spectre_golden_spm_registers,
+						 (const u32)ARRAY_SIZE(spectre_golden_spm_registers));
+		break;
+	case CHIP_HAWAII:
+		amdgpu_program_register_sequence(adev,
+						 hawaii_mgcg_cgcg_init,
+						 (const u32)ARRAY_SIZE(hawaii_mgcg_cgcg_init));
+		amdgpu_program_register_sequence(adev,
+						 hawaii_golden_registers,
+						 (const u32)ARRAY_SIZE(hawaii_golden_registers));
+		amdgpu_program_register_sequence(adev,
+						 hawaii_golden_common_registers,
+						 (const u32)ARRAY_SIZE(hawaii_golden_common_registers));
+		amdgpu_program_register_sequence(adev,
+						 hawaii_golden_spm_registers,
+						 (const u32)ARRAY_SIZE(hawaii_golden_spm_registers));
+		break;
+	default:
+		break;
+	}
+	mutex_unlock(&adev->grbm_idx_mutex);
+}
+
+/**
+ * cik_get_xclk - get the xclk
+ *
+ * @adev: amdgpu_device pointer
+ *
+ * Returns the reference clock used by the gfx engine
+ * (CIK).
+ */
+static u32 cik_get_xclk(struct amdgpu_device *adev)
+{
+	u32 reference_clock = adev->clock.spll.reference_freq;
+
+	if (adev->flags & AMDGPU_IS_APU) {
+		if (RREG32_SMC(ixGENERAL_PWRMGT) & GENERAL_PWRMGT__GPU_COUNTER_CLK_MASK)
+			return reference_clock / 2;
+	} else {
+		if (RREG32_SMC(ixCG_CLKPIN_CNTL) & CG_CLKPIN_CNTL__XTALIN_DIVIDE_MASK)
+			return reference_clock / 4;
+	}
+	return reference_clock;
+}
+
+/**
+ * cik_srbm_select - select specific register instances
+ *
+ * @adev: amdgpu_device pointer
+ * @me: selected ME (micro engine)
+ * @pipe: pipe
+ * @queue: queue
+ * @vmid: VMID
+ *
+ * Switches the currently active registers instances.  Some
+ * registers are instanced per VMID, others are instanced per
+ * me/pipe/queue combination.
+ */
+void cik_srbm_select(struct amdgpu_device *adev,
+		     u32 me, u32 pipe, u32 queue, u32 vmid)
+{
+	u32 srbm_gfx_cntl =
+		(((pipe << SRBM_GFX_CNTL__PIPEID__SHIFT) & SRBM_GFX_CNTL__PIPEID_MASK)|
+		((me << SRBM_GFX_CNTL__MEID__SHIFT) & SRBM_GFX_CNTL__MEID_MASK)|
+		((vmid << SRBM_GFX_CNTL__VMID__SHIFT) & SRBM_GFX_CNTL__VMID_MASK)|
+		((queue << SRBM_GFX_CNTL__QUEUEID__SHIFT) & SRBM_GFX_CNTL__QUEUEID_MASK));
+	WREG32(mmSRBM_GFX_CNTL, srbm_gfx_cntl);
+}
+
+static void cik_vga_set_state(struct amdgpu_device *adev, bool state)
+{
+	uint32_t tmp;
+
+	tmp = RREG32(mmCONFIG_CNTL);
+	if (state == false)
+		tmp |= CONFIG_CNTL__VGA_DIS_MASK;
+	else
+		tmp &= ~CONFIG_CNTL__VGA_DIS_MASK;
+	WREG32(mmCONFIG_CNTL, tmp);
+}
+
+static bool cik_read_disabled_bios(struct amdgpu_device *adev)
+{
+	u32 bus_cntl;
+	u32 d1vga_control = 0;
+	u32 d2vga_control = 0;
+	u32 vga_render_control = 0;
+	u32 rom_cntl;
+	bool r;
+
+	bus_cntl = RREG32(mmBUS_CNTL);
+	if (adev->mode_info.num_crtc) {
+		d1vga_control = RREG32(mmD1VGA_CONTROL);
+		d2vga_control = RREG32(mmD2VGA_CONTROL);
+		vga_render_control = RREG32(mmVGA_RENDER_CONTROL);
+	}
+	rom_cntl = RREG32_SMC(ixROM_CNTL);
+
+	/* enable the rom */
+	WREG32(mmBUS_CNTL, (bus_cntl & ~BUS_CNTL__BIOS_ROM_DIS_MASK));
+	if (adev->mode_info.num_crtc) {
+		/* Disable VGA mode */
+		WREG32(mmD1VGA_CONTROL,
+		       (d1vga_control & ~(D1VGA_CONTROL__D1VGA_MODE_ENABLE_MASK |
+					  D1VGA_CONTROL__D1VGA_TIMING_SELECT_MASK)));
+		WREG32(mmD2VGA_CONTROL,
+		       (d2vga_control & ~(D1VGA_CONTROL__D1VGA_MODE_ENABLE_MASK |
+					  D1VGA_CONTROL__D1VGA_TIMING_SELECT_MASK)));
+		WREG32(mmVGA_RENDER_CONTROL,
+		       (vga_render_control & ~VGA_RENDER_CONTROL__VGA_VSTATUS_CNTL_MASK));
+	}
+	WREG32_SMC(ixROM_CNTL, rom_cntl | ROM_CNTL__SCK_OVERWRITE_MASK);
+
+	r = amdgpu_read_bios(adev);
+
+	/* restore regs */
+	WREG32(mmBUS_CNTL, bus_cntl);
+	if (adev->mode_info.num_crtc) {
+		WREG32(mmD1VGA_CONTROL, d1vga_control);
+		WREG32(mmD2VGA_CONTROL, d2vga_control);
+		WREG32(mmVGA_RENDER_CONTROL, vga_render_control);
+	}
+	WREG32_SMC(ixROM_CNTL, rom_cntl);
+	return r;
+}
+
+static struct amdgpu_allowed_register_entry cik_allowed_read_registers[] = {
+	{mmGRBM_STATUS, false},
+	{mmGB_ADDR_CONFIG, false},
+	{mmMC_ARB_RAMCFG, false},
+	{mmGB_TILE_MODE0, false},
+	{mmGB_TILE_MODE1, false},
+	{mmGB_TILE_MODE2, false},
+	{mmGB_TILE_MODE3, false},
+	{mmGB_TILE_MODE4, false},
+	{mmGB_TILE_MODE5, false},
+	{mmGB_TILE_MODE6, false},
+	{mmGB_TILE_MODE7, false},
+	{mmGB_TILE_MODE8, false},
+	{mmGB_TILE_MODE9, false},
+	{mmGB_TILE_MODE10, false},
+	{mmGB_TILE_MODE11, false},
+	{mmGB_TILE_MODE12, false},
+	{mmGB_TILE_MODE13, false},
+	{mmGB_TILE_MODE14, false},
+	{mmGB_TILE_MODE15, false},
+	{mmGB_TILE_MODE16, false},
+	{mmGB_TILE_MODE17, false},
+	{mmGB_TILE_MODE18, false},
+	{mmGB_TILE_MODE19, false},
+	{mmGB_TILE_MODE20, false},
+	{mmGB_TILE_MODE21, false},
+	{mmGB_TILE_MODE22, false},
+	{mmGB_TILE_MODE23, false},
+	{mmGB_TILE_MODE24, false},
+	{mmGB_TILE_MODE25, false},
+	{mmGB_TILE_MODE26, false},
+	{mmGB_TILE_MODE27, false},
+	{mmGB_TILE_MODE28, false},
+	{mmGB_TILE_MODE29, false},
+	{mmGB_TILE_MODE30, false},
+	{mmGB_TILE_MODE31, false},
+	{mmGB_MACROTILE_MODE0, false},
+	{mmGB_MACROTILE_MODE1, false},
+	{mmGB_MACROTILE_MODE2, false},
+	{mmGB_MACROTILE_MODE3, false},
+	{mmGB_MACROTILE_MODE4, false},
+	{mmGB_MACROTILE_MODE5, false},
+	{mmGB_MACROTILE_MODE6, false},
+	{mmGB_MACROTILE_MODE7, false},
+	{mmGB_MACROTILE_MODE8, false},
+	{mmGB_MACROTILE_MODE9, false},
+	{mmGB_MACROTILE_MODE10, false},
+	{mmGB_MACROTILE_MODE11, false},
+	{mmGB_MACROTILE_MODE12, false},
+	{mmGB_MACROTILE_MODE13, false},
+	{mmGB_MACROTILE_MODE14, false},
+	{mmGB_MACROTILE_MODE15, false},
+	{mmCC_RB_BACKEND_DISABLE, false, true},
+	{mmGC_USER_RB_BACKEND_DISABLE, false, true},
+	{mmGB_BACKEND_MAP, false, false},
+	{mmPA_SC_RASTER_CONFIG, false, true},
+	{mmPA_SC_RASTER_CONFIG_1, false, true},
+};
+
+static uint32_t cik_read_indexed_register(struct amdgpu_device *adev,
+					  u32 se_num, u32 sh_num,
+					  u32 reg_offset)
+{
+	uint32_t val;
+
+	mutex_lock(&adev->grbm_idx_mutex);
+	if (se_num != 0xffffffff || sh_num != 0xffffffff)
+		gfx_v7_0_select_se_sh(adev, se_num, sh_num);
+
+	val = RREG32(reg_offset);
+
+	if (se_num != 0xffffffff || sh_num != 0xffffffff)
+		gfx_v7_0_select_se_sh(adev, 0xffffffff, 0xffffffff);
+	mutex_unlock(&adev->grbm_idx_mutex);
+	return val;
+}
+
+static int cik_read_register(struct amdgpu_device *adev, u32 se_num,
+			     u32 sh_num, u32 reg_offset, u32 *value)
+{
+	uint32_t i;
+
+	*value = 0;
+	for (i = 0; i < ARRAY_SIZE(cik_allowed_read_registers); i++) {
+		if (reg_offset != cik_allowed_read_registers[i].reg_offset)
+			continue;
+
+		if (!cik_allowed_read_registers[i].untouched)
+			*value = cik_allowed_read_registers[i].grbm_indexed ?
+				 cik_read_indexed_register(adev, se_num,
+							   sh_num, reg_offset) :
+				 RREG32(reg_offset);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static void cik_print_gpu_status_regs(struct amdgpu_device *adev)
+{
+	dev_info(adev->dev, "  GRBM_STATUS=0x%08X\n",
+		RREG32(mmGRBM_STATUS));
+	dev_info(adev->dev, "  GRBM_STATUS2=0x%08X\n",
+		RREG32(mmGRBM_STATUS2));
+	dev_info(adev->dev, "  GRBM_STATUS_SE0=0x%08X\n",
+		RREG32(mmGRBM_STATUS_SE0));
+	dev_info(adev->dev, "  GRBM_STATUS_SE1=0x%08X\n",
+		RREG32(mmGRBM_STATUS_SE1));
+	dev_info(adev->dev, "  GRBM_STATUS_SE2=0x%08X\n",
+		RREG32(mmGRBM_STATUS_SE2));
+	dev_info(adev->dev, "  GRBM_STATUS_SE3=0x%08X\n",
+		RREG32(mmGRBM_STATUS_SE3));
+	dev_info(adev->dev, "  SRBM_STATUS=0x%08X\n",
+		RREG32(mmSRBM_STATUS));
+	dev_info(adev->dev, "  SRBM_STATUS2=0x%08X\n",
+		RREG32(mmSRBM_STATUS2));
+	dev_info(adev->dev, "  SDMA0_STATUS_REG   = 0x%08X\n",
+		RREG32(mmSDMA0_STATUS_REG + SDMA0_REGISTER_OFFSET));
+	dev_info(adev->dev, "  SDMA1_STATUS_REG   = 0x%08X\n",
+		 RREG32(mmSDMA0_STATUS_REG + SDMA1_REGISTER_OFFSET));
+	dev_info(adev->dev, "  CP_STAT = 0x%08x\n", RREG32(mmCP_STAT));
+	dev_info(adev->dev, "  CP_STALLED_STAT1 = 0x%08x\n",
+		 RREG32(mmCP_STALLED_STAT1));
+	dev_info(adev->dev, "  CP_STALLED_STAT2 = 0x%08x\n",
+		 RREG32(mmCP_STALLED_STAT2));
+	dev_info(adev->dev, "  CP_STALLED_STAT3 = 0x%08x\n",
+		 RREG32(mmCP_STALLED_STAT3));
+	dev_info(adev->dev, "  CP_CPF_BUSY_STAT = 0x%08x\n",
+		 RREG32(mmCP_CPF_BUSY_STAT));
+	dev_info(adev->dev, "  CP_CPF_STALLED_STAT1 = 0x%08x\n",
+		 RREG32(mmCP_CPF_STALLED_STAT1));
+	dev_info(adev->dev, "  CP_CPF_STATUS = 0x%08x\n", RREG32(mmCP_CPF_STATUS));
+	dev_info(adev->dev, "  CP_CPC_BUSY_STAT = 0x%08x\n", RREG32(mmCP_CPC_BUSY_STAT));
+	dev_info(adev->dev, "  CP_CPC_STALLED_STAT1 = 0x%08x\n",
+		 RREG32(mmCP_CPC_STALLED_STAT1));
+	dev_info(adev->dev, "  CP_CPC_STATUS = 0x%08x\n", RREG32(mmCP_CPC_STATUS));
+}
+
+/**
+ * cik_gpu_check_soft_reset - check which blocks are busy
+ *
+ * @adev: amdgpu_device pointer
+ *
+ * Check which blocks are busy and return the relevant reset
+ * mask to be used by cik_gpu_soft_reset().
+ * Returns a mask of the blocks to be reset.
+ */
+u32 amdgpu_cik_gpu_check_soft_reset(struct amdgpu_device *adev)
+{
+	u32 reset_mask = 0;
+	u32 tmp;
+
+	/* GRBM_STATUS */
+	tmp = RREG32(mmGRBM_STATUS);
+	if (tmp & (GRBM_STATUS__PA_BUSY_MASK | GRBM_STATUS__SC_BUSY_MASK |
+		   GRBM_STATUS__BCI_BUSY_MASK | GRBM_STATUS__SX_BUSY_MASK |
+		   GRBM_STATUS__TA_BUSY_MASK | GRBM_STATUS__VGT_BUSY_MASK |
+		   GRBM_STATUS__DB_BUSY_MASK | GRBM_STATUS__CB_BUSY_MASK |
+		   GRBM_STATUS__GDS_BUSY_MASK | GRBM_STATUS__SPI_BUSY_MASK |
+		   GRBM_STATUS__IA_BUSY_MASK | GRBM_STATUS__IA_BUSY_NO_DMA_MASK))
+		reset_mask |= AMDGPU_RESET_GFX;
+
+	if (tmp & (GRBM_STATUS__CP_BUSY_MASK | GRBM_STATUS__CP_COHERENCY_BUSY_MASK))
+		reset_mask |= AMDGPU_RESET_CP;
+
+	/* GRBM_STATUS2 */
+	tmp = RREG32(mmGRBM_STATUS2);
+	if (tmp & GRBM_STATUS2__RLC_BUSY_MASK)
+		reset_mask |= AMDGPU_RESET_RLC;
+
+	/* SDMA0_STATUS_REG */
+	tmp = RREG32(mmSDMA0_STATUS_REG + SDMA0_REGISTER_OFFSET);
+	if (!(tmp & SDMA0_STATUS_REG__IDLE_MASK))
+		reset_mask |= AMDGPU_RESET_DMA;
+
+	/* SDMA1_STATUS_REG */
+	tmp = RREG32(mmSDMA0_STATUS_REG + SDMA1_REGISTER_OFFSET);
+	if (!(tmp & SDMA0_STATUS_REG__IDLE_MASK))
+		reset_mask |= AMDGPU_RESET_DMA1;
+
+	/* SRBM_STATUS2 */
+	tmp = RREG32(mmSRBM_STATUS2);
+	if (tmp & SRBM_STATUS2__SDMA_BUSY_MASK)
+		reset_mask |= AMDGPU_RESET_DMA;
+
+	if (tmp & SRBM_STATUS2__SDMA1_BUSY_MASK)
+		reset_mask |= AMDGPU_RESET_DMA1;
+
+	/* SRBM_STATUS */
+	tmp = RREG32(mmSRBM_STATUS);
+
+	if (tmp & SRBM_STATUS__IH_BUSY_MASK)
+		reset_mask |= AMDGPU_RESET_IH;
+
+	if (tmp & SRBM_STATUS__SEM_BUSY_MASK)
+		reset_mask |= AMDGPU_RESET_SEM;
+
+	if (tmp & SRBM_STATUS__GRBM_RQ_PENDING_MASK)
+		reset_mask |= AMDGPU_RESET_GRBM;
+
+	if (tmp & SRBM_STATUS__VMC_BUSY_MASK)
+		reset_mask |= AMDGPU_RESET_VMC;
+
+	if (tmp & (SRBM_STATUS__MCB_BUSY_MASK | SRBM_STATUS__MCB_NON_DISPLAY_BUSY_MASK |
+		   SRBM_STATUS__MCC_BUSY_MASK | SRBM_STATUS__MCD_BUSY_MASK))
+		reset_mask |= AMDGPU_RESET_MC;
+
+	if (amdgpu_display_is_display_hung(adev))
+		reset_mask |= AMDGPU_RESET_DISPLAY;
+
+	/* Skip MC reset as it's mostly likely not hung, just busy */
+	if (reset_mask & AMDGPU_RESET_MC) {
+		DRM_DEBUG("MC busy: 0x%08X, clearing.\n", reset_mask);
+		reset_mask &= ~AMDGPU_RESET_MC;
+	}
+
+	return reset_mask;
+}
+
+/**
+ * cik_gpu_soft_reset - soft reset GPU
+ *
+ * @adev: amdgpu_device pointer
+ * @reset_mask: mask of which blocks to reset
+ *
+ * Soft reset the blocks specified in @reset_mask.
+ */
+static void cik_gpu_soft_reset(struct amdgpu_device *adev, u32 reset_mask)
+{
+	struct amdgpu_mode_mc_save save;
+	u32 grbm_soft_reset = 0, srbm_soft_reset = 0;
+	u32 tmp;
+
+	if (reset_mask == 0)
+		return;
+
+	dev_info(adev->dev, "GPU softreset: 0x%08X\n", reset_mask);
+
+	cik_print_gpu_status_regs(adev);
+	dev_info(adev->dev, "  VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x%08X\n",
+		 RREG32(mmVM_CONTEXT1_PROTECTION_FAULT_ADDR));
+	dev_info(adev->dev, "  VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x%08X\n",
+		 RREG32(mmVM_CONTEXT1_PROTECTION_FAULT_STATUS));
+
+	/* disable CG/PG */
+
+	/* stop the rlc */
+	gfx_v7_0_rlc_stop(adev);
+
+	/* Disable GFX parsing/prefetching */
+	WREG32(mmCP_ME_CNTL, CP_ME_CNTL__ME_HALT_MASK | CP_ME_CNTL__PFP_HALT_MASK | CP_ME_CNTL__CE_HALT_MASK);
+
+	/* Disable MEC parsing/prefetching */
+	WREG32(mmCP_MEC_CNTL, CP_MEC_CNTL__MEC_ME1_HALT_MASK | CP_MEC_CNTL__MEC_ME2_HALT_MASK);
+
+	if (reset_mask & AMDGPU_RESET_DMA) {
+		/* sdma0 */
+		tmp = RREG32(mmSDMA0_F32_CNTL + SDMA0_REGISTER_OFFSET);
+		tmp |= SDMA0_F32_CNTL__HALT_MASK;
+		WREG32(mmSDMA0_F32_CNTL + SDMA0_REGISTER_OFFSET, tmp);
+	}
+	if (reset_mask & AMDGPU_RESET_DMA1) {
+		/* sdma1 */
+		tmp = RREG32(mmSDMA0_F32_CNTL + SDMA1_REGISTER_OFFSET);
+		tmp |= SDMA0_F32_CNTL__HALT_MASK;
+		WREG32(mmSDMA0_F32_CNTL + SDMA1_REGISTER_OFFSET, tmp);
+	}
+
+	gmc_v7_0_mc_stop(adev, &save);
+	if (amdgpu_asic_wait_for_mc_idle(adev)) {
+		dev_warn(adev->dev, "Wait for MC idle timedout !\n");
+	}
+
+	if (reset_mask & (AMDGPU_RESET_GFX | AMDGPU_RESET_COMPUTE | AMDGPU_RESET_CP))
+		grbm_soft_reset = GRBM_SOFT_RESET__SOFT_RESET_CP_MASK |
+			GRBM_SOFT_RESET__SOFT_RESET_GFX_MASK;
+
+	if (reset_mask & AMDGPU_RESET_CP) {
+		grbm_soft_reset |= GRBM_SOFT_RESET__SOFT_RESET_CP_MASK;
+
+		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_GRBM_MASK;
+	}
+
+	if (reset_mask & AMDGPU_RESET_DMA)
+		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_SDMA_MASK;
+
+	if (reset_mask & AMDGPU_RESET_DMA1)
+		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_SDMA1_MASK;
+
+	if (reset_mask & AMDGPU_RESET_DISPLAY)
+		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_DC_MASK;
+
+	if (reset_mask & AMDGPU_RESET_RLC)
+		grbm_soft_reset |= GRBM_SOFT_RESET__SOFT_RESET_RLC_MASK;
+
+	if (reset_mask & AMDGPU_RESET_SEM)
+		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_SEM_MASK;
+
+	if (reset_mask & AMDGPU_RESET_IH)
+		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_IH_MASK;
+
+	if (reset_mask & AMDGPU_RESET_GRBM)
+		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_GRBM_MASK;
+
+	if (reset_mask & AMDGPU_RESET_VMC)
+		srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_VMC_MASK;
+
+	if (!(adev->flags & AMDGPU_IS_APU)) {
+		if (reset_mask & AMDGPU_RESET_MC)
+			srbm_soft_reset |= SRBM_SOFT_RESET__SOFT_RESET_MC_MASK;
+	}
+
+	if (grbm_soft_reset) {
+		tmp = RREG32(mmGRBM_SOFT_RESET);
+		tmp |= grbm_soft_reset;
+		dev_info(adev->dev, "GRBM_SOFT_RESET=0x%08X\n", tmp);
+		WREG32(mmGRBM_SOFT_RESET, tmp);
+		tmp = RREG32(mmGRBM_SOFT_RESET);
+
+		udelay(50);
+
+		tmp &= ~grbm_soft_reset;
+		WREG32(mmGRBM_SOFT_RESET, tmp);
+		tmp = RREG32(mmGRBM_SOFT_RESET);
+	}
+
+	if (srbm_soft_reset) {
+		tmp = RREG32(mmSRBM_SOFT_RESET);
+		tmp |= srbm_soft_reset;
+		dev_info(adev->dev, "SRBM_SOFT_RESET=0x%08X\n", tmp);
+		WREG32(mmSRBM_SOFT_RESET, tmp);
+		tmp = RREG32(mmSRBM_SOFT_RESET);
+
+		udelay(50);
+
+		tmp &= ~srbm_soft_reset;
+		WREG32(mmSRBM_SOFT_RESET, tmp);
+		tmp = RREG32(mmSRBM_SOFT_RESET);
+	}
+
+	/* Wait a little for things to settle down */
+	udelay(50);
+
+	gmc_v7_0_mc_resume(adev, &save);
+	udelay(50);
+
+	cik_print_gpu_status_regs(adev);
+}
+
+struct kv_reset_save_regs {
+	u32 gmcon_reng_execute;
+	u32 gmcon_misc;
+	u32 gmcon_misc3;
+};
+
+static void kv_save_regs_for_reset(struct amdgpu_device *adev,
+				   struct kv_reset_save_regs *save)
+{
+	save->gmcon_reng_execute = RREG32(mmGMCON_RENG_EXECUTE);
+	save->gmcon_misc = RREG32(mmGMCON_MISC);
+	save->gmcon_misc3 = RREG32(mmGMCON_MISC3);
+
+	WREG32(mmGMCON_RENG_EXECUTE, save->gmcon_reng_execute &
+		~GMCON_RENG_EXECUTE__RENG_EXECUTE_ON_PWR_UP_MASK);
+	WREG32(mmGMCON_MISC, save->gmcon_misc &
+		~(GMCON_MISC__RENG_EXECUTE_ON_REG_UPDATE_MASK |
+			GMCON_MISC__STCTRL_STUTTER_EN_MASK));
+}
+
+static void kv_restore_regs_for_reset(struct amdgpu_device *adev,
+				      struct kv_reset_save_regs *save)
+{
+	int i;
+
+	WREG32(mmGMCON_PGFSM_WRITE, 0);
+	WREG32(mmGMCON_PGFSM_CONFIG, 0x200010ff);
+
+	for (i = 0; i < 5; i++)
+		WREG32(mmGMCON_PGFSM_WRITE, 0);
+
+	WREG32(mmGMCON_PGFSM_WRITE, 0);
+	WREG32(mmGMCON_PGFSM_CONFIG, 0x300010ff);
+
+	for (i = 0; i < 5; i++)
+		WREG32(mmGMCON_PGFSM_WRITE, 0);
+
+	WREG32(mmGMCON_PGFSM_WRITE, 0x210000);
+	WREG32(mmGMCON_PGFSM_CONFIG, 0xa00010ff);
+
+	for (i = 0; i < 5; i++)
+		WREG32(mmGMCON_PGFSM_WRITE, 0);
+
+	WREG32(mmGMCON_PGFSM_WRITE, 0x21003);
+	WREG32(mmGMCON_PGFSM_CONFIG, 0xb00010ff);
+
+	for (i = 0; i < 5; i++)
+		WREG32(mmGMCON_PGFSM_WRITE, 0);
+
+	WREG32(mmGMCON_PGFSM_WRITE, 0x2b00);
+	WREG32(mmGMCON_PGFSM_CONFIG, 0xc00010ff);
+
+	for (i = 0; i < 5; i++)
+		WREG32(mmGMCON_PGFSM_WRITE, 0);
+
+	WREG32(mmGMCON_PGFSM_WRITE, 0);
+	WREG32(mmGMCON_PGFSM_CONFIG, 0xd00010ff);
+
+	for (i = 0; i < 5; i++)
+		WREG32(mmGMCON_PGFSM_WRITE, 0);
+
+	WREG32(mmGMCON_PGFSM_WRITE, 0x420000);
+	WREG32(mmGMCON_PGFSM_CONFIG, 0x100010ff);
+
+	for (i = 0; i < 5; i++)
+		WREG32(mmGMCON_PGFSM_WRITE, 0);
+
+	WREG32(mmGMCON_PGFSM_WRITE, 0x120202);
+	WREG32(mmGMCON_PGFSM_CONFIG, 0x500010ff);
+
+	for (i = 0; i < 5; i++)
+		WREG32(mmGMCON_PGFSM_WRITE, 0);
+
+	WREG32(mmGMCON_PGFSM_WRITE, 0x3e3e36);
+	WREG32(mmGMCON_PGFSM_CONFIG, 0x600010ff);
+
+	for (i = 0; i < 5; i++)
+		WREG32(mmGMCON_PGFSM_WRITE, 0);
+
+	WREG32(mmGMCON_PGFSM_WRITE, 0x373f3e);
+	WREG32(mmGMCON_PGFSM_CONFIG, 0x700010ff);
+
+	for (i = 0; i < 5; i++)
+		WREG32(mmGMCON_PGFSM_WRITE, 0);
+
+	WREG32(mmGMCON_PGFSM_WRITE, 0x3e1332);
+	WREG32(mmGMCON_PGFSM_CONFIG, 0xe00010ff);
+
+	WREG32(mmGMCON_MISC3, save->gmcon_misc3);
+	WREG32(mmGMCON_MISC, save->gmcon_misc);
+	WREG32(mmGMCON_RENG_EXECUTE, save->gmcon_reng_execute);
+}
+
+static void cik_gpu_pci_config_reset(struct amdgpu_device *adev)
+{
+	struct amdgpu_mode_mc_save save;
+	struct kv_reset_save_regs kv_save = { 0 };
+	u32 tmp, i;
+
+	dev_info(adev->dev, "GPU pci config reset\n");
+
+	/* disable dpm? */
+
+	/* disable cg/pg */
+
+	/* Disable GFX parsing/prefetching */
+	WREG32(mmCP_ME_CNTL, CP_ME_CNTL__ME_HALT_MASK |
+		CP_ME_CNTL__PFP_HALT_MASK | CP_ME_CNTL__CE_HALT_MASK);
+
+	/* Disable MEC parsing/prefetching */
+	WREG32(mmCP_MEC_CNTL,
+			CP_MEC_CNTL__MEC_ME1_HALT_MASK | CP_MEC_CNTL__MEC_ME2_HALT_MASK);
+
+	/* sdma0 */
+	tmp = RREG32(mmSDMA0_F32_CNTL + SDMA0_REGISTER_OFFSET);
+	tmp |= SDMA0_F32_CNTL__HALT_MASK;
+	WREG32(mmSDMA0_F32_CNTL + SDMA0_REGISTER_OFFSET, tmp);
+	/* sdma1 */
+	tmp = RREG32(mmSDMA0_F32_CNTL + SDMA1_REGISTER_OFFSET);
+	tmp |= SDMA0_F32_CNTL__HALT_MASK;
+	WREG32(mmSDMA0_F32_CNTL + SDMA1_REGISTER_OFFSET, tmp);
+	/* XXX other engines? */
+
+	/* halt the rlc, disable cp internal ints */
+	gfx_v7_0_rlc_stop(adev);
+
+	udelay(50);
+
+	/* disable mem access */
+	gmc_v7_0_mc_stop(adev, &save);
+	if (amdgpu_asic_wait_for_mc_idle(adev)) {
+		dev_warn(adev->dev, "Wait for MC idle timed out !\n");
+	}
+
+	if (adev->flags & AMDGPU_IS_APU)
+		kv_save_regs_for_reset(adev, &kv_save);
+
+	/* disable BM */
+	pci_clear_master(adev->pdev);
+	/* reset */
+	amdgpu_pci_config_reset(adev);
+
+	udelay(100);
+
+	/* wait for asic to come out of reset */
+	for (i = 0; i < adev->usec_timeout; i++) {
+		if (RREG32(mmCONFIG_MEMSIZE) != 0xffffffff)
+			break;
+		udelay(1);
+	}
+
+	/* does asic init need to be run first??? */
+	if (adev->flags & AMDGPU_IS_APU)
+		kv_restore_regs_for_reset(adev, &kv_save);
+}
+
+static void cik_set_bios_scratch_engine_hung(struct amdgpu_device *adev, bool hung)
+{
+	u32 tmp = RREG32(mmBIOS_SCRATCH_3);
+
+	if (hung)
+		tmp |= ATOM_S3_ASIC_GUI_ENGINE_HUNG;
+	else
+		tmp &= ~ATOM_S3_ASIC_GUI_ENGINE_HUNG;
+
+	WREG32(mmBIOS_SCRATCH_3, tmp);
+}
+
+/**
+ * cik_asic_reset - soft reset GPU
+ *
+ * @adev: amdgpu_device pointer
+ *
+ * Look up which blocks are hung and attempt
+ * to reset them.
+ * Returns 0 for success.
+ */
+static int cik_asic_reset(struct amdgpu_device *adev)
+{
+	u32 reset_mask;
+
+	reset_mask = amdgpu_cik_gpu_check_soft_reset(adev);
+
+	if (reset_mask)
+		cik_set_bios_scratch_engine_hung(adev, true);
+
+	/* try soft reset */
+	cik_gpu_soft_reset(adev, reset_mask);
+
+	reset_mask = amdgpu_cik_gpu_check_soft_reset(adev);
+
+	/* try pci config reset */
+	if (reset_mask && amdgpu_hard_reset)
+		cik_gpu_pci_config_reset(adev);
+
+	reset_mask = amdgpu_cik_gpu_check_soft_reset(adev);
+
+	if (!reset_mask)
+		cik_set_bios_scratch_engine_hung(adev, false);
+
+	return 0;
+}
+
+static int cik_set_uvd_clock(struct amdgpu_device *adev, u32 clock,
+			      u32 cntl_reg, u32 status_reg)
+{
+	int r, i;
+	struct atom_clock_dividers dividers;
+	uint32_t tmp;
+
+	r = amdgpu_atombios_get_clock_dividers(adev,
+					       COMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,
+					       clock, false, &dividers);
+	if (r)
+		return r;
+
+	tmp = RREG32_SMC(cntl_reg);
+	tmp &= ~(CG_DCLK_CNTL__DCLK_DIR_CNTL_EN_MASK |
+		CG_DCLK_CNTL__DCLK_DIVIDER_MASK);
+	tmp |= dividers.post_divider;
+	WREG32_SMC(cntl_reg, tmp);
+
+	for (i = 0; i < 100; i++) {
+		if (RREG32_SMC(status_reg) & CG_DCLK_STATUS__DCLK_STATUS_MASK)
+			break;
+		mdelay(10);
+	}
+	if (i == 100)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static int cik_set_uvd_clocks(struct amdgpu_device *adev, u32 vclk, u32 dclk)
+{
+	int r = 0;
+
+	r = cik_set_uvd_clock(adev, vclk, ixCG_VCLK_CNTL, ixCG_VCLK_STATUS);
+	if (r)
+		return r;
+
+	r = cik_set_uvd_clock(adev, dclk, ixCG_DCLK_CNTL, ixCG_DCLK_STATUS);
+	return r;
+}
+
+static int cik_set_vce_clocks(struct amdgpu_device *adev, u32 evclk, u32 ecclk)
+{
+	int r, i;
+	struct atom_clock_dividers dividers;
+	u32 tmp;
+
+	r = amdgpu_atombios_get_clock_dividers(adev,
+					       COMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,
+					       ecclk, false, &dividers);
+	if (r)
+		return r;
+
+	for (i = 0; i < 100; i++) {
+		if (RREG32_SMC(ixCG_ECLK_STATUS) & CG_ECLK_STATUS__ECLK_STATUS_MASK)
+			break;
+		mdelay(10);
+	}
+	if (i == 100)
+		return -ETIMEDOUT;
+
+	tmp = RREG32_SMC(ixCG_ECLK_CNTL);
+	tmp &= ~(CG_ECLK_CNTL__ECLK_DIR_CNTL_EN_MASK |
+		CG_ECLK_CNTL__ECLK_DIVIDER_MASK);
+	tmp |= dividers.post_divider;
+	WREG32_SMC(ixCG_ECLK_CNTL, tmp);
+
+	for (i = 0; i < 100; i++) {
+		if (RREG32_SMC(ixCG_ECLK_STATUS) & CG_ECLK_STATUS__ECLK_STATUS_MASK)
+			break;
+		mdelay(10);
+	}
+	if (i == 100)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static void cik_pcie_gen3_enable(struct amdgpu_device *adev)
+{
+	struct pci_dev *root = adev->pdev->bus->self;
+	int bridge_pos, gpu_pos;
+	u32 speed_cntl, mask, current_data_rate;
+	int ret, i;
+	u16 tmp16;
+
+	if (amdgpu_pcie_gen2 == 0)
+		return;
+
+	if (adev->flags & AMDGPU_IS_APU)
+		return;
+
+	ret = drm_pcie_get_speed_cap_mask(adev->ddev, &mask);
+	if (ret != 0)
+		return;
+
+	if (!(mask & (DRM_PCIE_SPEED_50 | DRM_PCIE_SPEED_80)))
+		return;
+
+	speed_cntl = RREG32_PCIE(ixPCIE_LC_SPEED_CNTL);
+	current_data_rate = (speed_cntl & PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE_MASK) >>
+		PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE__SHIFT;
+	if (mask & DRM_PCIE_SPEED_80) {
+		if (current_data_rate == 2) {
+			DRM_INFO("PCIE gen 3 link speeds already enabled\n");
+			return;
+		}
+		DRM_INFO("enabling PCIE gen 3 link speeds, disable with amdgpu.pcie_gen2=0\n");
+	} else if (mask & DRM_PCIE_SPEED_50) {
+		if (current_data_rate == 1) {
+			DRM_INFO("PCIE gen 2 link speeds already enabled\n");
+			return;
+		}
+		DRM_INFO("enabling PCIE gen 2 link speeds, disable with amdgpu.pcie_gen2=0\n");
+	}
+
+	bridge_pos = pci_pcie_cap(root);
+	if (!bridge_pos)
+		return;
+
+	gpu_pos = pci_pcie_cap(adev->pdev);
+	if (!gpu_pos)
+		return;
+
+	if (mask & DRM_PCIE_SPEED_80) {
+		/* re-try equalization if gen3 is not already enabled */
+		if (current_data_rate != 2) {
+			u16 bridge_cfg, gpu_cfg;
+			u16 bridge_cfg2, gpu_cfg2;
+			u32 max_lw, current_lw, tmp;
+
+			pci_read_config_word(root, bridge_pos + PCI_EXP_LNKCTL, &bridge_cfg);
+			pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL, &gpu_cfg);
+
+			tmp16 = bridge_cfg | PCI_EXP_LNKCTL_HAWD;
+			pci_write_config_word(root, bridge_pos + PCI_EXP_LNKCTL, tmp16);
+
+			tmp16 = gpu_cfg | PCI_EXP_LNKCTL_HAWD;
+			pci_write_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL, tmp16);
+
+			tmp = RREG32_PCIE(ixPCIE_LC_STATUS1);
+			max_lw = (tmp & PCIE_LC_STATUS1__LC_DETECTED_LINK_WIDTH_MASK) >>
+				PCIE_LC_STATUS1__LC_DETECTED_LINK_WIDTH__SHIFT;
+			current_lw = (tmp & PCIE_LC_STATUS1__LC_OPERATING_LINK_WIDTH_MASK)
+				>> PCIE_LC_STATUS1__LC_OPERATING_LINK_WIDTH__SHIFT;
+
+			if (current_lw < max_lw) {
+				tmp = RREG32_PCIE(ixPCIE_LC_LINK_WIDTH_CNTL);
+				if (tmp & PCIE_LC_LINK_WIDTH_CNTL__LC_RENEGOTIATION_SUPPORT_MASK) {
+					tmp &= ~(PCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH_MASK |
+						PCIE_LC_LINK_WIDTH_CNTL__LC_UPCONFIGURE_DIS_MASK);
+					tmp |= (max_lw <<
+						PCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH__SHIFT);
+					tmp |= PCIE_LC_LINK_WIDTH_CNTL__LC_UPCONFIGURE_SUPPORT_MASK |
+					PCIE_LC_LINK_WIDTH_CNTL__LC_RENEGOTIATE_EN_MASK |
+					PCIE_LC_LINK_WIDTH_CNTL__LC_RECONFIG_NOW_MASK;
+					WREG32_PCIE(ixPCIE_LC_LINK_WIDTH_CNTL, tmp);
+				}
+			}
+
+			for (i = 0; i < 10; i++) {
+				/* check status */
+				pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_DEVSTA, &tmp16);
+				if (tmp16 & PCI_EXP_DEVSTA_TRPND)
+					break;
+
+				pci_read_config_word(root, bridge_pos + PCI_EXP_LNKCTL, &bridge_cfg);
+				pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL, &gpu_cfg);
+
+				pci_read_config_word(root, bridge_pos + PCI_EXP_LNKCTL2, &bridge_cfg2);
+				pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL2, &gpu_cfg2);
+
+				tmp = RREG32_PCIE(ixPCIE_LC_CNTL4);
+				tmp |= PCIE_LC_CNTL4__LC_SET_QUIESCE_MASK;
+				WREG32_PCIE(ixPCIE_LC_CNTL4, tmp);
+
+				tmp = RREG32_PCIE(ixPCIE_LC_CNTL4);
+				tmp |= PCIE_LC_CNTL4__LC_REDO_EQ_MASK;
+				WREG32_PCIE(ixPCIE_LC_CNTL4, tmp);
+
+				mdelay(100);
+
+				/* linkctl */
+				pci_read_config_word(root, bridge_pos + PCI_EXP_LNKCTL, &tmp16);
+				tmp16 &= ~PCI_EXP_LNKCTL_HAWD;
+				tmp16 |= (bridge_cfg & PCI_EXP_LNKCTL_HAWD);
+				pci_write_config_word(root, bridge_pos + PCI_EXP_LNKCTL, tmp16);
+
+				pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL, &tmp16);
+				tmp16 &= ~PCI_EXP_LNKCTL_HAWD;
+				tmp16 |= (gpu_cfg & PCI_EXP_LNKCTL_HAWD);
+				pci_write_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL, tmp16);
+
+				/* linkctl2 */
+				pci_read_config_word(root, bridge_pos + PCI_EXP_LNKCTL2, &tmp16);
+				tmp16 &= ~((1 << 4) | (7 << 9));
+				tmp16 |= (bridge_cfg2 & ((1 << 4) | (7 << 9)));
+				pci_write_config_word(root, bridge_pos + PCI_EXP_LNKCTL2, tmp16);
+
+				pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL2, &tmp16);
+				tmp16 &= ~((1 << 4) | (7 << 9));
+				tmp16 |= (gpu_cfg2 & ((1 << 4) | (7 << 9)));
+				pci_write_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL2, tmp16);
+
+				tmp = RREG32_PCIE(ixPCIE_LC_CNTL4);
+				tmp &= ~PCIE_LC_CNTL4__LC_SET_QUIESCE_MASK;
+				WREG32_PCIE(ixPCIE_LC_CNTL4, tmp);
+			}
+		}
+	}
+
+	/* set the link speed */
+	speed_cntl |= PCIE_LC_SPEED_CNTL__LC_FORCE_EN_SW_SPEED_CHANGE_MASK |
+		PCIE_LC_SPEED_CNTL__LC_FORCE_DIS_HW_SPEED_CHANGE_MASK;
+	speed_cntl &= ~PCIE_LC_SPEED_CNTL__LC_FORCE_DIS_SW_SPEED_CHANGE_MASK;
+	WREG32_PCIE(ixPCIE_LC_SPEED_CNTL, speed_cntl);
+
+	pci_read_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL2, &tmp16);
+	tmp16 &= ~0xf;
+	if (mask & DRM_PCIE_SPEED_80)
+		tmp16 |= 3; /* gen3 */
+	else if (mask & DRM_PCIE_SPEED_50)
+		tmp16 |= 2; /* gen2 */
+	else
+		tmp16 |= 1; /* gen1 */
+	pci_write_config_word(adev->pdev, gpu_pos + PCI_EXP_LNKCTL2, tmp16);
+
+	speed_cntl = RREG32_PCIE(ixPCIE_LC_SPEED_CNTL);
+	speed_cntl |= PCIE_LC_SPEED_CNTL__LC_INITIATE_LINK_SPEED_CHANGE_MASK;
+	WREG32_PCIE(ixPCIE_LC_SPEED_CNTL, speed_cntl);
+
+	for (i = 0; i < adev->usec_timeout; i++) {
+		speed_cntl = RREG32_PCIE(ixPCIE_LC_SPEED_CNTL);
+		if ((speed_cntl & PCIE_LC_SPEED_CNTL__LC_INITIATE_LINK_SPEED_CHANGE_MASK) == 0)
+			break;
+		udelay(1);
+	}
+}
+
+static void cik_program_aspm(struct amdgpu_device *adev)
+{
+	u32 data, orig;
+	bool disable_l0s = false, disable_l1 = false, disable_plloff_in_l1 = false;
+	bool disable_clkreq = false;
+
+	if (amdgpu_aspm == 0)
+		return;
+
+	/* XXX double check APUs */
+	if (adev->flags & AMDGPU_IS_APU)
+		return;
+
+	orig = data = RREG32_PCIE(ixPCIE_LC_N_FTS_CNTL);
+	data &= ~PCIE_LC_N_FTS_CNTL__LC_XMIT_N_FTS_MASK;
+	data |= (0x24 << PCIE_LC_N_FTS_CNTL__LC_XMIT_N_FTS__SHIFT) |
+		PCIE_LC_N_FTS_CNTL__LC_XMIT_N_FTS_OVERRIDE_EN_MASK;
+	if (orig != data)
+		WREG32_PCIE(ixPCIE_LC_N_FTS_CNTL, data);
+
+	orig = data = RREG32_PCIE(ixPCIE_LC_CNTL3);
+	data |= PCIE_LC_CNTL3__LC_GO_TO_RECOVERY_MASK;
+	if (orig != data)
+		WREG32_PCIE(ixPCIE_LC_CNTL3, data);
+
+	orig = data = RREG32_PCIE(ixPCIE_P_CNTL);
+	data |= PCIE_P_CNTL__P_IGNORE_EDB_ERR_MASK;
+	if (orig != data)
+		WREG32_PCIE(ixPCIE_P_CNTL, data);
+
+	orig = data = RREG32_PCIE(ixPCIE_LC_CNTL);
+	data &= ~(PCIE_LC_CNTL__LC_L0S_INACTIVITY_MASK |
+		PCIE_LC_CNTL__LC_L1_INACTIVITY_MASK);
+	data |= PCIE_LC_CNTL__LC_PMI_TO_L1_DIS_MASK;
+	if (!disable_l0s)
+		data |= (7 << PCIE_LC_CNTL__LC_L0S_INACTIVITY__SHIFT);
+
+	if (!disable_l1) {
+		data |= (7 << PCIE_LC_CNTL__LC_L1_INACTIVITY__SHIFT);
+		data &= ~PCIE_LC_CNTL__LC_PMI_TO_L1_DIS_MASK;
+		if (orig != data)
+			WREG32_PCIE(ixPCIE_LC_CNTL, data);
+
+		if (!disable_plloff_in_l1) {
+			bool clk_req_support;
+
+			orig = data = RREG32_PCIE(ixPB0_PIF_PWRDOWN_0);
+			data &= ~(PB0_PIF_PWRDOWN_0__PLL_POWER_STATE_IN_OFF_0_MASK |
+				PB0_PIF_PWRDOWN_0__PLL_POWER_STATE_IN_TXS2_0_MASK);
+			data |= (7 << PB0_PIF_PWRDOWN_0__PLL_POWER_STATE_IN_OFF_0__SHIFT) |
+				(7 << PB0_PIF_PWRDOWN_0__PLL_POWER_STATE_IN_TXS2_0__SHIFT);
+			if (orig != data)
+				WREG32_PCIE(ixPB0_PIF_PWRDOWN_0, data);
+
+			orig = data = RREG32_PCIE(ixPB0_PIF_PWRDOWN_1);
+			data &= ~(PB0_PIF_PWRDOWN_1__PLL_POWER_STATE_IN_OFF_1_MASK |
+				PB0_PIF_PWRDOWN_1__PLL_POWER_STATE_IN_TXS2_1_MASK);
+			data |= (7 << PB0_PIF_PWRDOWN_1__PLL_POWER_STATE_IN_OFF_1__SHIFT) |
+				(7 << PB0_PIF_PWRDOWN_1__PLL_POWER_STATE_IN_TXS2_1__SHIFT);
+			if (orig != data)
+				WREG32_PCIE(ixPB0_PIF_PWRDOWN_1, data);
+
+			orig = data = RREG32_PCIE(ixPB1_PIF_PWRDOWN_0);
+			data &= ~(PB1_PIF_PWRDOWN_0__PLL_POWER_STATE_IN_OFF_0_MASK |
+				PB1_PIF_PWRDOWN_0__PLL_POWER_STATE_IN_TXS2_0_MASK);
+			data |= (7 << PB1_PIF_PWRDOWN_0__PLL_POWER_STATE_IN_OFF_0__SHIFT) |
+				(7 << PB1_PIF_PWRDOWN_0__PLL_POWER_STATE_IN_TXS2_0__SHIFT);
+			if (orig != data)
+				WREG32_PCIE(ixPB1_PIF_PWRDOWN_0, data);
+
+			orig = data = RREG32_PCIE(ixPB1_PIF_PWRDOWN_1);
+			data &= ~(PB1_PIF_PWRDOWN_1__PLL_POWER_STATE_IN_OFF_1_MASK |
+				PB1_PIF_PWRDOWN_1__PLL_POWER_STATE_IN_TXS2_1_MASK);
+			data |= (7 << PB1_PIF_PWRDOWN_1__PLL_POWER_STATE_IN_OFF_1__SHIFT) |
+				(7 << PB1_PIF_PWRDOWN_1__PLL_POWER_STATE_IN_TXS2_1__SHIFT);
+			if (orig != data)
+				WREG32_PCIE(ixPB1_PIF_PWRDOWN_1, data);
+
+			orig = data = RREG32_PCIE(ixPCIE_LC_LINK_WIDTH_CNTL);
+			data &= ~PCIE_LC_LINK_WIDTH_CNTL__LC_DYN_LANES_PWR_STATE_MASK;
+			data |= ~(3 << PCIE_LC_LINK_WIDTH_CNTL__LC_DYN_LANES_PWR_STATE__SHIFT);
+			if (orig != data)
+				WREG32_PCIE(ixPCIE_LC_LINK_WIDTH_CNTL, data);
+
+			if (!disable_clkreq) {
+				struct pci_dev *root = adev->pdev->bus->self;
+				u32 lnkcap;
+
+				clk_req_support = false;
+				pcie_capability_read_dword(root, PCI_EXP_LNKCAP, &lnkcap);
+				if (lnkcap & PCI_EXP_LNKCAP_CLKPM)
+					clk_req_support = true;
+			} else {
+				clk_req_support = false;
+			}
+
+			if (clk_req_support) {
+				orig = data = RREG32_PCIE(ixPCIE_LC_CNTL2);
+				data |= PCIE_LC_CNTL2__LC_ALLOW_PDWN_IN_L1_MASK |
+					PCIE_LC_CNTL2__LC_ALLOW_PDWN_IN_L23_MASK;
+				if (orig != data)
+					WREG32_PCIE(ixPCIE_LC_CNTL2, data);
+
+				orig = data = RREG32_SMC(ixTHM_CLK_CNTL);
+				data &= ~(THM_CLK_CNTL__CMON_CLK_SEL_MASK |
+					THM_CLK_CNTL__TMON_CLK_SEL_MASK);
+				data |= (1 << THM_CLK_CNTL__CMON_CLK_SEL__SHIFT) |
+					(1 << THM_CLK_CNTL__TMON_CLK_SEL__SHIFT);
+				if (orig != data)
+					WREG32_SMC(ixTHM_CLK_CNTL, data);
+
+				orig = data = RREG32_SMC(ixMISC_CLK_CTRL);
+				data &= ~(MISC_CLK_CTRL__DEEP_SLEEP_CLK_SEL_MASK |
+					MISC_CLK_CTRL__ZCLK_SEL_MASK);
+				data |= (1 << MISC_CLK_CTRL__DEEP_SLEEP_CLK_SEL__SHIFT) |
+					(1 << MISC_CLK_CTRL__ZCLK_SEL__SHIFT);
+				if (orig != data)
+					WREG32_SMC(ixMISC_CLK_CTRL, data);
+
+				orig = data = RREG32_SMC(ixCG_CLKPIN_CNTL);
+				data &= ~CG_CLKPIN_CNTL__BCLK_AS_XCLK_MASK;
+				if (orig != data)
+					WREG32_SMC(ixCG_CLKPIN_CNTL, data);
+
+				orig = data = RREG32_SMC(ixCG_CLKPIN_CNTL_2);
+				data &= ~CG_CLKPIN_CNTL_2__FORCE_BIF_REFCLK_EN_MASK;
+				if (orig != data)
+					WREG32_SMC(ixCG_CLKPIN_CNTL_2, data);
+
+				orig = data = RREG32_SMC(ixMPLL_BYPASSCLK_SEL);
+				data &= ~MPLL_BYPASSCLK_SEL__MPLL_CLKOUT_SEL_MASK;
+				data |= (4 << MPLL_BYPASSCLK_SEL__MPLL_CLKOUT_SEL__SHIFT);
+				if (orig != data)
+					WREG32_SMC(ixMPLL_BYPASSCLK_SEL, data);
+			}
+		}
+	} else {
+		if (orig != data)
+			WREG32_PCIE(ixPCIE_LC_CNTL, data);
+	}
+
+	orig = data = RREG32_PCIE(ixPCIE_CNTL2);
+	data |= PCIE_CNTL2__SLV_MEM_LS_EN_MASK |
+		PCIE_CNTL2__MST_MEM_LS_EN_MASK |
+		PCIE_CNTL2__REPLAY_MEM_LS_EN_MASK;
+	if (orig != data)
+		WREG32_PCIE(ixPCIE_CNTL2, data);
+
+	if (!disable_l0s) {
+		data = RREG32_PCIE(ixPCIE_LC_N_FTS_CNTL);
+		if ((data & PCIE_LC_N_FTS_CNTL__LC_N_FTS_MASK) ==
+				PCIE_LC_N_FTS_CNTL__LC_N_FTS_MASK) {
+			data = RREG32_PCIE(ixPCIE_LC_STATUS1);
+			if ((data & PCIE_LC_STATUS1__LC_REVERSE_XMIT_MASK) &&
+			(data & PCIE_LC_STATUS1__LC_REVERSE_RCVR_MASK)) {
+				orig = data = RREG32_PCIE(ixPCIE_LC_CNTL);
+				data &= ~PCIE_LC_CNTL__LC_L0S_INACTIVITY_MASK;
+				if (orig != data)
+					WREG32_PCIE(ixPCIE_LC_CNTL, data);
+			}
+		}
+	}
+}
+
+static uint32_t cik_get_rev_id(struct amdgpu_device *adev)
+{
+	return (RREG32(mmCC_DRM_ID_STRAPS) & CC_DRM_ID_STRAPS__ATI_REV_ID_MASK)
+		>> CC_DRM_ID_STRAPS__ATI_REV_ID__SHIFT;
+}
+
+static const struct amdgpu_ip_block_version bonaire_ip_blocks[] =
+{
+	/* ORDER MATTERS! */
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.major = 1,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_common_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &gmc_v7_0_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_ih_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &ci_dpm_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_DCE,
+		.major = 8,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &dce_v8_0_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.major = 7,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &gfx_v7_0_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_sdma_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_UVD,
+		.major = 4,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &uvd_v4_2_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_VCE,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &vce_v2_0_ip_funcs,
+	},
+};
+
+static const struct amdgpu_ip_block_version hawaii_ip_blocks[] =
+{
+	/* ORDER MATTERS! */
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.major = 1,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_common_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &gmc_v7_0_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_ih_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &ci_dpm_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_DCE,
+		.major = 8,
+		.minor = 5,
+		.rev = 0,
+		.funcs = &dce_v8_0_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.major = 7,
+		.minor = 3,
+		.rev = 0,
+		.funcs = &gfx_v7_0_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_sdma_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_UVD,
+		.major = 4,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &uvd_v4_2_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_VCE,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &vce_v2_0_ip_funcs,
+	},
+};
+
+static const struct amdgpu_ip_block_version kabini_ip_blocks[] =
+{
+	/* ORDER MATTERS! */
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.major = 1,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_common_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &gmc_v7_0_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_ih_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &kv_dpm_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_DCE,
+		.major = 8,
+		.minor = 3,
+		.rev = 0,
+		.funcs = &dce_v8_0_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.major = 7,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &gfx_v7_0_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_sdma_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_UVD,
+		.major = 4,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &uvd_v4_2_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_VCE,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &vce_v2_0_ip_funcs,
+	},
+};
+
+static const struct amdgpu_ip_block_version mullins_ip_blocks[] =
+{
+	/* ORDER MATTERS! */
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.major = 1,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_common_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &gmc_v7_0_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_ih_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &kv_dpm_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_DCE,
+		.major = 8,
+		.minor = 3,
+		.rev = 0,
+		.funcs = &dce_v8_0_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.major = 7,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &gfx_v7_0_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_sdma_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_UVD,
+		.major = 4,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &uvd_v4_2_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_VCE,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &vce_v2_0_ip_funcs,
+	},
+};
+
+static const struct amdgpu_ip_block_version kaveri_ip_blocks[] =
+{
+	/* ORDER MATTERS! */
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_COMMON,
+		.major = 1,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_common_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_GMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &gmc_v7_0_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_IH,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_ih_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_SMC,
+		.major = 7,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &kv_dpm_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_DCE,
+		.major = 8,
+		.minor = 1,
+		.rev = 0,
+		.funcs = &dce_v8_0_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_GFX,
+		.major = 7,
+		.minor = 1,
+		.rev = 0,
+		.funcs = &gfx_v7_0_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_SDMA,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &cik_sdma_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_UVD,
+		.major = 4,
+		.minor = 2,
+		.rev = 0,
+		.funcs = &uvd_v4_2_ip_funcs,
+	},
+	{
+		.type = AMDGPU_IP_BLOCK_TYPE_VCE,
+		.major = 2,
+		.minor = 0,
+		.rev = 0,
+		.funcs = &vce_v2_0_ip_funcs,
+	},
+};
+
+int cik_set_ip_blocks(struct amdgpu_device *adev)
+{
+	switch (adev->asic_type) {
+	case CHIP_BONAIRE:
+		adev->ip_blocks = bonaire_ip_blocks;
+		adev->num_ip_blocks = ARRAY_SIZE(bonaire_ip_blocks);
+		break;
+	case CHIP_HAWAII:
+		adev->ip_blocks = hawaii_ip_blocks;
+		adev->num_ip_blocks = ARRAY_SIZE(hawaii_ip_blocks);
+		break;
+	case CHIP_KAVERI:
+		adev->ip_blocks = kaveri_ip_blocks;
+		adev->num_ip_blocks = ARRAY_SIZE(kaveri_ip_blocks);
+		break;
+	case CHIP_KABINI:
+		adev->ip_blocks = kabini_ip_blocks;
+		adev->num_ip_blocks = ARRAY_SIZE(kabini_ip_blocks);
+		break;
+	case CHIP_MULLINS:
+		adev->ip_blocks = mullins_ip_blocks;
+		adev->num_ip_blocks = ARRAY_SIZE(mullins_ip_blocks);
+		break;
+	default:
+		/* FIXME: not supported yet */
+		return -EINVAL;
+	}
+
+	adev->ip_block_enabled = kcalloc(adev->num_ip_blocks, sizeof(bool), GFP_KERNEL);
+	if (adev->ip_block_enabled == NULL)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static const struct amdgpu_asic_funcs cik_asic_funcs =
+{
+	.read_disabled_bios = &cik_read_disabled_bios,
+	.read_register = &cik_read_register,
+	.reset = &cik_asic_reset,
+	.set_vga_state = &cik_vga_set_state,
+	.get_xclk = &cik_get_xclk,
+	.set_uvd_clocks = &cik_set_uvd_clocks,
+	.set_vce_clocks = &cik_set_vce_clocks,
+	.get_cu_info = &gfx_v7_0_get_cu_info,
+	/* these should be moved to their own ip modules */
+	.get_gpu_clock_counter = &gfx_v7_0_get_gpu_clock_counter,
+	.wait_for_mc_idle = &gmc_v7_0_mc_wait_for_idle,
+};
+
+static int cik_common_early_init(struct amdgpu_device *adev)
+{
+	adev->smc_rreg = &cik_smc_rreg;
+	adev->smc_wreg = &cik_smc_wreg;
+	adev->pcie_rreg = &cik_pcie_rreg;
+	adev->pcie_wreg = &cik_pcie_wreg;
+	adev->uvd_ctx_rreg = &cik_uvd_ctx_rreg;
+	adev->uvd_ctx_wreg = &cik_uvd_ctx_wreg;
+	adev->didt_rreg = &cik_didt_rreg;
+	adev->didt_wreg = &cik_didt_wreg;
+
+	adev->asic_funcs = &cik_asic_funcs;
+
+	adev->has_uvd = true;
+
+	adev->rev_id = cik_get_rev_id(adev);
+	adev->external_rev_id = 0xFF;
+	switch (adev->asic_type) {
+	case CHIP_BONAIRE:
+		adev->cg_flags =
+			AMDGPU_CG_SUPPORT_GFX_MGCG |
+			AMDGPU_CG_SUPPORT_GFX_MGLS |
+			/*AMDGPU_CG_SUPPORT_GFX_CGCG |*/
+			AMDGPU_CG_SUPPORT_GFX_CGLS |
+			AMDGPU_CG_SUPPORT_GFX_CGTS |
+			AMDGPU_CG_SUPPORT_GFX_CGTS_LS |
+			AMDGPU_CG_SUPPORT_GFX_CP_LS |
+			AMDGPU_CG_SUPPORT_MC_LS |
+			AMDGPU_CG_SUPPORT_MC_MGCG |
+			AMDGPU_CG_SUPPORT_SDMA_MGCG |
+			AMDGPU_CG_SUPPORT_SDMA_LS |
+			AMDGPU_CG_SUPPORT_BIF_LS |
+			AMDGPU_CG_SUPPORT_VCE_MGCG |
+			AMDGPU_CG_SUPPORT_UVD_MGCG |
+			AMDGPU_CG_SUPPORT_HDP_LS |
+			AMDGPU_CG_SUPPORT_HDP_MGCG;
+		adev->pg_flags = 0;
+		adev->external_rev_id = adev->rev_id + 0x14;
+		break;
+	case CHIP_HAWAII:
+		adev->cg_flags =
+			AMDGPU_CG_SUPPORT_GFX_MGCG |
+			AMDGPU_CG_SUPPORT_GFX_MGLS |
+			/*AMDGPU_CG_SUPPORT_GFX_CGCG |*/
+			AMDGPU_CG_SUPPORT_GFX_CGLS |
+			AMDGPU_CG_SUPPORT_GFX_CGTS |
+			AMDGPU_CG_SUPPORT_GFX_CP_LS |
+			AMDGPU_CG_SUPPORT_MC_LS |
+			AMDGPU_CG_SUPPORT_MC_MGCG |
+			AMDGPU_CG_SUPPORT_SDMA_MGCG |
+			AMDGPU_CG_SUPPORT_SDMA_LS |
+			AMDGPU_CG_SUPPORT_BIF_LS |
+			AMDGPU_CG_SUPPORT_VCE_MGCG |
+			AMDGPU_CG_SUPPORT_UVD_MGCG |
+			AMDGPU_CG_SUPPORT_HDP_LS |
+			AMDGPU_CG_SUPPORT_HDP_MGCG;
+		adev->pg_flags = 0;
+		adev->external_rev_id = 0x28;
+		break;
+	case CHIP_KAVERI:
+		adev->cg_flags =
+			AMDGPU_CG_SUPPORT_GFX_MGCG |
+			AMDGPU_CG_SUPPORT_GFX_MGLS |
+			/*AMDGPU_CG_SUPPORT_GFX_CGCG |*/
+			AMDGPU_CG_SUPPORT_GFX_CGLS |
+			AMDGPU_CG_SUPPORT_GFX_CGTS |
+			AMDGPU_CG_SUPPORT_GFX_CGTS_LS |
+			AMDGPU_CG_SUPPORT_GFX_CP_LS |
+			AMDGPU_CG_SUPPORT_SDMA_MGCG |
+			AMDGPU_CG_SUPPORT_SDMA_LS |
+			AMDGPU_CG_SUPPORT_BIF_LS |
+			AMDGPU_CG_SUPPORT_VCE_MGCG |
+			AMDGPU_CG_SUPPORT_UVD_MGCG |
+			AMDGPU_CG_SUPPORT_HDP_LS |
+			AMDGPU_CG_SUPPORT_HDP_MGCG;
+		adev->pg_flags =
+			/*AMDGPU_PG_SUPPORT_GFX_PG |
+			  AMDGPU_PG_SUPPORT_GFX_SMG |
+			  AMDGPU_PG_SUPPORT_GFX_DMG |*/
+			AMDGPU_PG_SUPPORT_UVD |
+			/*AMDGPU_PG_SUPPORT_VCE |
+			  AMDGPU_PG_SUPPORT_CP |
+			  AMDGPU_PG_SUPPORT_GDS |
+			  AMDGPU_PG_SUPPORT_RLC_SMU_HS |
+			  AMDGPU_PG_SUPPORT_ACP |
+			  AMDGPU_PG_SUPPORT_SAMU |*/
+			0;
+		if (adev->pdev->device == 0x1312 ||
+			adev->pdev->device == 0x1316 ||
+			adev->pdev->device == 0x1317)
+			adev->external_rev_id = 0x41;
+		else
+			adev->external_rev_id = 0x1;
+		break;
+	case CHIP_KABINI:
+	case CHIP_MULLINS:
+		adev->cg_flags =
+			AMDGPU_CG_SUPPORT_GFX_MGCG |
+			AMDGPU_CG_SUPPORT_GFX_MGLS |
+			/*AMDGPU_CG_SUPPORT_GFX_CGCG |*/
+			AMDGPU_CG_SUPPORT_GFX_CGLS |
+			AMDGPU_CG_SUPPORT_GFX_CGTS |
+			AMDGPU_CG_SUPPORT_GFX_CGTS_LS |
+			AMDGPU_CG_SUPPORT_GFX_CP_LS |
+			AMDGPU_CG_SUPPORT_SDMA_MGCG |
+			AMDGPU_CG_SUPPORT_SDMA_LS |
+			AMDGPU_CG_SUPPORT_BIF_LS |
+			AMDGPU_CG_SUPPORT_VCE_MGCG |
+			AMDGPU_CG_SUPPORT_UVD_MGCG |
+			AMDGPU_CG_SUPPORT_HDP_LS |
+			AMDGPU_CG_SUPPORT_HDP_MGCG;
+		adev->pg_flags =
+			/*AMDGPU_PG_SUPPORT_GFX_PG |
+			  AMDGPU_PG_SUPPORT_GFX_SMG | */
+			AMDGPU_PG_SUPPORT_UVD |
+			/*AMDGPU_PG_SUPPORT_VCE |
+			  AMDGPU_PG_SUPPORT_CP |
+			  AMDGPU_PG_SUPPORT_GDS |
+			  AMDGPU_PG_SUPPORT_RLC_SMU_HS |
+			  AMDGPU_PG_SUPPORT_SAMU |*/
+			0;
+		if (adev->asic_type == CHIP_KABINI) {
+			if (adev->rev_id == 0)
+				adev->external_rev_id = 0x81;
+			else if (adev->rev_id == 1)
+				adev->external_rev_id = 0x82;
+			else if (adev->rev_id == 2)
+				adev->external_rev_id = 0x85;
+		} else
+			adev->external_rev_id = adev->rev_id + 0xa1;
+		break;
+	default:
+		/* FIXME: not supported yet */
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int cik_common_sw_init(struct amdgpu_device *adev)
+{
+	return 0;
+}
+
+static int cik_common_sw_fini(struct amdgpu_device *adev)
+{
+	return 0;
+}
+
+static int cik_common_hw_init(struct amdgpu_device *adev)
+{
+	/* move the golden regs per IP block */
+	cik_init_golden_registers(adev);
+	/* enable pcie gen2/3 link */
+	cik_pcie_gen3_enable(adev);
+	/* enable aspm */
+	cik_program_aspm(adev);
+
+	return 0;
+}
+
+static int cik_common_hw_fini(struct amdgpu_device *adev)
+{
+	return 0;
+}
+
+static int cik_common_suspend(struct amdgpu_device *adev)
+{
+	return cik_common_hw_fini(adev);
+}
+
+static int cik_common_resume(struct amdgpu_device *adev)
+{
+	return cik_common_hw_init(adev);
+}
+
+static bool cik_common_is_idle(struct amdgpu_device *adev)
+{
+	return true;
+}
+
+static int cik_common_wait_for_idle(struct amdgpu_device *adev)
+{
+	return 0;
+}
+
+static void cik_common_print_status(struct amdgpu_device *adev)
+{
+
+}
+
+static int cik_common_soft_reset(struct amdgpu_device *adev)
+{
+	/* XXX hard reset?? */
+	return 0;
+}
+
+static int cik_common_set_clockgating_state(struct amdgpu_device *adev,
+					    enum amdgpu_clockgating_state state)
+{
+	return 0;
+}
+
+static int cik_common_set_powergating_state(struct amdgpu_device *adev,
+					    enum amdgpu_powergating_state state)
+{
+	return 0;
+}
+
+const struct amdgpu_ip_funcs cik_common_ip_funcs = {
+	.early_init = cik_common_early_init,
+	.late_init = NULL,
+	.sw_init = cik_common_sw_init,
+	.sw_fini = cik_common_sw_fini,
+	.hw_init = cik_common_hw_init,
+	.hw_fini = cik_common_hw_fini,
+	.suspend = cik_common_suspend,
+	.resume = cik_common_resume,
+	.is_idle = cik_common_is_idle,
+	.wait_for_idle = cik_common_wait_for_idle,
+	.soft_reset = cik_common_soft_reset,
+	.print_status = cik_common_print_status,
+	.set_clockgating_state = cik_common_set_clockgating_state,
+	.set_powergating_state = cik_common_set_powergating_state,
+};
