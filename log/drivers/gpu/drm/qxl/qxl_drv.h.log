commit e304f8a0513b830be37b3f5059c3d8fcaacda4b7
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Apr 15 09:40:02 2020 +0200

    drm/qxl: Don't use drm_device->dev_private
    
    Upcasting using a container_of macro is more typesafe, faster and
    easier for the compiler to optimize.
    
    Acked-by: Gerd Hoffmann <kraxel@redhat.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Gerd Hoffmann <kraxel@redhat.com>
    Cc: virtualization@lists.linux-foundation.org
    Cc: spice-devel@lists.freedesktop.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20200415074034.175360-28-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 86ac191d9205..31e35f787df2 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -192,8 +192,6 @@ struct qxl_debugfs {
 
 int qxl_debugfs_fence_init(struct qxl_device *rdev);
 
-struct qxl_device;
-
 struct qxl_device {
 	struct drm_device ddev;
 
@@ -273,6 +271,8 @@ struct qxl_device {
 	int monitors_config_height;
 };
 
+#define to_qxl(dev) container_of(dev, struct qxl_device, ddev)
+
 extern const struct drm_ioctl_desc qxl_ioctls[];
 extern int qxl_max_ioctl;
 

commit a9b0b24a6fff2d269eb966d7e4eca498bf9f0bba
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Apr 15 09:40:01 2020 +0200

    drm/qxl: Use devm_drm_dev_alloc
    
    Also need to remove the drm_dev_put from the remove hook.
    
    Acked-by: Gerd Hoffmann <kraxel@redhat.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Gerd Hoffmann <kraxel@redhat.com>
    Cc: virtualization@lists.linux-foundation.org
    Cc: spice-devel@lists.freedesktop.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20200415074034.175360-27-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 435126facc9b..86ac191d9205 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -276,8 +276,7 @@ struct qxl_device {
 extern const struct drm_ioctl_desc qxl_ioctls[];
 extern int qxl_max_ioctl;
 
-int qxl_device_init(struct qxl_device *qdev, struct drm_driver *drv,
-		    struct pci_dev *pdev);
+int qxl_device_init(struct qxl_device *qdev, struct pci_dev *pdev);
 void qxl_device_fini(struct qxl_device *qdev);
 
 int qxl_modeset_init(struct qxl_device *qdev);

commit 7ce84471e3c72e23020b046714358b45a7ffe9ab
Author: Wambui Karuga <wambui.karugax@gmail.com>
Date:   Tue Mar 10 16:31:21 2020 +0300

    drm: convert .debugfs_init() hook to return void.
    
    As a result of commit 987d65d01356 (drm: debugfs: make
    drm_debugfs_create_files() never fail) and changes to various debugfs
    functions in drm/core and across various drivers, there is no need for
    the drm_driver.debugfs_init() hook to have a return value. Therefore,
    declare it as void.
    
    This also includes refactoring all users of the .debugfs_init() hook to
    return void across the subsystem.
    
    v2: include changes to the hook and drivers that use it in one patch to
    prevent driver breakage and enable individual successful compilation of
    this change.
    
    References: https://lists.freedesktop.org/archives/dri-devel/2020-February/257183.html
    Signed-off-by: Wambui Karuga <wambui.karugax@gmail.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200310133121.27913-18-wambui.karugax@gmail.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 27e45a2d6b52..435126facc9b 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -190,9 +190,6 @@ struct qxl_debugfs {
 	unsigned int num_files;
 };
 
-int qxl_debugfs_add_files(struct qxl_device *rdev,
-			     struct drm_info_list *files,
-			     unsigned int nfiles);
 int qxl_debugfs_fence_init(struct qxl_device *rdev);
 
 struct qxl_device;
@@ -442,8 +439,8 @@ int qxl_garbage_collect(struct qxl_device *qdev);
 
 /* debugfs */
 
-int qxl_debugfs_init(struct drm_minor *minor);
-int qxl_ttm_debugfs_init(struct qxl_device *qdev);
+void qxl_debugfs_init(struct drm_minor *minor);
+void qxl_ttm_debugfs_init(struct qxl_device *qdev);
 
 /* qxl_prime.c */
 int qxl_gem_prime_pin(struct drm_gem_object *obj);
@@ -461,9 +458,9 @@ int qxl_gem_prime_mmap(struct drm_gem_object *obj,
 int qxl_irq_init(struct qxl_device *qdev);
 irqreturn_t qxl_irq_handler(int irq, void *arg);
 
-int qxl_debugfs_add_files(struct qxl_device *qdev,
-			  struct drm_info_list *files,
-			  unsigned int nfiles);
+void qxl_debugfs_add_files(struct qxl_device *qdev,
+			   struct drm_info_list *files,
+			   unsigned int nfiles);
 
 int qxl_surface_id_alloc(struct qxl_device *qdev,
 			 struct qxl_bo *surf);

commit 51ea742c87f3c6537a0df0f79f5da7bce4d8a40a
Author: Christian König <christian.koenig@amd.com>
Date:   Fri Sep 27 15:06:22 2019 +0200

    drm/qxl: stop using TTM to call driver internal functions
    
    The ttm_mem_io_* functions were intended to be internal to TTM and
    shouldn't have been used in a driver. They were exported in commit
    afe6804c045fbd69a1b75c681107b5d6df9190de just for QXL.
    
    Instead call the qxl_ttm_io_mem_reserve() function directly and
    completely drop the free call since that is a dummy on QXL.
    
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Gerd Hoffmann <kraxel@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/333289/

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index a5cb3864d686..27e45a2d6b52 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -355,6 +355,8 @@ int qxl_mode_dumb_mmap(struct drm_file *filp,
 /* qxl ttm */
 int qxl_ttm_init(struct qxl_device *qdev);
 void qxl_ttm_fini(struct qxl_device *qdev);
+int qxl_ttm_io_mem_reserve(struct ttm_bo_device *bdev,
+			   struct ttm_mem_reg *mem);
 
 /* qxl image */
 

commit 60f57220cd3c2f35866904a7eea6b03c8ee5a743
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Thu Oct 17 15:26:35 2019 +0200

    drm/qxl: switch qxl to &drm_gem_object_funcs.mmap
    
    Wire up the new drm_gem_ttm_mmap() helper function.
    Use generic drm_gem_mmap() and remove qxl_mmap().
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20191017132638.9693-3-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index d4051409ce64..a5cb3864d686 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -355,7 +355,6 @@ int qxl_mode_dumb_mmap(struct drm_file *filp,
 /* qxl ttm */
 int qxl_ttm_init(struct qxl_device *qdev);
 void qxl_ttm_fini(struct qxl_device *qdev);
-int qxl_mmap(struct file *filp, struct vm_area_struct *vma);
 
 /* qxl image */
 

commit 78d54f1f6a3353f54dee6f2be34fcbbcab0ac380
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Wed Sep 4 07:47:39 2019 +0200

    drm/qxl: use drm_gem_ttm_print_info
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Acked-by: Thomas Zimmermann <tzimmermann@suse.de>
    Link: http://patchwork.freedesktop.org/patch/msgid/20190904054740.20817-7-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 9e034c5fa87d..d4051409ce64 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -38,6 +38,7 @@
 #include <drm/drm_crtc.h>
 #include <drm/drm_encoder.h>
 #include <drm/drm_fb_helper.h>
+#include <drm/drm_gem_ttm_helper.h>
 #include <drm/drm_ioctl.h>
 #include <drm/drm_gem.h>
 #include <drm/qxl_drm.h>

commit e0828d54c81cb111ead1a7c47a5ef1b319610a1d
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Mon Aug 5 16:01:05 2019 +0200

    drm/qxl: use embedded gem object
    
    Drop drm_gem_object from qxl_bo, use the
    ttm_buffer_object.base instead.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20190805140119.7337-4-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index ae82e5fab09c..9e034c5fa87d 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -71,12 +71,13 @@ extern int qxl_max_ioctls;
 	QXL_INTERRUPT_CLIENT_MONITORS_CONFIG)
 
 struct qxl_bo {
+	struct ttm_buffer_object	tbo;
+
 	/* Protected by gem.mutex */
 	struct list_head		list;
 	/* Protected by tbo.reserved */
 	struct ttm_place		placements[3];
 	struct ttm_placement		placement;
-	struct ttm_buffer_object	tbo;
 	struct ttm_bo_kmap_obj		kmap;
 	unsigned int pin_count;
 	void				*kptr;
@@ -84,7 +85,6 @@ struct qxl_bo {
 	int                             type;
 
 	/* Constant after initialization */
-	struct drm_gem_object		gem_base;
 	unsigned int is_primary:1; /* is this now a primary surface */
 	unsigned int is_dumb:1;
 	struct qxl_bo *shadow;
@@ -93,7 +93,7 @@ struct qxl_bo {
 	uint32_t surface_id;
 	struct qxl_release *surf_create;
 };
-#define gem_to_qxl_bo(gobj) container_of((gobj), struct qxl_bo, gem_base)
+#define gem_to_qxl_bo(gobj) container_of((gobj), struct qxl_bo, tbo.base)
 #define to_qxl_bo(tobj) container_of((tobj), struct qxl_bo, tbo)
 
 struct qxl_gem {

commit c0f4b75c065ba2c6b9610f4526da9bf432049b9e
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Jun 30 08:18:58 2019 +0200

    drm/qxl: drop use of drmP.h
    
    Drop use of the deprecated drmP.h header file.
    While touching the files divided includes in blocks,
    and when needed sort the blocks.
    Fix fallout.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Gerd Hoffmann <kraxel@redhat.com>
    Acked-by: Emil Velikov <emil.velikov@collabora.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: virtualization@lists.linux-foundation.org
    Cc: spice-devel@lists.freedesktop.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190630061922.7254-10-sam@ravnborg.org

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 2896bb6fdbf4..ae82e5fab09c 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -31,22 +31,21 @@
  */
 
 #include <linux/dma-fence.h>
-#include <linux/workqueue.h>
 #include <linux/firmware.h>
 #include <linux/platform_device.h>
+#include <linux/workqueue.h>
 
 #include <drm/drm_crtc.h>
 #include <drm/drm_encoder.h>
 #include <drm/drm_fb_helper.h>
+#include <drm/drm_ioctl.h>
 #include <drm/drm_gem.h>
-#include <drm/drmP.h>
+#include <drm/qxl_drm.h>
 #include <drm/ttm/ttm_bo_api.h>
 #include <drm/ttm/ttm_bo_driver.h>
-/* just for ttm_validate_buffer */
 #include <drm/ttm/ttm_execbuf_util.h>
 #include <drm/ttm/ttm_module.h>
 #include <drm/ttm/ttm_placement.h>
-#include <drm/qxl_drm.h>
 
 #include "qxl_dev.h"
 

commit aa8e2435b3d4878a0db8917805e86f61001fe174
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Thu Feb 7 09:59:28 2019 +0100

    drm/ttm: Define a single DRM_FILE_PAGE_OFFSET constant
    
    Most TTM drivers define the constant DRM_FILE_PAGE_OFFSET of the same
    value. The only exception is vboxvideo, which is being converted to the
    new offset by this patch. Unifying the constants in a single place
    simplifies the driver code.
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 4a0331b3ff7d..2896bb6fdbf4 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -65,9 +65,6 @@
 extern int qxl_num_crtc;
 extern int qxl_max_ioctls;
 
-#define DRM_FILE_OFFSET 0x100000000ULL
-#define DRM_FILE_PAGE_OFFSET (DRM_FILE_OFFSET >> PAGE_SHIFT)
-
 #define QXL_INTERRUPT_MASK (\
 	QXL_INTERRUPT_DISPLAY |\
 	QXL_INTERRUPT_CURSOR |\

commit 13aff184ed9f651f80e7dc8be1e1b457a5d38134
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Fri Jan 18 13:20:15 2019 +0100

    drm/qxl: remove dead qxl fbdev emulation code
    
    Lovely diffstat, thanks to the new generic fbdev emulation.
    
     drm/qxl/Makefile   |    2
     drm/qxl/qxl_draw.c |  232 ----------------------------------------
     drm/qxl/qxl_drv.h  |   21 ---
     drm/qxl/qxl_fb.c   |  300 -----------------------------------------------------
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Acked-by: Noralf Trønnes <noralf@tronnes.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20190118122020.27596-19-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 8c3af1cdbe9b..4a0331b3ff7d 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -220,8 +220,6 @@ struct qxl_device {
 	struct qxl_mman		mman;
 	struct qxl_gem		gem;
 
-	struct drm_fb_helper	fb_helper;
-
 	void *ram_physical;
 
 	struct qxl_ring *release_ring;
@@ -322,12 +320,6 @@ qxl_bo_physical_address(struct qxl_device *qdev, struct qxl_bo *bo,
 	return slot->high_bits | (bo->tbo.offset - slot->gpu_offset + offset);
 }
 
-/* qxl_fb.c */
-#define QXLFB_CONN_LIMIT 1
-
-int qxl_fbdev_init(struct qxl_device *qdev);
-void qxl_fbdev_fini(struct qxl_device *qdev);
-
 /* qxl_display.c */
 void qxl_display_read_client_monitors_config(struct qxl_device *qdev);
 int qxl_create_monitors_object(struct qxl_device *qdev);
@@ -432,9 +424,6 @@ int qxl_alloc_bo_reserved(struct qxl_device *qdev,
 			  struct qxl_bo **_bo);
 /* qxl drawing commands */
 
-void qxl_draw_opaque_fb(const struct qxl_fb_image *qxl_fb_image,
-			int stride /* filled in if 0 */);
-
 void qxl_draw_dirty_fb(struct qxl_device *qdev,
 		       struct drm_framebuffer *fb,
 		       struct qxl_bo *bo,
@@ -443,13 +432,6 @@ void qxl_draw_dirty_fb(struct qxl_device *qdev,
 		       unsigned int num_clips, int inc,
 		       uint32_t dumb_shadow_offset);
 
-void qxl_draw_fill(struct qxl_draw_fill *qxl_draw_fill_rec);
-
-void qxl_draw_copyarea(struct qxl_device *qdev,
-		       u32 width, u32 height,
-		       u32 sx, u32 sy,
-		       u32 dx, u32 dy);
-
 void qxl_release_free(struct qxl_device *qdev,
 		      struct qxl_release *release);
 
@@ -481,9 +463,6 @@ int qxl_gem_prime_mmap(struct drm_gem_object *obj,
 int qxl_irq_init(struct qxl_device *qdev);
 irqreturn_t qxl_irq_handler(int irq, void *arg);
 
-/* qxl_fb.c */
-bool qxl_fbdev_qobj_is_fb(struct qxl_device *qdev, struct qxl_bo *qobj);
-
 int qxl_debugfs_add_files(struct qxl_device *qdev,
 			  struct drm_info_list *files,
 			  unsigned int nfiles);

commit 9b369116fd0ecd3e4fb3d82f8d61859d9607f9b3
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Fri Jan 18 13:20:13 2019 +0100

    drm/qxl: implement prime kmap/kunmap
    
    Generic fbdev emulation needs this.  Also: We must keep track of the
    number of mappings now, so we don't unmap early in case two users want a
    kmap of the same bo.  Add a sanity check to destroy callback to make
    sure kmap/kunmap is balanced.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Acked-by: Noralf Trønnes <noralf@tronnes.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20190118122020.27596-17-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 43c6df9cf98e..8c3af1cdbe9b 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -84,6 +84,7 @@ struct qxl_bo {
 	struct ttm_bo_kmap_obj		kmap;
 	unsigned int pin_count;
 	void				*kptr;
+	unsigned int                    map_count;
 	int                             type;
 
 	/* Constant after initialization */

commit 90adda2ce898c7a76d1a55d4650ade8cc957e54f
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Fri Jan 18 13:20:11 2019 +0100

    drm/qxl: cover all crtcs in shadow bo.
    
    The qxl device supports only a single active framebuffer ("primary
    surface" in spice terminology).  In multihead configurations are handled
    by defining rectangles within the primary surface for each head/crtc.
    
    Userspace which uses the qxl ioctl interface (xorg qxl driver) is aware
    of this limitation and will setup framebuffers and crtcs accordingly.
    
    Userspace which uses dumb framebuffers (xorg modesetting driver,
    wayland) is not aware of this limitation and tries to use two
    framebuffers (one for each crtc) instead.
    
    The qxl kms driver already has the dumb bo separated from the primary
    surface, by using a (shared) shadow bo as primary surface.  This is
    needed to support pageflips without having to re-create the primary
    surface.  The qxl driver will blit from the dumb bo to the shadow bo
    instead.
    
    So we can extend the shadow logic:  Maintain a global shadow bo (aka
    primary surface), make it big enough that dumb bo's for all crtcs fit in
    side-by-side.  Adjust the pageflip blits to place the heads next to each
    other in the shadow.
    
    With this patch in place multihead qxl works with wayland.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Acked-by: Noralf Trønnes <noralf@tronnes.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20190118122020.27596-15-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 150b1a4f667a..43c6df9cf98e 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -230,6 +230,8 @@ struct qxl_device {
 	struct qxl_ram_header *ram_header;
 
 	struct qxl_bo *primary_bo;
+	struct qxl_bo *dumb_shadow_bo;
+	struct qxl_head *dumb_heads;
 
 	struct qxl_memslot main_slot;
 	struct qxl_memslot surfaces_slot;
@@ -437,7 +439,8 @@ void qxl_draw_dirty_fb(struct qxl_device *qdev,
 		       struct qxl_bo *bo,
 		       unsigned int flags, unsigned int color,
 		       struct drm_clip_rect *clips,
-		       unsigned int num_clips, int inc);
+		       unsigned int num_clips, int inc,
+		       uint32_t dumb_shadow_offset);
 
 void qxl_draw_fill(struct qxl_draw_fill *qxl_draw_fill_rec);
 

commit 166205444b90f49382e26cc4ed0f9abc6b6a81f8
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Fri Jan 18 13:20:09 2019 +0100

    drm/qxl: track primary bo
    
    Track which bo is used as primary surface.  With that in place we don't
    need the primary_created flag any more, we can just check the primary bo
    pointer instead.
    
    Also verify we don't already have a primary surface in
    qxl_io_create_primary().
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Acked-by: Noralf Trønnes <noralf@tronnes.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20190118122020.27596-13-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index cb767aaef630..150b1a4f667a 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -229,7 +229,7 @@ struct qxl_device {
 
 	struct qxl_ram_header *ram_header;
 
-	unsigned int primary_created:1;
+	struct qxl_bo *primary_bo;
 
 	struct qxl_memslot main_slot;
 	struct qxl_memslot surfaces_slot;

commit fb7ebc0119ed0b24e261b06bacca6a4eb766443c
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Fri Jan 18 13:20:08 2019 +0100

    drm/qxl: drop unused offset parameter from qxl_io_create_primary()
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Acked-by: Noralf Trønnes <noralf@tronnes.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20190118122020.27596-12-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 27e0a3fc08e6..cb767aaef630 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -385,7 +385,6 @@ void qxl_update_screen(struct qxl_device *qxl);
 /* qxl io operations (qxl_cmd.c) */
 
 void qxl_io_create_primary(struct qxl_device *qdev,
-			   unsigned int offset,
 			   struct qxl_bo *bo);
 void qxl_io_destroy_primary(struct qxl_device *qdev);
 void qxl_io_memslot_add(struct qxl_device *qdev, uint8_t id);

commit 96e8f153964aa0cc0ebb21576974a723f2b03cd5
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Fri Jan 18 13:20:03 2019 +0100

    drm/qxl: use separate offset spaces for the two slots / ttm memory types.
    
    Without that ttm offsets are not unique, they can refer to objects
    in both VRAM and PRIV memory (aka main and surfaces slot).
    
    One of those "why things didn't blow up without this" moments.
    Probably offset conflicts are rare enough by pure luck.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Acked-by: Noralf Trønnes <noralf@tronnes.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20190118122020.27596-7-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 3ebe66abf259..27e0a3fc08e6 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -136,6 +136,7 @@ struct qxl_memslot {
 	uint64_t	start_phys_addr;
 	uint64_t	size;
 	uint64_t	high_bits;
+	uint64_t        gpu_offset;
 };
 
 enum {
@@ -312,8 +313,10 @@ qxl_bo_physical_address(struct qxl_device *qdev, struct qxl_bo *bo,
 		(bo->tbo.mem.mem_type == TTM_PL_VRAM)
 		? &qdev->main_slot : &qdev->surfaces_slot;
 
+	WARN_ON_ONCE((bo->tbo.offset & slot->gpu_offset) != slot->gpu_offset);
+
 	/* TODO - need to hold one of the locks to read tbo.offset */
-	return slot->high_bits | (bo->tbo.offset + offset);
+	return slot->high_bits | (bo->tbo.offset - slot->gpu_offset + offset);
 }
 
 /* qxl_fb.c */

commit 3ebe3ddf37c84acfb1dfbe471482cb4bbdb0f7c0
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Fri Jan 18 13:20:02 2019 +0100

    drm/qxl: drop unused fields from struct qxl_device
    
    slot_id_bits and slot_gen_bits can be read directly from qxlrom instead.
    va_slot_mask is never used anywhere.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Acked-by: Noralf Trønnes <noralf@tronnes.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20190118122020.27596-6-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index d015d4fff158..3ebe66abf259 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -232,9 +232,6 @@ struct qxl_device {
 
 	struct qxl_memslot main_slot;
 	struct qxl_memslot surfaces_slot;
-	uint8_t		slot_id_bits;
-	uint8_t		slot_gen_bits;
-	uint64_t	va_slot_mask;
 
 	spinlock_t	release_lock;
 	struct idr	release_idr;

commit a8dc42142a0ebbb5fade13f3e48d89399499d297
Author: Frediano Ziglio <fziglio@redhat.com>
Date:   Fri Jan 18 13:20:01 2019 +0100

    drm/qxl: change the way slot is detected
    
    Instead of relaying on surface type use the actual placement.
    This allow to have different placement for a single type of
    surface.
    
    Signed-off-by: Frediano Ziglio <fziglio@redhat.com>
    Acked-by: Noralf Trønnes <noralf@tronnes.org>
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20190118122020.27596-5-kraxel@redhat.com
    
    [ kraxel: rebased, adapted to upstream changes ]
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index f9dddfe7d988..d015d4fff158 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -311,7 +311,8 @@ static inline uint64_t
 qxl_bo_physical_address(struct qxl_device *qdev, struct qxl_bo *bo,
 			unsigned long offset)
 {
-	struct qxl_memslot *slot = bo->type == QXL_GEM_DOMAIN_VRAM
+	struct qxl_memslot *slot =
+		(bo->tbo.mem.mem_type == TTM_PL_VRAM)
 		? &qdev->main_slot : &qdev->surfaces_slot;
 
 	/* TODO - need to hold one of the locks to read tbo.offset */

commit 2ec6bd67b76ea0afc97eaa22f369738f1a7ad7f3
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Fri Jan 18 13:20:00 2019 +0100

    drm/qxl: simplify slot management
    
    Drop pointless indirection, remove the mem_slots array and index
    variables, drop dynamic allocation.  Store memslots in qxl_device
    instead.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Acked-by: Noralf Trønnes <noralf@tronnes.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20190118122020.27596-4-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 7eabf4a9ed14..f9dddfe7d988 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -130,9 +130,11 @@ struct qxl_mman {
 };
 
 struct qxl_memslot {
+	int             index;
+	const char      *name;
 	uint8_t		generation;
 	uint64_t	start_phys_addr;
-	uint64_t	end_phys_addr;
+	uint64_t	size;
 	uint64_t	high_bits;
 };
 
@@ -228,11 +230,8 @@ struct qxl_device {
 
 	unsigned int primary_created:1;
 
-	struct qxl_memslot	*mem_slots;
-	uint8_t		n_mem_slots;
-
-	uint8_t		main_mem_slot;
-	uint8_t		surfaces_mem_slot;
+	struct qxl_memslot main_slot;
+	struct qxl_memslot surfaces_slot;
 	uint8_t		slot_id_bits;
 	uint8_t		slot_gen_bits;
 	uint64_t	va_slot_mask;
@@ -312,8 +311,8 @@ static inline uint64_t
 qxl_bo_physical_address(struct qxl_device *qdev, struct qxl_bo *bo,
 			unsigned long offset)
 {
-	int slot_id = bo->type == QXL_GEM_DOMAIN_VRAM ? qdev->main_mem_slot : qdev->surfaces_mem_slot;
-	struct qxl_memslot *slot = &(qdev->mem_slots[slot_id]);
+	struct qxl_memslot *slot = bo->type == QXL_GEM_DOMAIN_VRAM
+		? &qdev->main_slot : &qdev->surfaces_slot;
 
 	/* TODO - need to hold one of the locks to read tbo.offset */
 	return slot->high_bits | (bo->tbo.offset + offset);

commit d934ef6b98bcdc77242b66f4fa0ea0c3330ae3b6
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Fri Jan 18 13:19:59 2019 +0100

    drm/qxl: drop unused qxl_fb_virtual_address
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Acked-by: Noralf Trønnes <noralf@tronnes.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20190118122020.27596-3-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 38c5a8b1dfc1..7eabf4a9ed14 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -308,13 +308,6 @@ void qxl_ring_free(struct qxl_ring *ring);
 void qxl_ring_init_hdr(struct qxl_ring *ring);
 int qxl_check_idle(struct qxl_ring *ring);
 
-static inline void *
-qxl_fb_virtual_address(struct qxl_device *qdev, unsigned long physical)
-{
-	DRM_DEBUG_DRIVER("not implemented (%lu)\n", physical);
-	return 0;
-}
-
 static inline uint64_t
 qxl_bo_physical_address(struct qxl_device *qdev, struct qxl_bo *bo,
 			unsigned long offset)

commit edd38a1e598dd970f61f9c8d8649e65089a4fdbc
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Fri Jan 18 13:19:58 2019 +0100

    drm/qxl: drop ttm_mem_reg arg from qxl_hw_surface_alloc()
    
    Not used, is always NULL.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Acked-by: Noralf Trønnes <noralf@tronnes.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20190118122020.27596-2-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 13a0254b59a1..38c5a8b1dfc1 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -497,8 +497,7 @@ int qxl_surface_id_alloc(struct qxl_device *qdev,
 void qxl_surface_id_dealloc(struct qxl_device *qdev,
 			    uint32_t surface_id);
 int qxl_hw_surface_alloc(struct qxl_device *qdev,
-			 struct qxl_bo *surf,
-			 struct ttm_mem_reg *mem);
+			 struct qxl_bo *surf);
 int qxl_hw_surface_dealloc(struct qxl_device *qdev,
 			   struct qxl_bo *surf);
 

commit 9235dd441af43599b9cdcce599a3da4083fcad3c
Merge: d7563c55ef9f 36b486bc6821
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Nov 19 11:07:52 2018 +1000

    Merge branch 'drm-next-4.21' of git://people.freedesktop.org/~agd5f/linux into drm-next
    
    New features for 4.21:
    amdgpu:
    - Support for SDMA paging queue on vega
    - Put compute EOP buffers into vram for better performance
    - Share more code with amdkfd
    - Support for scanout with DCC on gfx9
    - Initial kerneldoc for DC
    - Updated SMU firmware support for gfx8 chips
    - Rework CSA handling for eventual support for preemption
    - XGMI PSP support
    - Clean up RLC handling
    - Enable GPU reset by default on VI, SOC15 dGPUs
    - Ring and IB test cleanups
    
    amdkfd:
    - Share more code with amdgpu
    
    ttm:
    - Move global init out of the drivers
    
    scheduler:
    - Track if schedulers are ready for work
    - Timeout/fault handling changes to facilitate GPU recovery
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    From: Alex Deucher <alexdeucher@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181114165113.3751-1-alexander.deucher@amd.com

commit a64f784bb14a56bfdfad2dc397dd67e4564e3a29
Author: Christian König <christian.koenig@amd.com>
Date:   Fri Oct 19 16:55:26 2018 +0200

    drm/ttm: initialize globals during device init (v2)
    
    Make sure that the global BO state is always correctly initialized.
    
    This allows removing all the device code to initialize it.
    
    v2: fix up vbox (Alex)
    
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Junwei Zhang <Jerry.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 52912e54e990..2310d6e9ff1f 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -127,8 +127,6 @@ struct qxl_output {
 #define drm_encoder_to_qxl_output(x) container_of(x, struct qxl_output, enc)
 
 struct qxl_mman {
-	struct ttm_bo_global_ref        bo_global_ref;
-	bool				mem_global_referenced;
 	struct ttm_bo_device		bdev;
 };
 

commit 27eb1fa9130a98edd2b321d4dbce5c8b244ee7af
Author: Christian König <christian.koenig@amd.com>
Date:   Fri Oct 19 13:49:05 2018 +0200

    drm/ttm: use a static ttm_mem_global instance
    
    As the name says we only need one global instance of ttm_mem_global.
    
    Drop all the driver initialization and just use a single exported
    instance which is initialized during BO global initialization.
    
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Junwei Zhang <Jerry.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 8ff70a7281a7..52912e54e990 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -128,7 +128,6 @@ struct qxl_output {
 
 struct qxl_mman {
 	struct ttm_bo_global_ref        bo_global_ref;
-	struct drm_global_reference	mem_global_ref;
 	bool				mem_global_referenced;
 	struct ttm_bo_device		bdev;
 };

commit 94feeaafbefd01b1be00ef8aa33e2a6224500f06
Author: Shayenne da Luz Moura <shayenneluzmoura@gmail.com>
Date:   Fri Oct 26 16:24:58 2018 -0300

    drm/qxl: Use 'unsigned int' instead of 'bool'
    
    Use 'unsigned int' with bitfield instead of 'bool' to avoid alignment
    issues and remove checkpatch.pl check:
    
    CHECK: Avoid using bool structure members because of possible alignment
    issues
    
    Signed-off-by: Shayenne da Luz Moura <shayenneluzmoura@gmail.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/fcd9d7ea7eec1ac6a3ad9ad16e0fc9ef13c089fd.1540579956.git.shayenneluzmoura@gmail.com
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index d78bcb95df3e..14d3fa855708 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -88,10 +88,10 @@ struct qxl_bo {
 
 	/* Constant after initialization */
 	struct drm_gem_object		gem_base;
-	bool is_primary; /* is this now a primary surface */
-	bool is_dumb;
+	unsigned int is_primary:1; /* is this now a primary surface */
+	unsigned int is_dumb:1;
 	struct qxl_bo *shadow;
-	bool hw_surf_alloc;
+	unsigned int hw_surf_alloc:1;
 	struct qxl_surface surf;
 	uint32_t surface_id;
 	struct qxl_release *surf_create;
@@ -128,7 +128,7 @@ struct qxl_output {
 struct qxl_mman {
 	struct ttm_bo_global_ref        bo_global_ref;
 	struct drm_global_reference	mem_global_ref;
-	bool				mem_global_referenced;
+	unsigned int mem_global_referenced:1;
 	struct ttm_bo_device		bdev;
 };
 
@@ -229,7 +229,7 @@ struct qxl_device {
 
 	struct qxl_ram_header *ram_header;
 
-	bool primary_created;
+	unsigned int primary_created:1;
 
 	struct qxl_memslot	*mem_slots;
 	uint8_t		n_mem_slots;

commit 1b000494978d2f3603e9eed4ba90c222587122ad
Author: Shayenne da Luz Moura <shayenneluzmoura@gmail.com>
Date:   Fri Oct 26 16:23:49 2018 -0300

    drm/qxl: Use 'unsigned int' instead of 'usigned'
    
    Use 'usigned int' instead of 'usigned' to remove the checkpath.pl warning:
    
    WARNING: Prefer 'unsigned int' to bare use of 'unsigned'
    
    Signed-off-by: Shayenne da Luz Moura <shayenneluzmoura@gmail.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/52604806eb18bc25e7e429f5b229fe8c1d271b5c.1540579956.git.shayenneluzmoura@gmail.com
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 4b90f9bd7280..d78bcb95df3e 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -82,7 +82,7 @@ struct qxl_bo {
 	struct ttm_placement		placement;
 	struct ttm_buffer_object	tbo;
 	struct ttm_bo_kmap_obj		kmap;
-	unsigned			pin_count;
+	unsigned int pin_count;
 	void				*kptr;
 	int                             type;
 
@@ -189,12 +189,12 @@ struct qxl_draw_fill {
  */
 struct qxl_debugfs {
 	struct drm_info_list	*files;
-	unsigned		num_files;
+	unsigned int num_files;
 };
 
 int qxl_debugfs_add_files(struct qxl_device *rdev,
 			     struct drm_info_list *files,
-			     unsigned nfiles);
+			     unsigned int nfiles);
 int qxl_debugfs_fence_init(struct qxl_device *rdev);
 
 struct qxl_device;
@@ -252,7 +252,7 @@ struct qxl_device {
 	atomic_t irq_received_display;
 	atomic_t irq_received_cursor;
 	atomic_t irq_received_io_cmd;
-	unsigned irq_received_error;
+	unsigned int irq_received_error;
 	wait_queue_head_t display_event;
 	wait_queue_head_t cursor_event;
 	wait_queue_head_t io_cmd_event;
@@ -260,7 +260,7 @@ struct qxl_device {
 
 	/* debugfs */
 	struct qxl_debugfs	debugfs[QXL_DEBUGFS_MAX_COMPONENTS];
-	unsigned		debugfs_count;
+	unsigned int debugfs_count;
 
 	struct mutex		update_area_mutex;
 
@@ -395,7 +395,7 @@ void qxl_update_screen(struct qxl_device *qxl);
 /* qxl io operations (qxl_cmd.c) */
 
 void qxl_io_create_primary(struct qxl_device *qdev,
-			   unsigned offset,
+			   unsigned int offset,
 			   struct qxl_bo *bo);
 void qxl_io_destroy_primary(struct qxl_device *qdev);
 void qxl_io_memslot_add(struct qxl_device *qdev, uint8_t id);
@@ -446,9 +446,9 @@ void qxl_draw_opaque_fb(const struct qxl_fb_image *qxl_fb_image,
 void qxl_draw_dirty_fb(struct qxl_device *qdev,
 		       struct drm_framebuffer *fb,
 		       struct qxl_bo *bo,
-		       unsigned flags, unsigned color,
+		       unsigned int flags, unsigned int color,
 		       struct drm_clip_rect *clips,
-		       unsigned num_clips, int inc);
+		       unsigned int num_clips, int inc);
 
 void qxl_draw_fill(struct qxl_draw_fill *qxl_draw_fill_rec);
 
@@ -493,7 +493,7 @@ bool qxl_fbdev_qobj_is_fb(struct qxl_device *qdev, struct qxl_bo *qobj);
 
 int qxl_debugfs_add_files(struct qxl_device *qdev,
 			  struct drm_info_list *files,
-			  unsigned nfiles);
+			  unsigned int nfiles);
 
 int qxl_surface_id_alloc(struct qxl_device *qdev,
 			 struct qxl_bo *surf);

commit d964985c0d5de15ce78bb614c2b2ba61becb56b9
Author: Shayenne da Luz Moura <shayenneluzmoura@gmail.com>
Date:   Fri Oct 26 16:23:16 2018 -0300

    drm/qxl: Remove exceding whiteline
    
    Remove extra whiteline to clean the checkpatch.pl check:
    
    CHECK: Please don't use multiple blank lines
    
    Signed-off-by: Shayenne da Luz Moura <shayenneluzmoura@gmail.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/5b95e1d4d515d02d01b829ddc5b3ca80af29e2e2.1540579956.git.shayenneluzmoura@gmail.com
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 8ff70a7281a7..4b90f9bd7280 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -23,7 +23,6 @@
  *          Alon Levy
  */
 
-
 #ifndef QXL_DRV_H
 #define QXL_DRV_H
 
@@ -133,7 +132,6 @@ struct qxl_mman {
 	struct ttm_bo_device		bdev;
 };
 
-
 struct qxl_memslot {
 	uint8_t		generation;
 	uint64_t	start_phys_addr;
@@ -372,7 +370,6 @@ int qxl_mode_dumb_mmap(struct drm_file *filp,
 		       struct drm_device *dev,
 		       uint32_t handle, uint64_t *offset_p);
 
-
 /* qxl ttm */
 int qxl_ttm_init(struct qxl_device *qdev);
 void qxl_ttm_fini(struct qxl_device *qdev);

commit bf8744e40cd6db20dfbd231ad44943f6bc8ac311
Author: Peter Wu <peter@lekensteyn.nl>
Date:   Mon Sep 10 15:21:56 2018 +0200

    qxl: refactor to use drm_fb_helper_fbdev_setup
    
    Lots of code can be removed by relying on fb-helper:
    - "struct drm_framebuffer" moves to fb_helper.fb.
    - "struct drm_gem_object" moves to fb_helper.obj[0].
    - "struct qxl_device" can be inferred as drm_fb_helper is embedded.
    - qxl_user_framebuffer_create -> drm_gem_fb_create.
    - qxl_user_framebuffer_destroy -> drm_gem_fb_destroy.
    - qxl_fbdev_destroy -> drm_fb_helper_fbdev_teardown + vfree(shadow).
    
    Remove unused code:
    - qxl_fbdev_qobj_is_fb, qxl_fbdev_set_suspend.
    - Unused fields of qxl_fbdev: delayed_ops, delayed_ops_lock, size.
    
    Misc notes:
    - The dirty callback is preserved as it is necessary to trigger update
      commands in the hw (the screen stays black otherwise).
    - No idea when .create_handle in drm_framebuffer_funcs is used, but use
      the same drm_gem_fb_create_handle to match drm_gem_fb_funcs.
    - I don't know why qxl_fb_find_or_create_single used to check for an
      existing framebuffer and removed that check to match other drivers.
    - Use of drm_fb_helper_fbdev_teardown also requires "info->fbdefio" to
      be dynamically allocated. Replace the existing defio config by
      drm_fb_helper_defio_init to accomodate this.
    
    Testing results: startx with fbdev, modesetting and qxl all seems to
    work. Tested also with CONFIG_DRM_FBDEV_EMULATION=n, fbdev obviously
    fails but others are fine. QEMU -spice and QEMU -spice with vdagent and
    multiple (resized) displays (via remote-viewer) also works.
    unbind vtconsole and rmmod has *not* regressed (i.e. it still trips on a
    use-after-free in qxl_check_idle via qxl_ttm_fini).
    
    Ideally setup/teardown is replaced by drm_fbdev_generic_setup as that
    would result in further code reduction, improve error handling (like not
    leaking shadow memory), but unfortunately QXL has no implementation for
    qxl_gem_prime_vmap.
    
    Signed-off-by: Peter Wu <peter@lekensteyn.nl>
    Link: http://patchwork.freedesktop.org/patch/msgid/20180910132156.23201-1-peter@lekensteyn.nl
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 01220d386b0a..8ff70a7281a7 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -38,6 +38,7 @@
 
 #include <drm/drm_crtc.h>
 #include <drm/drm_encoder.h>
+#include <drm/drm_fb_helper.h>
 #include <drm/drm_gem.h>
 #include <drm/drmP.h>
 #include <drm/ttm/ttm_bo_api.h>
@@ -121,15 +122,9 @@ struct qxl_output {
 	struct drm_encoder enc;
 };
 
-struct qxl_framebuffer {
-	struct drm_framebuffer base;
-	struct drm_gem_object *obj;
-};
-
 #define to_qxl_crtc(x) container_of(x, struct qxl_crtc, base)
 #define drm_connector_to_qxl_output(x) container_of(x, struct qxl_output, base)
 #define drm_encoder_to_qxl_output(x) container_of(x, struct qxl_output, enc)
-#define to_qxl_framebuffer(x) container_of(x, struct qxl_framebuffer, base)
 
 struct qxl_mman {
 	struct ttm_bo_global_ref        bo_global_ref;
@@ -138,13 +133,6 @@ struct qxl_mman {
 	struct ttm_bo_device		bdev;
 };
 
-struct qxl_mode_info {
-	bool mode_config_initialized;
-
-	/* pointer to fbdev info structure */
-	struct qxl_fbdev *qfbdev;
-};
-
 
 struct qxl_memslot {
 	uint8_t		generation;
@@ -232,10 +220,9 @@ struct qxl_device {
 	void *ram;
 	struct qxl_mman		mman;
 	struct qxl_gem		gem;
-	struct qxl_mode_info mode_info;
 
-	struct fb_info			*fbdev_info;
-	struct qxl_framebuffer	*fbdev_qfb;
+	struct drm_fb_helper	fb_helper;
+
 	void *ram_physical;
 
 	struct qxl_ring *release_ring;
@@ -349,19 +336,8 @@ qxl_bo_physical_address(struct qxl_device *qdev, struct qxl_bo *bo,
 
 int qxl_fbdev_init(struct qxl_device *qdev);
 void qxl_fbdev_fini(struct qxl_device *qdev);
-int qxl_get_handle_for_primary_fb(struct qxl_device *qdev,
-				  struct drm_file *file_priv,
-				  uint32_t *handle);
-void qxl_fbdev_set_suspend(struct qxl_device *qdev, int state);
 
 /* qxl_display.c */
-void qxl_user_framebuffer_destroy(struct drm_framebuffer *fb);
-int
-qxl_framebuffer_init(struct drm_device *dev,
-		     struct qxl_framebuffer *rfb,
-		     const struct drm_mode_fb_cmd2 *mode_cmd,
-		     struct drm_gem_object *obj,
-		     const struct drm_framebuffer_funcs *funcs);
 void qxl_display_read_client_monitors_config(struct qxl_device *qdev);
 int qxl_create_monitors_object(struct qxl_device *qdev);
 int qxl_destroy_monitors_object(struct qxl_device *qdev);
@@ -471,7 +447,7 @@ void qxl_draw_opaque_fb(const struct qxl_fb_image *qxl_fb_image,
 			int stride /* filled in if 0 */);
 
 void qxl_draw_dirty_fb(struct qxl_device *qdev,
-		       struct qxl_framebuffer *qxl_fb,
+		       struct drm_framebuffer *fb,
 		       struct qxl_bo *bo,
 		       unsigned flags, unsigned color,
 		       struct drm_clip_rect *clips,

commit 94cc2fde365fb4484080ea6675bb1e0c933f8002
Merge: 900aa8ad2158 8eb008c80841
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Fri May 11 18:08:10 2018 +0200

    Merge remote-tracking branch 'drm/drm-next' into drm-misc-next
    
    drm-misc-next is still based on v4.16-rc7, and was getting a bit stale.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>

commit 735581a0a13c58e6ff7eaf7a1087e1e5d917cabe
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Fri Apr 20 09:19:01 2018 +0200

    qxl: remove qxl_io_log()
    
    qxl_io_log() sends messages over to the host (qemu) for logging.
    Remove the function and all callers, we can just use standard
    DRM_DEBUG calls (and if needed a serial console).
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Reviewed-by: Dave Airlie <airlied@redhat.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20180420071904.24276-2-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 00a1a66b052a..4b8984017373 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -298,9 +298,6 @@ struct qxl_device {
 	int monitors_config_height;
 };
 
-/* forward declaration for QXL_INFO_IO */
-__printf(2,3) void qxl_io_log(struct qxl_device *qdev, const char *fmt, ...);
-
 extern const struct drm_ioctl_desc qxl_ioctls[];
 extern int qxl_max_ioctl;
 

commit 7a31805ba28c93f80cf874492e2f21da80851a9f
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Wed Apr 18 07:42:57 2018 +0200

    qxl: keep separate release_bo pointer
    
    qxl expects that list_first_entry(release->bos) returns the first
    element qxl added to the list.  ttm_eu_reserve_buffers() may reorder
    the list though.
    
    Add a release_bo field to struct qxl_release and use that instead.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Reviewed-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20180418054257.15388-3-kraxel@redhat.com
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 00a1a66b052a..864b456080c4 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -167,6 +167,7 @@ struct qxl_release {
 
 	int id;
 	int type;
+	struct qxl_bo *release_bo;
 	uint32_t release_offset;
 	uint32_t surface_release_id;
 	struct ww_acquire_ctx ticket;

commit 9428088c90b6f7d5edd2a1b0d742c75339b36f6e
Author: Ray Strode <rstrode@redhat.com>
Date:   Mon Nov 27 16:50:10 2017 -0500

    drm/qxl: reapply cursor after resetting primary
    
    QXL associates mouse state with its primary plane.
    
    Destroying a primary plane and putting a new one in place has the side
    effect of destroying the cursor as well.
    
    This commit changes the driver to reapply the cursor any time a new
    primary is created. It achieves this by keeping a reference to the
    cursor bo on the qxl_crtc struct.
    
    This fix is very similar to
    
    commit 4532b241a4b7 ("drm/qxl: reapply cursor after SetCrtc calls")
    
    which got implicitly reverted as part of implementing the atomic
    modeset feature.
    
    Cc: Gerd Hoffmann <kraxel@redhat.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1512097
    Fixes: 1277eed5fecb ("drm: qxl: Atomic phase 1: convert cursor to universal plane")
    Cc: stable@vger.kernel.org
    Signed-off-by: Ray Strode <rstrode@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 08752c0ffb35..00a1a66b052a 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -111,6 +111,8 @@ struct qxl_bo_list {
 struct qxl_crtc {
 	struct drm_crtc base;
 	int index;
+
+	struct qxl_bo *cursor_bo;
 };
 
 struct qxl_output {

commit 62676d10b483a2ff6e8b08c5e7c7d63a831343f5
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Thu Oct 19 08:21:50 2017 +0200

    qxl: alloc & use shadow for dumb buffers
    
    This patch changes the way the primary surface is used for dumb
    framebuffers.  Instead of configuring the bo itself as primary surface
    a shadow bo is created and used instead.  Framebuffers can share the
    shadow bo in case they have the same format and resolution.
    
    On atomic plane updates we don't have to update the primary surface in
    case we pageflip from one framebuffer to another framebuffer which
    shares the same shadow.  This in turn avoids the flicker caused by the
    primary-destroy + primary-create cycle, which is very annonying when
    running wayland on qxl.
    
    The qxl driver never actually writes to the shadow bo.  It sends qxl
    blit commands which update it though, and the spice server might
    actually execute them (and thereby write to the shadow) in case the
    local rendering is kicked for some reason.  This happens for example in
    case qemu is asked to write out a dump of the guest display (screendump
    monitor command).
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Reviewed-by: Dave Airlie <airlied@redhat.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20171019062150.28090-3-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index d707b351875c..08752c0ffb35 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -89,6 +89,8 @@ struct qxl_bo {
 	/* Constant after initialization */
 	struct drm_gem_object		gem_base;
 	bool is_primary; /* is this now a primary surface */
+	bool is_dumb;
+	struct qxl_bo *shadow;
 	bool hw_surf_alloc;
 	struct qxl_surface surf;
 	uint32_t surface_id;

commit 56cbcb6c41932b19ef0d838f1ff25a662a2e403d
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Thu Oct 19 08:21:49 2017 +0200

    drm/qxl: replace QXL_INFO with DRM_DEBUG_DRIVER
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Reviewed-by: Dave Airlie <airlied@redhat.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20171019062150.28090-2-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 3397a1907336..d707b351875c 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -62,33 +62,9 @@
 
 #define QXL_DEBUGFS_MAX_COMPONENTS		32
 
-extern int qxl_log_level;
 extern int qxl_num_crtc;
 extern int qxl_max_ioctls;
 
-enum {
-	QXL_INFO_LEVEL = 1,
-	QXL_DEBUG_LEVEL = 2,
-};
-
-#define QXL_INFO(qdev, fmt, ...) do { \
-		if (qxl_log_level >= QXL_INFO_LEVEL) {	\
-			qxl_io_log(qdev, fmt, __VA_ARGS__); \
-		}	\
-	} while (0)
-#define QXL_DEBUG(qdev, fmt, ...) do { \
-		if (qxl_log_level >= QXL_DEBUG_LEVEL) {	\
-			qxl_io_log(qdev, fmt, __VA_ARGS__); \
-		}	\
-	} while (0)
-#define QXL_INFO_ONCE(qdev, fmt, ...) do { \
-		static int done;		\
-		if (!done) {			\
-			done = 1;			\
-			QXL_INFO(qdev, fmt, __VA_ARGS__);	\
-		}						\
-	} while (0)
-
 #define DRM_FILE_OFFSET 0x100000000ULL
 #define DRM_FILE_PAGE_OFFSET (DRM_FILE_OFFSET >> PAGE_SHIFT)
 
@@ -351,7 +327,7 @@ int qxl_check_idle(struct qxl_ring *ring);
 static inline void *
 qxl_fb_virtual_address(struct qxl_device *qdev, unsigned long physical)
 {
-	QXL_INFO(qdev, "not implemented (%lu)\n", physical);
+	DRM_DEBUG_DRIVER("not implemented (%lu)\n", physical);
 	return 0;
 }
 

commit 747fddd4e85369630c212e04a78caf90e2ec8f48
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Tue Jun 20 13:39:16 2017 +0200

    drm/qxl: move extern variable declaration header file
    
    Flagged by sparse.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170620113916.6967-4-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 3591d2330a09..3397a1907336 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -64,6 +64,7 @@
 
 extern int qxl_log_level;
 extern int qxl_num_crtc;
+extern int qxl_max_ioctls;
 
 enum {
 	QXL_INFO_LEVEL = 1,

commit edaf492c1319c9b23c013ee9c6b99a6d9d61dcc3
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Apr 24 13:50:30 2017 +0900

    drm/qxl: fix include notation and remove -Iinclude/drm flag
    
    Include <drm/*.h> instead of relative path from include/drm, then
    remove the -Iinclude/drm compiler flag.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1493009447-31524-13-git-send-email-yamada.masahiro@socionext.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 5ea290a33a68..3591d2330a09 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -36,20 +36,18 @@
 #include <linux/firmware.h>
 #include <linux/platform_device.h>
 
-#include "drmP.h"
-#include "drm_crtc.h"
-#include <ttm/ttm_bo_api.h>
-#include <ttm/ttm_bo_driver.h>
-#include <ttm/ttm_placement.h>
-#include <ttm/ttm_module.h>
-
+#include <drm/drm_crtc.h>
 #include <drm/drm_encoder.h>
 #include <drm/drm_gem.h>
-
+#include <drm/drmP.h>
+#include <drm/ttm/ttm_bo_api.h>
+#include <drm/ttm/ttm_bo_driver.h>
 /* just for ttm_validate_buffer */
-#include <ttm/ttm_execbuf_util.h>
-
+#include <drm/ttm/ttm_execbuf_util.h>
+#include <drm/ttm/ttm_module.h>
+#include <drm/ttm/ttm_placement.h>
 #include <drm/qxl_drm.h>
+
 #include "qxl_dev.h"
 
 #define DRIVER_AUTHOR		"Dave Airlie"

commit 34c9d524103fc8d4657b41ab9f1120e936010793
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Tue Mar 7 21:49:24 2017 +0100

    drm/qxl: Remove qxl_debugfs_remove_files()
    
    drm_debugfs_cleanup() now removes all minor->debugfs_list entries
    automatically, so it's not necessary to call drm_debugfs_remove_files().
    
    Cc: airlied@linux.ie
    Cc: kraxel@redhat.com
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170307204924.1002-4-noralf@tronnes.org
    
    [ kraxel: solved conflict ]
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index b43320fe5da5..5ea290a33a68 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -230,7 +230,6 @@ int qxl_debugfs_add_files(struct qxl_device *rdev,
 			     struct drm_info_list *files,
 			     unsigned nfiles);
 int qxl_debugfs_fence_init(struct qxl_device *rdev);
-void qxl_debugfs_remove_files(struct qxl_device *qdev);
 
 struct qxl_device;
 

commit ecefd94e8bde7de4f03d6fc874378d826537df7b
Author: Gerd Hoffmann <kraxel@redhat.com>
Date:   Wed Mar 1 11:12:31 2017 +0100

    qxl: drop mode_info.modes & related code.
    
    very old qxl hardware revisions (predating qxl ksm support by a few
    years) supported a fixed list of video modes only.  The list is still
    provided by the virtual hardware, for backward compatibility reasons.
    
    The qxl kms driver never ever looks at it, except for dumping it to
    the kernel log at load time in case debug logging is enabled.  Drop
    that pointless code.
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    Reviewed-by: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1488363154-6889-2-git-send-email-kraxel@redhat.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index c0481706e4b0..b43320fe5da5 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -160,8 +160,6 @@ struct qxl_mman {
 };
 
 struct qxl_mode_info {
-	int num_modes;
-	struct qxl_mode *modes;
 	bool mode_config_initialized;
 
 	/* pointer to fbdev info structure */

commit cc14d46ba1cf21d2f1163add493e07ffbe0e222b
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Thu Jan 26 23:56:20 2017 +0100

    drm/qxl: Remove qxl_debugfs_takedown()
    
    drm_debugfs_cleanup() now removes all minor->debugfs_list entries
    automatically, so the drm_driver.debugfs_cleanup callback is not
    needed.
    
    Cc: airlied@linux.ie
    Cc: kraxel@redhat.com
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170126225621.12314-19-noralf@tronnes.org

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 0c313e563632..c0481706e4b0 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -523,7 +523,6 @@ int qxl_garbage_collect(struct qxl_device *qdev);
 /* debugfs */
 
 int qxl_debugfs_init(struct drm_minor *minor);
-void qxl_debugfs_takedown(struct drm_minor *minor);
 int qxl_ttm_debugfs_init(struct qxl_device *qdev);
 
 /* qxl_prime.c */

commit 1277eed5fecb8830c8cc414ad70c1ef640464bc0
Author: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
Date:   Mon Feb 27 17:43:19 2017 -0300

    drm: qxl: Atomic phase 1: convert cursor to universal plane
    
    In preparation for atomic conversion, let's use the transitional atomic
    helpers drm_plane_helper_update/disable.
    
    Signed-off-by: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170227204328.18761-6-krisman@collabora.co.uk
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 647f0926cb50..0c313e563632 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -134,11 +134,6 @@ struct qxl_bo_list {
 struct qxl_crtc {
 	struct drm_crtc base;
 	int index;
-	int cur_x;
-	int cur_y;
-	int hot_spot_x;
-	int hot_spot_y;
-	struct qxl_bo *cursor_bo;
 };
 
 struct qxl_output {

commit aa5b62bac05d4b2bf7e5b3a006fa87625ee7beec
Author: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
Date:   Mon Feb 27 17:43:15 2017 -0300

    drm: qxl: Drop device flags attribute
    
    There are no device specific flags that we need to keep track of here.
    Let it vanish.
    
    Signed-off-by: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
    Reviewed-by: Gustavo Padovan <gustavo.padovan@collabora.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170227204328.18761-2-krisman@collabora.co.uk
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 785c17b56f73..647f0926cb50 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -243,7 +243,6 @@ struct qxl_device;
 
 struct qxl_device {
 	struct drm_device ddev;
-	unsigned long flags;
 
 	resource_size_t vram_base, vram_size;
 	resource_size_t surfaceram_base, surfaceram_size;
@@ -335,7 +334,7 @@ extern const struct drm_ioctl_desc qxl_ioctls[];
 extern int qxl_max_ioctl;
 
 int qxl_device_init(struct qxl_device *qdev, struct drm_driver *drv,
-		    struct pci_dev *pdev, unsigned long flags);
+		    struct pci_dev *pdev);
 void qxl_device_fini(struct qxl_device *qdev);
 
 int qxl_modeset_init(struct qxl_device *qdev);

commit cbdded7f8a633ee9418047c50a7114ce2282b912
Author: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
Date:   Thu Jan 26 23:05:48 2017 -0200

    drm: qxl: Embed drm_device into driver structure
    
    This is the recommended way to create the drm_device structure,
    according to DRM documentation.
    
    Signed-off-by: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170127010548.27970-4-krisman@collabora.co.uk
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 05a96dde1916..785c17b56f73 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -242,7 +242,7 @@ void qxl_debugfs_remove_files(struct qxl_device *qdev);
 struct qxl_device;
 
 struct qxl_device {
-	struct drm_device		*ddev;
+	struct drm_device ddev;
 	unsigned long flags;
 
 	resource_size_t vram_base, vram_size;
@@ -334,8 +334,8 @@ __printf(2,3) void qxl_io_log(struct qxl_device *qdev, const char *fmt, ...);
 extern const struct drm_ioctl_desc qxl_ioctls[];
 extern int qxl_max_ioctl;
 
-int qxl_device_init(struct qxl_device *qdev, struct drm_device *ddev,
-		    struct pci_dev *pdev,  unsigned long flags);
+int qxl_device_init(struct qxl_device *qdev, struct drm_driver *drv,
+		    struct pci_dev *pdev, unsigned long flags);
 void qxl_device_fini(struct qxl_device *qdev);
 
 int qxl_modeset_init(struct qxl_device *qdev);

commit d74d74aeaf0b29a158bc95c63c6b6b107a57f4f5
Author: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
Date:   Thu Jan 26 23:05:47 2017 -0200

    drm: qxl: Drop duplicated pci_device pointer attribute
    
    qxl_device duplicates the pointer to struct pci_dev, which is not
    needed since we already have it in the drm_device structure.  Clean it
    up.
    
    Signed-off-by: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170127010548.27970-3-krisman@collabora.co.uk
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index a022de205134..05a96dde1916 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -243,7 +243,6 @@ struct qxl_device;
 
 struct qxl_device {
 	struct drm_device		*ddev;
-	struct pci_dev			*pdev;
 	unsigned long flags;
 
 	resource_size_t vram_base, vram_size;

commit 5472bdee3f7ac3393e6911fc21eaa339b978cfed
Author: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
Date:   Thu Jan 26 23:05:46 2017 -0200

    drm: qxl: Drop duplicated device pointer attribute
    
    qxl_device duplicates a pointer to struct device, which is not needed
    since we already have it in the drm_device structure.  Clean it up.
    
    Signed-off-by: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170127010548.27970-2-krisman@collabora.co.uk
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 0d877fa61162..a022de205134 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -242,7 +242,6 @@ void qxl_debugfs_remove_files(struct qxl_device *qdev);
 struct qxl_device;
 
 struct qxl_device {
-	struct device			*dev;
 	struct drm_device		*ddev;
 	struct pci_dev			*pdev;
 	unsigned long flags;

commit 6f897f51c4181397bf811d260eb7fef8d7ccd14f
Author: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
Date:   Thu Jan 19 11:48:06 2017 -0200

    drm: qxl: Open code teardown function for qxl
    
    This avoids using the deprecated drm_put_dev() and unload() hook
    interfaces in the qxl driver.
    
    Signed-off-by: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Gustavo Padovan <gustavo.padovan@collabora.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170119134806.8926-2-krisman@collabora.co.uk

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 83201988394f..0d877fa61162 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -340,8 +340,6 @@ int qxl_device_init(struct qxl_device *qdev, struct drm_device *ddev,
 		    struct pci_dev *pdev,  unsigned long flags);
 void qxl_device_fini(struct qxl_device *qdev);
 
-void qxl_driver_unload(struct drm_device *dev);
-
 int qxl_modeset_init(struct qxl_device *qdev);
 void qxl_modeset_fini(struct qxl_device *qdev);
 

commit 2b65d5677a797f8b53e97548003d1f38677fee81
Author: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
Date:   Thu Jan 19 11:48:05 2017 -0200

    drm: qxl: Open code probing sequence for qxl
    
    This avoids using the deprecated drm_get_pci_dev() and load() hook
    interfaces in the qxl driver.
    
    The only tricky part is to ensure TTM debugfs initialization happens
    after the debugfs root node is created, which is done by moving that
    code into the debufs_init() hook.
    
    Tested on qemu with igt and running a WM on top of X.
    
    Changes since v1:
     - Drop verification for primary minor in qxl_debugsfs_init.
    Changes since V2:
     - Put new header together with other debugfs headers.
    
    Signed-off-by: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Gustavo Padovan <gustavo.padovan@collabora.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170119134806.8926-1-krisman@collabora.co.uk

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 883d8639c04e..83201988394f 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -336,7 +336,10 @@ __printf(2,3) void qxl_io_log(struct qxl_device *qdev, const char *fmt, ...);
 extern const struct drm_ioctl_desc qxl_ioctls[];
 extern int qxl_max_ioctl;
 
-int qxl_driver_load(struct drm_device *dev, unsigned long flags);
+int qxl_device_init(struct qxl_device *qdev, struct drm_device *ddev,
+		    struct pci_dev *pdev,  unsigned long flags);
+void qxl_device_fini(struct qxl_device *qdev);
+
 void qxl_driver_unload(struct drm_device *dev);
 
 int qxl_modeset_init(struct qxl_device *qdev);
@@ -531,6 +534,7 @@ int qxl_garbage_collect(struct qxl_device *qdev);
 
 int qxl_debugfs_init(struct drm_minor *minor);
 void qxl_debugfs_takedown(struct drm_minor *minor);
+int qxl_ttm_debugfs_init(struct qxl_device *qdev);
 
 /* qxl_prime.c */
 int qxl_gem_prime_pin(struct drm_gem_object *obj);

commit 11b3c20bdd15d17382068be569740de1dccb173d
Author: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
Date:   Fri Jan 6 15:57:31 2017 -0200

    drm: Change the return type of the unload hook to void
    
    The integer returned by the unload hook is ignored by the drm core, so
    let's make it void.
    
    This patch was created using the following Coccinelle semantic script
    (except for the declaration and comment in drm_drv.h):
    
    Compile-tested only.
    
    // <smpl>
    @ get_name @
    struct drm_driver drv;
    identifier fn;
    @@
    drv.unload = fn;
    
    @ replace_type @
    identifier get_name.fn;
    @@
    - int
    + void
    fn (...)
    {
    ...
    }
    
    @ remove_return_param @
    identifier get_name.fn;
    @@
    void fn (...)
    {
    <...
    if (...)
    return
    - ...
    ;
    ...>
     }
    
    @ drop_final_return @
    identifier get_name.fn;
    @@
    void fn (...)
    {
    ...
    
    - return 0;
    }
    // </smpl>
    
    Suggested-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
    Acked-by: Christian König <christian.koenig@amd.com>.
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170106175731.29196-1-krisman@collabora.co.uk

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index f15ddd0eb85b..883d8639c04e 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -337,7 +337,7 @@ extern const struct drm_ioctl_desc qxl_ioctls[];
 extern int qxl_max_ioctl;
 
 int qxl_driver_load(struct drm_device *dev, unsigned long flags);
-int qxl_driver_unload(struct drm_device *dev);
+void qxl_driver_unload(struct drm_device *dev);
 
 int qxl_modeset_init(struct qxl_device *qdev);
 void qxl_modeset_fini(struct qxl_device *qdev);

commit 9338203c4f03ffe323b67f0b2fa17b9811fa9bb6
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Nov 28 20:51:09 2016 +0200

    drm: Don't include <drm/drm_encoder.h> in <drm/drm_crtc.h>
    
    <drm/drm_crtc.h> used to define most of the in-kernel KMS API. It has
    now been split into separate files for each object type, but still
    includes most other KMS headers to avoid breaking driver compilation.
    
    As a step towards fixing that problem, remove the inclusion of
    <drm/drm_encoder.h> from <drm/drm_crtc.h> and include it instead where
    appropriate. Also remove the forward declarations of the drm_encoder and
    drm_encoder_helper_funcs structures from <drm/drm_crtc.h> as they're not
    needed in the header.
    
    <drm/drm_encoder.h> now has to include <drm/drm_mode.h> and contain a
    forward declaration of struct drm_encoder in order to allow including it
    as the first header in a compilation unit.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com> # For vmwgfx
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481709550-29226-2-git-send-email-laurent.pinchart+renesas@ideasonboard.com

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 785aad42e9bb..f15ddd0eb85b 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -43,6 +43,7 @@
 #include <ttm/ttm_placement.h>
 #include <ttm/ttm_module.h>
 
+#include <drm/drm_encoder.h>
 #include <drm/drm_gem.h>
 
 /* just for ttm_validate_buffer */

commit 63207455963053ca212e61c75f43b3502ea69f0e
Merge: 7625e05286cf 348a4b6dd77d
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Nov 30 14:18:51 2016 +1000

    Merge tag 'drm-qemu-20161121' of git://git.kraxel.org/linux into drm-next
    
    drm/virtio: fix busid in a different way, allocate more vbufs.
    drm/qxl: various bugfixes and cleanups,
    
    * tag 'drm-qemu-20161121' of git://git.kraxel.org/linux: (224 commits)
      drm/virtio: allocate some extra bufs
      qxl: Allow resolution which are not multiple of 8
      qxl: Don't notify userspace when monitors config is unchanged
      qxl: Remove qxl_bo_init() return value
      qxl: Call qxl_gem_{init, fini}
      qxl: Add missing '\n' to qxl_io_log() call
      qxl: Remove unused prototype
      qxl: Mark some internal functions as static
      Revert "drm: virtio: reinstate drm_virtio_set_busid()"
      drm/virtio: fix busid regression
      drm: re-export drm_dev_set_unique
      Linux 4.9-rc5
      gp8psk: Fix DVB frontend attach
      gp8psk: fix gp8psk_usb_in_op() logic
      dvb-usb: move data_mutex to struct dvb_usb_device
      iio: maxim_thermocouple: detect invalid storage size in read()
      aoe: fix crash in page count manipulation
      lightnvm: invalid offset calculation for lba_shift
      Kbuild: enable -Wmaybe-uninitialized warnings by default
      pcmcia: fix return value of soc_pcmcia_regulator_set
      ...

commit ae4b9a09234ec77832406bdb767015ebd82cf22f
Author: Christophe Fergeau <cfergeau@redhat.com>
Date:   Tue Nov 8 10:12:07 2016 +0100

    qxl: Remove qxl_bo_init() return value
    
    It's always returning 0, and it's always ignored.
    
    Signed-off-by: Christophe Fergeau <cfergeau@redhat.com>
    Acked-by: Frediano Ziglio <fziglio@redhat.com>
    Message-id: 20161108091209.25568-6-cfergeau@redhat.com
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 590ba25862f4..707680601c47 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -399,7 +399,7 @@ int qxl_create_monitors_object(struct qxl_device *qdev);
 int qxl_destroy_monitors_object(struct qxl_device *qdev);
 
 /* qxl_gem.c */
-int qxl_gem_init(struct qxl_device *qdev);
+void qxl_gem_init(struct qxl_device *qdev);
 void qxl_gem_fini(struct qxl_device *qdev);
 int qxl_gem_object_create(struct qxl_device *qdev, int size,
 			  int alignment, int initial_domain,

commit 86c792aa22d6fc262f7533ca6cad373300ae4830
Author: Christophe Fergeau <cfergeau@redhat.com>
Date:   Tue Nov 8 10:12:04 2016 +0100

    qxl: Remove unused prototype
    
    qxl_crtc_set_from_monitors_config() is defined in qxl_drv.h but never
    implemented.
    
    Signed-off-by: Christophe Fergeau <cfergeau@redhat.com>
    Acked-by: Frediano Ziglio <fziglio@redhat.com>
    Message-id: 20161108091209.25568-3-cfergeau@redhat.com
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index da41e1f8b527..590ba25862f4 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -398,9 +398,6 @@ void qxl_display_read_client_monitors_config(struct qxl_device *qdev);
 int qxl_create_monitors_object(struct qxl_device *qdev);
 int qxl_destroy_monitors_object(struct qxl_device *qdev);
 
-/* used by qxl_debugfs only */
-void qxl_crtc_set_from_monitors_config(struct qxl_device *qdev);
-
 /* qxl_gem.c */
 int qxl_gem_init(struct qxl_device *qdev);
 void qxl_gem_fini(struct qxl_device *qdev);

commit e4a76442efe137b52bd493698e8134ba49d592fa
Author: Christophe Fergeau <cfergeau@redhat.com>
Date:   Tue Nov 8 10:12:03 2016 +0100

    qxl: Mark some internal functions as static
    
    They are not used outside of their respective source file
    
    Signed-off-by: Christophe Fergeau <cfergeau@redhat.com>
    Acked-by: Frediano Ziglio <fziglio@redhat.com>
    Message-id: 20161108091209.25568-2-cfergeau@redhat.com
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 5f3e5ad99de7..da41e1f8b527 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -395,13 +395,11 @@ qxl_framebuffer_init(struct drm_device *dev,
 		     struct drm_gem_object *obj,
 		     const struct drm_framebuffer_funcs *funcs);
 void qxl_display_read_client_monitors_config(struct qxl_device *qdev);
-void qxl_send_monitors_config(struct qxl_device *qdev);
 int qxl_create_monitors_object(struct qxl_device *qdev);
 int qxl_destroy_monitors_object(struct qxl_device *qdev);
 
 /* used by qxl_debugfs only */
 void qxl_crtc_set_from_monitors_config(struct qxl_device *qdev);
-void qxl_alloc_client_monitors_config(struct qxl_device *qdev, unsigned count);
 
 /* qxl_gem.c */
 int qxl_gem_init(struct qxl_device *qdev);
@@ -574,6 +572,5 @@ int qxl_bo_check_id(struct qxl_device *qdev, struct qxl_bo *bo);
 struct qxl_drv_surface *
 qxl_surface_lookup(struct drm_device *dev, int surface_id);
 void qxl_surface_evict(struct qxl_device *qdev, struct qxl_bo *surf, bool freeing);
-int qxl_update_surface(struct qxl_device *qdev, struct qxl_bo *surf);
 
 #endif

commit f54d1867005c3323f5d8ad83eed823e84226c429
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Oct 25 13:00:45 2016 +0100

    dma-buf: Rename struct fence to dma_fence
    
    I plan to usurp the short name of struct fence for a core kernel struct,
    and so I need to rename the specialised fence/timeline for DMA
    operations to make room.
    
    A consensus was reached in
    https://lists.freedesktop.org/archives/dri-devel/2016-July/113083.html
    that making clear this fence applies to DMA operations was a good thing.
    Since then the patch has grown a bit as usage increases, so hopefully it
    remains a good thing!
    
    (v2...: rebase, rerun spatch)
    v3: Compile on msm, spotted a manual fixup that I broke.
    v4: Try again for msm, sorry Daniel
    
    coccinelle script:
    @@
    
    @@
    - struct fence
    + struct dma_fence
    @@
    
    @@
    - struct fence_ops
    + struct dma_fence_ops
    @@
    
    @@
    - struct fence_cb
    + struct dma_fence_cb
    @@
    
    @@
    - struct fence_array
    + struct dma_fence_array
    @@
    
    @@
    - enum fence_flag_bits
    + enum dma_fence_flag_bits
    @@
    
    @@
    (
    - fence_init
    + dma_fence_init
    |
    - fence_release
    + dma_fence_release
    |
    - fence_free
    + dma_fence_free
    |
    - fence_get
    + dma_fence_get
    |
    - fence_get_rcu
    + dma_fence_get_rcu
    |
    - fence_put
    + dma_fence_put
    |
    - fence_signal
    + dma_fence_signal
    |
    - fence_signal_locked
    + dma_fence_signal_locked
    |
    - fence_default_wait
    + dma_fence_default_wait
    |
    - fence_add_callback
    + dma_fence_add_callback
    |
    - fence_remove_callback
    + dma_fence_remove_callback
    |
    - fence_enable_sw_signaling
    + dma_fence_enable_sw_signaling
    |
    - fence_is_signaled_locked
    + dma_fence_is_signaled_locked
    |
    - fence_is_signaled
    + dma_fence_is_signaled
    |
    - fence_is_later
    + dma_fence_is_later
    |
    - fence_later
    + dma_fence_later
    |
    - fence_wait_timeout
    + dma_fence_wait_timeout
    |
    - fence_wait_any_timeout
    + dma_fence_wait_any_timeout
    |
    - fence_wait
    + dma_fence_wait
    |
    - fence_context_alloc
    + dma_fence_context_alloc
    |
    - fence_array_create
    + dma_fence_array_create
    |
    - to_fence_array
    + to_dma_fence_array
    |
    - fence_is_array
    + dma_fence_is_array
    |
    - trace_fence_emit
    + trace_dma_fence_emit
    |
    - FENCE_TRACE
    + DMA_FENCE_TRACE
    |
    - FENCE_WARN
    + DMA_FENCE_WARN
    |
    - FENCE_ERR
    + DMA_FENCE_ERR
    )
     (
     ...
     )
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Acked-by: Sumit Semwal <sumit.semwal@linaro.org>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161025120045.28839-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 5f3e5ad99de7..84995ebc6ffc 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -31,7 +31,7 @@
  * Definitions taken from spice-protocol, plus kernel driver specific bits.
  */
 
-#include <linux/fence.h>
+#include <linux/dma-fence.h>
 #include <linux/workqueue.h>
 #include <linux/firmware.h>
 #include <linux/platform_device.h>
@@ -190,7 +190,7 @@ enum {
  * spice-protocol/qxl_dev.h */
 #define QXL_MAX_RES 96
 struct qxl_release {
-	struct fence base;
+	struct dma_fence base;
 
 	int id;
 	int type;

commit 4532b241a4b7b0ca372a80baf900ce4ea2015412
Author: Ray Strode <rstrode@redhat.com>
Date:   Fri Sep 9 11:09:05 2016 -0400

    drm/qxl: reapply cursor after SetCrtc calls
    
    The qxl driver currently destroys and recreates the
    qxl "primary" any time the first crtc is set.
    
    A side-effect of destroying the primary is mouse state
    associated with the crtc is lost, which leads to
    disappearing mouse cursors on wayland sessions.
    
    This commit changes the driver to reapply the cursor
    any time SetCrtc is called. It achieves this by keeping
    a reference to the cursor bo on the qxl_crtc struct.
    
    Signed-off-by: Ray Strode <rstrode@redhat.com>
    Message-id: 1473433745-11016-1-git-send-email-halfline@gmail.com
    
    https://bugzilla.redhat.com/show_bug.cgi?id=1200901
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 8e633caa4078..5f3e5ad99de7 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -137,6 +137,7 @@ struct qxl_crtc {
 	int cur_y;
 	int hot_spot_x;
 	int hot_spot_y;
+	struct qxl_bo *cursor_bo;
 };
 
 struct qxl_output {

commit 7b2d16f55c6beec76510929eb7e481bf26a51764
Author: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
Date:   Sat Jul 2 16:32:09 2016 +0530

    drm/qxl: Remove deprecated create_singlethread_workqueue
    
    System workqueues have been able to handle high level of concurrency
    for a long time now and there's no reason to use dedicated workqueues
    just to gain concurrency. Since the workqueue in the QXL graphics device
    driver is involved in freeing and processing the release ring
    (workitem &qdev->gc_workqxl, maps to gc_work which calls
    qxl_garbage_collect) and is not being used on a memory reclaim path,
    dedicated gc_queue has been replaced with the use of system_wq.
    
    Unlike a dedicated per-cpu workqueue created with create_workqueue(),
    system_wq allows multiple work items to overlap executions even on
    the same CPU; however, a per-cpu workqueue doesn't have any CPU
    locality or global ordering guarantees unless the target CPU is
    explicitly specified and thus the increase of local concurrency
    shouldn't make any difference.
    
    flush_work() has been called in qxl_device_fini() to ensure that there
    are no pending tasks while disconnecting the driver.
    
    Signed-off-by: Bhaktipriya Shridhar <bhaktipriya96@gmail.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160702110209.GA3560@Karyakshetra

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 3ad6604b34ce..8e633caa4078 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -321,7 +321,6 @@ struct qxl_device {
 	struct qxl_bo *current_release_bo[3];
 	int current_release_bo_offset[3];
 
-	struct workqueue_struct *gc_queue;
 	struct work_struct gc_work;
 
 	struct drm_property *hotplug_mode_update_property;

commit bafb86f5bc3173479002555dea7f31d943b12332
Merge: ba391646d0d4 44549e8f5eea
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon May 9 13:49:56 2016 +1000

    Merge tag 'v4.6-rc7' into drm-next
    
    Merge this back as we've built up a fair few conflicts, and I have
    some newer trees to pull in.

commit 6819c3c2517604f979da3de773f2420e07dd4f4b
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Thu Apr 28 17:18:36 2016 +0200

    drm/qxl: Use drm_fb_helper deferred_io support
    
    Use the fbdev deferred io support in drm_fb_helper which mirrors the
    one qxl has had.
    This patch has only been compile tested.
    
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Tested-by: Gerd Hoffmann <kraxel@redhat.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1461856717-6476-7-git-send-email-noralf@tronnes.org

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 6e6b9b1519b8..c9c54260cc6c 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -322,8 +322,6 @@ struct qxl_device {
 	struct workqueue_struct *gc_queue;
 	struct work_struct gc_work;
 
-	struct work_struct fb_work;
-
 	struct drm_property *hotplug_mode_update_property;
 	int monitors_config_width;
 	int monitors_config_height;
@@ -387,11 +385,13 @@ int qxl_get_handle_for_primary_fb(struct qxl_device *qdev,
 void qxl_fbdev_set_suspend(struct qxl_device *qdev, int state);
 
 /* qxl_display.c */
+void qxl_user_framebuffer_destroy(struct drm_framebuffer *fb);
 int
 qxl_framebuffer_init(struct drm_device *dev,
 		     struct qxl_framebuffer *rfb,
 		     const struct drm_mode_fb_cmd2 *mode_cmd,
-		     struct drm_gem_object *obj);
+		     struct drm_gem_object *obj,
+		     const struct drm_framebuffer_funcs *funcs);
 void qxl_display_read_client_monitors_config(struct qxl_device *qdev);
 void qxl_send_monitors_config(struct qxl_device *qdev);
 int qxl_create_monitors_object(struct qxl_device *qdev);
@@ -551,7 +551,6 @@ int qxl_irq_init(struct qxl_device *qdev);
 irqreturn_t qxl_irq_handler(int irq, void *arg);
 
 /* qxl_fb.c */
-int qxl_fb_init(struct qxl_device *qdev);
 bool qxl_fbdev_qobj_is_fb(struct qxl_device *qdev, struct qxl_bo *qobj);
 
 int qxl_debugfs_add_files(struct qxl_device *qdev,

commit d59a1f71ff1aeda4b4630df92d3ad4e3b1dfc885
Author: John Keeping <john@metanate.com>
Date:   Wed Nov 18 11:17:25 2015 +0000

    drm/qxl: fix cursor position with non-zero hotspot
    
    The SPICE protocol considers the position of a cursor to be the location
    of its active pixel on the display, so the cursor is drawn with its
    top-left corner at "(x - hot_spot_x, y - hot_spot_y)" but the DRM cursor
    position gives the location where the top-left corner should be drawn,
    with the hotspot being a hint for drivers that need it.
    
    This fixes the location of the window resize cursors when using Fluxbox
    with the QXL DRM driver and both the QXL and modesetting X drivers.
    
    Signed-off-by: John Keeping <john@metanate.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: stable@vger.kernel.org
    Link: http://patchwork.freedesktop.org/patch/msgid/1447845445-2116-1-git-send-email-john@metanate.com
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 6e6b9b1519b8..3f3897eb458c 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -135,6 +135,8 @@ struct qxl_crtc {
 	int index;
 	int cur_x;
 	int cur_y;
+	int hot_spot_x;
+	int hot_spot_y;
 };
 
 struct qxl_output {

commit 1eb83451ba55d7a8c82b76b1591894ff2d4a95f2
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Nov 11 19:11:29 2015 +0200

    drm: Pass the user drm_mode_fb_cmd2 as const to .fb_create()
    
    Drivers shouldn't clobber the passed in addfb ioctl parameters.
    i915 was doing just that. To prevent it from happening again,
    pass the struct around as const, starting all the way from
    internal_framebuffer_create().
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 01a86948eb8c..6e6b9b1519b8 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -390,7 +390,7 @@ void qxl_fbdev_set_suspend(struct qxl_device *qdev, int state);
 int
 qxl_framebuffer_init(struct drm_device *dev,
 		     struct qxl_framebuffer *rfb,
-		     struct drm_mode_fb_cmd2 *mode_cmd,
+		     const struct drm_mode_fb_cmd2 *mode_cmd,
 		     struct drm_gem_object *obj);
 void qxl_display_read_client_monitors_config(struct qxl_device *qdev);
 void qxl_send_monitors_config(struct qxl_device *qdev);

commit bd3e1c7c6de9f5f70d97cdb6c817151c0477c5e3
Author: Jonathon Jongsma <jjongsma@redhat.com>
Date:   Thu Aug 20 14:04:32 2015 -0500

    drm/qxl: validate monitors config modes
    
    Due to some recent changes in
    drm_helper_probe_single_connector_modes_merge_bits(), old custom modes
    were not being pruned properly. In current kernels,
    drm_mode_validate_basic() is called to sanity-check each mode in the
    list. If the sanity-check passes, the mode's status gets set to to
    MODE_OK. In older kernels this check was not done, so old custom modes
    would still have a status of MODE_UNVERIFIED at this point, and would
    therefore be pruned later in the function.
    
    As a result of this new behavior, the list of modes for a device always
    includes every custom mode ever configured for the device, with the
    largest one listed first. Since desktop environments usually choose the
    first preferred mode when a hotplug event is emitted, this had the
    result of making it very difficult for the user to reduce the size of
    the display.
    
    The qxl driver did implement the mode_valid connector function, but it
    was empty. In order to restore the old behavior where old custom modes
    are pruned, we implement a proper mode_valid function for the qxl
    driver. This function now checks each mode against the last configured
    custom mode and the list of standard modes. If the mode doesn't match
    any of these, its status is set to MODE_BAD so that it will be pruned as
    expected.
    
    Signed-off-by: Jonathon Jongsma <jjongsma@redhat.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index d8549690801d..01a86948eb8c 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -325,6 +325,8 @@ struct qxl_device {
 	struct work_struct fb_work;
 
 	struct drm_property *hotplug_mode_update_property;
+	int monitors_config_width;
+	int monitors_config_height;
 };
 
 /* forward declaration for QXL_INFO_IO */

commit 72ec5650a85e8337d6364d16c65dd85a208b7986
Author: Frediano Ziglio <fziglio@redhat.com>
Date:   Wed Jun 3 12:09:16 2015 +0100

    drm/qxl: Remove format string errors
    
    Enable format string checks for qxl_io_log and remove resulting warnings
    which could lead to memory errors on different platform or just printing
    wrong information.
    
    Signed-off-by: Frediano Ziglio <fziglio@redhat.com>
    Reviewed-by: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 7c6cafe21f5f..d8549690801d 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -328,7 +328,7 @@ struct qxl_device {
 };
 
 /* forward declaration for QXL_INFO_IO */
-void qxl_io_log(struct qxl_device *qdev, const char *fmt, ...);
+__printf(2,3) void qxl_io_log(struct qxl_device *qdev, const char *fmt, ...);
 
 extern const struct drm_ioctl_desc qxl_ioctls[];
 extern int qxl_max_ioctl;

commit b5e9c1a25fcf8a0d664606251a53b5caa6a19d08
Author: Maarten Lankhorst <maarten.lankhorst@canonical.com>
Date:   Thu Jan 9 11:03:14 2014 +0100

    drm: Pass dma-buf as argument to gem_prime_import_sg_table
    
    Allows importing dma_reservation_objects from a dma-buf.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@canonical.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index ff0772728eb0..7c6cafe21f5f 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -537,7 +537,7 @@ int qxl_gem_prime_pin(struct drm_gem_object *obj);
 void qxl_gem_prime_unpin(struct drm_gem_object *obj);
 struct sg_table *qxl_gem_prime_get_sg_table(struct drm_gem_object *obj);
 struct drm_gem_object *qxl_gem_prime_import_sg_table(
-	struct drm_device *dev, size_t size,
+	struct drm_device *dev, struct dma_buf_attachment *attach,
 	struct sg_table *sgt);
 void *qxl_gem_prime_vmap(struct drm_gem_object *obj);
 void qxl_gem_prime_vunmap(struct drm_gem_object *obj, void *vaddr);

commit d9fc9413f97f5c615256a5657ec667c064c07a70
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Sep 23 15:46:53 2014 +0200

    drm: Extract <drm/drm_gem.h>
    
    v2: Don't forget git add, noticed by David.
    
    Cc: David Herrmann <dh.herrmann@gmail.com>
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Acked-by: David Herrmann <dh.herrmann@gmail.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index d75c0a9f674f..ff0772728eb0 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -43,6 +43,8 @@
 #include <ttm/ttm_placement.h>
 #include <ttm/ttm_module.h>
 
+#include <drm/drm_gem.h>
+
 /* just for ttm_validate_buffer */
 #include <ttm/ttm_execbuf_util.h>
 

commit 47c1296829505d119d7d58dd23d39cc5db344f12
Author: Andreas Pokorny <andreas.pokorny@canonical.com>
Date:   Fri Aug 8 10:40:56 2014 +0200

    drm/qxl: enables gem prime helpers for qxl using dummy driver callbacks
    
    As there should not be any other virtual device that might share buffers,
    the callbacks remain empty stubs. Still prime can be used to transfer buffers
    between processes that use qxl.
    
    Signed-off-by: Andreas Pokorny <andreas.pokorny@canonical.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index a8be87632cae..d75c0a9f674f 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -530,6 +530,18 @@ int qxl_garbage_collect(struct qxl_device *qdev);
 int qxl_debugfs_init(struct drm_minor *minor);
 void qxl_debugfs_takedown(struct drm_minor *minor);
 
+/* qxl_prime.c */
+int qxl_gem_prime_pin(struct drm_gem_object *obj);
+void qxl_gem_prime_unpin(struct drm_gem_object *obj);
+struct sg_table *qxl_gem_prime_get_sg_table(struct drm_gem_object *obj);
+struct drm_gem_object *qxl_gem_prime_import_sg_table(
+	struct drm_device *dev, size_t size,
+	struct sg_table *sgt);
+void *qxl_gem_prime_vmap(struct drm_gem_object *obj);
+void qxl_gem_prime_vunmap(struct drm_gem_object *obj, void *vaddr);
+int qxl_gem_prime_mmap(struct drm_gem_object *obj,
+				struct vm_area_struct *vma);
+
 /* qxl_irq.c */
 int qxl_irq_init(struct qxl_device *qdev);
 irqreturn_t qxl_irq_handler(int irq, void *arg);

commit f2c24b83ae90292d315aa7ac029c6ce7929e01aa
Author: Maarten Lankhorst <maarten.lankhorst@canonical.com>
Date:   Wed Apr 2 17:14:48 2014 +0200

    drm/ttm: flip the switch, and convert to dma_fence
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@canonical.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 116eeae843b4..a8be87632cae 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -280,9 +280,7 @@ struct qxl_device {
 	uint8_t		slot_gen_bits;
 	uint64_t	va_slot_mask;
 
-	/* XXX: when rcu becomes available, release_lock can be killed */
 	spinlock_t	release_lock;
-	spinlock_t	fence_lock;
 	struct idr	release_idr;
 	uint32_t	release_seqno;
 	spinlock_t release_idr_lock;

commit 2f453ed4038526172292fb3250b638b3782c7f2b
Author: Maarten Lankhorst <maarten.lankhorst@canonical.com>
Date:   Wed Apr 2 12:40:05 2014 +0200

    drm/qxl: rework to new fence interface
    
    Final driver! \o/
    
    This is not a proper dma_fence because the hardware may never signal
    anything, so don't use dma-buf with qxl, ever.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@canonical.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index f6022b703645..116eeae843b4 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -31,6 +31,7 @@
  * Definitions taken from spice-protocol, plus kernel driver specific bits.
  */
 
+#include <linux/fence.h>
 #include <linux/workqueue.h>
 #include <linux/firmware.h>
 #include <linux/platform_device.h>
@@ -95,13 +96,6 @@ enum {
 	QXL_INTERRUPT_IO_CMD |\
 	QXL_INTERRUPT_CLIENT_MONITORS_CONFIG)
 
-struct qxl_fence {
-	struct qxl_device *qdev;
-	uint32_t num_active_releases;
-	uint32_t *release_ids;
-	struct radix_tree_root tree;
-};
-
 struct qxl_bo {
 	/* Protected by gem.mutex */
 	struct list_head		list;
@@ -113,13 +107,13 @@ struct qxl_bo {
 	unsigned			pin_count;
 	void				*kptr;
 	int                             type;
+
 	/* Constant after initialization */
 	struct drm_gem_object		gem_base;
 	bool is_primary; /* is this now a primary surface */
 	bool hw_surf_alloc;
 	struct qxl_surface surf;
 	uint32_t surface_id;
-	struct qxl_fence fence; /* per bo fence  - list of releases */
 	struct qxl_release *surf_create;
 };
 #define gem_to_qxl_bo(gobj) container_of((gobj), struct qxl_bo, gem_base)
@@ -191,6 +185,8 @@ enum {
  * spice-protocol/qxl_dev.h */
 #define QXL_MAX_RES 96
 struct qxl_release {
+	struct fence base;
+
 	int id;
 	int type;
 	uint32_t release_offset;
@@ -284,7 +280,11 @@ struct qxl_device {
 	uint8_t		slot_gen_bits;
 	uint64_t	va_slot_mask;
 
+	/* XXX: when rcu becomes available, release_lock can be killed */
+	spinlock_t	release_lock;
+	spinlock_t	fence_lock;
 	struct idr	release_idr;
+	uint32_t	release_seqno;
 	spinlock_t release_idr_lock;
 	struct mutex	async_io_mutex;
 	unsigned int last_sent_io_cmd;
@@ -561,10 +561,4 @@ qxl_surface_lookup(struct drm_device *dev, int surface_id);
 void qxl_surface_evict(struct qxl_device *qdev, struct qxl_bo *surf, bool freeing);
 int qxl_update_surface(struct qxl_device *qdev, struct qxl_bo *surf);
 
-/* qxl_fence.c */
-void qxl_fence_add_release_locked(struct qxl_fence *qfence, uint32_t rel_id);
-int qxl_fence_remove_release(struct qxl_fence *qfence, uint32_t rel_id);
-int qxl_fence_init(struct qxl_device *qdev, struct qxl_fence *qfence);
-void qxl_fence_fini(struct qxl_fence *qfence);
-
 #endif

commit f1217ed09f827e42a49ffa6a5aab672aa6f57a65
Author: Christian König <christian.koenig@amd.com>
Date:   Wed Aug 27 13:16:04 2014 +0200

    drm/ttm: move fpfn and lpfn into each placement v2
    
    This allows us to more fine grained specify where to place the buffer object.
    
    v2: rebased on drm-next, add bochs changes as well
    
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 36ed40ba773f..f6022b703645 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -106,7 +106,7 @@ struct qxl_bo {
 	/* Protected by gem.mutex */
 	struct list_head		list;
 	/* Protected by tbo.reserved */
-	u32				placements[3];
+	struct ttm_place		placements[3];
 	struct ttm_placement		placement;
 	struct ttm_buffer_object	tbo;
 	struct ttm_bo_kmap_obj		kmap;

commit e9f0d76f3bcd4dda7136baaaaf45bda3b13ff40f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Dec 11 11:34:42 2013 +0100

    drm: Kill DRM_IRQ_ARGS
    
    I've killed them a long time ago in drm/i915, let's get rid of this
    remnant of shared drm core days for good.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 7bda32f68d3b..36ed40ba773f 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -534,7 +534,7 @@ void qxl_debugfs_takedown(struct drm_minor *minor);
 
 /* qxl_irq.c */
 int qxl_irq_init(struct qxl_device *qdev);
-irqreturn_t qxl_irq_handler(DRM_IRQ_ARGS);
+irqreturn_t qxl_irq_handler(int irq, void *arg);
 
 /* qxl_fb.c */
 int qxl_fb_init(struct qxl_device *qdev);

commit 4695b03970df378dcb93fe3e7158381f1e980fa2
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Oct 11 11:05:00 2013 +1000

    qxl: add a connector property to denote hotplug should rescan modes.
    
    So GNOME userspace has an issue with when it rescans for modes on hotplug
    events, if the monitor has no EDID it assumes that nothing has changed on
    EDID as with real hw we'd never have new modes without a new EDID, and they
    kind off rely on the behaviour now, however with virtual GPUs we would
    like to rescan the modes and get a new preferred mode on hotplug events
    to handle dynamic guest resizing (where you resize the host window and the
    guest resizes with it).
    
    This is a simple property we can make userspace watch for to trigger new
    behaviour based on it, and can be used to replaced EDID hacks in virtual
    drivers.
    
    Acked-by: Marc-André Lureau <marcandre.lureau@gmail.com> (on irc)
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 41d22ed26060..7bda32f68d3b 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -323,6 +323,8 @@ struct qxl_device {
 	struct work_struct gc_work;
 
 	struct work_struct fb_work;
+
+	struct drm_property *hotplug_mode_update_property;
 };
 
 /* forward declaration for QXL_INFO_IO */

commit 16eb5f4379b2097438a224381be3b4d9e56ac979
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Wed Oct 2 10:15:18 2013 +0200

    drm: kill ->gem_init_object() and friends
    
    All drivers embed gem-objects into their own buffer objects. There is no
    reason to keep drm_gem_object_alloc(), gem->driver_private and
    ->gem_init_object() anymore.
    
    New drivers are highly encouraged to do the same. There is no benefit in
    allocating gem-objects separately.
    
    Cc: Dave Airlie <airlied@gmail.com>
    Cc: Alex Deucher <alexdeucher@gmail.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Ben Skeggs <skeggsb@gmail.com>
    Cc: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index f7c9adde46a0..41d22ed26060 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -412,7 +412,6 @@ int qxl_gem_object_create_with_handle(struct qxl_device *qdev,
 				      struct qxl_surface *surf,
 				      struct qxl_bo **qobj,
 				      uint32_t *handle);
-int qxl_gem_object_init(struct drm_gem_object *obj);
 void qxl_gem_object_free(struct drm_gem_object *gobj);
 int qxl_gem_object_open(struct drm_gem_object *obj, struct drm_file *file_priv);
 void qxl_gem_object_close(struct drm_gem_object *obj,

commit f547b22aaf4f429089b3d5a987b94a2bd8c92eb1
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Wed Aug 14 15:07:17 2013 +0200

    drm/qxl: remove unused object_pin/unpin() helpers
    
    These two helpers are unused. Remove them. They rely on
    gem_obj->driver_private, which is set to NULL during setup. As this field
    isn't used by the driver, anymore, we can remove this assignment as well.
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 4708621fe720..f7c9adde46a0 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -405,9 +405,6 @@ int qxl_gem_object_create(struct qxl_device *qdev, int size,
 			  bool discardable, bool kernel,
 			  struct qxl_surface *surf,
 			  struct drm_gem_object **obj);
-int qxl_gem_object_pin(struct drm_gem_object *obj, uint32_t pin_domain,
-			  uint64_t *gpu_addr);
-void qxl_gem_object_unpin(struct drm_gem_object *obj);
 int qxl_gem_object_create_with_handle(struct qxl_device *qdev,
 				      struct drm_file *file_priv,
 				      u32 domain,

commit 1dda8d02acbba80444a98e71d9d419232c109e94
Merge: a97671886787 b43bd9256869
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Aug 19 09:24:13 2013 +1000

    Merge remote-tracking branch 'pfdo/drm-rcar-for-v3.12' into drm-next
    
    Merge the rcar stable branch that is being shared with the arm-soc tree.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    * pfdo/drm-rcar-for-v3.12: (220 commits)
      drm/rcar-du: Add FBDEV emulation support
      drm/rcar-du: Add internal LVDS encoder support
      drm/rcar-du: Configure RGB output routing to DPAD0
      drm/rcar-du: Rework output routing support
      drm/rcar-du: Add support for DEFR8 register
      drm/rcar-du: Add support for multiple groups
      drm/rcar-du: Fix buffer pitch alignment for R8A7790 DU
      drm/rcar-du: Add support for the R8A7790 DU
      drm/rcar-du: Move output routing configuration to group
      drm/rcar-du: Remove register definitions for the second channel
      drm/rcar-du: Use dynamic number of CRTCs instead of CRTCs array size
      drm/rcar-du: Introduce CRTCs groups
      drm/rcar-du: Rename rcar_du_plane_(init|register) to rcar_du_planes_*
      drm/rcar-du: Create rcar_du_planes structure
      drm/rcar-du: Rename platform data fields to match what they describe
      drm/rcar-du: Merge LVDS and VGA encoder code
      drm/rcar-du: Split VGA encoder and connector
      drm/rcar-du: Split LVDS encoder and connector
      drm/rcar-du: Clarify comment regarding plane Y source coordinate
      drm/rcar-du: Support per-CRTC clock and IRQ
      ...
    
    Conflicts:
            drivers/gpu/drm/i915/i915_dma.c
            drivers/gpu/drm/i915/intel_pm.c
            drivers/gpu/drm/qxl/qxl_release.c

commit baa7094355a10b432bbccacb925da4bdac861c8d
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Aug 2 13:27:49 2013 -0400

    drm: const'ify ioctls table (v2)
    
    Because, there is no reason for it not to be const.
    
    v1: original
    v2: fix compile break in vmwgfx, and couple related cleanups suggested
        by Ville Syrjälä
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 57cb7a8e6fb5..afd09d48d72c 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -319,7 +319,7 @@ struct qxl_device {
 /* forward declaration for QXL_INFO_IO */
 void qxl_io_log(struct qxl_device *qdev, const char *fmt, ...);
 
-extern struct drm_ioctl_desc qxl_ioctls[];
+extern const struct drm_ioctl_desc qxl_ioctls[];
 extern int qxl_max_ioctl;
 
 int qxl_driver_load(struct drm_device *dev, unsigned long flags);

commit 43387b37fa2d0f368142b8fa8c9440da92e5381b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 16 09:12:04 2013 +0200

    drm/gem: create drm_gem_dumb_destroy
    
    All the gem based kms drivers really want the same function to
    destroy a dumb framebuffer backing storage object.
    
    So give it to them and roll it out in all drivers.
    
    This still leaves the option open for kms drivers which don't use GEM
    for backing storage, but it does decently simplify matters for gem
    drivers.
    
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Intel Graphics Development <intel-gfx@lists.freedesktop.org>
    Cc: Ben Skeggs <skeggsb@gmail.com>
    Reviwed-by: Rob Clark <robdclark@gmail.com>
    Cc: Alex Deucher <alexdeucher@gmail.com>
    Acked-by: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index aacb791464a3..57cb7a8e6fb5 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -418,9 +418,6 @@ int qxl_bo_kmap(struct qxl_bo *bo, void **ptr);
 int qxl_mode_dumb_create(struct drm_file *file_priv,
 			 struct drm_device *dev,
 			 struct drm_mode_create_dumb *args);
-int qxl_mode_dumb_destroy(struct drm_file *file_priv,
-			  struct drm_device *dev,
-			  uint32_t handle);
 int qxl_mode_dumb_mmap(struct drm_file *filp,
 		       struct drm_device *dev,
 		       uint32_t handle, uint64_t *offset_p);

commit 8002db6336dd361fc13214e9515fe5d52ff294ee
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Jul 23 14:16:42 2013 +1000

    qxl: convert qxl driver to proper use for reservations
    
    The recent addition of lockdep support to reservations and their subsequent
    use by TTM showed up a number of potential problems with the way qxl was using
    TTM objects.
    
    a) it was allocating objects, and reserving them later without validating
    underneath the reservation, which meant in extreme conditions the objects could
    be evicted before the reservation ever used them.
    
    b) it was reserving objects straight after allocating them, but with no
    ability to back off should the reservations fail. It now allocates the necessary
    objects then does a complete reservation pass on them to avoid deadlocks.
    
    c) it had two lists per release tracking objects, unnecessary complicating
    the reservation process.
    
    This patch removes the dual object tracking, adds reservations ticket support
    to the release and fence object handling. It then ports the internal fb
    drawing code and the userspace facing ioctl to use the new interfaces properly,
    along with cleanup up the error path handling in some codepaths.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 6a4106fb4c21..7e96f4f11738 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -42,6 +42,9 @@
 #include <ttm/ttm_placement.h>
 #include <ttm/ttm_module.h>
 
+/* just for ttm_validate_buffer */
+#include <ttm/ttm_execbuf_util.h>
+
 #include <drm/qxl_drm.h>
 #include "qxl_dev.h"
 
@@ -118,9 +121,9 @@ struct qxl_bo {
 	uint32_t surface_id;
 	struct qxl_fence fence; /* per bo fence  - list of releases */
 	struct qxl_release *surf_create;
-	atomic_t reserve_count;
 };
 #define gem_to_qxl_bo(gobj) container_of((gobj), struct qxl_bo, gem_base)
+#define to_qxl_bo(tobj) container_of((tobj), struct qxl_bo, tbo)
 
 struct qxl_gem {
 	struct mutex		mutex;
@@ -128,12 +131,7 @@ struct qxl_gem {
 };
 
 struct qxl_bo_list {
-	struct list_head lhead;
-	struct qxl_bo *bo;
-};
-
-struct qxl_reloc_list {
-	struct list_head bos;
+	struct ttm_validate_buffer tv;
 };
 
 struct qxl_crtc {
@@ -195,10 +193,20 @@ enum {
 struct qxl_release {
 	int id;
 	int type;
-	int bo_count;
 	uint32_t release_offset;
 	uint32_t surface_release_id;
-	struct qxl_bo *bos[QXL_MAX_RES];
+	struct ww_acquire_ctx ticket;
+	struct list_head bos;
+};
+
+struct qxl_drm_chunk {
+	struct list_head head;
+	struct qxl_bo *bo;
+};
+
+struct qxl_drm_image {
+	struct qxl_bo *bo;
+	struct list_head chunk_list;
 };
 
 struct qxl_fb_image {
@@ -434,12 +442,19 @@ int qxl_mmap(struct file *filp, struct vm_area_struct *vma);
 
 /* qxl image */
 
-int qxl_image_create(struct qxl_device *qdev,
-		     struct qxl_release *release,
-		     struct qxl_bo **image_bo,
-		     const uint8_t *data,
-		     int x, int y, int width, int height,
-		     int depth, int stride);
+int qxl_image_init(struct qxl_device *qdev,
+		   struct qxl_release *release,
+		   struct qxl_drm_image *dimage,
+		   const uint8_t *data,
+		   int x, int y, int width, int height,
+		   int depth, int stride);
+int
+qxl_image_alloc_objects(struct qxl_device *qdev,
+			struct qxl_release *release,
+			struct qxl_drm_image **image_ptr,
+			int height, int stride);
+void qxl_image_free_objects(struct qxl_device *qdev, struct qxl_drm_image *dimage);
+
 void qxl_update_screen(struct qxl_device *qxl);
 
 /* qxl io operations (qxl_cmd.c) */
@@ -460,20 +475,15 @@ int qxl_ring_push(struct qxl_ring *ring, const void *new_elt, bool interruptible
 void qxl_io_flush_release(struct qxl_device *qdev);
 void qxl_io_flush_surfaces(struct qxl_device *qdev);
 
-int qxl_release_reserve(struct qxl_device *qdev,
-			struct qxl_release *release, bool no_wait);
-void qxl_release_unreserve(struct qxl_device *qdev,
-			   struct qxl_release *release);
 union qxl_release_info *qxl_release_map(struct qxl_device *qdev,
 					struct qxl_release *release);
 void qxl_release_unmap(struct qxl_device *qdev,
 		       struct qxl_release *release,
 		       union qxl_release_info *info);
-/*
- * qxl_bo_add_resource.
- *
- */
-void qxl_bo_add_resource(struct qxl_bo *main_bo, struct qxl_bo *resource);
+int qxl_release_list_add(struct qxl_release *release, struct qxl_bo *bo);
+int qxl_release_reserve_list(struct qxl_release *release, bool no_intr);
+void qxl_release_backoff_reserve_list(struct qxl_release *release);
+void qxl_release_fence_buffer_objects(struct qxl_release *release);
 
 int qxl_alloc_surface_release_reserved(struct qxl_device *qdev,
 				       enum qxl_surface_cmd_type surface_cmd_type,
@@ -482,15 +492,16 @@ int qxl_alloc_surface_release_reserved(struct qxl_device *qdev,
 int qxl_alloc_release_reserved(struct qxl_device *qdev, unsigned long size,
 			       int type, struct qxl_release **release,
 			       struct qxl_bo **rbo);
-int qxl_fence_releaseable(struct qxl_device *qdev,
-			  struct qxl_release *release);
+
 int
 qxl_push_command_ring_release(struct qxl_device *qdev, struct qxl_release *release,
 			      uint32_t type, bool interruptible);
 int
 qxl_push_cursor_ring_release(struct qxl_device *qdev, struct qxl_release *release,
 			     uint32_t type, bool interruptible);
-int qxl_alloc_bo_reserved(struct qxl_device *qdev, unsigned long size,
+int qxl_alloc_bo_reserved(struct qxl_device *qdev,
+			  struct qxl_release *release,
+			  unsigned long size,
 			  struct qxl_bo **_bo);
 /* qxl drawing commands */
 
@@ -511,15 +522,9 @@ void qxl_draw_copyarea(struct qxl_device *qdev,
 		       u32 sx, u32 sy,
 		       u32 dx, u32 dy);
 
-uint64_t
-qxl_release_alloc(struct qxl_device *qdev, int type,
-		  struct qxl_release **ret);
-
 void qxl_release_free(struct qxl_device *qdev,
 		      struct qxl_release *release);
-void qxl_release_add_res(struct qxl_device *qdev,
-			 struct qxl_release *release,
-			 struct qxl_bo *bo);
+
 /* used by qxl_debugfs_release */
 struct qxl_release *qxl_release_from_id_locked(struct qxl_device *qdev,
 						   uint64_t id);
@@ -562,7 +567,7 @@ void qxl_surface_evict(struct qxl_device *qdev, struct qxl_bo *surf, bool freein
 int qxl_update_surface(struct qxl_device *qdev, struct qxl_bo *surf);
 
 /* qxl_fence.c */
-int qxl_fence_add_release(struct qxl_fence *qfence, uint32_t rel_id);
+void qxl_fence_add_release_locked(struct qxl_fence *qfence, uint32_t rel_id);
 int qxl_fence_remove_release(struct qxl_fence *qfence, uint32_t rel_id);
 int qxl_fence_init(struct qxl_device *qdev, struct qxl_fence *qfence);
 void qxl_fence_fini(struct qxl_fence *qfence);

commit 0665f9f852b4ac05f2f62046a169f0f5b9212317
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Jul 22 14:37:39 2013 +1000

    drm/qxl: add delayed fb operations
    
    Due to the nature of qxl hw we cannot queue operations while in an irq
    context, so we queue these operations as best we can until atomic allocations
    fail, and dequeue them later in a work queue.
    
    Daniel looked over the locking on the list and agrees it should be sufficent.
    
    The atomic allocs use no warn, as the last thing we want if we haven't memory
    to allocate space for a printk in an irq context is more printks.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index aacb791464a3..6a4106fb4c21 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -314,6 +314,7 @@ struct qxl_device {
 	struct workqueue_struct *gc_queue;
 	struct work_struct gc_work;
 
+	struct work_struct fb_work;
 };
 
 /* forward declaration for QXL_INFO_IO */

commit d84300bf793471cc20c7553601c45d6f70dd2b1e
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jul 4 15:02:33 2013 +1000

    qxl: add suspend/resume/hibernate support.
    
    This adds suspend/resume and hibernate support for the KMS driver. it evicts
    all the objects, turns off the outputs, and waits for the hw to go idle,
    
    On resume, it resets the memslots, rings, monitors object and forces modeset.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 70a67862673a..aacb791464a3 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -333,6 +333,7 @@ void qxl_bo_fini(struct qxl_device *qdev);
 
 void qxl_reinit_memslots(struct qxl_device *qdev);
 int qxl_surf_evict(struct qxl_device *qdev);
+int qxl_vram_evict(struct qxl_device *qdev);
 
 struct qxl_ring *qxl_ring_create(struct qxl_ring_header *header,
 				 int element_size,

commit b86487a6b671ff7107fbf6d3ff10c2da970cd1c3
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jul 4 14:59:34 2013 +1000

    qxl: add fb and ttm entry points for use by suspend/resume.
    
    This just ports some APIs like radeon uses to provide hooks for s/r to
    call.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index aec9f1f9c814..70a67862673a 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -332,6 +332,7 @@ int qxl_bo_init(struct qxl_device *qdev);
 void qxl_bo_fini(struct qxl_device *qdev);
 
 void qxl_reinit_memslots(struct qxl_device *qdev);
+int qxl_surf_evict(struct qxl_device *qdev);
 
 struct qxl_ring *qxl_ring_create(struct qxl_ring_header *header,
 				 int element_size,
@@ -369,6 +370,7 @@ void qxl_fbdev_fini(struct qxl_device *qdev);
 int qxl_get_handle_for_primary_fb(struct qxl_device *qdev,
 				  struct drm_file *file_priv,
 				  uint32_t *handle);
+void qxl_fbdev_set_suspend(struct qxl_device *qdev, int state);
 
 /* qxl_display.c */
 int
@@ -534,6 +536,7 @@ irqreturn_t qxl_irq_handler(DRM_IRQ_ARGS);
 
 /* qxl_fb.c */
 int qxl_fb_init(struct qxl_device *qdev);
+bool qxl_fbdev_qobj_is_fb(struct qxl_device *qdev, struct qxl_bo *qobj);
 
 int qxl_debugfs_add_files(struct qxl_device *qdev,
 			  struct drm_info_list *files,

commit 1e209117dbe00d3d87db1c5266f177eaa60451c8
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jul 4 14:58:45 2013 +1000

    qxl: add ring prep code for s/r
    
    This prepare the ring code for s/r additions, the release ring will need
    reinitialising.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 056330e5fecf..aec9f1f9c814 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -340,6 +340,8 @@ struct qxl_ring *qxl_ring_create(struct qxl_ring_header *header,
 				 bool set_prod_notify,
 				 wait_queue_head_t *push_event);
 void qxl_ring_free(struct qxl_ring *ring);
+void qxl_ring_init_hdr(struct qxl_ring *ring);
+int qxl_check_idle(struct qxl_ring *ring);
 
 static inline void *
 qxl_fb_virtual_address(struct qxl_device *qdev, unsigned long physical)

commit c9fdda2a2b7a8875db3eebd89e428aa760afb897
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jul 4 14:57:58 2013 +1000

    qxl: prepare memslot code for suspend/resume
    
    this splits out initing the hw memslots from the guest info, and
    creates an entrypoint for s/r to use.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 6a929258fff9..056330e5fecf 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -331,6 +331,8 @@ void qxl_modeset_fini(struct qxl_device *qdev);
 int qxl_bo_init(struct qxl_device *qdev);
 void qxl_bo_fini(struct qxl_device *qdev);
 
+void qxl_reinit_memslots(struct qxl_device *qdev);
+
 struct qxl_ring *qxl_ring_create(struct qxl_ring_header *header,
 				 int element_size,
 				 int n_elements,

commit 2bd6ce84e1b4799be1f328a165d0b8a4fdfd2141
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jul 4 14:46:46 2013 +1000

    qxl: split monitors_config object creation out.
    
    This splits the creation of the monitors config object out so we can
    re-use it across suspend/resume later.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 42ef0e2b5094..6a929258fff9 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -374,6 +374,8 @@ qxl_framebuffer_init(struct drm_device *dev,
 		     struct drm_gem_object *obj);
 void qxl_display_read_client_monitors_config(struct qxl_device *qdev);
 void qxl_send_monitors_config(struct qxl_device *qdev);
+int qxl_create_monitors_object(struct qxl_device *qdev);
+int qxl_destroy_monitors_object(struct qxl_device *qdev);
 
 /* used by qxl_debugfs only */
 void qxl_crtc_set_from_monitors_config(struct qxl_device *qdev);

commit 07f8d9bdb235836d0a255d20f387bc3afa99180f
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Jul 2 06:37:13 2013 +0100

    drm/qxl: add support for > 1 output
    
    This adds support for a default of 4 heads, with a command line
    parameter to change the default number.
    
    It also overhauls the modesetting code to handle this case properly,
    and send the correct things to the hardware at the right time.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 43d06ab28a21..42ef0e2b5094 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -55,11 +55,10 @@
 #define DRIVER_MINOR 1
 #define DRIVER_PATCHLEVEL 0
 
-#define QXL_NUM_OUTPUTS 1
-
 #define QXL_DEBUGFS_MAX_COMPONENTS		32
 
 extern int qxl_log_level;
+extern int qxl_num_crtc;
 
 enum {
 	QXL_INFO_LEVEL = 1,
@@ -139,6 +138,7 @@ struct qxl_reloc_list {
 
 struct qxl_crtc {
 	struct drm_crtc base;
+	int index;
 	int cur_x;
 	int cur_y;
 };
@@ -156,7 +156,7 @@ struct qxl_framebuffer {
 
 #define to_qxl_crtc(x) container_of(x, struct qxl_crtc, base)
 #define drm_connector_to_qxl_output(x) container_of(x, struct qxl_output, base)
-#define drm_encoder_to_qxl_output(x) container_of(x, struct qxl_output, base)
+#define drm_encoder_to_qxl_output(x) container_of(x, struct qxl_output, enc)
 #define to_qxl_framebuffer(x) container_of(x, struct qxl_framebuffer, base)
 
 struct qxl_mman {
@@ -435,7 +435,7 @@ void qxl_update_screen(struct qxl_device *qxl);
 /* qxl io operations (qxl_cmd.c) */
 
 void qxl_io_create_primary(struct qxl_device *qdev,
-			   unsigned width, unsigned height, unsigned offset,
+			   unsigned offset,
 			   struct qxl_bo *bo);
 void qxl_io_destroy_primary(struct qxl_device *qdev);
 void qxl_io_memslot_add(struct qxl_device *qdev, uint8_t id);

commit b2b4465d8bade681491e225fa6a5dc050820b004
Author: Dave Airlie <airlied@gmail.com>
Date:   Mon May 13 12:48:40 2013 +1000

    drm/qxl: drop active_user_framebuffer as its unneeded
    
    This was a bogus way to figure out what the active framebuffer was,
    just check if the underlying bo is the primary bo.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 5b7c130f4744..43d06ab28a21 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -255,12 +255,6 @@ struct qxl_device {
 	struct qxl_gem		gem;
 	struct qxl_mode_info mode_info;
 
-	/*
-	 * last created framebuffer with fb_create
-	 * only used by debugfs dumbppm
-	 */
-	struct qxl_framebuffer *active_user_framebuffer;
-
 	struct fb_info			*fbdev_info;
 	struct qxl_framebuffer	*fbdev_qfb;
 	void *ram_physical;

commit d7292a07a1b3d0b31a54a3e949ed4dd99e9a85e8
Author: Dave Airlie <airlied@gmail.com>
Date:   Mon May 13 12:42:26 2013 +1000

    qxl: drop unused variable.
    
    this boolean isn't used anymore so drop it.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 52b582c211da..5b7c130f4744 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -270,7 +270,6 @@ struct qxl_device {
 	struct qxl_ring *cursor_ring;
 
 	struct qxl_ram_header *ram_header;
-	bool mode_set;
 
 	bool primary_created;
 

commit f64122c1f6ade301585569863b4b3b18f6e4e332
Author: Dave Airlie <airlied@gmail.com>
Date:   Mon Feb 25 14:47:55 2013 +1000

    drm: add new QXL driver. (v1.4)
    
    QXL is a paravirtual graphics device used by the Spice virtual desktop
    interface.
    
    The drivers uses GEM and TTM to manage memory, the qxl hw fencing however
    is quite different than normal TTM expects, we have to keep track of a number
    of non-linear fence ids per bo that we need to have released by the hardware.
    
    The releases are freed from a workqueue that wakes up and processes the
    release ring.
    
    releases are suballocated from a BO, there are 3 release categories, drawables,
    surfaces and cursor cmds. The hw also has 3 rings for commands, cursor and release handling.
    
    The hardware also have a surface id tracking mechnaism and the driver encapsulates it completely inside the kernel, userspace never sees the actual hw surface
    ids.
    
    This requires a newer version of the QXL userspace driver, so shouldn't be
    enabled until that has been placed into your distro of choice.
    
    Authors: Dave Airlie, Alon Levy
    
    v1.1: fixup some issues in the ioctl interface with padding
    v1.2: add module device table
    v1.3: fix nomodeset, fbcon leak, dumb bo create, release ring irq,
          don't try flush release ring (broken hw), fix -modesetting.
    v1.4: fbcon cpu usage reduction + suitable accel flags.
    
    Signed-off-by: Alon Levy <alevy@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
new file mode 100644
index 000000000000..52b582c211da
--- /dev/null
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -0,0 +1,566 @@
+/*
+ * Copyright 2013 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Dave Airlie
+ *          Alon Levy
+ */
+
+
+#ifndef QXL_DRV_H
+#define QXL_DRV_H
+
+/*
+ * Definitions taken from spice-protocol, plus kernel driver specific bits.
+ */
+
+#include <linux/workqueue.h>
+#include <linux/firmware.h>
+#include <linux/platform_device.h>
+
+#include "drmP.h"
+#include "drm_crtc.h"
+#include <ttm/ttm_bo_api.h>
+#include <ttm/ttm_bo_driver.h>
+#include <ttm/ttm_placement.h>
+#include <ttm/ttm_module.h>
+
+#include <drm/qxl_drm.h>
+#include "qxl_dev.h"
+
+#define DRIVER_AUTHOR		"Dave Airlie"
+
+#define DRIVER_NAME		"qxl"
+#define DRIVER_DESC		"RH QXL"
+#define DRIVER_DATE		"20120117"
+
+#define DRIVER_MAJOR 0
+#define DRIVER_MINOR 1
+#define DRIVER_PATCHLEVEL 0
+
+#define QXL_NUM_OUTPUTS 1
+
+#define QXL_DEBUGFS_MAX_COMPONENTS		32
+
+extern int qxl_log_level;
+
+enum {
+	QXL_INFO_LEVEL = 1,
+	QXL_DEBUG_LEVEL = 2,
+};
+
+#define QXL_INFO(qdev, fmt, ...) do { \
+		if (qxl_log_level >= QXL_INFO_LEVEL) {	\
+			qxl_io_log(qdev, fmt, __VA_ARGS__); \
+		}	\
+	} while (0)
+#define QXL_DEBUG(qdev, fmt, ...) do { \
+		if (qxl_log_level >= QXL_DEBUG_LEVEL) {	\
+			qxl_io_log(qdev, fmt, __VA_ARGS__); \
+		}	\
+	} while (0)
+#define QXL_INFO_ONCE(qdev, fmt, ...) do { \
+		static int done;		\
+		if (!done) {			\
+			done = 1;			\
+			QXL_INFO(qdev, fmt, __VA_ARGS__);	\
+		}						\
+	} while (0)
+
+#define DRM_FILE_OFFSET 0x100000000ULL
+#define DRM_FILE_PAGE_OFFSET (DRM_FILE_OFFSET >> PAGE_SHIFT)
+
+#define QXL_INTERRUPT_MASK (\
+	QXL_INTERRUPT_DISPLAY |\
+	QXL_INTERRUPT_CURSOR |\
+	QXL_INTERRUPT_IO_CMD |\
+	QXL_INTERRUPT_CLIENT_MONITORS_CONFIG)
+
+struct qxl_fence {
+	struct qxl_device *qdev;
+	uint32_t num_active_releases;
+	uint32_t *release_ids;
+	struct radix_tree_root tree;
+};
+
+struct qxl_bo {
+	/* Protected by gem.mutex */
+	struct list_head		list;
+	/* Protected by tbo.reserved */
+	u32				placements[3];
+	struct ttm_placement		placement;
+	struct ttm_buffer_object	tbo;
+	struct ttm_bo_kmap_obj		kmap;
+	unsigned			pin_count;
+	void				*kptr;
+	int                             type;
+	/* Constant after initialization */
+	struct drm_gem_object		gem_base;
+	bool is_primary; /* is this now a primary surface */
+	bool hw_surf_alloc;
+	struct qxl_surface surf;
+	uint32_t surface_id;
+	struct qxl_fence fence; /* per bo fence  - list of releases */
+	struct qxl_release *surf_create;
+	atomic_t reserve_count;
+};
+#define gem_to_qxl_bo(gobj) container_of((gobj), struct qxl_bo, gem_base)
+
+struct qxl_gem {
+	struct mutex		mutex;
+	struct list_head	objects;
+};
+
+struct qxl_bo_list {
+	struct list_head lhead;
+	struct qxl_bo *bo;
+};
+
+struct qxl_reloc_list {
+	struct list_head bos;
+};
+
+struct qxl_crtc {
+	struct drm_crtc base;
+	int cur_x;
+	int cur_y;
+};
+
+struct qxl_output {
+	int index;
+	struct drm_connector base;
+	struct drm_encoder enc;
+};
+
+struct qxl_framebuffer {
+	struct drm_framebuffer base;
+	struct drm_gem_object *obj;
+};
+
+#define to_qxl_crtc(x) container_of(x, struct qxl_crtc, base)
+#define drm_connector_to_qxl_output(x) container_of(x, struct qxl_output, base)
+#define drm_encoder_to_qxl_output(x) container_of(x, struct qxl_output, base)
+#define to_qxl_framebuffer(x) container_of(x, struct qxl_framebuffer, base)
+
+struct qxl_mman {
+	struct ttm_bo_global_ref        bo_global_ref;
+	struct drm_global_reference	mem_global_ref;
+	bool				mem_global_referenced;
+	struct ttm_bo_device		bdev;
+};
+
+struct qxl_mode_info {
+	int num_modes;
+	struct qxl_mode *modes;
+	bool mode_config_initialized;
+
+	/* pointer to fbdev info structure */
+	struct qxl_fbdev *qfbdev;
+};
+
+
+struct qxl_memslot {
+	uint8_t		generation;
+	uint64_t	start_phys_addr;
+	uint64_t	end_phys_addr;
+	uint64_t	high_bits;
+};
+
+enum {
+	QXL_RELEASE_DRAWABLE,
+	QXL_RELEASE_SURFACE_CMD,
+	QXL_RELEASE_CURSOR_CMD,
+};
+
+/* drm_ prefix to differentiate from qxl_release_info in
+ * spice-protocol/qxl_dev.h */
+#define QXL_MAX_RES 96
+struct qxl_release {
+	int id;
+	int type;
+	int bo_count;
+	uint32_t release_offset;
+	uint32_t surface_release_id;
+	struct qxl_bo *bos[QXL_MAX_RES];
+};
+
+struct qxl_fb_image {
+	struct qxl_device *qdev;
+	uint32_t pseudo_palette[16];
+	struct fb_image fb_image;
+	uint32_t visual;
+};
+
+struct qxl_draw_fill {
+	struct qxl_device *qdev;
+	struct qxl_rect rect;
+	uint32_t color;
+	uint16_t rop;
+};
+
+/*
+ * Debugfs
+ */
+struct qxl_debugfs {
+	struct drm_info_list	*files;
+	unsigned		num_files;
+};
+
+int qxl_debugfs_add_files(struct qxl_device *rdev,
+			     struct drm_info_list *files,
+			     unsigned nfiles);
+int qxl_debugfs_fence_init(struct qxl_device *rdev);
+void qxl_debugfs_remove_files(struct qxl_device *qdev);
+
+struct qxl_device;
+
+struct qxl_device {
+	struct device			*dev;
+	struct drm_device		*ddev;
+	struct pci_dev			*pdev;
+	unsigned long flags;
+
+	resource_size_t vram_base, vram_size;
+	resource_size_t surfaceram_base, surfaceram_size;
+	resource_size_t rom_base, rom_size;
+	struct qxl_rom *rom;
+
+	struct qxl_mode *modes;
+	struct qxl_bo *monitors_config_bo;
+	struct qxl_monitors_config *monitors_config;
+
+	/* last received client_monitors_config */
+	struct qxl_monitors_config *client_monitors_config;
+
+	int io_base;
+	void *ram;
+	struct qxl_mman		mman;
+	struct qxl_gem		gem;
+	struct qxl_mode_info mode_info;
+
+	/*
+	 * last created framebuffer with fb_create
+	 * only used by debugfs dumbppm
+	 */
+	struct qxl_framebuffer *active_user_framebuffer;
+
+	struct fb_info			*fbdev_info;
+	struct qxl_framebuffer	*fbdev_qfb;
+	void *ram_physical;
+
+	struct qxl_ring *release_ring;
+	struct qxl_ring *command_ring;
+	struct qxl_ring *cursor_ring;
+
+	struct qxl_ram_header *ram_header;
+	bool mode_set;
+
+	bool primary_created;
+
+	struct qxl_memslot	*mem_slots;
+	uint8_t		n_mem_slots;
+
+	uint8_t		main_mem_slot;
+	uint8_t		surfaces_mem_slot;
+	uint8_t		slot_id_bits;
+	uint8_t		slot_gen_bits;
+	uint64_t	va_slot_mask;
+
+	struct idr	release_idr;
+	spinlock_t release_idr_lock;
+	struct mutex	async_io_mutex;
+	unsigned int last_sent_io_cmd;
+
+	/* interrupt handling */
+	atomic_t irq_received;
+	atomic_t irq_received_display;
+	atomic_t irq_received_cursor;
+	atomic_t irq_received_io_cmd;
+	unsigned irq_received_error;
+	wait_queue_head_t display_event;
+	wait_queue_head_t cursor_event;
+	wait_queue_head_t io_cmd_event;
+	struct work_struct client_monitors_config_work;
+
+	/* debugfs */
+	struct qxl_debugfs	debugfs[QXL_DEBUGFS_MAX_COMPONENTS];
+	unsigned		debugfs_count;
+
+	struct mutex		update_area_mutex;
+
+	struct idr	surf_id_idr;
+	spinlock_t surf_id_idr_lock;
+	int last_alloced_surf_id;
+
+	struct mutex surf_evict_mutex;
+	struct io_mapping *vram_mapping;
+	struct io_mapping *surface_mapping;
+
+	/* */
+	struct mutex release_mutex;
+	struct qxl_bo *current_release_bo[3];
+	int current_release_bo_offset[3];
+
+	struct workqueue_struct *gc_queue;
+	struct work_struct gc_work;
+
+};
+
+/* forward declaration for QXL_INFO_IO */
+void qxl_io_log(struct qxl_device *qdev, const char *fmt, ...);
+
+extern struct drm_ioctl_desc qxl_ioctls[];
+extern int qxl_max_ioctl;
+
+int qxl_driver_load(struct drm_device *dev, unsigned long flags);
+int qxl_driver_unload(struct drm_device *dev);
+
+int qxl_modeset_init(struct qxl_device *qdev);
+void qxl_modeset_fini(struct qxl_device *qdev);
+
+int qxl_bo_init(struct qxl_device *qdev);
+void qxl_bo_fini(struct qxl_device *qdev);
+
+struct qxl_ring *qxl_ring_create(struct qxl_ring_header *header,
+				 int element_size,
+				 int n_elements,
+				 int prod_notify,
+				 bool set_prod_notify,
+				 wait_queue_head_t *push_event);
+void qxl_ring_free(struct qxl_ring *ring);
+
+static inline void *
+qxl_fb_virtual_address(struct qxl_device *qdev, unsigned long physical)
+{
+	QXL_INFO(qdev, "not implemented (%lu)\n", physical);
+	return 0;
+}
+
+static inline uint64_t
+qxl_bo_physical_address(struct qxl_device *qdev, struct qxl_bo *bo,
+			unsigned long offset)
+{
+	int slot_id = bo->type == QXL_GEM_DOMAIN_VRAM ? qdev->main_mem_slot : qdev->surfaces_mem_slot;
+	struct qxl_memslot *slot = &(qdev->mem_slots[slot_id]);
+
+	/* TODO - need to hold one of the locks to read tbo.offset */
+	return slot->high_bits | (bo->tbo.offset + offset);
+}
+
+/* qxl_fb.c */
+#define QXLFB_CONN_LIMIT 1
+
+int qxl_fbdev_init(struct qxl_device *qdev);
+void qxl_fbdev_fini(struct qxl_device *qdev);
+int qxl_get_handle_for_primary_fb(struct qxl_device *qdev,
+				  struct drm_file *file_priv,
+				  uint32_t *handle);
+
+/* qxl_display.c */
+int
+qxl_framebuffer_init(struct drm_device *dev,
+		     struct qxl_framebuffer *rfb,
+		     struct drm_mode_fb_cmd2 *mode_cmd,
+		     struct drm_gem_object *obj);
+void qxl_display_read_client_monitors_config(struct qxl_device *qdev);
+void qxl_send_monitors_config(struct qxl_device *qdev);
+
+/* used by qxl_debugfs only */
+void qxl_crtc_set_from_monitors_config(struct qxl_device *qdev);
+void qxl_alloc_client_monitors_config(struct qxl_device *qdev, unsigned count);
+
+/* qxl_gem.c */
+int qxl_gem_init(struct qxl_device *qdev);
+void qxl_gem_fini(struct qxl_device *qdev);
+int qxl_gem_object_create(struct qxl_device *qdev, int size,
+			  int alignment, int initial_domain,
+			  bool discardable, bool kernel,
+			  struct qxl_surface *surf,
+			  struct drm_gem_object **obj);
+int qxl_gem_object_pin(struct drm_gem_object *obj, uint32_t pin_domain,
+			  uint64_t *gpu_addr);
+void qxl_gem_object_unpin(struct drm_gem_object *obj);
+int qxl_gem_object_create_with_handle(struct qxl_device *qdev,
+				      struct drm_file *file_priv,
+				      u32 domain,
+				      size_t size,
+				      struct qxl_surface *surf,
+				      struct qxl_bo **qobj,
+				      uint32_t *handle);
+int qxl_gem_object_init(struct drm_gem_object *obj);
+void qxl_gem_object_free(struct drm_gem_object *gobj);
+int qxl_gem_object_open(struct drm_gem_object *obj, struct drm_file *file_priv);
+void qxl_gem_object_close(struct drm_gem_object *obj,
+			  struct drm_file *file_priv);
+void qxl_bo_force_delete(struct qxl_device *qdev);
+int qxl_bo_kmap(struct qxl_bo *bo, void **ptr);
+
+/* qxl_dumb.c */
+int qxl_mode_dumb_create(struct drm_file *file_priv,
+			 struct drm_device *dev,
+			 struct drm_mode_create_dumb *args);
+int qxl_mode_dumb_destroy(struct drm_file *file_priv,
+			  struct drm_device *dev,
+			  uint32_t handle);
+int qxl_mode_dumb_mmap(struct drm_file *filp,
+		       struct drm_device *dev,
+		       uint32_t handle, uint64_t *offset_p);
+
+
+/* qxl ttm */
+int qxl_ttm_init(struct qxl_device *qdev);
+void qxl_ttm_fini(struct qxl_device *qdev);
+int qxl_mmap(struct file *filp, struct vm_area_struct *vma);
+
+/* qxl image */
+
+int qxl_image_create(struct qxl_device *qdev,
+		     struct qxl_release *release,
+		     struct qxl_bo **image_bo,
+		     const uint8_t *data,
+		     int x, int y, int width, int height,
+		     int depth, int stride);
+void qxl_update_screen(struct qxl_device *qxl);
+
+/* qxl io operations (qxl_cmd.c) */
+
+void qxl_io_create_primary(struct qxl_device *qdev,
+			   unsigned width, unsigned height, unsigned offset,
+			   struct qxl_bo *bo);
+void qxl_io_destroy_primary(struct qxl_device *qdev);
+void qxl_io_memslot_add(struct qxl_device *qdev, uint8_t id);
+void qxl_io_notify_oom(struct qxl_device *qdev);
+
+int qxl_io_update_area(struct qxl_device *qdev, struct qxl_bo *surf,
+		       const struct qxl_rect *area);
+
+void qxl_io_reset(struct qxl_device *qdev);
+void qxl_io_monitors_config(struct qxl_device *qdev);
+int qxl_ring_push(struct qxl_ring *ring, const void *new_elt, bool interruptible);
+void qxl_io_flush_release(struct qxl_device *qdev);
+void qxl_io_flush_surfaces(struct qxl_device *qdev);
+
+int qxl_release_reserve(struct qxl_device *qdev,
+			struct qxl_release *release, bool no_wait);
+void qxl_release_unreserve(struct qxl_device *qdev,
+			   struct qxl_release *release);
+union qxl_release_info *qxl_release_map(struct qxl_device *qdev,
+					struct qxl_release *release);
+void qxl_release_unmap(struct qxl_device *qdev,
+		       struct qxl_release *release,
+		       union qxl_release_info *info);
+/*
+ * qxl_bo_add_resource.
+ *
+ */
+void qxl_bo_add_resource(struct qxl_bo *main_bo, struct qxl_bo *resource);
+
+int qxl_alloc_surface_release_reserved(struct qxl_device *qdev,
+				       enum qxl_surface_cmd_type surface_cmd_type,
+				       struct qxl_release *create_rel,
+				       struct qxl_release **release);
+int qxl_alloc_release_reserved(struct qxl_device *qdev, unsigned long size,
+			       int type, struct qxl_release **release,
+			       struct qxl_bo **rbo);
+int qxl_fence_releaseable(struct qxl_device *qdev,
+			  struct qxl_release *release);
+int
+qxl_push_command_ring_release(struct qxl_device *qdev, struct qxl_release *release,
+			      uint32_t type, bool interruptible);
+int
+qxl_push_cursor_ring_release(struct qxl_device *qdev, struct qxl_release *release,
+			     uint32_t type, bool interruptible);
+int qxl_alloc_bo_reserved(struct qxl_device *qdev, unsigned long size,
+			  struct qxl_bo **_bo);
+/* qxl drawing commands */
+
+void qxl_draw_opaque_fb(const struct qxl_fb_image *qxl_fb_image,
+			int stride /* filled in if 0 */);
+
+void qxl_draw_dirty_fb(struct qxl_device *qdev,
+		       struct qxl_framebuffer *qxl_fb,
+		       struct qxl_bo *bo,
+		       unsigned flags, unsigned color,
+		       struct drm_clip_rect *clips,
+		       unsigned num_clips, int inc);
+
+void qxl_draw_fill(struct qxl_draw_fill *qxl_draw_fill_rec);
+
+void qxl_draw_copyarea(struct qxl_device *qdev,
+		       u32 width, u32 height,
+		       u32 sx, u32 sy,
+		       u32 dx, u32 dy);
+
+uint64_t
+qxl_release_alloc(struct qxl_device *qdev, int type,
+		  struct qxl_release **ret);
+
+void qxl_release_free(struct qxl_device *qdev,
+		      struct qxl_release *release);
+void qxl_release_add_res(struct qxl_device *qdev,
+			 struct qxl_release *release,
+			 struct qxl_bo *bo);
+/* used by qxl_debugfs_release */
+struct qxl_release *qxl_release_from_id_locked(struct qxl_device *qdev,
+						   uint64_t id);
+
+bool qxl_queue_garbage_collect(struct qxl_device *qdev, bool flush);
+int qxl_garbage_collect(struct qxl_device *qdev);
+
+/* debugfs */
+
+int qxl_debugfs_init(struct drm_minor *minor);
+void qxl_debugfs_takedown(struct drm_minor *minor);
+
+/* qxl_irq.c */
+int qxl_irq_init(struct qxl_device *qdev);
+irqreturn_t qxl_irq_handler(DRM_IRQ_ARGS);
+
+/* qxl_fb.c */
+int qxl_fb_init(struct qxl_device *qdev);
+
+int qxl_debugfs_add_files(struct qxl_device *qdev,
+			  struct drm_info_list *files,
+			  unsigned nfiles);
+
+int qxl_surface_id_alloc(struct qxl_device *qdev,
+			 struct qxl_bo *surf);
+void qxl_surface_id_dealloc(struct qxl_device *qdev,
+			    uint32_t surface_id);
+int qxl_hw_surface_alloc(struct qxl_device *qdev,
+			 struct qxl_bo *surf,
+			 struct ttm_mem_reg *mem);
+int qxl_hw_surface_dealloc(struct qxl_device *qdev,
+			   struct qxl_bo *surf);
+
+int qxl_bo_check_id(struct qxl_device *qdev, struct qxl_bo *bo);
+
+struct qxl_drv_surface *
+qxl_surface_lookup(struct drm_device *dev, int surface_id);
+void qxl_surface_evict(struct qxl_device *qdev, struct qxl_bo *surf, bool freeing);
+int qxl_update_surface(struct qxl_device *qdev, struct qxl_bo *surf);
+
+/* qxl_fence.c */
+int qxl_fence_add_release(struct qxl_fence *qfence, uint32_t rel_id);
+int qxl_fence_remove_release(struct qxl_fence *qfence, uint32_t rel_id);
+int qxl_fence_init(struct qxl_device *qdev, struct qxl_fence *qfence);
+void qxl_fence_fini(struct qxl_fence *qfence);
+
+#endif
