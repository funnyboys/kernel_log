commit d4f5a095daf0d25f0b385e1ef26338608433a4c5
Author: Navid Emamdoost <navid.emamdoost@gmail.com>
Date:   Mon Jun 15 00:49:28 2020 -0500

    drm/exynos: fix ref count leak in mic_pre_enable
    
    in mic_pre_enable, pm_runtime_get_sync is called which
    increments the counter even in case of failure, leading to incorrect
    ref count. In case of failure, decrement the ref count before returning.
    
    Signed-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index a86abc173605..3821ea76a703 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -269,8 +269,10 @@ static void mic_pre_enable(struct drm_bridge *bridge)
 		goto unlock;
 
 	ret = pm_runtime_get_sync(mic->dev);
-	if (ret < 0)
+	if (ret < 0) {
+		pm_runtime_put_noidle(mic->dev);
 		goto unlock;
+	}
 
 	mic_set_path(mic, 1);
 

commit a046e7bf4e27d77a34595778945adbd4450d803a
Author: Bernard Zhao <bernard@vivo.com>
Date:   Sun Apr 26 02:01:42 2020 -0700

    drm/exynos: make pointer to const data const type
    
    Maybe keep pointer which points to global const string data
    in const type is better, make sure not change const data.
    
    Signed-off-by: Bernard Zhao <bernard@vivo.com>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index f41d75923557..a86abc173605 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -88,7 +88,7 @@
 
 #define MIC_BS_SIZE_2D(x)	((x) & 0x3fff)
 
-static char *clk_names[] = { "pclk_mic0", "sclk_rgb_vclk_to_mic0" };
+static const char *const clk_names[] = { "pclk_mic0", "sclk_rgb_vclk_to_mic0" };
 #define NUM_CLKS		ARRAY_SIZE(clk_names)
 static DEFINE_MUTEX(mic_mutex);
 

commit ee68c743f8d0747585b4c0c171c039d6635bda7c
Author: Boris Brezillon <boris.brezillon@collabora.com>
Date:   Mon Aug 26 17:26:29 2019 +0200

    drm: Stop including drm_bridge.h from drm_crtc.h
    
    We are about to add a drm_bridge_state that inherits from
    drm_private_state which is defined in drm_atomic.h. Problem is,
    drm_atomic.h includes drm_crtc.h which in turn includes drm_bridge.h,
    leading to "drm_private_state has incomplete type" error.
    
    Let's force all users of the drm_bridge API to explicitly include
    drm_bridge.h.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190826152649.13820-2-boris.brezillon@collabora.com

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index b78e8c5ba553..f41d75923557 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -21,6 +21,7 @@
 #include <video/of_videomode.h>
 #include <video/videomode.h>
 
+#include <drm/drm_bridge.h>
 #include <drm/drm_encoder.h>
 #include <drm/drm_print.h>
 

commit 2bda34d7d9102f1ffc030256daad5f14dbc623cd
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 24 22:06:28 2019 +0900

    drm/exynos: drop drmP.h usage
    
    Drop use of the deprecated drmP.h file.
    Replace with forwards / externals as appropriate.
    
    While touching the list of include files divide
    them up in blocks and sort them.
    
    v3:
    - fix build errors in exynos_drm_g2d.c (Inki Dae)
      The exynos_drm_g2d.c file is not built in the
      standard configurations and was therefore missed.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Joonyoung Shim <jy0922.shim@samsung.com>
    Cc: Seung-Woo Kim <sw0312.kim@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: Jingoo Han <jingoohan1@gmail.com>
    Fixed merge conflict.
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index 8363cb40daed..b78e8c5ba553 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -5,23 +5,25 @@
  *	Hyungwon Hwang <human.hwang@samsung.com>
  */
 
-#include <linux/platform_device.h>
-#include <video/of_videomode.h>
-#include <linux/of_address.h>
-#include <video/videomode.h>
-#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/component.h>
 #include <linux/delay.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
 #include <linux/of_graph.h>
-#include <linux/clk.h>
-#include <linux/component.h>
+#include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
-#include <drm/drmP.h>
-#include <drm/drm_encoder.h>
-#include <linux/mfd/syscon.h>
 #include <linux/regmap.h>
 
+#include <video/of_videomode.h>
+#include <video/videomode.h>
+
+#include <drm/drm_encoder.h>
+#include <drm/drm_print.h>
+
 #include "exynos_drm_drv.h"
 
 /* Sysreg registers for MIC */

commit 9f06080f861ccd67e15228d30177614a49b039dc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:38 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 423
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundationr
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 7 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190113.913773588@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index d1c8411ae7d4..8363cb40daed 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2015 Samsung Electronics Co.Ltd
  * Authors:
  *	Hyungwon Hwang <human.hwang@samsung.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundationr
  */
 
 #include <linux/platform_device.h>

commit 6be900563a9e7420ead7de5737a004e1878ef145
Author: Inki Dae <inki.dae@samsung.com>
Date:   Mon Apr 15 16:25:12 2019 +0900

    drm/exynos: use DRM_DEV_DEBUG* instead of DRM_DEBUG macro
    
    Use DRM_DEV_DEBUG* instead of DRM_DEBUG macro to print out
    debug messages.
    
    This patch just cleans up the use of debug log macro, which changes
    the log macro to DRM_DEV_DEBUG*.
    
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index ddf5b4dfd6c3..d1c8411ae7d4 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -192,7 +192,7 @@ static void mic_set_output_timing(struct exynos_mic *mic)
 	struct videomode vm = mic->vm;
 	u32 reg, bs_size_2d;
 
-	DRM_DEBUG("w: %u, h: %u\n", vm.hactive, vm.vactive);
+	DRM_DEV_DEBUG(mic->dev, "w: %u, h: %u\n", vm.hactive, vm.vactive);
 	bs_size_2d = ((vm.hactive >> 2) << 1) + (vm.vactive % 4);
 	reg = MIC_BS_SIZE_2D(bs_size_2d);
 	writel(reg, mic->reg + MIC_2D_OUTPUT_TIMING_2);
@@ -433,7 +433,7 @@ static int exynos_mic_probe(struct platform_device *pdev)
 	if (ret)
 		goto err_pm;
 
-	DRM_DEBUG_KMS("MIC has been probed\n");
+	DRM_DEV_DEBUG_KMS(dev, "MIC has been probed\n");
 
 	return 0;
 

commit 6f83d20838c09936b2884d5b35fed8d208679947
Author: Inki Dae <inki.dae@samsung.com>
Date:   Mon Apr 15 14:24:36 2019 +0900

    drm/exynos: use DRM_DEV_ERROR to print out error message
    
    This patch just cleans up the use of error log macro, which changes
    the log macro to DRM_DEV_ERROR.
    
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index dd02e8a323ef..ddf5b4dfd6c3 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -113,7 +113,8 @@ static void mic_set_path(struct exynos_mic *mic, bool enable)
 
 	ret = regmap_read(mic->sysreg, DSD_CFG_MUX, &val);
 	if (ret) {
-		DRM_ERROR("mic: Failed to read system register\n");
+		DRM_DEV_ERROR(mic->dev,
+			      "mic: Failed to read system register\n");
 		return;
 	}
 
@@ -129,7 +130,8 @@ static void mic_set_path(struct exynos_mic *mic, bool enable)
 
 	ret = regmap_write(mic->sysreg, DSD_CFG_MUX, val);
 	if (ret)
-		DRM_ERROR("mic: Failed to read system register\n");
+		DRM_DEV_ERROR(mic->dev,
+			      "mic: Failed to read system register\n");
 }
 
 static int mic_sw_reset(struct exynos_mic *mic)
@@ -274,7 +276,7 @@ static void mic_pre_enable(struct drm_bridge *bridge)
 
 	ret = mic_sw_reset(mic);
 	if (ret) {
-		DRM_ERROR("Failed to reset\n");
+		DRM_DEV_ERROR(mic->dev, "Failed to reset\n");
 		goto turn_off;
 	}
 
@@ -354,8 +356,8 @@ static int exynos_mic_resume(struct device *dev)
 	for (i = 0; i < NUM_CLKS; i++) {
 		ret = clk_prepare_enable(mic->clks[i]);
 		if (ret < 0) {
-			DRM_ERROR("Failed to enable clock (%s)\n",
-							clk_names[i]);
+			DRM_DEV_ERROR(dev, "Failed to enable clock (%s)\n",
+				      clk_names[i]);
 			while (--i > -1)
 				clk_disable_unprepare(mic->clks[i]);
 			return ret;
@@ -380,7 +382,8 @@ static int exynos_mic_probe(struct platform_device *pdev)
 
 	mic = devm_kzalloc(dev, sizeof(*mic), GFP_KERNEL);
 	if (!mic) {
-		DRM_ERROR("mic: Failed to allocate memory for MIC object\n");
+		DRM_DEV_ERROR(dev,
+			      "mic: Failed to allocate memory for MIC object\n");
 		ret = -ENOMEM;
 		goto err;
 	}
@@ -389,12 +392,12 @@ static int exynos_mic_probe(struct platform_device *pdev)
 
 	ret = of_address_to_resource(dev->of_node, 0, &res);
 	if (ret) {
-		DRM_ERROR("mic: Failed to get mem region for MIC\n");
+		DRM_DEV_ERROR(dev, "mic: Failed to get mem region for MIC\n");
 		goto err;
 	}
 	mic->reg = devm_ioremap(dev, res.start, resource_size(&res));
 	if (!mic->reg) {
-		DRM_ERROR("mic: Failed to remap for MIC\n");
+		DRM_DEV_ERROR(dev, "mic: Failed to remap for MIC\n");
 		ret = -ENOMEM;
 		goto err;
 	}
@@ -402,7 +405,7 @@ static int exynos_mic_probe(struct platform_device *pdev)
 	mic->sysreg = syscon_regmap_lookup_by_phandle(dev->of_node,
 							"samsung,disp-syscon");
 	if (IS_ERR(mic->sysreg)) {
-		DRM_ERROR("mic: Failed to get system register.\n");
+		DRM_DEV_ERROR(dev, "mic: Failed to get system register.\n");
 		ret = PTR_ERR(mic->sysreg);
 		goto err;
 	}
@@ -410,8 +413,8 @@ static int exynos_mic_probe(struct platform_device *pdev)
 	for (i = 0; i < NUM_CLKS; i++) {
 		mic->clks[i] = devm_clk_get(dev, clk_names[i]);
 		if (IS_ERR(mic->clks[i])) {
-			DRM_ERROR("mic: Failed to get clock (%s)\n",
-								clk_names[i]);
+			DRM_DEV_ERROR(dev, "mic: Failed to get clock (%s)\n",
+				      clk_names[i]);
 			ret = PTR_ERR(mic->clks[i]);
 			goto err;
 		}

commit 63f8f3badf799c8b63ff33a489886bc138ce5d09
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Apr 6 17:39:01 2018 +0300

    drm: bridge: Constify mode arguments to bridge .mode_set() operation
    
    The mode and ajusted_mode passed to the bridge .mode_set() operation
    should never be modified by the bridge (and are not in any of the
    existing bridge drivers). Make them const to make this clear.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index 2fd299a58297..dd02e8a323ef 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -246,8 +246,8 @@ static void mic_post_disable(struct drm_bridge *bridge)
 }
 
 static void mic_mode_set(struct drm_bridge *bridge,
-			struct drm_display_mode *mode,
-			struct drm_display_mode *adjusted_mode)
+			 const struct drm_display_mode *mode,
+			 const struct drm_display_mode *adjusted_mode)
 {
 	struct exynos_mic *mic = bridge->driver_private;
 

commit 7e915746de03e0e62d58491f22805cc5a80a581a
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Jun 11 14:25:00 2018 +0200

    drm/exynos: Ensure suspended runtime PM state during system suspend
    
    Add calls to pm_runtime_force_{suspend,resume} as SYSTEM_SLEEP_PM_OPS for
    all drivers for the real Exynos DRM hardware modules. This ensures that
    the resources will be released for the system PM suspend/resume cycle.
    Exynos DRM core already takes care of suspending the whole display pipeline
    before PM callbacks of the real devices are called.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index 2174814273e2..2fd299a58297 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -367,6 +367,8 @@ static int exynos_mic_resume(struct device *dev)
 
 static const struct dev_pm_ops exynos_mic_pm_ops = {
 	SET_RUNTIME_PM_OPS(exynos_mic_suspend, exynos_mic_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
 };
 
 static int exynos_mic_probe(struct platform_device *pdev)

commit 29baa82aa55f40d67cfc8138c944fd8880c27e8e
Merge: e19b205be43d ac6c35a4d8c7
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Sep 28 05:45:27 2017 +1000

    Merge tag 'drm-misc-next-2017-09-20' of git://anongit.freedesktop.org/git/drm-misc into drm-next
    
    UAPI Changes:
    
    Cross-subsystem Changes:
    
    Core Changes:
    - DP SDP defines (Ville)
    - polish for scdc helpers (Thierry Reding)
    - fix lifetimes for connector/plane state across crtc changes (Maarten
      Lankhorst).
    - sparse fixes (Ville+Thierry)
    - make legacy kms ioctls all interruptible (Maarten)
    - push edid override into the edid helpers (out of probe helpers)
      (Jani)
    - DP ESI defines for link status (DK)
    
    Driver Changes:
    - drm-panel is now in drm-misc!
    - minor panel-simple cleanups/refactoring by various folks
    - drm_bridge_add cleanup (Inki Dae)
    - constify a few i2c_device_id structs (Arvind Yadav)
    - More patches from Noralf's fb/gem helper cleanup
    - bridge/synopsis: reset fix (Philippe Cornu)
    - fix tracepoint include handling in drivers (Thierry)
    - rockchip: lvds support (Sandy Huang)
    - move sun4i into drm-misc fold (Maxime Ripard)
    - sun4i: refactor driver load + support TCON backend/layer muxing
      (Chen-Yu Tsai)
    - pl111: support more pl11x variants (Linus Walleij)
    - bridge/adv7511: robustify probing/edid handling (Lars-Petersen
      Clausen)
    
    New hw support:
    - S6E63J0X03 panel (Hoegeun Kwon)
    - OTM8009A panel (Philippe CORNU)
    - Seiko 43WVF1G panel (Marco Franchi)
    - tve200 driver (Linus Walleij)
    
    Plus assorted of tiny patches all over, including our first outreachy
    patches from applicants for the winter round!
    
    * tag 'drm-misc-next-2017-09-20' of git://anongit.freedesktop.org/git/drm-misc: (101 commits)
      drm: add backwards compatibility support for drm_kms_helper.edid_firmware
      drm: handle override and firmware EDID at drm_do_get_edid() level
      drm/dp: DPCD register defines for link status within ESI field
      drm/rockchip: Replace dev_* with DRM_DEV_*
      drm/tinydrm: Drop driver registered message
      drm/gem-fb-helper: Use debug message on gem lookup failure
      drm/imx: Use drm_gem_fb_create() and drm_gem_fb_prepare_fb()
      drm/bridge: adv7511: Constify HDMI CODEC platform data
      drm/bridge: adv7511: Enable connector polling when no interrupt is specified
      drm/bridge: adv7511: Remove private copy of the EDID
      drm/bridge: adv7511: Properly update EDID when no EDID was found
      drm/crtc: Convert setcrtc ioctl locking to interruptible.
      drm/atomic: Convert pageflip ioctl locking to interruptible.
      drm/legacy: Convert setplane ioctl locking to interruptible.
      drm/legacy: Convert cursor ioctl locking to interruptible.
      drm/atomic: Convert atomic ioctl locking to interruptible.
      drm/atomic: Prepare drm_modeset_lock infrastructure for interruptible waiting, v2.
      drm/tve200: Clean up panel bridging
      drm/doc: Update todo.rst
      drm/dp/mst: Sideband message transaction to power up/down nodes
      ...

commit 29c5079d9e67e4c32719077ba619f2782b34e3d0
Author: Andrzej Hajda <a.hajda@samsung.com>
Date:   Thu Aug 24 15:33:54 2017 +0200

    drm/exynos/mic: use mode info stored in CRTC to detect i80 mode
    
    MIC driver should use info from CRTC to check mode of work instead of
    illegally peeking into nodes of other devices.
    
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index 16bbee897e0d..ba4a32b132ba 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -21,9 +21,12 @@
 #include <linux/component.h>
 #include <linux/pm_runtime.h>
 #include <drm/drmP.h>
+#include <drm/drm_encoder.h>
 #include <linux/mfd/syscon.h>
 #include <linux/regmap.h>
 
+#include "exynos_drm_drv.h"
+
 /* Sysreg registers for MIC */
 #define DSD_CFG_MUX	0x1004
 #define MIC0_RGB_MUX	(1 << 0)
@@ -85,12 +88,6 @@
 
 #define MIC_BS_SIZE_2D(x)	((x) & 0x3fff)
 
-enum {
-	ENDPOINT_DECON_NODE,
-	ENDPOINT_DSI_NODE,
-	NUM_ENDPOINTS
-};
-
 static char *clk_names[] = { "pclk_mic0", "sclk_rgb_vclk_to_mic0" };
 #define NUM_CLKS		ARRAY_SIZE(clk_names)
 static DEFINE_MUTEX(mic_mutex);
@@ -229,36 +226,6 @@ static void mic_set_reg_on(struct exynos_mic *mic, bool enable)
 	writel(reg, mic->reg + MIC_OP);
 }
 
-static int parse_dt(struct exynos_mic *mic)
-{
-	int ret = 0, i, j;
-	struct device_node *remote_node;
-	struct device_node *nodes[3];
-
-	/*
-	 * The order of endpoints does matter.
-	 * The first node must be for decon and the second one must be for dsi.
-	 */
-	for (i = 0, j = 0; i < NUM_ENDPOINTS; i++) {
-		remote_node = of_graph_get_remote_node(mic->dev->of_node, i, 0);
-		if (!remote_node) {
-			ret = -EPIPE;
-			goto exit;
-		}
-		nodes[j++] = remote_node;
-
-		if (i == ENDPOINT_DECON_NODE &&
-			of_get_child_by_name(remote_node, "i80-if-timings"))
-			mic->i80_mode = 1;
-	}
-
-exit:
-	while (--j > -1)
-		of_node_put(nodes[j]);
-
-	return ret;
-}
-
 static void mic_disable(struct drm_bridge *bridge) { }
 
 static void mic_post_disable(struct drm_bridge *bridge)
@@ -286,6 +253,7 @@ static void mic_mode_set(struct drm_bridge *bridge,
 
 	mutex_lock(&mic_mutex);
 	drm_display_mode_to_videomode(mode, &mic->vm);
+	mic->i80_mode = to_exynos_crtc(bridge->encoder->crtc)->i80_mode;
 	mutex_unlock(&mic_mutex);
 }
 
@@ -417,10 +385,6 @@ static int exynos_mic_probe(struct platform_device *pdev)
 
 	mic->dev = dev;
 
-	ret = parse_dt(mic);
-	if (ret)
-		goto err;
-
 	ret = of_address_to_resource(dev->of_node, 0, &res);
 	if (ret) {
 		DRM_ERROR("mic: Failed to get mem region for MIC\n");

commit 059e3c0b2fa30b6903de6b78f191028484385c3b
Author: Inki Dae <inki.dae@samsung.com>
Date:   Mon Jul 3 17:42:28 2017 +0900

    drm/exynos: mic: clean up drm_bridge_add call
    
    This patch removes unnecessary checking of return value.
    
    Signed-off-by: Inki Dae <inki.dae@samsung.com>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/1499071350-25168-13-git-send-email-inki.dae@samsung.com

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index 16bbee897e0d..ab333d5b2727 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -456,11 +456,7 @@ static int exynos_mic_probe(struct platform_device *pdev)
 	mic->bridge.funcs = &mic_bridge_funcs;
 	mic->bridge.of_node = dev->of_node;
 
-	ret = drm_bridge_add(&mic->bridge);
-	if (ret) {
-		DRM_ERROR("mic: Failed to add MIC to the global bridge list\n");
-		return ret;
-	}
+	drm_bridge_add(&mic->bridge);
 
 	pm_runtime_enable(dev);
 

commit 576d72fbfb454eb903447fee5e5dbb5cfb700fee
Author: Inki Dae <inki.dae@samsung.com>
Date:   Mon Jul 3 16:08:23 2017 +0900

    drm/exynos: mic: add a bridge at probe
    
    This patch moves drm_bridge_add call into probe.
    
    It doesn't need to call drm_bridge_add call every time
    bind callback is called.
    
    Changelog v2
    - moved drm_bridge_remove call into remove callback.
    - corrected description.
    
    Suggested-by: Andrzej Hajda <a.hajda@samsung.com>
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Reviewed-by: Hoegeun Kwon <hoegeun.kwon@samsung.com>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index e45720543a45..16bbee897e0d 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -340,16 +340,10 @@ static int exynos_mic_bind(struct device *dev, struct device *master,
 			   void *data)
 {
 	struct exynos_mic *mic = dev_get_drvdata(dev);
-	int ret;
 
-	mic->bridge.funcs = &mic_bridge_funcs;
-	mic->bridge.of_node = dev->of_node;
 	mic->bridge.driver_private = mic;
-	ret = drm_bridge_add(&mic->bridge);
-	if (ret)
-		DRM_ERROR("mic: Failed to add MIC to the global bridge list\n");
 
-	return ret;
+	return 0;
 }
 
 static void exynos_mic_unbind(struct device *dev, struct device *master,
@@ -365,8 +359,6 @@ static void exynos_mic_unbind(struct device *dev, struct device *master,
 
 already_disabled:
 	mutex_unlock(&mic_mutex);
-
-	drm_bridge_remove(&mic->bridge);
 }
 
 static const struct component_ops exynos_mic_component_ops = {
@@ -461,6 +453,15 @@ static int exynos_mic_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, mic);
 
+	mic->bridge.funcs = &mic_bridge_funcs;
+	mic->bridge.of_node = dev->of_node;
+
+	ret = drm_bridge_add(&mic->bridge);
+	if (ret) {
+		DRM_ERROR("mic: Failed to add MIC to the global bridge list\n");
+		return ret;
+	}
+
 	pm_runtime_enable(dev);
 
 	ret = component_add(dev, &exynos_mic_component_ops);
@@ -479,8 +480,13 @@ static int exynos_mic_probe(struct platform_device *pdev)
 
 static int exynos_mic_remove(struct platform_device *pdev)
 {
+	struct exynos_mic *mic = platform_get_drvdata(pdev);
+
 	component_del(&pdev->dev, &exynos_mic_component_ops);
 	pm_runtime_disable(&pdev->dev);
+
+	drm_bridge_remove(&mic->bridge);
+
 	return 0;
 }
 

commit 86418f90a4c1a0073db65d8a1e2bf94421117a60
Author: Rob Herring <robh@kernel.org>
Date:   Wed Mar 22 08:26:06 2017 -0500

    drm: convert drivers to use of_graph_get_remote_node
    
    Convert drivers to use the new of_graph_get_remote_node() helper
    instead of parsing the endpoint node and then getting the remote device
    node. Now drivers can just specify the device node and which
    port/endpoint and get back the connected remote device node. The details
    of the graph binding are nicely abstracted into the core OF graph code.
    
    This changes some error messages to debug messages (in the graph core).
    Graph connections are often "no connects" depending on the particular
    board, so we want to avoid spurious messages. Plus the kernel is not a
    DT validator.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Tested-by: Liviu Dudau <liviu.dudau@arm.com>
    Tested-by: Eric Anholt <eric@anholt.net>
    Tested-by: Jyri Sarha <jsarha@ti.com>
    Tested by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index 2ef43d403eaa..e45720543a45 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -229,29 +229,6 @@ static void mic_set_reg_on(struct exynos_mic *mic, bool enable)
 	writel(reg, mic->reg + MIC_OP);
 }
 
-static struct device_node *get_remote_node(struct device_node *from, int reg)
-{
-	struct device_node *endpoint = NULL, *remote_node = NULL;
-
-	endpoint = of_graph_get_endpoint_by_regs(from, reg, -1);
-	if (!endpoint) {
-		DRM_ERROR("mic: Failed to find remote port from %s",
-				from->full_name);
-		goto exit;
-	}
-
-	remote_node = of_graph_get_remote_port_parent(endpoint);
-	if (!remote_node) {
-		DRM_ERROR("mic: Failed to find remote port parent from %s",
-							from->full_name);
-		goto exit;
-	}
-
-exit:
-	of_node_put(endpoint);
-	return remote_node;
-}
-
 static int parse_dt(struct exynos_mic *mic)
 {
 	int ret = 0, i, j;
@@ -263,7 +240,7 @@ static int parse_dt(struct exynos_mic *mic)
 	 * The first node must be for decon and the second one must be for dsi.
 	 */
 	for (i = 0, j = 0; i < NUM_ENDPOINTS; i++) {
-		remote_node = get_remote_node(mic->dev->of_node, i);
+		remote_node = of_graph_get_remote_node(mic->dev->of_node, i, 0);
 		if (!remote_node) {
 			ret = -EPIPE;
 			goto exit;

commit 4e8ba5cc8863562cb948e26f614217a873f34bac
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Fri Jan 13 09:30:00 2017 +0100

    drm/exynos: mic: Add runtime PM support
    
    This patch adds runtime support calls to notify device core when MIC
    device is really in use. Runtime PM is implemented by enabling and
    disabling clocks like in other Exynos DRM subdrivers. Adding runtime
    PM support is needed to let power domain with this device to be turned
    off when display is not used.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index cf9361ab0eb7..2ef43d403eaa 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -19,6 +19,7 @@
 #include <linux/of_graph.h>
 #include <linux/clk.h>
 #include <linux/component.h>
+#include <linux/pm_runtime.h>
 #include <drm/drmP.h>
 #include <linux/mfd/syscon.h>
 #include <linux/regmap.h>
@@ -286,7 +287,6 @@ static void mic_disable(struct drm_bridge *bridge) { }
 static void mic_post_disable(struct drm_bridge *bridge)
 {
 	struct exynos_mic *mic = bridge->driver_private;
-	int i;
 
 	mutex_lock(&mic_mutex);
 	if (!mic->enabled)
@@ -294,9 +294,7 @@ static void mic_post_disable(struct drm_bridge *bridge)
 
 	mic_set_path(mic, 0);
 
-	for (i = NUM_CLKS - 1; i > -1; i--)
-		clk_disable_unprepare(mic->clks[i]);
-
+	pm_runtime_put(mic->dev);
 	mic->enabled = 0;
 
 already_disabled:
@@ -317,27 +315,22 @@ static void mic_mode_set(struct drm_bridge *bridge,
 static void mic_pre_enable(struct drm_bridge *bridge)
 {
 	struct exynos_mic *mic = bridge->driver_private;
-	int ret, i;
+	int ret;
 
 	mutex_lock(&mic_mutex);
 	if (mic->enabled)
-		goto already_enabled;
+		goto unlock;
 
-	for (i = 0; i < NUM_CLKS; i++) {
-		ret = clk_prepare_enable(mic->clks[i]);
-		if (ret < 0) {
-			DRM_ERROR("Failed to enable clock (%s)\n",
-							clk_names[i]);
-			goto turn_off_clks;
-		}
-	}
+	ret = pm_runtime_get_sync(mic->dev);
+	if (ret < 0)
+		goto unlock;
 
 	mic_set_path(mic, 1);
 
 	ret = mic_sw_reset(mic);
 	if (ret) {
 		DRM_ERROR("Failed to reset\n");
-		goto turn_off_clks;
+		goto turn_off;
 	}
 
 	if (!mic->i80_mode)
@@ -350,10 +343,9 @@ static void mic_pre_enable(struct drm_bridge *bridge)
 
 	return;
 
-turn_off_clks:
-	while (--i > -1)
-		clk_disable_unprepare(mic->clks[i]);
-already_enabled:
+turn_off:
+	pm_runtime_put(mic->dev);
+unlock:
 	mutex_unlock(&mic_mutex);
 }
 
@@ -387,14 +379,12 @@ static void exynos_mic_unbind(struct device *dev, struct device *master,
 			      void *data)
 {
 	struct exynos_mic *mic = dev_get_drvdata(dev);
-	int i;
 
 	mutex_lock(&mic_mutex);
 	if (!mic->enabled)
 		goto already_disabled;
 
-	for (i = NUM_CLKS - 1; i > -1; i--)
-		clk_disable_unprepare(mic->clks[i]);
+	pm_runtime_put(mic->dev);
 
 already_disabled:
 	mutex_unlock(&mic_mutex);
@@ -407,6 +397,41 @@ static const struct component_ops exynos_mic_component_ops = {
 	.unbind	= exynos_mic_unbind,
 };
 
+#ifdef CONFIG_PM
+static int exynos_mic_suspend(struct device *dev)
+{
+	struct exynos_mic *mic = dev_get_drvdata(dev);
+	int i;
+
+	for (i = NUM_CLKS - 1; i > -1; i--)
+		clk_disable_unprepare(mic->clks[i]);
+
+	return 0;
+}
+
+static int exynos_mic_resume(struct device *dev)
+{
+	struct exynos_mic *mic = dev_get_drvdata(dev);
+	int ret, i;
+
+	for (i = 0; i < NUM_CLKS; i++) {
+		ret = clk_prepare_enable(mic->clks[i]);
+		if (ret < 0) {
+			DRM_ERROR("Failed to enable clock (%s)\n",
+							clk_names[i]);
+			while (--i > -1)
+				clk_disable_unprepare(mic->clks[i]);
+			return ret;
+		}
+	}
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops exynos_mic_pm_ops = {
+	SET_RUNTIME_PM_OPS(exynos_mic_suspend, exynos_mic_resume, NULL)
+};
+
 static int exynos_mic_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -459,9 +484,18 @@ static int exynos_mic_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, mic);
 
+	pm_runtime_enable(dev);
+
+	ret = component_add(dev, &exynos_mic_component_ops);
+	if (ret)
+		goto err_pm;
+
 	DRM_DEBUG_KMS("MIC has been probed\n");
-	return component_add(dev, &exynos_mic_component_ops);
 
+	return 0;
+
+err_pm:
+	pm_runtime_disable(dev);
 err:
 	return ret;
 }
@@ -469,6 +503,7 @@ static int exynos_mic_probe(struct platform_device *pdev)
 static int exynos_mic_remove(struct platform_device *pdev)
 {
 	component_del(&pdev->dev, &exynos_mic_component_ops);
+	pm_runtime_disable(&pdev->dev);
 	return 0;
 }
 
@@ -483,6 +518,7 @@ struct platform_driver mic_driver = {
 	.remove		= exynos_mic_remove,
 	.driver		= {
 		.name	= "exynos-mic",
+		.pm	= &exynos_mic_pm_ops,
 		.owner	= THIS_MODULE,
 		.of_match_table = exynos_mic_of_match,
 	},

commit cc2b022518b0d3b040a9016dffccd35d47e8bd8f
Author: Hoegeun Kwon <hoegeun.kwon@samsung.com>
Date:   Thu Jan 5 19:20:07 2017 +0900

    drm/exynos: mic: Fix parse_dt function
    
    The OF graph is not necessary because the panel is a child of
    dsi. therefore, the parse_dt function of dsi does not need to
    check the remote_node connected to the panel. and the whole
    parse_dt function should be refactored later.
    
    Signed-off-by: Hoegeun Kwon <hoegeun.kwon@samsung.com>
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index fed1a940ca5d..cf9361ab0eb7 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -269,28 +269,9 @@ static int parse_dt(struct exynos_mic *mic)
 		}
 		nodes[j++] = remote_node;
 
-		switch (i) {
-		case ENDPOINT_DECON_NODE:
-			/* decon node */
-			if (of_get_child_by_name(remote_node,
-						"i80-if-timings"))
-				mic->i80_mode = 1;
-
-			break;
-		case ENDPOINT_DSI_NODE:
-			/* panel node */
-			remote_node = get_remote_node(remote_node, 1);
-			if (!remote_node) {
-				ret = -EPIPE;
-				goto exit;
-			}
-			nodes[j++] = remote_node;
-
-			break;
-		default:
-			DRM_ERROR("mic: Unknown endpoint from MIC");
-			break;
-		}
+		if (i == ENDPOINT_DECON_NODE &&
+			of_get_child_by_name(remote_node, "i80-if-timings"))
+			mic->i80_mode = 1;
 	}
 
 exit:

commit e87eb57c69003a99b18d43abe58d5850ad19e188
Author: Hoegeun Kwon <hoegeun.kwon@samsung.com>
Date:   Thu Jan 5 19:20:06 2017 +0900

    drm/exynos: mic: Add mode_set callback function
    
    Before applying the patch, used the of_get_videomode function to
    parse the display-timings in the panel which is the child driver
    of dsi in the devicetree. this is wrong. So removed the
    of_get_videomode and fixed to get videomode struct through
    mode_set callback function.
    
    Signed-off-by: Hoegeun Kwon <hoegeun.kwon@samsung.com>
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index a0def0be6d65..fed1a940ca5d 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -286,13 +286,6 @@ static int parse_dt(struct exynos_mic *mic)
 			}
 			nodes[j++] = remote_node;
 
-			ret = of_get_videomode(remote_node,
-							&mic->vm, 0);
-			if (ret) {
-				DRM_ERROR("mic: failed to get videomode");
-				goto exit;
-			}
-
 			break;
 		default:
 			DRM_ERROR("mic: Unknown endpoint from MIC");
@@ -329,6 +322,17 @@ static void mic_post_disable(struct drm_bridge *bridge)
 	mutex_unlock(&mic_mutex);
 }
 
+static void mic_mode_set(struct drm_bridge *bridge,
+			struct drm_display_mode *mode,
+			struct drm_display_mode *adjusted_mode)
+{
+	struct exynos_mic *mic = bridge->driver_private;
+
+	mutex_lock(&mic_mutex);
+	drm_display_mode_to_videomode(mode, &mic->vm);
+	mutex_unlock(&mic_mutex);
+}
+
 static void mic_pre_enable(struct drm_bridge *bridge)
 {
 	struct exynos_mic *mic = bridge->driver_private;
@@ -377,6 +381,7 @@ static void mic_enable(struct drm_bridge *bridge) { }
 static const struct drm_bridge_funcs mic_bridge_funcs = {
 	.disable = mic_disable,
 	.post_disable = mic_post_disable,
+	.mode_set = mic_mode_set,
 	.pre_enable = mic_pre_enable,
 	.enable = mic_enable,
 };

commit 36ffc2bde5fc743aa64c2e1f53de163a92824a27
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Mar 25 23:05:59 2016 +0300

    drm/exynos: fix a warning message
    
    The "ret = regmap_write()" assignment was missing so this error message
    is never printed.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index 890c9b1c0239..a0def0be6d65 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -129,7 +129,7 @@ static void mic_set_path(struct exynos_mic *mic, bool enable)
 	} else
 		val &= ~(MIC0_RGB_MUX | MIC0_I80_MUX | MIC0_ON_MUX);
 
-	regmap_write(mic->sysreg, DSD_CFG_MUX, val);
+	ret = regmap_write(mic->sysreg, DSD_CFG_MUX, val);
 	if (ret)
 		DRM_ERROR("mic: Failed to read system register\n");
 }

commit 6c9c15813b21ce75bc82db86db1163a34b772437
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Mar 17 13:32:15 2016 +0300

    drm/exynos: mic: fix an error code
    
    We accidentally return success instead of a negative error code here.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index 9869d70e9e54..890c9b1c0239 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -457,6 +457,7 @@ static int exynos_mic_probe(struct platform_device *pdev)
 							"samsung,disp-syscon");
 	if (IS_ERR(mic->sysreg)) {
 		DRM_ERROR("mic: Failed to get system register.\n");
+		ret = PTR_ERR(mic->sysreg);
 		goto err;
 	}
 

commit 8b0be57286642f87a968c00932c3f2ef936f6b7b
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Feb 3 13:42:50 2016 +0100

    drm/exynos: mic: make all functions static
    
    There is no point exposing all internal functions to global kernel name
    space, so make all internals functions static.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index 899061a35cf6..9869d70e9e54 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -307,9 +307,9 @@ static int parse_dt(struct exynos_mic *mic)
 	return ret;
 }
 
-void mic_disable(struct drm_bridge *bridge) { }
+static void mic_disable(struct drm_bridge *bridge) { }
 
-void mic_post_disable(struct drm_bridge *bridge)
+static void mic_post_disable(struct drm_bridge *bridge)
 {
 	struct exynos_mic *mic = bridge->driver_private;
 	int i;
@@ -329,7 +329,7 @@ void mic_post_disable(struct drm_bridge *bridge)
 	mutex_unlock(&mic_mutex);
 }
 
-void mic_pre_enable(struct drm_bridge *bridge)
+static void mic_pre_enable(struct drm_bridge *bridge)
 {
 	struct exynos_mic *mic = bridge->driver_private;
 	int ret, i;
@@ -372,7 +372,7 @@ void mic_pre_enable(struct drm_bridge *bridge)
 	mutex_unlock(&mic_mutex);
 }
 
-void mic_enable(struct drm_bridge *bridge) { }
+static void mic_enable(struct drm_bridge *bridge) { }
 
 static const struct drm_bridge_funcs mic_bridge_funcs = {
 	.disable = mic_disable,
@@ -421,7 +421,7 @@ static const struct component_ops exynos_mic_component_ops = {
 	.unbind	= exynos_mic_unbind,
 };
 
-int exynos_mic_probe(struct platform_device *pdev)
+static int exynos_mic_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct exynos_mic *mic;

commit 622688f36e9b98ab0c0a01a47c33635519e735cb
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Feb 3 13:42:49 2016 +0100

    drm/exynos: mic: convert to component framework
    
    MIC is SoC component and important part of kms pipeline on Exynos5433,
    so convert it to use component framework like other KMS/CRTC drivers.
    MIC driver is already listed on KMS component driver list in Exynos DRM
    core, so without this conversion, initialization of Exynos DRM core
    fails on Exynos 5433 SoC.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index 10594c17097a..899061a35cf6 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -18,6 +18,7 @@
 #include <linux/of.h>
 #include <linux/of_graph.h>
 #include <linux/clk.h>
+#include <linux/component.h>
 #include <drm/drmP.h>
 #include <linux/mfd/syscon.h>
 #include <linux/regmap.h>
@@ -373,9 +374,33 @@ void mic_pre_enable(struct drm_bridge *bridge)
 
 void mic_enable(struct drm_bridge *bridge) { }
 
-void mic_destroy(struct drm_bridge *bridge)
+static const struct drm_bridge_funcs mic_bridge_funcs = {
+	.disable = mic_disable,
+	.post_disable = mic_post_disable,
+	.pre_enable = mic_pre_enable,
+	.enable = mic_enable,
+};
+
+static int exynos_mic_bind(struct device *dev, struct device *master,
+			   void *data)
 {
-	struct exynos_mic *mic = bridge->driver_private;
+	struct exynos_mic *mic = dev_get_drvdata(dev);
+	int ret;
+
+	mic->bridge.funcs = &mic_bridge_funcs;
+	mic->bridge.of_node = dev->of_node;
+	mic->bridge.driver_private = mic;
+	ret = drm_bridge_add(&mic->bridge);
+	if (ret)
+		DRM_ERROR("mic: Failed to add MIC to the global bridge list\n");
+
+	return ret;
+}
+
+static void exynos_mic_unbind(struct device *dev, struct device *master,
+			      void *data)
+{
+	struct exynos_mic *mic = dev_get_drvdata(dev);
 	int i;
 
 	mutex_lock(&mic_mutex);
@@ -387,13 +412,13 @@ void mic_destroy(struct drm_bridge *bridge)
 
 already_disabled:
 	mutex_unlock(&mic_mutex);
+
+	drm_bridge_remove(&mic->bridge);
 }
 
-static const struct drm_bridge_funcs mic_bridge_funcs = {
-	.disable = mic_disable,
-	.post_disable = mic_post_disable,
-	.pre_enable = mic_pre_enable,
-	.enable = mic_enable,
+static const struct component_ops exynos_mic_component_ops = {
+	.bind	= exynos_mic_bind,
+	.unbind	= exynos_mic_unbind,
 };
 
 int exynos_mic_probe(struct platform_device *pdev)
@@ -435,15 +460,6 @@ int exynos_mic_probe(struct platform_device *pdev)
 		goto err;
 	}
 
-	mic->bridge.funcs = &mic_bridge_funcs;
-	mic->bridge.of_node = dev->of_node;
-	mic->bridge.driver_private = mic;
-	ret = drm_bridge_add(&mic->bridge);
-	if (ret) {
-		DRM_ERROR("mic: Failed to add MIC to the global bridge list\n");
-		goto err;
-	}
-
 	for (i = 0; i < NUM_CLKS; i++) {
 		mic->clks[i] = devm_clk_get(dev, clk_names[i]);
 		if (IS_ERR(mic->clks[i])) {
@@ -454,7 +470,10 @@ int exynos_mic_probe(struct platform_device *pdev)
 		}
 	}
 
+	platform_set_drvdata(pdev, mic);
+
 	DRM_DEBUG_KMS("MIC has been probed\n");
+	return component_add(dev, &exynos_mic_component_ops);
 
 err:
 	return ret;
@@ -462,10 +481,7 @@ int exynos_mic_probe(struct platform_device *pdev)
 
 static int exynos_mic_remove(struct platform_device *pdev)
 {
-	struct exynos_mic *mic = platform_get_drvdata(pdev);
-
-	drm_bridge_remove(&mic->bridge);
-
+	component_del(&pdev->dev, &exynos_mic_component_ops);
 	return 0;
 }
 

commit 38b5e5f4d76df1116b0b5a76fb9b7549a44efe6e
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Feb 3 13:42:48 2016 +0100

    drm/exynos: mic: use devm_clk interface
    
    Drivers should use devm_clk* interface instead of of_clk* functions.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index 4eaef36aec5a..10594c17097a 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -445,7 +445,7 @@ int exynos_mic_probe(struct platform_device *pdev)
 	}
 
 	for (i = 0; i < NUM_CLKS; i++) {
-		mic->clks[i] = of_clk_get_by_name(dev->of_node, clk_names[i]);
+		mic->clks[i] = devm_clk_get(dev, clk_names[i]);
 		if (IS_ERR(mic->clks[i])) {
 			DRM_ERROR("mic: Failed to get clock (%s)\n",
 								clk_names[i]);
@@ -463,13 +463,9 @@ int exynos_mic_probe(struct platform_device *pdev)
 static int exynos_mic_remove(struct platform_device *pdev)
 {
 	struct exynos_mic *mic = platform_get_drvdata(pdev);
-	int i;
 
 	drm_bridge_remove(&mic->bridge);
 
-	for (i = NUM_CLKS - 1; i > -1; i--)
-		clk_put(mic->clks[i]);
-
 	return 0;
 }
 

commit 800ba2b58182e4b0e8dc826a27362d45499068b1
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Dec 15 12:21:06 2015 +0100

    drm/exynos: Constify function pointer structs
    
    Moves a bunch of junk to .rodata from .data.
    
     drivers/gpu/drm/exynos/exynosdrm.ko:
    -.text                       125792
    +.text                       125788
    -.rodata                      10972
    +.rodata                      11748
    -.data                         6720
    +.data                         5944
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1450178476-26284-19-git-send-email-boris.brezillon@free-electrons.com
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
index 8994eab56ba8..4eaef36aec5a 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_mic.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -389,7 +389,7 @@ void mic_destroy(struct drm_bridge *bridge)
 	mutex_unlock(&mic_mutex);
 }
 
-struct drm_bridge_funcs mic_bridge_funcs = {
+static const struct drm_bridge_funcs mic_bridge_funcs = {
 	.disable = mic_disable,
 	.post_disable = mic_post_disable,
 	.pre_enable = mic_pre_enable,

commit 77bbd8914a91fab25f567772db60e2d1372de8c6
Author: Hyungwon Hwang <human.hwang@samsung.com>
Date:   Fri Jun 12 21:59:02 2015 +0900

    drm/exynos: mic: add MIC driver
    
    MIC(Mobile image compressor) is newly added IP in Exynos5433. MIC
    resides between decon and mipi dsim, and compresses frame data by 50%.
    With dsi, not display port, to send frame data to the panel, the
    bandwidth is not enough. That is why this compressor is introduced.
    
    Signed-off-by: Hyungwon Hwang <human.hwang@samsung.com>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_mic.c b/drivers/gpu/drm/exynos/exynos_drm_mic.c
new file mode 100644
index 000000000000..8994eab56ba8
--- /dev/null
+++ b/drivers/gpu/drm/exynos/exynos_drm_mic.c
@@ -0,0 +1,490 @@
+/*
+ * Copyright (C) 2015 Samsung Electronics Co.Ltd
+ * Authors:
+ *	Hyungwon Hwang <human.hwang@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundationr
+ */
+
+#include <linux/platform_device.h>
+#include <video/of_videomode.h>
+#include <linux/of_address.h>
+#include <video/videomode.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/clk.h>
+#include <drm/drmP.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+
+/* Sysreg registers for MIC */
+#define DSD_CFG_MUX	0x1004
+#define MIC0_RGB_MUX	(1 << 0)
+#define MIC0_I80_MUX	(1 << 1)
+#define MIC0_ON_MUX	(1 << 5)
+
+/* MIC registers */
+#define MIC_OP				0x0
+#define MIC_IP_VER			0x0004
+#define MIC_V_TIMING_0			0x0008
+#define MIC_V_TIMING_1			0x000C
+#define MIC_IMG_SIZE			0x0010
+#define MIC_INPUT_TIMING_0		0x0014
+#define MIC_INPUT_TIMING_1		0x0018
+#define MIC_2D_OUTPUT_TIMING_0		0x001C
+#define MIC_2D_OUTPUT_TIMING_1		0x0020
+#define MIC_2D_OUTPUT_TIMING_2		0x0024
+#define MIC_3D_OUTPUT_TIMING_0		0x0028
+#define MIC_3D_OUTPUT_TIMING_1		0x002C
+#define MIC_3D_OUTPUT_TIMING_2		0x0030
+#define MIC_CORE_PARA_0			0x0034
+#define MIC_CORE_PARA_1			0x0038
+#define MIC_CTC_CTRL			0x0040
+#define MIC_RD_DATA			0x0044
+
+#define MIC_UPD_REG			(1 << 31)
+#define MIC_ON_REG			(1 << 30)
+#define MIC_TD_ON_REG			(1 << 29)
+#define MIC_BS_CHG_OUT			(1 << 16)
+#define MIC_VIDEO_TYPE(x)		(((x) & 0xf) << 12)
+#define MIC_PSR_EN			(1 << 5)
+#define MIC_SW_RST			(1 << 4)
+#define MIC_ALL_RST			(1 << 3)
+#define MIC_CORE_VER_CONTROL		(1 << 2)
+#define MIC_MODE_SEL_COMMAND_MODE	(1 << 1)
+#define MIC_MODE_SEL_MASK		(1 << 1)
+#define MIC_CORE_EN			(1 << 0)
+
+#define MIC_V_PULSE_WIDTH(x)		(((x) & 0x3fff) << 16)
+#define MIC_V_PERIOD_LINE(x)		((x) & 0x3fff)
+
+#define MIC_VBP_SIZE(x)			(((x) & 0x3fff) << 16)
+#define MIC_VFP_SIZE(x)			((x) & 0x3fff)
+
+#define MIC_IMG_V_SIZE(x)		(((x) & 0x3fff) << 16)
+#define MIC_IMG_H_SIZE(x)		((x) & 0x3fff)
+
+#define MIC_H_PULSE_WIDTH_IN(x)		(((x) & 0x3fff) << 16)
+#define MIC_H_PERIOD_PIXEL_IN(x)	((x) & 0x3fff)
+
+#define MIC_HBP_SIZE_IN(x)		(((x) & 0x3fff) << 16)
+#define MIC_HFP_SIZE_IN(x)		((x) & 0x3fff)
+
+#define MIC_H_PULSE_WIDTH_2D(x)		(((x) & 0x3fff) << 16)
+#define MIC_H_PERIOD_PIXEL_2D(x)	((x) & 0x3fff)
+
+#define MIC_HBP_SIZE_2D(x)		(((x) & 0x3fff) << 16)
+#define MIC_HFP_SIZE_2D(x)		((x) & 0x3fff)
+
+#define MIC_BS_SIZE_2D(x)	((x) & 0x3fff)
+
+enum {
+	ENDPOINT_DECON_NODE,
+	ENDPOINT_DSI_NODE,
+	NUM_ENDPOINTS
+};
+
+static char *clk_names[] = { "pclk_mic0", "sclk_rgb_vclk_to_mic0" };
+#define NUM_CLKS		ARRAY_SIZE(clk_names)
+static DEFINE_MUTEX(mic_mutex);
+
+struct exynos_mic {
+	struct device *dev;
+	void __iomem *reg;
+	struct regmap *sysreg;
+	struct clk *clks[NUM_CLKS];
+
+	bool i80_mode;
+	struct videomode vm;
+	struct drm_encoder *encoder;
+	struct drm_bridge bridge;
+
+	bool enabled;
+};
+
+static void mic_set_path(struct exynos_mic *mic, bool enable)
+{
+	int ret;
+	unsigned int val;
+
+	ret = regmap_read(mic->sysreg, DSD_CFG_MUX, &val);
+	if (ret) {
+		DRM_ERROR("mic: Failed to read system register\n");
+		return;
+	}
+
+	if (enable) {
+		if (mic->i80_mode)
+			val |= MIC0_I80_MUX;
+		else
+			val |= MIC0_RGB_MUX;
+
+		val |=  MIC0_ON_MUX;
+	} else
+		val &= ~(MIC0_RGB_MUX | MIC0_I80_MUX | MIC0_ON_MUX);
+
+	regmap_write(mic->sysreg, DSD_CFG_MUX, val);
+	if (ret)
+		DRM_ERROR("mic: Failed to read system register\n");
+}
+
+static int mic_sw_reset(struct exynos_mic *mic)
+{
+	unsigned int retry = 100;
+	int ret;
+
+	writel(MIC_SW_RST, mic->reg + MIC_OP);
+
+	while (retry-- > 0) {
+		ret = readl(mic->reg + MIC_OP);
+		if (!(ret & MIC_SW_RST))
+			return 0;
+
+		udelay(10);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static void mic_set_porch_timing(struct exynos_mic *mic)
+{
+	struct videomode vm = mic->vm;
+	u32 reg;
+
+	reg = MIC_V_PULSE_WIDTH(vm.vsync_len) +
+		MIC_V_PERIOD_LINE(vm.vsync_len + vm.vactive +
+				vm.vback_porch + vm.vfront_porch);
+	writel(reg, mic->reg + MIC_V_TIMING_0);
+
+	reg = MIC_VBP_SIZE(vm.vback_porch) +
+		MIC_VFP_SIZE(vm.vfront_porch);
+	writel(reg, mic->reg + MIC_V_TIMING_1);
+
+	reg = MIC_V_PULSE_WIDTH(vm.hsync_len) +
+		MIC_V_PERIOD_LINE(vm.hsync_len + vm.hactive +
+				vm.hback_porch + vm.hfront_porch);
+	writel(reg, mic->reg + MIC_INPUT_TIMING_0);
+
+	reg = MIC_VBP_SIZE(vm.hback_porch) +
+		MIC_VFP_SIZE(vm.hfront_porch);
+	writel(reg, mic->reg + MIC_INPUT_TIMING_1);
+}
+
+static void mic_set_img_size(struct exynos_mic *mic)
+{
+	struct videomode *vm = &mic->vm;
+	u32 reg;
+
+	reg = MIC_IMG_H_SIZE(vm->hactive) +
+		MIC_IMG_V_SIZE(vm->vactive);
+
+	writel(reg, mic->reg + MIC_IMG_SIZE);
+}
+
+static void mic_set_output_timing(struct exynos_mic *mic)
+{
+	struct videomode vm = mic->vm;
+	u32 reg, bs_size_2d;
+
+	DRM_DEBUG("w: %u, h: %u\n", vm.hactive, vm.vactive);
+	bs_size_2d = ((vm.hactive >> 2) << 1) + (vm.vactive % 4);
+	reg = MIC_BS_SIZE_2D(bs_size_2d);
+	writel(reg, mic->reg + MIC_2D_OUTPUT_TIMING_2);
+
+	if (!mic->i80_mode) {
+		reg = MIC_H_PULSE_WIDTH_2D(vm.hsync_len) +
+			MIC_H_PERIOD_PIXEL_2D(vm.hsync_len + bs_size_2d +
+					vm.hback_porch + vm.hfront_porch);
+		writel(reg, mic->reg + MIC_2D_OUTPUT_TIMING_0);
+
+		reg = MIC_HBP_SIZE_2D(vm.hback_porch) +
+			MIC_H_PERIOD_PIXEL_2D(vm.hfront_porch);
+		writel(reg, mic->reg + MIC_2D_OUTPUT_TIMING_1);
+	}
+}
+
+static void mic_set_reg_on(struct exynos_mic *mic, bool enable)
+{
+	u32 reg = readl(mic->reg + MIC_OP);
+
+	if (enable) {
+		reg &= ~(MIC_MODE_SEL_MASK | MIC_CORE_VER_CONTROL | MIC_PSR_EN);
+		reg |= (MIC_CORE_EN | MIC_BS_CHG_OUT | MIC_ON_REG);
+
+		reg  &= ~MIC_MODE_SEL_COMMAND_MODE;
+		if (mic->i80_mode)
+			reg |= MIC_MODE_SEL_COMMAND_MODE;
+	} else {
+		reg &= ~MIC_CORE_EN;
+	}
+
+	reg |= MIC_UPD_REG;
+	writel(reg, mic->reg + MIC_OP);
+}
+
+static struct device_node *get_remote_node(struct device_node *from, int reg)
+{
+	struct device_node *endpoint = NULL, *remote_node = NULL;
+
+	endpoint = of_graph_get_endpoint_by_regs(from, reg, -1);
+	if (!endpoint) {
+		DRM_ERROR("mic: Failed to find remote port from %s",
+				from->full_name);
+		goto exit;
+	}
+
+	remote_node = of_graph_get_remote_port_parent(endpoint);
+	if (!remote_node) {
+		DRM_ERROR("mic: Failed to find remote port parent from %s",
+							from->full_name);
+		goto exit;
+	}
+
+exit:
+	of_node_put(endpoint);
+	return remote_node;
+}
+
+static int parse_dt(struct exynos_mic *mic)
+{
+	int ret = 0, i, j;
+	struct device_node *remote_node;
+	struct device_node *nodes[3];
+
+	/*
+	 * The order of endpoints does matter.
+	 * The first node must be for decon and the second one must be for dsi.
+	 */
+	for (i = 0, j = 0; i < NUM_ENDPOINTS; i++) {
+		remote_node = get_remote_node(mic->dev->of_node, i);
+		if (!remote_node) {
+			ret = -EPIPE;
+			goto exit;
+		}
+		nodes[j++] = remote_node;
+
+		switch (i) {
+		case ENDPOINT_DECON_NODE:
+			/* decon node */
+			if (of_get_child_by_name(remote_node,
+						"i80-if-timings"))
+				mic->i80_mode = 1;
+
+			break;
+		case ENDPOINT_DSI_NODE:
+			/* panel node */
+			remote_node = get_remote_node(remote_node, 1);
+			if (!remote_node) {
+				ret = -EPIPE;
+				goto exit;
+			}
+			nodes[j++] = remote_node;
+
+			ret = of_get_videomode(remote_node,
+							&mic->vm, 0);
+			if (ret) {
+				DRM_ERROR("mic: failed to get videomode");
+				goto exit;
+			}
+
+			break;
+		default:
+			DRM_ERROR("mic: Unknown endpoint from MIC");
+			break;
+		}
+	}
+
+exit:
+	while (--j > -1)
+		of_node_put(nodes[j]);
+
+	return ret;
+}
+
+void mic_disable(struct drm_bridge *bridge) { }
+
+void mic_post_disable(struct drm_bridge *bridge)
+{
+	struct exynos_mic *mic = bridge->driver_private;
+	int i;
+
+	mutex_lock(&mic_mutex);
+	if (!mic->enabled)
+		goto already_disabled;
+
+	mic_set_path(mic, 0);
+
+	for (i = NUM_CLKS - 1; i > -1; i--)
+		clk_disable_unprepare(mic->clks[i]);
+
+	mic->enabled = 0;
+
+already_disabled:
+	mutex_unlock(&mic_mutex);
+}
+
+void mic_pre_enable(struct drm_bridge *bridge)
+{
+	struct exynos_mic *mic = bridge->driver_private;
+	int ret, i;
+
+	mutex_lock(&mic_mutex);
+	if (mic->enabled)
+		goto already_enabled;
+
+	for (i = 0; i < NUM_CLKS; i++) {
+		ret = clk_prepare_enable(mic->clks[i]);
+		if (ret < 0) {
+			DRM_ERROR("Failed to enable clock (%s)\n",
+							clk_names[i]);
+			goto turn_off_clks;
+		}
+	}
+
+	mic_set_path(mic, 1);
+
+	ret = mic_sw_reset(mic);
+	if (ret) {
+		DRM_ERROR("Failed to reset\n");
+		goto turn_off_clks;
+	}
+
+	if (!mic->i80_mode)
+		mic_set_porch_timing(mic);
+	mic_set_img_size(mic);
+	mic_set_output_timing(mic);
+	mic_set_reg_on(mic, 1);
+	mic->enabled = 1;
+	mutex_unlock(&mic_mutex);
+
+	return;
+
+turn_off_clks:
+	while (--i > -1)
+		clk_disable_unprepare(mic->clks[i]);
+already_enabled:
+	mutex_unlock(&mic_mutex);
+}
+
+void mic_enable(struct drm_bridge *bridge) { }
+
+void mic_destroy(struct drm_bridge *bridge)
+{
+	struct exynos_mic *mic = bridge->driver_private;
+	int i;
+
+	mutex_lock(&mic_mutex);
+	if (!mic->enabled)
+		goto already_disabled;
+
+	for (i = NUM_CLKS - 1; i > -1; i--)
+		clk_disable_unprepare(mic->clks[i]);
+
+already_disabled:
+	mutex_unlock(&mic_mutex);
+}
+
+struct drm_bridge_funcs mic_bridge_funcs = {
+	.disable = mic_disable,
+	.post_disable = mic_post_disable,
+	.pre_enable = mic_pre_enable,
+	.enable = mic_enable,
+};
+
+int exynos_mic_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct exynos_mic *mic;
+	struct resource res;
+	int ret, i;
+
+	mic = devm_kzalloc(dev, sizeof(*mic), GFP_KERNEL);
+	if (!mic) {
+		DRM_ERROR("mic: Failed to allocate memory for MIC object\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	mic->dev = dev;
+
+	ret = parse_dt(mic);
+	if (ret)
+		goto err;
+
+	ret = of_address_to_resource(dev->of_node, 0, &res);
+	if (ret) {
+		DRM_ERROR("mic: Failed to get mem region for MIC\n");
+		goto err;
+	}
+	mic->reg = devm_ioremap(dev, res.start, resource_size(&res));
+	if (!mic->reg) {
+		DRM_ERROR("mic: Failed to remap for MIC\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	mic->sysreg = syscon_regmap_lookup_by_phandle(dev->of_node,
+							"samsung,disp-syscon");
+	if (IS_ERR(mic->sysreg)) {
+		DRM_ERROR("mic: Failed to get system register.\n");
+		goto err;
+	}
+
+	mic->bridge.funcs = &mic_bridge_funcs;
+	mic->bridge.of_node = dev->of_node;
+	mic->bridge.driver_private = mic;
+	ret = drm_bridge_add(&mic->bridge);
+	if (ret) {
+		DRM_ERROR("mic: Failed to add MIC to the global bridge list\n");
+		goto err;
+	}
+
+	for (i = 0; i < NUM_CLKS; i++) {
+		mic->clks[i] = of_clk_get_by_name(dev->of_node, clk_names[i]);
+		if (IS_ERR(mic->clks[i])) {
+			DRM_ERROR("mic: Failed to get clock (%s)\n",
+								clk_names[i]);
+			ret = PTR_ERR(mic->clks[i]);
+			goto err;
+		}
+	}
+
+	DRM_DEBUG_KMS("MIC has been probed\n");
+
+err:
+	return ret;
+}
+
+static int exynos_mic_remove(struct platform_device *pdev)
+{
+	struct exynos_mic *mic = platform_get_drvdata(pdev);
+	int i;
+
+	drm_bridge_remove(&mic->bridge);
+
+	for (i = NUM_CLKS - 1; i > -1; i--)
+		clk_put(mic->clks[i]);
+
+	return 0;
+}
+
+static const struct of_device_id exynos_mic_of_match[] = {
+	{ .compatible = "samsung,exynos5433-mic" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, exynos_mic_of_match);
+
+struct platform_driver mic_driver = {
+	.probe		= exynos_mic_probe,
+	.remove		= exynos_mic_remove,
+	.driver		= {
+		.name	= "exynos-mic",
+		.owner	= THIS_MODULE,
+		.of_match_table = exynos_mic_of_match,
+	},
+};
