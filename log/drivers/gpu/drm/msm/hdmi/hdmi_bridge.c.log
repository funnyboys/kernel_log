commit a25b988ff83f3ca0d8f5acf855fb1717c1c61a69
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Feb 26 13:24:29 2020 +0200

    drm/bridge: Extend bridge API to disable connector creation
    
    Most bridge drivers create a DRM connector to model the connector at the
    output of the bridge. This model is historical and has worked pretty
    well so far, but causes several issues:
    
    - It prevents supporting more complex display pipelines where DRM
    connector operations are split over multiple components. For instance a
    pipeline with a bridge connected to the DDC signals to read EDID data,
    and another one connected to the HPD signal to detect connection and
    disconnection, will not be possible to support through this model.
    
    - It requires every bridge driver to implement similar connector
    handling code, resulting in code duplication.
    
    - It assumes that a bridge will either be wired to a connector or to
    another bridge, but doesn't support bridges that can be used in both
    positions very well (although there is some ad-hoc support for this in
    the analogix_dp bridge driver).
    
    In order to solve these issues, ownership of the connector should be
    moved to the display controller driver (where it can be implemented
    using helpers provided by the core).
    
    Extend the bridge API to allow disabling connector creation in bridge
    drivers as a first step towards the new model. The new flags argument to
    the bridge .attach() operation allows instructing the bridge driver to
    skip creating a connector. Unconditionally set the new flags argument to
    0 for now to keep the existing behaviour, and modify all existing bridge
    drivers to return an error when connector creation is not requested as
    they don't support this feature yet.
    
    The change is based on the following semantic patch, with manual review
    and edits.
    
    @ rule1 @
    identifier funcs;
    identifier fn;
    @@
     struct drm_bridge_funcs funcs = {
            ...,
            .attach = fn
     };
    
    @ depends on rule1 @
    identifier rule1.fn;
    identifier bridge;
    statement S, S1;
    @@
     int fn(
            struct drm_bridge *bridge
    +       , enum drm_bridge_attach_flags flags
     )
     {
            ... when != S
    +       if (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR) {
    +               DRM_ERROR("Fix bridge driver to make connector optional!");
    +               return -EINVAL;
    +       }
    +
            S1
            ...
     }
    
    @ depends on rule1 @
    identifier rule1.fn;
    identifier bridge, flags;
    expression E1, E2, E3;
    @@
     int fn(
            struct drm_bridge *bridge,
            enum drm_bridge_attach_flags flags
     ) {
     <...
     drm_bridge_attach(E1, E2, E3
    +       , flags
     )
     ...>
     }
    
    @@
    expression E1, E2, E3;
    @@
     drm_bridge_attach(E1, E2, E3
    +       , 0
     )
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Boris Brezillon <boris.brezillon@collabora.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200226112514.12455-10-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index ba81338a9bf8..6e380db9287b 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -287,7 +287,7 @@ struct drm_bridge *msm_hdmi_bridge_init(struct hdmi *hdmi)
 	bridge = &hdmi_bridge->base;
 	bridge->funcs = &msm_hdmi_bridge_funcs;
 
-	ret = drm_bridge_attach(hdmi->encoder, bridge, NULL);
+	ret = drm_bridge_attach(hdmi->encoder, bridge, NULL, 0);
 	if (ret)
 		goto fail;
 

commit feea39a86dfdbad9d02264fd4730277b4e69764e
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Aug 4 08:55:51 2019 +0200

    drm/msm: drop use of drmP.h
    
    Drop the deprecated drmP.h header file, and trim msm_drv.h
    to the relevant include files.
    
    This resulted in a suprisingly many edits as many files relied
    on headers included via msm_drv.h.
    But msm_drv.h is not supposed to carry include files it do not need, so
    the individual files have to include what extra they needs.
    
    v2:
    - Rebased on top of https://gitlab.freedesktop.org/drm/msm.git msm-next
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Sean Paul <sean@poorly.run>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Jordan Crouse <jcrouse@codeaurora.org>
    Cc: Jeykumar Sankaran <jsanka@codeaurora.org>
    Cc: Bruce Wang <bzwang@chromium.org>
    Cc: Shayenne Moura <shayenneluzmoura@gmail.com>
    Cc: Mamta Shukla <mamtashukla555@gmail.com>
    Cc: Jonathan Marek <jonathan@marek.ca>
    Cc: Carsten Behling <carsten.behling@googlemail.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Paul Kocialkowski <paul.kocialkowski@bootlin.com>
    Cc: Sibi Sankar <sibis@codeaurora.org>
    Cc: Todor Tomov <todor.tomov@linaro.org>
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190804065551.GA5211@ravnborg.org

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index c8dbd82854c2..ba81338a9bf8 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -4,6 +4,8 @@
  * Author: Rob Clark <robdclark@gmail.com>
  */
 
+#include <linux/delay.h>
+
 #include "hdmi.h"
 
 struct hdmi_bridge {

commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index 03197b8959ba..c8dbd82854c2 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -1,18 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2013 Red Hat
  * Author: Rob Clark <robdclark@gmail.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "hdmi.h"

commit f164a94c2c87752caeb1a3cbe068c440e7f7921f
Merge: b122153c7198 94520db52fc0
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jan 18 09:20:10 2019 +1000

    Merge tag 'drm-misc-next-2019-01-16' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.1:
    
    UAPI Changes:
     - New fourcc identifier for ARM Framebuffer Compression v1.3
    
    Cross-subsystem Changes:
    
    Core Changes:
     - Reorganisation of drm_device and drm_framebuffer headers
     - Cleanup of the drmP inclusion
     - Fix leaks in the fb-helpers
     - Allow for depth different from bpp in fb-helper fbdev emulation
     - Remove drm_mode_object from drm_display_mode
    
    Driver Changes:
     - Add reflection properties to rockchip
     - a bunch of fixes for virtio
     - a bunch of fixes for dp_mst and drivers using it, and introduction of a
       new refcounting scheme
     - Convertion of bochs to atomic and generic fbdev emulation
     - Allow meson to remove the firmware framebuffers
    
    [airlied: patch rcar-du to add drm_modes.h]
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190116200428.u2n4jbk4mzza7n6e@flea

commit 63f8f3badf799c8b63ff33a489886bc138ce5d09
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Apr 6 17:39:01 2018 +0300

    drm: bridge: Constify mode arguments to bridge .mode_set() operation
    
    The mode and ajusted_mode passed to the bridge .mode_set() operation
    should never be modified by the bridge (and are not in any of the
    existing bridge drivers). Make them const to make this clear.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index 98d61c690260..b42feb80531b 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -207,8 +207,8 @@ static void msm_hdmi_bridge_post_disable(struct drm_bridge *bridge)
 }
 
 static void msm_hdmi_bridge_mode_set(struct drm_bridge *bridge,
-		 struct drm_display_mode *mode,
-		 struct drm_display_mode *adjusted_mode)
+		 const struct drm_display_mode *mode,
+		 const struct drm_display_mode *adjusted_mode)
 {
 	struct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);
 	struct hdmi *hdmi = hdmi_bridge->hdmi;

commit 23d19ba06b9c5614d6457f5fed349ec8f6d4dac9
Merge: 7d0250ed8e69 e3d093070eb0
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Fri Jan 11 16:32:10 2019 +0100

    Merge drm/drm-next into drm-misc-next
    
    drm-next has been forwarded to 5.0-rc1, and we need it to apply the damage
    helper for dirtyfb series from Noralf Trønnes.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>

commit 13d0add333afea7b2fef77473232b10dea3627dd
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jan 8 19:28:25 2019 +0200

    drm/edid: Pass connector to AVI infoframe functions
    
    Make life easier for drivers by simply passing the connector
    to drm_hdmi_avi_infoframe_from_display_mode() and
    drm_hdmi_avi_infoframe_quant_range(). That way drivers don't
    need to worry about is_hdmi2_sink mess.
    
    v2: Make is_hdmi2_sink() return true for sil-sii8620
        Adapt to omap/vc4 changes
    
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: Archit Taneja <architt@codeaurora.org>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Laurent Pinchart <Laurent.pinchart@ideasonboard.com>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Joonyoung Shim <jy0922.shim@samsung.com>
    Cc: Seung-Woo Kim <sw0312.kim@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: CK Hu <ck.hu@mediatek.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Sandy Huang <hjc@rock-chips.com>
    Cc: "Heiko Stübner" <heiko@sntech.de>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Vincent Abriou <vincent.abriou@st.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Ilia Mirkin <imirkin@alum.mit.edu>
    Cc: amd-gfx@lists.freedesktop.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: linux-tegra@vger.kernel.org
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190108172828.15184-1-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index 7e357077ed26..5ed4cab2819f 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -101,7 +101,8 @@ static void msm_hdmi_config_avi_infoframe(struct hdmi *hdmi)
 	u32 val;
 	int len;
 
-	drm_hdmi_avi_infoframe_from_display_mode(&frame.avi, mode, false);
+	drm_hdmi_avi_infoframe_from_display_mode(&frame.avi,
+						 hdmi->connector, mode);
 
 	len = hdmi_infoframe_pack(&frame, buffer, sizeof(buffer));
 	if (len < 0) {

commit 6a41da17e87dee2936645d9a51fccf932fa42981
Author: Mamta Shukla <mamtashukla555@gmail.com>
Date:   Sat Oct 20 23:19:26 2018 +0530

    drm: msm: Use DRM_DEV_* instead of dev_*
    
    Use DRM_DEV_INFO/ERROR/WARN instead of dev_info/err/debug to generate
    drm-formatted specific log messages so that it will be easy to
    differentiate in case of multiple instances of driver.
    
    Signed-off-by: Mamta Shukla <mamtashukla555@gmail.com>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index 7e357077ed26..98d61c690260 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -40,7 +40,7 @@ static void msm_hdmi_power_on(struct drm_bridge *bridge)
 	for (i = 0; i < config->pwr_reg_cnt; i++) {
 		ret = regulator_enable(hdmi->pwr_regs[i]);
 		if (ret) {
-			dev_err(dev->dev, "failed to enable pwr regulator: %s (%d)\n",
+			DRM_DEV_ERROR(dev->dev, "failed to enable pwr regulator: %s (%d)\n",
 					config->pwr_reg_names[i], ret);
 		}
 	}
@@ -49,7 +49,7 @@ static void msm_hdmi_power_on(struct drm_bridge *bridge)
 		DBG("pixclock: %lu", hdmi->pixclock);
 		ret = clk_set_rate(hdmi->pwr_clks[0], hdmi->pixclock);
 		if (ret) {
-			dev_err(dev->dev, "failed to set pixel clk: %s (%d)\n",
+			DRM_DEV_ERROR(dev->dev, "failed to set pixel clk: %s (%d)\n",
 					config->pwr_clk_names[0], ret);
 		}
 	}
@@ -57,7 +57,7 @@ static void msm_hdmi_power_on(struct drm_bridge *bridge)
 	for (i = 0; i < config->pwr_clk_cnt; i++) {
 		ret = clk_prepare_enable(hdmi->pwr_clks[i]);
 		if (ret) {
-			dev_err(dev->dev, "failed to enable pwr clk: %s (%d)\n",
+			DRM_DEV_ERROR(dev->dev, "failed to enable pwr clk: %s (%d)\n",
 					config->pwr_clk_names[i], ret);
 		}
 	}
@@ -82,7 +82,7 @@ static void power_off(struct drm_bridge *bridge)
 	for (i = 0; i < config->pwr_reg_cnt; i++) {
 		ret = regulator_disable(hdmi->pwr_regs[i]);
 		if (ret) {
-			dev_err(dev->dev, "failed to disable pwr regulator: %s (%d)\n",
+			DRM_DEV_ERROR(dev->dev, "failed to disable pwr regulator: %s (%d)\n",
 					config->pwr_reg_names[i], ret);
 		}
 	}
@@ -105,7 +105,7 @@ static void msm_hdmi_config_avi_infoframe(struct hdmi *hdmi)
 
 	len = hdmi_infoframe_pack(&frame, buffer, sizeof(buffer));
 	if (len < 0) {
-		dev_err(&hdmi->pdev->dev,
+		DRM_DEV_ERROR(&hdmi->pdev->dev,
 			"failed to configure avi infoframe\n");
 		return;
 	}

commit cfcfb65ad15a1b43cf5cd434c57966fae03db96b
Merge: 7c0059dd832c d1f08d821762
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Aug 25 09:29:45 2017 +1000

    Merge tag 'drm-msm-next-2017-08-22' of git://people.freedesktop.org/~robclark/linux into drm-next
    
    Updates for 4.14..  I have some further patches from Jordan to add
    multiple priority levels and pre-emption, but those will probably be
    for 4.15 to give me time for the mesa parts.
    
    * tag 'drm-msm-next-2017-08-22' of git://people.freedesktop.org/~robclark/linux:
      drm/msm/mdp5: mark runtime_pm functions as __maybe_unused
      drm/msm: remove unused variable
      drm/msm/mdp5: make helper function static
      drm/msm: make msm_framebuffer_init() static
      drm/msm: add helper to allocate stolen fb
      drm/msm: don't track fbdev's gem object separately
      drm/msm: add modeset module param
      drm/msm/mdp5: add tracking for clk enable-count
      drm/msm: remove unused define
      drm/msm: Add a helper function for in-kernel buffer allocations
      drm/msm: Attach the GPU MMU when it is created
      drm/msm: Add A5XX hardware fault detection
      drm/msm: Remove uneeded platform dev members
      drm/msm/mdp5: Set up runtime PM for MDSS
      drm/msm/mdp5: Write to SMP registers even if allocations don't change
      drm/msm/mdp5: Don't use mode_set helper funcs for encoders and CRTCs
      drm/msm/dsi: Implement RPM suspend/resume callbacks
      drm/msm/dsi: Set up runtime PM for DSI
      drm/msm/hdmi: Set up runtime PM for HDMI
      drm/msm/mdp5: Use runtime PM get/put API instead of toggling clocks

commit 6ed9ed484d04c2f6db0f68b0a31ef24db27d6454
Author: Archit Taneja <architt@codeaurora.org>
Date:   Fri Jul 28 16:17:02 2017 +0530

    drm/msm/hdmi: Set up runtime PM for HDMI
    
    Enable rudimentary runtime PM in the HDMI driver. We can't really do
    agressive PM toggling at the moment because we need to leave the hpd
    clocks enabled all the time. There isn't much benefit of creating
    suspend/resume ops to toggle clocks either.
    
    We just make sure that we configure the power domain in the HDMI bridge's
    enable/disable paths, and the HDMI connector's detect() op.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index ae40e7179d4f..e9b5e886e747 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -35,6 +35,8 @@ static void msm_hdmi_power_on(struct drm_bridge *bridge)
 	const struct hdmi_platform_config *config = hdmi->config;
 	int i, ret;
 
+	pm_runtime_get_sync(&hdmi->pdev->dev);
+
 	for (i = 0; i < config->pwr_reg_cnt; i++) {
 		ret = regulator_enable(hdmi->pwr_regs[i]);
 		if (ret) {
@@ -84,6 +86,8 @@ static void power_off(struct drm_bridge *bridge)
 					config->pwr_reg_names[i], ret);
 		}
 	}
+
+	pm_runtime_put_autosuspend(&hdmi->pdev->dev);
 }
 
 #define AVI_IFRAME_LINE_NUMBER 1

commit 0c1f528cb13708ff3ba462a5c757d5588fc47d36
Author: Shashank Sharma <shashank.sharma@intel.com>
Date:   Thu Jul 13 21:03:07 2017 +0530

    drm: handle HDMI 2.0 VICs in AVI info-frames
    
    HDMI 1.4b support the CEA video modes as per range of CEA-861-D (VIC 1-64).
    For any other mode, the VIC filed in AVI infoframes should be 0.
    HDMI 2.0 sinks, support video modes range as per CEA-861-F spec, which is
    extended to (VIC 1-107).
    
    This patch adds a bool input variable, which indicates if the connected
    sink is a HDMI 2.0 sink or not. This will make sure that we don't pass a
    HDMI 2.0 VIC to a HDMI 1.4 sink.
    
    This patch touches all drm drivers, who are callers of this function
    drm_hdmi_avi_infoframe_from_display_mode but to make sure there is
    no change in current behavior, is_hdmi2 is kept as false.
    
    In case of I915 driver, this patch:
    - checks if the connected display is HDMI 2.0.
    - HDMI infoframes carry one of this two type of information:
            - VIC for 4K modes for HDMI 1.4 sinks
            - S3D information for S3D modes
      As CEA-861-F has already defined VICs for 4K videomodes, this
      patch doesn't allow sending HDMI infoframes for HDMI 2.0 sinks,
      until the mode is 3D.
    
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Cc: Jose Abreu <jose.abreu@synopsys.com>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    
    PS: This patch touches a few lines in few files, which were
    already above 80 char, so checkpatch gives 80 char warning again.
    - gpu/drm/omapdrm/omap_encoder.c
    - gpu/drm/i915/intel_sdvo.c
    
    V2: Rebase, Added r-b from Andrzej
    V3: Addressed review comment from Ville:
            - Do not send VICs in both AVI-IF and HDMI-IF
              send only one of it.
    V4: Rebase
    V5: Added r-b from Neil.
        Addressed review comments from Ville
        - Do not block HDMI vendor IF, instead check for VIC while
          handling AVI infoframes
    V6: Rebase
    V7: Rebase
    
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Signed-off-by: Shashank Sharma <shashank.sharma@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1499960000-9232-2-git-send-email-shashank.sharma@intel.com
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index ae40e7179d4f..13ac822dee5d 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -97,7 +97,7 @@ static void msm_hdmi_config_avi_infoframe(struct hdmi *hdmi)
 	u32 val;
 	int len;
 
-	drm_hdmi_avi_infoframe_from_display_mode(&frame.avi, mode);
+	drm_hdmi_avi_infoframe_from_display_mode(&frame.avi, mode, false);
 
 	len = hdmi_infoframe_pack(&frame, buffer, sizeof(buffer));
 	if (len < 0) {

commit 816fa34c051492c7f115ad2fd91c9e723d7fc298
Author: Archit Taneja <architt@codeaurora.org>
Date:   Fri Jun 16 10:39:36 2017 +0530

    drm/msm/hdmi: Fix HDMI pink strip issue seen on 8x96
    
    A 2 pixel wide pink strip was observed on the left end of some HDMI
    monitors configured in a HDMI mode.
    
    It turned out that we were missing out on configuring AVI infoframes, and
    unlike APQ8064, the 8x96 HDMI H/W seems to be sensitive to that.
    
    Add configuration of AVI infoframes. While at it, make sure that
    hdmi_audio_update is only called when we've detected that the monitor
    supports HDMI.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index 4e6d1bf27474..ae40e7179d4f 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -86,6 +86,65 @@ static void power_off(struct drm_bridge *bridge)
 	}
 }
 
+#define AVI_IFRAME_LINE_NUMBER 1
+
+static void msm_hdmi_config_avi_infoframe(struct hdmi *hdmi)
+{
+	struct drm_crtc *crtc = hdmi->encoder->crtc;
+	const struct drm_display_mode *mode = &crtc->state->adjusted_mode;
+	union hdmi_infoframe frame;
+	u8 buffer[HDMI_INFOFRAME_SIZE(AVI)];
+	u32 val;
+	int len;
+
+	drm_hdmi_avi_infoframe_from_display_mode(&frame.avi, mode);
+
+	len = hdmi_infoframe_pack(&frame, buffer, sizeof(buffer));
+	if (len < 0) {
+		dev_err(&hdmi->pdev->dev,
+			"failed to configure avi infoframe\n");
+		return;
+	}
+
+	/*
+	 * the AVI_INFOx registers don't map exactly to how the AVI infoframes
+	 * are packed according to the spec. The checksum from the header is
+	 * written to the LSB byte of AVI_INFO0 and the version is written to
+	 * the third byte from the LSB of AVI_INFO3
+	 */
+	hdmi_write(hdmi, REG_HDMI_AVI_INFO(0),
+		   buffer[3] |
+		   buffer[4] << 8 |
+		   buffer[5] << 16 |
+		   buffer[6] << 24);
+
+	hdmi_write(hdmi, REG_HDMI_AVI_INFO(1),
+		   buffer[7] |
+		   buffer[8] << 8 |
+		   buffer[9] << 16 |
+		   buffer[10] << 24);
+
+	hdmi_write(hdmi, REG_HDMI_AVI_INFO(2),
+		   buffer[11] |
+		   buffer[12] << 8 |
+		   buffer[13] << 16 |
+		   buffer[14] << 24);
+
+	hdmi_write(hdmi, REG_HDMI_AVI_INFO(3),
+		   buffer[15] |
+		   buffer[16] << 8 |
+		   buffer[1] << 24);
+
+	hdmi_write(hdmi, REG_HDMI_INFOFRAME_CTRL0,
+		   HDMI_INFOFRAME_CTRL0_AVI_SEND |
+		   HDMI_INFOFRAME_CTRL0_AVI_CONT);
+
+	val = hdmi_read(hdmi, REG_HDMI_INFOFRAME_CTRL1);
+	val &= ~HDMI_INFOFRAME_CTRL1_AVI_INFO_LINE__MASK;
+	val |= HDMI_INFOFRAME_CTRL1_AVI_INFO_LINE(AVI_IFRAME_LINE_NUMBER);
+	hdmi_write(hdmi, REG_HDMI_INFOFRAME_CTRL1, val);
+}
+
 static void msm_hdmi_bridge_pre_enable(struct drm_bridge *bridge)
 {
 	struct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);
@@ -98,7 +157,10 @@ static void msm_hdmi_bridge_pre_enable(struct drm_bridge *bridge)
 		msm_hdmi_phy_resource_enable(phy);
 		msm_hdmi_power_on(bridge);
 		hdmi->power_on = true;
-		msm_hdmi_audio_update(hdmi);
+		if (hdmi->hdmi_mode) {
+			msm_hdmi_config_avi_infoframe(hdmi);
+			msm_hdmi_audio_update(hdmi);
+		}
 	}
 
 	msm_hdmi_phy_powerup(phy, hdmi->pixclock);
@@ -134,7 +196,8 @@ static void msm_hdmi_bridge_post_disable(struct drm_bridge *bridge)
 	if (hdmi->power_on) {
 		power_off(bridge);
 		hdmi->power_on = false;
-		msm_hdmi_audio_update(hdmi);
+		if (hdmi->hdmi_mode)
+			msm_hdmi_audio_update(hdmi);
 		msm_hdmi_phy_resource_disable(phy);
 	}
 }
@@ -196,7 +259,8 @@ static void msm_hdmi_bridge_mode_set(struct drm_bridge *bridge,
 	DBG("frame_ctrl=%08x", frame_ctrl);
 	hdmi_write(hdmi, REG_HDMI_FRAME_CTRL, frame_ctrl);
 
-	msm_hdmi_audio_update(hdmi);
+	if (hdmi->hdmi_mode)
+		msm_hdmi_audio_update(hdmi);
 }
 
 static const struct drm_bridge_funcs msm_hdmi_bridge_funcs = {

commit 3bb80f249525c059572d4bc89ac77ac2e511bcbe
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Nov 28 17:59:08 2016 +0200

    drm: bridge: Link encoder and bridge in core code
    
    Instead of linking encoders and bridges in every driver (and getting it
    wrong half of the time, as many drivers forget to set the drm_bridge
    encoder pointer), do so in core code. The drm_bridge_attach() function
    needs the encoder and optional previous bridge to perform that task,
    update all the callers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Stefan Agner <stefan@agner.ch> # For DCU
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com> # For atmel-hlcdc
    Acked-by: Vincent Abriou <vincent.abriou@st.com> # For STI
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com> # For sun4i
    Acked-by: Xinliang Liu <z.liuxinliang@hisilicon.com> # For hisilicon
    Acked-by: Jyri Sarha <jsarha@ti.com> # For tilcdc
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481709550-29226-4-git-send-email-laurent.pinchart+renesas@ideasonboard.com

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index bacbd5d8df0e..4e6d1bf27474 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -227,7 +227,7 @@ struct drm_bridge *msm_hdmi_bridge_init(struct hdmi *hdmi)
 	bridge = &hdmi_bridge->base;
 	bridge->funcs = &msm_hdmi_bridge_funcs;
 
-	ret = drm_bridge_attach(hdmi->dev, bridge);
+	ret = drm_bridge_attach(hdmi->encoder, bridge, NULL);
 	if (ret)
 		goto fail;
 

commit fcda50c8f484cf1140232c8444470449f0619db9
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Feb 22 22:08:35 2016 +0100

    drm/msm: rename hdmi symbols
    
    Global symbols in the kernel should be prefixed by the name
    of the subsystem and/or driver to avoid conflicts when all
    code is built-in.
    
    In this case, function names like 'hdmi_register' or 'hdmi_set_mode'
    are way too generic for an MSM specific DRM driver, so I'm renaming
    them all to msm_hdmi_* here.
    
    I also rename a lot of the 'static' symbols along with the global
    names for consistency, even though those are relatively harmless;
    they might only be slightly confusing when they show up in
    backtraces.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index 310d92d06229..bacbd5d8df0e 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -23,11 +23,11 @@ struct hdmi_bridge {
 };
 #define to_hdmi_bridge(x) container_of(x, struct hdmi_bridge, base)
 
-void hdmi_bridge_destroy(struct drm_bridge *bridge)
+void msm_hdmi_bridge_destroy(struct drm_bridge *bridge)
 {
 }
 
-static void power_on(struct drm_bridge *bridge)
+static void msm_hdmi_power_on(struct drm_bridge *bridge)
 {
 	struct drm_device *dev = bridge->dev;
 	struct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);
@@ -86,7 +86,7 @@ static void power_off(struct drm_bridge *bridge)
 	}
 }
 
-static void hdmi_bridge_pre_enable(struct drm_bridge *bridge)
+static void msm_hdmi_bridge_pre_enable(struct drm_bridge *bridge)
 {
 	struct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);
 	struct hdmi *hdmi = hdmi_bridge->hdmi;
@@ -95,51 +95,51 @@ static void hdmi_bridge_pre_enable(struct drm_bridge *bridge)
 	DBG("power up");
 
 	if (!hdmi->power_on) {
-		hdmi_phy_resource_enable(phy);
-		power_on(bridge);
+		msm_hdmi_phy_resource_enable(phy);
+		msm_hdmi_power_on(bridge);
 		hdmi->power_on = true;
-		hdmi_audio_update(hdmi);
+		msm_hdmi_audio_update(hdmi);
 	}
 
-	hdmi_phy_powerup(phy, hdmi->pixclock);
+	msm_hdmi_phy_powerup(phy, hdmi->pixclock);
 
-	hdmi_set_mode(hdmi, true);
+	msm_hdmi_set_mode(hdmi, true);
 
 	if (hdmi->hdcp_ctrl)
-		hdmi_hdcp_on(hdmi->hdcp_ctrl);
+		msm_hdmi_hdcp_on(hdmi->hdcp_ctrl);
 }
 
-static void hdmi_bridge_enable(struct drm_bridge *bridge)
+static void msm_hdmi_bridge_enable(struct drm_bridge *bridge)
 {
 }
 
-static void hdmi_bridge_disable(struct drm_bridge *bridge)
+static void msm_hdmi_bridge_disable(struct drm_bridge *bridge)
 {
 }
 
-static void hdmi_bridge_post_disable(struct drm_bridge *bridge)
+static void msm_hdmi_bridge_post_disable(struct drm_bridge *bridge)
 {
 	struct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);
 	struct hdmi *hdmi = hdmi_bridge->hdmi;
 	struct hdmi_phy *phy = hdmi->phy;
 
 	if (hdmi->hdcp_ctrl)
-		hdmi_hdcp_off(hdmi->hdcp_ctrl);
+		msm_hdmi_hdcp_off(hdmi->hdcp_ctrl);
 
 	DBG("power down");
-	hdmi_set_mode(hdmi, false);
+	msm_hdmi_set_mode(hdmi, false);
 
-	hdmi_phy_powerdown(phy);
+	msm_hdmi_phy_powerdown(phy);
 
 	if (hdmi->power_on) {
 		power_off(bridge);
 		hdmi->power_on = false;
-		hdmi_audio_update(hdmi);
-		hdmi_phy_resource_disable(phy);
+		msm_hdmi_audio_update(hdmi);
+		msm_hdmi_phy_resource_disable(phy);
 	}
 }
 
-static void hdmi_bridge_mode_set(struct drm_bridge *bridge,
+static void msm_hdmi_bridge_mode_set(struct drm_bridge *bridge,
 		 struct drm_display_mode *mode,
 		 struct drm_display_mode *adjusted_mode)
 {
@@ -196,20 +196,20 @@ static void hdmi_bridge_mode_set(struct drm_bridge *bridge,
 	DBG("frame_ctrl=%08x", frame_ctrl);
 	hdmi_write(hdmi, REG_HDMI_FRAME_CTRL, frame_ctrl);
 
-	hdmi_audio_update(hdmi);
+	msm_hdmi_audio_update(hdmi);
 }
 
-static const struct drm_bridge_funcs hdmi_bridge_funcs = {
-		.pre_enable = hdmi_bridge_pre_enable,
-		.enable = hdmi_bridge_enable,
-		.disable = hdmi_bridge_disable,
-		.post_disable = hdmi_bridge_post_disable,
-		.mode_set = hdmi_bridge_mode_set,
+static const struct drm_bridge_funcs msm_hdmi_bridge_funcs = {
+		.pre_enable = msm_hdmi_bridge_pre_enable,
+		.enable = msm_hdmi_bridge_enable,
+		.disable = msm_hdmi_bridge_disable,
+		.post_disable = msm_hdmi_bridge_post_disable,
+		.mode_set = msm_hdmi_bridge_mode_set,
 };
 
 
 /* initialize bridge */
-struct drm_bridge *hdmi_bridge_init(struct hdmi *hdmi)
+struct drm_bridge *msm_hdmi_bridge_init(struct hdmi *hdmi)
 {
 	struct drm_bridge *bridge = NULL;
 	struct hdmi_bridge *hdmi_bridge;
@@ -225,7 +225,7 @@ struct drm_bridge *hdmi_bridge_init(struct hdmi *hdmi)
 	hdmi_bridge->hdmi = hdmi;
 
 	bridge = &hdmi_bridge->base;
-	bridge->funcs = &hdmi_bridge_funcs;
+	bridge->funcs = &msm_hdmi_bridge_funcs;
 
 	ret = drm_bridge_attach(hdmi->dev, bridge);
 	if (ret)
@@ -235,7 +235,7 @@ struct drm_bridge *hdmi_bridge_init(struct hdmi *hdmi)
 
 fail:
 	if (bridge)
-		hdmi_bridge_destroy(bridge);
+		msm_hdmi_bridge_destroy(bridge);
 
 	return ERR_PTR(ret);
 }

commit ba3d7bf3a7abdadb803a2455b04d54a4d3b32124
Author: Archit Taneja <architt@codeaurora.org>
Date:   Thu Feb 25 11:22:41 2016 +0530

    drm/msm/hdmi: Convert PHY files according to new design
    
    Remove the old PHY ops managed by hdmi_platform_config and use them as ops
    provided by the HDMI PHY driver.
    
    Remove the old HDMI 8960 PLL code that used the top level HDMI TX mmio
    base.
    
    NOTE: With this commit, HDMI functionality will break until the HDMI
    PHY/PLL register offsets in hdmi.xml.h aren't updated to be used as
    separate domains.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index 92b69ae8caf9..310d92d06229 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -95,13 +95,13 @@ static void hdmi_bridge_pre_enable(struct drm_bridge *bridge)
 	DBG("power up");
 
 	if (!hdmi->power_on) {
+		hdmi_phy_resource_enable(phy);
 		power_on(bridge);
 		hdmi->power_on = true;
 		hdmi_audio_update(hdmi);
 	}
 
-	if (phy)
-		phy->funcs->powerup(phy, hdmi->pixclock);
+	hdmi_phy_powerup(phy, hdmi->pixclock);
 
 	hdmi_set_mode(hdmi, true);
 
@@ -129,13 +129,13 @@ static void hdmi_bridge_post_disable(struct drm_bridge *bridge)
 	DBG("power down");
 	hdmi_set_mode(hdmi, false);
 
-	if (phy)
-		phy->funcs->powerdown(phy);
+	hdmi_phy_powerdown(phy);
 
 	if (hdmi->power_on) {
 		power_off(bridge);
 		hdmi->power_on = false;
 		hdmi_audio_update(hdmi);
+		hdmi_phy_resource_disable(phy);
 	}
 }
 

commit 3a84f8469e2687b9fdcf83d615b8001a2443566a
Author: Stephane Viau <sviau@codeaurora.org>
Date:   Fri Jun 19 16:04:47 2015 -0400

    drm/msm: Add support for msm8x94
    
    This change adds the MDP and HDMI support for msm8x94.
    Note that HDMI PHY registers are not being accessed anymore from
    the driver.
    
    Signed-off-by: Stephane Viau <sviau@codeaurora.org>
    [rename compatible s/8x94/8994/ since preference is to not trust the
    marketing folks who invent chip #'s but instead name things after the
    lead chip.. we should rename some 80XY to 89XY to standardize on the
    lead chip but leave that for another patch.  Also, update dt bindings
    doc]
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index 1dd093e3451c..92b69ae8caf9 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -100,7 +100,9 @@ static void hdmi_bridge_pre_enable(struct drm_bridge *bridge)
 		hdmi_audio_update(hdmi);
 	}
 
-	phy->funcs->powerup(phy, hdmi->pixclock);
+	if (phy)
+		phy->funcs->powerup(phy, hdmi->pixclock);
+
 	hdmi_set_mode(hdmi, true);
 
 	if (hdmi->hdcp_ctrl)
@@ -126,7 +128,9 @@ static void hdmi_bridge_post_disable(struct drm_bridge *bridge)
 
 	DBG("power down");
 	hdmi_set_mode(hdmi, false);
-	phy->funcs->powerdown(phy);
+
+	if (phy)
+		phy->funcs->powerdown(phy);
 
 	if (hdmi->power_on) {
 		power_off(bridge);

commit c6a57a50ad562a2e6fc6ac3218b710caea73a58b
Author: jilai wang <jilaiw@codeaurora.org>
Date:   Thu Apr 2 17:49:01 2015 -0400

    drm/msm/hdmi: add hdmi hdcp support (V3)
    
    Add HDMI HDCP support including HDCP PartI/II/III authentication.
    V1: Initial Change
    V2: Address Bjorn&Rob's comments
        Refactor the authentication process to use single work instead
        of multiple work for different authentication stages.
    V3: Update to align with qcom SCM api.
    
    Signed-off-by: Jilai Wang <jilaiw@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index a7a1d8267cf0..1dd093e3451c 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -102,6 +102,9 @@ static void hdmi_bridge_pre_enable(struct drm_bridge *bridge)
 
 	phy->funcs->powerup(phy, hdmi->pixclock);
 	hdmi_set_mode(hdmi, true);
+
+	if (hdmi->hdcp_ctrl)
+		hdmi_hdcp_on(hdmi->hdcp_ctrl);
 }
 
 static void hdmi_bridge_enable(struct drm_bridge *bridge)
@@ -118,6 +121,9 @@ static void hdmi_bridge_post_disable(struct drm_bridge *bridge)
 	struct hdmi *hdmi = hdmi_bridge->hdmi;
 	struct hdmi_phy *phy = hdmi->phy;
 
+	if (hdmi->hdcp_ctrl)
+		hdmi_hdcp_off(hdmi->hdcp_ctrl);
+
 	DBG("power down");
 	hdmi_set_mode(hdmi, false);
 	phy->funcs->powerdown(phy);
@@ -142,8 +148,6 @@ static void hdmi_bridge_mode_set(struct drm_bridge *bridge,
 
 	hdmi->pixclock = mode->clock * 1000;
 
-	hdmi->hdmi_mode = drm_match_cea_mode(mode) > 1;
-
 	hstart = mode->htotal - mode->hsync_start;
 	hend   = mode->htotal - mode->hsync_start + mode->hdisplay;
 

commit 475ac0a13dfe108b80fbb89f54414de1a07a0d25
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Jan 31 11:45:09 2015 -0500

    drm/msm/hdmi: fix memory leak after bridge changes
    
    3d3f8b1f8b ("drm/bridge: make bridge registration independent of drm
    flow") resulted that the hdmi bridge object would be leaked at teardown.
    Just switch over to devm_kzalloc() as the easy way to solve this.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index d6f8d5818e18..a7a1d8267cf0 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -25,8 +25,6 @@ struct hdmi_bridge {
 
 void hdmi_bridge_destroy(struct drm_bridge *bridge)
 {
-	struct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);
-	kfree(hdmi_bridge);
 }
 
 static void power_on(struct drm_bridge *bridge)
@@ -209,7 +207,8 @@ struct drm_bridge *hdmi_bridge_init(struct hdmi *hdmi)
 	struct hdmi_bridge *hdmi_bridge;
 	int ret;
 
-	hdmi_bridge = kzalloc(sizeof(*hdmi_bridge), GFP_KERNEL);
+	hdmi_bridge = devm_kzalloc(hdmi->dev->dev,
+			sizeof(*hdmi_bridge), GFP_KERNEL);
 	if (!hdmi_bridge) {
 		ret = -ENOMEM;
 		goto fail;
@@ -220,7 +219,9 @@ struct drm_bridge *hdmi_bridge_init(struct hdmi *hdmi)
 	bridge = &hdmi_bridge->base;
 	bridge->funcs = &hdmi_bridge_funcs;
 
-	drm_bridge_attach(hdmi->dev, bridge);
+	ret = drm_bridge_attach(hdmi->dev, bridge);
+	if (ret)
+		goto fail;
 
 	return bridge;
 

commit 3d3f8b1f8b62c3a010976269df454baa9246fc65
Author: Ajay Kumar <ajaykumar.rs@samsung.com>
Date:   Tue Jan 20 22:08:44 2015 +0530

    drm/bridge: make bridge registration independent of drm flow
    
    Currently, third party bridge drivers(ptn3460) are dependent
    on the corresponding encoder driver init, since bridge driver
    needs a drm_device pointer to finish drm initializations.
    The encoder driver passes the drm_device pointer to the
    bridge driver. Because of this dependency, third party drivers
    like ptn3460 doesn't adhere to the driver model.
    
    In this patch, we reframe the bridge registration framework
    so that bridge initialization is split into 2 steps, and
    bridge registration happens independent of drm flow:
    --Step 1: gather all the bridge settings independent of drm and
              add the bridge onto a global list of bridges.
    --Step 2: when the encoder driver is probed, call drm_bridge_attach
              for the corresponding bridge so that the bridge receives
              drm_device pointer and continues with connector and other
              drm initializations.
    
    The old set of bridge helpers are removed, and a set of new helpers
    are added to accomplish the 2 step initialization.
    
    The bridge devices register themselves onto global list of bridges
    when they get probed by calling "drm_bridge_add".
    
    The parent encoder driver waits till the bridge is available
    in the lookup table(by calling "of_drm_find_bridge") and then
    continues with its initialization.
    
    The encoder driver should also call "drm_bridge_attach" to pass
    on the drm_device to the bridge object.
    
    drm_bridge_attach inturn calls "bridge->funcs->attach" so that
    bridge can continue with drm related initializations.
    
    Signed-off-by: Ajay Kumar <ajaykumar.rs@samsung.com>
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Tested-by: Rahul Sharma <rahul.sharma@samsung.com>
    Tested-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Tested-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Tested-by: Sjoerd Simons <sjoerd.simons@collabora.co.uk>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index 52ed2b53b246..d6f8d5818e18 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -23,10 +23,9 @@ struct hdmi_bridge {
 };
 #define to_hdmi_bridge(x) container_of(x, struct hdmi_bridge, base)
 
-static void hdmi_bridge_destroy(struct drm_bridge *bridge)
+void hdmi_bridge_destroy(struct drm_bridge *bridge)
 {
 	struct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);
-	drm_bridge_cleanup(bridge);
 	kfree(hdmi_bridge);
 }
 
@@ -200,7 +199,6 @@ static const struct drm_bridge_funcs hdmi_bridge_funcs = {
 		.disable = hdmi_bridge_disable,
 		.post_disable = hdmi_bridge_post_disable,
 		.mode_set = hdmi_bridge_mode_set,
-		.destroy = hdmi_bridge_destroy,
 };
 
 
@@ -222,7 +220,7 @@ struct drm_bridge *hdmi_bridge_init(struct hdmi *hdmi)
 	bridge = &hdmi_bridge->base;
 	bridge->funcs = &hdmi_bridge_funcs;
 
-	drm_bridge_init(hdmi->dev, bridge);
+	drm_bridge_attach(hdmi->dev, bridge);
 
 	return bridge;
 

commit b07b90fd178a4797b0454ead491b717b41046bee
Author: Ajay Kumar <ajaykumar.rs@samsung.com>
Date:   Tue Jan 20 22:08:43 2015 +0530

    drm/bridge: do not pass drm_bridge_funcs to drm_bridge_init
    
    Assign the pointer to bridge ops structure(drm_bridge_funcs) in
    the bridge driver itself, instead of passing it to drm_bridge_init.
    
    This will allow bridge driver developer to pack bridge private
    information inside the bridge object and pass only the drm-relevant
    information to drm_bridge_init.
    
    Signed-off-by: Ajay Kumar <ajaykumar.rs@samsung.com>
    Acked-by: Inki Dae <inki.dae@samsung.com>
    Tested-by: Rahul Sharma <rahul.sharma@samsung.com>
    Tested-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Tested-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Tested-by: Sjoerd Simons <sjoerd.simons@collabora.co.uk>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index 6902ad6da710..52ed2b53b246 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -220,8 +220,9 @@ struct drm_bridge *hdmi_bridge_init(struct hdmi *hdmi)
 	hdmi_bridge->hdmi = hdmi;
 
 	bridge = &hdmi_bridge->base;
+	bridge->funcs = &hdmi_bridge_funcs;
 
-	drm_bridge_init(hdmi->dev, bridge, &hdmi_bridge_funcs);
+	drm_bridge_init(hdmi->dev, bridge);
 
 	return bridge;
 

commit d1a717bd2719d6416fdc5e9b65786f17c6c3facb
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Nov 18 08:40:44 2014 -0500

    drm/msm/hdmi: remove useless kref
    
    A left-over from prior to component framework.  The original intent was
    to deal with hdmi getting unloaded before the master component, but that
    isn't really going to work anyways.  These days with the component
    framework taking care to unload the master component first, we don't
    have to worry about this.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index f6cf745c249e..6902ad6da710 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -26,7 +26,6 @@ struct hdmi_bridge {
 static void hdmi_bridge_destroy(struct drm_bridge *bridge)
 {
 	struct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);
-	hdmi_unreference(hdmi_bridge->hdmi);
 	drm_bridge_cleanup(bridge);
 	kfree(hdmi_bridge);
 }
@@ -218,7 +217,7 @@ struct drm_bridge *hdmi_bridge_init(struct hdmi *hdmi)
 		goto fail;
 	}
 
-	hdmi_bridge->hdmi = hdmi_reference(hdmi);
+	hdmi_bridge->hdmi = hdmi;
 
 	bridge = &hdmi_bridge->base;
 

commit c0c0d9eeeb8df43964601a2c4666f0c49bedacb4
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Dec 11 14:44:02 2013 -0500

    drm/msm: hdmi audio support
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index 7d10e55403c6..f6cf745c249e 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -19,11 +19,7 @@
 
 struct hdmi_bridge {
 	struct drm_bridge base;
-
 	struct hdmi *hdmi;
-	bool power_on;
-
-	unsigned long int pixclock;
 };
 #define to_hdmi_bridge(x) container_of(x, struct hdmi_bridge, base)
 
@@ -52,8 +48,8 @@ static void power_on(struct drm_bridge *bridge)
 	}
 
 	if (config->pwr_clk_cnt > 0) {
-		DBG("pixclock: %lu", hdmi_bridge->pixclock);
-		ret = clk_set_rate(hdmi->pwr_clks[0], hdmi_bridge->pixclock);
+		DBG("pixclock: %lu", hdmi->pixclock);
+		ret = clk_set_rate(hdmi->pwr_clks[0], hdmi->pixclock);
 		if (ret) {
 			dev_err(dev->dev, "failed to set pixel clk: %s (%d)\n",
 					config->pwr_clk_names[0], ret);
@@ -102,12 +98,13 @@ static void hdmi_bridge_pre_enable(struct drm_bridge *bridge)
 
 	DBG("power up");
 
-	if (!hdmi_bridge->power_on) {
+	if (!hdmi->power_on) {
 		power_on(bridge);
-		hdmi_bridge->power_on = true;
+		hdmi->power_on = true;
+		hdmi_audio_update(hdmi);
 	}
 
-	phy->funcs->powerup(phy, hdmi_bridge->pixclock);
+	phy->funcs->powerup(phy, hdmi->pixclock);
 	hdmi_set_mode(hdmi, true);
 }
 
@@ -129,9 +126,10 @@ static void hdmi_bridge_post_disable(struct drm_bridge *bridge)
 	hdmi_set_mode(hdmi, false);
 	phy->funcs->powerdown(phy);
 
-	if (hdmi_bridge->power_on) {
+	if (hdmi->power_on) {
 		power_off(bridge);
-		hdmi_bridge->power_on = false;
+		hdmi->power_on = false;
+		hdmi_audio_update(hdmi);
 	}
 }
 
@@ -146,7 +144,7 @@ static void hdmi_bridge_mode_set(struct drm_bridge *bridge,
 
 	mode = adjusted_mode;
 
-	hdmi_bridge->pixclock = mode->clock * 1000;
+	hdmi->pixclock = mode->clock * 1000;
 
 	hdmi->hdmi_mode = drm_match_cea_mode(mode) > 1;
 
@@ -194,9 +192,7 @@ static void hdmi_bridge_mode_set(struct drm_bridge *bridge,
 	DBG("frame_ctrl=%08x", frame_ctrl);
 	hdmi_write(hdmi, REG_HDMI_FRAME_CTRL, frame_ctrl);
 
-	// TODO until we have audio, this might be safest:
-	if (hdmi->hdmi_mode)
-		hdmi_write(hdmi, REG_HDMI_GC, HDMI_GC_MUTE);
+	hdmi_audio_update(hdmi);
 }
 
 static const struct drm_bridge_funcs hdmi_bridge_funcs = {

commit dada25bd22a52a4351357209a8c227070cfd406d
Author: Rob Clark <robdclark@gmail.com>
Date:   Sun Dec 1 12:12:54 2013 -0500

    drm/msm: add hdmi support for apq8x74/mdp5
    
    The HDMI block is basically the same between older SoC's with mdp4
    display controller, and newer ones with mdp5.
    
    So mostly this consists of better abstracting out the different sets of
    regulators, clks, etc.  In particular, for regulators and clks we can
    split it up by what is needed for hot plug detect to work, and what is
    needed to light up the display.
    
    Also, 8x74 has a new phy.. a very simple one, but split out into a
    different mmio space.  And with mdp5, the irq is shared with mdp, so we
    don't directly register our own irq handler.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
index 5a8ee3473cf5..7d10e55403c6 100644
--- a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -21,6 +21,7 @@ struct hdmi_bridge {
 	struct drm_bridge base;
 
 	struct hdmi *hdmi;
+	bool power_on;
 
 	unsigned long int pixclock;
 };
@@ -34,6 +35,65 @@ static void hdmi_bridge_destroy(struct drm_bridge *bridge)
 	kfree(hdmi_bridge);
 }
 
+static void power_on(struct drm_bridge *bridge)
+{
+	struct drm_device *dev = bridge->dev;
+	struct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);
+	struct hdmi *hdmi = hdmi_bridge->hdmi;
+	const struct hdmi_platform_config *config = hdmi->config;
+	int i, ret;
+
+	for (i = 0; i < config->pwr_reg_cnt; i++) {
+		ret = regulator_enable(hdmi->pwr_regs[i]);
+		if (ret) {
+			dev_err(dev->dev, "failed to enable pwr regulator: %s (%d)\n",
+					config->pwr_reg_names[i], ret);
+		}
+	}
+
+	if (config->pwr_clk_cnt > 0) {
+		DBG("pixclock: %lu", hdmi_bridge->pixclock);
+		ret = clk_set_rate(hdmi->pwr_clks[0], hdmi_bridge->pixclock);
+		if (ret) {
+			dev_err(dev->dev, "failed to set pixel clk: %s (%d)\n",
+					config->pwr_clk_names[0], ret);
+		}
+	}
+
+	for (i = 0; i < config->pwr_clk_cnt; i++) {
+		ret = clk_prepare_enable(hdmi->pwr_clks[i]);
+		if (ret) {
+			dev_err(dev->dev, "failed to enable pwr clk: %s (%d)\n",
+					config->pwr_clk_names[i], ret);
+		}
+	}
+}
+
+static void power_off(struct drm_bridge *bridge)
+{
+	struct drm_device *dev = bridge->dev;
+	struct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);
+	struct hdmi *hdmi = hdmi_bridge->hdmi;
+	const struct hdmi_platform_config *config = hdmi->config;
+	int i, ret;
+
+	/* TODO do we need to wait for final vblank somewhere before
+	 * cutting the clocks?
+	 */
+	mdelay(16 + 4);
+
+	for (i = 0; i < config->pwr_clk_cnt; i++)
+		clk_disable_unprepare(hdmi->pwr_clks[i]);
+
+	for (i = 0; i < config->pwr_reg_cnt; i++) {
+		ret = regulator_disable(hdmi->pwr_regs[i]);
+		if (ret) {
+			dev_err(dev->dev, "failed to disable pwr regulator: %s (%d)\n",
+					config->pwr_reg_names[i], ret);
+		}
+	}
+}
+
 static void hdmi_bridge_pre_enable(struct drm_bridge *bridge)
 {
 	struct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);
@@ -41,6 +101,12 @@ static void hdmi_bridge_pre_enable(struct drm_bridge *bridge)
 	struct hdmi_phy *phy = hdmi->phy;
 
 	DBG("power up");
+
+	if (!hdmi_bridge->power_on) {
+		power_on(bridge);
+		hdmi_bridge->power_on = true;
+	}
+
 	phy->funcs->powerup(phy, hdmi_bridge->pixclock);
 	hdmi_set_mode(hdmi, true);
 }
@@ -62,6 +128,11 @@ static void hdmi_bridge_post_disable(struct drm_bridge *bridge)
 	DBG("power down");
 	hdmi_set_mode(hdmi, false);
 	phy->funcs->powerdown(phy);
+
+	if (hdmi_bridge->power_on) {
+		power_off(bridge);
+		hdmi_bridge->power_on = false;
+	}
 }
 
 static void hdmi_bridge_mode_set(struct drm_bridge *bridge,

commit a3376e3ec81c5dd0622cbc187db76d2824d31c1c
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Aug 30 13:02:15 2013 -0400

    drm/msm: convert to drm_bridge
    
    Drop the msm_connector base class, and special calls to base class
    methods from the encoder, and use instead drm_bridge.  This allows for a
    cleaner division between the hdmi (and in future dsi) blocks, from the
    mdp block.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
new file mode 100644
index 000000000000..5a8ee3473cf5
--- /dev/null
+++ b/drivers/gpu/drm/msm/hdmi/hdmi_bridge.c
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2013 Red Hat
+ * Author: Rob Clark <robdclark@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "hdmi.h"
+
+struct hdmi_bridge {
+	struct drm_bridge base;
+
+	struct hdmi *hdmi;
+
+	unsigned long int pixclock;
+};
+#define to_hdmi_bridge(x) container_of(x, struct hdmi_bridge, base)
+
+static void hdmi_bridge_destroy(struct drm_bridge *bridge)
+{
+	struct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);
+	hdmi_unreference(hdmi_bridge->hdmi);
+	drm_bridge_cleanup(bridge);
+	kfree(hdmi_bridge);
+}
+
+static void hdmi_bridge_pre_enable(struct drm_bridge *bridge)
+{
+	struct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);
+	struct hdmi *hdmi = hdmi_bridge->hdmi;
+	struct hdmi_phy *phy = hdmi->phy;
+
+	DBG("power up");
+	phy->funcs->powerup(phy, hdmi_bridge->pixclock);
+	hdmi_set_mode(hdmi, true);
+}
+
+static void hdmi_bridge_enable(struct drm_bridge *bridge)
+{
+}
+
+static void hdmi_bridge_disable(struct drm_bridge *bridge)
+{
+}
+
+static void hdmi_bridge_post_disable(struct drm_bridge *bridge)
+{
+	struct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);
+	struct hdmi *hdmi = hdmi_bridge->hdmi;
+	struct hdmi_phy *phy = hdmi->phy;
+
+	DBG("power down");
+	hdmi_set_mode(hdmi, false);
+	phy->funcs->powerdown(phy);
+}
+
+static void hdmi_bridge_mode_set(struct drm_bridge *bridge,
+		 struct drm_display_mode *mode,
+		 struct drm_display_mode *adjusted_mode)
+{
+	struct hdmi_bridge *hdmi_bridge = to_hdmi_bridge(bridge);
+	struct hdmi *hdmi = hdmi_bridge->hdmi;
+	int hstart, hend, vstart, vend;
+	uint32_t frame_ctrl;
+
+	mode = adjusted_mode;
+
+	hdmi_bridge->pixclock = mode->clock * 1000;
+
+	hdmi->hdmi_mode = drm_match_cea_mode(mode) > 1;
+
+	hstart = mode->htotal - mode->hsync_start;
+	hend   = mode->htotal - mode->hsync_start + mode->hdisplay;
+
+	vstart = mode->vtotal - mode->vsync_start - 1;
+	vend   = mode->vtotal - mode->vsync_start + mode->vdisplay - 1;
+
+	DBG("htotal=%d, vtotal=%d, hstart=%d, hend=%d, vstart=%d, vend=%d",
+			mode->htotal, mode->vtotal, hstart, hend, vstart, vend);
+
+	hdmi_write(hdmi, REG_HDMI_TOTAL,
+			HDMI_TOTAL_H_TOTAL(mode->htotal - 1) |
+			HDMI_TOTAL_V_TOTAL(mode->vtotal - 1));
+
+	hdmi_write(hdmi, REG_HDMI_ACTIVE_HSYNC,
+			HDMI_ACTIVE_HSYNC_START(hstart) |
+			HDMI_ACTIVE_HSYNC_END(hend));
+	hdmi_write(hdmi, REG_HDMI_ACTIVE_VSYNC,
+			HDMI_ACTIVE_VSYNC_START(vstart) |
+			HDMI_ACTIVE_VSYNC_END(vend));
+
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE) {
+		hdmi_write(hdmi, REG_HDMI_VSYNC_TOTAL_F2,
+				HDMI_VSYNC_TOTAL_F2_V_TOTAL(mode->vtotal));
+		hdmi_write(hdmi, REG_HDMI_VSYNC_ACTIVE_F2,
+				HDMI_VSYNC_ACTIVE_F2_START(vstart + 1) |
+				HDMI_VSYNC_ACTIVE_F2_END(vend + 1));
+	} else {
+		hdmi_write(hdmi, REG_HDMI_VSYNC_TOTAL_F2,
+				HDMI_VSYNC_TOTAL_F2_V_TOTAL(0));
+		hdmi_write(hdmi, REG_HDMI_VSYNC_ACTIVE_F2,
+				HDMI_VSYNC_ACTIVE_F2_START(0) |
+				HDMI_VSYNC_ACTIVE_F2_END(0));
+	}
+
+	frame_ctrl = 0;
+	if (mode->flags & DRM_MODE_FLAG_NHSYNC)
+		frame_ctrl |= HDMI_FRAME_CTRL_HSYNC_LOW;
+	if (mode->flags & DRM_MODE_FLAG_NVSYNC)
+		frame_ctrl |= HDMI_FRAME_CTRL_VSYNC_LOW;
+	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
+		frame_ctrl |= HDMI_FRAME_CTRL_INTERLACED_EN;
+	DBG("frame_ctrl=%08x", frame_ctrl);
+	hdmi_write(hdmi, REG_HDMI_FRAME_CTRL, frame_ctrl);
+
+	// TODO until we have audio, this might be safest:
+	if (hdmi->hdmi_mode)
+		hdmi_write(hdmi, REG_HDMI_GC, HDMI_GC_MUTE);
+}
+
+static const struct drm_bridge_funcs hdmi_bridge_funcs = {
+		.pre_enable = hdmi_bridge_pre_enable,
+		.enable = hdmi_bridge_enable,
+		.disable = hdmi_bridge_disable,
+		.post_disable = hdmi_bridge_post_disable,
+		.mode_set = hdmi_bridge_mode_set,
+		.destroy = hdmi_bridge_destroy,
+};
+
+
+/* initialize bridge */
+struct drm_bridge *hdmi_bridge_init(struct hdmi *hdmi)
+{
+	struct drm_bridge *bridge = NULL;
+	struct hdmi_bridge *hdmi_bridge;
+	int ret;
+
+	hdmi_bridge = kzalloc(sizeof(*hdmi_bridge), GFP_KERNEL);
+	if (!hdmi_bridge) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	hdmi_bridge->hdmi = hdmi_reference(hdmi);
+
+	bridge = &hdmi_bridge->base;
+
+	drm_bridge_init(hdmi->dev, bridge, &hdmi_bridge_funcs);
+
+	return bridge;
+
+fail:
+	if (bridge)
+		hdmi_bridge_destroy(bridge);
+
+	return ERR_PTR(ret);
+}
