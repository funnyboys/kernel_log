commit ab723b7a992a19b843f798b183f53f7472f598c8
Author: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date:   Fri Jan 24 00:57:10 2020 +0100

    drm/msm: Add syncobj support.
    
    This
    
    1) Enables core DRM syncobj support.
    2) Adds options to the submission ioctl to wait/signal syncobjs.
    
    Just like the wait fence fd, this does inline waits. Using the
    scheduler would be nice but I believe it is out of scope for
    this work.
    
    Support for timeline syncobjs is implemented and the interface
    is ready for it, but I'm not enabling it yet until there is
    some code for turnip to use it.
    
    The reset is mostly in there because in the presence of waiting
    and signalling the same semaphores, resetting them after
    signalling can become very annoying.
    
    v2:
      - Fixed style issues
      - Removed a cleanup issue in a failure case
      - Moved to a copy_from_user per syncobj
    
    v3:
     - Fixed a missing declaration introduced in v2
     - Reworked to use ERR_PTR/PTR_ERR
     - Simplified failure gotos.
    
    Used by: https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/2769
    
    Signed-off-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
    Reviewed-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@chromium.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 29295dee2a2e..f6ce40bf3699 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -37,9 +37,10 @@
  * - 1.4.0 - softpin, MSM_RELOC_BO_DUMP, and GEM_INFO support to set/get
  *           GEM object's debug name
  * - 1.5.0 - Add SUBMITQUERY_QUERY ioctl
+ * - 1.6.0 - Syncobj support
  */
 #define MSM_VERSION_MAJOR	1
-#define MSM_VERSION_MINOR	5
+#define MSM_VERSION_MINOR	6
 #define MSM_VERSION_PATCHLEVEL	0
 
 static const struct drm_mode_config_funcs mode_config_funcs = {
@@ -1002,7 +1003,8 @@ static struct drm_driver msm_driver = {
 	.driver_features    = DRIVER_GEM |
 				DRIVER_RENDER |
 				DRIVER_ATOMIC |
-				DRIVER_MODESET,
+				DRIVER_MODESET |
+				DRIVER_SYNCOBJ,
 	.open               = msm_open,
 	.postclose           = msm_postclose,
 	.lastclose          = drm_fb_helper_lastclose,

commit 59e7a8cc2dcf335116d500d684bfb34d1d97a6fe
Merge: 5fc0df93fccd a5fb8b918920
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Mar 31 16:34:49 2020 +1000

    Merge tag 'drm-msm-next-2020-03-22' of https://gitlab.freedesktop.org/drm/msm into drm-next
    
    A bit smaller this time around.. there are still a couple uabi
    additions for vulkan waiting in the wings, but I punted on them this
    cycle due to running low on time.  (They should be easy enough to
    rebase, and if it is a problem for anyone I can push a next+uabi
    branch so that tu work can proceed.)
    
    The bigger change is refactoring dpu resource manager and moving dpu
    to use atomic global state.  Other than that, it is mostly cleanups
    and fixes.
    
    From: Rob Clark <robdclark@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/ <CAF6AEGuf1R4Xz-t9Z7_cwx9jD=b4wUvvwfqA5cHR8fCSXSd5XQ@mail.gmail.com
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit 66be340f827554cb1c8a1ed7dea97920b4085af2
Author: Pavel Machek <pavel@denx.de>
Date:   Mon Mar 9 11:14:10 2020 +0100

    drm/msm: fix leaks if initialization fails
    
    We should free resources in unlikely case of allocation failure.
    
    Signed-off-by: Pavel Machek <pavel@denx.de>
    Signed-off-by: Rob Clark <robdclark@chromium.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index e4b750b0c2d3..7d985f8865be 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -444,8 +444,10 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	if (!dev->dma_parms) {
 		dev->dma_parms = devm_kzalloc(dev, sizeof(*dev->dma_parms),
 					      GFP_KERNEL);
-		if (!dev->dma_parms)
-			return -ENOMEM;
+		if (!dev->dma_parms) {
+			ret = -ENOMEM;
+			goto err_msm_uninit;
+		}
 	}
 	dma_set_max_seg_size(dev, DMA_BIT_MASK(32));
 

commit 28f2aff1caa4997f58ca31179cad1b4a84a62827
Merge: 3e8a3844fefb 11a48a5a18c6
Author: Maxime Ripard <maxime@cerno.tech>
Date:   Mon Feb 17 10:34:34 2020 +0100

    Merge v5.6-rc2 into drm-misc-next
    
    Lyude needs some patches in 5.6-rc2 and we didn't bring drm-misc-next
    forward yet, so it looks like a good occasion.
    
    Signed-off-by: Maxime Ripard <maxime@cerno.tech>

commit 7ebdc26a315ac0f13369eaf922bcee3ede576438
Merge: 984f0103fcd1 e1cf35b94c5f
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Feb 14 12:57:47 2020 +1000

    Merge tag 'drm-misc-next-fixes-2020-02-07' of git://anongit.freedesktop.org/drm/drm-misc into drm-fixes
    
    drm-misc-next fixes for v5.6:
    - Fix build error in drm/edid.
    - Plug close-after-free race in vgem_gem_create.
    - Handle CONFIG_DMA_API_DEBUG_SG better in drm/msm.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/551b6183-a581-9d12-10a9-24cd929de425@linux.intel.com

commit 76e8cfd802c521bdc045de2c7917270922a1756a
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Thu Jan 23 14:59:34 2020 +0100

    drm/msm: Convert to CRTC VBLANK callbacks
    
    VBLANK callbacks in struct drm_driver are deprecated in favor of
    their equivalents in struct drm_crtc_funcs. Convert msm over.
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Tested-by: Yannick Fertr√© <yannick.fertre@st.com>
    Acked-by: Rob Clark <robdclark@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200123135943.24140-14-tzimmermann@suse.de

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index c84f0a8b3f2c..c5e044136fe5 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -660,8 +660,10 @@ static void msm_irq_uninstall(struct drm_device *dev)
 	kms->funcs->irq_uninstall(kms);
 }
 
-static int msm_enable_vblank(struct drm_device *dev, unsigned int pipe)
+int msm_crtc_enable_vblank(struct drm_crtc *crtc)
 {
+	struct drm_device *dev = crtc->dev;
+	unsigned int pipe = crtc->index;
 	struct msm_drm_private *priv = dev->dev_private;
 	struct msm_kms *kms = priv->kms;
 	if (!kms)
@@ -670,8 +672,10 @@ static int msm_enable_vblank(struct drm_device *dev, unsigned int pipe)
 	return vblank_ctrl_queue_work(priv, pipe, true);
 }
 
-static void msm_disable_vblank(struct drm_device *dev, unsigned int pipe)
+void msm_crtc_disable_vblank(struct drm_crtc *crtc)
 {
+	struct drm_device *dev = crtc->dev;
+	unsigned int pipe = crtc->index;
 	struct msm_drm_private *priv = dev->dev_private;
 	struct msm_kms *kms = priv->kms;
 	if (!kms)
@@ -996,8 +1000,6 @@ static struct drm_driver msm_driver = {
 	.irq_preinstall     = msm_irq_preinstall,
 	.irq_postinstall    = msm_irq_postinstall,
 	.irq_uninstall      = msm_irq_uninstall,
-	.enable_vblank      = msm_enable_vblank,
-	.disable_vblank     = msm_disable_vblank,
 	.gem_free_object_unlocked = msm_gem_free_object,
 	.gem_vm_ops         = &vm_ops,
 	.dumb_create        = msm_gem_dumb_create,

commit 9f68e3655aae6d49d6ba05dd263f99f33c2567af
Merge: 4cadc60d6bcf d47c7f062680
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 30 08:04:01 2020 -0800

    Merge tag 'drm-next-2020-01-30' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Davbe Airlie:
     "This is the main pull request for graphics for 5.6. Usual selection of
      changes all over.
    
      I've got one outstanding vmwgfx pull that touches mm so kept it
      separate until after all of this lands. I'll try and get it to you
      soon after this, but it might be early next week (nothing wrong with
      code, just my schedule is messy)
    
      This also hits a lot of fbdev drivers with some cleanups.
    
      Other notables:
       - vulkan timeline semaphore support added to syncobjs
       - nouveau turing secureboot/graphics support
       - Displayport MST display stream compression support
    
      Detailed summary:
    
      uapi:
       - dma-buf heaps added (and fixed)
       - command line add support for panel oreientation
       - command line allow overriding penguin count
    
      drm:
       - mipi dsi definition updates
       - lockdep annotations for dma_resv
       - remove dma-buf kmap/kunmap support
       - constify fb_ops in all fbdev drivers
       - MST fix for daisy chained hotplug-
       - CTA-861-G modes with VIC >= 193 added
       - fix drm_panel_of_backlight export
       - LVDS decoder support
       - more device based logging support
       - scanline alighment for dumb buffers
       - MST DSC helpers
    
      scheduler:
       - documentation fixes
       - job distribution improvements
    
      panel:
       - Logic PD type 28 panel support
       - Jimax8729d MIPI-DSI
       - igenic JZ4770
       - generic DSI devicetree bindings
       - sony acx424AKP panel
       - Leadtek LTK500HD1829
       - xinpeng XPP055C272
       - AUO B116XAK01
       - GiantPlus GPM940B0
       - BOE NV140FHM-N49
       - Satoz SAT050AT40H12R2
       - Sharp LS020B1DD01D panels.
    
      ttm:
       - use blocking WW lock
    
      i915:
       - hw/uapi state separation
       - Lock annotation improvements
       - selftest improvements
       - ICL/TGL DSI VDSC support
       - VBT parsing improvments
       - Display refactoring
       - DSI updates + fixes
       - HDCP 2.2 for CFL
       - CML PCI ID fixes
       - GLK+ fbc fix
       - PSR fixes
       - GEN/GT refactor improvments
       - DP MST fixes
       - switch context id alloc to xarray
       - workaround updates
       - LMEM debugfs support
       - tiled monitor fixes
       - ICL+ clock gating programming removed
       - DP MST disable sequence fixed
       - LMEM discontiguous object maps
       - prefaulting for discontiguous objects
       - use LMEM for dumb buffers if possible
       - add LMEM mmap support
    
      amdgpu:
       - enable sync object timelines for vulkan
       - MST atomic routines
       - enable MST DSC support
       - add DMCUB display microengine support
       - DC OEM i2c support
       - Renoir DC fixes
       - Initial HDCP 2.x support
       - BACO support for Arcturus
       - Use BACO for runtime PM power save
       - gfxoff on navi10
       - gfx10 golden updates and fixes
       - DCN support on POWER
       - GFXOFF for raven1 refresh
       - MM engine idle handlers cleanup
       - 10bpc EDP panel fixes
       - renoir watermark fixes
       - SR-IOV fixes
       - Arcturus VCN fixes
       - GDDR6 training fixes
       - freesync fixes
       - Pollock support
    
      amdkfd:
       - unify more codepath with amdgpu
       - use KIQ to setup HIQ rather than MMIO
    
      radeon:
       - fix vma fault handler race
       - PPC DMA fix
       - register check fixes for r100/r200
    
      nouveau:
       - mmap_sem vs dma_resv fix
       - rewrite the ACR secure boot code for Turing
       - TU10x graphics engine support (TU11x pending)
       - Page kind mapping for turing
       - 10-bit LUT support
       - GP10B Tegra fixes
       - HD audio regression fix
    
      hisilicon/hibmc:
       - use generic fbdev code and helpers
    
      rockchip:
       - dsi/px30 support
    
      virtio:
       - fb damage support
       - static some functions
    
      vc4:
       - use dma_resv lock wrappers
    
      msm:
       - use dma_resv lock wrappers
       - sc7180 display + DSI support
       - a618 support
       - UBWC support improvements
    
      vmwgfx:
       - updates + new logging uapi
    
      exynos:
       - enable/disable callback cleanups
    
      etnaviv:
       - use dma_resv lock wrappers
    
      atmel-hlcdc:
       - clock fixes
    
      mediatek:
       - cmdq support
       - non-smooth cursor fixes
       - ctm property support
    
      sun4i:
       - suspend support
       - A64 mipi dsi support
    
      rcar-du:
       - Color management module support
       - LVDS encoder dual-link support
       - R8A77980 support
    
      analogic:
       - add support for an6345
    
      ast:
       - atomic modeset support
       - primary plane garbage fix
    
      arcgpu:
       - fixes for fourcc handling
    
      tegra:
       - minor fixes and improvments
    
      mcde:
       - vblank support
    
      meson:
       - OSD1 plane AFBC commit
    
      gma500:
       - add pageflip support
       - reomve global drm_dev
    
      komeda:
       - tweak debugfs output
       - d32 support
       - runtime PM suppotr
    
      udl:
       - use generic shmem helpers
       - cleanup and fixes"
    
    * tag 'drm-next-2020-01-30' of git://anongit.freedesktop.org/drm/drm: (1998 commits)
      drm/nouveau/fb/gp102-: allow module to load even when scrubber binary is missing
      drm/nouveau/acr: return error when registering LSF if ACR not supported
      drm/nouveau/disp/gv100-: not all channel types support reporting error codes
      drm/nouveau/disp/nv50-: prevent oops when no channel method map provided
      drm/nouveau: support synchronous pushbuf submission
      drm/nouveau: signal pending fences when channel has been killed
      drm/nouveau: reject attempts to submit to dead channels
      drm/nouveau: zero vma pointer even if we only unreference it rather than free
      drm/nouveau: Add HD-audio component notifier support
      drm/nouveau: fix build error without CONFIG_IOMMU_API
      drm/nouveau/kms/nv04: remove set but not used variable 'width'
      drm/nouveau/kms/nv50: remove set but not unused variable 'nv_connector'
      drm/nouveau/mmu: fix comptag memory leak
      drm/nouveau/gr/gp10b: Use gp100_grctx and gp100_gr_zbc
      drm/nouveau/pmu/gm20b,gp10b: Fix Falcon bootstrapping
      drm/exynos: Rename Exynos to lowercase
      drm/exynos: change callback names
      drm/mst: Don't do atomic checks over disabled managers
      drm/amdgpu: add the lost mutex_init back
      drm/amd/display: skip opp blank or unblank if test pattern enabled
      ...

commit db735fc4036bbe1fbe606819b5f0ff26cc76cdff
Author: Sean Paul <seanpaul@chromium.org>
Date:   Tue Jan 21 11:18:48 2020 -0800

    drm/msm: Set dma maximum segment size for mdss
    
    Turning on CONFIG_DMA_API_DEBUG_SG results in the following error:
    
    [   12.078665] msm ae00000.mdss: DMA-API: mapping sg segment longer than device claims to support [len=3526656] [max=65536]
    [   12.089870] WARNING: CPU: 6 PID: 334 at /mnt/host/source/src/third_party/kernel/v4.19/kernel/dma/debug.c:1301 debug_dma_map_sg+0x1dc/0x318
    [   12.102655] Modules linked in: joydev
    [   12.106442] CPU: 6 PID: 334 Comm: frecon Not tainted 4.19.0 #2
    [   12.112450] Hardware name: Google Cheza (rev3+) (DT)
    [   12.117566] pstate: 60400009 (nZCv daif +PAN -UAO)
    [   12.122506] pc : debug_dma_map_sg+0x1dc/0x318
    [   12.126995] lr : debug_dma_map_sg+0x1dc/0x318
    [   12.131487] sp : ffffff800cc3ba80
    [   12.134913] x29: ffffff800cc3ba80 x28: 0000000000000000
    [   12.140395] x27: 0000000000000004 x26: 0000000000000004
    [   12.145868] x25: ffffff8008e55b18 x24: 0000000000000000
    [   12.151337] x23: 00000000ffffffff x22: ffffff800921c000
    [   12.156809] x21: ffffffc0fa75b080 x20: ffffffc0f7195090
    [   12.162280] x19: ffffffc0f1c53280 x18: 0000000000000000
    [   12.167749] x17: 0000000000000000 x16: 0000000000000000
    [   12.173218] x15: 0000000000000000 x14: 0720072007200720
    [   12.178689] x13: 0720072007200720 x12: 0720072007200720
    [   12.184161] x11: 0720072007200720 x10: 0720072007200720
    [   12.189641] x9 : ffffffc0f1fc6b60 x8 : 0000000000000000
    [   12.195110] x7 : ffffff8008132ce0 x6 : 0000000000000000
    [   12.200585] x5 : 0000000000000000 x4 : ffffff8008134734
    [   12.206058] x3 : ffffff800cc3b830 x2 : ffffffc0f1fc6240
    [   12.211532] x1 : 25045a74f48a7400 x0 : 25045a74f48a7400
    [   12.217006] Call trace:
    [   12.219535]  debug_dma_map_sg+0x1dc/0x318
    [   12.223671]  get_pages+0x19c/0x20c
    [   12.227177]  msm_gem_fault+0x64/0xfc
    [   12.230874]  __do_fault+0x3c/0x140
    [   12.234383]  __handle_mm_fault+0x70c/0xdb8
    [   12.238603]  handle_mm_fault+0xac/0xc4
    [   12.242473]  do_page_fault+0x1bc/0x3d4
    [   12.246342]  do_translation_fault+0x54/0x88
    [   12.250652]  do_mem_abort+0x60/0xf0
    [   12.254250]  el0_da+0x20/0x24
    [   12.257317] irq event stamp: 67260
    [   12.260828] hardirqs last  enabled at (67259): [<ffffff8008132d0c>] console_unlock+0x214/0x608
    [   12.269693] hardirqs last disabled at (67260): [<ffffff8008080e0c>] do_debug_exception+0x5c/0x178
    [   12.278820] softirqs last  enabled at (67256): [<ffffff8008081664>] __do_softirq+0x4d4/0x520
    [   12.287510] softirqs last disabled at (67249): [<ffffff80080be574>] irq_exit+0xa8/0x100
    [   12.295742] ---[ end trace e63cfc40c313ffab ]---
    
    The root of the problem is that the default segment size for sgt is
    (UINT_MAX & PAGE_MASK), and the default segment size for device dma is
    64K. As such, if you compare the 2, you would deduce that the sg segment
    will overflow the device's capacity. In reality, the hardware can
    accommodate the larger sg segments, it's just not initializing its max
    segment properly. This patch initializes the max segment size for the
    mdss device, which gets rid of that pesky warning.
    
    Reported-by: Stephen Boyd <swboyd@chromium.org>
    Tested-by: Stephen Boyd <swboyd@chromium.org>
    Tested-by: Sai Prakash Ranjan <saiprakash.ranjan@codeaurora.org>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200121111813.REPOST.1.I92c66a35fb13f368095b05287bdabdbe88ca6922@changeid

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index f50fefb87040..c80ddd7019b5 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -441,6 +441,14 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	if (ret)
 		goto err_msm_uninit;
 
+	if (!dev->dma_parms) {
+		dev->dma_parms = devm_kzalloc(dev, sizeof(*dev->dma_parms),
+					      GFP_KERNEL);
+		if (!dev->dma_parms)
+			return -ENOMEM;
+	}
+	dma_set_max_seg_size(dev, DMA_BIT_MASK(32));
+
 	msm_gem_shrinker_init(ddev);
 
 	switch (get_mdp_ver(pdev)) {

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index c84f0a8b3f2c..ac678ace09a3 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -138,7 +138,7 @@ void __iomem *msm_ioremap(struct platform_device *pdev, const char *name,
 
 	size = resource_size(res);
 
-	ptr = devm_ioremap_nocache(&pdev->dev, res->start, size);
+	ptr = devm_ioremap(&pdev->dev, res->start, size);
 	if (!ptr) {
 		DRM_DEV_ERROR(&pdev->dev, "failed to ioremap: %s\n", name);
 		return ERR_PTR(-ENOMEM);

commit 7bdc0c4b812602fb5678dcc477fe03679721e892
Author: Kalyan Thota <kalyan_t@codeaurora.org>
Date:   Mon Nov 25 17:29:27 2019 +0530

    msm:disp:dpu1: add support for display for SC7180 target
    
    Add display hw catalog changes for SC7180 target.
    
    Changes in v1:
     - Configure register offsets and capabilities for the
       display hw blocks.
    
    Changes in v2:
     - mdss_irq data type has changed in the dependent
       patch, accommodate the necessary changes.
     - Add co-developed-by tags in the commit msg (Stephen Boyd).
    
    Changes in v3:
     - fix kernel checkpatch errors in v2
    
    Changes in v4:
     - move documentation into seperate patch (Rob Herring).
    
    This patch has dependency on the below series
    
    https://patchwork.kernel.org/patch/11253647/
    
    Co-developed-by: Shubhashree Dhar <dhar@codeaurora.org>
    Signed-off-by: Shubhashree Dhar <dhar@codeaurora.org>
    Co-developed-by: Raviteja Tamatam <travitej@codeaurora.org>
    Signed-off-by: Raviteja Tamatam <travitej@codeaurora.org>
    Signed-off-by: Kalyan Thota <kalyan_t@codeaurora.org>
    [rebase on hw catalog const'ification, and add more const's]
    Signed-off-by: Rob Clark <robdclark@chromium.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index c84f0a8b3f2c..f50fefb87040 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1192,7 +1192,8 @@ static int add_display_components(struct device *dev,
 	 * the interfaces to our components list.
 	 */
 	if (of_device_is_compatible(dev->of_node, "qcom,mdss") ||
-	    of_device_is_compatible(dev->of_node, "qcom,sdm845-mdss")) {
+	    of_device_is_compatible(dev->of_node, "qcom,sdm845-mdss") ||
+	    of_device_is_compatible(dev->of_node, "qcom,sc7180-mdss")) {
 		ret = of_platform_populate(dev->of_node, NULL, NULL, dev);
 		if (ret) {
 			DRM_DEV_ERROR(dev, "failed to populate children devices\n");
@@ -1317,6 +1318,7 @@ static const struct of_device_id dt_match[] = {
 	{ .compatible = "qcom,mdp4", .data = (void *)KMS_MDP4 },
 	{ .compatible = "qcom,mdss", .data = (void *)KMS_MDP5 },
 	{ .compatible = "qcom,sdm845-mdss", .data = (void *)KMS_DPU },
+	{ .compatible = "qcom,sc7180-mdss", .data = (void *)KMS_DPU },
 	{}
 };
 MODULE_DEVICE_TABLE(of, dt_match);

commit 2d99ced787e3d0f251fa370d2aae83cf2085a8d9
Author: Rob Clark <robdclark@chromium.org>
Date:   Thu Aug 29 09:45:16 2019 -0700

    drm/msm: async commit support
    
    Now that flush/wait/complete is decoupled from the "synchronous" part of
    atomic commit_tail(), add support to defer flush to a timer that expires
    shortly before vblank for async commits.  In this way, multiple atomic
    commits (for example, cursor updates) can be coalesced into a single
    flush at the end of the frame.
    
    v2: don't hold lock over ->wait_flush(), to avoid locking interaction
        that was causing fps drop when combining page flips or non-async
        atomic commits and lots of legacy cursor updates
    
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Reviewed-by: Sean Paul <sean@poorly.run>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 996a508f762c..c84f0a8b3f2c 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -473,6 +473,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	ddev->mode_config.normalize_zpos = true;
 
 	if (kms) {
+		kms->dev = ddev;
 		ret = kms->funcs->hw_init(kms);
 		if (ret) {
 			DRM_DEV_ERROR(dev, "kms hw init failed: %d\n", ret);

commit 8e3e791d20d2f7ffd4926eda7555ec815293f533
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Thu Jul 25 10:53:55 2019 -0600

    drm/msm: Use generic bulk clock function
    
    Remove the homebrewed bulk clock get function and replace it with
    devm_clk_bulk_get_all().
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Rob Clark <robdclark@chromium.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 8a589d505b6f..996a508f762c 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -83,46 +83,6 @@ module_param(modeset, bool, 0600);
  * Util/helpers:
  */
 
-int msm_clk_bulk_get(struct device *dev, struct clk_bulk_data **bulk)
-{
-	struct property *prop;
-	const char *name;
-	struct clk_bulk_data *local;
-	int i = 0, ret, count;
-
-	count = of_property_count_strings(dev->of_node, "clock-names");
-	if (count < 1)
-		return 0;
-
-	local = devm_kcalloc(dev, sizeof(struct clk_bulk_data *),
-		count, GFP_KERNEL);
-	if (!local)
-		return -ENOMEM;
-
-	of_property_for_each_string(dev->of_node, "clock-names", prop, name) {
-		local[i].id = devm_kstrdup(dev, name, GFP_KERNEL);
-		if (!local[i].id) {
-			devm_kfree(dev, local);
-			return -ENOMEM;
-		}
-
-		i++;
-	}
-
-	ret = devm_clk_bulk_get(dev, count, local);
-
-	if (ret) {
-		for (i = 0; i < count; i++)
-			devm_kfree(dev, (void *) local[i].id);
-		devm_kfree(dev, local);
-
-		return ret;
-	}
-
-	*bulk = local;
-	return count;
-}
-
 struct clk *msm_clk_bulk_get_clock(struct clk_bulk_data *bulk, int count,
 		const char *name)
 {

commit feea39a86dfdbad9d02264fd4730277b4e69764e
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Aug 4 08:55:51 2019 +0200

    drm/msm: drop use of drmP.h
    
    Drop the deprecated drmP.h header file, and trim msm_drv.h
    to the relevant include files.
    
    This resulted in a suprisingly many edits as many files relied
    on headers included via msm_drv.h.
    But msm_drv.h is not supposed to carry include files it do not need, so
    the individual files have to include what extra they needs.
    
    v2:
    - Rebased on top of https://gitlab.freedesktop.org/drm/msm.git msm-next
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Sean Paul <sean@poorly.run>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Jordan Crouse <jcrouse@codeaurora.org>
    Cc: Jeykumar Sankaran <jsanka@codeaurora.org>
    Cc: Bruce Wang <bzwang@chromium.org>
    Cc: Shayenne Moura <shayenneluzmoura@gmail.com>
    Cc: Mamta Shukla <mamtashukla555@gmail.com>
    Cc: Jonathan Marek <jonathan@marek.ca>
    Cc: Carsten Behling <carsten.behling@googlemail.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Paul Kocialkowski <paul.kocialkowski@bootlin.com>
    Cc: Sibi Sankar <sibis@codeaurora.org>
    Cc: Todor Tomov <todor.tomov@linaro.org>
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190804065551.GA5211@ravnborg.org

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index ee031c086805..8a589d505b6f 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -5,9 +5,18 @@
  * Author: Rob Clark <robdclark@gmail.com>
  */
 
+#include <linux/dma-mapping.h>
 #include <linux/kthread.h>
+#include <linux/uaccess.h>
 #include <uapi/linux/sched/types.h>
+
+#include <drm/drm_drv.h>
+#include <drm/drm_file.h>
+#include <drm/drm_ioctl.h>
+#include <drm/drm_irq.h>
+#include <drm/drm_prime.h>
 #include <drm/drm_of.h>
+#include <drm/drm_vblank.h>
 
 #include "msm_drv.h"
 #include "msm_debugfs.h"
@@ -17,7 +26,6 @@
 #include "msm_kms.h"
 #include "adreno/adreno_gpu.h"
 
-
 /*
  * MSM driver version:
  * - 1.0.0 - initial interface

commit b0383c0653c4bd2d2732c5767ec8fa223b3d6efd
Merge: dce14e36aea2 cc8f12996e24
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Aug 9 16:04:15 2019 +1000

    Merge tag 'drm-misc-next-2019-08-08' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.4:
    
    UAPI Changes:
     - HDCP: Add a Content protection type property
    
    Cross-subsystem Changes:
    
    Core Changes:
     - Continue to rework the include dependencies
     - fb: Remove the unused drm_gem_fbdev_fb_create function
     - drm-dp-helper: Make the link rate calculation more tolerant to
                      non-explicitly defined, yet supported, rates
     - fb-helper: Map DRM client buffer only when required, and instanciate a
                  shadow buffer when the device has a dirty function or says so
     - connector: Add a helper to link the DDC adapter used by that connector to
                  the userspace
     - vblank: Switch from DRM_WAIT_ON to wait_event_interruptible_timeout
     - dma-buf: Fix a stack corruption
     - ttm: Embed a drm_gem_object struct to make ttm_buffer_object a
            superclass of GEM, and convert drivers to use it.
     - hdcp: Improvements to report the content protection type to the
             userspace
    
    Driver Changes:
     - Remove drm_gem_prime_import/export from being defined in the drivers
     - Drop DRM_AUTH usage from drivers
     - Continue to drop drmP.h
     - Convert drivers to the connector ddc helper
    
     - ingenic: Add support for more panel-related cases
     - komeda: Support for dual-link
     - lima: Reduce logging
     - mpag200: Fix the cursor support
     - panfrost: Export GPU features register to userspace through an ioctl
     - pl111: Remove the CLD pads wiring support from the DT
     - rockchip: Rework to use DRM PSR helpers, fix a bug in the VOP_WIN_GET
                 macro
     - sun4i: Improve support for color encoding and range
     - tinydrm: Rework SPI support, improve MIPI-DBI support, move to drm/tiny
     - vkms: Rework of the CRC tracking
    
     - bridges:
       - sii902x: Add support for audio graph card
       - tc358767: Rework AUX data handling code
       - ti-sn65dsi86: Add Debugfs and proper DSI mode flags support
    
     - panels
       - Support for GiantPlus GPM940B0, Sharp LQ070Y3DG3B, Ortustech
         COM37H3M, Novatek NT39016, Sharp LS020B1DD01D, Raydium RM67191,
         Boe Himax8279d, Sharp LD-D5116Z01B
       - Conversion of the device tree bindings to the YAML description
       - jh057n00900: Rework the enable / disable path
    
     - fbdev:
       - ssd1307fb: Support more devices based on that controller
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190808121423.xzpedzkpyecvsiy4@flea

commit 34127c7ad86ea144b85a6f405216ef1187debe84
Author: Emil Velikov <emil.velikov@collabora.com>
Date:   Mon May 27 09:17:35 2019 +0100

    drm/msm: drop DRM_AUTH usage from the driver
    
    The authentication can be circumvented, by design, by using the render
    node.
    
    From the driver POV there is no distinction between primary and render
    nodes, thus we can drop the token.
    
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Sean Paul <sean@poorly.run>
    Cc: freedreno@lists.freedesktop.org
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Emil Velikov <emil.velikov@collabora.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190527081741.14235-7-emil.l.velikov@gmail.com

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index abf8f4e4e543..ea335ca25eca 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -984,17 +984,17 @@ static int msm_ioctl_submitqueue_close(struct drm_device *dev, void *data,
 }
 
 static const struct drm_ioctl_desc msm_ioctls[] = {
-	DRM_IOCTL_DEF_DRV(MSM_GET_PARAM,    msm_ioctl_get_param,    DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_NEW,      msm_ioctl_gem_new,      DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_INFO,     msm_ioctl_gem_info,     DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_PREP, msm_ioctl_gem_cpu_prep, DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_FINI, msm_ioctl_gem_cpu_fini, DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_SUBMIT,   msm_ioctl_gem_submit,   DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_WAIT_FENCE,   msm_ioctl_wait_fence,   DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_MADVISE,  msm_ioctl_gem_madvise,  DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_NEW,   msm_ioctl_submitqueue_new,   DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_CLOSE, msm_ioctl_submitqueue_close, DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_QUERY, msm_ioctl_submitqueue_query, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GET_PARAM,    msm_ioctl_get_param,    DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_NEW,      msm_ioctl_gem_new,      DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_INFO,     msm_ioctl_gem_info,     DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_PREP, msm_ioctl_gem_cpu_prep, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_FINI, msm_ioctl_gem_cpu_fini, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_SUBMIT,   msm_ioctl_gem_submit,   DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_WAIT_FENCE,   msm_ioctl_wait_fence,   DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_MADVISE,  msm_ioctl_gem_madvise,  DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_NEW,   msm_ioctl_submitqueue_new,   DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_CLOSE, msm_ioctl_submitqueue_close, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_QUERY, msm_ioctl_submitqueue_query, DRM_RENDER_ALLOW),
 };
 
 static const struct vm_operations_struct vm_ops = {

commit 7d5000d7d21dd5d58ddbb75c534090d100d463a0
Author: Sean Paul <seanpaul@chromium.org>
Date:   Wed Aug 7 10:20:57 2019 -0400

    Revert "drm/msm: drop DRM_AUTH usage from the driver"
    
    This reverts commit 88209d2c5035737f96bcfc2fd73c0fd8d80e9bf1.
    
    Mandatory review was missing from this patch.
    
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Emil Velikov <emil.velikov@collabora.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190807142101.251400-5-sean@poorly.run

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index ea335ca25eca..abf8f4e4e543 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -984,17 +984,17 @@ static int msm_ioctl_submitqueue_close(struct drm_device *dev, void *data,
 }
 
 static const struct drm_ioctl_desc msm_ioctls[] = {
-	DRM_IOCTL_DEF_DRV(MSM_GET_PARAM,    msm_ioctl_get_param,    DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_NEW,      msm_ioctl_gem_new,      DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_INFO,     msm_ioctl_gem_info,     DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_PREP, msm_ioctl_gem_cpu_prep, DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_FINI, msm_ioctl_gem_cpu_fini, DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_SUBMIT,   msm_ioctl_gem_submit,   DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_WAIT_FENCE,   msm_ioctl_wait_fence,   DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_MADVISE,  msm_ioctl_gem_madvise,  DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_NEW,   msm_ioctl_submitqueue_new,   DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_CLOSE, msm_ioctl_submitqueue_close, DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_QUERY, msm_ioctl_submitqueue_query, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GET_PARAM,    msm_ioctl_get_param,    DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_NEW,      msm_ioctl_gem_new,      DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_INFO,     msm_ioctl_gem_info,     DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_PREP, msm_ioctl_gem_cpu_prep, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_FINI, msm_ioctl_gem_cpu_fini, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_SUBMIT,   msm_ioctl_gem_submit,   DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_WAIT_FENCE,   msm_ioctl_wait_fence,   DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_MADVISE,  msm_ioctl_gem_madvise,  DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_NEW,   msm_ioctl_submitqueue_new,   DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_CLOSE, msm_ioctl_submitqueue_close, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_QUERY, msm_ioctl_submitqueue_query, DRM_AUTH|DRM_RENDER_ALLOW),
 };
 
 static const struct vm_operations_struct vm_ops = {

commit 9ca7ad6c7706edeae331c1632d0c63897418ebad
Author: Jeffrey Hugo <jeffrey.l.hugo@gmail.com>
Date:   Wed Jun 26 11:00:15 2019 -0700

    drm: msm: Fix add_gpu_components
    
    add_gpu_components() adds found GPU nodes from the DT to the match list,
    regardless of the status of the nodes.  This is a problem, because if the
    nodes are disabled, they should not be on the match list because they will
    not be matched.  This prevents display from initing if a GPU node is
    defined, but it's status is disabled.
    
    Fix this by checking the node's status before adding it to the match list.
    
    Fixes: dc3ea265b856 (drm/msm: Drop the gpu binding)
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Jeffrey Hugo <jeffrey.l.hugo@gmail.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190626180015.45242-1-jeffrey.l.hugo@gmail.com

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index c226156f2dea..c356f5ccf253 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1279,7 +1279,8 @@ static int add_gpu_components(struct device *dev,
 	if (!np)
 		return 0;
 
-	drm_of_component_match_add(dev, matchptr, compare_of, np);
+	if (of_device_is_available(np))
+		drm_of_component_match_add(dev, matchptr, compare_of, np);
 
 	of_node_put(np);
 

commit 03b0f2ce735e97e9f49790d4563c82515b8fa702
Merge: e4f86e437164 5f9e832c1370
Author: Maxime Ripard <maxime.ripard@bootlin.com>
Date:   Mon Jul 22 21:24:10 2019 +0200

    Merge v5.3-rc1 into drm-misc-next
    
    Noralf needs some SPI patches in 5.3 to merge some work on tinydrm.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>

commit 7af5cdb158f3398a3220bd2fe81cec8d2be9317c
Author: Brian Masney <masneyb@onstation.org>
Date:   Wed Jun 26 22:05:15 2019 -0400

    drm/msm: correct NULL pointer dereference in context_init
    
    Correct attempted NULL pointer dereference in context_init() when
    running without an IOMMU.
    
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Brian Masney <masneyb@onstation.org>
    Fixes: 295b22ae596c ("drm/msm: Pass the MMU domain index in struct msm_file_private")
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190627020515.5660-1-masneyb@onstation.org

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index ab64ab470de7..c226156f2dea 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -619,7 +619,7 @@ static int context_init(struct drm_device *dev, struct drm_file *file)
 
 	msm_submitqueue_init(dev, ctx);
 
-	ctx->aspace = priv->gpu->aspace;
+	ctx->aspace = priv->gpu ? priv->gpu->aspace : NULL;
 	file->driver_priv = ctx;
 
 	return 0;

commit be8454afc50f43016ca8b6130d9673bdd0bd56ec
Merge: fec88ab0af97 3729fe2bc2a0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 15 19:04:27 2019 -0700

    Merge tag 'drm-next-2019-07-16' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Dave Airlie:
     "The biggest thing in this is the AMD Navi GPU support, this again
      contains a bunch of header files that are large. These are the new AMD
      RX5700 GPUs that just recently became available.
    
      New drivers:
       - ST-Ericsson MCDE driver
       - Ingenic JZ47xx SoC
    
      UAPI change:
       - HDR source metadata property
    
      Core:
       - HDR inforframes and EDID parsing
       - drm hdmi infoframe unpacking
       - remove prime sg_table caching into dma-buf
       - New gem vram helpers to reduce driver code
       - Lots of drmP.h removal
       - reservation fencing fix
       - documentation updates
       - drm_fb_helper_connector removed
       - mode name command handler rewrite
    
      fbcon:
       - Remove the fbcon notifiers
    
      ttm:
       - forward progress fixes
    
      dma-buf:
       - make mmap call optional
       - debugfs refcount fixes
       - dma-fence free with pending signals fix
       - each dma-buf gets an inode
    
      Panels:
       - Lots of additional panel bindings
    
      amdgpu:
       - initial navi10 support
       - avoid hw reset
       - HDR metadata support
       - new thermal sensors for vega asics
       - RAS fixes
       - use HMM rather than MMU notifier
       - xgmi topology via kfd
       - SR-IOV fixes
       - driver reload fixes
       - DC use a core bpc attribute
       - Aux fixes for DC
       - Bandwidth calc updates for DC
       - Clock handling refactor
       - kfd VEGAM support
    
      vmwgfx:
       - Coherent memory support changes
    
      i915:
       - HDR Support
       - HDMI i2c link
       - Icelake multi-segmented gamma support
       - GuC firmware update
       - Mule Creek Canyon PCH support for EHL
       - EHL platform updtes
       - move i915.alpha_support to i915.force_probe
       - runtime PM refactoring
       - VBT parsing refactoring
       - DSI fixes
       - struct mutex dependency reduction
       - GEM code reorg
    
      mali-dp:
       - Komeda driver features
    
      msm:
       - dsi vs EPROBE_DEFER fixes
       - msm8998 snapdragon 835 support
       - a540 gpu support
       - mdp5 and dpu interconnect support
    
      exynos:
       - drmP.h removal
    
      tegra:
       - misc fixes
    
      tda998x:
       - audio support improvements
       - pixel repeated mode support
       - quantisation range handling corrections
       - HDMI vendor info fix
    
      armada:
       - interlace support fix
       - overlay/video plane register handling refactor
       - add gamma support
    
      rockchip:
       - RX3328 support
    
      panfrost:
       - expose perf counters via hidden ioctls
    
      vkms:
       - enumerate CRC sources list
    
      ast:
       - rework BO handling
    
      mgag200:
       - rework BO handling
    
      dw-hdmi:
       - suspend/resume support
    
      rcar-du:
       - R8A774A1 Soc Support
       - LVDS dual-link mode support
       - Additional formats
       - Misc fixes
    
      omapdrm:
       - DSI command mode display support
    
      stm
       - fb modifier support
       - runtime PM support
    
      sun4i:
       - use vmap ops
    
      vc4:
       - binner bo binding rework
    
      v3d:
       - compute shader support
       - resync/sync fixes
       - job management refactoring
    
      lima:
       - NULL pointer in irq handler fix
       - scheduler default timeout
    
      virtio:
       - fence seqno support
       - trace events
    
      bochs:
       - misc fixes
    
      tc458767:
       - IRQ/HDP handling
    
      sii902x:
       - HDMI audio support
    
      atmel-hlcdc:
       - misc fixes
    
      meson:
       - zpos support"
    
    * tag 'drm-next-2019-07-16' of git://anongit.freedesktop.org/drm/drm: (1815 commits)
      Revert "Merge branch 'vmwgfx-next' of git://people.freedesktop.org/~thomash/linux into drm-next"
      Revert "mm: adjust apply_to_pfn_range interface for dropped token."
      mm: adjust apply_to_pfn_range interface for dropped token.
      drm/amdgpu/navi10: add uclk activity sensor
      drm/amdgpu: properly guard the generic discovery code
      drm/amdgpu: add missing documentation on new module parameters
      drm/amdgpu: don't invalidate caches in RELEASE_MEM, only do the writeback
      drm/amd/display: avoid 64-bit division
      drm/amdgpu/psp11: simplify the ucode register logic
      drm/amdgpu: properly guard DC support in navi code
      drm/amd/powerplay: vega20: fix uninitialized variable use
      drm/amd/display: dcn20: include linux/delay.h
      amdgpu: make pmu support optional
      drm/amd/powerplay: Zero initialize current_rpm in vega20_get_fan_speed_percent
      drm/amd/powerplay: Zero initialize freq in smu_v11_0_get_current_clk_freq
      drm/amd/powerplay: Use memset to initialize metrics structs
      drm/amdgpu/mes10.1: Fix header guard
      drm/amd/powerplay: add temperature sensor support for navi10
      drm/amdgpu: fix scheduler timeout calc
      drm/amdgpu: Prepare for hmm_range_register API change (v2)
      ...

commit 88209d2c5035737f96bcfc2fd73c0fd8d80e9bf1
Author: Emil Velikov <emil.velikov@collabora.com>
Date:   Mon May 27 09:17:35 2019 +0100

    drm/msm: drop DRM_AUTH usage from the driver
    
    The authentication can be circumvented, by design, by using the render
    node.
    
    From the driver POV there is no distinction between primary and render
    nodes, thus we can drop the token.
    
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Sean Paul <sean@poorly.run>
    Cc: freedreno@lists.freedesktop.org
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Emil Velikov <emil.velikov@collabora.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190527081741.14235-7-emil.l.velikov@gmail.com

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index da5a88413964..b2503e8a313b 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -983,17 +983,17 @@ static int msm_ioctl_submitqueue_close(struct drm_device *dev, void *data,
 }
 
 static const struct drm_ioctl_desc msm_ioctls[] = {
-	DRM_IOCTL_DEF_DRV(MSM_GET_PARAM,    msm_ioctl_get_param,    DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_NEW,      msm_ioctl_gem_new,      DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_INFO,     msm_ioctl_gem_info,     DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_PREP, msm_ioctl_gem_cpu_prep, DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_FINI, msm_ioctl_gem_cpu_fini, DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_SUBMIT,   msm_ioctl_gem_submit,   DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_WAIT_FENCE,   msm_ioctl_wait_fence,   DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_MADVISE,  msm_ioctl_gem_madvise,  DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_NEW,   msm_ioctl_submitqueue_new,   DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_CLOSE, msm_ioctl_submitqueue_close, DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_QUERY, msm_ioctl_submitqueue_query, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GET_PARAM,    msm_ioctl_get_param,    DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_NEW,      msm_ioctl_gem_new,      DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_INFO,     msm_ioctl_gem_info,     DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_PREP, msm_ioctl_gem_cpu_prep, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_FINI, msm_ioctl_gem_cpu_fini, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_SUBMIT,   msm_ioctl_gem_submit,   DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_WAIT_FENCE,   msm_ioctl_wait_fence,   DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_MADVISE,  msm_ioctl_gem_madvise,  DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_NEW,   msm_ioctl_submitqueue_new,   DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_CLOSE, msm_ioctl_submitqueue_close, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_QUERY, msm_ioctl_submitqueue_query, DRM_RENDER_ALLOW),
 };
 
 static const struct vm_operations_struct vm_ops = {

commit d229c592d12d1cf1c288adb03fe6f087c6b206e6
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jun 14 22:35:37 2019 +0200

    drm/msm: Drop drm_gem_prime_export/import
    
    They're the default.
    
    Aside: Would be really nice to switch the others over to
    drm_gem_object_funcs.
    
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Sean Paul <sean@poorly.run>
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190614203615.12639-22-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 87f92d3906ab..da5a88413964 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1034,8 +1034,6 @@ static struct drm_driver msm_driver = {
 	.dumb_map_offset    = msm_gem_dumb_map_offset,
 	.prime_handle_to_fd = drm_gem_prime_handle_to_fd,
 	.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
-	.gem_prime_export   = drm_gem_prime_export,
-	.gem_prime_import   = drm_gem_prime_import,
 	.gem_prime_pin      = msm_gem_prime_pin,
 	.gem_prime_unpin    = msm_gem_prime_unpin,
 	.gem_prime_get_sg_table = msm_gem_prime_get_sg_table,

commit 0424fdaf883a689d5185c0d0665b265373945898
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jun 17 17:39:24 2019 +0200

    drm/prime: Actually remove DRIVER_PRIME everywhere
    
    Split out to make the functional changes stick out more.
    
    All places where DRIVER_PRIME was used have been removed in previous
    patches already.
    
    v2: amdgpu gained DRIVER_SYNCOBJ_TIMELINE.
    
    v3: amdgpu lost DRIVER_SYNCOBJ_TIMELINE.
    
    v4: Don't add a space in i915_drv.c (Sam)
    
    v5: Add note that previous patches removed all the DRIVER_PRIME users
    already (Emil).
    
    v6: Fixupe ingenic (new driver) while applying.
    
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: amd-gfx@lists.freedesktop.org
    Cc: etnaviv@lists.freedesktop.org
    Cc: freedreno@lists.freedesktop.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: lima@lists.freedesktop.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: linux-aspeed@lists.ozlabs.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: linux-stm32@st-md-mailman.stormreply.com
    Cc: linux-tegra@vger.kernel.org
    Cc: nouveau@lists.freedesktop.org
    Cc: NXP Linux Team <linux-imx@nxp.com>
    Cc: spice-devel@lists.freedesktop.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: VMware Graphics <linux-graphics-maintainer@vmware.com>
    Cc: xen-devel@lists.xenproject.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190617153924.414-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 31deb87abfc6..87f92d3906ab 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1016,7 +1016,6 @@ static const struct file_operations fops = {
 
 static struct drm_driver msm_driver = {
 	.driver_features    = DRIVER_GEM |
-				DRIVER_PRIME |
 				DRIVER_RENDER |
 				DRIVER_ATOMIC |
 				DRIVER_MODESET,

commit 2aa31767259722d159e07240b0b8482a54223c2a
Author: Sean Paul <seanpaul@chromium.org>
Date:   Fri May 24 16:29:13 2019 -0400

    drm/msm: Re-order uninit function to work during probe defer
    
    If bind fails, we can call msm_drm_uninit before kms elements have been
    created. In this case, drm_atomic_helper_shutdown will fail since there
    are no drm objects. Only call drm unregistration and shutdown if drm is
    registered.
    
    Also while we're in here move the workqueue destruction to below
    component_unbind since components could be actively using the wq during
    uninit or in their unbind routine.
    
    Reviewed-by: Rob Clark <robdclark@chromium.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190524202919.179289-1-sean@poorly.run

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 72139ddcede6..229d49740677 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -259,13 +259,24 @@ static int msm_drm_uninit(struct device *dev)
 	struct msm_mdss *mdss = priv->mdss;
 	int i;
 
+	/*
+	 * Shutdown the hw if we're far enough along where things might be on.
+	 * If we run this too early, we'll end up panicking in any variety of
+	 * places. Since we don't register the drm device until late in
+	 * msm_drm_init, drm_dev->registered is used as an indicator that the
+	 * shutdown will be successful.
+	 */
+	if (ddev->registered) {
+		drm_dev_unregister(ddev);
+		drm_atomic_helper_shutdown(ddev);
+	}
+
 	/* We must cancel and cleanup any pending vblank enable/disable
 	 * work before drm_irq_uninstall() to avoid work re-enabling an
 	 * irq after uninstall has disabled it.
 	 */
 
 	flush_workqueue(priv->wq);
-	destroy_workqueue(priv->wq);
 
 	/* clean up event worker threads */
 	for (i = 0; i < priv->num_crtcs; i++) {
@@ -279,8 +290,6 @@ static int msm_drm_uninit(struct device *dev)
 
 	drm_kms_helper_poll_fini(ddev);
 
-	drm_dev_unregister(ddev);
-
 	msm_perf_debugfs_cleanup(priv);
 	msm_rd_debugfs_cleanup(priv);
 
@@ -288,7 +297,7 @@ static int msm_drm_uninit(struct device *dev)
 	if (fbdev && priv->fbdev)
 		msm_fbdev_free(ddev);
 #endif
-	drm_atomic_helper_shutdown(ddev);
+
 	drm_mode_config_cleanup(ddev);
 
 	pm_runtime_get_sync(dev);
@@ -313,6 +322,7 @@ static int msm_drm_uninit(struct device *dev)
 	ddev->dev_private = NULL;
 	drm_dev_put(ddev);
 
+	destroy_workqueue(priv->wq);
 	kfree(priv);
 
 	return 0;

commit 4368a1539c6b41ac3cddc06f5a5117952998804c
Author: Sean Paul <seanpaul@chromium.org>
Date:   Mon Jun 17 16:12:51 2019 -0400

    drm/msm: Depopulate platform on probe failure
    
    add_display_components() calls of_platform_populate, and we depopluate
    on pdev remove, but not when probe fails. So if we get a probe deferral
    in one of the components, we won't depopulate the platform. This causes
    the core to keep references to devices which should be destroyed, which
    causes issues when those same devices try to re-initialize on the next
    probe attempt.
    
    I think this is the reason we had issues with the gmu's device-managed
    resources on deferral (worked around in commit 94e3a17f33a5).
    
    Reviewed-by: Rob Clark <robdclark@chromium.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190617201301.133275-3-sean@poorly.run

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 4c51063531f1..72139ddcede6 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1319,16 +1319,24 @@ static int msm_pdev_probe(struct platform_device *pdev)
 
 	ret = add_gpu_components(&pdev->dev, &match);
 	if (ret)
-		return ret;
+		goto fail;
 
 	/* on all devices that I am aware of, iommu's which can map
 	 * any address the cpu can see are used:
 	 */
 	ret = dma_set_mask_and_coherent(&pdev->dev, ~0);
 	if (ret)
-		return ret;
+		goto fail;
+
+	ret = component_master_add_with_match(&pdev->dev, &msm_drm_ops, match);
+	if (ret)
+		goto fail;
 
-	return component_master_add_with_match(&pdev->dev, &msm_drm_ops, match);
+	return 0;
+
+fail:
+	of_platform_depopulate(&pdev->dev);
+	return ret;
 }
 
 static int msm_pdev_remove(struct platform_device *pdev)

commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 31deb87abfc6..f38d7367bd3b 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1,19 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2016-2018, The Linux Foundation. All rights reserved.
  * Copyright (C) 2013 Red Hat
  * Author: Rob Clark <robdclark@gmail.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <linux/kthread.h>

commit 295b22ae596c1d2dd8a4eb597d576f43acb4da6f
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Tue May 7 12:02:07 2019 -0600

    drm/msm: Pass the MMU domain index in struct msm_file_private
    
    Pass the index of the MMU domain in struct msm_file_private instead
    of assuming gpu->id throughout the submit path. This clears the way
    to change ctx->aspace to a per-instance pagetable.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@chromium.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 31deb87abfc6..4c51063531f1 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -611,6 +611,7 @@ static void load_gpu(struct drm_device *dev)
 
 static int context_init(struct drm_device *dev, struct drm_file *file)
 {
+	struct msm_drm_private *priv = dev->dev_private;
 	struct msm_file_private *ctx;
 
 	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
@@ -619,6 +620,7 @@ static int context_init(struct drm_device *dev, struct drm_file *file)
 
 	msm_submitqueue_init(dev, ctx);
 
+	ctx->aspace = priv->gpu->aspace;
 	file->driver_priv = ctx;
 
 	return 0;

commit 70b5f09e4389c789263c6d79c539b8378e3af3bc
Merge: 42f1a013300d b02872df58ac
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Apr 24 11:54:26 2019 +1000

    Merge tag 'drm-msm-next-2019-04-21' of https://gitlab.freedesktop.org/drm/msm into drm-next
    
    This time around it is a bunch of cleanup and fixes, expanding gpu
    "zap" shader support (so we can take the GPU out of secure mode on
    boot) to a6xx, and small UABI extension to support robustness (see
    mesa MR 673).
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    From: Rob Clark <robdclark@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/CAF6AEGsHwsEfi4y2LYKSqeqDEYvffwVgKhiP8jHcHpxp13J5LQ@mail.gmail.com

commit 48e7f18392c66f9b69ebac11c54f1a2e033ced54
Author: Kristian H. Kristensen <hoegsberg@gmail.com>
Date:   Wed Mar 20 10:09:08 2019 -0700

    drm/msm: Implement .gem_free_object_unlocked
    
    We use a llist and a worker to delay the object cleanup. This avoids
    taking mmap_sem and struct_mutex in the wrong order when calling
    drm_gem_object_put_unlocked() from drm_gem_mmap().
    
    Fixes lockdep problem with copy_from_user() in msm_ioctl_gem_submit().
    
    Signed-off-by: Kristian H. Kristensen <hoegsberg@chromium.org>
    Signed-off-by: Rob Clark <robdclark@chromium.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 37f18b55d11f..154dab0775f3 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -458,6 +458,9 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 
 	priv->wq = alloc_ordered_workqueue("msm", 0);
 
+	INIT_WORK(&priv->free_work, msm_gem_free_work);
+	init_llist_head(&priv->free_list);
+
 	INIT_LIST_HEAD(&priv->inactive_list);
 
 	drm_mode_config_init(ddev);
@@ -1026,7 +1029,7 @@ static struct drm_driver msm_driver = {
 	.irq_uninstall      = msm_irq_uninstall,
 	.enable_vblank      = msm_enable_vblank,
 	.disable_vblank     = msm_disable_vblank,
-	.gem_free_object    = msm_gem_free_object,
+	.gem_free_object_unlocked = msm_gem_free_object,
 	.gem_vm_ops         = &vm_ops,
 	.dumb_create        = msm_gem_dumb_create,
 	.dumb_map_offset    = msm_gem_dumb_map_offset,

commit b0fb66043a0d471a5acfe743adf90a0c447aca6b
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Fri Mar 22 14:21:22 2019 -0600

    drm/msm/gpu: Add submit queue queries
    
    Add the capability to query information from a submit queue.
    The first available parameter is for querying the number of GPU faults
    (hangs) that can be attributed to the queue.
    
    This is useful for implementing context robustness. A user context can
    regularly query the number of faults to see if it is responsible for any
    and if so it can invalidate itself.
    
    This is also helpful for testing by confirming to the user  driver if a
    particular command stream caused a fault (or not as the case may be).
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@chromium.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 0bdd93648761..37f18b55d11f 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -39,9 +39,10 @@
  *           MSM_GEM_INFO ioctl.
  * - 1.4.0 - softpin, MSM_RELOC_BO_DUMP, and GEM_INFO support to set/get
  *           GEM object's debug name
+ * - 1.5.0 - Add SUBMITQUERY_QUERY ioctl
  */
 #define MSM_VERSION_MAJOR	1
-#define MSM_VERSION_MINOR	4
+#define MSM_VERSION_MINOR	5
 #define MSM_VERSION_PATCHLEVEL	0
 
 static const struct drm_mode_config_funcs mode_config_funcs = {
@@ -964,6 +965,11 @@ static int msm_ioctl_submitqueue_new(struct drm_device *dev, void *data,
 		args->flags, &args->id);
 }
 
+static int msm_ioctl_submitqueue_query(struct drm_device *dev, void *data,
+		struct drm_file *file)
+{
+	return msm_submitqueue_query(dev, file->driver_priv, data);
+}
 
 static int msm_ioctl_submitqueue_close(struct drm_device *dev, void *data,
 		struct drm_file *file)
@@ -984,6 +990,7 @@ static const struct drm_ioctl_desc msm_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(MSM_GEM_MADVISE,  msm_ioctl_gem_madvise,  DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_NEW,   msm_ioctl_submitqueue_new,   DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_CLOSE, msm_ioctl_submitqueue_close, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_QUERY, msm_ioctl_submitqueue_query, DRM_AUTH|DRM_RENDER_ALLOW),
 };
 
 static const struct vm_operations_struct vm_ops = {

commit cd7d3a1bb42e0756b17ccfafbd956ca7ed757846
Merge: 6b5c029df5e4 4b057e73f28f
Author: Sean Paul <seanpaul@chromium.org>
Date:   Wed Mar 6 09:22:18 2019 -0500

    Merge drm/drm-next into drm-misc-next
    
    Picking up v5.0 + missed misc-fixes from last release
    
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

commit a5f2fafece141ef3509e686cea576366d55cabb6
Merge: 71f4e45a4ed3 860433ed2a55
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Feb 20 12:16:30 2019 +1000

    Merge https://gitlab.freedesktop.org/drm/msm into drm-next
    
    On the display side, cleanups and fixes to enabled modifiers
    (QCOM_COMPRESSED).  And otherwise mostly misc fixes all around.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    From: Rob Clark <robdclark@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/CAF6AEGuZ5uBKpf=fHvKpTiD10nychuEY8rnE+HeRz0QMvtY5_A@mail.gmail.com

commit 860433ed2a55dcd18f36c61b3c4fdb12dc76c869
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Tue Feb 19 11:40:19 2019 -0700

    drm/msm: Truncate the buffer object name if the copy from user failed
    
    (Resend since there was a compile error that I forgot to commit before sending)
    
    If there is a error while doing a copy_from_user() for MSM_INFO_SET_NAME
    make sure to truncate the object name so that there isn't a chance that
    we'll have random data in the string.
    
    This is on top of [1] reported and fixed by Dan Carpenter.
    
    [1] https://patchwork.freedesktop.org/series/56656/
    
    Fixes: f05c83e77460 ("drm/msm: add uapi to get/set debug name")
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 87eae44a1006..906b2bb79f6a 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -852,8 +852,11 @@ static int msm_ioctl_gem_info(struct drm_device *dev, void *data,
 			break;
 		}
 		if (copy_from_user(msm_obj->name, u64_to_user_ptr(args->value),
-				   args->len))
+				   args->len)) {
+			msm_obj->name[0] = '\0';
 			ret = -EFAULT;
+			break;
+		}
 		msm_obj->name[args->len] = '\0';
 		for (i = 0; i < args->len; i++) {
 			if (!isprint(msm_obj->name[i])) {

commit 7cce8e4efe5e782e130f79f8d55fdad48f2db52d
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Feb 14 10:19:27 2019 +0300

    drm/msm: fix an error code in the ioctl
    
    The copy_to/from_user() functions return the number of bytes remaining
    to be copied but we should return -EFAULT to the user.
    
    Fixes: f05c83e77460 ("drm/msm: add uapi to get/set debug name")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 5e7b5fa01401..87eae44a1006 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -851,8 +851,9 @@ static int msm_ioctl_gem_info(struct drm_device *dev, void *data,
 			ret = -EINVAL;
 			break;
 		}
-		ret = copy_from_user(msm_obj->name,
-			u64_to_user_ptr(args->value), args->len);
+		if (copy_from_user(msm_obj->name, u64_to_user_ptr(args->value),
+				   args->len))
+			ret = -EFAULT;
 		msm_obj->name[args->len] = '\0';
 		for (i = 0; i < args->len; i++) {
 			if (!isprint(msm_obj->name[i])) {
@@ -868,8 +869,9 @@ static int msm_ioctl_gem_info(struct drm_device *dev, void *data,
 		}
 		args->len = strlen(msm_obj->name);
 		if (args->value) {
-			ret = copy_to_user(u64_to_user_ptr(args->value),
-					msm_obj->name, args->len);
+			if (copy_to_user(u64_to_user_ptr(args->value),
+					 msm_obj->name, args->len))
+				ret = -EFAULT;
 		}
 		break;
 	}

commit dd55cf6929e61922961b8515e73dc4d8443089d2
Author: Rob Herring <robh@kernel.org>
Date:   Sat Feb 2 09:41:56 2019 -0600

    drm: msm: Switch to use drm_gem_object reservation_object
    
    Now that the base struct drm_gem_object has a reservation_object, use it
    and remove the private BO one.
    
    We can't use the drm_gem_reservation_object_wait() helper for MSM
    because (in theory) msm_gem_cpu_prep() will also do some cache
    maintenance on the GEM object.
    
    Cc: David Airlie <airlied@linux.ie>
    Cc: linux-arm-msm@vger.kernel.org
    Cc: dri-devel@lists.freedesktop.org
    Cc: freedreno@lists.freedesktop.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Rob Clark <robdclark@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190202154158.10443-4-robh@kernel.org
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 8747fb32a106..0689194b295d 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1085,7 +1085,6 @@ static struct drm_driver msm_driver = {
 	.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
 	.gem_prime_export   = drm_gem_prime_export,
 	.gem_prime_import   = drm_gem_prime_import,
-	.gem_prime_res_obj  = msm_gem_prime_res_obj,
 	.gem_prime_pin      = msm_gem_prime_pin,
 	.gem_prime_unpin    = msm_gem_prime_unpin,
 	.gem_prime_get_sg_table = msm_gem_prime_get_sg_table,

commit 48d1d28eec5cd7ebb8bb30009078feb438172cf2
Author: Jeykumar Sankaran <jsanka@codeaurora.org>
Date:   Fri Dec 14 15:57:55 2018 -0800

    drm/msm: subclass work object for vblank events
    
    msm maintains a separate structure to define vblank
    work definitions and a list to track events submitted
    to the workqueue. We can avoid this redundant list
    and its protection mechanism, if we subclass the
    work object to encapsulate vblank event parameters.
    
    changes in v2:
            - subclass optimization on system wq (Sean Paul)
    changes in v3:
            - none
    changes in v4:
            - move flush_workqueue before irq uninstall
    changes in v5:
            - none
    
    Signed-off-by: Jeykumar Sankaran <jsanka@codeaurora.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index a8a0b246e3a9..5e7b5fa01401 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -207,61 +207,44 @@ u32 msm_readl(const void __iomem *addr)
 	return val;
 }
 
-struct vblank_event {
-	struct list_head node;
+struct msm_vblank_work {
+	struct work_struct work;
 	int crtc_id;
 	bool enable;
+	struct msm_drm_private *priv;
 };
 
 static void vblank_ctrl_worker(struct work_struct *work)
 {
-	struct msm_vblank_ctrl *vbl_ctrl = container_of(work,
-						struct msm_vblank_ctrl, work);
-	struct msm_drm_private *priv = container_of(vbl_ctrl,
-					struct msm_drm_private, vblank_ctrl);
+	struct msm_vblank_work *vbl_work = container_of(work,
+						struct msm_vblank_work, work);
+	struct msm_drm_private *priv = vbl_work->priv;
 	struct msm_kms *kms = priv->kms;
-	struct vblank_event *vbl_ev, *tmp;
-	unsigned long flags;
-
-	spin_lock_irqsave(&vbl_ctrl->lock, flags);
-	list_for_each_entry_safe(vbl_ev, tmp, &vbl_ctrl->event_list, node) {
-		list_del(&vbl_ev->node);
-		spin_unlock_irqrestore(&vbl_ctrl->lock, flags);
-
-		if (vbl_ev->enable)
-			kms->funcs->enable_vblank(kms,
-						priv->crtcs[vbl_ev->crtc_id]);
-		else
-			kms->funcs->disable_vblank(kms,
-						priv->crtcs[vbl_ev->crtc_id]);
-
-		kfree(vbl_ev);
 
-		spin_lock_irqsave(&vbl_ctrl->lock, flags);
-	}
+	if (vbl_work->enable)
+		kms->funcs->enable_vblank(kms, priv->crtcs[vbl_work->crtc_id]);
+	else
+		kms->funcs->disable_vblank(kms,	priv->crtcs[vbl_work->crtc_id]);
 
-	spin_unlock_irqrestore(&vbl_ctrl->lock, flags);
+	kfree(vbl_work);
 }
 
 static int vblank_ctrl_queue_work(struct msm_drm_private *priv,
 					int crtc_id, bool enable)
 {
-	struct msm_vblank_ctrl *vbl_ctrl = &priv->vblank_ctrl;
-	struct vblank_event *vbl_ev;
-	unsigned long flags;
+	struct msm_vblank_work *vbl_work;
 
-	vbl_ev = kzalloc(sizeof(*vbl_ev), GFP_ATOMIC);
-	if (!vbl_ev)
+	vbl_work = kzalloc(sizeof(*vbl_work), GFP_ATOMIC);
+	if (!vbl_work)
 		return -ENOMEM;
 
-	vbl_ev->crtc_id = crtc_id;
-	vbl_ev->enable = enable;
+	INIT_WORK(&vbl_work->work, vblank_ctrl_worker);
 
-	spin_lock_irqsave(&vbl_ctrl->lock, flags);
-	list_add_tail(&vbl_ev->node, &vbl_ctrl->event_list);
-	spin_unlock_irqrestore(&vbl_ctrl->lock, flags);
+	vbl_work->crtc_id = crtc_id;
+	vbl_work->enable = enable;
+	vbl_work->priv = priv;
 
-	queue_work(priv->wq, &vbl_ctrl->work);
+	queue_work(priv->wq, &vbl_work->work);
 
 	return 0;
 }
@@ -273,19 +256,15 @@ static int msm_drm_uninit(struct device *dev)
 	struct msm_drm_private *priv = ddev->dev_private;
 	struct msm_kms *kms = priv->kms;
 	struct msm_mdss *mdss = priv->mdss;
-	struct msm_vblank_ctrl *vbl_ctrl = &priv->vblank_ctrl;
-	struct vblank_event *vbl_ev, *tmp;
 	int i;
 
 	/* We must cancel and cleanup any pending vblank enable/disable
 	 * work before drm_irq_uninstall() to avoid work re-enabling an
 	 * irq after uninstall has disabled it.
 	 */
-	flush_work(&vbl_ctrl->work);
-	list_for_each_entry_safe(vbl_ev, tmp, &vbl_ctrl->event_list, node) {
-		list_del(&vbl_ev->node);
-		kfree(vbl_ev);
-	}
+
+	flush_workqueue(priv->wq);
+	destroy_workqueue(priv->wq);
 
 	/* clean up event worker threads */
 	for (i = 0; i < priv->num_crtcs; i++) {
@@ -315,9 +294,6 @@ static int msm_drm_uninit(struct device *dev)
 	drm_irq_uninstall(ddev);
 	pm_runtime_put_sync(dev);
 
-	flush_workqueue(priv->wq);
-	destroy_workqueue(priv->wq);
-
 	if (kms && kms->funcs)
 		kms->funcs->destroy(kms);
 
@@ -482,9 +458,6 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	priv->wq = alloc_ordered_workqueue("msm", 0);
 
 	INIT_LIST_HEAD(&priv->inactive_list);
-	INIT_LIST_HEAD(&priv->vblank_ctrl.event_list);
-	INIT_WORK(&priv->vblank_ctrl.work, vblank_ctrl_worker);
-	spin_lock_init(&priv->vblank_ctrl.lock);
 
 	drm_mode_config_init(ddev);
 

commit d9db30ce7d04515d5d09a2517f5559c6f2f03c52
Author: Jeykumar Sankaran <jsanka@codeaurora.org>
Date:   Fri Dec 14 15:57:54 2018 -0800

    drm/msm: clean up display thread
    
    Since there are no clients using these threads,
    cleaning it up.
    
    changes in v2:
            - switch all the dependent clients to use system wq
              before removing the disp_threads (Sean Paul)
    changes in v3:
            - none
    changes in v4:
            - none
    changes in v5:
            - Rebase on latest tip with [1] (Sean Paul)
    
    [1] https://patchwork.freedesktop.org/patch/255105/
    
    Signed-off-by: Jeykumar Sankaran <jsanka@codeaurora.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 6c311f92c11d..a8a0b246e3a9 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -287,13 +287,8 @@ static int msm_drm_uninit(struct device *dev)
 		kfree(vbl_ev);
 	}
 
-	/* clean up display commit/event worker threads */
+	/* clean up event worker threads */
 	for (i = 0; i < priv->num_crtcs; i++) {
-		if (priv->disp_thread[i].thread) {
-			kthread_destroy_worker(&priv->disp_thread[i].worker);
-			priv->disp_thread[i].thread = NULL;
-		}
-
 		if (priv->event_thread[i].thread) {
 			kthread_destroy_worker(&priv->event_thread[i].worker);
 			priv->event_thread[i].thread = NULL;
@@ -551,27 +546,6 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	 */
 	param.sched_priority = 16;
 	for (i = 0; i < priv->num_crtcs; i++) {
-
-		/* initialize display thread */
-		priv->disp_thread[i].crtc_id = priv->crtcs[i]->base.id;
-		kthread_init_worker(&priv->disp_thread[i].worker);
-		priv->disp_thread[i].dev = ddev;
-		priv->disp_thread[i].thread =
-			kthread_run(kthread_worker_fn,
-				&priv->disp_thread[i].worker,
-				"crtc_commit:%d", priv->disp_thread[i].crtc_id);
-		if (IS_ERR(priv->disp_thread[i].thread)) {
-			DRM_DEV_ERROR(dev, "failed to create crtc_commit kthread\n");
-			priv->disp_thread[i].thread = NULL;
-			goto err_msm_uninit;
-		}
-
-		ret = sched_setscheduler(priv->disp_thread[i].thread,
-					 SCHED_FIFO, &param);
-		if (ret)
-			dev_warn(dev, "disp_thread set priority failed: %d\n",
-				 ret);
-
 		/* initialize event thread */
 		priv->event_thread[i].crtc_id = priv->crtcs[i]->base.id;
 		kthread_init_worker(&priv->event_thread[i].worker);
@@ -586,13 +560,6 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 			goto err_msm_uninit;
 		}
 
-		/**
-		 * event thread should also run at same priority as disp_thread
-		 * because it is handling frame_done events. A lower priority
-		 * event thread and higher priority disp_thread can causes
-		 * frame_pending counters beyond 2. This can lead to commit
-		 * failure at crtc commit level.
-		 */
 		ret = sched_setscheduler(priv->event_thread[i].thread,
 					 SCHED_FIFO, &param);
 		if (ret)

commit 5aeb66563fe22e7ce2e7b403b531630865a87446
Author: Jeykumar Sankaran <jsanka@codeaurora.org>
Date:   Fri Dec 14 15:57:52 2018 -0800

    drm/msm/dpu: use msm wq for vblank events
    
    DPU was using one thread per display to dispatch async commits and
    vblank requests. Since clean up already happened in msm to use the
    common thread for all the display commits, display threads are only
    used to cater vblank requests. Since a single thread is sufficient
    to do the job without any performance hits, use msm workqueue
    to queue requests. A separate patch is submitted later in this
    series to remove the display threads altogether.
    
    changes in v2:
            - switch to system wq before removing disp threads (Sean Paul)
    changes in v3:
            - none
    changes in v4:
            - use msm wq for vblank events
    changes in v5:
            - none
    
    Signed-off-by: Jeykumar Sankaran <jsanka@codeaurora.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 5f859653442d..6c311f92c11d 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -213,7 +213,7 @@ struct vblank_event {
 	bool enable;
 };
 
-static void vblank_ctrl_worker(struct kthread_work *work)
+static void vblank_ctrl_worker(struct work_struct *work)
 {
 	struct msm_vblank_ctrl *vbl_ctrl = container_of(work,
 						struct msm_vblank_ctrl, work);
@@ -261,8 +261,7 @@ static int vblank_ctrl_queue_work(struct msm_drm_private *priv,
 	list_add_tail(&vbl_ev->node, &vbl_ctrl->event_list);
 	spin_unlock_irqrestore(&vbl_ctrl->lock, flags);
 
-	kthread_queue_work(&priv->disp_thread[crtc_id].worker,
-			&vbl_ctrl->work);
+	queue_work(priv->wq, &vbl_ctrl->work);
 
 	return 0;
 }
@@ -282,7 +281,7 @@ static int msm_drm_uninit(struct device *dev)
 	 * work before drm_irq_uninstall() to avoid work re-enabling an
 	 * irq after uninstall has disabled it.
 	 */
-	kthread_flush_work(&vbl_ctrl->work);
+	flush_work(&vbl_ctrl->work);
 	list_for_each_entry_safe(vbl_ev, tmp, &vbl_ctrl->event_list, node) {
 		list_del(&vbl_ev->node);
 		kfree(vbl_ev);
@@ -489,7 +488,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 
 	INIT_LIST_HEAD(&priv->inactive_list);
 	INIT_LIST_HEAD(&priv->vblank_ctrl.event_list);
-	kthread_init_work(&priv->vblank_ctrl.work, vblank_ctrl_worker);
+	INIT_WORK(&priv->vblank_ctrl.work, vblank_ctrl_worker);
 	spin_lock_init(&priv->vblank_ctrl.lock);
 
 	drm_mode_config_init(ddev);

commit 3c12568271e294825df2f5377e1993a4a26a8bc0
Author: Jeykumar Sankaran <jsanka@codeaurora.org>
Date:   Fri Dec 14 15:57:51 2018 -0800

    drm/msm/dpu: use kthread_destroy_worker to release msm workers
    
    use kthread_destroy_worker to destroy workers and
    release their associated kthreads.
    
    changes in v3:
            - introduced in the series
    changes in v4:
            - none
    changes in v5:
            - none
    
    Signed-off-by: Jeykumar Sankaran <jsanka@codeaurora.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index d2cdc7b553fe..5f859653442d 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -291,14 +291,12 @@ static int msm_drm_uninit(struct device *dev)
 	/* clean up display commit/event worker threads */
 	for (i = 0; i < priv->num_crtcs; i++) {
 		if (priv->disp_thread[i].thread) {
-			kthread_flush_worker(&priv->disp_thread[i].worker);
-			kthread_stop(priv->disp_thread[i].thread);
+			kthread_destroy_worker(&priv->disp_thread[i].worker);
 			priv->disp_thread[i].thread = NULL;
 		}
 
 		if (priv->event_thread[i].thread) {
-			kthread_flush_worker(&priv->event_thread[i].worker);
-			kthread_stop(priv->event_thread[i].thread);
+			kthread_destroy_worker(&priv->event_thread[i].worker);
 			priv->event_thread[i].thread = NULL;
 		}
 	}

commit 5b38e7475e3dc54c1091ee169fd050b3f10461fc
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jan 29 11:42:46 2019 +0100

    drm/irq: Don't check for DRIVER_HAVE_IRQ in drm_irq_(un)install
    
    If a non-legacy driver calls these it's valid to assume there is
    interrupt support. The flag is really only needed for legacy drivers,
    which control IRQ enabling/disabling through the DRM_IOCTL_CONTROL
    legacy IOCTL.
    
    Also remove all the flag usage from non-legacy drivers.
    
    v2: Review from Emil:
    - improve commit message
    - I forgot hibmc, fix that
    
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: spice-devel@lists.freedesktop.org
    Cc: amd-gfx@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190129104248.26607-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index d2cdc7b553fe..8747fb32a106 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1063,8 +1063,7 @@ static const struct file_operations fops = {
 };
 
 static struct drm_driver msm_driver = {
-	.driver_features    = DRIVER_HAVE_IRQ |
-				DRIVER_GEM |
+	.driver_features    = DRIVER_GEM |
 				DRIVER_PRIME |
 				DRIVER_RENDER |
 				DRIVER_ATOMIC |

commit 4971f090aa7f6ce5daa094ce4334f6618f93a7eb
Merge: c76cd634eb5b 2a3c83f5fe07
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 25 11:48:26 2018 -0800

    Merge tag 'drm-next-2018-12-14' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Dave Airlie:
     "Core:
       - shared fencing staging removal
       - drop transactional atomic helpers and move helpers to new location
       - DP/MST atomic cleanup
       - Leasing cleanups and drop EXPORT_SYMBOL
       - Convert drivers to atomic helpers and generic fbdev.
       - removed deprecated obj_ref/unref in favour of get/put
       - Improve dumb callback documentation
       - MODESET_LOCK_BEGIN/END helpers
    
      panels:
       - CDTech panels, Banana Pi Panel, DLC1010GIG,
       - Olimex LCD-O-LinuXino, Samsung S6D16D0, Truly NT35597 WQXGA,
       - Himax HX8357D, simulated RTSM AEMv8.
       - GPD Win2 panel
       - AUO G101EVN010
    
      vgem:
       - render node support
    
      ttm:
       - move global init out of drivers
       - fix LRU handling for ghost objects
       - Support for simultaneous submissions to multiple engines
    
      scheduler:
       - timeout/fault handling changes to help GPU recovery
       - helpers for hw with preemption support
    
      i915:
       - Scaler/Watermark fixes
       - DP MST + powerwell fixes
       - PSR fixes
       - Break long get/put shmemfs pages
       - Icelake fixes
       - Icelake DSI video mode enablement
       - Engine workaround improvements
    
      amdgpu:
       - freesync support
       - GPU reset enabled on CI, VI, SOC15 dGPUs
       - ABM support in DC
       - KFD support for vega12/polaris12
       - SDMA paging queue on vega
       - More amdkfd code sharing
       - DCC scanout on GFX9
       - DC kerneldoc
       - Updated SMU firmware for GFX8 chips
       - XGMI PSP + hive reset support
       - GPU reset
       - DC trace support
       - Powerplay updates for newer Polaris
       - Cursor plane update fast path
       - kfd dma-buf support
    
      virtio-gpu:
       - add EDID support
    
      vmwgfx:
       - pageflip with damage support
    
      nouveau:
       - Initial Turing TU104/TU106 modesetting support
    
      msm:
       - a2xx gpu support for apq8060 and imx5
       - a2xx gpummu support
       - mdp4 display support for apq8060
       - DPU fixes and cleanups
       - enhanced profiling support
       - debug object naming interface
       - get_iova/page pinning decoupling
    
      tegra:
       - Tegra194 host1x, VIC and display support enabled
       - Audio over HDMI for Tegra186 and Tegra194
    
      exynos:
       - DMA/IOMMU refactoring
       - plane alpha + blend mode support
       - Color format fixes for mixer driver
    
      rcar-du:
       - R8A7744 and R8A77470 support
       - R8A77965 LVDS support
    
      imx:
       - fbdev emulation fix
       - multi-tiled scalling fixes
       - SPDX identifiers
    
      rockchip
       - dw_hdmi support
       - dw-mipi-dsi + dual dsi support
       - mailbox read size fix
    
      qxl:
       - fix cursor pinning
    
      vc4:
       - YUV support (scaling + cursor)
    
      v3d:
       - enable TFU (Texture Formatting Unit)
    
      mali-dp:
       - add support for linear tiled formats
    
      sun4i:
       - Display Engine 3 support
       - H6 DE3 mixer 0 support
       - H6 display engine support
       - dw-hdmi support
       - H6 HDMI phy support
       - implicit fence waiting
       - BGRX8888 support
    
      meson:
       - Overlay plane support
       - implicit fence waiting
       - HDMI 1.4 4k modes
    
      bridge:
       - i2c fixes for sii902x"
    
    * tag 'drm-next-2018-12-14' of git://anongit.freedesktop.org/drm/drm: (1403 commits)
      drm/amd/display: Add fast path for cursor plane updates
      drm/amdgpu: Enable GPU recovery by default for CI
      drm/amd/display: Fix duplicating scaling/underscan connector state
      drm/amd/display: Fix unintialized max_bpc state values
      Revert "drm/amd/display: Set RMX_ASPECT as default"
      drm/amdgpu: Fix stub function name
      drm/msm/dpu: Fix clock issue after bind failure
      drm/msm/dpu: Clean up dpu_media_info.h static inline functions
      drm/msm/dpu: Further cleanups for static inline functions
      drm/msm/dpu: Cleanup the debugfs functions
      drm/msm/dpu: Remove dpu_irq and unused functions
      drm/msm: Make irq_postinstall optional
      drm/msm/dpu: Cleanup callers of dpu_hw_blk_init
      drm/msm/dpu: Remove unused functions
      drm/msm/dpu: Remove dpu_crtc_is_enabled()
      drm/msm/dpu: Remove dpu_crtc_get_mixer_height
      drm/msm/dpu: Remove dpu_dbg
      drm/msm: dpu: Remove crtc_lock
      drm/msm: dpu: Remove vblank_requested flag from dpu_crtc
      drm/msm: dpu: Separate crtc assignment from vblank enable
      ...

commit ab07e0c19fda03712c979626178cf9e23d610aaf
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Mon Dec 3 15:47:19 2018 -0700

    drm/msm: Make irq_postinstall optional
    
    Allow the KMS operation 'irq_postinstall' to be optional
    so that the target display drivers don't need to define
    a dummy function if they don't need one.
    
    v3: No changes
    
    Reviewed-by: Sean Paul <sean@poorly.run>
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 79d1847f1c28..6265be8f4119 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -752,7 +752,11 @@ static int msm_irq_postinstall(struct drm_device *dev)
 	struct msm_drm_private *priv = dev->dev_private;
 	struct msm_kms *kms = priv->kms;
 	BUG_ON(!kms);
-	return kms->funcs->irq_postinstall(kms);
+
+	if (kms->funcs->irq_postinstall)
+		return kms->funcs->irq_postinstall(kms);
+
+	return 0;
 }
 
 static void msm_irq_uninstall(struct drm_device *dev)

commit e6f6d63ed14c20528aa6df05a8f0707c183c6ba3
Author: Jonathan Marek <jonathan@marek.ca>
Date:   Tue Dec 4 10:16:58 2018 -0500

    drm/msm: add headless gpu device for imx5
    
    This patch allows using drm/msm without qcom display hardware. It adds a
    amd,imageon compatible, which is used instead of qcom,adreno, but does
    not require a top level msm node.
    
    Signed-off-by: Jonathan Marek <jonathan@marek.ca>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index ae3d6b440bcc..79d1847f1c28 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -520,17 +520,13 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 		priv->kms = kms;
 		break;
 	default:
-		kms = ERR_PTR(-ENODEV);
+		/* valid only for the dummy headless case, where of_node=NULL */
+		WARN_ON(dev->of_node);
+		kms = NULL;
 		break;
 	}
 
 	if (IS_ERR(kms)) {
-		/*
-		 * NOTE: once we have GPU support, having no kms should not
-		 * be considered fatal.. ideally we would still support gpu
-		 * and (for example) use dmabuf/prime to share buffers with
-		 * imx drm driver on iMX5
-		 */
 		DRM_DEV_ERROR(dev, "failed to load kms\n");
 		ret = PTR_ERR(kms);
 		priv->kms = NULL;
@@ -648,7 +644,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	drm_mode_config_reset(ddev);
 
 #ifdef CONFIG_DRM_FBDEV_EMULATION
-	if (fbdev)
+	if (kms && fbdev)
 		priv->fbdev = msm_fbdev_init(ddev);
 #endif
 
@@ -1332,6 +1328,7 @@ static int add_display_components(struct device *dev,
 static const struct of_device_id msm_gpu_match[] = {
 	{ .compatible = "qcom,adreno" },
 	{ .compatible = "qcom,adreno-3xx" },
+	{ .compatible = "amd,imageon" },
 	{ .compatible = "qcom,kgsl-3d0" },
 	{ },
 };
@@ -1376,9 +1373,11 @@ static int msm_pdev_probe(struct platform_device *pdev)
 	struct component_match *match = NULL;
 	int ret;
 
-	ret = add_display_components(&pdev->dev, &match);
-	if (ret)
-		return ret;
+	if (get_mdp_ver(pdev)) {
+		ret = add_display_components(&pdev->dev, &match);
+		if (ret)
+			return ret;
+	}
 
 	ret = add_gpu_components(&pdev->dev, &match);
 	if (ret)

commit c2052a4e5c99f7edcb0283e6e12b2fb6975b7353
Author: Jonathan Marek <jonathan@marek.ca>
Date:   Wed Nov 14 17:08:04 2018 -0500

    drm/msm: implement a2xx mmu
    
    A2XX has its own very simple MMU.
    
    Added a msm_use_mmu() function because we can't rely on iommu_present to
    decide to use MMU or not.
    
    Signed-off-by: Jonathan Marek <jonathan@marek.ca>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 7661ca71fca6..ae3d6b440bcc 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -26,6 +26,7 @@
 #include "msm_gem.h"
 #include "msm_gpu.h"
 #include "msm_kms.h"
+#include "adreno/adreno_gpu.h"
 
 
 /*
@@ -361,6 +362,14 @@ static int get_mdp_ver(struct platform_device *pdev)
 
 #include <linux/of_address.h>
 
+bool msm_use_mmu(struct drm_device *dev)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+
+	/* a2xx comes with its own MMU */
+	return priv->is_a2xx || iommu_present(&platform_bus_type);
+}
+
 static int msm_init_vram(struct drm_device *dev)
 {
 	struct msm_drm_private *priv = dev->dev_private;
@@ -399,7 +408,7 @@ static int msm_init_vram(struct drm_device *dev)
 		 * Grab the entire CMA chunk carved out in early startup in
 		 * mach-msm:
 		 */
-	} else if (!iommu_present(&platform_bus_type)) {
+	} else if (!msm_use_mmu(dev)) {
 		DRM_INFO("using %s VRAM carveout\n", vram);
 		size = memparse(vram, NULL);
 	}

commit d1d9d0e1724d6a7123b4280fdf6630ae70f96c9c
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Dec 4 10:04:41 2018 -0800

    drm/msm: Only add available components
    
    When trying to get the display up on my sdm845 board I noticed that
    the display wouldn't probe if I had the dsi1 node marked as "disabled"
    even though my board doesn't use dsi1.  It looks like the msm code
    adds all nodes to its list of components even if they are disabled.  I
    believe this doesn't work because all registered components need to
    come up before we finish probing.  Let's do like other DRM code and
    only add available components.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 1a3b80d31726..7661ca71fca6 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1256,8 +1256,10 @@ static int add_components_mdp(struct device *mdp_dev,
 		if (!intf)
 			continue;
 
-		drm_of_component_match_add(master_dev, matchptr, compare_of,
-					   intf);
+		if (of_device_is_available(intf))
+			drm_of_component_match_add(master_dev, matchptr,
+						   compare_of, intf);
+
 		of_node_put(intf);
 	}
 

commit b2ccfdf1dde588d0e90d6d235b9ae557cbea5d4d
Author: Jonathan Marek <jonathan@marek.ca>
Date:   Wed Nov 21 20:52:35 2018 -0500

    drm/msm: set priv->kms to NULL before uninit
    
    otherwise, priv->kms is non-NULL and msm_drm_uninit will cause a panic.
    
    Signed-off-by: Jonathan Marek <jonathan@marek.ca>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index cce5bc97b863..1a3b80d31726 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -524,6 +524,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 		 */
 		DRM_DEV_ERROR(dev, "failed to load kms\n");
 		ret = PTR_ERR(kms);
+		priv->kms = NULL;
 		goto err_msm_uninit;
 	}
 

commit 1fed8df301336d904ba45b1bda0c7ce5bd7e6932
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Nov 29 10:30:04 2018 -0500

    drm/msm: bump UAPI version
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index c08f83c7ca57..cce5bc97b863 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -36,9 +36,11 @@
  * - 1.3.0 - adds GMEM_BASE + NR_RINGS params, SUBMITQUEUE_NEW +
  *           SUBMITQUEUE_CLOSE ioctls, and MSM_INFO_IOVA flag for
  *           MSM_GEM_INFO ioctl.
+ * - 1.4.0 - softpin, MSM_RELOC_BO_DUMP, and GEM_INFO support to set/get
+ *           GEM object's debug name
  */
 #define MSM_VERSION_MAJOR	1
-#define MSM_VERSION_MINOR	3
+#define MSM_VERSION_MINOR	4
 #define MSM_VERSION_PATCHLEVEL	0
 
 static const struct drm_mode_config_funcs mode_config_funcs = {

commit f05c83e7746088e6ada6ce83fd7840b4b7b52ffe
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Nov 29 10:27:22 2018 -0500

    drm/msm: add uapi to get/set debug name
    
    Add UAPI to get/set GEM objects' debug name.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index fe86c675d5b7..c08f83c7ca57 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -23,6 +23,7 @@
 #include "msm_drv.h"
 #include "msm_debugfs.h"
 #include "msm_fence.h"
+#include "msm_gem.h"
 #include "msm_gpu.h"
 #include "msm_kms.h"
 
@@ -880,7 +881,8 @@ static int msm_ioctl_gem_info(struct drm_device *dev, void *data,
 {
 	struct drm_msm_gem_info *args = data;
 	struct drm_gem_object *obj;
-	int ret = 0;
+	struct msm_gem_object *msm_obj;
+	int i, ret = 0;
 
 	if (args->pad)
 		return -EINVAL;
@@ -892,6 +894,9 @@ static int msm_ioctl_gem_info(struct drm_device *dev, void *data,
 		if (args->len)
 			return -EINVAL;
 		break;
+	case MSM_INFO_SET_NAME:
+	case MSM_INFO_GET_NAME:
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -900,6 +905,8 @@ static int msm_ioctl_gem_info(struct drm_device *dev, void *data,
 	if (!obj)
 		return -ENOENT;
 
+	msm_obj = to_msm_bo(obj);
+
 	switch (args->info) {
 	case MSM_INFO_GET_OFFSET:
 		args->value = msm_gem_mmap_offset(obj);
@@ -907,6 +914,33 @@ static int msm_ioctl_gem_info(struct drm_device *dev, void *data,
 	case MSM_INFO_GET_IOVA:
 		ret = msm_ioctl_gem_info_iova(dev, obj, &args->value);
 		break;
+	case MSM_INFO_SET_NAME:
+		/* length check should leave room for terminating null: */
+		if (args->len >= sizeof(msm_obj->name)) {
+			ret = -EINVAL;
+			break;
+		}
+		ret = copy_from_user(msm_obj->name,
+			u64_to_user_ptr(args->value), args->len);
+		msm_obj->name[args->len] = '\0';
+		for (i = 0; i < args->len; i++) {
+			if (!isprint(msm_obj->name[i])) {
+				msm_obj->name[i] = '\0';
+				break;
+			}
+		}
+		break;
+	case MSM_INFO_GET_NAME:
+		if (args->value && (args->len < strlen(msm_obj->name))) {
+			ret = -EINVAL;
+			break;
+		}
+		args->len = strlen(msm_obj->name);
+		if (args->value) {
+			ret = copy_to_user(u64_to_user_ptr(args->value),
+					msm_obj->name, args->len);
+		}
+		break;
 	}
 
 	drm_gem_object_put_unlocked(obj);

commit 789d2e5a772ce312a7a2b81ffaf304946195beb5
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Nov 29 09:54:42 2018 -0500

    drm/msm: rework GEM_INFO ioctl
    
    Prep work to add a way to get/set the GEM objects debug name.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index a73187274b62..fe86c675d5b7 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -882,21 +882,31 @@ static int msm_ioctl_gem_info(struct drm_device *dev, void *data,
 	struct drm_gem_object *obj;
 	int ret = 0;
 
-	if (args->flags & ~MSM_INFO_FLAGS)
+	if (args->pad)
 		return -EINVAL;
 
+	switch (args->info) {
+	case MSM_INFO_GET_OFFSET:
+	case MSM_INFO_GET_IOVA:
+		/* value returned as immediate, not pointer, so len==0: */
+		if (args->len)
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
 	obj = drm_gem_object_lookup(file, args->handle);
 	if (!obj)
 		return -ENOENT;
 
-	if (args->flags & MSM_INFO_IOVA) {
-		uint64_t iova;
-
-		ret = msm_ioctl_gem_info_iova(dev, obj, &iova);
-		if (!ret)
-			args->offset = iova;
-	} else {
-		args->offset = msm_gem_mmap_offset(obj);
+	switch (args->info) {
+	case MSM_INFO_GET_OFFSET:
+		args->value = msm_gem_mmap_offset(obj);
+		break;
+	case MSM_INFO_GET_IOVA:
+		ret = msm_ioctl_gem_info_iova(dev, obj, &args->value);
+		break;
 	}
 
 	drm_gem_object_put_unlocked(obj);

commit 0815d7749a68527adabe2ac40d49f6fc0800eae5
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Wed Nov 7 15:35:52 2018 -0700

    drm/msm: Add a name field for gem objects
    
    For debugging purposes it is useful to assign descriptions
    to buffers so that we know what they are used for. Add
    a field to the buffer object and use that to name the various
    kernel side allocations which ends up looking like like this
    in /d/dri/X/gem:
    
       flags       id ref  offset   kaddr            size     madv      name
       00040000: I  0 ( 1) 00000000 0000000070b79eca 00004096           memptrs
          vmas: [gpu: 01000000,mapped,inuse=1]
       00020000: I  0 ( 1) 00000000 0000000031ed4074 00032768           ring0
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 3f8ed21dfffb..a73187274b62 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -810,7 +810,7 @@ static int msm_ioctl_gem_new(struct drm_device *dev, void *data,
 	}
 
 	return msm_gem_new_handle(dev, file, args->size,
-			args->flags, &args->handle);
+			args->flags, &args->handle, NULL);
 }
 
 static inline ktime_t to_ktime(struct drm_msm_timespec timeout)

commit 9fe041f6fdfedd92e15dd81d96475ff04bdf879e
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Wed Nov 7 15:35:50 2018 -0700

    drm/msm: Add msm_gem_get_and_pin_iova()
    
    Add a new function to get and pin the iova memory in one
    step (basically renaming the old msm_gem_get_iova function)
    and switch msm_gem_get_iova() to only allocate an iova but
    not map it in the IOMMU. This is only currently used by
    msm_ioctl_gem_info() since all other users of of the iova
    expect that the memory be immediately available.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index cf960dc78982..3f8ed21dfffb 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -868,6 +868,10 @@ static int msm_ioctl_gem_info_iova(struct drm_device *dev,
 	if (!priv->gpu)
 		return -EINVAL;
 
+	/*
+	 * Don't pin the memory here - just get an address so that userspace can
+	 * be productive
+	 */
 	return msm_gem_get_iova(obj, priv->gpu->aspace, iova);
 }
 

commit 6a41da17e87dee2936645d9a51fccf932fa42981
Author: Mamta Shukla <mamtashukla555@gmail.com>
Date:   Sat Oct 20 23:19:26 2018 +0530

    drm: msm: Use DRM_DEV_* instead of dev_*
    
    Use DRM_DEV_INFO/ERROR/WARN instead of dev_info/err/debug to generate
    drm-formatted specific log messages so that it will be easy to
    differentiate in case of multiple instances of driver.
    
    Signed-off-by: Mamta Shukla <mamtashukla555@gmail.com>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index aa145d6f6469..cf960dc78982 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -170,7 +170,7 @@ void __iomem *msm_ioremap(struct platform_device *pdev, const char *name,
 		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 
 	if (!res) {
-		dev_err(&pdev->dev, "failed to get memory resource: %s\n", name);
+		DRM_DEV_ERROR(&pdev->dev, "failed to get memory resource: %s\n", name);
 		return ERR_PTR(-EINVAL);
 	}
 
@@ -178,7 +178,7 @@ void __iomem *msm_ioremap(struct platform_device *pdev, const char *name,
 
 	ptr = devm_ioremap_nocache(&pdev->dev, res->start, size);
 	if (!ptr) {
-		dev_err(&pdev->dev, "failed to ioremap: %s\n", name);
+		DRM_DEV_ERROR(&pdev->dev, "failed to ioremap: %s\n", name);
 		return ERR_PTR(-ENOMEM);
 	}
 
@@ -419,12 +419,12 @@ static int msm_init_vram(struct drm_device *dev)
 		p = dma_alloc_attrs(dev->dev, size,
 				&priv->vram.paddr, GFP_KERNEL, attrs);
 		if (!p) {
-			dev_err(dev->dev, "failed to allocate VRAM\n");
+			DRM_DEV_ERROR(dev->dev, "failed to allocate VRAM\n");
 			priv->vram.paddr = 0;
 			return -ENOMEM;
 		}
 
-		dev_info(dev->dev, "VRAM: %08x->%08x\n",
+		DRM_DEV_INFO(dev->dev, "VRAM: %08x->%08x\n",
 				(uint32_t)priv->vram.paddr,
 				(uint32_t)(priv->vram.paddr + size));
 	}
@@ -444,7 +444,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 
 	ddev = drm_dev_alloc(drv, dev);
 	if (IS_ERR(ddev)) {
-		dev_err(dev, "failed to allocate drm_device\n");
+		DRM_DEV_ERROR(dev, "failed to allocate drm_device\n");
 		return PTR_ERR(ddev);
 	}
 
@@ -519,7 +519,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 		 * and (for example) use dmabuf/prime to share buffers with
 		 * imx drm driver on iMX5
 		 */
-		dev_err(dev, "failed to load kms\n");
+		DRM_DEV_ERROR(dev, "failed to load kms\n");
 		ret = PTR_ERR(kms);
 		goto err_msm_uninit;
 	}
@@ -530,7 +530,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	if (kms) {
 		ret = kms->funcs->hw_init(kms);
 		if (ret) {
-			dev_err(dev, "kms hw init failed: %d\n", ret);
+			DRM_DEV_ERROR(dev, "kms hw init failed: %d\n", ret);
 			goto err_msm_uninit;
 		}
 	}
@@ -561,7 +561,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 									ret);
 
 		if (IS_ERR(priv->disp_thread[i].thread)) {
-			dev_err(dev, "failed to create crtc_commit kthread\n");
+			DRM_DEV_ERROR(dev, "failed to create crtc_commit kthread\n");
 			priv->disp_thread[i].thread = NULL;
 		}
 
@@ -573,6 +573,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 			kthread_run(kthread_worker_fn,
 				&priv->event_thread[i].worker,
 				"crtc_event:%d", priv->event_thread[i].crtc_id);
+
 		/**
 		 * event thread should also run at same priority as disp_thread
 		 * because it is handling frame_done events. A lower priority
@@ -613,7 +614,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 
 	ret = drm_vblank_init(ddev, priv->num_crtcs);
 	if (ret < 0) {
-		dev_err(dev, "failed to initialize vblank\n");
+		DRM_DEV_ERROR(dev, "failed to initialize vblank\n");
 		goto err_msm_uninit;
 	}
 
@@ -622,7 +623,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 		ret = drm_irq_install(ddev, kms->irq);
 		pm_runtime_put_sync(dev);
 		if (ret < 0) {
-			dev_err(dev, "failed to install IRQ handler\n");
+			DRM_DEV_ERROR(dev, "failed to install IRQ handler\n");
 			goto err_msm_uninit;
 		}
 	}
@@ -1182,7 +1183,7 @@ static int add_components_mdp(struct device *mdp_dev,
 
 		ret = of_graph_parse_endpoint(ep_node, &ep);
 		if (ret) {
-			dev_err(mdp_dev, "unable to parse port endpoint\n");
+			DRM_DEV_ERROR(mdp_dev, "unable to parse port endpoint\n");
 			of_node_put(ep_node);
 			return ret;
 		}
@@ -1233,13 +1234,13 @@ static int add_display_components(struct device *dev,
 	    of_device_is_compatible(dev->of_node, "qcom,sdm845-mdss")) {
 		ret = of_platform_populate(dev->of_node, NULL, NULL, dev);
 		if (ret) {
-			dev_err(dev, "failed to populate children devices\n");
+			DRM_DEV_ERROR(dev, "failed to populate children devices\n");
 			return ret;
 		}
 
 		mdp_dev = device_find_child(dev, NULL, compare_name_mdp);
 		if (!mdp_dev) {
-			dev_err(dev, "failed to find MDSS MDP node\n");
+			DRM_DEV_ERROR(dev, "failed to find MDSS MDP node\n");
 			of_platform_depopulate(dev);
 			return -ENODEV;
 		}

commit 3750e78c72da3c35292dcf531ebe3062faaa33bc
Author: Bruce Wang <bzwang@chromium.org>
Date:   Fri Oct 5 17:04:01 2018 -0400

    drm/msm: Cut dpu_kms hooks from msm_pm_suspend/resume
    
    Removes the traces of the non-atomic helper calls in
    msm_pm_suspend/resume since we just deleted those functions (see patch
    1). Also removes the drm_kms_helper_poll_disable/enable calls, since
    the DRM_CONNECTOR_POLL_CONNECT flag is never set so periodic polling
    doesn't happen anyways.
    
    v2: reorganized patch order
    v3: made error checks less severe
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Bruce Wang <bzwang@chromium.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 5e758d95751a..aa145d6f6469 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1070,18 +1070,15 @@ static int msm_pm_suspend(struct device *dev)
 {
 	struct drm_device *ddev = dev_get_drvdata(dev);
 	struct msm_drm_private *priv = ddev->dev_private;
-	struct msm_kms *kms = priv->kms;
-
-	/* TODO: Use atomic helper suspend/resume */
-	if (kms && kms->funcs && kms->funcs->pm_suspend)
-		return kms->funcs->pm_suspend(dev);
 
-	drm_kms_helper_poll_disable(ddev);
+	if (WARN_ON(priv->pm_state))
+		drm_atomic_state_put(priv->pm_state);
 
 	priv->pm_state = drm_atomic_helper_suspend(ddev);
 	if (IS_ERR(priv->pm_state)) {
-		drm_kms_helper_poll_enable(ddev);
-		return PTR_ERR(priv->pm_state);
+		int ret = PTR_ERR(priv->pm_state);
+		DRM_ERROR("Failed to suspend dpu, %d\n", ret);
+		return ret;
 	}
 
 	return 0;
@@ -1091,16 +1088,16 @@ static int msm_pm_resume(struct device *dev)
 {
 	struct drm_device *ddev = dev_get_drvdata(dev);
 	struct msm_drm_private *priv = ddev->dev_private;
-	struct msm_kms *kms = priv->kms;
+	int ret;
 
-	/* TODO: Use atomic helper suspend/resume */
-	if (kms && kms->funcs && kms->funcs->pm_resume)
-		return kms->funcs->pm_resume(dev);
+	if (WARN_ON(!priv->pm_state))
+		return -ENOENT;
 
-	drm_atomic_helper_resume(ddev, priv->pm_state);
-	drm_kms_helper_poll_enable(ddev);
+	ret = drm_atomic_helper_resume(ddev, priv->pm_state);
+	if (!ret)
+		priv->pm_state = NULL;
 
-	return 0;
+	return ret;
 }
 #endif
 

commit 7f9743abaa79d3491fee7a0446461b0fdd2aeaa5
Author: Jeykumar Sankaran <jsanka@codeaurora.org>
Date:   Wed Oct 10 14:11:16 2018 -0700

    drm/msm: validate display and event threads
    
    While creating display and event threads per crtc, validate
    them before setting their priorities.
    
    changes in v2:
            - use dev_warn (Abhinav Kumar)
    changes in v3:
            - fix compilation error
    changes in v4:
            - Remove Change-Id (Sean Paul)
            - Keep logging within 80 char limit (Sean Paul)
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Jeykumar Sankaran <jsanka@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 4904d0d41409..dcff812c63d0 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -553,17 +553,18 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 			kthread_run(kthread_worker_fn,
 				&priv->disp_thread[i].worker,
 				"crtc_commit:%d", priv->disp_thread[i].crtc_id);
-		ret = sched_setscheduler(priv->disp_thread[i].thread,
-							SCHED_FIFO, &param);
-		if (ret)
-			pr_warn("display thread priority update failed: %d\n",
-									ret);
-
 		if (IS_ERR(priv->disp_thread[i].thread)) {
 			dev_err(dev, "failed to create crtc_commit kthread\n");
 			priv->disp_thread[i].thread = NULL;
+			goto err_msm_uninit;
 		}
 
+		ret = sched_setscheduler(priv->disp_thread[i].thread,
+					 SCHED_FIFO, &param);
+		if (ret)
+			dev_warn(dev, "disp_thread set priority failed: %d\n",
+				 ret);
+
 		/* initialize event thread */
 		priv->event_thread[i].crtc_id = priv->crtcs[i]->base.id;
 		kthread_init_worker(&priv->event_thread[i].worker);
@@ -572,6 +573,12 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 			kthread_run(kthread_worker_fn,
 				&priv->event_thread[i].worker,
 				"crtc_event:%d", priv->event_thread[i].crtc_id);
+		if (IS_ERR(priv->event_thread[i].thread)) {
+			dev_err(dev, "failed to create crtc_event kthread\n");
+			priv->event_thread[i].thread = NULL;
+			goto err_msm_uninit;
+		}
+
 		/**
 		 * event thread should also run at same priority as disp_thread
 		 * because it is handling frame_done events. A lower priority
@@ -580,34 +587,10 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 		 * failure at crtc commit level.
 		 */
 		ret = sched_setscheduler(priv->event_thread[i].thread,
-							SCHED_FIFO, &param);
+					 SCHED_FIFO, &param);
 		if (ret)
-			pr_warn("display event thread priority update failed: %d\n",
-									ret);
-
-		if (IS_ERR(priv->event_thread[i].thread)) {
-			dev_err(dev, "failed to create crtc_event kthread\n");
-			priv->event_thread[i].thread = NULL;
-		}
-
-		if ((!priv->disp_thread[i].thread) ||
-				!priv->event_thread[i].thread) {
-			/* clean up previously created threads if any */
-			for ( ; i >= 0; i--) {
-				if (priv->disp_thread[i].thread) {
-					kthread_stop(
-						priv->disp_thread[i].thread);
-					priv->disp_thread[i].thread = NULL;
-				}
-
-				if (priv->event_thread[i].thread) {
-					kthread_stop(
-						priv->event_thread[i].thread);
-					priv->event_thread[i].thread = NULL;
-				}
-			}
-			goto err_msm_uninit;
-		}
+			dev_warn(dev, "event_thread set priority failed:%d\n",
+				 ret);
 	}
 
 	ret = drm_vblank_init(ddev, priv->num_crtcs);

commit 6542e9adc0da1e23d81ff9314265a029b961906d
Merge: 2b02a05bdc3a f2bfc71aee75
Author: Sean Paul <seanpaul@chromium.org>
Date:   Wed Oct 24 14:26:04 2018 -0400

    Merge drm/drm-next into drm-misc-next
    
    4.19 is out, Lyude asked for a backmerge, and it's been a while. All
    very good reasons on their own :-)
    
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

commit 3ea4b1e1b814384a59f2adf0e24fb108084ddab6
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Oct 4 22:24:36 2018 +0200

    drm/msm: Use drm_atomic_helper_shutdown
    
    drm_plane_helper_disable is a non-atomic drivers only function, and
    will blow up (since no one passes the locking context it needs).
    
    Atomic drivers which want to quiescent their hw on unload should
    use drm_atomic_helper_shutdown() instead.
    
    Reviewed-by: Ville Syrj√§l√§ <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Rajesh Yadav <ryadav@codeaurora.org>
    Cc: Chandan Uddaraju <chandanu@codeaurora.org>
    Cc: Archit Taneja <architt@codeaurora.org>
    Cc: Jeykumar Sankaran <jsanka@codeaurora.org>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Sinclair Yeh <syeh@vmware.com>
    Cc: "Ville Syrj√§l√§" <ville.syrjala@linux.intel.com>
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Cc: Gustavo Padovan <gustavo.padovan@collabora.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20181004202446.22905-12-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index c1abad8a8612..69dbdba183fe 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -312,6 +312,7 @@ static int msm_drm_uninit(struct device *dev)
 	if (fbdev && priv->fbdev)
 		msm_fbdev_free(ddev);
 #endif
+	drm_atomic_helper_shutdown(ddev);
 	drm_mode_config_cleanup(ddev);
 
 	pm_runtime_get_sync(dev);

commit 4d8dc2dfae2c486b54bb082918a398a22b97cf85
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Wed Sep 26 13:48:59 2018 +0200

    drm/msm: Replace drm_dev_unref with drm_dev_put
    
    This patch unifies the naming of DRM functions for reference counting
    of struct drm_device. The resulting code is more aligned with the rest
    of the Linux kernel interfaces.
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index c1abad8a8612..4904d0d41409 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -337,7 +337,7 @@ static int msm_drm_uninit(struct device *dev)
 		mdss->funcs->destroy(ddev);
 
 	ddev->dev_private = NULL;
-	drm_dev_unref(ddev);
+	drm_dev_put(ddev);
 
 	kfree(priv);
 
@@ -452,7 +452,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv) {
 		ret = -ENOMEM;
-		goto err_unref_drm_dev;
+		goto err_put_drm_dev;
 	}
 
 	ddev->dev_private = priv;
@@ -653,8 +653,8 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 		mdss->funcs->destroy(ddev);
 err_free_priv:
 	kfree(priv);
-err_unref_drm_dev:
-	drm_dev_unref(ddev);
+err_put_drm_dev:
+	drm_dev_put(ddev);
 	return ret;
 }
 

commit 8e54eea503caec53d39e67407ffa785690f38ba4
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Mon Aug 6 11:33:21 2018 -0600

    drm/msm: Add a helper function to parse clock names
    
    Add a helper function to parse the clock names and set up
    the bulk data so we can take advantage of the bulk clock
    functions instead of rolling our own. This is added
    as a helper function so the upcoming a6xx GMU code can
    also take advantage of it.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 46876bc8b707..c1abad8a8612 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -81,6 +81,63 @@ module_param(modeset, bool, 0600);
  * Util/helpers:
  */
 
+int msm_clk_bulk_get(struct device *dev, struct clk_bulk_data **bulk)
+{
+	struct property *prop;
+	const char *name;
+	struct clk_bulk_data *local;
+	int i = 0, ret, count;
+
+	count = of_property_count_strings(dev->of_node, "clock-names");
+	if (count < 1)
+		return 0;
+
+	local = devm_kcalloc(dev, sizeof(struct clk_bulk_data *),
+		count, GFP_KERNEL);
+	if (!local)
+		return -ENOMEM;
+
+	of_property_for_each_string(dev->of_node, "clock-names", prop, name) {
+		local[i].id = devm_kstrdup(dev, name, GFP_KERNEL);
+		if (!local[i].id) {
+			devm_kfree(dev, local);
+			return -ENOMEM;
+		}
+
+		i++;
+	}
+
+	ret = devm_clk_bulk_get(dev, count, local);
+
+	if (ret) {
+		for (i = 0; i < count; i++)
+			devm_kfree(dev, (void *) local[i].id);
+		devm_kfree(dev, local);
+
+		return ret;
+	}
+
+	*bulk = local;
+	return count;
+}
+
+struct clk *msm_clk_bulk_get_clock(struct clk_bulk_data *bulk, int count,
+		const char *name)
+{
+	int i;
+	char n[32];
+
+	snprintf(n, sizeof(n), "%s_clk", name);
+
+	for (i = 0; bulk && i < count; i++) {
+		if (!strcmp(bulk[i].id, name) || !strcmp(bulk[i].id, n))
+			return bulk[i].clk;
+	}
+
+
+	return NULL;
+}
+
 struct clk *msm_clk_get(struct platform_device *pdev, const char *name)
 {
 	struct clk *clk;

commit 25fdd5933e4c0f5fe2ea5cd59994f8ac5fbe90ef
Author: Jeykumar Sankaran <jsanka@codeaurora.org>
Date:   Wed Jun 27 15:26:09 2018 -0400

    drm/msm: Add SDM845 DPU support
    
    SDM845 SoC includes the Mobile Display Sub System (MDSS) which is a
    top level wrapper consisting of Display Processing Unit (DPU) and
    display peripheral modules such as Display Serial Interface (DSI)
    and DisplayPort (DP).
    
    MDSS functions essentially as a back-end composition engine. It blends
    video and graphic images stored in the frame buffers and scans out the
    composed image to a display sink (over DSI/DP).
    
    The following diagram represents hardware blocks for a simple pipeline
    (two planes are present on a given crtc which is connected to a DSI
    connector):
    
           MDSS
          +---------------------------------+
          | +-----------------------------+ |
          | | DPU                         | |
          | |  +--------+  +--------+     | |
          | |  |  SSPP  |  |  SSPP  |     | |
          | |  +----+---+  +----+---+     | |
          | |       |           |         | |
          | |  +----v-----------v---+     | |
          | |  |  Layer Mixer (LM)  |     | |
          | |  +--------------------+     | |
          | |  +--------------------+     | |
          | |  |    PingPong (PP)   |     | |
          | |  +--------------------+     | |
          | |  +--------------------+     | |
          | |  |  INTERFACE (VIDEO) |     | |
          | |  +---+----------------+     | |
          | +------|----------------------+ |
          |        |                        |
          | +------|---------------------+  |
          | |      | DISPLAY PERIPHERALS |  |
          | |  +---v-+      +-----+      |  |
          | |  | DSI |      |  DP |      |  |
          | |  +-----+      +-----+      |  |
          | +----------------------------+  |
          +---------------------------------+
    
    The number of DPU sub-blocks (i.e. SSPPs, LMs, PP blocks and INTFs)
    depends on SoC capabilities.
    
    Overview of DPU sub-blocks:
    ---------------------------
    * Source Surface Processor (SSPP):
     Refers to any of hardware pipes like ViG, DMA etc. Only ViG pipes are
     capable of performing format conversion, scaling and quality improvement
     for source surfaces.
    
    * Layer Mixer (LM):
     Blend source surfaces together (in requested zorder)
    
    * PingPong (PP):
     This block controls frame done interrupt output, EOL and EOF generation,
     overflow/underflow control.
    
    * Display interface (INTF):
     Timing generator and interface connecting the display peripherals.
    
    DRM components mapping to DPU architecture:
    ------------------------------------------
    PLANEs maps to SSPPs
    CRTC maps to LMs
    Encoder maps to PPs, INTFs
    
    Data flow setup:
    ---------------
    MDSS hardware can support various data flows (e.g.):
      - Dual pipe: Output from two LMs combined to single display.
      - Split display: Output from two LMs connected to two separate
                       interfaces.
    
    The hardware capabilities determine the number of concurrent data paths
    possible. Any control path (i.e. pipeline w/i DPU) can be routed to any
    of the hardware data paths. A given control path can be triggered,
    flushed and controlled independently.
    
    Changes in v3:
    - Move msm_media_info.h from uapi to dpu/ subdir
    - Remove preclose callback dpu (it's handled in core)
    - Fix kbuild warnings with parent_ops
    - Remove unused functions from dpu_core_irq
    - Rename mdss_phys to mdss
    - Rename mdp_phys address space to mdp
    - Drop _phys from vbif and regdma binding names
    
    Signed-off-by: Abhinav Kumar <abhinavk@codeaurora.org>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Chandan Uddaraju <chandanu@codeaurora.org>
    Signed-off-by: Jeykumar Sankaran <jsanka@codeaurora.org>
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rajesh Yadav <ryadav@codeaurora.org>
    Signed-off-by: Sravanthi Kollukuduru <skolluku@codeaurora.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    [robclark minor rebase]
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index e79ad74ca98c..46876bc8b707 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1,4 +1,5 @@
 /*
+ * Copyright (c) 2016-2018, The Linux Foundation. All rights reserved.
  * Copyright (C) 2013 Red Hat
  * Author: Rob Clark <robdclark@gmail.com>
  *
@@ -15,6 +16,8 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <linux/kthread.h>
+#include <uapi/linux/sched/types.h>
 #include <drm/drm_of.h>
 
 #include "msm_drv.h"
@@ -149,7 +152,7 @@ struct vblank_event {
 	bool enable;
 };
 
-static void vblank_ctrl_worker(struct work_struct *work)
+static void vblank_ctrl_worker(struct kthread_work *work)
 {
 	struct msm_vblank_ctrl *vbl_ctrl = container_of(work,
 						struct msm_vblank_ctrl, work);
@@ -197,7 +200,8 @@ static int vblank_ctrl_queue_work(struct msm_drm_private *priv,
 	list_add_tail(&vbl_ev->node, &vbl_ctrl->event_list);
 	spin_unlock_irqrestore(&vbl_ctrl->lock, flags);
 
-	queue_work(priv->wq, &vbl_ctrl->work);
+	kthread_queue_work(&priv->disp_thread[crtc_id].worker,
+			&vbl_ctrl->work);
 
 	return 0;
 }
@@ -211,17 +215,33 @@ static int msm_drm_uninit(struct device *dev)
 	struct msm_mdss *mdss = priv->mdss;
 	struct msm_vblank_ctrl *vbl_ctrl = &priv->vblank_ctrl;
 	struct vblank_event *vbl_ev, *tmp;
+	int i;
 
 	/* We must cancel and cleanup any pending vblank enable/disable
 	 * work before drm_irq_uninstall() to avoid work re-enabling an
 	 * irq after uninstall has disabled it.
 	 */
-	cancel_work_sync(&vbl_ctrl->work);
+	kthread_flush_work(&vbl_ctrl->work);
 	list_for_each_entry_safe(vbl_ev, tmp, &vbl_ctrl->event_list, node) {
 		list_del(&vbl_ev->node);
 		kfree(vbl_ev);
 	}
 
+	/* clean up display commit/event worker threads */
+	for (i = 0; i < priv->num_crtcs; i++) {
+		if (priv->disp_thread[i].thread) {
+			kthread_flush_worker(&priv->disp_thread[i].worker);
+			kthread_stop(priv->disp_thread[i].thread);
+			priv->disp_thread[i].thread = NULL;
+		}
+
+		if (priv->event_thread[i].thread) {
+			kthread_flush_worker(&priv->event_thread[i].worker);
+			kthread_stop(priv->event_thread[i].thread);
+			priv->event_thread[i].thread = NULL;
+		}
+	}
+
 	msm_gem_shrinker_cleanup(ddev);
 
 	drm_kms_helper_poll_fini(ddev);
@@ -269,6 +289,7 @@ static int msm_drm_uninit(struct device *dev)
 
 #define KMS_MDP4 4
 #define KMS_MDP5 5
+#define KMS_DPU  3
 
 static int get_mdp_ver(struct platform_device *pdev)
 {
@@ -360,7 +381,8 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	struct msm_drm_private *priv;
 	struct msm_kms *kms;
 	struct msm_mdss *mdss;
-	int ret;
+	int ret, i;
+	struct sched_param param;
 
 	ddev = drm_dev_alloc(drv, dev);
 	if (IS_ERR(ddev)) {
@@ -379,7 +401,17 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	ddev->dev_private = priv;
 	priv->dev = ddev;
 
-	ret = mdp5_mdss_init(ddev);
+	switch (get_mdp_ver(pdev)) {
+	case KMS_MDP5:
+		ret = mdp5_mdss_init(ddev);
+		break;
+	case KMS_DPU:
+		ret = dpu_mdss_init(ddev);
+		break;
+	default:
+		ret = 0;
+		break;
+	}
 	if (ret)
 		goto err_free_priv;
 
@@ -389,7 +421,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 
 	INIT_LIST_HEAD(&priv->inactive_list);
 	INIT_LIST_HEAD(&priv->vblank_ctrl.event_list);
-	INIT_WORK(&priv->vblank_ctrl.work, vblank_ctrl_worker);
+	kthread_init_work(&priv->vblank_ctrl.work, vblank_ctrl_worker);
 	spin_lock_init(&priv->vblank_ctrl.lock);
 
 	drm_mode_config_init(ddev);
@@ -413,6 +445,10 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	case KMS_MDP5:
 		kms = mdp5_kms_init(ddev);
 		break;
+	case KMS_DPU:
+		kms = dpu_kms_init(ddev);
+		priv->kms = kms;
+		break;
 	default:
 		kms = ERR_PTR(-ENODEV);
 		break;
@@ -444,6 +480,79 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	ddev->mode_config.funcs = &mode_config_funcs;
 	ddev->mode_config.helper_private = &mode_config_helper_funcs;
 
+	/**
+	 * this priority was found during empiric testing to have appropriate
+	 * realtime scheduling to process display updates and interact with
+	 * other real time and normal priority task
+	 */
+	param.sched_priority = 16;
+	for (i = 0; i < priv->num_crtcs; i++) {
+
+		/* initialize display thread */
+		priv->disp_thread[i].crtc_id = priv->crtcs[i]->base.id;
+		kthread_init_worker(&priv->disp_thread[i].worker);
+		priv->disp_thread[i].dev = ddev;
+		priv->disp_thread[i].thread =
+			kthread_run(kthread_worker_fn,
+				&priv->disp_thread[i].worker,
+				"crtc_commit:%d", priv->disp_thread[i].crtc_id);
+		ret = sched_setscheduler(priv->disp_thread[i].thread,
+							SCHED_FIFO, &param);
+		if (ret)
+			pr_warn("display thread priority update failed: %d\n",
+									ret);
+
+		if (IS_ERR(priv->disp_thread[i].thread)) {
+			dev_err(dev, "failed to create crtc_commit kthread\n");
+			priv->disp_thread[i].thread = NULL;
+		}
+
+		/* initialize event thread */
+		priv->event_thread[i].crtc_id = priv->crtcs[i]->base.id;
+		kthread_init_worker(&priv->event_thread[i].worker);
+		priv->event_thread[i].dev = ddev;
+		priv->event_thread[i].thread =
+			kthread_run(kthread_worker_fn,
+				&priv->event_thread[i].worker,
+				"crtc_event:%d", priv->event_thread[i].crtc_id);
+		/**
+		 * event thread should also run at same priority as disp_thread
+		 * because it is handling frame_done events. A lower priority
+		 * event thread and higher priority disp_thread can causes
+		 * frame_pending counters beyond 2. This can lead to commit
+		 * failure at crtc commit level.
+		 */
+		ret = sched_setscheduler(priv->event_thread[i].thread,
+							SCHED_FIFO, &param);
+		if (ret)
+			pr_warn("display event thread priority update failed: %d\n",
+									ret);
+
+		if (IS_ERR(priv->event_thread[i].thread)) {
+			dev_err(dev, "failed to create crtc_event kthread\n");
+			priv->event_thread[i].thread = NULL;
+		}
+
+		if ((!priv->disp_thread[i].thread) ||
+				!priv->event_thread[i].thread) {
+			/* clean up previously created threads if any */
+			for ( ; i >= 0; i--) {
+				if (priv->disp_thread[i].thread) {
+					kthread_stop(
+						priv->disp_thread[i].thread);
+					priv->disp_thread[i].thread = NULL;
+				}
+
+				if (priv->event_thread[i].thread) {
+					kthread_stop(
+						priv->event_thread[i].thread);
+					priv->event_thread[i].thread = NULL;
+				}
+			}
+			goto err_msm_uninit;
+		}
+	}
+
 	ret = drm_vblank_init(ddev, priv->num_crtcs);
 	if (ret < 0) {
 		dev_err(dev, "failed to initialize vblank\n");
@@ -1060,12 +1169,13 @@ static int add_display_components(struct device *dev,
 	int ret;
 
 	/*
-	 * MDP5 based devices don't have a flat hierarchy. There is a top level
-	 * parent: MDSS, and children: MDP5, DSI, HDMI, eDP etc. Populate the
-	 * children devices, find the MDP5 node, and then add the interfaces
-	 * to our components list.
+	 * MDP5/DPU based devices don't have a flat hierarchy. There is a top
+	 * level parent: MDSS, and children: MDP5/DPU, DSI, HDMI, eDP etc.
+	 * Populate the children devices, find the MDP5/DPU node, and then add
+	 * the interfaces to our components list.
 	 */
-	if (of_device_is_compatible(dev->of_node, "qcom,mdss")) {
+	if (of_device_is_compatible(dev->of_node, "qcom,mdss") ||
+	    of_device_is_compatible(dev->of_node, "qcom,sdm845-mdss")) {
 		ret = of_platform_populate(dev->of_node, NULL, NULL, dev);
 		if (ret) {
 			dev_err(dev, "failed to populate children devices\n");
@@ -1177,6 +1287,7 @@ static int msm_pdev_remove(struct platform_device *pdev)
 static const struct of_device_id dt_match[] = {
 	{ .compatible = "qcom,mdp4", .data = (void *)KMS_MDP4 },
 	{ .compatible = "qcom,mdss", .data = (void *)KMS_MDP5 },
+	{ .compatible = "qcom,sdm845-mdss", .data = (void *)KMS_DPU },
 	{}
 };
 MODULE_DEVICE_TABLE(of, dt_match);
@@ -1198,6 +1309,7 @@ static int __init msm_drm_register(void)
 
 	DBG("init");
 	msm_mdp_register();
+	msm_dpu_register();
 	msm_dsi_register();
 	msm_edp_register();
 	msm_hdmi_register();
@@ -1214,6 +1326,7 @@ static void __exit msm_drm_unregister(void)
 	msm_edp_unregister();
 	msm_dsi_unregister();
 	msm_mdp_unregister();
+	msm_dpu_unregister();
 }
 
 module_init(msm_drm_register);

commit 036bfeb33b89578ab924fa198213260659e08dc8
Author: Jeykumar Sankaran <jsanka@codeaurora.org>
Date:   Wed Jun 27 15:24:17 2018 -0400

    drm/msm: Add pm_suspend/resume callbacks to msm_kms
    
    Used by the dpu driver for custom suspend/resume.
    
    Changes in v3:
    - None
    
    Signed-off-by: Jeykumar Sankaran <jsanka@codeaurora.org>
    [seanpaul split this out of the megapatch]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 8bd9fe831968..e79ad74ca98c 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -903,6 +903,11 @@ static int msm_pm_suspend(struct device *dev)
 {
 	struct drm_device *ddev = dev_get_drvdata(dev);
 	struct msm_drm_private *priv = ddev->dev_private;
+	struct msm_kms *kms = priv->kms;
+
+	/* TODO: Use atomic helper suspend/resume */
+	if (kms && kms->funcs && kms->funcs->pm_suspend)
+		return kms->funcs->pm_suspend(dev);
 
 	drm_kms_helper_poll_disable(ddev);
 
@@ -919,6 +924,11 @@ static int msm_pm_resume(struct device *dev)
 {
 	struct drm_device *ddev = dev_get_drvdata(dev);
 	struct msm_drm_private *priv = ddev->dev_private;
+	struct msm_kms *kms = priv->kms;
+
+	/* TODO: Use atomic helper suspend/resume */
+	if (kms && kms->funcs && kms->funcs->pm_resume)
+		return kms->funcs->pm_resume(dev);
 
 	drm_atomic_helper_resume(ddev, priv->pm_state);
 	drm_kms_helper_poll_enable(ddev);

commit 77050c3febb1808ed6a0f7e9f0994278f06967ca
Author: Jeykumar Sankaran <jsanka@codeaurora.org>
Date:   Wed Jun 27 14:35:28 2018 -0400

    drm/msm: Use labels for unwinding in the error path
    
    This simplifies cleanup, to make sure nothing drops out in case of
    error.
    
    Changes in v3:
    - None
    
    Signed-off-by: Jeykumar Sankaran <jsanka@codeaurora.org>
    [seanpaul split out of dpu megapatch and renamed labels]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 67816543a0d7..8bd9fe831968 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -372,19 +372,16 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv) {
-		drm_dev_unref(ddev);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto err_unref_drm_dev;
 	}
 
 	ddev->dev_private = priv;
 	priv->dev = ddev;
 
 	ret = mdp5_mdss_init(ddev);
-	if (ret) {
-		kfree(priv);
-		drm_dev_unref(ddev);
-		return ret;
-	}
+	if (ret)
+		goto err_free_priv;
 
 	mdss = priv->mdss;
 
@@ -399,17 +396,12 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 
 	/* Bind all our sub-components: */
 	ret = component_bind_all(dev, ddev);
-	if (ret) {
-		if (mdss && mdss->funcs)
-			mdss->funcs->destroy(ddev);
-		kfree(priv);
-		drm_dev_unref(ddev);
-		return ret;
-	}
+	if (ret)
+		goto err_destroy_mdss;
 
 	ret = msm_init_vram(ddev);
 	if (ret)
-		goto fail;
+		goto err_msm_uninit;
 
 	msm_gem_shrinker_init(ddev);
 
@@ -435,7 +427,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 		 */
 		dev_err(dev, "failed to load kms\n");
 		ret = PTR_ERR(kms);
-		goto fail;
+		goto err_msm_uninit;
 	}
 
 	/* Enable normalization of plane zpos */
@@ -445,7 +437,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 		ret = kms->funcs->hw_init(kms);
 		if (ret) {
 			dev_err(dev, "kms hw init failed: %d\n", ret);
-			goto fail;
+			goto err_msm_uninit;
 		}
 	}
 
@@ -455,7 +447,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	ret = drm_vblank_init(ddev, priv->num_crtcs);
 	if (ret < 0) {
 		dev_err(dev, "failed to initialize vblank\n");
-		goto fail;
+		goto err_msm_uninit;
 	}
 
 	if (kms) {
@@ -464,13 +456,13 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 		pm_runtime_put_sync(dev);
 		if (ret < 0) {
 			dev_err(dev, "failed to install IRQ handler\n");
-			goto fail;
+			goto err_msm_uninit;
 		}
 	}
 
 	ret = drm_dev_register(ddev, 0);
 	if (ret)
-		goto fail;
+		goto err_msm_uninit;
 
 	drm_mode_config_reset(ddev);
 
@@ -481,15 +473,23 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 
 	ret = msm_debugfs_late_init(ddev);
 	if (ret)
-		goto fail;
+		goto err_msm_uninit;
 
 	drm_kms_helper_poll_init(ddev);
 
 	return 0;
 
-fail:
+err_msm_uninit:
 	msm_drm_uninit(dev);
 	return ret;
+err_destroy_mdss:
+	if (mdss && mdss->funcs)
+		mdss->funcs->destroy(ddev);
+err_free_priv:
+	kfree(priv);
+err_unref_drm_dev:
+	drm_dev_unref(ddev);
+	return ret;
 }
 
 /*

commit aaded2e3a1f6b776a5afd7c1168610d51f9a6a15
Author: Jeykumar Sankaran <jsanka@codeaurora.org>
Date:   Wed Jun 27 14:26:24 2018 -0400

    drm/msm: #define MDP version numbers
    
    Useful for incoming DPU support
    
    Changes in v3:
    - None
    
    Signed-off-by: Jeykumar Sankaran <jsanka@codeaurora.org>
    [seanpaul split this from the dpu megapatch]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index b73acdd52931..67816543a0d7 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -267,6 +267,9 @@ static int msm_drm_uninit(struct device *dev)
 	return 0;
 }
 
+#define KMS_MDP4 4
+#define KMS_MDP5 5
+
 static int get_mdp_ver(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -411,11 +414,11 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	msm_gem_shrinker_init(ddev);
 
 	switch (get_mdp_ver(pdev)) {
-	case 4:
+	case KMS_MDP4:
 		kms = mdp4_kms_init(ddev);
 		priv->kms = kms;
 		break;
-	case 5:
+	case KMS_MDP5:
 		kms = mdp5_kms_init(ddev);
 		break;
 	default:
@@ -1162,8 +1165,8 @@ static int msm_pdev_remove(struct platform_device *pdev)
 }
 
 static const struct of_device_id dt_match[] = {
-	{ .compatible = "qcom,mdp4", .data = (void *)4 },	/* MDP4 */
-	{ .compatible = "qcom,mdss", .data = (void *)5 },	/* MDP5 MDSS */
+	{ .compatible = "qcom,mdp4", .data = (void *)KMS_MDP4 },
+	{ .compatible = "qcom,mdss", .data = (void *)KMS_MDP5 },
 	{}
 };
 MODULE_DEVICE_TABLE(of, dt_match);

commit 74312fc7343efbfd95fc5e75c5c7547e9f751c22
Author: Sean Paul <seanpaul@chromium.org>
Date:   Wed Jun 27 15:15:49 2018 -0400

    drm/msm: Clean up dangling atomic_wq
    
    I missed this during the atomic conversion
    
    Changes in v3:
    - None
    
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 9c760cee5156..b73acdd52931 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -244,9 +244,6 @@ static int msm_drm_uninit(struct device *dev)
 	flush_workqueue(priv->wq);
 	destroy_workqueue(priv->wq);
 
-	flush_workqueue(priv->atomic_wq);
-	destroy_workqueue(priv->atomic_wq);
-
 	if (kms && kms->funcs)
 		kms->funcs->destroy(kms);
 
@@ -389,7 +386,6 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	mdss = priv->mdss;
 
 	priv->wq = alloc_ordered_workqueue("msm", 0);
-	priv->atomic_wq = alloc_ordered_workqueue("msm:atomic", 0);
 
 	INIT_LIST_HEAD(&priv->inactive_list);
 	INIT_LIST_HEAD(&priv->vblank_ctrl.event_list);

commit bb676df12b5e81cab57d1a212a6e9cfc343875a7
Author: Jeykumar Sankaran <jsanka@codeaurora.org>
Date:   Mon Jun 11 14:13:20 2018 -0700

    drm/msm: enable zpos normalization
    
    Enable drm core zpos normalization for planes.
    
    Changes in v3:
    - None
    
    Signed-off-by: Jeykumar Sankaran <jsanka@codeaurora.org>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 2608d3f77956..9c760cee5156 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -439,6 +439,9 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 		goto fail;
 	}
 
+	/* Enable normalization of plane zpos */
+	ddev->mode_config.normalize_zpos = true;
+
 	if (kms) {
 		ret = kms->funcs->hw_init(kms);
 		if (ret) {

commit bc3220be22577e199452edbb6a24a980a4ab5c73
Author: Rajesh Yadav <ryadav@codeaurora.org>
Date:   Thu Jun 21 16:06:10 2018 -0400

    drm/msm/mdp5: subclass msm_mdss for mdp5
    
    SoCs having mdp5 or dpu have identical tree like
    device hierarchy where MDSS top level wrapper manages
    common power resources for all child devices.
    
    Subclass msm_mdss so that msm_mdss includes common defines
    and mdp5/dpu mdss derivations to include any extensions.
    
    Add mdss helper interface (msm_mdss_funcs) to msm_mdss
    base for mdp5/dpu mdss specific implementation calls.
    
    This change subclasses msm_mdss for mdp5, dpu specific
    changes will be done separately.
    
    Changes in v3:
    - Added Archit's R-b
    
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rajesh Yadav <ryadav@codeaurora.org>
    [seanpaul rebased on msm-next and resolved conflicts]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 7f7321eb5312..2608d3f77956 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -208,6 +208,7 @@ static int msm_drm_uninit(struct device *dev)
 	struct drm_device *ddev = platform_get_drvdata(pdev);
 	struct msm_drm_private *priv = ddev->dev_private;
 	struct msm_kms *kms = priv->kms;
+	struct msm_mdss *mdss = priv->mdss;
 	struct msm_vblank_ctrl *vbl_ctrl = &priv->vblank_ctrl;
 	struct vblank_event *vbl_ev, *tmp;
 
@@ -258,7 +259,8 @@ static int msm_drm_uninit(struct device *dev)
 
 	component_unbind_all(dev, ddev);
 
-	msm_mdss_destroy(ddev);
+	if (mdss && mdss->funcs)
+		mdss->funcs->destroy(ddev);
 
 	ddev->dev_private = NULL;
 	drm_dev_unref(ddev);
@@ -357,6 +359,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	struct drm_device *ddev;
 	struct msm_drm_private *priv;
 	struct msm_kms *kms;
+	struct msm_mdss *mdss;
 	int ret;
 
 	ddev = drm_dev_alloc(drv, dev);
@@ -376,13 +379,15 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	ddev->dev_private = priv;
 	priv->dev = ddev;
 
-	ret = msm_mdss_init(ddev);
+	ret = mdp5_mdss_init(ddev);
 	if (ret) {
 		kfree(priv);
 		drm_dev_unref(ddev);
 		return ret;
 	}
 
+	mdss = priv->mdss;
+
 	priv->wq = alloc_ordered_workqueue("msm", 0);
 	priv->atomic_wq = alloc_ordered_workqueue("msm:atomic", 0);
 
@@ -396,7 +401,8 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	/* Bind all our sub-components: */
 	ret = component_bind_all(dev, ddev);
 	if (ret) {
-		msm_mdss_destroy(ddev);
+		if (mdss && mdss->funcs)
+			mdss->funcs->destroy(ddev);
 		kfree(priv);
 		drm_dev_unref(ddev);
 		return ret;
@@ -924,11 +930,12 @@ static int msm_runtime_suspend(struct device *dev)
 {
 	struct drm_device *ddev = dev_get_drvdata(dev);
 	struct msm_drm_private *priv = ddev->dev_private;
+	struct msm_mdss *mdss = priv->mdss;
 
 	DBG("");
 
-	if (priv->mdss)
-		return msm_mdss_disable(priv->mdss);
+	if (mdss && mdss->funcs)
+		return mdss->funcs->disable(mdss);
 
 	return 0;
 }
@@ -937,11 +944,12 @@ static int msm_runtime_resume(struct device *dev)
 {
 	struct drm_device *ddev = dev_get_drvdata(dev);
 	struct msm_drm_private *priv = ddev->dev_private;
+	struct msm_mdss *mdss = priv->mdss;
 
 	DBG("");
 
-	if (priv->mdss)
-		return msm_mdss_enable(priv->mdss);
+	if (mdss && mdss->funcs)
+		return mdss->funcs->enable(mdss);
 
 	return 0;
 }

commit ec446d09366cea199214b30810e368c5178841cd
Author: Daniel Mack <daniel@zonque.org>
Date:   Mon May 28 21:53:38 2018 +0200

    drm/msm: call drm_atomic_helper_suspend() and drm_atomic_helper_resume()
    
    To make suspend and resume work on msm8916 platforms, call into the generic
    helpers and preserve the state across suspends.
    
    Signed-off-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 021a0b6f9a59..7f7321eb5312 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -894,16 +894,25 @@ static struct drm_driver msm_driver = {
 static int msm_pm_suspend(struct device *dev)
 {
 	struct drm_device *ddev = dev_get_drvdata(dev);
+	struct msm_drm_private *priv = ddev->dev_private;
 
 	drm_kms_helper_poll_disable(ddev);
 
+	priv->pm_state = drm_atomic_helper_suspend(ddev);
+	if (IS_ERR(priv->pm_state)) {
+		drm_kms_helper_poll_enable(ddev);
+		return PTR_ERR(priv->pm_state);
+	}
+
 	return 0;
 }
 
 static int msm_pm_resume(struct device *dev)
 {
 	struct drm_device *ddev = dev_get_drvdata(dev);
+	struct msm_drm_private *priv = ddev->dev_private;
 
+	drm_atomic_helper_resume(ddev, priv->pm_state);
 	drm_kms_helper_poll_enable(ddev);
 
 	return 0;

commit d14659f5de7d2822764d6944ce7d8d7570ebfd9b
Author: Sean Paul <seanpaul@chromium.org>
Date:   Wed Feb 28 14:19:05 2018 -0500

    drm/msm: Switch to atomic_helper_commit()
    
    Now that all of the msm-specific goo is tucked safely away we can switch
    over to using the atomic helper commit directly. \o/
    
    Changes in v2:
    - None
    Changes in v3:
    - Rebased on Archit's private_obj set
    Changes in v4:
    - None
    
    Cc: Abhinav Kumar <abhinavk@codeaurora.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 9cec74c79aa2..021a0b6f9a59 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -41,7 +41,11 @@ static const struct drm_mode_config_funcs mode_config_funcs = {
 	.fb_create = msm_framebuffer_create,
 	.output_poll_changed = drm_fb_helper_output_poll_changed,
 	.atomic_check = drm_atomic_helper_check,
-	.atomic_commit = msm_atomic_commit,
+	.atomic_commit = drm_atomic_helper_commit,
+};
+
+static const struct drm_mode_config_helper_funcs mode_config_helper_funcs = {
+	.atomic_commit_tail = msm_atomic_commit_tail,
 };
 
 #ifdef CONFIG_DRM_MSM_REGISTER_LOGGING
@@ -438,6 +442,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	}
 
 	ddev->mode_config.funcs = &mode_config_funcs;
+	ddev->mode_config.helper_private = &mode_config_helper_funcs;
 
 	ret = drm_vblank_init(ddev, priv->num_crtcs);
 	if (ret < 0) {

commit 70db18dca4e0130acb0600ad51c33176b6162ccc
Author: Sean Paul <seanpaul@chromium.org>
Date:   Wed Feb 28 14:19:01 2018 -0500

    drm/msm: Remove msm_commit/worker, use atomic helper commit
    
    Moving further towards switching fully to the the atomic helpers, this
    patch removes the hand-rolled worker nonblock commit code and uses the
    atomic helpers commit_work model.
    
    Changes in v2:
    - Remove commit_destroy()
    - Shuffle order of commit_tail calls to further serialize commits
    - Use stall in swap_state to avoid abandoned events on disable
    Changes in v3:
    - Rebased on Archit's private_obj set
    Changes in v4:
    - None
    
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 1c89195da4ff..9cec74c79aa2 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -381,7 +381,6 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 
 	priv->wq = alloc_ordered_workqueue("msm", 0);
 	priv->atomic_wq = alloc_ordered_workqueue("msm:atomic", 0);
-	init_waitqueue_head(&priv->pending_crtcs_event);
 
 	INIT_LIST_HEAD(&priv->inactive_list);
 	INIT_LIST_HEAD(&priv->vblank_ctrl.event_list);

commit c21c731d93e8148d926a63797d33075128e60cdd
Author: Archit Taneja <architt@codeaurora.org>
Date:   Wed Feb 21 09:37:24 2018 -0500

    drm/msm: Don't subclass drm_atomic_state anymore
    
    With the addition of "private_objs" in drm_atomic_state, we no longer
    need to subclass drm_atomic_state to store state of share resources
    that don't perfectly fit within planes/crtc/connector state information.
    We can now save this state within drm_atomic_state itself using
    the private objects.
    
    Remove the infrastructure that allowed subclassing of drm_atomic_state
    in the driver.
    
    Changes in v3:
    - Added to the msm atomic helper patch set
    Changes in v4:
    - None
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 30cd514d8f7c..1c89195da4ff 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -42,9 +42,6 @@ static const struct drm_mode_config_funcs mode_config_funcs = {
 	.output_poll_changed = drm_fb_helper_output_poll_changed,
 	.atomic_check = drm_atomic_helper_check,
 	.atomic_commit = msm_atomic_commit,
-	.atomic_state_alloc = msm_atomic_state_alloc,
-	.atomic_state_clear = msm_atomic_state_clear,
-	.atomic_state_free = msm_atomic_state_free,
 };
 
 #ifdef CONFIG_DRM_MSM_REGISTER_LOGGING

commit dc9a9b32053efea0a2610be98814519ec59570b4
Author: Steve Kowalik <steven@wedontsleep.org>
Date:   Fri Jan 26 14:55:54 2018 +1100

    drm/msm: Replace gem_object deprecated functions
    
    drm_gem_object_{reference,unreference,unreference_unlocked} are
    deprecated functions, and merely alias to the get/put functions.
    Switch to the new names.
    
    Signed-off-by: Steve Kowalik <steven@wedontsleep.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index d90ef1d78a1b..30cd514d8f7c 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -660,7 +660,7 @@ static int msm_ioctl_gem_cpu_prep(struct drm_device *dev, void *data,
 
 	ret = msm_gem_cpu_prep(obj, args->op, &timeout);
 
-	drm_gem_object_unreference_unlocked(obj);
+	drm_gem_object_put_unlocked(obj);
 
 	return ret;
 }
@@ -678,7 +678,7 @@ static int msm_ioctl_gem_cpu_fini(struct drm_device *dev, void *data,
 
 	ret = msm_gem_cpu_fini(obj);
 
-	drm_gem_object_unreference_unlocked(obj);
+	drm_gem_object_put_unlocked(obj);
 
 	return ret;
 }
@@ -718,7 +718,7 @@ static int msm_ioctl_gem_info(struct drm_device *dev, void *data,
 		args->offset = msm_gem_mmap_offset(obj);
 	}
 
-	drm_gem_object_unreference_unlocked(obj);
+	drm_gem_object_put_unlocked(obj);
 
 	return ret;
 }
@@ -783,7 +783,7 @@ static int msm_ioctl_gem_madvise(struct drm_device *dev, void *data,
 		ret = 0;
 	}
 
-	drm_gem_object_unreference(obj);
+	drm_gem_object_put(obj);
 
 unlock:
 	mutex_unlock(&dev->struct_mutex);

commit 4ccbc6e5756296595d437e28565f3ed62a7f3a0f
Author: Noralf Tr√∏nnes <noralf@tronnes.org>
Date:   Tue Dec 5 19:24:59 2017 +0100

    drm/msm: Use drm_fb_helper_lastclose() and _poll_changed()
    
    This driver can use drm_fb_helper_lastclose() as its .lastclose callback.
    It can also use drm_fb_helper_output_poll_changed() as its
    .output_poll_changed callback.
    
    Cc: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Noralf Tr√∏nnes <noralf@tronnes.org>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171205182504.41923-7-noralf@tronnes.org

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 0a3ea3034e39..d90ef1d78a1b 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -37,16 +37,9 @@
 #define MSM_VERSION_MINOR	3
 #define MSM_VERSION_PATCHLEVEL	0
 
-static void msm_fb_output_poll_changed(struct drm_device *dev)
-{
-	struct msm_drm_private *priv = dev->dev_private;
-	if (priv->fbdev)
-		drm_fb_helper_hotplug_event(priv->fbdev);
-}
-
 static const struct drm_mode_config_funcs mode_config_funcs = {
 	.fb_create = msm_framebuffer_create,
-	.output_poll_changed = msm_fb_output_poll_changed,
+	.output_poll_changed = drm_fb_helper_output_poll_changed,
 	.atomic_check = drm_atomic_helper_check,
 	.atomic_commit = msm_atomic_commit,
 	.atomic_state_alloc = msm_atomic_state_alloc,
@@ -551,13 +544,6 @@ static void msm_postclose(struct drm_device *dev, struct drm_file *file)
 	context_close(ctx);
 }
 
-static void msm_lastclose(struct drm_device *dev)
-{
-	struct msm_drm_private *priv = dev->dev_private;
-	if (priv->fbdev)
-		drm_fb_helper_restore_fbdev_mode_unlocked(priv->fbdev);
-}
-
 static irqreturn_t msm_irq(int irq, void *arg)
 {
 	struct drm_device *dev = arg;
@@ -866,7 +852,7 @@ static struct drm_driver msm_driver = {
 				DRIVER_MODESET,
 	.open               = msm_open,
 	.postclose           = msm_postclose,
-	.lastclose          = msm_lastclose,
+	.lastclose          = drm_fb_helper_lastclose,
 	.irq_handler        = msm_irq,
 	.irq_preinstall     = msm_irq_preinstall,
 	.irq_postinstall    = msm_irq_postinstall,

commit 1f920175fff934b2bef0168cb70cf82b690f2d96
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Oct 25 12:30:51 2017 -0400

    drm/msm/atomic: switch to drm_atomic_helper_check
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index bfb8c7cf800a..0a3ea3034e39 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -47,7 +47,7 @@ static void msm_fb_output_poll_changed(struct drm_device *dev)
 static const struct drm_mode_config_funcs mode_config_funcs = {
 	.fb_create = msm_framebuffer_create,
 	.output_poll_changed = msm_fb_output_poll_changed,
-	.atomic_check = msm_atomic_check,
+	.atomic_check = drm_atomic_helper_check,
 	.atomic_commit = msm_atomic_commit,
 	.atomic_state_alloc = msm_atomic_state_alloc,
 	.atomic_state_clear = msm_atomic_state_clear,

commit f97decac5f4c2d862e5b848694e3ffb29fc8acdd
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Fri Oct 20 11:06:57 2017 -0600

    drm/msm: Support multiple ringbuffers
    
    Add the infrastructure to support the idea of multiple ringbuffers.
    Assign each ringbuffer an id and use that as an index for the various
    ring specific operations.
    
    The biggest delta is to support legacy fences. Each fence gets its own
    sequence number but the legacy functions expect to use a unique integer.
    To handle this we return a unique identifier for each submission but
    map it to a specific ring/sequence under the covers. Newer users use
    a dma_fence pointer anyway so they don't care about the actual sequence
    ID or ring.
    
    The actual mechanics for multiple ringbuffers are very target specific
    so this code just allows for the possibility but still only defines
    one ringbuffer for each target family.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 2585bebfcf3e..bfb8c7cf800a 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -507,7 +507,7 @@ static void load_gpu(struct drm_device *dev)
 	mutex_unlock(&init_lock);
 }
 
-static int context_init(struct drm_file *file)
+static int context_init(struct drm_device *dev, struct drm_file *file)
 {
 	struct msm_file_private *ctx;
 
@@ -515,7 +515,7 @@ static int context_init(struct drm_file *file)
 	if (!ctx)
 		return -ENOMEM;
 
-	msm_submitqueue_init(ctx);
+	msm_submitqueue_init(dev, ctx);
 
 	file->driver_priv = ctx;
 
@@ -529,7 +529,7 @@ static int msm_open(struct drm_device *dev, struct drm_file *file)
 	 */
 	load_gpu(dev);
 
-	return context_init(file);
+	return context_init(dev, file);
 }
 
 static void context_close(struct msm_file_private *ctx)
@@ -743,16 +743,27 @@ static int msm_ioctl_wait_fence(struct drm_device *dev, void *data,
 	struct msm_drm_private *priv = dev->dev_private;
 	struct drm_msm_wait_fence *args = data;
 	ktime_t timeout = to_ktime(args->timeout);
+	struct msm_gpu_submitqueue *queue;
+	struct msm_gpu *gpu = priv->gpu;
+	int ret;
 
 	if (args->pad) {
 		DRM_ERROR("invalid pad: %08x\n", args->pad);
 		return -EINVAL;
 	}
 
-	if (!priv->gpu)
+	if (!gpu)
 		return 0;
 
-	return msm_wait_fence(priv->gpu->fctx, args->fence, &timeout, true);
+	queue = msm_submitqueue_get(file->driver_priv, args->queueid);
+	if (!queue)
+		return -ENOENT;
+
+	ret = msm_wait_fence(gpu->rb[queue->prio]->fctx, args->fence, &timeout,
+		true);
+
+	msm_submitqueue_put(queue);
+	return ret;
 }
 
 static int msm_ioctl_gem_madvise(struct drm_device *dev, void *data,
@@ -802,7 +813,7 @@ static int msm_ioctl_submitqueue_new(struct drm_device *dev, void *data,
 	if (args->flags & ~MSM_SUBMITQUEUE_FLAGS)
 		return -EINVAL;
 
-	return msm_submitqueue_create(file->driver_priv, args->prio,
+	return msm_submitqueue_create(dev, file->driver_priv, args->prio,
 		args->flags, &args->id);
 }
 

commit f7de15450e906ed6586b29bde609a5686cd0d034
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Fri Oct 20 11:06:55 2017 -0600

    drm/msm: Add per-instance submit queues
    
    Currently the behavior of a command stream is provided by the user
    application during submission and the application is expected to internally
    maintain the settings for each 'context' or 'rendering queue' and specify
    the correct ones.
    
    This works okay for simple cases but as applications become more
    complex we will want to set context specific flags and do various
    permission checks to allow certain contexts to enable additional
    privileges.
    
    Add kernel-side submit queues to be analogous to 'contexts' or
    'rendering queues' on the application side. Each file descriptor
    instance will maintain its own list of queues. Queues cannot be
    shared between file descriptors.
    
    For backwards compatibility context id '0' is defined as a default
    context specifying no priority and no special flags. This is
    intended to be the usual configuration for 99% of applications so
    that a garden variety application can function correctly without
    creating a queue. Only those applications requiring the specific
    benefit of different queues need create one.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index d4d4146b3425..2585bebfcf3e 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -29,9 +29,12 @@
  * - 1.0.0 - initial interface
  * - 1.1.0 - adds madvise, and support for submits with > 4 cmd buffers
  * - 1.2.0 - adds explicit fence support for submit ioctl
+ * - 1.3.0 - adds GMEM_BASE + NR_RINGS params, SUBMITQUEUE_NEW +
+ *           SUBMITQUEUE_CLOSE ioctls, and MSM_INFO_IOVA flag for
+ *           MSM_GEM_INFO ioctl.
  */
 #define MSM_VERSION_MAJOR	1
-#define MSM_VERSION_MINOR	2
+#define MSM_VERSION_MINOR	3
 #define MSM_VERSION_PATCHLEVEL	0
 
 static void msm_fb_output_poll_changed(struct drm_device *dev)
@@ -504,24 +507,37 @@ static void load_gpu(struct drm_device *dev)
 	mutex_unlock(&init_lock);
 }
 
-static int msm_open(struct drm_device *dev, struct drm_file *file)
+static int context_init(struct drm_file *file)
 {
 	struct msm_file_private *ctx;
 
-	/* For now, load gpu on open.. to avoid the requirement of having
-	 * firmware in the initrd.
-	 */
-	load_gpu(dev);
-
 	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
 	if (!ctx)
 		return -ENOMEM;
 
+	msm_submitqueue_init(ctx);
+
 	file->driver_priv = ctx;
 
 	return 0;
 }
 
+static int msm_open(struct drm_device *dev, struct drm_file *file)
+{
+	/* For now, load gpu on open.. to avoid the requirement of having
+	 * firmware in the initrd.
+	 */
+	load_gpu(dev);
+
+	return context_init(file);
+}
+
+static void context_close(struct msm_file_private *ctx)
+{
+	msm_submitqueue_close(ctx);
+	kfree(ctx);
+}
+
 static void msm_postclose(struct drm_device *dev, struct drm_file *file)
 {
 	struct msm_drm_private *priv = dev->dev_private;
@@ -532,7 +548,7 @@ static void msm_postclose(struct drm_device *dev, struct drm_file *file)
 		priv->lastctx = NULL;
 	mutex_unlock(&dev->struct_mutex);
 
-	kfree(ctx);
+	context_close(ctx);
 }
 
 static void msm_lastclose(struct drm_device *dev)
@@ -777,6 +793,28 @@ static int msm_ioctl_gem_madvise(struct drm_device *dev, void *data,
 	return ret;
 }
 
+
+static int msm_ioctl_submitqueue_new(struct drm_device *dev, void *data,
+		struct drm_file *file)
+{
+	struct drm_msm_submitqueue *args = data;
+
+	if (args->flags & ~MSM_SUBMITQUEUE_FLAGS)
+		return -EINVAL;
+
+	return msm_submitqueue_create(file->driver_priv, args->prio,
+		args->flags, &args->id);
+}
+
+
+static int msm_ioctl_submitqueue_close(struct drm_device *dev, void *data,
+		struct drm_file *file)
+{
+	u32 id = *(u32 *) data;
+
+	return msm_submitqueue_remove(file->driver_priv, id);
+}
+
 static const struct drm_ioctl_desc msm_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(MSM_GET_PARAM,    msm_ioctl_get_param,    DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(MSM_GEM_NEW,      msm_ioctl_gem_new,      DRM_AUTH|DRM_RENDER_ALLOW),
@@ -786,6 +824,8 @@ static const struct drm_ioctl_desc msm_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(MSM_GEM_SUBMIT,   msm_ioctl_gem_submit,   DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(MSM_WAIT_FENCE,   msm_ioctl_wait_fence,   DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(MSM_GEM_MADVISE,  msm_ioctl_gem_madvise,  DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_NEW,   msm_ioctl_submitqueue_new,   DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_CLOSE, msm_ioctl_submitqueue_close, DRM_AUTH|DRM_RENDER_ALLOW),
 };
 
 static const struct vm_operations_struct vm_ops = {

commit eec874ce5ff1fe1742317513904a2292af749c7d
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon Oct 16 09:22:38 2017 -0400

    drm/msm/adreno: load gpu at probe/bind time
    
    Previously, in an effort to defer initializing the gpu until firmware
    was available (ie. rootfs mounted), the gpu was not loaded at when the
    subdevice was bound.  Which resulted that clks/etc were requested in a
    place that devm couldn't really help unwind if something failed.
    
    Instead move request_firmware() to gpu->hw_init() and construct the gpu
    earlier in adreno_bind().  To avoid the rest of the driver needing to
    be aware of a gpu that hasn't managed to load firmware and hw_init()
    yet, stash the gpu ptr in the adreno device's drvdata, and don't set
    priv->gpu() until hw_init() succeeds.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 606df7bea97b..d4d4146b3425 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -211,7 +211,6 @@ static int msm_drm_uninit(struct device *dev)
 	struct drm_device *ddev = platform_get_drvdata(pdev);
 	struct msm_drm_private *priv = ddev->dev_private;
 	struct msm_kms *kms = priv->kms;
-	struct msm_gpu *gpu = priv->gpu;
 	struct msm_vblank_ctrl *vbl_ctrl = &priv->vblank_ctrl;
 	struct vblank_event *vbl_ev, *tmp;
 
@@ -253,15 +252,6 @@ static int msm_drm_uninit(struct device *dev)
 	if (kms && kms->funcs)
 		kms->funcs->destroy(kms);
 
-	if (gpu) {
-		mutex_lock(&ddev->struct_mutex);
-		// XXX what do we do here?
-		//pm_runtime_enable(&pdev->dev);
-		gpu->funcs->pm_suspend(gpu);
-		mutex_unlock(&ddev->struct_mutex);
-		gpu->funcs->destroy(gpu);
-	}
-
 	if (priv->vram.paddr) {
 		unsigned long attrs = DMA_ATTR_NO_KERNEL_MAPPING;
 		drm_mm_takedown(&priv->vram.mm);

commit cfcfb65ad15a1b43cf5cd434c57966fae03db96b
Merge: 7c0059dd832c d1f08d821762
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Aug 25 09:29:45 2017 +1000

    Merge tag 'drm-msm-next-2017-08-22' of git://people.freedesktop.org/~robclark/linux into drm-next
    
    Updates for 4.14..  I have some further patches from Jordan to add
    multiple priority levels and pre-emption, but those will probably be
    for 4.15 to give me time for the mesa parts.
    
    * tag 'drm-msm-next-2017-08-22' of git://people.freedesktop.org/~robclark/linux:
      drm/msm/mdp5: mark runtime_pm functions as __maybe_unused
      drm/msm: remove unused variable
      drm/msm/mdp5: make helper function static
      drm/msm: make msm_framebuffer_init() static
      drm/msm: add helper to allocate stolen fb
      drm/msm: don't track fbdev's gem object separately
      drm/msm: add modeset module param
      drm/msm/mdp5: add tracking for clk enable-count
      drm/msm: remove unused define
      drm/msm: Add a helper function for in-kernel buffer allocations
      drm/msm: Attach the GPU MMU when it is created
      drm/msm: Add A5XX hardware fault detection
      drm/msm: Remove uneeded platform dev members
      drm/msm/mdp5: Set up runtime PM for MDSS
      drm/msm/mdp5: Write to SMP registers even if allocations don't change
      drm/msm/mdp5: Don't use mode_set helper funcs for encoders and CRTCs
      drm/msm/dsi: Implement RPM suspend/resume callbacks
      drm/msm/dsi: Set up runtime PM for DSI
      drm/msm/hdmi: Set up runtime PM for HDMI
      drm/msm/mdp5: Use runtime PM get/put API instead of toggling clocks

commit ba4dd71828bce7dfa46a5e6e33e2605f65d16534
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Jul 6 16:33:44 2017 -0400

    drm/msm: add modeset module param
    
    At least for debugging it is nice to have an easy way to force the
    driver not to load.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index a19c393f7e45..dda55b6103e2 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -73,6 +73,10 @@ bool dumpstate = false;
 MODULE_PARM_DESC(dumpstate, "Dump KMS state on errors");
 module_param(dumpstate, bool, 0600);
 
+static bool modeset = true;
+MODULE_PARM_DESC(modeset, "Use kernel modesetting [KMS] (1=on (default), 0=disable)");
+module_param(modeset, bool, 0600);
+
 /*
  * Util/helpers:
  */
@@ -1133,6 +1137,9 @@ static struct platform_driver msm_platform_driver = {
 
 static int __init msm_drm_register(void)
 {
+	if (!modeset)
+		return -EINVAL;
+
 	DBG("init");
 	msm_mdp_register();
 	msm_dsi_register();

commit 99da7cd6685e50ee88bd351cc08bb303731d4129
Author: Noralf Tr√∏nnes <noralf@tronnes.org>
Date:   Sun Aug 6 17:41:01 2017 +0200

    drm/msm: Use the drm_driver.dumb_destroy default
    
    drm_gem_dumb_destroy() is the drm_driver.dumb_destroy default,
    so no need to set it.
    
    Cc: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Noralf Tr√∏nnes <noralf@tronnes.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1502034068-51384-13-git-send-email-noralf@tronnes.org

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index f49f6ac5585c..b0129e7b29e3 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -832,7 +832,6 @@ static struct drm_driver msm_driver = {
 	.gem_vm_ops         = &vm_ops,
 	.dumb_create        = msm_gem_dumb_create,
 	.dumb_map_offset    = msm_gem_dumb_map_offset,
-	.dumb_destroy       = drm_gem_dumb_destroy,
 	.prime_handle_to_fd = drm_gem_prime_handle_to_fd,
 	.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
 	.gem_prime_export   = drm_gem_prime_export,

commit 774e39ee3572272b816f3a0b39dfdbcc70dd47f1
Author: Archit Taneja <architt@codeaurora.org>
Date:   Fri Jul 28 16:17:07 2017 +0530

    drm/msm/mdp5: Set up runtime PM for MDSS
    
    MDSS represents the top level wrapper that contains MDP5, DSI, HDMI and
    other sub-blocks. W.r.t device heirarchy, it's the parent of all these
    devices. The power domain of this device is actually tied to the GDSC
    hw. When any sub-device enables its PD, MDSS's PD is also enabled.
    
    The suspend/resume ops enable the top level clocks that end at the MDSS
    boundary. For now, we're letting them all be optional, since the child
    devices anyway hold a ref to these clocks.
    
    Until now, we'd called a runtime_get() during probe, which ensured that
    the GDSC was always on. Now that we've set up runtime PM for the children
    devices, we can get rid of this hack.
    
    Note: that the MDSS device is the platform_device in msm_drv.c. The
    msm_runtime_suspend/resume ops call the funcs that enable/disable
    the top level MDSS clocks. This is different from MDP4, where the
    platform device created in msm_drv.c represents MDP4 itself. It would
    have been nicer to hide these differences by adding new kms funcs, but
    runtime PM needs to be enabled before kms is set up (i.e, msm_kms_init
    is called).
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index f49f6ac5585c..a19c393f7e45 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -879,8 +879,37 @@ static int msm_pm_resume(struct device *dev)
 }
 #endif
 
+#ifdef CONFIG_PM
+static int msm_runtime_suspend(struct device *dev)
+{
+	struct drm_device *ddev = dev_get_drvdata(dev);
+	struct msm_drm_private *priv = ddev->dev_private;
+
+	DBG("");
+
+	if (priv->mdss)
+		return msm_mdss_disable(priv->mdss);
+
+	return 0;
+}
+
+static int msm_runtime_resume(struct device *dev)
+{
+	struct drm_device *ddev = dev_get_drvdata(dev);
+	struct msm_drm_private *priv = ddev->dev_private;
+
+	DBG("");
+
+	if (priv->mdss)
+		return msm_mdss_enable(priv->mdss);
+
+	return 0;
+}
+#endif
+
 static const struct dev_pm_ops msm_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(msm_pm_suspend, msm_pm_resume)
+	SET_RUNTIME_PM_OPS(msm_runtime_suspend, msm_runtime_resume, NULL)
 };
 
 /*

commit 0e08270a1f01bceae17d32a0d75aad2388bd1ba2
Author: Sushmita Susheelendra <ssusheel@codeaurora.org>
Date:   Tue Jun 13 16:52:54 2017 -0600

    drm/msm: Separate locking of buffer resources from struct_mutex
    
    Buffer object specific resources like pages, domains, sg list
    need not be protected with struct_mutex. They can be protected
    with a buffer object level lock. This simplifies locking and
    makes it easier to avoid potential recursive locking scenarios
    for SVM involving mmap_sem and struct_mutex. This also removes
    unnecessary serialization when creating buffer objects, and also
    between buffer object creation and GPU command submission.
    
    Signed-off-by: Sushmita Susheelendra <ssusheel@codeaurora.org>
    [robclark: squash in handling new locking for shrinker]
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 506de3862c18..f49f6ac5585c 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -336,6 +336,7 @@ static int msm_init_vram(struct drm_device *dev)
 		priv->vram.size = size;
 
 		drm_mm_init(&priv->vram.mm, 0, (size >> PAGE_SHIFT) - 1);
+		spin_lock_init(&priv->vram.lock);
 
 		attrs |= DMA_ATTR_NO_KERNEL_MAPPING;
 		attrs |= DMA_ATTR_WRITE_COMBINE;

commit 8432a903fb97ac3640dbf9281e7c15a673b45747
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Jun 13 14:27:45 2017 -0400

    drm/msm: remove address-space id
    
    Now that the msm_gem supports an arbitrary number of vma's, we no longer
    need to assign an id (index) to each address space.  So rip out the
    associated code.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index a9c3c6b813d3..506de3862c18 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -51,22 +51,6 @@ static const struct drm_mode_config_funcs mode_config_funcs = {
 	.atomic_state_free = msm_atomic_state_free,
 };
 
-#include "msm_gem.h"  /* temporary */
-int msm_register_address_space(struct drm_device *dev,
-		struct msm_gem_address_space *aspace)
-{
-	struct msm_drm_private *priv = dev->dev_private;
-
-	if (WARN_ON(priv->num_aspaces >= ARRAY_SIZE(priv->aspace)))
-		return -EINVAL;
-
-	priv->aspace[priv->num_aspaces] = aspace;
-
-	aspace->id = priv->num_aspaces++;
-
-	return aspace->id;
-}
-
 #ifdef CONFIG_DRM_MSM_REGISTER_LOGGING
 static bool reglog = false;
 MODULE_PARM_DESC(reglog, "Enable register read/write logging");

commit 8bdcd949bbe7e7f9e60a3564baa600884f8f4ba7
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Jun 13 11:07:08 2017 -0400

    drm/msm: pass address-space to _get_iova() and friends
    
    No functional change, that will come later.  But this will make it
    easier to deal with dynamically created address spaces (ie. per-
    process pagetables for gpu).
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index beb4f6b3ac70..a9c3c6b813d3 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -51,6 +51,7 @@ static const struct drm_mode_config_funcs mode_config_funcs = {
 	.atomic_state_free = msm_atomic_state_free,
 };
 
+#include "msm_gem.h"  /* temporary */
 int msm_register_address_space(struct drm_device *dev,
 		struct msm_gem_address_space *aspace)
 {
@@ -61,7 +62,9 @@ int msm_register_address_space(struct drm_device *dev,
 
 	priv->aspace[priv->num_aspaces] = aspace;
 
-	return priv->num_aspaces++;
+	aspace->id = priv->num_aspaces++;
+
+	return aspace->id;
 }
 
 #ifdef CONFIG_DRM_MSM_REGISTER_LOGGING
@@ -707,7 +710,7 @@ static int msm_ioctl_gem_info_iova(struct drm_device *dev,
 	if (!priv->gpu)
 		return -EINVAL;
 
-	return msm_gem_get_iova(obj, priv->gpu->id, iova);
+	return msm_gem_get_iova(obj, priv->gpu->aspace, iova);
 }
 
 static int msm_ioctl_gem_info(struct drm_device *dev, void *data,

commit 49fd08baa36ac10b13ea7b23fc6bbee8b4a6fcfe
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Mon May 8 14:35:01 2017 -0600

    drm/msm: Add hint to DRM_IOCTL_MSM_GEM_INFO to return an object IOVA
    
    Modify the 'pad' member of struct drm_msm_gem_info to 'flags'. If the
    user sets 'flags' to non-zero it means that they want a IOVA for the
    GEM object instead of a mmap() offset. Return the iova in the 'offset'
    member.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    [robclark: s/hint/flags in commit msg]
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 18d02ccb6c9b..beb4f6b3ac70 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -699,6 +699,17 @@ static int msm_ioctl_gem_cpu_fini(struct drm_device *dev, void *data,
 	return ret;
 }
 
+static int msm_ioctl_gem_info_iova(struct drm_device *dev,
+		struct drm_gem_object *obj, uint64_t *iova)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+
+	if (!priv->gpu)
+		return -EINVAL;
+
+	return msm_gem_get_iova(obj, priv->gpu->id, iova);
+}
+
 static int msm_ioctl_gem_info(struct drm_device *dev, void *data,
 		struct drm_file *file)
 {
@@ -706,14 +717,22 @@ static int msm_ioctl_gem_info(struct drm_device *dev, void *data,
 	struct drm_gem_object *obj;
 	int ret = 0;
 
-	if (args->pad)
+	if (args->flags & ~MSM_INFO_FLAGS)
 		return -EINVAL;
 
 	obj = drm_gem_object_lookup(file, args->handle);
 	if (!obj)
 		return -ENOENT;
 
-	args->offset = msm_gem_mmap_offset(obj);
+	if (args->flags & MSM_INFO_IOVA) {
+		uint64_t iova;
+
+		ret = msm_ioctl_gem_info_iova(dev, obj, &iova);
+		if (!ret)
+			args->offset = iova;
+	} else {
+		args->offset = msm_gem_mmap_offset(obj);
+	}
 
 	drm_gem_object_unreference_unlocked(obj);
 

commit 167b606aa262270ab6aeb5700adca6b1f33da26a
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Mon May 8 14:34:59 2017 -0600

    drm/msm: Remove DRM_MSM_NUM_IOCTLS
    
    The ioctl array is sparsely populated but the compiler will make sure
    that it is sufficiently sized for all the values that we have so we
    can safely use ARRAY_SIZE() instead of having a constantly changing
    #define in the uapi header.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 9d498eb81906..18d02ccb6c9b 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -842,7 +842,7 @@ static struct drm_driver msm_driver = {
 	.debugfs_init       = msm_debugfs_init,
 #endif
 	.ioctls             = msm_ioctls,
-	.num_ioctls         = DRM_MSM_NUM_IOCTLS,
+	.num_ioctls         = ARRAY_SIZE(msm_ioctls),
 	.fops               = &fops,
 	.name               = "msm",
 	.desc               = "MSM Snapdragon DRM",

commit 43523eba79bda8f5b4c27f8ffe20ea078d20113a
Author: Eric Anholt <eric@anholt.net>
Date:   Wed Apr 12 12:11:58 2017 -0700

    drm/msm: Expose our reservation object when exporting a dmabuf.
    
    Without this, polling on the dma-buf (and presumably other devices
    synchronizing against our rendering) would return immediately, even
    while the BO was busy.
    
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: stable@vger.kernel.org
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 87b5695d4034..9d498eb81906 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -830,6 +830,7 @@ static struct drm_driver msm_driver = {
 	.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
 	.gem_prime_export   = drm_gem_prime_export,
 	.gem_prime_import   = drm_gem_prime_import,
+	.gem_prime_res_obj  = msm_gem_prime_res_obj,
 	.gem_prime_pin      = msm_gem_prime_pin,
 	.gem_prime_unpin    = msm_gem_prime_unpin,
 	.gem_prime_get_sg_table = msm_gem_prime_get_sg_table,

commit 36849cc361428b0b60c9065f854fe22bd55ce3ab
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Tue Mar 7 09:50:28 2017 -0700

    drm/msm: Don't increase priv->num_aspaces until we know that it fits
    
    priv->num_aspaces is increased and then checked to see if it still fits
    in the priv->aspace array.  If it doesn't, we warn and exit but
    priv->num_aspaces remains incremented.
    
    Don't incremement the count until we know that it fits in the array.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 3f36c8d93122..87b5695d4034 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -55,14 +55,13 @@ int msm_register_address_space(struct drm_device *dev,
 		struct msm_gem_address_space *aspace)
 {
 	struct msm_drm_private *priv = dev->dev_private;
-	int idx = priv->num_aspaces++;
 
-	if (WARN_ON(idx >= ARRAY_SIZE(priv->aspace)))
+	if (WARN_ON(priv->num_aspaces >= ARRAY_SIZE(priv->aspace)))
 		return -EINVAL;
 
-	priv->aspace[idx] = aspace;
+	priv->aspace[priv->num_aspaces] = aspace;
 
-	return idx;
+	return priv->num_aspaces++;
 }
 
 #ifdef CONFIG_DRM_MSM_REGISTER_LOGGING

commit 94df145c7e17c6212e2078a2ef976c365973eada
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 8 15:12:46 2017 +0100

    drm/msm: switch to postclose
    
    I didn't spot anything that would require ordering here (well not
    anywhere else either), and I'm trying to unify at least modern drivers
    on one close hook.
    
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 5875aa8fbe7c..3f36c8d93122 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -541,7 +541,7 @@ static int msm_open(struct drm_device *dev, struct drm_file *file)
 	return 0;
 }
 
-static void msm_preclose(struct drm_device *dev, struct drm_file *file)
+static void msm_postclose(struct drm_device *dev, struct drm_file *file)
 {
 	struct msm_drm_private *priv = dev->dev_private;
 	struct msm_file_private *ctx = file->driver_priv;
@@ -814,7 +814,7 @@ static struct drm_driver msm_driver = {
 				DRIVER_ATOMIC |
 				DRIVER_MODESET,
 	.open               = msm_open,
-	.preclose           = msm_preclose,
+	.postclose           = msm_postclose,
 	.lastclose          = msm_lastclose,
 	.irq_handler        = msm_irq,
 	.irq_preinstall     = msm_irq_preinstall,

commit eeb754746b140c5f55e6b25706a9142aa549b348
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Feb 10 15:36:33 2017 -0500

    drm/msm/gpu: use pm-runtime
    
    We need to use pm-runtime properly when IOMMU is using device_link() to
    control it's own clocks.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 9208e67be453..5875aa8fbe7c 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -265,6 +265,8 @@ static int msm_drm_uninit(struct device *dev)
 
 	if (gpu) {
 		mutex_lock(&ddev->struct_mutex);
+		// XXX what do we do here?
+		//pm_runtime_enable(&pdev->dev);
 		gpu->funcs->pm_suspend(gpu);
 		mutex_unlock(&ddev->struct_mutex);
 		gpu->funcs->destroy(gpu);

commit a45216547e8925078b18b2a6b539100c3814e973
Merge: 35dc8aabc878 76adb460fd93
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sat Mar 11 11:46:03 2017 +0100

    Merge branch 'drm/next/platform' of git://linuxtv.org/pinchartl/media into drm-misc-next
    
    Merge Laurent's drm_platform removal code. Only conflict is with the
    drm_pci.h extraction, which allows me to fix up the misplayed
    drm_platform_init fumble that 0day and Stephen Rothwell reported.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit 85eac4700ede7c583aab29ad6bdfe135f693c29b
Author: Noralf Tr√∏nnes <noralf@tronnes.org>
Date:   Tue Mar 7 21:49:22 2017 +0100

    drm/msm: Remove msm_debugfs_cleanup()
    
    Move the contents of msm_debugfs_cleanup() to msm_drm_uninit() to free
    up the drm_driver->debugfs_cleanup callback. Also remove the
    mdp_kms_funcs->debugfs_cleanup callback which has no users.
    
    Cc: robdclark@gmail.com
    Signed-off-by: Noralf Tr√∏nnes <noralf@tronnes.org>
    Acked-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170307204924.1002-2-noralf@tronnes.org

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 6842d427cc2b..604331f3cf39 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -241,6 +241,9 @@ static int msm_drm_uninit(struct device *dev)
 
 	drm_dev_unregister(ddev);
 
+	msm_perf_debugfs_cleanup(priv);
+	msm_rd_debugfs_cleanup(priv);
+
 #ifdef CONFIG_DRM_FBDEV_EMULATION
 	if (fbdev && priv->fbdev)
 		msm_fbdev_free(ddev);
@@ -836,7 +839,6 @@ static struct drm_driver msm_driver = {
 	.gem_prime_mmap     = msm_gem_prime_mmap,
 #ifdef CONFIG_DEBUG_FS
 	.debugfs_init       = msm_debugfs_init,
-	.debugfs_cleanup    = msm_debugfs_cleanup,
 #endif
 	.ioctls             = msm_ioctls,
 	.num_ioctls         = DRM_MSM_NUM_IOCTLS,

commit 8dfe162ac74f56b382d6e3d37365672897422f51
Author: Joe Perches <joe@perches.com>
Date:   Tue Feb 28 04:55:54 2017 -0800

    gpu: drm: drivers: Convert printk(KERN_<LEVEL> to pr_<level>
    
    Use a more common logging style.
    
    Miscellanea:
    
    o Coalesce formats and realign arguments
    o Neaten a few macros now using pr_<level>
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Rob Clark <robdclark@gmail.com>
    Acked-by: Sinclair Yeh <syeh@vmware.com>
    Acked-by: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Acked-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/76355db47b31668bb64d996865ceee53bd66b11f.1488285953.git.joe@perches.com

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index cb47f4a14215..6842d427cc2b 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -152,7 +152,7 @@ u32 msm_readl(const void __iomem *addr)
 {
 	u32 val = readl(addr);
 	if (reglog)
-		printk(KERN_ERR "IO:R %p %08x\n", addr, val);
+		pr_err("IO:R %p %08x\n", addr, val);
 	return val;
 }
 

commit 8e22e1b3499a446df48c2b26667ca36c55bf864c
Merge: 00d3c14f14d5 64a577196d66
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sun Feb 26 21:34:42 2017 +0100

    Merge airlied/drm-next into drm-misc-next
    
    Backmerge the main pull request to sync up with all the newly landed
    drivers. Otherwise we'll have chaos even before 4.12 started in
    earnest.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

commit 76adb460fd939756db689f238d5c2ddb45469705
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sun Dec 18 00:01:19 2016 +0200

    drm: Remove the struct drm_device platformdev field
    
    The field contains a pointer to the parent platform device of the DRM
    device. As struct drm_device also contains a dev pointer to the struct
    device embedded in the platform_device structure, the platformdev field
    is redundant. Remove it and use the dev pointer directly.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Jyri Sarha <jsarha@ti.com>
    Acked-by: Vincent Abriou <vincent.abriou@st.com> # For sti
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk> # For armada
    Acked-by: Rob Clark <robdclark@gmail.com> # For msm
    Acked-by: Xinwei Kong<kong.kongxinwei@hisilicon.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 70226eaa5cac..19435079b11f 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -383,7 +383,6 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	}
 
 	platform_set_drvdata(pdev, ddev);
-	ddev->platformdev = pdev;
 
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv) {

commit 967dd48417874dd25491a4e933648f394a64f70f
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue Feb 7 17:16:14 2017 +0800

    drm: remove drm_vblank_no_hw_counter assignment from driver code
    
    Core code already makes drm_driver.get_vblank_counter hook optional by
    letting drm_vblank_no_hw_counter be the default implementation for the
    function hook.  So the drm_vblank_no_hw_counter assignment in the driver
    code becomes redundant and can be removed now.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Cc: Alexey Brodkin <abrodkin@synopsys.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Mali DP Maintainers <malidp@foss.arm.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Xinliang Liu <z.liuxinliang@hisilicon.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: CK Hu <ck.hu@mediatek.com>
    Cc: Neil Armstrong <narmstrong@baylibre.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Marek Vasut <marex@denx.de>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Mark Yao <mark.yao@rock-chips.com>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: Eric Anholt <eric@anholt.net>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Alexey Brodkin <abrodkin@synopsys.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1486458995-31018-3-git-send-email-shawnguo@kernel.org

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index e29bb66f55b1..54207fe59307 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -797,7 +797,6 @@ static struct drm_driver msm_driver = {
 	.irq_preinstall     = msm_irq_preinstall,
 	.irq_postinstall    = msm_irq_postinstall,
 	.irq_uninstall      = msm_irq_uninstall,
-	.get_vblank_counter = drm_vblank_no_hw_counter,
 	.enable_vblank      = msm_enable_vblank,
 	.disable_vblank     = msm_disable_vblank,
 	.gem_free_object    = msm_gem_free_object,

commit 720c3bb80235ffb10129ee930bb394871afbd235
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon Jan 30 11:30:58 2017 -0500

    drm/msm: drop _clk suffix from clk names
    
    Suggested by Rob Herring.  We still support the old names for
    compatibility with downstream android dt files.
    
    Cc: Rob Herring <robh@kernel.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Acked-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 6b85c4195252..70226eaa5cac 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -91,6 +91,25 @@ module_param(dumpstate, bool, 0600);
  * Util/helpers:
  */
 
+struct clk *msm_clk_get(struct platform_device *pdev, const char *name)
+{
+	struct clk *clk;
+	char name2[32];
+
+	clk = devm_clk_get(&pdev->dev, name);
+	if (!IS_ERR(clk) || PTR_ERR(clk) == -EPROBE_DEFER)
+		return clk;
+
+	snprintf(name2, sizeof(name2), "%s_clk", name);
+
+	clk = devm_clk_get(&pdev->dev, name2);
+	if (!IS_ERR(clk))
+		dev_warn(&pdev->dev, "Using legacy clk name binding.  Use "
+				"\"%s\" instead of \"%s\"\n", name, name2);
+
+	return clk;
+}
+
 void __iomem *msm_ioremap(struct platform_device *pdev, const char *name,
 		const char *dbgname)
 {

commit 1db7afa4914642146637f891c9d369948bb026c7
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon Jan 30 11:02:27 2017 -0500

    drm/msm: drop qcom,chipid
    
    The original way we determined the gpu version was based on downstream
    bindings from android kernel.  A cleaner way is to get the version from
    the compatible string.
    
    Note that no upstream dtb uses these bindings.  But the code still
    supports falling back to the legacy bindings (with a warning), so that
    we are still compatible with the gpu dt node from android device
    kernels.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Acked-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index e29bb66f55b1..6b85c4195252 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -985,6 +985,7 @@ static int add_display_components(struct device *dev,
  * as components.
  */
 static const struct of_device_id msm_gpu_match[] = {
+	{ .compatible = "qcom,adreno" },
 	{ .compatible = "qcom,adreno-3xx" },
 	{ .compatible = "qcom,kgsl-3d0" },
 	{ },

commit f5590134365f6f23dba723f140f72effcc71773f
Merge: a90f58311f48 2401a0084614
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Dec 1 09:25:58 2016 +1000

    Merge branch 'msm-next' of git://people.freedesktop.org/~robclark/linux into drm-next
    
    On the userspace side, all the basics are working, and most of glmark2
    is working.  I've been working through deqp, and I've got a couple more
    things to fix (but we've gone from 70% to 80+% pass in last day, and
    current deqp run that is going should pick up another 5-10%).  I expect
    to push the mesa patches today or tomorrow.
    
    There are a couple more a5xx related patches to take the gpu out of
    secure mode (for the devices that come up in secure mode, like the hw
    I have), but those depend on an scm patch that would come in through
    another tree.  If that can land in the next day or two, there might
    be a second late pull request for drm/msm.
    
    In addition to the new-shiny, there have also been a lot of overlay/
    plane related fixes for issues found using drm-hwc2 (in the process of
    testing/debugging the atomic/kms fence patches), resulting in rework
    to assign hwpipes to kms planes dynamically (as part of global atomic
    state) and also handling SMP (fifo) block allocation atomically as
    part of the ->atomic_check() step.  All those patches should also help
    out atomic weston (when those patches eventually land).
    
    * 'msm-next' of git://people.freedesktop.org/~robclark/linux: (36 commits)
      drm/msm: gpu: Add support for the GPMU
      drm/msm: gpu: Add A5XX target support
      drm/msm: Disable interrupts during init
      drm/msm: Remove 'src_clk' from adreno configuration
      drm/msm: gpu: Add OUT_TYPE4 and OUT_TYPE7
      drm/msm: Add adreno_gpu_write64()
      drm/msm: gpu Add new gpu register read/write functions
      drm/msm: gpu: Return error on hw_init failure
      drm/msm: gpu: Cut down the list of "generic" registers to the ones we use
      drm/msm: update generated headers
      drm/msm/adreno: move scratch register dumping to per-gen code
      drm/msm/rd: support for 64b iova
      drm/msm: convert iova to 64b
      drm/msm: set dma_mask properly
      drm/msm: Remove bad calls to of_node_put()
      drm/msm/mdp5: move LM bounds check into plane->atomic_check()
      drm/msm/mdp5: dump smp state on errors too
      drm/msm/mdp5: add debugfs to show smp block status
      drm/msm/mdp5: handle SMP block allocations "atomically"
      drm/msm/mdp5: dynamically assign hw pipes to planes
      ...

commit 63207455963053ca212e61c75f43b3502ea69f0e
Merge: 7625e05286cf 348a4b6dd77d
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Nov 30 14:18:51 2016 +1000

    Merge tag 'drm-qemu-20161121' of git://git.kraxel.org/linux into drm-next
    
    drm/virtio: fix busid in a different way, allocate more vbufs.
    drm/qxl: various bugfixes and cleanups,
    
    * tag 'drm-qemu-20161121' of git://git.kraxel.org/linux: (224 commits)
      drm/virtio: allocate some extra bufs
      qxl: Allow resolution which are not multiple of 8
      qxl: Don't notify userspace when monitors config is unchanged
      qxl: Remove qxl_bo_init() return value
      qxl: Call qxl_gem_{init, fini}
      qxl: Add missing '\n' to qxl_io_log() call
      qxl: Remove unused prototype
      qxl: Mark some internal functions as static
      Revert "drm: virtio: reinstate drm_virtio_set_busid()"
      drm/virtio: fix busid regression
      drm: re-export drm_dev_set_unique
      Linux 4.9-rc5
      gp8psk: Fix DVB frontend attach
      gp8psk: fix gp8psk_usb_in_op() logic
      dvb-usb: move data_mutex to struct dvb_usb_device
      iio: maxim_thermocouple: detect invalid storage size in read()
      aoe: fix crash in page count manipulation
      lightnvm: invalid offset calculation for lba_shift
      Kbuild: enable -Wmaybe-uninitialized warnings by default
      pcmcia: fix return value of soc_pcmcia_regulator_set
      ...

commit c83ea576010d513898c27121e5f8ac355a8eef05
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon Nov 7 13:31:30 2016 -0500

    drm/msm: set dma_mask properly
    
    Previous value really only made sense on armv7 without LPAE.  Everything
    that supports more than 4g of memory also has iommu's that can map
    anything.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index a2cc990bc7c2..10755a1c53b8 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1038,7 +1038,13 @@ static int msm_pdev_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+	/* on all devices that I am aware of, iommu's which can map
+	 * any address the cpu can see are used:
+	 */
+	ret = dma_set_mask_and_coherent(&pdev->dev, ~0);
+	if (ret)
+		return ret;
+
 	return component_master_add_with_match(&pdev->dev, &msm_drm_ops, match);
 }
 

commit d8dd80526c9097bd60464982a011150b1b213d06
Author: Archit Taneja <architt@codeaurora.org>
Date:   Thu Nov 17 12:12:03 2016 +0530

    drm/msm: Remove bad calls to of_node_put()
    
    In add_components_mdp, we parse the endpoints in MDP output ports
    using the helper for_each_endpoint_of_node(). Our function calls
    of_node_put() on the endpoint node before we iterate over the
    next one. This is already done by the helper, and results in
    trying to decrement the refcount twice.
    
    Remove the extra of_node_put calls. This fixes warnings seen when
    we try to insert the driver as a module on IFC6410.
    
    Reported-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index aa41d8dd623b..a2cc990bc7c2 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -911,10 +911,8 @@ static int add_components_mdp(struct device *mdp_dev,
 		 * remote-endpoint isn't a component that we need to add
 		 */
 		if (of_device_is_compatible(np, "qcom,mdp4") &&
-		    ep.port == 0) {
-			of_node_put(ep_node);
+		    ep.port == 0)
 			continue;
-		}
 
 		/*
 		 * It's okay if some of the ports don't have a remote endpoint
@@ -922,15 +920,12 @@ static int add_components_mdp(struct device *mdp_dev,
 		 * any external interface.
 		 */
 		intf = of_graph_get_remote_port_parent(ep_node);
-		if (!intf) {
-			of_node_put(ep_node);
+		if (!intf)
 			continue;
-		}
 
 		drm_of_component_match_add(master_dev, matchptr, compare_of,
 					   intf);
 		of_node_put(intf);
-		of_node_put(ep_node);
 	}
 
 	return 0;

commit 870d738acb7ebb0d4f6192c9d328cae95479715b
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Nov 4 13:51:42 2016 -0400

    drm/msm: subclass drm_atomic_state
    
    This will give the kms backends a slot to stash their own hw specific
    global state.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index c740eaf9272b..aa41d8dd623b 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -46,6 +46,9 @@ static const struct drm_mode_config_funcs mode_config_funcs = {
 	.output_poll_changed = msm_fb_output_poll_changed,
 	.atomic_check = msm_atomic_check,
 	.atomic_commit = msm_atomic_commit,
+	.atomic_state_alloc = msm_atomic_state_alloc,
+	.atomic_state_clear = msm_atomic_state_clear,
+	.atomic_state_free = msm_atomic_state_free,
 };
 
 int msm_register_address_space(struct drm_device *dev,

commit 667ce33e57d0de4074a8fb62d24daeefd03f6333
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Sep 28 19:58:32 2016 -0400

    drm/msm: support multiple address spaces
    
    We can have various combinations of 64b and 32b address space, ie. 64b
    CPU but 32b display and gpu, or 64b CPU and GPU but 32b display.  So
    best to decouple the device iova's from mmap offset.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 8d21fb27a401..c740eaf9272b 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -48,15 +48,16 @@ static const struct drm_mode_config_funcs mode_config_funcs = {
 	.atomic_commit = msm_atomic_commit,
 };
 
-int msm_register_mmu(struct drm_device *dev, struct msm_mmu *mmu)
+int msm_register_address_space(struct drm_device *dev,
+		struct msm_gem_address_space *aspace)
 {
 	struct msm_drm_private *priv = dev->dev_private;
-	int idx = priv->num_mmus++;
+	int idx = priv->num_aspaces++;
 
-	if (WARN_ON(idx >= ARRAY_SIZE(priv->mmus)))
+	if (WARN_ON(idx >= ARRAY_SIZE(priv->aspace)))
 		return -EINVAL;
 
-	priv->mmus[idx] = mmu;
+	priv->aspace[idx] = aspace;
 
 	return idx;
 }

commit 06d9f56f1d9aed065c18ffb48ea51901886afba9
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Nov 5 11:08:12 2016 -0400

    drm/msm: module param to dump state on error irq
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1478358492-30738-8-git-send-email-robdclark@gmail.com

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 8855972303ec..8d21fb27a401 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -79,6 +79,10 @@ static char *vram = "16m";
 MODULE_PARM_DESC(vram, "Configure VRAM size (for devices without IOMMU/GPUMMU)");
 module_param(vram, charp, 0);
 
+bool dumpstate = false;
+MODULE_PARM_DESC(dumpstate, "Dump KMS state on errors");
+module_param(dumpstate, bool, 0600);
+
 /*
  * Util/helpers:
  */

commit 16976085a114ae293c6fa7a463d74600ffcfeb4b
Author: Archit Taneja <architt@codeaurora.org>
Date:   Thu Nov 3 17:36:18 2016 +0530

    drm/msm: Fix error handling crashes seen when VRAM allocation fails
    
    If VRAM allocation fails, the error handling path crashes in
    msm_drm_uninit(). The following changes are made to fix this:
    
    msm_gem_shrinker_cleanup() is fixed to unregister the shrinker only
    if it was init-ed in the first place.
    
    Before calling kms->funcs->destroy(), we check if kms->funcs is also
    non-NULL. This is needed for MDP5, since during msm_drm_int(), priv->kms
    becomes non-NULL early, but msm_kms_init() is called on it only later
    in mdp5_kms_init().
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Andy Gross <andy.gross@linaro.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index fb5c0b0a7594..46568fc80848 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -228,7 +228,7 @@ static int msm_drm_uninit(struct device *dev)
 	flush_workqueue(priv->atomic_wq);
 	destroy_workqueue(priv->atomic_wq);
 
-	if (kms)
+	if (kms && kms->funcs)
 		kms->funcs->destroy(kms);
 
 	if (gpu) {

commit 55edf41b699bcb31dcf45082d99e91b7e217206e
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Tue Nov 1 17:40:44 2016 +0200

    drm: define drm_compat_ioctl NULL on CONFIG_COMPAT=n and reduce #ifdefs
    
    If we define drm_compat_ioctl NULL on CONFIG_COMPAT=n, we don't have to
    check for the config everywhere.
    
    Reviewed-by: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1478014844-27454-1-git-send-email-jani.nikula@intel.com

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 84d38eaea585..8855972303ec 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -768,9 +768,7 @@ static const struct file_operations fops = {
 	.open               = drm_open,
 	.release            = drm_release,
 	.unlocked_ioctl     = drm_ioctl,
-#ifdef CONFIG_COMPAT
 	.compat_ioctl       = drm_compat_ioctl,
-#endif
 	.poll               = drm_poll,
 	.read               = drm_read,
 	.llseek             = no_llseek,

commit 97ac0e47aed5f635893b0e2df634c64b38ca7541
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Wed Oct 19 11:28:27 2016 +0100

    drm: convert DT component matching to component_match_add_release()
    
    Convert DT component matching to use component_match_add_release().
    
    Acked-by: Jyri Sarha <jsarha@ti.com>
    Reviewed-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/E1bwo6l-0005Io-Q1@rmk-PC.armlinux.org.uk

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index fb5c0b0a7594..84d38eaea585 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -15,6 +15,8 @@
  * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <drm/drm_of.h>
+
 #include "msm_drv.h"
 #include "msm_debugfs.h"
 #include "msm_fence.h"
@@ -919,8 +921,8 @@ static int add_components_mdp(struct device *mdp_dev,
 			continue;
 		}
 
-		component_match_add(master_dev, matchptr, compare_of, intf);
-
+		drm_of_component_match_add(master_dev, matchptr, compare_of,
+					   intf);
 		of_node_put(intf);
 		of_node_put(ep_node);
 	}
@@ -962,8 +964,8 @@ static int add_display_components(struct device *dev,
 		put_device(mdp_dev);
 
 		/* add the MDP component itself */
-		component_match_add(dev, matchptr, compare_of,
-				    mdp_dev->of_node);
+		drm_of_component_match_add(dev, matchptr, compare_of,
+					   mdp_dev->of_node);
 	} else {
 		/* MDP4 */
 		mdp_dev = dev;
@@ -996,7 +998,7 @@ static int add_gpu_components(struct device *dev,
 	if (!np)
 		return 0;
 
-	component_match_add(dev, matchptr, compare_of, np);
+	drm_of_component_match_add(dev, matchptr, compare_of, np);
 
 	of_node_put(np);
 

commit f8049dd865a1de8b494c16a4cd18ee15fa896810
Merge: 3f346d5dcb59 7a3bcc0a8e2a
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Sep 28 11:09:59 2016 +1000

    Merge branch 'msm-next' of git://people.freedesktop.org/~robclark/linux into drm-next
    
    A bit smaller pull-req this time around.  Some continued DT binding
    cleanup to get the corresponding dts bits merged upstream (through
    other trees).  And explicit fence-fd support for submit ioctl.
    
    * 'msm-next' of git://people.freedesktop.org/~robclark/linux:
      drm/msm: bump kernel api version for explicit fencing
      drm/msm: submit support for out-fences
      drm/msm: move fence allocation out of msm_gpu_submit()
      drm/msm: submit support for in-fences
      drm/msm: extend the submit ioctl to pass in flags
      drm/msm/mdp5: Set rotation property initial value to DRM_ROTATE_0 insted of 0
      drm/msm/hdmi: don't print error when adding i2c adapter fails
      drm/msm/mdp4: mark symbols static where possible
      drm/msm: Remove call to reservation_object_test_signaled_rcu before wait
      drm/msm/hdmi: Clean up HDMI gpio DT bindings
      drm/msm/mdp4: Fix issue with LCDC/LVDS port parsing

commit 0f2886057be322ddfa4858384c40a505f7a32a4a
Author: Tom Gundersen <teg@jklm.no>
Date:   Wed Sep 21 16:59:19 2016 +0200

    drm: Don't swallow error codes in drm_dev_alloc()
    
    There are many reasons other than ENOMEM that drm_dev_init() can
    fail. Return ERR_PTR rather than NULL to be able to distinguish
    these in the caller.
    
    Signed-off-by: Tom Gundersen <teg@jklm.no>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160921145919.13754-2-teg@jklm.no

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 8a0237008f74..042bde48200d 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -347,9 +347,9 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	int ret;
 
 	ddev = drm_dev_alloc(drv, dev);
-	if (!ddev) {
+	if (IS_ERR(ddev)) {
 		dev_err(dev, "failed to allocate drm_device\n");
-		return -ENOMEM;
+		return PTR_ERR(ddev);
 	}
 
 	platform_set_drvdata(pdev, ddev);

commit 7a3bcc0a8e2ad5fa7fe6d627e01c66b3488149b7
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Sep 16 18:37:44 2016 -0400

    drm/msm: bump kernel api version for explicit fencing
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 8a0237008f74..46419be5ac4b 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -26,9 +26,10 @@
  * MSM driver version:
  * - 1.0.0 - initial interface
  * - 1.1.0 - adds madvise, and support for submits with > 4 cmd buffers
+ * - 1.2.0 - adds explicit fence support for submit ioctl
  */
 #define MSM_VERSION_MAJOR	1
-#define MSM_VERSION_MINOR	1
+#define MSM_VERSION_MINOR	2
 #define MSM_VERSION_PATCHLEVEL	0
 
 static void msm_fb_output_poll_changed(struct drm_device *dev)

commit 00085f1efa387a8ce100e3734920f7639c80caa3
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Wed Aug 3 13:46:00 2016 -0700

    dma-mapping: use unsigned long for dma_attrs
    
    The dma-mapping core and the implementations do not change the DMA
    attributes passed by pointer.  Thus the pointer can point to const data.
    However the attributes do not have to be a bitfield.  Instead unsigned
    long will do fine:
    
    1. This is just simpler.  Both in terms of reading the code and setting
       attributes.  Instead of initializing local attributes on the stack
       and passing pointer to it to dma_set_attr(), just set the bits.
    
    2. It brings safeness and checking for const correctness because the
       attributes are passed by value.
    
    Semantic patches for this change (at least most of them):
    
        virtual patch
        virtual context
    
        @r@
        identifier f, attrs;
    
        @@
        f(...,
        - struct dma_attrs *attrs
        + unsigned long attrs
        , ...)
        {
        ...
        }
    
        @@
        identifier r.f;
        @@
        f(...,
        - NULL
        + 0
         )
    
    and
    
        // Options: --all-includes
        virtual patch
        virtual context
    
        @r@
        identifier f, attrs;
        type t;
    
        @@
        t f(..., struct dma_attrs *attrs);
    
        @@
        identifier r.f;
        @@
        f(...,
        - NULL
        + 0
         )
    
    Link: http://lkml.kernel.org/r/1468399300-5399-2-git-send-email-k.kozlowski@samsung.com
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Vineet Gupta <vgupta@synopsys.com>
    Acked-by: Robin Murphy <robin.murphy@arm.com>
    Acked-by: Hans-Christian Noren Egtvedt <egtvedt@samfundet.no>
    Acked-by: Mark Salter <msalter@redhat.com> [c6x]
    Acked-by: Jesper Nilsson <jesper.nilsson@axis.com> [cris]
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch> [drm]
    Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Acked-by: Joerg Roedel <jroedel@suse.de> [iommu]
    Acked-by: Fabien Dessenne <fabien.dessenne@st.com> [bdisp]
    Reviewed-by: Marek Szyprowski <m.szyprowski@samsung.com> [vb2-core]
    Acked-by: David Vrabel <david.vrabel@citrix.com> [xen]
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> [xen swiotlb]
    Acked-by: Joerg Roedel <jroedel@suse.de> [iommu]
    Acked-by: Richard Kuo <rkuo@codeaurora.org> [hexagon]
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org> [m68k]
    Acked-by: Gerald Schaefer <gerald.schaefer@de.ibm.com> [s390]
    Acked-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Acked-by: Hans-Christian Noren Egtvedt <egtvedt@samfundet.no> [avr32]
    Acked-by: Vineet Gupta <vgupta@synopsys.com> [arc]
    Acked-by: Robin Murphy <robin.murphy@arm.com> [arm64 and dma-iommu]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 26f859ec24b3..8a0237008f74 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -238,11 +238,10 @@ static int msm_drm_uninit(struct device *dev)
 	}
 
 	if (priv->vram.paddr) {
-		DEFINE_DMA_ATTRS(attrs);
-		dma_set_attr(DMA_ATTR_NO_KERNEL_MAPPING, &attrs);
+		unsigned long attrs = DMA_ATTR_NO_KERNEL_MAPPING;
 		drm_mm_takedown(&priv->vram.mm);
 		dma_free_attrs(dev, priv->vram.size, NULL,
-			       priv->vram.paddr, &attrs);
+			       priv->vram.paddr, attrs);
 	}
 
 	component_unbind_all(dev, ddev);
@@ -310,21 +309,21 @@ static int msm_init_vram(struct drm_device *dev)
 	}
 
 	if (size) {
-		DEFINE_DMA_ATTRS(attrs);
+		unsigned long attrs = 0;
 		void *p;
 
 		priv->vram.size = size;
 
 		drm_mm_init(&priv->vram.mm, 0, (size >> PAGE_SHIFT) - 1);
 
-		dma_set_attr(DMA_ATTR_NO_KERNEL_MAPPING, &attrs);
-		dma_set_attr(DMA_ATTR_WRITE_COMBINE, &attrs);
+		attrs |= DMA_ATTR_NO_KERNEL_MAPPING;
+		attrs |= DMA_ATTR_WRITE_COMBINE;
 
 		/* note that for no-kernel-mapping, the vaddr returned
 		 * is bogus, but non-null if allocation succeeded:
 		 */
 		p = dma_alloc_attrs(dev->dev, size,
-				&priv->vram.paddr, GFP_KERNEL, &attrs);
+				&priv->vram.paddr, GFP_KERNEL, attrs);
 		if (!p) {
 			dev_err(dev->dev, "failed to allocate VRAM\n");
 			priv->vram.paddr = 0;

commit 2ca41c176a5d2197572153bf543a3f758c13a4d3
Author: Peter Chen <peter.chen@nxp.com>
Date:   Mon Jul 4 16:49:50 2016 +0800

    drm/msm: add missing of_node_put after calling of_parse_phandle
    
    of_node_put needs to be called when the device node which is got
    from of_parse_phandle has finished using.
    
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    [rebased on top of Archit's DT rework, so looses one hunk]
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 9cfa348fd2bb..26f859ec24b3 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -294,6 +294,7 @@ static int msm_init_vram(struct drm_device *dev)
 	if (node) {
 		struct resource r;
 		ret = of_address_to_resource(node, 0, &r);
+		of_node_put(node);
 		if (ret)
 			return ret;
 		size = r.end - r.start;

commit a8d854c102f880984c9c21241483716ee4054ff2
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Jun 1 14:02:02 2016 -0400

    drm/msm: bump kernel api version
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index f3b8f69ea9ae..9cfa348fd2bb 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -21,6 +21,16 @@
 #include "msm_gpu.h"
 #include "msm_kms.h"
 
+
+/*
+ * MSM driver version:
+ * - 1.0.0 - initial interface
+ * - 1.1.0 - adds madvise, and support for submits with > 4 cmd buffers
+ */
+#define MSM_VERSION_MAJOR	1
+#define MSM_VERSION_MINOR	1
+#define MSM_VERSION_PATCHLEVEL	0
+
 static void msm_fb_output_poll_changed(struct drm_device *dev)
 {
 	struct msm_drm_private *priv = dev->dev_private;
@@ -807,8 +817,9 @@ static struct drm_driver msm_driver = {
 	.name               = "msm",
 	.desc               = "MSM Snapdragon DRM",
 	.date               = "20130625",
-	.major              = 1,
-	.minor              = 0,
+	.major              = MSM_VERSION_MAJOR,
+	.minor              = MSM_VERSION_MINOR,
+	.patchlevel         = MSM_VERSION_PATCHLEVEL,
 };
 
 #ifdef CONFIG_PM_SLEEP

commit 68209390f116034449fa6a3ae03f7b100b3d894a
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue May 17 16:19:32 2016 -0400

    drm/msm: shrinker support
    
    For a first step, only purge obj->madv==DONTNEED objects.  We could be
    more agressive and next try unpinning inactive objects..  but that is
    only useful if you have swap.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 00881f3ed32e..f3b8f69ea9ae 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -195,6 +195,8 @@ static int msm_drm_uninit(struct device *dev)
 		kfree(vbl_ev);
 	}
 
+	msm_gem_shrinker_cleanup(ddev);
+
 	drm_kms_helper_poll_fini(ddev);
 
 	drm_dev_unregister(ddev);
@@ -350,6 +352,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	}
 
 	ddev->dev_private = priv;
+	priv->dev = ddev;
 
 	ret = msm_mdss_init(ddev);
 	if (ret) {
@@ -382,6 +385,8 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	if (ret)
 		goto fail;
 
+	msm_gem_shrinker_init(ddev);
+
 	switch (get_mdp_ver(pdev)) {
 	case 4:
 		kms = mdp4_kms_init(ddev);

commit 4cd33c48ea25ba17e9d0383fe914c3e58b48f7dd
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue May 17 15:44:49 2016 -0400

    drm/msm: add madvise ioctl
    
    Doesn't do anything too interesting until we wire up shrinker.  Pretty
    much lifted from i915.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 435a8f90c290..00881f3ed32e 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -690,6 +690,44 @@ static int msm_ioctl_wait_fence(struct drm_device *dev, void *data,
 	return msm_wait_fence(priv->gpu->fctx, args->fence, &timeout, true);
 }
 
+static int msm_ioctl_gem_madvise(struct drm_device *dev, void *data,
+		struct drm_file *file)
+{
+	struct drm_msm_gem_madvise *args = data;
+	struct drm_gem_object *obj;
+	int ret;
+
+	switch (args->madv) {
+	case MSM_MADV_DONTNEED:
+	case MSM_MADV_WILLNEED:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = mutex_lock_interruptible(&dev->struct_mutex);
+	if (ret)
+		return ret;
+
+	obj = drm_gem_object_lookup(file, args->handle);
+	if (!obj) {
+		ret = -ENOENT;
+		goto unlock;
+	}
+
+	ret = msm_gem_madvise(obj, args->madv);
+	if (ret >= 0) {
+		args->retained = ret;
+		ret = 0;
+	}
+
+	drm_gem_object_unreference(obj);
+
+unlock:
+	mutex_unlock(&dev->struct_mutex);
+	return ret;
+}
+
 static const struct drm_ioctl_desc msm_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(MSM_GET_PARAM,    msm_ioctl_get_param,    DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(MSM_GEM_NEW,      msm_ioctl_gem_new,      DRM_AUTH|DRM_RENDER_ALLOW),
@@ -698,6 +736,7 @@ static const struct drm_ioctl_desc msm_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_FINI, msm_ioctl_gem_cpu_fini, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(MSM_GEM_SUBMIT,   msm_ioctl_gem_submit,   DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(MSM_WAIT_FENCE,   msm_ioctl_wait_fence,   DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_MADVISE,  msm_ioctl_gem_madvise,  DRM_AUTH|DRM_RENDER_ALLOW),
 };
 
 static const struct vm_operations_struct vm_ops = {

commit 96a611b54f7f0564886d64c43485402fa2530bf4
Author: Archit Taneja <architt@codeaurora.org>
Date:   Mon May 30 17:02:00 2016 +0530

    drm/msm/mdp5: Update compatible strings for MDSS/MDP5
    
    Introduce new compatible strings for the top level MDSS wrapper device,
    and the MDP5 device.
    
    Previously, the "qcom,mdp5" and "qcom,mdss_mdp" compatible strings
    were used to match the top level platform_device (which was also tied
    to the top level drm_device struct). Now, these strings are used
    to match the MDP5 platform device.
    
    Use "qcom,mdss" as the compatible string for top level MDSS device.
    This is now used to match the top level platform_device (which is
    tied to the drm_device struct).
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 66371f23cc22..435a8f90c290 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -992,10 +992,8 @@ static int msm_pdev_remove(struct platform_device *pdev)
 }
 
 static const struct of_device_id dt_match[] = {
-	{ .compatible = "qcom,mdp4", .data = (void *) 4 },	/* mdp4 */
-	{ .compatible = "qcom,mdp5", .data = (void *) 5 },	/* mdp5 */
-	/* to support downstream DT files */
-	{ .compatible = "qcom,mdss_mdp", .data = (void *) 5 },  /* mdp5 */
+	{ .compatible = "qcom,mdp4", .data = (void *)4 },	/* MDP4 */
+	{ .compatible = "qcom,mdss", .data = (void *)5 },	/* MDP5 MDSS */
 	{}
 };
 MODULE_DEVICE_TABLE(of, dt_match);

commit dc3ea265b856c11ab7f6a9c7e504f16d545f53a2
Author: Archit Taneja <architt@codeaurora.org>
Date:   Thu May 19 13:33:52 2016 +0530

    drm/msm: Drop the gpu binding
    
    The driver currently identifies the GPU components it needs by parsing
    a phandle list from the 'gpus' DT property.
    
    This isn't the right binding to go with. So, for now, just search all
    device nodes and find the gpu node we need by parsing a list of
    compatible strings.
    
    Once we know how to link the kms and gpu drivers, we'll drop this method
    and use the correct binding.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 7333efd1eae8..66371f23cc22 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -804,25 +804,6 @@ static int compare_of(struct device *dev, void *data)
 	return dev->of_node == data;
 }
 
-static int add_components(struct device *dev, struct component_match **matchptr,
-		const char *name)
-{
-	struct device_node *np = dev->of_node;
-	unsigned i;
-
-	for (i = 0; ; i++) {
-		struct device_node *node;
-
-		node = of_parse_phandle(np, name, i);
-		if (!node)
-			break;
-
-		component_match_add(dev, matchptr, compare_of, node);
-	}
-
-	return 0;
-}
-
 /*
  * Identify what components need to be added by parsing what remote-endpoints
  * our MDP output ports are connected to. In the case of LVDS on MDP4, there
@@ -939,10 +920,31 @@ static int add_display_components(struct device *dev,
 	return ret;
 }
 
+/*
+ * We don't know what's the best binding to link the gpu with the drm device.
+ * Fow now, we just hunt for all the possible gpus that we support, and add them
+ * as components.
+ */
+static const struct of_device_id msm_gpu_match[] = {
+	{ .compatible = "qcom,adreno-3xx" },
+	{ .compatible = "qcom,kgsl-3d0" },
+	{ },
+};
+
 static int add_gpu_components(struct device *dev,
 			      struct component_match **matchptr)
 {
-	return add_components(dev, matchptr, "gpus");
+	struct device_node *np;
+
+	np = of_find_matching_node(NULL, msm_gpu_match);
+	if (!np)
+		return 0;
+
+	component_match_add(dev, matchptr, compare_of, np);
+
+	of_node_put(np);
+
+	return 0;
 }
 
 static int msm_drm_bind(struct device *dev)

commit 54011e266499ec80104136bcecec5e8c7e21340c
Author: Archit Taneja <architt@codeaurora.org>
Date:   Mon Jun 6 13:45:34 2016 +0530

    drm/msm: Add components for MDP5
    
    For MDP5 based platforms, the master device isn't the MDP5 platform
    device, but the top level MDSS device, which is a parent to MDP5 and
    interface (DSI, HDMI, eDP etc) devices.
    
    In order to add components on MDP5 platforms, we first need to populate
    the MDSS children, locate the MDP5 child, and then parse its ports to
    get the display interfaces.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 73510d0cc60a..7333efd1eae8 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -834,6 +834,20 @@ static int add_components_mdp(struct device *mdp_dev,
 {
 	struct device_node *np = mdp_dev->of_node;
 	struct device_node *ep_node;
+	struct device *master_dev;
+
+	/*
+	 * on MDP4 based platforms, the MDP platform device is the component
+	 * master that adds other display interface components to itself.
+	 *
+	 * on MDP5 based platforms, the MDSS platform device is the component
+	 * master that adds MDP5 and other display interface components to
+	 * itself.
+	 */
+	if (of_device_is_compatible(np, "qcom,mdp4"))
+		master_dev = mdp_dev;
+	else
+		master_dev = mdp_dev->parent;
 
 	for_each_endpoint_of_node(np, ep_node) {
 		struct device_node *intf;
@@ -868,7 +882,7 @@ static int add_components_mdp(struct device *mdp_dev,
 			continue;
 		}
 
-		component_match_add(mdp_dev, matchptr, compare_of, intf);
+		component_match_add(master_dev, matchptr, compare_of, intf);
 
 		of_node_put(intf);
 		of_node_put(ep_node);
@@ -877,10 +891,52 @@ static int add_components_mdp(struct device *mdp_dev,
 	return 0;
 }
 
+static int compare_name_mdp(struct device *dev, void *data)
+{
+	return (strstr(dev_name(dev), "mdp") != NULL);
+}
+
 static int add_display_components(struct device *dev,
 				  struct component_match **matchptr)
 {
-	return add_components_mdp(dev, matchptr);
+	struct device *mdp_dev;
+	int ret;
+
+	/*
+	 * MDP5 based devices don't have a flat hierarchy. There is a top level
+	 * parent: MDSS, and children: MDP5, DSI, HDMI, eDP etc. Populate the
+	 * children devices, find the MDP5 node, and then add the interfaces
+	 * to our components list.
+	 */
+	if (of_device_is_compatible(dev->of_node, "qcom,mdss")) {
+		ret = of_platform_populate(dev->of_node, NULL, NULL, dev);
+		if (ret) {
+			dev_err(dev, "failed to populate children devices\n");
+			return ret;
+		}
+
+		mdp_dev = device_find_child(dev, NULL, compare_name_mdp);
+		if (!mdp_dev) {
+			dev_err(dev, "failed to find MDSS MDP node\n");
+			of_platform_depopulate(dev);
+			return -ENODEV;
+		}
+
+		put_device(mdp_dev);
+
+		/* add the MDP component itself */
+		component_match_add(dev, matchptr, compare_of,
+				    mdp_dev->of_node);
+	} else {
+		/* MDP4 */
+		mdp_dev = dev;
+	}
+
+	ret = add_components_mdp(mdp_dev, matchptr);
+	if (ret)
+		of_platform_depopulate(dev);
+
+	return ret;
 }
 
 static int add_gpu_components(struct device *dev,
@@ -928,6 +984,7 @@ static int msm_pdev_probe(struct platform_device *pdev)
 static int msm_pdev_remove(struct platform_device *pdev)
 {
 	component_master_del(&pdev->dev, &msm_drm_ops);
+	of_platform_depopulate(&pdev->dev);
 
 	return 0;
 }

commit 812070eb090350af69848f462fe5266e25c5df6e
Author: Archit Taneja <architt@codeaurora.org>
Date:   Thu May 19 10:38:39 2016 +0530

    drm/msm: Add display components by parsing MDP ports
    
    The kms driver currently identifies all the mdss components it needs by
    parsing a phandle list from the 'connectors' DT property.
    
    Instead of this, describe a list of ports that the MDP hardware provides
    to the external world. These ports are linked to external encoder
    interfaces such as DSI, HDMI. These are also the subcomponent devices
    that we need add. This description of ports complies with the generic
    graph bindings.
    
    The LVDS port is a special case since it is a part of MDP4 itself, and
    its output connects directly to the LVDS panel. In this case, we don't
    try to add it as a component.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 132c81333491..73510d0cc60a 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -823,10 +823,64 @@ static int add_components(struct device *dev, struct component_match **matchptr,
 	return 0;
 }
 
+/*
+ * Identify what components need to be added by parsing what remote-endpoints
+ * our MDP output ports are connected to. In the case of LVDS on MDP4, there
+ * is no external component that we need to add since LVDS is within MDP4
+ * itself.
+ */
+static int add_components_mdp(struct device *mdp_dev,
+			      struct component_match **matchptr)
+{
+	struct device_node *np = mdp_dev->of_node;
+	struct device_node *ep_node;
+
+	for_each_endpoint_of_node(np, ep_node) {
+		struct device_node *intf;
+		struct of_endpoint ep;
+		int ret;
+
+		ret = of_graph_parse_endpoint(ep_node, &ep);
+		if (ret) {
+			dev_err(mdp_dev, "unable to parse port endpoint\n");
+			of_node_put(ep_node);
+			return ret;
+		}
+
+		/*
+		 * The LCDC/LVDS port on MDP4 is a speacial case where the
+		 * remote-endpoint isn't a component that we need to add
+		 */
+		if (of_device_is_compatible(np, "qcom,mdp4") &&
+		    ep.port == 0) {
+			of_node_put(ep_node);
+			continue;
+		}
+
+		/*
+		 * It's okay if some of the ports don't have a remote endpoint
+		 * specified. It just means that the port isn't connected to
+		 * any external interface.
+		 */
+		intf = of_graph_get_remote_port_parent(ep_node);
+		if (!intf) {
+			of_node_put(ep_node);
+			continue;
+		}
+
+		component_match_add(mdp_dev, matchptr, compare_of, intf);
+
+		of_node_put(intf);
+		of_node_put(ep_node);
+	}
+
+	return 0;
+}
+
 static int add_display_components(struct device *dev,
 				  struct component_match **matchptr)
 {
-	return add_components(dev, matchptr, "connectors");
+	return add_components_mdp(dev, matchptr);
 }
 
 static int add_gpu_components(struct device *dev,

commit 7d526fcf205ad011c6e5bce819b2b8a1698f7152
Author: Archit Taneja <architt@codeaurora.org>
Date:   Thu May 19 10:33:57 2016 +0530

    drm/msm: Create separate funcs for adding display/gpu components
    
    Simplifies some of the code that we'll add later.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 1c1869011092..132c81333491 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -823,6 +823,18 @@ static int add_components(struct device *dev, struct component_match **matchptr,
 	return 0;
 }
 
+static int add_display_components(struct device *dev,
+				  struct component_match **matchptr)
+{
+	return add_components(dev, matchptr, "connectors");
+}
+
+static int add_gpu_components(struct device *dev,
+			      struct component_match **matchptr)
+{
+	return add_components(dev, matchptr, "gpus");
+}
+
 static int msm_drm_bind(struct device *dev)
 {
 	return msm_drm_init(dev, &msm_driver);
@@ -845,9 +857,15 @@ static const struct component_master_ops msm_drm_ops = {
 static int msm_pdev_probe(struct platform_device *pdev)
 {
 	struct component_match *match = NULL;
+	int ret;
+
+	ret = add_display_components(&pdev->dev, &match);
+	if (ret)
+		return ret;
 
-	add_components(&pdev->dev, &match, "connectors");
-	add_components(&pdev->dev, &match, "gpus");
+	ret = add_gpu_components(&pdev->dev, &match);
+	if (ret)
+		return ret;
 
 	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
 	return component_master_add_with_match(&pdev->dev, &msm_drm_ops, match);

commit cd79272696ef21fb03d8b140c4530ac6b049e417
Author: Archit Taneja <architt@codeaurora.org>
Date:   Wed Jun 15 18:04:31 2016 +0530

    drm/msm: Call pm_runtime_enable/disable for newly created devices
    
    With the new device hierarchy for MDP5, we need to enable runtime PM
    for both the toplevel MDSS device and the MDP5 device itself. Enable
    runtime PM for the new devices.
    
    Since MDP4 and MDP5 now have different places where runtime PM is
    enabled, remove the previous pm_runtime_enable/disable calls, and
    squash them in the respective kms drivers.
    
    The new device hierarchy (as expressed in the DT bindings) has the GDSC
    tied only to the MDSS wrapper device. This GDSC needs to be enabled for
    accessing any register in the MDSS sub-blocks. Once every driver is
    runtime adapted, the GDSC will be enabled when any sub-block device
    calls runtime_get because of the parent-child relationship with MDSS.
    
    Until then, we call pm_runtime_get_sync() once for the MDSS device to
    ensure the GDSC is never disabled. This will be removed once all the
    drivers are runtime PM adapted.
    
    The error handling paths become a bit tricky when we call these runtime
    PM funcs. There doesn't seem to be any helper that checks if runtime PM
    is enabled already. Add bool variables in mdp4_kms/mdp5_kms structs to
    check if the driver had managed to call pm_runtime_enable before bailing
    out.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index d650aaca60f8..1c1869011092 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -215,10 +215,8 @@ static int msm_drm_uninit(struct device *dev)
 	flush_workqueue(priv->atomic_wq);
 	destroy_workqueue(priv->atomic_wq);
 
-	if (kms) {
-		pm_runtime_disable(dev);
+	if (kms)
 		kms->funcs->destroy(kms);
-	}
 
 	if (gpu) {
 		mutex_lock(&ddev->struct_mutex);
@@ -410,7 +408,6 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	}
 
 	if (kms) {
-		pm_runtime_enable(dev);
 		ret = kms->funcs->hw_init(kms);
 		if (ret) {
 			dev_err(dev, "kms hw init failed: %d\n", ret);

commit 392ae6e0efa5e27e977b1cdf88c619c0434a7417
Author: Archit Taneja <architt@codeaurora.org>
Date:   Tue Jun 14 18:24:54 2016 +0530

    drm/msm/mdp5: Remove old kms init/destroy funcs
    
    With the new kms_init/destroy funcs in place for MDP5, we can get rid of
    the old kms funcs. Some members of the mdp5_kms struct also become
    redundant, so we remove those too.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 517f0ae51335..d650aaca60f8 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -390,7 +390,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 		priv->kms = kms;
 		break;
 	case 5:
-		kms = mdp5_kms_init2(ddev);
+		kms = mdp5_kms_init(ddev);
 		break;
 	default:
 		kms = ERR_PTR(-ENODEV);

commit 0a6030d224d3a446624a06e2858a69974738bd2a
Author: Archit Taneja <architt@codeaurora.org>
Date:   Sun May 8 21:36:28 2016 +0530

    drm/msm/mdp5: Use the new hierarchy and drop old irq management
    
    Call msm_mdss_init in msm_drv to set up top level registers/irq line.
    Start using the new kms_init2/destroy2 funcs to inititalize MDP5 KMS.
    
    With the MDSS interrupt and irqdomain set up, the old MDP5 irq code
    can be dropped.
    
    The mdp5_hw_init kms func now uses the platform device tied to MDP5
    instead of the one tied to the drm_device/MDSS.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 570139234210..517f0ae51335 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -237,6 +237,8 @@ static int msm_drm_uninit(struct device *dev)
 
 	component_unbind_all(dev, ddev);
 
+	msm_mdss_destroy(ddev);
+
 	ddev->dev_private = NULL;
 	drm_dev_unref(ddev);
 
@@ -351,6 +353,13 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 
 	ddev->dev_private = priv;
 
+	ret = msm_mdss_init(ddev);
+	if (ret) {
+		kfree(priv);
+		drm_dev_unref(ddev);
+		return ret;
+	}
+
 	priv->wq = alloc_ordered_workqueue("msm", 0);
 	priv->atomic_wq = alloc_ordered_workqueue("msm:atomic", 0);
 	init_waitqueue_head(&priv->pending_crtcs_event);
@@ -365,6 +374,7 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	/* Bind all our sub-components: */
 	ret = component_bind_all(dev, ddev);
 	if (ret) {
+		msm_mdss_destroy(ddev);
 		kfree(priv);
 		drm_dev_unref(ddev);
 		return ret;
@@ -377,9 +387,10 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	switch (get_mdp_ver(pdev)) {
 	case 4:
 		kms = mdp4_kms_init(ddev);
+		priv->kms = kms;
 		break;
 	case 5:
-		kms = mdp5_kms_init(ddev);
+		kms = mdp5_kms_init2(ddev);
 		break;
 	default:
 		kms = ERR_PTR(-ENODEV);
@@ -398,8 +409,6 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 		goto fail;
 	}
 
-	priv->kms = kms;
-
 	if (kms) {
 		pm_runtime_enable(dev);
 		ret = kms->funcs->hw_init(kms);

commit 1dd0a0b18697e59c0928cea41b7e922e80d7d246
Author: Archit Taneja <architt@codeaurora.org>
Date:   Mon May 30 16:36:50 2016 +0530

    drm/msm/mdp5: Create a separate MDP5 device
    
    In order to have a tree-like device hierarchy between MDSS and its
    sub-blocks (MDP5, DSI, HDMI, eDP etc), we need to create a separate
    device/driver for MDP5. Currently, MDP5 and MDSS are squashed
    together are are tied to the top level platform_device, which is
    also the one used to create drm_device.
    
    The mdp5_kms_init code is split into two parts. The part where device
    resources are allocated are associated with the MDP5 driver's probe,
    the rest is executed later when we initialize modeset.
    
    With this change, unlike MDP4, the MDP5 platform_device isn't tied to
    the top level drm_device anymore. The top level drm_device is now
    associated with a platform device that corresponds to MDSS wrapper
    hardware.
    
    Create mdp5_init/destroy funcs that will be used by the MDP5 driver
    probe/remove. Use the HW_VERSION register in the MDP5 register address
    space. Both the MDSS and MDP VERSION registers give out identical
    version info.
    
    The older mdp5_kms_init code is left as is for now, this would be removed
    later when we have all the pieces to support the new device hierarchy.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 092926b35baf..570139234210 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -876,6 +876,7 @@ static struct platform_driver msm_platform_driver = {
 static int __init msm_drm_register(void)
 {
 	DBG("init");
+	msm_mdp_register();
 	msm_dsi_register();
 	msm_edp_register();
 	msm_hdmi_register();
@@ -891,6 +892,7 @@ static void __exit msm_drm_unregister(void)
 	adreno_unregister();
 	msm_edp_unregister();
 	msm_dsi_unregister();
+	msm_mdp_unregister();
 }
 
 module_init(msm_drm_register);

commit a2b3a5571f386e23b56164396292675bac6f2a19
Author: Archit Taneja <architt@codeaurora.org>
Date:   Wed May 18 15:06:03 2016 +0530

    drm/msm: Get irq number within kms driver itself
    
    The driver gets the irq number using platform_get_irq on the main kms
    platform device. This works fine since both MDP4 and MDP5 currently
    have a flat device hierarchy. The platform device tied with the
    drm_device points to the MDP DT node in both cases.
    
    This won't work when MDP5 supports a tree-like hierarchy. In this
    case, the platform device tied to the top level drm_device is the
    MDSS DT node, and the irq we need for KMS is the one generated by
    MDP5, not MDSS.
    
    Get the irq number from the MDP4/5 kms driver itself. Each driver
    can later provide the irq number based on what device hierarchy it
    uses.
    
    While we're at it, call drm_irq_install only when we have a valid KMS
    driver.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 476eafef7add..092926b35baf 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -417,12 +417,14 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 		goto fail;
 	}
 
-	pm_runtime_get_sync(dev);
-	ret = drm_irq_install(ddev, platform_get_irq(pdev, 0));
-	pm_runtime_put_sync(dev);
-	if (ret < 0) {
-		dev_err(dev, "failed to install IRQ handler\n");
-		goto fail;
+	if (kms) {
+		pm_runtime_get_sync(dev);
+		ret = drm_irq_install(ddev, kms->irq);
+		pm_runtime_put_sync(dev);
+		if (ret < 0) {
+			dev_err(dev, "failed to install IRQ handler\n");
+			goto fail;
+		}
 	}
 
 	ret = drm_dev_register(ddev, 0);

commit 6a5625d82704b1777696048e837c51418cfad1d8
Author: Archit Taneja <architt@codeaurora.org>
Date:   Thu May 5 21:26:34 2016 +0530

    drm/msm: Drop the id_table in platform_driver
    
    This isn't needed as we only support OF.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index a02dc2b27739..476eafef7add 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -852,11 +852,6 @@ static int msm_pdev_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static const struct platform_device_id msm_id[] = {
-	{ "mdp", 0 },
-	{ }
-};
-
 static const struct of_device_id dt_match[] = {
 	{ .compatible = "qcom,mdp4", .data = (void *) 4 },	/* mdp4 */
 	{ .compatible = "qcom,mdp5", .data = (void *) 5 },	/* mdp5 */
@@ -874,7 +869,6 @@ static struct platform_driver msm_platform_driver = {
 		.of_match_table = dt_match,
 		.pm     = &msm_pm_ops,
 	},
-	.id_table   = msm_id,
 };
 
 static int __init msm_drm_register(void)

commit a325725633c26aa66ab940f762a6b0778edf76c0
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jun 21 14:08:33 2016 +0200

    drm: Lobotomize set_busid nonsense for !pci drivers
    
    We already have a fallback in place to fill out the unique from
    dev->unique, which is set to something reasonable in drm_dev_alloc.
    
    Which means we only need to have a special set_busid for pci devices,
    to be able to care the backwards compat code for drm 1.1 around, which
    libdrm still needs.
    
    While developing and testing this patch things blew up in really
    interesting ways, and the code is rather confusing in naming things
    between the kernel code, ioctl #defines and libdrm. For the next brave
    dragon slayer, document all this madness properly in the userspace
    interface section of gpu.tmpl.
    
    v2: Make drm_dev_set_unique static and update kerneldoc.
    
    v3: Entire rewrite, plus document what's going on for posterity in the
    gpu docbook uapi section.
    
    v4: Drop accidental amdgpu hunk (Emil).
    
    v5: Drop accidental omapdrm vblank counter change (Emil).
    
    v6: Rebase on top of the sphinx conversion.
    
    Cc: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Cc: Emil Velikov <emil.l.velikov@gmail.com>
    Tested-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk> (virt_gpu)
    Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 568fcc328f27..a02dc2b27739 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -722,7 +722,6 @@ static struct drm_driver msm_driver = {
 	.open               = msm_open,
 	.preclose           = msm_preclose,
 	.lastclose          = msm_lastclose,
-	.set_busid          = drm_platform_set_busid,
 	.irq_handler        = msm_irq,
 	.irq_preinstall     = msm_irq_preinstall,
 	.irq_postinstall    = msm_irq_postinstall,

commit 8c2d8ed95f496dacbd6a06fdfe0ebb9a704299b4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jun 17 09:25:22 2016 +0100

    drm/msm: Remove redundant calls to drm_connector_register_all()
    
    Up to now, the recommendation was for drivers to call drm_dev_register()
    followed by drm_connector_register_all(). Now that
    drm_connector_register() is safe against multiple invocations, we can
    move drm_connector_register_all() to drm_dev_register() and not suffer
    from any backwards compatibility issues with drivers not following the
    more rigorous init ordering.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: dri-devel@lists.freedesktop.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Tested-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1466151923-1572-7-git-send-email-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 9c654092ef78..568fcc328f27 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -197,8 +197,6 @@ static int msm_drm_uninit(struct device *dev)
 
 	drm_kms_helper_poll_fini(ddev);
 
-	drm_connector_unregister_all(ddev);
-
 	drm_dev_unregister(ddev);
 
 #ifdef CONFIG_DRM_FBDEV_EMULATION
@@ -431,12 +429,6 @@ static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 	if (ret)
 		goto fail;
 
-	ret = drm_connector_register_all(ddev);
-	if (ret) {
-		dev_err(dev, "failed to register connectors\n");
-		goto fail;
-	}
-
 	drm_mode_config_reset(ddev);
 
 #ifdef CONFIG_DRM_FBDEV_EMULATION

commit a8ad0bd84f986072314595d05444719fdf29e412
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon May 9 11:04:54 2016 +0100

    drm: Remove unused drm_device from drm_gem_object_lookup()
    
    drm_gem_object_lookup() has never required the drm_device for its file
    local translation of the user handle to the GEM object. Let's remove the
    unused parameter and save some space.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: dri-devel@lists.freedesktop.org
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    [danvet: Fixup kerneldoc too.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 9788989ea21c..9c654092ef78 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -622,7 +622,7 @@ static int msm_ioctl_gem_cpu_prep(struct drm_device *dev, void *data,
 		return -EINVAL;
 	}
 
-	obj = drm_gem_object_lookup(dev, file, args->handle);
+	obj = drm_gem_object_lookup(file, args->handle);
 	if (!obj)
 		return -ENOENT;
 
@@ -640,7 +640,7 @@ static int msm_ioctl_gem_cpu_fini(struct drm_device *dev, void *data,
 	struct drm_gem_object *obj;
 	int ret;
 
-	obj = drm_gem_object_lookup(dev, file, args->handle);
+	obj = drm_gem_object_lookup(file, args->handle);
 	if (!obj)
 		return -ENOENT;
 
@@ -661,7 +661,7 @@ static int msm_ioctl_gem_info(struct drm_device *dev, void *data,
 	if (args->pad)
 		return -EINVAL;
 
-	obj = drm_gem_object_lookup(dev, file, args->handle);
+	obj = drm_gem_object_lookup(file, args->handle);
 	if (!obj)
 		return -ENOENT;
 

commit 2b669875332fbdff0a7ad559e8662e875e7a1526
Author: Archit Taneja <architt@codeaurora.org>
Date:   Mon May 2 11:05:54 2016 +0530

    drm/msm: Drop load/unload drm_driver ops
    
    The load/unload drm_driver ops are deprecated. They should be removed as
    they result in creation of devices visible to userspace even before
    the drm_device is registered.
    
    Drop these ops and use drm_dev_alloc/register and drm_dev_unregister/unref
    to explicitly create and destroy the drm device in the msm platform
    driver's bind and unbind ops. With this in use, the drm connectors are
    only registered once the drm_device is registered.
    
    It also fixes the issue of stray debugfs files after the msm module is
    removed. With this, all the debugfs files are removed, and allows
    successive module insertions/removals.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 336070d5eadc..9788989ea21c 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -175,13 +175,11 @@ static int vblank_ctrl_queue_work(struct msm_drm_private *priv,
 	return 0;
 }
 
-/*
- * DRM operations:
- */
-
-static int msm_unload(struct drm_device *dev)
+static int msm_drm_uninit(struct device *dev)
 {
-	struct msm_drm_private *priv = dev->dev_private;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct drm_device *ddev = platform_get_drvdata(pdev);
+	struct msm_drm_private *priv = ddev->dev_private;
 	struct msm_kms *kms = priv->kms;
 	struct msm_gpu *gpu = priv->gpu;
 	struct msm_vblank_ctrl *vbl_ctrl = &priv->vblank_ctrl;
@@ -197,20 +195,21 @@ static int msm_unload(struct drm_device *dev)
 		kfree(vbl_ev);
 	}
 
-	drm_kms_helper_poll_fini(dev);
+	drm_kms_helper_poll_fini(ddev);
+
+	drm_connector_unregister_all(ddev);
 
-	drm_connector_unregister_all(dev);
+	drm_dev_unregister(ddev);
 
 #ifdef CONFIG_DRM_FBDEV_EMULATION
 	if (fbdev && priv->fbdev)
-		msm_fbdev_free(dev);
+		msm_fbdev_free(ddev);
 #endif
-	drm_mode_config_cleanup(dev);
-	drm_vblank_cleanup(dev);
+	drm_mode_config_cleanup(ddev);
 
-	pm_runtime_get_sync(dev->dev);
-	drm_irq_uninstall(dev);
-	pm_runtime_put_sync(dev->dev);
+	pm_runtime_get_sync(dev);
+	drm_irq_uninstall(ddev);
+	pm_runtime_put_sync(dev);
 
 	flush_workqueue(priv->wq);
 	destroy_workqueue(priv->wq);
@@ -219,14 +218,14 @@ static int msm_unload(struct drm_device *dev)
 	destroy_workqueue(priv->atomic_wq);
 
 	if (kms) {
-		pm_runtime_disable(dev->dev);
+		pm_runtime_disable(dev);
 		kms->funcs->destroy(kms);
 	}
 
 	if (gpu) {
-		mutex_lock(&dev->struct_mutex);
+		mutex_lock(&ddev->struct_mutex);
 		gpu->funcs->pm_suspend(gpu);
-		mutex_unlock(&dev->struct_mutex);
+		mutex_unlock(&ddev->struct_mutex);
 		gpu->funcs->destroy(gpu);
 	}
 
@@ -234,13 +233,14 @@ static int msm_unload(struct drm_device *dev)
 		DEFINE_DMA_ATTRS(attrs);
 		dma_set_attr(DMA_ATTR_NO_KERNEL_MAPPING, &attrs);
 		drm_mm_takedown(&priv->vram.mm);
-		dma_free_attrs(dev->dev, priv->vram.size, NULL,
-				priv->vram.paddr, &attrs);
+		dma_free_attrs(dev, priv->vram.size, NULL,
+			       priv->vram.paddr, &attrs);
 	}
 
-	component_unbind_all(dev->dev, dev);
+	component_unbind_all(dev, ddev);
 
-	dev->dev_private = NULL;
+	ddev->dev_private = NULL;
+	drm_dev_unref(ddev);
 
 	kfree(priv);
 
@@ -328,20 +328,30 @@ static int msm_init_vram(struct drm_device *dev)
 	return ret;
 }
 
-static int msm_load(struct drm_device *dev, unsigned long flags)
+static int msm_drm_init(struct device *dev, struct drm_driver *drv)
 {
-	struct platform_device *pdev = dev->platformdev;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct drm_device *ddev;
 	struct msm_drm_private *priv;
 	struct msm_kms *kms;
 	int ret;
 
+	ddev = drm_dev_alloc(drv, dev);
+	if (!ddev) {
+		dev_err(dev, "failed to allocate drm_device\n");
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, ddev);
+	ddev->platformdev = pdev;
+
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv) {
-		dev_err(dev->dev, "failed to allocate private data\n");
+		drm_dev_unref(ddev);
 		return -ENOMEM;
 	}
 
-	dev->dev_private = priv;
+	ddev->dev_private = priv;
 
 	priv->wq = alloc_ordered_workqueue("msm", 0);
 	priv->atomic_wq = alloc_ordered_workqueue("msm:atomic", 0);
@@ -352,25 +362,26 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 	INIT_WORK(&priv->vblank_ctrl.work, vblank_ctrl_worker);
 	spin_lock_init(&priv->vblank_ctrl.lock);
 
-	drm_mode_config_init(dev);
-
-	platform_set_drvdata(pdev, dev);
+	drm_mode_config_init(ddev);
 
 	/* Bind all our sub-components: */
-	ret = component_bind_all(dev->dev, dev);
-	if (ret)
+	ret = component_bind_all(dev, ddev);
+	if (ret) {
+		kfree(priv);
+		drm_dev_unref(ddev);
 		return ret;
+	}
 
-	ret = msm_init_vram(dev);
+	ret = msm_init_vram(ddev);
 	if (ret)
 		goto fail;
 
 	switch (get_mdp_ver(pdev)) {
 	case 4:
-		kms = mdp4_kms_init(dev);
+		kms = mdp4_kms_init(ddev);
 		break;
 	case 5:
-		kms = mdp5_kms_init(dev);
+		kms = mdp5_kms_init(ddev);
 		break;
 	default:
 		kms = ERR_PTR(-ENODEV);
@@ -384,7 +395,7 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 		 * and (for example) use dmabuf/prime to share buffers with
 		 * imx drm driver on iMX5
 		 */
-		dev_err(dev->dev, "failed to load kms\n");
+		dev_err(dev, "failed to load kms\n");
 		ret = PTR_ERR(kms);
 		goto fail;
 	}
@@ -392,56 +403,64 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 	priv->kms = kms;
 
 	if (kms) {
-		pm_runtime_enable(dev->dev);
+		pm_runtime_enable(dev);
 		ret = kms->funcs->hw_init(kms);
 		if (ret) {
-			dev_err(dev->dev, "kms hw init failed: %d\n", ret);
+			dev_err(dev, "kms hw init failed: %d\n", ret);
 			goto fail;
 		}
 	}
 
-	dev->mode_config.funcs = &mode_config_funcs;
+	ddev->mode_config.funcs = &mode_config_funcs;
 
-	ret = drm_vblank_init(dev, priv->num_crtcs);
+	ret = drm_vblank_init(ddev, priv->num_crtcs);
 	if (ret < 0) {
-		dev_err(dev->dev, "failed to initialize vblank\n");
+		dev_err(dev, "failed to initialize vblank\n");
 		goto fail;
 	}
 
-	pm_runtime_get_sync(dev->dev);
-	ret = drm_irq_install(dev, platform_get_irq(dev->platformdev, 0));
-	pm_runtime_put_sync(dev->dev);
+	pm_runtime_get_sync(dev);
+	ret = drm_irq_install(ddev, platform_get_irq(pdev, 0));
+	pm_runtime_put_sync(dev);
 	if (ret < 0) {
-		dev_err(dev->dev, "failed to install IRQ handler\n");
+		dev_err(dev, "failed to install IRQ handler\n");
 		goto fail;
 	}
 
-	ret = drm_connector_register_all(dev);
+	ret = drm_dev_register(ddev, 0);
+	if (ret)
+		goto fail;
+
+	ret = drm_connector_register_all(ddev);
 	if (ret) {
-		dev_err(dev->dev, "failed to register connectors\n");
+		dev_err(dev, "failed to register connectors\n");
 		goto fail;
 	}
 
-	drm_mode_config_reset(dev);
+	drm_mode_config_reset(ddev);
 
 #ifdef CONFIG_DRM_FBDEV_EMULATION
 	if (fbdev)
-		priv->fbdev = msm_fbdev_init(dev);
+		priv->fbdev = msm_fbdev_init(ddev);
 #endif
 
-	ret = msm_debugfs_late_init(dev);
+	ret = msm_debugfs_late_init(ddev);
 	if (ret)
 		goto fail;
 
-	drm_kms_helper_poll_init(dev);
+	drm_kms_helper_poll_init(ddev);
 
 	return 0;
 
 fail:
-	msm_unload(dev);
+	msm_drm_uninit(dev);
 	return ret;
 }
 
+/*
+ * DRM operations:
+ */
+
 static void load_gpu(struct drm_device *dev)
 {
 	static DEFINE_MUTEX(init_lock);
@@ -708,8 +727,6 @@ static struct drm_driver msm_driver = {
 				DRIVER_RENDER |
 				DRIVER_ATOMIC |
 				DRIVER_MODESET,
-	.load               = msm_load,
-	.unload             = msm_unload,
 	.open               = msm_open,
 	.preclose           = msm_preclose,
 	.lastclose          = msm_lastclose,
@@ -809,12 +826,12 @@ static int add_components(struct device *dev, struct component_match **matchptr,
 
 static int msm_drm_bind(struct device *dev)
 {
-	return drm_platform_init(&msm_driver, to_platform_device(dev));
+	return msm_drm_init(dev, &msm_driver);
 }
 
 static void msm_drm_unbind(struct device *dev)
 {
-	drm_put_dev(platform_get_drvdata(to_platform_device(dev)));
+	msm_drm_uninit(dev);
 }
 
 static const struct component_master_ops msm_drm_ops = {

commit 8208ed931eea9b00a3b29c9ef36da382b5480881
Author: Archit Taneja <architt@codeaurora.org>
Date:   Mon May 2 11:05:53 2016 +0530

    drm/msm: Centralize connector registration/unregistration
    
    Move the drm_connector registration from the encoder(HDMI/DSI etc) drivers
    to the msm platform driver. This will simplify the task of ensuring that
    the connectors are registered only after the drm_device itself is
    registered.
    
    The connectors' destroy ops are made to use kzalloc instead of
    devm_kzalloc to ensure that that the connectors can be successfully
    unregistered when the msm driver module is removed. The memory for the
    connectors is unallocated when drm_mode_config_cleanup() is called
    during either during an error or during driver remove.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index c257cdd346e7..336070d5eadc 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -199,6 +199,8 @@ static int msm_unload(struct drm_device *dev)
 
 	drm_kms_helper_poll_fini(dev);
 
+	drm_connector_unregister_all(dev);
+
 #ifdef CONFIG_DRM_FBDEV_EMULATION
 	if (fbdev && priv->fbdev)
 		msm_fbdev_free(dev);
@@ -414,6 +416,12 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 		goto fail;
 	}
 
+	ret = drm_connector_register_all(dev);
+	if (ret) {
+		dev_err(dev->dev, "failed to register connectors\n");
+		goto fail;
+	}
+
 	drm_mode_config_reset(dev);
 
 #ifdef CONFIG_DRM_FBDEV_EMULATION

commit 6979cd54c0667189bb0805c0fcebfef8afc5a191
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Apr 16 22:41:46 2016 +0200

    drm: msm: remove unused variable
    
    A recent cleanup removed the only user of the 'kms' variable in
    msm_preclose(), causing a harmless compiler warning:
    
    drivers/gpu/drm/msm/msm_drv.c: In function 'msm_preclose':
    drivers/gpu/drm/msm/msm_drv.c:468:18: error: unused variable 'kms' [-Werror=unused-variable]
    
    This removes the variable as well.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: 4016260ba47a ("drm/msm: fix bug after preclose removal")
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 745793991ba6..c257cdd346e7 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -469,7 +469,6 @@ static void msm_preclose(struct drm_device *dev, struct drm_file *file)
 {
 	struct msm_drm_private *priv = dev->dev_private;
 	struct msm_file_private *ctx = file->driver_priv;
-	struct msm_kms *kms = priv->kms;
 
 	mutex_lock(&dev->struct_mutex);
 	if (ctx == priv->lastctx)

commit ba00c3f2f0c84456ffe9d548823ff4fb8e4e7ed4
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Mar 16 18:18:17 2016 -0400

    drm/msm: remove fence_cbs
    
    This was only used for atomic commit these days.  So instead just give
    atomic it's own work-queue where we can do a block on each bo in turn.
    Simplifies things a whole bunch and makes the 'struct fence' conversion
    easier.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 2b859f38772a..745793991ba6 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -213,6 +213,9 @@ static int msm_unload(struct drm_device *dev)
 	flush_workqueue(priv->wq);
 	destroy_workqueue(priv->wq);
 
+	flush_workqueue(priv->atomic_wq);
+	destroy_workqueue(priv->atomic_wq);
+
 	if (kms) {
 		pm_runtime_disable(dev->dev);
 		kms->funcs->destroy(kms);
@@ -339,6 +342,7 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 	dev->dev_private = priv;
 
 	priv->wq = alloc_ordered_workqueue("msm", 0);
+	priv->atomic_wq = alloc_ordered_workqueue("msm:atomic", 0);
 	init_waitqueue_head(&priv->pending_crtcs_event);
 
 	INIT_LIST_HEAD(&priv->inactive_list);

commit ca762a8ae7f453978a4769af9dcd3cb08e45b932
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Mar 15 17:22:13 2016 -0400

    drm/msm: introduce msm_fence_context
    
    Better encapsulate the per-timeline stuff into fence-context.  For now
    there is just a single fence-context, but eventually we'll also have one
    per-CRTC to enable fully explicit fencing.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index d4a1a11ccc43..2b859f38772a 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -339,11 +339,9 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 	dev->dev_private = priv;
 
 	priv->wq = alloc_ordered_workqueue("msm", 0);
-	init_waitqueue_head(&priv->fence_event);
 	init_waitqueue_head(&priv->pending_crtcs_event);
 
 	INIT_LIST_HEAD(&priv->inactive_list);
-	INIT_LIST_HEAD(&priv->fence_cbs);
 	INIT_LIST_HEAD(&priv->vblank_ctrl.event_list);
 	INIT_WORK(&priv->vblank_ctrl.work, vblank_ctrl_worker);
 	spin_lock_init(&priv->vblank_ctrl.lock);
@@ -647,6 +645,7 @@ static int msm_ioctl_gem_info(struct drm_device *dev, void *data,
 static int msm_ioctl_wait_fence(struct drm_device *dev, void *data,
 		struct drm_file *file)
 {
+	struct msm_drm_private *priv = dev->dev_private;
 	struct drm_msm_wait_fence *args = data;
 	ktime_t timeout = to_ktime(args->timeout);
 
@@ -655,7 +654,10 @@ static int msm_ioctl_wait_fence(struct drm_device *dev, void *data,
 		return -EINVAL;
 	}
 
-	return msm_wait_fence(dev, args->fence, &timeout, true);
+	if (!priv->gpu)
+		return 0;
+
+	return msm_wait_fence(priv->gpu->fctx, args->fence, &timeout, true);
 }
 
 static const struct drm_ioctl_desc msm_ioctls[] = {

commit fde5de6cb4617a160a6cc5c034284618350c2961
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Mar 15 15:35:08 2016 -0400

    drm/msm: move fence code to it's own file
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index c0467f90af02..d4a1a11ccc43 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -17,6 +17,7 @@
 
 #include "msm_drv.h"
 #include "msm_debugfs.h"
+#include "msm_fence.h"
 #include "msm_gpu.h"
 #include "msm_kms.h"
 
@@ -536,113 +537,6 @@ static void msm_disable_vblank(struct drm_device *dev, unsigned int pipe)
 	vblank_ctrl_queue_work(priv, pipe, false);
 }
 
-/*
- * Fences:
- */
-
-int msm_wait_fence(struct drm_device *dev, uint32_t fence,
-		ktime_t *timeout , bool interruptible)
-{
-	struct msm_drm_private *priv = dev->dev_private;
-	int ret;
-
-	if (!priv->gpu)
-		return 0;
-
-	if (fence > priv->gpu->submitted_fence) {
-		DRM_ERROR("waiting on invalid fence: %u (of %u)\n",
-				fence, priv->gpu->submitted_fence);
-		return -EINVAL;
-	}
-
-	if (!timeout) {
-		/* no-wait: */
-		ret = fence_completed(dev, fence) ? 0 : -EBUSY;
-	} else {
-		ktime_t now = ktime_get();
-		unsigned long remaining_jiffies;
-
-		if (ktime_compare(*timeout, now) < 0) {
-			remaining_jiffies = 0;
-		} else {
-			ktime_t rem = ktime_sub(*timeout, now);
-			struct timespec ts = ktime_to_timespec(rem);
-			remaining_jiffies = timespec_to_jiffies(&ts);
-		}
-
-		if (interruptible)
-			ret = wait_event_interruptible_timeout(priv->fence_event,
-				fence_completed(dev, fence),
-				remaining_jiffies);
-		else
-			ret = wait_event_timeout(priv->fence_event,
-				fence_completed(dev, fence),
-				remaining_jiffies);
-
-		if (ret == 0) {
-			DBG("timeout waiting for fence: %u (completed: %u)",
-					fence, priv->completed_fence);
-			ret = -ETIMEDOUT;
-		} else if (ret != -ERESTARTSYS) {
-			ret = 0;
-		}
-	}
-
-	return ret;
-}
-
-int msm_queue_fence_cb(struct drm_device *dev,
-		struct msm_fence_cb *cb, uint32_t fence)
-{
-	struct msm_drm_private *priv = dev->dev_private;
-	int ret = 0;
-
-	mutex_lock(&dev->struct_mutex);
-	if (!list_empty(&cb->work.entry)) {
-		ret = -EINVAL;
-	} else if (fence > priv->completed_fence) {
-		cb->fence = fence;
-		list_add_tail(&cb->work.entry, &priv->fence_cbs);
-	} else {
-		queue_work(priv->wq, &cb->work);
-	}
-	mutex_unlock(&dev->struct_mutex);
-
-	return ret;
-}
-
-/* called from workqueue */
-void msm_update_fence(struct drm_device *dev, uint32_t fence)
-{
-	struct msm_drm_private *priv = dev->dev_private;
-
-	mutex_lock(&dev->struct_mutex);
-	priv->completed_fence = max(fence, priv->completed_fence);
-
-	while (!list_empty(&priv->fence_cbs)) {
-		struct msm_fence_cb *cb;
-
-		cb = list_first_entry(&priv->fence_cbs,
-				struct msm_fence_cb, work.entry);
-
-		if (cb->fence > priv->completed_fence)
-			break;
-
-		list_del_init(&cb->work.entry);
-		queue_work(priv->wq, &cb->work);
-	}
-
-	mutex_unlock(&dev->struct_mutex);
-
-	wake_up_all(&priv->fence_event);
-}
-
-void __msm_fence_worker(struct work_struct *work)
-{
-	struct msm_fence_cb *cb = container_of(work, struct msm_fence_cb, work);
-	cb->func(cb);
-}
-
 /*
  * DRM ioctls:
  */

commit edcd60ce243d16f1b50dacb8f0643308b23f1070
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Mar 16 12:56:12 2016 -0400

    drm/msm: move debugfs code to it's own file
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index c03b96709179..c0467f90af02 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -16,6 +16,7 @@
  */
 
 #include "msm_drv.h"
+#include "msm_debugfs.h"
 #include "msm_gpu.h"
 #include "msm_kms.h"
 
@@ -535,158 +536,6 @@ static void msm_disable_vblank(struct drm_device *dev, unsigned int pipe)
 	vblank_ctrl_queue_work(priv, pipe, false);
 }
 
-/*
- * DRM debugfs:
- */
-
-#ifdef CONFIG_DEBUG_FS
-static int msm_gpu_show(struct drm_device *dev, struct seq_file *m)
-{
-	struct msm_drm_private *priv = dev->dev_private;
-	struct msm_gpu *gpu = priv->gpu;
-
-	if (gpu) {
-		seq_printf(m, "%s Status:\n", gpu->name);
-		gpu->funcs->show(gpu, m);
-	}
-
-	return 0;
-}
-
-static int msm_gem_show(struct drm_device *dev, struct seq_file *m)
-{
-	struct msm_drm_private *priv = dev->dev_private;
-	struct msm_gpu *gpu = priv->gpu;
-
-	if (gpu) {
-		seq_printf(m, "Active Objects (%s):\n", gpu->name);
-		msm_gem_describe_objects(&gpu->active_list, m);
-	}
-
-	seq_printf(m, "Inactive Objects:\n");
-	msm_gem_describe_objects(&priv->inactive_list, m);
-
-	return 0;
-}
-
-static int msm_mm_show(struct drm_device *dev, struct seq_file *m)
-{
-	return drm_mm_dump_table(m, &dev->vma_offset_manager->vm_addr_space_mm);
-}
-
-static int msm_fb_show(struct drm_device *dev, struct seq_file *m)
-{
-	struct msm_drm_private *priv = dev->dev_private;
-	struct drm_framebuffer *fb, *fbdev_fb = NULL;
-
-	if (priv->fbdev) {
-		seq_printf(m, "fbcon ");
-		fbdev_fb = priv->fbdev->fb;
-		msm_framebuffer_describe(fbdev_fb, m);
-	}
-
-	mutex_lock(&dev->mode_config.fb_lock);
-	list_for_each_entry(fb, &dev->mode_config.fb_list, head) {
-		if (fb == fbdev_fb)
-			continue;
-
-		seq_printf(m, "user ");
-		msm_framebuffer_describe(fb, m);
-	}
-	mutex_unlock(&dev->mode_config.fb_lock);
-
-	return 0;
-}
-
-static int show_locked(struct seq_file *m, void *arg)
-{
-	struct drm_info_node *node = (struct drm_info_node *) m->private;
-	struct drm_device *dev = node->minor->dev;
-	int (*show)(struct drm_device *dev, struct seq_file *m) =
-			node->info_ent->data;
-	int ret;
-
-	ret = mutex_lock_interruptible(&dev->struct_mutex);
-	if (ret)
-		return ret;
-
-	ret = show(dev, m);
-
-	mutex_unlock(&dev->struct_mutex);
-
-	return ret;
-}
-
-static struct drm_info_list msm_debugfs_list[] = {
-		{"gpu", show_locked, 0, msm_gpu_show},
-		{"gem", show_locked, 0, msm_gem_show},
-		{ "mm", show_locked, 0, msm_mm_show },
-		{ "fb", show_locked, 0, msm_fb_show },
-};
-
-static int late_init_minor(struct drm_minor *minor)
-{
-	int ret;
-
-	if (!minor)
-		return 0;
-
-	ret = msm_rd_debugfs_init(minor);
-	if (ret) {
-		dev_err(minor->dev->dev, "could not install rd debugfs\n");
-		return ret;
-	}
-
-	ret = msm_perf_debugfs_init(minor);
-	if (ret) {
-		dev_err(minor->dev->dev, "could not install perf debugfs\n");
-		return ret;
-	}
-
-	return 0;
-}
-
-int msm_debugfs_late_init(struct drm_device *dev)
-{
-	int ret;
-	ret = late_init_minor(dev->primary);
-	if (ret)
-		return ret;
-	ret = late_init_minor(dev->render);
-	if (ret)
-		return ret;
-	ret = late_init_minor(dev->control);
-	return ret;
-}
-
-static int msm_debugfs_init(struct drm_minor *minor)
-{
-	struct drm_device *dev = minor->dev;
-	int ret;
-
-	ret = drm_debugfs_create_files(msm_debugfs_list,
-			ARRAY_SIZE(msm_debugfs_list),
-			minor->debugfs_root, minor);
-
-	if (ret) {
-		dev_err(dev->dev, "could not install msm_debugfs_list\n");
-		return ret;
-	}
-
-	return 0;
-}
-
-static void msm_debugfs_cleanup(struct drm_minor *minor)
-{
-	drm_debugfs_remove_files(msm_debugfs_list,
-			ARRAY_SIZE(msm_debugfs_list), minor);
-	if (!minor->dev->dev_private)
-		return;
-	msm_rd_debugfs_cleanup(minor);
-	msm_perf_debugfs_cleanup(minor);
-}
-#endif
-
 /*
  * Fences:
  */

commit 4016260ba47a43ec67d4bf3610be37fcb2e416d7
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Mar 23 07:10:17 2016 -0400

    drm/msm: fix bug after preclose removal
    
    commit 53190c7194d9a8337fe419134e44c30eb63ebd08
    Author:     Daniel Vetter <daniel.vetter@ffwll.ch>
    AuthorDate: Mon Jan 25 22:16:49 2016 +0100
    Commit:     Daniel Vetter <daniel.vetter@ffwll.ch>
    CommitDate: Mon Feb 8 09:55:50 2016 +0100
    
        drm/msm: Nuke preclose hooks
    
    Left around the unused (and null) preclose fxn ptr, and things
    predictibly explode when you try to call that.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index d52910e2c26c..c03b96709179 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -467,9 +467,6 @@ static void msm_preclose(struct drm_device *dev, struct drm_file *file)
 	struct msm_file_private *ctx = file->driver_priv;
 	struct msm_kms *kms = priv->kms;
 
-	if (kms)
-		kms->funcs->preclose(kms, file);
-
 	mutex_lock(&dev->struct_mutex);
 	if (ctx == priv->lastctx)
 		priv->lastctx = NULL;

commit fcda50c8f484cf1140232c8444470449f0619db9
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Feb 22 22:08:35 2016 +0100

    drm/msm: rename hdmi symbols
    
    Global symbols in the kernel should be prefixed by the name
    of the subsystem and/or driver to avoid conflicts when all
    code is built-in.
    
    In this case, function names like 'hdmi_register' or 'hdmi_set_mode'
    are way too generic for an MSM specific DRM driver, so I'm renaming
    them all to msm_hdmi_* here.
    
    I also rename a lot of the 'static' symbols along with the global
    names for consistency, even though those are relatively harmless;
    they might only be slightly confusing when they show up in
    backtraces.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 280503e19bfd..d52910e2c26c 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1121,7 +1121,7 @@ static int __init msm_drm_register(void)
 	DBG("init");
 	msm_dsi_register();
 	msm_edp_register();
-	hdmi_register();
+	msm_hdmi_register();
 	adreno_register();
 	return platform_driver_register(&msm_platform_driver);
 }
@@ -1130,7 +1130,7 @@ static void __exit msm_drm_unregister(void)
 {
 	DBG("fini");
 	platform_driver_unregister(&msm_platform_driver);
-	hdmi_unregister();
+	msm_hdmi_unregister();
 	adreno_unregister();
 	msm_edp_unregister();
 	msm_dsi_unregister();

commit 4313c744d99314f84a7a98771a17c0c1adfb4de6
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Feb 3 14:02:04 2016 -0500

    drm/msm: fix small typo
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index c1053d634e91..280503e19bfd 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -61,7 +61,7 @@ module_param(fbdev, bool, 0600);
 #endif
 
 static char *vram = "16m";
-MODULE_PARM_DESC(vram, "Configure VRAM size (for devices without IOMMU/GPUMMU");
+MODULE_PARM_DESC(vram, "Configure VRAM size (for devices without IOMMU/GPUMMU)");
 module_param(vram, charp, 0);
 
 /*

commit 1aaa57f5d4b698a73aa9b8329415cb0cc2693596
Author: Archit Taneja <architt@codeaurora.org>
Date:   Thu Feb 25 11:19:45 2016 +0530

    drm/msm: Free fb helper resources in msm_unload
    
    We have a msm_fbev_free function to uninit fb_helper stuff, but we aren't
    using it. Call it in msm_unload.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 9a30807b900b..c1053d634e91 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -196,6 +196,11 @@ static int msm_unload(struct drm_device *dev)
 	}
 
 	drm_kms_helper_poll_fini(dev);
+
+#ifdef CONFIG_DRM_FBDEV_EMULATION
+	if (fbdev && priv->fbdev)
+		msm_fbdev_free(dev);
+#endif
 	drm_mode_config_cleanup(dev);
 	drm_vblank_cleanup(dev);
 

commit d4fc72ed15ce9612cf4124214fb13c3b9792b3d3
Author: Archit Taneja <architt@codeaurora.org>
Date:   Wed Nov 18 12:28:39 2015 +0530

    drm/msm: Update compatible strings for mdp
    
    Create distinct compatible strings for mdp4 and mdp5. Keep "qcom,mdss_mdp"
    as is to support downstream kernels.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 06df8aaab375..9a30807b900b 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1092,8 +1092,10 @@ static const struct platform_device_id msm_id[] = {
 };
 
 static const struct of_device_id dt_match[] = {
-	{ .compatible = "qcom,mdp", .data = (void *) 4 },     /* mdp4 */
-	{ .compatible = "qcom,mdss_mdp", .data = (void *) 5 }, /* mdp5 */
+	{ .compatible = "qcom,mdp4", .data = (void *) 4 },	/* mdp4 */
+	{ .compatible = "qcom,mdp5", .data = (void *) 5 },	/* mdp5 */
+	/* to support downstream DT files */
+	{ .compatible = "qcom,mdss_mdp", .data = (void *) 5 },  /* mdp5 */
 	{}
 };
 MODULE_DEVICE_TABLE(of, dt_match);

commit e9fbdaf25cee78049cefb877e1d2fd36ffbf4af1
Author: Archit Taneja <architt@codeaurora.org>
Date:   Wed Nov 18 12:15:14 2015 +0530

    drm/msm: Remove non-DT code in msm_drv
    
    Support for non-DT kernels was mainly to use v3.4 downstream kernels.
    This is no longer a priority now as we have reasonable support upstream.
    
    Remove CONFIG_OF from the top level msm_drv.c file. While we're at it,
    clean up the data matching process using of_device_get_match_data.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index b88ce514eb8e..06df8aaab375 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -237,20 +237,9 @@ static int msm_unload(struct drm_device *dev)
 
 static int get_mdp_ver(struct platform_device *pdev)
 {
-#ifdef CONFIG_OF
-	static const struct of_device_id match_types[] = { {
-		.compatible = "qcom,mdss_mdp",
-		.data	= (void	*)5,
-	}, {
-		/* end node */
-	} };
 	struct device *dev = &pdev->dev;
-	const struct of_device_id *match;
-	match = of_match_node(match_types, dev->of_node);
-	if (match)
-		return (int)(unsigned long)match->data;
-#endif
-	return 4;
+
+	return (int) (unsigned long) of_device_get_match_data(dev);
 }
 
 #include <linux/of_address.h>
@@ -258,10 +247,10 @@ static int get_mdp_ver(struct platform_device *pdev)
 static int msm_init_vram(struct drm_device *dev)
 {
 	struct msm_drm_private *priv = dev->dev_private;
+	struct device_node *node;
 	unsigned long size = 0;
 	int ret = 0;
 
-#ifdef CONFIG_OF
 	/* In the device-tree world, we could have a 'memory-region'
 	 * phandle, which gives us a link to our "vram".  Allocating
 	 * is all nicely abstracted behind the dma api, but we need
@@ -278,7 +267,6 @@ static int msm_init_vram(struct drm_device *dev)
 	 *     as corruption on screen before we have a chance to
 	 *     load and do initial modeset)
 	 */
-	struct device_node *node;
 
 	node = of_parse_phandle(dev->dev->of_node, "memory-region", 0);
 	if (node) {
@@ -288,14 +276,12 @@ static int msm_init_vram(struct drm_device *dev)
 			return ret;
 		size = r.end - r.start;
 		DRM_INFO("using VRAM carveout: %lx@%pa\n", size, &r.start);
-	} else
-#endif
 
-	/* if we have no IOMMU, then we need to use carveout allocator.
-	 * Grab the entire CMA chunk carved out in early startup in
-	 * mach-msm:
-	 */
-	if (!iommu_present(&platform_bus_type)) {
+		/* if we have no IOMMU, then we need to use carveout allocator.
+		 * Grab the entire CMA chunk carved out in early startup in
+		 * mach-msm:
+		 */
+	} else if (!iommu_present(&platform_bus_type)) {
 		DRM_INFO("using %s VRAM carveout\n", vram);
 		size = memparse(vram, NULL);
 	}
@@ -1035,9 +1021,9 @@ static const struct dev_pm_ops msm_pm_ops = {
  * Componentized driver support:
  */
 
-#ifdef CONFIG_OF
-/* NOTE: the CONFIG_OF case duplicates the same code as exynos or imx
- * (or probably any other).. so probably some room for some helpers
+/*
+ * NOTE: duplication of the same code as exynos or imx (or probably any other).
+ * so probably some room for some helpers
  */
 static int compare_of(struct device *dev, void *data)
 {
@@ -1062,12 +1048,6 @@ static int add_components(struct device *dev, struct component_match **matchptr,
 
 	return 0;
 }
-#else
-static int compare_dev(struct device *dev, void *data)
-{
-	return dev == data;
-}
-#endif
 
 static int msm_drm_bind(struct device *dev)
 {
@@ -1091,35 +1071,9 @@ static const struct component_master_ops msm_drm_ops = {
 static int msm_pdev_probe(struct platform_device *pdev)
 {
 	struct component_match *match = NULL;
-#ifdef CONFIG_OF
+
 	add_components(&pdev->dev, &match, "connectors");
 	add_components(&pdev->dev, &match, "gpus");
-#else
-	/* For non-DT case, it kinda sucks.  We don't actually have a way
-	 * to know whether or not we are waiting for certain devices (or if
-	 * they are simply not present).  But for non-DT we only need to
-	 * care about apq8064/apq8060/etc (all mdp4/a3xx):
-	 */
-	static const char *devnames[] = {
-			"hdmi_msm.0", "kgsl-3d0.0",
-	};
-	int i;
-
-	DBG("Adding components..");
-
-	for (i = 0; i < ARRAY_SIZE(devnames); i++) {
-		struct device *dev;
-
-		dev = bus_find_device_by_name(&platform_bus_type,
-				NULL, devnames[i]);
-		if (!dev) {
-			dev_info(&pdev->dev, "still waiting for %s\n", devnames[i]);
-			return -EPROBE_DEFER;
-		}
-
-		component_match_add(&pdev->dev, &match, compare_dev, dev);
-	}
-#endif
 
 	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
 	return component_master_add_with_match(&pdev->dev, &msm_drm_ops, match);
@@ -1138,8 +1092,8 @@ static const struct platform_device_id msm_id[] = {
 };
 
 static const struct of_device_id dt_match[] = {
-	{ .compatible = "qcom,mdp" },      /* mdp4 */
-	{ .compatible = "qcom,mdss_mdp" }, /* mdp5 */
+	{ .compatible = "qcom,mdp", .data = (void *) 4 },     /* mdp4 */
+	{ .compatible = "qcom,mdss_mdp", .data = (void *) 5 }, /* mdp5 */
 	{}
 };
 MODULE_DEVICE_TABLE(of, dt_match);

commit a9ee34b70e07ce942806eda154e48ea3f754a76f
Author: Archit Taneja <architt@codeaurora.org>
Date:   Mon Jul 13 12:12:07 2015 +0530

    drm/msm: Remove local fbdev emulation Kconfig option
    
    DRM_MSM_FBDEV config is used to enable/disable fbdev emulation for the
    msm kms driver.
    
    Replace this with the top level DRM_FBDEV_EMULATION config option where
    applicable. This also prevents build breaks caused by undefined
    drm_fb_helper_* functions when legacy fbdev support was disabled.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index d170131b0978..b88ce514eb8e 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -21,11 +21,9 @@
 
 static void msm_fb_output_poll_changed(struct drm_device *dev)
 {
-#ifdef CONFIG_DRM_MSM_FBDEV
 	struct msm_drm_private *priv = dev->dev_private;
 	if (priv->fbdev)
 		drm_fb_helper_hotplug_event(priv->fbdev);
-#endif
 }
 
 static const struct drm_mode_config_funcs mode_config_funcs = {
@@ -56,7 +54,7 @@ module_param(reglog, bool, 0600);
 #define reglog 0
 #endif
 
-#ifdef CONFIG_DRM_MSM_FBDEV
+#ifdef CONFIG_DRM_FBDEV_EMULATION
 static bool fbdev = true;
 MODULE_PARM_DESC(fbdev, "Enable fbdev compat layer");
 module_param(fbdev, bool, 0600);
@@ -423,7 +421,7 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 
 	drm_mode_config_reset(dev);
 
-#ifdef CONFIG_DRM_MSM_FBDEV
+#ifdef CONFIG_DRM_FBDEV_EMULATION
 	if (fbdev)
 		priv->fbdev = msm_fbdev_init(dev);
 #endif
@@ -491,11 +489,9 @@ static void msm_preclose(struct drm_device *dev, struct drm_file *file)
 
 static void msm_lastclose(struct drm_device *dev)
 {
-#ifdef CONFIG_DRM_MSM_FBDEV
 	struct msm_drm_private *priv = dev->dev_private;
 	if (priv->fbdev)
 		drm_fb_helper_restore_fbdev_mode_unlocked(priv->fbdev);
-#endif
 }
 
 static irqreturn_t msm_irq(int irq, void *arg)

commit f8c47144bf2964c8599ccce350ef71b62c2cbe28
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Sep 8 13:56:30 2015 +0200

    drm/<drivers>: Drop DRM_UNLOCKED from modeset drivers
    
    Just one special case (since i915 lost its ums code, yay):
    - radeon: Has slots for the old ums ioctls which don't have
      DRM_UNLOCKED, but all filled with drm_invalid_op. So ok to drop it
      everywhere.
    
    Every other kms driver just has DRM_UNLOCKED for all their ioctls, as
    they should.
    
    v2: admgpu happened, include that one too. And i915 lost its UMS
    support which means we can change all the i915 ioctls too.
    
    v3: Rebased on top of new vmwgfx DX interface extensions.
    
    v4: Rebase on top of render-node support in exynos.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Reviewed-by: Christian K√∂nig <christian.koenig@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index a06ec71e109d..d170131b0978 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -932,13 +932,13 @@ static int msm_ioctl_wait_fence(struct drm_device *dev, void *data,
 }
 
 static const struct drm_ioctl_desc msm_ioctls[] = {
-	DRM_IOCTL_DEF_DRV(MSM_GET_PARAM,    msm_ioctl_get_param,    DRM_UNLOCKED|DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_NEW,      msm_ioctl_gem_new,      DRM_UNLOCKED|DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_INFO,     msm_ioctl_gem_info,     DRM_UNLOCKED|DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_PREP, msm_ioctl_gem_cpu_prep, DRM_UNLOCKED|DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_FINI, msm_ioctl_gem_cpu_fini, DRM_UNLOCKED|DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_SUBMIT,   msm_ioctl_gem_submit,   DRM_UNLOCKED|DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(MSM_WAIT_FENCE,   msm_ioctl_wait_fence,   DRM_UNLOCKED|DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GET_PARAM,    msm_ioctl_get_param,    DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_NEW,      msm_ioctl_gem_new,      DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_INFO,     msm_ioctl_gem_info,     DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_PREP, msm_ioctl_gem_cpu_prep, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_FINI, msm_ioctl_gem_cpu_fini, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_SUBMIT,   msm_ioctl_gem_submit,   DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_WAIT_FENCE,   msm_ioctl_wait_fence,   DRM_AUTH|DRM_RENDER_ALLOW),
 };
 
 static const struct vm_operations_struct vm_ops = {

commit b44f84081b8db1b5830cbd30280ba1109cc1a084
Author: Ville Syrj√§l√§ <ville.syrjala@linux.intel.com>
Date:   Wed Sep 30 16:46:48 2015 +0300

    drm: Stop using drm_vblank_count() as the hw frame counter
    
    drm_vblank_count() returns the software counter. We should not pretend
    it's the hw counter since we use the hw counter to figuere out what the
    software counter value should be. So instead provide a new function
    drm_vblank_no_hw_counter() for drivers that don't have a real hw
    counter. The new function simply returns 0, which is about the only
    thing it can do.
    
    Cc: Vincent Abriou <vincent.abriou@st.com>
    Cc: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Ville Syrj√§l√§ <ville.syrjala@linux.intel.com>
    Reviewed-by: Vincent Abriou <vincent.abriou@st.com>
    [danvet: s/int pipe/unsigned int pipe/ to follow Thierry's interface
    change.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 7e44511d0951..a06ec71e109d 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -978,7 +978,7 @@ static struct drm_driver msm_driver = {
 	.irq_preinstall     = msm_irq_preinstall,
 	.irq_postinstall    = msm_irq_postinstall,
 	.irq_uninstall      = msm_irq_uninstall,
-	.get_vblank_counter = drm_vblank_count,
+	.get_vblank_counter = drm_vblank_no_hw_counter,
 	.enable_vblank      = msm_enable_vblank,
 	.disable_vblank     = msm_disable_vblank,
 	.gem_free_object    = msm_gem_free_object,

commit 88e72717c2de4181d8a6de1b04315953ad2bebdf
Author: Thierry Reding <treding@nvidia.com>
Date:   Thu Sep 24 18:35:31 2015 +0200

    drm/irq: Use unsigned int pipe in public API
    
    This continues the pattern started in commit cc1ef118fc09 ("drm/irq:
    Make pipe unsigned and name consistent"). This is applied to the public
    APIs and driver callbacks, so pretty much all drivers need to be updated
    to match the new prototypes.
    
    Cc: Christian K√∂nig <christian.koenig@amd.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Jianwei Wang <jianwei.wang.chn@gmail.com>
    Cc: Alison Wang <alison.wang@freescale.com>
    Cc: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Mark Yao <mark.yao@rock-chips.com>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Vincent Abriou <vincent.abriou@st.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Ville Syrj√§l√§ <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 0339c5d82d37..7e44511d0951 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -531,24 +531,24 @@ static void msm_irq_uninstall(struct drm_device *dev)
 	kms->funcs->irq_uninstall(kms);
 }
 
-static int msm_enable_vblank(struct drm_device *dev, int crtc_id)
+static int msm_enable_vblank(struct drm_device *dev, unsigned int pipe)
 {
 	struct msm_drm_private *priv = dev->dev_private;
 	struct msm_kms *kms = priv->kms;
 	if (!kms)
 		return -ENXIO;
-	DBG("dev=%p, crtc=%d", dev, crtc_id);
-	return vblank_ctrl_queue_work(priv, crtc_id, true);
+	DBG("dev=%p, crtc=%u", dev, pipe);
+	return vblank_ctrl_queue_work(priv, pipe, true);
 }
 
-static void msm_disable_vblank(struct drm_device *dev, int crtc_id)
+static void msm_disable_vblank(struct drm_device *dev, unsigned int pipe)
 {
 	struct msm_drm_private *priv = dev->dev_private;
 	struct msm_kms *kms = priv->kms;
 	if (!kms)
 		return;
-	DBG("dev=%p, crtc=%d", dev, crtc_id);
-	vblank_ctrl_queue_work(priv, crtc_id, false);
+	DBG("dev=%p, crtc=%u", dev, pipe);
+	vblank_ctrl_queue_work(priv, pipe, false);
 }
 
 /*

commit 78b1d470d57dd7a6e0efda63ebad97f0d44e817c
Author: Hai Li <hali@codeaurora.org>
Date:   Mon Jul 27 13:49:45 2015 -0400

    drm/msm: Enable clocks during enable/disable_vblank() callbacks
    
    AHB clock should be enabled before accessing registers during
    enable/disable_vblank(). Since these 2 callbacks are called in
    atomic context while clk_prepare may cause thread sleep, a work
    is scheduled to control vblanks.
    
    v2: fixup spinlock initialization
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    [add comment about cancel_work_sync() before drm_irq_uninstall()]
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 39ce1920f5f5..0339c5d82d37 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -116,6 +116,65 @@ u32 msm_readl(const void __iomem *addr)
 	return val;
 }
 
+struct vblank_event {
+	struct list_head node;
+	int crtc_id;
+	bool enable;
+};
+
+static void vblank_ctrl_worker(struct work_struct *work)
+{
+	struct msm_vblank_ctrl *vbl_ctrl = container_of(work,
+						struct msm_vblank_ctrl, work);
+	struct msm_drm_private *priv = container_of(vbl_ctrl,
+					struct msm_drm_private, vblank_ctrl);
+	struct msm_kms *kms = priv->kms;
+	struct vblank_event *vbl_ev, *tmp;
+	unsigned long flags;
+
+	spin_lock_irqsave(&vbl_ctrl->lock, flags);
+	list_for_each_entry_safe(vbl_ev, tmp, &vbl_ctrl->event_list, node) {
+		list_del(&vbl_ev->node);
+		spin_unlock_irqrestore(&vbl_ctrl->lock, flags);
+
+		if (vbl_ev->enable)
+			kms->funcs->enable_vblank(kms,
+						priv->crtcs[vbl_ev->crtc_id]);
+		else
+			kms->funcs->disable_vblank(kms,
+						priv->crtcs[vbl_ev->crtc_id]);
+
+		kfree(vbl_ev);
+
+		spin_lock_irqsave(&vbl_ctrl->lock, flags);
+	}
+
+	spin_unlock_irqrestore(&vbl_ctrl->lock, flags);
+}
+
+static int vblank_ctrl_queue_work(struct msm_drm_private *priv,
+					int crtc_id, bool enable)
+{
+	struct msm_vblank_ctrl *vbl_ctrl = &priv->vblank_ctrl;
+	struct vblank_event *vbl_ev;
+	unsigned long flags;
+
+	vbl_ev = kzalloc(sizeof(*vbl_ev), GFP_ATOMIC);
+	if (!vbl_ev)
+		return -ENOMEM;
+
+	vbl_ev->crtc_id = crtc_id;
+	vbl_ev->enable = enable;
+
+	spin_lock_irqsave(&vbl_ctrl->lock, flags);
+	list_add_tail(&vbl_ev->node, &vbl_ctrl->event_list);
+	spin_unlock_irqrestore(&vbl_ctrl->lock, flags);
+
+	queue_work(priv->wq, &vbl_ctrl->work);
+
+	return 0;
+}
+
 /*
  * DRM operations:
  */
@@ -125,6 +184,18 @@ static int msm_unload(struct drm_device *dev)
 	struct msm_drm_private *priv = dev->dev_private;
 	struct msm_kms *kms = priv->kms;
 	struct msm_gpu *gpu = priv->gpu;
+	struct msm_vblank_ctrl *vbl_ctrl = &priv->vblank_ctrl;
+	struct vblank_event *vbl_ev, *tmp;
+
+	/* We must cancel and cleanup any pending vblank enable/disable
+	 * work before drm_irq_uninstall() to avoid work re-enabling an
+	 * irq after uninstall has disabled it.
+	 */
+	cancel_work_sync(&vbl_ctrl->work);
+	list_for_each_entry_safe(vbl_ev, tmp, &vbl_ctrl->event_list, node) {
+		list_del(&vbl_ev->node);
+		kfree(vbl_ev);
+	}
 
 	drm_kms_helper_poll_fini(dev);
 	drm_mode_config_cleanup(dev);
@@ -282,6 +353,9 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 
 	INIT_LIST_HEAD(&priv->inactive_list);
 	INIT_LIST_HEAD(&priv->fence_cbs);
+	INIT_LIST_HEAD(&priv->vblank_ctrl.event_list);
+	INIT_WORK(&priv->vblank_ctrl.work, vblank_ctrl_worker);
+	spin_lock_init(&priv->vblank_ctrl.lock);
 
 	drm_mode_config_init(dev);
 
@@ -464,7 +538,7 @@ static int msm_enable_vblank(struct drm_device *dev, int crtc_id)
 	if (!kms)
 		return -ENXIO;
 	DBG("dev=%p, crtc=%d", dev, crtc_id);
-	return kms->funcs->enable_vblank(kms, priv->crtcs[crtc_id]);
+	return vblank_ctrl_queue_work(priv, crtc_id, true);
 }
 
 static void msm_disable_vblank(struct drm_device *dev, int crtc_id)
@@ -474,7 +548,7 @@ static void msm_disable_vblank(struct drm_device *dev, int crtc_id)
 	if (!kms)
 		return;
 	DBG("dev=%p, crtc=%d", dev, crtc_id);
-	kms->funcs->disable_vblank(kms, priv->crtcs[crtc_id]);
+	vblank_ctrl_queue_work(priv, crtc_id, false);
 }
 
 /*

commit 9b7a9fc29a48026d797cbf237121850c1c241df4
Author: Hai Li <hali@codeaurora.org>
Date:   Wed Jun 24 19:13:40 2015 -0400

    drm/msm: Set different display size limitation on each target
    
    The maximum output width of one pipeline depends on the LayerMixer's
    capability. It may be different on each target. Also, MDP5 doesn't
    have vertical limitation in one frame, as long as the pixel clock
    can be supported.
    
    This change obtains the maximum LM resolution from configuration
    table and treat it as the whole pipe's limitation for MDP5. The size
    limit on MDP4 is not changed.
    
    Signed-off-by: Hai Li <hali@codeaurora.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index d3467b115e04..39ce1920f5f5 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -331,10 +331,6 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 		}
 	}
 
-	dev->mode_config.min_width = 0;
-	dev->mode_config.min_height = 0;
-	dev->mode_config.max_width = 2048;
-	dev->mode_config.max_height = 2048;
 	dev->mode_config.funcs = &mode_config_funcs;
 
 	ret = drm_vblank_init(dev, priv->num_crtcs);

commit a9702ca23edae7b72dcff266a0c5ae56f6af0fa5
Author: Wentao Xu <wentaox@codeaurora.org>
Date:   Mon Jun 22 11:53:42 2015 -0400

    drm/msm: change to uninterruptible wait in atomic commit
    
    The atomic commit cannot easily undo and return an error once the
    state is swapped. Change to uninterruptible wait, and ignore the
    timeout error.
    
    Signed-off-by: Wentao Xu <wentaox@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index b7ef56ed8d1c..d3467b115e04 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -637,8 +637,8 @@ static void msm_debugfs_cleanup(struct drm_minor *minor)
  * Fences:
  */
 
-int msm_wait_fence_interruptable(struct drm_device *dev, uint32_t fence,
-		ktime_t *timeout)
+int msm_wait_fence(struct drm_device *dev, uint32_t fence,
+		ktime_t *timeout , bool interruptible)
 {
 	struct msm_drm_private *priv = dev->dev_private;
 	int ret;
@@ -667,7 +667,12 @@ int msm_wait_fence_interruptable(struct drm_device *dev, uint32_t fence,
 			remaining_jiffies = timespec_to_jiffies(&ts);
 		}
 
-		ret = wait_event_interruptible_timeout(priv->fence_event,
+		if (interruptible)
+			ret = wait_event_interruptible_timeout(priv->fence_event,
+				fence_completed(dev, fence),
+				remaining_jiffies);
+		else
+			ret = wait_event_timeout(priv->fence_event,
 				fence_completed(dev, fence),
 				remaining_jiffies);
 
@@ -853,7 +858,7 @@ static int msm_ioctl_wait_fence(struct drm_device *dev, void *data,
 		return -EINVAL;
 	}
 
-	return msm_wait_fence_interruptable(dev, args->fence, &timeout);
+	return msm_wait_fence(dev, args->fence, &timeout, true);
 }
 
 static const struct drm_ioctl_desc msm_ioctls[] = {

commit 56c2da8338d5cdfc0695eeed96ebe03cf2ac0321
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon May 11 11:50:03 2015 -0400

    drm/msm: fix timeout calculation
    
    The 'timeout' value comes from userspace (CLOCK_MONOTONIC), but
    converting this directly to jiffies doesn't take into account the
    initial jiffies count at boot, which may differ from the base time
    of CLOCK_MONOTONIC.
    
    TODO: add ktime_delta_jiffies() when rebasing on 4.1 and use that
    instead of ktime_sub/ktime_to_timespec/timespec_to_jiffies combo (as
    suggested by Arnd)
    
    v2: switch over from 'struct timespec' to ktime_t throughout, since
    'struct timespec' will be deprecated (as suggested by Arnd)
    v3: minor cosmetic tweaks
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 7efd3071481d..b7ef56ed8d1c 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -638,7 +638,7 @@ static void msm_debugfs_cleanup(struct drm_minor *minor)
  */
 
 int msm_wait_fence_interruptable(struct drm_device *dev, uint32_t fence,
-		struct timespec *timeout)
+		ktime_t *timeout)
 {
 	struct msm_drm_private *priv = dev->dev_private;
 	int ret;
@@ -656,14 +656,16 @@ int msm_wait_fence_interruptable(struct drm_device *dev, uint32_t fence,
 		/* no-wait: */
 		ret = fence_completed(dev, fence) ? 0 : -EBUSY;
 	} else {
-		unsigned long timeout_jiffies = timespec_to_jiffies(timeout);
-		unsigned long start_jiffies = jiffies;
+		ktime_t now = ktime_get();
 		unsigned long remaining_jiffies;
 
-		if (time_after(start_jiffies, timeout_jiffies))
+		if (ktime_compare(*timeout, now) < 0) {
 			remaining_jiffies = 0;
-		else
-			remaining_jiffies = timeout_jiffies - start_jiffies;
+		} else {
+			ktime_t rem = ktime_sub(*timeout, now);
+			struct timespec ts = ktime_to_timespec(rem);
+			remaining_jiffies = timespec_to_jiffies(&ts);
+		}
 
 		ret = wait_event_interruptible_timeout(priv->fence_event,
 				fence_completed(dev, fence),
@@ -772,13 +774,17 @@ static int msm_ioctl_gem_new(struct drm_device *dev, void *data,
 			args->flags, &args->handle);
 }
 
-#define TS(t) ((struct timespec){ .tv_sec = (t).tv_sec, .tv_nsec = (t).tv_nsec })
+static inline ktime_t to_ktime(struct drm_msm_timespec timeout)
+{
+	return ktime_set(timeout.tv_sec, timeout.tv_nsec);
+}
 
 static int msm_ioctl_gem_cpu_prep(struct drm_device *dev, void *data,
 		struct drm_file *file)
 {
 	struct drm_msm_gem_cpu_prep *args = data;
 	struct drm_gem_object *obj;
+	ktime_t timeout = to_ktime(args->timeout);
 	int ret;
 
 	if (args->op & ~MSM_PREP_FLAGS) {
@@ -790,7 +796,7 @@ static int msm_ioctl_gem_cpu_prep(struct drm_device *dev, void *data,
 	if (!obj)
 		return -ENOENT;
 
-	ret = msm_gem_cpu_prep(obj, args->op, &TS(args->timeout));
+	ret = msm_gem_cpu_prep(obj, args->op, &timeout);
 
 	drm_gem_object_unreference_unlocked(obj);
 
@@ -840,14 +846,14 @@ static int msm_ioctl_wait_fence(struct drm_device *dev, void *data,
 		struct drm_file *file)
 {
 	struct drm_msm_wait_fence *args = data;
+	ktime_t timeout = to_ktime(args->timeout);
 
 	if (args->pad) {
 		DRM_ERROR("invalid pad: %08x\n", args->pad);
 		return -EINVAL;
 	}
 
-	return msm_wait_fence_interruptable(dev, args->fence,
-			&TS(args->timeout));
+	return msm_wait_fence_interruptable(dev, args->fence, &timeout);
 }
 
 static const struct drm_ioctl_desc msm_ioctls[] = {

commit a5436e1d241488f58bbf7cd4a84fefc9c39c4b62
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Jun 4 10:12:22 2015 -0400

    drm/msm: add missing DRIVER_ATOMIC flag
    
    Somehow this got lost when msm atomic support was first merged.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index c80a6bee2b18..7efd3071481d 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -885,6 +885,7 @@ static struct drm_driver msm_driver = {
 				DRIVER_GEM |
 				DRIVER_PRIME |
 				DRIVER_RENDER |
+				DRIVER_ATOMIC |
 				DRIVER_MODESET,
 	.load               = msm_load,
 	.unload             = msm_unload,

commit 774449ebcb18bae146e2b6f6d012b46e64a095b9
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri May 15 09:19:36 2015 -0400

    drm/msm: fix locking inconsistencies in gpu->destroy()
    
    In error paths, this was being called without struct_mutex held.
    Leading to panics like:
    
      msm 1a00000.qcom,mdss_mdp: No memory protection without IOMMU
      Kernel panic - not syncing: BUG!
      CPU: 0 PID: 1409 Comm: cat Not tainted 4.0.0-dirty #4
      Hardware name: Qualcomm Technologies, Inc. APQ 8016 SBC (DT)
      Call trace:
      [<ffffffc000089c78>] dump_backtrace+0x0/0x118
      [<ffffffc000089da0>] show_stack+0x10/0x20
      [<ffffffc0006686d4>] dump_stack+0x84/0xc4
      [<ffffffc0006678b4>] panic+0xd0/0x210
      [<ffffffc0003e1ce4>] drm_gem_object_free+0x5c/0x60
      [<ffffffc000402870>] adreno_gpu_cleanup+0x60/0x80
      [<ffffffc0004035a0>] a3xx_destroy+0x20/0x70
      [<ffffffc0004036f4>] a3xx_gpu_init+0x84/0x108
      [<ffffffc0004018b8>] adreno_load_gpu+0x58/0x190
      [<ffffffc000419dac>] msm_open+0x74/0x88
      [<ffffffc0003e0a48>] drm_open+0x168/0x400
      [<ffffffc0003e7210>] drm_stub_open+0xa8/0x118
      [<ffffffc0001a0e84>] chrdev_open+0x94/0x198
      [<ffffffc000199f88>] do_dentry_open+0x208/0x310
      [<ffffffc00019a4c4>] vfs_open+0x44/0x50
      [<ffffffc0001aa26c>] do_last.isra.14+0x2c4/0xc10
      [<ffffffc0001aac38>] path_openat+0x80/0x5e8
      [<ffffffc0001ac354>] do_filp_open+0x2c/0x98
      [<ffffffc00019b60c>] do_sys_open+0x13c/0x228
      [<ffffffc00019b72c>] SyS_openat+0xc/0x18
      CPU1: stopping
    
    But there isn't any particularly good reason to hold struct_mutex for
    teardown, so just standardize on calling it without the mutex held and
    use the _unlocked() versions for GEM obj unref'ing
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index cc6485ef2949..c80a6bee2b18 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -145,8 +145,8 @@ static int msm_unload(struct drm_device *dev)
 	if (gpu) {
 		mutex_lock(&dev->struct_mutex);
 		gpu->funcs->pm_suspend(gpu);
-		gpu->funcs->destroy(gpu);
 		mutex_unlock(&dev->struct_mutex);
+		gpu->funcs->destroy(gpu);
 	}
 
 	if (priv->vram.paddr) {

commit 13f15565f7887a028b3442bbd763ff6d07b48479
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu May 7 15:20:13 2015 -0400

    drm/msm: setup vram after component_bind_all()
    
    First of all, we don't want -EPROBE_DEFER when trying to bind children
    to cause us to forget to free our vram.  And second we don't want vram
    allocation fail to trigger _unbind_all() before _bind_all().
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 72f2b962efd4..cc6485ef2949 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -285,10 +285,6 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 
 	drm_mode_config_init(dev);
 
-	ret = msm_init_vram(dev);
-	if (ret)
-		goto fail;
-
 	platform_set_drvdata(pdev, dev);
 
 	/* Bind all our sub-components: */
@@ -296,6 +292,10 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 	if (ret)
 		return ret;
 
+	ret = msm_init_vram(dev);
+	if (ret)
+		goto fail;
+
 	switch (get_mdp_ver(pdev)) {
 	case 4:
 		kms = mdp4_kms_init(dev);

commit a2ca77898e9b81f6d6b3bfa1ff46713e697e8af7
Author: Archit Taneja <architt@codeaurora.org>
Date:   Mon Feb 23 15:59:21 2015 +0530

    drm: msm: Fix build when legacy fbdev support isn't set
    
    The DRM_KMS_FB_HELPER config is selected only when DRM_MSM_FBDEV config is
    selected. The driver accesses drm_fb_helper_* functions even when legacy fbdev
    support is disabled in msm. Wrap around these functions with #ifdef checks to
    prevent build break.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index cc5dc5299b8d..72f2b962efd4 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -21,9 +21,11 @@
 
 static void msm_fb_output_poll_changed(struct drm_device *dev)
 {
+#ifdef CONFIG_DRM_MSM_FBDEV
 	struct msm_drm_private *priv = dev->dev_private;
 	if (priv->fbdev)
 		drm_fb_helper_hotplug_event(priv->fbdev);
+#endif
 }
 
 static const struct drm_mode_config_funcs mode_config_funcs = {
@@ -419,9 +421,11 @@ static void msm_preclose(struct drm_device *dev, struct drm_file *file)
 
 static void msm_lastclose(struct drm_device *dev)
 {
+#ifdef CONFIG_DRM_MSM_FBDEV
 	struct msm_drm_private *priv = dev->dev_private;
 	if (priv->fbdev)
 		drm_fb_helper_restore_fbdev_mode_unlocked(priv->fbdev);
+#endif
 }
 
 static irqreturn_t msm_irq(int irq, void *arg)

commit fc99f97af2f79be02c5045c9a02c50bdcc0c8ff8
Author: Thierry Reding <treding@nvidia.com>
Date:   Thu Apr 9 16:39:51 2015 +0200

    drm/msm: Fix a couple of 64-bit build warnings
    
    Avoid casts from pointers to fixed-size integers to prevent the compiler
    from warning. Print virtual memory addresses using %p instead. Also turn
    a couple of %d/%x specifiers into %zu/%zd/%zx to avoid further warnings
    due to mismatched format strings.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 47f4dd407671..cc5dc5299b8d 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -94,7 +94,7 @@ void __iomem *msm_ioremap(struct platform_device *pdev, const char *name,
 	}
 
 	if (reglog)
-		printk(KERN_DEBUG "IO:region %s %08x %08lx\n", dbgname, (u32)ptr, size);
+		printk(KERN_DEBUG "IO:region %s %p %08lx\n", dbgname, ptr, size);
 
 	return ptr;
 }
@@ -102,7 +102,7 @@ void __iomem *msm_ioremap(struct platform_device *pdev, const char *name,
 void msm_writel(u32 data, void __iomem *addr)
 {
 	if (reglog)
-		printk(KERN_DEBUG "IO:W %08x %08x\n", (u32)addr, data);
+		printk(KERN_DEBUG "IO:W %p %08x\n", addr, data);
 	writel(data, addr);
 }
 
@@ -110,7 +110,7 @@ u32 msm_readl(const void __iomem *addr)
 {
 	u32 val = readl(addr);
 	if (reglog)
-		printk(KERN_ERR "IO:R %08x %08x\n", (u32)addr, val);
+		printk(KERN_ERR "IO:R %p %08x\n", addr, val);
 	return val;
 }
 
@@ -177,7 +177,7 @@ static int get_mdp_ver(struct platform_device *pdev)
 	const struct of_device_id *match;
 	match = of_match_node(match_types, dev->of_node);
 	if (match)
-		return (int)match->data;
+		return (int)(unsigned long)match->data;
 #endif
 	return 4;
 }
@@ -216,7 +216,7 @@ static int msm_init_vram(struct drm_device *dev)
 		if (ret)
 			return ret;
 		size = r.end - r.start;
-		DRM_INFO("using VRAM carveout: %lx@%08x\n", size, r.start);
+		DRM_INFO("using VRAM carveout: %lx@%pa\n", size, &r.start);
 	} else
 #endif
 

commit d5af49c92a8aff8236e7b0bb35e9af364000c017
Author: Hai Li <hali@codeaurora.org>
Date:   Thu Mar 26 19:25:17 2015 -0400

    drm/msm/mdp5: Enable DSI connector in msm drm driver
    
    This change adds the support in mdp5 kms driver for single
    and dual DSI. Dual DSI case depends on the framework API
    and sequence change to support dual data path.
    
    v1: Initial change
    v2: Address Rob Clark's comment
    - Separate command mode encoder to a new file mdp5_cmd_encoder.c
    - Rebase to not depend on msm_drm_sub_dev change
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 0c38f34066e5..47f4dd407671 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1076,6 +1076,7 @@ static struct platform_driver msm_platform_driver = {
 static int __init msm_drm_register(void)
 {
 	DBG("init");
+	msm_dsi_register();
 	msm_edp_register();
 	hdmi_register();
 	adreno_register();
@@ -1089,6 +1090,7 @@ static void __exit msm_drm_unregister(void)
 	hdmi_unregister();
 	adreno_unregister();
 	msm_edp_unregister();
+	msm_dsi_unregister();
 }
 
 module_init(msm_drm_register);

commit 072f1f9168ed67d6ddc94bb76b1dfc04795062b4
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Mar 3 15:04:25 2015 -0500

    drm/msm: add support for "stolen" mem
    
    Add support to use the VRAM carveout (if specified in dtb) for fbdev
    scanout buffer.  This allows drm/msm to take over a bootloader splash-
    screen, and avoids corruption on screen that results if the kernel uses
    memory that is still being scanned out for itself.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index b250610e6393..0c38f34066e5 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -182,21 +182,57 @@ static int get_mdp_ver(struct platform_device *pdev)
 	return 4;
 }
 
+#include <linux/of_address.h>
+
 static int msm_init_vram(struct drm_device *dev)
 {
 	struct msm_drm_private *priv = dev->dev_private;
+	unsigned long size = 0;
+	int ret = 0;
+
+#ifdef CONFIG_OF
+	/* In the device-tree world, we could have a 'memory-region'
+	 * phandle, which gives us a link to our "vram".  Allocating
+	 * is all nicely abstracted behind the dma api, but we need
+	 * to know the entire size to allocate it all in one go. There
+	 * are two cases:
+	 *  1) device with no IOMMU, in which case we need exclusive
+	 *     access to a VRAM carveout big enough for all gpu
+	 *     buffers
+	 *  2) device with IOMMU, but where the bootloader puts up
+	 *     a splash screen.  In this case, the VRAM carveout
+	 *     need only be large enough for fbdev fb.  But we need
+	 *     exclusive access to the buffer to avoid the kernel
+	 *     using those pages for other purposes (which appears
+	 *     as corruption on screen before we have a chance to
+	 *     load and do initial modeset)
+	 */
+	struct device_node *node;
+
+	node = of_parse_phandle(dev->dev->of_node, "memory-region", 0);
+	if (node) {
+		struct resource r;
+		ret = of_address_to_resource(node, 0, &r);
+		if (ret)
+			return ret;
+		size = r.end - r.start;
+		DRM_INFO("using VRAM carveout: %lx@%08x\n", size, r.start);
+	} else
+#endif
 
 	/* if we have no IOMMU, then we need to use carveout allocator.
 	 * Grab the entire CMA chunk carved out in early startup in
 	 * mach-msm:
 	 */
 	if (!iommu_present(&platform_bus_type)) {
+		DRM_INFO("using %s VRAM carveout\n", vram);
+		size = memparse(vram, NULL);
+	}
+
+	if (size) {
 		DEFINE_DMA_ATTRS(attrs);
-		unsigned long size;
 		void *p;
 
-		DBG("using %s VRAM carveout", vram);
-		size = memparse(vram, NULL);
 		priv->vram.size = size;
 
 		drm_mm_init(&priv->vram.mm, 0, (size >> PAGE_SHIFT) - 1);
@@ -220,7 +256,7 @@ static int msm_init_vram(struct drm_device *dev)
 				(uint32_t)(priv->vram.paddr + size));
 	}
 
-	return 0;
+	return ret;
 }
 
 static int msm_load(struct drm_device *dev, unsigned long flags)

commit 5bf9c0b614542d69fb9a8681a0411715cc3e8ba8
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Mar 3 15:04:24 2015 -0500

    drm/msm: split out vram initialization
    
    We'll want to extend this a bit to handle also a reserved-memory
    ("stolen") region, so that drm/msm can take-over bootloader splash
    screen.  First split it out into it's own fxn to reduce noise in
    the following patch.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index a4269119f9ea..b250610e6393 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -182,29 +182,9 @@ static int get_mdp_ver(struct platform_device *pdev)
 	return 4;
 }
 
-static int msm_load(struct drm_device *dev, unsigned long flags)
+static int msm_init_vram(struct drm_device *dev)
 {
-	struct platform_device *pdev = dev->platformdev;
-	struct msm_drm_private *priv;
-	struct msm_kms *kms;
-	int ret;
-
-	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
-	if (!priv) {
-		dev_err(dev->dev, "failed to allocate private data\n");
-		return -ENOMEM;
-	}
-
-	dev->dev_private = priv;
-
-	priv->wq = alloc_ordered_workqueue("msm", 0);
-	init_waitqueue_head(&priv->fence_event);
-	init_waitqueue_head(&priv->pending_crtcs_event);
-
-	INIT_LIST_HEAD(&priv->inactive_list);
-	INIT_LIST_HEAD(&priv->fence_cbs);
-
-	drm_mode_config_init(dev);
+	struct msm_drm_private *priv = dev->dev_private;
 
 	/* if we have no IOMMU, then we need to use carveout allocator.
 	 * Grab the entire CMA chunk carved out in early startup in
@@ -232,8 +212,7 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 		if (!p) {
 			dev_err(dev->dev, "failed to allocate VRAM\n");
 			priv->vram.paddr = 0;
-			ret = -ENOMEM;
-			goto fail;
+			return -ENOMEM;
 		}
 
 		dev_info(dev->dev, "VRAM: %08x->%08x\n",
@@ -241,6 +220,37 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 				(uint32_t)(priv->vram.paddr + size));
 	}
 
+	return 0;
+}
+
+static int msm_load(struct drm_device *dev, unsigned long flags)
+{
+	struct platform_device *pdev = dev->platformdev;
+	struct msm_drm_private *priv;
+	struct msm_kms *kms;
+	int ret;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(dev->dev, "failed to allocate private data\n");
+		return -ENOMEM;
+	}
+
+	dev->dev_private = priv;
+
+	priv->wq = alloc_ordered_workqueue("msm", 0);
+	init_waitqueue_head(&priv->fence_event);
+	init_waitqueue_head(&priv->pending_crtcs_event);
+
+	INIT_LIST_HEAD(&priv->inactive_list);
+	INIT_LIST_HEAD(&priv->fence_cbs);
+
+	drm_mode_config_init(dev);
+
+	ret = msm_init_vram(dev);
+	if (ret)
+		goto fail;
+
 	platform_set_drvdata(pdev, dev);
 
 	/* Bind all our sub-components: */

commit e90dfec78ec288d6c89a7b508a5c5d4ae8b7f934
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Jan 30 17:05:41 2015 -0500

    drm/msm: add moduleparam to disable fbdev
    
    Useful to avoid recompiling to disable fbdev.  Useful because otherwise
    the first modeset happens under console_lock (ie. debugging sadness).
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index e757c9d866db..a4269119f9ea 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -54,6 +54,12 @@ module_param(reglog, bool, 0600);
 #define reglog 0
 #endif
 
+#ifdef CONFIG_DRM_MSM_FBDEV
+static bool fbdev = true;
+MODULE_PARM_DESC(fbdev, "Enable fbdev compat layer");
+module_param(fbdev, bool, 0600);
+#endif
+
 static char *vram = "16m";
 MODULE_PARM_DESC(vram, "Configure VRAM size (for devices without IOMMU/GPUMMU");
 module_param(vram, charp, 0);
@@ -300,7 +306,8 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 	drm_mode_config_reset(dev);
 
 #ifdef CONFIG_DRM_MSM_FBDEV
-	priv->fbdev = msm_fbdev_init(dev);
+	if (fbdev)
+		priv->fbdev = msm_fbdev_init(dev);
 #endif
 
 	ret = msm_debugfs_late_init(dev);

commit 0045398131e48cba3d759a2ad435d8b45640652e
Author: Hai Li <hali@codeaurora.org>
Date:   Fri Dec 12 14:41:17 2014 -0500

    drm/msm: Add the eDP connector in msm drm driver (V2)
    
    Modified the hard-coded hdmi connector/encoder implementations in msm drm
    driver to support both edp and hdmi.
    
    V1: Initial change
    
    V2: Address Thierry's change
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index f1ebedde6346..e757c9d866db 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1023,6 +1023,7 @@ static struct platform_driver msm_platform_driver = {
 static int __init msm_drm_register(void)
 {
 	DBG("init");
+	msm_edp_register();
 	hdmi_register();
 	adreno_register();
 	return platform_driver_register(&msm_platform_driver);
@@ -1034,6 +1035,7 @@ static void __exit msm_drm_unregister(void)
 	platform_driver_unregister(&msm_platform_driver);
 	hdmi_unregister();
 	adreno_unregister();
+	msm_edp_unregister();
 }
 
 module_init(msm_drm_register);

commit c93546a5e32bd788c22aefa072385f3784551c13
Merge: e5202a2289d7 179f158ccf15
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jan 9 09:22:40 2015 +1000

    Merge tag 'topic/atomic-core-2015-01-05' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    Next batch of atomic work. Most important is the propertification from Rob
    and the nth iteration of the actual atomic ioctl originally from Ville.
    Big differences compared to earlier revisions:
    - Core properties are now fully handled by the core, drivers can only
      handle driver-specific properties.
    - Atomic props&ioctl are opt-in per file_priv, userspace needs to
      explicitly ask for it (like universal plane support).
    - For now all hidden behind the atomic module option until this has
      settled a bit.
    - Atomic modesets are currently not possible since the exact abi for how
      to handle the mode property is still under discussion.
    
    Besides this some cleanup patches from me and the addition of per-object
    state to global state backpointers to simplify drivers.
    
    * tag 'topic/atomic-core-2015-01-05' of git://anongit.freedesktop.org/drm-intel:
      drm: Ensure universal_planes is set for atomic
      drm/atomic: Hide drm.ko internal interfaces
      drm: Atomic modeset ioctl
      drm/atomic: atomic connector properties
      drm/atomic: atomic plane properties
      drm: small property creation cleanup
      drm/atomic: atomic_check functions
      drm: add atomic properties
      drm: refactor getproperties/getconnector
      drm: tweak getconnector locking
      drm: add atomic_get_property
      drm: add atomic_set_property wrappers
      drm: get rid of direct property value access
      drm: store property instead of id in obj attachment
      drm: allow property validation for refcnted props
      drm/atomic: Introduce state->obj backpointers
      drm/atomic-helper: Again check modeset *before* plane states
      drm/atomic-helper: Export both plane and modeset check helpers

commit 955f6be8ec6adfb44cb07bb3e60d875426710535
Merge: 2036eaa74031 ff2f974e5c9d
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Dec 23 08:21:54 2014 +1000

    Merge branch 'msm-fixes-3.19' of git://people.freedesktop.org/~robclark/linux into drm-fixes
    
    A few msm fixes for 3.19:
     * hdmi regulators fix
     * hdmi fix for spurious HPD interrupts
     * fix for sync atomic update after async update (which could show
       up with a setcrtc following a pageflip)
     * couple little Coccinelle cleanups
    
    * 'msm-fixes-3.19' of git://people.freedesktop.org/~robclark/linux:
      drm/msm/hdmi: rework HDMI IRQ handler
      drm/msm/hdmi: enable regulators before clocks to avoid warnings
      drm/msm/mdp5: update irqs on crtc<->encoder link change
      drm/msm: block incoming update on pending updates
      drm/msm: Deletion of unnecessary checks before the function call "release_firmware"
      drm/msm: Deletion of unnecessary checks before two function calls

commit f86afecf0defbc8d046bc7a7c5fc19a8c9ba1364
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Nov 25 12:41:18 2014 -0500

    drm/msm: block incoming update on pending updates
    
    We can't have multiple updates pending on a given CRTC, and we don't
    want a sync update to race w/ an async update that preceeded it.  So
    keep track of which CRTCs have updates in flight, and block later
    updates that would conflict.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index d3b791b7ddef..7e1c71e51cb4 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -193,6 +193,7 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 
 	priv->wq = alloc_ordered_workqueue("msm", 0);
 	init_waitqueue_head(&priv->fence_event);
+	init_waitqueue_head(&priv->pending_crtcs_event);
 
 	INIT_LIST_HEAD(&priv->inactive_list);
 	INIT_LIST_HEAD(&priv->fence_cbs);

commit b4274fbee6fc7ca3dd1cc786456ec6fbc14f864d
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Nov 26 17:02:18 2014 +0100

    drm/atomic-helper: Again check modeset *before* plane states
    
    This essentially reverts
    
    commit 934ce1c23624526d9d784e0499190bb48113e6f4
    Author: Rob Clark <robdclark@gmail.com>
    Date:   Wed Nov 19 16:41:33 2014 -0500
    
        drm/atomic: check mode_changed *after* atomic_check
    
    Depending upon the driver both orders (or maybe even interleaving) is
    required:
    - If ->atomic_check updates ->mode_changed then helper_check_modeset
      must be run afters.
    - If ->atomic_check depends upon accurate adjusted dotclock values for
      e.g. watermarks, then helper_check_modeset must be run first.
    
    The failure mode in the first case is usually a totally angry hw
    because the pixel format switching doesn't happen. The failure mode in
    the later case is usually nothing, since in most cases the old
    adjusted mode from the previous modeset wont be too far off to be a
    problem. So just underruns and perhaps even just suboptimal (from a
    power consumption) watermarks.
    
    Furthermore in the transitional helpers we only call ->atomic_check
    after the new modeset state has been fully set up (and hence
    computed).
    
    Given that asymmetry in expected failure modes I think it's safer to
    go back to the older order. So do that and give msm a special check
    function to compensate.
    
    Also update kerneldoc to explain this a bit.
    
    v2: Actually add the missing hunk Rob spotted.
    
    v3: Move msm_atomic_check into msm_atomic.c, requested by Rob.
    
    Cc: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Tested-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index d3b791b7ddef..473e4d6051e9 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -29,7 +29,7 @@ static void msm_fb_output_poll_changed(struct drm_device *dev)
 static const struct drm_mode_config_funcs mode_config_funcs = {
 	.fb_create = msm_framebuffer_create,
 	.output_poll_changed = msm_fb_output_poll_changed,
-	.atomic_check = drm_atomic_helper_check,
+	.atomic_check = msm_atomic_check,
 	.atomic_commit = msm_atomic_commit,
 };
 

commit 988adfdffdd43cfd841df734664727993076d7cb
Merge: 26178ec11ef3 4e0cd6811562
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 15 15:52:01 2014 -0800

    Merge branch 'drm-next' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm updates from Dave Airlie:
     "Highlights:
    
       - AMD KFD driver merge
    
         This is the AMD HSA interface for exposing a lowlevel interface for
         GPGPU use.  They have an open source userspace built on top of this
         interface, and the code looks as good as it was going to get out of
         tree.
    
       - Initial atomic modesetting work
    
         The need for an atomic modesetting interface to allow userspace to
         try and send a complete set of modesetting state to the driver has
         arisen, and been suffering from neglect this past year.  No more,
         the start of the common code and changes for msm driver to use it
         are in this tree.  Ongoing work to get the userspace ioctl finished
         and the code clean will probably wait until next kernel.
    
       - DisplayID 1.3 and tiled monitor exposed to userspace.
    
         Tiled monitor property is now exposed for userspace to make use of.
    
       - Rockchip drm driver merged.
    
       - imx gpu driver moved out of staging
    
      Other stuff:
    
       - core:
            panel - MIPI DSI + new panels.
            expose suggested x/y properties for virtual GPUs
    
       - i915:
            Initial Skylake (SKL) support
            gen3/4 reset work
            start of dri1/ums removal
            infoframe tracking
            fixes for lots of things.
    
       - nouveau:
            tegra k1 voltage support
            GM204 modesetting support
            GT21x memory reclocking work
    
       - radeon:
            CI dpm fixes
            GPUVM improvements
            Initial DPM fan control
    
       - rcar-du:
            HDMI support added
            removed some support for old boards
            slave encoder driver for Analog Devices adv7511
    
       - exynos:
            Exynos4415 SoC support
    
       - msm:
            a4xx gpu support
            atomic helper conversion
    
       - tegra:
            iommu support
            universal plane support
            ganged-mode DSI support
    
       - sti:
            HDMI i2c improvements
    
       - vmwgfx:
            some late fixes.
    
       - qxl:
            use suggested x/y properties"
    
    * 'drm-next' of git://people.freedesktop.org/~airlied/linux: (969 commits)
      drm: sti: fix module compilation issue
      drm/i915: save/restore GMBUS freq across suspend/resume on gen4
      drm: sti: correctly cleanup CRTC and planes
      drm: sti: add HQVDP plane
      drm: sti: add cursor plane
      drm: sti: enable auxiliary CRTC
      drm: sti: fix delay in VTG programming
      drm: sti: prepare sti_tvout to support auxiliary crtc
      drm: sti: use drm_crtc_vblank_{on/off} instead of drm_vblank_{on/off}
      drm: sti: fix hdmi avi infoframe
      drm: sti: remove event lock while disabling vblank
      drm: sti: simplify gdp code
      drm: sti: clear all mixer control
      drm: sti: remove gpio for HDMI hot plug detection
      drm: sti: allow to change hdmi ddc i2c adapter
      drm/doc: Document drm_add_modes_noedid() usage
      drm/i915: Remove '& 0xffff' from the mask given to WA_REG()
      drm/i915: Invert the mask and val arguments in wa_add() and WA_REG()
      drm: Zero out DRM object memory upon cleanup
      drm/i915/bdw: Fix the write setting up the WIZ hashing mode
      ...

commit cf3a7e4ce08e6876cdcb80390876647f28a7cf8f
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Nov 8 13:21:06 2014 -0500

    drm/msm: atomic core bits
    
    The core parts for async commit.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 1456b1c3e890..d3b791b7ddef 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -29,6 +29,8 @@ static void msm_fb_output_poll_changed(struct drm_device *dev)
 static const struct drm_mode_config_funcs mode_config_funcs = {
 	.fb_create = msm_framebuffer_create,
 	.output_poll_changed = msm_fb_output_poll_changed,
+	.atomic_check = drm_atomic_helper_check,
+	.atomic_commit = msm_atomic_commit,
 };
 
 int msm_register_mmu(struct drm_device *dev, struct msm_mmu *mmu)
@@ -294,6 +296,8 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 		goto fail;
 	}
 
+	drm_mode_config_reset(dev);
+
 #ifdef CONFIG_DRM_MSM_FBDEV
 	priv->fbdev = msm_fbdev_init(dev);
 #endif

commit 69193e5060dd1c8f7cd614bad05f33f3e042ae6d
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Nov 7 18:10:04 2014 -0500

    drm/msm: small fence cleanup
    
    Give ourselves a way to wait for certain fence #..  makes it easier to
    wait on a set of bo's, which we'll need for atomic.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 5717d4ec1a2c..1456b1c3e890 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -619,6 +619,26 @@ int msm_wait_fence_interruptable(struct drm_device *dev, uint32_t fence,
 	return ret;
 }
 
+int msm_queue_fence_cb(struct drm_device *dev,
+		struct msm_fence_cb *cb, uint32_t fence)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+	int ret = 0;
+
+	mutex_lock(&dev->struct_mutex);
+	if (!list_empty(&cb->work.entry)) {
+		ret = -EINVAL;
+	} else if (fence > priv->completed_fence) {
+		cb->fence = fence;
+		list_add_tail(&cb->work.entry, &priv->fence_cbs);
+	} else {
+		queue_work(priv->wq, &cb->work);
+	}
+	mutex_unlock(&dev->struct_mutex);
+
+	return ret;
+}
+
 /* called from workqueue */
 void msm_update_fence(struct drm_device *dev, uint32_t fence)
 {

commit 77a147e742afe33a612d93d61ba153df668de428
Author: Daniel Thompson <daniel.thompson@linaro.org>
Date:   Wed Nov 12 11:38:14 2014 +0000

    drm/msm: Allow exported dma-bufs to be mapped
    
    Currently msm does not implement gem_prime_mmap. Without this it is not
    possible to draw onto a dma-buf from userspace (making its very hard to
    implement the Android rendering model).
    
    Fixing this is just a matter of adding a little boilerplate.
    
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index b67ef5985125..5717d4ec1a2c 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -832,6 +832,7 @@ static struct drm_driver msm_driver = {
 	.gem_prime_import_sg_table = msm_gem_prime_import_sg_table,
 	.gem_prime_vmap     = msm_gem_prime_vmap,
 	.gem_prime_vunmap   = msm_gem_prime_vunmap,
+	.gem_prime_mmap     = msm_gem_prime_mmap,
 #ifdef CONFIG_DEBUG_FS
 	.debugfs_init       = msm_debugfs_init,
 	.debugfs_cleanup    = msm_debugfs_cleanup,

commit 6a4d005e64d034dbd9f3ce551aeb1f89d0f65c7c
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:33 2014 +0200

    gpu: drm: msm: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index b67ef5985125..42e1c48eef28 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -987,7 +987,6 @@ static struct platform_driver msm_platform_driver = {
 	.probe      = msm_pdev_probe,
 	.remove     = msm_pdev_remove,
 	.driver     = {
-		.owner  = THIS_MODULE,
 		.name   = "msm",
 		.of_match_table = dt_match,
 		.pm     = &msm_pm_ops,

commit b2efb3f0a1db62aff5e824125785ec6731143b6d
Merge: 4ac073640a52 9e82bf014195
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Sep 16 11:28:52 2014 +1000

    drm: backmerge tag 'v3.17-rc5' into drm-next
    
    This is requested to get the fixes for intel and radeon into the
    same tree for future development work.
    
    i915_display.c: fix missing dev_priv conflict.

commit 3a10ba8c6b68d9b7f519cd25f903be2d43b37d9d
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon Sep 8 14:24:57 2014 -0400

    drm/msm: don't crash if no msm.vram param
    
    If VRAM carveout is used, due to no IOMMU, we should have a default
    value for msm.vram so that we don't simply crash.
    
    Reported-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 26ee80db17af..fcf95680413d 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -52,7 +52,7 @@ module_param(reglog, bool, 0600);
 #define reglog 0
 #endif
 
-static char *vram;
+static char *vram = "16m";
 MODULE_PARM_DESC(vram, "Configure VRAM size (for devices without IOMMU/GPUMMU");
 module_param(vram, charp, 0);
 

commit e2550b7a7d8f2030cfea43343eb3fccc3a8e8167
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Sep 5 13:30:27 2014 -0400

    drm/msm/adreno: move decision about what gpu to to load
    
    Move this into into adreno_device, and decide based on gpu revision
    rather than just assuming a3xx.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 7008900e6b29..307d52d4ece8 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -315,39 +315,12 @@ static void load_gpu(struct drm_device *dev)
 {
 	static DEFINE_MUTEX(init_lock);
 	struct msm_drm_private *priv = dev->dev_private;
-	struct msm_gpu *gpu;
 
 	mutex_lock(&init_lock);
 
-	if (priv->gpu)
-		goto out;
-
-	gpu = a3xx_gpu_init(dev);
-	if (IS_ERR(gpu)) {
-		dev_warn(dev->dev, "failed to load a3xx gpu\n");
-		gpu = NULL;
-		/* not fatal */
-	}
-
-	if (gpu) {
-		int ret;
-		mutex_lock(&dev->struct_mutex);
-		gpu->funcs->pm_resume(gpu);
-		mutex_unlock(&dev->struct_mutex);
-		ret = gpu->funcs->hw_init(gpu);
-		if (ret) {
-			dev_err(dev->dev, "gpu hw init failed: %d\n", ret);
-			gpu->funcs->destroy(gpu);
-			gpu = NULL;
-		} else {
-			/* give inactive pm a chance to kick in: */
-			msm_gpu_retire(gpu);
-		}
-	}
-
-	priv->gpu = gpu;
+	if (!priv->gpu)
+		priv->gpu = adreno_load_gpu(dev);
 
-out:
 	mutex_unlock(&init_lock);
 }
 

commit bfd28b136298f37ef2e10494d3a0bfb4dcbaa7b9
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Sep 5 13:06:37 2014 -0400

    drm/msm/adreno: split adreno device out into it's own file
    
    We'd rather not duplicate these parts as support for additional gpu
    generations is added.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 3b05fb4e3d66..7008900e6b29 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1027,7 +1027,7 @@ static int __init msm_drm_register(void)
 {
 	DBG("init");
 	hdmi_register();
-	a3xx_register();
+	adreno_register();
 	return platform_driver_register(&msm_platform_driver);
 }
 
@@ -1036,7 +1036,7 @@ static void __exit msm_drm_unregister(void)
 	DBG("fini");
 	platform_driver_unregister(&msm_platform_driver);
 	hdmi_unregister();
-	a3xx_unregister();
+	adreno_unregister();
 }
 
 module_init(msm_drm_register);

commit d65bd0e431156f156f43946b6efb524694afb685
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Aug 6 07:43:12 2014 -0400

    drm/msm/mdp4: fix blend setup with multiple crtcs
    
    In particular, blend_setup() should not overwrite the other crtc's mixer
    settings.  Also, the encoder needs to be able to specify the mixer-id
    explicitly, since both LVDS and DTV use 'INTF_LVDC_DTV', so we cannot
    guess the mixer-id from the interface.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 47ccdbf49fa1..3b05fb4e3d66 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -280,7 +280,7 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 	dev->mode_config.max_height = 2048;
 	dev->mode_config.funcs = &mode_config_funcs;
 
-	ret = drm_vblank_init(dev, 1);
+	ret = drm_vblank_init(dev, priv->num_crtcs);
 	if (ret < 0) {
 		dev_err(dev->dev, "failed to initialize vblank\n");
 		goto fail;

commit 915b4d11b8b9e7b84ba4a4645b6cc7fbc0c071cf
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Fri Aug 29 12:12:43 2014 +0200

    drm: add driver->set_busid() callback
    
    One step closer to dropping all the drm_bus_* code:
    Add a driver->set_busid() callback and make all drivers use the generic
    helpers. Nouveau is the only driver that uses two different bus-types with
    the same drm_driver. This is totally broken if both buses are available on
    the same machine (unlikely, but lets be safe). Therefore, we create two
    different drivers for each platform during module_init() and set the
    set_busid() callback respectively.
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index b447c01ad89c..47ccdbf49fa1 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -836,6 +836,7 @@ static struct drm_driver msm_driver = {
 	.open               = msm_open,
 	.preclose           = msm_preclose,
 	.lastclose          = msm_lastclose,
+	.set_busid          = drm_platform_set_busid,
 	.irq_handler        = msm_irq,
 	.irq_preinstall     = msm_irq_preinstall,
 	.irq_postinstall    = msm_irq_postinstall,

commit 12313c2aa81d669493c60438e42571d0b8e850c4
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon Aug 4 15:45:16 2014 -0400

    drm/msm: fix compile error for non-dt builds
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index b447c01ad89c..26ee80db17af 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -974,12 +974,11 @@ static int msm_pdev_probe(struct platform_device *pdev)
 
 	for (i = 0; i < ARRAY_SIZE(devnames); i++) {
 		struct device *dev;
-		int ret;
 
 		dev = bus_find_device_by_name(&platform_bus_type,
 				NULL, devnames[i]);
 		if (!dev) {
-			dev_info(master, "still waiting for %s\n", devnames[i]);
+			dev_info(&pdev->dev, "still waiting for %s\n", devnames[i]);
 			return -EPROBE_DEFER;
 		}
 

commit a1ad35233345e7ddd9ea3ea7b841432f4723d743
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Jul 11 11:59:22 2014 -0400

    drm/msm: fix potential deadlock in gpu init
    
    Somewhere along the way, the firmware loader sprouted another lock
    dependency, resulting in possible deadlock scenario:
    
     &dev->struct_mutex --> &sb->s_type->i_mutex_key#2 --> &mm->mmap_sem
    
    which is problematic vs things like gem mmap.
    
    So introduce a separate mutex to synchronize gpu init.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index a2f5bf6da6f3..b447c01ad89c 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -181,7 +181,6 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 	struct msm_kms *kms;
 	int ret;
 
-
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv) {
 		dev_err(dev->dev, "failed to allocate private data\n");
@@ -314,13 +313,15 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 
 static void load_gpu(struct drm_device *dev)
 {
+	static DEFINE_MUTEX(init_lock);
 	struct msm_drm_private *priv = dev->dev_private;
 	struct msm_gpu *gpu;
 
+	mutex_lock(&init_lock);
+
 	if (priv->gpu)
-		return;
+		goto out;
 
-	mutex_lock(&dev->struct_mutex);
 	gpu = a3xx_gpu_init(dev);
 	if (IS_ERR(gpu)) {
 		dev_warn(dev->dev, "failed to load a3xx gpu\n");
@@ -330,7 +331,9 @@ static void load_gpu(struct drm_device *dev)
 
 	if (gpu) {
 		int ret;
+		mutex_lock(&dev->struct_mutex);
 		gpu->funcs->pm_resume(gpu);
+		mutex_unlock(&dev->struct_mutex);
 		ret = gpu->funcs->hw_init(gpu);
 		if (ret) {
 			dev_err(dev->dev, "gpu hw init failed: %d\n", ret);
@@ -340,12 +343,12 @@ static void load_gpu(struct drm_device *dev)
 			/* give inactive pm a chance to kick in: */
 			msm_gpu_retire(gpu);
 		}
-
 	}
 
 	priv->gpu = gpu;
 
-	mutex_unlock(&dev->struct_mutex);
+out:
+	mutex_unlock(&init_lock);
 }
 
 static int msm_open(struct drm_device *dev, struct drm_file *file)

commit 41e69778c80764c12683beff5ebef12298a5d16b
Author: Rob Clark <robdclark@gmail.com>
Date:   Sun Dec 15 16:23:05 2013 -0500

    drm/msm: DT support for 8960/8064 (v3)
    
    Now that we (almost) have enough dependencies in place (MMCC, RPM, etc),
    add necessary DT support so that we can use drm/msm on upstream kernel.
    
    v2: update for review comments
    v3: rebase on component helper changes
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index a322029983ce..a2f5bf6da6f3 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -905,6 +905,25 @@ static int compare_of(struct device *dev, void *data)
 {
 	return dev->of_node == data;
 }
+
+static int add_components(struct device *dev, struct component_match **matchptr,
+		const char *name)
+{
+	struct device_node *np = dev->of_node;
+	unsigned i;
+
+	for (i = 0; ; i++) {
+		struct device_node *node;
+
+		node = of_parse_phandle(np, name, i);
+		if (!node)
+			break;
+
+		component_match_add(dev, matchptr, compare_of, node);
+	}
+
+	return 0;
+}
 #else
 static int compare_dev(struct device *dev, void *data)
 {
@@ -935,21 +954,8 @@ static int msm_pdev_probe(struct platform_device *pdev)
 {
 	struct component_match *match = NULL;
 #ifdef CONFIG_OF
-	/* NOTE: the CONFIG_OF case duplicates the same code as exynos or imx
-	 * (or probably any other).. so probably some room for some helpers
-	 */
-	struct device_node *np = pdev->dev.of_node;
-	unsigned i;
-
-	for (i = 0; ; i++) {
-		struct device_node *node;
-
-		node = of_parse_phandle(np, "connectors", i);
-		if (!node)
-			break;
-
-		component_match_add(&pdev->dev, &match, compare_of, node);
-	}
+	add_components(&pdev->dev, &match, "connectors");
+	add_components(&pdev->dev, &match, "gpus");
 #else
 	/* For non-DT case, it kinda sucks.  We don't actually have a way
 	 * to know whether or not we are waiting for certain devices (or if
@@ -995,7 +1001,8 @@ static const struct platform_device_id msm_id[] = {
 };
 
 static const struct of_device_id dt_match[] = {
-	{ .compatible = "qcom,mdss_mdp" },
+	{ .compatible = "qcom,mdp" },      /* mdp4 */
+	{ .compatible = "qcom,mdss_mdp" }, /* mdp5 */
 	{}
 };
 MODULE_DEVICE_TABLE(of, dt_match);

commit 84448288546d13d7e06fd6638fb78ddff559b399
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Apr 19 11:20:42 2014 +0100

    drm: msm: update to use component match support
    
    Update MSM's DRM driver to use the component match support rather than
    add_components.
    
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 9a5d87db5c23..a322029983ce 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -905,12 +905,41 @@ static int compare_of(struct device *dev, void *data)
 {
 	return dev->of_node == data;
 }
+#else
+static int compare_dev(struct device *dev, void *data)
+{
+	return dev == data;
+}
+#endif
+
+static int msm_drm_bind(struct device *dev)
+{
+	return drm_platform_init(&msm_driver, to_platform_device(dev));
+}
+
+static void msm_drm_unbind(struct device *dev)
+{
+	drm_put_dev(platform_get_drvdata(to_platform_device(dev)));
+}
+
+static const struct component_master_ops msm_drm_ops = {
+	.bind = msm_drm_bind,
+	.unbind = msm_drm_unbind,
+};
+
+/*
+ * Platform driver:
+ */
 
-static int msm_drm_add_components(struct device *master, struct master *m)
+static int msm_pdev_probe(struct platform_device *pdev)
 {
-	struct device_node *np = master->of_node;
+	struct component_match *match = NULL;
+#ifdef CONFIG_OF
+	/* NOTE: the CONFIG_OF case duplicates the same code as exynos or imx
+	 * (or probably any other).. so probably some room for some helpers
+	 */
+	struct device_node *np = pdev->dev.of_node;
 	unsigned i;
-	int ret;
 
 	for (i = 0; ; i++) {
 		struct device_node *node;
@@ -919,22 +948,9 @@ static int msm_drm_add_components(struct device *master, struct master *m)
 		if (!node)
 			break;
 
-		ret = component_master_add_child(m, compare_of, node);
-		of_node_put(node);
-
-		if (ret)
-			return ret;
+		component_match_add(&pdev->dev, &match, compare_of, node);
 	}
-	return 0;
-}
 #else
-static int compare_dev(struct device *dev, void *data)
-{
-	return dev == data;
-}
-
-static int msm_drm_add_components(struct device *master, struct master *m)
-{
 	/* For non-DT case, it kinda sucks.  We don't actually have a way
 	 * to know whether or not we are waiting for certain devices (or if
 	 * they are simply not present).  But for non-DT we only need to
@@ -958,41 +974,12 @@ static int msm_drm_add_components(struct device *master, struct master *m)
 			return -EPROBE_DEFER;
 		}
 
-		ret = component_master_add_child(m, compare_dev, dev);
-		if (ret) {
-			DBG("could not add child: %d", ret);
-			return ret;
-		}
+		component_match_add(&pdev->dev, &match, compare_dev, dev);
 	}
-
-	return 0;
-}
 #endif
 
-static int msm_drm_bind(struct device *dev)
-{
-	return drm_platform_init(&msm_driver, to_platform_device(dev));
-}
-
-static void msm_drm_unbind(struct device *dev)
-{
-	drm_put_dev(platform_get_drvdata(to_platform_device(dev)));
-}
-
-static const struct component_master_ops msm_drm_ops = {
-		.add_components = msm_drm_add_components,
-		.bind = msm_drm_bind,
-		.unbind = msm_drm_unbind,
-};
-
-/*
- * Platform driver:
- */
-
-static int msm_pdev_probe(struct platform_device *pdev)
-{
 	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
-	return component_master_add(&pdev->dev, &msm_drm_ops);
+	return component_master_add_with_match(&pdev->dev, &msm_drm_ops, match);
 }
 
 static int msm_pdev_remove(struct platform_device *pdev)

commit 370a4d8a79f166d2accc294c4db35e5cbe8c3a90
Author: Peter Griffin <peter.griffin@linaro.org>
Date:   Thu Jun 5 18:30:58 2014 +0100

    drm/msm: storage class should be before const qualifier
    
    The C99 specification states in section 6.11.5:
    
    The placement of a storage-class specifier other than at the beginning
    of the declaration specifiers in a declaration is an obsolescent
    feature.
    
    Signed-off-by: Peter Griffin <peter.griffin@linaro.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: dri-devel@lists.freedesktop.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 0d2562fb681e..9a5d87db5c23 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -159,7 +159,7 @@ static int msm_unload(struct drm_device *dev)
 static int get_mdp_ver(struct platform_device *pdev)
 {
 #ifdef CONFIG_OF
-	const static struct of_device_id match_types[] = { {
+	static const struct of_device_id match_types[] = { {
 		.compatible = "qcom,mdss_mdp",
 		.data	= (void	*)5,
 	}, {

commit 5ea1f752ae04be403a3dc8ec876a60d7f5f6990a
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri May 30 12:29:48 2014 -0400

    drm: add drm_fb_helper_restore_fbdev_mode_unlocked()
    
    All drm_fb_helper_restore_fbdev_mode() call sites, save one, do the same
    locking.  Simplify this into drm_fb_helper_restore_fbdev_mode_unlocked().
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index c071aacf2752..0d2562fb681e 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -386,11 +386,8 @@ static void msm_preclose(struct drm_device *dev, struct drm_file *file)
 static void msm_lastclose(struct drm_device *dev)
 {
 	struct msm_drm_private *priv = dev->dev_private;
-	if (priv->fbdev) {
-		drm_modeset_lock_all(dev);
-		drm_fb_helper_restore_fbdev_mode(priv->fbdev);
-		drm_modeset_unlock_all(dev);
-	}
+	if (priv->fbdev)
+		drm_fb_helper_restore_fbdev_mode_unlocked(priv->fbdev);
 }
 
 static irqreturn_t msm_irq(int irq, void *arg)

commit 543d3011f1c193ba2257a754757117cafda2252b
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon Jun 2 07:25:56 2014 -0400

    drm/msm: use correct gfp flag for vram allocation
    
    We want at least __GFP_WAIT, otherwise dma-mapping tries to use coherent
    pool rather than CMA pool.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 1d5151ab81e7..c071aacf2752 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -220,7 +220,7 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 		 * is bogus, but non-null if allocation succeeded:
 		 */
 		p = dma_alloc_attrs(dev->dev, size,
-				&priv->vram.paddr, 0, &attrs);
+				&priv->vram.paddr, GFP_KERNEL, &attrs);
 		if (!p) {
 			dev_err(dev->dev, "failed to allocate VRAM\n");
 			priv->vram.paddr = 0;

commit 70c70f091b1ffd16b3e1a439bd595f7d539b1d5d
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri May 30 14:49:43 2014 -0400

    drm/msm: add perf logging debugfs
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 929f57343440..1d5151ab81e7 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -548,6 +548,12 @@ static int late_init_minor(struct drm_minor *minor)
 		return ret;
 	}
 
+	ret = msm_perf_debugfs_init(minor);
+	if (ret) {
+		dev_err(minor->dev->dev, "could not install perf debugfs\n");
+		return ret;
+	}
+
 	return 0;
 }
 
@@ -588,6 +594,7 @@ static void msm_debugfs_cleanup(struct drm_minor *minor)
 	if (!minor->dev->dev_private)
 		return;
 	msm_rd_debugfs_cleanup(minor);
+	msm_perf_debugfs_cleanup(minor);
 }
 #endif
 

commit a7d3c9509b2fecf8e593f3c933ab302cbe987d2e
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri May 30 14:47:38 2014 -0400

    drm/msm: add rd logging debugfs
    
    To ease debugging, add debugfs file which can be cat/tail'd to log
    submits, along with fence #.  If GPU hangs, you can look at 'gpu'
    debugfs file to find last completed fence and current register state,
    and compare with logged rd file to narrow down the DRAW_INDX which
    triggered the GPU hang.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 50ec1bed5820..929f57343440 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -299,6 +299,10 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 	priv->fbdev = msm_fbdev_init(dev);
 #endif
 
+	ret = msm_debugfs_late_init(dev);
+	if (ret)
+		goto fail;
+
 	drm_kms_helper_poll_init(dev);
 
 	return 0;
@@ -531,6 +535,35 @@ static struct drm_info_list msm_debugfs_list[] = {
 		{ "fb", show_locked, 0, msm_fb_show },
 };
 
+static int late_init_minor(struct drm_minor *minor)
+{
+	int ret;
+
+	if (!minor)
+		return 0;
+
+	ret = msm_rd_debugfs_init(minor);
+	if (ret) {
+		dev_err(minor->dev->dev, "could not install rd debugfs\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int msm_debugfs_late_init(struct drm_device *dev)
+{
+	int ret;
+	ret = late_init_minor(dev->primary);
+	if (ret)
+		return ret;
+	ret = late_init_minor(dev->render);
+	if (ret)
+		return ret;
+	ret = late_init_minor(dev->control);
+	return ret;
+}
+
 static int msm_debugfs_init(struct drm_minor *minor)
 {
 	struct drm_device *dev = minor->dev;
@@ -545,13 +578,16 @@ static int msm_debugfs_init(struct drm_minor *minor)
 		return ret;
 	}
 
-	return ret;
+	return 0;
 }
 
 static void msm_debugfs_cleanup(struct drm_minor *minor)
 {
 	drm_debugfs_remove_files(msm_debugfs_list,
 			ARRAY_SIZE(msm_debugfs_list), minor);
+	if (!minor->dev->dev_private)
+		return;
+	msm_rd_debugfs_cleanup(minor);
 }
 #endif
 

commit bb0f1b5c1695b4399cfd2359c114ae63edbb3ad8
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sun Nov 3 21:09:27 2013 +0100

    drm: pass the irq explicitly to drm_irq_install
    
    Unfortunately this requires a drm-wide change, and I didn't see a sane
    way around that. Luckily it's fairly simple, we just need to inline
    the respective get_irq implementation from either drm_pci.c or
    drm_platform.c.
    
    With that we can now also remove drm_dev_to_irq from drm_irq.c.
    
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index f9de156b9e65..50ec1bed5820 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -288,7 +288,7 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 	}
 
 	pm_runtime_get_sync(dev->dev);
-	ret = drm_irq_install(dev);
+	ret = drm_irq_install(dev, platform_get_irq(dev->platformdev, 0));
 	pm_runtime_put_sync(dev->dev);
 	if (ret < 0) {
 		dev_err(dev->dev, "failed to install IRQ handler\n");

commit 93ddb0d3b022dfbd963f243bd01741643cebfb28
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon Mar 3 09:42:33 2014 -0500

    drm/msm: validate flags, etc
    
    After reading a nice article on LWN[1], I went back and double checked
    my handling of invalid-input checking.  Turns out there were a couple
    places I had missed.
    
    Since the driver is fairly young, and the devices it supports are really
    only just barely usable for basic stuff (serial console) with an
    upstream kernel, I think we should fix this now and revert specific
    parts of this patch later in the unlikely event that a regression is
    reported.
    
    [1] https://lwn.net/Articles/588444/
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 7a7421fb02b4..f9de156b9e65 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -664,6 +664,12 @@ static int msm_ioctl_gem_new(struct drm_device *dev, void *data,
 		struct drm_file *file)
 {
 	struct drm_msm_gem_new *args = data;
+
+	if (args->flags & ~MSM_BO_FLAGS) {
+		DRM_ERROR("invalid flags: %08x\n", args->flags);
+		return -EINVAL;
+	}
+
 	return msm_gem_new_handle(dev, file, args->size,
 			args->flags, &args->handle);
 }
@@ -677,6 +683,11 @@ static int msm_ioctl_gem_cpu_prep(struct drm_device *dev, void *data,
 	struct drm_gem_object *obj;
 	int ret;
 
+	if (args->op & ~MSM_PREP_FLAGS) {
+		DRM_ERROR("invalid op: %08x\n", args->op);
+		return -EINVAL;
+	}
+
 	obj = drm_gem_object_lookup(dev, file, args->handle);
 	if (!obj)
 		return -ENOENT;
@@ -731,7 +742,14 @@ static int msm_ioctl_wait_fence(struct drm_device *dev, void *data,
 		struct drm_file *file)
 {
 	struct drm_msm_wait_fence *args = data;
-	return msm_wait_fence_interruptable(dev, args->fence, &TS(args->timeout));
+
+	if (args->pad) {
+		DRM_ERROR("invalid pad: %08x\n", args->pad);
+		return -EINVAL;
+	}
+
+	return msm_wait_fence_interruptable(dev, args->fence,
+			&TS(args->timeout));
 }
 
 static const struct drm_ioctl_desc msm_ioctls[] = {

commit 060530f1ea6740eb767085008d183f89ccdd289c
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon Mar 3 14:19:12 2014 -0500

    drm/msm: use componentised device support
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index e913efa4ea0a..7a7421fb02b4 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -56,6 +56,10 @@ static char *vram;
 MODULE_PARM_DESC(vram, "Configure VRAM size (for devices without IOMMU/GPUMMU");
 module_param(vram, charp, 0);
 
+/*
+ * Util/helpers:
+ */
+
 void __iomem *msm_ioremap(struct platform_device *pdev, const char *name,
 		const char *dbgname)
 {
@@ -143,6 +147,8 @@ static int msm_unload(struct drm_device *dev)
 				priv->vram.paddr, &attrs);
 	}
 
+	component_unbind_all(dev->dev, dev);
+
 	dev->dev_private = NULL;
 
 	kfree(priv);
@@ -175,6 +181,7 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 	struct msm_kms *kms;
 	int ret;
 
+
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv) {
 		dev_err(dev->dev, "failed to allocate private data\n");
@@ -226,6 +233,13 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 				(uint32_t)(priv->vram.paddr + size));
 	}
 
+	platform_set_drvdata(pdev, dev);
+
+	/* Bind all our sub-components: */
+	ret = component_bind_all(dev->dev, dev);
+	if (ret)
+		return ret;
+
 	switch (get_mdp_ver(pdev)) {
 	case 4:
 		kms = mdp4_kms_init(dev);
@@ -281,8 +295,6 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 		goto fail;
 	}
 
-	platform_set_drvdata(pdev, dev);
-
 #ifdef CONFIG_DRM_MSM_FBDEV
 	priv->fbdev = msm_fbdev_init(dev);
 #endif
@@ -823,6 +835,98 @@ static const struct dev_pm_ops msm_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(msm_pm_suspend, msm_pm_resume)
 };
 
+/*
+ * Componentized driver support:
+ */
+
+#ifdef CONFIG_OF
+/* NOTE: the CONFIG_OF case duplicates the same code as exynos or imx
+ * (or probably any other).. so probably some room for some helpers
+ */
+static int compare_of(struct device *dev, void *data)
+{
+	return dev->of_node == data;
+}
+
+static int msm_drm_add_components(struct device *master, struct master *m)
+{
+	struct device_node *np = master->of_node;
+	unsigned i;
+	int ret;
+
+	for (i = 0; ; i++) {
+		struct device_node *node;
+
+		node = of_parse_phandle(np, "connectors", i);
+		if (!node)
+			break;
+
+		ret = component_master_add_child(m, compare_of, node);
+		of_node_put(node);
+
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+#else
+static int compare_dev(struct device *dev, void *data)
+{
+	return dev == data;
+}
+
+static int msm_drm_add_components(struct device *master, struct master *m)
+{
+	/* For non-DT case, it kinda sucks.  We don't actually have a way
+	 * to know whether or not we are waiting for certain devices (or if
+	 * they are simply not present).  But for non-DT we only need to
+	 * care about apq8064/apq8060/etc (all mdp4/a3xx):
+	 */
+	static const char *devnames[] = {
+			"hdmi_msm.0", "kgsl-3d0.0",
+	};
+	int i;
+
+	DBG("Adding components..");
+
+	for (i = 0; i < ARRAY_SIZE(devnames); i++) {
+		struct device *dev;
+		int ret;
+
+		dev = bus_find_device_by_name(&platform_bus_type,
+				NULL, devnames[i]);
+		if (!dev) {
+			dev_info(master, "still waiting for %s\n", devnames[i]);
+			return -EPROBE_DEFER;
+		}
+
+		ret = component_master_add_child(m, compare_dev, dev);
+		if (ret) {
+			DBG("could not add child: %d", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+#endif
+
+static int msm_drm_bind(struct device *dev)
+{
+	return drm_platform_init(&msm_driver, to_platform_device(dev));
+}
+
+static void msm_drm_unbind(struct device *dev)
+{
+	drm_put_dev(platform_get_drvdata(to_platform_device(dev)));
+}
+
+static const struct component_master_ops msm_drm_ops = {
+		.add_components = msm_drm_add_components,
+		.bind = msm_drm_bind,
+		.unbind = msm_drm_unbind,
+};
+
 /*
  * Platform driver:
  */
@@ -830,12 +934,12 @@ static const struct dev_pm_ops msm_pm_ops = {
 static int msm_pdev_probe(struct platform_device *pdev)
 {
 	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
-	return drm_platform_init(&msm_driver, pdev);
+	return component_master_add(&pdev->dev, &msm_drm_ops);
 }
 
 static int msm_pdev_remove(struct platform_device *pdev)
 {
-	drm_put_dev(platform_get_drvdata(pdev));
+	component_master_del(&pdev->dev, &msm_drm_ops);
 
 	return 0;
 }

commit 37d77c3ab589bf8e3160a33b651fe6dd7439ba48
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Jan 11 16:25:08 2014 -0500

    drm/msm: crank down gpu when inactive
    
    Shut down the clks when the gpu has nothing to do.  A short inactivity
    timer is used to provide a low pass filter for power transitions.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index e6adafc7eff3..e913efa4ea0a 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -311,7 +311,6 @@ static void load_gpu(struct drm_device *dev)
 		gpu = NULL;
 		/* not fatal */
 	}
-	mutex_unlock(&dev->struct_mutex);
 
 	if (gpu) {
 		int ret;
@@ -321,10 +320,16 @@ static void load_gpu(struct drm_device *dev)
 			dev_err(dev->dev, "gpu hw init failed: %d\n", ret);
 			gpu->funcs->destroy(gpu);
 			gpu = NULL;
+		} else {
+			/* give inactive pm a chance to kick in: */
+			msm_gpu_retire(gpu);
 		}
+
 	}
 
 	priv->gpu = gpu;
+
+	mutex_unlock(&dev->struct_mutex);
 }
 
 static int msm_open(struct drm_device *dev, struct drm_file *file)

commit b04a590623661132fbafdda53a6566b227dc39cf
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Dec 11 14:24:46 2013 +0100

    drm: store the gem vma offset manager in a typed pointer
    
    This was hidden in a generic void * dev->mm_private. But only ever
    used for gem. But thanks to this fake generic pretension no one
    noticed that Rob's drm drivers are now all broken.
    
    So just give the offset manager a type pointer and fix up msm, omapdrm
    and tilcdc.
    
    v2: Fixup compile fail.
    
    v3: Fixup rebase fail that David spotted.
    
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 63ed79fe8a05..e6adafc7eff3 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -461,7 +461,7 @@ static int msm_gem_show(struct drm_device *dev, struct seq_file *m)
 
 static int msm_mm_show(struct drm_device *dev, struct seq_file *m)
 {
-	return drm_mm_dump_table(m, dev->mm_private);
+	return drm_mm_dump_table(m, &dev->vma_offset_manager->vm_addr_space_mm);
 }
 
 static int msm_fb_show(struct drm_device *dev, struct seq_file *m)

commit 06c0dd96bfbba8a9368ffd7c4b12d3bfed37001d
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Nov 30 17:51:47 2013 -0500

    drm/msm: add mdp5/apq8x74
    
    Add support for the new MDP5 display controller block.  The mapping
    between parts of the display controller and KMS is:
    
      plane   -> PIPE{RGBn,VIGn}             \
      crtc    -> LM (layer mixer)            |-> MDP "device"
      encoder -> INTF                        /
      connector -> HDMI/DSI/eDP/etc          --> other device(s)
    
    Unlike MDP4, it appears we can get by with a single encoder, rather
    than needing a different implementation for DTV, DSI, etc.  (Ie. the
    register interface is same, just different bases.)
    
    Also unlike MDP4, all the IRQs for other blocks (HDMI, DSI, etc) are
    routed through MDP.
    
    And finally, MDP5 has this "Shared Memory Pool" (called "SMP"), from
    which blocks need to be allocated to the active pipes based on fetch
    stride.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 4fa9a03d2a6c..63ed79fe8a05 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -150,6 +150,24 @@ static int msm_unload(struct drm_device *dev)
 	return 0;
 }
 
+static int get_mdp_ver(struct platform_device *pdev)
+{
+#ifdef CONFIG_OF
+	const static struct of_device_id match_types[] = { {
+		.compatible = "qcom,mdss_mdp",
+		.data	= (void	*)5,
+	}, {
+		/* end node */
+	} };
+	struct device *dev = &pdev->dev;
+	const struct of_device_id *match;
+	match = of_match_node(match_types, dev->of_node);
+	if (match)
+		return (int)match->data;
+#endif
+	return 4;
+}
+
 static int msm_load(struct drm_device *dev, unsigned long flags)
 {
 	struct platform_device *pdev = dev->platformdev;
@@ -208,7 +226,18 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 				(uint32_t)(priv->vram.paddr + size));
 	}
 
-	kms = mdp4_kms_init(dev);
+	switch (get_mdp_ver(pdev)) {
+	case 4:
+		kms = mdp4_kms_init(dev);
+		break;
+	case 5:
+		kms = mdp5_kms_init(dev);
+		break;
+	default:
+		kms = ERR_PTR(-ENODEV);
+		break;
+	}
+
 	if (IS_ERR(kms)) {
 		/*
 		 * NOTE: once we have GPU support, having no kms should not
@@ -811,12 +840,19 @@ static const struct platform_device_id msm_id[] = {
 	{ }
 };
 
+static const struct of_device_id dt_match[] = {
+	{ .compatible = "qcom,mdss_mdp" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, dt_match);
+
 static struct platform_driver msm_platform_driver = {
 	.probe      = msm_pdev_probe,
 	.remove     = msm_pdev_remove,
 	.driver     = {
 		.owner  = THIS_MODULE,
 		.name   = "msm",
+		.of_match_table = dt_match,
 		.pm     = &msm_pm_ops,
 	},
 	.id_table   = msm_id,

commit dd2da6e34672100b5fd811fbf2cf97e29c08080f
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Nov 30 16:12:10 2013 -0500

    drm/msm: split out msm_kms.h
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index a7f0c65ca655..4fa9a03d2a6c 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -17,6 +17,7 @@
 
 #include "msm_drv.h"
 #include "msm_gpu.h"
+#include "msm_kms.h"
 
 static void msm_fb_output_poll_changed(struct drm_device *dev)
 {

commit 871d812aa43e6350a4edf41bf7cb0879675255f1
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Nov 16 12:56:06 2013 -0500

    drm/msm: add support for non-IOMMU systems
    
    Add a VRAM carveout that is used for systems which do not have an IOMMU.
    
    The VRAM carveout uses CMA.  The arch code must setup a CMA pool for the
    device (preferrably in highmem.. a 256m-512m VRAM pool in lowmem is not
    cool).  The user can configure the VRAM pool size using msm.vram module
    param.
    
    Technically, the abstraction of IOMMU behind msm_mmu is not strictly
    needed, but it simplifies the GEM code a bit, and will be useful later
    when I add support for a2xx devices with GPUMMU, so I decided to keep
    this part.
    
    It appears to be possible to configure the GPU to restrict access to
    addresses within the VRAM pool, but this is not done yet.  So for now
    the GPU will refuse to load if there is no sort of mmu.  Once address
    based limits are supported and tested to confirm that we aren't giving
    the GPU access to arbitrary memory, this restriction can be lifted
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 28b57eb6f9a1..a7f0c65ca655 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -30,50 +30,19 @@ static const struct drm_mode_config_funcs mode_config_funcs = {
 	.output_poll_changed = msm_fb_output_poll_changed,
 };
 
-static int msm_fault_handler(struct iommu_domain *iommu, struct device *dev,
-		unsigned long iova, int flags, void *arg)
-{
-	DBG("*** fault: iova=%08lx, flags=%d", iova, flags);
-	return 0;
-}
-
-int msm_register_iommu(struct drm_device *dev, struct iommu_domain *iommu)
+int msm_register_mmu(struct drm_device *dev, struct msm_mmu *mmu)
 {
 	struct msm_drm_private *priv = dev->dev_private;
-	int idx = priv->num_iommus++;
+	int idx = priv->num_mmus++;
 
-	if (WARN_ON(idx >= ARRAY_SIZE(priv->iommus)))
+	if (WARN_ON(idx >= ARRAY_SIZE(priv->mmus)))
 		return -EINVAL;
 
-	priv->iommus[idx] = iommu;
-
-	iommu_set_fault_handler(iommu, msm_fault_handler, dev);
-
-	/* need to iommu_attach_device() somewhere??  on resume?? */
+	priv->mmus[idx] = mmu;
 
 	return idx;
 }
 
-int msm_iommu_attach(struct drm_device *dev, struct iommu_domain *iommu,
-		const char **names, int cnt)
-{
-	int i, ret;
-
-	for (i = 0; i < cnt; i++) {
-		/* TODO maybe some day msm iommu won't require this hack: */
-		struct device *msm_iommu_get_ctx(const char *ctx_name);
-		struct device *ctx = msm_iommu_get_ctx(names[i]);
-		if (!ctx)
-			continue;
-		ret = iommu_attach_device(iommu, ctx);
-		if (ret) {
-			dev_warn(dev->dev, "could not attach iommu to %s", names[i]);
-			return ret;
-		}
-	}
-	return 0;
-}
-
 #ifdef CONFIG_DRM_MSM_REGISTER_LOGGING
 static bool reglog = false;
 MODULE_PARM_DESC(reglog, "Enable register read/write logging");
@@ -82,6 +51,10 @@ module_param(reglog, bool, 0600);
 #define reglog 0
 #endif
 
+static char *vram;
+MODULE_PARM_DESC(vram, "Configure VRAM size (for devices without IOMMU/GPUMMU");
+module_param(vram, charp, 0);
+
 void __iomem *msm_ioremap(struct platform_device *pdev, const char *name,
 		const char *dbgname)
 {
@@ -161,6 +134,14 @@ static int msm_unload(struct drm_device *dev)
 		mutex_unlock(&dev->struct_mutex);
 	}
 
+	if (priv->vram.paddr) {
+		DEFINE_DMA_ATTRS(attrs);
+		dma_set_attr(DMA_ATTR_NO_KERNEL_MAPPING, &attrs);
+		drm_mm_takedown(&priv->vram.mm);
+		dma_free_attrs(dev->dev, priv->vram.size, NULL,
+				priv->vram.paddr, &attrs);
+	}
+
 	dev->dev_private = NULL;
 
 	kfree(priv);
@@ -191,6 +172,41 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 
 	drm_mode_config_init(dev);
 
+	/* if we have no IOMMU, then we need to use carveout allocator.
+	 * Grab the entire CMA chunk carved out in early startup in
+	 * mach-msm:
+	 */
+	if (!iommu_present(&platform_bus_type)) {
+		DEFINE_DMA_ATTRS(attrs);
+		unsigned long size;
+		void *p;
+
+		DBG("using %s VRAM carveout", vram);
+		size = memparse(vram, NULL);
+		priv->vram.size = size;
+
+		drm_mm_init(&priv->vram.mm, 0, (size >> PAGE_SHIFT) - 1);
+
+		dma_set_attr(DMA_ATTR_NO_KERNEL_MAPPING, &attrs);
+		dma_set_attr(DMA_ATTR_WRITE_COMBINE, &attrs);
+
+		/* note that for no-kernel-mapping, the vaddr returned
+		 * is bogus, but non-null if allocation succeeded:
+		 */
+		p = dma_alloc_attrs(dev->dev, size,
+				&priv->vram.paddr, 0, &attrs);
+		if (!p) {
+			dev_err(dev->dev, "failed to allocate VRAM\n");
+			priv->vram.paddr = 0;
+			ret = -ENOMEM;
+			goto fail;
+		}
+
+		dev_info(dev->dev, "VRAM: %08x->%08x\n",
+				(uint32_t)priv->vram.paddr,
+				(uint32_t)(priv->vram.paddr + size));
+	}
+
 	kms = mdp4_kms_init(dev);
 	if (IS_ERR(kms)) {
 		/*
@@ -778,6 +794,7 @@ static const struct dev_pm_ops msm_pm_ops = {
 
 static int msm_pdev_probe(struct platform_device *pdev)
 {
+	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
 	return drm_platform_init(&msm_driver, pdev);
 }
 

commit e9f0d76f3bcd4dda7136baaaaf45bda3b13ff40f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Dec 11 11:34:42 2013 +0100

    drm: Kill DRM_IRQ_ARGS
    
    I've killed them a long time ago in drm/i915, let's get rid of this
    remnant of shared drm core days for good.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index aa5f3546bbec..28b57eb6f9a1 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -326,7 +326,7 @@ static void msm_lastclose(struct drm_device *dev)
 	}
 }
 
-static irqreturn_t msm_irq(DRM_IRQ_ARGS)
+static irqreturn_t msm_irq(int irq, void *arg)
 {
 	struct drm_device *dev = arg;
 	struct msm_drm_private *priv = dev->dev_private;

commit 0ff420f7f50c7d429d1c00058a0350559c0b9bb5
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Dec 11 11:34:29 2013 +0100

    drm/msm: call drm_put_dev directly in ->remove
    
    The drvdata pointer is already assigned to something useful.
    
    Cc: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 86537692e45c..aa5f3546bbec 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -783,7 +783,7 @@ static int msm_pdev_probe(struct platform_device *pdev)
 
 static int msm_pdev_remove(struct platform_device *pdev)
 {
-	drm_platform_exit(&msm_driver, pdev);
+	drm_put_dev(platform_get_drvdata(pdev));
 
 	return 0;
 }

commit edd4fc63a33eeeb922503b14e8040a3b028c76a5
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Sep 14 14:01:55 2013 -0400

    drm/msm: rework inactive-work
    
    Re-arrange things a bit so that we can get work requested after a bo
    fence passes, like pageflip, done before retiring bo's.  Without any
    sort of bo cache in userspace, some games can trigger hundred's of
    transient bo's, which can cause retire to take a long time (5-10ms).
    Obviously we want a bo cache.. but this cleanup will make things a
    bit easier for atomic as well and makes things a bit cleaner.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Acked-by: David Brown <davidb@codeaurora.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index e7ac95a38725..86537692e45c 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -187,6 +187,7 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 	init_waitqueue_head(&priv->fence_event);
 
 	INIT_LIST_HEAD(&priv->inactive_list);
+	INIT_LIST_HEAD(&priv->fence_cbs);
 
 	drm_mode_config_init(dev);
 
@@ -539,15 +540,36 @@ int msm_wait_fence_interruptable(struct drm_device *dev, uint32_t fence,
 	return ret;
 }
 
-/* call under struct_mutex */
+/* called from workqueue */
 void msm_update_fence(struct drm_device *dev, uint32_t fence)
 {
 	struct msm_drm_private *priv = dev->dev_private;
 
-	if (fence > priv->completed_fence) {
-		priv->completed_fence = fence;
-		wake_up_all(&priv->fence_event);
+	mutex_lock(&dev->struct_mutex);
+	priv->completed_fence = max(fence, priv->completed_fence);
+
+	while (!list_empty(&priv->fence_cbs)) {
+		struct msm_fence_cb *cb;
+
+		cb = list_first_entry(&priv->fence_cbs,
+				struct msm_fence_cb, work.entry);
+
+		if (cb->fence > priv->completed_fence)
+			break;
+
+		list_del_init(&cb->work.entry);
+		queue_work(priv->wq, &cb->work);
 	}
+
+	mutex_unlock(&dev->struct_mutex);
+
+	wake_up_all(&priv->fence_event);
+}
+
+void __msm_fence_worker(struct work_struct *work)
+{
+	struct msm_fence_cb *cb = container_of(work, struct msm_fence_cb, work);
+	cb->func(cb);
 }
 
 /*

commit b4b15c865da67e6f6d52af1441c52e0f74782344
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Sep 28 12:01:25 2013 -0400

    drm/msm: support render nodes
    
    Enable support for drm render nodes for msm by flagging the ioctls
    that are safe and only needed for rendering.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Acked-by: David Brown <davidb@codeaurora.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index cfeebdd911dd..e7ac95a38725 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -650,13 +650,13 @@ static int msm_ioctl_wait_fence(struct drm_device *dev, void *data,
 }
 
 static const struct drm_ioctl_desc msm_ioctls[] = {
-	DRM_IOCTL_DEF_DRV(MSM_GET_PARAM,    msm_ioctl_get_param,    DRM_UNLOCKED|DRM_AUTH),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_NEW,      msm_ioctl_gem_new,      DRM_UNLOCKED|DRM_AUTH),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_INFO,     msm_ioctl_gem_info,     DRM_UNLOCKED|DRM_AUTH),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_PREP, msm_ioctl_gem_cpu_prep, DRM_UNLOCKED|DRM_AUTH),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_FINI, msm_ioctl_gem_cpu_fini, DRM_UNLOCKED|DRM_AUTH),
-	DRM_IOCTL_DEF_DRV(MSM_GEM_SUBMIT,   msm_ioctl_gem_submit,   DRM_UNLOCKED|DRM_AUTH),
-	DRM_IOCTL_DEF_DRV(MSM_WAIT_FENCE,   msm_ioctl_wait_fence,   DRM_UNLOCKED|DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(MSM_GET_PARAM,    msm_ioctl_get_param,    DRM_UNLOCKED|DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_NEW,      msm_ioctl_gem_new,      DRM_UNLOCKED|DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_INFO,     msm_ioctl_gem_info,     DRM_UNLOCKED|DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_PREP, msm_ioctl_gem_cpu_prep, DRM_UNLOCKED|DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_FINI, msm_ioctl_gem_cpu_fini, DRM_UNLOCKED|DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_SUBMIT,   msm_ioctl_gem_submit,   DRM_UNLOCKED|DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(MSM_WAIT_FENCE,   msm_ioctl_wait_fence,   DRM_UNLOCKED|DRM_AUTH|DRM_RENDER_ALLOW),
 };
 
 static const struct vm_operations_struct vm_ops = {
@@ -683,6 +683,7 @@ static struct drm_driver msm_driver = {
 	.driver_features    = DRIVER_HAVE_IRQ |
 				DRIVER_GEM |
 				DRIVER_PRIME |
+				DRIVER_RENDER |
 				DRIVER_MODESET,
 	.load               = msm_load,
 	.unload             = msm_unload,

commit 05b849111c07454fd2f5b074ca7eb56ccdb8828c
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Sep 28 11:28:35 2013 -0400

    drm/msm: prime support
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Acked-by: David Brown <davidb@codeaurora.org>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index b3a2f1629041..cfeebdd911dd 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -680,7 +680,10 @@ static const struct file_operations fops = {
 };
 
 static struct drm_driver msm_driver = {
-	.driver_features    = DRIVER_HAVE_IRQ | DRIVER_GEM | DRIVER_MODESET,
+	.driver_features    = DRIVER_HAVE_IRQ |
+				DRIVER_GEM |
+				DRIVER_PRIME |
+				DRIVER_MODESET,
 	.load               = msm_load,
 	.unload             = msm_unload,
 	.open               = msm_open,
@@ -698,6 +701,16 @@ static struct drm_driver msm_driver = {
 	.dumb_create        = msm_gem_dumb_create,
 	.dumb_map_offset    = msm_gem_dumb_map_offset,
 	.dumb_destroy       = drm_gem_dumb_destroy,
+	.prime_handle_to_fd = drm_gem_prime_handle_to_fd,
+	.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
+	.gem_prime_export   = drm_gem_prime_export,
+	.gem_prime_import   = drm_gem_prime_import,
+	.gem_prime_pin      = msm_gem_prime_pin,
+	.gem_prime_unpin    = msm_gem_prime_unpin,
+	.gem_prime_get_sg_table = msm_gem_prime_get_sg_table,
+	.gem_prime_import_sg_table = msm_gem_prime_import_sg_table,
+	.gem_prime_vmap     = msm_gem_prime_vmap,
+	.gem_prime_vunmap   = msm_gem_prime_vunmap,
 #ifdef CONFIG_DEBUG_FS
 	.debugfs_init       = msm_debugfs_init,
 	.debugfs_cleanup    = msm_debugfs_cleanup,

commit 30600a9092dc44694fbb4d0c3fa796e977fd5c96
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Sep 28 10:13:04 2013 -0400

    drm/msm: use drm_gem_dumb_destroy helper
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 9c871b554365..b3a2f1629041 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -697,7 +697,7 @@ static struct drm_driver msm_driver = {
 	.gem_vm_ops         = &vm_ops,
 	.dumb_create        = msm_gem_dumb_create,
 	.dumb_map_offset    = msm_gem_dumb_map_offset,
-	.dumb_destroy       = msm_gem_dumb_destroy,
+	.dumb_destroy       = drm_gem_dumb_destroy,
 #ifdef CONFIG_DEBUG_FS
 	.debugfs_init       = msm_debugfs_init,
 	.debugfs_cleanup    = msm_debugfs_cleanup,

commit 33b559630cf4345f2eeda849efd9b8548b192706
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Sep 28 10:07:06 2013 -0400

    drm/msm: deal with mach/iommu.h removal
    
    We still need an API exported by msm iommu driver (but not visible in
    any public header anymore).  For now, just declare the prototype
    ourselves, but when msm iommu driver provides a better option, use that
    instead.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index fe03f9c26092..9c871b554365 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -18,8 +18,6 @@
 #include "msm_drv.h"
 #include "msm_gpu.h"
 
-#include <mach/iommu.h>
-
 static void msm_fb_output_poll_changed(struct drm_device *dev)
 {
 	struct msm_drm_private *priv = dev->dev_private;
@@ -62,6 +60,8 @@ int msm_iommu_attach(struct drm_device *dev, struct iommu_domain *iommu,
 	int i, ret;
 
 	for (i = 0; i < cnt; i++) {
+		/* TODO maybe some day msm iommu won't require this hack: */
+		struct device *msm_iommu_get_ctx(const char *ctx_name);
 		struct device *ctx = msm_iommu_get_ctx(names[i]);
 		if (!ctx)
 			continue;

commit e4826a94c7444698725572f3def3686fb3f38d6d
Author: Thomas Meyer <thomas@m3y3r.de>
Date:   Mon Sep 16 23:19:54 2013 +0200

    drm/msm: Odd PTR_ERR usage
    
    The variable priv->kms is not initialized yet.
    
    Found by "scripts/coccinelle/tests/odd_ptr_err.cocci".
    PTR_ERR should access the value just tested by IS_ERR.
    
    Signed-off-by: Thomas Meyer <thomas@m3y3r.de>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 008d772384c7..fe03f9c26092 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -199,7 +199,7 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 		 * imx drm driver on iMX5
 		 */
 		dev_err(dev->dev, "failed to load kms\n");
-		ret = PTR_ERR(priv->kms);
+		ret = PTR_ERR(kms);
 		goto fail;
 	}
 

commit f816f272437f3a2be0c9254d4ab8f917950d86a0
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Sep 11 17:34:07 2013 -0400

    drm/msm: return -EBUSY if bo still active
    
    When we CPU_PREP a bo with NOSYNC flag (for example, to implement
    PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE), an -EBUSY return indicates to
    userspace that the bo is still busy.  Previously it was incorrectly
    returning 0 in this case.
    
    And while we're in there throw in an bit of extra sanity checking in
    case userspace tries to wait for a bogus fence.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 864c9773636b..008d772384c7 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -499,25 +499,41 @@ int msm_wait_fence_interruptable(struct drm_device *dev, uint32_t fence,
 		struct timespec *timeout)
 {
 	struct msm_drm_private *priv = dev->dev_private;
-	unsigned long timeout_jiffies = timespec_to_jiffies(timeout);
-	unsigned long start_jiffies = jiffies;
-	unsigned long remaining_jiffies;
 	int ret;
 
-	if (time_after(start_jiffies, timeout_jiffies))
-		remaining_jiffies = 0;
-	else
-		remaining_jiffies = timeout_jiffies - start_jiffies;
-
-	ret = wait_event_interruptible_timeout(priv->fence_event,
-			priv->completed_fence >= fence,
-			remaining_jiffies);
-	if (ret == 0) {
-		DBG("timeout waiting for fence: %u (completed: %u)",
-				fence, priv->completed_fence);
-		ret = -ETIMEDOUT;
-	} else if (ret != -ERESTARTSYS) {
-		ret = 0;
+	if (!priv->gpu)
+		return 0;
+
+	if (fence > priv->gpu->submitted_fence) {
+		DRM_ERROR("waiting on invalid fence: %u (of %u)\n",
+				fence, priv->gpu->submitted_fence);
+		return -EINVAL;
+	}
+
+	if (!timeout) {
+		/* no-wait: */
+		ret = fence_completed(dev, fence) ? 0 : -EBUSY;
+	} else {
+		unsigned long timeout_jiffies = timespec_to_jiffies(timeout);
+		unsigned long start_jiffies = jiffies;
+		unsigned long remaining_jiffies;
+
+		if (time_after(start_jiffies, timeout_jiffies))
+			remaining_jiffies = 0;
+		else
+			remaining_jiffies = timeout_jiffies - start_jiffies;
+
+		ret = wait_event_interruptible_timeout(priv->fence_event,
+				fence_completed(dev, fence),
+				remaining_jiffies);
+
+		if (ret == 0) {
+			DBG("timeout waiting for fence: %u (completed: %u)",
+					fence, priv->completed_fence);
+			ret = -ETIMEDOUT;
+		} else if (ret != -ERESTARTSYS) {
+			ret = 0;
+		}
 	}
 
 	return ret;

commit 7198e6b03155f6dadecadba004eb83b81a6ffe4c
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Jul 19 12:59:32 2013 -0400

    drm/msm: add a3xx gpu support
    
    Add initial support for a3xx 3d core.
    
    So far, with hardware that I've seen to date, we can have:
     + zero, one, or two z180 2d cores
     + a3xx or a2xx 3d core, which share a common CP (the firmware
       for the CP seems to implement some different PM4 packet types
       but the basics of cmdstream submission are the same)
    
    Which means that the eventual complete "class" hierarchy, once
    support for all past and present hw is in place, becomes:
     + msm_gpu
       + adreno_gpu
         + a3xx_gpu
         + a2xx_gpu
       + z180_gpu
    
    This commit splits out the parts that will eventually be common
    between a2xx/a3xx into adreno_gpu, and the parts that are even
    common to z180 into msm_gpu.
    
    Note that there is no cmdstream validation required.  All memory access
    from the GPU is via IOMMU/MMU.  So as long as you don't map silly things
    to the GPU, there isn't much damage that the GPU can do.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index b5ae0dbe1eb8..864c9773636b 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -16,6 +16,7 @@
  */
 
 #include "msm_drv.h"
+#include "msm_gpu.h"
 
 #include <mach/iommu.h>
 
@@ -135,6 +136,7 @@ static int msm_unload(struct drm_device *dev)
 {
 	struct msm_drm_private *priv = dev->dev_private;
 	struct msm_kms *kms = priv->kms;
+	struct msm_gpu *gpu = priv->gpu;
 
 	drm_kms_helper_poll_fini(dev);
 	drm_mode_config_cleanup(dev);
@@ -152,6 +154,12 @@ static int msm_unload(struct drm_device *dev)
 		kms->funcs->destroy(kms);
 	}
 
+	if (gpu) {
+		mutex_lock(&dev->struct_mutex);
+		gpu->funcs->pm_suspend(gpu);
+		gpu->funcs->destroy(gpu);
+		mutex_unlock(&dev->struct_mutex);
+	}
 
 	dev->dev_private = NULL;
 
@@ -176,6 +184,7 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 	dev->dev_private = priv;
 
 	priv->wq = alloc_ordered_workqueue("msm", 0);
+	init_waitqueue_head(&priv->fence_event);
 
 	INIT_LIST_HEAD(&priv->inactive_list);
 
@@ -240,12 +249,70 @@ static int msm_load(struct drm_device *dev, unsigned long flags)
 	return ret;
 }
 
+static void load_gpu(struct drm_device *dev)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+	struct msm_gpu *gpu;
+
+	if (priv->gpu)
+		return;
+
+	mutex_lock(&dev->struct_mutex);
+	gpu = a3xx_gpu_init(dev);
+	if (IS_ERR(gpu)) {
+		dev_warn(dev->dev, "failed to load a3xx gpu\n");
+		gpu = NULL;
+		/* not fatal */
+	}
+	mutex_unlock(&dev->struct_mutex);
+
+	if (gpu) {
+		int ret;
+		gpu->funcs->pm_resume(gpu);
+		ret = gpu->funcs->hw_init(gpu);
+		if (ret) {
+			dev_err(dev->dev, "gpu hw init failed: %d\n", ret);
+			gpu->funcs->destroy(gpu);
+			gpu = NULL;
+		}
+	}
+
+	priv->gpu = gpu;
+}
+
+static int msm_open(struct drm_device *dev, struct drm_file *file)
+{
+	struct msm_file_private *ctx;
+
+	/* For now, load gpu on open.. to avoid the requirement of having
+	 * firmware in the initrd.
+	 */
+	load_gpu(dev);
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	file->driver_priv = ctx;
+
+	return 0;
+}
+
 static void msm_preclose(struct drm_device *dev, struct drm_file *file)
 {
 	struct msm_drm_private *priv = dev->dev_private;
+	struct msm_file_private *ctx = file->driver_priv;
 	struct msm_kms *kms = priv->kms;
+
 	if (kms)
 		kms->funcs->preclose(kms, file);
+
+	mutex_lock(&dev->struct_mutex);
+	if (ctx == priv->lastctx)
+		priv->lastctx = NULL;
+	mutex_unlock(&dev->struct_mutex);
+
+	kfree(ctx);
 }
 
 static void msm_lastclose(struct drm_device *dev)
@@ -316,11 +383,30 @@ static void msm_disable_vblank(struct drm_device *dev, int crtc_id)
  */
 
 #ifdef CONFIG_DEBUG_FS
+static int msm_gpu_show(struct drm_device *dev, struct seq_file *m)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+	struct msm_gpu *gpu = priv->gpu;
+
+	if (gpu) {
+		seq_printf(m, "%s Status:\n", gpu->name);
+		gpu->funcs->show(gpu, m);
+	}
+
+	return 0;
+}
+
 static int msm_gem_show(struct drm_device *dev, struct seq_file *m)
 {
 	struct msm_drm_private *priv = dev->dev_private;
+	struct msm_gpu *gpu = priv->gpu;
+
+	if (gpu) {
+		seq_printf(m, "Active Objects (%s):\n", gpu->name);
+		msm_gem_describe_objects(&gpu->active_list, m);
+	}
 
-	seq_printf(m, "All Objects:\n");
+	seq_printf(m, "Inactive Objects:\n");
 	msm_gem_describe_objects(&priv->inactive_list, m);
 
 	return 0;
@@ -375,6 +461,7 @@ static int show_locked(struct seq_file *m, void *arg)
 }
 
 static struct drm_info_list msm_debugfs_list[] = {
+		{"gpu", show_locked, 0, msm_gpu_show},
 		{"gem", show_locked, 0, msm_gem_show},
 		{ "mm", show_locked, 0, msm_mm_show },
 		{ "fb", show_locked, 0, msm_fb_show },
@@ -404,6 +491,158 @@ static void msm_debugfs_cleanup(struct drm_minor *minor)
 }
 #endif
 
+/*
+ * Fences:
+ */
+
+int msm_wait_fence_interruptable(struct drm_device *dev, uint32_t fence,
+		struct timespec *timeout)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+	unsigned long timeout_jiffies = timespec_to_jiffies(timeout);
+	unsigned long start_jiffies = jiffies;
+	unsigned long remaining_jiffies;
+	int ret;
+
+	if (time_after(start_jiffies, timeout_jiffies))
+		remaining_jiffies = 0;
+	else
+		remaining_jiffies = timeout_jiffies - start_jiffies;
+
+	ret = wait_event_interruptible_timeout(priv->fence_event,
+			priv->completed_fence >= fence,
+			remaining_jiffies);
+	if (ret == 0) {
+		DBG("timeout waiting for fence: %u (completed: %u)",
+				fence, priv->completed_fence);
+		ret = -ETIMEDOUT;
+	} else if (ret != -ERESTARTSYS) {
+		ret = 0;
+	}
+
+	return ret;
+}
+
+/* call under struct_mutex */
+void msm_update_fence(struct drm_device *dev, uint32_t fence)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+
+	if (fence > priv->completed_fence) {
+		priv->completed_fence = fence;
+		wake_up_all(&priv->fence_event);
+	}
+}
+
+/*
+ * DRM ioctls:
+ */
+
+static int msm_ioctl_get_param(struct drm_device *dev, void *data,
+		struct drm_file *file)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+	struct drm_msm_param *args = data;
+	struct msm_gpu *gpu;
+
+	/* for now, we just have 3d pipe.. eventually this would need to
+	 * be more clever to dispatch to appropriate gpu module:
+	 */
+	if (args->pipe != MSM_PIPE_3D0)
+		return -EINVAL;
+
+	gpu = priv->gpu;
+
+	if (!gpu)
+		return -ENXIO;
+
+	return gpu->funcs->get_param(gpu, args->param, &args->value);
+}
+
+static int msm_ioctl_gem_new(struct drm_device *dev, void *data,
+		struct drm_file *file)
+{
+	struct drm_msm_gem_new *args = data;
+	return msm_gem_new_handle(dev, file, args->size,
+			args->flags, &args->handle);
+}
+
+#define TS(t) ((struct timespec){ .tv_sec = (t).tv_sec, .tv_nsec = (t).tv_nsec })
+
+static int msm_ioctl_gem_cpu_prep(struct drm_device *dev, void *data,
+		struct drm_file *file)
+{
+	struct drm_msm_gem_cpu_prep *args = data;
+	struct drm_gem_object *obj;
+	int ret;
+
+	obj = drm_gem_object_lookup(dev, file, args->handle);
+	if (!obj)
+		return -ENOENT;
+
+	ret = msm_gem_cpu_prep(obj, args->op, &TS(args->timeout));
+
+	drm_gem_object_unreference_unlocked(obj);
+
+	return ret;
+}
+
+static int msm_ioctl_gem_cpu_fini(struct drm_device *dev, void *data,
+		struct drm_file *file)
+{
+	struct drm_msm_gem_cpu_fini *args = data;
+	struct drm_gem_object *obj;
+	int ret;
+
+	obj = drm_gem_object_lookup(dev, file, args->handle);
+	if (!obj)
+		return -ENOENT;
+
+	ret = msm_gem_cpu_fini(obj);
+
+	drm_gem_object_unreference_unlocked(obj);
+
+	return ret;
+}
+
+static int msm_ioctl_gem_info(struct drm_device *dev, void *data,
+		struct drm_file *file)
+{
+	struct drm_msm_gem_info *args = data;
+	struct drm_gem_object *obj;
+	int ret = 0;
+
+	if (args->pad)
+		return -EINVAL;
+
+	obj = drm_gem_object_lookup(dev, file, args->handle);
+	if (!obj)
+		return -ENOENT;
+
+	args->offset = msm_gem_mmap_offset(obj);
+
+	drm_gem_object_unreference_unlocked(obj);
+
+	return ret;
+}
+
+static int msm_ioctl_wait_fence(struct drm_device *dev, void *data,
+		struct drm_file *file)
+{
+	struct drm_msm_wait_fence *args = data;
+	return msm_wait_fence_interruptable(dev, args->fence, &TS(args->timeout));
+}
+
+static const struct drm_ioctl_desc msm_ioctls[] = {
+	DRM_IOCTL_DEF_DRV(MSM_GET_PARAM,    msm_ioctl_get_param,    DRM_UNLOCKED|DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_NEW,      msm_ioctl_gem_new,      DRM_UNLOCKED|DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_INFO,     msm_ioctl_gem_info,     DRM_UNLOCKED|DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_PREP, msm_ioctl_gem_cpu_prep, DRM_UNLOCKED|DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_FINI, msm_ioctl_gem_cpu_fini, DRM_UNLOCKED|DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(MSM_GEM_SUBMIT,   msm_ioctl_gem_submit,   DRM_UNLOCKED|DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(MSM_WAIT_FENCE,   msm_ioctl_wait_fence,   DRM_UNLOCKED|DRM_AUTH),
+};
+
 static const struct vm_operations_struct vm_ops = {
 	.fault = msm_gem_fault,
 	.open = drm_gem_vm_open,
@@ -428,6 +667,7 @@ static struct drm_driver msm_driver = {
 	.driver_features    = DRIVER_HAVE_IRQ | DRIVER_GEM | DRIVER_MODESET,
 	.load               = msm_load,
 	.unload             = msm_unload,
+	.open               = msm_open,
 	.preclose           = msm_preclose,
 	.lastclose          = msm_lastclose,
 	.irq_handler        = msm_irq,
@@ -446,6 +686,8 @@ static struct drm_driver msm_driver = {
 	.debugfs_init       = msm_debugfs_init,
 	.debugfs_cleanup    = msm_debugfs_cleanup,
 #endif
+	.ioctls             = msm_ioctls,
+	.num_ioctls         = DRM_MSM_NUM_IOCTLS,
 	.fops               = &fops,
 	.name               = "msm",
 	.desc               = "MSM Snapdragon DRM",
@@ -514,6 +756,7 @@ static int __init msm_drm_register(void)
 {
 	DBG("init");
 	hdmi_register();
+	a3xx_register();
 	return platform_driver_register(&msm_platform_driver);
 }
 
@@ -522,6 +765,7 @@ static void __exit msm_drm_unregister(void)
 	DBG("fini");
 	platform_driver_unregister(&msm_platform_driver);
 	hdmi_unregister();
+	a3xx_unregister();
 }
 
 module_init(msm_drm_register);

commit c8afe684c95cd17cf4f273d81af369a0fdfa5a74
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Jun 26 12:44:06 2013 -0400

    drm/msm: basic KMS driver for snapdragon
    
    The snapdragon chips have multiple different display controllers,
    depending on which chip variant/version.  (As far as I can tell, current
    devices have either MDP3 or MDP4, and upcoming devices have MDSS.)  And
    then external to the display controller are HDMI, DSI, etc. blocks which
    may be shared across devices which have different display controller
    blocks.
    
    To more easily add support for different display controller blocks, the
    display controller specific bits are split out into a "kms" module,
    which provides the kms plane/crtc/encoder objects.
    
    The external HDMI, DSI, etc. blocks are part encoder, and part connector
    currently.  But I think I will pull in the drm_bridge patches from
    chromeos tree, and split them into a bridge+connector, with the
    registers that need to be set in modeset handled by the bridge.  This
    would remove the 'msm_connector' base class.  But some things need to be
    double checked to make sure I could get the correct ON/OFF sequencing..
    
    This patch adds support for mdp4 crtc (including hw cursor), dtv encoder
    (part of MDP4 block), and hdmi.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
new file mode 100644
index 000000000000..b5ae0dbe1eb8
--- /dev/null
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -0,0 +1,532 @@
+/*
+ * Copyright (C) 2013 Red Hat
+ * Author: Rob Clark <robdclark@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "msm_drv.h"
+
+#include <mach/iommu.h>
+
+static void msm_fb_output_poll_changed(struct drm_device *dev)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+	if (priv->fbdev)
+		drm_fb_helper_hotplug_event(priv->fbdev);
+}
+
+static const struct drm_mode_config_funcs mode_config_funcs = {
+	.fb_create = msm_framebuffer_create,
+	.output_poll_changed = msm_fb_output_poll_changed,
+};
+
+static int msm_fault_handler(struct iommu_domain *iommu, struct device *dev,
+		unsigned long iova, int flags, void *arg)
+{
+	DBG("*** fault: iova=%08lx, flags=%d", iova, flags);
+	return 0;
+}
+
+int msm_register_iommu(struct drm_device *dev, struct iommu_domain *iommu)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+	int idx = priv->num_iommus++;
+
+	if (WARN_ON(idx >= ARRAY_SIZE(priv->iommus)))
+		return -EINVAL;
+
+	priv->iommus[idx] = iommu;
+
+	iommu_set_fault_handler(iommu, msm_fault_handler, dev);
+
+	/* need to iommu_attach_device() somewhere??  on resume?? */
+
+	return idx;
+}
+
+int msm_iommu_attach(struct drm_device *dev, struct iommu_domain *iommu,
+		const char **names, int cnt)
+{
+	int i, ret;
+
+	for (i = 0; i < cnt; i++) {
+		struct device *ctx = msm_iommu_get_ctx(names[i]);
+		if (!ctx)
+			continue;
+		ret = iommu_attach_device(iommu, ctx);
+		if (ret) {
+			dev_warn(dev->dev, "could not attach iommu to %s", names[i]);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+#ifdef CONFIG_DRM_MSM_REGISTER_LOGGING
+static bool reglog = false;
+MODULE_PARM_DESC(reglog, "Enable register read/write logging");
+module_param(reglog, bool, 0600);
+#else
+#define reglog 0
+#endif
+
+void __iomem *msm_ioremap(struct platform_device *pdev, const char *name,
+		const char *dbgname)
+{
+	struct resource *res;
+	unsigned long size;
+	void __iomem *ptr;
+
+	if (name)
+		res = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);
+	else
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (!res) {
+		dev_err(&pdev->dev, "failed to get memory resource: %s\n", name);
+		return ERR_PTR(-EINVAL);
+	}
+
+	size = resource_size(res);
+
+	ptr = devm_ioremap_nocache(&pdev->dev, res->start, size);
+	if (!ptr) {
+		dev_err(&pdev->dev, "failed to ioremap: %s\n", name);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	if (reglog)
+		printk(KERN_DEBUG "IO:region %s %08x %08lx\n", dbgname, (u32)ptr, size);
+
+	return ptr;
+}
+
+void msm_writel(u32 data, void __iomem *addr)
+{
+	if (reglog)
+		printk(KERN_DEBUG "IO:W %08x %08x\n", (u32)addr, data);
+	writel(data, addr);
+}
+
+u32 msm_readl(const void __iomem *addr)
+{
+	u32 val = readl(addr);
+	if (reglog)
+		printk(KERN_ERR "IO:R %08x %08x\n", (u32)addr, val);
+	return val;
+}
+
+/*
+ * DRM operations:
+ */
+
+static int msm_unload(struct drm_device *dev)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+	struct msm_kms *kms = priv->kms;
+
+	drm_kms_helper_poll_fini(dev);
+	drm_mode_config_cleanup(dev);
+	drm_vblank_cleanup(dev);
+
+	pm_runtime_get_sync(dev->dev);
+	drm_irq_uninstall(dev);
+	pm_runtime_put_sync(dev->dev);
+
+	flush_workqueue(priv->wq);
+	destroy_workqueue(priv->wq);
+
+	if (kms) {
+		pm_runtime_disable(dev->dev);
+		kms->funcs->destroy(kms);
+	}
+
+
+	dev->dev_private = NULL;
+
+	kfree(priv);
+
+	return 0;
+}
+
+static int msm_load(struct drm_device *dev, unsigned long flags)
+{
+	struct platform_device *pdev = dev->platformdev;
+	struct msm_drm_private *priv;
+	struct msm_kms *kms;
+	int ret;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(dev->dev, "failed to allocate private data\n");
+		return -ENOMEM;
+	}
+
+	dev->dev_private = priv;
+
+	priv->wq = alloc_ordered_workqueue("msm", 0);
+
+	INIT_LIST_HEAD(&priv->inactive_list);
+
+	drm_mode_config_init(dev);
+
+	kms = mdp4_kms_init(dev);
+	if (IS_ERR(kms)) {
+		/*
+		 * NOTE: once we have GPU support, having no kms should not
+		 * be considered fatal.. ideally we would still support gpu
+		 * and (for example) use dmabuf/prime to share buffers with
+		 * imx drm driver on iMX5
+		 */
+		dev_err(dev->dev, "failed to load kms\n");
+		ret = PTR_ERR(priv->kms);
+		goto fail;
+	}
+
+	priv->kms = kms;
+
+	if (kms) {
+		pm_runtime_enable(dev->dev);
+		ret = kms->funcs->hw_init(kms);
+		if (ret) {
+			dev_err(dev->dev, "kms hw init failed: %d\n", ret);
+			goto fail;
+		}
+	}
+
+	dev->mode_config.min_width = 0;
+	dev->mode_config.min_height = 0;
+	dev->mode_config.max_width = 2048;
+	dev->mode_config.max_height = 2048;
+	dev->mode_config.funcs = &mode_config_funcs;
+
+	ret = drm_vblank_init(dev, 1);
+	if (ret < 0) {
+		dev_err(dev->dev, "failed to initialize vblank\n");
+		goto fail;
+	}
+
+	pm_runtime_get_sync(dev->dev);
+	ret = drm_irq_install(dev);
+	pm_runtime_put_sync(dev->dev);
+	if (ret < 0) {
+		dev_err(dev->dev, "failed to install IRQ handler\n");
+		goto fail;
+	}
+
+	platform_set_drvdata(pdev, dev);
+
+#ifdef CONFIG_DRM_MSM_FBDEV
+	priv->fbdev = msm_fbdev_init(dev);
+#endif
+
+	drm_kms_helper_poll_init(dev);
+
+	return 0;
+
+fail:
+	msm_unload(dev);
+	return ret;
+}
+
+static void msm_preclose(struct drm_device *dev, struct drm_file *file)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+	struct msm_kms *kms = priv->kms;
+	if (kms)
+		kms->funcs->preclose(kms, file);
+}
+
+static void msm_lastclose(struct drm_device *dev)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+	if (priv->fbdev) {
+		drm_modeset_lock_all(dev);
+		drm_fb_helper_restore_fbdev_mode(priv->fbdev);
+		drm_modeset_unlock_all(dev);
+	}
+}
+
+static irqreturn_t msm_irq(DRM_IRQ_ARGS)
+{
+	struct drm_device *dev = arg;
+	struct msm_drm_private *priv = dev->dev_private;
+	struct msm_kms *kms = priv->kms;
+	BUG_ON(!kms);
+	return kms->funcs->irq(kms);
+}
+
+static void msm_irq_preinstall(struct drm_device *dev)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+	struct msm_kms *kms = priv->kms;
+	BUG_ON(!kms);
+	kms->funcs->irq_preinstall(kms);
+}
+
+static int msm_irq_postinstall(struct drm_device *dev)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+	struct msm_kms *kms = priv->kms;
+	BUG_ON(!kms);
+	return kms->funcs->irq_postinstall(kms);
+}
+
+static void msm_irq_uninstall(struct drm_device *dev)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+	struct msm_kms *kms = priv->kms;
+	BUG_ON(!kms);
+	kms->funcs->irq_uninstall(kms);
+}
+
+static int msm_enable_vblank(struct drm_device *dev, int crtc_id)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+	struct msm_kms *kms = priv->kms;
+	if (!kms)
+		return -ENXIO;
+	DBG("dev=%p, crtc=%d", dev, crtc_id);
+	return kms->funcs->enable_vblank(kms, priv->crtcs[crtc_id]);
+}
+
+static void msm_disable_vblank(struct drm_device *dev, int crtc_id)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+	struct msm_kms *kms = priv->kms;
+	if (!kms)
+		return;
+	DBG("dev=%p, crtc=%d", dev, crtc_id);
+	kms->funcs->disable_vblank(kms, priv->crtcs[crtc_id]);
+}
+
+/*
+ * DRM debugfs:
+ */
+
+#ifdef CONFIG_DEBUG_FS
+static int msm_gem_show(struct drm_device *dev, struct seq_file *m)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+
+	seq_printf(m, "All Objects:\n");
+	msm_gem_describe_objects(&priv->inactive_list, m);
+
+	return 0;
+}
+
+static int msm_mm_show(struct drm_device *dev, struct seq_file *m)
+{
+	return drm_mm_dump_table(m, dev->mm_private);
+}
+
+static int msm_fb_show(struct drm_device *dev, struct seq_file *m)
+{
+	struct msm_drm_private *priv = dev->dev_private;
+	struct drm_framebuffer *fb, *fbdev_fb = NULL;
+
+	if (priv->fbdev) {
+		seq_printf(m, "fbcon ");
+		fbdev_fb = priv->fbdev->fb;
+		msm_framebuffer_describe(fbdev_fb, m);
+	}
+
+	mutex_lock(&dev->mode_config.fb_lock);
+	list_for_each_entry(fb, &dev->mode_config.fb_list, head) {
+		if (fb == fbdev_fb)
+			continue;
+
+		seq_printf(m, "user ");
+		msm_framebuffer_describe(fb, m);
+	}
+	mutex_unlock(&dev->mode_config.fb_lock);
+
+	return 0;
+}
+
+static int show_locked(struct seq_file *m, void *arg)
+{
+	struct drm_info_node *node = (struct drm_info_node *) m->private;
+	struct drm_device *dev = node->minor->dev;
+	int (*show)(struct drm_device *dev, struct seq_file *m) =
+			node->info_ent->data;
+	int ret;
+
+	ret = mutex_lock_interruptible(&dev->struct_mutex);
+	if (ret)
+		return ret;
+
+	ret = show(dev, m);
+
+	mutex_unlock(&dev->struct_mutex);
+
+	return ret;
+}
+
+static struct drm_info_list msm_debugfs_list[] = {
+		{"gem", show_locked, 0, msm_gem_show},
+		{ "mm", show_locked, 0, msm_mm_show },
+		{ "fb", show_locked, 0, msm_fb_show },
+};
+
+static int msm_debugfs_init(struct drm_minor *minor)
+{
+	struct drm_device *dev = minor->dev;
+	int ret;
+
+	ret = drm_debugfs_create_files(msm_debugfs_list,
+			ARRAY_SIZE(msm_debugfs_list),
+			minor->debugfs_root, minor);
+
+	if (ret) {
+		dev_err(dev->dev, "could not install msm_debugfs_list\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+static void msm_debugfs_cleanup(struct drm_minor *minor)
+{
+	drm_debugfs_remove_files(msm_debugfs_list,
+			ARRAY_SIZE(msm_debugfs_list), minor);
+}
+#endif
+
+static const struct vm_operations_struct vm_ops = {
+	.fault = msm_gem_fault,
+	.open = drm_gem_vm_open,
+	.close = drm_gem_vm_close,
+};
+
+static const struct file_operations fops = {
+	.owner              = THIS_MODULE,
+	.open               = drm_open,
+	.release            = drm_release,
+	.unlocked_ioctl     = drm_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl       = drm_compat_ioctl,
+#endif
+	.poll               = drm_poll,
+	.read               = drm_read,
+	.llseek             = no_llseek,
+	.mmap               = msm_gem_mmap,
+};
+
+static struct drm_driver msm_driver = {
+	.driver_features    = DRIVER_HAVE_IRQ | DRIVER_GEM | DRIVER_MODESET,
+	.load               = msm_load,
+	.unload             = msm_unload,
+	.preclose           = msm_preclose,
+	.lastclose          = msm_lastclose,
+	.irq_handler        = msm_irq,
+	.irq_preinstall     = msm_irq_preinstall,
+	.irq_postinstall    = msm_irq_postinstall,
+	.irq_uninstall      = msm_irq_uninstall,
+	.get_vblank_counter = drm_vblank_count,
+	.enable_vblank      = msm_enable_vblank,
+	.disable_vblank     = msm_disable_vblank,
+	.gem_free_object    = msm_gem_free_object,
+	.gem_vm_ops         = &vm_ops,
+	.dumb_create        = msm_gem_dumb_create,
+	.dumb_map_offset    = msm_gem_dumb_map_offset,
+	.dumb_destroy       = msm_gem_dumb_destroy,
+#ifdef CONFIG_DEBUG_FS
+	.debugfs_init       = msm_debugfs_init,
+	.debugfs_cleanup    = msm_debugfs_cleanup,
+#endif
+	.fops               = &fops,
+	.name               = "msm",
+	.desc               = "MSM Snapdragon DRM",
+	.date               = "20130625",
+	.major              = 1,
+	.minor              = 0,
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int msm_pm_suspend(struct device *dev)
+{
+	struct drm_device *ddev = dev_get_drvdata(dev);
+
+	drm_kms_helper_poll_disable(ddev);
+
+	return 0;
+}
+
+static int msm_pm_resume(struct device *dev)
+{
+	struct drm_device *ddev = dev_get_drvdata(dev);
+
+	drm_kms_helper_poll_enable(ddev);
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops msm_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(msm_pm_suspend, msm_pm_resume)
+};
+
+/*
+ * Platform driver:
+ */
+
+static int msm_pdev_probe(struct platform_device *pdev)
+{
+	return drm_platform_init(&msm_driver, pdev);
+}
+
+static int msm_pdev_remove(struct platform_device *pdev)
+{
+	drm_platform_exit(&msm_driver, pdev);
+
+	return 0;
+}
+
+static const struct platform_device_id msm_id[] = {
+	{ "mdp", 0 },
+	{ }
+};
+
+static struct platform_driver msm_platform_driver = {
+	.probe      = msm_pdev_probe,
+	.remove     = msm_pdev_remove,
+	.driver     = {
+		.owner  = THIS_MODULE,
+		.name   = "msm",
+		.pm     = &msm_pm_ops,
+	},
+	.id_table   = msm_id,
+};
+
+static int __init msm_drm_register(void)
+{
+	DBG("init");
+	hdmi_register();
+	return platform_driver_register(&msm_platform_driver);
+}
+
+static void __exit msm_drm_unregister(void)
+{
+	DBG("fini");
+	platform_driver_unregister(&msm_platform_driver);
+	hdmi_unregister();
+}
+
+module_init(msm_drm_register);
+module_exit(msm_drm_unregister);
+
+MODULE_AUTHOR("Rob Clark <robdclark@gmail.com");
+MODULE_DESCRIPTION("MSM DRM Driver");
+MODULE_LICENSE("GPL");
