commit 9413b9a690ec8aeaedea74bb875079d36f295304
Merge: 107821669a9c efe792f39ddb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 8 11:33:38 2020 -0700

    Merge tag 'drm-next-msm-5.8-2020-06-08' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm msm updates from Dave Airlie:
     "This tree has been in next for a couple of weeks, but Rob missed an
      arm32 build issue, so I was awaiting the tree with a patch reverted.
    
       - new gpu support: a405, a640, a650
    
       - dpu: color processing support
    
       - mdp5: support for msm8x36 (the thing with a405)
    
       - some prep work for per-context pagetables (ie the part that does
         not depend on in-flight iommu patches)
    
       - last but not least, UABI update for submit ioctl to support syncobj
         (from Bas)"
    
    * tag 'drm-next-msm-5.8-2020-06-08' of git://anongit.freedesktop.org/drm/drm: (30 commits)
      Revert "drm/msm/dpu: add support for clk and bw scaling for display"
      drm/msm/a6xx: skip HFI set freq if GMU is powered down
      drm/msm: Update the MMU helper function APIs
      drm/msm: Refactor address space initialization
      drm/msm: Attach the IOMMU device during initialization
      drm/msm/dpu: dpu_setup_dspp_pcc() can be static
      drm/msm/a6xx: a6xx_hfi_send_start() can be static
      drm/msm/a4xx: add a405_registers for a405 device
      drm/msm/a4xx: add adreno a405 support
      drm/msm/a6xx: update a6xx_hw_init for A640 and A650
      drm/msm/a6xx: enable GMU log
      drm/msm/a6xx: update pdc/rscc GMU registers for A640/A650
      drm/msm/a6xx: A640/A650 GMU firmware path
      drm/msm/a6xx: HFI v2 for A640 and A650
      drm/msm/a6xx: add A640/A650 to gpulist
      drm/msm/a6xx: use msm_gem for GMU memory objects
      drm/msm: add internal MSM_BO_MAP_PRIV flag
      drm/msm: add msm_gem_get_and_pin_iova_range
      drm/msm: Check for powered down HW in the devfreq callbacks
      drm/msm/dpu: update bandwidth threshold check
      ...

commit ccac7ce373c1b5175bcf733fe6223129b8975788
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Fri May 22 16:03:15 2020 -0600

    drm/msm: Refactor address space initialization
    
    Refactor how address space initialization works. Instead of having the
    address space function create the MMU object (and thus require separate but
    equal functions for gpummu and iommu) use a single function and pass the
    MMU struct in. Make the generic code cleaner by using target specific
    functions to create the address space so a2xx can do its own thing in its
    own space.  For all the other targets use a generic helper to initialize
    IOMMU but leave the door open for newer targets to use customization
    if they need it.
    
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    [squash in rebase fixups]
    Signed-off-by: Rob Clark <robdclark@chromium.org>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index be5bc2e8425c..d496b68e58a9 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -21,8 +21,6 @@ struct msm_gpu_state;
 
 struct msm_gpu_config {
 	const char *ioname;
-	uint64_t va_start;
-	uint64_t va_end;
 	unsigned int nr_rings;
 };
 
@@ -64,6 +62,8 @@ struct msm_gpu_funcs {
 	int (*gpu_state_put)(struct msm_gpu_state *state);
 	unsigned long (*gpu_get_freq)(struct msm_gpu *gpu);
 	void (*gpu_set_freq)(struct msm_gpu *gpu, unsigned long freq);
+	struct msm_gem_address_space *(*create_address_space)
+		(struct msm_gpu *gpu, struct platform_device *pdev);
 };
 
 struct msm_gpu {

commit 7ce84471e3c72e23020b046714358b45a7ffe9ab
Author: Wambui Karuga <wambui.karugax@gmail.com>
Date:   Tue Mar 10 16:31:21 2020 +0300

    drm: convert .debugfs_init() hook to return void.
    
    As a result of commit 987d65d01356 (drm: debugfs: make
    drm_debugfs_create_files() never fail) and changes to various debugfs
    functions in drm/core and across various drivers, there is no need for
    the drm_driver.debugfs_init() hook to have a return value. Therefore,
    declare it as void.
    
    This also includes refactoring all users of the .debugfs_init() hook to
    return void across the subsystem.
    
    v2: include changes to the hook and drivers that use it in one patch to
    prevent driver breakage and enable individual successful compilation of
    this change.
    
    References: https://lists.freedesktop.org/archives/dri-devel/2020-February/257183.html
    Signed-off-by: Wambui Karuga <wambui.karugax@gmail.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200310133121.27913-18-wambui.karugax@gmail.com

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index be5bc2e8425c..6ccae4ba905c 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -57,7 +57,7 @@ struct msm_gpu_funcs {
 	void (*show)(struct msm_gpu *gpu, struct msm_gpu_state *state,
 			struct drm_printer *p);
 	/* for generation specific debugfs: */
-	int (*debugfs_init)(struct msm_gpu *gpu, struct drm_minor *minor);
+	void (*debugfs_init)(struct msm_gpu *gpu, struct drm_minor *minor);
 #endif
 	unsigned long (*gpu_busy)(struct msm_gpu *gpu);
 	struct msm_gpu_state *(*gpu_state_get)(struct msm_gpu *gpu);

commit 00bb9243d346cf749919035f2473d30fe9496153
Author: Brian Masney <masneyb@onstation.org>
Date:   Thu Nov 21 20:26:43 2019 -0500

    drm/msm/gpu: add support for ocmem interconnect path
    
    Some A3xx and all A4xx Adreno GPUs do not have GMEM inside the GPU core
    and must use the On Chip MEMory (OCMEM) in order to be functional.
    There's a separate interconnect path that needs to be setup to OCMEM.
    Add support for this second path to the GPU core.
    
    In the downstream MSM 3.4 sources, the two interconnect paths for the
    GPU are between:
    
      - MSM_BUS_MASTER_GRAPHICS_3D and MSM_BUS_SLAVE_EBI_CH0
      - MSM_BUS_MASTER_V_OCMEM_GFX3D and MSM_BUS_SLAVE_OCMEM
    
    Signed-off-by: Brian Masney <masneyb@onstation.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Rob Clark <robdclark@chromium.org>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index ab8f0f9c9dc8..be5bc2e8425c 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -111,8 +111,15 @@ struct msm_gpu {
 	struct clk *ebi1_clk, *core_clk, *rbbmtimer_clk;
 	uint32_t fast_rate;
 
+	/* The gfx-mem interconnect path that's used by all GPU types. */
 	struct icc_path *icc_path;
 
+	/*
+	 * Second interconnect path for some A3xx and all A4xx GPUs to the
+	 * On Chip MEMory (OCMEM).
+	 */
+	struct icc_path *ocmem_icc_path;
+
 	/* Hang and Inactivity Detection:
 	 */
 #define DRM_MSM_INACTIVE_PERIOD   66 /* in ms (roughly four frames) */

commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index f2739cd97cea..ab8f0f9c9dc8 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -1,18 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) 2013 Red Hat
  * Author: Rob Clark <robdclark@gmail.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef __MSM_GPU_H__

commit 48dc4241c9cd62bfbe33625e669e21d7081d35fa
Author: Rob Clark <robdclark@chromium.org>
Date:   Tue Apr 16 16:13:28 2019 -0700

    drm/msm: add param to retrieve # of GPU faults (global)
    
    For KHR_robustness, userspace wants to know two things, the count of GPU
    faults globally, and the count of faults attributed to a given context.
    This patch providees the former, and the next patch provides the latter.
    
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Reviewed-by: Jordan Crouse <jcrouse@codeaurora.org>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 6241986bab51..f2739cd97cea 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -104,6 +104,9 @@ struct msm_gpu {
 	/* does gpu need hw_init? */
 	bool needs_hw_init;
 
+	/* number of GPU hangs (for all contexts) */
+	int global_faults;
+
 	/* worker for handling active-list retiring: */
 	struct work_struct retire_work;
 

commit fcf9d0b7d2f50003efe0ba280be458f27671010d
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Tue Feb 12 11:52:38 2019 +0200

    drm/msm/a6xx: Add support for an interconnect path
    
    Try to get the interconnect path for the GPU and vote for the maximum
    bandwidth to support all frequencies. This is needed for performance.
    Later we will want to scale the bandwidth based on the frequency to
    also optimize for power but that will require some device tree
    infrastructure that does not yet exist.
    
    v6: use icc_set_bw() instead of icc_set()
    v5: Remove hardcoded interconnect name and just use the default
    v4: Don't use a port string at all to skip the need for names in the DT
    v3: Use macros and change port string per Georgi Djakov
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Acked-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Evan Green <evgreen@chromium.org>
    Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index ca17086f72c9..6241986bab51 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -19,6 +19,7 @@
 #define __MSM_GPU_H__
 
 #include <linux/clk.h>
+#include <linux/interconnect.h>
 #include <linux/regulator/consumer.h>
 
 #include "msm_drv.h"
@@ -118,6 +119,8 @@ struct msm_gpu {
 	struct clk *ebi1_clk, *core_clk, *rbbmtimer_clk;
 	uint32_t fast_rate;
 
+	struct icc_path *icc_path;
+
 	/* Hang and Inactivity Detection:
 	 */
 #define DRM_MSM_INACTIVE_PERIOD   66 /* in ms (roughly four frames) */

commit 878411aef631e4e2dd8d6c7cdb01e95a076cbcb9
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Tue Dec 18 11:32:36 2018 -0700

    drm/msm/gpu: Remove hardcoded interrupt name
    
    Every GPU core only has one interrupt so there isn't any
    value in looking up the interrupt by name. Remove the name (which
    is legacy anyway) and use platform_get_irq() instead.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 95170dee9d7a..ca17086f72c9 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -31,7 +31,6 @@ struct msm_gpu_state;
 
 struct msm_gpu_config {
 	const char *ioname;
-	const char *irqname;
 	uint64_t va_start;
 	uint64_t va_end;
 	unsigned int nr_rings;

commit c878a628e0c483ec36fa70f4590e4a58e34a6e49
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Aug 13 23:23:44 2018 +0200

    drm/msm/gpu: fix building without debugfs
    
    When debugfs is disabled, but coredump is turned on, the adreno driver fails to build:
    
    drivers/gpu/drm/msm/adreno/a3xx_gpu.c:460:4: error: 'struct msm_gpu_funcs' has no member named 'show'
       .show = adreno_show,
        ^~~~
    drivers/gpu/drm/msm/adreno/a3xx_gpu.c:460:11: note: (near initialization for 'funcs.base')
    drivers/gpu/drm/msm/adreno/a3xx_gpu.c:460:11: error: initialization of 'void (*)(struct msm_gpu *, struct msm_gem_submit *, struct msm_file_private *)' from incompatible pointer type 'void (*)(struct msm_gpu *, struct msm_gpu_state *, struct drm_printer *)' [-Werror=incompatible-pointer-types]
    drivers/gpu/drm/msm/adreno/a3xx_gpu.c:460:11: note: (near initialization for 'funcs.base.submit')
    drivers/gpu/drm/msm/adreno/a4xx_gpu.c:546:4: error: 'struct msm_gpu_funcs' has no member named 'show'
    drivers/gpu/drm/msm/adreno/a5xx_gpu.c:1460:4: error: 'struct msm_gpu_funcs' has no member named 'show'
    drivers/gpu/drm/msm/adreno/a6xx_gpu.c:769:4: error: 'struct msm_gpu_funcs' has no member named 'show'
    drivers/gpu/drm/msm/msm_gpu.c: In function 'msm_gpu_devcoredump_read':
    drivers/gpu/drm/msm/msm_gpu.c:289:12: error: 'const struct msm_gpu_funcs' has no member named 'show'
    
    Adjust the #ifdef to make it build again.
    
    Fixes: c0fec7f562ec ("drm/msm/gpu: Capture the GPU state on a GPU hang")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index efb49bb64191..95170dee9d7a 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -63,7 +63,7 @@ struct msm_gpu_funcs {
 	struct msm_ringbuffer *(*active_ring)(struct msm_gpu *gpu);
 	void (*recover)(struct msm_gpu *gpu);
 	void (*destroy)(struct msm_gpu *gpu);
-#ifdef CONFIG_DEBUG_FS
+#if defined(CONFIG_DEBUG_FS) || defined(CONFIG_DEV_COREDUMP)
 	/* show GPU status in debugfs: */
 	void (*show)(struct msm_gpu *gpu, struct msm_gpu_state *state,
 			struct drm_printer *p);

commit 1df4289d5b23178a8a2c38ca766feb3d9c40d9fb
Author: Sharat Masetty <smasetty@codeaurora.org>
Date:   Thu Nov 1 20:16:45 2018 +0530

    drm/msm: Optimize adreno_show_object()
    
    When the userspace tries to read the crashstate dump, the read side
    implementation in the driver currently ascii85 encodes all the binary
    buffers and it does this each time the read system call is called.
    A userspace tool like cat typically does a page by page read and the
    number of read calls depends on the size of the data captured by the
    driver. This is certainly not desirable and does not scale well with
    large captures.
    
    This patch encodes the buffer only once in the read path. With this there
    is an immediate >10X speed improvement in crashstate save time.
    
    Signed-off-by: Sharat Masetty <smasetty@codeaurora.org>
    Reviewed-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index f82bac086666..efb49bb64191 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -187,6 +187,7 @@ struct msm_gpu_state_bo {
 	u64 iova;
 	size_t size;
 	void *data;
+	bool encoded;
 };
 
 struct msm_gpu_state {
@@ -201,6 +202,7 @@ struct msm_gpu_state {
 		u32 wptr;
 		void *data;
 		int data_size;
+		bool encoded;
 	} ring[MSM_GPU_MAX_RINGS];
 
 	int nr_registers;

commit de0a3d094de0858f091cf353c437e912ca41a506
Author: Sharat Masetty <smasetty@codeaurora.org>
Date:   Thu Oct 4 15:11:42 2018 +0530

    drm/msm: re-factor devfreq code
    
    The devfreq framework requires the drivers to provide busy time estimations.
    The GPU driver relies on the hardware performance counteres for the busy time
    estimations, but different hardware revisions have counters which can be
    sourced from different clocks. So the busy time estimation will be target
    dependent.  Additionally on targets where the clocks are completely controlled
    by the on chip microcontroller, fetching and setting the current GPU frequency
    will be different. This patch aims to embrace these differences by re-factoring
    the devfreq code a bit.
    
    Signed-off-by: Sharat Masetty <smasetty@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 9122ee6e55e4..f82bac086666 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -70,9 +70,11 @@ struct msm_gpu_funcs {
 	/* for generation specific debugfs: */
 	int (*debugfs_init)(struct msm_gpu *gpu, struct drm_minor *minor);
 #endif
-	int (*gpu_busy)(struct msm_gpu *gpu, uint64_t *value);
+	unsigned long (*gpu_busy)(struct msm_gpu *gpu);
 	struct msm_gpu_state *(*gpu_state_get)(struct msm_gpu *gpu);
 	int (*gpu_state_put)(struct msm_gpu_state *state);
+	unsigned long (*gpu_get_freq)(struct msm_gpu *gpu);
+	void (*gpu_set_freq)(struct msm_gpu *gpu, unsigned long freq);
 };
 
 struct msm_gpu {
@@ -264,6 +266,7 @@ static inline void gpu_write64(struct msm_gpu *gpu, u32 lo, u32 hi, u64 val)
 
 int msm_gpu_pm_suspend(struct msm_gpu *gpu);
 int msm_gpu_pm_resume(struct msm_gpu *gpu);
+void msm_gpu_resume_devfreq(struct msm_gpu *gpu);
 
 int msm_gpu_hw_init(struct msm_gpu *gpu);
 

commit 8e54eea503caec53d39e67407ffa785690f38ba4
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Mon Aug 6 11:33:21 2018 -0600

    drm/msm: Add a helper function to parse clock names
    
    Add a helper function to parse the clock names and set up
    the bulk data so we can take advantage of the bulk clock
    functions instead of rolling our own. This is added
    as a helper function so the upcoming a6xx GMU code can
    also take advantage of it.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 1c6105bc55c7..9122ee6e55e4 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -112,7 +112,7 @@ struct msm_gpu {
 
 	/* Power Control: */
 	struct regulator *gpu_reg, *gpu_cx;
-	struct clk **grp_clks;
+	struct clk_bulk_data *grp_clks;
 	int nr_clocks;
 	struct clk *ebi1_clk, *core_clk, *rbbmtimer_clk;
 	uint32_t fast_rate;

commit 3530a17f4dc8f1f667fee14c16f229162daa79bb
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Jul 26 14:39:25 2018 +0200

    drm/msm/gpu: avoid deprecated do_gettimeofday
    
    All users of do_gettimeofday() have been removed, but this one recently
    crept in, along with an incorrect printing of the microseconds portion.
    
    This converts it to using ktime_get_real_timespec64() as a direct
    replacement, and adds the leading zeroes. I considered using monotonic
    times (ktime_get()) instead, but as this timestamp appears to only
    be used for humans rather than compared with other timestamps, the
    real time domain is probably good enough.
    
    Fixes: e43b045e2c82 ("drm/msm/gpu: Capture the state of the GPU")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 57380ef8d1f7..1c6105bc55c7 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -189,7 +189,7 @@ struct msm_gpu_state_bo {
 
 struct msm_gpu_state {
 	struct kref ref;
-	struct timeval time;
+	struct timespec64 time;
 
 	struct {
 		u64 iova;

commit cdb95931dea32981545e34a3b1dfc9e172425d95
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Tue Jul 24 10:33:31 2018 -0600

    drm/msm/gpu: Add the buffer objects from the submit to the crash dump
    
    For hangs, dump copy out the contents of the buffer objects attached to the
    guilty submission and print them in the crash dump report.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 878090b57e90..57380ef8d1f7 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -181,6 +181,12 @@ struct msm_gpu_submitqueue {
 	struct kref ref;
 };
 
+struct msm_gpu_state_bo {
+	u64 iova;
+	size_t size;
+	void *data;
+};
+
 struct msm_gpu_state {
 	struct kref ref;
 	struct timeval time;
@@ -202,6 +208,9 @@ struct msm_gpu_state {
 
 	char *comm;
 	char *cmd;
+
+	int nr_bos;
+	struct msm_gpu_state_bo *bos;
 };
 
 static inline void gpu_write(struct msm_gpu *gpu, u32 reg, u32 data)

commit 43a56687d15db09f3cf7b9d53b182bdef86c17c0
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Tue Jul 24 10:33:29 2018 -0600

    drm/msm/adreno: Add ringbuffer data to the GPU state
    
    Add the contents of each ringbuffer to the GPU state and dump the
    data in the crash file encoded with ascii85. To save space only
    the used portions of the ringbuffer are dumped.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index b1cb44922441..878090b57e90 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -191,6 +191,8 @@ struct msm_gpu_state {
 		u32 seqno;
 		u32 rptr;
 		u32 wptr;
+		void *data;
+		int data_size;
 	} ring[MSM_GPU_MAX_RINGS];
 
 	int nr_registers;

commit c0fec7f562ec76404ef0f074a89113a703587f3d
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Tue Jul 24 10:33:27 2018 -0600

    drm/msm/gpu: Capture the GPU state on a GPU hang
    
    Capture the GPU state on a GPU hang and store it for later playback
    via the devcoredump facility. Only one crash state is stored at a
    time on the assumption that the first hang is usually the most
    interesting. The existing crash state can be cleared after capturing
    it and then a new one will be captured on the next hang.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index d204eca8518e..b1cb44922441 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -66,13 +66,13 @@ struct msm_gpu_funcs {
 #ifdef CONFIG_DEBUG_FS
 	/* show GPU status in debugfs: */
 	void (*show)(struct msm_gpu *gpu, struct msm_gpu_state *state,
-			struct seq_file *m);
+			struct drm_printer *p);
 	/* for generation specific debugfs: */
 	int (*debugfs_init)(struct msm_gpu *gpu, struct drm_minor *minor);
 #endif
 	int (*gpu_busy)(struct msm_gpu *gpu, uint64_t *value);
 	struct msm_gpu_state *(*gpu_state_get)(struct msm_gpu *gpu);
-	void (*gpu_state_put)(struct msm_gpu_state *state);
+	int (*gpu_state_put)(struct msm_gpu_state *state);
 };
 
 struct msm_gpu {
@@ -133,6 +133,8 @@ struct msm_gpu {
 		u64 busy_cycles;
 		ktime_t time;
 	} devfreq;
+
+	struct msm_gpu_state *crashstate;
 };
 
 /* It turns out that all targets use the same ringbuffer size */
@@ -180,6 +182,7 @@ struct msm_gpu_submitqueue {
 };
 
 struct msm_gpu_state {
+	struct kref ref;
 	struct timeval time;
 
 	struct {
@@ -194,6 +197,9 @@ struct msm_gpu_state {
 	u32 *registers;
 
 	u32 rbbm_status;
+
+	char *comm;
+	char *cmd;
 };
 
 static inline void gpu_write(struct msm_gpu *gpu, u32 reg, u32 data)
@@ -275,4 +281,32 @@ static inline void msm_submitqueue_put(struct msm_gpu_submitqueue *queue)
 		kref_put(&queue->ref, msm_submitqueue_destroy);
 }
 
+static inline struct msm_gpu_state *msm_gpu_crashstate_get(struct msm_gpu *gpu)
+{
+	struct msm_gpu_state *state = NULL;
+
+	mutex_lock(&gpu->dev->struct_mutex);
+
+	if (gpu->crashstate) {
+		kref_get(&gpu->crashstate->ref);
+		state = gpu->crashstate;
+	}
+
+	mutex_unlock(&gpu->dev->struct_mutex);
+
+	return state;
+}
+
+static inline void msm_gpu_crashstate_put(struct msm_gpu *gpu)
+{
+	mutex_lock(&gpu->dev->struct_mutex);
+
+	if (gpu->crashstate) {
+		if (gpu->funcs->gpu_state_put(gpu->crashstate))
+			gpu->crashstate = NULL;
+	}
+
+	mutex_unlock(&gpu->dev->struct_mutex);
+}
+
 #endif /* __MSM_GPU_H__ */

commit 4f776f4511c7f7b6576dfc38c609b168b9188d72
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Tue Jul 24 10:33:25 2018 -0600

    drm/msm/gpu: Convert the GPU show function to use the GPU state
    
    Convert the existing GPU show function to use the GPU state to
    dump the information rather than reading it directly from the hardware.
    This will require an additional step to capture the state before
    dumping it for the existing nodes but it will greatly facilitate reusing
    the same code for dumping a previously captured state from a GPU hang.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index de71cc04ecf3..d204eca8518e 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -65,7 +65,8 @@ struct msm_gpu_funcs {
 	void (*destroy)(struct msm_gpu *gpu);
 #ifdef CONFIG_DEBUG_FS
 	/* show GPU status in debugfs: */
-	void (*show)(struct msm_gpu *gpu, struct seq_file *m);
+	void (*show)(struct msm_gpu *gpu, struct msm_gpu_state *state,
+			struct seq_file *m);
 	/* for generation specific debugfs: */
 	int (*debugfs_init)(struct msm_gpu *gpu, struct drm_minor *minor);
 #endif

commit e00e473d9817e03cddbaf181a491c42ae8373482
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Tue Jul 24 10:33:24 2018 -0600

    drm/msm/gpu: Capture the state of the GPU
    
    Add the infrastructure to capture the current state of the GPU and
    store it in memory so that it can be dumped later.
    
    For now grab the same basic ringbuffer information and registers
    that are provided by the debugfs 'gpu' node but obviously this should
    be extended to capture a much larger set of GPU information.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index b8241179175a..de71cc04ecf3 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -27,6 +27,7 @@
 
 struct msm_gem_submit;
 struct msm_gpu_perfcntr;
+struct msm_gpu_state;
 
 struct msm_gpu_config {
 	const char *ioname;
@@ -69,6 +70,8 @@ struct msm_gpu_funcs {
 	int (*debugfs_init)(struct msm_gpu *gpu, struct drm_minor *minor);
 #endif
 	int (*gpu_busy)(struct msm_gpu *gpu, uint64_t *value);
+	struct msm_gpu_state *(*gpu_state_get)(struct msm_gpu *gpu);
+	void (*gpu_state_put)(struct msm_gpu_state *state);
 };
 
 struct msm_gpu {
@@ -175,6 +178,23 @@ struct msm_gpu_submitqueue {
 	struct kref ref;
 };
 
+struct msm_gpu_state {
+	struct timeval time;
+
+	struct {
+		u64 iova;
+		u32 fence;
+		u32 seqno;
+		u32 rptr;
+		u32 wptr;
+	} ring[MSM_GPU_MAX_RINGS];
+
+	int nr_registers;
+	u32 *registers;
+
+	u32 rbbm_status;
+};
+
 static inline void gpu_write(struct msm_gpu *gpu, u32 reg, u32 data)
 {
 	msm_writel(data, gpu->mmio + (reg << 2));

commit 331dc0bc195bb77fcbe60b4513464b406a6d20cb
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Dec 13 15:12:56 2017 -0500

    drm/msm: add a5xx specific debugfs
    
    Add some debugfs to dump out PFP and ME microcontroller state, as well
    as some of the queues (MEQ and ROQ).  Also add a debugfs file to trigger
    a GPU reset (and reloading the firmware on next submit).
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index fccfccd303af..b8241179175a 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -65,6 +65,8 @@ struct msm_gpu_funcs {
 #ifdef CONFIG_DEBUG_FS
 	/* show GPU status in debugfs: */
 	void (*show)(struct msm_gpu *gpu, struct seq_file *m);
+	/* for generation specific debugfs: */
+	int (*debugfs_init)(struct msm_gpu *gpu, struct drm_minor *minor);
 #endif
 	int (*gpu_busy)(struct msm_gpu *gpu, uint64_t *value);
 };

commit f91c14ab448af4d9d57350301dd9d6b6a7b6128a
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Wed Jan 10 10:41:54 2018 -0700

    drm/msm: Add devfreq support for the GPU
    
    Add support for devfreq to dynamically control the GPU frequency.
    By default try to use the 'simple_ondemand' governor which can
    adjust the frequency based on GPU load.
    
    v2: Fix __aeabi_uldivmod issue from the 0 day bot and use
    devfreq_recommended_opp() as suggested by Rob.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 0de26b6f3732..fccfccd303af 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -66,6 +66,7 @@ struct msm_gpu_funcs {
 	/* show GPU status in debugfs: */
 	void (*show)(struct msm_gpu *gpu, struct seq_file *m);
 #endif
+	int (*gpu_busy)(struct msm_gpu *gpu, uint64_t *value);
 };
 
 struct msm_gpu {
@@ -120,6 +121,12 @@ struct msm_gpu {
 	struct work_struct recover_work;
 
 	struct drm_gem_object *memptrs_bo;
+
+	struct {
+		struct devfreq *devfreq;
+		u64 busy_cycles;
+		ktime_t time;
+	} devfreq;
 };
 
 /* It turns out that all targets use the same ringbuffer size */

commit 1babd706b455802d17762cb44ecdfcd953bb3dd5
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Tue Nov 21 12:40:53 2017 -0700

    drm/msm/gpu: Remove unused bus scaling code
    
    Remove the downstream bus scaling code. It isn't needed for for
    compatibility with a downstream or vendor kernel. Get it out of the
    way to clear space for devfreq support.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index e113d64574d3..0de26b6f3732 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -108,12 +108,7 @@ struct msm_gpu {
 	struct clk **grp_clks;
 	int nr_clocks;
 	struct clk *ebi1_clk, *core_clk, *rbbmtimer_clk;
-	uint32_t fast_rate, bus_freq;
-
-#ifdef DOWNSTREAM_CONFIG_MSM_BUS_SCALING
-	struct msm_bus_scale_pdata *bus_scale_table;
-	uint32_t bsc;
-#endif
+	uint32_t fast_rate;
 
 	/* Hang and Inactivity Detection:
 	 */

commit 4d87fc32dfd20ad0d4ffd5204f6e5d41d281e128
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Fri Oct 20 11:07:00 2017 -0600

    drm/msm: Make the value of RB_CNTL (almost) generic
    
    We use a global ringbuffer size and block size for all targets and
    at least for 5XX preemption we need to know the value the RB_CNTL
    in several locations so it makes sense to calculate it once and use
    it everywhere.
    
    The only monkey wrench is that we need to disable the RPTR shadow
    for A430 targets but that only needs to be done once and doesn't
    affect A5XX so we can or in the value at init time.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 1be0317bb2c0..e113d64574d3 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -129,6 +129,11 @@ struct msm_gpu {
 
 /* It turns out that all targets use the same ringbuffer size */
 #define MSM_GPU_RINGBUFFER_SZ SZ_32K
+#define MSM_GPU_RINGBUFFER_BLKSIZE 32
+
+#define MSM_GPU_RB_CNTL_DEFAULT \
+		(AXXX_CP_RB_CNTL_BUFSZ(ilog2(MSM_GPU_RINGBUFFER_SZ / 8)) | \
+		AXXX_CP_RB_CNTL_BLKSZ(ilog2(MSM_GPU_RINGBUFFER_BLKSIZE / 8)))
 
 static inline bool msm_gpu_active(struct msm_gpu *gpu)
 {

commit f97decac5f4c2d862e5b848694e3ffb29fc8acdd
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Fri Oct 20 11:06:57 2017 -0600

    drm/msm: Support multiple ringbuffers
    
    Add the infrastructure to support the idea of multiple ringbuffers.
    Assign each ringbuffer an id and use that as an index for the various
    ring specific operations.
    
    The biggest delta is to support legacy fences. Each fence gets its own
    sequence number but the legacy functions expect to use a unique integer.
    To handle this we return a unique identifier for each submission but
    map it to a specific ring/sequence under the covers. Newer users use
    a dma_fence pointer anyway so they don't care about the actual sequence
    ID or ring.
    
    The actual mechanics for multiple ringbuffers are very target specific
    so this code just allows for the possibility but still only defines
    one ringbuffer for each target family.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 8ddda059de34..1be0317bb2c0 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -33,7 +33,7 @@ struct msm_gpu_config {
 	const char *irqname;
 	uint64_t va_start;
 	uint64_t va_end;
-	unsigned int ringsz;
+	unsigned int nr_rings;
 };
 
 /* So far, with hardware that I've seen to date, we can have:
@@ -57,8 +57,9 @@ struct msm_gpu_funcs {
 	int (*pm_resume)(struct msm_gpu *gpu);
 	void (*submit)(struct msm_gpu *gpu, struct msm_gem_submit *submit,
 			struct msm_file_private *ctx);
-	void (*flush)(struct msm_gpu *gpu);
+	void (*flush)(struct msm_gpu *gpu, struct msm_ringbuffer *ring);
 	irqreturn_t (*irq)(struct msm_gpu *irq);
+	struct msm_ringbuffer *(*active_ring)(struct msm_gpu *gpu);
 	void (*recover)(struct msm_gpu *gpu);
 	void (*destroy)(struct msm_gpu *gpu);
 #ifdef CONFIG_DEBUG_FS
@@ -67,14 +68,6 @@ struct msm_gpu_funcs {
 #endif
 };
 
-#define rbmemptr(gpu, member)  \
-	((gpu)->memptrs_iova + offsetof(struct msm_rbmemptrs, member))
-
-struct msm_rbmemptrs {
-	volatile uint32_t rptr;
-	volatile uint32_t fence;
-};
-
 struct msm_gpu {
 	const char *name;
 	struct drm_device *dev;
@@ -93,16 +86,12 @@ struct msm_gpu {
 	const struct msm_gpu_perfcntr *perfcntrs;
 	uint32_t num_perfcntrs;
 
-	/* ringbuffer: */
-	struct msm_ringbuffer *rb;
-	uint64_t rb_iova;
+	struct msm_ringbuffer *rb[MSM_GPU_MAX_RINGS];
+	int nr_rings;
 
 	/* list of GEM active objects: */
 	struct list_head active_list;
 
-	/* fencing: */
-	struct msm_fence_context *fctx;
-
 	/* does gpu need hw_init? */
 	bool needs_hw_init;
 
@@ -133,21 +122,26 @@ struct msm_gpu {
 #define DRM_MSM_HANGCHECK_PERIOD 500 /* in ms */
 #define DRM_MSM_HANGCHECK_JIFFIES msecs_to_jiffies(DRM_MSM_HANGCHECK_PERIOD)
 	struct timer_list hangcheck_timer;
-	uint32_t hangcheck_fence;
 	struct work_struct recover_work;
 
-	struct list_head submit_list;
-
-	struct msm_rbmemptrs *memptrs;
 	struct drm_gem_object *memptrs_bo;
-	uint64_t memptrs_iova;
-
-
 };
 
+/* It turns out that all targets use the same ringbuffer size */
+#define MSM_GPU_RINGBUFFER_SZ SZ_32K
+
 static inline bool msm_gpu_active(struct msm_gpu *gpu)
 {
-	return gpu->fctx->last_fence > gpu->memptrs->fence;
+	int i;
+
+	for (i = 0; i < gpu->nr_rings; i++) {
+		struct msm_ringbuffer *ring = gpu->rb[i];
+
+		if (ring->seqno > ring->memptrs->fence)
+			return true;
+	}
+
+	return false;
 }
 
 /* Perf-Counters:

commit cd414f3d931687eb1ebeb87533d85537e315f195
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Fri Oct 20 11:06:56 2017 -0600

    drm/msm: Move memptrs to msm_gpu
    
    When we move to multiple ringbuffers we're going to store the data
    in the memptrs on a per-ring basis. In order to prepare for that
    move the current memptrs from the adreno namespace into msm_gpu.
    This is way cleaner and immediately lets us kill off some sub
    functions so there is much less cost later when we do move to
    per-ring structs.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index a890176c27ce..8ddda059de34 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -59,7 +59,6 @@ struct msm_gpu_funcs {
 			struct msm_file_private *ctx);
 	void (*flush)(struct msm_gpu *gpu);
 	irqreturn_t (*irq)(struct msm_gpu *irq);
-	uint32_t (*last_fence)(struct msm_gpu *gpu);
 	void (*recover)(struct msm_gpu *gpu);
 	void (*destroy)(struct msm_gpu *gpu);
 #ifdef CONFIG_DEBUG_FS
@@ -68,6 +67,14 @@ struct msm_gpu_funcs {
 #endif
 };
 
+#define rbmemptr(gpu, member)  \
+	((gpu)->memptrs_iova + offsetof(struct msm_rbmemptrs, member))
+
+struct msm_rbmemptrs {
+	volatile uint32_t rptr;
+	volatile uint32_t fence;
+};
+
 struct msm_gpu {
 	const char *name;
 	struct drm_device *dev;
@@ -130,11 +137,17 @@ struct msm_gpu {
 	struct work_struct recover_work;
 
 	struct list_head submit_list;
+
+	struct msm_rbmemptrs *memptrs;
+	struct drm_gem_object *memptrs_bo;
+	uint64_t memptrs_iova;
+
+
 };
 
 static inline bool msm_gpu_active(struct msm_gpu *gpu)
 {
-	return gpu->fctx->last_fence > gpu->funcs->last_fence(gpu);
+	return gpu->fctx->last_fence > gpu->memptrs->fence;
 }
 
 /* Perf-Counters:

commit f7de15450e906ed6586b29bde609a5686cd0d034
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Fri Oct 20 11:06:55 2017 -0600

    drm/msm: Add per-instance submit queues
    
    Currently the behavior of a command stream is provided by the user
    application during submission and the application is expected to internally
    maintain the settings for each 'context' or 'rendering queue' and specify
    the correct ones.
    
    This works okay for simple cases but as applications become more
    complex we will want to set context specific flags and do various
    permission checks to allow certain contexts to enable additional
    privileges.
    
    Add kernel-side submit queues to be analogous to 'contexts' or
    'rendering queues' on the application side. Each file descriptor
    instance will maintain its own list of queues. Queues cannot be
    shared between file descriptors.
    
    For backwards compatibility context id '0' is defined as a default
    context specifying no priority and no special flags. This is
    intended to be the usual configuration for 99% of applications so
    that a garden variety application can function correctly without
    creating a queue. Only those applications requiring the specific
    benefit of different queues need create one.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index df4e2771fb85..a890176c27ce 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -150,6 +150,15 @@ struct msm_gpu_perfcntr {
 	const char *name;
 };
 
+struct msm_gpu_submitqueue {
+	int id;
+	u32 flags;
+	u32 prio;
+	int faults;
+	struct list_head node;
+	struct kref ref;
+};
+
 static inline void gpu_write(struct msm_gpu *gpu, u32 reg, u32 data)
 {
 	msm_writel(data, gpu->mmio + (reg << 2));
@@ -223,4 +232,10 @@ struct msm_gpu *adreno_load_gpu(struct drm_device *dev);
 void __init adreno_register(void);
 void __exit adreno_unregister(void);
 
+static inline void msm_submitqueue_put(struct msm_gpu_submitqueue *queue)
+{
+	if (queue)
+		kref_put(&queue->ref, msm_submitqueue_destroy);
+}
+
 #endif /* __MSM_GPU_H__ */

commit 8432a903fb97ac3640dbf9281e7c15a673b45747
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Jun 13 14:27:45 2017 -0400

    drm/msm: remove address-space id
    
    Now that the msm_gem supports an arbitrary number of vma's, we no longer
    need to assign an id (index) to each address space.  So rip out the
    associated code.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index fd8049592aae..df4e2771fb85 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -106,7 +106,6 @@ struct msm_gpu {
 	int irq;
 
 	struct msm_gem_address_space *aspace;
-	int id;
 
 	/* Power Control: */
 	struct regulator *gpu_reg, *gpu_cx;

commit 5770fc7a562e7da37cbf981f352d774c0142d7ba
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Mon May 8 14:35:03 2017 -0600

    drm/msm: Add a struct to pass configuration to msm_gpu_init()
    
    The amount of information that we need to pass into msm_gpu_init()
    is steadily increasing, so add a new struct to stabilize the function
    call and make it easier to add new configuration down the line.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 636450299c33..fd8049592aae 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -28,6 +28,14 @@
 struct msm_gem_submit;
 struct msm_gpu_perfcntr;
 
+struct msm_gpu_config {
+	const char *ioname;
+	const char *irqname;
+	uint64_t va_start;
+	uint64_t va_end;
+	unsigned int ringsz;
+};
+
 /* So far, with hardware that I've seen to date, we can have:
  *  + zero, one, or two z180 2d cores
  *  + a3xx or a2xx 3d core, which share a common CP (the firmware
@@ -208,7 +216,8 @@ void msm_gpu_submit(struct msm_gpu *gpu, struct msm_gem_submit *submit,
 
 int msm_gpu_init(struct drm_device *drm, struct platform_device *pdev,
 		struct msm_gpu *gpu, const struct msm_gpu_funcs *funcs,
-		const char *name, const char *ioname, const char *irqname, int ringsz);
+		const char *name, struct msm_gpu_config *config);
+
 void msm_gpu_cleanup(struct msm_gpu *gpu);
 
 struct msm_gpu *adreno_load_gpu(struct drm_device *dev);

commit e895c7bd31f5ca7dbd315001cfbdcaee98ee16c4
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Mon May 8 14:35:00 2017 -0600

    drm/msm: Remove idle function hook
    
    There isn't any generic code that uses ->idle so remove it.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index aa3241000455..636450299c33 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -50,7 +50,6 @@ struct msm_gpu_funcs {
 	void (*submit)(struct msm_gpu *gpu, struct msm_gem_submit *submit,
 			struct msm_file_private *ctx);
 	void (*flush)(struct msm_gpu *gpu);
-	bool (*idle)(struct msm_gpu *gpu);
 	irqreturn_t (*irq)(struct msm_gpu *irq);
 	uint32_t (*last_fence)(struct msm_gpu *gpu);
 	void (*recover)(struct msm_gpu *gpu);

commit 98db803f6413e6d4bf1f590ea57e9e7dfe1eb32b
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Tue Mar 7 10:02:56 2017 -0700

    msm/drm: gpu: Dynamically locate the clocks from the device tree
    
    Instead of using a fixed list of clock names use the clock-names
    list in the device tree to discover and get the list of clocks
    that we need.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 44f0c34ee5e4..aa3241000455 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -103,7 +103,9 @@ struct msm_gpu {
 
 	/* Power Control: */
 	struct regulator *gpu_reg, *gpu_cx;
-	struct clk *ebi1_clk, *grp_clks[6];
+	struct clk **grp_clks;
+	int nr_clocks;
+	struct clk *ebi1_clk, *core_clk, *rbbmtimer_clk;
 	uint32_t fast_rate, bus_freq;
 
 #ifdef DOWNSTREAM_CONFIG_MSM_BUS_SCALING

commit bf5af4ae875d8803db98d38ed988c2ec4c941a00
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Tue Mar 7 10:02:54 2017 -0700

    drm/msm: Hard code the GPU "slow frequency"
    
    Some A3XX and A4XX GPU targets required that the GPU clock be
    programmed to a non zero value when it was disabled so
    27Mhz was chosen as the "invalid" frequency.
    
    Even though newer targets do not have the same clock restrictions
    we still write 27Mhz on clock disable and expect the clock subsystem
    to round down to zero.
    
    For unknown reasons even though the slow clock speed is always
    27Mhz and it isn't actually a functional level the legacy device tree
    frequency tables always defined it and then did gymnastics to work
    around it.
    
    Instead of playing the same silly games just hard code the "slow" clock
    speed in the code as 27MHz and save ourselves a bit of infrastructure.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 72dba973aabf..44f0c34ee5e4 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -104,7 +104,7 @@ struct msm_gpu {
 	/* Power Control: */
 	struct regulator *gpu_reg, *gpu_cx;
 	struct clk *ebi1_clk, *grp_clks[6];
-	uint32_t fast_rate, slow_rate, bus_freq;
+	uint32_t fast_rate, bus_freq;
 
 #ifdef DOWNSTREAM_CONFIG_MSM_BUS_SCALING
 	struct msm_bus_scale_pdata *bus_scale_table;

commit eeb754746b140c5f55e6b25706a9142aa549b348
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Feb 10 15:36:33 2017 -0500

    drm/msm/gpu: use pm-runtime
    
    We need to use pm-runtime properly when IOMMU is using device_link() to
    control it's own clocks.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index c4c39d3272c7..72dba973aabf 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -64,6 +64,7 @@ struct msm_gpu_funcs {
 struct msm_gpu {
 	const char *name;
 	struct drm_device *dev;
+	struct platform_device *pdev;
 	const struct msm_gpu_funcs *funcs;
 
 	/* performance counters (hw & sw): */
@@ -88,9 +89,8 @@ struct msm_gpu {
 	/* fencing: */
 	struct msm_fence_context *fctx;
 
-	/* is gpu powered/active? */
-	int active_cnt;
-	bool inactive;
+	/* does gpu need hw_init? */
+	bool needs_hw_init;
 
 	/* worker for handling active-list retiring: */
 	struct work_struct retire_work;
@@ -114,9 +114,7 @@ struct msm_gpu {
 	/* Hang and Inactivity Detection:
 	 */
 #define DRM_MSM_INACTIVE_PERIOD   66 /* in ms (roughly four frames) */
-#define DRM_MSM_INACTIVE_JIFFIES  msecs_to_jiffies(DRM_MSM_INACTIVE_PERIOD)
-	struct timer_list inactive_timer;
-	struct work_struct inactive_work;
+
 #define DRM_MSM_HANGCHECK_PERIOD 500 /* in ms */
 #define DRM_MSM_HANGCHECK_JIFFIES msecs_to_jiffies(DRM_MSM_HANGCHECK_PERIOD)
 	struct timer_list hangcheck_timer;
@@ -196,6 +194,8 @@ static inline void gpu_write64(struct msm_gpu *gpu, u32 lo, u32 hi, u64 val)
 int msm_gpu_pm_suspend(struct msm_gpu *gpu);
 int msm_gpu_pm_resume(struct msm_gpu *gpu);
 
+int msm_gpu_hw_init(struct msm_gpu *gpu);
+
 void msm_gpu_perfcntr_start(struct msm_gpu *gpu);
 void msm_gpu_perfcntr_stop(struct msm_gpu *gpu);
 int msm_gpu_perfcntr_sample(struct msm_gpu *gpu, uint32_t *activetime,

commit b5f103ab98c77ca5998b39533c2b46959fbd37d9
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Mon Nov 28 12:28:33 2016 -0700

    drm/msm: gpu: Add A5XX target support
    
    Add support for the A5XX family of Adreno GPUs.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 10252d07bb14..c4c39d3272c7 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -103,7 +103,7 @@ struct msm_gpu {
 
 	/* Power Control: */
 	struct regulator *gpu_reg, *gpu_cx;
-	struct clk *ebi1_clk, *grp_clks[5];
+	struct clk *ebi1_clk, *grp_clks[6];
 	uint32_t fast_rate, slow_rate, bus_freq;
 
 #ifdef DOWNSTREAM_CONFIG_MSM_BUS_SCALING

commit 89d777a572459d6ea726b609838beaef0c1b94a7
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Mon Nov 28 12:28:31 2016 -0700

    drm/msm: Remove 'src_clk' from adreno configuration
    
    The adreno code inherited a silly workaround from downstream
    from the bad old days before decent clock control. grp_clk[0]
    (named 'src_clk') doesn't actually exist - it was used as a proxy
    for whatever the core clock actually was (usually 'core_clk').
    
    All targets should be able to correctly request 'core_clk' and
    get the right thing back so zap the anachronism and directly
    use grp_clk[0] to control the clock rate.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index c4c39d3272c7..10252d07bb14 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -103,7 +103,7 @@ struct msm_gpu {
 
 	/* Power Control: */
 	struct regulator *gpu_reg, *gpu_cx;
-	struct clk *ebi1_clk, *grp_clks[6];
+	struct clk *ebi1_clk, *grp_clks[5];
 	uint32_t fast_rate, slow_rate, bus_freq;
 
 #ifdef DOWNSTREAM_CONFIG_MSM_BUS_SCALING

commit ae53a829d5c9715b651ee33e266eaa4454e7f2ad
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Mon Nov 28 12:28:28 2016 -0700

    drm/msm: gpu Add new gpu register read/write functions
    
    Add some new functions to manipulate GPU registers.  gpu_read64 and
    gpu_write64 can read/write a 64 bit value to two 32 bit registers.
    For 4XX and older these are normally perfcounter registers, but
    future targets will use 64 bit addressing so there will be many
    more spots where a 64 bit read and write are needed.
    
    gpu_rmw() does a read/modify/write on a 32 bit register given a mask
    and bits to OR in.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 10954135130d..c4c39d3272c7 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -154,6 +154,45 @@ static inline u32 gpu_read(struct msm_gpu *gpu, u32 reg)
 	return msm_readl(gpu->mmio + (reg << 2));
 }
 
+static inline void gpu_rmw(struct msm_gpu *gpu, u32 reg, u32 mask, u32 or)
+{
+	uint32_t val = gpu_read(gpu, reg);
+
+	val &= ~mask;
+	gpu_write(gpu, reg, val | or);
+}
+
+static inline u64 gpu_read64(struct msm_gpu *gpu, u32 lo, u32 hi)
+{
+	u64 val;
+
+	/*
+	 * Why not a readq here? Two reasons: 1) many of the LO registers are
+	 * not quad word aligned and 2) the GPU hardware designers have a bit
+	 * of a history of putting registers where they fit, especially in
+	 * spins. The longer a GPU family goes the higher the chance that
+	 * we'll get burned.  We could do a series of validity checks if we
+	 * wanted to, but really is a readq() that much better? Nah.
+	 */
+
+	/*
+	 * For some lo/hi registers (like perfcounters), the hi value is latched
+	 * when the lo is read, so make sure to read the lo first to trigger
+	 * that
+	 */
+	val = (u64) msm_readl(gpu->mmio + (lo << 2));
+	val |= ((u64) msm_readl(gpu->mmio + (hi << 2)) << 32);
+
+	return val;
+}
+
+static inline void gpu_write64(struct msm_gpu *gpu, u32 lo, u32 hi, u64 val)
+{
+	/* Why not a writeq here? Read the screed above */
+	msm_writel(lower_32_bits(val), gpu->mmio + (lo << 2));
+	msm_writel(upper_32_bits(val), gpu->mmio + (hi << 2));
+}
+
 int msm_gpu_pm_suspend(struct msm_gpu *gpu);
 int msm_gpu_pm_resume(struct msm_gpu *gpu);
 

commit c4a8d4756061f72cba52af1e3035c07769cee679
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Mon Nov 28 12:28:27 2016 -0700

    drm/msm: gpu: Return error on hw_init failure
    
    When the GPU hardware init function fails (like say, ME_INIT timed
    out) return error instead of blindly continuing on. This gives us
    a small chance of saving the system before it goes boom.
    
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 6a7e78b317f2..10954135130d 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -50,7 +50,7 @@ struct msm_gpu_funcs {
 	void (*submit)(struct msm_gpu *gpu, struct msm_gem_submit *submit,
 			struct msm_file_private *ctx);
 	void (*flush)(struct msm_gpu *gpu);
-	void (*idle)(struct msm_gpu *gpu);
+	bool (*idle)(struct msm_gpu *gpu);
 	irqreturn_t (*irq)(struct msm_gpu *irq);
 	uint32_t (*last_fence)(struct msm_gpu *gpu);
 	void (*recover)(struct msm_gpu *gpu);

commit 78babc1633c4b0664ea516500c2ace9bf1f17bc7
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Nov 11 12:06:46 2016 -0500

    drm/msm: convert iova to 64b
    
    For a5xx the gpu is 64b so we need to change iova to 64b everywhere.  On
    the display side, iova is still 32b so it can ignore the upper bits.
    (Although all the armv8 devices have an iommu that can map 64b pa to 32b
    iova.)
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index c6bf5d6ebc20..6a7e78b317f2 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -80,7 +80,7 @@ struct msm_gpu {
 
 	/* ringbuffer: */
 	struct msm_ringbuffer *rb;
-	uint32_t rb_iova;
+	uint64_t rb_iova;
 
 	/* list of GEM active objects: */
 	struct list_head active_list;

commit 667ce33e57d0de4074a8fb62d24daeefd03f6333
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Sep 28 19:58:32 2016 -0400

    drm/msm: support multiple address spaces
    
    We can have various combinations of 64b and 32b address space, ie. 64b
    CPU but 32b display and gpu, or 64b CPU and GPU but 32b display.  So
    best to decouple the device iova's from mmap offset.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index d61d98a6e047..c6bf5d6ebc20 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -98,7 +98,7 @@ struct msm_gpu {
 	void __iomem *mmio;
 	int irq;
 
-	struct msm_mmu *mmu;
+	struct msm_gem_address_space *aspace;
 	int id;
 
 	/* Power Control: */

commit f44d32c79fd591179820d6ce4645c4c2799e6d40
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Jun 16 16:37:38 2016 -0400

    drm/msm: move fence allocation out of msm_gpu_submit()
    
    Prep work for next patch.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index c9022837a1a4..d61d98a6e047 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -163,7 +163,7 @@ int msm_gpu_perfcntr_sample(struct msm_gpu *gpu, uint32_t *activetime,
 		uint32_t *totaltime, uint32_t ncntrs, uint32_t *cntrs);
 
 void msm_gpu_retire(struct msm_gpu *gpu);
-int msm_gpu_submit(struct msm_gpu *gpu, struct msm_gem_submit *submit,
+void msm_gpu_submit(struct msm_gpu *gpu, struct msm_gem_submit *submit,
 		struct msm_file_private *ctx);
 
 int msm_gpu_init(struct drm_device *drm, struct platform_device *pdev,

commit 1193c3bcb581807d58dd7df90528ec744af387a9
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue May 3 09:46:49 2016 -0400

    drm/msm: drop return from gpu->submit()
    
    At this point, there is nothing left to fail.  And submit already has a
    fence assigned and is added to the submit_list.  Any problems from here
    on out are asynchronous (ie. hangcheck/recovery).
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 025e25b648e7..c9022837a1a4 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -47,7 +47,7 @@ struct msm_gpu_funcs {
 	int (*hw_init)(struct msm_gpu *gpu);
 	int (*pm_suspend)(struct msm_gpu *gpu);
 	int (*pm_resume)(struct msm_gpu *gpu);
-	int (*submit)(struct msm_gpu *gpu, struct msm_gem_submit *submit,
+	void (*submit)(struct msm_gpu *gpu, struct msm_gem_submit *submit,
 			struct msm_file_private *ctx);
 	void (*flush)(struct msm_gpu *gpu);
 	void (*idle)(struct msm_gpu *gpu);

commit ca762a8ae7f453978a4769af9dcd3cb08e45b932
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Mar 15 17:22:13 2016 -0400

    drm/msm: introduce msm_fence_context
    
    Better encapsulate the per-timeline stuff into fence-context.  For now
    there is just a single fence-context, but eventually we'll also have one
    per-CRTC to enable fully explicit fencing.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 2bbe85a3d6f6..025e25b648e7 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -22,6 +22,7 @@
 #include <linux/regulator/consumer.h>
 
 #include "msm_drv.h"
+#include "msm_fence.h"
 #include "msm_ringbuffer.h"
 
 struct msm_gem_submit;
@@ -77,13 +78,15 @@ struct msm_gpu {
 	const struct msm_gpu_perfcntr *perfcntrs;
 	uint32_t num_perfcntrs;
 
+	/* ringbuffer: */
 	struct msm_ringbuffer *rb;
 	uint32_t rb_iova;
 
 	/* list of GEM active objects: */
 	struct list_head active_list;
 
-	uint32_t submitted_fence;
+	/* fencing: */
+	struct msm_fence_context *fctx;
 
 	/* is gpu powered/active? */
 	int active_cnt;
@@ -125,7 +128,7 @@ struct msm_gpu {
 
 static inline bool msm_gpu_active(struct msm_gpu *gpu)
 {
-	return gpu->submitted_fence > gpu->funcs->last_fence(gpu);
+	return gpu->fctx->last_fence > gpu->funcs->last_fence(gpu);
 }
 
 /* Perf-Counters:

commit 1a370be9ac51129e40b0ed7fa71d2b2b92bc47e5
Author: Rob Clark <robdclark@gmail.com>
Date:   Sun Jun 7 13:46:04 2015 -0400

    drm/msm: restart queued submits after hang
    
    Track the list of in-flight submits.  If the gpu hangs, retire up to an
    including the offending submit, and then re-submit the remainder.  This
    way, for concurrently running piglit tests (for example), one failing
    test doesn't cause unrelated tests to fail simply because it's submit
    was queued up after one that triggered a hang.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 7b3ec21d5d77..2bbe85a3d6f6 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -119,6 +119,8 @@ struct msm_gpu {
 	struct timer_list hangcheck_timer;
 	uint32_t hangcheck_fence;
 	struct work_struct recover_work;
+
+	struct list_head submit_list;
 };
 
 static inline bool msm_gpu_active(struct msm_gpu *gpu)

commit de558cd2ae2e9999d0b6328c22c398ff85b6327c
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed May 6 13:14:30 2015 -0400

    drm/msm: adreno a306 support
    
    As found in apq8016 (used in DragonBoard 410c) and msm8916.
    
    Note that numerically a306 is actually 307 (since a305c already claimed
    306).  Nice and confusing.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 2c46f1d820e0..7b3ec21d5d77 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -100,7 +100,7 @@ struct msm_gpu {
 
 	/* Power Control: */
 	struct regulator *gpu_reg, *gpu_cx;
-	struct clk *ebi1_clk, *grp_clks[5];
+	struct clk *ebi1_clk, *grp_clks[6];
 	uint32_t fast_rate, slow_rate, bus_freq;
 
 #ifdef DOWNSTREAM_CONFIG_MSM_BUS_SCALING

commit 6490ad47404539b479ca33f96793c4624bef2924
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Jun 4 10:26:37 2015 -0400

    drm/msm: clarify downstream bus scaling
    
    A few spots in the driver have support for downstream android
    CONFIG_MSM_BUS_SCALING.  This is mainly to simplify backporting the
    driver for various devices which do not have sufficient upstream
    kernel support.  But the intentionally dead code seems to cause
    some confusion.  Rename the #define to make this more clear.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index fd1e4b4a6d40..2c46f1d820e0 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -103,7 +103,7 @@ struct msm_gpu {
 	struct clk *ebi1_clk, *grp_clks[5];
 	uint32_t fast_rate, slow_rate, bus_freq;
 
-#ifdef CONFIG_MSM_BUS_SCALING
+#ifdef DOWNSTREAM_CONFIG_MSM_BUS_SCALING
 	struct msm_bus_scale_pdata *bus_scale_table;
 	uint32_t bsc;
 #endif

commit e2550b7a7d8f2030cfea43343eb3fccc3a8e8167
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Sep 5 13:30:27 2014 -0400

    drm/msm/adreno: move decision about what gpu to to load
    
    Move this into into adreno_device, and decide based on gpu revision
    rather than just assuming a3xx.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 38ef033c81f3..fd1e4b4a6d40 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -166,7 +166,7 @@ int msm_gpu_init(struct drm_device *drm, struct platform_device *pdev,
 		const char *name, const char *ioname, const char *irqname, int ringsz);
 void msm_gpu_cleanup(struct msm_gpu *gpu);
 
-struct msm_gpu *a3xx_gpu_init(struct drm_device *dev);
+struct msm_gpu *adreno_load_gpu(struct drm_device *dev);
 void __init adreno_register(void);
 void __exit adreno_unregister(void);
 

commit bfd28b136298f37ef2e10494d3a0bfb4dcbaa7b9
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Sep 5 13:06:37 2014 -0400

    drm/msm/adreno: split adreno device out into it's own file
    
    We'd rather not duplicate these parts as support for additional gpu
    generations is added.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 9b579b792840..38ef033c81f3 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -167,7 +167,7 @@ int msm_gpu_init(struct drm_device *drm, struct platform_device *pdev,
 void msm_gpu_cleanup(struct msm_gpu *gpu);
 
 struct msm_gpu *a3xx_gpu_init(struct drm_device *dev);
-void __init a3xx_register(void);
-void __exit a3xx_unregister(void);
+void __init adreno_register(void);
+void __exit adreno_unregister(void);
 
 #endif /* __MSM_GPU_H__ */

commit 70c70f091b1ffd16b3e1a439bd595f7d539b1d5d
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri May 30 14:49:43 2014 -0400

    drm/msm: add perf logging debugfs
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index fad27008922f..9b579b792840 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -25,6 +25,7 @@
 #include "msm_ringbuffer.h"
 
 struct msm_gem_submit;
+struct msm_gpu_perfcntr;
 
 /* So far, with hardware that I've seen to date, we can have:
  *  + zero, one, or two z180 2d cores
@@ -64,6 +65,18 @@ struct msm_gpu {
 	struct drm_device *dev;
 	const struct msm_gpu_funcs *funcs;
 
+	/* performance counters (hw & sw): */
+	spinlock_t perf_lock;
+	bool perfcntr_active;
+	struct {
+		bool active;
+		ktime_t time;
+	} last_sample;
+	uint32_t totaltime, activetime;    /* sw counters */
+	uint32_t last_cntrs[5];            /* hw counters */
+	const struct msm_gpu_perfcntr *perfcntrs;
+	uint32_t num_perfcntrs;
+
 	struct msm_ringbuffer *rb;
 	uint32_t rb_iova;
 
@@ -113,6 +126,19 @@ static inline bool msm_gpu_active(struct msm_gpu *gpu)
 	return gpu->submitted_fence > gpu->funcs->last_fence(gpu);
 }
 
+/* Perf-Counters:
+ * The select_reg and select_val are just there for the benefit of the child
+ * class that actually enables the perf counter..  but msm_gpu base class
+ * will handle sampling/displaying the counters.
+ */
+
+struct msm_gpu_perfcntr {
+	uint32_t select_reg;
+	uint32_t sample_reg;
+	uint32_t select_val;
+	const char *name;
+};
+
 static inline void gpu_write(struct msm_gpu *gpu, u32 reg, u32 data)
 {
 	msm_writel(data, gpu->mmio + (reg << 2));
@@ -126,6 +152,11 @@ static inline u32 gpu_read(struct msm_gpu *gpu, u32 reg)
 int msm_gpu_pm_suspend(struct msm_gpu *gpu);
 int msm_gpu_pm_resume(struct msm_gpu *gpu);
 
+void msm_gpu_perfcntr_start(struct msm_gpu *gpu);
+void msm_gpu_perfcntr_stop(struct msm_gpu *gpu);
+int msm_gpu_perfcntr_sample(struct msm_gpu *gpu, uint32_t *activetime,
+		uint32_t *totaltime, uint32_t ncntrs, uint32_t *cntrs);
+
 void msm_gpu_retire(struct msm_gpu *gpu);
 int msm_gpu_submit(struct msm_gpu *gpu, struct msm_gem_submit *submit,
 		struct msm_file_private *ctx);

commit 37d77c3ab589bf8e3160a33b651fe6dd7439ba48
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Jan 11 16:25:08 2014 -0500

    drm/msm: crank down gpu when inactive
    
    Shut down the clks when the gpu has nothing to do.  A short inactivity
    timer is used to provide a low pass filter for power transitions.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 458db8c64c28..fad27008922f 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -72,6 +72,10 @@ struct msm_gpu {
 
 	uint32_t submitted_fence;
 
+	/* is gpu powered/active? */
+	int active_cnt;
+	bool inactive;
+
 	/* worker for handling active-list retiring: */
 	struct work_struct retire_work;
 
@@ -91,7 +95,12 @@ struct msm_gpu {
 	uint32_t bsc;
 #endif
 
-	/* Hang Detction: */
+	/* Hang and Inactivity Detection:
+	 */
+#define DRM_MSM_INACTIVE_PERIOD   66 /* in ms (roughly four frames) */
+#define DRM_MSM_INACTIVE_JIFFIES  msecs_to_jiffies(DRM_MSM_INACTIVE_PERIOD)
+	struct timer_list inactive_timer;
+	struct work_struct inactive_work;
 #define DRM_MSM_HANGCHECK_PERIOD 500 /* in ms */
 #define DRM_MSM_HANGCHECK_JIFFIES msecs_to_jiffies(DRM_MSM_HANGCHECK_PERIOD)
 	struct timer_list hangcheck_timer;
@@ -99,6 +108,11 @@ struct msm_gpu {
 	struct work_struct recover_work;
 };
 
+static inline bool msm_gpu_active(struct msm_gpu *gpu)
+{
+	return gpu->submitted_fence > gpu->funcs->last_fence(gpu);
+}
+
 static inline void gpu_write(struct msm_gpu *gpu, u32 reg, u32 data)
 {
 	msm_writel(data, gpu->mmio + (reg << 2));

commit 871d812aa43e6350a4edf41bf7cb0879675255f1
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Nov 16 12:56:06 2013 -0500

    drm/msm: add support for non-IOMMU systems
    
    Add a VRAM carveout that is used for systems which do not have an IOMMU.
    
    The VRAM carveout uses CMA.  The arch code must setup a CMA pool for the
    device (preferrably in highmem.. a 256m-512m VRAM pool in lowmem is not
    cool).  The user can configure the VRAM pool size using msm.vram module
    param.
    
    Technically, the abstraction of IOMMU behind msm_mmu is not strictly
    needed, but it simplifies the GEM code a bit, and will be useful later
    when I add support for a2xx devices with GPUMMU, so I decided to keep
    this part.
    
    It appears to be possible to configure the GPU to restrict access to
    addresses within the VRAM pool, but this is not done yet.  So for now
    the GPU will refuse to load if there is no sort of mmu.  Once address
    based limits are supported and tested to confirm that we aren't giving
    the GPU access to arbitrary memory, this restriction can be lifted
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 08d08420cbcc..458db8c64c28 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -78,7 +78,7 @@ struct msm_gpu {
 	void __iomem *mmio;
 	int irq;
 
-	struct iommu_domain *iommu;
+	struct msm_mmu *mmu;
 	int id;
 
 	/* Power Control: */

commit bf2b33afb9ea1d9609767c70562610a686bdfbd7
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Nov 15 09:03:15 2013 -0500

    drm/msm: fix bus scaling
    
    This got a bit broken with original patches when re-arranging things to
    move dependencies on mach-msm inside #ifndef OF.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 8cd829e520bb..08d08420cbcc 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -85,7 +85,11 @@ struct msm_gpu {
 	struct regulator *gpu_reg, *gpu_cx;
 	struct clk *ebi1_clk, *grp_clks[5];
 	uint32_t fast_rate, slow_rate, bus_freq;
+
+#ifdef CONFIG_MSM_BUS_SCALING
+	struct msm_bus_scale_pdata *bus_scale_table;
 	uint32_t bsc;
+#endif
 
 	/* Hang Detction: */
 #define DRM_MSM_HANGCHECK_PERIOD 500 /* in ms */

commit bd6f82d8289422f618b98451a43887f452b3423e
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Aug 24 14:20:38 2013 -0400

    drm/msm: add basic hangcheck/recovery mechanism
    
    A basic, no-frills recovery mechanism in case the gpu gets wedged.  We
    could try to be a bit more fancy and restart the next submit after the
    one that got wedged, but for now keep it simple.  This is enough to
    recover things if, for example, the gpu hangs mid way through a piglit
    run.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
index 8d2cd6c2226b..8cd829e520bb 100644
--- a/drivers/gpu/drm/msm/msm_gpu.h
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -51,6 +51,7 @@ struct msm_gpu_funcs {
 	void (*idle)(struct msm_gpu *gpu);
 	irqreturn_t (*irq)(struct msm_gpu *irq);
 	uint32_t (*last_fence)(struct msm_gpu *gpu);
+	void (*recover)(struct msm_gpu *gpu);
 	void (*destroy)(struct msm_gpu *gpu);
 #ifdef CONFIG_DEBUG_FS
 	/* show GPU status in debugfs: */
@@ -69,6 +70,8 @@ struct msm_gpu {
 	/* list of GEM active objects: */
 	struct list_head active_list;
 
+	uint32_t submitted_fence;
+
 	/* worker for handling active-list retiring: */
 	struct work_struct retire_work;
 
@@ -83,6 +86,13 @@ struct msm_gpu {
 	struct clk *ebi1_clk, *grp_clks[5];
 	uint32_t fast_rate, slow_rate, bus_freq;
 	uint32_t bsc;
+
+	/* Hang Detction: */
+#define DRM_MSM_HANGCHECK_PERIOD 500 /* in ms */
+#define DRM_MSM_HANGCHECK_JIFFIES msecs_to_jiffies(DRM_MSM_HANGCHECK_PERIOD)
+	struct timer_list hangcheck_timer;
+	uint32_t hangcheck_fence;
+	struct work_struct recover_work;
 };
 
 static inline void gpu_write(struct msm_gpu *gpu, u32 reg, u32 data)

commit 7198e6b03155f6dadecadba004eb83b81a6ffe4c
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Jul 19 12:59:32 2013 -0400

    drm/msm: add a3xx gpu support
    
    Add initial support for a3xx 3d core.
    
    So far, with hardware that I've seen to date, we can have:
     + zero, one, or two z180 2d cores
     + a3xx or a2xx 3d core, which share a common CP (the firmware
       for the CP seems to implement some different PM4 packet types
       but the basics of cmdstream submission are the same)
    
    Which means that the eventual complete "class" hierarchy, once
    support for all past and present hw is in place, becomes:
     + msm_gpu
       + adreno_gpu
         + a3xx_gpu
         + a2xx_gpu
       + z180_gpu
    
    This commit splits out the parts that will eventually be common
    between a2xx/a3xx into adreno_gpu, and the parts that are even
    common to z180 into msm_gpu.
    
    Note that there is no cmdstream validation required.  All memory access
    from the GPU is via IOMMU/MMU.  So as long as you don't map silly things
    to the GPU, there isn't much damage that the GPU can do.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_gpu.h b/drivers/gpu/drm/msm/msm_gpu.h
new file mode 100644
index 000000000000..8d2cd6c2226b
--- /dev/null
+++ b/drivers/gpu/drm/msm/msm_gpu.h
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2013 Red Hat
+ * Author: Rob Clark <robdclark@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __MSM_GPU_H__
+#define __MSM_GPU_H__
+
+#include <linux/clk.h>
+#include <linux/regulator/consumer.h>
+
+#include "msm_drv.h"
+#include "msm_ringbuffer.h"
+
+struct msm_gem_submit;
+
+/* So far, with hardware that I've seen to date, we can have:
+ *  + zero, one, or two z180 2d cores
+ *  + a3xx or a2xx 3d core, which share a common CP (the firmware
+ *    for the CP seems to implement some different PM4 packet types
+ *    but the basics of cmdstream submission are the same)
+ *
+ * Which means that the eventual complete "class" hierarchy, once
+ * support for all past and present hw is in place, becomes:
+ *  + msm_gpu
+ *    + adreno_gpu
+ *      + a3xx_gpu
+ *      + a2xx_gpu
+ *    + z180_gpu
+ */
+struct msm_gpu_funcs {
+	int (*get_param)(struct msm_gpu *gpu, uint32_t param, uint64_t *value);
+	int (*hw_init)(struct msm_gpu *gpu);
+	int (*pm_suspend)(struct msm_gpu *gpu);
+	int (*pm_resume)(struct msm_gpu *gpu);
+	int (*submit)(struct msm_gpu *gpu, struct msm_gem_submit *submit,
+			struct msm_file_private *ctx);
+	void (*flush)(struct msm_gpu *gpu);
+	void (*idle)(struct msm_gpu *gpu);
+	irqreturn_t (*irq)(struct msm_gpu *irq);
+	uint32_t (*last_fence)(struct msm_gpu *gpu);
+	void (*destroy)(struct msm_gpu *gpu);
+#ifdef CONFIG_DEBUG_FS
+	/* show GPU status in debugfs: */
+	void (*show)(struct msm_gpu *gpu, struct seq_file *m);
+#endif
+};
+
+struct msm_gpu {
+	const char *name;
+	struct drm_device *dev;
+	const struct msm_gpu_funcs *funcs;
+
+	struct msm_ringbuffer *rb;
+	uint32_t rb_iova;
+
+	/* list of GEM active objects: */
+	struct list_head active_list;
+
+	/* worker for handling active-list retiring: */
+	struct work_struct retire_work;
+
+	void __iomem *mmio;
+	int irq;
+
+	struct iommu_domain *iommu;
+	int id;
+
+	/* Power Control: */
+	struct regulator *gpu_reg, *gpu_cx;
+	struct clk *ebi1_clk, *grp_clks[5];
+	uint32_t fast_rate, slow_rate, bus_freq;
+	uint32_t bsc;
+};
+
+static inline void gpu_write(struct msm_gpu *gpu, u32 reg, u32 data)
+{
+	msm_writel(data, gpu->mmio + (reg << 2));
+}
+
+static inline u32 gpu_read(struct msm_gpu *gpu, u32 reg)
+{
+	return msm_readl(gpu->mmio + (reg << 2));
+}
+
+int msm_gpu_pm_suspend(struct msm_gpu *gpu);
+int msm_gpu_pm_resume(struct msm_gpu *gpu);
+
+void msm_gpu_retire(struct msm_gpu *gpu);
+int msm_gpu_submit(struct msm_gpu *gpu, struct msm_gem_submit *submit,
+		struct msm_file_private *ctx);
+
+int msm_gpu_init(struct drm_device *drm, struct platform_device *pdev,
+		struct msm_gpu *gpu, const struct msm_gpu_funcs *funcs,
+		const char *name, const char *ioname, const char *irqname, int ringsz);
+void msm_gpu_cleanup(struct msm_gpu *gpu);
+
+struct msm_gpu *a3xx_gpu_init(struct drm_device *dev);
+void __init a3xx_register(void);
+void __exit a3xx_unregister(void);
+
+#endif /* __MSM_GPU_H__ */
