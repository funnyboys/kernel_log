commit cd6d923167b1bf3e051f9d90fa129456d78ef06e
Author: Rob Clark <robdclark@chromium.org>
Date:   Thu Aug 29 09:45:17 2019 -0700

    drm/msm/dpu: async commit support
    
    In addition, moving to kms->flush_commit() lets us drop the only user
    of kms->commit().
    
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Reviewed-by: Sean Paul <sean@poorly.run>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index ed8df60a32ad..1cbef6b200b7 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -80,9 +80,6 @@ struct msm_kms_funcs {
 	 */
 	void (*flush_commit)(struct msm_kms *kms, unsigned crtc_mask);
 
-	/* TODO remove ->commit(), use ->flush_commit() instead: */
-	void (*commit)(struct msm_kms *kms, struct drm_atomic_state *state);
-
 	/**
 	 * Wait for any in-progress flush to complete on the specified
 	 * crtcs.  This should not block if there is no in-progress

commit 2d99ced787e3d0f251fa370d2aae83cf2085a8d9
Author: Rob Clark <robdclark@chromium.org>
Date:   Thu Aug 29 09:45:16 2019 -0700

    drm/msm: async commit support
    
    Now that flush/wait/complete is decoupled from the "synchronous" part of
    atomic commit_tail(), add support to defer flush to a timer that expires
    shortly before vblank for async commits.  In this way, multiple atomic
    commits (for example, cursor updates) can be coalesced into a single
    flush at the end of the frame.
    
    v2: don't hold lock over ->wait_flush(), to avoid locking interaction
        that was causing fps drop when combining page flips or non-async
        atomic commits and lots of legacy cursor updates
    
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Reviewed-by: Sean Paul <sean@poorly.run>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 85264a2f1f6d..ed8df60a32ad 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -33,6 +33,20 @@ struct msm_kms_funcs {
 
 	/*
 	 * Atomic commit handling:
+	 *
+	 * Note that in the case of async commits, the funcs which take
+	 * a crtc_mask (ie. ->flush_commit(), and ->complete_commit())
+	 * might not be evenly balanced with ->prepare_commit(), however
+	 * each crtc that effected by a ->prepare_commit() (potentially
+	 * multiple times) will eventually (at end of vsync period) be
+	 * flushed and completed.
+	 *
+	 * This has some implications about tracking of cleanup state,
+	 * for example SMP blocks to release after commit completes.  Ie.
+	 * cleanup state should be also duplicated in the various
+	 * duplicate_state() methods, as the current cleanup state at
+	 * ->complete_commit() time may have accumulated cleanup work
+	 * from multiple commits.
 	 */
 
 	/**
@@ -45,6 +59,14 @@ struct msm_kms_funcs {
 	void (*enable_commit)(struct msm_kms *kms);
 	void (*disable_commit)(struct msm_kms *kms);
 
+	/**
+	 * If the kms backend supports async commit, it should implement
+	 * this method to return the time of the next vsync.  This is
+	 * used to determine a time slightly before vsync, for the async
+	 * commit timer to run and complete an async commit.
+	 */
+	ktime_t (*vsync_time)(struct msm_kms *kms, struct drm_crtc *crtc);
+
 	/**
 	 * Prepare for atomic commit.  This is called after any previous
 	 * (async or otherwise) commit has completed.
@@ -109,20 +131,48 @@ struct msm_kms_funcs {
 #endif
 };
 
+struct msm_kms;
+
+/*
+ * A per-crtc timer for pending async atomic flushes.  Scheduled to expire
+ * shortly before vblank to flush pending async updates.
+ */
+struct msm_pending_timer {
+	struct hrtimer timer;
+	struct work_struct work;
+	struct msm_kms *kms;
+	unsigned crtc_idx;
+};
+
 struct msm_kms {
 	const struct msm_kms_funcs *funcs;
+	struct drm_device *dev;
 
 	/* irq number to be passed on to drm_irq_install */
 	int irq;
 
 	/* mapper-id used to request GEM buffer mapped for scanout: */
 	struct msm_gem_address_space *aspace;
+
+	/*
+	 * For async commit, where ->flush_commit() and later happens
+	 * from the crtc's pending_timer close to end of the frame:
+	 */
+	struct mutex commit_lock;
+	unsigned pending_crtc_mask;
+	struct msm_pending_timer pending_timers[MAX_CRTCS];
 };
 
 static inline void msm_kms_init(struct msm_kms *kms,
 		const struct msm_kms_funcs *funcs)
 {
+	unsigned i;
+
+	mutex_init(&kms->commit_lock);
 	kms->funcs = funcs;
+
+	for (i = 0; i < ARRAY_SIZE(kms->pending_timers); i++)
+		msm_atomic_init_pending_timer(&kms->pending_timers[i], kms, i);
 }
 
 struct msm_kms *mdp4_kms_init(struct drm_device *dev);

commit e35a29d5c432504e6134c881dc4aaded7de7e717
Author: Rob Clark <robdclark@chromium.org>
Date:   Thu Aug 29 09:45:15 2019 -0700

    drm/msm: split power control from prepare/complete_commit
    
    With atomic commit, ->prepare_commit() and ->complete_commit() may not
    be evenly balanced (although ->complete_commit() will complete each
    crtc that had been previously prepared).  So these will no longer be
    a good place to enable/disable clocks needed for hw access.
    
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Reviewed-by: Sean Paul <sean@poorly.run>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 80bccbf4d993..85264a2f1f6d 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -35,6 +35,16 @@ struct msm_kms_funcs {
 	 * Atomic commit handling:
 	 */
 
+	/**
+	 * Enable/disable power/clks needed for hw access done in other
+	 * commit related methods.
+	 *
+	 * If mdp4 is migrated to runpm, we could probably drop these
+	 * and use runpm directly.
+	 */
+	void (*enable_commit)(struct msm_kms *kms);
+	void (*disable_commit)(struct msm_kms *kms);
+
 	/**
 	 * Prepare for atomic commit.  This is called after any previous
 	 * (async or otherwise) commit has completed.

commit 9f6b65642bd2d7ec1fc2eb675cf10a55f29417e2
Author: Rob Clark <robdclark@chromium.org>
Date:   Thu Aug 29 09:45:14 2019 -0700

    drm/msm: add kms->flush_commit()
    
    Add ->flush_commit(crtc_mask).  Currently a no-op, but kms backends
    should migrate writing flush registers to this hook, so we can decouple
    pushing updates to hardware, and flushing the updates.
    
    Once we add async commit support, the hw updates will be pushed down to
    the hw synchronously, but flushing the updates will be deferred until as
    close to vblank as possible, so that multiple updates can be combined in
    a single frame.
    
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Reviewed-by: Sean Paul <sean@poorly.run>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 10dd171b43f8..80bccbf4d993 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -30,12 +30,47 @@ struct msm_kms_funcs {
 	irqreturn_t (*irq)(struct msm_kms *kms);
 	int (*enable_vblank)(struct msm_kms *kms, struct drm_crtc *crtc);
 	void (*disable_vblank)(struct msm_kms *kms, struct drm_crtc *crtc);
-	/* modeset, bracketing atomic_commit(): */
+
+	/*
+	 * Atomic commit handling:
+	 */
+
+	/**
+	 * Prepare for atomic commit.  This is called after any previous
+	 * (async or otherwise) commit has completed.
+	 */
 	void (*prepare_commit)(struct msm_kms *kms, struct drm_atomic_state *state);
+
+	/**
+	 * Flush an atomic commit.  This is called after the hardware
+	 * updates have already been pushed down to effected planes/
+	 * crtcs/encoders/connectors.
+	 */
+	void (*flush_commit)(struct msm_kms *kms, unsigned crtc_mask);
+
+	/* TODO remove ->commit(), use ->flush_commit() instead: */
 	void (*commit)(struct msm_kms *kms, struct drm_atomic_state *state);
-	void (*complete_commit)(struct msm_kms *kms, unsigned crtc_mask);
+
+	/**
+	 * Wait for any in-progress flush to complete on the specified
+	 * crtcs.  This should not block if there is no in-progress
+	 * commit (ie. don't just wait for a vblank), as it will also
+	 * be called before ->prepare_commit() to ensure any potential
+	 * "async" commit has completed.
+	 */
 	void (*wait_flush)(struct msm_kms *kms, unsigned crtc_mask);
 
+	/**
+	 * Clean up after commit is completed.  This is called after
+	 * ->wait_flush(), to give the backend a chance to do any
+	 * post-commit cleanup.
+	 */
+	void (*complete_commit)(struct msm_kms *kms, unsigned crtc_mask);
+
+	/*
+	 * Format handling:
+	 */
+
 	/* get msm_format w/ optional format modifiers from drm_mode_fb_cmd2 */
 	const struct msm_format *(*get_format)(struct msm_kms *kms,
 					const uint32_t format,
@@ -45,6 +80,7 @@ struct msm_kms_funcs {
 			const struct msm_format *msm_fmt,
 			const struct drm_mode_fb_cmd2 *cmd,
 			struct drm_gem_object **bos);
+
 	/* misc: */
 	long (*round_pixclk)(struct msm_kms *kms, unsigned long rate,
 			struct drm_encoder *encoder);

commit 80b4b4a703d6e4fb966e5c6a7c74a06001bf7d19
Author: Rob Clark <robdclark@chromium.org>
Date:   Thu Aug 29 09:45:13 2019 -0700

    drm/msm: convert kms->complete_commit() to crtc_mask
    
    Prep work for async commits, in which case this will be called after we
    no longer have the atomic state object.
    
    This drops some wait_for_vblanks(), but those should be unnecessary, as
    we call this after waiting for flush to complete.
    
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Reviewed-by: Sean Paul <sean@poorly.run>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index a112dfb36301..10dd171b43f8 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -33,7 +33,7 @@ struct msm_kms_funcs {
 	/* modeset, bracketing atomic_commit(): */
 	void (*prepare_commit)(struct msm_kms *kms, struct drm_atomic_state *state);
 	void (*commit)(struct msm_kms *kms, struct drm_atomic_state *state);
-	void (*complete_commit)(struct msm_kms *kms, struct drm_atomic_state *state);
+	void (*complete_commit)(struct msm_kms *kms, unsigned crtc_mask);
 	void (*wait_flush)(struct msm_kms *kms, unsigned crtc_mask);
 
 	/* get msm_format w/ optional format modifiers from drm_mode_fb_cmd2 */

commit d4d2c60497cfc5063f129010521ba69f34f33127
Author: Rob Clark <robdclark@chromium.org>
Date:   Thu Aug 29 09:45:12 2019 -0700

    drm/msm: add kms->wait_flush()
    
    First step in re-working the atomic related internal API to prepare for
    async updates pending.. ->wait_flush() is intended to block until there
    is no in-progress flush.
    
    A crtc_mask is used, rather than an atomic state object, as this will
    later be used for async flush after the atomic state is destroyed.
    
    This replaces ->wait_for_crtc_commit_done()
    
    v2: update for review comments
    
    Signed-off-by: Rob Clark <robdclark@chromium.org>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index c7588a42635e..a112dfb36301 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -34,9 +34,8 @@ struct msm_kms_funcs {
 	void (*prepare_commit)(struct msm_kms *kms, struct drm_atomic_state *state);
 	void (*commit)(struct msm_kms *kms, struct drm_atomic_state *state);
 	void (*complete_commit)(struct msm_kms *kms, struct drm_atomic_state *state);
-	/* functions to wait for atomic commit completed on each CRTC */
-	void (*wait_for_crtc_commit_done)(struct msm_kms *kms,
-					struct drm_crtc *crtc);
+	void (*wait_flush)(struct msm_kms *kms, unsigned crtc_mask);
+
 	/* get msm_format w/ optional format modifiers from drm_mode_fb_cmd2 */
 	const struct msm_format *(*get_format)(struct msm_kms *kms,
 					const uint32_t format,
@@ -98,4 +97,8 @@ struct msm_mdss {
 int mdp5_mdss_init(struct drm_device *dev);
 int dpu_mdss_init(struct drm_device *dev);
 
+#define for_each_crtc_mask(dev, crtc, crtc_mask) \
+	drm_for_each_crtc(crtc, dev) \
+		for_each_if (drm_crtc_mask(crtc) & (crtc_mask))
+
 #endif /* __MSM_KMS_H__ */

commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 2b81b43a4bab..c7588a42635e 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -1,19 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (c) 2016-2018, The Linux Foundation. All rights reserved.
  * Copyright (C) 2013 Red Hat
  * Author: Rob Clark <robdclark@gmail.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef __MSM_KMS_H__

commit 3750e78c72da3c35292dcf531ebe3062faaa33bc
Author: Bruce Wang <bzwang@chromium.org>
Date:   Fri Oct 5 17:04:01 2018 -0400

    drm/msm: Cut dpu_kms hooks from msm_pm_suspend/resume
    
    Removes the traces of the non-atomic helper calls in
    msm_pm_suspend/resume since we just deleted those functions (see patch
    1). Also removes the drm_kms_helper_poll_disable/enable calls, since
    the DRM_CONNECTOR_POLL_CONNECT flag is never set so periodic polling
    doesn't happen anyways.
    
    v2: reorganized patch order
    v3: made error checks less severe
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Bruce Wang <bzwang@chromium.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index fd88cebb6adb..2b81b43a4bab 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -67,9 +67,6 @@ struct msm_kms_funcs {
 	void (*set_encoder_mode)(struct msm_kms *kms,
 				 struct drm_encoder *encoder,
 				 bool cmd_mode);
-	/* pm suspend/resume hooks */
-	int (*pm_suspend)(struct device *dev);
-	int (*pm_resume)(struct device *dev);
 	/* cleanup: */
 	void (*destroy)(struct msm_kms *kms);
 #ifdef CONFIG_DEBUG_FS

commit 25fdd5933e4c0f5fe2ea5cd59994f8ac5fbe90ef
Author: Jeykumar Sankaran <jsanka@codeaurora.org>
Date:   Wed Jun 27 15:26:09 2018 -0400

    drm/msm: Add SDM845 DPU support
    
    SDM845 SoC includes the Mobile Display Sub System (MDSS) which is a
    top level wrapper consisting of Display Processing Unit (DPU) and
    display peripheral modules such as Display Serial Interface (DSI)
    and DisplayPort (DP).
    
    MDSS functions essentially as a back-end composition engine. It blends
    video and graphic images stored in the frame buffers and scans out the
    composed image to a display sink (over DSI/DP).
    
    The following diagram represents hardware blocks for a simple pipeline
    (two planes are present on a given crtc which is connected to a DSI
    connector):
    
           MDSS
          +---------------------------------+
          | +-----------------------------+ |
          | | DPU                         | |
          | |  +--------+  +--------+     | |
          | |  |  SSPP  |  |  SSPP  |     | |
          | |  +----+---+  +----+---+     | |
          | |       |           |         | |
          | |  +----v-----------v---+     | |
          | |  |  Layer Mixer (LM)  |     | |
          | |  +--------------------+     | |
          | |  +--------------------+     | |
          | |  |    PingPong (PP)   |     | |
          | |  +--------------------+     | |
          | |  +--------------------+     | |
          | |  |  INTERFACE (VIDEO) |     | |
          | |  +---+----------------+     | |
          | +------|----------------------+ |
          |        |                        |
          | +------|---------------------+  |
          | |      | DISPLAY PERIPHERALS |  |
          | |  +---v-+      +-----+      |  |
          | |  | DSI |      |  DP |      |  |
          | |  +-----+      +-----+      |  |
          | +----------------------------+  |
          +---------------------------------+
    
    The number of DPU sub-blocks (i.e. SSPPs, LMs, PP blocks and INTFs)
    depends on SoC capabilities.
    
    Overview of DPU sub-blocks:
    ---------------------------
    * Source Surface Processor (SSPP):
     Refers to any of hardware pipes like ViG, DMA etc. Only ViG pipes are
     capable of performing format conversion, scaling and quality improvement
     for source surfaces.
    
    * Layer Mixer (LM):
     Blend source surfaces together (in requested zorder)
    
    * PingPong (PP):
     This block controls frame done interrupt output, EOL and EOF generation,
     overflow/underflow control.
    
    * Display interface (INTF):
     Timing generator and interface connecting the display peripherals.
    
    DRM components mapping to DPU architecture:
    ------------------------------------------
    PLANEs maps to SSPPs
    CRTC maps to LMs
    Encoder maps to PPs, INTFs
    
    Data flow setup:
    ---------------
    MDSS hardware can support various data flows (e.g.):
      - Dual pipe: Output from two LMs combined to single display.
      - Split display: Output from two LMs connected to two separate
                       interfaces.
    
    The hardware capabilities determine the number of concurrent data paths
    possible. Any control path (i.e. pipeline w/i DPU) can be routed to any
    of the hardware data paths. A given control path can be triggered,
    flushed and controlled independently.
    
    Changes in v3:
    - Move msm_media_info.h from uapi to dpu/ subdir
    - Remove preclose callback dpu (it's handled in core)
    - Fix kbuild warnings with parent_ops
    - Remove unused functions from dpu_core_irq
    - Rename mdss_phys to mdss
    - Rename mdp_phys address space to mdp
    - Drop _phys from vbif and regdma binding names
    
    Signed-off-by: Abhinav Kumar <abhinavk@codeaurora.org>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Chandan Uddaraju <chandanu@codeaurora.org>
    Signed-off-by: Jeykumar Sankaran <jsanka@codeaurora.org>
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Rajesh Yadav <ryadav@codeaurora.org>
    Signed-off-by: Sravanthi Kollukuduru <skolluku@codeaurora.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    [robclark minor rebase]
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index c15de28ae2dd..fd88cebb6adb 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -1,4 +1,5 @@
 /*
+ * Copyright (c) 2016-2018, The Linux Foundation. All rights reserved.
  * Copyright (C) 2013 Red Hat
  * Author: Rob Clark <robdclark@gmail.com>
  *
@@ -51,6 +52,11 @@ struct msm_kms_funcs {
 	const struct msm_format *(*get_format)(struct msm_kms *kms,
 					const uint32_t format,
 					const uint64_t modifiers);
+	/* do format checking on format modified through fb_cmd2 modifiers */
+	int (*check_modified_format)(const struct msm_kms *kms,
+			const struct msm_format *msm_fmt,
+			const struct drm_mode_fb_cmd2 *cmd,
+			struct drm_gem_object **bos);
 	/* misc: */
 	long (*round_pixclk)(struct msm_kms *kms, unsigned long rate,
 			struct drm_encoder *encoder);
@@ -90,6 +96,7 @@ static inline void msm_kms_init(struct msm_kms *kms,
 
 struct msm_kms *mdp4_kms_init(struct drm_device *dev);
 struct msm_kms *mdp5_kms_init(struct drm_device *dev);
+struct msm_kms *dpu_kms_init(struct drm_device *dev);
 
 struct msm_mdss_funcs {
 	int (*enable)(struct msm_mdss *mdss);
@@ -103,5 +110,6 @@ struct msm_mdss {
 };
 
 int mdp5_mdss_init(struct drm_device *dev);
+int dpu_mdss_init(struct drm_device *dev);
 
 #endif /* __MSM_KMS_H__ */

commit 036bfeb33b89578ab924fa198213260659e08dc8
Author: Jeykumar Sankaran <jsanka@codeaurora.org>
Date:   Wed Jun 27 15:24:17 2018 -0400

    drm/msm: Add pm_suspend/resume callbacks to msm_kms
    
    Used by the dpu driver for custom suspend/resume.
    
    Changes in v3:
    - None
    
    Signed-off-by: Jeykumar Sankaran <jsanka@codeaurora.org>
    [seanpaul split this out of the megapatch]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 761bb07cd7bf..c15de28ae2dd 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -61,6 +61,9 @@ struct msm_kms_funcs {
 	void (*set_encoder_mode)(struct msm_kms *kms,
 				 struct drm_encoder *encoder,
 				 bool cmd_mode);
+	/* pm suspend/resume hooks */
+	int (*pm_suspend)(struct device *dev);
+	int (*pm_resume)(struct device *dev);
 	/* cleanup: */
 	void (*destroy)(struct msm_kms *kms);
 #ifdef CONFIG_DEBUG_FS

commit 2b7ac1a8989829b085fae9750817ca3304047c04
Author: Jeykumar Sankaran <jsanka@codeaurora.org>
Date:   Wed Jun 27 13:49:23 2018 -0400

    drm/msm: Add .commit() callback to msm_kms functions
    
    Called right before wait_for_commit_done() to perform kickoff for
    active crtcs.
    
    Changes in v3:
    - None
    
    Signed-off-by: Jeykumar Sankaran <jsanka@codeaurora.org>
    [seanpaul split this out of the megapatch]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 76c14221ffdf..761bb07cd7bf 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -42,6 +42,7 @@ struct msm_kms_funcs {
 	void (*disable_vblank)(struct msm_kms *kms, struct drm_crtc *crtc);
 	/* modeset, bracketing atomic_commit(): */
 	void (*prepare_commit)(struct msm_kms *kms, struct drm_atomic_state *state);
+	void (*commit)(struct msm_kms *kms, struct drm_atomic_state *state);
 	void (*complete_commit)(struct msm_kms *kms, struct drm_atomic_state *state);
 	/* functions to wait for atomic commit completed on each CRTC */
 	void (*wait_for_crtc_commit_done)(struct msm_kms *kms,

commit bc3220be22577e199452edbb6a24a980a4ab5c73
Author: Rajesh Yadav <ryadav@codeaurora.org>
Date:   Thu Jun 21 16:06:10 2018 -0400

    drm/msm/mdp5: subclass msm_mdss for mdp5
    
    SoCs having mdp5 or dpu have identical tree like
    device hierarchy where MDSS top level wrapper manages
    common power resources for all child devices.
    
    Subclass msm_mdss so that msm_mdss includes common defines
    and mdp5/dpu mdss derivations to include any extensions.
    
    Add mdss helper interface (msm_mdss_funcs) to msm_mdss
    base for mdp5/dpu mdss specific implementation calls.
    
    This change subclasses msm_mdss for mdp5, dpu specific
    changes will be done separately.
    
    Changes in v3:
    - Added Archit's R-b
    
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rajesh Yadav <ryadav@codeaurora.org>
    [seanpaul rebased on msm-next and resolved conflicts]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index dfd92947de2c..76c14221ffdf 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -86,9 +86,18 @@ static inline void msm_kms_init(struct msm_kms *kms,
 
 struct msm_kms *mdp4_kms_init(struct drm_device *dev);
 struct msm_kms *mdp5_kms_init(struct drm_device *dev);
-int msm_mdss_init(struct drm_device *dev);
-void msm_mdss_destroy(struct drm_device *dev);
-int msm_mdss_enable(struct msm_mdss *mdss);
-int msm_mdss_disable(struct msm_mdss *mdss);
+
+struct msm_mdss_funcs {
+	int (*enable)(struct msm_mdss *mdss);
+	int (*disable)(struct msm_mdss *mdss);
+	void (*destroy)(struct drm_device *dev);
+};
+
+struct msm_mdss {
+	struct drm_device *dev;
+	const struct msm_mdss_funcs *funcs;
+};
+
+int mdp5_mdss_init(struct drm_device *dev);
 
 #endif /* __MSM_KMS_H__ */

commit c21c731d93e8148d926a63797d33075128e60cdd
Author: Archit Taneja <architt@codeaurora.org>
Date:   Wed Feb 21 09:37:24 2018 -0500

    drm/msm: Don't subclass drm_atomic_state anymore
    
    With the addition of "private_objs" in drm_atomic_state, we no longer
    need to subclass drm_atomic_state to store state of share resources
    that don't perfectly fit within planes/crtc/connector state information.
    We can now save this state within drm_atomic_state itself using
    the private objects.
    
    Remove the infrastructure that allowed subclassing of drm_atomic_state
    in the driver.
    
    Changes in v3:
    - Added to the msm atomic helper patch set
    Changes in v4:
    - None
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index aaa329dc020e..dfd92947de2c 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -40,8 +40,6 @@ struct msm_kms_funcs {
 	irqreturn_t (*irq)(struct msm_kms *kms);
 	int (*enable_vblank)(struct msm_kms *kms, struct drm_crtc *crtc);
 	void (*disable_vblank)(struct msm_kms *kms, struct drm_crtc *crtc);
-	/* swap global atomic state: */
-	void (*swap_state)(struct msm_kms *kms, struct drm_atomic_state *state);
 	/* modeset, bracketing atomic_commit(): */
 	void (*prepare_commit)(struct msm_kms *kms, struct drm_atomic_state *state);
 	void (*complete_commit)(struct msm_kms *kms, struct drm_atomic_state *state);
@@ -80,18 +78,6 @@ struct msm_kms {
 	struct msm_gem_address_space *aspace;
 };
 
-/**
- * Subclass of drm_atomic_state, to allow kms backend to have driver
- * private global state.  The kms backend can do whatever it wants
- * with the ->state ptr.  On ->atomic_state_clear() the ->state ptr
- * is kfree'd and set back to NULL.
- */
-struct msm_kms_state {
-	struct drm_atomic_state base;
-	void *state;
-};
-#define to_kms_state(x) container_of(x, struct msm_kms_state, base)
-
 static inline void msm_kms_init(struct msm_kms *kms,
 		const struct msm_kms_funcs *funcs)
 {

commit 4e4902324a9b46a9111d5e514301e154f938238a
Author: Jeykumar Sankaran <jsanka@codeaurora.org>
Date:   Tue Feb 13 12:42:44 2018 -0500

    drm/msm: Add modifier to mdp_get_format arguments
    
    This change plumbs the new fb modifier through the various mdp/disp
    get_format hooks.
    
    Signed-off-by: Jeykumar Sankaran <jsanka@codeaurora.org>
    [seanpaul pimped out commit message a bit]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 17d5824417ad..aaa329dc020e 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -48,8 +48,11 @@ struct msm_kms_funcs {
 	/* functions to wait for atomic commit completed on each CRTC */
 	void (*wait_for_crtc_commit_done)(struct msm_kms *kms,
 					struct drm_crtc *crtc);
+	/* get msm_format w/ optional format modifiers from drm_mode_fb_cmd2 */
+	const struct msm_format *(*get_format)(struct msm_kms *kms,
+					const uint32_t format,
+					const uint64_t modifiers);
 	/* misc: */
-	const struct msm_format *(*get_format)(struct msm_kms *kms, uint32_t format);
 	long (*round_pixclk)(struct msm_kms *kms, unsigned long rate,
 			struct drm_encoder *encoder);
 	int (*set_split_display)(struct msm_kms *kms,

commit 774e39ee3572272b816f3a0b39dfdbcc70dd47f1
Author: Archit Taneja <architt@codeaurora.org>
Date:   Fri Jul 28 16:17:07 2017 +0530

    drm/msm/mdp5: Set up runtime PM for MDSS
    
    MDSS represents the top level wrapper that contains MDP5, DSI, HDMI and
    other sub-blocks. W.r.t device heirarchy, it's the parent of all these
    devices. The power domain of this device is actually tied to the GDSC
    hw. When any sub-device enables its PD, MDSS's PD is also enabled.
    
    The suspend/resume ops enable the top level clocks that end at the MDSS
    boundary. For now, we're letting them all be optional, since the child
    devices anyway hold a ref to these clocks.
    
    Until now, we'd called a runtime_get() during probe, which ensured that
    the GDSC was always on. Now that we've set up runtime PM for the children
    devices, we can get rid of this hack.
    
    Note: that the MDSS device is the platform_device in msm_drv.c. The
    msm_runtime_suspend/resume ops call the funcs that enable/disable
    the top level MDSS clocks. This is different from MDP4, where the
    platform device created in msm_drv.c represents MDP4 itself. It would
    have been nicer to hide these differences by adding new kms funcs, but
    runtime PM needs to be enabled before kms is set up (i.e, msm_kms_init
    is called).
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index a8f2ba5e5f07..17d5824417ad 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -99,5 +99,7 @@ struct msm_kms *mdp4_kms_init(struct drm_device *dev);
 struct msm_kms *mdp5_kms_init(struct drm_device *dev);
 int msm_mdss_init(struct drm_device *dev);
 void msm_mdss_destroy(struct drm_device *dev);
+int msm_mdss_enable(struct msm_mdss *mdss);
+int msm_mdss_disable(struct msm_mdss *mdss);
 
 #endif /* __MSM_KMS_H__ */

commit 8432a903fb97ac3640dbf9281e7c15a673b45747
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Jun 13 14:27:45 2017 -0400

    drm/msm: remove address-space id
    
    Now that the msm_gem supports an arbitrary number of vma's, we no longer
    need to assign an id (index) to each address space.  So rip out the
    associated code.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 0b98171415fc..a8f2ba5e5f07 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -74,7 +74,6 @@ struct msm_kms {
 	int irq;
 
 	/* mapper-id used to request GEM buffer mapped for scanout: */
-	int id;
 	struct msm_gem_address_space *aspace;
 };
 

commit f59f62d592a0553bbff6c5b2ba66036becb01c4a
Author: Rob Clark <robdclark@gmail.com>
Date:   Tue Jun 13 10:22:37 2017 -0400

    drm/msm/mdp4+5: move aspace/id to base class
    
    Before we can shift to passing the address-space object to _get_iova(),
    we need to fix a few places (dsi+fbdev) that were hard-coding the adress
    space id.  That gets somewhat easier if we just move these to the kms
    base class.
    
    Prep work for next patch.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index faa22c7c5423..0b98171415fc 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -72,6 +72,10 @@ struct msm_kms {
 
 	/* irq number to be passed on to drm_irq_install */
 	int irq;
+
+	/* mapper-id used to request GEM buffer mapped for scanout: */
+	int id;
+	struct msm_gem_address_space *aspace;
 };
 
 /**

commit 85eac4700ede7c583aab29ad6bdfe135f693c29b
Author: Noralf Trønnes <noralf@tronnes.org>
Date:   Tue Mar 7 21:49:22 2017 +0100

    drm/msm: Remove msm_debugfs_cleanup()
    
    Move the contents of msm_debugfs_cleanup() to msm_drm_uninit() to free
    up the drm_driver->debugfs_cleanup callback. Also remove the
    mdp_kms_funcs->debugfs_cleanup callback which has no users.
    
    Cc: robdclark@gmail.com
    Signed-off-by: Noralf Trønnes <noralf@tronnes.org>
    Acked-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170307204924.1002-2-noralf@tronnes.org

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 117635d2b8c5..faa22c7c5423 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -64,7 +64,6 @@ struct msm_kms_funcs {
 #ifdef CONFIG_DEBUG_FS
 	/* debugfs: */
 	int (*debugfs_init)(struct msm_kms *kms, struct drm_minor *minor);
-	void (*debugfs_cleanup)(struct msm_kms *kms, struct drm_minor *minor);
 #endif
 };
 

commit 9c9f6f8d472cc9e11f2c0b370685ce78ab7eb2fa
Author: Archit Taneja <architt@codeaurora.org>
Date:   Mon Dec 5 15:24:53 2016 +0530

    drm/msm: Set encoder's mode of operation using a kms func
    
    The mdp5 kms driver currently sets up multiple encoders per interface
    (INTF), one for each kind of mode of operation it supports.
    We create 2 drm_encoders for DSI, one for Video Mode and the other
    for Command Mode operation. The reason behind this approach could have
    been that we aren't aware of the DSI device's mode of operation when
    we create the encoders.
    
    This makes things a bit complicated, since these encoders have to
    be further attached to the same DSI bridge. The easier way out is
    to create a single encoder, and make the DSI driver set its mode
    of operation when we know what the DSI device's mode flags are.
    
    Start with providing a way to set the mdp5_intf_mode using a kms
    func that sets the encoder's mode of operation. When constructing
    a DSI encoder, we set the mode of operation to Video Mode as
    default. When the DSI device is attached to the host, we probe the
    DSI mode flags and set the corresponding mode of operation.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index e470f4cf8f76..117635d2b8c5 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -56,6 +56,9 @@ struct msm_kms_funcs {
 			struct drm_encoder *encoder,
 			struct drm_encoder *slave_encoder,
 			bool is_cmd_mode);
+	void (*set_encoder_mode)(struct msm_kms *kms,
+				 struct drm_encoder *encoder,
+				 bool cmd_mode);
 	/* cleanup: */
 	void (*destroy)(struct msm_kms *kms);
 #ifdef CONFIG_DEBUG_FS

commit bc5289eed4817604d0fb709bd53b2e3bf1dcb73a
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Oct 26 14:06:55 2016 -0400

    drm/msm/mdp5: add debugfs to show smp block status
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index cb9758bcadfd..e470f4cf8f76 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -58,6 +58,11 @@ struct msm_kms_funcs {
 			bool is_cmd_mode);
 	/* cleanup: */
 	void (*destroy)(struct msm_kms *kms);
+#ifdef CONFIG_DEBUG_FS
+	/* debugfs: */
+	int (*debugfs_init)(struct msm_kms *kms, struct drm_minor *minor);
+	void (*debugfs_cleanup)(struct msm_kms *kms, struct drm_minor *minor);
+#endif
 };
 
 struct msm_kms {

commit 870d738acb7ebb0d4f6192c9d328cae95479715b
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Nov 4 13:51:42 2016 -0400

    drm/msm: subclass drm_atomic_state
    
    This will give the kms backends a slot to stash their own hw specific
    global state.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 40e41e5cdbc6..cb9758bcadfd 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -40,6 +40,8 @@ struct msm_kms_funcs {
 	irqreturn_t (*irq)(struct msm_kms *kms);
 	int (*enable_vblank)(struct msm_kms *kms, struct drm_crtc *crtc);
 	void (*disable_vblank)(struct msm_kms *kms, struct drm_crtc *crtc);
+	/* swap global atomic state: */
+	void (*swap_state)(struct msm_kms *kms, struct drm_atomic_state *state);
 	/* modeset, bracketing atomic_commit(): */
 	void (*prepare_commit)(struct msm_kms *kms, struct drm_atomic_state *state);
 	void (*complete_commit)(struct msm_kms *kms, struct drm_atomic_state *state);
@@ -65,6 +67,18 @@ struct msm_kms {
 	int irq;
 };
 
+/**
+ * Subclass of drm_atomic_state, to allow kms backend to have driver
+ * private global state.  The kms backend can do whatever it wants
+ * with the ->state ptr.  On ->atomic_state_clear() the ->state ptr
+ * is kfree'd and set back to NULL.
+ */
+struct msm_kms_state {
+	struct drm_atomic_state base;
+	void *state;
+};
+#define to_kms_state(x) container_of(x, struct msm_kms_state, base)
+
 static inline void msm_kms_init(struct msm_kms *kms,
 		const struct msm_kms_funcs *funcs)
 {

commit 392ae6e0efa5e27e977b1cdf88c619c0434a7417
Author: Archit Taneja <architt@codeaurora.org>
Date:   Tue Jun 14 18:24:54 2016 +0530

    drm/msm/mdp5: Remove old kms init/destroy funcs
    
    With the new kms_init/destroy funcs in place for MDP5, we can get rid of
    the old kms funcs. Some members of the mdp5_kms struct also become
    redundant, so we remove those too.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 13f893d1a518..40e41e5cdbc6 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -73,7 +73,6 @@ static inline void msm_kms_init(struct msm_kms *kms,
 
 struct msm_kms *mdp4_kms_init(struct drm_device *dev);
 struct msm_kms *mdp5_kms_init(struct drm_device *dev);
-struct msm_kms *mdp5_kms_init2(struct drm_device *dev);
 int msm_mdss_init(struct drm_device *dev);
 void msm_mdss_destroy(struct drm_device *dev);
 

commit aec095ecbcc70653a014ccb8c57abc094089e9fa
Author: Archit Taneja <architt@codeaurora.org>
Date:   Tue Jun 14 18:23:52 2016 +0530

    drm/msm/mdp5: Prepare new kms_init funcs
    
    With MDP5 as a new device, we need to do less for MDP when initializing
    modeset after all the components are bound.
    
    Create mdp5_kms_init2/destroy2 funcs that inits modeset. These will
    eventually replace the older kms_init/destroy funcs.
    
    In the new kms_init2, the platform_device used is the one corresponding
    to the new MDP5 platform_device. The new change here is that the irq is
    now retrieved using irq_of_parse_and_map(), since MDP5 is a child interrupt
    of the MDSS interrupt controller.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 40e41e5cdbc6..13f893d1a518 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -73,6 +73,7 @@ static inline void msm_kms_init(struct msm_kms *kms,
 
 struct msm_kms *mdp4_kms_init(struct drm_device *dev);
 struct msm_kms *mdp5_kms_init(struct drm_device *dev);
+struct msm_kms *mdp5_kms_init2(struct drm_device *dev);
 int msm_mdss_init(struct drm_device *dev);
 void msm_mdss_destroy(struct drm_device *dev);
 

commit 990a40079a55b81b5b6aef91a24aa053fb370072
Author: Archit Taneja <architt@codeaurora.org>
Date:   Sat May 7 23:11:25 2016 +0530

    drm/msm/mdp5: Add MDSS top level driver
    
    SoCs that contain MDP5 have a top level wrapper called MDSS that manages
    clocks, power and irq for the sub-blocks within it.
    
    Currently, the MDSS portions are stuffed into the MDP5 driver. This makes
    it hard to represent the DT bindings in the correct way. We create a top
    level MDSS helper that handles these parts. This is essentially moving out
    some of the mdp5_kms irq code and MDSS register space and keeping it as a
    separate entity. We haven't given any clocks to the top level MDSS yet,
    but a AHB clock would be added in the future to access registers.
    
    One thing to note is that the resources allocated by this helper are
    tied to the top level platform_device (the one that allocates the
    drm_device struct too). This device would be the parent to MDSS
    sub-blocks like MDP5, DSI, eDP etc.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 0452856355c1..40e41e5cdbc6 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -73,5 +73,7 @@ static inline void msm_kms_init(struct msm_kms *kms,
 
 struct msm_kms *mdp4_kms_init(struct drm_device *dev);
 struct msm_kms *mdp5_kms_init(struct drm_device *dev);
+int msm_mdss_init(struct drm_device *dev);
+void msm_mdss_destroy(struct drm_device *dev);
 
 #endif /* __MSM_KMS_H__ */

commit a2b3a5571f386e23b56164396292675bac6f2a19
Author: Archit Taneja <architt@codeaurora.org>
Date:   Wed May 18 15:06:03 2016 +0530

    drm/msm: Get irq number within kms driver itself
    
    The driver gets the irq number using platform_get_irq on the main kms
    platform device. This works fine since both MDP4 and MDP5 currently
    have a flat device hierarchy. The platform device tied with the
    drm_device points to the MDP DT node in both cases.
    
    This won't work when MDP5 supports a tree-like hierarchy. In this
    case, the platform device tied to the top level drm_device is the
    MDSS DT node, and the irq we need for KMS is the one generated by
    MDP5, not MDSS.
    
    Get the irq number from the MDP4/5 kms driver itself. Each driver
    can later provide the irq number based on what device hierarchy it
    uses.
    
    While we're at it, call drm_irq_install only when we have a valid KMS
    driver.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 00998f9ef16a..0452856355c1 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -60,6 +60,9 @@ struct msm_kms_funcs {
 
 struct msm_kms {
 	const struct msm_kms_funcs *funcs;
+
+	/* irq number to be passed on to drm_irq_install */
+	int irq;
 };
 
 static inline void msm_kms_init(struct msm_kms *kms,

commit 7429d860c1dce7361f97179ad096f1b0e64d40c4
Author: Archit Taneja <architt@codeaurora.org>
Date:   Fri May 6 18:17:15 2016 +0530

    drm/msm: Remove unused fields
    
    These aren't used. Probably left overs when driver was refactored to
    support both MDP4 and MDP5.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index e32222c3d44f..00998f9ef16a 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -60,11 +60,6 @@ struct msm_kms_funcs {
 
 struct msm_kms {
 	const struct msm_kms_funcs *funcs;
-
-	/* irq handling: */
-	bool in_irq;
-	struct list_head irq_list;    /* list of mdp4_irq */
-	uint32_t vblank_mask;         /* irq bits set for userspace vblank */
 };
 
 static inline void msm_kms_init(struct msm_kms *kms,

commit 4016260ba47a43ec67d4bf3610be37fcb2e416d7
Author: Rob Clark <robdclark@gmail.com>
Date:   Wed Mar 23 07:10:17 2016 -0400

    drm/msm: fix bug after preclose removal
    
    commit 53190c7194d9a8337fe419134e44c30eb63ebd08
    Author:     Daniel Vetter <daniel.vetter@ffwll.ch>
    AuthorDate: Mon Jan 25 22:16:49 2016 +0100
    Commit:     Daniel Vetter <daniel.vetter@ffwll.ch>
    CommitDate: Mon Feb 8 09:55:50 2016 +0100
    
        drm/msm: Nuke preclose hooks
    
    Left around the unused (and null) preclose fxn ptr, and things
    predictibly explode when you try to call that.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 9bcabaada179..e32222c3d44f 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -55,7 +55,6 @@ struct msm_kms_funcs {
 			struct drm_encoder *slave_encoder,
 			bool is_cmd_mode);
 	/* cleanup: */
-	void (*preclose)(struct msm_kms *kms, struct drm_file *file);
 	void (*destroy)(struct msm_kms *kms);
 };
 

commit 0a5c9aad119c4415e14ece4c17cec66aa572e827
Author: Hai Li <hali@codeaurora.org>
Date:   Tue Apr 28 19:35:37 2015 -0400

    drm/msm: Use customized function to wait for atomic commit done
    
    MDP FLUSH registers could indicate if the previous flush updates
    has taken effect at vsync boundary. Making use of this H/W feature
    can catch the vsync that happened between CRTC atomic_flush and
    *_wait_for_vblanks, to avoid unnecessary wait.
    
    This change allows kms CRTCs to use their own *_wait_for_commit_done
    functions to wait for FLUSH register cleared at vsync, before commit
    completion.
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index a9f17bdb4530..9bcabaada179 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -43,6 +43,9 @@ struct msm_kms_funcs {
 	/* modeset, bracketing atomic_commit(): */
 	void (*prepare_commit)(struct msm_kms *kms, struct drm_atomic_state *state);
 	void (*complete_commit)(struct msm_kms *kms, struct drm_atomic_state *state);
+	/* functions to wait for atomic commit completed on each CRTC */
+	void (*wait_for_crtc_commit_done)(struct msm_kms *kms,
+					struct drm_crtc *crtc);
 	/* misc: */
 	const struct msm_format *(*get_format)(struct msm_kms *kms, uint32_t format);
 	long (*round_pixclk)(struct msm_kms *kms, unsigned long rate,

commit 7a6dc9550d0a17e3f24b2c13582f093193cd08ef
Author: Hai Li <hali@codeaurora.org>
Date:   Thu Mar 26 19:25:15 2015 -0400

    drm/msm: Add split display interface
    
    This change is to add an interface to MDP for connector devices
    setting split display information.
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 3a78cb48662b..a9f17bdb4530 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -47,6 +47,10 @@ struct msm_kms_funcs {
 	const struct msm_format *(*get_format)(struct msm_kms *kms, uint32_t format);
 	long (*round_pixclk)(struct msm_kms *kms, unsigned long rate,
 			struct drm_encoder *encoder);
+	int (*set_split_display)(struct msm_kms *kms,
+			struct drm_encoder *encoder,
+			struct drm_encoder *slave_encoder,
+			bool is_cmd_mode);
 	/* cleanup: */
 	void (*preclose)(struct msm_kms *kms, struct drm_file *file);
 	void (*destroy)(struct msm_kms *kms);

commit 7ca12718b393a6b71fc62782a64737b5c9dc6d3c
Author: Stephane Viau <sviau@codeaurora.org>
Date:   Mon Dec 8 10:48:57 2014 -0500

    drm/msm/mdp: add common YUV information for MDP4/MDP5
    
    Both MDP4 and MDP5 share some code as far as YUV support is
    concerned. This change adds this information and will be followed
    by the actual MDP4 and MDP5 YUV support patches.
    
    Signed-off-by: Stephane Viau <sviau@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 867672eb1fee..3a78cb48662b 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -23,6 +23,8 @@
 
 #include "msm_drv.h"
 
+#define MAX_PLANE	4
+
 /* As there are different display controller blocks depending on the
  * snapdragon version, the kms support is split out and the appropriate
  * implementation is loaded at runtime.  The kms module is responsible

commit 0b776d457b9476e96a65d4daace8d8f668e010d4
Author: Rob Clark <robdclark@gmail.com>
Date:   Fri Jan 30 17:04:45 2015 -0500

    drm/msm: fix fallout of atomic dpms changes
    
    As a result of atomic DPMS support, the various prepare/commit hooks get
    called in a way that msm dislikes.  We were expecting prepare/commit to
    bracket a modeset, which is no longer the case.  This was needed to hold
    various extra clk's (such as interface clks) on while we are touching
    registers, and in the case of mdp4 holding vblank enabled.
    
    The most straightforward way to deal with this, since we already have
    our own atomic_commit(), is to just handle prepare/commit internally to
    the driver (with some additional vfuncs for mdp4 vs mdp5), and switch
    everything over to instead use the new enable/disable hooks.  It doesn't
    really change too much, despite the code motion.  What used to be in the
    encoder/crtc dpms() fxns is split out into enable/disable.
    
    We should be able to drop our own enable-state tracking, as the atomic
    helpers should do this for us.  But keeping that for the short term for
    extra debugging as atomic stablizes.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index 06437745bc2c..867672eb1fee 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -38,6 +38,9 @@ struct msm_kms_funcs {
 	irqreturn_t (*irq)(struct msm_kms *kms);
 	int (*enable_vblank)(struct msm_kms *kms, struct drm_crtc *crtc);
 	void (*disable_vblank)(struct msm_kms *kms, struct drm_crtc *crtc);
+	/* modeset, bracketing atomic_commit(): */
+	void (*prepare_commit)(struct msm_kms *kms, struct drm_atomic_state *state);
+	void (*complete_commit)(struct msm_kms *kms, struct drm_atomic_state *state);
 	/* misc: */
 	const struct msm_format *(*get_format)(struct msm_kms *kms, uint32_t format);
 	long (*round_pixclk)(struct msm_kms *kms, unsigned long rate,

commit 06c0dd96bfbba8a9368ffd7c4b12d3bfed37001d
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Nov 30 17:51:47 2013 -0500

    drm/msm: add mdp5/apq8x74
    
    Add support for the new MDP5 display controller block.  The mapping
    between parts of the display controller and KMS is:
    
      plane   -> PIPE{RGBn,VIGn}             \
      crtc    -> LM (layer mixer)            |-> MDP "device"
      encoder -> INTF                        /
      connector -> HDMI/DSI/eDP/etc          --> other device(s)
    
    Unlike MDP4, it appears we can get by with a single encoder, rather
    than needing a different implementation for DTV, DSI, etc.  (Ie. the
    register interface is same, just different bases.)
    
    Also unlike MDP4, all the IRQs for other blocks (HDMI, DSI, etc) are
    routed through MDP.
    
    And finally, MDP5 has this "Shared Memory Pool" (called "SMP"), from
    which blocks need to be allocated to the active pipes based on fetch
    stride.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index dc0d30f5b291..06437745bc2c 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -63,5 +63,6 @@ static inline void msm_kms_init(struct msm_kms *kms,
 }
 
 struct msm_kms *mdp4_kms_init(struct drm_device *dev);
+struct msm_kms *mdp5_kms_init(struct drm_device *dev);
 
 #endif /* __MSM_KMS_H__ */

commit 9e0efa63565511dc75846e6b036a4b80e92b9a98
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Nov 30 17:24:22 2013 -0500

    drm/msm: move irq utils to mdp_kms
    
    We'll want basically the same thing for mdp5, so refactor it out so it
    can be shared.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
index f01e239f7261..dc0d30f5b291 100644
--- a/drivers/gpu/drm/msm/msm_kms.h
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -49,8 +49,19 @@ struct msm_kms_funcs {
 
 struct msm_kms {
 	const struct msm_kms_funcs *funcs;
+
+	/* irq handling: */
+	bool in_irq;
+	struct list_head irq_list;    /* list of mdp4_irq */
+	uint32_t vblank_mask;         /* irq bits set for userspace vblank */
 };
 
+static inline void msm_kms_init(struct msm_kms *kms,
+		const struct msm_kms_funcs *funcs)
+{
+	kms->funcs = funcs;
+}
+
 struct msm_kms *mdp4_kms_init(struct drm_device *dev);
 
 #endif /* __MSM_KMS_H__ */

commit dd2da6e34672100b5fd811fbf2cf97e29c08080f
Author: Rob Clark <robdclark@gmail.com>
Date:   Sat Nov 30 16:12:10 2013 -0500

    drm/msm: split out msm_kms.h
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/msm_kms.h b/drivers/gpu/drm/msm/msm_kms.h
new file mode 100644
index 000000000000..f01e239f7261
--- /dev/null
+++ b/drivers/gpu/drm/msm/msm_kms.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2013 Red Hat
+ * Author: Rob Clark <robdclark@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __MSM_KMS_H__
+#define __MSM_KMS_H__
+
+#include <linux/clk.h>
+#include <linux/regulator/consumer.h>
+
+#include "msm_drv.h"
+
+/* As there are different display controller blocks depending on the
+ * snapdragon version, the kms support is split out and the appropriate
+ * implementation is loaded at runtime.  The kms module is responsible
+ * for constructing the appropriate planes/crtcs/encoders/connectors.
+ */
+struct msm_kms_funcs {
+	/* hw initialization: */
+	int (*hw_init)(struct msm_kms *kms);
+	/* irq handling: */
+	void (*irq_preinstall)(struct msm_kms *kms);
+	int (*irq_postinstall)(struct msm_kms *kms);
+	void (*irq_uninstall)(struct msm_kms *kms);
+	irqreturn_t (*irq)(struct msm_kms *kms);
+	int (*enable_vblank)(struct msm_kms *kms, struct drm_crtc *crtc);
+	void (*disable_vblank)(struct msm_kms *kms, struct drm_crtc *crtc);
+	/* misc: */
+	const struct msm_format *(*get_format)(struct msm_kms *kms, uint32_t format);
+	long (*round_pixclk)(struct msm_kms *kms, unsigned long rate,
+			struct drm_encoder *encoder);
+	/* cleanup: */
+	void (*preclose)(struct msm_kms *kms, struct drm_file *file);
+	void (*destroy)(struct msm_kms *kms);
+};
+
+struct msm_kms {
+	const struct msm_kms_funcs *funcs;
+};
+
+struct msm_kms *mdp4_kms_init(struct drm_device *dev);
+
+#endif /* __MSM_KMS_H__ */
