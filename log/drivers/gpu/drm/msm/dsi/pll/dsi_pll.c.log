commit 97fb5e8d9b57f10f294303c9a5d1bd033eded6bf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:58 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 284
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 and
      only version 2 as published by the free software foundation this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 294 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.825281744@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c b/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
index 7a1fb4da2ad3..4a4aa3c61d71 100644
--- a/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
+++ b/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
@@ -1,14 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include "dsi_pll.h"

commit 6a41da17e87dee2936645d9a51fccf932fa42981
Author: Mamta Shukla <mamtashukla555@gmail.com>
Date:   Sat Oct 20 23:19:26 2018 +0530

    drm: msm: Use DRM_DEV_* instead of dev_*
    
    Use DRM_DEV_INFO/ERROR/WARN instead of dev_info/err/debug to generate
    drm-formatted specific log messages so that it will be easy to
    differentiate in case of multiple instances of driver.
    
    Signed-off-by: Mamta Shukla <mamtashukla555@gmail.com>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c b/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
index 613e206fa4fc..7a1fb4da2ad3 100644
--- a/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
+++ b/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
@@ -175,7 +175,7 @@ struct msm_dsi_pll *msm_dsi_pll_init(struct platform_device *pdev,
 	}
 
 	if (IS_ERR(pll)) {
-		dev_err(dev, "%s: failed to init DSI PLL\n", __func__);
+		DRM_DEV_ERROR(dev, "%s: failed to init DSI PLL\n", __func__);
 		return pll;
 	}
 

commit 973e02db35c2c4036693e32ed6f250eefd8c322c
Author: Archit Taneja <architt@codeaurora.org>
Date:   Wed Jan 17 11:35:25 2018 +0530

    drm/msm/dsi: Add skeleton 10nm PHY/PLL code
    
    Add new 10nm DSI PLL/PHY files that will be used on SDM845.
    
    Just populate empty pll/phy funcs for now. These will be filled up
    later.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c b/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
index 491f08dce969..613e206fa4fc 100644
--- a/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
+++ b/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
@@ -166,6 +166,9 @@ struct msm_dsi_pll *msm_dsi_pll_init(struct platform_device *pdev,
 	case MSM_DSI_PHY_14NM:
 		pll = msm_dsi_pll_14nm_init(pdev, id);
 		break;
+	case MSM_DSI_PHY_10NM:
+		pll = msm_dsi_pll_10nm_init(pdev, id);
+		break;
 	default:
 		pll = ERR_PTR(-ENXIO);
 		break;

commit f0efc831d9439589efaf6406695470eca93ba08d
Author: Lloyd Atkinson <latkinso@codeaurora.org>
Date:   Tue Jan 16 16:26:01 2018 -0500

    drm/msm/dsi: check for failure on retrieving pll in dsi manager
    
    Make msm_dsi_pll_init consistently return an error code instead
    of NULL when pll initialization fails so that later pll
    retrieval can check against an error code. Add checks for these
    failures after retrieval of src_pll to avoid invalid pointer
    dereferences later in msm_dsi_pll_get_clk_provider.
    
    Signed-off-by: Lloyd Atkinson <latkinso@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c b/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
index bc289f5c9078..491f08dce969 100644
--- a/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
+++ b/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
@@ -173,7 +173,7 @@ struct msm_dsi_pll *msm_dsi_pll_init(struct platform_device *pdev,
 
 	if (IS_ERR(pll)) {
 		dev_err(dev, "%s: failed to init DSI PLL\n", __func__);
-		return NULL;
+		return pll;
 	}
 
 	pll->type = type;

commit f079f6d999cbf857f899732de680f2b62f245b8c
Author: Archit Taneja <architt@codeaurora.org>
Date:   Tue Jan 3 19:45:43 2017 +0530

    drm/msm/dsi: Add PHY/PLL for 8x96
    
    Extend the DSI PHY/PLL drivers to support the DSI 14nm PHY/PLL
    found on 8x96.
    
    These are picked up from the downstream driver. The PHY part is similar
    to the other DSI PHYs. The PLL driver requires some trickery so that
    one DSI PLL can drive both the DSIs (i.e, dual DSI mode).
    
    In the case of dual DSI mode. One DSI instance becomes the clock master,
    and other the clock slave. The master PLL's output (Byte and Pixel clock)
    is fed to both the DSI hosts/PHYs.
    
    When the DSIs are configured in dual DSI mode, the PHY driver communicates
    to the PLL driver using msm_dsi_pll_set_usecase() which instance is the
    master and which one is the slave. When setting rate, the master PLL also
    configures some of the slave PLL/PHY registers which need to be identical
    to the master's for correct dual DSI behaviour.
    
    There are 2 PLL post dividers that should have ideally been modelled as
    generic clk_divider clocks, but require some customization for dual DSI.
    In particular, when the master PLL's post-diviers are set, the slave PLL's
    post-dividers need to be set too. The clk_ops for these use clk_divider's
    helper ops and flags internally to prevent redundant code.
    
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c b/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
index 5cd438f91afe..bc289f5c9078 100644
--- a/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
+++ b/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
@@ -140,6 +140,15 @@ int msm_dsi_pll_restore_state(struct msm_dsi_pll *pll)
 	return 0;
 }
 
+int msm_dsi_pll_set_usecase(struct msm_dsi_pll *pll,
+			    enum msm_dsi_phy_usecase uc)
+{
+	if (pll->set_usecase)
+		return pll->set_usecase(pll, uc);
+
+	return 0;
+}
+
 struct msm_dsi_pll *msm_dsi_pll_init(struct platform_device *pdev,
 			enum msm_dsi_phy_type type, int id)
 {
@@ -154,6 +163,9 @@ struct msm_dsi_pll *msm_dsi_pll_init(struct platform_device *pdev,
 	case MSM_DSI_PHY_28NM_8960:
 		pll = msm_dsi_pll_28nm_8960_init(pdev, id);
 		break;
+	case MSM_DSI_PHY_14NM:
+		pll = msm_dsi_pll_14nm_init(pdev, id);
+		break;
 	default:
 		pll = ERR_PTR(-ENXIO);
 		break;

commit c6538de8dd5e08a5f2aac80900b170f2523711fb
Author: Archit Taneja <architt@codeaurora.org>
Date:   Wed Oct 14 12:03:44 2015 +0530

    drm/msm/dsi: Add DSI PLL for 28nm 8960 PHY
    
    Add DSI PLL common clock framework clocks for 8960 PHY.
    
    The PLL here is different from the ones found in B family msm chips. As
    before, the DSI provides two clocks to the outside world. dsixpll and
    dsixpllbyte (x = 1, 2). dsixpll is a regular clock divider, but
    dsixpllbyte is modelled as a custom clock divider.
    
    dsixpllbyte is the starting point of the PLL configuration. It is the
    one that sets up the VCO clock rate. We need the VCO clock rate in the
    form: F * byteclk, where F is a multiplication factor that varies on
    the byte clock the DSI driver is trying to set. We use the custom
    clk_ops for dsixpllbyte to ensure that the parent (VCO) is set at this
    rate.
    
    An additional divider (POSTDIV1) generates the bitclk. Since bit clock
    can be derived from byteclock, we calculate it internally, and don't
    expose it as a clock.
    
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c b/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
index 5104fc9f9a53..5cd438f91afe 100644
--- a/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
+++ b/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
@@ -151,6 +151,9 @@ struct msm_dsi_pll *msm_dsi_pll_init(struct platform_device *pdev,
 	case MSM_DSI_PHY_28NM_LP:
 		pll = msm_dsi_pll_28nm_init(pdev, type, id);
 		break;
+	case MSM_DSI_PHY_28NM_8960:
+		pll = msm_dsi_pll_28nm_8960_init(pdev, id);
+		break;
 	default:
 		pll = ERR_PTR(-ENXIO);
 		break;

commit 328e1a633c9bc26c36ecd320246e4a9b2726e81a
Author: Hai Li <hali@codeaurora.org>
Date:   Fri Jul 3 10:09:46 2015 -0400

    drm/msm/dsi: Save/Restore PLL status across PHY reset
    
    Reset DSI PHY silently changes its PLL registers to reset status,
    which will make cached status in clock driver invalid and result
    in wrong output rate of link clocks. The current restore mechanism
    in DSI PLL does not cover all the cases. This change is to recover
    PLL status after PHY reset to match HW status with cached status
    in clock driver.
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c b/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
index 509376fdd112..5104fc9f9a53 100644
--- a/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
+++ b/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
@@ -72,31 +72,14 @@ long msm_dsi_pll_helper_clk_round_rate(struct clk_hw *hw,
 int msm_dsi_pll_helper_clk_prepare(struct clk_hw *hw)
 {
 	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
-	int ret;
-
-	/*
-	 * Certain PLLs need to update the same VCO rate and registers
-	 * after resume in suspend/resume scenario.
-	 */
-	if (pll->restore_state) {
-		ret = pll->restore_state(pll);
-		if (ret)
-			goto error;
-	}
 
-	ret = dsi_pll_enable(pll);
-
-error:
-	return ret;
+	return dsi_pll_enable(pll);
 }
 
 void msm_dsi_pll_helper_clk_unprepare(struct clk_hw *hw)
 {
 	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
 
-	if (pll->save_state)
-		pll->save_state(pll);
-
 	dsi_pll_disable(pll);
 }
 
@@ -134,6 +117,29 @@ void msm_dsi_pll_destroy(struct msm_dsi_pll *pll)
 		pll->destroy(pll);
 }
 
+void msm_dsi_pll_save_state(struct msm_dsi_pll *pll)
+{
+	if (pll->save_state) {
+		pll->save_state(pll);
+		pll->state_saved = true;
+	}
+}
+
+int msm_dsi_pll_restore_state(struct msm_dsi_pll *pll)
+{
+	int ret;
+
+	if (pll->restore_state && pll->state_saved) {
+		ret = pll->restore_state(pll);
+		if (ret)
+			return ret;
+
+		pll->state_saved = false;
+	}
+
+	return 0;
+}
+
 struct msm_dsi_pll *msm_dsi_pll_init(struct platform_device *pdev,
 			enum msm_dsi_phy_type type, int id)
 {

commit 825637b9c06cede2a742421b0ea6f24428099af3
Author: Hai Li <hali@codeaurora.org>
Date:   Fri May 15 13:04:04 2015 -0400

    drm/msm/dsi: Add DSI PLL clock driver support
    
    DSI byte clock and pixel clocks are sourced from DSI PLL.
    This change adds the DSI PLL source clock driver under
    common clock framework.
    
    This change handles DSI 28nm PLL only.
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Stephane Viau <sviau@codeaurora.org>
    Signed-off-by: Wentao Xu <wentaox@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c b/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
new file mode 100644
index 000000000000..509376fdd112
--- /dev/null
+++ b/drivers/gpu/drm/msm/dsi/pll/dsi_pll.c
@@ -0,0 +1,164 @@
+/*
+ * Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "dsi_pll.h"
+
+static int dsi_pll_enable(struct msm_dsi_pll *pll)
+{
+	int i, ret = 0;
+
+	/*
+	 * Certain PLLs do not allow VCO rate update when it is on.
+	 * Keep track of their status to turn on/off after set rate success.
+	 */
+	if (unlikely(pll->pll_on))
+		return 0;
+
+	/* Try all enable sequences until one succeeds */
+	for (i = 0; i < pll->en_seq_cnt; i++) {
+		ret = pll->enable_seqs[i](pll);
+		DBG("DSI PLL %s after sequence #%d",
+			ret ? "unlocked" : "locked", i + 1);
+		if (!ret)
+			break;
+	}
+
+	if (ret) {
+		DRM_ERROR("DSI PLL failed to lock\n");
+		return ret;
+	}
+
+	pll->pll_on = true;
+
+	return 0;
+}
+
+static void dsi_pll_disable(struct msm_dsi_pll *pll)
+{
+	if (unlikely(!pll->pll_on))
+		return;
+
+	pll->disable_seq(pll);
+
+	pll->pll_on = false;
+}
+
+/*
+ * DSI PLL Helper functions
+ */
+long msm_dsi_pll_helper_clk_round_rate(struct clk_hw *hw,
+		unsigned long rate, unsigned long *parent_rate)
+{
+	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
+
+	if      (rate < pll->min_rate)
+		return  pll->min_rate;
+	else if (rate > pll->max_rate)
+		return  pll->max_rate;
+	else
+		return rate;
+}
+
+int msm_dsi_pll_helper_clk_prepare(struct clk_hw *hw)
+{
+	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
+	int ret;
+
+	/*
+	 * Certain PLLs need to update the same VCO rate and registers
+	 * after resume in suspend/resume scenario.
+	 */
+	if (pll->restore_state) {
+		ret = pll->restore_state(pll);
+		if (ret)
+			goto error;
+	}
+
+	ret = dsi_pll_enable(pll);
+
+error:
+	return ret;
+}
+
+void msm_dsi_pll_helper_clk_unprepare(struct clk_hw *hw)
+{
+	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
+
+	if (pll->save_state)
+		pll->save_state(pll);
+
+	dsi_pll_disable(pll);
+}
+
+void msm_dsi_pll_helper_unregister_clks(struct platform_device *pdev,
+					struct clk **clks, u32 num_clks)
+{
+	of_clk_del_provider(pdev->dev.of_node);
+
+	if (!num_clks || !clks)
+		return;
+
+	do {
+		clk_unregister(clks[--num_clks]);
+		clks[num_clks] = NULL;
+	} while (num_clks);
+}
+
+/*
+ * DSI PLL API
+ */
+int msm_dsi_pll_get_clk_provider(struct msm_dsi_pll *pll,
+	struct clk **byte_clk_provider, struct clk **pixel_clk_provider)
+{
+	if (pll->get_provider)
+		return pll->get_provider(pll,
+					byte_clk_provider,
+					pixel_clk_provider);
+
+	return -EINVAL;
+}
+
+void msm_dsi_pll_destroy(struct msm_dsi_pll *pll)
+{
+	if (pll->destroy)
+		pll->destroy(pll);
+}
+
+struct msm_dsi_pll *msm_dsi_pll_init(struct platform_device *pdev,
+			enum msm_dsi_phy_type type, int id)
+{
+	struct device *dev = &pdev->dev;
+	struct msm_dsi_pll *pll;
+
+	switch (type) {
+	case MSM_DSI_PHY_28NM_HPM:
+	case MSM_DSI_PHY_28NM_LP:
+		pll = msm_dsi_pll_28nm_init(pdev, type, id);
+		break;
+	default:
+		pll = ERR_PTR(-ENXIO);
+		break;
+	}
+
+	if (IS_ERR(pll)) {
+		dev_err(dev, "%s: failed to init DSI PLL\n", __func__);
+		return NULL;
+	}
+
+	pll->type = type;
+
+	DBG("DSI:%d PLL registered", id);
+
+	return pll;
+}
+
