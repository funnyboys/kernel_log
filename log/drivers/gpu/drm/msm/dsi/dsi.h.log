commit 6b16f05aa39f9fae43c18d4fd1ddad7988ab6d90
Author: Rob Clark <robdclark@chromium.org>
Date:   Sun Jun 30 07:18:31 2019 -0700

    drm/msm/dsi: split clk rate setting and enable
    
    Decouple enable and rate setting.  Prep work to handle bootloader
    enabled display.
    
    Signed-off-by: Rob Clark <robdclark@chromium.org>
    Reviewed-by: Jeffrey Hugo <jeffrey.l.hugo@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index eff1a4c61258..4de771d6f0be 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -178,6 +178,8 @@ int msm_dsi_host_modeset_init(struct mipi_dsi_host *host,
 int msm_dsi_host_init(struct msm_dsi *msm_dsi);
 int msm_dsi_runtime_suspend(struct device *dev);
 int msm_dsi_runtime_resume(struct device *dev);
+int dsi_link_clk_set_rate_6g(struct msm_dsi_host *msm_host);
+int dsi_link_clk_set_rate_v2(struct msm_dsi_host *msm_host);
 int dsi_link_clk_enable_6g(struct msm_dsi_host *msm_host);
 int dsi_link_clk_enable_v2(struct msm_dsi_host *msm_host);
 void dsi_link_clk_disable_6g(struct msm_dsi_host *msm_host);

commit ee68c743f8d0747585b4c0c171c039d6635bda7c
Author: Boris Brezillon <boris.brezillon@collabora.com>
Date:   Mon Aug 26 17:26:29 2019 +0200

    drm: Stop including drm_bridge.h from drm_crtc.h
    
    We are about to add a drm_bridge_state that inherits from
    drm_private_state which is defined in drm_atomic.h. Problem is,
    drm_atomic.h includes drm_crtc.h which in turn includes drm_bridge.h,
    leading to "drm_private_state has incomplete type" error.
    
    Let's force all users of the drm_bridge API to explicitly include
    drm_bridge.h.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190826152649.13820-2-boris.brezillon@collabora.com

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 0da8a4e428ad..eff1a4c61258 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -9,6 +9,7 @@
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
 
+#include <drm/drm_bridge.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_mipi_dsi.h>
 #include <drm/drm_panel.h>

commit 53e155f2bbd42df7e8bea87be78f0d60fe9fa122
Merge: 14808a12bdbd 648fdc3f6475
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jun 28 09:34:25 2019 +1000

    Merge tag 'drm-msm-next-2019-06-25' of https://gitlab.freedesktop.org/drm/msm into drm-next
    
    + usual progress on cleanups
    + dsi vs EPROBE_DEFER fixes
    + msm8998 (snapdragon 835 support)
      + a540 gpu support (mesa support already landed)
      + dsi, dsi-phy support
    + mdp5 and dpu interconnect (bus/memory scaling) support
    + initial prep work for per-context pagetables (at least the parts that
      don't have external dependencies like iommu/arm-smmu)
    
    There is one more patch for fixing DSI cmd mode panels (part of a set of
    patches to get things working on nexus5), but it would be conflicty with
    1cff7440a86e04a613665803b42034 in drm-next without rebasing or back-merge,
    and since it doesn't conflict with anything in msm-next, I think it best
    if Sean merges that through drm-mix-fixes instead.
    
    (In other news, I've been making some progress w/ getting efifb working
    properly on sdm850 laptop without horrible hacks, and drm/msm + clk stuff
    not totally falling over when bootloader enables display and things are
    already running when driver probes.. but not quite ready yet, hopefully
    we can post some of that for 5.4.. should help for both the sdm835 and
    sdm850 laptops.)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    From: Rob Clark <robdclark@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/CAF6AEGsj3N4XzDLSDoa+4RHZ9wXObYmhcep0M3LjnRg48BeLvg@mail.gmail.com

commit 03436e3ec69c8e026224a5f172e5d0431f722305
Author: Sean Paul <seanpaul@chromium.org>
Date:   Mon Jun 17 16:12:58 2019 -0400

    drm/msm/dsi: Move setup_encoder to modeset_init
    
    Now that the panel probe/setup is in the modeset path, we can call
    dsi_manager_setup_encoder() in a common place for both internal and
    external bridge setups.
    
    Reviewed-by: Rob Clark <robdclark@chromium.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190617201301.133275-10-sean@poorly.run

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index f8a611725f2e..53bb124e8259 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -96,7 +96,7 @@ struct drm_connector *msm_dsi_manager_connector_init(u8 id);
 struct drm_connector *msm_dsi_manager_ext_bridge_init(u8 id);
 int msm_dsi_manager_cmd_xfer(int id, const struct mipi_dsi_msg *msg);
 bool msm_dsi_manager_cmd_xfer_trigger(int id, u32 dma_base, u32 len);
-void msm_dsi_manager_attach_dsi_device(int id);
+void msm_dsi_manager_setup_encoder(int id);
 int msm_dsi_manager_register(struct msm_dsi *msm_dsi);
 void msm_dsi_manager_unregister(struct msm_dsi *msm_dsi);
 bool msm_dsi_manager_validate_current_config(u8 id);

commit 970524b07a9c1d0434266a0f32825631bc206848
Author: Sean Paul <seanpaul@chromium.org>
Date:   Mon Jun 17 16:12:56 2019 -0400

    drm/msm/dsi: Use the new setup_encoder function in attach_dsi_device
    
    Now that we have a function to call set_encoder_mode() for us, use it.
    
    Reviewed-by: Rob Clark <robdclark@chromium.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190617201301.133275-8-sean@poorly.run

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index e0bbe8128aef..f8a611725f2e 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -96,7 +96,7 @@ struct drm_connector *msm_dsi_manager_connector_init(u8 id);
 struct drm_connector *msm_dsi_manager_ext_bridge_init(u8 id);
 int msm_dsi_manager_cmd_xfer(int id, const struct mipi_dsi_msg *msg);
 bool msm_dsi_manager_cmd_xfer_trigger(int id, u32 dma_base, u32 len);
-void msm_dsi_manager_attach_dsi_device(int id, u32 device_flags);
+void msm_dsi_manager_attach_dsi_device(int id);
 int msm_dsi_manager_register(struct msm_dsi *msm_dsi);
 void msm_dsi_manager_unregister(struct msm_dsi *msm_dsi);
 bool msm_dsi_manager_validate_current_config(u8 id);

commit 09951aaa7229b253b0e00979d6c6d17b20e16fe4
Author: Sean Paul <seanpaul@chromium.org>
Date:   Mon Jun 17 16:12:53 2019 -0400

    drm/msm/dsi: Don't store dsi host mode_flags in msm_dsi
    
    It's a bit dangerous to store the flags in msm_dsi since there's no way to
    tell when they're populated. Fortunately the only place that uses them
    is the same place that fills them. So just use a local variable and
    delete the struct member.
    
    Reviewed-by: Rob Clark <robdclark@chromium.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190617201301.133275-5-sean@poorly.run

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 8bdc48ca0b67..e0bbe8128aef 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -79,7 +79,6 @@ struct msm_dsi {
 	 */
 	struct drm_panel *panel;
 	struct drm_bridge *external_bridge;
-	unsigned long device_flags;
 
 	struct device *phy_dev;
 	bool phy_enabled;

commit e3a91f893cabd684a6cd63599425118308defc06
Author: Sean Paul <seanpaul@chromium.org>
Date:   Mon Jun 17 16:12:52 2019 -0400

    drm/msm/dsi: Split mode_flags out of msm_dsi_host_get_panel()
    
    We use the flags in more places than just get_panel, so split them out
    into a separate function.
    
    Reviewed-by: Rob Clark <robdclark@chromium.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190617201301.133275-4-sean@poorly.run

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 9c6b31c2d79f..8bdc48ca0b67 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -169,8 +169,8 @@ int msm_dsi_host_power_on(struct mipi_dsi_host *host,
 int msm_dsi_host_power_off(struct mipi_dsi_host *host);
 int msm_dsi_host_set_display_mode(struct mipi_dsi_host *host,
 				  const struct drm_display_mode *mode);
-struct drm_panel *msm_dsi_host_get_panel(struct mipi_dsi_host *host,
-					unsigned long *panel_flags);
+struct drm_panel *msm_dsi_host_get_panel(struct mipi_dsi_host *host);
+unsigned long msm_dsi_host_get_mode_flags(struct mipi_dsi_host *host);
 struct drm_bridge *msm_dsi_host_get_bridge(struct mipi_dsi_host *host);
 int msm_dsi_host_register(struct mipi_dsi_host *host, bool check_defer);
 void msm_dsi_host_unregister(struct mipi_dsi_host *host);

commit 97fb5e8d9b57f10f294303c9a5d1bd033eded6bf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:58 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 284
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 and
      only version 2 as published by the free software foundation this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 294 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.825281744@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 9c6b31c2d79f..20a5d3cb0cab 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (c) 2015, The Linux Foundation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #ifndef __DSI_CONNECTOR_H__

commit 63f8f3badf799c8b63ff33a489886bc138ce5d09
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Apr 6 17:39:01 2018 +0300

    drm: bridge: Constify mode arguments to bridge .mode_set() operation
    
    The mode and ajusted_mode passed to the bridge .mode_set() operation
    should never be modified by the bridge (and are not in any of the
    existing bridge drivers). Make them const to make this clear.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 08f3fc6771b7..9c6b31c2d79f 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -168,7 +168,7 @@ int msm_dsi_host_power_on(struct mipi_dsi_host *host,
 			bool is_dual_dsi);
 int msm_dsi_host_power_off(struct mipi_dsi_host *host);
 int msm_dsi_host_set_display_mode(struct mipi_dsi_host *host,
-					struct drm_display_mode *mode);
+				  const struct drm_display_mode *mode);
 struct drm_panel *msm_dsi_host_get_panel(struct mipi_dsi_host *host,
 					unsigned long *panel_flags);
 struct drm_bridge *msm_dsi_host_get_bridge(struct mipi_dsi_host *host);

commit 8b03ad30e314691f7bfccc0f9fae0dffd498b667
Author: Chandan Uddaraju <chandanu@codeaurora.org>
Date:   Wed Apr 18 12:45:15 2018 -0700

    drm/msm/dsi: Use one connector for dual DSI mode
    
    Current DSI driver uses two connectors for dual DSI case even
    though we only have one panel. Fix this by implementing one
    connector/bridge for dual DSI use case. Use master DSI
    controllers to register one connector/bridge.
    
    Changes in v3:
    - None
    
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Chandan Uddaraju <chandanu@codeaurora.org>
    [seanpaul removed unused local var causing a build warning]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index d3f613c76ffa..08f3fc6771b7 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -100,6 +100,7 @@ bool msm_dsi_manager_cmd_xfer_trigger(int id, u32 dma_base, u32 len);
 void msm_dsi_manager_attach_dsi_device(int id, u32 device_flags);
 int msm_dsi_manager_register(struct msm_dsi *msm_dsi);
 void msm_dsi_manager_unregister(struct msm_dsi *msm_dsi);
+bool msm_dsi_manager_validate_current_config(u8 id);
 
 /* msm dsi */
 static inline bool msm_dsi_device_connected(struct msm_dsi *msm_dsi)

commit ed9976a09b486d85ae537b5cd73e947d7dfbb136
Author: Chandan Uddaraju <chandanu@codeaurora.org>
Date:   Wed Apr 18 12:45:14 2018 -0700

    drm/msm/dsi: adjust dsi timing for dual dsi mode
    
    For dual dsi mode, the horizontal timing needs
    to be divided by half since both the dsi controllers
    will be driving this panel. Adjust the pixel clock and
    DSI timing accordingly.
    
    Changes in v3:
    - Added Archit's R-b
    - Rebase on dsi cleanup set in msm-next
    
    Cc: Sibi Sankar <sibis@codeaurora.org>
    Reviewed-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Chandan Uddaraju <chandanu@codeaurora.org>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index dfa049d876bd..d3f613c76ffa 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -163,7 +163,8 @@ void msm_dsi_host_cmd_xfer_commit(struct mipi_dsi_host *host,
 int msm_dsi_host_enable(struct mipi_dsi_host *host);
 int msm_dsi_host_disable(struct mipi_dsi_host *host);
 int msm_dsi_host_power_on(struct mipi_dsi_host *host,
-			struct msm_dsi_phy_shared_timings *phy_shared_timings);
+			struct msm_dsi_phy_shared_timings *phy_shared_timings,
+			bool is_dual_dsi);
 int msm_dsi_host_power_off(struct mipi_dsi_host *host);
 int msm_dsi_host_set_display_mode(struct mipi_dsi_host *host,
 					struct drm_display_mode *mode);
@@ -176,7 +177,8 @@ int msm_dsi_host_set_src_pll(struct mipi_dsi_host *host,
 			struct msm_dsi_pll *src_pll);
 void msm_dsi_host_reset_phy(struct mipi_dsi_host *host);
 void msm_dsi_host_get_phy_clk_req(struct mipi_dsi_host *host,
-	struct msm_dsi_phy_clk_request *clk_req);
+	struct msm_dsi_phy_clk_request *clk_req,
+	bool is_dual_dsi);
 void msm_dsi_host_destroy(struct mipi_dsi_host *host);
 int msm_dsi_host_modeset_init(struct mipi_dsi_host *host,
 					struct drm_device *dev);
@@ -196,8 +198,8 @@ int dsi_dma_base_get_6g(struct msm_dsi_host *msm_host, uint64_t *iova);
 int dsi_dma_base_get_v2(struct msm_dsi_host *msm_host, uint64_t *iova);
 int dsi_clk_init_v2(struct msm_dsi_host *msm_host);
 int dsi_clk_init_6g_v2(struct msm_dsi_host *msm_host);
-int dsi_calc_clk_rate_v2(struct msm_dsi_host *msm_host);
-int dsi_calc_clk_rate_6g(struct msm_dsi_host *msm_host);
+int dsi_calc_clk_rate_v2(struct msm_dsi_host *msm_host, bool is_dual_dsi);
+int dsi_calc_clk_rate_6g(struct msm_dsi_host *msm_host, bool is_dual_dsi);
 
 /* dsi phy */
 struct msm_dsi_phy;

commit c4d8cfe516dc54bac8837bc90ccbd878ad26c59e
Author: Sibi Sankar <sibis@codeaurora.org>
Date:   Tue May 29 19:50:32 2018 +0530

    drm/msm/dsi: add implementation for helper functions
    
    Add dsi host helper function implementation for DSI v2
    DSI 6G 1.x and DSI 6G v2.0+ controllers
    
    Signed-off-by: Sibi Sankar <sibis@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 80be83e8fdec..dfa049d876bd 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -183,6 +183,21 @@ int msm_dsi_host_modeset_init(struct mipi_dsi_host *host,
 int msm_dsi_host_init(struct msm_dsi *msm_dsi);
 int msm_dsi_runtime_suspend(struct device *dev);
 int msm_dsi_runtime_resume(struct device *dev);
+int dsi_link_clk_enable_6g(struct msm_dsi_host *msm_host);
+int dsi_link_clk_enable_v2(struct msm_dsi_host *msm_host);
+void dsi_link_clk_disable_6g(struct msm_dsi_host *msm_host);
+void dsi_link_clk_disable_v2(struct msm_dsi_host *msm_host);
+int dsi_tx_buf_alloc_6g(struct msm_dsi_host *msm_host, int size);
+int dsi_tx_buf_alloc_v2(struct msm_dsi_host *msm_host, int size);
+void *dsi_tx_buf_get_6g(struct msm_dsi_host *msm_host);
+void *dsi_tx_buf_get_v2(struct msm_dsi_host *msm_host);
+void dsi_tx_buf_put_6g(struct msm_dsi_host *msm_host);
+int dsi_dma_base_get_6g(struct msm_dsi_host *msm_host, uint64_t *iova);
+int dsi_dma_base_get_v2(struct msm_dsi_host *msm_host, uint64_t *iova);
+int dsi_clk_init_v2(struct msm_dsi_host *msm_host);
+int dsi_clk_init_6g_v2(struct msm_dsi_host *msm_host);
+int dsi_calc_clk_rate_v2(struct msm_dsi_host *msm_host);
+int dsi_calc_clk_rate_6g(struct msm_dsi_host *msm_host);
 
 /* dsi phy */
 struct msm_dsi_phy;

commit e18177cc572939ad9526bae141fc4c8f5f006de4
Author: Sibi Sankar <sibis@codeaurora.org>
Date:   Tue May 29 19:50:31 2018 +0530

    drm/msm/dsi: add dsi host helper functions support
    
    Add dsi host helper functions support for DSI v2 and DSI 6G 1.x
    controllers that are under version checks
    
    Signed-off-by: Sibi Sankar <sibis@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 70d9a9a47acd..80be83e8fdec 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -149,6 +149,7 @@ static inline int msm_dsi_pll_set_usecase(struct msm_dsi_pll *pll,
 #endif
 
 /* dsi host */
+struct msm_dsi_host;
 int msm_dsi_host_xfer_prepare(struct mipi_dsi_host *host,
 					const struct mipi_dsi_msg *msg);
 void msm_dsi_host_xfer_restore(struct mipi_dsi_host *host,

commit 973e02db35c2c4036693e32ed6f250eefd8c322c
Author: Archit Taneja <architt@codeaurora.org>
Date:   Wed Jan 17 11:35:25 2018 +0530

    drm/msm/dsi: Add skeleton 10nm PHY/PLL code
    
    Add new 10nm DSI PLL/PHY files that will be used on SDM845.
    
    Just populate empty pll/phy funcs for now. These will be filled up
    later.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 2302046197a8..70d9a9a47acd 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -36,6 +36,7 @@ enum msm_dsi_phy_type {
 	MSM_DSI_PHY_20NM,
 	MSM_DSI_PHY_28NM_8960,
 	MSM_DSI_PHY_14NM,
+	MSM_DSI_PHY_10NM,
 	MSM_DSI_PHY_MAX
 };
 

commit f54ca1a0966bcdb525aee130a043a8adbccc5cbb
Author: Archit Taneja <architt@codeaurora.org>
Date:   Fri Jul 28 16:17:04 2017 +0530

    drm/msm/dsi: Implement RPM suspend/resume callbacks
    
    The bus clocks are always enabled/disabled along with the power
    domain, so move it to the runtime suspend/resume ops. This cleans
    up the clock code a bit. Get rid of the clk_mutex mutex since it
    isn't needed.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 9e6017387efb..2302046197a8 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -179,6 +179,8 @@ void msm_dsi_host_destroy(struct mipi_dsi_host *host);
 int msm_dsi_host_modeset_init(struct mipi_dsi_host *host,
 					struct drm_device *dev);
 int msm_dsi_host_init(struct msm_dsi *msm_dsi);
+int msm_dsi_runtime_suspend(struct device *dev);
+int msm_dsi_runtime_resume(struct device *dev);
 
 /* dsi phy */
 struct msm_dsi_phy;

commit 78f27b1ce3f852543443b5d2f12a40f217e3555e
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Apr 24 13:50:28 2017 +0900

    drm/msm: fix include notation and remove -Iinclude/drm flag
    
    Include <drm/*.h> instead of relative path from include/drm, then
    remove the -Iinclude/drm compiler flag.
    
    While we are here, sort the touched parts with public headers first.
    mdp4_kms.h must declare struct device_node to be self-contained.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1493009447-31524-11-git-send-email-yamada.masahiro@socionext.com

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 32369975d155..9e6017387efb 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -17,9 +17,9 @@
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
 
-#include "drm_crtc.h"
-#include "drm_mipi_dsi.h"
-#include "drm_panel.h"
+#include <drm/drm_crtc.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_panel.h>
 
 #include "msm_drv.h"
 

commit f079f6d999cbf857f899732de680f2b62f245b8c
Author: Archit Taneja <architt@codeaurora.org>
Date:   Tue Jan 3 19:45:43 2017 +0530

    drm/msm/dsi: Add PHY/PLL for 8x96
    
    Extend the DSI PHY/PLL drivers to support the DSI 14nm PHY/PLL
    found on 8x96.
    
    These are picked up from the downstream driver. The PHY part is similar
    to the other DSI PHYs. The PLL driver requires some trickery so that
    one DSI PLL can drive both the DSIs (i.e, dual DSI mode).
    
    In the case of dual DSI mode. One DSI instance becomes the clock master,
    and other the clock slave. The master PLL's output (Byte and Pixel clock)
    is fed to both the DSI hosts/PHYs.
    
    When the DSIs are configured in dual DSI mode, the PHY driver communicates
    to the PLL driver using msm_dsi_pll_set_usecase() which instance is the
    master and which one is the slave. When setting rate, the master PLL also
    configures some of the slave PLL/PHY registers which need to be identical
    to the master's for correct dual DSI behaviour.
    
    There are 2 PLL post dividers that should have ideally been modelled as
    generic clk_divider clocks, but require some customization for dual DSI.
    In particular, when the master PLL's post-diviers are set, the slave PLL's
    post-dividers need to be set too. The clk_ops for these use clk_divider's
    helper ops and flags internally to prevent redundant code.
    
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 9465996d0869..32369975d155 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -35,6 +35,7 @@ enum msm_dsi_phy_type {
 	MSM_DSI_PHY_28NM_LP,
 	MSM_DSI_PHY_20NM,
 	MSM_DSI_PHY_28NM_8960,
+	MSM_DSI_PHY_14NM,
 	MSM_DSI_PHY_MAX
 };
 
@@ -117,6 +118,8 @@ int msm_dsi_pll_get_clk_provider(struct msm_dsi_pll *pll,
 	struct clk **byte_clk_provider, struct clk **pixel_clk_provider);
 void msm_dsi_pll_save_state(struct msm_dsi_pll *pll);
 int msm_dsi_pll_restore_state(struct msm_dsi_pll *pll);
+int msm_dsi_pll_set_usecase(struct msm_dsi_pll *pll,
+			    enum msm_dsi_phy_usecase uc);
 #else
 static inline struct msm_dsi_pll *msm_dsi_pll_init(struct platform_device *pdev,
 			 enum msm_dsi_phy_type type, int id) {
@@ -137,6 +140,11 @@ static inline int msm_dsi_pll_restore_state(struct msm_dsi_pll *pll)
 {
 	return 0;
 }
+static inline int msm_dsi_pll_set_usecase(struct msm_dsi_pll *pll,
+					  enum msm_dsi_phy_usecase uc)
+{
+	return -ENODEV;
+}
 #endif
 
 /* dsi host */

commit b62aa70a98c5401ada63657eee7c88da70bdbb27
Author: Hai Li <hali@codeaurora.org>
Date:   Sat Jan 7 14:24:38 2017 +0530

    drm/msm/dsi: Move PHY operations out of host
    
    Since DSI PHY has been a separate platform device, it should not
    depend on the resources in host to be functional. This change is
    to trigger PHY operations in manager, instead of host, so that
    host and PHY can be completely separated.
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 9407a682d045..9465996d0869 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -28,6 +28,7 @@
 #define DSI_MAX	2
 
 struct msm_dsi_phy_shared_timings;
+struct msm_dsi_phy_clk_request;
 
 enum msm_dsi_phy_type {
 	MSM_DSI_PHY_28NM_HPM,
@@ -92,10 +93,6 @@ struct drm_bridge *msm_dsi_manager_bridge_init(u8 id);
 void msm_dsi_manager_bridge_destroy(struct drm_bridge *bridge);
 struct drm_connector *msm_dsi_manager_connector_init(u8 id);
 struct drm_connector *msm_dsi_manager_ext_bridge_init(u8 id);
-int msm_dsi_manager_phy_enable(int id,
-		const unsigned long bit_rate, const unsigned long esc_rate,
-		struct msm_dsi_phy_shared_timings *shared_timing);
-void msm_dsi_manager_phy_disable(int id);
 int msm_dsi_manager_cmd_xfer(int id, const struct mipi_dsi_msg *msg);
 bool msm_dsi_manager_cmd_xfer_trigger(int id, u32 dma_base, u32 len);
 void msm_dsi_manager_attach_dsi_device(int id, u32 device_flags);
@@ -155,7 +152,8 @@ void msm_dsi_host_cmd_xfer_commit(struct mipi_dsi_host *host,
 					u32 dma_base, u32 len);
 int msm_dsi_host_enable(struct mipi_dsi_host *host);
 int msm_dsi_host_disable(struct mipi_dsi_host *host);
-int msm_dsi_host_power_on(struct mipi_dsi_host *host);
+int msm_dsi_host_power_on(struct mipi_dsi_host *host,
+			struct msm_dsi_phy_shared_timings *phy_shared_timings);
 int msm_dsi_host_power_off(struct mipi_dsi_host *host);
 int msm_dsi_host_set_display_mode(struct mipi_dsi_host *host,
 					struct drm_display_mode *mode);
@@ -167,6 +165,8 @@ void msm_dsi_host_unregister(struct mipi_dsi_host *host);
 int msm_dsi_host_set_src_pll(struct mipi_dsi_host *host,
 			struct msm_dsi_pll *src_pll);
 void msm_dsi_host_reset_phy(struct mipi_dsi_host *host);
+void msm_dsi_host_get_phy_clk_req(struct mipi_dsi_host *host,
+	struct msm_dsi_phy_clk_request *clk_req);
 void msm_dsi_host_destroy(struct mipi_dsi_host *host);
 int msm_dsi_host_modeset_init(struct mipi_dsi_host *host,
 					struct drm_device *dev);
@@ -179,10 +179,16 @@ struct msm_dsi_phy_shared_timings {
 	u32 clk_pre;
 	bool clk_pre_inc_by_2;
 };
+
+struct msm_dsi_phy_clk_request {
+	unsigned long bitclk_rate;
+	unsigned long escclk_rate;
+};
+
 void msm_dsi_phy_driver_register(void);
 void msm_dsi_phy_driver_unregister(void);
 int msm_dsi_phy_enable(struct msm_dsi_phy *phy, int src_pll_id,
-	const unsigned long bit_rate, const unsigned long esc_rate);
+			struct msm_dsi_phy_clk_request *clk_req);
 void msm_dsi_phy_disable(struct msm_dsi_phy *phy);
 void msm_dsi_phy_get_shared_timings(struct msm_dsi_phy *phy,
 			struct msm_dsi_phy_shared_timings *shared_timing);

commit 34d9545b9f769c6553e31a6820c9cb51f5e93099
Author: Archit Taneja <architt@codeaurora.org>
Date:   Wed Jul 29 12:14:12 2015 -0400

    drm/msm/dsi: Reset both PHYs before clock operation for dual DSI
    
    In case of dual DSI, some registers in PHY1 have been programmed
    during PLL0 clock's set_rate. The PHY1 reset called by host1 later
    will silently reset those PHY1 registers. This change is to reset
    and enable both PHYs before any PLL clock operation.
    
    [Originally worked on by Hai Li <hali@codeaurora.org>. Fixed up
    by Archit Taneja <architt@codeaurora.org>]
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index d516fe296b78..9407a682d045 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -166,6 +166,7 @@ int msm_dsi_host_register(struct mipi_dsi_host *host, bool check_defer);
 void msm_dsi_host_unregister(struct mipi_dsi_host *host);
 int msm_dsi_host_set_src_pll(struct mipi_dsi_host *host,
 			struct msm_dsi_pll *src_pll);
+void msm_dsi_host_reset_phy(struct mipi_dsi_host *host);
 void msm_dsi_host_destroy(struct mipi_dsi_host *host);
 int msm_dsi_host_modeset_init(struct mipi_dsi_host *host,
 					struct drm_device *dev);

commit 57bf433893370c069a0c34842f35a3bb8aa130fc
Author: Hai Li <hali@codeaurora.org>
Date:   Thu Sep 15 14:44:22 2016 +0530

    drm/msm/dsi: Pass down use case to PHY
    
    For some new types of DSI PHY, more settings depend on
    use cases controlled by DSI manager. This change allows
    DSI manager to setup PHY with a use case.
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index f5e4ccfc902d..d516fe296b78 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -37,6 +37,12 @@ enum msm_dsi_phy_type {
 	MSM_DSI_PHY_MAX
 };
 
+enum msm_dsi_phy_usecase {
+	MSM_DSI_PHY_STANDALONE,
+	MSM_DSI_PHY_MASTER,
+	MSM_DSI_PHY_SLAVE,
+};
+
 #define DSI_DEV_REGULATOR_MAX	8
 #define DSI_BUS_CLK_MAX		4
 
@@ -180,6 +186,8 @@ void msm_dsi_phy_disable(struct msm_dsi_phy *phy);
 void msm_dsi_phy_get_shared_timings(struct msm_dsi_phy *phy,
 			struct msm_dsi_phy_shared_timings *shared_timing);
 struct msm_dsi_pll *msm_dsi_phy_get_pll(struct msm_dsi_phy *phy);
+void msm_dsi_phy_set_usecase(struct msm_dsi_phy *phy,
+			     enum msm_dsi_phy_usecase uc);
 
 #endif /* __DSI_CONNECTOR_H__ */
 

commit dceac340155b66b6c97cb802b03d4778dd82e9be
Author: Hai Li <hali@codeaurora.org>
Date:   Thu Sep 15 14:34:49 2016 +0530

    drm/msm/dsi: Return more timings from PHY to host
    
    The DSI host is required to configure more timings calculated
    in PHY. By introducing a shared structure, this change allows
    more timing information passed from PHY to host.
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 81971b3caf3b..f5e4ccfc902d 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -27,6 +27,8 @@
 #define DSI_1	1
 #define DSI_MAX	2
 
+struct msm_dsi_phy_shared_timings;
+
 enum msm_dsi_phy_type {
 	MSM_DSI_PHY_28NM_HPM,
 	MSM_DSI_PHY_28NM_LP,
@@ -86,7 +88,7 @@ struct drm_connector *msm_dsi_manager_connector_init(u8 id);
 struct drm_connector *msm_dsi_manager_ext_bridge_init(u8 id);
 int msm_dsi_manager_phy_enable(int id,
 		const unsigned long bit_rate, const unsigned long esc_rate,
-		u32 *clk_pre, u32 *clk_post);
+		struct msm_dsi_phy_shared_timings *shared_timing);
 void msm_dsi_manager_phy_disable(int id);
 int msm_dsi_manager_cmd_xfer(int id, const struct mipi_dsi_msg *msg);
 bool msm_dsi_manager_cmd_xfer_trigger(int id, u32 dma_base, u32 len);
@@ -165,13 +167,18 @@ int msm_dsi_host_init(struct msm_dsi *msm_dsi);
 
 /* dsi phy */
 struct msm_dsi_phy;
+struct msm_dsi_phy_shared_timings {
+	u32 clk_post;
+	u32 clk_pre;
+	bool clk_pre_inc_by_2;
+};
 void msm_dsi_phy_driver_register(void);
 void msm_dsi_phy_driver_unregister(void);
 int msm_dsi_phy_enable(struct msm_dsi_phy *phy, int src_pll_id,
 	const unsigned long bit_rate, const unsigned long esc_rate);
 void msm_dsi_phy_disable(struct msm_dsi_phy *phy);
-void msm_dsi_phy_get_clk_pre_post(struct msm_dsi_phy *phy,
-					u32 *clk_pre, u32 *clk_post);
+void msm_dsi_phy_get_shared_timings(struct msm_dsi_phy *phy,
+			struct msm_dsi_phy_shared_timings *shared_timing);
 struct msm_dsi_pll *msm_dsi_phy_get_pll(struct msm_dsi_phy *phy);
 
 #endif /* __DSI_CONNECTOR_H__ */

commit 9c9f6f8d472cc9e11f2c0b370685ce78ab7eb2fa
Author: Archit Taneja <architt@codeaurora.org>
Date:   Mon Dec 5 15:24:53 2016 +0530

    drm/msm: Set encoder's mode of operation using a kms func
    
    The mdp5 kms driver currently sets up multiple encoders per interface
    (INTF), one for each kind of mode of operation it supports.
    We create 2 drm_encoders for DSI, one for Video Mode and the other
    for Command Mode operation. The reason behind this approach could have
    been that we aren't aware of the DSI device's mode of operation when
    we create the encoders.
    
    This makes things a bit complicated, since these encoders have to
    be further attached to the same DSI bridge. The easier way out is
    to create a single encoder, and make the DSI driver set its mode
    of operation when we know what the DSI device's mode flags are.
    
    Start with providing a way to set the mdp5_intf_mode using a kms
    func that sets the encoder's mode of operation. When constructing
    a DSI encoder, we set the mode of operation to Video Mode as
    default. When the DSI device is attached to the host, we probe the
    DSI mode flags and set the corresponding mode of operation.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index ddcda8cec9a7..81971b3caf3b 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -90,6 +90,7 @@ int msm_dsi_manager_phy_enable(int id,
 void msm_dsi_manager_phy_disable(int id);
 int msm_dsi_manager_cmd_xfer(int id, const struct mipi_dsi_msg *msg);
 bool msm_dsi_manager_cmd_xfer_trigger(int id, u32 dma_base, u32 len);
+void msm_dsi_manager_attach_dsi_device(int id, u32 device_flags);
 int msm_dsi_manager_register(struct msm_dsi *msm_dsi);
 void msm_dsi_manager_unregister(struct msm_dsi *msm_dsi);
 

commit 97e00119534bf3c9f47c4eae0b7dd982ef2de92b
Author: Archit Taneja <architt@codeaurora.org>
Date:   Mon Jan 16 09:42:03 2017 +0530

    drm/msm: Construct only one encoder for DSI
    
    We currently create 2 encoders for DSI interfaces, one for command
    mode and other for video mode operation. This isn't needed as we
    can't really use both the encoders at the same time. It also makes
    connecting bridges harder.
    
    Switch to creating a single encoder. For now, we assume that the
    encoder is configured only in video mode. Later, the same encoder
    would be usable in both modes.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 03f115f532c2..ddcda8cec9a7 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -73,8 +73,8 @@ struct msm_dsi {
 	struct device *phy_dev;
 	bool phy_enabled;
 
-	/* the encoders we are hooked to (outside of dsi block) */
-	struct drm_encoder *encoders[MSM_DSI_ENCODER_NUM];
+	/* the encoder we are hooked to (outside of dsi block) */
+	struct drm_encoder *encoder;
 
 	int id;
 };

commit f377d59729e744122751977eb79b349d2e166095
Author: Archit Taneja <architt@codeaurora.org>
Date:   Fri Apr 29 15:19:35 2016 +0530

    drm/msm/dsi: Fix regulator API abuse
    
    The voltage changing code in this driver is broken and should be
    removed.  The driver sets a single, exact voltage on probe.  Unless
    there is a very good reason for this (which should be documented in
    comments) constraints like this need to be set via the machine
    constraints, voltage setting in a driver is expected to be used in cases
    where the voltage varies at runtime.
    
    In addition client drivers should almost never be calling
    regulator_can_set_voltage(), if the device needs to set a voltage it
    needs to set the voltage and the regulator core will handle the case
    where the regulator is fixed voltage.  If the driver simply skips
    setting the voltage if it doesn't have permission then it should just
    not bother in the first place.
    
    Originally authored by Mark Brown <broonie@kernel.org>
    
    Remove the min/max voltage data entries per SoC managed by the driver.
    These aren't needed as we don't try to set voltages any more. Mention in
    comments the voltages that each regulator expects.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 749fbb28ec3d..03f115f532c2 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -41,8 +41,6 @@ enum msm_dsi_phy_type {
 /* Regulators for DSI devices */
 struct dsi_reg_entry {
 	char name[32];
-	int min_voltage;
-	int max_voltage;
 	int enable_load;
 	int disable_load;
 };

commit 4ff9d4cbc15a1ac169eaabf2e3d282b7d2d3799d
Author: Archit Taneja <architt@codeaurora.org>
Date:   Tue Oct 13 12:20:47 2015 +0530

    drm/msm/dsi: Don't use iommu for command TX buffer for DSIv2
    
    We currently use iommu allocated DMA buffers for sending DSI commands.
    DSIv2 doesn't have a port connected to the MDP iommu. Therefore, it
    can't use iommu allocated buffers to fetch DSI commands.
    
    Use a regular contiguous DMA buffer if we are DSIv2.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 7336b55d05cc..749fbb28ec3d 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -91,7 +91,7 @@ int msm_dsi_manager_phy_enable(int id,
 		u32 *clk_pre, u32 *clk_post);
 void msm_dsi_manager_phy_disable(int id);
 int msm_dsi_manager_cmd_xfer(int id, const struct mipi_dsi_msg *msg);
-bool msm_dsi_manager_cmd_xfer_trigger(int id, u32 iova, u32 len);
+bool msm_dsi_manager_cmd_xfer_trigger(int id, u32 dma_base, u32 len);
 int msm_dsi_manager_register(struct msm_dsi *msm_dsi);
 void msm_dsi_manager_unregister(struct msm_dsi *msm_dsi);
 
@@ -145,7 +145,7 @@ int msm_dsi_host_cmd_tx(struct mipi_dsi_host *host,
 int msm_dsi_host_cmd_rx(struct mipi_dsi_host *host,
 					const struct mipi_dsi_msg *msg);
 void msm_dsi_host_cmd_xfer_commit(struct mipi_dsi_host *host,
-					u32 iova, u32 len);
+					u32 dma_base, u32 len);
 int msm_dsi_host_enable(struct mipi_dsi_host *host);
 int msm_dsi_host_disable(struct mipi_dsi_host *host);
 int msm_dsi_host_power_on(struct mipi_dsi_host *host);

commit 6e0eb52eba9e2c8d56e4e6826faa2bd6fd5dcf0c
Author: Archit Taneja <architt@codeaurora.org>
Date:   Fri Oct 9 15:21:12 2015 +0530

    drm/msm/dsi: Parse bus clocks from a list
    
    DSI bus clocks seem to vary between different DSI host versions, and the
    SOC to which they belong. Even the enable/disable sequence varies.
    
    Provide a list of bus clock names in dsi_cfg. The driver will use this to
    retrieve the clocks, and enable/disable them.
    
    Add bus clock lists for DSI6G, and DSI for MSM8916(this is DSI6G too, but
    there is no MMSS_CC specific clock since there is no MMSS clock controller
    on 8916).
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 8140e8b820e4..7336b55d05cc 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -36,6 +36,7 @@ enum msm_dsi_phy_type {
 };
 
 #define DSI_DEV_REGULATOR_MAX	8
+#define DSI_BUS_CLK_MAX		4
 
 /* Regulators for DSI devices */
 struct dsi_reg_entry {

commit 225380b3e9b4b82d19de5a161aee169dbc57f353
Author: Archit Taneja <architt@codeaurora.org>
Date:   Wed Oct 14 12:00:34 2015 +0530

    drm/msm/dsi: Add support for 28nm PHY on 8960
    
    DSI PHY on MSM8960 and APQ8064 is a 28nm PHY that's different from the
    supported 28nm LP PHY found in newer chips.
    
    Add support for the new PHY.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 5f5a3732cdf6..8140e8b820e4 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -31,6 +31,7 @@ enum msm_dsi_phy_type {
 	MSM_DSI_PHY_28NM_HPM,
 	MSM_DSI_PHY_28NM_LP,
 	MSM_DSI_PHY_20NM,
+	MSM_DSI_PHY_28NM_8960,
 	MSM_DSI_PHY_MAX
 };
 

commit 29e61690130adb1c27053558d2f21af88ae0334e
Author: Hai Li <hali@codeaurora.org>
Date:   Thu Aug 13 17:45:51 2015 -0400

    drm/msm/dsi: Return void from msm_dsi_phy_disable()
    
    We are not checking the return value from msm_dsi_phy_disable().
    Change the return type to void.
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 09492bfc0e02..5f5a3732cdf6 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -168,7 +168,7 @@ void msm_dsi_phy_driver_register(void);
 void msm_dsi_phy_driver_unregister(void);
 int msm_dsi_phy_enable(struct msm_dsi_phy *phy, int src_pll_id,
 	const unsigned long bit_rate, const unsigned long esc_rate);
-int msm_dsi_phy_disable(struct msm_dsi_phy *phy);
+void msm_dsi_phy_disable(struct msm_dsi_phy *phy);
 void msm_dsi_phy_get_clk_pre_post(struct msm_dsi_phy *phy,
 					u32 *clk_pre, u32 *clk_post);
 struct msm_dsi_pll *msm_dsi_phy_get_pll(struct msm_dsi_phy *phy);

commit c118e29033aa5b38b593ebd0e02f8b1224c20ed3
Author: Archit Taneja <architt@codeaurora.org>
Date:   Fri Jul 31 14:06:10 2015 +0530

    drm/msm/dsi: Allow dsi to connect to an external bridge
    
    There are platforms where the DSI output can be connected to another
    encoder bridge chip (DSI to HDMI, DSI to LVDS etc).
    
    Add support for external bridge support to the dsi driver. We assume that
    the external bridge chip would be of the type drm_bridge. The dsi driver's
    internal drm_bridge (msm_dsi->bridge) is linked to the external bridge's
    drm_bridge struct.
    
    In the case we're connected to an external bridge, we don't need to create
    and manage a connector within our driver, it's the bridge driver's
    responsibility to create one.
    
    v2:
    - Move the external bridge attaching stuff to dsi manager to make things
      cleaner.
    - Force the bridge to connect to a video mode encoder for now (the dsi
      mode flags may have not been populated by modeset_init)
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 1636513347e0..09492bfc0e02 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -54,12 +54,20 @@ struct msm_dsi {
 	struct drm_device *dev;
 	struct platform_device *pdev;
 
+	/* connector managed by us when we're connected to a drm_panel */
 	struct drm_connector *connector;
+	/* internal dsi bridge attached to MDP interface */
 	struct drm_bridge *bridge;
 
 	struct mipi_dsi_host *host;
 	struct msm_dsi_phy *phy;
+
+	/*
+	 * panel/external_bridge connected to dsi bridge output, only one of the
+	 * two can be valid at a time
+	 */
 	struct drm_panel *panel;
+	struct drm_bridge *external_bridge;
 	unsigned long device_flags;
 
 	struct device *phy_dev;
@@ -75,6 +83,7 @@ struct msm_dsi {
 struct drm_bridge *msm_dsi_manager_bridge_init(u8 id);
 void msm_dsi_manager_bridge_destroy(struct drm_bridge *bridge);
 struct drm_connector *msm_dsi_manager_connector_init(u8 id);
+struct drm_connector *msm_dsi_manager_ext_bridge_init(u8 id);
 int msm_dsi_manager_phy_enable(int id,
 		const unsigned long bit_rate, const unsigned long esc_rate,
 		u32 *clk_pre, u32 *clk_post);
@@ -87,7 +96,7 @@ void msm_dsi_manager_unregister(struct msm_dsi *msm_dsi);
 /* msm dsi */
 static inline bool msm_dsi_device_connected(struct msm_dsi *msm_dsi)
 {
-	return msm_dsi->panel;
+	return msm_dsi->panel || msm_dsi->external_bridge;
 }
 
 struct drm_encoder *msm_dsi_get_encoder(struct msm_dsi *msm_dsi);
@@ -143,6 +152,7 @@ int msm_dsi_host_set_display_mode(struct mipi_dsi_host *host,
 					struct drm_display_mode *mode);
 struct drm_panel *msm_dsi_host_get_panel(struct mipi_dsi_host *host,
 					unsigned long *panel_flags);
+struct drm_bridge *msm_dsi_host_get_bridge(struct mipi_dsi_host *host);
 int msm_dsi_host_register(struct mipi_dsi_host *host, bool check_defer);
 void msm_dsi_host_unregister(struct mipi_dsi_host *host);
 int msm_dsi_host_set_src_pll(struct mipi_dsi_host *host,

commit 6f054ec5b9ced3041f29541ae79402198678fc06
Author: Archit Taneja <architt@codeaurora.org>
Date:   Mon Aug 3 14:08:33 2015 +0530

    drm/msm/dsi: Create a helper to check if there is a connected device
    
    Create a helper msm_dsi_device_connected() which checks whether we have a
    device connected to the dsi host or not. This check gets messy when we
    have support external bridges too. Having an inline function makes it
    more legible.
    
    For now, the check only consists of msm_dsi->panel being non-NULL. Later,
    this will check if we have an external bridge or not.
    
    This helper isn't used in dsi_connector related code as that's specific
    to only when a drm_panel is connected.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 1a5990551c15..1636513347e0 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -85,6 +85,11 @@ int msm_dsi_manager_register(struct msm_dsi *msm_dsi);
 void msm_dsi_manager_unregister(struct msm_dsi *msm_dsi);
 
 /* msm dsi */
+static inline bool msm_dsi_device_connected(struct msm_dsi *msm_dsi)
+{
+	return msm_dsi->panel;
+}
+
 struct drm_encoder *msm_dsi_get_encoder(struct msm_dsi *msm_dsi);
 
 /* dsi pll */

commit a9ddac9c5765712fa7eace55feeaf7c4ac75e32b
Author: Archit Taneja <architt@codeaurora.org>
Date:   Mon Aug 3 14:05:45 2015 +0530

    drm/msm/dsi: Refer to connected device as 'device' instead of 'panel'
    
    We currently support only panels connected to dsi output. We're going to
    also support external bridge chips now.
    
    Change 'panel_node' to 'device_node' in the struct msm_dsi_host and
    'panel_flags' to 'device_flags' in msm_dsi. This makes things sound a
    bit more generic.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 912057df5c02..1a5990551c15 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -60,7 +60,7 @@ struct msm_dsi {
 	struct mipi_dsi_host *host;
 	struct msm_dsi_phy *phy;
 	struct drm_panel *panel;
-	unsigned long panel_flags;
+	unsigned long device_flags;
 
 	struct device *phy_dev;
 	bool phy_enabled;

commit 328e1a633c9bc26c36ecd320246e4a9b2726e81a
Author: Hai Li <hali@codeaurora.org>
Date:   Fri Jul 3 10:09:46 2015 -0400

    drm/msm/dsi: Save/Restore PLL status across PHY reset
    
    Reset DSI PHY silently changes its PLL registers to reset status,
    which will make cached status in clock driver invalid and result
    in wrong output rate of link clocks. The current restore mechanism
    in DSI PLL does not cover all the cases. This change is to recover
    PLL status after PHY reset to match HW status with cached status
    in clock driver.
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index e18872a62806..912057df5c02 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -95,6 +95,8 @@ struct msm_dsi_pll *msm_dsi_pll_init(struct platform_device *pdev,
 void msm_dsi_pll_destroy(struct msm_dsi_pll *pll);
 int msm_dsi_pll_get_clk_provider(struct msm_dsi_pll *pll,
 	struct clk **byte_clk_provider, struct clk **pixel_clk_provider);
+void msm_dsi_pll_save_state(struct msm_dsi_pll *pll);
+int msm_dsi_pll_restore_state(struct msm_dsi_pll *pll);
 #else
 static inline struct msm_dsi_pll *msm_dsi_pll_init(struct platform_device *pdev,
 			 enum msm_dsi_phy_type type, int id) {
@@ -108,6 +110,13 @@ static inline int msm_dsi_pll_get_clk_provider(struct msm_dsi_pll *pll,
 {
 	return -ENODEV;
 }
+static inline void msm_dsi_pll_save_state(struct msm_dsi_pll *pll)
+{
+}
+static inline int msm_dsi_pll_restore_state(struct msm_dsi_pll *pll)
+{
+	return 0;
+}
 #endif
 
 /* dsi host */

commit dcefc117cc192f215d04c4e7cbae6b76a9bafcf4
Author: Hai Li <hali@codeaurora.org>
Date:   Thu Jun 18 10:14:21 2015 -0400

    drm/msm/dsi: Add support for msm8x94
    
    DSI controller on msm8x94 is version 1.3, which requires different
    power supplies and works with 20nm DSI PHY. This change is to add
    the basic support for this version.
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 5e29aadc0bee..e18872a62806 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -30,6 +30,7 @@
 enum msm_dsi_phy_type {
 	MSM_DSI_PHY_28NM_HPM,
 	MSM_DSI_PHY_28NM_LP,
+	MSM_DSI_PHY_20NM,
 	MSM_DSI_PHY_MAX
 };
 

commit 13351cd17791694f2dcc96dc920e58b090b18c31
Author: Hai Li <hali@codeaurora.org>
Date:   Wed Jun 10 13:18:17 2015 -0400

    drm/msm/dsi: Update source PLL selection in DSI PHY
    
    The source PLL to be used by each DSI PHY should be decided by
    DSI manager based on dual DSI information, while the register
    programming to select PLL is different from one type of PHY to
    another. This change adds the H/W difference to PHY configuration
    and updates the interface between DSI manager and PHY.
    
    With this change, PLL selection can be supported on different
    targets.
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 92d697de4858..5e29aadc0bee 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -27,18 +27,6 @@
 #define DSI_1	1
 #define DSI_MAX	2
 
-#define DSI_CLOCK_MASTER	DSI_0
-#define DSI_CLOCK_SLAVE		DSI_1
-
-#define DSI_LEFT		DSI_0
-#define DSI_RIGHT		DSI_1
-
-/* According to the current drm framework sequence, take the encoder of
- * DSI_1 as master encoder
- */
-#define DSI_ENCODER_MASTER	DSI_1
-#define DSI_ENCODER_SLAVE	DSI_0
-
 enum msm_dsi_phy_type {
 	MSM_DSI_PHY_28NM_HPM,
 	MSM_DSI_PHY_28NM_LP,
@@ -153,7 +141,7 @@ int msm_dsi_host_init(struct msm_dsi *msm_dsi);
 struct msm_dsi_phy;
 void msm_dsi_phy_driver_register(void);
 void msm_dsi_phy_driver_unregister(void);
-int msm_dsi_phy_enable(struct msm_dsi_phy *phy, bool is_dual_panel,
+int msm_dsi_phy_enable(struct msm_dsi_phy *phy, int src_pll_id,
 	const unsigned long bit_rate, const unsigned long esc_rate);
 int msm_dsi_phy_disable(struct msm_dsi_phy *phy);
 void msm_dsi_phy_get_clk_pre_post(struct msm_dsi_phy *phy,

commit ec31abf6684ebe1134eb3320c96fb92e566eff74
Author: Hai Li <hali@codeaurora.org>
Date:   Fri May 15 13:04:06 2015 -0400

    drm/msm/dsi: Separate PHY to another platform device
    
    There are different types of PHY from one chipset to another, while
    the DSI host controller is relatively consistent across platforms.
    Also, the PLL inside PHY is providing the source of DSI byte and
    pixel clocks, which are used by DSI host controller. Separated devices
    for clock provider and clock consumer make DSI driver better fit into
    common clock framework.
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 8022814f7914..92d697de4858 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -14,6 +14,7 @@
 #ifndef __DSI_CONNECTOR_H__
 #define __DSI_CONNECTOR_H__
 
+#include <linux/of_platform.h>
 #include <linux/platform_device.h>
 
 #include "drm_crtc.h"
@@ -39,12 +40,27 @@
 #define DSI_ENCODER_SLAVE	DSI_0
 
 enum msm_dsi_phy_type {
-	MSM_DSI_PHY_UNKNOWN,
 	MSM_DSI_PHY_28NM_HPM,
 	MSM_DSI_PHY_28NM_LP,
 	MSM_DSI_PHY_MAX
 };
 
+#define DSI_DEV_REGULATOR_MAX	8
+
+/* Regulators for DSI devices */
+struct dsi_reg_entry {
+	char name[32];
+	int min_voltage;
+	int max_voltage;
+	int enable_load;
+	int disable_load;
+};
+
+struct dsi_reg_config {
+	int num;
+	struct dsi_reg_entry regs[DSI_DEV_REGULATOR_MAX];
+};
+
 struct msm_dsi {
 	struct drm_device *dev;
 	struct platform_device *pdev;
@@ -57,7 +73,7 @@ struct msm_dsi {
 	struct drm_panel *panel;
 	unsigned long panel_flags;
 
-	enum msm_dsi_phy_type phy_type;
+	struct device *phy_dev;
 	bool phy_enabled;
 
 	/* the encoders we are hooked to (outside of dsi block) */
@@ -135,9 +151,8 @@ int msm_dsi_host_init(struct msm_dsi *msm_dsi);
 
 /* dsi phy */
 struct msm_dsi_phy;
-struct msm_dsi_phy *msm_dsi_phy_init(struct platform_device *pdev,
-			enum msm_dsi_phy_type type, int id);
-void msm_dsi_phy_destroy(struct msm_dsi_phy *phy);
+void msm_dsi_phy_driver_register(void);
+void msm_dsi_phy_driver_unregister(void);
 int msm_dsi_phy_enable(struct msm_dsi_phy *phy, bool is_dual_panel,
 	const unsigned long bit_rate, const unsigned long esc_rate);
 int msm_dsi_phy_disable(struct msm_dsi_phy *phy);

commit 9d32c4989c858af12b333ae9a3c160a91ff43934
Author: Hai Li <hali@codeaurora.org>
Date:   Fri May 15 13:04:05 2015 -0400

    drm/msm/dsi: Enable PLL driver in MSM DSI
    
    This change activates PLL driver for DSI to work with
    common clock framework.
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 321964a6b27e..8022814f7914 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -38,6 +38,13 @@
 #define DSI_ENCODER_MASTER	DSI_1
 #define DSI_ENCODER_SLAVE	DSI_0
 
+enum msm_dsi_phy_type {
+	MSM_DSI_PHY_UNKNOWN,
+	MSM_DSI_PHY_28NM_HPM,
+	MSM_DSI_PHY_28NM_LP,
+	MSM_DSI_PHY_MAX
+};
+
 struct msm_dsi {
 	struct drm_device *dev;
 	struct platform_device *pdev;
@@ -49,6 +56,8 @@ struct msm_dsi {
 	struct msm_dsi_phy *phy;
 	struct drm_panel *panel;
 	unsigned long panel_flags;
+
+	enum msm_dsi_phy_type phy_type;
 	bool phy_enabled;
 
 	/* the encoders we are hooked to (outside of dsi block) */
@@ -73,6 +82,29 @@ void msm_dsi_manager_unregister(struct msm_dsi *msm_dsi);
 /* msm dsi */
 struct drm_encoder *msm_dsi_get_encoder(struct msm_dsi *msm_dsi);
 
+/* dsi pll */
+struct msm_dsi_pll;
+#ifdef CONFIG_DRM_MSM_DSI_PLL
+struct msm_dsi_pll *msm_dsi_pll_init(struct platform_device *pdev,
+			enum msm_dsi_phy_type type, int dsi_id);
+void msm_dsi_pll_destroy(struct msm_dsi_pll *pll);
+int msm_dsi_pll_get_clk_provider(struct msm_dsi_pll *pll,
+	struct clk **byte_clk_provider, struct clk **pixel_clk_provider);
+#else
+static inline struct msm_dsi_pll *msm_dsi_pll_init(struct platform_device *pdev,
+			 enum msm_dsi_phy_type type, int id) {
+	return ERR_PTR(-ENODEV);
+}
+static inline void msm_dsi_pll_destroy(struct msm_dsi_pll *pll)
+{
+}
+static inline int msm_dsi_pll_get_clk_provider(struct msm_dsi_pll *pll,
+	struct clk **byte_clk_provider, struct clk **pixel_clk_provider)
+{
+	return -ENODEV;
+}
+#endif
+
 /* dsi host */
 int msm_dsi_host_xfer_prepare(struct mipi_dsi_host *host,
 					const struct mipi_dsi_msg *msg);
@@ -94,6 +126,8 @@ struct drm_panel *msm_dsi_host_get_panel(struct mipi_dsi_host *host,
 					unsigned long *panel_flags);
 int msm_dsi_host_register(struct mipi_dsi_host *host, bool check_defer);
 void msm_dsi_host_unregister(struct mipi_dsi_host *host);
+int msm_dsi_host_set_src_pll(struct mipi_dsi_host *host,
+			struct msm_dsi_pll *src_pll);
 void msm_dsi_host_destroy(struct mipi_dsi_host *host);
 int msm_dsi_host_modeset_init(struct mipi_dsi_host *host,
 					struct drm_device *dev);
@@ -101,18 +135,15 @@ int msm_dsi_host_init(struct msm_dsi *msm_dsi);
 
 /* dsi phy */
 struct msm_dsi_phy;
-enum msm_dsi_phy_type {
-	MSM_DSI_PHY_UNKNOWN,
-	MSM_DSI_PHY_28NM_HPM,
-	MSM_DSI_PHY_28NM_LP,
-	MSM_DSI_PHY_MAX
-};
 struct msm_dsi_phy *msm_dsi_phy_init(struct platform_device *pdev,
 			enum msm_dsi_phy_type type, int id);
+void msm_dsi_phy_destroy(struct msm_dsi_phy *phy);
 int msm_dsi_phy_enable(struct msm_dsi_phy *phy, bool is_dual_panel,
 	const unsigned long bit_rate, const unsigned long esc_rate);
 int msm_dsi_phy_disable(struct msm_dsi_phy *phy);
 void msm_dsi_phy_get_clk_pre_post(struct msm_dsi_phy *phy,
 					u32 *clk_pre, u32 *clk_post);
+struct msm_dsi_pll *msm_dsi_phy_get_pll(struct msm_dsi_phy *phy);
+
 #endif /* __DSI_CONNECTOR_H__ */
 

commit 825637b9c06cede2a742421b0ea6f24428099af3
Author: Hai Li <hali@codeaurora.org>
Date:   Fri May 15 13:04:04 2015 -0400

    drm/msm/dsi: Add DSI PLL clock driver support
    
    DSI byte clock and pixel clocks are sourced from DSI PLL.
    This change adds the DSI PLL source clock driver under
    common clock framework.
    
    This change handles DSI 28nm PLL only.
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Stephane Viau <sviau@codeaurora.org>
    Signed-off-by: Wentao Xu <wentaox@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
index 10f54d4e379a..321964a6b27e 100644
--- a/drivers/gpu/drm/msm/dsi/dsi.h
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -103,7 +103,8 @@ int msm_dsi_host_init(struct msm_dsi *msm_dsi);
 struct msm_dsi_phy;
 enum msm_dsi_phy_type {
 	MSM_DSI_PHY_UNKNOWN,
-	MSM_DSI_PHY_28NM,
+	MSM_DSI_PHY_28NM_HPM,
+	MSM_DSI_PHY_28NM_LP,
 	MSM_DSI_PHY_MAX
 };
 struct msm_dsi_phy *msm_dsi_phy_init(struct platform_device *pdev,

commit a689554ba6ed81cf606c16539f6ffc2a1dcdaf8e
Author: Hai Li <hali@codeaurora.org>
Date:   Tue Mar 31 14:36:33 2015 -0400

    drm/msm: Initial add DSI connector support
    
    This change adds the DSI connector support in msm drm driver.
    
    v1: Initial change
    v2:
    - Address comments from Archit + minor clean-ups
    - Rebase to not depend on msm_drm_sub_dev change [Rob's comment]
    v3: Fix issues when initialization is failed
    
    Signed-off-by: Hai Li <hali@codeaurora.org>
    Signed-off-by: Rob Clark <robdclark@gmail.com>

diff --git a/drivers/gpu/drm/msm/dsi/dsi.h b/drivers/gpu/drm/msm/dsi/dsi.h
new file mode 100644
index 000000000000..10f54d4e379a
--- /dev/null
+++ b/drivers/gpu/drm/msm/dsi/dsi.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __DSI_CONNECTOR_H__
+#define __DSI_CONNECTOR_H__
+
+#include <linux/platform_device.h>
+
+#include "drm_crtc.h"
+#include "drm_mipi_dsi.h"
+#include "drm_panel.h"
+
+#include "msm_drv.h"
+
+#define DSI_0	0
+#define DSI_1	1
+#define DSI_MAX	2
+
+#define DSI_CLOCK_MASTER	DSI_0
+#define DSI_CLOCK_SLAVE		DSI_1
+
+#define DSI_LEFT		DSI_0
+#define DSI_RIGHT		DSI_1
+
+/* According to the current drm framework sequence, take the encoder of
+ * DSI_1 as master encoder
+ */
+#define DSI_ENCODER_MASTER	DSI_1
+#define DSI_ENCODER_SLAVE	DSI_0
+
+struct msm_dsi {
+	struct drm_device *dev;
+	struct platform_device *pdev;
+
+	struct drm_connector *connector;
+	struct drm_bridge *bridge;
+
+	struct mipi_dsi_host *host;
+	struct msm_dsi_phy *phy;
+	struct drm_panel *panel;
+	unsigned long panel_flags;
+	bool phy_enabled;
+
+	/* the encoders we are hooked to (outside of dsi block) */
+	struct drm_encoder *encoders[MSM_DSI_ENCODER_NUM];
+
+	int id;
+};
+
+/* dsi manager */
+struct drm_bridge *msm_dsi_manager_bridge_init(u8 id);
+void msm_dsi_manager_bridge_destroy(struct drm_bridge *bridge);
+struct drm_connector *msm_dsi_manager_connector_init(u8 id);
+int msm_dsi_manager_phy_enable(int id,
+		const unsigned long bit_rate, const unsigned long esc_rate,
+		u32 *clk_pre, u32 *clk_post);
+void msm_dsi_manager_phy_disable(int id);
+int msm_dsi_manager_cmd_xfer(int id, const struct mipi_dsi_msg *msg);
+bool msm_dsi_manager_cmd_xfer_trigger(int id, u32 iova, u32 len);
+int msm_dsi_manager_register(struct msm_dsi *msm_dsi);
+void msm_dsi_manager_unregister(struct msm_dsi *msm_dsi);
+
+/* msm dsi */
+struct drm_encoder *msm_dsi_get_encoder(struct msm_dsi *msm_dsi);
+
+/* dsi host */
+int msm_dsi_host_xfer_prepare(struct mipi_dsi_host *host,
+					const struct mipi_dsi_msg *msg);
+void msm_dsi_host_xfer_restore(struct mipi_dsi_host *host,
+					const struct mipi_dsi_msg *msg);
+int msm_dsi_host_cmd_tx(struct mipi_dsi_host *host,
+					const struct mipi_dsi_msg *msg);
+int msm_dsi_host_cmd_rx(struct mipi_dsi_host *host,
+					const struct mipi_dsi_msg *msg);
+void msm_dsi_host_cmd_xfer_commit(struct mipi_dsi_host *host,
+					u32 iova, u32 len);
+int msm_dsi_host_enable(struct mipi_dsi_host *host);
+int msm_dsi_host_disable(struct mipi_dsi_host *host);
+int msm_dsi_host_power_on(struct mipi_dsi_host *host);
+int msm_dsi_host_power_off(struct mipi_dsi_host *host);
+int msm_dsi_host_set_display_mode(struct mipi_dsi_host *host,
+					struct drm_display_mode *mode);
+struct drm_panel *msm_dsi_host_get_panel(struct mipi_dsi_host *host,
+					unsigned long *panel_flags);
+int msm_dsi_host_register(struct mipi_dsi_host *host, bool check_defer);
+void msm_dsi_host_unregister(struct mipi_dsi_host *host);
+void msm_dsi_host_destroy(struct mipi_dsi_host *host);
+int msm_dsi_host_modeset_init(struct mipi_dsi_host *host,
+					struct drm_device *dev);
+int msm_dsi_host_init(struct msm_dsi *msm_dsi);
+
+/* dsi phy */
+struct msm_dsi_phy;
+enum msm_dsi_phy_type {
+	MSM_DSI_PHY_UNKNOWN,
+	MSM_DSI_PHY_28NM,
+	MSM_DSI_PHY_MAX
+};
+struct msm_dsi_phy *msm_dsi_phy_init(struct platform_device *pdev,
+			enum msm_dsi_phy_type type, int id);
+int msm_dsi_phy_enable(struct msm_dsi_phy *phy, bool is_dual_panel,
+	const unsigned long bit_rate, const unsigned long esc_rate);
+int msm_dsi_phy_disable(struct msm_dsi_phy *phy);
+void msm_dsi_phy_get_clk_pre_post(struct msm_dsi_phy *phy,
+					u32 *clk_pre, u32 *clk_post);
+#endif /* __DSI_CONNECTOR_H__ */
+
