commit 6529007522ded00b8912c079250620fa7a732166
Author: Fabrizio Castro <fabrizio.castro@bp.renesas.com>
Date:   Tue Dec 17 13:45:56 2019 +0000

    drm: of: Add drm_of_lvds_get_dual_link_pixel_order
    
    An LVDS dual-link connection is made of two links, with even
    pixels transitting on one link, and odd pixels on the other
    link. The device tree can be used to fully describe dual-link
    LVDS connections between encoders and bridges/panels.
    The sink of an LVDS dual-link connection is made of two ports,
    the corresponding OF graph port nodes can be marked
    with either dual-lvds-even-pixels or dual-lvds-odd-pixels,
    and that fully describes an LVDS dual-link connection,
    including pixel order.
    
    drm_of_lvds_get_dual_link_pixel_order is a new helper
    added by this patch, given the source port nodes it
    returns DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS if the source
    port nodes belong to an LVDS dual-link connection, with even
    pixels expected to be generated from the first port, and odd
    pixels expected to be generated from the second port.
    If the new helper returns DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS,
    odd pixels are expected to be generated from the first port,
    and even pixels from the other port.
    
    Signed-off-by: Fabrizio Castro <fabrizio.castro@bp.renesas.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index 0ca58803ba46..b50b44e76279 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -274,3 +274,119 @@ int drm_of_find_panel_or_bridge(const struct device_node *np,
 	return ret;
 }
 EXPORT_SYMBOL_GPL(drm_of_find_panel_or_bridge);
+
+enum drm_of_lvds_pixels {
+	DRM_OF_LVDS_EVEN = BIT(0),
+	DRM_OF_LVDS_ODD = BIT(1),
+};
+
+static int drm_of_lvds_get_port_pixels_type(struct device_node *port_node)
+{
+	bool even_pixels =
+		of_property_read_bool(port_node, "dual-lvds-even-pixels");
+	bool odd_pixels =
+		of_property_read_bool(port_node, "dual-lvds-odd-pixels");
+
+	return (even_pixels ? DRM_OF_LVDS_EVEN : 0) |
+	       (odd_pixels ? DRM_OF_LVDS_ODD : 0);
+}
+
+static int drm_of_lvds_get_remote_pixels_type(
+			const struct device_node *port_node)
+{
+	struct device_node *endpoint = NULL;
+	int pixels_type = -EPIPE;
+
+	for_each_child_of_node(port_node, endpoint) {
+		struct device_node *remote_port;
+		int current_pt;
+
+		if (!of_node_name_eq(endpoint, "endpoint"))
+			continue;
+
+		remote_port = of_graph_get_remote_port(endpoint);
+		if (!remote_port) {
+			of_node_put(remote_port);
+			return -EPIPE;
+		}
+
+		current_pt = drm_of_lvds_get_port_pixels_type(remote_port);
+		of_node_put(remote_port);
+		if (pixels_type < 0)
+			pixels_type = current_pt;
+
+		/*
+		 * Sanity check, ensure that all remote endpoints have the same
+		 * pixel type. We may lift this restriction later if we need to
+		 * support multiple sinks with different dual-link
+		 * configurations by passing the endpoints explicitly to
+		 * drm_of_lvds_get_dual_link_pixel_order().
+		 */
+		if (!current_pt || pixels_type != current_pt) {
+			of_node_put(remote_port);
+			return -EINVAL;
+		}
+	}
+
+	return pixels_type;
+}
+
+/**
+ * drm_of_lvds_get_dual_link_pixel_order - Get LVDS dual-link pixel order
+ * @port1: First DT port node of the Dual-link LVDS source
+ * @port2: Second DT port node of the Dual-link LVDS source
+ *
+ * An LVDS dual-link connection is made of two links, with even pixels
+ * transitting on one link, and odd pixels on the other link. This function
+ * returns, for two ports of an LVDS dual-link source, which port shall transmit
+ * the even and odd pixels, based on the requirements of the connected sink.
+ *
+ * The pixel order is determined from the dual-lvds-even-pixels and
+ * dual-lvds-odd-pixels properties in the sink's DT port nodes. If those
+ * properties are not present, or if their usage is not valid, this function
+ * returns -EINVAL.
+ *
+ * If either port is not connected, this function returns -EPIPE.
+ *
+ * @port1 and @port2 are typically DT sibling nodes, but may have different
+ * parents when, for instance, two separate LVDS encoders carry the even and odd
+ * pixels.
+ *
+ * Return:
+ * * DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS - @port1 carries even pixels and @port2
+ *   carries odd pixels
+ * * DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS - @port1 carries odd pixels and @port2
+ *   carries even pixels
+ * * -EINVAL - @port1 and @port2 are not connected to a dual-link LVDS sink, or
+ *   the sink configuration is invalid
+ * * -EPIPE - when @port1 or @port2 are not connected
+ */
+int drm_of_lvds_get_dual_link_pixel_order(const struct device_node *port1,
+					  const struct device_node *port2)
+{
+	int remote_p1_pt, remote_p2_pt;
+
+	if (!port1 || !port2)
+		return -EINVAL;
+
+	remote_p1_pt = drm_of_lvds_get_remote_pixels_type(port1);
+	if (remote_p1_pt < 0)
+		return remote_p1_pt;
+
+	remote_p2_pt = drm_of_lvds_get_remote_pixels_type(port2);
+	if (remote_p2_pt < 0)
+		return remote_p2_pt;
+
+	/*
+	 * A valid dual-lVDS bus is found when one remote port is marked with
+	 * "dual-lvds-even-pixels", and the other remote port is marked with
+	 * "dual-lvds-odd-pixels", bail out if the markers are not right.
+	 */
+	if (remote_p1_pt + remote_p2_pt != DRM_OF_LVDS_EVEN + DRM_OF_LVDS_ODD)
+		return -EINVAL;
+
+	return remote_p1_pt == DRM_OF_LVDS_EVEN ?
+		DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS :
+		DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS;
+}
+EXPORT_SYMBOL_GPL(drm_of_lvds_get_dual_link_pixel_order);

commit 21185a668787e6673497cb032ecc9ad08c3fcbaf
Author: Ondrej Jirman <megous@megous.com>
Date:   Fri Sep 20 19:29:14 2019 +0200

    drm: Remove redundant of_device_is_available check
    
    This check is already performed by of_graph_get_remote_node. No
    need to repeat it immediately after the call.
    
    Signed-off-by: Ondrej Jirman <megous@megous.com>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190920172914.4015180-1-megous@megous.com

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index 43d89dd59c6b..0ca58803ba46 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -250,11 +250,6 @@ int drm_of_find_panel_or_bridge(const struct device_node *np,
 	if (!remote)
 		return -ENODEV;
 
-	if (!of_device_is_available(remote)) {
-		of_node_put(remote);
-		return -ENODEV;
-	}
-
 	if (panel) {
 		*panel = of_drm_find_panel(remote);
 		if (!IS_ERR(*panel))

commit 4672b1d65fc9b5a5ded911fbebb4853b892d5d89
Merge: cf57fdc8e42b 14ee642c2ab0
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue May 28 09:38:59 2019 +0200

    Merge remote-tracking branch 'drm/drm-next' into drm-misc-next
    
    This picks up rc2 for us as well.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>

commit 0500c04ea14a4143edf902d087079c4e7b2f0229
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun May 26 19:35:35 2019 +0200

    drm: drop use of drmP.h in drm/*
    
    The use of the drmP.h header file is deprecated.
    Remove use from all files in drm/*
    so people do not look there and follow a bad example.
    
    Build tested allyesconfig,allmodconfig on x86, arm etc.
    Including alpha that is as always more challenging than
    the rest.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Sean Paul <sean@poorly.run>
    Cc: David Airlie <airlied@linux.ie>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190526173535.32701-8-sam@ravnborg.org

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index f2f71d71494a..c13bd9a5185a 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -2,12 +2,13 @@
 #include <linux/export.h>
 #include <linux/list.h>
 #include <linux/of_graph.h>
-#include <drm/drmP.h>
+
 #include <drm/drm_bridge.h>
 #include <drm/drm_crtc.h>
+#include <drm/drm_device.h>
 #include <drm/drm_encoder.h>
-#include <drm/drm_panel.h>
 #include <drm/drm_of.h>
+#include <drm/drm_panel.h>
 
 /**
  * DOC: overview

commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index f2f71d71494a..6becf63f9166 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 #include <linux/component.h>
 #include <linux/export.h>
 #include <linux/list.h>

commit 3fbdfe99f7523a6e2a177f5c969234f2023b11bc
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jan 11 17:40:45 2019 +0100

    drm/of: Fix kerneldoc
    
    I noticed a link that didn't work ...
    
    Fixes: 1f2db3034c9f ("drm: of: introduce drm_of_find_panel_or_bridge")
    Cc: Rob Herring <robh@kernel.org>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190111164048.29067-2-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index 2763a5ec845b..f2f71d71494a 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -217,9 +217,11 @@ int drm_of_encoder_active_endpoint(struct device_node *node,
 }
 EXPORT_SYMBOL_GPL(drm_of_encoder_active_endpoint);
 
-/*
+/**
  * drm_of_find_panel_or_bridge - return connected panel or bridge device
  * @np: device tree node containing encoder output ports
+ * @port: port in the device tree node
+ * @endpoint: endpoint in the device tree node
  * @panel: pointer to hold returned drm_panel
  * @bridge: pointer to hold returned drm_bridge
  *

commit 7f9e7ec92be93e73ef552e6185a3ada72a90e1a9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jul 9 10:40:14 2018 +0200

    drm/doc: Include drm_of.c helpers
    
    Fixes a dead link I spotted in the struct drm_crtc docs. Comments
    themselves are in a surprisingly good state.
    
    v2: Fix subject typo (Sean).
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180709084016.23750-14-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index 260612958cbe..2763a5ec845b 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -9,6 +9,13 @@
 #include <drm/drm_panel.h>
 #include <drm/drm_of.h>
 
+/**
+ * DOC: overview
+ *
+ * A set of helper functions to aid DRM drivers in parsing standard DT
+ * properties.
+ */
+
 static void drm_release_of(struct device *dev, void *data)
 {
 	of_node_put(data);
@@ -94,7 +101,7 @@ EXPORT_SYMBOL_GPL(drm_of_component_match_add);
  * drm_of_component_probe - Generic probe function for a component based master
  * @dev: master device containing the OF node
  * @compare_of: compare function used for matching components
- * @master_ops: component master ops to be used
+ * @m_ops: component master ops to be used
  *
  * Parse the platform device OF node and bind all the components associated
  * with the master. Interface ports are added before the encoders in order to

commit 2e64a174179a144742fa70f09803a012aceca476
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Wed May 9 15:00:41 2018 +0200

    drm/of: Make drm_of_find_panel_or_bridge() fail when the device is disabled
    
    There's no point searching for a drm_bridge or drm_panel if the OF node
    we're pointing has a status property that is not "okay" or "ok". Just
    return -ENODEV in this case.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180509130042.9435-4-boris.brezillon@bootlin.com

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index 1f4a16772583..260612958cbe 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -239,6 +239,11 @@ int drm_of_find_panel_or_bridge(const struct device_node *np,
 	if (!remote)
 		return -ENODEV;
 
+	if (!of_device_is_available(remote)) {
+		of_node_put(remote);
+		return -ENODEV;
+	}
+
 	if (panel) {
 		*panel = of_drm_find_panel(remote);
 		if (!IS_ERR(*panel))

commit 5fa8e4a22182df8ea39adeba4bd518506e26a96d
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Wed May 9 15:00:39 2018 +0200

    drm/panel: Make of_drm_find_panel() return an ERR_PTR() instead of NULL
    
    Right now, the DRM panel logic returns NULL when a panel pointing to
    the passed OF node is not present in the list of registered panels.
    
    Most drivers interpret this NULL value as -EPROBE_DEFER, but we are
    about to modify the semantic of of_drm_find_panel() and let the
    framework return -ENODEV when the device node we're pointing to has
    a status property that is not equal to "okay" or "ok".
    
    Let's first patch the of_drm_find_panel() implementation to return
    ERR_PTR(-EPROBE_DEFER) instead of NULL and patch all callers to replace
    the '!panel' check by an 'IS_ERR(panel)' one.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180509130042.9435-2-boris.brezillon@bootlin.com

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index 3b8c7a6a5720..1f4a16772583 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -241,8 +241,10 @@ int drm_of_find_panel_or_bridge(const struct device_node *np,
 
 	if (panel) {
 		*panel = of_drm_find_panel(remote);
-		if (*panel)
+		if (!IS_ERR(*panel))
 			ret = 0;
+		else
+			*panel = NULL;
 	}
 
 	/* No panel found yet, check for a bridge next. */

commit 8b5f7a62464a24cb83d6290c01d6cf9c8871774a
Author: Jernej Skrabec <jernej.skrabec@siol.net>
Date:   Mon Jun 25 14:03:01 2018 +0200

    drm: of: Export and rename drm_crtc_port_mask()
    
    Function is useful when drm_of_find_possible_crtcs() can't be used and
    custom parsing is needed. This can happen for example when there is a
    node with multiple muxes between crtc and encoder.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
    [maxime: change the function to have a consistent prefix]
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180625120304.7543-22-jernej.skrabec@siol.net

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index 1fe122461298..3b8c7a6a5720 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -15,15 +15,15 @@ static void drm_release_of(struct device *dev, void *data)
 }
 
 /**
- * drm_crtc_port_mask - find the mask of a registered CRTC by port OF node
+ * drm_of_crtc_port_mask - find the mask of a registered CRTC by port OF node
  * @dev: DRM device
  * @port: port OF node
  *
  * Given a port OF node, return the possible mask of the corresponding
  * CRTC within a device's list of CRTCs.  Returns zero if not found.
  */
-static uint32_t drm_crtc_port_mask(struct drm_device *dev,
-				   struct device_node *port)
+uint32_t drm_of_crtc_port_mask(struct drm_device *dev,
+			    struct device_node *port)
 {
 	unsigned int index = 0;
 	struct drm_crtc *tmp;
@@ -37,6 +37,7 @@ static uint32_t drm_crtc_port_mask(struct drm_device *dev,
 
 	return 0;
 }
+EXPORT_SYMBOL(drm_of_crtc_port_mask);
 
 /**
  * drm_of_find_possible_crtcs - find the possible CRTCs for an encoder port
@@ -62,7 +63,7 @@ uint32_t drm_of_find_possible_crtcs(struct drm_device *dev,
 			return 0;
 		}
 
-		possible_crtcs |= drm_crtc_port_mask(dev, remote_port);
+		possible_crtcs |= drm_of_crtc_port_mask(dev, remote_port);
 
 		of_node_put(remote_port);
 	}

commit 2efa83920c7f4fb214517437c730afdaa4e28391
Author: Baruch Siach <baruch@tkos.co.il>
Date:   Thu Feb 22 21:22:50 2018 +0200

    drm: of: simplify component probe code
    
    Use positive logic for better readability. This also eliminates one
    of_node_put() call, making the code shorter.
    
    Signed-off-by: Baruch Siach <baruch@tkos.co.il>
    Reviewed-by: Philipp Zabel <p.zabel@pengutronix.de>
    Tested-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Archit Taneja <archit@cradlewise.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/61c56895d44117d80e7d82f04e729e29c60fadbd.1519327370.git.baruch@tkos.co.il

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index 4c191c050e7d..1fe122461298 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -122,12 +122,10 @@ int drm_of_component_probe(struct device *dev,
 		if (!port)
 			break;
 
-		if (!of_device_is_available(port->parent)) {
-			of_node_put(port);
-			continue;
-		}
+		if (of_device_is_available(port->parent))
+			drm_of_component_match_add(dev, &match, compare_of,
+						   port);
 
-		drm_of_component_match_add(dev, &match, compare_of, port);
 		of_node_put(port);
 	}
 

commit 512721a14a2a94b48ca0863d48f9829922a816b8
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Fri Oct 13 16:08:53 2017 +0200

    drm/drm_of: Move drm_of_panel_bridge_remove_function into header.
    
    Core drm shouldn't depend on anything in drm-kms-helper, or the drm
    module will fail to load.
    
    insmod drm fails with
    [ 6087.674390] drm: Unknown symbol drm_panel_bridge_remove (err 0)
    
    which is defined in drm_kms_helper.ko
    
    This call was added by commit c70087e8f16f ("drm/drm_of: add
    drm_of_panel_bridge_remove function"), and the fix is defining it in the
    drm_of.h header, to break the circular dependency.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/8f95e623-9480-97dc-2414-77086d8aa49d@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@intel.com> #irc
    Fixes: c70087e8f16f ("drm/drm_of: add drm_of_panel_bridge_remove function")
    Acked-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index 7a36934ea5db..4c191c050e7d 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -262,36 +262,3 @@ int drm_of_find_panel_or_bridge(const struct device_node *np,
 	return ret;
 }
 EXPORT_SYMBOL_GPL(drm_of_find_panel_or_bridge);
-
-#ifdef CONFIG_DRM_PANEL_BRIDGE
-/*
- * drm_of_panel_bridge_remove - remove panel bridge
- * @np: device tree node containing panel bridge output ports
- *
- * Remove the panel bridge of a given DT node's port and endpoint number
- *
- * Returns zero if successful, or one of the standard error codes if it fails.
- */
-int drm_of_panel_bridge_remove(const struct device_node *np,
-			       int port, int endpoint)
-{
-	struct drm_bridge *bridge;
-	struct device_node *remote;
-
-	remote = of_graph_get_remote_node(np, port, endpoint);
-	if (!remote)
-		return -ENODEV;
-
-	bridge = of_drm_find_bridge(remote);
-	drm_panel_bridge_remove(bridge);
-
-	return 0;
-}
-#else
-int drm_of_panel_bridge_remove(const struct device_node *np,
-			       int port, int endpoint)
-{
-	return -EINVAL;
-}
-#endif
-EXPORT_SYMBOL_GPL(drm_of_panel_bridge_remove);

commit c70087e8f16f1dfe703d223aadd95ede1cde8e30
Author: benjamin.gaignard@linaro.org <benjamin.gaignard@linaro.org>
Date:   Mon Oct 2 11:34:45 2017 +0200

    drm/drm_of: add drm_of_panel_bridge_remove function
    
    This function is the pendant of drm_of_find_panel_or_bridge()
    to remove a previously allocated panel_bridge.
    Given a specific port and endpoint it remove the panel bridge.
    Since drm_panel_bridge_remove() will check that bridge parameter
    is not NULL and is a real drm_panel_bridge and no a simple bridge
    it is safe to call it directly.
    
    Signed-off-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Reviewed-by: Philippe Cornu <philippe.cornu@st.com>
    Tested-by: Philippe Cornu <philippe.cornu@st.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/1506936888-23844-3-git-send-email-benjamin.gaignard@linaro.org

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index 4c191c050e7d..7a36934ea5db 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -262,3 +262,36 @@ int drm_of_find_panel_or_bridge(const struct device_node *np,
 	return ret;
 }
 EXPORT_SYMBOL_GPL(drm_of_find_panel_or_bridge);
+
+#ifdef CONFIG_DRM_PANEL_BRIDGE
+/*
+ * drm_of_panel_bridge_remove - remove panel bridge
+ * @np: device tree node containing panel bridge output ports
+ *
+ * Remove the panel bridge of a given DT node's port and endpoint number
+ *
+ * Returns zero if successful, or one of the standard error codes if it fails.
+ */
+int drm_of_panel_bridge_remove(const struct device_node *np,
+			       int port, int endpoint)
+{
+	struct drm_bridge *bridge;
+	struct device_node *remote;
+
+	remote = of_graph_get_remote_node(np, port, endpoint);
+	if (!remote)
+		return -ENODEV;
+
+	bridge = of_drm_find_bridge(remote);
+	drm_panel_bridge_remove(bridge);
+
+	return 0;
+}
+#else
+int drm_of_panel_bridge_remove(const struct device_node *np,
+			       int port, int endpoint)
+{
+	return -EINVAL;
+}
+#endif
+EXPORT_SYMBOL_GPL(drm_of_panel_bridge_remove);

commit 320e421ea303b1e53451b2b4cd3ad18cdd043b3b
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Sep 25 13:30:38 2017 +0300

    drm: of: always initialize panel in drm_of_find_panel_or_bridge()
    
    The callers expect "panel" to be initialized, but that isn't true if we
    return -ENODEV.  It causes bugs like:
    
        drivers/gpu/drm/tve200/tve200_drv.c:83 tve200_modeset_init()
        error: uninitialized symbol 'panel'.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170925103038.lvr5msjvekwczctn@mwanda

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index 8dafbdfcd2ea..4c191c050e7d 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -233,6 +233,8 @@ int drm_of_find_panel_or_bridge(const struct device_node *np,
 
 	if (!panel && !bridge)
 		return -EINVAL;
+	if (panel)
+		*panel = NULL;
 
 	remote = of_graph_get_remote_node(np, port, endpoint);
 	if (!remote)

commit 4bf99144d2b407bf393e5a7663fe1ed69c646269
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jul 18 16:43:04 2017 -0500

    drm: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Joonyoung Shim <jy0922.shim@samsung.com>
    Cc: Seung-Woo Kim <sw0312.kim@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: Javier Martinez Canillas <javier@osg.samsung.com>
    Cc: Xinliang Liu <z.liuxinliang@hisilicon.com>
    Cc: Rongrong Zou <zourongrong@gmail.com>
    Cc: Xinwei Kong <kong.kongxinwei@hisilicon.com>
    Cc: Chen Feng <puck.chen@hisilicon.com>
    Cc: CK Hu <ck.hu@mediatek.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Neil Armstrong <narmstrong@baylibre.com>
    Cc: Carlo Caione <carlo@caione.org>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Mark Yao <mark.yao@rock-chips.com>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: dri-devel@lists.freedesktop.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Partially-Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    [seanpaul changed subject prefix and fixed conflict in stm/ltdc.c]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index 2120f33bdf4a..8dafbdfcd2ea 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -160,8 +160,8 @@ int drm_of_component_probe(struct device *dev,
 				of_node_put(remote);
 				continue;
 			} else if (!of_device_is_available(remote->parent)) {
-				dev_warn(dev, "parent device of %s is not available\n",
-					 remote->full_name);
+				dev_warn(dev, "parent device of %pOF is not available\n",
+					 remote);
 				of_node_put(remote);
 				continue;
 			}

commit 1f2db3034c9f16ed918e34809167546f21d0fcb4
Author: Rob Herring <robh@kernel.org>
Date:   Wed Mar 22 08:26:05 2017 -0500

    drm: of: introduce drm_of_find_panel_or_bridge
    
    Many drivers have a common pattern of searching the OF graph for either an
    attached panel or bridge and then finding the DRM struct for the panel
    or bridge. Also, most drivers need to handle deferred probing when the
    DRM device is not yet instantiated. Create a common function,
    drm_of_find_panel_or_bridge, to find the connected node and the
    associated DRM panel or bridge device.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    [seanpaul dropped extern from drm_of.h]
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index b5f2f0fece99..2120f33bdf4a 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -3,8 +3,10 @@
 #include <linux/list.h>
 #include <linux/of_graph.h>
 #include <drm/drmP.h>
+#include <drm/drm_bridge.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_encoder.h>
+#include <drm/drm_panel.h>
 #include <drm/drm_of.h>
 
 static void drm_release_of(struct device *dev, void *data)
@@ -208,3 +210,53 @@ int drm_of_encoder_active_endpoint(struct device_node *node,
 	return -EINVAL;
 }
 EXPORT_SYMBOL_GPL(drm_of_encoder_active_endpoint);
+
+/*
+ * drm_of_find_panel_or_bridge - return connected panel or bridge device
+ * @np: device tree node containing encoder output ports
+ * @panel: pointer to hold returned drm_panel
+ * @bridge: pointer to hold returned drm_bridge
+ *
+ * Given a DT node's port and endpoint number, find the connected node and
+ * return either the associated struct drm_panel or drm_bridge device. Either
+ * @panel or @bridge must not be NULL.
+ *
+ * Returns zero if successful, or one of the standard error codes if it fails.
+ */
+int drm_of_find_panel_or_bridge(const struct device_node *np,
+				int port, int endpoint,
+				struct drm_panel **panel,
+				struct drm_bridge **bridge)
+{
+	int ret = -EPROBE_DEFER;
+	struct device_node *remote;
+
+	if (!panel && !bridge)
+		return -EINVAL;
+
+	remote = of_graph_get_remote_node(np, port, endpoint);
+	if (!remote)
+		return -ENODEV;
+
+	if (panel) {
+		*panel = of_drm_find_panel(remote);
+		if (*panel)
+			ret = 0;
+	}
+
+	/* No panel found yet, check for a bridge next. */
+	if (bridge) {
+		if (ret) {
+			*bridge = of_drm_find_bridge(remote);
+			if (*bridge)
+				ret = 0;
+		} else {
+			*bridge = NULL;
+		}
+
+	}
+
+	of_node_put(remote);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(drm_of_find_panel_or_bridge);

commit 9338203c4f03ffe323b67f0b2fa17b9811fa9bb6
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Nov 28 20:51:09 2016 +0200

    drm: Don't include <drm/drm_encoder.h> in <drm/drm_crtc.h>
    
    <drm/drm_crtc.h> used to define most of the in-kernel KMS API. It has
    now been split into separate files for each object type, but still
    includes most other KMS headers to avoid breaking driver compilation.
    
    As a step towards fixing that problem, remove the inclusion of
    <drm/drm_encoder.h> from <drm/drm_crtc.h> and include it instead where
    appropriate. Also remove the forward declarations of the drm_encoder and
    drm_encoder_helper_funcs structures from <drm/drm_crtc.h> as they're not
    needed in the header.
    
    <drm/drm_encoder.h> now has to include <drm/drm_mode.h> and contain a
    forward declaration of struct drm_encoder in order to allow including it
    as the first header in a compilation unit.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com> # For vmwgfx
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481709550-29226-2-git-send-email-laurent.pinchart+renesas@ideasonboard.com

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index 47848ed8ca48..b5f2f0fece99 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -4,6 +4,7 @@
 #include <linux/of_graph.h>
 #include <drm/drmP.h>
 #include <drm/drm_crtc.h>
+#include <drm/drm_encoder.h>
 #include <drm/drm_of.h>
 
 static void drm_release_of(struct device *dev, void *data)

commit 97ac0e47aed5f635893b0e2df634c64b38ca7541
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Wed Oct 19 11:28:27 2016 +0100

    drm: convert DT component matching to component_match_add_release()
    
    Convert DT component matching to use component_match_add_release().
    
    Acked-by: Jyri Sarha <jsarha@ti.com>
    Reviewed-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/E1bwo6l-0005Io-Q1@rmk-PC.armlinux.org.uk

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index bc98bb94264d..47848ed8ca48 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -6,6 +6,11 @@
 #include <drm/drm_crtc.h>
 #include <drm/drm_of.h>
 
+static void drm_release_of(struct device *dev, void *data)
+{
+	of_node_put(data);
+}
+
 /**
  * drm_crtc_port_mask - find the mask of a registered CRTC by port OF node
  * @dev: DRM device
@@ -63,6 +68,24 @@ uint32_t drm_of_find_possible_crtcs(struct drm_device *dev,
 }
 EXPORT_SYMBOL(drm_of_find_possible_crtcs);
 
+/**
+ * drm_of_component_match_add - Add a component helper OF node match rule
+ * @master: master device
+ * @matchptr: component match pointer
+ * @compare: compare function used for matching component
+ * @node: of_node
+ */
+void drm_of_component_match_add(struct device *master,
+				struct component_match **matchptr,
+				int (*compare)(struct device *, void *),
+				struct device_node *node)
+{
+	of_node_get(node);
+	component_match_add_release(master, matchptr, drm_release_of,
+				    compare, node);
+}
+EXPORT_SYMBOL_GPL(drm_of_component_match_add);
+
 /**
  * drm_of_component_probe - Generic probe function for a component based master
  * @dev: master device containing the OF node
@@ -101,7 +124,7 @@ int drm_of_component_probe(struct device *dev,
 			continue;
 		}
 
-		component_match_add(dev, &match, compare_of, port);
+		drm_of_component_match_add(dev, &match, compare_of, port);
 		of_node_put(port);
 	}
 
@@ -140,7 +163,8 @@ int drm_of_component_probe(struct device *dev,
 				continue;
 			}
 
-			component_match_add(dev, &match, compare_of, remote);
+			drm_of_component_match_add(dev, &match, compare_of,
+						   remote);
 			of_node_put(remote);
 		}
 		of_node_put(port);

commit 4cacf91fcb1d7118e93caf9cb6651d7f7b56e58d
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Tue Feb 24 11:34:01 2015 +0100

    drm: add drm_of_encoder_active_endpoint helpers
    
    This patch adds a helper to parse the encoder endpoint connected to the
    encoder's crtc and two helpers to return its id and port id.
    
    This can be used to determine input mux setting from endpoint or port ids.
    
    Suggested-by: Daniel Kurtz <djkurtz@chromium.org>
    Reviewed-by: Daniel Kurtz <djkurtz@chromium.org>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index 493c05c9ce4f..bc98bb94264d 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -149,3 +149,37 @@ int drm_of_component_probe(struct device *dev,
 	return component_master_add_with_match(dev, m_ops, match);
 }
 EXPORT_SYMBOL(drm_of_component_probe);
+
+/*
+ * drm_of_encoder_active_endpoint - return the active encoder endpoint
+ * @node: device tree node containing encoder input ports
+ * @encoder: drm_encoder
+ *
+ * Given an encoder device node and a drm_encoder with a connected crtc,
+ * parse the encoder endpoint connecting to the crtc port.
+ */
+int drm_of_encoder_active_endpoint(struct device_node *node,
+				   struct drm_encoder *encoder,
+				   struct of_endpoint *endpoint)
+{
+	struct device_node *ep;
+	struct drm_crtc *crtc = encoder->crtc;
+	struct device_node *port;
+	int ret;
+
+	if (!node || !crtc)
+		return -EINVAL;
+
+	for_each_endpoint_of_node(node, ep) {
+		port = of_graph_get_remote_port(ep);
+		of_node_put(port);
+		if (port == crtc->port) {
+			ret = of_graph_parse_endpoint(ep, endpoint);
+			of_node_put(ep);
+			return ret;
+		}
+	}
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(drm_of_encoder_active_endpoint);

commit df785aa87f3a43d6784f1d59803646ad69447da8
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Tue Oct 20 10:23:12 2015 +0100

    drm: Introduce generic probe function for component based masters.
    
    A lot of component based DRM drivers use a variant of the same code
    as the probe function. They bind the crtc ports in the first iteration
    and then scan through the child nodes and bind the encoders attached
    to the remote endpoints. Factor the common code into a separate
    function called drm_of_component_probe() in order to increase code
    reuse.
    
    Cc: David Airlie <airlied@linux.ie>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1445332995-11212-2-git-send-email-Liviu.Dudau@arm.com
    Acked-by: Eric Anholt <eric@anholt.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index be3884073ea4..493c05c9ce4f 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -1,3 +1,4 @@
+#include <linux/component.h>
 #include <linux/export.h>
 #include <linux/list.h>
 #include <linux/of_graph.h>
@@ -61,3 +62,90 @@ uint32_t drm_of_find_possible_crtcs(struct drm_device *dev,
 	return possible_crtcs;
 }
 EXPORT_SYMBOL(drm_of_find_possible_crtcs);
+
+/**
+ * drm_of_component_probe - Generic probe function for a component based master
+ * @dev: master device containing the OF node
+ * @compare_of: compare function used for matching components
+ * @master_ops: component master ops to be used
+ *
+ * Parse the platform device OF node and bind all the components associated
+ * with the master. Interface ports are added before the encoders in order to
+ * satisfy their .bind requirements
+ * See Documentation/devicetree/bindings/graph.txt for the bindings.
+ *
+ * Returns zero if successful, or one of the standard error codes if it fails.
+ */
+int drm_of_component_probe(struct device *dev,
+			   int (*compare_of)(struct device *, void *),
+			   const struct component_master_ops *m_ops)
+{
+	struct device_node *ep, *port, *remote;
+	struct component_match *match = NULL;
+	int i;
+
+	if (!dev->of_node)
+		return -EINVAL;
+
+	/*
+	 * Bind the crtc's ports first, so that drm_of_find_possible_crtcs()
+	 * called from encoder's .bind callbacks works as expected
+	 */
+	for (i = 0; ; i++) {
+		port = of_parse_phandle(dev->of_node, "ports", i);
+		if (!port)
+			break;
+
+		if (!of_device_is_available(port->parent)) {
+			of_node_put(port);
+			continue;
+		}
+
+		component_match_add(dev, &match, compare_of, port);
+		of_node_put(port);
+	}
+
+	if (i == 0) {
+		dev_err(dev, "missing 'ports' property\n");
+		return -ENODEV;
+	}
+
+	if (!match) {
+		dev_err(dev, "no available port\n");
+		return -ENODEV;
+	}
+
+	/*
+	 * For bound crtcs, bind the encoders attached to their remote endpoint
+	 */
+	for (i = 0; ; i++) {
+		port = of_parse_phandle(dev->of_node, "ports", i);
+		if (!port)
+			break;
+
+		if (!of_device_is_available(port->parent)) {
+			of_node_put(port);
+			continue;
+		}
+
+		for_each_child_of_node(port, ep) {
+			remote = of_graph_get_remote_port_parent(ep);
+			if (!remote || !of_device_is_available(remote)) {
+				of_node_put(remote);
+				continue;
+			} else if (!of_device_is_available(remote->parent)) {
+				dev_warn(dev, "parent device of %s is not available\n",
+					 remote->full_name);
+				of_node_put(remote);
+				continue;
+			}
+
+			component_match_add(dev, &match, compare_of, remote);
+			of_node_put(remote);
+		}
+		of_node_put(port);
+	}
+
+	return component_master_add_with_match(dev, m_ops, match);
+}
+EXPORT_SYMBOL(drm_of_component_probe);

commit 6295d607ad34ee4e43aab3f20714c2ef7a6adea1
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jul 9 23:44:25 2015 +0200

    drm: Add modeset object iterators
    
    And roll them out across drm_* files. The point here isn't code
    prettification (it helps with that too) but that some of these lists
    aren't static any more. And having macros will gives us a convenient
    place to put locking checks into.
    
    I didn't add an iterator for props since that's only used by a
    list_for_each_entry_safe in the driver teardown code.
    
    Search&replace was done with the below cocci spatch. Note that there's
    a bunch more places that didn't match and which would need some manual
    changes, but I've intentially left these out for this mostly automated
    patch.
    
    iterator name drm_for_each_crtc;
    struct drm_crtc *crtc;
    struct drm_device *dev;
    expression head;
    @@
    - list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
    + drm_for_each_crtc (crtc, dev) {
    ...
    }
    
    @@
    iterator name drm_for_each_encoder;
    struct drm_encoder *encoder;
    struct drm_device *dev;
    expression head;
    @@
    - list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
    + drm_for_each_encoder (encoder, dev) {
    ...
    }
    
    @@
    iterator name drm_for_each_fb;
    struct drm_framebuffer *fb;
    struct drm_device *dev;
    expression head;
    @@
    - list_for_each_entry(fb, &dev->mode_config.fb_list, head) {
    + drm_for_each_fb (fb, dev) {
    ...
    }
    
    @@
    iterator name drm_for_each_connector;
    struct drm_connector *connector;
    struct drm_device *dev;
    expression head;
    @@
    - list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
    + drm_for_each_connector (connector, dev) {
    ...
    }
    
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index aaa130736bf8..be3884073ea4 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -19,7 +19,7 @@ static uint32_t drm_crtc_port_mask(struct drm_device *dev,
 	unsigned int index = 0;
 	struct drm_crtc *tmp;
 
-	list_for_each_entry(tmp, &dev->mode_config.crtc_list, head) {
+	drm_for_each_crtc(tmp, dev) {
 		if (tmp->port == port)
 			return 1 << index;
 

commit 7416f4e33b5e924baa030ddab1f261a0a85fa32e
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Thu Jul 3 22:59:51 2014 +0200

    drm: use for_each_endpoint_of_node macro in drm_of_find_possible_crtcs
    
    Using the for_each_... macro should make the code a bit shorter and
    easier to read.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
index 16150a00c237..aaa130736bf8 100644
--- a/drivers/gpu/drm/drm_of.c
+++ b/drivers/gpu/drm/drm_of.c
@@ -43,14 +43,10 @@ static uint32_t drm_crtc_port_mask(struct drm_device *dev,
 uint32_t drm_of_find_possible_crtcs(struct drm_device *dev,
 				    struct device_node *port)
 {
-	struct device_node *remote_port, *ep = NULL;
+	struct device_node *remote_port, *ep;
 	uint32_t possible_crtcs = 0;
 
-	do {
-		ep = of_graph_get_next_endpoint(port, ep);
-		if (!ep)
-			break;
-
+	for_each_endpoint_of_node(port, ep) {
 		remote_port = of_graph_get_remote_port(ep);
 		if (!remote_port) {
 			of_node_put(ep);
@@ -60,7 +56,7 @@ uint32_t drm_of_find_possible_crtcs(struct drm_device *dev,
 		possible_crtcs |= drm_crtc_port_mask(dev, remote_port);
 
 		of_node_put(remote_port);
-	} while (1);
+	}
 
 	return possible_crtcs;
 }

commit 7e435aad38083f378ba7889d8b8fdcdbfe7088e7
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Jun 15 11:07:12 2014 +0100

    drm: add of_graph endpoint helper to find possible CRTCs
    
    Add a helper to allow encoders to find their possible CRTCs from the
    OF graph without having to re-implement this functionality.  We add a
    device_node to drm_crtc which corresponds with the port node in the
    DT description of the CRTC device.
    
    We can then scan the DRM device list for CRTCs to find their index,
    matching the appropriate CRTC using the port device_node, thus building
    up the possible CRTC mask.
    
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/gpu/drm/drm_of.c b/drivers/gpu/drm/drm_of.c
new file mode 100644
index 000000000000..16150a00c237
--- /dev/null
+++ b/drivers/gpu/drm/drm_of.c
@@ -0,0 +1,67 @@
+#include <linux/export.h>
+#include <linux/list.h>
+#include <linux/of_graph.h>
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_of.h>
+
+/**
+ * drm_crtc_port_mask - find the mask of a registered CRTC by port OF node
+ * @dev: DRM device
+ * @port: port OF node
+ *
+ * Given a port OF node, return the possible mask of the corresponding
+ * CRTC within a device's list of CRTCs.  Returns zero if not found.
+ */
+static uint32_t drm_crtc_port_mask(struct drm_device *dev,
+				   struct device_node *port)
+{
+	unsigned int index = 0;
+	struct drm_crtc *tmp;
+
+	list_for_each_entry(tmp, &dev->mode_config.crtc_list, head) {
+		if (tmp->port == port)
+			return 1 << index;
+
+		index++;
+	}
+
+	return 0;
+}
+
+/**
+ * drm_of_find_possible_crtcs - find the possible CRTCs for an encoder port
+ * @dev: DRM device
+ * @port: encoder port to scan for endpoints
+ *
+ * Scan all endpoints attached to a port, locate their attached CRTCs,
+ * and generate the DRM mask of CRTCs which may be attached to this
+ * encoder.
+ *
+ * See Documentation/devicetree/bindings/graph.txt for the bindings.
+ */
+uint32_t drm_of_find_possible_crtcs(struct drm_device *dev,
+				    struct device_node *port)
+{
+	struct device_node *remote_port, *ep = NULL;
+	uint32_t possible_crtcs = 0;
+
+	do {
+		ep = of_graph_get_next_endpoint(port, ep);
+		if (!ep)
+			break;
+
+		remote_port = of_graph_get_remote_port(ep);
+		if (!remote_port) {
+			of_node_put(ep);
+			return 0;
+		}
+
+		possible_crtcs |= drm_crtc_port_mask(dev, remote_port);
+
+		of_node_put(remote_port);
+	} while (1);
+
+	return possible_crtcs;
+}
+EXPORT_SYMBOL(drm_of_find_possible_crtcs);
