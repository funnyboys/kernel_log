commit 535d1b947ba3bb6d37791277bf71f1c848522e6c
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Aug 4 11:41:32 2019 +0200

    drm/arm: drop use of drmP.h
    
    Drop use of the deprecated drmP.h header file.
    
    While touching the list of include files divide them
    into blocks and sort within each block.
    Fix fallout.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: malidp@foss.arm.com
    Link: https://patchwork.freedesktop.org/patch/msgid/20190804094132.29463-5-sam@ravnborg.org

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index a3efa28436ea..af67fefed38d 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -9,7 +9,12 @@
  *  Implementation of a CRTC class for the HDLCD driver.
  */
 
-#include <drm/drmP.h>
+#include <linux/clk.h>
+#include <linux/of_graph.h>
+#include <linux/platform_data/simplefb.h>
+
+#include <video/videomode.h>
+
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc.h>
@@ -19,10 +24,7 @@
 #include <drm/drm_of.h>
 #include <drm/drm_plane_helper.h>
 #include <drm/drm_probe_helper.h>
-#include <linux/clk.h>
-#include <linux/of_graph.h>
-#include <linux/platform_data/simplefb.h>
-#include <video/videomode.h>
+#include <drm/drm_vblank.h>
 
 #include "hdlcd_drv.h"
 #include "hdlcd_regs.h"

commit 1c810739097fdeb31b393b67a0a1e3d7ffdd9f63
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Fri May 17 17:37:22 2019 +0100

    drm/arm/hdlcd: Allow a bit of clock tolerance
    
    On the Arm Juno platform, the HDLCD pixel clock is constrained to 250KHz
    resolution in order to avoid the tiny System Control Processor spending
    aeons trying to calculate exact PLL coefficients. This means that modes
    like my oddball 1600x1200 with 130.89MHz clock get rejected since the
    rate cannot be matched exactly. In practice, though, this mode works
    quite happily with the clock at 131MHz, so let's relax the check to
    allow a little bit of slop.
    
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index ecac6fe0b213..a3efa28436ea 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -193,7 +193,8 @@ static enum drm_mode_status hdlcd_crtc_mode_valid(struct drm_crtc *crtc,
 	long rate, clk_rate = mode->clock * 1000;
 
 	rate = clk_round_rate(hdlcd->clk, clk_rate);
-	if (rate != clk_rate) {
+	/* 0.1% seems a close enough tolerance for the TDA19988 on Juno */
+	if (abs(rate - clk_rate) * 1000 > clk_rate) {
 		/* clock required by mode not supported by hardware */
 		return MODE_NOCLOCK;
 	}

commit b96151edced4edb6a18aa89a5fa02c7066efff45
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Fri May 17 17:37:21 2019 +0100

    drm/arm/hdlcd: Actually validate CRTC modes
    
    Rather than allowing any old mode through, then subsequently refusing
    unmatchable clock rates in atomic_check when it's too late to back out
    and pick a different mode, let's do that validation up-front where it
    will cause unsupported modes to be correctly pruned in the first place.
    
    This also eliminates an issue whereby a perceived clock rate of 0 would
    cause atomic disable to fail and prevent the module from being unloaded.
    
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 0b2b62f8fa3c..ecac6fe0b213 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -186,20 +186,19 @@ static void hdlcd_crtc_atomic_disable(struct drm_crtc *crtc,
 	clk_disable_unprepare(hdlcd->clk);
 }
 
-static int hdlcd_crtc_atomic_check(struct drm_crtc *crtc,
-				   struct drm_crtc_state *state)
+static enum drm_mode_status hdlcd_crtc_mode_valid(struct drm_crtc *crtc,
+		const struct drm_display_mode *mode)
 {
 	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
-	struct drm_display_mode *mode = &state->adjusted_mode;
 	long rate, clk_rate = mode->clock * 1000;
 
 	rate = clk_round_rate(hdlcd->clk, clk_rate);
 	if (rate != clk_rate) {
 		/* clock required by mode not supported by hardware */
-		return -EINVAL;
+		return MODE_NOCLOCK;
 	}
 
-	return 0;
+	return MODE_OK;
 }
 
 static void hdlcd_crtc_atomic_begin(struct drm_crtc *crtc,
@@ -220,7 +219,7 @@ static void hdlcd_crtc_atomic_begin(struct drm_crtc *crtc,
 }
 
 static const struct drm_crtc_helper_funcs hdlcd_crtc_helper_funcs = {
-	.atomic_check	= hdlcd_crtc_atomic_check,
+	.mode_valid	= hdlcd_crtc_mode_valid,
 	.atomic_begin	= hdlcd_crtc_atomic_begin,
 	.atomic_enable	= hdlcd_crtc_atomic_enable,
 	.atomic_disable	= hdlcd_crtc_atomic_disable,

commit fcd70cd36b9bf697122538c9e38e8cf954b2342b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 17 22:03:34 2019 +0100

    drm: Split out drm_probe_helper.h
    
    Having the probe helper stuff (which pretty much everyone needs) in
    the drm_crtc_helper.h file (which atomic drivers should never need) is
    confusing. Split them out.
    
    To make sure I actually achieved the goal here I went through all
    drivers. And indeed, all atomic drivers are now free of
    drm_crtc_helper.h includes.
    
    v2: Make it compile. There was so much compile fail on arm drivers
    that I figured I'll better not include any of the acks on v1.
    
    v3: Massive rebase because i915 has lost a lot of drmP.h includes, but
    not all: Through drm_crtc_helper.h > drm_modeset_helper.h -> drmP.h
    there was still one, which this patch largely removes. Which means
    rolling out lots more includes all over.
    
    This will also conflict with ongoing drmP.h cleanup by others I
    expect.
    
    v3: Rebase on top of atomic bochs.
    
    v4: Review from Laurent for bridge/rcar/omap/shmob/core bits:
    - (re)move some of the added includes, use the better include files in
      other places (all suggested from Laurent adopted unchanged).
    - sort alphabetically
    
    v5: Actually try to sort them, and while at it, sort all the ones I
    touch.
    
    v6: Rebase onto i915 changes.
    
    v7: Rebase once more.
    
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Acked-by: CK Hu <ck.hu@mediatek.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: etnaviv@lists.freedesktop.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: spice-devel@lists.freedesktop.org
    Cc: amd-gfx@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-stm32@st-md-mailman.stormreply.com
    Cc: linux-tegra@vger.kernel.org
    Cc: xen-devel@lists.xen.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190117210334.13234-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index e4d67b70244d..0b2b62f8fa3c 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -13,12 +13,12 @@
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc.h>
-#include <drm/drm_crtc_helper.h>
-#include <drm/drm_fb_helper.h>
 #include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
 #include <drm/drm_gem_cma_helper.h>
 #include <drm/drm_of.h>
 #include <drm/drm_plane_helper.h>
+#include <drm/drm_probe_helper.h>
 #include <linux/clk.h>
 #include <linux/of_graph.h>
 #include <linux/platform_data/simplefb.h>

commit d664b851eb2bcdf84a3c063cf59457bb15bc6120
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Mon Jul 23 12:05:53 2018 +0100

    drm/arm/hdlcd: Reject atomic commits that disable only the plane
    
    The HDLCD engine needs an active plane while the CRTC is active, as
    it will start scanning out data from HDLCD_REG_FB_BASE once it gets
    enabled. Make sure that the only available plane doesn't get disabled
    while the CRTC remains active, as this will scanout invalid data.
    
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 8978d82159e5..e4d67b70244d 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -229,6 +229,8 @@ static const struct drm_crtc_helper_funcs hdlcd_crtc_helper_funcs = {
 static int hdlcd_plane_atomic_check(struct drm_plane *plane,
 				    struct drm_plane_state *state)
 {
+	int i;
+	struct drm_crtc *crtc;
 	struct drm_crtc_state *crtc_state;
 	u32 src_h = state->src_h >> 16;
 
@@ -238,20 +240,17 @@ static int hdlcd_plane_atomic_check(struct drm_plane *plane,
 		return -EINVAL;
 	}
 
-	if (!state->fb || !state->crtc)
-		return 0;
-
-	crtc_state = drm_atomic_get_existing_crtc_state(state->state,
-							state->crtc);
-	if (!crtc_state) {
-		DRM_DEBUG_KMS("Invalid crtc state\n");
-		return -EINVAL;
+	for_each_new_crtc_in_state(state->state, crtc, crtc_state, i) {
+		/* we cannot disable the plane while the CRTC is active */
+		if (!state->fb && crtc_state->active)
+			return -EINVAL;
+		return drm_atomic_helper_check_plane_state(state, crtc_state,
+						DRM_PLANE_HELPER_NO_SCALING,
+						DRM_PLANE_HELPER_NO_SCALING,
+						false, true);
 	}
 
-	return drm_atomic_helper_check_plane_state(state, crtc_state,
-						   DRM_PLANE_HELPER_NO_SCALING,
-						   DRM_PLANE_HELPER_NO_SCALING,
-						   false, true);
+	return 0;
 }
 
 static void hdlcd_plane_atomic_update(struct drm_plane *plane,

commit 9fd466f54f89fc3a2dc6f86fce2ea0b993ff83bd
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Jan 17 23:55:28 2018 +0200

    drm: arm: hdlcd: Use drm_atomic_helper_shutdown() to disable planes on removal
    
    The plane cleanup handler currently calls drm_plane_helper_disable(),
    which is a legacy helper function. Replace it with a call to
    drm_atomic_helper_shutdown() at removal time. The plane .destroy()
    handler now consisting only of a call to drm_plane_cleanup(), replace it
    with direct calls to that function.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index c36c75bef6d9..8978d82159e5 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -280,16 +280,10 @@ static const struct drm_plane_helper_funcs hdlcd_plane_helper_funcs = {
 	.atomic_update = hdlcd_plane_atomic_update,
 };
 
-static void hdlcd_plane_destroy(struct drm_plane *plane)
-{
-	drm_plane_helper_disable(plane, NULL);
-	drm_plane_cleanup(plane);
-}
-
 static const struct drm_plane_funcs hdlcd_plane_funcs = {
 	.update_plane		= drm_atomic_helper_update_plane,
 	.disable_plane		= drm_atomic_helper_disable_plane,
-	.destroy		= hdlcd_plane_destroy,
+	.destroy		= drm_plane_cleanup,
 	.reset			= drm_atomic_helper_plane_reset,
 	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
 	.atomic_destroy_state	= drm_atomic_helper_plane_destroy_state,

commit 8df24d57d34cd229e7094cfd1b927b585585202d
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Jan 17 23:55:27 2018 +0200

    drm: arm: hdlcd: Don't destroy plane manually in hdlcd_setup_crtc()
    
    The top-level error handler calls drm_mode_config_cleanup() which will
    destroy all planes. There's no need to destroy them manually in lower
    error handlers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index f3f08cd6e9ef..c36c75bef6d9 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -334,10 +334,8 @@ int hdlcd_setup_crtc(struct drm_device *drm)
 
 	ret = drm_crtc_init_with_planes(drm, &hdlcd->crtc, primary, NULL,
 					&hdlcd_crtc_funcs, NULL);
-	if (ret) {
-		hdlcd_plane_destroy(primary);
+	if (ret)
 		return ret;
-	}
 
 	drm_crtc_helper_add(&hdlcd->crtc, &hdlcd_crtc_helper_funcs);
 	return 0;

commit 070473bcf703366e9acb14e172d5b6563cc07a26
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Mon Jul 2 17:21:23 2018 +0100

    drm: add missing ctx argument to plane transitional helpers
    
    In commits:
    34a2ab5e0689 ("drm: Add acquire ctx parameter to ->update_plane")
    1931529448bc ("drm: Add acquire ctx parameter to ->plane_disable")
    
    a pointer to a drm_modeset_acquire_ctx structure was added as an
    argument to the method prototypes.  The transitional helpers are
    supposed to be directly plugged in as implementations of these
    methods, but doing so generates a warning.  Add the missing
    argument.
    
    A number of buggy users were added for drm_plane_helper_disable()
    which need to be fixed up for this change, which we do by passing
    a NULL ctx argument.
    
    Fixes: 1931529448bc ("drm: Add acquire ctx parameter to ->plane_disable")
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/E1fa1Zr-0005gT-VF@rmk-PC.armlinux.org.uk

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index cf5cbd63ecdf..f3f08cd6e9ef 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -282,7 +282,7 @@ static const struct drm_plane_helper_funcs hdlcd_plane_helper_funcs = {
 
 static void hdlcd_plane_destroy(struct drm_plane *plane)
 {
-	drm_plane_helper_disable(plane);
+	drm_plane_helper_disable(plane, NULL);
 	drm_plane_cleanup(plane);
 }
 

commit 81af63a4af82e739aaa391d1fbb97e02c58ea6a1
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jan 23 19:08:57 2018 +0200

    drm: Don't pass clip to drm_atomic_helper_check_plane_state()
    
    Move the plane clip rectangle handling into
    drm_atomic_helper_check_plane_state(). Drivers no longer
    have to worry about such mundane details.
    
    v2: Convert armada, rcar, and sun4i as well
    v3: Resolve simple_kms_helper conflict
    
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Cc: Mali DP Maintainers <malidp@foss.arm.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Gustavo Padovan <gustavo@padovan.org>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: CK Hu <ck.hu@mediatek.com>
    Cc: Neil Armstrong <narmstrong@baylibre.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Sandy Huang <hjc@rock-chips.com>
    Cc: "Heiko Stübner" <heiko@sntech.de>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: VMware Graphics <linux-graphics-maintainer@vmware.com>
    Cc: Sinclair Yeh <syeh@vmware.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Archit Taneja <architt@codeaurora.org>
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-tegra@vger.kernel.org
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Suggested-by: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Archit Taneja <architt@codeaurora.org> #msm
    Link: https://patchwork.freedesktop.org/patch/msgid/20180123170857.13818-5-ville.syrjala@linux.intel.com
    Acked-by: Liviu Dudau <liviu.dudau@arm.com> #hdlcd,malidp
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de> #imx,mtk
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com> #vmwgfx
    Acked-by: Neil Armstrong <narmstrong@baylibre.com> #meson
    Acked-by: Shawn Guo <shawnguo@kernel.org> #zte

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 877647ef35a9..cf5cbd63ecdf 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -229,7 +229,6 @@ static const struct drm_crtc_helper_funcs hdlcd_crtc_helper_funcs = {
 static int hdlcd_plane_atomic_check(struct drm_plane *plane,
 				    struct drm_plane_state *state)
 {
-	struct drm_rect clip = { 0 };
 	struct drm_crtc_state *crtc_state;
 	u32 src_h = state->src_h >> 16;
 
@@ -249,11 +248,7 @@ static int hdlcd_plane_atomic_check(struct drm_plane *plane,
 		return -EINVAL;
 	}
 
-	if (crtc_state->enable)
-		drm_mode_get_hv_timing(&crtc_state->mode,
-				       &clip.x2, &clip.y2);
-
-	return drm_atomic_helper_check_plane_state(state, crtc_state, &clip,
+	return drm_atomic_helper_check_plane_state(state, crtc_state,
 						   DRM_PLANE_HELPER_NO_SCALING,
 						   DRM_PLANE_HELPER_NO_SCALING,
 						   false, true);

commit 872d20dfbd91b296ebcd0b222f5fa3da89e0d1cf
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Nov 23 21:04:50 2017 +0200

    drm/arm/hdlcd: Use drm_mode_get_hv_timing() to populate plane clip rectangle
    
    Use drm_mode_get_hv_timing() to fill out the plane clip rectangle.
    
    Note that this replaces crtc_state->adjusted_mode usage with
    crtc_state->mode. The latter is the correct choice since that's the
    mode the user provided and it matches the plane crtc coordinates
    the user also provided.
    
    Once everyone agrees on this we can move the clip handling into
    drm_atomic_helper_check_plane_state().
    
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Cc: Mali DP Maintainers <malidp@foss.arm.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171123190502.28449-4-ville.syrjala@linux.intel.com
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Reviewed-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 630721f429f7..877647ef35a9 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -249,8 +249,9 @@ static int hdlcd_plane_atomic_check(struct drm_plane *plane,
 		return -EINVAL;
 	}
 
-	clip.x2 = crtc_state->adjusted_mode.hdisplay;
-	clip.y2 = crtc_state->adjusted_mode.vdisplay;
+	if (crtc_state->enable)
+		drm_mode_get_hv_timing(&crtc_state->mode,
+				       &clip.x2, &clip.y2);
 
 	return drm_atomic_helper_check_plane_state(state, crtc_state, &clip,
 						   DRM_PLANE_HELPER_NO_SCALING,

commit 2c1c55cb75a9c72f9726fabb8c3607947711a8df
Merge: ae64f9bd1d36 2f51be0945b9
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Dec 4 05:38:52 2017 +1000

    Merge tag 'drm-misc-next-2017-11-30' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    Cross-subsystem Changes:
    
    - device tree doc for the Mitsubishi AA070MC01 and Tianma TM070RVHG71
    panels (Lukasz Majewski) and for a 2nd endpoint on stm32 (Philippe Cornu)
    
    Core Changes:
    
    The most important changes are:
    
    - Add drm_driver .last_close and .output_poll_changed helpers to reduce
    fbdev emulation footprint in drivers (Noralf)
    - Fix plane clipping in core and for vmwgfx (Ville)
    
    Then we have a bunch of of improvement for print and debug such as the
    addition of a framebuffer debugfs file. ELD connector, HDMI and
    improvements.  And a bunch of misc improvements, clean ups and style
    changes and doc updates
    
    [airlied: drop eld bits from amdgpu_dm]
    
    Driver Changes:
    
    - sii8620: filter unsupported modes and add DVI mode support (Maciej Purski)
    - rockchip: analogix_dp: Remove unnecessary init code (Jeffy Chen)
    - virtio, cirrus: add fb create_handle support to enable screenshots(Lepton Wu)
    - virtio: replace reference/unreference with get/put (Aastha Gupta)
    - vc4, gma500: Convert timers to use timer_setup() (Kees Cook)
    - vc4: Reject HDMI modes with too high of clocks (Eric)
    - vc4: Add support for more pixel formats (Dave Stevenson)
    - stm: dsi: Rename driver name to "stm32-display-dsi" (Philippe Cornu)
    - stm: ltdc: add a 2nd endpoint (Philippe Cornu)
    - via: use monotonic time for VIA_WAIT_IRQ (Arnd Bergmann)
    
    * tag 'drm-misc-next-2017-11-30' of git://anongit.freedesktop.org/drm/drm-misc: (96 commits)
      drm/bridge: tc358767: add copyright lines
      MAINTAINERS: change maintainer for Rockchip drm drivers
      drm/vblank: Fix vblank timestamp debugs
      drm/via: use monotonic time for VIA_WAIT_IRQ
      dma-buf: Fix ifnullfree.cocci warnings
      drm/printer: Add drm_vprintf()
      drm/edid: Allow HDMI infoframe without VIC or S3D
      video/hdmi: Allow "empty" HDMI infoframes
      dma-buf/fence: Fix lock inversion within dma-fence-array
      drm/sti: Handle return value of platform_get_irq_byname
      drm/vc4: Add support for NV21 and NV61.
      drm/vc4: Use .pixel_order instead of custom .flip_cbcr
      drm/vc4: Add support for DRM_FORMAT_RGB888 and DRM_FORMAT_BGR888
      drm: Move drm_plane_helper_check_state() into drm_atomic_helper.c
      drm: Check crtc_state->enable rather than crtc->enabled in drm_plane_helper_check_state()
      drm/vmwgfx: Try to fix plane clipping
      drm/vmwgfx: Use drm_plane_helper_check_state()
      drm/vmwgfx: Remove bogus crtc coords vs fb size check
      gpu: gma500: remove unneeded DRIVER_LICENSE #define
      drm: don't link DP aux i2c adapter to the hardware device node
      ...

commit fa56b3f83177e1ad60815f750dd3816bd4c25677
Author: Vitor Massaru Iha <vitor@massaru.org>
Date:   Mon Oct 30 11:36:54 2017 -0200

    drm: Fix checkpatch issue: "WARNING: braces {} are not necessary for single statement blocks."
    
    Signed-off-by: Vitor Massaru Iha <vitor@massaru.org>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 72b22b805412..5a5427bbd70e 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -317,9 +317,8 @@ static struct drm_plane *hdlcd_plane_init(struct drm_device *drm)
 				       formats, ARRAY_SIZE(formats),
 				       NULL,
 				       DRM_PLANE_TYPE_PRIMARY, NULL);
-	if (ret) {
+	if (ret)
 		return ERR_PTR(ret);
-	}
 
 	drm_plane_helper_add(plane, &hdlcd_plane_helper_funcs);
 	hdlcd->plane = plane;

commit a01cb8ba3f6282934cff65e89ab36b18b14cbe27
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Nov 1 22:16:19 2017 +0200

    drm: Move drm_plane_helper_check_state() into drm_atomic_helper.c
    
    drm_plane_helper_check_update() isn't a transitional helper, so let's
    rename it to drm_atomic_helper_check_plane_state() and move it into
    drm_atomic_helper.c.
    
    v2: Fix the WARNs about plane_state->crtc matching crtc_state->crtc
    
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Suggested-by: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171101201619.6175-1-ville.syrjala@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 14721723fa8a..63511a3bbf6c 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -252,10 +252,10 @@ static int hdlcd_plane_atomic_check(struct drm_plane *plane,
 	clip.x2 = crtc_state->adjusted_mode.hdisplay;
 	clip.y2 = crtc_state->adjusted_mode.vdisplay;
 
-	return drm_plane_helper_check_state(state, crtc_state, &clip,
-					    DRM_PLANE_HELPER_NO_SCALING,
-					    DRM_PLANE_HELPER_NO_SCALING,
-					    false, true);
+	return drm_atomic_helper_check_plane_state(state, crtc_state, &clip,
+						   DRM_PLANE_HELPER_NO_SCALING,
+						   DRM_PLANE_HELPER_NO_SCALING,
+						   false, true);
 }
 
 static void hdlcd_plane_atomic_update(struct drm_plane *plane,

commit 10b47ee02d1ae66160058241cf5b962f64e81b47
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Nov 1 22:15:58 2017 +0200

    drm: Check crtc_state->enable rather than crtc->enabled in drm_plane_helper_check_state()
    
    drm_plane_helper_check_state() is supposed to do things the atomic way,
    so it should not be inspecting crtc->enabled. Rather we should be
    looking at crtc_state->enable.
    
    We have a slight complication due to drm_plane_helper_check_update()
    reusing drm_plane_helper_check_state() for non-atomic drivers. Thus
    we'll have to pass the crtc_state in manally and construct a fake
    crtc_state in drm_plane_helper_check_update().
    
    v2: Fix the WARNs about plane_state->crtc matching crtc_state->crtc
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171101201558.6059-1-ville.syrjala@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 72b22b805412..14721723fa8a 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -252,7 +252,7 @@ static int hdlcd_plane_atomic_check(struct drm_plane *plane,
 	clip.x2 = crtc_state->adjusted_mode.hdisplay;
 	clip.y2 = crtc_state->adjusted_mode.vdisplay;
 
-	return drm_plane_helper_check_state(state, &clip,
+	return drm_plane_helper_check_state(state, crtc_state, &clip,
 					    DRM_PLANE_HELPER_NO_SCALING,
 					    DRM_PLANE_HELPER_NO_SCALING,
 					    false, true);

commit e6fc3b68558e4c6d8d160b5daf2511b99afa8814
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Sun Jul 23 20:46:38 2017 -0700

    drm: Plumb modifiers through plane init
    
    This is the plumbing for supporting fb modifiers on planes. Modifiers
    have already been introduced to some extent, but this series will extend
    this to allow querying modifiers per plane. Based on this, the client to
    enable optimal modifications for framebuffers.
    
    This patch simply allows the DRM drivers to initialize their list of
    supported modifiers upon initializing the plane.
    
    v2: A minor addition from Daniel
    
    v3:
    * Updated commit message
    * s/INVALID/DRM_FORMAT_MOD_INVALID (Liviu)
    * Remove some excess newlines (Liviu)
    * Update comment for > 64 modifiers (Liviu)
    
    v4: Minor comment adjustments (Liviu)
    
    v5: Some new platforms added due to rebase
    
    v6: Add some missed plane inits (or maybe they're new - who knows at
    this point) (Daniel)
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Daniel Stone <daniels@collabora.com> (v2)
    Reviewed-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Daniel Stone <daniels@collabora.com>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 16e1e20cf04c..72b22b805412 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -315,6 +315,7 @@ static struct drm_plane *hdlcd_plane_init(struct drm_device *drm)
 
 	ret = drm_universal_plane_init(drm, plane, 0xff, &hdlcd_plane_funcs,
 				       formats, ARRAY_SIZE(formats),
+				       NULL,
 				       DRM_PLANE_TYPE_PRIMARY, NULL);
 	if (ret) {
 		return ERR_PTR(ret);

commit 64581714b58bc3e16ede8dc37a025c3aa0e0eef1
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Jun 30 12:36:45 2017 +0300

    drm: Convert atomic drivers from CRTC .disable() to .atomic_disable()
    
    The CRTC .disable() helper operation is deprecated for atomic drivers,
    the new .atomic_disable() helper operation being preferred. Convert all
    atomic drivers to .atomic_disable() to avoid cargo-cult use of
    .disable() in new drivers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com> # for sun4i
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de> # for mediatek
    Acked-by: Alexey Brodkin <abrodkin@synopsys.com> # for arcpgu
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com> # for atmel-hlcdc
    Tested-by: Philippe Cornu <philippe.cornu@st.com> # for stm
    Acked-by: Philippe Cornu <philippe.cornu@st.com> # for stm
    Acked-by: Vincent Abriou <vincent.abriou@st.com> # for sti
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com> # for vmwgfx
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170630093646.7928-3-laurent.pinchart+renesas@ideasonboard.com

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 2b7f4f05d91f..16e1e20cf04c 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -176,7 +176,8 @@ static void hdlcd_crtc_atomic_enable(struct drm_crtc *crtc,
 	drm_crtc_vblank_on(crtc);
 }
 
-static void hdlcd_crtc_disable(struct drm_crtc *crtc)
+static void hdlcd_crtc_atomic_disable(struct drm_crtc *crtc,
+				      struct drm_crtc_state *old_state)
 {
 	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
 
@@ -219,10 +220,10 @@ static void hdlcd_crtc_atomic_begin(struct drm_crtc *crtc,
 }
 
 static const struct drm_crtc_helper_funcs hdlcd_crtc_helper_funcs = {
-	.disable	= hdlcd_crtc_disable,
 	.atomic_check	= hdlcd_crtc_atomic_check,
 	.atomic_begin	= hdlcd_crtc_atomic_begin,
 	.atomic_enable	= hdlcd_crtc_atomic_enable,
+	.atomic_disable	= hdlcd_crtc_atomic_disable,
 };
 
 static int hdlcd_plane_atomic_check(struct drm_plane *plane,

commit 0b20a0f8c3cb6f74fe326101b62eeb5e2c56a53c
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Jun 30 12:36:44 2017 +0300

    drm: Add old state pointer to CRTC .enable() helper function
    
    The old state is useful for drivers that need to perform operations at
    enable time that depend on the transition between the old and new
    states.
    
    While at it, rename the operation to .atomic_enable() to be consistent
    with .atomic_disable(), as the .enable() operation is used by atomic
    helpers only.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com> # for sun4i
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de> # for imx-drm and mediatek
    Acked-by: Alexey Brodkin <abrodkin@synopsys.com> # for arcpgu
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com> # for atmel-hlcdc
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com> # for hdlcd and mali-dp
    Acked-by: Stefan Agner <stefan@agner.ch> # for fsl-dcu
    Tested-by: Philippe Cornu <philippe.cornu@st.com> # for stm
    Acked-by: Philippe Cornu <philippe.cornu@st.com> # for stm
    Acked-by: Vincent Abriou <vincent.abriou@st.com> # for sti
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com> # for vmwgfx
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170630093646.7928-2-laurent.pinchart+renesas@ideasonboard.com

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index d67b6f15e8b8..2b7f4f05d91f 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -165,7 +165,8 @@ static void hdlcd_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	clk_set_rate(hdlcd->clk, m->crtc_clock * 1000);
 }
 
-static void hdlcd_crtc_enable(struct drm_crtc *crtc)
+static void hdlcd_crtc_atomic_enable(struct drm_crtc *crtc,
+				     struct drm_crtc_state *old_state)
 {
 	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
 
@@ -218,10 +219,10 @@ static void hdlcd_crtc_atomic_begin(struct drm_crtc *crtc,
 }
 
 static const struct drm_crtc_helper_funcs hdlcd_crtc_helper_funcs = {
-	.enable		= hdlcd_crtc_enable,
 	.disable	= hdlcd_crtc_disable,
 	.atomic_check	= hdlcd_crtc_atomic_check,
 	.atomic_begin	= hdlcd_crtc_atomic_begin,
+	.atomic_enable	= hdlcd_crtc_atomic_enable,
 };
 
 static int hdlcd_plane_atomic_check(struct drm_plane *plane,

commit fee4964f0a6cd2ce6368d2c69e9ec8e6f44fb0ec
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jun 20 22:30:38 2017 +0200

    drm/arm: hdlcd: remove unused variables
    
    The last rework left behind two unused variables:
    
    drm/arm/hdlcd_crtc.c: In function 'hdlcd_plane_atomic_update':
    drm/arm/hdlcd_crtc.c:264:13: warning: unused variable 'src_y' [-Wunused-variable]
    drm/arm/hdlcd_crtc.c:264:6: warning: unused variable 'src_x' [-Wunused-variable]
    
    This removes them.
    
    Fixes: b2ae06ae9834 ("drm/arm: hdlcd: Use CMA helper for plane buffer address calculation")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 0128ebd318f5..d67b6f15e8b8 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -261,7 +261,7 @@ static void hdlcd_plane_atomic_update(struct drm_plane *plane,
 {
 	struct drm_framebuffer *fb = plane->state->fb;
 	struct hdlcd_drm_private *hdlcd;
-	u32 src_x, src_y, dest_h;
+	u32 dest_h;
 	dma_addr_t scanout_start;
 
 	if (!fb)

commit 49a58f26af7b5ee28ea8788fcd2bb7b590c711c5
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Tue Jun 13 12:18:03 2017 +0100

    drm/arm: hdlcd: Use CMA helper for plane buffer address calculation
    
    CMA has gained a recent helper function for calculating the start
    of the plane buffer's physical address. Use that instead of the
    hand rolled version.
    
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 1a3359c0f6cd..0128ebd318f5 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -261,21 +261,14 @@ static void hdlcd_plane_atomic_update(struct drm_plane *plane,
 {
 	struct drm_framebuffer *fb = plane->state->fb;
 	struct hdlcd_drm_private *hdlcd;
-	struct drm_gem_cma_object *gem;
 	u32 src_x, src_y, dest_h;
 	dma_addr_t scanout_start;
 
 	if (!fb)
 		return;
 
-	src_x = plane->state->src.x1 >> 16;
-	src_y = plane->state->src.y1 >> 16;
 	dest_h = drm_rect_height(&plane->state->dst);
-	gem = drm_fb_cma_get_gem_obj(fb, 0);
-
-	scanout_start = gem->paddr + fb->offsets[0] +
-			src_y * fb->pitches[0] +
-			src_x *	fb->format->cpp[0];
+	scanout_start = drm_fb_cma_get_gem_addr(fb, plane->state, 0);
 
 	hdlcd = plane->dev->dev_private;
 	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_LENGTH, fb->pitches[0]);

commit d51aff16e821a755c242e14168f5d4601199eafd
Merge: 4fd8922689c9 1de3cd4fb49f
Author: Dave Airlie <airlied@redhat.com>
Date:   Sat May 20 06:00:49 2017 +1000

    Merge branch 'for-upstream/hdlcd' of git://linux-arm.org/linux-ld into drm-fixes
    
    single hdlcd fix
    * 'for-upstream/hdlcd' of git://linux-arm.org/linux-ld:
      drm: hdlcd: Fix the calculation of the scanout start address

commit 1de3cd4fb49f3463679c49afe0aa9ceb133f3e49
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Wed Mar 8 16:10:19 2017 +0000

    drm: hdlcd: Fix the calculation of the scanout start address
    
    The calculation of the framebuffer's start address was wrongly using
    the CRTC's x and y position rather than the one of the source
    framebuffer. To fix that we need to update the plane_check code to
    call drm_plane_helper_check_state() to clip the src and dst coordinates.
    While there so some minor cleanup of redundant freeing of
    devm_alloc-ated memory.
    
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 20ebfb4fbdfa..c65116348281 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -10,6 +10,7 @@
  */
 
 #include <drm/drmP.h>
+#include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_crtc_helper.h>
@@ -206,16 +207,33 @@ static const struct drm_crtc_helper_funcs hdlcd_crtc_helper_funcs = {
 static int hdlcd_plane_atomic_check(struct drm_plane *plane,
 				    struct drm_plane_state *state)
 {
-	u32 src_w, src_h;
+	struct drm_rect clip = { 0 };
+	struct drm_crtc_state *crtc_state;
+	u32 src_h = state->src_h >> 16;
 
-	src_w = state->src_w >> 16;
-	src_h = state->src_h >> 16;
+	/* only the HDLCD_REG_FB_LINE_COUNT register has a limit */
+	if (src_h >= HDLCD_MAX_YRES) {
+		DRM_DEBUG_KMS("Invalid source width: %d\n", src_h);
+		return -EINVAL;
+	}
+
+	if (!state->fb || !state->crtc)
+		return 0;
 
-	/* we can't do any scaling of the plane source */
-	if ((src_w != state->crtc_w) || (src_h != state->crtc_h))
+	crtc_state = drm_atomic_get_existing_crtc_state(state->state,
+							state->crtc);
+	if (!crtc_state) {
+		DRM_DEBUG_KMS("Invalid crtc state\n");
 		return -EINVAL;
+	}
 
-	return 0;
+	clip.x2 = crtc_state->adjusted_mode.hdisplay;
+	clip.y2 = crtc_state->adjusted_mode.vdisplay;
+
+	return drm_plane_helper_check_state(state, &clip,
+					    DRM_PLANE_HELPER_NO_SCALING,
+					    DRM_PLANE_HELPER_NO_SCALING,
+					    false, true);
 }
 
 static void hdlcd_plane_atomic_update(struct drm_plane *plane,
@@ -224,21 +242,20 @@ static void hdlcd_plane_atomic_update(struct drm_plane *plane,
 	struct drm_framebuffer *fb = plane->state->fb;
 	struct hdlcd_drm_private *hdlcd;
 	struct drm_gem_cma_object *gem;
-	u32 src_w, src_h, dest_w, dest_h;
+	u32 src_x, src_y, dest_h;
 	dma_addr_t scanout_start;
 
 	if (!fb)
 		return;
 
-	src_w = plane->state->src_w >> 16;
-	src_h = plane->state->src_h >> 16;
-	dest_w = plane->state->crtc_w;
-	dest_h = plane->state->crtc_h;
+	src_x = plane->state->src.x1 >> 16;
+	src_y = plane->state->src.y1 >> 16;
+	dest_h = drm_rect_height(&plane->state->dst);
 	gem = drm_fb_cma_get_gem_obj(fb, 0);
+
 	scanout_start = gem->paddr + fb->offsets[0] +
-		plane->state->crtc_y * fb->pitches[0] +
-		plane->state->crtc_x *
-		fb->format->cpp[0];
+			src_y * fb->pitches[0] +
+			src_x *	fb->format->cpp[0];
 
 	hdlcd = plane->dev->dev_private;
 	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_LENGTH, fb->pitches[0]);
@@ -285,7 +302,6 @@ static struct drm_plane *hdlcd_plane_init(struct drm_device *drm)
 				       formats, ARRAY_SIZE(formats),
 				       DRM_PLANE_TYPE_PRIMARY, NULL);
 	if (ret) {
-		devm_kfree(drm->dev, plane);
 		return ERR_PTR(ret);
 	}
 
@@ -309,7 +325,6 @@ int hdlcd_setup_crtc(struct drm_device *drm)
 					&hdlcd_crtc_funcs, NULL);
 	if (ret) {
 		hdlcd_plane_destroy(primary);
-		devm_kfree(drm->dev, primary);
 		return ret;
 	}
 

commit 1fe25980bb2ef491e8688ae1113b0bb40e3b36a7
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue Feb 7 17:16:16 2017 +0800

    drm: hdlcd: use vblank hooks in struct drm_crtc_funcs
    
    The vblank hooks in struct drm_driver are deprecated and only meant for
    legacy drivers.  For modern drivers with DRIVER_MODESET flag, the hooks
    in struct drm_crtc_funcs should be used instead.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1486458995-31018-5-git-send-email-shawnguo@kernel.org

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 20ebfb4fbdfa..798a3cc480a2 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -42,6 +42,24 @@ static void hdlcd_crtc_cleanup(struct drm_crtc *crtc)
 	drm_crtc_cleanup(crtc);
 }
 
+static int hdlcd_crtc_enable_vblank(struct drm_crtc *crtc)
+{
+	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
+	unsigned int mask = hdlcd_read(hdlcd, HDLCD_REG_INT_MASK);
+
+	hdlcd_write(hdlcd, HDLCD_REG_INT_MASK, mask | HDLCD_INTERRUPT_VSYNC);
+
+	return 0;
+}
+
+static void hdlcd_crtc_disable_vblank(struct drm_crtc *crtc)
+{
+	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
+	unsigned int mask = hdlcd_read(hdlcd, HDLCD_REG_INT_MASK);
+
+	hdlcd_write(hdlcd, HDLCD_REG_INT_MASK, mask & ~HDLCD_INTERRUPT_VSYNC);
+}
+
 static const struct drm_crtc_funcs hdlcd_crtc_funcs = {
 	.destroy = hdlcd_crtc_cleanup,
 	.set_config = drm_atomic_helper_set_config,
@@ -49,6 +67,8 @@ static const struct drm_crtc_funcs hdlcd_crtc_funcs = {
 	.reset = drm_atomic_helper_crtc_reset,
 	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
 	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+	.enable_vblank = hdlcd_crtc_enable_vblank,
+	.disable_vblank = hdlcd_crtc_disable_vblank,
 };
 
 static struct simplefb_format supported_formats[] = SIMPLEFB_FORMATS;

commit 438b74a5497c36d6d59baded434002e30267cabe
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 14 23:32:55 2016 +0200

    drm: Nuke fb->pixel_format
    
    Replace uses of fb->pixel_format with fb->format->format.
    Less duplicated information is a good thing.
    
    Note that coccinelle failed to eliminate the
    "/* fourcc format */" comment from drm_framebuffer.h, so I had
    to do that part manually.
    
    @@
    struct drm_framebuffer *FB;
    expression E;
    @@
     drm_helper_mode_fill_fb_struct(...) {
            ...
    -       FB->pixel_format = E;
            ...
     }
    
    @@
    struct drm_framebuffer *FB;
    expression E;
    @@
     i9xx_get_initial_plane_config(...) {
            ...
    -       FB->pixel_format = E;
            ...
     }
    
    @@
    struct drm_framebuffer *FB;
    expression E;
    @@
     ironlake_get_initial_plane_config(...) {
            ...
    -       FB->pixel_format = E;
            ...
     }
    
    @@
    struct drm_framebuffer *FB;
    expression E;
    @@
     skylake_get_initial_plane_config(...) {
            ...
    -       FB->pixel_format = E;
            ...
     }
    
    @@
    struct drm_framebuffer *a;
    struct drm_framebuffer b;
    @@
    (
    - a->pixel_format
    + a->format->format
    |
    - b.pixel_format
    + b.format->format
    )
    
    @@
    struct drm_plane_state *a;
    struct drm_plane_state b;
    @@
    (
    - a->fb->pixel_format
    + a->fb->format->format
    |
    - b.fb->pixel_format
    + b.fb->format->format
    )
    
    @@
    struct drm_crtc *CRTC;
    @@
    (
    - CRTC->primary->fb->pixel_format
    + CRTC->primary->fb->format->format
    |
    - CRTC->primary->state->fb->pixel_format
    + CRTC->primary->state->fb->format->format
    )
    
    @@
    struct drm_mode_set *set;
    @@
    (
    - set->fb->pixel_format
    + set->fb->format->format
    |
    - set->crtc->primary->fb->pixel_format
    + set->crtc->primary->fb->format->format
    )
    
    @@
    @@
     struct drm_framebuffer {
             ...
    -        uint32_t pixel_format;
             ...
     };
    
    v2: Fix commit message (Laurent)
        Rebase due to earlier removal of many fb->pixel_format uses,
        including the 'fb->format = drm_format_info(fb->format->format);'
        snafu
    v3: Adjusted the semantic patch a bit and regenerated due to code
        changes
    
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com> (v1)
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481751175-18463-1-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index ecdcd99c92cc..20ebfb4fbdfa 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -65,7 +65,7 @@ static int hdlcd_set_pxl_fmt(struct drm_crtc *crtc)
 	struct simplefb_format *format = NULL;
 	int i;
 
-	pixel_format = fb->pixel_format;
+	pixel_format = fb->format->format;
 
 	for (i = 0; i < ARRAY_SIZE(supported_formats); i++) {
 		if (supported_formats[i].fourcc == pixel_format)

commit 353c859899635ea911f6476a0194c7a32c0c09c2
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 14 23:30:57 2016 +0200

    drm: Replace drm_format_plane_cpp() with fb->format->cpp[]
    
    Replace drm_format_plane_cpp(fb->pixel_format) with just
    fb->format->cpp[]. Avoids the expensive format info lookup.
    
    @@
    struct drm_framebuffer *a;
    struct drm_framebuffer b;
    expression E;
    @@
    (
    - drm_format_plane_cpp(a->pixel_format, E)
    + a->format->cpp[E]
    |
    - drm_format_plane_cpp(b.pixel_format, E)
    + b.format->cpp[E]
    )
    
    @@
    struct drm_plane_state *a;
    struct drm_plane_state b;
    expression E;
    @@
    (
    - drm_format_plane_cpp(a->fb->pixel_format, E)
    + a->fb->format->cpp[E]
    |
    - drm_format_plane_cpp(b.fb->pixel_format, E)
    + b.fb->format->cpp[E]
    )
    
    @@
    struct drm_framebuffer *a;
    identifier T;
    expression E;
    @@
      T = a->pixel_format
    <+...
    - drm_format_plane_cpp(T, E)
    + a->format->cpp[E]
    ...+>
    
    @@
    struct drm_framebuffer b;
    identifier T;
    expression E;
    @@
      T = b.pixel_format
    <+...
    - drm_format_plane_cpp(T, E)
    + b.format->cpp[E]
    ...+>
    
    v2: Rerun spatch due to code changes
    
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Suggested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481751057-18123-1-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 35705a4173f3..ecdcd99c92cc 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -238,7 +238,7 @@ static void hdlcd_plane_atomic_update(struct drm_plane *plane,
 	scanout_start = gem->paddr + fb->offsets[0] +
 		plane->state->crtc_y * fb->pitches[0] +
 		plane->state->crtc_x *
-		drm_format_plane_cpp(fb->pixel_format, 0);
+		fb->format->cpp[0];
 
 	hdlcd = plane->dev->dev_private;
 	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_LENGTH, fb->pitches[0]);

commit 59477fa90bfecc324708270f0867c2b4a9103956
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Nov 18 21:52:45 2016 +0200

    drm/arm: Add local 'fb' variables
    
    Add a local 'fb' variable to a few places to get rid of the
    'crtc->primary->fb' stuff. Looks neater and helps me with my ppor
    coccinelle skills later.
    
    In some places the local variable was already there, just not used
    consistently.
    
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Cc: Mali DP Maintainers <malidp@foss.arm.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1479498793-31021-10-git-send-email-ville.syrjala@linux.intel.com
    Reviewed-by: Brian Starkey <brian.starkey@arm.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 7d4e5aa77195..35705a4173f3 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -60,11 +60,12 @@ static int hdlcd_set_pxl_fmt(struct drm_crtc *crtc)
 {
 	unsigned int btpp;
 	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
+	const struct drm_framebuffer *fb = crtc->primary->state->fb;
 	uint32_t pixel_format;
 	struct simplefb_format *format = NULL;
 	int i;
 
-	pixel_format = crtc->primary->state->fb->pixel_format;
+	pixel_format = fb->pixel_format;
 
 	for (i = 0; i < ARRAY_SIZE(supported_formats); i++) {
 		if (supported_formats[i].fourcc == pixel_format)
@@ -220,27 +221,28 @@ static int hdlcd_plane_atomic_check(struct drm_plane *plane,
 static void hdlcd_plane_atomic_update(struct drm_plane *plane,
 				      struct drm_plane_state *state)
 {
+	struct drm_framebuffer *fb = plane->state->fb;
 	struct hdlcd_drm_private *hdlcd;
 	struct drm_gem_cma_object *gem;
 	u32 src_w, src_h, dest_w, dest_h;
 	dma_addr_t scanout_start;
 
-	if (!plane->state->fb)
+	if (!fb)
 		return;
 
 	src_w = plane->state->src_w >> 16;
 	src_h = plane->state->src_h >> 16;
 	dest_w = plane->state->crtc_w;
 	dest_h = plane->state->crtc_h;
-	gem = drm_fb_cma_get_gem_obj(plane->state->fb, 0);
-	scanout_start = gem->paddr + plane->state->fb->offsets[0] +
-		plane->state->crtc_y * plane->state->fb->pitches[0] +
+	gem = drm_fb_cma_get_gem_obj(fb, 0);
+	scanout_start = gem->paddr + fb->offsets[0] +
+		plane->state->crtc_y * fb->pitches[0] +
 		plane->state->crtc_x *
-		drm_format_plane_cpp(plane->state->fb->pixel_format, 0);
+		drm_format_plane_cpp(fb->pixel_format, 0);
 
 	hdlcd = plane->dev->dev_private;
-	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_LENGTH, plane->state->fb->pitches[0]);
-	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_PITCH, plane->state->fb->pitches[0]);
+	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_LENGTH, fb->pitches[0]);
+	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_PITCH, fb->pitches[0]);
 	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_COUNT, dest_h - 1);
 	hdlcd_write(hdlcd, HDLCD_REG_FB_BASE, scanout_start);
 }

commit f03ee46be9401e3434f52bb15e92d1e640f76438
Merge: 0d5320fc1941 3e5de27e940d
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Dec 5 17:11:48 2016 +1000

    Backmerge tag 'v4.9-rc8' into drm-next
    
    Linux 4.9-rc8
    
    Daniel requested this so we could apply some follow on fixes cleanly to -next.

commit 7a79279e7186c4ac8b753cbd335ecc4ba81b5970
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Tue Nov 22 13:56:54 2016 +0000

    drm/arm: hdlcd: fix plane base address update
    
    While testing HDMI with Xorg on the Juno board, I find that when Xorg
    starts up or shuts down, the display is shifted significantly to the
    right and wrapped in the active region.  (No sync bars are visible.)
    The timings are correct, it behaves as if the start address has been
    shifted many pixels _into_ the framebuffer.
    
    This occurs whenever the display mode size is changed - using xrandr
    in Xorg shows that changing the resolution triggers the problem
    almost every time, but changing the refresh rate does not.
    
    Using devmem2 to disable and re-enable the HDLCD resolves the issue,
    and repeated disable/enable cycles do not make the issue re-appear.
    Further debugging shows that we try to update the controller
    configuration while enabled.
    
    Alwys ensure that the HDLCD is disabled prior to updating the
    controller timings, and use drm_crtc_vblank_off()/drm_crtc_vblank_on()
    so that DRM knows whether it can expect vblank interrupts.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 48019ae22ddb..28341b32067f 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -150,15 +150,14 @@ static void hdlcd_crtc_enable(struct drm_crtc *crtc)
 	clk_prepare_enable(hdlcd->clk);
 	hdlcd_crtc_mode_set_nofb(crtc);
 	hdlcd_write(hdlcd, HDLCD_REG_COMMAND, 1);
+	drm_crtc_vblank_on(crtc);
 }
 
 static void hdlcd_crtc_disable(struct drm_crtc *crtc)
 {
 	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
 
-	if (!crtc->state->active)
-		return;
-
+	drm_crtc_vblank_off(crtc);
 	hdlcd_write(hdlcd, HDLCD_REG_COMMAND, 0);
 	clk_disable_unprepare(hdlcd->clk);
 }

commit ba0891d1120389ad44c4f4e6d0b71f5fbcc23163
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Oct 18 01:41:13 2016 +0300

    drm: hdlcd: Replace drm_fb_get_bpp_depth() with drm_format_plane_cpp()
    
    The driver needs the number of bytes per pixel, not the bpp and depth
    info meant for fbdev compatibility. Use the right API.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1476744081-24485-6-git-send-email-laurent.pinchart@ideasonboard.com

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 48019ae22ddb..bbaa55add2d2 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -223,14 +223,12 @@ static void hdlcd_plane_atomic_update(struct drm_plane *plane,
 {
 	struct hdlcd_drm_private *hdlcd;
 	struct drm_gem_cma_object *gem;
-	unsigned int depth, bpp;
 	u32 src_w, src_h, dest_w, dest_h;
 	dma_addr_t scanout_start;
 
 	if (!plane->state->fb)
 		return;
 
-	drm_fb_get_bpp_depth(plane->state->fb->pixel_format, &depth, &bpp);
 	src_w = plane->state->src_w >> 16;
 	src_h = plane->state->src_h >> 16;
 	dest_w = plane->state->crtc_w;
@@ -238,7 +236,8 @@ static void hdlcd_plane_atomic_update(struct drm_plane *plane,
 	gem = drm_fb_cma_get_gem_obj(plane->state->fb, 0);
 	scanout_start = gem->paddr + plane->state->fb->offsets[0] +
 		plane->state->crtc_y * plane->state->fb->pitches[0] +
-		plane->state->crtc_x * bpp / 8;
+		plane->state->crtc_x *
+		drm_format_plane_cpp(plane->state->fb->pixel_format, 0);
 
 	hdlcd = plane->dev->dev_private;
 	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_LENGTH, plane->state->fb->pitches[0]);

commit 2cca45574007b4a77fa5f63ea45d664510cec22a
Merge: bb4cec0222f9 e83950816367
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jun 9 11:19:28 2016 +1000

    Merge tag 'topic/drm-misc-2016-06-07' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    As promised, piles of prep work all around:
    - drm_atomic_state rework, prep for nonblocking commit helpers
    - fence patches from Gustavo and Christian to prep for atomic fences and
      some cool work in ttm/amdgpu from Christian
    - drm event prep for both nonblocking commit and atomic fences
    - Gustavo seems on a crusade against the non-kms-native version of the
      vblank functions.
    - prep work from Boris to nuke all the silly ->best_encoder
      implementations we have (we really only need that for truly dynamic
      cases like dvi-i vs dvi-d or dp mst selecting the right transcoder on
      intel)
    - prep work from Laurent to rework the format handling functions
    - and few small things all over
    
    * tag 'topic/drm-misc-2016-06-07' of git://anongit.freedesktop.org/drm-intel: (47 commits)
      drm/dsi: Implement set tear scanline
      drm/fb_cma_helper: Implement fb_mmap callback
      drm/qxl: Remove useless drm_fb_get_bpp_depth() call
      drm/ast: Remove useless drm_fb_get_bpp_depth() call
      drm/atomic: Fix remaining places where !funcs->best_encoder is valid
      drm/core: Change declaration for gamma_set.
      Documentation: add fence-array to kernel DocBook
      drm/shmobile: use drm_crtc_vblank_{get,put}()
      drm/radeon: use drm_crtc_vblank_{get,put}()
      drm/qxl: use drm_crtc_vblank_{get,put}()
      drm/atmel: use drm_crtc_vblank_{get,put}()
      drm/armada: use drm_crtc_vblank_{get,put}()
      drm/amdgpu: use drm_crtc_vblank_{get,put}()
      drm/virtio: use drm_crtc_send_vblank_event()
      drm/udl: use drm_crtc_send_vblank_event()
      drm/qxl: use drm_crtc_send_vblank_event()
      drm/atmel: use drm_crtc_send_vblank_event()
      drm/armada: use drm_crtc_send_vblank_event()
      drm/doc: Switch to sphinx/rst fixed-width quoting
      drm/doc: Drop kerneldoc for static functions in drm_irq.c
      ...

commit 96ebb1f3ed4dca25c6f5d1868b0de61f9366612a
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Wed Jun 1 15:00:15 2016 +0100

    drm: hdlcd: Cleanup the atomic plane operations
    
    Harden the plane_check() code to drop attempts at scaling because
    that is not supported. Make hdlcd_plane_atomic_update() set the pitch
    and line length registers that correctly reflect the plane's values.
    And make hdlcd_crtc_mode_set_nofb() a helper function for
    hdlcd_crtc_enable() rather than an exposed hook.
    
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index 97326c3d7a3a..0813c2f06931 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -106,7 +106,7 @@ static void hdlcd_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
 	struct drm_display_mode *m = &crtc->state->adjusted_mode;
 	struct videomode vm;
-	unsigned int polarities, line_length, err;
+	unsigned int polarities, err;
 
 	vm.vfront_porch = m->crtc_vsync_start - m->crtc_vdisplay;
 	vm.vback_porch = m->crtc_vtotal - m->crtc_vsync_end;
@@ -122,23 +122,18 @@ static void hdlcd_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	if (m->flags & DRM_MODE_FLAG_PVSYNC)
 		polarities |= HDLCD_POLARITY_VSYNC;
 
-	line_length = crtc->primary->state->fb->pitches[0];
-
 	/* Allow max number of outstanding requests and largest burst size */
 	hdlcd_write(hdlcd, HDLCD_REG_BUS_OPTIONS,
 		    HDLCD_BUS_MAX_OUTSTAND | HDLCD_BUS_BURST_16);
 
-	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_LENGTH, line_length);
-	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_PITCH, line_length);
-	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_COUNT, m->crtc_vdisplay - 1);
 	hdlcd_write(hdlcd, HDLCD_REG_V_DATA, m->crtc_vdisplay - 1);
 	hdlcd_write(hdlcd, HDLCD_REG_V_BACK_PORCH, vm.vback_porch - 1);
 	hdlcd_write(hdlcd, HDLCD_REG_V_FRONT_PORCH, vm.vfront_porch - 1);
 	hdlcd_write(hdlcd, HDLCD_REG_V_SYNC, vm.vsync_len - 1);
+	hdlcd_write(hdlcd, HDLCD_REG_H_DATA, m->crtc_hdisplay - 1);
 	hdlcd_write(hdlcd, HDLCD_REG_H_BACK_PORCH, vm.hback_porch - 1);
 	hdlcd_write(hdlcd, HDLCD_REG_H_FRONT_PORCH, vm.hfront_porch - 1);
 	hdlcd_write(hdlcd, HDLCD_REG_H_SYNC, vm.hsync_len - 1);
-	hdlcd_write(hdlcd, HDLCD_REG_H_DATA, m->crtc_hdisplay - 1);
 	hdlcd_write(hdlcd, HDLCD_REG_POLARITIES, polarities);
 
 	err = hdlcd_set_pxl_fmt(crtc);
@@ -153,20 +148,19 @@ static void hdlcd_crtc_enable(struct drm_crtc *crtc)
 	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
 
 	clk_prepare_enable(hdlcd->clk);
+	hdlcd_crtc_mode_set_nofb(crtc);
 	hdlcd_write(hdlcd, HDLCD_REG_COMMAND, 1);
-	drm_crtc_vblank_on(crtc);
 }
 
 static void hdlcd_crtc_disable(struct drm_crtc *crtc)
 {
 	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
 
-	if (!crtc->primary->fb)
+	if (!crtc->state->active)
 		return;
 
 	hdlcd_write(hdlcd, HDLCD_REG_COMMAND, 0);
 	clk_disable_unprepare(hdlcd->clk);
-	drm_crtc_vblank_off(crtc);
 }
 
 static int hdlcd_crtc_atomic_check(struct drm_crtc *crtc,
@@ -188,7 +182,6 @@ static int hdlcd_crtc_atomic_check(struct drm_crtc *crtc,
 static void hdlcd_crtc_atomic_begin(struct drm_crtc *crtc,
 				    struct drm_crtc_state *state)
 {
-	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
 	struct drm_pending_vblank_event *event = crtc->state->event;
 
 	if (event) {
@@ -232,6 +225,15 @@ static const struct drm_crtc_helper_funcs hdlcd_crtc_helper_funcs = {
 static int hdlcd_plane_atomic_check(struct drm_plane *plane,
 				    struct drm_plane_state *state)
 {
+	u32 src_w, src_h;
+
+	src_w = state->src_w >> 16;
+	src_h = state->src_h >> 16;
+
+	/* we can't do any scaling of the plane source */
+	if ((src_w != state->crtc_w) || (src_h != state->crtc_h))
+		return -EINVAL;
+
 	return 0;
 }
 
@@ -240,20 +242,31 @@ static void hdlcd_plane_atomic_update(struct drm_plane *plane,
 {
 	struct hdlcd_drm_private *hdlcd;
 	struct drm_gem_cma_object *gem;
+	unsigned int depth, bpp;
+	u32 src_w, src_h, dest_w, dest_h;
 	dma_addr_t scanout_start;
 
-	if (!plane->state->crtc || !plane->state->fb)
+	if (!plane->state->fb)
 		return;
 
-	hdlcd = crtc_to_hdlcd_priv(plane->state->crtc);
+	drm_fb_get_bpp_depth(plane->state->fb->pixel_format, &depth, &bpp);
+	src_w = plane->state->src_w >> 16;
+	src_h = plane->state->src_h >> 16;
+	dest_w = plane->state->crtc_w;
+	dest_h = plane->state->crtc_h;
 	gem = drm_fb_cma_get_gem_obj(plane->state->fb, 0);
-	scanout_start = gem->paddr;
+	scanout_start = gem->paddr + plane->state->fb->offsets[0] +
+		plane->state->crtc_y * plane->state->fb->pitches[0] +
+		plane->state->crtc_x * bpp / 8;
+
+	hdlcd = plane->dev->dev_private;
+	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_LENGTH, plane->state->fb->pitches[0]);
+	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_PITCH, plane->state->fb->pitches[0]);
+	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_COUNT, dest_h - 1);
 	hdlcd_write(hdlcd, HDLCD_REG_FB_BASE, scanout_start);
 }
 
 static const struct drm_plane_helper_funcs hdlcd_plane_helper_funcs = {
-	.prepare_fb = NULL,
-	.cleanup_fb = NULL,
 	.atomic_check = hdlcd_plane_atomic_check,
 	.atomic_update = hdlcd_plane_atomic_update,
 };

commit 38c8c22c12e99b70fc59ea7ef4d0bb24c11e5ddd
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue May 31 18:21:13 2016 +0200

    drm/hdlcd: Fix up crtc_state->event handling
    
    event_list just reimplemented what drm_crtc_arm_vblank_event does. And
    we also need to send out drm events when shutting down a pipe.
    
    With this it's possible to use the new nonblocking commit support in
    the helpers.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index d1e8d31e37ee..97326c3d7a3a 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -189,19 +189,17 @@ static void hdlcd_crtc_atomic_begin(struct drm_crtc *crtc,
 				    struct drm_crtc_state *state)
 {
 	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
-	unsigned long flags;
-
-	if (crtc->state->event) {
-		struct drm_pending_vblank_event *event = crtc->state->event;
+	struct drm_pending_vblank_event *event = crtc->state->event;
 
+	if (event) {
 		crtc->state->event = NULL;
-		event->pipe = drm_crtc_index(crtc);
-
-		WARN_ON(drm_crtc_vblank_get(crtc) != 0);
 
-		spin_lock_irqsave(&crtc->dev->event_lock, flags);
-		list_add_tail(&event->base.link, &hdlcd->event_list);
-		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+		spin_lock_irq(&crtc->dev->event_lock);
+		if (drm_crtc_vblank_get(crtc) == 0)
+			drm_crtc_arm_vblank_event(crtc, event);
+		else
+			drm_crtc_send_vblank_event(crtc, event);
+		spin_unlock_irq(&crtc->dev->event_lock);
 	}
 }
 

commit a95acec16d932ac78c2f70dc95a83bd162595d6c
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Tue May 17 10:06:54 2016 +0100

    drm: hdlcd: Revamp runtime power management
    
    Because the HDLCD driver acts as a component master it can end
    up enabling the runtime PM functionality before the encoders
    are initialised. This can cause crashes if the component slave
    never probes (missing module) or if the PM operations kick in
    before the probe finishes.
    
    Move the enabling of the runtime PM after the component master
    has finished collecting the slave components and use the DRM
    atomic helpers to suspend and resume the device.
    
    Tested-by: Robin Murphy <Robin.Murphy@arm.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index fef1b04c2aab..d1e8d31e37ee 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -33,8 +33,17 @@
  *
  */
 
+static void hdlcd_crtc_cleanup(struct drm_crtc *crtc)
+{
+	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
+
+	/* stop the controller on cleanup */
+	hdlcd_write(hdlcd, HDLCD_REG_COMMAND, 0);
+	drm_crtc_cleanup(crtc);
+}
+
 static const struct drm_crtc_funcs hdlcd_crtc_funcs = {
-	.destroy = drm_crtc_cleanup,
+	.destroy = hdlcd_crtc_cleanup,
 	.set_config = drm_atomic_helper_set_config,
 	.page_flip = drm_atomic_helper_page_flip,
 	.reset = drm_atomic_helper_crtc_reset,
@@ -155,8 +164,8 @@ static void hdlcd_crtc_disable(struct drm_crtc *crtc)
 	if (!crtc->primary->fb)
 		return;
 
-	clk_disable_unprepare(hdlcd->clk);
 	hdlcd_write(hdlcd, HDLCD_REG_COMMAND, 0);
+	clk_disable_unprepare(hdlcd->clk);
 	drm_crtc_vblank_off(crtc);
 }
 
@@ -294,16 +303,6 @@ static struct drm_plane *hdlcd_plane_init(struct drm_device *drm)
 	return plane;
 }
 
-void hdlcd_crtc_suspend(struct drm_crtc *crtc)
-{
-	hdlcd_crtc_disable(crtc);
-}
-
-void hdlcd_crtc_resume(struct drm_crtc *crtc)
-{
-	hdlcd_crtc_enable(crtc);
-}
-
 int hdlcd_setup_crtc(struct drm_device *drm)
 {
 	struct hdlcd_drm_private *hdlcd = drm->dev_private;

commit 9fb3fc70ca6c22c701321822a17fe18e74c9ebec
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jun 2 00:06:39 2016 +0200

    drm/hdlcd: Clean up crtc hooks
    
    Those are all no longer needed for a pure atomic driver.
    
    Cc: Liviu Dudau <Liviu.Dudau@arm.com>
    Tested-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1464818821-5736-17-git-send-email-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
index fef1b04c2aab..b44f72722764 100644
--- a/drivers/gpu/drm/arm/hdlcd_crtc.c
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -196,30 +196,11 @@ static void hdlcd_crtc_atomic_begin(struct drm_crtc *crtc,
 	}
 }
 
-static void hdlcd_crtc_atomic_flush(struct drm_crtc *crtc,
-				    struct drm_crtc_state *state)
-{
-}
-
-static bool hdlcd_crtc_mode_fixup(struct drm_crtc *crtc,
-			const struct drm_display_mode *mode,
-			struct drm_display_mode *adjusted_mode)
-{
-	return true;
-}
-
 static const struct drm_crtc_helper_funcs hdlcd_crtc_helper_funcs = {
-	.mode_fixup	= hdlcd_crtc_mode_fixup,
-	.mode_set	= drm_helper_crtc_mode_set,
-	.mode_set_base	= drm_helper_crtc_mode_set_base,
-	.mode_set_nofb	= hdlcd_crtc_mode_set_nofb,
 	.enable		= hdlcd_crtc_enable,
 	.disable	= hdlcd_crtc_disable,
-	.prepare	= hdlcd_crtc_disable,
-	.commit		= hdlcd_crtc_enable,
 	.atomic_check	= hdlcd_crtc_atomic_check,
 	.atomic_begin	= hdlcd_crtc_atomic_begin,
-	.atomic_flush	= hdlcd_crtc_atomic_flush,
 };
 
 static int hdlcd_plane_atomic_check(struct drm_plane *plane,

commit 8e22d79240d95c92b6cbc4c4e4139848de458927
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Thu Apr 2 19:48:39 2015 +0100

    drm: Add support for ARM's HDLCD controller.
    
    The HDLCD controller is a display controller that supports resolutions
    up to 4096x4096 pixels. It is present on various development boards
    produced by ARM Ltd and emulated by the latest Fast Models from the
    company.
    
    Cc: David Airlie <airlied@linux.ie>
    Cc: Robin Murphy <robin.murphy@arm.com>
    
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    [Kconfig cleanup and !CONFIG_PM fixes]
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/arm/hdlcd_crtc.c b/drivers/gpu/drm/arm/hdlcd_crtc.c
new file mode 100644
index 000000000000..fef1b04c2aab
--- /dev/null
+++ b/drivers/gpu/drm/arm/hdlcd_crtc.c
@@ -0,0 +1,327 @@
+/*
+ * Copyright (C) 2013-2015 ARM Limited
+ * Author: Liviu Dudau <Liviu.Dudau@arm.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ *  Implementation of a CRTC class for the HDLCD driver.
+ */
+
+#include <drm/drmP.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_of.h>
+#include <drm/drm_plane_helper.h>
+#include <linux/clk.h>
+#include <linux/of_graph.h>
+#include <linux/platform_data/simplefb.h>
+#include <video/videomode.h>
+
+#include "hdlcd_drv.h"
+#include "hdlcd_regs.h"
+
+/*
+ * The HDLCD controller is a dumb RGB streamer that gets connected to
+ * a single HDMI transmitter or in the case of the ARM Models it gets
+ * emulated by the software that does the actual rendering.
+ *
+ */
+
+static const struct drm_crtc_funcs hdlcd_crtc_funcs = {
+	.destroy = drm_crtc_cleanup,
+	.set_config = drm_atomic_helper_set_config,
+	.page_flip = drm_atomic_helper_page_flip,
+	.reset = drm_atomic_helper_crtc_reset,
+	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+};
+
+static struct simplefb_format supported_formats[] = SIMPLEFB_FORMATS;
+
+/*
+ * Setup the HDLCD registers for decoding the pixels out of the framebuffer
+ */
+static int hdlcd_set_pxl_fmt(struct drm_crtc *crtc)
+{
+	unsigned int btpp;
+	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
+	uint32_t pixel_format;
+	struct simplefb_format *format = NULL;
+	int i;
+
+	pixel_format = crtc->primary->state->fb->pixel_format;
+
+	for (i = 0; i < ARRAY_SIZE(supported_formats); i++) {
+		if (supported_formats[i].fourcc == pixel_format)
+			format = &supported_formats[i];
+	}
+
+	if (WARN_ON(!format))
+		return 0;
+
+	/* HDLCD uses 'bytes per pixel', zero means 1 byte */
+	btpp = (format->bits_per_pixel + 7) / 8;
+	hdlcd_write(hdlcd, HDLCD_REG_PIXEL_FORMAT, (btpp - 1) << 3);
+
+	/*
+	 * The format of the HDLCD_REG_<color>_SELECT register is:
+	 *   - bits[23:16] - default value for that color component
+	 *   - bits[11:8]  - number of bits to extract for each color component
+	 *   - bits[4:0]   - index of the lowest bit to extract
+	 *
+	 * The default color value is used when bits[11:8] are zero, when the
+	 * pixel is outside the visible frame area or when there is a
+	 * buffer underrun.
+	 */
+	hdlcd_write(hdlcd, HDLCD_REG_RED_SELECT, format->red.offset |
+#ifdef CONFIG_DRM_HDLCD_SHOW_UNDERRUN
+		    0x00ff0000 |	/* show underruns in red */
+#endif
+		    ((format->red.length & 0xf) << 8));
+	hdlcd_write(hdlcd, HDLCD_REG_GREEN_SELECT, format->green.offset |
+		    ((format->green.length & 0xf) << 8));
+	hdlcd_write(hdlcd, HDLCD_REG_BLUE_SELECT, format->blue.offset |
+		    ((format->blue.length & 0xf) << 8));
+
+	return 0;
+}
+
+static void hdlcd_crtc_mode_set_nofb(struct drm_crtc *crtc)
+{
+	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
+	struct drm_display_mode *m = &crtc->state->adjusted_mode;
+	struct videomode vm;
+	unsigned int polarities, line_length, err;
+
+	vm.vfront_porch = m->crtc_vsync_start - m->crtc_vdisplay;
+	vm.vback_porch = m->crtc_vtotal - m->crtc_vsync_end;
+	vm.vsync_len = m->crtc_vsync_end - m->crtc_vsync_start;
+	vm.hfront_porch = m->crtc_hsync_start - m->crtc_hdisplay;
+	vm.hback_porch = m->crtc_htotal - m->crtc_hsync_end;
+	vm.hsync_len = m->crtc_hsync_end - m->crtc_hsync_start;
+
+	polarities = HDLCD_POLARITY_DATAEN | HDLCD_POLARITY_DATA;
+
+	if (m->flags & DRM_MODE_FLAG_PHSYNC)
+		polarities |= HDLCD_POLARITY_HSYNC;
+	if (m->flags & DRM_MODE_FLAG_PVSYNC)
+		polarities |= HDLCD_POLARITY_VSYNC;
+
+	line_length = crtc->primary->state->fb->pitches[0];
+
+	/* Allow max number of outstanding requests and largest burst size */
+	hdlcd_write(hdlcd, HDLCD_REG_BUS_OPTIONS,
+		    HDLCD_BUS_MAX_OUTSTAND | HDLCD_BUS_BURST_16);
+
+	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_LENGTH, line_length);
+	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_PITCH, line_length);
+	hdlcd_write(hdlcd, HDLCD_REG_FB_LINE_COUNT, m->crtc_vdisplay - 1);
+	hdlcd_write(hdlcd, HDLCD_REG_V_DATA, m->crtc_vdisplay - 1);
+	hdlcd_write(hdlcd, HDLCD_REG_V_BACK_PORCH, vm.vback_porch - 1);
+	hdlcd_write(hdlcd, HDLCD_REG_V_FRONT_PORCH, vm.vfront_porch - 1);
+	hdlcd_write(hdlcd, HDLCD_REG_V_SYNC, vm.vsync_len - 1);
+	hdlcd_write(hdlcd, HDLCD_REG_H_BACK_PORCH, vm.hback_porch - 1);
+	hdlcd_write(hdlcd, HDLCD_REG_H_FRONT_PORCH, vm.hfront_porch - 1);
+	hdlcd_write(hdlcd, HDLCD_REG_H_SYNC, vm.hsync_len - 1);
+	hdlcd_write(hdlcd, HDLCD_REG_H_DATA, m->crtc_hdisplay - 1);
+	hdlcd_write(hdlcd, HDLCD_REG_POLARITIES, polarities);
+
+	err = hdlcd_set_pxl_fmt(crtc);
+	if (err)
+		return;
+
+	clk_set_rate(hdlcd->clk, m->crtc_clock * 1000);
+}
+
+static void hdlcd_crtc_enable(struct drm_crtc *crtc)
+{
+	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
+
+	clk_prepare_enable(hdlcd->clk);
+	hdlcd_write(hdlcd, HDLCD_REG_COMMAND, 1);
+	drm_crtc_vblank_on(crtc);
+}
+
+static void hdlcd_crtc_disable(struct drm_crtc *crtc)
+{
+	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
+
+	if (!crtc->primary->fb)
+		return;
+
+	clk_disable_unprepare(hdlcd->clk);
+	hdlcd_write(hdlcd, HDLCD_REG_COMMAND, 0);
+	drm_crtc_vblank_off(crtc);
+}
+
+static int hdlcd_crtc_atomic_check(struct drm_crtc *crtc,
+				   struct drm_crtc_state *state)
+{
+	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
+	struct drm_display_mode *mode = &state->adjusted_mode;
+	long rate, clk_rate = mode->clock * 1000;
+
+	rate = clk_round_rate(hdlcd->clk, clk_rate);
+	if (rate != clk_rate) {
+		/* clock required by mode not supported by hardware */
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void hdlcd_crtc_atomic_begin(struct drm_crtc *crtc,
+				    struct drm_crtc_state *state)
+{
+	struct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);
+	unsigned long flags;
+
+	if (crtc->state->event) {
+		struct drm_pending_vblank_event *event = crtc->state->event;
+
+		crtc->state->event = NULL;
+		event->pipe = drm_crtc_index(crtc);
+
+		WARN_ON(drm_crtc_vblank_get(crtc) != 0);
+
+		spin_lock_irqsave(&crtc->dev->event_lock, flags);
+		list_add_tail(&event->base.link, &hdlcd->event_list);
+		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+	}
+}
+
+static void hdlcd_crtc_atomic_flush(struct drm_crtc *crtc,
+				    struct drm_crtc_state *state)
+{
+}
+
+static bool hdlcd_crtc_mode_fixup(struct drm_crtc *crtc,
+			const struct drm_display_mode *mode,
+			struct drm_display_mode *adjusted_mode)
+{
+	return true;
+}
+
+static const struct drm_crtc_helper_funcs hdlcd_crtc_helper_funcs = {
+	.mode_fixup	= hdlcd_crtc_mode_fixup,
+	.mode_set	= drm_helper_crtc_mode_set,
+	.mode_set_base	= drm_helper_crtc_mode_set_base,
+	.mode_set_nofb	= hdlcd_crtc_mode_set_nofb,
+	.enable		= hdlcd_crtc_enable,
+	.disable	= hdlcd_crtc_disable,
+	.prepare	= hdlcd_crtc_disable,
+	.commit		= hdlcd_crtc_enable,
+	.atomic_check	= hdlcd_crtc_atomic_check,
+	.atomic_begin	= hdlcd_crtc_atomic_begin,
+	.atomic_flush	= hdlcd_crtc_atomic_flush,
+};
+
+static int hdlcd_plane_atomic_check(struct drm_plane *plane,
+				    struct drm_plane_state *state)
+{
+	return 0;
+}
+
+static void hdlcd_plane_atomic_update(struct drm_plane *plane,
+				      struct drm_plane_state *state)
+{
+	struct hdlcd_drm_private *hdlcd;
+	struct drm_gem_cma_object *gem;
+	dma_addr_t scanout_start;
+
+	if (!plane->state->crtc || !plane->state->fb)
+		return;
+
+	hdlcd = crtc_to_hdlcd_priv(plane->state->crtc);
+	gem = drm_fb_cma_get_gem_obj(plane->state->fb, 0);
+	scanout_start = gem->paddr;
+	hdlcd_write(hdlcd, HDLCD_REG_FB_BASE, scanout_start);
+}
+
+static const struct drm_plane_helper_funcs hdlcd_plane_helper_funcs = {
+	.prepare_fb = NULL,
+	.cleanup_fb = NULL,
+	.atomic_check = hdlcd_plane_atomic_check,
+	.atomic_update = hdlcd_plane_atomic_update,
+};
+
+static void hdlcd_plane_destroy(struct drm_plane *plane)
+{
+	drm_plane_helper_disable(plane);
+	drm_plane_cleanup(plane);
+}
+
+static const struct drm_plane_funcs hdlcd_plane_funcs = {
+	.update_plane		= drm_atomic_helper_update_plane,
+	.disable_plane		= drm_atomic_helper_disable_plane,
+	.destroy		= hdlcd_plane_destroy,
+	.reset			= drm_atomic_helper_plane_reset,
+	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state	= drm_atomic_helper_plane_destroy_state,
+};
+
+static struct drm_plane *hdlcd_plane_init(struct drm_device *drm)
+{
+	struct hdlcd_drm_private *hdlcd = drm->dev_private;
+	struct drm_plane *plane = NULL;
+	u32 formats[ARRAY_SIZE(supported_formats)], i;
+	int ret;
+
+	plane = devm_kzalloc(drm->dev, sizeof(*plane), GFP_KERNEL);
+	if (!plane)
+		return ERR_PTR(-ENOMEM);
+
+	for (i = 0; i < ARRAY_SIZE(supported_formats); i++)
+		formats[i] = supported_formats[i].fourcc;
+
+	ret = drm_universal_plane_init(drm, plane, 0xff, &hdlcd_plane_funcs,
+				       formats, ARRAY_SIZE(formats),
+				       DRM_PLANE_TYPE_PRIMARY, NULL);
+	if (ret) {
+		devm_kfree(drm->dev, plane);
+		return ERR_PTR(ret);
+	}
+
+	drm_plane_helper_add(plane, &hdlcd_plane_helper_funcs);
+	hdlcd->plane = plane;
+
+	return plane;
+}
+
+void hdlcd_crtc_suspend(struct drm_crtc *crtc)
+{
+	hdlcd_crtc_disable(crtc);
+}
+
+void hdlcd_crtc_resume(struct drm_crtc *crtc)
+{
+	hdlcd_crtc_enable(crtc);
+}
+
+int hdlcd_setup_crtc(struct drm_device *drm)
+{
+	struct hdlcd_drm_private *hdlcd = drm->dev_private;
+	struct drm_plane *primary;
+	int ret;
+
+	primary = hdlcd_plane_init(drm);
+	if (IS_ERR(primary))
+		return PTR_ERR(primary);
+
+	ret = drm_crtc_init_with_planes(drm, &hdlcd->crtc, primary, NULL,
+					&hdlcd_crtc_funcs, NULL);
+	if (ret) {
+		hdlcd_plane_destroy(primary);
+		devm_kfree(drm->dev, primary);
+		return ret;
+	}
+
+	drm_crtc_helper_add(&hdlcd->crtc, &hdlcd_crtc_helper_funcs);
+	return 0;
+}
