commit 04e84545b9805f6a141fce0b1f05fb74551094fc
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Fri May 17 11:05:13 2019 +0100

    drm/komeda: Add format support for Y0L2, P010, YUV420_8/10BIT
    
    - Y0L2 and P010 are block (tiled) format, Update the kemeda logic to
    compatible with such block format.
    - Since DRM introduced a general block information to drm_format_info,
      the format_caps->tiled_size no long needed, delete it.
    - Build some fb utils functions for code sharing.
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/include/malidp_io.h b/drivers/gpu/drm/arm/display/include/malidp_io.h
index 4fb3caf864ce..9440dff94212 100644
--- a/drivers/gpu/drm/arm/display/include/malidp_io.h
+++ b/drivers/gpu/drm/arm/display/include/malidp_io.h
@@ -21,6 +21,13 @@ malidp_write32(u32 __iomem *base, u32 offset, u32 v)
 	writel(v, (base + (offset >> 2)));
 }
 
+static inline void
+malidp_write64(u32 __iomem *base, u32 offset, u64 v)
+{
+	writel(lower_32_bits(v), (base + (offset >> 2)));
+	writel(upper_32_bits(v), (base + (offset >> 2) + 1));
+}
+
 static inline void
 malidp_write32_mask(u32 __iomem *base, u32 offset, u32 m, u32 v)
 {

commit 26bd43a759963981ad685b3ed917abd9c41c65f8
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu Jan 3 11:40:21 2019 +0000

    drm/komeda: Build komeda to be a platform module
    
    Implement a simple wrapper for platform module to build komeda to module,
    Also add a very simple D71 layer code to show how to discover a product.
    Komeda driver direct bind the product ENTRY function xxx_identity to DT
    compatible name like:
    
    d71_product = {
            .product_id = MALIDP_D71_PRODUCT_ID,
            .identify = d71_identify,
    },
    
    const struct of_device_id komeda_of_match[] = {
            { .compatible = "arm,mali-d71", .data = &d71_product, },
            {},
    };
    
    Then when linux found a matched DT node and call driver to probe, we can
    easily get the of data, and call into the product to do the identify:
    
    komeda_bind()
    {
        ...
        product = of_device_get_match_data(dev);
    
        product->identify();
        ...
    }
    
    Changes in v4:
    - Replaced kzalloc with devm_kzalloc
    
    Changes in v3:
    - Fixed style problem found by checkpatch.pl --strict.
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/include/malidp_io.h b/drivers/gpu/drm/arm/display/include/malidp_io.h
new file mode 100644
index 000000000000..4fb3caf864ce
--- /dev/null
+++ b/drivers/gpu/drm/arm/display/include/malidp_io.h
@@ -0,0 +1,42 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * (C) COPYRIGHT 2018 ARM Limited. All rights reserved.
+ * Author: James.Qian.Wang <james.qian.wang@arm.com>
+ *
+ */
+#ifndef _MALIDP_IO_H_
+#define _MALIDP_IO_H_
+
+#include <linux/io.h>
+
+static inline u32
+malidp_read32(u32 __iomem *base, u32 offset)
+{
+	return readl((base + (offset >> 2)));
+}
+
+static inline void
+malidp_write32(u32 __iomem *base, u32 offset, u32 v)
+{
+	writel(v, (base + (offset >> 2)));
+}
+
+static inline void
+malidp_write32_mask(u32 __iomem *base, u32 offset, u32 m, u32 v)
+{
+	u32 tmp = malidp_read32(base, offset);
+
+	tmp &= (~m);
+	malidp_write32(base, offset, v | tmp);
+}
+
+static inline void
+malidp_write_group(u32 __iomem *base, u32 offset, int num, const u32 *values)
+{
+	int i;
+
+	for (i = 0; i < num; i++)
+		malidp_write32(base, offset + i * 4, values[i]);
+}
+
+#endif /*_MALIDP_IO_H_*/
