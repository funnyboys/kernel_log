commit f61714cd5bd3610794c1eb76fc96a7041b76a3a4
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Tue Oct 15 09:10:36 2019 +0000

    drm/komeda: Adds output-color format support
    
    Sets output color format according to the connector formats and
    display supported formats. Default value is RGB444 and only force
    YUV format which must be YUV.
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191015091019.26021-1-lowry.li@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index a42503451b5d..456f3c435719 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -167,7 +167,7 @@ static inline bool has_flip_h(u32 rot)
 }
 
 void komeda_crtc_get_color_config(struct drm_crtc_state *crtc_st,
-				  u32 *color_depths);
+				  u32 *color_depths, u32 *color_formats);
 unsigned long komeda_crtc_get_aclk(struct komeda_crtc_state *kcrtc_st);
 
 int komeda_kms_setup_crtcs(struct komeda_kms_dev *kms, struct komeda_dev *mdev);

commit f9204ad9cd8ed83e2d10ab3294df62e03ddad1f3
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Sat Oct 12 06:50:46 2019 +0000

    drm/komeda: Set output color depth for output
    
    Set color_depth according to connector->bpc.
    
    Changes since v1:
     - Fixed min_bpc is effectively set but not used in
    komeda_crtc_get_color_config().
    
    Changes since v2:
     - Align the code.
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Reviewed-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191012065030.12691-1-lowry.li@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index 45c498e15e7a..a42503451b5d 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -166,6 +166,8 @@ static inline bool has_flip_h(u32 rot)
 		return !!(rotation & DRM_MODE_REFLECT_X);
 }
 
+void komeda_crtc_get_color_config(struct drm_crtc_state *crtc_st,
+				  u32 *color_depths);
 unsigned long komeda_crtc_get_aclk(struct komeda_crtc_state *kcrtc_st);
 
 int komeda_kms_setup_crtcs(struct komeda_kms_dev *kms, struct komeda_dev *mdev);

commit 8965ad8433eadadc5a41df2915eec4a144e8aed6
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jun 18 09:10:49 2019 +0100

    drm/komeda: Enable dual-link support
    
    Komeda HW can support dual-link which splits display frame to two halves
    (left/link0, right/link1) and output them by two output links.
    Due to the halved pixel rate of each link, the pxlclk of dual-link can be
    reduced two times compare with single-link.
    
    For enabling dual-link:
    - The DT need to configure two output-links for the pipeline node.
    - Komeda enable dual-link when both link0 and link1 have been connected.
    
    Example of how the pipeline node will look like for dual-link setup
    
    pipe0: pipeline@0 {
            clocks = <&fpgaosc2>;
            clock-names = "pxclk";
            reg = <0>;
    
            #address-cells = <1>;
            #size-cells = <0>;
    
            port@0 {
                    reg = <0>;
    
                    #address-cells = <1>;
                    #size-cells = <0>;
                    dp0_pipe0_link0: endpoint@0 {
                            reg = <0>;
                            remote-endpoint = <&dlink_connector_in0>;
    
                    };
                    dp0_pipe0_link1: endpoint@1 {
                            reg = <1>;
                            remote-endpoint = <&dlink_connector_in1>;
                    };
            };
    };
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190618081013.13638-3-james.qian.wang@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index 2e2a68cc8c40..45c498e15e7a 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -166,7 +166,7 @@ static inline bool has_flip_h(u32 rot)
 		return !!(rotation & DRM_MODE_REFLECT_X);
 }
 
-unsigned long komeda_calc_aclk(struct komeda_crtc_state *kcrtc_st);
+unsigned long komeda_crtc_get_aclk(struct komeda_crtc_state *kcrtc_st);
 
 int komeda_kms_setup_crtcs(struct komeda_kms_dev *kms, struct komeda_dev *mdev);
 

commit ed22c6d9304d35fbdfe4818016ae57a9da5df9bc
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jun 18 09:10:40 2019 +0100

    drm/komeda: Use drm_display_mode "crtc_" prefixed hardware timings
    
    struct drm_display_mode contains two copies of timings.
    - plain timings.
    - hardware timings, the ones with "crtc_" prefix.
    According to the definition, update komeda to use the hardware timing.
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190618081013.13638-2-james.qian.wang@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index 8c89fc245b83..2e2a68cc8c40 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -14,8 +14,6 @@
 #include <drm/drm_device.h>
 #include <drm/drm_writeback.h>
 #include <drm/drm_print.h>
-#include <video/videomode.h>
-#include <video/display_timing.h>
 
 /**
  * struct komeda_plane - komeda instance of drm_plane

commit 990dee3aa45690217e8d83e7704cf07b2f3d9821
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Mon Jul 8 08:00:22 2019 +0100

    drm/komeda: Computing image enhancer internally
    
    Enable image enhancer when the input data flow is 2x+ upscaling.
    
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190708070000.4945-1-james.qian.wang@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index 0c006576a25c..8c89fc245b83 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -47,11 +47,8 @@ struct komeda_plane_state {
 	/** @zlist_node: zorder list node */
 	struct list_head zlist_node;
 
-	/* @img_enhancement: on/off image enhancement
-	 * @layer_split: on/off layer_split
-	 */
-	u8 img_enhancement : 1,
-	   layer_split : 1;
+	/** @layer_split: on/off layer_split */
+	u8 layer_split : 1;
 };
 
 /**

commit c945623c05c34814c655a0c87155dca81d7e7146
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 5 14:10:05 2019 +0200

    drm/komeda: Remove layer_split property
    
    Properties are uapi like anything else, with all the usual rules
    regarding review, testcases, open source userspace ... Furthermore
    driver-private kms properties are highly discouraged, over the past
    few years we've realized we need to make a serious effort at better
    standardizing this stuff.
    
    Again this probably needs multiple pieces to solve this properly:
    
    - Instead of expecting userspace to compute this (and duplicating
      modeset code), the kernel driver should compute when it's necessary
      to enable layer_split mode to make a configuration possible. I.e. in
      komeda_plane_atomic_check() first try komeda_build_layer_data_flow()
      and if that fails, try komeda_build_layer_split_data_flow(), and set
      dflow.en_split accordingly. Assuming I understand somewhat correctly
      what this does.
    
    - If this is needed for validation then you want a debugfs file to
      force this one way or the other, or alternatively  use
      ->atomic_print_state to dump such hidden driver-private state.
      Depends upon how you do your validation ofc.
    
    Fixes: a407a6509393 ("drm/komeda: Add layer split support")
    Cc: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Cc: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Mali DP Maintainers <malidp@foss.arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190705121006.26085-4-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index fb2adc233760..0c006576a25c 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -33,9 +33,6 @@ struct komeda_plane {
 	 * Layers with same capabilities.
 	 */
 	struct komeda_layer *layer;
-
-	/** @prop_layer_split: for on/off layer_split */
-	struct drm_property *prop_layer_split;
 };
 
 /**

commit a76f612c1de8f82b1712e78e73d223f677f8254e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 5 14:10:04 2019 +0200

    drm/komeda: remove img_enhancement property
    
    Properties are uapi like anything else, with all the usual rules
    regarding review, testcases, open source userspace ... Furthermore
    driver-private kms properties are highly discouraged, over the past
    few years we've realized we need to make a serious effort at better
    standardizing this stuff.
    
    Again this probably needs multiple pieces to solve this properly:
    
    - Instead of expecting userspace to compute this (and duplicating
      modeset code), the kernel driver should compute when it's possible
      to enable this better up/downscale mode (assuming I understood
      Liviu correctly on what this does) automatically.
    
    - If this is needed for validation then you want a debugfs file to
      force this one way or the other, or alternatively  use
      ->atomic_print_state to dump such hidden driver-private state.
      Depends upon how you do your validation ofc.
    
    Fixes: 42b6f118f6d1 ("drm/komeda: Add image enhancement support")
    Cc: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Cc: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Mali DP Maintainers <malidp@foss.arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190705121006.26085-3-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index c545cb963d40..fb2adc233760 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -34,8 +34,6 @@ struct komeda_plane {
 	 */
 	struct komeda_layer *layer;
 
-	/** @prop_img_enhancement: for on/off image enhancement */
-	struct drm_property *prop_img_enhancement;
 	/** @prop_layer_split: for on/off layer_split */
 	struct drm_property *prop_layer_split;
 };

commit 8aa0625f48559861b17606cf73fb24bd9f479303
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 5 14:10:03 2019 +0200

    drm/komeda: remove slave_planes property
    
    Properties are uapi like anything else, with all the usual rules
    regarding review, testcases, open source userspace ... Furthermore
    driver-private kms properties are highly discouraged, over the past
    few years we've realized we need to make a serious effort at better
    standardizing this stuff.
    
    Again this probably needs multiple pieces to solve this properly:
    
    - To make plane configuration less surprising to userspace you
      propably need to virtualize planes, and reorder which logical plane
      you map to which physical one dynamically. Instead of exposing a
      komeda-specific limitation to userspace and expecting them to dtrt.
      I think msm and rcar-du do that already (and others), if you need
      people to chat with or example code.
    
    - If this is needed for validation, again ->atomic_print_state and the
      infrastructure around that is your friend.
    
    Fixes: 3b9dfa4ef28c ("drm/komeda: Add slave pipeline support")
    Cc: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Cc: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Mali DP Maintainers <malidp@foss.arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190705121006.26085-2-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index 2775f34bf4ab..c545cb963d40 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -94,9 +94,6 @@ struct komeda_crtc {
 
 	/** @disable_done: this flip_done is for tracing the disable */
 	struct completion *disable_done;
-
-	/** @slave_planes_property: property for slaves of the planes */
-	struct drm_property *slave_planes_property;
 };
 
 /**

commit 505f6cff880e33a9725bc8337bcb2941c6dd43a6
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 5 14:10:02 2019 +0200

    drm/komeda: Remove clock ratio property
    
    Properties are uapi like anything else, with all the usual rules
    regarding review, testcases, open source userspace ... Furthermore
    driver-private kms properties are highly discouraged, over the past
    few years we've realized we need to make a serious effort at better
    standardizing this stuff.
    
    From the discussion with Liviu the solution for these here needs
    multiple pieces:
    
    - For being able to reliably read the memory clock we need a DT
      property, plus maybe DT override snippets to fix it if it's wrong.
    
    - For exposing plane limitations to userspace there's TEST_ONLY. There
      is a bit a gap in telling userspace better that scaling doesn't work
      due to limits (atm a good strategy is to retry again without scaling
      when adding a plane didn't work the first time around). But that
      needs a more generic solution, not exposing something extremely
      komeda specific.
    
    - If this is needed by validation tools, you can still expose it in
      debugfs. We have an entire nice infrastructure for debug printing of
      kms objects already, see the various atomic_print_state callbacks
      and infrastructure around them.
    
    Fixes: 1f7f9ab7900e ("drm/komeda: Add engine clock requirement check for the downscaling")
    Cc: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Cc: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Mali DP Maintainers <malidp@foss.arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190705121006.26085-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index 219fa3f0c336..2775f34bf4ab 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -95,9 +95,6 @@ struct komeda_crtc {
 	/** @disable_done: this flip_done is for tracing the disable */
 	struct completion *disable_done;
 
-	/** @clock_ratio_property: property for ratio of (aclk << 32)/pxlclk */
-	struct drm_property *clock_ratio_property;
-
 	/** @slave_planes_property: property for slaves of the planes */
 	struct drm_property *slave_planes_property;
 };

commit 3b9dfa4ef28c7dfb847cd3f8f97e7b92686c3e76
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Tue Jun 11 12:13:39 2019 +0100

    drm/komeda: Add slave pipeline support
    
    One crtc can use two komeda_pipeline, and one works as master and as
    slave. the slave pipeline doesn't have its own output and timing
    ctrlr, but pre-composite the input layer data flow and then feed the
    result to master. the pipeline configuration like:
    
    slave-layer-0 \
    ...            slave->CU
    slave-layer-4 /         \
                            \
    master-layer-0 --------> master->CU -> ...
     ...                  /
    master-layer-4 ------>
    
    Since komeda Compiz doesn't output alpha, so the slave->CU result
    only can be used as bottom input when blend it with master input data
    flows.
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index 9dcfe5a01e23..219fa3f0c336 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -86,6 +86,9 @@ struct komeda_crtc {
 	 */
 	struct komeda_pipeline *slave;
 
+	/** @slave_planes: komeda slave planes mask */
+	u32 slave_planes;
+
 	/** @wb_conn: komeda write back connector */
 	struct komeda_wb_connector *wb_conn;
 
@@ -94,6 +97,9 @@ struct komeda_crtc {
 
 	/** @clock_ratio_property: property for ratio of (aclk << 32)/pxlclk */
 	struct drm_property *clock_ratio_property;
+
+	/** @slave_planes_property: property for slaves of the planes */
+	struct drm_property *slave_planes_property;
 };
 
 /**
@@ -119,6 +125,9 @@ struct komeda_crtc_state {
 
 	/** @clock_ratio: ratio of (aclk << 32)/pxlclk */
 	u64 clock_ratio;
+
+	/** @max_slave_zorder: the maximum of slave zorder */
+	u32 max_slave_zorder;
 };
 
 /** struct komeda_kms_dev - for gather KMS related things */

commit a407a65093937f6ced4a2ae30d3290088b41df87
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Mon Jun 10 11:16:08 2019 +0100

    drm/komeda: Add layer split support
    
    Komeda supports two types of layer split:
    - none-scaling split
    - scaling split
    Since D71 merger only support scaler as input, so for none-scaling split,
    the two layer dflow will be output to compiz directly. for scaling_split,
    the data flow will be merged by merger firstly, then output the merged
    data flow to compiz.
    
    Komeda handles the split in kernel completely to hide the detailed and
    complicated split calcualtion to user mode, for user only need to set the
    layer_split property to enable/disable it.
    
    v2: Rebase
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index 5f71e669d92b..9dcfe5a01e23 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -36,6 +36,8 @@ struct komeda_plane {
 
 	/** @prop_img_enhancement: for on/off image enhancement */
 	struct drm_property *prop_img_enhancement;
+	/** @prop_layer_split: for on/off layer_split */
+	struct drm_property *prop_layer_split;
 };
 
 /**
@@ -50,8 +52,11 @@ struct komeda_plane_state {
 	/** @zlist_node: zorder list node */
 	struct list_head zlist_node;
 
-	/* @img_enhancement: on/off image enhancement */
-	u8 img_enhancement : 1;
+	/* @img_enhancement: on/off image enhancement
+	 * @layer_split: on/off layer_split
+	 */
+	u8 img_enhancement : 1,
+	   layer_split : 1;
 };
 
 /**
@@ -155,6 +160,19 @@ is_only_changed_connector(struct drm_crtc_state *st, struct drm_connector *conn)
 	return BIT(drm_connector_index(conn)) == changed_connectors;
 }
 
+static inline bool has_flip_h(u32 rot)
+{
+	u32 rotation = drm_rotation_simplify(rot,
+					     DRM_MODE_ROTATE_0 |
+					     DRM_MODE_ROTATE_90 |
+					     DRM_MODE_REFLECT_MASK);
+
+	if (rotation & DRM_MODE_ROTATE_90)
+		return !!(rotation & DRM_MODE_REFLECT_Y);
+	else
+		return !!(rotation & DRM_MODE_REFLECT_X);
+}
+
 unsigned long komeda_calc_aclk(struct komeda_crtc_state *kcrtc_st);
 
 int komeda_kms_setup_crtcs(struct komeda_kms_dev *kms, struct komeda_dev *mdev);

commit 6f84da0c74f12f9dbcc612cced6b1fa07965415d
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Wed Jun 5 11:35:39 2019 +0100

    drm/komeda: Rename main engine clk name "mclk" to "aclk"
    
    To avoid confusion, unify the driver main engine clk name "mclk" to
    the spec name "aclk".
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index c07b4ab1b1d2..5f71e669d92b 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -87,7 +87,7 @@ struct komeda_crtc {
 	/** @disable_done: this flip_done is for tracing the disable */
 	struct completion *disable_done;
 
-	/** @clock_ratio_property: property for ratio of (mclk << 32)/pxlclk */
+	/** @clock_ratio_property: property for ratio of (aclk << 32)/pxlclk */
 	struct drm_property *clock_ratio_property;
 };
 
@@ -112,7 +112,7 @@ struct komeda_crtc_state {
 	 */
 	u32 active_pipes;
 
-	/** @clock_ratio: ratio of (mclk << 32)/pxlclk */
+	/** @clock_ratio: ratio of (aclk << 32)/pxlclk */
 	u64 clock_ratio;
 };
 
@@ -155,7 +155,7 @@ is_only_changed_connector(struct drm_crtc_state *st, struct drm_connector *conn)
 	return BIT(drm_connector_index(conn)) == changed_connectors;
 }
 
-unsigned long komeda_calc_mclk(struct komeda_crtc_state *kcrtc_st);
+unsigned long komeda_calc_aclk(struct komeda_crtc_state *kcrtc_st);
 
 int komeda_kms_setup_crtcs(struct komeda_kms_dev *kms, struct komeda_dev *mdev);
 

commit 109bd7d5f4c2db66541272e5a41aeabd6cfeef95
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Mon May 20 04:33:19 2019 +0100

    drm/komeda: Adds zorder support
    
    - Creates the zpos property.
    - Implement komeda_crtc_normalize_zpos to replace
    drm_atomic_normalize_zpos, reasons as the following:
    
    1. The drm_atomic_normalize_zpos allows to configure same zpos for
    different planes, but komeda doesn't support such configuration.
    2. For further slave pipline case, Komeda need to calculate the
    max_slave_zorder, we will merge such calculation into
    komed_crtc_normalize_zpos to save a separated plane_state loop.
    3. For feature none-scaling layer_split, which a plane_state will be
    assigned to two individual layers(left/right), which requires two
    normalize_zpos for this plane, plane_st->normalize_zpos will be used
    by left layer, normalize_zpos + 1 for right_layer.
    
    This patch series depends on:
    - https://patchwork.freedesktop.org/series/58710/
    - https://patchwork.freedesktop.org/series/59000/
    - https://patchwork.freedesktop.org/series/59002/
    - https://patchwork.freedesktop.org/series/59747/
    - https://patchwork.freedesktop.org/series/59915/
    - https://patchwork.freedesktop.org/series/60083/
    - https://patchwork.freedesktop.org/series/60698/
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index e6e059f2af52..c07b4ab1b1d2 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -7,6 +7,7 @@
 #ifndef _KOMEDA_KMS_H_
 #define _KOMEDA_KMS_H_
 
+#include <linux/list.h>
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc_helper.h>
@@ -46,6 +47,8 @@ struct komeda_plane {
 struct komeda_plane_state {
 	/** @base: &drm_plane_state */
 	struct drm_plane_state base;
+	/** @zlist_node: zorder list node */
+	struct list_head zlist_node;
 
 	/* @img_enhancement: on/off image enhancement */
 	u8 img_enhancement : 1;

commit 42b6f118f6d11268d652ce4946fef25a2611c39d
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu May 23 12:10:27 2019 +0100

    drm/komeda: Add image enhancement support
    
    Besides scaling, Arm display scaler also can support image enhancement.
    For support it, Add a new property "img_enhancement" to plane, then user
    can turn on/off it by this property, and kernel follow user's requirement
    to maitain the state and enable/disable the real HW image enhancement.
    
    v2: Rebase and rename "needs_img_enhancement" to "en_img_enhancement"
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index db59a9042beb..e6e059f2af52 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -32,6 +32,9 @@ struct komeda_plane {
 	 * Layers with same capabilities.
 	 */
 	struct komeda_layer *layer;
+
+	/** @prop_img_enhancement: for on/off image enhancement */
+	struct drm_property *prop_img_enhancement;
 };
 
 /**
@@ -44,7 +47,8 @@ struct komeda_plane_state {
 	/** @base: &drm_plane_state */
 	struct drm_plane_state base;
 
-	/* private properties */
+	/* @img_enhancement: on/off image enhancement */
+	u8 img_enhancement : 1;
 };
 
 /**

commit 1f7f9ab7900ec92c0beac0660cdce37d6af02d38
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu May 23 12:10:21 2019 +0100

    drm/komeda: Add engine clock requirement check for the downscaling
    
    For downscaling there is a restriction, the downscaling needed engine
    clock can not acceed the real engine clock, and the clock requirement
    mostly depend on the specific HW, to solve this problem:
    1. Add a pipeline func - downscaling_clk_check for CORE to query the real
       HW if downscaling can be supported.
    2. Add new property clock ratio which is the ratio of:
         (mclk << 32) / pxlclk
       then User driver can use this ratio to do the clock check to avoid post
       an invalid downscaling to kernel.
    
    v2: Rebase and Delete debug print
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index f16e9e577593..db59a9042beb 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -79,6 +79,9 @@ struct komeda_crtc {
 
 	/** @disable_done: this flip_done is for tracing the disable */
 	struct completion *disable_done;
+
+	/** @clock_ratio_property: property for ratio of (mclk << 32)/pxlclk */
+	struct drm_property *clock_ratio_property;
 };
 
 /**
@@ -101,6 +104,9 @@ struct komeda_crtc_state {
 	 * the active pipelines in once display instance
 	 */
 	u32 active_pipes;
+
+	/** @clock_ratio: ratio of (mclk << 32)/pxlclk */
+	u64 clock_ratio;
 };
 
 /** struct komeda_kms_dev - for gather KMS related things */
@@ -142,6 +148,8 @@ is_only_changed_connector(struct drm_crtc_state *st, struct drm_connector *conn)
 	return BIT(drm_connector_index(conn)) == changed_connectors;
 }
 
+unsigned long komeda_calc_mclk(struct komeda_crtc_state *kcrtc_st);
+
 int komeda_kms_setup_crtcs(struct komeda_kms_dev *kms, struct komeda_dev *mdev);
 
 int komeda_kms_add_crtcs(struct komeda_kms_dev *kms, struct komeda_dev *mdev);

commit 5d51f6c0da1b563e2f8eb5022a4d7748aa687be4
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu May 23 10:36:38 2019 +0100

    drm/komeda: Add writeback support
    
    Komeda driver uses a individual component to describe the HW's writeback
    caps, but drivers doesn't define a new structure and still uses the
    existing "struct komeda_layer" to describe this new component.
    The detailed changes as follow:
    
    1. Initialize wb_layer according to HW and report it to CORE.
    2. CORE exposes wb_layer as a resource to KMS by private_obj.
    3. Report writeback supporting by add a wb_connector to KMS, and then
       wb_connector will take act as a component resources user,
       so the func komeda_wb_encoder_atomic_check claims komeda resources
       (scaler and wb_layer) accroding to its state configuration to the
       wb_connector. and the wb_state configuration will be validated on the
       specific component resources to see if the caps of component can
       meet the requirement of wb_connector. if not check failed.
    4. Update irq_handler to notify the completion of writeback.
    
    NOTE:
    This change doesn't add scaling writeback support, that support will
    be added in the future after the scaler support.
    
    v2: Rebase
    v3: Rebase and constify the d71_wb_layer_funcs
    v4: Addressed Ayan's comments
    
    Depends on:
    - https://patchwork.freedesktop.org/series/59915/
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Acked-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index ac3d9209b4d9..f16e9e577593 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -12,6 +12,7 @@
 #include <drm/drm_crtc_helper.h>
 #include <drm/drm_device.h>
 #include <drm/drm_writeback.h>
+#include <drm/drm_print.h>
 #include <video/videomode.h>
 #include <video/display_timing.h>
 
@@ -73,6 +74,9 @@ struct komeda_crtc {
 	 */
 	struct komeda_pipeline *slave;
 
+	/** @wb_conn: komeda write back connector */
+	struct komeda_wb_connector *wb_conn;
+
 	/** @disable_done: this flip_done is for tracing the disable */
 	struct completion *disable_done;
 };
@@ -116,6 +120,27 @@ struct komeda_kms_dev {
 #define to_kcrtc(p)	container_of(p, struct komeda_crtc, base)
 #define to_kcrtc_st(p)	container_of(p, struct komeda_crtc_state, base)
 #define to_kdev(p)	container_of(p, struct komeda_kms_dev, base)
+#define to_wb_conn(x)	container_of(x, struct drm_writeback_connector, base)
+
+static inline bool is_writeback_only(struct drm_crtc_state *st)
+{
+	struct komeda_wb_connector *wb_conn = to_kcrtc(st->crtc)->wb_conn;
+	struct drm_connector *conn = wb_conn ? &wb_conn->base.base : NULL;
+
+	return conn && (st->connector_mask == BIT(drm_connector_index(conn)));
+}
+
+static inline bool
+is_only_changed_connector(struct drm_crtc_state *st, struct drm_connector *conn)
+{
+	struct drm_crtc_state *old_st;
+	u32 changed_connectors;
+
+	old_st = drm_atomic_get_old_crtc_state(st->state, st->crtc);
+	changed_connectors = st->connector_mask ^ old_st->connector_mask;
+
+	return BIT(drm_connector_index(conn)) == changed_connectors;
+}
 
 int komeda_kms_setup_crtcs(struct komeda_kms_dev *kms, struct komeda_dev *mdev);
 
@@ -123,6 +148,8 @@ int komeda_kms_add_crtcs(struct komeda_kms_dev *kms, struct komeda_dev *mdev);
 int komeda_kms_add_planes(struct komeda_kms_dev *kms, struct komeda_dev *mdev);
 int komeda_kms_add_private_objs(struct komeda_kms_dev *kms,
 				struct komeda_dev *mdev);
+int komeda_kms_add_wb_connectors(struct komeda_kms_dev *kms,
+				 struct komeda_dev *mdev);
 void komeda_kms_cleanup_private_objs(struct komeda_kms_dev *kms);
 
 void komeda_crtc_handle_event(struct komeda_crtc   *kcrtc,

commit 8c919745ee1c4d8d811a1e015d637d17aa78fe26
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Wed Apr 24 06:48:11 2019 +0100

    drm/komeda: Fixed warning: Function parameter or member not described
    
    Fixed the warnings: Function parameter or member 'xxx' not described
    when make htmldocs
    
    This patch depends on:
    - https://patchwork.freedesktop.org/series/54448/
    - https://patchwork.freedesktop.org/series/54449/
    - https://patchwork.freedesktop.org/series/54450/
    
    v2: Rebase and add reporter
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index 7ec571d3c240..ac3d9209b4d9 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -15,7 +15,9 @@
 #include <video/videomode.h>
 #include <video/display_timing.h>
 
-/** struct komeda_plane - komeda instance of drm_plane */
+/**
+ * struct komeda_plane - komeda instance of drm_plane
+ */
 struct komeda_plane {
 	/** @base: &drm_plane */
 	struct drm_plane base;
@@ -71,11 +73,13 @@ struct komeda_crtc {
 	 */
 	struct komeda_pipeline *slave;
 
-	/* this flip_done is for tracing the disable */
+	/** @disable_done: this flip_done is for tracing the disable */
 	struct completion *disable_done;
 };
 
-/** struct komeda_crtc_state */
+/**
+ * struct komeda_crtc_state
+ */
 struct komeda_crtc_state {
 	/** @base: &drm_crtc_state */
 	struct drm_crtc_state base;
@@ -83,7 +87,15 @@ struct komeda_crtc_state {
 	/* private properties */
 
 	/* computed state which are used by validate/check */
+	/**
+	 * @affected_pipes:
+	 * the affected pipelines in once display instance
+	 */
 	u32 affected_pipes;
+	/**
+	 * @active_pipes:
+	 * the active pipelines in once display instance
+	 */
 	u32 active_pipes;
 };
 

commit b7925b61bd311015e48fdfc8983572d0009e3909
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 11:11:16 2019 +0000

    drm/komeda: Add komeda_crtc_atomic_enable/disable
    
    Pass enable/disable command to komeda and adjust komeda hardware for
    enable/disable a display instance.
    
    v2: Rebase
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index beb94ff110d7..7ec571d3c240 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -70,6 +70,9 @@ struct komeda_crtc {
 	 * merge into the master.
 	 */
 	struct komeda_pipeline *slave;
+
+	/* this flip_done is for tracing the disable */
+	struct completion *disable_done;
 };
 
 /** struct komeda_crtc_state */

commit ee6b73d6b09d23e83be0605ff6467ade09077439
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 11:06:01 2019 +0000

    drm/komeda: Initialize komeda component as drm private object
    
    Initialize koemda_layer, komeda_compiz, komeda_improc and
    komeda_timing_ctrlr as drm private object, then track komeda private
    component state by drm_atomic_state.
    
    v2:
    - Update code after Applied commit:
      b962a12050a3 ("drm/atomic: integrate modeset lock with private objects")
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index 15ac8b85506c..beb94ff110d7 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -108,7 +108,7 @@ int komeda_kms_add_crtcs(struct komeda_kms_dev *kms, struct komeda_dev *mdev);
 int komeda_kms_add_planes(struct komeda_kms_dev *kms, struct komeda_dev *mdev);
 int komeda_kms_add_private_objs(struct komeda_kms_dev *kms,
 				struct komeda_dev *mdev);
-void komeda_kms_cleanup_private_objs(struct komeda_dev *mdev);
+void komeda_kms_cleanup_private_objs(struct komeda_kms_dev *kms);
 
 void komeda_crtc_handle_event(struct komeda_crtc   *kcrtc,
 			      struct komeda_events *evts);

commit 0dac37bf1c5dc1e8454fbe8d548f6e312cfd982d
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 09:24:25 2019 +0000

    drm/komeda: Add irq handling
    
    1. Added irq_handler/irq_enable/irq_disable to komeda_dev_func, then the
       Komeda-CORE can control the HW irq via these chip function.
    2. Install irq and register irq_handler to system by DRM, so once the IRQ
       coming, the handling sequence is:
    
       komeda_kms_irq_handler(int irq, void *data)
            /* step 1. call into the CHIP to recognize event */
            mdev->funcs->irq_handler(mdev, &evts);
    
            /* step 2. notify the crtc to handle the events */
            for (i = 0; i < kms->n_crtcs; i++)
                    komeda_crtc_handle_event(&kms->crtcs[i], &evts);
    
    v2:
    - Move get IRQ number into this change.
    - Enable irq before drm_dev_register.
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index 1e0c5ff650c0..15ac8b85506c 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -110,6 +110,9 @@ int komeda_kms_add_private_objs(struct komeda_kms_dev *kms,
 				struct komeda_dev *mdev);
 void komeda_kms_cleanup_private_objs(struct komeda_dev *mdev);
 
+void komeda_crtc_handle_event(struct komeda_crtc   *kcrtc,
+			      struct komeda_events *evts);
+
 struct komeda_kms_dev *komeda_kms_attach(struct komeda_dev *mdev);
 void komeda_kms_detach(struct komeda_kms_dev *kms);
 

commit f5f0a68e00688311fe9104fa32422e4e27ae8d3b
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 09:24:07 2019 +0000

    drm/komeda: Add D71 improc and timing_ctrlr
    
    Add and initialize improc and timing_ctrlr according to D71 capablitites
    
    v2: Rebase.
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index 874e9c9f0749..1e0c5ff650c0 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -12,6 +12,8 @@
 #include <drm/drm_crtc_helper.h>
 #include <drm/drm_device.h>
 #include <drm/drm_writeback.h>
+#include <video/videomode.h>
+#include <video/display_timing.h>
 
 /** struct komeda_plane - komeda instance of drm_plane */
 struct komeda_plane {

commit 6649a95d35d850e417f125821a803ca7889c713c
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Fri Feb 8 23:13:24 2019 +0100

    drm/komeda: fix build with drm_modeset_helper.h update
    
    With drmP.h removed from drm_modeset_helper.h the build of
    komeda filed as reported by linux-next
    
    Add missing include files to fix build.
    For the files touched group include files and sort them.
    
    The fix was tested on a tree with drm-misc-next merged.
    And the patch was also tested to work without drm-misc-next merged.
    
    Build tested on arm + x86.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au> [linux-next]
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: James Wang <james.qian.wang@arm.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190208221324.27002-1-sam@ravnborg.org

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
index f13666004a42..874e9c9f0749 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -10,6 +10,7 @@
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc_helper.h>
+#include <drm/drm_device.h>
 #include <drm/drm_writeback.h>
 
 /** struct komeda_plane - komeda instance of drm_plane */

commit 61f1c4a8ab7575c0147ae6c0d220f9719fdc741e
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu Jan 3 11:41:30 2019 +0000

    drm/komeda: Attach komeda_dev to DRM-KMS
    
    Add komeda_kms abstracton to attach komeda_dev to DRM-KMS
      CRTC: according to the komeda_pipeline
      PLANE: according to komeda_layer (layer input pipeline)
      PRIVATE_OBJS: komeda_pipeline/component all will be treat as private_objs
    
    komeda_kms is for connecting DRM-KMS and komeda_dev, like reporting the
    kms object properties according to the komeda_dev, and pass/convert KMS's
    requirement to komeda_dev.
    
    Changes in v4:
    - Set drm_atomic_helper_check as mode_config->atomic_check.
    
    Changes in v3:
    - Fixed style problem found by checkpatch.pl --strict.
    
    Changes in v2:
    - Unified abbreviation of "pipeline" to "pipe".
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Reviewed-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_kms.h b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
new file mode 100644
index 000000000000..f13666004a42
--- /dev/null
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_kms.h
@@ -0,0 +1,113 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * (C) COPYRIGHT 2018 ARM Limited. All rights reserved.
+ * Author: James.Qian.Wang <james.qian.wang@arm.com>
+ *
+ */
+#ifndef _KOMEDA_KMS_H_
+#define _KOMEDA_KMS_H_
+
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_writeback.h>
+
+/** struct komeda_plane - komeda instance of drm_plane */
+struct komeda_plane {
+	/** @base: &drm_plane */
+	struct drm_plane base;
+	/**
+	 * @layer:
+	 *
+	 * represents available layer input pipelines for this plane.
+	 *
+	 * NOTE:
+	 * the layer is not for a specific Layer, but indicate a group of
+	 * Layers with same capabilities.
+	 */
+	struct komeda_layer *layer;
+};
+
+/**
+ * struct komeda_plane_state
+ *
+ * The plane_state can be split into two data flow (left/right) and handled
+ * by two layers &komeda_plane.layer and &komeda_plane.layer.right
+ */
+struct komeda_plane_state {
+	/** @base: &drm_plane_state */
+	struct drm_plane_state base;
+
+	/* private properties */
+};
+
+/**
+ * struct komeda_wb_connector
+ */
+struct komeda_wb_connector {
+	/** @base: &drm_writeback_connector */
+	struct drm_writeback_connector base;
+
+	/** @wb_layer: represents associated writeback pipeline of komeda */
+	struct komeda_layer *wb_layer;
+};
+
+/**
+ * struct komeda_crtc
+ */
+struct komeda_crtc {
+	/** @base: &drm_crtc */
+	struct drm_crtc base;
+	/** @master: only master has display output */
+	struct komeda_pipeline *master;
+	/**
+	 * @slave: optional
+	 *
+	 * Doesn't have its own display output, the handled data flow will
+	 * merge into the master.
+	 */
+	struct komeda_pipeline *slave;
+};
+
+/** struct komeda_crtc_state */
+struct komeda_crtc_state {
+	/** @base: &drm_crtc_state */
+	struct drm_crtc_state base;
+
+	/* private properties */
+
+	/* computed state which are used by validate/check */
+	u32 affected_pipes;
+	u32 active_pipes;
+};
+
+/** struct komeda_kms_dev - for gather KMS related things */
+struct komeda_kms_dev {
+	/** @base: &drm_device */
+	struct drm_device base;
+
+	/** @n_crtcs: valid numbers of crtcs in &komeda_kms_dev.crtcs */
+	int n_crtcs;
+	/** @crtcs: crtcs list */
+	struct komeda_crtc crtcs[KOMEDA_MAX_PIPELINES];
+};
+
+#define to_kplane(p)	container_of(p, struct komeda_plane, base)
+#define to_kplane_st(p)	container_of(p, struct komeda_plane_state, base)
+#define to_kconn(p)	container_of(p, struct komeda_wb_connector, base)
+#define to_kcrtc(p)	container_of(p, struct komeda_crtc, base)
+#define to_kcrtc_st(p)	container_of(p, struct komeda_crtc_state, base)
+#define to_kdev(p)	container_of(p, struct komeda_kms_dev, base)
+
+int komeda_kms_setup_crtcs(struct komeda_kms_dev *kms, struct komeda_dev *mdev);
+
+int komeda_kms_add_crtcs(struct komeda_kms_dev *kms, struct komeda_dev *mdev);
+int komeda_kms_add_planes(struct komeda_kms_dev *kms, struct komeda_dev *mdev);
+int komeda_kms_add_private_objs(struct komeda_kms_dev *kms,
+				struct komeda_dev *mdev);
+void komeda_kms_cleanup_private_objs(struct komeda_dev *mdev);
+
+struct komeda_kms_dev *komeda_kms_attach(struct komeda_dev *mdev);
+void komeda_kms_detach(struct komeda_kms_dev *kms);
+
+#endif /*_KOMEDA_KMS_H_*/
