commit efb4650885187425f1da96460e5d2a84650f861a
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu Dec 12 07:48:13 2019 +0000

    drm/komeda: Add runtime_pm support
    
    - Add pm_runtime_get/put to crtc_enable/disable along with the real
      display usage
    - Add runtime_get/put to register_show, since register_show() will
      access register, need to wakeup HW.
    - For the case that PM is not enabled or configured, manually wakeup HW
    
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Reviewed-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191212074756.14678-1-james.qian.wang@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 1c452ea75999..56bd938961ee 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -5,6 +5,7 @@
  *
  */
 #include <linux/clk.h>
+#include <linux/pm_runtime.h>
 #include <linux/spinlock.h>
 
 #include <drm/drm_atomic.h>
@@ -274,6 +275,7 @@ static void
 komeda_crtc_atomic_enable(struct drm_crtc *crtc,
 			  struct drm_crtc_state *old)
 {
+	pm_runtime_get_sync(crtc->dev->dev);
 	komeda_crtc_prepare(to_kcrtc(crtc));
 	drm_crtc_vblank_on(crtc);
 	WARN_ON(drm_crtc_vblank_get(crtc));
@@ -372,6 +374,7 @@ komeda_crtc_atomic_disable(struct drm_crtc *crtc,
 	drm_crtc_vblank_put(crtc);
 	drm_crtc_vblank_off(crtc);
 	komeda_crtc_unprepare(kcrtc);
+	pm_runtime_put(crtc->dev->dev);
 }
 
 static void

commit db9cd76d099a0e4337d30e22c89fe019332bcec1
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Tue Nov 12 11:10:28 2019 +0000

    drm/komeda: Adds gamma and color-transform support for DOU-IPS
    
    Adds gamma and color-transform support for DOU-IPS.
    Adds two caps members fgamma_coeffs and ctm_coeffs to komeda_improc_state.
    If color management changed, set gamma and color-transform accordingly.
    
    v5: Rebase with drm-misc-next
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Reviewed-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191112110927.20931-5-james.qian.wang@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 252015210fbc..1c452ea75999 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -617,6 +617,8 @@ static int komeda_crtc_add(struct komeda_kms_dev *kms,
 
 	crtc->port = kcrtc->master->of_output_port;
 
+	drm_crtc_enable_color_mgmt(crtc, 0, true, KOMEDA_COLOR_LUT_SIZE);
+
 	return err;
 }
 

commit f61714cd5bd3610794c1eb76fc96a7041b76a3a4
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Tue Oct 15 09:10:36 2019 +0000

    drm/komeda: Adds output-color format support
    
    Sets output color format according to the connector formats and
    display supported formats. Default value is RGB444 and only force
    YUV format which must be YUV.
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191015091019.26021-1-lowry.li@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 5138a0c01024..252015210fbc 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -18,10 +18,11 @@
 #include "komeda_kms.h"
 
 void komeda_crtc_get_color_config(struct drm_crtc_state *crtc_st,
-				  u32 *color_depths)
+				  u32 *color_depths, u32 *color_formats)
 {
 	struct drm_connector *conn;
 	struct drm_connector_state *conn_st;
+	u32 conn_color_formats = ~0u;
 	int i, min_bpc = 31, conn_bpc = 0;
 
 	for_each_new_connector_in_state(crtc_st->state, conn, conn_st, i) {
@@ -29,12 +30,18 @@ void komeda_crtc_get_color_config(struct drm_crtc_state *crtc_st,
 			continue;
 
 		conn_bpc = conn->display_info.bpc ? conn->display_info.bpc : 8;
+		conn_color_formats &= conn->display_info.color_formats;
 
 		if (conn_bpc < min_bpc)
 			min_bpc = conn_bpc;
 	}
 
+	/* connector doesn't config any color_format, use RGB444 as default */
+	if (!conn_color_formats)
+		conn_color_formats = DRM_COLOR_FORMAT_RGB444;
+
 	*color_depths = GENMASK(min_bpc, 0);
+	*color_formats = conn_color_formats;
 }
 
 static void komeda_crtc_update_clock_ratio(struct komeda_crtc_state *kcrtc_st)

commit f9204ad9cd8ed83e2d10ab3294df62e03ddad1f3
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Sat Oct 12 06:50:46 2019 +0000

    drm/komeda: Set output color depth for output
    
    Set color_depth according to connector->bpc.
    
    Changes since v1:
     - Fixed min_bpc is effectively set but not used in
    komeda_crtc_get_color_config().
    
    Changes since v2:
     - Align the code.
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Reviewed-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191012065030.12691-1-lowry.li@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 9beeda04818b..5138a0c01024 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -17,6 +17,26 @@
 #include "komeda_dev.h"
 #include "komeda_kms.h"
 
+void komeda_crtc_get_color_config(struct drm_crtc_state *crtc_st,
+				  u32 *color_depths)
+{
+	struct drm_connector *conn;
+	struct drm_connector_state *conn_st;
+	int i, min_bpc = 31, conn_bpc = 0;
+
+	for_each_new_connector_in_state(crtc_st->state, conn, conn_st, i) {
+		if (conn_st->crtc != crtc_st->crtc)
+			continue;
+
+		conn_bpc = conn->display_info.bpc ? conn->display_info.bpc : 8;
+
+		if (conn_bpc < min_bpc)
+			min_bpc = conn_bpc;
+	}
+
+	*color_depths = GENMASK(min_bpc, 0);
+}
+
 static void komeda_crtc_update_clock_ratio(struct komeda_crtc_state *kcrtc_st)
 {
 	u64 pxlclk, aclk;

commit ce1ad03656bc35ae833e5344aca44e4069bd2de7
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Oct 4 17:21:56 2019 +0100

    drm/komeda: remove redundant assignment to pointer disable_done
    
    The pointer disable_done is being initialized with a value that
    is never read and is being re-assigned a little later on. The
    assignment is redundant and hence can be removed.
    
    Addresses-Coverity: ("Unused value")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191004162156.325-1-colin.king@canonical.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 75263d8cd0bd..9beeda04818b 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -296,7 +296,7 @@ komeda_crtc_atomic_disable(struct drm_crtc *crtc,
 	struct komeda_crtc_state *old_st = to_kcrtc_st(old);
 	struct komeda_pipeline *master = kcrtc->master;
 	struct komeda_pipeline *slave  = kcrtc->slave;
-	struct completion *disable_done = &crtc->state->commit->flip_done;
+	struct completion *disable_done;
 	bool needs_phase2 = false;
 
 	DRM_DEBUG_ATOMIC("CRTC%d_DISABLE: active_pipes: 0x%x, affected: 0x%x\n",

commit f59769c52cd7d158df53487ec2936f5592073340
Author: Mihail Atanassov <Mihail.Atanassov@arm.com>
Date:   Tue Oct 1 14:21:40 2019 +0000

    drm/komeda: Workaround for broken FLIP_COMPLETE timestamps
    
    When initially turning a crtc on, drm_reset_vblank_timestamp will
    set the vblank timestamp to 0 for any driver that doesn't provide
    a ->get_vblank_timestamp() hook.
    
    Unfortunately, the FLIP_COMPLETE event depends on that timestamp,
    and the only way to regenerate a valid one is to have vblank
    interrupts enabled and have a valid in-ISR call to
    drm_crtc_handle_vblank.
    
    Additionally, if the user doesn't request vblanks but _does_ request
    FLIP_COMPLETE events, we still don't have a good timestamp: it'll be the
    same stamp as the last vblank one.
    
    Work around the issue by always enabling vblanks when the CRTC is on.
    Reducing the amount of time that PL0 has to be unmasked would be nice to
    fix at a later time.
    
    Changes since v1 [https://patchwork.freedesktop.org/patch/331727/]:
     - moved drm_crtc_vblank_put call to the ->atomic_disable() hook
    
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Ayan kumar halder <ayan.halder@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191001142121.13939-1-mihail.atanassov@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 9ca5dbfd0723..75263d8cd0bd 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -249,6 +249,7 @@ komeda_crtc_atomic_enable(struct drm_crtc *crtc,
 {
 	komeda_crtc_prepare(to_kcrtc(crtc));
 	drm_crtc_vblank_on(crtc);
+	WARN_ON(drm_crtc_vblank_get(crtc));
 	komeda_crtc_do_flush(crtc, old);
 }
 
@@ -341,6 +342,7 @@ komeda_crtc_atomic_disable(struct drm_crtc *crtc,
 		komeda_crtc_flush_and_wait_for_flip_done(kcrtc, disable_done);
 	}
 
+	drm_crtc_vblank_put(crtc);
 	drm_crtc_vblank_off(crtc);
 	komeda_crtc_unprepare(kcrtc);
 }

commit d6cb013579e743bc7bc5590ca35a1943f2b8f3c8
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Fri Sep 6 07:18:06 2019 +0000

    drm/komeda: SW workaround for D71 doesn't flush shadow registers
    
    This is a SW workaround for shadow un-flushed when together with the
    DOU Timing-disable.
    
    D71 HW doesn't update shadow registers when display output is turned
    off. So when we disable all pipeline components together with display
    output disabling by one flush or one operation, the disable operation
    updated registers will not be flushed or valid in HW, which may lead
    problem. To workaround this problem, introduce a two phase disable for
    pipeline disable.
    
    Phase1: Disable components with display is on and flush it, this phase
            for flushing or validating the shadow registers.
    Phase2: Turn-off display output.
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190906071750.4563-1-lowry.li@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 4f66b0e205eb..9ca5dbfd0723 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -252,20 +252,53 @@ komeda_crtc_atomic_enable(struct drm_crtc *crtc,
 	komeda_crtc_do_flush(crtc, old);
 }
 
+static void
+komeda_crtc_flush_and_wait_for_flip_done(struct komeda_crtc *kcrtc,
+					 struct completion *input_flip_done)
+{
+	struct drm_device *drm = kcrtc->base.dev;
+	struct komeda_dev *mdev = kcrtc->master->mdev;
+	struct completion *flip_done;
+	struct completion temp;
+	int timeout;
+
+	/* if caller doesn't send a flip_done, use a private flip_done */
+	if (input_flip_done) {
+		flip_done = input_flip_done;
+	} else {
+		init_completion(&temp);
+		kcrtc->disable_done = &temp;
+		flip_done = &temp;
+	}
+
+	mdev->funcs->flush(mdev, kcrtc->master->id, 0);
+
+	/* wait the flip take affect.*/
+	timeout = wait_for_completion_timeout(flip_done, HZ);
+	if (timeout == 0) {
+		DRM_ERROR("wait pipe%d flip done timeout\n", kcrtc->master->id);
+		if (!input_flip_done) {
+			unsigned long flags;
+
+			spin_lock_irqsave(&drm->event_lock, flags);
+			kcrtc->disable_done = NULL;
+			spin_unlock_irqrestore(&drm->event_lock, flags);
+		}
+	}
+}
+
 static void
 komeda_crtc_atomic_disable(struct drm_crtc *crtc,
 			   struct drm_crtc_state *old)
 {
 	struct komeda_crtc *kcrtc = to_kcrtc(crtc);
 	struct komeda_crtc_state *old_st = to_kcrtc_st(old);
-	struct komeda_dev *mdev = crtc->dev->dev_private;
 	struct komeda_pipeline *master = kcrtc->master;
 	struct komeda_pipeline *slave  = kcrtc->slave;
 	struct completion *disable_done = &crtc->state->commit->flip_done;
-	struct completion temp;
-	int timeout;
+	bool needs_phase2 = false;
 
-	DRM_DEBUG_ATOMIC("CRTC%d_DISABLE: active_pipes: 0x%x, affected: 0x%x.\n",
+	DRM_DEBUG_ATOMIC("CRTC%d_DISABLE: active_pipes: 0x%x, affected: 0x%x\n",
 			 drm_crtc_index(crtc),
 			 old_st->active_pipes, old_st->affected_pipes);
 
@@ -273,7 +306,7 @@ komeda_crtc_atomic_disable(struct drm_crtc *crtc,
 		komeda_pipeline_disable(slave, old->state);
 
 	if (has_bit(master->id, old_st->active_pipes))
-		komeda_pipeline_disable(master, old->state);
+		needs_phase2 = komeda_pipeline_disable(master, old->state);
 
 	/* crtc_disable has two scenarios according to the state->active switch.
 	 * 1. active -> inactive
@@ -292,30 +325,20 @@ komeda_crtc_atomic_disable(struct drm_crtc *crtc,
 	 *    That's also the reason why skip modeset commit in
 	 *    komeda_crtc_atomic_flush()
 	 */
-	if (crtc->state->active) {
-		struct komeda_pipeline_state *pipe_st;
-		/* clear the old active_comps to zero */
-		pipe_st = komeda_pipeline_get_old_state(master, old->state);
-		pipe_st->active_comps = 0;
+	disable_done = (needs_phase2 || crtc->state->active) ?
+		       NULL : &crtc->state->commit->flip_done;
 
-		init_completion(&temp);
-		kcrtc->disable_done = &temp;
-		disable_done = &temp;
-	}
+	/* wait phase 1 disable done */
+	komeda_crtc_flush_and_wait_for_flip_done(kcrtc, disable_done);
 
-	mdev->funcs->flush(mdev, master->id, 0);
+	/* phase 2 */
+	if (needs_phase2) {
+		komeda_pipeline_disable(kcrtc->master, old->state);
 
-	/* wait the disable take affect.*/
-	timeout = wait_for_completion_timeout(disable_done, HZ);
-	if (timeout == 0) {
-		DRM_ERROR("disable pipeline%d timeout.\n", kcrtc->master->id);
-		if (crtc->state->active) {
-			unsigned long flags;
+		disable_done = crtc->state->active ?
+			       NULL : &crtc->state->commit->flip_done;
 
-			spin_lock_irqsave(&crtc->dev->event_lock, flags);
-			kcrtc->disable_done = NULL;
-			spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
-		}
+		komeda_crtc_flush_and_wait_for_flip_done(kcrtc, disable_done);
 	}
 
 	drm_crtc_vblank_off(crtc);

commit 2ebb6701654e0d625eac6c32832d72f8e875c01a
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Mon Sep 23 01:59:25 2019 +0000

    drm/komeda: Adds power management support
    
    Adds system power management support in KMS kernel driver.
    
    Depends on:
    https://patchwork.freedesktop.org/series/62377/
    
    Changes since v1:
    Since we have unified mclk/pclk/pipeline->aclk to one mclk, which will
    be turned on/off when crtc atomic enable/disable, removed runtime power
    management.
    Removes run time get/put related flow.
    Adds to disable the aclk when register access finished.
    
    Changes since v2:
    Rebases to the drm-misc-next branch.
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190923015908.26627-1-lowry.li@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 624d257da20f..4f66b0e205eb 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -5,7 +5,6 @@
  *
  */
 #include <linux/clk.h>
-#include <linux/pm_runtime.h>
 #include <linux/spinlock.h>
 
 #include <drm/drm_atomic.h>

commit c550b60c647941b581e4b0f4f2b1526b34f4a8e5
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Sun Aug 11 19:08:01 2019 -0500

    drm/komeda: Fix potential integer overflow in komeda_crtc_update_clock_ratio
    
    Add suffix ULL to constant 1000 in order to avoid a potential integer
    overflow and give the compiler complete information about the proper
    arithmetic to use. Notice that this constant is being used in a context
    that expects an expression of type u64, but it's currently evaluated
    using 32-bit arithmetic.
    
    Addresses-Coverity-ID: 1485796 ("Unintentional integer overflow")
    Fixes: ed22c6d9304d ("drm/komeda: Use drm_display_mode "crtc_" prefixed hardware timings")
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190812000801.GA29204@embeddedor

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index fa9a4593bb37..624d257da20f 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -27,7 +27,7 @@ static void komeda_crtc_update_clock_ratio(struct komeda_crtc_state *kcrtc_st)
 		return;
 	}
 
-	pxlclk = kcrtc_st->base.adjusted_mode.crtc_clock * 1000;
+	pxlclk = kcrtc_st->base.adjusted_mode.crtc_clock * 1000ULL;
 	aclk = komeda_crtc_get_aclk(kcrtc_st);
 
 	kcrtc_st->clock_ratio = div64_u64(aclk << 32, pxlclk);

commit 8965ad8433eadadc5a41df2915eec4a144e8aed6
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jun 18 09:10:49 2019 +0100

    drm/komeda: Enable dual-link support
    
    Komeda HW can support dual-link which splits display frame to two halves
    (left/link0, right/link1) and output them by two output links.
    Due to the halved pixel rate of each link, the pxlclk of dual-link can be
    reduced two times compare with single-link.
    
    For enabling dual-link:
    - The DT need to configure two output-links for the pipeline node.
    - Komeda enable dual-link when both link0 and link1 have been connected.
    
    Example of how the pipeline node will look like for dual-link setup
    
    pipe0: pipeline@0 {
            clocks = <&fpgaosc2>;
            clock-names = "pxclk";
            reg = <0>;
    
            #address-cells = <1>;
            #size-cells = <0>;
    
            port@0 {
                    reg = <0>;
    
                    #address-cells = <1>;
                    #size-cells = <0>;
                    dp0_pipe0_link0: endpoint@0 {
                            reg = <0>;
                            remote-endpoint = <&dlink_connector_in0>;
    
                    };
                    dp0_pipe0_link1: endpoint@1 {
                            reg = <1>;
                            remote-endpoint = <&dlink_connector_in1>;
                    };
            };
    };
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190618081013.13638-3-james.qian.wang@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index c6a3808614dc..fa9a4593bb37 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -28,7 +28,7 @@ static void komeda_crtc_update_clock_ratio(struct komeda_crtc_state *kcrtc_st)
 	}
 
 	pxlclk = kcrtc_st->base.adjusted_mode.crtc_clock * 1000;
-	aclk = komeda_calc_aclk(kcrtc_st);
+	aclk = komeda_crtc_get_aclk(kcrtc_st);
 
 	kcrtc_st->clock_ratio = div64_u64(aclk << 32, pxlclk);
 }
@@ -74,14 +74,6 @@ komeda_crtc_atomic_check(struct drm_crtc *crtc,
 	return 0;
 }
 
-unsigned long komeda_calc_aclk(struct komeda_crtc_state *kcrtc_st)
-{
-	struct komeda_dev *mdev = kcrtc_st->base.crtc->dev->dev_private;
-	unsigned long aclk = kcrtc_st->base.adjusted_mode.crtc_clock;
-
-	return clk_round_rate(mdev->aclk, aclk * 1000);
-}
-
 /* For active a crtc, mainly need two parts of preparation
  * 1. adjust display operation mode.
  * 2. enable needed clk
@@ -118,7 +110,7 @@ komeda_crtc_prepare(struct komeda_crtc *kcrtc)
 	 * to enable it again.
 	 */
 	if (new_mode != KOMEDA_MODE_DUAL_DISP) {
-		err = clk_set_rate(mdev->aclk, komeda_calc_aclk(kcrtc_st));
+		err = clk_set_rate(mdev->aclk, komeda_crtc_get_aclk(kcrtc_st));
 		if (err)
 			DRM_ERROR("failed to set aclk.\n");
 		err = clk_prepare_enable(mdev->aclk);
@@ -342,29 +334,58 @@ komeda_crtc_atomic_flush(struct drm_crtc *crtc,
 	komeda_crtc_do_flush(crtc, old);
 }
 
+/* Returns the minimum frequency of the aclk rate (main engine clock) in Hz */
+static unsigned long
+komeda_calc_min_aclk_rate(struct komeda_crtc *kcrtc,
+			  unsigned long pxlclk)
+{
+	/* Once dual-link one display pipeline drives two display outputs,
+	 * the aclk needs run on the double rate of pxlclk
+	 */
+	if (kcrtc->master->dual_link)
+		return pxlclk * 2;
+	else
+		return pxlclk;
+}
+
+/* Get current aclk rate that specified by state */
+unsigned long komeda_crtc_get_aclk(struct komeda_crtc_state *kcrtc_st)
+{
+	struct drm_crtc *crtc = kcrtc_st->base.crtc;
+	struct komeda_dev *mdev = crtc->dev->dev_private;
+	unsigned long pxlclk = kcrtc_st->base.adjusted_mode.crtc_clock * 1000;
+	unsigned long min_aclk;
+
+	min_aclk = komeda_calc_min_aclk_rate(to_kcrtc(crtc), pxlclk);
+
+	return clk_round_rate(mdev->aclk, min_aclk);
+}
+
 static enum drm_mode_status
 komeda_crtc_mode_valid(struct drm_crtc *crtc, const struct drm_display_mode *m)
 {
 	struct komeda_dev *mdev = crtc->dev->dev_private;
 	struct komeda_crtc *kcrtc = to_kcrtc(crtc);
 	struct komeda_pipeline *master = kcrtc->master;
-	long mode_clk, pxlclk;
+	unsigned long min_pxlclk, min_aclk;
 
 	if (m->flags & DRM_MODE_FLAG_INTERLACE)
 		return MODE_NO_INTERLACE;
 
-	mode_clk = m->clock * 1000;
-	pxlclk = clk_round_rate(master->pxlclk, mode_clk);
-	if (pxlclk != mode_clk) {
-		DRM_DEBUG_ATOMIC("pxlclk doesn't support %ld Hz\n", mode_clk);
+	min_pxlclk = m->clock * 1000;
+	if (master->dual_link)
+		min_pxlclk /= 2;
+
+	if (min_pxlclk != clk_round_rate(master->pxlclk, min_pxlclk)) {
+		DRM_DEBUG_ATOMIC("pxlclk doesn't support %lu Hz\n", min_pxlclk);
 
 		return MODE_NOCLOCK;
 	}
 
-	/* main engine clock must be faster than pxlclk*/
-	if (clk_round_rate(mdev->aclk, mode_clk) < pxlclk) {
-		DRM_DEBUG_ATOMIC("engine clk can't satisfy the requirement of %s-clk: %ld.\n",
-				 m->name, pxlclk);
+	min_aclk = komeda_calc_min_aclk_rate(to_kcrtc(crtc), min_pxlclk);
+	if (clk_round_rate(mdev->aclk, min_aclk) < min_aclk) {
+		DRM_DEBUG_ATOMIC("engine clk can't satisfy the requirement of %s-clk: %lu.\n",
+				 m->name, min_pxlclk);
 
 		return MODE_CLOCK_HIGH;
 	}
@@ -380,6 +401,14 @@ static bool komeda_crtc_mode_fixup(struct drm_crtc *crtc,
 	unsigned long clk_rate;
 
 	drm_mode_set_crtcinfo(adjusted_mode, 0);
+	/* In dual link half the horizontal settings */
+	if (kcrtc->master->dual_link) {
+		adjusted_mode->crtc_clock /= 2;
+		adjusted_mode->crtc_hdisplay /= 2;
+		adjusted_mode->crtc_hsync_start /= 2;
+		adjusted_mode->crtc_hsync_end /= 2;
+		adjusted_mode->crtc_htotal /= 2;
+	}
 
 	clk_rate = adjusted_mode->crtc_clock * 1000;
 	/* crtc_clock will be used as the komeda output pixel clock */
@@ -492,10 +521,8 @@ int komeda_kms_setup_crtcs(struct komeda_kms_dev *kms,
 		else
 			sprintf(str, "None");
 
-		DRM_INFO("crtc%d: master(pipe-%d) slave(%s) output: %s.\n",
-			 kms->n_crtcs, master->id, str,
-			 master->of_output_dev ?
-			 master->of_output_dev->full_name : "None");
+		DRM_INFO("CRTC-%d: master(pipe-%d) slave(%s).\n",
+			 kms->n_crtcs, master->id, str);
 
 		kms->n_crtcs++;
 	}

commit ed22c6d9304d35fbdfe4818016ae57a9da5df9bc
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jun 18 09:10:40 2019 +0100

    drm/komeda: Use drm_display_mode "crtc_" prefixed hardware timings
    
    struct drm_display_mode contains two copies of timings.
    - plain timings.
    - hardware timings, the ones with "crtc_" prefix.
    According to the definition, update komeda to use the hardware timing.
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190618081013.13638-2-james.qian.wang@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index f4400788ab94..c6a3808614dc 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -27,7 +27,7 @@ static void komeda_crtc_update_clock_ratio(struct komeda_crtc_state *kcrtc_st)
 		return;
 	}
 
-	pxlclk = kcrtc_st->base.adjusted_mode.clock * 1000;
+	pxlclk = kcrtc_st->base.adjusted_mode.crtc_clock * 1000;
 	aclk = komeda_calc_aclk(kcrtc_st);
 
 	kcrtc_st->clock_ratio = div64_u64(aclk << 32, pxlclk);
@@ -77,9 +77,9 @@ komeda_crtc_atomic_check(struct drm_crtc *crtc,
 unsigned long komeda_calc_aclk(struct komeda_crtc_state *kcrtc_st)
 {
 	struct komeda_dev *mdev = kcrtc_st->base.crtc->dev->dev_private;
-	unsigned long pxlclk = kcrtc_st->base.adjusted_mode.clock;
+	unsigned long aclk = kcrtc_st->base.adjusted_mode.crtc_clock;
 
-	return clk_round_rate(mdev->aclk, pxlclk * 1000);
+	return clk_round_rate(mdev->aclk, aclk * 1000);
 }
 
 /* For active a crtc, mainly need two parts of preparation
@@ -92,7 +92,7 @@ komeda_crtc_prepare(struct komeda_crtc *kcrtc)
 	struct komeda_dev *mdev = kcrtc->base.dev->dev_private;
 	struct komeda_pipeline *master = kcrtc->master;
 	struct komeda_crtc_state *kcrtc_st = to_kcrtc_st(kcrtc->base.state);
-	unsigned long pxlclk_rate = kcrtc_st->base.adjusted_mode.clock * 1000;
+	struct drm_display_mode *mode = &kcrtc_st->base.adjusted_mode;
 	u32 new_mode;
 	int err;
 
@@ -126,7 +126,7 @@ komeda_crtc_prepare(struct komeda_crtc *kcrtc)
 			DRM_ERROR("failed to enable aclk.\n");
 	}
 
-	err = clk_set_rate(master->pxlclk, pxlclk_rate);
+	err = clk_set_rate(master->pxlclk, mode->crtc_clock * 1000);
 	if (err)
 		DRM_ERROR("failed to set pxlclk for pipe%d\n", master->id);
 	err = clk_prepare_enable(master->pxlclk);
@@ -377,10 +377,14 @@ static bool komeda_crtc_mode_fixup(struct drm_crtc *crtc,
 				   struct drm_display_mode *adjusted_mode)
 {
 	struct komeda_crtc *kcrtc = to_kcrtc(crtc);
-	struct komeda_pipeline *master = kcrtc->master;
-	long mode_clk = m->clock * 1000;
+	unsigned long clk_rate;
+
+	drm_mode_set_crtcinfo(adjusted_mode, 0);
 
-	adjusted_mode->clock = clk_round_rate(master->pxlclk, mode_clk) / 1000;
+	clk_rate = adjusted_mode->crtc_clock * 1000;
+	/* crtc_clock will be used as the komeda output pixel clock */
+	adjusted_mode->crtc_clock = clk_round_rate(kcrtc->master->pxlclk,
+						   clk_rate) / 1000;
 
 	return true;
 }

commit 8aa0625f48559861b17606cf73fb24bd9f479303
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 5 14:10:03 2019 +0200

    drm/komeda: remove slave_planes property
    
    Properties are uapi like anything else, with all the usual rules
    regarding review, testcases, open source userspace ... Furthermore
    driver-private kms properties are highly discouraged, over the past
    few years we've realized we need to make a serious effort at better
    standardizing this stuff.
    
    Again this probably needs multiple pieces to solve this properly:
    
    - To make plane configuration less surprising to userspace you
      propably need to virtualize planes, and reorder which logical plane
      you map to which physical one dynamically. Instead of exposing a
      komeda-specific limitation to userspace and expecting them to dtrt.
      I think msm and rcar-du do that already (and others), if you need
      people to chat with or example code.
    
    - If this is needed for validation, again ->atomic_print_state and the
      infrastructure around that is your friend.
    
    Fixes: 3b9dfa4ef28c ("drm/komeda: Add slave pipeline support")
    Cc: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Cc: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Mali DP Maintainers <malidp@foss.arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190705121006.26085-2-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index e852dc27f1b8..f4400788ab94 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -499,26 +499,6 @@ int komeda_kms_setup_crtcs(struct komeda_kms_dev *kms,
 	return 0;
 }
 
-static int komeda_crtc_create_slave_planes_property(struct komeda_crtc *kcrtc)
-{
-	struct drm_crtc *crtc = &kcrtc->base;
-	struct drm_property *prop;
-
-	if (kcrtc->slave_planes == 0)
-		return 0;
-
-	prop = drm_property_create_range(crtc->dev, DRM_MODE_PROP_IMMUTABLE,
-					 "slave_planes", 0, U32_MAX);
-	if (!prop)
-		return -ENOMEM;
-
-	drm_object_attach_property(&crtc->base, prop, kcrtc->slave_planes);
-
-	kcrtc->slave_planes_property = prop;
-
-	return 0;
-}
-
 static struct drm_plane *
 get_crtc_primary(struct komeda_kms_dev *kms, struct komeda_crtc *crtc)
 {
@@ -555,10 +535,6 @@ static int komeda_crtc_add(struct komeda_kms_dev *kms,
 
 	crtc->port = kcrtc->master->of_output_port;
 
-	err = komeda_crtc_create_slave_planes_property(kcrtc);
-	if (err)
-		return err;
-
 	return err;
 }
 

commit 505f6cff880e33a9725bc8337bcb2941c6dd43a6
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 5 14:10:02 2019 +0200

    drm/komeda: Remove clock ratio property
    
    Properties are uapi like anything else, with all the usual rules
    regarding review, testcases, open source userspace ... Furthermore
    driver-private kms properties are highly discouraged, over the past
    few years we've realized we need to make a serious effort at better
    standardizing this stuff.
    
    From the discussion with Liviu the solution for these here needs
    multiple pieces:
    
    - For being able to reliably read the memory clock we need a DT
      property, plus maybe DT override snippets to fix it if it's wrong.
    
    - For exposing plane limitations to userspace there's TEST_ONLY. There
      is a bit a gap in telling userspace better that scaling doesn't work
      due to limits (atm a good strategy is to retry again without scaling
      when adding a plane didn't work the first time around). But that
      needs a more generic solution, not exposing something extremely
      komeda specific.
    
    - If this is needed by validation tools, you can still expose it in
      debugfs. We have an entire nice infrastructure for debug printing of
      kms objects already, see the various atomic_print_state callbacks
      and infrastructure around them.
    
    Fixes: 1f7f9ab7900e ("drm/komeda: Add engine clock requirement check for the downscaling")
    Cc: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Cc: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Mali DP Maintainers <malidp@foss.arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190705121006.26085-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 3f222f464eb2..e852dc27f1b8 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -454,24 +454,6 @@ static void komeda_crtc_vblank_disable(struct drm_crtc *crtc)
 	mdev->funcs->on_off_vblank(mdev, kcrtc->master->id, false);
 }
 
-static int
-komeda_crtc_atomic_get_property(struct drm_crtc *crtc,
-				const struct drm_crtc_state *state,
-				struct drm_property *property, uint64_t *val)
-{
-	struct komeda_crtc *kcrtc = to_kcrtc(crtc);
-	struct komeda_crtc_state *kcrtc_st = to_kcrtc_st(state);
-
-	if (property == kcrtc->clock_ratio_property) {
-		*val = kcrtc_st->clock_ratio;
-	} else {
-		DRM_DEBUG_DRIVER("Unknown property %s\n", property->name);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
 static const struct drm_crtc_funcs komeda_crtc_funcs = {
 	.gamma_set		= drm_atomic_helper_legacy_gamma_set,
 	.destroy		= drm_crtc_cleanup,
@@ -482,7 +464,6 @@ static const struct drm_crtc_funcs komeda_crtc_funcs = {
 	.atomic_destroy_state	= komeda_crtc_atomic_destroy_state,
 	.enable_vblank		= komeda_crtc_vblank_enable,
 	.disable_vblank		= komeda_crtc_vblank_disable,
-	.atomic_get_property	= komeda_crtc_atomic_get_property,
 };
 
 int komeda_kms_setup_crtcs(struct komeda_kms_dev *kms,
@@ -518,22 +499,6 @@ int komeda_kms_setup_crtcs(struct komeda_kms_dev *kms,
 	return 0;
 }
 
-static int komeda_crtc_create_clock_ratio_property(struct komeda_crtc *kcrtc)
-{
-	struct drm_crtc *crtc = &kcrtc->base;
-	struct drm_property *prop;
-
-	prop = drm_property_create_range(crtc->dev, DRM_MODE_PROP_ATOMIC,
-					 "CLOCK_RATIO", 0, U64_MAX);
-	if (!prop)
-		return -ENOMEM;
-
-	drm_object_attach_property(&crtc->base, prop, 0);
-	kcrtc->clock_ratio_property = prop;
-
-	return 0;
-}
-
 static int komeda_crtc_create_slave_planes_property(struct komeda_crtc *kcrtc)
 {
 	struct drm_crtc *crtc = &kcrtc->base;
@@ -590,10 +555,6 @@ static int komeda_crtc_add(struct komeda_kms_dev *kms,
 
 	crtc->port = kcrtc->master->of_output_port;
 
-	err = komeda_crtc_create_clock_ratio_property(kcrtc);
-	if (err)
-		return err;
-
 	err = komeda_crtc_create_slave_planes_property(kcrtc);
 	if (err)
 		return err;

commit 0b044a999e86ed1aa8791f8bd11a6d7083b33438
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 17 14:51:04 2019 +0200

    drm/komeda: fix 32-bit komeda_crtc_update_clock_ratio
    
    clang points out a bug in the clock calculation on 32-bit, that leads
    to the clock_ratio always being zero:
    
    drivers/gpu/drm/arm/display/komeda/komeda_crtc.c:31:36: error: shift count >= width of type [-Werror,-Wshift-count-overflow]
            aclk = komeda_calc_aclk(kcrtc_st) << 32;
    
    Move the shift into the division to make it apply on a 64-bit
    variable. Also use the more expensive div64_u64() instead of div_u64()
    to account for pxlclk being a 64-bit integer.
    
    Fixes: 1f7f9ab7900e ("drm/komeda: Add engine clock requirement check for the downscaling")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index cafb4457e187..3f222f464eb2 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -28,10 +28,9 @@ static void komeda_crtc_update_clock_ratio(struct komeda_crtc_state *kcrtc_st)
 	}
 
 	pxlclk = kcrtc_st->base.adjusted_mode.clock * 1000;
-	aclk = komeda_calc_aclk(kcrtc_st) << 32;
+	aclk = komeda_calc_aclk(kcrtc_st);
 
-	do_div(aclk, pxlclk);
-	kcrtc_st->clock_ratio = aclk;
+	kcrtc_st->clock_ratio = div64_u64(aclk << 32, pxlclk);
 }
 
 /**

commit 3b9dfa4ef28c7dfb847cd3f8f97e7b92686c3e76
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Tue Jun 11 12:13:39 2019 +0100

    drm/komeda: Add slave pipeline support
    
    One crtc can use two komeda_pipeline, and one works as master and as
    slave. the slave pipeline doesn't have its own output and timing
    ctrlr, but pre-composite the input layer data flow and then feed the
    result to master. the pipeline configuration like:
    
    slave-layer-0 \
    ...            slave->CU
    slave-layer-4 /         \
                            \
    master-layer-0 --------> master->CU -> ...
     ...                  /
    master-layer-4 ------>
    
    Since komeda Compiz doesn't output alpha, so the slave->CU result
    only can be used as bottom input when blend it with master input data
    flows.
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index a2d656fe3147..cafb4457e187 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -64,6 +64,10 @@ komeda_crtc_atomic_check(struct drm_crtc *crtc,
 	}
 
 	/* release unclaimed pipeline resources */
+	err = komeda_release_unclaimed_resources(kcrtc->slave, kcrtc_st);
+	if (err)
+		return err;
+
 	err = komeda_release_unclaimed_resources(kcrtc->master, kcrtc_st);
 	if (err)
 		return err;
@@ -226,6 +230,7 @@ komeda_crtc_do_flush(struct drm_crtc *crtc,
 	struct komeda_crtc_state *kcrtc_st = to_kcrtc_st(crtc->state);
 	struct komeda_dev *mdev = kcrtc->base.dev->dev_private;
 	struct komeda_pipeline *master = kcrtc->master;
+	struct komeda_pipeline *slave = kcrtc->slave;
 	struct komeda_wb_connector *wb_conn = kcrtc->wb_conn;
 	struct drm_connector_state *conn_st;
 
@@ -237,6 +242,9 @@ komeda_crtc_do_flush(struct drm_crtc *crtc,
 	if (has_bit(master->id, kcrtc_st->affected_pipes))
 		komeda_pipeline_update(master, old->state);
 
+	if (slave && has_bit(slave->id, kcrtc_st->affected_pipes))
+		komeda_pipeline_update(slave, old->state);
+
 	conn_st = wb_conn ? wb_conn->base.base.state : NULL;
 	if (conn_st && conn_st->writeback_job)
 		drm_writeback_queue_job(&wb_conn->base, conn_st);
@@ -262,6 +270,7 @@ komeda_crtc_atomic_disable(struct drm_crtc *crtc,
 	struct komeda_crtc_state *old_st = to_kcrtc_st(old);
 	struct komeda_dev *mdev = crtc->dev->dev_private;
 	struct komeda_pipeline *master = kcrtc->master;
+	struct komeda_pipeline *slave  = kcrtc->slave;
 	struct completion *disable_done = &crtc->state->commit->flip_done;
 	struct completion temp;
 	int timeout;
@@ -270,6 +279,9 @@ komeda_crtc_atomic_disable(struct drm_crtc *crtc,
 			 drm_crtc_index(crtc),
 			 old_st->active_pipes, old_st->affected_pipes);
 
+	if (slave && has_bit(slave->id, old_st->active_pipes))
+		komeda_pipeline_disable(slave, old->state);
+
 	if (has_bit(master->id, old_st->active_pipes))
 		komeda_pipeline_disable(master, old->state);
 
@@ -414,6 +426,7 @@ komeda_crtc_atomic_duplicate_state(struct drm_crtc *crtc)
 
 	new->affected_pipes = old->active_pipes;
 	new->clock_ratio = old->clock_ratio;
+	new->max_slave_zorder = old->max_slave_zorder;
 
 	return &new->base;
 }
@@ -488,7 +501,7 @@ int komeda_kms_setup_crtcs(struct komeda_kms_dev *kms,
 		master = mdev->pipelines[i];
 
 		crtc->master = master;
-		crtc->slave  = NULL;
+		crtc->slave  = komeda_pipeline_get_slave(master);
 
 		if (crtc->slave)
 			sprintf(str, "pipe-%d", crtc->slave->id);
@@ -522,6 +535,26 @@ static int komeda_crtc_create_clock_ratio_property(struct komeda_crtc *kcrtc)
 	return 0;
 }
 
+static int komeda_crtc_create_slave_planes_property(struct komeda_crtc *kcrtc)
+{
+	struct drm_crtc *crtc = &kcrtc->base;
+	struct drm_property *prop;
+
+	if (kcrtc->slave_planes == 0)
+		return 0;
+
+	prop = drm_property_create_range(crtc->dev, DRM_MODE_PROP_IMMUTABLE,
+					 "slave_planes", 0, U32_MAX);
+	if (!prop)
+		return -ENOMEM;
+
+	drm_object_attach_property(&crtc->base, prop, kcrtc->slave_planes);
+
+	kcrtc->slave_planes_property = prop;
+
+	return 0;
+}
+
 static struct drm_plane *
 get_crtc_primary(struct komeda_kms_dev *kms, struct komeda_crtc *crtc)
 {
@@ -562,7 +595,11 @@ static int komeda_crtc_add(struct komeda_kms_dev *kms,
 	if (err)
 		return err;
 
-	return 0;
+	err = komeda_crtc_create_slave_planes_property(kcrtc);
+	if (err)
+		return err;
+
+	return err;
 }
 
 int komeda_kms_add_crtcs(struct komeda_kms_dev *kms, struct komeda_dev *mdev)

commit 6f84da0c74f12f9dbcc612cced6b1fa07965415d
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Wed Jun 5 11:35:39 2019 +0100

    drm/komeda: Rename main engine clk name "mclk" to "aclk"
    
    To avoid confusion, unify the driver main engine clk name "mclk" to
    the spec name "aclk".
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 04bdd7eb443c..a2d656fe3147 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -20,7 +20,7 @@
 
 static void komeda_crtc_update_clock_ratio(struct komeda_crtc_state *kcrtc_st)
 {
-	u64 pxlclk, mclk;
+	u64 pxlclk, aclk;
 
 	if (!kcrtc_st->base.active) {
 		kcrtc_st->clock_ratio = 0;
@@ -28,10 +28,10 @@ static void komeda_crtc_update_clock_ratio(struct komeda_crtc_state *kcrtc_st)
 	}
 
 	pxlclk = kcrtc_st->base.adjusted_mode.clock * 1000;
-	mclk = komeda_calc_mclk(kcrtc_st) << 32;
+	aclk = komeda_calc_aclk(kcrtc_st) << 32;
 
-	do_div(mclk, pxlclk);
-	kcrtc_st->clock_ratio = mclk;
+	do_div(aclk, pxlclk);
+	kcrtc_st->clock_ratio = aclk;
 }
 
 /**
@@ -71,12 +71,12 @@ komeda_crtc_atomic_check(struct drm_crtc *crtc,
 	return 0;
 }
 
-unsigned long komeda_calc_mclk(struct komeda_crtc_state *kcrtc_st)
+unsigned long komeda_calc_aclk(struct komeda_crtc_state *kcrtc_st)
 {
 	struct komeda_dev *mdev = kcrtc_st->base.crtc->dev->dev_private;
 	unsigned long pxlclk = kcrtc_st->base.adjusted_mode.clock;
 
-	return clk_round_rate(mdev->mclk, pxlclk * 1000);
+	return clk_round_rate(mdev->aclk, pxlclk * 1000);
 }
 
 /* For active a crtc, mainly need two parts of preparation
@@ -109,18 +109,18 @@ komeda_crtc_prepare(struct komeda_crtc *kcrtc)
 	}
 
 	mdev->dpmode = new_mode;
-	/* Only need to enable mclk on single display mode, but no need to
-	 * enable mclk it on dual display mode, since the dual mode always
-	 * switch from single display mode, the mclk already enabled, no need
+	/* Only need to enable aclk on single display mode, but no need to
+	 * enable aclk it on dual display mode, since the dual mode always
+	 * switch from single display mode, the aclk already enabled, no need
 	 * to enable it again.
 	 */
 	if (new_mode != KOMEDA_MODE_DUAL_DISP) {
-		err = clk_set_rate(mdev->mclk, komeda_calc_mclk(kcrtc_st));
+		err = clk_set_rate(mdev->aclk, komeda_calc_aclk(kcrtc_st));
 		if (err)
-			DRM_ERROR("failed to set mclk.\n");
-		err = clk_prepare_enable(mdev->mclk);
+			DRM_ERROR("failed to set aclk.\n");
+		err = clk_prepare_enable(mdev->aclk);
 		if (err)
-			DRM_ERROR("failed to enable mclk.\n");
+			DRM_ERROR("failed to enable aclk.\n");
 	}
 
 	err = clk_set_rate(master->pxlclk, pxlclk_rate);
@@ -164,7 +164,7 @@ komeda_crtc_unprepare(struct komeda_crtc *kcrtc)
 
 	clk_disable_unprepare(master->pxlclk);
 	if (new_mode == KOMEDA_MODE_INACTIVE)
-		clk_disable_unprepare(mdev->mclk);
+		clk_disable_unprepare(mdev->aclk);
 
 unlock:
 	mutex_unlock(&mdev->lock);
@@ -342,7 +342,6 @@ komeda_crtc_mode_valid(struct drm_crtc *crtc, const struct drm_display_mode *m)
 	if (m->flags & DRM_MODE_FLAG_INTERLACE)
 		return MODE_NO_INTERLACE;
 
-	/* main clock/AXI clk must be faster than pxlclk*/
 	mode_clk = m->clock * 1000;
 	pxlclk = clk_round_rate(master->pxlclk, mode_clk);
 	if (pxlclk != mode_clk) {
@@ -351,8 +350,9 @@ komeda_crtc_mode_valid(struct drm_crtc *crtc, const struct drm_display_mode *m)
 		return MODE_NOCLOCK;
 	}
 
-	if (clk_round_rate(mdev->mclk, mode_clk) < pxlclk) {
-		DRM_DEBUG_ATOMIC("mclk can't satisfy the requirement of %s-clk: %ld.\n",
+	/* main engine clock must be faster than pxlclk*/
+	if (clk_round_rate(mdev->aclk, mode_clk) < pxlclk) {
+		DRM_DEBUG_ATOMIC("engine clk can't satisfy the requirement of %s-clk: %ld.\n",
 				 m->name, pxlclk);
 
 		return MODE_CLOCK_HIGH;

commit 28be315c9c0c0b8d1093fcddf3245398108b83fd
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Wed Jun 5 11:35:32 2019 +0100

    drm/komeda: Unify mclk/pclk/pipeline->aclk to one MCLK
    
    Current komeda driver uses three dedicated clks for a specific purpose:
    - mclk: main engine clock
    - pclk: APB clock
    - pipeline->aclk: AXI clock.
    
    But per spec the komeda HW only has three input clks:
    - ACLK: used for AXI masters, APB slave and most pipeline processing
    - PXCLK for pipeline 0: output pixel clock for pipeline 0
    - PXCLK for pipeline 1: output pixel clock for pipeline 1
    
    So one ACLK is enough, no need to split it to three mclk/pclk/axiclk.
    drop pclk/pipeline->axiclk. but only keep one mclk in komeda driver.
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 24a961356cb3..04bdd7eb443c 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -123,9 +123,6 @@ komeda_crtc_prepare(struct komeda_crtc *kcrtc)
 			DRM_ERROR("failed to enable mclk.\n");
 	}
 
-	err = clk_prepare_enable(master->aclk);
-	if (err)
-		DRM_ERROR("failed to enable axi clk for pipe%d.\n", master->id);
 	err = clk_set_rate(master->pxlclk, pxlclk_rate);
 	if (err)
 		DRM_ERROR("failed to set pxlclk for pipe%d\n", master->id);
@@ -166,7 +163,6 @@ komeda_crtc_unprepare(struct komeda_crtc *kcrtc)
 	mdev->dpmode = new_mode;
 
 	clk_disable_unprepare(master->pxlclk);
-	clk_disable_unprepare(master->aclk);
 	if (new_mode == KOMEDA_MODE_INACTIVE)
 		clk_disable_unprepare(mdev->mclk);
 
@@ -362,13 +358,6 @@ komeda_crtc_mode_valid(struct drm_crtc *crtc, const struct drm_display_mode *m)
 		return MODE_CLOCK_HIGH;
 	}
 
-	if (clk_round_rate(master->aclk, mode_clk) < pxlclk) {
-		DRM_DEBUG_ATOMIC("aclk can't satisfy the requirement of %s-clk: %ld.\n",
-				 m->name, pxlclk);
-
-		return MODE_CLOCK_HIGH;
-	}
-
 	return MODE_OK;
 }
 

commit 1f7f9ab7900ec92c0beac0660cdce37d6af02d38
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu May 23 12:10:21 2019 +0100

    drm/komeda: Add engine clock requirement check for the downscaling
    
    For downscaling there is a restriction, the downscaling needed engine
    clock can not acceed the real engine clock, and the clock requirement
    mostly depend on the specific HW, to solve this problem:
    1. Add a pipeline func - downscaling_clk_check for CORE to query the real
       HW if downscaling can be supported.
    2. Add new property clock ratio which is the ratio of:
         (mclk << 32) / pxlclk
       then User driver can use this ratio to do the clock check to avoid post
       an invalid downscaling to kernel.
    
    v2: Rebase and Delete debug print
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 6712603b8c7a..24a961356cb3 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -18,6 +18,22 @@
 #include "komeda_dev.h"
 #include "komeda_kms.h"
 
+static void komeda_crtc_update_clock_ratio(struct komeda_crtc_state *kcrtc_st)
+{
+	u64 pxlclk, mclk;
+
+	if (!kcrtc_st->base.active) {
+		kcrtc_st->clock_ratio = 0;
+		return;
+	}
+
+	pxlclk = kcrtc_st->base.adjusted_mode.clock * 1000;
+	mclk = komeda_calc_mclk(kcrtc_st) << 32;
+
+	do_div(mclk, pxlclk);
+	kcrtc_st->clock_ratio = mclk;
+}
+
 /**
  * komeda_crtc_atomic_check - build display output data flow
  * @crtc: DRM crtc
@@ -38,6 +54,9 @@ komeda_crtc_atomic_check(struct drm_crtc *crtc,
 	struct komeda_crtc_state *kcrtc_st = to_kcrtc_st(state);
 	int err;
 
+	if (drm_atomic_crtc_needs_modeset(state))
+		komeda_crtc_update_clock_ratio(kcrtc_st);
+
 	if (state->active) {
 		err = komeda_build_display_data_flow(kcrtc, kcrtc_st);
 		if (err)
@@ -52,11 +71,12 @@ komeda_crtc_atomic_check(struct drm_crtc *crtc,
 	return 0;
 }
 
-static u32 komeda_calc_mclk(struct komeda_crtc_state *kcrtc_st)
+unsigned long komeda_calc_mclk(struct komeda_crtc_state *kcrtc_st)
 {
-	unsigned long mclk = kcrtc_st->base.adjusted_mode.clock * 1000;
+	struct komeda_dev *mdev = kcrtc_st->base.crtc->dev->dev_private;
+	unsigned long pxlclk = kcrtc_st->base.adjusted_mode.clock;
 
-	return mclk;
+	return clk_round_rate(mdev->mclk, pxlclk * 1000);
 }
 
 /* For active a crtc, mainly need two parts of preparation
@@ -404,6 +424,7 @@ komeda_crtc_atomic_duplicate_state(struct drm_crtc *crtc)
 	__drm_atomic_helper_crtc_duplicate_state(crtc, &new->base);
 
 	new->affected_pipes = old->active_pipes;
+	new->clock_ratio = old->clock_ratio;
 
 	return &new->base;
 }
@@ -432,6 +453,24 @@ static void komeda_crtc_vblank_disable(struct drm_crtc *crtc)
 	mdev->funcs->on_off_vblank(mdev, kcrtc->master->id, false);
 }
 
+static int
+komeda_crtc_atomic_get_property(struct drm_crtc *crtc,
+				const struct drm_crtc_state *state,
+				struct drm_property *property, uint64_t *val)
+{
+	struct komeda_crtc *kcrtc = to_kcrtc(crtc);
+	struct komeda_crtc_state *kcrtc_st = to_kcrtc_st(state);
+
+	if (property == kcrtc->clock_ratio_property) {
+		*val = kcrtc_st->clock_ratio;
+	} else {
+		DRM_DEBUG_DRIVER("Unknown property %s\n", property->name);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static const struct drm_crtc_funcs komeda_crtc_funcs = {
 	.gamma_set		= drm_atomic_helper_legacy_gamma_set,
 	.destroy		= drm_crtc_cleanup,
@@ -442,6 +481,7 @@ static const struct drm_crtc_funcs komeda_crtc_funcs = {
 	.atomic_destroy_state	= komeda_crtc_atomic_destroy_state,
 	.enable_vblank		= komeda_crtc_vblank_enable,
 	.disable_vblank		= komeda_crtc_vblank_disable,
+	.atomic_get_property	= komeda_crtc_atomic_get_property,
 };
 
 int komeda_kms_setup_crtcs(struct komeda_kms_dev *kms,
@@ -477,6 +517,22 @@ int komeda_kms_setup_crtcs(struct komeda_kms_dev *kms,
 	return 0;
 }
 
+static int komeda_crtc_create_clock_ratio_property(struct komeda_crtc *kcrtc)
+{
+	struct drm_crtc *crtc = &kcrtc->base;
+	struct drm_property *prop;
+
+	prop = drm_property_create_range(crtc->dev, DRM_MODE_PROP_ATOMIC,
+					 "CLOCK_RATIO", 0, U64_MAX);
+	if (!prop)
+		return -ENOMEM;
+
+	drm_object_attach_property(&crtc->base, prop, 0);
+	kcrtc->clock_ratio_property = prop;
+
+	return 0;
+}
+
 static struct drm_plane *
 get_crtc_primary(struct komeda_kms_dev *kms, struct komeda_crtc *crtc)
 {
@@ -513,6 +569,10 @@ static int komeda_crtc_add(struct komeda_kms_dev *kms,
 
 	crtc->port = kcrtc->master->of_output_port;
 
+	err = komeda_crtc_create_clock_ratio_property(kcrtc);
+	if (err)
+		return err;
+
 	return 0;
 }
 

commit 5d51f6c0da1b563e2f8eb5022a4d7748aa687be4
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu May 23 10:36:38 2019 +0100

    drm/komeda: Add writeback support
    
    Komeda driver uses a individual component to describe the HW's writeback
    caps, but drivers doesn't define a new structure and still uses the
    existing "struct komeda_layer" to describe this new component.
    The detailed changes as follow:
    
    1. Initialize wb_layer according to HW and report it to CORE.
    2. CORE exposes wb_layer as a resource to KMS by private_obj.
    3. Report writeback supporting by add a wb_connector to KMS, and then
       wb_connector will take act as a component resources user,
       so the func komeda_wb_encoder_atomic_check claims komeda resources
       (scaler and wb_layer) accroding to its state configuration to the
       wb_connector. and the wb_state configuration will be validated on the
       specific component resources to see if the caps of component can
       meet the requirement of wb_connector. if not check failed.
    4. Update irq_handler to notify the completion of writeback.
    
    NOTE:
    This change doesn't add scaling writeback support, that support will
    be added in the future after the scaler support.
    
    v2: Rebase
    v3: Rebase and constify the d71_wb_layer_funcs
    v4: Addressed Ayan's comments
    
    Depends on:
    - https://patchwork.freedesktop.org/series/59915/
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Acked-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 284ce079d8c4..6712603b8c7a 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -165,6 +165,15 @@ void komeda_crtc_handle_event(struct komeda_crtc   *kcrtc,
 	if (events & KOMEDA_EVENT_VSYNC)
 		drm_crtc_handle_vblank(crtc);
 
+	if (events & KOMEDA_EVENT_EOW) {
+		struct komeda_wb_connector *wb_conn = kcrtc->wb_conn;
+
+		if (wb_conn)
+			drm_writeback_signal_completion(&wb_conn->base, 0);
+		else
+			DRM_WARN("CRTC[%d]: EOW happen but no wb_connector.\n",
+				 drm_crtc_index(&kcrtc->base));
+	}
 	/* will handle it together with the write back support */
 	if (events & KOMEDA_EVENT_EOW)
 		DRM_DEBUG("EOW.\n");
@@ -201,6 +210,8 @@ komeda_crtc_do_flush(struct drm_crtc *crtc,
 	struct komeda_crtc_state *kcrtc_st = to_kcrtc_st(crtc->state);
 	struct komeda_dev *mdev = kcrtc->base.dev->dev_private;
 	struct komeda_pipeline *master = kcrtc->master;
+	struct komeda_wb_connector *wb_conn = kcrtc->wb_conn;
+	struct drm_connector_state *conn_st;
 
 	DRM_DEBUG_ATOMIC("CRTC%d_FLUSH: active_pipes: 0x%x, affected: 0x%x.\n",
 			 drm_crtc_index(crtc),
@@ -210,6 +221,10 @@ komeda_crtc_do_flush(struct drm_crtc *crtc,
 	if (has_bit(master->id, kcrtc_st->affected_pipes))
 		komeda_pipeline_update(master, old->state);
 
+	conn_st = wb_conn ? wb_conn->base.base.state : NULL;
+	if (conn_st && conn_st->writeback_job)
+		drm_writeback_queue_job(&wb_conn->base, conn_st);
+
 	/* step 2: notify the HW to kickoff the update */
 	mdev->funcs->flush(mdev, master->id, kcrtc_st->active_pipes);
 }

commit ba1b9f8c4658663dd66e992bef31f6f8747b6c8c
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu Apr 25 07:12:09 2019 +0100

    drm/komeda: Constify the usage of komeda_component/pipeline/dev_funcs
    
    Depends on:
    - https://patchwork.freedesktop.org/series/58976/
    - https://patchwork.freedesktop.org/series/59855/
    
    Reported-by: Emil Velikov <emil.l.velikov@gmail.com>
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 62fad59f5a6a..284ce079d8c4 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -350,7 +350,7 @@ static bool komeda_crtc_mode_fixup(struct drm_crtc *crtc,
 	return true;
 }
 
-static struct drm_crtc_helper_funcs komeda_crtc_helper_funcs = {
+static const struct drm_crtc_helper_funcs komeda_crtc_helper_funcs = {
 	.atomic_check	= komeda_crtc_atomic_check,
 	.atomic_flush	= komeda_crtc_atomic_flush,
 	.atomic_enable	= komeda_crtc_atomic_enable,

commit 15e9122d9b5c745024f2d9d5653caed1f37c185f
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Wed Apr 24 06:51:45 2019 +0100

    drm/komeda: Mark the local functions as static
    
    Fix the kbuild test rebot reported warnings:
    - symbol was not declared. Should it be static?
    - missing braces around initializer
    
    Depends on:
    - https://patchwork.freedesktop.org/series/58976/
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index d335fec1b727..62fad59f5a6a 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -52,7 +52,7 @@ komeda_crtc_atomic_check(struct drm_crtc *crtc,
 	return 0;
 }
 
-u32 komeda_calc_mclk(struct komeda_crtc_state *kcrtc_st)
+static u32 komeda_calc_mclk(struct komeda_crtc_state *kcrtc_st)
 {
 	unsigned long mclk = kcrtc_st->base.adjusted_mode.clock * 1000;
 
@@ -350,7 +350,7 @@ static bool komeda_crtc_mode_fixup(struct drm_crtc *crtc,
 	return true;
 }
 
-struct drm_crtc_helper_funcs komeda_crtc_helper_funcs = {
+static struct drm_crtc_helper_funcs komeda_crtc_helper_funcs = {
 	.atomic_check	= komeda_crtc_atomic_check,
 	.atomic_flush	= komeda_crtc_atomic_flush,
 	.atomic_enable	= komeda_crtc_atomic_enable,

commit 8c919745ee1c4d8d811a1e015d637d17aa78fe26
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Wed Apr 24 06:48:11 2019 +0100

    drm/komeda: Fixed warning: Function parameter or member not described
    
    Fixed the warnings: Function parameter or member 'xxx' not described
    when make htmldocs
    
    This patch depends on:
    - https://patchwork.freedesktop.org/series/54448/
    - https://patchwork.freedesktop.org/series/54449/
    - https://patchwork.freedesktop.org/series/54450/
    
    v2: Rebase and add reporter
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 053b1e3e74be..d335fec1b727 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -18,9 +18,17 @@
 #include "komeda_dev.h"
 #include "komeda_kms.h"
 
-/* crtc_atomic_check is the final check stage, so beside build a display data
- * pipeline according the crtc_state, but still needs to release/disable the
- * unclaimed pipeline resources.
+/**
+ * komeda_crtc_atomic_check - build display output data flow
+ * @crtc: DRM crtc
+ * @state: the crtc state object
+ *
+ * crtc_atomic_check is the final check stage, so beside build a display data
+ * pipeline according to the crtc_state, but still needs to release or disable
+ * the unclaimed pipeline resources.
+ *
+ * RETURNS:
+ * Zero for success or -errno
  */
 static int
 komeda_crtc_atomic_check(struct drm_crtc *crtc,

commit d29da5d8cd43e316bac8428c1b23a28016a1a9c4
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 11:11:35 2019 +0000

    drm/komeda: Add komeda_crtc_funcs
    
    Added functions:
    -  komeda_crtc_reset
    -  komeda_crtc_vblank_enable
    -  komeda_crtc_vblank_disable
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 015ae217ebc3..053b1e3e74be 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -351,6 +351,47 @@ struct drm_crtc_helper_funcs komeda_crtc_helper_funcs = {
 	.mode_fixup	= komeda_crtc_mode_fixup,
 };
 
+static void komeda_crtc_reset(struct drm_crtc *crtc)
+{
+	struct komeda_crtc_state *state;
+
+	if (crtc->state)
+		__drm_atomic_helper_crtc_destroy_state(crtc->state);
+
+	kfree(to_kcrtc_st(crtc->state));
+	crtc->state = NULL;
+
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (state) {
+		crtc->state = &state->base;
+		crtc->state->crtc = crtc;
+	}
+}
+
+static struct drm_crtc_state *
+komeda_crtc_atomic_duplicate_state(struct drm_crtc *crtc)
+{
+	struct komeda_crtc_state *old = to_kcrtc_st(crtc->state);
+	struct komeda_crtc_state *new;
+
+	new = kzalloc(sizeof(*new), GFP_KERNEL);
+	if (!new)
+		return NULL;
+
+	__drm_atomic_helper_crtc_duplicate_state(crtc, &new->base);
+
+	new->affected_pipes = old->active_pipes;
+
+	return &new->base;
+}
+
+static void komeda_crtc_atomic_destroy_state(struct drm_crtc *crtc,
+					     struct drm_crtc_state *state)
+{
+	__drm_atomic_helper_crtc_destroy_state(state);
+	kfree(to_kcrtc_st(state));
+}
+
 static int komeda_crtc_vblank_enable(struct drm_crtc *crtc)
 {
 	struct komeda_dev *mdev = crtc->dev->dev_private;
@@ -369,6 +410,13 @@ static void komeda_crtc_vblank_disable(struct drm_crtc *crtc)
 }
 
 static const struct drm_crtc_funcs komeda_crtc_funcs = {
+	.gamma_set		= drm_atomic_helper_legacy_gamma_set,
+	.destroy		= drm_crtc_cleanup,
+	.set_config		= drm_atomic_helper_set_config,
+	.page_flip		= drm_atomic_helper_page_flip,
+	.reset			= komeda_crtc_reset,
+	.atomic_duplicate_state	= komeda_crtc_atomic_duplicate_state,
+	.atomic_destroy_state	= komeda_crtc_atomic_destroy_state,
 	.enable_vblank		= komeda_crtc_vblank_enable,
 	.disable_vblank		= komeda_crtc_vblank_disable,
 };

commit 98fe3f93a9ca58e937376074c6d3c680a1e54906
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 11:11:25 2019 +0000

    drm/komeda: Add komeda_crtc_vblank_enable/disable
    
    Add a new komeda_dev_func->on_off_vblank to enable/disable HW vblank event
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 6c85d36208e0..015ae217ebc3 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -351,7 +351,26 @@ struct drm_crtc_helper_funcs komeda_crtc_helper_funcs = {
 	.mode_fixup	= komeda_crtc_mode_fixup,
 };
 
+static int komeda_crtc_vblank_enable(struct drm_crtc *crtc)
+{
+	struct komeda_dev *mdev = crtc->dev->dev_private;
+	struct komeda_crtc *kcrtc = to_kcrtc(crtc);
+
+	mdev->funcs->on_off_vblank(mdev, kcrtc->master->id, true);
+	return 0;
+}
+
+static void komeda_crtc_vblank_disable(struct drm_crtc *crtc)
+{
+	struct komeda_dev *mdev = crtc->dev->dev_private;
+	struct komeda_crtc *kcrtc = to_kcrtc(crtc);
+
+	mdev->funcs->on_off_vblank(mdev, kcrtc->master->id, false);
+}
+
 static const struct drm_crtc_funcs komeda_crtc_funcs = {
+	.enable_vblank		= komeda_crtc_vblank_enable,
+	.disable_vblank		= komeda_crtc_vblank_disable,
 };
 
 int komeda_kms_setup_crtcs(struct komeda_kms_dev *kms,

commit b7925b61bd311015e48fdfc8983572d0009e3909
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 11:11:16 2019 +0000

    drm/komeda: Add komeda_crtc_atomic_enable/disable
    
    Pass enable/disable command to komeda and adjust komeda hardware for
    enable/disable a display instance.
    
    v2: Rebase
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index ef902bf3bba4..6c85d36208e0 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -55,7 +55,7 @@ u32 komeda_calc_mclk(struct komeda_crtc_state *kcrtc_st)
  * 1. adjust display operation mode.
  * 2. enable needed clk
  */
-int
+static int
 komeda_crtc_prepare(struct komeda_crtc *kcrtc)
 {
 	struct komeda_dev *mdev = kcrtc->base.dev->dev_private;
@@ -111,7 +111,7 @@ komeda_crtc_prepare(struct komeda_crtc *kcrtc)
 	return err;
 }
 
-int
+static int
 komeda_crtc_unprepare(struct komeda_crtc *kcrtc)
 {
 	struct komeda_dev *mdev = kcrtc->base.dev->dev_private;
@@ -161,9 +161,28 @@ void komeda_crtc_handle_event(struct komeda_crtc   *kcrtc,
 	if (events & KOMEDA_EVENT_EOW)
 		DRM_DEBUG("EOW.\n");
 
-	/* will handle it with crtc->flush */
-	if (events & KOMEDA_EVENT_FLIP)
-		DRM_DEBUG("FLIP Done.\n");
+	if (events & KOMEDA_EVENT_FLIP) {
+		unsigned long flags;
+		struct drm_pending_vblank_event *event;
+
+		spin_lock_irqsave(&crtc->dev->event_lock, flags);
+		if (kcrtc->disable_done) {
+			complete_all(kcrtc->disable_done);
+			kcrtc->disable_done = NULL;
+		} else if (crtc->state->event) {
+			event = crtc->state->event;
+			/*
+			 * Consume event before notifying drm core that flip
+			 * happened.
+			 */
+			crtc->state->event = NULL;
+			drm_crtc_send_vblank_event(crtc, event);
+		} else {
+			DRM_WARN("CRTC[%d]: FLIP happen but no pending commit.\n",
+				 drm_crtc_index(&kcrtc->base));
+		}
+		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+	}
 }
 
 static void
@@ -187,6 +206,81 @@ komeda_crtc_do_flush(struct drm_crtc *crtc,
 	mdev->funcs->flush(mdev, master->id, kcrtc_st->active_pipes);
 }
 
+static void
+komeda_crtc_atomic_enable(struct drm_crtc *crtc,
+			  struct drm_crtc_state *old)
+{
+	komeda_crtc_prepare(to_kcrtc(crtc));
+	drm_crtc_vblank_on(crtc);
+	komeda_crtc_do_flush(crtc, old);
+}
+
+static void
+komeda_crtc_atomic_disable(struct drm_crtc *crtc,
+			   struct drm_crtc_state *old)
+{
+	struct komeda_crtc *kcrtc = to_kcrtc(crtc);
+	struct komeda_crtc_state *old_st = to_kcrtc_st(old);
+	struct komeda_dev *mdev = crtc->dev->dev_private;
+	struct komeda_pipeline *master = kcrtc->master;
+	struct completion *disable_done = &crtc->state->commit->flip_done;
+	struct completion temp;
+	int timeout;
+
+	DRM_DEBUG_ATOMIC("CRTC%d_DISABLE: active_pipes: 0x%x, affected: 0x%x.\n",
+			 drm_crtc_index(crtc),
+			 old_st->active_pipes, old_st->affected_pipes);
+
+	if (has_bit(master->id, old_st->active_pipes))
+		komeda_pipeline_disable(master, old->state);
+
+	/* crtc_disable has two scenarios according to the state->active switch.
+	 * 1. active -> inactive
+	 *    this commit is a disable commit. and the commit will be finished
+	 *    or done after the disable operation. on this case we can directly
+	 *    use the crtc->state->event to tracking the HW disable operation.
+	 * 2. active -> active
+	 *    the crtc->commit is not for disable, but a modeset operation when
+	 *    crtc is active, such commit actually has been completed by 3
+	 *    DRM operations:
+	 *    crtc_disable, update_planes(crtc_flush), crtc_enable
+	 *    so on this case the crtc->commit is for the whole process.
+	 *    we can not use it for tracing the disable, we need a temporary
+	 *    flip_done for tracing the disable. and crtc->state->event for
+	 *    the crtc_enable operation.
+	 *    That's also the reason why skip modeset commit in
+	 *    komeda_crtc_atomic_flush()
+	 */
+	if (crtc->state->active) {
+		struct komeda_pipeline_state *pipe_st;
+		/* clear the old active_comps to zero */
+		pipe_st = komeda_pipeline_get_old_state(master, old->state);
+		pipe_st->active_comps = 0;
+
+		init_completion(&temp);
+		kcrtc->disable_done = &temp;
+		disable_done = &temp;
+	}
+
+	mdev->funcs->flush(mdev, master->id, 0);
+
+	/* wait the disable take affect.*/
+	timeout = wait_for_completion_timeout(disable_done, HZ);
+	if (timeout == 0) {
+		DRM_ERROR("disable pipeline%d timeout.\n", kcrtc->master->id);
+		if (crtc->state->active) {
+			unsigned long flags;
+
+			spin_lock_irqsave(&crtc->dev->event_lock, flags);
+			kcrtc->disable_done = NULL;
+			spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+		}
+	}
+
+	drm_crtc_vblank_off(crtc);
+	komeda_crtc_unprepare(kcrtc);
+}
+
 static void
 komeda_crtc_atomic_flush(struct drm_crtc *crtc,
 			 struct drm_crtc_state *old)
@@ -251,6 +345,8 @@ static bool komeda_crtc_mode_fixup(struct drm_crtc *crtc,
 struct drm_crtc_helper_funcs komeda_crtc_helper_funcs = {
 	.atomic_check	= komeda_crtc_atomic_check,
 	.atomic_flush	= komeda_crtc_atomic_flush,
+	.atomic_enable	= komeda_crtc_atomic_enable,
+	.atomic_disable	= komeda_crtc_atomic_disable,
 	.mode_valid	= komeda_crtc_mode_valid,
 	.mode_fixup	= komeda_crtc_mode_fixup,
 };

commit 20d84aa841791075edc07e0a7417cea443abe889
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 11:11:07 2019 +0000

    drm/komeda: Add komeda_crtc_prepare/unprepare
    
    These two function will be used by komeda_crtc_enable/disable to do some
    prepartion works when enable/disable a crtc. like enable a crtc:
      1. Adjust display operation mode.
      2. Enable/prepare needed clk.
    
    v2: Rebase
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 902f3992083e..ef902bf3bba4 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -44,6 +44,110 @@ komeda_crtc_atomic_check(struct drm_crtc *crtc,
 	return 0;
 }
 
+u32 komeda_calc_mclk(struct komeda_crtc_state *kcrtc_st)
+{
+	unsigned long mclk = kcrtc_st->base.adjusted_mode.clock * 1000;
+
+	return mclk;
+}
+
+/* For active a crtc, mainly need two parts of preparation
+ * 1. adjust display operation mode.
+ * 2. enable needed clk
+ */
+int
+komeda_crtc_prepare(struct komeda_crtc *kcrtc)
+{
+	struct komeda_dev *mdev = kcrtc->base.dev->dev_private;
+	struct komeda_pipeline *master = kcrtc->master;
+	struct komeda_crtc_state *kcrtc_st = to_kcrtc_st(kcrtc->base.state);
+	unsigned long pxlclk_rate = kcrtc_st->base.adjusted_mode.clock * 1000;
+	u32 new_mode;
+	int err;
+
+	mutex_lock(&mdev->lock);
+
+	new_mode = mdev->dpmode | BIT(master->id);
+	if (WARN_ON(new_mode == mdev->dpmode)) {
+		err = 0;
+		goto unlock;
+	}
+
+	err = mdev->funcs->change_opmode(mdev, new_mode);
+	if (err) {
+		DRM_ERROR("failed to change opmode: 0x%x -> 0x%x.\n,",
+			  mdev->dpmode, new_mode);
+		goto unlock;
+	}
+
+	mdev->dpmode = new_mode;
+	/* Only need to enable mclk on single display mode, but no need to
+	 * enable mclk it on dual display mode, since the dual mode always
+	 * switch from single display mode, the mclk already enabled, no need
+	 * to enable it again.
+	 */
+	if (new_mode != KOMEDA_MODE_DUAL_DISP) {
+		err = clk_set_rate(mdev->mclk, komeda_calc_mclk(kcrtc_st));
+		if (err)
+			DRM_ERROR("failed to set mclk.\n");
+		err = clk_prepare_enable(mdev->mclk);
+		if (err)
+			DRM_ERROR("failed to enable mclk.\n");
+	}
+
+	err = clk_prepare_enable(master->aclk);
+	if (err)
+		DRM_ERROR("failed to enable axi clk for pipe%d.\n", master->id);
+	err = clk_set_rate(master->pxlclk, pxlclk_rate);
+	if (err)
+		DRM_ERROR("failed to set pxlclk for pipe%d\n", master->id);
+	err = clk_prepare_enable(master->pxlclk);
+	if (err)
+		DRM_ERROR("failed to enable pxl clk for pipe%d.\n", master->id);
+
+unlock:
+	mutex_unlock(&mdev->lock);
+
+	return err;
+}
+
+int
+komeda_crtc_unprepare(struct komeda_crtc *kcrtc)
+{
+	struct komeda_dev *mdev = kcrtc->base.dev->dev_private;
+	struct komeda_pipeline *master = kcrtc->master;
+	u32 new_mode;
+	int err;
+
+	mutex_lock(&mdev->lock);
+
+	new_mode = mdev->dpmode & (~BIT(master->id));
+
+	if (WARN_ON(new_mode == mdev->dpmode)) {
+		err = 0;
+		goto unlock;
+	}
+
+	err = mdev->funcs->change_opmode(mdev, new_mode);
+	if (err) {
+		DRM_ERROR("failed to change opmode: 0x%x -> 0x%x.\n,",
+			  mdev->dpmode, new_mode);
+		goto unlock;
+	}
+
+	mdev->dpmode = new_mode;
+
+	clk_disable_unprepare(master->pxlclk);
+	clk_disable_unprepare(master->aclk);
+	if (new_mode == KOMEDA_MODE_INACTIVE)
+		clk_disable_unprepare(mdev->mclk);
+
+unlock:
+	mutex_unlock(&mdev->lock);
+
+	return err;
+}
+
 void komeda_crtc_handle_event(struct komeda_crtc   *kcrtc,
 			      struct komeda_events *evts)
 {

commit a2491b900d63e3d9774cb1f8baae2ee1fbb75651
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 11:10:57 2019 +0000

    drm/komeda: Add komeda_crtc_mode_valid/fixup
    
    komeda_crtc_mode_valid compares the input mode->clk with main engine clk
    and AXI clk, and reject the mode if the required pixel clk can not be
    satisfied by main engine clk and AXI-clk.
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 40ee45d36ad6..902f3992083e 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -94,9 +94,61 @@ komeda_crtc_atomic_flush(struct drm_crtc *crtc,
 	komeda_crtc_do_flush(crtc, old);
 }
 
+static enum drm_mode_status
+komeda_crtc_mode_valid(struct drm_crtc *crtc, const struct drm_display_mode *m)
+{
+	struct komeda_dev *mdev = crtc->dev->dev_private;
+	struct komeda_crtc *kcrtc = to_kcrtc(crtc);
+	struct komeda_pipeline *master = kcrtc->master;
+	long mode_clk, pxlclk;
+
+	if (m->flags & DRM_MODE_FLAG_INTERLACE)
+		return MODE_NO_INTERLACE;
+
+	/* main clock/AXI clk must be faster than pxlclk*/
+	mode_clk = m->clock * 1000;
+	pxlclk = clk_round_rate(master->pxlclk, mode_clk);
+	if (pxlclk != mode_clk) {
+		DRM_DEBUG_ATOMIC("pxlclk doesn't support %ld Hz\n", mode_clk);
+
+		return MODE_NOCLOCK;
+	}
+
+	if (clk_round_rate(mdev->mclk, mode_clk) < pxlclk) {
+		DRM_DEBUG_ATOMIC("mclk can't satisfy the requirement of %s-clk: %ld.\n",
+				 m->name, pxlclk);
+
+		return MODE_CLOCK_HIGH;
+	}
+
+	if (clk_round_rate(master->aclk, mode_clk) < pxlclk) {
+		DRM_DEBUG_ATOMIC("aclk can't satisfy the requirement of %s-clk: %ld.\n",
+				 m->name, pxlclk);
+
+		return MODE_CLOCK_HIGH;
+	}
+
+	return MODE_OK;
+}
+
+static bool komeda_crtc_mode_fixup(struct drm_crtc *crtc,
+				   const struct drm_display_mode *m,
+				   struct drm_display_mode *adjusted_mode)
+{
+	struct komeda_crtc *kcrtc = to_kcrtc(crtc);
+	struct komeda_pipeline *master = kcrtc->master;
+	long mode_clk = m->clock * 1000;
+
+	adjusted_mode->clock = clk_round_rate(master->pxlclk, mode_clk) / 1000;
+
+	return true;
+}
+
 struct drm_crtc_helper_funcs komeda_crtc_helper_funcs = {
 	.atomic_check	= komeda_crtc_atomic_check,
 	.atomic_flush	= komeda_crtc_atomic_flush,
+	.mode_valid	= komeda_crtc_mode_valid,
+	.mode_fixup	= komeda_crtc_mode_fixup,
 };
 
 static const struct drm_crtc_funcs komeda_crtc_funcs = {

commit 59dd6d58a5332daa7af9a4c14defe0a80a9e195d
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 11:10:48 2019 +0000

    drm/komeda: Add komeda_crtc_atomic_flush
    
    A komeda flush is comprised two steps:
    1. update pipeline/component state to HW.
    2. call dev_func->flush to notify HW to kickoff the update.
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 18209cae287c..40ee45d36ad6 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -62,8 +62,41 @@ void komeda_crtc_handle_event(struct komeda_crtc   *kcrtc,
 		DRM_DEBUG("FLIP Done.\n");
 }
 
+static void
+komeda_crtc_do_flush(struct drm_crtc *crtc,
+		     struct drm_crtc_state *old)
+{
+	struct komeda_crtc *kcrtc = to_kcrtc(crtc);
+	struct komeda_crtc_state *kcrtc_st = to_kcrtc_st(crtc->state);
+	struct komeda_dev *mdev = kcrtc->base.dev->dev_private;
+	struct komeda_pipeline *master = kcrtc->master;
+
+	DRM_DEBUG_ATOMIC("CRTC%d_FLUSH: active_pipes: 0x%x, affected: 0x%x.\n",
+			 drm_crtc_index(crtc),
+			 kcrtc_st->active_pipes, kcrtc_st->affected_pipes);
+
+	/* step 1: update the pipeline/component state to HW */
+	if (has_bit(master->id, kcrtc_st->affected_pipes))
+		komeda_pipeline_update(master, old->state);
+
+	/* step 2: notify the HW to kickoff the update */
+	mdev->funcs->flush(mdev, master->id, kcrtc_st->active_pipes);
+}
+
+static void
+komeda_crtc_atomic_flush(struct drm_crtc *crtc,
+			 struct drm_crtc_state *old)
+{
+	/* commit with modeset will be handled in enable/disable */
+	if (drm_atomic_crtc_needs_modeset(crtc->state))
+		return;
+
+	komeda_crtc_do_flush(crtc, old);
+}
+
 struct drm_crtc_helper_funcs komeda_crtc_helper_funcs = {
 	.atomic_check	= komeda_crtc_atomic_check,
+	.atomic_flush	= komeda_crtc_atomic_flush,
 };
 
 static const struct drm_crtc_funcs komeda_crtc_funcs = {

commit 552b831cd5e1d8ee0cf71e8af08734ef2b5aa7e4
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 11:10:39 2019 +0000

    drm/komeda: Add komeda_release_unclaimed_resources
    
    Komeda driver treats KMS-CRTC/PLANE as user which will acquire pipeline
    resources, but we still need to release the unclaimed resources.
    crtc_atomic_check is the final check stage, so beside build a display data
    pipeline according the crtc_state, but still needs to release/disable the
    unclaimed pipeline resources.
    
    v2: Rebase
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index f88a14927be9..18209cae287c 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -18,6 +18,32 @@
 #include "komeda_dev.h"
 #include "komeda_kms.h"
 
+/* crtc_atomic_check is the final check stage, so beside build a display data
+ * pipeline according the crtc_state, but still needs to release/disable the
+ * unclaimed pipeline resources.
+ */
+static int
+komeda_crtc_atomic_check(struct drm_crtc *crtc,
+			 struct drm_crtc_state *state)
+{
+	struct komeda_crtc *kcrtc = to_kcrtc(crtc);
+	struct komeda_crtc_state *kcrtc_st = to_kcrtc_st(state);
+	int err;
+
+	if (state->active) {
+		err = komeda_build_display_data_flow(kcrtc, kcrtc_st);
+		if (err)
+			return err;
+	}
+
+	/* release unclaimed pipeline resources */
+	err = komeda_release_unclaimed_resources(kcrtc->master, kcrtc_st);
+	if (err)
+		return err;
+
+	return 0;
+}
+
 void komeda_crtc_handle_event(struct komeda_crtc   *kcrtc,
 			      struct komeda_events *evts)
 {
@@ -37,6 +63,7 @@ void komeda_crtc_handle_event(struct komeda_crtc   *kcrtc,
 }
 
 struct drm_crtc_helper_funcs komeda_crtc_helper_funcs = {
+	.atomic_check	= komeda_crtc_atomic_check,
 };
 
 static const struct drm_crtc_funcs komeda_crtc_funcs = {

commit 0dac37bf1c5dc1e8454fbe8d548f6e312cfd982d
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 09:24:25 2019 +0000

    drm/komeda: Add irq handling
    
    1. Added irq_handler/irq_enable/irq_disable to komeda_dev_func, then the
       Komeda-CORE can control the HW irq via these chip function.
    2. Install irq and register irq_handler to system by DRM, so once the IRQ
       coming, the handling sequence is:
    
       komeda_kms_irq_handler(int irq, void *data)
            /* step 1. call into the CHIP to recognize event */
            mdev->funcs->irq_handler(mdev, &evts);
    
            /* step 2. notify the crtc to handle the events */
            for (i = 0; i < kms->n_crtcs; i++)
                    komeda_crtc_handle_event(&kms->crtcs[i], &evts);
    
    v2:
    - Move get IRQ number into this change.
    - Enable irq before drm_dev_register.
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 3ca5718aa0c2..f88a14927be9 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -18,6 +18,24 @@
 #include "komeda_dev.h"
 #include "komeda_kms.h"
 
+void komeda_crtc_handle_event(struct komeda_crtc   *kcrtc,
+			      struct komeda_events *evts)
+{
+	struct drm_crtc *crtc = &kcrtc->base;
+	u32 events = evts->pipes[kcrtc->master->id];
+
+	if (events & KOMEDA_EVENT_VSYNC)
+		drm_crtc_handle_vblank(crtc);
+
+	/* will handle it together with the write back support */
+	if (events & KOMEDA_EVENT_EOW)
+		DRM_DEBUG("EOW.\n");
+
+	/* will handle it with crtc->flush */
+	if (events & KOMEDA_EVENT_FLIP)
+		DRM_DEBUG("FLIP Done.\n");
+}
+
 struct drm_crtc_helper_funcs komeda_crtc_helper_funcs = {
 };
 

commit 6649a95d35d850e417f125821a803ca7889c713c
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Fri Feb 8 23:13:24 2019 +0100

    drm/komeda: fix build with drm_modeset_helper.h update
    
    With drmP.h removed from drm_modeset_helper.h the build of
    komeda filed as reported by linux-next
    
    Add missing include files to fix build.
    For the files touched group include files and sort them.
    
    The fix was tested on a tree with drm-misc-next merged.
    And the patch was also tested to work without drm-misc-next merged.
    
    Build tested on arm + x86.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au> [linux-next]
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: James Wang <james.qian.wang@arm.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190208221324.27002-1-sam@ravnborg.org

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
index 5bb5a55f6b31..3ca5718aa0c2 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -5,12 +5,16 @@
  *
  */
 #include <linux/clk.h>
+#include <linux/pm_runtime.h>
 #include <linux/spinlock.h>
+
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
-#include <drm/drm_plane_helper.h>
 #include <drm/drm_crtc_helper.h>
-#include <linux/pm_runtime.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_print.h>
+#include <drm/drm_vblank.h>
+
 #include "komeda_dev.h"
 #include "komeda_kms.h"
 

commit 61f1c4a8ab7575c0147ae6c0d220f9719fdc741e
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu Jan 3 11:41:30 2019 +0000

    drm/komeda: Attach komeda_dev to DRM-KMS
    
    Add komeda_kms abstracton to attach komeda_dev to DRM-KMS
      CRTC: according to the komeda_pipeline
      PLANE: according to komeda_layer (layer input pipeline)
      PRIVATE_OBJS: komeda_pipeline/component all will be treat as private_objs
    
    komeda_kms is for connecting DRM-KMS and komeda_dev, like reporting the
    kms object properties according to the komeda_dev, and pass/convert KMS's
    requirement to komeda_dev.
    
    Changes in v4:
    - Set drm_atomic_helper_check as mode_config->atomic_check.
    
    Changes in v3:
    - Fixed style problem found by checkpatch.pl --strict.
    
    Changes in v2:
    - Unified abbreviation of "pipeline" to "pipe".
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Reviewed-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
new file mode 100644
index 000000000000..5bb5a55f6b31
--- /dev/null
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c
@@ -0,0 +1,106 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * (C) COPYRIGHT 2018 ARM Limited. All rights reserved.
+ * Author: James.Qian.Wang <james.qian.wang@arm.com>
+ *
+ */
+#include <linux/clk.h>
+#include <linux/spinlock.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <linux/pm_runtime.h>
+#include "komeda_dev.h"
+#include "komeda_kms.h"
+
+struct drm_crtc_helper_funcs komeda_crtc_helper_funcs = {
+};
+
+static const struct drm_crtc_funcs komeda_crtc_funcs = {
+};
+
+int komeda_kms_setup_crtcs(struct komeda_kms_dev *kms,
+			   struct komeda_dev *mdev)
+{
+	struct komeda_crtc *crtc;
+	struct komeda_pipeline *master;
+	char str[16];
+	int i;
+
+	kms->n_crtcs = 0;
+
+	for (i = 0; i < mdev->n_pipelines; i++) {
+		crtc = &kms->crtcs[kms->n_crtcs];
+		master = mdev->pipelines[i];
+
+		crtc->master = master;
+		crtc->slave  = NULL;
+
+		if (crtc->slave)
+			sprintf(str, "pipe-%d", crtc->slave->id);
+		else
+			sprintf(str, "None");
+
+		DRM_INFO("crtc%d: master(pipe-%d) slave(%s) output: %s.\n",
+			 kms->n_crtcs, master->id, str,
+			 master->of_output_dev ?
+			 master->of_output_dev->full_name : "None");
+
+		kms->n_crtcs++;
+	}
+
+	return 0;
+}
+
+static struct drm_plane *
+get_crtc_primary(struct komeda_kms_dev *kms, struct komeda_crtc *crtc)
+{
+	struct komeda_plane *kplane;
+	struct drm_plane *plane;
+
+	drm_for_each_plane(plane, &kms->base) {
+		if (plane->type != DRM_PLANE_TYPE_PRIMARY)
+			continue;
+
+		kplane = to_kplane(plane);
+		/* only master can be primary */
+		if (kplane->layer->base.pipeline == crtc->master)
+			return plane;
+	}
+
+	return NULL;
+}
+
+static int komeda_crtc_add(struct komeda_kms_dev *kms,
+			   struct komeda_crtc *kcrtc)
+{
+	struct drm_crtc *crtc = &kcrtc->base;
+	int err;
+
+	err = drm_crtc_init_with_planes(&kms->base, crtc,
+					get_crtc_primary(kms, kcrtc), NULL,
+					&komeda_crtc_funcs, NULL);
+	if (err)
+		return err;
+
+	drm_crtc_helper_add(crtc, &komeda_crtc_helper_funcs);
+	drm_crtc_vblank_reset(crtc);
+
+	crtc->port = kcrtc->master->of_output_port;
+
+	return 0;
+}
+
+int komeda_kms_add_crtcs(struct komeda_kms_dev *kms, struct komeda_dev *mdev)
+{
+	int i, err;
+
+	for (i = 0; i < kms->n_crtcs; i++) {
+		err = komeda_crtc_add(kms, &kms->crtcs[i]);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
