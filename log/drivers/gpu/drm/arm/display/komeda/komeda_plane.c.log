commit 513be3334431ec5c645e9e8c3ee7fdc7c03e99a1
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Mon Jul 22 13:56:27 2019 +0800

    drm/komeda: remove set but not used variable 'old'
    
    Fixes gcc '-Wunused-but-set-variable' warning:
    
    drivers/gpu/drm/arm/display/komeda/komeda_plane.c:
     In function komeda_plane_atomic_duplicate_state:
    drivers/gpu/drm/arm/display/komeda/komeda_plane.c:161:35:
     warning: variable old set but not used [-Wunused-but-set-variable
    
    It is not used since commit 990dee3aa456 ("drm/komeda:
    Computing image enhancer internally")
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190722055627.38008-1-yuehaibing@huawei.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index c095af154216..98e915e325dd 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -158,7 +158,7 @@ static void komeda_plane_reset(struct drm_plane *plane)
 static struct drm_plane_state *
 komeda_plane_atomic_duplicate_state(struct drm_plane *plane)
 {
-	struct komeda_plane_state *new, *old;
+	struct komeda_plane_state *new;
 
 	if (WARN_ON(!plane->state))
 		return NULL;
@@ -169,8 +169,6 @@ komeda_plane_atomic_duplicate_state(struct drm_plane *plane)
 
 	__drm_atomic_helper_plane_duplicate_state(plane, &new->base);
 
-	old = to_kplane_st(plane->state);
-
 	return &new->base;
 }
 

commit 990dee3aa45690217e8d83e7704cf07b2f3d9821
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Mon Jul 8 08:00:22 2019 +0100

    drm/komeda: Computing image enhancer internally
    
    Enable image enhancer when the input data flow is 2x+ upscaling.
    
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190708070000.4945-1-james.qian.wang@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index b1386438357b..c095af154216 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -18,7 +18,6 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
 			    struct komeda_data_flow_cfg *dflow)
 {
 	struct komeda_plane *kplane = to_kplane(st->plane);
-	struct komeda_plane_state *kplane_st = to_kplane_st(st);
 	struct drm_framebuffer *fb = st->fb;
 	const struct komeda_format_caps *caps = to_kfb(fb)->format_caps;
 	struct komeda_pipeline *pipe = kplane->layer->base.pipeline;
@@ -57,8 +56,6 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
 		return -EINVAL;
 	}
 
-	dflow->en_img_enhancement = !!kplane_st->img_enhancement;
-
 	komeda_complete_data_flow_cfg(kplane->layer, dflow, fb);
 
 	return 0;
@@ -174,8 +171,6 @@ komeda_plane_atomic_duplicate_state(struct drm_plane *plane)
 
 	old = to_kplane_st(plane->state);
 
-	new->img_enhancement = old->img_enhancement;
-
 	return &new->base;
 }
 

commit 1930c11204b1d83549a6f5f32500b35a4b909dbb
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Mon Jul 8 07:59:45 2019 +0100

    drm/komeda: Computing layer_split internally
    
    For layer_split no need user to enable/disable it, but compute it in
    komeda internally, komeda will enable it if the scaling exceed the
    acceptable range of scaler.
    
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190708065923.4887-1-james.qian.wang@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index 5bb8553cc117..b1386438357b 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -58,9 +58,8 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
 	}
 
 	dflow->en_img_enhancement = !!kplane_st->img_enhancement;
-	dflow->en_split = !!kplane_st->layer_split;
 
-	komeda_complete_data_flow_cfg(dflow, fb);
+	komeda_complete_data_flow_cfg(kplane->layer, dflow, fb);
 
 	return 0;
 }

commit c945623c05c34814c655a0c87155dca81d7e7146
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 5 14:10:05 2019 +0200

    drm/komeda: Remove layer_split property
    
    Properties are uapi like anything else, with all the usual rules
    regarding review, testcases, open source userspace ... Furthermore
    driver-private kms properties are highly discouraged, over the past
    few years we've realized we need to make a serious effort at better
    standardizing this stuff.
    
    Again this probably needs multiple pieces to solve this properly:
    
    - Instead of expecting userspace to compute this (and duplicating
      modeset code), the kernel driver should compute when it's necessary
      to enable layer_split mode to make a configuration possible. I.e. in
      komeda_plane_atomic_check() first try komeda_build_layer_data_flow()
      and if that fails, try komeda_build_layer_split_data_flow(), and set
      dflow.en_split accordingly. Assuming I understand somewhat correctly
      what this does.
    
    - If this is needed for validation then you want a debugfs file to
      force this one way or the other, or alternatively  use
      ->atomic_print_state to dump such hidden driver-private state.
      Depends upon how you do your validation ofc.
    
    Fixes: a407a6509393 ("drm/komeda: Add layer split support")
    Cc: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Cc: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Mali DP Maintainers <malidp@foss.arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190705121006.26085-4-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index 23db38650a46..5bb8553cc117 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -188,40 +188,6 @@ komeda_plane_atomic_destroy_state(struct drm_plane *plane,
 	kfree(to_kplane_st(state));
 }
 
-static int
-komeda_plane_atomic_get_property(struct drm_plane *plane,
-				 const struct drm_plane_state *state,
-				 struct drm_property *property,
-				 uint64_t *val)
-{
-	struct komeda_plane *kplane = to_kplane(plane);
-	struct komeda_plane_state *st = to_kplane_st(state);
-
-	if (property == kplane->prop_layer_split)
-		*val = st->layer_split;
-	else
-		return -EINVAL;
-
-	return 0;
-}
-
-static int
-komeda_plane_atomic_set_property(struct drm_plane *plane,
-				 struct drm_plane_state *state,
-				 struct drm_property *property,
-				 uint64_t val)
-{
-	struct komeda_plane *kplane = to_kplane(plane);
-	struct komeda_plane_state *st = to_kplane_st(state);
-
-	if (property == kplane->prop_layer_split)
-		st->layer_split = !!val;
-	else
-		return -EINVAL;
-
-	return 0;
-}
-
 static bool
 komeda_plane_format_mod_supported(struct drm_plane *plane,
 				  u32 format, u64 modifier)
@@ -241,32 +207,9 @@ static const struct drm_plane_funcs komeda_plane_funcs = {
 	.reset			= komeda_plane_reset,
 	.atomic_duplicate_state	= komeda_plane_atomic_duplicate_state,
 	.atomic_destroy_state	= komeda_plane_atomic_destroy_state,
-	.atomic_get_property	= komeda_plane_atomic_get_property,
-	.atomic_set_property	= komeda_plane_atomic_set_property,
 	.format_mod_supported	= komeda_plane_format_mod_supported,
 };
 
-static int
-komeda_plane_create_layer_properties(struct komeda_plane *kplane,
-				     struct komeda_layer *layer)
-{
-	struct drm_device *drm = kplane->base.dev;
-	struct drm_plane *plane = &kplane->base;
-	struct drm_property *prop = NULL;
-
-	/* property: layer split */
-	if (layer->right) {
-		prop = drm_property_create_bool(drm, DRM_MODE_PROP_ATOMIC,
-						"layer_split");
-		if (!prop)
-			return -ENOMEM;
-		kplane->prop_layer_split = prop;
-		drm_object_attach_property(&plane->base, prop, 0);
-	}
-
-	return 0;
-}
-
 /* for komeda, which is pipeline can be share between crtcs */
 static u32 get_possible_crtcs(struct komeda_kms_dev *kms,
 			      struct komeda_pipeline *pipe)
@@ -360,10 +303,6 @@ static int komeda_plane_add(struct komeda_kms_dev *kms,
 	if (err)
 		goto cleanup;
 
-	err = komeda_plane_create_layer_properties(kplane, layer);
-	if (err)
-		goto cleanup;
-
 	err = drm_plane_create_color_properties(plane,
 			BIT(DRM_COLOR_YCBCR_BT601) |
 			BIT(DRM_COLOR_YCBCR_BT709) |

commit a76f612c1de8f82b1712e78e73d223f677f8254e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jul 5 14:10:04 2019 +0200

    drm/komeda: remove img_enhancement property
    
    Properties are uapi like anything else, with all the usual rules
    regarding review, testcases, open source userspace ... Furthermore
    driver-private kms properties are highly discouraged, over the past
    few years we've realized we need to make a serious effort at better
    standardizing this stuff.
    
    Again this probably needs multiple pieces to solve this properly:
    
    - Instead of expecting userspace to compute this (and duplicating
      modeset code), the kernel driver should compute when it's possible
      to enable this better up/downscale mode (assuming I understood
      Liviu correctly on what this does) automatically.
    
    - If this is needed for validation then you want a debugfs file to
      force this one way or the other, or alternatively  use
      ->atomic_print_state to dump such hidden driver-private state.
      Depends upon how you do your validation ofc.
    
    Fixes: 42b6f118f6d1 ("drm/komeda: Add image enhancement support")
    Cc: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Cc: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Mali DP Maintainers <malidp@foss.arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190705121006.26085-3-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index 04b122f28fb6..23db38650a46 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -197,9 +197,7 @@ komeda_plane_atomic_get_property(struct drm_plane *plane,
 	struct komeda_plane *kplane = to_kplane(plane);
 	struct komeda_plane_state *st = to_kplane_st(state);
 
-	if (property == kplane->prop_img_enhancement)
-		*val = st->img_enhancement;
-	else if (property == kplane->prop_layer_split)
+	if (property == kplane->prop_layer_split)
 		*val = st->layer_split;
 	else
 		return -EINVAL;
@@ -216,9 +214,7 @@ komeda_plane_atomic_set_property(struct drm_plane *plane,
 	struct komeda_plane *kplane = to_kplane(plane);
 	struct komeda_plane_state *st = to_kplane_st(state);
 
-	if (property == kplane->prop_img_enhancement)
-		st->img_enhancement = !!val;
-	else if (property == kplane->prop_layer_split)
+	if (property == kplane->prop_layer_split)
 		st->layer_split = !!val;
 	else
 		return -EINVAL;
@@ -258,17 +254,6 @@ komeda_plane_create_layer_properties(struct komeda_plane *kplane,
 	struct drm_plane *plane = &kplane->base;
 	struct drm_property *prop = NULL;
 
-	/* property: layer image_enhancement */
-	if (layer->base.supported_outputs & KOMEDA_PIPELINE_SCALERS) {
-		prop = drm_property_create_bool(drm, DRM_MODE_PROP_ATOMIC,
-						"img_enhancement");
-		if (!prop)
-			return -ENOMEM;
-
-		drm_object_attach_property(&plane->base, prop, 0);
-		kplane->prop_img_enhancement = prop;
-	}
-
 	/* property: layer split */
 	if (layer->right) {
 		prop = drm_property_create_bool(drm, DRM_MODE_PROP_ATOMIC,

commit 3b9dfa4ef28c7dfb847cd3f8f97e7b92686c3e76
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Tue Jun 11 12:13:39 2019 +0100

    drm/komeda: Add slave pipeline support
    
    One crtc can use two komeda_pipeline, and one works as master and as
    slave. the slave pipeline doesn't have its own output and timing
    ctrlr, but pre-composite the input layer data flow and then feed the
    result to master. the pipeline configuration like:
    
    slave-layer-0 \
    ...            slave->CU
    slave-layer-4 /         \
                            \
    master-layer-0 --------> master->CU -> ...
     ...                  /
    master-layer-4 ------>
    
    Since komeda Compiz doesn't output alpha, so the slave->CU result
    only can be used as bottom input when blend it with master input data
    flows.
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index d1c58a88d9e2..04b122f28fb6 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -14,15 +14,27 @@
 
 static int
 komeda_plane_init_data_flow(struct drm_plane_state *st,
+			    struct komeda_crtc_state *kcrtc_st,
 			    struct komeda_data_flow_cfg *dflow)
 {
+	struct komeda_plane *kplane = to_kplane(st->plane);
 	struct komeda_plane_state *kplane_st = to_kplane_st(st);
 	struct drm_framebuffer *fb = st->fb;
 	const struct komeda_format_caps *caps = to_kfb(fb)->format_caps;
+	struct komeda_pipeline *pipe = kplane->layer->base.pipeline;
 
 	memset(dflow, 0, sizeof(*dflow));
 
 	dflow->blending_zorder = st->normalized_zpos;
+	if (pipe == to_kcrtc(st->crtc)->master)
+		dflow->blending_zorder -= kcrtc_st->max_slave_zorder;
+	if (dflow->blending_zorder < 0) {
+		DRM_DEBUG_ATOMIC("%s zorder:%d < max_slave_zorder: %d.\n",
+				 st->plane->name, st->normalized_zpos,
+				 kcrtc_st->max_slave_zorder);
+		return -EINVAL;
+	}
+
 	dflow->pixel_blend_mode = st->pixel_blend_mode;
 	dflow->layer_alpha = st->alpha >> 8;
 
@@ -88,7 +100,7 @@ komeda_plane_atomic_check(struct drm_plane *plane,
 
 	kcrtc_st = to_kcrtc_st(crtc_st);
 
-	err = komeda_plane_init_data_flow(state, &dflow);
+	err = komeda_plane_init_data_flow(state, kcrtc_st, &dflow);
 	if (err)
 		return err;
 
@@ -288,6 +300,22 @@ static u32 get_possible_crtcs(struct komeda_kms_dev *kms,
 	return possible_crtcs;
 }
 
+static void
+komeda_set_crtc_plane_mask(struct komeda_kms_dev *kms,
+			   struct komeda_pipeline *pipe,
+			   struct drm_plane *plane)
+{
+	struct komeda_crtc *kcrtc;
+	int i;
+
+	for (i = 0; i < kms->n_crtcs; i++) {
+		kcrtc = &kms->crtcs[i];
+
+		if (pipe == kcrtc->slave)
+			kcrtc->slave_planes |= BIT(drm_plane_index(plane));
+	}
+}
+
 /* use Layer0 as primary */
 static u32 get_plane_type(struct komeda_kms_dev *kms,
 			  struct komeda_component *c)
@@ -366,6 +394,8 @@ static int komeda_plane_add(struct komeda_kms_dev *kms,
 	if (err)
 		goto cleanup;
 
+	komeda_set_crtc_plane_mask(kms, c->pipeline, plane);
+
 	return 0;
 cleanup:
 	komeda_plane_destroy(plane);

commit a407a65093937f6ced4a2ae30d3290088b41df87
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Mon Jun 10 11:16:08 2019 +0100

    drm/komeda: Add layer split support
    
    Komeda supports two types of layer split:
    - none-scaling split
    - scaling split
    Since D71 merger only support scaler as input, so for none-scaling split,
    the two layer dflow will be output to compiz directly. for scaling_split,
    the data flow will be merged by merger firstly, then output the merged
    data flow to compiz.
    
    Komeda handles the split in kernel completely to hide the detailed and
    complicated split calcualtion to user mode, for user only need to set the
    layer_split property to enable/disable it.
    
    v2: Rebase
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index 9d29820345b9..d1c58a88d9e2 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -45,7 +45,8 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
 		return -EINVAL;
 	}
 
-	dflow->en_img_enhancement = kplane_st->img_enhancement;
+	dflow->en_img_enhancement = !!kplane_st->img_enhancement;
+	dflow->en_split = !!kplane_st->layer_split;
 
 	komeda_complete_data_flow_cfg(dflow, fb);
 
@@ -91,7 +92,12 @@ komeda_plane_atomic_check(struct drm_plane *plane,
 	if (err)
 		return err;
 
-	err = komeda_build_layer_data_flow(layer, kplane_st, kcrtc_st, &dflow);
+	if (dflow.en_split)
+		err = komeda_build_layer_split_data_flow(layer,
+				kplane_st, kcrtc_st, &dflow);
+	else
+		err = komeda_build_layer_data_flow(layer,
+				kplane_st, kcrtc_st, &dflow);
 
 	return err;
 }
@@ -181,6 +187,8 @@ komeda_plane_atomic_get_property(struct drm_plane *plane,
 
 	if (property == kplane->prop_img_enhancement)
 		*val = st->img_enhancement;
+	else if (property == kplane->prop_layer_split)
+		*val = st->layer_split;
 	else
 		return -EINVAL;
 
@@ -198,6 +206,8 @@ komeda_plane_atomic_set_property(struct drm_plane *plane,
 
 	if (property == kplane->prop_img_enhancement)
 		st->img_enhancement = !!val;
+	else if (property == kplane->prop_layer_split)
+		st->layer_split = !!val;
 	else
 		return -EINVAL;
 
@@ -247,6 +257,16 @@ komeda_plane_create_layer_properties(struct komeda_plane *kplane,
 		kplane->prop_img_enhancement = prop;
 	}
 
+	/* property: layer split */
+	if (layer->right) {
+		prop = drm_property_create_bool(drm, DRM_MODE_PROP_ATOMIC,
+						"layer_split");
+		if (!prop)
+			return -ENOMEM;
+		kplane->prop_layer_split = prop;
+		drm_object_attach_property(&plane->base, prop, 0);
+	}
+
 	return 0;
 }
 

commit b35d0927d3b02ccef061113268c202b7b9fac695
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Mon Jun 10 11:16:02 2019 +0100

    drm/komeda: Add split support for scaler
    
    To achieve same caling effect compare with none split, the texel
    calculation need to use the same scaling ratio before split, so add
    "total_xxx" to pipeline to describe the hsize/vsize before split.
    Update pipeline and d71_scaler_update accordingly.
    
    v2: Rebase and addressed Liviu's comments
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index c0e381cee524..9d29820345b9 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -23,10 +23,7 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
 	memset(dflow, 0, sizeof(*dflow));
 
 	dflow->blending_zorder = st->normalized_zpos;
-
-	/* if format doesn't have alpha, fix blend mode to PIXEL_NONE */
-	dflow->pixel_blend_mode = fb->format->has_alpha ?
-			st->pixel_blend_mode : DRM_MODE_BLEND_PIXEL_NONE;
+	dflow->pixel_blend_mode = st->pixel_blend_mode;
 	dflow->layer_alpha = st->alpha >> 8;
 
 	dflow->out_x = st->crtc_x;
@@ -39,8 +36,6 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
 	dflow->in_w = st->src_w >> 16;
 	dflow->in_h = st->src_h >> 16;
 
-	dflow->en_img_enhancement = kplane_st->img_enhancement;
-
 	dflow->rot = drm_rotation_simplify(st->rotation, caps->supported_rots);
 	if (!has_bits(dflow->rot, caps->supported_rots)) {
 		DRM_DEBUG_ATOMIC("rotation(0x%x) isn't supported by %s.\n",
@@ -50,7 +45,9 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
 		return -EINVAL;
 	}
 
-	komeda_complete_data_flow_cfg(dflow);
+	dflow->en_img_enhancement = kplane_st->img_enhancement;
+
+	komeda_complete_data_flow_cfg(dflow, fb);
 
 	return 0;
 }

commit 109bd7d5f4c2db66541272e5a41aeabd6cfeef95
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Mon May 20 04:33:19 2019 +0100

    drm/komeda: Adds zorder support
    
    - Creates the zpos property.
    - Implement komeda_crtc_normalize_zpos to replace
    drm_atomic_normalize_zpos, reasons as the following:
    
    1. The drm_atomic_normalize_zpos allows to configure same zpos for
    different planes, but komeda doesn't support such configuration.
    2. For further slave pipline case, Komeda need to calculate the
    max_slave_zorder, we will merge such calculation into
    komed_crtc_normalize_zpos to save a separated plane_state loop.
    3. For feature none-scaling layer_split, which a plane_state will be
    assigned to two individual layers(left/right), which requires two
    normalize_zpos for this plane, plane_st->normalize_zpos will be used
    by left layer, normalize_zpos + 1 for right_layer.
    
    This patch series depends on:
    - https://patchwork.freedesktop.org/series/58710/
    - https://patchwork.freedesktop.org/series/59000/
    - https://patchwork.freedesktop.org/series/59002/
    - https://patchwork.freedesktop.org/series/59747/
    - https://patchwork.freedesktop.org/series/59915/
    - https://patchwork.freedesktop.org/series/60083/
    - https://patchwork.freedesktop.org/series/60698/
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index 9e049ee9014a..c0e381cee524 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -22,7 +22,7 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
 
 	memset(dflow, 0, sizeof(*dflow));
 
-	dflow->blending_zorder = st->zpos;
+	dflow->blending_zorder = st->normalized_zpos;
 
 	/* if format doesn't have alpha, fix blend mode to PIXEL_NONE */
 	dflow->pixel_blend_mode = fb->format->has_alpha ?
@@ -345,6 +345,10 @@ static int komeda_plane_add(struct komeda_kms_dev *kms,
 	if (err)
 		goto cleanup;
 
+	err = drm_plane_create_zpos_property(plane, layer->base.id, 0, 8);
+	if (err)
+		goto cleanup;
+
 	return 0;
 cleanup:
 	komeda_plane_destroy(plane);

commit 9682dee9822246c4ea3d320ff8c96afc54163c89
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Thu May 16 07:13:13 2019 +0100

    drm/komeda: Enable color-encoding (YUV format) support
    
    Adds color-encoding properties if layer can support YUV format.
    Updates HW YUV-RGB matrix state according to the color-encoding
    properties.
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index 9009f87b7323..9e049ee9014a 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -137,6 +137,8 @@ static void komeda_plane_reset(struct drm_plane *plane)
 		state->base.pixel_blend_mode = DRM_MODE_BLEND_PREMULTI;
 		state->base.alpha = DRM_BLEND_ALPHA_OPAQUE;
 		state->base.zpos = kplane->layer->base.id;
+		state->base.color_encoding = DRM_COLOR_YCBCR_BT601;
+		state->base.color_range = DRM_COLOR_YCBCR_LIMITED_RANGE;
 		plane->state = &state->base;
 		plane->state->plane = plane;
 	}
@@ -332,6 +334,17 @@ static int komeda_plane_add(struct komeda_kms_dev *kms,
 	if (err)
 		goto cleanup;
 
+	err = drm_plane_create_color_properties(plane,
+			BIT(DRM_COLOR_YCBCR_BT601) |
+			BIT(DRM_COLOR_YCBCR_BT709) |
+			BIT(DRM_COLOR_YCBCR_BT2020),
+			BIT(DRM_COLOR_YCBCR_LIMITED_RANGE) |
+			BIT(DRM_COLOR_YCBCR_FULL_RANGE),
+			DRM_COLOR_YCBCR_BT601,
+			DRM_COLOR_YCBCR_LIMITED_RANGE);
+	if (err)
+		goto cleanup;
+
 	return 0;
 cleanup:
 	komeda_plane_destroy(plane);

commit 19358630f3a570e7ced509a65c28693840d2ae65
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Mon Apr 22 04:16:30 2019 +0100

    drm/komeda: Adds limitation check for AFBC wide block not support Rot90
    
    Komeda series hardware doesn't support Rot90 for AFBC wide block. So
    add limitation check to reject it if such configuration has been posted.
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index e55b7be9bbb0..9009f87b7323 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -214,7 +214,7 @@ komeda_plane_format_mod_supported(struct drm_plane *plane,
 	u32 layer_type = kplane->layer->layer_type;
 
 	return komeda_format_mod_supported(&mdev->fmt_tbl, layer_type,
-					   format, modifier);
+					   format, modifier, 0);
 }
 
 static const struct drm_plane_funcs komeda_plane_funcs = {

commit 429bfabe00549c3a5db4d7d6aacd7852a1f53f12
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Mon Apr 22 04:16:26 2019 +0100

    drm/komeda: Add rotation support on Komeda driver
    
    - Adds rotation property to plane.
    - Komeda display rotation support diverges from the specific formats,
    so need to check the user required rotation type with the format caps
    and reject the commit if it can not be supported.
    - In the layer validate flow, sets the rotation value to the layer
    state. If r90 or r270, swap the width and height of the data flow
    for next stage.
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index b86a517cf92f..e55b7be9bbb0 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -10,6 +10,7 @@
 #include <drm/drm_print.h>
 #include "komeda_dev.h"
 #include "komeda_kms.h"
+#include "komeda_framebuffer.h"
 
 static int
 komeda_plane_init_data_flow(struct drm_plane_state *st,
@@ -17,6 +18,7 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
 {
 	struct komeda_plane_state *kplane_st = to_kplane_st(st);
 	struct drm_framebuffer *fb = st->fb;
+	const struct komeda_format_caps *caps = to_kfb(fb)->format_caps;
 
 	memset(dflow, 0, sizeof(*dflow));
 
@@ -39,6 +41,15 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
 
 	dflow->en_img_enhancement = kplane_st->img_enhancement;
 
+	dflow->rot = drm_rotation_simplify(st->rotation, caps->supported_rots);
+	if (!has_bits(dflow->rot, caps->supported_rots)) {
+		DRM_DEBUG_ATOMIC("rotation(0x%x) isn't supported by %s.\n",
+				 dflow->rot,
+				 komeda_get_format_name(caps->fourcc,
+							fb->modifier));
+		return -EINVAL;
+	}
+
 	komeda_complete_data_flow_cfg(dflow);
 
 	return 0;
@@ -301,6 +312,11 @@ static int komeda_plane_add(struct komeda_kms_dev *kms,
 
 	drm_plane_helper_add(plane, &komeda_plane_helper_funcs);
 
+	err = drm_plane_create_rotation_property(plane, DRM_MODE_ROTATE_0,
+						 layer->supported_rots);
+	if (err)
+		goto cleanup;
+
 	err = drm_plane_create_alpha_property(plane);
 	if (err)
 		goto cleanup;

commit 62ffc39320e6135235c659687324b393d4215300
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Fri May 24 10:20:24 2019 +0100

    drm/komeda: Creates plane alpha and blend mode properties
    
    Creates plane alpha and blend mode properties attached to plane.
    
    This patch depends on:
    - https://patchwork.freedesktop.org/series/59915/
    - https://patchwork.freedesktop.org/series/58665/
    - https://patchwork.freedesktop.org/series/59000/
    - https://patchwork.freedesktop.org/series/59002/
    - https://patchwork.freedesktop.org/series/59471/
    
    Changes since v1:
    - Adds patch denpendency in the comment
    
    Changes since v2:
    - Remove [RFC] from the subject
    
    Changes since v3:
    - Rebase the code
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index 94268f49e83e..b86a517cf92f 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -301,6 +301,17 @@ static int komeda_plane_add(struct komeda_kms_dev *kms,
 
 	drm_plane_helper_add(plane, &komeda_plane_helper_funcs);
 
+	err = drm_plane_create_alpha_property(plane);
+	if (err)
+		goto cleanup;
+
+	err = drm_plane_create_blend_mode_property(plane,
+			BIT(DRM_MODE_BLEND_PIXEL_NONE) |
+			BIT(DRM_MODE_BLEND_PREMULTI)   |
+			BIT(DRM_MODE_BLEND_COVERAGE));
+	if (err)
+		goto cleanup;
+
 	err = komeda_plane_create_layer_properties(kplane, layer);
 	if (err)
 		goto cleanup;

commit 42b6f118f6d11268d652ce4946fef25a2611c39d
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu May 23 12:10:27 2019 +0100

    drm/komeda: Add image enhancement support
    
    Besides scaling, Arm display scaler also can support image enhancement.
    For support it, Add a new property "img_enhancement" to plane, then user
    can turn on/off it by this property, and kernel follow user's requirement
    to maitain the state and enable/disable the real HW image enhancement.
    
    v2: Rebase and rename "needs_img_enhancement" to "en_img_enhancement"
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index d4f14ecf6e2a..94268f49e83e 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -15,6 +15,7 @@ static int
 komeda_plane_init_data_flow(struct drm_plane_state *st,
 			    struct komeda_data_flow_cfg *dflow)
 {
+	struct komeda_plane_state *kplane_st = to_kplane_st(st);
 	struct drm_framebuffer *fb = st->fb;
 
 	memset(dflow, 0, sizeof(*dflow));
@@ -23,7 +24,7 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
 
 	/* if format doesn't have alpha, fix blend mode to PIXEL_NONE */
 	dflow->pixel_blend_mode = fb->format->has_alpha ?
-		st->pixel_blend_mode : DRM_MODE_BLEND_PIXEL_NONE;
+			st->pixel_blend_mode : DRM_MODE_BLEND_PIXEL_NONE;
 	dflow->layer_alpha = st->alpha >> 8;
 
 	dflow->out_x = st->crtc_x;
@@ -36,6 +37,8 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
 	dflow->in_w = st->src_w >> 16;
 	dflow->in_h = st->src_h >> 16;
 
+	dflow->en_img_enhancement = kplane_st->img_enhancement;
+
 	komeda_complete_data_flow_cfg(dflow);
 
 	return 0;
@@ -131,7 +134,7 @@ static void komeda_plane_reset(struct drm_plane *plane)
 static struct drm_plane_state *
 komeda_plane_atomic_duplicate_state(struct drm_plane *plane)
 {
-	struct komeda_plane_state *new;
+	struct komeda_plane_state *new, *old;
 
 	if (WARN_ON(!plane->state))
 		return NULL;
@@ -142,6 +145,10 @@ komeda_plane_atomic_duplicate_state(struct drm_plane *plane)
 
 	__drm_atomic_helper_plane_duplicate_state(plane, &new->base);
 
+	old = to_kplane_st(plane->state);
+
+	new->img_enhancement = old->img_enhancement;
+
 	return &new->base;
 }
 
@@ -153,6 +160,40 @@ komeda_plane_atomic_destroy_state(struct drm_plane *plane,
 	kfree(to_kplane_st(state));
 }
 
+static int
+komeda_plane_atomic_get_property(struct drm_plane *plane,
+				 const struct drm_plane_state *state,
+				 struct drm_property *property,
+				 uint64_t *val)
+{
+	struct komeda_plane *kplane = to_kplane(plane);
+	struct komeda_plane_state *st = to_kplane_st(state);
+
+	if (property == kplane->prop_img_enhancement)
+		*val = st->img_enhancement;
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int
+komeda_plane_atomic_set_property(struct drm_plane *plane,
+				 struct drm_plane_state *state,
+				 struct drm_property *property,
+				 uint64_t val)
+{
+	struct komeda_plane *kplane = to_kplane(plane);
+	struct komeda_plane_state *st = to_kplane_st(state);
+
+	if (property == kplane->prop_img_enhancement)
+		st->img_enhancement = !!val;
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
 static bool
 komeda_plane_format_mod_supported(struct drm_plane *plane,
 				  u32 format, u64 modifier)
@@ -172,9 +213,33 @@ static const struct drm_plane_funcs komeda_plane_funcs = {
 	.reset			= komeda_plane_reset,
 	.atomic_duplicate_state	= komeda_plane_atomic_duplicate_state,
 	.atomic_destroy_state	= komeda_plane_atomic_destroy_state,
+	.atomic_get_property	= komeda_plane_atomic_get_property,
+	.atomic_set_property	= komeda_plane_atomic_set_property,
 	.format_mod_supported	= komeda_plane_format_mod_supported,
 };
 
+static int
+komeda_plane_create_layer_properties(struct komeda_plane *kplane,
+				     struct komeda_layer *layer)
+{
+	struct drm_device *drm = kplane->base.dev;
+	struct drm_plane *plane = &kplane->base;
+	struct drm_property *prop = NULL;
+
+	/* property: layer image_enhancement */
+	if (layer->base.supported_outputs & KOMEDA_PIPELINE_SCALERS) {
+		prop = drm_property_create_bool(drm, DRM_MODE_PROP_ATOMIC,
+						"img_enhancement");
+		if (!prop)
+			return -ENOMEM;
+
+		drm_object_attach_property(&plane->base, prop, 0);
+		kplane->prop_img_enhancement = prop;
+	}
+
+	return 0;
+}
+
 /* for komeda, which is pipeline can be share between crtcs */
 static u32 get_possible_crtcs(struct komeda_kms_dev *kms,
 			      struct komeda_pipeline *pipe)
@@ -236,6 +301,10 @@ static int komeda_plane_add(struct komeda_kms_dev *kms,
 
 	drm_plane_helper_add(plane, &komeda_plane_helper_funcs);
 
+	err = komeda_plane_create_layer_properties(kplane, layer);
+	if (err)
+		goto cleanup;
+
 	return 0;
 cleanup:
 	komeda_plane_destroy(plane);

commit d92b66b875024f6b2ae90543039e2c030f084fbc
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu May 23 12:10:15 2019 +0100

    drm/komeda: Add writeback scaling support
    
    1. Add scaler to writeback pipeline to enable the writeback scaling support
    2. Display HW can not do upscaling for writeback, check it when validate.
    
    v2: Rebase
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index d536c2884cfd..d4f14ecf6e2a 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -16,7 +16,6 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
 			    struct komeda_data_flow_cfg *dflow)
 {
 	struct drm_framebuffer *fb = st->fb;
-	u32 w, h;
 
 	memset(dflow, 0, sizeof(*dflow));
 
@@ -37,12 +36,7 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
 	dflow->in_w = st->src_w >> 16;
 	dflow->in_h = st->src_h >> 16;
 
-	w = dflow->in_w;
-	h = dflow->in_h;
-	if (drm_rotation_90_or_270(dflow->rot))
-		swap(w, h);
-
-	dflow->en_scaling = (w != dflow->out_w) || (h != dflow->out_h);
+	komeda_complete_data_flow_cfg(dflow);
 
 	return 0;
 }

commit 502932a03fceca1cb161eba5f30b18eb640aa8de
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu May 23 12:10:03 2019 +0100

    drm/komeda: Add the initial scaler support for CORE
    
    This patch add the initial and necessary logic for CORE to support scaler:
    - Complete the struct komeda_scaler and komeda_scaler_state for adding
      the scaler specific features and capablities.
    - Implement komeda_scaler_validate to check the scaler with the data flow
      configurations.
    - Enable scaling support for plane input path (layer input data flow).
    
    v2: Fix a typo, and rename "needs_scaling" to "en_scaling"
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index 7516660131d5..d536c2884cfd 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -16,6 +16,7 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
 			    struct komeda_data_flow_cfg *dflow)
 {
 	struct drm_framebuffer *fb = st->fb;
+	u32 w, h;
 
 	memset(dflow, 0, sizeof(*dflow));
 
@@ -36,6 +37,13 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
 	dflow->in_w = st->src_w >> 16;
 	dflow->in_h = st->src_h >> 16;
 
+	w = dflow->in_w;
+	h = dflow->in_h;
+	if (drm_rotation_90_or_270(dflow->rot))
+		swap(w, h);
+
+	dflow->en_scaling = (w != dflow->out_w) || (h != dflow->out_h);
+
 	return 0;
 }
 

commit 65ad2392dd6d1691db93e82b08d3311298b9d64a
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu May 23 10:56:54 2019 +0100

    drm/komeda: Added AFBC support for komeda driver
    
    For supporting AFBC:
    1. Check if the user requested modifier can be supported by display HW.
    2. Check the obj->size with AFBC's requirement.
    3. Configure HW according to the modifier (afbc features)
    
    This patch depends on:
    - https://patchwork.freedesktop.org/series/59915/
    - https://patchwork.freedesktop.org/series/59000/
    
    v2: Rebase and addressed Ayan's comments
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index c97062bdd69b..7516660131d5 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -151,6 +151,18 @@ komeda_plane_atomic_destroy_state(struct drm_plane *plane,
 	kfree(to_kplane_st(state));
 }
 
+static bool
+komeda_plane_format_mod_supported(struct drm_plane *plane,
+				  u32 format, u64 modifier)
+{
+	struct komeda_dev *mdev = plane->dev->dev_private;
+	struct komeda_plane *kplane = to_kplane(plane);
+	u32 layer_type = kplane->layer->layer_type;
+
+	return komeda_format_mod_supported(&mdev->fmt_tbl, layer_type,
+					   format, modifier);
+}
+
 static const struct drm_plane_funcs komeda_plane_funcs = {
 	.update_plane		= drm_atomic_helper_update_plane,
 	.disable_plane		= drm_atomic_helper_disable_plane,
@@ -158,6 +170,7 @@ static const struct drm_plane_funcs komeda_plane_funcs = {
 	.reset			= komeda_plane_reset,
 	.atomic_duplicate_state	= komeda_plane_atomic_duplicate_state,
 	.atomic_destroy_state	= komeda_plane_atomic_destroy_state,
+	.format_mod_supported	= komeda_plane_format_mod_supported,
 };
 
 /* for komeda, which is pipeline can be share between crtcs */
@@ -210,7 +223,7 @@ static int komeda_plane_add(struct komeda_kms_dev *kms,
 	err = drm_universal_plane_init(&kms->base, plane,
 			get_possible_crtcs(kms, c->pipeline),
 			&komeda_plane_funcs,
-			formats, n_formats, NULL,
+			formats, n_formats, komeda_supported_modifiers,
 			get_plane_type(kms, c),
 			"%s", c->name);
 

commit 6d10dc617b4128c06fc2a88b47fda0a183ffe36c
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri May 3 15:25:25 2019 +0300

    drm/komeda: Potential error pointer dereference
    
    We need to check whether drm_atomic_get_crtc_state() returns an error
    pointer before dereferencing "crtc_st".
    
    Fixes: 9e5603094176 ("drm/komeda: Add komeda_plane/plane_helper_funcs")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: "james qian wang (Arm Technology China)" <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index 0753892b98d2..c97062bdd69b 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -63,7 +63,7 @@ komeda_plane_atomic_check(struct drm_plane *plane,
 		return 0;
 
 	crtc_st = drm_atomic_get_crtc_state(state->state, state->crtc);
-	if (!crtc_st->enable) {
+	if (IS_ERR(crtc_st) || !crtc_st->enable) {
 		DRM_DEBUG_ATOMIC("Cannot update plane on a disabled CRTC.\n");
 		return -EINVAL;
 	}

commit 7cb8bec205258601af2810f4f1998a207340e73c
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Sat Apr 27 00:42:02 2019 +0800

    drm/komeda: remove set but not used variable 'kcrtc'
    
    Fixes gcc '-Wunused-but-set-variable' warning:
    
    drivers/gpu/drm/arm/display/komeda/komeda_plane.c: In function komeda_plane_atomic_check:
    drivers/gpu/drm/arm/display/komeda/komeda_plane.c:49:22: warning: variable kcrtc set but not used [-Wunused-but-set-variable]
    
    It is never used since introduction in
    commit 9e5603094176 ("drm/komeda: Add komeda_plane/plane_helper_funcs")
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index 07ed0cc1bc44..0753892b98d2 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -55,7 +55,6 @@ komeda_plane_atomic_check(struct drm_plane *plane,
 	struct komeda_plane_state *kplane_st = to_kplane_st(state);
 	struct komeda_layer *layer = kplane->layer;
 	struct drm_crtc_state *crtc_st;
-	struct komeda_crtc *kcrtc;
 	struct komeda_crtc_state *kcrtc_st;
 	struct komeda_data_flow_cfg dflow;
 	int err;
@@ -73,7 +72,6 @@ komeda_plane_atomic_check(struct drm_plane *plane,
 	if (!crtc_st->active)
 		return 0;
 
-	kcrtc = to_kcrtc(state->crtc);
 	kcrtc_st = to_kcrtc_st(crtc_st);
 
 	err = komeda_plane_init_data_flow(state, &dflow);

commit 15e9122d9b5c745024f2d9d5653caed1f37c185f
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Wed Apr 24 06:51:45 2019 +0100

    drm/komeda: Mark the local functions as static
    
    Fix the kbuild test rebot reported warnings:
    - symbol was not declared. Should it be static?
    - missing braces around initializer
    
    Depends on:
    - https://patchwork.freedesktop.org/series/58976/
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index 46654f0be73d..07ed0cc1bc44 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -47,8 +47,9 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
  * RETURNS:
  * Zero for success or -errno
  */
-int komeda_plane_atomic_check(struct drm_plane *plane,
-			      struct drm_plane_state *state)
+static int
+komeda_plane_atomic_check(struct drm_plane *plane,
+			  struct drm_plane_state *state)
 {
 	struct komeda_plane *kplane = to_kplane(plane);
 	struct komeda_plane_state *kplane_st = to_kplane_st(state);
@@ -87,8 +88,9 @@ int komeda_plane_atomic_check(struct drm_plane *plane,
 /* plane doesn't represent a real HW, so there is no HW update for plane.
  * komeda handles all the HW update in crtc->atomic_flush
  */
-void komeda_plane_atomic_update(struct drm_plane *plane,
-				struct drm_plane_state *old_state)
+static void
+komeda_plane_atomic_update(struct drm_plane *plane,
+			   struct drm_plane_state *old_state)
 {
 }
 

commit 8c919745ee1c4d8d811a1e015d637d17aa78fe26
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Wed Apr 24 06:48:11 2019 +0100

    drm/komeda: Fixed warning: Function parameter or member not described
    
    Fixed the warnings: Function parameter or member 'xxx' not described
    when make htmldocs
    
    This patch depends on:
    - https://patchwork.freedesktop.org/series/54448/
    - https://patchwork.freedesktop.org/series/54449/
    - https://patchwork.freedesktop.org/series/54450/
    
    v2: Rebase and add reporter
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index ffcd3d08b5d3..46654f0be73d 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -39,6 +39,14 @@ komeda_plane_init_data_flow(struct drm_plane_state *st,
 	return 0;
 }
 
+/**
+ * komeda_plane_atomic_check - build input data flow
+ * @plane: DRM plane
+ * @state: the plane state object
+ *
+ * RETURNS:
+ * Zero for success or -errno
+ */
 int komeda_plane_atomic_check(struct drm_plane *plane,
 			      struct drm_plane_state *state)
 {

commit 9e560309417638507398fd6239e04f47cc907f70
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 11:06:22 2019 +0000

    drm/komeda: Add komeda_plane/plane_helper_funcs
    
    Per komeda design KMS-plane maps to komeda layer input pipeline.
    komeda_plane_atomic_check is for building a komeda layer input pipeline.
    
    And KMS-plane is only a user of komeda resources. so there is no real HW
    update for plane, but all HW update will be handled in crtc->flush.
    
    v2: Rebase
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
index 0a4953a9a909..ffcd3d08b5d3 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -7,10 +7,86 @@
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_plane_helper.h>
+#include <drm/drm_print.h>
 #include "komeda_dev.h"
 #include "komeda_kms.h"
 
+static int
+komeda_plane_init_data_flow(struct drm_plane_state *st,
+			    struct komeda_data_flow_cfg *dflow)
+{
+	struct drm_framebuffer *fb = st->fb;
+
+	memset(dflow, 0, sizeof(*dflow));
+
+	dflow->blending_zorder = st->zpos;
+
+	/* if format doesn't have alpha, fix blend mode to PIXEL_NONE */
+	dflow->pixel_blend_mode = fb->format->has_alpha ?
+		st->pixel_blend_mode : DRM_MODE_BLEND_PIXEL_NONE;
+	dflow->layer_alpha = st->alpha >> 8;
+
+	dflow->out_x = st->crtc_x;
+	dflow->out_y = st->crtc_y;
+	dflow->out_w = st->crtc_w;
+	dflow->out_h = st->crtc_h;
+
+	dflow->in_x = st->src_x >> 16;
+	dflow->in_y = st->src_y >> 16;
+	dflow->in_w = st->src_w >> 16;
+	dflow->in_h = st->src_h >> 16;
+
+	return 0;
+}
+
+int komeda_plane_atomic_check(struct drm_plane *plane,
+			      struct drm_plane_state *state)
+{
+	struct komeda_plane *kplane = to_kplane(plane);
+	struct komeda_plane_state *kplane_st = to_kplane_st(state);
+	struct komeda_layer *layer = kplane->layer;
+	struct drm_crtc_state *crtc_st;
+	struct komeda_crtc *kcrtc;
+	struct komeda_crtc_state *kcrtc_st;
+	struct komeda_data_flow_cfg dflow;
+	int err;
+
+	if (!state->crtc || !state->fb)
+		return 0;
+
+	crtc_st = drm_atomic_get_crtc_state(state->state, state->crtc);
+	if (!crtc_st->enable) {
+		DRM_DEBUG_ATOMIC("Cannot update plane on a disabled CRTC.\n");
+		return -EINVAL;
+	}
+
+	/* crtc is inactive, skip the resource assignment */
+	if (!crtc_st->active)
+		return 0;
+
+	kcrtc = to_kcrtc(state->crtc);
+	kcrtc_st = to_kcrtc_st(crtc_st);
+
+	err = komeda_plane_init_data_flow(state, &dflow);
+	if (err)
+		return err;
+
+	err = komeda_build_layer_data_flow(layer, kplane_st, kcrtc_st, &dflow);
+
+	return err;
+}
+
+/* plane doesn't represent a real HW, so there is no HW update for plane.
+ * komeda handles all the HW update in crtc->atomic_flush
+ */
+void komeda_plane_atomic_update(struct drm_plane *plane,
+				struct drm_plane_state *old_state)
+{
+}
+
 static const struct drm_plane_helper_funcs komeda_plane_helper_funcs = {
+	.atomic_check	= komeda_plane_atomic_check,
+	.atomic_update	= komeda_plane_atomic_update,
 };
 
 static void komeda_plane_destroy(struct drm_plane *plane)
@@ -20,7 +96,60 @@ static void komeda_plane_destroy(struct drm_plane *plane)
 	kfree(to_kplane(plane));
 }
 
+static void komeda_plane_reset(struct drm_plane *plane)
+{
+	struct komeda_plane_state *state;
+	struct komeda_plane *kplane = to_kplane(plane);
+
+	if (plane->state)
+		__drm_atomic_helper_plane_destroy_state(plane->state);
+
+	kfree(plane->state);
+	plane->state = NULL;
+
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (state) {
+		state->base.rotation = DRM_MODE_ROTATE_0;
+		state->base.pixel_blend_mode = DRM_MODE_BLEND_PREMULTI;
+		state->base.alpha = DRM_BLEND_ALPHA_OPAQUE;
+		state->base.zpos = kplane->layer->base.id;
+		plane->state = &state->base;
+		plane->state->plane = plane;
+	}
+}
+
+static struct drm_plane_state *
+komeda_plane_atomic_duplicate_state(struct drm_plane *plane)
+{
+	struct komeda_plane_state *new;
+
+	if (WARN_ON(!plane->state))
+		return NULL;
+
+	new = kzalloc(sizeof(*new), GFP_KERNEL);
+	if (!new)
+		return NULL;
+
+	__drm_atomic_helper_plane_duplicate_state(plane, &new->base);
+
+	return &new->base;
+}
+
+static void
+komeda_plane_atomic_destroy_state(struct drm_plane *plane,
+				  struct drm_plane_state *state)
+{
+	__drm_atomic_helper_plane_destroy_state(state);
+	kfree(to_kplane_st(state));
+}
+
 static const struct drm_plane_funcs komeda_plane_funcs = {
+	.update_plane		= drm_atomic_helper_update_plane,
+	.disable_plane		= drm_atomic_helper_disable_plane,
+	.destroy		= komeda_plane_destroy,
+	.reset			= komeda_plane_reset,
+	.atomic_duplicate_state	= komeda_plane_atomic_duplicate_state,
+	.atomic_destroy_state	= komeda_plane_atomic_destroy_state,
 };
 
 /* for komeda, which is pipeline can be share between crtcs */

commit 61f1c4a8ab7575c0147ae6c0d220f9719fdc741e
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu Jan 3 11:41:30 2019 +0000

    drm/komeda: Attach komeda_dev to DRM-KMS
    
    Add komeda_kms abstracton to attach komeda_dev to DRM-KMS
      CRTC: according to the komeda_pipeline
      PLANE: according to komeda_layer (layer input pipeline)
      PRIVATE_OBJS: komeda_pipeline/component all will be treat as private_objs
    
    komeda_kms is for connecting DRM-KMS and komeda_dev, like reporting the
    kms object properties according to the komeda_dev, and pass/convert KMS's
    requirement to komeda_dev.
    
    Changes in v4:
    - Set drm_atomic_helper_check as mode_config->atomic_check.
    
    Changes in v3:
    - Fixed style problem found by checkpatch.pl --strict.
    
    Changes in v2:
    - Unified abbreviation of "pipeline" to "pipe".
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Reviewed-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_plane.c b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
new file mode 100644
index 000000000000..0a4953a9a909
--- /dev/null
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_plane.c
@@ -0,0 +1,109 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * (C) COPYRIGHT 2018 ARM Limited. All rights reserved.
+ * Author: James.Qian.Wang <james.qian.wang@arm.com>
+ *
+ */
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_plane_helper.h>
+#include "komeda_dev.h"
+#include "komeda_kms.h"
+
+static const struct drm_plane_helper_funcs komeda_plane_helper_funcs = {
+};
+
+static void komeda_plane_destroy(struct drm_plane *plane)
+{
+	drm_plane_cleanup(plane);
+
+	kfree(to_kplane(plane));
+}
+
+static const struct drm_plane_funcs komeda_plane_funcs = {
+};
+
+/* for komeda, which is pipeline can be share between crtcs */
+static u32 get_possible_crtcs(struct komeda_kms_dev *kms,
+			      struct komeda_pipeline *pipe)
+{
+	struct komeda_crtc *crtc;
+	u32 possible_crtcs = 0;
+	int i;
+
+	for (i = 0; i < kms->n_crtcs; i++) {
+		crtc = &kms->crtcs[i];
+
+		if ((pipe == crtc->master) || (pipe == crtc->slave))
+			possible_crtcs |= BIT(i);
+	}
+
+	return possible_crtcs;
+}
+
+/* use Layer0 as primary */
+static u32 get_plane_type(struct komeda_kms_dev *kms,
+			  struct komeda_component *c)
+{
+	bool is_primary = (c->id == KOMEDA_COMPONENT_LAYER0);
+
+	return is_primary ? DRM_PLANE_TYPE_PRIMARY : DRM_PLANE_TYPE_OVERLAY;
+}
+
+static int komeda_plane_add(struct komeda_kms_dev *kms,
+			    struct komeda_layer *layer)
+{
+	struct komeda_dev *mdev = kms->base.dev_private;
+	struct komeda_component *c = &layer->base;
+	struct komeda_plane *kplane;
+	struct drm_plane *plane;
+	u32 *formats, n_formats = 0;
+	int err;
+
+	kplane = kzalloc(sizeof(*kplane), GFP_KERNEL);
+	if (!kplane)
+		return -ENOMEM;
+
+	plane = &kplane->base;
+	kplane->layer = layer;
+
+	formats = komeda_get_layer_fourcc_list(&mdev->fmt_tbl,
+					       layer->layer_type, &n_formats);
+
+	err = drm_universal_plane_init(&kms->base, plane,
+			get_possible_crtcs(kms, c->pipeline),
+			&komeda_plane_funcs,
+			formats, n_formats, NULL,
+			get_plane_type(kms, c),
+			"%s", c->name);
+
+	komeda_put_fourcc_list(formats);
+
+	if (err)
+		goto cleanup;
+
+	drm_plane_helper_add(plane, &komeda_plane_helper_funcs);
+
+	return 0;
+cleanup:
+	komeda_plane_destroy(plane);
+	return err;
+}
+
+int komeda_kms_add_planes(struct komeda_kms_dev *kms, struct komeda_dev *mdev)
+{
+	struct komeda_pipeline *pipe;
+	int i, j, err;
+
+	for (i = 0; i < mdev->n_pipelines; i++) {
+		pipe = mdev->pipelines[i];
+
+		for (j = 0; j < pipe->n_layers; j++) {
+			err = komeda_plane_add(kms, pipe->layers[j]);
+			if (err)
+				return err;
+		}
+	}
+
+	return 0;
+}
