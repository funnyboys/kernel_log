commit efb4650885187425f1da96460e5d2a84650f861a
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu Dec 12 07:48:13 2019 +0000

    drm/komeda: Add runtime_pm support
    
    - Add pm_runtime_get/put to crtc_enable/disable along with the real
      display usage
    - Add runtime_get/put to register_show, since register_show() will
      access register, need to wakeup HW.
    - For the case that PM is not enabled or configured, manually wakeup HW
    
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Reviewed-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191212074756.14678-1-james.qian.wang@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 38b832804bad..1d767473ba8a 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -10,6 +10,7 @@
 #include <linux/of_graph.h>
 #include <linux/of_reserved_mem.h>
 #include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
 #include <linux/dma-mapping.h>
 #ifdef CONFIG_DEBUG_FS
 #include <linux/debugfs.h>
@@ -27,12 +28,16 @@ static int komeda_register_show(struct seq_file *sf, void *x)
 
 	seq_puts(sf, "\n====== Komeda register dump =========\n");
 
+	pm_runtime_get_sync(mdev->dev);
+
 	if (mdev->funcs->dump_register)
 		mdev->funcs->dump_register(mdev, sf);
 
 	for (i = 0; i < mdev->n_pipelines; i++)
 		komeda_pipeline_dump_register(mdev->pipelines[i], sf);
 
+	pm_runtime_put(mdev->dev);
+
 	return 0;
 }
 
@@ -263,15 +268,6 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 	if (!mdev->iommu)
 		DRM_INFO("continue without IOMMU support!\n");
 
-	if (mdev->iommu && mdev->funcs->connect_iommu) {
-		err = mdev->funcs->connect_iommu(mdev);
-		if (err) {
-			DRM_ERROR("connect iommu failed.\n");
-			mdev->iommu = NULL;
-			goto disable_clk;
-		}
-	}
-
 	clk_disable_unprepare(mdev->aclk);
 
 	err = sysfs_create_group(&dev->kobj, &komeda_sysfs_attr_group);
@@ -310,11 +306,6 @@ void komeda_dev_destroy(struct komeda_dev *mdev)
 	if (mdev->aclk)
 		clk_prepare_enable(mdev->aclk);
 
-	if (mdev->iommu && mdev->funcs->disconnect_iommu)
-		if (mdev->funcs->disconnect_iommu(mdev))
-			DRM_ERROR("disconnect iommu failed.\n");
-	mdev->iommu = NULL;
-
 	for (i = 0; i < mdev->n_pipelines; i++) {
 		komeda_pipeline_destroy(mdev, mdev->pipelines[i]);
 		mdev->pipelines[i] = NULL;
@@ -343,44 +334,26 @@ void komeda_dev_destroy(struct komeda_dev *mdev)
 
 int komeda_dev_resume(struct komeda_dev *mdev)
 {
-	int ret = 0;
-
 	clk_prepare_enable(mdev->aclk);
 
-	if (mdev->iommu && mdev->funcs->connect_iommu) {
-		ret = mdev->funcs->connect_iommu(mdev);
-		if (ret < 0) {
-			DRM_ERROR("connect iommu failed.\n");
-			goto disable_clk;
-		}
-	}
-
-	ret = mdev->funcs->enable_irq(mdev);
+	mdev->funcs->enable_irq(mdev);
 
-disable_clk:
-	clk_disable_unprepare(mdev->aclk);
+	if (mdev->iommu && mdev->funcs->connect_iommu)
+		if (mdev->funcs->connect_iommu(mdev))
+			DRM_ERROR("connect iommu failed.\n");
 
-	return ret;
+	return 0;
 }
 
 int komeda_dev_suspend(struct komeda_dev *mdev)
 {
-	int ret = 0;
-
-	clk_prepare_enable(mdev->aclk);
-
-	if (mdev->iommu && mdev->funcs->disconnect_iommu) {
-		ret = mdev->funcs->disconnect_iommu(mdev);
-		if (ret < 0) {
+	if (mdev->iommu && mdev->funcs->disconnect_iommu)
+		if (mdev->funcs->disconnect_iommu(mdev))
 			DRM_ERROR("disconnect iommu failed.\n");
-			goto disable_clk;
-		}
-	}
 
-	ret = mdev->funcs->disable_irq(mdev);
+	mdev->funcs->disable_irq(mdev);
 
-disable_clk:
 	clk_disable_unprepare(mdev->aclk);
 
-	return ret;
+	return 0;
 }

commit b25bc78f8a0750125604e6b82650eb6e990cb09d
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Dec 10 08:48:46 2019 +0000

    drm/komeda: Update the chip identify
    
    1. Drop komeda-CORE product id comparison and put it into the d71_identify
    2. Update pipeline node DT-binding:
       (a). Skip the needless pipeline DT node.
       (b). Return fail if the essential pipeline DT node is missing.
    
    With these changes, for chips in same family no need to change the DT.
    
    v2: Rebase
    v3: Address Mihail's comments.
    
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Reviewed-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191210084828.19664-2-james.qian.wang@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 4e46f650fddf..38b832804bad 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -115,22 +115,14 @@ static struct attribute_group komeda_sysfs_attr_group = {
 	.attrs = komeda_sysfs_entries,
 };
 
-static int komeda_parse_pipe_dt(struct komeda_dev *mdev, struct device_node *np)
+static int komeda_parse_pipe_dt(struct komeda_pipeline *pipe)
 {
-	struct komeda_pipeline *pipe;
+	struct device_node *np = pipe->of_node;
 	struct clk *clk;
-	u32 pipe_id;
-	int ret = 0;
-
-	ret = of_property_read_u32(np, "reg", &pipe_id);
-	if (ret != 0 || pipe_id >= mdev->n_pipelines)
-		return -EINVAL;
-
-	pipe = mdev->pipelines[pipe_id];
 
 	clk = of_clk_get_by_name(np, "pxclk");
 	if (IS_ERR(clk)) {
-		DRM_ERROR("get pxclk for pipeline %d failed!\n", pipe_id);
+		DRM_ERROR("get pxclk for pipeline %d failed!\n", pipe->id);
 		return PTR_ERR(clk);
 	}
 	pipe->pxlclk = clk;
@@ -144,7 +136,6 @@ static int komeda_parse_pipe_dt(struct komeda_dev *mdev, struct device_node *np)
 		of_graph_get_port_by_id(np, KOMEDA_OF_PORT_OUTPUT);
 
 	pipe->dual_link = pipe->of_output_links[0] && pipe->of_output_links[1];
-	pipe->of_node = of_node_get(np);
 
 	return 0;
 }
@@ -153,7 +144,9 @@ static int komeda_parse_dt(struct device *dev, struct komeda_dev *mdev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct device_node *child, *np = dev->of_node;
-	int ret;
+	struct komeda_pipeline *pipe;
+	u32 pipe_id = U32_MAX;
+	int ret = -1;
 
 	mdev->irq  = platform_get_irq(pdev, 0);
 	if (mdev->irq < 0) {
@@ -168,28 +161,42 @@ static int komeda_parse_dt(struct device *dev, struct komeda_dev *mdev)
 	ret = 0;
 
 	for_each_available_child_of_node(np, child) {
-		if (of_node_cmp(child->name, "pipeline") == 0) {
-			ret = komeda_parse_pipe_dt(mdev, child);
-			if (ret) {
-				DRM_ERROR("parse pipeline dt error!\n");
-				of_node_put(child);
-				break;
+		if (of_node_name_eq(child, "pipeline")) {
+			of_property_read_u32(child, "reg", &pipe_id);
+			if (pipe_id >= mdev->n_pipelines) {
+				DRM_WARN("Skip the redundant DT node: pipeline-%u.\n",
+					 pipe_id);
+				continue;
 			}
+			mdev->pipelines[pipe_id]->of_node = of_node_get(child);
 		}
 	}
 
-	return ret;
+	for (pipe_id = 0; pipe_id < mdev->n_pipelines; pipe_id++) {
+		pipe = mdev->pipelines[pipe_id];
+
+		if (!pipe->of_node) {
+			DRM_ERROR("Pipeline-%d doesn't have a DT node.\n",
+				  pipe->id);
+			return -EINVAL;
+		}
+		ret = komeda_parse_pipe_dt(pipe);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
 }
 
 struct komeda_dev *komeda_dev_create(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	const struct komeda_product_data *product;
+	komeda_identify_func komeda_identify;
 	struct komeda_dev *mdev;
 	int err = 0;
 
-	product = of_device_get_match_data(dev);
-	if (!product)
+	komeda_identify = of_device_get_match_data(dev);
+	if (!komeda_identify)
 		return ERR_PTR(-ENODEV);
 
 	mdev = devm_kzalloc(dev, sizeof(*mdev), GFP_KERNEL);
@@ -217,11 +224,9 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 
 	clk_prepare_enable(mdev->aclk);
 
-	mdev->funcs = product->identify(mdev->reg_base, &mdev->chip);
-	if (!komeda_product_match(mdev, product->product_id)) {
-		DRM_ERROR("DT configured %x mismatch with real HW %x.\n",
-			  product->product_id,
-			  MALIDP_CORE_ID_PRODUCT_ID(mdev->chip.core_id));
+	mdev->funcs = komeda_identify(mdev->reg_base, &mdev->chip);
+	if (!mdev->funcs) {
+		DRM_ERROR("Failed to identify the HW.\n");
 		err = -ENODEV;
 		goto disable_clk;
 	}

commit 8894cd5824e500c530db5f6f399d22edbcddea73
Author: Mihail Atanassov <Mihail.Atanassov@arm.com>
Date:   Thu Nov 7 11:42:28 2019 +0000

    drm/komeda: Add debugfs node to control error verbosity
    
    Named 'err_verbosity', currently with only 1 active bit in that
    replicates the existing level - print error events once per flip.
    
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191107114155.54307-2-mihail.atanassov@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 14d5c5da9e3b..4e46f650fddf 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -58,6 +58,8 @@ static void komeda_debugfs_init(struct komeda_dev *mdev)
 	mdev->debugfs_root = debugfs_create_dir("komeda", NULL);
 	debugfs_create_file("register", 0444, mdev->debugfs_root,
 			    mdev, &komeda_register_fops);
+	debugfs_create_x16("err_verbosity", 0664, mdev->debugfs_root,
+			   &mdev->err_verbosity);
 }
 #endif
 
@@ -273,6 +275,8 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 		goto err_cleanup;
 	}
 
+	mdev->err_verbosity = KOMEDA_DEV_PRINT_ERR_EVENTS;
+
 #ifdef CONFIG_DEBUG_FS
 	komeda_debugfs_init(mdev);
 #endif

commit 50ec5b563bed04b0b262822b755f6aa336f1f40a
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Sep 21 19:43:51 2019 +0200

    drm/komeda: Use devm_platform_ioremap_resource() in komeda_dev_create()
    
    Simplify this function implementation by using a known wrapper function.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/64a6ea39-3e4b-2ebe-74f7-98720e581e3e@web.de

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 937a6d4c4865..14d5c5da9e3b 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -184,19 +184,12 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	const struct komeda_product_data *product;
 	struct komeda_dev *mdev;
-	struct resource *io_res;
 	int err = 0;
 
 	product = of_device_get_match_data(dev);
 	if (!product)
 		return ERR_PTR(-ENODEV);
 
-	io_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!io_res) {
-		DRM_ERROR("No registers defined.\n");
-		return ERR_PTR(-ENODEV);
-	}
-
 	mdev = devm_kzalloc(dev, sizeof(*mdev), GFP_KERNEL);
 	if (!mdev)
 		return ERR_PTR(-ENOMEM);
@@ -204,7 +197,7 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 	mutex_init(&mdev->lock);
 
 	mdev->dev = dev;
-	mdev->reg_base = devm_ioremap_resource(dev, io_res);
+	mdev->reg_base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(mdev->reg_base)) {
 		DRM_ERROR("Map register space failed.\n");
 		err = PTR_ERR(mdev->reg_base);

commit 4092de1ba34eb376791809fb366bc15f8a9e0b7c
Merge: a00d17e0a71a 54ecb8f7028c
Author: Maxime Ripard <mripard@kernel.org>
Date:   Thu Oct 3 16:38:50 2019 +0200

    Merge drm/drm-next into drm-misc-next
    
    We haven't done any backmerge for a while due to the merge window, and it
    starts to become an issue for komeda. Let's bring 5.4-rc1 in.
    
    Signed-off-by: Maxime Ripard <mripard@kernel.org>

commit 2ebb6701654e0d625eac6c32832d72f8e875c01a
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Mon Sep 23 01:59:25 2019 +0000

    drm/komeda: Adds power management support
    
    Adds system power management support in KMS kernel driver.
    
    Depends on:
    https://patchwork.freedesktop.org/series/62377/
    
    Changes since v1:
    Since we have unified mclk/pclk/pipeline->aclk to one mclk, which will
    be turned on/off when crtc atomic enable/disable, removed runtime power
    management.
    Removes run time get/put related flow.
    Adds to disable the aclk when register access finished.
    
    Changes since v2:
    Rebases to the drm-misc-next branch.
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190923015908.26627-1-lowry.li@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 9cbcd56e54cd..b5f960bc2277 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -228,7 +228,7 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 			  product->product_id,
 			  MALIDP_CORE_ID_PRODUCT_ID(mdev->chip.core_id));
 		err = -ENODEV;
-		goto err_cleanup;
+		goto disable_clk;
 	}
 
 	DRM_INFO("Found ARM Mali-D%x version r%dp%d\n",
@@ -241,19 +241,19 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 	err = mdev->funcs->enum_resources(mdev);
 	if (err) {
 		DRM_ERROR("enumerate display resource failed.\n");
-		goto err_cleanup;
+		goto disable_clk;
 	}
 
 	err = komeda_parse_dt(dev, mdev);
 	if (err) {
 		DRM_ERROR("parse device tree failed.\n");
-		goto err_cleanup;
+		goto disable_clk;
 	}
 
 	err = komeda_assemble_pipelines(mdev);
 	if (err) {
 		DRM_ERROR("assemble display pipelines failed.\n");
-		goto err_cleanup;
+		goto disable_clk;
 	}
 
 	dev->dma_parms = &mdev->dma_parms;
@@ -266,11 +266,14 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 	if (mdev->iommu && mdev->funcs->connect_iommu) {
 		err = mdev->funcs->connect_iommu(mdev);
 		if (err) {
+			DRM_ERROR("connect iommu failed.\n");
 			mdev->iommu = NULL;
-			goto err_cleanup;
+			goto disable_clk;
 		}
 	}
 
+	clk_disable_unprepare(mdev->aclk);
+
 	err = sysfs_create_group(&dev->kobj, &komeda_sysfs_attr_group);
 	if (err) {
 		DRM_ERROR("create sysfs group failed.\n");
@@ -283,6 +286,8 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 
 	return mdev;
 
+disable_clk:
+	clk_disable_unprepare(mdev->aclk);
 err_cleanup:
 	komeda_dev_destroy(mdev);
 	return ERR_PTR(err);
@@ -300,8 +305,12 @@ void komeda_dev_destroy(struct komeda_dev *mdev)
 	debugfs_remove_recursive(mdev->debugfs_root);
 #endif
 
+	if (mdev->aclk)
+		clk_prepare_enable(mdev->aclk);
+
 	if (mdev->iommu && mdev->funcs->disconnect_iommu)
-		mdev->funcs->disconnect_iommu(mdev);
+		if (mdev->funcs->disconnect_iommu(mdev))
+			DRM_ERROR("disconnect iommu failed.\n");
 	mdev->iommu = NULL;
 
 	for (i = 0; i < mdev->n_pipelines; i++) {
@@ -329,3 +338,47 @@ void komeda_dev_destroy(struct komeda_dev *mdev)
 
 	devm_kfree(dev, mdev);
 }
+
+int komeda_dev_resume(struct komeda_dev *mdev)
+{
+	int ret = 0;
+
+	clk_prepare_enable(mdev->aclk);
+
+	if (mdev->iommu && mdev->funcs->connect_iommu) {
+		ret = mdev->funcs->connect_iommu(mdev);
+		if (ret < 0) {
+			DRM_ERROR("connect iommu failed.\n");
+			goto disable_clk;
+		}
+	}
+
+	ret = mdev->funcs->enable_irq(mdev);
+
+disable_clk:
+	clk_disable_unprepare(mdev->aclk);
+
+	return ret;
+}
+
+int komeda_dev_suspend(struct komeda_dev *mdev)
+{
+	int ret = 0;
+
+	clk_prepare_enable(mdev->aclk);
+
+	if (mdev->iommu && mdev->funcs->disconnect_iommu) {
+		ret = mdev->funcs->disconnect_iommu(mdev);
+		if (ret < 0) {
+			DRM_ERROR("disconnect iommu failed.\n");
+			goto disable_clk;
+		}
+	}
+
+	ret = mdev->funcs->disable_irq(mdev);
+
+disable_clk:
+	clk_disable_unprepare(mdev->aclk);
+
+	return ret;
+}

commit 574cc4539762561d96b456dbc0544d8898bd4c6e
Merge: 3c2edc36a774 945b584c94f8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 19 16:24:24 2019 -0700

    Merge tag 'drm-next-2019-09-18' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Dave Airlie:
     "This is the main pull request for 5.4-rc1 merge window. I don't think
      there is anything outstanding so next week should just be fixes, but
      we'll see if I missed anything. I landed some fixes earlier in the
      week but got delayed writing summary and sending it out, due to a mix
      of sick kid and jetlag!
    
      There are some fixes pending, but I'd rather get the main merge out of
      the way instead of delaying it longer.
    
      It's also pretty large in commit count and new amd header file size.
      The largest thing is four new amdgpu products (navi12/14, arcturus and
      renoir APU support).
    
      Otherwise it's pretty much lots of work across the board, i915 has
      started landing tigerlake support, lots of icelake fixes and lots of
      locking reworking for future gpu support, lots of header file rework
      (drmP.h is nearly gone), some old legacy hacks (DRM_WAIT_ON) have been
      put into the places they are needed.
    
      uapi:
       - content protection type property for HDCP
    
      core:
       - rework include dependencies
       - lots of drmP.h removals
       - link rate calculation robustness fix
       - make fb helper map only when required
       - add connector->DDC adapter link
       - DRM_WAIT_ON removed
       - drop DRM_AUTH usage from drivers
    
      dma-buf:
       - reservation object fence helper
    
      dma-fence:
       - shrink dma_fence struct
       - merge signal functions
       - store timestamps in dma_fence
       - selftests
    
      ttm:
       - embed drm_get_object struct into ttm_buffer_object
       - release_notify callback
    
      bridges:
       - sii902x - audio graph card support
       - tc358767 - aux data handling rework
       - ti-snd64dsi86 - debugfs support, DSI mode flags support
    
      panels:
       - Support for GiantPlus GPM940B0, Sharp LQ070Y3DG3B, Ortustech
         COM37H3M, Novatek NT39016, Sharp LS020B1DD01D, Raydium RM67191, Boe
         Himax8279d, Sharp LD-D5116Z01B
       - TI nspire, NEC NL8048HL11, LG Philips LB035Q02, Sharp LS037V7DW01,
         Sony ACX565AKM, Toppoly TD028TTEC1 Toppoly TD043MTEA1
    
      i915:
       - Initial tigerlake platform support
       - Locking simplification work, general all over refactoring.
       - Selftests
       - HDCP debug info improvements
       - DSI properties
       - Icelake display PLL fixes, colorspace fixes, bandwidth fixes, DSI
         suspend/resume
       - GuC fixes
       - Perf fixes
       - ElkhartLake enablement
       - DP MST fixes
       - GVT - command parser enhancements
    
      amdgpu:
       - add wipe memory on release flag for buffer creation
       - Navi12/14 support (may be marked experimental)
       - Arcturus support
       - Renoir APU support
       - mclk DPM for Navi
       - DC display fixes
       - Raven scatter/gather support
       - RAS support for GFX
       - Navi12 + Arcturus power features
       - GPU reset for Picasso
       - smu11 i2c controller support
    
      amdkfd:
       - navi12/14 support
       - Arcturus support
    
      radeon:
       - kexec fix
    
      nouveau:
       - improved display color management
       - detect lack of GPU power cables
    
      vmwgfx:
       - evicition priority support
       - remove unused security feature
    
      msm:
       - msm8998 display support
       - better async commit support for cursor updates
    
      etnaviv:
       - per-process address space support
       - performance counter fixes
       - softpin support
    
      mcde:
       - DCS transfers fix
    
      exynos:
       - drmP.h cleanup
    
      lima:
       - reduce logging
    
      kirin:
       - misc clenaups
    
      komeda:
       - dual-link support
       - DT memory regions
    
      hisilicon:
       - misc fixes
    
      imx:
       - IPUv3 image converter fixes
       - 32-bit RGB V4L2 pixel format support
    
      ingenic:
       - more support for panel related cases
    
      mgag200:
       - cursor support fix
    
      panfrost:
       - export GPU features register to userspace
       - gpu heap allocations
       - per-fd address space support
    
      pl111:
       - CLD pads wiring support removed from DT
    
      rockchip:
       - rework to use DRM PSR helpers
       - fix bug in VOP_WIN_GET macro
       - DSI DT binding rework
    
      sun4i:
       - improve support for color encoding and range
       - DDC enabled GPIO
    
      tinydrm:
       - rework SPI support
       - improve MIPI-DBI support
       - moved to drm/tiny
    
      vkms:
       - rework CRC tracking
    
      dw-hdmi:
       - get_eld and i2s improvements
    
      gm12u320:
       - misc fixes
    
      meson:
       - global code cleanup
       - vpu feature detect
    
      omap:
       - alpha/pixel blend mode properties
    
      rcar-du:
       - misc fixes"
    
    * tag 'drm-next-2019-09-18' of git://anongit.freedesktop.org/drm/drm: (2112 commits)
      drm/nouveau/bar/gm20b: Avoid BAR1 teardown during init
      drm/nouveau: Fix ordering between TTM and GEM release
      drm/nouveau/prime: Extend DMA reservation object lock
      drm/nouveau: Fix fallout from reservation object rework
      drm/nouveau/kms/nv50-: Don't create MSTMs for eDP connectors
      drm/i915: Use NOEVICT for first pass on attemping to pin a GGTT mmap
      drm/i915: to make vgpu ppgtt notificaiton as atomic operation
      drm/i915: Flush the existing fence before GGTT read/write
      drm/i915: Hold irq-off for the entire fake lock period
      drm/i915/gvt: update RING_START reg of vGPU when the context is submitted to i915
      drm/i915/gvt: update vgpu workload head pointer correctly
      drm/mcde: Fix DSI transfers
      drm/msm: Use the correct dma_sync calls harder
      drm/msm: remove unlikely() from WARN_ON() conditions
      drm/msm/dsi: Fix return value check for clk_get_parent
      drm/msm: add atomic traces
      drm/msm/dpu: async commit support
      drm/msm: async commit support
      drm/msm: split power control from prepare/complete_commit
      drm/msm: add kms->flush_commit()
      ...

commit aefdaa15e54c092709cb926a4b2732986386ef34
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Tue Sep 17 11:25:44 2019 +0000

    drm/komeda: Adds register dump support for gcu, lup and dou
    
    Adds to support register dump on lpu and dou of pipeline and gcu on D71
    
    Changes since v1:
    - For a constant format without additional arguments, use seq_puts()
    instead of seq_printf().
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190917112525.25490-1-lowry.li@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index e8d67395a3b9..9cbcd56e54cd 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -25,6 +25,8 @@ static int komeda_register_show(struct seq_file *sf, void *x)
 	struct komeda_dev *mdev = sf->private;
 	int i;
 
+	seq_puts(sf, "\n====== Komeda register dump =========\n");
+
 	if (mdev->funcs->dump_register)
 		mdev->funcs->dump_register(mdev, sf);
 

commit 5fcd055193c5d4cac6d205bd65e52c957ea057c2
Author: Mihail Atanassov <Mihail.Atanassov@arm.com>
Date:   Wed Aug 28 11:03:49 2019 +0000

    drm/komeda: Add ACLK rate to sysfs
    
    Expose node with the name 'aclk_hz'
    
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Ayan kumar halder <ayan.halder@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190828110342.45936-1-mihail.atanassov@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 0142ee991957..e8d67395a3b9 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -91,9 +91,19 @@ config_id_show(struct device *dev, struct device_attribute *attr, char *buf)
 }
 static DEVICE_ATTR_RO(config_id);
 
+static ssize_t
+aclk_hz_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct komeda_dev *mdev = dev_to_mdev(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%lu\n", clk_get_rate(mdev->aclk));
+}
+static DEVICE_ATTR_RO(aclk_hz);
+
 static struct attribute *komeda_sysfs_entries[] = {
 	&dev_attr_core_id.attr,
 	&dev_attr_config_id.attr,
+	&dev_attr_aclk_hz.attr,
 	NULL,
 };
 

commit 51a44a28eefd0d4c1addeb23fc5a599ff1787dfd
Author: Mihail Atanassov <Mihail.Atanassov@arm.com>
Date:   Tue Aug 20 15:16:58 2019 +0000

    drm/komeda: Add missing of_node_get() call
    
    komeda_pipeline_destroy has the matching of_node_put().
    
    Fixes: 29e56aec911dd ("drm/komeda: Add DT parsing")
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Reviewed-by: Ayan Kumar Halder <ayan.halder@arm.com>
    [Rebased on the latest drm-misc-fixes]
    Signed-off-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Link: https://patchwork.freedesktop.org/patch/325278/
    
    Change-Id: I5fa2479d6cb3a77182f1a92833c1c0bca8668cb4

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index a0eabc134dd6..9d4d5075cc64 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -127,7 +127,7 @@ static int komeda_parse_pipe_dt(struct komeda_dev *mdev, struct device_node *np)
 	pipe->of_output_port =
 		of_graph_get_port_by_id(np, KOMEDA_OF_PORT_OUTPUT);
 
-	pipe->of_node = np;
+	pipe->of_node = of_node_get(np);
 
 	return 0;
 }

commit a8c16b7593bd1a4e613164a47c526ca9d1be764b
Author: Mihail Atanassov <Mihail.Atanassov@arm.com>
Date:   Mon Aug 5 09:56:25 2019 +0000

    drm/komeda: Add support for 'memory-region' DT node property
    
    The 'memory-region' property of the komeda display driver DT binding
    allows the use of a 'reserved-memory' node for buffer allocations. Add
    the requisite of_reserved_mem_device_{init,release} calls to actually
    make use of the memory if present.
    
    Changes since v1:
     - Move handling inside komeda_parse_dt
    
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Signed-off-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Link:- https://patchwork.kernel.org/patch/11076413/

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 1ff7f4b2c620..0142ee991957 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -8,6 +8,7 @@
 #include <linux/iommu.h>
 #include <linux/of_device.h>
 #include <linux/of_graph.h>
+#include <linux/of_reserved_mem.h>
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>
 #ifdef CONFIG_DEBUG_FS
@@ -146,6 +147,12 @@ static int komeda_parse_dt(struct device *dev, struct komeda_dev *mdev)
 		return mdev->irq;
 	}
 
+	/* Get the optional framebuffer memory resource */
+	ret = of_reserved_mem_device_init(dev);
+	if (ret && ret != -ENODEV)
+		return ret;
+	ret = 0;
+
 	for_each_available_child_of_node(np, child) {
 		if (of_node_cmp(child->name, "pipeline") == 0) {
 			ret = komeda_parse_pipe_dt(mdev, child);
@@ -292,6 +299,8 @@ void komeda_dev_destroy(struct komeda_dev *mdev)
 
 	mdev->n_pipelines = 0;
 
+	of_reserved_mem_device_release(dev);
+
 	if (funcs && funcs->cleanup)
 		funcs->cleanup(mdev);
 

commit 8f1c748b9a7751ee1297b4880788a09f7c802eb4
Author: Mihail Atanassov <Mihail.Atanassov@arm.com>
Date:   Mon Aug 5 09:56:25 2019 +0000

    drm/komeda: Add support for 'memory-region' DT node property
    
    The 'memory-region' property of the komeda display driver DT binding
    allows the use of a 'reserved-memory' node for buffer allocations. Add
    the requisite of_reserved_mem_device_{init,release} calls to actually
    make use of the memory if present.
    
    Changes since v1:
     - Move handling inside komeda_parse_dt
    
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190805095408.21285-1-mihail.atanassov@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 5a118984de33..a0eabc134dd6 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -8,6 +8,7 @@
 #include <linux/iommu.h>
 #include <linux/of_device.h>
 #include <linux/of_graph.h>
+#include <linux/of_reserved_mem.h>
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>
 #ifdef CONFIG_DEBUG_FS
@@ -143,6 +144,12 @@ static int komeda_parse_dt(struct device *dev, struct komeda_dev *mdev)
 		return mdev->irq;
 	}
 
+	/* Get the optional framebuffer memory resource */
+	ret = of_reserved_mem_device_init(dev);
+	if (ret && ret != -ENODEV)
+		return ret;
+	ret = 0;
+
 	for_each_available_child_of_node(np, child) {
 		if (of_node_cmp(child->name, "pipeline") == 0) {
 			ret = komeda_parse_pipe_dt(mdev, child);
@@ -289,6 +296,8 @@ void komeda_dev_destroy(struct komeda_dev *mdev)
 
 	mdev->n_pipelines = 0;
 
+	of_reserved_mem_device_release(dev);
+
 	if (funcs && funcs->cleanup)
 		funcs->cleanup(mdev);
 

commit 8965ad8433eadadc5a41df2915eec4a144e8aed6
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jun 18 09:10:49 2019 +0100

    drm/komeda: Enable dual-link support
    
    Komeda HW can support dual-link which splits display frame to two halves
    (left/link0, right/link1) and output them by two output links.
    Due to the halved pixel rate of each link, the pxlclk of dual-link can be
    reduced two times compare with single-link.
    
    For enabling dual-link:
    - The DT need to configure two output-links for the pipeline node.
    - Komeda enable dual-link when both link0 and link1 have been connected.
    
    Example of how the pipeline node will look like for dual-link setup
    
    pipe0: pipeline@0 {
            clocks = <&fpgaosc2>;
            clock-names = "pxclk";
            reg = <0>;
    
            #address-cells = <1>;
            #size-cells = <0>;
    
            port@0 {
                    reg = <0>;
    
                    #address-cells = <1>;
                    #size-cells = <0>;
                    dp0_pipe0_link0: endpoint@0 {
                            reg = <0>;
                            remote-endpoint = <&dlink_connector_in0>;
    
                    };
                    dp0_pipe0_link1: endpoint@1 {
                            reg = <1>;
                            remote-endpoint = <&dlink_connector_in1>;
                    };
            };
    };
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190618081013.13638-3-james.qian.wang@arm.com

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 5a118984de33..1ff7f4b2c620 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -121,11 +121,14 @@ static int komeda_parse_pipe_dt(struct komeda_dev *mdev, struct device_node *np)
 	pipe->pxlclk = clk;
 
 	/* enum ports */
-	pipe->of_output_dev =
+	pipe->of_output_links[0] =
 		of_graph_get_remote_node(np, KOMEDA_OF_PORT_OUTPUT, 0);
+	pipe->of_output_links[1] =
+		of_graph_get_remote_node(np, KOMEDA_OF_PORT_OUTPUT, 1);
 	pipe->of_output_port =
 		of_graph_get_port_by_id(np, KOMEDA_OF_PORT_OUTPUT);
 
+	pipe->dual_link = pipe->of_output_links[0] && pipe->of_output_links[1];
 	pipe->of_node = np;
 
 	return 0;

commit 8b70ce7ddf074a46d7137b1805f2a88ec89a6271
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jun 13 15:28:06 2019 +0200

    komeda: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    Cc: "James (Qian) Wang" <james.qian.wang@arm.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: dri-devel@lists.freedesktop.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index e1aa58ef03d7..5a118984de33 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -53,9 +53,6 @@ static void komeda_debugfs_init(struct komeda_dev *mdev)
 		return;
 
 	mdev->debugfs_root = debugfs_create_dir("komeda", NULL);
-	if (IS_ERR_OR_NULL(mdev->debugfs_root))
-		return;
-
 	debugfs_create_file("register", 0444, mdev->debugfs_root,
 			    mdev, &komeda_register_fops);
 }

commit 6f84da0c74f12f9dbcc612cced6b1fa07965415d
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Wed Jun 5 11:35:39 2019 +0100

    drm/komeda: Rename main engine clk name "mclk" to "aclk"
    
    To avoid confusion, unify the driver main engine clk name "mclk" to
    the spec name "aclk".
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index fd0741533676..e1aa58ef03d7 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -193,15 +193,15 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 		goto err_cleanup;
 	}
 
-	mdev->mclk = devm_clk_get(dev, "mclk");
-	if (IS_ERR(mdev->mclk)) {
+	mdev->aclk = devm_clk_get(dev, "aclk");
+	if (IS_ERR(mdev->aclk)) {
 		DRM_ERROR("Get engine clk failed.\n");
-		err = PTR_ERR(mdev->mclk);
-		mdev->mclk = NULL;
+		err = PTR_ERR(mdev->aclk);
+		mdev->aclk = NULL;
 		goto err_cleanup;
 	}
 
-	clk_prepare_enable(mdev->mclk);
+	clk_prepare_enable(mdev->aclk);
 
 	mdev->funcs = product->identify(mdev->reg_base, &mdev->chip);
 	if (!komeda_product_match(mdev, product->product_id)) {
@@ -300,10 +300,10 @@ void komeda_dev_destroy(struct komeda_dev *mdev)
 		mdev->reg_base = NULL;
 	}
 
-	if (mdev->mclk) {
-		clk_disable_unprepare(mdev->mclk);
-		devm_clk_put(dev, mdev->mclk);
-		mdev->mclk = NULL;
+	if (mdev->aclk) {
+		clk_disable_unprepare(mdev->aclk);
+		devm_clk_put(dev, mdev->aclk);
+		mdev->aclk = NULL;
 	}
 
 	devm_kfree(dev, mdev);

commit 28be315c9c0c0b8d1093fcddf3245398108b83fd
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Wed Jun 5 11:35:32 2019 +0100

    drm/komeda: Unify mclk/pclk/pipeline->aclk to one MCLK
    
    Current komeda driver uses three dedicated clks for a specific purpose:
    - mclk: main engine clock
    - pclk: APB clock
    - pipeline->aclk: AXI clock.
    
    But per spec the komeda HW only has three input clks:
    - ACLK: used for AXI masters, APB slave and most pipeline processing
    - PXCLK for pipeline 0: output pixel clock for pipeline 0
    - PXCLK for pipeline 1: output pixel clock for pipeline 1
    
    So one ACLK is enough, no need to split it to three mclk/pclk/axiclk.
    drop pclk/pipeline->axiclk. but only keep one mclk in komeda driver.
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 7bb5f88db792..fd0741533676 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -116,13 +116,6 @@ static int komeda_parse_pipe_dt(struct komeda_dev *mdev, struct device_node *np)
 
 	pipe = mdev->pipelines[pipe_id];
 
-	clk = of_clk_get_by_name(np, "aclk");
-	if (IS_ERR(clk)) {
-		DRM_ERROR("get aclk for pipeline %d failed!\n", pipe_id);
-		return PTR_ERR(clk);
-	}
-	pipe->aclk = clk;
-
 	clk = of_clk_get_by_name(np, "pxclk");
 	if (IS_ERR(clk)) {
 		DRM_ERROR("get pxclk for pipeline %d failed!\n", pipe_id);
@@ -145,14 +138,8 @@ static int komeda_parse_dt(struct device *dev, struct komeda_dev *mdev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct device_node *child, *np = dev->of_node;
-	struct clk *clk;
 	int ret;
 
-	clk = devm_clk_get(dev, "mclk");
-	if (IS_ERR(clk))
-		return PTR_ERR(clk);
-
-	mdev->mclk = clk;
 	mdev->irq  = platform_get_irq(pdev, 0);
 	if (mdev->irq < 0) {
 		DRM_ERROR("could not get IRQ number.\n");
@@ -206,16 +193,15 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 		goto err_cleanup;
 	}
 
-	mdev->pclk = devm_clk_get(dev, "pclk");
-	if (IS_ERR(mdev->pclk)) {
-		DRM_ERROR("Get APB clk failed.\n");
-		err = PTR_ERR(mdev->pclk);
-		mdev->pclk = NULL;
+	mdev->mclk = devm_clk_get(dev, "mclk");
+	if (IS_ERR(mdev->mclk)) {
+		DRM_ERROR("Get engine clk failed.\n");
+		err = PTR_ERR(mdev->mclk);
+		mdev->mclk = NULL;
 		goto err_cleanup;
 	}
 
-	/* Enable APB clock to access the registers */
-	clk_prepare_enable(mdev->pclk);
+	clk_prepare_enable(mdev->mclk);
 
 	mdev->funcs = product->identify(mdev->reg_base, &mdev->chip);
 	if (!komeda_product_match(mdev, product->product_id)) {
@@ -315,15 +301,10 @@ void komeda_dev_destroy(struct komeda_dev *mdev)
 	}
 
 	if (mdev->mclk) {
+		clk_disable_unprepare(mdev->mclk);
 		devm_clk_put(dev, mdev->mclk);
 		mdev->mclk = NULL;
 	}
 
-	if (mdev->pclk) {
-		clk_disable_unprepare(mdev->pclk);
-		devm_clk_put(dev, mdev->pclk);
-		mdev->pclk = NULL;
-	}
-
 	devm_kfree(dev, mdev);
 }

commit e87cae37f6006f5cebb2ae2b39daf39be7fc0a27
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Thu Jun 6 10:53:05 2019 +0100

    drm/komeda: Adds SMMU support
    
    Adds iommu_connect and disconnect for SMMU support, and configures
    TBU translation once SMMU has been attached to the display device.
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    [fixed checking of error code returned by dp_wait_cond() and removed
    extraneous DRM_ERROR() calls]
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index b67030a9f056..7bb5f88db792 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -5,6 +5,7 @@
  *
  */
 #include <linux/io.h>
+#include <linux/iommu.h>
 #include <linux/of_device.h>
 #include <linux/of_graph.h>
 #include <linux/platform_device.h>
@@ -253,6 +254,18 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 	dev->dma_parms = &mdev->dma_parms;
 	dma_set_max_seg_size(dev, DMA_BIT_MASK(32));
 
+	mdev->iommu = iommu_get_domain_for_dev(mdev->dev);
+	if (!mdev->iommu)
+		DRM_INFO("continue without IOMMU support!\n");
+
+	if (mdev->iommu && mdev->funcs->connect_iommu) {
+		err = mdev->funcs->connect_iommu(mdev);
+		if (err) {
+			mdev->iommu = NULL;
+			goto err_cleanup;
+		}
+	}
+
 	err = sysfs_create_group(&dev->kobj, &komeda_sysfs_attr_group);
 	if (err) {
 		DRM_ERROR("create sysfs group failed.\n");
@@ -282,6 +295,10 @@ void komeda_dev_destroy(struct komeda_dev *mdev)
 	debugfs_remove_recursive(mdev->debugfs_root);
 #endif
 
+	if (mdev->iommu && mdev->funcs->disconnect_iommu)
+		mdev->funcs->disconnect_iommu(mdev);
+	mdev->iommu = NULL;
+
 	for (i = 0; i < mdev->n_pipelines; i++) {
 		komeda_pipeline_destroy(mdev, mdev->pipelines[i]);
 		mdev->pipelines[i] = NULL;

commit a260e0b847f079b7eda85a76fc066a6537f34951
Author: Lowry Li (Arm Technology China) <Lowry.Li@arm.com>
Date:   Thu Apr 11 09:37:13 2019 +0100

    drm/komeda: fixing of DMA mapping sg segment warning
    
    Fixing the DMA mapping sg segment warning, which shows "DMA-API: mapping
    sg segment longer than device claims to support [len=921600] [max=65536]".
    Fixed by setting the max segment size at Komeda driver.
    
    This patch depends on:
    - https://patchwork.freedesktop.org/series/54448/
    - https://patchwork.freedesktop.org/series/54449/
    - https://patchwork.freedesktop.org/series/54450/
    - https://patchwork.freedesktop.org/series/58976/
    
    Changes since v1:
    - Adds member description
    - Adds patch denpendency in the comment
    
    Signed-off-by: Lowry Li (Arm Technology China) <lowry.li@arm.com>
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Reviewed-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index d7527e126658..b67030a9f056 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -8,6 +8,7 @@
 #include <linux/of_device.h>
 #include <linux/of_graph.h>
 #include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
 #ifdef CONFIG_DEBUG_FS
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
@@ -249,6 +250,9 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 		goto err_cleanup;
 	}
 
+	dev->dma_parms = &mdev->dma_parms;
+	dma_set_max_seg_size(dev, DMA_BIT_MASK(32));
+
 	err = sysfs_create_group(&dev->kobj, &komeda_sysfs_attr_group);
 	if (err) {
 		DRM_ERROR("create sysfs group failed.\n");

commit ba1b9f8c4658663dd66e992bef31f6f8747b6c8c
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu Apr 25 07:12:09 2019 +0100

    drm/komeda: Constify the usage of komeda_component/pipeline/dev_funcs
    
    Depends on:
    - https://patchwork.freedesktop.org/series/58976/
    - https://patchwork.freedesktop.org/series/59855/
    
    Reported-by: Emil Velikov <emil.l.velikov@gmail.com>
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index ca3599e4a4d3..d7527e126658 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -269,7 +269,7 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 void komeda_dev_destroy(struct komeda_dev *mdev)
 {
 	struct device *dev = mdev->dev;
-	struct komeda_dev_funcs *funcs = mdev->funcs;
+	const struct komeda_dev_funcs *funcs = mdev->funcs;
 	int i;
 
 	sysfs_remove_group(&dev->kobj, &komeda_sysfs_attr_group);

commit 55223394d56bab42ebac71ba52e0fd8bfdc6fc07
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 11:11:53 2019 +0000

    drm/komeda: Add sysfs attribute: core_id and config_id
    
    Add two sysfs node: core_id, config_id, user can read them to fetch the
    HW product information.
    
    Also, use memset to initialize config_id, rather than quirky C syntax.
    Courtesy of Nathan Chancellor <natechancellor@gmail.com>.
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    [Merged Nathan's patch that uses memset to initialize config_id into
    original patch as the fixes tag changed due to rebase, reworded the
    commit to reference the merged patch]
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 131f26692a3d..ca3599e4a4d3 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -59,6 +59,48 @@ static void komeda_debugfs_init(struct komeda_dev *mdev)
 }
 #endif
 
+static ssize_t
+core_id_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct komeda_dev *mdev = dev_to_mdev(dev);
+
+	return snprintf(buf, PAGE_SIZE, "0x%08x\n", mdev->chip.core_id);
+}
+static DEVICE_ATTR_RO(core_id);
+
+static ssize_t
+config_id_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct komeda_dev *mdev = dev_to_mdev(dev);
+	struct komeda_pipeline *pipe = mdev->pipelines[0];
+	union komeda_config_id config_id;
+	int i;
+
+	memset(&config_id, 0, sizeof(config_id));
+
+	config_id.max_line_sz = pipe->layers[0]->hsize_in.end;
+	config_id.n_pipelines = mdev->n_pipelines;
+	config_id.n_scalers = pipe->n_scalers;
+	config_id.n_layers = pipe->n_layers;
+	config_id.n_richs = 0;
+	for (i = 0; i < pipe->n_layers; i++) {
+		if (pipe->layers[i]->layer_type == KOMEDA_FMT_RICH_LAYER)
+			config_id.n_richs++;
+	}
+	return snprintf(buf, PAGE_SIZE, "0x%08x\n", config_id.value);
+}
+static DEVICE_ATTR_RO(config_id);
+
+static struct attribute *komeda_sysfs_entries[] = {
+	&dev_attr_core_id.attr,
+	&dev_attr_config_id.attr,
+	NULL,
+};
+
+static struct attribute_group komeda_sysfs_attr_group = {
+	.attrs = komeda_sysfs_entries,
+};
+
 static int komeda_parse_pipe_dt(struct komeda_dev *mdev, struct device_node *np)
 {
 	struct komeda_pipeline *pipe;
@@ -207,6 +249,12 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 		goto err_cleanup;
 	}
 
+	err = sysfs_create_group(&dev->kobj, &komeda_sysfs_attr_group);
+	if (err) {
+		DRM_ERROR("create sysfs group failed.\n");
+		goto err_cleanup;
+	}
+
 #ifdef CONFIG_DEBUG_FS
 	komeda_debugfs_init(mdev);
 #endif
@@ -224,6 +272,8 @@ void komeda_dev_destroy(struct komeda_dev *mdev)
 	struct komeda_dev_funcs *funcs = mdev->funcs;
 	int i;
 
+	sysfs_remove_group(&dev->kobj, &komeda_sysfs_attr_group);
+
 #ifdef CONFIG_DEBUG_FS
 	debugfs_remove_recursive(mdev->debugfs_root);
 #endif

commit 20d84aa841791075edc07e0a7417cea443abe889
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 11:11:07 2019 +0000

    drm/komeda: Add komeda_crtc_prepare/unprepare
    
    These two function will be used by komeda_crtc_enable/disable to do some
    prepartion works when enable/disable a crtc. like enable a crtc:
      1. Adjust display operation mode.
      2. Enable/prepare needed clk.
    
    v2: Rebase
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 24548b87e182..131f26692a3d 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -151,6 +151,8 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 	if (!mdev)
 		return ERR_PTR(-ENOMEM);
 
+	mutex_init(&mdev->lock);
+
 	mdev->dev = dev;
 	mdev->reg_base = devm_ioremap_resource(dev, io_res);
 	if (IS_ERR(mdev->reg_base)) {

commit 57683268189140d3a02c71bb39933a0faec39234
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Mon Mar 25 16:31:44 2019 +0000

    arm/komeda: Compile komeda_debugfs_init() only if CONFIG_DEBUG_FS is enabled
    
    We don't call this function if CONFIG_DEBUG_FS is not defined, but we
    should not be compiling it either, as the declaration of the debugfs
    core functions is not included.
    
    Reported by the kbuild test robot.
    
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index b420c6205d6b..24548b87e182 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -44,6 +44,7 @@ static const struct file_operations komeda_register_fops = {
 	.release	= single_release,
 };
 
+#ifdef CONFIG_DEBUG_FS
 static void komeda_debugfs_init(struct komeda_dev *mdev)
 {
 	if (!debugfs_initialized())
@@ -56,6 +57,7 @@ static void komeda_debugfs_init(struct komeda_dev *mdev)
 	debugfs_create_file("register", 0444, mdev->debugfs_root,
 			    mdev, &komeda_register_fops);
 }
+#endif
 
 static int komeda_parse_pipe_dt(struct komeda_dev *mdev, struct device_node *np)
 {

commit 7d3cfb70a604d215e195ba9282df42dd6edff16a
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 09:24:34 2019 +0000

    drm/komeda: Add debugfs node "register" for register dump
    
    Add a debugfs node "register" and entry function dump_register to
    dev/pipeline/component to register dump, then user can read
    "/sys/kernel/debug/komeda/register" to get the register values via these
    chip function.
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    [Added the d71_layer_dump() function that was in a previous commit]
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index cf65bf5331d9..b420c6205d6b 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -8,11 +8,55 @@
 #include <linux/of_device.h>
 #include <linux/of_graph.h>
 #include <linux/platform_device.h>
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#endif
 
 #include <drm/drm_print.h>
 
 #include "komeda_dev.h"
 
+static int komeda_register_show(struct seq_file *sf, void *x)
+{
+	struct komeda_dev *mdev = sf->private;
+	int i;
+
+	if (mdev->funcs->dump_register)
+		mdev->funcs->dump_register(mdev, sf);
+
+	for (i = 0; i < mdev->n_pipelines; i++)
+		komeda_pipeline_dump_register(mdev->pipelines[i], sf);
+
+	return 0;
+}
+
+static int komeda_register_open(struct inode *inode, struct file *filp)
+{
+	return single_open(filp, komeda_register_show, inode->i_private);
+}
+
+static const struct file_operations komeda_register_fops = {
+	.owner		= THIS_MODULE,
+	.open		= komeda_register_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static void komeda_debugfs_init(struct komeda_dev *mdev)
+{
+	if (!debugfs_initialized())
+		return;
+
+	mdev->debugfs_root = debugfs_create_dir("komeda", NULL);
+	if (IS_ERR_OR_NULL(mdev->debugfs_root))
+		return;
+
+	debugfs_create_file("register", 0444, mdev->debugfs_root,
+			    mdev, &komeda_register_fops);
+}
+
 static int komeda_parse_pipe_dt(struct komeda_dev *mdev, struct device_node *np)
 {
 	struct komeda_pipeline *pipe;
@@ -159,6 +203,10 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 		goto err_cleanup;
 	}
 
+#ifdef CONFIG_DEBUG_FS
+	komeda_debugfs_init(mdev);
+#endif
+
 	return mdev;
 
 err_cleanup:
@@ -172,6 +220,10 @@ void komeda_dev_destroy(struct komeda_dev *mdev)
 	struct komeda_dev_funcs *funcs = mdev->funcs;
 	int i;
 
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove_recursive(mdev->debugfs_root);
+#endif
+
 	for (i = 0; i < mdev->n_pipelines; i++) {
 		komeda_pipeline_destroy(mdev, mdev->pipelines[i]);
 		mdev->pipelines[i] = NULL;

commit 0dac37bf1c5dc1e8454fbe8d548f6e312cfd982d
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 09:24:25 2019 +0000

    drm/komeda: Add irq handling
    
    1. Added irq_handler/irq_enable/irq_disable to komeda_dev_func, then the
       Komeda-CORE can control the HW irq via these chip function.
    2. Install irq and register irq_handler to system by DRM, so once the IRQ
       coming, the handling sequence is:
    
       komeda_kms_irq_handler(int irq, void *data)
            /* step 1. call into the CHIP to recognize event */
            mdev->funcs->irq_handler(mdev, &evts);
    
            /* step 2. notify the crtc to handle the events */
            for (i = 0; i < kms->n_crtcs; i++)
                    komeda_crtc_handle_event(&kms->crtcs[i], &evts);
    
    v2:
    - Move get IRQ number into this change.
    - Enable irq before drm_dev_register.
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 780ca86c9db9..cf65bf5331d9 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -53,6 +53,7 @@ static int komeda_parse_pipe_dt(struct komeda_dev *mdev, struct device_node *np)
 
 static int komeda_parse_dt(struct device *dev, struct komeda_dev *mdev)
 {
+	struct platform_device *pdev = to_platform_device(dev);
 	struct device_node *child, *np = dev->of_node;
 	struct clk *clk;
 	int ret;
@@ -62,6 +63,11 @@ static int komeda_parse_dt(struct device *dev, struct komeda_dev *mdev)
 		return PTR_ERR(clk);
 
 	mdev->mclk = clk;
+	mdev->irq  = platform_get_irq(pdev, 0);
+	if (mdev->irq < 0) {
+		DRM_ERROR("could not get IRQ number.\n");
+		return mdev->irq;
+	}
 
 	for_each_available_child_of_node(np, child) {
 		if (of_node_cmp(child->name, "pipeline") == 0) {

commit 321e925c5813c228bafda5ea3729ebddb00a3040
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Tue Jan 22 09:24:16 2019 +0000

    drm/komeda: Add komeda_assemble_pipelines
    
    komeda_accemble_pipelines is for:
    
    1. Verifing the component->supported_inputs according to the
       pipeline->avail_components.
    2. Generating component->supported_outputs.
    
    v2: Lower the debug message of komeda_component_dump to DRM_DEBUG.
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 70e9bb7fa30c..780ca86c9db9 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -147,6 +147,12 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 		goto err_cleanup;
 	}
 
+	err = komeda_assemble_pipelines(mdev);
+	if (err) {
+		DRM_ERROR("assemble display pipelines failed.\n");
+		goto err_cleanup;
+	}
+
 	return mdev;
 
 err_cleanup:

commit 6649a95d35d850e417f125821a803ca7889c713c
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Fri Feb 8 23:13:24 2019 +0100

    drm/komeda: fix build with drm_modeset_helper.h update
    
    With drmP.h removed from drm_modeset_helper.h the build of
    komeda filed as reported by linux-next
    
    Add missing include files to fix build.
    For the files touched group include files and sort them.
    
    The fix was tested on a tree with drm-misc-next merged.
    And the patch was also tested to work without drm-misc-next merged.
    
    Build tested on arm + x86.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au> [linux-next]
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: James Wang <james.qian.wang@arm.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190208221324.27002-1-sam@ravnborg.org

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 0fe6954fbbf4..70e9bb7fa30c 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -4,9 +4,13 @@
  * Author: James.Qian.Wang <james.qian.wang@arm.com>
  *
  */
-#include <linux/platform_device.h>
+#include <linux/io.h>
 #include <linux/of_device.h>
 #include <linux/of_graph.h>
+#include <linux/platform_device.h>
+
+#include <drm/drm_print.h>
+
 #include "komeda_dev.h"
 
 static int komeda_parse_pipe_dt(struct komeda_dev *mdev, struct device_node *np)

commit 874cf192964e05dc6f8103aa8bbcd090a7541312
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Tue Jan 15 10:06:31 2019 +0000

    drm: arm/komeda: Remove IRQ parsing from initial series
    
    The initial series is only introducing the basic components and not
    implementing IRQ handling. Remove the left over code that touches
    IRQs until the proper implementation is introduced in a later series.
    
    Reviewed-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 84fdf707f210..0fe6954fbbf4 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -49,7 +49,6 @@ static int komeda_parse_pipe_dt(struct komeda_dev *mdev, struct device_node *np)
 
 static int komeda_parse_dt(struct device *dev, struct komeda_dev *mdev)
 {
-	struct platform_device *pdev = to_platform_device(dev);
 	struct device_node *child, *np = dev->of_node;
 	struct clk *clk;
 	int ret;
@@ -59,11 +58,6 @@ static int komeda_parse_dt(struct device *dev, struct komeda_dev *mdev)
 		return PTR_ERR(clk);
 
 	mdev->mclk = clk;
-	mdev->irq  = platform_get_irq(pdev, 0);
-	if (mdev->irq < 0) {
-		DRM_ERROR("could not get IRQ number.\n");
-		return mdev->irq;
-	}
 
 	for_each_available_child_of_node(np, child) {
 		if (of_node_cmp(child->name, "pipeline") == 0) {

commit 981d29d2db7c96b942aa4b73fed31469140bcf9d
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu Jan 3 11:40:55 2019 +0000

    drm/komeda: Add komeda_format_caps for format handling
    
    komeda_format_caps is for describing ARM display specific features and
    limitations of a specific format, and format_caps will be linked into
    &komeda_framebuffer like a extension of &drm_format_info.
    And komed_format_caps_table will be initialized before the enum_resources,
    since the layer features description depend on this format_caps table, so
    we'd better initialize the table first.
    
    Changes in v4:
    - Rebase.
    
    Changes in v3:
    - Fixed style problem found by checkpatch.pl --strict.
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 7257248463bc..84fdf707f210 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -135,6 +135,8 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 		 MALIDP_CORE_ID_MAJOR(mdev->chip.core_id),
 		 MALIDP_CORE_ID_MINOR(mdev->chip.core_id));
 
+	mdev->funcs->init_format_table(mdev);
+
 	err = mdev->funcs->enum_resources(mdev);
 	if (err) {
 		DRM_ERROR("enumerate display resource failed.\n");

commit 29e56aec911dd784c1a29f28254f74fcd683bfe0
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu Jan 3 11:40:38 2019 +0000

    drm/komeda: Add DT parsing
    
    Parse DT and initialize corresponding dev/pipeline attributes.
    
    Changes in v4:
    - Rebase.
    
    Changes in v3:
    - Fixed style problem found by checkpatch.pl --strict.
    
    Changes in v2:
    - Unified abbreviation of "pipeline" to "pipe".
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
index 4dec259cecac..7257248463bc 100644
--- a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -9,6 +9,76 @@
 #include <linux/of_graph.h>
 #include "komeda_dev.h"
 
+static int komeda_parse_pipe_dt(struct komeda_dev *mdev, struct device_node *np)
+{
+	struct komeda_pipeline *pipe;
+	struct clk *clk;
+	u32 pipe_id;
+	int ret = 0;
+
+	ret = of_property_read_u32(np, "reg", &pipe_id);
+	if (ret != 0 || pipe_id >= mdev->n_pipelines)
+		return -EINVAL;
+
+	pipe = mdev->pipelines[pipe_id];
+
+	clk = of_clk_get_by_name(np, "aclk");
+	if (IS_ERR(clk)) {
+		DRM_ERROR("get aclk for pipeline %d failed!\n", pipe_id);
+		return PTR_ERR(clk);
+	}
+	pipe->aclk = clk;
+
+	clk = of_clk_get_by_name(np, "pxclk");
+	if (IS_ERR(clk)) {
+		DRM_ERROR("get pxclk for pipeline %d failed!\n", pipe_id);
+		return PTR_ERR(clk);
+	}
+	pipe->pxlclk = clk;
+
+	/* enum ports */
+	pipe->of_output_dev =
+		of_graph_get_remote_node(np, KOMEDA_OF_PORT_OUTPUT, 0);
+	pipe->of_output_port =
+		of_graph_get_port_by_id(np, KOMEDA_OF_PORT_OUTPUT);
+
+	pipe->of_node = np;
+
+	return 0;
+}
+
+static int komeda_parse_dt(struct device *dev, struct komeda_dev *mdev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct device_node *child, *np = dev->of_node;
+	struct clk *clk;
+	int ret;
+
+	clk = devm_clk_get(dev, "mclk");
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	mdev->mclk = clk;
+	mdev->irq  = platform_get_irq(pdev, 0);
+	if (mdev->irq < 0) {
+		DRM_ERROR("could not get IRQ number.\n");
+		return mdev->irq;
+	}
+
+	for_each_available_child_of_node(np, child) {
+		if (of_node_cmp(child->name, "pipeline") == 0) {
+			ret = komeda_parse_pipe_dt(mdev, child);
+			if (ret) {
+				DRM_ERROR("parse pipeline dt error!\n");
+				of_node_put(child);
+				break;
+			}
+		}
+	}
+
+	return ret;
+}
+
 struct komeda_dev *komeda_dev_create(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
@@ -71,6 +141,12 @@ struct komeda_dev *komeda_dev_create(struct device *dev)
 		goto err_cleanup;
 	}
 
+	err = komeda_parse_dt(dev, mdev);
+	if (err) {
+		DRM_ERROR("parse device tree failed.\n");
+		goto err_cleanup;
+	}
+
 	return mdev;
 
 err_cleanup:

commit bd628c1bed7902ec1f24ba0fe70758949146abbe
Author: james qian wang (Arm Technology China) <james.qian.wang@arm.com>
Date:   Thu Jan 3 11:39:48 2019 +0000

    drm/komeda: komeda_dev/pipeline/component definition and initialzation
    
    1. Added a brief definition of komeda_dev/pipeline/component, this change
       didn't add the detailed component features and capabilities, which will
       be added in the following changes.
    2. Corresponding resources discovery and initialzation functions.
    
    Changes in v4:
    - Deleted unnecessary headers
    
    Changes in v3:
    - Fixed style problem found by checkpatch.pl --strict.
    
    Changes in v2:
    - Unified abbreviation of "pipeline" to "pipe".
    
    Signed-off-by: James Qian Wang (Arm Technology China) <james.qian.wang@arm.com>
    Reviewed-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/display/komeda/komeda_dev.c b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
new file mode 100644
index 000000000000..4dec259cecac
--- /dev/null
+++ b/drivers/gpu/drm/arm/display/komeda/komeda_dev.c
@@ -0,0 +1,114 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * (C) COPYRIGHT 2018 ARM Limited. All rights reserved.
+ * Author: James.Qian.Wang <james.qian.wang@arm.com>
+ *
+ */
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include "komeda_dev.h"
+
+struct komeda_dev *komeda_dev_create(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	const struct komeda_product_data *product;
+	struct komeda_dev *mdev;
+	struct resource *io_res;
+	int err = 0;
+
+	product = of_device_get_match_data(dev);
+	if (!product)
+		return ERR_PTR(-ENODEV);
+
+	io_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!io_res) {
+		DRM_ERROR("No registers defined.\n");
+		return ERR_PTR(-ENODEV);
+	}
+
+	mdev = devm_kzalloc(dev, sizeof(*mdev), GFP_KERNEL);
+	if (!mdev)
+		return ERR_PTR(-ENOMEM);
+
+	mdev->dev = dev;
+	mdev->reg_base = devm_ioremap_resource(dev, io_res);
+	if (IS_ERR(mdev->reg_base)) {
+		DRM_ERROR("Map register space failed.\n");
+		err = PTR_ERR(mdev->reg_base);
+		mdev->reg_base = NULL;
+		goto err_cleanup;
+	}
+
+	mdev->pclk = devm_clk_get(dev, "pclk");
+	if (IS_ERR(mdev->pclk)) {
+		DRM_ERROR("Get APB clk failed.\n");
+		err = PTR_ERR(mdev->pclk);
+		mdev->pclk = NULL;
+		goto err_cleanup;
+	}
+
+	/* Enable APB clock to access the registers */
+	clk_prepare_enable(mdev->pclk);
+
+	mdev->funcs = product->identify(mdev->reg_base, &mdev->chip);
+	if (!komeda_product_match(mdev, product->product_id)) {
+		DRM_ERROR("DT configured %x mismatch with real HW %x.\n",
+			  product->product_id,
+			  MALIDP_CORE_ID_PRODUCT_ID(mdev->chip.core_id));
+		err = -ENODEV;
+		goto err_cleanup;
+	}
+
+	DRM_INFO("Found ARM Mali-D%x version r%dp%d\n",
+		 MALIDP_CORE_ID_PRODUCT_ID(mdev->chip.core_id),
+		 MALIDP_CORE_ID_MAJOR(mdev->chip.core_id),
+		 MALIDP_CORE_ID_MINOR(mdev->chip.core_id));
+
+	err = mdev->funcs->enum_resources(mdev);
+	if (err) {
+		DRM_ERROR("enumerate display resource failed.\n");
+		goto err_cleanup;
+	}
+
+	return mdev;
+
+err_cleanup:
+	komeda_dev_destroy(mdev);
+	return ERR_PTR(err);
+}
+
+void komeda_dev_destroy(struct komeda_dev *mdev)
+{
+	struct device *dev = mdev->dev;
+	struct komeda_dev_funcs *funcs = mdev->funcs;
+	int i;
+
+	for (i = 0; i < mdev->n_pipelines; i++) {
+		komeda_pipeline_destroy(mdev, mdev->pipelines[i]);
+		mdev->pipelines[i] = NULL;
+	}
+
+	mdev->n_pipelines = 0;
+
+	if (funcs && funcs->cleanup)
+		funcs->cleanup(mdev);
+
+	if (mdev->reg_base) {
+		devm_iounmap(dev, mdev->reg_base);
+		mdev->reg_base = NULL;
+	}
+
+	if (mdev->mclk) {
+		devm_clk_put(dev, mdev->mclk);
+		mdev->mclk = NULL;
+	}
+
+	if (mdev->pclk) {
+		clk_disable_unprepare(mdev->pclk);
+		devm_clk_put(dev, mdev->pclk);
+		mdev->pclk = NULL;
+	}
+
+	devm_kfree(dev, mdev);
+}
