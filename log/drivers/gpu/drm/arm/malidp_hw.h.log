commit d298e6a27a81362af4b755db2e89469c2a609cd8
Author: Wen He <wen.he_1@nxp.com>
Date:   Tue Sep 10 15:59:13 2019 +0800

    drm/arm/mali-dp: Add display QoS interface configuration for Mali DP500
    
    Configure the display Quality of service (QoS) levels priority if the
    optional property node "arm,malidp-aqros-value" is defined in DTS file.
    
    QoS signaling using AQROS and AWQOS AXI interface signals, the AQROS is
    driven from the "RQOS" register, so needed to program the RQOS register
    to avoid the high resolutions flicker issue on the LS1028A platform.
    
    Signed-off-by: Wen He <wen.he_1@nxp.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190910075913.17650-2-wen.he_1@nxp.com

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 968a65eed371..e4c36bc90bda 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -251,6 +251,9 @@ struct malidp_hw_device {
 
 	/* size of memory used for rotating layers, up to two banks available */
 	u32 rotation_memory[2];
+
+	/* priority level of RQOS register used for driven the ARQOS signal */
+	u32 arqos_value;
 };
 
 static inline u32 malidp_hw_read(struct malidp_hw_device *hwdev, u32 reg)

commit e559355a9da60a2388893d9e9da66c79fd604b9a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:57 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 443
    
    Based on 1 normalized pattern(s):
    
      this program is free software and is provided to you under the terms
      of the gnu general public license version 2 as published by the free
      software foundation and any use by you of this program is subject to
      the terms of such gnu licence
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 13 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190115.691558990@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 207c3ce52f1a..968a65eed371 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -1,12 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  *
  * (C) COPYRIGHT 2013-2016 ARM Limited. All rights reserved.
  *
- * This program is free software and is provided to you under the terms of the
- * GNU General Public License version 2 as published by the Free Software
- * Foundation, and any use by you of this program is subject to the terms
- * of such GNU licence.
- *
  * ARM Mali DP hardware manipulation routines.
  */
 

commit b8207562abdda11fab394c9f91db31c03a969cbb
Author: Ayan Kumar Halder <ayan.halder@arm.com>
Date:   Mon Sep 17 16:07:41 2018 +0100

    drm/arm/malidp: Specified the rotation memory requirements for AFBC YUV formats
    
    The newly supported AFBC YUV formats have the following rotation memory
    constraints (in DP550/DP650).
    1. DRM_FORMAT_VUY888/DRM_FORMAT_VUY101010 :- It can rotate upto 8
    horizontal lines in the AFBC output buffer.
    2. DRM_FORMAT_YUV420_8BIT :- It can rotate upto 16 horizontal lines
    in the AFBC output buffer.
    
    Also some of the pixel formats are specified in bits per pixel (rather
    than bytes per pixel), so the calculation needs to take note of this.
    
    Besides there are some difference between DP550 and DP650 and these are
    as follows:-
    1. DRM_FORMAT_X0L2 (in uncompressed format) does not support rotation in
    DP550. For DP650, it can rotate upto 16 horizontal lines in the AFBC
    output buffer, whereas in DP550 (with AFBC), it can rotate upto 8
    horizontal lines.
    2. DRM_FORMAT_YUV420_10BIT :- It can rotate upto 8 horizontal lines in
    dp550 and 16 horizontal lines in DP650.
    
    Changes since v3 (series):
    - Added the ack
    - Rebased on the latest drm-misc-next
    
    Signed-off-by: Ayan Kumar halder <ayan.halder@arm.com>
    Reviewed-by: Liviu Dudau <liviu.dudau@arm.com>
    Acked-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
    Link: https://patchwork.freedesktop.org/patch/291763/?series=57895&rev=1

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 0859302fd909..207c3ce52f1a 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -184,7 +184,8 @@ struct malidp_hw {
 	 * Calculate the required rotation memory given the active area
 	 * and the buffer format.
 	 */
-	int (*rotmem_required)(struct malidp_hw_device *hwdev, u16 w, u16 h, u32 fmt);
+	int (*rotmem_required)(struct malidp_hw_device *hwdev, u16 w, u16 h,
+			       u32 fmt, bool has_modifier);
 
 	int (*se_set_scaling_coeffs)(struct malidp_hw_device *hwdev,
 				     struct malidp_se_config *se_config,
@@ -326,6 +327,8 @@ void malidp_se_irq_fini(struct malidp_hw_device *hwdev);
 u8 malidp_hw_get_format_id(const struct malidp_hw_regmap *map,
 			   u8 layer_id, u32 format, bool has_modifier);
 
+int malidp_format_get_bpp(u32 fmt);
+
 static inline u8 malidp_hw_get_pitch_align(struct malidp_hw_device *hwdev, bool rotated)
 {
 	/*

commit 5e290226b11b19ab2300f25644359990e7c1b1d1
Author: Ayan Kumar Halder <ayan.halder@arm.com>
Date:   Tue Jul 17 12:11:09 2018 +0100

    drm/arm/malidp:- Define a common list of AFBC format modifiers supported for DP500, DP550 and DP650
    
    We need to define a common list of format modifiers supported by each of
    the Mali display processors.
    
    The following are the constraints with AFBC:-
    
    1. AFBC is not supported for the formats defined in
    malidp_hw_format_is_linear_only()
    
    2. Some of the formats are supported only with AFBC modifiers. Thus we have
    introduced a new function 'malidp_hw_format_is_afbc_only()' which verifies
    the same.
    
    3. AFBC_FORMAT_MOD_YTR needs to be provided for any RGB format.
    
    4. Formats <= 16bpp cannot support AFBC_FORMAT_MOD_SPLIT.
    
    5. CBR should not be set for non-subsampled formats.
    
    6. SMART layer does not support framebuffer with AFBC modifiers.
    Return -EINVAL for such a scenario.
    
    7. AFBC_FORMAT_MOD_YTR is not supported for any YUV formats.
    
    8. Formats which are subsampled cannot support AFBC_FORMAT_MOD_SPLIT.
    However in DP550, YUV_420_10BIT is supported with AFBC_FORMAT_MOD_SPLIT.
    This feature has been identified with
    MALIDP_DEVICE_AFBC_YUV_420_10_SUPPORT_SPLIT.
    
    9. In DP550 and DP650, for YUYV, the hardware supports different
    format-ids to be used with and without AFBC modifier. We have used the
    feature 'MALIDP_DEVICE_AFBC_YUYV_USE_422_P2' to identify this
    characteristic.
    
    10. DP500 does not support split mode (ie AFBC_FORMAT_MOD_SPLIT). We have
    used the feature 'MALIDP_DEVICE_AFBC_SUPPORT_SPLIT' to identify the DPs
    which support SPLIT mode.
    
    11. DP550 supports YUV420 with split mode. We have defined the feature
    'AFBC_SUPPORT_SPLIT_WITH_YUV_420_10' to identify this characteristic.
    
    Changes since v1:-
    - Merged https://patchwork.freedesktop.org/patch/265215/ into this patch
    - As Liviu pointed out in the last patch, we can pull the checks outside
    of the 'while (*modifiers != DRM_FORMAT_MOD_INVALID)' loop
    - Rebased
    
    Changes since v3 (series):
    - Added the ack
    - Rebased on the latest drm-misc-next
    
    Signed-off-by: Ayan Kumar halder <ayan.halder@arm.com>
    Reviewed-by: Liviu Dudau <liviu.dudau@arm.com>
    Acked-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
    Link: https://patchwork.freedesktop.org/patch/291762/?series=57895&rev=1

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 651558f403c6..0859302fd909 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -95,7 +95,10 @@ struct malidp_se_config {
 };
 
 /* regmap features */
-#define MALIDP_REGMAP_HAS_CLEARIRQ	(1 << 0)
+#define MALIDP_REGMAP_HAS_CLEARIRQ				BIT(0)
+#define MALIDP_DEVICE_AFBC_SUPPORT_SPLIT			BIT(1)
+#define MALIDP_DEVICE_AFBC_YUV_420_10_SUPPORT_SPLIT		BIT(2)
+#define MALIDP_DEVICE_AFBC_YUYV_USE_422_P2			BIT(3)
 
 struct malidp_hw_regmap {
 	/* address offset of the DE register bank */
@@ -321,7 +324,7 @@ int malidp_se_irq_init(struct drm_device *drm, int irq);
 void malidp_se_irq_fini(struct malidp_hw_device *hwdev);
 
 u8 malidp_hw_get_format_id(const struct malidp_hw_regmap *map,
-			   u8 layer_id, u32 format);
+			   u8 layer_id, u32 format, bool has_modifier);
 
 static inline u8 malidp_hw_get_pitch_align(struct malidp_hw_device *hwdev, bool rotated)
 {
@@ -390,9 +393,18 @@ static inline void malidp_se_set_enh_coeffs(struct malidp_hw_device *hwdev)
 
 #define MALIDP_GAMMA_LUT_SIZE		4096
 
-#define AFBC_MOD_VALID_BITS (AFBC_FORMAT_MOD_BLOCK_SIZE_MASK | \
-			AFBC_FORMAT_MOD_YTR | AFBC_FORMAT_MOD_SPLIT | \
-			AFBC_FORMAT_MOD_SPARSE | AFBC_FORMAT_MOD_CBR | \
-			AFBC_FORMAT_MOD_TILED | AFBC_FORMAT_MOD_SC)
+#define AFBC_SIZE_MASK		AFBC_FORMAT_MOD_BLOCK_SIZE_MASK
+#define AFBC_SIZE_16X16		AFBC_FORMAT_MOD_BLOCK_SIZE_16x16
+#define AFBC_YTR		AFBC_FORMAT_MOD_YTR
+#define AFBC_SPARSE		AFBC_FORMAT_MOD_SPARSE
+#define AFBC_CBR		AFBC_FORMAT_MOD_CBR
+#define AFBC_SPLIT		AFBC_FORMAT_MOD_SPLIT
+#define AFBC_TILED		AFBC_FORMAT_MOD_TILED
+#define AFBC_SC			AFBC_FORMAT_MOD_SC
+
+#define AFBC_MOD_VALID_BITS	(AFBC_SIZE_MASK | AFBC_YTR | AFBC_SPLIT | \
+				 AFBC_SPARSE | AFBC_CBR | AFBC_TILED | AFBC_SC)
+
+extern const u64 malidp_format_modifiers[];
 
 #endif  /* __MALIDP_HW_H__ */

commit 54b4260ac404813d97a499eec370204f6de8f43b
Author: Ayan Kumar Halder <ayan.halder@arm.com>
Date:   Wed May 16 19:23:08 2018 +0100

    drm/arm/malidp: Set the AFBC register bits if the framebuffer has AFBC modifier
    
    Added the AFBC decoder registers for DP500 , DP550 and DP650.
    These registers control the processing of AFBC buffers. It controls various
    features like AFBC decoder enable, lossless transformation and block split
    as well as setting of the left, right, top and bottom cropping of AFBC
    buffers (in number of pixels).
    All the layers (except DE_SMART) support framebuffers with AFBC modifiers.
    One needs to set the pixel values of the top, left, bottom and right
    cropping for the AFBC framebuffer.
    Cropping an AFBC framebuffer is controlled by the AFBC crop registers.
    In that case, the layer input size registers should be configured with
    framebuffer's dimensions and not with drm_plane_state source width/height
    values (which is used for non AFBC framebuffer to denote cropping).
    
    Changes from v1:
     - Removed the "if (fb->modifier)" check from malidp_de_plane_update()
    and added it in malidp_de_set_plane_afbc(). This will consolidate all the
    AFBC specific register configurations in a single function ie
    malidp_de_set_plane_afbc().
    
    Changes from v2:
     - For AFBC framebuffer, layer input size register should be set to
    framebuffer's width and height.
    
    Changes from v3:
    - Rebased on top of latest drm-misc-next
    - Some cleanups/sanity changes based on Liviu's comments
    
    Changes from v3 (series):
    - Added the ack
    - Rebased on the latest drm-misc-next
    
    Signed-off-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Reviewed-by: Liviu Dudau <liviu.dudau@arm.com>
    Acked-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
    Link: https://patchwork.freedesktop.org/patch/291760/?series=57895&rev=1

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 40155e2ea9d9..651558f403c6 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -70,6 +70,8 @@ struct malidp_layer {
 	s16 yuv2rgb_offset;	/* offset to the YUV->RGB matrix entries */
 	u16 mmu_ctrl_offset;    /* offset to the MMU control register */
 	enum rotation_features rot;	/* type of rotation supported */
+	/* address offset for the AFBC decoder registers */
+	u16 afbc_decoder_offset;
 };
 
 enum malidp_scaling_coeff_set {

commit 3dae1c0919d8c46710187df4fa1a43622289a1f5
Author: Ayan Kumar Halder <ayan.halder@arm.com>
Date:   Tue Jul 10 14:18:55 2018 +0100

    drm/arm/malidp: Implemented the size validation for AFBC framebuffers
    
    AFBC buffers include additional metadata which increases the required
    allocation size. Implement the appropriate size validation and sanity
    checking for AFBC buffers.
    Added malidp specific function for framebuffer creation. This checks
    if the framebuffer has AFBC modifiers and if so, it verifies the
    necessary constraints on the size, alignment, offsets and pitch.
    
    Changes from v2:
    - Replaced DRM_ERROR() with DRM_DEBUG_KMS() in
    malidp_verify_afbc_framebuffer_caps() and malidp_verify_afbc_framebuffer_size()
    
    Signed-off-by: Ayan Kumar halder <ayan.halder@arm.com>
    Reviewed-by: Brian Starkey <brian.starkey@arm.com>
    Reviewed-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 3ab133d49bba..40155e2ea9d9 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -388,4 +388,9 @@ static inline void malidp_se_set_enh_coeffs(struct malidp_hw_device *hwdev)
 
 #define MALIDP_GAMMA_LUT_SIZE		4096
 
+#define AFBC_MOD_VALID_BITS (AFBC_FORMAT_MOD_BLOCK_SIZE_MASK | \
+			AFBC_FORMAT_MOD_YTR | AFBC_FORMAT_MOD_SPLIT | \
+			AFBC_FORMAT_MOD_SPARSE | AFBC_FORMAT_MOD_CBR | \
+			AFBC_FORMAT_MOD_TILED | AFBC_FORMAT_MOD_SC)
+
 #endif  /* __MALIDP_HW_H__ */

commit 66da13a519b33143932df5dc89973781c027c827
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Tue Oct 2 12:11:00 2018 +0100

    drm/arm/malidp: Validate rotations for compressed/uncompressed framebuffers for each layer
    
    Add support for compressed framebuffers that are described using
    the framebuffer's modifier field. Mali DP uses the rotation memory for
    the decompressor of the format, so we need to check for space when
    the modifiers are present.
    
    Signed-off-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Reviewed-by: Brian Starkey <brian.starkey@arm.com>
    [re-worded commit, rebased, cleaned up duplicated checks for
     RGB888 and BGR888 and removed additional parameter for
     rotmem_required function hook]
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 0d7f9ea0ade8..3ab133d49bba 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -36,6 +36,12 @@ enum {
 	SE_MEMWRITE = BIT(5),
 };
 
+enum rotation_features {
+	ROTATE_NONE,		/* does not support rotation at all */
+	ROTATE_ANY,		/* supports rotation on any buffers */
+	ROTATE_COMPRESSED,	/* supports rotation only on compressed buffers */
+};
+
 struct malidp_format_id {
 	u32 format;		/* DRM fourcc */
 	u8 layer;		/* bitmask of layers supporting it */
@@ -63,6 +69,7 @@ struct malidp_layer {
 	u16 stride_offset;	/* offset to the first stride register. */
 	s16 yuv2rgb_offset;	/* offset to the YUV->RGB matrix entries */
 	u16 mmu_ctrl_offset;    /* offset to the MMU control register */
+	enum rotation_features rot;	/* type of rotation supported */
 };
 
 enum malidp_scaling_coeff_set {

commit 1f23a56a46b81de50eb8b898f06296ca06720a99
Author: Jamie Fox <jamie.fox@arm.com>
Date:   Mon Oct 1 14:39:07 2018 +0100

    drm/malidp: Enable MMU prefetch on Mali-DP650
    
    Mali-DP650 supports warming up the SMMU translations, by sending
    requsts to the SMMU before a buffer is read.
    
    There are two modes supported:
    
    - PARTIAL: could be enabled when the buffer is composed of 4K or 64K
      pages, the display hardware will send a configurable number of
      requests before the actual reading.
    
    - FULL: could be enabled when the buffer is composed of 1M or 2M
      pages, the display hardware will send requests before reading for
      all pages composing the buffer.
    
    This patch adds a mechanism for detecting the page size and set the
    MMU prefetch mode if possible.
    
    Changes since v1:
     - For imported buffers use the already populated
       drm_gem_cma_object.sgt instead of calling
       driver.gem_prime_get_sg_table, which works just for buffers
       allocated through the gem_cma API.
    
    Signed-off-by: Jamie Fox <jamie.fox@arm.com>
    Signed-off-by: Alexandru Gheorghe <alexandru-cosmin.gheorghe@arm.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    [rebased and re-ordered functions]
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 9fc94c08190f..0d7f9ea0ade8 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -62,6 +62,7 @@ struct malidp_layer {
 	u16 ptr;		/* address offset for the pointer register */
 	u16 stride_offset;	/* offset to the first stride register. */
 	s16 yuv2rgb_offset;	/* offset to the YUV->RGB matrix entries */
+	u16 mmu_ctrl_offset;    /* offset to the MMU control register */
 };
 
 enum malidp_scaling_coeff_set {

commit b11507815d1be0173e27990ffcae6da58eadbc10
Author: Alexandru Gheorghe <alexandru-cosmin.gheorghe@arm.com>
Date:   Wed Aug 22 16:18:19 2018 +0100

    drm/malidp: Fix writeback in NV12
    
    When we want to writeback to memory in NV12 format we need to program
    the RGB2YUV coefficients. Currently, we don't program the coefficients
    and NV12 doesn't work at all.
    
    This patchset fixes that by programming a sane default(bt709, limited
    range) as rgb2yuv coefficients.
    
    In the long run, probably we need to think of a way for userspace to
    be able to program that, but for now I think this is better than not
    working at all or not advertising NV12 as a supported format for
    memwrite.
    
    Changes since v1:
     - Write the rgb2yuv coefficients only once, since we don't change
       them at all, just write them the first time NV12 is programmed,
       suggested by Brian Starkey, here [1]
    
    [1] https://lists.freedesktop.org/archives/dri-devel/2018-August/186819.html
    
    Signed-off-by: Alexandru Gheorghe <alexandru-cosmin.gheorghe@arm.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index ad2e96915d44..9fc94c08190f 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -191,7 +191,8 @@ struct malidp_hw {
 	 * @param fmt_id - internal format ID of output buffer
 	 */
 	int (*enable_memwrite)(struct malidp_hw_device *hwdev, dma_addr_t *addrs,
-			       s32 *pitches, int num_planes, u16 w, u16 h, u32 fmt_id);
+			       s32 *pitches, int num_planes, u16 w, u16 h, u32 fmt_id,
+			       const s16 *rgb2yuv_coeffs);
 
 	/*
 	 * Disable the writing to memory of the next frame's content.

commit f877006d5db49f3615fcee4bd5eb1a56c053d419
Author: Ayan Kumar Halder <ayan.halder@arm.com>
Date:   Tue May 15 17:04:18 2018 +0100

    drm/arm/malidp: Set the output_depth register in modeset
    
    One needs to store the value of the OUTPUT_DEPTH that one has parsed from
    device tree, so that it can be restored on system resume. This value is
    set in the modeset function as this gets reset when the system suspends.
    
    Signed-off-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index f5b3eab8398b..ad2e96915d44 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -230,6 +230,7 @@ struct malidp_hw_device {
 
 	u8 min_line_size;
 	u16 max_line_size;
+	u32 output_color_depth;
 
 	/* track the device PM state */
 	bool pm_suspended;

commit ff8fc26a764acdf5e0a2f86430bcb96c7b4eebec
Author: Ayan Kumar Halder <ayan.halder@arm.com>
Date:   Tue May 15 17:04:16 2018 +0100

    drm/arm/malidp: Split malidp interrupt initialization functions.
    
    Malidp uses two interrupts ie 1. se_irq - used for memory writeback.
     and 2. de_irq - used for display output.
    Extract the hardware initialization part from malidp interrupt registration
    ie (malidp_de_irq_init()/ malidp_se_irq_init()) into a separate function
    (ie malidp_de_irq_hw_init()/malidp_se_irq_hw_init())
    which will be later invoked from runtime_pm_resume function when it needs
    to re-enable the interrupts.
    
    Signed-off-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 8304d7763b8d..f5b3eab8398b 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -302,6 +302,8 @@ static inline void malidp_hw_enable_irq(struct malidp_hw_device *hwdev,
 }
 
 int malidp_de_irq_init(struct drm_device *drm, int irq);
+void malidp_se_irq_hw_init(struct malidp_hw_device *hwdev);
+void malidp_de_irq_hw_init(struct malidp_hw_device *hwdev);
 void malidp_de_irq_fini(struct malidp_hw_device *hwdev);
 int malidp_se_irq_init(struct drm_device *drm, int irq);
 void malidp_se_irq_fini(struct malidp_hw_device *hwdev);

commit 62862cfbb18d10c5f8409f4c8e49c4bbaaf18d3a
Author: Ayan Kumar Halder <ayan.halder@arm.com>
Date:   Tue May 15 17:04:15 2018 +0100

    drm/arm/malidp: Modified the prototype of malidp irq de-initializers
    
    Malidp uses two interrupts ie 1. se_irq - used for memory writeback.
     and 2. de_irq - used for display output.
    'struct drm_device' is being replaced with 'struct malidp_hw_device'
    as the function argument. The reason being the dependency of
    malidp_de_irq_fini on 'struct drm_device' needs to be removed so as to
    enable it to call from functions which receives 'struct malidp_hw_device'
    as argument. Furthermore, there is no way to retrieve 'struct drm_device'
    from 'struct malidp_hw_device'.
    
    Signed-off-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 5b99445433a2..8304d7763b8d 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -302,9 +302,9 @@ static inline void malidp_hw_enable_irq(struct malidp_hw_device *hwdev,
 }
 
 int malidp_de_irq_init(struct drm_device *drm, int irq);
-void malidp_de_irq_fini(struct drm_device *drm);
+void malidp_de_irq_fini(struct malidp_hw_device *hwdev);
 int malidp_se_irq_init(struct drm_device *drm, int irq);
-void malidp_se_irq_fini(struct drm_device *drm);
+void malidp_se_irq_fini(struct malidp_hw_device *hwdev);
 
 u8 malidp_hw_get_format_id(const struct malidp_hw_regmap *map,
 			   u8 layer_id, u32 format);

commit 613c5c7fc8152866a798c52a5944e4b437b526f5
Author: Alexandru Gheorghe <alexandru-cosmin.gheorghe@arm.com>
Date:   Tue May 15 11:18:50 2018 +0100

    drm: mali-dp: Add debugfs file for reporting internal errors
    
    Status register contains a lot of bits for reporting internal errors
    inside Mali DP. Currently, we just silently ignore all of the errors,
    that doesn't help when we are investigating different bugs, especially
    on the FPGA models which have a lot of constraints, so we could easily
    end up in AXI or underrun errors.
    
    Add a new file called debug that contains an aggregate of the
    errors reported by the Mali DP hardware.
    
    E.g:
    [root@alarm ~]# cat /sys/kernel/debug/dri/1/debug
    [DE] num_errors : 167
    [DE] last_error_status  : 0x00000001
    [DE] last_error_vblank : 385
    [SE] num_errors : 3
    [SE] last_error_status  : 0x00e23001
    [SE] last_error_vblank : 201
    
    Changes since v2:
    - Add lock to protect the errors stats.
    - Add possibility to reset the error stats by writing anything to the
      debug file.
    
    Signed-off-by: Alexandru Gheorghe <alexandru-cosmin.gheorghe@arm.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index bd41aa6974a0..5b99445433a2 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -53,6 +53,7 @@ struct malidp_format_id {
 struct malidp_irq_map {
 	u32 irq_mask;		/* mask of IRQs that can be enabled in the block */
 	u32 vsync_irq;		/* IRQ bit used for signaling during VSYNC */
+	u32 err_mask;		/* mask of bits that represent errors */
 };
 
 struct malidp_layer {

commit 0735cfdf0af4d4ffc3743fb75b9ad929dfd37206
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Fri Jun 15 16:56:09 2018 +0100

    drm/mali-dp: Improve writeback handling for DP500.
    
    Mali DP500 operates in continuous writeback mode (writes frame content
    until stopped) and it needs special handling in order to behave like
    a one-shot writeback engine. The original state machine added for DP500
    was a bit fragile, as it did not handle correctly cases where a new
    atomic commit was in progress when the SE IRQ happens and it would
    commit some partial updates.
    
    Improve the handling by adding a parameter to the set_config_valid()
    function to clear the config valid bit in hardware before starting a
    new commit and by introducing a MW_RESTART state in the writeback
    state machine to cater for the case where a new writeback commit
    gets submitted while the last one is still being active.
    
    Reported-by: Brian Starkey <brian.starkey@arm.com>
    Reviewed-by: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index c479738b81af..bd41aa6974a0 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -152,12 +152,13 @@ struct malidp_hw {
 	bool (*in_config_mode)(struct malidp_hw_device *hwdev);
 
 	/*
-	 * Set configuration valid flag for hardware parameters that can
-	 * be changed outside the configuration mode. Hardware will use
-	 * the new settings when config valid is set after the end of the
-	 * current buffer scanout
+	 * Set/clear configuration valid flag for hardware parameters that can
+	 * be changed outside the configuration mode to the given value.
+	 * Hardware will use the new settings when config valid is set,
+	 * after the end of the current buffer scanout, and will ignore
+	 * any new values for those parameters if config valid flag is cleared
 	 */
-	void (*set_config_valid)(struct malidp_hw_device *hwdev);
+	void (*set_config_valid)(struct malidp_hw_device *hwdev, u8 value);
 
 	/*
 	 * Set a new mode in hardware. Requires the hardware to be in

commit 1cb3cbe732d9bedd4046bbeb2726d1699cdfabce
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Tue Apr 10 17:25:57 2018 +0100

    drm/mali-dp: Add writeback support for DP500.
    
    Mali DP500 behaves differently from the rest of the Mali DP IP,
    in that it does not have a one-shot mode and keeps writing the
    content of the current frame to the provided memory area until
    stopped. As a way of emulating the one-shot behaviour, we are
    going to use the CVAL interrupt that is being raised at the
    start of each frame, during prefetch phase, to act as End-of-Write
    signal, but with a twist: we are going to disable the memory
    write engine right after we're notified that it has been enabled,
    using the knowledge that the bit controlling the enabling will
    only be acted upon on the next vblank/prefetch.
    
    CVAL interrupt will fire durint the next prefetch phase every time
    the global CVAL bit gets set, so we need a state byte to track
    the memory write enabling. We also need to pay attention during the
    disabling of the memory write engine as that requires the CVAL bit
    to be set in the control register, but we don't want to do that
    during an atomic commit, as it will write into the hardware a partial
    state.
    
    Reviewed-by: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index a242e97cf642..c479738b81af 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -178,7 +178,7 @@ struct malidp_hw {
 	long (*se_calc_mclk)(struct malidp_hw_device *hwdev,
 			     struct malidp_se_config *se_config,
 			     struct videomode *vm);
-	/**
+	/*
 	 * Enable writing to memory the content of the next frame
 	 * @param hwdev - malidp_hw_device structure containing the HW description
 	 * @param addrs - array of addresses for each plane
@@ -232,6 +232,9 @@ struct malidp_hw_device {
 	/* track the device PM state */
 	bool pm_suspended;
 
+	/* track the SE memory writeback state */
+	u8 mw_state;
+
 	/* size of memory used for rotating layers, up to two banks available */
 	u32 rotation_memory[2];
 };

commit a67bbbe225c281f441533d55cd9dce5c2ae207a5
Author: Brian Starkey <brian.starkey@arm.com>
Date:   Wed Mar 29 17:42:35 2017 +0100

    drm: mali-dp: Add RGB writeback formats for DP550/DP650
    
    Add a layer bit for the SE memory-write, and add it to the pixel format
    matrix for DP550/DP650.
    
    Signed-off-by: Brian Starkey <brian.starkey@arm.com>
    [rebased and fixed conflicts]
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 72cc22f82836..a242e97cf642 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -33,6 +33,7 @@ enum {
 	DE_GRAPHICS2 = BIT(2), /* used only in DP500 */
 	DE_VIDEO2 = BIT(3),
 	DE_SMART = BIT(4),
+	SE_MEMWRITE = BIT(5),
 };
 
 struct malidp_format_id {

commit 846c87a068f4b72e200357b899ca4dcc92ef42c4
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Wed Mar 29 17:42:34 2017 +0100

    drm: mali-dp: Add support for writeback on DP550/DP650
    
    Mali-DP display processors are able to write the composition result to a
    memory buffer via the SE.
    
    Add entry points in the HAL for enabling/disabling this feature, and
    implement support for it on DP650 and DP550. DP500 acts differently and
    so is omitted from this change.
    
    Changes since v3:
     - Fix missing vsync interrupt for DP550
    
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Brian Starkey <brian.starkey@arm.com>
    [rebased and fixed conflicts]
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index b5dd6c73ec9f..72cc22f82836 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -177,6 +177,23 @@ struct malidp_hw {
 	long (*se_calc_mclk)(struct malidp_hw_device *hwdev,
 			     struct malidp_se_config *se_config,
 			     struct videomode *vm);
+	/**
+	 * Enable writing to memory the content of the next frame
+	 * @param hwdev - malidp_hw_device structure containing the HW description
+	 * @param addrs - array of addresses for each plane
+	 * @param pitches - array of pitches for each plane
+	 * @param num_planes - number of planes to be written
+	 * @param w - width of the output frame
+	 * @param h - height of the output frame
+	 * @param fmt_id - internal format ID of output buffer
+	 */
+	int (*enable_memwrite)(struct malidp_hw_device *hwdev, dma_addr_t *addrs,
+			       s32 *pitches, int num_planes, u16 w, u16 h, u32 fmt_id);
+
+	/*
+	 * Disable the writing to memory of the next frame's content.
+	 */
+	void (*disable_memwrite)(struct malidp_hw_device *hwdev);
 
 	u8 features;
 };

commit 6e810eb508f4b937bc2a718bd4e5cd74cca55500
Author: Mihail Atanassov <mihail.atanassov@arm.com>
Date:   Tue Nov 7 15:30:46 2017 +0000

    drm: mali-dp: Add YUV->RGB conversion support for video layers
    
    Internally Mali DP uses an RGB pipeline so video layers that support
    YUV input buffers need to convert the input data to RGB. The YUV
    buffers can have various encodings and this patch introduces support
    for BT.601, BT.709 and BT.2020 encodings, both limited and full ranges.
    
    This patch adds support for specifying the color encoding of the
    input buffers for the planes that are backed by the video layers
    and programs the YUV2RGB coefficients into hardware based on the
    selected encoding.
    
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>
    [updated to use standard properties]
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 42d3e7b9ba98..b5dd6c73ec9f 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -58,7 +58,8 @@ struct malidp_layer {
 	u16 id;			/* layer ID */
 	u16 base;		/* address offset for the register bank */
 	u16 ptr;		/* address offset for the pointer register */
-	u16 stride_offset;	/* Offset to the first stride register. */
+	u16 stride_offset;	/* offset to the first stride register. */
+	s16 yuv2rgb_offset;	/* offset to the YUV->RGB matrix entries */
 };
 
 enum malidp_scaling_coeff_set {

commit fcad73b9b1fb9580fd43f1349fd8ab34d5d456e9
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Tue Dec 5 16:51:03 2017 +0000

    drm/mali-dp: Rotated planes need a larger pitch size.
    
    Rotated planes need a pitch size that is aligned to 8 bytes
    for older DP500 and DP550 and at least 64 bytes for DP650. Replace
    the malidp_hw_pitch_valid() function with one that calculates
    the correct pitch alignment to take into account rotation.
    
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index b0690ebb3565..42d3e7b9ba98 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -285,10 +285,16 @@ void malidp_se_irq_fini(struct drm_device *drm);
 u8 malidp_hw_get_format_id(const struct malidp_hw_regmap *map,
 			   u8 layer_id, u32 format);
 
-static inline bool malidp_hw_pitch_valid(struct malidp_hw_device *hwdev,
-					 unsigned int pitch)
+static inline u8 malidp_hw_get_pitch_align(struct malidp_hw_device *hwdev, bool rotated)
 {
-	return !(pitch & (hwdev->hw->map.bus_align_bytes - 1));
+	/*
+	 * only hardware that cannot do 8 bytes bus alignments have further
+	 * constraints on rotated planes
+	 */
+	if (hwdev->hw->map.bus_align_bytes == 8)
+		return 8;
+	else
+		return hwdev->hw->map.bus_align_bytes << (rotated ? 2 : 0);
 }
 
 /* U16.16 */

commit a6993b215a719ad5758c1bced5f8df95add070bf
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Thu Aug 31 15:48:43 2017 +0100

    drm: mali-dp: Separate static internal data into a read-only structure.
    
    The malidp_hw_device structure that the driver uses to handle the
    differences between versions of the IP contains both non-changeable
    data and fields that get updated at probe time. Previously we were
    copying the read-only part into allocated memory, but that can be
    completely avoided by splitting the structure into a read-only part
    and keeping the runtime modifiable fields into the old structure.
    
    Reviewed-by: Brian Starkey <brian.starkey@arm.com>
    Reviewed-by: Gustavo Padovan <gustavo.padovan@collabora.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 849ad9a30c3a..b0690ebb3565 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -120,18 +120,14 @@ struct malidp_hw_regmap {
 /* Unlike DP550/650, DP500 has 3 stride registers in its video layer. */
 #define MALIDP_DEVICE_LV_HAS_3_STRIDES	BIT(0)
 
-struct malidp_hw_device {
-	const struct malidp_hw_regmap map;
-	void __iomem *regs;
+struct malidp_hw_device;
 
-	/* APB clock */
-	struct clk *pclk;
-	/* AXI clock */
-	struct clk *aclk;
-	/* main clock for display core */
-	struct clk *mclk;
-	/* pixel clock for display core */
-	struct clk *pxlclk;
+/*
+ * Static structure containing hardware specific data and pointers to
+ * functions that behave differently between various versions of the IP.
+ */
+struct malidp_hw {
+	const struct malidp_hw_regmap map;
 
 	/*
 	 * Validate the driver instance against the hardware bits
@@ -182,15 +178,6 @@ struct malidp_hw_device {
 			     struct videomode *vm);
 
 	u8 features;
-
-	u8 min_line_size;
-	u16 max_line_size;
-
-	/* track the device PM state */
-	bool pm_suspended;
-
-	/* size of memory used for rotating layers, up to two banks available */
-	u32 rotation_memory[2];
 };
 
 /* Supported variants of the hardware */
@@ -202,7 +189,33 @@ enum {
 	MALIDP_MAX_DEVICES
 };
 
-extern const struct malidp_hw_device malidp_device[MALIDP_MAX_DEVICES];
+extern const struct malidp_hw malidp_device[MALIDP_MAX_DEVICES];
+
+/*
+ * Structure used by the driver during runtime operation.
+ */
+struct malidp_hw_device {
+	struct malidp_hw *hw;
+	void __iomem *regs;
+
+	/* APB clock */
+	struct clk *pclk;
+	/* AXI clock */
+	struct clk *aclk;
+	/* main clock for display core */
+	struct clk *mclk;
+	/* pixel clock for display core */
+	struct clk *pxlclk;
+
+	u8 min_line_size;
+	u16 max_line_size;
+
+	/* track the device PM state */
+	bool pm_suspended;
+
+	/* size of memory used for rotating layers, up to two banks available */
+	u32 rotation_memory[2];
+};
 
 static inline u32 malidp_hw_read(struct malidp_hw_device *hwdev, u32 reg)
 {
@@ -240,9 +253,9 @@ static inline u32 malidp_get_block_base(struct malidp_hw_device *hwdev,
 {
 	switch (block) {
 	case MALIDP_SE_BLOCK:
-		return hwdev->map.se_base;
+		return hwdev->hw->map.se_base;
 	case MALIDP_DC_BLOCK:
-		return hwdev->map.dc_base;
+		return hwdev->hw->map.dc_base;
 	}
 
 	return 0;
@@ -275,7 +288,7 @@ u8 malidp_hw_get_format_id(const struct malidp_hw_regmap *map,
 static inline bool malidp_hw_pitch_valid(struct malidp_hw_device *hwdev,
 					 unsigned int pitch)
 {
-	return !(pitch & (hwdev->map.bus_align_bytes - 1));
+	return !(pitch & (hwdev->hw->map.bus_align_bytes - 1));
 }
 
 /* U16.16 */
@@ -308,8 +321,8 @@ static inline void malidp_se_set_enh_coeffs(struct malidp_hw_device *hwdev)
 	};
 	u32 val = MALIDP_SE_SET_ENH_LIMIT_LOW(MALIDP_SE_ENH_LOW_LEVEL) |
 		  MALIDP_SE_SET_ENH_LIMIT_HIGH(MALIDP_SE_ENH_HIGH_LEVEL);
-	u32 image_enh = hwdev->map.se_base +
-			((hwdev->map.features & MALIDP_REGMAP_HAS_CLEARIRQ) ?
+	u32 image_enh = hwdev->hw->map.se_base +
+			((hwdev->hw->map.features & MALIDP_REGMAP_HAS_CLEARIRQ) ?
 			 0x10 : 0xC) + MALIDP_SE_IMAGE_ENH;
 	u32 enh_coeffs = image_enh + MALIDP_SE_ENH_COEFF0;
 	int i;

commit c2e7f82d336a451ebb904b8bf9a5a558cf16c39b
Author: Mihail Atanassov <mihail.atanassov@arm.com>
Date:   Mon Feb 13 15:09:01 2017 +0000

    drm: mali-dp: Check the mclk rate and allow up/down scaling
    
    When downscaling, mclk needs to be sufficiently higher than pxlclk in
    order to be able to fetch the higher-resolution data and produce output
    pixels. When not scaling, or when upscaling, mclk can be equal to
    pxlclk. Since the driver doesn't control mclk, just ensure that the
    requirement is satisfied with the current clock rate.
    
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index a93ae0a951a3..849ad9a30c3a 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -177,6 +177,10 @@ struct malidp_hw_device {
 				     struct malidp_se_config *se_config,
 				     struct malidp_se_config *old_config);
 
+	long (*se_calc_mclk)(struct malidp_hw_device *hwdev,
+			     struct malidp_se_config *se_config,
+			     struct videomode *vm);
+
 	u8 features;
 
 	u8 min_line_size;

commit 0274e6a0ba9a4994a449fcd3483ef530027e152f
Author: Mihail Atanassov <mihail.atanassov@arm.com>
Date:   Mon Feb 6 12:20:56 2017 +0000

    drm: mali-dp: Enable image enhancement when scaling
    
    Apply image enhacement when we are upscaling by a factor of 2
    or more in either direction.
    
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 52a65a8a056f..a93ae0a951a3 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -71,6 +71,7 @@ enum malidp_scaling_coeff_set {
 
 struct malidp_se_config {
 	u8 scale_enable : 1;
+	u8 enhancer_enable : 1;
 	u8 hcoeff : 3;
 	u8 vcoeff : 3;
 	u8 plane_src_id;
@@ -295,6 +296,25 @@ malidp_se_select_coeffs(u32 upscale_factor)
 #undef FP_0_50000
 #undef FP_0_66667
 #undef FP_1_00000
+
+static inline void malidp_se_set_enh_coeffs(struct malidp_hw_device *hwdev)
+{
+	static const s32 enhancer_coeffs[] = {
+		-8, -8, -8, -8, 128, -8, -8, -8, -8
+	};
+	u32 val = MALIDP_SE_SET_ENH_LIMIT_LOW(MALIDP_SE_ENH_LOW_LEVEL) |
+		  MALIDP_SE_SET_ENH_LIMIT_HIGH(MALIDP_SE_ENH_HIGH_LEVEL);
+	u32 image_enh = hwdev->map.se_base +
+			((hwdev->map.features & MALIDP_REGMAP_HAS_CLEARIRQ) ?
+			 0x10 : 0xC) + MALIDP_SE_IMAGE_ENH;
+	u32 enh_coeffs = image_enh + MALIDP_SE_ENH_COEFF0;
+	int i;
+
+	malidp_hw_write(hwdev, val, image_enh);
+	for (i = 0; i < ARRAY_SIZE(enhancer_coeffs); ++i)
+		malidp_hw_write(hwdev, enhancer_coeffs[i], enh_coeffs + i * 4);
+}
+
 /*
  * background color components are defined as 12bits values,
  * they will be shifted right when stored on hardware that

commit 28ce675b74742cae1c815970347267b45dc73a8a
Author: Mihail Atanassov <mihail.atanassov@arm.com>
Date:   Mon Feb 13 15:14:05 2017 +0000

    drm: mali-dp: Add plane upscaling support
    
    Enable the scaling engine for upscaling a single plane using the polyphase
    scaler. No image enhancement support or downscaling yet*, and composition
    result scaling is not implemented.
    
    * Downscaling a plane requires mclk > pxlclk.
    
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 470fe71724a3..52a65a8a056f 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -61,6 +61,25 @@ struct malidp_layer {
 	u16 stride_offset;	/* Offset to the first stride register. */
 };
 
+enum malidp_scaling_coeff_set {
+	MALIDP_UPSCALING_COEFFS = 1,
+	MALIDP_DOWNSCALING_1_5_COEFFS = 2,
+	MALIDP_DOWNSCALING_2_COEFFS = 3,
+	MALIDP_DOWNSCALING_2_75_COEFFS = 4,
+	MALIDP_DOWNSCALING_4_COEFFS = 5,
+};
+
+struct malidp_se_config {
+	u8 scale_enable : 1;
+	u8 hcoeff : 3;
+	u8 vcoeff : 3;
+	u8 plane_src_id;
+	u16 input_w, input_h;
+	u16 output_w, output_h;
+	u32 h_init_phase, h_delta_phase;
+	u32 v_init_phase, v_delta_phase;
+};
+
 /* regmap features */
 #define MALIDP_REGMAP_HAS_CLEARIRQ	(1 << 0)
 
@@ -153,6 +172,10 @@ struct malidp_hw_device {
 	 */
 	int (*rotmem_required)(struct malidp_hw_device *hwdev, u16 w, u16 h, u32 fmt);
 
+	int (*se_set_scaling_coeffs)(struct malidp_hw_device *hwdev,
+				     struct malidp_se_config *se_config,
+				     struct malidp_se_config *old_config);
+
 	u8 features;
 
 	u8 min_line_size;
@@ -250,6 +273,28 @@ static inline bool malidp_hw_pitch_valid(struct malidp_hw_device *hwdev,
 	return !(pitch & (hwdev->map.bus_align_bytes - 1));
 }
 
+/* U16.16 */
+#define FP_1_00000	0x00010000	/* 1.0 */
+#define FP_0_66667	0x0000AAAA	/* 0.6667 = 1/1.5 */
+#define FP_0_50000	0x00008000	/* 0.5 = 1/2 */
+#define FP_0_36363	0x00005D17	/* 0.36363 = 1/2.75 */
+#define FP_0_25000	0x00004000	/* 0.25 = 1/4 */
+
+static inline enum malidp_scaling_coeff_set
+malidp_se_select_coeffs(u32 upscale_factor)
+{
+	return (upscale_factor >= FP_1_00000) ? MALIDP_UPSCALING_COEFFS :
+	       (upscale_factor >= FP_0_66667) ? MALIDP_DOWNSCALING_1_5_COEFFS :
+	       (upscale_factor >= FP_0_50000) ? MALIDP_DOWNSCALING_2_COEFFS :
+	       (upscale_factor >= FP_0_36363) ? MALIDP_DOWNSCALING_2_75_COEFFS :
+	       MALIDP_DOWNSCALING_4_COEFFS;
+}
+
+#undef FP_0_25000
+#undef FP_0_36363
+#undef FP_0_50000
+#undef FP_0_66667
+#undef FP_1_00000
 /*
  * background color components are defined as 12bits values,
  * they will be shifted right when stored on hardware that

commit 6954f24588ebddc2e3c840103f02d1fe7e65a2d6
Author: Mihail Atanassov <mihail.atanassov@arm.com>
Date:   Mon Feb 13 12:49:03 2017 +0000

    drm: mali-dp: Add CTM support
    
    All DPs have a COLORADJ matrix which is applied prior to output gamma.
    Attach that to the CTM property. Also, ensure the input CTM's coefficients
    can fit in the DP registers' Q3.12 format.
    
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index c2df6b6e7645..470fe71724a3 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -259,6 +259,7 @@ static inline bool malidp_hw_pitch_valid(struct malidp_hw_device *hwdev,
 #define MALIDP_BGND_COLOR_G		0x000
 #define MALIDP_BGND_COLOR_B		0x000
 
+#define MALIDP_COLORADJ_NUM_COEFFS	12
 #define MALIDP_COEFFTAB_NUM_COEFFS	64
 
 #define MALIDP_GAMMA_LUT_SIZE		4096

commit 02725d31371b66b97bc58b2a81f0c6dc40970598
Author: Mihail Atanassov <mihail.atanassov@arm.com>
Date:   Wed Feb 1 14:48:50 2017 +0000

    drm: mali-dp: enable gamma support
    
    Add gamma via the DRM GAMMA_LUT/GAMMA_LUT_SIZE CRTC
    properties. The expected LUT size is 4096 in order
    to produce as accurate a set of segments as possible.
    
    This version uses only the green channel's gamma curve
    to set the hardware curve on DP550/650. For the sake of
    simplicity, it uses the same table of coefficients for
    all 3 curves on DP500.
    
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index ea2dbae08990..c2df6b6e7645 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -67,6 +67,8 @@ struct malidp_layer {
 struct malidp_hw_regmap {
 	/* address offset of the DE register bank */
 	/* is always 0x0000 */
+	/* address offset of the DE coefficients registers */
+	const u16 coeffs_base;
 	/* address offset of the SE registers bank */
 	const u16 se_base;
 	/* address offset of the DC registers bank */
@@ -257,4 +259,8 @@ static inline bool malidp_hw_pitch_valid(struct malidp_hw_device *hwdev,
 #define MALIDP_BGND_COLOR_G		0x000
 #define MALIDP_BGND_COLOR_B		0x000
 
+#define MALIDP_COEFFTAB_NUM_COEFFS	64
+
+#define MALIDP_GAMMA_LUT_SIZE		4096
+
 #endif  /* __MALIDP_HW_H__ */

commit 85f6421889eca68ceb0a0403c4c00b2eaf3c16e0
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Wed Mar 22 10:44:57 2017 +0000

    drm: mali-dp: Enable power management for the device.
    
    Enable runtime and system Power Management. Clocks are now managed
    from malidp_crtc_{enable,disable} functions. Suspend-to-RAM tested
    as working on Juno.
    
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 00974b59407d..ea2dbae08990 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -156,6 +156,9 @@ struct malidp_hw_device {
 	u8 min_line_size;
 	u16 max_line_size;
 
+	/* track the device PM state */
+	bool pm_suspended;
+
 	/* size of memory used for rotating layers, up to two banks available */
 	u32 rotation_memory[2];
 };
@@ -173,12 +176,14 @@ extern const struct malidp_hw_device malidp_device[MALIDP_MAX_DEVICES];
 
 static inline u32 malidp_hw_read(struct malidp_hw_device *hwdev, u32 reg)
 {
+	WARN_ON(hwdev->pm_suspended);
 	return readl(hwdev->regs + reg);
 }
 
 static inline void malidp_hw_write(struct malidp_hw_device *hwdev,
 				   u32 value, u32 reg)
 {
+	WARN_ON(hwdev->pm_suspended);
 	writel(value, hwdev->regs + reg);
 }
 

commit 83d642ee6dbec57ef1639a3de1e383fbfc5c44ec
Author: Mihail Atanassov <mihail.atanassov@arm.com>
Date:   Mon Jan 23 15:24:35 2017 +0000

    drm: mali-dp: fix stride setting for multi-plane formats
    
    Hardware has multiple (2 or 3, depending on model) stride
    registers per layer; add a function that correctly takes that
    into account. On hardware that only has 2 stride registers,
    ensure that 3-plane (YUV) content has identical strides
    for both chroma planes.
    
    Signed-off-by: Mihail Atanassov <mihail.atanassov@arm.com>
    [Removed smart layer stride setup, comment and commit message clarifications]
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 4f8c884d1960..00974b59407d 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -58,6 +58,7 @@ struct malidp_layer {
 	u16 id;			/* layer ID */
 	u16 base;		/* address offset for the register bank */
 	u16 ptr;		/* address offset for the pointer register */
+	u16 stride_offset;	/* Offset to the first stride register. */
 };
 
 /* regmap features */
@@ -93,6 +94,10 @@ struct malidp_hw_regmap {
 	const u8 bus_align_bytes;
 };
 
+/* device features */
+/* Unlike DP550/650, DP500 has 3 stride registers in its video layer. */
+#define MALIDP_DEVICE_LV_HAS_3_STRIDES	BIT(0)
+
 struct malidp_hw_device {
 	const struct malidp_hw_regmap map;
 	void __iomem *regs;

commit 6211b4868ea615227d61859d65e22bd2942f32a0
Author: Brian Starkey <brian.starkey@arm.com>
Date:   Mon Oct 3 15:08:12 2016 +0100

    drm: mali-dp: Rename malidp_input_format to malidp_pixel_format
    
    We're going to use the same format list for output formats, so rename
    everything related to input formats to avoid confusion.
    
    Signed-off-by: Brian Starkey <brian.starkey@arm.com>
    [touched commit title to clarify the final struct name]
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 087e1202db3d..4f8c884d1960 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -35,7 +35,7 @@ enum {
 	DE_SMART = BIT(4),
 };
 
-struct malidp_input_format {
+struct malidp_format_id {
 	u32 format;		/* DRM fourcc */
 	u8 layer;		/* bitmask of layers supporting it */
 	u8 id;			/* used internally */
@@ -85,9 +85,9 @@ struct malidp_hw_regmap {
 	const struct malidp_irq_map se_irq_map;
 	const struct malidp_irq_map dc_irq_map;
 
-	/* list of supported input formats for each layer */
-	const struct malidp_input_format *input_formats;
-	const u8 n_input_formats;
+	/* list of supported pixel formats for each layer */
+	const struct malidp_format_id *pixel_formats;
+	const u8 n_pixel_formats;
 
 	/* pitch alignment requirement in bytes */
 	const u8 bus_align_bytes;

commit a228062cb4e43e0f94bf48107338757d4d5857b9
Author: Brian Starkey <brian.starkey@arm.com>
Date:   Tue Oct 11 15:26:04 2016 +0100

    drm: mali-dp: Add pitch alignment check function
    
    Different hardware versions have different requirements when it comes to
    pitch alignment. Add a function which can be used to check pitch
    alignment for a device.
    
    Signed-off-by: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
index 141743e9f3a6..087e1202db3d 100644
--- a/drivers/gpu/drm/arm/malidp_hw.h
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -88,6 +88,9 @@ struct malidp_hw_regmap {
 	/* list of supported input formats for each layer */
 	const struct malidp_input_format *input_formats;
 	const u8 n_input_formats;
+
+	/* pitch alignment requirement in bytes */
+	const u8 bus_align_bytes;
 };
 
 struct malidp_hw_device {
@@ -229,6 +232,12 @@ void malidp_se_irq_fini(struct drm_device *drm);
 u8 malidp_hw_get_format_id(const struct malidp_hw_regmap *map,
 			   u8 layer_id, u32 format);
 
+static inline bool malidp_hw_pitch_valid(struct malidp_hw_device *hwdev,
+					 unsigned int pitch)
+{
+	return !(pitch & (hwdev->map.bus_align_bytes - 1));
+}
+
 /*
  * background color components are defined as 12bits values,
  * they will be shifted right when stored on hardware that

commit ad49f8602fe88929b185b21ccf43ff5196bbb7c3
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Mon Mar 7 10:00:53 2016 +0000

    drm/arm: Add support for Mali Display Processors
    
    Add support for the new family of Display Processors from ARM Ltd.
    This commit adds basic support for Mali DP500, DP550 and DP650
    parts, with only the display engine being supported at the moment.
    
    Cc: David Brown <David.Brown@arm.com>
    Cc: Brian Starkey <Brian.Starkey@arm.com>
    
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/arm/malidp_hw.h b/drivers/gpu/drm/arm/malidp_hw.h
new file mode 100644
index 000000000000..141743e9f3a6
--- /dev/null
+++ b/drivers/gpu/drm/arm/malidp_hw.h
@@ -0,0 +1,241 @@
+/*
+ *
+ * (C) COPYRIGHT 2013-2016 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * ARM Mali DP hardware manipulation routines.
+ */
+
+#ifndef __MALIDP_HW_H__
+#define __MALIDP_HW_H__
+
+#include <linux/bitops.h>
+#include "malidp_regs.h"
+
+struct videomode;
+struct clk;
+
+/* Mali DP IP blocks */
+enum {
+	MALIDP_DE_BLOCK = 0,
+	MALIDP_SE_BLOCK,
+	MALIDP_DC_BLOCK
+};
+
+/* Mali DP layer IDs */
+enum {
+	DE_VIDEO1 = BIT(0),
+	DE_GRAPHICS1 = BIT(1),
+	DE_GRAPHICS2 = BIT(2), /* used only in DP500 */
+	DE_VIDEO2 = BIT(3),
+	DE_SMART = BIT(4),
+};
+
+struct malidp_input_format {
+	u32 format;		/* DRM fourcc */
+	u8 layer;		/* bitmask of layers supporting it */
+	u8 id;			/* used internally */
+};
+
+#define MALIDP_INVALID_FORMAT_ID	0xff
+
+/*
+ * hide the differences between register maps
+ * by using a common structure to hold the
+ * base register offsets
+ */
+
+struct malidp_irq_map {
+	u32 irq_mask;		/* mask of IRQs that can be enabled in the block */
+	u32 vsync_irq;		/* IRQ bit used for signaling during VSYNC */
+};
+
+struct malidp_layer {
+	u16 id;			/* layer ID */
+	u16 base;		/* address offset for the register bank */
+	u16 ptr;		/* address offset for the pointer register */
+};
+
+/* regmap features */
+#define MALIDP_REGMAP_HAS_CLEARIRQ	(1 << 0)
+
+struct malidp_hw_regmap {
+	/* address offset of the DE register bank */
+	/* is always 0x0000 */
+	/* address offset of the SE registers bank */
+	const u16 se_base;
+	/* address offset of the DC registers bank */
+	const u16 dc_base;
+
+	/* address offset for the output depth register */
+	const u16 out_depth_base;
+
+	/* bitmap with register map features */
+	const u8 features;
+
+	/* list of supported layers */
+	const u8 n_layers;
+	const struct malidp_layer *layers;
+
+	const struct malidp_irq_map de_irq_map;
+	const struct malidp_irq_map se_irq_map;
+	const struct malidp_irq_map dc_irq_map;
+
+	/* list of supported input formats for each layer */
+	const struct malidp_input_format *input_formats;
+	const u8 n_input_formats;
+};
+
+struct malidp_hw_device {
+	const struct malidp_hw_regmap map;
+	void __iomem *regs;
+
+	/* APB clock */
+	struct clk *pclk;
+	/* AXI clock */
+	struct clk *aclk;
+	/* main clock for display core */
+	struct clk *mclk;
+	/* pixel clock for display core */
+	struct clk *pxlclk;
+
+	/*
+	 * Validate the driver instance against the hardware bits
+	 */
+	int (*query_hw)(struct malidp_hw_device *hwdev);
+
+	/*
+	 * Set the hardware into config mode, ready to accept mode changes
+	 */
+	void (*enter_config_mode)(struct malidp_hw_device *hwdev);
+
+	/*
+	 * Tell hardware to exit configuration mode
+	 */
+	void (*leave_config_mode)(struct malidp_hw_device *hwdev);
+
+	/*
+	 * Query if hardware is in configuration mode
+	 */
+	bool (*in_config_mode)(struct malidp_hw_device *hwdev);
+
+	/*
+	 * Set configuration valid flag for hardware parameters that can
+	 * be changed outside the configuration mode. Hardware will use
+	 * the new settings when config valid is set after the end of the
+	 * current buffer scanout
+	 */
+	void (*set_config_valid)(struct malidp_hw_device *hwdev);
+
+	/*
+	 * Set a new mode in hardware. Requires the hardware to be in
+	 * configuration mode before this function is called.
+	 */
+	void (*modeset)(struct malidp_hw_device *hwdev, struct videomode *m);
+
+	/*
+	 * Calculate the required rotation memory given the active area
+	 * and the buffer format.
+	 */
+	int (*rotmem_required)(struct malidp_hw_device *hwdev, u16 w, u16 h, u32 fmt);
+
+	u8 features;
+
+	u8 min_line_size;
+	u16 max_line_size;
+
+	/* size of memory used for rotating layers, up to two banks available */
+	u32 rotation_memory[2];
+};
+
+/* Supported variants of the hardware */
+enum {
+	MALIDP_500 = 0,
+	MALIDP_550,
+	MALIDP_650,
+	/* keep the next entry last */
+	MALIDP_MAX_DEVICES
+};
+
+extern const struct malidp_hw_device malidp_device[MALIDP_MAX_DEVICES];
+
+static inline u32 malidp_hw_read(struct malidp_hw_device *hwdev, u32 reg)
+{
+	return readl(hwdev->regs + reg);
+}
+
+static inline void malidp_hw_write(struct malidp_hw_device *hwdev,
+				   u32 value, u32 reg)
+{
+	writel(value, hwdev->regs + reg);
+}
+
+static inline void malidp_hw_setbits(struct malidp_hw_device *hwdev,
+				     u32 mask, u32 reg)
+{
+	u32 data = malidp_hw_read(hwdev, reg);
+
+	data |= mask;
+	malidp_hw_write(hwdev, data, reg);
+}
+
+static inline void malidp_hw_clearbits(struct malidp_hw_device *hwdev,
+				       u32 mask, u32 reg)
+{
+	u32 data = malidp_hw_read(hwdev, reg);
+
+	data &= ~mask;
+	malidp_hw_write(hwdev, data, reg);
+}
+
+static inline u32 malidp_get_block_base(struct malidp_hw_device *hwdev,
+					u8 block)
+{
+	switch (block) {
+	case MALIDP_SE_BLOCK:
+		return hwdev->map.se_base;
+	case MALIDP_DC_BLOCK:
+		return hwdev->map.dc_base;
+	}
+
+	return 0;
+}
+
+static inline void malidp_hw_disable_irq(struct malidp_hw_device *hwdev,
+					 u8 block, u32 irq)
+{
+	u32 base = malidp_get_block_base(hwdev, block);
+
+	malidp_hw_clearbits(hwdev, irq, base + MALIDP_REG_MASKIRQ);
+}
+
+static inline void malidp_hw_enable_irq(struct malidp_hw_device *hwdev,
+					u8 block, u32 irq)
+{
+	u32 base = malidp_get_block_base(hwdev, block);
+
+	malidp_hw_setbits(hwdev, irq, base + MALIDP_REG_MASKIRQ);
+}
+
+int malidp_de_irq_init(struct drm_device *drm, int irq);
+void malidp_de_irq_fini(struct drm_device *drm);
+int malidp_se_irq_init(struct drm_device *drm, int irq);
+void malidp_se_irq_fini(struct drm_device *drm);
+
+u8 malidp_hw_get_format_id(const struct malidp_hw_regmap *map,
+			   u8 layer_id, u32 format);
+
+/*
+ * background color components are defined as 12bits values,
+ * they will be shifted right when stored on hardware that
+ * supports only 8bits per channel
+ */
+#define MALIDP_BGND_COLOR_R		0x000
+#define MALIDP_BGND_COLOR_G		0x000
+#define MALIDP_BGND_COLOR_B		0x000
+
+#endif  /* __MALIDP_HW_H__ */
