commit c3b790ea07a13da0c46816bda6b04abef346af15
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Mar 23 15:49:25 2020 +0100

    drm: Manage drm_mode_config_init with drmm_
    
    drm_mode_config_cleanup is idempotent, so no harm in calling this
    twice. This allows us to gradually switch drivers over by removing
    explicit drm_mode_config_cleanup calls.
    
    With this step it's now also possible that (at least for simple
    drivers) automatic resource cleanup can be done correctly without a
    drm_driver->release hook. Therefore allow this now in
    devm_drm_dev_init().
    
    Also with drmm_ explicit drm_driver->release hooks are kinda not the
    best option: Drivers can always just register their current release
    hook with drmm_add_action, but even better they could split them up to
    simplify the unwinding for the driver load failure case. So deprecate
    that hook to discourage future users.
    
    v2: Fixup the example in the kerneldoc too.
    
    v3:
    - For paranoia, double check that minor->dev == dev in the release
      hook, because I botched the pointer math in the drmm library.
    - Call drm_mode_config_cleanup when drmm_add_action fails, we'd be
      missing some mutex_destroy and ida_cleanup otherwise (Laurent)
    
    v4: Add a drmm_add_action_or_reset (like devm_ has) to encapsulate this
    pattern (Noralf).
    
    v5: Fix oversight in the new drmm_add_action_or_reset macro (Noralf)
    
    v4: Review from Sam:
    - drmm_mode_config_init wrapper (also suggested by Thomas)
    - improve commit message, explain better why ->relase is deprecated
    
    v5:
    - Make drmm_ the main function, with the old one as compat wrapper
      (Sam)
    - Add FIXME comments to drm_mode_config_cleanup/init() that drivers
      shouldn't use these anymore.
    - Move drmm_add_action_or_reset helper to an earlier patch.
    
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: "Noralf Trønnes" <noralf@tronnes.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Thomas Zimmermann <tzimmermann@suse.de>
    Acked-by: Noralf Trønnes <noralf@tronnes.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200323144950.3018436-27-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index e1ec1bb7068d..5761f838a057 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -25,6 +25,7 @@
 #include <drm/drm_drv.h>
 #include <drm/drm_encoder.h>
 #include <drm/drm_file.h>
+#include <drm/drm_managed.h>
 #include <drm/drm_mode_config.h>
 #include <drm/drm_print.h>
 #include <linux/dma-resv.h>
@@ -373,8 +374,14 @@ static int drm_mode_create_standard_properties(struct drm_device *dev)
 	return 0;
 }
 
+static void drm_mode_config_init_release(struct drm_device *dev, void *ptr)
+{
+	drm_mode_config_cleanup(dev);
+}
+
 /**
- * drm_mode_config_init - initialize DRM mode_configuration structure
+ * drmm_mode_config_init - managed DRM mode_configuration structure
+ * 	initialization
  * @dev: DRM device
  *
  * Initialize @dev's mode_config structure, used for tracking the graphics
@@ -384,8 +391,12 @@ static int drm_mode_create_standard_properties(struct drm_device *dev)
  * problem, since this should happen single threaded at init time. It is the
  * driver's problem to ensure this guarantee.
  *
+ * Cleanup is automatically handled through registering drm_mode_config_cleanup
+ * with drmm_add_action().
+ *
+ * Returns: 0 on success, negative error value on failure.
  */
-void drm_mode_config_init(struct drm_device *dev)
+int drmm_mode_config_init(struct drm_device *dev)
 {
 	mutex_init(&dev->mode_config.mutex);
 	drm_modeset_lock_init(&dev->mode_config.connection_mutex);
@@ -443,8 +454,11 @@ void drm_mode_config_init(struct drm_device *dev)
 		drm_modeset_acquire_fini(&modeset_ctx);
 		dma_resv_fini(&resv);
 	}
+
+	return drmm_add_action_or_reset(dev, drm_mode_config_init_release,
+					NULL);
 }
-EXPORT_SYMBOL(drm_mode_config_init);
+EXPORT_SYMBOL(drmm_mode_config_init);
 
 /**
  * drm_mode_config_cleanup - free up DRM mode_config info
@@ -456,6 +470,9 @@ EXPORT_SYMBOL(drm_mode_config_init);
  * Note that since this /should/ happen single-threaded at driver/device
  * teardown time, no locking is required. It's the driver's job to ensure that
  * this guarantee actually holds true.
+ *
+ * FIXME: With the managed drmm_mode_config_init() it is no longer necessary for
+ * drivers to explicitly call this function.
  */
 void drm_mode_config_cleanup(struct drm_device *dev)
 {

commit b684822a44469fe44b80aef5cdca52cd979a4ecb
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Mar 18 20:25:18 2020 +0200

    drm: Skip drm_mode_config_validate() for !modeset
    
    drm_mode_config_init() may not have been called when the driver/device
    doesn't support modeset. That will cause drm_mode_config_validate()
    to oops. Skip the validation for !modeset.
    
    TODO: We may want to consider calling drm_mode_config_init()
    unconditionally to avoid similar issues elsewhere...
    
    Fixes: 74d2aacbe840 ("drm: Validate encoder->possible_clones")
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200318182518.31618-1-ville.syrjala@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 55322d7048f5..e1ec1bb7068d 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -608,6 +608,9 @@ void drm_mode_config_validate(struct drm_device *dev)
 {
 	struct drm_encoder *encoder;
 
+	if (!drm_core_check_feature(dev, DRIVER_MODESET))
+		return;
+
 	drm_for_each_encoder(encoder, dev)
 		fixup_encoder_possible_clones(encoder);
 

commit 0df10823743311f31a067c26e2a3c6fa6dc867e9
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Feb 11 18:22:07 2020 +0200

    drm: Validate encoder->possible_crtcs
    
    WARN if the encoder possible_crtcs is effectively empty or contains
    bits for non-existing crtcs.
    
    v2: Move to drm_mode_config_validate() (Daniel)
        Make the docs say we WARN when this is wrong (Daniel)
        Extract full_crtc_mask()
    
    Cc: Thomas Zimmermann <tzimmermann@suse.de>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200211162208.16224-7-ville.syrjala@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 4099a626324a..55322d7048f5 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -581,6 +581,29 @@ static void validate_encoder_possible_clones(struct drm_encoder *encoder)
 	     encoder->possible_clones, encoder_mask);
 }
 
+static u32 full_crtc_mask(struct drm_device *dev)
+{
+	struct drm_crtc *crtc;
+	u32 crtc_mask = 0;
+
+	drm_for_each_crtc(crtc, dev)
+		crtc_mask |= drm_crtc_mask(crtc);
+
+	return crtc_mask;
+}
+
+static void validate_encoder_possible_crtcs(struct drm_encoder *encoder)
+{
+	u32 crtc_mask = full_crtc_mask(encoder->dev);
+
+	WARN((encoder->possible_crtcs & crtc_mask) == 0 ||
+	     (encoder->possible_crtcs & ~crtc_mask) != 0,
+	     "Bogus possible_crtcs: "
+	     "[ENCODER:%d:%s] possible_crtcs=0x%x (full crtc mask=0x%x)\n",
+	     encoder->base.id, encoder->name,
+	     encoder->possible_crtcs, crtc_mask);
+}
+
 void drm_mode_config_validate(struct drm_device *dev)
 {
 	struct drm_encoder *encoder;
@@ -588,6 +611,8 @@ void drm_mode_config_validate(struct drm_device *dev)
 	drm_for_each_encoder(encoder, dev)
 		fixup_encoder_possible_clones(encoder);
 
-	drm_for_each_encoder(encoder, dev)
+	drm_for_each_encoder(encoder, dev) {
 		validate_encoder_possible_clones(encoder);
+		validate_encoder_possible_crtcs(encoder);
+	}
 }

commit 74d2aacbe84042d89f572a3112a146fca05bfcb1
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Feb 11 18:22:06 2020 +0200

    drm: Validate encoder->possible_clones
    
    Many drivers are populating encoder->possible_clones wrong. Let's
    persuade them to get it right by adding some loud WARNs.
    
    We'll cross check the bits between any two encoders. So either
    both encoders can clone with the other, or neither can.
    
    We'll also complain about effectively empty possible_clones, and
    possible_clones containing bits for encoders that don't exist.
    
    v2: encoder->possible_clones now includes the encoder itelf
    v3: Move to drm_mode_config_validate() (Daniel)
        Document that you get a WARN when this is wrong (Daniel)
        Extract full_encoder_mask()
    v4: !! instead of ! (Daniel)
    
    Acked-by: Thomas Zimmermann <tzimmermann@suse.de>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200211162208.16224-6-ville.syrjala@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 75e357c7e84d..4099a626324a 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -533,6 +533,17 @@ void drm_mode_config_cleanup(struct drm_device *dev)
 }
 EXPORT_SYMBOL(drm_mode_config_cleanup);
 
+static u32 full_encoder_mask(struct drm_device *dev)
+{
+	struct drm_encoder *encoder;
+	u32 encoder_mask = 0;
+
+	drm_for_each_encoder(encoder, dev)
+		encoder_mask |= drm_encoder_mask(encoder);
+
+	return encoder_mask;
+}
+
 /*
  * For some reason we want the encoder itself included in
  * possible_clones. Make life easy for drivers by allowing them
@@ -544,10 +555,39 @@ static void fixup_encoder_possible_clones(struct drm_encoder *encoder)
 		encoder->possible_clones = drm_encoder_mask(encoder);
 }
 
+static void validate_encoder_possible_clones(struct drm_encoder *encoder)
+{
+	struct drm_device *dev = encoder->dev;
+	u32 encoder_mask = full_encoder_mask(dev);
+	struct drm_encoder *other;
+
+	drm_for_each_encoder(other, dev) {
+		WARN(!!(encoder->possible_clones & drm_encoder_mask(other)) !=
+		     !!(other->possible_clones & drm_encoder_mask(encoder)),
+		     "possible_clones mismatch: "
+		     "[ENCODER:%d:%s] mask=0x%x possible_clones=0x%x vs. "
+		     "[ENCODER:%d:%s] mask=0x%x possible_clones=0x%x\n",
+		     encoder->base.id, encoder->name,
+		     drm_encoder_mask(encoder), encoder->possible_clones,
+		     other->base.id, other->name,
+		     drm_encoder_mask(other), other->possible_clones);
+	}
+
+	WARN((encoder->possible_clones & drm_encoder_mask(encoder)) == 0 ||
+	     (encoder->possible_clones & ~encoder_mask) != 0,
+	     "Bogus possible_clones: "
+	     "[ENCODER:%d:%s] possible_clones=0x%x (full encoder mask=0x%x)\n",
+	     encoder->base.id, encoder->name,
+	     encoder->possible_clones, encoder_mask);
+}
+
 void drm_mode_config_validate(struct drm_device *dev)
 {
 	struct drm_encoder *encoder;
 
 	drm_for_each_encoder(encoder, dev)
 		fixup_encoder_possible_clones(encoder);
+
+	drm_for_each_encoder(encoder, dev)
+		validate_encoder_possible_clones(encoder);
 }

commit 714277951deb9f5b22ec3789b61bb45f55c643b8
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Feb 11 18:22:02 2020 +0200

    drm: Include the encoder itself in possible_clones
    
    The docs say possible_clones should always include the encoder itself.
    Since most drivers don't want to deal with the complexities of cloning
    let's allow them to set possible_clones=0 and instead we'll fix that
    up in the core.
    
    We can't put this special case into drm_encoder_init() because drivers
    will have to fill up possible_clones after adding all the relevant
    encoders. Otherwise they wouldn't know the proper encoder indexes to
    use. So we'll just do it just before registering the device.
    
    v2: Don't set the bit if possible_clones!=0 so that the
        validation (coming soon) will WARN (Thomas)
        Fix up the docs to allow possible_clones==0 (Daniel)
        .late_register() is too late, introduce drm_mode_config_validate()
        which gets called _before_ we register the char device (Daniel)
    
    Acked-by: Thomas Zimmermann <tzimmermann@suse.de>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200211162208.16224-2-ville.syrjala@linux.intel.com
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 08e6eff6a179..75e357c7e84d 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -532,3 +532,22 @@ void drm_mode_config_cleanup(struct drm_device *dev)
 	drm_modeset_lock_fini(&dev->mode_config.connection_mutex);
 }
 EXPORT_SYMBOL(drm_mode_config_cleanup);
+
+/*
+ * For some reason we want the encoder itself included in
+ * possible_clones. Make life easy for drivers by allowing them
+ * to leave possible_clones unset if no cloning is possible.
+ */
+static void fixup_encoder_possible_clones(struct drm_encoder *encoder)
+{
+	if (encoder->possible_clones == 0)
+		encoder->possible_clones = drm_encoder_mask(encoder);
+}
+
+void drm_mode_config_validate(struct drm_device *dev)
+{
+	struct drm_encoder *encoder;
+
+	drm_for_each_encoder(encoder, dev)
+		fixup_encoder_possible_clones(encoder);
+}

commit 2c51419e8c06f6b8b1b91892688b17dd9a7f6e39
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Nov 19 22:08:42 2019 +0100

    drm/modeset: Prime modeset lock vs dma_resv
    
    It's kinda really hard to get this wrong on a driver with both display
    and dma_resv locking. But who ever knows, so better to make sure that
    really all drivers nest these the same way.
    
    For actual lock semantics the acquire context nesting doesn't matter.
    But to teach lockdep what's going on with ww_mutex the acquire ctx is
    a fake lockdep lock, hence from a lockdep pov it does matter. That's
    why I figured better to include it.
    
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Christian König <christian.koenig@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191119210844.16947-2-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 3b570a404933..08e6eff6a179 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -27,6 +27,7 @@
 #include <drm/drm_file.h>
 #include <drm/drm_mode_config.h>
 #include <drm/drm_print.h>
+#include <linux/dma-resv.h>
 
 #include "drm_crtc_internal.h"
 #include "drm_internal.h"
@@ -415,6 +416,33 @@ void drm_mode_config_init(struct drm_device *dev)
 	dev->mode_config.num_crtc = 0;
 	dev->mode_config.num_encoder = 0;
 	dev->mode_config.num_total_plane = 0;
+
+	if (IS_ENABLED(CONFIG_LOCKDEP)) {
+		struct drm_modeset_acquire_ctx modeset_ctx;
+		struct ww_acquire_ctx resv_ctx;
+		struct dma_resv resv;
+		int ret;
+
+		dma_resv_init(&resv);
+
+		drm_modeset_acquire_init(&modeset_ctx, 0);
+		ret = drm_modeset_lock(&dev->mode_config.connection_mutex,
+				       &modeset_ctx);
+		if (ret == -EDEADLK)
+			ret = drm_modeset_backoff(&modeset_ctx);
+
+		ww_acquire_init(&resv_ctx, &reservation_ww_class);
+		ret = dma_resv_lock(&resv, &resv_ctx);
+		if (ret == -EDEADLK)
+			dma_resv_lock_slow(&resv, &resv_ctx);
+
+		dma_resv_unlock(&resv);
+		ww_acquire_fini(&resv_ctx);
+
+		drm_modeset_drop_locks(&modeset_ctx);
+		drm_modeset_acquire_fini(&modeset_ctx);
+		dma_resv_fini(&resv);
+	}
 }
 EXPORT_SYMBOL(drm_mode_config_init);
 

commit b60e711a43f2425a975beacdd72fe283e0286e55
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Oct 22 18:37:17 2019 +0200

    drm/doc: Drop misleading comment on drm_mode_config_cleanup
    
    This is not something we'll fix, because failing to clean up stuff (or
    doing it in the wrong order) is a driver bug. The offending FIXME goes
    all the way back to the original modeset merge.
    
    We've added a WARN_ON in
    
    commit 2b677e8c08eed11e4ebe66a7c334f03e389a19a3
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Mon Dec 10 21:16:05 2012 +0100
    
        drm: reference framebuffers which are on the idr
    
    including a comment blaming drivers on this. Right thing to do is most
    likely drm_atomic_helper_shutdown plus making sure that
    drm_mode_config_cleanup is not called too early (i.e. not in driver
    unload, but only in the final drm_device release callback).
    
    Cc: Mihail Atanassov <Mihail.Atanassov@arm.com>
    Reported-by: Mihail Atanassov <Mihail.Atanassov@arm.com>
    Reviewed-by: Mihail Atanassov <mihail.atanassov@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191022163717.1064-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 7bc03c3c154f..3b570a404933 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -428,8 +428,6 @@ EXPORT_SYMBOL(drm_mode_config_init);
  * Note that since this /should/ happen single-threaded at driver/device
  * teardown time, no locking is required. It's the driver's job to ensure that
  * this guarantee actually holds true.
- *
- * FIXME: cleanup any dangling user buffer objects too
  */
 void drm_mode_config_cleanup(struct drm_device *dev)
 {

commit 0500c04ea14a4143edf902d087079c4e7b2f0229
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun May 26 19:35:35 2019 +0200

    drm: drop use of drmP.h in drm/*
    
    The use of the drmP.h header file is deprecated.
    Remove use from all files in drm/*
    so people do not look there and follow a bad example.
    
    Build tested allyesconfig,allmodconfig on x86, arm etc.
    Including alpha that is as always more challenging than
    the rest.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: Sean Paul <sean@poorly.run>
    Cc: David Airlie <airlied@linux.ie>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190526173535.32701-8-sam@ravnborg.org

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 1a346ae1599d..7bc03c3c154f 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -20,9 +20,13 @@
  * OF THIS SOFTWARE.
  */
 
+#include <linux/uaccess.h>
+
+#include <drm/drm_drv.h>
 #include <drm/drm_encoder.h>
+#include <drm/drm_file.h>
 #include <drm/drm_mode_config.h>
-#include <drm/drmP.h>
+#include <drm/drm_print.h>
 
 #include "drm_crtc_internal.h"
 #include "drm_internal.h"

commit c8f005684c98f4d9942baec13ad98054dbf312a0
Author: Deepak Rawat <drawat@vmware.com>
Date:   Mon Apr 15 10:28:05 2019 -0700

    drm: Expose "FB_DAMAGE_CLIPS" property to atomic aware user-space only
    
    Plane property "FB_DAMAGE_CLIPS" can only be used by atomic aware
    user-space, so no point exposing it otherwise.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Fixes: d3b21767821e ("drm: Add a new plane property to send damage during plane update")
    Link: https://patchwork.freedesktop.org/patch/msgid/20190415172814.9840-1-drawat@vmware.com

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 4a1c2023ccf0..1a346ae1599d 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -297,8 +297,9 @@ static int drm_mode_create_standard_properties(struct drm_device *dev)
 		return -ENOMEM;
 	dev->mode_config.prop_crtc_id = prop;
 
-	prop = drm_property_create(dev, DRM_MODE_PROP_BLOB, "FB_DAMAGE_CLIPS",
-				   0);
+	prop = drm_property_create(dev,
+			DRM_MODE_PROP_ATOMIC | DRM_MODE_PROP_BLOB,
+			"FB_DAMAGE_CLIPS", 0);
 	if (!prop)
 		return -ENOMEM;
 	dev->mode_config.prop_fb_damage_clips = prop;

commit 8c1a765bc62c93be2803f4541363a1c06355243e
Merge: bfeffd155283 1c95f662fcee
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jan 10 05:53:51 2019 +1000

    Merge tag 'drm-misc-next-2019-01-07-1' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 5.1:
    
    UAPI Changes:
    
    Cross-subsystem Changes:
      - Turn dma-buf fence sequence numbers into 64 bit numbers
    
    Core Changes:
      - Move to a common helper for the DP MST hotplug for radeon, i915 and
        amdgpu
      - i2c improvements for drm_dp_mst
      - Removal of drm_syncobj_cb
      - Introduction of an helper to create and attach the TV margin properties
    
    Driver Changes:
      - Improve cache flushes for v3d
      - Reflection support for vc4
      - HDMI overscan support for vc4
      - Add implicit fencing support for rockchip and sun4i
      - Switch to generic fbdev emulation for virtio
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    [airlied: applied amdgpu merge fixup]
    From: Maxime Ripard <maxime.ripard@bootlin.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190107180333.amklwycudbsub3s5@flea

commit b5f06893c4992553a12c66ca094a09fb245d280e
Author: Shayenne da Luz Moura <shayenneluzmoura@gmail.com>
Date:   Thu Dec 13 19:29:57 2018 -0200

    drm: Rename crtc_idr as object_idr to KMS cleanups
    
    This patch solves this TODO task:
     drm_mode_config.crtc_idr is misnamed, since it contains all KMS object.
     Should be renamed to drm_mode_config.object_idr.
    
    Signed-off-by: Shayenne da Luz Moura <shayenneluzmoura@gmail.com>
    [danvet: resolve conflict with addition of privobj_list.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181213212957.vkitkyl5cj2qh7qr@smtp.gmail.com

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 931523c5bc9d..037e243ec863 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -382,7 +382,7 @@ void drm_mode_config_init(struct drm_device *dev)
 	INIT_LIST_HEAD(&dev->mode_config.property_blob_list);
 	INIT_LIST_HEAD(&dev->mode_config.plane_list);
 	INIT_LIST_HEAD(&dev->mode_config.privobj_list);
-	idr_init(&dev->mode_config.crtc_idr);
+	idr_init(&dev->mode_config.object_idr);
 	idr_init(&dev->mode_config.tile_idr);
 	ida_init(&dev->mode_config.connector_ida);
 	spin_lock_init(&dev->mode_config.connector_list_lock);
@@ -485,7 +485,7 @@ void drm_mode_config_cleanup(struct drm_device *dev)
 
 	ida_destroy(&dev->mode_config.connector_ida);
 	idr_destroy(&dev->mode_config.tile_idr);
-	idr_destroy(&dev->mode_config.crtc_idr);
+	idr_destroy(&dev->mode_config.object_idr);
 	drm_modeset_lock_fini(&dev->mode_config.connection_mutex);
 }
 EXPORT_SYMBOL(drm_mode_config_cleanup);

commit b962a12050a387e4bbf3a48745afe1d29d396b0d
Author: Rob Clark <robdclark@gmail.com>
Date:   Mon Oct 22 14:31:22 2018 +0200

    drm/atomic: integrate modeset lock with private objects
    
    Follow the same pattern of locking as with other state objects. This
    avoids boilerplate in the driver.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181022123122.30468-1-boris.brezillon@bootlin.com

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index ee80788f2c40..931523c5bc9d 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -381,6 +381,7 @@ void drm_mode_config_init(struct drm_device *dev)
 	INIT_LIST_HEAD(&dev->mode_config.property_list);
 	INIT_LIST_HEAD(&dev->mode_config.property_blob_list);
 	INIT_LIST_HEAD(&dev->mode_config.plane_list);
+	INIT_LIST_HEAD(&dev->mode_config.privobj_list);
 	idr_init(&dev->mode_config.crtc_idr);
 	idr_init(&dev->mode_config.tile_idr);
 	ida_init(&dev->mode_config.connector_ida);

commit 1f9a5dce3548d54d810b23e4e0b1d8c6d73a52d4
Merge: fb878d106b77 9a01135b98b9
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Dec 6 13:43:22 2018 +1000

    Merge tag 'vmwgfx-next-2018-12-05' of git://people.freedesktop.org/~thomash/linux into drm-next
    
    Pull request of 2018-12-05
    
    Page flip with damage by Deepak and others,
    Various vmwgfx minor fixes anc cleanups.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    From: Thomas Hellstrom <thellstrom@vmware.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181205103554.3675-1-thellstrom@vmware.com

commit d3b21767821ed322a4024c99bc360cd0892f3d82
Author: Lukasz Spintzyk <lukasz.spintzyk@displaylink.com>
Date:   Wed May 23 19:04:08 2018 -0700

    drm: Add a new plane property to send damage during plane update
    
    FB_DAMAGE_CLIPS is an optional plane property to mark damaged regions
    on the plane in framebuffer coordinates of the framebuffer attached to
    the plane.
    
    The layout of blob data is simply an array of "struct drm_mode_rect".
    Unlike plane src coordinates, damage clips are not in 16.16 fixed point.
    As plane src in framebuffer cannot be negative so are damage clips. In
    damage clip, x1/y1 are inclusive and x2/y2 are exclusive.
    
    This patch also exports the kernel internal drm_rect to userspace as
    drm_mode_rect. This is because "struct drm_clip_rect" is not sufficient
    to represent damage for current plane size.
    
    Driver which are interested in enabling FB_DAMAGE_CLIPS property for a
    plane should enable this property using drm_plane_enable_damage_clips.
    
    v2:
    - Input validation on damage clips against framebuffer size.
    - Doc update, other minor changes.
    
    Signed-off-by: Lukasz Spintzyk <lukasz.spintzyk@displaylink.com>
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index ee80788f2c40..05cd5e9857e4 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -297,6 +297,12 @@ static int drm_mode_create_standard_properties(struct drm_device *dev)
 		return -ENOMEM;
 	dev->mode_config.prop_crtc_id = prop;
 
+	prop = drm_property_create(dev, DRM_MODE_PROP_BLOB, "FB_DAMAGE_CLIPS",
+				   0);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.prop_fb_damage_clips = prop;
+
 	prop = drm_property_create_bool(dev, DRM_MODE_PROP_ATOMIC,
 			"ACTIVE");
 	if (!prop)

commit 1398958cfd8d331342d657d37151791dd7256b40
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Thu Oct 4 11:46:07 2018 -0400

    drm: Add vrr_enabled property to drm CRTC
    
    This patch introduces the 'vrr_enabled' CRTC property to allow
    dynamic control over variable refresh rate support for a CRTC.
    
    This property should be treated like a content hint to the driver -
    if the hardware or driver is not capable of driving variable refresh
    timings then this is not considered an error.
    
    Capability for variable refresh rate support should be determined
    by querying the vrr_capable drm connector property.
    
    It is worth noting that while the property is intended for atomic use
    it isn't filtered from legacy userspace queries. This allows for Xorg
    userspace drivers to implement support.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index ee80788f2c40..5670c67f28d4 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -310,6 +310,12 @@ static int drm_mode_create_standard_properties(struct drm_device *dev)
 		return -ENOMEM;
 	dev->mode_config.prop_mode_id = prop;
 
+	prop = drm_property_create_bool(dev, 0,
+			"VRR_ENABLED");
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.prop_vrr_enabled = prop;
+
 	prop = drm_property_create(dev,
 			DRM_MODE_PROP_BLOB,
 			"DEGAMMA_LUT", 0);

commit 69fdf4206a8ba91a277b3d50a3a05b71247635b2
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Sep 13 20:20:50 2018 +0100

    drm: Differentiate the lack of an interface from invalid parameter
    
    If the ioctl is not supported on a particular piece of HW/driver
    combination, report ENOTSUP (aka EOPNOTSUPP) so that it can be easily
    distinguished from both the lack of the ioctl and from a regular invalid
    parameter.
    
    v2: Across all the kms ioctls we had a mixture of reporting EINVAL,
    ENODEV and a few ENOTSUPP (most where EINVAL) for a failed
    drm_core_check_feature(). Update everybody to report ENOTSUPP.
    
    v3: ENOTSUPP is an internal errno! It's value (524) does not correspond
    to a POSIX errno, the one we want is ENOTSUP. However,
    uapi/asm-generic/errno.h doesn't include ENOTSUP but man errno says
    
            "ENOTSUP and EOPNOTSUPP have the same value on Linux,
            but according to POSIX.1 these error values should be
            distinct."
    
    so use EOPNOTSUPP as its equivalent.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch> #v2
    Link: https://patchwork.freedesktop.org/patch/msgid/20180913192050.24812-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 21e353bd3948..ee80788f2c40 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -97,8 +97,7 @@ int drm_mode_getresources(struct drm_device *dev, void *data,
 	struct drm_connector_list_iter conn_iter;
 
 	if (!drm_core_check_feature(dev, DRIVER_MODESET))
-		return -EINVAL;
-
+		return -EOPNOTSUPP;
 
 	mutex_lock(&file_priv->fbs_lock);
 	count = 0;

commit d67b6a2065076d763c7df626b8c54f16038ad862
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Wed Feb 28 14:11:23 2018 +0000

    drm: writeback: Add client capability for exposing writeback connectors
    
    Due to the fact that writeback connectors behave in a special way
    in DRM (they always report being disconnected) we might confuse some
    userspace. Add a client capability for writeback connectors that will
    filter them out for clients that don't understand the capability.
    
    Changelog:
     - only accept the capability if the client has already set the
    DRM_CLIENT_CAP_ATOMIC one.
    
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Reviewed-by: Brian Starkey <brian.starkey@arm.com>
    Link: https://patchwork.freedesktop.org/patch/229038/

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index e5c653357024..21e353bd3948 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -145,6 +145,11 @@ int drm_mode_getresources(struct drm_device *dev, void *data,
 	count = 0;
 	connector_id = u64_to_user_ptr(card_res->connector_id_ptr);
 	drm_for_each_connector_iter(connector, &conn_iter) {
+		/* only expose writeback connectors if userspace understands them */
+		if (!file_priv->writeback_connectors &&
+		    (connector->connector_type == DRM_MODE_CONNECTOR_WRITEBACK))
+			continue;
+
 		if (drm_lease_held(file_priv, connector->base.id)) {
 			if (count < card_res->count_connectors &&
 			    put_user(connector->base.id, connector_id + count)) {

commit 6b7dcb536e3535444c39286333f10d06d2f44fb5
Merge: a942b3c2cddc 1291a0d5049d
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Dec 19 21:37:24 2017 +1000

    BackMerge tag 'v4.15-rc4' into drm-next
    
    Linux 4.15-rc4
    
    Daniel requested it to fix some messy conflicts.

commit ea497bb92064875497554ee7cdf10df7fb7393fc
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Dec 13 13:49:36 2017 +0100

    drm: rework delayed connector cleanup in connector_iter
    
    PROBE_DEFER also uses system_wq to reprobe drivers, which means when
    that again fails, and we try to flush the overall system_wq (to get
    all the delayed connectore cleanup work_struct completed), we
    deadlock.
    
    Fix this by using just a single cleanup work, so that we can only
    flush that one and don't block on anything else. That means a free
    list plus locking, a standard pattern.
    
    v2:
    - Correctly free connectors only on last ref. Oops (Chris).
    - use llist_head/node (Chris).
    
    v3
    - Add init_llist_head (Chris).
    
    Fixes: a703c55004e1 ("drm: safely free connectors from connector_iter")
    Fixes: 613051dac40d ("drm: locking&new iterators for connector_list")
    Cc: Ben Widawsky <ben@bwidawsk.net>
    Cc: Dave Airlie <airlied@gmail.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: <stable@vger.kernel.org> # v4.11+: 613051dac40d ("drm: locking&new iterators for connector_list"
    Cc: <stable@vger.kernel.org> # v4.11+
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Gustavo Padovan <gustavo@padovan.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Javier Martinez Canillas <javier@dowhile0.org>
    Cc: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: Guillaume Tucker <guillaume.tucker@collabora.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Matt Hart <matthew.hart@linaro.org>
    Cc: Thierry Escande <thierry.escande@collabora.co.uk>
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Cc: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171213124936.17914-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index cc78b3d9e5e4..256de7313612 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -382,6 +382,9 @@ void drm_mode_config_init(struct drm_device *dev)
 	ida_init(&dev->mode_config.connector_ida);
 	spin_lock_init(&dev->mode_config.connector_list_lock);
 
+	init_llist_head(&dev->mode_config.connector_free_list);
+	INIT_WORK(&dev->mode_config.connector_free_work, drm_connector_free_work_fn);
+
 	drm_mode_create_standard_properties(dev);
 
 	/* Just to be sure */
@@ -432,7 +435,7 @@ void drm_mode_config_cleanup(struct drm_device *dev)
 	}
 	drm_connector_list_iter_end(&conn_iter);
 	/* connector_iter drops references in a work item. */
-	flush_scheduled_work();
+	flush_work(&dev->mode_config.connector_free_work);
 	if (WARN_ON(!list_empty(&dev->mode_config.connector_list))) {
 		drm_connector_list_iter_begin(dev, &conn_iter);
 		drm_for_each_connector_iter(connector, &conn_iter)

commit 2aa0fcc2c72456a20ba958fce7669be922c6db15
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Dec 7 15:49:25 2017 +0100

    drm: More debug info for fb leaks in mode_config_cleanup
    
    We're spotting this very rarely in CI, but have no idea. Let's add
    more debug info about what's going on here.
    
    References: https://bugs.freedesktop.org/show_bug.cgi?id=102707
    Acked-by: Noralf Trønnes <noralf@tronnes.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171207144925.14191-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index cda8bfab6d3b..bc5c46306b3d 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -467,6 +467,9 @@ void drm_mode_config_cleanup(struct drm_device *dev)
 	 */
 	WARN_ON(!list_empty(&dev->mode_config.fb_list));
 	list_for_each_entry_safe(fb, fbt, &dev->mode_config.fb_list, head) {
+		struct drm_printer p = drm_debug_printer("[leaked fb]");
+		drm_printf(&p, "framebuffer[%u]:\n", fb->base.id);
+		drm_framebuffer_print_info(&p, 1, fb);
 		drm_framebuffer_free(&fb->base.refcount);
 	}
 

commit a703c55004e1c5076d57e43771b3e11117796ea0
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Dec 4 21:48:18 2017 +0100

    drm: safely free connectors from connector_iter
    
    In
    
    commit 613051dac40da1751ab269572766d3348d45a197
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Wed Dec 14 00:08:06 2016 +0100
    
        drm: locking&new iterators for connector_list
    
    we've went to extreme lengths to make sure connector iterations works
    in any context, without introducing any additional locking context.
    This worked, except for a small fumble in the implementation:
    
    When we actually race with a concurrent connector unplug event, and
    our temporary connector reference turns out to be the final one, then
    everything breaks: We call the connector release function from
    whatever context we happen to be in, which can be an irq/atomic
    context. And connector freeing grabs all kinds of locks and stuff.
    
    Fix this by creating a specially safe put function for connetor_iter,
    which (in this rare case) punts the cleanup to a worker.
    
    Reported-by: Ben Widawsky <ben@bwidawsk.net>
    Cc: Ben Widawsky <ben@bwidawsk.net>
    Fixes: 613051dac40d ("drm: locking&new iterators for connector_list")
    Cc: Dave Airlie <airlied@gmail.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: <stable@vger.kernel.org> # v4.11+
    Reviewed-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171204204818.24745-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index cda8bfab6d3b..cc78b3d9e5e4 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -431,6 +431,8 @@ void drm_mode_config_cleanup(struct drm_device *dev)
 		drm_connector_put(connector);
 	}
 	drm_connector_list_iter_end(&conn_iter);
+	/* connector_iter drops references in a work item. */
+	flush_scheduled_work();
 	if (WARN_ON(!list_empty(&dev->mode_config.connector_list))) {
 		drm_connector_list_iter_begin(dev, &conn_iter);
 		drm_for_each_connector_iter(connector, &conn_iter)

commit 7de440db20d4531e4b740bf17b56afc426c54377
Author: Keith Packard <keithp@keithp.com>
Date:   Sun Apr 9 22:35:34 2017 -0600

    drm: Check mode object lease status in all master ioctl paths [v4]
    
    Attempts to modify un-leased objects are rejected with an error.
    Information returned about unleased objects is modified to make them
    appear unusable and/or disconnected.
    
    Changes for v2 as suggested by Daniel Vetter <daniel.vetter@ffwll.ch>:
    
     * With the change in the __drm_mode_object_find API to pass the
       file_priv along, we can now centralize most of the lease-based
       access checks in that function.
    
     * A few places skip that API and require in-line checks.
    
    Changes for v3 provided by Dave Airlie <airlied@redhat.com>
    
     * remove support for leasing encoders.
     * add support for leasing planes.
    
    Changes for v4
    
     * Only call drm_lease_held if DRIVER_MODESET.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 919e78d45ab0..cda8bfab6d3b 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -122,10 +122,12 @@ int drm_mode_getresources(struct drm_device *dev, void *data,
 	count = 0;
 	crtc_id = u64_to_user_ptr(card_res->crtc_id_ptr);
 	drm_for_each_crtc(crtc, dev) {
-		if (count < card_res->count_crtcs &&
-		    put_user(crtc->base.id, crtc_id + count))
-			return -EFAULT;
-		count++;
+		if (drm_lease_held(file_priv, crtc->base.id)) {
+			if (count < card_res->count_crtcs &&
+			    put_user(crtc->base.id, crtc_id + count))
+				return -EFAULT;
+			count++;
+		}
 	}
 	card_res->count_crtcs = count;
 
@@ -143,12 +145,14 @@ int drm_mode_getresources(struct drm_device *dev, void *data,
 	count = 0;
 	connector_id = u64_to_user_ptr(card_res->connector_id_ptr);
 	drm_for_each_connector_iter(connector, &conn_iter) {
-		if (count < card_res->count_connectors &&
-		    put_user(connector->base.id, connector_id + count)) {
-			drm_connector_list_iter_end(&conn_iter);
-			return -EFAULT;
+		if (drm_lease_held(file_priv, connector->base.id)) {
+			if (count < card_res->count_connectors &&
+			    put_user(connector->base.id, connector_id + count)) {
+				drm_connector_list_iter_end(&conn_iter);
+				return -EFAULT;
+			}
+			count++;
 		}
-		count++;
 	}
 	card_res->count_connectors = count;
 	drm_connector_list_iter_end(&conn_iter);

commit 40d86701a625eed9e644281b9af228d6a52d8ed9
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Oct 13 00:52:01 2017 +0100

    drm/plane: drop num_overlay_planes (v3)
    
    In order to implement plane leasing we need to count things,
    just make the code consistent with the counting code currently
    used for counting crtcs/encoders/connectors and drop the need
    for num_overlay_planes.
    
    v2: don't forget to assign plane_ptr. (keithp)
    v3: use correct bounds check, found by igt.
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 74f6ff5df656..919e78d45ab0 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -385,7 +385,6 @@ void drm_mode_config_init(struct drm_device *dev)
 	dev->mode_config.num_connector = 0;
 	dev->mode_config.num_crtc = 0;
 	dev->mode_config.num_encoder = 0;
-	dev->mode_config.num_overlay_plane = 0;
 	dev->mode_config.num_total_plane = 0;
 }
 EXPORT_SYMBOL(drm_mode_config_init);

commit db1689aa61bd1efb5ce9b896e7aa860a85b7f1b6
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Sun Jul 23 20:46:39 2017 -0700

    drm: Create a format/modifier blob
    
    Updated blob layout (Rob, Daniel, Kristian, xerpi)
    
    v2:
    * Removed __packed, and alignment (.+)
    * Fix indent in drm_format_modifier fields (Liviu)
    * Remove duplicated modifier > 64 check (Liviu)
    * Change comment about modifier (Liviu)
    * Remove arguments to blob creation, use plane instead (Liviu)
    * Fix data types (Ben)
    * Make the blob part of uapi (Daniel)
    
    v3:
    Remove unused ret field.
    Change i, and j to unsigned int (Emil)
    
    v4:
    Use plane->modifier_count instead of recounting (Daniel)
    
    v5:
    Rename modifiers to modifiers_property (Ville)
    Use sizeof(__u32) instead to reflect UAPI nature (Ville)
    Make BUILD_BUG_ON for blob header size
    
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Kristian H. Kristensen <hoegsberg@gmail.com>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Daniel Stone <daniels@collabora.com> (v2)
    Reviewed-by: Liviu Dudau <liviu@dudau.co.uk> (v2)
    Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com> (v3)
    Signed-off-by: Daniel Stone <daniels@collabora.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170724034641.13369-2-ben@bwidawsk.net

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index d9862259a2a7..74f6ff5df656 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -337,6 +337,13 @@ static int drm_mode_create_standard_properties(struct drm_device *dev)
 		return -ENOMEM;
 	dev->mode_config.gamma_lut_size_property = prop;
 
+	prop = drm_property_create(dev,
+				   DRM_MODE_PROP_IMMUTABLE | DRM_MODE_PROP_BLOB,
+				   "IN_FORMATS", 0);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.modifiers_property = prop;
+
 	return 0;
 }
 

commit b982dab1e66d2b998e80a97acb6eaf56518988d3
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Feb 28 15:46:43 2017 +0100

    drm: Rename connector list iterator API
    
    Currently the functions that initialize and tear down a connector
    iterator use the _get() and _put() suffixes. However, these suffixes
    are typically used by reference counting functions.
    
    Make these function names a little more consistent by changing the
    suffixes to _begin() and _end(), which is a fairly common pattern in
    the rest of the Linux kernel.
    
    Suggested-by: Jani Nikula <jani.nikula@linux.intel.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170228144643.5668-8-thierry.reding@gmail.com

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 37779b9f0c1e..d9862259a2a7 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -139,19 +139,19 @@ int drm_mode_getresources(struct drm_device *dev, void *data,
 	}
 	card_res->count_encoders = count;
 
-	drm_connector_list_iter_get(dev, &conn_iter);
+	drm_connector_list_iter_begin(dev, &conn_iter);
 	count = 0;
 	connector_id = u64_to_user_ptr(card_res->connector_id_ptr);
 	drm_for_each_connector_iter(connector, &conn_iter) {
 		if (count < card_res->count_connectors &&
 		    put_user(connector->base.id, connector_id + count)) {
-			drm_connector_list_iter_put(&conn_iter);
+			drm_connector_list_iter_end(&conn_iter);
 			return -EFAULT;
 		}
 		count++;
 	}
 	card_res->count_connectors = count;
-	drm_connector_list_iter_put(&conn_iter);
+	drm_connector_list_iter_end(&conn_iter);
 
 	return ret;
 }
@@ -184,11 +184,11 @@ void drm_mode_config_reset(struct drm_device *dev)
 		if (encoder->funcs->reset)
 			encoder->funcs->reset(encoder);
 
-	drm_connector_list_iter_get(dev, &conn_iter);
+	drm_connector_list_iter_begin(dev, &conn_iter);
 	drm_for_each_connector_iter(connector, &conn_iter)
 		if (connector->funcs->reset)
 			connector->funcs->reset(connector);
-	drm_connector_list_iter_put(&conn_iter);
+	drm_connector_list_iter_end(&conn_iter);
 }
 EXPORT_SYMBOL(drm_mode_config_reset);
 
@@ -412,7 +412,7 @@ void drm_mode_config_cleanup(struct drm_device *dev)
 		encoder->funcs->destroy(encoder);
 	}
 
-	drm_connector_list_iter_get(dev, &conn_iter);
+	drm_connector_list_iter_begin(dev, &conn_iter);
 	drm_for_each_connector_iter(connector, &conn_iter) {
 		/* drm_connector_list_iter holds an full reference to the
 		 * current connector itself, which means it is inherently safe
@@ -420,12 +420,12 @@ void drm_mode_config_cleanup(struct drm_device *dev)
 		 * deleting it right away. */
 		drm_connector_put(connector);
 	}
-	drm_connector_list_iter_put(&conn_iter);
+	drm_connector_list_iter_end(&conn_iter);
 	if (WARN_ON(!list_empty(&dev->mode_config.connector_list))) {
-		drm_connector_list_iter_get(dev, &conn_iter);
+		drm_connector_list_iter_begin(dev, &conn_iter);
 		drm_for_each_connector_iter(connector, &conn_iter)
 			DRM_ERROR("connector %s leaked!\n", connector->name);
-		drm_connector_list_iter_put(&conn_iter);
+		drm_connector_list_iter_end(&conn_iter);
 	}
 
 	list_for_each_entry_safe(property, pt, &dev->mode_config.property_list,

commit 6472e5090be7c78749a3c279b4faae87ab835c40
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Feb 28 15:46:42 2017 +0100

    drm: Introduce drm_property_blob_{get,put}()
    
    For consistency with other reference counting APIs in the kernel, add
    drm_property_blob_get() and drm_property_blob_put() to reference count
    DRM blob properties.
    
    Compatibility aliases are added to keep existing code working. To help
    speed up the transition, all the instances of the old functions in the
    DRM core are already replaced in this commit.
    
    A semantic patch is provided that can be used to convert all drivers to
    the new helpers.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170228144643.5668-7-thierry.reding@gmail.com

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 20aec165abd7..37779b9f0c1e 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -444,7 +444,7 @@ void drm_mode_config_cleanup(struct drm_device *dev)
 
 	list_for_each_entry_safe(blob, bt, &dev->mode_config.property_blob_list,
 				 head_global) {
-		drm_property_unreference_blob(blob);
+		drm_property_blob_put(blob);
 	}
 
 	/*

commit ad09360750afa18a0a0ce0253d6ea6033abc22e7
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Feb 28 15:46:39 2017 +0100

    drm: Introduce drm_connector_{get,put}()
    
    For consistency with other reference counting APIs in the kernel, add
    drm_connector_get() and drm_connector_put() functions to reference count
    connectors.
    
    Compatibility aliases are added to keep existing code working. To help
    speed up the transition, all the instances of the old functions in the
    DRM core are already replaced in this commit.
    
    The existing semantic patch for mode object reference count conversion
    is extended for these new helpers.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170228144643.5668-4-thierry.reding@gmail.com

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 884cc4d26fb5..20aec165abd7 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -418,7 +418,7 @@ void drm_mode_config_cleanup(struct drm_device *dev)
 		 * current connector itself, which means it is inherently safe
 		 * against unreferencing the current connector - but not against
 		 * deleting it right away. */
-		drm_connector_unreference(connector);
+		drm_connector_put(connector);
 	}
 	drm_connector_list_iter_put(&conn_iter);
 	if (WARN_ON(!list_empty(&dev->mode_config.connector_list))) {

commit d352f352a377750e5b555e3b6329e0db7a6e8aea
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jan 19 09:05:13 2017 +0000

    drm: Show leaked connectors upon unload
    
    After warning that the connector list is not empty on device
    unregistration (i.e. module unload) also print out which connectors are
    still hanging around to aide finding the leak.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170119090513.4154-1-chris@chris-wilson.co.uk

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index ed1ee5a44a7b..884cc4d26fb5 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -421,7 +421,12 @@ void drm_mode_config_cleanup(struct drm_device *dev)
 		drm_connector_unreference(connector);
 	}
 	drm_connector_list_iter_put(&conn_iter);
-	WARN_ON(!list_empty(&dev->mode_config.connector_list));
+	if (WARN_ON(!list_empty(&dev->mode_config.connector_list))) {
+		drm_connector_list_iter_get(dev, &conn_iter);
+		drm_for_each_connector_iter(connector, &conn_iter)
+			DRM_ERROR("connector %s leaked!\n", connector->name);
+		drm_connector_list_iter_put(&conn_iter);
+	}
 
 	list_for_each_entry_safe(property, pt, &dev->mode_config.property_list,
 				 head) {

commit 2ab8c5f8c0358010a19e82656fa4826a6a51d1e0
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Dec 14 00:08:08 2016 +0100

    drm: Clean up connectors by unreferencing them
    
    Only static connectors should be left at this point, and we should be
    able to clean them out by simply dropping that last reference still
    around from drm_connector_init.
    
    If that leaves anything behind then we have a driver bug.
    
    Doing the final cleanup this way also allows us to use
    drm_connector_iter, removing the very last place where we walk
    connector_list explicitly in drm core&helpers.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161213230814.19598-8-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 649f1da3596f..ed1ee5a44a7b 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -398,7 +398,8 @@ EXPORT_SYMBOL(drm_mode_config_init);
  */
 void drm_mode_config_cleanup(struct drm_device *dev)
 {
-	struct drm_connector *connector, *ot;
+	struct drm_connector *connector;
+	struct drm_connector_list_iter conn_iter;
 	struct drm_crtc *crtc, *ct;
 	struct drm_encoder *encoder, *enct;
 	struct drm_framebuffer *fb, *fbt;
@@ -411,10 +412,16 @@ void drm_mode_config_cleanup(struct drm_device *dev)
 		encoder->funcs->destroy(encoder);
 	}
 
-	list_for_each_entry_safe(connector, ot,
-				 &dev->mode_config.connector_list, head) {
-		connector->funcs->destroy(connector);
+	drm_connector_list_iter_get(dev, &conn_iter);
+	drm_for_each_connector_iter(connector, &conn_iter) {
+		/* drm_connector_list_iter holds an full reference to the
+		 * current connector itself, which means it is inherently safe
+		 * against unreferencing the current connector - but not against
+		 * deleting it right away. */
+		drm_connector_unreference(connector);
 	}
+	drm_connector_list_iter_put(&conn_iter);
+	WARN_ON(!list_empty(&dev->mode_config.connector_list));
 
 	list_for_each_entry_safe(property, pt, &dev->mode_config.property_list,
 				 head) {

commit 613051dac40da1751ab269572766d3348d45a197
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Dec 14 00:08:06 2016 +0100

    drm: locking&new iterators for connector_list
    
    The requirements for connector_list locking are a bit tricky:
    - We need to be able to jump over zombie conectors (i.e. with refcount
      == 0, but not yet removed from the list). If instead we require that
      there's no zombies on the list then the final kref_put must happen
      under the list protection lock, which means that locking context
      leaks all over the place. Not pretty - better to deal with zombies
      and wrap the locking just around the list_del in the destructor.
    
    - When we walk the list we must _not_ hold the connector list lock. We
      walk the connector list at an absolutely massive amounts of places,
      if all those places can't ever call drm_connector_unreference the
      code would get unecessarily complicated.
    
    - connector_list needs it own lock, again too many places that walk it
      that we could reuse e.g. mode_config.mutex without resulting in
      inversions.
    
    - Lots of code uses these loops to look-up a connector, i.e. they want
      to be able to call drm_connector_reference. But on the other hand we
      want connectors to stay on that list until they're dead (i.e.
      connector_list can't hold a full reference), which means despite the
      "can't hold lock for the loop body" rule we need to make sure a
      connector doesn't suddenly become a zombie.
    
    At first Dave&I discussed various horror-show approaches using srcu,
    but turns out it's fairly easy:
    
    - For the loop body we always hold an additional reference to the
      current connector. That means it can't zombify, and it also means
      it'll stay on the list, which means we can use it as our iterator to
      find the next connector.
    
    - When we try to find the next connector we only have to jump over
      zombies. To make sure we don't chase bad pointers that entire loop
      is protected with the new connect_list_lock spinlock. And because we
      know that we're starting out with a non-zombie (need to drop our
      reference for the old connector only after we have our new one),
      we're guranteed to still be on the connector_list and either find
      the next non-zombie or complete the iteration.
    
    - Only downside is that we need to make sure that the temporary
      reference for the loop body doesn't leak. iter_get/put() functions +
      lockdep make sure that's the case.
    
    - To avoid a flag day the new iterator macro has an _iter postfix. We
      can rename it back once all the users of the unsafe version are gone
      (there's about 100 list walkers for the connector_list).
    
    For now this patch only converts all the list walking in the core,
    leaving helpers and drivers for later patches. The nice thing is that
    we can now finally remove 2 FIXME comments from the
    register/unregister functions.
    
    v2:
    - use irqsafe spinlocks, so that we can use this in drm_state_dump
      too.
    - nuke drm_modeset_lock_all from drm_connector_init, now entirely
      cargo-culted nonsense.
    
    v3:
    - do {} while (!kref_get_unless_zero), makes for a tidier loop (Dave).
    - pretty kerneldoc
    - add EXPORT_SYMBOL, helpers&drivers are supposed to use this.
    
    v4: Change lockdep annotations to only check whether we release the
    iter fake lock again (i.e. make sure that iter_put is called), but
    not check any locking dependecies itself. That seams to require a
    recursive read lock in trylock mode.
    
    Cc: Dave Airlie <airlied@gmail.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161213230814.19598-6-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index a9a40dc629d3..649f1da3596f 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -94,6 +94,7 @@ int drm_mode_getresources(struct drm_device *dev, void *data,
 	uint32_t __user *crtc_id;
 	uint32_t __user *connector_id;
 	uint32_t __user *encoder_id;
+	struct drm_connector_list_iter conn_iter;
 
 	if (!drm_core_check_feature(dev, DRIVER_MODESET))
 		return -EINVAL;
@@ -113,9 +114,6 @@ int drm_mode_getresources(struct drm_device *dev, void *data,
 	card_res->count_fbs = count;
 	mutex_unlock(&file_priv->fbs_lock);
 
-	/* mode_config.mutex protects the connector list against e.g. DP MST
-	 * connector hot-adding. CRTC/Plane lists are invariant. */
-	mutex_lock(&dev->mode_config.mutex);
 	card_res->max_height = dev->mode_config.max_height;
 	card_res->min_height = dev->mode_config.min_height;
 	card_res->max_width = dev->mode_config.max_width;
@@ -125,10 +123,8 @@ int drm_mode_getresources(struct drm_device *dev, void *data,
 	crtc_id = u64_to_user_ptr(card_res->crtc_id_ptr);
 	drm_for_each_crtc(crtc, dev) {
 		if (count < card_res->count_crtcs &&
-		    put_user(crtc->base.id, crtc_id + count)) {
-			ret = -EFAULT;
-			goto out;
-		}
+		    put_user(crtc->base.id, crtc_id + count))
+			return -EFAULT;
 		count++;
 	}
 	card_res->count_crtcs = count;
@@ -137,28 +133,26 @@ int drm_mode_getresources(struct drm_device *dev, void *data,
 	encoder_id = u64_to_user_ptr(card_res->encoder_id_ptr);
 	drm_for_each_encoder(encoder, dev) {
 		if (count < card_res->count_encoders &&
-		    put_user(encoder->base.id, encoder_id + count)) {
-			ret = -EFAULT;
-			goto out;
-		}
+		    put_user(encoder->base.id, encoder_id + count))
+			return -EFAULT;
 		count++;
 	}
 	card_res->count_encoders = count;
 
+	drm_connector_list_iter_get(dev, &conn_iter);
 	count = 0;
 	connector_id = u64_to_user_ptr(card_res->connector_id_ptr);
-	drm_for_each_connector(connector, dev) {
+	drm_for_each_connector_iter(connector, &conn_iter) {
 		if (count < card_res->count_connectors &&
 		    put_user(connector->base.id, connector_id + count)) {
-			ret = -EFAULT;
-			goto out;
+			drm_connector_list_iter_put(&conn_iter);
+			return -EFAULT;
 		}
 		count++;
 	}
 	card_res->count_connectors = count;
+	drm_connector_list_iter_put(&conn_iter);
 
-out:
-	mutex_unlock(&dev->mode_config.mutex);
 	return ret;
 }
 
@@ -176,6 +170,7 @@ void drm_mode_config_reset(struct drm_device *dev)
 	struct drm_plane *plane;
 	struct drm_encoder *encoder;
 	struct drm_connector *connector;
+	struct drm_connector_list_iter conn_iter;
 
 	drm_for_each_plane(plane, dev)
 		if (plane->funcs->reset)
@@ -189,11 +184,11 @@ void drm_mode_config_reset(struct drm_device *dev)
 		if (encoder->funcs->reset)
 			encoder->funcs->reset(encoder);
 
-	mutex_lock(&dev->mode_config.mutex);
-	drm_for_each_connector(connector, dev)
+	drm_connector_list_iter_get(dev, &conn_iter);
+	drm_for_each_connector_iter(connector, &conn_iter)
 		if (connector->funcs->reset)
 			connector->funcs->reset(connector);
-	mutex_unlock(&dev->mode_config.mutex);
+	drm_connector_list_iter_put(&conn_iter);
 }
 EXPORT_SYMBOL(drm_mode_config_reset);
 
@@ -374,6 +369,7 @@ void drm_mode_config_init(struct drm_device *dev)
 	idr_init(&dev->mode_config.crtc_idr);
 	idr_init(&dev->mode_config.tile_idr);
 	ida_init(&dev->mode_config.connector_ida);
+	spin_lock_init(&dev->mode_config.connector_list_lock);
 
 	drm_mode_create_standard_properties(dev);
 

commit 15092c7a3cddb495649363a403f242edd2aaa6a5
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Dec 14 00:08:05 2016 +0100

    drm: Drop locking cargo-cult from drm_mode_config_init
    
    This is single-threaded setup code, no need for locks. And anyway,
    all properties need to be set up before the driver is registered
    anyway, they can't be hot-added.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Daniel Stone <daniels@collabora.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161213230814.19598-5-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 5aba075f112c..a9a40dc629d3 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -375,9 +375,7 @@ void drm_mode_config_init(struct drm_device *dev)
 	idr_init(&dev->mode_config.tile_idr);
 	ida_init(&dev->mode_config.connector_ida);
 
-	drm_modeset_lock_all(dev);
 	drm_mode_create_standard_properties(dev);
-	drm_modeset_unlock_all(dev);
 
 	/* Just to be sure */
 	dev->mode_config.num_fb = 0;

commit 9338203c4f03ffe323b67f0b2fa17b9811fa9bb6
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Nov 28 20:51:09 2016 +0200

    drm: Don't include <drm/drm_encoder.h> in <drm/drm_crtc.h>
    
    <drm/drm_crtc.h> used to define most of the in-kernel KMS API. It has
    now been split into separate files for each object type, but still
    includes most other KMS headers to avoid breaking driver compilation.
    
    As a step towards fixing that problem, remove the inclusion of
    <drm/drm_encoder.h> from <drm/drm_crtc.h> and include it instead where
    appropriate. Also remove the forward declarations of the drm_encoder and
    drm_encoder_helper_funcs structures from <drm/drm_crtc.h> as they're not
    needed in the header.
    
    <drm/drm_encoder.h> now has to include <drm/drm_mode.h> and contain a
    forward declaration of struct drm_encoder in order to allow including it
    as the first header in a compilation unit.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com> # For vmwgfx
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481709550-29226-2-git-send-email-laurent.pinchart+renesas@ideasonboard.com

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index b1e8bbceaf39..5aba075f112c 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -20,6 +20,7 @@
  * OF THIS SOFTWARE.
  */
 
+#include <drm/drm_encoder.h>
 #include <drm/drm_mode_config.h>
 #include <drm/drmP.h>
 

commit 697cc9c8a2c39a42188840e35e212230a240f9e4
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sun Dec 11 20:20:19 2016 +0100

    drm: Simplify GETRESOURCES ioctl
    
    Looping twice when we can do it once is silly. Also use a consistent
    style. Note that there's a good race with the connector list walking,
    since that is no longer protected by mode_config.mutex. But that's for
    a later patch to fix.
    
    v2: Actually try to not blow up, somehow I lost the hunk that checks
    we don't copy too much. Noticed by Chris.
    
    v3:
    - squash all drm_mode_getresources cleanups into one
    - use consistent style for walking objects (Chris)
    
    v4:
    - Use u64_to_user_ptr (Chris)
    - Don't forget to copy the last connector (Chris)
    
    v5: Chris was right ...
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161211192019.29603-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 2735a5847ffa..b1e8bbceaf39 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -84,17 +84,11 @@ int drm_mode_getresources(struct drm_device *dev, void *data,
 			  struct drm_file *file_priv)
 {
 	struct drm_mode_card_res *card_res = data;
-	struct list_head *lh;
 	struct drm_framebuffer *fb;
 	struct drm_connector *connector;
 	struct drm_crtc *crtc;
 	struct drm_encoder *encoder;
-	int ret = 0;
-	int connector_count = 0;
-	int crtc_count = 0;
-	int fb_count = 0;
-	int encoder_count = 0;
-	int copied = 0;
+	int count, ret = 0;
 	uint32_t __user *fb_id;
 	uint32_t __user *crtc_id;
 	uint32_t __user *connector_id;
@@ -105,89 +99,62 @@ int drm_mode_getresources(struct drm_device *dev, void *data,
 
 
 	mutex_lock(&file_priv->fbs_lock);
-	/*
-	 * For the non-control nodes we need to limit the list of resources
-	 * by IDs in the group list for this node
-	 */
-	list_for_each(lh, &file_priv->fbs)
-		fb_count++;
-
-	/* handle this in 4 parts */
-	/* FBs */
-	if (card_res->count_fbs >= fb_count) {
-		copied = 0;
-		fb_id = (uint32_t __user *)(unsigned long)card_res->fb_id_ptr;
-		list_for_each_entry(fb, &file_priv->fbs, filp_head) {
-			if (put_user(fb->base.id, fb_id + copied)) {
-				mutex_unlock(&file_priv->fbs_lock);
-				return -EFAULT;
-			}
-			copied++;
+	count = 0;
+	fb_id = u64_to_user_ptr(card_res->fb_id_ptr);
+	list_for_each_entry(fb, &file_priv->fbs, filp_head) {
+		if (count < card_res->count_fbs &&
+		    put_user(fb->base.id, fb_id + count)) {
+			mutex_unlock(&file_priv->fbs_lock);
+			return -EFAULT;
 		}
+		count++;
 	}
-	card_res->count_fbs = fb_count;
+	card_res->count_fbs = count;
 	mutex_unlock(&file_priv->fbs_lock);
 
 	/* mode_config.mutex protects the connector list against e.g. DP MST
 	 * connector hot-adding. CRTC/Plane lists are invariant. */
 	mutex_lock(&dev->mode_config.mutex);
-	drm_for_each_crtc(crtc, dev)
-		crtc_count++;
-
-	drm_for_each_connector(connector, dev)
-		connector_count++;
-
-	drm_for_each_encoder(encoder, dev)
-		encoder_count++;
-
 	card_res->max_height = dev->mode_config.max_height;
 	card_res->min_height = dev->mode_config.min_height;
 	card_res->max_width = dev->mode_config.max_width;
 	card_res->min_width = dev->mode_config.min_width;
 
-	/* CRTCs */
-	if (card_res->count_crtcs >= crtc_count) {
-		copied = 0;
-		crtc_id = (uint32_t __user *)(unsigned long)card_res->crtc_id_ptr;
-		drm_for_each_crtc(crtc, dev) {
-			if (put_user(crtc->base.id, crtc_id + copied)) {
-				ret = -EFAULT;
-				goto out;
-			}
-			copied++;
+	count = 0;
+	crtc_id = u64_to_user_ptr(card_res->crtc_id_ptr);
+	drm_for_each_crtc(crtc, dev) {
+		if (count < card_res->count_crtcs &&
+		    put_user(crtc->base.id, crtc_id + count)) {
+			ret = -EFAULT;
+			goto out;
 		}
+		count++;
 	}
-	card_res->count_crtcs = crtc_count;
-
-	/* Encoders */
-	if (card_res->count_encoders >= encoder_count) {
-		copied = 0;
-		encoder_id = (uint32_t __user *)(unsigned long)card_res->encoder_id_ptr;
-		drm_for_each_encoder(encoder, dev) {
-			if (put_user(encoder->base.id, encoder_id +
-				     copied)) {
-				ret = -EFAULT;
-				goto out;
-			}
-			copied++;
+	card_res->count_crtcs = count;
+
+	count = 0;
+	encoder_id = u64_to_user_ptr(card_res->encoder_id_ptr);
+	drm_for_each_encoder(encoder, dev) {
+		if (count < card_res->count_encoders &&
+		    put_user(encoder->base.id, encoder_id + count)) {
+			ret = -EFAULT;
+			goto out;
 		}
+		count++;
 	}
-	card_res->count_encoders = encoder_count;
-
-	/* Connectors */
-	if (card_res->count_connectors >= connector_count) {
-		copied = 0;
-		connector_id = (uint32_t __user *)(unsigned long)card_res->connector_id_ptr;
-		drm_for_each_connector(connector, dev) {
-			if (put_user(connector->base.id,
-				     connector_id + copied)) {
-				ret = -EFAULT;
-				goto out;
-			}
-			copied++;
+	card_res->count_encoders = count;
+
+	count = 0;
+	connector_id = u64_to_user_ptr(card_res->connector_id_ptr);
+	drm_for_each_connector(connector, dev) {
+		if (count < card_res->count_connectors &&
+		    put_user(connector->base.id, connector_id + count)) {
+			ret = -EFAULT;
+			goto out;
 		}
+		count++;
 	}
-	card_res->count_connectors = connector_count;
+	card_res->count_connectors = count;
 
 out:
 	mutex_unlock(&dev->mode_config.mutex);

commit beaf5af48034c9e2ebb8b2b1fb12dc4d8aeba99e
Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date:   Wed Nov 16 22:00:21 2016 +0900

    drm/fence: add out-fences support
    
    Support DRM out-fences by creating a sync_file with a fence for each CRTC
    that sets the OUT_FENCE_PTR property.
    
    We use the out_fence pointer received in the OUT_FENCE_PTR prop to send
    the sync_file fd back to userspace.
    
    The sync_file and fd are allocated/created before commit, but the
    fd_install operation only happens after we know that commit succeed.
    
    v2: Comment by Rob Clark:
            - Squash commit that adds DRM_MODE_ATOMIC_OUT_FENCE flag here.
    
        Comment by Daniel Vetter:
            - Add clean up code for out_fences
    
    v3: Comments by Daniel Vetter:
            - create DRM_MODE_ATOMIC_EVENT_MASK
            - userspace should fill out_fences_ptr with the crtc_ids for which
            it wants fences back.
    
    v4: Create OUT_FENCE_PTR properties and remove old approach.
    
    v5: Comments by Brian Starkey:
            - Remove extra fence_get() in atomic_ioctl()
            - Check ret before iterating on the crtc_state
            - check ret before fd_install
            - set fence_state to NULL at the beginning
            - check fence_state->out_fence_ptr before put_user()
            - change order of fput() and put_unused_fd() on failure
    
         - Add access_ok() check to the out_fence_ptr received
         - Rebase after fence -> dma_fence rename
         - Store out_fence_ptr in the drm_atomic_state
         - Split crtc_setup_out_fence()
         - return -1 as out_fence with TEST_ONLY flag
    
    v6: Comments by Daniel Vetter
            - Add prepare/unprepare_crtc_signaling()
            - move struct drm_out_fence_state to drm_atomic.c
            - mark get_crtc_fence() as static
    
        Comments by Brian Starkey
            - proper set fence_ptr fence_state array
            - isolate fence_idx increment
    
        - improve error handling
    
    v7: Comments by Daniel Vetter
            - remove prefix from internal functions
            - make out_fence_ptr an s64 pointer
            - degrade DRM_INFO to DRM_DEBUG_ATOMIC when put_user fail
            - fix doc issues
            - filter out OUT_FENCE_PTR == NULL and do not fail in this case
            - add complete_crtc_signalling()
            - krealloc fence_state on demand
    
        Comment by Brian Starkey
            - remove unused crtc_state arg from get_out_fence()
    
    v8: Comment by Brian Starkey
            - cancel events before check for !fence_state
            - convert a few lefovers u64 types for out_fence_ptr
            - fix memleak by assign fence_state earlier after realloc
            - proper accout num_fences in case of error
    
    v9: Comment by Brian Starkey
            - memset last position of fence_state after krealloc
        Comments by Sean Paul
            - pass install_fds in complete_crtc_signaling() instead of ret
    
         - put_user(-1, fence_ptr) when decoding props
    
    v10: Comment by Brian Starkey
            - remove unneeded num_fences increment on error path
            - kfree fence_state after installing fences fd
    
    v11: rebase against latest drm-misc
    
    v12: rebase again against latest drm-misc
    
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Reviewed-by: Brian Starkey <brian.starkey@arm.com> (v10)
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Tested-by: Robert Foss <robert.foss@collabora.com> (v10)
    [danvet: Appease checkpatch.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1479301221-13056-1-git-send-email-gustavo@padovan.org

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 8bee2addf7b4..2735a5847ffa 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -314,6 +314,12 @@ static int drm_mode_create_standard_properties(struct drm_device *dev)
 		return -ENOMEM;
 	dev->mode_config.prop_in_fence_fd = prop;
 
+	prop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,
+			"OUT_FENCE_PTR", 0, U64_MAX);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.prop_out_fence_ptr = prop;
+
 	prop = drm_property_create_object(dev, DRM_MODE_PROP_ATOMIC,
 			"CRTC_ID", DRM_MODE_OBJECT_CRTC);
 	if (!prop)

commit 9626014258a5957ff120b3987ee72decdbe0c798
Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date:   Tue Nov 15 22:06:39 2016 +0900

    drm/fence: add in-fences support
    
    There is now a new property called IN_FENCE_FD attached to every plane
    state that receives sync_file fds from userspace via the atomic commit
    IOCTL.
    
    The fd is then translated to a fence (that may be a fence_array
    subclass or just a normal fence) and then used by DRM to fence_wait() for
    all fences in the sync_file to signal. So it only commits when all
    framebuffers are ready to scanout.
    
    v2: Comments by Daniel Vetter:
            - remove set state->fence = NULL in destroy phase
            - accept fence -1 as valid and just return 0
            - do not call fence_get() - sync_file_fences_get() already calls it
            - fence_put() if state->fence is already set, in case userspace
            set the property more than once.
    
    v3: WARN_ON if fence is set but state has no FB
    
    v4: Comment from Maarten Lankhorst
            - allow set fence with no related fb
    
    v5: rename FENCE_FD to IN_FENCE_FD
    
    v6: Comments by Daniel Vetter:
            - rename plane_state->in_fence back to "fence"
            - re-introduce WARN_ON if fence set but no fb
    
         - rebase after fence -> dma_fence rename
    
    v7: Comments by Brian Starkey
            - set state->fence to NULL when duplicating the state
            - fail if IN_FENCE_FD was already set
    
    v8: rebase against latest drm-misc
    
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Reviewed-by: Brian Starkey <brian.starkey@arm.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Tested-by: Robert Foss <robert.foss@collabora.com>
    [danvet: Rebase onto extracted drm_mode_config.[hc].]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
index 6f80886ed40b..8bee2addf7b4 100644
--- a/drivers/gpu/drm/drm_mode_config.c
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -308,6 +308,12 @@ static int drm_mode_create_standard_properties(struct drm_device *dev)
 		return -ENOMEM;
 	dev->mode_config.prop_fb_id = prop;
 
+	prop = drm_property_create_signed_range(dev, DRM_MODE_PROP_ATOMIC,
+			"IN_FENCE_FD", -1, INT_MAX);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.prop_in_fence_fd = prop;
+
 	prop = drm_property_create_object(dev, DRM_MODE_PROP_ATOMIC,
 			"CRTC_ID", DRM_MODE_OBJECT_CRTC);
 	if (!prop)

commit 28575f165d36051310d7ea2350e2011f8095b6fb
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Nov 14 12:58:23 2016 +0100

    drm: Extract drm_mode_config.[hc]
    
    And shuffle the kernel-doc structure a bit since drm_crtc.[hc] now
    only contains CRTC-related functions and structures.
    
    v2:
    - rebase onto drm-misc
    - don't forget to move drm_mode_config_cleanup.
    - move 2 internal decls under the right heading (Chris)
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/drivers/gpu/drm/drm_mode_config.c b/drivers/gpu/drm/drm_mode_config.c
new file mode 100644
index 000000000000..6f80886ed40b
--- /dev/null
+++ b/drivers/gpu/drm/drm_mode_config.c
@@ -0,0 +1,482 @@
+/*
+ * Copyright (c) 2016 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include <drm/drm_mode_config.h>
+#include <drm/drmP.h>
+
+#include "drm_crtc_internal.h"
+#include "drm_internal.h"
+
+int drm_modeset_register_all(struct drm_device *dev)
+{
+	int ret;
+
+	ret = drm_plane_register_all(dev);
+	if (ret)
+		goto err_plane;
+
+	ret = drm_crtc_register_all(dev);
+	if  (ret)
+		goto err_crtc;
+
+	ret = drm_encoder_register_all(dev);
+	if (ret)
+		goto err_encoder;
+
+	ret = drm_connector_register_all(dev);
+	if (ret)
+		goto err_connector;
+
+	return 0;
+
+err_connector:
+	drm_encoder_unregister_all(dev);
+err_encoder:
+	drm_crtc_unregister_all(dev);
+err_crtc:
+	drm_plane_unregister_all(dev);
+err_plane:
+	return ret;
+}
+
+void drm_modeset_unregister_all(struct drm_device *dev)
+{
+	drm_connector_unregister_all(dev);
+	drm_encoder_unregister_all(dev);
+	drm_crtc_unregister_all(dev);
+	drm_plane_unregister_all(dev);
+}
+
+/**
+ * drm_mode_getresources - get graphics configuration
+ * @dev: drm device for the ioctl
+ * @data: data pointer for the ioctl
+ * @file_priv: drm file for the ioctl call
+ *
+ * Construct a set of configuration description structures and return
+ * them to the user, including CRTC, connector and framebuffer configuration.
+ *
+ * Called by the user via ioctl.
+ *
+ * Returns:
+ * Zero on success, negative errno on failure.
+ */
+int drm_mode_getresources(struct drm_device *dev, void *data,
+			  struct drm_file *file_priv)
+{
+	struct drm_mode_card_res *card_res = data;
+	struct list_head *lh;
+	struct drm_framebuffer *fb;
+	struct drm_connector *connector;
+	struct drm_crtc *crtc;
+	struct drm_encoder *encoder;
+	int ret = 0;
+	int connector_count = 0;
+	int crtc_count = 0;
+	int fb_count = 0;
+	int encoder_count = 0;
+	int copied = 0;
+	uint32_t __user *fb_id;
+	uint32_t __user *crtc_id;
+	uint32_t __user *connector_id;
+	uint32_t __user *encoder_id;
+
+	if (!drm_core_check_feature(dev, DRIVER_MODESET))
+		return -EINVAL;
+
+
+	mutex_lock(&file_priv->fbs_lock);
+	/*
+	 * For the non-control nodes we need to limit the list of resources
+	 * by IDs in the group list for this node
+	 */
+	list_for_each(lh, &file_priv->fbs)
+		fb_count++;
+
+	/* handle this in 4 parts */
+	/* FBs */
+	if (card_res->count_fbs >= fb_count) {
+		copied = 0;
+		fb_id = (uint32_t __user *)(unsigned long)card_res->fb_id_ptr;
+		list_for_each_entry(fb, &file_priv->fbs, filp_head) {
+			if (put_user(fb->base.id, fb_id + copied)) {
+				mutex_unlock(&file_priv->fbs_lock);
+				return -EFAULT;
+			}
+			copied++;
+		}
+	}
+	card_res->count_fbs = fb_count;
+	mutex_unlock(&file_priv->fbs_lock);
+
+	/* mode_config.mutex protects the connector list against e.g. DP MST
+	 * connector hot-adding. CRTC/Plane lists are invariant. */
+	mutex_lock(&dev->mode_config.mutex);
+	drm_for_each_crtc(crtc, dev)
+		crtc_count++;
+
+	drm_for_each_connector(connector, dev)
+		connector_count++;
+
+	drm_for_each_encoder(encoder, dev)
+		encoder_count++;
+
+	card_res->max_height = dev->mode_config.max_height;
+	card_res->min_height = dev->mode_config.min_height;
+	card_res->max_width = dev->mode_config.max_width;
+	card_res->min_width = dev->mode_config.min_width;
+
+	/* CRTCs */
+	if (card_res->count_crtcs >= crtc_count) {
+		copied = 0;
+		crtc_id = (uint32_t __user *)(unsigned long)card_res->crtc_id_ptr;
+		drm_for_each_crtc(crtc, dev) {
+			if (put_user(crtc->base.id, crtc_id + copied)) {
+				ret = -EFAULT;
+				goto out;
+			}
+			copied++;
+		}
+	}
+	card_res->count_crtcs = crtc_count;
+
+	/* Encoders */
+	if (card_res->count_encoders >= encoder_count) {
+		copied = 0;
+		encoder_id = (uint32_t __user *)(unsigned long)card_res->encoder_id_ptr;
+		drm_for_each_encoder(encoder, dev) {
+			if (put_user(encoder->base.id, encoder_id +
+				     copied)) {
+				ret = -EFAULT;
+				goto out;
+			}
+			copied++;
+		}
+	}
+	card_res->count_encoders = encoder_count;
+
+	/* Connectors */
+	if (card_res->count_connectors >= connector_count) {
+		copied = 0;
+		connector_id = (uint32_t __user *)(unsigned long)card_res->connector_id_ptr;
+		drm_for_each_connector(connector, dev) {
+			if (put_user(connector->base.id,
+				     connector_id + copied)) {
+				ret = -EFAULT;
+				goto out;
+			}
+			copied++;
+		}
+	}
+	card_res->count_connectors = connector_count;
+
+out:
+	mutex_unlock(&dev->mode_config.mutex);
+	return ret;
+}
+
+/**
+ * drm_mode_config_reset - call ->reset callbacks
+ * @dev: drm device
+ *
+ * This functions calls all the crtc's, encoder's and connector's ->reset
+ * callback. Drivers can use this in e.g. their driver load or resume code to
+ * reset hardware and software state.
+ */
+void drm_mode_config_reset(struct drm_device *dev)
+{
+	struct drm_crtc *crtc;
+	struct drm_plane *plane;
+	struct drm_encoder *encoder;
+	struct drm_connector *connector;
+
+	drm_for_each_plane(plane, dev)
+		if (plane->funcs->reset)
+			plane->funcs->reset(plane);
+
+	drm_for_each_crtc(crtc, dev)
+		if (crtc->funcs->reset)
+			crtc->funcs->reset(crtc);
+
+	drm_for_each_encoder(encoder, dev)
+		if (encoder->funcs->reset)
+			encoder->funcs->reset(encoder);
+
+	mutex_lock(&dev->mode_config.mutex);
+	drm_for_each_connector(connector, dev)
+		if (connector->funcs->reset)
+			connector->funcs->reset(connector);
+	mutex_unlock(&dev->mode_config.mutex);
+}
+EXPORT_SYMBOL(drm_mode_config_reset);
+
+/*
+ * Global properties
+ */
+static const struct drm_prop_enum_list drm_plane_type_enum_list[] = {
+	{ DRM_PLANE_TYPE_OVERLAY, "Overlay" },
+	{ DRM_PLANE_TYPE_PRIMARY, "Primary" },
+	{ DRM_PLANE_TYPE_CURSOR, "Cursor" },
+};
+
+static int drm_mode_create_standard_properties(struct drm_device *dev)
+{
+	struct drm_property *prop;
+	int ret;
+
+	ret = drm_connector_create_standard_properties(dev);
+	if (ret)
+		return ret;
+
+	prop = drm_property_create_enum(dev, DRM_MODE_PROP_IMMUTABLE,
+					"type", drm_plane_type_enum_list,
+					ARRAY_SIZE(drm_plane_type_enum_list));
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.plane_type_property = prop;
+
+	prop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,
+			"SRC_X", 0, UINT_MAX);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.prop_src_x = prop;
+
+	prop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,
+			"SRC_Y", 0, UINT_MAX);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.prop_src_y = prop;
+
+	prop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,
+			"SRC_W", 0, UINT_MAX);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.prop_src_w = prop;
+
+	prop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,
+			"SRC_H", 0, UINT_MAX);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.prop_src_h = prop;
+
+	prop = drm_property_create_signed_range(dev, DRM_MODE_PROP_ATOMIC,
+			"CRTC_X", INT_MIN, INT_MAX);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.prop_crtc_x = prop;
+
+	prop = drm_property_create_signed_range(dev, DRM_MODE_PROP_ATOMIC,
+			"CRTC_Y", INT_MIN, INT_MAX);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.prop_crtc_y = prop;
+
+	prop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,
+			"CRTC_W", 0, INT_MAX);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.prop_crtc_w = prop;
+
+	prop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,
+			"CRTC_H", 0, INT_MAX);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.prop_crtc_h = prop;
+
+	prop = drm_property_create_object(dev, DRM_MODE_PROP_ATOMIC,
+			"FB_ID", DRM_MODE_OBJECT_FB);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.prop_fb_id = prop;
+
+	prop = drm_property_create_object(dev, DRM_MODE_PROP_ATOMIC,
+			"CRTC_ID", DRM_MODE_OBJECT_CRTC);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.prop_crtc_id = prop;
+
+	prop = drm_property_create_bool(dev, DRM_MODE_PROP_ATOMIC,
+			"ACTIVE");
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.prop_active = prop;
+
+	prop = drm_property_create(dev,
+			DRM_MODE_PROP_ATOMIC | DRM_MODE_PROP_BLOB,
+			"MODE_ID", 0);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.prop_mode_id = prop;
+
+	prop = drm_property_create(dev,
+			DRM_MODE_PROP_BLOB,
+			"DEGAMMA_LUT", 0);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.degamma_lut_property = prop;
+
+	prop = drm_property_create_range(dev,
+			DRM_MODE_PROP_IMMUTABLE,
+			"DEGAMMA_LUT_SIZE", 0, UINT_MAX);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.degamma_lut_size_property = prop;
+
+	prop = drm_property_create(dev,
+			DRM_MODE_PROP_BLOB,
+			"CTM", 0);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.ctm_property = prop;
+
+	prop = drm_property_create(dev,
+			DRM_MODE_PROP_BLOB,
+			"GAMMA_LUT", 0);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.gamma_lut_property = prop;
+
+	prop = drm_property_create_range(dev,
+			DRM_MODE_PROP_IMMUTABLE,
+			"GAMMA_LUT_SIZE", 0, UINT_MAX);
+	if (!prop)
+		return -ENOMEM;
+	dev->mode_config.gamma_lut_size_property = prop;
+
+	return 0;
+}
+
+/**
+ * drm_mode_config_init - initialize DRM mode_configuration structure
+ * @dev: DRM device
+ *
+ * Initialize @dev's mode_config structure, used for tracking the graphics
+ * configuration of @dev.
+ *
+ * Since this initializes the modeset locks, no locking is possible. Which is no
+ * problem, since this should happen single threaded at init time. It is the
+ * driver's problem to ensure this guarantee.
+ *
+ */
+void drm_mode_config_init(struct drm_device *dev)
+{
+	mutex_init(&dev->mode_config.mutex);
+	drm_modeset_lock_init(&dev->mode_config.connection_mutex);
+	mutex_init(&dev->mode_config.idr_mutex);
+	mutex_init(&dev->mode_config.fb_lock);
+	mutex_init(&dev->mode_config.blob_lock);
+	INIT_LIST_HEAD(&dev->mode_config.fb_list);
+	INIT_LIST_HEAD(&dev->mode_config.crtc_list);
+	INIT_LIST_HEAD(&dev->mode_config.connector_list);
+	INIT_LIST_HEAD(&dev->mode_config.encoder_list);
+	INIT_LIST_HEAD(&dev->mode_config.property_list);
+	INIT_LIST_HEAD(&dev->mode_config.property_blob_list);
+	INIT_LIST_HEAD(&dev->mode_config.plane_list);
+	idr_init(&dev->mode_config.crtc_idr);
+	idr_init(&dev->mode_config.tile_idr);
+	ida_init(&dev->mode_config.connector_ida);
+
+	drm_modeset_lock_all(dev);
+	drm_mode_create_standard_properties(dev);
+	drm_modeset_unlock_all(dev);
+
+	/* Just to be sure */
+	dev->mode_config.num_fb = 0;
+	dev->mode_config.num_connector = 0;
+	dev->mode_config.num_crtc = 0;
+	dev->mode_config.num_encoder = 0;
+	dev->mode_config.num_overlay_plane = 0;
+	dev->mode_config.num_total_plane = 0;
+}
+EXPORT_SYMBOL(drm_mode_config_init);
+
+/**
+ * drm_mode_config_cleanup - free up DRM mode_config info
+ * @dev: DRM device
+ *
+ * Free up all the connectors and CRTCs associated with this DRM device, then
+ * free up the framebuffers and associated buffer objects.
+ *
+ * Note that since this /should/ happen single-threaded at driver/device
+ * teardown time, no locking is required. It's the driver's job to ensure that
+ * this guarantee actually holds true.
+ *
+ * FIXME: cleanup any dangling user buffer objects too
+ */
+void drm_mode_config_cleanup(struct drm_device *dev)
+{
+	struct drm_connector *connector, *ot;
+	struct drm_crtc *crtc, *ct;
+	struct drm_encoder *encoder, *enct;
+	struct drm_framebuffer *fb, *fbt;
+	struct drm_property *property, *pt;
+	struct drm_property_blob *blob, *bt;
+	struct drm_plane *plane, *plt;
+
+	list_for_each_entry_safe(encoder, enct, &dev->mode_config.encoder_list,
+				 head) {
+		encoder->funcs->destroy(encoder);
+	}
+
+	list_for_each_entry_safe(connector, ot,
+				 &dev->mode_config.connector_list, head) {
+		connector->funcs->destroy(connector);
+	}
+
+	list_for_each_entry_safe(property, pt, &dev->mode_config.property_list,
+				 head) {
+		drm_property_destroy(dev, property);
+	}
+
+	list_for_each_entry_safe(plane, plt, &dev->mode_config.plane_list,
+				 head) {
+		plane->funcs->destroy(plane);
+	}
+
+	list_for_each_entry_safe(crtc, ct, &dev->mode_config.crtc_list, head) {
+		crtc->funcs->destroy(crtc);
+	}
+
+	list_for_each_entry_safe(blob, bt, &dev->mode_config.property_blob_list,
+				 head_global) {
+		drm_property_unreference_blob(blob);
+	}
+
+	/*
+	 * Single-threaded teardown context, so it's not required to grab the
+	 * fb_lock to protect against concurrent fb_list access. Contrary, it
+	 * would actually deadlock with the drm_framebuffer_cleanup function.
+	 *
+	 * Also, if there are any framebuffers left, that's a driver leak now,
+	 * so politely WARN about this.
+	 */
+	WARN_ON(!list_empty(&dev->mode_config.fb_list));
+	list_for_each_entry_safe(fb, fbt, &dev->mode_config.fb_list, head) {
+		drm_framebuffer_free(&fb->base.refcount);
+	}
+
+	ida_destroy(&dev->mode_config.connector_ida);
+	idr_destroy(&dev->mode_config.tile_idr);
+	idr_destroy(&dev->mode_config.crtc_idr);
+	drm_modeset_lock_fini(&dev->mode_config.connection_mutex);
+}
+EXPORT_SYMBOL(drm_mode_config_cleanup);
