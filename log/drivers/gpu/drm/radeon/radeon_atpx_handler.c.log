commit f50a7f3d9225dd374455f28138f79ae3074a7a3d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:18 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 191
    
    Based on 1 normalized pattern(s):
    
      licensed under gplv2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 99 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170027.163048684@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index fa5fadaa9bbb..6f93f54bf651 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2010 Red Hat Inc.
  * Author : Dave Airlie <airlied@redhat.com>
  *
- * Licensed under GPLv2
- *
  * ATPX support for both Intel/ATI
  */
 #include <linux/vga_switcheroo.h>

commit 4a8f264a8a8756bb7d3a478d08e449c67d291ab9
Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
Date:   Tue Apr 24 15:15:41 2018 +0200

    drm/radeon: fix radeon_atpx_get_client_id()'s return type
    
    The method struct vga_switcheroo_handler::get_client_id() is defined
    as returning an 'enum vga_switcheroo_client_id' but the implementation
    in this driver, radeon_atpx_get_client_id(), returns an 'int'.
    
    Fix this by returning 'enum vga_switcheroo_client_id' in this driver too.
    
    Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 40be4068ca69..fa5fadaa9bbb 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -526,7 +526,7 @@ static int radeon_atpx_init(void)
  * look up whether we are the integrated or discrete GPU (all asics).
  * Returns the client id.
  */
-static int radeon_atpx_get_client_id(struct pci_dev *pdev)
+static enum vga_switcheroo_client_id radeon_atpx_get_client_id(struct pci_dev *pdev)
 {
 	if (radeon_atpx_priv.dhandle == ACPI_HANDLE(&pdev->dev))
 		return VGA_SWITCHEROO_IGD;

commit 7ca85295d8cc280ea79cf6250c47363b7fd92f92
Author: Joe Perches <joe@perches.com>
Date:   Tue Feb 28 04:55:52 2017 -0800

    gpu: drm: amd/radeon: Convert printk(KERN_<LEVEL> to pr_<level>
    
    Use a more common logging style.
    
    Miscellanea:
    
    o Coalesce formats and realign arguments
    o Neaten a few macros now using pr_<level>
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 0ae13cd2adda..40be4068ca69 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -577,8 +577,8 @@ static bool radeon_atpx_detect(void)
 
 	if (has_atpx && vga_count == 2) {
 		acpi_get_name(radeon_atpx_priv.atpx.handle, ACPI_FULL_PATHNAME, &buffer);
-		printk(KERN_INFO "vga_switcheroo: detected switching method %s handle\n",
-		       acpi_method_name);
+		pr_info("vga_switcheroo: detected switching method %s handle\n",
+			acpi_method_name);
 		radeon_atpx_priv.atpx_detected = true;
 		radeon_atpx_priv.bridge_pm_usable = d3_supported;
 		radeon_atpx_init();

commit bcfdd5d5105087e6f33dfeb08a1ca6b2c0287b61
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Nov 28 17:23:40 2016 -0500

    drm/radeon: fix check for port PM availability
    
    The ATPX method does not always exist on the dGPU, it may be located at
    the iGPU. The parent device of the iGPU is the root port for which
    bridge_d3 is false. This accidentally enables the legacy PM method which
    conflicts with port PM and prevented the dGPU from powering on.
    
    Ported from amdgpu commit:
    drm/amdgpu: fix check for port PM availability
    from Peter Wu.
    
    Fixes: d3ac31f3b4bf9fad (drm/radeon: fix power state when port pm is unavailable (v2))
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: Peter Wu <peter@lekensteyn.nl>
    Cc: <stable@vger.kernel.org> # 4.8+

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 4129b12521a6..0ae13cd2adda 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -479,7 +479,6 @@ static int radeon_atpx_power_state(enum vga_switcheroo_client_id id,
  */
 static bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)
 {
-	struct pci_dev *parent_pdev = pci_upstream_bridge(pdev);
 	acpi_handle dhandle, atpx_handle;
 	acpi_status status;
 
@@ -493,7 +492,6 @@ static bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)
 
 	radeon_atpx_priv.dhandle = dhandle;
 	radeon_atpx_priv.atpx.handle = atpx_handle;
-	radeon_atpx_priv.bridge_pm_usable = parent_pdev && parent_pdev->bridge_d3;
 	return true;
 }
 
@@ -555,11 +553,16 @@ static bool radeon_atpx_detect(void)
 	struct pci_dev *pdev = NULL;
 	bool has_atpx = false;
 	int vga_count = 0;
+	bool d3_supported = false;
+	struct pci_dev *parent_pdev;
 
 	while ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {
 		vga_count++;
 
 		has_atpx |= (radeon_atpx_pci_probe_handle(pdev) == true);
+
+		parent_pdev = pci_upstream_bridge(pdev);
+		d3_supported |= parent_pdev && parent_pdev->bridge_d3;
 	}
 
 	/* some newer PX laptops mark the dGPU as a non-VGA display device */
@@ -567,6 +570,9 @@ static bool radeon_atpx_detect(void)
 		vga_count++;
 
 		has_atpx |= (radeon_atpx_pci_probe_handle(pdev) == true);
+
+		parent_pdev = pci_upstream_bridge(pdev);
+		d3_supported |= parent_pdev && parent_pdev->bridge_d3;
 	}
 
 	if (has_atpx && vga_count == 2) {
@@ -574,6 +580,7 @@ static bool radeon_atpx_detect(void)
 		printk(KERN_INFO "vga_switcheroo: detected switching method %s handle\n",
 		       acpi_method_name);
 		radeon_atpx_priv.atpx_detected = true;
+		radeon_atpx_priv.bridge_pm_usable = d3_supported;
 		radeon_atpx_init();
 		return true;
 	}

commit d3ac31f3b4bf9fade93d69770cb9c34912e017be
Author: Peter Wu <peter@lekensteyn.nl>
Date:   Wed Nov 23 02:22:25 2016 +0100

    drm/radeon: fix power state when port pm is unavailable (v2)
    
    When PCIe port PM is not enabled (system BIOS is pre-2015 or the
    pcie_port_pm=off parameter is set), legacy ATPX PM should still be
    marked as supported. Otherwise the GPU can fail to power on after
    runtime suspend. This affected a Dell Inspiron 5548.
    
    Ideally the BIOS date in the PCI core is lowered to 2013 (the first year
    where hybrid graphics platforms using power resources was introduced),
    but that seems more risky at this point and would not solve the
    pcie_port_pm=off issue.
    
    v2: agd: fix typo
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=98505
    Signed-off-by: Peter Wu <peter@lekensteyn.nl>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: <stable@vger.kernel.org> # 4.8+
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 2fdcd04bc93f..4129b12521a6 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -34,6 +34,7 @@ struct radeon_atpx {
 
 static struct radeon_atpx_priv {
 	bool atpx_detected;
+	bool bridge_pm_usable;
 	/* handle for device - and atpx */
 	acpi_handle dhandle;
 	struct radeon_atpx atpx;
@@ -203,7 +204,11 @@ static int radeon_atpx_validate(struct radeon_atpx *atpx)
 	atpx->is_hybrid = false;
 	if (valid_bits & ATPX_MS_HYBRID_GFX_SUPPORTED) {
 		printk("ATPX Hybrid Graphics\n");
-		atpx->functions.power_cntl = false;
+		/*
+		 * Disable legacy PM methods only when pcie port PM is usable,
+		 * otherwise the device might fail to power off or power on.
+		 */
+		atpx->functions.power_cntl = !radeon_atpx_priv.bridge_pm_usable;
 		atpx->is_hybrid = true;
 	}
 
@@ -474,6 +479,7 @@ static int radeon_atpx_power_state(enum vga_switcheroo_client_id id,
  */
 static bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)
 {
+	struct pci_dev *parent_pdev = pci_upstream_bridge(pdev);
 	acpi_handle dhandle, atpx_handle;
 	acpi_status status;
 
@@ -487,6 +493,7 @@ static bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)
 
 	radeon_atpx_priv.dhandle = dhandle;
 	radeon_atpx_priv.atpx.handle = atpx_handle;
+	radeon_atpx_priv.bridge_pm_usable = parent_pdev && parent_pdev->bridge_d3;
 	return true;
 }
 

commit ca09fb9f60b5f3ab2d57e761aaeea89a5147d784
Merge: 9f4ef05bcdcf 08895a8b6b06
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Sep 28 12:08:49 2016 +1000

    Merge tag 'v4.8-rc8' into drm-next
    
    Linux 4.8-rc8
    
    There was a lot of fallout in the imx/amdgpu/i915 drivers, so backmerge
    it now to avoid troubles.
    
    * tag 'v4.8-rc8': (1442 commits)
      Linux 4.8-rc8
      fault_in_multipages_readable() throws set-but-unused error
      mm: check VMA flags to avoid invalid PROT_NONE NUMA balancing
      radix tree: fix sibling entry handling in radix_tree_descend()
      radix tree test suite: Test radix_tree_replace_slot() for multiorder entries
      fix memory leaks in tracing_buffers_splice_read()
      tracing: Move mutex to protect against resetting of seq data
      MIPS: Fix delay slot emulation count in debugfs
      MIPS: SMP: Fix possibility of deadlock when bringing CPUs online
      mm: delete unnecessary and unsafe init_tlb_ubc()
      huge tmpfs: fix Committed_AS leak
      shmem: fix tmpfs to handle the huge= option properly
      blk-mq: skip unmapped queues in blk_mq_alloc_request_hctx
      MIPS: Fix pre-r6 emulation FPU initialisation
      arm64: kgdb: handle read-only text / modules
      arm64: Call numa_store_cpu_info() earlier.
      locking/hung_task: Fix typo in CONFIG_DETECT_HUNG_TASK help text
      nvme-rdma: only clear queue flags after successful connect
      i2c: qup: skip qup_i2c_suspend if the device is already runtime suspended
      perf/core: Limit matching exclusive events to one PMU
      ...

commit 4777166989dee66a5050ce77d0ea37832ed330d7
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Sep 14 14:14:55 2016 -0400

    drm/radeon/atpx: check for ATIF dGPU wake for display events support
    
    Some ATPX laptops implement special circuitry to generate
    display hotplug events via ACPI when the dGPU is powered off.
    Check if this is supported.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 6de342861202..a1321b2fa454 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -29,6 +29,7 @@ struct radeon_atpx {
 	acpi_handle handle;
 	struct radeon_atpx_functions functions;
 	bool is_hybrid;
+	bool dgpu_req_power_for_displays;
 };
 
 static struct radeon_atpx_priv {
@@ -72,6 +73,10 @@ bool radeon_is_atpx_hybrid(void) {
 	return radeon_atpx_priv.atpx.is_hybrid;
 }
 
+bool radeon_atpx_dgpu_req_power_for_displays(void) {
+	return radeon_atpx_priv.atpx.dgpu_req_power_for_displays;
+}
+
 /**
  * radeon_atpx_call - call an ATPX method
  *

commit b817634276f7f68c9d1d6d4a27117ff3c2f16956
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Aug 9 00:21:45 2016 -0400

    Revert "drm/radeon: work around lack of upstream ACPI support for D3cold"
    
    This reverts commit bdfb76040068d960cb9e226876be8a508d741c4a.
    
    Now that d3cold is upstream, there is no more need for this workaround.

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 6de342861202..ddef0d494084 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -198,16 +198,7 @@ static int radeon_atpx_validate(struct radeon_atpx *atpx)
 	atpx->is_hybrid = false;
 	if (valid_bits & ATPX_MS_HYBRID_GFX_SUPPORTED) {
 		printk("ATPX Hybrid Graphics\n");
-#if 1
-		/* This is a temporary hack until the D3 cold support
-		 * makes it upstream.  The ATPX power_control method seems
-		 * to still work on even if the system should be using
-		 * the new standardized hybrid D3 cold ACPI interface.
-		 */
-		atpx->functions.power_cntl = true;
-#else
 		atpx->functions.power_cntl = false;
-#endif
 		atpx->is_hybrid = true;
 	}
 

commit 69ee9742f945cda8bd0081961770cd2e3192a77a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Jul 27 14:56:12 2016 -0400

    drm/radeon: init atpx at switcheroo register time v2
    
    If we do it at enable time, it's too late for the feature
    checks.
    
    v2: drop .init setting as per Peter's comments
    
    bug: https://bugzilla.kernel.org/show_bug.cgi?id=115321
    Reviewed-by: Peter Wu <peter@lekensteyn.nl>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: Peter Wu <peter@lekensteyn.nl>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 86dcdf38b732..6de342861202 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -536,7 +536,6 @@ static int radeon_atpx_get_client_id(struct pci_dev *pdev)
 static const struct vga_switcheroo_handler radeon_atpx_handler = {
 	.switchto = radeon_atpx_switchto,
 	.power_state = radeon_atpx_power_state,
-	.init = radeon_atpx_init,
 	.get_client_id = radeon_atpx_get_client_id,
 };
 
@@ -572,6 +571,7 @@ static bool radeon_atpx_detect(void)
 		printk(KERN_INFO "vga_switcheroo: detected switching method %s handle\n",
 		       acpi_method_name);
 		radeon_atpx_priv.atpx_detected = true;
+		radeon_atpx_init();
 		return true;
 	}
 	return false;

commit bdfb76040068d960cb9e226876be8a508d741c4a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Jun 3 17:10:33 2016 -0400

    drm/radeon: work around lack of upstream ACPI support for D3cold
    
    Until Dave's patch to support the new hybrid gfx ACPI method goes
    upstream, we can fallback to the old ATPX method which seems to
    still work.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index de17b5ed3ea4..86dcdf38b732 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -198,7 +198,16 @@ static int radeon_atpx_validate(struct radeon_atpx *atpx)
 	atpx->is_hybrid = false;
 	if (valid_bits & ATPX_MS_HYBRID_GFX_SUPPORTED) {
 		printk("ATPX Hybrid Graphics\n");
+#if 1
+		/* This is a temporary hack until the D3 cold support
+		 * makes it upstream.  The ATPX power_control method seems
+		 * to still work on even if the system should be using
+		 * the new standardized hybrid D3 cold ACPI interface.
+		 */
+		atpx->functions.power_cntl = true;
+#else
 		atpx->functions.power_cntl = false;
+#endif
 		atpx->is_hybrid = true;
 	}
 

commit b8c9fd5ad4b478ec1a5482177833e1a7082e48bd
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Jun 2 09:24:53 2016 -0400

    drm/radeon/atpx: track whether if this is a hybrid graphics platform
    
    hybrid graphics in this case refers to systems which use the new
    platform d3 cold ACPI methods as opposed to ATPX for dGPU power
    control.
    
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 6996b316d5c5..de17b5ed3ea4 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -28,6 +28,7 @@ struct radeon_atpx_functions {
 struct radeon_atpx {
 	acpi_handle handle;
 	struct radeon_atpx_functions functions;
+	bool is_hybrid;
 };
 
 static struct radeon_atpx_priv {
@@ -67,6 +68,10 @@ bool radeon_has_atpx_dgpu_power_cntl(void) {
 	return radeon_atpx_priv.atpx.functions.power_cntl;
 }
 
+bool radeon_is_atpx_hybrid(void) {
+	return radeon_atpx_priv.atpx.is_hybrid;
+}
+
 /**
  * radeon_atpx_call - call an ATPX method
  *
@@ -190,9 +195,11 @@ static int radeon_atpx_validate(struct radeon_atpx *atpx)
 			  ATPX_DYNAMIC_DGPU_POWER_OFF_SUPPORTED))
 		atpx->functions.power_cntl = true;
 
+	atpx->is_hybrid = false;
 	if (valid_bits & ATPX_MS_HYBRID_GFX_SUPPORTED) {
-		printk("Hybrid Graphics, ATPX dGPU power cntl disabled\n");
+		printk("ATPX Hybrid Graphics\n");
 		atpx->functions.power_cntl = false;
+		atpx->is_hybrid = true;
 	}
 
 	return 0;

commit 410ca8d13b89761cac3cb637ea7670377c620538
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Jun 1 15:13:24 2016 -0400

    drm/radeon/atpx: drop forcing of dGPU power control
    
    Now that we handle this correctly, there is no need to force
    it.
    
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 51da319db14a..6996b316d5c5 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -193,11 +193,6 @@ static int radeon_atpx_validate(struct radeon_atpx *atpx)
 	if (valid_bits & ATPX_MS_HYBRID_GFX_SUPPORTED) {
 		printk("Hybrid Graphics, ATPX dGPU power cntl disabled\n");
 		atpx->functions.power_cntl = false;
-	} else if (atpx->functions.power_cntl == false) {
-		/* make sure required functions are enabled */
-		/* dGPU power control is required */
-		printk("ATPX dGPU power cntl not present, forcing\n");
-		atpx->functions.power_cntl = true;
 	}
 
 	return 0;

commit e1052b35f4ac860707743eb3a9c665b2393b5bb9
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Jun 1 15:05:05 2016 -0400

    drm/radeon/atpx: add a query for ATPX dGPU power control
    
    The runtime pm sequence is different depending on whether or
    not the platform supports ATPX dGPU power control.
    
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 3d9519411c84..51da319db14a 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -63,6 +63,10 @@ bool radeon_has_atpx(void) {
 	return radeon_atpx_priv.atpx_detected;
 }
 
+bool radeon_has_atpx_dgpu_power_cntl(void) {
+	return radeon_atpx_priv.atpx.functions.power_cntl;
+}
+
 /**
  * radeon_atpx_call - call an ATPX method
  *

commit d814b24fb74cb9797d70cb8053961447c5879a5c
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Jun 1 12:58:36 2016 -0400

    drm/radeon: add a delay after ATPX dGPU power off
    
    ATPX dGPU power control requires a 200ms delay between
    power off and on.  This should fix dGPU failures on
    resume from power off.
    
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 55efbcdfd377..3d9519411c84 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -10,6 +10,7 @@
 #include <linux/slab.h>
 #include <linux/acpi.h>
 #include <linux/pci.h>
+#include <linux/delay.h>
 
 #include "radeon_acpi.h"
 
@@ -269,6 +270,10 @@ static int radeon_atpx_set_discrete_state(struct radeon_atpx *atpx, u8 state)
 		if (!info)
 			return -EIO;
 		kfree(info);
+
+		/* 200ms delay is required after off */
+		if (state == 0)
+			msleep(200);
 	}
 	return 0;
 }

commit 305e12d0e24b942044cbb6f0f67a860635c597d3
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Jun 1 12:47:38 2016 -0400

    drm/radeon: clean up atpx power control handling
    
    The presence of the power control method should be determined
    via the presence of the method in function 0.  However, some
    sbioses only set the appropriate bits in function 1 so use
    then to override a missing power control function.
    
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 3e24fe053f38..55efbcdfd377 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -141,18 +141,12 @@ static void radeon_atpx_parse_functions(struct radeon_atpx_functions *f, u32 mas
  */
 static int radeon_atpx_validate(struct radeon_atpx *atpx)
 {
-	/* make sure required functions are enabled */
-	/* dGPU power control is required */
-	if (atpx->functions.power_cntl == false) {
-		printk("ATPX dGPU power cntl not present, forcing\n");
-		atpx->functions.power_cntl = true;
-	}
+	u32 valid_bits = 0;
 
 	if (atpx->functions.px_params) {
 		union acpi_object *info;
 		struct atpx_px_params output;
 		size_t size;
-		u32 valid_bits;
 
 		info = radeon_atpx_call(atpx->handle, ATPX_FUNCTION_GET_PX_PARAMETERS, NULL);
 		if (!info)
@@ -171,24 +165,36 @@ static int radeon_atpx_validate(struct radeon_atpx *atpx)
 		memcpy(&output, info->buffer.pointer, size);
 
 		valid_bits = output.flags & output.valid_flags;
-		/* if separate mux flag is set, mux controls are required */
-		if (valid_bits & ATPX_SEPARATE_MUX_FOR_I2C) {
-			atpx->functions.i2c_mux_cntl = true;
-			atpx->functions.disp_mux_cntl = true;
-		}
-		/* if any outputs are muxed, mux controls are required */
-		if (valid_bits & (ATPX_CRT1_RGB_SIGNAL_MUXED |
-				  ATPX_TV_SIGNAL_MUXED |
-				  ATPX_DFP_SIGNAL_MUXED))
-			atpx->functions.disp_mux_cntl = true;
-
-		if (valid_bits & ATPX_MS_HYBRID_GFX_SUPPORTED) {
-			printk("Hybrid Graphics, ATPX dGPU power cntl disabled\n");
-			atpx->functions.power_cntl = false;
-		}
 
 		kfree(info);
 	}
+
+	/* if separate mux flag is set, mux controls are required */
+	if (valid_bits & ATPX_SEPARATE_MUX_FOR_I2C) {
+		atpx->functions.i2c_mux_cntl = true;
+		atpx->functions.disp_mux_cntl = true;
+	}
+	/* if any outputs are muxed, mux controls are required */
+	if (valid_bits & (ATPX_CRT1_RGB_SIGNAL_MUXED |
+			  ATPX_TV_SIGNAL_MUXED |
+			  ATPX_DFP_SIGNAL_MUXED))
+		atpx->functions.disp_mux_cntl = true;
+
+	/* some bioses set these bits rather than flagging power_cntl as supported */
+	if (valid_bits & (ATPX_DYNAMIC_PX_SUPPORTED |
+			  ATPX_DYNAMIC_DGPU_POWER_OFF_SUPPORTED))
+		atpx->functions.power_cntl = true;
+
+	if (valid_bits & ATPX_MS_HYBRID_GFX_SUPPORTED) {
+		printk("Hybrid Graphics, ATPX dGPU power cntl disabled\n");
+		atpx->functions.power_cntl = false;
+	} else if (atpx->functions.power_cntl == false) {
+		/* make sure required functions are enabled */
+		/* dGPU power control is required */
+		printk("ATPX dGPU power cntl not present, forcing\n");
+		atpx->functions.power_cntl = true;
+	}
+
 	return 0;
 }
 

commit cf26f9081fd7412f19a836af47567e680fcd269d
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Jun 1 12:20:16 2016 -0400

    drm/radeon: disable power control on hybrid laptops
    
    Windows 10 (and some 8.1) systems use standardized
    ACPI calls for hybrid laptops to control dGPU power.
    Detect those cases and disable the AMD specific ATPX
    power control.
    
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 95f4fea89302..3e24fe053f38 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -182,6 +182,11 @@ static int radeon_atpx_validate(struct radeon_atpx *atpx)
 				  ATPX_DFP_SIGNAL_MUXED))
 			atpx->functions.disp_mux_cntl = true;
 
+		if (valid_bits & ATPX_MS_HYBRID_GFX_SUPPORTED) {
+			printk("Hybrid Graphics, ATPX dGPU power cntl disabled\n");
+			atpx->functions.power_cntl = false;
+		}
+
 		kfree(info);
 	}
 	return 0;

commit dfc4f59d901bf72f93280b7c142c8ad846359c6f
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Apr 18 11:26:26 2016 -0400

    drm/radeon: print a message if ATPX dGPU power control is missing
    
    It will help identify problematic boards.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 56482e35d43e..95f4fea89302 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -143,7 +143,10 @@ static int radeon_atpx_validate(struct radeon_atpx *atpx)
 {
 	/* make sure required functions are enabled */
 	/* dGPU power control is required */
-	atpx->functions.power_cntl = true;
+	if (atpx->functions.power_cntl == false) {
+		printk("ATPX dGPU power cntl not present, forcing\n");
+		atpx->functions.power_cntl = true;
+	}
 
 	if (atpx->functions.px_params) {
 		union acpi_object *info;

commit bfaddd9fc8ac048b99475f000dbef6f08297417f
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Apr 18 11:19:19 2016 -0400

    Revert "drm/radeon: disable runtime pm on PX laptops without dGPU power control"
    
    This reverts commit e64c952efb8e0c15ae82cec8e455ab4910690ef1.
    
    ATPX is the ACPI method for controlling AMD PowerXpress laptops.
    There are flags to indicate which methods are supported.  If
    the dGPU power down flag is not supported, the driver needs to
    implement the dGPU power down manually.  We had previously
    always forced the driver to assume the ATPX dGPU power down
    was present, but this causes problems on boards where it is
    not, leading to GPU hangs when attempting to power down the
    dGPU.  Manual dGPU power down is not currently supported in
    the Linux driver.  Some laptops indicate that the ATPX
    dGPU power down method is not present, but it actually
    apparently is.  I'm not sure if this is a bios bug and it should
    be set or if there is a reason it was unset and the method should
    not be used.  This is not an issue on other OSes since both the
    ATPX and the manual driver power down methods are supported.
    
    This is apparently fairly widespread, so just revert for now.
    
    bugs:
    https://bugzilla.kernel.org/show_bug.cgi?id=115321
    https://bugzilla.kernel.org/show_bug.cgi?id=116581
    https://bugzilla.kernel.org/show_bug.cgi?id=116251
    
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index fd8c4d317e60..56482e35d43e 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -62,10 +62,6 @@ bool radeon_has_atpx(void) {
 	return radeon_atpx_priv.atpx_detected;
 }
 
-bool radeon_has_atpx_dgpu_power_cntl(void) {
-	return radeon_atpx_priv.atpx.functions.power_cntl;
-}
-
 /**
  * radeon_atpx_call - call an ATPX method
  *
@@ -145,6 +141,10 @@ static void radeon_atpx_parse_functions(struct radeon_atpx_functions *f, u32 mas
  */
 static int radeon_atpx_validate(struct radeon_atpx *atpx)
 {
+	/* make sure required functions are enabled */
+	/* dGPU power control is required */
+	atpx->functions.power_cntl = true;
+
 	if (atpx->functions.px_params) {
 		union acpi_object *info;
 		struct atpx_px_params output;

commit e64c952efb8e0c15ae82cec8e455ab4910690ef1
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Mar 2 11:47:29 2016 -0500

    drm/radeon: disable runtime pm on PX laptops without dGPU power control
    
    Some PX laptops don't provide an ACPI method to control dGPU power.  On
    those systems, the driver is responsible for handling the dGPU power
    state.  Disable runtime PM on them until support for this is implemented.
    
    Reviewed-by: Michel Dänzer <michel.daenzer@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 56482e35d43e..fd8c4d317e60 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -62,6 +62,10 @@ bool radeon_has_atpx(void) {
 	return radeon_atpx_priv.atpx_detected;
 }
 
+bool radeon_has_atpx_dgpu_power_cntl(void) {
+	return radeon_atpx_priv.atpx.functions.power_cntl;
+}
+
 /**
  * radeon_atpx_call - call an ATPX method
  *
@@ -141,10 +145,6 @@ static void radeon_atpx_parse_functions(struct radeon_atpx_functions *f, u32 mas
  */
 static int radeon_atpx_validate(struct radeon_atpx *atpx)
 {
-	/* make sure required functions are enabled */
-	/* dGPU power control is required */
-	atpx->functions.power_cntl = true;
-
 	if (atpx->functions.px_params) {
 		union acpi_object *info;
 		struct atpx_px_params output;

commit 156d7d4120e1c860fde667fc30eeae84bc3e7a25
Author: Lukas Wunner <lukas@wunner.de>
Date:   Mon Jan 11 20:09:20 2016 +0100

    vga_switcheroo: Add handler flags infrastructure
    
    Allow handlers to declare their capabilities and allow clients to
    obtain that information. So far we have these use cases:
    
    * If the handler is able to switch DDC separately, clients need to
      probe EDID with drm_get_edid_switcheroo(). We should allow them
      to detect a capable handler to ensure this function only gets
      called when needed.
    
    * Likewise if the handler is unable to switch AUX separately, the active
      client needs to communicate link training parameters to the inactive
      client, which may then skip the AUX handshake and set up its output
      with these pre-calibrated values (DisplayPort specification v1.1a,
      section 2.5.3.3). Clients need a way to recognize such a situation.
    
    The flags for the radeon_atpx_handler and amdgpu_atpx_handler are
    initially set to 0, this can later on be amended with
      handler_flags |= VGA_SWITCHEROO_CAN_SWITCH_DDC;
    when a ->switch_ddc callback is added.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=88861
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=61115
    Tested-by: Lukas Wunner <lukas@wunner.de>
        [MBP  9,1 2012  intel IVB + nvidia GK107  pre-retina  15"]
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Reviewed-by: Darren Hart <dvhart@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/2b0d93ed6e511ca09e95e45e0b35627f330fabce.1452525860.git.lukas@wunner.de

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index c4b4f298a283..56482e35d43e 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -551,13 +551,14 @@ static bool radeon_atpx_detect(void)
 void radeon_register_atpx_handler(void)
 {
 	bool r;
+	enum vga_switcheroo_handler_flags_t handler_flags = 0;
 
 	/* detect if we have any ATPX + 2 VGA in the system */
 	r = radeon_atpx_detect();
 	if (!r)
 		return;
 
-	vga_switcheroo_register_handler(&radeon_atpx_handler);
+	vga_switcheroo_register_handler(&radeon_atpx_handler, handler_flags);
 }
 
 /**

commit 5d170139eb10ae12e1bd076245c42b35453d8324
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Oct 18 13:05:40 2015 +0200

    vga_switcheroo: Constify vga_switcheroo_handler
    
    vga_switcheroo_client_ops has always been declared const since its
    introduction with 26ec685ff9d9 ("vga_switcheroo: Introduce struct
    vga_switcheroo_client_ops").
    
    Do so for vga_switcheroo_handler as well.
    
     drivers/gpu/drm/amd/amdgpu/amdgpu.ko:
       6 .rodata       00009888
    - 19 .data         00001f00
    + 19 .data         00001ee0
     drivers/gpu/drm/nouveau/nouveau.ko:
       6 .rodata       000460b8
      17 .data         00018fe0
     drivers/gpu/drm/radeon/radeon.ko:
    -  7 .rodata       00030944
    +  7 .rodata       00030964
    - 21 .data         0000d6a0
    + 21 .data         0000d678
     drivers/platform/x86/apple-gmux.ko:
    -  7 .rodata       00000140
    +  7 .rodata       00000160
    - 11 .data         000000e0
    + 11 .data         000000b8
    
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Darren Hart <dvhart@linux.intel.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Reviewed-by: Christian König <christian.koenig@amd.com>.
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index a771b9f0bf98..c4b4f298a283 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -499,7 +499,7 @@ static int radeon_atpx_get_client_id(struct pci_dev *pdev)
 		return VGA_SWITCHEROO_DIS;
 }
 
-static struct vga_switcheroo_handler radeon_atpx_handler = {
+static const struct vga_switcheroo_handler radeon_atpx_handler = {
 	.switchto = radeon_atpx_switchto,
 	.power_state = radeon_atpx_power_state,
 	.init = radeon_atpx_init,

commit 8e5de1d8c34c63331f12cf7bf7bbf115bba0317a
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Sep 5 11:14:43 2015 +0200

    drm/radeon: Spell vga_switcheroo consistently
    
    Currently everyone and their dog has their own favourite spelling
    for vga_switcheroo. This makes it hard to grep dmesg for log entries
    relating to vga_switcheroo. It also makes it hard to find related
    source files in the tree.
    
    vga_switcheroo.c uses pr_fmt "vga_switcheroo". Use that everywhere.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 8bc7d0bbd3c8..a771b9f0bf98 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -535,7 +535,7 @@ static bool radeon_atpx_detect(void)
 
 	if (has_atpx && vga_count == 2) {
 		acpi_get_name(radeon_atpx_priv.atpx.handle, ACPI_FULL_PATHNAME, &buffer);
-		printk(KERN_INFO "VGA switcheroo: detected switching method %s handle\n",
+		printk(KERN_INFO "vga_switcheroo: detected switching method %s handle\n",
 		       acpi_method_name);
 		radeon_atpx_priv.atpx_detected = true;
 		return true;

commit f91ce35e471ae17552ce7bfe355cfd997e3ad781
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Sep 10 15:30:08 2014 -0600

    ACPIPHP / radeon / nouveau: Remove acpi_bus_no_hotplug()
    
    Revert parts of f244d8b623da ("ACPIPHP / radeon / nouveau: Fix VGA
    switcheroo problem related to hotplug").
    
    A previous commit 5493b31f0b55 ("PCI: Add pci_ignore_hotplug() to ignore
    hotplug events for a device") added equivalent functionality implemented in
    a different way for both acpiphp and pciehp.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Dave Airlie <airlied@redhat.com>
    Acked-by: Rajat Jain <rajatxjain@gmail.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index a9fb0d016d38..8bc7d0bbd3c8 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -33,7 +33,6 @@ static struct radeon_atpx_priv {
 	bool atpx_detected;
 	/* handle for device - and atpx */
 	acpi_handle dhandle;
-	acpi_handle other_handle;
 	struct radeon_atpx atpx;
 } radeon_atpx_priv;
 
@@ -453,10 +452,9 @@ static bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)
 		return false;
 
 	status = acpi_get_handle(dhandle, "ATPX", &atpx_handle);
-	if (ACPI_FAILURE(status)) {
-		radeon_atpx_priv.other_handle = dhandle;
+	if (ACPI_FAILURE(status))
 		return false;
-	}
+
 	radeon_atpx_priv.dhandle = dhandle;
 	radeon_atpx_priv.atpx.handle = atpx_handle;
 	return true;
@@ -540,16 +538,6 @@ static bool radeon_atpx_detect(void)
 		printk(KERN_INFO "VGA switcheroo: detected switching method %s handle\n",
 		       acpi_method_name);
 		radeon_atpx_priv.atpx_detected = true;
-		/*
-		 * On some systems hotplug events are generated for the device
-		 * being switched off when ATPX is executed.  They cause ACPI
-		 * hotplug to trigger and attempt to remove the device from
-		 * the system, which causes it to break down.  Prevent that from
-		 * happening by setting the no_hotplug flag for the involved
-		 * ACPI device objects.
-		 */
-		acpi_bus_no_hotplug(radeon_atpx_priv.dhandle);
-		acpi_bus_no_hotplug(radeon_atpx_priv.other_handle);
 		return true;
 	}
 	return false;

commit e9a4099a59cc598a44006059dd775c25e422b772
Author: Alex Deucher <alexdeucher@gmail.com>
Date:   Tue Apr 15 12:44:34 2014 -0400

    drm/radeon: fix ATPX detection on non-VGA GPUs
    
    Some newer PX laptops have the pci device class
    set to DISPLAY_OTHER rather than DISPLAY_VGA.  This
    properly detects ATPX on those laptops.
    
    Based on a patch from: Pali Rohár <pali.rohar@gmail.com>
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org
    Cc: airlied@gmail.com

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index dedea72f48c4..a9fb0d016d38 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -528,6 +528,13 @@ static bool radeon_atpx_detect(void)
 		has_atpx |= (radeon_atpx_pci_probe_handle(pdev) == true);
 	}
 
+	/* some newer PX laptops mark the dGPU as a non-VGA display device */
+	while ((pdev = pci_get_class(PCI_CLASS_DISPLAY_OTHER << 8, pdev)) != NULL) {
+		vga_count++;
+
+		has_atpx |= (radeon_atpx_pci_probe_handle(pdev) == true);
+	}
+
 	if (has_atpx && vga_count == 2) {
 		acpi_get_name(radeon_atpx_priv.atpx.handle, ACPI_FULL_PATHNAME, &buffer);
 		printk(KERN_INFO "VGA switcheroo: detected switching method %s handle\n",

commit 90c4cde9d5a2bb6239cb3e253bb3832ed89dc75c
Author: Alex Deucher <alexdeucher@gmail.com>
Date:   Thu Apr 10 22:29:01 2014 -0400

    drm/radeon: fix runpm handling on APUs (v4)
    
    Don't try and runtime suspend the APU in PX systems.  We
    only want to power down the dGPU.
    
    v2: fix harder
    v3: fix stupid typo
    v4: consolidate runpm enablement to a single flag
    
    bugs:
    https://bugs.freedesktop.org/show_bug.cgi?id=75127
    https://bugzilla.kernel.org/show_bug.cgi?id=72701
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index fa9a9c02751e..dedea72f48c4 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -59,7 +59,7 @@ struct atpx_mux {
 	u16 mux;
 } __packed;
 
-bool radeon_is_px(void) {
+bool radeon_has_atpx(void) {
 	return radeon_atpx_priv.atpx_detected;
 }
 

commit 9f050c7f9738ffa746c63415136645ad231b1348
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Feb 20 09:16:01 2014 -0500

    drm/radeon: print the supported atpx function mask
    
    Print the supported functions mask in addition to
    the version.  This is useful in debugging PX
    problems since we can see what functions are available.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 485848f889f5..fa9a9c02751e 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -219,7 +219,8 @@ static int radeon_atpx_verify_interface(struct radeon_atpx *atpx)
 	memcpy(&output, info->buffer.pointer, size);
 
 	/* TODO: check version? */
-	printk("ATPX version %u\n", output.version);
+	printk("ATPX version %u, functions 0x%08x\n",
+	       output.version, output.function_bits);
 
 	radeon_atpx_parse_functions(&atpx->functions, output.function_bits);
 

commit f244d8b623dae7a7bc695b0336f67729b95a9736
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Dec 31 13:39:42 2013 +0100

    ACPIPHP / radeon / nouveau: Fix VGA switcheroo problem related to hotplug
    
    The changes in the ACPI-based PCI hotplug (ACPIPHP) subsystem made
    during the 3.12 development cycle uncovered a problem with VGA
    switcheroo that on some systems, when the device-specific method
    (ATPX in the radeon case, _DSM in the nouveau case) is used to turn
    off the discrete graphics, the BIOS generates ACPI hotplug events for
    that device and those events cause ACPIPHP to attempt to remove the
    device from the system (they are events for a device that was present
    previously and is not present any more, so that's what should be done
    according to the spec).  Then, the system stops functioning correctly.
    
    Since the hotplug events in question were simply silently ignored
    previously, the least intrusive way to address that problem is to
    make ACPIPHP ignore them again.  For this purpose, introduce a new
    ACPI device flag, no_hotplug, and modify ACPIPHP to ignore hotplug
    events for PCI devices whose ACPI companions have that flag set.
    Next, make the radeon and nouveau switcheroo detection code set the
    no_hotplug flag for the discrete graphics' ACPI companion.
    
    Fixes: bbd34fcdd1b2 (ACPI / hotplug / PCI: Register all devices under the given bridge)
    References: https://bugzilla.kernel.org/show_bug.cgi?id=61891
    References: https://bugzilla.kernel.org/show_bug.cgi?id=64891
    Reported-and-tested-by: Mike Lothian <mike@fireburn.co.uk>
    Reported-and-tested-by: <madcatx@atlas.cz>
    Reported-and-tested-by: Joaquín Aramendía <samsagax@gmail.com>
    Cc: Alex Deucher <alexdeucher@gmail.com>
    Cc: Dave Airlie <airlied@linux.ie>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: 3.12+ <stable@vger.kernel.org> # 3.12+

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 9d302eaeea15..485848f889f5 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -33,6 +33,7 @@ static struct radeon_atpx_priv {
 	bool atpx_detected;
 	/* handle for device - and atpx */
 	acpi_handle dhandle;
+	acpi_handle other_handle;
 	struct radeon_atpx atpx;
 } radeon_atpx_priv;
 
@@ -451,9 +452,10 @@ static bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)
 		return false;
 
 	status = acpi_get_handle(dhandle, "ATPX", &atpx_handle);
-	if (ACPI_FAILURE(status))
+	if (ACPI_FAILURE(status)) {
+		radeon_atpx_priv.other_handle = dhandle;
 		return false;
-
+	}
 	radeon_atpx_priv.dhandle = dhandle;
 	radeon_atpx_priv.atpx.handle = atpx_handle;
 	return true;
@@ -530,6 +532,16 @@ static bool radeon_atpx_detect(void)
 		printk(KERN_INFO "VGA switcheroo: detected switching method %s handle\n",
 		       acpi_method_name);
 		radeon_atpx_priv.atpx_detected = true;
+		/*
+		 * On some systems hotplug events are generated for the device
+		 * being switched off when ATPX is executed.  They cause ACPI
+		 * hotplug to trigger and attempt to remove the device from
+		 * the system, which causes it to break down.  Prevent that from
+		 * happening by setting the no_hotplug flag for the involved
+		 * ACPI device objects.
+		 */
+		acpi_bus_no_hotplug(radeon_atpx_priv.dhandle);
+		acpi_bus_no_hotplug(radeon_atpx_priv.other_handle);
 		return true;
 	}
 	return false;

commit 82023bb7f75b0052f40d3e74169d191c3e4e6286
Merge: e6d69a60b77a ed6a82546d2e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 20 13:25:04 2013 -0800

    Merge tag 'pm+acpi-2-3.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more ACPI and power management updates from Rafael Wysocki:
    
     - ACPI-based device hotplug fixes for issues introduced recently and a
       fix for an older error code path bug in the ACPI PCI host bridge
       driver
    
     - Fix for recently broken OMAP cpufreq build from Viresh Kumar
    
     - Fix for a recent hibernation regression related to s2disk
    
     - Fix for a locking-related regression in the ACPI EC driver from
       Puneet Kumar
    
     - System suspend error code path fix related to runtime PM and runtime
       PM documentation update from Ulf Hansson
    
     - cpufreq's conservative governor fix from Xiaoguang Chen
    
     - New processor IDs for intel_idle and turbostat and removal of an
       obsolete Kconfig option from Len Brown
    
     - New device IDs for the ACPI LPSS (Low-Power Subsystem) driver and
       ACPI-based PCI hotplug (ACPIPHP) cleanup from Mika Westerberg
    
     - Removal of several ACPI video DMI blacklist entries that are not
       necessary any more from Aaron Lu
    
     - Rework of the ACPI companion representation in struct device and code
       cleanup related to that change from Rafael J Wysocki, Lan Tianyu and
       Jarkko Nikula
    
     - Fixes for assigning names to ACPI-enumerated I2C and SPI devices from
       Jarkko Nikula
    
    * tag 'pm+acpi-2-3.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (24 commits)
      PCI / hotplug / ACPI: Drop unused acpiphp_debug declaration
      ACPI / scan: Set flags.match_driver in acpi_bus_scan_fixed()
      ACPI / PCI root: Clear driver_data before failing enumeration
      ACPI / hotplug: Fix PCI host bridge hot removal
      ACPI / hotplug: Fix acpi_bus_get_device() return value check
      cpufreq: governor: Remove fossil comment in the cpufreq_governor_dbs()
      ACPI / video: clean up DMI table for initial black screen problem
      ACPI / EC: Ensure lock is acquired before accessing ec struct members
      PM / Hibernate: Do not crash kernel in free_basic_memory_bitmaps()
      ACPI / AC: Remove struct acpi_device pointer from struct acpi_ac
      spi: Use stable dev_name for ACPI enumerated SPI slaves
      i2c: Use stable dev_name for ACPI enumerated I2C slaves
      ACPI: Provide acpi_dev_name accessor for struct acpi_device device name
      ACPI / bind: Use (put|get)_device() on ACPI device objects too
      ACPI: Eliminate the DEVICE_ACPI_HANDLE() macro
      ACPI / driver core: Store an ACPI device pointer in struct acpi_dev_node
      cpufreq: OMAP: Fix compilation error 'r & ret undeclared'
      PM / Runtime: Fix error path for prepare
      PM / Runtime: Update documentation around probe|remove|suspend
      cpufreq: conservative: set requested_freq to policy max when it is over policy max
      ...

commit 3a83f992490f8235661b768e53bd5f14915420ac
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 14 23:17:21 2013 +0100

    ACPI: Eliminate the DEVICE_ACPI_HANDLE() macro
    
    Since DEVICE_ACPI_HANDLE() is now literally identical to
    ACPI_HANDLE(), replace it with the latter everywhere and drop its
    definition from include/acpi.h.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 27a6e9dbd0c4..933bd946057b 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -442,7 +442,7 @@ static bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)
 	acpi_handle dhandle, atpx_handle;
 	acpi_status status;
 
-	dhandle = DEVICE_ACPI_HANDLE(&pdev->dev);
+	dhandle = ACPI_HANDLE(&pdev->dev);
 	if (!dhandle)
 		return false;
 
@@ -488,7 +488,7 @@ static int radeon_atpx_init(void)
  */
 static int radeon_atpx_get_client_id(struct pci_dev *pdev)
 {
-	if (radeon_atpx_priv.dhandle == DEVICE_ACPI_HANDLE(&pdev->dev))
+	if (radeon_atpx_priv.dhandle == ACPI_HANDLE(&pdev->dev))
 		return VGA_SWITCHEROO_IGD;
 	else
 		return VGA_SWITCHEROO_DIS;

commit 7b1998116bbb2f3e5dd6cb9a8ee6db479b0b50a9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 11 22:41:56 2013 +0100

    ACPI / driver core: Store an ACPI device pointer in struct acpi_dev_node
    
    Modify struct acpi_dev_node to contain a pointer to struct acpi_device
    associated with the given device object (that is, its ACPI companion
    device) instead of an ACPI handle corresponding to it.  Introduce two
    new macros for manipulating that pointer in a CONFIG_ACPI-safe way,
    ACPI_COMPANION() and ACPI_COMPANION_SET(), and rework the
    ACPI_HANDLE() macro to take the above changes into account.
    Drop the ACPI_HANDLE_SET() macro entirely and rework its users to
    use ACPI_COMPANION_SET() instead.  For some of them who used to
    pass the result of acpi_get_child() directly to ACPI_HANDLE_SET()
    introduce a helper routine acpi_preset_companion() doing an
    equivalent thing.
    
    The main motivation for doing this is that there are things
    represented by struct acpi_device objects that don't have valid
    ACPI handles (so called fixed ACPI hardware features, such as
    power and sleep buttons) and we would like to create platform
    device objects for them and "glue" them to their ACPI companions
    in the usual way (which currently is impossible due to the
    lack of valid ACPI handles).  However, there are more reasons
    why it may be useful.
    
    First, struct acpi_device pointers allow of much better type checking
    than void pointers which are ACPI handles, so it should be more
    difficult to write buggy code using modified struct acpi_dev_node
    and the new macros.  Second, the change should help to reduce (over
    time) the number of places in which the result of ACPI_HANDLE() is
    passed to acpi_bus_get_device() in order to obtain a pointer to the
    struct acpi_device associated with the given "physical" device,
    because now that pointer is returned by ACPI_COMPANION() directly.
    Finally, the change should make it easier to write generic code that
    will build both for CONFIG_ACPI set and unset without adding explicit
    compiler directives to it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com> # on Haswell
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com> # for ATA and SDIO part

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index d96070bf8388..27a6e9dbd0c4 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -8,8 +8,7 @@
  */
 #include <linux/vga_switcheroo.h>
 #include <linux/slab.h>
-#include <acpi/acpi.h>
-#include <acpi/acpi_bus.h>
+#include <linux/acpi.h>
 #include <linux/pci.h>
 
 #include "radeon_acpi.h"

commit 10ebc0bc09344ab6310309169efc73dfe6c23d72
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Sep 17 14:40:31 2012 +1000

    drm/radeon: add runtime PM support (v2)
    
    This hooks radeon up to the runtime PM system to enable
    dynamic power management for secondary GPUs in switchable
    and powerxpress laptops.
    
    v2: agd5f: clean up, add module parameter
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index d96070bf8388..6153ec18943a 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -59,6 +59,10 @@ struct atpx_mux {
 	u16 mux;
 } __packed;
 
+bool radeon_is_px(void) {
+	return radeon_atpx_priv.atpx_detected;
+}
+
 /**
  * radeon_atpx_call - call an ATPX method
  *

commit 43a23aa450cc19fe8996caf09e7e21ae5f6e56e8
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Feb 19 12:55:52 2013 -0500

    drm/radeon: properly validate the atpx interface
    
    Some bioses don't set the function mask correctly
    which caused required functions to be disabled.
    
    Fixes:
    https://bugzilla.kernel.org/show_bug.cgi?id=53111
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 15f5ded65e0c..d96070bf8388 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -43,6 +43,12 @@ struct atpx_verify_interface {
 	u32 function_bits;	/* supported functions bit vector */
 } __packed;
 
+struct atpx_px_params {
+	u16 size;		/* structure size in bytes (includes size field) */
+	u32 valid_flags;	/* which flags are valid */
+	u32 flags;		/* flags */
+} __packed;
+
 struct atpx_power_control {
 	u16 size;
 	u8 dgpu_state;
@@ -122,10 +128,62 @@ static void radeon_atpx_parse_functions(struct radeon_atpx_functions *f, u32 mas
 	f->disp_detetion_ports = mask & ATPX_GET_DISPLAY_DETECTION_PORTS_SUPPORTED;
 }
 
+/**
+ * radeon_atpx_validate_functions - validate ATPX functions
+ *
+ * @atpx: radeon atpx struct
+ *
+ * Validate that required functions are enabled (all asics).
+ * returns 0 on success, error on failure.
+ */
+static int radeon_atpx_validate(struct radeon_atpx *atpx)
+{
+	/* make sure required functions are enabled */
+	/* dGPU power control is required */
+	atpx->functions.power_cntl = true;
+
+	if (atpx->functions.px_params) {
+		union acpi_object *info;
+		struct atpx_px_params output;
+		size_t size;
+		u32 valid_bits;
+
+		info = radeon_atpx_call(atpx->handle, ATPX_FUNCTION_GET_PX_PARAMETERS, NULL);
+		if (!info)
+			return -EIO;
+
+		memset(&output, 0, sizeof(output));
+
+		size = *(u16 *) info->buffer.pointer;
+		if (size < 10) {
+			printk("ATPX buffer is too small: %zu\n", size);
+			kfree(info);
+			return -EINVAL;
+		}
+		size = min(sizeof(output), size);
+
+		memcpy(&output, info->buffer.pointer, size);
+
+		valid_bits = output.flags & output.valid_flags;
+		/* if separate mux flag is set, mux controls are required */
+		if (valid_bits & ATPX_SEPARATE_MUX_FOR_I2C) {
+			atpx->functions.i2c_mux_cntl = true;
+			atpx->functions.disp_mux_cntl = true;
+		}
+		/* if any outputs are muxed, mux controls are required */
+		if (valid_bits & (ATPX_CRT1_RGB_SIGNAL_MUXED |
+				  ATPX_TV_SIGNAL_MUXED |
+				  ATPX_DFP_SIGNAL_MUXED))
+			atpx->functions.disp_mux_cntl = true;
+
+		kfree(info);
+	}
+	return 0;
+}
+
 /**
  * radeon_atpx_verify_interface - verify ATPX
  *
- * @handle: acpi handle
  * @atpx: radeon atpx struct
  *
  * Execute the ATPX_FUNCTION_VERIFY_INTERFACE ATPX function
@@ -406,8 +464,19 @@ static bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)
  */
 static int radeon_atpx_init(void)
 {
+	int r;
+
 	/* set up the ATPX handle */
-	return radeon_atpx_verify_interface(&radeon_atpx_priv.atpx);
+	r = radeon_atpx_verify_interface(&radeon_atpx_priv.atpx);
+	if (r)
+		return r;
+
+	/* validate the atpx setup */
+	r = radeon_atpx_validate(&radeon_atpx_priv.atpx);
+	if (r)
+		return r;
+
+	return 0;
 }
 
 /**

commit dfdcbebc548ff14fd1a7029c95d060e0dd466469
Author: Igor Murzov <e-mail@date.by>
Date:   Thu Oct 25 17:09:00 2012 +0400

    drm/radeon: fix ATPX function documentation
    
    Fix a copy&pasted documentation.
    
    Signed-off-by: Igor Murzov <e-mail@date.by>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 37f6a907aea4..15f5ded65e0c 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -352,9 +352,9 @@ static int radeon_atpx_switchto(enum vga_switcheroo_client_id id)
 }
 
 /**
- * radeon_atpx_switchto - switch to the requested GPU
+ * radeon_atpx_power_state - power down/up the requested GPU
  *
- * @id: GPU to switch to
+ * @id: GPU to power down/up
  * @state: requested power state (0 = off, 1 = on)
  *
  * Execute the necessary ATPX function to power down/up the discrete GPU

commit 0b90365e7a32317b948583c4b5c2712d84610b08
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Oct 23 17:57:54 2012 -0400

    drm/radeon: fix ATPX regression in acpi rework
    
    Copy and paste typo in the apci rework.
    
    Fixes:
    https://bugzilla.kernel.org/show_bug.cgi?id=49351
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Jerome Glisse <jglisse@redhat.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 5c5e5bb00f56..37f6a907aea4 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -87,7 +87,7 @@ static union acpi_object *radeon_atpx_call(acpi_handle handle, int function,
 		atpx_arg_elements[1].integer.value = 0;
 	}
 
-	status = acpi_evaluate_object(handle, "ATPX", &atpx_arg, &buffer);
+	status = acpi_evaluate_object(handle, NULL, &atpx_arg, &buffer);
 
 	/* Fail only if calling the method fails and ATPX is supported */
 	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {

commit c9bd773c6dd4a52f32e64af5dbbf9b3834f8569a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Oct 23 12:42:42 2012 -0400

    drm/radeon: fix ATPX function documentation
    
    The ATPX code no longer handles ATRM.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 1aa3f910b993..5c5e5bb00f56 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -373,11 +373,11 @@ static int radeon_atpx_power_state(enum vga_switcheroo_client_id id,
 }
 
 /**
- * radeon_atpx_pci_probe_handle - look up the ATRM and ATPX handles
+ * radeon_atpx_pci_probe_handle - look up the ATPX handle
  *
  * @pdev: pci device
  *
- * Look up the ATPX and ATRM handles (all asics).
+ * Look up the ATPX handles (all asics).
  * Returns true if the handles are found, false if not.
  */
 static bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)

commit bd6126bd0766cb0e03a4d832cc3611dff5ea8e50
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Tue Oct 16 10:15:45 2012 +1000

    drm: radeon: fix printk format warning
    
    drivers/gpu/drm/radeon/radeon_atpx_handler.c:151:3: warning: format '%lu' expects type 'long unsigned int', but argument 2 has type 'size_t'
    
    [airlied: Alex had others fixed already, except for atpx one]
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 582e99449c12..1aa3f910b993 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -148,7 +148,7 @@ static int radeon_atpx_verify_interface(struct radeon_atpx *atpx)
 
 	size = *(u16 *) info->buffer.pointer;
 	if (size < 8) {
-		printk("ATPX buffer is too small: %lu\n", size);
+		printk("ATPX buffer is too small: %zu\n", size);
 		err = -EINVAL;
 		goto out;
 	}

commit 82e029357d4726bbfb31b4169f82dcaea5fa3eba
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Aug 16 14:09:21 2012 -0400

    drm/radeon: document radeon_atpx_handler.c (v2)
    
    v2: rebase updates
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 331db7a95f09..582e99449c12 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -166,6 +166,16 @@ static int radeon_atpx_verify_interface(struct radeon_atpx *atpx)
 	return err;
 }
 
+/**
+ * radeon_atpx_set_discrete_state - power up/down discrete GPU
+ *
+ * @atpx: atpx info struct
+ * @state: discrete GPU state (0 = power down, 1 = power up)
+ *
+ * Execute the ATPX_FUNCTION_POWER_CONTROL ATPX function to
+ * power down/up the discrete GPU (all asics).
+ * Returns 0 on success, error on failure.
+ */
 static int radeon_atpx_set_discrete_state(struct radeon_atpx *atpx, u8 state)
 {
 	struct acpi_buffer params;
@@ -187,6 +197,17 @@ static int radeon_atpx_set_discrete_state(struct radeon_atpx *atpx, u8 state)
 	return 0;
 }
 
+/**
+ * radeon_atpx_switch_disp_mux - switch display mux
+ *
+ * @atpx: atpx info struct
+ * @mux_id: mux state (0 = integrated GPU, 1 = discrete GPU)
+ *
+ * Execute the ATPX_FUNCTION_DISPLAY_MUX_CONTROL ATPX function to
+ * switch the display mux between the discrete GPU and integrated GPU
+ * (all asics).
+ * Returns 0 on success, error on failure.
+ */
 static int radeon_atpx_switch_disp_mux(struct radeon_atpx *atpx, u16 mux_id)
 {
 	struct acpi_buffer params;
@@ -208,6 +229,17 @@ static int radeon_atpx_switch_disp_mux(struct radeon_atpx *atpx, u16 mux_id)
 	return 0;
 }
 
+/**
+ * radeon_atpx_switch_i2c_mux - switch i2c/hpd mux
+ *
+ * @atpx: atpx info struct
+ * @mux_id: mux state (0 = integrated GPU, 1 = discrete GPU)
+ *
+ * Execute the ATPX_FUNCTION_I2C_MUX_CONTROL ATPX function to
+ * switch the i2c/hpd mux between the discrete GPU and integrated GPU
+ * (all asics).
+ * Returns 0 on success, error on failure.
+ */
 static int radeon_atpx_switch_i2c_mux(struct radeon_atpx *atpx, u16 mux_id)
 {
 	struct acpi_buffer params;
@@ -229,6 +261,17 @@ static int radeon_atpx_switch_i2c_mux(struct radeon_atpx *atpx, u16 mux_id)
 	return 0;
 }
 
+/**
+ * radeon_atpx_switch_start - notify the sbios of a GPU switch
+ *
+ * @atpx: atpx info struct
+ * @mux_id: mux state (0 = integrated GPU, 1 = discrete GPU)
+ *
+ * Execute the ATPX_FUNCTION_GRAPHICS_DEVICE_SWITCH_START_NOTIFICATION ATPX
+ * function to notify the sbios that a switch between the discrete GPU and
+ * integrated GPU has begun (all asics).
+ * Returns 0 on success, error on failure.
+ */
 static int radeon_atpx_switch_start(struct radeon_atpx *atpx, u16 mux_id)
 {
 	struct acpi_buffer params;
@@ -250,6 +293,17 @@ static int radeon_atpx_switch_start(struct radeon_atpx *atpx, u16 mux_id)
 	return 0;
 }
 
+/**
+ * radeon_atpx_switch_end - notify the sbios of a GPU switch
+ *
+ * @atpx: atpx info struct
+ * @mux_id: mux state (0 = integrated GPU, 1 = discrete GPU)
+ *
+ * Execute the ATPX_FUNCTION_GRAPHICS_DEVICE_SWITCH_END_NOTIFICATION ATPX
+ * function to notify the sbios that a switch between the discrete GPU and
+ * integrated GPU has ended (all asics).
+ * Returns 0 on success, error on failure.
+ */
 static int radeon_atpx_switch_end(struct radeon_atpx *atpx, u16 mux_id)
 {
 	struct acpi_buffer params;
@@ -271,6 +325,15 @@ static int radeon_atpx_switch_end(struct radeon_atpx *atpx, u16 mux_id)
 	return 0;
 }
 
+/**
+ * radeon_atpx_switchto - switch to the requested GPU
+ *
+ * @id: GPU to switch to
+ *
+ * Execute the necessary ATPX functions to switch between the discrete GPU and
+ * integrated GPU (all asics).
+ * Returns 0 on success, error on failure.
+ */
 static int radeon_atpx_switchto(enum vga_switcheroo_client_id id)
 {
 	u16 gpu_id;
@@ -288,6 +351,16 @@ static int radeon_atpx_switchto(enum vga_switcheroo_client_id id)
 	return 0;
 }
 
+/**
+ * radeon_atpx_switchto - switch to the requested GPU
+ *
+ * @id: GPU to switch to
+ * @state: requested power state (0 = off, 1 = on)
+ *
+ * Execute the necessary ATPX function to power down/up the discrete GPU
+ * (all asics).
+ * Returns 0 on success, error on failure.
+ */
 static int radeon_atpx_power_state(enum vga_switcheroo_client_id id,
 				   enum vga_switcheroo_state state)
 {
@@ -299,6 +372,14 @@ static int radeon_atpx_power_state(enum vga_switcheroo_client_id id,
 	return 0;
 }
 
+/**
+ * radeon_atpx_pci_probe_handle - look up the ATRM and ATPX handles
+ *
+ * @pdev: pci device
+ *
+ * Look up the ATPX and ATRM handles (all asics).
+ * Returns true if the handles are found, false if not.
+ */
 static bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)
 {
 	acpi_handle dhandle, atpx_handle;
@@ -317,12 +398,26 @@ static bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)
 	return true;
 }
 
+/**
+ * radeon_atpx_init - verify the ATPX interface
+ *
+ * Verify the ATPX interface (all asics).
+ * Returns 0 on success, error on failure.
+ */
 static int radeon_atpx_init(void)
 {
 	/* set up the ATPX handle */
 	return radeon_atpx_verify_interface(&radeon_atpx_priv.atpx);
 }
 
+/**
+ * radeon_atpx_get_client_id - get the client id
+ *
+ * @pdev: pci device
+ *
+ * look up whether we are the integrated or discrete GPU (all asics).
+ * Returns the client id.
+ */
 static int radeon_atpx_get_client_id(struct pci_dev *pdev)
 {
 	if (radeon_atpx_priv.dhandle == DEVICE_ACPI_HANDLE(&pdev->dev))
@@ -338,6 +433,12 @@ static struct vga_switcheroo_handler radeon_atpx_handler = {
 	.get_client_id = radeon_atpx_get_client_id,
 };
 
+/**
+ * radeon_atpx_detect - detect whether we have PX
+ *
+ * Check if we have a PX system (all asics).
+ * Returns true if we have a PX system, false if not.
+ */
 static bool radeon_atpx_detect(void)
 {
 	char acpi_method_name[255] = { 0 };
@@ -362,6 +463,11 @@ static bool radeon_atpx_detect(void)
 	return false;
 }
 
+/**
+ * radeon_register_atpx_handler - register with vga_switcheroo
+ *
+ * Register the PX callbacks with vga_switcheroo (all asics).
+ */
 void radeon_register_atpx_handler(void)
 {
 	bool r;
@@ -374,6 +480,11 @@ void radeon_register_atpx_handler(void)
 	vga_switcheroo_register_handler(&radeon_atpx_handler);
 }
 
+/**
+ * radeon_unregister_atpx_handler - unregister with vga_switcheroo
+ *
+ * Unregister the PX callbacks with vga_switcheroo (all asics).
+ */
 void radeon_unregister_atpx_handler(void)
 {
 	vga_switcheroo_unregister_handler();

commit 492b49a2f21a7ce6cb0abce36017daa06036a626
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Aug 16 14:07:37 2012 -0400

    drm/radeon: reorganize ATPX support (v2)
    
    - rework the acpi execute code
    - User proper parameters for ATPX functions
    
    v2: rebase fixes
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index c1f2671a7b0b..331db7a95f09 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -26,6 +26,7 @@ struct radeon_atpx_functions {
 };
 
 struct radeon_atpx {
+	acpi_handle handle;
 	struct radeon_atpx_functions functions;
 };
 
@@ -33,7 +34,6 @@ static struct radeon_atpx_priv {
 	bool atpx_detected;
 	/* handle for device - and atpx */
 	acpi_handle dhandle;
-	acpi_handle atpx_handle;
 	struct radeon_atpx atpx;
 } radeon_atpx_priv;
 
@@ -43,6 +43,16 @@ struct atpx_verify_interface {
 	u32 function_bits;	/* supported functions bit vector */
 } __packed;
 
+struct atpx_power_control {
+	u16 size;
+	u8 dgpu_state;
+} __packed;
+
+struct atpx_mux {
+	u16 size;
+	u16 mux;
+} __packed;
+
 /**
  * radeon_atpx_call - call an ATPX method
  *
@@ -123,15 +133,14 @@ static void radeon_atpx_parse_functions(struct radeon_atpx_functions *f, u32 mas
  * (all asics).
  * returns 0 on success, error on failure.
  */
-static int radeon_atpx_verify_interface(acpi_handle handle,
-					struct radeon_atpx *atpx)
+static int radeon_atpx_verify_interface(struct radeon_atpx *atpx)
 {
 	union acpi_object *info;
 	struct atpx_verify_interface output;
 	size_t size;
 	int err = 0;
 
-	info = radeon_atpx_call(handle, ATPX_FUNCTION_VERIFY_INTERFACE, NULL);
+	info = radeon_atpx_call(atpx->handle, ATPX_FUNCTION_VERIFY_INTERFACE, NULL);
 	if (!info)
 		return -EIO;
 
@@ -157,82 +166,124 @@ static int radeon_atpx_verify_interface(acpi_handle handle,
 	return err;
 }
 
-static int radeon_atpx_execute(acpi_handle handle, int cmd_id, u16 value)
+static int radeon_atpx_set_discrete_state(struct radeon_atpx *atpx, u8 state)
 {
-	acpi_status status;
-	union acpi_object atpx_arg_elements[2];
-	struct acpi_object_list atpx_arg;
-	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
-	uint8_t buf[4] = {0};
-
-	if (!handle)
-		return -EINVAL;
-
-	atpx_arg.count = 2;
-	atpx_arg.pointer = &atpx_arg_elements[0];
-
-	atpx_arg_elements[0].type = ACPI_TYPE_INTEGER;
-	atpx_arg_elements[0].integer.value = cmd_id;
-
-	buf[2] = value & 0xff;
-	buf[3] = (value >> 8) & 0xff;
-
-	atpx_arg_elements[1].type = ACPI_TYPE_BUFFER;
-	atpx_arg_elements[1].buffer.length = 4;
-	atpx_arg_elements[1].buffer.pointer = buf;
-
-	status = acpi_evaluate_object(handle, NULL, &atpx_arg, &buffer);
-	if (ACPI_FAILURE(status)) {
-		printk("%s: failed to call ATPX: %s\n", __func__, acpi_format_exception(status));
-		return -ENOSYS;
+	struct acpi_buffer params;
+	union acpi_object *info;
+	struct atpx_power_control input;
+
+	if (atpx->functions.power_cntl) {
+		input.size = 3;
+		input.dgpu_state = state;
+		params.length = input.size;
+		params.pointer = &input;
+		info = radeon_atpx_call(atpx->handle,
+					ATPX_FUNCTION_POWER_CONTROL,
+					&params);
+		if (!info)
+			return -EIO;
+		kfree(info);
 	}
-	kfree(buffer.pointer);
-
 	return 0;
 }
 
-static int radeon_atpx_set_discrete_state(acpi_handle handle, int state)
-{
-	return radeon_atpx_execute(handle, ATPX_FUNCTION_POWER_CONTROL, state);
-}
-
-static int radeon_atpx_switch_mux(acpi_handle handle, int mux_id)
+static int radeon_atpx_switch_disp_mux(struct radeon_atpx *atpx, u16 mux_id)
 {
-	return radeon_atpx_execute(handle, ATPX_FUNCTION_DISPLAY_MUX_CONTROL, mux_id);
+	struct acpi_buffer params;
+	union acpi_object *info;
+	struct atpx_mux input;
+
+	if (atpx->functions.disp_mux_cntl) {
+		input.size = 4;
+		input.mux = mux_id;
+		params.length = input.size;
+		params.pointer = &input;
+		info = radeon_atpx_call(atpx->handle,
+					ATPX_FUNCTION_DISPLAY_MUX_CONTROL,
+					&params);
+		if (!info)
+			return -EIO;
+		kfree(info);
+	}
+	return 0;
 }
 
-static int radeon_atpx_switch_i2c_mux(acpi_handle handle, int mux_id)
+static int radeon_atpx_switch_i2c_mux(struct radeon_atpx *atpx, u16 mux_id)
 {
-	return radeon_atpx_execute(handle, ATPX_FUNCTION_I2C_MUX_CONTROL, mux_id);
+	struct acpi_buffer params;
+	union acpi_object *info;
+	struct atpx_mux input;
+
+	if (atpx->functions.i2c_mux_cntl) {
+		input.size = 4;
+		input.mux = mux_id;
+		params.length = input.size;
+		params.pointer = &input;
+		info = radeon_atpx_call(atpx->handle,
+					ATPX_FUNCTION_I2C_MUX_CONTROL,
+					&params);
+		if (!info)
+			return -EIO;
+		kfree(info);
+	}
+	return 0;
 }
 
-static int radeon_atpx_switch_start(acpi_handle handle, int gpu_id)
+static int radeon_atpx_switch_start(struct radeon_atpx *atpx, u16 mux_id)
 {
-	return radeon_atpx_execute(handle,
-				   ATPX_FUNCTION_GRAPHICS_DEVICE_SWITCH_START_NOTIFICATION,
-				   gpu_id);
+	struct acpi_buffer params;
+	union acpi_object *info;
+	struct atpx_mux input;
+
+	if (atpx->functions.switch_start) {
+		input.size = 4;
+		input.mux = mux_id;
+		params.length = input.size;
+		params.pointer = &input;
+		info = radeon_atpx_call(atpx->handle,
+					ATPX_FUNCTION_GRAPHICS_DEVICE_SWITCH_START_NOTIFICATION,
+					&params);
+		if (!info)
+			return -EIO;
+		kfree(info);
+	}
+	return 0;
 }
 
-static int radeon_atpx_switch_end(acpi_handle handle, int gpu_id)
+static int radeon_atpx_switch_end(struct radeon_atpx *atpx, u16 mux_id)
 {
-	return radeon_atpx_execute(handle,
-				   ATPX_FUNCTION_GRAPHICS_DEVICE_SWITCH_END_NOTIFICATION,
-				   gpu_id);
+	struct acpi_buffer params;
+	union acpi_object *info;
+	struct atpx_mux input;
+
+	if (atpx->functions.switch_end) {
+		input.size = 4;
+		input.mux = mux_id;
+		params.length = input.size;
+		params.pointer = &input;
+		info = radeon_atpx_call(atpx->handle,
+					ATPX_FUNCTION_GRAPHICS_DEVICE_SWITCH_END_NOTIFICATION,
+					&params);
+		if (!info)
+			return -EIO;
+		kfree(info);
+	}
+	return 0;
 }
 
 static int radeon_atpx_switchto(enum vga_switcheroo_client_id id)
 {
-	int gpu_id;
+	u16 gpu_id;
 
 	if (id == VGA_SWITCHEROO_IGD)
 		gpu_id = ATPX_INTEGRATED_GPU;
 	else
 		gpu_id = ATPX_DISCRETE_GPU;
 
-	radeon_atpx_switch_start(radeon_atpx_priv.atpx_handle, gpu_id);
-	radeon_atpx_switch_mux(radeon_atpx_priv.atpx_handle, gpu_id);
-	radeon_atpx_switch_i2c_mux(radeon_atpx_priv.atpx_handle, gpu_id);
-	radeon_atpx_switch_end(radeon_atpx_priv.atpx_handle, gpu_id);
+	radeon_atpx_switch_start(&radeon_atpx_priv.atpx, gpu_id);
+	radeon_atpx_switch_disp_mux(&radeon_atpx_priv.atpx, gpu_id);
+	radeon_atpx_switch_i2c_mux(&radeon_atpx_priv.atpx, gpu_id);
+	radeon_atpx_switch_end(&radeon_atpx_priv.atpx, gpu_id);
 
 	return 0;
 }
@@ -244,7 +295,7 @@ static int radeon_atpx_power_state(enum vga_switcheroo_client_id id,
 	if (id == VGA_SWITCHEROO_IGD)
 		return 0;
 
-	radeon_atpx_set_discrete_state(radeon_atpx_priv.atpx_handle, state);
+	radeon_atpx_set_discrete_state(&radeon_atpx_priv.atpx, state);
 	return 0;
 }
 
@@ -262,15 +313,14 @@ static bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)
 		return false;
 
 	radeon_atpx_priv.dhandle = dhandle;
-	radeon_atpx_priv.atpx_handle = atpx_handle;
+	radeon_atpx_priv.atpx.handle = atpx_handle;
 	return true;
 }
 
 static int radeon_atpx_init(void)
 {
 	/* set up the ATPX handle */
-	return radeon_atpx_verify_interface(radeon_atpx_priv.atpx_handle,
-					    &radeon_atpx_priv.atpx);
+	return radeon_atpx_verify_interface(&radeon_atpx_priv.atpx);
 }
 
 static int radeon_atpx_get_client_id(struct pci_dev *pdev)
@@ -303,7 +353,7 @@ static bool radeon_atpx_detect(void)
 	}
 
 	if (has_atpx && vga_count == 2) {
-		acpi_get_name(radeon_atpx_priv.atpx_handle, ACPI_FULL_PATHNAME, &buffer);
+		acpi_get_name(radeon_atpx_priv.atpx.handle, ACPI_FULL_PATHNAME, &buffer);
 		printk(KERN_INFO "VGA switcheroo: detected switching method %s handle\n",
 		       acpi_method_name);
 		radeon_atpx_priv.atpx_detected = true;

commit 48fa412b7451530322cdbe969e404b798c6e204e
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Aug 16 14:01:57 2012 -0400

    drm/radeon: update ATPX verify interface handling (v2)
    
    Verify the ATPX interface and track what ATPX functions
    are available for future use.
    
    v2: rework due to tree changes
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 950a1ac95d6a..c1f2671a7b0b 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -14,17 +14,50 @@
 
 #include "radeon_acpi.h"
 
+struct radeon_atpx_functions {
+	bool px_params;
+	bool power_cntl;
+	bool disp_mux_cntl;
+	bool i2c_mux_cntl;
+	bool switch_start;
+	bool switch_end;
+	bool disp_connectors_mapping;
+	bool disp_detetion_ports;
+};
+
+struct radeon_atpx {
+	struct radeon_atpx_functions functions;
+};
+
 static struct radeon_atpx_priv {
 	bool atpx_detected;
 	/* handle for device - and atpx */
 	acpi_handle dhandle;
 	acpi_handle atpx_handle;
+	struct radeon_atpx atpx;
 } radeon_atpx_priv;
 
-static int radeon_atpx_get_version(acpi_handle handle)
+struct atpx_verify_interface {
+	u16 size;		/* structure size in bytes (includes size field) */
+	u16 version;		/* version */
+	u32 function_bits;	/* supported functions bit vector */
+} __packed;
+
+/**
+ * radeon_atpx_call - call an ATPX method
+ *
+ * @handle: acpi handle
+ * @function: the ATPX function to execute
+ * @params: ATPX function params
+ *
+ * Executes the requested ATPX function (all asics).
+ * Returns a pointer to the acpi output buffer.
+ */
+static union acpi_object *radeon_atpx_call(acpi_handle handle, int function,
+					   struct acpi_buffer *params)
 {
 	acpi_status status;
-	union acpi_object atpx_arg_elements[2], *obj;
+	union acpi_object atpx_arg_elements[2];
 	struct acpi_object_list atpx_arg;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 
@@ -32,21 +65,96 @@ static int radeon_atpx_get_version(acpi_handle handle)
 	atpx_arg.pointer = &atpx_arg_elements[0];
 
 	atpx_arg_elements[0].type = ACPI_TYPE_INTEGER;
-	atpx_arg_elements[0].integer.value = ATPX_FUNCTION_VERIFY_INTERFACE;
+	atpx_arg_elements[0].integer.value = function;
+
+	if (params) {
+		atpx_arg_elements[1].type = ACPI_TYPE_BUFFER;
+		atpx_arg_elements[1].buffer.length = params->length;
+		atpx_arg_elements[1].buffer.pointer = params->pointer;
+	} else {
+		/* We need a second fake parameter */
+		atpx_arg_elements[1].type = ACPI_TYPE_INTEGER;
+		atpx_arg_elements[1].integer.value = 0;
+	}
 
-	atpx_arg_elements[1].type = ACPI_TYPE_INTEGER;
-	atpx_arg_elements[1].integer.value = 0;
+	status = acpi_evaluate_object(handle, "ATPX", &atpx_arg, &buffer);
 
-	status = acpi_evaluate_object(handle, NULL, &atpx_arg, &buffer);
-	if (ACPI_FAILURE(status)) {
-		printk("%s: failed to call ATPX: %s\n", __func__, acpi_format_exception(status));
-		return -ENOSYS;
+	/* Fail only if calling the method fails and ATPX is supported */
+	if (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {
+		printk("failed to evaluate ATPX got %s\n",
+		       acpi_format_exception(status));
+		kfree(buffer.pointer);
+		return NULL;
 	}
-	obj = (union acpi_object *)buffer.pointer;
-	if (obj && (obj->type == ACPI_TYPE_BUFFER))
-		printk(KERN_INFO "radeon atpx: version is %d\n", *((u8 *)(obj->buffer.pointer) + 2));
-	kfree(buffer.pointer);
-	return 0;
+
+	return buffer.pointer;
+}
+
+/**
+ * radeon_atpx_parse_functions - parse supported functions
+ *
+ * @f: supported functions struct
+ * @mask: supported functions mask from ATPX
+ *
+ * Use the supported functions mask from ATPX function
+ * ATPX_FUNCTION_VERIFY_INTERFACE to determine what functions
+ * are supported (all asics).
+ */
+static void radeon_atpx_parse_functions(struct radeon_atpx_functions *f, u32 mask)
+{
+	f->px_params = mask & ATPX_GET_PX_PARAMETERS_SUPPORTED;
+	f->power_cntl = mask & ATPX_POWER_CONTROL_SUPPORTED;
+	f->disp_mux_cntl = mask & ATPX_DISPLAY_MUX_CONTROL_SUPPORTED;
+	f->i2c_mux_cntl = mask & ATPX_I2C_MUX_CONTROL_SUPPORTED;
+	f->switch_start = mask & ATPX_GRAPHICS_DEVICE_SWITCH_START_NOTIFICATION_SUPPORTED;
+	f->switch_end = mask & ATPX_GRAPHICS_DEVICE_SWITCH_END_NOTIFICATION_SUPPORTED;
+	f->disp_connectors_mapping = mask & ATPX_GET_DISPLAY_CONNECTORS_MAPPING_SUPPORTED;
+	f->disp_detetion_ports = mask & ATPX_GET_DISPLAY_DETECTION_PORTS_SUPPORTED;
+}
+
+/**
+ * radeon_atpx_verify_interface - verify ATPX
+ *
+ * @handle: acpi handle
+ * @atpx: radeon atpx struct
+ *
+ * Execute the ATPX_FUNCTION_VERIFY_INTERFACE ATPX function
+ * to initialize ATPX and determine what features are supported
+ * (all asics).
+ * returns 0 on success, error on failure.
+ */
+static int radeon_atpx_verify_interface(acpi_handle handle,
+					struct radeon_atpx *atpx)
+{
+	union acpi_object *info;
+	struct atpx_verify_interface output;
+	size_t size;
+	int err = 0;
+
+	info = radeon_atpx_call(handle, ATPX_FUNCTION_VERIFY_INTERFACE, NULL);
+	if (!info)
+		return -EIO;
+
+	memset(&output, 0, sizeof(output));
+
+	size = *(u16 *) info->buffer.pointer;
+	if (size < 8) {
+		printk("ATPX buffer is too small: %lu\n", size);
+		err = -EINVAL;
+		goto out;
+	}
+	size = min(sizeof(output), size);
+
+	memcpy(&output, info->buffer.pointer, size);
+
+	/* TODO: check version? */
+	printk("ATPX version %u\n", output.version);
+
+	radeon_atpx_parse_functions(&atpx->functions, output.function_bits);
+
+out:
+	kfree(info);
+	return err;
 }
 
 static int radeon_atpx_execute(acpi_handle handle, int cmd_id, u16 value)
@@ -161,9 +269,8 @@ static bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)
 static int radeon_atpx_init(void)
 {
 	/* set up the ATPX handle */
-
-	radeon_atpx_get_version(radeon_atpx_priv.atpx_handle);
-	return 0;
+	return radeon_atpx_verify_interface(radeon_atpx_priv.atpx_handle,
+					    &radeon_atpx_priv.atpx);
 }
 
 static int radeon_atpx_get_client_id(struct pci_dev *pdev)

commit 9e05b2f49eb9484e857e9b6c70dea3bbbe564290
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Jul 18 13:28:52 2012 -0400

    drm/radeon: add new AMD ACPI header and update relevant code (v2)
    
    Add a new header that defines the AMD ACPI interface used
    for laptops, PowerXpress, and chipset specific functionality
    and update the current code to use it.
    
    Todo:
    - properly verify the ACPI interfaces
    - hook up and handle ACPI notifications
    - make PX code more robust
    - implement PCIe Gen and width switching using ACPI
    
    v2: fix typo in header
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 2a2cf0b88a28..950a1ac95d6a 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -12,18 +12,7 @@
 #include <acpi/acpi_bus.h>
 #include <linux/pci.h>
 
-#define ATPX_VERSION 0
-#define ATPX_GPU_PWR 2
-#define ATPX_MUX_SELECT 3
-#define ATPX_I2C_MUX_SELECT 4
-#define ATPX_SWITCH_START 5
-#define ATPX_SWITCH_END 6
-
-#define ATPX_INTEGRATED 0
-#define ATPX_DISCRETE 1
-
-#define ATPX_MUX_IGD 0
-#define ATPX_MUX_DISCRETE 1
+#include "radeon_acpi.h"
 
 static struct radeon_atpx_priv {
 	bool atpx_detected;
@@ -43,10 +32,10 @@ static int radeon_atpx_get_version(acpi_handle handle)
 	atpx_arg.pointer = &atpx_arg_elements[0];
 
 	atpx_arg_elements[0].type = ACPI_TYPE_INTEGER;
-	atpx_arg_elements[0].integer.value = ATPX_VERSION;
+	atpx_arg_elements[0].integer.value = ATPX_FUNCTION_VERIFY_INTERFACE;
 
 	atpx_arg_elements[1].type = ACPI_TYPE_INTEGER;
-	atpx_arg_elements[1].integer.value = ATPX_VERSION;
+	atpx_arg_elements[1].integer.value = 0;
 
 	status = acpi_evaluate_object(handle, NULL, &atpx_arg, &buffer);
 	if (ACPI_FAILURE(status)) {
@@ -96,27 +85,31 @@ static int radeon_atpx_execute(acpi_handle handle, int cmd_id, u16 value)
 
 static int radeon_atpx_set_discrete_state(acpi_handle handle, int state)
 {
-	return radeon_atpx_execute(handle, ATPX_GPU_PWR, state);
+	return radeon_atpx_execute(handle, ATPX_FUNCTION_POWER_CONTROL, state);
 }
 
 static int radeon_atpx_switch_mux(acpi_handle handle, int mux_id)
 {
-	return radeon_atpx_execute(handle, ATPX_MUX_SELECT, mux_id);
+	return radeon_atpx_execute(handle, ATPX_FUNCTION_DISPLAY_MUX_CONTROL, mux_id);
 }
 
 static int radeon_atpx_switch_i2c_mux(acpi_handle handle, int mux_id)
 {
-	return radeon_atpx_execute(handle, ATPX_I2C_MUX_SELECT, mux_id);
+	return radeon_atpx_execute(handle, ATPX_FUNCTION_I2C_MUX_CONTROL, mux_id);
 }
 
 static int radeon_atpx_switch_start(acpi_handle handle, int gpu_id)
 {
-	return radeon_atpx_execute(handle, ATPX_SWITCH_START, gpu_id);
+	return radeon_atpx_execute(handle,
+				   ATPX_FUNCTION_GRAPHICS_DEVICE_SWITCH_START_NOTIFICATION,
+				   gpu_id);
 }
 
 static int radeon_atpx_switch_end(acpi_handle handle, int gpu_id)
 {
-	return radeon_atpx_execute(handle, ATPX_SWITCH_END, gpu_id);
+	return radeon_atpx_execute(handle,
+				   ATPX_FUNCTION_GRAPHICS_DEVICE_SWITCH_END_NOTIFICATION,
+				   gpu_id);
 }
 
 static int radeon_atpx_switchto(enum vga_switcheroo_client_id id)
@@ -124,9 +117,9 @@ static int radeon_atpx_switchto(enum vga_switcheroo_client_id id)
 	int gpu_id;
 
 	if (id == VGA_SWITCHEROO_IGD)
-		gpu_id = ATPX_INTEGRATED;
+		gpu_id = ATPX_INTEGRATED_GPU;
 	else
-		gpu_id = ATPX_DISCRETE;
+		gpu_id = ATPX_DISCRETE_GPU;
 
 	radeon_atpx_switch_start(radeon_atpx_priv.atpx_handle, gpu_id);
 	radeon_atpx_switch_mux(radeon_atpx_priv.atpx_handle, gpu_id);

commit c61e2775873f603148e8e998a938721b7d222d24
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Aug 16 15:39:09 2012 -0400

    drm/radeon: split ATRM support out from the ATPX handler (v3)
    
    There are systems that use ATRM, but not ATPX.
    
    Fixes:
    https://bugs.freedesktop.org/show_bug.cgi?id=41265
    
    V2: fix #ifdefs as per Greg's comments
    V3: fix it harder
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 98724fcb0088..2a2cf0b88a28 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -30,57 +30,8 @@ static struct radeon_atpx_priv {
 	/* handle for device - and atpx */
 	acpi_handle dhandle;
 	acpi_handle atpx_handle;
-	acpi_handle atrm_handle;
 } radeon_atpx_priv;
 
-/* retrieve the ROM in 4k blocks */
-static int radeon_atrm_call(acpi_handle atrm_handle, uint8_t *bios,
-			    int offset, int len)
-{
-	acpi_status status;
-	union acpi_object atrm_arg_elements[2], *obj;
-	struct acpi_object_list atrm_arg;
-	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL};
-
-	atrm_arg.count = 2;
-	atrm_arg.pointer = &atrm_arg_elements[0];
-
-	atrm_arg_elements[0].type = ACPI_TYPE_INTEGER;
-	atrm_arg_elements[0].integer.value = offset;
-
-	atrm_arg_elements[1].type = ACPI_TYPE_INTEGER;
-	atrm_arg_elements[1].integer.value = len;
-
-	status = acpi_evaluate_object(atrm_handle, NULL, &atrm_arg, &buffer);
-	if (ACPI_FAILURE(status)) {
-		printk("failed to evaluate ATRM got %s\n", acpi_format_exception(status));
-		return -ENODEV;
-	}
-
-	obj = (union acpi_object *)buffer.pointer;
-	memcpy(bios+offset, obj->buffer.pointer, obj->buffer.length);
-	len = obj->buffer.length;
-	kfree(buffer.pointer);
-	return len;
-}
-
-bool radeon_atrm_supported(struct pci_dev *pdev)
-{
-	/* get the discrete ROM only via ATRM */
-	if (!radeon_atpx_priv.atpx_detected)
-		return false;
-
-	if (radeon_atpx_priv.dhandle == DEVICE_ACPI_HANDLE(&pdev->dev))
-		return false;
-	return true;
-}
-
-
-int radeon_atrm_get_bios_chunk(uint8_t *bios, int offset, int len)
-{
-	return radeon_atrm_call(radeon_atpx_priv.atrm_handle, bios, offset, len);
-}
-
 static int radeon_atpx_get_version(acpi_handle handle)
 {
 	acpi_status status;
@@ -198,7 +149,7 @@ static int radeon_atpx_power_state(enum vga_switcheroo_client_id id,
 
 static bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)
 {
-	acpi_handle dhandle, atpx_handle, atrm_handle;
+	acpi_handle dhandle, atpx_handle;
 	acpi_status status;
 
 	dhandle = DEVICE_ACPI_HANDLE(&pdev->dev);
@@ -209,13 +160,8 @@ static bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)
 	if (ACPI_FAILURE(status))
 		return false;
 
-	status = acpi_get_handle(dhandle, "ATRM", &atrm_handle);
-	if (ACPI_FAILURE(status))
-		return false;
-
 	radeon_atpx_priv.dhandle = dhandle;
 	radeon_atpx_priv.atpx_handle = atpx_handle;
-	radeon_atpx_priv.atrm_handle = atrm_handle;
 	return true;
 }
 

commit de47a9cd62771e3e78954d855d2304fbad4c5a44
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Feb 2 15:25:16 2012 +0000

    drm/radeon: fix use after free in ATRM bios reading code.
    
    Fixes:
    https://bugs.freedesktop.org/show_bug.cgi?id=45503
    
    Reported-and-Debugged-by: mlambda@gmail.com
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 13ac63ba6075..98724fcb0088 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -59,8 +59,9 @@ static int radeon_atrm_call(acpi_handle atrm_handle, uint8_t *bios,
 
 	obj = (union acpi_object *)buffer.pointer;
 	memcpy(bios+offset, obj->buffer.pointer, obj->buffer.length);
+	len = obj->buffer.length;
 	kfree(buffer.pointer);
-	return obj->buffer.length;
+	return len;
 }
 
 bool radeon_atrm_supported(struct pci_dev *pdev)

commit 211fa4fc4e13492151e698d92b0dff56b29928ec
Author: Igor Murzov <intergalactic.anonymous@gmail.com>
Date:   Sun Jan 22 18:47:28 2012 +0400

    drm/radeon: finish getting bios earlier
    
    Return a number of bytes read in radeon_atrm_get_bios_chunk() and
    properly check this value in radeon_atrm_get_bios().
    If radeon_atrm_get_bios_chunk() read less bytes then were requested,
    it means that it finished reading bios data.
    
    Prior to this patch, condition in radeon_atrm_get_bios() was always
    equivalent to "if (ATRM_BIOS_PAGE <= 0)", so it was always false,
    thus radeon_atrm_get_bios() was trying to read past the bios data
    wasting boot time.
    
    On my lenovo ideapad u455 laptop this patch drops bios reading time
    from ~5.5s to ~1.5s.
    
    Signed-off-by: Igor Murzov <e-mail@date.by>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index c666a5b5e505..13ac63ba6075 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -60,7 +60,7 @@ static int radeon_atrm_call(acpi_handle atrm_handle, uint8_t *bios,
 	obj = (union acpi_object *)buffer.pointer;
 	memcpy(bios+offset, obj->buffer.pointer, obj->buffer.length);
 	kfree(buffer.pointer);
-	return len;
+	return obj->buffer.length;
 }
 
 bool radeon_atrm_supported(struct pci_dev *pdev)

commit a3f83ab1a717c0e6c2f59a4cfdaa10707cc35c55
Author: Igor Murzov <intergalactic.anonymous@gmail.com>
Date:   Sun Jan 22 18:43:25 2012 +0400

    drm/radeon: fix invalid memory access in radeon_atrm_get_bios()
    
    At a boot time I observed following bug:
    
     BUG: unable to handle kernel paging request at ffff8800a4244000
     IP: [<ffffffff81275b5b>] memcpy+0xb/0x120
     PGD 1816063 PUD 1fe7d067 PMD 1ff9f067 PTE 80000000a4244160
     Oops: 0000 [#1] SMP DEBUG_PAGEALLOC
     CPU 0
     Modules linked in: btusb bluetooth brcmsmac brcmutil crc8 cordic b43 radeon(+)
      mac80211 cfg80211 ttm ohci_hcd drm_kms_helper rfkill drm ssb agpgart mmc_core
      sp5100_tco video battery ac thermal processor rtc_cmos thermal_sys snd_hda_codec_hdmi
      joydev snd_hda_codec_conexant button bcma pcmcia snd_hda_intel snd_hda_codec
      snd_hwdep snd_pcm shpchp pcmcia_core k8temp snd_timer atl1c snd psmouse hwmon
      i2c_piix4 i2c_algo_bit soundcore evdev i2c_core ehci_hcd sg serio_raw snd_page_alloc
      loop btrfs
    
     Pid: 1008, comm: modprobe Not tainted 3.3.0-rc1 #21 LENOVO 20046                           /AMD CRB
     RIP: 0010:[<ffffffff81275b5b>]  [<ffffffff81275b5b>] memcpy+0xb/0x120
     RSP: 0018:ffff8800aa72db00  EFLAGS: 00010246
     RAX: ffff8800a4150000 RBX: 0000000000001000 RCX: 0000000000000087
     RDX: 0000000000000000 RSI: ffff8800a4244000 RDI: ffff8800a4150bc8
     RBP: ffff8800aa72db78 R08: 0000000000000010 R09: ffffffff8174bbec
     R10: ffffffff812ee010 R11: 0000000000000001 R12: 0000000000001000
     R13: 0000000000010000 R14: ffff8800a4140000 R15: ffff8800aaba1800
     FS:  00007ff9a3bd4720(0000) GS:ffff8800afa00000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
     CR2: ffff8800a4244000 CR3: 00000000a9c18000 CR4: 00000000000006f0
     DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
     DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
     Process modprobe (pid: 1008, threadinfo ffff8800aa72c000, task ffff8800aa0e4000)
     Stack:
      ffffffffa04e7c7b 0000000000000001 0000000000010000 ffff8800aa72db28
      ffffffff00000001 0000000000001000 ffffffff8113cbef 0000000000000020
      ffff8800a4243420 ffff880000000002 ffff8800aa72db08 ffff8800a9d42000
     Call Trace:
      [<ffffffffa04e7c7b>] ? radeon_atrm_get_bios_chunk+0x8b/0xd0 [radeon]
      [<ffffffff8113cbef>] ? kmalloc_order_trace+0x3f/0xb0
      [<ffffffffa04a9298>] radeon_get_bios+0x68/0x2f0 [radeon]
      [<ffffffffa04c7a30>] rv770_init+0x40/0x280 [radeon]
      [<ffffffffa047d740>] radeon_device_init+0x560/0x600 [radeon]
      [<ffffffffa047ef4f>] radeon_driver_load_kms+0xaf/0x170 [radeon]
      [<ffffffffa043cdde>] drm_get_pci_dev+0x18e/0x2c0 [drm]
      [<ffffffffa04e7e95>] radeon_pci_probe+0xad/0xb5 [radeon]
      [<ffffffff81296c5f>] local_pci_probe+0x5f/0xd0
      [<ffffffff81297418>] pci_device_probe+0x88/0xb0
      [<ffffffff813417aa>] ? driver_sysfs_add+0x7a/0xb0
      [<ffffffff813418d8>] really_probe+0x68/0x180
      [<ffffffff81341be5>] driver_probe_device+0x45/0x70
      [<ffffffff81341cb3>] __driver_attach+0xa3/0xb0
      [<ffffffff81341c10>] ? driver_probe_device+0x70/0x70
      [<ffffffff813400ce>] bus_for_each_dev+0x5e/0x90
      [<ffffffff8134172e>] driver_attach+0x1e/0x20
      [<ffffffff81341298>] bus_add_driver+0xc8/0x280
      [<ffffffff813422c6>] driver_register+0x76/0x140
      [<ffffffff812976d6>] __pci_register_driver+0x66/0xe0
      [<ffffffffa043d021>] drm_pci_init+0x111/0x120 [drm]
      [<ffffffff8133c67a>] ? vga_switcheroo_register_handler+0x3a/0x60
      [<ffffffffa0229000>] ? 0xffffffffa0228fff
      [<ffffffffa02290ec>] radeon_init+0xec/0xee [radeon]
      [<ffffffff810002f2>] do_one_initcall+0x42/0x180
      [<ffffffff8109d8d2>] sys_init_module+0x92/0x1e0
      [<ffffffff815407a9>] system_call_fastpath+0x16/0x1b
     Code: 58 2a 43 50 88 43 4e 48 83 c4 08 5b c9 c3 66 90 e8 cb fd ff ff eb
      e6 90 90 90 90 90 90 90 90 90 48 89 f8 89 d1 c1 e9 03 83 e2 07 <f3> 48
      a5 89 d1 f3 a4 c3 20 48 83 ea 20 4c 8b 06 4c 8b 4e 08 4c
     RIP  [<ffffffff81275b5b>] memcpy+0xb/0x120
      RSP <ffff8800aa72db00>
     CR2: ffff8800a4244000
     ---[ end trace fcffa1599cf56382 ]---
    
    Call to acpi_evaluate_object() not always returns 4096 bytes chunks,
    on my system it can return 2048 bytes chunk, so pass the length of
    retrieved chunk to memcpy(), not the length of the recieving buffer.
    
    Signed-off-by: Igor Murzov <e-mail@date.by>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 9d95792bea3e..c666a5b5e505 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -58,7 +58,7 @@ static int radeon_atrm_call(acpi_handle atrm_handle, uint8_t *bios,
 	}
 
 	obj = (union acpi_object *)buffer.pointer;
-	memcpy(bios+offset, obj->buffer.pointer, len);
+	memcpy(bios+offset, obj->buffer.pointer, obj->buffer.length);
 	kfree(buffer.pointer);
 	return len;
 }

commit 58e73811c85d0c0e74b8d300547bbc9abaf40a38
Author: Alex Deucher <alexdeucher@gmail.com>
Date:   Fri May 6 01:42:49 2011 -0400

    drm/radeon/kms: ATPX switcheroo fixes
    
    When we switch the display mux, also switch
    the i2c mux.  Also use the start and finish
    methods to let the sbios know that the switch
    is happening.
    
    Should fix:
    https://bugs.freedesktop.org/show_bug.cgi?id=35398
    
    Signed-off-by: Alex Deucher <alexdeucher@gmail.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index ed5dfe58f29c..9d95792bea3e 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -15,6 +15,9 @@
 #define ATPX_VERSION 0
 #define ATPX_GPU_PWR 2
 #define ATPX_MUX_SELECT 3
+#define ATPX_I2C_MUX_SELECT 4
+#define ATPX_SWITCH_START 5
+#define ATPX_SWITCH_END 6
 
 #define ATPX_INTEGRATED 0
 #define ATPX_DISCRETE 1
@@ -149,13 +152,35 @@ static int radeon_atpx_switch_mux(acpi_handle handle, int mux_id)
 	return radeon_atpx_execute(handle, ATPX_MUX_SELECT, mux_id);
 }
 
+static int radeon_atpx_switch_i2c_mux(acpi_handle handle, int mux_id)
+{
+	return radeon_atpx_execute(handle, ATPX_I2C_MUX_SELECT, mux_id);
+}
+
+static int radeon_atpx_switch_start(acpi_handle handle, int gpu_id)
+{
+	return radeon_atpx_execute(handle, ATPX_SWITCH_START, gpu_id);
+}
+
+static int radeon_atpx_switch_end(acpi_handle handle, int gpu_id)
+{
+	return radeon_atpx_execute(handle, ATPX_SWITCH_END, gpu_id);
+}
 
 static int radeon_atpx_switchto(enum vga_switcheroo_client_id id)
 {
+	int gpu_id;
+
 	if (id == VGA_SWITCHEROO_IGD)
-		radeon_atpx_switch_mux(radeon_atpx_priv.atpx_handle, 0);
+		gpu_id = ATPX_INTEGRATED;
 	else
-		radeon_atpx_switch_mux(radeon_atpx_priv.atpx_handle, 1);
+		gpu_id = ATPX_DISCRETE;
+
+	radeon_atpx_switch_start(radeon_atpx_priv.atpx_handle, gpu_id);
+	radeon_atpx_switch_mux(radeon_atpx_priv.atpx_handle, gpu_id);
+	radeon_atpx_switch_i2c_mux(radeon_atpx_priv.atpx_handle, gpu_id);
+	radeon_atpx_switch_end(radeon_atpx_priv.atpx_handle, gpu_id);
+
 	return 0;
 }
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 3f557c4151e0..ed5dfe58f29c 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -7,6 +7,7 @@
  * ATPX support for both Intel/ATI
  */
 #include <linux/vga_switcheroo.h>
+#include <linux/slab.h>
 #include <acpi/acpi.h>
 #include <acpi/acpi_bus.h>
 #include <linux/pci.h>

commit 8edb381d6705811b278527907a5ae2a9c4db8074
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Mar 1 21:50:01 2010 +1100

    vga_switcheroo: fix build on platforms with no ACPI
    
    radeon was always including the atpx code unnecessarily, also core
    switcheroo was including acpi headers.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 0ae52f19071d..3f557c4151e0 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -6,7 +6,6 @@
  *
  * ATPX support for both Intel/ATI
  */
-
 #include <linux/vga_switcheroo.h>
 #include <acpi/acpi.h>
 #include <acpi/acpi_bus.h>

commit 6a9ee8af344e3bd7dbd61e67037096cdf7f83289
Author: Dave Airlie <airlied@linux.ie>
Date:   Mon Feb 1 15:38:10 2010 +1000

    vga_switcheroo: initial implementation (v15)
    
    Many new laptops now come with 2 gpus, one to be used for low power
    modes and one for gaming/on-ac applications. These GPUs are typically
    wired to the laptop panel and VGA ports via a multiplexer unit which
    is controlled via ACPI methods.
    
    4 combinations of systems typically exist - with 2 ACPI methods.
    Intel/ATI - Lenovo W500/T500 - use ATPX ACPI method
    ATI/ATI - some ASUS - use ATPX ACPI Method
    Intel/Nvidia - - use _DSM ACPI method
    Nvidia/Nvidia -  - use _DSM ACPI method.
    
    TODO:
    This patch adds support for the ATPX method and initial bits
    for the _DSM methods that need to written by someone with
    access to the hardware.
    Add a proper non-debugfs interface - need to get some proper
    testing first.
    
    v2: add power up/down support for both devices
    on W500 puts i915/radeon into D3 and cuts power to radeon.
    
    v3: redo probing methods, no DMI list, drm devices call to
    register with switcheroo, it tries to find an ATPX method on
    any device and once there is two devices + ATPX it inits the
    switcher.
    
    v4: ATPX msg handling using buffers - should work on more machines
    
    v5: rearchitect after more mjg59 discussion - move ATPX handling to
        radeon driver.
    
    v6: add file headers + initial nouveau bits (to be filled out).
    
    v7: merge delayed switcher code.
    
    v8: avoid suspend/resume of gpu that is off
    
    v9: rearchitect - mjg59 is always right. - move all ATPX code to
    radeon, should allow simpler DSM also proper ATRM handling
    
    v10: add ATRM support for radeon BIOS, add mutex to lock vgasr_priv
    
    v11: fix bug in resuming Intel for 2nd time.
    
    v12: start fixing up nvidia code blindly.
    
    v13: blindly guess at finishing nvidia code
    
    v14: remove radeon audio hacks - fix up intel resume more like upstream
    
    v15: clean up printks + remove unnecessary igd/dis pointers
    
    mount debugfs
    
    /sys/kernel/debug/vgaswitcheroo/switch - should exist if ATPX detected
     + 2 cards.
    
    DIS - immediate change to discrete
    IGD - immediate change to IGD
    DDIS - delayed change to discrete
    DIGD - delayed change to IGD
    ON - turn on not in use
    OFF - turn off not in use
    
    Tested on W500 (Intel/ATI) and T500 (Intel/ATI)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
new file mode 100644
index 000000000000..0ae52f19071d
--- /dev/null
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -0,0 +1,258 @@
+/*
+ * Copyright (c) 2010 Red Hat Inc.
+ * Author : Dave Airlie <airlied@redhat.com>
+ *
+ * Licensed under GPLv2
+ *
+ * ATPX support for both Intel/ATI
+ */
+
+#include <linux/vga_switcheroo.h>
+#include <acpi/acpi.h>
+#include <acpi/acpi_bus.h>
+#include <linux/pci.h>
+
+#define ATPX_VERSION 0
+#define ATPX_GPU_PWR 2
+#define ATPX_MUX_SELECT 3
+
+#define ATPX_INTEGRATED 0
+#define ATPX_DISCRETE 1
+
+#define ATPX_MUX_IGD 0
+#define ATPX_MUX_DISCRETE 1
+
+static struct radeon_atpx_priv {
+	bool atpx_detected;
+	/* handle for device - and atpx */
+	acpi_handle dhandle;
+	acpi_handle atpx_handle;
+	acpi_handle atrm_handle;
+} radeon_atpx_priv;
+
+/* retrieve the ROM in 4k blocks */
+static int radeon_atrm_call(acpi_handle atrm_handle, uint8_t *bios,
+			    int offset, int len)
+{
+	acpi_status status;
+	union acpi_object atrm_arg_elements[2], *obj;
+	struct acpi_object_list atrm_arg;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL};
+
+	atrm_arg.count = 2;
+	atrm_arg.pointer = &atrm_arg_elements[0];
+
+	atrm_arg_elements[0].type = ACPI_TYPE_INTEGER;
+	atrm_arg_elements[0].integer.value = offset;
+
+	atrm_arg_elements[1].type = ACPI_TYPE_INTEGER;
+	atrm_arg_elements[1].integer.value = len;
+
+	status = acpi_evaluate_object(atrm_handle, NULL, &atrm_arg, &buffer);
+	if (ACPI_FAILURE(status)) {
+		printk("failed to evaluate ATRM got %s\n", acpi_format_exception(status));
+		return -ENODEV;
+	}
+
+	obj = (union acpi_object *)buffer.pointer;
+	memcpy(bios+offset, obj->buffer.pointer, len);
+	kfree(buffer.pointer);
+	return len;
+}
+
+bool radeon_atrm_supported(struct pci_dev *pdev)
+{
+	/* get the discrete ROM only via ATRM */
+	if (!radeon_atpx_priv.atpx_detected)
+		return false;
+
+	if (radeon_atpx_priv.dhandle == DEVICE_ACPI_HANDLE(&pdev->dev))
+		return false;
+	return true;
+}
+
+
+int radeon_atrm_get_bios_chunk(uint8_t *bios, int offset, int len)
+{
+	return radeon_atrm_call(radeon_atpx_priv.atrm_handle, bios, offset, len);
+}
+
+static int radeon_atpx_get_version(acpi_handle handle)
+{
+	acpi_status status;
+	union acpi_object atpx_arg_elements[2], *obj;
+	struct acpi_object_list atpx_arg;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+
+	atpx_arg.count = 2;
+	atpx_arg.pointer = &atpx_arg_elements[0];
+
+	atpx_arg_elements[0].type = ACPI_TYPE_INTEGER;
+	atpx_arg_elements[0].integer.value = ATPX_VERSION;
+
+	atpx_arg_elements[1].type = ACPI_TYPE_INTEGER;
+	atpx_arg_elements[1].integer.value = ATPX_VERSION;
+
+	status = acpi_evaluate_object(handle, NULL, &atpx_arg, &buffer);
+	if (ACPI_FAILURE(status)) {
+		printk("%s: failed to call ATPX: %s\n", __func__, acpi_format_exception(status));
+		return -ENOSYS;
+	}
+	obj = (union acpi_object *)buffer.pointer;
+	if (obj && (obj->type == ACPI_TYPE_BUFFER))
+		printk(KERN_INFO "radeon atpx: version is %d\n", *((u8 *)(obj->buffer.pointer) + 2));
+	kfree(buffer.pointer);
+	return 0;
+}
+
+static int radeon_atpx_execute(acpi_handle handle, int cmd_id, u16 value)
+{
+	acpi_status status;
+	union acpi_object atpx_arg_elements[2];
+	struct acpi_object_list atpx_arg;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	uint8_t buf[4] = {0};
+
+	if (!handle)
+		return -EINVAL;
+
+	atpx_arg.count = 2;
+	atpx_arg.pointer = &atpx_arg_elements[0];
+
+	atpx_arg_elements[0].type = ACPI_TYPE_INTEGER;
+	atpx_arg_elements[0].integer.value = cmd_id;
+
+	buf[2] = value & 0xff;
+	buf[3] = (value >> 8) & 0xff;
+
+	atpx_arg_elements[1].type = ACPI_TYPE_BUFFER;
+	atpx_arg_elements[1].buffer.length = 4;
+	atpx_arg_elements[1].buffer.pointer = buf;
+
+	status = acpi_evaluate_object(handle, NULL, &atpx_arg, &buffer);
+	if (ACPI_FAILURE(status)) {
+		printk("%s: failed to call ATPX: %s\n", __func__, acpi_format_exception(status));
+		return -ENOSYS;
+	}
+	kfree(buffer.pointer);
+
+	return 0;
+}
+
+static int radeon_atpx_set_discrete_state(acpi_handle handle, int state)
+{
+	return radeon_atpx_execute(handle, ATPX_GPU_PWR, state);
+}
+
+static int radeon_atpx_switch_mux(acpi_handle handle, int mux_id)
+{
+	return radeon_atpx_execute(handle, ATPX_MUX_SELECT, mux_id);
+}
+
+
+static int radeon_atpx_switchto(enum vga_switcheroo_client_id id)
+{
+	if (id == VGA_SWITCHEROO_IGD)
+		radeon_atpx_switch_mux(radeon_atpx_priv.atpx_handle, 0);
+	else
+		radeon_atpx_switch_mux(radeon_atpx_priv.atpx_handle, 1);
+	return 0;
+}
+
+static int radeon_atpx_power_state(enum vga_switcheroo_client_id id,
+				   enum vga_switcheroo_state state)
+{
+	/* on w500 ACPI can't change intel gpu state */
+	if (id == VGA_SWITCHEROO_IGD)
+		return 0;
+
+	radeon_atpx_set_discrete_state(radeon_atpx_priv.atpx_handle, state);
+	return 0;
+}
+
+static bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)
+{
+	acpi_handle dhandle, atpx_handle, atrm_handle;
+	acpi_status status;
+
+	dhandle = DEVICE_ACPI_HANDLE(&pdev->dev);
+	if (!dhandle)
+		return false;
+
+	status = acpi_get_handle(dhandle, "ATPX", &atpx_handle);
+	if (ACPI_FAILURE(status))
+		return false;
+
+	status = acpi_get_handle(dhandle, "ATRM", &atrm_handle);
+	if (ACPI_FAILURE(status))
+		return false;
+
+	radeon_atpx_priv.dhandle = dhandle;
+	radeon_atpx_priv.atpx_handle = atpx_handle;
+	radeon_atpx_priv.atrm_handle = atrm_handle;
+	return true;
+}
+
+static int radeon_atpx_init(void)
+{
+	/* set up the ATPX handle */
+
+	radeon_atpx_get_version(radeon_atpx_priv.atpx_handle);
+	return 0;
+}
+
+static int radeon_atpx_get_client_id(struct pci_dev *pdev)
+{
+	if (radeon_atpx_priv.dhandle == DEVICE_ACPI_HANDLE(&pdev->dev))
+		return VGA_SWITCHEROO_IGD;
+	else
+		return VGA_SWITCHEROO_DIS;
+}
+
+static struct vga_switcheroo_handler radeon_atpx_handler = {
+	.switchto = radeon_atpx_switchto,
+	.power_state = radeon_atpx_power_state,
+	.init = radeon_atpx_init,
+	.get_client_id = radeon_atpx_get_client_id,
+};
+
+static bool radeon_atpx_detect(void)
+{
+	char acpi_method_name[255] = { 0 };
+	struct acpi_buffer buffer = {sizeof(acpi_method_name), acpi_method_name};
+	struct pci_dev *pdev = NULL;
+	bool has_atpx = false;
+	int vga_count = 0;
+
+	while ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {
+		vga_count++;
+
+		has_atpx |= (radeon_atpx_pci_probe_handle(pdev) == true);
+	}
+
+	if (has_atpx && vga_count == 2) {
+		acpi_get_name(radeon_atpx_priv.atpx_handle, ACPI_FULL_PATHNAME, &buffer);
+		printk(KERN_INFO "VGA switcheroo: detected switching method %s handle\n",
+		       acpi_method_name);
+		radeon_atpx_priv.atpx_detected = true;
+		return true;
+	}
+	return false;
+}
+
+void radeon_register_atpx_handler(void)
+{
+	bool r;
+
+	/* detect if we have any ATPX + 2 VGA in the system */
+	r = radeon_atpx_detect();
+	if (!r)
+		return;
+
+	vga_switcheroo_register_handler(&radeon_atpx_handler);
+}
+
+void radeon_unregister_atpx_handler(void)
+{
+	vga_switcheroo_unregister_handler();
+}
