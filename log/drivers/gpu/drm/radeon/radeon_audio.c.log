commit edac2525ae9efe79572c0bbbd38d5d67a1bca23b
Author: Jules Irenge <jbi.octave@gmail.com>
Date:   Tue Nov 26 00:35:14 2019 +0000

    drm: radeon: replace 0 with NULL
    
    Replace 0 with NULL to fix sparse tool  warning
     warning: Using plain integer as NULL pointer
    
    Acked-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Zhan Liu <zhan.liu@amd.com>
    Signed-off-by: Jules Irenge <jbi.octave@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 72db2b41e96d..8c63ccb8b623 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -288,7 +288,7 @@ static void radeon_audio_interface_init(struct radeon_device *rdev)
 	} else {
 		rdev->audio.funcs = &r600_funcs;
 		rdev->audio.hdmi_funcs = &r600_hdmi_funcs;
-		rdev->audio.dp_funcs = 0;
+		rdev->audio.dp_funcs = NULL;
 	}
 }
 

commit 72496eb11734ed7a8420af91f737025dab583af1
Author: Jean Delvare <jdelvare@suse.de>
Date:   Wed Sep 4 11:13:37 2019 +0200

    drm/radeon: be quiet when no SAD block is found
    
    It is fine for displays without audio functionality to not provide
    any SAD block in their EDID. Do not log an error in that case,
    just return quietly.
    
    Inspired by a similar fix to the amdgpu driver in the context of bug
    fdo#107825:
    https://bugs.freedesktop.org/show_bug.cgi?id=107825
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index b9aea5776d3d..72db2b41e96d 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -367,10 +367,10 @@ static void radeon_audio_write_sad_regs(struct drm_encoder *encoder)
 		return;
 
 	sad_count = drm_edid_to_sad(radeon_connector_edid(connector), &sads);
-	if (sad_count <= 0) {
+	if (sad_count < 0)
 		DRM_ERROR("Couldn't read SADs: %d\n", sad_count);
+	if (sad_count <= 0)
 		return;
-	}
 	BUG_ON(!sads);
 
 	if (radeon_encoder->audio && radeon_encoder->audio->write_sad_regs)

commit f91831274e6ed2e6f7514dd16f20816f6753057d
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jun 8 10:02:40 2019 +0200

    drm/radeon: drop use of drmP.h (1/2)
    
    Drop use of drmP.h in all .c files named radeon*c.
    To ease review a little drmP.h removal was divided in two commits.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190608080241.4958-7-sam@ravnborg.org

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 96f71114237a..b9aea5776d3d 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -23,7 +23,7 @@
  */
 
 #include <linux/gcd.h>
-#include <drm/drmP.h>
+
 #include <drm/drm_crtc.h>
 #include "radeon.h"
 #include "atom.h"

commit 1581b2df4cbf614315225f121636e1eb7c80cbae
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jan 8 19:28:28 2019 +0200

    drm/edid: Add display_info.rgb_quant_range_selectable
    
    Move the CEA-861 QS bit handling entirely into the edid code. No
    need to bother the drivers with this.
    
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: amd-gfx@lists.freedesktop.org
    Cc: Eric Anholt <eric@anholt.net> (supporter:DRM DRIVERS FOR VC4)
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Eric Anholt <eric@anholt.net>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190108172828.15184-4-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 708765bf9e66..96f71114237a 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -526,8 +526,7 @@ static int radeon_audio_set_avi_packet(struct drm_encoder *encoder,
 		drm_hdmi_avi_infoframe_quant_range(&frame, connector, mode,
 						   radeon_encoder->output_csc == RADEON_OUTPUT_CSC_TVRGB ?
 						   HDMI_QUANTIZATION_RANGE_LIMITED :
-						   HDMI_QUANTIZATION_RANGE_FULL,
-						   drm_rgb_quant_range_selectable(radeon_connector_edid(connector)));
+						   HDMI_QUANTIZATION_RANGE_FULL);
 	}
 
 	err = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));

commit 8ee491b4d29b48530ed9220059edd2f666bf2889
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jan 8 19:28:27 2019 +0200

    drm/radeon: Use drm_hdmi_avi_infoframe_quant_range()
    
    Fill out the AVI infoframe quantization range bits using
    drm_hdmi_avi_infoframe_quant_range() instead of hand rolling it.
    
    This changes the behaviour slightly as
    drm_hdmi_avi_infoframe_quant_range() will set a non-zero Q bit
    even when QS==0 iff the Q bit matched the default quantization
    range for the given mode. This matches the recommendation in
    HDMI 2.0 and is allowed even before that.
    
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: amd-gfx@lists.freedesktop.org
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190108172828.15184-3-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 5a7d48339b32..708765bf9e66 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -523,14 +523,11 @@ static int radeon_audio_set_avi_packet(struct drm_encoder *encoder,
 	}
 
 	if (radeon_encoder->output_csc != RADEON_OUTPUT_CSC_BYPASS) {
-		if (drm_rgb_quant_range_selectable(radeon_connector_edid(connector))) {
-			if (radeon_encoder->output_csc == RADEON_OUTPUT_CSC_TVRGB)
-				frame.quantization_range = HDMI_QUANTIZATION_RANGE_LIMITED;
-			else
-				frame.quantization_range = HDMI_QUANTIZATION_RANGE_FULL;
-		} else {
-			frame.quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;
-		}
+		drm_hdmi_avi_infoframe_quant_range(&frame, connector, mode,
+						   radeon_encoder->output_csc == RADEON_OUTPUT_CSC_TVRGB ?
+						   HDMI_QUANTIZATION_RANGE_LIMITED :
+						   HDMI_QUANTIZATION_RANGE_FULL,
+						   drm_rgb_quant_range_selectable(radeon_connector_edid(connector)));
 	}
 
 	err = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));

commit 13d0add333afea7b2fef77473232b10dea3627dd
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Jan 8 19:28:25 2019 +0200

    drm/edid: Pass connector to AVI infoframe functions
    
    Make life easier for drivers by simply passing the connector
    to drm_hdmi_avi_infoframe_from_display_mode() and
    drm_hdmi_avi_infoframe_quant_range(). That way drivers don't
    need to worry about is_hdmi2_sink mess.
    
    v2: Make is_hdmi2_sink() return true for sil-sii8620
        Adapt to omap/vc4 changes
    
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: Archit Taneja <architt@codeaurora.org>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Laurent Pinchart <Laurent.pinchart@ideasonboard.com>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Joonyoung Shim <jy0922.shim@samsung.com>
    Cc: Seung-Woo Kim <sw0312.kim@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: CK Hu <ck.hu@mediatek.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Sandy Huang <hjc@rock-chips.com>
    Cc: "Heiko Stübner" <heiko@sntech.de>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Vincent Abriou <vincent.abriou@st.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Ilia Mirkin <imirkin@alum.mit.edu>
    Cc: amd-gfx@lists.freedesktop.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: linux-tegra@vger.kernel.org
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190108172828.15184-1-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 770e31f5fd1b..5a7d48339b32 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -516,7 +516,7 @@ static int radeon_audio_set_avi_packet(struct drm_encoder *encoder,
 	if (!connector)
 		return -EINVAL;
 
-	err = drm_hdmi_avi_infoframe_from_display_mode(&frame, mode, false);
+	err = drm_hdmi_avi_infoframe_from_display_mode(&frame, connector, mode);
 	if (err < 0) {
 		DRM_ERROR("failed to setup AVI infoframe: %d\n", err);
 		return err;

commit 0c1f528cb13708ff3ba462a5c757d5588fc47d36
Author: Shashank Sharma <shashank.sharma@intel.com>
Date:   Thu Jul 13 21:03:07 2017 +0530

    drm: handle HDMI 2.0 VICs in AVI info-frames
    
    HDMI 1.4b support the CEA video modes as per range of CEA-861-D (VIC 1-64).
    For any other mode, the VIC filed in AVI infoframes should be 0.
    HDMI 2.0 sinks, support video modes range as per CEA-861-F spec, which is
    extended to (VIC 1-107).
    
    This patch adds a bool input variable, which indicates if the connected
    sink is a HDMI 2.0 sink or not. This will make sure that we don't pass a
    HDMI 2.0 VIC to a HDMI 1.4 sink.
    
    This patch touches all drm drivers, who are callers of this function
    drm_hdmi_avi_infoframe_from_display_mode but to make sure there is
    no change in current behavior, is_hdmi2 is kept as false.
    
    In case of I915 driver, this patch:
    - checks if the connected display is HDMI 2.0.
    - HDMI infoframes carry one of this two type of information:
            - VIC for 4K modes for HDMI 1.4 sinks
            - S3D information for S3D modes
      As CEA-861-F has already defined VICs for 4K videomodes, this
      patch doesn't allow sending HDMI infoframes for HDMI 2.0 sinks,
      until the mode is 3D.
    
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Cc: Jose Abreu <jose.abreu@synopsys.com>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    
    PS: This patch touches a few lines in few files, which were
    already above 80 char, so checkpatch gives 80 char warning again.
    - gpu/drm/omapdrm/omap_encoder.c
    - gpu/drm/i915/intel_sdvo.c
    
    V2: Rebase, Added r-b from Andrzej
    V3: Addressed review comment from Ville:
            - Do not send VICs in both AVI-IF and HDMI-IF
              send only one of it.
    V4: Rebase
    V5: Added r-b from Neil.
        Addressed review comments from Ville
        - Do not block HDMI vendor IF, instead check for VIC while
          handling AVI infoframes
    V6: Rebase
    V7: Rebase
    
    Reviewed-by: Andrzej Hajda <a.hajda@samsung.com>
    Reviewed-by: Neil Armstrong <narmstrong@baylibre.com>
    Signed-off-by: Shashank Sharma <shashank.sharma@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1499960000-9232-2-git-send-email-shashank.sharma@intel.com
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index aaacac190d26..770e31f5fd1b 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -516,7 +516,7 @@ static int radeon_audio_set_avi_packet(struct drm_encoder *encoder,
 	if (!connector)
 		return -EINVAL;
 
-	err = drm_hdmi_avi_infoframe_from_display_mode(&frame, mode);
+	err = drm_hdmi_avi_infoframe_from_display_mode(&frame, mode, false);
 	if (err < 0) {
 		DRM_ERROR("failed to setup AVI infoframe: %d\n", err);
 		return err;

commit 7ca85295d8cc280ea79cf6250c47363b7fd92f92
Author: Joe Perches <joe@perches.com>
Date:   Tue Feb 28 04:55:52 2017 -0800

    gpu: drm: amd/radeon: Convert printk(KERN_<LEVEL> to pr_<level>
    
    Use a more common logging style.
    
    Miscellanea:
    
    o Coalesce formats and realign arguments
    o Neaten a few macros now using pr_<level>
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index b214663b370d..aaacac190d26 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -576,9 +576,9 @@ static void radeon_audio_calc_cts(unsigned int clock, int *CTS, int *N, int freq
 
 	/* Check that we are in spec (not always possible) */
 	if (n < (128*freq/1500))
-		printk(KERN_WARNING "Calculated ACR N value is too small. You may experience audio problems.\n");
+		pr_warn("Calculated ACR N value is too small. You may experience audio problems.\n");
 	if (n > (128*freq/300))
-		printk(KERN_WARNING "Calculated ACR N value is too large. You may experience audio problems.\n");
+		pr_warn("Calculated ACR N value is too large. You may experience audio problems.\n");
 
 	*N = n;
 	*CTS = cts;

commit a64c9dab1c4d05c87ec8a1cb9b48915816462143
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Tue Jan 26 16:56:25 2016 -0500

    drm/radeon: Add a common function for DFS handling
    
    Move encoding of DFS (digital frequency synthesizer) divider into a
    separate function and improve calculation precision.
    
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 85e1c234f020..b214663b370d 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -775,3 +775,15 @@ void radeon_audio_dpms(struct drm_encoder *encoder, int mode)
 	if (radeon_encoder->audio && radeon_encoder->audio->dpms)
 		radeon_encoder->audio->dpms(encoder, mode == DRM_MODE_DPMS_ON);
 }
+
+unsigned int radeon_audio_decode_dfs_div(unsigned int div)
+{
+	if (div >= 8 && div < 64)
+		return (div - 8) * 25 + 200;
+	else if (div >= 64 && div < 96)
+		return (div - 64) * 50 + 1600;
+	else if (div >= 96 && div < 128)
+		return (div - 96) * 100 + 3200;
+	else
+		return 0;
+}

commit c9a392eac18409f51a071520cf508c0b4ad990e2
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Tue Jan 26 16:45:10 2016 -0500

    drm/radeon: cleaned up VCO output settings for DP audio
    
    This is preparation for the fixes in the following patches.
    
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 2c02e99b5f95..85e1c234f020 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -739,9 +739,6 @@ static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
 	struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);
-	struct radeon_connector *radeon_connector = to_radeon_connector(connector);
-	struct radeon_connector_atom_dig *dig_connector =
-		radeon_connector->con_priv;
 
 	if (!dig || !dig->afmt)
 		return;
@@ -753,10 +750,7 @@ static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,
 		radeon_audio_write_speaker_allocation(encoder);
 		radeon_audio_write_sad_regs(encoder);
 		radeon_audio_write_latency_fields(encoder, mode);
-		if (rdev->clock.dp_extclk || ASIC_IS_DCE5(rdev))
-			radeon_audio_set_dto(encoder, rdev->clock.default_dispclk * 10);
-		else
-			radeon_audio_set_dto(encoder, dig_connector->dp_clock);
+		radeon_audio_set_dto(encoder, rdev->clock.vco_freq * 10);
 		radeon_audio_set_audio_packet(encoder);
 		radeon_audio_select_pin(encoder);
 

commit 86b7709d48f0df8796bddd7e1ce45c6fb7a7c6ec
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Aug 27 09:52:22 2015 -0400

    drm/radeon: fix HDMI quantization_range for pre-DCE5 asics
    
    Support for output_csc is only available on DCE5 and newer so
    don't mess with the HDMI quantization_range on pre-DCE5 asics.
    
    bug:
    https://bugs.freedesktop.org/show_bug.cgi?id=83226
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index fbc8d88d6e5d..2c02e99b5f95 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -522,13 +522,15 @@ static int radeon_audio_set_avi_packet(struct drm_encoder *encoder,
 		return err;
 	}
 
-	if (drm_rgb_quant_range_selectable(radeon_connector_edid(connector))) {
-		if (radeon_encoder->output_csc == RADEON_OUTPUT_CSC_TVRGB)
-			frame.quantization_range = HDMI_QUANTIZATION_RANGE_LIMITED;
-		else
-			frame.quantization_range = HDMI_QUANTIZATION_RANGE_FULL;
-	} else {
-		frame.quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;
+	if (radeon_encoder->output_csc != RADEON_OUTPUT_CSC_BYPASS) {
+		if (drm_rgb_quant_range_selectable(radeon_connector_edid(connector))) {
+			if (radeon_encoder->output_csc == RADEON_OUTPUT_CSC_TVRGB)
+				frame.quantization_range = HDMI_QUANTIZATION_RANGE_LIMITED;
+			else
+				frame.quantization_range = HDMI_QUANTIZATION_RANGE_FULL;
+		} else {
+			frame.quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;
+		}
 	}
 
 	err = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));

commit 7726e72b3d6879ee5fc743a230eb6f5afa12844b
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Jul 24 00:42:02 2015 -0400

    drm/radeon: rework audio modeset to handle non-audio hdmi features
    
    Need to setup the deep color and avi packets regardless of
    audio setup.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 59b3d3221294..fbc8d88d6e5d 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -696,26 +696,37 @@ static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,
 {
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
+	struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);
 
 	if (!dig || !dig->afmt)
 		return;
 
-	radeon_audio_set_mute(encoder, true);
+	if (!connector)
+		return;
 
-	radeon_audio_write_speaker_allocation(encoder);
-	radeon_audio_write_sad_regs(encoder);
-	radeon_audio_write_latency_fields(encoder, mode);
-	radeon_audio_set_dto(encoder, mode->clock);
-	radeon_audio_set_vbi_packet(encoder);
-	radeon_hdmi_set_color_depth(encoder);
-	radeon_audio_update_acr(encoder, mode->clock);
-	radeon_audio_set_audio_packet(encoder);
-	radeon_audio_select_pin(encoder);
+	if (drm_detect_monitor_audio(radeon_connector_edid(connector))) {
+		radeon_audio_set_mute(encoder, true);
 
-	if (radeon_audio_set_avi_packet(encoder, mode) < 0)
-		return;
+		radeon_audio_write_speaker_allocation(encoder);
+		radeon_audio_write_sad_regs(encoder);
+		radeon_audio_write_latency_fields(encoder, mode);
+		radeon_audio_set_dto(encoder, mode->clock);
+		radeon_audio_set_vbi_packet(encoder);
+		radeon_hdmi_set_color_depth(encoder);
+		radeon_audio_update_acr(encoder, mode->clock);
+		radeon_audio_set_audio_packet(encoder);
+		radeon_audio_select_pin(encoder);
+
+		if (radeon_audio_set_avi_packet(encoder, mode) < 0)
+			return;
+
+		radeon_audio_set_mute(encoder, false);
+	} else {
+		radeon_hdmi_set_color_depth(encoder);
 
-	radeon_audio_set_mute(encoder, false);
+		if (radeon_audio_set_avi_packet(encoder, mode) < 0)
+			return;
+	}
 }
 
 static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,
@@ -730,24 +741,26 @@ static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,
 	struct radeon_connector_atom_dig *dig_connector =
 		radeon_connector->con_priv;
 
-	if (!connector)
+	if (!dig || !dig->afmt)
 		return;
 
-	if (!dig || !dig->afmt)
+	if (!connector)
 		return;
 
-	radeon_audio_write_speaker_allocation(encoder);
-	radeon_audio_write_sad_regs(encoder);
-	radeon_audio_write_latency_fields(encoder, mode);
-	if (rdev->clock.dp_extclk || ASIC_IS_DCE5(rdev))
-		radeon_audio_set_dto(encoder, rdev->clock.default_dispclk * 10);
-	else
-		radeon_audio_set_dto(encoder, dig_connector->dp_clock);
-	radeon_audio_set_audio_packet(encoder);
-	radeon_audio_select_pin(encoder);
+	if (drm_detect_monitor_audio(radeon_connector_edid(connector))) {
+		radeon_audio_write_speaker_allocation(encoder);
+		radeon_audio_write_sad_regs(encoder);
+		radeon_audio_write_latency_fields(encoder, mode);
+		if (rdev->clock.dp_extclk || ASIC_IS_DCE5(rdev))
+			radeon_audio_set_dto(encoder, rdev->clock.default_dispclk * 10);
+		else
+			radeon_audio_set_dto(encoder, dig_connector->dp_clock);
+		radeon_audio_set_audio_packet(encoder);
+		radeon_audio_select_pin(encoder);
 
-	if (radeon_audio_set_avi_packet(encoder, mode) < 0)
-		return;
+		if (radeon_audio_set_avi_packet(encoder, mode) < 0)
+			return;
+	}
 }
 
 void radeon_audio_mode_set(struct drm_encoder *encoder,

commit d0ea397e22f9ad0113c1dbdaab14eded050472eb
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Jul 23 10:01:09 2015 -0400

    drm/radeon: rework audio detect (v4)
    
    1. Always assign audio function pointers even if the display does
    not support audio.  We need to properly disable the audio stream
    when when using a non-audio capable monitor.  Fixes purple line
    on some hdmi monitors.
    
    2. Check if a pin is in use by another encoder before disabling
    it.
    
    v2: make sure we've fetched the edid before checking audio and
        look up the encoder before calling audio_detect since
        connector->encoder may not be assigned yet.  Separate
        pin and afmt.  They are allocated at different times and
        have no dependency on eachother.
    v3: fix connector fetching in encoder functions
    v4: fix missed dig->pin check in dce6_afmt_write_latency_fields
    
    bugs:
    https://bugzilla.kernel.org/show_bug.cgi?id=93701
    https://bugzilla.redhat.com/show_bug.cgi?id=1236337
    https://bugs.freedesktop.org/show_bug.cgi?id=91041
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index fa719c53449b..59b3d3221294 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -245,6 +245,28 @@ static struct radeon_audio_funcs dce6_dp_funcs = {
 static void radeon_audio_enable(struct radeon_device *rdev,
 				struct r600_audio_pin *pin, u8 enable_mask)
 {
+	struct drm_encoder *encoder;
+	struct radeon_encoder *radeon_encoder;
+	struct radeon_encoder_atom_dig *dig;
+	int pin_count = 0;
+
+	if (!pin)
+		return;
+
+	if (rdev->mode_info.mode_config_initialized) {
+		list_for_each_entry(encoder, &rdev->ddev->mode_config.encoder_list, head) {
+			if (radeon_encoder_is_digital(encoder)) {
+				radeon_encoder = to_radeon_encoder(encoder);
+				dig = radeon_encoder->enc_priv;
+				if (dig->pin == pin)
+					pin_count++;
+			}
+		}
+
+		if ((pin_count > 1) && (enable_mask == 0))
+			return;
+	}
+
 	if (rdev->audio.funcs->enable)
 		rdev->audio.funcs->enable(rdev, pin, enable_mask);
 }
@@ -336,24 +358,13 @@ void radeon_audio_endpoint_wreg(struct radeon_device *rdev, u32 offset,
 
 static void radeon_audio_write_sad_regs(struct drm_encoder *encoder)
 {
-	struct radeon_encoder *radeon_encoder;
-	struct drm_connector *connector;
-	struct radeon_connector *radeon_connector = NULL;
+	struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct cea_sad *sads;
 	int sad_count;
 
-	list_for_each_entry(connector,
-		&encoder->dev->mode_config.connector_list, head) {
-		if (connector->encoder == encoder) {
-			radeon_connector = to_radeon_connector(connector);
-			break;
-		}
-	}
-
-	if (!radeon_connector) {
-		DRM_ERROR("Couldn't find encoder's connector\n");
+	if (!connector)
 		return;
-	}
 
 	sad_count = drm_edid_to_sad(radeon_connector_edid(connector), &sads);
 	if (sad_count <= 0) {
@@ -362,8 +373,6 @@ static void radeon_audio_write_sad_regs(struct drm_encoder *encoder)
 	}
 	BUG_ON(!sads);
 
-	radeon_encoder = to_radeon_encoder(encoder);
-
 	if (radeon_encoder->audio && radeon_encoder->audio->write_sad_regs)
 		radeon_encoder->audio->write_sad_regs(encoder, sads, sad_count);
 
@@ -372,27 +381,16 @@ static void radeon_audio_write_sad_regs(struct drm_encoder *encoder)
 
 static void radeon_audio_write_speaker_allocation(struct drm_encoder *encoder)
 {
+	struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
-	struct drm_connector *connector;
-	struct radeon_connector *radeon_connector = NULL;
 	u8 *sadb = NULL;
 	int sad_count;
 
-	list_for_each_entry(connector,
-			    &encoder->dev->mode_config.connector_list, head) {
-		if (connector->encoder == encoder) {
-			radeon_connector = to_radeon_connector(connector);
-			break;
-		}
-	}
-
-	if (!radeon_connector) {
-		DRM_ERROR("Couldn't find encoder's connector\n");
+	if (!connector)
 		return;
-	}
 
-	sad_count = drm_edid_to_speaker_allocation(
-		radeon_connector_edid(connector), &sadb);
+	sad_count = drm_edid_to_speaker_allocation(radeon_connector_edid(connector),
+						   &sadb);
 	if (sad_count < 0) {
 		DRM_DEBUG("Couldn't read Speaker Allocation Data Block: %d\n",
 			  sad_count);
@@ -406,26 +404,13 @@ static void radeon_audio_write_speaker_allocation(struct drm_encoder *encoder)
 }
 
 static void radeon_audio_write_latency_fields(struct drm_encoder *encoder,
-	struct drm_display_mode *mode)
+					      struct drm_display_mode *mode)
 {
-	struct radeon_encoder *radeon_encoder;
-	struct drm_connector *connector;
-	struct radeon_connector *radeon_connector = 0;
-
-	list_for_each_entry(connector,
-		&encoder->dev->mode_config.connector_list, head) {
-		if (connector->encoder == encoder) {
-			radeon_connector = to_radeon_connector(connector);
-			break;
-		}
-	}
+	struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 
-	if (!radeon_connector) {
-		DRM_ERROR("Couldn't find encoder's connector\n");
+	if (!connector)
 		return;
-	}
-
-	radeon_encoder = to_radeon_encoder(encoder);
 
 	if (radeon_encoder->audio && radeon_encoder->audio->write_latency_fields)
 		radeon_encoder->audio->write_latency_fields(encoder, connector, mode);
@@ -451,29 +436,23 @@ static void radeon_audio_select_pin(struct drm_encoder *encoder)
 }
 
 void radeon_audio_detect(struct drm_connector *connector,
+			 struct drm_encoder *encoder,
 			 enum drm_connector_status status)
 {
-	struct radeon_device *rdev;
-	struct radeon_encoder *radeon_encoder;
+	struct drm_device *dev = connector->dev;
+	struct radeon_device *rdev = dev->dev_private;
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_encoder_atom_dig *dig;
 
-	if (!connector || !connector->encoder)
+	if (!radeon_audio_chipset_supported(rdev))
 		return;
 
-	rdev = connector->encoder->dev->dev_private;
-
-	if (!radeon_audio_chipset_supported(rdev))
+	if (!radeon_encoder_is_digital(encoder))
 		return;
 
-	radeon_encoder = to_radeon_encoder(connector->encoder);
 	dig = radeon_encoder->enc_priv;
 
 	if (status == connector_status_connected) {
-		if (!drm_detect_monitor_audio(radeon_connector_edid(connector))) {
-			radeon_encoder->audio = NULL;
-			return;
-		}
-
 		if (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort) {
 			struct radeon_connector *radeon_connector = to_radeon_connector(connector);
 
@@ -486,11 +465,17 @@ void radeon_audio_detect(struct drm_connector *connector,
 			radeon_encoder->audio = rdev->audio.hdmi_funcs;
 		}
 
-		dig->afmt->pin = radeon_audio_get_pin(connector->encoder);
-		radeon_audio_enable(rdev, dig->afmt->pin, 0xf);
+		if (drm_detect_monitor_audio(radeon_connector_edid(connector))) {
+			if (!dig->pin)
+				dig->pin = radeon_audio_get_pin(encoder);
+			radeon_audio_enable(rdev, dig->pin, 0xf);
+		} else {
+			radeon_audio_enable(rdev, dig->pin, 0);
+			dig->pin = NULL;
+		}
 	} else {
-		radeon_audio_enable(rdev, dig->afmt->pin, 0);
-		dig->afmt->pin = NULL;
+		radeon_audio_enable(rdev, dig->pin, 0);
+		dig->pin = NULL;
 	}
 }
 
@@ -518,29 +503,18 @@ static void radeon_audio_set_dto(struct drm_encoder *encoder, unsigned int clock
 }
 
 static int radeon_audio_set_avi_packet(struct drm_encoder *encoder,
-	struct drm_display_mode *mode)
+				       struct drm_display_mode *mode)
 {
 	struct radeon_device *rdev = encoder->dev->dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
-	struct drm_connector *connector;
-	struct radeon_connector *radeon_connector = NULL;
+	struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);
 	u8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AVI_INFOFRAME_SIZE];
 	struct hdmi_avi_infoframe frame;
 	int err;
 
-	list_for_each_entry(connector,
-		&encoder->dev->mode_config.connector_list, head) {
-		if (connector->encoder == encoder) {
-			radeon_connector = to_radeon_connector(connector);
-			break;
-		}
-	}
-
-	if (!radeon_connector) {
-		DRM_ERROR("Couldn't find encoder's connector\n");
-		return -ENOENT;
-	}
+	if (!connector)
+		return -EINVAL;
 
 	err = drm_hdmi_avi_infoframe_from_display_mode(&frame, mode);
 	if (err < 0) {
@@ -563,8 +537,8 @@ static int radeon_audio_set_avi_packet(struct drm_encoder *encoder,
 		return err;
 	}
 
-	if (dig && dig->afmt &&
-		radeon_encoder->audio && radeon_encoder->audio->set_avi_packet)
+	if (dig && dig->afmt && radeon_encoder->audio &&
+	    radeon_encoder->audio->set_avi_packet)
 		radeon_encoder->audio->set_avi_packet(rdev, dig->afmt->offset,
 			buffer, sizeof(buffer));
 
@@ -745,7 +719,7 @@ static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,
 }
 
 static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,
-	struct drm_display_mode *mode)
+				     struct drm_display_mode *mode)
 {
 	struct drm_device *dev = encoder->dev;
 	struct radeon_device *rdev = dev->dev_private;
@@ -756,6 +730,9 @@ static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,
 	struct radeon_connector_atom_dig *dig_connector =
 		radeon_connector->con_priv;
 
+	if (!connector)
+		return;
+
 	if (!dig || !dig->afmt)
 		return;
 
@@ -774,7 +751,7 @@ static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,
 }
 
 void radeon_audio_mode_set(struct drm_encoder *encoder,
-	struct drm_display_mode *mode)
+			   struct drm_display_mode *mode)
 {
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 

commit 479e9a95120aaae0bf0d3e0b5b26b36ac4a347b6
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jun 30 09:30:01 2015 -0400

    drm/radeon: only check the sink type on DP connectors
    
    Avoids a crash on pre-DP asics that support HDMI.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index c89215275053..fa719c53449b 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -469,22 +469,22 @@ void radeon_audio_detect(struct drm_connector *connector,
 	dig = radeon_encoder->enc_priv;
 
 	if (status == connector_status_connected) {
-		struct radeon_connector *radeon_connector;
-		int sink_type;
-
 		if (!drm_detect_monitor_audio(radeon_connector_edid(connector))) {
 			radeon_encoder->audio = NULL;
 			return;
 		}
 
-		radeon_connector = to_radeon_connector(connector);
-		sink_type = radeon_dp_getsinktype(radeon_connector);
+		if (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort) {
+			struct radeon_connector *radeon_connector = to_radeon_connector(connector);
 
-		if (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort &&
-			sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT)
-			radeon_encoder->audio = rdev->audio.dp_funcs;
-		else
+			if (radeon_dp_getsinktype(radeon_connector) ==
+			    CONNECTOR_OBJECT_ID_DISPLAYPORT)
+				radeon_encoder->audio = rdev->audio.dp_funcs;
+			else
+				radeon_encoder->audio = rdev->audio.hdmi_funcs;
+		} else {
 			radeon_encoder->audio = rdev->audio.hdmi_funcs;
+		}
 
 		dig->afmt->pin = radeon_audio_get_pin(connector->encoder);
 		radeon_audio_enable(rdev, dig->afmt->pin, 0xf);

commit a8a50fce60e86f82e442bf84b8af20750b3d6105
Merge: 9b5edbf7a462 c65b99f04684
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jun 4 09:23:51 2015 +1000

    Merge tag 'v4.1-rc6' into drm-next
    
    Linux 4.1-rc6
    
    backmerge 4.1-rc6 as some of the later pull reqs are based on newer bases
    and I'd prefer to do the fixup myself.

commit 010621936103fcfc15375ccdc92c0f583923d489
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon May 18 11:11:48 2015 -0400

    drm/radeon: clean up radeon_audio_enable
    
    - make it static
    - fix mask/bool handling for last param
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index dcb779647c57..abbc154b1bff 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -242,6 +242,13 @@ static struct radeon_audio_funcs dce6_dp_funcs = {
 	.dpms = evergreen_dp_enable,
 };
 
+static void radeon_audio_enable(struct radeon_device *rdev,
+				struct r600_audio_pin *pin, u8 enable_mask)
+{
+	if (rdev->audio.funcs->enable)
+		rdev->audio.funcs->enable(rdev, pin, enable_mask);
+}
+
 static void radeon_audio_interface_init(struct radeon_device *rdev)
 {
 	if (ASIC_IS_DCE6(rdev)) {
@@ -307,7 +314,7 @@ int radeon_audio_init(struct radeon_device *rdev)
 
 	/* disable audio.  it will be set up later */
 	for (i = 0; i < rdev->audio.num_pins; i++)
-		radeon_audio_enable(rdev, &rdev->audio.pin[i], false);
+		radeon_audio_enable(rdev, &rdev->audio.pin[i], 0);
 
 	return 0;
 }
@@ -443,13 +450,6 @@ static void radeon_audio_select_pin(struct drm_encoder *encoder)
 		radeon_encoder->audio->select_pin(encoder);
 }
 
-void radeon_audio_enable(struct radeon_device *rdev,
-	struct r600_audio_pin *pin, u8 enable_mask)
-{
-	if (rdev->audio.funcs->enable)
-		rdev->audio.funcs->enable(rdev, pin, enable_mask);
-}
-
 void radeon_audio_detect(struct drm_connector *connector,
 			 enum drm_connector_status status)
 {
@@ -505,7 +505,7 @@ void radeon_audio_fini(struct radeon_device *rdev)
 		return;
 
 	for (i = 0; i < rdev->audio.num_pins; i++)
-		radeon_audio_enable(rdev, &rdev->audio.pin[i], false);
+		radeon_audio_enable(rdev, &rdev->audio.pin[i], 0);
 
 	rdev->audio.enabled = false;
 }

commit 2d1c18bba15daf89d75ce475ecd2068f483aa12f
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed May 27 11:43:53 2015 -0400

    Revert "drm/radeon: only mark audio as connected if the monitor supports it (v3)"
    
    This breaks too many things.
    
    bugs:
    https://bugzilla.kernel.org/show_bug.cgi?id=99041
    https://bugs.freedesktop.org/show_bug.cgi?id=90681
    
    This reverts commit 0f55db36d49d45b80eff0c0a2a498766016f458b.
    
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index dcb779647c57..25191f126f3b 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -460,9 +460,6 @@ void radeon_audio_detect(struct drm_connector *connector,
 	if (!connector || !connector->encoder)
 		return;
 
-	if (!radeon_encoder_is_digital(connector->encoder))
-		return;
-
 	rdev = connector->encoder->dev->dev_private;
 
 	if (!radeon_audio_chipset_supported(rdev))
@@ -471,26 +468,26 @@ void radeon_audio_detect(struct drm_connector *connector,
 	radeon_encoder = to_radeon_encoder(connector->encoder);
 	dig = radeon_encoder->enc_priv;
 
-	if (!dig->afmt)
-		return;
-
 	if (status == connector_status_connected) {
-		struct radeon_connector *radeon_connector = to_radeon_connector(connector);
+		struct radeon_connector *radeon_connector;
+		int sink_type;
+
+		if (!drm_detect_monitor_audio(radeon_connector_edid(connector))) {
+			radeon_encoder->audio = NULL;
+			return;
+		}
+
+		radeon_connector = to_radeon_connector(connector);
+		sink_type = radeon_dp_getsinktype(radeon_connector);
 
 		if (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort &&
-		    radeon_dp_getsinktype(radeon_connector) ==
-		    CONNECTOR_OBJECT_ID_DISPLAYPORT)
+			sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT)
 			radeon_encoder->audio = rdev->audio.dp_funcs;
 		else
 			radeon_encoder->audio = rdev->audio.hdmi_funcs;
 
 		dig->afmt->pin = radeon_audio_get_pin(connector->encoder);
-		if (drm_detect_monitor_audio(radeon_connector_edid(connector))) {
-			radeon_audio_enable(rdev, dig->afmt->pin, 0xf);
-		} else {
-			radeon_audio_enable(rdev, dig->afmt->pin, 0);
-			dig->afmt->pin = NULL;
-		}
+		radeon_audio_enable(rdev, dig->afmt->pin, 0xf);
 	} else {
 		radeon_audio_enable(rdev, dig->afmt->pin, 0);
 		dig->afmt->pin = NULL;

commit d73a824acc705571c0f47596326d7967fba9a1d9
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon May 4 14:35:01 2015 -0400

    drm/radeon: don't setup audio on asics that don't support it
    
    bug: https://bugzilla.kernel.org/show_bug.cgi?id=97701
    
    Reported-by: Mikael Pettersson <mikpelinux@gmail.com>
    Tested-by: Mikael Pettersson <mikpelinux@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 8b82abb78df1..dcb779647c57 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -464,6 +464,10 @@ void radeon_audio_detect(struct drm_connector *connector,
 		return;
 
 	rdev = connector->encoder->dev->dev_private;
+
+	if (!radeon_audio_chipset_supported(rdev))
+		return;
+
 	radeon_encoder = to_radeon_encoder(connector->encoder);
 	dig = radeon_encoder->enc_priv;
 

commit 0f55db36d49d45b80eff0c0a2a498766016f458b
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Apr 7 09:52:42 2015 -0400

    drm/radeon: only mark audio as connected if the monitor supports it (v3)
    
    Otherwise the driver may try and send audio which may confuse the
    monitor.
    
    v2: set pin to NULL if no audio
    v3: avoid crash with analog encoders
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 2c17df978d61..8b82abb78df1 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -460,30 +460,33 @@ void radeon_audio_detect(struct drm_connector *connector,
 	if (!connector || !connector->encoder)
 		return;
 
+	if (!radeon_encoder_is_digital(connector->encoder))
+		return;
+
 	rdev = connector->encoder->dev->dev_private;
 	radeon_encoder = to_radeon_encoder(connector->encoder);
 	dig = radeon_encoder->enc_priv;
 
-	if (status == connector_status_connected) {
-		struct radeon_connector *radeon_connector;
-		int sink_type;
-
-		if (!drm_detect_monitor_audio(radeon_connector_edid(connector))) {
-			radeon_encoder->audio = NULL;
-			return;
-		}
+	if (!dig->afmt)
+		return;
 
-		radeon_connector = to_radeon_connector(connector);
-		sink_type = radeon_dp_getsinktype(radeon_connector);
+	if (status == connector_status_connected) {
+		struct radeon_connector *radeon_connector = to_radeon_connector(connector);
 
 		if (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort &&
-			sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT)
+		    radeon_dp_getsinktype(radeon_connector) ==
+		    CONNECTOR_OBJECT_ID_DISPLAYPORT)
 			radeon_encoder->audio = rdev->audio.dp_funcs;
 		else
 			radeon_encoder->audio = rdev->audio.hdmi_funcs;
 
 		dig->afmt->pin = radeon_audio_get_pin(connector->encoder);
-		radeon_audio_enable(rdev, dig->afmt->pin, 0xf);
+		if (drm_detect_monitor_audio(radeon_connector_edid(connector))) {
+			radeon_audio_enable(rdev, dig->afmt->pin, 0xf);
+		} else {
+			radeon_audio_enable(rdev, dig->afmt->pin, 0);
+			dig->afmt->pin = NULL;
+		}
 	} else {
 		radeon_audio_enable(rdev, dig->afmt->pin, 0);
 		dig->afmt->pin = NULL;

commit 12428327bbd1180b5d8ef83fdf9482b878d0502a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Mar 31 11:38:48 2015 -0400

    drm/radeon: drop dce6_dp_enable
    
    It's mostly duplicated with evergreen_dp_enable. This
    is a prerequisite for fix implemented in another patch.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 48d49e651a30..2c17df978d61 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -102,7 +102,6 @@ static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,
 void r600_hdmi_enable(struct drm_encoder *encoder, bool enable);
 void evergreen_hdmi_enable(struct drm_encoder *encoder, bool enable);
 void evergreen_dp_enable(struct drm_encoder *encoder, bool enable);
-void dce6_dp_enable(struct drm_encoder *encoder, bool enable);
 
 static const u32 pin_offsets[7] =
 {
@@ -240,7 +239,7 @@ static struct radeon_audio_funcs dce6_dp_funcs = {
 	.set_avi_packet = evergreen_set_avi_packet,
 	.set_audio_packet = dce4_set_audio_packet,
 	.mode_set = radeon_audio_dp_mode_set,
-	.dpms = dce6_dp_enable,
+	.dpms = evergreen_dp_enable,
 };
 
 static void radeon_audio_interface_init(struct radeon_device *rdev)

commit a1dcc2778b682361351a369652b66dd2d66cf1d9
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Feb 23 17:14:47 2015 -0500

    drm/radeon: setup quantization_range in AVI infoframe
    
    If the display supports selectable range, set the range
    based on what the user has selected for output csc.
    
    bug:
    https://bugs.freedesktop.org/show_bug.cgi?id=83226
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index b21ef69a34ac..48d49e651a30 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -520,16 +520,40 @@ static int radeon_audio_set_avi_packet(struct drm_encoder *encoder,
 	struct radeon_device *rdev = encoder->dev->dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
+	struct drm_connector *connector;
+	struct radeon_connector *radeon_connector = NULL;
 	u8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AVI_INFOFRAME_SIZE];
 	struct hdmi_avi_infoframe frame;
 	int err;
 
+	list_for_each_entry(connector,
+		&encoder->dev->mode_config.connector_list, head) {
+		if (connector->encoder == encoder) {
+			radeon_connector = to_radeon_connector(connector);
+			break;
+		}
+	}
+
+	if (!radeon_connector) {
+		DRM_ERROR("Couldn't find encoder's connector\n");
+		return -ENOENT;
+	}
+
 	err = drm_hdmi_avi_infoframe_from_display_mode(&frame, mode);
 	if (err < 0) {
 		DRM_ERROR("failed to setup AVI infoframe: %d\n", err);
 		return err;
 	}
 
+	if (drm_rgb_quant_range_selectable(radeon_connector_edid(connector))) {
+		if (radeon_encoder->output_csc == RADEON_OUTPUT_CSC_TVRGB)
+			frame.quantization_range = HDMI_QUANTIZATION_RANGE_LIMITED;
+		else
+			frame.quantization_range = HDMI_QUANTIZATION_RANGE_FULL;
+	} else {
+		frame.quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;
+	}
+
 	err = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));
 	if (err < 0) {
 		DRM_ERROR("failed to pack AVI infoframe: %d\n", err);

commit aeefd07e90e277f9ac5c242c8b2e6797373021a3
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Feb 27 14:43:47 2015 -0500

    drm/radeon: properly set dto for dp on DCE4/5
    
    If DCPLL or ext PLL is used, use the disp clk.  If
    PPLL is used, use the dp clock.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 31de59271007..b21ef69a34ac 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -724,6 +724,10 @@ static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,
 	struct radeon_device *rdev = dev->dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
+	struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);
+	struct radeon_connector *radeon_connector = to_radeon_connector(connector);
+	struct radeon_connector_atom_dig *dig_connector =
+		radeon_connector->con_priv;
 
 	if (!dig || !dig->afmt)
 		return;
@@ -731,7 +735,10 @@ static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,
 	radeon_audio_write_speaker_allocation(encoder);
 	radeon_audio_write_sad_regs(encoder);
 	radeon_audio_write_latency_fields(encoder, mode);
-	radeon_audio_set_dto(encoder, rdev->clock.default_dispclk * 10);
+	if (rdev->clock.dp_extclk || ASIC_IS_DCE5(rdev))
+		radeon_audio_set_dto(encoder, rdev->clock.default_dispclk * 10);
+	else
+		radeon_audio_set_dto(encoder, dig_connector->dp_clock);
 	radeon_audio_set_audio_packet(encoder);
 	radeon_audio_select_pin(encoder);
 

commit b20932dd62f77a96124ec8f0c7ad0908b5584526
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Feb 27 10:51:40 2015 -0500

    drm/radeon/audio: update EDID derived fields in modeset
    
    We don't necessarily have an EDID at this point when
    audio detect gets called.  Ideally we'd update these
    fields in detect, but that requires a larger rework
    of the display detect code.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index c16191975916..31de59271007 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -484,11 +484,6 @@ void radeon_audio_detect(struct drm_connector *connector,
 			radeon_encoder->audio = rdev->audio.hdmi_funcs;
 
 		dig->afmt->pin = radeon_audio_get_pin(connector->encoder);
-		radeon_audio_write_speaker_allocation(connector->encoder);
-		radeon_audio_write_sad_regs(connector->encoder);
-		if (connector->encoder->crtc)
-			radeon_audio_write_latency_fields(connector->encoder,
-				&connector->encoder->crtc->mode);
 		radeon_audio_enable(rdev, dig->afmt->pin, 0xf);
 	} else {
 		radeon_audio_enable(rdev, dig->afmt->pin, 0);
@@ -706,6 +701,9 @@ static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,
 
 	radeon_audio_set_mute(encoder, true);
 
+	radeon_audio_write_speaker_allocation(encoder);
+	radeon_audio_write_sad_regs(encoder);
+	radeon_audio_write_latency_fields(encoder, mode);
 	radeon_audio_set_dto(encoder, mode->clock);
 	radeon_audio_set_vbi_packet(encoder);
 	radeon_hdmi_set_color_depth(encoder);
@@ -730,6 +728,9 @@ static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,
 	if (!dig || !dig->afmt)
 		return;
 
+	radeon_audio_write_speaker_allocation(encoder);
+	radeon_audio_write_sad_regs(encoder);
+	radeon_audio_write_latency_fields(encoder, mode);
 	radeon_audio_set_dto(encoder, rdev->clock.default_dispclk * 10);
 	radeon_audio_set_audio_packet(encoder);
 	radeon_audio_select_pin(encoder);

commit 3ed7ceeabf4d6a6df02121cc7e4b46d39501b6e9
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Feb 27 10:42:21 2015 -0500

    drm/radeon: don't toggle audio state in modeset
    
    Should be done only at detect time to avoid spurious
    state changes on the audio side.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 5b579582175b..c16191975916 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -696,9 +696,8 @@ static void radeon_audio_set_mute(struct drm_encoder *encoder, bool mute)
  * update the info frames with the data from the current display mode
  */
 static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,
-	struct drm_display_mode *mode)
+				       struct drm_display_mode *mode)
 {
-	struct radeon_device *rdev = encoder->dev->dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
 
@@ -706,8 +705,6 @@ static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,
 		return;
 
 	radeon_audio_set_mute(encoder, true);
-	/* disable audio prior to setting up hw */
-	radeon_audio_enable(rdev, dig->afmt->pin, 0);
 
 	radeon_audio_set_dto(encoder, mode->clock);
 	radeon_audio_set_vbi_packet(encoder);
@@ -719,8 +716,6 @@ static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,
 	if (radeon_audio_set_avi_packet(encoder, mode) < 0)
 		return;
 
-	/* enable audio after to setting up hw */
-	radeon_audio_enable(rdev, dig->afmt->pin, 0xf);
 	radeon_audio_set_mute(encoder, false);
 }
 
@@ -735,18 +730,12 @@ static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,
 	if (!dig || !dig->afmt)
 		return;
 
-	/* disable audio prior to setting up hw */
-	radeon_audio_enable(rdev, dig->afmt->pin, 0);
-
 	radeon_audio_set_dto(encoder, rdev->clock.default_dispclk * 10);
 	radeon_audio_set_audio_packet(encoder);
 	radeon_audio_select_pin(encoder);
 
 	if (radeon_audio_set_avi_packet(encoder, mode) < 0)
 		return;
-
-	/* enable audio after to setting up hw */
-	radeon_audio_enable(rdev, dig->afmt->pin, 0xf);
 }
 
 void radeon_audio_mode_set(struct drm_encoder *encoder,

commit 88af339f9fe285cb93c264adc75545a3d3b50470
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Feb 27 10:38:40 2015 -0500

    drm/radeon/audio: set mute around state setup
    
    To avoid possible sound artifacts while setting up audio.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 713949487a66..5b579582175b 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -705,13 +705,13 @@ static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,
 	if (!dig || !dig->afmt)
 		return;
 
+	radeon_audio_set_mute(encoder, true);
 	/* disable audio prior to setting up hw */
 	radeon_audio_enable(rdev, dig->afmt->pin, 0);
 
 	radeon_audio_set_dto(encoder, mode->clock);
 	radeon_audio_set_vbi_packet(encoder);
 	radeon_hdmi_set_color_depth(encoder);
-	radeon_audio_set_mute(encoder, false);
 	radeon_audio_update_acr(encoder, mode->clock);
 	radeon_audio_set_audio_packet(encoder);
 	radeon_audio_select_pin(encoder);
@@ -721,6 +721,7 @@ static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,
 
 	/* enable audio after to setting up hw */
 	radeon_audio_enable(rdev, dig->afmt->pin, 0xf);
+	radeon_audio_set_mute(encoder, false);
 }
 
 static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,

commit d3c34d2c73481c39378dd91ec531564bb67a50df
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Feb 27 10:36:39 2015 -0500

    drm/radeon: assign pin in detect
    
    We need the pin from detect on, it's too late in dpms.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index e4bb81245b9b..713949487a66 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -452,7 +452,7 @@ void radeon_audio_enable(struct radeon_device *rdev,
 }
 
 void radeon_audio_detect(struct drm_connector *connector,
-	enum drm_connector_status status)
+			 enum drm_connector_status status)
 {
 	struct radeon_device *rdev;
 	struct radeon_encoder *radeon_encoder;
@@ -483,6 +483,7 @@ void radeon_audio_detect(struct drm_connector *connector,
 		else
 			radeon_encoder->audio = rdev->audio.hdmi_funcs;
 
+		dig->afmt->pin = radeon_audio_get_pin(connector->encoder);
 		radeon_audio_write_speaker_allocation(connector->encoder);
 		radeon_audio_write_sad_regs(connector->encoder);
 		if (connector->encoder->crtc)
@@ -491,6 +492,7 @@ void radeon_audio_detect(struct drm_connector *connector,
 		radeon_audio_enable(rdev, dig->afmt->pin, 0xf);
 	} else {
 		radeon_audio_enable(rdev, dig->afmt->pin, 0);
+		dig->afmt->pin = NULL;
 	}
 }
 
@@ -704,7 +706,6 @@ static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,
 		return;
 
 	/* disable audio prior to setting up hw */
-	dig->afmt->pin = radeon_audio_get_pin(encoder);
 	radeon_audio_enable(rdev, dig->afmt->pin, 0);
 
 	radeon_audio_set_dto(encoder, mode->clock);
@@ -734,7 +735,6 @@ static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,
 		return;
 
 	/* disable audio prior to setting up hw */
-	dig->afmt->pin = radeon_audio_get_pin(encoder);
 	radeon_audio_enable(rdev, dig->afmt->pin, 0);
 
 	radeon_audio_set_dto(encoder, rdev->clock.default_dispclk * 10);

commit add7d7596612bac594201da151a3ed6f8e94fc33
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Feb 27 10:04:11 2015 -0500

    drm/radeon: fix the audio dpms callbacks
    
    Don't touch the audio enable bits as these are already
    handled in display detection.  Enable the hdmi secondary
    streams in hdmi enable to match dp.  Rename dp dpms
    callback to be consistent with hdmi.
    
    bug:
    https://bugs.freedesktop.org/show_bug.cgi?id=89327
    https://bugzilla.kernel.org/show_bug.cgi?id=93921
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index a3ceef6d9632..e4bb81245b9b 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -101,8 +101,8 @@ static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,
 	struct drm_display_mode *mode);
 void r600_hdmi_enable(struct drm_encoder *encoder, bool enable);
 void evergreen_hdmi_enable(struct drm_encoder *encoder, bool enable);
-void evergreen_enable_dp_audio_packets(struct drm_encoder *encoder, bool enable);
-void dce6_enable_dp_audio_packets(struct drm_encoder *encoder, bool enable);
+void evergreen_dp_enable(struct drm_encoder *encoder, bool enable);
+void dce6_dp_enable(struct drm_encoder *encoder, bool enable);
 
 static const u32 pin_offsets[7] =
 {
@@ -210,7 +210,7 @@ static struct radeon_audio_funcs dce4_dp_funcs = {
 	.set_avi_packet = evergreen_set_avi_packet,
 	.set_audio_packet = dce4_set_audio_packet,
 	.mode_set = radeon_audio_dp_mode_set,
-	.dpms = evergreen_enable_dp_audio_packets,
+	.dpms = evergreen_dp_enable,
 };
 
 static struct radeon_audio_funcs dce6_hdmi_funcs = {
@@ -240,7 +240,7 @@ static struct radeon_audio_funcs dce6_dp_funcs = {
 	.set_avi_packet = evergreen_set_avi_packet,
 	.set_audio_packet = dce4_set_audio_packet,
 	.mode_set = radeon_audio_dp_mode_set,
-	.dpms = dce6_enable_dp_audio_packets,
+	.dpms = dce6_dp_enable,
 };
 
 static void radeon_audio_interface_init(struct radeon_device *rdev)

commit 308de41ba3bde80d50833718a2e37e49be868f5a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Jan 14 17:20:10 2015 -0500

    drm/radeon: use NULL rather then 0 in audio detect
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 8b4352d206b0..a3ceef6d9632 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -470,7 +470,7 @@ void radeon_audio_detect(struct drm_connector *connector,
 		int sink_type;
 
 		if (!drm_detect_monitor_audio(radeon_connector_edid(connector))) {
-			radeon_encoder->audio = 0;
+			radeon_encoder->audio = NULL;
 			return;
 		}
 

commit f4c6c08182b3f648b788422f27926f097759b0eb
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jan 13 12:41:40 2015 -0500

    drm/radeon: whitespace clean up in radeon_audio.c
    
    Clean up some formatting in radeon_audio.c to be
    more consistent with the rest of the driver.
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 192a614255e9..8b4352d206b0 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -367,36 +367,36 @@ static void radeon_audio_write_sad_regs(struct drm_encoder *encoder)
 static void radeon_audio_write_speaker_allocation(struct drm_encoder *encoder)
 {
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
-    struct drm_connector *connector;
-    struct radeon_connector *radeon_connector = NULL;
-    u8 *sadb = NULL;
-    int sad_count;
+	struct drm_connector *connector;
+	struct radeon_connector *radeon_connector = NULL;
+	u8 *sadb = NULL;
+	int sad_count;
 
-    list_for_each_entry(connector,
-		&encoder->dev->mode_config.connector_list, head) {
-        if (connector->encoder == encoder) {
-            radeon_connector = to_radeon_connector(connector);
-            break;
-        }
-    }
-
-    if (!radeon_connector) {
-        DRM_ERROR("Couldn't find encoder's connector\n");
-        return;
-    }
-
-    sad_count = drm_edid_to_speaker_allocation(
+	list_for_each_entry(connector,
+			    &encoder->dev->mode_config.connector_list, head) {
+		if (connector->encoder == encoder) {
+			radeon_connector = to_radeon_connector(connector);
+			break;
+		}
+	}
+
+	if (!radeon_connector) {
+		DRM_ERROR("Couldn't find encoder's connector\n");
+		return;
+	}
+
+	sad_count = drm_edid_to_speaker_allocation(
 		radeon_connector_edid(connector), &sadb);
-    if (sad_count < 0) {
-        DRM_DEBUG("Couldn't read Speaker Allocation Data Block: %d\n",
-			sad_count);
-        sad_count = 0;
-    }
+	if (sad_count < 0) {
+		DRM_DEBUG("Couldn't read Speaker Allocation Data Block: %d\n",
+			  sad_count);
+		sad_count = 0;
+	}
 
 	if (radeon_encoder->audio && radeon_encoder->audio->write_speaker_allocation)
 		radeon_encoder->audio->write_speaker_allocation(encoder, sadb, sad_count);
 
-    kfree(sadb);
+	kfree(sadb);
 }
 
 static void radeon_audio_write_latency_fields(struct drm_encoder *encoder,
@@ -520,7 +520,7 @@ static void radeon_audio_set_dto(struct drm_encoder *encoder, unsigned int clock
 static int radeon_audio_set_avi_packet(struct drm_encoder *encoder,
 	struct drm_display_mode *mode)
 {
-    struct radeon_device *rdev = encoder->dev->dev_private;
+	struct radeon_device *rdev = encoder->dev->dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
 	u8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AVI_INFOFRAME_SIZE];
@@ -625,9 +625,9 @@ static const struct radeon_hdmi_acr* radeon_audio_acr(unsigned int clock)
  */
 static void radeon_audio_update_acr(struct drm_encoder *encoder, unsigned int clock)
 {
-    const struct radeon_hdmi_acr *acr = radeon_audio_acr(clock);
-    struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
-    struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
+	const struct radeon_hdmi_acr *acr = radeon_audio_acr(clock);
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+	struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
 
 	if (!dig || !dig->afmt)
 		return;
@@ -638,8 +638,8 @@ static void radeon_audio_update_acr(struct drm_encoder *encoder, unsigned int cl
 
 static void radeon_audio_set_vbi_packet(struct drm_encoder *encoder)
 {
-    struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
-    struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+	struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
 
 	if (!dig || !dig->afmt)
 		return;
@@ -668,8 +668,8 @@ static void radeon_hdmi_set_color_depth(struct drm_encoder *encoder)
 
 static void radeon_audio_set_audio_packet(struct drm_encoder *encoder)
 {
-    struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
-    struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+	struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
 
 	if (!dig || !dig->afmt)
 		return;
@@ -680,8 +680,8 @@ static void radeon_audio_set_audio_packet(struct drm_encoder *encoder)
 
 static void radeon_audio_set_mute(struct drm_encoder *encoder, bool mute)
 {
-    struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
-    struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+	struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
 
 	if (!dig || !dig->afmt)
 		return;
@@ -696,7 +696,7 @@ static void radeon_audio_set_mute(struct drm_encoder *encoder, bool mute)
 static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,
 	struct drm_display_mode *mode)
 {
-    struct radeon_device *rdev = encoder->dev->dev_private;
+	struct radeon_device *rdev = encoder->dev->dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
 

commit e55bca26188e45f209597abf986c87cc5a49894a
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Fri Dec 12 17:01:42 2014 -0500

    radeon/audio: enable DP audio
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index f1e22a857da9..192a614255e9 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -97,8 +97,12 @@ void dce3_2_set_mute(struct drm_encoder *encoder, u32 offset, bool mute);
 void dce4_set_mute(struct drm_encoder *encoder, u32 offset, bool mute);
 static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,
 	struct drm_display_mode *mode);
+static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,
+	struct drm_display_mode *mode);
 void r600_hdmi_enable(struct drm_encoder *encoder, bool enable);
 void evergreen_hdmi_enable(struct drm_encoder *encoder, bool enable);
+void evergreen_enable_dp_audio_packets(struct drm_encoder *encoder, bool enable);
+void dce6_enable_dp_audio_packets(struct drm_encoder *encoder, bool enable);
 
 static const u32 pin_offsets[7] =
 {
@@ -178,6 +182,7 @@ static struct radeon_audio_funcs dce32_dp_funcs = {
 	.write_speaker_allocation = dce3_2_afmt_dp_write_speaker_allocation,
 	.set_dto = dce3_2_audio_set_dto,
 	.set_avi_packet = r600_set_avi_packet,
+	.set_audio_packet = dce3_2_set_audio_packet,
 };
 
 static struct radeon_audio_funcs dce4_hdmi_funcs = {
@@ -203,6 +208,9 @@ static struct radeon_audio_funcs dce4_dp_funcs = {
 	.write_latency_fields = dce4_afmt_write_latency_fields,
 	.set_dto = dce4_dp_audio_set_dto,
 	.set_avi_packet = evergreen_set_avi_packet,
+	.set_audio_packet = dce4_set_audio_packet,
+	.mode_set = radeon_audio_dp_mode_set,
+	.dpms = evergreen_enable_dp_audio_packets,
 };
 
 static struct radeon_audio_funcs dce6_hdmi_funcs = {
@@ -230,6 +238,9 @@ static struct radeon_audio_funcs dce6_dp_funcs = {
 	.write_latency_fields = dce6_afmt_write_latency_fields,
 	.set_dto = dce6_dp_audio_set_dto,
 	.set_avi_packet = evergreen_set_avi_packet,
+	.set_audio_packet = dce4_set_audio_packet,
+	.mode_set = radeon_audio_dp_mode_set,
+	.dpms = dce6_enable_dp_audio_packets,
 };
 
 static void radeon_audio_interface_init(struct radeon_device *rdev)
@@ -711,6 +722,32 @@ static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,
 	radeon_audio_enable(rdev, dig->afmt->pin, 0xf);
 }
 
+static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,
+	struct drm_display_mode *mode)
+{
+	struct drm_device *dev = encoder->dev;
+	struct radeon_device *rdev = dev->dev_private;
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+	struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
+
+	if (!dig || !dig->afmt)
+		return;
+
+	/* disable audio prior to setting up hw */
+	dig->afmt->pin = radeon_audio_get_pin(encoder);
+	radeon_audio_enable(rdev, dig->afmt->pin, 0);
+
+	radeon_audio_set_dto(encoder, rdev->clock.default_dispclk * 10);
+	radeon_audio_set_audio_packet(encoder);
+	radeon_audio_select_pin(encoder);
+
+	if (radeon_audio_set_avi_packet(encoder, mode) < 0)
+		return;
+
+	/* enable audio after to setting up hw */
+	radeon_audio_enable(rdev, dig->afmt->pin, 0xf);
+}
+
 void radeon_audio_mode_set(struct drm_encoder *encoder,
 	struct drm_display_mode *mode)
 {

commit ccd4be7eb7ef2aac076b604c716f36aa926651e3
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Thu Dec 11 13:11:29 2014 -0500

    radeon/audio: moved audio caps programming to audio_hotplug() function
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 4a2774ac7827..f1e22a857da9 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -302,38 +302,6 @@ int radeon_audio_init(struct radeon_device *rdev)
 	return 0;
 }
 
-void radeon_audio_detect(struct drm_connector *connector,
-	enum drm_connector_status status)
-{
-	if (!connector || !connector->encoder)
-		return;
-
-	if (status == connector_status_connected) {
-		int sink_type;
-		struct radeon_device *rdev = connector->encoder->dev->dev_private;
-		struct radeon_connector *radeon_connector;
-		struct radeon_encoder *radeon_encoder =
-			to_radeon_encoder(connector->encoder);
-
-		if (!drm_detect_monitor_audio(radeon_connector_edid(connector))) {
-			radeon_encoder->audio = 0;
-			return;
-		}
-
-		radeon_connector = to_radeon_connector(connector);
-		sink_type = radeon_dp_getsinktype(radeon_connector);
-
-		if (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort &&
-			sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT)
-			radeon_encoder->audio = rdev->audio.dp_funcs;
-		else
-			radeon_encoder->audio = rdev->audio.hdmi_funcs;
-		/* TODO: set up the sads, etc. and set the audio enable_mask */
-	} else {
-		/* TODO: reset the audio enable_mask */
-	}
-}
-
 u32 radeon_audio_endpoint_rreg(struct radeon_device *rdev, u32 offset, u32 reg)
 {
 	if (rdev->audio.funcs->endpoint_rreg)
@@ -472,6 +440,49 @@ void radeon_audio_enable(struct radeon_device *rdev,
 		rdev->audio.funcs->enable(rdev, pin, enable_mask);
 }
 
+void radeon_audio_detect(struct drm_connector *connector,
+	enum drm_connector_status status)
+{
+	struct radeon_device *rdev;
+	struct radeon_encoder *radeon_encoder;
+	struct radeon_encoder_atom_dig *dig;
+
+	if (!connector || !connector->encoder)
+		return;
+
+	rdev = connector->encoder->dev->dev_private;
+	radeon_encoder = to_radeon_encoder(connector->encoder);
+	dig = radeon_encoder->enc_priv;
+
+	if (status == connector_status_connected) {
+		struct radeon_connector *radeon_connector;
+		int sink_type;
+
+		if (!drm_detect_monitor_audio(radeon_connector_edid(connector))) {
+			radeon_encoder->audio = 0;
+			return;
+		}
+
+		radeon_connector = to_radeon_connector(connector);
+		sink_type = radeon_dp_getsinktype(radeon_connector);
+
+		if (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort &&
+			sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT)
+			radeon_encoder->audio = rdev->audio.dp_funcs;
+		else
+			radeon_encoder->audio = rdev->audio.hdmi_funcs;
+
+		radeon_audio_write_speaker_allocation(connector->encoder);
+		radeon_audio_write_sad_regs(connector->encoder);
+		if (connector->encoder->crtc)
+			radeon_audio_write_latency_fields(connector->encoder,
+				&connector->encoder->crtc->mode);
+		radeon_audio_enable(rdev, dig->afmt->pin, 0xf);
+	} else {
+		radeon_audio_enable(rdev, dig->afmt->pin, 0);
+	}
+}
+
 void radeon_audio_fini(struct radeon_device *rdev)
 {
 	int i;
@@ -690,11 +701,8 @@ static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,
 	radeon_hdmi_set_color_depth(encoder);
 	radeon_audio_set_mute(encoder, false);
 	radeon_audio_update_acr(encoder, mode->clock);
-	radeon_audio_write_speaker_allocation(encoder);
 	radeon_audio_set_audio_packet(encoder);
 	radeon_audio_select_pin(encoder);
-	radeon_audio_write_sad_regs(encoder);
-	radeon_audio_write_latency_fields(encoder, mode);
 
 	if (radeon_audio_set_avi_packet(encoder, mode) < 0)
 		return;

commit 6f945693be7eea24b1a8e5ce252a96df98d55a5c
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Wed Dec 10 14:52:43 2014 -0500

    radeon/audio: applied audio_dpms() and audio_mode_set() calls
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 05c7ffed6996..4a2774ac7827 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -97,6 +97,8 @@ void dce3_2_set_mute(struct drm_encoder *encoder, u32 offset, bool mute);
 void dce4_set_mute(struct drm_encoder *encoder, u32 offset, bool mute);
 static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,
 	struct drm_display_mode *mode);
+void r600_hdmi_enable(struct drm_encoder *encoder, bool enable);
+void evergreen_hdmi_enable(struct drm_encoder *encoder, bool enable);
 
 static const u32 pin_offsets[7] =
 {
@@ -153,6 +155,7 @@ static struct radeon_audio_funcs r600_hdmi_funcs = {
 	.set_audio_packet = r600_set_audio_packet,
 	.set_mute = r600_set_mute,
 	.mode_set = radeon_audio_hdmi_mode_set,
+	.dpms = r600_hdmi_enable,
 };
 
 static struct radeon_audio_funcs dce32_hdmi_funcs = {
@@ -166,6 +169,7 @@ static struct radeon_audio_funcs dce32_hdmi_funcs = {
 	.set_audio_packet = dce3_2_set_audio_packet,
 	.set_mute = dce3_2_set_mute,
 	.mode_set = radeon_audio_hdmi_mode_set,
+	.dpms = r600_hdmi_enable,
 };
 
 static struct radeon_audio_funcs dce32_dp_funcs = {
@@ -189,6 +193,7 @@ static struct radeon_audio_funcs dce4_hdmi_funcs = {
 	.set_audio_packet = dce4_set_audio_packet,
 	.set_mute = dce4_set_mute,
 	.mode_set = radeon_audio_hdmi_mode_set,
+	.dpms = evergreen_hdmi_enable,
 };
 
 static struct radeon_audio_funcs dce4_dp_funcs = {
@@ -214,6 +219,7 @@ static struct radeon_audio_funcs dce6_hdmi_funcs = {
 	.set_audio_packet = dce4_set_audio_packet,
 	.set_mute = dce4_set_mute,
 	.mode_set = radeon_audio_hdmi_mode_set,
+	.dpms = evergreen_hdmi_enable,
 };
 
 static struct radeon_audio_funcs dce6_dp_funcs = {
@@ -705,3 +711,11 @@ void radeon_audio_mode_set(struct drm_encoder *encoder,
 	if (radeon_encoder->audio && radeon_encoder->audio->mode_set)
 		radeon_encoder->audio->mode_set(encoder, mode);
 }
+
+void radeon_audio_dpms(struct drm_encoder *encoder, int mode)
+{
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+
+	if (radeon_encoder->audio && radeon_encoder->audio->dpms)
+		radeon_encoder->audio->dpms(encoder, mode == DRM_MODE_DPMS_ON);
+}

commit 6e72376dcc663e4b8a00cdd08f61a8623f572ef1
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Wed Dec 10 10:43:51 2014 -0500

    radeon/audio: consolidate audio_mode_set() functions
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 3aa5d111f650..05c7ffed6996 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -95,6 +95,8 @@ void dce4_set_audio_packet(struct drm_encoder *encoder, u32 offset);
 void r600_set_mute(struct drm_encoder *encoder, u32 offset, bool mute);
 void dce3_2_set_mute(struct drm_encoder *encoder, u32 offset, bool mute);
 void dce4_set_mute(struct drm_encoder *encoder, u32 offset, bool mute);
+static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,
+	struct drm_display_mode *mode);
 
 static const u32 pin_offsets[7] =
 {
@@ -150,6 +152,7 @@ static struct radeon_audio_funcs r600_hdmi_funcs = {
 	.set_avi_packet = r600_set_avi_packet,
 	.set_audio_packet = r600_set_audio_packet,
 	.set_mute = r600_set_mute,
+	.mode_set = radeon_audio_hdmi_mode_set,
 };
 
 static struct radeon_audio_funcs dce32_hdmi_funcs = {
@@ -162,6 +165,7 @@ static struct radeon_audio_funcs dce32_hdmi_funcs = {
 	.set_avi_packet = r600_set_avi_packet,
 	.set_audio_packet = dce3_2_set_audio_packet,
 	.set_mute = dce3_2_set_mute,
+	.mode_set = radeon_audio_hdmi_mode_set,
 };
 
 static struct radeon_audio_funcs dce32_dp_funcs = {
@@ -184,6 +188,7 @@ static struct radeon_audio_funcs dce4_hdmi_funcs = {
 	.set_avi_packet = evergreen_set_avi_packet,
 	.set_audio_packet = dce4_set_audio_packet,
 	.set_mute = dce4_set_mute,
+	.mode_set = radeon_audio_hdmi_mode_set,
 };
 
 static struct radeon_audio_funcs dce4_dp_funcs = {
@@ -208,6 +213,7 @@ static struct radeon_audio_funcs dce6_hdmi_funcs = {
 	.set_avi_packet = evergreen_set_avi_packet,
 	.set_audio_packet = dce4_set_audio_packet,
 	.set_mute = dce4_set_mute,
+	.mode_set = radeon_audio_hdmi_mode_set,
 };
 
 static struct radeon_audio_funcs dce6_dp_funcs = {
@@ -337,7 +343,7 @@ void radeon_audio_endpoint_wreg(struct radeon_device *rdev, u32 offset,
 		rdev->audio.funcs->endpoint_wreg(rdev, offset, reg, v);
 }
 
-void radeon_audio_write_sad_regs(struct drm_encoder *encoder)
+static void radeon_audio_write_sad_regs(struct drm_encoder *encoder)
 {
 	struct radeon_encoder *radeon_encoder;
 	struct drm_connector *connector;
@@ -373,7 +379,7 @@ void radeon_audio_write_sad_regs(struct drm_encoder *encoder)
 	kfree(sads);
 }
 
-void radeon_audio_write_speaker_allocation(struct drm_encoder *encoder)
+static void radeon_audio_write_speaker_allocation(struct drm_encoder *encoder)
 {
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
     struct drm_connector *connector;
@@ -408,7 +414,7 @@ void radeon_audio_write_speaker_allocation(struct drm_encoder *encoder)
     kfree(sadb);
 }
 
-void radeon_audio_write_latency_fields(struct drm_encoder *encoder,
+static void radeon_audio_write_latency_fields(struct drm_encoder *encoder,
 	struct drm_display_mode *mode)
 {
 	struct radeon_encoder *radeon_encoder;
@@ -445,7 +451,7 @@ struct r600_audio_pin* radeon_audio_get_pin(struct drm_encoder *encoder)
 	return NULL;
 }
 
-void radeon_audio_select_pin(struct drm_encoder *encoder)
+static void radeon_audio_select_pin(struct drm_encoder *encoder)
 {
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 
@@ -473,7 +479,7 @@ void radeon_audio_fini(struct radeon_device *rdev)
 	rdev->audio.enabled = false;
 }
 
-void radeon_audio_set_dto(struct drm_encoder *encoder, unsigned int clock)
+static void radeon_audio_set_dto(struct drm_encoder *encoder, unsigned int clock)
 {
 	struct radeon_device *rdev = encoder->dev->dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
@@ -483,7 +489,7 @@ void radeon_audio_set_dto(struct drm_encoder *encoder, unsigned int clock)
 		radeon_encoder->audio->set_dto(rdev, crtc, clock);
 }
 
-int radeon_audio_set_avi_packet(struct drm_encoder *encoder,
+static int radeon_audio_set_avi_packet(struct drm_encoder *encoder,
 	struct drm_display_mode *mode)
 {
     struct radeon_device *rdev = encoder->dev->dev_private;
@@ -589,7 +595,7 @@ static const struct radeon_hdmi_acr* radeon_audio_acr(unsigned int clock)
 /*
  * update the N and CTS parameters for a given pixel clock rate
  */
-void radeon_audio_update_acr(struct drm_encoder *encoder, unsigned int clock)
+static void radeon_audio_update_acr(struct drm_encoder *encoder, unsigned int clock)
 {
     const struct radeon_hdmi_acr *acr = radeon_audio_acr(clock);
     struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
@@ -602,7 +608,7 @@ void radeon_audio_update_acr(struct drm_encoder *encoder, unsigned int clock)
 		radeon_encoder->audio->update_acr(encoder, dig->afmt->offset, acr);
 }
 
-void radeon_audio_set_vbi_packet(struct drm_encoder *encoder)
+static void radeon_audio_set_vbi_packet(struct drm_encoder *encoder)
 {
     struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
     struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
@@ -614,7 +620,7 @@ void radeon_audio_set_vbi_packet(struct drm_encoder *encoder)
 		radeon_encoder->audio->set_vbi_packet(encoder, dig->afmt->offset);
 }
 
-void radeon_hdmi_set_color_depth(struct drm_encoder *encoder)
+static void radeon_hdmi_set_color_depth(struct drm_encoder *encoder)
 {
 	int bpc = 8;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
@@ -632,7 +638,7 @@ void radeon_hdmi_set_color_depth(struct drm_encoder *encoder)
 		radeon_encoder->audio->set_color_depth(encoder, dig->afmt->offset, bpc);
 }
 
-void radeon_audio_set_audio_packet(struct drm_encoder *encoder)
+static void radeon_audio_set_audio_packet(struct drm_encoder *encoder)
 {
     struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
     struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
@@ -644,7 +650,7 @@ void radeon_audio_set_audio_packet(struct drm_encoder *encoder)
 		radeon_encoder->audio->set_audio_packet(encoder, dig->afmt->offset);
 }
 
-void radeon_audio_set_mute(struct drm_encoder *encoder, bool mute)
+static void radeon_audio_set_mute(struct drm_encoder *encoder, bool mute)
 {
     struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
     struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
@@ -655,3 +661,47 @@ void radeon_audio_set_mute(struct drm_encoder *encoder, bool mute)
 	if (radeon_encoder->audio && radeon_encoder->audio->set_mute)
 		radeon_encoder->audio->set_mute(encoder, dig->afmt->offset, mute);
 }
+
+/*
+ * update the info frames with the data from the current display mode
+ */
+static void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,
+	struct drm_display_mode *mode)
+{
+    struct radeon_device *rdev = encoder->dev->dev_private;
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+	struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
+
+	if (!dig || !dig->afmt)
+		return;
+
+	/* disable audio prior to setting up hw */
+	dig->afmt->pin = radeon_audio_get_pin(encoder);
+	radeon_audio_enable(rdev, dig->afmt->pin, 0);
+
+	radeon_audio_set_dto(encoder, mode->clock);
+	radeon_audio_set_vbi_packet(encoder);
+	radeon_hdmi_set_color_depth(encoder);
+	radeon_audio_set_mute(encoder, false);
+	radeon_audio_update_acr(encoder, mode->clock);
+	radeon_audio_write_speaker_allocation(encoder);
+	radeon_audio_set_audio_packet(encoder);
+	radeon_audio_select_pin(encoder);
+	radeon_audio_write_sad_regs(encoder);
+	radeon_audio_write_latency_fields(encoder, mode);
+
+	if (radeon_audio_set_avi_packet(encoder, mode) < 0)
+		return;
+
+	/* enable audio after to setting up hw */
+	radeon_audio_enable(rdev, dig->afmt->pin, 0xf);
+}
+
+void radeon_audio_mode_set(struct drm_encoder *encoder,
+	struct drm_display_mode *mode)
+{
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+
+	if (radeon_encoder->audio && radeon_encoder->audio->mode_set)
+		radeon_encoder->audio->mode_set(encoder, mode);
+}

commit 3be2e7d0e705621c1bb41eeabb63b122d50ecff3
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Tue Dec 9 17:17:35 2014 -0500

    radeon/audio: moved mute programming to a separate function
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index e29d6552bb62..3aa5d111f650 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -92,6 +92,9 @@ void dce4_hdmi_set_color_depth(struct drm_encoder *encoder,
 void r600_set_audio_packet(struct drm_encoder *encoder, u32 offset);
 void dce3_2_set_audio_packet(struct drm_encoder *encoder, u32 offset);
 void dce4_set_audio_packet(struct drm_encoder *encoder, u32 offset);
+void r600_set_mute(struct drm_encoder *encoder, u32 offset, bool mute);
+void dce3_2_set_mute(struct drm_encoder *encoder, u32 offset, bool mute);
+void dce4_set_mute(struct drm_encoder *encoder, u32 offset, bool mute);
 
 static const u32 pin_offsets[7] =
 {
@@ -146,6 +149,7 @@ static struct radeon_audio_funcs r600_hdmi_funcs = {
 	.set_vbi_packet = r600_set_vbi_packet,
 	.set_avi_packet = r600_set_avi_packet,
 	.set_audio_packet = r600_set_audio_packet,
+	.set_mute = r600_set_mute,
 };
 
 static struct radeon_audio_funcs dce32_hdmi_funcs = {
@@ -157,6 +161,7 @@ static struct radeon_audio_funcs dce32_hdmi_funcs = {
 	.set_vbi_packet = r600_set_vbi_packet,
 	.set_avi_packet = r600_set_avi_packet,
 	.set_audio_packet = dce3_2_set_audio_packet,
+	.set_mute = dce3_2_set_mute,
 };
 
 static struct radeon_audio_funcs dce32_dp_funcs = {
@@ -178,6 +183,7 @@ static struct radeon_audio_funcs dce4_hdmi_funcs = {
 	.set_color_depth = dce4_hdmi_set_color_depth,
 	.set_avi_packet = evergreen_set_avi_packet,
 	.set_audio_packet = dce4_set_audio_packet,
+	.set_mute = dce4_set_mute,
 };
 
 static struct radeon_audio_funcs dce4_dp_funcs = {
@@ -201,6 +207,7 @@ static struct radeon_audio_funcs dce6_hdmi_funcs = {
 	.set_color_depth = dce4_hdmi_set_color_depth,
 	.set_avi_packet = evergreen_set_avi_packet,
 	.set_audio_packet = dce4_set_audio_packet,
+	.set_mute = dce4_set_mute,
 };
 
 static struct radeon_audio_funcs dce6_dp_funcs = {
@@ -636,3 +643,15 @@ void radeon_audio_set_audio_packet(struct drm_encoder *encoder)
 	if (radeon_encoder->audio && radeon_encoder->audio->set_audio_packet)
 		radeon_encoder->audio->set_audio_packet(encoder, dig->afmt->offset);
 }
+
+void radeon_audio_set_mute(struct drm_encoder *encoder, bool mute)
+{
+    struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+    struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
+
+	if (!dig || !dig->afmt)
+		return;
+
+	if (radeon_encoder->audio && radeon_encoder->audio->set_mute)
+		radeon_encoder->audio->set_mute(encoder, dig->afmt->offset, mute);
+}

commit 1852c9a09a25aad40c80b0012ad19379b1fb78be
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Tue Dec 9 16:44:18 2014 -0500

    radeon/audio: moved audio packet programming to a separate function
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index cafd2f8ec7c1..e29d6552bb62 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -89,6 +89,9 @@ void r600_set_vbi_packet(struct drm_encoder *encoder, u32 offset);
 void dce4_set_vbi_packet(struct drm_encoder *encoder, u32 offset);
 void dce4_hdmi_set_color_depth(struct drm_encoder *encoder,
 	u32 offset, int bpc);
+void r600_set_audio_packet(struct drm_encoder *encoder, u32 offset);
+void dce3_2_set_audio_packet(struct drm_encoder *encoder, u32 offset);
+void dce4_set_audio_packet(struct drm_encoder *encoder, u32 offset);
 
 static const u32 pin_offsets[7] =
 {
@@ -142,6 +145,7 @@ static struct radeon_audio_funcs r600_hdmi_funcs = {
 	.update_acr = r600_hdmi_update_acr,
 	.set_vbi_packet = r600_set_vbi_packet,
 	.set_avi_packet = r600_set_avi_packet,
+	.set_audio_packet = r600_set_audio_packet,
 };
 
 static struct radeon_audio_funcs dce32_hdmi_funcs = {
@@ -152,6 +156,7 @@ static struct radeon_audio_funcs dce32_hdmi_funcs = {
 	.update_acr = dce3_2_hdmi_update_acr,
 	.set_vbi_packet = r600_set_vbi_packet,
 	.set_avi_packet = r600_set_avi_packet,
+	.set_audio_packet = dce3_2_set_audio_packet,
 };
 
 static struct radeon_audio_funcs dce32_dp_funcs = {
@@ -172,6 +177,7 @@ static struct radeon_audio_funcs dce4_hdmi_funcs = {
 	.set_vbi_packet = dce4_set_vbi_packet,
 	.set_color_depth = dce4_hdmi_set_color_depth,
 	.set_avi_packet = evergreen_set_avi_packet,
+	.set_audio_packet = dce4_set_audio_packet,
 };
 
 static struct radeon_audio_funcs dce4_dp_funcs = {
@@ -194,6 +200,7 @@ static struct radeon_audio_funcs dce6_hdmi_funcs = {
 	.set_vbi_packet = dce4_set_vbi_packet,
 	.set_color_depth = dce4_hdmi_set_color_depth,
 	.set_avi_packet = evergreen_set_avi_packet,
+	.set_audio_packet = dce4_set_audio_packet,
 };
 
 static struct radeon_audio_funcs dce6_dp_funcs = {
@@ -617,3 +624,15 @@ void radeon_hdmi_set_color_depth(struct drm_encoder *encoder)
 	if (radeon_encoder->audio && radeon_encoder->audio->set_color_depth)
 		radeon_encoder->audio->set_color_depth(encoder, dig->afmt->offset, bpc);
 }
+
+void radeon_audio_set_audio_packet(struct drm_encoder *encoder)
+{
+    struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+    struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
+
+	if (!dig || !dig->afmt)
+		return;
+
+	if (radeon_encoder->audio && radeon_encoder->audio->set_audio_packet)
+		radeon_encoder->audio->set_audio_packet(encoder, dig->afmt->offset);
+}

commit baa7d8e451f030c049f83f943b9995620d6d6bd3
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Mon Dec 8 18:28:33 2014 -0500

    radeon/audio: set_avi_packet() function cleanup
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index ac9ebbfc48af..cafd2f8ec7c1 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -75,9 +75,9 @@ void dce6_hdmi_audio_set_dto(struct radeon_device *rdev,
 	struct radeon_crtc *crtc, unsigned int clock);
 void dce6_dp_audio_set_dto(struct radeon_device *rdev,
 	struct radeon_crtc *crtc, unsigned int clock);
-void r600_update_avi_infoframe(struct radeon_device *rdev, u32 offset,
+void r600_set_avi_packet(struct radeon_device *rdev, u32 offset,
 	unsigned char *buffer, size_t size);
-void evergreen_update_avi_infoframe(struct radeon_device *rdev, u32 offset,
+void evergreen_set_avi_packet(struct radeon_device *rdev, u32 offset,
 	unsigned char *buffer, size_t size);
 void r600_hdmi_update_acr(struct drm_encoder *encoder, long offset,
 	const struct radeon_hdmi_acr *acr);
@@ -116,28 +116,24 @@ static struct radeon_audio_basic_funcs r600_funcs = {
 	.endpoint_rreg = radeon_audio_rreg,
 	.endpoint_wreg = radeon_audio_wreg,
 	.enable = r600_audio_enable,
-	.update_avi_infoframe = r600_update_avi_infoframe,
 };
 
 static struct radeon_audio_basic_funcs dce32_funcs = {
 	.endpoint_rreg = radeon_audio_rreg,
 	.endpoint_wreg = radeon_audio_wreg,
 	.enable = r600_audio_enable,
-	.update_avi_infoframe = r600_update_avi_infoframe,
 };
 
 static struct radeon_audio_basic_funcs dce4_funcs = {
 	.endpoint_rreg = radeon_audio_rreg,
 	.endpoint_wreg = radeon_audio_wreg,
 	.enable = dce4_audio_enable,
-	.update_avi_infoframe = evergreen_update_avi_infoframe,
 };
 
 static struct radeon_audio_basic_funcs dce6_funcs = {
 	.endpoint_rreg = dce6_endpoint_rreg,
 	.endpoint_wreg = dce6_endpoint_wreg,
 	.enable = dce6_audio_enable,
-	.update_avi_infoframe = evergreen_update_avi_infoframe,
 };
 
 static struct radeon_audio_funcs r600_hdmi_funcs = {
@@ -145,6 +141,7 @@ static struct radeon_audio_funcs r600_hdmi_funcs = {
 	.set_dto = r600_hdmi_audio_set_dto,
 	.update_acr = r600_hdmi_update_acr,
 	.set_vbi_packet = r600_set_vbi_packet,
+	.set_avi_packet = r600_set_avi_packet,
 };
 
 static struct radeon_audio_funcs dce32_hdmi_funcs = {
@@ -154,6 +151,7 @@ static struct radeon_audio_funcs dce32_hdmi_funcs = {
 	.set_dto = dce3_2_audio_set_dto,
 	.update_acr = dce3_2_hdmi_update_acr,
 	.set_vbi_packet = r600_set_vbi_packet,
+	.set_avi_packet = r600_set_avi_packet,
 };
 
 static struct radeon_audio_funcs dce32_dp_funcs = {
@@ -161,6 +159,7 @@ static struct radeon_audio_funcs dce32_dp_funcs = {
 	.write_sad_regs = dce3_2_afmt_write_sad_regs,
 	.write_speaker_allocation = dce3_2_afmt_dp_write_speaker_allocation,
 	.set_dto = dce3_2_audio_set_dto,
+	.set_avi_packet = r600_set_avi_packet,
 };
 
 static struct radeon_audio_funcs dce4_hdmi_funcs = {
@@ -172,6 +171,7 @@ static struct radeon_audio_funcs dce4_hdmi_funcs = {
 	.update_acr = evergreen_hdmi_update_acr,
 	.set_vbi_packet = dce4_set_vbi_packet,
 	.set_color_depth = dce4_hdmi_set_color_depth,
+	.set_avi_packet = evergreen_set_avi_packet,
 };
 
 static struct radeon_audio_funcs dce4_dp_funcs = {
@@ -180,6 +180,7 @@ static struct radeon_audio_funcs dce4_dp_funcs = {
 	.write_speaker_allocation = dce4_afmt_dp_write_speaker_allocation,
 	.write_latency_fields = dce4_afmt_write_latency_fields,
 	.set_dto = dce4_dp_audio_set_dto,
+	.set_avi_packet = evergreen_set_avi_packet,
 };
 
 static struct radeon_audio_funcs dce6_hdmi_funcs = {
@@ -192,6 +193,7 @@ static struct radeon_audio_funcs dce6_hdmi_funcs = {
 	.update_acr = evergreen_hdmi_update_acr,
 	.set_vbi_packet = dce4_set_vbi_packet,
 	.set_color_depth = dce4_hdmi_set_color_depth,
+	.set_avi_packet = evergreen_set_avi_packet,
 };
 
 static struct radeon_audio_funcs dce6_dp_funcs = {
@@ -201,6 +203,7 @@ static struct radeon_audio_funcs dce6_dp_funcs = {
 	.write_speaker_allocation = dce6_afmt_dp_write_speaker_allocation,
 	.write_latency_fields = dce6_afmt_write_latency_fields,
 	.set_dto = dce6_dp_audio_set_dto,
+	.set_avi_packet = evergreen_set_avi_packet,
 };
 
 static void radeon_audio_interface_init(struct radeon_device *rdev)
@@ -466,16 +469,34 @@ void radeon_audio_set_dto(struct drm_encoder *encoder, unsigned int clock)
 		radeon_encoder->audio->set_dto(rdev, crtc, clock);
 }
 
-void radeon_update_avi_infoframe(struct drm_encoder *encoder, void *buffer,
-	size_t size)
+int radeon_audio_set_avi_packet(struct drm_encoder *encoder,
+	struct drm_display_mode *mode)
 {
     struct radeon_device *rdev = encoder->dev->dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
+	u8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AVI_INFOFRAME_SIZE];
+	struct hdmi_avi_infoframe frame;
+	int err;
+
+	err = drm_hdmi_avi_infoframe_from_display_mode(&frame, mode);
+	if (err < 0) {
+		DRM_ERROR("failed to setup AVI infoframe: %d\n", err);
+		return err;
+	}
+
+	err = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));
+	if (err < 0) {
+		DRM_ERROR("failed to pack AVI infoframe: %d\n", err);
+		return err;
+	}
+
+	if (dig && dig->afmt &&
+		radeon_encoder->audio && radeon_encoder->audio->set_avi_packet)
+		radeon_encoder->audio->set_avi_packet(rdev, dig->afmt->offset,
+			buffer, sizeof(buffer));
 
-	if (dig && dig->afmt && rdev->audio.funcs->update_avi_infoframe)
-		rdev->audio.funcs->update_avi_infoframe(rdev, dig->afmt->offset,
-			buffer, size);
+	return 0;
 }
 
 /*

commit be273e58f00f75c750fd0ece8f0d7c3cfb36c88e
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Mon Dec 8 16:25:37 2014 -0500

    radeon: moved HDMI color depth programming to a separate function
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 8fad9af92ec8..ac9ebbfc48af 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -87,6 +87,8 @@ void evergreen_hdmi_update_acr(struct drm_encoder *encoder, long offset,
 	const struct radeon_hdmi_acr *acr);
 void r600_set_vbi_packet(struct drm_encoder *encoder, u32 offset);
 void dce4_set_vbi_packet(struct drm_encoder *encoder, u32 offset);
+void dce4_hdmi_set_color_depth(struct drm_encoder *encoder,
+	u32 offset, int bpc);
 
 static const u32 pin_offsets[7] =
 {
@@ -169,6 +171,7 @@ static struct radeon_audio_funcs dce4_hdmi_funcs = {
 	.set_dto = dce4_hdmi_audio_set_dto,
 	.update_acr = evergreen_hdmi_update_acr,
 	.set_vbi_packet = dce4_set_vbi_packet,
+	.set_color_depth = dce4_hdmi_set_color_depth,
 };
 
 static struct radeon_audio_funcs dce4_dp_funcs = {
@@ -188,6 +191,7 @@ static struct radeon_audio_funcs dce6_hdmi_funcs = {
 	.set_dto = dce6_hdmi_audio_set_dto,
 	.update_acr = evergreen_hdmi_update_acr,
 	.set_vbi_packet = dce4_set_vbi_packet,
+	.set_color_depth = dce4_hdmi_set_color_depth,
 };
 
 static struct radeon_audio_funcs dce6_dp_funcs = {
@@ -574,3 +578,21 @@ void radeon_audio_set_vbi_packet(struct drm_encoder *encoder)
 	if (radeon_encoder->audio && radeon_encoder->audio->set_vbi_packet)
 		radeon_encoder->audio->set_vbi_packet(encoder, dig->afmt->offset);
 }
+
+void radeon_hdmi_set_color_depth(struct drm_encoder *encoder)
+{
+	int bpc = 8;
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+	struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
+
+	if (!dig || !dig->afmt)
+		return;
+
+	if (encoder->crtc) {
+		struct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);
+		bpc = radeon_crtc->bpc;
+	}
+
+	if (radeon_encoder->audio && radeon_encoder->audio->set_color_depth)
+		radeon_encoder->audio->set_color_depth(encoder, dig->afmt->offset, bpc);
+}

commit 930a9785120d7397ba8912e1a4f72b65e7e25f25
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jan 20 19:20:52 2015 -0500

    radeon/audio: moved VBI packet programming to separate functions
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index dbb3c594e9ae..8fad9af92ec8 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -85,6 +85,8 @@ void dce3_2_hdmi_update_acr(struct drm_encoder *encoder, long offset,
 	const struct radeon_hdmi_acr *acr);
 void evergreen_hdmi_update_acr(struct drm_encoder *encoder, long offset,
 	const struct radeon_hdmi_acr *acr);
+void r600_set_vbi_packet(struct drm_encoder *encoder, u32 offset);
+void dce4_set_vbi_packet(struct drm_encoder *encoder, u32 offset);
 
 static const u32 pin_offsets[7] =
 {
@@ -140,6 +142,7 @@ static struct radeon_audio_funcs r600_hdmi_funcs = {
 	.get_pin = r600_audio_get_pin,
 	.set_dto = r600_hdmi_audio_set_dto,
 	.update_acr = r600_hdmi_update_acr,
+	.set_vbi_packet = r600_set_vbi_packet,
 };
 
 static struct radeon_audio_funcs dce32_hdmi_funcs = {
@@ -148,6 +151,7 @@ static struct radeon_audio_funcs dce32_hdmi_funcs = {
 	.write_speaker_allocation = dce3_2_afmt_hdmi_write_speaker_allocation,
 	.set_dto = dce3_2_audio_set_dto,
 	.update_acr = dce3_2_hdmi_update_acr,
+	.set_vbi_packet = r600_set_vbi_packet,
 };
 
 static struct radeon_audio_funcs dce32_dp_funcs = {
@@ -164,6 +168,7 @@ static struct radeon_audio_funcs dce4_hdmi_funcs = {
 	.write_latency_fields = dce4_afmt_write_latency_fields,
 	.set_dto = dce4_hdmi_audio_set_dto,
 	.update_acr = evergreen_hdmi_update_acr,
+	.set_vbi_packet = dce4_set_vbi_packet,
 };
 
 static struct radeon_audio_funcs dce4_dp_funcs = {
@@ -182,6 +187,7 @@ static struct radeon_audio_funcs dce6_hdmi_funcs = {
 	.write_latency_fields = dce6_afmt_write_latency_fields,
 	.set_dto = dce6_hdmi_audio_set_dto,
 	.update_acr = evergreen_hdmi_update_acr,
+	.set_vbi_packet = dce4_set_vbi_packet,
 };
 
 static struct radeon_audio_funcs dce6_dp_funcs = {
@@ -556,3 +562,15 @@ void radeon_audio_update_acr(struct drm_encoder *encoder, unsigned int clock)
 	if (radeon_encoder->audio && radeon_encoder->audio->update_acr)
 		radeon_encoder->audio->update_acr(encoder, dig->afmt->offset, acr);
 }
+
+void radeon_audio_set_vbi_packet(struct drm_encoder *encoder)
+{
+    struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+    struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
+
+	if (!dig || !dig->afmt)
+		return;
+
+	if (radeon_encoder->audio && radeon_encoder->audio->set_vbi_packet)
+		radeon_encoder->audio->set_vbi_packet(encoder, dig->afmt->offset);
+}

commit 64424d6e45aeee311a4231def7e125bcc2de0855
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Sat Dec 6 20:19:16 2014 -0500

    radeon/audio: consolidate update_acr() functions (v2)
    
    V2: fix missing dce6 callback
    
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index cc58ee8c7d2f..dbb3c594e9ae 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -22,6 +22,7 @@
  * Authors: Slava Grigorev <slava.grigorev@amd.com>
  */
 
+#include <linux/gcd.h>
 #include <drm/drmP.h>
 #include <drm/drm_crtc.h>
 #include "radeon.h"
@@ -78,6 +79,12 @@ void r600_update_avi_infoframe(struct radeon_device *rdev, u32 offset,
 	unsigned char *buffer, size_t size);
 void evergreen_update_avi_infoframe(struct radeon_device *rdev, u32 offset,
 	unsigned char *buffer, size_t size);
+void r600_hdmi_update_acr(struct drm_encoder *encoder, long offset,
+	const struct radeon_hdmi_acr *acr);
+void dce3_2_hdmi_update_acr(struct drm_encoder *encoder, long offset,
+	const struct radeon_hdmi_acr *acr);
+void evergreen_hdmi_update_acr(struct drm_encoder *encoder, long offset,
+	const struct radeon_hdmi_acr *acr);
 
 static const u32 pin_offsets[7] =
 {
@@ -132,6 +139,7 @@ static struct radeon_audio_basic_funcs dce6_funcs = {
 static struct radeon_audio_funcs r600_hdmi_funcs = {
 	.get_pin = r600_audio_get_pin,
 	.set_dto = r600_hdmi_audio_set_dto,
+	.update_acr = r600_hdmi_update_acr,
 };
 
 static struct radeon_audio_funcs dce32_hdmi_funcs = {
@@ -139,6 +147,7 @@ static struct radeon_audio_funcs dce32_hdmi_funcs = {
 	.write_sad_regs = dce3_2_afmt_write_sad_regs,
 	.write_speaker_allocation = dce3_2_afmt_hdmi_write_speaker_allocation,
 	.set_dto = dce3_2_audio_set_dto,
+	.update_acr = dce3_2_hdmi_update_acr,
 };
 
 static struct radeon_audio_funcs dce32_dp_funcs = {
@@ -154,6 +163,7 @@ static struct radeon_audio_funcs dce4_hdmi_funcs = {
 	.write_speaker_allocation = dce4_afmt_hdmi_write_speaker_allocation,
 	.write_latency_fields = dce4_afmt_write_latency_fields,
 	.set_dto = dce4_hdmi_audio_set_dto,
+	.update_acr = evergreen_hdmi_update_acr,
 };
 
 static struct radeon_audio_funcs dce4_dp_funcs = {
@@ -171,6 +181,7 @@ static struct radeon_audio_funcs dce6_hdmi_funcs = {
 	.write_speaker_allocation = dce6_afmt_hdmi_write_speaker_allocation,
 	.write_latency_fields = dce6_afmt_write_latency_fields,
 	.set_dto = dce6_hdmi_audio_set_dto,
+	.update_acr = evergreen_hdmi_update_acr,
 };
 
 static struct radeon_audio_funcs dce6_dp_funcs = {
@@ -456,3 +467,92 @@ void radeon_update_avi_infoframe(struct drm_encoder *encoder, void *buffer,
 		rdev->audio.funcs->update_avi_infoframe(rdev, dig->afmt->offset,
 			buffer, size);
 }
+
+/*
+ * calculate CTS and N values if they are not found in the table
+ */
+static void radeon_audio_calc_cts(unsigned int clock, int *CTS, int *N, int freq)
+{
+	int n, cts;
+	unsigned long div, mul;
+
+	/* Safe, but overly large values */
+	n = 128 * freq;
+	cts = clock * 1000;
+
+	/* Smallest valid fraction */
+	div = gcd(n, cts);
+
+	n /= div;
+	cts /= div;
+
+	/*
+	 * The optimal N is 128*freq/1000. Calculate the closest larger
+	 * value that doesn't truncate any bits.
+	 */
+	mul = ((128*freq/1000) + (n-1))/n;
+
+	n *= mul;
+	cts *= mul;
+
+	/* Check that we are in spec (not always possible) */
+	if (n < (128*freq/1500))
+		printk(KERN_WARNING "Calculated ACR N value is too small. You may experience audio problems.\n");
+	if (n > (128*freq/300))
+		printk(KERN_WARNING "Calculated ACR N value is too large. You may experience audio problems.\n");
+
+	*N = n;
+	*CTS = cts;
+
+	DRM_DEBUG("Calculated ACR timing N=%d CTS=%d for frequency %d\n",
+		*N, *CTS, freq);
+}
+
+static const struct radeon_hdmi_acr* radeon_audio_acr(unsigned int clock)
+{
+	static struct radeon_hdmi_acr res;
+	u8 i;
+
+	static const struct radeon_hdmi_acr hdmi_predefined_acr[] = {
+		/*       32kHz    44.1kHz   48kHz    */
+		/* Clock      N     CTS      N     CTS      N     CTS */
+		{  25175,  4096,  25175, 28224, 125875,  6144,  25175 }, /*  25,20/1.001 MHz */
+		{  25200,  4096,  25200,  6272,  28000,  6144,  25200 }, /*  25.20       MHz */
+		{  27000,  4096,  27000,  6272,  30000,  6144,  27000 }, /*  27.00       MHz */
+		{  27027,  4096,  27027,  6272,  30030,  6144,  27027 }, /*  27.00*1.001 MHz */
+		{  54000,  4096,  54000,  6272,  60000,  6144,  54000 }, /*  54.00       MHz */
+		{  54054,  4096,  54054,  6272,  60060,  6144,  54054 }, /*  54.00*1.001 MHz */
+		{  74176,  4096,  74176,  5733,  75335,  6144,  74176 }, /*  74.25/1.001 MHz */
+		{  74250,  4096,  74250,  6272,  82500,  6144,  74250 }, /*  74.25       MHz */
+		{ 148352,  4096, 148352,  5733, 150670,  6144, 148352 }, /* 148.50/1.001 MHz */
+		{ 148500,  4096, 148500,  6272, 165000,  6144, 148500 }, /* 148.50       MHz */
+	};
+
+	/* Precalculated values for common clocks */
+	for (i = 0; i < ARRAY_SIZE(hdmi_predefined_acr); i++)
+		if (hdmi_predefined_acr[i].clock == clock)
+			return &hdmi_predefined_acr[i];
+
+	/* And odd clocks get manually calculated */
+	radeon_audio_calc_cts(clock, &res.cts_32khz, &res.n_32khz, 32000);
+	radeon_audio_calc_cts(clock, &res.cts_44_1khz, &res.n_44_1khz, 44100);
+	radeon_audio_calc_cts(clock, &res.cts_48khz, &res.n_48khz, 48000);
+
+	return &res;
+}
+
+/*
+ * update the N and CTS parameters for a given pixel clock rate
+ */
+void radeon_audio_update_acr(struct drm_encoder *encoder, unsigned int clock)
+{
+    const struct radeon_hdmi_acr *acr = radeon_audio_acr(clock);
+    struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+    struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
+
+	if (!dig || !dig->afmt)
+		return;
+
+	if (radeon_encoder->audio && radeon_encoder->audio->update_acr)
+		radeon_encoder->audio->update_acr(encoder, dig->afmt->offset, acr);
+}

commit 96ea7afbc256ce7e2b2446909f52dab357942c3c
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Fri Dec 5 17:59:56 2014 -0500

    radeon/audio: consolidate update_avi_infoframe() functions
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 2a2bf5b5b805..cc58ee8c7d2f 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -74,6 +74,10 @@ void dce6_hdmi_audio_set_dto(struct radeon_device *rdev,
 	struct radeon_crtc *crtc, unsigned int clock);
 void dce6_dp_audio_set_dto(struct radeon_device *rdev,
 	struct radeon_crtc *crtc, unsigned int clock);
+void r600_update_avi_infoframe(struct radeon_device *rdev, u32 offset,
+	unsigned char *buffer, size_t size);
+void evergreen_update_avi_infoframe(struct radeon_device *rdev, u32 offset,
+	unsigned char *buffer, size_t size);
 
 static const u32 pin_offsets[7] =
 {
@@ -101,24 +105,28 @@ static struct radeon_audio_basic_funcs r600_funcs = {
 	.endpoint_rreg = radeon_audio_rreg,
 	.endpoint_wreg = radeon_audio_wreg,
 	.enable = r600_audio_enable,
+	.update_avi_infoframe = r600_update_avi_infoframe,
 };
 
 static struct radeon_audio_basic_funcs dce32_funcs = {
 	.endpoint_rreg = radeon_audio_rreg,
 	.endpoint_wreg = radeon_audio_wreg,
 	.enable = r600_audio_enable,
+	.update_avi_infoframe = r600_update_avi_infoframe,
 };
 
 static struct radeon_audio_basic_funcs dce4_funcs = {
 	.endpoint_rreg = radeon_audio_rreg,
 	.endpoint_wreg = radeon_audio_wreg,
 	.enable = dce4_audio_enable,
+	.update_avi_infoframe = evergreen_update_avi_infoframe,
 };
 
 static struct radeon_audio_basic_funcs dce6_funcs = {
 	.endpoint_rreg = dce6_endpoint_rreg,
 	.endpoint_wreg = dce6_endpoint_wreg,
 	.enable = dce6_audio_enable,
+	.update_avi_infoframe = evergreen_update_avi_infoframe,
 };
 
 static struct radeon_audio_funcs r600_hdmi_funcs = {
@@ -436,3 +444,15 @@ void radeon_audio_set_dto(struct drm_encoder *encoder, unsigned int clock)
 	if (radeon_encoder->audio && radeon_encoder->audio->set_dto)
 		radeon_encoder->audio->set_dto(rdev, crtc, clock);
 }
+
+void radeon_update_avi_infoframe(struct drm_encoder *encoder, void *buffer,
+	size_t size)
+{
+    struct radeon_device *rdev = encoder->dev->dev_private;
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+	struct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;
+
+	if (dig && dig->afmt && rdev->audio.funcs->update_avi_infoframe)
+		rdev->audio.funcs->update_avi_infoframe(rdev, dig->afmt->offset,
+			buffer, size);
+}

commit a85d682a6578a3bd02c95afb4ef527fa0897bb69
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Fri Dec 5 13:38:31 2014 -0500

    radeon/audio: consolidate audio_set_dto() functions
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index e6c73f8206b2..2a2bf5b5b805 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -62,6 +62,18 @@ void dce6_afmt_write_latency_fields(struct drm_encoder *encoder,
 struct r600_audio_pin* r600_audio_get_pin(struct radeon_device *rdev);
 struct r600_audio_pin* dce6_audio_get_pin(struct radeon_device *rdev);
 void dce6_afmt_select_pin(struct drm_encoder *encoder);
+void r600_hdmi_audio_set_dto(struct radeon_device *rdev,
+	struct radeon_crtc *crtc, unsigned int clock);
+void dce3_2_audio_set_dto(struct radeon_device *rdev,
+	struct radeon_crtc *crtc, unsigned int clock);
+void dce4_hdmi_audio_set_dto(struct radeon_device *rdev,
+	struct radeon_crtc *crtc, unsigned int clock);
+void dce4_dp_audio_set_dto(struct radeon_device *rdev,
+	struct radeon_crtc *crtc, unsigned int clock);
+void dce6_hdmi_audio_set_dto(struct radeon_device *rdev,
+	struct radeon_crtc *crtc, unsigned int clock);
+void dce6_dp_audio_set_dto(struct radeon_device *rdev,
+	struct radeon_crtc *crtc, unsigned int clock);
 
 static const u32 pin_offsets[7] =
 {
@@ -85,6 +97,12 @@ static void radeon_audio_wreg(struct radeon_device *rdev, u32 offset,
 	WREG32(reg, v);
 }
 
+static struct radeon_audio_basic_funcs r600_funcs = {
+	.endpoint_rreg = radeon_audio_rreg,
+	.endpoint_wreg = radeon_audio_wreg,
+	.enable = r600_audio_enable,
+};
+
 static struct radeon_audio_basic_funcs dce32_funcs = {
 	.endpoint_rreg = radeon_audio_rreg,
 	.endpoint_wreg = radeon_audio_wreg,
@@ -103,16 +121,23 @@ static struct radeon_audio_basic_funcs dce6_funcs = {
 	.enable = dce6_audio_enable,
 };
 
+static struct radeon_audio_funcs r600_hdmi_funcs = {
+	.get_pin = r600_audio_get_pin,
+	.set_dto = r600_hdmi_audio_set_dto,
+};
+
 static struct radeon_audio_funcs dce32_hdmi_funcs = {
 	.get_pin = r600_audio_get_pin,
 	.write_sad_regs = dce3_2_afmt_write_sad_regs,
 	.write_speaker_allocation = dce3_2_afmt_hdmi_write_speaker_allocation,
+	.set_dto = dce3_2_audio_set_dto,
 };
 
 static struct radeon_audio_funcs dce32_dp_funcs = {
 	.get_pin = r600_audio_get_pin,
 	.write_sad_regs = dce3_2_afmt_write_sad_regs,
 	.write_speaker_allocation = dce3_2_afmt_dp_write_speaker_allocation,
+	.set_dto = dce3_2_audio_set_dto,
 };
 
 static struct radeon_audio_funcs dce4_hdmi_funcs = {
@@ -120,6 +145,7 @@ static struct radeon_audio_funcs dce4_hdmi_funcs = {
 	.write_sad_regs = evergreen_hdmi_write_sad_regs,
 	.write_speaker_allocation = dce4_afmt_hdmi_write_speaker_allocation,
 	.write_latency_fields = dce4_afmt_write_latency_fields,
+	.set_dto = dce4_hdmi_audio_set_dto,
 };
 
 static struct radeon_audio_funcs dce4_dp_funcs = {
@@ -127,6 +153,7 @@ static struct radeon_audio_funcs dce4_dp_funcs = {
 	.write_sad_regs = evergreen_hdmi_write_sad_regs,
 	.write_speaker_allocation = dce4_afmt_dp_write_speaker_allocation,
 	.write_latency_fields = dce4_afmt_write_latency_fields,
+	.set_dto = dce4_dp_audio_set_dto,
 };
 
 static struct radeon_audio_funcs dce6_hdmi_funcs = {
@@ -135,6 +162,7 @@ static struct radeon_audio_funcs dce6_hdmi_funcs = {
 	.write_sad_regs = dce6_afmt_write_sad_regs,
 	.write_speaker_allocation = dce6_afmt_hdmi_write_speaker_allocation,
 	.write_latency_fields = dce6_afmt_write_latency_fields,
+	.set_dto = dce6_hdmi_audio_set_dto,
 };
 
 static struct radeon_audio_funcs dce6_dp_funcs = {
@@ -143,6 +171,7 @@ static struct radeon_audio_funcs dce6_dp_funcs = {
 	.write_sad_regs = dce6_afmt_write_sad_regs,
 	.write_speaker_allocation = dce6_afmt_dp_write_speaker_allocation,
 	.write_latency_fields = dce6_afmt_write_latency_fields,
+	.set_dto = dce6_dp_audio_set_dto,
 };
 
 static void radeon_audio_interface_init(struct radeon_device *rdev)
@@ -155,10 +184,14 @@ static void radeon_audio_interface_init(struct radeon_device *rdev)
 		rdev->audio.funcs = &dce4_funcs;
 		rdev->audio.hdmi_funcs = &dce4_hdmi_funcs;
 		rdev->audio.dp_funcs = &dce4_dp_funcs;
-	} else {
+	} else if (ASIC_IS_DCE32(rdev)) {
 		rdev->audio.funcs = &dce32_funcs;
 		rdev->audio.hdmi_funcs = &dce32_hdmi_funcs;
 		rdev->audio.dp_funcs = &dce32_dp_funcs;
+	} else {
+		rdev->audio.funcs = &r600_funcs;
+		rdev->audio.hdmi_funcs = &r600_hdmi_funcs;
+		rdev->audio.dp_funcs = 0;
 	}
 }
 
@@ -393,3 +426,13 @@ void radeon_audio_fini(struct radeon_device *rdev)
 
 	rdev->audio.enabled = false;
 }
+
+void radeon_audio_set_dto(struct drm_encoder *encoder, unsigned int clock)
+{
+	struct radeon_device *rdev = encoder->dev->dev_private;
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+	struct radeon_crtc *crtc = to_radeon_crtc(encoder->crtc);
+
+	if (radeon_encoder->audio && radeon_encoder->audio->set_dto)
+		radeon_encoder->audio->set_dto(rdev, crtc, clock);
+}

commit 7991d6650117064ae1d2b215b5cbb4112711ed5e
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Wed Dec 3 17:07:01 2014 -0500

    radeon/audio: consolidate audio_fini() functions
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index eed5c740cefa..e6c73f8206b2 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -380,3 +380,16 @@ void radeon_audio_enable(struct radeon_device *rdev,
 	if (rdev->audio.funcs->enable)
 		rdev->audio.funcs->enable(rdev, pin, enable_mask);
 }
+
+void radeon_audio_fini(struct radeon_device *rdev)
+{
+	int i;
+
+	if (!rdev->audio.enabled)
+		return;
+
+	for (i = 0; i < rdev->audio.num_pins; i++)
+		radeon_audio_enable(rdev, &rdev->audio.pin[i], false);
+
+	rdev->audio.enabled = false;
+}

commit 8bf598207efb35ea17075b11bf116043c18aca40
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Wed Dec 3 15:29:53 2014 -0500

    radeon/audio: consolidate audio_enable() functions
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 5aedf5b97b96..eed5c740cefa 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -30,6 +30,8 @@
 
 void r600_audio_enable(struct radeon_device *rdev, struct r600_audio_pin *pin,
 		u8 enable_mask);
+void dce4_audio_enable(struct radeon_device *rdev, struct r600_audio_pin *pin,
+		u8 enable_mask);
 void dce6_audio_enable(struct radeon_device *rdev, struct r600_audio_pin *pin,
 		u8 enable_mask);
 u32 dce6_endpoint_rreg(struct radeon_device *rdev, u32 offset, u32 reg);
@@ -86,16 +88,19 @@ static void radeon_audio_wreg(struct radeon_device *rdev, u32 offset,
 static struct radeon_audio_basic_funcs dce32_funcs = {
 	.endpoint_rreg = radeon_audio_rreg,
 	.endpoint_wreg = radeon_audio_wreg,
+	.enable = r600_audio_enable,
 };
 
 static struct radeon_audio_basic_funcs dce4_funcs = {
 	.endpoint_rreg = radeon_audio_rreg,
 	.endpoint_wreg = radeon_audio_wreg,
+	.enable = dce4_audio_enable,
 };
 
 static struct radeon_audio_basic_funcs dce6_funcs = {
 	.endpoint_rreg = dce6_endpoint_rreg,
 	.endpoint_wreg = dce6_endpoint_wreg,
+	.enable = dce6_audio_enable,
 };
 
 static struct radeon_audio_funcs dce32_hdmi_funcs = {
@@ -201,10 +206,7 @@ int radeon_audio_init(struct radeon_device *rdev)
 
 	/* disable audio.  it will be set up later */
 	for (i = 0; i < rdev->audio.num_pins; i++)
-		if (ASIC_IS_DCE6(rdev))
-			dce6_audio_enable(rdev, &rdev->audio.pin[i], false);
-		else
-			r600_audio_enable(rdev, &rdev->audio.pin[i], false);
+		radeon_audio_enable(rdev, &rdev->audio.pin[i], false);
 
 	return 0;
 }
@@ -371,3 +373,10 @@ void radeon_audio_select_pin(struct drm_encoder *encoder)
 	if (radeon_encoder->audio && radeon_encoder->audio->select_pin)
 		radeon_encoder->audio->select_pin(encoder);
 }
+
+void radeon_audio_enable(struct radeon_device *rdev,
+	struct r600_audio_pin *pin, u8 enable_mask)
+{
+	if (rdev->audio.funcs->enable)
+		rdev->audio.funcs->enable(rdev, pin, enable_mask);
+}

commit 88252d7728f414a838f6a7cfbe895ba708e8d26d
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Tue Dec 2 17:27:29 2014 -0500

    radeon/audio: consolidate select_pin() functions
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 795f84c8187e..5aedf5b97b96 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -59,6 +59,7 @@ void dce6_afmt_write_latency_fields(struct drm_encoder *encoder,
 		struct drm_connector *connector, struct drm_display_mode *mode);
 struct r600_audio_pin* r600_audio_get_pin(struct radeon_device *rdev);
 struct r600_audio_pin* dce6_audio_get_pin(struct radeon_device *rdev);
+void dce6_afmt_select_pin(struct drm_encoder *encoder);
 
 static const u32 pin_offsets[7] =
 {
@@ -124,6 +125,7 @@ static struct radeon_audio_funcs dce4_dp_funcs = {
 };
 
 static struct radeon_audio_funcs dce6_hdmi_funcs = {
+	.select_pin = dce6_afmt_select_pin,
 	.get_pin = dce6_audio_get_pin,
 	.write_sad_regs = dce6_afmt_write_sad_regs,
 	.write_speaker_allocation = dce6_afmt_hdmi_write_speaker_allocation,
@@ -131,6 +133,7 @@ static struct radeon_audio_funcs dce6_hdmi_funcs = {
 };
 
 static struct radeon_audio_funcs dce6_dp_funcs = {
+	.select_pin = dce6_afmt_select_pin,
 	.get_pin = dce6_audio_get_pin,
 	.write_sad_regs = dce6_afmt_write_sad_regs,
 	.write_speaker_allocation = dce6_afmt_dp_write_speaker_allocation,
@@ -360,3 +363,11 @@ struct r600_audio_pin* radeon_audio_get_pin(struct drm_encoder *encoder)
 
 	return NULL;
 }
+
+void radeon_audio_select_pin(struct drm_encoder *encoder)
+{
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+
+	if (radeon_encoder->audio && radeon_encoder->audio->select_pin)
+		radeon_encoder->audio->select_pin(encoder);
+}

commit 3cdde027aae8b2d3f49912e463f8083da50c8611
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Tue Dec 2 15:22:43 2014 -0500

    radeon/audio: consolidate audio_get_pin() functions
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index a95eee14c4bf..795f84c8187e 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -57,6 +57,8 @@ void dce4_afmt_write_latency_fields(struct drm_encoder *encoder,
 		struct drm_connector *connector, struct drm_display_mode *mode);
 void dce6_afmt_write_latency_fields(struct drm_encoder *encoder,
 		struct drm_connector *connector, struct drm_display_mode *mode);
+struct r600_audio_pin* r600_audio_get_pin(struct radeon_device *rdev);
+struct r600_audio_pin* dce6_audio_get_pin(struct radeon_device *rdev);
 
 static const u32 pin_offsets[7] =
 {
@@ -96,34 +98,40 @@ static struct radeon_audio_basic_funcs dce6_funcs = {
 };
 
 static struct radeon_audio_funcs dce32_hdmi_funcs = {
+	.get_pin = r600_audio_get_pin,
 	.write_sad_regs = dce3_2_afmt_write_sad_regs,
 	.write_speaker_allocation = dce3_2_afmt_hdmi_write_speaker_allocation,
 };
 
 static struct radeon_audio_funcs dce32_dp_funcs = {
+	.get_pin = r600_audio_get_pin,
 	.write_sad_regs = dce3_2_afmt_write_sad_regs,
 	.write_speaker_allocation = dce3_2_afmt_dp_write_speaker_allocation,
 };
 
 static struct radeon_audio_funcs dce4_hdmi_funcs = {
+	.get_pin = r600_audio_get_pin,
 	.write_sad_regs = evergreen_hdmi_write_sad_regs,
 	.write_speaker_allocation = dce4_afmt_hdmi_write_speaker_allocation,
 	.write_latency_fields = dce4_afmt_write_latency_fields,
 };
 
 static struct radeon_audio_funcs dce4_dp_funcs = {
+	.get_pin = r600_audio_get_pin,
 	.write_sad_regs = evergreen_hdmi_write_sad_regs,
 	.write_speaker_allocation = dce4_afmt_dp_write_speaker_allocation,
 	.write_latency_fields = dce4_afmt_write_latency_fields,
 };
 
 static struct radeon_audio_funcs dce6_hdmi_funcs = {
+	.get_pin = dce6_audio_get_pin,
 	.write_sad_regs = dce6_afmt_write_sad_regs,
 	.write_speaker_allocation = dce6_afmt_hdmi_write_speaker_allocation,
 	.write_latency_fields = dce6_afmt_write_latency_fields,
 };
 
 static struct radeon_audio_funcs dce6_dp_funcs = {
+	.get_pin = dce6_audio_get_pin,
 	.write_sad_regs = dce6_afmt_write_sad_regs,
 	.write_speaker_allocation = dce6_afmt_dp_write_speaker_allocation,
 	.write_latency_fields = dce6_afmt_write_latency_fields,
@@ -341,3 +349,14 @@ void radeon_audio_write_latency_fields(struct drm_encoder *encoder,
 	if (radeon_encoder->audio && radeon_encoder->audio->write_latency_fields)
 		radeon_encoder->audio->write_latency_fields(encoder, connector, mode);
 }
+
+struct r600_audio_pin* radeon_audio_get_pin(struct drm_encoder *encoder)
+{
+	struct radeon_device *rdev = encoder->dev->dev_private;
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+
+	if (radeon_encoder->audio && radeon_encoder->audio->get_pin)
+		return radeon_encoder->audio->get_pin(rdev);
+
+	return NULL;
+}

commit 87654f87af2a06f325cc1a1a6e6a6a27f8837bf3
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Tue Dec 2 11:20:48 2014 -0500

    radeon/audio: consolidate write_latency_fields() functions
    
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 22f12e8e1b14..a95eee14c4bf 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -53,6 +53,10 @@ void dce6_afmt_hdmi_write_speaker_allocation(struct drm_encoder *encoder,
 		u8 *sadb, int sad_count);
 void dce6_afmt_dp_write_speaker_allocation(struct drm_encoder *encoder,
 		u8 *sadb, int sad_count);
+void dce4_afmt_write_latency_fields(struct drm_encoder *encoder,
+		struct drm_connector *connector, struct drm_display_mode *mode);
+void dce6_afmt_write_latency_fields(struct drm_encoder *encoder,
+		struct drm_connector *connector, struct drm_display_mode *mode);
 
 static const u32 pin_offsets[7] =
 {
@@ -104,21 +108,25 @@ static struct radeon_audio_funcs dce32_dp_funcs = {
 static struct radeon_audio_funcs dce4_hdmi_funcs = {
 	.write_sad_regs = evergreen_hdmi_write_sad_regs,
 	.write_speaker_allocation = dce4_afmt_hdmi_write_speaker_allocation,
+	.write_latency_fields = dce4_afmt_write_latency_fields,
 };
 
 static struct radeon_audio_funcs dce4_dp_funcs = {
 	.write_sad_regs = evergreen_hdmi_write_sad_regs,
 	.write_speaker_allocation = dce4_afmt_dp_write_speaker_allocation,
+	.write_latency_fields = dce4_afmt_write_latency_fields,
 };
 
 static struct radeon_audio_funcs dce6_hdmi_funcs = {
 	.write_sad_regs = dce6_afmt_write_sad_regs,
 	.write_speaker_allocation = dce6_afmt_hdmi_write_speaker_allocation,
+	.write_latency_fields = dce6_afmt_write_latency_fields,
 };
 
 static struct radeon_audio_funcs dce6_dp_funcs = {
 	.write_sad_regs = dce6_afmt_write_sad_regs,
 	.write_speaker_allocation = dce6_afmt_dp_write_speaker_allocation,
+	.write_latency_fields = dce6_afmt_write_latency_fields,
 };
 
 static void radeon_audio_interface_init(struct radeon_device *rdev)
@@ -307,3 +315,29 @@ void radeon_audio_write_speaker_allocation(struct drm_encoder *encoder)
 
     kfree(sadb);
 }
+
+void radeon_audio_write_latency_fields(struct drm_encoder *encoder,
+	struct drm_display_mode *mode)
+{
+	struct radeon_encoder *radeon_encoder;
+	struct drm_connector *connector;
+	struct radeon_connector *radeon_connector = 0;
+
+	list_for_each_entry(connector,
+		&encoder->dev->mode_config.connector_list, head) {
+		if (connector->encoder == encoder) {
+			radeon_connector = to_radeon_connector(connector);
+			break;
+		}
+	}
+
+	if (!radeon_connector) {
+		DRM_ERROR("Couldn't find encoder's connector\n");
+		return;
+	}
+
+	radeon_encoder = to_radeon_encoder(encoder);
+
+	if (radeon_encoder->audio && radeon_encoder->audio->write_latency_fields)
+		radeon_encoder->audio->write_latency_fields(encoder, connector, mode);
+}

commit 00a9d4bcf8983a5aefcabf5de26b3cb7f805121c
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Mon Dec 1 18:02:57 2014 -0500

    radeon/audio: consolidate write_speaker_allocation() functions
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 0fc7a93a6fb2..22f12e8e1b14 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -41,6 +41,18 @@ void evergreen_hdmi_write_sad_regs(struct drm_encoder *encoder,
 		struct cea_sad *sads, int sad_count);
 void dce6_afmt_write_sad_regs(struct drm_encoder *encoder,
 		struct cea_sad *sads, int sad_count);
+void dce3_2_afmt_hdmi_write_speaker_allocation(struct drm_encoder *encoder,
+		u8 *sadb, int sad_count);
+void dce3_2_afmt_dp_write_speaker_allocation(struct drm_encoder *encoder,
+		u8 *sadb, int sad_count);
+void dce4_afmt_hdmi_write_speaker_allocation(struct drm_encoder *encoder,
+		u8 *sadb, int sad_count);
+void dce4_afmt_dp_write_speaker_allocation(struct drm_encoder *encoder,
+		u8 *sadb, int sad_count);
+void dce6_afmt_hdmi_write_speaker_allocation(struct drm_encoder *encoder,
+		u8 *sadb, int sad_count);
+void dce6_afmt_dp_write_speaker_allocation(struct drm_encoder *encoder,
+		u8 *sadb, int sad_count);
 
 static const u32 pin_offsets[7] =
 {
@@ -81,26 +93,32 @@ static struct radeon_audio_basic_funcs dce6_funcs = {
 
 static struct radeon_audio_funcs dce32_hdmi_funcs = {
 	.write_sad_regs = dce3_2_afmt_write_sad_regs,
+	.write_speaker_allocation = dce3_2_afmt_hdmi_write_speaker_allocation,
 };
 
 static struct radeon_audio_funcs dce32_dp_funcs = {
 	.write_sad_regs = dce3_2_afmt_write_sad_regs,
+	.write_speaker_allocation = dce3_2_afmt_dp_write_speaker_allocation,
 };
 
 static struct radeon_audio_funcs dce4_hdmi_funcs = {
 	.write_sad_regs = evergreen_hdmi_write_sad_regs,
+	.write_speaker_allocation = dce4_afmt_hdmi_write_speaker_allocation,
 };
 
 static struct radeon_audio_funcs dce4_dp_funcs = {
 	.write_sad_regs = evergreen_hdmi_write_sad_regs,
+	.write_speaker_allocation = dce4_afmt_dp_write_speaker_allocation,
 };
 
 static struct radeon_audio_funcs dce6_hdmi_funcs = {
 	.write_sad_regs = dce6_afmt_write_sad_regs,
+	.write_speaker_allocation = dce6_afmt_hdmi_write_speaker_allocation,
 };
 
 static struct radeon_audio_funcs dce6_dp_funcs = {
 	.write_sad_regs = dce6_afmt_write_sad_regs,
+	.write_speaker_allocation = dce6_afmt_dp_write_speaker_allocation,
 };
 
 static void radeon_audio_interface_init(struct radeon_device *rdev)
@@ -254,3 +272,38 @@ void radeon_audio_write_sad_regs(struct drm_encoder *encoder)
 
 	kfree(sads);
 }
+
+void radeon_audio_write_speaker_allocation(struct drm_encoder *encoder)
+{
+	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
+    struct drm_connector *connector;
+    struct radeon_connector *radeon_connector = NULL;
+    u8 *sadb = NULL;
+    int sad_count;
+
+    list_for_each_entry(connector,
+		&encoder->dev->mode_config.connector_list, head) {
+        if (connector->encoder == encoder) {
+            radeon_connector = to_radeon_connector(connector);
+            break;
+        }
+    }
+
+    if (!radeon_connector) {
+        DRM_ERROR("Couldn't find encoder's connector\n");
+        return;
+    }
+
+    sad_count = drm_edid_to_speaker_allocation(
+		radeon_connector_edid(connector), &sadb);
+    if (sad_count < 0) {
+        DRM_DEBUG("Couldn't read Speaker Allocation Data Block: %d\n",
+			sad_count);
+        sad_count = 0;
+    }
+
+	if (radeon_encoder->audio && radeon_encoder->audio->write_speaker_allocation)
+		radeon_encoder->audio->write_speaker_allocation(encoder, sadb, sad_count);
+
+    kfree(sadb);
+}

commit 070a2e63f6ed77d6e8fa533acd5417068274a972
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Jan 22 10:41:55 2015 -0500

    radeon/audio: consolidate write_sad_regs() functions
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 36174b6ca681..0fc7a93a6fb2 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -35,6 +35,12 @@ void dce6_audio_enable(struct radeon_device *rdev, struct r600_audio_pin *pin,
 u32 dce6_endpoint_rreg(struct radeon_device *rdev, u32 offset, u32 reg);
 void dce6_endpoint_wreg(struct radeon_device *rdev,
 		u32 offset, u32 reg, u32 v);
+void dce3_2_afmt_write_sad_regs(struct drm_encoder *encoder,
+		struct cea_sad *sads, int sad_count);
+void evergreen_hdmi_write_sad_regs(struct drm_encoder *encoder,
+		struct cea_sad *sads, int sad_count);
+void dce6_afmt_write_sad_regs(struct drm_encoder *encoder,
+		struct cea_sad *sads, int sad_count);
 
 static const u32 pin_offsets[7] =
 {
@@ -73,14 +79,44 @@ static struct radeon_audio_basic_funcs dce6_funcs = {
 	.endpoint_wreg = dce6_endpoint_wreg,
 };
 
+static struct radeon_audio_funcs dce32_hdmi_funcs = {
+	.write_sad_regs = dce3_2_afmt_write_sad_regs,
+};
+
+static struct radeon_audio_funcs dce32_dp_funcs = {
+	.write_sad_regs = dce3_2_afmt_write_sad_regs,
+};
+
+static struct radeon_audio_funcs dce4_hdmi_funcs = {
+	.write_sad_regs = evergreen_hdmi_write_sad_regs,
+};
+
+static struct radeon_audio_funcs dce4_dp_funcs = {
+	.write_sad_regs = evergreen_hdmi_write_sad_regs,
+};
+
+static struct radeon_audio_funcs dce6_hdmi_funcs = {
+	.write_sad_regs = dce6_afmt_write_sad_regs,
+};
+
+static struct radeon_audio_funcs dce6_dp_funcs = {
+	.write_sad_regs = dce6_afmt_write_sad_regs,
+};
+
 static void radeon_audio_interface_init(struct radeon_device *rdev)
 {
 	if (ASIC_IS_DCE6(rdev)) {
 		rdev->audio.funcs = &dce6_funcs;
+		rdev->audio.hdmi_funcs = &dce6_hdmi_funcs;
+		rdev->audio.dp_funcs = &dce6_dp_funcs;
 	} else if (ASIC_IS_DCE4(rdev)) {
 		rdev->audio.funcs = &dce4_funcs;
+		rdev->audio.hdmi_funcs = &dce4_hdmi_funcs;
+		rdev->audio.dp_funcs = &dce4_dp_funcs;
 	} else {
 		rdev->audio.funcs = &dce32_funcs;
+		rdev->audio.hdmi_funcs = &dce32_hdmi_funcs;
+		rdev->audio.dp_funcs = &dce32_dp_funcs;
 	}
 }
 
@@ -182,3 +218,39 @@ void radeon_audio_endpoint_wreg(struct radeon_device *rdev, u32 offset,
 	if (rdev->audio.funcs->endpoint_wreg)
 		rdev->audio.funcs->endpoint_wreg(rdev, offset, reg, v);
 }
+
+void radeon_audio_write_sad_regs(struct drm_encoder *encoder)
+{
+	struct radeon_encoder *radeon_encoder;
+	struct drm_connector *connector;
+	struct radeon_connector *radeon_connector = NULL;
+	struct cea_sad *sads;
+	int sad_count;
+
+	list_for_each_entry(connector,
+		&encoder->dev->mode_config.connector_list, head) {
+		if (connector->encoder == encoder) {
+			radeon_connector = to_radeon_connector(connector);
+			break;
+		}
+	}
+
+	if (!radeon_connector) {
+		DRM_ERROR("Couldn't find encoder's connector\n");
+		return;
+	}
+
+	sad_count = drm_edid_to_sad(radeon_connector_edid(connector), &sads);
+	if (sad_count <= 0) {
+		DRM_ERROR("Couldn't read SADs: %d\n", sad_count);
+		return;
+	}
+	BUG_ON(!sads);
+
+	radeon_encoder = to_radeon_encoder(encoder);
+
+	if (radeon_encoder->audio && radeon_encoder->audio->write_sad_regs)
+		radeon_encoder->audio->write_sad_regs(encoder, sads, sad_count);
+
+	kfree(sads);
+}

commit 1a626b68fbfa4782477caad56f3b8b652a9dbf7e
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Mon Dec 1 13:49:39 2014 -0500

    radeon/audio: defined initial audio interface that gets initialized via detect() call
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index cc835e2e0de5..36174b6ca681 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -23,12 +23,18 @@
  */
 
 #include <drm/drmP.h>
+#include <drm/drm_crtc.h>
 #include "radeon.h"
+#include "atom.h"
+#include "radeon_audio.h"
 
 void r600_audio_enable(struct radeon_device *rdev, struct r600_audio_pin *pin,
 		u8 enable_mask);
 void dce6_audio_enable(struct radeon_device *rdev, struct r600_audio_pin *pin,
 		u8 enable_mask);
+u32 dce6_endpoint_rreg(struct radeon_device *rdev, u32 offset, u32 reg);
+void dce6_endpoint_wreg(struct radeon_device *rdev,
+		u32 offset, u32 reg, u32 v);
 
 static const u32 pin_offsets[7] =
 {
@@ -41,6 +47,43 @@ static const u32 pin_offsets[7] =
 	(0x5e90 - 0x5e00),
 };
 
+static u32 radeon_audio_rreg(struct radeon_device *rdev, u32 offset, u32 reg)
+{
+	return RREG32(reg);
+}
+
+static void radeon_audio_wreg(struct radeon_device *rdev, u32 offset,
+		u32 reg, u32 v)
+{
+	WREG32(reg, v);
+}
+
+static struct radeon_audio_basic_funcs dce32_funcs = {
+	.endpoint_rreg = radeon_audio_rreg,
+	.endpoint_wreg = radeon_audio_wreg,
+};
+
+static struct radeon_audio_basic_funcs dce4_funcs = {
+	.endpoint_rreg = radeon_audio_rreg,
+	.endpoint_wreg = radeon_audio_wreg,
+};
+
+static struct radeon_audio_basic_funcs dce6_funcs = {
+	.endpoint_rreg = dce6_endpoint_rreg,
+	.endpoint_wreg = dce6_endpoint_wreg,
+};
+
+static void radeon_audio_interface_init(struct radeon_device *rdev)
+{
+	if (ASIC_IS_DCE6(rdev)) {
+		rdev->audio.funcs = &dce6_funcs;
+	} else if (ASIC_IS_DCE4(rdev)) {
+		rdev->audio.funcs = &dce4_funcs;
+	} else {
+		rdev->audio.funcs = &dce32_funcs;
+	}
+}
+
 static int radeon_audio_chipset_supported(struct radeon_device *rdev)
 {
 	return ASIC_IS_DCE2(rdev) && !ASIC_IS_NODCE(rdev);
@@ -79,12 +122,63 @@ int radeon_audio_init(struct radeon_device *rdev)
 		rdev->audio.pin[i].connected = false;
 		rdev->audio.pin[i].offset = pin_offsets[i];
 		rdev->audio.pin[i].id = i;
-		/* disable audio.  it will be set up later */
+	}
+
+	radeon_audio_interface_init(rdev);
+
+	/* disable audio.  it will be set up later */
+	for (i = 0; i < rdev->audio.num_pins; i++)
 		if (ASIC_IS_DCE6(rdev))
 			dce6_audio_enable(rdev, &rdev->audio.pin[i], false);
 		else
 			r600_audio_enable(rdev, &rdev->audio.pin[i], false);
+
+	return 0;
+}
+
+void radeon_audio_detect(struct drm_connector *connector,
+	enum drm_connector_status status)
+{
+	if (!connector || !connector->encoder)
+		return;
+
+	if (status == connector_status_connected) {
+		int sink_type;
+		struct radeon_device *rdev = connector->encoder->dev->dev_private;
+		struct radeon_connector *radeon_connector;
+		struct radeon_encoder *radeon_encoder =
+			to_radeon_encoder(connector->encoder);
+
+		if (!drm_detect_monitor_audio(radeon_connector_edid(connector))) {
+			radeon_encoder->audio = 0;
+			return;
+		}
+
+		radeon_connector = to_radeon_connector(connector);
+		sink_type = radeon_dp_getsinktype(radeon_connector);
+
+		if (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort &&
+			sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT)
+			radeon_encoder->audio = rdev->audio.dp_funcs;
+		else
+			radeon_encoder->audio = rdev->audio.hdmi_funcs;
+		/* TODO: set up the sads, etc. and set the audio enable_mask */
+	} else {
+		/* TODO: reset the audio enable_mask */
 	}
+}
+
+u32 radeon_audio_endpoint_rreg(struct radeon_device *rdev, u32 offset, u32 reg)
+{
+	if (rdev->audio.funcs->endpoint_rreg)
+		return rdev->audio.funcs->endpoint_rreg(rdev, offset, reg);
 
 	return 0;
 }
+
+void radeon_audio_endpoint_wreg(struct radeon_device *rdev, u32 offset,
+	u32 reg, u32 v)
+{
+	if (rdev->audio.funcs->endpoint_wreg)
+		rdev->audio.funcs->endpoint_wreg(rdev, offset, reg, v);
+}

commit bfc1f97d8ac5d3dc6f7ded64ba9adbac371e912c
Author: Slava Grigorev <slava.grigorev@amd.com>
Date:   Mon Dec 22 17:26:51 2014 -0500

    radeon/audio: consolidate audio_init() functions
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Slava Grigorev <slava.grigorev@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
new file mode 100644
index 000000000000..cc835e2e0de5
--- /dev/null
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2014 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Slava Grigorev <slava.grigorev@amd.com>
+ */
+
+#include <drm/drmP.h>
+#include "radeon.h"
+
+void r600_audio_enable(struct radeon_device *rdev, struct r600_audio_pin *pin,
+		u8 enable_mask);
+void dce6_audio_enable(struct radeon_device *rdev, struct r600_audio_pin *pin,
+		u8 enable_mask);
+
+static const u32 pin_offsets[7] =
+{
+	(0x5e00 - 0x5e00),
+	(0x5e18 - 0x5e00),
+	(0x5e30 - 0x5e00),
+	(0x5e48 - 0x5e00),
+	(0x5e60 - 0x5e00),
+	(0x5e78 - 0x5e00),
+	(0x5e90 - 0x5e00),
+};
+
+static int radeon_audio_chipset_supported(struct radeon_device *rdev)
+{
+	return ASIC_IS_DCE2(rdev) && !ASIC_IS_NODCE(rdev);
+}
+
+int radeon_audio_init(struct radeon_device *rdev)
+{
+	int i;
+
+	if (!radeon_audio || !radeon_audio_chipset_supported(rdev))
+		return 0;
+
+	rdev->audio.enabled = true;
+
+	if (ASIC_IS_DCE83(rdev))		/* KB: 2 streams, 3 endpoints */
+		rdev->audio.num_pins = 3;
+	else if (ASIC_IS_DCE81(rdev))	/* KV: 4 streams, 7 endpoints */
+		rdev->audio.num_pins = 7;
+	else if (ASIC_IS_DCE8(rdev))	/* BN/HW: 6 streams, 7 endpoints */
+		rdev->audio.num_pins = 7;
+	else if (ASIC_IS_DCE64(rdev))	/* OL: 2 streams, 2 endpoints */
+		rdev->audio.num_pins = 2;
+	else if (ASIC_IS_DCE61(rdev))	/* TN: 4 streams, 6 endpoints */
+		rdev->audio.num_pins = 6;
+	else if (ASIC_IS_DCE6(rdev))	/* SI: 6 streams, 6 endpoints */
+		rdev->audio.num_pins = 6;
+	else
+		rdev->audio.num_pins = 1;
+
+	for (i = 0; i < rdev->audio.num_pins; i++) {
+		rdev->audio.pin[i].channels = -1;
+		rdev->audio.pin[i].rate = -1;
+		rdev->audio.pin[i].bits_per_sample = -1;
+		rdev->audio.pin[i].status_bits = 0;
+		rdev->audio.pin[i].category_code = 0;
+		rdev->audio.pin[i].connected = false;
+		rdev->audio.pin[i].offset = pin_offsets[i];
+		rdev->audio.pin[i].id = i;
+		/* disable audio.  it will be set up later */
+		if (ASIC_IS_DCE6(rdev))
+			dce6_audio_enable(rdev, &rdev->audio.pin[i], false);
+		else
+			r600_audio_enable(rdev, &rdev->audio.pin[i], false);
+	}
+
+	return 0;
+}
