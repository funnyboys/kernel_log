commit d6a9efece7248d3cbd7bf65d3a8325e8e5dceec0
Author: Lyude Paul <lyude@redhat.com>
Date:   Mon May 11 18:41:27 2020 -0400

    drm/nouveau/kms/nv50-: Share DP SST mode_valid() handling with MST
    
    Currently, the nv50_mstc_mode_valid() function is happy to take any and
    all modes, even the ones we can't actually support sometimes like
    interlaced modes.
    
    Luckily, the only difference between the mode validation that needs to
    be performed for MST vs. SST is that eventually we'll need to check the
    minimum PBN against the MSTB's full PBN capabilities (remember-we don't
    care about the current bw state here). Otherwise, all of the other code
    can be shared.
    
    So, we move all of the common mode validation in
    nouveau_connector_mode_valid() into a separate helper,
    nv50_dp_mode_valid(), and use that from both nv50_mstc_mode_valid() and
    nouveau_connector_mode_valid(). Note that we allow for returning the
    calculated clock that nv50_dp_mode_valid() came up with, since we'll
    eventually want to use that for PBN calculation in
    nv50_mstc_mode_valid().
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index de84fb4708c7..9e062c7adec8 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -195,6 +195,11 @@ int nouveau_conn_atomic_get_property(struct drm_connector *,
 				     const struct drm_connector_state *,
 				     struct drm_property *, u64 *);
 struct drm_display_mode *nouveau_conn_native_mode(struct drm_connector *);
+enum drm_mode_status
+nouveau_conn_mode_clock_valid(const struct drm_display_mode *,
+			      const unsigned min_clock,
+			      const unsigned max_clock,
+			      unsigned *clock);
 
 #ifdef CONFIG_DRM_NOUVEAU_BACKLIGHT
 extern int nouveau_backlight_init(struct drm_connector *);

commit 64d17f25dcad518461ccf0c260544e1e379c5b35
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Oct 24 10:52:53 2019 +0200

    drm/nouveau: Fix drm-core using atomic code-paths on pre-nv50 hardware
    
    We do not support atomic modesetting on pre-nv50 hardware, but until now
    our connector code was setting drm_connector->state on pre-nv50 hardware.
    
    This causes the core to enter atomic modesetting paths in at least:
    
    1. drm_connector_get_encoder(), returning connector->state->best_encoder
    which is always 0, causing us to always report 0 as encoder_id in
    the drmModeConnector struct returned by drmModeGetConnector().
    
    2. drm_encoder_get_crtc(), returning NULL because uses_atomic get set,
    causing us to always report 0 as crtc_id in the drmModeEncoder struct
    returned by drmModeGetEncoder()
    
    Which in turn confuses userspace, at least plymouth thinks that the pipe
    has changed because of this and tries to reconfigure it unnecessarily.
    
    More in general we should not set drm_connector->state in the non-atomic
    code as this violates the drm-core's expectations.
    
    This commit fixes this by using a nouveau_conn_atom struct embedded in the
    nouveau_connector struct for property handling in the non-atomic case.
    
    Fixes: https://bugzilla.redhat.com/show_bug.cgi?id=1706557
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index de9588420884..de84fb4708c7 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -118,6 +118,12 @@ struct nouveau_connector {
 #ifdef CONFIG_DRM_NOUVEAU_BACKLIGHT
 	struct nouveau_backlight *backlight;
 #endif
+	/*
+	 * Our connector property code expects a nouveau_conn_atom struct
+	 * even on pre-nv50 where we do not support atomic. This embedded
+	 * version gets used in the non atomic modeset case.
+	 */
+	struct nouveau_conn_atom properties_state;
 };
 
 static inline struct nouveau_connector *nouveau_connector(

commit 37a68eab4cd92b507c9e8afd760fdc18e4fecac6
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Oct 24 10:52:52 2019 +0200

    drm/nouveau: Move the declaration of struct nouveau_conn_atom up a bit
    
    Place the declaration of struct nouveau_conn_atom above that of
    struct nouveau_connector. This commit makes no changes to the moved
    block what so ever, it just moves it up a bit.
    
    This is a preparation patch to fix some issues with connector handling
    on pre nv50 displays (which do not use atomic modesetting).
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index f43a8d63aef8..de9588420884 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -29,6 +29,7 @@
 
 #include <nvif/notify.h>
 
+#include <drm/drm_crtc.h>
 #include <drm/drm_edid.h>
 #include <drm/drm_encoder.h>
 #include <drm/drm_dp_helper.h>
@@ -44,6 +45,60 @@ struct dcb_output;
 struct nouveau_backlight;
 #endif
 
+#define nouveau_conn_atom(p)                                                   \
+	container_of((p), struct nouveau_conn_atom, state)
+
+struct nouveau_conn_atom {
+	struct drm_connector_state state;
+
+	struct {
+		/* The enum values specifically defined here match nv50/gf119
+		 * hw values, and the code relies on this.
+		 */
+		enum {
+			DITHERING_MODE_OFF = 0x00,
+			DITHERING_MODE_ON = 0x01,
+			DITHERING_MODE_DYNAMIC2X2 = 0x10 | DITHERING_MODE_ON,
+			DITHERING_MODE_STATIC2X2 = 0x18 | DITHERING_MODE_ON,
+			DITHERING_MODE_TEMPORAL = 0x20 | DITHERING_MODE_ON,
+			DITHERING_MODE_AUTO
+		} mode;
+		enum {
+			DITHERING_DEPTH_6BPC = 0x00,
+			DITHERING_DEPTH_8BPC = 0x02,
+			DITHERING_DEPTH_AUTO
+		} depth;
+	} dither;
+
+	struct {
+		int mode;	/* DRM_MODE_SCALE_* */
+		struct {
+			enum {
+				UNDERSCAN_OFF,
+				UNDERSCAN_ON,
+				UNDERSCAN_AUTO,
+			} mode;
+			u32 hborder;
+			u32 vborder;
+		} underscan;
+		bool full;
+	} scaler;
+
+	struct {
+		int color_vibrance;
+		int vibrant_hue;
+	} procamp;
+
+	union {
+		struct {
+			bool dither:1;
+			bool scaler:1;
+			bool procamp:1;
+		};
+		u8 mask;
+	} set;
+};
+
 struct nouveau_connector {
 	struct drm_connector base;
 	enum dcb_connector_type type;
@@ -121,61 +176,6 @@ extern int nouveau_ignorelid;
 extern int nouveau_duallink;
 extern int nouveau_hdmimhz;
 
-#include <drm/drm_crtc.h>
-#define nouveau_conn_atom(p)                                                   \
-	container_of((p), struct nouveau_conn_atom, state)
-
-struct nouveau_conn_atom {
-	struct drm_connector_state state;
-
-	struct {
-		/* The enum values specifically defined here match nv50/gf119
-		 * hw values, and the code relies on this.
-		 */
-		enum {
-			DITHERING_MODE_OFF = 0x00,
-			DITHERING_MODE_ON = 0x01,
-			DITHERING_MODE_DYNAMIC2X2 = 0x10 | DITHERING_MODE_ON,
-			DITHERING_MODE_STATIC2X2 = 0x18 | DITHERING_MODE_ON,
-			DITHERING_MODE_TEMPORAL = 0x20 | DITHERING_MODE_ON,
-			DITHERING_MODE_AUTO
-		} mode;
-		enum {
-			DITHERING_DEPTH_6BPC = 0x00,
-			DITHERING_DEPTH_8BPC = 0x02,
-			DITHERING_DEPTH_AUTO
-		} depth;
-	} dither;
-
-	struct {
-		int mode;	/* DRM_MODE_SCALE_* */
-		struct {
-			enum {
-				UNDERSCAN_OFF,
-				UNDERSCAN_ON,
-				UNDERSCAN_AUTO,
-			} mode;
-			u32 hborder;
-			u32 vborder;
-		} underscan;
-		bool full;
-	} scaler;
-
-	struct {
-		int color_vibrance;
-		int vibrant_hue;
-	} procamp;
-
-	union {
-		struct {
-			bool dither:1;
-			bool scaler:1;
-			bool procamp:1;
-		};
-		u8 mask;
-	} set;
-};
-
 void nouveau_conn_attach_properties(struct drm_connector *);
 void nouveau_conn_reset(struct drm_connector *);
 struct drm_connector_state *

commit 3c7fc252b3fab080db110057d2d6d8c9a56d349b
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Jul 12 13:13:52 2018 -0400

    drm/nouveau/drm/nouveau: Don't forget to label dp_aux devices
    
    This makes debugging with DP tracing a lot harder to interpret, so name
    each i2c based off the name of the encoder that it's for
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Karol Herbst <karolherbst@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index f57ef35b1e5e..f43a8d63aef8 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -38,6 +38,7 @@
 #include "nouveau_encoder.h"
 
 struct nvkm_i2c_port;
+struct dcb_output;
 
 #ifdef CONFIG_DRM_NOUVEAU_BACKLIGHT
 struct nouveau_backlight;
@@ -113,7 +114,7 @@ nouveau_crtc_connector_get(struct nouveau_crtc *nv_crtc)
 }
 
 struct drm_connector *
-nouveau_connector_create(struct drm_device *, int index);
+nouveau_connector_create(struct drm_device *, const struct dcb_output *);
 
 extern int nouveau_tv_disable;
 extern int nouveau_ignorelid;

commit a4e05f415e2fb22b1804c86bbf84cc1d5d29b9f1
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Sep 6 17:43:24 2018 -0400

    drm/nouveau/drm/nouveau: s/nouveau_backlight_exit/nouveau_backlight_fini/
    
    More consistent with the rest of the codebase, no functional changes
    here.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Karol Herbst <kherbst@redhat.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 6f89d4938059..f57ef35b1e5e 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -191,7 +191,7 @@ struct drm_display_mode *nouveau_conn_native_mode(struct drm_connector *);
 
 #ifdef CONFIG_DRM_NOUVEAU_BACKLIGHT
 extern int nouveau_backlight_init(struct drm_connector *);
-extern void nouveau_backlight_exit(struct drm_connector *);
+extern void nouveau_backlight_fini(struct drm_connector *);
 extern void nouveau_backlight_ctor(void);
 extern void nouveau_backlight_dtor(void);
 #else
@@ -202,7 +202,7 @@ nouveau_backlight_init(struct drm_connector *connector)
 }
 
 static inline void
-nouveau_backlight_exit(struct drm_connector *connector) {
+nouveau_backlight_fini(struct drm_connector *connector) {
 }
 
 static inline void

commit 6d757753cef8d523342fe544299068d30b5be490
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Sep 6 17:43:23 2018 -0400

    drm/nouveau: Move backlight device into nouveau_connector
    
    Currently module unloading is broken in nouveau due to a rather annoying
    race condition resulting from nouveau_backlight.c having gone a bit
    stale over time:
    
    [ 1960.791143] ==================================================================
    [ 1960.791394] BUG: KASAN: use-after-free in nouveau_backlight_exit+0x112/0x150 [nouveau]
    [ 1960.791460] Read of size 4 at addr ffff88075accf350 by task zsh/11185
    [ 1960.791521]
    [ 1960.791545] CPU: 7 PID: 11185 Comm: zsh Kdump: loaded Tainted: G           O      4.18.0Lyude-Test+ #4
    [ 1960.791580] Hardware name: LENOVO 20EQS64N0B/20EQS64N0B, BIOS N1EET79W (1.52 ) 07/13/2018
    [ 1960.791628] Call Trace:
    [ 1960.791680]  dump_stack+0xa4/0xfd
    [ 1960.791721]  print_address_description+0x71/0x239
    [ 1960.791833]  ? nouveau_backlight_exit+0x112/0x150 [nouveau]
    [ 1960.791877]  kasan_report.cold.6+0x242/0x2fe
    [ 1960.791919]  __asan_report_load4_noabort+0x19/0x20
    [ 1960.792012]  nouveau_backlight_exit+0x112/0x150 [nouveau]
    [ 1960.792081]  nouveau_display_destroy+0x76/0x150 [nouveau]
    [ 1960.792150]  nouveau_drm_device_fini+0xb7/0x190 [nouveau]
    [ 1960.792265]  nouveau_drm_device_remove+0x14b/0x1d0 [nouveau]
    [ 1960.792347]  ? nouveau_cli_work_queue+0x2e0/0x2e0 [nouveau]
    [ 1960.792378]  ? trace_hardirqs_on_caller+0x38b/0x570
    [ 1960.792406]  ? trace_hardirqs_on+0xd/0x10
    [ 1960.792472]  nouveau_drm_remove+0x37/0x50 [nouveau]
    [ 1960.792502]  pci_device_remove+0x112/0x2d0
    [ 1960.792530]  ? pcibios_free_irq+0x10/0x10
    [ 1960.792558]  ? kasan_check_write+0x14/0x20
    [ 1960.792587]  device_release_driver_internal+0x35c/0x650
    [ 1960.792617]  device_release_driver+0x12/0x20
    [ 1960.792643]  pci_stop_bus_device+0x172/0x1e0
    [ 1960.792671]  pci_stop_and_remove_bus_device_locked+0x1a/0x30
    [ 1960.792715]  remove_store+0xcb/0xe0
    [ 1960.792753]  ? sriov_numvfs_store+0x2e0/0x2e0
    [ 1960.792779]  ? __lock_is_held+0xb5/0x140
    [ 1960.792808]  ? component_add+0x530/0x530
    [ 1960.792834]  dev_attr_store+0x3f/0x70
    [ 1960.792859]  ? sysfs_file_ops+0x11d/0x170
    [ 1960.792885]  sysfs_kf_write+0x104/0x150
    [ 1960.792915]  ? sysfs_file_ops+0x170/0x170
    [ 1960.792940]  kernfs_fop_write+0x24f/0x400
    [ 1960.792978]  ? __lock_acquire+0x6ea/0x47f0
    [ 1960.793021]  __vfs_write+0xeb/0x760
    [ 1960.793048]  ? kernel_read+0x130/0x130
    [ 1960.793076]  ? __lock_is_held+0xb5/0x140
    [ 1960.793107]  ? rcu_read_lock_sched_held+0xdd/0x110
    [ 1960.793135]  ? rcu_sync_lockdep_assert+0x78/0xb0
    [ 1960.793162]  ? __sb_start_write+0x183/0x220
    [ 1960.793189]  vfs_write+0x14d/0x4a0
    [ 1960.793229]  ksys_write+0xd2/0x1b0
    [ 1960.793255]  ? __ia32_sys_read+0xb0/0xb0
    [ 1960.793298]  ? fput+0x1d/0x120
    [ 1960.793324]  ? filp_close+0xf3/0x130
    [ 1960.793349]  ? entry_SYSCALL_64_after_hwframe+0x59/0xbe
    [ 1960.793380]  __x64_sys_write+0x73/0xb0
    [ 1960.793407]  do_syscall_64+0xaa/0x400
    [ 1960.793433]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [ 1960.793460] RIP: 0033:0x7f59df433164
    [ 1960.793486] Code: 89 02 48 c7 c0 ff ff ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 8d 05 81 38 2d 00 8b 00 85 c0 75 13 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 c3 0f 1f 00 41 54 49 89 d4 55 48 89 f5 53
    [ 1960.793541] RSP: 002b:00007ffd70ee2fb8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    [ 1960.793576] RAX: ffffffffffffffda RBX: 0000000000000002 RCX: 00007f59df433164
    [ 1960.793620] RDX: 0000000000000002 RSI: 00005578088640c0 RDI: 0000000000000001
    [ 1960.793665] RBP: 00005578088640c0 R08: 00007f59df7038c0 R09: 00007f59e0995b80
    [ 1960.793696] R10: 000000000000000a R11: 0000000000000246 R12: 00007f59df702760
    [ 1960.793730] R13: 0000000000000002 R14: 00007f59df6fd760 R15: 0000000000000002
    [ 1960.793768]
    [ 1960.793790] Allocated by task 11167:
    [ 1960.793816]  save_stack+0x43/0xd0
    [ 1960.793841]  kasan_kmalloc+0xc4/0xe0
    [ 1960.793880]  kasan_slab_alloc+0x11/0x20
    [ 1960.793905]  kmem_cache_alloc+0xd7/0x270
    [ 1960.793944]  getname_flags+0xbd/0x520
    [ 1960.793969]  user_path_at_empty+0x23/0x50
    [ 1960.793994]  do_faccessat+0x1fc/0x5d0
    [ 1960.794018]  __x64_sys_access+0x59/0x80
    [ 1960.794043]  do_syscall_64+0xaa/0x400
    [ 1960.794067]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [ 1960.794093]
    [ 1960.794127] Freed by task 11167:
    [ 1960.794152]  save_stack+0x43/0xd0
    [ 1960.794190]  __kasan_slab_free+0x139/0x190
    [ 1960.794215]  kasan_slab_free+0xe/0x10
    [ 1960.794239]  kmem_cache_free+0xcb/0x2c0
    [ 1960.794264]  putname+0xad/0xe0
    [ 1960.794287]  filename_lookup.part.59+0x1f1/0x360
    [ 1960.794313]  user_path_at_empty+0x3e/0x50
    [ 1960.794338]  do_faccessat+0x1fc/0x5d0
    [ 1960.794362]  __x64_sys_access+0x59/0x80
    [ 1960.794393]  do_syscall_64+0xaa/0x400
    [ 1960.794421]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [ 1960.794461]
    [ 1960.794483] The buggy address belongs to the object at ffff88075acceac0
    [ 1960.794483]  which belongs to the cache names_cache of size 4096
    [ 1960.794540] The buggy address is located 2192 bytes inside of
    [ 1960.794540]  4096-byte region [ffff88075acceac0, ffff88075accfac0)
    [ 1960.794581] The buggy address belongs to the page:
    [ 1960.794609] page:ffffea001d6b3200 count:1 mapcount:0 mapping:ffff880778e4b1c0 index:0x0 compound_mapcount: 0
    [ 1960.794651] flags: 0x8000000000008100(slab|head)
    [ 1960.794679] raw: 8000000000008100 ffffea001d39e808 ffffea001d39ea08 ffff880778e4b1c0
    [ 1960.794739] raw: 0000000000000000 0000000000070007 00000001ffffffff 0000000000000000
    [ 1960.794785] page dumped because: kasan: bad access detected
    [ 1960.794813]
    [ 1960.794834] Memory state around the buggy address:
    [ 1960.794861]  ffff88075accf200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [ 1960.794894]  ffff88075accf280: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [ 1960.794925] >ffff88075accf300: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [ 1960.794956]                                                  ^
    [ 1960.794985]  ffff88075accf380: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [ 1960.795017]  ffff88075accf400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [ 1960.795061] ==================================================================
    [ 1960.795106] Disabling lock debugging due to kernel taint
    [ 1960.795131] ------------[ cut here ]------------
    [ 1960.795148] ida_remove called for id=1802201963 which is not allocated.
    [ 1960.795193] WARNING: CPU: 7 PID: 11185 at lib/idr.c:521 ida_remove+0x184/0x210
    [ 1960.795213] Modules linked in: nouveau(O) mxm_wmi ttm i2c_algo_bit drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops drm joydev vfat fat intel_rapl x86_pkg_temp_thermal coretemp crc32_pclmul iTCO_wdt psmouse wmi_bmof mei_me tpm_tis mei tpm_tis_core tpm i2c_i801 thinkpad_acpi pcc_cpufreq crc32c_intel serio_raw xhci_pci xhci_hcd wmi video i2c_dev i2c_core
    [ 1960.795305] CPU: 7 PID: 11185 Comm: zsh Kdump: loaded Tainted: G    B      O      4.18.0Lyude-Test+ #4
    [ 1960.795330] Hardware name: LENOVO 20EQS64N0B/20EQS64N0B, BIOS N1EET79W (1.52 ) 07/13/2018
    [ 1960.795352] RIP: 0010:ida_remove+0x184/0x210
    [ 1960.795370] Code: 4c 89 f7 e8 ae c8 00 00 eb 22 41 83 c4 02 4c 89 e8 41 83 fc 3f 0f 86 64 ff ff ff 44 89 fe 48 c7 c7 20 94 1e 83 e8 54 ed 81 fe <0f> 0b 48 b8 00 00 00 00 00 fc ff df 48 01 c3 c7 03 00 00 00 00 c7
    [ 1960.795402] RSP: 0018:ffff88074d4df7b8 EFLAGS: 00010082
    [ 1960.795421] RAX: 0000000000000000 RBX: 1ffff100e9a9befa RCX: ffffffff81479975
    [ 1960.795440] RDX: 0000000000000000 RSI: 0000000000000008 RDI: ffff88077c1de690
    [ 1960.795460] RBP: ffff88074d4df878 R08: ffffed00ef83bcd3 R09: ffffed00ef83bcd2
    [ 1960.795479] R10: ffffed00ef83bcd2 R11: ffff88077c1de697 R12: 000000000000036b
    [ 1960.795498] R13: 0000000000000202 R14: ffffffffa0aa7fa0 R15: 000000006b6b6b6b
    [ 1960.795518] FS:  00007f59e0995b80(0000) GS:ffff88077c1c0000(0000) knlGS:0000000000000000
    [ 1960.795553] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [ 1960.795571] CR2: 00007f59e09a2010 CR3: 00000004a1a70005 CR4: 00000000003606e0
    [ 1960.795596] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [ 1960.795629] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [ 1960.795649] Call Trace:
    [ 1960.795667]  ? ida_destroy+0x1d0/0x1d0
    [ 1960.795686]  ? kasan_check_write+0x14/0x20
    [ 1960.795704]  ? do_raw_spin_lock+0xc2/0x1c0
    [ 1960.795724]  ida_simple_remove+0x26/0x40
    [ 1960.795794]  nouveau_backlight_exit+0x9d/0x150 [nouveau]
    [ 1960.795867]  nouveau_display_destroy+0x76/0x150 [nouveau]
    [ 1960.795930]  nouveau_drm_device_fini+0xb7/0x190 [nouveau]
    [ 1960.795989]  nouveau_drm_device_remove+0x14b/0x1d0 [nouveau]
    [ 1960.796047]  ? nouveau_cli_work_queue+0x2e0/0x2e0 [nouveau]
    [ 1960.796067]  ? trace_hardirqs_on_caller+0x38b/0x570
    [ 1960.796089]  ? trace_hardirqs_on+0xd/0x10
    [ 1960.796146]  nouveau_drm_remove+0x37/0x50 [nouveau]
    [ 1960.796167]  pci_device_remove+0x112/0x2d0
    [ 1960.796186]  ? pcibios_free_irq+0x10/0x10
    [ 1960.796218]  ? kasan_check_write+0x14/0x20
    [ 1960.796237]  device_release_driver_internal+0x35c/0x650
    [ 1960.796257]  device_release_driver+0x12/0x20
    [ 1960.796289]  pci_stop_bus_device+0x172/0x1e0
    [ 1960.796308]  pci_stop_and_remove_bus_device_locked+0x1a/0x30
    [ 1960.796328]  remove_store+0xcb/0xe0
    [ 1960.796345]  ? sriov_numvfs_store+0x2e0/0x2e0
    [ 1960.796364]  ? __lock_is_held+0xb5/0x140
    [ 1960.796383]  ? component_add+0x530/0x530
    [ 1960.796401]  dev_attr_store+0x3f/0x70
    [ 1960.796419]  ? sysfs_file_ops+0x11d/0x170
    [ 1960.796436]  sysfs_kf_write+0x104/0x150
    [ 1960.796454]  ? sysfs_file_ops+0x170/0x170
    [ 1960.796471]  kernfs_fop_write+0x24f/0x400
    [ 1960.796488]  ? __lock_acquire+0x6ea/0x47f0
    [ 1960.796520]  __vfs_write+0xeb/0x760
    [ 1960.796538]  ? kernel_read+0x130/0x130
    [ 1960.796556]  ? __lock_is_held+0xb5/0x140
    [ 1960.796590]  ? rcu_read_lock_sched_held+0xdd/0x110
    [ 1960.796608]  ? rcu_sync_lockdep_assert+0x78/0xb0
    [ 1960.796626]  ? __sb_start_write+0x183/0x220
    [ 1960.796648]  vfs_write+0x14d/0x4a0
    [ 1960.796666]  ksys_write+0xd2/0x1b0
    [ 1960.796684]  ? __ia32_sys_read+0xb0/0xb0
    [ 1960.796701]  ? fput+0x1d/0x120
    [ 1960.796732]  ? filp_close+0xf3/0x130
    [ 1960.796749]  ? entry_SYSCALL_64_after_hwframe+0x59/0xbe
    [ 1960.796768]  __x64_sys_write+0x73/0xb0
    [ 1960.796800]  do_syscall_64+0xaa/0x400
    [ 1960.796818]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [ 1960.796836] RIP: 0033:0x7f59df433164
    [ 1960.796854] Code: 89 02 48 c7 c0 ff ff ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 8d 05 81 38 2d 00 8b 00 85 c0 75 13 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 c3 0f 1f 00 41 54 49 89 d4 55 48 89 f5 53
    [ 1960.796884] RSP: 002b:00007ffd70ee2fb8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    [ 1960.796906] RAX: ffffffffffffffda RBX: 0000000000000002 RCX: 00007f59df433164
    [ 1960.796926] RDX: 0000000000000002 RSI: 00005578088640c0 RDI: 0000000000000001
    [ 1960.796946] RBP: 00005578088640c0 R08: 00007f59df7038c0 R09: 00007f59e0995b80
    [ 1960.796966] R10: 000000000000000a R11: 0000000000000246 R12: 00007f59df702760
    [ 1960.796985] R13: 0000000000000002 R14: 00007f59df6fd760 R15: 0000000000000002
    [ 1960.797008] irq event stamp: 509990
    [ 1960.797026] hardirqs last  enabled at (509989): [<ffffffff8119ff78>] flush_work+0x4b8/0x6d0
    [ 1960.797063] hardirqs last disabled at (509990): [<ffffffff8297c395>] _raw_spin_lock_irqsave+0x25/0x60
    [ 1960.797085] softirqs last  enabled at (509744): [<ffffffff82c005ad>] __do_softirq+0x5ad/0x8c0
    [ 1960.797121] softirqs last disabled at (509735): [<ffffffff8115aa15>] irq_exit+0x1a5/0x1e0
    [ 1960.797142] ---[ end trace fb1342325f1846b8 ]---
    
    While I haven't actually gone into the details of what's causing this to
    happen (maybe the kernel removes the backlight device in the device core
    before we get to it?), it doesn't really matter anyway because the way
    nouveau handles backlights has long since been deprecated.
    
    According to the documentation on the drm_connector->late_register()
    hook, the ->late_register() hook should be used for adding extra
    connector-related devices. Vice versa, the ->early_unregister() hook is
    meant to be used for removing those devices.
    
    So: gut nouveau_drm->bl_list and nouveau_drm->backlight, and replace
    them with per-connector backlight structures. Additionally, move
    backlight registration/teardown into the ->late_register() and
    ->early_unregister() hooks so that DRM can give us a chance to remove
    the backlight before the connector is even removed. This appears to fix
    the problem once and for all.
    
    Changes since v2:
    - Use NV_INFO_ONCE for printing GMUX information, since otherwise this
      will end up printing that message for as many times as we have
      connectors
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Karol Herbst <kherbst@redhat.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 0acc07555bcd..6f89d4938059 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -39,6 +39,10 @@
 
 struct nvkm_i2c_port;
 
+#ifdef CONFIG_DRM_NOUVEAU_BACKLIGHT
+struct nouveau_backlight;
+#endif
+
 struct nouveau_connector {
 	struct drm_connector base;
 	enum dcb_connector_type type;
@@ -55,6 +59,9 @@ struct nouveau_connector {
 	struct nouveau_encoder *detected_encoder;
 	struct edid *edid;
 	struct drm_display_mode *native_mode;
+#ifdef CONFIG_DRM_NOUVEAU_BACKLIGHT
+	struct nouveau_backlight *backlight;
+#endif
 };
 
 static inline struct nouveau_connector *nouveau_connector(
@@ -181,4 +188,30 @@ int nouveau_conn_atomic_get_property(struct drm_connector *,
 				     const struct drm_connector_state *,
 				     struct drm_property *, u64 *);
 struct drm_display_mode *nouveau_conn_native_mode(struct drm_connector *);
+
+#ifdef CONFIG_DRM_NOUVEAU_BACKLIGHT
+extern int nouveau_backlight_init(struct drm_connector *);
+extern void nouveau_backlight_exit(struct drm_connector *);
+extern void nouveau_backlight_ctor(void);
+extern void nouveau_backlight_dtor(void);
+#else
+static inline int
+nouveau_backlight_init(struct drm_connector *connector)
+{
+	return 0;
+}
+
+static inline void
+nouveau_backlight_exit(struct drm_connector *connector) {
+}
+
+static inline void
+nouveau_backlight_ctor(void) {
+}
+
+static inline void
+nouveau_backlight_dtor(void) {
+}
+#endif
+
 #endif /* __NOUVEAU_CONNECTOR_H__ */

commit d78aa650670d2257099469c344d4d147a43652d9
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Sep 5 15:57:05 2018 +0200

    drm: Add drm/drm_util.h header file
    
    We have a bunch of neat little macros all over the place which should
    move to kernel.h. But some of them died in bikesheds on lkml, and we
    need a decent home for them.
    
    Start out by moving the for_each_if macro there.
    
    v2: Rename to drm_util.h instead (Dave&Sean)
    
    Cc: Sean Paul <seanpaul@chromium.org>
    Acked-by: Sean Paul <seanpaul@chromium.org>
    Cc: Dave Airlie <airlied@gmail.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180905135711.28370-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index dc7454e7f19a..0acc07555bcd 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -32,6 +32,8 @@
 #include <drm/drm_edid.h>
 #include <drm/drm_encoder.h>
 #include <drm/drm_dp_helper.h>
+#include <drm/drm_util.h>
+
 #include "nouveau_crtc.h"
 #include "nouveau_encoder.h"
 

commit 37afe55b4ae0600deafe7c0e0e658593c4754f1b
Author: Lyude Paul <lyude@redhat.com>
Date:   Fri Jul 13 13:06:33 2018 -0400

    drm/nouveau: Avoid looping through fake MST connectors
    
    When MST and atomic were introduced to nouveau, another structure that
    could contain a drm_connector embedded within it was introduced; struct
    nv50_mstc. This meant that we no longer would be able to simply loop
    through our connector list and assume that nouveau_connector() would
    return a proper pointer for each connector, since the assertion that
    all connectors coming from nouveau have a full nouveau_connector struct
    became invalid.
    
    Unfortunately, none of the actual code that looped through connectors
    ever got updated, which means that we've been causing invalid memory
    accesses for quite a while now.
    
    An example that was caught by KASAN:
    
    [  201.038698] ==================================================================
    [  201.038792] BUG: KASAN: slab-out-of-bounds in nvif_notify_get+0x190/0x1a0 [nouveau]
    [  201.038797] Read of size 4 at addr ffff88076738c650 by task kworker/0:3/718
    [  201.038800]
    [  201.038822] CPU: 0 PID: 718 Comm: kworker/0:3 Tainted: G           O      4.18.0-rc4Lyude-Test+ #1
    [  201.038825] Hardware name: LENOVO 20EQS64N0B/20EQS64N0B, BIOS N1EET78W (1.51 ) 05/18/2018
    [  201.038882] Workqueue: events nouveau_display_hpd_work [nouveau]
    [  201.038887] Call Trace:
    [  201.038894]  dump_stack+0xa4/0xfd
    [  201.038900]  print_address_description+0x71/0x239
    [  201.038929]  ? nvif_notify_get+0x190/0x1a0 [nouveau]
    [  201.038935]  kasan_report.cold.6+0x242/0x2fe
    [  201.038942]  __asan_report_load4_noabort+0x19/0x20
    [  201.038970]  nvif_notify_get+0x190/0x1a0 [nouveau]
    [  201.038998]  ? nvif_notify_put+0x1f0/0x1f0 [nouveau]
    [  201.039003]  ? kmsg_dump_rewind_nolock+0xe4/0xe4
    [  201.039049]  nouveau_display_init.cold.12+0x34/0x39 [nouveau]
    [  201.039089]  ? nouveau_user_framebuffer_create+0x120/0x120 [nouveau]
    [  201.039133]  nouveau_display_resume+0x5c0/0x810 [nouveau]
    [  201.039173]  ? nvkm_client_ioctl+0x20/0x20 [nouveau]
    [  201.039215]  nouveau_do_resume+0x19f/0x570 [nouveau]
    [  201.039256]  nouveau_pmops_runtime_resume+0xd8/0x2a0 [nouveau]
    [  201.039264]  pci_pm_runtime_resume+0x130/0x250
    [  201.039269]  ? pci_restore_standard_config+0x70/0x70
    [  201.039275]  __rpm_callback+0x1f2/0x5d0
    [  201.039279]  ? rpm_resume+0x560/0x18a0
    [  201.039283]  ? pci_restore_standard_config+0x70/0x70
    [  201.039287]  ? pci_restore_standard_config+0x70/0x70
    [  201.039291]  ? pci_restore_standard_config+0x70/0x70
    [  201.039296]  rpm_callback+0x175/0x210
    [  201.039300]  ? pci_restore_standard_config+0x70/0x70
    [  201.039305]  rpm_resume+0xcc3/0x18a0
    [  201.039312]  ? rpm_callback+0x210/0x210
    [  201.039317]  ? __pm_runtime_resume+0x9e/0x100
    [  201.039322]  ? kasan_check_write+0x14/0x20
    [  201.039326]  ? do_raw_spin_lock+0xc2/0x1c0
    [  201.039333]  __pm_runtime_resume+0xac/0x100
    [  201.039374]  nouveau_display_hpd_work+0x67/0x1f0 [nouveau]
    [  201.039380]  process_one_work+0x7a0/0x14d0
    [  201.039388]  ? cancel_delayed_work_sync+0x20/0x20
    [  201.039392]  ? lock_acquire+0x113/0x310
    [  201.039398]  ? kasan_check_write+0x14/0x20
    [  201.039402]  ? do_raw_spin_lock+0xc2/0x1c0
    [  201.039409]  worker_thread+0x86/0xb50
    [  201.039418]  kthread+0x2e9/0x3a0
    [  201.039422]  ? process_one_work+0x14d0/0x14d0
    [  201.039426]  ? kthread_create_worker_on_cpu+0xc0/0xc0
    [  201.039431]  ret_from_fork+0x3a/0x50
    [  201.039441]
    [  201.039444] Allocated by task 79:
    [  201.039449]  save_stack+0x43/0xd0
    [  201.039452]  kasan_kmalloc+0xc4/0xe0
    [  201.039456]  kmem_cache_alloc_trace+0x10a/0x260
    [  201.039494]  nv50_mstm_add_connector+0x9a/0x340 [nouveau]
    [  201.039504]  drm_dp_add_port+0xff5/0x1fc0 [drm_kms_helper]
    [  201.039511]  drm_dp_send_link_address+0x4a7/0x740 [drm_kms_helper]
    [  201.039518]  drm_dp_check_and_send_link_address+0x1a7/0x210 [drm_kms_helper]
    [  201.039525]  drm_dp_mst_link_probe_work+0x71/0xb0 [drm_kms_helper]
    [  201.039529]  process_one_work+0x7a0/0x14d0
    [  201.039533]  worker_thread+0x86/0xb50
    [  201.039537]  kthread+0x2e9/0x3a0
    [  201.039541]  ret_from_fork+0x3a/0x50
    [  201.039543]
    [  201.039546] Freed by task 0:
    [  201.039549] (stack is not available)
    [  201.039551]
    [  201.039555] The buggy address belongs to the object at ffff88076738c1a8
                                     which belongs to the cache kmalloc-2048 of size 2048
    [  201.039559] The buggy address is located 1192 bytes inside of
                                     2048-byte region [ffff88076738c1a8, ffff88076738c9a8)
    [  201.039563] The buggy address belongs to the page:
    [  201.039567] page:ffffea001d9ce200 count:1 mapcount:0 mapping:ffff88084000d0c0 index:0x0 compound_mapcount: 0
    [  201.039573] flags: 0x8000000000008100(slab|head)
    [  201.039578] raw: 8000000000008100 ffffea001da3be08 ffffea001da25a08 ffff88084000d0c0
    [  201.039582] raw: 0000000000000000 00000000000d000d 00000001ffffffff 0000000000000000
    [  201.039585] page dumped because: kasan: bad access detected
    [  201.039588]
    [  201.039591] Memory state around the buggy address:
    [  201.039594]  ffff88076738c500: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [  201.039598]  ffff88076738c580: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [  201.039601] >ffff88076738c600: 00 00 00 00 00 00 00 00 00 00 fc fc fc fc fc fc
    [  201.039604]                                                  ^
    [  201.039607]  ffff88076738c680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [  201.039611]  ffff88076738c700: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [  201.039613] ==================================================================
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Cc: stable@vger.kernel.org
    Cc: Karol Herbst <karolherbst@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index a8cbb4b56fc7..dc7454e7f19a 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -33,6 +33,7 @@
 #include <drm/drm_encoder.h>
 #include <drm/drm_dp_helper.h>
 #include "nouveau_crtc.h"
+#include "nouveau_encoder.h"
 
 struct nvkm_i2c_port;
 
@@ -60,6 +61,27 @@ static inline struct nouveau_connector *nouveau_connector(
 	return container_of(con, struct nouveau_connector, base);
 }
 
+static inline bool
+nouveau_connector_is_mst(struct drm_connector *connector)
+{
+	const struct nouveau_encoder *nv_encoder;
+	const struct drm_encoder *encoder;
+
+	if (connector->connector_type != DRM_MODE_CONNECTOR_DisplayPort)
+		return false;
+
+	nv_encoder = find_encoder(connector, DCB_OUTPUT_ANY);
+	if (!nv_encoder)
+		return false;
+
+	encoder = &nv_encoder->base.base;
+	return encoder->encoder_type == DRM_MODE_ENCODER_DPMST;
+}
+
+#define nouveau_for_each_non_mst_connector_iter(connector, iter) \
+	drm_for_each_connector_iter(connector, iter) \
+		for_each_if(!nouveau_connector_is_mst(connector))
+
 static inline struct nouveau_connector *
 nouveau_crtc_connector_get(struct nouveau_crtc *nv_crtc)
 {
@@ -70,7 +92,7 @@ nouveau_crtc_connector_get(struct nouveau_crtc *nv_crtc)
 	struct drm_crtc *crtc = to_drm_crtc(nv_crtc);
 
 	drm_connector_list_iter_begin(dev, &conn_iter);
-	drm_for_each_connector_iter(connector, &conn_iter) {
+	nouveau_for_each_non_mst_connector_iter(connector, &conn_iter) {
 		if (connector->encoder && connector->encoder->crtc == crtc) {
 			nv_connector = nouveau_connector(connector);
 			break;

commit 22b76bbe089cd901f5260ecb9a3dc41f9edb97a0
Author: Lyude Paul <lyude@redhat.com>
Date:   Fri Jul 13 13:06:32 2018 -0400

    drm/nouveau: Use drm_connector_list_iter_* for iterating connectors
    
    Every codepath in nouveau that loops through the connector list
    currently does so using the old method, which is prone to race
    conditions from MST connectors being created and destroyed. This has
    been causing a multitude of problems, including memory corruption from
    trying to access connectors that have already been freed!
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Cc: stable@vger.kernel.org
    Cc: Karol Herbst <karolherbst@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index a4d1a059bd3d..a8cbb4b56fc7 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -65,14 +65,20 @@ nouveau_crtc_connector_get(struct nouveau_crtc *nv_crtc)
 {
 	struct drm_device *dev = nv_crtc->base.dev;
 	struct drm_connector *connector;
+	struct drm_connector_list_iter conn_iter;
+	struct nouveau_connector *nv_connector = NULL;
 	struct drm_crtc *crtc = to_drm_crtc(nv_crtc);
 
-	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
-		if (connector->encoder && connector->encoder->crtc == crtc)
-			return nouveau_connector(connector);
+	drm_connector_list_iter_begin(dev, &conn_iter);
+	drm_for_each_connector_iter(connector, &conn_iter) {
+		if (connector->encoder && connector->encoder->crtc == crtc) {
+			nv_connector = nouveau_connector(connector);
+			break;
+		}
 	}
+	drm_connector_list_iter_end(&conn_iter);
 
-	return NULL;
+	return nv_connector;
 }
 
 struct drm_connector *

commit 9338203c4f03ffe323b67f0b2fa17b9811fa9bb6
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Nov 28 20:51:09 2016 +0200

    drm: Don't include <drm/drm_encoder.h> in <drm/drm_crtc.h>
    
    <drm/drm_crtc.h> used to define most of the in-kernel KMS API. It has
    now been split into separate files for each object type, but still
    includes most other KMS headers to avoid breaking driver compilation.
    
    As a step towards fixing that problem, remove the inclusion of
    <drm/drm_encoder.h> from <drm/drm_crtc.h> and include it instead where
    appropriate. Also remove the forward declarations of the drm_encoder and
    drm_encoder_helper_funcs structures from <drm/drm_crtc.h> as they're not
    needed in the header.
    
    <drm/drm_encoder.h> now has to include <drm/drm_mode.h> and contain a
    forward declaration of struct drm_encoder in order to allow including it
    as the first header in a compilation unit.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com> # For vmwgfx
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481709550-29226-2-git-send-email-laurent.pinchart+renesas@ideasonboard.com

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 096983c42a1f..a4d1a059bd3d 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -30,6 +30,7 @@
 #include <nvif/notify.h>
 
 #include <drm/drm_edid.h>
+#include <drm/drm_encoder.h>
 #include <drm/drm_dp_helper.h>
 #include "nouveau_crtc.h"
 

commit c2d926aacc7eeaf39edbd0ab8d5fba33acbb168d
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 4 17:20:36 2016 +1000

    drm/nouveau/kms/nv50: remove code to support non-atomic connector properties
    
    Made completely unreachable by atomic commits.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 77bb69ec9d34..096983c42a1f 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -46,12 +46,7 @@ struct nouveau_connector {
 	struct drm_dp_aux aux;
 
 	int dithering_mode;
-	int dithering_depth;
 	int scaling_mode;
-	bool scaling_full;
-	int underscan;
-	u32 underscan_hborder;
-	u32 underscan_vborder;
 
 	struct nouveau_encoder *detected_encoder;
 	struct edid *edid;

commit c4e6812c1c406df24eb1a59568f210841beb5f33
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 4 17:20:36 2016 +1000

    drm/nouveau/kms/nv50: separate out viewport commit
    
    This commit separates the calculation of EVO state from the commit, in
    order to make the same code useful for atomic modesetting.
    
    The legacy interfaces have been wrapped on top of them.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index ed1187efe708..77bb69ec9d34 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -124,6 +124,7 @@ struct nouveau_conn_atom {
 			u32 hborder;
 			u32 vborder;
 		} underscan;
+		bool full;
 	} scaler;
 
 	struct {

commit 56182b8bd14bb8fe85d4d6e6bcbc9779ad538288
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 4 17:20:35 2016 +1000

    drm/nouveau/kms: separate connector property attach from nouveau_connector
    
    These will also be used by MST connectors.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index c366b3842fb2..ed1187efe708 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -141,6 +141,7 @@ struct nouveau_conn_atom {
 	} set;
 };
 
+void nouveau_conn_attach_properties(struct drm_connector *);
 void nouveau_conn_reset(struct drm_connector *);
 struct drm_connector_state *
 nouveau_conn_atomic_duplicate_state(struct drm_connector *);

commit 616915ec7629af65532e2220792e3ec83ee3510b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 4 17:20:35 2016 +1000

    drm/nouveau/kms: subclass atomic connector state
    
    This commit implements the atomic property hooks for a connector, and
    wraps the legacy interface handling on top of those.
    
    For the moment, a full modeset will be done after any property change
    in order to ease subsequent changes.  The optimised behaviour will be
    restored for Tesla and later (earlier boards always do full modesets)
    once atomic commits are implemented.
    
    Some functions are put under the "nouveau_conn" namespace now, rather
    than "nouveau_connector", to distinguish functions that will work for
    (upcoming) MST connectors too.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 43b9583304d0..c366b3842fb2 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -35,30 +35,6 @@
 
 struct nvkm_i2c_port;
 
-enum nouveau_underscan_type {
-	UNDERSCAN_OFF,
-	UNDERSCAN_ON,
-	UNDERSCAN_AUTO,
-};
-
-/* the enum values specifically defined here match nv50/nvd0 hw values, and
- * the code relies on this
- */
-enum nouveau_dithering_mode {
-	DITHERING_MODE_OFF = 0x00,
-	DITHERING_MODE_ON = 0x01,
-	DITHERING_MODE_DYNAMIC2X2 = 0x10 | DITHERING_MODE_ON,
-	DITHERING_MODE_STATIC2X2 = 0x18 | DITHERING_MODE_ON,
-	DITHERING_MODE_TEMPORAL = 0x20 | DITHERING_MODE_ON,
-	DITHERING_MODE_AUTO
-};
-
-enum nouveau_dithering_depth {
-	DITHERING_DEPTH_6BPC = 0x00,
-	DITHERING_DEPTH_8BPC = 0x02,
-	DITHERING_DEPTH_AUTO
-};
-
 struct nouveau_connector {
 	struct drm_connector base;
 	enum dcb_connector_type type;
@@ -73,7 +49,7 @@ struct nouveau_connector {
 	int dithering_depth;
 	int scaling_mode;
 	bool scaling_full;
-	enum nouveau_underscan_type underscan;
+	int underscan;
 	u32 underscan_hborder;
 	u32 underscan_vborder;
 
@@ -111,4 +87,70 @@ extern int nouveau_ignorelid;
 extern int nouveau_duallink;
 extern int nouveau_hdmimhz;
 
+#include <drm/drm_crtc.h>
+#define nouveau_conn_atom(p)                                                   \
+	container_of((p), struct nouveau_conn_atom, state)
+
+struct nouveau_conn_atom {
+	struct drm_connector_state state;
+
+	struct {
+		/* The enum values specifically defined here match nv50/gf119
+		 * hw values, and the code relies on this.
+		 */
+		enum {
+			DITHERING_MODE_OFF = 0x00,
+			DITHERING_MODE_ON = 0x01,
+			DITHERING_MODE_DYNAMIC2X2 = 0x10 | DITHERING_MODE_ON,
+			DITHERING_MODE_STATIC2X2 = 0x18 | DITHERING_MODE_ON,
+			DITHERING_MODE_TEMPORAL = 0x20 | DITHERING_MODE_ON,
+			DITHERING_MODE_AUTO
+		} mode;
+		enum {
+			DITHERING_DEPTH_6BPC = 0x00,
+			DITHERING_DEPTH_8BPC = 0x02,
+			DITHERING_DEPTH_AUTO
+		} depth;
+	} dither;
+
+	struct {
+		int mode;	/* DRM_MODE_SCALE_* */
+		struct {
+			enum {
+				UNDERSCAN_OFF,
+				UNDERSCAN_ON,
+				UNDERSCAN_AUTO,
+			} mode;
+			u32 hborder;
+			u32 vborder;
+		} underscan;
+	} scaler;
+
+	struct {
+		int color_vibrance;
+		int vibrant_hue;
+	} procamp;
+
+	union {
+		struct {
+			bool dither:1;
+			bool scaler:1;
+			bool procamp:1;
+		};
+		u8 mask;
+	} set;
+};
+
+void nouveau_conn_reset(struct drm_connector *);
+struct drm_connector_state *
+nouveau_conn_atomic_duplicate_state(struct drm_connector *);
+void nouveau_conn_atomic_destroy_state(struct drm_connector *,
+				       struct drm_connector_state *);
+int nouveau_conn_atomic_set_property(struct drm_connector *,
+				     struct drm_connector_state *,
+				     struct drm_property *, u64);
+int nouveau_conn_atomic_get_property(struct drm_connector *,
+				     const struct drm_connector_state *,
+				     struct drm_property *, u64 *);
+struct drm_display_mode *nouveau_conn_native_mode(struct drm_connector *);
 #endif /* __NOUVEAU_CONNECTOR_H__ */

commit f3a8b6645dc2e60d11f20c1c23afd964ff4e55ae
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 4 11:44:21 2016 +1000

    drm/nouveau: silence sparse warnings about symbols not being marked static
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 7446ee66ea04..43b9583304d0 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -109,5 +109,6 @@ nouveau_connector_create(struct drm_device *, int index);
 extern int nouveau_tv_disable;
 extern int nouveau_ignorelid;
 extern int nouveau_duallink;
+extern int nouveau_hdmimhz;
 
 #endif /* __NOUVEAU_CONNECTOR_H__ */

commit be83cd4ef9a2a56bd35550bf96146b7b837daf02
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:36:34 2015 +1000

    drm/nouveau: finalise nvkm namespace switch (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index a2d099142d96..7446ee66ea04 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -33,7 +33,7 @@
 #include <drm/drm_dp_helper.h>
 #include "nouveau_crtc.h"
 
-struct nouveau_i2c_port;
+struct nvkm_i2c_port;
 
 enum nouveau_underscan_type {
 	UNDERSCAN_OFF,

commit 576f79116ee8ed6f41f0f9f1fc295eaad5d5aeee
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon Dec 22 17:19:26 2014 +1000

    drm/nv50-/kms: allow disabling of gpu scaling on fixed panels
    
    The hilarious part is that, under X, this won't work anyway because the
    server decides to construct its own modes for some reason.
    
    Tested with modetest, which isn't quite as insane.  I'd hope that
    wayland is more sensible.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 629a380c7085..a2d099142d96 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -72,6 +72,7 @@ struct nouveau_connector {
 	int dithering_mode;
 	int dithering_depth;
 	int scaling_mode;
+	bool scaling_full;
 	enum nouveau_underscan_type underscan;
 	u32 underscan_hborder;
 	u32 underscan_vborder;

commit 703fa264b1c09ff9d0526553f5448fef77fda898
Author: Pierre Moreau <pierre.morrow@free.fr>
Date:   Mon Aug 18 22:43:24 2014 +0200

    drm/nouveau: Display Nouveau boot options at launch
    
    It can help to remove any ambiguity about which options were passed to Nouveau,
    especially in case the user had some options set in /etc/modprobe.d/*.conf that
    he forgot about, as they won't appear in a dmesg.
    
    Signed-off-by: Pierre Moreau <pierre.morrow@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 68029d041dd2..629a380c7085 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -105,4 +105,8 @@ nouveau_crtc_connector_get(struct nouveau_crtc *nv_crtc)
 struct drm_connector *
 nouveau_connector_create(struct drm_device *, int index);
 
+extern int nouveau_tv_disable;
+extern int nouveau_ignorelid;
+extern int nouveau_duallink;
+
 #endif /* __NOUVEAU_CONNECTOR_H__ */

commit 80bc340b3dd720c5b7818e21a9a1ee36e1d7ef30
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Aug 10 04:10:28 2014 +1000

    drm/nouveau/disp: implement nvif event sources for vblank/connector notifiers
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index a64f4629628d..68029d041dd2 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -27,6 +27,8 @@
 #ifndef __NOUVEAU_CONNECTOR_H__
 #define __NOUVEAU_CONNECTOR_H__
 
+#include <nvif/notify.h>
+
 #include <drm/drm_edid.h>
 #include <drm/drm_dp_helper.h>
 #include "nouveau_crtc.h"
@@ -63,7 +65,7 @@ struct nouveau_connector {
 	u8 index;
 	u8 *dcb;
 
-	struct nvkm_notify hpd;
+	struct nvif_notify hpd;
 
 	struct drm_dp_aux aux;
 

commit fdb751ef2bbc78314d1e01d3425cfacfb19b9f86
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Aug 10 04:10:23 2014 +1000

    drm/nouveau: remove as much direct use of core headers as possible
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 0dcec024ec7d..a64f4629628d 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -31,10 +31,6 @@
 #include <drm/drm_dp_helper.h>
 #include "nouveau_crtc.h"
 
-#include <core/event.h>
-
-#include <subdev/bios.h>
-
 struct nouveau_i2c_port;
 
 enum nouveau_underscan_type {

commit 79ca27706a034b683196c85f5c6901b78e5ab8f0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Aug 10 04:10:20 2014 +1000

    drm/nouveau/core: rework event interface
    
    This is a lot of prep-work for being able to send event notifications
    back to userspace.  Events now contain data, rather than a "something
    just happened" signal.
    
    Handler data is now embedded into a containing structure, rather than
    being kmalloc()'d, and can optionally have the notify routine handled
    in a workqueue.
    
    Various races between suspend/unload with display HPD/DP IRQ handlers
    automagically solved as a result.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 8861b6c579ad..0dcec024ec7d 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -67,9 +67,7 @@ struct nouveau_connector {
 	u8 index;
 	u8 *dcb;
 
-	struct nouveau_eventh *hpd;
-	u32 status;
-	struct work_struct work;
+	struct nvkm_notify hpd;
 
 	struct drm_dp_aux aux;
 

commit 8894f4919bc43f821775db2cfff4b917871b2102
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 30 16:20:58 2014 +1000

    drm/nouveau: register a drm_dp_aux channel for each dp connector
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 7e7682dfa991..8861b6c579ad 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -28,6 +28,7 @@
 #define __NOUVEAU_CONNECTOR_H__
 
 #include <drm/drm_edid.h>
+#include <drm/drm_dp_helper.h>
 #include "nouveau_crtc.h"
 
 #include <core/event.h>
@@ -70,6 +71,8 @@ struct nouveau_connector {
 	u32 status;
 	struct work_struct work;
 
+	struct drm_dp_aux aux;
+
 	int dithering_mode;
 	int dithering_depth;
 	int scaling_mode;

commit 456b0579fb0af095c24fa9e5867bd3983b842b1a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 30 12:49:17 2014 +1000

    drm/nouveau: use connector events for HPD instead of GPIO watching
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 264a778f473b..7e7682dfa991 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -33,7 +33,6 @@
 #include <core/event.h>
 
 #include <subdev/bios.h>
-#include <subdev/bios/gpio.h>
 
 struct nouveau_i2c_port;
 
@@ -67,9 +66,9 @@ struct nouveau_connector {
 	u8 index;
 	u8 *dcb;
 
-	struct dcb_gpio_func hpd;
-	struct work_struct hpd_work;
-	struct nouveau_eventh *hpd_func;
+	struct nouveau_eventh *hpd;
+	u32 status;
+	struct work_struct work;
 
 	int dithering_mode;
 	int dithering_depth;

commit 4449933a3703704e8dc74ea774372857240c142d
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Thu Sep 5 04:45:00 2013 -0400

    drm/nouveau: remove prototype for non-existent nouveau_connector_bpp
    
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 27c2be68810e..264a778f473b 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -107,7 +107,4 @@ nouveau_crtc_connector_get(struct nouveau_crtc *nv_crtc)
 struct drm_connector *
 nouveau_connector_create(struct drm_device *, int index);
 
-int
-nouveau_connector_bpp(struct drm_connector *);
-
 #endif /* __NOUVEAU_CONNECTOR_H__ */

commit 51cb4b392a307a8293b4f1f300ab803d7ad3b036
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Oct 3 07:02:29 2013 +1000

    drm/nouveau/core: convert event handler apis to split create/enable semantics
    
    This is a necessary step towards being able to work with the insane locking
    requirements of the DRM core's vblank routines, and a nice cleanup as a
    side-effect.
    
    This is similar in spirit to the interfaces that Peter Hurley arrived at
    with his nouveau_event rcu conversion series.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 6e399aad491a..27c2be68810e 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -69,7 +69,7 @@ struct nouveau_connector {
 
 	struct dcb_gpio_func hpd;
 	struct work_struct hpd_work;
-	struct nouveau_eventh hpd_func;
+	struct nouveau_eventh *hpd_func;
 
 	int dithering_mode;
 	int dithering_depth;

commit 4f47643dbb4c345c5beebe53588682a7ff2c872a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Feb 3 12:56:16 2013 +1000

    drm/nouveau/gpio: use event interfaces for interrupt signalling
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index f37250c8469d..6e399aad491a 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -30,6 +30,8 @@
 #include <drm/drm_edid.h>
 #include "nouveau_crtc.h"
 
+#include <core/event.h>
+
 #include <subdev/bios.h>
 #include <subdev/bios/gpio.h>
 
@@ -62,10 +64,13 @@ enum nouveau_dithering_depth {
 struct nouveau_connector {
 	struct drm_connector base;
 	enum dcb_connector_type type;
-	struct dcb_gpio_func hpd;
 	u8 index;
 	u8 *dcb;
 
+	struct dcb_gpio_func hpd;
+	struct work_struct hpd_work;
+	struct nouveau_eventh hpd_func;
+
 	int dithering_mode;
 	int dithering_depth;
 	int scaling_mode;

commit 23fc09ee09c3b8f904a2220c7f71b2ff04e91219
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Feb 3 20:29:53 2013 +1000

    drm/nouveau/drm: store full dcb gpio function data in connector
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 20eb84cce9e6..f37250c8469d 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -30,6 +30,9 @@
 #include <drm/drm_edid.h>
 #include "nouveau_crtc.h"
 
+#include <subdev/bios.h>
+#include <subdev/bios/gpio.h>
+
 struct nouveau_i2c_port;
 
 enum nouveau_underscan_type {
@@ -59,9 +62,9 @@ enum nouveau_dithering_depth {
 struct nouveau_connector {
 	struct drm_connector base;
 	enum dcb_connector_type type;
+	struct dcb_gpio_func hpd;
 	u8 index;
 	u8 *dcb;
-	u8 hpd;
 
 	int dithering_mode;
 	int dithering_depth;

commit 4f6029da58ba9204c98e33f4f3737fe085c87a6f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 16 11:54:31 2012 +1000

    drm/nv50-nvc0: switch to common disp impl, removing previous version
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index ebdb87670a8f..20eb84cce9e6 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -28,6 +28,7 @@
 #define __NOUVEAU_CONNECTOR_H__
 
 #include <drm/drm_edid.h>
+#include "nouveau_crtc.h"
 
 struct nouveau_i2c_port;
 
@@ -80,6 +81,21 @@ static inline struct nouveau_connector *nouveau_connector(
 	return container_of(con, struct nouveau_connector, base);
 }
 
+static inline struct nouveau_connector *
+nouveau_crtc_connector_get(struct nouveau_crtc *nv_crtc)
+{
+	struct drm_device *dev = nv_crtc->base.dev;
+	struct drm_connector *connector;
+	struct drm_crtc *crtc = to_drm_crtc(nv_crtc);
+
+	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+		if (connector->encoder && connector->encoder->crtc == crtc)
+			return nouveau_connector(connector);
+	}
+
+	return NULL;
+}
+
 struct drm_connector *
 nouveau_connector_create(struct drm_device *, int index);
 

commit 612a9aab56a93533e76e3ad91642db7033e03b69
Merge: 3a494318b14b 268d28371cd3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 3 23:29:23 2012 -0700

    Merge branch 'drm-next' of git://people.freedesktop.org/~airlied/linux
    
    Pull drm merge (part 1) from Dave Airlie:
     "So first of all my tree and uapi stuff has a conflict mess, its my
      fault as the nouveau stuff didn't hit -next as were trying to rebase
      regressions out of it before we merged.
    
      Highlights:
       - SH mobile modesetting driver and associated helpers
       - some DRM core documentation
       - i915 modesetting rework, haswell hdmi, haswell and vlv fixes, write
         combined pte writing, ilk rc6 support,
       - nouveau: major driver rework into a hw core driver, makes features
         like SLI a lot saner to implement,
       - psb: add eDP/DP support for Cedarview
       - radeon: 2 layer page tables, async VM pte updates, better PLL
         selection for > 2 screens, better ACPI interactions
    
      The rest is general grab bag of fixes.
    
      So why part 1? well I have the exynos pull req which came in a bit
      late but was waiting for me to do something they shouldn't have and it
      looks fairly safe, and David Howells has some more header cleanups
      he'd like me to pull, that seem like a good idea, but I'd like to get
      this merge out of the way so -next dosen't get blocked."
    
    Tons of conflicts mostly due to silly include line changes, but mostly
    mindless.  A few other small semantic conflicts too, noted from Dave's
    pre-merged branch.
    
    * 'drm-next' of git://people.freedesktop.org/~airlied/linux: (447 commits)
      drm/nv98/crypt: fix fuc build with latest envyas
      drm/nouveau/devinit: fixup various issues with subdev ctor/init ordering
      drm/nv41/vm: fix and enable use of "real" pciegart
      drm/nv44/vm: fix and enable use of "real" pciegart
      drm/nv04/dmaobj: fixup vm target handling in preparation for nv4x pcie
      drm/nouveau: store supported dma mask in vmmgr
      drm/nvc0/ibus: initial implementation of subdev
      drm/nouveau/therm: add support for fan-control modes
      drm/nouveau/hwmon: rename pwm0* to pmw1* to follow hwmon's rules
      drm/nouveau/therm: calculate the pwm divisor on nv50+
      drm/nouveau/fan: rewrite the fan tachometer driver to get more precision, faster
      drm/nouveau/therm: move thermal-related functions to the therm subdev
      drm/nouveau/bios: parse the pwm divisor from the perf table
      drm/nouveau/therm: use the EXTDEV table to detect i2c monitoring devices
      drm/nouveau/therm: rework thermal table parsing
      drm/nouveau/gpio: expose the PWM/TOGGLE parameter found in the gpio vbios table
      drm/nouveau: fix pm initialization order
      drm/nouveau/bios: check that fixed tvdac gpio data is valid before using it
      drm/nouveau: log channel debug/error messages from client object rather than drm client
      drm/nouveau: have drm debugging macros build on top of core macros
      ...

commit 4196faa8623264b79279a06fd186654c959f2767
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jul 10 14:36:38 2012 +1000

    drm/nouveau/i2c: port to subdev interfaces
    
    v2/v3: Ben Skeggs <bskeggs@redhat.com>
    - fix typo in default bus selection
    - fix accidental loss of destructor
    
    v4: Dmitry Eremin-Solenikov <dmitry_eremin@mentor.com>
    - fix typo causing incorrect default i2c port settings when no BMP data
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index bb0faf9f5d1e..9503cfa0492c 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -28,7 +28,8 @@
 #define __NOUVEAU_CONNECTOR_H__
 
 #include "drm_edid.h"
-#include <subdev/i2c.h>
+
+struct nouveau_i2c_port;
 
 enum nouveau_underscan_type {
 	UNDERSCAN_OFF,

commit 02a841d434513c7b3620250271c372fabce56de5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jul 4 23:44:54 2012 +1000

    drm/nouveau: restructure source tree, split core from drm implementation
    
    Future work will be headed in the way of separating the policy supplied by
    the nouveau drm module from the mechanisms provided by the driver core.
    
    There will be a couple of major classes (subdev, engine) of driver modules
    that have clearly defined tasks, and the further directory structure change
    is to reflect this.
    
    No code changes here whatsoever, aside from fixing up a couple of include
    file pathnames.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index e4857021304c..bb0faf9f5d1e 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -28,7 +28,7 @@
 #define __NOUVEAU_CONNECTOR_H__
 
 #include "drm_edid.h"
-#include "nouveau_i2c.h"
+#include <subdev/i2c.h>
 
 enum nouveau_underscan_type {
 	UNDERSCAN_OFF,

commit 760285e7e7ab282c25b5e90816f7c47000557f4f
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 2 18:01:07 2012 +0100

    UAPI: (Scripted) Convert #include "..." to #include <path/...> in drivers/gpu/
    
    Convert #include "..." to #include <path/...> in drivers/gpu/.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Dave Airlie <airlied@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index e4857021304c..e1c1567c0c1a 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -27,7 +27,7 @@
 #ifndef __NOUVEAU_CONNECTOR_H__
 #define __NOUVEAU_CONNECTOR_H__
 
-#include "drm_edid.h"
+#include <drm/drm_edid.h>
 #include "nouveau_i2c.h"
 
 enum nouveau_underscan_type {

commit befb51e9c97e783c86a1da27bdda3a638d2f02c7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 18 10:23:59 2011 +1000

    drm/nouveau/disp: parse connector info directly in nouveau_connector.c
    
    Another case where we parsed vbios data to some structs, then again use
    that info once to construct another set of data.  Skip the intermediate
    step.
    
    This is also slightly improved in that we can now use DCB 3.x connector
    table info, which will allow NV4x to gain hotplug support, and to make
    quirks for SPWG LVDS panels unnecessary.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 6468f5e67ccf..e4857021304c 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -56,8 +56,10 @@ enum nouveau_dithering_depth {
 
 struct nouveau_connector {
 	struct drm_connector base;
-
-	struct dcb_connector_table_entry *dcb;
+	enum dcb_connector_type type;
+	u8 index;
+	u8 *dcb;
+	u8 hpd;
 
 	int dithering_mode;
 	int dithering_depth;

commit de69185573586302ada2e59ba41835df36986277
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon Oct 17 12:23:41 2011 +1000

    drm/nouveau: improve dithering properties, and implement proper auto mode
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 5bcaabbd375c..6468f5e67ccf 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -30,12 +30,37 @@
 #include "drm_edid.h"
 #include "nouveau_i2c.h"
 
+enum nouveau_underscan_type {
+	UNDERSCAN_OFF,
+	UNDERSCAN_ON,
+	UNDERSCAN_AUTO,
+};
+
+/* the enum values specifically defined here match nv50/nvd0 hw values, and
+ * the code relies on this
+ */
+enum nouveau_dithering_mode {
+	DITHERING_MODE_OFF = 0x00,
+	DITHERING_MODE_ON = 0x01,
+	DITHERING_MODE_DYNAMIC2X2 = 0x10 | DITHERING_MODE_ON,
+	DITHERING_MODE_STATIC2X2 = 0x18 | DITHERING_MODE_ON,
+	DITHERING_MODE_TEMPORAL = 0x20 | DITHERING_MODE_ON,
+	DITHERING_MODE_AUTO
+};
+
+enum nouveau_dithering_depth {
+	DITHERING_DEPTH_6BPC = 0x00,
+	DITHERING_DEPTH_8BPC = 0x02,
+	DITHERING_DEPTH_AUTO
+};
+
 struct nouveau_connector {
 	struct drm_connector base;
 
 	struct dcb_connector_table_entry *dcb;
 
-	bool use_dithering;
+	int dithering_mode;
+	int dithering_depth;
 	int scaling_mode;
 	enum nouveau_underscan_type underscan;
 	u32 underscan_hborder;

commit b29caa5885e85bbda7c84ea55721b9e79718583a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Oct 6 13:29:05 2011 +1000

    drm/nouveau: add overscan compensation connector properties
    
    Exposes the same connector properties as the Radeon implementation, however
    their behaviour isn't exactly the same.  The primary difference being that
    unless both hborder/vborder have been defined by the user, the driver will
    keep the aspect ratio of the overscanned area the same as the mode the
    display is programmed for.
    
    Enabled for digital outputs on GeForce 8 and up, excluding GF119.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 711b1e9203af..5bcaabbd375c 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -35,8 +35,11 @@ struct nouveau_connector {
 
 	struct dcb_connector_table_entry *dcb;
 
-	int scaling_mode;
 	bool use_dithering;
+	int scaling_mode;
+	enum nouveau_underscan_type underscan;
+	u32 underscan_hborder;
+	u32 underscan_vborder;
 
 	struct nouveau_encoder *detected_encoder;
 	struct edid *edid;

commit 01db363979e96115a895f35c823303660f0f328d
Author: Francisco Jerez <currojerez@riseup.net>
Date:   Thu Oct 21 17:43:08 2010 +0200

    drm/nouveau: Use "force" to decide if analog load detection is ok or not.
    
    Signed-off-by: Francisco Jerez <currojerez@riseup.net>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index c21ed6b16f88..711b1e9203af 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -52,9 +52,6 @@ static inline struct nouveau_connector *nouveau_connector(
 struct drm_connector *
 nouveau_connector_create(struct drm_device *, int index);
 
-void
-nouveau_connector_set_polling(struct drm_connector *);
-
 int
 nouveau_connector_bpp(struct drm_connector *);
 

commit 62acdc71cfbc816b26a57d89f433f8afaf4ff78d
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Sep 28 10:23:20 2010 +1000

    drm/nouveau: fix required mode bandwidth calculation for DP
    
    This should fix eDP on certain laptops with 18-bit panels, we were rejecting
    the panel's native mode due to thinking there was insufficient bandwidth
    for it.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 0d2e668ccfe5..c21ed6b16f88 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -55,4 +55,7 @@ nouveau_connector_create(struct drm_device *, int index);
 void
 nouveau_connector_set_polling(struct drm_connector *);
 
+int
+nouveau_connector_bpp(struct drm_connector *);
+
 #endif /* __NOUVEAU_CONNECTOR_H__ */

commit 2ed06b7d974a750ccb90ff88f5b7a870b89db966
Author: Francisco Jerez <currojerez@riseup.net>
Date:   Sat Jul 3 15:52:03 2010 +0200

    drm/nv04-nv40: Disable connector polling when there're no spare CRTCs left.
    
    Load detection needs the connector wired to a CRTC, when there are no
    inactive CRTCs left that means we need to cut some other head off for
    a while, causing intermittent flickering.
    
    Signed-off-by: Francisco Jerez <currojerez@riseup.net>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 1ce3d913867e..0d2e668ccfe5 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -52,4 +52,7 @@ static inline struct nouveau_connector *nouveau_connector(
 struct drm_connector *
 nouveau_connector_create(struct drm_device *, int index);
 
+void
+nouveau_connector_set_polling(struct drm_connector *);
+
 #endif /* __NOUVEAU_CONNECTOR_H__ */

commit 8f1a60868f4594bc5576cca8952635f475e8bec6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon Jun 28 14:35:50 2010 +1000

    drm/nouveau: tidy connector/encoder creation a little
    
    Create connectors before encoders to avoid having to do another loop across
    encoder list whenever we create a new connector.  This allows us to pass
    the connector to the encoder creation functions, and avoid using a
    create_resources() callback since we can now call it directly.
    
    This can also potentially modify the connector ordering on nv50.  On cards
    where the DCB connector and encoder tables are in the same order, things
    will be unchanged.  However, there's some cards where the ordering between
    the tables differ, and in one case, leads us to naming the connectors
    "wrongly".
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 4ef38abc2d9c..1ce3d913867e 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -49,7 +49,7 @@ static inline struct nouveau_connector *nouveau_connector(
 	return container_of(con, struct nouveau_connector, base);
 }
 
-int nouveau_connector_create(struct drm_device *,
-			     struct dcb_connector_table_entry *);
+struct drm_connector *
+nouveau_connector_create(struct drm_device *, int index);
 
 #endif /* __NOUVEAU_CONNECTOR_H__ */

commit 7f612d87f8b4b1ddbcee04264a93e5af7b9f21c7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Feb 24 12:07:31 2010 +1000

    drm/nouveau: use dcb connector table for creating drm connectors
    
    This makes this code common to both the nv04 and nv50 paths.
    
    For the moment, we keep the previous behaviour with HDMI/eDP connectors
    and report them as DVI-D/DP instead.  This will be fixed once the rest
    of the code has been fixed to deal with those types.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
index 728b8090e5ff..4ef38abc2d9c 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.h
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -49,6 +49,7 @@ static inline struct nouveau_connector *nouveau_connector(
 	return container_of(con, struct nouveau_connector, base);
 }
 
-int nouveau_connector_create(struct drm_device *dev, int i2c_index, int type);
+int nouveau_connector_create(struct drm_device *,
+			     struct dcb_connector_table_entry *);
 
 #endif /* __NOUVEAU_CONNECTOR_H__ */

commit 6ee738610f41b59733f63718f0bdbcba7d3a3f12
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Dec 11 19:24:15 2009 +1000

    drm/nouveau: Add DRM driver for NVIDIA GPUs
    
    This adds a drm/kms staging non-API stable driver for GPUs from NVIDIA.
    
    This driver is a KMS-based driver and requires a compatible nouveau
    userspace libdrm and nouveau X.org driver.
    
    This driver requires firmware files not available in this kernel tree,
    interested parties can find them via the nouveau project git archive.
    
    This driver is reverse engineered, and is in no way supported by nVidia.
    
    Support for nearly the complete range of nvidia hw from nv04->g80 (nv50)
    is available, and the kms driver should support driving nearly all
    output types (displayport is under development still) along with supporting
    suspend/resume.
    
    This work is all from the upstream nouveau project found at
    nouveau.freedesktop.org.
    
    The original authors list from nouveau git tree is:
    Anssi Hannula <anssi.hannula@iki.fi>
    Ben Skeggs <bskeggs@redhat.com>
    Francisco Jerez <currojerez@riseup.net>
    Maarten Maathuis <madman2003@gmail.com>
    Marcin Kocielnicki <koriakin@0x04.net>
    Matthew Garrett <mjg@redhat.com>
    Matt Parnell <mparnell@gmail.com>
    Patrice Mandin <patmandin@gmail.com>
    Pekka Paalanen <pq@iki.fi>
    Xavier Chantry <shiningxc@gmail.com>
    along with project founder Stephane Marchesin <marchesin@icps.u-strasbg.fr>
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.h b/drivers/gpu/drm/nouveau/nouveau_connector.h
new file mode 100644
index 000000000000..728b8090e5ff
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2008 Maarten Maathuis.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __NOUVEAU_CONNECTOR_H__
+#define __NOUVEAU_CONNECTOR_H__
+
+#include "drm_edid.h"
+#include "nouveau_i2c.h"
+
+struct nouveau_connector {
+	struct drm_connector base;
+
+	struct dcb_connector_table_entry *dcb;
+
+	int scaling_mode;
+	bool use_dithering;
+
+	struct nouveau_encoder *detected_encoder;
+	struct edid *edid;
+	struct drm_display_mode *native_mode;
+};
+
+static inline struct nouveau_connector *nouveau_connector(
+						struct drm_connector *con)
+{
+	return container_of(con, struct nouveau_connector, base);
+}
+
+int nouveau_connector_create(struct drm_device *dev, int i2c_index, int type);
+
+#endif /* __NOUVEAU_CONNECTOR_H__ */
