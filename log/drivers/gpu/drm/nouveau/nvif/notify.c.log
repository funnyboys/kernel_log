commit 8423d75d8f15b8eba52f064707ee7892fba77837
Author: Lucas Stach <dev@lynxeye.de>
Date:   Wed Oct 26 13:11:06 2016 +0200

    drm/nouveau: fix notify data leak
    
    There is no reason to not free the notify data if the NTFY_DEL ioctl
    failed. As nvif_notify_fini() is also called from the cleanup path of
    nvif_notify_init(), the notifier may not have been successfully created
    at that point. But it should also be the right thing to just free the
    data in the regular fini calls, as there is nothing much we can do if
    the ioctl fails, so better not leak memory.
    
    Signed-off-by: Lucas Stach <dev@lynxeye.de>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvif/notify.c b/drivers/gpu/drm/nouveau/nvif/notify.c
index b0787ff833ef..278b3933dc96 100644
--- a/drivers/gpu/drm/nouveau/nvif/notify.c
+++ b/drivers/gpu/drm/nouveau/nvif/notify.c
@@ -155,10 +155,8 @@ nvif_notify_fini(struct nvif_notify *notify)
 	int ret = nvif_notify_put(notify);
 	if (ret >= 0 && object) {
 		ret = nvif_object_ioctl(object, &args, sizeof(args), NULL);
-		if (ret == 0) {
-			notify->object = NULL;
-			kfree((void *)notify->data);
-		}
+		notify->object = NULL;
+		kfree((void *)notify->data);
 	}
 	return ret;
 }

commit a01ca78c8f118e5a24f1527ecf078ab56ddd4805
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:15 2015 +1000

    drm/nouveau/nvif: simplify and tidy library interfaces
    
    A variety of tweaks to the NVIF library interfaces, mostly ripping out
    things that turned out to be not so useful.
    
    - Removed refcounting from nvif_object, callers are expected to not be
      stupid instead.
    - nvif_client is directly reachable from anything derived from nvif_object,
      removing the need for heuristics to locate it
    - _new() versions of interfaces, that allocate memory for the object
      they construct, have been removed.  The vast majority of callers used
      the embedded _init() interfaces.
    - No longer storing constructor arguments (and the data returned from
      nvkm) inside nvif_object, it's more or less unused and just wastes
      memory.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvif/notify.c b/drivers/gpu/drm/nouveau/nvif/notify.c
index 8e34748709a0..b0787ff833ef 100644
--- a/drivers/gpu/drm/nouveau/nvif/notify.c
+++ b/drivers/gpu/drm/nouveau/nvif/notify.c
@@ -124,7 +124,7 @@ nvif_notify(const void *header, u32 length, const void *data, u32 size)
 	}
 
 	if (!WARN_ON(notify == NULL)) {
-		struct nvif_client *client = nvif_client(notify->object);
+		struct nvif_client *client = notify->object->client;
 		if (!WARN_ON(notify->size != size)) {
 			atomic_inc(&notify->putcnt);
 			if (test_bit(NVIF_NOTIFY_WORK, &notify->flags)) {
@@ -156,7 +156,7 @@ nvif_notify_fini(struct nvif_notify *notify)
 	if (ret >= 0 && object) {
 		ret = nvif_object_ioctl(object, &args, sizeof(args), NULL);
 		if (ret == 0) {
-			nvif_object_ref(NULL, &notify->object);
+			notify->object = NULL;
 			kfree((void *)notify->data);
 		}
 	}
@@ -164,9 +164,9 @@ nvif_notify_fini(struct nvif_notify *notify)
 }
 
 int
-nvif_notify_init(struct nvif_object *object, void (*dtor)(struct nvif_notify *),
-		 int (*func)(struct nvif_notify *), bool work, u8 event,
-		 void *data, u32 size, u32 reply, struct nvif_notify *notify)
+nvif_notify_init(struct nvif_object *object, int (*func)(struct nvif_notify *),
+		 bool work, u8 event, void *data, u32 size, u32 reply,
+		 struct nvif_notify *notify)
 {
 	struct {
 		struct nvif_ioctl_v0 ioctl;
@@ -175,11 +175,9 @@ nvif_notify_init(struct nvif_object *object, void (*dtor)(struct nvif_notify *),
 	} *args;
 	int ret = -ENOMEM;
 
-	notify->object = NULL;
-	nvif_object_ref(object, &notify->object);
+	notify->object = object;
 	notify->flags = 0;
 	atomic_set(&notify->putcnt, 1);
-	notify->dtor = dtor;
 	notify->func = func;
 	notify->data = NULL;
 	notify->size = reply;
@@ -211,38 +209,3 @@ nvif_notify_init(struct nvif_object *object, void (*dtor)(struct nvif_notify *),
 		nvif_notify_fini(notify);
 	return ret;
 }
-
-static void
-nvif_notify_del(struct nvif_notify *notify)
-{
-	nvif_notify_fini(notify);
-	kfree(notify);
-}
-
-void
-nvif_notify_ref(struct nvif_notify *notify, struct nvif_notify **pnotify)
-{
-	BUG_ON(notify != NULL);
-	if (*pnotify)
-		(*pnotify)->dtor(*pnotify);
-	*pnotify = notify;
-}
-
-int
-nvif_notify_new(struct nvif_object *object, int (*func)(struct nvif_notify *),
-		bool work, u8 type, void *data, u32 size, u32 reply,
-		struct nvif_notify **pnotify)
-{
-	struct nvif_notify *notify = kzalloc(sizeof(*notify), GFP_KERNEL);
-	if (notify) {
-		int ret = nvif_notify_init(object, nvif_notify_del, func, work,
-					   type, data, size, reply, notify);
-		if (ret) {
-			kfree(notify);
-			notify = NULL;
-		}
-		*pnotify = notify;
-		return ret;
-	}
-	return -ENOMEM;
-}

commit 5025407b9862349d17b1dff25737aaef6520a439
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 14:11:21 2015 +1000

    drm/nouveau/core: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvif/notify.c b/drivers/gpu/drm/nouveau/nvif/notify.c
index 0898c3155292..8e34748709a0 100644
--- a/drivers/gpu/drm/nouveau/nvif/notify.c
+++ b/drivers/gpu/drm/nouveau/nvif/notify.c
@@ -92,7 +92,7 @@ nvif_notify_func(struct nvif_notify *notify, bool keep)
 {
 	int ret = notify->func(notify);
 	if (ret == NVIF_NOTIFY_KEEP ||
-	    !test_and_clear_bit(NVKM_NOTIFY_USER, &notify->flags)) {
+	    !test_and_clear_bit(NVIF_NOTIFY_USER, &notify->flags)) {
 		if (!keep)
 			atomic_dec(&notify->putcnt);
 		else

commit ef07ceae02271ac6eadc9f5cd652bb7162455a1b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Aug 12 22:56:09 2014 +1000

    drm/nouveau/nvif: return null pointers on failure, in addition to ret != 0
    
    Reported by Coverity.  The intention is that the return value is
    checked, but let's be more paranoid and make it extremely obvious
    if something forgets to.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvif/notify.c b/drivers/gpu/drm/nouveau/nvif/notify.c
index 7e03cdd17827..0898c3155292 100644
--- a/drivers/gpu/drm/nouveau/nvif/notify.c
+++ b/drivers/gpu/drm/nouveau/nvif/notify.c
@@ -237,8 +237,10 @@ nvif_notify_new(struct nvif_object *object, int (*func)(struct nvif_notify *),
 	if (notify) {
 		int ret = nvif_notify_init(object, nvif_notify_del, func, work,
 					   type, data, size, reply, notify);
-		if (ret)
+		if (ret) {
 			kfree(notify);
+			notify = NULL;
+		}
 		*pnotify = notify;
 		return ret;
 	}

commit 7caa63c04029c5882865867470c106ef73eafb2b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon Aug 11 11:36:45 2014 +1000

    drm/nouveau/nvif: fix a number of notify thinkos
    
    Note to self: more sleep
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvif/notify.c b/drivers/gpu/drm/nouveau/nvif/notify.c
index 7c06123a559c..7e03cdd17827 100644
--- a/drivers/gpu/drm/nouveau/nvif/notify.c
+++ b/drivers/gpu/drm/nouveau/nvif/notify.c
@@ -87,12 +87,25 @@ nvif_notify_get(struct nvif_notify *notify)
 	return 0;
 }
 
+static inline int
+nvif_notify_func(struct nvif_notify *notify, bool keep)
+{
+	int ret = notify->func(notify);
+	if (ret == NVIF_NOTIFY_KEEP ||
+	    !test_and_clear_bit(NVKM_NOTIFY_USER, &notify->flags)) {
+		if (!keep)
+			atomic_dec(&notify->putcnt);
+		else
+			nvif_notify_get_(notify);
+	}
+	return ret;
+}
+
 static void
 nvif_notify_work(struct work_struct *work)
 {
 	struct nvif_notify *notify = container_of(work, typeof(*notify), work);
-	if (notify->func(notify) == NVIF_NOTIFY_KEEP)
-		nvif_notify_get_(notify);
+	nvif_notify_func(notify, true);
 }
 
 int
@@ -113,19 +126,15 @@ nvif_notify(const void *header, u32 length, const void *data, u32 size)
 	if (!WARN_ON(notify == NULL)) {
 		struct nvif_client *client = nvif_client(notify->object);
 		if (!WARN_ON(notify->size != size)) {
+			atomic_inc(&notify->putcnt);
 			if (test_bit(NVIF_NOTIFY_WORK, &notify->flags)) {
-				atomic_inc(&notify->putcnt);
 				memcpy((void *)notify->data, data, size);
 				schedule_work(&notify->work);
 				return NVIF_NOTIFY_DROP;
 			}
 			notify->data = data;
-			ret = notify->func(notify);
+			ret = nvif_notify_func(notify, client->driver->keep);
 			notify->data = NULL;
-			if (ret != NVIF_NOTIFY_DROP && client->driver->keep) {
-				atomic_inc(&notify->putcnt);
-				nvif_notify_get_(notify);
-			}
 		}
 	}
 

commit a04d04231b490a2dca427a0f04603ed47fdb9cee
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Aug 10 04:10:21 2014 +1000

    drm/nouveau/nvif: import library functions for the ioctl/event interfaces
    
    This is a wrapper around the interfaces defined in an earlier commit,
    and is also used by various userspace (either by a libdrm backend, or
    libpciaccess) tools/tests.
    
    In the future this will be extended to handle channels, replacing some
    long-unloved code we currently use, and allow fifo/display/mpeg (hi
    Ilia ;)) engines to all be exposed in the same way.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvif/notify.c b/drivers/gpu/drm/nouveau/nvif/notify.c
new file mode 100644
index 000000000000..7c06123a559c
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvif/notify.c
@@ -0,0 +1,237 @@
+/*
+ * Copyright 2014 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs <bskeggs@redhat.com>
+ */
+
+#include <nvif/client.h>
+#include <nvif/driver.h>
+#include <nvif/notify.h>
+#include <nvif/object.h>
+#include <nvif/ioctl.h>
+#include <nvif/event.h>
+
+static inline int
+nvif_notify_put_(struct nvif_notify *notify)
+{
+	struct nvif_object *object = notify->object;
+	struct {
+		struct nvif_ioctl_v0 ioctl;
+		struct nvif_ioctl_ntfy_put_v0 ntfy;
+	} args = {
+		.ioctl.type = NVIF_IOCTL_V0_NTFY_PUT,
+		.ntfy.index = notify->index,
+	};
+
+	if (atomic_inc_return(&notify->putcnt) != 1)
+		return 0;
+
+	return nvif_object_ioctl(object, &args, sizeof(args), NULL);
+}
+
+int
+nvif_notify_put(struct nvif_notify *notify)
+{
+	if (likely(notify->object) &&
+	    test_and_clear_bit(NVIF_NOTIFY_USER, &notify->flags)) {
+		int ret = nvif_notify_put_(notify);
+		if (test_bit(NVIF_NOTIFY_WORK, &notify->flags))
+			flush_work(&notify->work);
+		return ret;
+	}
+	return 0;
+}
+
+static inline int
+nvif_notify_get_(struct nvif_notify *notify)
+{
+	struct nvif_object *object = notify->object;
+	struct {
+		struct nvif_ioctl_v0 ioctl;
+		struct nvif_ioctl_ntfy_get_v0 ntfy;
+	} args = {
+		.ioctl.type = NVIF_IOCTL_V0_NTFY_GET,
+		.ntfy.index = notify->index,
+	};
+
+	if (atomic_dec_return(&notify->putcnt) != 0)
+		return 0;
+
+	return nvif_object_ioctl(object, &args, sizeof(args), NULL);
+}
+
+int
+nvif_notify_get(struct nvif_notify *notify)
+{
+	if (likely(notify->object) &&
+	    !test_and_set_bit(NVIF_NOTIFY_USER, &notify->flags))
+		return nvif_notify_get_(notify);
+	return 0;
+}
+
+static void
+nvif_notify_work(struct work_struct *work)
+{
+	struct nvif_notify *notify = container_of(work, typeof(*notify), work);
+	if (notify->func(notify) == NVIF_NOTIFY_KEEP)
+		nvif_notify_get_(notify);
+}
+
+int
+nvif_notify(const void *header, u32 length, const void *data, u32 size)
+{
+	struct nvif_notify *notify = NULL;
+	const union {
+		struct nvif_notify_rep_v0 v0;
+	} *args = header;
+	int ret = NVIF_NOTIFY_DROP;
+
+	if (length == sizeof(args->v0) && args->v0.version == 0) {
+		if (WARN_ON(args->v0.route))
+			return NVIF_NOTIFY_DROP;
+		notify = (void *)(unsigned long)args->v0.token;
+	}
+
+	if (!WARN_ON(notify == NULL)) {
+		struct nvif_client *client = nvif_client(notify->object);
+		if (!WARN_ON(notify->size != size)) {
+			if (test_bit(NVIF_NOTIFY_WORK, &notify->flags)) {
+				atomic_inc(&notify->putcnt);
+				memcpy((void *)notify->data, data, size);
+				schedule_work(&notify->work);
+				return NVIF_NOTIFY_DROP;
+			}
+			notify->data = data;
+			ret = notify->func(notify);
+			notify->data = NULL;
+			if (ret != NVIF_NOTIFY_DROP && client->driver->keep) {
+				atomic_inc(&notify->putcnt);
+				nvif_notify_get_(notify);
+			}
+		}
+	}
+
+	return ret;
+}
+
+int
+nvif_notify_fini(struct nvif_notify *notify)
+{
+	struct nvif_object *object = notify->object;
+	struct {
+		struct nvif_ioctl_v0 ioctl;
+		struct nvif_ioctl_ntfy_del_v0 ntfy;
+	} args = {
+		.ioctl.type = NVIF_IOCTL_V0_NTFY_DEL,
+		.ntfy.index = notify->index,
+	};
+	int ret = nvif_notify_put(notify);
+	if (ret >= 0 && object) {
+		ret = nvif_object_ioctl(object, &args, sizeof(args), NULL);
+		if (ret == 0) {
+			nvif_object_ref(NULL, &notify->object);
+			kfree((void *)notify->data);
+		}
+	}
+	return ret;
+}
+
+int
+nvif_notify_init(struct nvif_object *object, void (*dtor)(struct nvif_notify *),
+		 int (*func)(struct nvif_notify *), bool work, u8 event,
+		 void *data, u32 size, u32 reply, struct nvif_notify *notify)
+{
+	struct {
+		struct nvif_ioctl_v0 ioctl;
+		struct nvif_ioctl_ntfy_new_v0 ntfy;
+		struct nvif_notify_req_v0 req;
+	} *args;
+	int ret = -ENOMEM;
+
+	notify->object = NULL;
+	nvif_object_ref(object, &notify->object);
+	notify->flags = 0;
+	atomic_set(&notify->putcnt, 1);
+	notify->dtor = dtor;
+	notify->func = func;
+	notify->data = NULL;
+	notify->size = reply;
+	if (work) {
+		INIT_WORK(&notify->work, nvif_notify_work);
+		set_bit(NVIF_NOTIFY_WORK, &notify->flags);
+		notify->data = kmalloc(notify->size, GFP_KERNEL);
+		if (!notify->data)
+			goto done;
+	}
+
+	if (!(args = kmalloc(sizeof(*args) + size, GFP_KERNEL)))
+		goto done;
+	args->ioctl.version = 0;
+	args->ioctl.type = NVIF_IOCTL_V0_NTFY_NEW;
+	args->ntfy.version = 0;
+	args->ntfy.event = event;
+	args->req.version = 0;
+	args->req.reply = notify->size;
+	args->req.route = 0;
+	args->req.token = (unsigned long)(void *)notify;
+
+	memcpy(args->req.data, data, size);
+	ret = nvif_object_ioctl(object, args, sizeof(*args) + size, NULL);
+	notify->index = args->ntfy.index;
+	kfree(args);
+done:
+	if (ret)
+		nvif_notify_fini(notify);
+	return ret;
+}
+
+static void
+nvif_notify_del(struct nvif_notify *notify)
+{
+	nvif_notify_fini(notify);
+	kfree(notify);
+}
+
+void
+nvif_notify_ref(struct nvif_notify *notify, struct nvif_notify **pnotify)
+{
+	BUG_ON(notify != NULL);
+	if (*pnotify)
+		(*pnotify)->dtor(*pnotify);
+	*pnotify = notify;
+}
+
+int
+nvif_notify_new(struct nvif_object *object, int (*func)(struct nvif_notify *),
+		bool work, u8 type, void *data, u32 size, u32 reply,
+		struct nvif_notify **pnotify)
+{
+	struct nvif_notify *notify = kzalloc(sizeof(*notify), GFP_KERNEL);
+	if (notify) {
+		int ret = nvif_notify_init(object, nvif_notify_del, func, work,
+					   type, data, size, reply, notify);
+		if (ret)
+			kfree(notify);
+		*pnotify = notify;
+		return ret;
+	}
+	return -ENOMEM;
+}
