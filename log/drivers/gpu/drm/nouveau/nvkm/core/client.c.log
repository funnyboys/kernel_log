commit c83c4097eba8950bc7028f0846c21f9718dd8697
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/mmu: define user interfaces to mmu memory allocation
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index 0d3a896892b4..ac671202919e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -301,5 +301,7 @@ nvkm_client_new(const char *name, u64 device, const char *cfg,
 	client->debug = nvkm_dbgopt(dbg, "CLIENT");
 	client->objroot = RB_ROOT;
 	client->ntfy = ntfy;
+	INIT_LIST_HEAD(&client->umem);
+	spin_lock_init(&client->lock);
 	return 0;
 }

commit 04b8867758a4e1fca9d349f4a279fff8855db58c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun May 22 20:35:16 2016 +1000

    drm/nouveau/core/client: allow creation of subclients
    
    We want a supervisor client of NVKM (such as the DRM) to be able to
    allow sharing of resources (such as memory objects) between clients.
    
    To allow this, the supervisor creates all its clients as children of
    itself, and will use an upcoming ioctl to permit sharing.
    
    Currently it's not possible for indirect clients to use subclients.
    Supporting this will require an additional field in the main ioctl.
    This isn't important currently, but will need to be fixed for virt.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index 4e2730cb1fec..0d3a896892b4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -31,9 +31,41 @@
 #include <nvif/if0000.h>
 #include <nvif/unpack.h>
 
-static const struct nvkm_sclass
+static int
+nvkm_uclient_new(const struct nvkm_oclass *oclass, void *argv, u32 argc,
+		 struct nvkm_object **pobject)
+{
+	union {
+		struct nvif_client_v0 v0;
+	} *args = argv;
+	struct nvkm_client *client;
+	int ret = -ENOSYS;
+
+	if (!(ret = nvif_unpack(ret, &argv, &argc, args->v0, 0, 0, false))){
+		args->v0.name[sizeof(args->v0.name) - 1] = 0;
+		ret = nvkm_client_new(args->v0.name, args->v0.device, NULL,
+				      NULL, oclass->client->ntfy, &client);
+		if (ret)
+			return ret;
+	} else
+		return ret;
+
+	client->object.client = oclass->client;
+	client->object.handle = oclass->handle;
+	client->object.route  = oclass->route;
+	client->object.token  = oclass->token;
+	client->object.object = oclass->object;
+	client->debug = oclass->client->debug;
+	*pobject = &client->object;
+	return 0;
+}
+
+const struct nvkm_sclass
 nvkm_uclient_sclass = {
 	.oclass = NVIF_CLASS_CLIENT,
+	.minver = 0,
+	.maxver = 0,
+	.ctor = nvkm_uclient_new,
 };
 
 struct nvkm_client_notify {
@@ -143,6 +175,19 @@ nvkm_client_notify_new(struct nvkm_object *object,
 	return ret;
 }
 
+static const struct nvkm_object_func nvkm_client;
+struct nvkm_client *
+nvkm_client_search(struct nvkm_client *client, u64 handle)
+{
+	struct nvkm_object *object;
+
+	object = nvkm_object_search(client, handle, &nvkm_client);
+	if (IS_ERR(object))
+		return (void *)object;
+
+	return nvkm_client(object);
+}
+
 static int
 nvkm_client_mthd_devlist(struct nvkm_client *client, void *data, u32 size)
 {
@@ -196,7 +241,8 @@ nvkm_client_child_get(struct nvkm_object *object, int index,
 	const struct nvkm_sclass *sclass;
 
 	switch (index) {
-	case 0: sclass = &nvkm_udevice_sclass; break;
+	case 0: sclass = &nvkm_uclient_sclass; break;
+	case 1: sclass = &nvkm_udevice_sclass; break;
 	default:
 		return -EINVAL;
 	}

commit 7c413feb7f9907c72aad7ea8f43af8ca8893c2bc
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed May 25 17:08:21 2016 +1000

    drm/nouveau/core/client: pass notification callback to nvkm_client_new
    
    Preparation for supporting subclients.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index 3cde975816f3..4e2730cb1fec 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -238,7 +238,9 @@ nvkm_client = {
 
 int
 nvkm_client_new(const char *name, u64 device, const char *cfg,
-		const char *dbg, struct nvkm_client **pclient)
+		const char *dbg,
+		int (*ntfy)(const void *, u32, const void *, u32),
+		struct nvkm_client **pclient)
 {
 	struct nvkm_oclass oclass = { .base = nvkm_uclient_sclass };
 	struct nvkm_client *client;
@@ -252,5 +254,6 @@ nvkm_client_new(const char *name, u64 device, const char *cfg,
 	client->device = device;
 	client->debug = nvkm_dbgopt(dbg, "CLIENT");
 	client->objroot = RB_ROOT;
+	client->ntfy = ntfy;
 	return 0;
 }

commit 2c3af924fbee23544a6adc81a2bbe398132b472f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon May 23 08:42:54 2016 +1000

    drm/nouveau/core/client: use standard object dtor/init/fini paths
    
    Preparation for supporting subclients, and also good for consistency.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index aab4a8897cfb..3cde975816f3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -206,45 +206,36 @@ nvkm_client_child_get(struct nvkm_object *object, int index,
 	return 0;
 }
 
-static const struct nvkm_object_func
-nvkm_client_object_func = {
-	.mthd = nvkm_client_mthd,
-	.sclass = nvkm_client_child_get,
-};
-
-int
-nvkm_client_fini(struct nvkm_client *client, bool suspend)
+static int
+nvkm_client_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nvkm_object *object = &client->object;
+	struct nvkm_client *client = nvkm_client(object);
 	const char *name[2] = { "fini", "suspend" };
 	int i;
 	nvif_debug(object, "%s notify\n", name[suspend]);
 	for (i = 0; i < ARRAY_SIZE(client->notify); i++)
 		nvkm_client_notify_put(client, i);
-	return nvkm_object_fini(&client->object, suspend);
-}
-
-int
-nvkm_client_init(struct nvkm_client *client)
-{
-	return nvkm_object_init(&client->object);
+	return 0;
 }
 
-void
-nvkm_client_del(struct nvkm_client **pclient)
+static void *
+nvkm_client_dtor(struct nvkm_object *object)
 {
-	struct nvkm_client *client = *pclient;
+	struct nvkm_client *client = nvkm_client(object);
 	int i;
-	if (client) {
-		nvkm_client_fini(client, false);
-		for (i = 0; i < ARRAY_SIZE(client->notify); i++)
-			nvkm_client_notify_del(client, i);
-		nvkm_object_dtor(&client->object);
-		kfree(*pclient);
-		*pclient = NULL;
-	}
+	for (i = 0; i < ARRAY_SIZE(client->notify); i++)
+		nvkm_client_notify_del(client, i);
+	return client;
 }
 
+static const struct nvkm_object_func
+nvkm_client = {
+	.dtor = nvkm_client_dtor,
+	.fini = nvkm_client_fini,
+	.mthd = nvkm_client_mthd,
+	.sclass = nvkm_client_child_get,
+};
+
 int
 nvkm_client_new(const char *name, u64 device, const char *cfg,
 		const char *dbg, struct nvkm_client **pclient)
@@ -256,7 +247,7 @@ nvkm_client_new(const char *name, u64 device, const char *cfg,
 		return -ENOMEM;
 	oclass.client = client;
 
-	nvkm_object_ctor(&nvkm_client_object_func, &oclass, &client->object);
+	nvkm_object_ctor(&nvkm_client, &oclass, &client->object);
 	snprintf(client->name, sizeof(client->name), "%s", name);
 	client->device = device;
 	client->debug = nvkm_dbgopt(dbg, "CLIENT");

commit 03295eabdb95153be4777ff04cc4f1dec0d62bc4
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu May 26 08:43:00 2016 +1000

    drm/nouveau/core/client: modify prefix on nvif structures, for consistency
    
    Preparation for supporting subclients.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index 8087b253845c..aab4a8897cfb 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -31,6 +31,11 @@
 #include <nvif/if0000.h>
 #include <nvif/unpack.h>
 
+static const struct nvkm_sclass
+nvkm_uclient_sclass = {
+	.oclass = NVIF_CLASS_CLIENT,
+};
+
 struct nvkm_client_notify {
 	struct nvkm_client *client;
 	struct nvkm_notify n;
@@ -139,16 +144,16 @@ nvkm_client_notify_new(struct nvkm_object *object,
 }
 
 static int
-nvkm_client_mthd_devlist(struct nvkm_object *object, void *data, u32 size)
+nvkm_client_mthd_devlist(struct nvkm_client *client, void *data, u32 size)
 {
 	union {
-		struct nv_client_devlist_v0 v0;
+		struct nvif_client_devlist_v0 v0;
 	} *args = data;
 	int ret = -ENOSYS;
 
-	nvif_ioctl(object, "client devlist size %d\n", size);
+	nvif_ioctl(&client->object, "client devlist size %d\n", size);
 	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
-		nvif_ioctl(object, "client devlist vers %d count %d\n",
+		nvif_ioctl(&client->object, "client devlist vers %d count %d\n",
 			   args->v0.version, args->v0.count);
 		if (size == sizeof(args->v0.device[0]) * args->v0.count) {
 			ret = nvkm_device_list(args->v0.device, args->v0.count);
@@ -167,9 +172,10 @@ nvkm_client_mthd_devlist(struct nvkm_object *object, void *data, u32 size)
 static int
 nvkm_client_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
+	struct nvkm_client *client = nvkm_client(object);
 	switch (mthd) {
-	case NV_CLIENT_DEVLIST:
-		return nvkm_client_mthd_devlist(object, data, size);
+	case NVIF_CLIENT_V0_DEVLIST:
+		return nvkm_client_mthd_devlist(client, data, size);
 	default:
 		break;
 	}
@@ -243,7 +249,7 @@ int
 nvkm_client_new(const char *name, u64 device, const char *cfg,
 		const char *dbg, struct nvkm_client **pclient)
 {
-	struct nvkm_oclass oclass = {};
+	struct nvkm_oclass oclass = { .base = nvkm_uclient_sclass };
 	struct nvkm_client *client;
 
 	if (!(client = *pclient = kzalloc(sizeof(*client), GFP_KERNEL)))

commit 83e85d91b2bc38d4067baf05a7fe9e47436e1d8c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 17 19:40:29 2016 +1000

    drm/nouveau/dma: lookup objects with nvkm_object_search()
    
    Custom code is no longer needed here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index 0c2fdf14201e..8087b253845c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -255,6 +255,5 @@ nvkm_client_new(const char *name, u64 device, const char *cfg,
 	client->device = device;
 	client->debug = nvkm_dbgopt(dbg, "CLIENT");
 	client->objroot = RB_ROOT;
-	client->dmaroot = RB_ROOT;
 	return 0;
 }

commit daad3dfb05be8b0682c1bb0db6b59e50a4bb95f6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Dec 22 15:23:04 2016 +1000

    drm/nouveau/core/client: lookup client objects with nvkm_object_search()
    
    Custom code is no longer needed here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index e1943910858e..0c2fdf14201e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -206,55 +206,6 @@ nvkm_client_object_func = {
 	.sclass = nvkm_client_child_get,
 };
 
-void
-nvkm_client_remove(struct nvkm_client *client, struct nvkm_object *object)
-{
-	if (!RB_EMPTY_NODE(&object->node))
-		rb_erase(&object->node, &client->objroot);
-}
-
-bool
-nvkm_client_insert(struct nvkm_client *client, struct nvkm_object *object)
-{
-	struct rb_node **ptr = &client->objroot.rb_node;
-	struct rb_node *parent = NULL;
-
-	while (*ptr) {
-		struct nvkm_object *this =
-			container_of(*ptr, typeof(*this), node);
-		parent = *ptr;
-		if (object->object < this->object)
-			ptr = &parent->rb_left;
-		else
-		if (object->object > this->object)
-			ptr = &parent->rb_right;
-		else
-			return false;
-	}
-
-	rb_link_node(&object->node, parent, ptr);
-	rb_insert_color(&object->node, &client->objroot);
-	return true;
-}
-
-struct nvkm_object *
-nvkm_client_search(struct nvkm_client *client, u64 handle)
-{
-	struct rb_node *node = client->objroot.rb_node;
-	while (node) {
-		struct nvkm_object *object =
-			container_of(node, typeof(*object), node);
-		if (handle < object->object)
-			node = node->rb_left;
-		else
-		if (handle > object->object)
-			node = node->rb_right;
-		else
-			return object;
-	}
-	return NULL;
-}
-
 int
 nvkm_client_fini(struct nvkm_client *client, bool suspend)
 {

commit f01c4e682c941ba70e0ebec44db754844a1b9b82
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon Nov 9 09:21:27 2015 +1000

    drm/nouveau/nvif: modify nvif_unvers/nvif_unpack macros to be more obvious
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index 98e694179ace..e1943910858e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -97,7 +97,7 @@ nvkm_client_notify_new(struct nvkm_object *object,
 		struct nvif_notify_req_v0 v0;
 	} *req = data;
 	u8  index, reply;
-	int ret;
+	int ret = -ENOSYS;
 
 	for (index = 0; index < ARRAY_SIZE(client->notify); index++) {
 		if (!client->notify[index])
@@ -112,7 +112,7 @@ nvkm_client_notify_new(struct nvkm_object *object,
 		return -ENOMEM;
 
 	nvif_ioctl(object, "notify new size %d\n", size);
-	if (nvif_unpack(req->v0, 0, 0, true)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, req->v0, 0, 0, true))) {
 		nvif_ioctl(object, "notify new vers %d reply %d route %02x "
 				   "token %llx\n", req->v0.version,
 			   req->v0.reply, req->v0.route, req->v0.token);
@@ -144,10 +144,10 @@ nvkm_client_mthd_devlist(struct nvkm_object *object, void *data, u32 size)
 	union {
 		struct nv_client_devlist_v0 v0;
 	} *args = data;
-	int ret;
+	int ret = -ENOSYS;
 
 	nvif_ioctl(object, "client devlist size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, true)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
 		nvif_ioctl(object, "client devlist vers %d count %d\n",
 			   args->v0.version, args->v0.count);
 		if (size == sizeof(args->v0.device[0]) * args->v0.count) {

commit 13db6d6ea7190a377af31246016af66803766588
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Nov 8 12:26:01 2015 +1000

    drm/nouveau/nvif: split out client interface definitions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index 297e1e953fa6..98e694179ace 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -28,6 +28,7 @@
 
 #include <nvif/class.h>
 #include <nvif/event.h>
+#include <nvif/if0000.h>
 #include <nvif/unpack.h>
 
 struct nvkm_client_notify {

commit fbd58ebda9c8572ca6285b88e3348c7712f125ec
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/object: merge with handle
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index ab98f8c45950..297e1e953fa6 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -23,7 +23,6 @@
  */
 #include <core/client.h>
 #include <core/device.h>
-#include <core/handle.h>
 #include <core/notify.h>
 #include <core/option.h>
 
@@ -91,7 +90,7 @@ int
 nvkm_client_notify_new(struct nvkm_object *object,
 		       struct nvkm_event *event, void *data, u32 size)
 {
-	struct nvkm_client *client = nvkm_client(object);
+	struct nvkm_client *client = object->client;
 	struct nvkm_client_notify *notify;
 	union {
 		struct nvif_notify_req_v0 v0;
@@ -207,47 +206,47 @@ nvkm_client_object_func = {
 };
 
 void
-nvkm_client_remove(struct nvkm_client *client, struct nvkm_handle *object)
+nvkm_client_remove(struct nvkm_client *client, struct nvkm_object *object)
 {
-	if (!RB_EMPTY_NODE(&object->rb))
-		rb_erase(&object->rb, &client->objroot);
+	if (!RB_EMPTY_NODE(&object->node))
+		rb_erase(&object->node, &client->objroot);
 }
 
 bool
-nvkm_client_insert(struct nvkm_client *client, struct nvkm_handle *object)
+nvkm_client_insert(struct nvkm_client *client, struct nvkm_object *object)
 {
 	struct rb_node **ptr = &client->objroot.rb_node;
 	struct rb_node *parent = NULL;
 
 	while (*ptr) {
-		struct nvkm_handle *this =
-			container_of(*ptr, typeof(*this), rb);
+		struct nvkm_object *this =
+			container_of(*ptr, typeof(*this), node);
 		parent = *ptr;
-		if (object->handle < this->handle)
+		if (object->object < this->object)
 			ptr = &parent->rb_left;
 		else
-		if (object->handle > this->handle)
+		if (object->object > this->object)
 			ptr = &parent->rb_right;
 		else
 			return false;
 	}
 
-	rb_link_node(&object->rb, parent, ptr);
-	rb_insert_color(&object->rb, &client->objroot);
+	rb_link_node(&object->node, parent, ptr);
+	rb_insert_color(&object->node, &client->objroot);
 	return true;
 }
 
-struct nvkm_handle *
+struct nvkm_object *
 nvkm_client_search(struct nvkm_client *client, u64 handle)
 {
 	struct rb_node *node = client->objroot.rb_node;
 	while (node) {
-		struct nvkm_handle *object =
-			container_of(node, typeof(*object), rb);
-		if (handle < object->handle)
+		struct nvkm_object *object =
+			container_of(node, typeof(*object), node);
+		if (handle < object->object)
 			node = node->rb_left;
 		else
-		if (handle > object->handle)
+		if (handle > object->object)
 			node = node->rb_right;
 		else
 			return object;
@@ -260,26 +259,17 @@ nvkm_client_fini(struct nvkm_client *client, bool suspend)
 {
 	struct nvkm_object *object = &client->object;
 	const char *name[2] = { "fini", "suspend" };
-	int ret, i;
-	nvif_trace(object, "%s running\n", name[suspend]);
-	nvif_trace(object, "%s notify\n", name[suspend]);
+	int i;
+	nvif_debug(object, "%s notify\n", name[suspend]);
 	for (i = 0; i < ARRAY_SIZE(client->notify); i++)
 		nvkm_client_notify_put(client, i);
-	nvif_trace(object, "%s object\n", name[suspend]);
-	ret = nvkm_handle_fini(client->root, suspend);
-	nvif_trace(object, "%s completed with %d\n", name[suspend], ret);
-	return ret;
+	return nvkm_object_fini(&client->object, suspend);
 }
 
 int
 nvkm_client_init(struct nvkm_client *client)
 {
-	struct nvkm_object *object = &client->object;
-	int ret;
-	nvif_trace(object, "init running\n");
-	ret = nvkm_handle_init(client->root);
-	nvif_trace(object, "init completed with %d\n", ret);
-	return ret;
+	return nvkm_object_init(&client->object);
 }
 
 void
@@ -291,7 +281,7 @@ nvkm_client_del(struct nvkm_client **pclient)
 		nvkm_client_fini(client, false);
 		for (i = 0; i < ARRAY_SIZE(client->notify); i++)
 			nvkm_client_notify_del(client, i);
-		nvkm_handle_destroy(client->root);
+		nvkm_object_dtor(&client->object);
 		kfree(*pclient);
 		*pclient = NULL;
 	}
@@ -303,7 +293,6 @@ nvkm_client_new(const char *name, u64 device, const char *cfg,
 {
 	struct nvkm_oclass oclass = {};
 	struct nvkm_client *client;
-	int ret;
 
 	if (!(client = *pclient = kzalloc(sizeof(*client), GFP_KERNEL)))
 		return -ENOMEM;
@@ -315,9 +304,5 @@ nvkm_client_new(const char *name, u64 device, const char *cfg,
 	client->debug = nvkm_dbgopt(dbg, "CLIENT");
 	client->objroot = RB_ROOT;
 	client->dmaroot = RB_ROOT;
-
-	ret = nvkm_handle_create(NULL, ~0, &client->object, &client->root);
-	if (ret)
-		nvkm_client_del(pclient);
-	return ret;
+	return 0;
 }

commit 27f3d6cf80324940edd29be7758f81145e73d1ff
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/gr: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index 910f736cd1b6..ab98f8c45950 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -321,13 +321,3 @@ nvkm_client_new(const char *name, u64 device, const char *cfg,
 		nvkm_client_del(pclient);
 	return ret;
 }
-
-const char *
-nvkm_client_name(void *obj)
-{
-	const char *client_name = "unknown";
-	struct nvkm_client *client = nvkm_client(obj);
-	if (client)
-		client_name = client->name;
-	return client_name;
-}

commit 0710cc31482ae3711367c42e61580126c50c8ec0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/dma: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index dce1d45cac5e..910f736cd1b6 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -314,6 +314,7 @@ nvkm_client_new(const char *name, u64 device, const char *cfg,
 	client->device = device;
 	client->debug = nvkm_dbgopt(dbg, "CLIENT");
 	client->objroot = RB_ROOT;
+	client->dmaroot = RB_ROOT;
 
 	ret = nvkm_handle_create(NULL, ~0, &client->object, &client->root);
 	if (ret)

commit 2a9f847f5d43d15c0401d050cdd77fb4cbe7da06
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/device: convert user class to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index 1affa2299a8c..dce1d45cac5e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -180,25 +180,24 @@ static int
 nvkm_client_child_new(const struct nvkm_oclass *oclass,
 		      void *data, u32 size, struct nvkm_object **pobject)
 {
-	static struct nvkm_oclass devobj = {
-		.handle = NV_DEVICE,
-		.ofuncs = &nvkm_udevice_ofuncs,
-	};
-	return nvkm_object_old(oclass->parent, NULL, &devobj, data, size, pobject);
+	return oclass->base.ctor(oclass, data, size, pobject);
 }
 
 static int
 nvkm_client_child_get(struct nvkm_object *object, int index,
 		      struct nvkm_oclass *oclass)
 {
-	if (index == 0) {
-		oclass->base.oclass = NV_DEVICE;
-		oclass->base.minver = 0;
-		oclass->base.maxver = 0;
-		oclass->ctor = nvkm_client_child_new;
-		return 0;
+	const struct nvkm_sclass *sclass;
+
+	switch (index) {
+	case 0: sclass = &nvkm_udevice_sclass; break;
+	default:
+		return -EINVAL;
 	}
-	return -EINVAL;
+
+	oclass->ctor = nvkm_client_child_new;
+	oclass->base = *sclass;
+	return 0;
 }
 
 static const struct nvkm_object_func

commit 24bd0930bedea1182aaadc52757897d2b9b3ca99
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/client: convert to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index 9a7c4bc24a76..1affa2299a8c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -176,11 +176,35 @@ nvkm_client_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	return -EINVAL;
 }
 
-static struct nvkm_oclass
-nvkm_client_oclass = {
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.mthd = nvkm_client_mthd,
-	},
+static int
+nvkm_client_child_new(const struct nvkm_oclass *oclass,
+		      void *data, u32 size, struct nvkm_object **pobject)
+{
+	static struct nvkm_oclass devobj = {
+		.handle = NV_DEVICE,
+		.ofuncs = &nvkm_udevice_ofuncs,
+	};
+	return nvkm_object_old(oclass->parent, NULL, &devobj, data, size, pobject);
+}
+
+static int
+nvkm_client_child_get(struct nvkm_object *object, int index,
+		      struct nvkm_oclass *oclass)
+{
+	if (index == 0) {
+		oclass->base.oclass = NV_DEVICE;
+		oclass->base.minver = 0;
+		oclass->base.maxver = 0;
+		oclass->ctor = nvkm_client_child_new;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static const struct nvkm_object_func
+nvkm_client_object_func = {
+	.mthd = nvkm_client_mthd,
+	.sclass = nvkm_client_child_get,
 };
 
 void
@@ -235,7 +259,7 @@ nvkm_client_search(struct nvkm_client *client, u64 handle)
 int
 nvkm_client_fini(struct nvkm_client *client, bool suspend)
 {
-	struct nvkm_object *object = &client->namedb.parent.object;
+	struct nvkm_object *object = &client->object;
 	const char *name[2] = { "fini", "suspend" };
 	int ret, i;
 	nvif_trace(object, "%s running\n", name[suspend]);
@@ -251,7 +275,7 @@ nvkm_client_fini(struct nvkm_client *client, bool suspend)
 int
 nvkm_client_init(struct nvkm_client *client)
 {
-	struct nvkm_object *object = &client->namedb.parent.object;
+	struct nvkm_object *object = &client->object;
 	int ret;
 	nvif_trace(object, "init running\n");
 	ret = nvkm_handle_init(client->root);
@@ -269,43 +293,33 @@ nvkm_client_del(struct nvkm_client **pclient)
 		for (i = 0; i < ARRAY_SIZE(client->notify); i++)
 			nvkm_client_notify_del(client, i);
 		nvkm_handle_destroy(client->root);
-		nvkm_namedb_destroy(&client->namedb);
+		kfree(*pclient);
 		*pclient = NULL;
 	}
 }
 
-static struct nvkm_oclass
-nvkm_client_sclass[] = {
-	{ NV_DEVICE, &nvkm_udevice_ofuncs },
-	{}
-};
-
 int
 nvkm_client_new(const char *name, u64 device, const char *cfg,
 		const char *dbg, struct nvkm_client **pclient)
 {
+	struct nvkm_oclass oclass = {};
 	struct nvkm_client *client;
 	int ret;
 
-	ret = nvkm_namedb_create(NULL, NULL, &nvkm_client_oclass,
-				 NV_CLIENT_CLASS, nvkm_client_sclass,
-				 0, &client);
-	*pclient = client;
-	if (ret)
-		return ret;
-
-	ret = nvkm_handle_create(NULL, ~0, nv_object(client), &client->root);
-	if (ret)
-		return ret;
-
-	/* prevent init/fini being called, os in in charge of this */
-	atomic_set(&nv_object(client)->usecount, 2);
+	if (!(client = *pclient = kzalloc(sizeof(*client), GFP_KERNEL)))
+		return -ENOMEM;
+	oclass.client = client;
 
-	client->device = device;
+	nvkm_object_ctor(&nvkm_client_object_func, &oclass, &client->object);
 	snprintf(client->name, sizeof(client->name), "%s", name);
+	client->device = device;
 	client->debug = nvkm_dbgopt(dbg, "CLIENT");
 	client->objroot = RB_ROOT;
-	return 0;
+
+	ret = nvkm_handle_create(NULL, ~0, &client->object, &client->root);
+	if (ret)
+		nvkm_client_del(pclient);
+	return ret;
 }
 
 const char *

commit 524bdbf2025d44cdea672511d21012a52b427374
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/core: prepare for new-style objects
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index bfe5357d7334..9a7c4bc24a76 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -294,8 +294,7 @@ nvkm_client_new(const char *name, u64 device, const char *cfg,
 	if (ret)
 		return ret;
 
-	ret = nvkm_handle_create(nv_object(client), ~0, ~0, nv_object(client),
-				 &client->root);
+	ret = nvkm_handle_create(NULL, ~0, nv_object(client), &client->root);
 	if (ret)
 		return ret;
 

commit bf81df9be28657eea4aca8c6ab4ed3e69f8a051c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/nvif: replace path-based object identification
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index 7615cdd75294..bfe5357d7334 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -183,6 +183,55 @@ nvkm_client_oclass = {
 	},
 };
 
+void
+nvkm_client_remove(struct nvkm_client *client, struct nvkm_handle *object)
+{
+	if (!RB_EMPTY_NODE(&object->rb))
+		rb_erase(&object->rb, &client->objroot);
+}
+
+bool
+nvkm_client_insert(struct nvkm_client *client, struct nvkm_handle *object)
+{
+	struct rb_node **ptr = &client->objroot.rb_node;
+	struct rb_node *parent = NULL;
+
+	while (*ptr) {
+		struct nvkm_handle *this =
+			container_of(*ptr, typeof(*this), rb);
+		parent = *ptr;
+		if (object->handle < this->handle)
+			ptr = &parent->rb_left;
+		else
+		if (object->handle > this->handle)
+			ptr = &parent->rb_right;
+		else
+			return false;
+	}
+
+	rb_link_node(&object->rb, parent, ptr);
+	rb_insert_color(&object->rb, &client->objroot);
+	return true;
+}
+
+struct nvkm_handle *
+nvkm_client_search(struct nvkm_client *client, u64 handle)
+{
+	struct rb_node *node = client->objroot.rb_node;
+	while (node) {
+		struct nvkm_handle *object =
+			container_of(node, typeof(*object), rb);
+		if (handle < object->handle)
+			node = node->rb_left;
+		else
+		if (handle > object->handle)
+			node = node->rb_right;
+		else
+			return object;
+	}
+	return NULL;
+}
+
 int
 nvkm_client_fini(struct nvkm_client *client, bool suspend)
 {
@@ -256,6 +305,7 @@ nvkm_client_new(const char *name, u64 device, const char *cfg,
 	client->device = device;
 	snprintf(client->name, sizeof(client->name), "%s", name);
 	client->debug = nvkm_dbgopt(dbg, "CLIENT");
+	client->objroot = RB_ROOT;
 	return 0;
 }
 

commit 4e7e62d607a711bc8e8576a0fc7d8f242d25c9b3
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:15 2015 +1000

    drm/nouveau/client: store default device by handle, not reference
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index 5a1ddb3433de..7615cdd75294 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -219,7 +219,6 @@ nvkm_client_del(struct nvkm_client **pclient)
 		nvkm_client_fini(client, false);
 		for (i = 0; i < ARRAY_SIZE(client->notify); i++)
 			nvkm_client_notify_del(client, i);
-		nvkm_object_ref(NULL, (struct nvkm_object **)&client->device);
 		nvkm_handle_destroy(client->root);
 		nvkm_namedb_destroy(&client->namedb);
 		*pclient = NULL;
@@ -233,17 +232,12 @@ nvkm_client_sclass[] = {
 };
 
 int
-nvkm_client_new(const char *name, u64 devname, const char *cfg,
+nvkm_client_new(const char *name, u64 device, const char *cfg,
 		const char *dbg, struct nvkm_client **pclient)
 {
-	struct nvkm_device *device;
 	struct nvkm_client *client;
 	int ret;
 
-	device = nvkm_device_find(devname);
-	if (!device)
-		return -ENODEV;
-
 	ret = nvkm_namedb_create(NULL, NULL, &nvkm_client_oclass,
 				 NV_CLIENT_CLASS, nvkm_client_sclass,
 				 0, &client);
@@ -259,8 +253,7 @@ nvkm_client_new(const char *name, u64 devname, const char *cfg,
 	/* prevent init/fini being called, os in in charge of this */
 	atomic_set(&nv_object(client)->usecount, 2);
 
-	nvkm_object_ref(&device->engine.subdev.object,
-			(struct nvkm_object **)&client->device);
+	client->device = device;
 	snprintf(client->name, sizeof(client->name), "%s", name);
 	client->debug = nvkm_dbgopt(dbg, "CLIENT");
 	return 0;

commit a1e88736221d2e971726931c449ed7d0af31755b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:15 2015 +1000

    drm/nouveau/device: decouple from engine machinery
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index cd8e51f74aa1..5a1ddb3433de 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -226,6 +226,12 @@ nvkm_client_del(struct nvkm_client **pclient)
 	}
 }
 
+static struct nvkm_oclass
+nvkm_client_sclass[] = {
+	{ NV_DEVICE, &nvkm_udevice_ofuncs },
+	{}
+};
+
 int
 nvkm_client_new(const char *name, u64 devname, const char *cfg,
 		const char *dbg, struct nvkm_client **pclient)
@@ -239,9 +245,8 @@ nvkm_client_new(const char *name, u64 devname, const char *cfg,
 		return -ENODEV;
 
 	ret = nvkm_namedb_create(NULL, NULL, &nvkm_client_oclass,
-				 NV_CLIENT_CLASS, NULL,
-				 (1ULL << NVDEV_ENGINE_DEVICE),
-				 &client);
+				 NV_CLIENT_CLASS, nvkm_client_sclass,
+				 0, &client);
 	*pclient = client;
 	if (ret)
 		return ret;

commit 76ecea5b4b9383edde2bfe49e59e76fec4e21aa4
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:15 2015 +1000

    drm/nouveau/client: tidy ctor/dtor interfaces
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index 0c7162fbe06c..cd8e51f74aa1 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -176,43 +176,73 @@ nvkm_client_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	return -EINVAL;
 }
 
-static void
-nvkm_client_dtor(struct nvkm_object *object)
-{
-	struct nvkm_client *client = (void *)object;
-	int i;
-	for (i = 0; i < ARRAY_SIZE(client->notify); i++)
-		nvkm_client_notify_del(client, i);
-	nvkm_object_ref(NULL, &client->device);
-	nvkm_handle_destroy(client->root);
-	nvkm_namedb_destroy(&client->namedb);
-}
-
 static struct nvkm_oclass
 nvkm_client_oclass = {
 	.ofuncs = &(struct nvkm_ofuncs) {
-		.dtor = nvkm_client_dtor,
 		.mthd = nvkm_client_mthd,
 	},
 };
 
 int
-nvkm_client_create_(const char *name, u64 devname, const char *cfg,
-		    const char *dbg, int length, void **pobject)
+nvkm_client_fini(struct nvkm_client *client, bool suspend)
+{
+	struct nvkm_object *object = &client->namedb.parent.object;
+	const char *name[2] = { "fini", "suspend" };
+	int ret, i;
+	nvif_trace(object, "%s running\n", name[suspend]);
+	nvif_trace(object, "%s notify\n", name[suspend]);
+	for (i = 0; i < ARRAY_SIZE(client->notify); i++)
+		nvkm_client_notify_put(client, i);
+	nvif_trace(object, "%s object\n", name[suspend]);
+	ret = nvkm_handle_fini(client->root, suspend);
+	nvif_trace(object, "%s completed with %d\n", name[suspend], ret);
+	return ret;
+}
+
+int
+nvkm_client_init(struct nvkm_client *client)
+{
+	struct nvkm_object *object = &client->namedb.parent.object;
+	int ret;
+	nvif_trace(object, "init running\n");
+	ret = nvkm_handle_init(client->root);
+	nvif_trace(object, "init completed with %d\n", ret);
+	return ret;
+}
+
+void
+nvkm_client_del(struct nvkm_client **pclient)
+{
+	struct nvkm_client *client = *pclient;
+	int i;
+	if (client) {
+		nvkm_client_fini(client, false);
+		for (i = 0; i < ARRAY_SIZE(client->notify); i++)
+			nvkm_client_notify_del(client, i);
+		nvkm_object_ref(NULL, (struct nvkm_object **)&client->device);
+		nvkm_handle_destroy(client->root);
+		nvkm_namedb_destroy(&client->namedb);
+		*pclient = NULL;
+	}
+}
+
+int
+nvkm_client_new(const char *name, u64 devname, const char *cfg,
+		const char *dbg, struct nvkm_client **pclient)
 {
-	struct nvkm_object *device;
+	struct nvkm_device *device;
 	struct nvkm_client *client;
 	int ret;
 
-	device = (void *)nvkm_device_find(devname);
+	device = nvkm_device_find(devname);
 	if (!device)
 		return -ENODEV;
 
-	ret = nvkm_namedb_create_(NULL, NULL, &nvkm_client_oclass,
-				  NV_CLIENT_CLASS, NULL,
-				  (1ULL << NVDEV_ENGINE_DEVICE),
-				  length, pobject);
-	client = *pobject;
+	ret = nvkm_namedb_create(NULL, NULL, &nvkm_client_oclass,
+				 NV_CLIENT_CLASS, NULL,
+				 (1ULL << NVDEV_ENGINE_DEVICE),
+				 &client);
+	*pclient = client;
 	if (ret)
 		return ret;
 
@@ -224,39 +254,13 @@ nvkm_client_create_(const char *name, u64 devname, const char *cfg,
 	/* prevent init/fini being called, os in in charge of this */
 	atomic_set(&nv_object(client)->usecount, 2);
 
-	nvkm_object_ref(device, &client->device);
+	nvkm_object_ref(&device->engine.subdev.object,
+			(struct nvkm_object **)&client->device);
 	snprintf(client->name, sizeof(client->name), "%s", name);
 	client->debug = nvkm_dbgopt(dbg, "CLIENT");
 	return 0;
 }
 
-int
-nvkm_client_init(struct nvkm_client *client)
-{
-	struct nvkm_object *object = &client->namedb.parent.object;
-	int ret;
-	nvif_trace(object, "init running\n");
-	ret = nvkm_handle_init(client->root);
-	nvif_trace(object, "init completed with %d\n", ret);
-	return ret;
-}
-
-int
-nvkm_client_fini(struct nvkm_client *client, bool suspend)
-{
-	struct nvkm_object *object = &client->namedb.parent.object;
-	const char *name[2] = { "fini", "suspend" };
-	int ret, i;
-	nvif_trace(object, "%s running\n", name[suspend]);
-	nvif_trace(object, "%s notify\n", name[suspend]);
-	for (i = 0; i < ARRAY_SIZE(client->notify); i++)
-		nvkm_client_notify_put(client, i);
-	nvif_trace(object, "%s object\n", name[suspend]);
-	ret = nvkm_handle_fini(client->root, suspend);
-	nvif_trace(object, "%s completed with %d\n", name[suspend], ret);
-	return ret;
-}
-
 const char *
 nvkm_client_name(void *obj)
 {

commit 53003941067534b1071b0f7b71f4700c16d97b28
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:13 2015 +1000

    drm/nouveau/core: remove last printks
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index 878a82f8f295..0c7162fbe06c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -111,11 +111,11 @@ nvkm_client_notify_new(struct nvkm_object *object,
 	if (!notify)
 		return -ENOMEM;
 
-	nv_ioctl(client, "notify new size %d\n", size);
+	nvif_ioctl(object, "notify new size %d\n", size);
 	if (nvif_unpack(req->v0, 0, 0, true)) {
-		nv_ioctl(client, "notify new vers %d reply %d route %02x "
-				 "token %llx\n", req->v0.version,
-			 req->v0.reply, req->v0.route, req->v0.token);
+		nvif_ioctl(object, "notify new vers %d reply %d route %02x "
+				   "token %llx\n", req->v0.version,
+			   req->v0.reply, req->v0.route, req->v0.token);
 		notify->version = req->v0.version;
 		notify->size = sizeof(notify->rep.v0);
 		notify->rep.v0.version = req->v0.version;
@@ -146,10 +146,10 @@ nvkm_client_mthd_devlist(struct nvkm_object *object, void *data, u32 size)
 	} *args = data;
 	int ret;
 
-	nv_ioctl(object, "client devlist size %d\n", size);
+	nvif_ioctl(object, "client devlist size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, true)) {
-		nv_ioctl(object, "client devlist vers %d count %d\n",
-			 args->v0.version, args->v0.count);
+		nvif_ioctl(object, "client devlist vers %d count %d\n",
+			   args->v0.version, args->v0.count);
 		if (size == sizeof(args->v0.device[0]) * args->v0.count) {
 			ret = nvkm_device_list(args->v0.device, args->v0.count);
 			if (ret >= 0) {
@@ -233,25 +233,27 @@ nvkm_client_create_(const char *name, u64 devname, const char *cfg,
 int
 nvkm_client_init(struct nvkm_client *client)
 {
+	struct nvkm_object *object = &client->namedb.parent.object;
 	int ret;
-	nv_debug(client, "init running\n");
+	nvif_trace(object, "init running\n");
 	ret = nvkm_handle_init(client->root);
-	nv_debug(client, "init completed with %d\n", ret);
+	nvif_trace(object, "init completed with %d\n", ret);
 	return ret;
 }
 
 int
 nvkm_client_fini(struct nvkm_client *client, bool suspend)
 {
+	struct nvkm_object *object = &client->namedb.parent.object;
 	const char *name[2] = { "fini", "suspend" };
 	int ret, i;
-	nv_debug(client, "%s running\n", name[suspend]);
-	nv_debug(client, "%s notify\n", name[suspend]);
+	nvif_trace(object, "%s running\n", name[suspend]);
+	nvif_trace(object, "%s notify\n", name[suspend]);
 	for (i = 0; i < ARRAY_SIZE(client->notify); i++)
 		nvkm_client_notify_put(client, i);
-	nv_debug(client, "%s object\n", name[suspend]);
+	nvif_trace(object, "%s object\n", name[suspend]);
 	ret = nvkm_handle_fini(client->root, suspend);
-	nv_debug(client, "%s completed with %d\n", name[suspend], ret);
+	nvif_trace(object, "%s completed with %d\n", name[suspend], ret);
 	return ret;
 }
 

commit 5025407b9862349d17b1dff25737aaef6520a439
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 14:11:21 2015 +1000

    drm/nouveau/core: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
index acff10387846..878a82f8f295 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/client.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -21,21 +21,18 @@
  *
  * Authors: Ben Skeggs
  */
-
-#include <core/object.h>
 #include <core/client.h>
+#include <core/device.h>
 #include <core/handle.h>
+#include <core/notify.h>
 #include <core/option.h>
-#include <nvif/unpack.h>
-#include <nvif/class.h>
 
-#include <nvif/unpack.h>
+#include <nvif/class.h>
 #include <nvif/event.h>
-
-#include <engine/device.h>
+#include <nvif/unpack.h>
 
 struct nvkm_client_notify {
-	struct nouveau_client *client;
+	struct nvkm_client *client;
 	struct nvkm_notify n;
 	u8 version;
 	u8 size;
@@ -48,12 +45,12 @@ static int
 nvkm_client_notify(struct nvkm_notify *n)
 {
 	struct nvkm_client_notify *notify = container_of(n, typeof(*notify), n);
-	struct nouveau_client *client = notify->client;
+	struct nvkm_client *client = notify->client;
 	return client->ntfy(&notify->rep, notify->size, n->data, n->size);
 }
 
 int
-nvkm_client_notify_put(struct nouveau_client *client, int index)
+nvkm_client_notify_put(struct nvkm_client *client, int index)
 {
 	if (index < ARRAY_SIZE(client->notify)) {
 		if (client->notify[index]) {
@@ -65,7 +62,7 @@ nvkm_client_notify_put(struct nouveau_client *client, int index)
 }
 
 int
-nvkm_client_notify_get(struct nouveau_client *client, int index)
+nvkm_client_notify_get(struct nvkm_client *client, int index)
 {
 	if (index < ARRAY_SIZE(client->notify)) {
 		if (client->notify[index]) {
@@ -77,7 +74,7 @@ nvkm_client_notify_get(struct nouveau_client *client, int index)
 }
 
 int
-nvkm_client_notify_del(struct nouveau_client *client, int index)
+nvkm_client_notify_del(struct nvkm_client *client, int index)
 {
 	if (index < ARRAY_SIZE(client->notify)) {
 		if (client->notify[index]) {
@@ -91,10 +88,10 @@ nvkm_client_notify_del(struct nouveau_client *client, int index)
 }
 
 int
-nvkm_client_notify_new(struct nouveau_object *object,
+nvkm_client_notify_new(struct nvkm_object *object,
 		       struct nvkm_event *event, void *data, u32 size)
 {
-	struct nouveau_client *client = nouveau_client(object);
+	struct nvkm_client *client = nvkm_client(object);
 	struct nvkm_client_notify *notify;
 	union {
 		struct nvif_notify_req_v0 v0;
@@ -142,7 +139,7 @@ nvkm_client_notify_new(struct nouveau_object *object,
 }
 
 static int
-nouveau_client_devlist(struct nouveau_object *object, void *data, u32 size)
+nvkm_client_mthd_devlist(struct nvkm_object *object, void *data, u32 size)
 {
 	union {
 		struct nv_client_devlist_v0 v0;
@@ -154,8 +151,7 @@ nouveau_client_devlist(struct nouveau_object *object, void *data, u32 size)
 		nv_ioctl(object, "client devlist vers %d count %d\n",
 			 args->v0.version, args->v0.count);
 		if (size == sizeof(args->v0.device[0]) * args->v0.count) {
-			ret = nouveau_device_list(args->v0.device,
-						  args->v0.count);
+			ret = nvkm_device_list(args->v0.device, args->v0.count);
 			if (ret >= 0) {
 				args->v0.count = ret;
 				ret = 0;
@@ -169,12 +165,11 @@ nouveau_client_devlist(struct nouveau_object *object, void *data, u32 size)
 }
 
 static int
-nouveau_client_mthd(struct nouveau_object *object, u32 mthd,
-		    void *data, u32 size)
+nvkm_client_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
 	switch (mthd) {
 	case NV_CLIENT_DEVLIST:
-		return nouveau_client_devlist(object, data, size);
+		return nvkm_client_mthd_devlist(object, data, size);
 	default:
 		break;
 	}
@@ -182,71 +177,71 @@ nouveau_client_mthd(struct nouveau_object *object, u32 mthd,
 }
 
 static void
-nouveau_client_dtor(struct nouveau_object *object)
+nvkm_client_dtor(struct nvkm_object *object)
 {
-	struct nouveau_client *client = (void *)object;
+	struct nvkm_client *client = (void *)object;
 	int i;
 	for (i = 0; i < ARRAY_SIZE(client->notify); i++)
 		nvkm_client_notify_del(client, i);
-	nouveau_object_ref(NULL, &client->device);
-	nouveau_handle_destroy(client->root);
-	nouveau_namedb_destroy(&client->namedb);
+	nvkm_object_ref(NULL, &client->device);
+	nvkm_handle_destroy(client->root);
+	nvkm_namedb_destroy(&client->namedb);
 }
 
-static struct nouveau_oclass
-nouveau_client_oclass = {
-	.ofuncs = &(struct nouveau_ofuncs) {
-		.dtor = nouveau_client_dtor,
-		.mthd = nouveau_client_mthd,
+static struct nvkm_oclass
+nvkm_client_oclass = {
+	.ofuncs = &(struct nvkm_ofuncs) {
+		.dtor = nvkm_client_dtor,
+		.mthd = nvkm_client_mthd,
 	},
 };
 
 int
-nouveau_client_create_(const char *name, u64 devname, const char *cfg,
-		       const char *dbg, int length, void **pobject)
+nvkm_client_create_(const char *name, u64 devname, const char *cfg,
+		    const char *dbg, int length, void **pobject)
 {
-	struct nouveau_object *device;
-	struct nouveau_client *client;
+	struct nvkm_object *device;
+	struct nvkm_client *client;
 	int ret;
 
-	device = (void *)nouveau_device_find(devname);
+	device = (void *)nvkm_device_find(devname);
 	if (!device)
 		return -ENODEV;
 
-	ret = nouveau_namedb_create_(NULL, NULL, &nouveau_client_oclass,
-				     NV_CLIENT_CLASS, NULL,
-				     (1ULL << NVDEV_ENGINE_DEVICE),
-				     length, pobject);
+	ret = nvkm_namedb_create_(NULL, NULL, &nvkm_client_oclass,
+				  NV_CLIENT_CLASS, NULL,
+				  (1ULL << NVDEV_ENGINE_DEVICE),
+				  length, pobject);
 	client = *pobject;
 	if (ret)
 		return ret;
 
-	ret = nouveau_handle_create(nv_object(client), ~0, ~0,
-				    nv_object(client), &client->root);
+	ret = nvkm_handle_create(nv_object(client), ~0, ~0, nv_object(client),
+				 &client->root);
 	if (ret)
 		return ret;
 
 	/* prevent init/fini being called, os in in charge of this */
 	atomic_set(&nv_object(client)->usecount, 2);
 
-	nouveau_object_ref(device, &client->device);
+	nvkm_object_ref(device, &client->device);
 	snprintf(client->name, sizeof(client->name), "%s", name);
-	client->debug = nouveau_dbgopt(dbg, "CLIENT");
+	client->debug = nvkm_dbgopt(dbg, "CLIENT");
 	return 0;
 }
 
 int
-nouveau_client_init(struct nouveau_client *client)
+nvkm_client_init(struct nvkm_client *client)
 {
 	int ret;
 	nv_debug(client, "init running\n");
-	ret = nouveau_handle_init(client->root);
+	ret = nvkm_handle_init(client->root);
 	nv_debug(client, "init completed with %d\n", ret);
 	return ret;
 }
 
 int
-nouveau_client_fini(struct nouveau_client *client, bool suspend)
+nvkm_client_fini(struct nvkm_client *client, bool suspend)
 {
 	const char *name[2] = { "fini", "suspend" };
 	int ret, i;
@@ -255,16 +250,16 @@ nouveau_client_fini(struct nouveau_client *client, bool suspend)
 	for (i = 0; i < ARRAY_SIZE(client->notify); i++)
 		nvkm_client_notify_put(client, i);
 	nv_debug(client, "%s object\n", name[suspend]);
-	ret = nouveau_handle_fini(client->root, suspend);
+	ret = nvkm_handle_fini(client->root, suspend);
 	nv_debug(client, "%s completed with %d\n", name[suspend], ret);
 	return ret;
 }
 
 const char *
-nouveau_client_name(void *obj)
+nvkm_client_name(void *obj)
 {
 	const char *client_name = "unknown";
-	struct nouveau_client *client = nouveau_client(obj);
+	struct nvkm_client *client = nvkm_client(obj);
 	if (client)
 		client_name = client->name;
 	return client_name;

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/client.c b/drivers/gpu/drm/nouveau/nvkm/core/client.c
new file mode 100644
index 000000000000..acff10387846
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/core/client.c
@@ -0,0 +1,271 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <core/object.h>
+#include <core/client.h>
+#include <core/handle.h>
+#include <core/option.h>
+#include <nvif/unpack.h>
+#include <nvif/class.h>
+
+#include <nvif/unpack.h>
+#include <nvif/event.h>
+
+#include <engine/device.h>
+
+struct nvkm_client_notify {
+	struct nouveau_client *client;
+	struct nvkm_notify n;
+	u8 version;
+	u8 size;
+	union {
+		struct nvif_notify_rep_v0 v0;
+	} rep;
+};
+
+static int
+nvkm_client_notify(struct nvkm_notify *n)
+{
+	struct nvkm_client_notify *notify = container_of(n, typeof(*notify), n);
+	struct nouveau_client *client = notify->client;
+	return client->ntfy(&notify->rep, notify->size, n->data, n->size);
+}
+
+int
+nvkm_client_notify_put(struct nouveau_client *client, int index)
+{
+	if (index < ARRAY_SIZE(client->notify)) {
+		if (client->notify[index]) {
+			nvkm_notify_put(&client->notify[index]->n);
+			return 0;
+		}
+	}
+	return -ENOENT;
+}
+
+int
+nvkm_client_notify_get(struct nouveau_client *client, int index)
+{
+	if (index < ARRAY_SIZE(client->notify)) {
+		if (client->notify[index]) {
+			nvkm_notify_get(&client->notify[index]->n);
+			return 0;
+		}
+	}
+	return -ENOENT;
+}
+
+int
+nvkm_client_notify_del(struct nouveau_client *client, int index)
+{
+	if (index < ARRAY_SIZE(client->notify)) {
+		if (client->notify[index]) {
+			nvkm_notify_fini(&client->notify[index]->n);
+			kfree(client->notify[index]);
+			client->notify[index] = NULL;
+			return 0;
+		}
+	}
+	return -ENOENT;
+}
+
+int
+nvkm_client_notify_new(struct nouveau_object *object,
+		       struct nvkm_event *event, void *data, u32 size)
+{
+	struct nouveau_client *client = nouveau_client(object);
+	struct nvkm_client_notify *notify;
+	union {
+		struct nvif_notify_req_v0 v0;
+	} *req = data;
+	u8  index, reply;
+	int ret;
+
+	for (index = 0; index < ARRAY_SIZE(client->notify); index++) {
+		if (!client->notify[index])
+			break;
+	}
+
+	if (index == ARRAY_SIZE(client->notify))
+		return -ENOSPC;
+
+	notify = kzalloc(sizeof(*notify), GFP_KERNEL);
+	if (!notify)
+		return -ENOMEM;
+
+	nv_ioctl(client, "notify new size %d\n", size);
+	if (nvif_unpack(req->v0, 0, 0, true)) {
+		nv_ioctl(client, "notify new vers %d reply %d route %02x "
+				 "token %llx\n", req->v0.version,
+			 req->v0.reply, req->v0.route, req->v0.token);
+		notify->version = req->v0.version;
+		notify->size = sizeof(notify->rep.v0);
+		notify->rep.v0.version = req->v0.version;
+		notify->rep.v0.route = req->v0.route;
+		notify->rep.v0.token = req->v0.token;
+		reply = req->v0.reply;
+	}
+
+	if (ret == 0) {
+		ret = nvkm_notify_init(object, event, nvkm_client_notify,
+				       false, data, size, reply, &notify->n);
+		if (ret == 0) {
+			client->notify[index] = notify;
+			notify->client = client;
+			return index;
+		}
+	}
+
+	kfree(notify);
+	return ret;
+}
+
+static int
+nouveau_client_devlist(struct nouveau_object *object, void *data, u32 size)
+{
+	union {
+		struct nv_client_devlist_v0 v0;
+	} *args = data;
+	int ret;
+
+	nv_ioctl(object, "client devlist size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, true)) {
+		nv_ioctl(object, "client devlist vers %d count %d\n",
+			 args->v0.version, args->v0.count);
+		if (size == sizeof(args->v0.device[0]) * args->v0.count) {
+			ret = nouveau_device_list(args->v0.device,
+						  args->v0.count);
+			if (ret >= 0) {
+				args->v0.count = ret;
+				ret = 0;
+			}
+		} else {
+			ret = -EINVAL;
+		}
+	}
+
+	return ret;
+}
+
+static int
+nouveau_client_mthd(struct nouveau_object *object, u32 mthd,
+		    void *data, u32 size)
+{
+	switch (mthd) {
+	case NV_CLIENT_DEVLIST:
+		return nouveau_client_devlist(object, data, size);
+	default:
+		break;
+	}
+	return -EINVAL;
+}
+
+static void
+nouveau_client_dtor(struct nouveau_object *object)
+{
+	struct nouveau_client *client = (void *)object;
+	int i;
+	for (i = 0; i < ARRAY_SIZE(client->notify); i++)
+		nvkm_client_notify_del(client, i);
+	nouveau_object_ref(NULL, &client->device);
+	nouveau_handle_destroy(client->root);
+	nouveau_namedb_destroy(&client->namedb);
+}
+
+static struct nouveau_oclass
+nouveau_client_oclass = {
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.dtor = nouveau_client_dtor,
+		.mthd = nouveau_client_mthd,
+	},
+};
+
+int
+nouveau_client_create_(const char *name, u64 devname, const char *cfg,
+		       const char *dbg, int length, void **pobject)
+{
+	struct nouveau_object *device;
+	struct nouveau_client *client;
+	int ret;
+
+	device = (void *)nouveau_device_find(devname);
+	if (!device)
+		return -ENODEV;
+
+	ret = nouveau_namedb_create_(NULL, NULL, &nouveau_client_oclass,
+				     NV_CLIENT_CLASS, NULL,
+				     (1ULL << NVDEV_ENGINE_DEVICE),
+				     length, pobject);
+	client = *pobject;
+	if (ret)
+		return ret;
+
+	ret = nouveau_handle_create(nv_object(client), ~0, ~0,
+				    nv_object(client), &client->root);
+	if (ret)
+		return ret;
+
+	/* prevent init/fini being called, os in in charge of this */
+	atomic_set(&nv_object(client)->usecount, 2);
+
+	nouveau_object_ref(device, &client->device);
+	snprintf(client->name, sizeof(client->name), "%s", name);
+	client->debug = nouveau_dbgopt(dbg, "CLIENT");
+	return 0;
+}
+
+int
+nouveau_client_init(struct nouveau_client *client)
+{
+	int ret;
+	nv_debug(client, "init running\n");
+	ret = nouveau_handle_init(client->root);
+	nv_debug(client, "init completed with %d\n", ret);
+	return ret;
+}
+
+int
+nouveau_client_fini(struct nouveau_client *client, bool suspend)
+{
+	const char *name[2] = { "fini", "suspend" };
+	int ret, i;
+	nv_debug(client, "%s running\n", name[suspend]);
+	nv_debug(client, "%s notify\n", name[suspend]);
+	for (i = 0; i < ARRAY_SIZE(client->notify); i++)
+		nvkm_client_notify_put(client, i);
+	nv_debug(client, "%s object\n", name[suspend]);
+	ret = nouveau_handle_fini(client->root, suspend);
+	nv_debug(client, "%s completed with %d\n", name[suspend], ret);
+	return ret;
+}
+
+const char *
+nouveau_client_name(void *obj)
+{
+	const char *client_name = "unknown";
+	struct nouveau_client *client = nouveau_client(obj);
+	if (client)
+		client_name = client->name;
+	return client_name;
+}
