commit c83c4097eba8950bc7028f0846c21f9718dd8697
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/mmu: define user interfaces to mmu memory allocation
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index a28018ee5b19..d777df5a64e6 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -53,7 +53,7 @@ nvkm_ioctl_sclass(struct nvkm_client *client,
 	union {
 		struct nvif_ioctl_sclass_v0 v0;
 	} *args = data;
-	struct nvkm_oclass oclass;
+	struct nvkm_oclass oclass = { .client = client };
 	int ret = -ENOSYS, i = 0;
 
 	nvif_ioctl(object, "sclass size %d\n", size);

commit 8e0042d505e86299544cf000e26408bdd252e36b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/core/object: plumb the unmap ioctl through
    
    MMU will be using this for BAR mappings.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index bf2507f17baa..a28018ee5b19 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -287,6 +287,7 @@ nvkm_ioctl_unmap(struct nvkm_client *client,
 	nvif_ioctl(object, "unmap size %d\n", size);
 	if (!(ret = nvif_unvers(ret, &data, &size, args->none))) {
 		nvif_ioctl(object, "unmap\n");
+		ret = nvkm_object_unmap(object);
 	}
 
 	return ret;

commit 01326050391ceee2cf1b6c91c108414a35f40861
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/core/object: allow arguments to be passed to map function
    
    MMU will be needing this to specify kind info on BAR mappings.
    
    We have no userspace currently using these interfaces, so break the ABI
    instead of supporting both.  NVIF version bump so any future use can be
    guarded.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index be19bbe56bba..bf2507f17baa 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -257,13 +257,19 @@ nvkm_ioctl_map(struct nvkm_client *client,
 	union {
 		struct nvif_ioctl_map_v0 v0;
 	} *args = data;
+	enum nvkm_object_map type;
 	int ret = -ENOSYS;
 
 	nvif_ioctl(object, "map size %d\n", size);
-	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
 		nvif_ioctl(object, "map vers %d\n", args->v0.version);
-		ret = nvkm_object_map(object, &args->v0.handle,
-					      &args->v0.length);
+		ret = nvkm_object_map(object, data, size, &type,
+				      &args->v0.handle,
+				      &args->v0.length);
+		if (type == NVKM_OBJECT_MAP_IO)
+			args->v0.type = NVIF_IOCTL_MAP_V0_IO;
+		else
+			args->v0.type = NVIF_IOCTL_MAP_V0_VA;
 	}
 
 	return ret;

commit 05da248bbe91fecb29e1f2fb9b978c4d2ee6da8e
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed May 25 17:02:11 2016 +1000

    drm/nouveau/core/client: destroy client objects over nvif
    
    Preparation for supporting subclients, and also good for consistency.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index 25c800b426ca..be19bbe56bba 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -158,7 +158,7 @@ nvkm_ioctl_del(struct nvkm_client *client,
 		nvkm_object_del(&object);
 	}
 
-	return ret;
+	return ret ? ret : 1;
 }
 
 static int
@@ -441,12 +441,13 @@ nvkm_ioctl(struct nvkm_client *client, bool supervisor,
 				      &args->v0.route, &args->v0.token);
 	}
 
-	nvif_ioctl(object, "return %d\n", ret);
-	if (hack) {
-		*hack = client->data;
-		client->data = NULL;
+	if (ret != 1) {
+		nvif_ioctl(object, "return %d\n", ret);
+		if (hack) {
+			*hack = client->data;
+			client->data = NULL;
+		}
 	}
 
-	client->super = false;
 	return ret;
 }

commit 843faa030c3677080e4a108889dccb21798b2a32
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed May 25 17:47:18 2016 +1000

    drm/nouveau/core/object: pass more args in oclass
    
    The fields were already in struct nvkm_oclass for some reason (probably
    as an accidental left-over).
    
    Preparation for supporting subclients.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index b43ce4e724e8..25c800b426ca 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -106,9 +106,11 @@ nvkm_ioctl_new(struct nvkm_client *client,
 
 	do {
 		memset(&oclass, 0x00, sizeof(oclass));
-		oclass.client = client;
 		oclass.handle = args->v0.handle;
+		oclass.route  = args->v0.route;
+		oclass.token  = args->v0.token;
 		oclass.object = args->v0.object;
+		oclass.client = client;
 		oclass.parent = parent;
 		ret = parent->func->sclass(parent, i++, &oclass);
 		if (ret)
@@ -127,9 +129,6 @@ nvkm_ioctl_new(struct nvkm_client *client,
 		ret = nvkm_object_init(object);
 		if (ret == 0) {
 			list_add(&object->head, &parent->tree);
-			object->route = args->v0.route;
-			object->token = args->v0.token;
-			object->object = args->v0.object;
 			if (nvkm_object_insert(object)) {
 				client->data = object;
 				return 0;

commit a664869ac4c77875ca84a38f614bc1c7b3c79812
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed May 25 17:33:36 2016 +1000

    drm/nouveau/core/object: pass client directly to ioctl handlers
    
    nvkm_object::client refers to the client that created the object, which,
    is currently always the same as the ioctl caller.
    
    Upcoming patches introduce the concept of subclients, where a parent is
    able to access the object trees of its children, making the above no
    longer true.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index 6e695b7a5733..b43ce4e724e8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -29,7 +29,8 @@
 #include <nvif/ioctl.h>
 
 static int
-nvkm_ioctl_nop(struct nvkm_object *object, void *data, u32 size)
+nvkm_ioctl_nop(struct nvkm_client *client,
+	       struct nvkm_object *object, void *data, u32 size)
 {
 	union {
 		struct nvif_ioctl_nop_v0 v0;
@@ -46,7 +47,8 @@ nvkm_ioctl_nop(struct nvkm_object *object, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_sclass(struct nvkm_object *object, void *data, u32 size)
+nvkm_ioctl_sclass(struct nvkm_client *client,
+		  struct nvkm_object *object, void *data, u32 size)
 {
 	union {
 		struct nvif_ioctl_sclass_v0 v0;
@@ -78,12 +80,12 @@ nvkm_ioctl_sclass(struct nvkm_object *object, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_new(struct nvkm_object *parent, void *data, u32 size)
+nvkm_ioctl_new(struct nvkm_client *client,
+	       struct nvkm_object *parent, void *data, u32 size)
 {
 	union {
 		struct nvif_ioctl_new_v0 v0;
 	} *args = data;
-	struct nvkm_client *client = parent->client;
 	struct nvkm_object *object = NULL;
 	struct nvkm_oclass oclass;
 	int ret = -ENOSYS, i = 0;
@@ -142,7 +144,8 @@ nvkm_ioctl_new(struct nvkm_object *parent, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_del(struct nvkm_object *object, void *data, u32 size)
+nvkm_ioctl_del(struct nvkm_client *client,
+	       struct nvkm_object *object, void *data, u32 size)
 {
 	union {
 		struct nvif_ioctl_del none;
@@ -160,7 +163,8 @@ nvkm_ioctl_del(struct nvkm_object *object, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_mthd(struct nvkm_object *object, void *data, u32 size)
+nvkm_ioctl_mthd(struct nvkm_client *client,
+		struct nvkm_object *object, void *data, u32 size)
 {
 	union {
 		struct nvif_ioctl_mthd_v0 v0;
@@ -179,7 +183,8 @@ nvkm_ioctl_mthd(struct nvkm_object *object, void *data, u32 size)
 
 
 static int
-nvkm_ioctl_rd(struct nvkm_object *object, void *data, u32 size)
+nvkm_ioctl_rd(struct nvkm_client *client,
+	      struct nvkm_object *object, void *data, u32 size)
 {
 	union {
 		struct nvif_ioctl_rd_v0 v0;
@@ -218,7 +223,8 @@ nvkm_ioctl_rd(struct nvkm_object *object, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_wr(struct nvkm_object *object, void *data, u32 size)
+nvkm_ioctl_wr(struct nvkm_client *client,
+	      struct nvkm_object *object, void *data, u32 size)
 {
 	union {
 		struct nvif_ioctl_wr_v0 v0;
@@ -246,7 +252,8 @@ nvkm_ioctl_wr(struct nvkm_object *object, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_map(struct nvkm_object *object, void *data, u32 size)
+nvkm_ioctl_map(struct nvkm_client *client,
+	       struct nvkm_object *object, void *data, u32 size)
 {
 	union {
 		struct nvif_ioctl_map_v0 v0;
@@ -264,7 +271,8 @@ nvkm_ioctl_map(struct nvkm_object *object, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_unmap(struct nvkm_object *object, void *data, u32 size)
+nvkm_ioctl_unmap(struct nvkm_client *client,
+		 struct nvkm_object *object, void *data, u32 size)
 {
 	union {
 		struct nvif_ioctl_unmap none;
@@ -280,7 +288,8 @@ nvkm_ioctl_unmap(struct nvkm_object *object, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_ntfy_new(struct nvkm_object *object, void *data, u32 size)
+nvkm_ioctl_ntfy_new(struct nvkm_client *client,
+		    struct nvkm_object *object, void *data, u32 size)
 {
 	union {
 		struct nvif_ioctl_ntfy_new_v0 v0;
@@ -306,9 +315,9 @@ nvkm_ioctl_ntfy_new(struct nvkm_object *object, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_ntfy_del(struct nvkm_object *object, void *data, u32 size)
+nvkm_ioctl_ntfy_del(struct nvkm_client *client,
+		    struct nvkm_object *object, void *data, u32 size)
 {
-	struct nvkm_client *client = object->client;
 	union {
 		struct nvif_ioctl_ntfy_del_v0 v0;
 	} *args = data;
@@ -325,9 +334,9 @@ nvkm_ioctl_ntfy_del(struct nvkm_object *object, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_ntfy_get(struct nvkm_object *object, void *data, u32 size)
+nvkm_ioctl_ntfy_get(struct nvkm_client *client,
+		    struct nvkm_object *object, void *data, u32 size)
 {
-	struct nvkm_client *client = object->client;
 	union {
 		struct nvif_ioctl_ntfy_get_v0 v0;
 	} *args = data;
@@ -344,9 +353,9 @@ nvkm_ioctl_ntfy_get(struct nvkm_object *object, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_ntfy_put(struct nvkm_object *object, void *data, u32 size)
+nvkm_ioctl_ntfy_put(struct nvkm_client *client,
+		    struct nvkm_object *object, void *data, u32 size)
 {
-	struct nvkm_client *client = object->client;
 	union {
 		struct nvif_ioctl_ntfy_put_v0 v0;
 	} *args = data;
@@ -364,7 +373,7 @@ nvkm_ioctl_ntfy_put(struct nvkm_object *object, void *data, u32 size)
 
 static struct {
 	int version;
-	int (*func)(struct nvkm_object *, void *, u32);
+	int (*func)(struct nvkm_client *, struct nvkm_object *, void *, u32);
 }
 nvkm_ioctl_v0[] = {
 	{ 0x00, nvkm_ioctl_nop },
@@ -404,7 +413,7 @@ nvkm_ioctl_path(struct nvkm_client *client, u64 handle, u32 type,
 
 	if (ret = -EINVAL, type < ARRAY_SIZE(nvkm_ioctl_v0)) {
 		if (nvkm_ioctl_v0[type].version == 0)
-			ret = nvkm_ioctl_v0[type].func(object, data, size);
+			ret = nvkm_ioctl_v0[type].func(client, object, data, size);
 	}
 
 	return ret;

commit daad3dfb05be8b0682c1bb0db6b59e50a4bb95f6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Dec 22 15:23:04 2016 +1000

    drm/nouveau/core/client: lookup client objects with nvkm_object_search()
    
    Custom code is no longer needed here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index b0db51847c36..6e695b7a5733 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -128,7 +128,7 @@ nvkm_ioctl_new(struct nvkm_object *parent, void *data, u32 size)
 			object->route = args->v0.route;
 			object->token = args->v0.token;
 			object->object = args->v0.object;
-			if (nvkm_client_insert(client, object)) {
+			if (nvkm_object_insert(object)) {
 				client->data = object;
 				return 0;
 			}
@@ -389,13 +389,10 @@ nvkm_ioctl_path(struct nvkm_client *client, u64 handle, u32 type,
 	struct nvkm_object *object;
 	int ret;
 
-	if (handle)
-		object = nvkm_client_search(client, handle);
-	else
-		object = &client->object;
-	if (unlikely(!object)) {
+	object = nvkm_object_search(client, handle, NULL);
+	if (IS_ERR(object)) {
 		nvif_ioctl(&client->object, "object not found\n");
-		return -ENOENT;
+		return PTR_ERR(object);
 	}
 
 	if (owner != NVIF_IOCTL_V0_OWNER_ANY && owner != object->route) {

commit f01c4e682c941ba70e0ebec44db754844a1b9b82
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon Nov 9 09:21:27 2015 +1000

    drm/nouveau/nvif: modify nvif_unvers/nvif_unpack macros to be more obvious
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index d87d6ab03cc7..b0db51847c36 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -34,10 +34,10 @@ nvkm_ioctl_nop(struct nvkm_object *object, void *data, u32 size)
 	union {
 		struct nvif_ioctl_nop_v0 v0;
 	} *args = data;
-	int ret;
+	int ret = -ENOSYS;
 
 	nvif_ioctl(object, "nop size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 		nvif_ioctl(object, "nop vers %lld\n", args->v0.version);
 		args->v0.version = NVIF_VERSION_LATEST;
 	}
@@ -52,10 +52,10 @@ nvkm_ioctl_sclass(struct nvkm_object *object, void *data, u32 size)
 		struct nvif_ioctl_sclass_v0 v0;
 	} *args = data;
 	struct nvkm_oclass oclass;
-	int ret, i = 0;
+	int ret = -ENOSYS, i = 0;
 
 	nvif_ioctl(object, "sclass size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, true)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
 		nvif_ioctl(object, "sclass vers %d count %d\n",
 			   args->v0.version, args->v0.count);
 		if (size != args->v0.count * sizeof(args->v0.oclass[0]))
@@ -86,10 +86,10 @@ nvkm_ioctl_new(struct nvkm_object *parent, void *data, u32 size)
 	struct nvkm_client *client = parent->client;
 	struct nvkm_object *object = NULL;
 	struct nvkm_oclass oclass;
-	int ret, i = 0;
+	int ret = -ENOSYS, i = 0;
 
 	nvif_ioctl(parent, "new size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, true)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
 		nvif_ioctl(parent, "new vers %d handle %08x class %08x "
 				   "route %02x token %llx object %016llx\n",
 			   args->v0.version, args->v0.handle, args->v0.oclass,
@@ -147,10 +147,10 @@ nvkm_ioctl_del(struct nvkm_object *object, void *data, u32 size)
 	union {
 		struct nvif_ioctl_del none;
 	} *args = data;
-	int ret;
+	int ret = -ENOSYS;
 
 	nvif_ioctl(object, "delete size %d\n", size);
-	if (nvif_unvers(args->none)) {
+	if (!(ret = nvif_unvers(ret, &data, &size, args->none))) {
 		nvif_ioctl(object, "delete\n");
 		nvkm_object_fini(object, false);
 		nvkm_object_del(&object);
@@ -165,10 +165,10 @@ nvkm_ioctl_mthd(struct nvkm_object *object, void *data, u32 size)
 	union {
 		struct nvif_ioctl_mthd_v0 v0;
 	} *args = data;
-	int ret;
+	int ret = -ENOSYS;
 
 	nvif_ioctl(object, "mthd size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, true)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
 		nvif_ioctl(object, "mthd vers %d mthd %02x\n",
 			   args->v0.version, args->v0.method);
 		ret = nvkm_object_mthd(object, args->v0.method, data, size);
@@ -189,10 +189,10 @@ nvkm_ioctl_rd(struct nvkm_object *object, void *data, u32 size)
 		u16 b16;
 		u32 b32;
 	} v;
-	int ret;
+	int ret = -ENOSYS;
 
 	nvif_ioctl(object, "rd size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 		nvif_ioctl(object, "rd vers %d size %d addr %016llx\n",
 			   args->v0.version, args->v0.size, args->v0.addr);
 		switch (args->v0.size) {
@@ -223,10 +223,10 @@ nvkm_ioctl_wr(struct nvkm_object *object, void *data, u32 size)
 	union {
 		struct nvif_ioctl_wr_v0 v0;
 	} *args = data;
-	int ret;
+	int ret = -ENOSYS;
 
 	nvif_ioctl(object, "wr size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 		nvif_ioctl(object,
 			   "wr vers %d size %d addr %016llx data %08x\n",
 			   args->v0.version, args->v0.size, args->v0.addr,
@@ -251,10 +251,10 @@ nvkm_ioctl_map(struct nvkm_object *object, void *data, u32 size)
 	union {
 		struct nvif_ioctl_map_v0 v0;
 	} *args = data;
-	int ret;
+	int ret = -ENOSYS;
 
 	nvif_ioctl(object, "map size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 		nvif_ioctl(object, "map vers %d\n", args->v0.version);
 		ret = nvkm_object_map(object, &args->v0.handle,
 					      &args->v0.length);
@@ -269,10 +269,10 @@ nvkm_ioctl_unmap(struct nvkm_object *object, void *data, u32 size)
 	union {
 		struct nvif_ioctl_unmap none;
 	} *args = data;
-	int ret;
+	int ret = -ENOSYS;
 
 	nvif_ioctl(object, "unmap size %d\n", size);
-	if (nvif_unvers(args->none)) {
+	if (!(ret = nvif_unvers(ret, &data, &size, args->none))) {
 		nvif_ioctl(object, "unmap\n");
 	}
 
@@ -286,10 +286,10 @@ nvkm_ioctl_ntfy_new(struct nvkm_object *object, void *data, u32 size)
 		struct nvif_ioctl_ntfy_new_v0 v0;
 	} *args = data;
 	struct nvkm_event *event;
-	int ret;
+	int ret = -ENOSYS;
 
 	nvif_ioctl(object, "ntfy new size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, true)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
 		nvif_ioctl(object, "ntfy new vers %d event %02x\n",
 			   args->v0.version, args->v0.event);
 		ret = nvkm_object_ntfy(object, args->v0.event, &event);
@@ -312,10 +312,10 @@ nvkm_ioctl_ntfy_del(struct nvkm_object *object, void *data, u32 size)
 	union {
 		struct nvif_ioctl_ntfy_del_v0 v0;
 	} *args = data;
-	int ret;
+	int ret = -ENOSYS;
 
 	nvif_ioctl(object, "ntfy del size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 		nvif_ioctl(object, "ntfy del vers %d index %d\n",
 			   args->v0.version, args->v0.index);
 		ret = nvkm_client_notify_del(client, args->v0.index);
@@ -331,10 +331,10 @@ nvkm_ioctl_ntfy_get(struct nvkm_object *object, void *data, u32 size)
 	union {
 		struct nvif_ioctl_ntfy_get_v0 v0;
 	} *args = data;
-	int ret;
+	int ret = -ENOSYS;
 
 	nvif_ioctl(object, "ntfy get size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 		nvif_ioctl(object, "ntfy get vers %d index %d\n",
 			   args->v0.version, args->v0.index);
 		ret = nvkm_client_notify_get(client, args->v0.index);
@@ -350,10 +350,10 @@ nvkm_ioctl_ntfy_put(struct nvkm_object *object, void *data, u32 size)
 	union {
 		struct nvif_ioctl_ntfy_put_v0 v0;
 	} *args = data;
-	int ret;
+	int ret = -ENOSYS;
 
 	nvif_ioctl(object, "ntfy put size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 		nvif_ioctl(object, "ntfy put vers %d index %d\n",
 			   args->v0.version, args->v0.index);
 		ret = nvkm_client_notify_put(client, args->v0.index);
@@ -421,12 +421,12 @@ nvkm_ioctl(struct nvkm_client *client, bool supervisor,
 	union {
 		struct nvif_ioctl_v0 v0;
 	} *args = data;
-	int ret;
+	int ret = -ENOSYS;
 
 	client->super = supervisor;
 	nvif_ioctl(object, "size %d\n", size);
 
-	if (nvif_unpack(args->v0, 0, 0, true)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
 		nvif_ioctl(object,
 			   "vers %d type %02x object %016llx owner %02x\n",
 			   args->v0.version, args->v0.type, args->v0.object,

commit fbd58ebda9c8572ca6285b88e3348c7712f125ec
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/object: merge with handle
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index d9bb0394d83f..d87d6ab03cc7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -24,15 +24,13 @@
 #include <core/ioctl.h>
 #include <core/client.h>
 #include <core/engine.h>
-#include <core/handle.h>
 
 #include <nvif/unpack.h>
 #include <nvif/ioctl.h>
 
 static int
-nvkm_ioctl_nop(struct nvkm_handle *handle, void *data, u32 size)
+nvkm_ioctl_nop(struct nvkm_object *object, void *data, u32 size)
 {
-	struct nvkm_object *object = handle->object;
 	union {
 		struct nvif_ioctl_nop_v0 v0;
 	} *args = data;
@@ -48,9 +46,8 @@ nvkm_ioctl_nop(struct nvkm_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_sclass(struct nvkm_handle *handle, void *data, u32 size)
+nvkm_ioctl_sclass(struct nvkm_object *object, void *data, u32 size)
 {
-	struct nvkm_object *object = handle->object;
 	union {
 		struct nvif_ioctl_sclass_v0 v0;
 	} *args = data;
@@ -81,13 +78,12 @@ nvkm_ioctl_sclass(struct nvkm_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
+nvkm_ioctl_new(struct nvkm_object *parent, void *data, u32 size)
 {
 	union {
 		struct nvif_ioctl_new_v0 v0;
 	} *args = data;
-	struct nvkm_client *client = handle->object->client;
-	struct nvkm_object *parent = handle->object;
+	struct nvkm_client *client = parent->client;
 	struct nvkm_object *object = NULL;
 	struct nvkm_oclass oclass;
 	int ret, i = 0;
@@ -124,38 +120,30 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 	}
 
 	ret = oclass.ctor(&oclass, data, size, &object);
-	if (ret)
-		goto fail_object;
-
-	ret = nvkm_object_inc(object);
-	if (ret)
-		goto fail_object;
-
-	ret = nvkm_handle_create(handle, args->v0.handle, object, &handle);
-	if (ret)
-		goto fail_handle;
-
-	ret = nvkm_handle_init(handle);
-	handle->route = args->v0.route;
-	handle->token = args->v0.token;
-	if (ret)
-		nvkm_handle_destroy(handle);
-
-	handle->handle = args->v0.object;
-	nvkm_client_insert(client, handle);
-	client->data = object;
-fail_handle:
-	nvkm_object_dec(object, false);
-fail_object:
-	nvkm_object_ref(NULL, &object);
 	nvkm_engine_unref(&oclass.engine);
+	if (ret == 0) {
+		ret = nvkm_object_init(object);
+		if (ret == 0) {
+			list_add(&object->head, &parent->tree);
+			object->route = args->v0.route;
+			object->token = args->v0.token;
+			object->object = args->v0.object;
+			if (nvkm_client_insert(client, object)) {
+				client->data = object;
+				return 0;
+			}
+			ret = -EEXIST;
+		}
+		nvkm_object_fini(object, false);
+	}
+
+	nvkm_object_del(&object);
 	return ret;
 }
 
 static int
-nvkm_ioctl_del(struct nvkm_handle *handle, void *data, u32 size)
+nvkm_ioctl_del(struct nvkm_object *object, void *data, u32 size)
 {
-	struct nvkm_object *object = handle->object;
 	union {
 		struct nvif_ioctl_del none;
 	} *args = data;
@@ -164,17 +152,16 @@ nvkm_ioctl_del(struct nvkm_handle *handle, void *data, u32 size)
 	nvif_ioctl(object, "delete size %d\n", size);
 	if (nvif_unvers(args->none)) {
 		nvif_ioctl(object, "delete\n");
-		nvkm_handle_fini(handle, false);
-		nvkm_handle_destroy(handle);
+		nvkm_object_fini(object, false);
+		nvkm_object_del(&object);
 	}
 
 	return ret;
 }
 
 static int
-nvkm_ioctl_mthd(struct nvkm_handle *handle, void *data, u32 size)
+nvkm_ioctl_mthd(struct nvkm_object *object, void *data, u32 size)
 {
-	struct nvkm_object *object = handle->object;
 	union {
 		struct nvif_ioctl_mthd_v0 v0;
 	} *args = data;
@@ -192,9 +179,8 @@ nvkm_ioctl_mthd(struct nvkm_handle *handle, void *data, u32 size)
 
 
 static int
-nvkm_ioctl_rd(struct nvkm_handle *handle, void *data, u32 size)
+nvkm_ioctl_rd(struct nvkm_object *object, void *data, u32 size)
 {
-	struct nvkm_object *object = handle->object;
 	union {
 		struct nvif_ioctl_rd_v0 v0;
 	} *args = data;
@@ -232,9 +218,8 @@ nvkm_ioctl_rd(struct nvkm_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_wr(struct nvkm_handle *handle, void *data, u32 size)
+nvkm_ioctl_wr(struct nvkm_object *object, void *data, u32 size)
 {
-	struct nvkm_object *object = handle->object;
 	union {
 		struct nvif_ioctl_wr_v0 v0;
 	} *args = data;
@@ -261,9 +246,8 @@ nvkm_ioctl_wr(struct nvkm_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_map(struct nvkm_handle *handle, void *data, u32 size)
+nvkm_ioctl_map(struct nvkm_object *object, void *data, u32 size)
 {
-	struct nvkm_object *object = handle->object;
 	union {
 		struct nvif_ioctl_map_v0 v0;
 	} *args = data;
@@ -280,9 +264,8 @@ nvkm_ioctl_map(struct nvkm_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_unmap(struct nvkm_handle *handle, void *data, u32 size)
+nvkm_ioctl_unmap(struct nvkm_object *object, void *data, u32 size)
 {
-	struct nvkm_object *object = handle->object;
 	union {
 		struct nvif_ioctl_unmap none;
 	} *args = data;
@@ -297,9 +280,8 @@ nvkm_ioctl_unmap(struct nvkm_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_ntfy_new(struct nvkm_handle *handle, void *data, u32 size)
+nvkm_ioctl_ntfy_new(struct nvkm_object *object, void *data, u32 size)
 {
-	struct nvkm_object *object = handle->object;
 	union {
 		struct nvif_ioctl_ntfy_new_v0 v0;
 	} *args = data;
@@ -324,10 +306,9 @@ nvkm_ioctl_ntfy_new(struct nvkm_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_ntfy_del(struct nvkm_handle *handle, void *data, u32 size)
+nvkm_ioctl_ntfy_del(struct nvkm_object *object, void *data, u32 size)
 {
-	struct nvkm_client *client = nvkm_client(handle->object);
-	struct nvkm_object *object = handle->object;
+	struct nvkm_client *client = object->client;
 	union {
 		struct nvif_ioctl_ntfy_del_v0 v0;
 	} *args = data;
@@ -344,10 +325,9 @@ nvkm_ioctl_ntfy_del(struct nvkm_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_ntfy_get(struct nvkm_handle *handle, void *data, u32 size)
+nvkm_ioctl_ntfy_get(struct nvkm_object *object, void *data, u32 size)
 {
-	struct nvkm_client *client = nvkm_client(handle->object);
-	struct nvkm_object *object = handle->object;
+	struct nvkm_client *client = object->client;
 	union {
 		struct nvif_ioctl_ntfy_get_v0 v0;
 	} *args = data;
@@ -364,10 +344,9 @@ nvkm_ioctl_ntfy_get(struct nvkm_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_ntfy_put(struct nvkm_handle *handle, void *data, u32 size)
+nvkm_ioctl_ntfy_put(struct nvkm_object *object, void *data, u32 size)
 {
-	struct nvkm_client *client = nvkm_client(handle->object);
-	struct nvkm_object *object = handle->object;
+	struct nvkm_client *client = object->client;
 	union {
 		struct nvif_ioctl_ntfy_put_v0 v0;
 	} *args = data;
@@ -385,7 +364,7 @@ nvkm_ioctl_ntfy_put(struct nvkm_handle *handle, void *data, u32 size)
 
 static struct {
 	int version;
-	int (*func)(struct nvkm_handle *, void *, u32);
+	int (*func)(struct nvkm_object *, void *, u32);
 }
 nvkm_ioctl_v0[] = {
 	{ 0x00, nvkm_ioctl_nop },
@@ -407,13 +386,13 @@ static int
 nvkm_ioctl_path(struct nvkm_client *client, u64 handle, u32 type,
 		void *data, u32 size, u8 owner, u8 *route, u64 *token)
 {
-	struct nvkm_handle *object;
+	struct nvkm_object *object;
 	int ret;
 
 	if (handle)
 		object = nvkm_client_search(client, handle);
 	else
-		object = client->root;
+		object = &client->object;
 	if (unlikely(!object)) {
 		nvif_ioctl(&client->object, "object not found\n");
 		return -ENOENT;

commit ef8bc5760b51d69741ed5f42224f1fdd2935541a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/core: kill some (now) dead code
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index 28f9fa289e80..d9bb0394d83f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -25,7 +25,6 @@
 #include <core/client.h>
 #include <core/engine.h>
 #include <core/handle.h>
-#include <core/parent.h>
 
 #include <nvif/unpack.h>
 #include <nvif/ioctl.h>
@@ -65,17 +64,6 @@ nvkm_ioctl_sclass(struct nvkm_handle *handle, void *data, u32 size)
 		if (size != args->v0.count * sizeof(args->v0.oclass[0]))
 			return -EINVAL;
 
-		if (object->oclass) {
-			if (nv_iclass(object, NV_PARENT_CLASS)) {
-				ret = nvkm_parent_lclass(object,
-							 args->v0.oclass,
-							 args->v0.count);
-			}
-
-			args->v0.count = ret;
-			return 0;
-		}
-
 		while (object->func->sclass &&
 		       object->func->sclass(object, i, &oclass) >= 0) {
 			if (i < args->v0.count) {
@@ -92,111 +80,6 @@ nvkm_ioctl_sclass(struct nvkm_handle *handle, void *data, u32 size)
 	return ret;
 }
 
-static int
-nvkm_ioctl_new_old(struct nvkm_handle *handle, void *data, u32 size)
-{
-	union {
-		struct nvif_ioctl_new_v0 v0;
-	} *args = data;
-	struct nvkm_client *client = nvkm_client(handle->object);
-	struct nvkm_object *engctx = NULL;
-	struct nvkm_object *object = NULL;
-	struct nvkm_parent *parent;
-	struct nvkm_engine *engine;
-	struct nvkm_oclass *oclass;
-	u32 _handle, _oclass;
-	int ret;
-
-	nvif_ioctl(handle->object, "new size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, true)) {
-		_handle = args->v0.handle;
-		_oclass = args->v0.oclass;
-	} else
-		return ret;
-
-	nvif_ioctl(handle->object, "new vers %d handle %08x class %08x "
-				   "route %02x token %llx object %016llx\n",
-		   args->v0.version, _handle, _oclass,
-		   args->v0.route, args->v0.token, args->v0.object);
-
-	if (!nv_iclass(handle->object, NV_PARENT_CLASS)) {
-		nvif_debug(handle->object, "cannot have children (ctor)\n");
-		ret = -ENODEV;
-		goto fail_class;
-	}
-
-	parent = nv_parent(handle->object);
-
-	/* check that parent supports the requested subclass */
-	ret = nvkm_parent_sclass(&parent->object, _oclass,
-				 (struct nvkm_object **)&engine, &oclass);
-	if (ret) {
-		nvif_debug(&parent->object, "illegal class 0x%04x\n", _oclass);
-		goto fail_class;
-	}
-
-	/* make sure engine init has been completed *before* any objects
-	 * it controls are created - the constructors may depend on
-	 * state calculated at init (ie. default context construction)
-	 */
-	if (engine) {
-		engine = nvkm_engine_ref(engine);
-		if (IS_ERR(engine)) {
-			ret = PTR_ERR(engine);
-			engine = NULL;
-			goto fail_class;
-		}
-	}
-
-	/* if engine requires it, create a context object to insert
-	 * between the parent and its children (eg. PGRAPH context)
-	 */
-	if (engine && engine->cclass) {
-		ret = nvkm_object_old(&parent->object, &engine->subdev.object,
-				      engine->cclass, data, size, &engctx);
-		if (ret)
-			goto fail_engctx;
-	} else {
-		nvkm_object_ref(&parent->object, &engctx);
-	}
-
-	/* finally, create new object and bind it to its handle */
-	ret = nvkm_object_old(engctx, &engine->subdev.object, oclass,
-			      data, size, &object);
-	if (ret)
-		goto fail_ctor;
-
-	object->handle = _handle;
-
-	ret = nvkm_object_inc(object);
-	if (ret)
-		goto fail_init;
-
-	ret = nvkm_handle_create(handle, _handle, object, &handle);
-	if (ret)
-		goto fail_handle;
-
-	ret = nvkm_handle_init(handle);
-	handle->route = args->v0.route;
-	handle->token = args->v0.token;
-	if (ret)
-		nvkm_handle_destroy(handle);
-
-	handle->handle = args->v0.object;
-	nvkm_client_insert(client, handle);
-	client->data = object;
-fail_handle:
-	nvkm_object_dec(object, false);
-fail_init:
-	nvkm_object_ref(NULL, &object);
-fail_ctor:
-	nvkm_object_ref(NULL, &engctx);
-fail_engctx:
-	nvkm_engine_unref(&engine);
-fail_class:
-	return ret;
-}
-
 static int
 nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 {
@@ -209,9 +92,6 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 	struct nvkm_oclass oclass;
 	int ret, i = 0;
 
-	if (parent->oclass)
-		return nvkm_ioctl_new_old(handle, data, size);
-
 	nvif_ioctl(parent, "new size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, true)) {
 		nvif_ioctl(parent, "new vers %d handle %08x class %08x "

commit 8f0649b5c6e70ec18122255690e39f010c12a614
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/fifo: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index 04f1bc2d0f8e..28f9fa289e80 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -25,7 +25,7 @@
 #include <core/client.h>
 #include <core/engine.h>
 #include <core/handle.h>
-#include <core/namedb.h>
+#include <core/parent.h>
 
 #include <nvif/unpack.h>
 #include <nvif/ioctl.h>

commit 24bd0930bedea1182aaadc52757897d2b9b3ca99
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/client: convert to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index b9c813690433..04f1bc2d0f8e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -535,12 +535,12 @@ nvkm_ioctl_path(struct nvkm_client *client, u64 handle, u32 type,
 	else
 		object = client->root;
 	if (unlikely(!object)) {
-		nvif_ioctl(&client->namedb.parent.object, "object not found\n");
+		nvif_ioctl(&client->object, "object not found\n");
 		return -ENOENT;
 	}
 
 	if (owner != NVIF_IOCTL_V0_OWNER_ANY && owner != object->route) {
-		nvif_ioctl(&client->namedb.parent.object, "route != owner\n");
+		nvif_ioctl(&client->object, "route != owner\n");
 		return -EACCES;
 	}
 	*route = object->route;
@@ -558,7 +558,7 @@ int
 nvkm_ioctl(struct nvkm_client *client, bool supervisor,
 	   void *data, u32 size, void **hack)
 {
-	struct nvkm_object *object = &client->namedb.parent.object;
+	struct nvkm_object *object = &client->object;
 	union {
 		struct nvif_ioctl_v0 v0;
 	} *args = data;

commit 524bdbf2025d44cdea672511d21012a52b427374
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/core: prepare for new-style objects
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index d9c26e40ae32..b9c813690433 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -55,34 +55,45 @@ nvkm_ioctl_sclass(struct nvkm_handle *handle, void *data, u32 size)
 	union {
 		struct nvif_ioctl_sclass_v0 v0;
 	} *args = data;
-	int ret;
+	struct nvkm_oclass oclass;
+	int ret, i = 0;
 
 	nvif_ioctl(object, "sclass size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, true)) {
 		nvif_ioctl(object, "sclass vers %d count %d\n",
 			   args->v0.version, args->v0.count);
-		if (size == args->v0.count * sizeof(args->v0.oclass[0])) {
+		if (size != args->v0.count * sizeof(args->v0.oclass[0]))
+			return -EINVAL;
+
+		if (object->oclass) {
 			if (nv_iclass(object, NV_PARENT_CLASS)) {
 				ret = nvkm_parent_lclass(object,
 							 args->v0.oclass,
 							 args->v0.count);
-			} else {
-				ret = 0;
 			}
-			if (ret >= 0) {
-				args->v0.count = ret;
-				ret = 0;
+
+			args->v0.count = ret;
+			return 0;
+		}
+
+		while (object->func->sclass &&
+		       object->func->sclass(object, i, &oclass) >= 0) {
+			if (i < args->v0.count) {
+				args->v0.oclass[i].oclass = oclass.base.oclass;
+				args->v0.oclass[i].minver = oclass.base.minver;
+				args->v0.oclass[i].maxver = oclass.base.maxver;
 			}
-		} else {
-			ret = -EINVAL;
+			i++;
 		}
+
+		args->v0.count = i;
 	}
 
 	return ret;
 }
 
 static int
-nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
+nvkm_ioctl_new_old(struct nvkm_handle *handle, void *data, u32 size)
 {
 	union {
 		struct nvif_ioctl_new_v0 v0;
@@ -152,7 +163,6 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 	/* finally, create new object and bind it to its handle */
 	ret = nvkm_object_old(engctx, &engine->subdev.object, oclass,
 			      data, size, &object);
-	client->data = object;
 	if (ret)
 		goto fail_ctor;
 
@@ -162,8 +172,7 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 	if (ret)
 		goto fail_init;
 
-	ret = nvkm_handle_create(&parent->object, handle->name,
-				 _handle, object, &handle);
+	ret = nvkm_handle_create(handle, _handle, object, &handle);
 	if (ret)
 		goto fail_handle;
 
@@ -175,6 +184,7 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 
 	handle->handle = args->v0.object;
 	nvkm_client_insert(client, handle);
+	client->data = object;
 fail_handle:
 	nvkm_object_dec(object, false);
 fail_init:
@@ -187,6 +197,81 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 	return ret;
 }
 
+static int
+nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
+{
+	union {
+		struct nvif_ioctl_new_v0 v0;
+	} *args = data;
+	struct nvkm_client *client = handle->object->client;
+	struct nvkm_object *parent = handle->object;
+	struct nvkm_object *object = NULL;
+	struct nvkm_oclass oclass;
+	int ret, i = 0;
+
+	if (parent->oclass)
+		return nvkm_ioctl_new_old(handle, data, size);
+
+	nvif_ioctl(parent, "new size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, true)) {
+		nvif_ioctl(parent, "new vers %d handle %08x class %08x "
+				   "route %02x token %llx object %016llx\n",
+			   args->v0.version, args->v0.handle, args->v0.oclass,
+			   args->v0.route, args->v0.token, args->v0.object);
+	} else
+		return ret;
+
+	if (!parent->func->sclass) {
+		nvif_ioctl(parent, "cannot have children\n");
+		return -EINVAL;
+	}
+
+	do {
+		memset(&oclass, 0x00, sizeof(oclass));
+		oclass.client = client;
+		oclass.handle = args->v0.handle;
+		oclass.object = args->v0.object;
+		oclass.parent = parent;
+		ret = parent->func->sclass(parent, i++, &oclass);
+		if (ret)
+			return ret;
+	} while (oclass.base.oclass != args->v0.oclass);
+
+	if (oclass.engine) {
+		oclass.engine = nvkm_engine_ref(oclass.engine);
+		if (IS_ERR(oclass.engine))
+			return PTR_ERR(oclass.engine);
+	}
+
+	ret = oclass.ctor(&oclass, data, size, &object);
+	if (ret)
+		goto fail_object;
+
+	ret = nvkm_object_inc(object);
+	if (ret)
+		goto fail_object;
+
+	ret = nvkm_handle_create(handle, args->v0.handle, object, &handle);
+	if (ret)
+		goto fail_handle;
+
+	ret = nvkm_handle_init(handle);
+	handle->route = args->v0.route;
+	handle->token = args->v0.token;
+	if (ret)
+		nvkm_handle_destroy(handle);
+
+	handle->handle = args->v0.object;
+	nvkm_client_insert(client, handle);
+	client->data = object;
+fail_handle:
+	nvkm_object_dec(object, false);
+fail_object:
+	nvkm_object_ref(NULL, &object);
+	nvkm_engine_unref(&oclass.engine);
+	return ret;
+}
+
 static int
 nvkm_ioctl_del(struct nvkm_handle *handle, void *data, u32 size)
 {

commit 6cf813fb26640ef539051fb7f965af8c9ff10d92
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/device: prepare for new-style subdevs
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index 6e5ff942a6da..d9c26e40ae32 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -91,7 +91,7 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 	struct nvkm_object *engctx = NULL;
 	struct nvkm_object *object = NULL;
 	struct nvkm_parent *parent;
-	struct nvkm_object *engine;
+	struct nvkm_engine *engine;
 	struct nvkm_oclass *oclass;
 	u32 _handle, _oclass;
 	int ret;
@@ -117,7 +117,8 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 	parent = nv_parent(handle->object);
 
 	/* check that parent supports the requested subclass */
-	ret = nvkm_parent_sclass(&parent->object, _oclass, &engine, &oclass);
+	ret = nvkm_parent_sclass(&parent->object, _oclass,
+				 (struct nvkm_object **)&engine, &oclass);
 	if (ret) {
 		nvif_debug(&parent->object, "illegal class 0x%04x\n", _oclass);
 		goto fail_class;
@@ -128,18 +129,20 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 	 * state calculated at init (ie. default context construction)
 	 */
 	if (engine) {
-		ret = nvkm_object_inc(engine);
-		if (ret)
+		engine = nvkm_engine_ref(engine);
+		if (IS_ERR(engine)) {
+			ret = PTR_ERR(engine);
+			engine = NULL;
 			goto fail_class;
+		}
 	}
 
 	/* if engine requires it, create a context object to insert
 	 * between the parent and its children (eg. PGRAPH context)
 	 */
-	if (engine && nv_engine(engine)->cclass) {
-		ret = nvkm_object_old(&parent->object, engine,
-				       nv_engine(engine)->cclass,
-				       data, size, &engctx);
+	if (engine && engine->cclass) {
+		ret = nvkm_object_old(&parent->object, &engine->subdev.object,
+				      engine->cclass, data, size, &engctx);
 		if (ret)
 			goto fail_engctx;
 	} else {
@@ -147,7 +150,8 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 	}
 
 	/* finally, create new object and bind it to its handle */
-	ret = nvkm_object_old(engctx, engine, oclass, data, size, &object);
+	ret = nvkm_object_old(engctx, &engine->subdev.object, oclass,
+			      data, size, &object);
 	client->data = object;
 	if (ret)
 		goto fail_ctor;
@@ -178,8 +182,7 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 fail_ctor:
 	nvkm_object_ref(NULL, &engctx);
 fail_engctx:
-	if (engine)
-		nvkm_object_dec(engine, false);
+	nvkm_engine_unref(&engine);
 fail_class:
 	return ret;
 }

commit cbea21e2ab658ca1256bfe5f4c535b2b1b9e4060
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/object: implement support for new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index 7a15b15bfce0..6e5ff942a6da 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -152,6 +152,8 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 	if (ret)
 		goto fail_ctor;
 
+	object->handle = _handle;
+
 	ret = nvkm_object_inc(object);
 	if (ret)
 		goto fail_init;
@@ -205,7 +207,6 @@ static int
 nvkm_ioctl_mthd(struct nvkm_handle *handle, void *data, u32 size)
 {
 	struct nvkm_object *object = handle->object;
-	struct nvkm_ofuncs *ofuncs = object->oclass->ofuncs;
 	union {
 		struct nvif_ioctl_mthd_v0 v0;
 	} *args = data;
@@ -215,8 +216,7 @@ nvkm_ioctl_mthd(struct nvkm_handle *handle, void *data, u32 size)
 	if (nvif_unpack(args->v0, 0, 0, true)) {
 		nvif_ioctl(object, "mthd vers %d mthd %02x\n",
 			   args->v0.version, args->v0.method);
-		if (ret = -ENODEV, ofuncs->mthd)
-			ret = ofuncs->mthd(object, args->v0.method, data, size);
+		ret = nvkm_object_mthd(object, args->v0.method, data, size);
 	}
 
 	return ret;
@@ -296,7 +296,6 @@ static int
 nvkm_ioctl_map(struct nvkm_handle *handle, void *data, u32 size)
 {
 	struct nvkm_object *object = handle->object;
-	struct nvkm_ofuncs *ofuncs = object->oclass->ofuncs;
 	union {
 		struct nvif_ioctl_map_v0 v0;
 	} *args = data;
@@ -305,10 +304,8 @@ nvkm_ioctl_map(struct nvkm_handle *handle, void *data, u32 size)
 	nvif_ioctl(object, "map size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
 		nvif_ioctl(object, "map vers %d\n", args->v0.version);
-		if (ret = -ENODEV, ofuncs->map) {
-			ret = ofuncs->map(object, &args->v0.handle,
-						  &args->v0.length);
-		}
+		ret = nvkm_object_map(object, &args->v0.handle,
+					      &args->v0.length);
 	}
 
 	return ret;
@@ -335,7 +332,6 @@ static int
 nvkm_ioctl_ntfy_new(struct nvkm_handle *handle, void *data, u32 size)
 {
 	struct nvkm_object *object = handle->object;
-	struct nvkm_ofuncs *ofuncs = object->oclass->ofuncs;
 	union {
 		struct nvif_ioctl_ntfy_new_v0 v0;
 	} *args = data;
@@ -346,8 +342,7 @@ nvkm_ioctl_ntfy_new(struct nvkm_handle *handle, void *data, u32 size)
 	if (nvif_unpack(args->v0, 0, 0, true)) {
 		nvif_ioctl(object, "ntfy new vers %d event %02x\n",
 			   args->v0.version, args->v0.event);
-		if (ret = -ENODEV, ofuncs->ntfy)
-			ret = ofuncs->ntfy(object, args->v0.event, &event);
+		ret = nvkm_object_ntfy(object, args->v0.event, &event);
 		if (ret == 0) {
 			ret = nvkm_client_notify_new(object, event, data, size);
 			if (ret >= 0) {

commit aa35888ff024b18c7b6b29eb773a221f642987f7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/object: rename some functions to avoid upcoming conflicts
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index ee6ff01c2b1b..7a15b15bfce0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -137,7 +137,7 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 	 * between the parent and its children (eg. PGRAPH context)
 	 */
 	if (engine && nv_engine(engine)->cclass) {
-		ret = nvkm_object_ctor(&parent->object, engine,
+		ret = nvkm_object_old(&parent->object, engine,
 				       nv_engine(engine)->cclass,
 				       data, size, &engctx);
 		if (ret)
@@ -147,7 +147,7 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 	}
 
 	/* finally, create new object and bind it to its handle */
-	ret = nvkm_object_ctor(engctx, engine, oclass, data, size, &object);
+	ret = nvkm_object_old(engctx, engine, oclass, data, size, &object);
 	client->data = object;
 	if (ret)
 		goto fail_ctor;

commit 5c15bf709eb6fb52c5bcb95d545250dde22f9625
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/nvif: return success from sclass even for objects without children
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index 629ee56dd8ab..ee6ff01c2b1b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -57,18 +57,18 @@ nvkm_ioctl_sclass(struct nvkm_handle *handle, void *data, u32 size)
 	} *args = data;
 	int ret;
 
-	if (!nv_iclass(object, NV_PARENT_CLASS)) {
-		nvif_debug(object, "cannot have children (sclass)\n");
-		return -ENODEV;
-	}
-
 	nvif_ioctl(object, "sclass size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, true)) {
 		nvif_ioctl(object, "sclass vers %d count %d\n",
 			   args->v0.version, args->v0.count);
 		if (size == args->v0.count * sizeof(args->v0.oclass[0])) {
-			ret = nvkm_parent_lclass(object, args->v0.oclass,
+			if (nv_iclass(object, NV_PARENT_CLASS)) {
+				ret = nvkm_parent_lclass(object,
+							 args->v0.oclass,
 							 args->v0.count);
+			} else {
+				ret = 0;
+			}
 			if (ret >= 0) {
 				args->v0.count = ret;
 				ret = 0;

commit 99d4d36ad673c2b4fea364f6d456718f0f701ce4
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/nvif: extend nop ioctl to return nvif version identifier
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index 7654783e8350..629ee56dd8ab 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -35,13 +35,14 @@ nvkm_ioctl_nop(struct nvkm_handle *handle, void *data, u32 size)
 {
 	struct nvkm_object *object = handle->object;
 	union {
-		struct nvif_ioctl_nop none;
+		struct nvif_ioctl_nop_v0 v0;
 	} *args = data;
 	int ret;
 
 	nvif_ioctl(object, "nop size %d\n", size);
-	if (nvif_unvers(args->none)) {
-		nvif_ioctl(object, "nop\n");
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nvif_ioctl(object, "nop vers %lld\n", args->v0.version);
+		args->v0.version = NVIF_VERSION_LATEST;
 	}
 
 	return ret;

commit bf81df9be28657eea4aca8c6ab4ed3e69f8a051c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/nvif: replace path-based object identification
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index 7434958846f7..7654783e8350 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -103,9 +103,9 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 		return ret;
 
 	nvif_ioctl(handle->object, "new vers %d handle %08x class %08x "
-				   "route %02x token %llx\n",
+				   "route %02x token %llx object %016llx\n",
 		   args->v0.version, _handle, _oclass,
-		   args->v0.route, args->v0.token);
+		   args->v0.route, args->v0.token, args->v0.object);
 
 	if (!nv_iclass(handle->object, NV_PARENT_CLASS)) {
 		nvif_debug(handle->object, "cannot have children (ctor)\n");
@@ -166,6 +166,8 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 	if (ret)
 		nvkm_handle_destroy(handle);
 
+	handle->handle = args->v0.object;
+	nvkm_client_insert(client, handle);
 fail_handle:
 	nvkm_object_dec(object, false);
 fail_init:
@@ -438,40 +440,31 @@ nvkm_ioctl_v0[] = {
 };
 
 static int
-nvkm_ioctl_path(struct nvkm_handle *parent, u32 type, u32 nr, u32 *path,
+nvkm_ioctl_path(struct nvkm_client *client, u64 handle, u32 type,
 		void *data, u32 size, u8 owner, u8 *route, u64 *token)
 {
-	struct nvkm_handle *handle = parent;
-	struct nvkm_namedb *namedb;
-	struct nvkm_object *object;
+	struct nvkm_handle *object;
 	int ret;
 
-	while ((object = parent->object), nr--) {
-		nvif_ioctl(object, "path 0x%08x\n", path[nr]);
-		if (!nv_iclass(object, NV_PARENT_CLASS)) {
-			nvif_debug(object, "cannot have children (path)\n");
-			return -EINVAL;
-		}
-
-		if (!(namedb = (void *)nv_pclass(object, NV_NAMEDB_CLASS)) ||
-		    !(handle = nvkm_namedb_get(namedb, path[nr]))) {
-			nvif_debug(object, "handle 0x%08x not found\n", path[nr]);
-			return -ENOENT;
-		}
-		nvkm_namedb_put(handle);
-		parent = handle;
+	if (handle)
+		object = nvkm_client_search(client, handle);
+	else
+		object = client->root;
+	if (unlikely(!object)) {
+		nvif_ioctl(&client->namedb.parent.object, "object not found\n");
+		return -ENOENT;
 	}
 
-	if (owner != NVIF_IOCTL_V0_OWNER_ANY && owner != handle->route) {
-		nvif_ioctl(object, "object route != owner\n");
+	if (owner != NVIF_IOCTL_V0_OWNER_ANY && owner != object->route) {
+		nvif_ioctl(&client->namedb.parent.object, "route != owner\n");
 		return -EACCES;
 	}
-	*route = handle->route;
-	*token = handle->token;
+	*route = object->route;
+	*token = object->token;
 
 	if (ret = -EINVAL, type < ARRAY_SIZE(nvkm_ioctl_v0)) {
 		if (nvkm_ioctl_v0[type].version == 0)
-			ret = nvkm_ioctl_v0[type].func(handle, data, size);
+			ret = nvkm_ioctl_v0[type].func(object, data, size);
 	}
 
 	return ret;
@@ -491,11 +484,11 @@ nvkm_ioctl(struct nvkm_client *client, bool supervisor,
 	nvif_ioctl(object, "size %d\n", size);
 
 	if (nvif_unpack(args->v0, 0, 0, true)) {
-		nvif_ioctl(object, "vers %d type %02x path %d owner %02x\n",
-			   args->v0.version, args->v0.type, args->v0.path_nr,
+		nvif_ioctl(object,
+			   "vers %d type %02x object %016llx owner %02x\n",
+			   args->v0.version, args->v0.type, args->v0.object,
 			   args->v0.owner);
-		ret = nvkm_ioctl_path(client->root, args->v0.type,
-				      args->v0.path_nr, args->v0.path,
+		ret = nvkm_ioctl_path(client, args->v0.object, args->v0.type,
 				      data, size, args->v0.owner,
 				      &args->v0.route, &args->v0.token);
 	}

commit cfdc4c44b4388bb8e697882cddd966333e4ab7b0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:14 2015 +1000

    drm/nouveau/core: wrap direct use of object accessor functions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index 8a0d291d5f5f..7434958846f7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -224,10 +224,14 @@ static int
 nvkm_ioctl_rd(struct nvkm_handle *handle, void *data, u32 size)
 {
 	struct nvkm_object *object = handle->object;
-	struct nvkm_ofuncs *ofuncs = object->oclass->ofuncs;
 	union {
 		struct nvif_ioctl_rd_v0 v0;
 	} *args = data;
+	union {
+		u8  b08;
+		u16 b16;
+		u32 b32;
+	} v;
 	int ret;
 
 	nvif_ioctl(object, "rd size %d\n", size);
@@ -236,22 +240,16 @@ nvkm_ioctl_rd(struct nvkm_handle *handle, void *data, u32 size)
 			   args->v0.version, args->v0.size, args->v0.addr);
 		switch (args->v0.size) {
 		case 1:
-			if (ret = -ENODEV, ofuncs->rd08) {
-				args->v0.data = nv_ro08(object, args->v0.addr);
-				ret = 0;
-			}
+			ret = nvkm_object_rd08(object, args->v0.addr, &v.b08);
+			args->v0.data = v.b08;
 			break;
 		case 2:
-			if (ret = -ENODEV, ofuncs->rd16) {
-				args->v0.data = nv_ro16(object, args->v0.addr);
-				ret = 0;
-			}
+			ret = nvkm_object_rd16(object, args->v0.addr, &v.b16);
+			args->v0.data = v.b16;
 			break;
 		case 4:
-			if (ret = -ENODEV, ofuncs->rd32) {
-				args->v0.data = nv_ro32(object, args->v0.addr);
-				ret = 0;
-			}
+			ret = nvkm_object_rd32(object, args->v0.addr, &v.b32);
+			args->v0.data = v.b32;
 			break;
 		default:
 			ret = -EINVAL;
@@ -266,7 +264,6 @@ static int
 nvkm_ioctl_wr(struct nvkm_handle *handle, void *data, u32 size)
 {
 	struct nvkm_object *object = handle->object;
-	struct nvkm_ofuncs *ofuncs = object->oclass->ofuncs;
 	union {
 		struct nvif_ioctl_wr_v0 v0;
 	} *args = data;
@@ -278,32 +275,18 @@ nvkm_ioctl_wr(struct nvkm_handle *handle, void *data, u32 size)
 			   "wr vers %d size %d addr %016llx data %08x\n",
 			   args->v0.version, args->v0.size, args->v0.addr,
 			   args->v0.data);
-		switch (args->v0.size) {
-		case 1:
-			if (ret = -ENODEV, ofuncs->wr08) {
-				nv_wo08(object, args->v0.addr, args->v0.data);
-				ret = 0;
-			}
-			break;
-		case 2:
-			if (ret = -ENODEV, ofuncs->wr16) {
-				nv_wo16(object, args->v0.addr, args->v0.data);
-				ret = 0;
-			}
-			break;
-		case 4:
-			if (ret = -ENODEV, ofuncs->wr32) {
-				nv_wo32(object, args->v0.addr, args->v0.data);
-				ret = 0;
-			}
-			break;
-		default:
-			ret = -EINVAL;
-			break;
-		}
+	} else
+		return ret;
+
+	switch (args->v0.size) {
+	case 1: return nvkm_object_wr08(object, args->v0.addr, args->v0.data);
+	case 2: return nvkm_object_wr16(object, args->v0.addr, args->v0.data);
+	case 4: return nvkm_object_wr32(object, args->v0.addr, args->v0.data);
+	default:
+		break;
 	}
 
-	return ret;
+	return -EINVAL;
 }
 
 static int

commit 53003941067534b1071b0f7b71f4700c16d97b28
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:13 2015 +1000

    drm/nouveau/core: remove last printks
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index 4459ff5f4cb8..8a0d291d5f5f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -39,9 +39,9 @@ nvkm_ioctl_nop(struct nvkm_handle *handle, void *data, u32 size)
 	} *args = data;
 	int ret;
 
-	nv_ioctl(object, "nop size %d\n", size);
+	nvif_ioctl(object, "nop size %d\n", size);
 	if (nvif_unvers(args->none)) {
-		nv_ioctl(object, "nop\n");
+		nvif_ioctl(object, "nop\n");
 	}
 
 	return ret;
@@ -57,14 +57,14 @@ nvkm_ioctl_sclass(struct nvkm_handle *handle, void *data, u32 size)
 	int ret;
 
 	if (!nv_iclass(object, NV_PARENT_CLASS)) {
-		nv_debug(object, "cannot have children (sclass)\n");
+		nvif_debug(object, "cannot have children (sclass)\n");
 		return -ENODEV;
 	}
 
-	nv_ioctl(object, "sclass size %d\n", size);
+	nvif_ioctl(object, "sclass size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, true)) {
-		nv_ioctl(object, "sclass vers %d count %d\n",
-			 args->v0.version, args->v0.count);
+		nvif_ioctl(object, "sclass vers %d count %d\n",
+			   args->v0.version, args->v0.count);
 		if (size == args->v0.count * sizeof(args->v0.oclass[0])) {
 			ret = nvkm_parent_lclass(object, args->v0.oclass,
 							 args->v0.count);
@@ -95,20 +95,20 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 	u32 _handle, _oclass;
 	int ret;
 
-	nv_ioctl(client, "new size %d\n", size);
+	nvif_ioctl(handle->object, "new size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, true)) {
 		_handle = args->v0.handle;
 		_oclass = args->v0.oclass;
 	} else
 		return ret;
 
-	nv_ioctl(client, "new vers %d handle %08x class %08x "
-			 "route %02x token %llx\n",
-		 args->v0.version, _handle, _oclass,
-		 args->v0.route, args->v0.token);
+	nvif_ioctl(handle->object, "new vers %d handle %08x class %08x "
+				   "route %02x token %llx\n",
+		   args->v0.version, _handle, _oclass,
+		   args->v0.route, args->v0.token);
 
 	if (!nv_iclass(handle->object, NV_PARENT_CLASS)) {
-		nv_debug(handle->object, "cannot have children (ctor)\n");
+		nvif_debug(handle->object, "cannot have children (ctor)\n");
 		ret = -ENODEV;
 		goto fail_class;
 	}
@@ -118,7 +118,7 @@ nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 	/* check that parent supports the requested subclass */
 	ret = nvkm_parent_sclass(&parent->object, _oclass, &engine, &oclass);
 	if (ret) {
-		nv_debug(parent, "illegal class 0x%04x\n", _oclass);
+		nvif_debug(&parent->object, "illegal class 0x%04x\n", _oclass);
 		goto fail_class;
 	}
 
@@ -188,9 +188,9 @@ nvkm_ioctl_del(struct nvkm_handle *handle, void *data, u32 size)
 	} *args = data;
 	int ret;
 
-	nv_ioctl(object, "delete size %d\n", size);
+	nvif_ioctl(object, "delete size %d\n", size);
 	if (nvif_unvers(args->none)) {
-		nv_ioctl(object, "delete\n");
+		nvif_ioctl(object, "delete\n");
 		nvkm_handle_fini(handle, false);
 		nvkm_handle_destroy(handle);
 	}
@@ -208,10 +208,10 @@ nvkm_ioctl_mthd(struct nvkm_handle *handle, void *data, u32 size)
 	} *args = data;
 	int ret;
 
-	nv_ioctl(object, "mthd size %d\n", size);
+	nvif_ioctl(object, "mthd size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, true)) {
-		nv_ioctl(object, "mthd vers %d mthd %02x\n",
-			 args->v0.version, args->v0.method);
+		nvif_ioctl(object, "mthd vers %d mthd %02x\n",
+			   args->v0.version, args->v0.method);
 		if (ret = -ENODEV, ofuncs->mthd)
 			ret = ofuncs->mthd(object, args->v0.method, data, size);
 	}
@@ -230,10 +230,10 @@ nvkm_ioctl_rd(struct nvkm_handle *handle, void *data, u32 size)
 	} *args = data;
 	int ret;
 
-	nv_ioctl(object, "rd size %d\n", size);
+	nvif_ioctl(object, "rd size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(object, "rd vers %d size %d addr %016llx\n",
-			 args->v0.version, args->v0.size, args->v0.addr);
+		nvif_ioctl(object, "rd vers %d size %d addr %016llx\n",
+			   args->v0.version, args->v0.size, args->v0.addr);
 		switch (args->v0.size) {
 		case 1:
 			if (ret = -ENODEV, ofuncs->rd08) {
@@ -272,11 +272,12 @@ nvkm_ioctl_wr(struct nvkm_handle *handle, void *data, u32 size)
 	} *args = data;
 	int ret;
 
-	nv_ioctl(object, "wr size %d\n", size);
+	nvif_ioctl(object, "wr size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(object, "wr vers %d size %d addr %016llx data %08x\n",
-			 args->v0.version, args->v0.size, args->v0.addr,
-			 args->v0.data);
+		nvif_ioctl(object,
+			   "wr vers %d size %d addr %016llx data %08x\n",
+			   args->v0.version, args->v0.size, args->v0.addr,
+			   args->v0.data);
 		switch (args->v0.size) {
 		case 1:
 			if (ret = -ENODEV, ofuncs->wr08) {
@@ -315,9 +316,9 @@ nvkm_ioctl_map(struct nvkm_handle *handle, void *data, u32 size)
 	} *args = data;
 	int ret;
 
-	nv_ioctl(object, "map size %d\n", size);
+	nvif_ioctl(object, "map size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(object, "map vers %d\n", args->v0.version);
+		nvif_ioctl(object, "map vers %d\n", args->v0.version);
 		if (ret = -ENODEV, ofuncs->map) {
 			ret = ofuncs->map(object, &args->v0.handle,
 						  &args->v0.length);
@@ -336,9 +337,9 @@ nvkm_ioctl_unmap(struct nvkm_handle *handle, void *data, u32 size)
 	} *args = data;
 	int ret;
 
-	nv_ioctl(object, "unmap size %d\n", size);
+	nvif_ioctl(object, "unmap size %d\n", size);
 	if (nvif_unvers(args->none)) {
-		nv_ioctl(object, "unmap\n");
+		nvif_ioctl(object, "unmap\n");
 	}
 
 	return ret;
@@ -355,10 +356,10 @@ nvkm_ioctl_ntfy_new(struct nvkm_handle *handle, void *data, u32 size)
 	struct nvkm_event *event;
 	int ret;
 
-	nv_ioctl(object, "ntfy new size %d\n", size);
+	nvif_ioctl(object, "ntfy new size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, true)) {
-		nv_ioctl(object, "ntfy new vers %d event %02x\n",
-			 args->v0.version, args->v0.event);
+		nvif_ioctl(object, "ntfy new vers %d event %02x\n",
+			   args->v0.version, args->v0.event);
 		if (ret = -ENODEV, ofuncs->ntfy)
 			ret = ofuncs->ntfy(object, args->v0.event, &event);
 		if (ret == 0) {
@@ -383,10 +384,10 @@ nvkm_ioctl_ntfy_del(struct nvkm_handle *handle, void *data, u32 size)
 	} *args = data;
 	int ret;
 
-	nv_ioctl(object, "ntfy del size %d\n", size);
+	nvif_ioctl(object, "ntfy del size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(object, "ntfy del vers %d index %d\n",
-			 args->v0.version, args->v0.index);
+		nvif_ioctl(object, "ntfy del vers %d index %d\n",
+			   args->v0.version, args->v0.index);
 		ret = nvkm_client_notify_del(client, args->v0.index);
 	}
 
@@ -403,10 +404,10 @@ nvkm_ioctl_ntfy_get(struct nvkm_handle *handle, void *data, u32 size)
 	} *args = data;
 	int ret;
 
-	nv_ioctl(object, "ntfy get size %d\n", size);
+	nvif_ioctl(object, "ntfy get size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(object, "ntfy get vers %d index %d\n",
-			 args->v0.version, args->v0.index);
+		nvif_ioctl(object, "ntfy get vers %d index %d\n",
+			   args->v0.version, args->v0.index);
 		ret = nvkm_client_notify_get(client, args->v0.index);
 	}
 
@@ -423,10 +424,10 @@ nvkm_ioctl_ntfy_put(struct nvkm_handle *handle, void *data, u32 size)
 	} *args = data;
 	int ret;
 
-	nv_ioctl(object, "ntfy put size %d\n", size);
+	nvif_ioctl(object, "ntfy put size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(object, "ntfy put vers %d index %d\n",
-			 args->v0.version, args->v0.index);
+		nvif_ioctl(object, "ntfy put vers %d index %d\n",
+			   args->v0.version, args->v0.index);
 		ret = nvkm_client_notify_put(client, args->v0.index);
 	}
 
@@ -463,15 +464,15 @@ nvkm_ioctl_path(struct nvkm_handle *parent, u32 type, u32 nr, u32 *path,
 	int ret;
 
 	while ((object = parent->object), nr--) {
-		nv_ioctl(object, "path 0x%08x\n", path[nr]);
+		nvif_ioctl(object, "path 0x%08x\n", path[nr]);
 		if (!nv_iclass(object, NV_PARENT_CLASS)) {
-			nv_debug(object, "cannot have children (path)\n");
+			nvif_debug(object, "cannot have children (path)\n");
 			return -EINVAL;
 		}
 
 		if (!(namedb = (void *)nv_pclass(object, NV_NAMEDB_CLASS)) ||
 		    !(handle = nvkm_namedb_get(namedb, path[nr]))) {
-			nv_debug(object, "handle 0x%08x not found\n", path[nr]);
+			nvif_debug(object, "handle 0x%08x not found\n", path[nr]);
 			return -ENOENT;
 		}
 		nvkm_namedb_put(handle);
@@ -479,7 +480,7 @@ nvkm_ioctl_path(struct nvkm_handle *parent, u32 type, u32 nr, u32 *path,
 	}
 
 	if (owner != NVIF_IOCTL_V0_OWNER_ANY && owner != handle->route) {
-		nv_ioctl(object, "object route != owner\n");
+		nvif_ioctl(object, "object route != owner\n");
 		return -EACCES;
 	}
 	*route = handle->route;
@@ -497,25 +498,26 @@ int
 nvkm_ioctl(struct nvkm_client *client, bool supervisor,
 	   void *data, u32 size, void **hack)
 {
+	struct nvkm_object *object = &client->namedb.parent.object;
 	union {
 		struct nvif_ioctl_v0 v0;
 	} *args = data;
 	int ret;
 
 	client->super = supervisor;
-	nv_ioctl(client, "size %d\n", size);
+	nvif_ioctl(object, "size %d\n", size);
 
 	if (nvif_unpack(args->v0, 0, 0, true)) {
-		nv_ioctl(client, "vers %d type %02x path %d owner %02x\n",
-			 args->v0.version, args->v0.type, args->v0.path_nr,
-			 args->v0.owner);
+		nvif_ioctl(object, "vers %d type %02x path %d owner %02x\n",
+			   args->v0.version, args->v0.type, args->v0.path_nr,
+			   args->v0.owner);
 		ret = nvkm_ioctl_path(client->root, args->v0.type,
 				      args->v0.path_nr, args->v0.path,
 				      data, size, args->v0.owner,
 				      &args->v0.route, &args->v0.token);
 	}
 
-	nv_ioctl(client, "return %d\n", ret);
+	nvif_ioctl(object, "return %d\n", ret);
 	if (hack) {
 		*hack = client->data;
 		client->data = NULL;

commit 5025407b9862349d17b1dff25737aaef6520a439
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 14:11:21 2015 +1000

    drm/nouveau/core: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
index bdfabb4a8dc9..4459ff5f4cb8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -21,23 +21,19 @@
  *
  * Authors: Ben Skeggs <bskeggs@redhat.com>
  */
-
-#include <core/object.h>
-#include <core/parent.h>
+#include <core/ioctl.h>
+#include <core/client.h>
+#include <core/engine.h>
 #include <core/handle.h>
 #include <core/namedb.h>
-#include <core/client.h>
-#include <core/device.h>
-#include <core/ioctl.h>
-#include <core/event.h>
 
 #include <nvif/unpack.h>
 #include <nvif/ioctl.h>
 
 static int
-nvkm_ioctl_nop(struct nouveau_handle *handle, void *data, u32 size)
+nvkm_ioctl_nop(struct nvkm_handle *handle, void *data, u32 size)
 {
-	struct nouveau_object *object = handle->object;
+	struct nvkm_object *object = handle->object;
 	union {
 		struct nvif_ioctl_nop none;
 	} *args = data;
@@ -52,9 +48,9 @@ nvkm_ioctl_nop(struct nouveau_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_sclass(struct nouveau_handle *handle, void *data, u32 size)
+nvkm_ioctl_sclass(struct nvkm_handle *handle, void *data, u32 size)
 {
-	struct nouveau_object *object = handle->object;
+	struct nvkm_object *object = handle->object;
 	union {
 		struct nvif_ioctl_sclass_v0 v0;
 	} *args = data;
@@ -70,8 +66,8 @@ nvkm_ioctl_sclass(struct nouveau_handle *handle, void *data, u32 size)
 		nv_ioctl(object, "sclass vers %d count %d\n",
 			 args->v0.version, args->v0.count);
 		if (size == args->v0.count * sizeof(args->v0.oclass[0])) {
-			ret = nouveau_parent_lclass(object, args->v0.oclass,
-							    args->v0.count);
+			ret = nvkm_parent_lclass(object, args->v0.oclass,
+							 args->v0.count);
 			if (ret >= 0) {
 				args->v0.count = ret;
 				ret = 0;
@@ -85,17 +81,17 @@ nvkm_ioctl_sclass(struct nouveau_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_new(struct nouveau_handle *handle, void *data, u32 size)
+nvkm_ioctl_new(struct nvkm_handle *handle, void *data, u32 size)
 {
 	union {
 		struct nvif_ioctl_new_v0 v0;
 	} *args = data;
-	struct nouveau_client *client = nouveau_client(handle->object);
-	struct nouveau_object *engctx = NULL;
-	struct nouveau_object *object = NULL;
-	struct nouveau_parent *parent;
-	struct nouveau_object *engine;
-	struct nouveau_oclass *oclass;
+	struct nvkm_client *client = nvkm_client(handle->object);
+	struct nvkm_object *engctx = NULL;
+	struct nvkm_object *object = NULL;
+	struct nvkm_parent *parent;
+	struct nvkm_object *engine;
+	struct nvkm_oclass *oclass;
 	u32 _handle, _oclass;
 	int ret;
 
@@ -108,8 +104,8 @@ nvkm_ioctl_new(struct nouveau_handle *handle, void *data, u32 size)
 
 	nv_ioctl(client, "new vers %d handle %08x class %08x "
 			 "route %02x token %llx\n",
-		args->v0.version, _handle, _oclass,
-		args->v0.route, args->v0.token);
+		 args->v0.version, _handle, _oclass,
+		 args->v0.route, args->v0.token);
 
 	if (!nv_iclass(handle->object, NV_PARENT_CLASS)) {
 		nv_debug(handle->object, "cannot have children (ctor)\n");
@@ -120,7 +116,7 @@ nvkm_ioctl_new(struct nouveau_handle *handle, void *data, u32 size)
 	parent = nv_parent(handle->object);
 
 	/* check that parent supports the requested subclass */
-	ret = nouveau_parent_sclass(&parent->object, _oclass, &engine, &oclass);
+	ret = nvkm_parent_sclass(&parent->object, _oclass, &engine, &oclass);
 	if (ret) {
 		nv_debug(parent, "illegal class 0x%04x\n", _oclass);
 		goto fail_class;
@@ -131,7 +127,7 @@ nvkm_ioctl_new(struct nouveau_handle *handle, void *data, u32 size)
 	 * state calculated at init (ie. default context construction)
 	 */
 	if (engine) {
-		ret = nouveau_object_inc(engine);
+		ret = nvkm_object_inc(engine);
 		if (ret)
 			goto fail_class;
 	}
@@ -140,53 +136,53 @@ nvkm_ioctl_new(struct nouveau_handle *handle, void *data, u32 size)
 	 * between the parent and its children (eg. PGRAPH context)
 	 */
 	if (engine && nv_engine(engine)->cclass) {
-		ret = nouveau_object_ctor(&parent->object, engine,
-					  nv_engine(engine)->cclass,
-					  data, size, &engctx);
+		ret = nvkm_object_ctor(&parent->object, engine,
+				       nv_engine(engine)->cclass,
+				       data, size, &engctx);
 		if (ret)
 			goto fail_engctx;
 	} else {
-		nouveau_object_ref(&parent->object, &engctx);
+		nvkm_object_ref(&parent->object, &engctx);
 	}
 
 	/* finally, create new object and bind it to its handle */
-	ret = nouveau_object_ctor(engctx, engine, oclass, data, size, &object);
+	ret = nvkm_object_ctor(engctx, engine, oclass, data, size, &object);
 	client->data = object;
 	if (ret)
 		goto fail_ctor;
 
-	ret = nouveau_object_inc(object);
+	ret = nvkm_object_inc(object);
 	if (ret)
 		goto fail_init;
 
-	ret = nouveau_handle_create(&parent->object, handle->name,
-				    _handle, object, &handle);
+	ret = nvkm_handle_create(&parent->object, handle->name,
+				 _handle, object, &handle);
 	if (ret)
 		goto fail_handle;
 
-	ret = nouveau_handle_init(handle);
+	ret = nvkm_handle_init(handle);
 	handle->route = args->v0.route;
 	handle->token = args->v0.token;
 	if (ret)
-		nouveau_handle_destroy(handle);
+		nvkm_handle_destroy(handle);
 
 fail_handle:
-	nouveau_object_dec(object, false);
+	nvkm_object_dec(object, false);
 fail_init:
-	nouveau_object_ref(NULL, &object);
+	nvkm_object_ref(NULL, &object);
 fail_ctor:
-	nouveau_object_ref(NULL, &engctx);
+	nvkm_object_ref(NULL, &engctx);
 fail_engctx:
 	if (engine)
-		nouveau_object_dec(engine, false);
+		nvkm_object_dec(engine, false);
 fail_class:
 	return ret;
 }
 
 static int
-nvkm_ioctl_del(struct nouveau_handle *handle, void *data, u32 size)
+nvkm_ioctl_del(struct nvkm_handle *handle, void *data, u32 size)
 {
-	struct nouveau_object *object = handle->object;
+	struct nvkm_object *object = handle->object;
 	union {
 		struct nvif_ioctl_del none;
 	} *args = data;
@@ -195,18 +191,18 @@ nvkm_ioctl_del(struct nouveau_handle *handle, void *data, u32 size)
 	nv_ioctl(object, "delete size %d\n", size);
 	if (nvif_unvers(args->none)) {
 		nv_ioctl(object, "delete\n");
-		nouveau_handle_fini(handle, false);
-		nouveau_handle_destroy(handle);
+		nvkm_handle_fini(handle, false);
+		nvkm_handle_destroy(handle);
 	}
 
 	return ret;
 }
 
 static int
-nvkm_ioctl_mthd(struct nouveau_handle *handle, void *data, u32 size)
+nvkm_ioctl_mthd(struct nvkm_handle *handle, void *data, u32 size)
 {
-	struct nouveau_object *object = handle->object;
-	struct nouveau_ofuncs *ofuncs = object->oclass->ofuncs;
+	struct nvkm_object *object = handle->object;
+	struct nvkm_ofuncs *ofuncs = object->oclass->ofuncs;
 	union {
 		struct nvif_ioctl_mthd_v0 v0;
 	} *args = data;
@@ -225,10 +221,10 @@ nvkm_ioctl_mthd(struct nouveau_handle *handle, void *data, u32 size)
 
 
 static int
-nvkm_ioctl_rd(struct nouveau_handle *handle, void *data, u32 size)
+nvkm_ioctl_rd(struct nvkm_handle *handle, void *data, u32 size)
 {
-	struct nouveau_object *object = handle->object;
-	struct nouveau_ofuncs *ofuncs = object->oclass->ofuncs;
+	struct nvkm_object *object = handle->object;
+	struct nvkm_ofuncs *ofuncs = object->oclass->ofuncs;
 	union {
 		struct nvif_ioctl_rd_v0 v0;
 	} *args = data;
@@ -237,7 +233,7 @@ nvkm_ioctl_rd(struct nouveau_handle *handle, void *data, u32 size)
 	nv_ioctl(object, "rd size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
 		nv_ioctl(object, "rd vers %d size %d addr %016llx\n",
-			args->v0.version, args->v0.size, args->v0.addr);
+			 args->v0.version, args->v0.size, args->v0.addr);
 		switch (args->v0.size) {
 		case 1:
 			if (ret = -ENODEV, ofuncs->rd08) {
@@ -267,10 +263,10 @@ nvkm_ioctl_rd(struct nouveau_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_wr(struct nouveau_handle *handle, void *data, u32 size)
+nvkm_ioctl_wr(struct nvkm_handle *handle, void *data, u32 size)
 {
-	struct nouveau_object *object = handle->object;
-	struct nouveau_ofuncs *ofuncs = object->oclass->ofuncs;
+	struct nvkm_object *object = handle->object;
+	struct nvkm_ofuncs *ofuncs = object->oclass->ofuncs;
 	union {
 		struct nvif_ioctl_wr_v0 v0;
 	} *args = data;
@@ -310,10 +306,10 @@ nvkm_ioctl_wr(struct nouveau_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_map(struct nouveau_handle *handle, void *data, u32 size)
+nvkm_ioctl_map(struct nvkm_handle *handle, void *data, u32 size)
 {
-	struct nouveau_object *object = handle->object;
-	struct nouveau_ofuncs *ofuncs = object->oclass->ofuncs;
+	struct nvkm_object *object = handle->object;
+	struct nvkm_ofuncs *ofuncs = object->oclass->ofuncs;
 	union {
 		struct nvif_ioctl_map_v0 v0;
 	} *args = data;
@@ -332,9 +328,9 @@ nvkm_ioctl_map(struct nouveau_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_unmap(struct nouveau_handle *handle, void *data, u32 size)
+nvkm_ioctl_unmap(struct nvkm_handle *handle, void *data, u32 size)
 {
-	struct nouveau_object *object = handle->object;
+	struct nvkm_object *object = handle->object;
 	union {
 		struct nvif_ioctl_unmap none;
 	} *args = data;
@@ -349,10 +345,10 @@ nvkm_ioctl_unmap(struct nouveau_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_ntfy_new(struct nouveau_handle *handle, void *data, u32 size)
+nvkm_ioctl_ntfy_new(struct nvkm_handle *handle, void *data, u32 size)
 {
-	struct nouveau_object *object = handle->object;
-	struct nouveau_ofuncs *ofuncs = object->oclass->ofuncs;
+	struct nvkm_object *object = handle->object;
+	struct nvkm_ofuncs *ofuncs = object->oclass->ofuncs;
 	union {
 		struct nvif_ioctl_ntfy_new_v0 v0;
 	} *args = data;
@@ -378,10 +374,10 @@ nvkm_ioctl_ntfy_new(struct nouveau_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_ntfy_del(struct nouveau_handle *handle, void *data, u32 size)
+nvkm_ioctl_ntfy_del(struct nvkm_handle *handle, void *data, u32 size)
 {
-	struct nouveau_client *client = nouveau_client(handle->object);
-	struct nouveau_object *object = handle->object;
+	struct nvkm_client *client = nvkm_client(handle->object);
+	struct nvkm_object *object = handle->object;
 	union {
 		struct nvif_ioctl_ntfy_del_v0 v0;
 	} *args = data;
@@ -398,10 +394,10 @@ nvkm_ioctl_ntfy_del(struct nouveau_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_ntfy_get(struct nouveau_handle *handle, void *data, u32 size)
+nvkm_ioctl_ntfy_get(struct nvkm_handle *handle, void *data, u32 size)
 {
-	struct nouveau_client *client = nouveau_client(handle->object);
-	struct nouveau_object *object = handle->object;
+	struct nvkm_client *client = nvkm_client(handle->object);
+	struct nvkm_object *object = handle->object;
 	union {
 		struct nvif_ioctl_ntfy_get_v0 v0;
 	} *args = data;
@@ -418,10 +414,10 @@ nvkm_ioctl_ntfy_get(struct nouveau_handle *handle, void *data, u32 size)
 }
 
 static int
-nvkm_ioctl_ntfy_put(struct nouveau_handle *handle, void *data, u32 size)
+nvkm_ioctl_ntfy_put(struct nvkm_handle *handle, void *data, u32 size)
 {
-	struct nouveau_client *client = nouveau_client(handle->object);
-	struct nouveau_object *object = handle->object;
+	struct nvkm_client *client = nvkm_client(handle->object);
+	struct nvkm_object *object = handle->object;
 	union {
 		struct nvif_ioctl_ntfy_put_v0 v0;
 	} *args = data;
@@ -439,7 +435,7 @@ nvkm_ioctl_ntfy_put(struct nouveau_handle *handle, void *data, u32 size)
 
 static struct {
 	int version;
-	int (*func)(struct nouveau_handle *, void *, u32);
+	int (*func)(struct nvkm_handle *, void *, u32);
 }
 nvkm_ioctl_v0[] = {
 	{ 0x00, nvkm_ioctl_nop },
@@ -458,13 +454,12 @@ nvkm_ioctl_v0[] = {
 };
 
 static int
-nvkm_ioctl_path(struct nouveau_handle *parent, u32 type, u32 nr,
-		  u32 *path, void *data, u32 size,
-		  u8 owner, u8 *route, u64 *token)
+nvkm_ioctl_path(struct nvkm_handle *parent, u32 type, u32 nr, u32 *path,
+		void *data, u32 size, u8 owner, u8 *route, u64 *token)
 {
-	struct nouveau_handle *handle = parent;
-	struct nouveau_namedb *namedb;
-	struct nouveau_object *object;
+	struct nvkm_handle *handle = parent;
+	struct nvkm_namedb *namedb;
+	struct nvkm_object *object;
 	int ret;
 
 	while ((object = parent->object), nr--) {
@@ -475,16 +470,15 @@ nvkm_ioctl_path(struct nouveau_handle *parent, u32 type, u32 nr,
 		}
 
 		if (!(namedb = (void *)nv_pclass(object, NV_NAMEDB_CLASS)) ||
-		    !(handle = nouveau_namedb_get(namedb, path[nr]))) {
+		    !(handle = nvkm_namedb_get(namedb, path[nr]))) {
 			nv_debug(object, "handle 0x%08x not found\n", path[nr]);
 			return -ENOENT;
 		}
-		nouveau_namedb_put(handle);
+		nvkm_namedb_put(handle);
 		parent = handle;
 	}
 
-	if (owner != NVIF_IOCTL_V0_OWNER_ANY &&
-	    owner != handle->route) {
+	if (owner != NVIF_IOCTL_V0_OWNER_ANY && owner != handle->route) {
 		nv_ioctl(object, "object route != owner\n");
 		return -EACCES;
 	}
@@ -492,16 +486,15 @@ nvkm_ioctl_path(struct nouveau_handle *parent, u32 type, u32 nr,
 	*token = handle->token;
 
 	if (ret = -EINVAL, type < ARRAY_SIZE(nvkm_ioctl_v0)) {
-		if (nvkm_ioctl_v0[type].version == 0) {
+		if (nvkm_ioctl_v0[type].version == 0)
 			ret = nvkm_ioctl_v0[type].func(handle, data, size);
-		}
 	}
 
 	return ret;
 }
 
 int
-nvkm_ioctl(struct nouveau_client *client, bool supervisor,
+nvkm_ioctl(struct nvkm_client *client, bool supervisor,
 	   void *data, u32 size, void **hack)
 {
 	union {
@@ -519,7 +512,7 @@ nvkm_ioctl(struct nouveau_client *client, bool supervisor,
 		ret = nvkm_ioctl_path(client->root, args->v0.type,
 				      args->v0.path_nr, args->v0.path,
 				      data, size, args->v0.owner,
-				     &args->v0.route, &args->v0.token);
+				      &args->v0.route, &args->v0.token);
 	}
 
 	nv_ioctl(client, "return %d\n", ret);
@@ -527,6 +520,7 @@ nvkm_ioctl(struct nouveau_client *client, bool supervisor,
 		*hack = client->data;
 		client->data = NULL;
 	}
+
 	client->super = false;
 	return ret;
 }

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
new file mode 100644
index 000000000000..bdfabb4a8dc9
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c
@@ -0,0 +1,532 @@
+/*
+ * Copyright 2014 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs <bskeggs@redhat.com>
+ */
+
+#include <core/object.h>
+#include <core/parent.h>
+#include <core/handle.h>
+#include <core/namedb.h>
+#include <core/client.h>
+#include <core/device.h>
+#include <core/ioctl.h>
+#include <core/event.h>
+
+#include <nvif/unpack.h>
+#include <nvif/ioctl.h>
+
+static int
+nvkm_ioctl_nop(struct nouveau_handle *handle, void *data, u32 size)
+{
+	struct nouveau_object *object = handle->object;
+	union {
+		struct nvif_ioctl_nop none;
+	} *args = data;
+	int ret;
+
+	nv_ioctl(object, "nop size %d\n", size);
+	if (nvif_unvers(args->none)) {
+		nv_ioctl(object, "nop\n");
+	}
+
+	return ret;
+}
+
+static int
+nvkm_ioctl_sclass(struct nouveau_handle *handle, void *data, u32 size)
+{
+	struct nouveau_object *object = handle->object;
+	union {
+		struct nvif_ioctl_sclass_v0 v0;
+	} *args = data;
+	int ret;
+
+	if (!nv_iclass(object, NV_PARENT_CLASS)) {
+		nv_debug(object, "cannot have children (sclass)\n");
+		return -ENODEV;
+	}
+
+	nv_ioctl(object, "sclass size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, true)) {
+		nv_ioctl(object, "sclass vers %d count %d\n",
+			 args->v0.version, args->v0.count);
+		if (size == args->v0.count * sizeof(args->v0.oclass[0])) {
+			ret = nouveau_parent_lclass(object, args->v0.oclass,
+							    args->v0.count);
+			if (ret >= 0) {
+				args->v0.count = ret;
+				ret = 0;
+			}
+		} else {
+			ret = -EINVAL;
+		}
+	}
+
+	return ret;
+}
+
+static int
+nvkm_ioctl_new(struct nouveau_handle *handle, void *data, u32 size)
+{
+	union {
+		struct nvif_ioctl_new_v0 v0;
+	} *args = data;
+	struct nouveau_client *client = nouveau_client(handle->object);
+	struct nouveau_object *engctx = NULL;
+	struct nouveau_object *object = NULL;
+	struct nouveau_parent *parent;
+	struct nouveau_object *engine;
+	struct nouveau_oclass *oclass;
+	u32 _handle, _oclass;
+	int ret;
+
+	nv_ioctl(client, "new size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, true)) {
+		_handle = args->v0.handle;
+		_oclass = args->v0.oclass;
+	} else
+		return ret;
+
+	nv_ioctl(client, "new vers %d handle %08x class %08x "
+			 "route %02x token %llx\n",
+		args->v0.version, _handle, _oclass,
+		args->v0.route, args->v0.token);
+
+	if (!nv_iclass(handle->object, NV_PARENT_CLASS)) {
+		nv_debug(handle->object, "cannot have children (ctor)\n");
+		ret = -ENODEV;
+		goto fail_class;
+	}
+
+	parent = nv_parent(handle->object);
+
+	/* check that parent supports the requested subclass */
+	ret = nouveau_parent_sclass(&parent->object, _oclass, &engine, &oclass);
+	if (ret) {
+		nv_debug(parent, "illegal class 0x%04x\n", _oclass);
+		goto fail_class;
+	}
+
+	/* make sure engine init has been completed *before* any objects
+	 * it controls are created - the constructors may depend on
+	 * state calculated at init (ie. default context construction)
+	 */
+	if (engine) {
+		ret = nouveau_object_inc(engine);
+		if (ret)
+			goto fail_class;
+	}
+
+	/* if engine requires it, create a context object to insert
+	 * between the parent and its children (eg. PGRAPH context)
+	 */
+	if (engine && nv_engine(engine)->cclass) {
+		ret = nouveau_object_ctor(&parent->object, engine,
+					  nv_engine(engine)->cclass,
+					  data, size, &engctx);
+		if (ret)
+			goto fail_engctx;
+	} else {
+		nouveau_object_ref(&parent->object, &engctx);
+	}
+
+	/* finally, create new object and bind it to its handle */
+	ret = nouveau_object_ctor(engctx, engine, oclass, data, size, &object);
+	client->data = object;
+	if (ret)
+		goto fail_ctor;
+
+	ret = nouveau_object_inc(object);
+	if (ret)
+		goto fail_init;
+
+	ret = nouveau_handle_create(&parent->object, handle->name,
+				    _handle, object, &handle);
+	if (ret)
+		goto fail_handle;
+
+	ret = nouveau_handle_init(handle);
+	handle->route = args->v0.route;
+	handle->token = args->v0.token;
+	if (ret)
+		nouveau_handle_destroy(handle);
+
+fail_handle:
+	nouveau_object_dec(object, false);
+fail_init:
+	nouveau_object_ref(NULL, &object);
+fail_ctor:
+	nouveau_object_ref(NULL, &engctx);
+fail_engctx:
+	if (engine)
+		nouveau_object_dec(engine, false);
+fail_class:
+	return ret;
+}
+
+static int
+nvkm_ioctl_del(struct nouveau_handle *handle, void *data, u32 size)
+{
+	struct nouveau_object *object = handle->object;
+	union {
+		struct nvif_ioctl_del none;
+	} *args = data;
+	int ret;
+
+	nv_ioctl(object, "delete size %d\n", size);
+	if (nvif_unvers(args->none)) {
+		nv_ioctl(object, "delete\n");
+		nouveau_handle_fini(handle, false);
+		nouveau_handle_destroy(handle);
+	}
+
+	return ret;
+}
+
+static int
+nvkm_ioctl_mthd(struct nouveau_handle *handle, void *data, u32 size)
+{
+	struct nouveau_object *object = handle->object;
+	struct nouveau_ofuncs *ofuncs = object->oclass->ofuncs;
+	union {
+		struct nvif_ioctl_mthd_v0 v0;
+	} *args = data;
+	int ret;
+
+	nv_ioctl(object, "mthd size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, true)) {
+		nv_ioctl(object, "mthd vers %d mthd %02x\n",
+			 args->v0.version, args->v0.method);
+		if (ret = -ENODEV, ofuncs->mthd)
+			ret = ofuncs->mthd(object, args->v0.method, data, size);
+	}
+
+	return ret;
+}
+
+
+static int
+nvkm_ioctl_rd(struct nouveau_handle *handle, void *data, u32 size)
+{
+	struct nouveau_object *object = handle->object;
+	struct nouveau_ofuncs *ofuncs = object->oclass->ofuncs;
+	union {
+		struct nvif_ioctl_rd_v0 v0;
+	} *args = data;
+	int ret;
+
+	nv_ioctl(object, "rd size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(object, "rd vers %d size %d addr %016llx\n",
+			args->v0.version, args->v0.size, args->v0.addr);
+		switch (args->v0.size) {
+		case 1:
+			if (ret = -ENODEV, ofuncs->rd08) {
+				args->v0.data = nv_ro08(object, args->v0.addr);
+				ret = 0;
+			}
+			break;
+		case 2:
+			if (ret = -ENODEV, ofuncs->rd16) {
+				args->v0.data = nv_ro16(object, args->v0.addr);
+				ret = 0;
+			}
+			break;
+		case 4:
+			if (ret = -ENODEV, ofuncs->rd32) {
+				args->v0.data = nv_ro32(object, args->v0.addr);
+				ret = 0;
+			}
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int
+nvkm_ioctl_wr(struct nouveau_handle *handle, void *data, u32 size)
+{
+	struct nouveau_object *object = handle->object;
+	struct nouveau_ofuncs *ofuncs = object->oclass->ofuncs;
+	union {
+		struct nvif_ioctl_wr_v0 v0;
+	} *args = data;
+	int ret;
+
+	nv_ioctl(object, "wr size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(object, "wr vers %d size %d addr %016llx data %08x\n",
+			 args->v0.version, args->v0.size, args->v0.addr,
+			 args->v0.data);
+		switch (args->v0.size) {
+		case 1:
+			if (ret = -ENODEV, ofuncs->wr08) {
+				nv_wo08(object, args->v0.addr, args->v0.data);
+				ret = 0;
+			}
+			break;
+		case 2:
+			if (ret = -ENODEV, ofuncs->wr16) {
+				nv_wo16(object, args->v0.addr, args->v0.data);
+				ret = 0;
+			}
+			break;
+		case 4:
+			if (ret = -ENODEV, ofuncs->wr32) {
+				nv_wo32(object, args->v0.addr, args->v0.data);
+				ret = 0;
+			}
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int
+nvkm_ioctl_map(struct nouveau_handle *handle, void *data, u32 size)
+{
+	struct nouveau_object *object = handle->object;
+	struct nouveau_ofuncs *ofuncs = object->oclass->ofuncs;
+	union {
+		struct nvif_ioctl_map_v0 v0;
+	} *args = data;
+	int ret;
+
+	nv_ioctl(object, "map size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(object, "map vers %d\n", args->v0.version);
+		if (ret = -ENODEV, ofuncs->map) {
+			ret = ofuncs->map(object, &args->v0.handle,
+						  &args->v0.length);
+		}
+	}
+
+	return ret;
+}
+
+static int
+nvkm_ioctl_unmap(struct nouveau_handle *handle, void *data, u32 size)
+{
+	struct nouveau_object *object = handle->object;
+	union {
+		struct nvif_ioctl_unmap none;
+	} *args = data;
+	int ret;
+
+	nv_ioctl(object, "unmap size %d\n", size);
+	if (nvif_unvers(args->none)) {
+		nv_ioctl(object, "unmap\n");
+	}
+
+	return ret;
+}
+
+static int
+nvkm_ioctl_ntfy_new(struct nouveau_handle *handle, void *data, u32 size)
+{
+	struct nouveau_object *object = handle->object;
+	struct nouveau_ofuncs *ofuncs = object->oclass->ofuncs;
+	union {
+		struct nvif_ioctl_ntfy_new_v0 v0;
+	} *args = data;
+	struct nvkm_event *event;
+	int ret;
+
+	nv_ioctl(object, "ntfy new size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, true)) {
+		nv_ioctl(object, "ntfy new vers %d event %02x\n",
+			 args->v0.version, args->v0.event);
+		if (ret = -ENODEV, ofuncs->ntfy)
+			ret = ofuncs->ntfy(object, args->v0.event, &event);
+		if (ret == 0) {
+			ret = nvkm_client_notify_new(object, event, data, size);
+			if (ret >= 0) {
+				args->v0.index = ret;
+				ret = 0;
+			}
+		}
+	}
+
+	return ret;
+}
+
+static int
+nvkm_ioctl_ntfy_del(struct nouveau_handle *handle, void *data, u32 size)
+{
+	struct nouveau_client *client = nouveau_client(handle->object);
+	struct nouveau_object *object = handle->object;
+	union {
+		struct nvif_ioctl_ntfy_del_v0 v0;
+	} *args = data;
+	int ret;
+
+	nv_ioctl(object, "ntfy del size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(object, "ntfy del vers %d index %d\n",
+			 args->v0.version, args->v0.index);
+		ret = nvkm_client_notify_del(client, args->v0.index);
+	}
+
+	return ret;
+}
+
+static int
+nvkm_ioctl_ntfy_get(struct nouveau_handle *handle, void *data, u32 size)
+{
+	struct nouveau_client *client = nouveau_client(handle->object);
+	struct nouveau_object *object = handle->object;
+	union {
+		struct nvif_ioctl_ntfy_get_v0 v0;
+	} *args = data;
+	int ret;
+
+	nv_ioctl(object, "ntfy get size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(object, "ntfy get vers %d index %d\n",
+			 args->v0.version, args->v0.index);
+		ret = nvkm_client_notify_get(client, args->v0.index);
+	}
+
+	return ret;
+}
+
+static int
+nvkm_ioctl_ntfy_put(struct nouveau_handle *handle, void *data, u32 size)
+{
+	struct nouveau_client *client = nouveau_client(handle->object);
+	struct nouveau_object *object = handle->object;
+	union {
+		struct nvif_ioctl_ntfy_put_v0 v0;
+	} *args = data;
+	int ret;
+
+	nv_ioctl(object, "ntfy put size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(object, "ntfy put vers %d index %d\n",
+			 args->v0.version, args->v0.index);
+		ret = nvkm_client_notify_put(client, args->v0.index);
+	}
+
+	return ret;
+}
+
+static struct {
+	int version;
+	int (*func)(struct nouveau_handle *, void *, u32);
+}
+nvkm_ioctl_v0[] = {
+	{ 0x00, nvkm_ioctl_nop },
+	{ 0x00, nvkm_ioctl_sclass },
+	{ 0x00, nvkm_ioctl_new },
+	{ 0x00, nvkm_ioctl_del },
+	{ 0x00, nvkm_ioctl_mthd },
+	{ 0x00, nvkm_ioctl_rd },
+	{ 0x00, nvkm_ioctl_wr },
+	{ 0x00, nvkm_ioctl_map },
+	{ 0x00, nvkm_ioctl_unmap },
+	{ 0x00, nvkm_ioctl_ntfy_new },
+	{ 0x00, nvkm_ioctl_ntfy_del },
+	{ 0x00, nvkm_ioctl_ntfy_get },
+	{ 0x00, nvkm_ioctl_ntfy_put },
+};
+
+static int
+nvkm_ioctl_path(struct nouveau_handle *parent, u32 type, u32 nr,
+		  u32 *path, void *data, u32 size,
+		  u8 owner, u8 *route, u64 *token)
+{
+	struct nouveau_handle *handle = parent;
+	struct nouveau_namedb *namedb;
+	struct nouveau_object *object;
+	int ret;
+
+	while ((object = parent->object), nr--) {
+		nv_ioctl(object, "path 0x%08x\n", path[nr]);
+		if (!nv_iclass(object, NV_PARENT_CLASS)) {
+			nv_debug(object, "cannot have children (path)\n");
+			return -EINVAL;
+		}
+
+		if (!(namedb = (void *)nv_pclass(object, NV_NAMEDB_CLASS)) ||
+		    !(handle = nouveau_namedb_get(namedb, path[nr]))) {
+			nv_debug(object, "handle 0x%08x not found\n", path[nr]);
+			return -ENOENT;
+		}
+		nouveau_namedb_put(handle);
+		parent = handle;
+	}
+
+	if (owner != NVIF_IOCTL_V0_OWNER_ANY &&
+	    owner != handle->route) {
+		nv_ioctl(object, "object route != owner\n");
+		return -EACCES;
+	}
+	*route = handle->route;
+	*token = handle->token;
+
+	if (ret = -EINVAL, type < ARRAY_SIZE(nvkm_ioctl_v0)) {
+		if (nvkm_ioctl_v0[type].version == 0) {
+			ret = nvkm_ioctl_v0[type].func(handle, data, size);
+		}
+	}
+
+	return ret;
+}
+
+int
+nvkm_ioctl(struct nouveau_client *client, bool supervisor,
+	   void *data, u32 size, void **hack)
+{
+	union {
+		struct nvif_ioctl_v0 v0;
+	} *args = data;
+	int ret;
+
+	client->super = supervisor;
+	nv_ioctl(client, "size %d\n", size);
+
+	if (nvif_unpack(args->v0, 0, 0, true)) {
+		nv_ioctl(client, "vers %d type %02x path %d owner %02x\n",
+			 args->v0.version, args->v0.type, args->v0.path_nr,
+			 args->v0.owner);
+		ret = nvkm_ioctl_path(client->root, args->v0.type,
+				      args->v0.path_nr, args->v0.path,
+				      data, size, args->v0.owner,
+				     &args->v0.route, &args->v0.token);
+	}
+
+	nv_ioctl(client, "return %d\n", ret);
+	if (hack) {
+		*hack = client->data;
+		client->data = NULL;
+	}
+	client->super = false;
+	return ret;
+}
