commit 8e0042d505e86299544cf000e26408bdd252e36b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/core/object: plumb the unmap ioctl through
    
    MMU will be using this for BAR mappings.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/object.c b/drivers/gpu/drm/nouveau/nvkm/core/object.c
index 516e73a52665..301a5e5b5f7f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/object.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/object.c
@@ -110,6 +110,14 @@ nvkm_object_map(struct nvkm_object *object, void *argv, u32 argc,
 	return -ENODEV;
 }
 
+int
+nvkm_object_unmap(struct nvkm_object *object)
+{
+	if (likely(object->func->unmap))
+		return object->func->unmap(object);
+	return -ENODEV;
+}
+
 int
 nvkm_object_rd08(struct nvkm_object *object, u64 addr, u8 *data)
 {
@@ -260,6 +268,7 @@ nvkm_object_dtor(struct nvkm_object *object)
 	}
 
 	nvif_debug(object, "destroy running...\n");
+	nvkm_object_unmap(object);
 	if (object->func->dtor)
 		data = object->func->dtor(object);
 	nvkm_engine_unref(&object->engine);

commit 01326050391ceee2cf1b6c91c108414a35f40861
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/core/object: allow arguments to be passed to map function
    
    MMU will be needing this to specify kind info on BAR mappings.
    
    We have no userspace currently using these interfaces, so break the ABI
    instead of supporting both.  NVIF version bump so any future use can be
    guarded.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/object.c b/drivers/gpu/drm/nouveau/nvkm/core/object.c
index acd76fd4f6d8..516e73a52665 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/object.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/object.c
@@ -102,10 +102,11 @@ nvkm_object_ntfy(struct nvkm_object *object, u32 mthd,
 }
 
 int
-nvkm_object_map(struct nvkm_object *object, u64 *addr, u32 *size)
+nvkm_object_map(struct nvkm_object *object, void *argv, u32 argc,
+		enum nvkm_object_map *type, u64 *addr, u64 *size)
 {
 	if (likely(object->func->map))
-		return object->func->map(object, addr, size);
+		return object->func->map(object, argv, argc, type, addr, size);
 	return -ENODEV;
 }
 

commit 89ed10a5721d569b053a8355c1a6bd812fed7c29
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu May 4 17:29:03 2017 +1000

    drm/nouveau/core: fix static checker warning
    
    object->engine cannot be NULL, it's either valid, or an error pointer.
    
    This particular condition shouldn't actually be possible, but just in
    case, we'll keep it.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/object.c b/drivers/gpu/drm/nouveau/nvkm/core/object.c
index 89d2e9da11c7..acd76fd4f6d8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/object.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/object.c
@@ -295,7 +295,7 @@ nvkm_object_ctor(const struct nvkm_object_func *func,
 	INIT_LIST_HEAD(&object->head);
 	INIT_LIST_HEAD(&object->tree);
 	RB_CLEAR_NODE(&object->node);
-	WARN_ON(oclass->engine && !object->engine);
+	WARN_ON(IS_ERR(object->engine));
 }
 
 int

commit 843faa030c3677080e4a108889dccb21798b2a32
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed May 25 17:47:18 2016 +1000

    drm/nouveau/core/object: pass more args in oclass
    
    The fields were already in struct nvkm_oclass for some reason (probably
    as an accidental left-over).
    
    Preparation for supporting subclients.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/object.c b/drivers/gpu/drm/nouveau/nvkm/core/object.c
index 218f932b1022..89d2e9da11c7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/object.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/object.c
@@ -289,6 +289,9 @@ nvkm_object_ctor(const struct nvkm_object_func *func,
 	object->engine = nvkm_engine_ref(oclass->engine);
 	object->oclass = oclass->base.oclass;
 	object->handle = oclass->handle;
+	object->route  = oclass->route;
+	object->token  = oclass->token;
+	object->object = oclass->object;
 	INIT_LIST_HEAD(&object->head);
 	INIT_LIST_HEAD(&object->tree);
 	RB_CLEAR_NODE(&object->node);

commit 110cccff955313c66dccd2817f62368f106d9bf2
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Dec 22 15:22:25 2016 +1000

    drm/nouveau/core/object: support lookup of specific object types
    
    It turns out we have a nice and convenient way of looking up a specific
    object type already, by using the func pointer as a key.
    
    This will be used to remove the separate object trees for each type we
    need to be able to search for.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/object.c b/drivers/gpu/drm/nouveau/nvkm/core/object.c
index 67aa7223dcd7..218f932b1022 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/object.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/object.c
@@ -25,6 +25,65 @@
 #include <core/client.h>
 #include <core/engine.h>
 
+struct nvkm_object *
+nvkm_object_search(struct nvkm_client *client, u64 handle,
+		   const struct nvkm_object_func *func)
+{
+	struct nvkm_object *object;
+
+	if (handle) {
+		struct rb_node *node = client->objroot.rb_node;
+		while (node) {
+			object = rb_entry(node, typeof(*object), node);
+			if (handle < object->object)
+				node = node->rb_left;
+			else
+			if (handle > object->object)
+				node = node->rb_right;
+			else
+				goto done;
+		}
+		return ERR_PTR(-ENOENT);
+	} else {
+		object = &client->object;
+	}
+
+done:
+	if (unlikely(func && object->func != func))
+		return ERR_PTR(-EINVAL);
+	return object;
+}
+
+void
+nvkm_object_remove(struct nvkm_object *object)
+{
+	if (!RB_EMPTY_NODE(&object->node))
+		rb_erase(&object->node, &object->client->objroot);
+}
+
+bool
+nvkm_object_insert(struct nvkm_object *object)
+{
+	struct rb_node **ptr = &object->client->objroot.rb_node;
+	struct rb_node *parent = NULL;
+
+	while (*ptr) {
+		struct nvkm_object *this = rb_entry(*ptr, typeof(*this), node);
+		parent = *ptr;
+		if (object->object < this->object)
+			ptr = &parent->rb_left;
+		else
+		if (object->object > this->object)
+			ptr = &parent->rb_right;
+		else
+			return false;
+	}
+
+	rb_link_node(&object->node, parent, ptr);
+	rb_insert_color(&object->node, &object->client->objroot);
+	return true;
+}
+
 int
 nvkm_object_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
@@ -214,7 +273,7 @@ nvkm_object_del(struct nvkm_object **pobject)
 	struct nvkm_object *object = *pobject;
 	if (object && !WARN_ON(!object->func)) {
 		*pobject = nvkm_object_dtor(object);
-		nvkm_client_remove(object->client, object);
+		nvkm_object_remove(object);
 		list_del(&object->head);
 		kfree(*pobject);
 		*pobject = NULL;

commit fbd58ebda9c8572ca6285b88e3348c7712f125ec
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/object: merge with handle
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/object.c b/drivers/gpu/drm/nouveau/nvkm/core/object.c
index 8976526b1c8f..67aa7223dcd7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/object.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/object.c
@@ -22,6 +22,7 @@
  * Authors: Ben Skeggs
  */
 #include <core/object.h>
+#include <core/client.h>
 #include <core/engine.h>
 
 int
@@ -109,28 +110,112 @@ nvkm_object_bind(struct nvkm_object *object, struct nvkm_gpuobj *gpuobj,
 int
 nvkm_object_fini(struct nvkm_object *object, bool suspend)
 {
-	if (object->func->fini)
-		return object->func->fini(object, suspend);
+	const char *action = suspend ? "suspend" : "fini";
+	struct nvkm_object *child;
+	s64 time;
+	int ret;
+
+	nvif_debug(object, "%s children...\n", action);
+	time = ktime_to_us(ktime_get());
+	list_for_each_entry(child, &object->tree, head) {
+		ret = nvkm_object_fini(child, suspend);
+		if (ret && suspend)
+			goto fail_child;
+	}
+
+	nvif_debug(object, "%s running...\n", action);
+	if (object->func->fini) {
+		ret = object->func->fini(object, suspend);
+		if (ret) {
+			nvif_error(object, "%s failed with %d\n", action, ret);
+			if (suspend)
+				goto fail;
+		}
+	}
+
+	time = ktime_to_us(ktime_get()) - time;
+	nvif_debug(object, "%s completed in %lldus\n", action, time);
 	return 0;
+
+fail:
+	if (object->func->init) {
+		int rret = object->func->init(object);
+		if (rret)
+			nvif_fatal(object, "failed to restart, %d\n", rret);
+	}
+fail_child:
+	list_for_each_entry_continue_reverse(child, &object->tree, head) {
+		nvkm_object_init(child);
+	}
+	return ret;
 }
 
 int
 nvkm_object_init(struct nvkm_object *object)
 {
-	if (object->func->init)
-		return object->func->init(object);
+	struct nvkm_object *child;
+	s64 time;
+	int ret;
+
+	nvif_debug(object, "init running...\n");
+	time = ktime_to_us(ktime_get());
+	if (object->func->init) {
+		ret = object->func->init(object);
+		if (ret)
+			goto fail;
+	}
+
+	nvif_debug(object, "init children...\n");
+	list_for_each_entry(child, &object->tree, head) {
+		ret = nvkm_object_init(child);
+		if (ret)
+			goto fail_child;
+	}
+
+	time = ktime_to_us(ktime_get()) - time;
+	nvif_debug(object, "init completed in %lldus\n", time);
 	return 0;
+
+fail_child:
+	list_for_each_entry_continue_reverse(child, &object->tree, head)
+		nvkm_object_fini(child, false);
+fail:
+	nvif_error(object, "init failed with %d\n", ret);
+	if (object->func->fini)
+		object->func->fini(object, false);
+	return ret;
 }
 
-static void
+void *
+nvkm_object_dtor(struct nvkm_object *object)
+{
+	struct nvkm_object *child, *ctemp;
+	void *data = object;
+	s64 time;
+
+	nvif_debug(object, "destroy children...\n");
+	time = ktime_to_us(ktime_get());
+	list_for_each_entry_safe(child, ctemp, &object->tree, head) {
+		nvkm_object_del(&child);
+	}
+
+	nvif_debug(object, "destroy running...\n");
+	if (object->func->dtor)
+		data = object->func->dtor(object);
+	nvkm_engine_unref(&object->engine);
+	time = ktime_to_us(ktime_get()) - time;
+	nvif_debug(object, "destroy completed in %lldus...\n", time);
+	return data;
+}
+
+void
 nvkm_object_del(struct nvkm_object **pobject)
 {
 	struct nvkm_object *object = *pobject;
-
 	if (object && !WARN_ON(!object->func)) {
-		if (object->func->dtor)
-			*pobject = object->func->dtor(object);
-		nvkm_engine_unref(&object->engine);
+		*pobject = nvkm_object_dtor(object);
+		nvkm_client_remove(object->client, object);
+		list_del(&object->head);
 		kfree(*pobject);
 		*pobject = NULL;
 	}
@@ -145,9 +230,10 @@ nvkm_object_ctor(const struct nvkm_object_func *func,
 	object->engine = nvkm_engine_ref(oclass->engine);
 	object->oclass = oclass->base.oclass;
 	object->handle = oclass->handle;
-	object->parent = oclass->parent;
-	atomic_set(&object->refcount, 1);
-	atomic_set(&object->usecount, 0);
+	INIT_LIST_HEAD(&object->head);
+	INIT_LIST_HEAD(&object->tree);
+	RB_CLEAR_NODE(&object->node);
+	WARN_ON(oclass->engine && !object->engine);
 }
 
 int
@@ -176,106 +262,3 @@ nvkm_object_new(const struct nvkm_oclass *oclass, void *data, u32 size,
 		oclass->base.func ? oclass->base.func : &nvkm_object_func;
 	return nvkm_object_new_(func, oclass, data, size, pobject);
 }
-
-void
-nvkm_object_ref(struct nvkm_object *obj, struct nvkm_object **ref)
-{
-	if (obj) {
-		atomic_inc(&obj->refcount);
-	}
-
-	if (*ref) {
-		int dead = atomic_dec_and_test(&(*ref)->refcount);
-		if (dead)
-			nvkm_object_del(ref);
-	}
-
-	*ref = obj;
-}
-
-int
-nvkm_object_inc(struct nvkm_object *object)
-{
-	int ref = atomic_add_return(1, &object->usecount);
-	int ret;
-
-	if (ref != 1)
-		return 0;
-
-	if (object->parent) {
-		ret = nvkm_object_inc(object->parent);
-		if (ret)
-			goto fail_parent;
-	}
-
-	ret = nvkm_object_init(object);
-	atomic_set(&object->usecount, 1);
-	if (ret)
-		goto fail_self;
-
-	return 0;
-
-fail_self:
-	if (object->parent)
-		 nvkm_object_dec(object->parent, false);
-fail_parent:
-	atomic_dec(&object->usecount);
-	return ret;
-}
-
-static int
-nvkm_object_decf(struct nvkm_object *object)
-{
-	nvkm_object_fini(object, false);
-	atomic_set(&object->usecount, 0);
-
-	if (object->parent)
-		nvkm_object_dec(object->parent, false);
-
-	return 0;
-}
-
-static int
-nvkm_object_decs(struct nvkm_object *object)
-{
-	int ret;
-
-	ret = nvkm_object_fini(object, true);
-	atomic_set(&object->usecount, 0);
-	if (ret)
-		return ret;
-
-	if (object->parent) {
-		ret = nvkm_object_dec(object->parent, true);
-		if (ret)
-			goto fail_parent;
-	}
-
-	return 0;
-
-fail_parent:
-	nvkm_object_init(object);
-
-	return ret;
-}
-
-int
-nvkm_object_dec(struct nvkm_object *object, bool suspend)
-{
-	int ref = atomic_add_return(-1, &object->usecount);
-	int ret;
-
-	if (ref == 0) {
-		if (suspend)
-			ret = nvkm_object_decs(object);
-		else
-			ret = nvkm_object_decf(object);
-
-		if (ret) {
-			atomic_inc(&object->usecount);
-			return ret;
-		}
-	}
-
-	return 0;
-}

commit 68f3f702b6a430a8d1e909455a60d26c0f2da530
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/core: remove the remainder of the previous style
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/object.c b/drivers/gpu/drm/nouveau/nvkm/core/object.c
index 0680eae072cf..8976526b1c8f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/object.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/object.c
@@ -27,11 +27,6 @@
 int
 nvkm_object_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
-	if (object->oclass) {
-		if (object->oclass->ofuncs->mthd)
-			return object->oclass->ofuncs->mthd(object, mthd, data, size);
-		return -ENODEV;
-	}
 	if (likely(object->func->mthd))
 		return object->func->mthd(object, mthd, data, size);
 	return -ENODEV;
@@ -41,11 +36,6 @@ int
 nvkm_object_ntfy(struct nvkm_object *object, u32 mthd,
 		 struct nvkm_event **pevent)
 {
-	if (object->oclass) {
-		if (object->oclass->ofuncs->ntfy)
-			return object->oclass->ofuncs->ntfy(object, mthd, pevent);
-		return -ENODEV;
-	}
 	if (likely(object->func->ntfy))
 		return object->func->ntfy(object, mthd, pevent);
 	return -ENODEV;
@@ -54,11 +44,6 @@ nvkm_object_ntfy(struct nvkm_object *object, u32 mthd,
 int
 nvkm_object_map(struct nvkm_object *object, u64 *addr, u32 *size)
 {
-	if (object->oclass) {
-		if (object->oclass->ofuncs->map)
-			return object->oclass->ofuncs->map(object, addr, size);
-		return -ENODEV;
-	}
 	if (likely(object->func->map))
 		return object->func->map(object, addr, size);
 	return -ENODEV;
@@ -67,14 +52,6 @@ nvkm_object_map(struct nvkm_object *object, u64 *addr, u32 *size)
 int
 nvkm_object_rd08(struct nvkm_object *object, u64 addr, u8 *data)
 {
-	if (object->oclass) {
-		if (object->oclass->ofuncs->rd08) {
-			*data = object->oclass->ofuncs->rd08(object, addr);
-			return 0;
-		}
-		*data = 0x00;
-		return -ENODEV;
-	}
 	if (likely(object->func->rd08))
 		return object->func->rd08(object, addr, data);
 	return -ENODEV;
@@ -83,14 +60,6 @@ nvkm_object_rd08(struct nvkm_object *object, u64 addr, u8 *data)
 int
 nvkm_object_rd16(struct nvkm_object *object, u64 addr, u16 *data)
 {
-	if (object->oclass) {
-		if (object->oclass->ofuncs->rd16) {
-			*data = object->oclass->ofuncs->rd16(object, addr);
-			return 0;
-		}
-		*data = 0x0000;
-		return -ENODEV;
-	}
 	if (likely(object->func->rd16))
 		return object->func->rd16(object, addr, data);
 	return -ENODEV;
@@ -99,14 +68,6 @@ nvkm_object_rd16(struct nvkm_object *object, u64 addr, u16 *data)
 int
 nvkm_object_rd32(struct nvkm_object *object, u64 addr, u32 *data)
 {
-	if (object->oclass) {
-		if (object->oclass->ofuncs->rd32) {
-			*data = object->oclass->ofuncs->rd32(object, addr);
-			return 0;
-		}
-		*data = 0x00000000;
-		return -ENODEV;
-	}
 	if (likely(object->func->rd32))
 		return object->func->rd32(object, addr, data);
 	return -ENODEV;
@@ -115,13 +76,6 @@ nvkm_object_rd32(struct nvkm_object *object, u64 addr, u32 *data)
 int
 nvkm_object_wr08(struct nvkm_object *object, u64 addr, u8 data)
 {
-	if (object->oclass) {
-		if (object->oclass->ofuncs->wr08) {
-			object->oclass->ofuncs->wr08(object, addr, data);
-			return 0;
-		}
-		return -ENODEV;
-	}
 	if (likely(object->func->wr08))
 		return object->func->wr08(object, addr, data);
 	return -ENODEV;
@@ -130,13 +84,6 @@ nvkm_object_wr08(struct nvkm_object *object, u64 addr, u8 data)
 int
 nvkm_object_wr16(struct nvkm_object *object, u64 addr, u16 data)
 {
-	if (object->oclass) {
-		if (object->oclass->ofuncs->wr16) {
-			object->oclass->ofuncs->wr16(object, addr, data);
-			return 0;
-		}
-		return -ENODEV;
-	}
 	if (likely(object->func->wr16))
 		return object->func->wr16(object, addr, data);
 	return -ENODEV;
@@ -145,13 +92,6 @@ nvkm_object_wr16(struct nvkm_object *object, u64 addr, u16 data)
 int
 nvkm_object_wr32(struct nvkm_object *object, u64 addr, u32 data)
 {
-	if (object->oclass) {
-		if (object->oclass->ofuncs->wr32) {
-			object->oclass->ofuncs->wr32(object, addr, data);
-			return 0;
-		}
-		return -ENODEV;
-	}
 	if (likely(object->func->wr32))
 		return object->func->wr32(object, addr, data);
 	return -ENODEV;
@@ -161,8 +101,6 @@ int
 nvkm_object_bind(struct nvkm_object *object, struct nvkm_gpuobj *gpuobj,
 		 int align, struct nvkm_gpuobj **pgpuobj)
 {
-	if (object->oclass)
-		return -ENODEV;
 	if (object->func->bind)
 		return object->func->bind(object, gpuobj, align, pgpuobj);
 	return -ENODEV;
@@ -171,8 +109,6 @@ nvkm_object_bind(struct nvkm_object *object, struct nvkm_gpuobj *gpuobj,
 int
 nvkm_object_fini(struct nvkm_object *object, bool suspend)
 {
-	if (object->oclass)
-		return object->oclass->ofuncs->fini(object, suspend);
 	if (object->func->fini)
 		return object->func->fini(object, suspend);
 	return 0;
@@ -181,8 +117,6 @@ nvkm_object_fini(struct nvkm_object *object, bool suspend)
 int
 nvkm_object_init(struct nvkm_object *object)
 {
-	if (object->oclass)
-		return object->oclass->ofuncs->init(object);
 	if (object->func->init)
 		return object->func->init(object);
 	return 0;
@@ -193,11 +127,6 @@ nvkm_object_del(struct nvkm_object **pobject)
 {
 	struct nvkm_object *object = *pobject;
 
-	if (object && object->oclass) {
-		object->oclass->ofuncs->dtor(object);
-		return;
-	}
-
 	if (object && !WARN_ON(!object->func)) {
 		if (object->func->dtor)
 			*pobject = object->func->dtor(object);
@@ -214,14 +143,11 @@ nvkm_object_ctor(const struct nvkm_object_func *func,
 	object->func = func;
 	object->client = oclass->client;
 	object->engine = nvkm_engine_ref(oclass->engine);
-	object->oclass_name = oclass->base.oclass;
+	object->oclass = oclass->base.oclass;
 	object->handle = oclass->handle;
 	object->parent = oclass->parent;
 	atomic_set(&object->refcount, 1);
 	atomic_set(&object->usecount, 0);
-#ifdef NVKM_OBJECT_MAGIC
-	object->_magic = NVKM_OBJECT_MAGIC;
-#endif
 }
 
 int
@@ -251,97 +177,6 @@ nvkm_object_new(const struct nvkm_oclass *oclass, void *data, u32 size,
 	return nvkm_object_new_(func, oclass, data, size, pobject);
 }
 
-int
-nvkm_object_create_(struct nvkm_object *parent, struct nvkm_object *engobj,
-		    struct nvkm_oclass *oclass, u32 pclass,
-		    int size, void **pobject)
-{
-	struct nvkm_engine *engine = engobj ? nv_engine(engobj) : NULL;
-	struct nvkm_object *object;
-
-	object = *pobject = kzalloc(size, GFP_KERNEL);
-	if (!object)
-		return -ENOMEM;
-
-	nvkm_object_ref(parent, &object->parent);
-	object->engine = nvkm_engine_ref(engine);
-	object->oclass = oclass;
-	object->pclass = pclass;
-	atomic_set(&object->refcount, 1);
-	atomic_set(&object->usecount, 0);
-
-#ifdef NVKM_OBJECT_MAGIC
-	object->_magic = NVKM_OBJECT_MAGIC;
-#endif
-	return 0;
-}
-
-int
-_nvkm_object_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-		  struct nvkm_oclass *oclass, void *data, u32 size,
-		  struct nvkm_object **pobject)
-{
-	if (size != 0)
-		return -ENOSYS;
-	return nvkm_object_create(parent, engine, oclass, 0, pobject);
-}
-
-void
-nvkm_object_destroy(struct nvkm_object *object)
-{
-	nvkm_engine_unref(&object->engine);
-	nvkm_object_ref(NULL, &object->parent);
-	kfree(object);
-}
-
-int
-_nvkm_object_init(struct nvkm_object *object)
-{
-	return 0;
-}
-
-int
-_nvkm_object_fini(struct nvkm_object *object, bool suspend)
-{
-	return 0;
-}
-
-struct nvkm_ofuncs
-nvkm_object_ofuncs = {
-	.ctor = _nvkm_object_ctor,
-	.dtor = nvkm_object_destroy,
-	.init = _nvkm_object_init,
-	.fini = _nvkm_object_fini,
-};
-
-int
-nvkm_object_old(struct nvkm_object *parent, struct nvkm_object *engine,
-		 struct nvkm_oclass *oclass, void *data, u32 size,
-		 struct nvkm_object **pobject)
-{
-	struct nvkm_ofuncs *ofuncs = oclass->ofuncs;
-	struct nvkm_object *object = NULL;
-	int ret;
-
-	ret = ofuncs->ctor(parent, engine, oclass, data, size, &object);
-	*pobject = object;
-	if (ret < 0) {
-		if (object) {
-			ofuncs->dtor(object);
-			*pobject = NULL;
-		}
-
-		return ret;
-	}
-
-	if (ret == 0) {
-		if (!nv_iclass(object, NV_SUBDEV_CLASS))
-			atomic_set(&object->refcount, 1);
-	}
-
-	return 0;
-}
-
 void
 nvkm_object_ref(struct nvkm_object *obj, struct nvkm_object **ref)
 {

commit 6cf813fb26640ef539051fb7f965af8c9ff10d92
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/device: prepare for new-style subdevs
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/object.c b/drivers/gpu/drm/nouveau/nvkm/core/object.c
index 0abee7816874..0680eae072cf 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/object.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/object.c
@@ -201,6 +201,7 @@ nvkm_object_del(struct nvkm_object **pobject)
 	if (object && !WARN_ON(!object->func)) {
 		if (object->func->dtor)
 			*pobject = object->func->dtor(object);
+		nvkm_engine_unref(&object->engine);
 		kfree(*pobject);
 		*pobject = NULL;
 	}
@@ -212,7 +213,7 @@ nvkm_object_ctor(const struct nvkm_object_func *func,
 {
 	object->func = func;
 	object->client = oclass->client;
-	object->engine = oclass->engine;
+	object->engine = nvkm_engine_ref(oclass->engine);
 	object->oclass_name = oclass->base.oclass;
 	object->handle = oclass->handle;
 	object->parent = oclass->parent;
@@ -251,10 +252,11 @@ nvkm_object_new(const struct nvkm_oclass *oclass, void *data, u32 size,
 }
 
 int
-nvkm_object_create_(struct nvkm_object *parent, struct nvkm_object *engine,
+nvkm_object_create_(struct nvkm_object *parent, struct nvkm_object *engobj,
 		    struct nvkm_oclass *oclass, u32 pclass,
 		    int size, void **pobject)
 {
+	struct nvkm_engine *engine = engobj ? nv_engine(engobj) : NULL;
 	struct nvkm_object *object;
 
 	object = *pobject = kzalloc(size, GFP_KERNEL);
@@ -262,7 +264,7 @@ nvkm_object_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		return -ENOMEM;
 
 	nvkm_object_ref(parent, &object->parent);
-	nvkm_object_ref(engine, (struct nvkm_object **)&object->engine);
+	object->engine = nvkm_engine_ref(engine);
 	object->oclass = oclass;
 	object->pclass = pclass;
 	atomic_set(&object->refcount, 1);
@@ -287,7 +289,7 @@ _nvkm_object_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 void
 nvkm_object_destroy(struct nvkm_object *object)
 {
-	nvkm_object_ref(NULL, (struct nvkm_object **)&object->engine);
+	nvkm_engine_unref(&object->engine);
 	nvkm_object_ref(NULL, &object->parent);
 	kfree(object);
 }
@@ -333,7 +335,8 @@ nvkm_object_old(struct nvkm_object *parent, struct nvkm_object *engine,
 	}
 
 	if (ret == 0) {
-		atomic_set(&object->refcount, 1);
+		if (!nv_iclass(object, NV_SUBDEV_CLASS))
+			atomic_set(&object->refcount, 1);
 	}
 
 	return 0;
@@ -370,14 +373,6 @@ nvkm_object_inc(struct nvkm_object *object)
 			goto fail_parent;
 	}
 
-	if (object->engine) {
-		mutex_lock(&nv_subdev(object->engine)->mutex);
-		ret = nvkm_object_inc(&object->engine->subdev.object);
-		mutex_unlock(&nv_subdev(object->engine)->mutex);
-		if (ret)
-			goto fail_engine;
-	}
-
 	ret = nvkm_object_init(object);
 	atomic_set(&object->usecount, 1);
 	if (ret)
@@ -386,12 +381,6 @@ nvkm_object_inc(struct nvkm_object *object)
 	return 0;
 
 fail_self:
-	if (object->engine) {
-		mutex_lock(&nv_subdev(object->engine)->mutex);
-		nvkm_object_dec(&object->engine->subdev.object, false);
-		mutex_unlock(&nv_subdev(object->engine)->mutex);
-	}
-fail_engine:
 	if (object->parent)
 		 nvkm_object_dec(object->parent, false);
 fail_parent:
@@ -405,12 +394,6 @@ nvkm_object_decf(struct nvkm_object *object)
 	nvkm_object_fini(object, false);
 	atomic_set(&object->usecount, 0);
 
-	if (object->engine) {
-		mutex_lock(&nv_subdev(object->engine)->mutex);
-		nvkm_object_dec(&object->engine->subdev.object, false);
-		mutex_unlock(&nv_subdev(object->engine)->mutex);
-	}
-
 	if (object->parent)
 		nvkm_object_dec(object->parent, false);
 
@@ -427,14 +410,6 @@ nvkm_object_decs(struct nvkm_object *object)
 	if (ret)
 		return ret;
 
-	if (object->engine) {
-		mutex_lock(&nv_subdev(object->engine)->mutex);
-		ret = nvkm_object_dec(&object->engine->subdev.object, true);
-		mutex_unlock(&nv_subdev(object->engine)->mutex);
-		if (ret)
-			goto fail_engine;
-	}
-
 	if (object->parent) {
 		ret = nvkm_object_dec(object->parent, true);
 		if (ret)
@@ -444,13 +419,6 @@ nvkm_object_decs(struct nvkm_object *object)
 	return 0;
 
 fail_parent:
-	if (object->engine) {
-		mutex_lock(&nv_subdev(object->engine)->mutex);
-		nvkm_object_inc(&object->engine->subdev.object);
-		mutex_unlock(&nv_subdev(object->engine)->mutex);
-	}
-
-fail_engine:
 	nvkm_object_init(object);
 
 	return ret;

commit cbea21e2ab658ca1256bfe5f4c535b2b1b9e4060
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/object: implement support for new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/object.c b/drivers/gpu/drm/nouveau/nvkm/core/object.c
index 1c117f0a7245..0abee7816874 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/object.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/object.c
@@ -24,75 +24,232 @@
 #include <core/object.h>
 #include <core/engine.h>
 
+int
+nvkm_object_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
+{
+	if (object->oclass) {
+		if (object->oclass->ofuncs->mthd)
+			return object->oclass->ofuncs->mthd(object, mthd, data, size);
+		return -ENODEV;
+	}
+	if (likely(object->func->mthd))
+		return object->func->mthd(object, mthd, data, size);
+	return -ENODEV;
+}
+
+int
+nvkm_object_ntfy(struct nvkm_object *object, u32 mthd,
+		 struct nvkm_event **pevent)
+{
+	if (object->oclass) {
+		if (object->oclass->ofuncs->ntfy)
+			return object->oclass->ofuncs->ntfy(object, mthd, pevent);
+		return -ENODEV;
+	}
+	if (likely(object->func->ntfy))
+		return object->func->ntfy(object, mthd, pevent);
+	return -ENODEV;
+}
+
+int
+nvkm_object_map(struct nvkm_object *object, u64 *addr, u32 *size)
+{
+	if (object->oclass) {
+		if (object->oclass->ofuncs->map)
+			return object->oclass->ofuncs->map(object, addr, size);
+		return -ENODEV;
+	}
+	if (likely(object->func->map))
+		return object->func->map(object, addr, size);
+	return -ENODEV;
+}
+
 int
 nvkm_object_rd08(struct nvkm_object *object, u64 addr, u8 *data)
 {
-	const struct nvkm_oclass *oclass = object->oclass;
-	if (oclass->ofuncs && oclass->ofuncs->rd08) {
-		*data = oclass->ofuncs->rd08(object, addr);
-		return 0;
+	if (object->oclass) {
+		if (object->oclass->ofuncs->rd08) {
+			*data = object->oclass->ofuncs->rd08(object, addr);
+			return 0;
+		}
+		*data = 0x00;
+		return -ENODEV;
 	}
-	*data = 0x00;
+	if (likely(object->func->rd08))
+		return object->func->rd08(object, addr, data);
 	return -ENODEV;
 }
 
 int
 nvkm_object_rd16(struct nvkm_object *object, u64 addr, u16 *data)
 {
-	const struct nvkm_oclass *oclass = object->oclass;
-	if (oclass->ofuncs && oclass->ofuncs->rd16) {
-		*data = oclass->ofuncs->rd16(object, addr);
-		return 0;
+	if (object->oclass) {
+		if (object->oclass->ofuncs->rd16) {
+			*data = object->oclass->ofuncs->rd16(object, addr);
+			return 0;
+		}
+		*data = 0x0000;
+		return -ENODEV;
 	}
-	*data = 0x0000;
+	if (likely(object->func->rd16))
+		return object->func->rd16(object, addr, data);
 	return -ENODEV;
 }
 
 int
 nvkm_object_rd32(struct nvkm_object *object, u64 addr, u32 *data)
 {
-	const struct nvkm_oclass *oclass = object->oclass;
-	if (oclass->ofuncs && oclass->ofuncs->rd32) {
-		*data = oclass->ofuncs->rd32(object, addr);
-		return 0;
+	if (object->oclass) {
+		if (object->oclass->ofuncs->rd32) {
+			*data = object->oclass->ofuncs->rd32(object, addr);
+			return 0;
+		}
+		*data = 0x00000000;
+		return -ENODEV;
 	}
-	*data = 0x0000;
+	if (likely(object->func->rd32))
+		return object->func->rd32(object, addr, data);
 	return -ENODEV;
 }
 
 int
 nvkm_object_wr08(struct nvkm_object *object, u64 addr, u8 data)
 {
-	const struct nvkm_oclass *oclass = object->oclass;
-	if (oclass->ofuncs && oclass->ofuncs->wr08) {
-		oclass->ofuncs->wr08(object, addr, data);
-		return 0;
+	if (object->oclass) {
+		if (object->oclass->ofuncs->wr08) {
+			object->oclass->ofuncs->wr08(object, addr, data);
+			return 0;
+		}
+		return -ENODEV;
 	}
+	if (likely(object->func->wr08))
+		return object->func->wr08(object, addr, data);
 	return -ENODEV;
 }
 
 int
 nvkm_object_wr16(struct nvkm_object *object, u64 addr, u16 data)
 {
-	const struct nvkm_oclass *oclass = object->oclass;
-	if (oclass->ofuncs && oclass->ofuncs->wr16) {
-		oclass->ofuncs->wr16(object, addr, data);
-		return 0;
+	if (object->oclass) {
+		if (object->oclass->ofuncs->wr16) {
+			object->oclass->ofuncs->wr16(object, addr, data);
+			return 0;
+		}
+		return -ENODEV;
 	}
+	if (likely(object->func->wr16))
+		return object->func->wr16(object, addr, data);
 	return -ENODEV;
 }
 
 int
 nvkm_object_wr32(struct nvkm_object *object, u64 addr, u32 data)
 {
-	const struct nvkm_oclass *oclass = object->oclass;
-	if (oclass->ofuncs && oclass->ofuncs->wr32) {
-		oclass->ofuncs->wr32(object, addr, data);
-		return 0;
+	if (object->oclass) {
+		if (object->oclass->ofuncs->wr32) {
+			object->oclass->ofuncs->wr32(object, addr, data);
+			return 0;
+		}
+		return -ENODEV;
 	}
+	if (likely(object->func->wr32))
+		return object->func->wr32(object, addr, data);
 	return -ENODEV;
 }
 
+int
+nvkm_object_bind(struct nvkm_object *object, struct nvkm_gpuobj *gpuobj,
+		 int align, struct nvkm_gpuobj **pgpuobj)
+{
+	if (object->oclass)
+		return -ENODEV;
+	if (object->func->bind)
+		return object->func->bind(object, gpuobj, align, pgpuobj);
+	return -ENODEV;
+}
+
+int
+nvkm_object_fini(struct nvkm_object *object, bool suspend)
+{
+	if (object->oclass)
+		return object->oclass->ofuncs->fini(object, suspend);
+	if (object->func->fini)
+		return object->func->fini(object, suspend);
+	return 0;
+}
+
+int
+nvkm_object_init(struct nvkm_object *object)
+{
+	if (object->oclass)
+		return object->oclass->ofuncs->init(object);
+	if (object->func->init)
+		return object->func->init(object);
+	return 0;
+}
+
+static void
+nvkm_object_del(struct nvkm_object **pobject)
+{
+	struct nvkm_object *object = *pobject;
+
+	if (object && object->oclass) {
+		object->oclass->ofuncs->dtor(object);
+		return;
+	}
+
+	if (object && !WARN_ON(!object->func)) {
+		if (object->func->dtor)
+			*pobject = object->func->dtor(object);
+		kfree(*pobject);
+		*pobject = NULL;
+	}
+}
+
+void
+nvkm_object_ctor(const struct nvkm_object_func *func,
+		 const struct nvkm_oclass *oclass, struct nvkm_object *object)
+{
+	object->func = func;
+	object->client = oclass->client;
+	object->engine = oclass->engine;
+	object->oclass_name = oclass->base.oclass;
+	object->handle = oclass->handle;
+	object->parent = oclass->parent;
+	atomic_set(&object->refcount, 1);
+	atomic_set(&object->usecount, 0);
+#ifdef NVKM_OBJECT_MAGIC
+	object->_magic = NVKM_OBJECT_MAGIC;
+#endif
+}
+
+int
+nvkm_object_new_(const struct nvkm_object_func *func,
+		 const struct nvkm_oclass *oclass, void *data, u32 size,
+		 struct nvkm_object **pobject)
+{
+	if (size == 0) {
+		if (!(*pobject = kzalloc(sizeof(**pobject), GFP_KERNEL)))
+			return -ENOMEM;
+		nvkm_object_ctor(func, oclass, *pobject);
+		return 0;
+	}
+	return -ENOSYS;
+}
+
+static const struct nvkm_object_func
+nvkm_object_func = {
+};
+
+int
+nvkm_object_new(const struct nvkm_oclass *oclass, void *data, u32 size,
+		struct nvkm_object **pobject)
+{
+	const struct nvkm_object_func *func =
+		oclass->base.func ? oclass->base.func : &nvkm_object_func;
+	return nvkm_object_new_(func, oclass, data, size, pobject);
+}
+
 int
 nvkm_object_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		    struct nvkm_oclass *oclass, u32 pclass,
@@ -182,12 +339,6 @@ nvkm_object_old(struct nvkm_object *parent, struct nvkm_object *engine,
 	return 0;
 }
 
-static void
-nvkm_object_dtor(struct nvkm_object *object)
-{
-	nv_ofuncs(object)->dtor(object);
-}
-
 void
 nvkm_object_ref(struct nvkm_object *obj, struct nvkm_object **ref)
 {
@@ -198,7 +349,7 @@ nvkm_object_ref(struct nvkm_object *obj, struct nvkm_object **ref)
 	if (*ref) {
 		int dead = atomic_dec_and_test(&(*ref)->refcount);
 		if (dead)
-			nvkm_object_dtor(*ref);
+			nvkm_object_del(ref);
 	}
 
 	*ref = obj;
@@ -227,7 +378,7 @@ nvkm_object_inc(struct nvkm_object *object)
 			goto fail_engine;
 	}
 
-	ret = nv_ofuncs(object)->init(object);
+	ret = nvkm_object_init(object);
 	atomic_set(&object->usecount, 1);
 	if (ret)
 		goto fail_self;
@@ -251,7 +402,7 @@ nvkm_object_inc(struct nvkm_object *object)
 static int
 nvkm_object_decf(struct nvkm_object *object)
 {
-	nv_ofuncs(object)->fini(object, false);
+	nvkm_object_fini(object, false);
 	atomic_set(&object->usecount, 0);
 
 	if (object->engine) {
@@ -271,7 +422,7 @@ nvkm_object_decs(struct nvkm_object *object)
 {
 	int ret;
 
-	ret = nv_ofuncs(object)->fini(object, true);
+	ret = nvkm_object_fini(object, true);
 	atomic_set(&object->usecount, 0);
 	if (ret)
 		return ret;
@@ -300,7 +451,7 @@ nvkm_object_decs(struct nvkm_object *object)
 	}
 
 fail_engine:
-	nv_ofuncs(object)->init(object);
+	nvkm_object_init(object);
 
 	return ret;
 }

commit aa35888ff024b18c7b6b29eb773a221f642987f7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/object: rename some functions to avoid upcoming conflicts
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/object.c b/drivers/gpu/drm/nouveau/nvkm/core/object.c
index 98ba58ec1d39..1c117f0a7245 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/object.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/object.c
@@ -136,13 +136,13 @@ nvkm_object_destroy(struct nvkm_object *object)
 }
 
 int
-nvkm_object_init(struct nvkm_object *object)
+_nvkm_object_init(struct nvkm_object *object)
 {
 	return 0;
 }
 
 int
-nvkm_object_fini(struct nvkm_object *object, bool suspend)
+_nvkm_object_fini(struct nvkm_object *object, bool suspend)
 {
 	return 0;
 }
@@ -151,12 +151,12 @@ struct nvkm_ofuncs
 nvkm_object_ofuncs = {
 	.ctor = _nvkm_object_ctor,
 	.dtor = nvkm_object_destroy,
-	.init = nvkm_object_init,
-	.fini = nvkm_object_fini,
+	.init = _nvkm_object_init,
+	.fini = _nvkm_object_fini,
 };
 
 int
-nvkm_object_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+nvkm_object_old(struct nvkm_object *parent, struct nvkm_object *engine,
 		 struct nvkm_oclass *oclass, void *data, u32 size,
 		 struct nvkm_object **pobject)
 {

commit 493f189dc0cbbe9bde8074fb49ca777ba1ef292c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:15 2015 +1000

    drm/nouveau/object: store object type data outside of handle
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/object.c b/drivers/gpu/drm/nouveau/nvkm/core/object.c
index b32a041636a4..98ba58ec1d39 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/object.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/object.c
@@ -107,7 +107,7 @@ nvkm_object_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 	nvkm_object_ref(parent, &object->parent);
 	nvkm_object_ref(engine, (struct nvkm_object **)&object->engine);
 	object->oclass = oclass;
-	object->oclass->handle |= pclass;
+	object->pclass = pclass;
 	atomic_set(&object->refcount, 1);
 	atomic_set(&object->usecount, 0);
 

commit cfdc4c44b4388bb8e697882cddd966333e4ab7b0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:14 2015 +1000

    drm/nouveau/core: wrap direct use of object accessor functions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/object.c b/drivers/gpu/drm/nouveau/nvkm/core/object.c
index b690a3898732..b32a041636a4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/object.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/object.c
@@ -24,6 +24,75 @@
 #include <core/object.h>
 #include <core/engine.h>
 
+int
+nvkm_object_rd08(struct nvkm_object *object, u64 addr, u8 *data)
+{
+	const struct nvkm_oclass *oclass = object->oclass;
+	if (oclass->ofuncs && oclass->ofuncs->rd08) {
+		*data = oclass->ofuncs->rd08(object, addr);
+		return 0;
+	}
+	*data = 0x00;
+	return -ENODEV;
+}
+
+int
+nvkm_object_rd16(struct nvkm_object *object, u64 addr, u16 *data)
+{
+	const struct nvkm_oclass *oclass = object->oclass;
+	if (oclass->ofuncs && oclass->ofuncs->rd16) {
+		*data = oclass->ofuncs->rd16(object, addr);
+		return 0;
+	}
+	*data = 0x0000;
+	return -ENODEV;
+}
+
+int
+nvkm_object_rd32(struct nvkm_object *object, u64 addr, u32 *data)
+{
+	const struct nvkm_oclass *oclass = object->oclass;
+	if (oclass->ofuncs && oclass->ofuncs->rd32) {
+		*data = oclass->ofuncs->rd32(object, addr);
+		return 0;
+	}
+	*data = 0x0000;
+	return -ENODEV;
+}
+
+int
+nvkm_object_wr08(struct nvkm_object *object, u64 addr, u8 data)
+{
+	const struct nvkm_oclass *oclass = object->oclass;
+	if (oclass->ofuncs && oclass->ofuncs->wr08) {
+		oclass->ofuncs->wr08(object, addr, data);
+		return 0;
+	}
+	return -ENODEV;
+}
+
+int
+nvkm_object_wr16(struct nvkm_object *object, u64 addr, u16 data)
+{
+	const struct nvkm_oclass *oclass = object->oclass;
+	if (oclass->ofuncs && oclass->ofuncs->wr16) {
+		oclass->ofuncs->wr16(object, addr, data);
+		return 0;
+	}
+	return -ENODEV;
+}
+
+int
+nvkm_object_wr32(struct nvkm_object *object, u64 addr, u32 data)
+{
+	const struct nvkm_oclass *oclass = object->oclass;
+	if (oclass->ofuncs && oclass->ofuncs->wr32) {
+		oclass->ofuncs->wr32(object, addr, data);
+		return 0;
+	}
+	return -ENODEV;
+}
+
 int
 nvkm_object_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		    struct nvkm_oclass *oclass, u32 pclass,

commit 53003941067534b1071b0f7b71f4700c16d97b28
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:13 2015 +1000

    drm/nouveau/core: remove last printks
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/object.c b/drivers/gpu/drm/nouveau/nvkm/core/object.c
index 979f3627d395..b690a3898732 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/object.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/object.c
@@ -24,11 +24,6 @@
 #include <core/object.h>
 #include <core/engine.h>
 
-#ifdef NVKM_OBJECT_MAGIC
-static struct list_head _objlist = LIST_HEAD_INIT(_objlist);
-static DEFINE_SPINLOCK(_objlist_lock);
-#endif
-
 int
 nvkm_object_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		    struct nvkm_oclass *oclass, u32 pclass,
@@ -49,9 +44,6 @@ nvkm_object_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 
 #ifdef NVKM_OBJECT_MAGIC
 	object->_magic = NVKM_OBJECT_MAGIC;
-	spin_lock(&_objlist_lock);
-	list_add(&object->list, &_objlist);
-	spin_unlock(&_objlist_lock);
 #endif
 	return 0;
 }
@@ -69,11 +61,6 @@ _nvkm_object_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 void
 nvkm_object_destroy(struct nvkm_object *object)
 {
-#ifdef NVKM_OBJECT_MAGIC
-	spin_lock(&_objlist_lock);
-	list_del(&object->list);
-	spin_unlock(&_objlist_lock);
-#endif
 	nvkm_object_ref(NULL, (struct nvkm_object **)&object->engine);
 	nvkm_object_ref(NULL, &object->parent);
 	kfree(object);
@@ -111,11 +98,6 @@ nvkm_object_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	ret = ofuncs->ctor(parent, engine, oclass, data, size, &object);
 	*pobject = object;
 	if (ret < 0) {
-		if (ret != -ENODEV) {
-			nv_error(parent, "failed to create 0x%08x, %d\n",
-				 oclass->handle, ret);
-		}
-
 		if (object) {
 			ofuncs->dtor(object);
 			*pobject = NULL;
@@ -125,7 +107,6 @@ nvkm_object_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	}
 
 	if (ret == 0) {
-		nv_trace(object, "created\n");
 		atomic_set(&object->refcount, 1);
 	}
 
@@ -135,7 +116,6 @@ nvkm_object_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 static void
 nvkm_object_dtor(struct nvkm_object *object)
 {
-	nv_trace(object, "destroying\n");
 	nv_ofuncs(object)->dtor(object);
 }
 
@@ -144,12 +124,10 @@ nvkm_object_ref(struct nvkm_object *obj, struct nvkm_object **ref)
 {
 	if (obj) {
 		atomic_inc(&obj->refcount);
-		nv_trace(obj, "inc() == %d\n", atomic_read(&obj->refcount));
 	}
 
 	if (*ref) {
 		int dead = atomic_dec_and_test(&(*ref)->refcount);
-		nv_trace(*ref, "dec() == %d\n", atomic_read(&(*ref)->refcount));
 		if (dead)
 			nvkm_object_dtor(*ref);
 	}
@@ -163,37 +141,28 @@ nvkm_object_inc(struct nvkm_object *object)
 	int ref = atomic_add_return(1, &object->usecount);
 	int ret;
 
-	nv_trace(object, "use(+1) == %d\n", atomic_read(&object->usecount));
 	if (ref != 1)
 		return 0;
 
-	nv_trace(object, "initialising...\n");
 	if (object->parent) {
 		ret = nvkm_object_inc(object->parent);
-		if (ret) {
-			nv_error(object, "parent failed, %d\n", ret);
+		if (ret)
 			goto fail_parent;
-		}
 	}
 
 	if (object->engine) {
 		mutex_lock(&nv_subdev(object->engine)->mutex);
 		ret = nvkm_object_inc(&object->engine->subdev.object);
 		mutex_unlock(&nv_subdev(object->engine)->mutex);
-		if (ret) {
-			nv_error(object, "engine failed, %d\n", ret);
+		if (ret)
 			goto fail_engine;
-		}
 	}
 
 	ret = nv_ofuncs(object)->init(object);
 	atomic_set(&object->usecount, 1);
-	if (ret) {
-		nv_error(object, "init failed, %d\n", ret);
+	if (ret)
 		goto fail_self;
-	}
 
-	nv_trace(object, "initialised\n");
 	return 0;
 
 fail_self:
@@ -213,14 +182,8 @@ nvkm_object_inc(struct nvkm_object *object)
 static int
 nvkm_object_decf(struct nvkm_object *object)
 {
-	int ret;
-
-	nv_trace(object, "stopping...\n");
-
-	ret = nv_ofuncs(object)->fini(object, false);
+	nv_ofuncs(object)->fini(object, false);
 	atomic_set(&object->usecount, 0);
-	if (ret)
-		nv_warn(object, "failed fini, %d\n", ret);
 
 	if (object->engine) {
 		mutex_lock(&nv_subdev(object->engine)->mutex);
@@ -231,58 +194,44 @@ nvkm_object_decf(struct nvkm_object *object)
 	if (object->parent)
 		nvkm_object_dec(object->parent, false);
 
-	nv_trace(object, "stopped\n");
 	return 0;
 }
 
 static int
 nvkm_object_decs(struct nvkm_object *object)
 {
-	int ret, rret;
-
-	nv_trace(object, "suspending...\n");
+	int ret;
 
 	ret = nv_ofuncs(object)->fini(object, true);
 	atomic_set(&object->usecount, 0);
-	if (ret) {
-		nv_error(object, "failed suspend, %d\n", ret);
+	if (ret)
 		return ret;
-	}
 
 	if (object->engine) {
 		mutex_lock(&nv_subdev(object->engine)->mutex);
 		ret = nvkm_object_dec(&object->engine->subdev.object, true);
 		mutex_unlock(&nv_subdev(object->engine)->mutex);
-		if (ret) {
-			nv_warn(object, "engine failed suspend, %d\n", ret);
+		if (ret)
 			goto fail_engine;
-		}
 	}
 
 	if (object->parent) {
 		ret = nvkm_object_dec(object->parent, true);
-		if (ret) {
-			nv_warn(object, "parent failed suspend, %d\n", ret);
+		if (ret)
 			goto fail_parent;
-		}
 	}
 
-	nv_trace(object, "suspended\n");
 	return 0;
 
 fail_parent:
 	if (object->engine) {
 		mutex_lock(&nv_subdev(object->engine)->mutex);
-		rret = nvkm_object_inc(&object->engine->subdev.object);
+		nvkm_object_inc(&object->engine->subdev.object);
 		mutex_unlock(&nv_subdev(object->engine)->mutex);
-		if (rret)
-			nv_fatal(object, "engine failed to reinit, %d\n", rret);
 	}
 
 fail_engine:
-	rret = nv_ofuncs(object)->init(object);
-	if (rret)
-		nv_fatal(object, "failed to reinit, %d\n", rret);
+	nv_ofuncs(object)->init(object);
 
 	return ret;
 }
@@ -293,8 +242,6 @@ nvkm_object_dec(struct nvkm_object *object, bool suspend)
 	int ref = atomic_add_return(-1, &object->usecount);
 	int ret;
 
-	nv_trace(object, "use(-1) == %d\n", atomic_read(&object->usecount));
-
 	if (ref == 0) {
 		if (suspend)
 			ret = nvkm_object_decs(object);
@@ -309,22 +256,3 @@ nvkm_object_dec(struct nvkm_object *object, bool suspend)
 
 	return 0;
 }
-
-void
-nvkm_object_debug(void)
-{
-#ifdef NVKM_OBJECT_MAGIC
-	struct nvkm_object *object;
-	if (!list_empty(&_objlist)) {
-		nv_fatal(NULL, "*******************************************\n");
-		nv_fatal(NULL, "* AIIIII! object(s) still exist!!!\n");
-		nv_fatal(NULL, "*******************************************\n");
-		list_for_each_entry(object, &_objlist, list) {
-			nv_fatal(object, "%p/%p/%d/%d\n",
-				 object->parent, object->engine,
-				 atomic_read(&object->refcount),
-				 atomic_read(&object->usecount));
-		}
-	}
-#endif
-}

commit 5025407b9862349d17b1dff25737aaef6520a439
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 14:11:21 2015 +1000

    drm/nouveau/core: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/object.c b/drivers/gpu/drm/nouveau/nvkm/core/object.c
index b160860edf54..979f3627d395 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/object.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/object.c
@@ -21,36 +21,34 @@
  *
  * Authors: Ben Skeggs
  */
-
 #include <core/object.h>
 #include <core/engine.h>
 
-#ifdef NOUVEAU_OBJECT_MAGIC
+#ifdef NVKM_OBJECT_MAGIC
 static struct list_head _objlist = LIST_HEAD_INIT(_objlist);
 static DEFINE_SPINLOCK(_objlist_lock);
 #endif
 
 int
-nouveau_object_create_(struct nouveau_object *parent,
-		       struct nouveau_object *engine,
-		       struct nouveau_oclass *oclass, u32 pclass,
-		       int size, void **pobject)
+nvkm_object_create_(struct nvkm_object *parent, struct nvkm_object *engine,
+		    struct nvkm_oclass *oclass, u32 pclass,
+		    int size, void **pobject)
 {
-	struct nouveau_object *object;
+	struct nvkm_object *object;
 
 	object = *pobject = kzalloc(size, GFP_KERNEL);
 	if (!object)
 		return -ENOMEM;
 
-	nouveau_object_ref(parent, &object->parent);
-	nouveau_object_ref(engine, (struct nouveau_object **)&object->engine);
+	nvkm_object_ref(parent, &object->parent);
+	nvkm_object_ref(engine, (struct nvkm_object **)&object->engine);
 	object->oclass = oclass;
 	object->oclass->handle |= pclass;
 	atomic_set(&object->refcount, 1);
 	atomic_set(&object->usecount, 0);
 
-#ifdef NOUVEAU_OBJECT_MAGIC
-	object->_magic = NOUVEAU_OBJECT_MAGIC;
+#ifdef NVKM_OBJECT_MAGIC
+	object->_magic = NVKM_OBJECT_MAGIC;
 	spin_lock(&_objlist_lock);
 	list_add(&object->list, &_objlist);
 	spin_unlock(&_objlist_lock);
@@ -59,57 +57,55 @@ nouveau_object_create_(struct nouveau_object *parent,
 }
 
 int
-_nouveau_object_ctor(struct nouveau_object *parent,
-		     struct nouveau_object *engine,
-		     struct nouveau_oclass *oclass, void *data, u32 size,
-		     struct nouveau_object **pobject)
+_nvkm_object_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+		  struct nvkm_oclass *oclass, void *data, u32 size,
+		  struct nvkm_object **pobject)
 {
 	if (size != 0)
 		return -ENOSYS;
-	return nouveau_object_create(parent, engine, oclass, 0, pobject);
+	return nvkm_object_create(parent, engine, oclass, 0, pobject);
 }
 
 void
-nouveau_object_destroy(struct nouveau_object *object)
+nvkm_object_destroy(struct nvkm_object *object)
 {
-#ifdef NOUVEAU_OBJECT_MAGIC
+#ifdef NVKM_OBJECT_MAGIC
 	spin_lock(&_objlist_lock);
 	list_del(&object->list);
 	spin_unlock(&_objlist_lock);
 #endif
-	nouveau_object_ref(NULL, (struct nouveau_object **)&object->engine);
-	nouveau_object_ref(NULL, &object->parent);
+	nvkm_object_ref(NULL, (struct nvkm_object **)&object->engine);
+	nvkm_object_ref(NULL, &object->parent);
 	kfree(object);
 }
 
 int
-nouveau_object_init(struct nouveau_object *object)
+nvkm_object_init(struct nvkm_object *object)
 {
 	return 0;
 }
 
 int
-nouveau_object_fini(struct nouveau_object *object, bool suspend)
+nvkm_object_fini(struct nvkm_object *object, bool suspend)
 {
 	return 0;
 }
 
-struct nouveau_ofuncs
-nouveau_object_ofuncs = {
-	.ctor = _nouveau_object_ctor,
-	.dtor = nouveau_object_destroy,
-	.init = nouveau_object_init,
-	.fini = nouveau_object_fini,
+struct nvkm_ofuncs
+nvkm_object_ofuncs = {
+	.ctor = _nvkm_object_ctor,
+	.dtor = nvkm_object_destroy,
+	.init = nvkm_object_init,
+	.fini = nvkm_object_fini,
 };
 
 int
-nouveau_object_ctor(struct nouveau_object *parent,
-		    struct nouveau_object *engine,
-		    struct nouveau_oclass *oclass, void *data, u32 size,
-		    struct nouveau_object **pobject)
+nvkm_object_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+		 struct nvkm_oclass *oclass, void *data, u32 size,
+		 struct nvkm_object **pobject)
 {
-	struct nouveau_ofuncs *ofuncs = oclass->ofuncs;
-	struct nouveau_object *object = NULL;
+	struct nvkm_ofuncs *ofuncs = oclass->ofuncs;
+	struct nvkm_object *object = NULL;
 	int ret;
 
 	ret = ofuncs->ctor(parent, engine, oclass, data, size, &object);
@@ -137,14 +133,14 @@ nouveau_object_ctor(struct nouveau_object *parent,
 }
 
 static void
-nouveau_object_dtor(struct nouveau_object *object)
+nvkm_object_dtor(struct nvkm_object *object)
 {
 	nv_trace(object, "destroying\n");
 	nv_ofuncs(object)->dtor(object);
 }
 
 void
-nouveau_object_ref(struct nouveau_object *obj, struct nouveau_object **ref)
+nvkm_object_ref(struct nvkm_object *obj, struct nvkm_object **ref)
 {
 	if (obj) {
 		atomic_inc(&obj->refcount);
@@ -155,14 +151,14 @@ nouveau_object_ref(struct nouveau_object *obj, struct nouveau_object **ref)
 		int dead = atomic_dec_and_test(&(*ref)->refcount);
 		nv_trace(*ref, "dec() == %d\n", atomic_read(&(*ref)->refcount));
 		if (dead)
-			nouveau_object_dtor(*ref);
+			nvkm_object_dtor(*ref);
 	}
 
 	*ref = obj;
 }
 
 int
-nouveau_object_inc(struct nouveau_object *object)
+nvkm_object_inc(struct nvkm_object *object)
 {
 	int ref = atomic_add_return(1, &object->usecount);
 	int ret;
@@ -173,7 +169,7 @@ nouveau_object_inc(struct nouveau_object *object)
 
 	nv_trace(object, "initialising...\n");
 	if (object->parent) {
-		ret = nouveau_object_inc(object->parent);
+		ret = nvkm_object_inc(object->parent);
 		if (ret) {
 			nv_error(object, "parent failed, %d\n", ret);
 			goto fail_parent;
@@ -182,7 +178,7 @@ nouveau_object_inc(struct nouveau_object *object)
 
 	if (object->engine) {
 		mutex_lock(&nv_subdev(object->engine)->mutex);
-		ret = nouveau_object_inc(&object->engine->subdev.object);
+		ret = nvkm_object_inc(&object->engine->subdev.object);
 		mutex_unlock(&nv_subdev(object->engine)->mutex);
 		if (ret) {
 			nv_error(object, "engine failed, %d\n", ret);
@@ -203,19 +199,19 @@ nouveau_object_inc(struct nouveau_object *object)
 fail_self:
 	if (object->engine) {
 		mutex_lock(&nv_subdev(object->engine)->mutex);
-		nouveau_object_dec(&object->engine->subdev.object, false);
+		nvkm_object_dec(&object->engine->subdev.object, false);
 		mutex_unlock(&nv_subdev(object->engine)->mutex);
 	}
 fail_engine:
 	if (object->parent)
-		 nouveau_object_dec(object->parent, false);
+		 nvkm_object_dec(object->parent, false);
 fail_parent:
 	atomic_dec(&object->usecount);
 	return ret;
 }
 
 static int
-nouveau_object_decf(struct nouveau_object *object)
+nvkm_object_decf(struct nvkm_object *object)
 {
 	int ret;
 
@@ -228,19 +224,19 @@ nouveau_object_decf(struct nouveau_object *object)
 
 	if (object->engine) {
 		mutex_lock(&nv_subdev(object->engine)->mutex);
-		nouveau_object_dec(&object->engine->subdev.object, false);
+		nvkm_object_dec(&object->engine->subdev.object, false);
 		mutex_unlock(&nv_subdev(object->engine)->mutex);
 	}
 
 	if (object->parent)
-		nouveau_object_dec(object->parent, false);
+		nvkm_object_dec(object->parent, false);
 
 	nv_trace(object, "stopped\n");
 	return 0;
 }
 
 static int
-nouveau_object_decs(struct nouveau_object *object)
+nvkm_object_decs(struct nvkm_object *object)
 {
 	int ret, rret;
 
@@ -255,7 +251,7 @@ nouveau_object_decs(struct nouveau_object *object)
 
 	if (object->engine) {
 		mutex_lock(&nv_subdev(object->engine)->mutex);
-		ret = nouveau_object_dec(&object->engine->subdev.object, true);
+		ret = nvkm_object_dec(&object->engine->subdev.object, true);
 		mutex_unlock(&nv_subdev(object->engine)->mutex);
 		if (ret) {
 			nv_warn(object, "engine failed suspend, %d\n", ret);
@@ -264,7 +260,7 @@ nouveau_object_decs(struct nouveau_object *object)
 	}
 
 	if (object->parent) {
-		ret = nouveau_object_dec(object->parent, true);
+		ret = nvkm_object_dec(object->parent, true);
 		if (ret) {
 			nv_warn(object, "parent failed suspend, %d\n", ret);
 			goto fail_parent;
@@ -277,7 +273,7 @@ nouveau_object_decs(struct nouveau_object *object)
 fail_parent:
 	if (object->engine) {
 		mutex_lock(&nv_subdev(object->engine)->mutex);
-		rret = nouveau_object_inc(&object->engine->subdev.object);
+		rret = nvkm_object_inc(&object->engine->subdev.object);
 		mutex_unlock(&nv_subdev(object->engine)->mutex);
 		if (rret)
 			nv_fatal(object, "engine failed to reinit, %d\n", rret);
@@ -292,7 +288,7 @@ nouveau_object_decs(struct nouveau_object *object)
 }
 
 int
-nouveau_object_dec(struct nouveau_object *object, bool suspend)
+nvkm_object_dec(struct nvkm_object *object, bool suspend)
 {
 	int ref = atomic_add_return(-1, &object->usecount);
 	int ret;
@@ -301,9 +297,9 @@ nouveau_object_dec(struct nouveau_object *object, bool suspend)
 
 	if (ref == 0) {
 		if (suspend)
-			ret = nouveau_object_decs(object);
+			ret = nvkm_object_decs(object);
 		else
-			ret = nouveau_object_decf(object);
+			ret = nvkm_object_decf(object);
 
 		if (ret) {
 			atomic_inc(&object->usecount);
@@ -315,10 +311,10 @@ nouveau_object_dec(struct nouveau_object *object, bool suspend)
 }
 
 void
-nouveau_object_debug(void)
+nvkm_object_debug(void)
 {
-#ifdef NOUVEAU_OBJECT_MAGIC
-	struct nouveau_object *object;
+#ifdef NVKM_OBJECT_MAGIC
+	struct nvkm_object *object;
 	if (!list_empty(&_objlist)) {
 		nv_fatal(NULL, "*******************************************\n");
 		nv_fatal(NULL, "* AIIIII! object(s) still exist!!!\n");

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/object.c b/drivers/gpu/drm/nouveau/nvkm/core/object.c
new file mode 100644
index 000000000000..b160860edf54
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/core/object.c
@@ -0,0 +1,334 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <core/object.h>
+#include <core/engine.h>
+
+#ifdef NOUVEAU_OBJECT_MAGIC
+static struct list_head _objlist = LIST_HEAD_INIT(_objlist);
+static DEFINE_SPINLOCK(_objlist_lock);
+#endif
+
+int
+nouveau_object_create_(struct nouveau_object *parent,
+		       struct nouveau_object *engine,
+		       struct nouveau_oclass *oclass, u32 pclass,
+		       int size, void **pobject)
+{
+	struct nouveau_object *object;
+
+	object = *pobject = kzalloc(size, GFP_KERNEL);
+	if (!object)
+		return -ENOMEM;
+
+	nouveau_object_ref(parent, &object->parent);
+	nouveau_object_ref(engine, (struct nouveau_object **)&object->engine);
+	object->oclass = oclass;
+	object->oclass->handle |= pclass;
+	atomic_set(&object->refcount, 1);
+	atomic_set(&object->usecount, 0);
+
+#ifdef NOUVEAU_OBJECT_MAGIC
+	object->_magic = NOUVEAU_OBJECT_MAGIC;
+	spin_lock(&_objlist_lock);
+	list_add(&object->list, &_objlist);
+	spin_unlock(&_objlist_lock);
+#endif
+	return 0;
+}
+
+int
+_nouveau_object_ctor(struct nouveau_object *parent,
+		     struct nouveau_object *engine,
+		     struct nouveau_oclass *oclass, void *data, u32 size,
+		     struct nouveau_object **pobject)
+{
+	if (size != 0)
+		return -ENOSYS;
+	return nouveau_object_create(parent, engine, oclass, 0, pobject);
+}
+
+void
+nouveau_object_destroy(struct nouveau_object *object)
+{
+#ifdef NOUVEAU_OBJECT_MAGIC
+	spin_lock(&_objlist_lock);
+	list_del(&object->list);
+	spin_unlock(&_objlist_lock);
+#endif
+	nouveau_object_ref(NULL, (struct nouveau_object **)&object->engine);
+	nouveau_object_ref(NULL, &object->parent);
+	kfree(object);
+}
+
+int
+nouveau_object_init(struct nouveau_object *object)
+{
+	return 0;
+}
+
+int
+nouveau_object_fini(struct nouveau_object *object, bool suspend)
+{
+	return 0;
+}
+
+struct nouveau_ofuncs
+nouveau_object_ofuncs = {
+	.ctor = _nouveau_object_ctor,
+	.dtor = nouveau_object_destroy,
+	.init = nouveau_object_init,
+	.fini = nouveau_object_fini,
+};
+
+int
+nouveau_object_ctor(struct nouveau_object *parent,
+		    struct nouveau_object *engine,
+		    struct nouveau_oclass *oclass, void *data, u32 size,
+		    struct nouveau_object **pobject)
+{
+	struct nouveau_ofuncs *ofuncs = oclass->ofuncs;
+	struct nouveau_object *object = NULL;
+	int ret;
+
+	ret = ofuncs->ctor(parent, engine, oclass, data, size, &object);
+	*pobject = object;
+	if (ret < 0) {
+		if (ret != -ENODEV) {
+			nv_error(parent, "failed to create 0x%08x, %d\n",
+				 oclass->handle, ret);
+		}
+
+		if (object) {
+			ofuncs->dtor(object);
+			*pobject = NULL;
+		}
+
+		return ret;
+	}
+
+	if (ret == 0) {
+		nv_trace(object, "created\n");
+		atomic_set(&object->refcount, 1);
+	}
+
+	return 0;
+}
+
+static void
+nouveau_object_dtor(struct nouveau_object *object)
+{
+	nv_trace(object, "destroying\n");
+	nv_ofuncs(object)->dtor(object);
+}
+
+void
+nouveau_object_ref(struct nouveau_object *obj, struct nouveau_object **ref)
+{
+	if (obj) {
+		atomic_inc(&obj->refcount);
+		nv_trace(obj, "inc() == %d\n", atomic_read(&obj->refcount));
+	}
+
+	if (*ref) {
+		int dead = atomic_dec_and_test(&(*ref)->refcount);
+		nv_trace(*ref, "dec() == %d\n", atomic_read(&(*ref)->refcount));
+		if (dead)
+			nouveau_object_dtor(*ref);
+	}
+
+	*ref = obj;
+}
+
+int
+nouveau_object_inc(struct nouveau_object *object)
+{
+	int ref = atomic_add_return(1, &object->usecount);
+	int ret;
+
+	nv_trace(object, "use(+1) == %d\n", atomic_read(&object->usecount));
+	if (ref != 1)
+		return 0;
+
+	nv_trace(object, "initialising...\n");
+	if (object->parent) {
+		ret = nouveau_object_inc(object->parent);
+		if (ret) {
+			nv_error(object, "parent failed, %d\n", ret);
+			goto fail_parent;
+		}
+	}
+
+	if (object->engine) {
+		mutex_lock(&nv_subdev(object->engine)->mutex);
+		ret = nouveau_object_inc(&object->engine->subdev.object);
+		mutex_unlock(&nv_subdev(object->engine)->mutex);
+		if (ret) {
+			nv_error(object, "engine failed, %d\n", ret);
+			goto fail_engine;
+		}
+	}
+
+	ret = nv_ofuncs(object)->init(object);
+	atomic_set(&object->usecount, 1);
+	if (ret) {
+		nv_error(object, "init failed, %d\n", ret);
+		goto fail_self;
+	}
+
+	nv_trace(object, "initialised\n");
+	return 0;
+
+fail_self:
+	if (object->engine) {
+		mutex_lock(&nv_subdev(object->engine)->mutex);
+		nouveau_object_dec(&object->engine->subdev.object, false);
+		mutex_unlock(&nv_subdev(object->engine)->mutex);
+	}
+fail_engine:
+	if (object->parent)
+		 nouveau_object_dec(object->parent, false);
+fail_parent:
+	atomic_dec(&object->usecount);
+	return ret;
+}
+
+static int
+nouveau_object_decf(struct nouveau_object *object)
+{
+	int ret;
+
+	nv_trace(object, "stopping...\n");
+
+	ret = nv_ofuncs(object)->fini(object, false);
+	atomic_set(&object->usecount, 0);
+	if (ret)
+		nv_warn(object, "failed fini, %d\n", ret);
+
+	if (object->engine) {
+		mutex_lock(&nv_subdev(object->engine)->mutex);
+		nouveau_object_dec(&object->engine->subdev.object, false);
+		mutex_unlock(&nv_subdev(object->engine)->mutex);
+	}
+
+	if (object->parent)
+		nouveau_object_dec(object->parent, false);
+
+	nv_trace(object, "stopped\n");
+	return 0;
+}
+
+static int
+nouveau_object_decs(struct nouveau_object *object)
+{
+	int ret, rret;
+
+	nv_trace(object, "suspending...\n");
+
+	ret = nv_ofuncs(object)->fini(object, true);
+	atomic_set(&object->usecount, 0);
+	if (ret) {
+		nv_error(object, "failed suspend, %d\n", ret);
+		return ret;
+	}
+
+	if (object->engine) {
+		mutex_lock(&nv_subdev(object->engine)->mutex);
+		ret = nouveau_object_dec(&object->engine->subdev.object, true);
+		mutex_unlock(&nv_subdev(object->engine)->mutex);
+		if (ret) {
+			nv_warn(object, "engine failed suspend, %d\n", ret);
+			goto fail_engine;
+		}
+	}
+
+	if (object->parent) {
+		ret = nouveau_object_dec(object->parent, true);
+		if (ret) {
+			nv_warn(object, "parent failed suspend, %d\n", ret);
+			goto fail_parent;
+		}
+	}
+
+	nv_trace(object, "suspended\n");
+	return 0;
+
+fail_parent:
+	if (object->engine) {
+		mutex_lock(&nv_subdev(object->engine)->mutex);
+		rret = nouveau_object_inc(&object->engine->subdev.object);
+		mutex_unlock(&nv_subdev(object->engine)->mutex);
+		if (rret)
+			nv_fatal(object, "engine failed to reinit, %d\n", rret);
+	}
+
+fail_engine:
+	rret = nv_ofuncs(object)->init(object);
+	if (rret)
+		nv_fatal(object, "failed to reinit, %d\n", rret);
+
+	return ret;
+}
+
+int
+nouveau_object_dec(struct nouveau_object *object, bool suspend)
+{
+	int ref = atomic_add_return(-1, &object->usecount);
+	int ret;
+
+	nv_trace(object, "use(-1) == %d\n", atomic_read(&object->usecount));
+
+	if (ref == 0) {
+		if (suspend)
+			ret = nouveau_object_decs(object);
+		else
+			ret = nouveau_object_decf(object);
+
+		if (ret) {
+			atomic_inc(&object->usecount);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+void
+nouveau_object_debug(void)
+{
+#ifdef NOUVEAU_OBJECT_MAGIC
+	struct nouveau_object *object;
+	if (!list_empty(&_objlist)) {
+		nv_fatal(NULL, "*******************************************\n");
+		nv_fatal(NULL, "* AIIIII! object(s) still exist!!!\n");
+		nv_fatal(NULL, "*******************************************\n");
+		list_for_each_entry(object, &_objlist, list) {
+			nv_fatal(object, "%p/%p/%d/%d\n",
+				 object->parent, object->engine,
+				 atomic_read(&object->refcount),
+				 atomic_read(&object->usecount));
+		}
+	}
+#endif
+}
