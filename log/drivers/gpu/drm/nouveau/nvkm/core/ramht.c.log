commit b4b06db115bbbc10252287ae2d326fb5ecefaf18
Author: Kees Cook <keescook@chromium.org>
Date:   Tue May 8 15:56:34 2018 -0700

    treewide: Use struct_size() for vmalloc()-family
    
    This only finds one hit in the entire tree, but here's the Coccinelle:
    
    // Directly refer to structure's field
    @@
    identifier alloc =~ "vmalloc|vzalloc";
    identifier VAR, ELEMENT;
    expression COUNT;
    @@
    
    - alloc(sizeof(*VAR) + COUNT * sizeof(*VAR->ELEMENT))
    + alloc(struct_size(VAR, ELEMENT, COUNT))
    
    // mr = kzalloc(sizeof(*mr) + m * sizeof(mr->map[0]), GFP_KERNEL);
    @@
    identifier alloc =~ "vmalloc|vzalloc";
    identifier VAR, ELEMENT;
    expression COUNT;
    @@
    
    - alloc(sizeof(*VAR) + COUNT * sizeof(VAR->ELEMENT[0]))
    + alloc(struct_size(VAR, ELEMENT, COUNT))
    
    // Same pattern, but can't trivially locate the trailing element name,
    // or variable name.
    @@
    identifier alloc =~ "vmalloc|vzalloc";
    expression SOMETHING, COUNT, ELEMENT;
    @@
    
    - alloc(sizeof(SOMETHING) + COUNT * sizeof(ELEMENT))
    + alloc(CHECKME_struct_size(&SOMETHING, ELEMENT, COUNT))
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
index ccba4ae73cc5..8162e3d2359c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
@@ -144,8 +144,7 @@ nvkm_ramht_new(struct nvkm_device *device, u32 size, u32 align,
 	struct nvkm_ramht *ramht;
 	int ret, i;
 
-	if (!(ramht = *pramht = vzalloc(sizeof(*ramht) +
-					(size >> 3) * sizeof(*ramht->data))))
+	if (!(ramht = *pramht = vzalloc(struct_size(ramht, data, (size >> 3)))))
 		return -ENOMEM;
 
 	ramht->device = device;

commit 4246b92cf9fb32da8d8b060c92d8302797c6fbea
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/core/device: remove object include to prevent unnecessary rebuilds
    
    nvkm_device hasn't subclassed nvkm_object in a long time.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
index 89da47234016..ccba4ae73cc5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
@@ -21,6 +21,7 @@
  */
 #include <core/ramht.h>
 #include <core/engine.h>
+#include <core/object.h>
 
 static u32
 nvkm_ramht_hash(struct nvkm_ramht *ramht, int chid, u32 handle)

commit 78a121d82da8aff3aca2a6a1c40f5061081760f0
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Sun Mar 6 16:06:06 2016 -0500

    drm/nouveau/core: use vzalloc for allocating ramht
    
    Most calls to nvkm_ramht_new use 0x8000 as the size. This results in a
    fairly sizeable chunk of memory to be allocated, which may not be
    available with kzalloc. Since this is done fairly rarely (once per
    channel), use vzalloc instead.
    
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
index 3216e157a8a0..89da47234016 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
@@ -131,7 +131,7 @@ nvkm_ramht_del(struct nvkm_ramht **pramht)
 	struct nvkm_ramht *ramht = *pramht;
 	if (ramht) {
 		nvkm_gpuobj_del(&ramht->gpuobj);
-		kfree(*pramht);
+		vfree(*pramht);
 		*pramht = NULL;
 	}
 }
@@ -143,8 +143,8 @@ nvkm_ramht_new(struct nvkm_device *device, u32 size, u32 align,
 	struct nvkm_ramht *ramht;
 	int ret, i;
 
-	if (!(ramht = *pramht = kzalloc(sizeof(*ramht) + (size >> 3) *
-					sizeof(*ramht->data), GFP_KERNEL)))
+	if (!(ramht = *pramht = vzalloc(sizeof(*ramht) +
+					(size >> 3) * sizeof(*ramht->data))))
 		return -ENOMEM;
 
 	ramht->device = device;

commit 68f3f702b6a430a8d1e909455a60d26c0f2da530
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/core: remove the remainder of the previous style
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
index 307d53269625..3216e157a8a0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
@@ -67,40 +67,27 @@ nvkm_ramht_update(struct nvkm_ramht *ramht, int co, struct nvkm_object *object,
 	data->chid = chid;
 	data->handle = handle;
 
-	if (!object) {
-		inst = 0;
-		goto done;
-	}
-
-	if (nv_iclass(object, NV_GPUOBJ_CLASS)) {
-		struct nvkm_gpuobj *gpuobj = nv_gpuobj(object);
-		if (ramht->device->card_type >= NV_50)
-			inst = gpuobj->node->offset;
-		else
-			inst = gpuobj->addr;
-		goto done;
-	}
+	if (object) {
+		ret = nvkm_object_bind(object, ramht->parent, 16, &data->inst);
+		if (ret) {
+			if (ret != -ENODEV) {
+				data->chid = -1;
+				return ret;
+			}
+			data->inst = NULL;
+		}
 
-	ret = nvkm_object_bind(object, ramht->parent, 16, &data->inst);
-	if (ret) {
-		if (ret != -ENODEV) {
-			data->chid = -1;
-			return ret;
+		if (data->inst) {
+			if (ramht->device->card_type >= NV_50)
+				inst = data->inst->node->offset;
+			else
+				inst = data->inst->addr;
 		}
-		data->inst = NULL;
-	}
 
-	if (data->inst) {
-		if (ramht->device->card_type >= NV_50)
-			inst = data->inst->node->offset;
-		else
-			inst = data->inst->addr;
+		if (addr < 0) context |= inst << -addr;
+		else          context |= inst >>  addr;
 	}
 
-done:
-	if (addr < 0) context |= inst << -addr;
-	else          context |= inst >>  addr;
-
 	nvkm_kmap(ramht->gpuobj);
 	nvkm_wo32(ramht->gpuobj, (co << 3) + 0, handle);
 	nvkm_wo32(ramht->gpuobj, (co << 3) + 4, context);

commit 1d2a1e53865266a67fb569705eba3ec992682721
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/ramht: remove dependence on namedb
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
index 061adedc6e2c..307d53269625 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
@@ -33,74 +33,143 @@ nvkm_ramht_hash(struct nvkm_ramht *ramht, int chid, u32 handle)
 	}
 
 	hash ^= chid << (ramht->bits - 4);
-	hash  = hash << 3;
 	return hash;
 }
 
-int
-nvkm_ramht_insert(struct nvkm_ramht *ramht, int chid, u32 handle, u32 context)
+struct nvkm_gpuobj *
+nvkm_ramht_search(struct nvkm_ramht *ramht, int chid, u32 handle)
 {
-	struct nvkm_gpuobj *gpuobj = &ramht->gpuobj;
-	int ret = -ENOSPC;
 	u32 co, ho;
 
 	co = ho = nvkm_ramht_hash(ramht, chid, handle);
-	nvkm_kmap(gpuobj);
 	do {
-		if (!nvkm_ro32(gpuobj, co + 4)) {
-			nvkm_wo32(gpuobj, co + 0, handle);
-			nvkm_wo32(gpuobj, co + 4, context);
-			ret = co;
-			break;
+		if (ramht->data[co].chid == chid) {
+			if (ramht->data[co].handle == handle)
+				return ramht->data[co].inst;
 		}
 
-		co += 8;
-		if (co >= nv_gpuobj(ramht)->size)
+		if (++co >= ramht->size)
 			co = 0;
 	} while (co != ho);
-	nvkm_done(gpuobj);
 
-	return ret;
+	return NULL;
+}
+
+static int
+nvkm_ramht_update(struct nvkm_ramht *ramht, int co, struct nvkm_object *object,
+		  int chid, int addr, u32 handle, u32 context)
+{
+	struct nvkm_ramht_data *data = &ramht->data[co];
+	u64 inst = 0x00000040; /* just non-zero for <=g8x fifo ramht */
+	int ret;
+
+	nvkm_gpuobj_del(&data->inst);
+	data->chid = chid;
+	data->handle = handle;
+
+	if (!object) {
+		inst = 0;
+		goto done;
+	}
+
+	if (nv_iclass(object, NV_GPUOBJ_CLASS)) {
+		struct nvkm_gpuobj *gpuobj = nv_gpuobj(object);
+		if (ramht->device->card_type >= NV_50)
+			inst = gpuobj->node->offset;
+		else
+			inst = gpuobj->addr;
+		goto done;
+	}
+
+	ret = nvkm_object_bind(object, ramht->parent, 16, &data->inst);
+	if (ret) {
+		if (ret != -ENODEV) {
+			data->chid = -1;
+			return ret;
+		}
+		data->inst = NULL;
+	}
+
+	if (data->inst) {
+		if (ramht->device->card_type >= NV_50)
+			inst = data->inst->node->offset;
+		else
+			inst = data->inst->addr;
+	}
+
+done:
+	if (addr < 0) context |= inst << -addr;
+	else          context |= inst >>  addr;
+
+	nvkm_kmap(ramht->gpuobj);
+	nvkm_wo32(ramht->gpuobj, (co << 3) + 0, handle);
+	nvkm_wo32(ramht->gpuobj, (co << 3) + 4, context);
+	nvkm_done(ramht->gpuobj);
+	return co + 1;
 }
 
 void
 nvkm_ramht_remove(struct nvkm_ramht *ramht, int cookie)
 {
-	struct nvkm_gpuobj *gpuobj = &ramht->gpuobj;
-	nvkm_kmap(gpuobj);
-	nvkm_wo32(gpuobj, cookie + 0, 0x00000000);
-	nvkm_wo32(gpuobj, cookie + 4, 0x00000000);
-	nvkm_done(gpuobj);
+	if (--cookie >= 0)
+		nvkm_ramht_update(ramht, cookie, NULL, -1, 0, 0, 0);
 }
 
-static struct nvkm_oclass
-nvkm_ramht_oclass = {
-	.handle = 0x0000abcd,
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = NULL,
-		.dtor = _nvkm_gpuobj_dtor,
-		.init = _nvkm_gpuobj_init,
-		.fini = _nvkm_gpuobj_fini,
-		.rd32 = _nvkm_gpuobj_rd32,
-		.wr32 = _nvkm_gpuobj_wr32,
-	},
-};
+int
+nvkm_ramht_insert(struct nvkm_ramht *ramht, struct nvkm_object *object,
+		  int chid, int addr, u32 handle, u32 context)
+{
+	u32 co, ho;
+
+	if (nvkm_ramht_search(ramht, chid, handle))
+		return -EEXIST;
+
+	co = ho = nvkm_ramht_hash(ramht, chid, handle);
+	do {
+		if (ramht->data[co].chid < 0) {
+			return nvkm_ramht_update(ramht, co, object, chid,
+						 addr, handle, context);
+		}
+
+		if (++co >= ramht->size)
+			co = 0;
+	} while (co != ho);
+
+	return -ENOSPC;
+}
+
+void
+nvkm_ramht_del(struct nvkm_ramht **pramht)
+{
+	struct nvkm_ramht *ramht = *pramht;
+	if (ramht) {
+		nvkm_gpuobj_del(&ramht->gpuobj);
+		kfree(*pramht);
+		*pramht = NULL;
+	}
+}
 
 int
-nvkm_ramht_new(struct nvkm_object *parent, struct nvkm_object *pargpu,
-	       u32 size, u32 align, struct nvkm_ramht **pramht)
+nvkm_ramht_new(struct nvkm_device *device, u32 size, u32 align,
+	       struct nvkm_gpuobj *parent, struct nvkm_ramht **pramht)
 {
 	struct nvkm_ramht *ramht;
-	int ret;
+	int ret, i;
 
-	ret = nvkm_gpuobj_create(parent, parent->engine ?
-				 &parent->engine->subdev.object : NULL, /* <nv50 ramht */
-				 &nvkm_ramht_oclass, 0, pargpu, size,
-				 align, NVOBJ_FLAG_ZERO_ALLOC, &ramht);
-	*pramht = ramht;
-	if (ret)
-		return ret;
+	if (!(ramht = *pramht = kzalloc(sizeof(*ramht) + (size >> 3) *
+					sizeof(*ramht->data), GFP_KERNEL)))
+		return -ENOMEM;
+
+	ramht->device = device;
+	ramht->parent = parent;
+	ramht->size = size >> 3;
+	ramht->bits = order_base_2(ramht->size);
+	for (i = 0; i < ramht->size; i++)
+		ramht->data[i].chid = -1;
 
-	ramht->bits = order_base_2(nv_gpuobj(ramht)->size >> 3);
-	return 0;
+	ret = nvkm_gpuobj_new(ramht->device, size, align, true,
+			      ramht->parent, &ramht->gpuobj);
+	if (ret)
+		nvkm_ramht_del(pramht);
+	return ret;
 }

commit d8e83994aaf6749b7124a219f5b46bd1329e2a08
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/imem: improve management of instance memory
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
index 4717af0800e9..061adedc6e2c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
@@ -22,8 +22,6 @@
 #include <core/ramht.h>
 #include <core/engine.h>
 
-#include <subdev/bar.h>
-
 static u32
 nvkm_ramht_hash(struct nvkm_ramht *ramht, int chid, u32 handle)
 {
@@ -43,7 +41,6 @@ int
 nvkm_ramht_insert(struct nvkm_ramht *ramht, int chid, u32 handle, u32 context)
 {
 	struct nvkm_gpuobj *gpuobj = &ramht->gpuobj;
-	struct nvkm_bar *bar = nvkm_bar(ramht);
 	int ret = -ENOSPC;
 	u32 co, ho;
 
@@ -53,8 +50,6 @@ nvkm_ramht_insert(struct nvkm_ramht *ramht, int chid, u32 handle, u32 context)
 		if (!nvkm_ro32(gpuobj, co + 4)) {
 			nvkm_wo32(gpuobj, co + 0, handle);
 			nvkm_wo32(gpuobj, co + 4, context);
-			if (bar)
-				bar->flush(bar);
 			ret = co;
 			break;
 		}
@@ -72,12 +67,9 @@ void
 nvkm_ramht_remove(struct nvkm_ramht *ramht, int cookie)
 {
 	struct nvkm_gpuobj *gpuobj = &ramht->gpuobj;
-	struct nvkm_bar *bar = nvkm_bar(ramht);
 	nvkm_kmap(gpuobj);
 	nvkm_wo32(gpuobj, cookie + 0, 0x00000000);
 	nvkm_wo32(gpuobj, cookie + 4, 0x00000000);
-	if (bar)
-		bar->flush(bar);
 	nvkm_done(gpuobj);
 }
 

commit cbea21e2ab658ca1256bfe5f4c535b2b1b9e4060
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/object: implement support for new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
index c61bb0fa93f6..4717af0800e9 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
@@ -102,7 +102,7 @@ nvkm_ramht_new(struct nvkm_object *parent, struct nvkm_object *pargpu,
 	int ret;
 
 	ret = nvkm_gpuobj_create(parent, parent->engine ?
-				 &parent->engine->subdev.object : parent, /* <nv50 ramht */
+				 &parent->engine->subdev.object : NULL, /* <nv50 ramht */
 				 &nvkm_ramht_oclass, 0, pargpu, size,
 				 align, NVOBJ_FLAG_ZERO_ALLOC, &ramht);
 	*pramht = ramht;

commit 45ea503161af6e94d593a59e8cca8981d0435d5c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:14 2015 +1000

    drm/nouveau/core: switch to gpuobj accessor macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
index ebd4d15479bd..c61bb0fa93f6 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
@@ -42,35 +42,43 @@ nvkm_ramht_hash(struct nvkm_ramht *ramht, int chid, u32 handle)
 int
 nvkm_ramht_insert(struct nvkm_ramht *ramht, int chid, u32 handle, u32 context)
 {
+	struct nvkm_gpuobj *gpuobj = &ramht->gpuobj;
 	struct nvkm_bar *bar = nvkm_bar(ramht);
+	int ret = -ENOSPC;
 	u32 co, ho;
 
 	co = ho = nvkm_ramht_hash(ramht, chid, handle);
+	nvkm_kmap(gpuobj);
 	do {
-		if (!nv_ro32(ramht, co + 4)) {
-			nv_wo32(ramht, co + 0, handle);
-			nv_wo32(ramht, co + 4, context);
+		if (!nvkm_ro32(gpuobj, co + 4)) {
+			nvkm_wo32(gpuobj, co + 0, handle);
+			nvkm_wo32(gpuobj, co + 4, context);
 			if (bar)
 				bar->flush(bar);
-			return co;
+			ret = co;
+			break;
 		}
 
 		co += 8;
 		if (co >= nv_gpuobj(ramht)->size)
 			co = 0;
 	} while (co != ho);
+	nvkm_done(gpuobj);
 
-	return -ENOMEM;
+	return ret;
 }
 
 void
 nvkm_ramht_remove(struct nvkm_ramht *ramht, int cookie)
 {
+	struct nvkm_gpuobj *gpuobj = &ramht->gpuobj;
 	struct nvkm_bar *bar = nvkm_bar(ramht);
-	nv_wo32(ramht, cookie + 0, 0x00000000);
-	nv_wo32(ramht, cookie + 4, 0x00000000);
+	nvkm_kmap(gpuobj);
+	nvkm_wo32(gpuobj, cookie + 0, 0x00000000);
+	nvkm_wo32(gpuobj, cookie + 4, 0x00000000);
 	if (bar)
 		bar->flush(bar);
+	nvkm_done(gpuobj);
 }
 
 static struct nvkm_oclass

commit 245dcfe96f6900dbf64e48a350badf4c90fabc2e
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 14:35:35 2015 +1000

    drm/nouveau/bar: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
index 0a382d0975b0..ebd4d15479bd 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
@@ -20,6 +20,7 @@
  * OTHER DEALINGS IN THE SOFTWARE.
  */
 #include <core/ramht.h>
+#include <core/engine.h>
 
 #include <subdev/bar.h>
 

commit 5025407b9862349d17b1dff25737aaef6520a439
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 14:11:21 2015 +1000

    drm/nouveau/core: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
index 25cd6f29072b..0a382d0975b0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
@@ -19,14 +19,12 @@
  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  * OTHER DEALINGS IN THE SOFTWARE.
  */
-
-#include <core/object.h>
 #include <core/ramht.h>
 
 #include <subdev/bar.h>
 
 static u32
-nouveau_ramht_hash(struct nouveau_ramht *ramht, int chid, u32 handle)
+nvkm_ramht_hash(struct nvkm_ramht *ramht, int chid, u32 handle)
 {
 	u32 hash = 0;
 
@@ -41,13 +39,12 @@ nouveau_ramht_hash(struct nouveau_ramht *ramht, int chid, u32 handle)
 }
 
 int
-nouveau_ramht_insert(struct nouveau_ramht *ramht, int chid,
-		     u32 handle, u32 context)
+nvkm_ramht_insert(struct nvkm_ramht *ramht, int chid, u32 handle, u32 context)
 {
-	struct nouveau_bar *bar = nouveau_bar(ramht);
+	struct nvkm_bar *bar = nvkm_bar(ramht);
 	u32 co, ho;
 
-	co = ho = nouveau_ramht_hash(ramht, chid, handle);
+	co = ho = nvkm_ramht_hash(ramht, chid, handle);
 	do {
 		if (!nv_ro32(ramht, co + 4)) {
 			nv_wo32(ramht, co + 0, handle);
@@ -66,39 +63,39 @@ nouveau_ramht_insert(struct nouveau_ramht *ramht, int chid,
 }
 
 void
-nouveau_ramht_remove(struct nouveau_ramht *ramht, int cookie)
+nvkm_ramht_remove(struct nvkm_ramht *ramht, int cookie)
 {
-	struct nouveau_bar *bar = nouveau_bar(ramht);
+	struct nvkm_bar *bar = nvkm_bar(ramht);
 	nv_wo32(ramht, cookie + 0, 0x00000000);
 	nv_wo32(ramht, cookie + 4, 0x00000000);
 	if (bar)
 		bar->flush(bar);
 }
 
-static struct nouveau_oclass
-nouveau_ramht_oclass = {
+static struct nvkm_oclass
+nvkm_ramht_oclass = {
 	.handle = 0x0000abcd,
-	.ofuncs = &(struct nouveau_ofuncs) {
+	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = NULL,
-		.dtor = _nouveau_gpuobj_dtor,
-		.init = _nouveau_gpuobj_init,
-		.fini = _nouveau_gpuobj_fini,
-		.rd32 = _nouveau_gpuobj_rd32,
-		.wr32 = _nouveau_gpuobj_wr32,
+		.dtor = _nvkm_gpuobj_dtor,
+		.init = _nvkm_gpuobj_init,
+		.fini = _nvkm_gpuobj_fini,
+		.rd32 = _nvkm_gpuobj_rd32,
+		.wr32 = _nvkm_gpuobj_wr32,
 	},
 };
 
 int
-nouveau_ramht_new(struct nouveau_object *parent, struct nouveau_object *pargpu,
-		  u32 size, u32 align, struct nouveau_ramht **pramht)
+nvkm_ramht_new(struct nvkm_object *parent, struct nvkm_object *pargpu,
+	       u32 size, u32 align, struct nvkm_ramht **pramht)
 {
-	struct nouveau_ramht *ramht;
+	struct nvkm_ramht *ramht;
 	int ret;
 
-	ret = nouveau_gpuobj_create(parent, parent->engine ?
-				    &parent->engine->subdev.object : parent, /* <nv50 ramht */
-				    &nouveau_ramht_oclass, 0, pargpu, size,
-				    align, NVOBJ_FLAG_ZERO_ALLOC, &ramht);
+	ret = nvkm_gpuobj_create(parent, parent->engine ?
+				 &parent->engine->subdev.object : parent, /* <nv50 ramht */
+				 &nvkm_ramht_oclass, 0, pargpu, size,
+				 align, NVOBJ_FLAG_ZERO_ALLOC, &ramht);
 	*pramht = ramht;
 	if (ret)
 		return ret;

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/core/ramht.c b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
new file mode 100644
index 000000000000..25cd6f29072b
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/core/ramht.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <core/object.h>
+#include <core/ramht.h>
+
+#include <subdev/bar.h>
+
+static u32
+nouveau_ramht_hash(struct nouveau_ramht *ramht, int chid, u32 handle)
+{
+	u32 hash = 0;
+
+	while (handle) {
+		hash ^= (handle & ((1 << ramht->bits) - 1));
+		handle >>= ramht->bits;
+	}
+
+	hash ^= chid << (ramht->bits - 4);
+	hash  = hash << 3;
+	return hash;
+}
+
+int
+nouveau_ramht_insert(struct nouveau_ramht *ramht, int chid,
+		     u32 handle, u32 context)
+{
+	struct nouveau_bar *bar = nouveau_bar(ramht);
+	u32 co, ho;
+
+	co = ho = nouveau_ramht_hash(ramht, chid, handle);
+	do {
+		if (!nv_ro32(ramht, co + 4)) {
+			nv_wo32(ramht, co + 0, handle);
+			nv_wo32(ramht, co + 4, context);
+			if (bar)
+				bar->flush(bar);
+			return co;
+		}
+
+		co += 8;
+		if (co >= nv_gpuobj(ramht)->size)
+			co = 0;
+	} while (co != ho);
+
+	return -ENOMEM;
+}
+
+void
+nouveau_ramht_remove(struct nouveau_ramht *ramht, int cookie)
+{
+	struct nouveau_bar *bar = nouveau_bar(ramht);
+	nv_wo32(ramht, cookie + 0, 0x00000000);
+	nv_wo32(ramht, cookie + 4, 0x00000000);
+	if (bar)
+		bar->flush(bar);
+}
+
+static struct nouveau_oclass
+nouveau_ramht_oclass = {
+	.handle = 0x0000abcd,
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = NULL,
+		.dtor = _nouveau_gpuobj_dtor,
+		.init = _nouveau_gpuobj_init,
+		.fini = _nouveau_gpuobj_fini,
+		.rd32 = _nouveau_gpuobj_rd32,
+		.wr32 = _nouveau_gpuobj_wr32,
+	},
+};
+
+int
+nouveau_ramht_new(struct nouveau_object *parent, struct nouveau_object *pargpu,
+		  u32 size, u32 align, struct nouveau_ramht **pramht)
+{
+	struct nouveau_ramht *ramht;
+	int ret;
+
+	ret = nouveau_gpuobj_create(parent, parent->engine ?
+				    &parent->engine->subdev.object : parent, /* <nv50 ramht */
+				    &nouveau_ramht_oclass, 0, pargpu, size,
+				    align, NVOBJ_FLAG_ZERO_ALLOC, &ramht);
+	*pramht = ramht;
+	if (ret)
+		return ret;
+
+	ramht->bits = order_base_2(nv_gpuobj(ramht)->size >> 3);
+	return 0;
+}
