commit acafe7e30216166a17e6e226aadc3ecb63993242
Author: Kees Cook <keescook@chromium.org>
Date:   Tue May 8 13:45:50 2018 -0700

    treewide: Use struct_size() for kmalloc()-family
    
    One of the more common cases of allocation size calculations is finding
    the size of a structure that has a zero-sized array at the end, along
    with memory for some number of elements for that array. For example:
    
    struct foo {
        int stuff;
        void *entry[];
    };
    
    instance = kmalloc(sizeof(struct foo) + sizeof(void *) * count, GFP_KERNEL);
    
    Instead of leaving these open-coded and prone to type mistakes, we can
    now use the new struct_size() helper:
    
    instance = kmalloc(struct_size(instance, entry, count), GFP_KERNEL);
    
    This patch makes the changes for kmalloc()-family (and kvmalloc()-family)
    uses. It was done via automatic conversion with manual review for the
    "CHECKME" non-standard cases noted below, using the following Coccinelle
    script:
    
    // pkey_cache = kmalloc(sizeof *pkey_cache + tprops->pkey_tbl_len *
    //                      sizeof *pkey_cache->table, GFP_KERNEL);
    @@
    identifier alloc =~ "kmalloc|kzalloc|kvmalloc|kvzalloc";
    expression GFP;
    identifier VAR, ELEMENT;
    expression COUNT;
    @@
    
    - alloc(sizeof(*VAR) + COUNT * sizeof(*VAR->ELEMENT), GFP)
    + alloc(struct_size(VAR, ELEMENT, COUNT), GFP)
    
    // mr = kzalloc(sizeof(*mr) + m * sizeof(mr->map[0]), GFP_KERNEL);
    @@
    identifier alloc =~ "kmalloc|kzalloc|kvmalloc|kvzalloc";
    expression GFP;
    identifier VAR, ELEMENT;
    expression COUNT;
    @@
    
    - alloc(sizeof(*VAR) + COUNT * sizeof(VAR->ELEMENT[0]), GFP)
    + alloc(struct_size(VAR, ELEMENT, COUNT), GFP)
    
    // Same pattern, but can't trivially locate the trailing element name,
    // or variable name.
    @@
    identifier alloc =~ "kmalloc|kzalloc|kvmalloc|kvzalloc";
    expression GFP;
    expression SOMETHING, COUNT, ELEMENT;
    @@
    
    - alloc(sizeof(SOMETHING) + COUNT * sizeof(ELEMENT), GFP)
    + alloc(CHECKME_struct_size(&SOMETHING, ELEMENT, COUNT), GFP)
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 53859b6254d6..b2785bee418e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -779,8 +779,8 @@ nvkm_perfdom_new(struct nvkm_pm *pm, const char *name, u32 mask,
 
 		sdom = spec;
 		while (sdom->signal_nr) {
-			dom = kzalloc(sizeof(*dom) + sdom->signal_nr *
-				      sizeof(*dom->signal), GFP_KERNEL);
+			dom = kzalloc(struct_size(dom, signal, sdom->signal_nr),
+				      GFP_KERNEL);
 			if (!dom)
 				return -ENOMEM;
 

commit ee0d58100296d9b1a2aa23b913c09e8f297449a4
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Dec 4 15:54:26 2017 +0100

    drm/nouveau: nouveau: use correct string length
    
    gcc-8 reports
    
    drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c: In function 'nvkm_perfmon_mthd':
    include/linux/string.h:265:9: error: '__builtin_strncpy' specified bound 64 equals destination size [-Werror=stringop-truncation]
    
    We need one less byte or call strlcpy() to make it a
    nul-terminated string.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index dde89a4a0f5b..53859b6254d6 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -462,7 +462,7 @@ nvkm_perfmon_mthd_query_domain(struct nvkm_perfmon *perfmon,
 
 		args->v0.id         = di;
 		args->v0.signal_nr  = nvkm_perfdom_count_perfsig(dom);
-		strncpy(args->v0.name, dom->name, sizeof(args->v0.name));
+		strncpy(args->v0.name, dom->name, sizeof(args->v0.name) - 1);
 
 		/* Currently only global counters (PCOUNTER) are implemented
 		 * but this will be different for local counters (MP). */
@@ -514,7 +514,7 @@ nvkm_perfmon_mthd_query_signal(struct nvkm_perfmon *perfmon,
 				 "/%s/%02x", dom->name, si);
 		} else {
 			strncpy(args->v0.name, sig->name,
-				sizeof(args->v0.name));
+				sizeof(args->v0.name) - 1);
 		}
 
 		args->v0.signal = si;
@@ -572,7 +572,7 @@ nvkm_perfmon_mthd_query_source(struct nvkm_perfmon *perfmon,
 
 		args->v0.source = sig->source[si];
 		args->v0.mask   = src->mask;
-		strncpy(args->v0.name, src->name, sizeof(args->v0.name));
+		strncpy(args->v0.name, src->name, sizeof(args->v0.name) - 1);
 	}
 
 	if (++si < source_nr) {

commit e08a1d97d33e2ac05cd368b955f9fdc2823f15fd
Author: Baoyou Xie <baoyou.xie@linaro.org>
Date:   Mon Oct 24 11:09:03 2016 +0800

    drm/nouveau: mark symbols static where possible
    
    We get a few warnings when building kernel with W=1:
    drivers/gpu/drm/nouveau/nvkm/subdev/bios/fan.c:29:1: warning: no previous prototype for 'nvbios_fan_table' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/bios/fan.c:56:1: warning: no previous prototype for 'nvbios_fan_entry' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/clk/gt215.c:184:1: warning: no previous prototype for 'gt215_clk_info' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c:99:1: warning: no previous prototype for 'gt215_link_train_calc' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c:153:1: warning: no previous prototype for 'gt215_link_train' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c:271:1: warning: no previous prototype for 'gt215_link_train_init' [-Wmissing-prototypes]
    ....
    
    In fact, both functions are only used in the file in which they are
    declared and don't need a declaration, but can be made static.
    So this patch marks these functions with 'static'.
    
    Signed-off-by: Baoyou Xie <baoyou.xie@linaro.org>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 8616636ad7b4..dde89a4a0f5b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -71,7 +71,7 @@ nvkm_perfdom_find(struct nvkm_pm *pm, int di)
 	return NULL;
 }
 
-struct nvkm_perfsig *
+static struct nvkm_perfsig *
 nvkm_perfsig_find(struct nvkm_pm *pm, u8 di, u8 si, struct nvkm_perfdom **pdom)
 {
 	struct nvkm_perfdom *dom = *pdom;
@@ -699,7 +699,7 @@ nvkm_pm_oclass_get(struct nvkm_oclass *oclass, int index,
 	return 1;
 }
 
-int
+static int
 nvkm_perfsrc_new(struct nvkm_pm *pm, struct nvkm_perfsig *sig,
 		 const struct nvkm_specsrc *spec)
 {

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index f19fabef8d73..8616636ad7b4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -863,5 +863,5 @@ nvkm_pm_ctor(const struct nvkm_pm_func *func, struct nvkm_device *device,
 	pm->func = func;
 	INIT_LIST_HEAD(&pm->domains);
 	INIT_LIST_HEAD(&pm->sources);
-	return nvkm_engine_ctor(&nvkm_pm, device, index, 0, true, &pm->engine);
+	return nvkm_engine_ctor(&nvkm_pm, device, index, true, &pm->engine);
 }

commit f01c4e682c941ba70e0ebec44db754844a1b9b82
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon Nov 9 09:21:27 2015 +1000

    drm/nouveau/nvif: modify nvif_unvers/nvif_unpack macros to be more obvious
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 344b1e5d7f85..f19fabef8d73 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -212,10 +212,10 @@ nvkm_perfdom_init(struct nvkm_perfdom *dom, void *data, u32 size)
 	} *args = data;
 	struct nvkm_object *object = &dom->object;
 	struct nvkm_pm *pm = dom->perfmon->pm;
-	int ret, i;
+	int ret = -ENOSYS, i;
 
 	nvif_ioctl(object, "perfdom init size %d\n", size);
-	if (nvif_unvers(args->none)) {
+	if (!(ret = nvif_unvers(ret, &data, &size, args->none))) {
 		nvif_ioctl(object, "perfdom init\n");
 	} else
 		return ret;
@@ -242,10 +242,10 @@ nvkm_perfdom_sample(struct nvkm_perfdom *dom, void *data, u32 size)
 	} *args = data;
 	struct nvkm_object *object = &dom->object;
 	struct nvkm_pm *pm = dom->perfmon->pm;
-	int ret;
+	int ret = -ENOSYS;
 
 	nvif_ioctl(object, "perfdom sample size %d\n", size);
-	if (nvif_unvers(args->none)) {
+	if (!(ret = nvif_unvers(ret, &data, &size, args->none))) {
 		nvif_ioctl(object, "perfdom sample\n");
 	} else
 		return ret;
@@ -266,10 +266,10 @@ nvkm_perfdom_read(struct nvkm_perfdom *dom, void *data, u32 size)
 	} *args = data;
 	struct nvkm_object *object = &dom->object;
 	struct nvkm_pm *pm = dom->perfmon->pm;
-	int ret, i;
+	int ret = -ENOSYS, i;
 
 	nvif_ioctl(object, "perfdom read size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 		nvif_ioctl(object, "perfdom read vers %d\n", args->v0.version);
 	} else
 		return ret;
@@ -376,10 +376,10 @@ nvkm_perfdom_new_(struct nvkm_perfmon *perfmon,
 	struct nvkm_perfctr *ctr[4] = {};
 	struct nvkm_perfdom *dom;
 	int c, s, m;
-	int ret;
+	int ret = -ENOSYS;
 
 	nvif_ioctl(parent, "create perfdom size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 		nvif_ioctl(parent, "create perfdom vers %d dom %d mode %02x\n",
 			   args->v0.version, args->v0.domain, args->v0.mode);
 	} else
@@ -441,10 +441,10 @@ nvkm_perfmon_mthd_query_domain(struct nvkm_perfmon *perfmon,
 	struct nvkm_pm *pm = perfmon->pm;
 	struct nvkm_perfdom *dom;
 	u8 domain_nr;
-	int di, ret;
+	int di, ret = -ENOSYS;
 
 	nvif_ioctl(object, "perfmon query domain size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 		nvif_ioctl(object, "perfmon domain vers %d iter %02x\n",
 			   args->v0.version, args->v0.iter);
 		di = (args->v0.iter & 0xff) - 1;
@@ -492,10 +492,10 @@ nvkm_perfmon_mthd_query_signal(struct nvkm_perfmon *perfmon,
 	struct nvkm_perfsig *sig;
 	const bool all = nvkm_boolopt(device->cfgopt, "NvPmShowAll", false);
 	const bool raw = nvkm_boolopt(device->cfgopt, "NvPmUnnamed", all);
-	int ret, si;
+	int ret = -ENOSYS, si;
 
 	nvif_ioctl(object, "perfmon query signal size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 		nvif_ioctl(object,
 			   "perfmon query signal vers %d dom %d iter %04x\n",
 			   args->v0.version, args->v0.domain, args->v0.iter);
@@ -545,10 +545,10 @@ nvkm_perfmon_mthd_query_source(struct nvkm_perfmon *perfmon,
 	struct nvkm_perfsig *sig;
 	struct nvkm_perfsrc *src;
 	u8 source_nr = 0;
-	int si, ret;
+	int si, ret = -ENOSYS;
 
 	nvif_ioctl(object, "perfmon query source size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 		nvif_ioctl(object,
 			   "perfmon source vers %d dom %d sig %02x iter %02x\n",
 			   args->v0.version, args->v0.domain, args->v0.signal,

commit 75445a4d6423e7f742fcfe2b06eee3ce9c7de4c0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Nov 8 12:12:15 2015 +1000

    drm/nouveau/nvif: split out perfmon interface definitions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 808a23914c4d..344b1e5d7f85 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -27,6 +27,8 @@
 #include <core/option.h>
 
 #include <nvif/class.h>
+#include <nvif/if0002.h>
+#include <nvif/if0003.h>
 #include <nvif/ioctl.h>
 #include <nvif/unpack.h>
 

commit 08f7633c1de8007c3735764d5ca0c1bde4239b84
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Nov 8 10:18:19 2015 +1000

    drm/nouveau/nvif: move internal class identifiers to class.h
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 2721592d3031..808a23914c4d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -612,7 +612,7 @@ nvkm_perfmon_child_get(struct nvkm_object *object, int index,
 		       struct nvkm_oclass *oclass)
 {
 	if (index == 0) {
-		oclass->base.oclass = NVIF_IOCTL_NEW_V0_PERFDOM;
+		oclass->base.oclass = NVIF_CLASS_PERFDOM;
 		oclass->base.minver = 0;
 		oclass->base.maxver = 0;
 		oclass->ctor = nvkm_perfmon_child_new;
@@ -679,7 +679,7 @@ nvkm_pm_oclass_new(struct nvkm_device *device, const struct nvkm_oclass *oclass,
 
 static const struct nvkm_device_oclass
 nvkm_pm_oclass = {
-	.base.oclass = NVIF_IOCTL_NEW_V0_PERFMON,
+	.base.oclass = NVIF_CLASS_PERFMON,
 	.base.minver = -1,
 	.base.maxver = -1,
 	.ctor = nvkm_pm_oclass_new,

commit 354a22496613366833edfe29300a6bfe6482255c
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Oct 11 14:18:09 2015 +0200

    drm/nouveau/disp,pm: constify nvkm_object_func structures
    
    These nvkm_object_func structures are never modified.  All other
    nvkm_object_func structures are declared as const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 0db9be202c42..2721592d3031 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -633,7 +633,7 @@ nvkm_perfmon_dtor(struct nvkm_object *object)
 	return perfmon;
 }
 
-static struct nvkm_object_func
+static const struct nvkm_object_func
 nvkm_perfmon = {
 	.dtor = nvkm_perfmon_dtor,
 	.mthd = nvkm_perfmon_mthd,

commit 97070f23c60869830039b216ff88230f54ef7107
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/pm: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 5b4ab63809be..0db9be202c42 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -203,13 +203,13 @@ nvkm_perfsrc_disable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
  * Perfdom object classes
  ******************************************************************************/
 static int
-nvkm_perfdom_init(struct nvkm_object *object, void *data, u32 size)
+nvkm_perfdom_init(struct nvkm_perfdom *dom, void *data, u32 size)
 {
 	union {
 		struct nvif_perfdom_init none;
 	} *args = data;
-	struct nvkm_pm *pm = (void *)object->engine;
-	struct nvkm_perfdom *dom = (void *)object;
+	struct nvkm_object *object = &dom->object;
+	struct nvkm_pm *pm = dom->perfmon->pm;
 	int ret, i;
 
 	nvif_ioctl(object, "perfdom init size %d\n", size);
@@ -233,13 +233,13 @@ nvkm_perfdom_init(struct nvkm_object *object, void *data, u32 size)
 }
 
 static int
-nvkm_perfdom_sample(struct nvkm_object *object, void *data, u32 size)
+nvkm_perfdom_sample(struct nvkm_perfdom *dom, void *data, u32 size)
 {
 	union {
 		struct nvif_perfdom_sample none;
 	} *args = data;
-	struct nvkm_pm *pm = (void *)object->engine;
-	struct nvkm_perfdom *dom;
+	struct nvkm_object *object = &dom->object;
+	struct nvkm_pm *pm = dom->perfmon->pm;
 	int ret;
 
 	nvif_ioctl(object, "perfdom sample size %d\n", size);
@@ -257,13 +257,13 @@ nvkm_perfdom_sample(struct nvkm_object *object, void *data, u32 size)
 }
 
 static int
-nvkm_perfdom_read(struct nvkm_object *object, void *data, u32 size)
+nvkm_perfdom_read(struct nvkm_perfdom *dom, void *data, u32 size)
 {
 	union {
 		struct nvif_perfdom_read_v0 v0;
 	} *args = data;
-	struct nvkm_pm *pm = (void *)object->engine;
-	struct nvkm_perfdom *dom = (void *)object;
+	struct nvkm_object *object = &dom->object;
+	struct nvkm_pm *pm = dom->perfmon->pm;
 	int ret, i;
 
 	nvif_ioctl(object, "perfdom read size %d\n", size);
@@ -290,13 +290,14 @@ nvkm_perfdom_read(struct nvkm_object *object, void *data, u32 size)
 static int
 nvkm_perfdom_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
+	struct nvkm_perfdom *dom = nvkm_perfdom(object);
 	switch (mthd) {
 	case NVIF_PERFDOM_V0_INIT:
-		return nvkm_perfdom_init(object, data, size);
+		return nvkm_perfdom_init(dom, data, size);
 	case NVIF_PERFDOM_V0_SAMPLE:
-		return nvkm_perfdom_sample(object, data, size);
+		return nvkm_perfdom_sample(dom, data, size);
 	case NVIF_PERFDOM_V0_READ:
-		return nvkm_perfdom_read(object, data, size);
+		return nvkm_perfdom_read(dom, data, size);
 	default:
 		break;
 	}
@@ -304,9 +305,9 @@ nvkm_perfdom_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 }
 
 static void *
-nvkm_perfdom_dtor(struct nvkm_object *base)
+nvkm_perfdom_dtor(struct nvkm_object *object)
 {
-	struct nvkm_perfdom *dom = nvkm_perfdom(base);
+	struct nvkm_perfdom *dom = nvkm_perfdom(object);
 	struct nvkm_pm *pm = dom->perfmon->pm;
 	int i;
 
@@ -607,7 +608,7 @@ nvkm_perfmon_child_new(const struct nvkm_oclass *oclass, void *data, u32 size,
 }
 
 static int
-nvkm_perfmon_child_get(struct nvkm_object *base, int index,
+nvkm_perfmon_child_get(struct nvkm_object *object, int index,
 		       struct nvkm_oclass *oclass)
 {
 	if (index == 0) {
@@ -621,9 +622,9 @@ nvkm_perfmon_child_get(struct nvkm_object *base, int index,
 }
 
 static void *
-nvkm_perfmon_dtor(struct nvkm_object *base)
+nvkm_perfmon_dtor(struct nvkm_object *object)
 {
-	struct nvkm_perfmon *perfmon = nvkm_perfmon(base);
+	struct nvkm_perfmon *perfmon = nvkm_perfmon(object);
 	struct nvkm_pm *pm = perfmon->pm;
 	mutex_lock(&pm->engine.subdev.mutex);
 	if (pm->perfmon == &perfmon->object)
@@ -816,24 +817,19 @@ nvkm_perfdom_new(struct nvkm_pm *pm, const char *name, u32 mask,
 	return 0;
 }
 
-int
-_nvkm_pm_fini(struct nvkm_object *object, bool suspend)
-{
-	struct nvkm_pm *pm = (void *)object;
-	return nvkm_engine_fini_old(&pm->engine, suspend);
-}
-
-int
-_nvkm_pm_init(struct nvkm_object *object)
+static int
+nvkm_pm_fini(struct nvkm_engine *engine, bool suspend)
 {
-	struct nvkm_pm *pm = (void *)object;
-	return nvkm_engine_init_old(&pm->engine);
+	struct nvkm_pm *pm = nvkm_pm(engine);
+	if (pm->func->fini)
+		pm->func->fini(pm);
+	return 0;
 }
 
-void
-_nvkm_pm_dtor(struct nvkm_object *object)
+static void *
+nvkm_pm_dtor(struct nvkm_engine *engine)
 {
-	struct nvkm_pm *pm = (void *)object;
+	struct nvkm_pm *pm = nvkm_pm(engine);
 	struct nvkm_perfdom *dom, *next_dom;
 	struct nvkm_perfsrc *src, *next_src;
 
@@ -848,30 +844,22 @@ _nvkm_pm_dtor(struct nvkm_object *object)
 		kfree(src);
 	}
 
-	nvkm_engine_destroy(&pm->engine);
+	return pm;
 }
 
 static const struct nvkm_engine_func
 nvkm_pm = {
+	.dtor = nvkm_pm_dtor,
+	.fini = nvkm_pm_fini,
 	.base.sclass = nvkm_pm_oclass_get,
 };
 
 int
-nvkm_pm_create_(struct nvkm_object *parent, struct nvkm_object *engine,
-		struct nvkm_oclass *oclass, int length, void **pobject)
+nvkm_pm_ctor(const struct nvkm_pm_func *func, struct nvkm_device *device,
+	     int index, struct nvkm_pm *pm)
 {
-	struct nvkm_pm *pm;
-	int ret;
-
-	ret = nvkm_engine_create_(parent, engine, oclass, true, "PPM",
-				  "pm", length, pobject);
-	pm = *pobject;
-	if (ret)
-		return ret;
-
-	pm->engine.func = &nvkm_pm;
-
+	pm->func = func;
 	INIT_LIST_HEAD(&pm->domains);
 	INIT_LIST_HEAD(&pm->sources);
-	return 0;
+	return nvkm_engine_ctor(&nvkm_pm, device, index, 0, true, &pm->engine);
 }

commit 5ffeb84b8eba71b4f88af6997db843ddf68149e0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/pm: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 90a7d89cc019..5b4ab63809be 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -25,7 +25,6 @@
 
 #include <core/client.h>
 #include <core/option.h>
-#include <core/parent.h>
 
 #include <nvif/class.h>
 #include <nvif/ioctl.h>
@@ -304,11 +303,11 @@ nvkm_perfdom_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	return -EINVAL;
 }
 
-static void
-nvkm_perfdom_dtor(struct nvkm_object *object)
+static void *
+nvkm_perfdom_dtor(struct nvkm_object *base)
 {
-	struct nvkm_pm *pm = (void *)object->engine;
-	struct nvkm_perfdom *dom = (void *)object;
+	struct nvkm_perfdom *dom = nvkm_perfdom(base);
+	struct nvkm_pm *pm = dom->perfmon->pm;
 	int i;
 
 	for (i = 0; i < 4; i++) {
@@ -320,7 +319,8 @@ nvkm_perfdom_dtor(struct nvkm_object *object)
 		}
 		kfree(ctr);
 	}
-	nvkm_object_destroy(&dom->base);
+
+	return dom;
 }
 
 static int
@@ -353,15 +353,22 @@ nvkm_perfctr_new(struct nvkm_perfdom *dom, int slot, u8 domain,
 	return 0;
 }
 
+static const struct nvkm_object_func
+nvkm_perfdom = {
+	.dtor = nvkm_perfdom_dtor,
+	.mthd = nvkm_perfdom_mthd,
+};
+
 static int
-nvkm_perfdom_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-		  struct nvkm_oclass *oclass, void *data, u32 size,
+nvkm_perfdom_new_(struct nvkm_perfmon *perfmon,
+		  const struct nvkm_oclass *oclass, void *data, u32 size,
 		  struct nvkm_object **pobject)
 {
 	union {
 		struct nvif_perfdom_v0 v0;
 	} *args = data;
-	struct nvkm_pm *pm = (void *)engine;
+	struct nvkm_pm *pm = perfmon->pm;
+	struct nvkm_object *parent = oclass->parent;
 	struct nvkm_perfdom *sdom = NULL;
 	struct nvkm_perfctr *ctr[4] = {};
 	struct nvkm_perfdom *dom;
@@ -403,10 +410,11 @@ nvkm_perfdom_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (!sdom)
 		return -EINVAL;
 
-	ret = nvkm_object_create(parent, engine, oclass, 0, &dom);
-	*pobject = nv_object(dom);
-	if (ret)
-		return ret;
+	if (!(dom = kzalloc(sizeof(*dom), GFP_KERNEL)))
+		return -ENOMEM;
+	nvkm_object_ctor(&nvkm_perfdom, oclass, &dom->object);
+	dom->perfmon = perfmon;
+	*pobject = &dom->object;
 
 	dom->func = sdom->func;
 	dom->addr = sdom->addr;
@@ -416,25 +424,18 @@ nvkm_perfdom_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	return 0;
 }
 
-static struct nvkm_ofuncs
-nvkm_perfdom_ofuncs = {
-	.ctor = nvkm_perfdom_ctor,
-	.dtor = nvkm_perfdom_dtor,
-	.init = _nvkm_object_init,
-	.fini = _nvkm_object_fini,
-	.mthd = nvkm_perfdom_mthd,
-};
-
 /*******************************************************************************
  * Perfmon object classes
  ******************************************************************************/
 static int
-nvkm_perfmon_mthd_query_domain(struct nvkm_object *object, void *data, u32 size)
+nvkm_perfmon_mthd_query_domain(struct nvkm_perfmon *perfmon,
+			       void *data, u32 size)
 {
 	union {
 		struct nvif_perfmon_query_domain_v0 v0;
 	} *args = data;
-	struct nvkm_pm *pm = (void *)object->engine;
+	struct nvkm_object *object = &perfmon->object;
+	struct nvkm_pm *pm = perfmon->pm;
 	struct nvkm_perfdom *dom;
 	u8 domain_nr;
 	int di, ret;
@@ -475,13 +476,15 @@ nvkm_perfmon_mthd_query_domain(struct nvkm_object *object, void *data, u32 size)
 }
 
 static int
-nvkm_perfmon_mthd_query_signal(struct nvkm_object *object, void *data, u32 size)
+nvkm_perfmon_mthd_query_signal(struct nvkm_perfmon *perfmon,
+			       void *data, u32 size)
 {
 	union {
 		struct nvif_perfmon_query_signal_v0 v0;
 	} *args = data;
-	struct nvkm_device *device = nv_device(object);
-	struct nvkm_pm *pm = (void *)object->engine;
+	struct nvkm_object *object = &perfmon->object;
+	struct nvkm_pm *pm = perfmon->pm;
+	struct nvkm_device *device = pm->engine.subdev.device;
 	struct nvkm_perfdom *dom;
 	struct nvkm_perfsig *sig;
 	const bool all = nvkm_boolopt(device->cfgopt, "NvPmShowAll", false);
@@ -527,12 +530,14 @@ nvkm_perfmon_mthd_query_signal(struct nvkm_object *object, void *data, u32 size)
 }
 
 static int
-nvkm_perfmon_mthd_query_source(struct nvkm_object *object, void *data, u32 size)
+nvkm_perfmon_mthd_query_source(struct nvkm_perfmon *perfmon,
+			       void *data, u32 size)
 {
 	union {
 		struct nvif_perfmon_query_source_v0 v0;
 	} *args = data;
-	struct nvkm_pm *pm = (void *)object->engine;
+	struct nvkm_object *object = &perfmon->object;
+	struct nvkm_pm *pm = perfmon->pm;
 	struct nvkm_perfdom *dom = NULL;
 	struct nvkm_perfsig *sig;
 	struct nvkm_perfsrc *src;
@@ -579,117 +584,118 @@ nvkm_perfmon_mthd_query_source(struct nvkm_object *object, void *data, u32 size)
 static int
 nvkm_perfmon_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
+	struct nvkm_perfmon *perfmon = nvkm_perfmon(object);
 	switch (mthd) {
 	case NVIF_PERFMON_V0_QUERY_DOMAIN:
-		return nvkm_perfmon_mthd_query_domain(object, data, size);
+		return nvkm_perfmon_mthd_query_domain(perfmon, data, size);
 	case NVIF_PERFMON_V0_QUERY_SIGNAL:
-		return nvkm_perfmon_mthd_query_signal(object, data, size);
+		return nvkm_perfmon_mthd_query_signal(perfmon, data, size);
 	case NVIF_PERFMON_V0_QUERY_SOURCE:
-		return nvkm_perfmon_mthd_query_source(object, data, size);
+		return nvkm_perfmon_mthd_query_source(perfmon, data, size);
 	default:
 		break;
 	}
 	return -EINVAL;
 }
 
-static struct nvkm_oclass
-nvkm_perfmon_sclass[] = {
-	{ .handle = NVIF_IOCTL_NEW_V0_PERFDOM,
-	  .ofuncs = &nvkm_perfdom_ofuncs,
-	},
-	{}
-};
+static int
+nvkm_perfmon_child_new(const struct nvkm_oclass *oclass, void *data, u32 size,
+		       struct nvkm_object **pobject)
+{
+	struct nvkm_perfmon *perfmon = nvkm_perfmon(oclass->parent);
+	return nvkm_perfdom_new_(perfmon, oclass, data, size, pobject);
+}
 
 static int
-nvkm_perfmon_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-		  struct nvkm_oclass *oclass, void *data, u32 size,
-		  struct nvkm_object **pobject)
+nvkm_perfmon_child_get(struct nvkm_object *base, int index,
+		       struct nvkm_oclass *oclass)
 {
-	struct nvkm_parent *perfmon;
-	int ret = nvkm_parent_create(parent, engine, oclass, 0,
-				     nvkm_perfmon_sclass, 0, &perfmon);
-	*pobject = perfmon ? &perfmon->object : NULL;
-	return ret;
+	if (index == 0) {
+		oclass->base.oclass = NVIF_IOCTL_NEW_V0_PERFDOM;
+		oclass->base.minver = 0;
+		oclass->base.maxver = 0;
+		oclass->ctor = nvkm_perfmon_child_new;
+		return 0;
+	}
+	return -EINVAL;
 }
 
-static struct nvkm_ofuncs
-nvkm_perfmon_ofuncs = {
-	.ctor = nvkm_perfmon_ctor,
-	.dtor = _nvkm_parent_dtor,
-	.init = _nvkm_parent_init,
-	.fini = _nvkm_parent_fini,
-	.mthd = nvkm_perfmon_mthd,
-};
+static void *
+nvkm_perfmon_dtor(struct nvkm_object *base)
+{
+	struct nvkm_perfmon *perfmon = nvkm_perfmon(base);
+	struct nvkm_pm *pm = perfmon->pm;
+	mutex_lock(&pm->engine.subdev.mutex);
+	if (pm->perfmon == &perfmon->object)
+		pm->perfmon = NULL;
+	mutex_unlock(&pm->engine.subdev.mutex);
+	return perfmon;
+}
 
-struct nvkm_oclass
-nvkm_pm_sclass[] = {
-	{
-	  .handle = NVIF_IOCTL_NEW_V0_PERFMON,
-	  .ofuncs = &nvkm_perfmon_ofuncs,
-	},
-	{},
+static struct nvkm_object_func
+nvkm_perfmon = {
+	.dtor = nvkm_perfmon_dtor,
+	.mthd = nvkm_perfmon_mthd,
+	.sclass = nvkm_perfmon_child_get,
 };
 
-/*******************************************************************************
- * PPM context
- ******************************************************************************/
-static void
-nvkm_perfctx_dtor(struct nvkm_object *object)
+static int
+nvkm_perfmon_new(struct nvkm_pm *pm, const struct nvkm_oclass *oclass,
+		 void *data, u32 size, struct nvkm_object **pobject)
 {
-	struct nvkm_pm *pm = (void *)object->engine;
-	struct nvkm_perfctx *ctx = (void *)object;
+	struct nvkm_perfmon *perfmon;
 
-	nvkm_gpuobj_destroy(&ctx->base);
-	mutex_lock(&nv_subdev(pm)->mutex);
-	if (pm->context == ctx)
-		pm->context = NULL;
-	mutex_unlock(&nv_subdev(pm)->mutex);
+	if (!(perfmon = kzalloc(sizeof(*perfmon), GFP_KERNEL)))
+		return -ENOMEM;
+	nvkm_object_ctor(&nvkm_perfmon, oclass, &perfmon->object);
+	perfmon->pm = pm;
+	*pobject = &perfmon->object;
+	return 0;
 }
 
+/*******************************************************************************
+ * PPM engine/subdev functions
+ ******************************************************************************/
+
 static int
-nvkm_perfctx_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-		  struct nvkm_oclass *oclass, void *data, u32 size,
-		  struct nvkm_object **pobject)
+nvkm_pm_oclass_new(struct nvkm_device *device, const struct nvkm_oclass *oclass,
+		   void *data, u32 size, struct nvkm_object **pobject)
 {
-	struct nvkm_pm *pm = (void *)engine;
-	struct nvkm_perfctx *ctx;
+	struct nvkm_pm *pm = nvkm_pm(oclass->engine);
 	int ret;
 
-	/* no context needed for perfdom objects... */
-	if (parent->parent != &nvkm_client(parent)->object) {
-		atomic_inc(&parent->refcount);
-		*pobject = parent;
-		return 1;
-	}
-
-	ret = nvkm_gpuobj_create(parent, engine, oclass, 0, NULL, 0, 0, 0, &ctx);
-	*pobject = nv_object(ctx);
+	ret = nvkm_perfmon_new(pm, oclass, data, size, pobject);
 	if (ret)
 		return ret;
 
-	mutex_lock(&nv_subdev(pm)->mutex);
-	if (pm->context == NULL)
-		pm->context = ctx;
-	if (ctx != pm->context)
-		ret = -EBUSY;
-	mutex_unlock(&nv_subdev(pm)->mutex);
-
+	mutex_lock(&pm->engine.subdev.mutex);
+	if (pm->perfmon == NULL)
+		pm->perfmon = *pobject;
+	ret = (pm->perfmon == *pobject) ? 0 : -EBUSY;
+	mutex_unlock(&pm->engine.subdev.mutex);
 	return ret;
 }
 
-struct nvkm_oclass
-nvkm_pm_cclass = {
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nvkm_perfctx_ctor,
-		.dtor = nvkm_perfctx_dtor,
-		.init = _nvkm_gpuobj_init,
-		.fini = _nvkm_gpuobj_fini,
-	},
+static const struct nvkm_device_oclass
+nvkm_pm_oclass = {
+	.base.oclass = NVIF_IOCTL_NEW_V0_PERFMON,
+	.base.minver = -1,
+	.base.maxver = -1,
+	.ctor = nvkm_pm_oclass_new,
 };
 
-/*******************************************************************************
- * PPM engine/subdev functions
- ******************************************************************************/
+static int
+nvkm_pm_oclass_get(struct nvkm_oclass *oclass, int index,
+		   const struct nvkm_device_oclass **class)
+{
+	if (index == 0) {
+		oclass->base = nvkm_pm_oclass.base;
+		*class = &nvkm_pm_oclass;
+		return index;
+	}
+	return 1;
+}
+
 int
 nvkm_perfsrc_new(struct nvkm_pm *pm, struct nvkm_perfsig *sig,
 		 const struct nvkm_specsrc *spec)
@@ -845,6 +851,11 @@ _nvkm_pm_dtor(struct nvkm_object *object)
 	nvkm_engine_destroy(&pm->engine);
 }
 
+static const struct nvkm_engine_func
+nvkm_pm = {
+	.base.sclass = nvkm_pm_oclass_get,
+};
+
 int
 nvkm_pm_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		struct nvkm_oclass *oclass, int length, void **pobject)
@@ -858,6 +869,8 @@ nvkm_pm_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
+	pm->engine.func = &nvkm_pm;
+
 	INIT_LIST_HEAD(&pm->domains);
 	INIT_LIST_HEAD(&pm->sources);
 	return 0;

commit 2a9f847f5d43d15c0401d050cdd77fb4cbe7da06
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/device: convert user class to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index ae84db1f296b..90a7d89cc019 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -656,7 +656,7 @@ nvkm_perfctx_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	int ret;
 
 	/* no context needed for perfdom objects... */
-	if (nv_mclass(parent) != NV_DEVICE) {
+	if (parent->parent != &nvkm_client(parent)->object) {
 		atomic_inc(&parent->refcount);
 		*pobject = parent;
 		return 1;

commit 24bd0930bedea1182aaadc52757897d2b9b3ca99
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/client: convert to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index b3ae0d96ddb0..ae84db1f296b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -25,6 +25,7 @@
 
 #include <core/client.h>
 #include <core/option.h>
+#include <core/parent.h>
 
 #include <nvif/class.h>
 #include <nvif/ioctl.h>

commit 6cf813fb26640ef539051fb7f965af8c9ff10d92
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/device: prepare for new-style subdevs
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index a441fd3b69bc..b3ae0d96ddb0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -638,8 +638,8 @@ nvkm_perfctx_dtor(struct nvkm_object *object)
 	struct nvkm_pm *pm = (void *)object->engine;
 	struct nvkm_perfctx *ctx = (void *)object;
 
-	mutex_lock(&nv_subdev(pm)->mutex);
 	nvkm_gpuobj_destroy(&ctx->base);
+	mutex_lock(&nv_subdev(pm)->mutex);
 	if (pm->context == ctx)
 		pm->context = NULL;
 	mutex_unlock(&nv_subdev(pm)->mutex);

commit 89c651e2213a148d19407109051abbf81328a4a8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/engine: rename some functions to avoid upcoming conflicts
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index ac27f511163a..a441fd3b69bc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -813,14 +813,14 @@ int
 _nvkm_pm_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nvkm_pm *pm = (void *)object;
-	return nvkm_engine_fini(&pm->engine, suspend);
+	return nvkm_engine_fini_old(&pm->engine, suspend);
 }
 
 int
 _nvkm_pm_init(struct nvkm_object *object)
 {
 	struct nvkm_pm *pm = (void *)object;
-	return nvkm_engine_init(&pm->engine);
+	return nvkm_engine_init_old(&pm->engine);
 }
 
 void

commit aa35888ff024b18c7b6b29eb773a221f642987f7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/object: rename some functions to avoid upcoming conflicts
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index b75395bf8ffa..ac27f511163a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -419,8 +419,8 @@ static struct nvkm_ofuncs
 nvkm_perfdom_ofuncs = {
 	.ctor = nvkm_perfdom_ctor,
 	.dtor = nvkm_perfdom_dtor,
-	.init = nvkm_object_init,
-	.fini = nvkm_object_fini,
+	.init = _nvkm_object_init,
+	.fini = _nvkm_object_fini,
 	.mthd = nvkm_perfdom_mthd,
 };
 

commit a1e88736221d2e971726931c449ed7d0af31755b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:15 2015 +1000

    drm/nouveau/device: decouple from engine machinery
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index ba1623de8bcb..b75395bf8ffa 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -639,7 +639,7 @@ nvkm_perfctx_dtor(struct nvkm_object *object)
 	struct nvkm_perfctx *ctx = (void *)object;
 
 	mutex_lock(&nv_subdev(pm)->mutex);
-	nvkm_engctx_destroy(&ctx->base);
+	nvkm_gpuobj_destroy(&ctx->base);
 	if (pm->context == ctx)
 		pm->context = NULL;
 	mutex_unlock(&nv_subdev(pm)->mutex);
@@ -661,7 +661,7 @@ nvkm_perfctx_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		return 1;
 	}
 
-	ret = nvkm_engctx_create(parent, engine, oclass, NULL, 0, 0, 0, &ctx);
+	ret = nvkm_gpuobj_create(parent, engine, oclass, 0, NULL, 0, 0, 0, &ctx);
 	*pobject = nv_object(ctx);
 	if (ret)
 		return ret;
@@ -678,12 +678,11 @@ nvkm_perfctx_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 
 struct nvkm_oclass
 nvkm_pm_cclass = {
-	.handle = NV_ENGCTX(PM, 0x00),
 	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nvkm_perfctx_ctor,
 		.dtor = nvkm_perfctx_dtor,
-		.init = _nvkm_engctx_init,
-		.fini = _nvkm_engctx_fini,
+		.init = _nvkm_gpuobj_init,
+		.fini = _nvkm_gpuobj_fini,
 	},
 };
 

commit 53003941067534b1071b0f7b71f4700c16d97b28
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:13 2015 +1000

    drm/nouveau/core: remove last printks
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 365cd823d6bb..ba1623de8bcb 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -212,9 +212,9 @@ nvkm_perfdom_init(struct nvkm_object *object, void *data, u32 size)
 	struct nvkm_perfdom *dom = (void *)object;
 	int ret, i;
 
-	nv_ioctl(object, "perfdom init size %d\n", size);
+	nvif_ioctl(object, "perfdom init size %d\n", size);
 	if (nvif_unvers(args->none)) {
-		nv_ioctl(object, "perfdom init\n");
+		nvif_ioctl(object, "perfdom init\n");
 	} else
 		return ret;
 
@@ -242,9 +242,9 @@ nvkm_perfdom_sample(struct nvkm_object *object, void *data, u32 size)
 	struct nvkm_perfdom *dom;
 	int ret;
 
-	nv_ioctl(object, "perfdom sample size %d\n", size);
+	nvif_ioctl(object, "perfdom sample size %d\n", size);
 	if (nvif_unvers(args->none)) {
-		nv_ioctl(object, "perfdom sample\n");
+		nvif_ioctl(object, "perfdom sample\n");
 	} else
 		return ret;
 	pm->sequence++;
@@ -266,9 +266,9 @@ nvkm_perfdom_read(struct nvkm_object *object, void *data, u32 size)
 	struct nvkm_perfdom *dom = (void *)object;
 	int ret, i;
 
-	nv_ioctl(object, "perfdom read size %d\n", size);
+	nvif_ioctl(object, "perfdom read size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(object, "perfdom read vers %d\n", args->v0.version);
+		nvif_ioctl(object, "perfdom read vers %d\n", args->v0.version);
 	} else
 		return ret;
 
@@ -367,10 +367,10 @@ nvkm_perfdom_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	int c, s, m;
 	int ret;
 
-	nv_ioctl(parent, "create perfdom size %d\n", size);
+	nvif_ioctl(parent, "create perfdom size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(parent, "create perfdom vers %d dom %d mode %02x\n",
-			 args->v0.version, args->v0.domain, args->v0.mode);
+		nvif_ioctl(parent, "create perfdom vers %d dom %d mode %02x\n",
+			   args->v0.version, args->v0.domain, args->v0.mode);
 	} else
 		return ret;
 
@@ -438,10 +438,10 @@ nvkm_perfmon_mthd_query_domain(struct nvkm_object *object, void *data, u32 size)
 	u8 domain_nr;
 	int di, ret;
 
-	nv_ioctl(object, "perfmon query domain size %d\n", size);
+	nvif_ioctl(object, "perfmon query domain size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(object, "perfmon domain vers %d iter %02x\n",
-			 args->v0.version, args->v0.iter);
+		nvif_ioctl(object, "perfmon domain vers %d iter %02x\n",
+			   args->v0.version, args->v0.iter);
 		di = (args->v0.iter & 0xff) - 1;
 	} else
 		return ret;
@@ -487,11 +487,11 @@ nvkm_perfmon_mthd_query_signal(struct nvkm_object *object, void *data, u32 size)
 	const bool raw = nvkm_boolopt(device->cfgopt, "NvPmUnnamed", all);
 	int ret, si;
 
-	nv_ioctl(object, "perfmon query signal size %d\n", size);
+	nvif_ioctl(object, "perfmon query signal size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(object,
-			 "perfmon query signal vers %d dom %d iter %04x\n",
-			 args->v0.version, args->v0.domain, args->v0.iter);
+		nvif_ioctl(object,
+			   "perfmon query signal vers %d dom %d iter %04x\n",
+			   args->v0.version, args->v0.domain, args->v0.iter);
 		si = (args->v0.iter & 0xffff) - 1;
 	} else
 		return ret;
@@ -538,12 +538,12 @@ nvkm_perfmon_mthd_query_source(struct nvkm_object *object, void *data, u32 size)
 	u8 source_nr = 0;
 	int si, ret;
 
-	nv_ioctl(object, "perfmon query source size %d\n", size);
+	nvif_ioctl(object, "perfmon query source size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(object,
-			 "perfmon source vers %d dom %d sig %02x iter %02x\n",
-			 args->v0.version, args->v0.domain, args->v0.signal,
-			 args->v0.iter);
+		nvif_ioctl(object,
+			   "perfmon source vers %d dom %d sig %02x iter %02x\n",
+			   args->v0.version, args->v0.domain, args->v0.signal,
+			   args->v0.iter);
 		si = (args->v0.iter & 0xff) - 1;
 	} else
 		return ret;

commit 476901ff6c611620daab3af6cea940be91d97420
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:13 2015 +1000

    drm/nouveau/pm: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index fde6a6013c49..365cd823d6bb 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -126,7 +126,8 @@ nvkm_perfsrc_find(struct nvkm_pm *pm, struct nvkm_perfsig *sig, int si)
 static int
 nvkm_perfsrc_enable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
 {
-	struct nvkm_device *device = pm->engine.subdev.device;
+	struct nvkm_subdev *subdev = &pm->engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	struct nvkm_perfdom *dom = NULL;
 	struct nvkm_perfsig *sig;
 	struct nvkm_perfsrc *src;
@@ -153,8 +154,9 @@ nvkm_perfsrc_enable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
 
 			/* enable the source */
 			nvkm_mask(device, src->addr, mask, value);
-			nv_debug(pm, "enabled source 0x%08x 0x%08x 0x%08x\n",
-				 src->addr, mask, value);
+			nvkm_debug(subdev,
+				   "enabled source %08x %08x %08x\n",
+				   src->addr, mask, value);
 		}
 	}
 	return 0;
@@ -163,7 +165,8 @@ nvkm_perfsrc_enable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
 static int
 nvkm_perfsrc_disable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
 {
-	struct nvkm_device *device = pm->engine.subdev.device;
+	struct nvkm_subdev *subdev = &pm->engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	struct nvkm_perfdom *dom = NULL;
 	struct nvkm_perfsig *sig;
 	struct nvkm_perfsrc *src;
@@ -189,8 +192,8 @@ nvkm_perfsrc_disable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
 
 			/* disable the source */
 			nvkm_mask(device, src->addr, mask, 0);
-			nv_debug(pm, "disabled source 0x%08x 0x%08x\n",
-				 src->addr, mask);
+			nvkm_debug(subdev, "disabled source %08x %08x\n",
+				   src->addr, mask);
 		}
 	}
 	return 0;

commit 846e831d953fd01cb78b9ed92495baee142bed37
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:10 2015 +1000

    drm/nouveau/pm: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 6803ad9ebe6f..fde6a6013c49 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -126,6 +126,7 @@ nvkm_perfsrc_find(struct nvkm_pm *pm, struct nvkm_perfsig *sig, int si)
 static int
 nvkm_perfsrc_enable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
 {
+	struct nvkm_device *device = pm->engine.subdev.device;
 	struct nvkm_perfdom *dom = NULL;
 	struct nvkm_perfsig *sig;
 	struct nvkm_perfsrc *src;
@@ -151,7 +152,7 @@ nvkm_perfsrc_enable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
 			value |= ((ctr->source[i][j] >> 32) << src->shift);
 
 			/* enable the source */
-			nv_mask(pm, src->addr, mask, value);
+			nvkm_mask(device, src->addr, mask, value);
 			nv_debug(pm, "enabled source 0x%08x 0x%08x 0x%08x\n",
 				 src->addr, mask, value);
 		}
@@ -162,6 +163,7 @@ nvkm_perfsrc_enable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
 static int
 nvkm_perfsrc_disable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
 {
+	struct nvkm_device *device = pm->engine.subdev.device;
 	struct nvkm_perfdom *dom = NULL;
 	struct nvkm_perfsig *sig;
 	struct nvkm_perfsrc *src;
@@ -186,7 +188,7 @@ nvkm_perfsrc_disable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
 			mask |= (src->mask << src->shift);
 
 			/* disable the source */
-			nv_mask(pm, src->addr, mask, 0);
+			nvkm_mask(device, src->addr, mask, 0);
 			nv_debug(pm, "disabled source 0x%08x 0x%08x\n",
 				 src->addr, mask);
 		}

commit 8c1aeaa13954585e8482866457abacb5c094db35
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:08 2015 +1000

    drm/nouveau/pm: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 8741201d4236..6803ad9ebe6f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -31,12 +31,12 @@
 #include <nvif/unpack.h>
 
 static u8
-nvkm_pm_count_perfdom(struct nvkm_pm *ppm)
+nvkm_pm_count_perfdom(struct nvkm_pm *pm)
 {
 	struct nvkm_perfdom *dom;
 	u8 domain_nr = 0;
 
-	list_for_each_entry(dom, &ppm->domains, head)
+	list_for_each_entry(dom, &pm->domains, head)
 		domain_nr++;
 	return domain_nr;
 }
@@ -57,12 +57,12 @@ nvkm_perfdom_count_perfsig(struct nvkm_perfdom *dom)
 }
 
 static struct nvkm_perfdom *
-nvkm_perfdom_find(struct nvkm_pm *ppm, int di)
+nvkm_perfdom_find(struct nvkm_pm *pm, int di)
 {
 	struct nvkm_perfdom *dom;
 	int tmp = 0;
 
-	list_for_each_entry(dom, &ppm->domains, head) {
+	list_for_each_entry(dom, &pm->domains, head) {
 		if (tmp++ == di)
 			return dom;
 	}
@@ -70,13 +70,12 @@ nvkm_perfdom_find(struct nvkm_pm *ppm, int di)
 }
 
 struct nvkm_perfsig *
-nvkm_perfsig_find(struct nvkm_pm *ppm, uint8_t di, uint8_t si,
-		  struct nvkm_perfdom **pdom)
+nvkm_perfsig_find(struct nvkm_pm *pm, u8 di, u8 si, struct nvkm_perfdom **pdom)
 {
 	struct nvkm_perfdom *dom = *pdom;
 
 	if (dom == NULL) {
-		dom = nvkm_perfdom_find(ppm, di);
+		dom = nvkm_perfdom_find(pm, di);
 		if (dom == NULL)
 			return NULL;
 		*pdom = dom;
@@ -100,7 +99,7 @@ nvkm_perfsig_count_perfsrc(struct nvkm_perfsig *sig)
 }
 
 static struct nvkm_perfsrc *
-nvkm_perfsrc_find(struct nvkm_pm *ppm, struct nvkm_perfsig *sig, int si)
+nvkm_perfsrc_find(struct nvkm_pm *pm, struct nvkm_perfsig *sig, int si)
 {
 	struct nvkm_perfsrc *src;
 	bool found = false;
@@ -115,7 +114,7 @@ nvkm_perfsrc_find(struct nvkm_pm *ppm, struct nvkm_perfsig *sig, int si)
 	}
 
 	if (found) {
-		list_for_each_entry(src, &ppm->sources, head) {
+		list_for_each_entry(src, &pm->sources, head) {
 			if (tmp++ == si)
 				return src;
 		}
@@ -125,7 +124,7 @@ nvkm_perfsrc_find(struct nvkm_pm *ppm, struct nvkm_perfsig *sig, int si)
 }
 
 static int
-nvkm_perfsrc_enable(struct nvkm_pm *ppm, struct nvkm_perfctr *ctr)
+nvkm_perfsrc_enable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
 {
 	struct nvkm_perfdom *dom = NULL;
 	struct nvkm_perfsig *sig;
@@ -135,12 +134,12 @@ nvkm_perfsrc_enable(struct nvkm_pm *ppm, struct nvkm_perfctr *ctr)
 
 	for (i = 0; i < 4; i++) {
 		for (j = 0; j < 8 && ctr->source[i][j]; j++) {
-			sig = nvkm_perfsig_find(ppm, ctr->domain,
+			sig = nvkm_perfsig_find(pm, ctr->domain,
 						ctr->signal[i], &dom);
 			if (!sig)
 				return -EINVAL;
 
-			src = nvkm_perfsrc_find(ppm, sig, ctr->source[i][j]);
+			src = nvkm_perfsrc_find(pm, sig, ctr->source[i][j]);
 			if (!src)
 				return -EINVAL;
 
@@ -152,8 +151,8 @@ nvkm_perfsrc_enable(struct nvkm_pm *ppm, struct nvkm_perfctr *ctr)
 			value |= ((ctr->source[i][j] >> 32) << src->shift);
 
 			/* enable the source */
-			nv_mask(ppm, src->addr, mask, value);
-			nv_debug(ppm, "enabled source 0x%08x 0x%08x 0x%08x\n",
+			nv_mask(pm, src->addr, mask, value);
+			nv_debug(pm, "enabled source 0x%08x 0x%08x 0x%08x\n",
 				 src->addr, mask, value);
 		}
 	}
@@ -161,7 +160,7 @@ nvkm_perfsrc_enable(struct nvkm_pm *ppm, struct nvkm_perfctr *ctr)
 }
 
 static int
-nvkm_perfsrc_disable(struct nvkm_pm *ppm, struct nvkm_perfctr *ctr)
+nvkm_perfsrc_disable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
 {
 	struct nvkm_perfdom *dom = NULL;
 	struct nvkm_perfsig *sig;
@@ -171,12 +170,12 @@ nvkm_perfsrc_disable(struct nvkm_pm *ppm, struct nvkm_perfctr *ctr)
 
 	for (i = 0; i < 4; i++) {
 		for (j = 0; j < 8 && ctr->source[i][j]; j++) {
-			sig = nvkm_perfsig_find(ppm, ctr->domain,
+			sig = nvkm_perfsig_find(pm, ctr->domain,
 						ctr->signal[i], &dom);
 			if (!sig)
 				return -EINVAL;
 
-			src = nvkm_perfsrc_find(ppm, sig, ctr->source[i][j]);
+			src = nvkm_perfsrc_find(pm, sig, ctr->source[i][j]);
 			if (!src)
 				return -EINVAL;
 
@@ -187,8 +186,8 @@ nvkm_perfsrc_disable(struct nvkm_pm *ppm, struct nvkm_perfctr *ctr)
 			mask |= (src->mask << src->shift);
 
 			/* disable the source */
-			nv_mask(ppm, src->addr, mask, 0);
-			nv_debug(ppm, "disabled source 0x%08x 0x%08x\n",
+			nv_mask(pm, src->addr, mask, 0);
+			nv_debug(pm, "disabled source 0x%08x 0x%08x\n",
 				 src->addr, mask);
 		}
 	}
@@ -204,7 +203,7 @@ nvkm_perfdom_init(struct nvkm_object *object, void *data, u32 size)
 	union {
 		struct nvif_perfdom_init none;
 	} *args = data;
-	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_pm *pm = (void *)object->engine;
 	struct nvkm_perfdom *dom = (void *)object;
 	int ret, i;
 
@@ -216,15 +215,15 @@ nvkm_perfdom_init(struct nvkm_object *object, void *data, u32 size)
 
 	for (i = 0; i < 4; i++) {
 		if (dom->ctr[i]) {
-			dom->func->init(ppm, dom, dom->ctr[i]);
+			dom->func->init(pm, dom, dom->ctr[i]);
 
 			/* enable sources */
-			nvkm_perfsrc_enable(ppm, dom->ctr[i]);
+			nvkm_perfsrc_enable(pm, dom->ctr[i]);
 		}
 	}
 
 	/* start next batch of counters for sampling */
-	dom->func->next(ppm, dom);
+	dom->func->next(pm, dom);
 	return 0;
 }
 
@@ -234,7 +233,7 @@ nvkm_perfdom_sample(struct nvkm_object *object, void *data, u32 size)
 	union {
 		struct nvif_perfdom_sample none;
 	} *args = data;
-	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_pm *pm = (void *)object->engine;
 	struct nvkm_perfdom *dom;
 	int ret;
 
@@ -243,11 +242,11 @@ nvkm_perfdom_sample(struct nvkm_object *object, void *data, u32 size)
 		nv_ioctl(object, "perfdom sample\n");
 	} else
 		return ret;
-	ppm->sequence++;
+	pm->sequence++;
 
 	/* sample previous batch of counters */
-	list_for_each_entry(dom, &ppm->domains, head)
-		dom->func->next(ppm, dom);
+	list_for_each_entry(dom, &pm->domains, head)
+		dom->func->next(pm, dom);
 
 	return 0;
 }
@@ -258,7 +257,7 @@ nvkm_perfdom_read(struct nvkm_object *object, void *data, u32 size)
 	union {
 		struct nvif_perfdom_read_v0 v0;
 	} *args = data;
-	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_pm *pm = (void *)object->engine;
 	struct nvkm_perfdom *dom = (void *)object;
 	int ret, i;
 
@@ -270,7 +269,7 @@ nvkm_perfdom_read(struct nvkm_object *object, void *data, u32 size)
 
 	for (i = 0; i < 4; i++) {
 		if (dom->ctr[i])
-			dom->func->read(ppm, dom, dom->ctr[i]);
+			dom->func->read(pm, dom, dom->ctr[i]);
 	}
 
 	if (!dom->clk)
@@ -302,14 +301,14 @@ nvkm_perfdom_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 static void
 nvkm_perfdom_dtor(struct nvkm_object *object)
 {
-	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_pm *pm = (void *)object->engine;
 	struct nvkm_perfdom *dom = (void *)object;
 	int i;
 
 	for (i = 0; i < 4; i++) {
 		struct nvkm_perfctr *ctr = dom->ctr[i];
 		if (ctr) {
-			nvkm_perfsrc_disable(ppm, ctr);
+			nvkm_perfsrc_disable(pm, ctr);
 			if (ctr->head.next)
 				list_del(&ctr->head);
 		}
@@ -319,9 +318,9 @@ nvkm_perfdom_dtor(struct nvkm_object *object)
 }
 
 static int
-nvkm_perfctr_new(struct nvkm_perfdom *dom, int slot, uint8_t domain,
-		 struct nvkm_perfsig *signal[4], uint64_t source[4][8],
-		 uint16_t logic_op, struct nvkm_perfctr **pctr)
+nvkm_perfctr_new(struct nvkm_perfdom *dom, int slot, u8 domain,
+		 struct nvkm_perfsig *signal[4], u64 source[4][8],
+		 u16 logic_op, struct nvkm_perfctr **pctr)
 {
 	struct nvkm_perfctr *ctr;
 	int i, j;
@@ -356,7 +355,7 @@ nvkm_perfdom_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	union {
 		struct nvif_perfdom_v0 v0;
 	} *args = data;
-	struct nvkm_pm *ppm = (void *)engine;
+	struct nvkm_pm *pm = (void *)engine;
 	struct nvkm_perfdom *sdom = NULL;
 	struct nvkm_perfctr *ctr[4] = {};
 	struct nvkm_perfdom *dom;
@@ -375,7 +374,7 @@ nvkm_perfdom_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		u64 src[4][8] = {};
 
 		for (s = 0; s < ARRAY_SIZE(args->v0.ctr[c].signal); s++) {
-			sig[s] = nvkm_perfsig_find(ppm, args->v0.domain,
+			sig[s] = nvkm_perfsig_find(pm, args->v0.domain,
 						   args->v0.ctr[c].signal[s],
 						   &sdom);
 			if (args->v0.ctr[c].signal[s] && !sig[s])
@@ -383,7 +382,7 @@ nvkm_perfdom_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 
 			for (m = 0; m < 8; m++) {
 				src[s][m] = args->v0.ctr[c].source[s][m];
-				if (src[s][m] && !nvkm_perfsrc_find(ppm, sig[s],
+				if (src[s][m] && !nvkm_perfsrc_find(pm, sig[s],
 							            src[s][m]))
 					return -EINVAL;
 			}
@@ -429,7 +428,7 @@ nvkm_perfmon_mthd_query_domain(struct nvkm_object *object, void *data, u32 size)
 	union {
 		struct nvif_perfmon_query_domain_v0 v0;
 	} *args = data;
-	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_pm *pm = (void *)object->engine;
 	struct nvkm_perfdom *dom;
 	u8 domain_nr;
 	int di, ret;
@@ -442,12 +441,12 @@ nvkm_perfmon_mthd_query_domain(struct nvkm_object *object, void *data, u32 size)
 	} else
 		return ret;
 
-	domain_nr = nvkm_pm_count_perfdom(ppm);
+	domain_nr = nvkm_pm_count_perfdom(pm);
 	if (di >= (int)domain_nr)
 		return -EINVAL;
 
 	if (di >= 0) {
-		dom = nvkm_perfdom_find(ppm, di);
+		dom = nvkm_perfdom_find(pm, di);
 		if (dom == NULL)
 			return -EINVAL;
 
@@ -476,7 +475,7 @@ nvkm_perfmon_mthd_query_signal(struct nvkm_object *object, void *data, u32 size)
 		struct nvif_perfmon_query_signal_v0 v0;
 	} *args = data;
 	struct nvkm_device *device = nv_device(object);
-	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_pm *pm = (void *)object->engine;
 	struct nvkm_perfdom *dom;
 	struct nvkm_perfsig *sig;
 	const bool all = nvkm_boolopt(device->cfgopt, "NvPmShowAll", false);
@@ -492,7 +491,7 @@ nvkm_perfmon_mthd_query_signal(struct nvkm_object *object, void *data, u32 size)
 	} else
 		return ret;
 
-	dom = nvkm_perfdom_find(ppm, args->v0.domain);
+	dom = nvkm_perfdom_find(pm, args->v0.domain);
 	if (dom == NULL || si >= (int)dom->signal_nr)
 		return -EINVAL;
 
@@ -527,7 +526,7 @@ nvkm_perfmon_mthd_query_source(struct nvkm_object *object, void *data, u32 size)
 	union {
 		struct nvif_perfmon_query_source_v0 v0;
 	} *args = data;
-	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_pm *pm = (void *)object->engine;
 	struct nvkm_perfdom *dom = NULL;
 	struct nvkm_perfsig *sig;
 	struct nvkm_perfsrc *src;
@@ -544,7 +543,7 @@ nvkm_perfmon_mthd_query_source(struct nvkm_object *object, void *data, u32 size)
 	} else
 		return ret;
 
-	sig = nvkm_perfsig_find(ppm, args->v0.domain, args->v0.signal, &dom);
+	sig = nvkm_perfsig_find(pm, args->v0.domain, args->v0.signal, &dom);
 	if (!sig)
 		return -EINVAL;
 
@@ -553,7 +552,7 @@ nvkm_perfmon_mthd_query_source(struct nvkm_object *object, void *data, u32 size)
 		return -EINVAL;
 
 	if (si >= 0) {
-		src = nvkm_perfsrc_find(ppm, sig, sig->source[si]);
+		src = nvkm_perfsrc_find(pm, sig, sig->source[si]);
 		if (!src)
 			return -EINVAL;
 
@@ -631,14 +630,14 @@ nvkm_pm_sclass[] = {
 static void
 nvkm_perfctx_dtor(struct nvkm_object *object)
 {
-	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_pm *pm = (void *)object->engine;
 	struct nvkm_perfctx *ctx = (void *)object;
 
-	mutex_lock(&nv_subdev(ppm)->mutex);
+	mutex_lock(&nv_subdev(pm)->mutex);
 	nvkm_engctx_destroy(&ctx->base);
-	if (ppm->context == ctx)
-		ppm->context = NULL;
-	mutex_unlock(&nv_subdev(ppm)->mutex);
+	if (pm->context == ctx)
+		pm->context = NULL;
+	mutex_unlock(&nv_subdev(pm)->mutex);
 }
 
 static int
@@ -646,7 +645,7 @@ nvkm_perfctx_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		  struct nvkm_oclass *oclass, void *data, u32 size,
 		  struct nvkm_object **pobject)
 {
-	struct nvkm_pm *ppm = (void *)engine;
+	struct nvkm_pm *pm = (void *)engine;
 	struct nvkm_perfctx *ctx;
 	int ret;
 
@@ -662,12 +661,12 @@ nvkm_perfctx_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	mutex_lock(&nv_subdev(ppm)->mutex);
-	if (ppm->context == NULL)
-		ppm->context = ctx;
-	if (ctx != ppm->context)
+	mutex_lock(&nv_subdev(pm)->mutex);
+	if (pm->context == NULL)
+		pm->context = ctx;
+	if (ctx != pm->context)
 		ret = -EBUSY;
-	mutex_unlock(&nv_subdev(ppm)->mutex);
+	mutex_unlock(&nv_subdev(pm)->mutex);
 
 	return ret;
 }
@@ -687,7 +686,7 @@ nvkm_pm_cclass = {
  * PPM engine/subdev functions
  ******************************************************************************/
 int
-nvkm_perfsrc_new(struct nvkm_pm *ppm, struct nvkm_perfsig *sig,
+nvkm_perfsrc_new(struct nvkm_pm *pm, struct nvkm_perfsig *sig,
 		 const struct nvkm_specsrc *spec)
 {
 	const struct nvkm_specsrc *ssrc;
@@ -708,7 +707,7 @@ nvkm_perfsrc_new(struct nvkm_pm *ppm, struct nvkm_perfsig *sig,
 			u8 source_id = 0;
 			u32 len;
 
-			list_for_each_entry(src, &ppm->sources, head) {
+			list_for_each_entry(src, &pm->sources, head) {
 				if (src->addr == ssrc->addr &&
 				    src->shift == smux->shift) {
 					found = true;
@@ -730,12 +729,14 @@ nvkm_perfsrc_new(struct nvkm_pm *ppm, struct nvkm_perfsig *sig,
 				len = strlen(ssrc->name) +
 				      strlen(smux->name) + 2;
 				src->name = kzalloc(len, GFP_KERNEL);
-				if (!src->name)
+				if (!src->name) {
+					kfree(src);
 					return -ENOMEM;
+				}
 				snprintf(src->name, len, "%s_%s", ssrc->name,
 					 smux->name);
 
-				list_add_tail(&src->head, &ppm->sources);
+				list_add_tail(&src->head, &pm->sources);
 			}
 
 			sig->source[source_nr++] = source_id + 1;
@@ -748,7 +749,7 @@ nvkm_perfsrc_new(struct nvkm_pm *ppm, struct nvkm_perfsig *sig,
 }
 
 int
-nvkm_perfdom_new(struct nvkm_pm *ppm, const char *name, u32 mask,
+nvkm_perfdom_new(struct nvkm_pm *pm, const char *name, u32 mask,
 		 u32 base, u32 size_unit, u32 size_domain,
 		 const struct nvkm_specdom *spec)
 {
@@ -778,7 +779,7 @@ nvkm_perfdom_new(struct nvkm_pm *ppm, const char *name, u32 mask,
 					 "%s/%02x", name, (int)(sdom - spec));
 			}
 
-			list_add_tail(&dom->head, &ppm->domains);
+			list_add_tail(&dom->head, &pm->domains);
 			INIT_LIST_HEAD(&dom->list);
 			dom->func = sdom->func;
 			dom->addr = addr;
@@ -789,7 +790,7 @@ nvkm_perfdom_new(struct nvkm_pm *ppm, const char *name, u32 mask,
 				struct nvkm_perfsig *sig =
 					&dom->signal[ssig->signal];
 				sig->name = ssig->name;
-				ret = nvkm_perfsrc_new(ppm, sig, ssig->source);
+				ret = nvkm_perfsrc_new(pm, sig, ssig->source);
 				if (ret)
 					return ret;
 				ssig++;
@@ -807,52 +808,52 @@ nvkm_perfdom_new(struct nvkm_pm *ppm, const char *name, u32 mask,
 int
 _nvkm_pm_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nvkm_pm *ppm = (void *)object;
-	return nvkm_engine_fini(&ppm->base, suspend);
+	struct nvkm_pm *pm = (void *)object;
+	return nvkm_engine_fini(&pm->engine, suspend);
 }
 
 int
 _nvkm_pm_init(struct nvkm_object *object)
 {
-	struct nvkm_pm *ppm = (void *)object;
-	return nvkm_engine_init(&ppm->base);
+	struct nvkm_pm *pm = (void *)object;
+	return nvkm_engine_init(&pm->engine);
 }
 
 void
 _nvkm_pm_dtor(struct nvkm_object *object)
 {
-	struct nvkm_pm *ppm = (void *)object;
+	struct nvkm_pm *pm = (void *)object;
 	struct nvkm_perfdom *dom, *next_dom;
 	struct nvkm_perfsrc *src, *next_src;
 
-	list_for_each_entry_safe(dom, next_dom, &ppm->domains, head) {
+	list_for_each_entry_safe(dom, next_dom, &pm->domains, head) {
 		list_del(&dom->head);
 		kfree(dom);
 	}
 
-	list_for_each_entry_safe(src, next_src, &ppm->sources, head) {
+	list_for_each_entry_safe(src, next_src, &pm->sources, head) {
 		list_del(&src->head);
 		kfree(src->name);
 		kfree(src);
 	}
 
-	nvkm_engine_destroy(&ppm->base);
+	nvkm_engine_destroy(&pm->engine);
 }
 
 int
 nvkm_pm_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		struct nvkm_oclass *oclass, int length, void **pobject)
 {
-	struct nvkm_pm *ppm;
+	struct nvkm_pm *pm;
 	int ret;
 
 	ret = nvkm_engine_create_(parent, engine, oclass, true, "PPM",
 				  "pm", length, pobject);
-	ppm = *pobject;
+	pm = *pobject;
 	if (ret)
 		return ret;
 
-	INIT_LIST_HEAD(&ppm->domains);
-	INIT_LIST_HEAD(&ppm->sources);
+	INIT_LIST_HEAD(&pm->domains);
+	INIT_LIST_HEAD(&pm->sources);
 	return 0;
 }

commit 9ace404b1098221021b01c2ba0eeea0c257fa4a5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/device: include core/device.h automatically for subdevs/engines
    
    Pretty much every subdev/engine is going to need access to nvkm_device
    shortly to touch registers and/or output messages.
    
    The odd placement of the includes is necessary to work around some
    inter-dependencies that currently exist.  This will be fixed later.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 48c1ce6e663c..8741201d4236 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -24,7 +24,6 @@
 #include "priv.h"
 
 #include <core/client.h>
-#include <core/device.h>
 #include <core/option.h>
 
 #include <nvif/class.h>

commit 7fe882eb90844f79acd9cdd3ccd5d3459c27cf3f
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Tue Aug 4 23:58:12 2015 +0200

    drm/nouveau/pm: allow zeroed signals to enable sources
    
    Hardware signals index 0x00 are defined for some domains and they have
    to be allowed to enable sources like the others.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 94991d63640c..48c1ce6e663c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -134,7 +134,7 @@ nvkm_perfsrc_enable(struct nvkm_pm *ppm, struct nvkm_perfctr *ctr)
 	u32 mask, value;
 	int i, j;
 
-	for (i = 0; i < 4 && ctr->signal[i]; i++) {
+	for (i = 0; i < 4; i++) {
 		for (j = 0; j < 8 && ctr->source[i][j]; j++) {
 			sig = nvkm_perfsig_find(ppm, ctr->domain,
 						ctr->signal[i], &dom);
@@ -170,7 +170,7 @@ nvkm_perfsrc_disable(struct nvkm_pm *ppm, struct nvkm_perfctr *ctr)
 	u32 mask;
 	int i, j;
 
-	for (i = 0; i < 4 && ctr->signal[i]; i++) {
+	for (i = 0; i < 4; i++) {
 		for (j = 0; j < 8 && ctr->source[i][j]; j++) {
 			sig = nvkm_perfsig_find(ppm, ctr->domain,
 						ctr->signal[i], &dom);

commit df0b37ee1aa19fc1b948099bf449fdd94f36036c
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Fri Jun 19 17:36:37 2015 +0200

    drm/nouveau/pm: expose name of domains
    
    This is going to be very useful for GF100+ because each GPC can
    have its own domain of counters.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 7866e220b66f..94991d63640c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -454,6 +454,7 @@ nvkm_perfmon_mthd_query_domain(struct nvkm_object *object, void *data, u32 size)
 
 		args->v0.id         = di;
 		args->v0.signal_nr  = nvkm_perfdom_count_perfsig(dom);
+		strncpy(args->v0.name, dom->name, sizeof(args->v0.name));
 
 		/* Currently only global counters (PCOUNTER) are implemented
 		 * but this will be different for local counters (MP). */

commit d4a312dc90a7c1079133b038aec0120ee9e3d0ce
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 14 13:50:06 2015 +0200

    drm/nouveau/pm: some fixes related to sources
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index f505a11a938a..7866e220b66f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -154,6 +154,8 @@ nvkm_perfsrc_enable(struct nvkm_pm *ppm, struct nvkm_perfctr *ctr)
 
 			/* enable the source */
 			nv_mask(ppm, src->addr, mask, value);
+			nv_debug(ppm, "enabled source 0x%08x 0x%08x 0x%08x\n",
+				 src->addr, mask, value);
 		}
 	}
 	return 0;
@@ -165,6 +167,7 @@ nvkm_perfsrc_disable(struct nvkm_pm *ppm, struct nvkm_perfctr *ctr)
 	struct nvkm_perfdom *dom = NULL;
 	struct nvkm_perfsig *sig;
 	struct nvkm_perfsrc *src;
+	u32 mask;
 	int i, j;
 
 	for (i = 0; i < 4 && ctr->signal[i]; i++) {
@@ -178,8 +181,16 @@ nvkm_perfsrc_disable(struct nvkm_pm *ppm, struct nvkm_perfctr *ctr)
 			if (!src)
 				return -EINVAL;
 
+			/* unset enable bit if needed */
+			mask = 0x00000000;
+			if (src->enable)
+				mask = 0x80000000;
+			mask |= (src->mask << src->shift);
+
 			/* disable the source */
-			nv_mask(ppm, src->addr, src->mask << src->shift, 0);
+			nv_mask(ppm, src->addr, mask, 0);
+			nv_debug(ppm, "disabled source 0x%08x 0x%08x\n",
+				 src->addr, mask);
 		}
 	}
 	return 0;
@@ -309,7 +320,7 @@ nvkm_perfdom_dtor(struct nvkm_object *object)
 }
 
 static int
-nvkm_perfctr_new(struct nvkm_perfdom *dom, int slot,
+nvkm_perfctr_new(struct nvkm_perfdom *dom, int slot, uint8_t domain,
 		 struct nvkm_perfsig *signal[4], uint64_t source[4][8],
 		 uint16_t logic_op, struct nvkm_perfctr **pctr)
 {
@@ -323,6 +334,7 @@ nvkm_perfctr_new(struct nvkm_perfdom *dom, int slot,
 	if (!ctr)
 		return -ENOMEM;
 
+	ctr->domain   = domain;
 	ctr->logic_op = logic_op;
 	ctr->slot     = slot;
 	for (i = 0; i < 4; i++) {
@@ -361,7 +373,7 @@ nvkm_perfdom_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	for (c = 0; c < ARRAY_SIZE(args->v0.ctr); c++) {
 		struct nvkm_perfsig *sig[4] = {};
-		u64 src[4][8];
+		u64 src[4][8] = {};
 
 		for (s = 0; s < ARRAY_SIZE(args->v0.ctr[c].signal); s++) {
 			sig[s] = nvkm_perfsig_find(ppm, args->v0.domain,
@@ -378,11 +390,10 @@ nvkm_perfdom_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 			}
 		}
 
-		ret = nvkm_perfctr_new(sdom, c, sig, src,
+		ret = nvkm_perfctr_new(sdom, c, args->v0.domain, sig, src,
 				       args->v0.ctr[c].logic_op, &ctr[c]);
 		if (ret)
 			return ret;
-		ctr[c]->domain = args->v0.domain;
 	}
 
 	if (!sdom)

commit f21950ea35c86be79c293b199fe48b5152ec8311
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Jun 14 12:20:37 2015 +1000

    drm/nouveau/pm: stack perfdom class under perfmon
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 0e1536d5c777..f505a11a938a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -576,12 +576,32 @@ nvkm_perfmon_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	return -EINVAL;
 }
 
+static struct nvkm_oclass
+nvkm_perfmon_sclass[] = {
+	{ .handle = NVIF_IOCTL_NEW_V0_PERFDOM,
+	  .ofuncs = &nvkm_perfdom_ofuncs,
+	},
+	{}
+};
+
+static int
+nvkm_perfmon_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+		  struct nvkm_oclass *oclass, void *data, u32 size,
+		  struct nvkm_object **pobject)
+{
+	struct nvkm_parent *perfmon;
+	int ret = nvkm_parent_create(parent, engine, oclass, 0,
+				     nvkm_perfmon_sclass, 0, &perfmon);
+	*pobject = perfmon ? &perfmon->object : NULL;
+	return ret;
+}
+
 static struct nvkm_ofuncs
 nvkm_perfmon_ofuncs = {
-	.ctor = _nvkm_object_ctor,
-	.dtor = nvkm_object_destroy,
-	.init = nvkm_object_init,
-	.fini = nvkm_object_fini,
+	.ctor = nvkm_perfmon_ctor,
+	.dtor = _nvkm_parent_dtor,
+	.init = _nvkm_parent_init,
+	.fini = _nvkm_parent_fini,
 	.mthd = nvkm_perfmon_mthd,
 };
 
@@ -591,9 +611,6 @@ nvkm_pm_sclass[] = {
 	  .handle = NVIF_IOCTL_NEW_V0_PERFMON,
 	  .ofuncs = &nvkm_perfmon_ofuncs,
 	},
-	{ .handle = NVIF_IOCTL_NEW_V0_PERFDOM,
-	  .ofuncs = &nvkm_perfdom_ofuncs,
-	},
 	{},
 };
 
@@ -622,6 +639,13 @@ nvkm_perfctx_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	struct nvkm_perfctx *ctx;
 	int ret;
 
+	/* no context needed for perfdom objects... */
+	if (nv_mclass(parent) != NV_DEVICE) {
+		atomic_inc(&parent->refcount);
+		*pobject = parent;
+		return 1;
+	}
+
 	ret = nvkm_engctx_create(parent, engine, oclass, NULL, 0, 0, 0, &ctx);
 	*pobject = nv_object(ctx);
 	if (ret)

commit 2d4b94b95f30b0a4244fce4866583094d991c0ec
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Jun 14 12:10:59 2015 +1000

    drm/nouveau/pm: swap perfmon/perfdom code to avoid forward decl in next commit
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index a4bb6fe5e90b..0e1536d5c777 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -185,181 +185,6 @@ nvkm_perfsrc_disable(struct nvkm_pm *ppm, struct nvkm_perfctr *ctr)
 	return 0;
 }
 
-/*******************************************************************************
- * Perfmon object classes
- ******************************************************************************/
-static int
-nvkm_perfmon_mthd_query_domain(struct nvkm_object *object, void *data, u32 size)
-{
-	union {
-		struct nvif_perfmon_query_domain_v0 v0;
-	} *args = data;
-	struct nvkm_pm *ppm = (void *)object->engine;
-	struct nvkm_perfdom *dom;
-	u8 domain_nr;
-	int di, ret;
-
-	nv_ioctl(object, "perfmon query domain size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(object, "perfmon domain vers %d iter %02x\n",
-			 args->v0.version, args->v0.iter);
-		di = (args->v0.iter & 0xff) - 1;
-	} else
-		return ret;
-
-	domain_nr = nvkm_pm_count_perfdom(ppm);
-	if (di >= (int)domain_nr)
-		return -EINVAL;
-
-	if (di >= 0) {
-		dom = nvkm_perfdom_find(ppm, di);
-		if (dom == NULL)
-			return -EINVAL;
-
-		args->v0.id         = di;
-		args->v0.signal_nr  = nvkm_perfdom_count_perfsig(dom);
-
-		/* Currently only global counters (PCOUNTER) are implemented
-		 * but this will be different for local counters (MP). */
-		args->v0.counter_nr = 4;
-	}
-
-	if (++di < domain_nr) {
-		args->v0.iter = ++di;
-		return 0;
-	}
-
-	args->v0.iter = 0xff;
-	return 0;
-}
-
-static int
-nvkm_perfmon_mthd_query_signal(struct nvkm_object *object, void *data, u32 size)
-{
-	union {
-		struct nvif_perfmon_query_signal_v0 v0;
-	} *args = data;
-	struct nvkm_device *device = nv_device(object);
-	struct nvkm_pm *ppm = (void *)object->engine;
-	struct nvkm_perfdom *dom;
-	struct nvkm_perfsig *sig;
-	const bool all = nvkm_boolopt(device->cfgopt, "NvPmShowAll", false);
-	const bool raw = nvkm_boolopt(device->cfgopt, "NvPmUnnamed", all);
-	int ret, si;
-
-	nv_ioctl(object, "perfmon query signal size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(object,
-			 "perfmon query signal vers %d dom %d iter %04x\n",
-			 args->v0.version, args->v0.domain, args->v0.iter);
-		si = (args->v0.iter & 0xffff) - 1;
-	} else
-		return ret;
-
-	dom = nvkm_perfdom_find(ppm, args->v0.domain);
-	if (dom == NULL || si >= (int)dom->signal_nr)
-		return -EINVAL;
-
-	if (si >= 0) {
-		sig = &dom->signal[si];
-		if (raw || !sig->name) {
-			snprintf(args->v0.name, sizeof(args->v0.name),
-				 "/%s/%02x", dom->name, si);
-		} else {
-			strncpy(args->v0.name, sig->name,
-				sizeof(args->v0.name));
-		}
-
-		args->v0.signal = si;
-		args->v0.source_nr = nvkm_perfsig_count_perfsrc(sig);
-	}
-
-	while (++si < dom->signal_nr) {
-		if (all || dom->signal[si].name) {
-			args->v0.iter = ++si;
-			return 0;
-		}
-	}
-
-	args->v0.iter = 0xffff;
-	return 0;
-}
-
-static int
-nvkm_perfmon_mthd_query_source(struct nvkm_object *object, void *data, u32 size)
-{
-	union {
-		struct nvif_perfmon_query_source_v0 v0;
-	} *args = data;
-	struct nvkm_pm *ppm = (void *)object->engine;
-	struct nvkm_perfdom *dom = NULL;
-	struct nvkm_perfsig *sig;
-	struct nvkm_perfsrc *src;
-	u8 source_nr = 0;
-	int si, ret;
-
-	nv_ioctl(object, "perfmon query source size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(object,
-			 "perfmon source vers %d dom %d sig %02x iter %02x\n",
-			 args->v0.version, args->v0.domain, args->v0.signal,
-			 args->v0.iter);
-		si = (args->v0.iter & 0xff) - 1;
-	} else
-		return ret;
-
-	sig = nvkm_perfsig_find(ppm, args->v0.domain, args->v0.signal, &dom);
-	if (!sig)
-		return -EINVAL;
-
-	source_nr = nvkm_perfsig_count_perfsrc(sig);
-	if (si >= (int)source_nr)
-		return -EINVAL;
-
-	if (si >= 0) {
-		src = nvkm_perfsrc_find(ppm, sig, sig->source[si]);
-		if (!src)
-			return -EINVAL;
-
-		args->v0.source = sig->source[si];
-		args->v0.mask   = src->mask;
-		strncpy(args->v0.name, src->name, sizeof(args->v0.name));
-	}
-
-	if (++si < source_nr) {
-		args->v0.iter = ++si;
-		return 0;
-	}
-
-	args->v0.iter = 0xff;
-	return 0;
-}
-
-static int
-nvkm_perfmon_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
-{
-	switch (mthd) {
-	case NVIF_PERFMON_V0_QUERY_DOMAIN:
-		return nvkm_perfmon_mthd_query_domain(object, data, size);
-	case NVIF_PERFMON_V0_QUERY_SIGNAL:
-		return nvkm_perfmon_mthd_query_signal(object, data, size);
-	case NVIF_PERFMON_V0_QUERY_SOURCE:
-		return nvkm_perfmon_mthd_query_source(object, data, size);
-	default:
-		break;
-	}
-	return -EINVAL;
-}
-
-static struct nvkm_ofuncs
-nvkm_perfmon_ofuncs = {
-	.ctor = _nvkm_object_ctor,
-	.dtor = nvkm_object_destroy,
-	.init = nvkm_object_init,
-	.fini = nvkm_object_fini,
-	.mthd = nvkm_perfmon_mthd,
-};
-
 /*******************************************************************************
  * Perfdom object classes
  ******************************************************************************/
@@ -585,6 +410,181 @@ nvkm_perfdom_ofuncs = {
 	.mthd = nvkm_perfdom_mthd,
 };
 
+/*******************************************************************************
+ * Perfmon object classes
+ ******************************************************************************/
+static int
+nvkm_perfmon_mthd_query_domain(struct nvkm_object *object, void *data, u32 size)
+{
+	union {
+		struct nvif_perfmon_query_domain_v0 v0;
+	} *args = data;
+	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_perfdom *dom;
+	u8 domain_nr;
+	int di, ret;
+
+	nv_ioctl(object, "perfmon query domain size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(object, "perfmon domain vers %d iter %02x\n",
+			 args->v0.version, args->v0.iter);
+		di = (args->v0.iter & 0xff) - 1;
+	} else
+		return ret;
+
+	domain_nr = nvkm_pm_count_perfdom(ppm);
+	if (di >= (int)domain_nr)
+		return -EINVAL;
+
+	if (di >= 0) {
+		dom = nvkm_perfdom_find(ppm, di);
+		if (dom == NULL)
+			return -EINVAL;
+
+		args->v0.id         = di;
+		args->v0.signal_nr  = nvkm_perfdom_count_perfsig(dom);
+
+		/* Currently only global counters (PCOUNTER) are implemented
+		 * but this will be different for local counters (MP). */
+		args->v0.counter_nr = 4;
+	}
+
+	if (++di < domain_nr) {
+		args->v0.iter = ++di;
+		return 0;
+	}
+
+	args->v0.iter = 0xff;
+	return 0;
+}
+
+static int
+nvkm_perfmon_mthd_query_signal(struct nvkm_object *object, void *data, u32 size)
+{
+	union {
+		struct nvif_perfmon_query_signal_v0 v0;
+	} *args = data;
+	struct nvkm_device *device = nv_device(object);
+	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_perfdom *dom;
+	struct nvkm_perfsig *sig;
+	const bool all = nvkm_boolopt(device->cfgopt, "NvPmShowAll", false);
+	const bool raw = nvkm_boolopt(device->cfgopt, "NvPmUnnamed", all);
+	int ret, si;
+
+	nv_ioctl(object, "perfmon query signal size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(object,
+			 "perfmon query signal vers %d dom %d iter %04x\n",
+			 args->v0.version, args->v0.domain, args->v0.iter);
+		si = (args->v0.iter & 0xffff) - 1;
+	} else
+		return ret;
+
+	dom = nvkm_perfdom_find(ppm, args->v0.domain);
+	if (dom == NULL || si >= (int)dom->signal_nr)
+		return -EINVAL;
+
+	if (si >= 0) {
+		sig = &dom->signal[si];
+		if (raw || !sig->name) {
+			snprintf(args->v0.name, sizeof(args->v0.name),
+				 "/%s/%02x", dom->name, si);
+		} else {
+			strncpy(args->v0.name, sig->name,
+				sizeof(args->v0.name));
+		}
+
+		args->v0.signal = si;
+		args->v0.source_nr = nvkm_perfsig_count_perfsrc(sig);
+	}
+
+	while (++si < dom->signal_nr) {
+		if (all || dom->signal[si].name) {
+			args->v0.iter = ++si;
+			return 0;
+		}
+	}
+
+	args->v0.iter = 0xffff;
+	return 0;
+}
+
+static int
+nvkm_perfmon_mthd_query_source(struct nvkm_object *object, void *data, u32 size)
+{
+	union {
+		struct nvif_perfmon_query_source_v0 v0;
+	} *args = data;
+	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_perfdom *dom = NULL;
+	struct nvkm_perfsig *sig;
+	struct nvkm_perfsrc *src;
+	u8 source_nr = 0;
+	int si, ret;
+
+	nv_ioctl(object, "perfmon query source size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(object,
+			 "perfmon source vers %d dom %d sig %02x iter %02x\n",
+			 args->v0.version, args->v0.domain, args->v0.signal,
+			 args->v0.iter);
+		si = (args->v0.iter & 0xff) - 1;
+	} else
+		return ret;
+
+	sig = nvkm_perfsig_find(ppm, args->v0.domain, args->v0.signal, &dom);
+	if (!sig)
+		return -EINVAL;
+
+	source_nr = nvkm_perfsig_count_perfsrc(sig);
+	if (si >= (int)source_nr)
+		return -EINVAL;
+
+	if (si >= 0) {
+		src = nvkm_perfsrc_find(ppm, sig, sig->source[si]);
+		if (!src)
+			return -EINVAL;
+
+		args->v0.source = sig->source[si];
+		args->v0.mask   = src->mask;
+		strncpy(args->v0.name, src->name, sizeof(args->v0.name));
+	}
+
+	if (++si < source_nr) {
+		args->v0.iter = ++si;
+		return 0;
+	}
+
+	args->v0.iter = 0xff;
+	return 0;
+}
+
+static int
+nvkm_perfmon_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
+{
+	switch (mthd) {
+	case NVIF_PERFMON_V0_QUERY_DOMAIN:
+		return nvkm_perfmon_mthd_query_domain(object, data, size);
+	case NVIF_PERFMON_V0_QUERY_SIGNAL:
+		return nvkm_perfmon_mthd_query_signal(object, data, size);
+	case NVIF_PERFMON_V0_QUERY_SOURCE:
+		return nvkm_perfmon_mthd_query_source(object, data, size);
+	default:
+		break;
+	}
+	return -EINVAL;
+}
+
+static struct nvkm_ofuncs
+nvkm_perfmon_ofuncs = {
+	.ctor = _nvkm_object_ctor,
+	.dtor = nvkm_object_destroy,
+	.init = nvkm_object_init,
+	.fini = nvkm_object_fini,
+	.mthd = nvkm_perfmon_mthd,
+};
+
 struct nvkm_oclass
 nvkm_pm_sclass[] = {
 	{

commit 6137b5a7c2aeca9f72229c120504f5d083fa9127
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:27 2015 +0200

    drm/nouveau/pm: allow the userspace to configure sources
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset at gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 8960bf4ff459..a4bb6fe5e90b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -125,6 +125,66 @@ nvkm_perfsrc_find(struct nvkm_pm *ppm, struct nvkm_perfsig *sig, int si)
 	return NULL;
 }
 
+static int
+nvkm_perfsrc_enable(struct nvkm_pm *ppm, struct nvkm_perfctr *ctr)
+{
+	struct nvkm_perfdom *dom = NULL;
+	struct nvkm_perfsig *sig;
+	struct nvkm_perfsrc *src;
+	u32 mask, value;
+	int i, j;
+
+	for (i = 0; i < 4 && ctr->signal[i]; i++) {
+		for (j = 0; j < 8 && ctr->source[i][j]; j++) {
+			sig = nvkm_perfsig_find(ppm, ctr->domain,
+						ctr->signal[i], &dom);
+			if (!sig)
+				return -EINVAL;
+
+			src = nvkm_perfsrc_find(ppm, sig, ctr->source[i][j]);
+			if (!src)
+				return -EINVAL;
+
+			/* set enable bit if needed */
+			mask = value = 0x00000000;
+			if (src->enable)
+				mask = value = 0x80000000;
+			mask  |= (src->mask << src->shift);
+			value |= ((ctr->source[i][j] >> 32) << src->shift);
+
+			/* enable the source */
+			nv_mask(ppm, src->addr, mask, value);
+		}
+	}
+	return 0;
+}
+
+static int
+nvkm_perfsrc_disable(struct nvkm_pm *ppm, struct nvkm_perfctr *ctr)
+{
+	struct nvkm_perfdom *dom = NULL;
+	struct nvkm_perfsig *sig;
+	struct nvkm_perfsrc *src;
+	int i, j;
+
+	for (i = 0; i < 4 && ctr->signal[i]; i++) {
+		for (j = 0; j < 8 && ctr->source[i][j]; j++) {
+			sig = nvkm_perfsig_find(ppm, ctr->domain,
+						ctr->signal[i], &dom);
+			if (!sig)
+				return -EINVAL;
+
+			src = nvkm_perfsrc_find(ppm, sig, ctr->source[i][j]);
+			if (!src)
+				return -EINVAL;
+
+			/* disable the source */
+			nv_mask(ppm, src->addr, src->mask << src->shift, 0);
+		}
+	}
+	return 0;
+}
+
 /*******************************************************************************
  * Perfmon object classes
  ******************************************************************************/
@@ -319,10 +379,15 @@ nvkm_perfdom_init(struct nvkm_object *object, void *data, u32 size)
 	} else
 		return ret;
 
-	for (i = 0; i < 4; i++)
-		if (dom->ctr[i])
+	for (i = 0; i < 4; i++) {
+		if (dom->ctr[i]) {
 			dom->func->init(ppm, dom, dom->ctr[i]);
 
+			/* enable sources */
+			nvkm_perfsrc_enable(ppm, dom->ctr[i]);
+		}
+	}
+
 	/* start next batch of counters for sampling */
 	dom->func->next(ppm, dom);
 	return 0;
@@ -402,13 +467,17 @@ nvkm_perfdom_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 static void
 nvkm_perfdom_dtor(struct nvkm_object *object)
 {
+	struct nvkm_pm *ppm = (void *)object->engine;
 	struct nvkm_perfdom *dom = (void *)object;
 	int i;
 
 	for (i = 0; i < 4; i++) {
 		struct nvkm_perfctr *ctr = dom->ctr[i];
-		if (ctr && ctr->head.next)
-			list_del(&ctr->head);
+		if (ctr) {
+			nvkm_perfsrc_disable(ppm, ctr);
+			if (ctr->head.next)
+				list_del(&ctr->head);
+		}
 		kfree(ctr);
 	}
 	nvkm_object_destroy(&dom->base);
@@ -416,11 +485,11 @@ nvkm_perfdom_dtor(struct nvkm_object *object)
 
 static int
 nvkm_perfctr_new(struct nvkm_perfdom *dom, int slot,
-		 struct nvkm_perfsig *signal[4], uint16_t logic_op,
-		 struct nvkm_perfctr **pctr)
+		 struct nvkm_perfsig *signal[4], uint64_t source[4][8],
+		 uint16_t logic_op, struct nvkm_perfctr **pctr)
 {
 	struct nvkm_perfctr *ctr;
-	int i;
+	int i, j;
 
 	if (!dom)
 		return -EINVAL;
@@ -432,8 +501,11 @@ nvkm_perfctr_new(struct nvkm_perfdom *dom, int slot,
 	ctr->logic_op = logic_op;
 	ctr->slot     = slot;
 	for (i = 0; i < 4; i++) {
-		if (signal[i])
+		if (signal[i]) {
 			ctr->signal[i] = signal[i] - dom->signal;
+			for (j = 0; j < 8; j++)
+				ctr->source[i][j] = source[i][j];
+		}
 	}
 	list_add_tail(&ctr->head, &dom->list);
 
@@ -452,7 +524,7 @@ nvkm_perfdom_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	struct nvkm_perfdom *sdom = NULL;
 	struct nvkm_perfctr *ctr[4] = {};
 	struct nvkm_perfdom *dom;
-	int c, s;
+	int c, s, m;
 	int ret;
 
 	nv_ioctl(parent, "create perfdom size %d\n", size);
@@ -464,18 +536,28 @@ nvkm_perfdom_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	for (c = 0; c < ARRAY_SIZE(args->v0.ctr); c++) {
 		struct nvkm_perfsig *sig[4] = {};
+		u64 src[4][8];
+
 		for (s = 0; s < ARRAY_SIZE(args->v0.ctr[c].signal); s++) {
 			sig[s] = nvkm_perfsig_find(ppm, args->v0.domain,
 						   args->v0.ctr[c].signal[s],
 						   &sdom);
 			if (args->v0.ctr[c].signal[s] && !sig[s])
 				return -EINVAL;
+
+			for (m = 0; m < 8; m++) {
+				src[s][m] = args->v0.ctr[c].source[s][m];
+				if (src[s][m] && !nvkm_perfsrc_find(ppm, sig[s],
+							            src[s][m]))
+					return -EINVAL;
+			}
 		}
 
-		ret = nvkm_perfctr_new(sdom, c, sig,
+		ret = nvkm_perfctr_new(sdom, c, sig, src,
 				       args->v0.ctr[c].logic_op, &ctr[c]);
 		if (ret)
 			return ret;
+		ctr[c]->domain = args->v0.domain;
 	}
 
 	if (!sdom)

commit 0f3804360dd4f88332b9c0b2d7cb4c1f30893cc7
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:26 2015 +0200

    drm/nouveau/pm: allow to configure domains instead of simple counters
    
    Configuring counters from the userspace require the kernel to handle some
    logic related to performance counters. Basically, it has to find a free
    slot to assign a counter, to handle extra counting modes like B4/B6 and it
    must return and error when it can't configure a counter.
    
    In my opinion, the kernel should not handle all of that logic but it
    should only write the configuration sent by the userspace without
    checking anything. In other words, it should overwrite the configuration
    even if it's already counting and do not return any errors.
    
    This patch allows the userspace to configure a domain instead of
    separate counters. This has the advantage to move all of the logic to
    the userspace.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 5dbb3b4e2ebb..8960bf4ff459 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -31,9 +31,6 @@
 #include <nvif/ioctl.h>
 #include <nvif/unpack.h>
 
-#define QUAD_MASK 0x0f
-#define QUAD_FREE 0x01
-
 static u8
 nvkm_pm_count_perfdom(struct nvkm_pm *ppm)
 {
@@ -304,32 +301,27 @@ nvkm_perfmon_ofuncs = {
 };
 
 /*******************************************************************************
- * Perfctr object classes
+ * Perfdom object classes
  ******************************************************************************/
 static int
-nvkm_perfctr_init(struct nvkm_object *object, void *data, u32 size)
+nvkm_perfdom_init(struct nvkm_object *object, void *data, u32 size)
 {
 	union {
-		struct nvif_perfctr_init none;
+		struct nvif_perfdom_init none;
 	} *args = data;
 	struct nvkm_pm *ppm = (void *)object->engine;
-	struct nvkm_perfctr *ctr = (void *)object;
-	struct nvkm_perfdom *dom = ctr->dom;
-	int ret;
+	struct nvkm_perfdom *dom = (void *)object;
+	int ret, i;
 
-	nv_ioctl(object, "perfctr init size %d\n", size);
+	nv_ioctl(object, "perfdom init size %d\n", size);
 	if (nvif_unvers(args->none)) {
-		nv_ioctl(object, "perfctr init\n");
+		nv_ioctl(object, "perfdom init\n");
 	} else
 		return ret;
 
-	ctr->slot = ffs(dom->quad) - 1;
-	if (ctr->slot < 0) {
-		/* no free slots are available */
-		return -EINVAL;
-	}
-	dom->quad &= ~(QUAD_FREE << ctr->slot);
-	dom->func->init(ppm, dom, ctr);
+	for (i = 0; i < 4; i++)
+		if (dom->ctr[i])
+			dom->func->init(ppm, dom, dom->ctr[i]);
 
 	/* start next batch of counters for sampling */
 	dom->func->next(ppm, dom);
@@ -337,74 +329,70 @@ nvkm_perfctr_init(struct nvkm_object *object, void *data, u32 size)
 }
 
 static int
-nvkm_perfctr_sample(struct nvkm_object *object, void *data, u32 size)
+nvkm_perfdom_sample(struct nvkm_object *object, void *data, u32 size)
 {
 	union {
-		struct nvif_perfctr_sample none;
+		struct nvif_perfdom_sample none;
 	} *args = data;
 	struct nvkm_pm *ppm = (void *)object->engine;
-	struct nvkm_perfctr *ctr;
 	struct nvkm_perfdom *dom;
 	int ret;
 
-	nv_ioctl(object, "perfctr sample size %d\n", size);
+	nv_ioctl(object, "perfdom sample size %d\n", size);
 	if (nvif_unvers(args->none)) {
-		nv_ioctl(object, "perfctr sample\n");
+		nv_ioctl(object, "perfdom sample\n");
 	} else
 		return ret;
 	ppm->sequence++;
 
-	list_for_each_entry(dom, &ppm->domains, head) {
-		/* sample previous batch of counters */
-		if (dom->quad != QUAD_MASK) {
-			dom->func->next(ppm, dom);
-
-			/* read counter values */
-			list_for_each_entry(ctr, &dom->list, head) {
-				dom->func->read(ppm, dom, ctr);
-				ctr->slot = -1;
-			}
-
-			dom->quad = QUAD_MASK;
-		}
-	}
+	/* sample previous batch of counters */
+	list_for_each_entry(dom, &ppm->domains, head)
+		dom->func->next(ppm, dom);
 
 	return 0;
 }
 
 static int
-nvkm_perfctr_read(struct nvkm_object *object, void *data, u32 size)
+nvkm_perfdom_read(struct nvkm_object *object, void *data, u32 size)
 {
 	union {
-		struct nvif_perfctr_read_v0 v0;
+		struct nvif_perfdom_read_v0 v0;
 	} *args = data;
-	struct nvkm_perfctr *ctr = (void *)object;
-	int ret;
+	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_perfdom *dom = (void *)object;
+	int ret, i;
 
-	nv_ioctl(object, "perfctr read size %d\n", size);
+	nv_ioctl(object, "perfdom read size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(object, "perfctr read vers %d\n", args->v0.version);
+		nv_ioctl(object, "perfdom read vers %d\n", args->v0.version);
 	} else
 		return ret;
 
-	if (!ctr->clk)
+	for (i = 0; i < 4; i++) {
+		if (dom->ctr[i])
+			dom->func->read(ppm, dom, dom->ctr[i]);
+	}
+
+	if (!dom->clk)
 		return -EAGAIN;
 
-	args->v0.clk = ctr->clk;
-	args->v0.ctr = ctr->ctr;
+	for (i = 0; i < 4; i++)
+		if (dom->ctr[i])
+			args->v0.ctr[i] = dom->ctr[i]->ctr;
+	args->v0.clk = dom->clk;
 	return 0;
 }
 
 static int
-nvkm_perfctr_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
+nvkm_perfdom_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
 	switch (mthd) {
-	case NVIF_PERFCTR_V0_INIT:
-		return nvkm_perfctr_init(object, data, size);
-	case NVIF_PERFCTR_V0_SAMPLE:
-		return nvkm_perfctr_sample(object, data, size);
-	case NVIF_PERFCTR_V0_READ:
-		return nvkm_perfctr_read(object, data, size);
+	case NVIF_PERFDOM_V0_INIT:
+		return nvkm_perfdom_init(object, data, size);
+	case NVIF_PERFDOM_V0_SAMPLE:
+		return nvkm_perfdom_sample(object, data, size);
+	case NVIF_PERFDOM_V0_READ:
+		return nvkm_perfdom_read(object, data, size);
 	default:
 		break;
 	}
@@ -412,70 +400,107 @@ nvkm_perfctr_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 }
 
 static void
-nvkm_perfctr_dtor(struct nvkm_object *object)
+nvkm_perfdom_dtor(struct nvkm_object *object)
 {
-	struct nvkm_perfctr *ctr = (void *)object;
-	if (ctr->dom)
-		ctr->dom->quad |= (QUAD_FREE << ctr->slot);
-	if (ctr->head.next)
-		list_del(&ctr->head);
-	nvkm_object_destroy(&ctr->base);
+	struct nvkm_perfdom *dom = (void *)object;
+	int i;
+
+	for (i = 0; i < 4; i++) {
+		struct nvkm_perfctr *ctr = dom->ctr[i];
+		if (ctr && ctr->head.next)
+			list_del(&ctr->head);
+		kfree(ctr);
+	}
+	nvkm_object_destroy(&dom->base);
 }
 
 static int
-nvkm_perfctr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+nvkm_perfctr_new(struct nvkm_perfdom *dom, int slot,
+		 struct nvkm_perfsig *signal[4], uint16_t logic_op,
+		 struct nvkm_perfctr **pctr)
+{
+	struct nvkm_perfctr *ctr;
+	int i;
+
+	if (!dom)
+		return -EINVAL;
+
+	ctr = *pctr = kzalloc(sizeof(*ctr), GFP_KERNEL);
+	if (!ctr)
+		return -ENOMEM;
+
+	ctr->logic_op = logic_op;
+	ctr->slot     = slot;
+	for (i = 0; i < 4; i++) {
+		if (signal[i])
+			ctr->signal[i] = signal[i] - dom->signal;
+	}
+	list_add_tail(&ctr->head, &dom->list);
+
+	return 0;
+}
+
+static int
+nvkm_perfdom_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		  struct nvkm_oclass *oclass, void *data, u32 size,
 		  struct nvkm_object **pobject)
 {
 	union {
-		struct nvif_perfctr_v0 v0;
+		struct nvif_perfdom_v0 v0;
 	} *args = data;
 	struct nvkm_pm *ppm = (void *)engine;
-	struct nvkm_perfdom *dom = NULL;
-	struct nvkm_perfsig *sig[4] = {};
-	struct nvkm_perfctr *ctr;
-	int ret, i;
+	struct nvkm_perfdom *sdom = NULL;
+	struct nvkm_perfctr *ctr[4] = {};
+	struct nvkm_perfdom *dom;
+	int c, s;
+	int ret;
 
-	nv_ioctl(parent, "create perfctr size %d\n", size);
+	nv_ioctl(parent, "create perfdom size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(parent, "create perfctr vers %d logic_op %04x\n",
-			 args->v0.version, args->v0.logic_op);
+		nv_ioctl(parent, "create perfdom vers %d dom %d mode %02x\n",
+			 args->v0.version, args->v0.domain, args->v0.mode);
 	} else
 		return ret;
 
-	for (i = 0; i < ARRAY_SIZE(args->v0.signal); i++) {
-		sig[i] = nvkm_perfsig_find(ppm, args->v0.domain,
-					   args->v0.signal[i], &dom);
-		if (args->v0.signal[i] && !sig[i])
-			return -EINVAL;
+	for (c = 0; c < ARRAY_SIZE(args->v0.ctr); c++) {
+		struct nvkm_perfsig *sig[4] = {};
+		for (s = 0; s < ARRAY_SIZE(args->v0.ctr[c].signal); s++) {
+			sig[s] = nvkm_perfsig_find(ppm, args->v0.domain,
+						   args->v0.ctr[c].signal[s],
+						   &sdom);
+			if (args->v0.ctr[c].signal[s] && !sig[s])
+				return -EINVAL;
+		}
+
+		ret = nvkm_perfctr_new(sdom, c, sig,
+				       args->v0.ctr[c].logic_op, &ctr[c]);
+		if (ret)
+			return ret;
 	}
 
-	if (!dom)
+	if (!sdom)
 		return -EINVAL;
 
-	ret = nvkm_object_create(parent, engine, oclass, 0, &ctr);
-	*pobject = nv_object(ctr);
+	ret = nvkm_object_create(parent, engine, oclass, 0, &dom);
+	*pobject = nv_object(dom);
 	if (ret)
 		return ret;
 
-	ctr->dom = dom;
-	ctr->slot = -1;
-	ctr->logic_op = args->v0.logic_op;
-	ctr->signal[0] = sig[0];
-	ctr->signal[1] = sig[1];
-	ctr->signal[2] = sig[2];
-	ctr->signal[3] = sig[3];
-	list_add_tail(&ctr->head, &dom->list);
+	dom->func = sdom->func;
+	dom->addr = sdom->addr;
+	dom->mode = args->v0.mode;
+	for (c = 0; c < ARRAY_SIZE(ctr); c++)
+		dom->ctr[c] = ctr[c];
 	return 0;
 }
 
 static struct nvkm_ofuncs
-nvkm_perfctr_ofuncs = {
-	.ctor = nvkm_perfctr_ctor,
-	.dtor = nvkm_perfctr_dtor,
+nvkm_perfdom_ofuncs = {
+	.ctor = nvkm_perfdom_ctor,
+	.dtor = nvkm_perfdom_dtor,
 	.init = nvkm_object_init,
 	.fini = nvkm_object_fini,
-	.mthd = nvkm_perfctr_mthd,
+	.mthd = nvkm_perfdom_mthd,
 };
 
 struct nvkm_oclass
@@ -484,8 +509,8 @@ nvkm_pm_sclass[] = {
 	  .handle = NVIF_IOCTL_NEW_V0_PERFMON,
 	  .ofuncs = &nvkm_perfmon_ofuncs,
 	},
-	{ .handle = NVIF_IOCTL_NEW_V0_PERFCTR,
-	  .ofuncs = &nvkm_perfctr_ofuncs,
+	{ .handle = NVIF_IOCTL_NEW_V0_PERFDOM,
+	  .ofuncs = &nvkm_perfdom_ofuncs,
 	},
 	{},
 };
@@ -640,7 +665,6 @@ nvkm_perfdom_new(struct nvkm_pm *ppm, const char *name, u32 mask,
 			INIT_LIST_HEAD(&dom->list);
 			dom->func = sdom->func;
 			dom->addr = addr;
-			dom->quad = QUAD_MASK;
 			dom->signal_nr = sdom->signal_nr;
 
 			ssig = (sdom++)->signal;

commit 3bfdde178a959cb5e490e4a3a2433c95a9a1af26
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:25 2015 +0200

    drm/nouveau/pm: allow the userspace to schedule hardware counters
    
    This adds a new method NVIF_PERFCTR_V0_INIT which starts a batch of
    hardware counters for sampling. This will allow the userspace to start
    a monitoring session using the INIT method and to stop it with SAMPLE,
    for example before and after a frame is rendered.
    
    This commit temporarily breaks nv_perfmon but this is going to be fixed
    with the upcoming patch.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index ec02abfd86b0..5dbb3b4e2ebb 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -306,6 +306,36 @@ nvkm_perfmon_ofuncs = {
 /*******************************************************************************
  * Perfctr object classes
  ******************************************************************************/
+static int
+nvkm_perfctr_init(struct nvkm_object *object, void *data, u32 size)
+{
+	union {
+		struct nvif_perfctr_init none;
+	} *args = data;
+	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_perfctr *ctr = (void *)object;
+	struct nvkm_perfdom *dom = ctr->dom;
+	int ret;
+
+	nv_ioctl(object, "perfctr init size %d\n", size);
+	if (nvif_unvers(args->none)) {
+		nv_ioctl(object, "perfctr init\n");
+	} else
+		return ret;
+
+	ctr->slot = ffs(dom->quad) - 1;
+	if (ctr->slot < 0) {
+		/* no free slots are available */
+		return -EINVAL;
+	}
+	dom->quad &= ~(QUAD_FREE << ctr->slot);
+	dom->func->init(ppm, dom, ctr);
+
+	/* start next batch of counters for sampling */
+	dom->func->next(ppm, dom);
+	return 0;
+}
+
 static int
 nvkm_perfctr_sample(struct nvkm_object *object, void *data, u32 size)
 {
@@ -313,7 +343,7 @@ nvkm_perfctr_sample(struct nvkm_object *object, void *data, u32 size)
 		struct nvif_perfctr_sample none;
 	} *args = data;
 	struct nvkm_pm *ppm = (void *)object->engine;
-	struct nvkm_perfctr *ctr, *tmp;
+	struct nvkm_perfctr *ctr;
 	struct nvkm_perfdom *dom;
 	int ret;
 
@@ -328,32 +358,15 @@ nvkm_perfctr_sample(struct nvkm_object *object, void *data, u32 size)
 		/* sample previous batch of counters */
 		if (dom->quad != QUAD_MASK) {
 			dom->func->next(ppm, dom);
-			tmp = NULL;
-			while (!list_empty(&dom->list)) {
-				ctr = list_first_entry(&dom->list,
-						       typeof(*ctr), head);
-				if (ctr->slot < 0) break;
-				if ( tmp && tmp == ctr) break;
-				if (!tmp) tmp = ctr;
+
+			/* read counter values */
+			list_for_each_entry(ctr, &dom->list, head) {
 				dom->func->read(ppm, dom, ctr);
-				ctr->slot  = -1;
-				list_move_tail(&ctr->head, &dom->list);
+				ctr->slot = -1;
 			}
-		}
-
-		dom->quad = QUAD_MASK;
 
-		/* setup next batch of counters for sampling */
-		list_for_each_entry(ctr, &dom->list, head) {
-			ctr->slot = ffs(dom->quad) - 1;
-			if (ctr->slot < 0)
-				break;
-			dom->quad &= ~(QUAD_FREE << ctr->slot);
-			dom->func->init(ppm, dom, ctr);
+			dom->quad = QUAD_MASK;
 		}
-
-		if (dom->quad != QUAD_MASK)
-			dom->func->next(ppm, dom);
 	}
 
 	return 0;
@@ -386,6 +399,8 @@ static int
 nvkm_perfctr_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
 	switch (mthd) {
+	case NVIF_PERFCTR_V0_INIT:
+		return nvkm_perfctr_init(object, data, size);
 	case NVIF_PERFCTR_V0_SAMPLE:
 		return nvkm_perfctr_sample(object, data, size);
 	case NVIF_PERFCTR_V0_READ:
@@ -400,6 +415,8 @@ static void
 nvkm_perfctr_dtor(struct nvkm_object *object)
 {
 	struct nvkm_perfctr *ctr = (void *)object;
+	if (ctr->dom)
+		ctr->dom->quad |= (QUAD_FREE << ctr->slot);
 	if (ctr->head.next)
 		list_del(&ctr->head);
 	nvkm_object_destroy(&ctr->base);
@@ -441,6 +458,7 @@ nvkm_perfctr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
+	ctr->dom = dom;
 	ctr->slot = -1;
 	ctr->logic_op = args->v0.logic_op;
 	ctr->signal[0] = sig[0];

commit 6f99c84873f455a76a0356061b276bc0c89b5d92
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:24 2015 +0200

    drm/nouveau/pm: implement NVIF_PERFMON_V0_QUERY_SOURCE method
    
    This allows to query the ID, the mask and the user-readable name of
    sources for each signal.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index a9c57a20186a..ec02abfd86b0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -103,6 +103,31 @@ nvkm_perfsig_count_perfsrc(struct nvkm_perfsig *sig)
 	return source_nr;
 }
 
+static struct nvkm_perfsrc *
+nvkm_perfsrc_find(struct nvkm_pm *ppm, struct nvkm_perfsig *sig, int si)
+{
+	struct nvkm_perfsrc *src;
+	bool found = false;
+	int tmp = 1; /* Sources ID start from 1 */
+	u8 i;
+
+	for (i = 0; i < ARRAY_SIZE(sig->source) && sig->source[i]; i++) {
+		if (sig->source[i] == si) {
+			found = true;
+			break;
+		}
+	}
+
+	if (found) {
+		list_for_each_entry(src, &ppm->sources, head) {
+			if (tmp++ == si)
+				return src;
+		}
+	}
+
+	return NULL;
+}
+
 /*******************************************************************************
  * Perfmon object classes
  ******************************************************************************/
@@ -203,6 +228,56 @@ nvkm_perfmon_mthd_query_signal(struct nvkm_object *object, void *data, u32 size)
 	return 0;
 }
 
+static int
+nvkm_perfmon_mthd_query_source(struct nvkm_object *object, void *data, u32 size)
+{
+	union {
+		struct nvif_perfmon_query_source_v0 v0;
+	} *args = data;
+	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_perfdom *dom = NULL;
+	struct nvkm_perfsig *sig;
+	struct nvkm_perfsrc *src;
+	u8 source_nr = 0;
+	int si, ret;
+
+	nv_ioctl(object, "perfmon query source size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(object,
+			 "perfmon source vers %d dom %d sig %02x iter %02x\n",
+			 args->v0.version, args->v0.domain, args->v0.signal,
+			 args->v0.iter);
+		si = (args->v0.iter & 0xff) - 1;
+	} else
+		return ret;
+
+	sig = nvkm_perfsig_find(ppm, args->v0.domain, args->v0.signal, &dom);
+	if (!sig)
+		return -EINVAL;
+
+	source_nr = nvkm_perfsig_count_perfsrc(sig);
+	if (si >= (int)source_nr)
+		return -EINVAL;
+
+	if (si >= 0) {
+		src = nvkm_perfsrc_find(ppm, sig, sig->source[si]);
+		if (!src)
+			return -EINVAL;
+
+		args->v0.source = sig->source[si];
+		args->v0.mask   = src->mask;
+		strncpy(args->v0.name, src->name, sizeof(args->v0.name));
+	}
+
+	if (++si < source_nr) {
+		args->v0.iter = ++si;
+		return 0;
+	}
+
+	args->v0.iter = 0xff;
+	return 0;
+}
+
 static int
 nvkm_perfmon_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
@@ -211,6 +286,8 @@ nvkm_perfmon_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 		return nvkm_perfmon_mthd_query_domain(object, data, size);
 	case NVIF_PERFMON_V0_QUERY_SIGNAL:
 		return nvkm_perfmon_mthd_query_signal(object, data, size);
+	case NVIF_PERFMON_V0_QUERY_SOURCE:
+		return nvkm_perfmon_mthd_query_source(object, data, size);
 	default:
 		break;
 	}

commit 50d138d7528c3370ebf3a54079091a35a60a23be
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:23 2015 +0200

    drm/nouveau/pm: allow to query the number of sources for a signal
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index dfafefd9facf..a9c57a20186a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -91,6 +91,18 @@ nvkm_perfsig_find(struct nvkm_pm *ppm, uint8_t di, uint8_t si,
 	return &dom->signal[si];
 }
 
+static u8
+nvkm_perfsig_count_perfsrc(struct nvkm_perfsig *sig)
+{
+	u8 source_nr = 0, i;
+
+	for (i = 0; i < ARRAY_SIZE(sig->source); i++) {
+		if (sig->source[i])
+			source_nr++;
+	}
+	return source_nr;
+}
+
 /*******************************************************************************
  * Perfmon object classes
  ******************************************************************************/
@@ -148,9 +160,9 @@ nvkm_perfmon_mthd_query_signal(struct nvkm_object *object, void *data, u32 size)
 	struct nvkm_device *device = nv_device(object);
 	struct nvkm_pm *ppm = (void *)object->engine;
 	struct nvkm_perfdom *dom;
+	struct nvkm_perfsig *sig;
 	const bool all = nvkm_boolopt(device->cfgopt, "NvPmShowAll", false);
 	const bool raw = nvkm_boolopt(device->cfgopt, "NvPmUnnamed", all);
-	const char *name;
 	int ret, si;
 
 	nv_ioctl(object, "perfmon query signal size %d\n", size);
@@ -167,13 +179,17 @@ nvkm_perfmon_mthd_query_signal(struct nvkm_object *object, void *data, u32 size)
 		return -EINVAL;
 
 	if (si >= 0) {
-		if (raw || !(name = dom->signal[si].name)) {
+		sig = &dom->signal[si];
+		if (raw || !sig->name) {
 			snprintf(args->v0.name, sizeof(args->v0.name),
 				 "/%s/%02x", dom->name, si);
 		} else {
-			strncpy(args->v0.name, name, sizeof(args->v0.name));
+			strncpy(args->v0.name, sig->name,
+				sizeof(args->v0.name));
 		}
+
 		args->v0.signal = si;
+		args->v0.source_nr = nvkm_perfsig_count_perfsrc(sig);
 	}
 
 	while (++si < dom->signal_nr) {

commit e82661e23c60fc41424ca138820d729d8e4a2226
Author: Samuel Pitoiset <samuel.pitoisetgmail.com>
Date:   Sun Jun 7 22:40:22 2015 +0200

    drm/nouveau/pm: add concept of sources
    
    A source (or multiplexer) is a tuple addr+mask+shift which allows to
    control a block of signals. The maximum number of sources that a signal
    can define is arbitrary limited to 8 and this should be large enough.
    This patch allows to define multi-level of sources for a signal.
    
    Each different sources are stored to a global list and will be exposed
    to the userspace through the nvif interface in order to avoid conflicts.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset at gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 610c0ca5c80b..dfafefd9facf 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -433,6 +433,67 @@ nvkm_pm_cclass = {
 /*******************************************************************************
  * PPM engine/subdev functions
  ******************************************************************************/
+int
+nvkm_perfsrc_new(struct nvkm_pm *ppm, struct nvkm_perfsig *sig,
+		 const struct nvkm_specsrc *spec)
+{
+	const struct nvkm_specsrc *ssrc;
+	const struct nvkm_specmux *smux;
+	struct nvkm_perfsrc *src;
+	u8 source_nr = 0;
+
+	if (!spec) {
+		/* No sources are defined for this signal. */
+		return 0;
+	}
+
+	ssrc = spec;
+	while (ssrc->name) {
+		smux = ssrc->mux;
+		while (smux->name) {
+			bool found = false;
+			u8 source_id = 0;
+			u32 len;
+
+			list_for_each_entry(src, &ppm->sources, head) {
+				if (src->addr == ssrc->addr &&
+				    src->shift == smux->shift) {
+					found = true;
+					break;
+				}
+				source_id++;
+			}
+
+			if (!found) {
+				src = kzalloc(sizeof(*src), GFP_KERNEL);
+				if (!src)
+					return -ENOMEM;
+
+				src->addr   = ssrc->addr;
+				src->mask   = smux->mask;
+				src->shift  = smux->shift;
+				src->enable = smux->enable;
+
+				len = strlen(ssrc->name) +
+				      strlen(smux->name) + 2;
+				src->name = kzalloc(len, GFP_KERNEL);
+				if (!src->name)
+					return -ENOMEM;
+				snprintf(src->name, len, "%s_%s", ssrc->name,
+					 smux->name);
+
+				list_add_tail(&src->head, &ppm->sources);
+			}
+
+			sig->source[source_nr++] = source_id + 1;
+			smux++;
+		}
+		ssrc++;
+	}
+
+	return 0;
+}
+
 int
 nvkm_perfdom_new(struct nvkm_pm *ppm, const char *name, u32 mask,
 		 u32 base, u32 size_unit, u32 size_domain,
@@ -441,7 +502,7 @@ nvkm_perfdom_new(struct nvkm_pm *ppm, const char *name, u32 mask,
 	const struct nvkm_specdom *sdom;
 	const struct nvkm_specsig *ssig;
 	struct nvkm_perfdom *dom;
-	int i;
+	int ret, i;
 
 	for (i = 0; i == 0 || mask; i++) {
 		u32 addr = base + (i * size_unit);
@@ -473,7 +534,12 @@ nvkm_perfdom_new(struct nvkm_pm *ppm, const char *name, u32 mask,
 
 			ssig = (sdom++)->signal;
 			while (ssig->name) {
-				dom->signal[ssig->signal].name = ssig->name;
+				struct nvkm_perfsig *sig =
+					&dom->signal[ssig->signal];
+				sig->name = ssig->name;
+				ret = nvkm_perfsrc_new(ppm, sig, ssig->source);
+				if (ret)
+					return ret;
 				ssig++;
 			}
 
@@ -504,13 +570,20 @@ void
 _nvkm_pm_dtor(struct nvkm_object *object)
 {
 	struct nvkm_pm *ppm = (void *)object;
-	struct nvkm_perfdom *dom, *tmp;
+	struct nvkm_perfdom *dom, *next_dom;
+	struct nvkm_perfsrc *src, *next_src;
 
-	list_for_each_entry_safe(dom, tmp, &ppm->domains, head) {
+	list_for_each_entry_safe(dom, next_dom, &ppm->domains, head) {
 		list_del(&dom->head);
 		kfree(dom);
 	}
 
+	list_for_each_entry_safe(src, next_src, &ppm->sources, head) {
+		list_del(&src->head);
+		kfree(src->name);
+		kfree(src);
+	}
+
 	nvkm_engine_destroy(&ppm->base);
 }
 
@@ -528,5 +601,6 @@ nvkm_pm_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		return ret;
 
 	INIT_LIST_HEAD(&ppm->domains);
+	INIT_LIST_HEAD(&ppm->sources);
 	return 0;
 }

commit 40a3b22c92ac3dad5adc818a84671bfb00303731
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:21 2015 +0200

    drm/nouveau/pm: allow to monitor hardware signal index 0x00
    
    This signal index must be always allowed even if it's not clearly
    defined in a domain in order to monitor a counter like 0x03020100
    because it's the default value of signals.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 71834b96ca9e..610c0ca5c80b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -333,10 +333,10 @@ nvkm_perfctr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	} else
 		return ret;
 
-	for (i = 0; i < ARRAY_SIZE(args->v0.signal) && args->v0.signal[i]; i++) {
+	for (i = 0; i < ARRAY_SIZE(args->v0.signal); i++) {
 		sig[i] = nvkm_perfsig_find(ppm, args->v0.domain,
 					   args->v0.signal[i], &dom);
-		if (!sig[i])
+		if (args->v0.signal[i] && !sig[i])
 			return -EINVAL;
 	}
 

commit 10a4d2b2489394e32f17afc6cc63ccdfc1b6050b
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:20 2015 +0200

    drm/nouveau/pm: use hardware signals indexes instead of user-readable names
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index fab05985ba40..71834b96ca9e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -73,49 +73,22 @@ nvkm_perfdom_find(struct nvkm_pm *ppm, int di)
 	return NULL;
 }
 
-static struct nvkm_perfsig *
-nvkm_perfsig_find_(struct nvkm_perfdom *dom, const char *name, u32 size)
-{
-	char path[64];
-	int i;
-
-	if (name[0] != '/') {
-		for (i = 0; i < dom->signal_nr; i++) {
-			if ( dom->signal[i].name &&
-			    !strncmp(name, dom->signal[i].name, size))
-				return &dom->signal[i];
-		}
-	} else {
-		for (i = 0; i < dom->signal_nr; i++) {
-			snprintf(path, sizeof(path), "/%s/%02x", dom->name, i);
-			if (!strncmp(name, path, size))
-				return &dom->signal[i];
-		}
-	}
-
-	return NULL;
-}
-
 struct nvkm_perfsig *
-nvkm_perfsig_find(struct nvkm_pm *ppm, const char *name, u32 size,
+nvkm_perfsig_find(struct nvkm_pm *ppm, uint8_t di, uint8_t si,
 		  struct nvkm_perfdom **pdom)
 {
 	struct nvkm_perfdom *dom = *pdom;
-	struct nvkm_perfsig *sig;
 
 	if (dom == NULL) {
-		list_for_each_entry(dom, &ppm->domains, head) {
-			sig = nvkm_perfsig_find_(dom, name, size);
-			if (sig) {
-				*pdom = dom;
-				return sig;
-			}
-		}
-
-		return NULL;
+		dom = nvkm_perfdom_find(ppm, di);
+		if (dom == NULL)
+			return NULL;
+		*pdom = dom;
 	}
 
-	return nvkm_perfsig_find_(dom, name, size);
+	if (!dom->signal[si].name)
+		return NULL;
+	return &dom->signal[si];
 }
 
 /*******************************************************************************
@@ -200,6 +173,7 @@ nvkm_perfmon_mthd_query_signal(struct nvkm_object *object, void *data, u32 size)
 		} else {
 			strncpy(args->v0.name, name, sizeof(args->v0.name));
 		}
+		args->v0.signal = si;
 	}
 
 	while (++si < dom->signal_nr) {
@@ -359,11 +333,9 @@ nvkm_perfctr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	} else
 		return ret;
 
-	for (i = 0; i < ARRAY_SIZE(args->v0.name) && args->v0.name[i][0]; i++) {
-		sig[i] = nvkm_perfsig_find(ppm, args->v0.name[i],
-					   strnlen(args->v0.name[i],
-						   sizeof(args->v0.name[i])),
-					   &dom);
+	for (i = 0; i < ARRAY_SIZE(args->v0.signal) && args->v0.signal[i]; i++) {
+		sig[i] = nvkm_perfsig_find(ppm, args->v0.domain,
+					   args->v0.signal[i], &dom);
 		if (!sig[i])
 			return -EINVAL;
 	}

commit e4047599aede7a7aca97ace770002c4e29e403d2
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:19 2015 +0200

    drm/nouveau/pm: change signal iter to u16
    
    16 bits is large enough to store the maximum number of signals available
    for one domain (i.e. 256).
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index d61beffd2404..fab05985ba40 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -45,10 +45,10 @@ nvkm_pm_count_perfdom(struct nvkm_pm *ppm)
 	return domain_nr;
 }
 
-static u32
+static u16
 nvkm_perfdom_count_perfsig(struct nvkm_perfdom *dom)
 {
-	u32 signal_nr = 0;
+	u16 signal_nr = 0;
 	int i;
 
 	if (dom) {
@@ -183,9 +183,9 @@ nvkm_perfmon_mthd_query_signal(struct nvkm_object *object, void *data, u32 size)
 	nv_ioctl(object, "perfmon query signal size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
 		nv_ioctl(object,
-			 "perfmon query signal vers %d dom %d iter %08x\n",
+			 "perfmon query signal vers %d dom %d iter %04x\n",
 			 args->v0.version, args->v0.domain, args->v0.iter);
-		si = (args->v0.iter & 0xffffffff) - 1;
+		si = (args->v0.iter & 0xffff) - 1;
 	} else
 		return ret;
 
@@ -209,7 +209,7 @@ nvkm_perfmon_mthd_query_signal(struct nvkm_object *object, void *data, u32 size)
 		}
 	}
 
-	args->v0.iter = 0xffffffff;
+	args->v0.iter = 0xffff;
 	return 0;
 }
 

commit 3e1b33571ab4937cbd400976a115e4922797559a
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:18 2015 +0200

    drm/nouveau/pm: allow to query signals by domain
    
    This will allow to configure performance counters with hardware signal
    indexes instead of user-readable names in an upcoming patch.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 3d9bcbc1064c..d61beffd2404 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -174,29 +174,22 @@ nvkm_perfmon_mthd_query_signal(struct nvkm_object *object, void *data, u32 size)
 	} *args = data;
 	struct nvkm_device *device = nv_device(object);
 	struct nvkm_pm *ppm = (void *)object->engine;
-	struct nvkm_perfdom *dom = NULL, *chk;
+	struct nvkm_perfdom *dom;
 	const bool all = nvkm_boolopt(device->cfgopt, "NvPmShowAll", false);
 	const bool raw = nvkm_boolopt(device->cfgopt, "NvPmUnnamed", all);
 	const char *name;
-	int tmp = 0, di, si;
-	int ret;
+	int ret, si;
 
 	nv_ioctl(object, "perfmon query signal size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(object, "perfmon query signal vers %d iter %08x\n",
-			 args->v0.version, args->v0.iter);
-		di = (args->v0.iter & 0xff000000) >> 24;
-		si = (args->v0.iter & 0x00ffffff) - 1;
+		nv_ioctl(object,
+			 "perfmon query signal vers %d dom %d iter %08x\n",
+			 args->v0.version, args->v0.domain, args->v0.iter);
+		si = (args->v0.iter & 0xffffffff) - 1;
 	} else
 		return ret;
 
-	list_for_each_entry(chk, &ppm->domains, head) {
-		if (tmp++ == di) {
-			dom = chk;
-			break;
-		}
-	}
-
+	dom = nvkm_perfdom_find(ppm, args->v0.domain);
 	if (dom == NULL || si >= (int)dom->signal_nr)
 		return -EINVAL;
 
@@ -209,17 +202,12 @@ nvkm_perfmon_mthd_query_signal(struct nvkm_object *object, void *data, u32 size)
 		}
 	}
 
-	do {
-		while (++si < dom->signal_nr) {
-			if (all || dom->signal[si].name) {
-				args->v0.iter = (di << 24) | ++si;
-				return 0;
-			}
+	while (++si < dom->signal_nr) {
+		if (all || dom->signal[si].name) {
+			args->v0.iter = ++si;
+			return 0;
 		}
-		si = -1;
-		di = di + 1;
-		dom = list_entry(dom->head.next, typeof(*dom), head);
-	} while (&dom->head != &ppm->domains);
+	}
 
 	args->v0.iter = 0xffffffff;
 	return 0;

commit 45f0f94db285009a41a94e069618ea9bb269af84
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:17 2015 +0200

    drm/nouveau/pm: implement NVIF_PERFMON_V0_QUERY_DOMAIN method
    
    This allows to query the number of available domains, including the
    number of hardware counter and the number of signals per domain.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 2f851473cecf..3d9bcbc1064c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -34,6 +34,45 @@
 #define QUAD_MASK 0x0f
 #define QUAD_FREE 0x01
 
+static u8
+nvkm_pm_count_perfdom(struct nvkm_pm *ppm)
+{
+	struct nvkm_perfdom *dom;
+	u8 domain_nr = 0;
+
+	list_for_each_entry(dom, &ppm->domains, head)
+		domain_nr++;
+	return domain_nr;
+}
+
+static u32
+nvkm_perfdom_count_perfsig(struct nvkm_perfdom *dom)
+{
+	u32 signal_nr = 0;
+	int i;
+
+	if (dom) {
+		for (i = 0; i < dom->signal_nr; i++) {
+			if (dom->signal[i].name)
+				signal_nr++;
+		}
+	}
+	return signal_nr;
+}
+
+static struct nvkm_perfdom *
+nvkm_perfdom_find(struct nvkm_pm *ppm, int di)
+{
+	struct nvkm_perfdom *dom;
+	int tmp = 0;
+
+	list_for_each_entry(dom, &ppm->domains, head) {
+		if (tmp++ == di)
+			return dom;
+	}
+	return NULL;
+}
+
 static struct nvkm_perfsig *
 nvkm_perfsig_find_(struct nvkm_perfdom *dom, const char *name, u32 size)
 {
@@ -82,6 +121,51 @@ nvkm_perfsig_find(struct nvkm_pm *ppm, const char *name, u32 size,
 /*******************************************************************************
  * Perfmon object classes
  ******************************************************************************/
+static int
+nvkm_perfmon_mthd_query_domain(struct nvkm_object *object, void *data, u32 size)
+{
+	union {
+		struct nvif_perfmon_query_domain_v0 v0;
+	} *args = data;
+	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_perfdom *dom;
+	u8 domain_nr;
+	int di, ret;
+
+	nv_ioctl(object, "perfmon query domain size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(object, "perfmon domain vers %d iter %02x\n",
+			 args->v0.version, args->v0.iter);
+		di = (args->v0.iter & 0xff) - 1;
+	} else
+		return ret;
+
+	domain_nr = nvkm_pm_count_perfdom(ppm);
+	if (di >= (int)domain_nr)
+		return -EINVAL;
+
+	if (di >= 0) {
+		dom = nvkm_perfdom_find(ppm, di);
+		if (dom == NULL)
+			return -EINVAL;
+
+		args->v0.id         = di;
+		args->v0.signal_nr  = nvkm_perfdom_count_perfsig(dom);
+
+		/* Currently only global counters (PCOUNTER) are implemented
+		 * but this will be different for local counters (MP). */
+		args->v0.counter_nr = 4;
+	}
+
+	if (++di < domain_nr) {
+		args->v0.iter = ++di;
+		return 0;
+	}
+
+	args->v0.iter = 0xff;
+	return 0;
+}
+
 static int
 nvkm_perfmon_mthd_query_signal(struct nvkm_object *object, void *data, u32 size)
 {
@@ -145,6 +229,8 @@ static int
 nvkm_perfmon_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
 	switch (mthd) {
+	case NVIF_PERFMON_V0_QUERY_DOMAIN:
+		return nvkm_perfmon_mthd_query_domain(object, data, size);
 	case NVIF_PERFMON_V0_QUERY_SIGNAL:
 		return nvkm_perfmon_mthd_query_signal(object, data, size);
 	default:

commit 44d9de58ea5633e4f2d062e718016383b28b4eed
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:16 2015 +0200

    drm/nouveau/pm: prevent creating a perfctr object when signals are not found
    
    Since a new class has been introduced to query signals, we can now
    return an error when the userspace wants to monitor unknown signals.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index cb88170610bb..2f851473cecf 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -294,6 +294,9 @@ nvkm_perfctr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 			return -EINVAL;
 	}
 
+	if (!dom)
+		return -EINVAL;
+
 	ret = nvkm_object_create(parent, engine, oclass, 0, &ctr);
 	*pobject = nv_object(ctr);
 	if (ret)
@@ -305,8 +308,7 @@ nvkm_perfctr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	ctr->signal[1] = sig[1];
 	ctr->signal[2] = sig[2];
 	ctr->signal[3] = sig[3];
-	if (dom)
-		list_add_tail(&ctr->head, &dom->list);
+	list_add_tail(&ctr->head, &dom->list);
 	return 0;
 }
 

commit 5a0bc4b5aeba3bb32eb7da6a98108e93bbd64f7e
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:15 2015 +0200

    drm/nouveau/pm: reorganize the nvif interface
    
    This commit introduces the NVIF_IOCTL_NEW_V0_PERFMON class which will be
    used in order to query domains, signals and sources. This separates the
    querying and the counting interface.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 7b07e8b04052..cb88170610bb 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -83,10 +83,10 @@ nvkm_perfsig_find(struct nvkm_pm *ppm, const char *name, u32 size,
  * Perfmon object classes
  ******************************************************************************/
 static int
-nvkm_perfctr_query(struct nvkm_object *object, void *data, u32 size)
+nvkm_perfmon_mthd_query_signal(struct nvkm_object *object, void *data, u32 size)
 {
 	union {
-		struct nvif_perfctr_query_v0 v0;
+		struct nvif_perfmon_query_signal_v0 v0;
 	} *args = data;
 	struct nvkm_device *device = nv_device(object);
 	struct nvkm_pm *ppm = (void *)object->engine;
@@ -97,9 +97,9 @@ nvkm_perfctr_query(struct nvkm_object *object, void *data, u32 size)
 	int tmp = 0, di, si;
 	int ret;
 
-	nv_ioctl(object, "perfctr query size %d\n", size);
+	nv_ioctl(object, "perfmon query signal size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(object, "perfctr query vers %d iter %08x\n",
+		nv_ioctl(object, "perfmon query signal vers %d iter %08x\n",
 			 args->v0.version, args->v0.iter);
 		di = (args->v0.iter & 0xff000000) >> 24;
 		si = (args->v0.iter & 0x00ffffff) - 1;
@@ -141,6 +141,30 @@ nvkm_perfctr_query(struct nvkm_object *object, void *data, u32 size)
 	return 0;
 }
 
+static int
+nvkm_perfmon_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
+{
+	switch (mthd) {
+	case NVIF_PERFMON_V0_QUERY_SIGNAL:
+		return nvkm_perfmon_mthd_query_signal(object, data, size);
+	default:
+		break;
+	}
+	return -EINVAL;
+}
+
+static struct nvkm_ofuncs
+nvkm_perfmon_ofuncs = {
+	.ctor = _nvkm_object_ctor,
+	.dtor = nvkm_object_destroy,
+	.init = nvkm_object_init,
+	.fini = nvkm_object_fini,
+	.mthd = nvkm_perfmon_mthd,
+};
+
+/*******************************************************************************
+ * Perfctr object classes
+ ******************************************************************************/
 static int
 nvkm_perfctr_sample(struct nvkm_object *object, void *data, u32 size)
 {
@@ -221,8 +245,6 @@ static int
 nvkm_perfctr_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
 	switch (mthd) {
-	case NVIF_PERFCTR_V0_QUERY:
-		return nvkm_perfctr_query(object, data, size);
 	case NVIF_PERFCTR_V0_SAMPLE:
 		return nvkm_perfctr_sample(object, data, size);
 	case NVIF_PERFCTR_V0_READ:
@@ -299,6 +321,10 @@ nvkm_perfctr_ofuncs = {
 
 struct nvkm_oclass
 nvkm_pm_sclass[] = {
+	{
+	  .handle = NVIF_IOCTL_NEW_V0_PERFMON,
+	  .ofuncs = &nvkm_perfmon_ofuncs,
+	},
 	{ .handle = NVIF_IOCTL_NEW_V0_PERFCTR,
 	  .ofuncs = &nvkm_perfctr_ofuncs,
 	},

commit a78ce96f96d76311fd165207a6ffb64b0ebd85cc
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:14 2015 +0200

    drm/nouveau/pm: remove unused nvkm_perfsig_wrap() function
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 4cf36a3aa814..7b07e8b04052 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -79,26 +79,6 @@ nvkm_perfsig_find(struct nvkm_pm *ppm, const char *name, u32 size,
 	return nvkm_perfsig_find_(dom, name, size);
 }
 
-struct nvkm_perfctr *
-nvkm_perfsig_wrap(struct nvkm_pm *ppm, const char *name,
-		  struct nvkm_perfdom **pdom)
-{
-	struct nvkm_perfsig *sig;
-	struct nvkm_perfctr *ctr;
-
-	sig = nvkm_perfsig_find(ppm, name, strlen(name), pdom);
-	if (!sig)
-		return NULL;
-
-	ctr = kzalloc(sizeof(*ctr), GFP_KERNEL);
-	if (ctr) {
-		ctr->signal[0] = sig;
-		ctr->logic_op = 0xaaaa;
-	}
-
-	return ctr;
-}
-
 /*******************************************************************************
  * Perfmon object classes
  ******************************************************************************/

commit 305c1959ea60ddcae5142a20c50db849a40c2a35
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:12 2015 +0200

    drm/nouveau/pm: fix a potential race condition when creating an engine context
    
    There is always the possiblity that the ppm->context pointer would get
    partially updated and accidentally would equal ctx. This would allow two
    contexts to co-exist, which is not acceptable. Moving the test to the
    critical section takes care of this problem.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 274457ca3fef..4cf36a3aa814 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -358,12 +358,11 @@ nvkm_perfctx_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	mutex_lock(&nv_subdev(ppm)->mutex);
 	if (ppm->context == NULL)
 		ppm->context = ctx;
-	mutex_unlock(&nv_subdev(ppm)->mutex);
-
 	if (ctx != ppm->context)
-		return -EBUSY;
+		ret = -EBUSY;
+	mutex_unlock(&nv_subdev(ppm)->mutex);
 
-	return 0;
+	return ret;
 }
 
 struct nvkm_oclass

commit 3693d544056b822f7f2454da5acb7eda9471b902
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:11 2015 +0200

    drm/nouveau/pm: prevent freeing the wrong engine context
    
    This fixes a crash when multiple PM engine contexts are created.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 2006c445938d..274457ca3fef 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -332,9 +332,12 @@ static void
 nvkm_perfctx_dtor(struct nvkm_object *object)
 {
 	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_perfctx *ctx = (void *)object;
+
 	mutex_lock(&nv_subdev(ppm)->mutex);
-	nvkm_engctx_destroy(&ppm->context->base);
-	ppm->context = NULL;
+	nvkm_engctx_destroy(&ctx->base);
+	if (ppm->context == ctx)
+		ppm->context = NULL;
 	mutex_unlock(&nv_subdev(ppm)->mutex);
 }
 

commit 4d34686eb607037dafffb9d66d9e50b4648cfda4
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:31:13 2015 +1000

    drm/nouveau/pm: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 5efb308e5d1c..2006c445938d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -21,22 +21,21 @@
  *
  * Authors: Ben Skeggs
  */
+#include "priv.h"
 
 #include <core/client.h>
+#include <core/device.h>
 #include <core/option.h>
-#include <nvif/unpack.h>
+
 #include <nvif/class.h>
 #include <nvif/ioctl.h>
-
-#include <subdev/clk.h>
-
-#include "priv.h"
+#include <nvif/unpack.h>
 
 #define QUAD_MASK 0x0f
 #define QUAD_FREE 0x01
 
-static struct nouveau_perfsig *
-nouveau_perfsig_find_(struct nouveau_perfdom *dom, const char *name, u32 size)
+static struct nvkm_perfsig *
+nvkm_perfsig_find_(struct nvkm_perfdom *dom, const char *name, u32 size)
 {
 	char path[64];
 	int i;
@@ -58,16 +57,16 @@ nouveau_perfsig_find_(struct nouveau_perfdom *dom, const char *name, u32 size)
 	return NULL;
 }
 
-struct nouveau_perfsig *
-nouveau_perfsig_find(struct nouveau_pm *ppm, const char *name, u32 size,
-		     struct nouveau_perfdom **pdom)
+struct nvkm_perfsig *
+nvkm_perfsig_find(struct nvkm_pm *ppm, const char *name, u32 size,
+		  struct nvkm_perfdom **pdom)
 {
-	struct nouveau_perfdom *dom = *pdom;
-	struct nouveau_perfsig *sig;
+	struct nvkm_perfdom *dom = *pdom;
+	struct nvkm_perfsig *sig;
 
 	if (dom == NULL) {
 		list_for_each_entry(dom, &ppm->domains, head) {
-			sig = nouveau_perfsig_find_(dom, name, size);
+			sig = nvkm_perfsig_find_(dom, name, size);
 			if (sig) {
 				*pdom = dom;
 				return sig;
@@ -77,17 +76,17 @@ nouveau_perfsig_find(struct nouveau_pm *ppm, const char *name, u32 size,
 		return NULL;
 	}
 
-	return nouveau_perfsig_find_(dom, name, size);
+	return nvkm_perfsig_find_(dom, name, size);
 }
 
-struct nouveau_perfctr *
-nouveau_perfsig_wrap(struct nouveau_pm *ppm, const char *name,
-		     struct nouveau_perfdom **pdom)
+struct nvkm_perfctr *
+nvkm_perfsig_wrap(struct nvkm_pm *ppm, const char *name,
+		  struct nvkm_perfdom **pdom)
 {
-	struct nouveau_perfsig *sig;
-	struct nouveau_perfctr *ctr;
+	struct nvkm_perfsig *sig;
+	struct nvkm_perfctr *ctr;
 
-	sig = nouveau_perfsig_find(ppm, name, strlen(name), pdom);
+	sig = nvkm_perfsig_find(ppm, name, strlen(name), pdom);
 	if (!sig)
 		return NULL;
 
@@ -104,16 +103,16 @@ nouveau_perfsig_wrap(struct nouveau_pm *ppm, const char *name,
  * Perfmon object classes
  ******************************************************************************/
 static int
-nouveau_perfctr_query(struct nouveau_object *object, void *data, u32 size)
+nvkm_perfctr_query(struct nvkm_object *object, void *data, u32 size)
 {
 	union {
 		struct nvif_perfctr_query_v0 v0;
 	} *args = data;
-	struct nouveau_device *device = nv_device(object);
-	struct nouveau_pm *ppm = (void *)object->engine;
-	struct nouveau_perfdom *dom = NULL, *chk;
-	const bool all = nouveau_boolopt(device->cfgopt, "NvPmShowAll", false);
-	const bool raw = nouveau_boolopt(device->cfgopt, "NvPmUnnamed", all);
+	struct nvkm_device *device = nv_device(object);
+	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_perfdom *dom = NULL, *chk;
+	const bool all = nvkm_boolopt(device->cfgopt, "NvPmShowAll", false);
+	const bool raw = nvkm_boolopt(device->cfgopt, "NvPmUnnamed", all);
 	const char *name;
 	int tmp = 0, di, si;
 	int ret;
@@ -163,14 +162,14 @@ nouveau_perfctr_query(struct nouveau_object *object, void *data, u32 size)
 }
 
 static int
-nouveau_perfctr_sample(struct nouveau_object *object, void *data, u32 size)
+nvkm_perfctr_sample(struct nvkm_object *object, void *data, u32 size)
 {
 	union {
 		struct nvif_perfctr_sample none;
 	} *args = data;
-	struct nouveau_pm *ppm = (void *)object->engine;
-	struct nouveau_perfctr *ctr, *tmp;
-	struct nouveau_perfdom *dom;
+	struct nvkm_pm *ppm = (void *)object->engine;
+	struct nvkm_perfctr *ctr, *tmp;
+	struct nvkm_perfdom *dom;
 	int ret;
 
 	nv_ioctl(object, "perfctr sample size %d\n", size);
@@ -187,7 +186,7 @@ nouveau_perfctr_sample(struct nouveau_object *object, void *data, u32 size)
 			tmp = NULL;
 			while (!list_empty(&dom->list)) {
 				ctr = list_first_entry(&dom->list,
-							typeof(*ctr), head);
+						       typeof(*ctr), head);
 				if (ctr->slot < 0) break;
 				if ( tmp && tmp == ctr) break;
 				if (!tmp) tmp = ctr;
@@ -216,12 +215,12 @@ nouveau_perfctr_sample(struct nouveau_object *object, void *data, u32 size)
 }
 
 static int
-nouveau_perfctr_read(struct nouveau_object *object, void *data, u32 size)
+nvkm_perfctr_read(struct nvkm_object *object, void *data, u32 size)
 {
 	union {
 		struct nvif_perfctr_read_v0 v0;
 	} *args = data;
-	struct nouveau_perfctr *ctr = (void *)object;
+	struct nvkm_perfctr *ctr = (void *)object;
 	int ret;
 
 	nv_ioctl(object, "perfctr read size %d\n", size);
@@ -239,16 +238,15 @@ nouveau_perfctr_read(struct nouveau_object *object, void *data, u32 size)
 }
 
 static int
-nouveau_perfctr_mthd(struct nouveau_object *object, u32 mthd,
-		     void *data, u32 size)
+nvkm_perfctr_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
 	switch (mthd) {
 	case NVIF_PERFCTR_V0_QUERY:
-		return nouveau_perfctr_query(object, data, size);
+		return nvkm_perfctr_query(object, data, size);
 	case NVIF_PERFCTR_V0_SAMPLE:
-		return nouveau_perfctr_sample(object, data, size);
+		return nvkm_perfctr_sample(object, data, size);
 	case NVIF_PERFCTR_V0_READ:
-		return nouveau_perfctr_read(object, data, size);
+		return nvkm_perfctr_read(object, data, size);
 	default:
 		break;
 	}
@@ -256,27 +254,26 @@ nouveau_perfctr_mthd(struct nouveau_object *object, u32 mthd,
 }
 
 static void
-nouveau_perfctr_dtor(struct nouveau_object *object)
+nvkm_perfctr_dtor(struct nvkm_object *object)
 {
-	struct nouveau_perfctr *ctr = (void *)object;
+	struct nvkm_perfctr *ctr = (void *)object;
 	if (ctr->head.next)
 		list_del(&ctr->head);
-	nouveau_object_destroy(&ctr->base);
+	nvkm_object_destroy(&ctr->base);
 }
 
 static int
-nouveau_perfctr_ctor(struct nouveau_object *parent,
-		     struct nouveau_object *engine,
-		     struct nouveau_oclass *oclass, void *data, u32 size,
-		     struct nouveau_object **pobject)
+nvkm_perfctr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+		  struct nvkm_oclass *oclass, void *data, u32 size,
+		  struct nvkm_object **pobject)
 {
 	union {
 		struct nvif_perfctr_v0 v0;
 	} *args = data;
-	struct nouveau_pm *ppm = (void *)engine;
-	struct nouveau_perfdom *dom = NULL;
-	struct nouveau_perfsig *sig[4] = {};
-	struct nouveau_perfctr *ctr;
+	struct nvkm_pm *ppm = (void *)engine;
+	struct nvkm_perfdom *dom = NULL;
+	struct nvkm_perfsig *sig[4] = {};
+	struct nvkm_perfctr *ctr;
 	int ret, i;
 
 	nv_ioctl(parent, "create perfctr size %d\n", size);
@@ -287,15 +284,15 @@ nouveau_perfctr_ctor(struct nouveau_object *parent,
 		return ret;
 
 	for (i = 0; i < ARRAY_SIZE(args->v0.name) && args->v0.name[i][0]; i++) {
-		sig[i] = nouveau_perfsig_find(ppm, args->v0.name[i],
-					      strnlen(args->v0.name[i],
-					      sizeof(args->v0.name[i])),
-					      &dom);
+		sig[i] = nvkm_perfsig_find(ppm, args->v0.name[i],
+					   strnlen(args->v0.name[i],
+						   sizeof(args->v0.name[i])),
+					   &dom);
 		if (!sig[i])
 			return -EINVAL;
 	}
 
-	ret = nouveau_object_create(parent, engine, oclass, 0, &ctr);
+	ret = nvkm_object_create(parent, engine, oclass, 0, &ctr);
 	*pobject = nv_object(ctr);
 	if (ret)
 		return ret;
@@ -311,19 +308,19 @@ nouveau_perfctr_ctor(struct nouveau_object *parent,
 	return 0;
 }
 
-static struct nouveau_ofuncs
-nouveau_perfctr_ofuncs = {
-	.ctor = nouveau_perfctr_ctor,
-	.dtor = nouveau_perfctr_dtor,
-	.init = nouveau_object_init,
-	.fini = nouveau_object_fini,
-	.mthd = nouveau_perfctr_mthd,
+static struct nvkm_ofuncs
+nvkm_perfctr_ofuncs = {
+	.ctor = nvkm_perfctr_ctor,
+	.dtor = nvkm_perfctr_dtor,
+	.init = nvkm_object_init,
+	.fini = nvkm_object_fini,
+	.mthd = nvkm_perfctr_mthd,
 };
 
-struct nouveau_oclass
-nouveau_pm_sclass[] = {
+struct nvkm_oclass
+nvkm_pm_sclass[] = {
 	{ .handle = NVIF_IOCTL_NEW_V0_PERFCTR,
-	  .ofuncs = &nouveau_perfctr_ofuncs,
+	  .ofuncs = &nvkm_perfctr_ofuncs,
 	},
 	{},
 };
@@ -332,27 +329,25 @@ nouveau_pm_sclass[] = {
  * PPM context
  ******************************************************************************/
 static void
-nouveau_perfctx_dtor(struct nouveau_object *object)
+nvkm_perfctx_dtor(struct nvkm_object *object)
 {
-	struct nouveau_pm *ppm = (void *)object->engine;
+	struct nvkm_pm *ppm = (void *)object->engine;
 	mutex_lock(&nv_subdev(ppm)->mutex);
-	nouveau_engctx_destroy(&ppm->context->base);
+	nvkm_engctx_destroy(&ppm->context->base);
 	ppm->context = NULL;
 	mutex_unlock(&nv_subdev(ppm)->mutex);
 }
 
 static int
-nouveau_perfctx_ctor(struct nouveau_object *parent,
-		     struct nouveau_object *engine,
-		     struct nouveau_oclass *oclass, void *data, u32 size,
-		     struct nouveau_object **pobject)
+nvkm_perfctx_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+		  struct nvkm_oclass *oclass, void *data, u32 size,
+		  struct nvkm_object **pobject)
 {
-	struct nouveau_pm *ppm = (void *)engine;
-	struct nouveau_perfctx *ctx;
+	struct nvkm_pm *ppm = (void *)engine;
+	struct nvkm_perfctx *ctx;
 	int ret;
 
-	ret = nouveau_engctx_create(parent, engine, oclass, NULL,
-				    0, 0, 0, &ctx);
+	ret = nvkm_engctx_create(parent, engine, oclass, NULL, 0, 0, 0, &ctx);
 	*pobject = nv_object(ctx);
 	if (ret)
 		return ret;
@@ -368,14 +363,14 @@ nouveau_perfctx_ctor(struct nouveau_object *parent,
 	return 0;
 }
 
-struct nouveau_oclass
-nouveau_pm_cclass = {
+struct nvkm_oclass
+nvkm_pm_cclass = {
 	.handle = NV_ENGCTX(PM, 0x00),
-	.ofuncs = &(struct nouveau_ofuncs) {
-		.ctor = nouveau_perfctx_ctor,
-		.dtor = nouveau_perfctx_dtor,
-		.init = _nouveau_engctx_init,
-		.fini = _nouveau_engctx_fini,
+	.ofuncs = &(struct nvkm_ofuncs) {
+		.ctor = nvkm_perfctx_ctor,
+		.dtor = nvkm_perfctx_dtor,
+		.init = _nvkm_engctx_init,
+		.fini = _nvkm_engctx_fini,
 	},
 };
 
@@ -383,13 +378,13 @@ nouveau_pm_cclass = {
  * PPM engine/subdev functions
  ******************************************************************************/
 int
-nouveau_perfdom_new(struct nouveau_pm *ppm, const char *name, u32 mask,
-		    u32 base, u32 size_unit, u32 size_domain,
-		    const struct nouveau_specdom *spec)
+nvkm_perfdom_new(struct nvkm_pm *ppm, const char *name, u32 mask,
+		 u32 base, u32 size_unit, u32 size_domain,
+		 const struct nvkm_specdom *spec)
 {
-	const struct nouveau_specdom *sdom;
-	const struct nouveau_specsig *ssig;
-	struct nouveau_perfdom *dom;
+	const struct nvkm_specdom *sdom;
+	const struct nvkm_specsig *ssig;
+	struct nvkm_perfdom *dom;
 	int i;
 
 	for (i = 0; i == 0 || mask; i++) {
@@ -436,44 +431,42 @@ nouveau_perfdom_new(struct nouveau_pm *ppm, const char *name, u32 mask,
 }
 
 int
-_nouveau_pm_fini(struct nouveau_object *object, bool suspend)
+_nvkm_pm_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nouveau_pm *ppm = (void *)object;
-	return nouveau_engine_fini(&ppm->base, suspend);
+	struct nvkm_pm *ppm = (void *)object;
+	return nvkm_engine_fini(&ppm->base, suspend);
 }
 
 int
-_nouveau_pm_init(struct nouveau_object *object)
+_nvkm_pm_init(struct nvkm_object *object)
 {
-	struct nouveau_pm *ppm = (void *)object;
-	return nouveau_engine_init(&ppm->base);
+	struct nvkm_pm *ppm = (void *)object;
+	return nvkm_engine_init(&ppm->base);
 }
 
 void
-_nouveau_pm_dtor(struct nouveau_object *object)
+_nvkm_pm_dtor(struct nvkm_object *object)
 {
-	struct nouveau_pm *ppm = (void *)object;
-	struct nouveau_perfdom *dom, *tmp;
+	struct nvkm_pm *ppm = (void *)object;
+	struct nvkm_perfdom *dom, *tmp;
 
 	list_for_each_entry_safe(dom, tmp, &ppm->domains, head) {
 		list_del(&dom->head);
 		kfree(dom);
 	}
 
-	nouveau_engine_destroy(&ppm->base);
+	nvkm_engine_destroy(&ppm->base);
 }
 
 int
-nouveau_pm_create_(struct nouveau_object *parent,
-			struct nouveau_object *engine,
-			struct nouveau_oclass *oclass,
-			int length, void **pobject)
+nvkm_pm_create_(struct nvkm_object *parent, struct nvkm_object *engine,
+		struct nvkm_oclass *oclass, int length, void **pobject)
 {
-	struct nouveau_pm *ppm;
+	struct nvkm_pm *ppm;
 	int ret;
 
-	ret = nouveau_engine_create_(parent, engine, oclass, true, "PPM",
-				     "pm", length, pobject);
+	ret = nvkm_engine_create_(parent, engine, oclass, true, "PPM",
+				  "pm", length, pobject);
 	ppm = *pobject;
 	if (ret)
 		return ret;

commit d5752b9b86fbfb8febd9d45ac4431325031e25e0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 12:11:28 2015 +1000

    drm/nouveau/pm: rename from perfmon (no binary change)
    
    Switch to NVIDIA's name for the device.
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
new file mode 100644
index 000000000000..5efb308e5d1c
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -0,0 +1,483 @@
+/*
+ * Copyright 2013 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <core/client.h>
+#include <core/option.h>
+#include <nvif/unpack.h>
+#include <nvif/class.h>
+#include <nvif/ioctl.h>
+
+#include <subdev/clk.h>
+
+#include "priv.h"
+
+#define QUAD_MASK 0x0f
+#define QUAD_FREE 0x01
+
+static struct nouveau_perfsig *
+nouveau_perfsig_find_(struct nouveau_perfdom *dom, const char *name, u32 size)
+{
+	char path[64];
+	int i;
+
+	if (name[0] != '/') {
+		for (i = 0; i < dom->signal_nr; i++) {
+			if ( dom->signal[i].name &&
+			    !strncmp(name, dom->signal[i].name, size))
+				return &dom->signal[i];
+		}
+	} else {
+		for (i = 0; i < dom->signal_nr; i++) {
+			snprintf(path, sizeof(path), "/%s/%02x", dom->name, i);
+			if (!strncmp(name, path, size))
+				return &dom->signal[i];
+		}
+	}
+
+	return NULL;
+}
+
+struct nouveau_perfsig *
+nouveau_perfsig_find(struct nouveau_pm *ppm, const char *name, u32 size,
+		     struct nouveau_perfdom **pdom)
+{
+	struct nouveau_perfdom *dom = *pdom;
+	struct nouveau_perfsig *sig;
+
+	if (dom == NULL) {
+		list_for_each_entry(dom, &ppm->domains, head) {
+			sig = nouveau_perfsig_find_(dom, name, size);
+			if (sig) {
+				*pdom = dom;
+				return sig;
+			}
+		}
+
+		return NULL;
+	}
+
+	return nouveau_perfsig_find_(dom, name, size);
+}
+
+struct nouveau_perfctr *
+nouveau_perfsig_wrap(struct nouveau_pm *ppm, const char *name,
+		     struct nouveau_perfdom **pdom)
+{
+	struct nouveau_perfsig *sig;
+	struct nouveau_perfctr *ctr;
+
+	sig = nouveau_perfsig_find(ppm, name, strlen(name), pdom);
+	if (!sig)
+		return NULL;
+
+	ctr = kzalloc(sizeof(*ctr), GFP_KERNEL);
+	if (ctr) {
+		ctr->signal[0] = sig;
+		ctr->logic_op = 0xaaaa;
+	}
+
+	return ctr;
+}
+
+/*******************************************************************************
+ * Perfmon object classes
+ ******************************************************************************/
+static int
+nouveau_perfctr_query(struct nouveau_object *object, void *data, u32 size)
+{
+	union {
+		struct nvif_perfctr_query_v0 v0;
+	} *args = data;
+	struct nouveau_device *device = nv_device(object);
+	struct nouveau_pm *ppm = (void *)object->engine;
+	struct nouveau_perfdom *dom = NULL, *chk;
+	const bool all = nouveau_boolopt(device->cfgopt, "NvPmShowAll", false);
+	const bool raw = nouveau_boolopt(device->cfgopt, "NvPmUnnamed", all);
+	const char *name;
+	int tmp = 0, di, si;
+	int ret;
+
+	nv_ioctl(object, "perfctr query size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(object, "perfctr query vers %d iter %08x\n",
+			 args->v0.version, args->v0.iter);
+		di = (args->v0.iter & 0xff000000) >> 24;
+		si = (args->v0.iter & 0x00ffffff) - 1;
+	} else
+		return ret;
+
+	list_for_each_entry(chk, &ppm->domains, head) {
+		if (tmp++ == di) {
+			dom = chk;
+			break;
+		}
+	}
+
+	if (dom == NULL || si >= (int)dom->signal_nr)
+		return -EINVAL;
+
+	if (si >= 0) {
+		if (raw || !(name = dom->signal[si].name)) {
+			snprintf(args->v0.name, sizeof(args->v0.name),
+				 "/%s/%02x", dom->name, si);
+		} else {
+			strncpy(args->v0.name, name, sizeof(args->v0.name));
+		}
+	}
+
+	do {
+		while (++si < dom->signal_nr) {
+			if (all || dom->signal[si].name) {
+				args->v0.iter = (di << 24) | ++si;
+				return 0;
+			}
+		}
+		si = -1;
+		di = di + 1;
+		dom = list_entry(dom->head.next, typeof(*dom), head);
+	} while (&dom->head != &ppm->domains);
+
+	args->v0.iter = 0xffffffff;
+	return 0;
+}
+
+static int
+nouveau_perfctr_sample(struct nouveau_object *object, void *data, u32 size)
+{
+	union {
+		struct nvif_perfctr_sample none;
+	} *args = data;
+	struct nouveau_pm *ppm = (void *)object->engine;
+	struct nouveau_perfctr *ctr, *tmp;
+	struct nouveau_perfdom *dom;
+	int ret;
+
+	nv_ioctl(object, "perfctr sample size %d\n", size);
+	if (nvif_unvers(args->none)) {
+		nv_ioctl(object, "perfctr sample\n");
+	} else
+		return ret;
+	ppm->sequence++;
+
+	list_for_each_entry(dom, &ppm->domains, head) {
+		/* sample previous batch of counters */
+		if (dom->quad != QUAD_MASK) {
+			dom->func->next(ppm, dom);
+			tmp = NULL;
+			while (!list_empty(&dom->list)) {
+				ctr = list_first_entry(&dom->list,
+							typeof(*ctr), head);
+				if (ctr->slot < 0) break;
+				if ( tmp && tmp == ctr) break;
+				if (!tmp) tmp = ctr;
+				dom->func->read(ppm, dom, ctr);
+				ctr->slot  = -1;
+				list_move_tail(&ctr->head, &dom->list);
+			}
+		}
+
+		dom->quad = QUAD_MASK;
+
+		/* setup next batch of counters for sampling */
+		list_for_each_entry(ctr, &dom->list, head) {
+			ctr->slot = ffs(dom->quad) - 1;
+			if (ctr->slot < 0)
+				break;
+			dom->quad &= ~(QUAD_FREE << ctr->slot);
+			dom->func->init(ppm, dom, ctr);
+		}
+
+		if (dom->quad != QUAD_MASK)
+			dom->func->next(ppm, dom);
+	}
+
+	return 0;
+}
+
+static int
+nouveau_perfctr_read(struct nouveau_object *object, void *data, u32 size)
+{
+	union {
+		struct nvif_perfctr_read_v0 v0;
+	} *args = data;
+	struct nouveau_perfctr *ctr = (void *)object;
+	int ret;
+
+	nv_ioctl(object, "perfctr read size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(object, "perfctr read vers %d\n", args->v0.version);
+	} else
+		return ret;
+
+	if (!ctr->clk)
+		return -EAGAIN;
+
+	args->v0.clk = ctr->clk;
+	args->v0.ctr = ctr->ctr;
+	return 0;
+}
+
+static int
+nouveau_perfctr_mthd(struct nouveau_object *object, u32 mthd,
+		     void *data, u32 size)
+{
+	switch (mthd) {
+	case NVIF_PERFCTR_V0_QUERY:
+		return nouveau_perfctr_query(object, data, size);
+	case NVIF_PERFCTR_V0_SAMPLE:
+		return nouveau_perfctr_sample(object, data, size);
+	case NVIF_PERFCTR_V0_READ:
+		return nouveau_perfctr_read(object, data, size);
+	default:
+		break;
+	}
+	return -EINVAL;
+}
+
+static void
+nouveau_perfctr_dtor(struct nouveau_object *object)
+{
+	struct nouveau_perfctr *ctr = (void *)object;
+	if (ctr->head.next)
+		list_del(&ctr->head);
+	nouveau_object_destroy(&ctr->base);
+}
+
+static int
+nouveau_perfctr_ctor(struct nouveau_object *parent,
+		     struct nouveau_object *engine,
+		     struct nouveau_oclass *oclass, void *data, u32 size,
+		     struct nouveau_object **pobject)
+{
+	union {
+		struct nvif_perfctr_v0 v0;
+	} *args = data;
+	struct nouveau_pm *ppm = (void *)engine;
+	struct nouveau_perfdom *dom = NULL;
+	struct nouveau_perfsig *sig[4] = {};
+	struct nouveau_perfctr *ctr;
+	int ret, i;
+
+	nv_ioctl(parent, "create perfctr size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(parent, "create perfctr vers %d logic_op %04x\n",
+			 args->v0.version, args->v0.logic_op);
+	} else
+		return ret;
+
+	for (i = 0; i < ARRAY_SIZE(args->v0.name) && args->v0.name[i][0]; i++) {
+		sig[i] = nouveau_perfsig_find(ppm, args->v0.name[i],
+					      strnlen(args->v0.name[i],
+					      sizeof(args->v0.name[i])),
+					      &dom);
+		if (!sig[i])
+			return -EINVAL;
+	}
+
+	ret = nouveau_object_create(parent, engine, oclass, 0, &ctr);
+	*pobject = nv_object(ctr);
+	if (ret)
+		return ret;
+
+	ctr->slot = -1;
+	ctr->logic_op = args->v0.logic_op;
+	ctr->signal[0] = sig[0];
+	ctr->signal[1] = sig[1];
+	ctr->signal[2] = sig[2];
+	ctr->signal[3] = sig[3];
+	if (dom)
+		list_add_tail(&ctr->head, &dom->list);
+	return 0;
+}
+
+static struct nouveau_ofuncs
+nouveau_perfctr_ofuncs = {
+	.ctor = nouveau_perfctr_ctor,
+	.dtor = nouveau_perfctr_dtor,
+	.init = nouveau_object_init,
+	.fini = nouveau_object_fini,
+	.mthd = nouveau_perfctr_mthd,
+};
+
+struct nouveau_oclass
+nouveau_pm_sclass[] = {
+	{ .handle = NVIF_IOCTL_NEW_V0_PERFCTR,
+	  .ofuncs = &nouveau_perfctr_ofuncs,
+	},
+	{},
+};
+
+/*******************************************************************************
+ * PPM context
+ ******************************************************************************/
+static void
+nouveau_perfctx_dtor(struct nouveau_object *object)
+{
+	struct nouveau_pm *ppm = (void *)object->engine;
+	mutex_lock(&nv_subdev(ppm)->mutex);
+	nouveau_engctx_destroy(&ppm->context->base);
+	ppm->context = NULL;
+	mutex_unlock(&nv_subdev(ppm)->mutex);
+}
+
+static int
+nouveau_perfctx_ctor(struct nouveau_object *parent,
+		     struct nouveau_object *engine,
+		     struct nouveau_oclass *oclass, void *data, u32 size,
+		     struct nouveau_object **pobject)
+{
+	struct nouveau_pm *ppm = (void *)engine;
+	struct nouveau_perfctx *ctx;
+	int ret;
+
+	ret = nouveau_engctx_create(parent, engine, oclass, NULL,
+				    0, 0, 0, &ctx);
+	*pobject = nv_object(ctx);
+	if (ret)
+		return ret;
+
+	mutex_lock(&nv_subdev(ppm)->mutex);
+	if (ppm->context == NULL)
+		ppm->context = ctx;
+	mutex_unlock(&nv_subdev(ppm)->mutex);
+
+	if (ctx != ppm->context)
+		return -EBUSY;
+
+	return 0;
+}
+
+struct nouveau_oclass
+nouveau_pm_cclass = {
+	.handle = NV_ENGCTX(PM, 0x00),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nouveau_perfctx_ctor,
+		.dtor = nouveau_perfctx_dtor,
+		.init = _nouveau_engctx_init,
+		.fini = _nouveau_engctx_fini,
+	},
+};
+
+/*******************************************************************************
+ * PPM engine/subdev functions
+ ******************************************************************************/
+int
+nouveau_perfdom_new(struct nouveau_pm *ppm, const char *name, u32 mask,
+		    u32 base, u32 size_unit, u32 size_domain,
+		    const struct nouveau_specdom *spec)
+{
+	const struct nouveau_specdom *sdom;
+	const struct nouveau_specsig *ssig;
+	struct nouveau_perfdom *dom;
+	int i;
+
+	for (i = 0; i == 0 || mask; i++) {
+		u32 addr = base + (i * size_unit);
+		if (i && !(mask & (1 << i)))
+			continue;
+
+		sdom = spec;
+		while (sdom->signal_nr) {
+			dom = kzalloc(sizeof(*dom) + sdom->signal_nr *
+				      sizeof(*dom->signal), GFP_KERNEL);
+			if (!dom)
+				return -ENOMEM;
+
+			if (mask) {
+				snprintf(dom->name, sizeof(dom->name),
+					 "%s/%02x/%02x", name, i,
+					 (int)(sdom - spec));
+			} else {
+				snprintf(dom->name, sizeof(dom->name),
+					 "%s/%02x", name, (int)(sdom - spec));
+			}
+
+			list_add_tail(&dom->head, &ppm->domains);
+			INIT_LIST_HEAD(&dom->list);
+			dom->func = sdom->func;
+			dom->addr = addr;
+			dom->quad = QUAD_MASK;
+			dom->signal_nr = sdom->signal_nr;
+
+			ssig = (sdom++)->signal;
+			while (ssig->name) {
+				dom->signal[ssig->signal].name = ssig->name;
+				ssig++;
+			}
+
+			addr += size_domain;
+		}
+
+		mask &= ~(1 << i);
+	}
+
+	return 0;
+}
+
+int
+_nouveau_pm_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nouveau_pm *ppm = (void *)object;
+	return nouveau_engine_fini(&ppm->base, suspend);
+}
+
+int
+_nouveau_pm_init(struct nouveau_object *object)
+{
+	struct nouveau_pm *ppm = (void *)object;
+	return nouveau_engine_init(&ppm->base);
+}
+
+void
+_nouveau_pm_dtor(struct nouveau_object *object)
+{
+	struct nouveau_pm *ppm = (void *)object;
+	struct nouveau_perfdom *dom, *tmp;
+
+	list_for_each_entry_safe(dom, tmp, &ppm->domains, head) {
+		list_del(&dom->head);
+		kfree(dom);
+	}
+
+	nouveau_engine_destroy(&ppm->base);
+}
+
+int
+nouveau_pm_create_(struct nouveau_object *parent,
+			struct nouveau_object *engine,
+			struct nouveau_oclass *oclass,
+			int length, void **pobject)
+{
+	struct nouveau_pm *ppm;
+	int ret;
+
+	ret = nouveau_engine_create_(parent, engine, oclass, true, "PPM",
+				     "pm", length, pobject);
+	ppm = *pobject;
+	if (ret)
+		return ret;
+
+	INIT_LIST_HEAD(&ppm->domains);
+	return 0;
+}
