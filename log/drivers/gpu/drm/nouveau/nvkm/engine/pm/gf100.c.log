commit f3a8b6645dc2e60d11f20c1c23afd964ff4e55ae
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 4 11:44:21 2016 +1000

    drm/nouveau: silence sparse warnings about symbols not being marked static
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
index d2901e9a7808..fe2532ee4145 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
@@ -102,7 +102,7 @@ gf100_pm_gpc[] = {
 	{}
 };
 
-const struct nvkm_specdom
+static const struct nvkm_specdom
 gf100_pm_part[] = {
 	{ 0xe0, (const struct nvkm_specsig[]) {
 			{ 0x0f, "part00_pbfb_00", gf100_pbfb_sources },

commit 97070f23c60869830039b216ff88230f54ef7107
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/pm: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
index 18e0ed514249..d2901e9a7808 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
@@ -129,7 +129,6 @@ gf100_perfctr_init(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 		   struct nvkm_perfctr *ctr)
 {
 	struct nvkm_device *device = pm->engine.subdev.device;
-	struct gf100_pm_cntr *cntr = (void *)ctr;
 	u32 log = ctr->logic_op;
 	u32 src = 0x00000000;
 	int i;
@@ -139,8 +138,8 @@ gf100_perfctr_init(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 
 	nvkm_wr32(device, dom->addr + 0x09c, 0x00040002 | (dom->mode << 3));
 	nvkm_wr32(device, dom->addr + 0x100, 0x00000000);
-	nvkm_wr32(device, dom->addr + 0x040 + (cntr->base.slot * 0x08), src);
-	nvkm_wr32(device, dom->addr + 0x044 + (cntr->base.slot * 0x08), log);
+	nvkm_wr32(device, dom->addr + 0x040 + (ctr->slot * 0x08), src);
+	nvkm_wr32(device, dom->addr + 0x044 + (ctr->slot * 0x08), log);
 }
 
 static void
@@ -148,13 +147,12 @@ gf100_perfctr_read(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 		   struct nvkm_perfctr *ctr)
 {
 	struct nvkm_device *device = pm->engine.subdev.device;
-	struct gf100_pm_cntr *cntr = (void *)ctr;
 
-	switch (cntr->base.slot) {
-	case 0: cntr->base.ctr = nvkm_rd32(device, dom->addr + 0x08c); break;
-	case 1: cntr->base.ctr = nvkm_rd32(device, dom->addr + 0x088); break;
-	case 2: cntr->base.ctr = nvkm_rd32(device, dom->addr + 0x080); break;
-	case 3: cntr->base.ctr = nvkm_rd32(device, dom->addr + 0x090); break;
+	switch (ctr->slot) {
+	case 0: ctr->ctr = nvkm_rd32(device, dom->addr + 0x08c); break;
+	case 1: ctr->ctr = nvkm_rd32(device, dom->addr + 0x088); break;
+	case 2: ctr->ctr = nvkm_rd32(device, dom->addr + 0x080); break;
+	case 3: ctr->ctr = nvkm_rd32(device, dom->addr + 0x090); break;
 	}
 	dom->clk = nvkm_rd32(device, dom->addr + 0x070);
 }
@@ -174,35 +172,37 @@ gf100_perfctr_func = {
 	.next = gf100_perfctr_next,
 };
 
-int
-gf100_pm_fini(struct nvkm_object *object, bool suspend)
+static void
+gf100_pm_fini(struct nvkm_pm *pm)
 {
-	struct nvkm_pm *pm = (void *)object;
 	struct nvkm_device *device = pm->engine.subdev.device;
 	nvkm_mask(device, 0x000200, 0x10000000, 0x00000000);
 	nvkm_mask(device, 0x000200, 0x10000000, 0x10000000);
-	return nvkm_pm_fini(pm, suspend);
 }
 
+static const struct nvkm_pm_func
+gf100_pm_ = {
+	.fini = gf100_pm_fini,
+};
+
 int
-gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-	      struct nvkm_oclass *oclass, void *data, u32 size,
-	      struct nvkm_object **pobject)
+gf100_pm_new_(const struct gf100_pm_func *func, struct nvkm_device *device,
+	      int index, struct nvkm_pm **ppm)
 {
-	struct gf100_pm_oclass *mclass = (void *)oclass;
-	struct nvkm_device *device = (void *)parent;
 	struct nvkm_pm *pm;
 	u32 mask;
 	int ret;
 
-	ret = nvkm_pm_create(parent, engine, oclass, &pm);
-	*pobject = nv_object(pm);
+	if (!(pm = *ppm = kzalloc(sizeof(*pm), GFP_KERNEL)))
+		return -ENOMEM;
+
+	ret = nvkm_pm_ctor(&gf100_pm_, device, index, pm);
 	if (ret)
 		return ret;
 
 	/* HUB */
 	ret = nvkm_perfdom_new(pm, "hub", 0, 0x1b0000, 0, 0x200,
-			       mclass->doms_hub);
+			       func->doms_hub);
 	if (ret)
 		return ret;
 
@@ -212,7 +212,7 @@ gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	mask &= ~nvkm_rd32(device, 0x022584);
 
 	ret = nvkm_perfdom_new(pm, "gpc", mask, 0x180000,
-			       0x1000, 0x200, mclass->doms_gpc);
+			       0x1000, 0x200, func->doms_gpc);
 	if (ret)
 		return ret;
 
@@ -222,23 +222,22 @@ gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	mask &= ~nvkm_rd32(device, 0x0225c8);
 
 	ret = nvkm_perfdom_new(pm, "part", mask, 0x1a0000,
-			       0x1000, 0x200, mclass->doms_part);
+			       0x1000, 0x200, func->doms_part);
 	if (ret)
 		return ret;
 
 	return 0;
 }
 
-struct nvkm_oclass *
-gf100_pm_oclass = &(struct gf100_pm_oclass) {
-	.base.handle = NV_ENGINE(PM, 0xc0),
-	.base.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = gf100_pm_ctor,
-		.dtor = _nvkm_pm_dtor,
-		.init = _nvkm_pm_init,
-		.fini = gf100_pm_fini,
-	},
-	.doms_gpc  = gf100_pm_gpc,
-	.doms_hub  = gf100_pm_hub,
+static const struct gf100_pm_func
+gf100_pm = {
+	.doms_gpc = gf100_pm_gpc,
+	.doms_hub = gf100_pm_hub,
 	.doms_part = gf100_pm_part,
-}.base;
+};
+
+int
+gf100_pm_new(struct nvkm_device *device, int index, struct nvkm_pm **ppm)
+{
+	return gf100_pm_new_(&gf100_pm, device, index, ppm);
+}

commit 5ffeb84b8eba71b4f88af6997db843ddf68149e0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/pm: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
index 75a9e6286101..18e0ed514249 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
@@ -226,8 +226,6 @@ gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	nv_engine(pm)->cclass = &nvkm_pm_cclass;
-	nv_engine(pm)->sclass =  nvkm_pm_sclass;
 	return 0;
 }
 

commit 846e831d953fd01cb78b9ed92495baee142bed37
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:10 2015 +1000

    drm/nouveau/pm: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
index cb3f52d2f24b..75a9e6286101 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
@@ -128,6 +128,7 @@ static void
 gf100_perfctr_init(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 		   struct nvkm_perfctr *ctr)
 {
+	struct nvkm_device *device = pm->engine.subdev.device;
 	struct gf100_pm_cntr *cntr = (void *)ctr;
 	u32 log = ctr->logic_op;
 	u32 src = 0x00000000;
@@ -136,32 +137,34 @@ gf100_perfctr_init(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 	for (i = 0; i < 4; i++)
 		src |= ctr->signal[i] << (i * 8);
 
-	nv_wr32(pm, dom->addr + 0x09c, 0x00040002 | (dom->mode << 3));
-	nv_wr32(pm, dom->addr + 0x100, 0x00000000);
-	nv_wr32(pm, dom->addr + 0x040 + (cntr->base.slot * 0x08), src);
-	nv_wr32(pm, dom->addr + 0x044 + (cntr->base.slot * 0x08), log);
+	nvkm_wr32(device, dom->addr + 0x09c, 0x00040002 | (dom->mode << 3));
+	nvkm_wr32(device, dom->addr + 0x100, 0x00000000);
+	nvkm_wr32(device, dom->addr + 0x040 + (cntr->base.slot * 0x08), src);
+	nvkm_wr32(device, dom->addr + 0x044 + (cntr->base.slot * 0x08), log);
 }
 
 static void
 gf100_perfctr_read(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 		   struct nvkm_perfctr *ctr)
 {
+	struct nvkm_device *device = pm->engine.subdev.device;
 	struct gf100_pm_cntr *cntr = (void *)ctr;
 
 	switch (cntr->base.slot) {
-	case 0: cntr->base.ctr = nv_rd32(pm, dom->addr + 0x08c); break;
-	case 1: cntr->base.ctr = nv_rd32(pm, dom->addr + 0x088); break;
-	case 2: cntr->base.ctr = nv_rd32(pm, dom->addr + 0x080); break;
-	case 3: cntr->base.ctr = nv_rd32(pm, dom->addr + 0x090); break;
+	case 0: cntr->base.ctr = nvkm_rd32(device, dom->addr + 0x08c); break;
+	case 1: cntr->base.ctr = nvkm_rd32(device, dom->addr + 0x088); break;
+	case 2: cntr->base.ctr = nvkm_rd32(device, dom->addr + 0x080); break;
+	case 3: cntr->base.ctr = nvkm_rd32(device, dom->addr + 0x090); break;
 	}
-	dom->clk = nv_rd32(pm, dom->addr + 0x070);
+	dom->clk = nvkm_rd32(device, dom->addr + 0x070);
 }
 
 static void
 gf100_perfctr_next(struct nvkm_pm *pm, struct nvkm_perfdom *dom)
 {
-	nv_wr32(pm, dom->addr + 0x06c, dom->signal_nr - 0x40 + 0x27);
-	nv_wr32(pm, dom->addr + 0x0ec, 0x00000011);
+	struct nvkm_device *device = pm->engine.subdev.device;
+	nvkm_wr32(device, dom->addr + 0x06c, dom->signal_nr - 0x40 + 0x27);
+	nvkm_wr32(device, dom->addr + 0x0ec, 0x00000011);
 }
 
 const struct nvkm_funcdom
@@ -175,8 +178,9 @@ int
 gf100_pm_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nvkm_pm *pm = (void *)object;
-	nv_mask(pm, 0x000200, 0x10000000, 0x00000000);
-	nv_mask(pm, 0x000200, 0x10000000, 0x10000000);
+	struct nvkm_device *device = pm->engine.subdev.device;
+	nvkm_mask(device, 0x000200, 0x10000000, 0x00000000);
+	nvkm_mask(device, 0x000200, 0x10000000, 0x10000000);
 	return nvkm_pm_fini(pm, suspend);
 }
 
@@ -186,6 +190,7 @@ gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	      struct nvkm_object **pobject)
 {
 	struct gf100_pm_oclass *mclass = (void *)oclass;
+	struct nvkm_device *device = (void *)parent;
 	struct nvkm_pm *pm;
 	u32 mask;
 	int ret;
@@ -202,9 +207,9 @@ gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		return ret;
 
 	/* GPC */
-	mask  = (1 << nv_rd32(pm, 0x022430)) - 1;
-	mask &= ~nv_rd32(pm, 0x022504);
-	mask &= ~nv_rd32(pm, 0x022584);
+	mask  = (1 << nvkm_rd32(device, 0x022430)) - 1;
+	mask &= ~nvkm_rd32(device, 0x022504);
+	mask &= ~nvkm_rd32(device, 0x022584);
 
 	ret = nvkm_perfdom_new(pm, "gpc", mask, 0x180000,
 			       0x1000, 0x200, mclass->doms_gpc);
@@ -212,9 +217,9 @@ gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		return ret;
 
 	/* PART */
-	mask  = (1 << nv_rd32(pm, 0x022438)) - 1;
-	mask &= ~nv_rd32(pm, 0x022548);
-	mask &= ~nv_rd32(pm, 0x0225c8);
+	mask  = (1 << nvkm_rd32(device, 0x022438)) - 1;
+	mask &= ~nvkm_rd32(device, 0x022548);
+	mask &= ~nvkm_rd32(device, 0x0225c8);
 
 	ret = nvkm_perfdom_new(pm, "part", mask, 0x1a0000,
 			       0x1000, 0x200, mclass->doms_part);

commit 8c1aeaa13954585e8482866457abacb5c094db35
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:08 2015 +1000

    drm/nouveau/pm: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
index 887d2dfeaa3c..cb3f52d2f24b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
@@ -125,10 +125,9 @@ gf100_pm_part[] = {
 };
 
 static void
-gf100_perfctr_init(struct nvkm_pm *ppm, struct nvkm_perfdom *dom,
+gf100_perfctr_init(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 		   struct nvkm_perfctr *ctr)
 {
-	struct gf100_pm_priv *priv = (void *)ppm;
 	struct gf100_pm_cntr *cntr = (void *)ctr;
 	u32 log = ctr->logic_op;
 	u32 src = 0x00000000;
@@ -137,34 +136,32 @@ gf100_perfctr_init(struct nvkm_pm *ppm, struct nvkm_perfdom *dom,
 	for (i = 0; i < 4; i++)
 		src |= ctr->signal[i] << (i * 8);
 
-	nv_wr32(priv, dom->addr + 0x09c, 0x00040002 | (dom->mode << 3));
-	nv_wr32(priv, dom->addr + 0x100, 0x00000000);
-	nv_wr32(priv, dom->addr + 0x040 + (cntr->base.slot * 0x08), src);
-	nv_wr32(priv, dom->addr + 0x044 + (cntr->base.slot * 0x08), log);
+	nv_wr32(pm, dom->addr + 0x09c, 0x00040002 | (dom->mode << 3));
+	nv_wr32(pm, dom->addr + 0x100, 0x00000000);
+	nv_wr32(pm, dom->addr + 0x040 + (cntr->base.slot * 0x08), src);
+	nv_wr32(pm, dom->addr + 0x044 + (cntr->base.slot * 0x08), log);
 }
 
 static void
-gf100_perfctr_read(struct nvkm_pm *ppm, struct nvkm_perfdom *dom,
+gf100_perfctr_read(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 		   struct nvkm_perfctr *ctr)
 {
-	struct gf100_pm_priv *priv = (void *)ppm;
 	struct gf100_pm_cntr *cntr = (void *)ctr;
 
 	switch (cntr->base.slot) {
-	case 0: cntr->base.ctr = nv_rd32(priv, dom->addr + 0x08c); break;
-	case 1: cntr->base.ctr = nv_rd32(priv, dom->addr + 0x088); break;
-	case 2: cntr->base.ctr = nv_rd32(priv, dom->addr + 0x080); break;
-	case 3: cntr->base.ctr = nv_rd32(priv, dom->addr + 0x090); break;
+	case 0: cntr->base.ctr = nv_rd32(pm, dom->addr + 0x08c); break;
+	case 1: cntr->base.ctr = nv_rd32(pm, dom->addr + 0x088); break;
+	case 2: cntr->base.ctr = nv_rd32(pm, dom->addr + 0x080); break;
+	case 3: cntr->base.ctr = nv_rd32(pm, dom->addr + 0x090); break;
 	}
-	dom->clk = nv_rd32(priv, dom->addr + 0x070);
+	dom->clk = nv_rd32(pm, dom->addr + 0x070);
 }
 
 static void
-gf100_perfctr_next(struct nvkm_pm *ppm, struct nvkm_perfdom *dom)
+gf100_perfctr_next(struct nvkm_pm *pm, struct nvkm_perfdom *dom)
 {
-	struct gf100_pm_priv *priv = (void *)ppm;
-	nv_wr32(priv, dom->addr + 0x06c, dom->signal_nr - 0x40 + 0x27);
-	nv_wr32(priv, dom->addr + 0x0ec, 0x00000011);
+	nv_wr32(pm, dom->addr + 0x06c, dom->signal_nr - 0x40 + 0x27);
+	nv_wr32(pm, dom->addr + 0x0ec, 0x00000011);
 }
 
 const struct nvkm_funcdom
@@ -177,10 +174,10 @@ gf100_perfctr_func = {
 int
 gf100_pm_fini(struct nvkm_object *object, bool suspend)
 {
-	struct gf100_pm_priv *priv = (void *)object;
-	nv_mask(priv, 0x000200, 0x10000000, 0x00000000);
-	nv_mask(priv, 0x000200, 0x10000000, 0x10000000);
-	return nvkm_pm_fini(&priv->base, suspend);
+	struct nvkm_pm *pm = (void *)object;
+	nv_mask(pm, 0x000200, 0x10000000, 0x00000000);
+	nv_mask(pm, 0x000200, 0x10000000, 0x10000000);
+	return nvkm_pm_fini(pm, suspend);
 }
 
 int
@@ -189,43 +186,43 @@ gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	      struct nvkm_object **pobject)
 {
 	struct gf100_pm_oclass *mclass = (void *)oclass;
-	struct gf100_pm_priv *priv;
+	struct nvkm_pm *pm;
 	u32 mask;
 	int ret;
 
-	ret = nvkm_pm_create(parent, engine, oclass, &priv);
-	*pobject = nv_object(priv);
+	ret = nvkm_pm_create(parent, engine, oclass, &pm);
+	*pobject = nv_object(pm);
 	if (ret)
 		return ret;
 
 	/* HUB */
-	ret = nvkm_perfdom_new(&priv->base, "hub", 0, 0x1b0000, 0, 0x200,
+	ret = nvkm_perfdom_new(pm, "hub", 0, 0x1b0000, 0, 0x200,
 			       mclass->doms_hub);
 	if (ret)
 		return ret;
 
 	/* GPC */
-	mask  = (1 << nv_rd32(priv, 0x022430)) - 1;
-	mask &= ~nv_rd32(priv, 0x022504);
-	mask &= ~nv_rd32(priv, 0x022584);
+	mask  = (1 << nv_rd32(pm, 0x022430)) - 1;
+	mask &= ~nv_rd32(pm, 0x022504);
+	mask &= ~nv_rd32(pm, 0x022584);
 
-	ret = nvkm_perfdom_new(&priv->base, "gpc", mask, 0x180000,
+	ret = nvkm_perfdom_new(pm, "gpc", mask, 0x180000,
 			       0x1000, 0x200, mclass->doms_gpc);
 	if (ret)
 		return ret;
 
 	/* PART */
-	mask  = (1 << nv_rd32(priv, 0x022438)) - 1;
-	mask &= ~nv_rd32(priv, 0x022548);
-	mask &= ~nv_rd32(priv, 0x0225c8);
+	mask  = (1 << nv_rd32(pm, 0x022438)) - 1;
+	mask &= ~nv_rd32(pm, 0x022548);
+	mask &= ~nv_rd32(pm, 0x0225c8);
 
-	ret = nvkm_perfdom_new(&priv->base, "part", mask, 0x1a0000,
+	ret = nvkm_perfdom_new(pm, "part", mask, 0x1a0000,
 			       0x1000, 0x200, mclass->doms_part);
 	if (ret)
 		return ret;
 
-	nv_engine(priv)->cclass = &nvkm_pm_cclass;
-	nv_engine(priv)->sclass =  nvkm_pm_sclass;
+	nv_engine(pm)->cclass = &nvkm_pm_cclass;
+	nv_engine(pm)->sclass =  nvkm_pm_sclass;
 	return 0;
 }
 

commit 2df0bf57f89cfa6e6adafb44d666ecc4a228a731
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Tue Aug 4 23:58:15 2015 +0200

    drm/nouveau/pm/gf100: only use PBFB_BROADCAST.PM_UNK100 for PBFB signals
    
    High level hardware events related to PBFB will monitor all partitions.
    While we are at it, fix bitfield for this mux.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
index ab463898b437..887d2dfeaa3c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
@@ -23,6 +23,16 @@
  */
 #include "gf100.h"
 
+const struct nvkm_specsrc
+gf100_pbfb_sources[] = {
+	{ 0x10f100, (const struct nvkm_specmux[]) {
+			{ 0x1, 0, "unk0" },
+			{ 0x3f, 4, "unk4" },
+			{}
+		}, "pbfb_broadcast_pm_unk100" },
+	{}
+};
+
 const struct nvkm_specsrc
 gf100_pmfb_sources[] = {
 	{ 0x140028, (const struct nvkm_specmux[]) {
@@ -44,17 +54,6 @@ gf100_l1_sources[] = {
 	{}
 };
 
-static const struct nvkm_specsrc
-gf100_pbfb_sources[] = {
-	{ 0x10f100, (const struct nvkm_specmux[]) {
-			{ 0x1, 0, "unk0" },
-			{ 0xf, 4, "unk4" },
-			{ 0x3, 8, "unk8" },
-			{}
-		}, "pbfb_broadcast_pm_unk100" },
-	{}
-};
-
 static const struct nvkm_specsrc
 gf100_tex_sources[] = {
 	{ 0x5042c0, (const struct nvkm_specmux[]) {

commit 8feece04db884e04c31c008b76a7610849757720
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Tue Aug 4 23:58:14 2015 +0200

    drm/nouveau/pm/gf100: remove multiple definitions of GPC_DOM signal 0x0e
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
index 37b1636d0f29..ab463898b437 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
@@ -93,11 +93,10 @@ gf100_pm_gpc[] = {
 			{ 0x0c, "gpc00_tex_02", gf100_tex_sources },
 			{ 0x0d, "gpc00_tex_03", gf100_tex_sources },
 			{ 0x0e, "gpc00_tex_04", gf100_tex_sources },
-			{ 0x0e, "gpc00_tex_05", gf100_tex_sources },
-			{ 0x0f, "gpc00_tex_06", gf100_tex_sources },
-			{ 0x10, "gpc00_tex_07", gf100_tex_sources },
-			{ 0x11, "gpc00_tex_08", gf100_tex_sources },
-			{ 0x12, "gpc00_tex_09", gf100_tex_sources },
+			{ 0x0f, "gpc00_tex_05", gf100_tex_sources },
+			{ 0x10, "gpc00_tex_06", gf100_tex_sources },
+			{ 0x11, "gpc00_tex_07", gf100_tex_sources },
+			{ 0x12, "gpc00_tex_08", gf100_tex_sources },
 			{ 0x26, "gpc00_unk400_00", gf100_unk400_sources },
 			{}
 		}, &gf100_perfctr_func },

commit 9b4dc66d4772a432f271e1ebafd70aafe2b9bb27
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Tue Aug 4 23:58:13 2015 +0200

    drm/nouveau/pm/gf100: remove undefined TEX.PM_UNKC8 mux
    
    This mux only exists on GF108+ (except for GF110 one), but since it is
    not used by the userspace we can drop it for now.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
index b40c2188d003..37b1636d0f29 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
@@ -62,10 +62,6 @@ gf100_tex_sources[] = {
 			{ 0x7, 8, "sel1", true },
 			{}
 		}, "pgraph_gpc0_tpc0_tex_pm_mux_c_d" },
-	{ 0x5042c8, (const struct nvkm_specmux[]) {
-			{ 0x1f, 0, "sel", true },
-			{}
-		}, "pgraph_gpc0_tpc0_tex_pm_unkc8" },
 	{}
 };
 

commit 94a2ef69aa0c3612577ab1a6f5c248b206118e68
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 14 13:33:55 2015 +0200

    drm/nouveau/pm/gf100: add compute signals/sources
    
    These signals and sources have been reverse engineered from CUPTI
    (Linux). Graphics signals exposed by PerfKit (Windows only) will be
    added later. I need to reverse engineer them and it's a bit painful.
    
    This commit also adds a new class for GF108 and GF117.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
index 64db47e3742b..b40c2188d003 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
@@ -23,18 +23,110 @@
  */
 #include "gf100.h"
 
+const struct nvkm_specsrc
+gf100_pmfb_sources[] = {
+	{ 0x140028, (const struct nvkm_specmux[]) {
+			{ 0x3fff, 0, "unk0" },
+			{ 0x7, 16, "unk16" },
+			{ 0x3, 24, "unk24" },
+			{ 0x2, 29, "unk29" },
+			{}
+		}, "pmfb0_pm_unk28" },
+	{}
+};
+
+static const struct nvkm_specsrc
+gf100_l1_sources[] = {
+	{ 0x5044a8, (const struct nvkm_specmux[]) {
+			{ 0x3f, 0, "sel", true },
+			{}
+		}, "pgraph_gpc0_tpc0_l1_pm_mux" },
+	{}
+};
+
+static const struct nvkm_specsrc
+gf100_pbfb_sources[] = {
+	{ 0x10f100, (const struct nvkm_specmux[]) {
+			{ 0x1, 0, "unk0" },
+			{ 0xf, 4, "unk4" },
+			{ 0x3, 8, "unk8" },
+			{}
+		}, "pbfb_broadcast_pm_unk100" },
+	{}
+};
+
+static const struct nvkm_specsrc
+gf100_tex_sources[] = {
+	{ 0x5042c0, (const struct nvkm_specmux[]) {
+			{ 0xf, 0, "sel0", true },
+			{ 0x7, 8, "sel1", true },
+			{}
+		}, "pgraph_gpc0_tpc0_tex_pm_mux_c_d" },
+	{ 0x5042c8, (const struct nvkm_specmux[]) {
+			{ 0x1f, 0, "sel", true },
+			{}
+		}, "pgraph_gpc0_tpc0_tex_pm_unkc8" },
+	{}
+};
+
+static const struct nvkm_specsrc
+gf100_unk400_sources[] = {
+	{ 0x50440c, (const struct nvkm_specmux[]) {
+			{ 0x3f, 0, "sel", true },
+			{}
+		}, "pgraph_gpc0_tpc0_unk400_pm_mux" },
+	{}
+};
+
 static const struct nvkm_specdom
 gf100_pm_hub[] = {
 	{}
 };
 
-static const struct nvkm_specdom
+const struct nvkm_specdom
 gf100_pm_gpc[] = {
+	{ 0xe0, (const struct nvkm_specsig[]) {
+			{ 0x00, "gpc00_l1_00", gf100_l1_sources },
+			{ 0x01, "gpc00_l1_01", gf100_l1_sources },
+			{ 0x02, "gpc00_l1_02", gf100_l1_sources },
+			{ 0x03, "gpc00_l1_03", gf100_l1_sources },
+			{ 0x05, "gpc00_l1_04", gf100_l1_sources },
+			{ 0x06, "gpc00_l1_05", gf100_l1_sources },
+			{ 0x0a, "gpc00_tex_00", gf100_tex_sources },
+			{ 0x0b, "gpc00_tex_01", gf100_tex_sources },
+			{ 0x0c, "gpc00_tex_02", gf100_tex_sources },
+			{ 0x0d, "gpc00_tex_03", gf100_tex_sources },
+			{ 0x0e, "gpc00_tex_04", gf100_tex_sources },
+			{ 0x0e, "gpc00_tex_05", gf100_tex_sources },
+			{ 0x0f, "gpc00_tex_06", gf100_tex_sources },
+			{ 0x10, "gpc00_tex_07", gf100_tex_sources },
+			{ 0x11, "gpc00_tex_08", gf100_tex_sources },
+			{ 0x12, "gpc00_tex_09", gf100_tex_sources },
+			{ 0x26, "gpc00_unk400_00", gf100_unk400_sources },
+			{}
+		}, &gf100_perfctr_func },
 	{}
 };
 
-static const struct nvkm_specdom
+const struct nvkm_specdom
 gf100_pm_part[] = {
+	{ 0xe0, (const struct nvkm_specsig[]) {
+			{ 0x0f, "part00_pbfb_00", gf100_pbfb_sources },
+			{ 0x10, "part00_pbfb_01", gf100_pbfb_sources },
+			{ 0x21, "part00_pmfb_00", gf100_pmfb_sources },
+			{ 0x04, "part00_pmfb_01", gf100_pmfb_sources },
+			{ 0x00, "part00_pmfb_02", gf100_pmfb_sources },
+			{ 0x02, "part00_pmfb_03", gf100_pmfb_sources },
+			{ 0x01, "part00_pmfb_04", gf100_pmfb_sources },
+			{ 0x2e, "part00_pmfb_05", gf100_pmfb_sources },
+			{ 0x2f, "part00_pmfb_06", gf100_pmfb_sources },
+			{ 0x1b, "part00_pmfb_07", gf100_pmfb_sources },
+			{ 0x1c, "part00_pmfb_08", gf100_pmfb_sources },
+			{ 0x1d, "part00_pmfb_09", gf100_pmfb_sources },
+			{ 0x1e, "part00_pmfb_0a", gf100_pmfb_sources },
+			{ 0x1f, "part00_pmfb_0b", gf100_pmfb_sources },
+			{}
+		}, &gf100_perfctr_func },
 	{}
 };
 

commit 060f50e3b100b8f51fbf165de48c2ea097ff7390
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 14 13:33:54 2015 +0200

    drm/nouveau/pm/gf100: allow to share GPC, HUB and PART domains
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
index edab97aa918e..64db47e3742b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
@@ -97,11 +97,12 @@ gf100_pm_fini(struct nvkm_object *object, bool suspend)
 	return nvkm_pm_fini(&priv->base, suspend);
 }
 
-static int
+int
 gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	      struct nvkm_oclass *oclass, void *data, u32 size,
 	      struct nvkm_object **pobject)
 {
+	struct gf100_pm_oclass *mclass = (void *)oclass;
 	struct gf100_pm_priv *priv;
 	u32 mask;
 	int ret;
@@ -113,7 +114,7 @@ gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	/* HUB */
 	ret = nvkm_perfdom_new(&priv->base, "hub", 0, 0x1b0000, 0, 0x200,
-			       gf100_pm_hub);
+			       mclass->doms_hub);
 	if (ret)
 		return ret;
 
@@ -123,7 +124,7 @@ gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	mask &= ~nv_rd32(priv, 0x022584);
 
 	ret = nvkm_perfdom_new(&priv->base, "gpc", mask, 0x180000,
-			       0x1000, 0x200, gf100_pm_gpc);
+			       0x1000, 0x200, mclass->doms_gpc);
 	if (ret)
 		return ret;
 
@@ -133,7 +134,7 @@ gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	mask &= ~nv_rd32(priv, 0x0225c8);
 
 	ret = nvkm_perfdom_new(&priv->base, "part", mask, 0x1a0000,
-			       0x1000, 0x200, gf100_pm_part);
+			       0x1000, 0x200, mclass->doms_part);
 	if (ret)
 		return ret;
 
@@ -142,13 +143,16 @@ gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	return 0;
 }
 
-struct nvkm_oclass
-gf100_pm_oclass = {
-	.handle = NV_ENGINE(PM, 0xc0),
-	.ofuncs = &(struct nvkm_ofuncs) {
+struct nvkm_oclass *
+gf100_pm_oclass = &(struct gf100_pm_oclass) {
+	.base.handle = NV_ENGINE(PM, 0xc0),
+	.base.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = gf100_pm_ctor,
 		.dtor = _nvkm_pm_dtor,
 		.init = _nvkm_pm_init,
 		.fini = gf100_pm_fini,
 	},
-};
+	.doms_gpc  = gf100_pm_gpc,
+	.doms_hub  = gf100_pm_hub,
+	.doms_part = gf100_pm_part,
+}.base;

commit 0f3804360dd4f88332b9c0b2d7cb4c1f30893cc7
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:26 2015 +0200

    drm/nouveau/pm: allow to configure domains instead of simple counters
    
    Configuring counters from the userspace require the kernel to handle some
    logic related to performance counters. Basically, it has to find a free
    slot to assign a counter, to handle extra counting modes like B4/B6 and it
    must return and error when it can't configure a counter.
    
    In my opinion, the kernel should not handle all of that logic but it
    should only write the configuration sent by the userspace without
    checking anything. In other words, it should overwrite the configuration
    even if it's already counting and do not return any errors.
    
    This patch allows the userspace to configure a domain instead of
    separate counters. This has the advantage to move all of the logic to
    the userspace.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
index 41350d6199a5..edab97aa918e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
@@ -48,12 +48,10 @@ gf100_perfctr_init(struct nvkm_pm *ppm, struct nvkm_perfdom *dom,
 	u32 src = 0x00000000;
 	int i;
 
-	for (i = 0; i < 4; i++) {
-		if (ctr->signal[i])
-			src |= (ctr->signal[i] - dom->signal) << (i * 8);
-	}
+	for (i = 0; i < 4; i++)
+		src |= ctr->signal[i] << (i * 8);
 
-	nv_wr32(priv, dom->addr + 0x09c, 0x00040002);
+	nv_wr32(priv, dom->addr + 0x09c, 0x00040002 | (dom->mode << 3));
 	nv_wr32(priv, dom->addr + 0x100, 0x00000000);
 	nv_wr32(priv, dom->addr + 0x040 + (cntr->base.slot * 0x08), src);
 	nv_wr32(priv, dom->addr + 0x044 + (cntr->base.slot * 0x08), log);
@@ -72,7 +70,7 @@ gf100_perfctr_read(struct nvkm_pm *ppm, struct nvkm_perfdom *dom,
 	case 2: cntr->base.ctr = nv_rd32(priv, dom->addr + 0x080); break;
 	case 3: cntr->base.ctr = nv_rd32(priv, dom->addr + 0x090); break;
 	}
-	cntr->base.clk = nv_rd32(priv, dom->addr + 0x070);
+	dom->clk = nv_rd32(priv, dom->addr + 0x070);
 }
 
 static void

commit 40a3b22c92ac3dad5adc818a84671bfb00303731
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:21 2015 +0200

    drm/nouveau/pm: allow to monitor hardware signal index 0x00
    
    This signal index must be always allowed even if it's not clearly
    defined in a domain in order to monitor a counter like 0x03020100
    because it's the default value of signals.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
index 69303b5dbcbc..41350d6199a5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
@@ -48,8 +48,10 @@ gf100_perfctr_init(struct nvkm_pm *ppm, struct nvkm_perfdom *dom,
 	u32 src = 0x00000000;
 	int i;
 
-	for (i = 0; i < 4 && ctr->signal[i]; i++)
-		src |= (ctr->signal[i] - dom->signal) << (i * 8);
+	for (i = 0; i < 4; i++) {
+		if (ctr->signal[i])
+			src |= (ctr->signal[i] - dom->signal) << (i * 8);
+	}
 
 	nv_wr32(priv, dom->addr + 0x09c, 0x00040002);
 	nv_wr32(priv, dom->addr + 0x100, 0x00000000);

commit 0b7515c035d26faee91b6c3023622385c109b99e
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:13 2015 +0200

    drm/nouveau/pm: remove pmu signals
    
    PDAEMON signals don't have to be exposed by the perfmon engine.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
index 008fed73dd82..69303b5dbcbc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
@@ -111,10 +111,6 @@ gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	ret = nvkm_perfdom_new(&priv->base, "pwr", 0, 0, 0, 0, gf100_pm_pwr);
-	if (ret)
-		return ret;
-
 	/* HUB */
 	ret = nvkm_perfdom_new(&priv->base, "hub", 0, 0x1b0000, 0, 0x200,
 			       gf100_pm_hub);
@@ -143,7 +139,6 @@ gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	nv_engine(priv)->cclass = &nvkm_pm_cclass;
 	nv_engine(priv)->sclass =  nvkm_pm_sclass;
-	priv->base.last = 7;
 	return 0;
 }
 

commit 4d34686eb607037dafffb9d66d9e50b4648cfda4
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:31:13 2015 +1000

    drm/nouveau/pm: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
new file mode 100644
index 000000000000..008fed73dd82
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
@@ -0,0 +1,159 @@
+/*
+ * Copyright 2013 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+#include "gf100.h"
+
+static const struct nvkm_specdom
+gf100_pm_hub[] = {
+	{}
+};
+
+static const struct nvkm_specdom
+gf100_pm_gpc[] = {
+	{}
+};
+
+static const struct nvkm_specdom
+gf100_pm_part[] = {
+	{}
+};
+
+static void
+gf100_perfctr_init(struct nvkm_pm *ppm, struct nvkm_perfdom *dom,
+		   struct nvkm_perfctr *ctr)
+{
+	struct gf100_pm_priv *priv = (void *)ppm;
+	struct gf100_pm_cntr *cntr = (void *)ctr;
+	u32 log = ctr->logic_op;
+	u32 src = 0x00000000;
+	int i;
+
+	for (i = 0; i < 4 && ctr->signal[i]; i++)
+		src |= (ctr->signal[i] - dom->signal) << (i * 8);
+
+	nv_wr32(priv, dom->addr + 0x09c, 0x00040002);
+	nv_wr32(priv, dom->addr + 0x100, 0x00000000);
+	nv_wr32(priv, dom->addr + 0x040 + (cntr->base.slot * 0x08), src);
+	nv_wr32(priv, dom->addr + 0x044 + (cntr->base.slot * 0x08), log);
+}
+
+static void
+gf100_perfctr_read(struct nvkm_pm *ppm, struct nvkm_perfdom *dom,
+		   struct nvkm_perfctr *ctr)
+{
+	struct gf100_pm_priv *priv = (void *)ppm;
+	struct gf100_pm_cntr *cntr = (void *)ctr;
+
+	switch (cntr->base.slot) {
+	case 0: cntr->base.ctr = nv_rd32(priv, dom->addr + 0x08c); break;
+	case 1: cntr->base.ctr = nv_rd32(priv, dom->addr + 0x088); break;
+	case 2: cntr->base.ctr = nv_rd32(priv, dom->addr + 0x080); break;
+	case 3: cntr->base.ctr = nv_rd32(priv, dom->addr + 0x090); break;
+	}
+	cntr->base.clk = nv_rd32(priv, dom->addr + 0x070);
+}
+
+static void
+gf100_perfctr_next(struct nvkm_pm *ppm, struct nvkm_perfdom *dom)
+{
+	struct gf100_pm_priv *priv = (void *)ppm;
+	nv_wr32(priv, dom->addr + 0x06c, dom->signal_nr - 0x40 + 0x27);
+	nv_wr32(priv, dom->addr + 0x0ec, 0x00000011);
+}
+
+const struct nvkm_funcdom
+gf100_perfctr_func = {
+	.init = gf100_perfctr_init,
+	.read = gf100_perfctr_read,
+	.next = gf100_perfctr_next,
+};
+
+int
+gf100_pm_fini(struct nvkm_object *object, bool suspend)
+{
+	struct gf100_pm_priv *priv = (void *)object;
+	nv_mask(priv, 0x000200, 0x10000000, 0x00000000);
+	nv_mask(priv, 0x000200, 0x10000000, 0x10000000);
+	return nvkm_pm_fini(&priv->base, suspend);
+}
+
+static int
+gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+	      struct nvkm_oclass *oclass, void *data, u32 size,
+	      struct nvkm_object **pobject)
+{
+	struct gf100_pm_priv *priv;
+	u32 mask;
+	int ret;
+
+	ret = nvkm_pm_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	ret = nvkm_perfdom_new(&priv->base, "pwr", 0, 0, 0, 0, gf100_pm_pwr);
+	if (ret)
+		return ret;
+
+	/* HUB */
+	ret = nvkm_perfdom_new(&priv->base, "hub", 0, 0x1b0000, 0, 0x200,
+			       gf100_pm_hub);
+	if (ret)
+		return ret;
+
+	/* GPC */
+	mask  = (1 << nv_rd32(priv, 0x022430)) - 1;
+	mask &= ~nv_rd32(priv, 0x022504);
+	mask &= ~nv_rd32(priv, 0x022584);
+
+	ret = nvkm_perfdom_new(&priv->base, "gpc", mask, 0x180000,
+			       0x1000, 0x200, gf100_pm_gpc);
+	if (ret)
+		return ret;
+
+	/* PART */
+	mask  = (1 << nv_rd32(priv, 0x022438)) - 1;
+	mask &= ~nv_rd32(priv, 0x022548);
+	mask &= ~nv_rd32(priv, 0x0225c8);
+
+	ret = nvkm_perfdom_new(&priv->base, "part", mask, 0x1a0000,
+			       0x1000, 0x200, gf100_pm_part);
+	if (ret)
+		return ret;
+
+	nv_engine(priv)->cclass = &nvkm_pm_cclass;
+	nv_engine(priv)->sclass =  nvkm_pm_sclass;
+	priv->base.last = 7;
+	return 0;
+}
+
+struct nvkm_oclass
+gf100_pm_oclass = {
+	.handle = NV_ENGINE(PM, 0xc0),
+	.ofuncs = &(struct nvkm_ofuncs) {
+		.ctor = gf100_pm_ctor,
+		.dtor = _nvkm_pm_dtor,
+		.init = _nvkm_pm_init,
+		.fini = gf100_pm_fini,
+	},
+};
