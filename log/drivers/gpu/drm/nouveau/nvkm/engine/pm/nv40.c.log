commit 86d65b7e7a0c927d07d18605c276d0f142438ead
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Mar 14 15:24:10 2016 +0100

    nouveau: fix nv40_perfctr_next() cleanup regression
    
    gcc-6 warns about code in the nouveau driver that is obviously silly:
    
    drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c: In function 'nv40_perfctr_next':
    drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c:62:19: warning: self-comparison always evaluats to false [-Wtautological-compare]
      if (pm->sequence != pm->sequence) {
    
    The behavior was accidentally introduced in a patch described as "This is
    purely preparation for upcoming commits, there should be no code changes here.".
    As far as I can tell, that was true for the rest of that patch except for
    this one function, which has been changed to a NOP.
    
    This patch restores the original behavior.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: 8c1aeaa13954 ("drm/nouveau/pm: cosmetic changes")
    Reviewed-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
index 4bef72a9d106..3fda594700e0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
@@ -59,9 +59,11 @@ static void
 nv40_perfctr_next(struct nvkm_pm *pm, struct nvkm_perfdom *dom)
 {
 	struct nvkm_device *device = pm->engine.subdev.device;
-	if (pm->sequence != pm->sequence) {
+	struct nv40_pm *nv40pm = container_of(pm, struct nv40_pm, base);
+
+	if (nv40pm->sequence != pm->sequence) {
 		nvkm_wr32(device, 0x400084, 0x00000020);
-		pm->sequence = pm->sequence;
+		nv40pm->sequence = pm->sequence;
 	}
 }
 

commit 97070f23c60869830039b216ff88230f54ef7107
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/pm: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
index a4660dc14259..4bef72a9d106 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
@@ -28,7 +28,6 @@ nv40_perfctr_init(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 		  struct nvkm_perfctr *ctr)
 {
 	struct nvkm_device *device = pm->engine.subdev.device;
-	struct nv40_pm_cntr *cntr = (void *)ctr;
 	u32 log = ctr->logic_op;
 	u32 src = 0x00000000;
 	int i;
@@ -37,8 +36,8 @@ nv40_perfctr_init(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 		src |= ctr->signal[i] << (i * 8);
 
 	nvkm_wr32(device, 0x00a7c0 + dom->addr, 0x00000001 | (dom->mode << 4));
-	nvkm_wr32(device, 0x00a400 + dom->addr + (cntr->base.slot * 0x40), src);
-	nvkm_wr32(device, 0x00a420 + dom->addr + (cntr->base.slot * 0x40), log);
+	nvkm_wr32(device, 0x00a400 + dom->addr + (ctr->slot * 0x40), src);
+	nvkm_wr32(device, 0x00a420 + dom->addr + (ctr->slot * 0x40), log);
 }
 
 static void
@@ -46,13 +45,12 @@ nv40_perfctr_read(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 		  struct nvkm_perfctr *ctr)
 {
 	struct nvkm_device *device = pm->engine.subdev.device;
-	struct nv40_pm_cntr *cntr = (void *)ctr;
 
-	switch (cntr->base.slot) {
-	case 0: cntr->base.ctr = nvkm_rd32(device, 0x00a700 + dom->addr); break;
-	case 1: cntr->base.ctr = nvkm_rd32(device, 0x00a6c0 + dom->addr); break;
-	case 2: cntr->base.ctr = nvkm_rd32(device, 0x00a680 + dom->addr); break;
-	case 3: cntr->base.ctr = nvkm_rd32(device, 0x00a740 + dom->addr); break;
+	switch (ctr->slot) {
+	case 0: ctr->ctr = nvkm_rd32(device, 0x00a700 + dom->addr); break;
+	case 1: ctr->ctr = nvkm_rd32(device, 0x00a6c0 + dom->addr); break;
+	case 2: ctr->ctr = nvkm_rd32(device, 0x00a680 + dom->addr); break;
+	case 3: ctr->ctr = nvkm_rd32(device, 0x00a740 + dom->addr); break;
 	}
 	dom->clk = nvkm_rd32(device, 0x00a600 + dom->addr);
 }
@@ -74,6 +72,28 @@ nv40_perfctr_func = {
 	.next = nv40_perfctr_next,
 };
 
+static const struct nvkm_pm_func
+nv40_pm_ = {
+};
+
+int
+nv40_pm_new_(const struct nvkm_specdom *doms, struct nvkm_device *device,
+	     int index, struct nvkm_pm **ppm)
+{
+	struct nv40_pm *pm;
+	int ret;
+
+	if (!(pm = kzalloc(sizeof(*pm), GFP_KERNEL)))
+		return -ENOMEM;
+	*ppm = &pm->base;
+
+	ret = nvkm_pm_ctor(&nv40_pm_, device, index, &pm->base);
+	if (ret)
+		return ret;
+
+	return nvkm_perfdom_new(&pm->base, "pc", 0, 0, 0, 4, doms);
+}
+
 static const struct nvkm_specdom
 nv40_pm[] = {
 	{ 0x20, (const struct nvkm_specsig[]) {
@@ -95,34 +115,7 @@ nv40_pm[] = {
 };
 
 int
-nv40_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-	     struct nvkm_oclass *oclass, void *data, u32 size,
-	     struct nvkm_object **pobject)
+nv40_pm_new(struct nvkm_device *device, int index, struct nvkm_pm **ppm)
 {
-	struct nv40_pm_oclass *mclass = (void *)oclass;
-	struct nv40_pm *pm;
-	int ret;
-
-	ret = nvkm_pm_create(parent, engine, oclass, &pm);
-	*pobject = nv_object(pm);
-	if (ret)
-		return ret;
-
-	ret = nvkm_perfdom_new(&pm->base, "pc", 0, 0, 0, 4, mclass->doms);
-	if (ret)
-		return ret;
-
-	return 0;
+	return nv40_pm_new_(nv40_pm, device, index, ppm);
 }
-
-struct nvkm_oclass *
-nv40_pm_oclass = &(struct nv40_pm_oclass) {
-	.base.handle = NV_ENGINE(PM, 0x40),
-	.base.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nv40_pm_ctor,
-		.dtor = _nvkm_pm_dtor,
-		.init = _nvkm_pm_init,
-		.fini = _nvkm_pm_fini,
-	},
-	.doms = nv40_pm,
-}.base;

commit 5ffeb84b8eba71b4f88af6997db843ddf68149e0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/pm: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
index b37c024f0783..a4660dc14259 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
@@ -112,8 +112,6 @@ nv40_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	nv_engine(pm)->cclass = &nvkm_pm_cclass;
-	nv_engine(pm)->sclass =  nvkm_pm_sclass;
 	return 0;
 }
 

commit 846e831d953fd01cb78b9ed92495baee142bed37
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:10 2015 +1000

    drm/nouveau/pm: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
index a447eac24f3b..b37c024f0783 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
@@ -27,6 +27,7 @@ static void
 nv40_perfctr_init(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 		  struct nvkm_perfctr *ctr)
 {
+	struct nvkm_device *device = pm->engine.subdev.device;
 	struct nv40_pm_cntr *cntr = (void *)ctr;
 	u32 log = ctr->logic_op;
 	u32 src = 0x00000000;
@@ -35,31 +36,33 @@ nv40_perfctr_init(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 	for (i = 0; i < 4; i++)
 		src |= ctr->signal[i] << (i * 8);
 
-	nv_wr32(pm, 0x00a7c0 + dom->addr, 0x00000001 | (dom->mode << 4));
-	nv_wr32(pm, 0x00a400 + dom->addr + (cntr->base.slot * 0x40), src);
-	nv_wr32(pm, 0x00a420 + dom->addr + (cntr->base.slot * 0x40), log);
+	nvkm_wr32(device, 0x00a7c0 + dom->addr, 0x00000001 | (dom->mode << 4));
+	nvkm_wr32(device, 0x00a400 + dom->addr + (cntr->base.slot * 0x40), src);
+	nvkm_wr32(device, 0x00a420 + dom->addr + (cntr->base.slot * 0x40), log);
 }
 
 static void
 nv40_perfctr_read(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 		  struct nvkm_perfctr *ctr)
 {
+	struct nvkm_device *device = pm->engine.subdev.device;
 	struct nv40_pm_cntr *cntr = (void *)ctr;
 
 	switch (cntr->base.slot) {
-	case 0: cntr->base.ctr = nv_rd32(pm, 0x00a700 + dom->addr); break;
-	case 1: cntr->base.ctr = nv_rd32(pm, 0x00a6c0 + dom->addr); break;
-	case 2: cntr->base.ctr = nv_rd32(pm, 0x00a680 + dom->addr); break;
-	case 3: cntr->base.ctr = nv_rd32(pm, 0x00a740 + dom->addr); break;
+	case 0: cntr->base.ctr = nvkm_rd32(device, 0x00a700 + dom->addr); break;
+	case 1: cntr->base.ctr = nvkm_rd32(device, 0x00a6c0 + dom->addr); break;
+	case 2: cntr->base.ctr = nvkm_rd32(device, 0x00a680 + dom->addr); break;
+	case 3: cntr->base.ctr = nvkm_rd32(device, 0x00a740 + dom->addr); break;
 	}
-	dom->clk = nv_rd32(pm, 0x00a600 + dom->addr);
+	dom->clk = nvkm_rd32(device, 0x00a600 + dom->addr);
 }
 
 static void
 nv40_perfctr_next(struct nvkm_pm *pm, struct nvkm_perfdom *dom)
 {
+	struct nvkm_device *device = pm->engine.subdev.device;
 	if (pm->sequence != pm->sequence) {
-		nv_wr32(pm, 0x400084, 0x00000020);
+		nvkm_wr32(device, 0x400084, 0x00000020);
 		pm->sequence = pm->sequence;
 	}
 }

commit 8c1aeaa13954585e8482866457abacb5c094db35
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:08 2015 +1000

    drm/nouveau/pm: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
index 5a87f3a1b947..a447eac24f3b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
@@ -24,10 +24,9 @@
 #include "nv40.h"
 
 static void
-nv40_perfctr_init(struct nvkm_pm *ppm, struct nvkm_perfdom *dom,
+nv40_perfctr_init(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 		  struct nvkm_perfctr *ctr)
 {
-	struct nv40_pm_priv *priv = (void *)ppm;
 	struct nv40_pm_cntr *cntr = (void *)ctr;
 	u32 log = ctr->logic_op;
 	u32 src = 0x00000000;
@@ -36,34 +35,32 @@ nv40_perfctr_init(struct nvkm_pm *ppm, struct nvkm_perfdom *dom,
 	for (i = 0; i < 4; i++)
 		src |= ctr->signal[i] << (i * 8);
 
-	nv_wr32(priv, 0x00a7c0 + dom->addr, 0x00000001 | (dom->mode << 4));
-	nv_wr32(priv, 0x00a400 + dom->addr + (cntr->base.slot * 0x40), src);
-	nv_wr32(priv, 0x00a420 + dom->addr + (cntr->base.slot * 0x40), log);
+	nv_wr32(pm, 0x00a7c0 + dom->addr, 0x00000001 | (dom->mode << 4));
+	nv_wr32(pm, 0x00a400 + dom->addr + (cntr->base.slot * 0x40), src);
+	nv_wr32(pm, 0x00a420 + dom->addr + (cntr->base.slot * 0x40), log);
 }
 
 static void
-nv40_perfctr_read(struct nvkm_pm *ppm, struct nvkm_perfdom *dom,
+nv40_perfctr_read(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 		  struct nvkm_perfctr *ctr)
 {
-	struct nv40_pm_priv *priv = (void *)ppm;
 	struct nv40_pm_cntr *cntr = (void *)ctr;
 
 	switch (cntr->base.slot) {
-	case 0: cntr->base.ctr = nv_rd32(priv, 0x00a700 + dom->addr); break;
-	case 1: cntr->base.ctr = nv_rd32(priv, 0x00a6c0 + dom->addr); break;
-	case 2: cntr->base.ctr = nv_rd32(priv, 0x00a680 + dom->addr); break;
-	case 3: cntr->base.ctr = nv_rd32(priv, 0x00a740 + dom->addr); break;
+	case 0: cntr->base.ctr = nv_rd32(pm, 0x00a700 + dom->addr); break;
+	case 1: cntr->base.ctr = nv_rd32(pm, 0x00a6c0 + dom->addr); break;
+	case 2: cntr->base.ctr = nv_rd32(pm, 0x00a680 + dom->addr); break;
+	case 3: cntr->base.ctr = nv_rd32(pm, 0x00a740 + dom->addr); break;
 	}
-	dom->clk = nv_rd32(priv, 0x00a600 + dom->addr);
+	dom->clk = nv_rd32(pm, 0x00a600 + dom->addr);
 }
 
 static void
-nv40_perfctr_next(struct nvkm_pm *ppm, struct nvkm_perfdom *dom)
+nv40_perfctr_next(struct nvkm_pm *pm, struct nvkm_perfdom *dom)
 {
-	struct nv40_pm_priv *priv = (void *)ppm;
-	if (priv->sequence != ppm->sequence) {
-		nv_wr32(priv, 0x400084, 0x00000020);
-		priv->sequence = ppm->sequence;
+	if (pm->sequence != pm->sequence) {
+		nv_wr32(pm, 0x400084, 0x00000020);
+		pm->sequence = pm->sequence;
 	}
 }
 
@@ -100,20 +97,20 @@ nv40_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	     struct nvkm_object **pobject)
 {
 	struct nv40_pm_oclass *mclass = (void *)oclass;
-	struct nv40_pm_priv *priv;
+	struct nv40_pm *pm;
 	int ret;
 
-	ret = nvkm_pm_create(parent, engine, oclass, &priv);
-	*pobject = nv_object(priv);
+	ret = nvkm_pm_create(parent, engine, oclass, &pm);
+	*pobject = nv_object(pm);
 	if (ret)
 		return ret;
 
-	ret = nvkm_perfdom_new(&priv->base, "pc", 0, 0, 0, 4, mclass->doms);
+	ret = nvkm_perfdom_new(&pm->base, "pc", 0, 0, 0, 4, mclass->doms);
 	if (ret)
 		return ret;
 
-	nv_engine(priv)->cclass = &nvkm_pm_cclass;
-	nv_engine(priv)->sclass =  nvkm_pm_sclass;
+	nv_engine(pm)->cclass = &nvkm_pm_cclass;
+	nv_engine(pm)->sclass =  nvkm_pm_sclass;
 	return 0;
 }
 

commit 261d678d10d9ba866e279e0da0415267f1e6e561
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Fri Jun 19 17:36:38 2015 +0200

    drm/nouveau/pm/nv40: rename pcounter domains to 'pc' instead of 'pm'
    
    This trivial patch makes thing more consistent since hardware signals
    names are prefixed by 'pcXX'.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
index 1c6d1ca4799e..5a87f3a1b947 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
@@ -108,7 +108,7 @@ nv40_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	ret = nvkm_perfdom_new(&priv->base, "pm", 0, 0, 0, 4, mclass->doms);
+	ret = nvkm_perfdom_new(&priv->base, "pc", 0, 0, 0, 4, mclass->doms);
 	if (ret)
 		return ret;
 

commit 0f3804360dd4f88332b9c0b2d7cb4c1f30893cc7
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:26 2015 +0200

    drm/nouveau/pm: allow to configure domains instead of simple counters
    
    Configuring counters from the userspace require the kernel to handle some
    logic related to performance counters. Basically, it has to find a free
    slot to assign a counter, to handle extra counting modes like B4/B6 and it
    must return and error when it can't configure a counter.
    
    In my opinion, the kernel should not handle all of that logic but it
    should only write the configuration sent by the userspace without
    checking anything. In other words, it should overwrite the configuration
    even if it's already counting and do not return any errors.
    
    This patch allows the userspace to configure a domain instead of
    separate counters. This has the advantage to move all of the logic to
    the userspace.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
index 603874ec0fba..1c6d1ca4799e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
@@ -33,12 +33,10 @@ nv40_perfctr_init(struct nvkm_pm *ppm, struct nvkm_perfdom *dom,
 	u32 src = 0x00000000;
 	int i;
 
-	for (i = 0; i < 4; i++) {
-		if (ctr->signal[i])
-			src |= (ctr->signal[i] - dom->signal) << (i * 8);
-	}
+	for (i = 0; i < 4; i++)
+		src |= ctr->signal[i] << (i * 8);
 
-	nv_wr32(priv, 0x00a7c0 + dom->addr, 0x00000001);
+	nv_wr32(priv, 0x00a7c0 + dom->addr, 0x00000001 | (dom->mode << 4));
 	nv_wr32(priv, 0x00a400 + dom->addr + (cntr->base.slot * 0x40), src);
 	nv_wr32(priv, 0x00a420 + dom->addr + (cntr->base.slot * 0x40), log);
 }
@@ -56,7 +54,7 @@ nv40_perfctr_read(struct nvkm_pm *ppm, struct nvkm_perfdom *dom,
 	case 2: cntr->base.ctr = nv_rd32(priv, 0x00a680 + dom->addr); break;
 	case 3: cntr->base.ctr = nv_rd32(priv, 0x00a740 + dom->addr); break;
 	}
-	cntr->base.clk = nv_rd32(priv, 0x00a600 + dom->addr);
+	dom->clk = nv_rd32(priv, 0x00a600 + dom->addr);
 }
 
 static void

commit 40a3b22c92ac3dad5adc818a84671bfb00303731
Author: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date:   Sun Jun 7 22:40:21 2015 +0200

    drm/nouveau/pm: allow to monitor hardware signal index 0x00
    
    This signal index must be always allowed even if it's not clearly
    defined in a domain in order to monitor a counter like 0x03020100
    because it's the default value of signals.
    
    Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
index ff22f06b22b8..603874ec0fba 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
@@ -33,8 +33,10 @@ nv40_perfctr_init(struct nvkm_pm *ppm, struct nvkm_perfdom *dom,
 	u32 src = 0x00000000;
 	int i;
 
-	for (i = 0; i < 4 && ctr->signal[i]; i++)
-		src |= (ctr->signal[i] - dom->signal) << (i * 8);
+	for (i = 0; i < 4; i++) {
+		if (ctr->signal[i])
+			src |= (ctr->signal[i] - dom->signal) << (i * 8);
+	}
 
 	nv_wr32(priv, 0x00a7c0 + dom->addr, 0x00000001);
 	nv_wr32(priv, 0x00a400 + dom->addr + (cntr->base.slot * 0x40), src);

commit 4d34686eb607037dafffb9d66d9e50b4648cfda4
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:31:13 2015 +1000

    drm/nouveau/pm: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
index 82a1777a3e11..ff22f06b22b8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
@@ -21,24 +21,11 @@
  *
  * Authors: Ben Skeggs
  */
-
 #include "nv40.h"
 
-/*******************************************************************************
- * Perfmon object classes
- ******************************************************************************/
-
-/*******************************************************************************
- * PPM context
- ******************************************************************************/
-
-/*******************************************************************************
- * PPM engine/subdev functions
- ******************************************************************************/
-
 static void
-nv40_perfctr_init(struct nouveau_pm *ppm, struct nouveau_perfdom *dom,
-		  struct nouveau_perfctr *ctr)
+nv40_perfctr_init(struct nvkm_pm *ppm, struct nvkm_perfdom *dom,
+		  struct nvkm_perfctr *ctr)
 {
 	struct nv40_pm_priv *priv = (void *)ppm;
 	struct nv40_pm_cntr *cntr = (void *)ctr;
@@ -55,8 +42,8 @@ nv40_perfctr_init(struct nouveau_pm *ppm, struct nouveau_perfdom *dom,
 }
 
 static void
-nv40_perfctr_read(struct nouveau_pm *ppm, struct nouveau_perfdom *dom,
-		  struct nouveau_perfctr *ctr)
+nv40_perfctr_read(struct nvkm_pm *ppm, struct nvkm_perfdom *dom,
+		  struct nvkm_perfctr *ctr)
 {
 	struct nv40_pm_priv *priv = (void *)ppm;
 	struct nv40_pm_cntr *cntr = (void *)ctr;
@@ -71,7 +58,7 @@ nv40_perfctr_read(struct nouveau_pm *ppm, struct nouveau_perfdom *dom,
 }
 
 static void
-nv40_perfctr_next(struct nouveau_pm *ppm, struct nouveau_perfdom *dom)
+nv40_perfctr_next(struct nvkm_pm *ppm, struct nvkm_perfdom *dom)
 {
 	struct nv40_pm_priv *priv = (void *)ppm;
 	if (priv->sequence != ppm->sequence) {
@@ -80,64 +67,64 @@ nv40_perfctr_next(struct nouveau_pm *ppm, struct nouveau_perfdom *dom)
 	}
 }
 
-const struct nouveau_funcdom
+const struct nvkm_funcdom
 nv40_perfctr_func = {
 	.init = nv40_perfctr_init,
 	.read = nv40_perfctr_read,
 	.next = nv40_perfctr_next,
 };
 
-static const struct nouveau_specdom
+static const struct nvkm_specdom
 nv40_pm[] = {
-	{ 0x20, (const struct nouveau_specsig[]) {
+	{ 0x20, (const struct nvkm_specsig[]) {
 			{}
 		}, &nv40_perfctr_func },
-	{ 0x20, (const struct nouveau_specsig[]) {
+	{ 0x20, (const struct nvkm_specsig[]) {
 			{}
 		}, &nv40_perfctr_func },
-	{ 0x20, (const struct nouveau_specsig[]) {
+	{ 0x20, (const struct nvkm_specsig[]) {
 			{}
 		}, &nv40_perfctr_func },
-	{ 0x20, (const struct nouveau_specsig[]) {
+	{ 0x20, (const struct nvkm_specsig[]) {
 			{}
 		}, &nv40_perfctr_func },
-	{ 0x20, (const struct nouveau_specsig[]) {
+	{ 0x20, (const struct nvkm_specsig[]) {
 			{}
 		}, &nv40_perfctr_func },
 	{}
 };
 
 int
-nv40_pm_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
-		  struct nouveau_oclass *oclass, void *data, u32 size,
-		  struct nouveau_object **pobject)
+nv40_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+	     struct nvkm_oclass *oclass, void *data, u32 size,
+	     struct nvkm_object **pobject)
 {
 	struct nv40_pm_oclass *mclass = (void *)oclass;
 	struct nv40_pm_priv *priv;
 	int ret;
 
-	ret = nouveau_pm_create(parent, engine, oclass, &priv);
+	ret = nvkm_pm_create(parent, engine, oclass, &priv);
 	*pobject = nv_object(priv);
 	if (ret)
 		return ret;
 
-	ret = nouveau_perfdom_new(&priv->base, "pm", 0, 0, 0, 4, mclass->doms);
+	ret = nvkm_perfdom_new(&priv->base, "pm", 0, 0, 0, 4, mclass->doms);
 	if (ret)
 		return ret;
 
-	nv_engine(priv)->cclass = &nouveau_pm_cclass;
-	nv_engine(priv)->sclass =  nouveau_pm_sclass;
+	nv_engine(priv)->cclass = &nvkm_pm_cclass;
+	nv_engine(priv)->sclass =  nvkm_pm_sclass;
 	return 0;
 }
 
-struct nouveau_oclass *
+struct nvkm_oclass *
 nv40_pm_oclass = &(struct nv40_pm_oclass) {
 	.base.handle = NV_ENGINE(PM, 0x40),
-	.base.ofuncs = &(struct nouveau_ofuncs) {
+	.base.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv40_pm_ctor,
-		.dtor = _nouveau_pm_dtor,
-		.init = _nouveau_pm_init,
-		.fini = _nouveau_pm_fini,
+		.dtor = _nvkm_pm_dtor,
+		.init = _nvkm_pm_init,
+		.fini = _nvkm_pm_fini,
 	},
 	.doms = nv40_pm,
 }.base;

commit d5752b9b86fbfb8febd9d45ac4431325031e25e0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 12:11:28 2015 +1000

    drm/nouveau/pm: rename from perfmon (no binary change)
    
    Switch to NVIDIA's name for the device.
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
new file mode 100644
index 000000000000..82a1777a3e11
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
@@ -0,0 +1,143 @@
+/*
+ * Copyright 2013 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include "nv40.h"
+
+/*******************************************************************************
+ * Perfmon object classes
+ ******************************************************************************/
+
+/*******************************************************************************
+ * PPM context
+ ******************************************************************************/
+
+/*******************************************************************************
+ * PPM engine/subdev functions
+ ******************************************************************************/
+
+static void
+nv40_perfctr_init(struct nouveau_pm *ppm, struct nouveau_perfdom *dom,
+		  struct nouveau_perfctr *ctr)
+{
+	struct nv40_pm_priv *priv = (void *)ppm;
+	struct nv40_pm_cntr *cntr = (void *)ctr;
+	u32 log = ctr->logic_op;
+	u32 src = 0x00000000;
+	int i;
+
+	for (i = 0; i < 4 && ctr->signal[i]; i++)
+		src |= (ctr->signal[i] - dom->signal) << (i * 8);
+
+	nv_wr32(priv, 0x00a7c0 + dom->addr, 0x00000001);
+	nv_wr32(priv, 0x00a400 + dom->addr + (cntr->base.slot * 0x40), src);
+	nv_wr32(priv, 0x00a420 + dom->addr + (cntr->base.slot * 0x40), log);
+}
+
+static void
+nv40_perfctr_read(struct nouveau_pm *ppm, struct nouveau_perfdom *dom,
+		  struct nouveau_perfctr *ctr)
+{
+	struct nv40_pm_priv *priv = (void *)ppm;
+	struct nv40_pm_cntr *cntr = (void *)ctr;
+
+	switch (cntr->base.slot) {
+	case 0: cntr->base.ctr = nv_rd32(priv, 0x00a700 + dom->addr); break;
+	case 1: cntr->base.ctr = nv_rd32(priv, 0x00a6c0 + dom->addr); break;
+	case 2: cntr->base.ctr = nv_rd32(priv, 0x00a680 + dom->addr); break;
+	case 3: cntr->base.ctr = nv_rd32(priv, 0x00a740 + dom->addr); break;
+	}
+	cntr->base.clk = nv_rd32(priv, 0x00a600 + dom->addr);
+}
+
+static void
+nv40_perfctr_next(struct nouveau_pm *ppm, struct nouveau_perfdom *dom)
+{
+	struct nv40_pm_priv *priv = (void *)ppm;
+	if (priv->sequence != ppm->sequence) {
+		nv_wr32(priv, 0x400084, 0x00000020);
+		priv->sequence = ppm->sequence;
+	}
+}
+
+const struct nouveau_funcdom
+nv40_perfctr_func = {
+	.init = nv40_perfctr_init,
+	.read = nv40_perfctr_read,
+	.next = nv40_perfctr_next,
+};
+
+static const struct nouveau_specdom
+nv40_pm[] = {
+	{ 0x20, (const struct nouveau_specsig[]) {
+			{}
+		}, &nv40_perfctr_func },
+	{ 0x20, (const struct nouveau_specsig[]) {
+			{}
+		}, &nv40_perfctr_func },
+	{ 0x20, (const struct nouveau_specsig[]) {
+			{}
+		}, &nv40_perfctr_func },
+	{ 0x20, (const struct nouveau_specsig[]) {
+			{}
+		}, &nv40_perfctr_func },
+	{ 0x20, (const struct nouveau_specsig[]) {
+			{}
+		}, &nv40_perfctr_func },
+	{}
+};
+
+int
+nv40_pm_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+		  struct nouveau_oclass *oclass, void *data, u32 size,
+		  struct nouveau_object **pobject)
+{
+	struct nv40_pm_oclass *mclass = (void *)oclass;
+	struct nv40_pm_priv *priv;
+	int ret;
+
+	ret = nouveau_pm_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	ret = nouveau_perfdom_new(&priv->base, "pm", 0, 0, 0, 4, mclass->doms);
+	if (ret)
+		return ret;
+
+	nv_engine(priv)->cclass = &nouveau_pm_cclass;
+	nv_engine(priv)->sclass =  nouveau_pm_sclass;
+	return 0;
+}
+
+struct nouveau_oclass *
+nv40_pm_oclass = &(struct nv40_pm_oclass) {
+	.base.handle = NV_ENGINE(PM, 0x40),
+	.base.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv40_pm_ctor,
+		.dtor = _nouveau_pm_dtor,
+		.init = _nouveau_pm_init,
+		.fini = _nouveau_pm_fini,
+	},
+	.doms = nv40_pm,
+}.base;
