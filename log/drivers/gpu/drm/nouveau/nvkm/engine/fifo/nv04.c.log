commit 322b38ce3dd6458b92ee25acee68c973281dbbde
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Wed Oct 17 16:28:51 2018 +0200

    drm/nouveau/nvkm: mark expected switch fall-throughs
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    This patch aims to suppress 29 missing-break-in-switch false positives.
    
    Addresses-Coverity-ID: 1456891 ("Missing break in switch")
    Addresses-Coverity-ID: 1324063 ("Missing break in switch")
    Addresses-Coverity-ID: 1324063 ("Missing break in switch")
    Addresses-Coverity-ID: 141432 ("Missing break in switch")
    Addresses-Coverity-ID: 141433 ("Missing break in switch")
    Addresses-Coverity-ID: 141434 ("Missing break in switch")
    Addresses-Coverity-ID: 141435 ("Missing break in switch")
    Addresses-Coverity-ID: 141436 ("Missing break in switch")
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index ad707ff176cc..93493b335d76 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -117,8 +117,10 @@ nv04_fifo_swmthd(struct nvkm_device *device, u32 chid, u32 addr, u32 data)
 	switch (mthd) {
 	case 0x0000 ... 0x0000: /* subchannel's engine -> software */
 		nvkm_wr32(device, 0x003280, (engine &= ~mask));
+		/* fall through */
 	case 0x0180 ... 0x01fc: /* handle -> instance */
 		data = nvkm_rd32(device, 0x003258) & 0x0000ffff;
+		/* fall through */
 	case 0x0100 ... 0x017c:
 	case 0x0200 ... 0x1ffc: /* pass method down to sw */
 		if (!(engine & mask) && sw)

commit fbd58ebda9c8572ca6285b88e3348c7712f125ec
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/object: merge with handle
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index e6f04e87139a..ad707ff176cc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -26,7 +26,6 @@
 #include "regsnv04.h"
 
 #include <core/client.h>
-#include <core/handle.h>
 #include <core/ramht.h>
 #include <subdev/instmem.h>
 #include <subdev/timer.h>

commit 13de7f462902d1a452d501cdb2d06ef02cabbfff
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/fifo: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index d1ad3fa72c34..e6f04e87139a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -32,8 +32,8 @@
 #include <subdev/timer.h>
 #include <engine/sw.h>
 
-static struct ramfc_desc
-nv04_ramfc[] = {
+static const struct nv04_fifo_ramfc
+nv04_fifo_ramfc[] = {
 	{ 32,  0, 0x00,  0, NV04_PFIFO_CACHE1_DMA_PUT },
 	{ 32,  0, 0x04,  0, NV04_PFIFO_CACHE1_DMA_GET },
 	{ 16,  0, 0x08,  0, NV04_PFIFO_CACHE1_DMA_INSTANCE },
@@ -46,10 +46,10 @@ nv04_ramfc[] = {
 };
 
 void
-nv04_fifo_pause(struct nvkm_fifo *obj, unsigned long *pflags)
+nv04_fifo_pause(struct nvkm_fifo *base, unsigned long *pflags)
 __acquires(fifo->base.lock)
 {
-	struct nv04_fifo *fifo = container_of(obj, typeof(*fifo), base);
+	struct nv04_fifo *fifo = nv04_fifo(base);
 	struct nvkm_device *device = fifo->base.engine.subdev.device;
 	unsigned long flags;
 
@@ -82,10 +82,10 @@ __acquires(fifo->base.lock)
 }
 
 void
-nv04_fifo_start(struct nvkm_fifo *obj, unsigned long *pflags)
+nv04_fifo_start(struct nvkm_fifo *base, unsigned long *pflags)
 __releases(fifo->base.lock)
 {
-	struct nv04_fifo *fifo = container_of(obj, typeof(*fifo), base);
+	struct nv04_fifo *fifo = nv04_fifo(base);
 	struct nvkm_device *device = fifo->base.engine.subdev.device;
 	unsigned long flags = *pflags;
 
@@ -236,10 +236,11 @@ nv04_fifo_dma_pusher(struct nv04_fifo *fifo, u32 chid)
 }
 
 void
-nv04_fifo_intr(struct nvkm_subdev *subdev)
+nv04_fifo_intr(struct nvkm_fifo *base)
 {
+	struct nv04_fifo *fifo = nv04_fifo(base);
+	struct nvkm_subdev *subdev = &fifo->base.engine.subdev;
 	struct nvkm_device *device = subdev->device;
-	struct nv04_fifo *fifo = (void *)subdev;
 	u32 mask = nvkm_rd32(device, NV03_PFIFO_INTR_EN_0);
 	u32 stat = nvkm_rd32(device, NV03_PFIFO_INTR_0) & mask;
 	u32 reassign, chid, get, sem;
@@ -293,20 +294,15 @@ nv04_fifo_intr(struct nvkm_subdev *subdev)
 	nvkm_wr32(device, NV03_PFIFO_CACHES, reassign);
 }
 
-int
-nv04_fifo_init(struct nvkm_object *object)
+void
+nv04_fifo_init(struct nvkm_fifo *base)
 {
-	struct nv04_fifo *fifo = (void *)object;
+	struct nv04_fifo *fifo = nv04_fifo(base);
 	struct nvkm_device *device = fifo->base.engine.subdev.device;
 	struct nvkm_instmem *imem = device->imem;
 	struct nvkm_ramht *ramht = imem->ramht;
 	struct nvkm_memory *ramro = imem->ramro;
 	struct nvkm_memory *ramfc = imem->ramfc;
-	int ret;
-
-	ret = nvkm_fifo_init(&fifo->base);
-	if (ret)
-		return ret;
 
 	nvkm_wr32(device, NV04_PFIFO_DELAY_0, 0x000000ff);
 	nvkm_wr32(device, NV04_PFIFO_DMA_TIMESLICE, 0x0101ffff);
@@ -325,54 +321,44 @@ nv04_fifo_init(struct nvkm_object *object)
 	nvkm_wr32(device, NV03_PFIFO_CACHE1_PUSH0, 1);
 	nvkm_wr32(device, NV04_PFIFO_CACHE1_PULL0, 1);
 	nvkm_wr32(device, NV03_PFIFO_CACHES, 1);
-	return 0;
 }
 
-void
-nv04_fifo_dtor(struct nvkm_object *object)
-{
-	struct nv04_fifo *fifo = (void *)object;
-	nvkm_fifo_destroy(&fifo->base);
-}
-
-static const struct nvkm_fifo_func
-nv04_fifo_func = {
-	.chan = {
-		&nv04_fifo_dma_oclass,
-		NULL
-	},
-};
-
-static int
-nv04_fifo_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-	       struct nvkm_oclass *oclass, void *data, u32 size,
-	       struct nvkm_object **pobject)
+int
+nv04_fifo_new_(const struct nvkm_fifo_func *func, struct nvkm_device *device,
+	       int index, int nr, const struct nv04_fifo_ramfc *ramfc,
+	       struct nvkm_fifo **pfifo)
 {
 	struct nv04_fifo *fifo;
 	int ret;
 
-	ret = nvkm_fifo_create(parent, engine, oclass, 0, 15, &fifo);
-	*pobject = nv_object(fifo);
+	if (!(fifo = kzalloc(sizeof(*fifo), GFP_KERNEL)))
+		return -ENOMEM;
+	fifo->ramfc = ramfc;
+	*pfifo = &fifo->base;
+
+	ret = nvkm_fifo_ctor(func, device, index, nr, &fifo->base);
 	if (ret)
 		return ret;
 
-	fifo->base.func = &nv04_fifo_func;
-
-	nv_subdev(fifo)->unit = 0x00000100;
-	nv_subdev(fifo)->intr = nv04_fifo_intr;
-	fifo->base.pause = nv04_fifo_pause;
-	fifo->base.start = nv04_fifo_start;
-	fifo->ramfc_desc = nv04_ramfc;
+	set_bit(nr - 1, fifo->base.mask); /* inactive channel */
 	return 0;
 }
 
-struct nvkm_oclass *
-nv04_fifo_oclass = &(struct nvkm_oclass) {
-	.handle = NV_ENGINE(FIFO, 0x04),
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nv04_fifo_ctor,
-		.dtor = nv04_fifo_dtor,
-		.init = nv04_fifo_init,
-		.fini = _nvkm_fifo_fini,
+static const struct nvkm_fifo_func
+nv04_fifo = {
+	.init = nv04_fifo_init,
+	.intr = nv04_fifo_intr,
+	.pause = nv04_fifo_pause,
+	.start = nv04_fifo_start,
+	.chan = {
+		&nv04_fifo_dma_oclass,
+		NULL
 	},
 };
+
+int
+nv04_fifo_new(struct nvkm_device *device, int index, struct nvkm_fifo **pfifo)
+{
+	return nv04_fifo_new_(&nv04_fifo, device, index, 16,
+			      nv04_fifo_ramfc, pfifo);
+}

commit 8f0649b5c6e70ec18122255690e39f010c12a614
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/fifo: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index d880cfa6de9e..d1ad3fa72c34 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -25,6 +25,7 @@
 #include "channv04.h"
 #include "regsnv04.h"
 
+#include <core/client.h>
 #include <core/handle.h>
 #include <core/ramht.h>
 #include <subdev/instmem.h>
@@ -136,6 +137,8 @@ nv04_fifo_cache_error(struct nv04_fifo *fifo, u32 chid, u32 get)
 {
 	struct nvkm_subdev *subdev = &fifo->base.engine.subdev;
 	struct nvkm_device *device = subdev->device;
+	struct nvkm_fifo_chan *chan;
+	unsigned long flags;
 	u32 pull0 = nvkm_rd32(device, 0x003250);
 	u32 mthd, data;
 	int ptr;
@@ -157,12 +160,12 @@ nv04_fifo_cache_error(struct nv04_fifo *fifo, u32 chid, u32 get)
 
 	if (!(pull0 & 0x00000100) ||
 	    !nv04_fifo_swmthd(device, chid, mthd, data)) {
-		const char *client_name =
-			nvkm_client_name_for_fifo_chid(&fifo->base, chid);
+		chan = nvkm_fifo_chan_chid(&fifo->base, chid, &flags);
 		nvkm_error(subdev, "CACHE_ERROR - "
 			   "ch %d [%s] subc %d mthd %04x data %08x\n",
-			   chid, client_name, (mthd >> 13) & 7, mthd & 0x1ffc,
-			   data);
+			   chid, chan ? chan->object.client->name : "unknown",
+			   (mthd >> 13) & 7, mthd & 0x1ffc, data);
+		nvkm_fifo_chan_put(&fifo->base, flags, &chan);
 	}
 
 	nvkm_wr32(device, NV04_PFIFO_CACHE1_DMA_PUSH, 0);
@@ -189,10 +192,12 @@ nv04_fifo_dma_pusher(struct nv04_fifo *fifo, u32 chid)
 	u32 dma_put = nvkm_rd32(device, 0x003240);
 	u32 push = nvkm_rd32(device, 0x003220);
 	u32 state = nvkm_rd32(device, 0x003228);
-	const char *client_name;
-
-	client_name = nvkm_client_name_for_fifo_chid(&fifo->base, chid);
+	struct nvkm_fifo_chan *chan;
+	unsigned long flags;
+	const char *name;
 
+	chan = nvkm_fifo_chan_chid(&fifo->base, chid, &flags);
+	name = chan ? chan->object.client->name : "unknown";
 	if (device->card_type == NV_50) {
 		u32 ho_get = nvkm_rd32(device, 0x003328);
 		u32 ho_put = nvkm_rd32(device, 0x003320);
@@ -202,7 +207,7 @@ nv04_fifo_dma_pusher(struct nv04_fifo *fifo, u32 chid)
 		nvkm_error(subdev, "DMA_PUSHER - "
 			   "ch %d [%s] get %02x%08x put %02x%08x ib_get %08x "
 			   "ib_put %08x state %08x (err: %s) push %08x\n",
-			   chid, client_name, ho_get, dma_get, ho_put, dma_put,
+			   chid, name, ho_get, dma_get, ho_put, dma_put,
 			   ib_get, ib_put, state, nv_dma_state_err(state),
 			   push);
 
@@ -217,12 +222,13 @@ nv04_fifo_dma_pusher(struct nv04_fifo *fifo, u32 chid)
 	} else {
 		nvkm_error(subdev, "DMA_PUSHER - ch %d [%s] get %08x put %08x "
 				   "state %08x (err: %s) push %08x\n",
-			   chid, client_name, dma_get, dma_put, state,
+			   chid, name, dma_get, dma_put, state,
 			   nv_dma_state_err(state), push);
 
 		if (dma_get != dma_put)
 			nvkm_wr32(device, 0x003244, dma_put);
 	}
+	nvkm_fifo_chan_put(&fifo->base, flags, &chan);
 
 	nvkm_wr32(device, 0x003228, 0x00000000);
 	nvkm_wr32(device, 0x003220, 0x00000001);
@@ -241,7 +247,7 @@ nv04_fifo_intr(struct nvkm_subdev *subdev)
 	reassign = nvkm_rd32(device, NV03_PFIFO_CACHES) & 1;
 	nvkm_wr32(device, NV03_PFIFO_CACHES, 0);
 
-	chid = nvkm_rd32(device, NV03_PFIFO_CACHE1_PUSH1) & fifo->base.max;
+	chid = nvkm_rd32(device, NV03_PFIFO_CACHE1_PUSH1) & (fifo->base.nr - 1);
 	get  = nvkm_rd32(device, NV03_PFIFO_CACHE1_GET);
 
 	if (stat & NV_PFIFO_INTR_CACHE_ERROR) {
@@ -311,7 +317,7 @@ nv04_fifo_init(struct nvkm_object *object)
 	nvkm_wr32(device, NV03_PFIFO_RAMRO, nvkm_memory_addr(ramro) >> 8);
 	nvkm_wr32(device, NV03_PFIFO_RAMFC, nvkm_memory_addr(ramfc) >> 8);
 
-	nvkm_wr32(device, NV03_PFIFO_CACHE1_PUSH1, fifo->base.max);
+	nvkm_wr32(device, NV03_PFIFO_CACHE1_PUSH1, fifo->base.nr - 1);
 
 	nvkm_wr32(device, NV03_PFIFO_INTR_0, 0xffffffff);
 	nvkm_wr32(device, NV03_PFIFO_INTR_EN_0, 0xffffffff);
@@ -329,6 +335,14 @@ nv04_fifo_dtor(struct nvkm_object *object)
 	nvkm_fifo_destroy(&fifo->base);
 }
 
+static const struct nvkm_fifo_func
+nv04_fifo_func = {
+	.chan = {
+		&nv04_fifo_dma_oclass,
+		NULL
+	},
+};
+
 static int
 nv04_fifo_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_oclass *oclass, void *data, u32 size,
@@ -342,10 +356,10 @@ nv04_fifo_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
+	fifo->base.func = &nv04_fifo_func;
+
 	nv_subdev(fifo)->unit = 0x00000100;
 	nv_subdev(fifo)->intr = nv04_fifo_intr;
-	nv_engine(fifo)->cclass = &nv04_fifo_cclass;
-	nv_engine(fifo)->sclass = nv04_fifo_sclass;
 	fifo->base.pause = nv04_fifo_pause;
 	fifo->base.start = nv04_fifo_start;
 	fifo->ramfc_desc = nv04_ramfc;

commit 9a65a38c456ebac97f0498e85fe26f6d26fe3936
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/fifo: split user classes out from engine implementations
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index 8bdb71f5f1c5..d880cfa6de9e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -22,18 +22,15 @@
  * Authors: Ben Skeggs
  */
 #include "nv04.h"
+#include "channv04.h"
+#include "regsnv04.h"
 
-#include <core/client.h>
-#include <core/engctx.h>
 #include <core/handle.h>
 #include <core/ramht.h>
 #include <subdev/instmem.h>
 #include <subdev/timer.h>
 #include <engine/sw.h>
 
-#include <nvif/class.h>
-#include <nvif/unpack.h>
-
 static struct ramfc_desc
 nv04_ramfc[] = {
 	{ 32,  0, 0x00,  0, NV04_PFIFO_CACHE1_DMA_PUT },
@@ -47,268 +44,6 @@ nv04_ramfc[] = {
 	{}
 };
 
-/*******************************************************************************
- * FIFO channel objects
- ******************************************************************************/
-
-int
-nv04_fifo_object_attach(struct nvkm_object *parent,
-			struct nvkm_object *object, u32 handle)
-{
-	struct nv04_fifo *fifo = (void *)parent->engine;
-	struct nv04_fifo_chan *chan = (void *)parent;
-	struct nvkm_instmem *imem = fifo->base.engine.subdev.device->imem;
-	u32 context, chid = chan->base.chid;
-	int ret;
-
-	if (nv_iclass(object, NV_GPUOBJ_CLASS))
-		context = nv_gpuobj(object)->addr >> 4;
-	else
-		context = 0x00000004; /* just non-zero */
-
-	if (object->engine) {
-		switch (nv_engidx(object->engine)) {
-		case NVDEV_ENGINE_DMAOBJ:
-		case NVDEV_ENGINE_SW:
-			context |= 0x00000000;
-			break;
-		case NVDEV_ENGINE_GR:
-			context |= 0x00010000;
-			break;
-		case NVDEV_ENGINE_MPEG:
-			context |= 0x00020000;
-			break;
-		default:
-			return -EINVAL;
-		}
-	}
-
-	context |= 0x80000000; /* valid */
-	context |= chid << 24;
-
-	mutex_lock(&nv_subdev(fifo)->mutex);
-	ret = nvkm_ramht_insert(imem->ramht, NULL, chid, 0, handle, context);
-	mutex_unlock(&nv_subdev(fifo)->mutex);
-	return ret;
-}
-
-void
-nv04_fifo_object_detach(struct nvkm_object *parent, int cookie)
-{
-	struct nv04_fifo *fifo = (void *)parent->engine;
-	struct nvkm_instmem *imem = fifo->base.engine.subdev.device->imem;
-	mutex_lock(&nv_subdev(fifo)->mutex);
-	nvkm_ramht_remove(imem->ramht, cookie);
-	mutex_unlock(&nv_subdev(fifo)->mutex);
-}
-
-int
-nv04_fifo_context_attach(struct nvkm_object *parent,
-			 struct nvkm_object *object)
-{
-	nv_engctx(object)->addr = nvkm_fifo_chan(parent)->chid;
-	return 0;
-}
-
-static int
-nv04_fifo_chan_ctor(struct nvkm_object *parent,
-		    struct nvkm_object *engine,
-		    struct nvkm_oclass *oclass, void *data, u32 size,
-		    struct nvkm_object **pobject)
-{
-	union {
-		struct nv03_channel_dma_v0 v0;
-	} *args = data;
-	struct nv04_fifo *fifo = (void *)engine;
-	struct nvkm_instmem *imem = fifo->base.engine.subdev.device->imem;
-	struct nv04_fifo_chan *chan;
-	int ret;
-
-	nvif_ioctl(parent, "create channel dma size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nvif_ioctl(parent, "create channel dma vers %d pushbuf %llx "
-				   "offset %08x\n", args->v0.version,
-			   args->v0.pushbuf, args->v0.offset);
-	} else
-		return ret;
-
-	ret = nvkm_fifo_channel_create(parent, engine, oclass, 0, 0x800000,
-				       0x10000, args->v0.pushbuf,
-				       (1ULL << NVDEV_ENGINE_DMAOBJ) |
-				       (1ULL << NVDEV_ENGINE_SW) |
-				       (1ULL << NVDEV_ENGINE_GR), &chan);
-	*pobject = nv_object(chan);
-	if (ret)
-		return ret;
-
-	args->v0.chid = chan->base.chid;
-
-	nv_parent(chan)->object_attach = nv04_fifo_object_attach;
-	nv_parent(chan)->object_detach = nv04_fifo_object_detach;
-	nv_parent(chan)->context_attach = nv04_fifo_context_attach;
-	chan->ramfc = chan->base.chid * 32;
-
-	nvkm_kmap(imem->ramfc);
-	nvkm_wo32(imem->ramfc, chan->ramfc + 0x00, args->v0.offset);
-	nvkm_wo32(imem->ramfc, chan->ramfc + 0x04, args->v0.offset);
-	nvkm_wo32(imem->ramfc, chan->ramfc + 0x08, chan->base.pushgpu->addr >> 4);
-	nvkm_wo32(imem->ramfc, chan->ramfc + 0x10,
-			     NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |
-			     NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |
-#ifdef __BIG_ENDIAN
-			     NV_PFIFO_CACHE1_BIG_ENDIAN |
-#endif
-			     NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8);
-	nvkm_done(imem->ramfc);
-	return 0;
-}
-
-void
-nv04_fifo_chan_dtor(struct nvkm_object *object)
-{
-	struct nv04_fifo *fifo = (void *)object->engine;
-	struct nv04_fifo_chan *chan = (void *)object;
-	struct nvkm_instmem *imem = fifo->base.engine.subdev.device->imem;
-	struct ramfc_desc *c = fifo->ramfc_desc;
-
-	nvkm_kmap(imem->ramfc);
-	do {
-		nvkm_wo32(imem->ramfc, chan->ramfc + c->ctxp, 0x00000000);
-	} while ((++c)->bits);
-	nvkm_done(imem->ramfc);
-
-	nvkm_fifo_channel_destroy(&chan->base);
-}
-
-int
-nv04_fifo_chan_init(struct nvkm_object *object)
-{
-	struct nv04_fifo *fifo = (void *)object->engine;
-	struct nv04_fifo_chan *chan = (void *)object;
-	struct nvkm_device *device = fifo->base.engine.subdev.device;
-	u32 mask = 1 << chan->base.chid;
-	unsigned long flags;
-	int ret;
-
-	ret = nvkm_fifo_channel_init(&chan->base);
-	if (ret)
-		return ret;
-
-	spin_lock_irqsave(&fifo->base.lock, flags);
-	nvkm_mask(device, NV04_PFIFO_MODE, mask, mask);
-	spin_unlock_irqrestore(&fifo->base.lock, flags);
-	return 0;
-}
-
-int
-nv04_fifo_chan_fini(struct nvkm_object *object, bool suspend)
-{
-	struct nv04_fifo *fifo = (void *)object->engine;
-	struct nv04_fifo_chan *chan = (void *)object;
-	struct nvkm_device *device = fifo->base.engine.subdev.device;
-	struct nvkm_memory *fctx = device->imem->ramfc;
-	struct ramfc_desc *c;
-	unsigned long flags;
-	u32 data = chan->ramfc;
-	u32 chid;
-
-	/* prevent fifo context switches */
-	spin_lock_irqsave(&fifo->base.lock, flags);
-	nvkm_wr32(device, NV03_PFIFO_CACHES, 0);
-
-	/* if this channel is active, replace it with a null context */
-	chid = nvkm_rd32(device, NV03_PFIFO_CACHE1_PUSH1) & fifo->base.max;
-	if (chid == chan->base.chid) {
-		nvkm_mask(device, NV04_PFIFO_CACHE1_DMA_PUSH, 0x00000001, 0);
-		nvkm_wr32(device, NV03_PFIFO_CACHE1_PUSH0, 0);
-		nvkm_mask(device, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0);
-
-		c = fifo->ramfc_desc;
-		do {
-			u32 rm = ((1ULL << c->bits) - 1) << c->regs;
-			u32 cm = ((1ULL << c->bits) - 1) << c->ctxs;
-			u32 rv = (nvkm_rd32(device, c->regp) &  rm) >> c->regs;
-			u32 cv = (nvkm_ro32(fctx, c->ctxp + data) & ~cm);
-			nvkm_wo32(fctx, c->ctxp + data, cv | (rv << c->ctxs));
-		} while ((++c)->bits);
-
-		c = fifo->ramfc_desc;
-		do {
-			nvkm_wr32(device, c->regp, 0x00000000);
-		} while ((++c)->bits);
-
-		nvkm_wr32(device, NV03_PFIFO_CACHE1_GET, 0);
-		nvkm_wr32(device, NV03_PFIFO_CACHE1_PUT, 0);
-		nvkm_wr32(device, NV03_PFIFO_CACHE1_PUSH1, fifo->base.max);
-		nvkm_wr32(device, NV03_PFIFO_CACHE1_PUSH0, 1);
-		nvkm_wr32(device, NV04_PFIFO_CACHE1_PULL0, 1);
-	}
-
-	/* restore normal operation, after disabling dma mode */
-	nvkm_mask(device, NV04_PFIFO_MODE, 1 << chan->base.chid, 0);
-	nvkm_wr32(device, NV03_PFIFO_CACHES, 1);
-	spin_unlock_irqrestore(&fifo->base.lock, flags);
-
-	return nvkm_fifo_channel_fini(&chan->base, suspend);
-}
-
-static struct nvkm_ofuncs
-nv04_fifo_ofuncs = {
-	.ctor = nv04_fifo_chan_ctor,
-	.dtor = nv04_fifo_chan_dtor,
-	.init = nv04_fifo_chan_init,
-	.fini = nv04_fifo_chan_fini,
-	.map  = _nvkm_fifo_channel_map,
-	.rd32 = _nvkm_fifo_channel_rd32,
-	.wr32 = _nvkm_fifo_channel_wr32,
-	.ntfy = _nvkm_fifo_channel_ntfy
-};
-
-static struct nvkm_oclass
-nv04_fifo_sclass[] = {
-	{ NV03_CHANNEL_DMA, &nv04_fifo_ofuncs },
-	{}
-};
-
-/*******************************************************************************
- * FIFO context - basically just the instmem reserved for the channel
- ******************************************************************************/
-
-int
-nv04_fifo_context_ctor(struct nvkm_object *parent,
-		       struct nvkm_object *engine,
-		       struct nvkm_oclass *oclass, void *data, u32 size,
-		       struct nvkm_object **pobject)
-{
-	struct nv04_fifo_base *base;
-	int ret;
-
-	ret = nvkm_fifo_context_create(parent, engine, oclass, NULL, 0x1000,
-				       0x1000, NVOBJ_FLAG_HEAP, &base);
-	*pobject = nv_object(base);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static struct nvkm_oclass
-nv04_fifo_cclass = {
-	.handle = NV_ENGCTX(FIFO, 0x04),
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nv04_fifo_context_ctor,
-		.dtor = _nvkm_fifo_context_dtor,
-		.init = _nvkm_fifo_context_init,
-		.fini = _nvkm_fifo_context_fini,
-		.rd32 = _nvkm_fifo_context_rd32,
-		.wr32 = _nvkm_fifo_context_wr32,
-	},
-};
-
-/*******************************************************************************
- * PFIFO engine
- ******************************************************************************/
-
 void
 nv04_fifo_pause(struct nvkm_fifo *obj, unsigned long *pflags)
 __acquires(fifo->base.lock)
@@ -552,36 +287,6 @@ nv04_fifo_intr(struct nvkm_subdev *subdev)
 	nvkm_wr32(device, NV03_PFIFO_CACHES, reassign);
 }
 
-static int
-nv04_fifo_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-	       struct nvkm_oclass *oclass, void *data, u32 size,
-	       struct nvkm_object **pobject)
-{
-	struct nv04_fifo *fifo;
-	int ret;
-
-	ret = nvkm_fifo_create(parent, engine, oclass, 0, 15, &fifo);
-	*pobject = nv_object(fifo);
-	if (ret)
-		return ret;
-
-	nv_subdev(fifo)->unit = 0x00000100;
-	nv_subdev(fifo)->intr = nv04_fifo_intr;
-	nv_engine(fifo)->cclass = &nv04_fifo_cclass;
-	nv_engine(fifo)->sclass = nv04_fifo_sclass;
-	fifo->base.pause = nv04_fifo_pause;
-	fifo->base.start = nv04_fifo_start;
-	fifo->ramfc_desc = nv04_ramfc;
-	return 0;
-}
-
-void
-nv04_fifo_dtor(struct nvkm_object *object)
-{
-	struct nv04_fifo *fifo = (void *)object;
-	nvkm_fifo_destroy(&fifo->base);
-}
-
 int
 nv04_fifo_init(struct nvkm_object *object)
 {
@@ -617,6 +322,36 @@ nv04_fifo_init(struct nvkm_object *object)
 	return 0;
 }
 
+void
+nv04_fifo_dtor(struct nvkm_object *object)
+{
+	struct nv04_fifo *fifo = (void *)object;
+	nvkm_fifo_destroy(&fifo->base);
+}
+
+static int
+nv04_fifo_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+	       struct nvkm_oclass *oclass, void *data, u32 size,
+	       struct nvkm_object **pobject)
+{
+	struct nv04_fifo *fifo;
+	int ret;
+
+	ret = nvkm_fifo_create(parent, engine, oclass, 0, 15, &fifo);
+	*pobject = nv_object(fifo);
+	if (ret)
+		return ret;
+
+	nv_subdev(fifo)->unit = 0x00000100;
+	nv_subdev(fifo)->intr = nv04_fifo_intr;
+	nv_engine(fifo)->cclass = &nv04_fifo_cclass;
+	nv_engine(fifo)->sclass = nv04_fifo_sclass;
+	fifo->base.pause = nv04_fifo_pause;
+	fifo->base.start = nv04_fifo_start;
+	fifo->ramfc_desc = nv04_ramfc;
+	return 0;
+}
+
 struct nvkm_oclass *
 nv04_fifo_oclass = &(struct nvkm_oclass) {
 	.handle = NV_ENGINE(FIFO, 0x04),

commit 6157091177102638c7d94ffc159c0b157a1c9b56
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/sw: remove dependence on namedb/engctx lookup
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index cd5009302e22..8bdb71f5f1c5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -29,6 +29,7 @@
 #include <core/ramht.h>
 #include <subdev/instmem.h>
 #include <subdev/timer.h>
+#include <engine/sw.h>
 
 #include <nvif/class.h>
 #include <nvif/unpack.h>
@@ -369,55 +370,29 @@ nv_dma_state_err(u32 state)
 }
 
 static bool
-nv04_fifo_swmthd(struct nv04_fifo *fifo, u32 chid, u32 addr, u32 data)
+nv04_fifo_swmthd(struct nvkm_device *device, u32 chid, u32 addr, u32 data)
 {
-	struct nvkm_device *device = fifo->base.engine.subdev.device;
-	struct nv04_fifo_chan *chan = NULL;
-	struct nvkm_handle *bind;
-	const int subc = (addr >> 13) & 0x7;
-	const int mthd = addr & 0x1ffc;
+	struct nvkm_sw *sw = device->sw;
+	const int subc = (addr & 0x0000e000) >> 13;
+	const int mthd = (addr & 0x00001ffc);
+	const u32 mask = 0x0000000f << (subc * 4);
+	u32 engine = nvkm_rd32(device, 0x003280);
 	bool handled = false;
-	unsigned long flags;
-	u32 engine;
-
-	spin_lock_irqsave(&fifo->base.lock, flags);
-	if (likely(chid >= fifo->base.min && chid <= fifo->base.max))
-		chan = (void *)fifo->base.channel[chid];
-	if (unlikely(!chan))
-		goto out;
 
 	switch (mthd) {
-	case 0x0000:
-		bind = nvkm_namedb_get(nv_namedb(chan), data);
-		if (unlikely(!bind))
-			break;
-
-		if (nv_engidx(bind->object->engine) == NVDEV_ENGINE_SW) {
-			engine = 0x0000000f << (subc * 4);
-			chan->subc[subc] = data;
-			handled = true;
-
-			nvkm_mask(device, NV04_PFIFO_CACHE1_ENGINE, engine, 0);
-		}
-
-		nvkm_namedb_put(bind);
+	case 0x0000 ... 0x0000: /* subchannel's engine -> software */
+		nvkm_wr32(device, 0x003280, (engine &= ~mask));
+	case 0x0180 ... 0x01fc: /* handle -> instance */
+		data = nvkm_rd32(device, 0x003258) & 0x0000ffff;
+	case 0x0100 ... 0x017c:
+	case 0x0200 ... 0x1ffc: /* pass method down to sw */
+		if (!(engine & mask) && sw)
+			handled = nvkm_sw_mthd(sw, chid, subc, mthd, data);
 		break;
 	default:
-		engine = nvkm_rd32(device, NV04_PFIFO_CACHE1_ENGINE);
-		if (unlikely(((engine >> (subc * 4)) & 0xf) != 0))
-			break;
-
-		bind = nvkm_namedb_get(nv_namedb(chan), chan->subc[subc]);
-		if (likely(bind)) {
-			if (!nv_call(bind->object, mthd, data))
-				handled = true;
-			nvkm_namedb_put(bind);
-		}
 		break;
 	}
 
-out:
-	spin_unlock_irqrestore(&fifo->base.lock, flags);
 	return handled;
 }
 
@@ -426,6 +401,7 @@ nv04_fifo_cache_error(struct nv04_fifo *fifo, u32 chid, u32 get)
 {
 	struct nvkm_subdev *subdev = &fifo->base.engine.subdev;
 	struct nvkm_device *device = subdev->device;
+	u32 pull0 = nvkm_rd32(device, 0x003250);
 	u32 mthd, data;
 	int ptr;
 
@@ -444,7 +420,8 @@ nv04_fifo_cache_error(struct nv04_fifo *fifo, u32 chid, u32 get)
 		data = nvkm_rd32(device, NV40_PFIFO_CACHE1_DATA(ptr));
 	}
 
-	if (!nv04_fifo_swmthd(fifo, chid, mthd, data)) {
+	if (!(pull0 & 0x00000100) ||
+	    !nv04_fifo_swmthd(device, chid, mthd, data)) {
 		const char *client_name =
 			nvkm_client_name_for_fifo_chid(&fifo->base, chid);
 		nvkm_error(subdev, "CACHE_ERROR - "

commit 1d2a1e53865266a67fb569705eba3ec992682721
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/ramht: remove dependence on namedb
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index 4bec70730558..cd5009302e22 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -86,7 +86,7 @@ nv04_fifo_object_attach(struct nvkm_object *parent,
 	context |= chid << 24;
 
 	mutex_lock(&nv_subdev(fifo)->mutex);
-	ret = nvkm_ramht_insert(imem->ramht, chid, handle, context);
+	ret = nvkm_ramht_insert(imem->ramht, NULL, chid, 0, handle, context);
 	mutex_unlock(&nv_subdev(fifo)->mutex);
 	return ret;
 }
@@ -625,7 +625,7 @@ nv04_fifo_init(struct nvkm_object *object)
 
 	nvkm_wr32(device, NV03_PFIFO_RAMHT, (0x03 << 24) /* search 128 */ |
 					    ((ramht->bits - 9) << 16) |
-					    (ramht->gpuobj.addr >> 8));
+					    (ramht->gpuobj->addr >> 8));
 	nvkm_wr32(device, NV03_PFIFO_RAMRO, nvkm_memory_addr(ramro) >> 8);
 	nvkm_wr32(device, NV03_PFIFO_RAMFC, nvkm_memory_addr(ramfc) >> 8);
 

commit f027f49166171c98d5945af12ac3ee9bc9f9bf4c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/gpuobj: separate allocation from nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index f0fd1ce8f671..4bec70730558 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -65,19 +65,21 @@ nv04_fifo_object_attach(struct nvkm_object *parent,
 	else
 		context = 0x00000004; /* just non-zero */
 
-	switch (nv_engidx(object->engine)) {
-	case NVDEV_ENGINE_DMAOBJ:
-	case NVDEV_ENGINE_SW:
-		context |= 0x00000000;
-		break;
-	case NVDEV_ENGINE_GR:
-		context |= 0x00010000;
-		break;
-	case NVDEV_ENGINE_MPEG:
-		context |= 0x00020000;
-		break;
-	default:
-		return -EINVAL;
+	if (object->engine) {
+		switch (nv_engidx(object->engine)) {
+		case NVDEV_ENGINE_DMAOBJ:
+		case NVDEV_ENGINE_SW:
+			context |= 0x00000000;
+			break;
+		case NVDEV_ENGINE_GR:
+			context |= 0x00010000;
+			break;
+		case NVDEV_ENGINE_MPEG:
+			context |= 0x00020000;
+			break;
+		default:
+			return -EINVAL;
+		}
 	}
 
 	context |= 0x80000000; /* valid */

commit 5b1ab0c2c79c3556c4350f4f47d11745fdffad8f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/imem/nv04-nv40: directly use instmem for vbios/ramfc/ramro
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index b01490f71f09..f0fd1ce8f671 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -56,6 +56,7 @@ nv04_fifo_object_attach(struct nvkm_object *parent,
 {
 	struct nv04_fifo *fifo = (void *)parent->engine;
 	struct nv04_fifo_chan *chan = (void *)parent;
+	struct nvkm_instmem *imem = fifo->base.engine.subdev.device->imem;
 	u32 context, chid = chan->base.chid;
 	int ret;
 
@@ -83,7 +84,7 @@ nv04_fifo_object_attach(struct nvkm_object *parent,
 	context |= chid << 24;
 
 	mutex_lock(&nv_subdev(fifo)->mutex);
-	ret = nvkm_ramht_insert(fifo->ramht, chid, handle, context);
+	ret = nvkm_ramht_insert(imem->ramht, chid, handle, context);
 	mutex_unlock(&nv_subdev(fifo)->mutex);
 	return ret;
 }
@@ -92,8 +93,9 @@ void
 nv04_fifo_object_detach(struct nvkm_object *parent, int cookie)
 {
 	struct nv04_fifo *fifo = (void *)parent->engine;
+	struct nvkm_instmem *imem = fifo->base.engine.subdev.device->imem;
 	mutex_lock(&nv_subdev(fifo)->mutex);
-	nvkm_ramht_remove(fifo->ramht, cookie);
+	nvkm_ramht_remove(imem->ramht, cookie);
 	mutex_unlock(&nv_subdev(fifo)->mutex);
 }
 
@@ -115,6 +117,7 @@ nv04_fifo_chan_ctor(struct nvkm_object *parent,
 		struct nv03_channel_dma_v0 v0;
 	} *args = data;
 	struct nv04_fifo *fifo = (void *)engine;
+	struct nvkm_instmem *imem = fifo->base.engine.subdev.device->imem;
 	struct nv04_fifo_chan *chan;
 	int ret;
 
@@ -142,18 +145,18 @@ nv04_fifo_chan_ctor(struct nvkm_object *parent,
 	nv_parent(chan)->context_attach = nv04_fifo_context_attach;
 	chan->ramfc = chan->base.chid * 32;
 
-	nvkm_kmap(fifo->ramfc);
-	nvkm_wo32(fifo->ramfc, chan->ramfc + 0x00, args->v0.offset);
-	nvkm_wo32(fifo->ramfc, chan->ramfc + 0x04, args->v0.offset);
-	nvkm_wo32(fifo->ramfc, chan->ramfc + 0x08, chan->base.pushgpu->addr >> 4);
-	nvkm_wo32(fifo->ramfc, chan->ramfc + 0x10,
+	nvkm_kmap(imem->ramfc);
+	nvkm_wo32(imem->ramfc, chan->ramfc + 0x00, args->v0.offset);
+	nvkm_wo32(imem->ramfc, chan->ramfc + 0x04, args->v0.offset);
+	nvkm_wo32(imem->ramfc, chan->ramfc + 0x08, chan->base.pushgpu->addr >> 4);
+	nvkm_wo32(imem->ramfc, chan->ramfc + 0x10,
 			     NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |
 			     NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |
 #ifdef __BIG_ENDIAN
 			     NV_PFIFO_CACHE1_BIG_ENDIAN |
 #endif
 			     NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8);
-	nvkm_done(fifo->ramfc);
+	nvkm_done(imem->ramfc);
 	return 0;
 }
 
@@ -162,13 +165,14 @@ nv04_fifo_chan_dtor(struct nvkm_object *object)
 {
 	struct nv04_fifo *fifo = (void *)object->engine;
 	struct nv04_fifo_chan *chan = (void *)object;
+	struct nvkm_instmem *imem = fifo->base.engine.subdev.device->imem;
 	struct ramfc_desc *c = fifo->ramfc_desc;
 
-	nvkm_kmap(fifo->ramfc);
+	nvkm_kmap(imem->ramfc);
 	do {
-		nvkm_wo32(fifo->ramfc, chan->ramfc + c->ctxp, 0x00000000);
+		nvkm_wo32(imem->ramfc, chan->ramfc + c->ctxp, 0x00000000);
 	} while ((++c)->bits);
-	nvkm_done(fifo->ramfc);
+	nvkm_done(imem->ramfc);
 
 	nvkm_fifo_channel_destroy(&chan->base);
 }
@@ -198,8 +202,8 @@ nv04_fifo_chan_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nv04_fifo *fifo = (void *)object->engine;
 	struct nv04_fifo_chan *chan = (void *)object;
-	struct nvkm_gpuobj *fctx = fifo->ramfc;
 	struct nvkm_device *device = fifo->base.engine.subdev.device;
+	struct nvkm_memory *fctx = device->imem->ramfc;
 	struct ramfc_desc *c;
 	unsigned long flags;
 	u32 data = chan->ramfc;
@@ -574,8 +578,6 @@ nv04_fifo_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_oclass *oclass, void *data, u32 size,
 	       struct nvkm_object **pobject)
 {
-	struct nvkm_device *device = (void *)parent;
-	struct nvkm_instmem *imem = device->imem;
 	struct nv04_fifo *fifo;
 	int ret;
 
@@ -584,10 +586,6 @@ nv04_fifo_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	nvkm_ramht_ref(imem->ramht, &fifo->ramht);
-	nvkm_gpuobj_ref(imem->ramro, &fifo->ramro);
-	nvkm_gpuobj_ref(imem->ramfc, &fifo->ramfc);
-
 	nv_subdev(fifo)->unit = 0x00000100;
 	nv_subdev(fifo)->intr = nv04_fifo_intr;
 	nv_engine(fifo)->cclass = &nv04_fifo_cclass;
@@ -602,9 +600,6 @@ void
 nv04_fifo_dtor(struct nvkm_object *object)
 {
 	struct nv04_fifo *fifo = (void *)object;
-	nvkm_gpuobj_ref(NULL, &fifo->ramfc);
-	nvkm_gpuobj_ref(NULL, &fifo->ramro);
-	nvkm_ramht_ref(NULL, &fifo->ramht);
 	nvkm_fifo_destroy(&fifo->base);
 }
 
@@ -613,6 +608,10 @@ nv04_fifo_init(struct nvkm_object *object)
 {
 	struct nv04_fifo *fifo = (void *)object;
 	struct nvkm_device *device = fifo->base.engine.subdev.device;
+	struct nvkm_instmem *imem = device->imem;
+	struct nvkm_ramht *ramht = imem->ramht;
+	struct nvkm_memory *ramro = imem->ramro;
+	struct nvkm_memory *ramfc = imem->ramfc;
 	int ret;
 
 	ret = nvkm_fifo_init(&fifo->base);
@@ -623,10 +622,10 @@ nv04_fifo_init(struct nvkm_object *object)
 	nvkm_wr32(device, NV04_PFIFO_DMA_TIMESLICE, 0x0101ffff);
 
 	nvkm_wr32(device, NV03_PFIFO_RAMHT, (0x03 << 24) /* search 128 */ |
-				       ((fifo->ramht->bits - 9) << 16) |
-				        (fifo->ramht->gpuobj.addr >> 8));
-	nvkm_wr32(device, NV03_PFIFO_RAMRO, fifo->ramro->addr >> 8);
-	nvkm_wr32(device, NV03_PFIFO_RAMFC, fifo->ramfc->addr >> 8);
+					    ((ramht->bits - 9) << 16) |
+					    (ramht->gpuobj.addr >> 8));
+	nvkm_wr32(device, NV03_PFIFO_RAMRO, nvkm_memory_addr(ramro) >> 8);
+	nvkm_wr32(device, NV03_PFIFO_RAMFC, nvkm_memory_addr(ramfc) >> 8);
 
 	nvkm_wr32(device, NV03_PFIFO_CACHE1_PUSH1, fifo->base.max);
 

commit d8e83994aaf6749b7124a219f5b46bd1329e2a08
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/imem: improve management of instance memory
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index 51b8fce9e0fc..b01490f71f09 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -27,7 +27,7 @@
 #include <core/engctx.h>
 #include <core/handle.h>
 #include <core/ramht.h>
-#include <subdev/instmem/nv04.h>
+#include <subdev/instmem.h>
 #include <subdev/timer.h>
 
 #include <nvif/class.h>
@@ -574,7 +574,8 @@ nv04_fifo_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_oclass *oclass, void *data, u32 size,
 	       struct nvkm_object **pobject)
 {
-	struct nv04_instmem *imem = nv04_instmem(parent);
+	struct nvkm_device *device = (void *)parent;
+	struct nvkm_instmem *imem = device->imem;
 	struct nv04_fifo *fifo;
 	int ret;
 

commit 159045cdc460794df27e2cc624a9641be5c54b23
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/nvif: replace pushbuf with vm in fermi/kepler gpfifo class args
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index 6458fa0dcb95..51b8fce9e0fc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -121,7 +121,7 @@ nv04_fifo_chan_ctor(struct nvkm_object *parent,
 	nvif_ioctl(parent, "create channel dma size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
 		nvif_ioctl(parent, "create channel dma vers %d pushbuf %llx "
-				   "offset %016llx\n", args->v0.version,
+				   "offset %08x\n", args->v0.version,
 			   args->v0.pushbuf, args->v0.offset);
 	} else
 		return ret;

commit bf81df9be28657eea4aca8c6ab4ed3e69f8a051c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/nvif: replace path-based object identification
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index d5346636b7e3..6458fa0dcb95 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -120,7 +120,7 @@ nv04_fifo_chan_ctor(struct nvkm_object *parent,
 
 	nvif_ioctl(parent, "create channel dma size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nvif_ioctl(parent, "create channel dma vers %d pushbuf %08x "
+		nvif_ioctl(parent, "create channel dma vers %d pushbuf %llx "
 				   "offset %016llx\n", args->v0.version,
 			   args->v0.pushbuf, args->v0.offset);
 	} else

commit 5444e770e3991ddb5a9583d622fc18bbf414b551
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:14 2015 +1000

    drm/nouveau/fifo: switch to gpuobj accessor macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index 5eca5de292f6..d5346636b7e3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -142,16 +142,18 @@ nv04_fifo_chan_ctor(struct nvkm_object *parent,
 	nv_parent(chan)->context_attach = nv04_fifo_context_attach;
 	chan->ramfc = chan->base.chid * 32;
 
-	nv_wo32(fifo->ramfc, chan->ramfc + 0x00, args->v0.offset);
-	nv_wo32(fifo->ramfc, chan->ramfc + 0x04, args->v0.offset);
-	nv_wo32(fifo->ramfc, chan->ramfc + 0x08, chan->base.pushgpu->addr >> 4);
-	nv_wo32(fifo->ramfc, chan->ramfc + 0x10,
+	nvkm_kmap(fifo->ramfc);
+	nvkm_wo32(fifo->ramfc, chan->ramfc + 0x00, args->v0.offset);
+	nvkm_wo32(fifo->ramfc, chan->ramfc + 0x04, args->v0.offset);
+	nvkm_wo32(fifo->ramfc, chan->ramfc + 0x08, chan->base.pushgpu->addr >> 4);
+	nvkm_wo32(fifo->ramfc, chan->ramfc + 0x10,
 			     NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |
 			     NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |
 #ifdef __BIG_ENDIAN
 			     NV_PFIFO_CACHE1_BIG_ENDIAN |
 #endif
 			     NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8);
+	nvkm_done(fifo->ramfc);
 	return 0;
 }
 
@@ -162,9 +164,11 @@ nv04_fifo_chan_dtor(struct nvkm_object *object)
 	struct nv04_fifo_chan *chan = (void *)object;
 	struct ramfc_desc *c = fifo->ramfc_desc;
 
+	nvkm_kmap(fifo->ramfc);
 	do {
-		nv_wo32(fifo->ramfc, chan->ramfc + c->ctxp, 0x00000000);
+		nvkm_wo32(fifo->ramfc, chan->ramfc + c->ctxp, 0x00000000);
 	} while ((++c)->bits);
+	nvkm_done(fifo->ramfc);
 
 	nvkm_fifo_channel_destroy(&chan->base);
 }
@@ -217,8 +221,8 @@ nv04_fifo_chan_fini(struct nvkm_object *object, bool suspend)
 			u32 rm = ((1ULL << c->bits) - 1) << c->regs;
 			u32 cm = ((1ULL << c->bits) - 1) << c->ctxs;
 			u32 rv = (nvkm_rd32(device, c->regp) &  rm) >> c->regs;
-			u32 cv = (nv_ro32(fctx, c->ctxp + data) & ~cm);
-			nv_wo32(fctx, c->ctxp + data, cv | (rv << c->ctxs));
+			u32 cv = (nvkm_ro32(fctx, c->ctxp + data) & ~cm);
+			nvkm_wo32(fctx, c->ctxp + data, cv | (rv << c->ctxs));
 		} while ((++c)->bits);
 
 		c = fifo->ramfc_desc;

commit 53003941067534b1071b0f7b71f4700c16d97b28
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:13 2015 +1000

    drm/nouveau/core: remove last printks
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index 61de6fded74b..5eca5de292f6 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -118,11 +118,11 @@ nv04_fifo_chan_ctor(struct nvkm_object *parent,
 	struct nv04_fifo_chan *chan;
 	int ret;
 
-	nv_ioctl(parent, "create channel dma size %d\n", size);
+	nvif_ioctl(parent, "create channel dma size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(parent, "create channel dma vers %d pushbuf %08x "
-				 "offset %016llx\n", args->v0.version,
-			 args->v0.pushbuf, args->v0.offset);
+		nvif_ioctl(parent, "create channel dma vers %d pushbuf %08x "
+				   "offset %016llx\n", args->v0.version,
+			   args->v0.pushbuf, args->v0.offset);
 	} else
 		return ret;
 

commit e5c5e4f5d319799fe67dc67531e41ba0b7ed15e6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:13 2015 +1000

    drm/nouveau/fifo: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index 214bf122b19c..61de6fded74b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -412,9 +412,10 @@ nv04_fifo_swmthd(struct nv04_fifo *fifo, u32 chid, u32 addr, u32 data)
 }
 
 static void
-nv04_fifo_cache_error(struct nvkm_device *device,
-		      struct nv04_fifo *fifo, u32 chid, u32 get)
+nv04_fifo_cache_error(struct nv04_fifo *fifo, u32 chid, u32 get)
 {
+	struct nvkm_subdev *subdev = &fifo->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	u32 mthd, data;
 	int ptr;
 
@@ -436,10 +437,10 @@ nv04_fifo_cache_error(struct nvkm_device *device,
 	if (!nv04_fifo_swmthd(fifo, chid, mthd, data)) {
 		const char *client_name =
 			nvkm_client_name_for_fifo_chid(&fifo->base, chid);
-		nv_error(fifo,
-			 "CACHE_ERROR - ch %d [%s] subc %d mthd 0x%04x data 0x%08x\n",
-			 chid, client_name, (mthd >> 13) & 7, mthd & 0x1ffc,
-			 data);
+		nvkm_error(subdev, "CACHE_ERROR - "
+			   "ch %d [%s] subc %d mthd %04x data %08x\n",
+			   chid, client_name, (mthd >> 13) & 7, mthd & 0x1ffc,
+			   data);
 	}
 
 	nvkm_wr32(device, NV04_PFIFO_CACHE1_DMA_PUSH, 0);
@@ -458,14 +459,15 @@ nv04_fifo_cache_error(struct nvkm_device *device,
 }
 
 static void
-nv04_fifo_dma_pusher(struct nvkm_device *device,
-		     struct nv04_fifo *fifo, u32 chid)
+nv04_fifo_dma_pusher(struct nv04_fifo *fifo, u32 chid)
 {
-	const char *client_name;
+	struct nvkm_subdev *subdev = &fifo->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	u32 dma_get = nvkm_rd32(device, 0x003244);
 	u32 dma_put = nvkm_rd32(device, 0x003240);
 	u32 push = nvkm_rd32(device, 0x003220);
 	u32 state = nvkm_rd32(device, 0x003228);
+	const char *client_name;
 
 	client_name = nvkm_client_name_for_fifo_chid(&fifo->base, chid);
 
@@ -475,10 +477,12 @@ nv04_fifo_dma_pusher(struct nvkm_device *device,
 		u32 ib_get = nvkm_rd32(device, 0x003334);
 		u32 ib_put = nvkm_rd32(device, 0x003330);
 
-		nv_error(fifo,
-			 "DMA_PUSHER - ch %d [%s] get 0x%02x%08x put 0x%02x%08x ib_get 0x%08x ib_put 0x%08x state 0x%08x (err: %s) push 0x%08x\n",
-			 chid, client_name, ho_get, dma_get, ho_put, dma_put,
-			 ib_get, ib_put, state, nv_dma_state_err(state), push);
+		nvkm_error(subdev, "DMA_PUSHER - "
+			   "ch %d [%s] get %02x%08x put %02x%08x ib_get %08x "
+			   "ib_put %08x state %08x (err: %s) push %08x\n",
+			   chid, client_name, ho_get, dma_get, ho_put, dma_put,
+			   ib_get, ib_put, state, nv_dma_state_err(state),
+			   push);
 
 		/* METHOD_COUNT, in DMA_STATE on earlier chipsets */
 		nvkm_wr32(device, 0x003364, 0x00000000);
@@ -489,10 +493,10 @@ nv04_fifo_dma_pusher(struct nvkm_device *device,
 		if (ib_get != ib_put)
 			nvkm_wr32(device, 0x003334, ib_put);
 	} else {
-		nv_error(fifo,
-			 "DMA_PUSHER - ch %d [%s] get 0x%08x put 0x%08x state 0x%08x (err: %s) push 0x%08x\n",
-			 chid, client_name, dma_get, dma_put, state,
-			 nv_dma_state_err(state), push);
+		nvkm_error(subdev, "DMA_PUSHER - ch %d [%s] get %08x put %08x "
+				   "state %08x (err: %s) push %08x\n",
+			   chid, client_name, dma_get, dma_put, state,
+			   nv_dma_state_err(state), push);
 
 		if (dma_get != dma_put)
 			nvkm_wr32(device, 0x003244, dma_put);
@@ -506,7 +510,7 @@ nv04_fifo_dma_pusher(struct nvkm_device *device,
 void
 nv04_fifo_intr(struct nvkm_subdev *subdev)
 {
-	struct nvkm_device *device = nv_device(subdev);
+	struct nvkm_device *device = subdev->device;
 	struct nv04_fifo *fifo = (void *)subdev;
 	u32 mask = nvkm_rd32(device, NV03_PFIFO_INTR_EN_0);
 	u32 stat = nvkm_rd32(device, NV03_PFIFO_INTR_0) & mask;
@@ -519,12 +523,12 @@ nv04_fifo_intr(struct nvkm_subdev *subdev)
 	get  = nvkm_rd32(device, NV03_PFIFO_CACHE1_GET);
 
 	if (stat & NV_PFIFO_INTR_CACHE_ERROR) {
-		nv04_fifo_cache_error(device, fifo, chid, get);
+		nv04_fifo_cache_error(fifo, chid, get);
 		stat &= ~NV_PFIFO_INTR_CACHE_ERROR;
 	}
 
 	if (stat & NV_PFIFO_INTR_DMA_PUSHER) {
-		nv04_fifo_dma_pusher(device, fifo, chid);
+		nv04_fifo_dma_pusher(fifo, chid);
 		stat &= ~NV_PFIFO_INTR_DMA_PUSHER;
 	}
 
@@ -553,7 +557,7 @@ nv04_fifo_intr(struct nvkm_subdev *subdev)
 	}
 
 	if (stat) {
-		nv_warn(fifo, "unknown intr 0x%08x\n", stat);
+		nvkm_warn(subdev, "intr %08x\n", stat);
 		nvkm_mask(device, NV03_PFIFO_INTR_EN_0, stat, 0x00000000);
 		nvkm_wr32(device, NV03_PFIFO_INTR_0, stat);
 	}

commit af3082b3c621e75371dc6d11fac5a2dc2b19b1bc
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:11 2015 +1000

    drm/nouveau/fifo: switch to new-style timer macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index 6339b473feb0..214bf122b19c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -321,9 +321,11 @@ __acquires(fifo->base.lock)
 	 * to avoid this, we invalidate the most recently calculated
 	 * instance.
 	 */
-	if (!nv_wait(fifo, NV04_PFIFO_CACHE1_PULL0,
-			   NV04_PFIFO_CACHE1_PULL0_HASH_BUSY, 0x00000000))
-		nv_warn(fifo, "timeout idling puller\n");
+	nvkm_msec(device, 2000,
+		u32 tmp = nvkm_rd32(device, NV04_PFIFO_CACHE1_PULL0);
+		if (!(tmp & NV04_PFIFO_CACHE1_PULL0_HASH_BUSY))
+			break;
+	);
 
 	if (nvkm_rd32(device, NV04_PFIFO_CACHE1_PULL0) &
 			  NV04_PFIFO_CACHE1_PULL0_HASH_FAILED)

commit 8774440390cdfe37c5d003f850847c9fd67cdf61
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:10 2015 +1000

    drm/nouveau/fifo: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index 91a2080bdaf9..6339b473feb0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -174,6 +174,7 @@ nv04_fifo_chan_init(struct nvkm_object *object)
 {
 	struct nv04_fifo *fifo = (void *)object->engine;
 	struct nv04_fifo_chan *chan = (void *)object;
+	struct nvkm_device *device = fifo->base.engine.subdev.device;
 	u32 mask = 1 << chan->base.chid;
 	unsigned long flags;
 	int ret;
@@ -183,7 +184,7 @@ nv04_fifo_chan_init(struct nvkm_object *object)
 		return ret;
 
 	spin_lock_irqsave(&fifo->base.lock, flags);
-	nv_mask(fifo, NV04_PFIFO_MODE, mask, mask);
+	nvkm_mask(device, NV04_PFIFO_MODE, mask, mask);
 	spin_unlock_irqrestore(&fifo->base.lock, flags);
 	return 0;
 }
@@ -194,6 +195,7 @@ nv04_fifo_chan_fini(struct nvkm_object *object, bool suspend)
 	struct nv04_fifo *fifo = (void *)object->engine;
 	struct nv04_fifo_chan *chan = (void *)object;
 	struct nvkm_gpuobj *fctx = fifo->ramfc;
+	struct nvkm_device *device = fifo->base.engine.subdev.device;
 	struct ramfc_desc *c;
 	unsigned long flags;
 	u32 data = chan->ramfc;
@@ -201,39 +203,39 @@ nv04_fifo_chan_fini(struct nvkm_object *object, bool suspend)
 
 	/* prevent fifo context switches */
 	spin_lock_irqsave(&fifo->base.lock, flags);
-	nv_wr32(fifo, NV03_PFIFO_CACHES, 0);
+	nvkm_wr32(device, NV03_PFIFO_CACHES, 0);
 
 	/* if this channel is active, replace it with a null context */
-	chid = nv_rd32(fifo, NV03_PFIFO_CACHE1_PUSH1) & fifo->base.max;
+	chid = nvkm_rd32(device, NV03_PFIFO_CACHE1_PUSH1) & fifo->base.max;
 	if (chid == chan->base.chid) {
-		nv_mask(fifo, NV04_PFIFO_CACHE1_DMA_PUSH, 0x00000001, 0);
-		nv_wr32(fifo, NV03_PFIFO_CACHE1_PUSH0, 0);
-		nv_mask(fifo, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0);
+		nvkm_mask(device, NV04_PFIFO_CACHE1_DMA_PUSH, 0x00000001, 0);
+		nvkm_wr32(device, NV03_PFIFO_CACHE1_PUSH0, 0);
+		nvkm_mask(device, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0);
 
 		c = fifo->ramfc_desc;
 		do {
 			u32 rm = ((1ULL << c->bits) - 1) << c->regs;
 			u32 cm = ((1ULL << c->bits) - 1) << c->ctxs;
-			u32 rv = (nv_rd32(fifo, c->regp) &  rm) >> c->regs;
+			u32 rv = (nvkm_rd32(device, c->regp) &  rm) >> c->regs;
 			u32 cv = (nv_ro32(fctx, c->ctxp + data) & ~cm);
 			nv_wo32(fctx, c->ctxp + data, cv | (rv << c->ctxs));
 		} while ((++c)->bits);
 
 		c = fifo->ramfc_desc;
 		do {
-			nv_wr32(fifo, c->regp, 0x00000000);
+			nvkm_wr32(device, c->regp, 0x00000000);
 		} while ((++c)->bits);
 
-		nv_wr32(fifo, NV03_PFIFO_CACHE1_GET, 0);
-		nv_wr32(fifo, NV03_PFIFO_CACHE1_PUT, 0);
-		nv_wr32(fifo, NV03_PFIFO_CACHE1_PUSH1, fifo->base.max);
-		nv_wr32(fifo, NV03_PFIFO_CACHE1_PUSH0, 1);
-		nv_wr32(fifo, NV04_PFIFO_CACHE1_PULL0, 1);
+		nvkm_wr32(device, NV03_PFIFO_CACHE1_GET, 0);
+		nvkm_wr32(device, NV03_PFIFO_CACHE1_PUT, 0);
+		nvkm_wr32(device, NV03_PFIFO_CACHE1_PUSH1, fifo->base.max);
+		nvkm_wr32(device, NV03_PFIFO_CACHE1_PUSH0, 1);
+		nvkm_wr32(device, NV04_PFIFO_CACHE1_PULL0, 1);
 	}
 
 	/* restore normal operation, after disabling dma mode */
-	nv_mask(fifo, NV04_PFIFO_MODE, 1 << chan->base.chid, 0);
-	nv_wr32(fifo, NV03_PFIFO_CACHES, 1);
+	nvkm_mask(device, NV04_PFIFO_MODE, 1 << chan->base.chid, 0);
+	nvkm_wr32(device, NV03_PFIFO_CACHES, 1);
 	spin_unlock_irqrestore(&fifo->base.lock, flags);
 
 	return nvkm_fifo_channel_fini(&chan->base, suspend);
@@ -301,13 +303,14 @@ nv04_fifo_pause(struct nvkm_fifo *obj, unsigned long *pflags)
 __acquires(fifo->base.lock)
 {
 	struct nv04_fifo *fifo = container_of(obj, typeof(*fifo), base);
+	struct nvkm_device *device = fifo->base.engine.subdev.device;
 	unsigned long flags;
 
 	spin_lock_irqsave(&fifo->base.lock, flags);
 	*pflags = flags;
 
-	nv_wr32(fifo, NV03_PFIFO_CACHES, 0x00000000);
-	nv_mask(fifo, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0x00000000);
+	nvkm_wr32(device, NV03_PFIFO_CACHES, 0x00000000);
+	nvkm_mask(device, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0x00000000);
 
 	/* in some cases the puller may be left in an inconsistent state
 	 * if you try to stop it while it's busy translating handles.
@@ -322,11 +325,11 @@ __acquires(fifo->base.lock)
 			   NV04_PFIFO_CACHE1_PULL0_HASH_BUSY, 0x00000000))
 		nv_warn(fifo, "timeout idling puller\n");
 
-	if (nv_rd32(fifo, NV04_PFIFO_CACHE1_PULL0) &
+	if (nvkm_rd32(device, NV04_PFIFO_CACHE1_PULL0) &
 			  NV04_PFIFO_CACHE1_PULL0_HASH_FAILED)
-		nv_wr32(fifo, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_CACHE_ERROR);
+		nvkm_wr32(device, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_CACHE_ERROR);
 
-	nv_wr32(fifo, NV04_PFIFO_CACHE1_HASH, 0x00000000);
+	nvkm_wr32(device, NV04_PFIFO_CACHE1_HASH, 0x00000000);
 }
 
 void
@@ -334,10 +337,11 @@ nv04_fifo_start(struct nvkm_fifo *obj, unsigned long *pflags)
 __releases(fifo->base.lock)
 {
 	struct nv04_fifo *fifo = container_of(obj, typeof(*fifo), base);
+	struct nvkm_device *device = fifo->base.engine.subdev.device;
 	unsigned long flags = *pflags;
 
-	nv_mask(fifo, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0x00000001);
-	nv_wr32(fifo, NV03_PFIFO_CACHES, 0x00000001);
+	nvkm_mask(device, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0x00000001);
+	nvkm_wr32(device, NV03_PFIFO_CACHES, 0x00000001);
 
 	spin_unlock_irqrestore(&fifo->base.lock, flags);
 }
@@ -355,6 +359,7 @@ nv_dma_state_err(u32 state)
 static bool
 nv04_fifo_swmthd(struct nv04_fifo *fifo, u32 chid, u32 addr, u32 data)
 {
+	struct nvkm_device *device = fifo->base.engine.subdev.device;
 	struct nv04_fifo_chan *chan = NULL;
 	struct nvkm_handle *bind;
 	const int subc = (addr >> 13) & 0x7;
@@ -380,13 +385,13 @@ nv04_fifo_swmthd(struct nv04_fifo *fifo, u32 chid, u32 addr, u32 data)
 			chan->subc[subc] = data;
 			handled = true;
 
-			nv_mask(fifo, NV04_PFIFO_CACHE1_ENGINE, engine, 0);
+			nvkm_mask(device, NV04_PFIFO_CACHE1_ENGINE, engine, 0);
 		}
 
 		nvkm_namedb_put(bind);
 		break;
 	default:
-		engine = nv_rd32(fifo, NV04_PFIFO_CACHE1_ENGINE);
+		engine = nvkm_rd32(device, NV04_PFIFO_CACHE1_ENGINE);
 		if (unlikely(((engine >> (subc * 4)) & 0xf) != 0))
 			break;
 
@@ -419,11 +424,11 @@ nv04_fifo_cache_error(struct nvkm_device *device,
 	ptr = (get & 0x7ff) >> 2;
 
 	if (device->card_type < NV_40) {
-		mthd = nv_rd32(fifo, NV04_PFIFO_CACHE1_METHOD(ptr));
-		data = nv_rd32(fifo, NV04_PFIFO_CACHE1_DATA(ptr));
+		mthd = nvkm_rd32(device, NV04_PFIFO_CACHE1_METHOD(ptr));
+		data = nvkm_rd32(device, NV04_PFIFO_CACHE1_DATA(ptr));
 	} else {
-		mthd = nv_rd32(fifo, NV40_PFIFO_CACHE1_METHOD(ptr));
-		data = nv_rd32(fifo, NV40_PFIFO_CACHE1_DATA(ptr));
+		mthd = nvkm_rd32(device, NV40_PFIFO_CACHE1_METHOD(ptr));
+		data = nvkm_rd32(device, NV40_PFIFO_CACHE1_DATA(ptr));
 	}
 
 	if (!nv04_fifo_swmthd(fifo, chid, mthd, data)) {
@@ -435,19 +440,19 @@ nv04_fifo_cache_error(struct nvkm_device *device,
 			 data);
 	}
 
-	nv_wr32(fifo, NV04_PFIFO_CACHE1_DMA_PUSH, 0);
-	nv_wr32(fifo, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_CACHE_ERROR);
+	nvkm_wr32(device, NV04_PFIFO_CACHE1_DMA_PUSH, 0);
+	nvkm_wr32(device, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_CACHE_ERROR);
 
-	nv_wr32(fifo, NV03_PFIFO_CACHE1_PUSH0,
-		nv_rd32(fifo, NV03_PFIFO_CACHE1_PUSH0) & ~1);
-	nv_wr32(fifo, NV03_PFIFO_CACHE1_GET, get + 4);
-	nv_wr32(fifo, NV03_PFIFO_CACHE1_PUSH0,
-		nv_rd32(fifo, NV03_PFIFO_CACHE1_PUSH0) | 1);
-	nv_wr32(fifo, NV04_PFIFO_CACHE1_HASH, 0);
+	nvkm_wr32(device, NV03_PFIFO_CACHE1_PUSH0,
+		nvkm_rd32(device, NV03_PFIFO_CACHE1_PUSH0) & ~1);
+	nvkm_wr32(device, NV03_PFIFO_CACHE1_GET, get + 4);
+	nvkm_wr32(device, NV03_PFIFO_CACHE1_PUSH0,
+		nvkm_rd32(device, NV03_PFIFO_CACHE1_PUSH0) | 1);
+	nvkm_wr32(device, NV04_PFIFO_CACHE1_HASH, 0);
 
-	nv_wr32(fifo, NV04_PFIFO_CACHE1_DMA_PUSH,
-		nv_rd32(fifo, NV04_PFIFO_CACHE1_DMA_PUSH) | 1);
-	nv_wr32(fifo, NV04_PFIFO_CACHE1_PULL0, 1);
+	nvkm_wr32(device, NV04_PFIFO_CACHE1_DMA_PUSH,
+		nvkm_rd32(device, NV04_PFIFO_CACHE1_DMA_PUSH) | 1);
+	nvkm_wr32(device, NV04_PFIFO_CACHE1_PULL0, 1);
 }
 
 static void
@@ -455,18 +460,18 @@ nv04_fifo_dma_pusher(struct nvkm_device *device,
 		     struct nv04_fifo *fifo, u32 chid)
 {
 	const char *client_name;
-	u32 dma_get = nv_rd32(fifo, 0x003244);
-	u32 dma_put = nv_rd32(fifo, 0x003240);
-	u32 push = nv_rd32(fifo, 0x003220);
-	u32 state = nv_rd32(fifo, 0x003228);
+	u32 dma_get = nvkm_rd32(device, 0x003244);
+	u32 dma_put = nvkm_rd32(device, 0x003240);
+	u32 push = nvkm_rd32(device, 0x003220);
+	u32 state = nvkm_rd32(device, 0x003228);
 
 	client_name = nvkm_client_name_for_fifo_chid(&fifo->base, chid);
 
 	if (device->card_type == NV_50) {
-		u32 ho_get = nv_rd32(fifo, 0x003328);
-		u32 ho_put = nv_rd32(fifo, 0x003320);
-		u32 ib_get = nv_rd32(fifo, 0x003334);
-		u32 ib_put = nv_rd32(fifo, 0x003330);
+		u32 ho_get = nvkm_rd32(device, 0x003328);
+		u32 ho_put = nvkm_rd32(device, 0x003320);
+		u32 ib_get = nvkm_rd32(device, 0x003334);
+		u32 ib_put = nvkm_rd32(device, 0x003330);
 
 		nv_error(fifo,
 			 "DMA_PUSHER - ch %d [%s] get 0x%02x%08x put 0x%02x%08x ib_get 0x%08x ib_put 0x%08x state 0x%08x (err: %s) push 0x%08x\n",
@@ -474,13 +479,13 @@ nv04_fifo_dma_pusher(struct nvkm_device *device,
 			 ib_get, ib_put, state, nv_dma_state_err(state), push);
 
 		/* METHOD_COUNT, in DMA_STATE on earlier chipsets */
-		nv_wr32(fifo, 0x003364, 0x00000000);
+		nvkm_wr32(device, 0x003364, 0x00000000);
 		if (dma_get != dma_put || ho_get != ho_put) {
-			nv_wr32(fifo, 0x003244, dma_put);
-			nv_wr32(fifo, 0x003328, ho_put);
+			nvkm_wr32(device, 0x003244, dma_put);
+			nvkm_wr32(device, 0x003328, ho_put);
 		} else
 		if (ib_get != ib_put)
-			nv_wr32(fifo, 0x003334, ib_put);
+			nvkm_wr32(device, 0x003334, ib_put);
 	} else {
 		nv_error(fifo,
 			 "DMA_PUSHER - ch %d [%s] get 0x%08x put 0x%08x state 0x%08x (err: %s) push 0x%08x\n",
@@ -488,12 +493,12 @@ nv04_fifo_dma_pusher(struct nvkm_device *device,
 			 nv_dma_state_err(state), push);
 
 		if (dma_get != dma_put)
-			nv_wr32(fifo, 0x003244, dma_put);
+			nvkm_wr32(device, 0x003244, dma_put);
 	}
 
-	nv_wr32(fifo, 0x003228, 0x00000000);
-	nv_wr32(fifo, 0x003220, 0x00000001);
-	nv_wr32(fifo, 0x002100, NV_PFIFO_INTR_DMA_PUSHER);
+	nvkm_wr32(device, 0x003228, 0x00000000);
+	nvkm_wr32(device, 0x003220, 0x00000001);
+	nvkm_wr32(device, 0x002100, NV_PFIFO_INTR_DMA_PUSHER);
 }
 
 void
@@ -501,15 +506,15 @@ nv04_fifo_intr(struct nvkm_subdev *subdev)
 {
 	struct nvkm_device *device = nv_device(subdev);
 	struct nv04_fifo *fifo = (void *)subdev;
-	u32 mask = nv_rd32(fifo, NV03_PFIFO_INTR_EN_0);
-	u32 stat = nv_rd32(fifo, NV03_PFIFO_INTR_0) & mask;
+	u32 mask = nvkm_rd32(device, NV03_PFIFO_INTR_EN_0);
+	u32 stat = nvkm_rd32(device, NV03_PFIFO_INTR_0) & mask;
 	u32 reassign, chid, get, sem;
 
-	reassign = nv_rd32(fifo, NV03_PFIFO_CACHES) & 1;
-	nv_wr32(fifo, NV03_PFIFO_CACHES, 0);
+	reassign = nvkm_rd32(device, NV03_PFIFO_CACHES) & 1;
+	nvkm_wr32(device, NV03_PFIFO_CACHES, 0);
 
-	chid = nv_rd32(fifo, NV03_PFIFO_CACHE1_PUSH1) & fifo->base.max;
-	get  = nv_rd32(fifo, NV03_PFIFO_CACHE1_GET);
+	chid = nvkm_rd32(device, NV03_PFIFO_CACHE1_PUSH1) & fifo->base.max;
+	get  = nvkm_rd32(device, NV03_PFIFO_CACHE1_GET);
 
 	if (stat & NV_PFIFO_INTR_CACHE_ERROR) {
 		nv04_fifo_cache_error(device, fifo, chid, get);
@@ -523,23 +528,23 @@ nv04_fifo_intr(struct nvkm_subdev *subdev)
 
 	if (stat & NV_PFIFO_INTR_SEMAPHORE) {
 		stat &= ~NV_PFIFO_INTR_SEMAPHORE;
-		nv_wr32(fifo, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_SEMAPHORE);
+		nvkm_wr32(device, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_SEMAPHORE);
 
-		sem = nv_rd32(fifo, NV10_PFIFO_CACHE1_SEMAPHORE);
-		nv_wr32(fifo, NV10_PFIFO_CACHE1_SEMAPHORE, sem | 0x1);
+		sem = nvkm_rd32(device, NV10_PFIFO_CACHE1_SEMAPHORE);
+		nvkm_wr32(device, NV10_PFIFO_CACHE1_SEMAPHORE, sem | 0x1);
 
-		nv_wr32(fifo, NV03_PFIFO_CACHE1_GET, get + 4);
-		nv_wr32(fifo, NV04_PFIFO_CACHE1_PULL0, 1);
+		nvkm_wr32(device, NV03_PFIFO_CACHE1_GET, get + 4);
+		nvkm_wr32(device, NV04_PFIFO_CACHE1_PULL0, 1);
 	}
 
 	if (device->card_type == NV_50) {
 		if (stat & 0x00000010) {
 			stat &= ~0x00000010;
-			nv_wr32(fifo, 0x002100, 0x00000010);
+			nvkm_wr32(device, 0x002100, 0x00000010);
 		}
 
 		if (stat & 0x40000000) {
-			nv_wr32(fifo, 0x002100, 0x40000000);
+			nvkm_wr32(device, 0x002100, 0x40000000);
 			nvkm_fifo_uevent(&fifo->base);
 			stat &= ~0x40000000;
 		}
@@ -547,11 +552,11 @@ nv04_fifo_intr(struct nvkm_subdev *subdev)
 
 	if (stat) {
 		nv_warn(fifo, "unknown intr 0x%08x\n", stat);
-		nv_mask(fifo, NV03_PFIFO_INTR_EN_0, stat, 0x00000000);
-		nv_wr32(fifo, NV03_PFIFO_INTR_0, stat);
+		nvkm_mask(device, NV03_PFIFO_INTR_EN_0, stat, 0x00000000);
+		nvkm_wr32(device, NV03_PFIFO_INTR_0, stat);
 	}
 
-	nv_wr32(fifo, NV03_PFIFO_CACHES, reassign);
+	nvkm_wr32(device, NV03_PFIFO_CACHES, reassign);
 }
 
 static int
@@ -596,29 +601,30 @@ int
 nv04_fifo_init(struct nvkm_object *object)
 {
 	struct nv04_fifo *fifo = (void *)object;
+	struct nvkm_device *device = fifo->base.engine.subdev.device;
 	int ret;
 
 	ret = nvkm_fifo_init(&fifo->base);
 	if (ret)
 		return ret;
 
-	nv_wr32(fifo, NV04_PFIFO_DELAY_0, 0x000000ff);
-	nv_wr32(fifo, NV04_PFIFO_DMA_TIMESLICE, 0x0101ffff);
+	nvkm_wr32(device, NV04_PFIFO_DELAY_0, 0x000000ff);
+	nvkm_wr32(device, NV04_PFIFO_DMA_TIMESLICE, 0x0101ffff);
 
-	nv_wr32(fifo, NV03_PFIFO_RAMHT, (0x03 << 24) /* search 128 */ |
+	nvkm_wr32(device, NV03_PFIFO_RAMHT, (0x03 << 24) /* search 128 */ |
 				       ((fifo->ramht->bits - 9) << 16) |
 				        (fifo->ramht->gpuobj.addr >> 8));
-	nv_wr32(fifo, NV03_PFIFO_RAMRO, fifo->ramro->addr >> 8);
-	nv_wr32(fifo, NV03_PFIFO_RAMFC, fifo->ramfc->addr >> 8);
+	nvkm_wr32(device, NV03_PFIFO_RAMRO, fifo->ramro->addr >> 8);
+	nvkm_wr32(device, NV03_PFIFO_RAMFC, fifo->ramfc->addr >> 8);
 
-	nv_wr32(fifo, NV03_PFIFO_CACHE1_PUSH1, fifo->base.max);
+	nvkm_wr32(device, NV03_PFIFO_CACHE1_PUSH1, fifo->base.max);
 
-	nv_wr32(fifo, NV03_PFIFO_INTR_0, 0xffffffff);
-	nv_wr32(fifo, NV03_PFIFO_INTR_EN_0, 0xffffffff);
+	nvkm_wr32(device, NV03_PFIFO_INTR_0, 0xffffffff);
+	nvkm_wr32(device, NV03_PFIFO_INTR_EN_0, 0xffffffff);
 
-	nv_wr32(fifo, NV03_PFIFO_CACHE1_PUSH0, 1);
-	nv_wr32(fifo, NV04_PFIFO_CACHE1_PULL0, 1);
-	nv_wr32(fifo, NV03_PFIFO_CACHES, 1);
+	nvkm_wr32(device, NV03_PFIFO_CACHE1_PUSH0, 1);
+	nvkm_wr32(device, NV04_PFIFO_CACHE1_PULL0, 1);
+	nvkm_wr32(device, NV03_PFIFO_CACHES, 1);
 	return 0;
 }
 

commit 6189f1b0938dc0621c27494031b83ffae566e318
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/fifo: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index bdf635f9ab5f..91a2080bdaf9 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -54,7 +54,7 @@ int
 nv04_fifo_object_attach(struct nvkm_object *parent,
 			struct nvkm_object *object, u32 handle)
 {
-	struct nv04_fifo_priv *priv = (void *)parent->engine;
+	struct nv04_fifo *fifo = (void *)parent->engine;
 	struct nv04_fifo_chan *chan = (void *)parent;
 	u32 context, chid = chan->base.chid;
 	int ret;
@@ -82,19 +82,19 @@ nv04_fifo_object_attach(struct nvkm_object *parent,
 	context |= 0x80000000; /* valid */
 	context |= chid << 24;
 
-	mutex_lock(&nv_subdev(priv)->mutex);
-	ret = nvkm_ramht_insert(priv->ramht, chid, handle, context);
-	mutex_unlock(&nv_subdev(priv)->mutex);
+	mutex_lock(&nv_subdev(fifo)->mutex);
+	ret = nvkm_ramht_insert(fifo->ramht, chid, handle, context);
+	mutex_unlock(&nv_subdev(fifo)->mutex);
 	return ret;
 }
 
 void
 nv04_fifo_object_detach(struct nvkm_object *parent, int cookie)
 {
-	struct nv04_fifo_priv *priv = (void *)parent->engine;
-	mutex_lock(&nv_subdev(priv)->mutex);
-	nvkm_ramht_remove(priv->ramht, cookie);
-	mutex_unlock(&nv_subdev(priv)->mutex);
+	struct nv04_fifo *fifo = (void *)parent->engine;
+	mutex_lock(&nv_subdev(fifo)->mutex);
+	nvkm_ramht_remove(fifo->ramht, cookie);
+	mutex_unlock(&nv_subdev(fifo)->mutex);
 }
 
 int
@@ -114,7 +114,7 @@ nv04_fifo_chan_ctor(struct nvkm_object *parent,
 	union {
 		struct nv03_channel_dma_v0 v0;
 	} *args = data;
-	struct nv04_fifo_priv *priv = (void *)engine;
+	struct nv04_fifo *fifo = (void *)engine;
 	struct nv04_fifo_chan *chan;
 	int ret;
 
@@ -142,10 +142,10 @@ nv04_fifo_chan_ctor(struct nvkm_object *parent,
 	nv_parent(chan)->context_attach = nv04_fifo_context_attach;
 	chan->ramfc = chan->base.chid * 32;
 
-	nv_wo32(priv->ramfc, chan->ramfc + 0x00, args->v0.offset);
-	nv_wo32(priv->ramfc, chan->ramfc + 0x04, args->v0.offset);
-	nv_wo32(priv->ramfc, chan->ramfc + 0x08, chan->base.pushgpu->addr >> 4);
-	nv_wo32(priv->ramfc, chan->ramfc + 0x10,
+	nv_wo32(fifo->ramfc, chan->ramfc + 0x00, args->v0.offset);
+	nv_wo32(fifo->ramfc, chan->ramfc + 0x04, args->v0.offset);
+	nv_wo32(fifo->ramfc, chan->ramfc + 0x08, chan->base.pushgpu->addr >> 4);
+	nv_wo32(fifo->ramfc, chan->ramfc + 0x10,
 			     NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |
 			     NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |
 #ifdef __BIG_ENDIAN
@@ -158,12 +158,12 @@ nv04_fifo_chan_ctor(struct nvkm_object *parent,
 void
 nv04_fifo_chan_dtor(struct nvkm_object *object)
 {
-	struct nv04_fifo_priv *priv = (void *)object->engine;
+	struct nv04_fifo *fifo = (void *)object->engine;
 	struct nv04_fifo_chan *chan = (void *)object;
-	struct ramfc_desc *c = priv->ramfc_desc;
+	struct ramfc_desc *c = fifo->ramfc_desc;
 
 	do {
-		nv_wo32(priv->ramfc, chan->ramfc + c->ctxp, 0x00000000);
+		nv_wo32(fifo->ramfc, chan->ramfc + c->ctxp, 0x00000000);
 	} while ((++c)->bits);
 
 	nvkm_fifo_channel_destroy(&chan->base);
@@ -172,7 +172,7 @@ nv04_fifo_chan_dtor(struct nvkm_object *object)
 int
 nv04_fifo_chan_init(struct nvkm_object *object)
 {
-	struct nv04_fifo_priv *priv = (void *)object->engine;
+	struct nv04_fifo *fifo = (void *)object->engine;
 	struct nv04_fifo_chan *chan = (void *)object;
 	u32 mask = 1 << chan->base.chid;
 	unsigned long flags;
@@ -182,59 +182,59 @@ nv04_fifo_chan_init(struct nvkm_object *object)
 	if (ret)
 		return ret;
 
-	spin_lock_irqsave(&priv->base.lock, flags);
-	nv_mask(priv, NV04_PFIFO_MODE, mask, mask);
-	spin_unlock_irqrestore(&priv->base.lock, flags);
+	spin_lock_irqsave(&fifo->base.lock, flags);
+	nv_mask(fifo, NV04_PFIFO_MODE, mask, mask);
+	spin_unlock_irqrestore(&fifo->base.lock, flags);
 	return 0;
 }
 
 int
 nv04_fifo_chan_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nv04_fifo_priv *priv = (void *)object->engine;
+	struct nv04_fifo *fifo = (void *)object->engine;
 	struct nv04_fifo_chan *chan = (void *)object;
-	struct nvkm_gpuobj *fctx = priv->ramfc;
+	struct nvkm_gpuobj *fctx = fifo->ramfc;
 	struct ramfc_desc *c;
 	unsigned long flags;
 	u32 data = chan->ramfc;
 	u32 chid;
 
 	/* prevent fifo context switches */
-	spin_lock_irqsave(&priv->base.lock, flags);
-	nv_wr32(priv, NV03_PFIFO_CACHES, 0);
+	spin_lock_irqsave(&fifo->base.lock, flags);
+	nv_wr32(fifo, NV03_PFIFO_CACHES, 0);
 
 	/* if this channel is active, replace it with a null context */
-	chid = nv_rd32(priv, NV03_PFIFO_CACHE1_PUSH1) & priv->base.max;
+	chid = nv_rd32(fifo, NV03_PFIFO_CACHE1_PUSH1) & fifo->base.max;
 	if (chid == chan->base.chid) {
-		nv_mask(priv, NV04_PFIFO_CACHE1_DMA_PUSH, 0x00000001, 0);
-		nv_wr32(priv, NV03_PFIFO_CACHE1_PUSH0, 0);
-		nv_mask(priv, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0);
+		nv_mask(fifo, NV04_PFIFO_CACHE1_DMA_PUSH, 0x00000001, 0);
+		nv_wr32(fifo, NV03_PFIFO_CACHE1_PUSH0, 0);
+		nv_mask(fifo, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0);
 
-		c = priv->ramfc_desc;
+		c = fifo->ramfc_desc;
 		do {
 			u32 rm = ((1ULL << c->bits) - 1) << c->regs;
 			u32 cm = ((1ULL << c->bits) - 1) << c->ctxs;
-			u32 rv = (nv_rd32(priv, c->regp) &  rm) >> c->regs;
+			u32 rv = (nv_rd32(fifo, c->regp) &  rm) >> c->regs;
 			u32 cv = (nv_ro32(fctx, c->ctxp + data) & ~cm);
 			nv_wo32(fctx, c->ctxp + data, cv | (rv << c->ctxs));
 		} while ((++c)->bits);
 
-		c = priv->ramfc_desc;
+		c = fifo->ramfc_desc;
 		do {
-			nv_wr32(priv, c->regp, 0x00000000);
+			nv_wr32(fifo, c->regp, 0x00000000);
 		} while ((++c)->bits);
 
-		nv_wr32(priv, NV03_PFIFO_CACHE1_GET, 0);
-		nv_wr32(priv, NV03_PFIFO_CACHE1_PUT, 0);
-		nv_wr32(priv, NV03_PFIFO_CACHE1_PUSH1, priv->base.max);
-		nv_wr32(priv, NV03_PFIFO_CACHE1_PUSH0, 1);
-		nv_wr32(priv, NV04_PFIFO_CACHE1_PULL0, 1);
+		nv_wr32(fifo, NV03_PFIFO_CACHE1_GET, 0);
+		nv_wr32(fifo, NV03_PFIFO_CACHE1_PUT, 0);
+		nv_wr32(fifo, NV03_PFIFO_CACHE1_PUSH1, fifo->base.max);
+		nv_wr32(fifo, NV03_PFIFO_CACHE1_PUSH0, 1);
+		nv_wr32(fifo, NV04_PFIFO_CACHE1_PULL0, 1);
 	}
 
 	/* restore normal operation, after disabling dma mode */
-	nv_mask(priv, NV04_PFIFO_MODE, 1 << chan->base.chid, 0);
-	nv_wr32(priv, NV03_PFIFO_CACHES, 1);
-	spin_unlock_irqrestore(&priv->base.lock, flags);
+	nv_mask(fifo, NV04_PFIFO_MODE, 1 << chan->base.chid, 0);
+	nv_wr32(fifo, NV03_PFIFO_CACHES, 1);
+	spin_unlock_irqrestore(&fifo->base.lock, flags);
 
 	return nvkm_fifo_channel_fini(&chan->base, suspend);
 }
@@ -297,17 +297,17 @@ nv04_fifo_cclass = {
  ******************************************************************************/
 
 void
-nv04_fifo_pause(struct nvkm_fifo *pfifo, unsigned long *pflags)
-__acquires(priv->base.lock)
+nv04_fifo_pause(struct nvkm_fifo *obj, unsigned long *pflags)
+__acquires(fifo->base.lock)
 {
-	struct nv04_fifo_priv *priv = (void *)pfifo;
+	struct nv04_fifo *fifo = container_of(obj, typeof(*fifo), base);
 	unsigned long flags;
 
-	spin_lock_irqsave(&priv->base.lock, flags);
+	spin_lock_irqsave(&fifo->base.lock, flags);
 	*pflags = flags;
 
-	nv_wr32(priv, NV03_PFIFO_CACHES, 0x00000000);
-	nv_mask(priv, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0x00000000);
+	nv_wr32(fifo, NV03_PFIFO_CACHES, 0x00000000);
+	nv_mask(fifo, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0x00000000);
 
 	/* in some cases the puller may be left in an inconsistent state
 	 * if you try to stop it while it's busy translating handles.
@@ -318,28 +318,28 @@ __acquires(priv->base.lock)
 	 * to avoid this, we invalidate the most recently calculated
 	 * instance.
 	 */
-	if (!nv_wait(priv, NV04_PFIFO_CACHE1_PULL0,
+	if (!nv_wait(fifo, NV04_PFIFO_CACHE1_PULL0,
 			   NV04_PFIFO_CACHE1_PULL0_HASH_BUSY, 0x00000000))
-		nv_warn(priv, "timeout idling puller\n");
+		nv_warn(fifo, "timeout idling puller\n");
 
-	if (nv_rd32(priv, NV04_PFIFO_CACHE1_PULL0) &
+	if (nv_rd32(fifo, NV04_PFIFO_CACHE1_PULL0) &
 			  NV04_PFIFO_CACHE1_PULL0_HASH_FAILED)
-		nv_wr32(priv, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_CACHE_ERROR);
+		nv_wr32(fifo, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_CACHE_ERROR);
 
-	nv_wr32(priv, NV04_PFIFO_CACHE1_HASH, 0x00000000);
+	nv_wr32(fifo, NV04_PFIFO_CACHE1_HASH, 0x00000000);
 }
 
 void
-nv04_fifo_start(struct nvkm_fifo *pfifo, unsigned long *pflags)
-__releases(priv->base.lock)
+nv04_fifo_start(struct nvkm_fifo *obj, unsigned long *pflags)
+__releases(fifo->base.lock)
 {
-	struct nv04_fifo_priv *priv = (void *)pfifo;
+	struct nv04_fifo *fifo = container_of(obj, typeof(*fifo), base);
 	unsigned long flags = *pflags;
 
-	nv_mask(priv, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0x00000001);
-	nv_wr32(priv, NV03_PFIFO_CACHES, 0x00000001);
+	nv_mask(fifo, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0x00000001);
+	nv_wr32(fifo, NV03_PFIFO_CACHES, 0x00000001);
 
-	spin_unlock_irqrestore(&priv->base.lock, flags);
+	spin_unlock_irqrestore(&fifo->base.lock, flags);
 }
 
 static const char *
@@ -353,7 +353,7 @@ nv_dma_state_err(u32 state)
 }
 
 static bool
-nv04_fifo_swmthd(struct nv04_fifo_priv *priv, u32 chid, u32 addr, u32 data)
+nv04_fifo_swmthd(struct nv04_fifo *fifo, u32 chid, u32 addr, u32 data)
 {
 	struct nv04_fifo_chan *chan = NULL;
 	struct nvkm_handle *bind;
@@ -363,9 +363,9 @@ nv04_fifo_swmthd(struct nv04_fifo_priv *priv, u32 chid, u32 addr, u32 data)
 	unsigned long flags;
 	u32 engine;
 
-	spin_lock_irqsave(&priv->base.lock, flags);
-	if (likely(chid >= priv->base.min && chid <= priv->base.max))
-		chan = (void *)priv->base.channel[chid];
+	spin_lock_irqsave(&fifo->base.lock, flags);
+	if (likely(chid >= fifo->base.min && chid <= fifo->base.max))
+		chan = (void *)fifo->base.channel[chid];
 	if (unlikely(!chan))
 		goto out;
 
@@ -380,13 +380,13 @@ nv04_fifo_swmthd(struct nv04_fifo_priv *priv, u32 chid, u32 addr, u32 data)
 			chan->subc[subc] = data;
 			handled = true;
 
-			nv_mask(priv, NV04_PFIFO_CACHE1_ENGINE, engine, 0);
+			nv_mask(fifo, NV04_PFIFO_CACHE1_ENGINE, engine, 0);
 		}
 
 		nvkm_namedb_put(bind);
 		break;
 	default:
-		engine = nv_rd32(priv, NV04_PFIFO_CACHE1_ENGINE);
+		engine = nv_rd32(fifo, NV04_PFIFO_CACHE1_ENGINE);
 		if (unlikely(((engine >> (subc * 4)) & 0xf) != 0))
 			break;
 
@@ -400,13 +400,13 @@ nv04_fifo_swmthd(struct nv04_fifo_priv *priv, u32 chid, u32 addr, u32 data)
 	}
 
 out:
-	spin_unlock_irqrestore(&priv->base.lock, flags);
+	spin_unlock_irqrestore(&fifo->base.lock, flags);
 	return handled;
 }
 
 static void
 nv04_fifo_cache_error(struct nvkm_device *device,
-		      struct nv04_fifo_priv *priv, u32 chid, u32 get)
+		      struct nv04_fifo *fifo, u32 chid, u32 get)
 {
 	u32 mthd, data;
 	int ptr;
@@ -419,139 +419,139 @@ nv04_fifo_cache_error(struct nvkm_device *device,
 	ptr = (get & 0x7ff) >> 2;
 
 	if (device->card_type < NV_40) {
-		mthd = nv_rd32(priv, NV04_PFIFO_CACHE1_METHOD(ptr));
-		data = nv_rd32(priv, NV04_PFIFO_CACHE1_DATA(ptr));
+		mthd = nv_rd32(fifo, NV04_PFIFO_CACHE1_METHOD(ptr));
+		data = nv_rd32(fifo, NV04_PFIFO_CACHE1_DATA(ptr));
 	} else {
-		mthd = nv_rd32(priv, NV40_PFIFO_CACHE1_METHOD(ptr));
-		data = nv_rd32(priv, NV40_PFIFO_CACHE1_DATA(ptr));
+		mthd = nv_rd32(fifo, NV40_PFIFO_CACHE1_METHOD(ptr));
+		data = nv_rd32(fifo, NV40_PFIFO_CACHE1_DATA(ptr));
 	}
 
-	if (!nv04_fifo_swmthd(priv, chid, mthd, data)) {
+	if (!nv04_fifo_swmthd(fifo, chid, mthd, data)) {
 		const char *client_name =
-			nvkm_client_name_for_fifo_chid(&priv->base, chid);
-		nv_error(priv,
+			nvkm_client_name_for_fifo_chid(&fifo->base, chid);
+		nv_error(fifo,
 			 "CACHE_ERROR - ch %d [%s] subc %d mthd 0x%04x data 0x%08x\n",
 			 chid, client_name, (mthd >> 13) & 7, mthd & 0x1ffc,
 			 data);
 	}
 
-	nv_wr32(priv, NV04_PFIFO_CACHE1_DMA_PUSH, 0);
-	nv_wr32(priv, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_CACHE_ERROR);
+	nv_wr32(fifo, NV04_PFIFO_CACHE1_DMA_PUSH, 0);
+	nv_wr32(fifo, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_CACHE_ERROR);
 
-	nv_wr32(priv, NV03_PFIFO_CACHE1_PUSH0,
-		nv_rd32(priv, NV03_PFIFO_CACHE1_PUSH0) & ~1);
-	nv_wr32(priv, NV03_PFIFO_CACHE1_GET, get + 4);
-	nv_wr32(priv, NV03_PFIFO_CACHE1_PUSH0,
-		nv_rd32(priv, NV03_PFIFO_CACHE1_PUSH0) | 1);
-	nv_wr32(priv, NV04_PFIFO_CACHE1_HASH, 0);
+	nv_wr32(fifo, NV03_PFIFO_CACHE1_PUSH0,
+		nv_rd32(fifo, NV03_PFIFO_CACHE1_PUSH0) & ~1);
+	nv_wr32(fifo, NV03_PFIFO_CACHE1_GET, get + 4);
+	nv_wr32(fifo, NV03_PFIFO_CACHE1_PUSH0,
+		nv_rd32(fifo, NV03_PFIFO_CACHE1_PUSH0) | 1);
+	nv_wr32(fifo, NV04_PFIFO_CACHE1_HASH, 0);
 
-	nv_wr32(priv, NV04_PFIFO_CACHE1_DMA_PUSH,
-		nv_rd32(priv, NV04_PFIFO_CACHE1_DMA_PUSH) | 1);
-	nv_wr32(priv, NV04_PFIFO_CACHE1_PULL0, 1);
+	nv_wr32(fifo, NV04_PFIFO_CACHE1_DMA_PUSH,
+		nv_rd32(fifo, NV04_PFIFO_CACHE1_DMA_PUSH) | 1);
+	nv_wr32(fifo, NV04_PFIFO_CACHE1_PULL0, 1);
 }
 
 static void
 nv04_fifo_dma_pusher(struct nvkm_device *device,
-		     struct nv04_fifo_priv *priv, u32 chid)
+		     struct nv04_fifo *fifo, u32 chid)
 {
 	const char *client_name;
-	u32 dma_get = nv_rd32(priv, 0x003244);
-	u32 dma_put = nv_rd32(priv, 0x003240);
-	u32 push = nv_rd32(priv, 0x003220);
-	u32 state = nv_rd32(priv, 0x003228);
+	u32 dma_get = nv_rd32(fifo, 0x003244);
+	u32 dma_put = nv_rd32(fifo, 0x003240);
+	u32 push = nv_rd32(fifo, 0x003220);
+	u32 state = nv_rd32(fifo, 0x003228);
 
-	client_name = nvkm_client_name_for_fifo_chid(&priv->base, chid);
+	client_name = nvkm_client_name_for_fifo_chid(&fifo->base, chid);
 
 	if (device->card_type == NV_50) {
-		u32 ho_get = nv_rd32(priv, 0x003328);
-		u32 ho_put = nv_rd32(priv, 0x003320);
-		u32 ib_get = nv_rd32(priv, 0x003334);
-		u32 ib_put = nv_rd32(priv, 0x003330);
+		u32 ho_get = nv_rd32(fifo, 0x003328);
+		u32 ho_put = nv_rd32(fifo, 0x003320);
+		u32 ib_get = nv_rd32(fifo, 0x003334);
+		u32 ib_put = nv_rd32(fifo, 0x003330);
 
-		nv_error(priv,
+		nv_error(fifo,
 			 "DMA_PUSHER - ch %d [%s] get 0x%02x%08x put 0x%02x%08x ib_get 0x%08x ib_put 0x%08x state 0x%08x (err: %s) push 0x%08x\n",
 			 chid, client_name, ho_get, dma_get, ho_put, dma_put,
 			 ib_get, ib_put, state, nv_dma_state_err(state), push);
 
 		/* METHOD_COUNT, in DMA_STATE on earlier chipsets */
-		nv_wr32(priv, 0x003364, 0x00000000);
+		nv_wr32(fifo, 0x003364, 0x00000000);
 		if (dma_get != dma_put || ho_get != ho_put) {
-			nv_wr32(priv, 0x003244, dma_put);
-			nv_wr32(priv, 0x003328, ho_put);
+			nv_wr32(fifo, 0x003244, dma_put);
+			nv_wr32(fifo, 0x003328, ho_put);
 		} else
 		if (ib_get != ib_put)
-			nv_wr32(priv, 0x003334, ib_put);
+			nv_wr32(fifo, 0x003334, ib_put);
 	} else {
-		nv_error(priv,
+		nv_error(fifo,
 			 "DMA_PUSHER - ch %d [%s] get 0x%08x put 0x%08x state 0x%08x (err: %s) push 0x%08x\n",
 			 chid, client_name, dma_get, dma_put, state,
 			 nv_dma_state_err(state), push);
 
 		if (dma_get != dma_put)
-			nv_wr32(priv, 0x003244, dma_put);
+			nv_wr32(fifo, 0x003244, dma_put);
 	}
 
-	nv_wr32(priv, 0x003228, 0x00000000);
-	nv_wr32(priv, 0x003220, 0x00000001);
-	nv_wr32(priv, 0x002100, NV_PFIFO_INTR_DMA_PUSHER);
+	nv_wr32(fifo, 0x003228, 0x00000000);
+	nv_wr32(fifo, 0x003220, 0x00000001);
+	nv_wr32(fifo, 0x002100, NV_PFIFO_INTR_DMA_PUSHER);
 }
 
 void
 nv04_fifo_intr(struct nvkm_subdev *subdev)
 {
 	struct nvkm_device *device = nv_device(subdev);
-	struct nv04_fifo_priv *priv = (void *)subdev;
-	u32 mask = nv_rd32(priv, NV03_PFIFO_INTR_EN_0);
-	u32 stat = nv_rd32(priv, NV03_PFIFO_INTR_0) & mask;
+	struct nv04_fifo *fifo = (void *)subdev;
+	u32 mask = nv_rd32(fifo, NV03_PFIFO_INTR_EN_0);
+	u32 stat = nv_rd32(fifo, NV03_PFIFO_INTR_0) & mask;
 	u32 reassign, chid, get, sem;
 
-	reassign = nv_rd32(priv, NV03_PFIFO_CACHES) & 1;
-	nv_wr32(priv, NV03_PFIFO_CACHES, 0);
+	reassign = nv_rd32(fifo, NV03_PFIFO_CACHES) & 1;
+	nv_wr32(fifo, NV03_PFIFO_CACHES, 0);
 
-	chid = nv_rd32(priv, NV03_PFIFO_CACHE1_PUSH1) & priv->base.max;
-	get  = nv_rd32(priv, NV03_PFIFO_CACHE1_GET);
+	chid = nv_rd32(fifo, NV03_PFIFO_CACHE1_PUSH1) & fifo->base.max;
+	get  = nv_rd32(fifo, NV03_PFIFO_CACHE1_GET);
 
 	if (stat & NV_PFIFO_INTR_CACHE_ERROR) {
-		nv04_fifo_cache_error(device, priv, chid, get);
+		nv04_fifo_cache_error(device, fifo, chid, get);
 		stat &= ~NV_PFIFO_INTR_CACHE_ERROR;
 	}
 
 	if (stat & NV_PFIFO_INTR_DMA_PUSHER) {
-		nv04_fifo_dma_pusher(device, priv, chid);
+		nv04_fifo_dma_pusher(device, fifo, chid);
 		stat &= ~NV_PFIFO_INTR_DMA_PUSHER;
 	}
 
 	if (stat & NV_PFIFO_INTR_SEMAPHORE) {
 		stat &= ~NV_PFIFO_INTR_SEMAPHORE;
-		nv_wr32(priv, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_SEMAPHORE);
+		nv_wr32(fifo, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_SEMAPHORE);
 
-		sem = nv_rd32(priv, NV10_PFIFO_CACHE1_SEMAPHORE);
-		nv_wr32(priv, NV10_PFIFO_CACHE1_SEMAPHORE, sem | 0x1);
+		sem = nv_rd32(fifo, NV10_PFIFO_CACHE1_SEMAPHORE);
+		nv_wr32(fifo, NV10_PFIFO_CACHE1_SEMAPHORE, sem | 0x1);
 
-		nv_wr32(priv, NV03_PFIFO_CACHE1_GET, get + 4);
-		nv_wr32(priv, NV04_PFIFO_CACHE1_PULL0, 1);
+		nv_wr32(fifo, NV03_PFIFO_CACHE1_GET, get + 4);
+		nv_wr32(fifo, NV04_PFIFO_CACHE1_PULL0, 1);
 	}
 
 	if (device->card_type == NV_50) {
 		if (stat & 0x00000010) {
 			stat &= ~0x00000010;
-			nv_wr32(priv, 0x002100, 0x00000010);
+			nv_wr32(fifo, 0x002100, 0x00000010);
 		}
 
 		if (stat & 0x40000000) {
-			nv_wr32(priv, 0x002100, 0x40000000);
-			nvkm_fifo_uevent(&priv->base);
+			nv_wr32(fifo, 0x002100, 0x40000000);
+			nvkm_fifo_uevent(&fifo->base);
 			stat &= ~0x40000000;
 		}
 	}
 
 	if (stat) {
-		nv_warn(priv, "unknown intr 0x%08x\n", stat);
-		nv_mask(priv, NV03_PFIFO_INTR_EN_0, stat, 0x00000000);
-		nv_wr32(priv, NV03_PFIFO_INTR_0, stat);
+		nv_warn(fifo, "unknown intr 0x%08x\n", stat);
+		nv_mask(fifo, NV03_PFIFO_INTR_EN_0, stat, 0x00000000);
+		nv_wr32(fifo, NV03_PFIFO_INTR_0, stat);
 	}
 
-	nv_wr32(priv, NV03_PFIFO_CACHES, reassign);
+	nv_wr32(fifo, NV03_PFIFO_CACHES, reassign);
 }
 
 static int
@@ -560,65 +560,65 @@ nv04_fifo_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_object **pobject)
 {
 	struct nv04_instmem *imem = nv04_instmem(parent);
-	struct nv04_fifo_priv *priv;
+	struct nv04_fifo *fifo;
 	int ret;
 
-	ret = nvkm_fifo_create(parent, engine, oclass, 0, 15, &priv);
-	*pobject = nv_object(priv);
+	ret = nvkm_fifo_create(parent, engine, oclass, 0, 15, &fifo);
+	*pobject = nv_object(fifo);
 	if (ret)
 		return ret;
 
-	nvkm_ramht_ref(imem->ramht, &priv->ramht);
-	nvkm_gpuobj_ref(imem->ramro, &priv->ramro);
-	nvkm_gpuobj_ref(imem->ramfc, &priv->ramfc);
-
-	nv_subdev(priv)->unit = 0x00000100;
-	nv_subdev(priv)->intr = nv04_fifo_intr;
-	nv_engine(priv)->cclass = &nv04_fifo_cclass;
-	nv_engine(priv)->sclass = nv04_fifo_sclass;
-	priv->base.pause = nv04_fifo_pause;
-	priv->base.start = nv04_fifo_start;
-	priv->ramfc_desc = nv04_ramfc;
+	nvkm_ramht_ref(imem->ramht, &fifo->ramht);
+	nvkm_gpuobj_ref(imem->ramro, &fifo->ramro);
+	nvkm_gpuobj_ref(imem->ramfc, &fifo->ramfc);
+
+	nv_subdev(fifo)->unit = 0x00000100;
+	nv_subdev(fifo)->intr = nv04_fifo_intr;
+	nv_engine(fifo)->cclass = &nv04_fifo_cclass;
+	nv_engine(fifo)->sclass = nv04_fifo_sclass;
+	fifo->base.pause = nv04_fifo_pause;
+	fifo->base.start = nv04_fifo_start;
+	fifo->ramfc_desc = nv04_ramfc;
 	return 0;
 }
 
 void
 nv04_fifo_dtor(struct nvkm_object *object)
 {
-	struct nv04_fifo_priv *priv = (void *)object;
-	nvkm_gpuobj_ref(NULL, &priv->ramfc);
-	nvkm_gpuobj_ref(NULL, &priv->ramro);
-	nvkm_ramht_ref(NULL, &priv->ramht);
-	nvkm_fifo_destroy(&priv->base);
+	struct nv04_fifo *fifo = (void *)object;
+	nvkm_gpuobj_ref(NULL, &fifo->ramfc);
+	nvkm_gpuobj_ref(NULL, &fifo->ramro);
+	nvkm_ramht_ref(NULL, &fifo->ramht);
+	nvkm_fifo_destroy(&fifo->base);
 }
 
 int
 nv04_fifo_init(struct nvkm_object *object)
 {
-	struct nv04_fifo_priv *priv = (void *)object;
+	struct nv04_fifo *fifo = (void *)object;
 	int ret;
 
-	ret = nvkm_fifo_init(&priv->base);
+	ret = nvkm_fifo_init(&fifo->base);
 	if (ret)
 		return ret;
 
-	nv_wr32(priv, NV04_PFIFO_DELAY_0, 0x000000ff);
-	nv_wr32(priv, NV04_PFIFO_DMA_TIMESLICE, 0x0101ffff);
+	nv_wr32(fifo, NV04_PFIFO_DELAY_0, 0x000000ff);
+	nv_wr32(fifo, NV04_PFIFO_DMA_TIMESLICE, 0x0101ffff);
 
-	nv_wr32(priv, NV03_PFIFO_RAMHT, (0x03 << 24) /* search 128 */ |
-				       ((priv->ramht->bits - 9) << 16) |
-				        (priv->ramht->gpuobj.addr >> 8));
-	nv_wr32(priv, NV03_PFIFO_RAMRO, priv->ramro->addr >> 8);
-	nv_wr32(priv, NV03_PFIFO_RAMFC, priv->ramfc->addr >> 8);
+	nv_wr32(fifo, NV03_PFIFO_RAMHT, (0x03 << 24) /* search 128 */ |
+				       ((fifo->ramht->bits - 9) << 16) |
+				        (fifo->ramht->gpuobj.addr >> 8));
+	nv_wr32(fifo, NV03_PFIFO_RAMRO, fifo->ramro->addr >> 8);
+	nv_wr32(fifo, NV03_PFIFO_RAMFC, fifo->ramfc->addr >> 8);
 
-	nv_wr32(priv, NV03_PFIFO_CACHE1_PUSH1, priv->base.max);
+	nv_wr32(fifo, NV03_PFIFO_CACHE1_PUSH1, fifo->base.max);
 
-	nv_wr32(priv, NV03_PFIFO_INTR_0, 0xffffffff);
-	nv_wr32(priv, NV03_PFIFO_INTR_EN_0, 0xffffffff);
+	nv_wr32(fifo, NV03_PFIFO_INTR_0, 0xffffffff);
+	nv_wr32(fifo, NV03_PFIFO_INTR_EN_0, 0xffffffff);
 
-	nv_wr32(priv, NV03_PFIFO_CACHE1_PUSH0, 1);
-	nv_wr32(priv, NV04_PFIFO_CACHE1_PULL0, 1);
-	nv_wr32(priv, NV03_PFIFO_CACHES, 1);
+	nv_wr32(fifo, NV03_PFIFO_CACHE1_PUSH0, 1);
+	nv_wr32(fifo, NV04_PFIFO_CACHE1_PULL0, 1);
+	nv_wr32(fifo, NV03_PFIFO_CACHES, 1);
 	return 0;
 }
 

commit c44c06aeebf481fb69c665a21090f2f0aac878c5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/imem: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index d157aaede405..bdf635f9ab5f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -559,7 +559,7 @@ nv04_fifo_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_oclass *oclass, void *data, u32 size,
 	       struct nvkm_object **pobject)
 {
-	struct nv04_instmem_priv *imem = nv04_instmem(parent);
+	struct nv04_instmem *imem = nv04_instmem(parent);
 	struct nv04_fifo_priv *priv;
 	int ret;
 

commit 9ace404b1098221021b01c2ba0eeea0c257fa4a5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/device: include core/device.h automatically for subdevs/engines
    
    Pretty much every subdev/engine is going to need access to nvkm_device
    shortly to touch registers and/or output messages.
    
    The odd placement of the includes is necessary to work around some
    inter-dependencies that currently exist.  This will be fixed later.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index 043e4296084c..d157aaede405 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -24,7 +24,6 @@
 #include "nv04.h"
 
 #include <core/client.h>
-#include <core/device.h>
 #include <core/engctx.h>
 #include <core/handle.h>
 #include <core/ramht.h>

commit adc346b133c952ec6988d90f6fa79cbe0a3eb7ef
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 27 15:09:39 2015 +1000

    drm/nouveau/fifo/nv04: remove the loop from the interrupt handler
    
    Complete bong hit (and not the last...), the hardware will reassert the
    interrupt to PMC if it's necessary.
    
    Also potentially harmful in the face of interrupts such as the non-stall
    interrupt, which remain active in NV_PFIFO_INTR even when we don't care
    about servicing it.
    
    It appears (hopefully, fdo#87244), that under certain loads, the methods
    may pass quickly enough to hit the "100 spins and kill PFIFO" thing that
    we had going on.  Not ideal ;)
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index b038b6eb51db..043e4296084c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -502,72 +502,57 @@ nv04_fifo_intr(struct nvkm_subdev *subdev)
 {
 	struct nvkm_device *device = nv_device(subdev);
 	struct nv04_fifo_priv *priv = (void *)subdev;
-	uint32_t status, reassign;
-	int cnt = 0;
+	u32 mask = nv_rd32(priv, NV03_PFIFO_INTR_EN_0);
+	u32 stat = nv_rd32(priv, NV03_PFIFO_INTR_0) & mask;
+	u32 reassign, chid, get, sem;
 
 	reassign = nv_rd32(priv, NV03_PFIFO_CACHES) & 1;
-	while ((status = nv_rd32(priv, NV03_PFIFO_INTR_0)) && (cnt++ < 100)) {
-		uint32_t chid, get;
-
-		nv_wr32(priv, NV03_PFIFO_CACHES, 0);
-
-		chid = nv_rd32(priv, NV03_PFIFO_CACHE1_PUSH1) & priv->base.max;
-		get  = nv_rd32(priv, NV03_PFIFO_CACHE1_GET);
+	nv_wr32(priv, NV03_PFIFO_CACHES, 0);
 
-		if (status & NV_PFIFO_INTR_CACHE_ERROR) {
-			nv04_fifo_cache_error(device, priv, chid, get);
-			status &= ~NV_PFIFO_INTR_CACHE_ERROR;
-		}
+	chid = nv_rd32(priv, NV03_PFIFO_CACHE1_PUSH1) & priv->base.max;
+	get  = nv_rd32(priv, NV03_PFIFO_CACHE1_GET);
 
-		if (status & NV_PFIFO_INTR_DMA_PUSHER) {
-			nv04_fifo_dma_pusher(device, priv, chid);
-			status &= ~NV_PFIFO_INTR_DMA_PUSHER;
-		}
+	if (stat & NV_PFIFO_INTR_CACHE_ERROR) {
+		nv04_fifo_cache_error(device, priv, chid, get);
+		stat &= ~NV_PFIFO_INTR_CACHE_ERROR;
+	}
 
-		if (status & NV_PFIFO_INTR_SEMAPHORE) {
-			uint32_t sem;
+	if (stat & NV_PFIFO_INTR_DMA_PUSHER) {
+		nv04_fifo_dma_pusher(device, priv, chid);
+		stat &= ~NV_PFIFO_INTR_DMA_PUSHER;
+	}
 
-			status &= ~NV_PFIFO_INTR_SEMAPHORE;
-			nv_wr32(priv, NV03_PFIFO_INTR_0,
-				NV_PFIFO_INTR_SEMAPHORE);
+	if (stat & NV_PFIFO_INTR_SEMAPHORE) {
+		stat &= ~NV_PFIFO_INTR_SEMAPHORE;
+		nv_wr32(priv, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_SEMAPHORE);
 
-			sem = nv_rd32(priv, NV10_PFIFO_CACHE1_SEMAPHORE);
-			nv_wr32(priv, NV10_PFIFO_CACHE1_SEMAPHORE, sem | 0x1);
+		sem = nv_rd32(priv, NV10_PFIFO_CACHE1_SEMAPHORE);
+		nv_wr32(priv, NV10_PFIFO_CACHE1_SEMAPHORE, sem | 0x1);
 
-			nv_wr32(priv, NV03_PFIFO_CACHE1_GET, get + 4);
-			nv_wr32(priv, NV04_PFIFO_CACHE1_PULL0, 1);
-		}
+		nv_wr32(priv, NV03_PFIFO_CACHE1_GET, get + 4);
+		nv_wr32(priv, NV04_PFIFO_CACHE1_PULL0, 1);
+	}
 
-		if (device->card_type == NV_50) {
-			if (status & 0x00000010) {
-				status &= ~0x00000010;
-				nv_wr32(priv, 0x002100, 0x00000010);
-			}
-
-			if (status & 0x40000000) {
-				nv_wr32(priv, 0x002100, 0x40000000);
-				nvkm_fifo_uevent(&priv->base);
-				status &= ~0x40000000;
-			}
+	if (device->card_type == NV_50) {
+		if (stat & 0x00000010) {
+			stat &= ~0x00000010;
+			nv_wr32(priv, 0x002100, 0x00000010);
 		}
 
-		if (status) {
-			nv_warn(priv, "unknown intr 0x%08x, ch %d\n",
-				status, chid);
-			nv_wr32(priv, NV03_PFIFO_INTR_0, status);
-			status = 0;
+		if (stat & 0x40000000) {
+			nv_wr32(priv, 0x002100, 0x40000000);
+			nvkm_fifo_uevent(&priv->base);
+			stat &= ~0x40000000;
 		}
-
-		nv_wr32(priv, NV03_PFIFO_CACHES, reassign);
 	}
 
-	if (status) {
-		nv_error(priv, "still angry after %d spins, halt\n", cnt);
-		nv_wr32(priv, 0x002140, 0);
-		nv_wr32(priv, 0x000140, 0);
+	if (stat) {
+		nv_warn(priv, "unknown intr 0x%08x\n", stat);
+		nv_mask(priv, NV03_PFIFO_INTR_EN_0, stat, 0x00000000);
+		nv_wr32(priv, NV03_PFIFO_INTR_0, stat);
 	}
 
-	nv_wr32(priv, 0x000100, 0x00000100);
+	nv_wr32(priv, NV03_PFIFO_CACHES, reassign);
 }
 
 static int

commit 05c7145dae17a53b030238f477bf28211a21b736
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:28:47 2015 +1000

    drm/nouveau/fifo: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index 1b384bd5994e..b038b6eb51db 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -21,25 +21,18 @@
  *
  * Authors: Ben Skeggs
  */
+#include "nv04.h"
 
 #include <core/client.h>
 #include <core/device.h>
-#include <nvif/unpack.h>
-#include <nvif/class.h>
 #include <core/engctx.h>
-#include <core/namedb.h>
 #include <core/handle.h>
 #include <core/ramht.h>
-#include <core/event.h>
-
-#include <subdev/instmem.h>
 #include <subdev/instmem/nv04.h>
 #include <subdev/timer.h>
-#include <subdev/fb.h>
 
-#include <engine/fifo.h>
-
-#include "nv04.h"
+#include <nvif/class.h>
+#include <nvif/unpack.h>
 
 static struct ramfc_desc
 nv04_ramfc[] = {
@@ -59,8 +52,8 @@ nv04_ramfc[] = {
  ******************************************************************************/
 
 int
-nv04_fifo_object_attach(struct nouveau_object *parent,
-			struct nouveau_object *object, u32 handle)
+nv04_fifo_object_attach(struct nvkm_object *parent,
+			struct nvkm_object *object, u32 handle)
 {
 	struct nv04_fifo_priv *priv = (void *)parent->engine;
 	struct nv04_fifo_chan *chan = (void *)parent;
@@ -91,33 +84,33 @@ nv04_fifo_object_attach(struct nouveau_object *parent,
 	context |= chid << 24;
 
 	mutex_lock(&nv_subdev(priv)->mutex);
-	ret = nouveau_ramht_insert(priv->ramht, chid, handle, context);
+	ret = nvkm_ramht_insert(priv->ramht, chid, handle, context);
 	mutex_unlock(&nv_subdev(priv)->mutex);
 	return ret;
 }
 
 void
-nv04_fifo_object_detach(struct nouveau_object *parent, int cookie)
+nv04_fifo_object_detach(struct nvkm_object *parent, int cookie)
 {
 	struct nv04_fifo_priv *priv = (void *)parent->engine;
 	mutex_lock(&nv_subdev(priv)->mutex);
-	nouveau_ramht_remove(priv->ramht, cookie);
+	nvkm_ramht_remove(priv->ramht, cookie);
 	mutex_unlock(&nv_subdev(priv)->mutex);
 }
 
 int
-nv04_fifo_context_attach(struct nouveau_object *parent,
-			 struct nouveau_object *object)
+nv04_fifo_context_attach(struct nvkm_object *parent,
+			 struct nvkm_object *object)
 {
-	nv_engctx(object)->addr = nouveau_fifo_chan(parent)->chid;
+	nv_engctx(object)->addr = nvkm_fifo_chan(parent)->chid;
 	return 0;
 }
 
 static int
-nv04_fifo_chan_ctor(struct nouveau_object *parent,
-		    struct nouveau_object *engine,
-		    struct nouveau_oclass *oclass, void *data, u32 size,
-		    struct nouveau_object **pobject)
+nv04_fifo_chan_ctor(struct nvkm_object *parent,
+		    struct nvkm_object *engine,
+		    struct nvkm_oclass *oclass, void *data, u32 size,
+		    struct nvkm_object **pobject)
 {
 	union {
 		struct nv03_channel_dma_v0 v0;
@@ -134,11 +127,11 @@ nv04_fifo_chan_ctor(struct nouveau_object *parent,
 	} else
 		return ret;
 
-	ret = nouveau_fifo_channel_create(parent, engine, oclass, 0, 0x800000,
-					  0x10000, args->v0.pushbuf,
-					  (1ULL << NVDEV_ENGINE_DMAOBJ) |
-					  (1ULL << NVDEV_ENGINE_SW) |
-					  (1ULL << NVDEV_ENGINE_GR), &chan);
+	ret = nvkm_fifo_channel_create(parent, engine, oclass, 0, 0x800000,
+				       0x10000, args->v0.pushbuf,
+				       (1ULL << NVDEV_ENGINE_DMAOBJ) |
+				       (1ULL << NVDEV_ENGINE_SW) |
+				       (1ULL << NVDEV_ENGINE_GR), &chan);
 	*pobject = nv_object(chan);
 	if (ret)
 		return ret;
@@ -164,7 +157,7 @@ nv04_fifo_chan_ctor(struct nouveau_object *parent,
 }
 
 void
-nv04_fifo_chan_dtor(struct nouveau_object *object)
+nv04_fifo_chan_dtor(struct nvkm_object *object)
 {
 	struct nv04_fifo_priv *priv = (void *)object->engine;
 	struct nv04_fifo_chan *chan = (void *)object;
@@ -174,11 +167,11 @@ nv04_fifo_chan_dtor(struct nouveau_object *object)
 		nv_wo32(priv->ramfc, chan->ramfc + c->ctxp, 0x00000000);
 	} while ((++c)->bits);
 
-	nouveau_fifo_channel_destroy(&chan->base);
+	nvkm_fifo_channel_destroy(&chan->base);
 }
 
 int
-nv04_fifo_chan_init(struct nouveau_object *object)
+nv04_fifo_chan_init(struct nvkm_object *object)
 {
 	struct nv04_fifo_priv *priv = (void *)object->engine;
 	struct nv04_fifo_chan *chan = (void *)object;
@@ -186,7 +179,7 @@ nv04_fifo_chan_init(struct nouveau_object *object)
 	unsigned long flags;
 	int ret;
 
-	ret = nouveau_fifo_channel_init(&chan->base);
+	ret = nvkm_fifo_channel_init(&chan->base);
 	if (ret)
 		return ret;
 
@@ -197,11 +190,11 @@ nv04_fifo_chan_init(struct nouveau_object *object)
 }
 
 int
-nv04_fifo_chan_fini(struct nouveau_object *object, bool suspend)
+nv04_fifo_chan_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nv04_fifo_priv *priv = (void *)object->engine;
 	struct nv04_fifo_chan *chan = (void *)object;
-	struct nouveau_gpuobj *fctx = priv->ramfc;
+	struct nvkm_gpuobj *fctx = priv->ramfc;
 	struct ramfc_desc *c;
 	unsigned long flags;
 	u32 data = chan->ramfc;
@@ -244,22 +237,22 @@ nv04_fifo_chan_fini(struct nouveau_object *object, bool suspend)
 	nv_wr32(priv, NV03_PFIFO_CACHES, 1);
 	spin_unlock_irqrestore(&priv->base.lock, flags);
 
-	return nouveau_fifo_channel_fini(&chan->base, suspend);
+	return nvkm_fifo_channel_fini(&chan->base, suspend);
 }
 
-static struct nouveau_ofuncs
+static struct nvkm_ofuncs
 nv04_fifo_ofuncs = {
 	.ctor = nv04_fifo_chan_ctor,
 	.dtor = nv04_fifo_chan_dtor,
 	.init = nv04_fifo_chan_init,
 	.fini = nv04_fifo_chan_fini,
-	.map  = _nouveau_fifo_channel_map,
-	.rd32 = _nouveau_fifo_channel_rd32,
-	.wr32 = _nouveau_fifo_channel_wr32,
-	.ntfy = _nouveau_fifo_channel_ntfy
+	.map  = _nvkm_fifo_channel_map,
+	.rd32 = _nvkm_fifo_channel_rd32,
+	.wr32 = _nvkm_fifo_channel_wr32,
+	.ntfy = _nvkm_fifo_channel_ntfy
 };
 
-static struct nouveau_oclass
+static struct nvkm_oclass
 nv04_fifo_sclass[] = {
 	{ NV03_CHANNEL_DMA, &nv04_fifo_ofuncs },
 	{}
@@ -270,16 +263,16 @@ nv04_fifo_sclass[] = {
  ******************************************************************************/
 
 int
-nv04_fifo_context_ctor(struct nouveau_object *parent,
-		       struct nouveau_object *engine,
-		       struct nouveau_oclass *oclass, void *data, u32 size,
-		       struct nouveau_object **pobject)
+nv04_fifo_context_ctor(struct nvkm_object *parent,
+		       struct nvkm_object *engine,
+		       struct nvkm_oclass *oclass, void *data, u32 size,
+		       struct nvkm_object **pobject)
 {
 	struct nv04_fifo_base *base;
 	int ret;
 
-	ret = nouveau_fifo_context_create(parent, engine, oclass, NULL, 0x1000,
-				          0x1000, NVOBJ_FLAG_HEAP, &base);
+	ret = nvkm_fifo_context_create(parent, engine, oclass, NULL, 0x1000,
+				       0x1000, NVOBJ_FLAG_HEAP, &base);
 	*pobject = nv_object(base);
 	if (ret)
 		return ret;
@@ -287,16 +280,16 @@ nv04_fifo_context_ctor(struct nouveau_object *parent,
 	return 0;
 }
 
-static struct nouveau_oclass
+static struct nvkm_oclass
 nv04_fifo_cclass = {
 	.handle = NV_ENGCTX(FIFO, 0x04),
-	.ofuncs = &(struct nouveau_ofuncs) {
+	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv04_fifo_context_ctor,
-		.dtor = _nouveau_fifo_context_dtor,
-		.init = _nouveau_fifo_context_init,
-		.fini = _nouveau_fifo_context_fini,
-		.rd32 = _nouveau_fifo_context_rd32,
-		.wr32 = _nouveau_fifo_context_wr32,
+		.dtor = _nvkm_fifo_context_dtor,
+		.init = _nvkm_fifo_context_init,
+		.fini = _nvkm_fifo_context_fini,
+		.rd32 = _nvkm_fifo_context_rd32,
+		.wr32 = _nvkm_fifo_context_wr32,
 	},
 };
 
@@ -305,7 +298,7 @@ nv04_fifo_cclass = {
  ******************************************************************************/
 
 void
-nv04_fifo_pause(struct nouveau_fifo *pfifo, unsigned long *pflags)
+nv04_fifo_pause(struct nvkm_fifo *pfifo, unsigned long *pflags)
 __acquires(priv->base.lock)
 {
 	struct nv04_fifo_priv *priv = (void *)pfifo;
@@ -338,7 +331,7 @@ __acquires(priv->base.lock)
 }
 
 void
-nv04_fifo_start(struct nouveau_fifo *pfifo, unsigned long *pflags)
+nv04_fifo_start(struct nvkm_fifo *pfifo, unsigned long *pflags)
 __releases(priv->base.lock)
 {
 	struct nv04_fifo_priv *priv = (void *)pfifo;
@@ -364,7 +357,7 @@ static bool
 nv04_fifo_swmthd(struct nv04_fifo_priv *priv, u32 chid, u32 addr, u32 data)
 {
 	struct nv04_fifo_chan *chan = NULL;
-	struct nouveau_handle *bind;
+	struct nvkm_handle *bind;
 	const int subc = (addr >> 13) & 0x7;
 	const int mthd = addr & 0x1ffc;
 	bool handled = false;
@@ -379,7 +372,7 @@ nv04_fifo_swmthd(struct nv04_fifo_priv *priv, u32 chid, u32 addr, u32 data)
 
 	switch (mthd) {
 	case 0x0000:
-		bind = nouveau_namedb_get(nv_namedb(chan), data);
+		bind = nvkm_namedb_get(nv_namedb(chan), data);
 		if (unlikely(!bind))
 			break;
 
@@ -391,18 +384,18 @@ nv04_fifo_swmthd(struct nv04_fifo_priv *priv, u32 chid, u32 addr, u32 data)
 			nv_mask(priv, NV04_PFIFO_CACHE1_ENGINE, engine, 0);
 		}
 
-		nouveau_namedb_put(bind);
+		nvkm_namedb_put(bind);
 		break;
 	default:
 		engine = nv_rd32(priv, NV04_PFIFO_CACHE1_ENGINE);
 		if (unlikely(((engine >> (subc * 4)) & 0xf) != 0))
 			break;
 
-		bind = nouveau_namedb_get(nv_namedb(chan), chan->subc[subc]);
+		bind = nvkm_namedb_get(nv_namedb(chan), chan->subc[subc]);
 		if (likely(bind)) {
 			if (!nv_call(bind->object, mthd, data))
 				handled = true;
-			nouveau_namedb_put(bind);
+			nvkm_namedb_put(bind);
 		}
 		break;
 	}
@@ -413,8 +406,8 @@ nv04_fifo_swmthd(struct nv04_fifo_priv *priv, u32 chid, u32 addr, u32 data)
 }
 
 static void
-nv04_fifo_cache_error(struct nouveau_device *device,
-		struct nv04_fifo_priv *priv, u32 chid, u32 get)
+nv04_fifo_cache_error(struct nvkm_device *device,
+		      struct nv04_fifo_priv *priv, u32 chid, u32 get)
 {
 	u32 mthd, data;
 	int ptr;
@@ -436,7 +429,7 @@ nv04_fifo_cache_error(struct nouveau_device *device,
 
 	if (!nv04_fifo_swmthd(priv, chid, mthd, data)) {
 		const char *client_name =
-			nouveau_client_name_for_fifo_chid(&priv->base, chid);
+			nvkm_client_name_for_fifo_chid(&priv->base, chid);
 		nv_error(priv,
 			 "CACHE_ERROR - ch %d [%s] subc %d mthd 0x%04x data 0x%08x\n",
 			 chid, client_name, (mthd >> 13) & 7, mthd & 0x1ffc,
@@ -459,8 +452,8 @@ nv04_fifo_cache_error(struct nouveau_device *device,
 }
 
 static void
-nv04_fifo_dma_pusher(struct nouveau_device *device, struct nv04_fifo_priv *priv,
-		u32 chid)
+nv04_fifo_dma_pusher(struct nvkm_device *device,
+		     struct nv04_fifo_priv *priv, u32 chid)
 {
 	const char *client_name;
 	u32 dma_get = nv_rd32(priv, 0x003244);
@@ -468,7 +461,7 @@ nv04_fifo_dma_pusher(struct nouveau_device *device, struct nv04_fifo_priv *priv,
 	u32 push = nv_rd32(priv, 0x003220);
 	u32 state = nv_rd32(priv, 0x003228);
 
-	client_name = nouveau_client_name_for_fifo_chid(&priv->base, chid);
+	client_name = nvkm_client_name_for_fifo_chid(&priv->base, chid);
 
 	if (device->card_type == NV_50) {
 		u32 ho_get = nv_rd32(priv, 0x003328);
@@ -505,9 +498,9 @@ nv04_fifo_dma_pusher(struct nouveau_device *device, struct nv04_fifo_priv *priv,
 }
 
 void
-nv04_fifo_intr(struct nouveau_subdev *subdev)
+nv04_fifo_intr(struct nvkm_subdev *subdev)
 {
-	struct nouveau_device *device = nv_device(subdev);
+	struct nvkm_device *device = nv_device(subdev);
 	struct nv04_fifo_priv *priv = (void *)subdev;
 	uint32_t status, reassign;
 	int cnt = 0;
@@ -553,7 +546,7 @@ nv04_fifo_intr(struct nouveau_subdev *subdev)
 
 			if (status & 0x40000000) {
 				nv_wr32(priv, 0x002100, 0x40000000);
-				nouveau_fifo_uevent(&priv->base);
+				nvkm_fifo_uevent(&priv->base);
 				status &= ~0x40000000;
 			}
 		}
@@ -578,22 +571,22 @@ nv04_fifo_intr(struct nouveau_subdev *subdev)
 }
 
 static int
-nv04_fifo_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
-	       struct nouveau_oclass *oclass, void *data, u32 size,
-	       struct nouveau_object **pobject)
+nv04_fifo_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+	       struct nvkm_oclass *oclass, void *data, u32 size,
+	       struct nvkm_object **pobject)
 {
 	struct nv04_instmem_priv *imem = nv04_instmem(parent);
 	struct nv04_fifo_priv *priv;
 	int ret;
 
-	ret = nouveau_fifo_create(parent, engine, oclass, 0, 15, &priv);
+	ret = nvkm_fifo_create(parent, engine, oclass, 0, 15, &priv);
 	*pobject = nv_object(priv);
 	if (ret)
 		return ret;
 
-	nouveau_ramht_ref(imem->ramht, &priv->ramht);
-	nouveau_gpuobj_ref(imem->ramro, &priv->ramro);
-	nouveau_gpuobj_ref(imem->ramfc, &priv->ramfc);
+	nvkm_ramht_ref(imem->ramht, &priv->ramht);
+	nvkm_gpuobj_ref(imem->ramro, &priv->ramro);
+	nvkm_gpuobj_ref(imem->ramfc, &priv->ramfc);
 
 	nv_subdev(priv)->unit = 0x00000100;
 	nv_subdev(priv)->intr = nv04_fifo_intr;
@@ -606,22 +599,22 @@ nv04_fifo_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 }
 
 void
-nv04_fifo_dtor(struct nouveau_object *object)
+nv04_fifo_dtor(struct nvkm_object *object)
 {
 	struct nv04_fifo_priv *priv = (void *)object;
-	nouveau_gpuobj_ref(NULL, &priv->ramfc);
-	nouveau_gpuobj_ref(NULL, &priv->ramro);
-	nouveau_ramht_ref(NULL, &priv->ramht);
-	nouveau_fifo_destroy(&priv->base);
+	nvkm_gpuobj_ref(NULL, &priv->ramfc);
+	nvkm_gpuobj_ref(NULL, &priv->ramro);
+	nvkm_ramht_ref(NULL, &priv->ramht);
+	nvkm_fifo_destroy(&priv->base);
 }
 
 int
-nv04_fifo_init(struct nouveau_object *object)
+nv04_fifo_init(struct nvkm_object *object)
 {
 	struct nv04_fifo_priv *priv = (void *)object;
 	int ret;
 
-	ret = nouveau_fifo_init(&priv->base);
+	ret = nvkm_fifo_init(&priv->base);
 	if (ret)
 		return ret;
 
@@ -645,13 +638,13 @@ nv04_fifo_init(struct nouveau_object *object)
 	return 0;
 }
 
-struct nouveau_oclass *
-nv04_fifo_oclass = &(struct nouveau_oclass) {
+struct nvkm_oclass *
+nv04_fifo_oclass = &(struct nvkm_oclass) {
 	.handle = NV_ENGINE(FIFO, 0x04),
-	.ofuncs = &(struct nouveau_ofuncs) {
+	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv04_fifo_ctor,
 		.dtor = nv04_fifo_dtor,
 		.init = nv04_fifo_init,
-		.fini = _nouveau_fifo_fini,
+		.fini = _nvkm_fifo_fini,
 	},
 };

commit 9e79a85343e2191ac83f0ef4fe49b71b9d80ad38
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:12:11 2015 +1000

    drm/nouveau/timer: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
index 6f51ae0daecf..1b384bd5994e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -23,6 +23,7 @@
  */
 
 #include <core/client.h>
+#include <core/device.h>
 #include <nvif/unpack.h>
 #include <nvif/class.h>
 #include <core/engctx.h>

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
new file mode 100644
index 000000000000..6f51ae0daecf
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv04.c
@@ -0,0 +1,656 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <core/client.h>
+#include <nvif/unpack.h>
+#include <nvif/class.h>
+#include <core/engctx.h>
+#include <core/namedb.h>
+#include <core/handle.h>
+#include <core/ramht.h>
+#include <core/event.h>
+
+#include <subdev/instmem.h>
+#include <subdev/instmem/nv04.h>
+#include <subdev/timer.h>
+#include <subdev/fb.h>
+
+#include <engine/fifo.h>
+
+#include "nv04.h"
+
+static struct ramfc_desc
+nv04_ramfc[] = {
+	{ 32,  0, 0x00,  0, NV04_PFIFO_CACHE1_DMA_PUT },
+	{ 32,  0, 0x04,  0, NV04_PFIFO_CACHE1_DMA_GET },
+	{ 16,  0, 0x08,  0, NV04_PFIFO_CACHE1_DMA_INSTANCE },
+	{ 16, 16, 0x08,  0, NV04_PFIFO_CACHE1_DMA_DCOUNT },
+	{ 32,  0, 0x0c,  0, NV04_PFIFO_CACHE1_DMA_STATE },
+	{ 32,  0, 0x10,  0, NV04_PFIFO_CACHE1_DMA_FETCH },
+	{ 32,  0, 0x14,  0, NV04_PFIFO_CACHE1_ENGINE },
+	{ 32,  0, 0x18,  0, NV04_PFIFO_CACHE1_PULL1 },
+	{}
+};
+
+/*******************************************************************************
+ * FIFO channel objects
+ ******************************************************************************/
+
+int
+nv04_fifo_object_attach(struct nouveau_object *parent,
+			struct nouveau_object *object, u32 handle)
+{
+	struct nv04_fifo_priv *priv = (void *)parent->engine;
+	struct nv04_fifo_chan *chan = (void *)parent;
+	u32 context, chid = chan->base.chid;
+	int ret;
+
+	if (nv_iclass(object, NV_GPUOBJ_CLASS))
+		context = nv_gpuobj(object)->addr >> 4;
+	else
+		context = 0x00000004; /* just non-zero */
+
+	switch (nv_engidx(object->engine)) {
+	case NVDEV_ENGINE_DMAOBJ:
+	case NVDEV_ENGINE_SW:
+		context |= 0x00000000;
+		break;
+	case NVDEV_ENGINE_GR:
+		context |= 0x00010000;
+		break;
+	case NVDEV_ENGINE_MPEG:
+		context |= 0x00020000;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	context |= 0x80000000; /* valid */
+	context |= chid << 24;
+
+	mutex_lock(&nv_subdev(priv)->mutex);
+	ret = nouveau_ramht_insert(priv->ramht, chid, handle, context);
+	mutex_unlock(&nv_subdev(priv)->mutex);
+	return ret;
+}
+
+void
+nv04_fifo_object_detach(struct nouveau_object *parent, int cookie)
+{
+	struct nv04_fifo_priv *priv = (void *)parent->engine;
+	mutex_lock(&nv_subdev(priv)->mutex);
+	nouveau_ramht_remove(priv->ramht, cookie);
+	mutex_unlock(&nv_subdev(priv)->mutex);
+}
+
+int
+nv04_fifo_context_attach(struct nouveau_object *parent,
+			 struct nouveau_object *object)
+{
+	nv_engctx(object)->addr = nouveau_fifo_chan(parent)->chid;
+	return 0;
+}
+
+static int
+nv04_fifo_chan_ctor(struct nouveau_object *parent,
+		    struct nouveau_object *engine,
+		    struct nouveau_oclass *oclass, void *data, u32 size,
+		    struct nouveau_object **pobject)
+{
+	union {
+		struct nv03_channel_dma_v0 v0;
+	} *args = data;
+	struct nv04_fifo_priv *priv = (void *)engine;
+	struct nv04_fifo_chan *chan;
+	int ret;
+
+	nv_ioctl(parent, "create channel dma size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(parent, "create channel dma vers %d pushbuf %08x "
+				 "offset %016llx\n", args->v0.version,
+			 args->v0.pushbuf, args->v0.offset);
+	} else
+		return ret;
+
+	ret = nouveau_fifo_channel_create(parent, engine, oclass, 0, 0x800000,
+					  0x10000, args->v0.pushbuf,
+					  (1ULL << NVDEV_ENGINE_DMAOBJ) |
+					  (1ULL << NVDEV_ENGINE_SW) |
+					  (1ULL << NVDEV_ENGINE_GR), &chan);
+	*pobject = nv_object(chan);
+	if (ret)
+		return ret;
+
+	args->v0.chid = chan->base.chid;
+
+	nv_parent(chan)->object_attach = nv04_fifo_object_attach;
+	nv_parent(chan)->object_detach = nv04_fifo_object_detach;
+	nv_parent(chan)->context_attach = nv04_fifo_context_attach;
+	chan->ramfc = chan->base.chid * 32;
+
+	nv_wo32(priv->ramfc, chan->ramfc + 0x00, args->v0.offset);
+	nv_wo32(priv->ramfc, chan->ramfc + 0x04, args->v0.offset);
+	nv_wo32(priv->ramfc, chan->ramfc + 0x08, chan->base.pushgpu->addr >> 4);
+	nv_wo32(priv->ramfc, chan->ramfc + 0x10,
+			     NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |
+			     NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |
+#ifdef __BIG_ENDIAN
+			     NV_PFIFO_CACHE1_BIG_ENDIAN |
+#endif
+			     NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8);
+	return 0;
+}
+
+void
+nv04_fifo_chan_dtor(struct nouveau_object *object)
+{
+	struct nv04_fifo_priv *priv = (void *)object->engine;
+	struct nv04_fifo_chan *chan = (void *)object;
+	struct ramfc_desc *c = priv->ramfc_desc;
+
+	do {
+		nv_wo32(priv->ramfc, chan->ramfc + c->ctxp, 0x00000000);
+	} while ((++c)->bits);
+
+	nouveau_fifo_channel_destroy(&chan->base);
+}
+
+int
+nv04_fifo_chan_init(struct nouveau_object *object)
+{
+	struct nv04_fifo_priv *priv = (void *)object->engine;
+	struct nv04_fifo_chan *chan = (void *)object;
+	u32 mask = 1 << chan->base.chid;
+	unsigned long flags;
+	int ret;
+
+	ret = nouveau_fifo_channel_init(&chan->base);
+	if (ret)
+		return ret;
+
+	spin_lock_irqsave(&priv->base.lock, flags);
+	nv_mask(priv, NV04_PFIFO_MODE, mask, mask);
+	spin_unlock_irqrestore(&priv->base.lock, flags);
+	return 0;
+}
+
+int
+nv04_fifo_chan_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nv04_fifo_priv *priv = (void *)object->engine;
+	struct nv04_fifo_chan *chan = (void *)object;
+	struct nouveau_gpuobj *fctx = priv->ramfc;
+	struct ramfc_desc *c;
+	unsigned long flags;
+	u32 data = chan->ramfc;
+	u32 chid;
+
+	/* prevent fifo context switches */
+	spin_lock_irqsave(&priv->base.lock, flags);
+	nv_wr32(priv, NV03_PFIFO_CACHES, 0);
+
+	/* if this channel is active, replace it with a null context */
+	chid = nv_rd32(priv, NV03_PFIFO_CACHE1_PUSH1) & priv->base.max;
+	if (chid == chan->base.chid) {
+		nv_mask(priv, NV04_PFIFO_CACHE1_DMA_PUSH, 0x00000001, 0);
+		nv_wr32(priv, NV03_PFIFO_CACHE1_PUSH0, 0);
+		nv_mask(priv, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0);
+
+		c = priv->ramfc_desc;
+		do {
+			u32 rm = ((1ULL << c->bits) - 1) << c->regs;
+			u32 cm = ((1ULL << c->bits) - 1) << c->ctxs;
+			u32 rv = (nv_rd32(priv, c->regp) &  rm) >> c->regs;
+			u32 cv = (nv_ro32(fctx, c->ctxp + data) & ~cm);
+			nv_wo32(fctx, c->ctxp + data, cv | (rv << c->ctxs));
+		} while ((++c)->bits);
+
+		c = priv->ramfc_desc;
+		do {
+			nv_wr32(priv, c->regp, 0x00000000);
+		} while ((++c)->bits);
+
+		nv_wr32(priv, NV03_PFIFO_CACHE1_GET, 0);
+		nv_wr32(priv, NV03_PFIFO_CACHE1_PUT, 0);
+		nv_wr32(priv, NV03_PFIFO_CACHE1_PUSH1, priv->base.max);
+		nv_wr32(priv, NV03_PFIFO_CACHE1_PUSH0, 1);
+		nv_wr32(priv, NV04_PFIFO_CACHE1_PULL0, 1);
+	}
+
+	/* restore normal operation, after disabling dma mode */
+	nv_mask(priv, NV04_PFIFO_MODE, 1 << chan->base.chid, 0);
+	nv_wr32(priv, NV03_PFIFO_CACHES, 1);
+	spin_unlock_irqrestore(&priv->base.lock, flags);
+
+	return nouveau_fifo_channel_fini(&chan->base, suspend);
+}
+
+static struct nouveau_ofuncs
+nv04_fifo_ofuncs = {
+	.ctor = nv04_fifo_chan_ctor,
+	.dtor = nv04_fifo_chan_dtor,
+	.init = nv04_fifo_chan_init,
+	.fini = nv04_fifo_chan_fini,
+	.map  = _nouveau_fifo_channel_map,
+	.rd32 = _nouveau_fifo_channel_rd32,
+	.wr32 = _nouveau_fifo_channel_wr32,
+	.ntfy = _nouveau_fifo_channel_ntfy
+};
+
+static struct nouveau_oclass
+nv04_fifo_sclass[] = {
+	{ NV03_CHANNEL_DMA, &nv04_fifo_ofuncs },
+	{}
+};
+
+/*******************************************************************************
+ * FIFO context - basically just the instmem reserved for the channel
+ ******************************************************************************/
+
+int
+nv04_fifo_context_ctor(struct nouveau_object *parent,
+		       struct nouveau_object *engine,
+		       struct nouveau_oclass *oclass, void *data, u32 size,
+		       struct nouveau_object **pobject)
+{
+	struct nv04_fifo_base *base;
+	int ret;
+
+	ret = nouveau_fifo_context_create(parent, engine, oclass, NULL, 0x1000,
+				          0x1000, NVOBJ_FLAG_HEAP, &base);
+	*pobject = nv_object(base);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static struct nouveau_oclass
+nv04_fifo_cclass = {
+	.handle = NV_ENGCTX(FIFO, 0x04),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv04_fifo_context_ctor,
+		.dtor = _nouveau_fifo_context_dtor,
+		.init = _nouveau_fifo_context_init,
+		.fini = _nouveau_fifo_context_fini,
+		.rd32 = _nouveau_fifo_context_rd32,
+		.wr32 = _nouveau_fifo_context_wr32,
+	},
+};
+
+/*******************************************************************************
+ * PFIFO engine
+ ******************************************************************************/
+
+void
+nv04_fifo_pause(struct nouveau_fifo *pfifo, unsigned long *pflags)
+__acquires(priv->base.lock)
+{
+	struct nv04_fifo_priv *priv = (void *)pfifo;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->base.lock, flags);
+	*pflags = flags;
+
+	nv_wr32(priv, NV03_PFIFO_CACHES, 0x00000000);
+	nv_mask(priv, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0x00000000);
+
+	/* in some cases the puller may be left in an inconsistent state
+	 * if you try to stop it while it's busy translating handles.
+	 * sometimes you get a CACHE_ERROR, sometimes it just fails
+	 * silently; sending incorrect instance offsets to PGRAPH after
+	 * it's started up again.
+	 *
+	 * to avoid this, we invalidate the most recently calculated
+	 * instance.
+	 */
+	if (!nv_wait(priv, NV04_PFIFO_CACHE1_PULL0,
+			   NV04_PFIFO_CACHE1_PULL0_HASH_BUSY, 0x00000000))
+		nv_warn(priv, "timeout idling puller\n");
+
+	if (nv_rd32(priv, NV04_PFIFO_CACHE1_PULL0) &
+			  NV04_PFIFO_CACHE1_PULL0_HASH_FAILED)
+		nv_wr32(priv, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_CACHE_ERROR);
+
+	nv_wr32(priv, NV04_PFIFO_CACHE1_HASH, 0x00000000);
+}
+
+void
+nv04_fifo_start(struct nouveau_fifo *pfifo, unsigned long *pflags)
+__releases(priv->base.lock)
+{
+	struct nv04_fifo_priv *priv = (void *)pfifo;
+	unsigned long flags = *pflags;
+
+	nv_mask(priv, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0x00000001);
+	nv_wr32(priv, NV03_PFIFO_CACHES, 0x00000001);
+
+	spin_unlock_irqrestore(&priv->base.lock, flags);
+}
+
+static const char *
+nv_dma_state_err(u32 state)
+{
+	static const char * const desc[] = {
+		"NONE", "CALL_SUBR_ACTIVE", "INVALID_MTHD", "RET_SUBR_INACTIVE",
+		"INVALID_CMD", "IB_EMPTY"/* NV50+ */, "MEM_FAULT", "UNK"
+	};
+	return desc[(state >> 29) & 0x7];
+}
+
+static bool
+nv04_fifo_swmthd(struct nv04_fifo_priv *priv, u32 chid, u32 addr, u32 data)
+{
+	struct nv04_fifo_chan *chan = NULL;
+	struct nouveau_handle *bind;
+	const int subc = (addr >> 13) & 0x7;
+	const int mthd = addr & 0x1ffc;
+	bool handled = false;
+	unsigned long flags;
+	u32 engine;
+
+	spin_lock_irqsave(&priv->base.lock, flags);
+	if (likely(chid >= priv->base.min && chid <= priv->base.max))
+		chan = (void *)priv->base.channel[chid];
+	if (unlikely(!chan))
+		goto out;
+
+	switch (mthd) {
+	case 0x0000:
+		bind = nouveau_namedb_get(nv_namedb(chan), data);
+		if (unlikely(!bind))
+			break;
+
+		if (nv_engidx(bind->object->engine) == NVDEV_ENGINE_SW) {
+			engine = 0x0000000f << (subc * 4);
+			chan->subc[subc] = data;
+			handled = true;
+
+			nv_mask(priv, NV04_PFIFO_CACHE1_ENGINE, engine, 0);
+		}
+
+		nouveau_namedb_put(bind);
+		break;
+	default:
+		engine = nv_rd32(priv, NV04_PFIFO_CACHE1_ENGINE);
+		if (unlikely(((engine >> (subc * 4)) & 0xf) != 0))
+			break;
+
+		bind = nouveau_namedb_get(nv_namedb(chan), chan->subc[subc]);
+		if (likely(bind)) {
+			if (!nv_call(bind->object, mthd, data))
+				handled = true;
+			nouveau_namedb_put(bind);
+		}
+		break;
+	}
+
+out:
+	spin_unlock_irqrestore(&priv->base.lock, flags);
+	return handled;
+}
+
+static void
+nv04_fifo_cache_error(struct nouveau_device *device,
+		struct nv04_fifo_priv *priv, u32 chid, u32 get)
+{
+	u32 mthd, data;
+	int ptr;
+
+	/* NV_PFIFO_CACHE1_GET actually goes to 0xffc before wrapping on my
+	 * G80 chips, but CACHE1 isn't big enough for this much data.. Tests
+	 * show that it wraps around to the start at GET=0x800.. No clue as to
+	 * why..
+	 */
+	ptr = (get & 0x7ff) >> 2;
+
+	if (device->card_type < NV_40) {
+		mthd = nv_rd32(priv, NV04_PFIFO_CACHE1_METHOD(ptr));
+		data = nv_rd32(priv, NV04_PFIFO_CACHE1_DATA(ptr));
+	} else {
+		mthd = nv_rd32(priv, NV40_PFIFO_CACHE1_METHOD(ptr));
+		data = nv_rd32(priv, NV40_PFIFO_CACHE1_DATA(ptr));
+	}
+
+	if (!nv04_fifo_swmthd(priv, chid, mthd, data)) {
+		const char *client_name =
+			nouveau_client_name_for_fifo_chid(&priv->base, chid);
+		nv_error(priv,
+			 "CACHE_ERROR - ch %d [%s] subc %d mthd 0x%04x data 0x%08x\n",
+			 chid, client_name, (mthd >> 13) & 7, mthd & 0x1ffc,
+			 data);
+	}
+
+	nv_wr32(priv, NV04_PFIFO_CACHE1_DMA_PUSH, 0);
+	nv_wr32(priv, NV03_PFIFO_INTR_0, NV_PFIFO_INTR_CACHE_ERROR);
+
+	nv_wr32(priv, NV03_PFIFO_CACHE1_PUSH0,
+		nv_rd32(priv, NV03_PFIFO_CACHE1_PUSH0) & ~1);
+	nv_wr32(priv, NV03_PFIFO_CACHE1_GET, get + 4);
+	nv_wr32(priv, NV03_PFIFO_CACHE1_PUSH0,
+		nv_rd32(priv, NV03_PFIFO_CACHE1_PUSH0) | 1);
+	nv_wr32(priv, NV04_PFIFO_CACHE1_HASH, 0);
+
+	nv_wr32(priv, NV04_PFIFO_CACHE1_DMA_PUSH,
+		nv_rd32(priv, NV04_PFIFO_CACHE1_DMA_PUSH) | 1);
+	nv_wr32(priv, NV04_PFIFO_CACHE1_PULL0, 1);
+}
+
+static void
+nv04_fifo_dma_pusher(struct nouveau_device *device, struct nv04_fifo_priv *priv,
+		u32 chid)
+{
+	const char *client_name;
+	u32 dma_get = nv_rd32(priv, 0x003244);
+	u32 dma_put = nv_rd32(priv, 0x003240);
+	u32 push = nv_rd32(priv, 0x003220);
+	u32 state = nv_rd32(priv, 0x003228);
+
+	client_name = nouveau_client_name_for_fifo_chid(&priv->base, chid);
+
+	if (device->card_type == NV_50) {
+		u32 ho_get = nv_rd32(priv, 0x003328);
+		u32 ho_put = nv_rd32(priv, 0x003320);
+		u32 ib_get = nv_rd32(priv, 0x003334);
+		u32 ib_put = nv_rd32(priv, 0x003330);
+
+		nv_error(priv,
+			 "DMA_PUSHER - ch %d [%s] get 0x%02x%08x put 0x%02x%08x ib_get 0x%08x ib_put 0x%08x state 0x%08x (err: %s) push 0x%08x\n",
+			 chid, client_name, ho_get, dma_get, ho_put, dma_put,
+			 ib_get, ib_put, state, nv_dma_state_err(state), push);
+
+		/* METHOD_COUNT, in DMA_STATE on earlier chipsets */
+		nv_wr32(priv, 0x003364, 0x00000000);
+		if (dma_get != dma_put || ho_get != ho_put) {
+			nv_wr32(priv, 0x003244, dma_put);
+			nv_wr32(priv, 0x003328, ho_put);
+		} else
+		if (ib_get != ib_put)
+			nv_wr32(priv, 0x003334, ib_put);
+	} else {
+		nv_error(priv,
+			 "DMA_PUSHER - ch %d [%s] get 0x%08x put 0x%08x state 0x%08x (err: %s) push 0x%08x\n",
+			 chid, client_name, dma_get, dma_put, state,
+			 nv_dma_state_err(state), push);
+
+		if (dma_get != dma_put)
+			nv_wr32(priv, 0x003244, dma_put);
+	}
+
+	nv_wr32(priv, 0x003228, 0x00000000);
+	nv_wr32(priv, 0x003220, 0x00000001);
+	nv_wr32(priv, 0x002100, NV_PFIFO_INTR_DMA_PUSHER);
+}
+
+void
+nv04_fifo_intr(struct nouveau_subdev *subdev)
+{
+	struct nouveau_device *device = nv_device(subdev);
+	struct nv04_fifo_priv *priv = (void *)subdev;
+	uint32_t status, reassign;
+	int cnt = 0;
+
+	reassign = nv_rd32(priv, NV03_PFIFO_CACHES) & 1;
+	while ((status = nv_rd32(priv, NV03_PFIFO_INTR_0)) && (cnt++ < 100)) {
+		uint32_t chid, get;
+
+		nv_wr32(priv, NV03_PFIFO_CACHES, 0);
+
+		chid = nv_rd32(priv, NV03_PFIFO_CACHE1_PUSH1) & priv->base.max;
+		get  = nv_rd32(priv, NV03_PFIFO_CACHE1_GET);
+
+		if (status & NV_PFIFO_INTR_CACHE_ERROR) {
+			nv04_fifo_cache_error(device, priv, chid, get);
+			status &= ~NV_PFIFO_INTR_CACHE_ERROR;
+		}
+
+		if (status & NV_PFIFO_INTR_DMA_PUSHER) {
+			nv04_fifo_dma_pusher(device, priv, chid);
+			status &= ~NV_PFIFO_INTR_DMA_PUSHER;
+		}
+
+		if (status & NV_PFIFO_INTR_SEMAPHORE) {
+			uint32_t sem;
+
+			status &= ~NV_PFIFO_INTR_SEMAPHORE;
+			nv_wr32(priv, NV03_PFIFO_INTR_0,
+				NV_PFIFO_INTR_SEMAPHORE);
+
+			sem = nv_rd32(priv, NV10_PFIFO_CACHE1_SEMAPHORE);
+			nv_wr32(priv, NV10_PFIFO_CACHE1_SEMAPHORE, sem | 0x1);
+
+			nv_wr32(priv, NV03_PFIFO_CACHE1_GET, get + 4);
+			nv_wr32(priv, NV04_PFIFO_CACHE1_PULL0, 1);
+		}
+
+		if (device->card_type == NV_50) {
+			if (status & 0x00000010) {
+				status &= ~0x00000010;
+				nv_wr32(priv, 0x002100, 0x00000010);
+			}
+
+			if (status & 0x40000000) {
+				nv_wr32(priv, 0x002100, 0x40000000);
+				nouveau_fifo_uevent(&priv->base);
+				status &= ~0x40000000;
+			}
+		}
+
+		if (status) {
+			nv_warn(priv, "unknown intr 0x%08x, ch %d\n",
+				status, chid);
+			nv_wr32(priv, NV03_PFIFO_INTR_0, status);
+			status = 0;
+		}
+
+		nv_wr32(priv, NV03_PFIFO_CACHES, reassign);
+	}
+
+	if (status) {
+		nv_error(priv, "still angry after %d spins, halt\n", cnt);
+		nv_wr32(priv, 0x002140, 0);
+		nv_wr32(priv, 0x000140, 0);
+	}
+
+	nv_wr32(priv, 0x000100, 0x00000100);
+}
+
+static int
+nv04_fifo_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+	       struct nouveau_oclass *oclass, void *data, u32 size,
+	       struct nouveau_object **pobject)
+{
+	struct nv04_instmem_priv *imem = nv04_instmem(parent);
+	struct nv04_fifo_priv *priv;
+	int ret;
+
+	ret = nouveau_fifo_create(parent, engine, oclass, 0, 15, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	nouveau_ramht_ref(imem->ramht, &priv->ramht);
+	nouveau_gpuobj_ref(imem->ramro, &priv->ramro);
+	nouveau_gpuobj_ref(imem->ramfc, &priv->ramfc);
+
+	nv_subdev(priv)->unit = 0x00000100;
+	nv_subdev(priv)->intr = nv04_fifo_intr;
+	nv_engine(priv)->cclass = &nv04_fifo_cclass;
+	nv_engine(priv)->sclass = nv04_fifo_sclass;
+	priv->base.pause = nv04_fifo_pause;
+	priv->base.start = nv04_fifo_start;
+	priv->ramfc_desc = nv04_ramfc;
+	return 0;
+}
+
+void
+nv04_fifo_dtor(struct nouveau_object *object)
+{
+	struct nv04_fifo_priv *priv = (void *)object;
+	nouveau_gpuobj_ref(NULL, &priv->ramfc);
+	nouveau_gpuobj_ref(NULL, &priv->ramro);
+	nouveau_ramht_ref(NULL, &priv->ramht);
+	nouveau_fifo_destroy(&priv->base);
+}
+
+int
+nv04_fifo_init(struct nouveau_object *object)
+{
+	struct nv04_fifo_priv *priv = (void *)object;
+	int ret;
+
+	ret = nouveau_fifo_init(&priv->base);
+	if (ret)
+		return ret;
+
+	nv_wr32(priv, NV04_PFIFO_DELAY_0, 0x000000ff);
+	nv_wr32(priv, NV04_PFIFO_DMA_TIMESLICE, 0x0101ffff);
+
+	nv_wr32(priv, NV03_PFIFO_RAMHT, (0x03 << 24) /* search 128 */ |
+				       ((priv->ramht->bits - 9) << 16) |
+				        (priv->ramht->gpuobj.addr >> 8));
+	nv_wr32(priv, NV03_PFIFO_RAMRO, priv->ramro->addr >> 8);
+	nv_wr32(priv, NV03_PFIFO_RAMFC, priv->ramfc->addr >> 8);
+
+	nv_wr32(priv, NV03_PFIFO_CACHE1_PUSH1, priv->base.max);
+
+	nv_wr32(priv, NV03_PFIFO_INTR_0, 0xffffffff);
+	nv_wr32(priv, NV03_PFIFO_INTR_EN_0, 0xffffffff);
+
+	nv_wr32(priv, NV03_PFIFO_CACHE1_PUSH0, 1);
+	nv_wr32(priv, NV04_PFIFO_CACHE1_PULL0, 1);
+	nv_wr32(priv, NV03_PFIFO_CACHES, 1);
+	return 0;
+}
+
+struct nouveau_oclass *
+nv04_fifo_oclass = &(struct nouveau_oclass) {
+	.handle = NV_ENGINE(FIFO, 0x04),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv04_fifo_ctor,
+		.dtor = nv04_fifo_dtor,
+		.init = nv04_fifo_init,
+		.fini = _nouveau_fifo_fini,
+	},
+};
