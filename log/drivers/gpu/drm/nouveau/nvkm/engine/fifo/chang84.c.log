commit 832ca2ac3c95feb01e53c24fcd1a00b4cf05cbdc
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:20 2017 +1000

    drm/nouveau: pass handle of vmm object to channel allocation ioctls
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
index 1870310549e8..a5c998fe4485 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
@@ -229,15 +229,18 @@ g84_fifo_chan_func = {
 };
 
 int
-g84_fifo_chan_ctor(struct nv50_fifo *fifo, u64 vm, u64 push,
+g84_fifo_chan_ctor(struct nv50_fifo *fifo, u64 vmm, u64 push,
 		   const struct nvkm_oclass *oclass,
 		   struct nv50_fifo_chan *chan)
 {
 	struct nvkm_device *device = fifo->base.engine.subdev.device;
 	int ret;
 
+	if (!vmm)
+		return -EINVAL;
+
 	ret = nvkm_fifo_chan_ctor(&g84_fifo_chan_func, &fifo->base,
-				  0x10000, 0x1000, false, vm, push,
+				  0x10000, 0x1000, false, vmm, push,
 				  (1ULL << NVKM_ENGINE_BSP) |
 				  (1ULL << NVKM_ENGINE_CE0) |
 				  (1ULL << NVKM_ENGINE_CIPHER) |

commit f66c57d9229c313de3adf340c604b1c7a40e5306
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/fifo: initialise vmm with new interfaces
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
index 705a6d951d32..1870310549e8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
@@ -277,9 +277,5 @@ g84_fifo_chan_ctor(struct nv50_fifo *fifo, u64 vm, u64 push,
 	if (ret)
 		return ret;
 
-	ret = nvkm_ramht_new(device, 0x8000, 16, chan->base.inst, &chan->ramht);
-	if (ret)
-		return ret;
-
-	return nvkm_vm_ref(chan->base.vm, &chan->vm, chan->base.inst->memory);
+	return nvkm_ramht_new(device, 0x8000, 16, chan->base.inst, &chan->ramht);
 }

commit d30af7ce2c96e57b503da1d70454818331f0a6d5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/mmu: handle instance block setup
    
    We previously required each VMM user to allocate their own page directory
    and fill in the instance block themselves.
    
    It makes more sense to handle this in a common location.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
index 61797c4dd07a..705a6d951d32 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
@@ -281,5 +281,5 @@ g84_fifo_chan_ctor(struct nv50_fifo *fifo, u64 vm, u64 push,
 	if (ret)
 		return ret;
 
-	return nvkm_vm_ref(chan->base.vm, &chan->vm, chan->pgd);
+	return nvkm_vm_ref(chan->base.vm, &chan->vm, chan->base.inst->memory);
 }

commit ff9f29abf0ef4c43e696bef7621884518e6bdbda
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sat Nov 5 13:05:14 2016 +1000

    drm/nouveau/fifo/gf100-: provide notification to user if channel is killed
    
    There are instances (such as non-recoverable GPU page faults) where
    NVKM decides that a channel's context is no longer viable, and will
    be removed from the runlist.
    
    This commit notifies the owner of the channel when this happens, so
    it has the opportunity to take some kind of recovery action instead
    of hanging.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
index 66bd1cda5602..61797c4dd07a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
@@ -30,7 +30,7 @@
 
 #include <nvif/cl826e.h>
 
-int
+static int
 g84_fifo_chan_ntfy(struct nvkm_fifo_chan *chan, u32 type,
 		   struct nvkm_event **pevent)
 {

commit 40cea73984a77acb714e1d4a60a47fdfb07b656f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 24 16:08:14 2017 +1000

    drm/nouveau/fifo/g84-: rename non-stall interrupt event
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
index 15a992b3580a..66bd1cda5602 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
@@ -35,7 +35,7 @@ g84_fifo_chan_ntfy(struct nvkm_fifo_chan *chan, u32 type,
 		   struct nvkm_event **pevent)
 {
 	switch (type) {
-	case G82_CHANNEL_DMA_V0_NTFY_UEVENT:
+	case NV826E_V0_NTFY_NON_STALL_INTERRUPT:
 		*pevent = &chan->fifo->uevent;
 		return 0;
 	default:

commit e08a1d97d33e2ac05cd368b955f9fdc2823f15fd
Author: Baoyou Xie <baoyou.xie@linaro.org>
Date:   Mon Oct 24 11:09:03 2016 +0800

    drm/nouveau: mark symbols static where possible
    
    We get a few warnings when building kernel with W=1:
    drivers/gpu/drm/nouveau/nvkm/subdev/bios/fan.c:29:1: warning: no previous prototype for 'nvbios_fan_table' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/bios/fan.c:56:1: warning: no previous prototype for 'nvbios_fan_entry' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/clk/gt215.c:184:1: warning: no previous prototype for 'gt215_clk_info' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c:99:1: warning: no previous prototype for 'gt215_link_train_calc' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c:153:1: warning: no previous prototype for 'gt215_link_train' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c:271:1: warning: no previous prototype for 'gt215_link_train_init' [-Wmissing-prototypes]
    ....
    
    In fact, both functions are only used in the file in which they are
    declared and don't need a declaration, but can be made static.
    So this patch marks these functions with 'static'.
    
    Signed-off-by: Baoyou Xie <baoyou.xie@linaro.org>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
index aeb3387a3fb0..15a992b3580a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
@@ -129,7 +129,7 @@ g84_fifo_chan_engine_fini(struct nvkm_fifo_chan *base,
 }
 
 
-int
+static int
 g84_fifo_chan_engine_init(struct nvkm_fifo_chan *base,
 			  struct nvkm_engine *engine)
 {
@@ -170,7 +170,7 @@ g84_fifo_chan_engine_ctor(struct nvkm_fifo_chan *base,
 	return nvkm_object_bind(object, NULL, 0, &chan->engn[engn]);
 }
 
-int
+static int
 g84_fifo_chan_object_ctor(struct nvkm_fifo_chan *base,
 			  struct nvkm_object *object)
 {

commit 8ed1730ccd6cf2a84243456e371a5f4484be60f5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Nov 8 11:28:26 2015 +1000

    drm/nouveau/nvif: split out fifo interface definitions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
index 04305241ceed..aeb3387a3fb0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
@@ -28,7 +28,7 @@
 #include <subdev/mmu.h>
 #include <subdev/timer.h>
 
-#include <nvif/class.h>
+#include <nvif/cl826e.h>
 
 int
 g84_fifo_chan_ntfy(struct nvkm_fifo_chan *chan, u32 type,

commit 68f3f702b6a430a8d1e909455a60d26c0f2da530
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/core: remove the remainder of the previous style
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
index a7e5dfae3833..04305241ceed 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
@@ -48,16 +48,16 @@ static int
 g84_fifo_chan_engine(struct nvkm_engine *engine)
 {
 	switch (engine->subdev.index) {
-	case NVDEV_ENGINE_GR    : return 0;
-	case NVDEV_ENGINE_MPEG  :
-	case NVDEV_ENGINE_MSPPP : return 1;
-	case NVDEV_ENGINE_CE0   : return 2;
-	case NVDEV_ENGINE_VP    :
-	case NVDEV_ENGINE_MSPDEC: return 3;
-	case NVDEV_ENGINE_CIPHER:
-	case NVDEV_ENGINE_SEC   : return 4;
-	case NVDEV_ENGINE_BSP   :
-	case NVDEV_ENGINE_MSVLD : return 5;
+	case NVKM_ENGINE_GR    : return 0;
+	case NVKM_ENGINE_MPEG  :
+	case NVKM_ENGINE_MSPPP : return 1;
+	case NVKM_ENGINE_CE0   : return 2;
+	case NVKM_ENGINE_VP    :
+	case NVKM_ENGINE_MSPDEC: return 3;
+	case NVKM_ENGINE_CIPHER:
+	case NVKM_ENGINE_SEC   : return 4;
+	case NVKM_ENGINE_BSP   :
+	case NVKM_ENGINE_MSVLD : return 5;
 	default:
 		WARN_ON(1);
 		return 0;
@@ -68,18 +68,18 @@ static int
 g84_fifo_chan_engine_addr(struct nvkm_engine *engine)
 {
 	switch (engine->subdev.index) {
-	case NVDEV_ENGINE_DMAOBJ:
-	case NVDEV_ENGINE_SW    : return -1;
-	case NVDEV_ENGINE_GR    : return 0x0020;
-	case NVDEV_ENGINE_VP    :
-	case NVDEV_ENGINE_MSPDEC: return 0x0040;
-	case NVDEV_ENGINE_MPEG  :
-	case NVDEV_ENGINE_MSPPP : return 0x0060;
-	case NVDEV_ENGINE_BSP   :
-	case NVDEV_ENGINE_MSVLD : return 0x0080;
-	case NVDEV_ENGINE_CIPHER:
-	case NVDEV_ENGINE_SEC   : return 0x00a0;
-	case NVDEV_ENGINE_CE0   : return 0x00c0;
+	case NVKM_ENGINE_DMAOBJ:
+	case NVKM_ENGINE_SW    : return -1;
+	case NVKM_ENGINE_GR    : return 0x0020;
+	case NVKM_ENGINE_VP    :
+	case NVKM_ENGINE_MSPDEC: return 0x0040;
+	case NVKM_ENGINE_MPEG  :
+	case NVKM_ENGINE_MSPPP : return 0x0060;
+	case NVKM_ENGINE_BSP   :
+	case NVKM_ENGINE_MSVLD : return 0x0080;
+	case NVKM_ENGINE_CIPHER:
+	case NVKM_ENGINE_SEC   : return 0x00a0;
+	case NVKM_ENGINE_CE0   : return 0x00c0;
 	default:
 		WARN_ON(1);
 		return -1;
@@ -167,11 +167,6 @@ g84_fifo_chan_engine_ctor(struct nvkm_fifo_chan *base,
 	if (g84_fifo_chan_engine_addr(engine) < 0)
 		return 0;
 
-	if (nv_iclass(object, NV_GPUOBJ_CLASS)) {
-		chan->engn[engn] = nv_gpuobj(object);
-		return 0;
-	}
-
 	return nvkm_object_bind(object, NULL, 0, &chan->engn[engn]);
 }
 
@@ -184,20 +179,20 @@ g84_fifo_chan_object_ctor(struct nvkm_fifo_chan *base,
 	u32 context;
 
 	switch (object->engine->subdev.index) {
-	case NVDEV_ENGINE_DMAOBJ:
-	case NVDEV_ENGINE_SW    : context = 0x00000000; break;
-	case NVDEV_ENGINE_GR    : context = 0x00100000; break;
-	case NVDEV_ENGINE_MPEG  :
-	case NVDEV_ENGINE_MSPPP : context = 0x00200000; break;
-	case NVDEV_ENGINE_ME    :
-	case NVDEV_ENGINE_CE0   : context = 0x00300000; break;
-	case NVDEV_ENGINE_VP    :
-	case NVDEV_ENGINE_MSPDEC: context = 0x00400000; break;
-	case NVDEV_ENGINE_CIPHER:
-	case NVDEV_ENGINE_SEC   :
-	case NVDEV_ENGINE_VIC   : context = 0x00500000; break;
-	case NVDEV_ENGINE_BSP   :
-	case NVDEV_ENGINE_MSVLD : context = 0x00600000; break;
+	case NVKM_ENGINE_DMAOBJ:
+	case NVKM_ENGINE_SW    : context = 0x00000000; break;
+	case NVKM_ENGINE_GR    : context = 0x00100000; break;
+	case NVKM_ENGINE_MPEG  :
+	case NVKM_ENGINE_MSPPP : context = 0x00200000; break;
+	case NVKM_ENGINE_ME    :
+	case NVKM_ENGINE_CE0   : context = 0x00300000; break;
+	case NVKM_ENGINE_VP    :
+	case NVKM_ENGINE_MSPDEC: context = 0x00400000; break;
+	case NVKM_ENGINE_CIPHER:
+	case NVKM_ENGINE_SEC   :
+	case NVKM_ENGINE_VIC   : context = 0x00500000; break;
+	case NVKM_ENGINE_BSP   :
+	case NVKM_ENGINE_MSVLD : context = 0x00600000; break;
 	default:
 		WARN_ON(1);
 		return -EINVAL;
@@ -243,20 +238,20 @@ g84_fifo_chan_ctor(struct nv50_fifo *fifo, u64 vm, u64 push,
 
 	ret = nvkm_fifo_chan_ctor(&g84_fifo_chan_func, &fifo->base,
 				  0x10000, 0x1000, false, vm, push,
-				  (1ULL << NVDEV_ENGINE_BSP) |
-				  (1ULL << NVDEV_ENGINE_CE0) |
-				  (1ULL << NVDEV_ENGINE_CIPHER) |
-				  (1ULL << NVDEV_ENGINE_DMAOBJ) |
-				  (1ULL << NVDEV_ENGINE_GR) |
-				  (1ULL << NVDEV_ENGINE_ME) |
-				  (1ULL << NVDEV_ENGINE_MPEG) |
-				  (1ULL << NVDEV_ENGINE_MSPDEC) |
-				  (1ULL << NVDEV_ENGINE_MSPPP) |
-				  (1ULL << NVDEV_ENGINE_MSVLD) |
-				  (1ULL << NVDEV_ENGINE_SEC) |
-				  (1ULL << NVDEV_ENGINE_SW) |
-				  (1ULL << NVDEV_ENGINE_VIC) |
-				  (1ULL << NVDEV_ENGINE_VP),
+				  (1ULL << NVKM_ENGINE_BSP) |
+				  (1ULL << NVKM_ENGINE_CE0) |
+				  (1ULL << NVKM_ENGINE_CIPHER) |
+				  (1ULL << NVKM_ENGINE_DMAOBJ) |
+				  (1ULL << NVKM_ENGINE_GR) |
+				  (1ULL << NVKM_ENGINE_ME) |
+				  (1ULL << NVKM_ENGINE_MPEG) |
+				  (1ULL << NVKM_ENGINE_MSPDEC) |
+				  (1ULL << NVKM_ENGINE_MSPPP) |
+				  (1ULL << NVKM_ENGINE_MSVLD) |
+				  (1ULL << NVKM_ENGINE_SEC) |
+				  (1ULL << NVKM_ENGINE_SW) |
+				  (1ULL << NVKM_ENGINE_VIC) |
+				  (1ULL << NVKM_ENGINE_VP),
 				  0, 0xc00000, 0x2000, oclass, &chan->base);
 	chan->fifo = fifo;
 	if (ret)

commit 8f0649b5c6e70ec18122255690e39f010c12a614
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/fifo: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
index f2b4a96f8794..a7e5dfae3833 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
@@ -25,38 +25,86 @@
 
 #include <core/client.h>
 #include <core/ramht.h>
+#include <subdev/mmu.h>
 #include <subdev/timer.h>
 
+#include <nvif/class.h>
+
 int
-g84_fifo_context_detach(struct nvkm_object *parent, bool suspend,
-			struct nvkm_object *object)
+g84_fifo_chan_ntfy(struct nvkm_fifo_chan *chan, u32 type,
+		   struct nvkm_event **pevent)
 {
-	struct nv50_fifo *fifo = (void *)parent->engine;
-	struct nv50_fifo_base *base = (void *)parent->parent;
-	struct nv50_fifo_chan *chan = (void *)parent;
-	struct nvkm_subdev *subdev = &fifo->base.engine.subdev;
-	struct nvkm_device *device = subdev->device;
-	u32 addr, save, engn;
-	bool done;
+	switch (type) {
+	case G82_CHANNEL_DMA_V0_NTFY_UEVENT:
+		*pevent = &chan->fifo->uevent;
+		return 0;
+	default:
+		break;
+	}
+	return -EINVAL;
+}
 
-	switch (nv_engidx(object->engine)) {
-	case NVDEV_ENGINE_SW    : return 0;
-	case NVDEV_ENGINE_GR    : engn = 0; addr = 0x0020; break;
+static int
+g84_fifo_chan_engine(struct nvkm_engine *engine)
+{
+	switch (engine->subdev.index) {
+	case NVDEV_ENGINE_GR    : return 0;
+	case NVDEV_ENGINE_MPEG  :
+	case NVDEV_ENGINE_MSPPP : return 1;
+	case NVDEV_ENGINE_CE0   : return 2;
 	case NVDEV_ENGINE_VP    :
-	case NVDEV_ENGINE_MSPDEC: engn = 3; addr = 0x0040; break;
-	case NVDEV_ENGINE_MSPPP :
-	case NVDEV_ENGINE_MPEG  : engn = 1; addr = 0x0060; break;
+	case NVDEV_ENGINE_MSPDEC: return 3;
+	case NVDEV_ENGINE_CIPHER:
+	case NVDEV_ENGINE_SEC   : return 4;
 	case NVDEV_ENGINE_BSP   :
-	case NVDEV_ENGINE_MSVLD : engn = 5; addr = 0x0080; break;
+	case NVDEV_ENGINE_MSVLD : return 5;
+	default:
+		WARN_ON(1);
+		return 0;
+	}
+}
+
+static int
+g84_fifo_chan_engine_addr(struct nvkm_engine *engine)
+{
+	switch (engine->subdev.index) {
+	case NVDEV_ENGINE_DMAOBJ:
+	case NVDEV_ENGINE_SW    : return -1;
+	case NVDEV_ENGINE_GR    : return 0x0020;
+	case NVDEV_ENGINE_VP    :
+	case NVDEV_ENGINE_MSPDEC: return 0x0040;
+	case NVDEV_ENGINE_MPEG  :
+	case NVDEV_ENGINE_MSPPP : return 0x0060;
+	case NVDEV_ENGINE_BSP   :
+	case NVDEV_ENGINE_MSVLD : return 0x0080;
 	case NVDEV_ENGINE_CIPHER:
-	case NVDEV_ENGINE_SEC   : engn = 4; addr = 0x00a0; break;
-	case NVDEV_ENGINE_CE0   : engn = 2; addr = 0x00c0; break;
+	case NVDEV_ENGINE_SEC   : return 0x00a0;
+	case NVDEV_ENGINE_CE0   : return 0x00c0;
 	default:
-		return -EINVAL;
+		WARN_ON(1);
+		return -1;
 	}
+}
 
+static int
+g84_fifo_chan_engine_fini(struct nvkm_fifo_chan *base,
+			  struct nvkm_engine *engine, bool suspend)
+{
+	struct nv50_fifo_chan *chan = nv50_fifo_chan(base);
+	struct nv50_fifo *fifo = chan->fifo;
+	struct nvkm_subdev *subdev = &fifo->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
+	u32 engn, save;
+	int offset;
+	bool done;
+
+	offset = g84_fifo_chan_engine_addr(engine);
+	if (offset < 0)
+		return 0;
+
+	engn = g84_fifo_chan_engine(engine);
 	save = nvkm_mask(device, 0x002520, 0x0000003f, 1 << engn);
-	nvkm_wr32(device, 0x0032fc, nv_gpuobj(base)->addr >> 12);
+	nvkm_wr32(device, 0x0032fc, chan->base.inst->addr >> 12);
 	done = nvkm_msec(device, 2000,
 		if (nvkm_rd32(device, 0x0032fc) != 0xffffffff)
 			break;
@@ -64,168 +112,179 @@ g84_fifo_context_detach(struct nvkm_object *parent, bool suspend,
 	nvkm_wr32(device, 0x002520, save);
 	if (!done) {
 		nvkm_error(subdev, "channel %d [%s] unload timeout\n",
-			   chan->base.chid, nvkm_client_name(chan));
+			   chan->base.chid, chan->base.object.client->name);
 		if (suspend)
 			return -EBUSY;
 	}
 
-	nvkm_kmap(base->eng);
-	nvkm_wo32(base->eng, addr + 0x00, 0x00000000);
-	nvkm_wo32(base->eng, addr + 0x04, 0x00000000);
-	nvkm_wo32(base->eng, addr + 0x08, 0x00000000);
-	nvkm_wo32(base->eng, addr + 0x0c, 0x00000000);
-	nvkm_wo32(base->eng, addr + 0x10, 0x00000000);
-	nvkm_wo32(base->eng, addr + 0x14, 0x00000000);
-	nvkm_done(base->eng);
+	nvkm_kmap(chan->eng);
+	nvkm_wo32(chan->eng, offset + 0x00, 0x00000000);
+	nvkm_wo32(chan->eng, offset + 0x04, 0x00000000);
+	nvkm_wo32(chan->eng, offset + 0x08, 0x00000000);
+	nvkm_wo32(chan->eng, offset + 0x0c, 0x00000000);
+	nvkm_wo32(chan->eng, offset + 0x10, 0x00000000);
+	nvkm_wo32(chan->eng, offset + 0x14, 0x00000000);
+	nvkm_done(chan->eng);
 	return 0;
 }
 
 
 int
-g84_fifo_context_attach(struct nvkm_object *parent, struct nvkm_object *object)
+g84_fifo_chan_engine_init(struct nvkm_fifo_chan *base,
+			  struct nvkm_engine *engine)
 {
-	struct nv50_fifo_base *base = (void *)parent->parent;
-	struct nvkm_gpuobj *ectx = (void *)object;
-	u64 limit = ectx->addr + ectx->size - 1;
-	u64 start = ectx->addr;
-	u32 addr;
-
-	switch (nv_engidx(object->engine)) {
-	case NVDEV_ENGINE_SW    : return 0;
-	case NVDEV_ENGINE_GR    : addr = 0x0020; break;
-	case NVDEV_ENGINE_VP    :
-	case NVDEV_ENGINE_MSPDEC: addr = 0x0040; break;
-	case NVDEV_ENGINE_MSPPP :
-	case NVDEV_ENGINE_MPEG  : addr = 0x0060; break;
-	case NVDEV_ENGINE_BSP   :
-	case NVDEV_ENGINE_MSVLD : addr = 0x0080; break;
-	case NVDEV_ENGINE_CIPHER:
-	case NVDEV_ENGINE_SEC   : addr = 0x00a0; break;
-	case NVDEV_ENGINE_CE0   : addr = 0x00c0; break;
-	default:
-		return -EINVAL;
-	}
+	struct nv50_fifo_chan *chan = nv50_fifo_chan(base);
+	struct nvkm_gpuobj *engn = chan->engn[engine->subdev.index];
+	u64 limit, start;
+	int offset;
 
-	nv_engctx(ectx)->addr = nv_gpuobj(base)->addr >> 12;
-	nvkm_kmap(base->eng);
-	nvkm_wo32(base->eng, addr + 0x00, 0x00190000);
-	nvkm_wo32(base->eng, addr + 0x04, lower_32_bits(limit));
-	nvkm_wo32(base->eng, addr + 0x08, lower_32_bits(start));
-	nvkm_wo32(base->eng, addr + 0x0c, upper_32_bits(limit) << 24 |
-					  upper_32_bits(start));
-	nvkm_wo32(base->eng, addr + 0x10, 0x00000000);
-	nvkm_wo32(base->eng, addr + 0x14, 0x00000000);
-	nvkm_done(base->eng);
+	offset = g84_fifo_chan_engine_addr(engine);
+	if (offset < 0)
+		return 0;
+	limit = engn->addr + engn->size - 1;
+	start = engn->addr;
+
+	nvkm_kmap(chan->eng);
+	nvkm_wo32(chan->eng, offset + 0x00, 0x00190000);
+	nvkm_wo32(chan->eng, offset + 0x04, lower_32_bits(limit));
+	nvkm_wo32(chan->eng, offset + 0x08, lower_32_bits(start));
+	nvkm_wo32(chan->eng, offset + 0x0c, upper_32_bits(limit) << 24 |
+					    upper_32_bits(start));
+	nvkm_wo32(chan->eng, offset + 0x10, 0x00000000);
+	nvkm_wo32(chan->eng, offset + 0x14, 0x00000000);
+	nvkm_done(chan->eng);
 	return 0;
 }
 
+static int
+g84_fifo_chan_engine_ctor(struct nvkm_fifo_chan *base,
+			  struct nvkm_engine *engine,
+			  struct nvkm_object *object)
+{
+	struct nv50_fifo_chan *chan = nv50_fifo_chan(base);
+	int engn = engine->subdev.index;
+
+	if (g84_fifo_chan_engine_addr(engine) < 0)
+		return 0;
+
+	if (nv_iclass(object, NV_GPUOBJ_CLASS)) {
+		chan->engn[engn] = nv_gpuobj(object);
+		return 0;
+	}
+
+	return nvkm_object_bind(object, NULL, 0, &chan->engn[engn]);
+}
+
 int
-g84_fifo_object_attach(struct nvkm_object *parent,
-		       struct nvkm_object *object, u32 handle)
+g84_fifo_chan_object_ctor(struct nvkm_fifo_chan *base,
+			  struct nvkm_object *object)
 {
-	struct nv50_fifo_chan *chan = (void *)parent;
+	struct nv50_fifo_chan *chan = nv50_fifo_chan(base);
+	u32 handle = object->handle;
 	u32 context;
 
-	if (nv_iclass(object, NV_GPUOBJ_CLASS))
-		context = nv_gpuobj(object)->node->offset >> 4;
-	else
-		context = 0x00000004; /* just non-zero */
-
-	if (object->engine) {
-		switch (nv_engidx(object->engine)) {
-		case NVDEV_ENGINE_DMAOBJ:
-		case NVDEV_ENGINE_SW    : context |= 0x00000000; break;
-		case NVDEV_ENGINE_GR    : context |= 0x00100000; break;
-		case NVDEV_ENGINE_MPEG  :
-		case NVDEV_ENGINE_MSPPP : context |= 0x00200000; break;
-		case NVDEV_ENGINE_ME    :
-		case NVDEV_ENGINE_CE0   : context |= 0x00300000; break;
-		case NVDEV_ENGINE_VP    :
-		case NVDEV_ENGINE_MSPDEC: context |= 0x00400000; break;
-		case NVDEV_ENGINE_CIPHER:
-		case NVDEV_ENGINE_SEC   :
-		case NVDEV_ENGINE_VIC   : context |= 0x00500000; break;
-		case NVDEV_ENGINE_BSP   :
-		case NVDEV_ENGINE_MSVLD : context |= 0x00600000; break;
-		default:
-			return -EINVAL;
-		}
+	switch (object->engine->subdev.index) {
+	case NVDEV_ENGINE_DMAOBJ:
+	case NVDEV_ENGINE_SW    : context = 0x00000000; break;
+	case NVDEV_ENGINE_GR    : context = 0x00100000; break;
+	case NVDEV_ENGINE_MPEG  :
+	case NVDEV_ENGINE_MSPPP : context = 0x00200000; break;
+	case NVDEV_ENGINE_ME    :
+	case NVDEV_ENGINE_CE0   : context = 0x00300000; break;
+	case NVDEV_ENGINE_VP    :
+	case NVDEV_ENGINE_MSPDEC: context = 0x00400000; break;
+	case NVDEV_ENGINE_CIPHER:
+	case NVDEV_ENGINE_SEC   :
+	case NVDEV_ENGINE_VIC   : context = 0x00500000; break;
+	case NVDEV_ENGINE_BSP   :
+	case NVDEV_ENGINE_MSVLD : context = 0x00600000; break;
+	default:
+		WARN_ON(1);
+		return -EINVAL;
 	}
 
-	return nvkm_ramht_insert(chan->ramht, NULL, 0, 0, handle, context);
+	return nvkm_ramht_insert(chan->ramht, object, 0, 4, handle, context);
 }
 
-int
-g84_fifo_chan_init(struct nvkm_object *object)
+static void
+g84_fifo_chan_init(struct nvkm_fifo_chan *base)
 {
-	struct nv50_fifo *fifo = (void *)object->engine;
-	struct nv50_fifo_base *base = (void *)object->parent;
-	struct nv50_fifo_chan *chan = (void *)object;
-	struct nvkm_gpuobj *ramfc = base->ramfc;
+	struct nv50_fifo_chan *chan = nv50_fifo_chan(base);
+	struct nv50_fifo *fifo = chan->fifo;
 	struct nvkm_device *device = fifo->base.engine.subdev.device;
+	u64 addr = chan->ramfc->addr >> 8;
 	u32 chid = chan->base.chid;
-	int ret;
-
-	ret = nvkm_fifo_channel_init(&chan->base);
-	if (ret)
-		return ret;
 
-	nvkm_wr32(device, 0x002600 + (chid * 4), 0x80000000 | ramfc->addr >> 8);
+	nvkm_wr32(device, 0x002600 + (chid * 4), 0x80000000 | addr);
 	nv50_fifo_runlist_update(fifo);
-	return 0;
 }
 
-static int
-g84_fifo_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-		      struct nvkm_oclass *oclass, void *data, u32 size,
-		      struct nvkm_object **pobject)
+static const struct nvkm_fifo_chan_func
+g84_fifo_chan_func = {
+	.dtor = nv50_fifo_chan_dtor,
+	.init = g84_fifo_chan_init,
+	.fini = nv50_fifo_chan_fini,
+	.ntfy = g84_fifo_chan_ntfy,
+	.engine_ctor = g84_fifo_chan_engine_ctor,
+	.engine_dtor = nv50_fifo_chan_engine_dtor,
+	.engine_init = g84_fifo_chan_engine_init,
+	.engine_fini = g84_fifo_chan_engine_fini,
+	.object_ctor = g84_fifo_chan_object_ctor,
+	.object_dtor = nv50_fifo_chan_object_dtor,
+};
+
+int
+g84_fifo_chan_ctor(struct nv50_fifo *fifo, u64 vm, u64 push,
+		   const struct nvkm_oclass *oclass,
+		   struct nv50_fifo_chan *chan)
 {
-	struct nvkm_device *device = nv_engine(engine)->subdev.device;
-	struct nv50_fifo_base *base;
+	struct nvkm_device *device = fifo->base.engine.subdev.device;
 	int ret;
 
-	ret = nvkm_fifo_context_create(parent, engine, oclass, NULL, 0x10000,
-				       0x1000, NVOBJ_FLAG_HEAP, &base);
-	*pobject = nv_object(base);
+	ret = nvkm_fifo_chan_ctor(&g84_fifo_chan_func, &fifo->base,
+				  0x10000, 0x1000, false, vm, push,
+				  (1ULL << NVDEV_ENGINE_BSP) |
+				  (1ULL << NVDEV_ENGINE_CE0) |
+				  (1ULL << NVDEV_ENGINE_CIPHER) |
+				  (1ULL << NVDEV_ENGINE_DMAOBJ) |
+				  (1ULL << NVDEV_ENGINE_GR) |
+				  (1ULL << NVDEV_ENGINE_ME) |
+				  (1ULL << NVDEV_ENGINE_MPEG) |
+				  (1ULL << NVDEV_ENGINE_MSPDEC) |
+				  (1ULL << NVDEV_ENGINE_MSPPP) |
+				  (1ULL << NVDEV_ENGINE_MSVLD) |
+				  (1ULL << NVDEV_ENGINE_SEC) |
+				  (1ULL << NVDEV_ENGINE_SW) |
+				  (1ULL << NVDEV_ENGINE_VIC) |
+				  (1ULL << NVDEV_ENGINE_VP),
+				  0, 0xc00000, 0x2000, oclass, &chan->base);
+	chan->fifo = fifo;
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(device, 0x0200, 0, true, &base->base.gpuobj,
-			      &base->eng);
+	ret = nvkm_gpuobj_new(device, 0x0200, 0, true, chan->base.inst,
+			      &chan->eng);
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(device, 0x4000, 0, false, &base->base.gpuobj,
-			      &base->pgd);
+	ret = nvkm_gpuobj_new(device, 0x4000, 0, false, chan->base.inst,
+			      &chan->pgd);
 	if (ret)
 		return ret;
 
-	ret = nvkm_vm_ref(nvkm_client(parent)->vm, &base->vm, base->pgd);
+	ret = nvkm_gpuobj_new(device, 0x1000, 0x400, true, chan->base.inst,
+			      &chan->cache);
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(device, 0x1000, 0x400, true, &base->base.gpuobj,
-			      &base->cache);
+	ret = nvkm_gpuobj_new(device, 0x100, 0x100, true, chan->base.inst,
+			      &chan->ramfc);
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(device, 0x100, 0x100, true, &base->base.gpuobj,
-			      &base->ramfc);
+	ret = nvkm_ramht_new(device, 0x8000, 16, chan->base.inst, &chan->ramht);
 	if (ret)
 		return ret;
 
-	return 0;
+	return nvkm_vm_ref(chan->base.vm, &chan->vm, chan->pgd);
 }
-
-struct nvkm_oclass
-g84_fifo_cclass = {
-	.handle = NV_ENGCTX(FIFO, 0x84),
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = g84_fifo_context_ctor,
-		.dtor = nv50_fifo_context_dtor,
-		.init = _nvkm_fifo_context_init,
-		.fini = _nvkm_fifo_context_fini,
-		.rd32 = _nvkm_fifo_context_rd32,
-		.wr32 = _nvkm_fifo_context_wr32,
-	},
-};

commit 9a65a38c456ebac97f0498e85fe26f6d26fe3936
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/fifo: split user classes out from engine implementations
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
new file mode 100644
index 000000000000..f2b4a96f8794
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chang84.c
@@ -0,0 +1,231 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+#include "channv50.h"
+
+#include <core/client.h>
+#include <core/ramht.h>
+#include <subdev/timer.h>
+
+int
+g84_fifo_context_detach(struct nvkm_object *parent, bool suspend,
+			struct nvkm_object *object)
+{
+	struct nv50_fifo *fifo = (void *)parent->engine;
+	struct nv50_fifo_base *base = (void *)parent->parent;
+	struct nv50_fifo_chan *chan = (void *)parent;
+	struct nvkm_subdev *subdev = &fifo->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
+	u32 addr, save, engn;
+	bool done;
+
+	switch (nv_engidx(object->engine)) {
+	case NVDEV_ENGINE_SW    : return 0;
+	case NVDEV_ENGINE_GR    : engn = 0; addr = 0x0020; break;
+	case NVDEV_ENGINE_VP    :
+	case NVDEV_ENGINE_MSPDEC: engn = 3; addr = 0x0040; break;
+	case NVDEV_ENGINE_MSPPP :
+	case NVDEV_ENGINE_MPEG  : engn = 1; addr = 0x0060; break;
+	case NVDEV_ENGINE_BSP   :
+	case NVDEV_ENGINE_MSVLD : engn = 5; addr = 0x0080; break;
+	case NVDEV_ENGINE_CIPHER:
+	case NVDEV_ENGINE_SEC   : engn = 4; addr = 0x00a0; break;
+	case NVDEV_ENGINE_CE0   : engn = 2; addr = 0x00c0; break;
+	default:
+		return -EINVAL;
+	}
+
+	save = nvkm_mask(device, 0x002520, 0x0000003f, 1 << engn);
+	nvkm_wr32(device, 0x0032fc, nv_gpuobj(base)->addr >> 12);
+	done = nvkm_msec(device, 2000,
+		if (nvkm_rd32(device, 0x0032fc) != 0xffffffff)
+			break;
+	) >= 0;
+	nvkm_wr32(device, 0x002520, save);
+	if (!done) {
+		nvkm_error(subdev, "channel %d [%s] unload timeout\n",
+			   chan->base.chid, nvkm_client_name(chan));
+		if (suspend)
+			return -EBUSY;
+	}
+
+	nvkm_kmap(base->eng);
+	nvkm_wo32(base->eng, addr + 0x00, 0x00000000);
+	nvkm_wo32(base->eng, addr + 0x04, 0x00000000);
+	nvkm_wo32(base->eng, addr + 0x08, 0x00000000);
+	nvkm_wo32(base->eng, addr + 0x0c, 0x00000000);
+	nvkm_wo32(base->eng, addr + 0x10, 0x00000000);
+	nvkm_wo32(base->eng, addr + 0x14, 0x00000000);
+	nvkm_done(base->eng);
+	return 0;
+}
+
+
+int
+g84_fifo_context_attach(struct nvkm_object *parent, struct nvkm_object *object)
+{
+	struct nv50_fifo_base *base = (void *)parent->parent;
+	struct nvkm_gpuobj *ectx = (void *)object;
+	u64 limit = ectx->addr + ectx->size - 1;
+	u64 start = ectx->addr;
+	u32 addr;
+
+	switch (nv_engidx(object->engine)) {
+	case NVDEV_ENGINE_SW    : return 0;
+	case NVDEV_ENGINE_GR    : addr = 0x0020; break;
+	case NVDEV_ENGINE_VP    :
+	case NVDEV_ENGINE_MSPDEC: addr = 0x0040; break;
+	case NVDEV_ENGINE_MSPPP :
+	case NVDEV_ENGINE_MPEG  : addr = 0x0060; break;
+	case NVDEV_ENGINE_BSP   :
+	case NVDEV_ENGINE_MSVLD : addr = 0x0080; break;
+	case NVDEV_ENGINE_CIPHER:
+	case NVDEV_ENGINE_SEC   : addr = 0x00a0; break;
+	case NVDEV_ENGINE_CE0   : addr = 0x00c0; break;
+	default:
+		return -EINVAL;
+	}
+
+	nv_engctx(ectx)->addr = nv_gpuobj(base)->addr >> 12;
+	nvkm_kmap(base->eng);
+	nvkm_wo32(base->eng, addr + 0x00, 0x00190000);
+	nvkm_wo32(base->eng, addr + 0x04, lower_32_bits(limit));
+	nvkm_wo32(base->eng, addr + 0x08, lower_32_bits(start));
+	nvkm_wo32(base->eng, addr + 0x0c, upper_32_bits(limit) << 24 |
+					  upper_32_bits(start));
+	nvkm_wo32(base->eng, addr + 0x10, 0x00000000);
+	nvkm_wo32(base->eng, addr + 0x14, 0x00000000);
+	nvkm_done(base->eng);
+	return 0;
+}
+
+int
+g84_fifo_object_attach(struct nvkm_object *parent,
+		       struct nvkm_object *object, u32 handle)
+{
+	struct nv50_fifo_chan *chan = (void *)parent;
+	u32 context;
+
+	if (nv_iclass(object, NV_GPUOBJ_CLASS))
+		context = nv_gpuobj(object)->node->offset >> 4;
+	else
+		context = 0x00000004; /* just non-zero */
+
+	if (object->engine) {
+		switch (nv_engidx(object->engine)) {
+		case NVDEV_ENGINE_DMAOBJ:
+		case NVDEV_ENGINE_SW    : context |= 0x00000000; break;
+		case NVDEV_ENGINE_GR    : context |= 0x00100000; break;
+		case NVDEV_ENGINE_MPEG  :
+		case NVDEV_ENGINE_MSPPP : context |= 0x00200000; break;
+		case NVDEV_ENGINE_ME    :
+		case NVDEV_ENGINE_CE0   : context |= 0x00300000; break;
+		case NVDEV_ENGINE_VP    :
+		case NVDEV_ENGINE_MSPDEC: context |= 0x00400000; break;
+		case NVDEV_ENGINE_CIPHER:
+		case NVDEV_ENGINE_SEC   :
+		case NVDEV_ENGINE_VIC   : context |= 0x00500000; break;
+		case NVDEV_ENGINE_BSP   :
+		case NVDEV_ENGINE_MSVLD : context |= 0x00600000; break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	return nvkm_ramht_insert(chan->ramht, NULL, 0, 0, handle, context);
+}
+
+int
+g84_fifo_chan_init(struct nvkm_object *object)
+{
+	struct nv50_fifo *fifo = (void *)object->engine;
+	struct nv50_fifo_base *base = (void *)object->parent;
+	struct nv50_fifo_chan *chan = (void *)object;
+	struct nvkm_gpuobj *ramfc = base->ramfc;
+	struct nvkm_device *device = fifo->base.engine.subdev.device;
+	u32 chid = chan->base.chid;
+	int ret;
+
+	ret = nvkm_fifo_channel_init(&chan->base);
+	if (ret)
+		return ret;
+
+	nvkm_wr32(device, 0x002600 + (chid * 4), 0x80000000 | ramfc->addr >> 8);
+	nv50_fifo_runlist_update(fifo);
+	return 0;
+}
+
+static int
+g84_fifo_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+		      struct nvkm_oclass *oclass, void *data, u32 size,
+		      struct nvkm_object **pobject)
+{
+	struct nvkm_device *device = nv_engine(engine)->subdev.device;
+	struct nv50_fifo_base *base;
+	int ret;
+
+	ret = nvkm_fifo_context_create(parent, engine, oclass, NULL, 0x10000,
+				       0x1000, NVOBJ_FLAG_HEAP, &base);
+	*pobject = nv_object(base);
+	if (ret)
+		return ret;
+
+	ret = nvkm_gpuobj_new(device, 0x0200, 0, true, &base->base.gpuobj,
+			      &base->eng);
+	if (ret)
+		return ret;
+
+	ret = nvkm_gpuobj_new(device, 0x4000, 0, false, &base->base.gpuobj,
+			      &base->pgd);
+	if (ret)
+		return ret;
+
+	ret = nvkm_vm_ref(nvkm_client(parent)->vm, &base->vm, base->pgd);
+	if (ret)
+		return ret;
+
+	ret = nvkm_gpuobj_new(device, 0x1000, 0x400, true, &base->base.gpuobj,
+			      &base->cache);
+	if (ret)
+		return ret;
+
+	ret = nvkm_gpuobj_new(device, 0x100, 0x100, true, &base->base.gpuobj,
+			      &base->ramfc);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+struct nvkm_oclass
+g84_fifo_cclass = {
+	.handle = NV_ENGCTX(FIFO, 0x84),
+	.ofuncs = &(struct nvkm_ofuncs) {
+		.ctor = g84_fifo_context_ctor,
+		.dtor = nv50_fifo_context_dtor,
+		.init = _nvkm_fifo_context_init,
+		.fini = _nvkm_fifo_context_fini,
+		.rd32 = _nvkm_fifo_context_rd32,
+		.wr32 = _nvkm_fifo_context_wr32,
+	},
+};
