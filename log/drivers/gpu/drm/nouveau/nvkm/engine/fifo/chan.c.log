commit 832ca2ac3c95feb01e53c24fcd1a00b4cf05cbdc
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:20 2017 +1000

    drm/nouveau: pass handle of vmm object to channel allocation ioctls
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
index ac94b57777c4..d83485385934 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
@@ -27,7 +27,6 @@
 #include <core/gpuobj.h>
 #include <core/oproxy.h>
 #include <subdev/mmu.h>
-#include <subdev/mmu/priv.h>
 #include <engine/dma.h>
 
 struct nvkm_fifo_chan_object {
@@ -353,8 +352,8 @@ nvkm_fifo_chan_func = {
 int
 nvkm_fifo_chan_ctor(const struct nvkm_fifo_chan_func *func,
 		    struct nvkm_fifo *fifo, u32 size, u32 align, bool zero,
-		    u64 vm, u64 push, u64 engines, int bar, u32 base, u32 user,
-		    const struct nvkm_oclass *oclass,
+		    u64 hvmm, u64 push, u64 engines, int bar, u32 base,
+		    u32 user, const struct nvkm_oclass *oclass,
 		    struct nvkm_fifo_chan *chan)
 {
 	struct nvkm_client *client = oclass->client;
@@ -387,8 +386,11 @@ nvkm_fifo_chan_ctor(const struct nvkm_fifo_chan_func *func,
 	}
 
 	/* channel address space */
-	if (!device->mmu->func->vmm.global) {
-		struct nvkm_vmm *vmm = client->vm;
+	if (hvmm) {
+		struct nvkm_vmm *vmm = nvkm_uvmm_search(client, hvmm);
+		if (IS_ERR(vmm))
+			return PTR_ERR(vmm);
+
 		if (vmm->mmu != device->mmu)
 			return -EINVAL;
 

commit f66c57d9229c313de3adf340c604b1c7a40e5306
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/fifo: initialise vmm with new interfaces
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
index 7aea0a8692ae..ac94b57777c4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
@@ -27,6 +27,7 @@
 #include <core/gpuobj.h>
 #include <core/oproxy.h>
 #include <subdev/mmu.h>
+#include <subdev/mmu/priv.h>
 #include <engine/dma.h>
 
 struct nvkm_fifo_chan_object {
@@ -117,8 +118,8 @@ nvkm_fifo_chan_child_del(struct nvkm_oproxy *base)
 		if (chan->func->engine_dtor)
 			chan->func->engine_dtor(chan, engine);
 		nvkm_object_del(&engn->object);
-		if (chan->vm)
-			atomic_dec(&chan->vm->engref[engine->subdev.index]);
+		if (chan->vmm)
+			atomic_dec(&chan->vmm->engref[engine->subdev.index]);
 	}
 }
 
@@ -151,8 +152,8 @@ nvkm_fifo_chan_child_new(const struct nvkm_oclass *oclass, void *data, u32 size,
 			.engine = oclass->engine,
 		};
 
-		if (chan->vm)
-			atomic_inc(&chan->vm->engref[engine->subdev.index]);
+		if (chan->vmm)
+			atomic_inc(&chan->vmm->engref[engine->subdev.index]);
 
 		if (engine->func->fifo.cclass) {
 			ret = engine->func->fifo.cclass(chan, &cclass,
@@ -327,7 +328,10 @@ nvkm_fifo_chan_dtor(struct nvkm_object *object)
 	if (chan->user)
 		iounmap(chan->user);
 
-	nvkm_vm_ref(NULL, &chan->vm, NULL);
+	if (chan->vmm) {
+		nvkm_vmm_part(chan->vmm, chan->inst->memory);
+		nvkm_vmm_unref(&chan->vmm);
+	}
 
 	nvkm_gpuobj_del(&chan->push);
 	nvkm_gpuobj_del(&chan->inst);
@@ -355,7 +359,6 @@ nvkm_fifo_chan_ctor(const struct nvkm_fifo_chan_func *func,
 {
 	struct nvkm_client *client = oclass->client;
 	struct nvkm_device *device = fifo->engine.subdev.device;
-	struct nvkm_mmu *mmu = device->mmu;
 	struct nvkm_dmaobj *dmaobj;
 	unsigned long flags;
 	int ret;
@@ -384,16 +387,16 @@ nvkm_fifo_chan_ctor(const struct nvkm_fifo_chan_func *func,
 	}
 
 	/* channel address space */
-	if (!vm && mmu) {
-		if (!client->vm || client->vm->mmu == mmu) {
-			ret = nvkm_vm_ref(client->vm, &chan->vm, NULL);
-			if (ret)
-				return ret;
-		} else {
+	if (!device->mmu->func->vmm.global) {
+		struct nvkm_vmm *vmm = client->vm;
+		if (vmm->mmu != device->mmu)
 			return -EINVAL;
-		}
-	} else {
-		return -ENOENT;
+
+		ret = nvkm_vmm_join(vmm, chan->inst->memory);
+		if (ret)
+			return ret;
+
+		chan->vmm = nvkm_vmm_ref(vmm);
 	}
 
 	/* allocate channel id */

commit 01326050391ceee2cf1b6c91c108414a35f40861
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/core/object: allow arguments to be passed to map function
    
    MMU will be needing this to specify kind info on BAR mappings.
    
    We have no userspace currently using these interfaces, so break the ABI
    instead of supporting both.  NVIF version bump so any future use can be
    guarded.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
index fab760ae922f..7aea0a8692ae 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
@@ -253,9 +253,11 @@ nvkm_fifo_chan_ntfy(struct nvkm_object *object, u32 type,
 }
 
 static int
-nvkm_fifo_chan_map(struct nvkm_object *object, u64 *addr, u32 *size)
+nvkm_fifo_chan_map(struct nvkm_object *object, void *argv, u32 argc,
+		   enum nvkm_object_map *type, u64 *addr, u64 *size)
 {
 	struct nvkm_fifo_chan *chan = nvkm_fifo_chan(object);
+	*type = NVKM_OBJECT_MAP_IO;
 	*addr = chan->addr;
 	*size = chan->size;
 	return 0;

commit e774055a074b6715193c2984024eecf8fdf8dbd1
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sat Nov 5 13:12:57 2016 +1000

    drm/nouveau/fifo: tidy up channel creation event code
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
index 3b87e09e31ef..fab760ae922f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
@@ -410,6 +410,6 @@ nvkm_fifo_chan_ctor(const struct nvkm_fifo_chan_func *func,
 		     base + user * chan->chid;
 	chan->size = user;
 
-	nvkm_event_send(&fifo->cevent, 1, 0, NULL, 0);
+	nvkm_fifo_cevent(fifo);
 	return 0;
 }

commit 83e85d91b2bc38d4067baf05a7fe9e47436e1d8c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 17 19:40:29 2016 +1000

    drm/nouveau/dma: lookup objects with nvkm_object_search()
    
    Custom code is no longer needed here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
index dc6d4678f228..3b87e09e31ef 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
@@ -371,9 +371,9 @@ nvkm_fifo_chan_ctor(const struct nvkm_fifo_chan_func *func,
 
 	/* allocate push buffer ctxdma instance */
 	if (push) {
-		dmaobj = nvkm_dma_search(device->dma, oclass->client, push);
-		if (!dmaobj)
-			return -ENOENT;
+		dmaobj = nvkm_dmaobj_search(client, push);
+		if (IS_ERR(dmaobj))
+			return PTR_ERR(dmaobj);
 
 		ret = nvkm_object_bind(&dmaobj->object, chan->inst, -16,
 				       &chan->push);

commit 7e8820fed712c6de1933dcc91edbf08dcec74925
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:23 2015 +1000

    drm/nouveau/device: cleaner abstraction for device resource functions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
index 9921482fc162..dc6d4678f228 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
@@ -406,7 +406,7 @@ nvkm_fifo_chan_ctor(const struct nvkm_fifo_chan_func *func,
 	spin_unlock_irqrestore(&fifo->lock, flags);
 
 	/* determine address of this channel's user registers */
-	chan->addr = nv_device_resource_start(device, bar) +
+	chan->addr = device->func->resource_addr(device, bar) +
 		     base + user * chan->chid;
 	chan->size = user;
 

commit fbd58ebda9c8572ca6285b88e3348c7712f125ec
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/object: merge with handle
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
index a56e56eed57b..9921482fc162 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
@@ -116,7 +116,7 @@ nvkm_fifo_chan_child_del(struct nvkm_oproxy *base)
 	if (!--engn->refcount) {
 		if (chan->func->engine_dtor)
 			chan->func->engine_dtor(chan, engine);
-		nvkm_object_ref(NULL, &engn->object);
+		nvkm_object_del(&engn->object);
 		if (chan->vm)
 			atomic_dec(&chan->vm->engref[engine->subdev.index]);
 	}

commit 68f3f702b6a430a8d1e909455a60d26c0f2da530
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/core: remove the remainder of the previous style
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
index 4ed06abdc917..a56e56eed57b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
@@ -332,7 +332,7 @@ nvkm_fifo_chan_dtor(struct nvkm_object *object)
 	return data;
 }
 
-const struct nvkm_object_func
+static const struct nvkm_object_func
 nvkm_fifo_chan_func = {
 	.dtor = nvkm_fifo_chan_dtor,
 	.init = nvkm_fifo_chan_init,

commit 13de7f462902d1a452d501cdb2d06ef02cabbfff
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/fifo: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
index a02c60f340c0..4ed06abdc917 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
@@ -24,6 +24,7 @@
 #include "chan.h"
 
 #include <core/client.h>
+#include <core/gpuobj.h>
 #include <core/oproxy.h>
 #include <subdev/mmu.h>
 #include <engine/dma.h>

commit ef8bc5760b51d69741ed5f42224f1fdd2935541a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/core: kill some (now) dead code
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
index 2735c2df2218..a02c60f340c0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
@@ -128,67 +128,6 @@ nvkm_fifo_chan_child_func = {
 	.fini[0] = nvkm_fifo_chan_child_fini,
 };
 
-static int
-nvkm_fifo_chan_child_old(const struct nvkm_oclass *oclass,
-			 void *data, u32 size, struct nvkm_object **pobject)
-{
-	struct nvkm_fifo_chan *chan = nvkm_fifo_chan(oclass->parent);
-	struct nvkm_object *parent = &chan->object;
-	struct nvkm_engine *engine = oclass->engine;
-	struct nvkm_oclass *eclass = (void *)oclass->priv;
-	struct nvkm_object *engctx = NULL;
-	struct nvkm_fifo_chan_object *object;
-	struct nvkm_fifo_engn *engn = &chan->engn[engine->subdev.index];
-	int ret;
-
-	if (!(object = kzalloc(sizeof(*object), GFP_KERNEL)))
-		return -ENOMEM;
-	nvkm_oproxy_ctor(&nvkm_fifo_chan_child_func, oclass, &object->oproxy);
-	*pobject = &object->oproxy.base;
-	object->chan = chan;
-
-	if (!engn->refcount++) {
-		if (chan->vm)
-			atomic_inc(&chan->vm->engref[engine->subdev.index]);
-		if (engine->cclass && !engn->object) {
-			ret = nvkm_object_old(parent, &engine->subdev.object,
-					      engine->cclass, NULL, 0,
-					      &engn->object);
-			if (ret) {
-				nvkm_engine_unref(&engine);
-				return ret;
-			}
-		} else {
-			nvkm_object_ref(parent, &engn->object);
-		}
-
-		if (chan->func->engine_ctor) {
-			ret = chan->func->engine_ctor(chan, engine,
-						      engn->object);
-			if (ret)
-				return ret;
-		}
-	}
-	nvkm_object_ref(engn->object, &engctx);
-
-	ret = nvkm_object_old(engctx, &engine->subdev.object, eclass,
-			      data, size, &object->oproxy.object);
-	nvkm_object_ref(NULL, &engctx);
-	if (ret)
-		return ret;
-
-	object->oproxy.object->handle = oclass->handle;
-
-	if (chan->func->object_ctor) {
-		object->hash =
-			chan->func->object_ctor(chan, object->oproxy.object);
-		if (object->hash < 0)
-			return object->hash;
-	}
-
-	return 0;
-}
-
 static int
 nvkm_fifo_chan_child_new(const struct nvkm_oclass *oclass, void *data, u32 size,
 			 struct nvkm_object **pobject)
@@ -269,26 +208,6 @@ nvkm_fifo_chan_child_get(struct nvkm_object *object, int index,
 	int ret, i, c;
 
 	for (; c = 0, i = __ffs64(mask), mask; mask &= ~(1ULL << i)) {
-		if ((engine = nvkm_device_engine(device, i)) &&
-		    !engine->func) {
-			struct nvkm_oclass *sclass = engine->sclass;
-			int c = 0;
-			while (sclass && sclass->ofuncs) {
-				if (c++ == index) {
-					oclass->base.oclass = sclass->handle;
-					oclass->base.minver = -2;
-					oclass->base.maxver = -2;
-					oclass->ctor = nvkm_fifo_chan_child_old;
-					oclass->priv = sclass;
-					oclass->engine = engine;
-					return 0;
-				}
-				sclass++;
-			}
-			index -= c;
-			continue;
-		}
-
 		if (!(engine = nvkm_device_engine(device, i)))
 			continue;
 		oclass->engine = engine;

commit 8f0649b5c6e70ec18122255690e39f010c12a614
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/fifo: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
index cc401ae1d6a5..2735c2df2218 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
@@ -24,139 +24,472 @@
 #include "chan.h"
 
 #include <core/client.h>
+#include <core/oproxy.h>
+#include <subdev/mmu.h>
 #include <engine/dma.h>
 
-#include <nvif/class.h>
+struct nvkm_fifo_chan_object {
+	struct nvkm_oproxy oproxy;
+	struct nvkm_fifo_chan *chan;
+	int hash;
+};
 
-int
-_nvkm_fifo_channel_ntfy(struct nvkm_object *object, u32 type,
-			struct nvkm_event **event)
+static int
+nvkm_fifo_chan_child_fini(struct nvkm_oproxy *base, bool suspend)
+{
+	struct nvkm_fifo_chan_object *object =
+		container_of(base, typeof(*object), oproxy);
+	struct nvkm_engine *engine  = object->oproxy.object->engine;
+	struct nvkm_fifo_chan *chan = object->chan;
+	struct nvkm_fifo_engn *engn = &chan->engn[engine->subdev.index];
+	const char *name = nvkm_subdev_name[engine->subdev.index];
+	int ret = 0;
+
+	if (--engn->usecount)
+		return 0;
+
+	if (chan->func->engine_fini) {
+		ret = chan->func->engine_fini(chan, engine, suspend);
+		if (ret) {
+			nvif_error(&chan->object,
+				   "detach %s failed, %d\n", name, ret);
+			return ret;
+		}
+	}
+
+	if (engn->object) {
+		ret = nvkm_object_fini(engn->object, suspend);
+		if (ret && suspend)
+			return ret;
+	}
+
+	nvif_trace(&chan->object, "detached %s\n", name);
+	return ret;
+}
+
+static int
+nvkm_fifo_chan_child_init(struct nvkm_oproxy *base)
+{
+	struct nvkm_fifo_chan_object *object =
+		container_of(base, typeof(*object), oproxy);
+	struct nvkm_engine *engine  = object->oproxy.object->engine;
+	struct nvkm_fifo_chan *chan = object->chan;
+	struct nvkm_fifo_engn *engn = &chan->engn[engine->subdev.index];
+	const char *name = nvkm_subdev_name[engine->subdev.index];
+	int ret;
+
+	if (engn->usecount++)
+		return 0;
+
+	if (engn->object) {
+		ret = nvkm_object_init(engn->object);
+		if (ret)
+			return ret;
+	}
+
+	if (chan->func->engine_init) {
+		ret = chan->func->engine_init(chan, engine);
+		if (ret) {
+			nvif_error(&chan->object,
+				   "attach %s failed, %d\n", name, ret);
+			return ret;
+		}
+	}
+
+	nvif_trace(&chan->object, "attached %s\n", name);
+	return 0;
+}
+
+static void
+nvkm_fifo_chan_child_del(struct nvkm_oproxy *base)
+{
+	struct nvkm_fifo_chan_object *object =
+		container_of(base, typeof(*object), oproxy);
+	struct nvkm_engine *engine  = object->oproxy.base.engine;
+	struct nvkm_fifo_chan *chan = object->chan;
+	struct nvkm_fifo_engn *engn = &chan->engn[engine->subdev.index];
+
+	if (chan->func->object_dtor)
+		chan->func->object_dtor(chan, object->hash);
+
+	if (!--engn->refcount) {
+		if (chan->func->engine_dtor)
+			chan->func->engine_dtor(chan, engine);
+		nvkm_object_ref(NULL, &engn->object);
+		if (chan->vm)
+			atomic_dec(&chan->vm->engref[engine->subdev.index]);
+	}
+}
+
+static const struct nvkm_oproxy_func
+nvkm_fifo_chan_child_func = {
+	.dtor[0] = nvkm_fifo_chan_child_del,
+	.init[0] = nvkm_fifo_chan_child_init,
+	.fini[0] = nvkm_fifo_chan_child_fini,
+};
+
+static int
+nvkm_fifo_chan_child_old(const struct nvkm_oclass *oclass,
+			 void *data, u32 size, struct nvkm_object **pobject)
 {
-	struct nvkm_fifo *fifo = (void *)object->engine;
-	switch (type) {
-	case G82_CHANNEL_DMA_V0_NTFY_UEVENT:
-		if (nv_mclass(object) >= G82_CHANNEL_DMA) {
-			*event = &fifo->uevent;
-			return 0;
+	struct nvkm_fifo_chan *chan = nvkm_fifo_chan(oclass->parent);
+	struct nvkm_object *parent = &chan->object;
+	struct nvkm_engine *engine = oclass->engine;
+	struct nvkm_oclass *eclass = (void *)oclass->priv;
+	struct nvkm_object *engctx = NULL;
+	struct nvkm_fifo_chan_object *object;
+	struct nvkm_fifo_engn *engn = &chan->engn[engine->subdev.index];
+	int ret;
+
+	if (!(object = kzalloc(sizeof(*object), GFP_KERNEL)))
+		return -ENOMEM;
+	nvkm_oproxy_ctor(&nvkm_fifo_chan_child_func, oclass, &object->oproxy);
+	*pobject = &object->oproxy.base;
+	object->chan = chan;
+
+	if (!engn->refcount++) {
+		if (chan->vm)
+			atomic_inc(&chan->vm->engref[engine->subdev.index]);
+		if (engine->cclass && !engn->object) {
+			ret = nvkm_object_old(parent, &engine->subdev.object,
+					      engine->cclass, NULL, 0,
+					      &engn->object);
+			if (ret) {
+				nvkm_engine_unref(&engine);
+				return ret;
+			}
+		} else {
+			nvkm_object_ref(parent, &engn->object);
 		}
-		break;
-	default:
-		break;
+
+		if (chan->func->engine_ctor) {
+			ret = chan->func->engine_ctor(chan, engine,
+						      engn->object);
+			if (ret)
+				return ret;
+		}
+	}
+	nvkm_object_ref(engn->object, &engctx);
+
+	ret = nvkm_object_old(engctx, &engine->subdev.object, eclass,
+			      data, size, &object->oproxy.object);
+	nvkm_object_ref(NULL, &engctx);
+	if (ret)
+		return ret;
+
+	object->oproxy.object->handle = oclass->handle;
+
+	if (chan->func->object_ctor) {
+		object->hash =
+			chan->func->object_ctor(chan, object->oproxy.object);
+		if (object->hash < 0)
+			return object->hash;
 	}
+
+	return 0;
+}
+
+static int
+nvkm_fifo_chan_child_new(const struct nvkm_oclass *oclass, void *data, u32 size,
+			 struct nvkm_object **pobject)
+{
+	struct nvkm_engine *engine = oclass->engine;
+	struct nvkm_fifo_chan *chan = nvkm_fifo_chan(oclass->parent);
+	struct nvkm_fifo_engn *engn = &chan->engn[engine->subdev.index];
+	struct nvkm_fifo_chan_object *object;
+	int ret = 0;
+
+	if (!(object = kzalloc(sizeof(*object), GFP_KERNEL)))
+		return -ENOMEM;
+	nvkm_oproxy_ctor(&nvkm_fifo_chan_child_func, oclass, &object->oproxy);
+	object->chan = chan;
+	*pobject = &object->oproxy.base;
+
+	if (!engn->refcount++) {
+		struct nvkm_oclass cclass = {
+			.client = oclass->client,
+			.engine = oclass->engine,
+		};
+
+		if (chan->vm)
+			atomic_inc(&chan->vm->engref[engine->subdev.index]);
+
+		if (engine->func->fifo.cclass) {
+			ret = engine->func->fifo.cclass(chan, &cclass,
+							&engn->object);
+		} else
+		if (engine->func->cclass) {
+			ret = nvkm_object_new_(engine->func->cclass, &cclass,
+					       NULL, 0, &engn->object);
+		}
+		if (ret)
+			return ret;
+
+		if (chan->func->engine_ctor) {
+			ret = chan->func->engine_ctor(chan, oclass->engine,
+						      engn->object);
+			if (ret)
+				return ret;
+		}
+	}
+
+	ret = oclass->base.ctor(&(const struct nvkm_oclass) {
+					.base = oclass->base,
+					.engn = oclass->engn,
+					.handle = oclass->handle,
+					.object = oclass->object,
+					.client = oclass->client,
+					.parent = engn->object ?
+						  engn->object :
+						  oclass->parent,
+					.engine = engine,
+				}, data, size, &object->oproxy.object);
+	if (ret)
+		return ret;
+
+	if (chan->func->object_ctor) {
+		object->hash =
+			chan->func->object_ctor(chan, object->oproxy.object);
+		if (object->hash < 0)
+			return object->hash;
+	}
+
+	return 0;
+}
+
+static int
+nvkm_fifo_chan_child_get(struct nvkm_object *object, int index,
+			 struct nvkm_oclass *oclass)
+{
+	struct nvkm_fifo_chan *chan = nvkm_fifo_chan(object);
+	struct nvkm_fifo *fifo = chan->fifo;
+	struct nvkm_device *device = fifo->engine.subdev.device;
+	struct nvkm_engine *engine;
+	u64 mask = chan->engines;
+	int ret, i, c;
+
+	for (; c = 0, i = __ffs64(mask), mask; mask &= ~(1ULL << i)) {
+		if ((engine = nvkm_device_engine(device, i)) &&
+		    !engine->func) {
+			struct nvkm_oclass *sclass = engine->sclass;
+			int c = 0;
+			while (sclass && sclass->ofuncs) {
+				if (c++ == index) {
+					oclass->base.oclass = sclass->handle;
+					oclass->base.minver = -2;
+					oclass->base.maxver = -2;
+					oclass->ctor = nvkm_fifo_chan_child_old;
+					oclass->priv = sclass;
+					oclass->engine = engine;
+					return 0;
+				}
+				sclass++;
+			}
+			index -= c;
+			continue;
+		}
+
+		if (!(engine = nvkm_device_engine(device, i)))
+			continue;
+		oclass->engine = engine;
+		oclass->base.oclass = 0;
+
+		if (engine->func->fifo.sclass) {
+			ret = engine->func->fifo.sclass(oclass, index);
+			if (oclass->base.oclass) {
+				if (!oclass->base.ctor)
+					oclass->base.ctor = nvkm_object_new;
+				oclass->ctor = nvkm_fifo_chan_child_new;
+				return 0;
+			}
+
+			index -= ret;
+			continue;
+		}
+
+		while (engine->func->sclass[c].oclass) {
+			if (c++ == index) {
+				oclass->base = engine->func->sclass[index];
+				if (!oclass->base.ctor)
+					oclass->base.ctor = nvkm_object_new;
+				oclass->ctor = nvkm_fifo_chan_child_new;
+				return 0;
+			}
+		}
+		index -= c;
+	}
+
 	return -EINVAL;
 }
 
-int
-_nvkm_fifo_channel_map(struct nvkm_object *object, u64 *addr, u32 *size)
+static int
+nvkm_fifo_chan_ntfy(struct nvkm_object *object, u32 type,
+		    struct nvkm_event **pevent)
 {
-	struct nvkm_fifo_chan *chan = (void *)object;
+	struct nvkm_fifo_chan *chan = nvkm_fifo_chan(object);
+	if (chan->func->ntfy)
+		return chan->func->ntfy(chan, type, pevent);
+	return -ENODEV;
+}
+
+static int
+nvkm_fifo_chan_map(struct nvkm_object *object, u64 *addr, u32 *size)
+{
+	struct nvkm_fifo_chan *chan = nvkm_fifo_chan(object);
 	*addr = chan->addr;
 	*size = chan->size;
 	return 0;
 }
 
-u32
-_nvkm_fifo_channel_rd32(struct nvkm_object *object, u64 addr)
+static int
+nvkm_fifo_chan_rd32(struct nvkm_object *object, u64 addr, u32 *data)
 {
-	struct nvkm_fifo_chan *chan = (void *)object;
+	struct nvkm_fifo_chan *chan = nvkm_fifo_chan(object);
 	if (unlikely(!chan->user)) {
 		chan->user = ioremap(chan->addr, chan->size);
-		if (WARN_ON_ONCE(chan->user == NULL))
-			return 0;
+		if (!chan->user)
+			return -ENOMEM;
 	}
-	return ioread32_native(chan->user + addr);
+	if (unlikely(addr + 4 > chan->size))
+		return -EINVAL;
+	*data = ioread32_native(chan->user + addr);
+	return 0;
 }
 
-void
-_nvkm_fifo_channel_wr32(struct nvkm_object *object, u64 addr, u32 data)
+static int
+nvkm_fifo_chan_wr32(struct nvkm_object *object, u64 addr, u32 data)
 {
-	struct nvkm_fifo_chan *chan = (void *)object;
+	struct nvkm_fifo_chan *chan = nvkm_fifo_chan(object);
 	if (unlikely(!chan->user)) {
 		chan->user = ioremap(chan->addr, chan->size);
-		if (WARN_ON_ONCE(chan->user == NULL))
-			return;
+		if (!chan->user)
+			return -ENOMEM;
 	}
+	if (unlikely(addr + 4 > chan->size))
+		return -EINVAL;
 	iowrite32_native(data, chan->user + addr);
+	return 0;
+}
+
+static int
+nvkm_fifo_chan_fini(struct nvkm_object *object, bool suspend)
+{
+	struct nvkm_fifo_chan *chan = nvkm_fifo_chan(object);
+	chan->func->fini(chan);
+	return 0;
 }
 
-void
-nvkm_fifo_channel_destroy(struct nvkm_fifo_chan *chan)
+static int
+nvkm_fifo_chan_init(struct nvkm_object *object)
 {
-	struct nvkm_fifo *fifo = (void *)nv_object(chan)->engine;
+	struct nvkm_fifo_chan *chan = nvkm_fifo_chan(object);
+	chan->func->init(chan);
+	return 0;
+}
+
+static void *
+nvkm_fifo_chan_dtor(struct nvkm_object *object)
+{
+	struct nvkm_fifo_chan *chan = nvkm_fifo_chan(object);
+	struct nvkm_fifo *fifo = chan->fifo;
+	void *data = chan->func->dtor(chan);
 	unsigned long flags;
 
+	spin_lock_irqsave(&fifo->lock, flags);
+	if (!list_empty(&chan->head)) {
+		__clear_bit(chan->chid, fifo->mask);
+		list_del(&chan->head);
+	}
+	spin_unlock_irqrestore(&fifo->lock, flags);
+
 	if (chan->user)
 		iounmap(chan->user);
 
-	spin_lock_irqsave(&fifo->lock, flags);
-	fifo->channel[chan->chid] = NULL;
-	spin_unlock_irqrestore(&fifo->lock, flags);
+	nvkm_vm_ref(NULL, &chan->vm, NULL);
 
-	nvkm_gpuobj_del(&chan->pushgpu);
-	nvkm_namedb_destroy(&chan->namedb);
+	nvkm_gpuobj_del(&chan->push);
+	nvkm_gpuobj_del(&chan->inst);
+	return data;
 }
 
-void
-_nvkm_fifo_channel_dtor(struct nvkm_object *object)
-{
-	struct nvkm_fifo_chan *chan = (void *)object;
-	nvkm_fifo_channel_destroy(chan);
-}
+const struct nvkm_object_func
+nvkm_fifo_chan_func = {
+	.dtor = nvkm_fifo_chan_dtor,
+	.init = nvkm_fifo_chan_init,
+	.fini = nvkm_fifo_chan_fini,
+	.ntfy = nvkm_fifo_chan_ntfy,
+	.map = nvkm_fifo_chan_map,
+	.rd32 = nvkm_fifo_chan_rd32,
+	.wr32 = nvkm_fifo_chan_wr32,
+	.sclass = nvkm_fifo_chan_child_get,
+};
 
 int
-nvkm_fifo_channel_create_(struct nvkm_object *parent,
-			  struct nvkm_object *engine,
-			  struct nvkm_oclass *oclass,
-			  int bar, u32 addr, u32 size, u64 pushbuf,
-			  u64 engmask, int len, void **ptr)
+nvkm_fifo_chan_ctor(const struct nvkm_fifo_chan_func *func,
+		    struct nvkm_fifo *fifo, u32 size, u32 align, bool zero,
+		    u64 vm, u64 push, u64 engines, int bar, u32 base, u32 user,
+		    const struct nvkm_oclass *oclass,
+		    struct nvkm_fifo_chan *chan)
 {
-	struct nvkm_client *client = nvkm_client(parent);
-	struct nvkm_fifo *fifo = (void *)engine;
-	struct nvkm_fifo_base *base = (void *)parent;
-	struct nvkm_fifo_chan *chan;
-	struct nvkm_subdev *subdev = &fifo->engine.subdev;
-	struct nvkm_device *device = subdev->device;
+	struct nvkm_client *client = oclass->client;
+	struct nvkm_device *device = fifo->engine.subdev.device;
+	struct nvkm_mmu *mmu = device->mmu;
 	struct nvkm_dmaobj *dmaobj;
 	unsigned long flags;
 	int ret;
 
-	/* create base object class */
-	ret = nvkm_namedb_create_(parent, engine, oclass, 0, NULL,
-				  engmask, len, ptr);
-	chan = *ptr;
+	nvkm_object_ctor(&nvkm_fifo_chan_func, oclass, &chan->object);
+	chan->func = func;
+	chan->fifo = fifo;
+	chan->engines = engines;
+	INIT_LIST_HEAD(&chan->head);
+
+	/* instance memory */
+	ret = nvkm_gpuobj_new(device, size, align, zero, NULL, &chan->inst);
 	if (ret)
 		return ret;
 
-	/* validate dma object representing push buffer */
-	if (pushbuf) {
-		dmaobj = nvkm_dma_search(device->dma, client, pushbuf);
+	/* allocate push buffer ctxdma instance */
+	if (push) {
+		dmaobj = nvkm_dma_search(device->dma, oclass->client, push);
 		if (!dmaobj)
 			return -ENOENT;
 
-		ret = nvkm_object_bind(&dmaobj->object, &base->gpuobj, 16,
-				       &chan->pushgpu);
+		ret = nvkm_object_bind(&dmaobj->object, chan->inst, -16,
+				       &chan->push);
 		if (ret)
 			return ret;
 	}
 
-	/* find a free fifo channel */
-	spin_lock_irqsave(&fifo->lock, flags);
-	for (chan->chid = fifo->min; chan->chid < fifo->max; chan->chid++) {
-		if (!fifo->channel[chan->chid]) {
-			fifo->channel[chan->chid] = nv_object(chan);
-			break;
+	/* channel address space */
+	if (!vm && mmu) {
+		if (!client->vm || client->vm->mmu == mmu) {
+			ret = nvkm_vm_ref(client->vm, &chan->vm, NULL);
+			if (ret)
+				return ret;
+		} else {
+			return -EINVAL;
 		}
+	} else {
+		return -ENOENT;
 	}
-	spin_unlock_irqrestore(&fifo->lock, flags);
 
-	if (chan->chid == fifo->max) {
-		nvkm_error(subdev, "no free channels\n");
+	/* allocate channel id */
+	spin_lock_irqsave(&fifo->lock, flags);
+	chan->chid = find_first_zero_bit(fifo->mask, NVKM_FIFO_CHID_NR);
+	if (chan->chid >= NVKM_FIFO_CHID_NR) {
+		spin_unlock_irqrestore(&fifo->lock, flags);
 		return -ENOSPC;
 	}
+	list_add(&chan->head, &fifo->chan);
+	__set_bit(chan->chid, fifo->mask);
+	spin_unlock_irqrestore(&fifo->lock, flags);
 
+	/* determine address of this channel's user registers */
 	chan->addr = nv_device_resource_start(device, bar) +
-		     addr + size * chan->chid;
-	chan->size = size;
+		     base + user * chan->chid;
+	chan->size = user;
+
 	nvkm_event_send(&fifo->cevent, 1, 0, NULL, 0);
 	return 0;
 }

commit 9a65a38c456ebac97f0498e85fe26f6d26fe3936
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/fifo: split user classes out from engine implementations
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
new file mode 100644
index 000000000000..cc401ae1d6a5
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/chan.c
@@ -0,0 +1,162 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+#include "chan.h"
+
+#include <core/client.h>
+#include <engine/dma.h>
+
+#include <nvif/class.h>
+
+int
+_nvkm_fifo_channel_ntfy(struct nvkm_object *object, u32 type,
+			struct nvkm_event **event)
+{
+	struct nvkm_fifo *fifo = (void *)object->engine;
+	switch (type) {
+	case G82_CHANNEL_DMA_V0_NTFY_UEVENT:
+		if (nv_mclass(object) >= G82_CHANNEL_DMA) {
+			*event = &fifo->uevent;
+			return 0;
+		}
+		break;
+	default:
+		break;
+	}
+	return -EINVAL;
+}
+
+int
+_nvkm_fifo_channel_map(struct nvkm_object *object, u64 *addr, u32 *size)
+{
+	struct nvkm_fifo_chan *chan = (void *)object;
+	*addr = chan->addr;
+	*size = chan->size;
+	return 0;
+}
+
+u32
+_nvkm_fifo_channel_rd32(struct nvkm_object *object, u64 addr)
+{
+	struct nvkm_fifo_chan *chan = (void *)object;
+	if (unlikely(!chan->user)) {
+		chan->user = ioremap(chan->addr, chan->size);
+		if (WARN_ON_ONCE(chan->user == NULL))
+			return 0;
+	}
+	return ioread32_native(chan->user + addr);
+}
+
+void
+_nvkm_fifo_channel_wr32(struct nvkm_object *object, u64 addr, u32 data)
+{
+	struct nvkm_fifo_chan *chan = (void *)object;
+	if (unlikely(!chan->user)) {
+		chan->user = ioremap(chan->addr, chan->size);
+		if (WARN_ON_ONCE(chan->user == NULL))
+			return;
+	}
+	iowrite32_native(data, chan->user + addr);
+}
+
+void
+nvkm_fifo_channel_destroy(struct nvkm_fifo_chan *chan)
+{
+	struct nvkm_fifo *fifo = (void *)nv_object(chan)->engine;
+	unsigned long flags;
+
+	if (chan->user)
+		iounmap(chan->user);
+
+	spin_lock_irqsave(&fifo->lock, flags);
+	fifo->channel[chan->chid] = NULL;
+	spin_unlock_irqrestore(&fifo->lock, flags);
+
+	nvkm_gpuobj_del(&chan->pushgpu);
+	nvkm_namedb_destroy(&chan->namedb);
+}
+
+void
+_nvkm_fifo_channel_dtor(struct nvkm_object *object)
+{
+	struct nvkm_fifo_chan *chan = (void *)object;
+	nvkm_fifo_channel_destroy(chan);
+}
+
+int
+nvkm_fifo_channel_create_(struct nvkm_object *parent,
+			  struct nvkm_object *engine,
+			  struct nvkm_oclass *oclass,
+			  int bar, u32 addr, u32 size, u64 pushbuf,
+			  u64 engmask, int len, void **ptr)
+{
+	struct nvkm_client *client = nvkm_client(parent);
+	struct nvkm_fifo *fifo = (void *)engine;
+	struct nvkm_fifo_base *base = (void *)parent;
+	struct nvkm_fifo_chan *chan;
+	struct nvkm_subdev *subdev = &fifo->engine.subdev;
+	struct nvkm_device *device = subdev->device;
+	struct nvkm_dmaobj *dmaobj;
+	unsigned long flags;
+	int ret;
+
+	/* create base object class */
+	ret = nvkm_namedb_create_(parent, engine, oclass, 0, NULL,
+				  engmask, len, ptr);
+	chan = *ptr;
+	if (ret)
+		return ret;
+
+	/* validate dma object representing push buffer */
+	if (pushbuf) {
+		dmaobj = nvkm_dma_search(device->dma, client, pushbuf);
+		if (!dmaobj)
+			return -ENOENT;
+
+		ret = nvkm_object_bind(&dmaobj->object, &base->gpuobj, 16,
+				       &chan->pushgpu);
+		if (ret)
+			return ret;
+	}
+
+	/* find a free fifo channel */
+	spin_lock_irqsave(&fifo->lock, flags);
+	for (chan->chid = fifo->min; chan->chid < fifo->max; chan->chid++) {
+		if (!fifo->channel[chan->chid]) {
+			fifo->channel[chan->chid] = nv_object(chan);
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&fifo->lock, flags);
+
+	if (chan->chid == fifo->max) {
+		nvkm_error(subdev, "no free channels\n");
+		return -ENOSPC;
+	}
+
+	chan->addr = nv_device_resource_start(device, bar) +
+		     addr + size * chan->chid;
+	chan->size = size;
+	nvkm_event_send(&fifo->cevent, 1, 0, NULL, 0);
+	return 0;
+}
