commit 0233a9f403973c107a2937ed42f3d588e5f1811b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Dec 21 12:46:50 2016 +1000

    drm/nouveau/gr/nv50-mcp89: add defines for gr classes
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index fca67de43f2b..df16ffda1749 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -27,6 +27,8 @@
 #include <core/gpuobj.h>
 #include <engine/fifo.h>
 
+#include <nvif/class.h>
+
 u64
 nv50_gr_units(struct nvkm_gr *gr)
 {
@@ -778,11 +780,11 @@ nv50_gr = {
 	.chan_new = nv50_gr_chan_new,
 	.units = nv50_gr_units,
 	.sclass = {
-		{ -1, -1, 0x0030, &nv50_gr_object },
-		{ -1, -1, 0x502d, &nv50_gr_object },
-		{ -1, -1, 0x5039, &nv50_gr_object },
-		{ -1, -1, 0x5097, &nv50_gr_object },
-		{ -1, -1, 0x50c0, &nv50_gr_object },
+		{ -1, -1, NV_NULL_CLASS, &nv50_gr_object },
+		{ -1, -1, NV50_TWOD, &nv50_gr_object },
+		{ -1, -1, NV50_MEMORY_TO_MEMORY_FORMAT, &nv50_gr_object },
+		{ -1, -1, NV50_TESLA, &nv50_gr_object },
+		{ -1, -1, NV50_COMPUTE, &nv50_gr_object },
 		{}
 	}
 };

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index b19b912d5787..fca67de43f2b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -768,7 +768,7 @@ nv50_gr_new_(const struct nvkm_gr_func *func, struct nvkm_device *device,
 	spin_lock_init(&gr->lock);
 	*pgr = &gr->base;
 
-	return nvkm_gr_ctor(func, device, index, 0x00201000, true, &gr->base);
+	return nvkm_gr_ctor(func, device, index, true, &gr->base);
 }
 
 static const struct nvkm_gr_func

commit 68f3f702b6a430a8d1e909455a60d26c0f2da530
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/core: remove the remainder of the previous style
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index 9992a919a6d9..b19b912d5787 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -45,7 +45,7 @@ nv50_gr_object_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,
 				  align, false, parent, pgpuobj);
 	if (ret == 0) {
 		nvkm_kmap(*pgpuobj);
-		nvkm_wo32(*pgpuobj, 0x00, object->oclass_name);
+		nvkm_wo32(*pgpuobj, 0x00, object->oclass);
 		nvkm_wo32(*pgpuobj, 0x04, 0x00000000);
 		nvkm_wo32(*pgpuobj, 0x08, 0x00000000);
 		nvkm_wo32(*pgpuobj, 0x0c, 0x00000000);

commit c85ee6ca79590cd51356bf24fb8936bc352138cf
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/gr: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index 11c4c8838937..9992a919a6d9 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -25,10 +25,9 @@
 
 #include <core/client.h>
 #include <core/gpuobj.h>
-#include <subdev/timer.h>
 #include <engine/fifo.h>
 
-static u64
+u64
 nv50_gr_units(struct nvkm_gr *gr)
 {
 	return nvkm_rd32(gr->engine.subdev.device, 0x1540);
@@ -55,27 +54,11 @@ nv50_gr_object_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,
 	return ret;
 }
 
-static const struct nvkm_object_func
+const struct nvkm_object_func
 nv50_gr_object = {
 	.bind = nv50_gr_object_bind,
 };
 
-static int
-nv50_gr_object_get(struct nvkm_gr *base, int index, struct nvkm_sclass *sclass)
-{
-	struct nv50_gr *gr = nv50_gr(base);
-	int c = 0;
-
-	while (gr->func->sclass[c].oclass) {
-		if (c++ == index) {
-			*sclass = gr->func->sclass[index];
-			return index;
-		}
-	}
-
-	return c;
-}
-
 /*******************************************************************************
  * PGRAPH context
  ******************************************************************************/
@@ -100,7 +83,7 @@ nv50_gr_chan = {
 	.bind = nv50_gr_chan_bind,
 };
 
-static int
+int
 nv50_gr_chan_new(struct nvkm_gr *base, struct nvkm_fifo_chan *fifoch,
 		 const struct nvkm_oclass *oclass, struct nvkm_object **pobject)
 {
@@ -119,153 +102,6 @@ nv50_gr_chan_new(struct nvkm_gr *base, struct nvkm_fifo_chan *fifoch,
  * PGRAPH engine/subdev functions
  ******************************************************************************/
 
-static const struct nvkm_bitfield nv50_gr_status[] = {
-	{ 0x00000001, "BUSY" }, /* set when any bit is set */
-	{ 0x00000002, "DISPATCH" },
-	{ 0x00000004, "UNK2" },
-	{ 0x00000008, "UNK3" },
-	{ 0x00000010, "UNK4" },
-	{ 0x00000020, "UNK5" },
-	{ 0x00000040, "M2MF" },
-	{ 0x00000080, "UNK7" },
-	{ 0x00000100, "CTXPROG" },
-	{ 0x00000200, "VFETCH" },
-	{ 0x00000400, "CCACHE_PREGEOM" },
-	{ 0x00000800, "STRMOUT_VATTR_POSTGEOM" },
-	{ 0x00001000, "VCLIP" },
-	{ 0x00002000, "RATTR_APLANE" },
-	{ 0x00004000, "TRAST" },
-	{ 0x00008000, "CLIPID" },
-	{ 0x00010000, "ZCULL" },
-	{ 0x00020000, "ENG2D" },
-	{ 0x00040000, "RMASK" },
-	{ 0x00080000, "TPC_RAST" },
-	{ 0x00100000, "TPC_PROP" },
-	{ 0x00200000, "TPC_TEX" },
-	{ 0x00400000, "TPC_GEOM" },
-	{ 0x00800000, "TPC_MP" },
-	{ 0x01000000, "ROP" },
-	{}
-};
-
-static const struct nvkm_bitfield
-nv50_gr_vstatus_0[] = {
-	{ 0x01, "VFETCH" },
-	{ 0x02, "CCACHE" },
-	{ 0x04, "PREGEOM" },
-	{ 0x08, "POSTGEOM" },
-	{ 0x10, "VATTR" },
-	{ 0x20, "STRMOUT" },
-	{ 0x40, "VCLIP" },
-	{}
-};
-
-static const struct nvkm_bitfield
-nv50_gr_vstatus_1[] = {
-	{ 0x01, "TPC_RAST" },
-	{ 0x02, "TPC_PROP" },
-	{ 0x04, "TPC_TEX" },
-	{ 0x08, "TPC_GEOM" },
-	{ 0x10, "TPC_MP" },
-	{}
-};
-
-static const struct nvkm_bitfield
-nv50_gr_vstatus_2[] = {
-	{ 0x01, "RATTR" },
-	{ 0x02, "APLANE" },
-	{ 0x04, "TRAST" },
-	{ 0x08, "CLIPID" },
-	{ 0x10, "ZCULL" },
-	{ 0x20, "ENG2D" },
-	{ 0x40, "RMASK" },
-	{ 0x80, "ROP" },
-	{}
-};
-
-static void
-nvkm_gr_vstatus_print(struct nv50_gr *gr, int r,
-		      const struct nvkm_bitfield *units, u32 status)
-{
-	struct nvkm_subdev *subdev = &gr->base.engine.subdev;
-	u32 stat = status;
-	u8  mask = 0x00;
-	char msg[64];
-	int i;
-
-	for (i = 0; units[i].name && status; i++) {
-		if ((status & 7) == 1)
-			mask |= (1 << i);
-		status >>= 3;
-	}
-
-	nvkm_snprintbf(msg, sizeof(msg), units, mask);
-	nvkm_error(subdev, "PGRAPH_VSTATUS%d: %08x [%s]\n", r, stat, msg);
-}
-
-static int
-g84_gr_tlb_flush(struct nvkm_engine *engine)
-{
-	struct nv50_gr *gr = (void *)engine;
-	struct nvkm_subdev *subdev = &gr->base.engine.subdev;
-	struct nvkm_device *device = subdev->device;
-	struct nvkm_timer *tmr = device->timer;
-	bool idle, timeout = false;
-	unsigned long flags;
-	char status[128];
-	u64 start;
-	u32 tmp;
-
-	spin_lock_irqsave(&gr->lock, flags);
-	nvkm_mask(device, 0x400500, 0x00000001, 0x00000000);
-
-	start = nvkm_timer_read(tmr);
-	do {
-		idle = true;
-
-		for (tmp = nvkm_rd32(device, 0x400380); tmp && idle; tmp >>= 3) {
-			if ((tmp & 7) == 1)
-				idle = false;
-		}
-
-		for (tmp = nvkm_rd32(device, 0x400384); tmp && idle; tmp >>= 3) {
-			if ((tmp & 7) == 1)
-				idle = false;
-		}
-
-		for (tmp = nvkm_rd32(device, 0x400388); tmp && idle; tmp >>= 3) {
-			if ((tmp & 7) == 1)
-				idle = false;
-		}
-	} while (!idle &&
-		 !(timeout = nvkm_timer_read(tmr) - start > 2000000000));
-
-	if (timeout) {
-		nvkm_error(subdev, "PGRAPH TLB flush idle timeout fail\n");
-
-		tmp = nvkm_rd32(device, 0x400700);
-		nvkm_snprintbf(status, sizeof(status), nv50_gr_status, tmp);
-		nvkm_error(subdev, "PGRAPH_STATUS %08x [%s]\n", tmp, status);
-
-		nvkm_gr_vstatus_print(gr, 0, nv50_gr_vstatus_0,
-				       nvkm_rd32(device, 0x400380));
-		nvkm_gr_vstatus_print(gr, 1, nv50_gr_vstatus_1,
-				       nvkm_rd32(device, 0x400384));
-		nvkm_gr_vstatus_print(gr, 2, nv50_gr_vstatus_2,
-				       nvkm_rd32(device, 0x400388));
-	}
-
-
-	nvkm_wr32(device, 0x100c80, 0x00000001);
-	nvkm_msec(device, 2000,
-		if (!(nvkm_rd32(device, 0x100c80) & 0x00000001))
-			break;
-	);
-	nvkm_mask(device, 0x400500, 0x00000001, 0x00000001);
-	spin_unlock_irqrestore(&gr->lock, flags);
-	return timeout ? -EBUSY : 0;
-}
-
 static const struct nvkm_bitfield nv50_mp_exec_errors[] = {
 	{ 0x01, "STACK_UNDERFLOW" },
 	{ 0x02, "STACK_MISMATCH" },
@@ -453,7 +289,7 @@ nv50_gr_mp_trap(struct nv50_gr *gr, int tpid, int display)
 	for (i = 0; i < 4; i++) {
 		if (!(units & 1 << (i+24)))
 			continue;
-		if (nv_device(gr)->chipset < 0xa0)
+		if (device->chipset < 0xa0)
 			addr = 0x408200 + (tpid << 12) + (i << 7);
 		else
 			addr = 0x408100 + (tpid << 11) + (i << 7);
@@ -497,7 +333,7 @@ nv50_gr_tp_trap(struct nv50_gr *gr, int type, u32 ustatus_old,
 	for (i = 0; i < 16; i++) {
 		if (!(units & (1 << i)))
 			continue;
-		if (nv_device(gr)->chipset < 0xa0)
+		if (device->chipset < 0xa0)
 			ustatus_addr = ustatus_old + (i << 12);
 		else
 			ustatus_addr = ustatus_new + (i << 11);
@@ -778,11 +614,12 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 	return 1;
 }
 
-static void
-nv50_gr_intr(struct nvkm_subdev *subdev)
+void
+nv50_gr_intr(struct nvkm_gr *base)
 {
-	struct nv50_gr *gr = (void *)subdev;
-	struct nvkm_device *device = gr->base.engine.subdev.device;
+	struct nv50_gr *gr = nv50_gr(base);
+	struct nvkm_subdev *subdev = &gr->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	struct nvkm_fifo_chan *chan;
 	u32 stat = nvkm_rd32(device, 0x400100);
 	u32 inst = nvkm_rd32(device, 0x40032c) & 0x0fffffff;
@@ -836,140 +673,13 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 	nvkm_fifo_chan_put(device->fifo, flags, &chan);
 }
 
-static const struct nv50_gr_func
-nv50_gr = {
-	.sclass = {
-		{ -1, -1, 0x0030, &nv50_gr_object },
-		{ -1, -1, 0x502d, &nv50_gr_object },
-		{ -1, -1, 0x5039, &nv50_gr_object },
-		{ -1, -1, 0x5097, &nv50_gr_object },
-		{ -1, -1, 0x50c0, &nv50_gr_object },
-		{}
-	}
-};
-
-static const struct nv50_gr_func
-g84_gr = {
-	.sclass = {
-		{ -1, -1, 0x0030, &nv50_gr_object },
-		{ -1, -1, 0x502d, &nv50_gr_object },
-		{ -1, -1, 0x5039, &nv50_gr_object },
-		{ -1, -1, 0x50c0, &nv50_gr_object },
-		{ -1, -1, 0x8297, &nv50_gr_object },
-		{}
-	}
-};
-
-static const struct nv50_gr_func
-gt200_gr = {
-	.sclass = {
-		{ -1, -1, 0x0030, &nv50_gr_object },
-		{ -1, -1, 0x502d, &nv50_gr_object },
-		{ -1, -1, 0x5039, &nv50_gr_object },
-		{ -1, -1, 0x50c0, &nv50_gr_object },
-		{ -1, -1, 0x8397, &nv50_gr_object },
-		{}
-	}
-};
-
-static const struct nv50_gr_func
-gt215_gr = {
-	.sclass = {
-		{ -1, -1, 0x0030, &nv50_gr_object },
-		{ -1, -1, 0x502d, &nv50_gr_object },
-		{ -1, -1, 0x5039, &nv50_gr_object },
-		{ -1, -1, 0x50c0, &nv50_gr_object },
-		{ -1, -1, 0x8597, &nv50_gr_object },
-		{ -1, -1, 0x85c0, &nv50_gr_object },
-		{}
-	}
-};
-
-static const struct nv50_gr_func
-mcp89_gr = {
-	.sclass = {
-		{ -1, -1, 0x0030, &nv50_gr_object },
-		{ -1, -1, 0x502d, &nv50_gr_object },
-		{ -1, -1, 0x5039, &nv50_gr_object },
-		{ -1, -1, 0x50c0, &nv50_gr_object },
-		{ -1, -1, 0x85c0, &nv50_gr_object },
-		{ -1, -1, 0x8697, &nv50_gr_object },
-		{}
-	}
-};
-
-static const struct nvkm_gr_func
-nv50_gr_ = {
-	.chan_new = nv50_gr_chan_new,
-	.object_get = nv50_gr_object_get,
-};
-
-static int
-nv50_gr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-	     struct nvkm_oclass *oclass, void *data, u32 size,
-	     struct nvkm_object **pobject)
-{
-	struct nv50_gr *gr;
-	int ret;
-
-	ret = nvkm_gr_create(parent, engine, oclass, true, &gr);
-	*pobject = nv_object(gr);
-	if (ret)
-		return ret;
-
-	nv_subdev(gr)->unit = 0x00201000;
-	nv_subdev(gr)->intr = nv50_gr_intr;
-
-	gr->base.func = &nv50_gr_;
-	gr->base.units = nv50_gr_units;
-
-	switch (nv_device(gr)->chipset) {
-	case 0x50:
-		gr->func = &nv50_gr;
-		break;
-	case 0x84:
-	case 0x86:
-	case 0x92:
-	case 0x94:
-	case 0x96:
-	case 0x98:
-		gr->func = &g84_gr;
-		break;
-	case 0xa0:
-	case 0xaa:
-	case 0xac:
-		gr->func = &gt200_gr;
-		break;
-	case 0xa3:
-	case 0xa5:
-	case 0xa8:
-		gr->func = &gt215_gr;
-		break;
-	case 0xaf:
-		gr->func = &mcp89_gr;
-		break;
-	}
-
-	/* unfortunate hw bug workaround... */
-	if (nv_device(gr)->chipset != 0x50 &&
-	    nv_device(gr)->chipset != 0xac)
-		nv_engine(gr)->tlb_flush = g84_gr_tlb_flush;
-
-	spin_lock_init(&gr->lock);
-	return 0;
-}
-
-static int
-nv50_gr_init(struct nvkm_object *object)
+int
+nv50_gr_init(struct nvkm_gr *base)
 {
-	struct nv50_gr *gr = (void *)object;
+	struct nv50_gr *gr = nv50_gr(base);
 	struct nvkm_device *device = gr->base.engine.subdev.device;
 	int ret, units, i;
 
-	ret = nvkm_gr_init(&gr->base);
-	if (ret)
-		return ret;
-
 	/* NV_PGRAPH_DEBUG_3_HW_CTX_SWITCH_ENABLED */
 	nvkm_wr32(device, 0x40008c, 0x00000004);
 
@@ -986,7 +696,7 @@ nv50_gr_init(struct nvkm_object *object)
 		if (!(units & (1 << i)))
 			continue;
 
-		if (nv_device(gr)->chipset < 0xa0) {
+		if (device->chipset < 0xa0) {
 			nvkm_wr32(device, 0x408900 + (i << 12), 0xc0000000);
 			nvkm_wr32(device, 0x408e08 + (i << 12), 0xc0000000);
 			nvkm_wr32(device, 0x408314 + (i << 12), 0xc0000000);
@@ -1004,7 +714,7 @@ nv50_gr_init(struct nvkm_object *object)
 	nvkm_wr32(device, 0x400500, 0x00010001);
 
 	/* upload context program, initialise ctxctl defaults */
-	ret = nv50_grctx_init(nv_device(gr), &gr->size);
+	ret = nv50_grctx_init(device, &gr->size);
 	if (ret)
 		return ret;
 
@@ -1016,7 +726,7 @@ nv50_gr_init(struct nvkm_object *object)
 	nvkm_wr32(device, 0x400330, 0x00000000);
 
 	/* some unknown zcull magic */
-	switch (nv_device(gr)->chipset & 0xf0) {
+	switch (device->chipset & 0xf0) {
 	case 0x50:
 	case 0x80:
 	case 0x90:
@@ -1024,9 +734,9 @@ nv50_gr_init(struct nvkm_object *object)
 		break;
 	case 0xa0:
 	default:
-		if (nv_device(gr)->chipset == 0xa0 ||
-		    nv_device(gr)->chipset == 0xaa ||
-		    nv_device(gr)->chipset == 0xac) {
+		if (device->chipset == 0xa0 ||
+		    device->chipset == 0xaa ||
+		    device->chipset == 0xac) {
 			nvkm_wr32(device, 0x402ca8, 0x00000802);
 		} else {
 			nvkm_wr32(device, 0x402cc0, 0x00000000);
@@ -1043,16 +753,42 @@ nv50_gr_init(struct nvkm_object *object)
 		nvkm_wr32(device, 0x402c28 + (i * 0x10), 0x00000000);
 		nvkm_wr32(device, 0x402c2c + (i * 0x10), 0x00000000);
 	}
+
 	return 0;
 }
 
-struct nvkm_oclass
-nv50_gr_oclass = {
-	.handle = NV_ENGINE(GR, 0x50),
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nv50_gr_ctor,
-		.dtor = _nvkm_gr_dtor,
-		.init = nv50_gr_init,
-		.fini = _nvkm_gr_fini,
-	},
+int
+nv50_gr_new_(const struct nvkm_gr_func *func, struct nvkm_device *device,
+	     int index, struct nvkm_gr **pgr)
+{
+	struct nv50_gr *gr;
+
+	if (!(gr = kzalloc(sizeof(*gr), GFP_KERNEL)))
+		return -ENOMEM;
+	spin_lock_init(&gr->lock);
+	*pgr = &gr->base;
+
+	return nvkm_gr_ctor(func, device, index, 0x00201000, true, &gr->base);
+}
+
+static const struct nvkm_gr_func
+nv50_gr = {
+	.init = nv50_gr_init,
+	.intr = nv50_gr_intr,
+	.chan_new = nv50_gr_chan_new,
+	.units = nv50_gr_units,
+	.sclass = {
+		{ -1, -1, 0x0030, &nv50_gr_object },
+		{ -1, -1, 0x502d, &nv50_gr_object },
+		{ -1, -1, 0x5039, &nv50_gr_object },
+		{ -1, -1, 0x5097, &nv50_gr_object },
+		{ -1, -1, 0x50c0, &nv50_gr_object },
+		{}
+	}
 };
+
+int
+nv50_gr_new(struct nvkm_device *device, int index, struct nvkm_gr **pgr)
+{
+	return nv50_gr_new_(&nv50_gr, device, index, pgr);
+}

commit 13de7f462902d1a452d501cdb2d06ef02cabbfff
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/fifo: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index 2a5bc9270fb9..11c4c8838937 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -24,6 +24,7 @@
 #include "nv50.h"
 
 #include <core/client.h>
+#include <core/gpuobj.h>
 #include <subdev/timer.h>
 #include <engine/fifo.h>
 

commit 31649ecf47a44e02e73bffc5680c8f56d6cf587a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:21 2015 +1000

    drm/nouveau/tmr: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index 403d2c9aff3b..2a5bc9270fb9 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -218,7 +218,7 @@ g84_gr_tlb_flush(struct nvkm_engine *engine)
 	spin_lock_irqsave(&gr->lock, flags);
 	nvkm_mask(device, 0x400500, 0x00000001, 0x00000000);
 
-	start = tmr->read(tmr);
+	start = nvkm_timer_read(tmr);
 	do {
 		idle = true;
 
@@ -237,7 +237,7 @@ g84_gr_tlb_flush(struct nvkm_engine *engine)
 				idle = false;
 		}
 	} while (!idle &&
-		 !(timeout = tmr->read(tmr) - start > 2000000000));
+		 !(timeout = nvkm_timer_read(tmr) - start > 2000000000));
 
 	if (timeout) {
 		nvkm_error(subdev, "PGRAPH TLB flush idle timeout fail\n");

commit 27f3d6cf80324940edd29be7758f81145e73d1ff
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/gr: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index 5f22dd3c788c..403d2c9aff3b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -27,16 +27,6 @@
 #include <subdev/timer.h>
 #include <engine/fifo.h>
 
-struct nv50_gr {
-	struct nvkm_gr base;
-	spinlock_t lock;
-	u32 size;
-};
-
-struct nv50_gr_chan {
-	struct nvkm_gr_chan base;
-};
-
 static u64
 nv50_gr_units(struct nvkm_gr *gr)
 {
@@ -48,126 +38,82 @@ nv50_gr_units(struct nvkm_gr *gr)
  ******************************************************************************/
 
 static int
-nv50_gr_object_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-		    struct nvkm_oclass *oclass, void *data, u32 size,
-		    struct nvkm_object **pobject)
+nv50_gr_object_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,
+		    int align, struct nvkm_gpuobj **pgpuobj)
 {
-	struct nvkm_gpuobj *obj;
-	int ret;
-
-	ret = nvkm_gpuobj_create(parent, engine, oclass, 0, parent,
-				 16, 16, 0, &obj);
-	*pobject = nv_object(obj);
-	if (ret)
-		return ret;
-
-	nvkm_kmap(obj);
-	nvkm_wo32(obj, 0x00, nv_mclass(obj));
-	nvkm_wo32(obj, 0x04, 0x00000000);
-	nvkm_wo32(obj, 0x08, 0x00000000);
-	nvkm_wo32(obj, 0x0c, 0x00000000);
-	nvkm_done(obj);
-	return 0;
+	int ret = nvkm_gpuobj_new(object->engine->subdev.device, 16,
+				  align, false, parent, pgpuobj);
+	if (ret == 0) {
+		nvkm_kmap(*pgpuobj);
+		nvkm_wo32(*pgpuobj, 0x00, object->oclass_name);
+		nvkm_wo32(*pgpuobj, 0x04, 0x00000000);
+		nvkm_wo32(*pgpuobj, 0x08, 0x00000000);
+		nvkm_wo32(*pgpuobj, 0x0c, 0x00000000);
+		nvkm_done(*pgpuobj);
+	}
+	return ret;
 }
 
-static struct nvkm_ofuncs
-nv50_gr_ofuncs = {
-	.ctor = nv50_gr_object_ctor,
-	.dtor = _nvkm_gpuobj_dtor,
-	.init = _nvkm_gpuobj_init,
-	.fini = _nvkm_gpuobj_fini,
-	.rd32 = _nvkm_gpuobj_rd32,
-	.wr32 = _nvkm_gpuobj_wr32,
-};
-
-static struct nvkm_oclass
-nv50_gr_sclass[] = {
-	{ 0x0030, &nv50_gr_ofuncs },
-	{ 0x502d, &nv50_gr_ofuncs },
-	{ 0x5039, &nv50_gr_ofuncs },
-	{ 0x5097, &nv50_gr_ofuncs },
-	{ 0x50c0, &nv50_gr_ofuncs },
-	{}
+static const struct nvkm_object_func
+nv50_gr_object = {
+	.bind = nv50_gr_object_bind,
 };
 
-static struct nvkm_oclass
-g84_gr_sclass[] = {
-	{ 0x0030, &nv50_gr_ofuncs },
-	{ 0x502d, &nv50_gr_ofuncs },
-	{ 0x5039, &nv50_gr_ofuncs },
-	{ 0x50c0, &nv50_gr_ofuncs },
-	{ 0x8297, &nv50_gr_ofuncs },
-	{}
-};
-
-static struct nvkm_oclass
-gt200_gr_sclass[] = {
-	{ 0x0030, &nv50_gr_ofuncs },
-	{ 0x502d, &nv50_gr_ofuncs },
-	{ 0x5039, &nv50_gr_ofuncs },
-	{ 0x50c0, &nv50_gr_ofuncs },
-	{ 0x8397, &nv50_gr_ofuncs },
-	{}
-};
+static int
+nv50_gr_object_get(struct nvkm_gr *base, int index, struct nvkm_sclass *sclass)
+{
+	struct nv50_gr *gr = nv50_gr(base);
+	int c = 0;
 
-static struct nvkm_oclass
-gt215_gr_sclass[] = {
-	{ 0x0030, &nv50_gr_ofuncs },
-	{ 0x502d, &nv50_gr_ofuncs },
-	{ 0x5039, &nv50_gr_ofuncs },
-	{ 0x50c0, &nv50_gr_ofuncs },
-	{ 0x8597, &nv50_gr_ofuncs },
-	{ 0x85c0, &nv50_gr_ofuncs },
-	{}
-};
+	while (gr->func->sclass[c].oclass) {
+		if (c++ == index) {
+			*sclass = gr->func->sclass[index];
+			return index;
+		}
+	}
 
-static struct nvkm_oclass
-mcp89_gr_sclass[] = {
-	{ 0x0030, &nv50_gr_ofuncs },
-	{ 0x502d, &nv50_gr_ofuncs },
-	{ 0x5039, &nv50_gr_ofuncs },
-	{ 0x50c0, &nv50_gr_ofuncs },
-	{ 0x85c0, &nv50_gr_ofuncs },
-	{ 0x8697, &nv50_gr_ofuncs },
-	{}
-};
+	return c;
+}
 
 /*******************************************************************************
  * PGRAPH context
  ******************************************************************************/
 
 static int
-nv50_gr_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-		     struct nvkm_oclass *oclass, void *data, u32 size,
-		     struct nvkm_object **pobject)
+nv50_gr_chan_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,
+		  int align, struct nvkm_gpuobj **pgpuobj)
 {
-	struct nv50_gr *gr = (void *)engine;
-	struct nv50_gr_chan *chan;
-	int ret;
+	struct nv50_gr *gr = nv50_gr_chan(object)->gr;
+	int ret = nvkm_gpuobj_new(gr->base.engine.subdev.device, gr->size,
+				  align, true, parent, pgpuobj);
+	if (ret == 0) {
+		nvkm_kmap(*pgpuobj);
+		nv50_grctx_fill(gr->base.engine.subdev.device, *pgpuobj);
+		nvkm_done(*pgpuobj);
+	}
+	return ret;
+}
 
-	ret = nvkm_gr_context_create(parent, engine, oclass, NULL, gr->size,
-				     0, NVOBJ_FLAG_ZERO_ALLOC, &chan);
-	*pobject = nv_object(chan);
-	if (ret)
-		return ret;
+static const struct nvkm_object_func
+nv50_gr_chan = {
+	.bind = nv50_gr_chan_bind,
+};
+
+static int
+nv50_gr_chan_new(struct nvkm_gr *base, struct nvkm_fifo_chan *fifoch,
+		 const struct nvkm_oclass *oclass, struct nvkm_object **pobject)
+{
+	struct nv50_gr *gr = nv50_gr(base);
+	struct nv50_gr_chan *chan;
 
-	nv50_grctx_fill(nv_device(gr), nv_gpuobj(chan));
+	if (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))
+		return -ENOMEM;
+	nvkm_object_ctor(&nv50_gr_chan, oclass, &chan->object);
+	chan->gr = gr;
+	*pobject = &chan->object;
 	return 0;
 }
 
-static struct nvkm_oclass
-nv50_gr_cclass = {
-	.handle = NV_ENGCTX(GR, 0x50),
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nv50_gr_context_ctor,
-		.dtor = _nvkm_gr_context_dtor,
-		.init = _nvkm_gr_context_init,
-		.fini = _nvkm_gr_context_fini,
-		.rd32 = _nvkm_gr_context_rd32,
-		.wr32 = _nvkm_gr_context_wr32,
-	},
-};
-
 /*******************************************************************************
  * PGRAPH engine/subdev functions
  ******************************************************************************/
@@ -889,6 +835,74 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 	nvkm_fifo_chan_put(device->fifo, flags, &chan);
 }
 
+static const struct nv50_gr_func
+nv50_gr = {
+	.sclass = {
+		{ -1, -1, 0x0030, &nv50_gr_object },
+		{ -1, -1, 0x502d, &nv50_gr_object },
+		{ -1, -1, 0x5039, &nv50_gr_object },
+		{ -1, -1, 0x5097, &nv50_gr_object },
+		{ -1, -1, 0x50c0, &nv50_gr_object },
+		{}
+	}
+};
+
+static const struct nv50_gr_func
+g84_gr = {
+	.sclass = {
+		{ -1, -1, 0x0030, &nv50_gr_object },
+		{ -1, -1, 0x502d, &nv50_gr_object },
+		{ -1, -1, 0x5039, &nv50_gr_object },
+		{ -1, -1, 0x50c0, &nv50_gr_object },
+		{ -1, -1, 0x8297, &nv50_gr_object },
+		{}
+	}
+};
+
+static const struct nv50_gr_func
+gt200_gr = {
+	.sclass = {
+		{ -1, -1, 0x0030, &nv50_gr_object },
+		{ -1, -1, 0x502d, &nv50_gr_object },
+		{ -1, -1, 0x5039, &nv50_gr_object },
+		{ -1, -1, 0x50c0, &nv50_gr_object },
+		{ -1, -1, 0x8397, &nv50_gr_object },
+		{}
+	}
+};
+
+static const struct nv50_gr_func
+gt215_gr = {
+	.sclass = {
+		{ -1, -1, 0x0030, &nv50_gr_object },
+		{ -1, -1, 0x502d, &nv50_gr_object },
+		{ -1, -1, 0x5039, &nv50_gr_object },
+		{ -1, -1, 0x50c0, &nv50_gr_object },
+		{ -1, -1, 0x8597, &nv50_gr_object },
+		{ -1, -1, 0x85c0, &nv50_gr_object },
+		{}
+	}
+};
+
+static const struct nv50_gr_func
+mcp89_gr = {
+	.sclass = {
+		{ -1, -1, 0x0030, &nv50_gr_object },
+		{ -1, -1, 0x502d, &nv50_gr_object },
+		{ -1, -1, 0x5039, &nv50_gr_object },
+		{ -1, -1, 0x50c0, &nv50_gr_object },
+		{ -1, -1, 0x85c0, &nv50_gr_object },
+		{ -1, -1, 0x8697, &nv50_gr_object },
+		{}
+	}
+};
+
+static const struct nvkm_gr_func
+nv50_gr_ = {
+	.chan_new = nv50_gr_chan_new,
+	.object_get = nv50_gr_object_get,
+};
+
 static int
 nv50_gr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	     struct nvkm_oclass *oclass, void *data, u32 size,
@@ -904,13 +918,13 @@ nv50_gr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	nv_subdev(gr)->unit = 0x00201000;
 	nv_subdev(gr)->intr = nv50_gr_intr;
-	nv_engine(gr)->cclass = &nv50_gr_cclass;
 
+	gr->base.func = &nv50_gr_;
 	gr->base.units = nv50_gr_units;
 
 	switch (nv_device(gr)->chipset) {
 	case 0x50:
-		nv_engine(gr)->sclass = nv50_gr_sclass;
+		gr->func = &nv50_gr;
 		break;
 	case 0x84:
 	case 0x86:
@@ -918,22 +932,21 @@ nv50_gr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	case 0x94:
 	case 0x96:
 	case 0x98:
-		nv_engine(gr)->sclass = g84_gr_sclass;
+		gr->func = &g84_gr;
 		break;
 	case 0xa0:
 	case 0xaa:
 	case 0xac:
-		nv_engine(gr)->sclass = gt200_gr_sclass;
+		gr->func = &gt200_gr;
 		break;
 	case 0xa3:
 	case 0xa5:
 	case 0xa8:
-		nv_engine(gr)->sclass = gt215_gr_sclass;
+		gr->func = &gt215_gr;
 		break;
 	case 0xaf:
-		nv_engine(gr)->sclass = mcp89_gr_sclass;
+		gr->func = &mcp89_gr;
 		break;
-
 	}
 
 	/* unfortunate hw bug workaround... */

commit 8f0649b5c6e70ec18122255690e39f010c12a614
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/fifo: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index daac54075705..5f22dd3c788c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -608,7 +608,7 @@ nv50_gr_tp_trap(struct nv50_gr *gr, int type, u32 ustatus_old,
 
 static int
 nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
-		     int chid, u64 inst, struct nvkm_fifo_chan *chan)
+		     int chid, u64 inst, const char *name)
 {
 	struct nvkm_subdev *subdev = &gr->base.engine.subdev;
 	struct nvkm_device *device = subdev->device;
@@ -648,8 +648,7 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 					   "ch %d [%010llx %s] subc %d "
 					   "class %04x mthd %04x data %08x%08x "
 					   "400808 %08x 400848 %08x\n",
-					   chid, inst, nvkm_client_name(chan),
-					   subc, class, mthd,
+					   chid, inst, name, subc, class, mthd,
 					   datah, datal, addr, r848);
 			} else
 			if (display) {
@@ -674,9 +673,8 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 				nvkm_error(subdev,
 					   "ch %d [%010llx %s] subc %d "
 					   "class %04x mthd %04x data %08x "
-					   "40084c %08x\n", chid, inst,
-					   nvkm_client_name(chan), subc,
-					   class, mthd, data, addr);
+					   "40084c %08x\n", chid, inst, name,
+					   subc, class, mthd, data, addr);
 			} else
 			if (display) {
 				nvkm_error(subdev, "no stuck command?\n");
@@ -849,11 +847,15 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 	u32 show = stat, show_bitfield = stat;
 	const struct nvkm_enum *en;
 	unsigned long flags;
+	const char *name = "unknown";
 	char msg[128];
-	int chid;
+	int chid = -1;
 
 	chan = nvkm_fifo_chan_inst(device->fifo, (u64)inst << 12, &flags);
-	chid = chan ? chan->chid : -1;
+	if (chan)  {
+		name = chan->object.client->name;
+		chid = chan->chid;
+	}
 
 	if (show & 0x00100000) {
 		u32 ecode = nvkm_rd32(device, 0x400110);
@@ -864,7 +866,7 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 	}
 
 	if (stat & 0x00200000) {
-		if (!nv50_gr_trap_handler(gr, show, chid, (u64)inst << 12, chan))
+		if (!nv50_gr_trap_handler(gr, show, chid, (u64)inst << 12, name))
 			show &= ~0x00200000;
 		show_bitfield &= ~0x00200000;
 	}
@@ -877,8 +879,8 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 		nvkm_snprintbf(msg, sizeof(msg), nv50_gr_intr_name, show);
 		nvkm_error(subdev, "%08x [%s] ch %d [%010llx %s] subc %d "
 				   "class %04x mthd %04x data %08x\n",
-			   stat, msg, chid, (u64)inst << 12,
-			   nvkm_client_name(chan), subc, class, mthd, data);
+			   stat, msg, chid, (u64)inst << 12, name,
+			   subc, class, mthd, data);
 	}
 
 	if (nvkm_rd32(device, 0x400824) & (1 << 31))

commit a65955e19e769e92a0e29cccdc29aea0b19f3809
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/gr: remove dependence on namedb/engctx lookup
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index c50cfe4875ef..daac54075705 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -24,9 +24,8 @@
 #include "nv50.h"
 
 #include <core/client.h>
-#include <core/handle.h>
-#include <engine/fifo.h>
 #include <subdev/timer.h>
+#include <engine/fifo.h>
 
 struct nv50_gr {
 	struct nvkm_gr base;
@@ -609,7 +608,7 @@ nv50_gr_tp_trap(struct nv50_gr *gr, int type, u32 ustatus_old,
 
 static int
 nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
-		     int chid, u64 inst, struct nvkm_object *engctx)
+		     int chid, u64 inst, struct nvkm_fifo_chan *chan)
 {
 	struct nvkm_subdev *subdev = &gr->base.engine.subdev;
 	struct nvkm_device *device = subdev->device;
@@ -649,8 +648,7 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 					   "ch %d [%010llx %s] subc %d "
 					   "class %04x mthd %04x data %08x%08x "
 					   "400808 %08x 400848 %08x\n",
-					   chid, inst,
-					   nvkm_client_name(engctx),
+					   chid, inst, nvkm_client_name(chan),
 					   subc, class, mthd,
 					   datah, datal, addr, r848);
 			} else
@@ -677,7 +675,7 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 					   "ch %d [%010llx %s] subc %d "
 					   "class %04x mthd %04x data %08x "
 					   "40084c %08x\n", chid, inst,
-					   nvkm_client_name(engctx), subc,
+					   nvkm_client_name(chan), subc,
 					   class, mthd, data, addr);
 			} else
 			if (display) {
@@ -840,10 +838,7 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 {
 	struct nv50_gr *gr = (void *)subdev;
 	struct nvkm_device *device = gr->base.engine.subdev.device;
-	struct nvkm_fifo *fifo = device->fifo;
-	struct nvkm_engine *engine = nv_engine(subdev);
-	struct nvkm_object *engctx;
-	struct nvkm_handle *handle = NULL;
+	struct nvkm_fifo_chan *chan;
 	u32 stat = nvkm_rd32(device, 0x400100);
 	u32 inst = nvkm_rd32(device, 0x40032c) & 0x0fffffff;
 	u32 addr = nvkm_rd32(device, 0x400704);
@@ -853,18 +848,12 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 	u32 class = nvkm_rd32(device, 0x400814);
 	u32 show = stat, show_bitfield = stat;
 	const struct nvkm_enum *en;
+	unsigned long flags;
 	char msg[128];
 	int chid;
 
-	engctx = nvkm_engctx_get(engine, inst);
-	chid   = fifo->chid(fifo, engctx);
-
-	if (stat & 0x00000010) {
-		handle = nvkm_handle_get_class(engctx, class);
-		if (handle && !nv_call(handle->object, mthd, data))
-			show &= ~0x00000010;
-		nvkm_handle_put(handle);
-	}
+	chan = nvkm_fifo_chan_inst(device->fifo, (u64)inst << 12, &flags);
+	chid = chan ? chan->chid : -1;
 
 	if (show & 0x00100000) {
 		u32 ecode = nvkm_rd32(device, 0x400110);
@@ -875,8 +864,7 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 	}
 
 	if (stat & 0x00200000) {
-		if (!nv50_gr_trap_handler(gr, show, chid, (u64)inst << 12,
-					  engctx))
+		if (!nv50_gr_trap_handler(gr, show, chid, (u64)inst << 12, chan))
 			show &= ~0x00200000;
 		show_bitfield &= ~0x00200000;
 	}
@@ -890,13 +878,13 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 		nvkm_error(subdev, "%08x [%s] ch %d [%010llx %s] subc %d "
 				   "class %04x mthd %04x data %08x\n",
 			   stat, msg, chid, (u64)inst << 12,
-			   nvkm_client_name(engctx), subc, class, mthd, data);
+			   nvkm_client_name(chan), subc, class, mthd, data);
 	}
 
 	if (nvkm_rd32(device, 0x400824) & (1 << 31))
 		nvkm_wr32(device, 0x400824, nvkm_rd32(device, 0x400824) & ~(1 << 31));
 
-	nvkm_engctx_put(engctx);
+	nvkm_fifo_chan_put(device->fifo, flags, &chan);
 }
 
 static int

commit 142ea05f49b9517929f8b27ee800160e7ebf3a02
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:14 2015 +1000

    drm/nouveau/gr: switch to gpuobj accessor macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index 4ea7f0938769..c50cfe4875ef 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -62,10 +62,12 @@ nv50_gr_object_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	nv_wo32(obj, 0x00, nv_mclass(obj));
-	nv_wo32(obj, 0x04, 0x00000000);
-	nv_wo32(obj, 0x08, 0x00000000);
-	nv_wo32(obj, 0x0c, 0x00000000);
+	nvkm_kmap(obj);
+	nvkm_wo32(obj, 0x00, nv_mclass(obj));
+	nvkm_wo32(obj, 0x04, 0x00000000);
+	nvkm_wo32(obj, 0x08, 0x00000000);
+	nvkm_wo32(obj, 0x0c, 0x00000000);
+	nvkm_done(obj);
 	return 0;
 }
 

commit 109c2f2f1c42c16a4b265e796dee6ae4ada78417
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:13 2015 +1000

    drm/nouveau/gr: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index 3b482bcc22d0..4ea7f0938769 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -200,46 +200,71 @@ static const struct nvkm_bitfield nv50_gr_status[] = {
 	{}
 };
 
-static const char *const nv50_gr_vstatus_0[] = {
-	"VFETCH", "CCACHE", "PREGEOM", "POSTGEOM", "VATTR", "STRMOUT", "VCLIP",
-	NULL
+static const struct nvkm_bitfield
+nv50_gr_vstatus_0[] = {
+	{ 0x01, "VFETCH" },
+	{ 0x02, "CCACHE" },
+	{ 0x04, "PREGEOM" },
+	{ 0x08, "POSTGEOM" },
+	{ 0x10, "VATTR" },
+	{ 0x20, "STRMOUT" },
+	{ 0x40, "VCLIP" },
+	{}
 };
 
-static const char *const nv50_gr_vstatus_1[] = {
-	"TPC_RAST", "TPC_PROP", "TPC_TEX", "TPC_GEOM", "TPC_MP", NULL
+static const struct nvkm_bitfield
+nv50_gr_vstatus_1[] = {
+	{ 0x01, "TPC_RAST" },
+	{ 0x02, "TPC_PROP" },
+	{ 0x04, "TPC_TEX" },
+	{ 0x08, "TPC_GEOM" },
+	{ 0x10, "TPC_MP" },
+	{}
 };
 
-static const char *const nv50_gr_vstatus_2[] = {
-	"RATTR", "APLANE", "TRAST", "CLIPID", "ZCULL", "ENG2D", "RMASK",
-	"ROP", NULL
+static const struct nvkm_bitfield
+nv50_gr_vstatus_2[] = {
+	{ 0x01, "RATTR" },
+	{ 0x02, "APLANE" },
+	{ 0x04, "TRAST" },
+	{ 0x08, "CLIPID" },
+	{ 0x10, "ZCULL" },
+	{ 0x20, "ENG2D" },
+	{ 0x40, "RMASK" },
+	{ 0x80, "ROP" },
+	{}
 };
 
 static void
 nvkm_gr_vstatus_print(struct nv50_gr *gr, int r,
-		       const char *const units[], u32 status)
+		      const struct nvkm_bitfield *units, u32 status)
 {
+	struct nvkm_subdev *subdev = &gr->base.engine.subdev;
+	u32 stat = status;
+	u8  mask = 0x00;
+	char msg[64];
 	int i;
 
-	nv_error(gr, "PGRAPH_VSTATUS%d: 0x%08x", r, status);
-
-	for (i = 0; units[i] && status; i++) {
+	for (i = 0; units[i].name && status; i++) {
 		if ((status & 7) == 1)
-			pr_cont(" %s", units[i]);
+			mask |= (1 << i);
 		status >>= 3;
 	}
-	if (status)
-		pr_cont(" (invalid: 0x%x)", status);
-	pr_cont("\n");
+
+	nvkm_snprintbf(msg, sizeof(msg), units, mask);
+	nvkm_error(subdev, "PGRAPH_VSTATUS%d: %08x [%s]\n", r, stat, msg);
 }
 
 static int
 g84_gr_tlb_flush(struct nvkm_engine *engine)
 {
 	struct nv50_gr *gr = (void *)engine;
-	struct nvkm_device *device = gr->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &gr->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	struct nvkm_timer *tmr = device->timer;
 	bool idle, timeout = false;
 	unsigned long flags;
+	char status[128];
 	u64 start;
 	u32 tmp;
 
@@ -268,12 +293,11 @@ g84_gr_tlb_flush(struct nvkm_engine *engine)
 		 !(timeout = tmr->read(tmr) - start > 2000000000));
 
 	if (timeout) {
-		nv_error(gr, "PGRAPH TLB flush idle timeout fail\n");
+		nvkm_error(subdev, "PGRAPH TLB flush idle timeout fail\n");
 
 		tmp = nvkm_rd32(device, 0x400700);
-		nv_error(gr, "PGRAPH_STATUS  : 0x%08x", tmp);
-		nvkm_bitfield_print(nv50_gr_status, tmp);
-		pr_cont("\n");
+		nvkm_snprintbf(status, sizeof(status), nv50_gr_status, tmp);
+		nvkm_error(subdev, "PGRAPH_STATUS %08x [%s]\n", tmp, status);
 
 		nvkm_gr_vstatus_print(gr, 0, nv50_gr_vstatus_0,
 				       nvkm_rd32(device, 0x400380));
@@ -427,10 +451,10 @@ static const struct nvkm_bitfield nv50_gr_trap_prop[] = {
 };
 
 static void
-nv50_gr_prop_trap(struct nv50_gr *gr,
-		    u32 ustatus_addr, u32 ustatus, u32 tp)
+nv50_gr_prop_trap(struct nv50_gr *gr, u32 ustatus_addr, u32 ustatus, u32 tp)
 {
-	struct nvkm_device *device = gr->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &gr->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	u32 e0c = nvkm_rd32(device, ustatus_addr + 0x04);
 	u32 e10 = nvkm_rd32(device, ustatus_addr + 0x08);
 	u32 e14 = nvkm_rd32(device, ustatus_addr + 0x0c);
@@ -438,40 +462,44 @@ nv50_gr_prop_trap(struct nv50_gr *gr,
 	u32 e1c = nvkm_rd32(device, ustatus_addr + 0x14);
 	u32 e20 = nvkm_rd32(device, ustatus_addr + 0x18);
 	u32 e24 = nvkm_rd32(device, ustatus_addr + 0x1c);
+	char msg[128];
 
 	/* CUDA memory: l[], g[] or stack. */
 	if (ustatus & 0x00000080) {
 		if (e18 & 0x80000000) {
 			/* g[] read fault? */
-			nv_error(gr, "TRAP_PROP - TP %d - CUDA_FAULT - Global read fault at address %02x%08x\n",
+			nvkm_error(subdev, "TRAP_PROP - TP %d - CUDA_FAULT - Global read fault at address %02x%08x\n",
 					 tp, e14, e10 | ((e18 >> 24) & 0x1f));
 			e18 &= ~0x1f000000;
 		} else if (e18 & 0xc) {
 			/* g[] write fault? */
-			nv_error(gr, "TRAP_PROP - TP %d - CUDA_FAULT - Global write fault at address %02x%08x\n",
+			nvkm_error(subdev, "TRAP_PROP - TP %d - CUDA_FAULT - Global write fault at address %02x%08x\n",
 				 tp, e14, e10 | ((e18 >> 7) & 0x1f));
 			e18 &= ~0x00000f80;
 		} else {
-			nv_error(gr, "TRAP_PROP - TP %d - Unknown CUDA fault at address %02x%08x\n",
+			nvkm_error(subdev, "TRAP_PROP - TP %d - Unknown CUDA fault at address %02x%08x\n",
 				 tp, e14, e10);
 		}
 		ustatus &= ~0x00000080;
 	}
 	if (ustatus) {
-		nv_error(gr, "TRAP_PROP - TP %d -", tp);
-		nvkm_bitfield_print(nv50_gr_trap_prop, ustatus);
-		pr_cont(" - Address %02x%08x\n", e14, e10);
+		nvkm_snprintbf(msg, sizeof(msg), nv50_gr_trap_prop, ustatus);
+		nvkm_error(subdev, "TRAP_PROP - TP %d - %08x [%s] - "
+				   "Address %02x%08x\n",
+			   tp, ustatus, msg, e14, e10);
 	}
-	nv_error(gr, "TRAP_PROP - TP %d - e0c: %08x, e18: %08x, e1c: %08x, e20: %08x, e24: %08x\n",
+	nvkm_error(subdev, "TRAP_PROP - TP %d - e0c: %08x, e18: %08x, e1c: %08x, e20: %08x, e24: %08x\n",
 		 tp, e0c, e18, e1c, e20, e24);
 }
 
 static void
 nv50_gr_mp_trap(struct nv50_gr *gr, int tpid, int display)
 {
-	struct nvkm_device *device = gr->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &gr->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	u32 units = nvkm_rd32(device, 0x1540);
 	u32 addr, mp10, status, pc, oplow, ophigh;
+	char msg[128];
 	int i;
 	int mps = 0;
 	for (i = 0; i < 4; i++) {
@@ -490,19 +518,20 @@ nv50_gr_mp_trap(struct nv50_gr *gr, int tpid, int display)
 			pc = nvkm_rd32(device, addr + 0x24);
 			oplow = nvkm_rd32(device, addr + 0x70);
 			ophigh = nvkm_rd32(device, addr + 0x74);
-			nv_error(gr, "TRAP_MP_EXEC - "
-					"TP %d MP %d:", tpid, i);
-			nvkm_bitfield_print(nv50_mp_exec_errors, status);
-			pr_cont(" at %06x warp %d, opcode %08x %08x\n",
-					pc&0xffffff, pc >> 24,
-					oplow, ophigh);
+			nvkm_snprintbf(msg, sizeof(msg),
+				       nv50_mp_exec_errors, status);
+			nvkm_error(subdev, "TRAP_MP_EXEC - TP %d MP %d: "
+					   "%08x [%s] at %06x warp %d, "
+					   "opcode %08x %08x\n",
+				   tpid, i, status, msg, pc & 0xffffff,
+				   pc >> 24, oplow, ophigh);
 		}
 		nvkm_wr32(device, addr + 0x10, mp10);
 		nvkm_wr32(device, addr + 0x14, 0);
 		mps++;
 	}
 	if (!mps && display)
-		nv_error(gr, "TRAP_MP_EXEC - TP %d: "
+		nvkm_error(subdev, "TRAP_MP_EXEC - TP %d: "
 				"No MPs claiming errors?\n", tpid);
 }
 
@@ -510,10 +539,12 @@ static void
 nv50_gr_tp_trap(struct nv50_gr *gr, int type, u32 ustatus_old,
 		  u32 ustatus_new, int display, const char *name)
 {
-	struct nvkm_device *device = gr->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &gr->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	u32 units = nvkm_rd32(device, 0x1540);
 	int tps = 0;
 	int i, r;
+	char msg[128];
 	u32 ustatus_addr, ustatus;
 	for (i = 0; i < 16; i++) {
 		if (!(units & (1 << i)))
@@ -529,15 +560,16 @@ nv50_gr_tp_trap(struct nv50_gr *gr, int type, u32 ustatus_old,
 		switch (type) {
 		case 6: /* texture error... unknown for now */
 			if (display) {
-				nv_error(gr, "magic set %d:\n", i);
+				nvkm_error(subdev, "magic set %d:\n", i);
 				for (r = ustatus_addr + 4; r <= ustatus_addr + 0x10; r += 4)
-					nv_error(gr, "\t0x%08x: 0x%08x\n", r,
-						nvkm_rd32(device, r));
+					nvkm_error(subdev, "\t%08x: %08x\n", r,
+						   nvkm_rd32(device, r));
 				if (ustatus) {
-					nv_error(gr, "%s - TP%d:", name, i);
-					nvkm_bitfield_print(nv50_tex_traps,
-							       ustatus);
-					pr_cont("\n");
+					nvkm_snprintbf(msg, sizeof(msg),
+						       nv50_tex_traps, ustatus);
+					nvkm_error(subdev,
+						   "%s - TP%d: %08x [%s]\n",
+						   name, i, ustatus, msg);
 					ustatus = 0;
 				}
 			}
@@ -548,9 +580,10 @@ nv50_gr_tp_trap(struct nv50_gr *gr, int type, u32 ustatus_old,
 				ustatus &= ~0x04030000;
 			}
 			if (ustatus && display) {
-				nv_error(gr, "%s - TP%d:", name, i);
-				nvkm_bitfield_print(nv50_mpc_traps, ustatus);
-				pr_cont("\n");
+				nvkm_snprintbf(msg, sizeof(msg),
+					       nv50_mpc_traps, ustatus);
+				nvkm_error(subdev, "%s - TP%d: %08x [%s]\n",
+					   name, i, ustatus, msg);
 				ustatus = 0;
 			}
 			break;
@@ -563,25 +596,27 @@ nv50_gr_tp_trap(struct nv50_gr *gr, int type, u32 ustatus_old,
 		}
 		if (ustatus) {
 			if (display)
-				nv_error(gr, "%s - TP%d: Unhandled ustatus 0x%08x\n", name, i, ustatus);
+				nvkm_error(subdev, "%s - TP%d: Unhandled ustatus %08x\n", name, i, ustatus);
 		}
 		nvkm_wr32(device, ustatus_addr, 0xc0000000);
 	}
 
 	if (!tps && display)
-		nv_warn(gr, "%s - No TPs claiming errors?\n", name);
+		nvkm_warn(subdev, "%s - No TPs claiming errors?\n", name);
 }
 
 static int
 nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 		     int chid, u64 inst, struct nvkm_object *engctx)
 {
-	struct nvkm_device *device = gr->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &gr->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	u32 status = nvkm_rd32(device, 0x400108);
 	u32 ustatus;
+	char msg[128];
 
 	if (!status && display) {
-		nv_error(gr, "TRAP: no units reporting traps?\n");
+		nvkm_error(subdev, "TRAP: no units reporting traps?\n");
 		return 1;
 	}
 
@@ -591,7 +626,7 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 	if (status & 0x001) {
 		ustatus = nvkm_rd32(device, 0x400804) & 0x7fffffff;
 		if (!ustatus && display) {
-			nv_error(gr, "TRAP_DISPATCH - no ustatus?\n");
+			nvkm_error(subdev, "TRAP_DISPATCH - no ustatus?\n");
 		}
 
 		nvkm_wr32(device, 0x400500, 0x00000000);
@@ -606,16 +641,19 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 			u32 class = nvkm_rd32(device, 0x400814);
 			u32 r848 = nvkm_rd32(device, 0x400848);
 
-			nv_error(gr, "TRAP DISPATCH_FAULT\n");
+			nvkm_error(subdev, "TRAP DISPATCH_FAULT\n");
 			if (display && (addr & 0x80000000)) {
-				nv_error(gr,
-					 "ch %d [0x%010llx %s] subc %d class 0x%04x mthd 0x%04x data 0x%08x%08x 400808 0x%08x 400848 0x%08x\n",
-					 chid, inst,
-					 nvkm_client_name(engctx), subc,
-					 class, mthd, datah, datal, addr, r848);
+				nvkm_error(subdev,
+					   "ch %d [%010llx %s] subc %d "
+					   "class %04x mthd %04x data %08x%08x "
+					   "400808 %08x 400848 %08x\n",
+					   chid, inst,
+					   nvkm_client_name(engctx),
+					   subc, class, mthd,
+					   datah, datal, addr, r848);
 			} else
 			if (display) {
-				nv_error(gr, "no stuck command?\n");
+				nvkm_error(subdev, "no stuck command?\n");
 			}
 
 			nvkm_wr32(device, 0x400808, 0);
@@ -631,16 +669,17 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 			u32 data = nvkm_rd32(device, 0x40085c);
 			u32 class = nvkm_rd32(device, 0x400814);
 
-			nv_error(gr, "TRAP DISPATCH_QUERY\n");
+			nvkm_error(subdev, "TRAP DISPATCH_QUERY\n");
 			if (display && (addr & 0x80000000)) {
-				nv_error(gr,
-					 "ch %d [0x%010llx %s] subc %d class 0x%04x mthd 0x%04x data 0x%08x 40084c 0x%08x\n",
-					 chid, inst,
-					 nvkm_client_name(engctx), subc,
-					 class, mthd, data, addr);
+				nvkm_error(subdev,
+					   "ch %d [%010llx %s] subc %d "
+					   "class %04x mthd %04x data %08x "
+					   "40084c %08x\n", chid, inst,
+					   nvkm_client_name(engctx), subc,
+					   class, mthd, data, addr);
 			} else
 			if (display) {
-				nv_error(gr, "no stuck command?\n");
+				nvkm_error(subdev, "no stuck command?\n");
 			}
 
 			nvkm_wr32(device, 0x40084c, 0);
@@ -648,8 +687,8 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 		}
 
 		if (ustatus && display) {
-			nv_error(gr, "TRAP_DISPATCH (unknown "
-				      "0x%08x)\n", ustatus);
+			nvkm_error(subdev, "TRAP_DISPATCH "
+					   "(unknown %08x)\n", ustatus);
 		}
 
 		nvkm_wr32(device, 0x400804, 0xc0000000);
@@ -663,13 +702,15 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 	if (status & 0x002) {
 		u32 ustatus = nvkm_rd32(device, 0x406800) & 0x7fffffff;
 		if (display) {
-			nv_error(gr, "TRAP_M2MF");
-			nvkm_bitfield_print(nv50_gr_trap_m2mf, ustatus);
-			pr_cont("\n");
-			nv_error(gr, "TRAP_M2MF %08x %08x %08x %08x\n",
-				nvkm_rd32(device, 0x406804), nvkm_rd32(device, 0x406808),
-				nvkm_rd32(device, 0x40680c), nvkm_rd32(device, 0x406810));
-
+			nvkm_snprintbf(msg, sizeof(msg),
+				       nv50_gr_trap_m2mf, ustatus);
+			nvkm_error(subdev, "TRAP_M2MF %08x [%s]\n",
+				   ustatus, msg);
+			nvkm_error(subdev, "TRAP_M2MF %08x %08x %08x %08x\n",
+				   nvkm_rd32(device, 0x406804),
+				   nvkm_rd32(device, 0x406808),
+				   nvkm_rd32(device, 0x40680c),
+				   nvkm_rd32(device, 0x406810));
 		}
 
 		/* No sane way found yet -- just reset the bugger. */
@@ -684,12 +725,15 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 	if (status & 0x004) {
 		u32 ustatus = nvkm_rd32(device, 0x400c04) & 0x7fffffff;
 		if (display) {
-			nv_error(gr, "TRAP_VFETCH");
-			nvkm_bitfield_print(nv50_gr_trap_vfetch, ustatus);
-			pr_cont("\n");
-			nv_error(gr, "TRAP_VFETCH %08x %08x %08x %08x\n",
-				nvkm_rd32(device, 0x400c00), nvkm_rd32(device, 0x400c08),
-				nvkm_rd32(device, 0x400c0c), nvkm_rd32(device, 0x400c10));
+			nvkm_snprintbf(msg, sizeof(msg),
+				       nv50_gr_trap_vfetch, ustatus);
+			nvkm_error(subdev, "TRAP_VFETCH %08x [%s]\n",
+				   ustatus, msg);
+			nvkm_error(subdev, "TRAP_VFETCH %08x %08x %08x %08x\n",
+				   nvkm_rd32(device, 0x400c00),
+				   nvkm_rd32(device, 0x400c08),
+				   nvkm_rd32(device, 0x400c0c),
+				   nvkm_rd32(device, 0x400c10));
 		}
 
 		nvkm_wr32(device, 0x400c04, 0xc0000000);
@@ -701,13 +745,15 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 	if (status & 0x008) {
 		ustatus = nvkm_rd32(device, 0x401800) & 0x7fffffff;
 		if (display) {
-			nv_error(gr, "TRAP_STRMOUT");
-			nvkm_bitfield_print(nv50_gr_trap_strmout, ustatus);
-			pr_cont("\n");
-			nv_error(gr, "TRAP_STRMOUT %08x %08x %08x %08x\n",
-				nvkm_rd32(device, 0x401804), nvkm_rd32(device, 0x401808),
-				nvkm_rd32(device, 0x40180c), nvkm_rd32(device, 0x401810));
-
+			nvkm_snprintbf(msg, sizeof(msg),
+				       nv50_gr_trap_strmout, ustatus);
+			nvkm_error(subdev, "TRAP_STRMOUT %08x [%s]\n",
+				   ustatus, msg);
+			nvkm_error(subdev, "TRAP_STRMOUT %08x %08x %08x %08x\n",
+				   nvkm_rd32(device, 0x401804),
+				   nvkm_rd32(device, 0x401808),
+				   nvkm_rd32(device, 0x40180c),
+				   nvkm_rd32(device, 0x401810));
 		}
 
 		/* No sane way found yet -- just reset the bugger. */
@@ -722,16 +768,19 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 	if (status & 0x010) {
 		ustatus = nvkm_rd32(device, 0x405018) & 0x7fffffff;
 		if (display) {
-			nv_error(gr, "TRAP_CCACHE");
-			nvkm_bitfield_print(nv50_gr_trap_ccache, ustatus);
-			pr_cont("\n");
-			nv_error(gr, "TRAP_CCACHE %08x %08x %08x %08x"
-				     " %08x %08x %08x\n",
-				nvkm_rd32(device, 0x405000), nvkm_rd32(device, 0x405004),
-				nvkm_rd32(device, 0x405008), nvkm_rd32(device, 0x40500c),
-				nvkm_rd32(device, 0x405010), nvkm_rd32(device, 0x405014),
-				nvkm_rd32(device, 0x40501c));
-
+			nvkm_snprintbf(msg, sizeof(msg),
+				       nv50_gr_trap_ccache, ustatus);
+			nvkm_error(subdev, "TRAP_CCACHE %08x [%s]\n",
+				   ustatus, msg);
+			nvkm_error(subdev, "TRAP_CCACHE %08x %08x %08x %08x "
+					   "%08x %08x %08x\n",
+				   nvkm_rd32(device, 0x405000),
+				   nvkm_rd32(device, 0x405004),
+				   nvkm_rd32(device, 0x405008),
+				   nvkm_rd32(device, 0x40500c),
+				   nvkm_rd32(device, 0x405010),
+				   nvkm_rd32(device, 0x405014),
+				   nvkm_rd32(device, 0x40501c));
 		}
 
 		nvkm_wr32(device, 0x405018, 0xc0000000);
@@ -745,7 +794,7 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 	if (status & 0x20) {
 		ustatus = nvkm_rd32(device, 0x402000) & 0x7fffffff;
 		if (display)
-			nv_error(gr, "TRAP_UNKC04 0x%08x\n", ustatus);
+			nvkm_error(subdev, "TRAP_UNKC04 %08x\n", ustatus);
 		nvkm_wr32(device, 0x402000, 0xc0000000);
 		/* no status modifiction on purpose */
 	}
@@ -777,7 +826,7 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 
 	if (status) {
 		if (display)
-			nv_error(gr, "TRAP: unknown 0x%08x\n", status);
+			nvkm_error(subdev, "TRAP: unknown %08x\n", status);
 		nvkm_wr32(device, 0x400108, status);
 	}
 
@@ -801,6 +850,8 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 	u32 data = nvkm_rd32(device, 0x400708);
 	u32 class = nvkm_rd32(device, 0x400814);
 	u32 show = stat, show_bitfield = stat;
+	const struct nvkm_enum *en;
+	char msg[128];
 	int chid;
 
 	engctx = nvkm_engctx_get(engine, inst);
@@ -815,9 +866,9 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 
 	if (show & 0x00100000) {
 		u32 ecode = nvkm_rd32(device, 0x400110);
-		nv_error(gr, "DATA_ERROR ");
-		nvkm_enum_print(nv50_data_error_names, ecode);
-		pr_cont("\n");
+		en = nvkm_enum_find(nv50_data_error_names, ecode);
+		nvkm_error(subdev, "DATA_ERROR %08x [%s]\n",
+			   ecode, en ? en->name : "");
 		show_bitfield &= ~0x00100000;
 	}
 
@@ -833,15 +884,11 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 
 	if (show) {
 		show &= show_bitfield;
-		if (show) {
-			nv_error(gr, "%s", "");
-			nvkm_bitfield_print(nv50_gr_intr_name, show);
-			pr_cont("\n");
-		}
-		nv_error(gr,
-			 "ch %d [0x%010llx %s] subc %d class 0x%04x mthd 0x%04x data 0x%08x\n",
-			 chid, (u64)inst << 12, nvkm_client_name(engctx),
-			 subc, class, mthd, data);
+		nvkm_snprintbf(msg, sizeof(msg), nv50_gr_intr_name, show);
+		nvkm_error(subdev, "%08x [%s] ch %d [%010llx %s] subc %d "
+				   "class %04x mthd %04x data %08x\n",
+			   stat, msg, chid, (u64)inst << 12,
+			   nvkm_client_name(engctx), subc, class, mthd, data);
 	}
 
 	if (nvkm_rd32(device, 0x400824) & (1 << 31))

commit c4584adc37720b65ae44a84c660d47b3ebcf7dfb
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:11 2015 +1000

    drm/nouveau/gr: switch to new-style timer macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index ade34d8a4ea0..3b482bcc22d0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -285,8 +285,10 @@ g84_gr_tlb_flush(struct nvkm_engine *engine)
 
 
 	nvkm_wr32(device, 0x100c80, 0x00000001);
-	if (!nv_wait(gr, 0x100c80, 0x00000001, 0x00000000))
-		nv_error(gr, "vm flush timeout\n");
+	nvkm_msec(device, 2000,
+		if (!(nvkm_rd32(device, 0x100c80) & 0x00000001))
+			break;
+	);
 	nvkm_mask(device, 0x400500, 0x00000001, 0x00000001);
 	spin_unlock_irqrestore(&gr->lock, flags);
 	return timeout ? -EBUSY : 0;

commit 276836d46e535c8ca299a1ea8302879dbdd3e93a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:10 2015 +1000

    drm/nouveau/gr: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index 70be675b1928..ade34d8a4ea0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -41,7 +41,7 @@ struct nv50_gr_chan {
 static u64
 nv50_gr_units(struct nvkm_gr *gr)
 {
-	return nv_rd32(gr, 0x1540);
+	return nvkm_rd32(gr->engine.subdev.device, 0x1540);
 }
 
 /*******************************************************************************
@@ -235,31 +235,32 @@ nvkm_gr_vstatus_print(struct nv50_gr *gr, int r,
 static int
 g84_gr_tlb_flush(struct nvkm_engine *engine)
 {
-	struct nvkm_timer *tmr = nvkm_timer(engine);
 	struct nv50_gr *gr = (void *)engine;
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	struct nvkm_timer *tmr = device->timer;
 	bool idle, timeout = false;
 	unsigned long flags;
 	u64 start;
 	u32 tmp;
 
 	spin_lock_irqsave(&gr->lock, flags);
-	nv_mask(gr, 0x400500, 0x00000001, 0x00000000);
+	nvkm_mask(device, 0x400500, 0x00000001, 0x00000000);
 
 	start = tmr->read(tmr);
 	do {
 		idle = true;
 
-		for (tmp = nv_rd32(gr, 0x400380); tmp && idle; tmp >>= 3) {
+		for (tmp = nvkm_rd32(device, 0x400380); tmp && idle; tmp >>= 3) {
 			if ((tmp & 7) == 1)
 				idle = false;
 		}
 
-		for (tmp = nv_rd32(gr, 0x400384); tmp && idle; tmp >>= 3) {
+		for (tmp = nvkm_rd32(device, 0x400384); tmp && idle; tmp >>= 3) {
 			if ((tmp & 7) == 1)
 				idle = false;
 		}
 
-		for (tmp = nv_rd32(gr, 0x400388); tmp && idle; tmp >>= 3) {
+		for (tmp = nvkm_rd32(device, 0x400388); tmp && idle; tmp >>= 3) {
 			if ((tmp & 7) == 1)
 				idle = false;
 		}
@@ -269,24 +270,24 @@ g84_gr_tlb_flush(struct nvkm_engine *engine)
 	if (timeout) {
 		nv_error(gr, "PGRAPH TLB flush idle timeout fail\n");
 
-		tmp = nv_rd32(gr, 0x400700);
+		tmp = nvkm_rd32(device, 0x400700);
 		nv_error(gr, "PGRAPH_STATUS  : 0x%08x", tmp);
 		nvkm_bitfield_print(nv50_gr_status, tmp);
 		pr_cont("\n");
 
 		nvkm_gr_vstatus_print(gr, 0, nv50_gr_vstatus_0,
-				       nv_rd32(gr, 0x400380));
+				       nvkm_rd32(device, 0x400380));
 		nvkm_gr_vstatus_print(gr, 1, nv50_gr_vstatus_1,
-				       nv_rd32(gr, 0x400384));
+				       nvkm_rd32(device, 0x400384));
 		nvkm_gr_vstatus_print(gr, 2, nv50_gr_vstatus_2,
-				       nv_rd32(gr, 0x400388));
+				       nvkm_rd32(device, 0x400388));
 	}
 
 
-	nv_wr32(gr, 0x100c80, 0x00000001);
+	nvkm_wr32(device, 0x100c80, 0x00000001);
 	if (!nv_wait(gr, 0x100c80, 0x00000001, 0x00000000))
 		nv_error(gr, "vm flush timeout\n");
-	nv_mask(gr, 0x400500, 0x00000001, 0x00000001);
+	nvkm_mask(device, 0x400500, 0x00000001, 0x00000001);
 	spin_unlock_irqrestore(&gr->lock, flags);
 	return timeout ? -EBUSY : 0;
 }
@@ -427,13 +428,14 @@ static void
 nv50_gr_prop_trap(struct nv50_gr *gr,
 		    u32 ustatus_addr, u32 ustatus, u32 tp)
 {
-	u32 e0c = nv_rd32(gr, ustatus_addr + 0x04);
-	u32 e10 = nv_rd32(gr, ustatus_addr + 0x08);
-	u32 e14 = nv_rd32(gr, ustatus_addr + 0x0c);
-	u32 e18 = nv_rd32(gr, ustatus_addr + 0x10);
-	u32 e1c = nv_rd32(gr, ustatus_addr + 0x14);
-	u32 e20 = nv_rd32(gr, ustatus_addr + 0x18);
-	u32 e24 = nv_rd32(gr, ustatus_addr + 0x1c);
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	u32 e0c = nvkm_rd32(device, ustatus_addr + 0x04);
+	u32 e10 = nvkm_rd32(device, ustatus_addr + 0x08);
+	u32 e14 = nvkm_rd32(device, ustatus_addr + 0x0c);
+	u32 e18 = nvkm_rd32(device, ustatus_addr + 0x10);
+	u32 e1c = nvkm_rd32(device, ustatus_addr + 0x14);
+	u32 e20 = nvkm_rd32(device, ustatus_addr + 0x18);
+	u32 e24 = nvkm_rd32(device, ustatus_addr + 0x1c);
 
 	/* CUDA memory: l[], g[] or stack. */
 	if (ustatus & 0x00000080) {
@@ -465,7 +467,8 @@ nv50_gr_prop_trap(struct nv50_gr *gr,
 static void
 nv50_gr_mp_trap(struct nv50_gr *gr, int tpid, int display)
 {
-	u32 units = nv_rd32(gr, 0x1540);
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	u32 units = nvkm_rd32(device, 0x1540);
 	u32 addr, mp10, status, pc, oplow, ophigh;
 	int i;
 	int mps = 0;
@@ -476,15 +479,15 @@ nv50_gr_mp_trap(struct nv50_gr *gr, int tpid, int display)
 			addr = 0x408200 + (tpid << 12) + (i << 7);
 		else
 			addr = 0x408100 + (tpid << 11) + (i << 7);
-		mp10 = nv_rd32(gr, addr + 0x10);
-		status = nv_rd32(gr, addr + 0x14);
+		mp10 = nvkm_rd32(device, addr + 0x10);
+		status = nvkm_rd32(device, addr + 0x14);
 		if (!status)
 			continue;
 		if (display) {
-			nv_rd32(gr, addr + 0x20);
-			pc = nv_rd32(gr, addr + 0x24);
-			oplow = nv_rd32(gr, addr + 0x70);
-			ophigh = nv_rd32(gr, addr + 0x74);
+			nvkm_rd32(device, addr + 0x20);
+			pc = nvkm_rd32(device, addr + 0x24);
+			oplow = nvkm_rd32(device, addr + 0x70);
+			ophigh = nvkm_rd32(device, addr + 0x74);
 			nv_error(gr, "TRAP_MP_EXEC - "
 					"TP %d MP %d:", tpid, i);
 			nvkm_bitfield_print(nv50_mp_exec_errors, status);
@@ -492,8 +495,8 @@ nv50_gr_mp_trap(struct nv50_gr *gr, int tpid, int display)
 					pc&0xffffff, pc >> 24,
 					oplow, ophigh);
 		}
-		nv_wr32(gr, addr + 0x10, mp10);
-		nv_wr32(gr, addr + 0x14, 0);
+		nvkm_wr32(device, addr + 0x10, mp10);
+		nvkm_wr32(device, addr + 0x14, 0);
 		mps++;
 	}
 	if (!mps && display)
@@ -505,8 +508,9 @@ static void
 nv50_gr_tp_trap(struct nv50_gr *gr, int type, u32 ustatus_old,
 		  u32 ustatus_new, int display, const char *name)
 {
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	u32 units = nvkm_rd32(device, 0x1540);
 	int tps = 0;
-	u32 units = nv_rd32(gr, 0x1540);
 	int i, r;
 	u32 ustatus_addr, ustatus;
 	for (i = 0; i < 16; i++) {
@@ -516,7 +520,7 @@ nv50_gr_tp_trap(struct nv50_gr *gr, int type, u32 ustatus_old,
 			ustatus_addr = ustatus_old + (i << 12);
 		else
 			ustatus_addr = ustatus_new + (i << 11);
-		ustatus = nv_rd32(gr, ustatus_addr) & 0x7fffffff;
+		ustatus = nvkm_rd32(device, ustatus_addr) & 0x7fffffff;
 		if (!ustatus)
 			continue;
 		tps++;
@@ -526,7 +530,7 @@ nv50_gr_tp_trap(struct nv50_gr *gr, int type, u32 ustatus_old,
 				nv_error(gr, "magic set %d:\n", i);
 				for (r = ustatus_addr + 4; r <= ustatus_addr + 0x10; r += 4)
 					nv_error(gr, "\t0x%08x: 0x%08x\n", r,
-						nv_rd32(gr, r));
+						nvkm_rd32(device, r));
 				if (ustatus) {
 					nv_error(gr, "%s - TP%d:", name, i);
 					nvkm_bitfield_print(nv50_tex_traps,
@@ -559,7 +563,7 @@ nv50_gr_tp_trap(struct nv50_gr *gr, int type, u32 ustatus_old,
 			if (display)
 				nv_error(gr, "%s - TP%d: Unhandled ustatus 0x%08x\n", name, i, ustatus);
 		}
-		nv_wr32(gr, ustatus_addr, 0xc0000000);
+		nvkm_wr32(device, ustatus_addr, 0xc0000000);
 	}
 
 	if (!tps && display)
@@ -570,7 +574,8 @@ static int
 nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 		     int chid, u64 inst, struct nvkm_object *engctx)
 {
-	u32 status = nv_rd32(gr, 0x400108);
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	u32 status = nvkm_rd32(device, 0x400108);
 	u32 ustatus;
 
 	if (!status && display) {
@@ -582,22 +587,22 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 	 * COND, QUERY. If you get a trap from it, the command is still stuck
 	 * in DISPATCH and you need to do something about it. */
 	if (status & 0x001) {
-		ustatus = nv_rd32(gr, 0x400804) & 0x7fffffff;
+		ustatus = nvkm_rd32(device, 0x400804) & 0x7fffffff;
 		if (!ustatus && display) {
 			nv_error(gr, "TRAP_DISPATCH - no ustatus?\n");
 		}
 
-		nv_wr32(gr, 0x400500, 0x00000000);
+		nvkm_wr32(device, 0x400500, 0x00000000);
 
 		/* Known to be triggered by screwed up NOTIFY and COND... */
 		if (ustatus & 0x00000001) {
-			u32 addr = nv_rd32(gr, 0x400808);
+			u32 addr = nvkm_rd32(device, 0x400808);
 			u32 subc = (addr & 0x00070000) >> 16;
 			u32 mthd = (addr & 0x00001ffc);
-			u32 datal = nv_rd32(gr, 0x40080c);
-			u32 datah = nv_rd32(gr, 0x400810);
-			u32 class = nv_rd32(gr, 0x400814);
-			u32 r848 = nv_rd32(gr, 0x400848);
+			u32 datal = nvkm_rd32(device, 0x40080c);
+			u32 datah = nvkm_rd32(device, 0x400810);
+			u32 class = nvkm_rd32(device, 0x400814);
+			u32 r848 = nvkm_rd32(device, 0x400848);
 
 			nv_error(gr, "TRAP DISPATCH_FAULT\n");
 			if (display && (addr & 0x80000000)) {
@@ -611,18 +616,18 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 				nv_error(gr, "no stuck command?\n");
 			}
 
-			nv_wr32(gr, 0x400808, 0);
-			nv_wr32(gr, 0x4008e8, nv_rd32(gr, 0x4008e8) & 3);
-			nv_wr32(gr, 0x400848, 0);
+			nvkm_wr32(device, 0x400808, 0);
+			nvkm_wr32(device, 0x4008e8, nvkm_rd32(device, 0x4008e8) & 3);
+			nvkm_wr32(device, 0x400848, 0);
 			ustatus &= ~0x00000001;
 		}
 
 		if (ustatus & 0x00000002) {
-			u32 addr = nv_rd32(gr, 0x40084c);
+			u32 addr = nvkm_rd32(device, 0x40084c);
 			u32 subc = (addr & 0x00070000) >> 16;
 			u32 mthd = (addr & 0x00001ffc);
-			u32 data = nv_rd32(gr, 0x40085c);
-			u32 class = nv_rd32(gr, 0x400814);
+			u32 data = nvkm_rd32(device, 0x40085c);
+			u32 class = nvkm_rd32(device, 0x400814);
 
 			nv_error(gr, "TRAP DISPATCH_QUERY\n");
 			if (display && (addr & 0x80000000)) {
@@ -636,7 +641,7 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 				nv_error(gr, "no stuck command?\n");
 			}
 
-			nv_wr32(gr, 0x40084c, 0);
+			nvkm_wr32(device, 0x40084c, 0);
 			ustatus &= ~0x00000002;
 		}
 
@@ -645,8 +650,8 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 				      "0x%08x)\n", ustatus);
 		}
 
-		nv_wr32(gr, 0x400804, 0xc0000000);
-		nv_wr32(gr, 0x400108, 0x001);
+		nvkm_wr32(device, 0x400804, 0xc0000000);
+		nvkm_wr32(device, 0x400108, 0x001);
 		status &= ~0x001;
 		if (!status)
 			return 0;
@@ -654,81 +659,81 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 
 	/* M2MF: Memory to memory copy engine. */
 	if (status & 0x002) {
-		u32 ustatus = nv_rd32(gr, 0x406800) & 0x7fffffff;
+		u32 ustatus = nvkm_rd32(device, 0x406800) & 0x7fffffff;
 		if (display) {
 			nv_error(gr, "TRAP_M2MF");
 			nvkm_bitfield_print(nv50_gr_trap_m2mf, ustatus);
 			pr_cont("\n");
 			nv_error(gr, "TRAP_M2MF %08x %08x %08x %08x\n",
-				nv_rd32(gr, 0x406804), nv_rd32(gr, 0x406808),
-				nv_rd32(gr, 0x40680c), nv_rd32(gr, 0x406810));
+				nvkm_rd32(device, 0x406804), nvkm_rd32(device, 0x406808),
+				nvkm_rd32(device, 0x40680c), nvkm_rd32(device, 0x406810));
 
 		}
 
 		/* No sane way found yet -- just reset the bugger. */
-		nv_wr32(gr, 0x400040, 2);
-		nv_wr32(gr, 0x400040, 0);
-		nv_wr32(gr, 0x406800, 0xc0000000);
-		nv_wr32(gr, 0x400108, 0x002);
+		nvkm_wr32(device, 0x400040, 2);
+		nvkm_wr32(device, 0x400040, 0);
+		nvkm_wr32(device, 0x406800, 0xc0000000);
+		nvkm_wr32(device, 0x400108, 0x002);
 		status &= ~0x002;
 	}
 
 	/* VFETCH: Fetches data from vertex buffers. */
 	if (status & 0x004) {
-		u32 ustatus = nv_rd32(gr, 0x400c04) & 0x7fffffff;
+		u32 ustatus = nvkm_rd32(device, 0x400c04) & 0x7fffffff;
 		if (display) {
 			nv_error(gr, "TRAP_VFETCH");
 			nvkm_bitfield_print(nv50_gr_trap_vfetch, ustatus);
 			pr_cont("\n");
 			nv_error(gr, "TRAP_VFETCH %08x %08x %08x %08x\n",
-				nv_rd32(gr, 0x400c00), nv_rd32(gr, 0x400c08),
-				nv_rd32(gr, 0x400c0c), nv_rd32(gr, 0x400c10));
+				nvkm_rd32(device, 0x400c00), nvkm_rd32(device, 0x400c08),
+				nvkm_rd32(device, 0x400c0c), nvkm_rd32(device, 0x400c10));
 		}
 
-		nv_wr32(gr, 0x400c04, 0xc0000000);
-		nv_wr32(gr, 0x400108, 0x004);
+		nvkm_wr32(device, 0x400c04, 0xc0000000);
+		nvkm_wr32(device, 0x400108, 0x004);
 		status &= ~0x004;
 	}
 
 	/* STRMOUT: DirectX streamout / OpenGL transform feedback. */
 	if (status & 0x008) {
-		ustatus = nv_rd32(gr, 0x401800) & 0x7fffffff;
+		ustatus = nvkm_rd32(device, 0x401800) & 0x7fffffff;
 		if (display) {
 			nv_error(gr, "TRAP_STRMOUT");
 			nvkm_bitfield_print(nv50_gr_trap_strmout, ustatus);
 			pr_cont("\n");
 			nv_error(gr, "TRAP_STRMOUT %08x %08x %08x %08x\n",
-				nv_rd32(gr, 0x401804), nv_rd32(gr, 0x401808),
-				nv_rd32(gr, 0x40180c), nv_rd32(gr, 0x401810));
+				nvkm_rd32(device, 0x401804), nvkm_rd32(device, 0x401808),
+				nvkm_rd32(device, 0x40180c), nvkm_rd32(device, 0x401810));
 
 		}
 
 		/* No sane way found yet -- just reset the bugger. */
-		nv_wr32(gr, 0x400040, 0x80);
-		nv_wr32(gr, 0x400040, 0);
-		nv_wr32(gr, 0x401800, 0xc0000000);
-		nv_wr32(gr, 0x400108, 0x008);
+		nvkm_wr32(device, 0x400040, 0x80);
+		nvkm_wr32(device, 0x400040, 0);
+		nvkm_wr32(device, 0x401800, 0xc0000000);
+		nvkm_wr32(device, 0x400108, 0x008);
 		status &= ~0x008;
 	}
 
 	/* CCACHE: Handles code and c[] caches and fills them. */
 	if (status & 0x010) {
-		ustatus = nv_rd32(gr, 0x405018) & 0x7fffffff;
+		ustatus = nvkm_rd32(device, 0x405018) & 0x7fffffff;
 		if (display) {
 			nv_error(gr, "TRAP_CCACHE");
 			nvkm_bitfield_print(nv50_gr_trap_ccache, ustatus);
 			pr_cont("\n");
 			nv_error(gr, "TRAP_CCACHE %08x %08x %08x %08x"
 				     " %08x %08x %08x\n",
-				nv_rd32(gr, 0x405000), nv_rd32(gr, 0x405004),
-				nv_rd32(gr, 0x405008), nv_rd32(gr, 0x40500c),
-				nv_rd32(gr, 0x405010), nv_rd32(gr, 0x405014),
-				nv_rd32(gr, 0x40501c));
+				nvkm_rd32(device, 0x405000), nvkm_rd32(device, 0x405004),
+				nvkm_rd32(device, 0x405008), nvkm_rd32(device, 0x40500c),
+				nvkm_rd32(device, 0x405010), nvkm_rd32(device, 0x405014),
+				nvkm_rd32(device, 0x40501c));
 
 		}
 
-		nv_wr32(gr, 0x405018, 0xc0000000);
-		nv_wr32(gr, 0x400108, 0x010);
+		nvkm_wr32(device, 0x405018, 0xc0000000);
+		nvkm_wr32(device, 0x400108, 0x010);
 		status &= ~0x010;
 	}
 
@@ -736,10 +741,10 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 	 * remaining, so try to handle it anyway. Perhaps related to that
 	 * unknown DMA slot on tesla? */
 	if (status & 0x20) {
-		ustatus = nv_rd32(gr, 0x402000) & 0x7fffffff;
+		ustatus = nvkm_rd32(device, 0x402000) & 0x7fffffff;
 		if (display)
 			nv_error(gr, "TRAP_UNKC04 0x%08x\n", ustatus);
-		nv_wr32(gr, 0x402000, 0xc0000000);
+		nvkm_wr32(device, 0x402000, 0xc0000000);
 		/* no status modifiction on purpose */
 	}
 
@@ -747,7 +752,7 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 	if (status & 0x040) {
 		nv50_gr_tp_trap(gr, 6, 0x408900, 0x408600, display,
 				    "TRAP_TEXTURE");
-		nv_wr32(gr, 0x400108, 0x040);
+		nvkm_wr32(device, 0x400108, 0x040);
 		status &= ~0x040;
 	}
 
@@ -755,7 +760,7 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 	if (status & 0x080) {
 		nv50_gr_tp_trap(gr, 7, 0x408314, 0x40831c, display,
 				    "TRAP_MP");
-		nv_wr32(gr, 0x400108, 0x080);
+		nvkm_wr32(device, 0x400108, 0x080);
 		status &= ~0x080;
 	}
 
@@ -764,14 +769,14 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 	if (status & 0x100) {
 		nv50_gr_tp_trap(gr, 8, 0x408e08, 0x408708, display,
 				    "TRAP_PROP");
-		nv_wr32(gr, 0x400108, 0x100);
+		nvkm_wr32(device, 0x400108, 0x100);
 		status &= ~0x100;
 	}
 
 	if (status) {
 		if (display)
 			nv_error(gr, "TRAP: unknown 0x%08x\n", status);
-		nv_wr32(gr, 0x400108, status);
+		nvkm_wr32(device, 0x400108, status);
 	}
 
 	return 1;
@@ -780,18 +785,19 @@ nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 static void
 nv50_gr_intr(struct nvkm_subdev *subdev)
 {
-	struct nvkm_fifo *fifo = nvkm_fifo(subdev);
+	struct nv50_gr *gr = (void *)subdev;
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	struct nvkm_fifo *fifo = device->fifo;
 	struct nvkm_engine *engine = nv_engine(subdev);
 	struct nvkm_object *engctx;
 	struct nvkm_handle *handle = NULL;
-	struct nv50_gr *gr = (void *)subdev;
-	u32 stat = nv_rd32(gr, 0x400100);
-	u32 inst = nv_rd32(gr, 0x40032c) & 0x0fffffff;
-	u32 addr = nv_rd32(gr, 0x400704);
+	u32 stat = nvkm_rd32(device, 0x400100);
+	u32 inst = nvkm_rd32(device, 0x40032c) & 0x0fffffff;
+	u32 addr = nvkm_rd32(device, 0x400704);
 	u32 subc = (addr & 0x00070000) >> 16;
 	u32 mthd = (addr & 0x00001ffc);
-	u32 data = nv_rd32(gr, 0x400708);
-	u32 class = nv_rd32(gr, 0x400814);
+	u32 data = nvkm_rd32(device, 0x400708);
+	u32 class = nvkm_rd32(device, 0x400814);
 	u32 show = stat, show_bitfield = stat;
 	int chid;
 
@@ -806,7 +812,7 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 	}
 
 	if (show & 0x00100000) {
-		u32 ecode = nv_rd32(gr, 0x400110);
+		u32 ecode = nvkm_rd32(device, 0x400110);
 		nv_error(gr, "DATA_ERROR ");
 		nvkm_enum_print(nv50_data_error_names, ecode);
 		pr_cont("\n");
@@ -820,8 +826,8 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 		show_bitfield &= ~0x00200000;
 	}
 
-	nv_wr32(gr, 0x400100, stat);
-	nv_wr32(gr, 0x400500, 0x00010001);
+	nvkm_wr32(device, 0x400100, stat);
+	nvkm_wr32(device, 0x400500, 0x00010001);
 
 	if (show) {
 		show &= show_bitfield;
@@ -836,8 +842,8 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 			 subc, class, mthd, data);
 	}
 
-	if (nv_rd32(gr, 0x400824) & (1 << 31))
-		nv_wr32(gr, 0x400824, nv_rd32(gr, 0x400824) & ~(1 << 31));
+	if (nvkm_rd32(device, 0x400824) & (1 << 31))
+		nvkm_wr32(device, 0x400824, nvkm_rd32(device, 0x400824) & ~(1 << 31));
 
 	nvkm_engctx_put(engctx);
 }
@@ -902,6 +908,7 @@ static int
 nv50_gr_init(struct nvkm_object *object)
 {
 	struct nv50_gr *gr = (void *)object;
+	struct nvkm_device *device = gr->base.engine.subdev.device;
 	int ret, units, i;
 
 	ret = nvkm_gr_init(&gr->base);
@@ -909,66 +916,66 @@ nv50_gr_init(struct nvkm_object *object)
 		return ret;
 
 	/* NV_PGRAPH_DEBUG_3_HW_CTX_SWITCH_ENABLED */
-	nv_wr32(gr, 0x40008c, 0x00000004);
+	nvkm_wr32(device, 0x40008c, 0x00000004);
 
 	/* reset/enable traps and interrupts */
-	nv_wr32(gr, 0x400804, 0xc0000000);
-	nv_wr32(gr, 0x406800, 0xc0000000);
-	nv_wr32(gr, 0x400c04, 0xc0000000);
-	nv_wr32(gr, 0x401800, 0xc0000000);
-	nv_wr32(gr, 0x405018, 0xc0000000);
-	nv_wr32(gr, 0x402000, 0xc0000000);
-
-	units = nv_rd32(gr, 0x001540);
+	nvkm_wr32(device, 0x400804, 0xc0000000);
+	nvkm_wr32(device, 0x406800, 0xc0000000);
+	nvkm_wr32(device, 0x400c04, 0xc0000000);
+	nvkm_wr32(device, 0x401800, 0xc0000000);
+	nvkm_wr32(device, 0x405018, 0xc0000000);
+	nvkm_wr32(device, 0x402000, 0xc0000000);
+
+	units = nvkm_rd32(device, 0x001540);
 	for (i = 0; i < 16; i++) {
 		if (!(units & (1 << i)))
 			continue;
 
 		if (nv_device(gr)->chipset < 0xa0) {
-			nv_wr32(gr, 0x408900 + (i << 12), 0xc0000000);
-			nv_wr32(gr, 0x408e08 + (i << 12), 0xc0000000);
-			nv_wr32(gr, 0x408314 + (i << 12), 0xc0000000);
+			nvkm_wr32(device, 0x408900 + (i << 12), 0xc0000000);
+			nvkm_wr32(device, 0x408e08 + (i << 12), 0xc0000000);
+			nvkm_wr32(device, 0x408314 + (i << 12), 0xc0000000);
 		} else {
-			nv_wr32(gr, 0x408600 + (i << 11), 0xc0000000);
-			nv_wr32(gr, 0x408708 + (i << 11), 0xc0000000);
-			nv_wr32(gr, 0x40831c + (i << 11), 0xc0000000);
+			nvkm_wr32(device, 0x408600 + (i << 11), 0xc0000000);
+			nvkm_wr32(device, 0x408708 + (i << 11), 0xc0000000);
+			nvkm_wr32(device, 0x40831c + (i << 11), 0xc0000000);
 		}
 	}
 
-	nv_wr32(gr, 0x400108, 0xffffffff);
-	nv_wr32(gr, 0x400138, 0xffffffff);
-	nv_wr32(gr, 0x400100, 0xffffffff);
-	nv_wr32(gr, 0x40013c, 0xffffffff);
-	nv_wr32(gr, 0x400500, 0x00010001);
+	nvkm_wr32(device, 0x400108, 0xffffffff);
+	nvkm_wr32(device, 0x400138, 0xffffffff);
+	nvkm_wr32(device, 0x400100, 0xffffffff);
+	nvkm_wr32(device, 0x40013c, 0xffffffff);
+	nvkm_wr32(device, 0x400500, 0x00010001);
 
 	/* upload context program, initialise ctxctl defaults */
 	ret = nv50_grctx_init(nv_device(gr), &gr->size);
 	if (ret)
 		return ret;
 
-	nv_wr32(gr, 0x400824, 0x00000000);
-	nv_wr32(gr, 0x400828, 0x00000000);
-	nv_wr32(gr, 0x40082c, 0x00000000);
-	nv_wr32(gr, 0x400830, 0x00000000);
-	nv_wr32(gr, 0x40032c, 0x00000000);
-	nv_wr32(gr, 0x400330, 0x00000000);
+	nvkm_wr32(device, 0x400824, 0x00000000);
+	nvkm_wr32(device, 0x400828, 0x00000000);
+	nvkm_wr32(device, 0x40082c, 0x00000000);
+	nvkm_wr32(device, 0x400830, 0x00000000);
+	nvkm_wr32(device, 0x40032c, 0x00000000);
+	nvkm_wr32(device, 0x400330, 0x00000000);
 
 	/* some unknown zcull magic */
 	switch (nv_device(gr)->chipset & 0xf0) {
 	case 0x50:
 	case 0x80:
 	case 0x90:
-		nv_wr32(gr, 0x402ca8, 0x00000800);
+		nvkm_wr32(device, 0x402ca8, 0x00000800);
 		break;
 	case 0xa0:
 	default:
 		if (nv_device(gr)->chipset == 0xa0 ||
 		    nv_device(gr)->chipset == 0xaa ||
 		    nv_device(gr)->chipset == 0xac) {
-			nv_wr32(gr, 0x402ca8, 0x00000802);
+			nvkm_wr32(device, 0x402ca8, 0x00000802);
 		} else {
-			nv_wr32(gr, 0x402cc0, 0x00000000);
-			nv_wr32(gr, 0x402ca8, 0x00000002);
+			nvkm_wr32(device, 0x402cc0, 0x00000000);
+			nvkm_wr32(device, 0x402ca8, 0x00000002);
 		}
 
 		break;
@@ -976,10 +983,10 @@ nv50_gr_init(struct nvkm_object *object)
 
 	/* zero out zcull regions */
 	for (i = 0; i < 8; i++) {
-		nv_wr32(gr, 0x402c20 + (i * 0x10), 0x00000000);
-		nv_wr32(gr, 0x402c24 + (i * 0x10), 0x00000000);
-		nv_wr32(gr, 0x402c28 + (i * 0x10), 0x00000000);
-		nv_wr32(gr, 0x402c2c + (i * 0x10), 0x00000000);
+		nvkm_wr32(device, 0x402c20 + (i * 0x10), 0x00000000);
+		nvkm_wr32(device, 0x402c24 + (i * 0x10), 0x00000000);
+		nvkm_wr32(device, 0x402c28 + (i * 0x10), 0x00000000);
+		nvkm_wr32(device, 0x402c2c + (i * 0x10), 0x00000000);
 	}
 	return 0;
 }

commit bfee3f3d97db88bfb732735eb4955ad3381ac758
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:08 2015 +1000

    drm/nouveau/gr: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index e232cb8e2f9e..70be675b1928 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -28,7 +28,7 @@
 #include <engine/fifo.h>
 #include <subdev/timer.h>
 
-struct nv50_gr_priv {
+struct nv50_gr {
 	struct nvkm_gr base;
 	spinlock_t lock;
 	u32 size;
@@ -41,9 +41,7 @@ struct nv50_gr_chan {
 static u64
 nv50_gr_units(struct nvkm_gr *gr)
 {
-	struct nv50_gr_priv *priv = (void *)gr;
-
-	return nv_rd32(priv, 0x1540);
+	return nv_rd32(gr, 0x1540);
 }
 
 /*******************************************************************************
@@ -142,17 +140,17 @@ nv50_gr_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		     struct nvkm_oclass *oclass, void *data, u32 size,
 		     struct nvkm_object **pobject)
 {
-	struct nv50_gr_priv *priv = (void *)engine;
+	struct nv50_gr *gr = (void *)engine;
 	struct nv50_gr_chan *chan;
 	int ret;
 
-	ret = nvkm_gr_context_create(parent, engine, oclass, NULL, priv->size,
+	ret = nvkm_gr_context_create(parent, engine, oclass, NULL, gr->size,
 				     0, NVOBJ_FLAG_ZERO_ALLOC, &chan);
 	*pobject = nv_object(chan);
 	if (ret)
 		return ret;
 
-	nv50_grctx_fill(nv_device(priv), nv_gpuobj(chan));
+	nv50_grctx_fill(nv_device(gr), nv_gpuobj(chan));
 	return 0;
 }
 
@@ -173,7 +171,7 @@ nv50_gr_cclass = {
  * PGRAPH engine/subdev functions
  ******************************************************************************/
 
-static const struct nvkm_bitfield nv50_pgr_status[] = {
+static const struct nvkm_bitfield nv50_gr_status[] = {
 	{ 0x00000001, "BUSY" }, /* set when any bit is set */
 	{ 0x00000002, "DISPATCH" },
 	{ 0x00000004, "UNK2" },
@@ -202,27 +200,27 @@ static const struct nvkm_bitfield nv50_pgr_status[] = {
 	{}
 };
 
-static const char *const nv50_pgr_vstatus_0[] = {
+static const char *const nv50_gr_vstatus_0[] = {
 	"VFETCH", "CCACHE", "PREGEOM", "POSTGEOM", "VATTR", "STRMOUT", "VCLIP",
 	NULL
 };
 
-static const char *const nv50_pgr_vstatus_1[] = {
+static const char *const nv50_gr_vstatus_1[] = {
 	"TPC_RAST", "TPC_PROP", "TPC_TEX", "TPC_GEOM", "TPC_MP", NULL
 };
 
-static const char *const nv50_pgr_vstatus_2[] = {
+static const char *const nv50_gr_vstatus_2[] = {
 	"RATTR", "APLANE", "TRAST", "CLIPID", "ZCULL", "ENG2D", "RMASK",
 	"ROP", NULL
 };
 
 static void
-nvkm_pgr_vstatus_print(struct nv50_gr_priv *priv, int r,
+nvkm_gr_vstatus_print(struct nv50_gr *gr, int r,
 		       const char *const units[], u32 status)
 {
 	int i;
 
-	nv_error(priv, "PGRAPH_VSTATUS%d: 0x%08x", r, status);
+	nv_error(gr, "PGRAPH_VSTATUS%d: 0x%08x", r, status);
 
 	for (i = 0; units[i] && status; i++) {
 		if ((status & 7) == 1)
@@ -238,30 +236,30 @@ static int
 g84_gr_tlb_flush(struct nvkm_engine *engine)
 {
 	struct nvkm_timer *tmr = nvkm_timer(engine);
-	struct nv50_gr_priv *priv = (void *)engine;
+	struct nv50_gr *gr = (void *)engine;
 	bool idle, timeout = false;
 	unsigned long flags;
 	u64 start;
 	u32 tmp;
 
-	spin_lock_irqsave(&priv->lock, flags);
-	nv_mask(priv, 0x400500, 0x00000001, 0x00000000);
+	spin_lock_irqsave(&gr->lock, flags);
+	nv_mask(gr, 0x400500, 0x00000001, 0x00000000);
 
 	start = tmr->read(tmr);
 	do {
 		idle = true;
 
-		for (tmp = nv_rd32(priv, 0x400380); tmp && idle; tmp >>= 3) {
+		for (tmp = nv_rd32(gr, 0x400380); tmp && idle; tmp >>= 3) {
 			if ((tmp & 7) == 1)
 				idle = false;
 		}
 
-		for (tmp = nv_rd32(priv, 0x400384); tmp && idle; tmp >>= 3) {
+		for (tmp = nv_rd32(gr, 0x400384); tmp && idle; tmp >>= 3) {
 			if ((tmp & 7) == 1)
 				idle = false;
 		}
 
-		for (tmp = nv_rd32(priv, 0x400388); tmp && idle; tmp >>= 3) {
+		for (tmp = nv_rd32(gr, 0x400388); tmp && idle; tmp >>= 3) {
 			if ((tmp & 7) == 1)
 				idle = false;
 		}
@@ -269,27 +267,27 @@ g84_gr_tlb_flush(struct nvkm_engine *engine)
 		 !(timeout = tmr->read(tmr) - start > 2000000000));
 
 	if (timeout) {
-		nv_error(priv, "PGRAPH TLB flush idle timeout fail\n");
+		nv_error(gr, "PGRAPH TLB flush idle timeout fail\n");
 
-		tmp = nv_rd32(priv, 0x400700);
-		nv_error(priv, "PGRAPH_STATUS  : 0x%08x", tmp);
-		nvkm_bitfield_print(nv50_pgr_status, tmp);
+		tmp = nv_rd32(gr, 0x400700);
+		nv_error(gr, "PGRAPH_STATUS  : 0x%08x", tmp);
+		nvkm_bitfield_print(nv50_gr_status, tmp);
 		pr_cont("\n");
 
-		nvkm_pgr_vstatus_print(priv, 0, nv50_pgr_vstatus_0,
-				       nv_rd32(priv, 0x400380));
-		nvkm_pgr_vstatus_print(priv, 1, nv50_pgr_vstatus_1,
-				       nv_rd32(priv, 0x400384));
-		nvkm_pgr_vstatus_print(priv, 2, nv50_pgr_vstatus_2,
-				       nv_rd32(priv, 0x400388));
+		nvkm_gr_vstatus_print(gr, 0, nv50_gr_vstatus_0,
+				       nv_rd32(gr, 0x400380));
+		nvkm_gr_vstatus_print(gr, 1, nv50_gr_vstatus_1,
+				       nv_rd32(gr, 0x400384));
+		nvkm_gr_vstatus_print(gr, 2, nv50_gr_vstatus_2,
+				       nv_rd32(gr, 0x400388));
 	}
 
 
-	nv_wr32(priv, 0x100c80, 0x00000001);
-	if (!nv_wait(priv, 0x100c80, 0x00000001, 0x00000000))
-		nv_error(priv, "vm flush timeout\n");
-	nv_mask(priv, 0x400500, 0x00000001, 0x00000001);
-	spin_unlock_irqrestore(&priv->lock, flags);
+	nv_wr32(gr, 0x100c80, 0x00000001);
+	if (!nv_wait(gr, 0x100c80, 0x00000001, 0x00000000))
+		nv_error(gr, "vm flush timeout\n");
+	nv_mask(gr, 0x400500, 0x00000001, 0x00000001);
+	spin_unlock_irqrestore(&gr->lock, flags);
 	return timeout ? -EBUSY : 0;
 }
 
@@ -426,111 +424,111 @@ static const struct nvkm_bitfield nv50_gr_trap_prop[] = {
 };
 
 static void
-nv50_priv_prop_trap(struct nv50_gr_priv *priv,
+nv50_gr_prop_trap(struct nv50_gr *gr,
 		    u32 ustatus_addr, u32 ustatus, u32 tp)
 {
-	u32 e0c = nv_rd32(priv, ustatus_addr + 0x04);
-	u32 e10 = nv_rd32(priv, ustatus_addr + 0x08);
-	u32 e14 = nv_rd32(priv, ustatus_addr + 0x0c);
-	u32 e18 = nv_rd32(priv, ustatus_addr + 0x10);
-	u32 e1c = nv_rd32(priv, ustatus_addr + 0x14);
-	u32 e20 = nv_rd32(priv, ustatus_addr + 0x18);
-	u32 e24 = nv_rd32(priv, ustatus_addr + 0x1c);
+	u32 e0c = nv_rd32(gr, ustatus_addr + 0x04);
+	u32 e10 = nv_rd32(gr, ustatus_addr + 0x08);
+	u32 e14 = nv_rd32(gr, ustatus_addr + 0x0c);
+	u32 e18 = nv_rd32(gr, ustatus_addr + 0x10);
+	u32 e1c = nv_rd32(gr, ustatus_addr + 0x14);
+	u32 e20 = nv_rd32(gr, ustatus_addr + 0x18);
+	u32 e24 = nv_rd32(gr, ustatus_addr + 0x1c);
 
 	/* CUDA memory: l[], g[] or stack. */
 	if (ustatus & 0x00000080) {
 		if (e18 & 0x80000000) {
 			/* g[] read fault? */
-			nv_error(priv, "TRAP_PROP - TP %d - CUDA_FAULT - Global read fault at address %02x%08x\n",
+			nv_error(gr, "TRAP_PROP - TP %d - CUDA_FAULT - Global read fault at address %02x%08x\n",
 					 tp, e14, e10 | ((e18 >> 24) & 0x1f));
 			e18 &= ~0x1f000000;
 		} else if (e18 & 0xc) {
 			/* g[] write fault? */
-			nv_error(priv, "TRAP_PROP - TP %d - CUDA_FAULT - Global write fault at address %02x%08x\n",
+			nv_error(gr, "TRAP_PROP - TP %d - CUDA_FAULT - Global write fault at address %02x%08x\n",
 				 tp, e14, e10 | ((e18 >> 7) & 0x1f));
 			e18 &= ~0x00000f80;
 		} else {
-			nv_error(priv, "TRAP_PROP - TP %d - Unknown CUDA fault at address %02x%08x\n",
+			nv_error(gr, "TRAP_PROP - TP %d - Unknown CUDA fault at address %02x%08x\n",
 				 tp, e14, e10);
 		}
 		ustatus &= ~0x00000080;
 	}
 	if (ustatus) {
-		nv_error(priv, "TRAP_PROP - TP %d -", tp);
+		nv_error(gr, "TRAP_PROP - TP %d -", tp);
 		nvkm_bitfield_print(nv50_gr_trap_prop, ustatus);
 		pr_cont(" - Address %02x%08x\n", e14, e10);
 	}
-	nv_error(priv, "TRAP_PROP - TP %d - e0c: %08x, e18: %08x, e1c: %08x, e20: %08x, e24: %08x\n",
+	nv_error(gr, "TRAP_PROP - TP %d - e0c: %08x, e18: %08x, e1c: %08x, e20: %08x, e24: %08x\n",
 		 tp, e0c, e18, e1c, e20, e24);
 }
 
 static void
-nv50_priv_mp_trap(struct nv50_gr_priv *priv, int tpid, int display)
+nv50_gr_mp_trap(struct nv50_gr *gr, int tpid, int display)
 {
-	u32 units = nv_rd32(priv, 0x1540);
+	u32 units = nv_rd32(gr, 0x1540);
 	u32 addr, mp10, status, pc, oplow, ophigh;
 	int i;
 	int mps = 0;
 	for (i = 0; i < 4; i++) {
 		if (!(units & 1 << (i+24)))
 			continue;
-		if (nv_device(priv)->chipset < 0xa0)
+		if (nv_device(gr)->chipset < 0xa0)
 			addr = 0x408200 + (tpid << 12) + (i << 7);
 		else
 			addr = 0x408100 + (tpid << 11) + (i << 7);
-		mp10 = nv_rd32(priv, addr + 0x10);
-		status = nv_rd32(priv, addr + 0x14);
+		mp10 = nv_rd32(gr, addr + 0x10);
+		status = nv_rd32(gr, addr + 0x14);
 		if (!status)
 			continue;
 		if (display) {
-			nv_rd32(priv, addr + 0x20);
-			pc = nv_rd32(priv, addr + 0x24);
-			oplow = nv_rd32(priv, addr + 0x70);
-			ophigh = nv_rd32(priv, addr + 0x74);
-			nv_error(priv, "TRAP_MP_EXEC - "
+			nv_rd32(gr, addr + 0x20);
+			pc = nv_rd32(gr, addr + 0x24);
+			oplow = nv_rd32(gr, addr + 0x70);
+			ophigh = nv_rd32(gr, addr + 0x74);
+			nv_error(gr, "TRAP_MP_EXEC - "
 					"TP %d MP %d:", tpid, i);
 			nvkm_bitfield_print(nv50_mp_exec_errors, status);
 			pr_cont(" at %06x warp %d, opcode %08x %08x\n",
 					pc&0xffffff, pc >> 24,
 					oplow, ophigh);
 		}
-		nv_wr32(priv, addr + 0x10, mp10);
-		nv_wr32(priv, addr + 0x14, 0);
+		nv_wr32(gr, addr + 0x10, mp10);
+		nv_wr32(gr, addr + 0x14, 0);
 		mps++;
 	}
 	if (!mps && display)
-		nv_error(priv, "TRAP_MP_EXEC - TP %d: "
+		nv_error(gr, "TRAP_MP_EXEC - TP %d: "
 				"No MPs claiming errors?\n", tpid);
 }
 
 static void
-nv50_priv_tp_trap(struct nv50_gr_priv *priv, int type, u32 ustatus_old,
+nv50_gr_tp_trap(struct nv50_gr *gr, int type, u32 ustatus_old,
 		  u32 ustatus_new, int display, const char *name)
 {
 	int tps = 0;
-	u32 units = nv_rd32(priv, 0x1540);
+	u32 units = nv_rd32(gr, 0x1540);
 	int i, r;
 	u32 ustatus_addr, ustatus;
 	for (i = 0; i < 16; i++) {
 		if (!(units & (1 << i)))
 			continue;
-		if (nv_device(priv)->chipset < 0xa0)
+		if (nv_device(gr)->chipset < 0xa0)
 			ustatus_addr = ustatus_old + (i << 12);
 		else
 			ustatus_addr = ustatus_new + (i << 11);
-		ustatus = nv_rd32(priv, ustatus_addr) & 0x7fffffff;
+		ustatus = nv_rd32(gr, ustatus_addr) & 0x7fffffff;
 		if (!ustatus)
 			continue;
 		tps++;
 		switch (type) {
 		case 6: /* texture error... unknown for now */
 			if (display) {
-				nv_error(priv, "magic set %d:\n", i);
+				nv_error(gr, "magic set %d:\n", i);
 				for (r = ustatus_addr + 4; r <= ustatus_addr + 0x10; r += 4)
-					nv_error(priv, "\t0x%08x: 0x%08x\n", r,
-						nv_rd32(priv, r));
+					nv_error(gr, "\t0x%08x: 0x%08x\n", r,
+						nv_rd32(gr, r));
 				if (ustatus) {
-					nv_error(priv, "%s - TP%d:", name, i);
+					nv_error(gr, "%s - TP%d:", name, i);
 					nvkm_bitfield_print(nv50_tex_traps,
 							       ustatus);
 					pr_cont("\n");
@@ -540,11 +538,11 @@ nv50_priv_tp_trap(struct nv50_gr_priv *priv, int type, u32 ustatus_old,
 			break;
 		case 7: /* MP error */
 			if (ustatus & 0x04030000) {
-				nv50_priv_mp_trap(priv, i, display);
+				nv50_gr_mp_trap(gr, i, display);
 				ustatus &= ~0x04030000;
 			}
 			if (ustatus && display) {
-				nv_error(priv, "%s - TP%d:", name, i);
+				nv_error(gr, "%s - TP%d:", name, i);
 				nvkm_bitfield_print(nv50_mpc_traps, ustatus);
 				pr_cont("\n");
 				ustatus = 0;
@@ -552,31 +550,31 @@ nv50_priv_tp_trap(struct nv50_gr_priv *priv, int type, u32 ustatus_old,
 			break;
 		case 8: /* PROP error */
 			if (display)
-				nv50_priv_prop_trap(
-						priv, ustatus_addr, ustatus, i);
+				nv50_gr_prop_trap(
+						gr, ustatus_addr, ustatus, i);
 			ustatus = 0;
 			break;
 		}
 		if (ustatus) {
 			if (display)
-				nv_error(priv, "%s - TP%d: Unhandled ustatus 0x%08x\n", name, i, ustatus);
+				nv_error(gr, "%s - TP%d: Unhandled ustatus 0x%08x\n", name, i, ustatus);
 		}
-		nv_wr32(priv, ustatus_addr, 0xc0000000);
+		nv_wr32(gr, ustatus_addr, 0xc0000000);
 	}
 
 	if (!tps && display)
-		nv_warn(priv, "%s - No TPs claiming errors?\n", name);
+		nv_warn(gr, "%s - No TPs claiming errors?\n", name);
 }
 
 static int
-nv50_gr_trap_handler(struct nv50_gr_priv *priv, u32 display,
+nv50_gr_trap_handler(struct nv50_gr *gr, u32 display,
 		     int chid, u64 inst, struct nvkm_object *engctx)
 {
-	u32 status = nv_rd32(priv, 0x400108);
+	u32 status = nv_rd32(gr, 0x400108);
 	u32 ustatus;
 
 	if (!status && display) {
-		nv_error(priv, "TRAP: no units reporting traps?\n");
+		nv_error(gr, "TRAP: no units reporting traps?\n");
 		return 1;
 	}
 
@@ -584,71 +582,71 @@ nv50_gr_trap_handler(struct nv50_gr_priv *priv, u32 display,
 	 * COND, QUERY. If you get a trap from it, the command is still stuck
 	 * in DISPATCH and you need to do something about it. */
 	if (status & 0x001) {
-		ustatus = nv_rd32(priv, 0x400804) & 0x7fffffff;
+		ustatus = nv_rd32(gr, 0x400804) & 0x7fffffff;
 		if (!ustatus && display) {
-			nv_error(priv, "TRAP_DISPATCH - no ustatus?\n");
+			nv_error(gr, "TRAP_DISPATCH - no ustatus?\n");
 		}
 
-		nv_wr32(priv, 0x400500, 0x00000000);
+		nv_wr32(gr, 0x400500, 0x00000000);
 
 		/* Known to be triggered by screwed up NOTIFY and COND... */
 		if (ustatus & 0x00000001) {
-			u32 addr = nv_rd32(priv, 0x400808);
+			u32 addr = nv_rd32(gr, 0x400808);
 			u32 subc = (addr & 0x00070000) >> 16;
 			u32 mthd = (addr & 0x00001ffc);
-			u32 datal = nv_rd32(priv, 0x40080c);
-			u32 datah = nv_rd32(priv, 0x400810);
-			u32 class = nv_rd32(priv, 0x400814);
-			u32 r848 = nv_rd32(priv, 0x400848);
+			u32 datal = nv_rd32(gr, 0x40080c);
+			u32 datah = nv_rd32(gr, 0x400810);
+			u32 class = nv_rd32(gr, 0x400814);
+			u32 r848 = nv_rd32(gr, 0x400848);
 
-			nv_error(priv, "TRAP DISPATCH_FAULT\n");
+			nv_error(gr, "TRAP DISPATCH_FAULT\n");
 			if (display && (addr & 0x80000000)) {
-				nv_error(priv,
+				nv_error(gr,
 					 "ch %d [0x%010llx %s] subc %d class 0x%04x mthd 0x%04x data 0x%08x%08x 400808 0x%08x 400848 0x%08x\n",
 					 chid, inst,
 					 nvkm_client_name(engctx), subc,
 					 class, mthd, datah, datal, addr, r848);
 			} else
 			if (display) {
-				nv_error(priv, "no stuck command?\n");
+				nv_error(gr, "no stuck command?\n");
 			}
 
-			nv_wr32(priv, 0x400808, 0);
-			nv_wr32(priv, 0x4008e8, nv_rd32(priv, 0x4008e8) & 3);
-			nv_wr32(priv, 0x400848, 0);
+			nv_wr32(gr, 0x400808, 0);
+			nv_wr32(gr, 0x4008e8, nv_rd32(gr, 0x4008e8) & 3);
+			nv_wr32(gr, 0x400848, 0);
 			ustatus &= ~0x00000001;
 		}
 
 		if (ustatus & 0x00000002) {
-			u32 addr = nv_rd32(priv, 0x40084c);
+			u32 addr = nv_rd32(gr, 0x40084c);
 			u32 subc = (addr & 0x00070000) >> 16;
 			u32 mthd = (addr & 0x00001ffc);
-			u32 data = nv_rd32(priv, 0x40085c);
-			u32 class = nv_rd32(priv, 0x400814);
+			u32 data = nv_rd32(gr, 0x40085c);
+			u32 class = nv_rd32(gr, 0x400814);
 
-			nv_error(priv, "TRAP DISPATCH_QUERY\n");
+			nv_error(gr, "TRAP DISPATCH_QUERY\n");
 			if (display && (addr & 0x80000000)) {
-				nv_error(priv,
+				nv_error(gr,
 					 "ch %d [0x%010llx %s] subc %d class 0x%04x mthd 0x%04x data 0x%08x 40084c 0x%08x\n",
 					 chid, inst,
 					 nvkm_client_name(engctx), subc,
 					 class, mthd, data, addr);
 			} else
 			if (display) {
-				nv_error(priv, "no stuck command?\n");
+				nv_error(gr, "no stuck command?\n");
 			}
 
-			nv_wr32(priv, 0x40084c, 0);
+			nv_wr32(gr, 0x40084c, 0);
 			ustatus &= ~0x00000002;
 		}
 
 		if (ustatus && display) {
-			nv_error(priv, "TRAP_DISPATCH (unknown "
+			nv_error(gr, "TRAP_DISPATCH (unknown "
 				      "0x%08x)\n", ustatus);
 		}
 
-		nv_wr32(priv, 0x400804, 0xc0000000);
-		nv_wr32(priv, 0x400108, 0x001);
+		nv_wr32(gr, 0x400804, 0xc0000000);
+		nv_wr32(gr, 0x400108, 0x001);
 		status &= ~0x001;
 		if (!status)
 			return 0;
@@ -656,81 +654,81 @@ nv50_gr_trap_handler(struct nv50_gr_priv *priv, u32 display,
 
 	/* M2MF: Memory to memory copy engine. */
 	if (status & 0x002) {
-		u32 ustatus = nv_rd32(priv, 0x406800) & 0x7fffffff;
+		u32 ustatus = nv_rd32(gr, 0x406800) & 0x7fffffff;
 		if (display) {
-			nv_error(priv, "TRAP_M2MF");
+			nv_error(gr, "TRAP_M2MF");
 			nvkm_bitfield_print(nv50_gr_trap_m2mf, ustatus);
 			pr_cont("\n");
-			nv_error(priv, "TRAP_M2MF %08x %08x %08x %08x\n",
-				nv_rd32(priv, 0x406804), nv_rd32(priv, 0x406808),
-				nv_rd32(priv, 0x40680c), nv_rd32(priv, 0x406810));
+			nv_error(gr, "TRAP_M2MF %08x %08x %08x %08x\n",
+				nv_rd32(gr, 0x406804), nv_rd32(gr, 0x406808),
+				nv_rd32(gr, 0x40680c), nv_rd32(gr, 0x406810));
 
 		}
 
 		/* No sane way found yet -- just reset the bugger. */
-		nv_wr32(priv, 0x400040, 2);
-		nv_wr32(priv, 0x400040, 0);
-		nv_wr32(priv, 0x406800, 0xc0000000);
-		nv_wr32(priv, 0x400108, 0x002);
+		nv_wr32(gr, 0x400040, 2);
+		nv_wr32(gr, 0x400040, 0);
+		nv_wr32(gr, 0x406800, 0xc0000000);
+		nv_wr32(gr, 0x400108, 0x002);
 		status &= ~0x002;
 	}
 
 	/* VFETCH: Fetches data from vertex buffers. */
 	if (status & 0x004) {
-		u32 ustatus = nv_rd32(priv, 0x400c04) & 0x7fffffff;
+		u32 ustatus = nv_rd32(gr, 0x400c04) & 0x7fffffff;
 		if (display) {
-			nv_error(priv, "TRAP_VFETCH");
+			nv_error(gr, "TRAP_VFETCH");
 			nvkm_bitfield_print(nv50_gr_trap_vfetch, ustatus);
 			pr_cont("\n");
-			nv_error(priv, "TRAP_VFETCH %08x %08x %08x %08x\n",
-				nv_rd32(priv, 0x400c00), nv_rd32(priv, 0x400c08),
-				nv_rd32(priv, 0x400c0c), nv_rd32(priv, 0x400c10));
+			nv_error(gr, "TRAP_VFETCH %08x %08x %08x %08x\n",
+				nv_rd32(gr, 0x400c00), nv_rd32(gr, 0x400c08),
+				nv_rd32(gr, 0x400c0c), nv_rd32(gr, 0x400c10));
 		}
 
-		nv_wr32(priv, 0x400c04, 0xc0000000);
-		nv_wr32(priv, 0x400108, 0x004);
+		nv_wr32(gr, 0x400c04, 0xc0000000);
+		nv_wr32(gr, 0x400108, 0x004);
 		status &= ~0x004;
 	}
 
 	/* STRMOUT: DirectX streamout / OpenGL transform feedback. */
 	if (status & 0x008) {
-		ustatus = nv_rd32(priv, 0x401800) & 0x7fffffff;
+		ustatus = nv_rd32(gr, 0x401800) & 0x7fffffff;
 		if (display) {
-			nv_error(priv, "TRAP_STRMOUT");
+			nv_error(gr, "TRAP_STRMOUT");
 			nvkm_bitfield_print(nv50_gr_trap_strmout, ustatus);
 			pr_cont("\n");
-			nv_error(priv, "TRAP_STRMOUT %08x %08x %08x %08x\n",
-				nv_rd32(priv, 0x401804), nv_rd32(priv, 0x401808),
-				nv_rd32(priv, 0x40180c), nv_rd32(priv, 0x401810));
+			nv_error(gr, "TRAP_STRMOUT %08x %08x %08x %08x\n",
+				nv_rd32(gr, 0x401804), nv_rd32(gr, 0x401808),
+				nv_rd32(gr, 0x40180c), nv_rd32(gr, 0x401810));
 
 		}
 
 		/* No sane way found yet -- just reset the bugger. */
-		nv_wr32(priv, 0x400040, 0x80);
-		nv_wr32(priv, 0x400040, 0);
-		nv_wr32(priv, 0x401800, 0xc0000000);
-		nv_wr32(priv, 0x400108, 0x008);
+		nv_wr32(gr, 0x400040, 0x80);
+		nv_wr32(gr, 0x400040, 0);
+		nv_wr32(gr, 0x401800, 0xc0000000);
+		nv_wr32(gr, 0x400108, 0x008);
 		status &= ~0x008;
 	}
 
 	/* CCACHE: Handles code and c[] caches and fills them. */
 	if (status & 0x010) {
-		ustatus = nv_rd32(priv, 0x405018) & 0x7fffffff;
+		ustatus = nv_rd32(gr, 0x405018) & 0x7fffffff;
 		if (display) {
-			nv_error(priv, "TRAP_CCACHE");
+			nv_error(gr, "TRAP_CCACHE");
 			nvkm_bitfield_print(nv50_gr_trap_ccache, ustatus);
 			pr_cont("\n");
-			nv_error(priv, "TRAP_CCACHE %08x %08x %08x %08x"
+			nv_error(gr, "TRAP_CCACHE %08x %08x %08x %08x"
 				     " %08x %08x %08x\n",
-				nv_rd32(priv, 0x405000), nv_rd32(priv, 0x405004),
-				nv_rd32(priv, 0x405008), nv_rd32(priv, 0x40500c),
-				nv_rd32(priv, 0x405010), nv_rd32(priv, 0x405014),
-				nv_rd32(priv, 0x40501c));
+				nv_rd32(gr, 0x405000), nv_rd32(gr, 0x405004),
+				nv_rd32(gr, 0x405008), nv_rd32(gr, 0x40500c),
+				nv_rd32(gr, 0x405010), nv_rd32(gr, 0x405014),
+				nv_rd32(gr, 0x40501c));
 
 		}
 
-		nv_wr32(priv, 0x405018, 0xc0000000);
-		nv_wr32(priv, 0x400108, 0x010);
+		nv_wr32(gr, 0x405018, 0xc0000000);
+		nv_wr32(gr, 0x400108, 0x010);
 		status &= ~0x010;
 	}
 
@@ -738,42 +736,42 @@ nv50_gr_trap_handler(struct nv50_gr_priv *priv, u32 display,
 	 * remaining, so try to handle it anyway. Perhaps related to that
 	 * unknown DMA slot on tesla? */
 	if (status & 0x20) {
-		ustatus = nv_rd32(priv, 0x402000) & 0x7fffffff;
+		ustatus = nv_rd32(gr, 0x402000) & 0x7fffffff;
 		if (display)
-			nv_error(priv, "TRAP_UNKC04 0x%08x\n", ustatus);
-		nv_wr32(priv, 0x402000, 0xc0000000);
+			nv_error(gr, "TRAP_UNKC04 0x%08x\n", ustatus);
+		nv_wr32(gr, 0x402000, 0xc0000000);
 		/* no status modifiction on purpose */
 	}
 
 	/* TEXTURE: CUDA texturing units */
 	if (status & 0x040) {
-		nv50_priv_tp_trap(priv, 6, 0x408900, 0x408600, display,
+		nv50_gr_tp_trap(gr, 6, 0x408900, 0x408600, display,
 				    "TRAP_TEXTURE");
-		nv_wr32(priv, 0x400108, 0x040);
+		nv_wr32(gr, 0x400108, 0x040);
 		status &= ~0x040;
 	}
 
 	/* MP: CUDA execution engines. */
 	if (status & 0x080) {
-		nv50_priv_tp_trap(priv, 7, 0x408314, 0x40831c, display,
+		nv50_gr_tp_trap(gr, 7, 0x408314, 0x40831c, display,
 				    "TRAP_MP");
-		nv_wr32(priv, 0x400108, 0x080);
+		nv_wr32(gr, 0x400108, 0x080);
 		status &= ~0x080;
 	}
 
 	/* PROP:  Handles TP-initiated uncached memory accesses:
 	 * l[], g[], stack, 2d surfaces, render targets. */
 	if (status & 0x100) {
-		nv50_priv_tp_trap(priv, 8, 0x408e08, 0x408708, display,
+		nv50_gr_tp_trap(gr, 8, 0x408e08, 0x408708, display,
 				    "TRAP_PROP");
-		nv_wr32(priv, 0x400108, 0x100);
+		nv_wr32(gr, 0x400108, 0x100);
 		status &= ~0x100;
 	}
 
 	if (status) {
 		if (display)
-			nv_error(priv, "TRAP: unknown 0x%08x\n", status);
-		nv_wr32(priv, 0x400108, status);
+			nv_error(gr, "TRAP: unknown 0x%08x\n", status);
+		nv_wr32(gr, 0x400108, status);
 	}
 
 	return 1;
@@ -786,14 +784,14 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 	struct nvkm_engine *engine = nv_engine(subdev);
 	struct nvkm_object *engctx;
 	struct nvkm_handle *handle = NULL;
-	struct nv50_gr_priv *priv = (void *)subdev;
-	u32 stat = nv_rd32(priv, 0x400100);
-	u32 inst = nv_rd32(priv, 0x40032c) & 0x0fffffff;
-	u32 addr = nv_rd32(priv, 0x400704);
+	struct nv50_gr *gr = (void *)subdev;
+	u32 stat = nv_rd32(gr, 0x400100);
+	u32 inst = nv_rd32(gr, 0x40032c) & 0x0fffffff;
+	u32 addr = nv_rd32(gr, 0x400704);
 	u32 subc = (addr & 0x00070000) >> 16;
 	u32 mthd = (addr & 0x00001ffc);
-	u32 data = nv_rd32(priv, 0x400708);
-	u32 class = nv_rd32(priv, 0x400814);
+	u32 data = nv_rd32(gr, 0x400708);
+	u32 class = nv_rd32(gr, 0x400814);
 	u32 show = stat, show_bitfield = stat;
 	int chid;
 
@@ -808,38 +806,38 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 	}
 
 	if (show & 0x00100000) {
-		u32 ecode = nv_rd32(priv, 0x400110);
-		nv_error(priv, "DATA_ERROR ");
+		u32 ecode = nv_rd32(gr, 0x400110);
+		nv_error(gr, "DATA_ERROR ");
 		nvkm_enum_print(nv50_data_error_names, ecode);
 		pr_cont("\n");
 		show_bitfield &= ~0x00100000;
 	}
 
 	if (stat & 0x00200000) {
-		if (!nv50_gr_trap_handler(priv, show, chid, (u64)inst << 12,
+		if (!nv50_gr_trap_handler(gr, show, chid, (u64)inst << 12,
 					  engctx))
 			show &= ~0x00200000;
 		show_bitfield &= ~0x00200000;
 	}
 
-	nv_wr32(priv, 0x400100, stat);
-	nv_wr32(priv, 0x400500, 0x00010001);
+	nv_wr32(gr, 0x400100, stat);
+	nv_wr32(gr, 0x400500, 0x00010001);
 
 	if (show) {
 		show &= show_bitfield;
 		if (show) {
-			nv_error(priv, "%s", "");
+			nv_error(gr, "%s", "");
 			nvkm_bitfield_print(nv50_gr_intr_name, show);
 			pr_cont("\n");
 		}
-		nv_error(priv,
+		nv_error(gr,
 			 "ch %d [0x%010llx %s] subc %d class 0x%04x mthd 0x%04x data 0x%08x\n",
 			 chid, (u64)inst << 12, nvkm_client_name(engctx),
 			 subc, class, mthd, data);
 	}
 
-	if (nv_rd32(priv, 0x400824) & (1 << 31))
-		nv_wr32(priv, 0x400824, nv_rd32(priv, 0x400824) & ~(1 << 31));
+	if (nv_rd32(gr, 0x400824) & (1 << 31))
+		nv_wr32(gr, 0x400824, nv_rd32(gr, 0x400824) & ~(1 << 31));
 
 	nvkm_engctx_put(engctx);
 }
@@ -849,23 +847,23 @@ nv50_gr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	     struct nvkm_oclass *oclass, void *data, u32 size,
 	     struct nvkm_object **pobject)
 {
-	struct nv50_gr_priv *priv;
+	struct nv50_gr *gr;
 	int ret;
 
-	ret = nvkm_gr_create(parent, engine, oclass, true, &priv);
-	*pobject = nv_object(priv);
+	ret = nvkm_gr_create(parent, engine, oclass, true, &gr);
+	*pobject = nv_object(gr);
 	if (ret)
 		return ret;
 
-	nv_subdev(priv)->unit = 0x00201000;
-	nv_subdev(priv)->intr = nv50_gr_intr;
-	nv_engine(priv)->cclass = &nv50_gr_cclass;
+	nv_subdev(gr)->unit = 0x00201000;
+	nv_subdev(gr)->intr = nv50_gr_intr;
+	nv_engine(gr)->cclass = &nv50_gr_cclass;
 
-	priv->base.units = nv50_gr_units;
+	gr->base.units = nv50_gr_units;
 
-	switch (nv_device(priv)->chipset) {
+	switch (nv_device(gr)->chipset) {
 	case 0x50:
-		nv_engine(priv)->sclass = nv50_gr_sclass;
+		nv_engine(gr)->sclass = nv50_gr_sclass;
 		break;
 	case 0x84:
 	case 0x86:
@@ -873,104 +871,104 @@ nv50_gr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	case 0x94:
 	case 0x96:
 	case 0x98:
-		nv_engine(priv)->sclass = g84_gr_sclass;
+		nv_engine(gr)->sclass = g84_gr_sclass;
 		break;
 	case 0xa0:
 	case 0xaa:
 	case 0xac:
-		nv_engine(priv)->sclass = gt200_gr_sclass;
+		nv_engine(gr)->sclass = gt200_gr_sclass;
 		break;
 	case 0xa3:
 	case 0xa5:
 	case 0xa8:
-		nv_engine(priv)->sclass = gt215_gr_sclass;
+		nv_engine(gr)->sclass = gt215_gr_sclass;
 		break;
 	case 0xaf:
-		nv_engine(priv)->sclass = mcp89_gr_sclass;
+		nv_engine(gr)->sclass = mcp89_gr_sclass;
 		break;
 
 	}
 
 	/* unfortunate hw bug workaround... */
-	if (nv_device(priv)->chipset != 0x50 &&
-	    nv_device(priv)->chipset != 0xac)
-		nv_engine(priv)->tlb_flush = g84_gr_tlb_flush;
+	if (nv_device(gr)->chipset != 0x50 &&
+	    nv_device(gr)->chipset != 0xac)
+		nv_engine(gr)->tlb_flush = g84_gr_tlb_flush;
 
-	spin_lock_init(&priv->lock);
+	spin_lock_init(&gr->lock);
 	return 0;
 }
 
 static int
 nv50_gr_init(struct nvkm_object *object)
 {
-	struct nv50_gr_priv *priv = (void *)object;
+	struct nv50_gr *gr = (void *)object;
 	int ret, units, i;
 
-	ret = nvkm_gr_init(&priv->base);
+	ret = nvkm_gr_init(&gr->base);
 	if (ret)
 		return ret;
 
 	/* NV_PGRAPH_DEBUG_3_HW_CTX_SWITCH_ENABLED */
-	nv_wr32(priv, 0x40008c, 0x00000004);
+	nv_wr32(gr, 0x40008c, 0x00000004);
 
 	/* reset/enable traps and interrupts */
-	nv_wr32(priv, 0x400804, 0xc0000000);
-	nv_wr32(priv, 0x406800, 0xc0000000);
-	nv_wr32(priv, 0x400c04, 0xc0000000);
-	nv_wr32(priv, 0x401800, 0xc0000000);
-	nv_wr32(priv, 0x405018, 0xc0000000);
-	nv_wr32(priv, 0x402000, 0xc0000000);
-
-	units = nv_rd32(priv, 0x001540);
+	nv_wr32(gr, 0x400804, 0xc0000000);
+	nv_wr32(gr, 0x406800, 0xc0000000);
+	nv_wr32(gr, 0x400c04, 0xc0000000);
+	nv_wr32(gr, 0x401800, 0xc0000000);
+	nv_wr32(gr, 0x405018, 0xc0000000);
+	nv_wr32(gr, 0x402000, 0xc0000000);
+
+	units = nv_rd32(gr, 0x001540);
 	for (i = 0; i < 16; i++) {
 		if (!(units & (1 << i)))
 			continue;
 
-		if (nv_device(priv)->chipset < 0xa0) {
-			nv_wr32(priv, 0x408900 + (i << 12), 0xc0000000);
-			nv_wr32(priv, 0x408e08 + (i << 12), 0xc0000000);
-			nv_wr32(priv, 0x408314 + (i << 12), 0xc0000000);
+		if (nv_device(gr)->chipset < 0xa0) {
+			nv_wr32(gr, 0x408900 + (i << 12), 0xc0000000);
+			nv_wr32(gr, 0x408e08 + (i << 12), 0xc0000000);
+			nv_wr32(gr, 0x408314 + (i << 12), 0xc0000000);
 		} else {
-			nv_wr32(priv, 0x408600 + (i << 11), 0xc0000000);
-			nv_wr32(priv, 0x408708 + (i << 11), 0xc0000000);
-			nv_wr32(priv, 0x40831c + (i << 11), 0xc0000000);
+			nv_wr32(gr, 0x408600 + (i << 11), 0xc0000000);
+			nv_wr32(gr, 0x408708 + (i << 11), 0xc0000000);
+			nv_wr32(gr, 0x40831c + (i << 11), 0xc0000000);
 		}
 	}
 
-	nv_wr32(priv, 0x400108, 0xffffffff);
-	nv_wr32(priv, 0x400138, 0xffffffff);
-	nv_wr32(priv, 0x400100, 0xffffffff);
-	nv_wr32(priv, 0x40013c, 0xffffffff);
-	nv_wr32(priv, 0x400500, 0x00010001);
+	nv_wr32(gr, 0x400108, 0xffffffff);
+	nv_wr32(gr, 0x400138, 0xffffffff);
+	nv_wr32(gr, 0x400100, 0xffffffff);
+	nv_wr32(gr, 0x40013c, 0xffffffff);
+	nv_wr32(gr, 0x400500, 0x00010001);
 
 	/* upload context program, initialise ctxctl defaults */
-	ret = nv50_grctx_init(nv_device(priv), &priv->size);
+	ret = nv50_grctx_init(nv_device(gr), &gr->size);
 	if (ret)
 		return ret;
 
-	nv_wr32(priv, 0x400824, 0x00000000);
-	nv_wr32(priv, 0x400828, 0x00000000);
-	nv_wr32(priv, 0x40082c, 0x00000000);
-	nv_wr32(priv, 0x400830, 0x00000000);
-	nv_wr32(priv, 0x40032c, 0x00000000);
-	nv_wr32(priv, 0x400330, 0x00000000);
+	nv_wr32(gr, 0x400824, 0x00000000);
+	nv_wr32(gr, 0x400828, 0x00000000);
+	nv_wr32(gr, 0x40082c, 0x00000000);
+	nv_wr32(gr, 0x400830, 0x00000000);
+	nv_wr32(gr, 0x40032c, 0x00000000);
+	nv_wr32(gr, 0x400330, 0x00000000);
 
 	/* some unknown zcull magic */
-	switch (nv_device(priv)->chipset & 0xf0) {
+	switch (nv_device(gr)->chipset & 0xf0) {
 	case 0x50:
 	case 0x80:
 	case 0x90:
-		nv_wr32(priv, 0x402ca8, 0x00000800);
+		nv_wr32(gr, 0x402ca8, 0x00000800);
 		break;
 	case 0xa0:
 	default:
-		if (nv_device(priv)->chipset == 0xa0 ||
-		    nv_device(priv)->chipset == 0xaa ||
-		    nv_device(priv)->chipset == 0xac) {
-			nv_wr32(priv, 0x402ca8, 0x00000802);
+		if (nv_device(gr)->chipset == 0xa0 ||
+		    nv_device(gr)->chipset == 0xaa ||
+		    nv_device(gr)->chipset == 0xac) {
+			nv_wr32(gr, 0x402ca8, 0x00000802);
 		} else {
-			nv_wr32(priv, 0x402cc0, 0x00000000);
-			nv_wr32(priv, 0x402ca8, 0x00000002);
+			nv_wr32(gr, 0x402cc0, 0x00000000);
+			nv_wr32(gr, 0x402ca8, 0x00000002);
 		}
 
 		break;
@@ -978,10 +976,10 @@ nv50_gr_init(struct nvkm_object *object)
 
 	/* zero out zcull regions */
 	for (i = 0; i < 8; i++) {
-		nv_wr32(priv, 0x402c20 + (i * 0x10), 0x00000000);
-		nv_wr32(priv, 0x402c24 + (i * 0x10), 0x00000000);
-		nv_wr32(priv, 0x402c28 + (i * 0x10), 0x00000000);
-		nv_wr32(priv, 0x402c2c + (i * 0x10), 0x00000000);
+		nv_wr32(gr, 0x402c20 + (i * 0x10), 0x00000000);
+		nv_wr32(gr, 0x402c24 + (i * 0x10), 0x00000000);
+		nv_wr32(gr, 0x402c28 + (i * 0x10), 0x00000000);
+		nv_wr32(gr, 0x402c2c + (i * 0x10), 0x00000000);
 	}
 	return 0;
 }

commit 6189f1b0938dc0621c27494031b83ffae566e318
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/fifo: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index f18b75b883ac..e232cb8e2f9e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -782,7 +782,7 @@ nv50_gr_trap_handler(struct nv50_gr_priv *priv, u32 display,
 static void
 nv50_gr_intr(struct nvkm_subdev *subdev)
 {
-	struct nvkm_fifo *pfifo = nvkm_fifo(subdev);
+	struct nvkm_fifo *fifo = nvkm_fifo(subdev);
 	struct nvkm_engine *engine = nv_engine(subdev);
 	struct nvkm_object *engctx;
 	struct nvkm_handle *handle = NULL;
@@ -798,7 +798,7 @@ nv50_gr_intr(struct nvkm_subdev *subdev)
 	int chid;
 
 	engctx = nvkm_engctx_get(engine, inst);
-	chid   = pfifo->chid(pfifo, engctx);
+	chid   = fifo->chid(fifo, engctx);
 
 	if (stat & 0x00000010) {
 		handle = nvkm_handle_get_class(engctx, class);

commit cb8bb9cedb6015eafd56ef9e9c5b2c216e8e7960
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/tmr: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index 754284feae91..f18b75b883ac 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -237,7 +237,7 @@ nvkm_pgr_vstatus_print(struct nv50_gr_priv *priv, int r,
 static int
 g84_gr_tlb_flush(struct nvkm_engine *engine)
 {
-	struct nvkm_timer *ptimer = nvkm_timer(engine);
+	struct nvkm_timer *tmr = nvkm_timer(engine);
 	struct nv50_gr_priv *priv = (void *)engine;
 	bool idle, timeout = false;
 	unsigned long flags;
@@ -247,7 +247,7 @@ g84_gr_tlb_flush(struct nvkm_engine *engine)
 	spin_lock_irqsave(&priv->lock, flags);
 	nv_mask(priv, 0x400500, 0x00000001, 0x00000000);
 
-	start = ptimer->read(ptimer);
+	start = tmr->read(tmr);
 	do {
 		idle = true;
 
@@ -266,7 +266,7 @@ g84_gr_tlb_flush(struct nvkm_engine *engine)
 				idle = false;
 		}
 	} while (!idle &&
-		 !(timeout = ptimer->read(ptimer) - start > 2000000000));
+		 !(timeout = tmr->read(tmr) - start > 2000000000));
 
 	if (timeout) {
 		nv_error(priv, "PGRAPH TLB flush idle timeout fail\n");

commit 9ace404b1098221021b01c2ba0eeea0c257fa4a5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/device: include core/device.h automatically for subdevs/engines
    
    Pretty much every subdev/engine is going to need access to nvkm_device
    shortly to touch registers and/or output messages.
    
    The odd placement of the includes is necessary to work around some
    inter-dependencies that currently exist.  This will be fixed later.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index 270d7cd63fc7..754284feae91 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -24,7 +24,6 @@
 #include "nv50.h"
 
 #include <core/client.h>
-#include <core/device.h>
 #include <core/handle.h>
 #include <engine/fifo.h>
 #include <subdev/timer.h>

commit e3c71eb27419b600dcacea9f268254369e6550c4
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:29:43 2015 +1000

    drm/nouveau/gr: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index 9d7fcbd96522..270d7cd63fc7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -21,35 +21,26 @@
  *
  * Authors: Ben Skeggs
  */
+#include "nv50.h"
 
-#include <core/os.h>
 #include <core/client.h>
 #include <core/device.h>
 #include <core/handle.h>
-#include <core/engctx.h>
-#include <core/enum.h>
-
-#include <subdev/fb.h>
-#include <subdev/mmu.h>
-#include <subdev/timer.h>
-
 #include <engine/fifo.h>
-#include <engine/gr.h>
-
-#include "nv50.h"
+#include <subdev/timer.h>
 
 struct nv50_gr_priv {
-	struct nouveau_gr base;
+	struct nvkm_gr base;
 	spinlock_t lock;
 	u32 size;
 };
 
 struct nv50_gr_chan {
-	struct nouveau_gr_chan base;
+	struct nvkm_gr_chan base;
 };
 
 static u64
-nv50_gr_units(struct nouveau_gr *gr)
+nv50_gr_units(struct nvkm_gr *gr)
 {
 	struct nv50_gr_priv *priv = (void *)gr;
 
@@ -61,16 +52,15 @@ nv50_gr_units(struct nouveau_gr *gr)
  ******************************************************************************/
 
 static int
-nv50_gr_object_ctor(struct nouveau_object *parent,
-		       struct nouveau_object *engine,
-		       struct nouveau_oclass *oclass, void *data, u32 size,
-		       struct nouveau_object **pobject)
+nv50_gr_object_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+		    struct nvkm_oclass *oclass, void *data, u32 size,
+		    struct nvkm_object **pobject)
 {
-	struct nouveau_gpuobj *obj;
+	struct nvkm_gpuobj *obj;
 	int ret;
 
-	ret = nouveau_gpuobj_create(parent, engine, oclass, 0, parent,
-				    16, 16, 0, &obj);
+	ret = nvkm_gpuobj_create(parent, engine, oclass, 0, parent,
+				 16, 16, 0, &obj);
 	*pobject = nv_object(obj);
 	if (ret)
 		return ret;
@@ -82,17 +72,17 @@ nv50_gr_object_ctor(struct nouveau_object *parent,
 	return 0;
 }
 
-static struct nouveau_ofuncs
+static struct nvkm_ofuncs
 nv50_gr_ofuncs = {
 	.ctor = nv50_gr_object_ctor,
-	.dtor = _nouveau_gpuobj_dtor,
-	.init = _nouveau_gpuobj_init,
-	.fini = _nouveau_gpuobj_fini,
-	.rd32 = _nouveau_gpuobj_rd32,
-	.wr32 = _nouveau_gpuobj_wr32,
+	.dtor = _nvkm_gpuobj_dtor,
+	.init = _nvkm_gpuobj_init,
+	.fini = _nvkm_gpuobj_fini,
+	.rd32 = _nvkm_gpuobj_rd32,
+	.wr32 = _nvkm_gpuobj_wr32,
 };
 
-static struct nouveau_oclass
+static struct nvkm_oclass
 nv50_gr_sclass[] = {
 	{ 0x0030, &nv50_gr_ofuncs },
 	{ 0x502d, &nv50_gr_ofuncs },
@@ -102,8 +92,8 @@ nv50_gr_sclass[] = {
 	{}
 };
 
-static struct nouveau_oclass
-nv84_gr_sclass[] = {
+static struct nvkm_oclass
+g84_gr_sclass[] = {
 	{ 0x0030, &nv50_gr_ofuncs },
 	{ 0x502d, &nv50_gr_ofuncs },
 	{ 0x5039, &nv50_gr_ofuncs },
@@ -112,8 +102,8 @@ nv84_gr_sclass[] = {
 	{}
 };
 
-static struct nouveau_oclass
-nva0_gr_sclass[] = {
+static struct nvkm_oclass
+gt200_gr_sclass[] = {
 	{ 0x0030, &nv50_gr_ofuncs },
 	{ 0x502d, &nv50_gr_ofuncs },
 	{ 0x5039, &nv50_gr_ofuncs },
@@ -122,8 +112,8 @@ nva0_gr_sclass[] = {
 	{}
 };
 
-static struct nouveau_oclass
-nva3_gr_sclass[] = {
+static struct nvkm_oclass
+gt215_gr_sclass[] = {
 	{ 0x0030, &nv50_gr_ofuncs },
 	{ 0x502d, &nv50_gr_ofuncs },
 	{ 0x5039, &nv50_gr_ofuncs },
@@ -133,8 +123,8 @@ nva3_gr_sclass[] = {
 	{}
 };
 
-static struct nouveau_oclass
-nvaf_gr_sclass[] = {
+static struct nvkm_oclass
+mcp89_gr_sclass[] = {
 	{ 0x0030, &nv50_gr_ofuncs },
 	{ 0x502d, &nv50_gr_ofuncs },
 	{ 0x5039, &nv50_gr_ofuncs },
@@ -149,18 +139,16 @@ nvaf_gr_sclass[] = {
  ******************************************************************************/
 
 static int
-nv50_gr_context_ctor(struct nouveau_object *parent,
-			struct nouveau_object *engine,
-			struct nouveau_oclass *oclass, void *data, u32 size,
-			struct nouveau_object **pobject)
+nv50_gr_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+		     struct nvkm_oclass *oclass, void *data, u32 size,
+		     struct nvkm_object **pobject)
 {
 	struct nv50_gr_priv *priv = (void *)engine;
 	struct nv50_gr_chan *chan;
 	int ret;
 
-	ret = nouveau_gr_context_create(parent, engine, oclass, NULL,
-					   priv->size, 0,
-					   NVOBJ_FLAG_ZERO_ALLOC, &chan);
+	ret = nvkm_gr_context_create(parent, engine, oclass, NULL, priv->size,
+				     0, NVOBJ_FLAG_ZERO_ALLOC, &chan);
 	*pobject = nv_object(chan);
 	if (ret)
 		return ret;
@@ -169,16 +157,16 @@ nv50_gr_context_ctor(struct nouveau_object *parent,
 	return 0;
 }
 
-static struct nouveau_oclass
+static struct nvkm_oclass
 nv50_gr_cclass = {
 	.handle = NV_ENGCTX(GR, 0x50),
-	.ofuncs = &(struct nouveau_ofuncs) {
+	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv50_gr_context_ctor,
-		.dtor = _nouveau_gr_context_dtor,
-		.init = _nouveau_gr_context_init,
-		.fini = _nouveau_gr_context_fini,
-		.rd32 = _nouveau_gr_context_rd32,
-		.wr32 = _nouveau_gr_context_wr32,
+		.dtor = _nvkm_gr_context_dtor,
+		.init = _nvkm_gr_context_init,
+		.fini = _nvkm_gr_context_fini,
+		.rd32 = _nvkm_gr_context_rd32,
+		.wr32 = _nvkm_gr_context_wr32,
 	},
 };
 
@@ -186,7 +174,7 @@ nv50_gr_cclass = {
  * PGRAPH engine/subdev functions
  ******************************************************************************/
 
-static const struct nouveau_bitfield nv50_pgr_status[] = {
+static const struct nvkm_bitfield nv50_pgr_status[] = {
 	{ 0x00000001, "BUSY" }, /* set when any bit is set */
 	{ 0x00000002, "DISPATCH" },
 	{ 0x00000004, "UNK2" },
@@ -229,8 +217,9 @@ static const char *const nv50_pgr_vstatus_2[] = {
 	"ROP", NULL
 };
 
-static void nouveau_pgr_vstatus_print(struct nv50_gr_priv *priv, int r,
-		const char *const units[], u32 status)
+static void
+nvkm_pgr_vstatus_print(struct nv50_gr_priv *priv, int r,
+		       const char *const units[], u32 status)
 {
 	int i;
 
@@ -247,9 +236,9 @@ static void nouveau_pgr_vstatus_print(struct nv50_gr_priv *priv, int r,
 }
 
 static int
-nv84_gr_tlb_flush(struct nouveau_engine *engine)
+g84_gr_tlb_flush(struct nvkm_engine *engine)
 {
-	struct nouveau_timer *ptimer = nouveau_timer(engine);
+	struct nvkm_timer *ptimer = nvkm_timer(engine);
 	struct nv50_gr_priv *priv = (void *)engine;
 	bool idle, timeout = false;
 	unsigned long flags;
@@ -285,15 +274,15 @@ nv84_gr_tlb_flush(struct nouveau_engine *engine)
 
 		tmp = nv_rd32(priv, 0x400700);
 		nv_error(priv, "PGRAPH_STATUS  : 0x%08x", tmp);
-		nouveau_bitfield_print(nv50_pgr_status, tmp);
+		nvkm_bitfield_print(nv50_pgr_status, tmp);
 		pr_cont("\n");
 
-		nouveau_pgr_vstatus_print(priv, 0, nv50_pgr_vstatus_0,
-				nv_rd32(priv, 0x400380));
-		nouveau_pgr_vstatus_print(priv, 1, nv50_pgr_vstatus_1,
-				nv_rd32(priv, 0x400384));
-		nouveau_pgr_vstatus_print(priv, 2, nv50_pgr_vstatus_2,
-				nv_rd32(priv, 0x400388));
+		nvkm_pgr_vstatus_print(priv, 0, nv50_pgr_vstatus_0,
+				       nv_rd32(priv, 0x400380));
+		nvkm_pgr_vstatus_print(priv, 1, nv50_pgr_vstatus_1,
+				       nv_rd32(priv, 0x400384));
+		nvkm_pgr_vstatus_print(priv, 2, nv50_pgr_vstatus_2,
+				       nv_rd32(priv, 0x400388));
 	}
 
 
@@ -305,7 +294,7 @@ nv84_gr_tlb_flush(struct nouveau_engine *engine)
 	return timeout ? -EBUSY : 0;
 }
 
-static const struct nouveau_bitfield nv50_mp_exec_errors[] = {
+static const struct nvkm_bitfield nv50_mp_exec_errors[] = {
 	{ 0x01, "STACK_UNDERFLOW" },
 	{ 0x02, "STACK_MISMATCH" },
 	{ 0x04, "QUADON_ACTIVE" },
@@ -316,7 +305,7 @@ static const struct nouveau_bitfield nv50_mp_exec_errors[] = {
 	{}
 };
 
-static const struct nouveau_bitfield nv50_mpc_traps[] = {
+static const struct nvkm_bitfield nv50_mpc_traps[] = {
 	{ 0x0000001, "LOCAL_LIMIT_READ" },
 	{ 0x0000010, "LOCAL_LIMIT_WRITE" },
 	{ 0x0000040, "STACK_LIMIT" },
@@ -330,7 +319,7 @@ static const struct nouveau_bitfield nv50_mpc_traps[] = {
 	{}
 };
 
-static const struct nouveau_bitfield nv50_tex_traps[] = {
+static const struct nvkm_bitfield nv50_tex_traps[] = {
 	{ 0x00000001, "" }, /* any bit set? */
 	{ 0x00000002, "FAULT" },
 	{ 0x00000004, "STORAGE_TYPE_MISMATCH" },
@@ -339,30 +328,30 @@ static const struct nouveau_bitfield nv50_tex_traps[] = {
 	{}
 };
 
-static const struct nouveau_bitfield nv50_gr_trap_m2mf[] = {
+static const struct nvkm_bitfield nv50_gr_trap_m2mf[] = {
 	{ 0x00000001, "NOTIFY" },
 	{ 0x00000002, "IN" },
 	{ 0x00000004, "OUT" },
 	{}
 };
 
-static const struct nouveau_bitfield nv50_gr_trap_vfetch[] = {
+static const struct nvkm_bitfield nv50_gr_trap_vfetch[] = {
 	{ 0x00000001, "FAULT" },
 	{}
 };
 
-static const struct nouveau_bitfield nv50_gr_trap_strmout[] = {
+static const struct nvkm_bitfield nv50_gr_trap_strmout[] = {
 	{ 0x00000001, "FAULT" },
 	{}
 };
 
-static const struct nouveau_bitfield nv50_gr_trap_ccache[] = {
+static const struct nvkm_bitfield nv50_gr_trap_ccache[] = {
 	{ 0x00000001, "FAULT" },
 	{}
 };
 
 /* There must be a *lot* of these. Will take some time to gather them up. */
-const struct nouveau_enum nv50_data_error_names[] = {
+const struct nvkm_enum nv50_data_error_names[] = {
 	{ 0x00000003, "INVALID_OPERATION", NULL },
 	{ 0x00000004, "INVALID_VALUE", NULL },
 	{ 0x00000005, "INVALID_ENUM", NULL },
@@ -408,7 +397,7 @@ const struct nouveau_enum nv50_data_error_names[] = {
 	{}
 };
 
-static const struct nouveau_bitfield nv50_gr_intr_name[] = {
+static const struct nvkm_bitfield nv50_gr_intr_name[] = {
 	{ 0x00000001, "NOTIFY" },
 	{ 0x00000002, "COMPUTE_QUERY" },
 	{ 0x00000010, "ILLEGAL_MTHD" },
@@ -422,7 +411,7 @@ static const struct nouveau_bitfield nv50_gr_intr_name[] = {
 	{}
 };
 
-static const struct nouveau_bitfield nv50_gr_trap_prop[] = {
+static const struct nvkm_bitfield nv50_gr_trap_prop[] = {
 	{ 0x00000004, "SURF_WIDTH_OVERRUN" },
 	{ 0x00000008, "SURF_HEIGHT_OVERRUN" },
 	{ 0x00000010, "DST2D_FAULT" },
@@ -469,7 +458,7 @@ nv50_priv_prop_trap(struct nv50_gr_priv *priv,
 	}
 	if (ustatus) {
 		nv_error(priv, "TRAP_PROP - TP %d -", tp);
-		nouveau_bitfield_print(nv50_gr_trap_prop, ustatus);
+		nvkm_bitfield_print(nv50_gr_trap_prop, ustatus);
 		pr_cont(" - Address %02x%08x\n", e14, e10);
 	}
 	nv_error(priv, "TRAP_PROP - TP %d - e0c: %08x, e18: %08x, e1c: %08x, e20: %08x, e24: %08x\n",
@@ -501,7 +490,7 @@ nv50_priv_mp_trap(struct nv50_gr_priv *priv, int tpid, int display)
 			ophigh = nv_rd32(priv, addr + 0x74);
 			nv_error(priv, "TRAP_MP_EXEC - "
 					"TP %d MP %d:", tpid, i);
-			nouveau_bitfield_print(nv50_mp_exec_errors, status);
+			nvkm_bitfield_print(nv50_mp_exec_errors, status);
 			pr_cont(" at %06x warp %d, opcode %08x %08x\n",
 					pc&0xffffff, pc >> 24,
 					oplow, ophigh);
@@ -517,7 +506,7 @@ nv50_priv_mp_trap(struct nv50_gr_priv *priv, int tpid, int display)
 
 static void
 nv50_priv_tp_trap(struct nv50_gr_priv *priv, int type, u32 ustatus_old,
-		u32 ustatus_new, int display, const char *name)
+		  u32 ustatus_new, int display, const char *name)
 {
 	int tps = 0;
 	u32 units = nv_rd32(priv, 0x1540);
@@ -543,7 +532,7 @@ nv50_priv_tp_trap(struct nv50_gr_priv *priv, int type, u32 ustatus_old,
 						nv_rd32(priv, r));
 				if (ustatus) {
 					nv_error(priv, "%s - TP%d:", name, i);
-					nouveau_bitfield_print(nv50_tex_traps,
+					nvkm_bitfield_print(nv50_tex_traps,
 							       ustatus);
 					pr_cont("\n");
 					ustatus = 0;
@@ -557,7 +546,7 @@ nv50_priv_tp_trap(struct nv50_gr_priv *priv, int type, u32 ustatus_old,
 			}
 			if (ustatus && display) {
 				nv_error(priv, "%s - TP%d:", name, i);
-				nouveau_bitfield_print(nv50_mpc_traps, ustatus);
+				nvkm_bitfield_print(nv50_mpc_traps, ustatus);
 				pr_cont("\n");
 				ustatus = 0;
 			}
@@ -582,7 +571,7 @@ nv50_priv_tp_trap(struct nv50_gr_priv *priv, int type, u32 ustatus_old,
 
 static int
 nv50_gr_trap_handler(struct nv50_gr_priv *priv, u32 display,
-			int chid, u64 inst, struct nouveau_object *engctx)
+		     int chid, u64 inst, struct nvkm_object *engctx)
 {
 	u32 status = nv_rd32(priv, 0x400108);
 	u32 ustatus;
@@ -618,7 +607,7 @@ nv50_gr_trap_handler(struct nv50_gr_priv *priv, u32 display,
 				nv_error(priv,
 					 "ch %d [0x%010llx %s] subc %d class 0x%04x mthd 0x%04x data 0x%08x%08x 400808 0x%08x 400848 0x%08x\n",
 					 chid, inst,
-					 nouveau_client_name(engctx), subc,
+					 nvkm_client_name(engctx), subc,
 					 class, mthd, datah, datal, addr, r848);
 			} else
 			if (display) {
@@ -643,7 +632,7 @@ nv50_gr_trap_handler(struct nv50_gr_priv *priv, u32 display,
 				nv_error(priv,
 					 "ch %d [0x%010llx %s] subc %d class 0x%04x mthd 0x%04x data 0x%08x 40084c 0x%08x\n",
 					 chid, inst,
-					 nouveau_client_name(engctx), subc,
+					 nvkm_client_name(engctx), subc,
 					 class, mthd, data, addr);
 			} else
 			if (display) {
@@ -671,7 +660,7 @@ nv50_gr_trap_handler(struct nv50_gr_priv *priv, u32 display,
 		u32 ustatus = nv_rd32(priv, 0x406800) & 0x7fffffff;
 		if (display) {
 			nv_error(priv, "TRAP_M2MF");
-			nouveau_bitfield_print(nv50_gr_trap_m2mf, ustatus);
+			nvkm_bitfield_print(nv50_gr_trap_m2mf, ustatus);
 			pr_cont("\n");
 			nv_error(priv, "TRAP_M2MF %08x %08x %08x %08x\n",
 				nv_rd32(priv, 0x406804), nv_rd32(priv, 0x406808),
@@ -692,7 +681,7 @@ nv50_gr_trap_handler(struct nv50_gr_priv *priv, u32 display,
 		u32 ustatus = nv_rd32(priv, 0x400c04) & 0x7fffffff;
 		if (display) {
 			nv_error(priv, "TRAP_VFETCH");
-			nouveau_bitfield_print(nv50_gr_trap_vfetch, ustatus);
+			nvkm_bitfield_print(nv50_gr_trap_vfetch, ustatus);
 			pr_cont("\n");
 			nv_error(priv, "TRAP_VFETCH %08x %08x %08x %08x\n",
 				nv_rd32(priv, 0x400c00), nv_rd32(priv, 0x400c08),
@@ -709,7 +698,7 @@ nv50_gr_trap_handler(struct nv50_gr_priv *priv, u32 display,
 		ustatus = nv_rd32(priv, 0x401800) & 0x7fffffff;
 		if (display) {
 			nv_error(priv, "TRAP_STRMOUT");
-			nouveau_bitfield_print(nv50_gr_trap_strmout, ustatus);
+			nvkm_bitfield_print(nv50_gr_trap_strmout, ustatus);
 			pr_cont("\n");
 			nv_error(priv, "TRAP_STRMOUT %08x %08x %08x %08x\n",
 				nv_rd32(priv, 0x401804), nv_rd32(priv, 0x401808),
@@ -730,7 +719,7 @@ nv50_gr_trap_handler(struct nv50_gr_priv *priv, u32 display,
 		ustatus = nv_rd32(priv, 0x405018) & 0x7fffffff;
 		if (display) {
 			nv_error(priv, "TRAP_CCACHE");
-			nouveau_bitfield_print(nv50_gr_trap_ccache, ustatus);
+			nvkm_bitfield_print(nv50_gr_trap_ccache, ustatus);
 			pr_cont("\n");
 			nv_error(priv, "TRAP_CCACHE %08x %08x %08x %08x"
 				     " %08x %08x %08x\n",
@@ -792,12 +781,12 @@ nv50_gr_trap_handler(struct nv50_gr_priv *priv, u32 display,
 }
 
 static void
-nv50_gr_intr(struct nouveau_subdev *subdev)
+nv50_gr_intr(struct nvkm_subdev *subdev)
 {
-	struct nouveau_fifo *pfifo = nouveau_fifo(subdev);
-	struct nouveau_engine *engine = nv_engine(subdev);
-	struct nouveau_object *engctx;
-	struct nouveau_handle *handle = NULL;
+	struct nvkm_fifo *pfifo = nvkm_fifo(subdev);
+	struct nvkm_engine *engine = nv_engine(subdev);
+	struct nvkm_object *engctx;
+	struct nvkm_handle *handle = NULL;
 	struct nv50_gr_priv *priv = (void *)subdev;
 	u32 stat = nv_rd32(priv, 0x400100);
 	u32 inst = nv_rd32(priv, 0x40032c) & 0x0fffffff;
@@ -809,27 +798,27 @@ nv50_gr_intr(struct nouveau_subdev *subdev)
 	u32 show = stat, show_bitfield = stat;
 	int chid;
 
-	engctx = nouveau_engctx_get(engine, inst);
+	engctx = nvkm_engctx_get(engine, inst);
 	chid   = pfifo->chid(pfifo, engctx);
 
 	if (stat & 0x00000010) {
-		handle = nouveau_handle_get_class(engctx, class);
+		handle = nvkm_handle_get_class(engctx, class);
 		if (handle && !nv_call(handle->object, mthd, data))
 			show &= ~0x00000010;
-		nouveau_handle_put(handle);
+		nvkm_handle_put(handle);
 	}
 
 	if (show & 0x00100000) {
 		u32 ecode = nv_rd32(priv, 0x400110);
 		nv_error(priv, "DATA_ERROR ");
-		nouveau_enum_print(nv50_data_error_names, ecode);
+		nvkm_enum_print(nv50_data_error_names, ecode);
 		pr_cont("\n");
 		show_bitfield &= ~0x00100000;
 	}
 
 	if (stat & 0x00200000) {
 		if (!nv50_gr_trap_handler(priv, show, chid, (u64)inst << 12,
-				engctx))
+					  engctx))
 			show &= ~0x00200000;
 		show_bitfield &= ~0x00200000;
 	}
@@ -841,30 +830,30 @@ nv50_gr_intr(struct nouveau_subdev *subdev)
 		show &= show_bitfield;
 		if (show) {
 			nv_error(priv, "%s", "");
-			nouveau_bitfield_print(nv50_gr_intr_name, show);
+			nvkm_bitfield_print(nv50_gr_intr_name, show);
 			pr_cont("\n");
 		}
 		nv_error(priv,
 			 "ch %d [0x%010llx %s] subc %d class 0x%04x mthd 0x%04x data 0x%08x\n",
-			 chid, (u64)inst << 12, nouveau_client_name(engctx),
+			 chid, (u64)inst << 12, nvkm_client_name(engctx),
 			 subc, class, mthd, data);
 	}
 
 	if (nv_rd32(priv, 0x400824) & (1 << 31))
 		nv_wr32(priv, 0x400824, nv_rd32(priv, 0x400824) & ~(1 << 31));
 
-	nouveau_engctx_put(engctx);
+	nvkm_engctx_put(engctx);
 }
 
 static int
-nv50_gr_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
-	       struct nouveau_oclass *oclass, void *data, u32 size,
-	       struct nouveau_object **pobject)
+nv50_gr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+	     struct nvkm_oclass *oclass, void *data, u32 size,
+	     struct nvkm_object **pobject)
 {
 	struct nv50_gr_priv *priv;
 	int ret;
 
-	ret = nouveau_gr_create(parent, engine, oclass, true, &priv);
+	ret = nvkm_gr_create(parent, engine, oclass, true, &priv);
 	*pobject = nv_object(priv);
 	if (ret)
 		return ret;
@@ -885,20 +874,20 @@ nv50_gr_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	case 0x94:
 	case 0x96:
 	case 0x98:
-		nv_engine(priv)->sclass = nv84_gr_sclass;
+		nv_engine(priv)->sclass = g84_gr_sclass;
 		break;
 	case 0xa0:
 	case 0xaa:
 	case 0xac:
-		nv_engine(priv)->sclass = nva0_gr_sclass;
+		nv_engine(priv)->sclass = gt200_gr_sclass;
 		break;
 	case 0xa3:
 	case 0xa5:
 	case 0xa8:
-		nv_engine(priv)->sclass = nva3_gr_sclass;
+		nv_engine(priv)->sclass = gt215_gr_sclass;
 		break;
 	case 0xaf:
-		nv_engine(priv)->sclass = nvaf_gr_sclass;
+		nv_engine(priv)->sclass = mcp89_gr_sclass;
 		break;
 
 	}
@@ -906,19 +895,19 @@ nv50_gr_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	/* unfortunate hw bug workaround... */
 	if (nv_device(priv)->chipset != 0x50 &&
 	    nv_device(priv)->chipset != 0xac)
-		nv_engine(priv)->tlb_flush = nv84_gr_tlb_flush;
+		nv_engine(priv)->tlb_flush = g84_gr_tlb_flush;
 
 	spin_lock_init(&priv->lock);
 	return 0;
 }
 
 static int
-nv50_gr_init(struct nouveau_object *object)
+nv50_gr_init(struct nvkm_object *object)
 {
 	struct nv50_gr_priv *priv = (void *)object;
 	int ret, units, i;
 
-	ret = nouveau_gr_init(&priv->base);
+	ret = nvkm_gr_init(&priv->base);
 	if (ret)
 		return ret;
 
@@ -998,13 +987,13 @@ nv50_gr_init(struct nouveau_object *object)
 	return 0;
 }
 
-struct nouveau_oclass
+struct nvkm_oclass
 nv50_gr_oclass = {
 	.handle = NV_ENGINE(GR, 0x50),
-	.ofuncs = &(struct nouveau_ofuncs) {
+	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv50_gr_ctor,
-		.dtor = _nouveau_gr_dtor,
+		.dtor = _nvkm_gr_dtor,
 		.init = nv50_gr_init,
-		.fini = _nouveau_gr_fini,
+		.fini = _nvkm_gr_fini,
 	},
 };

commit 9e79a85343e2191ac83f0ef4fe49b71b9d80ad38
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:12:11 2015 +1000

    drm/nouveau/timer: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
index bd7687c683c8..9d7fcbd96522 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -24,6 +24,7 @@
 
 #include <core/os.h>
 #include <core/client.h>
+#include <core/device.h>
 #include <core/handle.h>
 #include <core/engctx.h>
 #include <core/enum.h>

commit b8bf04e1fd3aba5cdd81ec766fc0372c7894497c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 12:02:28 2015 +1000

    drm/nouveau/gr: rename from graph (no binary change)
    
    Shorter device name, match Tegra and our existing enums.
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
new file mode 100644
index 000000000000..bd7687c683c8
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c
@@ -0,0 +1,1009 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <core/os.h>
+#include <core/client.h>
+#include <core/handle.h>
+#include <core/engctx.h>
+#include <core/enum.h>
+
+#include <subdev/fb.h>
+#include <subdev/mmu.h>
+#include <subdev/timer.h>
+
+#include <engine/fifo.h>
+#include <engine/gr.h>
+
+#include "nv50.h"
+
+struct nv50_gr_priv {
+	struct nouveau_gr base;
+	spinlock_t lock;
+	u32 size;
+};
+
+struct nv50_gr_chan {
+	struct nouveau_gr_chan base;
+};
+
+static u64
+nv50_gr_units(struct nouveau_gr *gr)
+{
+	struct nv50_gr_priv *priv = (void *)gr;
+
+	return nv_rd32(priv, 0x1540);
+}
+
+/*******************************************************************************
+ * Graphics object classes
+ ******************************************************************************/
+
+static int
+nv50_gr_object_ctor(struct nouveau_object *parent,
+		       struct nouveau_object *engine,
+		       struct nouveau_oclass *oclass, void *data, u32 size,
+		       struct nouveau_object **pobject)
+{
+	struct nouveau_gpuobj *obj;
+	int ret;
+
+	ret = nouveau_gpuobj_create(parent, engine, oclass, 0, parent,
+				    16, 16, 0, &obj);
+	*pobject = nv_object(obj);
+	if (ret)
+		return ret;
+
+	nv_wo32(obj, 0x00, nv_mclass(obj));
+	nv_wo32(obj, 0x04, 0x00000000);
+	nv_wo32(obj, 0x08, 0x00000000);
+	nv_wo32(obj, 0x0c, 0x00000000);
+	return 0;
+}
+
+static struct nouveau_ofuncs
+nv50_gr_ofuncs = {
+	.ctor = nv50_gr_object_ctor,
+	.dtor = _nouveau_gpuobj_dtor,
+	.init = _nouveau_gpuobj_init,
+	.fini = _nouveau_gpuobj_fini,
+	.rd32 = _nouveau_gpuobj_rd32,
+	.wr32 = _nouveau_gpuobj_wr32,
+};
+
+static struct nouveau_oclass
+nv50_gr_sclass[] = {
+	{ 0x0030, &nv50_gr_ofuncs },
+	{ 0x502d, &nv50_gr_ofuncs },
+	{ 0x5039, &nv50_gr_ofuncs },
+	{ 0x5097, &nv50_gr_ofuncs },
+	{ 0x50c0, &nv50_gr_ofuncs },
+	{}
+};
+
+static struct nouveau_oclass
+nv84_gr_sclass[] = {
+	{ 0x0030, &nv50_gr_ofuncs },
+	{ 0x502d, &nv50_gr_ofuncs },
+	{ 0x5039, &nv50_gr_ofuncs },
+	{ 0x50c0, &nv50_gr_ofuncs },
+	{ 0x8297, &nv50_gr_ofuncs },
+	{}
+};
+
+static struct nouveau_oclass
+nva0_gr_sclass[] = {
+	{ 0x0030, &nv50_gr_ofuncs },
+	{ 0x502d, &nv50_gr_ofuncs },
+	{ 0x5039, &nv50_gr_ofuncs },
+	{ 0x50c0, &nv50_gr_ofuncs },
+	{ 0x8397, &nv50_gr_ofuncs },
+	{}
+};
+
+static struct nouveau_oclass
+nva3_gr_sclass[] = {
+	{ 0x0030, &nv50_gr_ofuncs },
+	{ 0x502d, &nv50_gr_ofuncs },
+	{ 0x5039, &nv50_gr_ofuncs },
+	{ 0x50c0, &nv50_gr_ofuncs },
+	{ 0x8597, &nv50_gr_ofuncs },
+	{ 0x85c0, &nv50_gr_ofuncs },
+	{}
+};
+
+static struct nouveau_oclass
+nvaf_gr_sclass[] = {
+	{ 0x0030, &nv50_gr_ofuncs },
+	{ 0x502d, &nv50_gr_ofuncs },
+	{ 0x5039, &nv50_gr_ofuncs },
+	{ 0x50c0, &nv50_gr_ofuncs },
+	{ 0x85c0, &nv50_gr_ofuncs },
+	{ 0x8697, &nv50_gr_ofuncs },
+	{}
+};
+
+/*******************************************************************************
+ * PGRAPH context
+ ******************************************************************************/
+
+static int
+nv50_gr_context_ctor(struct nouveau_object *parent,
+			struct nouveau_object *engine,
+			struct nouveau_oclass *oclass, void *data, u32 size,
+			struct nouveau_object **pobject)
+{
+	struct nv50_gr_priv *priv = (void *)engine;
+	struct nv50_gr_chan *chan;
+	int ret;
+
+	ret = nouveau_gr_context_create(parent, engine, oclass, NULL,
+					   priv->size, 0,
+					   NVOBJ_FLAG_ZERO_ALLOC, &chan);
+	*pobject = nv_object(chan);
+	if (ret)
+		return ret;
+
+	nv50_grctx_fill(nv_device(priv), nv_gpuobj(chan));
+	return 0;
+}
+
+static struct nouveau_oclass
+nv50_gr_cclass = {
+	.handle = NV_ENGCTX(GR, 0x50),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv50_gr_context_ctor,
+		.dtor = _nouveau_gr_context_dtor,
+		.init = _nouveau_gr_context_init,
+		.fini = _nouveau_gr_context_fini,
+		.rd32 = _nouveau_gr_context_rd32,
+		.wr32 = _nouveau_gr_context_wr32,
+	},
+};
+
+/*******************************************************************************
+ * PGRAPH engine/subdev functions
+ ******************************************************************************/
+
+static const struct nouveau_bitfield nv50_pgr_status[] = {
+	{ 0x00000001, "BUSY" }, /* set when any bit is set */
+	{ 0x00000002, "DISPATCH" },
+	{ 0x00000004, "UNK2" },
+	{ 0x00000008, "UNK3" },
+	{ 0x00000010, "UNK4" },
+	{ 0x00000020, "UNK5" },
+	{ 0x00000040, "M2MF" },
+	{ 0x00000080, "UNK7" },
+	{ 0x00000100, "CTXPROG" },
+	{ 0x00000200, "VFETCH" },
+	{ 0x00000400, "CCACHE_PREGEOM" },
+	{ 0x00000800, "STRMOUT_VATTR_POSTGEOM" },
+	{ 0x00001000, "VCLIP" },
+	{ 0x00002000, "RATTR_APLANE" },
+	{ 0x00004000, "TRAST" },
+	{ 0x00008000, "CLIPID" },
+	{ 0x00010000, "ZCULL" },
+	{ 0x00020000, "ENG2D" },
+	{ 0x00040000, "RMASK" },
+	{ 0x00080000, "TPC_RAST" },
+	{ 0x00100000, "TPC_PROP" },
+	{ 0x00200000, "TPC_TEX" },
+	{ 0x00400000, "TPC_GEOM" },
+	{ 0x00800000, "TPC_MP" },
+	{ 0x01000000, "ROP" },
+	{}
+};
+
+static const char *const nv50_pgr_vstatus_0[] = {
+	"VFETCH", "CCACHE", "PREGEOM", "POSTGEOM", "VATTR", "STRMOUT", "VCLIP",
+	NULL
+};
+
+static const char *const nv50_pgr_vstatus_1[] = {
+	"TPC_RAST", "TPC_PROP", "TPC_TEX", "TPC_GEOM", "TPC_MP", NULL
+};
+
+static const char *const nv50_pgr_vstatus_2[] = {
+	"RATTR", "APLANE", "TRAST", "CLIPID", "ZCULL", "ENG2D", "RMASK",
+	"ROP", NULL
+};
+
+static void nouveau_pgr_vstatus_print(struct nv50_gr_priv *priv, int r,
+		const char *const units[], u32 status)
+{
+	int i;
+
+	nv_error(priv, "PGRAPH_VSTATUS%d: 0x%08x", r, status);
+
+	for (i = 0; units[i] && status; i++) {
+		if ((status & 7) == 1)
+			pr_cont(" %s", units[i]);
+		status >>= 3;
+	}
+	if (status)
+		pr_cont(" (invalid: 0x%x)", status);
+	pr_cont("\n");
+}
+
+static int
+nv84_gr_tlb_flush(struct nouveau_engine *engine)
+{
+	struct nouveau_timer *ptimer = nouveau_timer(engine);
+	struct nv50_gr_priv *priv = (void *)engine;
+	bool idle, timeout = false;
+	unsigned long flags;
+	u64 start;
+	u32 tmp;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	nv_mask(priv, 0x400500, 0x00000001, 0x00000000);
+
+	start = ptimer->read(ptimer);
+	do {
+		idle = true;
+
+		for (tmp = nv_rd32(priv, 0x400380); tmp && idle; tmp >>= 3) {
+			if ((tmp & 7) == 1)
+				idle = false;
+		}
+
+		for (tmp = nv_rd32(priv, 0x400384); tmp && idle; tmp >>= 3) {
+			if ((tmp & 7) == 1)
+				idle = false;
+		}
+
+		for (tmp = nv_rd32(priv, 0x400388); tmp && idle; tmp >>= 3) {
+			if ((tmp & 7) == 1)
+				idle = false;
+		}
+	} while (!idle &&
+		 !(timeout = ptimer->read(ptimer) - start > 2000000000));
+
+	if (timeout) {
+		nv_error(priv, "PGRAPH TLB flush idle timeout fail\n");
+
+		tmp = nv_rd32(priv, 0x400700);
+		nv_error(priv, "PGRAPH_STATUS  : 0x%08x", tmp);
+		nouveau_bitfield_print(nv50_pgr_status, tmp);
+		pr_cont("\n");
+
+		nouveau_pgr_vstatus_print(priv, 0, nv50_pgr_vstatus_0,
+				nv_rd32(priv, 0x400380));
+		nouveau_pgr_vstatus_print(priv, 1, nv50_pgr_vstatus_1,
+				nv_rd32(priv, 0x400384));
+		nouveau_pgr_vstatus_print(priv, 2, nv50_pgr_vstatus_2,
+				nv_rd32(priv, 0x400388));
+	}
+
+
+	nv_wr32(priv, 0x100c80, 0x00000001);
+	if (!nv_wait(priv, 0x100c80, 0x00000001, 0x00000000))
+		nv_error(priv, "vm flush timeout\n");
+	nv_mask(priv, 0x400500, 0x00000001, 0x00000001);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return timeout ? -EBUSY : 0;
+}
+
+static const struct nouveau_bitfield nv50_mp_exec_errors[] = {
+	{ 0x01, "STACK_UNDERFLOW" },
+	{ 0x02, "STACK_MISMATCH" },
+	{ 0x04, "QUADON_ACTIVE" },
+	{ 0x08, "TIMEOUT" },
+	{ 0x10, "INVALID_OPCODE" },
+	{ 0x20, "PM_OVERFLOW" },
+	{ 0x40, "BREAKPOINT" },
+	{}
+};
+
+static const struct nouveau_bitfield nv50_mpc_traps[] = {
+	{ 0x0000001, "LOCAL_LIMIT_READ" },
+	{ 0x0000010, "LOCAL_LIMIT_WRITE" },
+	{ 0x0000040, "STACK_LIMIT" },
+	{ 0x0000100, "GLOBAL_LIMIT_READ" },
+	{ 0x0001000, "GLOBAL_LIMIT_WRITE" },
+	{ 0x0010000, "MP0" },
+	{ 0x0020000, "MP1" },
+	{ 0x0040000, "GLOBAL_LIMIT_RED" },
+	{ 0x0400000, "GLOBAL_LIMIT_ATOM" },
+	{ 0x4000000, "MP2" },
+	{}
+};
+
+static const struct nouveau_bitfield nv50_tex_traps[] = {
+	{ 0x00000001, "" }, /* any bit set? */
+	{ 0x00000002, "FAULT" },
+	{ 0x00000004, "STORAGE_TYPE_MISMATCH" },
+	{ 0x00000008, "LINEAR_MISMATCH" },
+	{ 0x00000020, "WRONG_MEMTYPE" },
+	{}
+};
+
+static const struct nouveau_bitfield nv50_gr_trap_m2mf[] = {
+	{ 0x00000001, "NOTIFY" },
+	{ 0x00000002, "IN" },
+	{ 0x00000004, "OUT" },
+	{}
+};
+
+static const struct nouveau_bitfield nv50_gr_trap_vfetch[] = {
+	{ 0x00000001, "FAULT" },
+	{}
+};
+
+static const struct nouveau_bitfield nv50_gr_trap_strmout[] = {
+	{ 0x00000001, "FAULT" },
+	{}
+};
+
+static const struct nouveau_bitfield nv50_gr_trap_ccache[] = {
+	{ 0x00000001, "FAULT" },
+	{}
+};
+
+/* There must be a *lot* of these. Will take some time to gather them up. */
+const struct nouveau_enum nv50_data_error_names[] = {
+	{ 0x00000003, "INVALID_OPERATION", NULL },
+	{ 0x00000004, "INVALID_VALUE", NULL },
+	{ 0x00000005, "INVALID_ENUM", NULL },
+	{ 0x00000008, "INVALID_OBJECT", NULL },
+	{ 0x00000009, "READ_ONLY_OBJECT", NULL },
+	{ 0x0000000a, "SUPERVISOR_OBJECT", NULL },
+	{ 0x0000000b, "INVALID_ADDRESS_ALIGNMENT", NULL },
+	{ 0x0000000c, "INVALID_BITFIELD", NULL },
+	{ 0x0000000d, "BEGIN_END_ACTIVE", NULL },
+	{ 0x0000000e, "SEMANTIC_COLOR_BACK_OVER_LIMIT", NULL },
+	{ 0x0000000f, "VIEWPORT_ID_NEEDS_GP", NULL },
+	{ 0x00000010, "RT_DOUBLE_BIND", NULL },
+	{ 0x00000011, "RT_TYPES_MISMATCH", NULL },
+	{ 0x00000012, "RT_LINEAR_WITH_ZETA", NULL },
+	{ 0x00000015, "FP_TOO_FEW_REGS", NULL },
+	{ 0x00000016, "ZETA_FORMAT_CSAA_MISMATCH", NULL },
+	{ 0x00000017, "RT_LINEAR_WITH_MSAA", NULL },
+	{ 0x00000018, "FP_INTERPOLANT_START_OVER_LIMIT", NULL },
+	{ 0x00000019, "SEMANTIC_LAYER_OVER_LIMIT", NULL },
+	{ 0x0000001a, "RT_INVALID_ALIGNMENT", NULL },
+	{ 0x0000001b, "SAMPLER_OVER_LIMIT", NULL },
+	{ 0x0000001c, "TEXTURE_OVER_LIMIT", NULL },
+	{ 0x0000001e, "GP_TOO_MANY_OUTPUTS", NULL },
+	{ 0x0000001f, "RT_BPP128_WITH_MS8", NULL },
+	{ 0x00000021, "Z_OUT_OF_BOUNDS", NULL },
+	{ 0x00000023, "XY_OUT_OF_BOUNDS", NULL },
+	{ 0x00000024, "VP_ZERO_INPUTS", NULL },
+	{ 0x00000027, "CP_MORE_PARAMS_THAN_SHARED", NULL },
+	{ 0x00000028, "CP_NO_REG_SPACE_STRIPED", NULL },
+	{ 0x00000029, "CP_NO_REG_SPACE_PACKED", NULL },
+	{ 0x0000002a, "CP_NOT_ENOUGH_WARPS", NULL },
+	{ 0x0000002b, "CP_BLOCK_SIZE_MISMATCH", NULL },
+	{ 0x0000002c, "CP_NOT_ENOUGH_LOCAL_WARPS", NULL },
+	{ 0x0000002d, "CP_NOT_ENOUGH_STACK_WARPS", NULL },
+	{ 0x0000002e, "CP_NO_BLOCKDIM_LATCH", NULL },
+	{ 0x00000031, "ENG2D_FORMAT_MISMATCH", NULL },
+	{ 0x0000003f, "PRIMITIVE_ID_NEEDS_GP", NULL },
+	{ 0x00000044, "SEMANTIC_VIEWPORT_OVER_LIMIT", NULL },
+	{ 0x00000045, "SEMANTIC_COLOR_FRONT_OVER_LIMIT", NULL },
+	{ 0x00000046, "LAYER_ID_NEEDS_GP", NULL },
+	{ 0x00000047, "SEMANTIC_CLIP_OVER_LIMIT", NULL },
+	{ 0x00000048, "SEMANTIC_PTSZ_OVER_LIMIT", NULL },
+	{}
+};
+
+static const struct nouveau_bitfield nv50_gr_intr_name[] = {
+	{ 0x00000001, "NOTIFY" },
+	{ 0x00000002, "COMPUTE_QUERY" },
+	{ 0x00000010, "ILLEGAL_MTHD" },
+	{ 0x00000020, "ILLEGAL_CLASS" },
+	{ 0x00000040, "DOUBLE_NOTIFY" },
+	{ 0x00001000, "CONTEXT_SWITCH" },
+	{ 0x00010000, "BUFFER_NOTIFY" },
+	{ 0x00100000, "DATA_ERROR" },
+	{ 0x00200000, "TRAP" },
+	{ 0x01000000, "SINGLE_STEP" },
+	{}
+};
+
+static const struct nouveau_bitfield nv50_gr_trap_prop[] = {
+	{ 0x00000004, "SURF_WIDTH_OVERRUN" },
+	{ 0x00000008, "SURF_HEIGHT_OVERRUN" },
+	{ 0x00000010, "DST2D_FAULT" },
+	{ 0x00000020, "ZETA_FAULT" },
+	{ 0x00000040, "RT_FAULT" },
+	{ 0x00000080, "CUDA_FAULT" },
+	{ 0x00000100, "DST2D_STORAGE_TYPE_MISMATCH" },
+	{ 0x00000200, "ZETA_STORAGE_TYPE_MISMATCH" },
+	{ 0x00000400, "RT_STORAGE_TYPE_MISMATCH" },
+	{ 0x00000800, "DST2D_LINEAR_MISMATCH" },
+	{ 0x00001000, "RT_LINEAR_MISMATCH" },
+	{}
+};
+
+static void
+nv50_priv_prop_trap(struct nv50_gr_priv *priv,
+		    u32 ustatus_addr, u32 ustatus, u32 tp)
+{
+	u32 e0c = nv_rd32(priv, ustatus_addr + 0x04);
+	u32 e10 = nv_rd32(priv, ustatus_addr + 0x08);
+	u32 e14 = nv_rd32(priv, ustatus_addr + 0x0c);
+	u32 e18 = nv_rd32(priv, ustatus_addr + 0x10);
+	u32 e1c = nv_rd32(priv, ustatus_addr + 0x14);
+	u32 e20 = nv_rd32(priv, ustatus_addr + 0x18);
+	u32 e24 = nv_rd32(priv, ustatus_addr + 0x1c);
+
+	/* CUDA memory: l[], g[] or stack. */
+	if (ustatus & 0x00000080) {
+		if (e18 & 0x80000000) {
+			/* g[] read fault? */
+			nv_error(priv, "TRAP_PROP - TP %d - CUDA_FAULT - Global read fault at address %02x%08x\n",
+					 tp, e14, e10 | ((e18 >> 24) & 0x1f));
+			e18 &= ~0x1f000000;
+		} else if (e18 & 0xc) {
+			/* g[] write fault? */
+			nv_error(priv, "TRAP_PROP - TP %d - CUDA_FAULT - Global write fault at address %02x%08x\n",
+				 tp, e14, e10 | ((e18 >> 7) & 0x1f));
+			e18 &= ~0x00000f80;
+		} else {
+			nv_error(priv, "TRAP_PROP - TP %d - Unknown CUDA fault at address %02x%08x\n",
+				 tp, e14, e10);
+		}
+		ustatus &= ~0x00000080;
+	}
+	if (ustatus) {
+		nv_error(priv, "TRAP_PROP - TP %d -", tp);
+		nouveau_bitfield_print(nv50_gr_trap_prop, ustatus);
+		pr_cont(" - Address %02x%08x\n", e14, e10);
+	}
+	nv_error(priv, "TRAP_PROP - TP %d - e0c: %08x, e18: %08x, e1c: %08x, e20: %08x, e24: %08x\n",
+		 tp, e0c, e18, e1c, e20, e24);
+}
+
+static void
+nv50_priv_mp_trap(struct nv50_gr_priv *priv, int tpid, int display)
+{
+	u32 units = nv_rd32(priv, 0x1540);
+	u32 addr, mp10, status, pc, oplow, ophigh;
+	int i;
+	int mps = 0;
+	for (i = 0; i < 4; i++) {
+		if (!(units & 1 << (i+24)))
+			continue;
+		if (nv_device(priv)->chipset < 0xa0)
+			addr = 0x408200 + (tpid << 12) + (i << 7);
+		else
+			addr = 0x408100 + (tpid << 11) + (i << 7);
+		mp10 = nv_rd32(priv, addr + 0x10);
+		status = nv_rd32(priv, addr + 0x14);
+		if (!status)
+			continue;
+		if (display) {
+			nv_rd32(priv, addr + 0x20);
+			pc = nv_rd32(priv, addr + 0x24);
+			oplow = nv_rd32(priv, addr + 0x70);
+			ophigh = nv_rd32(priv, addr + 0x74);
+			nv_error(priv, "TRAP_MP_EXEC - "
+					"TP %d MP %d:", tpid, i);
+			nouveau_bitfield_print(nv50_mp_exec_errors, status);
+			pr_cont(" at %06x warp %d, opcode %08x %08x\n",
+					pc&0xffffff, pc >> 24,
+					oplow, ophigh);
+		}
+		nv_wr32(priv, addr + 0x10, mp10);
+		nv_wr32(priv, addr + 0x14, 0);
+		mps++;
+	}
+	if (!mps && display)
+		nv_error(priv, "TRAP_MP_EXEC - TP %d: "
+				"No MPs claiming errors?\n", tpid);
+}
+
+static void
+nv50_priv_tp_trap(struct nv50_gr_priv *priv, int type, u32 ustatus_old,
+		u32 ustatus_new, int display, const char *name)
+{
+	int tps = 0;
+	u32 units = nv_rd32(priv, 0x1540);
+	int i, r;
+	u32 ustatus_addr, ustatus;
+	for (i = 0; i < 16; i++) {
+		if (!(units & (1 << i)))
+			continue;
+		if (nv_device(priv)->chipset < 0xa0)
+			ustatus_addr = ustatus_old + (i << 12);
+		else
+			ustatus_addr = ustatus_new + (i << 11);
+		ustatus = nv_rd32(priv, ustatus_addr) & 0x7fffffff;
+		if (!ustatus)
+			continue;
+		tps++;
+		switch (type) {
+		case 6: /* texture error... unknown for now */
+			if (display) {
+				nv_error(priv, "magic set %d:\n", i);
+				for (r = ustatus_addr + 4; r <= ustatus_addr + 0x10; r += 4)
+					nv_error(priv, "\t0x%08x: 0x%08x\n", r,
+						nv_rd32(priv, r));
+				if (ustatus) {
+					nv_error(priv, "%s - TP%d:", name, i);
+					nouveau_bitfield_print(nv50_tex_traps,
+							       ustatus);
+					pr_cont("\n");
+					ustatus = 0;
+				}
+			}
+			break;
+		case 7: /* MP error */
+			if (ustatus & 0x04030000) {
+				nv50_priv_mp_trap(priv, i, display);
+				ustatus &= ~0x04030000;
+			}
+			if (ustatus && display) {
+				nv_error(priv, "%s - TP%d:", name, i);
+				nouveau_bitfield_print(nv50_mpc_traps, ustatus);
+				pr_cont("\n");
+				ustatus = 0;
+			}
+			break;
+		case 8: /* PROP error */
+			if (display)
+				nv50_priv_prop_trap(
+						priv, ustatus_addr, ustatus, i);
+			ustatus = 0;
+			break;
+		}
+		if (ustatus) {
+			if (display)
+				nv_error(priv, "%s - TP%d: Unhandled ustatus 0x%08x\n", name, i, ustatus);
+		}
+		nv_wr32(priv, ustatus_addr, 0xc0000000);
+	}
+
+	if (!tps && display)
+		nv_warn(priv, "%s - No TPs claiming errors?\n", name);
+}
+
+static int
+nv50_gr_trap_handler(struct nv50_gr_priv *priv, u32 display,
+			int chid, u64 inst, struct nouveau_object *engctx)
+{
+	u32 status = nv_rd32(priv, 0x400108);
+	u32 ustatus;
+
+	if (!status && display) {
+		nv_error(priv, "TRAP: no units reporting traps?\n");
+		return 1;
+	}
+
+	/* DISPATCH: Relays commands to other units and handles NOTIFY,
+	 * COND, QUERY. If you get a trap from it, the command is still stuck
+	 * in DISPATCH and you need to do something about it. */
+	if (status & 0x001) {
+		ustatus = nv_rd32(priv, 0x400804) & 0x7fffffff;
+		if (!ustatus && display) {
+			nv_error(priv, "TRAP_DISPATCH - no ustatus?\n");
+		}
+
+		nv_wr32(priv, 0x400500, 0x00000000);
+
+		/* Known to be triggered by screwed up NOTIFY and COND... */
+		if (ustatus & 0x00000001) {
+			u32 addr = nv_rd32(priv, 0x400808);
+			u32 subc = (addr & 0x00070000) >> 16;
+			u32 mthd = (addr & 0x00001ffc);
+			u32 datal = nv_rd32(priv, 0x40080c);
+			u32 datah = nv_rd32(priv, 0x400810);
+			u32 class = nv_rd32(priv, 0x400814);
+			u32 r848 = nv_rd32(priv, 0x400848);
+
+			nv_error(priv, "TRAP DISPATCH_FAULT\n");
+			if (display && (addr & 0x80000000)) {
+				nv_error(priv,
+					 "ch %d [0x%010llx %s] subc %d class 0x%04x mthd 0x%04x data 0x%08x%08x 400808 0x%08x 400848 0x%08x\n",
+					 chid, inst,
+					 nouveau_client_name(engctx), subc,
+					 class, mthd, datah, datal, addr, r848);
+			} else
+			if (display) {
+				nv_error(priv, "no stuck command?\n");
+			}
+
+			nv_wr32(priv, 0x400808, 0);
+			nv_wr32(priv, 0x4008e8, nv_rd32(priv, 0x4008e8) & 3);
+			nv_wr32(priv, 0x400848, 0);
+			ustatus &= ~0x00000001;
+		}
+
+		if (ustatus & 0x00000002) {
+			u32 addr = nv_rd32(priv, 0x40084c);
+			u32 subc = (addr & 0x00070000) >> 16;
+			u32 mthd = (addr & 0x00001ffc);
+			u32 data = nv_rd32(priv, 0x40085c);
+			u32 class = nv_rd32(priv, 0x400814);
+
+			nv_error(priv, "TRAP DISPATCH_QUERY\n");
+			if (display && (addr & 0x80000000)) {
+				nv_error(priv,
+					 "ch %d [0x%010llx %s] subc %d class 0x%04x mthd 0x%04x data 0x%08x 40084c 0x%08x\n",
+					 chid, inst,
+					 nouveau_client_name(engctx), subc,
+					 class, mthd, data, addr);
+			} else
+			if (display) {
+				nv_error(priv, "no stuck command?\n");
+			}
+
+			nv_wr32(priv, 0x40084c, 0);
+			ustatus &= ~0x00000002;
+		}
+
+		if (ustatus && display) {
+			nv_error(priv, "TRAP_DISPATCH (unknown "
+				      "0x%08x)\n", ustatus);
+		}
+
+		nv_wr32(priv, 0x400804, 0xc0000000);
+		nv_wr32(priv, 0x400108, 0x001);
+		status &= ~0x001;
+		if (!status)
+			return 0;
+	}
+
+	/* M2MF: Memory to memory copy engine. */
+	if (status & 0x002) {
+		u32 ustatus = nv_rd32(priv, 0x406800) & 0x7fffffff;
+		if (display) {
+			nv_error(priv, "TRAP_M2MF");
+			nouveau_bitfield_print(nv50_gr_trap_m2mf, ustatus);
+			pr_cont("\n");
+			nv_error(priv, "TRAP_M2MF %08x %08x %08x %08x\n",
+				nv_rd32(priv, 0x406804), nv_rd32(priv, 0x406808),
+				nv_rd32(priv, 0x40680c), nv_rd32(priv, 0x406810));
+
+		}
+
+		/* No sane way found yet -- just reset the bugger. */
+		nv_wr32(priv, 0x400040, 2);
+		nv_wr32(priv, 0x400040, 0);
+		nv_wr32(priv, 0x406800, 0xc0000000);
+		nv_wr32(priv, 0x400108, 0x002);
+		status &= ~0x002;
+	}
+
+	/* VFETCH: Fetches data from vertex buffers. */
+	if (status & 0x004) {
+		u32 ustatus = nv_rd32(priv, 0x400c04) & 0x7fffffff;
+		if (display) {
+			nv_error(priv, "TRAP_VFETCH");
+			nouveau_bitfield_print(nv50_gr_trap_vfetch, ustatus);
+			pr_cont("\n");
+			nv_error(priv, "TRAP_VFETCH %08x %08x %08x %08x\n",
+				nv_rd32(priv, 0x400c00), nv_rd32(priv, 0x400c08),
+				nv_rd32(priv, 0x400c0c), nv_rd32(priv, 0x400c10));
+		}
+
+		nv_wr32(priv, 0x400c04, 0xc0000000);
+		nv_wr32(priv, 0x400108, 0x004);
+		status &= ~0x004;
+	}
+
+	/* STRMOUT: DirectX streamout / OpenGL transform feedback. */
+	if (status & 0x008) {
+		ustatus = nv_rd32(priv, 0x401800) & 0x7fffffff;
+		if (display) {
+			nv_error(priv, "TRAP_STRMOUT");
+			nouveau_bitfield_print(nv50_gr_trap_strmout, ustatus);
+			pr_cont("\n");
+			nv_error(priv, "TRAP_STRMOUT %08x %08x %08x %08x\n",
+				nv_rd32(priv, 0x401804), nv_rd32(priv, 0x401808),
+				nv_rd32(priv, 0x40180c), nv_rd32(priv, 0x401810));
+
+		}
+
+		/* No sane way found yet -- just reset the bugger. */
+		nv_wr32(priv, 0x400040, 0x80);
+		nv_wr32(priv, 0x400040, 0);
+		nv_wr32(priv, 0x401800, 0xc0000000);
+		nv_wr32(priv, 0x400108, 0x008);
+		status &= ~0x008;
+	}
+
+	/* CCACHE: Handles code and c[] caches and fills them. */
+	if (status & 0x010) {
+		ustatus = nv_rd32(priv, 0x405018) & 0x7fffffff;
+		if (display) {
+			nv_error(priv, "TRAP_CCACHE");
+			nouveau_bitfield_print(nv50_gr_trap_ccache, ustatus);
+			pr_cont("\n");
+			nv_error(priv, "TRAP_CCACHE %08x %08x %08x %08x"
+				     " %08x %08x %08x\n",
+				nv_rd32(priv, 0x405000), nv_rd32(priv, 0x405004),
+				nv_rd32(priv, 0x405008), nv_rd32(priv, 0x40500c),
+				nv_rd32(priv, 0x405010), nv_rd32(priv, 0x405014),
+				nv_rd32(priv, 0x40501c));
+
+		}
+
+		nv_wr32(priv, 0x405018, 0xc0000000);
+		nv_wr32(priv, 0x400108, 0x010);
+		status &= ~0x010;
+	}
+
+	/* Unknown, not seen yet... 0x402000 is the only trap status reg
+	 * remaining, so try to handle it anyway. Perhaps related to that
+	 * unknown DMA slot on tesla? */
+	if (status & 0x20) {
+		ustatus = nv_rd32(priv, 0x402000) & 0x7fffffff;
+		if (display)
+			nv_error(priv, "TRAP_UNKC04 0x%08x\n", ustatus);
+		nv_wr32(priv, 0x402000, 0xc0000000);
+		/* no status modifiction on purpose */
+	}
+
+	/* TEXTURE: CUDA texturing units */
+	if (status & 0x040) {
+		nv50_priv_tp_trap(priv, 6, 0x408900, 0x408600, display,
+				    "TRAP_TEXTURE");
+		nv_wr32(priv, 0x400108, 0x040);
+		status &= ~0x040;
+	}
+
+	/* MP: CUDA execution engines. */
+	if (status & 0x080) {
+		nv50_priv_tp_trap(priv, 7, 0x408314, 0x40831c, display,
+				    "TRAP_MP");
+		nv_wr32(priv, 0x400108, 0x080);
+		status &= ~0x080;
+	}
+
+	/* PROP:  Handles TP-initiated uncached memory accesses:
+	 * l[], g[], stack, 2d surfaces, render targets. */
+	if (status & 0x100) {
+		nv50_priv_tp_trap(priv, 8, 0x408e08, 0x408708, display,
+				    "TRAP_PROP");
+		nv_wr32(priv, 0x400108, 0x100);
+		status &= ~0x100;
+	}
+
+	if (status) {
+		if (display)
+			nv_error(priv, "TRAP: unknown 0x%08x\n", status);
+		nv_wr32(priv, 0x400108, status);
+	}
+
+	return 1;
+}
+
+static void
+nv50_gr_intr(struct nouveau_subdev *subdev)
+{
+	struct nouveau_fifo *pfifo = nouveau_fifo(subdev);
+	struct nouveau_engine *engine = nv_engine(subdev);
+	struct nouveau_object *engctx;
+	struct nouveau_handle *handle = NULL;
+	struct nv50_gr_priv *priv = (void *)subdev;
+	u32 stat = nv_rd32(priv, 0x400100);
+	u32 inst = nv_rd32(priv, 0x40032c) & 0x0fffffff;
+	u32 addr = nv_rd32(priv, 0x400704);
+	u32 subc = (addr & 0x00070000) >> 16;
+	u32 mthd = (addr & 0x00001ffc);
+	u32 data = nv_rd32(priv, 0x400708);
+	u32 class = nv_rd32(priv, 0x400814);
+	u32 show = stat, show_bitfield = stat;
+	int chid;
+
+	engctx = nouveau_engctx_get(engine, inst);
+	chid   = pfifo->chid(pfifo, engctx);
+
+	if (stat & 0x00000010) {
+		handle = nouveau_handle_get_class(engctx, class);
+		if (handle && !nv_call(handle->object, mthd, data))
+			show &= ~0x00000010;
+		nouveau_handle_put(handle);
+	}
+
+	if (show & 0x00100000) {
+		u32 ecode = nv_rd32(priv, 0x400110);
+		nv_error(priv, "DATA_ERROR ");
+		nouveau_enum_print(nv50_data_error_names, ecode);
+		pr_cont("\n");
+		show_bitfield &= ~0x00100000;
+	}
+
+	if (stat & 0x00200000) {
+		if (!nv50_gr_trap_handler(priv, show, chid, (u64)inst << 12,
+				engctx))
+			show &= ~0x00200000;
+		show_bitfield &= ~0x00200000;
+	}
+
+	nv_wr32(priv, 0x400100, stat);
+	nv_wr32(priv, 0x400500, 0x00010001);
+
+	if (show) {
+		show &= show_bitfield;
+		if (show) {
+			nv_error(priv, "%s", "");
+			nouveau_bitfield_print(nv50_gr_intr_name, show);
+			pr_cont("\n");
+		}
+		nv_error(priv,
+			 "ch %d [0x%010llx %s] subc %d class 0x%04x mthd 0x%04x data 0x%08x\n",
+			 chid, (u64)inst << 12, nouveau_client_name(engctx),
+			 subc, class, mthd, data);
+	}
+
+	if (nv_rd32(priv, 0x400824) & (1 << 31))
+		nv_wr32(priv, 0x400824, nv_rd32(priv, 0x400824) & ~(1 << 31));
+
+	nouveau_engctx_put(engctx);
+}
+
+static int
+nv50_gr_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+	       struct nouveau_oclass *oclass, void *data, u32 size,
+	       struct nouveau_object **pobject)
+{
+	struct nv50_gr_priv *priv;
+	int ret;
+
+	ret = nouveau_gr_create(parent, engine, oclass, true, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	nv_subdev(priv)->unit = 0x00201000;
+	nv_subdev(priv)->intr = nv50_gr_intr;
+	nv_engine(priv)->cclass = &nv50_gr_cclass;
+
+	priv->base.units = nv50_gr_units;
+
+	switch (nv_device(priv)->chipset) {
+	case 0x50:
+		nv_engine(priv)->sclass = nv50_gr_sclass;
+		break;
+	case 0x84:
+	case 0x86:
+	case 0x92:
+	case 0x94:
+	case 0x96:
+	case 0x98:
+		nv_engine(priv)->sclass = nv84_gr_sclass;
+		break;
+	case 0xa0:
+	case 0xaa:
+	case 0xac:
+		nv_engine(priv)->sclass = nva0_gr_sclass;
+		break;
+	case 0xa3:
+	case 0xa5:
+	case 0xa8:
+		nv_engine(priv)->sclass = nva3_gr_sclass;
+		break;
+	case 0xaf:
+		nv_engine(priv)->sclass = nvaf_gr_sclass;
+		break;
+
+	}
+
+	/* unfortunate hw bug workaround... */
+	if (nv_device(priv)->chipset != 0x50 &&
+	    nv_device(priv)->chipset != 0xac)
+		nv_engine(priv)->tlb_flush = nv84_gr_tlb_flush;
+
+	spin_lock_init(&priv->lock);
+	return 0;
+}
+
+static int
+nv50_gr_init(struct nouveau_object *object)
+{
+	struct nv50_gr_priv *priv = (void *)object;
+	int ret, units, i;
+
+	ret = nouveau_gr_init(&priv->base);
+	if (ret)
+		return ret;
+
+	/* NV_PGRAPH_DEBUG_3_HW_CTX_SWITCH_ENABLED */
+	nv_wr32(priv, 0x40008c, 0x00000004);
+
+	/* reset/enable traps and interrupts */
+	nv_wr32(priv, 0x400804, 0xc0000000);
+	nv_wr32(priv, 0x406800, 0xc0000000);
+	nv_wr32(priv, 0x400c04, 0xc0000000);
+	nv_wr32(priv, 0x401800, 0xc0000000);
+	nv_wr32(priv, 0x405018, 0xc0000000);
+	nv_wr32(priv, 0x402000, 0xc0000000);
+
+	units = nv_rd32(priv, 0x001540);
+	for (i = 0; i < 16; i++) {
+		if (!(units & (1 << i)))
+			continue;
+
+		if (nv_device(priv)->chipset < 0xa0) {
+			nv_wr32(priv, 0x408900 + (i << 12), 0xc0000000);
+			nv_wr32(priv, 0x408e08 + (i << 12), 0xc0000000);
+			nv_wr32(priv, 0x408314 + (i << 12), 0xc0000000);
+		} else {
+			nv_wr32(priv, 0x408600 + (i << 11), 0xc0000000);
+			nv_wr32(priv, 0x408708 + (i << 11), 0xc0000000);
+			nv_wr32(priv, 0x40831c + (i << 11), 0xc0000000);
+		}
+	}
+
+	nv_wr32(priv, 0x400108, 0xffffffff);
+	nv_wr32(priv, 0x400138, 0xffffffff);
+	nv_wr32(priv, 0x400100, 0xffffffff);
+	nv_wr32(priv, 0x40013c, 0xffffffff);
+	nv_wr32(priv, 0x400500, 0x00010001);
+
+	/* upload context program, initialise ctxctl defaults */
+	ret = nv50_grctx_init(nv_device(priv), &priv->size);
+	if (ret)
+		return ret;
+
+	nv_wr32(priv, 0x400824, 0x00000000);
+	nv_wr32(priv, 0x400828, 0x00000000);
+	nv_wr32(priv, 0x40082c, 0x00000000);
+	nv_wr32(priv, 0x400830, 0x00000000);
+	nv_wr32(priv, 0x40032c, 0x00000000);
+	nv_wr32(priv, 0x400330, 0x00000000);
+
+	/* some unknown zcull magic */
+	switch (nv_device(priv)->chipset & 0xf0) {
+	case 0x50:
+	case 0x80:
+	case 0x90:
+		nv_wr32(priv, 0x402ca8, 0x00000800);
+		break;
+	case 0xa0:
+	default:
+		if (nv_device(priv)->chipset == 0xa0 ||
+		    nv_device(priv)->chipset == 0xaa ||
+		    nv_device(priv)->chipset == 0xac) {
+			nv_wr32(priv, 0x402ca8, 0x00000802);
+		} else {
+			nv_wr32(priv, 0x402cc0, 0x00000000);
+			nv_wr32(priv, 0x402ca8, 0x00000002);
+		}
+
+		break;
+	}
+
+	/* zero out zcull regions */
+	for (i = 0; i < 8; i++) {
+		nv_wr32(priv, 0x402c20 + (i * 0x10), 0x00000000);
+		nv_wr32(priv, 0x402c24 + (i * 0x10), 0x00000000);
+		nv_wr32(priv, 0x402c28 + (i * 0x10), 0x00000000);
+		nv_wr32(priv, 0x402c2c + (i * 0x10), 0x00000000);
+	}
+	return 0;
+}
+
+struct nouveau_oclass
+nv50_gr_oclass = {
+	.handle = NV_ENGINE(GR, 0x50),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv50_gr_ctor,
+		.dtor = _nouveau_gr_dtor,
+		.init = nv50_gr_init,
+		.fini = _nouveau_gr_fini,
+	},
+};
