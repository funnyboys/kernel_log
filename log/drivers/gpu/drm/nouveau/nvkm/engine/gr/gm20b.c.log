commit 9d350c5e5156792ba7c87b3b1e897656dc2a88e5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 15 06:34:22 2020 +1000

    drm/nouveau/secboot: remove
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index b45e8f10ec73..09d8c5d5b000 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -84,7 +84,7 @@ gm20b_gr_init_gpc_mmu(struct gf100_gr *gr)
 	u32 val;
 
 	/* Bypass MMU check for non-secure boot */
-	if (!device->secboot) {
+	if (!device->acr) {
 		nvkm_wr32(device, 0x100ce4, 0xffffffff);
 
 		if (nvkm_rd32(device, 0x100ce4) != 0xffffffff)

commit 22dcda45a3d1dfe6eeb4ab0a3b9aaa2333cb649d
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 15 06:34:22 2020 +1000

    drm/nouveau/acr: implement new subdev to replace "secure boot"
    
    ACR is responsible for managing the firmware for LS (Low Secure) falcons,
    this was previously handled in the driver by SECBOOT.
    
    This rewrite started from some test code that attempted to replicate the
    procedure RM uses in order to debug early Turing ACR firmwares that were
    provided by NVIDIA for development.
    
    Compared with SECBOOT, the code is structured into more individual steps,
    with the aim of making the process easier to follow/debug, whilst making
    it possible to support newer firmware versions that may have a different
    binary format or API interface.
    
    The HS (High Secure) binary(s) are now booted earlier in device init, to
    match the behaviour of RM, whereas SECBOOT would delay this until we try
    to boot the first LS falcon.
    
    There's also additional debugging features available, with the intention
    of making it easier to solve issues during FW/HW bring-up in the future.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index aaf5aff036f2..b45e8f10ec73 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -26,10 +26,55 @@
 #include <subdev/acr.h>
 #include <subdev/timer.h>
 
+#include <nvfw/flcn.h>
+
 #include <nvif/class.h>
 
+void
+gm20b_gr_acr_bld_patch(struct nvkm_acr *acr, u32 bld, s64 adjust)
+{
+	struct flcn_bl_dmem_desc hdr;
+	u64 addr;
+
+	nvkm_robj(acr->wpr, bld, &hdr, sizeof(hdr));
+	addr = ((u64)hdr.code_dma_base1 << 40 | hdr.code_dma_base << 8);
+	hdr.code_dma_base  = lower_32_bits((addr + adjust) >> 8);
+	hdr.code_dma_base1 = upper_32_bits((addr + adjust) >> 8);
+	addr = ((u64)hdr.data_dma_base1 << 40 | hdr.data_dma_base << 8);
+	hdr.data_dma_base  = lower_32_bits((addr + adjust) >> 8);
+	hdr.data_dma_base1 = upper_32_bits((addr + adjust) >> 8);
+	nvkm_wobj(acr->wpr, bld, &hdr, sizeof(hdr));
+
+	flcn_bl_dmem_desc_dump(&acr->subdev, &hdr);
+}
+
+void
+gm20b_gr_acr_bld_write(struct nvkm_acr *acr, u32 bld,
+		       struct nvkm_acr_lsfw *lsfw)
+{
+	const u64 base = lsfw->offset.img + lsfw->app_start_offset;
+	const u64 code = (base + lsfw->app_resident_code_offset) >> 8;
+	const u64 data = (base + lsfw->app_resident_data_offset) >> 8;
+	const struct flcn_bl_dmem_desc hdr = {
+		.ctx_dma = FALCON_DMAIDX_UCODE,
+		.code_dma_base = lower_32_bits(code),
+		.non_sec_code_off = lsfw->app_resident_code_offset,
+		.non_sec_code_size = lsfw->app_resident_code_size,
+		.code_entry_point = lsfw->app_imem_entry,
+		.data_dma_base = lower_32_bits(data),
+		.data_size = lsfw->app_resident_data_size,
+		.code_dma_base1 = upper_32_bits(code),
+		.data_dma_base1 = upper_32_bits(data),
+	};
+
+	nvkm_wobj(acr->wpr, bld, &hdr, sizeof(hdr));
+}
+
 const struct nvkm_acr_lsf_func
 gm20b_gr_fecs_acr = {
+	.bld_size = sizeof(struct flcn_bl_dmem_desc),
+	.bld_write = gm20b_gr_acr_bld_write,
+	.bld_patch = gm20b_gr_acr_bld_patch,
 };
 
 static void

commit 4f556362a3f6efbfa22ada34178c91a795f9548a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 15 06:34:21 2020 +1000

    drm/nouveau/gr/gf100-: initialise SW state for falcon from constructor
    
    This will allow us to register the falcon with ACR, and further customise
    its behaviour by providing the nvkm_falcon_func structure directly.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index d5a6210921c7..aaf5aff036f2 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -97,7 +97,7 @@ gm20b_gr_load(struct gf100_gr *gr, int ver, const struct gf100_gr_fwif *fwif)
 	struct nvkm_subdev *subdev = &gr->base.engine.subdev;
 	int ret;
 
-	ret = nvkm_acr_lsfw_load_bl_inst_data_sig(subdev, gr->fecs.falcon,
+	ret = nvkm_acr_lsfw_load_bl_inst_data_sig(subdev, &gr->fecs.falcon,
 						  NVKM_ACR_LSF_FECS,
 						  "gr/fecs_", ver, fwif->fecs);
 	if (ret)

commit ef16dc278ec22ddbf8da54bd06a6e662719c1420
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 15 06:34:21 2020 +1000

    drm/nouveau/gr/gf100-: select implementation based on available FW
    
    This will allow for further customisation of the subdev depending on what
    firmware is available.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index a667770ce3cb..d5a6210921c7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -22,10 +22,16 @@
 #include "gf100.h"
 #include "ctxgf100.h"
 
+#include <core/firmware.h>
+#include <subdev/acr.h>
 #include <subdev/timer.h>
 
 #include <nvif/class.h>
 
+const struct nvkm_acr_lsf_func
+gm20b_gr_fecs_acr = {
+};
+
 static void
 gm20b_gr_init_gpc_mmu(struct gf100_gr *gr)
 {
@@ -85,8 +91,51 @@ gm20b_gr = {
 	}
 };
 
+static int
+gm20b_gr_load(struct gf100_gr *gr, int ver, const struct gf100_gr_fwif *fwif)
+{
+	struct nvkm_subdev *subdev = &gr->base.engine.subdev;
+	int ret;
+
+	ret = nvkm_acr_lsfw_load_bl_inst_data_sig(subdev, gr->fecs.falcon,
+						  NVKM_ACR_LSF_FECS,
+						  "gr/fecs_", ver, fwif->fecs);
+	if (ret)
+		return ret;
+
+
+	if (nvkm_firmware_load_blob(subdev, "gr/", "gpccs_inst", ver,
+				    &gr->gpccs.inst) ||
+	    nvkm_firmware_load_blob(subdev, "gr/", "gpccs_data", ver,
+				    &gr->gpccs.data))
+		return -ENOENT;
+
+	gr->firmware = true;
+
+	return gk20a_gr_load_sw(gr, "gr/", ver);
+}
+
+#if IS_ENABLED(CONFIG_ARCH_TEGRA_210_SOC)
+MODULE_FIRMWARE("nvidia/gm20b/gr/fecs_bl.bin");
+MODULE_FIRMWARE("nvidia/gm20b/gr/fecs_inst.bin");
+MODULE_FIRMWARE("nvidia/gm20b/gr/fecs_data.bin");
+MODULE_FIRMWARE("nvidia/gm20b/gr/fecs_sig.bin");
+MODULE_FIRMWARE("nvidia/gm20b/gr/gpccs_inst.bin");
+MODULE_FIRMWARE("nvidia/gm20b/gr/gpccs_data.bin");
+MODULE_FIRMWARE("nvidia/gm20b/gr/sw_ctx.bin");
+MODULE_FIRMWARE("nvidia/gm20b/gr/sw_nonctx.bin");
+MODULE_FIRMWARE("nvidia/gm20b/gr/sw_bundle_init.bin");
+MODULE_FIRMWARE("nvidia/gm20b/gr/sw_method_init.bin");
+#endif
+
+static const struct gf100_gr_fwif
+gm20b_gr_fwif[] = {
+	{ 0, gm20b_gr_load, &gm20b_gr, &gm20b_gr_fecs_acr },
+	{}
+};
+
 int
 gm20b_gr_new(struct nvkm_device *device, int index, struct nvkm_gr **pgr)
 {
-	return gm200_gr_new_(&gm20b_gr, device, index, pgr);
+	return gf100_gr_new_(gm20b_gr_fwif, device, index, pgr);
 }

commit e9d03335f604a1123b8de3103ce8e06db4ad777a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:47 2018 +1000

    drm/nouveau/gr/gp100-: use correct registers for zbc colour/depth setup
    
    These were missed the first time around due to the driver version I traced
    using the older registers still.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index afa1c6e32230..a667770ce3cb 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -75,6 +75,7 @@ gm20b_gr = {
 	.rops = gm200_gr_rops,
 	.ppc_nr = 1,
 	.grctx = &gm20b_grctx,
+	.zbc = &gf100_gr_zbc,
 	.sclass = {
 		{ -1, -1, FERMI_TWOD_A },
 		{ -1, -1, KEPLER_INLINE_TO_MEMORY_B },

commit 068cae743c2ad08a082d6fef007e6b38f5fb3b16
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:47 2018 +1000

    drm/nouveau/gr/gf100-: calculate and use sm mapping table
    
    There's a number of places that require this data, so let's separate out
    the calculations to ensure they remain consistent.
    
    This is incorrect for GM200 and newer, but will produce the same results
    as we did before.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index 29d3b9445cf6..afa1c6e32230 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -65,6 +65,7 @@ gm20b_gr_set_hww_esr_report_mask(struct gf100_gr *gr)
 static const struct gf100_gr_func
 gm20b_gr = {
 	.oneinit_tiles = gm200_gr_oneinit_tiles,
+	.oneinit_sm_id = gm200_gr_oneinit_sm_id,
 	.init = gk20a_gr_init,
 	.init_zcull = gf117_gr_init_zcull,
 	.init_gpc_mmu = gm20b_gr_init_gpc_mmu,

commit 5f6474a4e6ce3291abb1843b279a23a0bb050d37
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:47 2018 +1000

    drm/nouveau/gr/gf100-: port tile mapping calculations from NVGPU
    
    There's also a couple of hardcoded tables for a couple of very specific
    configurations that NVGPU's algorithm didn't work for.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index d2f9c7bf9f03..29d3b9445cf6 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -64,6 +64,7 @@ gm20b_gr_set_hww_esr_report_mask(struct gf100_gr *gr)
 
 static const struct gf100_gr_func
 gm20b_gr = {
+	.oneinit_tiles = gm200_gr_oneinit_tiles,
 	.init = gk20a_gr_init,
 	.init_zcull = gf117_gr_init_zcull,
 	.init_gpc_mmu = gm20b_gr_init_gpc_mmu,

commit 5c05a589856ad5f79c22b0500340291c591c3050
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:47 2018 +1000

    drm/nouveau/gr/gf100-: virtualise trap_mp
    
    Required to support Volta.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index fcf86d5cf26f..d2f9c7bf9f03 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -68,6 +68,7 @@ gm20b_gr = {
 	.init_zcull = gf117_gr_init_zcull,
 	.init_gpc_mmu = gm20b_gr_init_gpc_mmu,
 	.init_rop_active_fbps = gk104_gr_init_rop_active_fbps,
+	.trap_mp = gf100_gr_trap_mp,
 	.set_hww_esr_report_mask = gm20b_gr_set_hww_esr_report_mask,
 	.rops = gm200_gr_rops,
 	.ppc_nr = 1,

commit 02917aa39d56f504b47354135120000da1efa760
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/gr/gf100-: virtualise init_zcull
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index 69479af1d829..fcf86d5cf26f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -65,6 +65,7 @@ gm20b_gr_set_hww_esr_report_mask(struct gf100_gr *gr)
 static const struct gf100_gr_func
 gm20b_gr = {
 	.init = gk20a_gr_init,
+	.init_zcull = gf117_gr_init_zcull,
 	.init_gpc_mmu = gm20b_gr_init_gpc_mmu,
 	.init_rop_active_fbps = gk104_gr_init_rop_active_fbps,
 	.set_hww_esr_report_mask = gm20b_gr_set_hww_esr_report_mask,

commit 87ac331e3f9aca9bdc3697bb936b3b2b43cbf5a0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Apr 19 11:10:38 2016 +1000

    drm/nouveau/gr/gk104-: move rop_active_fbps init to nonctx
    
    Matches newer RM.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index 712f036d09f3..69479af1d829 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -66,6 +66,7 @@ static const struct gf100_gr_func
 gm20b_gr = {
 	.init = gk20a_gr_init,
 	.init_gpc_mmu = gm20b_gr_init_gpc_mmu,
+	.init_rop_active_fbps = gk104_gr_init_rop_active_fbps,
 	.set_hww_esr_report_mask = gm20b_gr_set_hww_esr_report_mask,
 	.rops = gm200_gr_rops,
 	.ppc_nr = 1,

commit 734a0aa669fd032f40e27e3d3df7228e1fe27681
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Apr 14 14:28:03 2016 +1000

    drm/nouveau/gr/gm200-: rop count == ltc count
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index f1ea0ba5832f..712f036d09f3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -67,7 +67,7 @@ gm20b_gr = {
 	.init = gk20a_gr_init,
 	.init_gpc_mmu = gm20b_gr_init_gpc_mmu,
 	.set_hww_esr_report_mask = gm20b_gr_set_hww_esr_report_mask,
-	.rops = gf100_gr_rops,
+	.rops = gm200_gr_rops,
 	.ppc_nr = 1,
 	.grctx = &gm20b_grctx,
 	.sclass = {

commit c83e7d6836e1e7bf6ed30905444fa47d4ef0a82e
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Apr 14 14:41:52 2016 +1000

    drm/nouveau/gr/gm200: modify the mask when copying mmu settings from fb
    
    Appears to more closely match what RM does.
    
    For GM20B, now also copying bit 12 from NV_PFB_MMU_CTRL as upcoming
    changes will require it.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index 1281a9cffa76..f1ea0ba5832f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -42,7 +42,7 @@ gm20b_gr_init_gpc_mmu(struct gf100_gr *gr)
 	}
 
 	val = nvkm_rd32(device, 0x100c80);
-	val &= 0xf000087f;
+	val &= 0xf000187f;
 	nvkm_wr32(device, 0x418880, val);
 	nvkm_wr32(device, 0x418890, 0);
 	nvkm_wr32(device, 0x418894, 0);

commit 64cb5a31f477fe1540bfdbb7f72e7324d21208f4
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Apr 14 14:26:18 2016 +1000

    drm/nouveau/gr/gf100-: abstract fetching rop count
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index 29732bc14415..1281a9cffa76 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -67,6 +67,7 @@ gm20b_gr = {
 	.init = gk20a_gr_init,
 	.init_gpc_mmu = gm20b_gr_init_gpc_mmu,
 	.set_hww_esr_report_mask = gm20b_gr_set_hww_esr_report_mask,
+	.rops = gf100_gr_rops,
 	.ppc_nr = 1,
 	.grctx = &gm20b_grctx,
 	.sclass = {

commit 923f1bd27bf1ed49b3d1a4cccf2c8238618b49cf
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Wed Feb 24 14:42:24 2016 +0900

    drm/nouveau/secboot/gm20b: add secure boot support
    
    Add secure boot support for the GM20B chip found in Tegra X1. Secure
    boot on Tegra works slightly differently from desktop, notably in the
    way the WPR region is set up.
    
    In addition, the firmware bootloaders use a slightly different header
    format.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index a440772f8de4..29732bc14415 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -32,12 +32,15 @@ gm20b_gr_init_gpc_mmu(struct gf100_gr *gr)
 	struct nvkm_device *device = gr->base.engine.subdev.device;
 	u32 val;
 
-	/* TODO this needs to be removed once secure boot works */
-	if (1) {
+	/* Bypass MMU check for non-secure boot */
+	if (!device->secboot) {
 		nvkm_wr32(device, 0x100ce4, 0xffffffff);
+
+		if (nvkm_rd32(device, 0x100ce4) != 0xffffffff)
+			nvdev_warn(device,
+			  "cannot bypass secure boot - expect failure soon!\n");
 	}
 
-	/* TODO update once secure boot works */
 	val = nvkm_rd32(device, 0x100c80);
 	val &= 0xf000087f;
 	nvkm_wr32(device, 0x418880, val);

commit f008d8c7b2218c0be0e7853341eac63db3ca4a42
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Wed Feb 24 14:42:19 2016 +0900

    drm/nouveau/gr/gm200: load external firmware and bundles
    
    Load firmware and bundles in GM200's constructor. The previously called
    GF100 function did not care about the bundles.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index 443922e46ff9..a440772f8de4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -78,5 +78,5 @@ gm20b_gr = {
 int
 gm20b_gr_new(struct nvkm_device *device, int index, struct nvkm_gr **pgr)
 {
-	return gk20a_gr_new_(&gm20b_gr, device, index, pgr);
+	return gm200_gr_new_(&gm20b_gr, device, index, pgr);
 }

commit 336c46524fcd822aaef3ede92b56bb4367b4538f
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Wed Feb 24 14:42:15 2016 +0900

    drm/nouveau/gr/gk20a: move firmware bundle release to gf100
    
    Some members of gf100_gr were freed by the gk20a driver. That's not
    where it should be done - free them in gf100 so other chips that use
    NVIDIA-provided firmware free these structures properly.
    
    This also removes the need for a GK20A-specific destructor.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index 65b6e3d1e90d..443922e46ff9 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -61,7 +61,6 @@ gm20b_gr_set_hww_esr_report_mask(struct gf100_gr *gr)
 
 static const struct gf100_gr_func
 gm20b_gr = {
-	.dtor = gk20a_gr_dtor,
 	.init = gk20a_gr_init,
 	.init_gpc_mmu = gm20b_gr_init_gpc_mmu,
 	.set_hww_esr_report_mask = gm20b_gr_set_hww_esr_report_mask,

commit c85ee6ca79590cd51356bf24fb8936bc352138cf
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/gr: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index 7a663654543b..65b6e3d1e90d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -19,7 +19,7 @@
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  */
-#include "gk20a.h"
+#include "gf100.h"
 #include "ctxgf100.h"
 
 #include <subdev/timer.h>
@@ -61,6 +61,11 @@ gm20b_gr_set_hww_esr_report_mask(struct gf100_gr *gr)
 
 static const struct gf100_gr_func
 gm20b_gr = {
+	.dtor = gk20a_gr_dtor,
+	.init = gk20a_gr_init,
+	.init_gpc_mmu = gm20b_gr_init_gpc_mmu,
+	.set_hww_esr_report_mask = gm20b_gr_set_hww_esr_report_mask,
+	.ppc_nr = 1,
 	.grctx = &gm20b_grctx,
 	.sclass = {
 		{ -1, -1, FERMI_TWOD_A },
@@ -71,19 +76,8 @@ gm20b_gr = {
 	}
 };
 
-struct nvkm_oclass *
-gm20b_gr_oclass = &(struct gk20a_gr_oclass) {
-	.gf100 = {
-		.base.handle = NV_ENGINE(GR, 0x2b),
-		.base.ofuncs = &(struct nvkm_ofuncs) {
-			.ctor = gk20a_gr_ctor,
-			.dtor = gf100_gr_dtor,
-			.init = gk20a_gr_init,
-			.fini = _nvkm_gr_fini,
-		},
-		.func = &gm20b_gr,
-		.ppc_nr = 1,
-	},
-	.init_gpc_mmu = gm20b_gr_init_gpc_mmu,
-	.set_hww_esr_report_mask = gm20b_gr_set_hww_esr_report_mask,
-}.gf100.base;
+int
+gm20b_gr_new(struct nvkm_device *device, int index, struct nvkm_gr **pgr)
+{
+	return gk20a_gr_new_(&gm20b_gr, device, index, pgr);
+}

commit 27f3d6cf80324940edd29be7758f81145e73d1ff
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/gr: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index 87388926efa6..7a663654543b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -22,17 +22,9 @@
 #include "gk20a.h"
 #include "ctxgf100.h"
 
-#include <nvif/class.h>
 #include <subdev/timer.h>
 
-static struct nvkm_oclass
-gm20b_gr_sclass[] = {
-	{ FERMI_TWOD_A, &nvkm_object_ofuncs },
-	{ KEPLER_INLINE_TO_MEMORY_B, &nvkm_object_ofuncs },
-	{ MAXWELL_B, &gf100_fermi_ofuncs },
-	{ MAXWELL_COMPUTE_B, &nvkm_object_ofuncs },
-	{}
-};
+#include <nvif/class.h>
 
 static void
 gm20b_gr_init_gpc_mmu(struct gf100_gr *gr)
@@ -67,6 +59,18 @@ gm20b_gr_set_hww_esr_report_mask(struct gf100_gr *gr)
 	nvkm_wr32(device, 0x419e4c, 0x5);
 }
 
+static const struct gf100_gr_func
+gm20b_gr = {
+	.grctx = &gm20b_grctx,
+	.sclass = {
+		{ -1, -1, FERMI_TWOD_A },
+		{ -1, -1, KEPLER_INLINE_TO_MEMORY_B },
+		{ -1, -1, MAXWELL_B, &gf100_fermi },
+		{ -1, -1, MAXWELL_COMPUTE_B },
+		{}
+	}
+};
+
 struct nvkm_oclass *
 gm20b_gr_oclass = &(struct gk20a_gr_oclass) {
 	.gf100 = {
@@ -77,8 +81,7 @@ gm20b_gr_oclass = &(struct gk20a_gr_oclass) {
 			.init = gk20a_gr_init,
 			.fini = _nvkm_gr_fini,
 		},
-		.cclass = &gm20b_grctx_oclass,
-		.sclass = gm20b_gr_sclass,
+		.func = &gm20b_gr,
 		.ppc_nr = 1,
 	},
 	.init_gpc_mmu = gm20b_gr_init_gpc_mmu,

commit a65955e19e769e92a0e29cccdc29aea0b19f3809
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/gr: remove dependence on namedb/engctx lookup
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index 719ebfb6e640..87388926efa6 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -29,8 +29,8 @@ static struct nvkm_oclass
 gm20b_gr_sclass[] = {
 	{ FERMI_TWOD_A, &nvkm_object_ofuncs },
 	{ KEPLER_INLINE_TO_MEMORY_B, &nvkm_object_ofuncs },
-	{ MAXWELL_B, &gf100_fermi_ofuncs, gf100_gr_9097_omthds },
-	{ MAXWELL_COMPUTE_B, &nvkm_object_ofuncs, gf100_gr_90c0_omthds },
+	{ MAXWELL_B, &gf100_fermi_ofuncs },
+	{ MAXWELL_COMPUTE_B, &nvkm_object_ofuncs },
 	{}
 };
 

commit 276836d46e535c8ca299a1ea8302879dbdd3e93a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:10 2015 +1000

    drm/nouveau/gr: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index 6b9c84f8f12d..719ebfb6e640 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -37,32 +37,34 @@ gm20b_gr_sclass[] = {
 static void
 gm20b_gr_init_gpc_mmu(struct gf100_gr *gr)
 {
+	struct nvkm_device *device = gr->base.engine.subdev.device;
 	u32 val;
 
 	/* TODO this needs to be removed once secure boot works */
 	if (1) {
-		nv_wr32(gr, 0x100ce4, 0xffffffff);
+		nvkm_wr32(device, 0x100ce4, 0xffffffff);
 	}
 
 	/* TODO update once secure boot works */
-	val = nv_rd32(gr, 0x100c80);
+	val = nvkm_rd32(device, 0x100c80);
 	val &= 0xf000087f;
-	nv_wr32(gr, 0x418880, val);
-	nv_wr32(gr, 0x418890, 0);
-	nv_wr32(gr, 0x418894, 0);
+	nvkm_wr32(device, 0x418880, val);
+	nvkm_wr32(device, 0x418890, 0);
+	nvkm_wr32(device, 0x418894, 0);
 
-	nv_wr32(gr, 0x4188b0, nv_rd32(gr, 0x100cc4));
-	nv_wr32(gr, 0x4188b4, nv_rd32(gr, 0x100cc8));
-	nv_wr32(gr, 0x4188b8, nv_rd32(gr, 0x100ccc));
+	nvkm_wr32(device, 0x4188b0, nvkm_rd32(device, 0x100cc4));
+	nvkm_wr32(device, 0x4188b4, nvkm_rd32(device, 0x100cc8));
+	nvkm_wr32(device, 0x4188b8, nvkm_rd32(device, 0x100ccc));
 
-	nv_wr32(gr, 0x4188ac, nv_rd32(gr, 0x100800));
+	nvkm_wr32(device, 0x4188ac, nvkm_rd32(device, 0x100800));
 }
 
 static void
 gm20b_gr_set_hww_esr_report_mask(struct gf100_gr *gr)
 {
-	nv_wr32(gr, 0x419e44, 0xdffffe);
-	nv_wr32(gr, 0x419e4c, 0x5);
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	nvkm_wr32(device, 0x419e44, 0xdffffe);
+	nvkm_wr32(device, 0x419e4c, 0x5);
 }
 
 struct nvkm_oclass *

commit bfee3f3d97db88bfb732735eb4955ad3381ac758
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:08 2015 +1000

    drm/nouveau/gr: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
index 897628062d58..6b9c84f8f12d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -35,34 +35,34 @@ gm20b_gr_sclass[] = {
 };
 
 static void
-gm20b_gr_init_gpc_mmu(struct gf100_gr_priv *priv)
+gm20b_gr_init_gpc_mmu(struct gf100_gr *gr)
 {
 	u32 val;
 
 	/* TODO this needs to be removed once secure boot works */
 	if (1) {
-		nv_wr32(priv, 0x100ce4, 0xffffffff);
+		nv_wr32(gr, 0x100ce4, 0xffffffff);
 	}
 
 	/* TODO update once secure boot works */
-	val = nv_rd32(priv, 0x100c80);
+	val = nv_rd32(gr, 0x100c80);
 	val &= 0xf000087f;
-	nv_wr32(priv, 0x418880, val);
-	nv_wr32(priv, 0x418890, 0);
-	nv_wr32(priv, 0x418894, 0);
+	nv_wr32(gr, 0x418880, val);
+	nv_wr32(gr, 0x418890, 0);
+	nv_wr32(gr, 0x418894, 0);
 
-	nv_wr32(priv, 0x4188b0, nv_rd32(priv, 0x100cc4));
-	nv_wr32(priv, 0x4188b4, nv_rd32(priv, 0x100cc8));
-	nv_wr32(priv, 0x4188b8, nv_rd32(priv, 0x100ccc));
+	nv_wr32(gr, 0x4188b0, nv_rd32(gr, 0x100cc4));
+	nv_wr32(gr, 0x4188b4, nv_rd32(gr, 0x100cc8));
+	nv_wr32(gr, 0x4188b8, nv_rd32(gr, 0x100ccc));
 
-	nv_wr32(priv, 0x4188ac, nv_rd32(priv, 0x100800));
+	nv_wr32(gr, 0x4188ac, nv_rd32(gr, 0x100800));
 }
 
 static void
-gm20b_gr_set_hww_esr_report_mask(struct gf100_gr_priv *priv)
+gm20b_gr_set_hww_esr_report_mask(struct gf100_gr *gr)
 {
-	nv_wr32(priv, 0x419e44, 0xdffffe);
-	nv_wr32(priv, 0x419e4c, 0x5);
+	nv_wr32(gr, 0x419e44, 0xdffffe);
+	nv_wr32(gr, 0x419e4c, 0x5);
 }
 
 struct nvkm_oclass *

commit a032fb9da665ed6e6a36fa6788eff1db43ba2703
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Tue Jun 23 15:16:04 2015 +0900

    drm/nouveau/gr: add GM20B support
    
    Add support for GM20B's graphics engine, based on GK20A. Note that this
    code alone will not allow the engine to initialize on released devices
    which require PMU-assisted secure boot.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
new file mode 100644
index 000000000000..897628062d58
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2015, NVIDIA CORPORATION. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#include "gk20a.h"
+#include "ctxgf100.h"
+
+#include <nvif/class.h>
+#include <subdev/timer.h>
+
+static struct nvkm_oclass
+gm20b_gr_sclass[] = {
+	{ FERMI_TWOD_A, &nvkm_object_ofuncs },
+	{ KEPLER_INLINE_TO_MEMORY_B, &nvkm_object_ofuncs },
+	{ MAXWELL_B, &gf100_fermi_ofuncs, gf100_gr_9097_omthds },
+	{ MAXWELL_COMPUTE_B, &nvkm_object_ofuncs, gf100_gr_90c0_omthds },
+	{}
+};
+
+static void
+gm20b_gr_init_gpc_mmu(struct gf100_gr_priv *priv)
+{
+	u32 val;
+
+	/* TODO this needs to be removed once secure boot works */
+	if (1) {
+		nv_wr32(priv, 0x100ce4, 0xffffffff);
+	}
+
+	/* TODO update once secure boot works */
+	val = nv_rd32(priv, 0x100c80);
+	val &= 0xf000087f;
+	nv_wr32(priv, 0x418880, val);
+	nv_wr32(priv, 0x418890, 0);
+	nv_wr32(priv, 0x418894, 0);
+
+	nv_wr32(priv, 0x4188b0, nv_rd32(priv, 0x100cc4));
+	nv_wr32(priv, 0x4188b4, nv_rd32(priv, 0x100cc8));
+	nv_wr32(priv, 0x4188b8, nv_rd32(priv, 0x100ccc));
+
+	nv_wr32(priv, 0x4188ac, nv_rd32(priv, 0x100800));
+}
+
+static void
+gm20b_gr_set_hww_esr_report_mask(struct gf100_gr_priv *priv)
+{
+	nv_wr32(priv, 0x419e44, 0xdffffe);
+	nv_wr32(priv, 0x419e4c, 0x5);
+}
+
+struct nvkm_oclass *
+gm20b_gr_oclass = &(struct gk20a_gr_oclass) {
+	.gf100 = {
+		.base.handle = NV_ENGINE(GR, 0x2b),
+		.base.ofuncs = &(struct nvkm_ofuncs) {
+			.ctor = gk20a_gr_ctor,
+			.dtor = gf100_gr_dtor,
+			.init = gk20a_gr_init,
+			.fini = _nvkm_gr_fini,
+		},
+		.cclass = &gm20b_grctx_oclass,
+		.sclass = gm20b_gr_sclass,
+		.ppc_nr = 1,
+	},
+	.init_gpc_mmu = gm20b_gr_init_gpc_mmu,
+	.set_hww_esr_report_mask = gm20b_gr_set_hww_esr_report_mask,
+}.gf100.base;
