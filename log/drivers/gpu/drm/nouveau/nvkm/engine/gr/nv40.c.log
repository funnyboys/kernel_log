commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index 05a895496fc6..5f1ad8344ea9 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -438,7 +438,7 @@ nv40_gr_new_(const struct nvkm_gr_func *func, struct nvkm_device *device,
 	*pgr = &gr->base;
 	INIT_LIST_HEAD(&gr->chan);
 
-	return nvkm_gr_ctor(func, device, index, 0x00001000, true, &gr->base);
+	return nvkm_gr_ctor(func, device, index, true, &gr->base);
 }
 
 static const struct nvkm_gr_func

commit 9daf38f4fcca509d198fa4184760d55cd30a7b31
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon Jan 4 09:01:13 2016 +1000

    drm/nouveau/gr/nv40: fix oops in interrupt handler
    
    fdo#93557
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index ffa902ece872..05a895496fc6 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -156,6 +156,7 @@ nv40_gr_chan_new(struct nvkm_gr *base, struct nvkm_fifo_chan *fifoch,
 		return -ENOMEM;
 	nvkm_object_ctor(&nv40_gr_chan, oclass, &chan->object);
 	chan->gr = gr;
+	chan->fifo = fifoch;
 	*pobject = &chan->object;
 
 	spin_lock_irqsave(&chan->gr->base.engine.lock, flags);

commit 7e8820fed712c6de1933dcc91edbf08dcec74925
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:23 2015 +1000

    drm/nouveau/device: cleaner abstraction for device resource functions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index 7987df18415b..ffa902ece872 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -385,7 +385,7 @@ nv40_gr_init(struct nvkm_gr *base)
 	}
 
 	/* begin RAM config */
-	vramsz = nv_device_resource_len(device, 1) - 1;
+	vramsz = device->func->resource_size(device, 1) - 1;
 	switch (device->chipset) {
 	case 0x40:
 		nvkm_wr32(device, 0x4009A4, nvkm_rd32(device, 0x100200));

commit 68f3f702b6a430a8d1e909455a60d26c0f2da530
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/core: remove the remainder of the previous style
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index 127a36f5859e..7987df18415b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -48,7 +48,7 @@ nv40_gr_object_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,
 				  false, parent, pgpuobj);
 	if (ret == 0) {
 		nvkm_kmap(*pgpuobj);
-		nvkm_wo32(*pgpuobj, 0x00, object->oclass_name);
+		nvkm_wo32(*pgpuobj, 0x00, object->oclass);
 		nvkm_wo32(*pgpuobj, 0x04, 0x00000000);
 		nvkm_wo32(*pgpuobj, 0x08, 0x00000000);
 #ifdef __BIG_ENDIAN

commit c85ee6ca79590cd51356bf24fb8936bc352138cf
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/gr: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index be954500b4d8..127a36f5859e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -30,7 +30,7 @@
 #include <subdev/timer.h>
 #include <engine/fifo.h>
 
-static u64
+u64
 nv40_gr_units(struct nvkm_gr *gr)
 {
 	return nvkm_rd32(gr->engine.subdev.device, 0x1540);
@@ -61,7 +61,7 @@ nv40_gr_object_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,
 	return ret;
 }
 
-static const struct nvkm_object_func
+const struct nvkm_object_func
 nv40_gr_object = {
 	.bind = nv40_gr_object_bind,
 };
@@ -144,7 +144,7 @@ nv40_gr_chan = {
 	.bind = nv40_gr_chan_bind,
 };
 
-static int
+int
 nv40_gr_chan_new(struct nvkm_gr *base, struct nvkm_fifo_chan *fifoch,
 		 const struct nvkm_oclass *oclass, struct nvkm_object **pobject)
 {
@@ -169,31 +169,29 @@ nv40_gr_chan_new(struct nvkm_gr *base, struct nvkm_fifo_chan *fifoch,
  ******************************************************************************/
 
 static void
-nv40_gr_tile_prog(struct nvkm_engine *engine, int i)
+nv40_gr_tile(struct nvkm_gr *base, int i, struct nvkm_fb_tile *tile)
 {
-	struct nv40_gr *gr = (void *)engine;
+	struct nv40_gr *gr = nv40_gr(base);
 	struct nvkm_device *device = gr->base.engine.subdev.device;
 	struct nvkm_fifo *fifo = device->fifo;
-	struct nvkm_fb_tile *tile = &device->fb->tile.region[i];
 	unsigned long flags;
 
 	nvkm_fifo_pause(fifo, &flags);
 	nv04_gr_idle(&gr->base);
 
-	switch (nv_device(gr)->chipset) {
+	switch (device->chipset) {
 	case 0x40:
 	case 0x41:
 	case 0x42:
 	case 0x43:
 	case 0x45:
-	case 0x4e:
 		nvkm_wr32(device, NV20_PGRAPH_TSIZE(i), tile->pitch);
 		nvkm_wr32(device, NV20_PGRAPH_TLIMIT(i), tile->limit);
 		nvkm_wr32(device, NV20_PGRAPH_TILE(i), tile->addr);
 		nvkm_wr32(device, NV40_PGRAPH_TSIZE1(i), tile->pitch);
 		nvkm_wr32(device, NV40_PGRAPH_TLIMIT1(i), tile->limit);
 		nvkm_wr32(device, NV40_PGRAPH_TILE1(i), tile->addr);
-		switch (nv_device(gr)->chipset) {
+		switch (device->chipset) {
 		case 0x40:
 		case 0x45:
 			nvkm_wr32(device, NV20_PGRAPH_ZCOMP(i), tile->zcomp);
@@ -209,50 +207,33 @@ nv40_gr_tile_prog(struct nvkm_engine *engine, int i)
 			break;
 		}
 		break;
-	case 0x44:
-	case 0x4a:
-		nvkm_wr32(device, NV20_PGRAPH_TSIZE(i), tile->pitch);
-		nvkm_wr32(device, NV20_PGRAPH_TLIMIT(i), tile->limit);
-		nvkm_wr32(device, NV20_PGRAPH_TILE(i), tile->addr);
-		break;
-	case 0x46:
-	case 0x4c:
 	case 0x47:
 	case 0x49:
 	case 0x4b:
-	case 0x63:
-	case 0x67:
-	case 0x68:
 		nvkm_wr32(device, NV47_PGRAPH_TSIZE(i), tile->pitch);
 		nvkm_wr32(device, NV47_PGRAPH_TLIMIT(i), tile->limit);
 		nvkm_wr32(device, NV47_PGRAPH_TILE(i), tile->addr);
 		nvkm_wr32(device, NV40_PGRAPH_TSIZE1(i), tile->pitch);
 		nvkm_wr32(device, NV40_PGRAPH_TLIMIT1(i), tile->limit);
 		nvkm_wr32(device, NV40_PGRAPH_TILE1(i), tile->addr);
-		switch (nv_device(gr)->chipset) {
-		case 0x47:
-		case 0x49:
-		case 0x4b:
-			nvkm_wr32(device, NV47_PGRAPH_ZCOMP0(i), tile->zcomp);
-			nvkm_wr32(device, NV47_PGRAPH_ZCOMP1(i), tile->zcomp);
-			break;
-		default:
-			break;
-		}
+		nvkm_wr32(device, NV47_PGRAPH_ZCOMP0(i), tile->zcomp);
+		nvkm_wr32(device, NV47_PGRAPH_ZCOMP1(i), tile->zcomp);
 		break;
 	default:
+		WARN_ON(1);
 		break;
 	}
 
 	nvkm_fifo_start(fifo, &flags);
 }
 
-static void
-nv40_gr_intr(struct nvkm_subdev *subdev)
+void
+nv40_gr_intr(struct nvkm_gr *base)
 {
-	struct nv40_gr *gr = (void *)subdev;
+	struct nv40_gr *gr = nv40_gr(base);
 	struct nv40_gr_chan *temp, *chan = NULL;
-	struct nvkm_device *device = gr->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &gr->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	u32 stat = nvkm_rd32(device, NV03_PGRAPH_INTR);
 	u32 nsource = nvkm_rd32(device, NV03_PGRAPH_NSOURCE);
 	u32 nstatus = nvkm_rd32(device, NV03_PGRAPH_NSTATUS);
@@ -301,98 +282,16 @@ nv40_gr_intr(struct nvkm_subdev *subdev)
 	spin_unlock_irqrestore(&gr->base.engine.lock, flags);
 }
 
-static const struct nvkm_gr_func
-nv40_gr = {
-	.chan_new = nv40_gr_chan_new,
-	.sclass = {
-		{ -1, -1, 0x0012, &nv40_gr_object }, /* beta1 */
-		{ -1, -1, 0x0019, &nv40_gr_object }, /* clip */
-		{ -1, -1, 0x0030, &nv40_gr_object }, /* null */
-		{ -1, -1, 0x0039, &nv40_gr_object }, /* m2mf */
-		{ -1, -1, 0x0043, &nv40_gr_object }, /* rop */
-		{ -1, -1, 0x0044, &nv40_gr_object }, /* patt */
-		{ -1, -1, 0x004a, &nv40_gr_object }, /* gdi */
-		{ -1, -1, 0x0062, &nv40_gr_object }, /* surf2d */
-		{ -1, -1, 0x0072, &nv40_gr_object }, /* beta4 */
-		{ -1, -1, 0x0089, &nv40_gr_object }, /* sifm */
-		{ -1, -1, 0x008a, &nv40_gr_object }, /* ifc */
-		{ -1, -1, 0x009f, &nv40_gr_object }, /* imageblit */
-		{ -1, -1, 0x3062, &nv40_gr_object }, /* surf2d (nv40) */
-		{ -1, -1, 0x3089, &nv40_gr_object }, /* sifm (nv40) */
-		{ -1, -1, 0x309e, &nv40_gr_object }, /* swzsurf (nv40) */
-		{ -1, -1, 0x4097, &nv40_gr_object }, /* curie */
-		{}
-	}
-};
-
-static const struct nvkm_gr_func
-nv44_gr = {
-	.chan_new = nv40_gr_chan_new,
-	.sclass = {
-		{ -1, -1, 0x0012, &nv40_gr_object }, /* beta1 */
-		{ -1, -1, 0x0019, &nv40_gr_object }, /* clip */
-		{ -1, -1, 0x0030, &nv40_gr_object }, /* null */
-		{ -1, -1, 0x0039, &nv40_gr_object }, /* m2mf */
-		{ -1, -1, 0x0043, &nv40_gr_object }, /* rop */
-		{ -1, -1, 0x0044, &nv40_gr_object }, /* patt */
-		{ -1, -1, 0x004a, &nv40_gr_object }, /* gdi */
-		{ -1, -1, 0x0062, &nv40_gr_object }, /* surf2d */
-		{ -1, -1, 0x0072, &nv40_gr_object }, /* beta4 */
-		{ -1, -1, 0x0089, &nv40_gr_object }, /* sifm */
-		{ -1, -1, 0x008a, &nv40_gr_object }, /* ifc */
-		{ -1, -1, 0x009f, &nv40_gr_object }, /* imageblit */
-		{ -1, -1, 0x3062, &nv40_gr_object }, /* surf2d (nv40) */
-		{ -1, -1, 0x3089, &nv40_gr_object }, /* sifm (nv40) */
-		{ -1, -1, 0x309e, &nv40_gr_object }, /* swzsurf (nv40) */
-		{ -1, -1, 0x4497, &nv40_gr_object }, /* curie */
-	{}
-	}
-};
-
-static int
-nv40_gr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-	     struct nvkm_oclass *oclass, void *data, u32 size,
-	     struct nvkm_object **pobject)
-{
-	struct nvkm_device *device = (void *)parent;
-	struct nv40_gr *gr;
-	int ret;
-
-	ret = nvkm_gr_create(parent, engine, oclass, true, &gr);
-	*pobject = nv_object(gr);
-	if (ret)
-		return ret;
-
-	INIT_LIST_HEAD(&gr->chan);
-
-	nv_subdev(gr)->unit = 0x00001000;
-	nv_subdev(gr)->intr = nv40_gr_intr;
-	if (nv44_gr_class(device))
-		gr->base.func = &nv44_gr;
-	else
-		gr->base.func = &nv40_gr;
-	nv_engine(gr)->tile_prog = nv40_gr_tile_prog;
-
-	gr->base.units = nv40_gr_units;
-	return 0;
-}
-
-static int
-nv40_gr_init(struct nvkm_object *object)
+int
+nv40_gr_init(struct nvkm_gr *base)
 {
-	struct nvkm_engine *engine = nv_engine(object);
-	struct nv40_gr *gr = (void *)engine;
+	struct nv40_gr *gr = nv40_gr(base);
 	struct nvkm_device *device = gr->base.engine.subdev.device;
-	struct nvkm_fb *fb = device->fb;
 	int ret, i, j;
 	u32 vramsz;
 
-	ret = nvkm_gr_init(&gr->base);
-	if (ret)
-		return ret;
-
 	/* generate and upload context program */
-	ret = nv40_grctx_init(nv_device(gr), &gr->size);
+	ret = nv40_grctx_init(device, &gr->size);
 	if (ret)
 		return ret;
 
@@ -419,7 +318,7 @@ nv40_gr_init(struct nvkm_object *object)
 		nvkm_wr32(device, 0x405000, i);
 	}
 
-	if (nv_device(gr)->chipset == 0x40) {
+	if (device->chipset == 0x40) {
 		nvkm_wr32(device, 0x4009b0, 0x83280fff);
 		nvkm_wr32(device, 0x4009b4, 0x000000a0);
 	} else {
@@ -427,7 +326,7 @@ nv40_gr_init(struct nvkm_object *object)
 		nvkm_wr32(device, 0x400824, 0x000000a0);
 	}
 
-	switch (nv_device(gr)->chipset) {
+	switch (device->chipset) {
 	case 0x40:
 	case 0x45:
 		nvkm_wr32(device, 0x4009b8, 0x0078e366);
@@ -465,7 +364,7 @@ nv40_gr_init(struct nvkm_object *object)
 	nvkm_wr32(device, 0x400b3c, 0x00006000);
 
 	/* Tiling related stuff. */
-	switch (nv_device(gr)->chipset) {
+	switch (device->chipset) {
 	case 0x44:
 	case 0x4a:
 		nvkm_wr32(device, 0x400bc4, 0x1003d888);
@@ -485,13 +384,9 @@ nv40_gr_init(struct nvkm_object *object)
 		break;
 	}
 
-	/* Turn all the tiling regions off. */
-	for (i = 0; i < fb->tile.regions; i++)
-		engine->tile_prog(engine, i);
-
 	/* begin RAM config */
-	vramsz = nv_device_resource_len(nv_device(gr), 1) - 1;
-	switch (nv_device(gr)->chipset) {
+	vramsz = nv_device_resource_len(device, 1) - 1;
+	switch (device->chipset) {
 	case 0x40:
 		nvkm_wr32(device, 0x4009A4, nvkm_rd32(device, 0x100200));
 		nvkm_wr32(device, 0x4009A8, nvkm_rd32(device, 0x100204));
@@ -503,7 +398,7 @@ nv40_gr_init(struct nvkm_object *object)
 		nvkm_wr32(device, 0x400868, vramsz);
 		break;
 	default:
-		switch (nv_device(gr)->chipset) {
+		switch (device->chipset) {
 		case 0x41:
 		case 0x42:
 		case 0x43:
@@ -531,13 +426,50 @@ nv40_gr_init(struct nvkm_object *object)
 	return 0;
 }
 
-struct nvkm_oclass
-nv40_gr_oclass = {
-	.handle = NV_ENGINE(GR, 0x40),
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nv40_gr_ctor,
-		.dtor = _nvkm_gr_dtor,
-		.init = nv40_gr_init,
-		.fini = _nvkm_gr_fini,
-	},
+int
+nv40_gr_new_(const struct nvkm_gr_func *func, struct nvkm_device *device,
+	     int index, struct nvkm_gr **pgr)
+{
+	struct nv40_gr *gr;
+
+	if (!(gr = kzalloc(sizeof(*gr), GFP_KERNEL)))
+		return -ENOMEM;
+	*pgr = &gr->base;
+	INIT_LIST_HEAD(&gr->chan);
+
+	return nvkm_gr_ctor(func, device, index, 0x00001000, true, &gr->base);
+}
+
+static const struct nvkm_gr_func
+nv40_gr = {
+	.init = nv40_gr_init,
+	.intr = nv40_gr_intr,
+	.tile = nv40_gr_tile,
+	.units = nv40_gr_units,
+	.chan_new = nv40_gr_chan_new,
+	.sclass = {
+		{ -1, -1, 0x0012, &nv40_gr_object }, /* beta1 */
+		{ -1, -1, 0x0019, &nv40_gr_object }, /* clip */
+		{ -1, -1, 0x0030, &nv40_gr_object }, /* null */
+		{ -1, -1, 0x0039, &nv40_gr_object }, /* m2mf */
+		{ -1, -1, 0x0043, &nv40_gr_object }, /* rop */
+		{ -1, -1, 0x0044, &nv40_gr_object }, /* patt */
+		{ -1, -1, 0x004a, &nv40_gr_object }, /* gdi */
+		{ -1, -1, 0x0062, &nv40_gr_object }, /* surf2d */
+		{ -1, -1, 0x0072, &nv40_gr_object }, /* beta4 */
+		{ -1, -1, 0x0089, &nv40_gr_object }, /* sifm */
+		{ -1, -1, 0x008a, &nv40_gr_object }, /* ifc */
+		{ -1, -1, 0x009f, &nv40_gr_object }, /* imageblit */
+		{ -1, -1, 0x3062, &nv40_gr_object }, /* surf2d (nv40) */
+		{ -1, -1, 0x3089, &nv40_gr_object }, /* sifm (nv40) */
+		{ -1, -1, 0x309e, &nv40_gr_object }, /* swzsurf (nv40) */
+		{ -1, -1, 0x4097, &nv40_gr_object }, /* curie */
+		{}
+	}
 };
+
+int
+nv40_gr_new(struct nvkm_device *device, int index, struct nvkm_gr **pgr)
+{
+	return nv40_gr_new_(&nv40_gr, device, index, pgr);
+}

commit 13de7f462902d1a452d501cdb2d06ef02cabbfff
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/fifo: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index 0e4e1152eeec..be954500b4d8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -25,6 +25,7 @@
 #include "regs.h"
 
 #include <core/client.h>
+#include <core/gpuobj.h>
 #include <subdev/fb.h>
 #include <subdev/timer.h>
 #include <engine/fifo.h>
@@ -176,7 +177,7 @@ nv40_gr_tile_prog(struct nvkm_engine *engine, int i)
 	struct nvkm_fb_tile *tile = &device->fb->tile.region[i];
 	unsigned long flags;
 
-	fifo->pause(fifo, &flags);
+	nvkm_fifo_pause(fifo, &flags);
 	nv04_gr_idle(&gr->base);
 
 	switch (nv_device(gr)->chipset) {
@@ -243,7 +244,7 @@ nv40_gr_tile_prog(struct nvkm_engine *engine, int i)
 		break;
 	}
 
-	fifo->start(fifo, &flags);
+	nvkm_fifo_start(fifo, &flags);
 }
 
 static void

commit b7a2bc1886d00f5f1358079e1e6f4979006a4ed6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/imem: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index 0103337f55d2..0e4e1152eeec 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -353,6 +353,7 @@ nv40_gr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	     struct nvkm_oclass *oclass, void *data, u32 size,
 	     struct nvkm_object **pobject)
 {
+	struct nvkm_device *device = (void *)parent;
 	struct nv40_gr *gr;
 	int ret;
 
@@ -365,7 +366,7 @@ nv40_gr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	nv_subdev(gr)->unit = 0x00001000;
 	nv_subdev(gr)->intr = nv40_gr_intr;
-	if (nv44_gr_class(gr))
+	if (nv44_gr_class(device))
 		gr->base.func = &nv44_gr;
 	else
 		gr->base.func = &nv40_gr;

commit 27f3d6cf80324940edd29be7758f81145e73d1ff
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/gr: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index e716ae12b55c..0103337f55d2 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -29,19 +29,6 @@
 #include <subdev/timer.h>
 #include <engine/fifo.h>
 
-struct nv40_gr {
-	struct nvkm_gr base;
-	u32 size;
-	struct list_head chan;
-};
-
-struct nv40_gr_chan {
-	struct nvkm_gr_chan base;
-	struct nvkm_fifo_chan *fifo;
-	u32 inst;
-	struct list_head head;
-};
-
 static u64
 nv40_gr_units(struct nvkm_gr *gr)
 {
@@ -53,133 +40,61 @@ nv40_gr_units(struct nvkm_gr *gr)
  ******************************************************************************/
 
 static int
-nv40_gr_object_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-		    struct nvkm_oclass *oclass, void *data, u32 size,
-		    struct nvkm_object **pobject)
+nv40_gr_object_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,
+		    int align, struct nvkm_gpuobj **pgpuobj)
 {
-	struct nvkm_gpuobj *obj;
-	int ret;
-
-	ret = nvkm_gpuobj_create(parent, engine, oclass, 0, parent,
-				 20, 16, 0, &obj);
-	*pobject = nv_object(obj);
-	if (ret)
-		return ret;
-
-	nvkm_kmap(obj);
-	nvkm_wo32(obj, 0x00, nv_mclass(obj));
-	nvkm_wo32(obj, 0x04, 0x00000000);
-	nvkm_wo32(obj, 0x08, 0x00000000);
+	int ret = nvkm_gpuobj_new(object->engine->subdev.device, 20, align,
+				  false, parent, pgpuobj);
+	if (ret == 0) {
+		nvkm_kmap(*pgpuobj);
+		nvkm_wo32(*pgpuobj, 0x00, object->oclass_name);
+		nvkm_wo32(*pgpuobj, 0x04, 0x00000000);
+		nvkm_wo32(*pgpuobj, 0x08, 0x00000000);
 #ifdef __BIG_ENDIAN
-	nvkm_mo32(obj, 0x08, 0x01000000, 0x01000000);
+		nvkm_mo32(*pgpuobj, 0x08, 0x01000000, 0x01000000);
 #endif
-	nvkm_wo32(obj, 0x0c, 0x00000000);
-	nvkm_wo32(obj, 0x10, 0x00000000);
-	nvkm_done(obj);
-	return 0;
+		nvkm_wo32(*pgpuobj, 0x0c, 0x00000000);
+		nvkm_wo32(*pgpuobj, 0x10, 0x00000000);
+		nvkm_done(*pgpuobj);
+	}
+	return ret;
 }
 
-static struct nvkm_ofuncs
-nv40_gr_ofuncs = {
-	.ctor = nv40_gr_object_ctor,
-	.dtor = _nvkm_gpuobj_dtor,
-	.init = _nvkm_gpuobj_init,
-	.fini = _nvkm_gpuobj_fini,
-	.rd32 = _nvkm_gpuobj_rd32,
-	.wr32 = _nvkm_gpuobj_wr32,
-};
-
-static struct nvkm_oclass
-nv40_gr_sclass[] = {
-	{ 0x0012, &nv40_gr_ofuncs, NULL }, /* beta1 */
-	{ 0x0019, &nv40_gr_ofuncs, NULL }, /* clip */
-	{ 0x0030, &nv40_gr_ofuncs, NULL }, /* null */
-	{ 0x0039, &nv40_gr_ofuncs, NULL }, /* m2mf */
-	{ 0x0043, &nv40_gr_ofuncs, NULL }, /* rop */
-	{ 0x0044, &nv40_gr_ofuncs, NULL }, /* patt */
-	{ 0x004a, &nv40_gr_ofuncs, NULL }, /* gdi */
-	{ 0x0062, &nv40_gr_ofuncs, NULL }, /* surf2d */
-	{ 0x0072, &nv40_gr_ofuncs, NULL }, /* beta4 */
-	{ 0x0089, &nv40_gr_ofuncs, NULL }, /* sifm */
-	{ 0x008a, &nv40_gr_ofuncs, NULL }, /* ifc */
-	{ 0x009f, &nv40_gr_ofuncs, NULL }, /* imageblit */
-	{ 0x3062, &nv40_gr_ofuncs, NULL }, /* surf2d (nv40) */
-	{ 0x3089, &nv40_gr_ofuncs, NULL }, /* sifm (nv40) */
-	{ 0x309e, &nv40_gr_ofuncs, NULL }, /* swzsurf (nv40) */
-	{ 0x4097, &nv40_gr_ofuncs, NULL }, /* curie */
-	{},
-};
-
-static struct nvkm_oclass
-nv44_gr_sclass[] = {
-	{ 0x0012, &nv40_gr_ofuncs, NULL }, /* beta1 */
-	{ 0x0019, &nv40_gr_ofuncs, NULL }, /* clip */
-	{ 0x0030, &nv40_gr_ofuncs, NULL }, /* null */
-	{ 0x0039, &nv40_gr_ofuncs, NULL }, /* m2mf */
-	{ 0x0043, &nv40_gr_ofuncs, NULL }, /* rop */
-	{ 0x0044, &nv40_gr_ofuncs, NULL }, /* patt */
-	{ 0x004a, &nv40_gr_ofuncs, NULL }, /* gdi */
-	{ 0x0062, &nv40_gr_ofuncs, NULL }, /* surf2d */
-	{ 0x0072, &nv40_gr_ofuncs, NULL }, /* beta4 */
-	{ 0x0089, &nv40_gr_ofuncs, NULL }, /* sifm */
-	{ 0x008a, &nv40_gr_ofuncs, NULL }, /* ifc */
-	{ 0x009f, &nv40_gr_ofuncs, NULL }, /* imageblit */
-	{ 0x3062, &nv40_gr_ofuncs, NULL }, /* surf2d (nv40) */
-	{ 0x3089, &nv40_gr_ofuncs, NULL }, /* sifm (nv40) */
-	{ 0x309e, &nv40_gr_ofuncs, NULL }, /* swzsurf (nv40) */
-	{ 0x4497, &nv40_gr_ofuncs, NULL }, /* curie */
-	{},
+static const struct nvkm_object_func
+nv40_gr_object = {
+	.bind = nv40_gr_object_bind,
 };
 
 /*******************************************************************************
  * PGRAPH context
  ******************************************************************************/
 
-static void
-nv40_gr_context_dtor(struct nvkm_object *object)
-{
-	struct nv40_gr_chan *chan = (void *)object;
-	unsigned long flags;
-	spin_lock_irqsave(&object->engine->lock, flags);
-	list_del(&chan->head);
-	spin_unlock_irqrestore(&object->engine->lock, flags);
-}
-
 static int
-nv40_gr_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-		     struct nvkm_oclass *oclass, void *data, u32 size,
-		     struct nvkm_object **pobject)
+nv40_gr_chan_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,
+		  int align, struct nvkm_gpuobj **pgpuobj)
 {
-	struct nv40_gr *gr = (void *)engine;
-	struct nv40_gr_chan *chan;
-	unsigned long flags;
-	int ret;
-
-	ret = nvkm_gr_context_create(parent, engine, oclass, NULL, gr->size,
-				     16, NVOBJ_FLAG_ZERO_ALLOC, &chan);
-	*pobject = nv_object(chan);
-	if (ret)
-		return ret;
-
-	nv40_grctx_fill(nv_device(gr), nv_gpuobj(chan));
-	nvkm_wo32(&chan->base.base.gpuobj, 0x00000, nv_gpuobj(chan)->addr >> 4);
-
-	spin_lock_irqsave(&gr->base.engine.lock, flags);
-	chan->fifo = (void *)parent;
-	chan->inst = chan->base.base.gpuobj.addr;
-	list_add(&chan->head, &gr->chan);
-	spin_unlock_irqrestore(&gr->base.engine.lock, flags);
-	return 0;
+	struct nv40_gr_chan *chan = nv40_gr_chan(object);
+	struct nv40_gr *gr = chan->gr;
+	int ret = nvkm_gpuobj_new(gr->base.engine.subdev.device, gr->size,
+				  align, true, parent, pgpuobj);
+	if (ret == 0) {
+		chan->inst = (*pgpuobj)->addr;
+		nvkm_kmap(*pgpuobj);
+		nv40_grctx_fill(gr->base.engine.subdev.device, *pgpuobj);
+		nvkm_wo32(*pgpuobj, 0x00000, chan->inst >> 4);
+		nvkm_done(*pgpuobj);
+	}
+	return ret;
 }
 
 static int
-nv40_gr_context_fini(struct nvkm_object *object, bool suspend)
+nv40_gr_chan_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nv40_gr *gr = (void *)object->engine;
-	struct nv40_gr_chan *chan = (void *)object;
+	struct nv40_gr_chan *chan = nv40_gr_chan(object);
+	struct nv40_gr *gr = chan->gr;
 	struct nvkm_subdev *subdev = &gr->base.engine.subdev;
 	struct nvkm_device *device = subdev->device;
-	u32 inst = 0x01000000 | nv_gpuobj(chan)->addr >> 4;
+	u32 inst = 0x01000000 | chan->inst >> 4;
 	int ret = 0;
 
 	nvkm_mask(device, 0x400720, 0x00000001, 0x00000000);
@@ -210,19 +125,44 @@ nv40_gr_context_fini(struct nvkm_object *object, bool suspend)
 	return ret;
 }
 
-static struct nvkm_oclass
-nv40_gr_cclass = {
-	.handle = NV_ENGCTX(GR, 0x40),
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nv40_gr_context_ctor,
-		.dtor = nv40_gr_context_dtor,
-		.init = _nvkm_gr_context_init,
-		.fini = nv40_gr_context_fini,
-		.rd32 = _nvkm_gr_context_rd32,
-		.wr32 = _nvkm_gr_context_wr32,
-	},
+static void *
+nv40_gr_chan_dtor(struct nvkm_object *object)
+{
+	struct nv40_gr_chan *chan = nv40_gr_chan(object);
+	unsigned long flags;
+	spin_lock_irqsave(&chan->gr->base.engine.lock, flags);
+	list_del(&chan->head);
+	spin_unlock_irqrestore(&chan->gr->base.engine.lock, flags);
+	return chan;
+}
+
+static const struct nvkm_object_func
+nv40_gr_chan = {
+	.dtor = nv40_gr_chan_dtor,
+	.fini = nv40_gr_chan_fini,
+	.bind = nv40_gr_chan_bind,
 };
 
+static int
+nv40_gr_chan_new(struct nvkm_gr *base, struct nvkm_fifo_chan *fifoch,
+		 const struct nvkm_oclass *oclass, struct nvkm_object **pobject)
+{
+	struct nv40_gr *gr = nv40_gr(base);
+	struct nv40_gr_chan *chan;
+	unsigned long flags;
+
+	if (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))
+		return -ENOMEM;
+	nvkm_object_ctor(&nv40_gr_chan, oclass, &chan->object);
+	chan->gr = gr;
+	*pobject = &chan->object;
+
+	spin_lock_irqsave(&chan->gr->base.engine.lock, flags);
+	list_add(&chan->head, &gr->chan);
+	spin_unlock_irqrestore(&chan->gr->base.engine.lock, flags);
+	return 0;
+}
+
 /*******************************************************************************
  * PGRAPH engine/subdev functions
  ******************************************************************************/
@@ -237,7 +177,7 @@ nv40_gr_tile_prog(struct nvkm_engine *engine, int i)
 	unsigned long flags;
 
 	fifo->pause(fifo, &flags);
-	nv04_gr_idle(gr);
+	nv04_gr_idle(&gr->base);
 
 	switch (nv_device(gr)->chipset) {
 	case 0x40:
@@ -360,6 +300,54 @@ nv40_gr_intr(struct nvkm_subdev *subdev)
 	spin_unlock_irqrestore(&gr->base.engine.lock, flags);
 }
 
+static const struct nvkm_gr_func
+nv40_gr = {
+	.chan_new = nv40_gr_chan_new,
+	.sclass = {
+		{ -1, -1, 0x0012, &nv40_gr_object }, /* beta1 */
+		{ -1, -1, 0x0019, &nv40_gr_object }, /* clip */
+		{ -1, -1, 0x0030, &nv40_gr_object }, /* null */
+		{ -1, -1, 0x0039, &nv40_gr_object }, /* m2mf */
+		{ -1, -1, 0x0043, &nv40_gr_object }, /* rop */
+		{ -1, -1, 0x0044, &nv40_gr_object }, /* patt */
+		{ -1, -1, 0x004a, &nv40_gr_object }, /* gdi */
+		{ -1, -1, 0x0062, &nv40_gr_object }, /* surf2d */
+		{ -1, -1, 0x0072, &nv40_gr_object }, /* beta4 */
+		{ -1, -1, 0x0089, &nv40_gr_object }, /* sifm */
+		{ -1, -1, 0x008a, &nv40_gr_object }, /* ifc */
+		{ -1, -1, 0x009f, &nv40_gr_object }, /* imageblit */
+		{ -1, -1, 0x3062, &nv40_gr_object }, /* surf2d (nv40) */
+		{ -1, -1, 0x3089, &nv40_gr_object }, /* sifm (nv40) */
+		{ -1, -1, 0x309e, &nv40_gr_object }, /* swzsurf (nv40) */
+		{ -1, -1, 0x4097, &nv40_gr_object }, /* curie */
+		{}
+	}
+};
+
+static const struct nvkm_gr_func
+nv44_gr = {
+	.chan_new = nv40_gr_chan_new,
+	.sclass = {
+		{ -1, -1, 0x0012, &nv40_gr_object }, /* beta1 */
+		{ -1, -1, 0x0019, &nv40_gr_object }, /* clip */
+		{ -1, -1, 0x0030, &nv40_gr_object }, /* null */
+		{ -1, -1, 0x0039, &nv40_gr_object }, /* m2mf */
+		{ -1, -1, 0x0043, &nv40_gr_object }, /* rop */
+		{ -1, -1, 0x0044, &nv40_gr_object }, /* patt */
+		{ -1, -1, 0x004a, &nv40_gr_object }, /* gdi */
+		{ -1, -1, 0x0062, &nv40_gr_object }, /* surf2d */
+		{ -1, -1, 0x0072, &nv40_gr_object }, /* beta4 */
+		{ -1, -1, 0x0089, &nv40_gr_object }, /* sifm */
+		{ -1, -1, 0x008a, &nv40_gr_object }, /* ifc */
+		{ -1, -1, 0x009f, &nv40_gr_object }, /* imageblit */
+		{ -1, -1, 0x3062, &nv40_gr_object }, /* surf2d (nv40) */
+		{ -1, -1, 0x3089, &nv40_gr_object }, /* sifm (nv40) */
+		{ -1, -1, 0x309e, &nv40_gr_object }, /* swzsurf (nv40) */
+		{ -1, -1, 0x4497, &nv40_gr_object }, /* curie */
+	{}
+	}
+};
+
 static int
 nv40_gr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	     struct nvkm_oclass *oclass, void *data, u32 size,
@@ -377,11 +365,10 @@ nv40_gr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	nv_subdev(gr)->unit = 0x00001000;
 	nv_subdev(gr)->intr = nv40_gr_intr;
-	nv_engine(gr)->cclass = &nv40_gr_cclass;
 	if (nv44_gr_class(gr))
-		nv_engine(gr)->sclass = nv44_gr_sclass;
+		gr->base.func = &nv44_gr;
 	else
-		nv_engine(gr)->sclass = nv40_gr_sclass;
+		gr->base.func = &nv40_gr;
 	nv_engine(gr)->tile_prog = nv40_gr_tile_prog;
 
 	gr->base.units = nv40_gr_units;

commit 8f0649b5c6e70ec18122255690e39f010c12a614
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/fifo: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index 4db2a17f5308..e716ae12b55c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -353,7 +353,8 @@ nv40_gr_intr(struct nvkm_subdev *subdev)
 				   "class %04x mthd %04x data %08x\n",
 			   show, msg, nsource, src, nstatus, sta,
 			   chan ? chan->fifo->chid : -1, inst << 4,
-			   nvkm_client_name(chan), subc, class, mthd, data);
+			   chan ? chan->fifo->object.client->name : "unknown",
+			   subc, class, mthd, data);
 	}
 
 	spin_unlock_irqrestore(&gr->base.engine.lock, flags);

commit a65955e19e769e92a0e29cccdc29aea0b19f3809
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/gr: remove dependence on namedb/engctx lookup
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index 1ebf2edef4d4..4db2a17f5308 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -25,7 +25,6 @@
 #include "regs.h"
 
 #include <core/client.h>
-#include <core/handle.h>
 #include <subdev/fb.h>
 #include <subdev/timer.h>
 #include <engine/fifo.h>
@@ -33,10 +32,14 @@
 struct nv40_gr {
 	struct nvkm_gr base;
 	u32 size;
+	struct list_head chan;
 };
 
 struct nv40_gr_chan {
 	struct nvkm_gr_chan base;
+	struct nvkm_fifo_chan *fifo;
+	u32 inst;
+	struct list_head head;
 };
 
 static u64
@@ -132,6 +135,16 @@ nv44_gr_sclass[] = {
  * PGRAPH context
  ******************************************************************************/
 
+static void
+nv40_gr_context_dtor(struct nvkm_object *object)
+{
+	struct nv40_gr_chan *chan = (void *)object;
+	unsigned long flags;
+	spin_lock_irqsave(&object->engine->lock, flags);
+	list_del(&chan->head);
+	spin_unlock_irqrestore(&object->engine->lock, flags);
+}
+
 static int
 nv40_gr_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		     struct nvkm_oclass *oclass, void *data, u32 size,
@@ -139,6 +152,7 @@ nv40_gr_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 {
 	struct nv40_gr *gr = (void *)engine;
 	struct nv40_gr_chan *chan;
+	unsigned long flags;
 	int ret;
 
 	ret = nvkm_gr_context_create(parent, engine, oclass, NULL, gr->size,
@@ -149,6 +163,12 @@ nv40_gr_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	nv40_grctx_fill(nv_device(gr), nv_gpuobj(chan));
 	nvkm_wo32(&chan->base.base.gpuobj, 0x00000, nv_gpuobj(chan)->addr >> 4);
+
+	spin_lock_irqsave(&gr->base.engine.lock, flags);
+	chan->fifo = (void *)parent;
+	chan->inst = chan->base.base.gpuobj.addr;
+	list_add(&chan->head, &gr->chan);
+	spin_unlock_irqrestore(&gr->base.engine.lock, flags);
 	return 0;
 }
 
@@ -195,7 +215,7 @@ nv40_gr_cclass = {
 	.handle = NV_ENGCTX(GR, 0x40),
 	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv40_gr_context_ctor,
-		.dtor = _nvkm_gr_context_dtor,
+		.dtor = nv40_gr_context_dtor,
 		.init = _nvkm_gr_context_init,
 		.fini = nv40_gr_context_fini,
 		.rd32 = _nvkm_gr_context_rd32,
@@ -289,11 +309,8 @@ nv40_gr_tile_prog(struct nvkm_engine *engine, int i)
 static void
 nv40_gr_intr(struct nvkm_subdev *subdev)
 {
-	struct nvkm_fifo *fifo = nvkm_fifo(subdev);
-	struct nvkm_engine *engine = nv_engine(subdev);
-	struct nvkm_object *engctx;
-	struct nvkm_handle *handle = NULL;
 	struct nv40_gr *gr = (void *)subdev;
+	struct nv40_gr_chan *temp, *chan = NULL;
 	struct nvkm_device *device = gr->base.engine.subdev.device;
 	u32 stat = nvkm_rd32(device, NV03_PGRAPH_INTR);
 	u32 nsource = nvkm_rd32(device, NV03_PGRAPH_NSOURCE);
@@ -306,19 +323,19 @@ nv40_gr_intr(struct nvkm_subdev *subdev)
 	u32 class = nvkm_rd32(device, 0x400160 + subc * 4) & 0xffff;
 	u32 show = stat;
 	char msg[128], src[128], sta[128];
-	int chid;
-
-	engctx = nvkm_engctx_get(engine, inst);
-	chid   = fifo->chid(fifo, engctx);
+	unsigned long flags;
 
-	if (stat & NV_PGRAPH_INTR_ERROR) {
-		if (nsource & NV03_PGRAPH_NSOURCE_ILLEGAL_MTHD) {
-			handle = nvkm_handle_get_class(engctx, class);
-			if (handle && !nv_call(handle->object, mthd, data))
-				show &= ~NV_PGRAPH_INTR_ERROR;
-			nvkm_handle_put(handle);
+	spin_lock_irqsave(&gr->base.engine.lock, flags);
+	list_for_each_entry(temp, &gr->chan, head) {
+		if (temp->inst >> 4 == inst) {
+			chan = temp;
+			list_del(&chan->head);
+			list_add(&chan->head, &gr->chan);
+			break;
 		}
+	}
 
+	if (stat & NV_PGRAPH_INTR_ERROR) {
 		if (nsource & NV03_PGRAPH_NSOURCE_DMA_VTX_PROTECTION) {
 			nvkm_mask(device, 0x402000, 0, 0);
 		}
@@ -334,12 +351,12 @@ nv40_gr_intr(struct nvkm_subdev *subdev)
 		nvkm_error(subdev, "intr %08x [%s] nsource %08x [%s] "
 				   "nstatus %08x [%s] ch %d [%08x %s] subc %d "
 				   "class %04x mthd %04x data %08x\n",
-			   show, msg, nsource, src, nstatus, sta, chid,
-			   inst << 4, nvkm_client_name(engctx), subc,
-			   class, mthd, data);
+			   show, msg, nsource, src, nstatus, sta,
+			   chan ? chan->fifo->chid : -1, inst << 4,
+			   nvkm_client_name(chan), subc, class, mthd, data);
 	}
 
-	nvkm_engctx_put(engctx);
+	spin_unlock_irqrestore(&gr->base.engine.lock, flags);
 }
 
 static int
@@ -355,6 +372,8 @@ nv40_gr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
+	INIT_LIST_HEAD(&gr->chan);
+
 	nv_subdev(gr)->unit = 0x00001000;
 	nv_subdev(gr)->intr = nv40_gr_intr;
 	nv_engine(gr)->cclass = &nv40_gr_cclass;

commit 142ea05f49b9517929f8b27ee800160e7ebf3a02
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:14 2015 +1000

    drm/nouveau/gr: switch to gpuobj accessor macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index 10ffb676e55e..1ebf2edef4d4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -63,14 +63,16 @@ nv40_gr_object_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	nv_wo32(obj, 0x00, nv_mclass(obj));
-	nv_wo32(obj, 0x04, 0x00000000);
-	nv_wo32(obj, 0x08, 0x00000000);
+	nvkm_kmap(obj);
+	nvkm_wo32(obj, 0x00, nv_mclass(obj));
+	nvkm_wo32(obj, 0x04, 0x00000000);
+	nvkm_wo32(obj, 0x08, 0x00000000);
 #ifdef __BIG_ENDIAN
-	nv_mo32(obj, 0x08, 0x01000000, 0x01000000);
+	nvkm_mo32(obj, 0x08, 0x01000000, 0x01000000);
 #endif
-	nv_wo32(obj, 0x0c, 0x00000000);
-	nv_wo32(obj, 0x10, 0x00000000);
+	nvkm_wo32(obj, 0x0c, 0x00000000);
+	nvkm_wo32(obj, 0x10, 0x00000000);
+	nvkm_done(obj);
 	return 0;
 }
 
@@ -146,7 +148,7 @@ nv40_gr_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		return ret;
 
 	nv40_grctx_fill(nv_device(gr), nv_gpuobj(chan));
-	nv_wo32(chan, 0x00000, nv_gpuobj(chan)->addr >> 4);
+	nvkm_wo32(&chan->base.base.gpuobj, 0x00000, nv_gpuobj(chan)->addr >> 4);
 	return 0;
 }
 

commit 109c2f2f1c42c16a4b265e796dee6ae4ada78417
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:13 2015 +1000

    drm/nouveau/gr: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index 7455049ff178..10ffb676e55e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -155,7 +155,8 @@ nv40_gr_context_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nv40_gr *gr = (void *)object->engine;
 	struct nv40_gr_chan *chan = (void *)object;
-	struct nvkm_device *device = gr->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &gr->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	u32 inst = 0x01000000 | nv_gpuobj(chan)->addr >> 4;
 	int ret = 0;
 
@@ -172,7 +173,7 @@ nv40_gr_context_fini(struct nvkm_object *object, bool suspend)
 					break;
 			) < 0) {
 				u32 insn = nvkm_rd32(device, 0x400308);
-				nv_warn(gr, "ctxprog timeout 0x%08x\n", insn);
+				nvkm_warn(subdev, "ctxprog timeout %08x\n", insn);
 				ret = -EBUSY;
 			}
 		}
@@ -302,6 +303,7 @@ nv40_gr_intr(struct nvkm_subdev *subdev)
 	u32 data = nvkm_rd32(device, NV04_PGRAPH_TRAPPED_DATA);
 	u32 class = nvkm_rd32(device, 0x400160 + subc * 4) & 0xffff;
 	u32 show = stat;
+	char msg[128], src[128], sta[128];
 	int chid;
 
 	engctx = nvkm_engctx_get(engine, inst);
@@ -324,17 +326,15 @@ nv40_gr_intr(struct nvkm_subdev *subdev)
 	nvkm_wr32(device, NV04_PGRAPH_FIFO, 0x00000001);
 
 	if (show) {
-		nv_error(gr, "%s", "");
-		nvkm_bitfield_print(nv10_gr_intr_name, show);
-		pr_cont(" nsource:");
-		nvkm_bitfield_print(nv04_gr_nsource, nsource);
-		pr_cont(" nstatus:");
-		nvkm_bitfield_print(nv10_gr_nstatus, nstatus);
-		pr_cont("\n");
-		nv_error(gr,
-			 "ch %d [0x%08x %s] subc %d class 0x%04x mthd 0x%04x data 0x%08x\n",
-			 chid, inst << 4, nvkm_client_name(engctx), subc,
-			 class, mthd, data);
+		nvkm_snprintbf(msg, sizeof(msg), nv10_gr_intr_name, show);
+		nvkm_snprintbf(src, sizeof(src), nv04_gr_nsource, nsource);
+		nvkm_snprintbf(sta, sizeof(sta), nv10_gr_nstatus, nstatus);
+		nvkm_error(subdev, "intr %08x [%s] nsource %08x [%s] "
+				   "nstatus %08x [%s] ch %d [%08x %s] subc %d "
+				   "class %04x mthd %04x data %08x\n",
+			   show, msg, nsource, src, nstatus, sta, chid,
+			   inst << 4, nvkm_client_name(engctx), subc,
+			   class, mthd, data);
 	}
 
 	nvkm_engctx_put(engctx);

commit c4584adc37720b65ae44a84c660d47b3ebcf7dfb
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:11 2015 +1000

    drm/nouveau/gr: switch to new-style timer macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index edcaa65b1e09..7455049ff178 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -167,7 +167,10 @@ nv40_gr_context_fini(struct nvkm_object *object, bool suspend)
 			nvkm_wr32(device, 0x400784, inst);
 			nvkm_mask(device, 0x400310, 0x00000020, 0x00000020);
 			nvkm_mask(device, 0x400304, 0x00000001, 0x00000001);
-			if (!nv_wait(gr, 0x400300, 0x00000001, 0x00000000)) {
+			if (nvkm_msec(device, 2000,
+				if (!(nvkm_rd32(device, 0x400300) & 0x00000001))
+					break;
+			) < 0) {
 				u32 insn = nvkm_rd32(device, 0x400308);
 				nv_warn(gr, "ctxprog timeout 0x%08x\n", insn);
 				ret = -EBUSY;

commit 276836d46e535c8ca299a1ea8302879dbdd3e93a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:10 2015 +1000

    drm/nouveau/gr: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index 3c2df9d29ff3..edcaa65b1e09 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -42,7 +42,7 @@ struct nv40_gr_chan {
 static u64
 nv40_gr_units(struct nvkm_gr *gr)
 {
-	return nv_rd32(gr, 0x1540);
+	return nvkm_rd32(gr->engine.subdev.device, 0x1540);
 }
 
 /*******************************************************************************
@@ -155,31 +155,32 @@ nv40_gr_context_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nv40_gr *gr = (void *)object->engine;
 	struct nv40_gr_chan *chan = (void *)object;
+	struct nvkm_device *device = gr->base.engine.subdev.device;
 	u32 inst = 0x01000000 | nv_gpuobj(chan)->addr >> 4;
 	int ret = 0;
 
-	nv_mask(gr, 0x400720, 0x00000001, 0x00000000);
+	nvkm_mask(device, 0x400720, 0x00000001, 0x00000000);
 
-	if (nv_rd32(gr, 0x40032c) == inst) {
+	if (nvkm_rd32(device, 0x40032c) == inst) {
 		if (suspend) {
-			nv_wr32(gr, 0x400720, 0x00000000);
-			nv_wr32(gr, 0x400784, inst);
-			nv_mask(gr, 0x400310, 0x00000020, 0x00000020);
-			nv_mask(gr, 0x400304, 0x00000001, 0x00000001);
+			nvkm_wr32(device, 0x400720, 0x00000000);
+			nvkm_wr32(device, 0x400784, inst);
+			nvkm_mask(device, 0x400310, 0x00000020, 0x00000020);
+			nvkm_mask(device, 0x400304, 0x00000001, 0x00000001);
 			if (!nv_wait(gr, 0x400300, 0x00000001, 0x00000000)) {
-				u32 insn = nv_rd32(gr, 0x400308);
+				u32 insn = nvkm_rd32(device, 0x400308);
 				nv_warn(gr, "ctxprog timeout 0x%08x\n", insn);
 				ret = -EBUSY;
 			}
 		}
 
-		nv_mask(gr, 0x40032c, 0x01000000, 0x00000000);
+		nvkm_mask(device, 0x40032c, 0x01000000, 0x00000000);
 	}
 
-	if (nv_rd32(gr, 0x400330) == inst)
-		nv_mask(gr, 0x400330, 0x01000000, 0x00000000);
+	if (nvkm_rd32(device, 0x400330) == inst)
+		nvkm_mask(device, 0x400330, 0x01000000, 0x00000000);
 
-	nv_mask(gr, 0x400720, 0x00000001, 0x00000001);
+	nvkm_mask(device, 0x400720, 0x00000001, 0x00000001);
 	return ret;
 }
 
@@ -203,9 +204,10 @@ nv40_gr_cclass = {
 static void
 nv40_gr_tile_prog(struct nvkm_engine *engine, int i)
 {
-	struct nvkm_fb_tile *tile = &nvkm_fb(engine)->tile.region[i];
-	struct nvkm_fifo *fifo = nvkm_fifo(engine);
 	struct nv40_gr *gr = (void *)engine;
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	struct nvkm_fifo *fifo = device->fifo;
+	struct nvkm_fb_tile *tile = &device->fb->tile.region[i];
 	unsigned long flags;
 
 	fifo->pause(fifo, &flags);
@@ -218,23 +220,23 @@ nv40_gr_tile_prog(struct nvkm_engine *engine, int i)
 	case 0x43:
 	case 0x45:
 	case 0x4e:
-		nv_wr32(gr, NV20_PGRAPH_TSIZE(i), tile->pitch);
-		nv_wr32(gr, NV20_PGRAPH_TLIMIT(i), tile->limit);
-		nv_wr32(gr, NV20_PGRAPH_TILE(i), tile->addr);
-		nv_wr32(gr, NV40_PGRAPH_TSIZE1(i), tile->pitch);
-		nv_wr32(gr, NV40_PGRAPH_TLIMIT1(i), tile->limit);
-		nv_wr32(gr, NV40_PGRAPH_TILE1(i), tile->addr);
+		nvkm_wr32(device, NV20_PGRAPH_TSIZE(i), tile->pitch);
+		nvkm_wr32(device, NV20_PGRAPH_TLIMIT(i), tile->limit);
+		nvkm_wr32(device, NV20_PGRAPH_TILE(i), tile->addr);
+		nvkm_wr32(device, NV40_PGRAPH_TSIZE1(i), tile->pitch);
+		nvkm_wr32(device, NV40_PGRAPH_TLIMIT1(i), tile->limit);
+		nvkm_wr32(device, NV40_PGRAPH_TILE1(i), tile->addr);
 		switch (nv_device(gr)->chipset) {
 		case 0x40:
 		case 0x45:
-			nv_wr32(gr, NV20_PGRAPH_ZCOMP(i), tile->zcomp);
-			nv_wr32(gr, NV40_PGRAPH_ZCOMP1(i), tile->zcomp);
+			nvkm_wr32(device, NV20_PGRAPH_ZCOMP(i), tile->zcomp);
+			nvkm_wr32(device, NV40_PGRAPH_ZCOMP1(i), tile->zcomp);
 			break;
 		case 0x41:
 		case 0x42:
 		case 0x43:
-			nv_wr32(gr, NV41_PGRAPH_ZCOMP0(i), tile->zcomp);
-			nv_wr32(gr, NV41_PGRAPH_ZCOMP1(i), tile->zcomp);
+			nvkm_wr32(device, NV41_PGRAPH_ZCOMP0(i), tile->zcomp);
+			nvkm_wr32(device, NV41_PGRAPH_ZCOMP1(i), tile->zcomp);
 			break;
 		default:
 			break;
@@ -242,9 +244,9 @@ nv40_gr_tile_prog(struct nvkm_engine *engine, int i)
 		break;
 	case 0x44:
 	case 0x4a:
-		nv_wr32(gr, NV20_PGRAPH_TSIZE(i), tile->pitch);
-		nv_wr32(gr, NV20_PGRAPH_TLIMIT(i), tile->limit);
-		nv_wr32(gr, NV20_PGRAPH_TILE(i), tile->addr);
+		nvkm_wr32(device, NV20_PGRAPH_TSIZE(i), tile->pitch);
+		nvkm_wr32(device, NV20_PGRAPH_TLIMIT(i), tile->limit);
+		nvkm_wr32(device, NV20_PGRAPH_TILE(i), tile->addr);
 		break;
 	case 0x46:
 	case 0x4c:
@@ -254,18 +256,18 @@ nv40_gr_tile_prog(struct nvkm_engine *engine, int i)
 	case 0x63:
 	case 0x67:
 	case 0x68:
-		nv_wr32(gr, NV47_PGRAPH_TSIZE(i), tile->pitch);
-		nv_wr32(gr, NV47_PGRAPH_TLIMIT(i), tile->limit);
-		nv_wr32(gr, NV47_PGRAPH_TILE(i), tile->addr);
-		nv_wr32(gr, NV40_PGRAPH_TSIZE1(i), tile->pitch);
-		nv_wr32(gr, NV40_PGRAPH_TLIMIT1(i), tile->limit);
-		nv_wr32(gr, NV40_PGRAPH_TILE1(i), tile->addr);
+		nvkm_wr32(device, NV47_PGRAPH_TSIZE(i), tile->pitch);
+		nvkm_wr32(device, NV47_PGRAPH_TLIMIT(i), tile->limit);
+		nvkm_wr32(device, NV47_PGRAPH_TILE(i), tile->addr);
+		nvkm_wr32(device, NV40_PGRAPH_TSIZE1(i), tile->pitch);
+		nvkm_wr32(device, NV40_PGRAPH_TLIMIT1(i), tile->limit);
+		nvkm_wr32(device, NV40_PGRAPH_TILE1(i), tile->addr);
 		switch (nv_device(gr)->chipset) {
 		case 0x47:
 		case 0x49:
 		case 0x4b:
-			nv_wr32(gr, NV47_PGRAPH_ZCOMP0(i), tile->zcomp);
-			nv_wr32(gr, NV47_PGRAPH_ZCOMP1(i), tile->zcomp);
+			nvkm_wr32(device, NV47_PGRAPH_ZCOMP0(i), tile->zcomp);
+			nvkm_wr32(device, NV47_PGRAPH_ZCOMP1(i), tile->zcomp);
 			break;
 		default:
 			break;
@@ -286,15 +288,16 @@ nv40_gr_intr(struct nvkm_subdev *subdev)
 	struct nvkm_object *engctx;
 	struct nvkm_handle *handle = NULL;
 	struct nv40_gr *gr = (void *)subdev;
-	u32 stat = nv_rd32(gr, NV03_PGRAPH_INTR);
-	u32 nsource = nv_rd32(gr, NV03_PGRAPH_NSOURCE);
-	u32 nstatus = nv_rd32(gr, NV03_PGRAPH_NSTATUS);
-	u32 inst = nv_rd32(gr, 0x40032c) & 0x000fffff;
-	u32 addr = nv_rd32(gr, NV04_PGRAPH_TRAPPED_ADDR);
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	u32 stat = nvkm_rd32(device, NV03_PGRAPH_INTR);
+	u32 nsource = nvkm_rd32(device, NV03_PGRAPH_NSOURCE);
+	u32 nstatus = nvkm_rd32(device, NV03_PGRAPH_NSTATUS);
+	u32 inst = nvkm_rd32(device, 0x40032c) & 0x000fffff;
+	u32 addr = nvkm_rd32(device, NV04_PGRAPH_TRAPPED_ADDR);
 	u32 subc = (addr & 0x00070000) >> 16;
 	u32 mthd = (addr & 0x00001ffc);
-	u32 data = nv_rd32(gr, NV04_PGRAPH_TRAPPED_DATA);
-	u32 class = nv_rd32(gr, 0x400160 + subc * 4) & 0xffff;
+	u32 data = nvkm_rd32(device, NV04_PGRAPH_TRAPPED_DATA);
+	u32 class = nvkm_rd32(device, 0x400160 + subc * 4) & 0xffff;
 	u32 show = stat;
 	int chid;
 
@@ -310,12 +313,12 @@ nv40_gr_intr(struct nvkm_subdev *subdev)
 		}
 
 		if (nsource & NV03_PGRAPH_NSOURCE_DMA_VTX_PROTECTION) {
-			nv_mask(gr, 0x402000, 0, 0);
+			nvkm_mask(device, 0x402000, 0, 0);
 		}
 	}
 
-	nv_wr32(gr, NV03_PGRAPH_INTR, stat);
-	nv_wr32(gr, NV04_PGRAPH_FIFO, 0x00000001);
+	nvkm_wr32(device, NV03_PGRAPH_INTR, stat);
+	nvkm_wr32(device, NV04_PGRAPH_FIFO, 0x00000001);
 
 	if (show) {
 		nv_error(gr, "%s", "");
@@ -364,8 +367,9 @@ static int
 nv40_gr_init(struct nvkm_object *object)
 {
 	struct nvkm_engine *engine = nv_engine(object);
-	struct nvkm_fb *fb = nvkm_fb(object);
 	struct nv40_gr *gr = (void *)engine;
+	struct nvkm_device *device = gr->base.engine.subdev.device;
+	struct nvkm_fb *fb = device->fb;
 	int ret, i, j;
 	u32 vramsz;
 
@@ -379,89 +383,89 @@ nv40_gr_init(struct nvkm_object *object)
 		return ret;
 
 	/* No context present currently */
-	nv_wr32(gr, NV40_PGRAPH_CTXCTL_CUR, 0x00000000);
+	nvkm_wr32(device, NV40_PGRAPH_CTXCTL_CUR, 0x00000000);
 
-	nv_wr32(gr, NV03_PGRAPH_INTR   , 0xFFFFFFFF);
-	nv_wr32(gr, NV40_PGRAPH_INTR_EN, 0xFFFFFFFF);
+	nvkm_wr32(device, NV03_PGRAPH_INTR   , 0xFFFFFFFF);
+	nvkm_wr32(device, NV40_PGRAPH_INTR_EN, 0xFFFFFFFF);
 
-	nv_wr32(gr, NV04_PGRAPH_DEBUG_0, 0xFFFFFFFF);
-	nv_wr32(gr, NV04_PGRAPH_DEBUG_0, 0x00000000);
-	nv_wr32(gr, NV04_PGRAPH_DEBUG_1, 0x401287c0);
-	nv_wr32(gr, NV04_PGRAPH_DEBUG_3, 0xe0de8055);
-	nv_wr32(gr, NV10_PGRAPH_DEBUG_4, 0x00008000);
-	nv_wr32(gr, NV04_PGRAPH_LIMIT_VIOL_PIX, 0x00be3c5f);
+	nvkm_wr32(device, NV04_PGRAPH_DEBUG_0, 0xFFFFFFFF);
+	nvkm_wr32(device, NV04_PGRAPH_DEBUG_0, 0x00000000);
+	nvkm_wr32(device, NV04_PGRAPH_DEBUG_1, 0x401287c0);
+	nvkm_wr32(device, NV04_PGRAPH_DEBUG_3, 0xe0de8055);
+	nvkm_wr32(device, NV10_PGRAPH_DEBUG_4, 0x00008000);
+	nvkm_wr32(device, NV04_PGRAPH_LIMIT_VIOL_PIX, 0x00be3c5f);
 
-	nv_wr32(gr, NV10_PGRAPH_CTX_CONTROL, 0x10010100);
-	nv_wr32(gr, NV10_PGRAPH_STATE      , 0xFFFFFFFF);
+	nvkm_wr32(device, NV10_PGRAPH_CTX_CONTROL, 0x10010100);
+	nvkm_wr32(device, NV10_PGRAPH_STATE      , 0xFFFFFFFF);
 
-	j = nv_rd32(gr, 0x1540) & 0xff;
+	j = nvkm_rd32(device, 0x1540) & 0xff;
 	if (j) {
 		for (i = 0; !(j & 1); j >>= 1, i++)
 			;
-		nv_wr32(gr, 0x405000, i);
+		nvkm_wr32(device, 0x405000, i);
 	}
 
 	if (nv_device(gr)->chipset == 0x40) {
-		nv_wr32(gr, 0x4009b0, 0x83280fff);
-		nv_wr32(gr, 0x4009b4, 0x000000a0);
+		nvkm_wr32(device, 0x4009b0, 0x83280fff);
+		nvkm_wr32(device, 0x4009b4, 0x000000a0);
 	} else {
-		nv_wr32(gr, 0x400820, 0x83280eff);
-		nv_wr32(gr, 0x400824, 0x000000a0);
+		nvkm_wr32(device, 0x400820, 0x83280eff);
+		nvkm_wr32(device, 0x400824, 0x000000a0);
 	}
 
 	switch (nv_device(gr)->chipset) {
 	case 0x40:
 	case 0x45:
-		nv_wr32(gr, 0x4009b8, 0x0078e366);
-		nv_wr32(gr, 0x4009bc, 0x0000014c);
+		nvkm_wr32(device, 0x4009b8, 0x0078e366);
+		nvkm_wr32(device, 0x4009bc, 0x0000014c);
 		break;
 	case 0x41:
 	case 0x42: /* pciid also 0x00Cx */
 	/* case 0x0120: XXX (pciid) */
-		nv_wr32(gr, 0x400828, 0x007596ff);
-		nv_wr32(gr, 0x40082c, 0x00000108);
+		nvkm_wr32(device, 0x400828, 0x007596ff);
+		nvkm_wr32(device, 0x40082c, 0x00000108);
 		break;
 	case 0x43:
-		nv_wr32(gr, 0x400828, 0x0072cb77);
-		nv_wr32(gr, 0x40082c, 0x00000108);
+		nvkm_wr32(device, 0x400828, 0x0072cb77);
+		nvkm_wr32(device, 0x40082c, 0x00000108);
 		break;
 	case 0x44:
 	case 0x46: /* G72 */
 	case 0x4a:
 	case 0x4c: /* G7x-based C51 */
 	case 0x4e:
-		nv_wr32(gr, 0x400860, 0);
-		nv_wr32(gr, 0x400864, 0);
+		nvkm_wr32(device, 0x400860, 0);
+		nvkm_wr32(device, 0x400864, 0);
 		break;
 	case 0x47: /* G70 */
 	case 0x49: /* G71 */
 	case 0x4b: /* G73 */
-		nv_wr32(gr, 0x400828, 0x07830610);
-		nv_wr32(gr, 0x40082c, 0x0000016A);
+		nvkm_wr32(device, 0x400828, 0x07830610);
+		nvkm_wr32(device, 0x40082c, 0x0000016A);
 		break;
 	default:
 		break;
 	}
 
-	nv_wr32(gr, 0x400b38, 0x2ffff800);
-	nv_wr32(gr, 0x400b3c, 0x00006000);
+	nvkm_wr32(device, 0x400b38, 0x2ffff800);
+	nvkm_wr32(device, 0x400b3c, 0x00006000);
 
 	/* Tiling related stuff. */
 	switch (nv_device(gr)->chipset) {
 	case 0x44:
 	case 0x4a:
-		nv_wr32(gr, 0x400bc4, 0x1003d888);
-		nv_wr32(gr, 0x400bbc, 0xb7a7b500);
+		nvkm_wr32(device, 0x400bc4, 0x1003d888);
+		nvkm_wr32(device, 0x400bbc, 0xb7a7b500);
 		break;
 	case 0x46:
-		nv_wr32(gr, 0x400bc4, 0x0000e024);
-		nv_wr32(gr, 0x400bbc, 0xb7a7b520);
+		nvkm_wr32(device, 0x400bc4, 0x0000e024);
+		nvkm_wr32(device, 0x400bbc, 0xb7a7b520);
 		break;
 	case 0x4c:
 	case 0x4e:
 	case 0x67:
-		nv_wr32(gr, 0x400bc4, 0x1003d888);
-		nv_wr32(gr, 0x400bbc, 0xb7a7b540);
+		nvkm_wr32(device, 0x400bc4, 0x1003d888);
+		nvkm_wr32(device, 0x400bbc, 0xb7a7b540);
 		break;
 	default:
 		break;
@@ -475,14 +479,14 @@ nv40_gr_init(struct nvkm_object *object)
 	vramsz = nv_device_resource_len(nv_device(gr), 1) - 1;
 	switch (nv_device(gr)->chipset) {
 	case 0x40:
-		nv_wr32(gr, 0x4009A4, nv_rd32(gr, 0x100200));
-		nv_wr32(gr, 0x4009A8, nv_rd32(gr, 0x100204));
-		nv_wr32(gr, 0x4069A4, nv_rd32(gr, 0x100200));
-		nv_wr32(gr, 0x4069A8, nv_rd32(gr, 0x100204));
-		nv_wr32(gr, 0x400820, 0);
-		nv_wr32(gr, 0x400824, 0);
-		nv_wr32(gr, 0x400864, vramsz);
-		nv_wr32(gr, 0x400868, vramsz);
+		nvkm_wr32(device, 0x4009A4, nvkm_rd32(device, 0x100200));
+		nvkm_wr32(device, 0x4009A8, nvkm_rd32(device, 0x100204));
+		nvkm_wr32(device, 0x4069A4, nvkm_rd32(device, 0x100200));
+		nvkm_wr32(device, 0x4069A8, nvkm_rd32(device, 0x100204));
+		nvkm_wr32(device, 0x400820, 0);
+		nvkm_wr32(device, 0x400824, 0);
+		nvkm_wr32(device, 0x400864, vramsz);
+		nvkm_wr32(device, 0x400868, vramsz);
 		break;
 	default:
 		switch (nv_device(gr)->chipset) {
@@ -493,20 +497,20 @@ nv40_gr_init(struct nvkm_object *object)
 		case 0x4e:
 		case 0x44:
 		case 0x4a:
-			nv_wr32(gr, 0x4009F0, nv_rd32(gr, 0x100200));
-			nv_wr32(gr, 0x4009F4, nv_rd32(gr, 0x100204));
+			nvkm_wr32(device, 0x4009F0, nvkm_rd32(device, 0x100200));
+			nvkm_wr32(device, 0x4009F4, nvkm_rd32(device, 0x100204));
 			break;
 		default:
-			nv_wr32(gr, 0x400DF0, nv_rd32(gr, 0x100200));
-			nv_wr32(gr, 0x400DF4, nv_rd32(gr, 0x100204));
+			nvkm_wr32(device, 0x400DF0, nvkm_rd32(device, 0x100200));
+			nvkm_wr32(device, 0x400DF4, nvkm_rd32(device, 0x100204));
 			break;
 		}
-		nv_wr32(gr, 0x4069F0, nv_rd32(gr, 0x100200));
-		nv_wr32(gr, 0x4069F4, nv_rd32(gr, 0x100204));
-		nv_wr32(gr, 0x400840, 0);
-		nv_wr32(gr, 0x400844, 0);
-		nv_wr32(gr, 0x4008A0, vramsz);
-		nv_wr32(gr, 0x4008A4, vramsz);
+		nvkm_wr32(device, 0x4069F0, nvkm_rd32(device, 0x100200));
+		nvkm_wr32(device, 0x4069F4, nvkm_rd32(device, 0x100204));
+		nvkm_wr32(device, 0x400840, 0);
+		nvkm_wr32(device, 0x400844, 0);
+		nvkm_wr32(device, 0x4008A0, vramsz);
+		nvkm_wr32(device, 0x4008A4, vramsz);
 		break;
 	}
 

commit bfee3f3d97db88bfb732735eb4955ad3381ac758
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:08 2015 +1000

    drm/nouveau/gr: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index c0a1751a1e88..3c2df9d29ff3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -30,7 +30,7 @@
 #include <subdev/timer.h>
 #include <engine/fifo.h>
 
-struct nv40_gr_priv {
+struct nv40_gr {
 	struct nvkm_gr base;
 	u32 size;
 };
@@ -42,9 +42,7 @@ struct nv40_gr_chan {
 static u64
 nv40_gr_units(struct nvkm_gr *gr)
 {
-	struct nv40_gr_priv *priv = (void *)gr;
-
-	return nv_rd32(priv, 0x1540);
+	return nv_rd32(gr, 0x1540);
 }
 
 /*******************************************************************************
@@ -137,17 +135,17 @@ nv40_gr_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		     struct nvkm_oclass *oclass, void *data, u32 size,
 		     struct nvkm_object **pobject)
 {
-	struct nv40_gr_priv *priv = (void *)engine;
+	struct nv40_gr *gr = (void *)engine;
 	struct nv40_gr_chan *chan;
 	int ret;
 
-	ret = nvkm_gr_context_create(parent, engine, oclass, NULL, priv->size,
+	ret = nvkm_gr_context_create(parent, engine, oclass, NULL, gr->size,
 				     16, NVOBJ_FLAG_ZERO_ALLOC, &chan);
 	*pobject = nv_object(chan);
 	if (ret)
 		return ret;
 
-	nv40_grctx_fill(nv_device(priv), nv_gpuobj(chan));
+	nv40_grctx_fill(nv_device(gr), nv_gpuobj(chan));
 	nv_wo32(chan, 0x00000, nv_gpuobj(chan)->addr >> 4);
 	return 0;
 }
@@ -155,33 +153,33 @@ nv40_gr_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 static int
 nv40_gr_context_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nv40_gr_priv *priv = (void *)object->engine;
+	struct nv40_gr *gr = (void *)object->engine;
 	struct nv40_gr_chan *chan = (void *)object;
 	u32 inst = 0x01000000 | nv_gpuobj(chan)->addr >> 4;
 	int ret = 0;
 
-	nv_mask(priv, 0x400720, 0x00000001, 0x00000000);
+	nv_mask(gr, 0x400720, 0x00000001, 0x00000000);
 
-	if (nv_rd32(priv, 0x40032c) == inst) {
+	if (nv_rd32(gr, 0x40032c) == inst) {
 		if (suspend) {
-			nv_wr32(priv, 0x400720, 0x00000000);
-			nv_wr32(priv, 0x400784, inst);
-			nv_mask(priv, 0x400310, 0x00000020, 0x00000020);
-			nv_mask(priv, 0x400304, 0x00000001, 0x00000001);
-			if (!nv_wait(priv, 0x400300, 0x00000001, 0x00000000)) {
-				u32 insn = nv_rd32(priv, 0x400308);
-				nv_warn(priv, "ctxprog timeout 0x%08x\n", insn);
+			nv_wr32(gr, 0x400720, 0x00000000);
+			nv_wr32(gr, 0x400784, inst);
+			nv_mask(gr, 0x400310, 0x00000020, 0x00000020);
+			nv_mask(gr, 0x400304, 0x00000001, 0x00000001);
+			if (!nv_wait(gr, 0x400300, 0x00000001, 0x00000000)) {
+				u32 insn = nv_rd32(gr, 0x400308);
+				nv_warn(gr, "ctxprog timeout 0x%08x\n", insn);
 				ret = -EBUSY;
 			}
 		}
 
-		nv_mask(priv, 0x40032c, 0x01000000, 0x00000000);
+		nv_mask(gr, 0x40032c, 0x01000000, 0x00000000);
 	}
 
-	if (nv_rd32(priv, 0x400330) == inst)
-		nv_mask(priv, 0x400330, 0x01000000, 0x00000000);
+	if (nv_rd32(gr, 0x400330) == inst)
+		nv_mask(gr, 0x400330, 0x01000000, 0x00000000);
 
-	nv_mask(priv, 0x400720, 0x00000001, 0x00000001);
+	nv_mask(gr, 0x400720, 0x00000001, 0x00000001);
 	return ret;
 }
 
@@ -207,36 +205,36 @@ nv40_gr_tile_prog(struct nvkm_engine *engine, int i)
 {
 	struct nvkm_fb_tile *tile = &nvkm_fb(engine)->tile.region[i];
 	struct nvkm_fifo *fifo = nvkm_fifo(engine);
-	struct nv40_gr_priv *priv = (void *)engine;
+	struct nv40_gr *gr = (void *)engine;
 	unsigned long flags;
 
 	fifo->pause(fifo, &flags);
-	nv04_gr_idle(priv);
+	nv04_gr_idle(gr);
 
-	switch (nv_device(priv)->chipset) {
+	switch (nv_device(gr)->chipset) {
 	case 0x40:
 	case 0x41:
 	case 0x42:
 	case 0x43:
 	case 0x45:
 	case 0x4e:
-		nv_wr32(priv, NV20_PGRAPH_TSIZE(i), tile->pitch);
-		nv_wr32(priv, NV20_PGRAPH_TLIMIT(i), tile->limit);
-		nv_wr32(priv, NV20_PGRAPH_TILE(i), tile->addr);
-		nv_wr32(priv, NV40_PGRAPH_TSIZE1(i), tile->pitch);
-		nv_wr32(priv, NV40_PGRAPH_TLIMIT1(i), tile->limit);
-		nv_wr32(priv, NV40_PGRAPH_TILE1(i), tile->addr);
-		switch (nv_device(priv)->chipset) {
+		nv_wr32(gr, NV20_PGRAPH_TSIZE(i), tile->pitch);
+		nv_wr32(gr, NV20_PGRAPH_TLIMIT(i), tile->limit);
+		nv_wr32(gr, NV20_PGRAPH_TILE(i), tile->addr);
+		nv_wr32(gr, NV40_PGRAPH_TSIZE1(i), tile->pitch);
+		nv_wr32(gr, NV40_PGRAPH_TLIMIT1(i), tile->limit);
+		nv_wr32(gr, NV40_PGRAPH_TILE1(i), tile->addr);
+		switch (nv_device(gr)->chipset) {
 		case 0x40:
 		case 0x45:
-			nv_wr32(priv, NV20_PGRAPH_ZCOMP(i), tile->zcomp);
-			nv_wr32(priv, NV40_PGRAPH_ZCOMP1(i), tile->zcomp);
+			nv_wr32(gr, NV20_PGRAPH_ZCOMP(i), tile->zcomp);
+			nv_wr32(gr, NV40_PGRAPH_ZCOMP1(i), tile->zcomp);
 			break;
 		case 0x41:
 		case 0x42:
 		case 0x43:
-			nv_wr32(priv, NV41_PGRAPH_ZCOMP0(i), tile->zcomp);
-			nv_wr32(priv, NV41_PGRAPH_ZCOMP1(i), tile->zcomp);
+			nv_wr32(gr, NV41_PGRAPH_ZCOMP0(i), tile->zcomp);
+			nv_wr32(gr, NV41_PGRAPH_ZCOMP1(i), tile->zcomp);
 			break;
 		default:
 			break;
@@ -244,9 +242,9 @@ nv40_gr_tile_prog(struct nvkm_engine *engine, int i)
 		break;
 	case 0x44:
 	case 0x4a:
-		nv_wr32(priv, NV20_PGRAPH_TSIZE(i), tile->pitch);
-		nv_wr32(priv, NV20_PGRAPH_TLIMIT(i), tile->limit);
-		nv_wr32(priv, NV20_PGRAPH_TILE(i), tile->addr);
+		nv_wr32(gr, NV20_PGRAPH_TSIZE(i), tile->pitch);
+		nv_wr32(gr, NV20_PGRAPH_TLIMIT(i), tile->limit);
+		nv_wr32(gr, NV20_PGRAPH_TILE(i), tile->addr);
 		break;
 	case 0x46:
 	case 0x4c:
@@ -256,18 +254,18 @@ nv40_gr_tile_prog(struct nvkm_engine *engine, int i)
 	case 0x63:
 	case 0x67:
 	case 0x68:
-		nv_wr32(priv, NV47_PGRAPH_TSIZE(i), tile->pitch);
-		nv_wr32(priv, NV47_PGRAPH_TLIMIT(i), tile->limit);
-		nv_wr32(priv, NV47_PGRAPH_TILE(i), tile->addr);
-		nv_wr32(priv, NV40_PGRAPH_TSIZE1(i), tile->pitch);
-		nv_wr32(priv, NV40_PGRAPH_TLIMIT1(i), tile->limit);
-		nv_wr32(priv, NV40_PGRAPH_TILE1(i), tile->addr);
-		switch (nv_device(priv)->chipset) {
+		nv_wr32(gr, NV47_PGRAPH_TSIZE(i), tile->pitch);
+		nv_wr32(gr, NV47_PGRAPH_TLIMIT(i), tile->limit);
+		nv_wr32(gr, NV47_PGRAPH_TILE(i), tile->addr);
+		nv_wr32(gr, NV40_PGRAPH_TSIZE1(i), tile->pitch);
+		nv_wr32(gr, NV40_PGRAPH_TLIMIT1(i), tile->limit);
+		nv_wr32(gr, NV40_PGRAPH_TILE1(i), tile->addr);
+		switch (nv_device(gr)->chipset) {
 		case 0x47:
 		case 0x49:
 		case 0x4b:
-			nv_wr32(priv, NV47_PGRAPH_ZCOMP0(i), tile->zcomp);
-			nv_wr32(priv, NV47_PGRAPH_ZCOMP1(i), tile->zcomp);
+			nv_wr32(gr, NV47_PGRAPH_ZCOMP0(i), tile->zcomp);
+			nv_wr32(gr, NV47_PGRAPH_ZCOMP1(i), tile->zcomp);
 			break;
 		default:
 			break;
@@ -287,16 +285,16 @@ nv40_gr_intr(struct nvkm_subdev *subdev)
 	struct nvkm_engine *engine = nv_engine(subdev);
 	struct nvkm_object *engctx;
 	struct nvkm_handle *handle = NULL;
-	struct nv40_gr_priv *priv = (void *)subdev;
-	u32 stat = nv_rd32(priv, NV03_PGRAPH_INTR);
-	u32 nsource = nv_rd32(priv, NV03_PGRAPH_NSOURCE);
-	u32 nstatus = nv_rd32(priv, NV03_PGRAPH_NSTATUS);
-	u32 inst = nv_rd32(priv, 0x40032c) & 0x000fffff;
-	u32 addr = nv_rd32(priv, NV04_PGRAPH_TRAPPED_ADDR);
+	struct nv40_gr *gr = (void *)subdev;
+	u32 stat = nv_rd32(gr, NV03_PGRAPH_INTR);
+	u32 nsource = nv_rd32(gr, NV03_PGRAPH_NSOURCE);
+	u32 nstatus = nv_rd32(gr, NV03_PGRAPH_NSTATUS);
+	u32 inst = nv_rd32(gr, 0x40032c) & 0x000fffff;
+	u32 addr = nv_rd32(gr, NV04_PGRAPH_TRAPPED_ADDR);
 	u32 subc = (addr & 0x00070000) >> 16;
 	u32 mthd = (addr & 0x00001ffc);
-	u32 data = nv_rd32(priv, NV04_PGRAPH_TRAPPED_DATA);
-	u32 class = nv_rd32(priv, 0x400160 + subc * 4) & 0xffff;
+	u32 data = nv_rd32(gr, NV04_PGRAPH_TRAPPED_DATA);
+	u32 class = nv_rd32(gr, 0x400160 + subc * 4) & 0xffff;
 	u32 show = stat;
 	int chid;
 
@@ -312,22 +310,22 @@ nv40_gr_intr(struct nvkm_subdev *subdev)
 		}
 
 		if (nsource & NV03_PGRAPH_NSOURCE_DMA_VTX_PROTECTION) {
-			nv_mask(priv, 0x402000, 0, 0);
+			nv_mask(gr, 0x402000, 0, 0);
 		}
 	}
 
-	nv_wr32(priv, NV03_PGRAPH_INTR, stat);
-	nv_wr32(priv, NV04_PGRAPH_FIFO, 0x00000001);
+	nv_wr32(gr, NV03_PGRAPH_INTR, stat);
+	nv_wr32(gr, NV04_PGRAPH_FIFO, 0x00000001);
 
 	if (show) {
-		nv_error(priv, "%s", "");
+		nv_error(gr, "%s", "");
 		nvkm_bitfield_print(nv10_gr_intr_name, show);
 		pr_cont(" nsource:");
 		nvkm_bitfield_print(nv04_gr_nsource, nsource);
 		pr_cont(" nstatus:");
 		nvkm_bitfield_print(nv10_gr_nstatus, nstatus);
 		pr_cont("\n");
-		nv_error(priv,
+		nv_error(gr,
 			 "ch %d [0x%08x %s] subc %d class 0x%04x mthd 0x%04x data 0x%08x\n",
 			 chid, inst << 4, nvkm_client_name(engctx), subc,
 			 class, mthd, data);
@@ -341,24 +339,24 @@ nv40_gr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	     struct nvkm_oclass *oclass, void *data, u32 size,
 	     struct nvkm_object **pobject)
 {
-	struct nv40_gr_priv *priv;
+	struct nv40_gr *gr;
 	int ret;
 
-	ret = nvkm_gr_create(parent, engine, oclass, true, &priv);
-	*pobject = nv_object(priv);
+	ret = nvkm_gr_create(parent, engine, oclass, true, &gr);
+	*pobject = nv_object(gr);
 	if (ret)
 		return ret;
 
-	nv_subdev(priv)->unit = 0x00001000;
-	nv_subdev(priv)->intr = nv40_gr_intr;
-	nv_engine(priv)->cclass = &nv40_gr_cclass;
-	if (nv44_gr_class(priv))
-		nv_engine(priv)->sclass = nv44_gr_sclass;
+	nv_subdev(gr)->unit = 0x00001000;
+	nv_subdev(gr)->intr = nv40_gr_intr;
+	nv_engine(gr)->cclass = &nv40_gr_cclass;
+	if (nv44_gr_class(gr))
+		nv_engine(gr)->sclass = nv44_gr_sclass;
 	else
-		nv_engine(priv)->sclass = nv40_gr_sclass;
-	nv_engine(priv)->tile_prog = nv40_gr_tile_prog;
+		nv_engine(gr)->sclass = nv40_gr_sclass;
+	nv_engine(gr)->tile_prog = nv40_gr_tile_prog;
 
-	priv->base.units = nv40_gr_units;
+	gr->base.units = nv40_gr_units;
 	return 0;
 }
 
@@ -367,103 +365,103 @@ nv40_gr_init(struct nvkm_object *object)
 {
 	struct nvkm_engine *engine = nv_engine(object);
 	struct nvkm_fb *fb = nvkm_fb(object);
-	struct nv40_gr_priv *priv = (void *)engine;
+	struct nv40_gr *gr = (void *)engine;
 	int ret, i, j;
 	u32 vramsz;
 
-	ret = nvkm_gr_init(&priv->base);
+	ret = nvkm_gr_init(&gr->base);
 	if (ret)
 		return ret;
 
 	/* generate and upload context program */
-	ret = nv40_grctx_init(nv_device(priv), &priv->size);
+	ret = nv40_grctx_init(nv_device(gr), &gr->size);
 	if (ret)
 		return ret;
 
 	/* No context present currently */
-	nv_wr32(priv, NV40_PGRAPH_CTXCTL_CUR, 0x00000000);
+	nv_wr32(gr, NV40_PGRAPH_CTXCTL_CUR, 0x00000000);
 
-	nv_wr32(priv, NV03_PGRAPH_INTR   , 0xFFFFFFFF);
-	nv_wr32(priv, NV40_PGRAPH_INTR_EN, 0xFFFFFFFF);
+	nv_wr32(gr, NV03_PGRAPH_INTR   , 0xFFFFFFFF);
+	nv_wr32(gr, NV40_PGRAPH_INTR_EN, 0xFFFFFFFF);
 
-	nv_wr32(priv, NV04_PGRAPH_DEBUG_0, 0xFFFFFFFF);
-	nv_wr32(priv, NV04_PGRAPH_DEBUG_0, 0x00000000);
-	nv_wr32(priv, NV04_PGRAPH_DEBUG_1, 0x401287c0);
-	nv_wr32(priv, NV04_PGRAPH_DEBUG_3, 0xe0de8055);
-	nv_wr32(priv, NV10_PGRAPH_DEBUG_4, 0x00008000);
-	nv_wr32(priv, NV04_PGRAPH_LIMIT_VIOL_PIX, 0x00be3c5f);
+	nv_wr32(gr, NV04_PGRAPH_DEBUG_0, 0xFFFFFFFF);
+	nv_wr32(gr, NV04_PGRAPH_DEBUG_0, 0x00000000);
+	nv_wr32(gr, NV04_PGRAPH_DEBUG_1, 0x401287c0);
+	nv_wr32(gr, NV04_PGRAPH_DEBUG_3, 0xe0de8055);
+	nv_wr32(gr, NV10_PGRAPH_DEBUG_4, 0x00008000);
+	nv_wr32(gr, NV04_PGRAPH_LIMIT_VIOL_PIX, 0x00be3c5f);
 
-	nv_wr32(priv, NV10_PGRAPH_CTX_CONTROL, 0x10010100);
-	nv_wr32(priv, NV10_PGRAPH_STATE      , 0xFFFFFFFF);
+	nv_wr32(gr, NV10_PGRAPH_CTX_CONTROL, 0x10010100);
+	nv_wr32(gr, NV10_PGRAPH_STATE      , 0xFFFFFFFF);
 
-	j = nv_rd32(priv, 0x1540) & 0xff;
+	j = nv_rd32(gr, 0x1540) & 0xff;
 	if (j) {
 		for (i = 0; !(j & 1); j >>= 1, i++)
 			;
-		nv_wr32(priv, 0x405000, i);
+		nv_wr32(gr, 0x405000, i);
 	}
 
-	if (nv_device(priv)->chipset == 0x40) {
-		nv_wr32(priv, 0x4009b0, 0x83280fff);
-		nv_wr32(priv, 0x4009b4, 0x000000a0);
+	if (nv_device(gr)->chipset == 0x40) {
+		nv_wr32(gr, 0x4009b0, 0x83280fff);
+		nv_wr32(gr, 0x4009b4, 0x000000a0);
 	} else {
-		nv_wr32(priv, 0x400820, 0x83280eff);
-		nv_wr32(priv, 0x400824, 0x000000a0);
+		nv_wr32(gr, 0x400820, 0x83280eff);
+		nv_wr32(gr, 0x400824, 0x000000a0);
 	}
 
-	switch (nv_device(priv)->chipset) {
+	switch (nv_device(gr)->chipset) {
 	case 0x40:
 	case 0x45:
-		nv_wr32(priv, 0x4009b8, 0x0078e366);
-		nv_wr32(priv, 0x4009bc, 0x0000014c);
+		nv_wr32(gr, 0x4009b8, 0x0078e366);
+		nv_wr32(gr, 0x4009bc, 0x0000014c);
 		break;
 	case 0x41:
 	case 0x42: /* pciid also 0x00Cx */
 	/* case 0x0120: XXX (pciid) */
-		nv_wr32(priv, 0x400828, 0x007596ff);
-		nv_wr32(priv, 0x40082c, 0x00000108);
+		nv_wr32(gr, 0x400828, 0x007596ff);
+		nv_wr32(gr, 0x40082c, 0x00000108);
 		break;
 	case 0x43:
-		nv_wr32(priv, 0x400828, 0x0072cb77);
-		nv_wr32(priv, 0x40082c, 0x00000108);
+		nv_wr32(gr, 0x400828, 0x0072cb77);
+		nv_wr32(gr, 0x40082c, 0x00000108);
 		break;
 	case 0x44:
 	case 0x46: /* G72 */
 	case 0x4a:
 	case 0x4c: /* G7x-based C51 */
 	case 0x4e:
-		nv_wr32(priv, 0x400860, 0);
-		nv_wr32(priv, 0x400864, 0);
+		nv_wr32(gr, 0x400860, 0);
+		nv_wr32(gr, 0x400864, 0);
 		break;
 	case 0x47: /* G70 */
 	case 0x49: /* G71 */
 	case 0x4b: /* G73 */
-		nv_wr32(priv, 0x400828, 0x07830610);
-		nv_wr32(priv, 0x40082c, 0x0000016A);
+		nv_wr32(gr, 0x400828, 0x07830610);
+		nv_wr32(gr, 0x40082c, 0x0000016A);
 		break;
 	default:
 		break;
 	}
 
-	nv_wr32(priv, 0x400b38, 0x2ffff800);
-	nv_wr32(priv, 0x400b3c, 0x00006000);
+	nv_wr32(gr, 0x400b38, 0x2ffff800);
+	nv_wr32(gr, 0x400b3c, 0x00006000);
 
 	/* Tiling related stuff. */
-	switch (nv_device(priv)->chipset) {
+	switch (nv_device(gr)->chipset) {
 	case 0x44:
 	case 0x4a:
-		nv_wr32(priv, 0x400bc4, 0x1003d888);
-		nv_wr32(priv, 0x400bbc, 0xb7a7b500);
+		nv_wr32(gr, 0x400bc4, 0x1003d888);
+		nv_wr32(gr, 0x400bbc, 0xb7a7b500);
 		break;
 	case 0x46:
-		nv_wr32(priv, 0x400bc4, 0x0000e024);
-		nv_wr32(priv, 0x400bbc, 0xb7a7b520);
+		nv_wr32(gr, 0x400bc4, 0x0000e024);
+		nv_wr32(gr, 0x400bbc, 0xb7a7b520);
 		break;
 	case 0x4c:
 	case 0x4e:
 	case 0x67:
-		nv_wr32(priv, 0x400bc4, 0x1003d888);
-		nv_wr32(priv, 0x400bbc, 0xb7a7b540);
+		nv_wr32(gr, 0x400bc4, 0x1003d888);
+		nv_wr32(gr, 0x400bbc, 0xb7a7b540);
 		break;
 	default:
 		break;
@@ -474,20 +472,20 @@ nv40_gr_init(struct nvkm_object *object)
 		engine->tile_prog(engine, i);
 
 	/* begin RAM config */
-	vramsz = nv_device_resource_len(nv_device(priv), 0) - 1;
-	switch (nv_device(priv)->chipset) {
+	vramsz = nv_device_resource_len(nv_device(gr), 1) - 1;
+	switch (nv_device(gr)->chipset) {
 	case 0x40:
-		nv_wr32(priv, 0x4009A4, nv_rd32(priv, 0x100200));
-		nv_wr32(priv, 0x4009A8, nv_rd32(priv, 0x100204));
-		nv_wr32(priv, 0x4069A4, nv_rd32(priv, 0x100200));
-		nv_wr32(priv, 0x4069A8, nv_rd32(priv, 0x100204));
-		nv_wr32(priv, 0x400820, 0);
-		nv_wr32(priv, 0x400824, 0);
-		nv_wr32(priv, 0x400864, vramsz);
-		nv_wr32(priv, 0x400868, vramsz);
+		nv_wr32(gr, 0x4009A4, nv_rd32(gr, 0x100200));
+		nv_wr32(gr, 0x4009A8, nv_rd32(gr, 0x100204));
+		nv_wr32(gr, 0x4069A4, nv_rd32(gr, 0x100200));
+		nv_wr32(gr, 0x4069A8, nv_rd32(gr, 0x100204));
+		nv_wr32(gr, 0x400820, 0);
+		nv_wr32(gr, 0x400824, 0);
+		nv_wr32(gr, 0x400864, vramsz);
+		nv_wr32(gr, 0x400868, vramsz);
 		break;
 	default:
-		switch (nv_device(priv)->chipset) {
+		switch (nv_device(gr)->chipset) {
 		case 0x41:
 		case 0x42:
 		case 0x43:
@@ -495,20 +493,20 @@ nv40_gr_init(struct nvkm_object *object)
 		case 0x4e:
 		case 0x44:
 		case 0x4a:
-			nv_wr32(priv, 0x4009F0, nv_rd32(priv, 0x100200));
-			nv_wr32(priv, 0x4009F4, nv_rd32(priv, 0x100204));
+			nv_wr32(gr, 0x4009F0, nv_rd32(gr, 0x100200));
+			nv_wr32(gr, 0x4009F4, nv_rd32(gr, 0x100204));
 			break;
 		default:
-			nv_wr32(priv, 0x400DF0, nv_rd32(priv, 0x100200));
-			nv_wr32(priv, 0x400DF4, nv_rd32(priv, 0x100204));
+			nv_wr32(gr, 0x400DF0, nv_rd32(gr, 0x100200));
+			nv_wr32(gr, 0x400DF4, nv_rd32(gr, 0x100204));
 			break;
 		}
-		nv_wr32(priv, 0x4069F0, nv_rd32(priv, 0x100200));
-		nv_wr32(priv, 0x4069F4, nv_rd32(priv, 0x100204));
-		nv_wr32(priv, 0x400840, 0);
-		nv_wr32(priv, 0x400844, 0);
-		nv_wr32(priv, 0x4008A0, vramsz);
-		nv_wr32(priv, 0x4008A4, vramsz);
+		nv_wr32(gr, 0x4069F0, nv_rd32(gr, 0x100200));
+		nv_wr32(gr, 0x4069F4, nv_rd32(gr, 0x100204));
+		nv_wr32(gr, 0x400840, 0);
+		nv_wr32(gr, 0x400844, 0);
+		nv_wr32(gr, 0x4008A0, vramsz);
+		nv_wr32(gr, 0x4008A4, vramsz);
 		break;
 	}
 

commit 6189f1b0938dc0621c27494031b83ffae566e318
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/fifo: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index ed05c6d7875b..c0a1751a1e88 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -206,11 +206,11 @@ static void
 nv40_gr_tile_prog(struct nvkm_engine *engine, int i)
 {
 	struct nvkm_fb_tile *tile = &nvkm_fb(engine)->tile.region[i];
-	struct nvkm_fifo *pfifo = nvkm_fifo(engine);
+	struct nvkm_fifo *fifo = nvkm_fifo(engine);
 	struct nv40_gr_priv *priv = (void *)engine;
 	unsigned long flags;
 
-	pfifo->pause(pfifo, &flags);
+	fifo->pause(fifo, &flags);
 	nv04_gr_idle(priv);
 
 	switch (nv_device(priv)->chipset) {
@@ -277,13 +277,13 @@ nv40_gr_tile_prog(struct nvkm_engine *engine, int i)
 		break;
 	}
 
-	pfifo->start(pfifo, &flags);
+	fifo->start(fifo, &flags);
 }
 
 static void
 nv40_gr_intr(struct nvkm_subdev *subdev)
 {
-	struct nvkm_fifo *pfifo = nvkm_fifo(subdev);
+	struct nvkm_fifo *fifo = nvkm_fifo(subdev);
 	struct nvkm_engine *engine = nv_engine(subdev);
 	struct nvkm_object *engctx;
 	struct nvkm_handle *handle = NULL;
@@ -301,7 +301,7 @@ nv40_gr_intr(struct nvkm_subdev *subdev)
 	int chid;
 
 	engctx = nvkm_engctx_get(engine, inst);
-	chid   = pfifo->chid(pfifo, engctx);
+	chid   = fifo->chid(fifo, engctx);
 
 	if (stat & NV_PGRAPH_INTR_ERROR) {
 		if (nsource & NV03_PGRAPH_NSOURCE_ILLEGAL_MTHD) {

commit b1e4553cb1f9deddbd8c13d95e9cef81967a3f41
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/fb: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index 7e1937980e3f..ed05c6d7875b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -366,7 +366,7 @@ static int
 nv40_gr_init(struct nvkm_object *object)
 {
 	struct nvkm_engine *engine = nv_engine(object);
-	struct nvkm_fb *pfb = nvkm_fb(object);
+	struct nvkm_fb *fb = nvkm_fb(object);
 	struct nv40_gr_priv *priv = (void *)engine;
 	int ret, i, j;
 	u32 vramsz;
@@ -470,7 +470,7 @@ nv40_gr_init(struct nvkm_object *object)
 	}
 
 	/* Turn all the tiling regions off. */
-	for (i = 0; i < pfb->tile.regions; i++)
+	for (i = 0; i < fb->tile.regions; i++)
 		engine->tile_prog(engine, i);
 
 	/* begin RAM config */

commit e3c71eb27419b600dcacea9f268254369e6550c4
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:29:43 2015 +1000

    drm/nouveau/gr: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
index 6fadd830bc25..7e1937980e3f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -21,32 +21,26 @@
  *
  * Authors: Ben Skeggs
  */
+#include "nv40.h"
+#include "regs.h"
 
 #include <core/client.h>
-#include <core/os.h>
 #include <core/handle.h>
-#include <core/engctx.h>
-
 #include <subdev/fb.h>
 #include <subdev/timer.h>
-
-#include <engine/gr.h>
 #include <engine/fifo.h>
 
-#include "nv40.h"
-#include "regs.h"
-
 struct nv40_gr_priv {
-	struct nouveau_gr base;
+	struct nvkm_gr base;
 	u32 size;
 };
 
 struct nv40_gr_chan {
-	struct nouveau_gr_chan base;
+	struct nvkm_gr_chan base;
 };
 
 static u64
-nv40_gr_units(struct nouveau_gr *gr)
+nv40_gr_units(struct nvkm_gr *gr)
 {
 	struct nv40_gr_priv *priv = (void *)gr;
 
@@ -58,16 +52,15 @@ nv40_gr_units(struct nouveau_gr *gr)
  ******************************************************************************/
 
 static int
-nv40_gr_object_ctor(struct nouveau_object *parent,
-		       struct nouveau_object *engine,
-		       struct nouveau_oclass *oclass, void *data, u32 size,
-		       struct nouveau_object **pobject)
+nv40_gr_object_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+		    struct nvkm_oclass *oclass, void *data, u32 size,
+		    struct nvkm_object **pobject)
 {
-	struct nouveau_gpuobj *obj;
+	struct nvkm_gpuobj *obj;
 	int ret;
 
-	ret = nouveau_gpuobj_create(parent, engine, oclass, 0, parent,
-				    20, 16, 0, &obj);
+	ret = nvkm_gpuobj_create(parent, engine, oclass, 0, parent,
+				 20, 16, 0, &obj);
 	*pobject = nv_object(obj);
 	if (ret)
 		return ret;
@@ -83,17 +76,17 @@ nv40_gr_object_ctor(struct nouveau_object *parent,
 	return 0;
 }
 
-static struct nouveau_ofuncs
+static struct nvkm_ofuncs
 nv40_gr_ofuncs = {
 	.ctor = nv40_gr_object_ctor,
-	.dtor = _nouveau_gpuobj_dtor,
-	.init = _nouveau_gpuobj_init,
-	.fini = _nouveau_gpuobj_fini,
-	.rd32 = _nouveau_gpuobj_rd32,
-	.wr32 = _nouveau_gpuobj_wr32,
+	.dtor = _nvkm_gpuobj_dtor,
+	.init = _nvkm_gpuobj_init,
+	.fini = _nvkm_gpuobj_fini,
+	.rd32 = _nvkm_gpuobj_rd32,
+	.wr32 = _nvkm_gpuobj_wr32,
 };
 
-static struct nouveau_oclass
+static struct nvkm_oclass
 nv40_gr_sclass[] = {
 	{ 0x0012, &nv40_gr_ofuncs, NULL }, /* beta1 */
 	{ 0x0019, &nv40_gr_ofuncs, NULL }, /* clip */
@@ -114,7 +107,7 @@ nv40_gr_sclass[] = {
 	{},
 };
 
-static struct nouveau_oclass
+static struct nvkm_oclass
 nv44_gr_sclass[] = {
 	{ 0x0012, &nv40_gr_ofuncs, NULL }, /* beta1 */
 	{ 0x0019, &nv40_gr_ofuncs, NULL }, /* clip */
@@ -140,18 +133,16 @@ nv44_gr_sclass[] = {
  ******************************************************************************/
 
 static int
-nv40_gr_context_ctor(struct nouveau_object *parent,
-			struct nouveau_object *engine,
-			struct nouveau_oclass *oclass, void *data, u32 size,
-			struct nouveau_object **pobject)
+nv40_gr_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+		     struct nvkm_oclass *oclass, void *data, u32 size,
+		     struct nvkm_object **pobject)
 {
 	struct nv40_gr_priv *priv = (void *)engine;
 	struct nv40_gr_chan *chan;
 	int ret;
 
-	ret = nouveau_gr_context_create(parent, engine, oclass, NULL,
-					   priv->size, 16,
-					   NVOBJ_FLAG_ZERO_ALLOC, &chan);
+	ret = nvkm_gr_context_create(parent, engine, oclass, NULL, priv->size,
+				     16, NVOBJ_FLAG_ZERO_ALLOC, &chan);
 	*pobject = nv_object(chan);
 	if (ret)
 		return ret;
@@ -162,7 +153,7 @@ nv40_gr_context_ctor(struct nouveau_object *parent,
 }
 
 static int
-nv40_gr_context_fini(struct nouveau_object *object, bool suspend)
+nv40_gr_context_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nv40_gr_priv *priv = (void *)object->engine;
 	struct nv40_gr_chan *chan = (void *)object;
@@ -194,16 +185,16 @@ nv40_gr_context_fini(struct nouveau_object *object, bool suspend)
 	return ret;
 }
 
-static struct nouveau_oclass
+static struct nvkm_oclass
 nv40_gr_cclass = {
 	.handle = NV_ENGCTX(GR, 0x40),
-	.ofuncs = &(struct nouveau_ofuncs) {
+	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv40_gr_context_ctor,
-		.dtor = _nouveau_gr_context_dtor,
-		.init = _nouveau_gr_context_init,
+		.dtor = _nvkm_gr_context_dtor,
+		.init = _nvkm_gr_context_init,
 		.fini = nv40_gr_context_fini,
-		.rd32 = _nouveau_gr_context_rd32,
-		.wr32 = _nouveau_gr_context_wr32,
+		.rd32 = _nvkm_gr_context_rd32,
+		.wr32 = _nvkm_gr_context_wr32,
 	},
 };
 
@@ -212,10 +203,10 @@ nv40_gr_cclass = {
  ******************************************************************************/
 
 static void
-nv40_gr_tile_prog(struct nouveau_engine *engine, int i)
+nv40_gr_tile_prog(struct nvkm_engine *engine, int i)
 {
-	struct nouveau_fb_tile *tile = &nouveau_fb(engine)->tile.region[i];
-	struct nouveau_fifo *pfifo = nouveau_fifo(engine);
+	struct nvkm_fb_tile *tile = &nvkm_fb(engine)->tile.region[i];
+	struct nvkm_fifo *pfifo = nvkm_fifo(engine);
 	struct nv40_gr_priv *priv = (void *)engine;
 	unsigned long flags;
 
@@ -290,12 +281,12 @@ nv40_gr_tile_prog(struct nouveau_engine *engine, int i)
 }
 
 static void
-nv40_gr_intr(struct nouveau_subdev *subdev)
+nv40_gr_intr(struct nvkm_subdev *subdev)
 {
-	struct nouveau_fifo *pfifo = nouveau_fifo(subdev);
-	struct nouveau_engine *engine = nv_engine(subdev);
-	struct nouveau_object *engctx;
-	struct nouveau_handle *handle = NULL;
+	struct nvkm_fifo *pfifo = nvkm_fifo(subdev);
+	struct nvkm_engine *engine = nv_engine(subdev);
+	struct nvkm_object *engctx;
+	struct nvkm_handle *handle = NULL;
 	struct nv40_gr_priv *priv = (void *)subdev;
 	u32 stat = nv_rd32(priv, NV03_PGRAPH_INTR);
 	u32 nsource = nv_rd32(priv, NV03_PGRAPH_NSOURCE);
@@ -309,15 +300,15 @@ nv40_gr_intr(struct nouveau_subdev *subdev)
 	u32 show = stat;
 	int chid;
 
-	engctx = nouveau_engctx_get(engine, inst);
+	engctx = nvkm_engctx_get(engine, inst);
 	chid   = pfifo->chid(pfifo, engctx);
 
 	if (stat & NV_PGRAPH_INTR_ERROR) {
 		if (nsource & NV03_PGRAPH_NSOURCE_ILLEGAL_MTHD) {
-			handle = nouveau_handle_get_class(engctx, class);
+			handle = nvkm_handle_get_class(engctx, class);
 			if (handle && !nv_call(handle->object, mthd, data))
 				show &= ~NV_PGRAPH_INTR_ERROR;
-			nouveau_handle_put(handle);
+			nvkm_handle_put(handle);
 		}
 
 		if (nsource & NV03_PGRAPH_NSOURCE_DMA_VTX_PROTECTION) {
@@ -330,30 +321,30 @@ nv40_gr_intr(struct nouveau_subdev *subdev)
 
 	if (show) {
 		nv_error(priv, "%s", "");
-		nouveau_bitfield_print(nv10_gr_intr_name, show);
+		nvkm_bitfield_print(nv10_gr_intr_name, show);
 		pr_cont(" nsource:");
-		nouveau_bitfield_print(nv04_gr_nsource, nsource);
+		nvkm_bitfield_print(nv04_gr_nsource, nsource);
 		pr_cont(" nstatus:");
-		nouveau_bitfield_print(nv10_gr_nstatus, nstatus);
+		nvkm_bitfield_print(nv10_gr_nstatus, nstatus);
 		pr_cont("\n");
 		nv_error(priv,
 			 "ch %d [0x%08x %s] subc %d class 0x%04x mthd 0x%04x data 0x%08x\n",
-			 chid, inst << 4, nouveau_client_name(engctx), subc,
+			 chid, inst << 4, nvkm_client_name(engctx), subc,
 			 class, mthd, data);
 	}
 
-	nouveau_engctx_put(engctx);
+	nvkm_engctx_put(engctx);
 }
 
 static int
-nv40_gr_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
-	       struct nouveau_oclass *oclass, void *data, u32 size,
-	       struct nouveau_object **pobject)
+nv40_gr_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+	     struct nvkm_oclass *oclass, void *data, u32 size,
+	     struct nvkm_object **pobject)
 {
 	struct nv40_gr_priv *priv;
 	int ret;
 
-	ret = nouveau_gr_create(parent, engine, oclass, true, &priv);
+	ret = nvkm_gr_create(parent, engine, oclass, true, &priv);
 	*pobject = nv_object(priv);
 	if (ret)
 		return ret;
@@ -372,15 +363,15 @@ nv40_gr_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 }
 
 static int
-nv40_gr_init(struct nouveau_object *object)
+nv40_gr_init(struct nvkm_object *object)
 {
-	struct nouveau_engine *engine = nv_engine(object);
-	struct nouveau_fb *pfb = nouveau_fb(object);
+	struct nvkm_engine *engine = nv_engine(object);
+	struct nvkm_fb *pfb = nvkm_fb(object);
 	struct nv40_gr_priv *priv = (void *)engine;
 	int ret, i, j;
 	u32 vramsz;
 
-	ret = nouveau_gr_init(&priv->base);
+	ret = nvkm_gr_init(&priv->base);
 	if (ret)
 		return ret;
 
@@ -524,13 +515,13 @@ nv40_gr_init(struct nouveau_object *object)
 	return 0;
 }
 
-struct nouveau_oclass
+struct nvkm_oclass
 nv40_gr_oclass = {
 	.handle = NV_ENGINE(GR, 0x40),
-	.ofuncs = &(struct nouveau_ofuncs) {
+	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv40_gr_ctor,
-		.dtor = _nouveau_gr_dtor,
+		.dtor = _nvkm_gr_dtor,
 		.init = nv40_gr_init,
-		.fini = _nouveau_gr_fini,
+		.fini = _nvkm_gr_fini,
 	},
 };

commit b8bf04e1fd3aba5cdd81ec766fc0372c7894497c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 12:02:28 2015 +1000

    drm/nouveau/gr: rename from graph (no binary change)
    
    Shorter device name, match Tegra and our existing enums.
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
new file mode 100644
index 000000000000..6fadd830bc25
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c
@@ -0,0 +1,536 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <core/client.h>
+#include <core/os.h>
+#include <core/handle.h>
+#include <core/engctx.h>
+
+#include <subdev/fb.h>
+#include <subdev/timer.h>
+
+#include <engine/gr.h>
+#include <engine/fifo.h>
+
+#include "nv40.h"
+#include "regs.h"
+
+struct nv40_gr_priv {
+	struct nouveau_gr base;
+	u32 size;
+};
+
+struct nv40_gr_chan {
+	struct nouveau_gr_chan base;
+};
+
+static u64
+nv40_gr_units(struct nouveau_gr *gr)
+{
+	struct nv40_gr_priv *priv = (void *)gr;
+
+	return nv_rd32(priv, 0x1540);
+}
+
+/*******************************************************************************
+ * Graphics object classes
+ ******************************************************************************/
+
+static int
+nv40_gr_object_ctor(struct nouveau_object *parent,
+		       struct nouveau_object *engine,
+		       struct nouveau_oclass *oclass, void *data, u32 size,
+		       struct nouveau_object **pobject)
+{
+	struct nouveau_gpuobj *obj;
+	int ret;
+
+	ret = nouveau_gpuobj_create(parent, engine, oclass, 0, parent,
+				    20, 16, 0, &obj);
+	*pobject = nv_object(obj);
+	if (ret)
+		return ret;
+
+	nv_wo32(obj, 0x00, nv_mclass(obj));
+	nv_wo32(obj, 0x04, 0x00000000);
+	nv_wo32(obj, 0x08, 0x00000000);
+#ifdef __BIG_ENDIAN
+	nv_mo32(obj, 0x08, 0x01000000, 0x01000000);
+#endif
+	nv_wo32(obj, 0x0c, 0x00000000);
+	nv_wo32(obj, 0x10, 0x00000000);
+	return 0;
+}
+
+static struct nouveau_ofuncs
+nv40_gr_ofuncs = {
+	.ctor = nv40_gr_object_ctor,
+	.dtor = _nouveau_gpuobj_dtor,
+	.init = _nouveau_gpuobj_init,
+	.fini = _nouveau_gpuobj_fini,
+	.rd32 = _nouveau_gpuobj_rd32,
+	.wr32 = _nouveau_gpuobj_wr32,
+};
+
+static struct nouveau_oclass
+nv40_gr_sclass[] = {
+	{ 0x0012, &nv40_gr_ofuncs, NULL }, /* beta1 */
+	{ 0x0019, &nv40_gr_ofuncs, NULL }, /* clip */
+	{ 0x0030, &nv40_gr_ofuncs, NULL }, /* null */
+	{ 0x0039, &nv40_gr_ofuncs, NULL }, /* m2mf */
+	{ 0x0043, &nv40_gr_ofuncs, NULL }, /* rop */
+	{ 0x0044, &nv40_gr_ofuncs, NULL }, /* patt */
+	{ 0x004a, &nv40_gr_ofuncs, NULL }, /* gdi */
+	{ 0x0062, &nv40_gr_ofuncs, NULL }, /* surf2d */
+	{ 0x0072, &nv40_gr_ofuncs, NULL }, /* beta4 */
+	{ 0x0089, &nv40_gr_ofuncs, NULL }, /* sifm */
+	{ 0x008a, &nv40_gr_ofuncs, NULL }, /* ifc */
+	{ 0x009f, &nv40_gr_ofuncs, NULL }, /* imageblit */
+	{ 0x3062, &nv40_gr_ofuncs, NULL }, /* surf2d (nv40) */
+	{ 0x3089, &nv40_gr_ofuncs, NULL }, /* sifm (nv40) */
+	{ 0x309e, &nv40_gr_ofuncs, NULL }, /* swzsurf (nv40) */
+	{ 0x4097, &nv40_gr_ofuncs, NULL }, /* curie */
+	{},
+};
+
+static struct nouveau_oclass
+nv44_gr_sclass[] = {
+	{ 0x0012, &nv40_gr_ofuncs, NULL }, /* beta1 */
+	{ 0x0019, &nv40_gr_ofuncs, NULL }, /* clip */
+	{ 0x0030, &nv40_gr_ofuncs, NULL }, /* null */
+	{ 0x0039, &nv40_gr_ofuncs, NULL }, /* m2mf */
+	{ 0x0043, &nv40_gr_ofuncs, NULL }, /* rop */
+	{ 0x0044, &nv40_gr_ofuncs, NULL }, /* patt */
+	{ 0x004a, &nv40_gr_ofuncs, NULL }, /* gdi */
+	{ 0x0062, &nv40_gr_ofuncs, NULL }, /* surf2d */
+	{ 0x0072, &nv40_gr_ofuncs, NULL }, /* beta4 */
+	{ 0x0089, &nv40_gr_ofuncs, NULL }, /* sifm */
+	{ 0x008a, &nv40_gr_ofuncs, NULL }, /* ifc */
+	{ 0x009f, &nv40_gr_ofuncs, NULL }, /* imageblit */
+	{ 0x3062, &nv40_gr_ofuncs, NULL }, /* surf2d (nv40) */
+	{ 0x3089, &nv40_gr_ofuncs, NULL }, /* sifm (nv40) */
+	{ 0x309e, &nv40_gr_ofuncs, NULL }, /* swzsurf (nv40) */
+	{ 0x4497, &nv40_gr_ofuncs, NULL }, /* curie */
+	{},
+};
+
+/*******************************************************************************
+ * PGRAPH context
+ ******************************************************************************/
+
+static int
+nv40_gr_context_ctor(struct nouveau_object *parent,
+			struct nouveau_object *engine,
+			struct nouveau_oclass *oclass, void *data, u32 size,
+			struct nouveau_object **pobject)
+{
+	struct nv40_gr_priv *priv = (void *)engine;
+	struct nv40_gr_chan *chan;
+	int ret;
+
+	ret = nouveau_gr_context_create(parent, engine, oclass, NULL,
+					   priv->size, 16,
+					   NVOBJ_FLAG_ZERO_ALLOC, &chan);
+	*pobject = nv_object(chan);
+	if (ret)
+		return ret;
+
+	nv40_grctx_fill(nv_device(priv), nv_gpuobj(chan));
+	nv_wo32(chan, 0x00000, nv_gpuobj(chan)->addr >> 4);
+	return 0;
+}
+
+static int
+nv40_gr_context_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nv40_gr_priv *priv = (void *)object->engine;
+	struct nv40_gr_chan *chan = (void *)object;
+	u32 inst = 0x01000000 | nv_gpuobj(chan)->addr >> 4;
+	int ret = 0;
+
+	nv_mask(priv, 0x400720, 0x00000001, 0x00000000);
+
+	if (nv_rd32(priv, 0x40032c) == inst) {
+		if (suspend) {
+			nv_wr32(priv, 0x400720, 0x00000000);
+			nv_wr32(priv, 0x400784, inst);
+			nv_mask(priv, 0x400310, 0x00000020, 0x00000020);
+			nv_mask(priv, 0x400304, 0x00000001, 0x00000001);
+			if (!nv_wait(priv, 0x400300, 0x00000001, 0x00000000)) {
+				u32 insn = nv_rd32(priv, 0x400308);
+				nv_warn(priv, "ctxprog timeout 0x%08x\n", insn);
+				ret = -EBUSY;
+			}
+		}
+
+		nv_mask(priv, 0x40032c, 0x01000000, 0x00000000);
+	}
+
+	if (nv_rd32(priv, 0x400330) == inst)
+		nv_mask(priv, 0x400330, 0x01000000, 0x00000000);
+
+	nv_mask(priv, 0x400720, 0x00000001, 0x00000001);
+	return ret;
+}
+
+static struct nouveau_oclass
+nv40_gr_cclass = {
+	.handle = NV_ENGCTX(GR, 0x40),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv40_gr_context_ctor,
+		.dtor = _nouveau_gr_context_dtor,
+		.init = _nouveau_gr_context_init,
+		.fini = nv40_gr_context_fini,
+		.rd32 = _nouveau_gr_context_rd32,
+		.wr32 = _nouveau_gr_context_wr32,
+	},
+};
+
+/*******************************************************************************
+ * PGRAPH engine/subdev functions
+ ******************************************************************************/
+
+static void
+nv40_gr_tile_prog(struct nouveau_engine *engine, int i)
+{
+	struct nouveau_fb_tile *tile = &nouveau_fb(engine)->tile.region[i];
+	struct nouveau_fifo *pfifo = nouveau_fifo(engine);
+	struct nv40_gr_priv *priv = (void *)engine;
+	unsigned long flags;
+
+	pfifo->pause(pfifo, &flags);
+	nv04_gr_idle(priv);
+
+	switch (nv_device(priv)->chipset) {
+	case 0x40:
+	case 0x41:
+	case 0x42:
+	case 0x43:
+	case 0x45:
+	case 0x4e:
+		nv_wr32(priv, NV20_PGRAPH_TSIZE(i), tile->pitch);
+		nv_wr32(priv, NV20_PGRAPH_TLIMIT(i), tile->limit);
+		nv_wr32(priv, NV20_PGRAPH_TILE(i), tile->addr);
+		nv_wr32(priv, NV40_PGRAPH_TSIZE1(i), tile->pitch);
+		nv_wr32(priv, NV40_PGRAPH_TLIMIT1(i), tile->limit);
+		nv_wr32(priv, NV40_PGRAPH_TILE1(i), tile->addr);
+		switch (nv_device(priv)->chipset) {
+		case 0x40:
+		case 0x45:
+			nv_wr32(priv, NV20_PGRAPH_ZCOMP(i), tile->zcomp);
+			nv_wr32(priv, NV40_PGRAPH_ZCOMP1(i), tile->zcomp);
+			break;
+		case 0x41:
+		case 0x42:
+		case 0x43:
+			nv_wr32(priv, NV41_PGRAPH_ZCOMP0(i), tile->zcomp);
+			nv_wr32(priv, NV41_PGRAPH_ZCOMP1(i), tile->zcomp);
+			break;
+		default:
+			break;
+		}
+		break;
+	case 0x44:
+	case 0x4a:
+		nv_wr32(priv, NV20_PGRAPH_TSIZE(i), tile->pitch);
+		nv_wr32(priv, NV20_PGRAPH_TLIMIT(i), tile->limit);
+		nv_wr32(priv, NV20_PGRAPH_TILE(i), tile->addr);
+		break;
+	case 0x46:
+	case 0x4c:
+	case 0x47:
+	case 0x49:
+	case 0x4b:
+	case 0x63:
+	case 0x67:
+	case 0x68:
+		nv_wr32(priv, NV47_PGRAPH_TSIZE(i), tile->pitch);
+		nv_wr32(priv, NV47_PGRAPH_TLIMIT(i), tile->limit);
+		nv_wr32(priv, NV47_PGRAPH_TILE(i), tile->addr);
+		nv_wr32(priv, NV40_PGRAPH_TSIZE1(i), tile->pitch);
+		nv_wr32(priv, NV40_PGRAPH_TLIMIT1(i), tile->limit);
+		nv_wr32(priv, NV40_PGRAPH_TILE1(i), tile->addr);
+		switch (nv_device(priv)->chipset) {
+		case 0x47:
+		case 0x49:
+		case 0x4b:
+			nv_wr32(priv, NV47_PGRAPH_ZCOMP0(i), tile->zcomp);
+			nv_wr32(priv, NV47_PGRAPH_ZCOMP1(i), tile->zcomp);
+			break;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+
+	pfifo->start(pfifo, &flags);
+}
+
+static void
+nv40_gr_intr(struct nouveau_subdev *subdev)
+{
+	struct nouveau_fifo *pfifo = nouveau_fifo(subdev);
+	struct nouveau_engine *engine = nv_engine(subdev);
+	struct nouveau_object *engctx;
+	struct nouveau_handle *handle = NULL;
+	struct nv40_gr_priv *priv = (void *)subdev;
+	u32 stat = nv_rd32(priv, NV03_PGRAPH_INTR);
+	u32 nsource = nv_rd32(priv, NV03_PGRAPH_NSOURCE);
+	u32 nstatus = nv_rd32(priv, NV03_PGRAPH_NSTATUS);
+	u32 inst = nv_rd32(priv, 0x40032c) & 0x000fffff;
+	u32 addr = nv_rd32(priv, NV04_PGRAPH_TRAPPED_ADDR);
+	u32 subc = (addr & 0x00070000) >> 16;
+	u32 mthd = (addr & 0x00001ffc);
+	u32 data = nv_rd32(priv, NV04_PGRAPH_TRAPPED_DATA);
+	u32 class = nv_rd32(priv, 0x400160 + subc * 4) & 0xffff;
+	u32 show = stat;
+	int chid;
+
+	engctx = nouveau_engctx_get(engine, inst);
+	chid   = pfifo->chid(pfifo, engctx);
+
+	if (stat & NV_PGRAPH_INTR_ERROR) {
+		if (nsource & NV03_PGRAPH_NSOURCE_ILLEGAL_MTHD) {
+			handle = nouveau_handle_get_class(engctx, class);
+			if (handle && !nv_call(handle->object, mthd, data))
+				show &= ~NV_PGRAPH_INTR_ERROR;
+			nouveau_handle_put(handle);
+		}
+
+		if (nsource & NV03_PGRAPH_NSOURCE_DMA_VTX_PROTECTION) {
+			nv_mask(priv, 0x402000, 0, 0);
+		}
+	}
+
+	nv_wr32(priv, NV03_PGRAPH_INTR, stat);
+	nv_wr32(priv, NV04_PGRAPH_FIFO, 0x00000001);
+
+	if (show) {
+		nv_error(priv, "%s", "");
+		nouveau_bitfield_print(nv10_gr_intr_name, show);
+		pr_cont(" nsource:");
+		nouveau_bitfield_print(nv04_gr_nsource, nsource);
+		pr_cont(" nstatus:");
+		nouveau_bitfield_print(nv10_gr_nstatus, nstatus);
+		pr_cont("\n");
+		nv_error(priv,
+			 "ch %d [0x%08x %s] subc %d class 0x%04x mthd 0x%04x data 0x%08x\n",
+			 chid, inst << 4, nouveau_client_name(engctx), subc,
+			 class, mthd, data);
+	}
+
+	nouveau_engctx_put(engctx);
+}
+
+static int
+nv40_gr_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+	       struct nouveau_oclass *oclass, void *data, u32 size,
+	       struct nouveau_object **pobject)
+{
+	struct nv40_gr_priv *priv;
+	int ret;
+
+	ret = nouveau_gr_create(parent, engine, oclass, true, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	nv_subdev(priv)->unit = 0x00001000;
+	nv_subdev(priv)->intr = nv40_gr_intr;
+	nv_engine(priv)->cclass = &nv40_gr_cclass;
+	if (nv44_gr_class(priv))
+		nv_engine(priv)->sclass = nv44_gr_sclass;
+	else
+		nv_engine(priv)->sclass = nv40_gr_sclass;
+	nv_engine(priv)->tile_prog = nv40_gr_tile_prog;
+
+	priv->base.units = nv40_gr_units;
+	return 0;
+}
+
+static int
+nv40_gr_init(struct nouveau_object *object)
+{
+	struct nouveau_engine *engine = nv_engine(object);
+	struct nouveau_fb *pfb = nouveau_fb(object);
+	struct nv40_gr_priv *priv = (void *)engine;
+	int ret, i, j;
+	u32 vramsz;
+
+	ret = nouveau_gr_init(&priv->base);
+	if (ret)
+		return ret;
+
+	/* generate and upload context program */
+	ret = nv40_grctx_init(nv_device(priv), &priv->size);
+	if (ret)
+		return ret;
+
+	/* No context present currently */
+	nv_wr32(priv, NV40_PGRAPH_CTXCTL_CUR, 0x00000000);
+
+	nv_wr32(priv, NV03_PGRAPH_INTR   , 0xFFFFFFFF);
+	nv_wr32(priv, NV40_PGRAPH_INTR_EN, 0xFFFFFFFF);
+
+	nv_wr32(priv, NV04_PGRAPH_DEBUG_0, 0xFFFFFFFF);
+	nv_wr32(priv, NV04_PGRAPH_DEBUG_0, 0x00000000);
+	nv_wr32(priv, NV04_PGRAPH_DEBUG_1, 0x401287c0);
+	nv_wr32(priv, NV04_PGRAPH_DEBUG_3, 0xe0de8055);
+	nv_wr32(priv, NV10_PGRAPH_DEBUG_4, 0x00008000);
+	nv_wr32(priv, NV04_PGRAPH_LIMIT_VIOL_PIX, 0x00be3c5f);
+
+	nv_wr32(priv, NV10_PGRAPH_CTX_CONTROL, 0x10010100);
+	nv_wr32(priv, NV10_PGRAPH_STATE      , 0xFFFFFFFF);
+
+	j = nv_rd32(priv, 0x1540) & 0xff;
+	if (j) {
+		for (i = 0; !(j & 1); j >>= 1, i++)
+			;
+		nv_wr32(priv, 0x405000, i);
+	}
+
+	if (nv_device(priv)->chipset == 0x40) {
+		nv_wr32(priv, 0x4009b0, 0x83280fff);
+		nv_wr32(priv, 0x4009b4, 0x000000a0);
+	} else {
+		nv_wr32(priv, 0x400820, 0x83280eff);
+		nv_wr32(priv, 0x400824, 0x000000a0);
+	}
+
+	switch (nv_device(priv)->chipset) {
+	case 0x40:
+	case 0x45:
+		nv_wr32(priv, 0x4009b8, 0x0078e366);
+		nv_wr32(priv, 0x4009bc, 0x0000014c);
+		break;
+	case 0x41:
+	case 0x42: /* pciid also 0x00Cx */
+	/* case 0x0120: XXX (pciid) */
+		nv_wr32(priv, 0x400828, 0x007596ff);
+		nv_wr32(priv, 0x40082c, 0x00000108);
+		break;
+	case 0x43:
+		nv_wr32(priv, 0x400828, 0x0072cb77);
+		nv_wr32(priv, 0x40082c, 0x00000108);
+		break;
+	case 0x44:
+	case 0x46: /* G72 */
+	case 0x4a:
+	case 0x4c: /* G7x-based C51 */
+	case 0x4e:
+		nv_wr32(priv, 0x400860, 0);
+		nv_wr32(priv, 0x400864, 0);
+		break;
+	case 0x47: /* G70 */
+	case 0x49: /* G71 */
+	case 0x4b: /* G73 */
+		nv_wr32(priv, 0x400828, 0x07830610);
+		nv_wr32(priv, 0x40082c, 0x0000016A);
+		break;
+	default:
+		break;
+	}
+
+	nv_wr32(priv, 0x400b38, 0x2ffff800);
+	nv_wr32(priv, 0x400b3c, 0x00006000);
+
+	/* Tiling related stuff. */
+	switch (nv_device(priv)->chipset) {
+	case 0x44:
+	case 0x4a:
+		nv_wr32(priv, 0x400bc4, 0x1003d888);
+		nv_wr32(priv, 0x400bbc, 0xb7a7b500);
+		break;
+	case 0x46:
+		nv_wr32(priv, 0x400bc4, 0x0000e024);
+		nv_wr32(priv, 0x400bbc, 0xb7a7b520);
+		break;
+	case 0x4c:
+	case 0x4e:
+	case 0x67:
+		nv_wr32(priv, 0x400bc4, 0x1003d888);
+		nv_wr32(priv, 0x400bbc, 0xb7a7b540);
+		break;
+	default:
+		break;
+	}
+
+	/* Turn all the tiling regions off. */
+	for (i = 0; i < pfb->tile.regions; i++)
+		engine->tile_prog(engine, i);
+
+	/* begin RAM config */
+	vramsz = nv_device_resource_len(nv_device(priv), 0) - 1;
+	switch (nv_device(priv)->chipset) {
+	case 0x40:
+		nv_wr32(priv, 0x4009A4, nv_rd32(priv, 0x100200));
+		nv_wr32(priv, 0x4009A8, nv_rd32(priv, 0x100204));
+		nv_wr32(priv, 0x4069A4, nv_rd32(priv, 0x100200));
+		nv_wr32(priv, 0x4069A8, nv_rd32(priv, 0x100204));
+		nv_wr32(priv, 0x400820, 0);
+		nv_wr32(priv, 0x400824, 0);
+		nv_wr32(priv, 0x400864, vramsz);
+		nv_wr32(priv, 0x400868, vramsz);
+		break;
+	default:
+		switch (nv_device(priv)->chipset) {
+		case 0x41:
+		case 0x42:
+		case 0x43:
+		case 0x45:
+		case 0x4e:
+		case 0x44:
+		case 0x4a:
+			nv_wr32(priv, 0x4009F0, nv_rd32(priv, 0x100200));
+			nv_wr32(priv, 0x4009F4, nv_rd32(priv, 0x100204));
+			break;
+		default:
+			nv_wr32(priv, 0x400DF0, nv_rd32(priv, 0x100200));
+			nv_wr32(priv, 0x400DF4, nv_rd32(priv, 0x100204));
+			break;
+		}
+		nv_wr32(priv, 0x4069F0, nv_rd32(priv, 0x100200));
+		nv_wr32(priv, 0x4069F4, nv_rd32(priv, 0x100204));
+		nv_wr32(priv, 0x400840, 0);
+		nv_wr32(priv, 0x400844, 0);
+		nv_wr32(priv, 0x4008A0, vramsz);
+		nv_wr32(priv, 0x4008A4, vramsz);
+		break;
+	}
+
+	return 0;
+}
+
+struct nouveau_oclass
+nv40_gr_oclass = {
+	.handle = NV_ENGINE(GR, 0x40),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv40_gr_ctor,
+		.dtor = _nouveau_gr_dtor,
+		.init = nv40_gr_init,
+		.fini = _nouveau_gr_fini,
+	},
+};
