commit 83bce9c2baa51e439480a713119a73d3c8b61083
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Sat Mar 18 21:53:05 2017 -0400

    drm/nouveau/mpeg: mthd returns true on success now
    
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Fixes: 590801c1a3 ("drm/nouveau/mpeg: remove dependence on namedb/engctx lookup")
    Cc: stable@vger.kernel.org # v4.3+
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
index e536f37e24b0..c3cf02ed468e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
@@ -172,7 +172,7 @@ nv44_mpeg_intr(struct nvkm_engine *engine)
 		}
 
 		if (type == 0x00000010) {
-			if (!nv44_mpeg_mthd(subdev->device, mthd, data))
+			if (nv44_mpeg_mthd(subdev->device, mthd, data))
 				show &= ~0x01000000;
 		}
 	}

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
index d433cfa4a8ab..e536f37e24b0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
@@ -212,6 +212,5 @@ nv44_mpeg_new(struct nvkm_device *device, int index, struct nvkm_engine **pmpeg)
 	INIT_LIST_HEAD(&mpeg->chan);
 	*pmpeg = &mpeg->engine;
 
-	return nvkm_engine_ctor(&nv44_mpeg, device, index, 0x00000002,
-				true, &mpeg->engine);
+	return nvkm_engine_ctor(&nv44_mpeg, device, index, true, &mpeg->engine);
 }

commit 7624fc011e56902a83e409b14d6c1efa75aa4a58
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/mpeg: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
index d1b914b43cee..d433cfa4a8ab 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
@@ -21,7 +21,7 @@
  *
  * Authors: Ben Skeggs
  */
-#define nv44_mpeg(p) container_of((p), struct nv44_mpeg, base.engine)
+#define nv44_mpeg(p) container_of((p), struct nv44_mpeg, engine)
 #include "priv.h"
 
 #include <core/client.h>
@@ -31,12 +31,10 @@
 #include <nvif/class.h>
 
 struct nv44_mpeg {
-	struct nvkm_mpeg base;
+	struct nvkm_engine engine;
 	struct list_head chan;
 };
 
-bool nv40_mpeg_mthd_dma(struct nvkm_device *, u32, u32);
-
 /*******************************************************************************
  * PMPEG context
  ******************************************************************************/
@@ -72,7 +70,7 @@ nv44_mpeg_chan_fini(struct nvkm_object *object, bool suspend)
 
 	struct nv44_mpeg_chan *chan = nv44_mpeg_chan(object);
 	struct nv44_mpeg *mpeg = chan->mpeg;
-	struct nvkm_device *device = mpeg->base.engine.subdev.device;
+	struct nvkm_device *device = mpeg->engine.subdev.device;
 	u32 inst = 0x80000000 | (chan->inst >> 4);
 
 	nvkm_mask(device, 0x00b32c, 0x00000001, 0x00000000);
@@ -88,9 +86,9 @@ nv44_mpeg_chan_dtor(struct nvkm_object *object)
 	struct nv44_mpeg_chan *chan = nv44_mpeg_chan(object);
 	struct nv44_mpeg *mpeg = chan->mpeg;
 	unsigned long flags;
-	spin_lock_irqsave(&mpeg->base.engine.lock, flags);
+	spin_lock_irqsave(&mpeg->engine.lock, flags);
 	list_del(&chan->head);
-	spin_unlock_irqrestore(&mpeg->base.engine.lock, flags);
+	spin_unlock_irqrestore(&mpeg->engine.lock, flags);
 	return chan;
 }
 
@@ -117,9 +115,9 @@ nv44_mpeg_chan_new(struct nvkm_fifo_chan *fifoch,
 	chan->fifo = fifoch;
 	*pobject = &chan->object;
 
-	spin_lock_irqsave(&mpeg->base.engine.lock, flags);
+	spin_lock_irqsave(&mpeg->engine.lock, flags);
 	list_add(&chan->head, &mpeg->chan);
-	spin_unlock_irqrestore(&mpeg->base.engine.lock, flags);
+	spin_unlock_irqrestore(&mpeg->engine.lock, flags);
 	return 0;
 }
 
@@ -142,11 +140,12 @@ nv44_mpeg_mthd(struct nvkm_device *device, u32 mthd, u32 data)
 }
 
 static void
-nv44_mpeg_intr(struct nvkm_subdev *subdev)
+nv44_mpeg_intr(struct nvkm_engine *engine)
 {
-	struct nv44_mpeg *mpeg = (void *)subdev;
+	struct nv44_mpeg *mpeg = nv44_mpeg(engine);
+	struct nvkm_subdev *subdev = &mpeg->engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	struct nv44_mpeg_chan *temp, *chan = NULL;
-	struct nvkm_device *device = mpeg->base.engine.subdev.device;
 	unsigned long flags;
 	u32 inst = nvkm_rd32(device, 0x00b318) & 0x000fffff;
 	u32 stat = nvkm_rd32(device, 0x00b100);
@@ -155,7 +154,7 @@ nv44_mpeg_intr(struct nvkm_subdev *subdev)
 	u32 data = nvkm_rd32(device, 0x00b238);
 	u32 show = stat;
 
-	spin_lock_irqsave(&mpeg->base.engine.lock, flags);
+	spin_lock_irqsave(&mpeg->engine.lock, flags);
 	list_for_each_entry(temp, &mpeg->chan, head) {
 		if (temp->inst >> 4 == inst) {
 			chan = temp;
@@ -188,27 +187,14 @@ nv44_mpeg_intr(struct nvkm_subdev *subdev)
 			   stat, type, mthd, data);
 	}
 
-	spin_unlock_irqrestore(&mpeg->base.engine.lock, flags);
-}
-
-static void
-nv44_mpeg_me_intr(struct nvkm_subdev *subdev)
-{
-	struct nvkm_mpeg *mpeg = (void *)subdev;
-	struct nvkm_device *device = mpeg->engine.subdev.device;
-	u32 stat;
-
-	if ((stat = nvkm_rd32(device, 0x00b100)))
-		nv44_mpeg_intr(subdev);
-
-	if ((stat = nvkm_rd32(device, 0x00b800))) {
-		nvkm_error(subdev, "PMSRCH %08x\n", stat);
-		nvkm_wr32(device, 0x00b800, stat);
-	}
+	spin_unlock_irqrestore(&mpeg->engine.lock, flags);
 }
 
 static const struct nvkm_engine_func
 nv44_mpeg = {
+	.init = nv31_mpeg_init,
+	.intr = nv44_mpeg_intr,
+	.tile = nv31_mpeg_tile,
 	.fifo.cclass = nv44_mpeg_chan_new,
 	.sclass = {
 		{ -1, -1, NV31_MPEG, &nv31_mpeg_object },
@@ -216,35 +202,16 @@ nv44_mpeg = {
 	}
 };
 
-static int
-nv44_mpeg_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-	       struct nvkm_oclass *oclass, void *data, u32 size,
-	       struct nvkm_object **pobject)
+int
+nv44_mpeg_new(struct nvkm_device *device, int index, struct nvkm_engine **pmpeg)
 {
 	struct nv44_mpeg *mpeg;
-	int ret;
-
-	ret = nvkm_mpeg_create(parent, engine, oclass, &mpeg);
-	*pobject = nv_object(mpeg);
-	if (ret)
-		return ret;
 
+	if (!(mpeg = kzalloc(sizeof(*mpeg), GFP_KERNEL)))
+		return -ENOMEM;
 	INIT_LIST_HEAD(&mpeg->chan);
-	mpeg->base.engine.func = &nv44_mpeg;
+	*pmpeg = &mpeg->engine;
 
-	nv_subdev(mpeg)->unit = 0x00000002;
-	nv_subdev(mpeg)->intr = nv44_mpeg_me_intr;
-	nv_engine(mpeg)->tile_prog = nv31_mpeg_tile_prog;
-	return 0;
+	return nvkm_engine_ctor(&nv44_mpeg, device, index, 0x00000002,
+				true, &mpeg->engine);
 }
-
-struct nvkm_oclass
-nv44_mpeg_oclass = {
-	.handle = NV_ENGINE(MPEG, 0x44),
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nv44_mpeg_ctor,
-		.dtor = _nvkm_mpeg_dtor,
-		.init = nv31_mpeg_init,
-		.fini = _nvkm_mpeg_fini,
-	},
-};

commit 13de7f462902d1a452d501cdb2d06ef02cabbfff
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/fifo: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
index 0f9ef18bf18d..d1b914b43cee 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
@@ -25,6 +25,7 @@
 #include "priv.h"
 
 #include <core/client.h>
+#include <core/gpuobj.h>
 #include <engine/fifo.h>
 
 #include <nvif/class.h>

commit 218f978d43296a9ac142a63361e25f517df3d318
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/mpeg: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
index ff9ddc67a292..0f9ef18bf18d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
@@ -21,99 +21,107 @@
  *
  * Authors: Ben Skeggs
  */
-#include <engine/mpeg.h>
+#define nv44_mpeg(p) container_of((p), struct nv44_mpeg, base.engine)
+#include "priv.h"
 
 #include <core/client.h>
 #include <engine/fifo.h>
 
+#include <nvif/class.h>
+
 struct nv44_mpeg {
 	struct nvkm_mpeg base;
 	struct list_head chan;
 };
 
+bool nv40_mpeg_mthd_dma(struct nvkm_device *, u32, u32);
+
+/*******************************************************************************
+ * PMPEG context
+ ******************************************************************************/
+#define nv44_mpeg_chan(p) container_of((p), struct nv44_mpeg_chan, object)
+
 struct nv44_mpeg_chan {
-	struct nvkm_mpeg_chan base;
+	struct nvkm_object object;
+	struct nv44_mpeg *mpeg;
 	struct nvkm_fifo_chan *fifo;
-	u32 inst;
 	struct list_head head;
+	u32 inst;
 };
 
-bool nv40_mpeg_mthd_dma(struct nvkm_device *, u32, u32);
+static int
+nv44_mpeg_chan_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,
+		    int align, struct nvkm_gpuobj **pgpuobj)
+{
+	struct nv44_mpeg_chan *chan = nv44_mpeg_chan(object);
+	int ret = nvkm_gpuobj_new(chan->object.engine->subdev.device, 264 * 4,
+				  align, true, parent, pgpuobj);
+	if (ret == 0) {
+		chan->inst = (*pgpuobj)->addr;
+		nvkm_kmap(*pgpuobj);
+		nvkm_wo32(*pgpuobj, 0x78, 0x02001ec1);
+		nvkm_done(*pgpuobj);
+	}
+	return ret;
+}
 
-/*******************************************************************************
- * PMPEG context
- ******************************************************************************/
+static int
+nv44_mpeg_chan_fini(struct nvkm_object *object, bool suspend)
+{
 
-static void
-nv44_mpeg_context_dtor(struct nvkm_object *object)
+	struct nv44_mpeg_chan *chan = nv44_mpeg_chan(object);
+	struct nv44_mpeg *mpeg = chan->mpeg;
+	struct nvkm_device *device = mpeg->base.engine.subdev.device;
+	u32 inst = 0x80000000 | (chan->inst >> 4);
+
+	nvkm_mask(device, 0x00b32c, 0x00000001, 0x00000000);
+	if (nvkm_rd32(device, 0x00b318) == inst)
+		nvkm_mask(device, 0x00b318, 0x80000000, 0x00000000);
+	nvkm_mask(device, 0x00b32c, 0x00000001, 0x00000001);
+	return 0;
+}
+
+static void *
+nv44_mpeg_chan_dtor(struct nvkm_object *object)
 {
-	struct nv44_mpeg_chan *chan = (void *)object;
-	struct nv44_mpeg *mpeg = (void *)object->engine;
+	struct nv44_mpeg_chan *chan = nv44_mpeg_chan(object);
+	struct nv44_mpeg *mpeg = chan->mpeg;
 	unsigned long flags;
 	spin_lock_irqsave(&mpeg->base.engine.lock, flags);
 	list_del(&chan->head);
 	spin_unlock_irqrestore(&mpeg->base.engine.lock, flags);
-	nvkm_mpeg_context_destroy(&chan->base);
+	return chan;
 }
 
+static const struct nvkm_object_func
+nv44_mpeg_chan = {
+	.dtor = nv44_mpeg_chan_dtor,
+	.fini = nv44_mpeg_chan_fini,
+	.bind = nv44_mpeg_chan_bind,
+};
+
 static int
-nv44_mpeg_context_ctor(struct nvkm_object *parent,
-		       struct nvkm_object *engine,
-		       struct nvkm_oclass *oclass, void *data, u32 size,
-		       struct nvkm_object **pobject)
+nv44_mpeg_chan_new(struct nvkm_fifo_chan *fifoch,
+		   const struct nvkm_oclass *oclass,
+		   struct nvkm_object **pobject)
 {
-	struct nv44_mpeg *mpeg = (void *)engine;
+	struct nv44_mpeg *mpeg = nv44_mpeg(oclass->engine);
 	struct nv44_mpeg_chan *chan;
 	unsigned long flags;
-	int ret;
 
-	ret = nvkm_mpeg_context_create(parent, engine, oclass, NULL, 264 * 4,
-				       16, NVOBJ_FLAG_ZERO_ALLOC, &chan);
-	*pobject = nv_object(chan);
-	if (ret)
-		return ret;
+	if (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))
+		return -ENOMEM;
+	nvkm_object_ctor(&nv44_mpeg_chan, oclass, &chan->object);
+	chan->mpeg = mpeg;
+	chan->fifo = fifoch;
+	*pobject = &chan->object;
 
 	spin_lock_irqsave(&mpeg->base.engine.lock, flags);
-	chan->fifo = nvkm_fifo_chan(parent);
-	chan->inst = chan->base.base.gpuobj.addr;
 	list_add(&chan->head, &mpeg->chan);
 	spin_unlock_irqrestore(&mpeg->base.engine.lock, flags);
-
-	nvkm_kmap(&chan->base.base.gpuobj);
-	nvkm_wo32(&chan->base.base.gpuobj, 0x78, 0x02001ec1);
-	nvkm_done(&chan->base.base.gpuobj);
 	return 0;
 }
 
-static int
-nv44_mpeg_context_fini(struct nvkm_object *object, bool suspend)
-{
-
-	struct nvkm_mpeg *mpeg = (void *)object->engine;
-	struct nv44_mpeg_chan *chan = (void *)object;
-	struct nvkm_device *device = mpeg->engine.subdev.device;
-	u32 inst = 0x80000000 | nv_gpuobj(chan)->addr >> 4;
-
-	nvkm_mask(device, 0x00b32c, 0x00000001, 0x00000000);
-	if (nvkm_rd32(device, 0x00b318) == inst)
-		nvkm_mask(device, 0x00b318, 0x80000000, 0x00000000);
-	nvkm_mask(device, 0x00b32c, 0x00000001, 0x00000001);
-	return 0;
-}
-
-static struct nvkm_oclass
-nv44_mpeg_cclass = {
-	.handle = NV_ENGCTX(MPEG, 0x44),
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nv44_mpeg_context_ctor,
-		.dtor = nv44_mpeg_context_dtor,
-		.init = _nvkm_mpeg_context_init,
-		.fini = nv44_mpeg_context_fini,
-		.rd32 = _nvkm_mpeg_context_rd32,
-		.wr32 = _nvkm_mpeg_context_wr32,
-	},
-};
-
 /*******************************************************************************
  * PMPEG engine/subdev functions
  ******************************************************************************/
@@ -175,7 +183,7 @@ nv44_mpeg_intr(struct nvkm_subdev *subdev)
 	if (show) {
 		nvkm_error(subdev, "ch %d [%08x %s] %08x %08x %08x %08x\n",
 			   chan ? chan->fifo->chid : -1, inst << 4,
-			   chan ? chan->fifo->object.client->name : "unknown",
+			   chan ? chan->object.client->name : "unknown",
 			   stat, type, mthd, data);
 	}
 
@@ -198,6 +206,15 @@ nv44_mpeg_me_intr(struct nvkm_subdev *subdev)
 	}
 }
 
+static const struct nvkm_engine_func
+nv44_mpeg = {
+	.fifo.cclass = nv44_mpeg_chan_new,
+	.sclass = {
+		{ -1, -1, NV31_MPEG, &nv31_mpeg_object },
+		{}
+	}
+};
+
 static int
 nv44_mpeg_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_oclass *oclass, void *data, u32 size,
@@ -212,11 +229,10 @@ nv44_mpeg_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		return ret;
 
 	INIT_LIST_HEAD(&mpeg->chan);
+	mpeg->base.engine.func = &nv44_mpeg;
 
 	nv_subdev(mpeg)->unit = 0x00000002;
 	nv_subdev(mpeg)->intr = nv44_mpeg_me_intr;
-	nv_engine(mpeg)->cclass = &nv44_mpeg_cclass;
-	nv_engine(mpeg)->sclass = nv40_mpeg_sclass;
 	nv_engine(mpeg)->tile_prog = nv31_mpeg_tile_prog;
 	return 0;
 }

commit 8f0649b5c6e70ec18122255690e39f010c12a614
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/fifo: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
index 1223baddfb9a..ff9ddc67a292 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
@@ -145,13 +145,11 @@ nv44_mpeg_intr(struct nvkm_subdev *subdev)
 	u32 mthd = nvkm_rd32(device, 0x00b234);
 	u32 data = nvkm_rd32(device, 0x00b238);
 	u32 show = stat;
-	int chid = -1;
 
 	spin_lock_irqsave(&mpeg->base.engine.lock, flags);
 	list_for_each_entry(temp, &mpeg->chan, head) {
 		if (temp->inst >> 4 == inst) {
 			chan = temp;
-			chid = chan->fifo->chid;
 			list_del(&chan->head);
 			list_add(&chan->head, &mpeg->chan);
 			break;
@@ -176,7 +174,8 @@ nv44_mpeg_intr(struct nvkm_subdev *subdev)
 
 	if (show) {
 		nvkm_error(subdev, "ch %d [%08x %s] %08x %08x %08x %08x\n",
-			   chid, inst << 4, nvkm_client_name(chan),
+			   chan ? chan->fifo->chid : -1, inst << 4,
+			   chan ? chan->fifo->object.client->name : "unknown",
 			   stat, type, mthd, data);
 	}
 

commit 590801c1a3b19883b0d0e4c60241cbed8a916d47
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/mpeg: remove dependence on namedb/engctx lookup
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
index 93936671f39b..1223baddfb9a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
@@ -24,24 +24,47 @@
 #include <engine/mpeg.h>
 
 #include <core/client.h>
-#include <core/handle.h>
 #include <engine/fifo.h>
 
+struct nv44_mpeg {
+	struct nvkm_mpeg base;
+	struct list_head chan;
+};
+
 struct nv44_mpeg_chan {
 	struct nvkm_mpeg_chan base;
+	struct nvkm_fifo_chan *fifo;
+	u32 inst;
+	struct list_head head;
 };
 
+bool nv40_mpeg_mthd_dma(struct nvkm_device *, u32, u32);
+
 /*******************************************************************************
  * PMPEG context
  ******************************************************************************/
 
+static void
+nv44_mpeg_context_dtor(struct nvkm_object *object)
+{
+	struct nv44_mpeg_chan *chan = (void *)object;
+	struct nv44_mpeg *mpeg = (void *)object->engine;
+	unsigned long flags;
+	spin_lock_irqsave(&mpeg->base.engine.lock, flags);
+	list_del(&chan->head);
+	spin_unlock_irqrestore(&mpeg->base.engine.lock, flags);
+	nvkm_mpeg_context_destroy(&chan->base);
+}
+
 static int
 nv44_mpeg_context_ctor(struct nvkm_object *parent,
 		       struct nvkm_object *engine,
 		       struct nvkm_oclass *oclass, void *data, u32 size,
 		       struct nvkm_object **pobject)
 {
+	struct nv44_mpeg *mpeg = (void *)engine;
 	struct nv44_mpeg_chan *chan;
+	unsigned long flags;
 	int ret;
 
 	ret = nvkm_mpeg_context_create(parent, engine, oclass, NULL, 264 * 4,
@@ -50,6 +73,12 @@ nv44_mpeg_context_ctor(struct nvkm_object *parent,
 	if (ret)
 		return ret;
 
+	spin_lock_irqsave(&mpeg->base.engine.lock, flags);
+	chan->fifo = nvkm_fifo_chan(parent);
+	chan->inst = chan->base.base.gpuobj.addr;
+	list_add(&chan->head, &mpeg->chan);
+	spin_unlock_irqrestore(&mpeg->base.engine.lock, flags);
+
 	nvkm_kmap(&chan->base.base.gpuobj);
 	nvkm_wo32(&chan->base.base.gpuobj, 0x78, 0x02001ec1);
 	nvkm_done(&chan->base.base.gpuobj);
@@ -77,7 +106,7 @@ nv44_mpeg_cclass = {
 	.handle = NV_ENGCTX(MPEG, 0x44),
 	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv44_mpeg_context_ctor,
-		.dtor = _nvkm_mpeg_context_dtor,
+		.dtor = nv44_mpeg_context_dtor,
 		.init = _nvkm_mpeg_context_init,
 		.fini = nv44_mpeg_context_fini,
 		.rd32 = _nvkm_mpeg_context_rd32,
@@ -89,25 +118,45 @@ nv44_mpeg_cclass = {
  * PMPEG engine/subdev functions
  ******************************************************************************/
 
+static bool
+nv44_mpeg_mthd(struct nvkm_device *device, u32 mthd, u32 data)
+{
+	switch (mthd) {
+	case 0x190:
+	case 0x1a0:
+	case 0x1b0:
+		return nv40_mpeg_mthd_dma(device, mthd, data);
+	default:
+		break;
+	}
+	return false;
+}
+
 static void
 nv44_mpeg_intr(struct nvkm_subdev *subdev)
 {
-	struct nvkm_mpeg *mpeg = (void *)subdev;
-	struct nvkm_device *device = mpeg->engine.subdev.device;
-	struct nvkm_fifo *fifo = device->fifo;
-	struct nvkm_engine *engine = nv_engine(subdev);
-	struct nvkm_object *engctx;
-	struct nvkm_handle *handle;
+	struct nv44_mpeg *mpeg = (void *)subdev;
+	struct nv44_mpeg_chan *temp, *chan = NULL;
+	struct nvkm_device *device = mpeg->base.engine.subdev.device;
+	unsigned long flags;
 	u32 inst = nvkm_rd32(device, 0x00b318) & 0x000fffff;
 	u32 stat = nvkm_rd32(device, 0x00b100);
 	u32 type = nvkm_rd32(device, 0x00b230);
 	u32 mthd = nvkm_rd32(device, 0x00b234);
 	u32 data = nvkm_rd32(device, 0x00b238);
 	u32 show = stat;
-	int chid;
-
-	engctx = nvkm_engctx_get(engine, inst);
-	chid   = fifo->chid(fifo, engctx);
+	int chid = -1;
+
+	spin_lock_irqsave(&mpeg->base.engine.lock, flags);
+	list_for_each_entry(temp, &mpeg->chan, head) {
+		if (temp->inst >> 4 == inst) {
+			chan = temp;
+			chid = chan->fifo->chid;
+			list_del(&chan->head);
+			list_add(&chan->head, &mpeg->chan);
+			break;
+		}
+	}
 
 	if (stat & 0x01000000) {
 		/* happens on initial binding of the object */
@@ -117,10 +166,8 @@ nv44_mpeg_intr(struct nvkm_subdev *subdev)
 		}
 
 		if (type == 0x00000010) {
-			handle = nvkm_handle_get_class(engctx, 0x3174);
-			if (handle && !nv_call(handle->object, mthd, data))
+			if (!nv44_mpeg_mthd(subdev->device, mthd, data))
 				show &= ~0x01000000;
-			nvkm_handle_put(handle);
 		}
 	}
 
@@ -128,13 +175,12 @@ nv44_mpeg_intr(struct nvkm_subdev *subdev)
 	nvkm_wr32(device, 0x00b230, 0x00000001);
 
 	if (show) {
-		nvkm_error(subdev,
-			   "ch %d [%08x %s] %08x %08x %08x %08x\n",
-			   chid, inst << 4, nvkm_client_name(engctx), stat,
-			   type, mthd, data);
+		nvkm_error(subdev, "ch %d [%08x %s] %08x %08x %08x %08x\n",
+			   chid, inst << 4, nvkm_client_name(chan),
+			   stat, type, mthd, data);
 	}
 
-	nvkm_engctx_put(engctx);
+	spin_unlock_irqrestore(&mpeg->base.engine.lock, flags);
 }
 
 static void
@@ -158,7 +204,7 @@ nv44_mpeg_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_oclass *oclass, void *data, u32 size,
 	       struct nvkm_object **pobject)
 {
-	struct nvkm_mpeg *mpeg;
+	struct nv44_mpeg *mpeg;
 	int ret;
 
 	ret = nvkm_mpeg_create(parent, engine, oclass, &mpeg);
@@ -166,6 +212,8 @@ nv44_mpeg_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
+	INIT_LIST_HEAD(&mpeg->chan);
+
 	nv_subdev(mpeg)->unit = 0x00000002;
 	nv_subdev(mpeg)->intr = nv44_mpeg_me_intr;
 	nv_engine(mpeg)->cclass = &nv44_mpeg_cclass;

commit 572fb13db2a9dc5336a4b769d60428bc9cff0af6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:14 2015 +1000

    drm/nouveau/mpeg: switch to gpuobj accessor macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
index 9bd5fc185ea2..93936671f39b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
@@ -50,7 +50,9 @@ nv44_mpeg_context_ctor(struct nvkm_object *parent,
 	if (ret)
 		return ret;
 
-	nv_wo32(&chan->base.base, 0x78, 0x02001ec1);
+	nvkm_kmap(&chan->base.base.gpuobj);
+	nvkm_wo32(&chan->base.base.gpuobj, 0x78, 0x02001ec1);
+	nvkm_done(&chan->base.base.gpuobj);
 	return 0;
 }
 

commit b835c09bc6b87318fd06bfcb9ac4bb59eaa48f57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:13 2015 +1000

    drm/nouveau/mpeg: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
index cbf98b306d71..9bd5fc185ea2 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
@@ -126,10 +126,10 @@ nv44_mpeg_intr(struct nvkm_subdev *subdev)
 	nvkm_wr32(device, 0x00b230, 0x00000001);
 
 	if (show) {
-		nv_error(mpeg,
-			 "ch %d [0x%08x %s] 0x%08x 0x%08x 0x%08x 0x%08x\n",
-			 chid, inst << 4, nvkm_client_name(engctx), stat,
-			 type, mthd, data);
+		nvkm_error(subdev,
+			   "ch %d [%08x %s] %08x %08x %08x %08x\n",
+			   chid, inst << 4, nvkm_client_name(engctx), stat,
+			   type, mthd, data);
 	}
 
 	nvkm_engctx_put(engctx);
@@ -146,7 +146,7 @@ nv44_mpeg_me_intr(struct nvkm_subdev *subdev)
 		nv44_mpeg_intr(subdev);
 
 	if ((stat = nvkm_rd32(device, 0x00b800))) {
-		nv_error(mpeg, "PMSRCH 0x%08x\n", stat);
+		nvkm_error(subdev, "PMSRCH %08x\n", stat);
 		nvkm_wr32(device, 0x00b800, stat);
 	}
 }

commit 636e37aa978b4904189710b5b501299bd7404ad5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:10 2015 +1000

    drm/nouveau/mpeg: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
index f494328c74e3..cbf98b306d71 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
@@ -60,12 +60,13 @@ nv44_mpeg_context_fini(struct nvkm_object *object, bool suspend)
 
 	struct nvkm_mpeg *mpeg = (void *)object->engine;
 	struct nv44_mpeg_chan *chan = (void *)object;
+	struct nvkm_device *device = mpeg->engine.subdev.device;
 	u32 inst = 0x80000000 | nv_gpuobj(chan)->addr >> 4;
 
-	nv_mask(mpeg, 0x00b32c, 0x00000001, 0x00000000);
-	if (nv_rd32(mpeg, 0x00b318) == inst)
-		nv_mask(mpeg, 0x00b318, 0x80000000, 0x00000000);
-	nv_mask(mpeg, 0x00b32c, 0x00000001, 0x00000001);
+	nvkm_mask(device, 0x00b32c, 0x00000001, 0x00000000);
+	if (nvkm_rd32(device, 0x00b318) == inst)
+		nvkm_mask(device, 0x00b318, 0x80000000, 0x00000000);
+	nvkm_mask(device, 0x00b32c, 0x00000001, 0x00000001);
 	return 0;
 }
 
@@ -89,16 +90,17 @@ nv44_mpeg_cclass = {
 static void
 nv44_mpeg_intr(struct nvkm_subdev *subdev)
 {
-	struct nvkm_fifo *fifo = nvkm_fifo(subdev);
+	struct nvkm_mpeg *mpeg = (void *)subdev;
+	struct nvkm_device *device = mpeg->engine.subdev.device;
+	struct nvkm_fifo *fifo = device->fifo;
 	struct nvkm_engine *engine = nv_engine(subdev);
 	struct nvkm_object *engctx;
 	struct nvkm_handle *handle;
-	struct nvkm_mpeg *mpeg = (void *)subdev;
-	u32 inst = nv_rd32(mpeg, 0x00b318) & 0x000fffff;
-	u32 stat = nv_rd32(mpeg, 0x00b100);
-	u32 type = nv_rd32(mpeg, 0x00b230);
-	u32 mthd = nv_rd32(mpeg, 0x00b234);
-	u32 data = nv_rd32(mpeg, 0x00b238);
+	u32 inst = nvkm_rd32(device, 0x00b318) & 0x000fffff;
+	u32 stat = nvkm_rd32(device, 0x00b100);
+	u32 type = nvkm_rd32(device, 0x00b230);
+	u32 mthd = nvkm_rd32(device, 0x00b234);
+	u32 data = nvkm_rd32(device, 0x00b238);
 	u32 show = stat;
 	int chid;
 
@@ -108,7 +110,7 @@ nv44_mpeg_intr(struct nvkm_subdev *subdev)
 	if (stat & 0x01000000) {
 		/* happens on initial binding of the object */
 		if (type == 0x00000020 && mthd == 0x0000) {
-			nv_mask(mpeg, 0x00b308, 0x00000000, 0x00000000);
+			nvkm_mask(device, 0x00b308, 0x00000000, 0x00000000);
 			show &= ~0x01000000;
 		}
 
@@ -120,8 +122,8 @@ nv44_mpeg_intr(struct nvkm_subdev *subdev)
 		}
 	}
 
-	nv_wr32(mpeg, 0x00b100, stat);
-	nv_wr32(mpeg, 0x00b230, 0x00000001);
+	nvkm_wr32(device, 0x00b100, stat);
+	nvkm_wr32(device, 0x00b230, 0x00000001);
 
 	if (show) {
 		nv_error(mpeg,
@@ -137,14 +139,15 @@ static void
 nv44_mpeg_me_intr(struct nvkm_subdev *subdev)
 {
 	struct nvkm_mpeg *mpeg = (void *)subdev;
+	struct nvkm_device *device = mpeg->engine.subdev.device;
 	u32 stat;
 
-	if ((stat = nv_rd32(mpeg, 0x00b100)))
+	if ((stat = nvkm_rd32(device, 0x00b100)))
 		nv44_mpeg_intr(subdev);
 
-	if ((stat = nv_rd32(mpeg, 0x00b800))) {
+	if ((stat = nvkm_rd32(device, 0x00b800))) {
 		nv_error(mpeg, "PMSRCH 0x%08x\n", stat);
-		nv_wr32(mpeg, 0x00b800, stat);
+		nvkm_wr32(device, 0x00b800, stat);
 	}
 }
 

commit b19de4f3d787947224e89447505dd3c99b304d7b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:08 2015 +1000

    drm/nouveau/mpeg: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
index aeed7f850f65..f494328c74e3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
@@ -27,10 +27,6 @@
 #include <core/handle.h>
 #include <engine/fifo.h>
 
-struct nv44_mpeg_priv {
-	struct nvkm_mpeg base;
-};
-
 struct nv44_mpeg_chan {
 	struct nvkm_mpeg_chan base;
 };
@@ -62,14 +58,14 @@ static int
 nv44_mpeg_context_fini(struct nvkm_object *object, bool suspend)
 {
 
-	struct nv44_mpeg_priv *priv = (void *)object->engine;
+	struct nvkm_mpeg *mpeg = (void *)object->engine;
 	struct nv44_mpeg_chan *chan = (void *)object;
 	u32 inst = 0x80000000 | nv_gpuobj(chan)->addr >> 4;
 
-	nv_mask(priv, 0x00b32c, 0x00000001, 0x00000000);
-	if (nv_rd32(priv, 0x00b318) == inst)
-		nv_mask(priv, 0x00b318, 0x80000000, 0x00000000);
-	nv_mask(priv, 0x00b32c, 0x00000001, 0x00000001);
+	nv_mask(mpeg, 0x00b32c, 0x00000001, 0x00000000);
+	if (nv_rd32(mpeg, 0x00b318) == inst)
+		nv_mask(mpeg, 0x00b318, 0x80000000, 0x00000000);
+	nv_mask(mpeg, 0x00b32c, 0x00000001, 0x00000001);
 	return 0;
 }
 
@@ -97,12 +93,12 @@ nv44_mpeg_intr(struct nvkm_subdev *subdev)
 	struct nvkm_engine *engine = nv_engine(subdev);
 	struct nvkm_object *engctx;
 	struct nvkm_handle *handle;
-	struct nv44_mpeg_priv *priv = (void *)subdev;
-	u32 inst = nv_rd32(priv, 0x00b318) & 0x000fffff;
-	u32 stat = nv_rd32(priv, 0x00b100);
-	u32 type = nv_rd32(priv, 0x00b230);
-	u32 mthd = nv_rd32(priv, 0x00b234);
-	u32 data = nv_rd32(priv, 0x00b238);
+	struct nvkm_mpeg *mpeg = (void *)subdev;
+	u32 inst = nv_rd32(mpeg, 0x00b318) & 0x000fffff;
+	u32 stat = nv_rd32(mpeg, 0x00b100);
+	u32 type = nv_rd32(mpeg, 0x00b230);
+	u32 mthd = nv_rd32(mpeg, 0x00b234);
+	u32 data = nv_rd32(mpeg, 0x00b238);
 	u32 show = stat;
 	int chid;
 
@@ -112,7 +108,7 @@ nv44_mpeg_intr(struct nvkm_subdev *subdev)
 	if (stat & 0x01000000) {
 		/* happens on initial binding of the object */
 		if (type == 0x00000020 && mthd == 0x0000) {
-			nv_mask(priv, 0x00b308, 0x00000000, 0x00000000);
+			nv_mask(mpeg, 0x00b308, 0x00000000, 0x00000000);
 			show &= ~0x01000000;
 		}
 
@@ -124,11 +120,11 @@ nv44_mpeg_intr(struct nvkm_subdev *subdev)
 		}
 	}
 
-	nv_wr32(priv, 0x00b100, stat);
-	nv_wr32(priv, 0x00b230, 0x00000001);
+	nv_wr32(mpeg, 0x00b100, stat);
+	nv_wr32(mpeg, 0x00b230, 0x00000001);
 
 	if (show) {
-		nv_error(priv,
+		nv_error(mpeg,
 			 "ch %d [0x%08x %s] 0x%08x 0x%08x 0x%08x 0x%08x\n",
 			 chid, inst << 4, nvkm_client_name(engctx), stat,
 			 type, mthd, data);
@@ -140,15 +136,15 @@ nv44_mpeg_intr(struct nvkm_subdev *subdev)
 static void
 nv44_mpeg_me_intr(struct nvkm_subdev *subdev)
 {
-	struct nv44_mpeg_priv *priv = (void *)subdev;
+	struct nvkm_mpeg *mpeg = (void *)subdev;
 	u32 stat;
 
-	if ((stat = nv_rd32(priv, 0x00b100)))
+	if ((stat = nv_rd32(mpeg, 0x00b100)))
 		nv44_mpeg_intr(subdev);
 
-	if ((stat = nv_rd32(priv, 0x00b800))) {
-		nv_error(priv, "PMSRCH 0x%08x\n", stat);
-		nv_wr32(priv, 0x00b800, stat);
+	if ((stat = nv_rd32(mpeg, 0x00b800))) {
+		nv_error(mpeg, "PMSRCH 0x%08x\n", stat);
+		nv_wr32(mpeg, 0x00b800, stat);
 	}
 }
 
@@ -157,19 +153,19 @@ nv44_mpeg_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_oclass *oclass, void *data, u32 size,
 	       struct nvkm_object **pobject)
 {
-	struct nv44_mpeg_priv *priv;
+	struct nvkm_mpeg *mpeg;
 	int ret;
 
-	ret = nvkm_mpeg_create(parent, engine, oclass, &priv);
-	*pobject = nv_object(priv);
+	ret = nvkm_mpeg_create(parent, engine, oclass, &mpeg);
+	*pobject = nv_object(mpeg);
 	if (ret)
 		return ret;
 
-	nv_subdev(priv)->unit = 0x00000002;
-	nv_subdev(priv)->intr = nv44_mpeg_me_intr;
-	nv_engine(priv)->cclass = &nv44_mpeg_cclass;
-	nv_engine(priv)->sclass = nv40_mpeg_sclass;
-	nv_engine(priv)->tile_prog = nv31_mpeg_tile_prog;
+	nv_subdev(mpeg)->unit = 0x00000002;
+	nv_subdev(mpeg)->intr = nv44_mpeg_me_intr;
+	nv_engine(mpeg)->cclass = &nv44_mpeg_cclass;
+	nv_engine(mpeg)->sclass = nv40_mpeg_sclass;
+	nv_engine(mpeg)->tile_prog = nv31_mpeg_tile_prog;
 	return 0;
 }
 

commit 6189f1b0938dc0621c27494031b83ffae566e318
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/fifo: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
index 4720ac884468..aeed7f850f65 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
@@ -93,7 +93,7 @@ nv44_mpeg_cclass = {
 static void
 nv44_mpeg_intr(struct nvkm_subdev *subdev)
 {
-	struct nvkm_fifo *pfifo = nvkm_fifo(subdev);
+	struct nvkm_fifo *fifo = nvkm_fifo(subdev);
 	struct nvkm_engine *engine = nv_engine(subdev);
 	struct nvkm_object *engctx;
 	struct nvkm_handle *handle;
@@ -107,7 +107,7 @@ nv44_mpeg_intr(struct nvkm_subdev *subdev)
 	int chid;
 
 	engctx = nvkm_engctx_get(engine, inst);
-	chid   = pfifo->chid(pfifo, engctx);
+	chid   = fifo->chid(fifo, engctx);
 
 	if (stat & 0x01000000) {
 		/* happens on initial binding of the object */

commit e7c29683fd014dfb9a730086c2c564161264e1ea
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:29:56 2015 +1000

    drm/nouveau/mpeg: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
index 72c7f33fd29b..4720ac884468 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
@@ -21,25 +21,18 @@
  *
  * Authors: Ben Skeggs
  */
+#include <engine/mpeg.h>
 
-#include <core/os.h>
 #include <core/client.h>
-#include <core/engctx.h>
 #include <core/handle.h>
-
-#include <subdev/fb.h>
-#include <subdev/timer.h>
-#include <subdev/instmem.h>
-
 #include <engine/fifo.h>
-#include <engine/mpeg.h>
 
 struct nv44_mpeg_priv {
-	struct nouveau_mpeg base;
+	struct nvkm_mpeg base;
 };
 
 struct nv44_mpeg_chan {
-	struct nouveau_mpeg_chan base;
+	struct nvkm_mpeg_chan base;
 };
 
 /*******************************************************************************
@@ -47,17 +40,16 @@ struct nv44_mpeg_chan {
  ******************************************************************************/
 
 static int
-nv44_mpeg_context_ctor(struct nouveau_object *parent,
-		       struct nouveau_object *engine,
-		       struct nouveau_oclass *oclass, void *data, u32 size,
-		       struct nouveau_object **pobject)
+nv44_mpeg_context_ctor(struct nvkm_object *parent,
+		       struct nvkm_object *engine,
+		       struct nvkm_oclass *oclass, void *data, u32 size,
+		       struct nvkm_object **pobject)
 {
 	struct nv44_mpeg_chan *chan;
 	int ret;
 
-	ret = nouveau_mpeg_context_create(parent, engine, oclass, NULL,
-					  264 * 4, 16,
-					  NVOBJ_FLAG_ZERO_ALLOC, &chan);
+	ret = nvkm_mpeg_context_create(parent, engine, oclass, NULL, 264 * 4,
+				       16, NVOBJ_FLAG_ZERO_ALLOC, &chan);
 	*pobject = nv_object(chan);
 	if (ret)
 		return ret;
@@ -67,7 +59,7 @@ nv44_mpeg_context_ctor(struct nouveau_object *parent,
 }
 
 static int
-nv44_mpeg_context_fini(struct nouveau_object *object, bool suspend)
+nv44_mpeg_context_fini(struct nvkm_object *object, bool suspend)
 {
 
 	struct nv44_mpeg_priv *priv = (void *)object->engine;
@@ -81,16 +73,16 @@ nv44_mpeg_context_fini(struct nouveau_object *object, bool suspend)
 	return 0;
 }
 
-static struct nouveau_oclass
+static struct nvkm_oclass
 nv44_mpeg_cclass = {
 	.handle = NV_ENGCTX(MPEG, 0x44),
-	.ofuncs = &(struct nouveau_ofuncs) {
+	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv44_mpeg_context_ctor,
-		.dtor = _nouveau_mpeg_context_dtor,
-		.init = _nouveau_mpeg_context_init,
+		.dtor = _nvkm_mpeg_context_dtor,
+		.init = _nvkm_mpeg_context_init,
 		.fini = nv44_mpeg_context_fini,
-		.rd32 = _nouveau_mpeg_context_rd32,
-		.wr32 = _nouveau_mpeg_context_wr32,
+		.rd32 = _nvkm_mpeg_context_rd32,
+		.wr32 = _nvkm_mpeg_context_wr32,
 	},
 };
 
@@ -99,12 +91,12 @@ nv44_mpeg_cclass = {
  ******************************************************************************/
 
 static void
-nv44_mpeg_intr(struct nouveau_subdev *subdev)
+nv44_mpeg_intr(struct nvkm_subdev *subdev)
 {
-	struct nouveau_fifo *pfifo = nouveau_fifo(subdev);
-	struct nouveau_engine *engine = nv_engine(subdev);
-	struct nouveau_object *engctx;
-	struct nouveau_handle *handle;
+	struct nvkm_fifo *pfifo = nvkm_fifo(subdev);
+	struct nvkm_engine *engine = nv_engine(subdev);
+	struct nvkm_object *engctx;
+	struct nvkm_handle *handle;
 	struct nv44_mpeg_priv *priv = (void *)subdev;
 	u32 inst = nv_rd32(priv, 0x00b318) & 0x000fffff;
 	u32 stat = nv_rd32(priv, 0x00b100);
@@ -114,7 +106,7 @@ nv44_mpeg_intr(struct nouveau_subdev *subdev)
 	u32 show = stat;
 	int chid;
 
-	engctx = nouveau_engctx_get(engine, inst);
+	engctx = nvkm_engctx_get(engine, inst);
 	chid   = pfifo->chid(pfifo, engctx);
 
 	if (stat & 0x01000000) {
@@ -125,10 +117,10 @@ nv44_mpeg_intr(struct nouveau_subdev *subdev)
 		}
 
 		if (type == 0x00000010) {
-			handle = nouveau_handle_get_class(engctx, 0x3174);
+			handle = nvkm_handle_get_class(engctx, 0x3174);
 			if (handle && !nv_call(handle->object, mthd, data))
 				show &= ~0x01000000;
-			nouveau_handle_put(handle);
+			nvkm_handle_put(handle);
 		}
 	}
 
@@ -138,15 +130,15 @@ nv44_mpeg_intr(struct nouveau_subdev *subdev)
 	if (show) {
 		nv_error(priv,
 			 "ch %d [0x%08x %s] 0x%08x 0x%08x 0x%08x 0x%08x\n",
-			 chid, inst << 4, nouveau_client_name(engctx), stat,
+			 chid, inst << 4, nvkm_client_name(engctx), stat,
 			 type, mthd, data);
 	}
 
-	nouveau_engctx_put(engctx);
+	nvkm_engctx_put(engctx);
 }
 
 static void
-nv44_mpeg_me_intr(struct nouveau_subdev *subdev)
+nv44_mpeg_me_intr(struct nvkm_subdev *subdev)
 {
 	struct nv44_mpeg_priv *priv = (void *)subdev;
 	u32 stat;
@@ -161,14 +153,14 @@ nv44_mpeg_me_intr(struct nouveau_subdev *subdev)
 }
 
 static int
-nv44_mpeg_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
-	       struct nouveau_oclass *oclass, void *data, u32 size,
-	       struct nouveau_object **pobject)
+nv44_mpeg_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+	       struct nvkm_oclass *oclass, void *data, u32 size,
+	       struct nvkm_object **pobject)
 {
 	struct nv44_mpeg_priv *priv;
 	int ret;
 
-	ret = nouveau_mpeg_create(parent, engine, oclass, &priv);
+	ret = nvkm_mpeg_create(parent, engine, oclass, &priv);
 	*pobject = nv_object(priv);
 	if (ret)
 		return ret;
@@ -181,13 +173,13 @@ nv44_mpeg_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	return 0;
 }
 
-struct nouveau_oclass
+struct nvkm_oclass
 nv44_mpeg_oclass = {
 	.handle = NV_ENGINE(MPEG, 0x44),
-	.ofuncs = &(struct nouveau_ofuncs) {
+	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv44_mpeg_ctor,
-		.dtor = _nouveau_mpeg_dtor,
+		.dtor = _nvkm_mpeg_dtor,
 		.init = nv31_mpeg_init,
-		.fini = _nouveau_mpeg_fini,
+		.fini = _nvkm_mpeg_fini,
 	},
 };

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
new file mode 100644
index 000000000000..72c7f33fd29b
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c
@@ -0,0 +1,193 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <core/os.h>
+#include <core/client.h>
+#include <core/engctx.h>
+#include <core/handle.h>
+
+#include <subdev/fb.h>
+#include <subdev/timer.h>
+#include <subdev/instmem.h>
+
+#include <engine/fifo.h>
+#include <engine/mpeg.h>
+
+struct nv44_mpeg_priv {
+	struct nouveau_mpeg base;
+};
+
+struct nv44_mpeg_chan {
+	struct nouveau_mpeg_chan base;
+};
+
+/*******************************************************************************
+ * PMPEG context
+ ******************************************************************************/
+
+static int
+nv44_mpeg_context_ctor(struct nouveau_object *parent,
+		       struct nouveau_object *engine,
+		       struct nouveau_oclass *oclass, void *data, u32 size,
+		       struct nouveau_object **pobject)
+{
+	struct nv44_mpeg_chan *chan;
+	int ret;
+
+	ret = nouveau_mpeg_context_create(parent, engine, oclass, NULL,
+					  264 * 4, 16,
+					  NVOBJ_FLAG_ZERO_ALLOC, &chan);
+	*pobject = nv_object(chan);
+	if (ret)
+		return ret;
+
+	nv_wo32(&chan->base.base, 0x78, 0x02001ec1);
+	return 0;
+}
+
+static int
+nv44_mpeg_context_fini(struct nouveau_object *object, bool suspend)
+{
+
+	struct nv44_mpeg_priv *priv = (void *)object->engine;
+	struct nv44_mpeg_chan *chan = (void *)object;
+	u32 inst = 0x80000000 | nv_gpuobj(chan)->addr >> 4;
+
+	nv_mask(priv, 0x00b32c, 0x00000001, 0x00000000);
+	if (nv_rd32(priv, 0x00b318) == inst)
+		nv_mask(priv, 0x00b318, 0x80000000, 0x00000000);
+	nv_mask(priv, 0x00b32c, 0x00000001, 0x00000001);
+	return 0;
+}
+
+static struct nouveau_oclass
+nv44_mpeg_cclass = {
+	.handle = NV_ENGCTX(MPEG, 0x44),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv44_mpeg_context_ctor,
+		.dtor = _nouveau_mpeg_context_dtor,
+		.init = _nouveau_mpeg_context_init,
+		.fini = nv44_mpeg_context_fini,
+		.rd32 = _nouveau_mpeg_context_rd32,
+		.wr32 = _nouveau_mpeg_context_wr32,
+	},
+};
+
+/*******************************************************************************
+ * PMPEG engine/subdev functions
+ ******************************************************************************/
+
+static void
+nv44_mpeg_intr(struct nouveau_subdev *subdev)
+{
+	struct nouveau_fifo *pfifo = nouveau_fifo(subdev);
+	struct nouveau_engine *engine = nv_engine(subdev);
+	struct nouveau_object *engctx;
+	struct nouveau_handle *handle;
+	struct nv44_mpeg_priv *priv = (void *)subdev;
+	u32 inst = nv_rd32(priv, 0x00b318) & 0x000fffff;
+	u32 stat = nv_rd32(priv, 0x00b100);
+	u32 type = nv_rd32(priv, 0x00b230);
+	u32 mthd = nv_rd32(priv, 0x00b234);
+	u32 data = nv_rd32(priv, 0x00b238);
+	u32 show = stat;
+	int chid;
+
+	engctx = nouveau_engctx_get(engine, inst);
+	chid   = pfifo->chid(pfifo, engctx);
+
+	if (stat & 0x01000000) {
+		/* happens on initial binding of the object */
+		if (type == 0x00000020 && mthd == 0x0000) {
+			nv_mask(priv, 0x00b308, 0x00000000, 0x00000000);
+			show &= ~0x01000000;
+		}
+
+		if (type == 0x00000010) {
+			handle = nouveau_handle_get_class(engctx, 0x3174);
+			if (handle && !nv_call(handle->object, mthd, data))
+				show &= ~0x01000000;
+			nouveau_handle_put(handle);
+		}
+	}
+
+	nv_wr32(priv, 0x00b100, stat);
+	nv_wr32(priv, 0x00b230, 0x00000001);
+
+	if (show) {
+		nv_error(priv,
+			 "ch %d [0x%08x %s] 0x%08x 0x%08x 0x%08x 0x%08x\n",
+			 chid, inst << 4, nouveau_client_name(engctx), stat,
+			 type, mthd, data);
+	}
+
+	nouveau_engctx_put(engctx);
+}
+
+static void
+nv44_mpeg_me_intr(struct nouveau_subdev *subdev)
+{
+	struct nv44_mpeg_priv *priv = (void *)subdev;
+	u32 stat;
+
+	if ((stat = nv_rd32(priv, 0x00b100)))
+		nv44_mpeg_intr(subdev);
+
+	if ((stat = nv_rd32(priv, 0x00b800))) {
+		nv_error(priv, "PMSRCH 0x%08x\n", stat);
+		nv_wr32(priv, 0x00b800, stat);
+	}
+}
+
+static int
+nv44_mpeg_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+	       struct nouveau_oclass *oclass, void *data, u32 size,
+	       struct nouveau_object **pobject)
+{
+	struct nv44_mpeg_priv *priv;
+	int ret;
+
+	ret = nouveau_mpeg_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	nv_subdev(priv)->unit = 0x00000002;
+	nv_subdev(priv)->intr = nv44_mpeg_me_intr;
+	nv_engine(priv)->cclass = &nv44_mpeg_cclass;
+	nv_engine(priv)->sclass = nv40_mpeg_sclass;
+	nv_engine(priv)->tile_prog = nv31_mpeg_tile_prog;
+	return 0;
+}
+
+struct nouveau_oclass
+nv44_mpeg_oclass = {
+	.handle = NV_ENGINE(MPEG, 0x44),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv44_mpeg_ctor,
+		.dtor = _nouveau_mpeg_dtor,
+		.init = nv31_mpeg_init,
+		.fini = _nouveau_mpeg_fini,
+	},
+};
