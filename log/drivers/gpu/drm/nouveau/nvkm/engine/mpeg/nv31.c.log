commit d257f9bf06129613de539ea71ecea60848b662cd
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Sat Aug 5 22:19:53 2017 -0400

    drm/nouveau/mpeg: print more debug info when rejecting dma objects
    
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Reviewed-by: Tobias Klausmann <tobias.johannes.klausmann@mni.thm.de>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index 8a8895246d26..7fea7d45202f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -124,6 +124,8 @@ nv31_mpeg_tile(struct nvkm_engine *engine, int i, struct nvkm_fb_tile *tile)
 static bool
 nv31_mpeg_mthd_dma(struct nvkm_device *device, u32 mthd, u32 data)
 {
+	struct nv31_mpeg *mpeg = nv31_mpeg(device->mpeg);
+	struct nvkm_subdev *subdev = &mpeg->engine.subdev;
 	u32 inst = data << 4;
 	u32 dma0 = nvkm_rd32(device, 0x700000 + inst);
 	u32 dma1 = nvkm_rd32(device, 0x700004 + inst);
@@ -132,8 +134,11 @@ nv31_mpeg_mthd_dma(struct nvkm_device *device, u32 mthd, u32 data)
 	u32 size = dma1 + 1;
 
 	/* only allow linear DMA objects */
-	if (!(dma0 & 0x00002000))
+	if (!(dma0 & 0x00002000)) {
+		nvkm_error(subdev, "inst %08x dma0 %08x dma1 %08x dma2 %08x\n",
+			   inst, dma0, dma1, dma2);
 		return false;
+	}
 
 	if (mthd == 0x0190) {
 		/* DMA_CMD */

commit 83bce9c2baa51e439480a713119a73d3c8b61083
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Sat Mar 18 21:53:05 2017 -0400

    drm/nouveau/mpeg: mthd returns true on success now
    
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Fixes: 590801c1a3 ("drm/nouveau/mpeg: remove dependence on namedb/engctx lookup")
    Cc: stable@vger.kernel.org # v4.3+
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index 003ac915eaad..8a8895246d26 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -198,7 +198,7 @@ nv31_mpeg_intr(struct nvkm_engine *engine)
 		}
 
 		if (type == 0x00000010) {
-			if (!nv31_mpeg_mthd(mpeg, mthd, data))
+			if (nv31_mpeg_mthd(mpeg, mthd, data))
 				show &= ~0x01000000;
 		}
 	}

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index d4d8942b1347..003ac915eaad 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -278,7 +278,7 @@ nv31_mpeg_new_(const struct nv31_mpeg_func *func, struct nvkm_device *device,
 	mpeg->func = func;
 	*pmpeg = &mpeg->engine;
 
-	return nvkm_engine_ctor(&nv31_mpeg_, device, index, 0x00000002,
+	return nvkm_engine_ctor(&nv31_mpeg_, device, index,
 				true, &mpeg->engine);
 }
 

commit 68f3f702b6a430a8d1e909455a60d26c0f2da530
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/core: remove the remainder of the previous style
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index 87420b8329ac..d4d8942b1347 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -43,7 +43,7 @@ nv31_mpeg_object_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,
 				  false, parent, pgpuobj);
 	if (ret == 0) {
 		nvkm_kmap(*pgpuobj);
-		nvkm_wo32(*pgpuobj, 0x00, object->oclass_name);
+		nvkm_wo32(*pgpuobj, 0x00, object->oclass);
 		nvkm_wo32(*pgpuobj, 0x04, 0x00000000);
 		nvkm_wo32(*pgpuobj, 0x08, 0x00000000);
 		nvkm_wo32(*pgpuobj, 0x0c, 0x00000000);

commit 7624fc011e56902a83e409b14d6c1efa75aa4a58
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/mpeg: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index f79749946b72..87420b8329ac 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -68,10 +68,10 @@ nv31_mpeg_chan_dtor(struct nvkm_object *object)
 	struct nv31_mpeg *mpeg = chan->mpeg;
 	unsigned long flags;
 
-	spin_lock_irqsave(&mpeg->base.engine.lock, flags);
+	spin_lock_irqsave(&mpeg->engine.lock, flags);
 	if (mpeg->chan == chan)
 		mpeg->chan = NULL;
-	spin_unlock_irqrestore(&mpeg->base.engine.lock, flags);
+	spin_unlock_irqrestore(&mpeg->engine.lock, flags);
 	return chan;
 }
 
@@ -97,12 +97,12 @@ nv31_mpeg_chan_new(struct nvkm_fifo_chan *fifoch,
 	chan->fifo = fifoch;
 	*pobject = &chan->object;
 
-	spin_lock_irqsave(&mpeg->base.engine.lock, flags);
+	spin_lock_irqsave(&mpeg->engine.lock, flags);
 	if (!mpeg->chan) {
 		mpeg->chan = chan;
 		ret = 0;
 	}
-	spin_unlock_irqrestore(&mpeg->base.engine.lock, flags);
+	spin_unlock_irqrestore(&mpeg->engine.lock, flags);
 	return ret;
 }
 
@@ -111,11 +111,10 @@ nv31_mpeg_chan_new(struct nvkm_fifo_chan *fifoch,
  ******************************************************************************/
 
 void
-nv31_mpeg_tile_prog(struct nvkm_engine *engine, int i)
+nv31_mpeg_tile(struct nvkm_engine *engine, int i, struct nvkm_fb_tile *tile)
 {
-	struct nv31_mpeg *mpeg = (void *)engine;
-	struct nvkm_device *device = mpeg->base.engine.subdev.device;
-	struct nvkm_fb_tile *tile = &device->fb->tile.region[i];
+	struct nv31_mpeg *mpeg = nv31_mpeg(engine);
+	struct nvkm_device *device = mpeg->engine.subdev.device;
 
 	nvkm_wr32(device, 0x00b008 + (i * 0x10), tile->pitch);
 	nvkm_wr32(device, 0x00b004 + (i * 0x10), tile->limit);
@@ -164,23 +163,24 @@ nv31_mpeg_mthd_dma(struct nvkm_device *device, u32 mthd, u32 data)
 static bool
 nv31_mpeg_mthd(struct nv31_mpeg *mpeg, u32 mthd, u32 data)
 {
-	struct nvkm_device *device = mpeg->base.engine.subdev.device;
+	struct nvkm_device *device = mpeg->engine.subdev.device;
 	switch (mthd) {
 	case 0x190:
 	case 0x1a0:
 	case 0x1b0:
-		return mpeg->mthd_dma(device, mthd, data);
+		return mpeg->func->mthd_dma(device, mthd, data);
 	default:
 		break;
 	}
 	return false;
 }
 
-void
-nv31_mpeg_intr(struct nvkm_subdev *subdev)
+static void
+nv31_mpeg_intr(struct nvkm_engine *engine)
 {
-	struct nv31_mpeg *mpeg = (void *)subdev;
-	struct nvkm_device *device = mpeg->base.engine.subdev.device;
+	struct nv31_mpeg *mpeg = nv31_mpeg(engine);
+	struct nvkm_subdev *subdev = &mpeg->engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	u32 stat = nvkm_rd32(device, 0x00b100);
 	u32 type = nvkm_rd32(device, 0x00b230);
 	u32 mthd = nvkm_rd32(device, 0x00b234);
@@ -188,7 +188,7 @@ nv31_mpeg_intr(struct nvkm_subdev *subdev)
 	u32 show = stat;
 	unsigned long flags;
 
-	spin_lock_irqsave(&mpeg->base.engine.lock, flags);
+	spin_lock_irqsave(&mpeg->engine.lock, flags);
 
 	if (stat & 0x01000000) {
 		/* happens on initial binding of the object */
@@ -213,61 +213,19 @@ nv31_mpeg_intr(struct nvkm_subdev *subdev)
 			   "unknown", stat, type, mthd, data);
 	}
 
-	spin_unlock_irqrestore(&mpeg->base.engine.lock, flags);
-}
-
-static const struct nvkm_engine_func
-nv31_mpeg = {
-	.fifo.cclass = nv31_mpeg_chan_new,
-	.sclass = {
-		{ -1, -1, NV31_MPEG, &nv31_mpeg_object },
-		{}
-	}
-};
-
-static int
-nv31_mpeg_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-	       struct nvkm_oclass *oclass, void *data, u32 size,
-	       struct nvkm_object **pobject)
-{
-	struct nv31_mpeg *mpeg;
-	int ret;
-
-	ret = nvkm_mpeg_create(parent, engine, oclass, &mpeg);
-	*pobject = nv_object(mpeg);
-	if (ret)
-		return ret;
-
-	mpeg->base.engine.func = &nv31_mpeg;
-
-	mpeg->mthd_dma = nv31_mpeg_mthd_dma;
-	nv_subdev(mpeg)->unit = 0x00000002;
-	nv_subdev(mpeg)->intr = nv31_mpeg_intr;
-	nv_engine(mpeg)->tile_prog = nv31_mpeg_tile_prog;
-	return 0;
+	spin_unlock_irqrestore(&mpeg->engine.lock, flags);
 }
 
 int
-nv31_mpeg_init(struct nvkm_object *object)
+nv31_mpeg_init(struct nvkm_engine *mpeg)
 {
-	struct nvkm_engine *engine = nv_engine(object);
-	struct nv31_mpeg *mpeg = (void *)object;
-	struct nvkm_subdev *subdev = &mpeg->base.engine.subdev;
+	struct nvkm_subdev *subdev = &mpeg->subdev;
 	struct nvkm_device *device = subdev->device;
-	struct nvkm_fb *fb = device->fb;
-	int ret, i;
-
-	ret = nvkm_mpeg_init(&mpeg->base);
-	if (ret)
-		return ret;
 
 	/* VPE init */
 	nvkm_wr32(device, 0x00b0e0, 0x00000020); /* nvidia: rd 0x01, wr 0x20 */
 	nvkm_wr32(device, 0x00b0e8, 0x00000020); /* nvidia: rd 0x01, wr 0x20 */
 
-	for (i = 0; i < fb->tile.regions; i++)
-		engine->tile_prog(engine, i);
-
 	/* PMPEG init */
 	nvkm_wr32(device, 0x00b32c, 0x00000000);
 	nvkm_wr32(device, 0x00b314, 0x00000100);
@@ -290,13 +248,47 @@ nv31_mpeg_init(struct nvkm_object *object)
 	return 0;
 }
 
-struct nvkm_oclass
-nv31_mpeg_oclass = {
-	.handle = NV_ENGINE(MPEG, 0x31),
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nv31_mpeg_ctor,
-		.dtor = _nvkm_mpeg_dtor,
-		.init = nv31_mpeg_init,
-		.fini = _nvkm_mpeg_fini,
-	},
+static void *
+nv31_mpeg_dtor(struct nvkm_engine *engine)
+{
+	return nv31_mpeg(engine);
+}
+
+static const struct nvkm_engine_func
+nv31_mpeg_ = {
+	.dtor = nv31_mpeg_dtor,
+	.init = nv31_mpeg_init,
+	.intr = nv31_mpeg_intr,
+	.tile = nv31_mpeg_tile,
+	.fifo.cclass = nv31_mpeg_chan_new,
+	.sclass = {
+		{ -1, -1, NV31_MPEG, &nv31_mpeg_object },
+		{}
+	}
 };
+
+int
+nv31_mpeg_new_(const struct nv31_mpeg_func *func, struct nvkm_device *device,
+	       int index, struct nvkm_engine **pmpeg)
+{
+	struct nv31_mpeg *mpeg;
+
+	if (!(mpeg = kzalloc(sizeof(*mpeg), GFP_KERNEL)))
+		return -ENOMEM;
+	mpeg->func = func;
+	*pmpeg = &mpeg->engine;
+
+	return nvkm_engine_ctor(&nv31_mpeg_, device, index, 0x00000002,
+				true, &mpeg->engine);
+}
+
+static const struct nv31_mpeg_func
+nv31_mpeg = {
+	.mthd_dma = nv31_mpeg_mthd_dma,
+};
+
+int
+nv31_mpeg_new(struct nvkm_device *device, int index, struct nvkm_engine **pmpeg)
+{
+	return nv31_mpeg_new_(&nv31_mpeg, device, index, pmpeg);
+}

commit 13de7f462902d1a452d501cdb2d06ef02cabbfff
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/fifo: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index 417cc31a12ef..f79749946b72 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -24,6 +24,7 @@
 #include "nv31.h"
 
 #include <core/client.h>
+#include <core/gpuobj.h>
 #include <subdev/fb.h>
 #include <subdev/timer.h>
 #include <engine/fifo.h>

commit 218f978d43296a9ac142a63361e25f517df3d318
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/mpeg: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index 211b44c00c85..417cc31a12ef 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -26,33 +26,99 @@
 #include <core/client.h>
 #include <subdev/fb.h>
 #include <subdev/timer.h>
+#include <engine/fifo.h>
+
+#include <nvif/class.h>
 
 /*******************************************************************************
  * MPEG object classes
  ******************************************************************************/
 
 static int
-nv31_mpeg_object_ctor(struct nvkm_object *parent,
-		      struct nvkm_object *engine,
-		      struct nvkm_oclass *oclass, void *data, u32 size,
-		      struct nvkm_object **pobject)
+nv31_mpeg_object_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,
+		      int align, struct nvkm_gpuobj **pgpuobj)
 {
-	struct nvkm_gpuobj *obj;
-	int ret;
+	int ret = nvkm_gpuobj_new(object->engine->subdev.device, 16, align,
+				  false, parent, pgpuobj);
+	if (ret == 0) {
+		nvkm_kmap(*pgpuobj);
+		nvkm_wo32(*pgpuobj, 0x00, object->oclass_name);
+		nvkm_wo32(*pgpuobj, 0x04, 0x00000000);
+		nvkm_wo32(*pgpuobj, 0x08, 0x00000000);
+		nvkm_wo32(*pgpuobj, 0x0c, 0x00000000);
+		nvkm_done(*pgpuobj);
+	}
+	return ret;
+}
 
-	ret = nvkm_gpuobj_create(parent, engine, oclass, 0, parent,
-				 20, 16, 0, &obj);
-	*pobject = nv_object(obj);
-	if (ret)
-		return ret;
+const struct nvkm_object_func
+nv31_mpeg_object = {
+	.bind = nv31_mpeg_object_bind,
+};
 
-	nvkm_kmap(obj);
-	nvkm_wo32(obj, 0x00, nv_mclass(obj));
-	nvkm_wo32(obj, 0x04, 0x00000000);
-	nvkm_wo32(obj, 0x08, 0x00000000);
-	nvkm_wo32(obj, 0x0c, 0x00000000);
-	nvkm_done(obj);
-	return 0;
+/*******************************************************************************
+ * PMPEG context
+ ******************************************************************************/
+
+static void *
+nv31_mpeg_chan_dtor(struct nvkm_object *object)
+{
+	struct nv31_mpeg_chan *chan = nv31_mpeg_chan(object);
+	struct nv31_mpeg *mpeg = chan->mpeg;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mpeg->base.engine.lock, flags);
+	if (mpeg->chan == chan)
+		mpeg->chan = NULL;
+	spin_unlock_irqrestore(&mpeg->base.engine.lock, flags);
+	return chan;
+}
+
+static const struct nvkm_object_func
+nv31_mpeg_chan = {
+	.dtor = nv31_mpeg_chan_dtor,
+};
+
+int
+nv31_mpeg_chan_new(struct nvkm_fifo_chan *fifoch,
+		   const struct nvkm_oclass *oclass,
+		   struct nvkm_object **pobject)
+{
+	struct nv31_mpeg *mpeg = nv31_mpeg(oclass->engine);
+	struct nv31_mpeg_chan *chan;
+	unsigned long flags;
+	int ret = -EBUSY;
+
+	if (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))
+		return -ENOMEM;
+	nvkm_object_ctor(&nv31_mpeg_chan, oclass, &chan->object);
+	chan->mpeg = mpeg;
+	chan->fifo = fifoch;
+	*pobject = &chan->object;
+
+	spin_lock_irqsave(&mpeg->base.engine.lock, flags);
+	if (!mpeg->chan) {
+		mpeg->chan = chan;
+		ret = 0;
+	}
+	spin_unlock_irqrestore(&mpeg->base.engine.lock, flags);
+	return ret;
+}
+
+/*******************************************************************************
+ * PMPEG engine/subdev functions
+ ******************************************************************************/
+
+void
+nv31_mpeg_tile_prog(struct nvkm_engine *engine, int i)
+{
+	struct nv31_mpeg *mpeg = (void *)engine;
+	struct nvkm_device *device = mpeg->base.engine.subdev.device;
+	struct nvkm_fb_tile *tile = &device->fb->tile.region[i];
+
+	nvkm_wr32(device, 0x00b008 + (i * 0x10), tile->pitch);
+	nvkm_wr32(device, 0x00b004 + (i * 0x10), tile->limit);
+	nvkm_wr32(device, 0x00b000 + (i * 0x10), tile->addr);
 }
 
 static bool
@@ -109,95 +175,6 @@ nv31_mpeg_mthd(struct nv31_mpeg *mpeg, u32 mthd, u32 data)
 	return false;
 }
 
-struct nvkm_ofuncs
-nv31_mpeg_ofuncs = {
-	.ctor = nv31_mpeg_object_ctor,
-	.dtor = _nvkm_gpuobj_dtor,
-	.init = _nvkm_gpuobj_init,
-	.fini = _nvkm_gpuobj_fini,
-	.rd32 = _nvkm_gpuobj_rd32,
-	.wr32 = _nvkm_gpuobj_wr32,
-};
-
-struct nvkm_oclass
-nv31_mpeg_sclass[] = {
-	{ 0x3174, &nv31_mpeg_ofuncs },
-	{}
-};
-
-/*******************************************************************************
- * PMPEG context
- ******************************************************************************/
-
-static int
-nv31_mpeg_context_ctor(struct nvkm_object *parent,
-		       struct nvkm_object *engine,
-		       struct nvkm_oclass *oclass, void *data, u32 size,
-		       struct nvkm_object **pobject)
-{
-	struct nv31_mpeg *mpeg = (void *)engine;
-	struct nv31_mpeg_chan *chan;
-	unsigned long flags;
-	int ret;
-
-	ret = nvkm_object_create(parent, engine, oclass, 0, &chan);
-	*pobject = nv_object(chan);
-	if (ret)
-		return ret;
-
-	spin_lock_irqsave(&nv_engine(mpeg)->lock, flags);
-	if (mpeg->chan) {
-		spin_unlock_irqrestore(&nv_engine(mpeg)->lock, flags);
-		nvkm_object_destroy(&chan->base);
-		*pobject = NULL;
-		return -EBUSY;
-	}
-	chan->fifo = nvkm_fifo_chan(parent);
-	mpeg->chan = chan;
-	spin_unlock_irqrestore(&nv_engine(mpeg)->lock, flags);
-	return 0;
-}
-
-static void
-nv31_mpeg_context_dtor(struct nvkm_object *object)
-{
-	struct nv31_mpeg *mpeg = (void *)object->engine;
-	struct nv31_mpeg_chan *chan = (void *)object;
-	unsigned long flags;
-
-	spin_lock_irqsave(&nv_engine(mpeg)->lock, flags);
-	mpeg->chan = NULL;
-	spin_unlock_irqrestore(&nv_engine(mpeg)->lock, flags);
-	nvkm_object_destroy(&chan->base);
-}
-
-struct nvkm_oclass
-nv31_mpeg_cclass = {
-	.handle = NV_ENGCTX(MPEG, 0x31),
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nv31_mpeg_context_ctor,
-		.dtor = nv31_mpeg_context_dtor,
-		.init = _nvkm_object_init,
-		.fini = _nvkm_object_fini,
-	},
-};
-
-/*******************************************************************************
- * PMPEG engine/subdev functions
- ******************************************************************************/
-
-void
-nv31_mpeg_tile_prog(struct nvkm_engine *engine, int i)
-{
-	struct nv31_mpeg *mpeg = (void *)engine;
-	struct nvkm_device *device = mpeg->base.engine.subdev.device;
-	struct nvkm_fb_tile *tile = &device->fb->tile.region[i];
-
-	nvkm_wr32(device, 0x00b008 + (i * 0x10), tile->pitch);
-	nvkm_wr32(device, 0x00b004 + (i * 0x10), tile->limit);
-	nvkm_wr32(device, 0x00b000 + (i * 0x10), tile->addr);
-}
-
 void
 nv31_mpeg_intr(struct nvkm_subdev *subdev)
 {
@@ -231,13 +208,22 @@ nv31_mpeg_intr(struct nvkm_subdev *subdev)
 	if (show) {
 		nvkm_error(subdev, "ch %d [%s] %08x %08x %08x %08x\n",
 			   mpeg->chan ? mpeg->chan->fifo->chid : -1,
-			   mpeg->chan ? mpeg->chan->fifo->object.client->name :
+			   mpeg->chan ? mpeg->chan->object.client->name :
 			   "unknown", stat, type, mthd, data);
 	}
 
 	spin_unlock_irqrestore(&mpeg->base.engine.lock, flags);
 }
 
+static const struct nvkm_engine_func
+nv31_mpeg = {
+	.fifo.cclass = nv31_mpeg_chan_new,
+	.sclass = {
+		{ -1, -1, NV31_MPEG, &nv31_mpeg_object },
+		{}
+	}
+};
+
 static int
 nv31_mpeg_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_oclass *oclass, void *data, u32 size,
@@ -251,11 +237,11 @@ nv31_mpeg_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
+	mpeg->base.engine.func = &nv31_mpeg;
+
 	mpeg->mthd_dma = nv31_mpeg_mthd_dma;
 	nv_subdev(mpeg)->unit = 0x00000002;
 	nv_subdev(mpeg)->intr = nv31_mpeg_intr;
-	nv_engine(mpeg)->cclass = &nv31_mpeg_cclass;
-	nv_engine(mpeg)->sclass = nv31_mpeg_sclass;
 	nv_engine(mpeg)->tile_prog = nv31_mpeg_tile_prog;
 	return 0;
 }

commit 8f0649b5c6e70ec18122255690e39f010c12a614
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/fifo: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index 05597f2070ed..211b44c00c85 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -231,8 +231,8 @@ nv31_mpeg_intr(struct nvkm_subdev *subdev)
 	if (show) {
 		nvkm_error(subdev, "ch %d [%s] %08x %08x %08x %08x\n",
 			   mpeg->chan ? mpeg->chan->fifo->chid : -1,
-			   nvkm_client_name(mpeg->chan),
-			   stat, type, mthd, data);
+			   mpeg->chan ? mpeg->chan->fifo->object.client->name :
+			   "unknown", stat, type, mthd, data);
 	}
 
 	spin_unlock_irqrestore(&mpeg->base.engine.lock, flags);

commit 590801c1a3b19883b0d0e4c60241cbed8a916d47
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/mpeg: remove dependence on namedb/engctx lookup
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index 0f02b281f34e..05597f2070ed 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -24,9 +24,6 @@
 #include "nv31.h"
 
 #include <core/client.h>
-#include <core/handle.h>
-#include <engine/fifo.h>
-#include <subdev/instmem.h>
 #include <subdev/fb.h>
 #include <subdev/timer.h>
 
@@ -58,44 +55,58 @@ nv31_mpeg_object_ctor(struct nvkm_object *parent,
 	return 0;
 }
 
-static int
-nv31_mpeg_mthd_dma(struct nvkm_object *object, u32 mthd, void *arg, u32 len)
+static bool
+nv31_mpeg_mthd_dma(struct nvkm_device *device, u32 mthd, u32 data)
 {
-	struct nv31_mpeg *mpeg = (void *)object->engine;
-	struct nvkm_device *device = mpeg->base.engine.subdev.device;
-	struct nvkm_instmem *imem = device->imem;
-	u32 inst = *(u32 *)arg << 4;
-	u32 dma0 = imem->func->rd32(imem, inst + 0);
-	u32 dma1 = imem->func->rd32(imem, inst + 4);
-	u32 dma2 = imem->func->rd32(imem, inst + 8);
+	u32 inst = data << 4;
+	u32 dma0 = nvkm_rd32(device, 0x700000 + inst);
+	u32 dma1 = nvkm_rd32(device, 0x700004 + inst);
+	u32 dma2 = nvkm_rd32(device, 0x700008 + inst);
 	u32 base = (dma2 & 0xfffff000) | (dma0 >> 20);
 	u32 size = dma1 + 1;
 
 	/* only allow linear DMA objects */
 	if (!(dma0 & 0x00002000))
-		return -EINVAL;
+		return false;
 
 	if (mthd == 0x0190) {
 		/* DMA_CMD */
-		nvkm_mask(device, 0x00b300, 0x00010000, (dma0 & 0x00030000) ? 0x00010000 : 0);
+		nvkm_mask(device, 0x00b300, 0x00010000,
+				  (dma0 & 0x00030000) ? 0x00010000 : 0);
 		nvkm_wr32(device, 0x00b334, base);
 		nvkm_wr32(device, 0x00b324, size);
 	} else
 	if (mthd == 0x01a0) {
 		/* DMA_DATA */
-		nvkm_mask(device, 0x00b300, 0x00020000, (dma0 & 0x00030000) ? 0x00020000 : 0);
+		nvkm_mask(device, 0x00b300, 0x00020000,
+				  (dma0 & 0x00030000) ? 0x00020000 : 0);
 		nvkm_wr32(device, 0x00b360, base);
 		nvkm_wr32(device, 0x00b364, size);
 	} else {
 		/* DMA_IMAGE, VRAM only */
 		if (dma0 & 0x00030000)
-			return -EINVAL;
+			return false;
 
 		nvkm_wr32(device, 0x00b370, base);
 		nvkm_wr32(device, 0x00b374, size);
 	}
 
-	return 0;
+	return true;
+}
+
+static bool
+nv31_mpeg_mthd(struct nv31_mpeg *mpeg, u32 mthd, u32 data)
+{
+	struct nvkm_device *device = mpeg->base.engine.subdev.device;
+	switch (mthd) {
+	case 0x190:
+	case 0x1a0:
+	case 0x1b0:
+		return mpeg->mthd_dma(device, mthd, data);
+	default:
+		break;
+	}
+	return false;
 }
 
 struct nvkm_ofuncs
@@ -108,17 +119,9 @@ nv31_mpeg_ofuncs = {
 	.wr32 = _nvkm_gpuobj_wr32,
 };
 
-static struct nvkm_omthds
-nv31_mpeg_omthds[] = {
-	{ 0x0190, 0x0190, nv31_mpeg_mthd_dma },
-	{ 0x01a0, 0x01a0, nv31_mpeg_mthd_dma },
-	{ 0x01b0, 0x01b0, nv31_mpeg_mthd_dma },
-	{}
-};
-
 struct nvkm_oclass
 nv31_mpeg_sclass[] = {
-	{ 0x3174, &nv31_mpeg_ofuncs, nv31_mpeg_omthds },
+	{ 0x3174, &nv31_mpeg_ofuncs },
 	{}
 };
 
@@ -149,6 +152,7 @@ nv31_mpeg_context_ctor(struct nvkm_object *parent,
 		*pobject = NULL;
 		return -EBUSY;
 	}
+	chan->fifo = nvkm_fifo_chan(parent);
 	mpeg->chan = chan;
 	spin_unlock_irqrestore(&nv_engine(mpeg)->lock, flags);
 	return 0;
@@ -199,9 +203,6 @@ nv31_mpeg_intr(struct nvkm_subdev *subdev)
 {
 	struct nv31_mpeg *mpeg = (void *)subdev;
 	struct nvkm_device *device = mpeg->base.engine.subdev.device;
-	struct nvkm_fifo *fifo = device->fifo;
-	struct nvkm_handle *handle;
-	struct nvkm_object *engctx;
 	u32 stat = nvkm_rd32(device, 0x00b100);
 	u32 type = nvkm_rd32(device, 0x00b230);
 	u32 mthd = nvkm_rd32(device, 0x00b234);
@@ -209,8 +210,7 @@ nv31_mpeg_intr(struct nvkm_subdev *subdev)
 	u32 show = stat;
 	unsigned long flags;
 
-	spin_lock_irqsave(&nv_engine(mpeg)->lock, flags);
-	engctx = nv_object(mpeg->chan);
+	spin_lock_irqsave(&mpeg->base.engine.lock, flags);
 
 	if (stat & 0x01000000) {
 		/* happens on initial binding of the object */
@@ -219,11 +219,9 @@ nv31_mpeg_intr(struct nvkm_subdev *subdev)
 			show &= ~0x01000000;
 		}
 
-		if (type == 0x00000010 && engctx) {
-			handle = nvkm_handle_get_class(engctx, 0x3174);
-			if (handle && !nv_call(handle->object, mthd, data))
+		if (type == 0x00000010) {
+			if (!nv31_mpeg_mthd(mpeg, mthd, data))
 				show &= ~0x01000000;
-			nvkm_handle_put(handle);
 		}
 	}
 
@@ -232,11 +230,12 @@ nv31_mpeg_intr(struct nvkm_subdev *subdev)
 
 	if (show) {
 		nvkm_error(subdev, "ch %d [%s] %08x %08x %08x %08x\n",
-			   fifo->chid(fifo, engctx),
-			   nvkm_client_name(engctx), stat, type, mthd, data);
+			   mpeg->chan ? mpeg->chan->fifo->chid : -1,
+			   nvkm_client_name(mpeg->chan),
+			   stat, type, mthd, data);
 	}
 
-	spin_unlock_irqrestore(&nv_engine(mpeg)->lock, flags);
+	spin_unlock_irqrestore(&mpeg->base.engine.lock, flags);
 }
 
 static int
@@ -252,6 +251,7 @@ nv31_mpeg_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
+	mpeg->mthd_dma = nv31_mpeg_mthd_dma;
 	nv_subdev(mpeg)->unit = 0x00000002;
 	nv_subdev(mpeg)->intr = nv31_mpeg_intr;
 	nv_engine(mpeg)->cclass = &nv31_mpeg_cclass;

commit aa35888ff024b18c7b6b29eb773a221f642987f7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/object: rename some functions to avoid upcoming conflicts
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index 1586213b0830..0f02b281f34e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -173,8 +173,8 @@ nv31_mpeg_cclass = {
 	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv31_mpeg_context_ctor,
 		.dtor = nv31_mpeg_context_dtor,
-		.init = nvkm_object_init,
-		.fini = nvkm_object_fini,
+		.init = _nvkm_object_init,
+		.fini = _nvkm_object_fini,
 	},
 };
 

commit 572fb13db2a9dc5336a4b769d60428bc9cff0af6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:14 2015 +1000

    drm/nouveau/mpeg: switch to gpuobj accessor macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index d4d1abba02f4..1586213b0830 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -49,10 +49,12 @@ nv31_mpeg_object_ctor(struct nvkm_object *parent,
 	if (ret)
 		return ret;
 
-	nv_wo32(obj, 0x00, nv_mclass(obj));
-	nv_wo32(obj, 0x04, 0x00000000);
-	nv_wo32(obj, 0x08, 0x00000000);
-	nv_wo32(obj, 0x0c, 0x00000000);
+	nvkm_kmap(obj);
+	nvkm_wo32(obj, 0x00, nv_mclass(obj));
+	nvkm_wo32(obj, 0x04, 0x00000000);
+	nvkm_wo32(obj, 0x08, 0x00000000);
+	nvkm_wo32(obj, 0x0c, 0x00000000);
+	nvkm_done(obj);
 	return 0;
 }
 

commit a47474261e77b148480daff855e516dc60e80b48
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:13 2015 +1000

    drm/nouveau/imem: remove object accessor functions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index 4ece5c065412..d4d1abba02f4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -63,9 +63,9 @@ nv31_mpeg_mthd_dma(struct nvkm_object *object, u32 mthd, void *arg, u32 len)
 	struct nvkm_device *device = mpeg->base.engine.subdev.device;
 	struct nvkm_instmem *imem = device->imem;
 	u32 inst = *(u32 *)arg << 4;
-	u32 dma0 = nv_ro32(imem, inst + 0);
-	u32 dma1 = nv_ro32(imem, inst + 4);
-	u32 dma2 = nv_ro32(imem, inst + 8);
+	u32 dma0 = imem->func->rd32(imem, inst + 0);
+	u32 dma1 = imem->func->rd32(imem, inst + 4);
+	u32 dma2 = imem->func->rd32(imem, inst + 8);
 	u32 base = (dma2 & 0xfffff000) | (dma0 >> 20);
 	u32 size = dma1 + 1;
 

commit b835c09bc6b87318fd06bfcb9ac4bb59eaa48f57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:13 2015 +1000

    drm/nouveau/mpeg: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index 4ea554e81a29..4ece5c065412 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -229,9 +229,9 @@ nv31_mpeg_intr(struct nvkm_subdev *subdev)
 	nvkm_wr32(device, 0x00b230, 0x00000001);
 
 	if (show) {
-		nv_error(mpeg, "ch %d [%s] 0x%08x 0x%08x 0x%08x 0x%08x\n",
-			 fifo->chid(fifo, engctx),
-			 nvkm_client_name(engctx), stat, type, mthd, data);
+		nvkm_error(subdev, "ch %d [%s] %08x %08x %08x %08x\n",
+			   fifo->chid(fifo, engctx),
+			   nvkm_client_name(engctx), stat, type, mthd, data);
 	}
 
 	spin_unlock_irqrestore(&nv_engine(mpeg)->lock, flags);
@@ -263,7 +263,8 @@ nv31_mpeg_init(struct nvkm_object *object)
 {
 	struct nvkm_engine *engine = nv_engine(object);
 	struct nv31_mpeg *mpeg = (void *)object;
-	struct nvkm_device *device = mpeg->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &mpeg->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	struct nvkm_fb *fb = device->fb;
 	int ret, i;
 
@@ -292,7 +293,8 @@ nv31_mpeg_init(struct nvkm_object *object)
 		if (!(nvkm_rd32(device, 0x00b200) & 0x00000001))
 			break;
 	) < 0) {
-		nv_error(mpeg, "timeout 0x%08x\n", nvkm_rd32(device, 0x00b200));
+		nvkm_error(subdev, "timeout %08x\n",
+			   nvkm_rd32(device, 0x00b200));
 		return -EBUSY;
 	}
 

commit 37eabb030c03539996bff662e4adb078a7f8b2a6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:11 2015 +1000

    drm/nouveau/mpeg: switch to new-style timer macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index 2b86575ddcde..4ea554e81a29 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -288,7 +288,10 @@ nv31_mpeg_init(struct nvkm_object *object)
 	nvkm_wr32(device, 0x00b100, 0xffffffff);
 	nvkm_wr32(device, 0x00b140, 0xffffffff);
 
-	if (!nv_wait(mpeg, 0x00b200, 0x00000001, 0x00000000)) {
+	if (nvkm_msec(device, 2000,
+		if (!(nvkm_rd32(device, 0x00b200) & 0x00000001))
+			break;
+	) < 0) {
 		nv_error(mpeg, "timeout 0x%08x\n", nvkm_rd32(device, 0x00b200));
 		return -EBUSY;
 	}

commit 636e37aa978b4904189710b5b501299bd7404ad5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:10 2015 +1000

    drm/nouveau/mpeg: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index 34dd5f6ac247..2b86575ddcde 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -59,8 +59,9 @@ nv31_mpeg_object_ctor(struct nvkm_object *parent,
 static int
 nv31_mpeg_mthd_dma(struct nvkm_object *object, u32 mthd, void *arg, u32 len)
 {
-	struct nvkm_instmem *imem = nvkm_instmem(object);
 	struct nv31_mpeg *mpeg = (void *)object->engine;
+	struct nvkm_device *device = mpeg->base.engine.subdev.device;
+	struct nvkm_instmem *imem = device->imem;
 	u32 inst = *(u32 *)arg << 4;
 	u32 dma0 = nv_ro32(imem, inst + 0);
 	u32 dma1 = nv_ro32(imem, inst + 4);
@@ -74,22 +75,22 @@ nv31_mpeg_mthd_dma(struct nvkm_object *object, u32 mthd, void *arg, u32 len)
 
 	if (mthd == 0x0190) {
 		/* DMA_CMD */
-		nv_mask(mpeg, 0x00b300, 0x00010000, (dma0 & 0x00030000) ? 0x00010000 : 0);
-		nv_wr32(mpeg, 0x00b334, base);
-		nv_wr32(mpeg, 0x00b324, size);
+		nvkm_mask(device, 0x00b300, 0x00010000, (dma0 & 0x00030000) ? 0x00010000 : 0);
+		nvkm_wr32(device, 0x00b334, base);
+		nvkm_wr32(device, 0x00b324, size);
 	} else
 	if (mthd == 0x01a0) {
 		/* DMA_DATA */
-		nv_mask(mpeg, 0x00b300, 0x00020000, (dma0 & 0x00030000) ? 0x00020000 : 0);
-		nv_wr32(mpeg, 0x00b360, base);
-		nv_wr32(mpeg, 0x00b364, size);
+		nvkm_mask(device, 0x00b300, 0x00020000, (dma0 & 0x00030000) ? 0x00020000 : 0);
+		nvkm_wr32(device, 0x00b360, base);
+		nvkm_wr32(device, 0x00b364, size);
 	} else {
 		/* DMA_IMAGE, VRAM only */
 		if (dma0 & 0x00030000)
 			return -EINVAL;
 
-		nv_wr32(mpeg, 0x00b370, base);
-		nv_wr32(mpeg, 0x00b374, size);
+		nvkm_wr32(device, 0x00b370, base);
+		nvkm_wr32(device, 0x00b374, size);
 	}
 
 	return 0;
@@ -182,25 +183,27 @@ nv31_mpeg_cclass = {
 void
 nv31_mpeg_tile_prog(struct nvkm_engine *engine, int i)
 {
-	struct nvkm_fb_tile *tile = &nvkm_fb(engine)->tile.region[i];
 	struct nv31_mpeg *mpeg = (void *)engine;
+	struct nvkm_device *device = mpeg->base.engine.subdev.device;
+	struct nvkm_fb_tile *tile = &device->fb->tile.region[i];
 
-	nv_wr32(mpeg, 0x00b008 + (i * 0x10), tile->pitch);
-	nv_wr32(mpeg, 0x00b004 + (i * 0x10), tile->limit);
-	nv_wr32(mpeg, 0x00b000 + (i * 0x10), tile->addr);
+	nvkm_wr32(device, 0x00b008 + (i * 0x10), tile->pitch);
+	nvkm_wr32(device, 0x00b004 + (i * 0x10), tile->limit);
+	nvkm_wr32(device, 0x00b000 + (i * 0x10), tile->addr);
 }
 
 void
 nv31_mpeg_intr(struct nvkm_subdev *subdev)
 {
 	struct nv31_mpeg *mpeg = (void *)subdev;
-	struct nvkm_fifo *fifo = nvkm_fifo(subdev);
+	struct nvkm_device *device = mpeg->base.engine.subdev.device;
+	struct nvkm_fifo *fifo = device->fifo;
 	struct nvkm_handle *handle;
 	struct nvkm_object *engctx;
-	u32 stat = nv_rd32(mpeg, 0x00b100);
-	u32 type = nv_rd32(mpeg, 0x00b230);
-	u32 mthd = nv_rd32(mpeg, 0x00b234);
-	u32 data = nv_rd32(mpeg, 0x00b238);
+	u32 stat = nvkm_rd32(device, 0x00b100);
+	u32 type = nvkm_rd32(device, 0x00b230);
+	u32 mthd = nvkm_rd32(device, 0x00b234);
+	u32 data = nvkm_rd32(device, 0x00b238);
 	u32 show = stat;
 	unsigned long flags;
 
@@ -210,7 +213,7 @@ nv31_mpeg_intr(struct nvkm_subdev *subdev)
 	if (stat & 0x01000000) {
 		/* happens on initial binding of the object */
 		if (type == 0x00000020 && mthd == 0x0000) {
-			nv_mask(mpeg, 0x00b308, 0x00000000, 0x00000000);
+			nvkm_mask(device, 0x00b308, 0x00000000, 0x00000000);
 			show &= ~0x01000000;
 		}
 
@@ -222,8 +225,8 @@ nv31_mpeg_intr(struct nvkm_subdev *subdev)
 		}
 	}
 
-	nv_wr32(mpeg, 0x00b100, stat);
-	nv_wr32(mpeg, 0x00b230, 0x00000001);
+	nvkm_wr32(device, 0x00b100, stat);
+	nvkm_wr32(device, 0x00b230, 0x00000001);
 
 	if (show) {
 		nv_error(mpeg, "ch %d [%s] 0x%08x 0x%08x 0x%08x 0x%08x\n",
@@ -260,7 +263,8 @@ nv31_mpeg_init(struct nvkm_object *object)
 {
 	struct nvkm_engine *engine = nv_engine(object);
 	struct nv31_mpeg *mpeg = (void *)object;
-	struct nvkm_fb *fb = nvkm_fb(object);
+	struct nvkm_device *device = mpeg->base.engine.subdev.device;
+	struct nvkm_fb *fb = device->fb;
 	int ret, i;
 
 	ret = nvkm_mpeg_init(&mpeg->base);
@@ -268,24 +272,24 @@ nv31_mpeg_init(struct nvkm_object *object)
 		return ret;
 
 	/* VPE init */
-	nv_wr32(mpeg, 0x00b0e0, 0x00000020); /* nvidia: rd 0x01, wr 0x20 */
-	nv_wr32(mpeg, 0x00b0e8, 0x00000020); /* nvidia: rd 0x01, wr 0x20 */
+	nvkm_wr32(device, 0x00b0e0, 0x00000020); /* nvidia: rd 0x01, wr 0x20 */
+	nvkm_wr32(device, 0x00b0e8, 0x00000020); /* nvidia: rd 0x01, wr 0x20 */
 
 	for (i = 0; i < fb->tile.regions; i++)
 		engine->tile_prog(engine, i);
 
 	/* PMPEG init */
-	nv_wr32(mpeg, 0x00b32c, 0x00000000);
-	nv_wr32(mpeg, 0x00b314, 0x00000100);
-	nv_wr32(mpeg, 0x00b220, 0x00000031);
-	nv_wr32(mpeg, 0x00b300, 0x02001ec1);
-	nv_mask(mpeg, 0x00b32c, 0x00000001, 0x00000001);
+	nvkm_wr32(device, 0x00b32c, 0x00000000);
+	nvkm_wr32(device, 0x00b314, 0x00000100);
+	nvkm_wr32(device, 0x00b220, 0x00000031);
+	nvkm_wr32(device, 0x00b300, 0x02001ec1);
+	nvkm_mask(device, 0x00b32c, 0x00000001, 0x00000001);
 
-	nv_wr32(mpeg, 0x00b100, 0xffffffff);
-	nv_wr32(mpeg, 0x00b140, 0xffffffff);
+	nvkm_wr32(device, 0x00b100, 0xffffffff);
+	nvkm_wr32(device, 0x00b140, 0xffffffff);
 
 	if (!nv_wait(mpeg, 0x00b200, 0x00000001, 0x00000000)) {
-		nv_error(mpeg, "timeout 0x%08x\n", nv_rd32(mpeg, 0x00b200));
+		nv_error(mpeg, "timeout 0x%08x\n", nvkm_rd32(device, 0x00b200));
 		return -EBUSY;
 	}
 

commit b19de4f3d787947224e89447505dd3c99b304d7b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:08 2015 +1000

    drm/nouveau/mpeg: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index 4199684a4b28..34dd5f6ac247 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -60,7 +60,7 @@ static int
 nv31_mpeg_mthd_dma(struct nvkm_object *object, u32 mthd, void *arg, u32 len)
 {
 	struct nvkm_instmem *imem = nvkm_instmem(object);
-	struct nv31_mpeg_priv *priv = (void *)object->engine;
+	struct nv31_mpeg *mpeg = (void *)object->engine;
 	u32 inst = *(u32 *)arg << 4;
 	u32 dma0 = nv_ro32(imem, inst + 0);
 	u32 dma1 = nv_ro32(imem, inst + 4);
@@ -74,22 +74,22 @@ nv31_mpeg_mthd_dma(struct nvkm_object *object, u32 mthd, void *arg, u32 len)
 
 	if (mthd == 0x0190) {
 		/* DMA_CMD */
-		nv_mask(priv, 0x00b300, 0x00010000, (dma0 & 0x00030000) ? 0x00010000 : 0);
-		nv_wr32(priv, 0x00b334, base);
-		nv_wr32(priv, 0x00b324, size);
+		nv_mask(mpeg, 0x00b300, 0x00010000, (dma0 & 0x00030000) ? 0x00010000 : 0);
+		nv_wr32(mpeg, 0x00b334, base);
+		nv_wr32(mpeg, 0x00b324, size);
 	} else
 	if (mthd == 0x01a0) {
 		/* DMA_DATA */
-		nv_mask(priv, 0x00b300, 0x00020000, (dma0 & 0x00030000) ? 0x00020000 : 0);
-		nv_wr32(priv, 0x00b360, base);
-		nv_wr32(priv, 0x00b364, size);
+		nv_mask(mpeg, 0x00b300, 0x00020000, (dma0 & 0x00030000) ? 0x00020000 : 0);
+		nv_wr32(mpeg, 0x00b360, base);
+		nv_wr32(mpeg, 0x00b364, size);
 	} else {
 		/* DMA_IMAGE, VRAM only */
 		if (dma0 & 0x00030000)
 			return -EINVAL;
 
-		nv_wr32(priv, 0x00b370, base);
-		nv_wr32(priv, 0x00b374, size);
+		nv_wr32(mpeg, 0x00b370, base);
+		nv_wr32(mpeg, 0x00b374, size);
 	}
 
 	return 0;
@@ -129,7 +129,7 @@ nv31_mpeg_context_ctor(struct nvkm_object *parent,
 		       struct nvkm_oclass *oclass, void *data, u32 size,
 		       struct nvkm_object **pobject)
 {
-	struct nv31_mpeg_priv *priv = (void *)engine;
+	struct nv31_mpeg *mpeg = (void *)engine;
 	struct nv31_mpeg_chan *chan;
 	unsigned long flags;
 	int ret;
@@ -139,28 +139,28 @@ nv31_mpeg_context_ctor(struct nvkm_object *parent,
 	if (ret)
 		return ret;
 
-	spin_lock_irqsave(&nv_engine(priv)->lock, flags);
-	if (priv->chan) {
-		spin_unlock_irqrestore(&nv_engine(priv)->lock, flags);
+	spin_lock_irqsave(&nv_engine(mpeg)->lock, flags);
+	if (mpeg->chan) {
+		spin_unlock_irqrestore(&nv_engine(mpeg)->lock, flags);
 		nvkm_object_destroy(&chan->base);
 		*pobject = NULL;
 		return -EBUSY;
 	}
-	priv->chan = chan;
-	spin_unlock_irqrestore(&nv_engine(priv)->lock, flags);
+	mpeg->chan = chan;
+	spin_unlock_irqrestore(&nv_engine(mpeg)->lock, flags);
 	return 0;
 }
 
 static void
 nv31_mpeg_context_dtor(struct nvkm_object *object)
 {
-	struct nv31_mpeg_priv *priv = (void *)object->engine;
+	struct nv31_mpeg *mpeg = (void *)object->engine;
 	struct nv31_mpeg_chan *chan = (void *)object;
 	unsigned long flags;
 
-	spin_lock_irqsave(&nv_engine(priv)->lock, flags);
-	priv->chan = NULL;
-	spin_unlock_irqrestore(&nv_engine(priv)->lock, flags);
+	spin_lock_irqsave(&nv_engine(mpeg)->lock, flags);
+	mpeg->chan = NULL;
+	spin_unlock_irqrestore(&nv_engine(mpeg)->lock, flags);
 	nvkm_object_destroy(&chan->base);
 }
 
@@ -183,34 +183,34 @@ void
 nv31_mpeg_tile_prog(struct nvkm_engine *engine, int i)
 {
 	struct nvkm_fb_tile *tile = &nvkm_fb(engine)->tile.region[i];
-	struct nv31_mpeg_priv *priv = (void *)engine;
+	struct nv31_mpeg *mpeg = (void *)engine;
 
-	nv_wr32(priv, 0x00b008 + (i * 0x10), tile->pitch);
-	nv_wr32(priv, 0x00b004 + (i * 0x10), tile->limit);
-	nv_wr32(priv, 0x00b000 + (i * 0x10), tile->addr);
+	nv_wr32(mpeg, 0x00b008 + (i * 0x10), tile->pitch);
+	nv_wr32(mpeg, 0x00b004 + (i * 0x10), tile->limit);
+	nv_wr32(mpeg, 0x00b000 + (i * 0x10), tile->addr);
 }
 
 void
 nv31_mpeg_intr(struct nvkm_subdev *subdev)
 {
-	struct nv31_mpeg_priv *priv = (void *)subdev;
+	struct nv31_mpeg *mpeg = (void *)subdev;
 	struct nvkm_fifo *fifo = nvkm_fifo(subdev);
 	struct nvkm_handle *handle;
 	struct nvkm_object *engctx;
-	u32 stat = nv_rd32(priv, 0x00b100);
-	u32 type = nv_rd32(priv, 0x00b230);
-	u32 mthd = nv_rd32(priv, 0x00b234);
-	u32 data = nv_rd32(priv, 0x00b238);
+	u32 stat = nv_rd32(mpeg, 0x00b100);
+	u32 type = nv_rd32(mpeg, 0x00b230);
+	u32 mthd = nv_rd32(mpeg, 0x00b234);
+	u32 data = nv_rd32(mpeg, 0x00b238);
 	u32 show = stat;
 	unsigned long flags;
 
-	spin_lock_irqsave(&nv_engine(priv)->lock, flags);
-	engctx = nv_object(priv->chan);
+	spin_lock_irqsave(&nv_engine(mpeg)->lock, flags);
+	engctx = nv_object(mpeg->chan);
 
 	if (stat & 0x01000000) {
 		/* happens on initial binding of the object */
 		if (type == 0x00000020 && mthd == 0x0000) {
-			nv_mask(priv, 0x00b308, 0x00000000, 0x00000000);
+			nv_mask(mpeg, 0x00b308, 0x00000000, 0x00000000);
 			show &= ~0x01000000;
 		}
 
@@ -222,16 +222,16 @@ nv31_mpeg_intr(struct nvkm_subdev *subdev)
 		}
 	}
 
-	nv_wr32(priv, 0x00b100, stat);
-	nv_wr32(priv, 0x00b230, 0x00000001);
+	nv_wr32(mpeg, 0x00b100, stat);
+	nv_wr32(mpeg, 0x00b230, 0x00000001);
 
 	if (show) {
-		nv_error(priv, "ch %d [%s] 0x%08x 0x%08x 0x%08x 0x%08x\n",
+		nv_error(mpeg, "ch %d [%s] 0x%08x 0x%08x 0x%08x 0x%08x\n",
 			 fifo->chid(fifo, engctx),
 			 nvkm_client_name(engctx), stat, type, mthd, data);
 	}
 
-	spin_unlock_irqrestore(&nv_engine(priv)->lock, flags);
+	spin_unlock_irqrestore(&nv_engine(mpeg)->lock, flags);
 }
 
 static int
@@ -239,19 +239,19 @@ nv31_mpeg_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_oclass *oclass, void *data, u32 size,
 	       struct nvkm_object **pobject)
 {
-	struct nv31_mpeg_priv *priv;
+	struct nv31_mpeg *mpeg;
 	int ret;
 
-	ret = nvkm_mpeg_create(parent, engine, oclass, &priv);
-	*pobject = nv_object(priv);
+	ret = nvkm_mpeg_create(parent, engine, oclass, &mpeg);
+	*pobject = nv_object(mpeg);
 	if (ret)
 		return ret;
 
-	nv_subdev(priv)->unit = 0x00000002;
-	nv_subdev(priv)->intr = nv31_mpeg_intr;
-	nv_engine(priv)->cclass = &nv31_mpeg_cclass;
-	nv_engine(priv)->sclass = nv31_mpeg_sclass;
-	nv_engine(priv)->tile_prog = nv31_mpeg_tile_prog;
+	nv_subdev(mpeg)->unit = 0x00000002;
+	nv_subdev(mpeg)->intr = nv31_mpeg_intr;
+	nv_engine(mpeg)->cclass = &nv31_mpeg_cclass;
+	nv_engine(mpeg)->sclass = nv31_mpeg_sclass;
+	nv_engine(mpeg)->tile_prog = nv31_mpeg_tile_prog;
 	return 0;
 }
 
@@ -259,33 +259,33 @@ int
 nv31_mpeg_init(struct nvkm_object *object)
 {
 	struct nvkm_engine *engine = nv_engine(object);
-	struct nv31_mpeg_priv *priv = (void *)object;
+	struct nv31_mpeg *mpeg = (void *)object;
 	struct nvkm_fb *fb = nvkm_fb(object);
 	int ret, i;
 
-	ret = nvkm_mpeg_init(&priv->base);
+	ret = nvkm_mpeg_init(&mpeg->base);
 	if (ret)
 		return ret;
 
 	/* VPE init */
-	nv_wr32(priv, 0x00b0e0, 0x00000020); /* nvidia: rd 0x01, wr 0x20 */
-	nv_wr32(priv, 0x00b0e8, 0x00000020); /* nvidia: rd 0x01, wr 0x20 */
+	nv_wr32(mpeg, 0x00b0e0, 0x00000020); /* nvidia: rd 0x01, wr 0x20 */
+	nv_wr32(mpeg, 0x00b0e8, 0x00000020); /* nvidia: rd 0x01, wr 0x20 */
 
 	for (i = 0; i < fb->tile.regions; i++)
 		engine->tile_prog(engine, i);
 
 	/* PMPEG init */
-	nv_wr32(priv, 0x00b32c, 0x00000000);
-	nv_wr32(priv, 0x00b314, 0x00000100);
-	nv_wr32(priv, 0x00b220, 0x00000031);
-	nv_wr32(priv, 0x00b300, 0x02001ec1);
-	nv_mask(priv, 0x00b32c, 0x00000001, 0x00000001);
+	nv_wr32(mpeg, 0x00b32c, 0x00000000);
+	nv_wr32(mpeg, 0x00b314, 0x00000100);
+	nv_wr32(mpeg, 0x00b220, 0x00000031);
+	nv_wr32(mpeg, 0x00b300, 0x02001ec1);
+	nv_mask(mpeg, 0x00b32c, 0x00000001, 0x00000001);
 
-	nv_wr32(priv, 0x00b100, 0xffffffff);
-	nv_wr32(priv, 0x00b140, 0xffffffff);
+	nv_wr32(mpeg, 0x00b100, 0xffffffff);
+	nv_wr32(mpeg, 0x00b140, 0xffffffff);
 
-	if (!nv_wait(priv, 0x00b200, 0x00000001, 0x00000000)) {
-		nv_error(priv, "timeout 0x%08x\n", nv_rd32(priv, 0x00b200));
+	if (!nv_wait(mpeg, 0x00b200, 0x00000001, 0x00000000)) {
+		nv_error(mpeg, "timeout 0x%08x\n", nv_rd32(mpeg, 0x00b200));
 		return -EBUSY;
 	}
 

commit 6189f1b0938dc0621c27494031b83ffae566e318
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/fifo: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index 891004157ea8..4199684a4b28 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -194,7 +194,7 @@ void
 nv31_mpeg_intr(struct nvkm_subdev *subdev)
 {
 	struct nv31_mpeg_priv *priv = (void *)subdev;
-	struct nvkm_fifo *pfifo = nvkm_fifo(subdev);
+	struct nvkm_fifo *fifo = nvkm_fifo(subdev);
 	struct nvkm_handle *handle;
 	struct nvkm_object *engctx;
 	u32 stat = nv_rd32(priv, 0x00b100);
@@ -227,7 +227,7 @@ nv31_mpeg_intr(struct nvkm_subdev *subdev)
 
 	if (show) {
 		nv_error(priv, "ch %d [%s] 0x%08x 0x%08x 0x%08x 0x%08x\n",
-			 pfifo->chid(pfifo, engctx),
+			 fifo->chid(fifo, engctx),
 			 nvkm_client_name(engctx), stat, type, mthd, data);
 	}
 

commit b1e4553cb1f9deddbd8c13d95e9cef81967a3f41
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/fb: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index b5bef0718359..891004157ea8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -260,7 +260,7 @@ nv31_mpeg_init(struct nvkm_object *object)
 {
 	struct nvkm_engine *engine = nv_engine(object);
 	struct nv31_mpeg_priv *priv = (void *)object;
-	struct nvkm_fb *pfb = nvkm_fb(object);
+	struct nvkm_fb *fb = nvkm_fb(object);
 	int ret, i;
 
 	ret = nvkm_mpeg_init(&priv->base);
@@ -271,7 +271,7 @@ nv31_mpeg_init(struct nvkm_object *object)
 	nv_wr32(priv, 0x00b0e0, 0x00000020); /* nvidia: rd 0x01, wr 0x20 */
 	nv_wr32(priv, 0x00b0e8, 0x00000020); /* nvidia: rd 0x01, wr 0x20 */
 
-	for (i = 0; i < pfb->tile.regions; i++)
+	for (i = 0; i < fb->tile.regions; i++)
 		engine->tile_prog(engine, i);
 
 	/* PMPEG init */

commit e7c29683fd014dfb9a730086c2c564161264e1ea
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:29:56 2015 +1000

    drm/nouveau/mpeg: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
index d88c700b2f69..b5bef0718359 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -21,35 +21,30 @@
  *
  * Authors: Ben Skeggs
  */
+#include "nv31.h"
 
 #include <core/client.h>
-#include <core/os.h>
-#include <core/engctx.h>
 #include <core/handle.h>
-
+#include <engine/fifo.h>
+#include <subdev/instmem.h>
 #include <subdev/fb.h>
 #include <subdev/timer.h>
-#include <subdev/instmem.h>
-
-#include <engine/fifo.h>
-#include <engine/mpeg.h>
-#include <engine/mpeg/nv31.h>
 
 /*******************************************************************************
  * MPEG object classes
  ******************************************************************************/
 
 static int
-nv31_mpeg_object_ctor(struct nouveau_object *parent,
-		      struct nouveau_object *engine,
-		      struct nouveau_oclass *oclass, void *data, u32 size,
-		      struct nouveau_object **pobject)
+nv31_mpeg_object_ctor(struct nvkm_object *parent,
+		      struct nvkm_object *engine,
+		      struct nvkm_oclass *oclass, void *data, u32 size,
+		      struct nvkm_object **pobject)
 {
-	struct nouveau_gpuobj *obj;
+	struct nvkm_gpuobj *obj;
 	int ret;
 
-	ret = nouveau_gpuobj_create(parent, engine, oclass, 0, parent,
-				    20, 16, 0, &obj);
+	ret = nvkm_gpuobj_create(parent, engine, oclass, 0, parent,
+				 20, 16, 0, &obj);
 	*pobject = nv_object(obj);
 	if (ret)
 		return ret;
@@ -62,9 +57,9 @@ nv31_mpeg_object_ctor(struct nouveau_object *parent,
 }
 
 static int
-nv31_mpeg_mthd_dma(struct nouveau_object *object, u32 mthd, void *arg, u32 len)
+nv31_mpeg_mthd_dma(struct nvkm_object *object, u32 mthd, void *arg, u32 len)
 {
-	struct nouveau_instmem *imem = nouveau_instmem(object);
+	struct nvkm_instmem *imem = nvkm_instmem(object);
 	struct nv31_mpeg_priv *priv = (void *)object->engine;
 	u32 inst = *(u32 *)arg << 4;
 	u32 dma0 = nv_ro32(imem, inst + 0);
@@ -100,17 +95,17 @@ nv31_mpeg_mthd_dma(struct nouveau_object *object, u32 mthd, void *arg, u32 len)
 	return 0;
 }
 
-struct nouveau_ofuncs
+struct nvkm_ofuncs
 nv31_mpeg_ofuncs = {
 	.ctor = nv31_mpeg_object_ctor,
-	.dtor = _nouveau_gpuobj_dtor,
-	.init = _nouveau_gpuobj_init,
-	.fini = _nouveau_gpuobj_fini,
-	.rd32 = _nouveau_gpuobj_rd32,
-	.wr32 = _nouveau_gpuobj_wr32,
+	.dtor = _nvkm_gpuobj_dtor,
+	.init = _nvkm_gpuobj_init,
+	.fini = _nvkm_gpuobj_fini,
+	.rd32 = _nvkm_gpuobj_rd32,
+	.wr32 = _nvkm_gpuobj_wr32,
 };
 
-static struct nouveau_omthds
+static struct nvkm_omthds
 nv31_mpeg_omthds[] = {
 	{ 0x0190, 0x0190, nv31_mpeg_mthd_dma },
 	{ 0x01a0, 0x01a0, nv31_mpeg_mthd_dma },
@@ -118,7 +113,7 @@ nv31_mpeg_omthds[] = {
 	{}
 };
 
-struct nouveau_oclass
+struct nvkm_oclass
 nv31_mpeg_sclass[] = {
 	{ 0x3174, &nv31_mpeg_ofuncs, nv31_mpeg_omthds },
 	{}
@@ -129,17 +124,17 @@ nv31_mpeg_sclass[] = {
  ******************************************************************************/
 
 static int
-nv31_mpeg_context_ctor(struct nouveau_object *parent,
-		       struct nouveau_object *engine,
-		       struct nouveau_oclass *oclass, void *data, u32 size,
-		       struct nouveau_object **pobject)
+nv31_mpeg_context_ctor(struct nvkm_object *parent,
+		       struct nvkm_object *engine,
+		       struct nvkm_oclass *oclass, void *data, u32 size,
+		       struct nvkm_object **pobject)
 {
 	struct nv31_mpeg_priv *priv = (void *)engine;
 	struct nv31_mpeg_chan *chan;
 	unsigned long flags;
 	int ret;
 
-	ret = nouveau_object_create(parent, engine, oclass, 0, &chan);
+	ret = nvkm_object_create(parent, engine, oclass, 0, &chan);
 	*pobject = nv_object(chan);
 	if (ret)
 		return ret;
@@ -147,7 +142,7 @@ nv31_mpeg_context_ctor(struct nouveau_object *parent,
 	spin_lock_irqsave(&nv_engine(priv)->lock, flags);
 	if (priv->chan) {
 		spin_unlock_irqrestore(&nv_engine(priv)->lock, flags);
-		nouveau_object_destroy(&chan->base);
+		nvkm_object_destroy(&chan->base);
 		*pobject = NULL;
 		return -EBUSY;
 	}
@@ -157,7 +152,7 @@ nv31_mpeg_context_ctor(struct nouveau_object *parent,
 }
 
 static void
-nv31_mpeg_context_dtor(struct nouveau_object *object)
+nv31_mpeg_context_dtor(struct nvkm_object *object)
 {
 	struct nv31_mpeg_priv *priv = (void *)object->engine;
 	struct nv31_mpeg_chan *chan = (void *)object;
@@ -166,17 +161,17 @@ nv31_mpeg_context_dtor(struct nouveau_object *object)
 	spin_lock_irqsave(&nv_engine(priv)->lock, flags);
 	priv->chan = NULL;
 	spin_unlock_irqrestore(&nv_engine(priv)->lock, flags);
-	nouveau_object_destroy(&chan->base);
+	nvkm_object_destroy(&chan->base);
 }
 
-struct nouveau_oclass
+struct nvkm_oclass
 nv31_mpeg_cclass = {
 	.handle = NV_ENGCTX(MPEG, 0x31),
-	.ofuncs = &(struct nouveau_ofuncs) {
+	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv31_mpeg_context_ctor,
 		.dtor = nv31_mpeg_context_dtor,
-		.init = nouveau_object_init,
-		.fini = nouveau_object_fini,
+		.init = nvkm_object_init,
+		.fini = nvkm_object_fini,
 	},
 };
 
@@ -185,9 +180,9 @@ nv31_mpeg_cclass = {
  ******************************************************************************/
 
 void
-nv31_mpeg_tile_prog(struct nouveau_engine *engine, int i)
+nv31_mpeg_tile_prog(struct nvkm_engine *engine, int i)
 {
-	struct nouveau_fb_tile *tile = &nouveau_fb(engine)->tile.region[i];
+	struct nvkm_fb_tile *tile = &nvkm_fb(engine)->tile.region[i];
 	struct nv31_mpeg_priv *priv = (void *)engine;
 
 	nv_wr32(priv, 0x00b008 + (i * 0x10), tile->pitch);
@@ -196,12 +191,12 @@ nv31_mpeg_tile_prog(struct nouveau_engine *engine, int i)
 }
 
 void
-nv31_mpeg_intr(struct nouveau_subdev *subdev)
+nv31_mpeg_intr(struct nvkm_subdev *subdev)
 {
 	struct nv31_mpeg_priv *priv = (void *)subdev;
-	struct nouveau_fifo *pfifo = nouveau_fifo(subdev);
-	struct nouveau_handle *handle;
-	struct nouveau_object *engctx;
+	struct nvkm_fifo *pfifo = nvkm_fifo(subdev);
+	struct nvkm_handle *handle;
+	struct nvkm_object *engctx;
 	u32 stat = nv_rd32(priv, 0x00b100);
 	u32 type = nv_rd32(priv, 0x00b230);
 	u32 mthd = nv_rd32(priv, 0x00b234);
@@ -220,10 +215,10 @@ nv31_mpeg_intr(struct nouveau_subdev *subdev)
 		}
 
 		if (type == 0x00000010 && engctx) {
-			handle = nouveau_handle_get_class(engctx, 0x3174);
+			handle = nvkm_handle_get_class(engctx, 0x3174);
 			if (handle && !nv_call(handle->object, mthd, data))
 				show &= ~0x01000000;
-			nouveau_handle_put(handle);
+			nvkm_handle_put(handle);
 		}
 	}
 
@@ -233,21 +228,21 @@ nv31_mpeg_intr(struct nouveau_subdev *subdev)
 	if (show) {
 		nv_error(priv, "ch %d [%s] 0x%08x 0x%08x 0x%08x 0x%08x\n",
 			 pfifo->chid(pfifo, engctx),
-			 nouveau_client_name(engctx), stat, type, mthd, data);
+			 nvkm_client_name(engctx), stat, type, mthd, data);
 	}
 
 	spin_unlock_irqrestore(&nv_engine(priv)->lock, flags);
 }
 
 static int
-nv31_mpeg_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
-	       struct nouveau_oclass *oclass, void *data, u32 size,
-	       struct nouveau_object **pobject)
+nv31_mpeg_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+	       struct nvkm_oclass *oclass, void *data, u32 size,
+	       struct nvkm_object **pobject)
 {
 	struct nv31_mpeg_priv *priv;
 	int ret;
 
-	ret = nouveau_mpeg_create(parent, engine, oclass, &priv);
+	ret = nvkm_mpeg_create(parent, engine, oclass, &priv);
 	*pobject = nv_object(priv);
 	if (ret)
 		return ret;
@@ -261,14 +256,14 @@ nv31_mpeg_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 }
 
 int
-nv31_mpeg_init(struct nouveau_object *object)
+nv31_mpeg_init(struct nvkm_object *object)
 {
-	struct nouveau_engine *engine = nv_engine(object);
+	struct nvkm_engine *engine = nv_engine(object);
 	struct nv31_mpeg_priv *priv = (void *)object;
-	struct nouveau_fb *pfb = nouveau_fb(object);
+	struct nvkm_fb *pfb = nvkm_fb(object);
 	int ret, i;
 
-	ret = nouveau_mpeg_init(&priv->base);
+	ret = nvkm_mpeg_init(&priv->base);
 	if (ret)
 		return ret;
 
@@ -297,13 +292,13 @@ nv31_mpeg_init(struct nouveau_object *object)
 	return 0;
 }
 
-struct nouveau_oclass
+struct nvkm_oclass
 nv31_mpeg_oclass = {
 	.handle = NV_ENGINE(MPEG, 0x31),
-	.ofuncs = &(struct nouveau_ofuncs) {
+	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv31_mpeg_ctor,
-		.dtor = _nouveau_mpeg_dtor,
+		.dtor = _nvkm_mpeg_dtor,
 		.init = nv31_mpeg_init,
-		.fini = _nouveau_mpeg_fini,
+		.fini = _nvkm_mpeg_fini,
 	},
 };

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
new file mode 100644
index 000000000000..d88c700b2f69
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c
@@ -0,0 +1,309 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <core/client.h>
+#include <core/os.h>
+#include <core/engctx.h>
+#include <core/handle.h>
+
+#include <subdev/fb.h>
+#include <subdev/timer.h>
+#include <subdev/instmem.h>
+
+#include <engine/fifo.h>
+#include <engine/mpeg.h>
+#include <engine/mpeg/nv31.h>
+
+/*******************************************************************************
+ * MPEG object classes
+ ******************************************************************************/
+
+static int
+nv31_mpeg_object_ctor(struct nouveau_object *parent,
+		      struct nouveau_object *engine,
+		      struct nouveau_oclass *oclass, void *data, u32 size,
+		      struct nouveau_object **pobject)
+{
+	struct nouveau_gpuobj *obj;
+	int ret;
+
+	ret = nouveau_gpuobj_create(parent, engine, oclass, 0, parent,
+				    20, 16, 0, &obj);
+	*pobject = nv_object(obj);
+	if (ret)
+		return ret;
+
+	nv_wo32(obj, 0x00, nv_mclass(obj));
+	nv_wo32(obj, 0x04, 0x00000000);
+	nv_wo32(obj, 0x08, 0x00000000);
+	nv_wo32(obj, 0x0c, 0x00000000);
+	return 0;
+}
+
+static int
+nv31_mpeg_mthd_dma(struct nouveau_object *object, u32 mthd, void *arg, u32 len)
+{
+	struct nouveau_instmem *imem = nouveau_instmem(object);
+	struct nv31_mpeg_priv *priv = (void *)object->engine;
+	u32 inst = *(u32 *)arg << 4;
+	u32 dma0 = nv_ro32(imem, inst + 0);
+	u32 dma1 = nv_ro32(imem, inst + 4);
+	u32 dma2 = nv_ro32(imem, inst + 8);
+	u32 base = (dma2 & 0xfffff000) | (dma0 >> 20);
+	u32 size = dma1 + 1;
+
+	/* only allow linear DMA objects */
+	if (!(dma0 & 0x00002000))
+		return -EINVAL;
+
+	if (mthd == 0x0190) {
+		/* DMA_CMD */
+		nv_mask(priv, 0x00b300, 0x00010000, (dma0 & 0x00030000) ? 0x00010000 : 0);
+		nv_wr32(priv, 0x00b334, base);
+		nv_wr32(priv, 0x00b324, size);
+	} else
+	if (mthd == 0x01a0) {
+		/* DMA_DATA */
+		nv_mask(priv, 0x00b300, 0x00020000, (dma0 & 0x00030000) ? 0x00020000 : 0);
+		nv_wr32(priv, 0x00b360, base);
+		nv_wr32(priv, 0x00b364, size);
+	} else {
+		/* DMA_IMAGE, VRAM only */
+		if (dma0 & 0x00030000)
+			return -EINVAL;
+
+		nv_wr32(priv, 0x00b370, base);
+		nv_wr32(priv, 0x00b374, size);
+	}
+
+	return 0;
+}
+
+struct nouveau_ofuncs
+nv31_mpeg_ofuncs = {
+	.ctor = nv31_mpeg_object_ctor,
+	.dtor = _nouveau_gpuobj_dtor,
+	.init = _nouveau_gpuobj_init,
+	.fini = _nouveau_gpuobj_fini,
+	.rd32 = _nouveau_gpuobj_rd32,
+	.wr32 = _nouveau_gpuobj_wr32,
+};
+
+static struct nouveau_omthds
+nv31_mpeg_omthds[] = {
+	{ 0x0190, 0x0190, nv31_mpeg_mthd_dma },
+	{ 0x01a0, 0x01a0, nv31_mpeg_mthd_dma },
+	{ 0x01b0, 0x01b0, nv31_mpeg_mthd_dma },
+	{}
+};
+
+struct nouveau_oclass
+nv31_mpeg_sclass[] = {
+	{ 0x3174, &nv31_mpeg_ofuncs, nv31_mpeg_omthds },
+	{}
+};
+
+/*******************************************************************************
+ * PMPEG context
+ ******************************************************************************/
+
+static int
+nv31_mpeg_context_ctor(struct nouveau_object *parent,
+		       struct nouveau_object *engine,
+		       struct nouveau_oclass *oclass, void *data, u32 size,
+		       struct nouveau_object **pobject)
+{
+	struct nv31_mpeg_priv *priv = (void *)engine;
+	struct nv31_mpeg_chan *chan;
+	unsigned long flags;
+	int ret;
+
+	ret = nouveau_object_create(parent, engine, oclass, 0, &chan);
+	*pobject = nv_object(chan);
+	if (ret)
+		return ret;
+
+	spin_lock_irqsave(&nv_engine(priv)->lock, flags);
+	if (priv->chan) {
+		spin_unlock_irqrestore(&nv_engine(priv)->lock, flags);
+		nouveau_object_destroy(&chan->base);
+		*pobject = NULL;
+		return -EBUSY;
+	}
+	priv->chan = chan;
+	spin_unlock_irqrestore(&nv_engine(priv)->lock, flags);
+	return 0;
+}
+
+static void
+nv31_mpeg_context_dtor(struct nouveau_object *object)
+{
+	struct nv31_mpeg_priv *priv = (void *)object->engine;
+	struct nv31_mpeg_chan *chan = (void *)object;
+	unsigned long flags;
+
+	spin_lock_irqsave(&nv_engine(priv)->lock, flags);
+	priv->chan = NULL;
+	spin_unlock_irqrestore(&nv_engine(priv)->lock, flags);
+	nouveau_object_destroy(&chan->base);
+}
+
+struct nouveau_oclass
+nv31_mpeg_cclass = {
+	.handle = NV_ENGCTX(MPEG, 0x31),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv31_mpeg_context_ctor,
+		.dtor = nv31_mpeg_context_dtor,
+		.init = nouveau_object_init,
+		.fini = nouveau_object_fini,
+	},
+};
+
+/*******************************************************************************
+ * PMPEG engine/subdev functions
+ ******************************************************************************/
+
+void
+nv31_mpeg_tile_prog(struct nouveau_engine *engine, int i)
+{
+	struct nouveau_fb_tile *tile = &nouveau_fb(engine)->tile.region[i];
+	struct nv31_mpeg_priv *priv = (void *)engine;
+
+	nv_wr32(priv, 0x00b008 + (i * 0x10), tile->pitch);
+	nv_wr32(priv, 0x00b004 + (i * 0x10), tile->limit);
+	nv_wr32(priv, 0x00b000 + (i * 0x10), tile->addr);
+}
+
+void
+nv31_mpeg_intr(struct nouveau_subdev *subdev)
+{
+	struct nv31_mpeg_priv *priv = (void *)subdev;
+	struct nouveau_fifo *pfifo = nouveau_fifo(subdev);
+	struct nouveau_handle *handle;
+	struct nouveau_object *engctx;
+	u32 stat = nv_rd32(priv, 0x00b100);
+	u32 type = nv_rd32(priv, 0x00b230);
+	u32 mthd = nv_rd32(priv, 0x00b234);
+	u32 data = nv_rd32(priv, 0x00b238);
+	u32 show = stat;
+	unsigned long flags;
+
+	spin_lock_irqsave(&nv_engine(priv)->lock, flags);
+	engctx = nv_object(priv->chan);
+
+	if (stat & 0x01000000) {
+		/* happens on initial binding of the object */
+		if (type == 0x00000020 && mthd == 0x0000) {
+			nv_mask(priv, 0x00b308, 0x00000000, 0x00000000);
+			show &= ~0x01000000;
+		}
+
+		if (type == 0x00000010 && engctx) {
+			handle = nouveau_handle_get_class(engctx, 0x3174);
+			if (handle && !nv_call(handle->object, mthd, data))
+				show &= ~0x01000000;
+			nouveau_handle_put(handle);
+		}
+	}
+
+	nv_wr32(priv, 0x00b100, stat);
+	nv_wr32(priv, 0x00b230, 0x00000001);
+
+	if (show) {
+		nv_error(priv, "ch %d [%s] 0x%08x 0x%08x 0x%08x 0x%08x\n",
+			 pfifo->chid(pfifo, engctx),
+			 nouveau_client_name(engctx), stat, type, mthd, data);
+	}
+
+	spin_unlock_irqrestore(&nv_engine(priv)->lock, flags);
+}
+
+static int
+nv31_mpeg_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+	       struct nouveau_oclass *oclass, void *data, u32 size,
+	       struct nouveau_object **pobject)
+{
+	struct nv31_mpeg_priv *priv;
+	int ret;
+
+	ret = nouveau_mpeg_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	nv_subdev(priv)->unit = 0x00000002;
+	nv_subdev(priv)->intr = nv31_mpeg_intr;
+	nv_engine(priv)->cclass = &nv31_mpeg_cclass;
+	nv_engine(priv)->sclass = nv31_mpeg_sclass;
+	nv_engine(priv)->tile_prog = nv31_mpeg_tile_prog;
+	return 0;
+}
+
+int
+nv31_mpeg_init(struct nouveau_object *object)
+{
+	struct nouveau_engine *engine = nv_engine(object);
+	struct nv31_mpeg_priv *priv = (void *)object;
+	struct nouveau_fb *pfb = nouveau_fb(object);
+	int ret, i;
+
+	ret = nouveau_mpeg_init(&priv->base);
+	if (ret)
+		return ret;
+
+	/* VPE init */
+	nv_wr32(priv, 0x00b0e0, 0x00000020); /* nvidia: rd 0x01, wr 0x20 */
+	nv_wr32(priv, 0x00b0e8, 0x00000020); /* nvidia: rd 0x01, wr 0x20 */
+
+	for (i = 0; i < pfb->tile.regions; i++)
+		engine->tile_prog(engine, i);
+
+	/* PMPEG init */
+	nv_wr32(priv, 0x00b32c, 0x00000000);
+	nv_wr32(priv, 0x00b314, 0x00000100);
+	nv_wr32(priv, 0x00b220, 0x00000031);
+	nv_wr32(priv, 0x00b300, 0x02001ec1);
+	nv_mask(priv, 0x00b32c, 0x00000001, 0x00000001);
+
+	nv_wr32(priv, 0x00b100, 0xffffffff);
+	nv_wr32(priv, 0x00b140, 0xffffffff);
+
+	if (!nv_wait(priv, 0x00b200, 0x00000001, 0x00000000)) {
+		nv_error(priv, "timeout 0x%08x\n", nv_rd32(priv, 0x00b200));
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+struct nouveau_oclass
+nv31_mpeg_oclass = {
+	.handle = NV_ENGINE(MPEG, 0x31),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv31_mpeg_ctor,
+		.dtor = _nouveau_mpeg_dtor,
+		.init = nv31_mpeg_init,
+		.fini = _nouveau_mpeg_fini,
+	},
+};
