commit a8ce8b65e108e49b02e876be410f391fc413fb61
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Feb 12 22:28:13 2019 +1000

    drm/nouveau/disp/gf119-: decode exception reason to human-readable string
    
    We also change the error strings to match NVIDIA's naming.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index def005dd5fda..e21556bf2cb1 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -28,7 +28,6 @@
 #include "rootnv50.h"
 
 #include <core/client.h>
-#include <core/enum.h>
 #include <core/ramht.h>
 #include <subdev/bios.h>
 #include <subdev/bios/disp.h>
@@ -593,12 +592,15 @@ nv50_disp_super(struct work_struct *work)
 	nvkm_wr32(device, 0x610030, 0x80000000);
 }
 
-static const struct nvkm_enum
+const struct nvkm_enum
 nv50_disp_intr_error_type[] = {
-	{ 3, "ILLEGAL_MTHD" },
-	{ 4, "INVALID_VALUE" },
+	{ 0, "NONE" },
+	{ 1, "PUSHBUFFER_ERR" },
+	{ 2, "TRAP" },
+	{ 3, "RESERVED_METHOD" },
+	{ 4, "INVALID_ARG" },
 	{ 5, "INVALID_STATE" },
-	{ 7, "INVALID_HANDLE" },
+	{ 7, "UNRESOLVABLE_HANDLE" },
 	{}
 };
 

commit e04cfdc9b7398c60dbc70212415ea63b6c6a93ae
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Sep 4 15:57:09 2018 +1000

    drm/nouveau/disp: fix DP disable race
    
    If a HPD pulse signalling the need to retrain the link occurs between
    the KMS driver releasing the output and the supervisor interrupt that
    finishes the teardown, it was possible get a NULL-ptr deref.
    
    Avoid this by marking the link as inactive earlier.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index f89c7b977aa5..def005dd5fda 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -501,11 +501,11 @@ nv50_disp_super_2_0(struct nv50_disp *disp, struct nvkm_head *head)
 	nv50_disp_super_ied_off(head, ior, 2);
 
 	/* If we're shutting down the OR's only active head, execute
-	 * the output path's release function.
+	 * the output path's disable function.
 	 */
 	if (ior->arm.head == (1 << head->id)) {
-		if ((outp = ior->arm.outp) && outp->func->release)
-			outp->func->release(outp, ior);
+		if ((outp = ior->arm.outp) && outp->func->disable)
+			outp->func->disable(outp, ior);
 	}
 }
 

commit 290ffeafcc1a953aa287c8a7bf7f6d9af25b7e77
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:47 2018 +1000

    drm/nouveau/disp/gv100: initial support
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 4a37c44fcbed..f89c7b977aa5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -88,6 +88,12 @@ nv50_disp_oneinit_(struct nvkm_disp *base)
 	struct nvkm_device *device = subdev->device;
 	int ret, i;
 
+	if (func->wndw.cnt) {
+		disp->wndw.nr = func->wndw.cnt(&disp->base, &disp->wndw.mask);
+		nvkm_debug(subdev, "Window(s): %d (%08lx)\n",
+			   disp->wndw.nr, disp->wndw.mask);
+	}
+
 	disp->head.nr = func->head.cnt(&disp->base, &disp->head.mask);
 	nvkm_debug(subdev, "  Head(s): %d (%02lx)\n",
 		   disp->head.nr, disp->head.mask);
@@ -133,7 +139,8 @@ nv50_disp_oneinit_(struct nvkm_disp *base)
 	if (ret)
 		return ret;
 
-	return nvkm_ramht_new(device, 0x1000, 0, disp->inst, &disp->ramht);
+	return nvkm_ramht_new(device, func->ramht_size ? func->ramht_size :
+			      0x1000, 0, disp->inst, &disp->ramht);
 }
 
 static const struct nvkm_disp_func

commit 9b096283bf78f659e1286ef9b783b27ecf5a9977
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: simplify definiton of core channels
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 1d2280ab3194..4a37c44fcbed 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -24,6 +24,7 @@
 #include "nv50.h"
 #include "head.h"
 #include "ior.h"
+#include "channv50.h"
 #include "rootnv50.h"
 
 #include <core/client.h>

commit bb3b0a422074606400e6aff216300bb4f012b22a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: initialise from the engine, rather than the user object
    
    Engines are initialised on an as-needed basis, so this results in the
    same behaviour, whilst allowing us to simplify things a bit.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index c0faa3908a00..1d2280ab3194 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -28,7 +28,7 @@
 
 #include <core/client.h>
 #include <core/enum.h>
-#include <core/gpuobj.h>
+#include <core/ramht.h>
 #include <subdev/bios.h>
 #include <subdev/bios/disp.h>
 #include <subdev/bios/init.h>
@@ -49,13 +49,32 @@ nv50_disp_intr_(struct nvkm_disp *base)
 	disp->func->intr(disp);
 }
 
+static void
+nv50_disp_fini_(struct nvkm_disp *base)
+{
+	struct nv50_disp *disp = nv50_disp(base);
+	disp->func->fini(disp);
+}
+
+static int
+nv50_disp_init_(struct nvkm_disp *base)
+{
+	struct nv50_disp *disp = nv50_disp(base);
+	return disp->func->init(disp);
+}
+
 static void *
 nv50_disp_dtor_(struct nvkm_disp *base)
 {
 	struct nv50_disp *disp = nv50_disp(base);
+
+	nvkm_ramht_del(&disp->ramht);
+	nvkm_gpuobj_del(&disp->inst);
+
 	nvkm_event_fini(&disp->uevent);
 	if (disp->wq)
 		destroy_workqueue(disp->wq);
+
 	return disp;
 }
 
@@ -65,6 +84,7 @@ nv50_disp_oneinit_(struct nvkm_disp *base)
 	struct nv50_disp *disp = nv50_disp(base);
 	const struct nv50_disp_func *func = disp->func;
 	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	int ret, i;
 
 	disp->head.nr = func->head.cnt(&disp->base, &disp->head.mask);
@@ -107,13 +127,20 @@ nv50_disp_oneinit_(struct nvkm_disp *base)
 			return ret;
 	}
 
-	return 0;
+	ret = nvkm_gpuobj_new(device, 0x10000, 0x10000, false, NULL,
+			      &disp->inst);
+	if (ret)
+		return ret;
+
+	return nvkm_ramht_new(device, 0x1000, 0, disp->inst, &disp->ramht);
 }
 
 static const struct nvkm_disp_func
 nv50_disp_ = {
 	.dtor = nv50_disp_dtor_,
 	.oneinit = nv50_disp_oneinit_,
+	.init = nv50_disp_init_,
+	.fini = nv50_disp_fini_,
 	.intr = nv50_disp_intr_,
 	.root = nv50_disp_root_,
 };
@@ -643,8 +670,84 @@ nv50_disp_intr(struct nv50_disp *disp)
 	}
 }
 
+void
+nv50_disp_fini(struct nv50_disp *disp)
+{
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	/* disable all interrupts */
+	nvkm_wr32(device, 0x610024, 0x00000000);
+	nvkm_wr32(device, 0x610020, 0x00000000);
+}
+
+int
+nv50_disp_init(struct nv50_disp *disp)
+{
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_head *head;
+	u32 tmp;
+	int i;
+
+	/* The below segments of code copying values from one register to
+	 * another appear to inform EVO of the display capabilities or
+	 * something similar.  NFI what the 0x614004 caps are for..
+	 */
+	tmp = nvkm_rd32(device, 0x614004);
+	nvkm_wr32(device, 0x610184, tmp);
+
+	/* ... CRTC caps */
+	list_for_each_entry(head, &disp->base.head, head) {
+		tmp = nvkm_rd32(device, 0x616100 + (head->id * 0x800));
+		nvkm_wr32(device, 0x610190 + (head->id * 0x10), tmp);
+		tmp = nvkm_rd32(device, 0x616104 + (head->id * 0x800));
+		nvkm_wr32(device, 0x610194 + (head->id * 0x10), tmp);
+		tmp = nvkm_rd32(device, 0x616108 + (head->id * 0x800));
+		nvkm_wr32(device, 0x610198 + (head->id * 0x10), tmp);
+		tmp = nvkm_rd32(device, 0x61610c + (head->id * 0x800));
+		nvkm_wr32(device, 0x61019c + (head->id * 0x10), tmp);
+	}
+
+	/* ... DAC caps */
+	for (i = 0; i < disp->dac.nr; i++) {
+		tmp = nvkm_rd32(device, 0x61a000 + (i * 0x800));
+		nvkm_wr32(device, 0x6101d0 + (i * 0x04), tmp);
+	}
+
+	/* ... SOR caps */
+	for (i = 0; i < disp->sor.nr; i++) {
+		tmp = nvkm_rd32(device, 0x61c000 + (i * 0x800));
+		nvkm_wr32(device, 0x6101e0 + (i * 0x04), tmp);
+	}
+
+	/* ... PIOR caps */
+	for (i = 0; i < disp->pior.nr; i++) {
+		tmp = nvkm_rd32(device, 0x61e000 + (i * 0x800));
+		nvkm_wr32(device, 0x6101f0 + (i * 0x04), tmp);
+	}
+
+	/* steal display away from vbios, or something like that */
+	if (nvkm_rd32(device, 0x610024) & 0x00000100) {
+		nvkm_wr32(device, 0x610024, 0x00000100);
+		nvkm_mask(device, 0x6194e8, 0x00000001, 0x00000000);
+		if (nvkm_msec(device, 2000,
+			if (!(nvkm_rd32(device, 0x6194e8) & 0x00000002))
+				break;
+		) < 0)
+			return -EBUSY;
+	}
+
+	/* point at display engine memory area (hash table, objects) */
+	nvkm_wr32(device, 0x610010, (disp->inst->addr >> 8) | 9);
+
+	/* enable supervisor interrupts, disable everything else */
+	nvkm_wr32(device, 0x61002c, 0x00000370);
+	nvkm_wr32(device, 0x610028, 0x00000000);
+	return 0;
+}
+
 static const struct nv50_disp_func
 nv50_disp = {
+	.init = nv50_disp_init,
+	.fini = nv50_disp_fini,
 	.intr = nv50_disp_intr,
 	.uevent = &nv50_disp_chan_uevent,
 	.super = nv50_disp_super,

commit f5e088d6f0b4d969b2e7d8f931af082ba2527a56
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: fetch mask of available piors during oneinit
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 1e32814488bf..c0faa3908a00 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -87,10 +87,15 @@ nv50_disp_oneinit_(struct nvkm_disp *base)
 		}
 	}
 
-	for (i = 0; func->pior.new && i < func->pior.nr; i++) {
-		ret = func->pior.new(&disp->base, i);
-		if (ret)
-			return ret;
+	if (func->pior.cnt) {
+		disp->pior.nr = func->pior.cnt(&disp->base, &disp->pior.mask);
+		nvkm_debug(subdev, "  PIOR(s): %d (%02lx)\n",
+			   disp->pior.nr, disp->pior.mask);
+		for_each_set_bit(i, &disp->pior.mask, disp->pior.nr) {
+			ret = func->pior.new(&disp->base, i);
+			if (ret)
+				return ret;
+		}
 	}
 
 	disp->sor.nr = func->sor.cnt(&disp->base, &disp->sor.mask);
@@ -647,7 +652,7 @@ nv50_disp = {
 	.head = { .cnt = nv50_head_cnt, .new = nv50_head_new },
 	.dac = { .cnt = nv50_dac_cnt, .new = nv50_dac_new },
 	.sor = { .cnt = nv50_sor_cnt, .new = nv50_sor_new },
-	.pior = { .nr = 3, .new = nv50_pior_new },
+	.pior = { .cnt = nv50_pior_cnt, .new = nv50_pior_new },
 };
 
 int

commit 9fe4e177045f4b5af25d25859e30450ff1f18be9
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: fetch mask of available sors during oneinit
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 500ef8da696a..1e32814488bf 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -93,7 +93,10 @@ nv50_disp_oneinit_(struct nvkm_disp *base)
 			return ret;
 	}
 
-	for (i = 0; func->sor.new && i < func->sor.nr; i++) {
+	disp->sor.nr = func->sor.cnt(&disp->base, &disp->sor.mask);
+	nvkm_debug(subdev, "   SOR(s): %d (%02lx)\n",
+		   disp->sor.nr, disp->sor.mask);
+	for_each_set_bit(i, &disp->sor.mask, disp->sor.nr) {
 		ret = func->sor.new(&disp->base, i);
 		if (ret)
 			return ret;
@@ -643,7 +646,7 @@ nv50_disp = {
 	.root = &nv50_disp_root_oclass,
 	.head = { .cnt = nv50_head_cnt, .new = nv50_head_new },
 	.dac = { .cnt = nv50_dac_cnt, .new = nv50_dac_new },
-	.sor = { .nr = 2, .new = nv50_sor_new },
+	.sor = { .cnt = nv50_sor_cnt, .new = nv50_sor_new },
 	.pior = { .nr = 3, .new = nv50_pior_new },
 };
 

commit bf5d1a6b6a4489b7887589fca6321d4024da71c8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: fetch mask of available dacs during oneinit
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index bf50b7be8826..500ef8da696a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -76,10 +76,15 @@ nv50_disp_oneinit_(struct nvkm_disp *base)
 			return ret;
 	}
 
-	for (i = 0; func->dac.new && i < func->dac.nr; i++) {
-		ret = func->dac.new(&disp->base, i);
-		if (ret)
-			return ret;
+	if (func->dac.cnt) {
+		disp->dac.nr = func->dac.cnt(&disp->base, &disp->dac.mask);
+		nvkm_debug(subdev, "   DAC(s): %d (%02lx)\n",
+			   disp->dac.nr, disp->dac.mask);
+		for_each_set_bit(i, &disp->dac.mask, disp->dac.nr) {
+			ret = func->dac.new(&disp->base, i);
+			if (ret)
+				return ret;
+		}
 	}
 
 	for (i = 0; func->pior.new && i < func->pior.nr; i++) {
@@ -637,7 +642,7 @@ nv50_disp = {
 	.super = nv50_disp_super,
 	.root = &nv50_disp_root_oclass,
 	.head = { .cnt = nv50_head_cnt, .new = nv50_head_new },
-	.dac = { .nr = 3, .new = nv50_dac_new },
+	.dac = { .cnt = nv50_dac_cnt, .new = nv50_dac_new },
 	.sor = { .nr = 2, .new = nv50_sor_new },
 	.pior = { .nr = 3, .new = nv50_pior_new },
 };

commit f7b2ece37fce822692d3d6e616e0d0f3df9d4f49
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: fetch mask of available heads during oneinit
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 43373b366263..bf50b7be8826 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -64,9 +64,13 @@ nv50_disp_oneinit_(struct nvkm_disp *base)
 {
 	struct nv50_disp *disp = nv50_disp(base);
 	const struct nv50_disp_func *func = disp->func;
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
 	int ret, i;
 
-	for (i = 0; func->head.new && i < disp->head.nr; i++) {
+	disp->head.nr = func->head.cnt(&disp->base, &disp->head.mask);
+	nvkm_debug(subdev, "  Head(s): %d (%02lx)\n",
+		   disp->head.nr, disp->head.mask);
+	for_each_set_bit(i, &disp->head.mask, disp->head.nr) {
 		ret = func->head.new(&disp->base, i);
 		if (ret)
 			return ret;
@@ -103,7 +107,7 @@ nv50_disp_ = {
 
 int
 nv50_disp_new_(const struct nv50_disp_func *func, struct nvkm_device *device,
-	       int index, int heads, struct nvkm_disp **pdisp)
+	       int index, struct nvkm_disp **pdisp)
 {
 	struct nv50_disp *disp;
 	int ret;
@@ -122,7 +126,6 @@ nv50_disp_new_(const struct nv50_disp_func *func, struct nvkm_device *device,
 		return -ENOMEM;
 
 	INIT_WORK(&disp->supervisor, func->super);
-	disp->head.nr = heads;
 
 	return nvkm_event_init(func->uevent, 1, ARRAY_SIZE(disp->chan),
 			       &disp->uevent);
@@ -633,7 +636,7 @@ nv50_disp = {
 	.uevent = &nv50_disp_chan_uevent,
 	.super = nv50_disp_super,
 	.root = &nv50_disp_root_oclass,
-	.head.new = nv50_head_new,
+	.head = { .cnt = nv50_head_cnt, .new = nv50_head_new },
 	.dac = { .nr = 3, .new = nv50_dac_new },
 	.sor = { .nr = 2, .new = nv50_sor_new },
 	.pior = { .nr = 3, .new = nv50_pior_new },
@@ -642,5 +645,5 @@ nv50_disp = {
 int
 nv50_disp_new(struct nvkm_device *device, int index, struct nvkm_disp **pdisp)
 {
-	return nv50_disp_new_(&nv50_disp, device, index, 2, pdisp);
+	return nv50_disp_new_(&nv50_disp, device, index, pdisp);
 }

commit 3b9ba66ab0e027e6d7a2b9b62cbb5cd547421ebd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: delay subunit construction until oneinit
    
    We should be reading registers to determine which subunits are really
    present on a given board, and this needs to be done after DEVINIT.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 0c570dbd3021..43373b366263 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -59,9 +59,44 @@ nv50_disp_dtor_(struct nvkm_disp *base)
 	return disp;
 }
 
+static int
+nv50_disp_oneinit_(struct nvkm_disp *base)
+{
+	struct nv50_disp *disp = nv50_disp(base);
+	const struct nv50_disp_func *func = disp->func;
+	int ret, i;
+
+	for (i = 0; func->head.new && i < disp->head.nr; i++) {
+		ret = func->head.new(&disp->base, i);
+		if (ret)
+			return ret;
+	}
+
+	for (i = 0; func->dac.new && i < func->dac.nr; i++) {
+		ret = func->dac.new(&disp->base, i);
+		if (ret)
+			return ret;
+	}
+
+	for (i = 0; func->pior.new && i < func->pior.nr; i++) {
+		ret = func->pior.new(&disp->base, i);
+		if (ret)
+			return ret;
+	}
+
+	for (i = 0; func->sor.new && i < func->sor.nr; i++) {
+		ret = func->sor.new(&disp->base, i);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
 static const struct nvkm_disp_func
 nv50_disp_ = {
 	.dtor = nv50_disp_dtor_,
+	.oneinit = nv50_disp_oneinit_,
 	.intr = nv50_disp_intr_,
 	.root = nv50_disp_root_,
 };
@@ -71,7 +106,7 @@ nv50_disp_new_(const struct nv50_disp_func *func, struct nvkm_device *device,
 	       int index, int heads, struct nvkm_disp **pdisp)
 {
 	struct nv50_disp *disp;
-	int ret, i;
+	int ret;
 
 	if (!(disp = kzalloc(sizeof(*disp), GFP_KERNEL)))
 		return -ENOMEM;
@@ -85,33 +120,12 @@ nv50_disp_new_(const struct nv50_disp_func *func, struct nvkm_device *device,
 	disp->wq = create_singlethread_workqueue("nvkm-disp");
 	if (!disp->wq)
 		return -ENOMEM;
-	INIT_WORK(&disp->supervisor, func->super);
-
-	for (i = 0; func->head.new && i < heads; i++) {
-		ret = func->head.new(&disp->base, i);
-		if (ret)
-			return ret;
-	}
 
-	for (i = 0; func->dac.new && i < func->dac.nr; i++) {
-		ret = func->dac.new(&disp->base, i);
-		if (ret)
-			return ret;
-	}
-
-	for (i = 0; func->pior.new && i < func->pior.nr; i++) {
-		ret = func->pior.new(&disp->base, i);
-		if (ret)
-			return ret;
-	}
-
-	for (i = 0; func->sor.new && i < func->sor.nr; i++) {
-		ret = func->sor.new(&disp->base, i);
-		if (ret)
-			return ret;
-	}
+	INIT_WORK(&disp->supervisor, func->super);
+	disp->head.nr = heads;
 
-	return nvkm_event_init(func->uevent, 1, 1 + (heads * 4), &disp->uevent);
+	return nvkm_event_init(func->uevent, 1, ARRAY_SIZE(disp->chan),
+			       &disp->uevent);
 }
 
 static u32

commit 0d93cd92bd616474da0c842bc4e88f6921da18f1
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/nv50-: implement a common supervisor 3.0
    
    This makes use of all the additional routing and state added in previous
    commits, making it possible to deal with GM20x macro link routing, while
    also sharing code between the NV50 and GF119 implementations.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index f21e0e92d6f1..0c570dbd3021 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -238,162 +238,23 @@ nv50_disp_super_ior_arm(struct nvkm_head *head)
 	return NULL;
 }
 
-static struct nvkm_output *
-exec_lookup(struct nv50_disp *disp, int head, int or, u32 ctrl,
-	    u32 *data, u8 *ver, u8 *hdr, u8 *cnt, u8 *len,
-	    struct nvbios_outp *info)
-{
-	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
-	struct nvkm_bios *bios = subdev->device->bios;
-	struct nvkm_output *outp;
-	u16 mask, type;
-
-	if (or < 4) {
-		type = DCB_OUTPUT_ANALOG;
-		mask = 0;
-	} else
-	if (or < 8) {
-		switch (ctrl & 0x00000f00) {
-		case 0x00000000: type = DCB_OUTPUT_LVDS; mask = 1; break;
-		case 0x00000100: type = DCB_OUTPUT_TMDS; mask = 1; break;
-		case 0x00000200: type = DCB_OUTPUT_TMDS; mask = 2; break;
-		case 0x00000500: type = DCB_OUTPUT_TMDS; mask = 3; break;
-		case 0x00000800: type = DCB_OUTPUT_DP; mask = 1; break;
-		case 0x00000900: type = DCB_OUTPUT_DP; mask = 2; break;
-		default:
-			nvkm_error(subdev, "unknown SOR mc %08x\n", ctrl);
-			return NULL;
-		}
-		or  -= 4;
-	} else {
-		or   = or - 8;
-		type = 0x0010;
-		mask = 0;
-		switch (ctrl & 0x00000f00) {
-		case 0x00000000: type |= disp->pior.type[or]; break;
-		default:
-			nvkm_error(subdev, "unknown PIOR mc %08x\n", ctrl);
-			return NULL;
-		}
-	}
-
-	mask  = 0x00c0 & (mask << 6);
-	mask |= 0x0001 << or;
-	mask |= 0x0100 << head;
-
-	list_for_each_entry(outp, &disp->base.outp, head) {
-		if ((outp->info.hasht & 0xff) == type &&
-		    (outp->info.hashm & mask) == mask) {
-			*data = nvbios_outp_match(bios, outp->info.hasht, mask,
-						  ver, hdr, cnt, len, info);
-			if (!*data)
-				return NULL;
-			return outp;
-		}
-	}
-
-	return NULL;
-}
-
-static struct nvkm_output *
-exec_clkcmp(struct nv50_disp *disp, int head, int id, u32 pclk, u32 *conf)
-{
-	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
-	struct nvkm_device *device = subdev->device;
-	struct nvkm_bios *bios = device->bios;
-	struct nvkm_output *outp;
-	struct nvbios_outp info1;
-	struct nvbios_ocfg info2;
-	u8  ver, hdr, cnt, len;
-	u32 data, ctrl = 0;
-	u32 reg;
-	int i;
-
-	/* DAC */
-	for (i = 0; !(ctrl & (1 << head)) && i < disp->func->dac.nr; i++)
-		ctrl = nvkm_rd32(device, 0x610b58 + (i * 8));
-
-	/* SOR */
-	if (!(ctrl & (1 << head))) {
-		if (device->chipset  < 0x90 ||
-		    device->chipset == 0x92 ||
-		    device->chipset == 0xa0) {
-			reg = 0x610b70;
-		} else {
-			reg = 0x610794;
-		}
-		for (i = 0; !(ctrl & (1 << head)) && i < disp->func->sor.nr; i++)
-			ctrl = nvkm_rd32(device, reg + (i * 8));
-		i += 4;
-	}
-
-	/* PIOR */
-	if (!(ctrl & (1 << head))) {
-		for (i = 0; !(ctrl & (1 << head)) && i < disp->func->pior.nr; i++)
-			ctrl = nvkm_rd32(device, 0x610b80 + (i * 8));
-		i += 8;
-	}
-
-	if (!(ctrl & (1 << head)))
-		return NULL;
-	i--;
-
-	outp = exec_lookup(disp, head, i, ctrl, &data, &ver, &hdr, &cnt, &len, &info1);
-	if (!outp)
-		return NULL;
-
-	*conf = (ctrl & 0x00000f00) >> 8;
-	if (outp->info.location == 0) {
-		switch (outp->info.type) {
-		case DCB_OUTPUT_TMDS:
-			if (*conf == 5)
-				*conf |= 0x0100;
-			break;
-		case DCB_OUTPUT_LVDS:
-			*conf |= disp->sor.lvdsconf;
-			break;
-		default:
-			break;
-		}
-	} else {
-		*conf = (ctrl & 0x00000f00) >> 8;
-		pclk = pclk / 2;
-	}
-
-	data = nvbios_ocfg_match(bios, data, *conf & 0xff, *conf >> 8,
-				 &ver, &hdr, &cnt, &len, &info2);
-	if (data && id < 0xff) {
-		data = nvbios_oclk_match(bios, info2.clkcmp[id], pclk);
-		if (data) {
-			struct nvbios_init init = {
-				.subdev = subdev,
-				.bios = bios,
-				.offset = data,
-				.outp = &outp->info,
-				.crtc = head,
-				.execute = 1,
-			};
-
-			nvbios_exec(&init);
-		}
-	}
-
-	return outp;
-}
-
-static void
-nv50_disp_intr_unk40_0(struct nv50_disp *disp, int head)
+void
+nv50_disp_super_3_0(struct nv50_disp *disp, struct nvkm_head *head)
 {
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	struct nvkm_output *outp;
-	u32 pclk = nvkm_rd32(device, 0x610ad0 + (head * 0x540)) & 0x3fffff;
-	u32 conf;
+	struct nvkm_ior *ior;
 
-	outp = exec_clkcmp(disp, head, 1, pclk, &conf);
-	if (!outp)
+	/* Determine which OR, if any, we're attaching to the head. */
+	HEAD_DBG(head, "supervisor 3.0");
+	ior = nv50_disp_super_ior_asy(head);
+	if (!ior)
 		return;
 
-	nv50_disp_dptmds_war_3(disp, &outp->info);
+	/* Execute OnInt3 IED script. */
+	nv50_disp_super_ied_on(head, ior, 1, head->asy.hz / 1000);
+
+	/* OR-specific handling. */
+	if (ior->func->war_3)
+		ior->func->war_3(ior);
 }
 
 static void
@@ -660,9 +521,8 @@ nv50_disp_super(struct work_struct *work)
 		list_for_each_entry(head, &disp->base.head, head) {
 			if (!(super & (0x00000080 << head->id)))
 				continue;
-			nv50_disp_intr_unk40_0(disp, head->id);
+			nv50_disp_super_3_0(disp, head);
 		}
-		nv50_disp_update_sppll1(disp);
 	}
 
 	nvkm_wr32(device, 0x610030, 0x80000000);

commit 8d7ef84d908877708001f3334dbf44e9d48fad57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/nv50-: implement a common supervisor 2.2
    
    This makes use of all the additional routing and state added in previous
    commits, making it possible to deal with GM20x macro link routing, while
    also sharing code between the NV50 and GF119 implementations.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index ebe7657bf2af..f21e0e92d6f1 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -129,6 +129,62 @@ nv50_disp_super_iedt(struct nvkm_head *head, struct nvkm_outp *outp,
 	return data;
 }
 
+static void
+nv50_disp_super_ied_on(struct nvkm_head *head,
+		       struct nvkm_ior *ior, int id, u32 khz)
+{
+	struct nvkm_subdev *subdev = &head->disp->engine.subdev;
+	struct nvkm_bios *bios = subdev->device->bios;
+	struct nvkm_outp *outp = ior->asy.outp;
+	struct nvbios_ocfg iedtrs;
+	struct nvbios_outp iedt;
+	u8  ver, hdr, cnt, len, flags = 0x00;
+	u32 data;
+
+	if (!outp) {
+		IOR_DBG(ior, "nothing to attach");
+		return;
+	}
+
+	/* Lookup IED table for the device. */
+	data = nv50_disp_super_iedt(head, outp, &ver, &hdr, &cnt, &len, &iedt);
+	if (!data)
+		return;
+
+	/* Lookup IEDT runtime settings for the current configuration. */
+	if (ior->type == SOR) {
+		if (ior->asy.proto == LVDS) {
+			if (head->asy.or.depth == 24)
+				flags |= 0x02;
+		}
+		if (ior->asy.link == 3)
+			flags |= 0x01;
+	}
+
+	data = nvbios_ocfg_match(bios, data, ior->asy.proto_evo, flags,
+				 &ver, &hdr, &cnt, &len, &iedtrs);
+	if (!data) {
+		OUTP_DBG(outp, "missing IEDT RS for %02x:%02x",
+			 ior->asy.proto_evo, flags);
+		return;
+	}
+
+	/* Execute the OnInt[23] script for the current frequency. */
+	data = nvbios_oclk_match(bios, iedtrs.clkcmp[id], khz);
+	if (!data) {
+		OUTP_DBG(outp, "missing IEDT RSS %d for %02x:%02x %d khz",
+			 id, ior->asy.proto_evo, flags, khz);
+		return;
+	}
+
+	nvbios_init(subdev, data,
+		init.outp = &outp->info;
+		init.or   = ior->id;
+		init.link = ior->asy.link;
+		init.head = head->id;
+	);
+}
+
 static void
 nv50_disp_super_ied_off(struct nvkm_head *head, struct nvkm_ior *ior, int id)
 {
@@ -154,6 +210,20 @@ nv50_disp_super_ied_off(struct nvkm_head *head, struct nvkm_ior *ior, int id)
 	);
 }
 
+static struct nvkm_ior *
+nv50_disp_super_ior_asy(struct nvkm_head *head)
+{
+	struct nvkm_ior *ior;
+	list_for_each_entry(ior, &head->disp->ior, head) {
+		if (ior->asy.head & (1 << head->id)) {
+			HEAD_DBG(head, "to %s", ior->name);
+			return ior;
+		}
+	}
+	HEAD_DBG(head, "nothing to attach");
+	return NULL;
+}
+
 static struct nvkm_ior *
 nv50_disp_super_ior_arm(struct nvkm_head *head)
 {
@@ -327,58 +397,40 @@ nv50_disp_intr_unk40_0(struct nv50_disp *disp, int head)
 }
 
 static void
-nv50_disp_intr_unk20_2_dp(struct nv50_disp *disp, int head,
-			  struct dcb_output *outp, u32 pclk)
+nv50_disp_super_2_2_dp(struct nvkm_head *head, struct nvkm_ior *ior)
 {
-	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
-	struct nvkm_device *device = subdev->device;
-	const int link = !(outp->sorconf.link & 1);
-	const int   or = ffs(outp->or) - 1;
-	const u32 soff = (  or * 0x800);
-	const u32 loff = (link * 0x080) + soff;
-	const u32 ctrl = nvkm_rd32(device, 0x610794 + (or * 8));
-	const u32 symbol = 100000;
-	const s32 vactive = nvkm_rd32(device, 0x610af8 + (head * 0x540)) & 0xffff;
-	const s32 vblanke = nvkm_rd32(device, 0x610ae8 + (head * 0x540)) & 0xffff;
-	const s32 vblanks = nvkm_rd32(device, 0x610af0 + (head * 0x540)) & 0xffff;
-	u32 dpctrl = nvkm_rd32(device, 0x61c10c + loff);
-	u32 clksor = nvkm_rd32(device, 0x614300 + soff);
+	struct nvkm_subdev *subdev = &head->disp->engine.subdev;
+	const u32      khz = head->asy.hz / 1000;
+	const u32 linkKBps = ior->dp.bw * 27000;
+	const u32   symbol = 100000;
 	int bestTU = 0, bestVTUi = 0, bestVTUf = 0, bestVTUa = 0;
 	int TU, VTUi, VTUf, VTUa;
 	u64 link_data_rate, link_ratio, unk;
 	u32 best_diff = 64 * symbol;
-	u32 link_nr, link_bw, bits;
-	u64 value;
-
-	link_bw = (clksor & 0x000c0000) ? 270000 : 162000;
-	link_nr = hweight32(dpctrl & 0x000f0000);
+	u64 h, v;
 
 	/* symbols/hblank - algorithm taken from comments in tegra driver */
-	value = vblanke + vactive - vblanks - 7;
-	value = value * link_bw;
-	do_div(value, pclk);
-	value = value - (3 * !!(dpctrl & 0x00004000)) - (12 / link_nr);
-	nvkm_mask(device, 0x61c1e8 + soff, 0x0000ffff, value);
+	h = head->asy.hblanke + head->asy.htotal - head->asy.hblanks - 7;
+	h = h * linkKBps;
+	do_div(h, khz);
+	h = h - (3 * ior->dp.ef) - (12 / ior->dp.nr);
 
 	/* symbols/vblank - algorithm taken from comments in tegra driver */
-	value = vblanks - vblanke - 25;
-	value = value * link_bw;
-	do_div(value, pclk);
-	value = value - ((36 / link_nr) + 3) - 1;
-	nvkm_mask(device, 0x61c1ec + soff, 0x00ffffff, value);
+	v = head->asy.vblanks - head->asy.vblanke - 25;
+	v = v * linkKBps;
+	do_div(v, khz);
+	v = v - ((36 / ior->dp.nr) + 3) - 1;
 
-	/* watermark / activesym */
-	if      ((ctrl & 0xf0000) == 0x60000) bits = 30;
-	else if ((ctrl & 0xf0000) == 0x50000) bits = 24;
-	else                                  bits = 18;
+	ior->func->dp.audio_sym(ior, head->id, h, v);
 
-	link_data_rate = (pclk * bits / 8) / link_nr;
+	/* watermark / activesym */
+	link_data_rate = (khz * head->asy.or.depth / 8) / ior->dp.nr;
 
 	/* calculate ratio of packed data rate to link symbol rate */
 	link_ratio = link_data_rate * symbol;
-	do_div(link_ratio, link_bw);
+	do_div(link_ratio, linkKBps);
 
-	for (TU = 64; TU >= 32; TU--) {
+	for (TU = 64; ior->func->dp.activesym && TU >= 32; TU--) {
 		/* calculate average number of valid symbols in each TU */
 		u32 tu_valid = link_ratio * TU;
 		u32 calc, diff;
@@ -429,9 +481,15 @@ nv50_disp_intr_unk20_2_dp(struct nv50_disp *disp, int head,
 		}
 	}
 
-	if (!bestTU) {
-		nvkm_error(subdev, "unable to find suitable dp config\n");
-		return;
+	if (ior->func->dp.activesym) {
+		if (!bestTU) {
+			nvkm_error(subdev, "unable to determine dp config\n");
+			return;
+		}
+		ior->func->dp.activesym(ior, head->id, bestTU,
+					bestVTUa, bestVTUf, bestVTUi);
+	} else {
+		bestTU = 64;
 	}
 
 	/* XXX close to vbios numbers, but not right */
@@ -441,102 +499,61 @@ nv50_disp_intr_unk20_2_dp(struct nv50_disp *disp, int head,
 	do_div(unk, symbol);
 	unk += 6;
 
-	nvkm_mask(device, 0x61c10c + loff, 0x000001fc, bestTU << 2);
-	nvkm_mask(device, 0x61c128 + loff, 0x010f7f3f, bestVTUa << 24 |
-						   bestVTUf << 16 |
-						   bestVTUi << 8 | unk);
+	ior->func->dp.watermark(ior, head->id, unk);
 }
 
-static void
-nv50_disp_intr_unk20_2(struct nv50_disp *disp, int head)
+void
+nv50_disp_super_2_2(struct nv50_disp *disp, struct nvkm_head *head)
 {
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	struct nvkm_output *outp;
-	u32 pclk = nvkm_rd32(device, 0x610ad0 + (head * 0x540)) & 0x3fffff;
-	u32 hval, hreg = 0x614200 + (head * 0x800);
-	u32 oval, oreg;
-	u32 mask, conf;
+	const u32 khz = head->asy.hz / 1000;
+	struct nvkm_outp *outp;
+	struct nvkm_ior *ior;
 
-	outp = exec_clkcmp(disp, head, 0xff, pclk, &conf);
-	if (!outp)
+	/* Determine which OR, if any, we're attaching from the head. */
+	HEAD_DBG(head, "supervisor 2.2");
+	ior = nv50_disp_super_ior_asy(head);
+	if (!ior)
 		return;
 
-	/* we allow both encoder attach and detach operations to occur
-	 * within a single supervisor (ie. modeset) sequence.  the
-	 * encoder detach scripts quite often switch off power to the
-	 * lanes, which requires the link to be re-trained.
-	 *
-	 * this is not generally an issue as the sink "must" (heh)
-	 * signal an irq when it's lost sync so the driver can
-	 * re-train.
+	/* For some reason, NVIDIA decided not to:
 	 *
-	 * however, on some boards, if one does not configure at least
-	 * the gpu side of the link *before* attaching, then various
-	 * things can go horribly wrong (PDISP disappearing from mmio,
-	 * third supervisor never happens, etc).
+	 * A) Give dual-link LVDS a separate EVO protocol, like for TMDS.
+	 *  and
+	 * B) Use SetControlOutputResource.PixelDepth on LVDS.
 	 *
-	 * the solution is simply to retrain here, if necessary.  last
-	 * i checked, the binary driver userspace does not appear to
-	 * trigger this situation (it forces an UPDATE between steps).
+	 * Override the values we usually read from HW with the same
+	 * data we pass though an ioctl instead.
 	 */
-	if (outp->info.type == DCB_OUTPUT_DP) {
-		u32 soff = (ffs(outp->info.or) - 1) * 0x08;
-		u32 ctrl, datarate;
-
-		if (outp->info.location == 0) {
-			ctrl = nvkm_rd32(device, 0x610794 + soff);
-			soff = 1;
-		} else {
-			ctrl = nvkm_rd32(device, 0x610b80 + soff);
-			soff = 2;
-		}
-
-		switch ((ctrl & 0x000f0000) >> 16) {
-		case 6: datarate = pclk * 30; break;
-		case 5: datarate = pclk * 24; break;
-		case 2:
-		default:
-			datarate = pclk * 18;
-			break;
-		}
-
-		if (nvkm_output_dp_train(outp, datarate / soff))
-			OUTP_ERR(outp, "link not trained before attach");
+	if (ior->type == SOR && ior->asy.proto == LVDS) {
+		head->asy.or.depth = (disp->sor.lvdsconf & 0x0200) ? 24 : 18;
+		ior->asy.link      = (disp->sor.lvdsconf & 0x0100) ? 3  : 1;
 	}
 
-	exec_clkcmp(disp, head, 0, pclk, &conf);
+	/* Handle any link training, etc. */
+	if ((outp = ior->asy.outp) && outp->func->acquire)
+		outp->func->acquire(outp);
 
-	if (!outp->info.location && outp->info.type == DCB_OUTPUT_ANALOG) {
-		oreg = 0x614280 + (ffs(outp->info.or) - 1) * 0x800;
-		oval = 0x00000000;
-		hval = 0x00000000;
-		mask = 0xffffffff;
-	} else
-	if (!outp->info.location) {
-		if (outp->info.type == DCB_OUTPUT_DP)
-			nv50_disp_intr_unk20_2_dp(disp, head, &outp->info, pclk);
-		oreg = 0x614300 + (ffs(outp->info.or) - 1) * 0x800;
-		oval = (conf & 0x0100) ? 0x00000101 : 0x00000000;
-		hval = 0x00000000;
-		mask = 0x00000707;
-	} else {
-		oreg = 0x614380 + (ffs(outp->info.or) - 1) * 0x800;
-		oval = 0x00000001;
-		hval = 0x00000001;
-		mask = 0x00000707;
-	}
+	/* Execute OnInt2 IED script. */
+	nv50_disp_super_ied_on(head, ior, 0, khz);
+
+	/* Program RG clock divider. */
+	head->func->rgclk(head, ior->asy.rgdiv);
 
-	nvkm_mask(device, hreg, 0x0000000f, hval);
-	nvkm_mask(device, oreg, mask, oval);
+	/* Mode-specific internal DP configuration. */
+	if (ior->type == SOR && ior->asy.proto == DP)
+		nv50_disp_super_2_2_dp(head, ior);
 
-	nv50_disp_dptmds_war_2(disp, &outp->info);
+	/* OR-specific handling. */
+	ior->func->clock(ior);
+	if (ior->func->war_2)
+		ior->func->war_2(ior);
 }
 
 void
 nv50_disp_super_2_1(struct nv50_disp *disp, struct nvkm_head *head)
 {
 	struct nvkm_devinit *devinit = disp->base.engine.subdev.device->devinit;
-	u32 khz = head->asy.hz / 1000;
+	const u32 khz = head->asy.hz / 1000;
 	HEAD_DBG(head, "supervisor 2.1 - %d khz", khz);
 	if (khz)
 		nvkm_devinit_pll_set(devinit, PLL_VPLL0 + head->id, khz);
@@ -636,7 +653,7 @@ nv50_disp_super(struct work_struct *work)
 		list_for_each_entry(head, &disp->base.head, head) {
 			if (!(super & (0x00000080 << head->id)))
 				continue;
-			nv50_disp_intr_unk20_2(disp, head->id);
+			nv50_disp_super_2_2(disp, head);
 		}
 	} else
 	if (disp->super & 0x00000040) {

commit 1f0c9eaf31bba3e1cac5534ba17602c115b76cf8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/nv50-: implement a common supervisor 2.1
    
    This makes use of all the additional routing and state added in previous
    commits, making it possible to deal with GM20x macro link routing, while
    also sharing code between the NV50 and GF119 implementations.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 6c51045e284a..ebe7657bf2af 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -532,14 +532,14 @@ nv50_disp_intr_unk20_2(struct nv50_disp *disp, int head)
 	nv50_disp_dptmds_war_2(disp, &outp->info);
 }
 
-static void
-nv50_disp_intr_unk20_1(struct nv50_disp *disp, int head)
+void
+nv50_disp_super_2_1(struct nv50_disp *disp, struct nvkm_head *head)
 {
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	struct nvkm_devinit *devinit = device->devinit;
-	u32 pclk = nvkm_rd32(device, 0x610ad0 + (head * 0x540)) & 0x3fffff;
-	if (pclk)
-		nvkm_devinit_pll_set(devinit, PLL_VPLL0 + head, pclk);
+	struct nvkm_devinit *devinit = disp->base.engine.subdev.device->devinit;
+	u32 khz = head->asy.hz / 1000;
+	HEAD_DBG(head, "supervisor 2.1 - %d khz", khz);
+	if (khz)
+		nvkm_devinit_pll_set(devinit, PLL_VPLL0 + head->id, khz);
 }
 
 void
@@ -631,7 +631,7 @@ nv50_disp_super(struct work_struct *work)
 		list_for_each_entry(head, &disp->base.head, head) {
 			if (!(super & (0x00000200 << head->id)))
 				continue;
-			nv50_disp_intr_unk20_1(disp, head->id);
+			nv50_disp_super_2_1(disp, head);
 		}
 		list_for_each_entry(head, &disp->base.head, head) {
 			if (!(super & (0x00000080 << head->id)))

commit d52e948c67b263d0ceb71d734673ff8b1d4b10ce
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/nv50-: implement a common supervisor 2.0
    
    This makes use of all the additional routing and state added in previous
    commits, making it possible to deal with GM20x macro link routing, while
    also sharing code between the NV50 and GF119 implementations.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 96d281568765..6c51045e284a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -225,65 +225,6 @@ exec_lookup(struct nv50_disp *disp, int head, int or, u32 ctrl,
 	return NULL;
 }
 
-static struct nvkm_output *
-exec_script(struct nv50_disp *disp, int head, int id)
-{
-	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
-	struct nvkm_device *device = subdev->device;
-	struct nvkm_bios *bios = device->bios;
-	struct nvkm_output *outp;
-	struct nvbios_outp info;
-	u8  ver, hdr, cnt, len;
-	u32 data, ctrl = 0;
-	u32 reg;
-	int i;
-
-	/* DAC */
-	for (i = 0; !(ctrl & (1 << head)) && i < disp->func->dac.nr; i++)
-		ctrl = nvkm_rd32(device, 0x610b5c + (i * 8));
-
-	/* SOR */
-	if (!(ctrl & (1 << head))) {
-		if (device->chipset  < 0x90 ||
-		    device->chipset == 0x92 ||
-		    device->chipset == 0xa0) {
-			reg = 0x610b74;
-		} else {
-			reg = 0x610798;
-		}
-		for (i = 0; !(ctrl & (1 << head)) && i < disp->func->sor.nr; i++)
-			ctrl = nvkm_rd32(device, reg + (i * 8));
-		i += 4;
-	}
-
-	/* PIOR */
-	if (!(ctrl & (1 << head))) {
-		for (i = 0; !(ctrl & (1 << head)) && i < disp->func->pior.nr; i++)
-			ctrl = nvkm_rd32(device, 0x610b84 + (i * 8));
-		i += 8;
-	}
-
-	if (!(ctrl & (1 << head)))
-		return NULL;
-	i--;
-
-	outp = exec_lookup(disp, head, i, ctrl, &data, &ver, &hdr, &cnt, &len, &info);
-	if (outp) {
-		struct nvbios_init init = {
-			.subdev = subdev,
-			.bios = bios,
-			.offset = info.script[id],
-			.outp = &outp->info,
-			.crtc = head,
-			.execute = 1,
-		};
-
-		nvbios_exec(&init);
-	}
-
-	return outp;
-}
-
 static struct nvkm_output *
 exec_clkcmp(struct nv50_disp *disp, int head, int id, u32 pclk, u32 *conf)
 {
@@ -601,38 +542,27 @@ nv50_disp_intr_unk20_1(struct nv50_disp *disp, int head)
 		nvkm_devinit_pll_set(devinit, PLL_VPLL0 + head, pclk);
 }
 
-static void
-nv50_disp_intr_unk20_0(struct nv50_disp *disp, int head)
+void
+nv50_disp_super_2_0(struct nv50_disp *disp, struct nvkm_head *head)
 {
-	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
-	struct nvkm_output *outp = exec_script(disp, head, 2);
-
-	/* the binary driver does this outside of the supervisor handling
-	 * (after the third supervisor from a detach).  we (currently?)
-	 * allow both detach/attach to happen in the same set of
-	 * supervisor interrupts, so it would make sense to execute this
-	 * (full power down?) script after all the detach phases of the
-	 * supervisor handling.  like with training if needed from the
-	 * second supervisor, nvidia doesn't do this, so who knows if it's
-	 * entirely safe, but it does appear to work..
-	 *
-	 * without this script being run, on some configurations i've
-	 * seen, switching from DP to TMDS on a DP connector may result
-	 * in a blank screen (SOR_PWR off/on can restore it)
+	struct nvkm_outp *outp;
+	struct nvkm_ior *ior;
+
+	/* Determine which OR, if any, we're detaching from the head. */
+	HEAD_DBG(head, "supervisor 2.0");
+	ior = nv50_disp_super_ior_arm(head);
+	if (!ior)
+		return;
+
+	/* Execute OffInt2 IED script. */
+	nv50_disp_super_ied_off(head, ior, 2);
+
+	/* If we're shutting down the OR's only active head, execute
+	 * the output path's release function.
 	 */
-	if (outp && outp->info.type == DCB_OUTPUT_DP) {
-		struct nvkm_output_dp *outpdp = nvkm_output_dp(outp);
-		struct nvbios_init init = {
-			.subdev = subdev,
-			.bios = subdev->device->bios,
-			.outp = &outp->info,
-			.crtc = head,
-			.offset = outpdp->info.script[4],
-			.execute = 1,
-		};
-
-		atomic_set(&outpdp->lt.done, 0);
-		nvbios_exec(&init);
+	if (ior->arm.head == (1 << head->id)) {
+		if ((outp = ior->arm.outp) && outp->func->release)
+			outp->func->release(outp, ior);
 	}
 }
 
@@ -695,7 +625,7 @@ nv50_disp_super(struct work_struct *work)
 		list_for_each_entry(head, &disp->base.head, head) {
 			if (!(super & (0x00000080 << head->id)))
 				continue;
-			nv50_disp_intr_unk20_0(disp, head->id);
+			nv50_disp_super_2_0(disp, head);
 		}
 		nvkm_outp_route(&disp->base);
 		list_for_each_entry(head, &disp->base.head, head) {

commit 327c5581d303183e9e56b50238034f419dcca3ce
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/nv50-: implement a common supervisor 1.0
    
    This makes use of all the additional routing and state added in previous
    commits, making it possible to deal with GM20x macro link routing, while
    also sharing code between the NV50 and GF119 implementations.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index c018dbdb121d..96d281568765 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -114,6 +114,60 @@ nv50_disp_new_(const struct nv50_disp_func *func, struct nvkm_device *device,
 	return nvkm_event_init(func->uevent, 1, 1 + (heads * 4), &disp->uevent);
 }
 
+static u32
+nv50_disp_super_iedt(struct nvkm_head *head, struct nvkm_outp *outp,
+		     u8 *ver, u8 *hdr, u8 *cnt, u8 *len,
+		     struct nvbios_outp *iedt)
+{
+	struct nvkm_bios *bios = head->disp->engine.subdev.device->bios;
+	const u8  l = ffs(outp->info.link);
+	const u16 t = outp->info.hasht;
+	const u16 m = (0x0100 << head->id) | (l << 6) | outp->info.or;
+	u32 data = nvbios_outp_match(bios, t, m, ver, hdr, cnt, len, iedt);
+	if (!data)
+		OUTP_DBG(outp, "missing IEDT for %04x:%04x", t, m);
+	return data;
+}
+
+static void
+nv50_disp_super_ied_off(struct nvkm_head *head, struct nvkm_ior *ior, int id)
+{
+	struct nvkm_outp *outp = ior->arm.outp;
+	struct nvbios_outp iedt;
+	u8  ver, hdr, cnt, len;
+	u32 data;
+
+	if (!outp) {
+		IOR_DBG(ior, "nothing attached");
+		return;
+	}
+
+	data = nv50_disp_super_iedt(head, outp, &ver, &hdr, &cnt, &len, &iedt);
+	if (!data)
+		return;
+
+	nvbios_init(&head->disp->engine.subdev, iedt.script[id],
+		init.outp = &outp->info;
+		init.or   = ior->id;
+		init.link = ior->arm.link;
+		init.head = head->id;
+	);
+}
+
+static struct nvkm_ior *
+nv50_disp_super_ior_arm(struct nvkm_head *head)
+{
+	struct nvkm_ior *ior;
+	list_for_each_entry(ior, &head->disp->ior, head) {
+		if (ior->arm.head & (1 << head->id)) {
+			HEAD_DBG(head, "on %s", ior->name);
+			return ior;
+		}
+	}
+	HEAD_DBG(head, "nothing attached");
+	return NULL;
+}
+
 static struct nvkm_output *
 exec_lookup(struct nv50_disp *disp, int head, int or, u32 ctrl,
 	    u32 *data, u8 *ver, u8 *hdr, u8 *cnt, u8 *len,
@@ -582,10 +636,19 @@ nv50_disp_intr_unk20_0(struct nv50_disp *disp, int head)
 	}
 }
 
-static void
-nv50_disp_intr_unk10_0(struct nv50_disp *disp, int head)
+void
+nv50_disp_super_1_0(struct nv50_disp *disp, struct nvkm_head *head)
 {
-	exec_script(disp, head, 1);
+	struct nvkm_ior *ior;
+
+	/* Determine which OR, if any, we're detaching from the head. */
+	HEAD_DBG(head, "supervisor 1.0");
+	ior = nv50_disp_super_ior_arm(head);
+	if (!ior)
+		return;
+
+	/* Execute OffInt1 IED script. */
+	nv50_disp_super_ied_off(head, ior, 1);
 }
 
 void
@@ -625,7 +688,7 @@ nv50_disp_super(struct work_struct *work)
 				continue;
 			if (!(super & (0x00000080 << head->id)))
 				continue;
-			nv50_disp_intr_unk10_0(disp, head->id);
+			nv50_disp_super_1_0(disp, head);
 		}
 	} else
 	if (disp->super & 0x00000020) {

commit 99a845a30f62b926818412f337ad15218fb121ba
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/nv50-gt21x: remove workaround for dp->tmds hotplug issues
    
    This shouldn't have been needed ever since we started executing the
    DisableLT script when shutting down heads.
    
    Testing of the board this was originally written for seems to agree.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 58d46cefe7b1..c018dbdb121d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -316,31 +316,6 @@ exec_clkcmp(struct nv50_disp *disp, int head, int id, u32 pclk, u32 *conf)
 	return outp;
 }
 
-/* If programming a TMDS output on a SOR that can also be configured for
- * DisplayPort, make sure NV50_SOR_DP_CTRL_ENABLE is forced off.
- *
- * It looks like the VBIOS TMDS scripts make an attempt at this, however,
- * the VBIOS scripts on at least one board I have only switch it off on
- * link 0, causing a blank display if the output has previously been
- * programmed for DisplayPort.
- */
-static void
-nv50_disp_intr_unk40_0_tmds(struct nv50_disp *disp,
-			    struct dcb_output *outp)
-{
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	struct nvkm_bios *bios = device->bios;
-	const int link = !(outp->sorconf.link & 1);
-	const int   or = ffs(outp->or) - 1;
-	const u32 loff = (or * 0x800) + (link * 0x80);
-	const u16 mask = (outp->sorconf.link << 6) | outp->or;
-	struct dcb_output match;
-	u8  ver, hdr;
-
-	if (dcb_outp_match(bios, DCB_OUTPUT_DP, mask, &ver, &hdr, &match))
-		nvkm_mask(device, 0x61c10c + loff, 0x00000001, 0x00000000);
-}
-
 static void
 nv50_disp_intr_unk40_0(struct nv50_disp *disp, int head)
 {
@@ -353,8 +328,6 @@ nv50_disp_intr_unk40_0(struct nv50_disp *disp, int head)
 	if (!outp)
 		return;
 
-	if (outp->info.location == 0 && outp->info.type == DCB_OUTPUT_TMDS)
-		nv50_disp_intr_unk40_0_tmds(disp, &outp->info);
 	nv50_disp_dptmds_war_3(disp, &outp->info);
 }
 

commit 6c22ea3747fd36409ce4a1e1a0cbac40f93e1e71
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp: introduce acquire/release display path methods
    
    These exist to give NVKM information on the set of display paths that
    the DD needs to be active at any given time.
    
    Previously, the supervisor attempted to determine this solely from OR
    state, but there's a few configurations where this information on its
    own isn't enough to determine the specific display paths in question:
    
    - ANX9805, where the PIOR protocol for both DP and TMDS is TMDS.
    - On a device using DCB Switched Outputs.
    - On GM20x and newer, with a crossbar between the SOR and macro links.
    
    After this commit, the DD tells NVKM *exactly* which display path it's
    attempting a modeset on.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index b7365b56ed19..58d46cefe7b1 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -661,6 +661,7 @@ nv50_disp_super(struct work_struct *work)
 				continue;
 			nv50_disp_intr_unk20_0(disp, head->id);
 		}
+		nvkm_outp_route(&disp->base);
 		list_for_each_entry(head, &disp->base.head, head) {
 			if (!(super & (0x00000200 << head->id)))
 				continue;

commit 3c66c87dc96b3113b5ee84604800c2aabbb48994
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp: remove hw-specific customisation of output paths
    
    All of the necessary hw-specific logic is now handled at the output
    resource level, so all of this can go away.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index ae570f65e097..b7365b56ed19 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -42,63 +42,6 @@ nv50_disp_root_(struct nvkm_disp *base)
 	return nv50_disp(base)->func->root;
 }
 
-static int
-nv50_disp_outp_internal_crt_(struct nvkm_disp *base, int index,
-			     struct dcb_output *dcb, struct nvkm_output **poutp)
-{
-	struct nv50_disp *disp = nv50_disp(base);
-	return disp->func->outp.internal.crt(base, index, dcb, poutp);
-}
-
-static int
-nv50_disp_outp_internal_tmds_(struct nvkm_disp *base, int index,
-			      struct dcb_output *dcb,
-			      struct nvkm_output **poutp)
-{
-	struct nv50_disp *disp = nv50_disp(base);
-	return disp->func->outp.internal.tmds(base, index, dcb, poutp);
-}
-
-static int
-nv50_disp_outp_internal_lvds_(struct nvkm_disp *base, int index,
-			      struct dcb_output *dcb,
-			      struct nvkm_output **poutp)
-{
-	struct nv50_disp *disp = nv50_disp(base);
-	return disp->func->outp.internal.lvds(base, index, dcb, poutp);
-}
-
-static int
-nv50_disp_outp_internal_dp_(struct nvkm_disp *base, int index,
-			    struct dcb_output *dcb, struct nvkm_output **poutp)
-{
-	struct nv50_disp *disp = nv50_disp(base);
-	if (disp->func->outp.internal.dp)
-		return disp->func->outp.internal.dp(base, index, dcb, poutp);
-	return -ENODEV;
-}
-
-static int
-nv50_disp_outp_external_tmds_(struct nvkm_disp *base, int index,
-			      struct dcb_output *dcb,
-			      struct nvkm_output **poutp)
-{
-	struct nv50_disp *disp = nv50_disp(base);
-	if (disp->func->outp.external.tmds)
-		return disp->func->outp.external.tmds(base, index, dcb, poutp);
-	return -ENODEV;
-}
-
-static int
-nv50_disp_outp_external_dp_(struct nvkm_disp *base, int index,
-			    struct dcb_output *dcb, struct nvkm_output **poutp)
-{
-	struct nv50_disp *disp = nv50_disp(base);
-	if (disp->func->outp.external.dp)
-		return disp->func->outp.external.dp(base, index, dcb, poutp);
-	return -ENODEV;
-}
-
 static void
 nv50_disp_intr_(struct nvkm_disp *base)
 {
@@ -121,12 +64,6 @@ nv50_disp_ = {
 	.dtor = nv50_disp_dtor_,
 	.intr = nv50_disp_intr_,
 	.root = nv50_disp_root_,
-	.outp.internal.crt = nv50_disp_outp_internal_crt_,
-	.outp.internal.tmds = nv50_disp_outp_internal_tmds_,
-	.outp.internal.lvds = nv50_disp_outp_internal_lvds_,
-	.outp.internal.dp = nv50_disp_outp_internal_dp_,
-	.outp.external.tmds = nv50_disp_outp_external_tmds_,
-	.outp.external.dp = nv50_disp_outp_external_dp_,
 };
 
 int
@@ -839,11 +776,6 @@ nv50_disp = {
 	.super = nv50_disp_super,
 	.root = &nv50_disp_root_oclass,
 	.head.new = nv50_head_new,
-	.outp.internal.crt = nv50_dac_output_new,
-	.outp.internal.tmds = nv50_sor_output_new,
-	.outp.internal.lvds = nv50_sor_output_new,
-	.outp.external.tmds = nv50_pior_output_new,
-	.outp.external.dp = nv50_pior_dp_new,
 	.dac = { .nr = 3, .new = nv50_dac_new },
 	.sor = { .nr = 2, .new = nv50_sor_new },
 	.pior = { .nr = 3, .new = nv50_pior_new },

commit 0df182466265d39591d742839f1014f93b7cbd02
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/nv50-: port OR manual sink detection to nvkm_ior
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index f8986299dc54..ae570f65e097 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -844,9 +844,7 @@ nv50_disp = {
 	.outp.internal.lvds = nv50_sor_output_new,
 	.outp.external.tmds = nv50_pior_output_new,
 	.outp.external.dp = nv50_pior_dp_new,
-	.dac.nr = 3,
-	.dac.new = nv50_dac_new,
-	.dac.sense = nv50_dac_sense,
+	.dac = { .nr = 3, .new = nv50_dac_new },
 	.sor = { .nr = 2, .new = nv50_sor_new },
 	.pior = { .nr = 3, .new = nv50_pior_new },
 };

commit 9c5753bc708da0c2c544fcfe1e94afb399c2b3f6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/nv50-: port OR power state control to nvkm_ior
    
    Also removes the user-facing methods to these controls, as they're not
    currently utilised by the DD anyway.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 99a94a65b1a3..f8986299dc54 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -846,14 +846,9 @@ nv50_disp = {
 	.outp.external.dp = nv50_pior_dp_new,
 	.dac.nr = 3,
 	.dac.new = nv50_dac_new,
-	.dac.power = nv50_dac_power,
 	.dac.sense = nv50_dac_sense,
-	.sor.nr = 2,
-	.sor.new = nv50_sor_new,
-	.sor.power = nv50_sor_power,
-	.pior.nr = 3,
-	.pior.new = nv50_pior_new,
-	.pior.power = nv50_pior_power,
+	.sor = { .nr = 2, .new = nv50_sor_new },
+	.pior = { .nr = 3, .new = nv50_pior_new },
 };
 
 int

commit 29c0ca7389ce8e259516d14397890bfe0ab462c8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/nv50-: fetch head/OR state at beginning of supervisor
    
    This data will be used by essentially every part of the supervisor
    handling process.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 21bdf301d37e..99a94a65b1a3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -678,6 +678,23 @@ nv50_disp_intr_unk10_0(struct nv50_disp *disp, int head)
 	exec_script(disp, head, 1);
 }
 
+void
+nv50_disp_super_1(struct nv50_disp *disp)
+{
+	struct nvkm_head *head;
+	struct nvkm_ior *ior;
+
+	list_for_each_entry(head, &disp->base.head, head) {
+		head->func->state(head, &head->arm);
+		head->func->state(head, &head->asy);
+	}
+
+	list_for_each_entry(ior, &disp->base.ior, head) {
+		ior->func->state(ior, &ior->arm);
+		ior->func->state(ior, &ior->asy);
+	}
+}
+
 void
 nv50_disp_super(struct work_struct *work)
 {
@@ -692,6 +709,7 @@ nv50_disp_super(struct work_struct *work)
 
 	if (disp->super & 0x00000010) {
 		nv50_disp_chan_mthd(disp->chan[0], NV_DBG_DEBUG);
+		nv50_disp_super_1(disp);
 		list_for_each_entry(head, &disp->base.head, head) {
 			if (!(super & (0x00000020 << head->id)))
 				continue;

commit 3607bfd398204ddb11f63c09b1cc608adf85f96c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/nv50-: execute supervisor on its own workqueue
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index acc663061ceb..21bdf301d37e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -111,6 +111,8 @@ nv50_disp_dtor_(struct nvkm_disp *base)
 {
 	struct nv50_disp *disp = nv50_disp(base);
 	nvkm_event_fini(&disp->uevent);
+	if (disp->wq)
+		destroy_workqueue(disp->wq);
 	return disp;
 }
 
@@ -136,7 +138,6 @@ nv50_disp_new_(const struct nv50_disp_func *func, struct nvkm_device *device,
 
 	if (!(disp = kzalloc(sizeof(*disp), GFP_KERNEL)))
 		return -ENOMEM;
-	INIT_WORK(&disp->supervisor, func->super);
 	disp->func = func;
 	*pdisp = &disp->base;
 
@@ -144,6 +145,11 @@ nv50_disp_new_(const struct nv50_disp_func *func, struct nvkm_device *device,
 	if (ret)
 		return ret;
 
+	disp->wq = create_singlethread_workqueue("nvkm-disp");
+	if (!disp->wq)
+		return -ENOMEM;
+	INIT_WORK(&disp->supervisor, func->super);
+
 	for (i = 0; func->head.new && i < heads; i++) {
 		ret = func->head.new(&disp->base, i);
 		if (ret)
@@ -803,7 +809,7 @@ nv50_disp_intr(struct nv50_disp *disp)
 
 	if (intr1 & 0x00000070) {
 		disp->super = (intr1 & 0x00000070);
-		schedule_work(&disp->supervisor);
+		queue_work(disp->wq, &disp->supervisor);
 		nvkm_wr32(device, 0x610024, disp->super);
 	}
 }

commit 22e008f90d546507d57bdac92030cece73ded09a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/dp: only check for re-train when the link is active
    
    An upcoming commit will limit link training to only when the sink is
    meant to be displaying an image.
    
    We still need IRQs enabled even when the link isn't trained (for MST
    messages), but don't want to train the link unnecessarily.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index bd67335d5466..acc663061ceb 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -661,9 +661,8 @@ nv50_disp_intr_unk20_0(struct nv50_disp *disp, int head)
 			.execute = 1,
 		};
 
-		nvkm_notify_put(&outpdp->irq);
-		nvbios_exec(&init);
 		atomic_set(&outpdp->lt.done, 0);
+		nvbios_exec(&init);
 	}
 }
 

commit 78f1ad6f655847411b36bda2b2acbd0648a03d5c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp: introduce input/output resource abstraction
    
    In order to properly support the SOR -> SOR + pad macro separation
    that occurred with GM20x GPUs, we need to separate OR handling out
    of the output path code.
    
    This will be used as the base to support ORs (DAC, SOR, PIOR).
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index aa7ed87825e5..bd67335d5466 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -23,6 +23,7 @@
  */
 #include "nv50.h"
 #include "head.h"
+#include "ior.h"
 #include "rootnv50.h"
 
 #include <core/client.h>
@@ -149,6 +150,24 @@ nv50_disp_new_(const struct nv50_disp_func *func, struct nvkm_device *device,
 			return ret;
 	}
 
+	for (i = 0; func->dac.new && i < func->dac.nr; i++) {
+		ret = func->dac.new(&disp->base, i);
+		if (ret)
+			return ret;
+	}
+
+	for (i = 0; func->pior.new && i < func->pior.nr; i++) {
+		ret = func->pior.new(&disp->base, i);
+		if (ret)
+			return ret;
+	}
+
+	for (i = 0; func->sor.new && i < func->sor.nr; i++) {
+		ret = func->sor.new(&disp->base, i);
+		if (ret)
+			return ret;
+	}
+
 	return nvkm_event_init(func->uevent, 1, 1 + (heads * 4), &disp->uevent);
 }
 
@@ -803,11 +822,14 @@ nv50_disp = {
 	.outp.external.tmds = nv50_pior_output_new,
 	.outp.external.dp = nv50_pior_dp_new,
 	.dac.nr = 3,
+	.dac.new = nv50_dac_new,
 	.dac.power = nv50_dac_power,
 	.dac.sense = nv50_dac_sense,
 	.sor.nr = 2,
+	.sor.new = nv50_sor_new,
 	.sor.power = nv50_sor_power,
 	.pior.nr = 3,
+	.pior.new = nv50_pior_new,
 	.pior.power = nv50_pior_power,
 };
 

commit 57b2d73be275f853066aaf5cc33f6c59a94260b2
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp: common implementation of scanoutpos method in nvkm_head
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 6f2314d5dac1..aa7ed87825e5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -797,7 +797,6 @@ nv50_disp = {
 	.super = nv50_disp_super,
 	.root = &nv50_disp_root_oclass,
 	.head.new = nv50_head_new,
-	.head.scanoutpos = nv50_disp_root_scanoutpos,
 	.outp.internal.crt = nv50_dac_output_new,
 	.outp.internal.tmds = nv50_sor_output_new,
 	.outp.internal.lvds = nv50_sor_output_new,

commit 14187b007e646c0dbf0813d22f7733cf6eebc099
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp: move vblank_{get,put} methods into nvkm_head
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 9787a4cc4cce..6f2314d5dac1 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -98,20 +98,6 @@ nv50_disp_outp_external_dp_(struct nvkm_disp *base, int index,
 	return -ENODEV;
 }
 
-static void
-nv50_disp_vblank_fini_(struct nvkm_disp *base, int head)
-{
-	struct nv50_disp *disp = nv50_disp(base);
-	disp->func->head.vblank_fini(disp, head);
-}
-
-static void
-nv50_disp_vblank_init_(struct nvkm_disp *base, int head)
-{
-	struct nv50_disp *disp = nv50_disp(base);
-	disp->func->head.vblank_init(disp, head);
-}
-
 static void
 nv50_disp_intr_(struct nvkm_disp *base)
 {
@@ -138,8 +124,6 @@ nv50_disp_ = {
 	.outp.internal.dp = nv50_disp_outp_internal_dp_,
 	.outp.external.tmds = nv50_disp_outp_external_tmds_,
 	.outp.external.dp = nv50_disp_outp_external_dp_,
-	.head.vblank_init = nv50_disp_vblank_init_,
-	.head.vblank_fini = nv50_disp_vblank_fini_,
 };
 
 int
@@ -168,20 +152,6 @@ nv50_disp_new_(const struct nv50_disp_func *func, struct nvkm_device *device,
 	return nvkm_event_init(func->uevent, 1, 1 + (heads * 4), &disp->uevent);
 }
 
-void
-nv50_disp_vblank_fini(struct nv50_disp *disp, int head)
-{
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	nvkm_mask(device, 0x61002c, (4 << head), 0);
-}
-
-void
-nv50_disp_vblank_init(struct nv50_disp *disp, int head)
-{
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	nvkm_mask(device, 0x61002c, (4 << head), (4 << head));
-}
-
 static struct nvkm_output *
 exec_lookup(struct nv50_disp *disp, int head, int or, u32 ctrl,
 	    u32 *data, u8 *ver, u8 *hdr, u8 *cnt, u8 *len,
@@ -827,8 +797,6 @@ nv50_disp = {
 	.super = nv50_disp_super,
 	.root = &nv50_disp_root_oclass,
 	.head.new = nv50_head_new,
-	.head.vblank_init = nv50_disp_vblank_init,
-	.head.vblank_fini = nv50_disp_vblank_fini,
 	.head.scanoutpos = nv50_disp_root_scanoutpos,
 	.outp.internal.crt = nv50_dac_output_new,
 	.outp.internal.tmds = nv50_sor_output_new,

commit a1c930789aa51b928f804c9186f9821efd070ce1
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/disp: introduce object to track per-head functions/state
    
    Primarily intended as a way to pass per-head state around during
    supervisor handling, and share logic between NV50/GF119.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 025cc0d7feb3..9787a4cc4cce 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -22,6 +22,7 @@
  * Authors: Ben Skeggs
  */
 #include "nv50.h"
+#include "head.h"
 #include "rootnv50.h"
 
 #include <core/client.h>
@@ -146,7 +147,7 @@ nv50_disp_new_(const struct nv50_disp_func *func, struct nvkm_device *device,
 	       int index, int heads, struct nvkm_disp **pdisp)
 {
 	struct nv50_disp *disp;
-	int ret;
+	int ret, i;
 
 	if (!(disp = kzalloc(sizeof(*disp), GFP_KERNEL)))
 		return -ENOMEM;
@@ -154,10 +155,16 @@ nv50_disp_new_(const struct nv50_disp_func *func, struct nvkm_device *device,
 	disp->func = func;
 	*pdisp = &disp->base;
 
-	ret = nvkm_disp_ctor(&nv50_disp_, device, index, heads, &disp->base);
+	ret = nvkm_disp_ctor(&nv50_disp_, device, index, &disp->base);
 	if (ret)
 		return ret;
 
+	for (i = 0; func->head.new && i < heads; i++) {
+		ret = func->head.new(&disp->base, i);
+		if (ret)
+			return ret;
+	}
+
 	return nvkm_event_init(func->uevent, 1, 1 + (heads * 4), &disp->uevent);
 }
 
@@ -684,43 +691,43 @@ nv50_disp_super(struct work_struct *work)
 		container_of(work, struct nv50_disp, supervisor);
 	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
 	struct nvkm_device *device = subdev->device;
+	struct nvkm_head *head;
 	u32 super = nvkm_rd32(device, 0x610030);
-	int head;
 
 	nvkm_debug(subdev, "supervisor %08x %08x\n", disp->super, super);
 
 	if (disp->super & 0x00000010) {
 		nv50_disp_chan_mthd(disp->chan[0], NV_DBG_DEBUG);
-		for (head = 0; head < disp->base.head.nr; head++) {
-			if (!(super & (0x00000020 << head)))
+		list_for_each_entry(head, &disp->base.head, head) {
+			if (!(super & (0x00000020 << head->id)))
 				continue;
-			if (!(super & (0x00000080 << head)))
+			if (!(super & (0x00000080 << head->id)))
 				continue;
-			nv50_disp_intr_unk10_0(disp, head);
+			nv50_disp_intr_unk10_0(disp, head->id);
 		}
 	} else
 	if (disp->super & 0x00000020) {
-		for (head = 0; head < disp->base.head.nr; head++) {
-			if (!(super & (0x00000080 << head)))
+		list_for_each_entry(head, &disp->base.head, head) {
+			if (!(super & (0x00000080 << head->id)))
 				continue;
-			nv50_disp_intr_unk20_0(disp, head);
+			nv50_disp_intr_unk20_0(disp, head->id);
 		}
-		for (head = 0; head < disp->base.head.nr; head++) {
-			if (!(super & (0x00000200 << head)))
+		list_for_each_entry(head, &disp->base.head, head) {
+			if (!(super & (0x00000200 << head->id)))
 				continue;
-			nv50_disp_intr_unk20_1(disp, head);
+			nv50_disp_intr_unk20_1(disp, head->id);
 		}
-		for (head = 0; head < disp->base.head.nr; head++) {
-			if (!(super & (0x00000080 << head)))
+		list_for_each_entry(head, &disp->base.head, head) {
+			if (!(super & (0x00000080 << head->id)))
 				continue;
-			nv50_disp_intr_unk20_2(disp, head);
+			nv50_disp_intr_unk20_2(disp, head->id);
 		}
 	} else
 	if (disp->super & 0x00000040) {
-		for (head = 0; head < disp->base.head.nr; head++) {
-			if (!(super & (0x00000080 << head)))
+		list_for_each_entry(head, &disp->base.head, head) {
+			if (!(super & (0x00000080 << head->id)))
 				continue;
-			nv50_disp_intr_unk40_0(disp, head);
+			nv50_disp_intr_unk40_0(disp, head->id);
 		}
 		nv50_disp_update_sppll1(disp);
 	}
@@ -819,6 +826,7 @@ nv50_disp = {
 	.uevent = &nv50_disp_chan_uevent,
 	.super = nv50_disp_super,
 	.root = &nv50_disp_root_oclass,
+	.head.new = nv50_head_new,
 	.head.vblank_init = nv50_disp_vblank_init,
 	.head.vblank_fini = nv50_disp_vblank_fini,
 	.head.scanoutpos = nv50_disp_root_scanoutpos,

commit af85389c614ae04970c0eea7a5c50fb889c8a480
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/disp: shuffle functions around
    
    Upcoming changes to split OR from output path drastically change the
    placement of various operations.
    
    In order to make the real changes clearer, do the moving around part
    ahead of time.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 0db8efbf1c2e..025cc0d7feb3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -175,55 +175,6 @@ nv50_disp_vblank_init(struct nv50_disp *disp, int head)
 	nvkm_mask(device, 0x61002c, (4 << head), (4 << head));
 }
 
-static const struct nvkm_enum
-nv50_disp_intr_error_type[] = {
-	{ 3, "ILLEGAL_MTHD" },
-	{ 4, "INVALID_VALUE" },
-	{ 5, "INVALID_STATE" },
-	{ 7, "INVALID_HANDLE" },
-	{}
-};
-
-static const struct nvkm_enum
-nv50_disp_intr_error_code[] = {
-	{ 0x00, "" },
-	{}
-};
-
-static void
-nv50_disp_intr_error(struct nv50_disp *disp, int chid)
-{
-	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
-	struct nvkm_device *device = subdev->device;
-	u32 data = nvkm_rd32(device, 0x610084 + (chid * 0x08));
-	u32 addr = nvkm_rd32(device, 0x610080 + (chid * 0x08));
-	u32 code = (addr & 0x00ff0000) >> 16;
-	u32 type = (addr & 0x00007000) >> 12;
-	u32 mthd = (addr & 0x00000ffc);
-	const struct nvkm_enum *ec, *et;
-
-	et = nvkm_enum_find(nv50_disp_intr_error_type, type);
-	ec = nvkm_enum_find(nv50_disp_intr_error_code, code);
-
-	nvkm_error(subdev,
-		   "ERROR %d [%s] %02x [%s] chid %d mthd %04x data %08x\n",
-		   type, et ? et->name : "", code, ec ? ec->name : "",
-		   chid, mthd, data);
-
-	if (chid < ARRAY_SIZE(disp->chan)) {
-		switch (mthd) {
-		case 0x0080:
-			nv50_disp_chan_mthd(disp->chan[chid], NV_DBG_ERROR);
-			break;
-		default:
-			break;
-		}
-	}
-
-	nvkm_wr32(device, 0x610020, 0x00010000 << chid);
-	nvkm_wr32(device, 0x610080 + (chid * 0x08), 0x90000000);
-}
-
 static struct nvkm_output *
 exec_lookup(struct nv50_disp *disp, int head, int or, u32 ctrl,
 	    u32 *data, u8 *ver, u8 *hdr, u8 *cnt, u8 *len,
@@ -426,182 +377,46 @@ exec_clkcmp(struct nv50_disp *disp, int head, int id, u32 pclk, u32 *conf)
 	return outp;
 }
 
-static bool
-nv50_disp_dptmds_war(struct nvkm_device *device)
-{
-	switch (device->chipset) {
-	case 0x94:
-	case 0x96:
-	case 0x98:
-		return true;
-	default:
-		break;
-	}
-	return false;
-}
-
-static bool
-nv50_disp_dptmds_war_needed(struct nv50_disp *disp, struct dcb_output *outp)
-{
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	const u32 soff = __ffs(outp->or) * 0x800;
-	if (nv50_disp_dptmds_war(device) && outp->type == DCB_OUTPUT_TMDS) {
-		switch (nvkm_rd32(device, 0x614300 + soff) & 0x00030000) {
-		case 0x00000000:
-		case 0x00030000:
-			return true;
-		default:
-			break;
-		}
-	}
-	return false;
-
-}
-
-static void
-nv50_disp_dptmds_war_2(struct nv50_disp *disp, struct dcb_output *outp)
-{
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	const u32 soff = __ffs(outp->or) * 0x800;
-
-	if (!nv50_disp_dptmds_war_needed(disp, outp))
-		return;
-
-	nvkm_mask(device, 0x00e840, 0x80000000, 0x80000000);
-	nvkm_mask(device, 0x614300 + soff, 0x03000000, 0x03000000);
-	nvkm_mask(device, 0x61c10c + soff, 0x00000001, 0x00000001);
-
-	nvkm_mask(device, 0x61c00c + soff, 0x0f000000, 0x00000000);
-	nvkm_mask(device, 0x61c008 + soff, 0xff000000, 0x14000000);
-	nvkm_usec(device, 400, NVKM_DELAY);
-	nvkm_mask(device, 0x61c008 + soff, 0xff000000, 0x00000000);
-	nvkm_mask(device, 0x61c00c + soff, 0x0f000000, 0x01000000);
-
-	if (nvkm_rd32(device, 0x61c004 + soff) & 0x00000001) {
-		u32 seqctl = nvkm_rd32(device, 0x61c030 + soff);
-		u32  pu_pc = seqctl & 0x0000000f;
-		nvkm_wr32(device, 0x61c040 + soff + pu_pc * 4, 0x1f008000);
-	}
-}
-
+/* If programming a TMDS output on a SOR that can also be configured for
+ * DisplayPort, make sure NV50_SOR_DP_CTRL_ENABLE is forced off.
+ *
+ * It looks like the VBIOS TMDS scripts make an attempt at this, however,
+ * the VBIOS scripts on at least one board I have only switch it off on
+ * link 0, causing a blank display if the output has previously been
+ * programmed for DisplayPort.
+ */
 static void
-nv50_disp_dptmds_war_3(struct nv50_disp *disp, struct dcb_output *outp)
+nv50_disp_intr_unk40_0_tmds(struct nv50_disp *disp,
+			    struct dcb_output *outp)
 {
 	struct nvkm_device *device = disp->base.engine.subdev.device;
-	const u32 soff = __ffs(outp->or) * 0x800;
-	u32 sorpwr;
-
-	if (!nv50_disp_dptmds_war_needed(disp, outp))
-		return;
-
-	sorpwr = nvkm_rd32(device, 0x61c004 + soff);
-	if (sorpwr & 0x00000001) {
-		u32 seqctl = nvkm_rd32(device, 0x61c030 + soff);
-		u32  pd_pc = (seqctl & 0x00000f00) >> 8;
-		u32  pu_pc =  seqctl & 0x0000000f;
-
-		nvkm_wr32(device, 0x61c040 + soff + pd_pc * 4, 0x1f008000);
-
-		nvkm_msec(device, 2000,
-			if (!(nvkm_rd32(device, 0x61c030 + soff) & 0x10000000))
-				break;
-		);
-		nvkm_mask(device, 0x61c004 + soff, 0x80000001, 0x80000000);
-		nvkm_msec(device, 2000,
-			if (!(nvkm_rd32(device, 0x61c030 + soff) & 0x10000000))
-				break;
-		);
-
-		nvkm_wr32(device, 0x61c040 + soff + pd_pc * 4, 0x00002000);
-		nvkm_wr32(device, 0x61c040 + soff + pu_pc * 4, 0x1f000000);
-	}
-
-	nvkm_mask(device, 0x61c10c + soff, 0x00000001, 0x00000000);
-	nvkm_mask(device, 0x614300 + soff, 0x03000000, 0x00000000);
+	struct nvkm_bios *bios = device->bios;
+	const int link = !(outp->sorconf.link & 1);
+	const int   or = ffs(outp->or) - 1;
+	const u32 loff = (or * 0x800) + (link * 0x80);
+	const u16 mask = (outp->sorconf.link << 6) | outp->or;
+	struct dcb_output match;
+	u8  ver, hdr;
 
-	if (sorpwr & 0x00000001) {
-		nvkm_mask(device, 0x61c004 + soff, 0x80000001, 0x80000001);
-	}
+	if (dcb_outp_match(bios, DCB_OUTPUT_DP, mask, &ver, &hdr, &match))
+		nvkm_mask(device, 0x61c10c + loff, 0x00000001, 0x00000000);
 }
 
 static void
-nv50_disp_update_sppll1(struct nv50_disp *disp)
+nv50_disp_intr_unk40_0(struct nv50_disp *disp, int head)
 {
 	struct nvkm_device *device = disp->base.engine.subdev.device;
-	bool used = false;
-	int sor;
-
-	if (!nv50_disp_dptmds_war(device))
-		return;
-
-	for (sor = 0; sor < disp->func->sor.nr; sor++) {
-		u32 clksor = nvkm_rd32(device, 0x614300 + (sor * 0x800));
-		switch (clksor & 0x03000000) {
-		case 0x02000000:
-		case 0x03000000:
-			used = true;
-			break;
-		default:
-			break;
-		}
-	}
+	struct nvkm_output *outp;
+	u32 pclk = nvkm_rd32(device, 0x610ad0 + (head * 0x540)) & 0x3fffff;
+	u32 conf;
 
-	if (used)
+	outp = exec_clkcmp(disp, head, 1, pclk, &conf);
+	if (!outp)
 		return;
 
-	nvkm_mask(device, 0x00e840, 0x80000000, 0x00000000);
-}
-
-static void
-nv50_disp_intr_unk10_0(struct nv50_disp *disp, int head)
-{
-	exec_script(disp, head, 1);
-}
-
-static void
-nv50_disp_intr_unk20_0(struct nv50_disp *disp, int head)
-{
-	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
-	struct nvkm_output *outp = exec_script(disp, head, 2);
-
-	/* the binary driver does this outside of the supervisor handling
-	 * (after the third supervisor from a detach).  we (currently?)
-	 * allow both detach/attach to happen in the same set of
-	 * supervisor interrupts, so it would make sense to execute this
-	 * (full power down?) script after all the detach phases of the
-	 * supervisor handling.  like with training if needed from the
-	 * second supervisor, nvidia doesn't do this, so who knows if it's
-	 * entirely safe, but it does appear to work..
-	 *
-	 * without this script being run, on some configurations i've
-	 * seen, switching from DP to TMDS on a DP connector may result
-	 * in a blank screen (SOR_PWR off/on can restore it)
-	 */
-	if (outp && outp->info.type == DCB_OUTPUT_DP) {
-		struct nvkm_output_dp *outpdp = nvkm_output_dp(outp);
-		struct nvbios_init init = {
-			.subdev = subdev,
-			.bios = subdev->device->bios,
-			.outp = &outp->info,
-			.crtc = head,
-			.offset = outpdp->info.script[4],
-			.execute = 1,
-		};
-
-		nvkm_notify_put(&outpdp->irq);
-		nvbios_exec(&init);
-		atomic_set(&outpdp->lt.done, 0);
-	}
-}
-
-static void
-nv50_disp_intr_unk20_1(struct nv50_disp *disp, int head)
-{
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	struct nvkm_devinit *devinit = device->devinit;
-	u32 pclk = nvkm_rd32(device, 0x610ad0 + (head * 0x540)) & 0x3fffff;
-	if (pclk)
-		nvkm_devinit_pll_set(devinit, PLL_VPLL0 + head, pclk);
+	if (outp->info.location == 0 && outp->info.type == DCB_OUTPUT_TMDS)
+		nv50_disp_intr_unk40_0_tmds(disp, &outp->info);
+	nv50_disp_dptmds_war_3(disp, &outp->info);
 }
 
 static void
@@ -810,50 +625,60 @@ nv50_disp_intr_unk20_2(struct nv50_disp *disp, int head)
 	nv50_disp_dptmds_war_2(disp, &outp->info);
 }
 
-/* If programming a TMDS output on a SOR that can also be configured for
- * DisplayPort, make sure NV50_SOR_DP_CTRL_ENABLE is forced off.
- *
- * It looks like the VBIOS TMDS scripts make an attempt at this, however,
- * the VBIOS scripts on at least one board I have only switch it off on
- * link 0, causing a blank display if the output has previously been
- * programmed for DisplayPort.
- */
 static void
-nv50_disp_intr_unk40_0_tmds(struct nv50_disp *disp,
-			    struct dcb_output *outp)
+nv50_disp_intr_unk20_1(struct nv50_disp *disp, int head)
 {
 	struct nvkm_device *device = disp->base.engine.subdev.device;
-	struct nvkm_bios *bios = device->bios;
-	const int link = !(outp->sorconf.link & 1);
-	const int   or = ffs(outp->or) - 1;
-	const u32 loff = (or * 0x800) + (link * 0x80);
-	const u16 mask = (outp->sorconf.link << 6) | outp->or;
-	struct dcb_output match;
-	u8  ver, hdr;
-
-	if (dcb_outp_match(bios, DCB_OUTPUT_DP, mask, &ver, &hdr, &match))
-		nvkm_mask(device, 0x61c10c + loff, 0x00000001, 0x00000000);
+	struct nvkm_devinit *devinit = device->devinit;
+	u32 pclk = nvkm_rd32(device, 0x610ad0 + (head * 0x540)) & 0x3fffff;
+	if (pclk)
+		nvkm_devinit_pll_set(devinit, PLL_VPLL0 + head, pclk);
 }
 
 static void
-nv50_disp_intr_unk40_0(struct nv50_disp *disp, int head)
+nv50_disp_intr_unk20_0(struct nv50_disp *disp, int head)
 {
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	struct nvkm_output *outp;
-	u32 pclk = nvkm_rd32(device, 0x610ad0 + (head * 0x540)) & 0x3fffff;
-	u32 conf;
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
+	struct nvkm_output *outp = exec_script(disp, head, 2);
 
-	outp = exec_clkcmp(disp, head, 1, pclk, &conf);
-	if (!outp)
-		return;
+	/* the binary driver does this outside of the supervisor handling
+	 * (after the third supervisor from a detach).  we (currently?)
+	 * allow both detach/attach to happen in the same set of
+	 * supervisor interrupts, so it would make sense to execute this
+	 * (full power down?) script after all the detach phases of the
+	 * supervisor handling.  like with training if needed from the
+	 * second supervisor, nvidia doesn't do this, so who knows if it's
+	 * entirely safe, but it does appear to work..
+	 *
+	 * without this script being run, on some configurations i've
+	 * seen, switching from DP to TMDS on a DP connector may result
+	 * in a blank screen (SOR_PWR off/on can restore it)
+	 */
+	if (outp && outp->info.type == DCB_OUTPUT_DP) {
+		struct nvkm_output_dp *outpdp = nvkm_output_dp(outp);
+		struct nvbios_init init = {
+			.subdev = subdev,
+			.bios = subdev->device->bios,
+			.outp = &outp->info,
+			.crtc = head,
+			.offset = outpdp->info.script[4],
+			.execute = 1,
+		};
 
-	if (outp->info.location == 0 && outp->info.type == DCB_OUTPUT_TMDS)
-		nv50_disp_intr_unk40_0_tmds(disp, &outp->info);
-	nv50_disp_dptmds_war_3(disp, &outp->info);
+		nvkm_notify_put(&outpdp->irq);
+		nvbios_exec(&init);
+		atomic_set(&outpdp->lt.done, 0);
+	}
+}
+
+static void
+nv50_disp_intr_unk10_0(struct nv50_disp *disp, int head)
+{
+	exec_script(disp, head, 1);
 }
 
 void
-nv50_disp_intr_supervisor(struct work_struct *work)
+nv50_disp_super(struct work_struct *work)
 {
 	struct nv50_disp *disp =
 		container_of(work, struct nv50_disp, supervisor);
@@ -903,6 +728,55 @@ nv50_disp_intr_supervisor(struct work_struct *work)
 	nvkm_wr32(device, 0x610030, 0x80000000);
 }
 
+static const struct nvkm_enum
+nv50_disp_intr_error_type[] = {
+	{ 3, "ILLEGAL_MTHD" },
+	{ 4, "INVALID_VALUE" },
+	{ 5, "INVALID_STATE" },
+	{ 7, "INVALID_HANDLE" },
+	{}
+};
+
+static const struct nvkm_enum
+nv50_disp_intr_error_code[] = {
+	{ 0x00, "" },
+	{}
+};
+
+static void
+nv50_disp_intr_error(struct nv50_disp *disp, int chid)
+{
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
+	u32 data = nvkm_rd32(device, 0x610084 + (chid * 0x08));
+	u32 addr = nvkm_rd32(device, 0x610080 + (chid * 0x08));
+	u32 code = (addr & 0x00ff0000) >> 16;
+	u32 type = (addr & 0x00007000) >> 12;
+	u32 mthd = (addr & 0x00000ffc);
+	const struct nvkm_enum *ec, *et;
+
+	et = nvkm_enum_find(nv50_disp_intr_error_type, type);
+	ec = nvkm_enum_find(nv50_disp_intr_error_code, code);
+
+	nvkm_error(subdev,
+		   "ERROR %d [%s] %02x [%s] chid %d mthd %04x data %08x\n",
+		   type, et ? et->name : "", code, ec ? ec->name : "",
+		   chid, mthd, data);
+
+	if (chid < ARRAY_SIZE(disp->chan)) {
+		switch (mthd) {
+		case 0x0080:
+			nv50_disp_chan_mthd(disp->chan[chid], NV_DBG_ERROR);
+			break;
+		default:
+			break;
+		}
+	}
+
+	nvkm_wr32(device, 0x610020, 0x00010000 << chid);
+	nvkm_wr32(device, 0x610080 + (chid * 0x08), 0x90000000);
+}
+
 void
 nv50_disp_intr(struct nv50_disp *disp)
 {
@@ -943,7 +817,7 @@ static const struct nv50_disp_func
 nv50_disp = {
 	.intr = nv50_disp_intr,
 	.uevent = &nv50_disp_chan_uevent,
-	.super = nv50_disp_intr_supervisor,
+	.super = nv50_disp_super,
 	.root = &nv50_disp_root_oclass,
 	.head.vblank_init = nv50_disp_vblank_init,
 	.head.vblank_fini = nv50_disp_vblank_fini,

commit 7dfee6827780d4228148263545af936d0cae8930
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon Jan 9 10:22:15 2017 +1000

    drm/nouveau/disp/mcp7x: disable dptmds workaround
    
    The workaround appears to cause regressions on these boards, and from
    inspection of RM traces, NVIDIA don't appear to do it on them either.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Tested-by: Roy Spliet <nouveau@spliet.org>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 567466f93cd5..0db8efbf1c2e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -433,8 +433,6 @@ nv50_disp_dptmds_war(struct nvkm_device *device)
 	case 0x94:
 	case 0x96:
 	case 0x98:
-	case 0xaa:
-	case 0xac:
 		return true;
 	default:
 		break;

commit 725fa3ac39bef350b24445740d3dcf3a5d4af841
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 4 17:20:35 2016 +1000

    drm/nouveau/disp/g94-: stop listening for dp (sst) retrain irq when disabling link
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index a2bd0f06200f..567466f93cd5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -590,6 +590,7 @@ nv50_disp_intr_unk20_0(struct nv50_disp *disp, int head)
 			.execute = 1,
 		};
 
+		nvkm_notify_put(&outpdp->irq);
 		nvbios_exec(&init);
 		atomic_set(&outpdp->lt.done, 0);
 	}

commit 1f8711bafe0b43716592a3797f693eb7c0175123
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 4 17:20:35 2016 +1000

    drm/nouveau/disp/dp: remove workqueue for link training
    
    There haven't been any callers from an atomic context for a while now,
    so let's remove the extra complexity.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index fbb8c7dc18fd..a2bd0f06200f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -779,7 +779,7 @@ nv50_disp_intr_unk20_2(struct nv50_disp *disp, int head)
 			break;
 		}
 
-		if (nvkm_output_dp_train(outp, datarate / soff, true))
+		if (nvkm_output_dp_train(outp, datarate / soff))
 			OUTP_ERR(outp, "link not trained before attach");
 	}
 

commit 2a4bd8ac2ff775ee285dc0dc74d4d820d7439402
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon Jun 27 16:49:24 2016 +1000

    drm/nouveau/disp/g94: implement workaround for dvi issue on fx380
    
    Fixes the second DVI output on Quadro FX380.
    
    Thanks to NVIDIA for providing the details on the full workaround.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 0ea9d9df674b..fbb8c7dc18fd 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -32,6 +32,7 @@
 #include <subdev/bios/init.h>
 #include <subdev/bios/pll.h>
 #include <subdev/devinit.h>
+#include <subdev/timer.h>
 
 static const struct nvkm_disp_oclass *
 nv50_disp_root_(struct nvkm_disp *base)
@@ -425,6 +426,134 @@ exec_clkcmp(struct nv50_disp *disp, int head, int id, u32 pclk, u32 *conf)
 	return outp;
 }
 
+static bool
+nv50_disp_dptmds_war(struct nvkm_device *device)
+{
+	switch (device->chipset) {
+	case 0x94:
+	case 0x96:
+	case 0x98:
+	case 0xaa:
+	case 0xac:
+		return true;
+	default:
+		break;
+	}
+	return false;
+}
+
+static bool
+nv50_disp_dptmds_war_needed(struct nv50_disp *disp, struct dcb_output *outp)
+{
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	const u32 soff = __ffs(outp->or) * 0x800;
+	if (nv50_disp_dptmds_war(device) && outp->type == DCB_OUTPUT_TMDS) {
+		switch (nvkm_rd32(device, 0x614300 + soff) & 0x00030000) {
+		case 0x00000000:
+		case 0x00030000:
+			return true;
+		default:
+			break;
+		}
+	}
+	return false;
+
+}
+
+static void
+nv50_disp_dptmds_war_2(struct nv50_disp *disp, struct dcb_output *outp)
+{
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	const u32 soff = __ffs(outp->or) * 0x800;
+
+	if (!nv50_disp_dptmds_war_needed(disp, outp))
+		return;
+
+	nvkm_mask(device, 0x00e840, 0x80000000, 0x80000000);
+	nvkm_mask(device, 0x614300 + soff, 0x03000000, 0x03000000);
+	nvkm_mask(device, 0x61c10c + soff, 0x00000001, 0x00000001);
+
+	nvkm_mask(device, 0x61c00c + soff, 0x0f000000, 0x00000000);
+	nvkm_mask(device, 0x61c008 + soff, 0xff000000, 0x14000000);
+	nvkm_usec(device, 400, NVKM_DELAY);
+	nvkm_mask(device, 0x61c008 + soff, 0xff000000, 0x00000000);
+	nvkm_mask(device, 0x61c00c + soff, 0x0f000000, 0x01000000);
+
+	if (nvkm_rd32(device, 0x61c004 + soff) & 0x00000001) {
+		u32 seqctl = nvkm_rd32(device, 0x61c030 + soff);
+		u32  pu_pc = seqctl & 0x0000000f;
+		nvkm_wr32(device, 0x61c040 + soff + pu_pc * 4, 0x1f008000);
+	}
+}
+
+static void
+nv50_disp_dptmds_war_3(struct nv50_disp *disp, struct dcb_output *outp)
+{
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	const u32 soff = __ffs(outp->or) * 0x800;
+	u32 sorpwr;
+
+	if (!nv50_disp_dptmds_war_needed(disp, outp))
+		return;
+
+	sorpwr = nvkm_rd32(device, 0x61c004 + soff);
+	if (sorpwr & 0x00000001) {
+		u32 seqctl = nvkm_rd32(device, 0x61c030 + soff);
+		u32  pd_pc = (seqctl & 0x00000f00) >> 8;
+		u32  pu_pc =  seqctl & 0x0000000f;
+
+		nvkm_wr32(device, 0x61c040 + soff + pd_pc * 4, 0x1f008000);
+
+		nvkm_msec(device, 2000,
+			if (!(nvkm_rd32(device, 0x61c030 + soff) & 0x10000000))
+				break;
+		);
+		nvkm_mask(device, 0x61c004 + soff, 0x80000001, 0x80000000);
+		nvkm_msec(device, 2000,
+			if (!(nvkm_rd32(device, 0x61c030 + soff) & 0x10000000))
+				break;
+		);
+
+		nvkm_wr32(device, 0x61c040 + soff + pd_pc * 4, 0x00002000);
+		nvkm_wr32(device, 0x61c040 + soff + pu_pc * 4, 0x1f000000);
+	}
+
+	nvkm_mask(device, 0x61c10c + soff, 0x00000001, 0x00000000);
+	nvkm_mask(device, 0x614300 + soff, 0x03000000, 0x00000000);
+
+	if (sorpwr & 0x00000001) {
+		nvkm_mask(device, 0x61c004 + soff, 0x80000001, 0x80000001);
+	}
+}
+
+static void
+nv50_disp_update_sppll1(struct nv50_disp *disp)
+{
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	bool used = false;
+	int sor;
+
+	if (!nv50_disp_dptmds_war(device))
+		return;
+
+	for (sor = 0; sor < disp->func->sor.nr; sor++) {
+		u32 clksor = nvkm_rd32(device, 0x614300 + (sor * 0x800));
+		switch (clksor & 0x03000000) {
+		case 0x02000000:
+		case 0x03000000:
+			used = true;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (used)
+		return;
+
+	nvkm_mask(device, 0x00e840, 0x80000000, 0x00000000);
+}
+
 static void
 nv50_disp_intr_unk10_0(struct nv50_disp *disp, int head)
 {
@@ -678,6 +807,8 @@ nv50_disp_intr_unk20_2(struct nv50_disp *disp, int head)
 
 	nvkm_mask(device, hreg, 0x0000000f, hval);
 	nvkm_mask(device, oreg, mask, oval);
+
+	nv50_disp_dptmds_war_2(disp, &outp->info);
 }
 
 /* If programming a TMDS output on a SOR that can also be configured for
@@ -719,6 +850,7 @@ nv50_disp_intr_unk40_0(struct nv50_disp *disp, int head)
 
 	if (outp->info.location == 0 && outp->info.type == DCB_OUTPUT_TMDS)
 		nv50_disp_intr_unk40_0_tmds(disp, &outp->info);
+	nv50_disp_dptmds_war_3(disp, &outp->info);
 }
 
 void
@@ -766,6 +898,7 @@ nv50_disp_intr_supervisor(struct work_struct *work)
 				continue;
 			nv50_disp_intr_unk40_0(disp, head);
 		}
+		nv50_disp_update_sppll1(disp);
 	}
 
 	nvkm_wr32(device, 0x610030, 0x80000000);

commit 9a2b8131c38e9e9fea6a803efe855a542c0f32d1
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jun 21 16:29:03 2016 +1000

    drm/nouveau/disp/nv50-: fix lookup of udisp table under certain circumstances
    
    Some VBIOS have separate tables for each link of a given output path,
    which means we have to specify the specific link we're using instead
    of all possible links.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index fcb1b0c46d64..0ea9d9df674b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -269,8 +269,7 @@ exec_lookup(struct nv50_disp *disp, int head, int or, u32 ctrl,
 	list_for_each_entry(outp, &disp->base.outp, head) {
 		if ((outp->info.hasht & 0xff) == type &&
 		    (outp->info.hashm & mask) == mask) {
-			*data = nvbios_outp_match(bios, outp->info.hasht,
-							outp->info.hashm,
+			*data = nvbios_outp_match(bios, outp->info.hasht, mask,
 						  ver, hdr, cnt, len, info);
 			if (!*data)
 				return NULL;

commit bc9139d23f6b038e32bcd2dffdee70a8d76b3976
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed May 25 10:56:24 2016 +1000

    drm/nouveau/bios/disp: fix handling of "match any protocol" entries
    
    As it turns out, a value of 0xff means "any protocol" and not "VGA".
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 4226d2153b9c..fcb1b0c46d64 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -387,22 +387,17 @@ exec_clkcmp(struct nv50_disp *disp, int head, int id, u32 pclk, u32 *conf)
 	if (!outp)
 		return NULL;
 
+	*conf = (ctrl & 0x00000f00) >> 8;
 	if (outp->info.location == 0) {
 		switch (outp->info.type) {
 		case DCB_OUTPUT_TMDS:
-			*conf = (ctrl & 0x00000f00) >> 8;
 			if (*conf == 5)
 				*conf |= 0x0100;
 			break;
 		case DCB_OUTPUT_LVDS:
-			*conf = disp->sor.lvdsconf;
+			*conf |= disp->sor.lvdsconf;
 			break;
-		case DCB_OUTPUT_DP:
-			*conf = (ctrl & 0x00000f00) >> 8;
-			break;
-		case DCB_OUTPUT_ANALOG:
 		default:
-			*conf = 0x00ff;
 			break;
 		}
 	} else {
@@ -410,7 +405,8 @@ exec_clkcmp(struct nv50_disp *disp, int head, int id, u32 pclk, u32 *conf)
 		pclk = pclk / 2;
 	}
 
-	data = nvbios_ocfg_match(bios, data, *conf, &ver, &hdr, &cnt, &len, &info2);
+	data = nvbios_ocfg_match(bios, data, *conf & 0xff, *conf >> 8,
+				 &ver, &hdr, &cnt, &len, &info2);
 	if (data && id < 0xff) {
 		data = nvbios_oclk_match(bios, info2.clkcmp[id], pclk);
 		if (data) {

commit 16ef53a93c107392cd652f47251954064fa171e6
Author: Hauke Mehrtens <hauke@hauke-m.de>
Date:   Tue Nov 3 21:00:10 2015 -0500

    drm/nouveau/disp: activate dual link TMDS links only when possible
    
    Without this patch a pixel clock rate above 165 MHz on a TMDS link is
    assumed to be dual link. This is true for DVI, but not for HDMI. HDMI
    supports no dual link, but it supports pixel clock rates above 165 MHz.
    Only activate Dual Link mode when it is actually possible and requested.
    
    Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
    [imirkin: check for hdmi monitor for computing proto, use sor ctrl to
     enable extra config bit]
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 32e73a975b58..4226d2153b9c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -391,7 +391,7 @@ exec_clkcmp(struct nv50_disp *disp, int head, int id, u32 pclk, u32 *conf)
 		switch (outp->info.type) {
 		case DCB_OUTPUT_TMDS:
 			*conf = (ctrl & 0x00000f00) >> 8;
-			if (pclk >= 165000)
+			if (*conf == 5)
 				*conf |= 0x0100;
 			break;
 		case DCB_OUTPUT_LVDS:

commit 70aa8670e5229766f12c4b818a68aa61913df0b6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/disp: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index ddffcc1088be..32e73a975b58 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -33,29 +33,147 @@
 #include <subdev/bios/pll.h>
 #include <subdev/devinit.h>
 
+static const struct nvkm_disp_oclass *
+nv50_disp_root_(struct nvkm_disp *base)
+{
+	return nv50_disp(base)->func->root;
+}
+
+static int
+nv50_disp_outp_internal_crt_(struct nvkm_disp *base, int index,
+			     struct dcb_output *dcb, struct nvkm_output **poutp)
+{
+	struct nv50_disp *disp = nv50_disp(base);
+	return disp->func->outp.internal.crt(base, index, dcb, poutp);
+}
+
+static int
+nv50_disp_outp_internal_tmds_(struct nvkm_disp *base, int index,
+			      struct dcb_output *dcb,
+			      struct nvkm_output **poutp)
+{
+	struct nv50_disp *disp = nv50_disp(base);
+	return disp->func->outp.internal.tmds(base, index, dcb, poutp);
+}
+
+static int
+nv50_disp_outp_internal_lvds_(struct nvkm_disp *base, int index,
+			      struct dcb_output *dcb,
+			      struct nvkm_output **poutp)
+{
+	struct nv50_disp *disp = nv50_disp(base);
+	return disp->func->outp.internal.lvds(base, index, dcb, poutp);
+}
+
+static int
+nv50_disp_outp_internal_dp_(struct nvkm_disp *base, int index,
+			    struct dcb_output *dcb, struct nvkm_output **poutp)
+{
+	struct nv50_disp *disp = nv50_disp(base);
+	if (disp->func->outp.internal.dp)
+		return disp->func->outp.internal.dp(base, index, dcb, poutp);
+	return -ENODEV;
+}
+
+static int
+nv50_disp_outp_external_tmds_(struct nvkm_disp *base, int index,
+			      struct dcb_output *dcb,
+			      struct nvkm_output **poutp)
+{
+	struct nv50_disp *disp = nv50_disp(base);
+	if (disp->func->outp.external.tmds)
+		return disp->func->outp.external.tmds(base, index, dcb, poutp);
+	return -ENODEV;
+}
+
+static int
+nv50_disp_outp_external_dp_(struct nvkm_disp *base, int index,
+			    struct dcb_output *dcb, struct nvkm_output **poutp)
+{
+	struct nv50_disp *disp = nv50_disp(base);
+	if (disp->func->outp.external.dp)
+		return disp->func->outp.external.dp(base, index, dcb, poutp);
+	return -ENODEV;
+}
+
 static void
-nv50_disp_vblank_fini(struct nvkm_event *event, int type, int head)
+nv50_disp_vblank_fini_(struct nvkm_disp *base, int head)
 {
-	struct nvkm_disp *disp = container_of(event, typeof(*disp), vblank);
-	struct nvkm_device *device = disp->engine.subdev.device;
-	nvkm_mask(device, 0x61002c, (4 << head), 0);
+	struct nv50_disp *disp = nv50_disp(base);
+	disp->func->head.vblank_fini(disp, head);
 }
 
 static void
-nv50_disp_vblank_init(struct nvkm_event *event, int type, int head)
+nv50_disp_vblank_init_(struct nvkm_disp *base, int head)
 {
-	struct nvkm_disp *disp = container_of(event, typeof(*disp), vblank);
-	struct nvkm_device *device = disp->engine.subdev.device;
-	nvkm_mask(device, 0x61002c, (4 << head), (4 << head));
+	struct nv50_disp *disp = nv50_disp(base);
+	disp->func->head.vblank_init(disp, head);
+}
+
+static void
+nv50_disp_intr_(struct nvkm_disp *base)
+{
+	struct nv50_disp *disp = nv50_disp(base);
+	disp->func->intr(disp);
+}
+
+static void *
+nv50_disp_dtor_(struct nvkm_disp *base)
+{
+	struct nv50_disp *disp = nv50_disp(base);
+	nvkm_event_fini(&disp->uevent);
+	return disp;
 }
 
-const struct nvkm_event_func
-nv50_disp_vblank_func = {
-	.ctor = nvkm_disp_vblank_ctor,
-	.init = nv50_disp_vblank_init,
-	.fini = nv50_disp_vblank_fini,
+static const struct nvkm_disp_func
+nv50_disp_ = {
+	.dtor = nv50_disp_dtor_,
+	.intr = nv50_disp_intr_,
+	.root = nv50_disp_root_,
+	.outp.internal.crt = nv50_disp_outp_internal_crt_,
+	.outp.internal.tmds = nv50_disp_outp_internal_tmds_,
+	.outp.internal.lvds = nv50_disp_outp_internal_lvds_,
+	.outp.internal.dp = nv50_disp_outp_internal_dp_,
+	.outp.external.tmds = nv50_disp_outp_external_tmds_,
+	.outp.external.dp = nv50_disp_outp_external_dp_,
+	.head.vblank_init = nv50_disp_vblank_init_,
+	.head.vblank_fini = nv50_disp_vblank_fini_,
 };
 
+int
+nv50_disp_new_(const struct nv50_disp_func *func, struct nvkm_device *device,
+	       int index, int heads, struct nvkm_disp **pdisp)
+{
+	struct nv50_disp *disp;
+	int ret;
+
+	if (!(disp = kzalloc(sizeof(*disp), GFP_KERNEL)))
+		return -ENOMEM;
+	INIT_WORK(&disp->supervisor, func->super);
+	disp->func = func;
+	*pdisp = &disp->base;
+
+	ret = nvkm_disp_ctor(&nv50_disp_, device, index, heads, &disp->base);
+	if (ret)
+		return ret;
+
+	return nvkm_event_init(func->uevent, 1, 1 + (heads * 4), &disp->uevent);
+}
+
+void
+nv50_disp_vblank_fini(struct nv50_disp *disp, int head)
+{
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	nvkm_mask(device, 0x61002c, (4 << head), 0);
+}
+
+void
+nv50_disp_vblank_init(struct nv50_disp *disp, int head)
+{
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	nvkm_mask(device, 0x61002c, (4 << head), (4 << head));
+}
+
 static const struct nvkm_enum
 nv50_disp_intr_error_type[] = {
 	{ 3, "ILLEGAL_MTHD" },
@@ -166,7 +284,8 @@ exec_lookup(struct nv50_disp *disp, int head, int or, u32 ctrl,
 static struct nvkm_output *
 exec_script(struct nv50_disp *disp, int head, int id)
 {
-	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	struct nvkm_bios *bios = device->bios;
 	struct nvkm_output *outp;
 	struct nvbios_outp info;
@@ -176,26 +295,26 @@ exec_script(struct nv50_disp *disp, int head, int id)
 	int i;
 
 	/* DAC */
-	for (i = 0; !(ctrl & (1 << head)) && i < disp->dac.nr; i++)
+	for (i = 0; !(ctrl & (1 << head)) && i < disp->func->dac.nr; i++)
 		ctrl = nvkm_rd32(device, 0x610b5c + (i * 8));
 
 	/* SOR */
 	if (!(ctrl & (1 << head))) {
-		if (nv_device(disp)->chipset  < 0x90 ||
-		    nv_device(disp)->chipset == 0x92 ||
-		    nv_device(disp)->chipset == 0xa0) {
+		if (device->chipset  < 0x90 ||
+		    device->chipset == 0x92 ||
+		    device->chipset == 0xa0) {
 			reg = 0x610b74;
 		} else {
 			reg = 0x610798;
 		}
-		for (i = 0; !(ctrl & (1 << head)) && i < disp->sor.nr; i++)
+		for (i = 0; !(ctrl & (1 << head)) && i < disp->func->sor.nr; i++)
 			ctrl = nvkm_rd32(device, reg + (i * 8));
 		i += 4;
 	}
 
 	/* PIOR */
 	if (!(ctrl & (1 << head))) {
-		for (i = 0; !(ctrl & (1 << head)) && i < disp->pior.nr; i++)
+		for (i = 0; !(ctrl & (1 << head)) && i < disp->func->pior.nr; i++)
 			ctrl = nvkm_rd32(device, 0x610b84 + (i * 8));
 		i += 8;
 	}
@@ -207,7 +326,7 @@ exec_script(struct nv50_disp *disp, int head, int id)
 	outp = exec_lookup(disp, head, i, ctrl, &data, &ver, &hdr, &cnt, &len, &info);
 	if (outp) {
 		struct nvbios_init init = {
-			.subdev = nv_subdev(disp),
+			.subdev = subdev,
 			.bios = bios,
 			.offset = info.script[id],
 			.outp = &outp->info,
@@ -224,7 +343,8 @@ exec_script(struct nv50_disp *disp, int head, int id)
 static struct nvkm_output *
 exec_clkcmp(struct nv50_disp *disp, int head, int id, u32 pclk, u32 *conf)
 {
-	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	struct nvkm_bios *bios = device->bios;
 	struct nvkm_output *outp;
 	struct nvbios_outp info1;
@@ -235,26 +355,26 @@ exec_clkcmp(struct nv50_disp *disp, int head, int id, u32 pclk, u32 *conf)
 	int i;
 
 	/* DAC */
-	for (i = 0; !(ctrl & (1 << head)) && i < disp->dac.nr; i++)
+	for (i = 0; !(ctrl & (1 << head)) && i < disp->func->dac.nr; i++)
 		ctrl = nvkm_rd32(device, 0x610b58 + (i * 8));
 
 	/* SOR */
 	if (!(ctrl & (1 << head))) {
-		if (nv_device(disp)->chipset  < 0x90 ||
-		    nv_device(disp)->chipset == 0x92 ||
-		    nv_device(disp)->chipset == 0xa0) {
+		if (device->chipset  < 0x90 ||
+		    device->chipset == 0x92 ||
+		    device->chipset == 0xa0) {
 			reg = 0x610b70;
 		} else {
 			reg = 0x610794;
 		}
-		for (i = 0; !(ctrl & (1 << head)) && i < disp->sor.nr; i++)
+		for (i = 0; !(ctrl & (1 << head)) && i < disp->func->sor.nr; i++)
 			ctrl = nvkm_rd32(device, reg + (i * 8));
 		i += 4;
 	}
 
 	/* PIOR */
 	if (!(ctrl & (1 << head))) {
-		for (i = 0; !(ctrl & (1 << head)) && i < disp->pior.nr; i++)
+		for (i = 0; !(ctrl & (1 << head)) && i < disp->func->pior.nr; i++)
 			ctrl = nvkm_rd32(device, 0x610b80 + (i * 8));
 		i += 8;
 	}
@@ -295,7 +415,7 @@ exec_clkcmp(struct nv50_disp *disp, int head, int id, u32 pclk, u32 *conf)
 		data = nvbios_oclk_match(bios, info2.clkcmp[id], pclk);
 		if (data) {
 			struct nvbios_init init = {
-				.subdev = nv_subdev(disp),
+				.subdev = subdev,
 				.bios = bios,
 				.offset = data,
 				.outp = &outp->info,
@@ -620,7 +740,7 @@ nv50_disp_intr_supervisor(struct work_struct *work)
 
 	if (disp->super & 0x00000010) {
 		nv50_disp_chan_mthd(disp->chan[0], NV_DBG_DEBUG);
-		for (head = 0; head < disp->head.nr; head++) {
+		for (head = 0; head < disp->base.head.nr; head++) {
 			if (!(super & (0x00000020 << head)))
 				continue;
 			if (!(super & (0x00000080 << head)))
@@ -629,24 +749,24 @@ nv50_disp_intr_supervisor(struct work_struct *work)
 		}
 	} else
 	if (disp->super & 0x00000020) {
-		for (head = 0; head < disp->head.nr; head++) {
+		for (head = 0; head < disp->base.head.nr; head++) {
 			if (!(super & (0x00000080 << head)))
 				continue;
 			nv50_disp_intr_unk20_0(disp, head);
 		}
-		for (head = 0; head < disp->head.nr; head++) {
+		for (head = 0; head < disp->base.head.nr; head++) {
 			if (!(super & (0x00000200 << head)))
 				continue;
 			nv50_disp_intr_unk20_1(disp, head);
 		}
-		for (head = 0; head < disp->head.nr; head++) {
+		for (head = 0; head < disp->base.head.nr; head++) {
 			if (!(super & (0x00000080 << head)))
 				continue;
 			nv50_disp_intr_unk20_2(disp, head);
 		}
 	} else
 	if (disp->super & 0x00000040) {
-		for (head = 0; head < disp->head.nr; head++) {
+		for (head = 0; head < disp->base.head.nr; head++) {
 			if (!(super & (0x00000080 << head)))
 				continue;
 			nv50_disp_intr_unk40_0(disp, head);
@@ -657,9 +777,8 @@ nv50_disp_intr_supervisor(struct work_struct *work)
 }
 
 void
-nv50_disp_intr(struct nvkm_subdev *subdev)
+nv50_disp_intr(struct nv50_disp *disp)
 {
-	struct nv50_disp *disp = (void *)subdev;
 	struct nvkm_device *device = disp->base.engine.subdev.device;
 	u32 intr0 = nvkm_rd32(device, 0x610020);
 	u32 intr1 = nvkm_rd32(device, 0x610024);
@@ -693,58 +812,31 @@ nv50_disp_intr(struct nvkm_subdev *subdev)
 	}
 }
 
-static const struct nvkm_disp_func
+static const struct nv50_disp_func
 nv50_disp = {
+	.intr = nv50_disp_intr,
+	.uevent = &nv50_disp_chan_uevent,
+	.super = nv50_disp_intr_supervisor,
 	.root = &nv50_disp_root_oclass,
+	.head.vblank_init = nv50_disp_vblank_init,
+	.head.vblank_fini = nv50_disp_vblank_fini,
+	.head.scanoutpos = nv50_disp_root_scanoutpos,
+	.outp.internal.crt = nv50_dac_output_new,
+	.outp.internal.tmds = nv50_sor_output_new,
+	.outp.internal.lvds = nv50_sor_output_new,
+	.outp.external.tmds = nv50_pior_output_new,
+	.outp.external.dp = nv50_pior_dp_new,
+	.dac.nr = 3,
+	.dac.power = nv50_dac_power,
+	.dac.sense = nv50_dac_sense,
+	.sor.nr = 2,
+	.sor.power = nv50_sor_power,
+	.pior.nr = 3,
+	.pior.power = nv50_pior_power,
 };
 
-static int
-nv50_disp_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-	       struct nvkm_oclass *oclass, void *data, u32 size,
-	       struct nvkm_object **pobject)
+int
+nv50_disp_new(struct nvkm_device *device, int index, struct nvkm_disp **pdisp)
 {
-	struct nv50_disp *disp;
-	int ret;
-
-	ret = nvkm_disp_create(parent, engine, oclass, 2, "PDISP",
-			       "display", &disp);
-	*pobject = nv_object(disp);
-	if (ret)
-		return ret;
-
-	disp->base.func = &nv50_disp;
-
-	ret = nvkm_event_init(&nv50_disp_chan_uevent, 1, 9, &disp->uevent);
-	if (ret)
-		return ret;
-
-	nv_subdev(disp)->intr = nv50_disp_intr;
-	INIT_WORK(&disp->supervisor, nv50_disp_intr_supervisor);
-	disp->head.nr = 2;
-	disp->dac.nr = 3;
-	disp->sor.nr = 2;
-	disp->pior.nr = 3;
-	disp->dac.power = nv50_dac_power;
-	disp->dac.sense = nv50_dac_sense;
-	disp->sor.power = nv50_sor_power;
-	disp->pior.power = nv50_pior_power;
-	return 0;
+	return nv50_disp_new_(&nv50_disp, device, index, 2, pdisp);
 }
-
-struct nvkm_oclass *
-nv50_disp_oclass = &(struct nv50_disp_impl) {
-	.base.base.handle = NV_ENGINE(DISP, 0x50),
-	.base.base.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nv50_disp_ctor,
-		.dtor = _nvkm_disp_dtor,
-		.init = _nvkm_disp_init,
-		.fini = _nvkm_disp_fini,
-	},
-	.base.outp.internal.crt = nv50_dac_output_new,
-	.base.outp.internal.tmds = nv50_sor_output_new,
-	.base.outp.internal.lvds = nv50_sor_output_new,
-	.base.outp.external.tmds = nv50_pior_output_new,
-	.base.outp.external.dp = nv50_pior_dp_new,
-	.base.vblank = &nv50_disp_vblank_func,
-	.head.scanoutpos = nv50_disp_root_scanoutpos,
-}.base.base;

commit 151abd44c27c1562f348a99c176b078a876ebe93
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/devinit: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index efffecbc92a5..ddffcc1088be 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -358,7 +358,7 @@ nv50_disp_intr_unk20_1(struct nv50_disp *disp, int head)
 	struct nvkm_devinit *devinit = device->devinit;
 	u32 pclk = nvkm_rd32(device, 0x610ad0 + (head * 0x540)) & 0x3fffff;
 	if (pclk)
-		devinit->pll_set(devinit, PLL_VPLL0 + head, pclk);
+		nvkm_devinit_pll_set(devinit, PLL_VPLL0 + head, pclk);
 }
 
 static void

commit 46484438ab7dbab6ed29cf647d029e0b1ef3d9d8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/bios: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 9bc4273947c3..efffecbc92a5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -319,6 +319,7 @@ nv50_disp_intr_unk10_0(struct nv50_disp *disp, int head)
 static void
 nv50_disp_intr_unk20_0(struct nv50_disp *disp, int head)
 {
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
 	struct nvkm_output *outp = exec_script(disp, head, 2);
 
 	/* the binary driver does this outside of the supervisor handling
@@ -337,8 +338,8 @@ nv50_disp_intr_unk20_0(struct nv50_disp *disp, int head)
 	if (outp && outp->info.type == DCB_OUTPUT_DP) {
 		struct nvkm_output_dp *outpdp = nvkm_output_dp(outp);
 		struct nvbios_init init = {
-			.subdev = nv_subdev(disp),
-			.bios = nvkm_bios(disp),
+			.subdev = subdev,
+			.bios = subdev->device->bios,
 			.outp = &outp->info,
 			.crtc = head,
 			.offset = outpdp->info.script[4],

commit 0ce41e3c66ca8958dec427f1c46f64efdda90f30
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/disp: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 240a5438c7ac..9bc4273947c3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -33,47 +33,6 @@
 #include <subdev/bios/pll.h>
 #include <subdev/devinit.h>
 
-static int
-nv50_disp_data_ctor(struct nvkm_object *parent,
-		    struct nvkm_object *engine,
-		    struct nvkm_oclass *oclass, void *data, u32 size,
-		    struct nvkm_object **pobject)
-{
-	struct nv50_disp *disp = (void *)engine;
-	struct nvkm_gpuobj *gpuobj;
-	int ret;
-
-	/* no context needed for channel objects... */
-	if (parent->parent != &nvkm_client(parent)->object) {
-		atomic_inc(&parent->refcount);
-		*pobject = parent;
-		return 1;
-	}
-
-	/* allocate display hardware to client */
-	ret = nvkm_gpuobj_create(parent, engine, oclass, 0, NULL,
-				 0x10000, 0x10000, NVOBJ_FLAG_HEAP,
-				 &gpuobj);
-	*pobject = nv_object(gpuobj);
-	mutex_lock(&nv_subdev(disp)->mutex);
-	if (!list_empty(&nv_engine(disp)->contexts))
-		ret = -EBUSY;
-	mutex_unlock(&nv_subdev(disp)->mutex);
-	return ret;
-}
-
-struct nvkm_oclass
-nv50_disp_cclass = {
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nv50_disp_data_ctor,
-		.dtor = _nvkm_gpuobj_dtor,
-		.init = _nvkm_gpuobj_init,
-		.fini = _nvkm_gpuobj_fini,
-		.rd32 = _nvkm_gpuobj_rd32,
-		.wr32 = _nvkm_gpuobj_wr32,
-	},
-};
-
 static void
 nv50_disp_vblank_fini(struct nvkm_event *event, int type, int head)
 {
@@ -115,7 +74,6 @@ nv50_disp_intr_error_code[] = {
 static void
 nv50_disp_intr_error(struct nv50_disp *disp, int chid)
 {
-	struct nv50_disp_impl *impl = (void *)nv_object(disp)->oclass;
 	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
 	struct nvkm_device *device = subdev->device;
 	u32 data = nvkm_rd32(device, 0x610084 + (chid * 0x08));
@@ -133,31 +91,10 @@ nv50_disp_intr_error(struct nv50_disp *disp, int chid)
 		   type, et ? et->name : "", code, ec ? ec->name : "",
 		   chid, mthd, data);
 
-	if (chid == 0) {
-		switch (mthd) {
-		case 0x0080:
-			nv50_disp_mthd_chan(disp, NV_DBG_ERROR, chid - 0,
-					    impl->mthd.core);
-			break;
-		default:
-			break;
-		}
-	} else
-	if (chid <= 2) {
-		switch (mthd) {
-		case 0x0080:
-			nv50_disp_mthd_chan(disp, NV_DBG_ERROR, chid - 1,
-					    impl->mthd.base);
-			break;
-		default:
-			break;
-		}
-	} else
-	if (chid <= 4) {
+	if (chid < ARRAY_SIZE(disp->chan)) {
 		switch (mthd) {
 		case 0x0080:
-			nv50_disp_mthd_chan(disp, NV_DBG_ERROR, chid - 3,
-					    impl->mthd.ovly);
+			nv50_disp_chan_mthd(disp->chan[chid], NV_DBG_ERROR);
 			break;
 		default:
 			break;
@@ -673,7 +610,6 @@ nv50_disp_intr_supervisor(struct work_struct *work)
 {
 	struct nv50_disp *disp =
 		container_of(work, struct nv50_disp, supervisor);
-	struct nv50_disp_impl *impl = (void *)nv_object(disp)->oclass;
 	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
 	struct nvkm_device *device = subdev->device;
 	u32 super = nvkm_rd32(device, 0x610030);
@@ -682,7 +618,7 @@ nv50_disp_intr_supervisor(struct work_struct *work)
 	nvkm_debug(subdev, "supervisor %08x %08x\n", disp->super, super);
 
 	if (disp->super & 0x00000010) {
-		nv50_disp_mthd_chan(disp, NV_DBG_DEBUG, 0, impl->mthd.core);
+		nv50_disp_chan_mthd(disp->chan[0], NV_DBG_DEBUG);
 		for (head = 0; head < disp->head.nr; head++) {
 			if (!(super & (0x00000020 << head)))
 				continue;
@@ -756,6 +692,11 @@ nv50_disp_intr(struct nvkm_subdev *subdev)
 	}
 }
 
+static const struct nvkm_disp_func
+nv50_disp = {
+	.root = &nv50_disp_root_oclass,
+};
+
 static int
 nv50_disp_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_oclass *oclass, void *data, u32 size,
@@ -770,15 +711,14 @@ nv50_disp_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
+	disp->base.func = &nv50_disp;
+
 	ret = nvkm_event_init(&nv50_disp_chan_uevent, 1, 9, &disp->uevent);
 	if (ret)
 		return ret;
 
-	nv_engine(disp)->sclass = nv50_disp_root_oclass;
-	nv_engine(disp)->cclass = &nv50_disp_cclass;
 	nv_subdev(disp)->intr = nv50_disp_intr;
 	INIT_WORK(&disp->supervisor, nv50_disp_intr_supervisor);
-	disp->sclass = nv50_disp_sclass;
 	disp->head.nr = 2;
 	disp->dac.nr = 3;
 	disp->sor.nr = 2;
@@ -805,9 +745,5 @@ nv50_disp_oclass = &(struct nv50_disp_impl) {
 	.base.outp.external.tmds = nv50_pior_output_new,
 	.base.outp.external.dp = nv50_pior_dp_new,
 	.base.vblank = &nv50_disp_vblank_func,
-	.mthd.core = &nv50_disp_core_mthd_chan,
-	.mthd.base = &nv50_disp_base_mthd_chan,
-	.mthd.ovly = &nv50_disp_ovly_mthd_chan,
-	.mthd.prev = 0x000004,
 	.head.scanoutpos = nv50_disp_root_scanoutpos,
 }.base.base;

commit 2a7909c0ade08c66690e6115ae49765dc47873e6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/disp: split user classes out from engine implementations
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 36241cf9173e..240a5438c7ac 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -22,1265 +22,16 @@
  * Authors: Ben Skeggs
  */
 #include "nv50.h"
-#include "outp.h"
-#include "outpdp.h"
+#include "rootnv50.h"
 
 #include <core/client.h>
-#include <core/gpuobj.h>
 #include <core/enum.h>
-#include <core/handle.h>
-#include <core/ramht.h>
-#include <engine/dma.h>
+#include <core/gpuobj.h>
 #include <subdev/bios.h>
-#include <subdev/bios/dcb.h>
 #include <subdev/bios/disp.h>
 #include <subdev/bios/init.h>
 #include <subdev/bios/pll.h>
 #include <subdev/devinit.h>
-#include <subdev/fb.h>
-#include <subdev/timer.h>
-
-#include <nvif/class.h>
-#include <nvif/event.h>
-#include <nvif/unpack.h>
-
-/*******************************************************************************
- * EVO channel base class
- ******************************************************************************/
-
-static int
-nv50_disp_chan_create_(struct nvkm_object *parent,
-		       struct nvkm_object *engine,
-		       struct nvkm_oclass *oclass, int head,
-		       int length, void **pobject)
-{
-	const struct nv50_disp_chan_impl *impl = (void *)oclass->ofuncs;
-	struct nv50_disp_base *base = (void *)parent;
-	struct nv50_disp_chan *chan;
-	int chid = impl->chid + head;
-	int ret;
-
-	if (base->chan & (1 << chid))
-		return -EBUSY;
-	base->chan |= (1 << chid);
-
-	ret = nvkm_namedb_create_(parent, engine, oclass, 0, NULL,
-				  (1ULL << NVDEV_ENGINE_DMAOBJ),
-				  length, pobject);
-	chan = *pobject;
-	if (ret)
-		return ret;
-	chan->chid = chid;
-
-	nv_parent(chan)->object_attach = impl->attach;
-	nv_parent(chan)->object_detach = impl->detach;
-	return 0;
-}
-
-static void
-nv50_disp_chan_destroy(struct nv50_disp_chan *chan)
-{
-	struct nv50_disp_base *base = (void *)nv_object(chan)->parent;
-	base->chan &= ~(1 << chan->chid);
-	nvkm_namedb_destroy(&chan->base);
-}
-
-static void
-nv50_disp_chan_uevent_fini(struct nvkm_event *event, int type, int index)
-{
-	struct nv50_disp *disp = container_of(event, typeof(*disp), uevent);
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	nvkm_mask(device, 0x610028, 0x00000001 << index, 0x00000000 << index);
-	nvkm_wr32(device, 0x610020, 0x00000001 << index);
-}
-
-static void
-nv50_disp_chan_uevent_init(struct nvkm_event *event, int types, int index)
-{
-	struct nv50_disp *disp = container_of(event, typeof(*disp), uevent);
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	nvkm_wr32(device, 0x610020, 0x00000001 << index);
-	nvkm_mask(device, 0x610028, 0x00000001 << index, 0x00000001 << index);
-}
-
-void
-nv50_disp_chan_uevent_send(struct nv50_disp *disp, int chid)
-{
-	struct nvif_notify_uevent_rep {
-	} rep;
-
-	nvkm_event_send(&disp->uevent, 1, chid, &rep, sizeof(rep));
-}
-
-int
-nv50_disp_chan_uevent_ctor(struct nvkm_object *object, void *data, u32 size,
-			   struct nvkm_notify *notify)
-{
-	struct nv50_disp_dmac *dmac = (void *)object;
-	union {
-		struct nvif_notify_uevent_req none;
-	} *args = data;
-	int ret;
-
-	if (nvif_unvers(args->none)) {
-		notify->size  = sizeof(struct nvif_notify_uevent_rep);
-		notify->types = 1;
-		notify->index = dmac->base.chid;
-		return 0;
-	}
-
-	return ret;
-}
-
-const struct nvkm_event_func
-nv50_disp_chan_uevent = {
-	.ctor = nv50_disp_chan_uevent_ctor,
-	.init = nv50_disp_chan_uevent_init,
-	.fini = nv50_disp_chan_uevent_fini,
-};
-
-int
-nv50_disp_chan_ntfy(struct nvkm_object *object, u32 type,
-		    struct nvkm_event **pevent)
-{
-	struct nv50_disp *disp = (void *)object->engine;
-	switch (type) {
-	case NV50_DISP_CORE_CHANNEL_DMA_V0_NTFY_UEVENT:
-		*pevent = &disp->uevent;
-		return 0;
-	default:
-		break;
-	}
-	return -EINVAL;
-}
-
-int
-nv50_disp_chan_map(struct nvkm_object *object, u64 *addr, u32 *size)
-{
-	struct nv50_disp_chan *chan = (void *)object;
-	*addr = nv_device_resource_start(nv_device(object), 0) +
-		0x640000 + (chan->chid * 0x1000);
-	*size = 0x001000;
-	return 0;
-}
-
-u32
-nv50_disp_chan_rd32(struct nvkm_object *object, u64 addr)
-{
-	struct nv50_disp_chan *chan = (void *)object;
-	struct nvkm_device *device = object->engine->subdev.device;
-	return nvkm_rd32(device, 0x640000 + (chan->chid * 0x1000) + addr);
-}
-
-void
-nv50_disp_chan_wr32(struct nvkm_object *object, u64 addr, u32 data)
-{
-	struct nv50_disp_chan *chan = (void *)object;
-	struct nvkm_device *device = object->engine->subdev.device;
-	nvkm_wr32(device, 0x640000 + (chan->chid * 0x1000) + addr, data);
-}
-
-/*******************************************************************************
- * EVO DMA channel base class
- ******************************************************************************/
-
-static int
-nv50_disp_dmac_object_attach(struct nvkm_object *parent,
-			     struct nvkm_object *object, u32 name)
-{
-	struct nv50_disp_base *base = (void *)parent->parent;
-	struct nv50_disp_chan *chan = (void *)parent;
-	u32 addr = nv_gpuobj(object)->node->offset;
-	u32 chid = chan->chid;
-	u32 data = (chid << 28) | (addr << 10) | chid;
-	return nvkm_ramht_insert(base->ramht, NULL, chid, 0, name, data);
-}
-
-static void
-nv50_disp_dmac_object_detach(struct nvkm_object *parent, int cookie)
-{
-	struct nv50_disp_base *base = (void *)parent->parent;
-	nvkm_ramht_remove(base->ramht, cookie);
-}
-
-static int
-nv50_disp_dmac_create_(struct nvkm_object *parent,
-		       struct nvkm_object *engine,
-		       struct nvkm_oclass *oclass, u64 pushbuf, int head,
-		       int length, void **pobject)
-{
-	struct nvkm_device *device = parent->engine->subdev.device;
-	struct nvkm_client *client = nvkm_client(parent);
-	struct nvkm_dma *dma = device->dma;
-	struct nvkm_dmaobj *dmaobj;
-	struct nv50_disp_dmac *dmac;
-	int ret;
-
-	ret = nv50_disp_chan_create_(parent, engine, oclass, head,
-				     length, pobject);
-	dmac = *pobject;
-	if (ret)
-		return ret;
-
-	dmaobj = nvkm_dma_search(dma, client, pushbuf);
-	if (!dmaobj)
-		return -ENOENT;
-
-	if (dmaobj->limit - dmaobj->start != 0xfff)
-		return -EINVAL;
-
-	switch (dmaobj->target) {
-	case NV_MEM_TARGET_VRAM:
-		dmac->push = 0x00000001 | dmaobj->start >> 8;
-		break;
-	case NV_MEM_TARGET_PCI_NOSNOOP:
-		dmac->push = 0x00000003 | dmaobj->start >> 8;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-void
-nv50_disp_dmac_dtor(struct nvkm_object *object)
-{
-	struct nv50_disp_dmac *dmac = (void *)object;
-	nv50_disp_chan_destroy(&dmac->base);
-}
-
-static int
-nv50_disp_dmac_init(struct nvkm_object *object)
-{
-	struct nv50_disp *disp = (void *)object->engine;
-	struct nv50_disp_dmac *dmac = (void *)object;
-	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
-	struct nvkm_device *device = subdev->device;
-	int chid = dmac->base.chid;
-	int ret;
-
-	ret = nv50_disp_chan_init(&dmac->base);
-	if (ret)
-		return ret;
-
-	/* enable error reporting */
-	nvkm_mask(device, 0x610028, 0x00010000 << chid, 0x00010000 << chid);
-
-	/* initialise channel for dma command submission */
-	nvkm_wr32(device, 0x610204 + (chid * 0x0010), dmac->push);
-	nvkm_wr32(device, 0x610208 + (chid * 0x0010), 0x00010000);
-	nvkm_wr32(device, 0x61020c + (chid * 0x0010), chid);
-	nvkm_mask(device, 0x610200 + (chid * 0x0010), 0x00000010, 0x00000010);
-	nvkm_wr32(device, 0x640000 + (chid * 0x1000), 0x00000000);
-	nvkm_wr32(device, 0x610200 + (chid * 0x0010), 0x00000013);
-
-	/* wait for it to go inactive */
-	if (nvkm_msec(device, 2000,
-		if (!(nvkm_rd32(device, 0x610200 + (chid * 0x10)) & 0x80000000))
-			break;
-	) < 0) {
-		nvkm_error(subdev, "ch %d init timeout, %08x\n", chid,
-			   nvkm_rd32(device, 0x610200 + (chid * 0x10)));
-		return -EBUSY;
-	}
-
-	return 0;
-}
-
-static int
-nv50_disp_dmac_fini(struct nvkm_object *object, bool suspend)
-{
-	struct nv50_disp *disp = (void *)object->engine;
-	struct nv50_disp_dmac *dmac = (void *)object;
-	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
-	struct nvkm_device *device = subdev->device;
-	int chid = dmac->base.chid;
-
-	/* deactivate channel */
-	nvkm_mask(device, 0x610200 + (chid * 0x0010), 0x00001010, 0x00001000);
-	nvkm_mask(device, 0x610200 + (chid * 0x0010), 0x00000003, 0x00000000);
-	if (nvkm_msec(device, 2000,
-		if (!(nvkm_rd32(device, 0x610200 + (chid * 0x10)) & 0x001e0000))
-			break;
-	) < 0) {
-		nvkm_error(subdev, "ch %d fini timeout, %08x\n", chid,
-			   nvkm_rd32(device, 0x610200 + (chid * 0x10)));
-		if (suspend)
-			return -EBUSY;
-	}
-
-	/* disable error reporting and completion notifications */
-	nvkm_mask(device, 0x610028, 0x00010001 << chid, 0x00000000 << chid);
-
-	return nv50_disp_chan_fini(&dmac->base, suspend);
-}
-
-/*******************************************************************************
- * EVO master channel object
- ******************************************************************************/
-
-static void
-nv50_disp_mthd_list(struct nv50_disp *disp, int debug, u32 base, int c,
-		    const struct nv50_disp_mthd_list *list, int inst)
-{
-	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
-	struct nvkm_device *device = subdev->device;
-	int i;
-
-	for (i = 0; list->data[i].mthd; i++) {
-		if (list->data[i].addr) {
-			u32 next = nvkm_rd32(device, list->data[i].addr + base + 0);
-			u32 prev = nvkm_rd32(device, list->data[i].addr + base + c);
-			u32 mthd = list->data[i].mthd + (list->mthd * inst);
-			const char *name = list->data[i].name;
-			char mods[16];
-
-			if (prev != next)
-				snprintf(mods, sizeof(mods), "-> %08x", next);
-			else
-				snprintf(mods, sizeof(mods), "%13c", ' ');
-
-			nvkm_printk_(subdev, debug, info,
-				     "\t%04x: %08x %s%s%s\n",
-				     mthd, prev, mods, name ? " // " : "",
-				     name ? name : "");
-		}
-	}
-}
-
-void
-nv50_disp_mthd_chan(struct nv50_disp *disp, int debug, int head,
-		    const struct nv50_disp_mthd_chan *chan)
-{
-	struct nvkm_object *object = nv_object(disp);
-	const struct nv50_disp_impl *impl = (void *)object->oclass;
-	const struct nv50_disp_mthd_list *list;
-	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
-	int i, j;
-
-	if (debug > nv_subdev(disp)->debug)
-		return;
-
-	for (i = 0; (list = chan->data[i].mthd) != NULL; i++) {
-		u32 base = head * chan->addr;
-		for (j = 0; j < chan->data[i].nr; j++, base += list->addr) {
-			const char *cname = chan->name;
-			const char *sname = "";
-			char cname_[16], sname_[16];
-
-			if (chan->addr) {
-				snprintf(cname_, sizeof(cname_), "%s %d",
-					 chan->name, head);
-				cname = cname_;
-			}
-
-			if (chan->data[i].nr > 1) {
-				snprintf(sname_, sizeof(sname_), " - %s %d",
-					 chan->data[i].name, j);
-				sname = sname_;
-			}
-
-			nvkm_printk_(subdev, debug, info, "%s%s:\n", cname, sname);
-			nv50_disp_mthd_list(disp, debug, base, impl->mthd.prev,
-					    list, j);
-		}
-	}
-}
-
-const struct nv50_disp_mthd_list
-nv50_disp_core_mthd_base = {
-	.mthd = 0x0000,
-	.addr = 0x000000,
-	.data = {
-		{ 0x0080, 0x000000 },
-		{ 0x0084, 0x610bb8 },
-		{ 0x0088, 0x610b9c },
-		{ 0x008c, 0x000000 },
-		{}
-	}
-};
-
-static const struct nv50_disp_mthd_list
-nv50_disp_core_mthd_dac = {
-	.mthd = 0x0080,
-	.addr = 0x000008,
-	.data = {
-		{ 0x0400, 0x610b58 },
-		{ 0x0404, 0x610bdc },
-		{ 0x0420, 0x610828 },
-		{}
-	}
-};
-
-const struct nv50_disp_mthd_list
-nv50_disp_core_mthd_sor = {
-	.mthd = 0x0040,
-	.addr = 0x000008,
-	.data = {
-		{ 0x0600, 0x610b70 },
-		{}
-	}
-};
-
-const struct nv50_disp_mthd_list
-nv50_disp_core_mthd_pior = {
-	.mthd = 0x0040,
-	.addr = 0x000008,
-	.data = {
-		{ 0x0700, 0x610b80 },
-		{}
-	}
-};
-
-static const struct nv50_disp_mthd_list
-nv50_disp_core_mthd_head = {
-	.mthd = 0x0400,
-	.addr = 0x000540,
-	.data = {
-		{ 0x0800, 0x610ad8 },
-		{ 0x0804, 0x610ad0 },
-		{ 0x0808, 0x610a48 },
-		{ 0x080c, 0x610a78 },
-		{ 0x0810, 0x610ac0 },
-		{ 0x0814, 0x610af8 },
-		{ 0x0818, 0x610b00 },
-		{ 0x081c, 0x610ae8 },
-		{ 0x0820, 0x610af0 },
-		{ 0x0824, 0x610b08 },
-		{ 0x0828, 0x610b10 },
-		{ 0x082c, 0x610a68 },
-		{ 0x0830, 0x610a60 },
-		{ 0x0834, 0x000000 },
-		{ 0x0838, 0x610a40 },
-		{ 0x0840, 0x610a24 },
-		{ 0x0844, 0x610a2c },
-		{ 0x0848, 0x610aa8 },
-		{ 0x084c, 0x610ab0 },
-		{ 0x0860, 0x610a84 },
-		{ 0x0864, 0x610a90 },
-		{ 0x0868, 0x610b18 },
-		{ 0x086c, 0x610b20 },
-		{ 0x0870, 0x610ac8 },
-		{ 0x0874, 0x610a38 },
-		{ 0x0880, 0x610a58 },
-		{ 0x0884, 0x610a9c },
-		{ 0x08a0, 0x610a70 },
-		{ 0x08a4, 0x610a50 },
-		{ 0x08a8, 0x610ae0 },
-		{ 0x08c0, 0x610b28 },
-		{ 0x08c4, 0x610b30 },
-		{ 0x08c8, 0x610b40 },
-		{ 0x08d4, 0x610b38 },
-		{ 0x08d8, 0x610b48 },
-		{ 0x08dc, 0x610b50 },
-		{ 0x0900, 0x610a18 },
-		{ 0x0904, 0x610ab8 },
-		{}
-	}
-};
-
-static const struct nv50_disp_mthd_chan
-nv50_disp_core_mthd_chan = {
-	.name = "Core",
-	.addr = 0x000000,
-	.data = {
-		{ "Global", 1, &nv50_disp_core_mthd_base },
-		{    "DAC", 3, &nv50_disp_core_mthd_dac  },
-		{    "SOR", 2, &nv50_disp_core_mthd_sor  },
-		{   "PIOR", 3, &nv50_disp_core_mthd_pior },
-		{   "HEAD", 2, &nv50_disp_core_mthd_head },
-		{}
-	}
-};
-
-int
-nv50_disp_core_ctor(struct nvkm_object *parent,
-		    struct nvkm_object *engine,
-		    struct nvkm_oclass *oclass, void *data, u32 size,
-		    struct nvkm_object **pobject)
-{
-	union {
-		struct nv50_disp_core_channel_dma_v0 v0;
-	} *args = data;
-	struct nv50_disp_dmac *mast;
-	int ret;
-
-	nvif_ioctl(parent, "create disp core channel dma size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nvif_ioctl(parent, "create disp core channel dma vers %d "
-				   "pushbuf %016llx\n",
-			   args->v0.version, args->v0.pushbuf);
-	} else
-		return ret;
-
-	ret = nv50_disp_dmac_create_(parent, engine, oclass, args->v0.pushbuf,
-				     0, sizeof(*mast), (void **)&mast);
-	*pobject = nv_object(mast);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-static int
-nv50_disp_core_init(struct nvkm_object *object)
-{
-	struct nv50_disp *disp = (void *)object->engine;
-	struct nv50_disp_dmac *mast = (void *)object;
-	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
-	struct nvkm_device *device = subdev->device;
-	int ret;
-
-	ret = nv50_disp_chan_init(&mast->base);
-	if (ret)
-		return ret;
-
-	/* enable error reporting */
-	nvkm_mask(device, 0x610028, 0x00010000, 0x00010000);
-
-	/* attempt to unstick channel from some unknown state */
-	if ((nvkm_rd32(device, 0x610200) & 0x009f0000) == 0x00020000)
-		nvkm_mask(device, 0x610200, 0x00800000, 0x00800000);
-	if ((nvkm_rd32(device, 0x610200) & 0x003f0000) == 0x00030000)
-		nvkm_mask(device, 0x610200, 0x00600000, 0x00600000);
-
-	/* initialise channel for dma command submission */
-	nvkm_wr32(device, 0x610204, mast->push);
-	nvkm_wr32(device, 0x610208, 0x00010000);
-	nvkm_wr32(device, 0x61020c, 0x00000000);
-	nvkm_mask(device, 0x610200, 0x00000010, 0x00000010);
-	nvkm_wr32(device, 0x640000, 0x00000000);
-	nvkm_wr32(device, 0x610200, 0x01000013);
-
-	/* wait for it to go inactive */
-	if (nvkm_msec(device, 2000,
-		if (!(nvkm_rd32(device, 0x610200) & 0x80000000))
-			break;
-	) < 0) {
-		nvkm_error(subdev, "core init: %08x\n",
-			   nvkm_rd32(device, 0x610200));
-		return -EBUSY;
-	}
-
-	return 0;
-}
-
-static int
-nv50_disp_core_fini(struct nvkm_object *object, bool suspend)
-{
-	struct nv50_disp *disp = (void *)object->engine;
-	struct nv50_disp_dmac *mast = (void *)object;
-	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
-	struct nvkm_device *device = subdev->device;
-
-	/* deactivate channel */
-	nvkm_mask(device, 0x610200, 0x00000010, 0x00000000);
-	nvkm_mask(device, 0x610200, 0x00000003, 0x00000000);
-	if (nvkm_msec(device, 2000,
-		if (!(nvkm_rd32(device, 0x610200) & 0x001e0000))
-			break;
-	) < 0) {
-		nvkm_error(subdev, "core fini: %08x\n",
-			   nvkm_rd32(device, 0x610200));
-		if (suspend)
-			return -EBUSY;
-	}
-
-	/* disable error reporting and completion notifications */
-	nvkm_mask(device, 0x610028, 0x00010001, 0x00000000);
-
-	return nv50_disp_chan_fini(&mast->base, suspend);
-}
-
-struct nv50_disp_chan_impl
-nv50_disp_core_ofuncs = {
-	.base.ctor = nv50_disp_core_ctor,
-	.base.dtor = nv50_disp_dmac_dtor,
-	.base.init = nv50_disp_core_init,
-	.base.fini = nv50_disp_core_fini,
-	.base.map  = nv50_disp_chan_map,
-	.base.ntfy = nv50_disp_chan_ntfy,
-	.base.rd32 = nv50_disp_chan_rd32,
-	.base.wr32 = nv50_disp_chan_wr32,
-	.chid = 0,
-	.attach = nv50_disp_dmac_object_attach,
-	.detach = nv50_disp_dmac_object_detach,
-};
-
-/*******************************************************************************
- * EVO sync channel objects
- ******************************************************************************/
-
-static const struct nv50_disp_mthd_list
-nv50_disp_base_mthd_base = {
-	.mthd = 0x0000,
-	.addr = 0x000000,
-	.data = {
-		{ 0x0080, 0x000000 },
-		{ 0x0084, 0x0008c4 },
-		{ 0x0088, 0x0008d0 },
-		{ 0x008c, 0x0008dc },
-		{ 0x0090, 0x0008e4 },
-		{ 0x0094, 0x610884 },
-		{ 0x00a0, 0x6108a0 },
-		{ 0x00a4, 0x610878 },
-		{ 0x00c0, 0x61086c },
-		{ 0x00e0, 0x610858 },
-		{ 0x00e4, 0x610860 },
-		{ 0x00e8, 0x6108ac },
-		{ 0x00ec, 0x6108b4 },
-		{ 0x0100, 0x610894 },
-		{ 0x0110, 0x6108bc },
-		{ 0x0114, 0x61088c },
-		{}
-	}
-};
-
-const struct nv50_disp_mthd_list
-nv50_disp_base_mthd_image = {
-	.mthd = 0x0400,
-	.addr = 0x000000,
-	.data = {
-		{ 0x0800, 0x6108f0 },
-		{ 0x0804, 0x6108fc },
-		{ 0x0808, 0x61090c },
-		{ 0x080c, 0x610914 },
-		{ 0x0810, 0x610904 },
-		{}
-	}
-};
-
-static const struct nv50_disp_mthd_chan
-nv50_disp_base_mthd_chan = {
-	.name = "Base",
-	.addr = 0x000540,
-	.data = {
-		{ "Global", 1, &nv50_disp_base_mthd_base },
-		{  "Image", 2, &nv50_disp_base_mthd_image },
-		{}
-	}
-};
-
-int
-nv50_disp_base_ctor(struct nvkm_object *parent,
-		    struct nvkm_object *engine,
-		    struct nvkm_oclass *oclass, void *data, u32 size,
-		    struct nvkm_object **pobject)
-{
-	union {
-		struct nv50_disp_base_channel_dma_v0 v0;
-	} *args = data;
-	struct nv50_disp *disp = (void *)engine;
-	struct nv50_disp_dmac *dmac;
-	int ret;
-
-	nvif_ioctl(parent, "create disp base channel dma size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nvif_ioctl(parent, "create disp base channel dma vers %d "
-				   "pushbuf %016llx head %d\n",
-			   args->v0.version, args->v0.pushbuf, args->v0.head);
-		if (args->v0.head > disp->head.nr)
-			return -EINVAL;
-	} else
-		return ret;
-
-	ret = nv50_disp_dmac_create_(parent, engine, oclass, args->v0.pushbuf,
-				     args->v0.head, sizeof(*dmac),
-				     (void **)&dmac);
-	*pobject = nv_object(dmac);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-struct nv50_disp_chan_impl
-nv50_disp_base_ofuncs = {
-	.base.ctor = nv50_disp_base_ctor,
-	.base.dtor = nv50_disp_dmac_dtor,
-	.base.init = nv50_disp_dmac_init,
-	.base.fini = nv50_disp_dmac_fini,
-	.base.ntfy = nv50_disp_chan_ntfy,
-	.base.map  = nv50_disp_chan_map,
-	.base.rd32 = nv50_disp_chan_rd32,
-	.base.wr32 = nv50_disp_chan_wr32,
-	.chid = 1,
-	.attach = nv50_disp_dmac_object_attach,
-	.detach = nv50_disp_dmac_object_detach,
-};
-
-/*******************************************************************************
- * EVO overlay channel objects
- ******************************************************************************/
-
-const struct nv50_disp_mthd_list
-nv50_disp_ovly_mthd_base = {
-	.mthd = 0x0000,
-	.addr = 0x000000,
-	.data = {
-		{ 0x0080, 0x000000 },
-		{ 0x0084, 0x0009a0 },
-		{ 0x0088, 0x0009c0 },
-		{ 0x008c, 0x0009c8 },
-		{ 0x0090, 0x6109b4 },
-		{ 0x0094, 0x610970 },
-		{ 0x00a0, 0x610998 },
-		{ 0x00a4, 0x610964 },
-		{ 0x00c0, 0x610958 },
-		{ 0x00e0, 0x6109a8 },
-		{ 0x00e4, 0x6109d0 },
-		{ 0x00e8, 0x6109d8 },
-		{ 0x0100, 0x61094c },
-		{ 0x0104, 0x610984 },
-		{ 0x0108, 0x61098c },
-		{ 0x0800, 0x6109f8 },
-		{ 0x0808, 0x610a08 },
-		{ 0x080c, 0x610a10 },
-		{ 0x0810, 0x610a00 },
-		{}
-	}
-};
-
-static const struct nv50_disp_mthd_chan
-nv50_disp_ovly_mthd_chan = {
-	.name = "Overlay",
-	.addr = 0x000540,
-	.data = {
-		{ "Global", 1, &nv50_disp_ovly_mthd_base },
-		{}
-	}
-};
-
-int
-nv50_disp_ovly_ctor(struct nvkm_object *parent,
-		    struct nvkm_object *engine,
-		    struct nvkm_oclass *oclass, void *data, u32 size,
-		    struct nvkm_object **pobject)
-{
-	union {
-		struct nv50_disp_overlay_channel_dma_v0 v0;
-	} *args = data;
-	struct nv50_disp *disp = (void *)engine;
-	struct nv50_disp_dmac *dmac;
-	int ret;
-
-	nvif_ioctl(parent, "create disp overlay channel dma size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nvif_ioctl(parent, "create disp overlay channel dma vers %d "
-				   "pushbuf %016llx head %d\n",
-			   args->v0.version, args->v0.pushbuf, args->v0.head);
-		if (args->v0.head > disp->head.nr)
-			return -EINVAL;
-	} else
-		return ret;
-
-	ret = nv50_disp_dmac_create_(parent, engine, oclass, args->v0.pushbuf,
-				     args->v0.head, sizeof(*dmac),
-				     (void **)&dmac);
-	*pobject = nv_object(dmac);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-struct nv50_disp_chan_impl
-nv50_disp_ovly_ofuncs = {
-	.base.ctor = nv50_disp_ovly_ctor,
-	.base.dtor = nv50_disp_dmac_dtor,
-	.base.init = nv50_disp_dmac_init,
-	.base.fini = nv50_disp_dmac_fini,
-	.base.ntfy = nv50_disp_chan_ntfy,
-	.base.map  = nv50_disp_chan_map,
-	.base.rd32 = nv50_disp_chan_rd32,
-	.base.wr32 = nv50_disp_chan_wr32,
-	.chid = 3,
-	.attach = nv50_disp_dmac_object_attach,
-	.detach = nv50_disp_dmac_object_detach,
-};
-
-/*******************************************************************************
- * EVO PIO channel base class
- ******************************************************************************/
-
-static int
-nv50_disp_pioc_create_(struct nvkm_object *parent,
-		       struct nvkm_object *engine,
-		       struct nvkm_oclass *oclass, int head,
-		       int length, void **pobject)
-{
-	return nv50_disp_chan_create_(parent, engine, oclass, head,
-				      length, pobject);
-}
-
-void
-nv50_disp_pioc_dtor(struct nvkm_object *object)
-{
-	struct nv50_disp_pioc *pioc = (void *)object;
-	nv50_disp_chan_destroy(&pioc->base);
-}
-
-static int
-nv50_disp_pioc_init(struct nvkm_object *object)
-{
-	struct nv50_disp *disp = (void *)object->engine;
-	struct nv50_disp_pioc *pioc = (void *)object;
-	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
-	struct nvkm_device *device = subdev->device;
-	int chid = pioc->base.chid;
-	int ret;
-
-	ret = nv50_disp_chan_init(&pioc->base);
-	if (ret)
-		return ret;
-
-	nvkm_wr32(device, 0x610200 + (chid * 0x10), 0x00002000);
-	if (nvkm_msec(device, 2000,
-		if (!(nvkm_rd32(device, 0x610200 + (chid * 0x10)) & 0x00030000))
-			break;
-	) < 0) {
-		nvkm_error(subdev, "ch %d timeout0: %08x\n", chid,
-			   nvkm_rd32(device, 0x610200 + (chid * 0x10)));
-		return -EBUSY;
-	}
-
-	nvkm_wr32(device, 0x610200 + (chid * 0x10), 0x00000001);
-	if (nvkm_msec(device, 2000,
-		u32 tmp = nvkm_rd32(device, 0x610200 + (chid * 0x10));
-		if ((tmp & 0x00030000) == 0x00010000)
-			break;
-	) < 0) {
-		nvkm_error(subdev, "ch %d timeout1: %08x\n", chid,
-			   nvkm_rd32(device, 0x610200 + (chid * 0x10)));
-		return -EBUSY;
-	}
-
-	return 0;
-}
-
-static int
-nv50_disp_pioc_fini(struct nvkm_object *object, bool suspend)
-{
-	struct nv50_disp *disp = (void *)object->engine;
-	struct nv50_disp_pioc *pioc = (void *)object;
-	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
-	struct nvkm_device *device = subdev->device;
-	int chid = pioc->base.chid;
-
-	nvkm_mask(device, 0x610200 + (chid * 0x10), 0x00000001, 0x00000000);
-	if (nvkm_msec(device, 2000,
-		if (!(nvkm_rd32(device, 0x610200 + (chid * 0x10)) & 0x00030000))
-			break;
-	) < 0) {
-		nvkm_error(subdev, "ch %d timeout: %08x\n", chid,
-			   nvkm_rd32(device, 0x610200 + (chid * 0x10)));
-		if (suspend)
-			return -EBUSY;
-	}
-
-	return nv50_disp_chan_fini(&pioc->base, suspend);
-}
-
-/*******************************************************************************
- * EVO immediate overlay channel objects
- ******************************************************************************/
-
-int
-nv50_disp_oimm_ctor(struct nvkm_object *parent,
-		    struct nvkm_object *engine,
-		    struct nvkm_oclass *oclass, void *data, u32 size,
-		    struct nvkm_object **pobject)
-{
-	union {
-		struct nv50_disp_overlay_v0 v0;
-	} *args = data;
-	struct nv50_disp *disp = (void *)engine;
-	struct nv50_disp_pioc *pioc;
-	int ret;
-
-	nvif_ioctl(parent, "create disp overlay size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nvif_ioctl(parent, "create disp overlay vers %d head %d\n",
-			   args->v0.version, args->v0.head);
-		if (args->v0.head > disp->head.nr)
-			return -EINVAL;
-	} else
-		return ret;
-
-	ret = nv50_disp_pioc_create_(parent, engine, oclass, args->v0.head,
-				     sizeof(*pioc), (void **)&pioc);
-	*pobject = nv_object(pioc);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-struct nv50_disp_chan_impl
-nv50_disp_oimm_ofuncs = {
-	.base.ctor = nv50_disp_oimm_ctor,
-	.base.dtor = nv50_disp_pioc_dtor,
-	.base.init = nv50_disp_pioc_init,
-	.base.fini = nv50_disp_pioc_fini,
-	.base.ntfy = nv50_disp_chan_ntfy,
-	.base.map  = nv50_disp_chan_map,
-	.base.rd32 = nv50_disp_chan_rd32,
-	.base.wr32 = nv50_disp_chan_wr32,
-	.chid = 5,
-};
-
-/*******************************************************************************
- * EVO cursor channel objects
- ******************************************************************************/
-
-int
-nv50_disp_curs_ctor(struct nvkm_object *parent,
-		    struct nvkm_object *engine,
-		    struct nvkm_oclass *oclass, void *data, u32 size,
-		    struct nvkm_object **pobject)
-{
-	union {
-		struct nv50_disp_cursor_v0 v0;
-	} *args = data;
-	struct nv50_disp *disp = (void *)engine;
-	struct nv50_disp_pioc *pioc;
-	int ret;
-
-	nvif_ioctl(parent, "create disp cursor size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nvif_ioctl(parent, "create disp cursor vers %d head %d\n",
-			   args->v0.version, args->v0.head);
-		if (args->v0.head > disp->head.nr)
-			return -EINVAL;
-	} else
-		return ret;
-
-	ret = nv50_disp_pioc_create_(parent, engine, oclass, args->v0.head,
-				     sizeof(*pioc), (void **)&pioc);
-	*pobject = nv_object(pioc);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-struct nv50_disp_chan_impl
-nv50_disp_curs_ofuncs = {
-	.base.ctor = nv50_disp_curs_ctor,
-	.base.dtor = nv50_disp_pioc_dtor,
-	.base.init = nv50_disp_pioc_init,
-	.base.fini = nv50_disp_pioc_fini,
-	.base.ntfy = nv50_disp_chan_ntfy,
-	.base.map  = nv50_disp_chan_map,
-	.base.rd32 = nv50_disp_chan_rd32,
-	.base.wr32 = nv50_disp_chan_wr32,
-	.chid = 7,
-};
-
-/*******************************************************************************
- * Base display object
- ******************************************************************************/
-
-int
-nv50_disp_main_scanoutpos(NV50_DISP_MTHD_V0)
-{
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	const u32 blanke = nvkm_rd32(device, 0x610aec + (head * 0x540));
-	const u32 blanks = nvkm_rd32(device, 0x610af4 + (head * 0x540));
-	const u32 total  = nvkm_rd32(device, 0x610afc + (head * 0x540));
-	union {
-		struct nv04_disp_scanoutpos_v0 v0;
-	} *args = data;
-	int ret;
-
-	nvif_ioctl(object, "disp scanoutpos size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nvif_ioctl(object, "disp scanoutpos vers %d\n",
-			   args->v0.version);
-		args->v0.vblanke = (blanke & 0xffff0000) >> 16;
-		args->v0.hblanke = (blanke & 0x0000ffff);
-		args->v0.vblanks = (blanks & 0xffff0000) >> 16;
-		args->v0.hblanks = (blanks & 0x0000ffff);
-		args->v0.vtotal  = ( total & 0xffff0000) >> 16;
-		args->v0.htotal  = ( total & 0x0000ffff);
-		args->v0.time[0] = ktime_to_ns(ktime_get());
-		args->v0.vline = /* vline read locks hline */
-			nvkm_rd32(device, 0x616340 + (head * 0x800)) & 0xffff;
-		args->v0.time[1] = ktime_to_ns(ktime_get());
-		args->v0.hline =
-			nvkm_rd32(device, 0x616344 + (head * 0x800)) & 0xffff;
-	} else
-		return ret;
-
-	return 0;
-}
-
-int
-nv50_disp_main_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
-{
-	const struct nv50_disp_impl *impl = (void *)nv_oclass(object->engine);
-	union {
-		struct nv50_disp_mthd_v0 v0;
-		struct nv50_disp_mthd_v1 v1;
-	} *args = data;
-	struct nv50_disp *disp = (void *)object->engine;
-	struct nvkm_output *outp = NULL;
-	struct nvkm_output *temp;
-	u16 type, mask = 0;
-	int head, ret;
-
-	if (mthd != NV50_DISP_MTHD)
-		return -EINVAL;
-
-	nvif_ioctl(object, "disp mthd size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, true)) {
-		nvif_ioctl(object, "disp mthd vers %d mthd %02x head %d\n",
-			   args->v0.version, args->v0.method, args->v0.head);
-		mthd = args->v0.method;
-		head = args->v0.head;
-	} else
-	if (nvif_unpack(args->v1, 1, 1, true)) {
-		nvif_ioctl(object, "disp mthd vers %d mthd %02x "
-				   "type %04x mask %04x\n",
-			   args->v1.version, args->v1.method,
-			   args->v1.hasht, args->v1.hashm);
-		mthd = args->v1.method;
-		type = args->v1.hasht;
-		mask = args->v1.hashm;
-		head = ffs((mask >> 8) & 0x0f) - 1;
-	} else
-		return ret;
-
-	if (head < 0 || head >= disp->head.nr)
-		return -ENXIO;
-
-	if (mask) {
-		list_for_each_entry(temp, &disp->base.outp, head) {
-			if ((temp->info.hasht         == type) &&
-			    (temp->info.hashm & mask) == mask) {
-				outp = temp;
-				break;
-			}
-		}
-		if (outp == NULL)
-			return -ENXIO;
-	}
-
-	switch (mthd) {
-	case NV50_DISP_SCANOUTPOS:
-		return impl->head.scanoutpos(object, disp, data, size, head);
-	default:
-		break;
-	}
-
-	switch (mthd * !!outp) {
-	case NV50_DISP_MTHD_V1_DAC_PWR:
-		return disp->dac.power(object, disp, data, size, head, outp);
-	case NV50_DISP_MTHD_V1_DAC_LOAD:
-		return disp->dac.sense(object, disp, data, size, head, outp);
-	case NV50_DISP_MTHD_V1_SOR_PWR:
-		return disp->sor.power(object, disp, data, size, head, outp);
-	case NV50_DISP_MTHD_V1_SOR_HDA_ELD:
-		if (!disp->sor.hda_eld)
-			return -ENODEV;
-		return disp->sor.hda_eld(object, disp, data, size, head, outp);
-	case NV50_DISP_MTHD_V1_SOR_HDMI_PWR:
-		if (!disp->sor.hdmi)
-			return -ENODEV;
-		return disp->sor.hdmi(object, disp, data, size, head, outp);
-	case NV50_DISP_MTHD_V1_SOR_LVDS_SCRIPT: {
-		union {
-			struct nv50_disp_sor_lvds_script_v0 v0;
-		} *args = data;
-		nvif_ioctl(object, "disp sor lvds script size %d\n", size);
-		if (nvif_unpack(args->v0, 0, 0, false)) {
-			nvif_ioctl(object, "disp sor lvds script "
-					   "vers %d name %04x\n",
-				   args->v0.version, args->v0.script);
-			disp->sor.lvdsconf = args->v0.script;
-			return 0;
-		} else
-			return ret;
-	}
-		break;
-	case NV50_DISP_MTHD_V1_SOR_DP_PWR: {
-		struct nvkm_output_dp *outpdp = nvkm_output_dp(outp);
-		union {
-			struct nv50_disp_sor_dp_pwr_v0 v0;
-		} *args = data;
-		nvif_ioctl(object, "disp sor dp pwr size %d\n", size);
-		if (nvif_unpack(args->v0, 0, 0, false)) {
-			nvif_ioctl(object, "disp sor dp pwr vers %d state %d\n",
-				   args->v0.version, args->v0.state);
-			if (args->v0.state == 0) {
-				nvkm_notify_put(&outpdp->irq);
-				outpdp->func->lnk_pwr(outpdp, 0);
-				atomic_set(&outpdp->lt.done, 0);
-				return 0;
-			} else
-			if (args->v0.state != 0) {
-				nvkm_output_dp_train(&outpdp->base, 0, true);
-				return 0;
-			}
-		} else
-			return ret;
-	}
-		break;
-	case NV50_DISP_MTHD_V1_PIOR_PWR:
-		if (!disp->pior.power)
-			return -ENODEV;
-		return disp->pior.power(object, disp, data, size, head, outp);
-	default:
-		break;
-	}
-
-	return -EINVAL;
-}
-
-int
-nv50_disp_main_ctor(struct nvkm_object *parent,
-		    struct nvkm_object *engine,
-		    struct nvkm_oclass *oclass, void *data, u32 size,
-		    struct nvkm_object **pobject)
-{
-	struct nv50_disp *disp = (void *)engine;
-	struct nv50_disp_base *base;
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	struct nvkm_gpuobj *instmem = (void *)parent;
-	int ret;
-
-	ret = nvkm_parent_create(parent, engine, oclass, 0,
-				 disp->sclass, 0, &base);
-	*pobject = nv_object(base);
-	if (ret)
-		return ret;
-
-	return nvkm_ramht_new(device, 0x1000, 0, instmem, &base->ramht);
-}
-
-void
-nv50_disp_main_dtor(struct nvkm_object *object)
-{
-	struct nv50_disp_base *base = (void *)object;
-	nvkm_ramht_del(&base->ramht);
-	nvkm_parent_destroy(&base->base);
-}
-
-static int
-nv50_disp_main_init(struct nvkm_object *object)
-{
-	struct nv50_disp *disp = (void *)object->engine;
-	struct nv50_disp_base *base = (void *)object;
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	int ret, i;
-	u32 tmp;
-
-	ret = nvkm_parent_init(&base->base);
-	if (ret)
-		return ret;
-
-	/* The below segments of code copying values from one register to
-	 * another appear to inform EVO of the display capabilities or
-	 * something similar.  NFI what the 0x614004 caps are for..
-	 */
-	tmp = nvkm_rd32(device, 0x614004);
-	nvkm_wr32(device, 0x610184, tmp);
-
-	/* ... CRTC caps */
-	for (i = 0; i < disp->head.nr; i++) {
-		tmp = nvkm_rd32(device, 0x616100 + (i * 0x800));
-		nvkm_wr32(device, 0x610190 + (i * 0x10), tmp);
-		tmp = nvkm_rd32(device, 0x616104 + (i * 0x800));
-		nvkm_wr32(device, 0x610194 + (i * 0x10), tmp);
-		tmp = nvkm_rd32(device, 0x616108 + (i * 0x800));
-		nvkm_wr32(device, 0x610198 + (i * 0x10), tmp);
-		tmp = nvkm_rd32(device, 0x61610c + (i * 0x800));
-		nvkm_wr32(device, 0x61019c + (i * 0x10), tmp);
-	}
-
-	/* ... DAC caps */
-	for (i = 0; i < disp->dac.nr; i++) {
-		tmp = nvkm_rd32(device, 0x61a000 + (i * 0x800));
-		nvkm_wr32(device, 0x6101d0 + (i * 0x04), tmp);
-	}
-
-	/* ... SOR caps */
-	for (i = 0; i < disp->sor.nr; i++) {
-		tmp = nvkm_rd32(device, 0x61c000 + (i * 0x800));
-		nvkm_wr32(device, 0x6101e0 + (i * 0x04), tmp);
-	}
-
-	/* ... PIOR caps */
-	for (i = 0; i < disp->pior.nr; i++) {
-		tmp = nvkm_rd32(device, 0x61e000 + (i * 0x800));
-		nvkm_wr32(device, 0x6101f0 + (i * 0x04), tmp);
-	}
-
-	/* steal display away from vbios, or something like that */
-	if (nvkm_rd32(device, 0x610024) & 0x00000100) {
-		nvkm_wr32(device, 0x610024, 0x00000100);
-		nvkm_mask(device, 0x6194e8, 0x00000001, 0x00000000);
-		if (nvkm_msec(device, 2000,
-			if (!(nvkm_rd32(device, 0x6194e8) & 0x00000002))
-				break;
-		) < 0)
-			return -EBUSY;
-	}
-
-	/* point at display engine memory area (hash table, objects) */
-	nvkm_wr32(device, 0x610010, (base->ramht->gpuobj->addr >> 8) | 9);
-
-	/* enable supervisor interrupts, disable everything else */
-	nvkm_wr32(device, 0x61002c, 0x00000370);
-	nvkm_wr32(device, 0x610028, 0x00000000);
-	return 0;
-}
-
-static int
-nv50_disp_main_fini(struct nvkm_object *object, bool suspend)
-{
-	struct nv50_disp *disp = (void *)object->engine;
-	struct nv50_disp_base *base = (void *)object;
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-
-	/* disable all interrupts */
-	nvkm_wr32(device, 0x610024, 0x00000000);
-	nvkm_wr32(device, 0x610020, 0x00000000);
-
-	return nvkm_parent_fini(&base->base, suspend);
-}
-
-struct nvkm_ofuncs
-nv50_disp_main_ofuncs = {
-	.ctor = nv50_disp_main_ctor,
-	.dtor = nv50_disp_main_dtor,
-	.init = nv50_disp_main_init,
-	.fini = nv50_disp_main_fini,
-	.mthd = nv50_disp_main_mthd,
-	.ntfy = nvkm_disp_ntfy,
-};
-
-static struct nvkm_oclass
-nv50_disp_main_oclass[] = {
-	{ NV50_DISP, &nv50_disp_main_ofuncs },
-	{}
-};
-
-static struct nvkm_oclass
-nv50_disp_sclass[] = {
-	{ NV50_DISP_CORE_CHANNEL_DMA, &nv50_disp_core_ofuncs.base },
-	{ NV50_DISP_BASE_CHANNEL_DMA, &nv50_disp_base_ofuncs.base },
-	{ NV50_DISP_OVERLAY_CHANNEL_DMA, &nv50_disp_ovly_ofuncs.base },
-	{ NV50_DISP_OVERLAY, &nv50_disp_oimm_ofuncs.base },
-	{ NV50_DISP_CURSOR, &nv50_disp_curs_ofuncs.base },
-	{}
-};
-
-/*******************************************************************************
- * Display context, tracks instmem allocation and prevents more than one
- * client using the display hardware at any time.
- ******************************************************************************/
 
 static int
 nv50_disp_data_ctor(struct nvkm_object *parent,
@@ -1323,10 +74,6 @@ nv50_disp_cclass = {
 	},
 };
 
-/*******************************************************************************
- * Display engine implementation
- ******************************************************************************/
-
 static void
 nv50_disp_vblank_fini(struct nvkm_event *event, int type, int head)
 {
@@ -2027,7 +774,7 @@ nv50_disp_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	nv_engine(disp)->sclass = nv50_disp_main_oclass;
+	nv_engine(disp)->sclass = nv50_disp_root_oclass;
 	nv_engine(disp)->cclass = &nv50_disp_cclass;
 	nv_subdev(disp)->intr = nv50_disp_intr;
 	INIT_WORK(&disp->supervisor, nv50_disp_intr_supervisor);
@@ -2062,5 +809,5 @@ nv50_disp_oclass = &(struct nv50_disp_impl) {
 	.mthd.base = &nv50_disp_base_mthd_chan,
 	.mthd.ovly = &nv50_disp_ovly_mthd_chan,
 	.mthd.prev = 0x000004,
-	.head.scanoutpos = nv50_disp_main_scanoutpos,
+	.head.scanoutpos = nv50_disp_root_scanoutpos,
 }.base.base;

commit 0710cc31482ae3711367c42e61580126c50c8ec0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/dma: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 12b835fee0d5..36241cf9173e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -209,8 +209,9 @@ nv50_disp_dmac_create_(struct nvkm_object *parent,
 		       struct nvkm_oclass *oclass, u64 pushbuf, int head,
 		       int length, void **pobject)
 {
+	struct nvkm_device *device = parent->engine->subdev.device;
 	struct nvkm_client *client = nvkm_client(parent);
-	struct nvkm_handle *handle;
+	struct nvkm_dma *dma = device->dma;
 	struct nvkm_dmaobj *dmaobj;
 	struct nv50_disp_dmac *dmac;
 	int ret;
@@ -221,27 +222,19 @@ nv50_disp_dmac_create_(struct nvkm_object *parent,
 	if (ret)
 		return ret;
 
-	handle = nvkm_client_search(client, pushbuf);
-	if (!handle)
+	dmaobj = nvkm_dma_search(dma, client, pushbuf);
+	if (!dmaobj)
 		return -ENOENT;
-	dmaobj = (void *)handle->object;
 
-	switch (nv_mclass(dmaobj)) {
-	case 0x0002:
-	case 0x003d:
-		if (dmaobj->limit - dmaobj->start != 0xfff)
-			return -EINVAL;
+	if (dmaobj->limit - dmaobj->start != 0xfff)
+		return -EINVAL;
 
-		switch (dmaobj->target) {
-		case NV_MEM_TARGET_VRAM:
-			dmac->push = 0x00000001 | dmaobj->start >> 8;
-			break;
-		case NV_MEM_TARGET_PCI_NOSNOOP:
-			dmac->push = 0x00000003 | dmaobj->start >> 8;
-			break;
-		default:
-			return -EINVAL;
-		}
+	switch (dmaobj->target) {
+	case NV_MEM_TARGET_VRAM:
+		dmac->push = 0x00000001 | dmaobj->start >> 8;
+		break;
+	case NV_MEM_TARGET_PCI_NOSNOOP:
+		dmac->push = 0x00000003 | dmaobj->start >> 8;
 		break;
 	default:
 		return -EINVAL;

commit 19fef52d93518cc01fd284b55ee93c0a9967634f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/dma: split user classes out from engine implementations
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 8743972009dc..12b835fee0d5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -30,7 +30,7 @@
 #include <core/enum.h>
 #include <core/handle.h>
 #include <core/ramht.h>
-#include <engine/dmaobj.h>
+#include <engine/dma.h>
 #include <subdev/bios.h>
 #include <subdev/bios/dcb.h>
 #include <subdev/bios/disp.h>

commit 2a9f847f5d43d15c0401d050cdd77fb4cbe7da06
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/device: convert user class to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index a3632d4b05d4..8743972009dc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -1300,7 +1300,7 @@ nv50_disp_data_ctor(struct nvkm_object *parent,
 	int ret;
 
 	/* no context needed for channel objects... */
-	if (nv_mclass(parent) != NV_DEVICE) {
+	if (parent->parent != &nvkm_client(parent)->object) {
 		atomic_inc(&parent->refcount);
 		*pobject = parent;
 		return 1;

commit 1d2a1e53865266a67fb569705eba3ec992682721
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/ramht: remove dependence on namedb
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 2568e5d5790e..a3632d4b05d4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -193,7 +193,7 @@ nv50_disp_dmac_object_attach(struct nvkm_object *parent,
 	u32 addr = nv_gpuobj(object)->node->offset;
 	u32 chid = chan->chid;
 	u32 data = (chid << 28) | (addr << 10) | chid;
-	return nvkm_ramht_insert(base->ramht, chid, name, data);
+	return nvkm_ramht_insert(base->ramht, NULL, chid, 0, name, data);
 }
 
 static void
@@ -1153,6 +1153,8 @@ nv50_disp_main_ctor(struct nvkm_object *parent,
 {
 	struct nv50_disp *disp = (void *)engine;
 	struct nv50_disp_base *base;
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_gpuobj *instmem = (void *)parent;
 	int ret;
 
 	ret = nvkm_parent_create(parent, engine, oclass, 0,
@@ -1161,15 +1163,14 @@ nv50_disp_main_ctor(struct nvkm_object *parent,
 	if (ret)
 		return ret;
 
-	return nvkm_ramht_new(nv_object(base), nv_object(base), 0x1000, 0,
-			      &base->ramht);
+	return nvkm_ramht_new(device, 0x1000, 0, instmem, &base->ramht);
 }
 
 void
 nv50_disp_main_dtor(struct nvkm_object *object)
 {
 	struct nv50_disp_base *base = (void *)object;
-	nvkm_ramht_ref(NULL, &base->ramht);
+	nvkm_ramht_del(&base->ramht);
 	nvkm_parent_destroy(&base->base);
 }
 
@@ -1235,7 +1236,7 @@ nv50_disp_main_init(struct nvkm_object *object)
 	}
 
 	/* point at display engine memory area (hash table, objects) */
-	nvkm_wr32(device, 0x610010, (nv_gpuobj(base->ramht)->addr >> 8) | 9);
+	nvkm_wr32(device, 0x610010, (base->ramht->gpuobj->addr >> 8) | 9);
 
 	/* enable supervisor interrupts, disable everything else */
 	nvkm_wr32(device, 0x61002c, 0x00000370);

commit bf81df9be28657eea4aca8c6ab4ed3e69f8a051c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/nvif: replace path-based object identification
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 9d7ac6a15bd7..2568e5d5790e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -206,9 +206,12 @@ nv50_disp_dmac_object_detach(struct nvkm_object *parent, int cookie)
 static int
 nv50_disp_dmac_create_(struct nvkm_object *parent,
 		       struct nvkm_object *engine,
-		       struct nvkm_oclass *oclass, u32 pushbuf, int head,
+		       struct nvkm_oclass *oclass, u64 pushbuf, int head,
 		       int length, void **pobject)
 {
+	struct nvkm_client *client = nvkm_client(parent);
+	struct nvkm_handle *handle;
+	struct nvkm_dmaobj *dmaobj;
 	struct nv50_disp_dmac *dmac;
 	int ret;
 
@@ -218,22 +221,23 @@ nv50_disp_dmac_create_(struct nvkm_object *parent,
 	if (ret)
 		return ret;
 
-	dmac->pushdma = (void *)nvkm_handle_ref(parent, pushbuf);
-	if (!dmac->pushdma)
+	handle = nvkm_client_search(client, pushbuf);
+	if (!handle)
 		return -ENOENT;
+	dmaobj = (void *)handle->object;
 
-	switch (nv_mclass(dmac->pushdma)) {
+	switch (nv_mclass(dmaobj)) {
 	case 0x0002:
 	case 0x003d:
-		if (dmac->pushdma->limit - dmac->pushdma->start != 0xfff)
+		if (dmaobj->limit - dmaobj->start != 0xfff)
 			return -EINVAL;
 
-		switch (dmac->pushdma->target) {
+		switch (dmaobj->target) {
 		case NV_MEM_TARGET_VRAM:
-			dmac->push = 0x00000001 | dmac->pushdma->start >> 8;
+			dmac->push = 0x00000001 | dmaobj->start >> 8;
 			break;
 		case NV_MEM_TARGET_PCI_NOSNOOP:
-			dmac->push = 0x00000003 | dmac->pushdma->start >> 8;
+			dmac->push = 0x00000003 | dmaobj->start >> 8;
 			break;
 		default:
 			return -EINVAL;
@@ -250,7 +254,6 @@ void
 nv50_disp_dmac_dtor(struct nvkm_object *object)
 {
 	struct nv50_disp_dmac *dmac = (void *)object;
-	nvkm_object_ref(NULL, (struct nvkm_object **)&dmac->pushdma);
 	nv50_disp_chan_destroy(&dmac->base);
 }
 
@@ -513,7 +516,7 @@ nv50_disp_core_ctor(struct nvkm_object *parent,
 	nvif_ioctl(parent, "create disp core channel dma size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
 		nvif_ioctl(parent, "create disp core channel dma vers %d "
-				   "pushbuf %08x\n",
+				   "pushbuf %016llx\n",
 			   args->v0.version, args->v0.pushbuf);
 	} else
 		return ret;
@@ -682,7 +685,7 @@ nv50_disp_base_ctor(struct nvkm_object *parent,
 	nvif_ioctl(parent, "create disp base channel dma size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
 		nvif_ioctl(parent, "create disp base channel dma vers %d "
-				   "pushbuf %08x head %d\n",
+				   "pushbuf %016llx head %d\n",
 			   args->v0.version, args->v0.pushbuf, args->v0.head);
 		if (args->v0.head > disp->head.nr)
 			return -EINVAL;
@@ -772,7 +775,7 @@ nv50_disp_ovly_ctor(struct nvkm_object *parent,
 	nvif_ioctl(parent, "create disp overlay channel dma size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
 		nvif_ioctl(parent, "create disp overlay channel dma vers %d "
-				   "pushbuf %08x head %d\n",
+				   "pushbuf %016llx head %d\n",
 			   args->v0.version, args->v0.pushbuf, args->v0.head);
 		if (args->v0.head > disp->head.nr)
 			return -EINVAL;

commit a1e88736221d2e971726931c449ed7d0af31755b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:15 2015 +1000

    drm/nouveau/device: decouple from engine machinery
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 5079ea3df4bf..9d7ac6a15bd7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -26,7 +26,7 @@
 #include "outpdp.h"
 
 #include <core/client.h>
-#include <core/engctx.h>
+#include <core/gpuobj.h>
 #include <core/enum.h>
 #include <core/handle.h>
 #include <core/ramht.h>
@@ -1292,8 +1292,8 @@ nv50_disp_data_ctor(struct nvkm_object *parent,
 		    struct nvkm_object **pobject)
 {
 	struct nv50_disp *disp = (void *)engine;
-	struct nvkm_engctx *ectx;
-	int ret = -EBUSY;
+	struct nvkm_gpuobj *gpuobj;
+	int ret;
 
 	/* no context needed for channel objects... */
 	if (nv_mclass(parent) != NV_DEVICE) {
@@ -1303,26 +1303,26 @@ nv50_disp_data_ctor(struct nvkm_object *parent,
 	}
 
 	/* allocate display hardware to client */
+	ret = nvkm_gpuobj_create(parent, engine, oclass, 0, NULL,
+				 0x10000, 0x10000, NVOBJ_FLAG_HEAP,
+				 &gpuobj);
+	*pobject = nv_object(gpuobj);
 	mutex_lock(&nv_subdev(disp)->mutex);
-	if (list_empty(&nv_engine(disp)->contexts)) {
-		ret = nvkm_engctx_create(parent, engine, oclass, NULL, 0x10000,
-					 0x10000, NVOBJ_FLAG_HEAP, &ectx);
-		*pobject = nv_object(ectx);
-	}
+	if (!list_empty(&nv_engine(disp)->contexts))
+		ret = -EBUSY;
 	mutex_unlock(&nv_subdev(disp)->mutex);
 	return ret;
 }
 
 struct nvkm_oclass
 nv50_disp_cclass = {
-	.handle = NV_ENGCTX(DISP, 0x50),
 	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv50_disp_data_ctor,
-		.dtor = _nvkm_engctx_dtor,
-		.init = _nvkm_engctx_init,
-		.fini = _nvkm_engctx_fini,
-		.rd32 = _nvkm_engctx_rd32,
-		.wr32 = _nvkm_engctx_wr32,
+		.dtor = _nvkm_gpuobj_dtor,
+		.init = _nvkm_gpuobj_init,
+		.fini = _nvkm_gpuobj_fini,
+		.rd32 = _nvkm_gpuobj_rd32,
+		.wr32 = _nvkm_gpuobj_wr32,
 	},
 };
 

commit f2c906fc0cf1657e4164e09ae6061534eebd5430
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:15 2015 +1000

    drm/nouveau/disp: transition outp/conn away from being based on nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index b07cb0626e87..5079ea3df4bf 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -1109,7 +1109,7 @@ nv50_disp_main_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	}
 		break;
 	case NV50_DISP_MTHD_V1_SOR_DP_PWR: {
-		struct nvkm_output_dp *outpdp = (void *)outp;
+		struct nvkm_output_dp *outpdp = nvkm_output_dp(outp);
 		union {
 			struct nv50_disp_sor_dp_pwr_v0 v0;
 		} *args = data;
@@ -1119,8 +1119,7 @@ nv50_disp_main_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 				   args->v0.version, args->v0.state);
 			if (args->v0.state == 0) {
 				nvkm_notify_put(&outpdp->irq);
-				((struct nvkm_output_dp_impl *)nv_oclass(outp))
-					->lnk_pwr(outpdp, 0);
+				outpdp->func->lnk_pwr(outpdp, 0);
 				atomic_set(&outpdp->lt.done, 0);
 				return 0;
 			} else
@@ -1655,7 +1654,7 @@ nv50_disp_intr_unk20_0(struct nv50_disp *disp, int head)
 	 * in a blank screen (SOR_PWR off/on can restore it)
 	 */
 	if (outp && outp->info.type == DCB_OUTPUT_DP) {
-		struct nvkm_output_dp *outpdp = (void *)outp;
+		struct nvkm_output_dp *outpdp = nvkm_output_dp(outp);
 		struct nvbios_init init = {
 			.subdev = nv_subdev(disp),
 			.bios = nvkm_bios(disp),
@@ -1855,7 +1854,7 @@ nv50_disp_intr_unk20_2(struct nv50_disp *disp, int head)
 		}
 
 		if (nvkm_output_dp_train(outp, datarate / soff, true))
-			ERR("link not trained before attach\n");
+			OUTP_ERR(outp, "link not trained before attach");
 	}
 
 	exec_clkcmp(disp, head, 0, pclk, &conf);
@@ -2047,12 +2046,6 @@ nv50_disp_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	return 0;
 }
 
-struct nvkm_oclass *
-nv50_disp_outp_sclass[] = {
-	&nv50_pior_dp_impl.base.base,
-	NULL
-};
-
 struct nvkm_oclass *
 nv50_disp_oclass = &(struct nv50_disp_impl) {
 	.base.base.handle = NV_ENGINE(DISP, 0x50),
@@ -2062,8 +2055,12 @@ nv50_disp_oclass = &(struct nv50_disp_impl) {
 		.init = _nvkm_disp_init,
 		.fini = _nvkm_disp_fini,
 	},
+	.base.outp.internal.crt = nv50_dac_output_new,
+	.base.outp.internal.tmds = nv50_sor_output_new,
+	.base.outp.internal.lvds = nv50_sor_output_new,
+	.base.outp.external.tmds = nv50_pior_output_new,
+	.base.outp.external.dp = nv50_pior_dp_new,
 	.base.vblank = &nv50_disp_vblank_func,
-	.base.outp =  nv50_disp_outp_sclass,
 	.mthd.core = &nv50_disp_core_mthd_chan,
 	.mthd.base = &nv50_disp_base_mthd_chan,
 	.mthd.ovly = &nv50_disp_ovly_mthd_chan,

commit 53003941067534b1071b0f7b71f4700c16d97b28
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:13 2015 +1000

    drm/nouveau/core: remove last printks
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index f485d7829004..b07cb0626e87 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -510,11 +510,11 @@ nv50_disp_core_ctor(struct nvkm_object *parent,
 	struct nv50_disp_dmac *mast;
 	int ret;
 
-	nv_ioctl(parent, "create disp core channel dma size %d\n", size);
+	nvif_ioctl(parent, "create disp core channel dma size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(parent, "create disp core channel dma vers %d "
-				 "pushbuf %08x\n",
-			 args->v0.version, args->v0.pushbuf);
+		nvif_ioctl(parent, "create disp core channel dma vers %d "
+				   "pushbuf %08x\n",
+			   args->v0.version, args->v0.pushbuf);
 	} else
 		return ret;
 
@@ -679,11 +679,11 @@ nv50_disp_base_ctor(struct nvkm_object *parent,
 	struct nv50_disp_dmac *dmac;
 	int ret;
 
-	nv_ioctl(parent, "create disp base channel dma size %d\n", size);
+	nvif_ioctl(parent, "create disp base channel dma size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(parent, "create disp base channel dma vers %d "
-				 "pushbuf %08x head %d\n",
-			 args->v0.version, args->v0.pushbuf, args->v0.head);
+		nvif_ioctl(parent, "create disp base channel dma vers %d "
+				   "pushbuf %08x head %d\n",
+			   args->v0.version, args->v0.pushbuf, args->v0.head);
 		if (args->v0.head > disp->head.nr)
 			return -EINVAL;
 	} else
@@ -769,11 +769,11 @@ nv50_disp_ovly_ctor(struct nvkm_object *parent,
 	struct nv50_disp_dmac *dmac;
 	int ret;
 
-	nv_ioctl(parent, "create disp overlay channel dma size %d\n", size);
+	nvif_ioctl(parent, "create disp overlay channel dma size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(parent, "create disp overlay channel dma vers %d "
-				 "pushbuf %08x head %d\n",
-			 args->v0.version, args->v0.pushbuf, args->v0.head);
+		nvif_ioctl(parent, "create disp overlay channel dma vers %d "
+				   "pushbuf %08x head %d\n",
+			   args->v0.version, args->v0.pushbuf, args->v0.head);
 		if (args->v0.head > disp->head.nr)
 			return -EINVAL;
 	} else
@@ -903,10 +903,10 @@ nv50_disp_oimm_ctor(struct nvkm_object *parent,
 	struct nv50_disp_pioc *pioc;
 	int ret;
 
-	nv_ioctl(parent, "create disp overlay size %d\n", size);
+	nvif_ioctl(parent, "create disp overlay size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(parent, "create disp overlay vers %d head %d\n",
-			 args->v0.version, args->v0.head);
+		nvif_ioctl(parent, "create disp overlay vers %d head %d\n",
+			   args->v0.version, args->v0.head);
 		if (args->v0.head > disp->head.nr)
 			return -EINVAL;
 	} else
@@ -951,10 +951,10 @@ nv50_disp_curs_ctor(struct nvkm_object *parent,
 	struct nv50_disp_pioc *pioc;
 	int ret;
 
-	nv_ioctl(parent, "create disp cursor size %d\n", size);
+	nvif_ioctl(parent, "create disp cursor size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(parent, "create disp cursor vers %d head %d\n",
-			 args->v0.version, args->v0.head);
+		nvif_ioctl(parent, "create disp cursor vers %d head %d\n",
+			   args->v0.version, args->v0.head);
 		if (args->v0.head > disp->head.nr)
 			return -EINVAL;
 	} else
@@ -998,9 +998,10 @@ nv50_disp_main_scanoutpos(NV50_DISP_MTHD_V0)
 	} *args = data;
 	int ret;
 
-	nv_ioctl(object, "disp scanoutpos size %d\n", size);
+	nvif_ioctl(object, "disp scanoutpos size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		nv_ioctl(object, "disp scanoutpos vers %d\n", args->v0.version);
+		nvif_ioctl(object, "disp scanoutpos vers %d\n",
+			   args->v0.version);
 		args->v0.vblanke = (blanke & 0xffff0000) >> 16;
 		args->v0.hblanke = (blanke & 0x0000ffff);
 		args->v0.vblanks = (blanks & 0xffff0000) >> 16;
@@ -1036,18 +1037,18 @@ nv50_disp_main_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	if (mthd != NV50_DISP_MTHD)
 		return -EINVAL;
 
-	nv_ioctl(object, "disp mthd size %d\n", size);
+	nvif_ioctl(object, "disp mthd size %d\n", size);
 	if (nvif_unpack(args->v0, 0, 0, true)) {
-		nv_ioctl(object, "disp mthd vers %d mthd %02x head %d\n",
-			 args->v0.version, args->v0.method, args->v0.head);
+		nvif_ioctl(object, "disp mthd vers %d mthd %02x head %d\n",
+			   args->v0.version, args->v0.method, args->v0.head);
 		mthd = args->v0.method;
 		head = args->v0.head;
 	} else
 	if (nvif_unpack(args->v1, 1, 1, true)) {
-		nv_ioctl(object, "disp mthd vers %d mthd %02x "
-				 "type %04x mask %04x\n",
-			 args->v1.version, args->v1.method,
-			 args->v1.hasht, args->v1.hashm);
+		nvif_ioctl(object, "disp mthd vers %d mthd %02x "
+				   "type %04x mask %04x\n",
+			   args->v1.version, args->v1.method,
+			   args->v1.hasht, args->v1.hashm);
 		mthd = args->v1.method;
 		type = args->v1.hasht;
 		mask = args->v1.hashm;
@@ -1096,11 +1097,11 @@ nv50_disp_main_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 		union {
 			struct nv50_disp_sor_lvds_script_v0 v0;
 		} *args = data;
-		nv_ioctl(object, "disp sor lvds script size %d\n", size);
+		nvif_ioctl(object, "disp sor lvds script size %d\n", size);
 		if (nvif_unpack(args->v0, 0, 0, false)) {
-			nv_ioctl(object, "disp sor lvds script "
-					 "vers %d name %04x\n",
-				 args->v0.version, args->v0.script);
+			nvif_ioctl(object, "disp sor lvds script "
+					   "vers %d name %04x\n",
+				   args->v0.version, args->v0.script);
 			disp->sor.lvdsconf = args->v0.script;
 			return 0;
 		} else
@@ -1112,10 +1113,10 @@ nv50_disp_main_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 		union {
 			struct nv50_disp_sor_dp_pwr_v0 v0;
 		} *args = data;
-		nv_ioctl(object, "disp sor dp pwr size %d\n", size);
+		nvif_ioctl(object, "disp sor dp pwr size %d\n", size);
 		if (nvif_unpack(args->v0, 0, 0, false)) {
-			nv_ioctl(object, "disp sor dp pwr vers %d state %d\n",
-				 args->v0.version, args->v0.state);
+			nvif_ioctl(object, "disp sor dp pwr vers %d state %d\n",
+				   args->v0.version, args->v0.state);
 			if (args->v0.state == 0) {
 				nvkm_notify_put(&outpdp->irq);
 				((struct nvkm_output_dp_impl *)nv_oclass(outp))

commit 84407824e97d87161f5ef09ba43a1ac6ec10f479
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:13 2015 +1000

    drm/nouveau/disp: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 0cf02347178d..f485d7829004 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -259,7 +259,8 @@ nv50_disp_dmac_init(struct nvkm_object *object)
 {
 	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_dmac *dmac = (void *)object;
-	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	int chid = dmac->base.chid;
 	int ret;
 
@@ -283,8 +284,8 @@ nv50_disp_dmac_init(struct nvkm_object *object)
 		if (!(nvkm_rd32(device, 0x610200 + (chid * 0x10)) & 0x80000000))
 			break;
 	) < 0) {
-		nv_error(dmac, "init timeout, 0x%08x\n",
-			 nvkm_rd32(device, 0x610200 + (chid * 0x10)));
+		nvkm_error(subdev, "ch %d init timeout, %08x\n", chid,
+			   nvkm_rd32(device, 0x610200 + (chid * 0x10)));
 		return -EBUSY;
 	}
 
@@ -296,7 +297,8 @@ nv50_disp_dmac_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_dmac *dmac = (void *)object;
-	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	int chid = dmac->base.chid;
 
 	/* deactivate channel */
@@ -306,8 +308,8 @@ nv50_disp_dmac_fini(struct nvkm_object *object, bool suspend)
 		if (!(nvkm_rd32(device, 0x610200 + (chid * 0x10)) & 0x001e0000))
 			break;
 	) < 0) {
-		nv_error(dmac, "fini timeout, 0x%08x\n",
-			 nvkm_rd32(device, 0x610200 + (chid * 0x10)));
+		nvkm_error(subdev, "ch %d fini timeout, %08x\n", chid,
+			   nvkm_rd32(device, 0x610200 + (chid * 0x10)));
 		if (suspend)
 			return -EBUSY;
 	}
@@ -326,8 +328,8 @@ static void
 nv50_disp_mthd_list(struct nv50_disp *disp, int debug, u32 base, int c,
 		    const struct nv50_disp_mthd_list *list, int inst)
 {
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	struct nvkm_object *object = nv_object(disp);
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	int i;
 
 	for (i = 0; list->data[i].mthd; i++) {
@@ -339,13 +341,14 @@ nv50_disp_mthd_list(struct nv50_disp *disp, int debug, u32 base, int c,
 			char mods[16];
 
 			if (prev != next)
-				snprintf(mods, sizeof(mods), "-> 0x%08x", next);
+				snprintf(mods, sizeof(mods), "-> %08x", next);
 			else
 				snprintf(mods, sizeof(mods), "%13c", ' ');
 
-			nv_printk_(object, debug, "\t0x%04x: 0x%08x %s%s%s\n",
-				   mthd, prev, mods, name ? " // " : "",
-				   name ? name : "");
+			nvkm_printk_(subdev, debug, info,
+				     "\t%04x: %08x %s%s%s\n",
+				     mthd, prev, mods, name ? " // " : "",
+				     name ? name : "");
 		}
 	}
 }
@@ -357,6 +360,7 @@ nv50_disp_mthd_chan(struct nv50_disp *disp, int debug, int head,
 	struct nvkm_object *object = nv_object(disp);
 	const struct nv50_disp_impl *impl = (void *)object->oclass;
 	const struct nv50_disp_mthd_list *list;
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
 	int i, j;
 
 	if (debug > nv_subdev(disp)->debug)
@@ -381,7 +385,7 @@ nv50_disp_mthd_chan(struct nv50_disp *disp, int debug, int head,
 				sname = sname_;
 			}
 
-			nv_printk_(object, debug, "%s%s:\n", cname, sname);
+			nvkm_printk_(subdev, debug, info, "%s%s:\n", cname, sname);
 			nv50_disp_mthd_list(disp, debug, base, impl->mthd.prev,
 					    list, j);
 		}
@@ -528,7 +532,8 @@ nv50_disp_core_init(struct nvkm_object *object)
 {
 	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_dmac *mast = (void *)object;
-	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	int ret;
 
 	ret = nv50_disp_chan_init(&mast->base);
@@ -557,7 +562,8 @@ nv50_disp_core_init(struct nvkm_object *object)
 		if (!(nvkm_rd32(device, 0x610200) & 0x80000000))
 			break;
 	) < 0) {
-		nv_error(mast, "init: 0x%08x\n", nvkm_rd32(device, 0x610200));
+		nvkm_error(subdev, "core init: %08x\n",
+			   nvkm_rd32(device, 0x610200));
 		return -EBUSY;
 	}
 
@@ -569,7 +575,8 @@ nv50_disp_core_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_dmac *mast = (void *)object;
-	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 
 	/* deactivate channel */
 	nvkm_mask(device, 0x610200, 0x00000010, 0x00000000);
@@ -578,7 +585,8 @@ nv50_disp_core_fini(struct nvkm_object *object, bool suspend)
 		if (!(nvkm_rd32(device, 0x610200) & 0x001e0000))
 			break;
 	) < 0) {
-		nv_error(mast, "fini: 0x%08x\n", nvkm_rd32(device, 0x610200));
+		nvkm_error(subdev, "core fini: %08x\n",
+			   nvkm_rd32(device, 0x610200));
 		if (suspend)
 			return -EBUSY;
 	}
@@ -822,7 +830,8 @@ nv50_disp_pioc_init(struct nvkm_object *object)
 {
 	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_pioc *pioc = (void *)object;
-	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	int chid = pioc->base.chid;
 	int ret;
 
@@ -835,8 +844,8 @@ nv50_disp_pioc_init(struct nvkm_object *object)
 		if (!(nvkm_rd32(device, 0x610200 + (chid * 0x10)) & 0x00030000))
 			break;
 	) < 0) {
-		nv_error(pioc, "timeout0: 0x%08x\n",
-			 nvkm_rd32(device, 0x610200 + (chid * 0x10)));
+		nvkm_error(subdev, "ch %d timeout0: %08x\n", chid,
+			   nvkm_rd32(device, 0x610200 + (chid * 0x10)));
 		return -EBUSY;
 	}
 
@@ -846,8 +855,8 @@ nv50_disp_pioc_init(struct nvkm_object *object)
 		if ((tmp & 0x00030000) == 0x00010000)
 			break;
 	) < 0) {
-		nv_error(pioc, "timeout1: 0x%08x\n",
-			 nvkm_rd32(device, 0x610200 + (chid * 0x10)));
+		nvkm_error(subdev, "ch %d timeout1: %08x\n", chid,
+			   nvkm_rd32(device, 0x610200 + (chid * 0x10)));
 		return -EBUSY;
 	}
 
@@ -859,7 +868,8 @@ nv50_disp_pioc_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_pioc *pioc = (void *)object;
-	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	int chid = pioc->base.chid;
 
 	nvkm_mask(device, 0x610200 + (chid * 0x10), 0x00000001, 0x00000000);
@@ -867,8 +877,8 @@ nv50_disp_pioc_fini(struct nvkm_object *object, bool suspend)
 		if (!(nvkm_rd32(device, 0x610200 + (chid * 0x10)) & 0x00030000))
 			break;
 	) < 0) {
-		nv_error(pioc, "timeout: 0x%08x\n",
-			 nvkm_rd32(device, 0x610200 + (chid * 0x10)));
+		nvkm_error(subdev, "ch %d timeout: %08x\n", chid,
+			   nvkm_rd32(device, 0x610200 + (chid * 0x10)));
 		if (suspend)
 			return -EBUSY;
 	}
@@ -1362,26 +1372,22 @@ static void
 nv50_disp_intr_error(struct nv50_disp *disp, int chid)
 {
 	struct nv50_disp_impl *impl = (void *)nv_object(disp)->oclass;
-	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	u32 data = nvkm_rd32(device, 0x610084 + (chid * 0x08));
 	u32 addr = nvkm_rd32(device, 0x610080 + (chid * 0x08));
 	u32 code = (addr & 0x00ff0000) >> 16;
 	u32 type = (addr & 0x00007000) >> 12;
 	u32 mthd = (addr & 0x00000ffc);
 	const struct nvkm_enum *ec, *et;
-	char ecunk[6], etunk[6];
 
 	et = nvkm_enum_find(nv50_disp_intr_error_type, type);
-	if (!et)
-		snprintf(etunk, sizeof(etunk), "UNK%02X", type);
-
 	ec = nvkm_enum_find(nv50_disp_intr_error_code, code);
-	if (!ec)
-		snprintf(ecunk, sizeof(ecunk), "UNK%02X", code);
 
-	nv_error(disp, "%s [%s] chid %d mthd 0x%04x data 0x%08x\n",
-		 et ? et->name : etunk, ec ? ec->name : ecunk,
-		 chid, mthd, data);
+	nvkm_error(subdev,
+		   "ERROR %d [%s] %02x [%s] chid %d mthd %04x data %08x\n",
+		   type, et ? et->name : "", code, ec ? ec->name : "",
+		   chid, mthd, data);
 
 	if (chid == 0) {
 		switch (mthd) {
@@ -1423,7 +1429,8 @@ exec_lookup(struct nv50_disp *disp, int head, int or, u32 ctrl,
 	    u32 *data, u8 *ver, u8 *hdr, u8 *cnt, u8 *len,
 	    struct nvbios_outp *info)
 {
-	struct nvkm_bios *bios = nvkm_bios(disp);
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
+	struct nvkm_bios *bios = subdev->device->bios;
 	struct nvkm_output *outp;
 	u16 mask, type;
 
@@ -1440,7 +1447,7 @@ exec_lookup(struct nv50_disp *disp, int head, int or, u32 ctrl,
 		case 0x00000800: type = DCB_OUTPUT_DP; mask = 1; break;
 		case 0x00000900: type = DCB_OUTPUT_DP; mask = 2; break;
 		default:
-			nv_error(disp, "unknown SOR mc 0x%08x\n", ctrl);
+			nvkm_error(subdev, "unknown SOR mc %08x\n", ctrl);
 			return NULL;
 		}
 		or  -= 4;
@@ -1451,7 +1458,7 @@ exec_lookup(struct nv50_disp *disp, int head, int or, u32 ctrl,
 		switch (ctrl & 0x00000f00) {
 		case 0x00000000: type |= disp->pior.type[or]; break;
 		default:
-			nv_error(disp, "unknown PIOR mc 0x%08x\n", ctrl);
+			nvkm_error(subdev, "unknown PIOR mc %08x\n", ctrl);
 			return NULL;
 		}
 	}
@@ -1676,7 +1683,8 @@ static void
 nv50_disp_intr_unk20_2_dp(struct nv50_disp *disp, int head,
 			  struct dcb_output *outp, u32 pclk)
 {
-	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	const int link = !(outp->sorconf.link & 1);
 	const int   or = ffs(outp->or) - 1;
 	const u32 soff = (  or * 0x800);
@@ -1775,7 +1783,7 @@ nv50_disp_intr_unk20_2_dp(struct nv50_disp *disp, int head,
 	}
 
 	if (!bestTU) {
-		nv_error(disp, "unable to find suitable dp config\n");
+		nvkm_error(subdev, "unable to find suitable dp config\n");
 		return;
 	}
 
@@ -1922,11 +1930,12 @@ nv50_disp_intr_supervisor(struct work_struct *work)
 	struct nv50_disp *disp =
 		container_of(work, struct nv50_disp, supervisor);
 	struct nv50_disp_impl *impl = (void *)nv_object(disp)->oclass;
-	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_subdev *subdev = &disp->base.engine.subdev;
+	struct nvkm_device *device = subdev->device;
 	u32 super = nvkm_rd32(device, 0x610030);
 	int head;
 
-	nv_debug(disp, "supervisor 0x%08x 0x%08x\n", disp->super, super);
+	nvkm_debug(subdev, "supervisor %08x %08x\n", disp->super, super);
 
 	if (disp->super & 0x00000010) {
 		nv50_disp_mthd_chan(disp, NV_DBG_DEBUG, 0, impl->mthd.core);

commit 3a020b4dfc3a6c79f144b2c6786d86b33cda64d9
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:11 2015 +1000

    drm/nouveau/disp: switch to new-style timer macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index a57b7d0c4445..0cf02347178d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -279,7 +279,10 @@ nv50_disp_dmac_init(struct nvkm_object *object)
 	nvkm_wr32(device, 0x610200 + (chid * 0x0010), 0x00000013);
 
 	/* wait for it to go inactive */
-	if (!nv_wait(disp, 0x610200 + (chid * 0x10), 0x80000000, 0x00000000)) {
+	if (nvkm_msec(device, 2000,
+		if (!(nvkm_rd32(device, 0x610200 + (chid * 0x10)) & 0x80000000))
+			break;
+	) < 0) {
 		nv_error(dmac, "init timeout, 0x%08x\n",
 			 nvkm_rd32(device, 0x610200 + (chid * 0x10)));
 		return -EBUSY;
@@ -299,7 +302,10 @@ nv50_disp_dmac_fini(struct nvkm_object *object, bool suspend)
 	/* deactivate channel */
 	nvkm_mask(device, 0x610200 + (chid * 0x0010), 0x00001010, 0x00001000);
 	nvkm_mask(device, 0x610200 + (chid * 0x0010), 0x00000003, 0x00000000);
-	if (!nv_wait(disp, 0x610200 + (chid * 0x10), 0x001e0000, 0x00000000)) {
+	if (nvkm_msec(device, 2000,
+		if (!(nvkm_rd32(device, 0x610200 + (chid * 0x10)) & 0x001e0000))
+			break;
+	) < 0) {
 		nv_error(dmac, "fini timeout, 0x%08x\n",
 			 nvkm_rd32(device, 0x610200 + (chid * 0x10)));
 		if (suspend)
@@ -547,7 +553,10 @@ nv50_disp_core_init(struct nvkm_object *object)
 	nvkm_wr32(device, 0x610200, 0x01000013);
 
 	/* wait for it to go inactive */
-	if (!nv_wait(disp, 0x610200, 0x80000000, 0x00000000)) {
+	if (nvkm_msec(device, 2000,
+		if (!(nvkm_rd32(device, 0x610200) & 0x80000000))
+			break;
+	) < 0) {
 		nv_error(mast, "init: 0x%08x\n", nvkm_rd32(device, 0x610200));
 		return -EBUSY;
 	}
@@ -565,7 +574,10 @@ nv50_disp_core_fini(struct nvkm_object *object, bool suspend)
 	/* deactivate channel */
 	nvkm_mask(device, 0x610200, 0x00000010, 0x00000000);
 	nvkm_mask(device, 0x610200, 0x00000003, 0x00000000);
-	if (!nv_wait(disp, 0x610200, 0x001e0000, 0x00000000)) {
+	if (nvkm_msec(device, 2000,
+		if (!(nvkm_rd32(device, 0x610200) & 0x001e0000))
+			break;
+	) < 0) {
 		nv_error(mast, "fini: 0x%08x\n", nvkm_rd32(device, 0x610200));
 		if (suspend)
 			return -EBUSY;
@@ -819,14 +831,21 @@ nv50_disp_pioc_init(struct nvkm_object *object)
 		return ret;
 
 	nvkm_wr32(device, 0x610200 + (chid * 0x10), 0x00002000);
-	if (!nv_wait(disp, 0x610200 + (chid * 0x10), 0x00000000, 0x00000000)) {
+	if (nvkm_msec(device, 2000,
+		if (!(nvkm_rd32(device, 0x610200 + (chid * 0x10)) & 0x00030000))
+			break;
+	) < 0) {
 		nv_error(pioc, "timeout0: 0x%08x\n",
 			 nvkm_rd32(device, 0x610200 + (chid * 0x10)));
 		return -EBUSY;
 	}
 
 	nvkm_wr32(device, 0x610200 + (chid * 0x10), 0x00000001);
-	if (!nv_wait(disp, 0x610200 + (chid * 0x10), 0x00030000, 0x00010000)) {
+	if (nvkm_msec(device, 2000,
+		u32 tmp = nvkm_rd32(device, 0x610200 + (chid * 0x10));
+		if ((tmp & 0x00030000) == 0x00010000)
+			break;
+	) < 0) {
 		nv_error(pioc, "timeout1: 0x%08x\n",
 			 nvkm_rd32(device, 0x610200 + (chid * 0x10)));
 		return -EBUSY;
@@ -844,7 +863,10 @@ nv50_disp_pioc_fini(struct nvkm_object *object, bool suspend)
 	int chid = pioc->base.chid;
 
 	nvkm_mask(device, 0x610200 + (chid * 0x10), 0x00000001, 0x00000000);
-	if (!nv_wait(disp, 0x610200 + (chid * 0x10), 0x00030000, 0x00000000)) {
+	if (nvkm_msec(device, 2000,
+		if (!(nvkm_rd32(device, 0x610200 + (chid * 0x10)) & 0x00030000))
+			break;
+	) < 0) {
 		nv_error(pioc, "timeout: 0x%08x\n",
 			 nvkm_rd32(device, 0x610200 + (chid * 0x10)));
 		if (suspend)
@@ -1192,10 +1214,11 @@ nv50_disp_main_init(struct nvkm_object *object)
 	if (nvkm_rd32(device, 0x610024) & 0x00000100) {
 		nvkm_wr32(device, 0x610024, 0x00000100);
 		nvkm_mask(device, 0x6194e8, 0x00000001, 0x00000000);
-		if (!nv_wait(disp, 0x6194e8, 0x00000002, 0x00000000)) {
-			nv_error(disp, "timeout acquiring display\n");
+		if (nvkm_msec(device, 2000,
+			if (!(nvkm_rd32(device, 0x6194e8) & 0x00000002))
+				break;
+		) < 0)
 			return -EBUSY;
-		}
 	}
 
 	/* point at display engine memory area (hash table, objects) */

commit 2fde1f1c343030d169945aa67a0e485b568f1393
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:10 2015 +1000

    drm/nouveau/disp: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 9551cfe5622a..a57b7d0c4445 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -89,16 +89,18 @@ static void
 nv50_disp_chan_uevent_fini(struct nvkm_event *event, int type, int index)
 {
 	struct nv50_disp *disp = container_of(event, typeof(*disp), uevent);
-	nv_mask(disp, 0x610028, 0x00000001 << index, 0x00000000 << index);
-	nv_wr32(disp, 0x610020, 0x00000001 << index);
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	nvkm_mask(device, 0x610028, 0x00000001 << index, 0x00000000 << index);
+	nvkm_wr32(device, 0x610020, 0x00000001 << index);
 }
 
 static void
 nv50_disp_chan_uevent_init(struct nvkm_event *event, int types, int index)
 {
 	struct nv50_disp *disp = container_of(event, typeof(*disp), uevent);
-	nv_wr32(disp, 0x610020, 0x00000001 << index);
-	nv_mask(disp, 0x610028, 0x00000001 << index, 0x00000001 << index);
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	nvkm_wr32(device, 0x610020, 0x00000001 << index);
+	nvkm_mask(device, 0x610028, 0x00000001 << index, 0x00000001 << index);
 }
 
 void
@@ -165,17 +167,17 @@ nv50_disp_chan_map(struct nvkm_object *object, u64 *addr, u32 *size)
 u32
 nv50_disp_chan_rd32(struct nvkm_object *object, u64 addr)
 {
-	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_chan *chan = (void *)object;
-	return nv_rd32(disp, 0x640000 + (chan->chid * 0x1000) + addr);
+	struct nvkm_device *device = object->engine->subdev.device;
+	return nvkm_rd32(device, 0x640000 + (chan->chid * 0x1000) + addr);
 }
 
 void
 nv50_disp_chan_wr32(struct nvkm_object *object, u64 addr, u32 data)
 {
-	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_chan *chan = (void *)object;
-	nv_wr32(disp, 0x640000 + (chan->chid * 0x1000) + addr, data);
+	struct nvkm_device *device = object->engine->subdev.device;
+	nvkm_wr32(device, 0x640000 + (chan->chid * 0x1000) + addr, data);
 }
 
 /*******************************************************************************
@@ -257,6 +259,7 @@ nv50_disp_dmac_init(struct nvkm_object *object)
 {
 	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_dmac *dmac = (void *)object;
+	struct nvkm_device *device = disp->base.engine.subdev.device;
 	int chid = dmac->base.chid;
 	int ret;
 
@@ -265,20 +268,20 @@ nv50_disp_dmac_init(struct nvkm_object *object)
 		return ret;
 
 	/* enable error reporting */
-	nv_mask(disp, 0x610028, 0x00010000 << chid, 0x00010000 << chid);
+	nvkm_mask(device, 0x610028, 0x00010000 << chid, 0x00010000 << chid);
 
 	/* initialise channel for dma command submission */
-	nv_wr32(disp, 0x610204 + (chid * 0x0010), dmac->push);
-	nv_wr32(disp, 0x610208 + (chid * 0x0010), 0x00010000);
-	nv_wr32(disp, 0x61020c + (chid * 0x0010), chid);
-	nv_mask(disp, 0x610200 + (chid * 0x0010), 0x00000010, 0x00000010);
-	nv_wr32(disp, 0x640000 + (chid * 0x1000), 0x00000000);
-	nv_wr32(disp, 0x610200 + (chid * 0x0010), 0x00000013);
+	nvkm_wr32(device, 0x610204 + (chid * 0x0010), dmac->push);
+	nvkm_wr32(device, 0x610208 + (chid * 0x0010), 0x00010000);
+	nvkm_wr32(device, 0x61020c + (chid * 0x0010), chid);
+	nvkm_mask(device, 0x610200 + (chid * 0x0010), 0x00000010, 0x00000010);
+	nvkm_wr32(device, 0x640000 + (chid * 0x1000), 0x00000000);
+	nvkm_wr32(device, 0x610200 + (chid * 0x0010), 0x00000013);
 
 	/* wait for it to go inactive */
 	if (!nv_wait(disp, 0x610200 + (chid * 0x10), 0x80000000, 0x00000000)) {
 		nv_error(dmac, "init timeout, 0x%08x\n",
-			 nv_rd32(disp, 0x610200 + (chid * 0x10)));
+			 nvkm_rd32(device, 0x610200 + (chid * 0x10)));
 		return -EBUSY;
 	}
 
@@ -290,20 +293,21 @@ nv50_disp_dmac_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_dmac *dmac = (void *)object;
+	struct nvkm_device *device = disp->base.engine.subdev.device;
 	int chid = dmac->base.chid;
 
 	/* deactivate channel */
-	nv_mask(disp, 0x610200 + (chid * 0x0010), 0x00001010, 0x00001000);
-	nv_mask(disp, 0x610200 + (chid * 0x0010), 0x00000003, 0x00000000);
+	nvkm_mask(device, 0x610200 + (chid * 0x0010), 0x00001010, 0x00001000);
+	nvkm_mask(device, 0x610200 + (chid * 0x0010), 0x00000003, 0x00000000);
 	if (!nv_wait(disp, 0x610200 + (chid * 0x10), 0x001e0000, 0x00000000)) {
 		nv_error(dmac, "fini timeout, 0x%08x\n",
-			 nv_rd32(disp, 0x610200 + (chid * 0x10)));
+			 nvkm_rd32(device, 0x610200 + (chid * 0x10)));
 		if (suspend)
 			return -EBUSY;
 	}
 
 	/* disable error reporting and completion notifications */
-	nv_mask(disp, 0x610028, 0x00010001 << chid, 0x00000000 << chid);
+	nvkm_mask(device, 0x610028, 0x00010001 << chid, 0x00000000 << chid);
 
 	return nv50_disp_chan_fini(&dmac->base, suspend);
 }
@@ -316,13 +320,14 @@ static void
 nv50_disp_mthd_list(struct nv50_disp *disp, int debug, u32 base, int c,
 		    const struct nv50_disp_mthd_list *list, int inst)
 {
+	struct nvkm_device *device = disp->base.engine.subdev.device;
 	struct nvkm_object *object = nv_object(disp);
 	int i;
 
 	for (i = 0; list->data[i].mthd; i++) {
 		if (list->data[i].addr) {
-			u32 next = nv_rd32(disp, list->data[i].addr + base + 0);
-			u32 prev = nv_rd32(disp, list->data[i].addr + base + c);
+			u32 next = nvkm_rd32(device, list->data[i].addr + base + 0);
+			u32 prev = nvkm_rd32(device, list->data[i].addr + base + c);
 			u32 mthd = list->data[i].mthd + (list->mthd * inst);
 			const char *name = list->data[i].name;
 			char mods[16];
@@ -517,6 +522,7 @@ nv50_disp_core_init(struct nvkm_object *object)
 {
 	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_dmac *mast = (void *)object;
+	struct nvkm_device *device = disp->base.engine.subdev.device;
 	int ret;
 
 	ret = nv50_disp_chan_init(&mast->base);
@@ -524,25 +530,25 @@ nv50_disp_core_init(struct nvkm_object *object)
 		return ret;
 
 	/* enable error reporting */
-	nv_mask(disp, 0x610028, 0x00010000, 0x00010000);
+	nvkm_mask(device, 0x610028, 0x00010000, 0x00010000);
 
 	/* attempt to unstick channel from some unknown state */
-	if ((nv_rd32(disp, 0x610200) & 0x009f0000) == 0x00020000)
-		nv_mask(disp, 0x610200, 0x00800000, 0x00800000);
-	if ((nv_rd32(disp, 0x610200) & 0x003f0000) == 0x00030000)
-		nv_mask(disp, 0x610200, 0x00600000, 0x00600000);
+	if ((nvkm_rd32(device, 0x610200) & 0x009f0000) == 0x00020000)
+		nvkm_mask(device, 0x610200, 0x00800000, 0x00800000);
+	if ((nvkm_rd32(device, 0x610200) & 0x003f0000) == 0x00030000)
+		nvkm_mask(device, 0x610200, 0x00600000, 0x00600000);
 
 	/* initialise channel for dma command submission */
-	nv_wr32(disp, 0x610204, mast->push);
-	nv_wr32(disp, 0x610208, 0x00010000);
-	nv_wr32(disp, 0x61020c, 0x00000000);
-	nv_mask(disp, 0x610200, 0x00000010, 0x00000010);
-	nv_wr32(disp, 0x640000, 0x00000000);
-	nv_wr32(disp, 0x610200, 0x01000013);
+	nvkm_wr32(device, 0x610204, mast->push);
+	nvkm_wr32(device, 0x610208, 0x00010000);
+	nvkm_wr32(device, 0x61020c, 0x00000000);
+	nvkm_mask(device, 0x610200, 0x00000010, 0x00000010);
+	nvkm_wr32(device, 0x640000, 0x00000000);
+	nvkm_wr32(device, 0x610200, 0x01000013);
 
 	/* wait for it to go inactive */
 	if (!nv_wait(disp, 0x610200, 0x80000000, 0x00000000)) {
-		nv_error(mast, "init: 0x%08x\n", nv_rd32(disp, 0x610200));
+		nv_error(mast, "init: 0x%08x\n", nvkm_rd32(device, 0x610200));
 		return -EBUSY;
 	}
 
@@ -554,18 +560,19 @@ nv50_disp_core_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_dmac *mast = (void *)object;
+	struct nvkm_device *device = disp->base.engine.subdev.device;
 
 	/* deactivate channel */
-	nv_mask(disp, 0x610200, 0x00000010, 0x00000000);
-	nv_mask(disp, 0x610200, 0x00000003, 0x00000000);
+	nvkm_mask(device, 0x610200, 0x00000010, 0x00000000);
+	nvkm_mask(device, 0x610200, 0x00000003, 0x00000000);
 	if (!nv_wait(disp, 0x610200, 0x001e0000, 0x00000000)) {
-		nv_error(mast, "fini: 0x%08x\n", nv_rd32(disp, 0x610200));
+		nv_error(mast, "fini: 0x%08x\n", nvkm_rd32(device, 0x610200));
 		if (suspend)
 			return -EBUSY;
 	}
 
 	/* disable error reporting and completion notifications */
-	nv_mask(disp, 0x610028, 0x00010001, 0x00000000);
+	nvkm_mask(device, 0x610028, 0x00010001, 0x00000000);
 
 	return nv50_disp_chan_fini(&mast->base, suspend);
 }
@@ -803,6 +810,7 @@ nv50_disp_pioc_init(struct nvkm_object *object)
 {
 	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_pioc *pioc = (void *)object;
+	struct nvkm_device *device = disp->base.engine.subdev.device;
 	int chid = pioc->base.chid;
 	int ret;
 
@@ -810,17 +818,17 @@ nv50_disp_pioc_init(struct nvkm_object *object)
 	if (ret)
 		return ret;
 
-	nv_wr32(disp, 0x610200 + (chid * 0x10), 0x00002000);
+	nvkm_wr32(device, 0x610200 + (chid * 0x10), 0x00002000);
 	if (!nv_wait(disp, 0x610200 + (chid * 0x10), 0x00000000, 0x00000000)) {
 		nv_error(pioc, "timeout0: 0x%08x\n",
-			 nv_rd32(disp, 0x610200 + (chid * 0x10)));
+			 nvkm_rd32(device, 0x610200 + (chid * 0x10)));
 		return -EBUSY;
 	}
 
-	nv_wr32(disp, 0x610200 + (chid * 0x10), 0x00000001);
+	nvkm_wr32(device, 0x610200 + (chid * 0x10), 0x00000001);
 	if (!nv_wait(disp, 0x610200 + (chid * 0x10), 0x00030000, 0x00010000)) {
 		nv_error(pioc, "timeout1: 0x%08x\n",
-			 nv_rd32(disp, 0x610200 + (chid * 0x10)));
+			 nvkm_rd32(device, 0x610200 + (chid * 0x10)));
 		return -EBUSY;
 	}
 
@@ -832,12 +840,13 @@ nv50_disp_pioc_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_pioc *pioc = (void *)object;
+	struct nvkm_device *device = disp->base.engine.subdev.device;
 	int chid = pioc->base.chid;
 
-	nv_mask(disp, 0x610200 + (chid * 0x10), 0x00000001, 0x00000000);
+	nvkm_mask(device, 0x610200 + (chid * 0x10), 0x00000001, 0x00000000);
 	if (!nv_wait(disp, 0x610200 + (chid * 0x10), 0x00030000, 0x00000000)) {
 		nv_error(pioc, "timeout: 0x%08x\n",
-			 nv_rd32(disp, 0x610200 + (chid * 0x10)));
+			 nvkm_rd32(device, 0x610200 + (chid * 0x10)));
 		if (suspend)
 			return -EBUSY;
 	}
@@ -948,9 +957,10 @@ nv50_disp_curs_ofuncs = {
 int
 nv50_disp_main_scanoutpos(NV50_DISP_MTHD_V0)
 {
-	const u32 blanke = nv_rd32(disp, 0x610aec + (head * 0x540));
-	const u32 blanks = nv_rd32(disp, 0x610af4 + (head * 0x540));
-	const u32 total  = nv_rd32(disp, 0x610afc + (head * 0x540));
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	const u32 blanke = nvkm_rd32(device, 0x610aec + (head * 0x540));
+	const u32 blanks = nvkm_rd32(device, 0x610af4 + (head * 0x540));
+	const u32 total  = nvkm_rd32(device, 0x610afc + (head * 0x540));
 	union {
 		struct nv04_disp_scanoutpos_v0 v0;
 	} *args = data;
@@ -967,10 +977,10 @@ nv50_disp_main_scanoutpos(NV50_DISP_MTHD_V0)
 		args->v0.htotal  = ( total & 0x0000ffff);
 		args->v0.time[0] = ktime_to_ns(ktime_get());
 		args->v0.vline = /* vline read locks hline */
-			nv_rd32(disp, 0x616340 + (head * 0x800)) & 0xffff;
+			nvkm_rd32(device, 0x616340 + (head * 0x800)) & 0xffff;
 		args->v0.time[1] = ktime_to_ns(ktime_get());
 		args->v0.hline =
-			nv_rd32(disp, 0x616344 + (head * 0x800)) & 0xffff;
+			nvkm_rd32(device, 0x616344 + (head * 0x800)) & 0xffff;
 	} else
 		return ret;
 
@@ -1133,6 +1143,7 @@ nv50_disp_main_init(struct nvkm_object *object)
 {
 	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_base *base = (void *)object;
+	struct nvkm_device *device = disp->base.engine.subdev.device;
 	int ret, i;
 	u32 tmp;
 
@@ -1144,43 +1155,43 @@ nv50_disp_main_init(struct nvkm_object *object)
 	 * another appear to inform EVO of the display capabilities or
 	 * something similar.  NFI what the 0x614004 caps are for..
 	 */
-	tmp = nv_rd32(disp, 0x614004);
-	nv_wr32(disp, 0x610184, tmp);
+	tmp = nvkm_rd32(device, 0x614004);
+	nvkm_wr32(device, 0x610184, tmp);
 
 	/* ... CRTC caps */
 	for (i = 0; i < disp->head.nr; i++) {
-		tmp = nv_rd32(disp, 0x616100 + (i * 0x800));
-		nv_wr32(disp, 0x610190 + (i * 0x10), tmp);
-		tmp = nv_rd32(disp, 0x616104 + (i * 0x800));
-		nv_wr32(disp, 0x610194 + (i * 0x10), tmp);
-		tmp = nv_rd32(disp, 0x616108 + (i * 0x800));
-		nv_wr32(disp, 0x610198 + (i * 0x10), tmp);
-		tmp = nv_rd32(disp, 0x61610c + (i * 0x800));
-		nv_wr32(disp, 0x61019c + (i * 0x10), tmp);
+		tmp = nvkm_rd32(device, 0x616100 + (i * 0x800));
+		nvkm_wr32(device, 0x610190 + (i * 0x10), tmp);
+		tmp = nvkm_rd32(device, 0x616104 + (i * 0x800));
+		nvkm_wr32(device, 0x610194 + (i * 0x10), tmp);
+		tmp = nvkm_rd32(device, 0x616108 + (i * 0x800));
+		nvkm_wr32(device, 0x610198 + (i * 0x10), tmp);
+		tmp = nvkm_rd32(device, 0x61610c + (i * 0x800));
+		nvkm_wr32(device, 0x61019c + (i * 0x10), tmp);
 	}
 
 	/* ... DAC caps */
 	for (i = 0; i < disp->dac.nr; i++) {
-		tmp = nv_rd32(disp, 0x61a000 + (i * 0x800));
-		nv_wr32(disp, 0x6101d0 + (i * 0x04), tmp);
+		tmp = nvkm_rd32(device, 0x61a000 + (i * 0x800));
+		nvkm_wr32(device, 0x6101d0 + (i * 0x04), tmp);
 	}
 
 	/* ... SOR caps */
 	for (i = 0; i < disp->sor.nr; i++) {
-		tmp = nv_rd32(disp, 0x61c000 + (i * 0x800));
-		nv_wr32(disp, 0x6101e0 + (i * 0x04), tmp);
+		tmp = nvkm_rd32(device, 0x61c000 + (i * 0x800));
+		nvkm_wr32(device, 0x6101e0 + (i * 0x04), tmp);
 	}
 
 	/* ... PIOR caps */
 	for (i = 0; i < disp->pior.nr; i++) {
-		tmp = nv_rd32(disp, 0x61e000 + (i * 0x800));
-		nv_wr32(disp, 0x6101f0 + (i * 0x04), tmp);
+		tmp = nvkm_rd32(device, 0x61e000 + (i * 0x800));
+		nvkm_wr32(device, 0x6101f0 + (i * 0x04), tmp);
 	}
 
 	/* steal display away from vbios, or something like that */
-	if (nv_rd32(disp, 0x610024) & 0x00000100) {
-		nv_wr32(disp, 0x610024, 0x00000100);
-		nv_mask(disp, 0x6194e8, 0x00000001, 0x00000000);
+	if (nvkm_rd32(device, 0x610024) & 0x00000100) {
+		nvkm_wr32(device, 0x610024, 0x00000100);
+		nvkm_mask(device, 0x6194e8, 0x00000001, 0x00000000);
 		if (!nv_wait(disp, 0x6194e8, 0x00000002, 0x00000000)) {
 			nv_error(disp, "timeout acquiring display\n");
 			return -EBUSY;
@@ -1188,11 +1199,11 @@ nv50_disp_main_init(struct nvkm_object *object)
 	}
 
 	/* point at display engine memory area (hash table, objects) */
-	nv_wr32(disp, 0x610010, (nv_gpuobj(base->ramht)->addr >> 8) | 9);
+	nvkm_wr32(device, 0x610010, (nv_gpuobj(base->ramht)->addr >> 8) | 9);
 
 	/* enable supervisor interrupts, disable everything else */
-	nv_wr32(disp, 0x61002c, 0x00000370);
-	nv_wr32(disp, 0x610028, 0x00000000);
+	nvkm_wr32(device, 0x61002c, 0x00000370);
+	nvkm_wr32(device, 0x610028, 0x00000000);
 	return 0;
 }
 
@@ -1201,10 +1212,11 @@ nv50_disp_main_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_base *base = (void *)object;
+	struct nvkm_device *device = disp->base.engine.subdev.device;
 
 	/* disable all interrupts */
-	nv_wr32(disp, 0x610024, 0x00000000);
-	nv_wr32(disp, 0x610020, 0x00000000);
+	nvkm_wr32(device, 0x610024, 0x00000000);
+	nvkm_wr32(device, 0x610020, 0x00000000);
 
 	return nvkm_parent_fini(&base->base, suspend);
 }
@@ -1289,14 +1301,16 @@ static void
 nv50_disp_vblank_fini(struct nvkm_event *event, int type, int head)
 {
 	struct nvkm_disp *disp = container_of(event, typeof(*disp), vblank);
-	nv_mask(disp, 0x61002c, (4 << head), 0);
+	struct nvkm_device *device = disp->engine.subdev.device;
+	nvkm_mask(device, 0x61002c, (4 << head), 0);
 }
 
 static void
 nv50_disp_vblank_init(struct nvkm_event *event, int type, int head)
 {
 	struct nvkm_disp *disp = container_of(event, typeof(*disp), vblank);
-	nv_mask(disp, 0x61002c, (4 << head), (4 << head));
+	struct nvkm_device *device = disp->engine.subdev.device;
+	nvkm_mask(device, 0x61002c, (4 << head), (4 << head));
 }
 
 const struct nvkm_event_func
@@ -1325,8 +1339,9 @@ static void
 nv50_disp_intr_error(struct nv50_disp *disp, int chid)
 {
 	struct nv50_disp_impl *impl = (void *)nv_object(disp)->oclass;
-	u32 data = nv_rd32(disp, 0x610084 + (chid * 0x08));
-	u32 addr = nv_rd32(disp, 0x610080 + (chid * 0x08));
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	u32 data = nvkm_rd32(device, 0x610084 + (chid * 0x08));
+	u32 addr = nvkm_rd32(device, 0x610080 + (chid * 0x08));
 	u32 code = (addr & 0x00ff0000) >> 16;
 	u32 type = (addr & 0x00007000) >> 12;
 	u32 mthd = (addr & 0x00000ffc);
@@ -1376,8 +1391,8 @@ nv50_disp_intr_error(struct nv50_disp *disp, int chid)
 		}
 	}
 
-	nv_wr32(disp, 0x610020, 0x00010000 << chid);
-	nv_wr32(disp, 0x610080 + (chid * 0x08), 0x90000000);
+	nvkm_wr32(device, 0x610020, 0x00010000 << chid);
+	nvkm_wr32(device, 0x610080 + (chid * 0x08), 0x90000000);
 }
 
 static struct nvkm_output *
@@ -1440,7 +1455,8 @@ exec_lookup(struct nv50_disp *disp, int head, int or, u32 ctrl,
 static struct nvkm_output *
 exec_script(struct nv50_disp *disp, int head, int id)
 {
-	struct nvkm_bios *bios = nvkm_bios(disp);
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_bios *bios = device->bios;
 	struct nvkm_output *outp;
 	struct nvbios_outp info;
 	u8  ver, hdr, cnt, len;
@@ -1450,7 +1466,7 @@ exec_script(struct nv50_disp *disp, int head, int id)
 
 	/* DAC */
 	for (i = 0; !(ctrl & (1 << head)) && i < disp->dac.nr; i++)
-		ctrl = nv_rd32(disp, 0x610b5c + (i * 8));
+		ctrl = nvkm_rd32(device, 0x610b5c + (i * 8));
 
 	/* SOR */
 	if (!(ctrl & (1 << head))) {
@@ -1462,14 +1478,14 @@ exec_script(struct nv50_disp *disp, int head, int id)
 			reg = 0x610798;
 		}
 		for (i = 0; !(ctrl & (1 << head)) && i < disp->sor.nr; i++)
-			ctrl = nv_rd32(disp, reg + (i * 8));
+			ctrl = nvkm_rd32(device, reg + (i * 8));
 		i += 4;
 	}
 
 	/* PIOR */
 	if (!(ctrl & (1 << head))) {
 		for (i = 0; !(ctrl & (1 << head)) && i < disp->pior.nr; i++)
-			ctrl = nv_rd32(disp, 0x610b84 + (i * 8));
+			ctrl = nvkm_rd32(device, 0x610b84 + (i * 8));
 		i += 8;
 	}
 
@@ -1497,7 +1513,8 @@ exec_script(struct nv50_disp *disp, int head, int id)
 static struct nvkm_output *
 exec_clkcmp(struct nv50_disp *disp, int head, int id, u32 pclk, u32 *conf)
 {
-	struct nvkm_bios *bios = nvkm_bios(disp);
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_bios *bios = device->bios;
 	struct nvkm_output *outp;
 	struct nvbios_outp info1;
 	struct nvbios_ocfg info2;
@@ -1508,7 +1525,7 @@ exec_clkcmp(struct nv50_disp *disp, int head, int id, u32 pclk, u32 *conf)
 
 	/* DAC */
 	for (i = 0; !(ctrl & (1 << head)) && i < disp->dac.nr; i++)
-		ctrl = nv_rd32(disp, 0x610b58 + (i * 8));
+		ctrl = nvkm_rd32(device, 0x610b58 + (i * 8));
 
 	/* SOR */
 	if (!(ctrl & (1 << head))) {
@@ -1520,14 +1537,14 @@ exec_clkcmp(struct nv50_disp *disp, int head, int id, u32 pclk, u32 *conf)
 			reg = 0x610794;
 		}
 		for (i = 0; !(ctrl & (1 << head)) && i < disp->sor.nr; i++)
-			ctrl = nv_rd32(disp, reg + (i * 8));
+			ctrl = nvkm_rd32(device, reg + (i * 8));
 		i += 4;
 	}
 
 	/* PIOR */
 	if (!(ctrl & (1 << head))) {
 		for (i = 0; !(ctrl & (1 << head)) && i < disp->pior.nr; i++)
-			ctrl = nv_rd32(disp, 0x610b80 + (i * 8));
+			ctrl = nvkm_rd32(device, 0x610b80 + (i * 8));
 		i += 8;
 	}
 
@@ -1625,8 +1642,9 @@ nv50_disp_intr_unk20_0(struct nv50_disp *disp, int head)
 static void
 nv50_disp_intr_unk20_1(struct nv50_disp *disp, int head)
 {
-	struct nvkm_devinit *devinit = nvkm_devinit(disp);
-	u32 pclk = nv_rd32(disp, 0x610ad0 + (head * 0x540)) & 0x3fffff;
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_devinit *devinit = device->devinit;
+	u32 pclk = nvkm_rd32(device, 0x610ad0 + (head * 0x540)) & 0x3fffff;
 	if (pclk)
 		devinit->pll_set(devinit, PLL_VPLL0 + head, pclk);
 }
@@ -1635,17 +1653,18 @@ static void
 nv50_disp_intr_unk20_2_dp(struct nv50_disp *disp, int head,
 			  struct dcb_output *outp, u32 pclk)
 {
+	struct nvkm_device *device = disp->base.engine.subdev.device;
 	const int link = !(outp->sorconf.link & 1);
 	const int   or = ffs(outp->or) - 1;
 	const u32 soff = (  or * 0x800);
 	const u32 loff = (link * 0x080) + soff;
-	const u32 ctrl = nv_rd32(disp, 0x610794 + (or * 8));
+	const u32 ctrl = nvkm_rd32(device, 0x610794 + (or * 8));
 	const u32 symbol = 100000;
-	const s32 vactive = nv_rd32(disp, 0x610af8 + (head * 0x540)) & 0xffff;
-	const s32 vblanke = nv_rd32(disp, 0x610ae8 + (head * 0x540)) & 0xffff;
-	const s32 vblanks = nv_rd32(disp, 0x610af0 + (head * 0x540)) & 0xffff;
-	u32 dpctrl = nv_rd32(disp, 0x61c10c + loff);
-	u32 clksor = nv_rd32(disp, 0x614300 + soff);
+	const s32 vactive = nvkm_rd32(device, 0x610af8 + (head * 0x540)) & 0xffff;
+	const s32 vblanke = nvkm_rd32(device, 0x610ae8 + (head * 0x540)) & 0xffff;
+	const s32 vblanks = nvkm_rd32(device, 0x610af0 + (head * 0x540)) & 0xffff;
+	u32 dpctrl = nvkm_rd32(device, 0x61c10c + loff);
+	u32 clksor = nvkm_rd32(device, 0x614300 + soff);
 	int bestTU = 0, bestVTUi = 0, bestVTUf = 0, bestVTUa = 0;
 	int TU, VTUi, VTUf, VTUa;
 	u64 link_data_rate, link_ratio, unk;
@@ -1661,14 +1680,14 @@ nv50_disp_intr_unk20_2_dp(struct nv50_disp *disp, int head,
 	value = value * link_bw;
 	do_div(value, pclk);
 	value = value - (3 * !!(dpctrl & 0x00004000)) - (12 / link_nr);
-	nv_mask(disp, 0x61c1e8 + soff, 0x0000ffff, value);
+	nvkm_mask(device, 0x61c1e8 + soff, 0x0000ffff, value);
 
 	/* symbols/vblank - algorithm taken from comments in tegra driver */
 	value = vblanks - vblanke - 25;
 	value = value * link_bw;
 	do_div(value, pclk);
 	value = value - ((36 / link_nr) + 3) - 1;
-	nv_mask(disp, 0x61c1ec + soff, 0x00ffffff, value);
+	nvkm_mask(device, 0x61c1ec + soff, 0x00ffffff, value);
 
 	/* watermark / activesym */
 	if      ((ctrl & 0xf0000) == 0x60000) bits = 30;
@@ -1744,8 +1763,8 @@ nv50_disp_intr_unk20_2_dp(struct nv50_disp *disp, int head,
 	do_div(unk, symbol);
 	unk += 6;
 
-	nv_mask(disp, 0x61c10c + loff, 0x000001fc, bestTU << 2);
-	nv_mask(disp, 0x61c128 + loff, 0x010f7f3f, bestVTUa << 24 |
+	nvkm_mask(device, 0x61c10c + loff, 0x000001fc, bestTU << 2);
+	nvkm_mask(device, 0x61c128 + loff, 0x010f7f3f, bestVTUa << 24 |
 						   bestVTUf << 16 |
 						   bestVTUi << 8 | unk);
 }
@@ -1753,8 +1772,9 @@ nv50_disp_intr_unk20_2_dp(struct nv50_disp *disp, int head,
 static void
 nv50_disp_intr_unk20_2(struct nv50_disp *disp, int head)
 {
+	struct nvkm_device *device = disp->base.engine.subdev.device;
 	struct nvkm_output *outp;
-	u32 pclk = nv_rd32(disp, 0x610ad0 + (head * 0x540)) & 0x3fffff;
+	u32 pclk = nvkm_rd32(device, 0x610ad0 + (head * 0x540)) & 0x3fffff;
 	u32 hval, hreg = 0x614200 + (head * 0x800);
 	u32 oval, oreg;
 	u32 mask, conf;
@@ -1786,10 +1806,10 @@ nv50_disp_intr_unk20_2(struct nv50_disp *disp, int head)
 		u32 ctrl, datarate;
 
 		if (outp->info.location == 0) {
-			ctrl = nv_rd32(disp, 0x610794 + soff);
+			ctrl = nvkm_rd32(device, 0x610794 + soff);
 			soff = 1;
 		} else {
-			ctrl = nv_rd32(disp, 0x610b80 + soff);
+			ctrl = nvkm_rd32(device, 0x610b80 + soff);
 			soff = 2;
 		}
 
@@ -1828,8 +1848,8 @@ nv50_disp_intr_unk20_2(struct nv50_disp *disp, int head)
 		mask = 0x00000707;
 	}
 
-	nv_mask(disp, hreg, 0x0000000f, hval);
-	nv_mask(disp, oreg, mask, oval);
+	nvkm_mask(device, hreg, 0x0000000f, hval);
+	nvkm_mask(device, oreg, mask, oval);
 }
 
 /* If programming a TMDS output on a SOR that can also be configured for
@@ -1844,7 +1864,8 @@ static void
 nv50_disp_intr_unk40_0_tmds(struct nv50_disp *disp,
 			    struct dcb_output *outp)
 {
-	struct nvkm_bios *bios = nvkm_bios(disp);
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_bios *bios = device->bios;
 	const int link = !(outp->sorconf.link & 1);
 	const int   or = ffs(outp->or) - 1;
 	const u32 loff = (or * 0x800) + (link * 0x80);
@@ -1853,14 +1874,15 @@ nv50_disp_intr_unk40_0_tmds(struct nv50_disp *disp,
 	u8  ver, hdr;
 
 	if (dcb_outp_match(bios, DCB_OUTPUT_DP, mask, &ver, &hdr, &match))
-		nv_mask(disp, 0x61c10c + loff, 0x00000001, 0x00000000);
+		nvkm_mask(device, 0x61c10c + loff, 0x00000001, 0x00000000);
 }
 
 static void
 nv50_disp_intr_unk40_0(struct nv50_disp *disp, int head)
 {
+	struct nvkm_device *device = disp->base.engine.subdev.device;
 	struct nvkm_output *outp;
-	u32 pclk = nv_rd32(disp, 0x610ad0 + (head * 0x540)) & 0x3fffff;
+	u32 pclk = nvkm_rd32(device, 0x610ad0 + (head * 0x540)) & 0x3fffff;
 	u32 conf;
 
 	outp = exec_clkcmp(disp, head, 1, pclk, &conf);
@@ -1877,7 +1899,8 @@ nv50_disp_intr_supervisor(struct work_struct *work)
 	struct nv50_disp *disp =
 		container_of(work, struct nv50_disp, supervisor);
 	struct nv50_disp_impl *impl = (void *)nv_object(disp)->oclass;
-	u32 super = nv_rd32(disp, 0x610030);
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	u32 super = nvkm_rd32(device, 0x610030);
 	int head;
 
 	nv_debug(disp, "supervisor 0x%08x 0x%08x\n", disp->super, super);
@@ -1917,15 +1940,16 @@ nv50_disp_intr_supervisor(struct work_struct *work)
 		}
 	}
 
-	nv_wr32(disp, 0x610030, 0x80000000);
+	nvkm_wr32(device, 0x610030, 0x80000000);
 }
 
 void
 nv50_disp_intr(struct nvkm_subdev *subdev)
 {
 	struct nv50_disp *disp = (void *)subdev;
-	u32 intr0 = nv_rd32(disp, 0x610020);
-	u32 intr1 = nv_rd32(disp, 0x610024);
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	u32 intr0 = nvkm_rd32(device, 0x610020);
+	u32 intr1 = nvkm_rd32(device, 0x610024);
 
 	while (intr0 & 0x001f0000) {
 		u32 chid = __ffs(intr0 & 0x001f0000) - 16;
@@ -1941,18 +1965,18 @@ nv50_disp_intr(struct nvkm_subdev *subdev)
 
 	if (intr1 & 0x00000004) {
 		nvkm_disp_vblank(&disp->base, 0);
-		nv_wr32(disp, 0x610024, 0x00000004);
+		nvkm_wr32(device, 0x610024, 0x00000004);
 	}
 
 	if (intr1 & 0x00000008) {
 		nvkm_disp_vblank(&disp->base, 1);
-		nv_wr32(disp, 0x610024, 0x00000008);
+		nvkm_wr32(device, 0x610024, 0x00000008);
 	}
 
 	if (intr1 & 0x00000070) {
 		disp->super = (intr1 & 0x00000070);
 		schedule_work(&disp->supervisor);
-		nv_wr32(disp, 0x610024, disp->super);
+		nvkm_wr32(device, 0x610024, disp->super);
 	}
 }
 

commit fd166a1832db138f22ad95eacd0879af30742f57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/disp: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 25fcabcb1d6c..9551cfe5622a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -88,26 +88,26 @@ nv50_disp_chan_destroy(struct nv50_disp_chan *chan)
 static void
 nv50_disp_chan_uevent_fini(struct nvkm_event *event, int type, int index)
 {
-	struct nv50_disp_priv *priv = container_of(event, typeof(*priv), uevent);
-	nv_mask(priv, 0x610028, 0x00000001 << index, 0x00000000 << index);
-	nv_wr32(priv, 0x610020, 0x00000001 << index);
+	struct nv50_disp *disp = container_of(event, typeof(*disp), uevent);
+	nv_mask(disp, 0x610028, 0x00000001 << index, 0x00000000 << index);
+	nv_wr32(disp, 0x610020, 0x00000001 << index);
 }
 
 static void
 nv50_disp_chan_uevent_init(struct nvkm_event *event, int types, int index)
 {
-	struct nv50_disp_priv *priv = container_of(event, typeof(*priv), uevent);
-	nv_wr32(priv, 0x610020, 0x00000001 << index);
-	nv_mask(priv, 0x610028, 0x00000001 << index, 0x00000001 << index);
+	struct nv50_disp *disp = container_of(event, typeof(*disp), uevent);
+	nv_wr32(disp, 0x610020, 0x00000001 << index);
+	nv_mask(disp, 0x610028, 0x00000001 << index, 0x00000001 << index);
 }
 
 void
-nv50_disp_chan_uevent_send(struct nv50_disp_priv *priv, int chid)
+nv50_disp_chan_uevent_send(struct nv50_disp *disp, int chid)
 {
 	struct nvif_notify_uevent_rep {
 	} rep;
 
-	nvkm_event_send(&priv->uevent, 1, chid, &rep, sizeof(rep));
+	nvkm_event_send(&disp->uevent, 1, chid, &rep, sizeof(rep));
 }
 
 int
@@ -141,10 +141,10 @@ int
 nv50_disp_chan_ntfy(struct nvkm_object *object, u32 type,
 		    struct nvkm_event **pevent)
 {
-	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp *disp = (void *)object->engine;
 	switch (type) {
 	case NV50_DISP_CORE_CHANNEL_DMA_V0_NTFY_UEVENT:
-		*pevent = &priv->uevent;
+		*pevent = &disp->uevent;
 		return 0;
 	default:
 		break;
@@ -165,17 +165,17 @@ nv50_disp_chan_map(struct nvkm_object *object, u64 *addr, u32 *size)
 u32
 nv50_disp_chan_rd32(struct nvkm_object *object, u64 addr)
 {
-	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_chan *chan = (void *)object;
-	return nv_rd32(priv, 0x640000 + (chan->chid * 0x1000) + addr);
+	return nv_rd32(disp, 0x640000 + (chan->chid * 0x1000) + addr);
 }
 
 void
 nv50_disp_chan_wr32(struct nvkm_object *object, u64 addr, u32 data)
 {
-	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_chan *chan = (void *)object;
-	nv_wr32(priv, 0x640000 + (chan->chid * 0x1000) + addr, data);
+	nv_wr32(disp, 0x640000 + (chan->chid * 0x1000) + addr, data);
 }
 
 /*******************************************************************************
@@ -255,7 +255,7 @@ nv50_disp_dmac_dtor(struct nvkm_object *object)
 static int
 nv50_disp_dmac_init(struct nvkm_object *object)
 {
-	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_dmac *dmac = (void *)object;
 	int chid = dmac->base.chid;
 	int ret;
@@ -265,20 +265,20 @@ nv50_disp_dmac_init(struct nvkm_object *object)
 		return ret;
 
 	/* enable error reporting */
-	nv_mask(priv, 0x610028, 0x00010000 << chid, 0x00010000 << chid);
+	nv_mask(disp, 0x610028, 0x00010000 << chid, 0x00010000 << chid);
 
 	/* initialise channel for dma command submission */
-	nv_wr32(priv, 0x610204 + (chid * 0x0010), dmac->push);
-	nv_wr32(priv, 0x610208 + (chid * 0x0010), 0x00010000);
-	nv_wr32(priv, 0x61020c + (chid * 0x0010), chid);
-	nv_mask(priv, 0x610200 + (chid * 0x0010), 0x00000010, 0x00000010);
-	nv_wr32(priv, 0x640000 + (chid * 0x1000), 0x00000000);
-	nv_wr32(priv, 0x610200 + (chid * 0x0010), 0x00000013);
+	nv_wr32(disp, 0x610204 + (chid * 0x0010), dmac->push);
+	nv_wr32(disp, 0x610208 + (chid * 0x0010), 0x00010000);
+	nv_wr32(disp, 0x61020c + (chid * 0x0010), chid);
+	nv_mask(disp, 0x610200 + (chid * 0x0010), 0x00000010, 0x00000010);
+	nv_wr32(disp, 0x640000 + (chid * 0x1000), 0x00000000);
+	nv_wr32(disp, 0x610200 + (chid * 0x0010), 0x00000013);
 
 	/* wait for it to go inactive */
-	if (!nv_wait(priv, 0x610200 + (chid * 0x10), 0x80000000, 0x00000000)) {
+	if (!nv_wait(disp, 0x610200 + (chid * 0x10), 0x80000000, 0x00000000)) {
 		nv_error(dmac, "init timeout, 0x%08x\n",
-			 nv_rd32(priv, 0x610200 + (chid * 0x10)));
+			 nv_rd32(disp, 0x610200 + (chid * 0x10)));
 		return -EBUSY;
 	}
 
@@ -288,22 +288,22 @@ nv50_disp_dmac_init(struct nvkm_object *object)
 static int
 nv50_disp_dmac_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_dmac *dmac = (void *)object;
 	int chid = dmac->base.chid;
 
 	/* deactivate channel */
-	nv_mask(priv, 0x610200 + (chid * 0x0010), 0x00001010, 0x00001000);
-	nv_mask(priv, 0x610200 + (chid * 0x0010), 0x00000003, 0x00000000);
-	if (!nv_wait(priv, 0x610200 + (chid * 0x10), 0x001e0000, 0x00000000)) {
+	nv_mask(disp, 0x610200 + (chid * 0x0010), 0x00001010, 0x00001000);
+	nv_mask(disp, 0x610200 + (chid * 0x0010), 0x00000003, 0x00000000);
+	if (!nv_wait(disp, 0x610200 + (chid * 0x10), 0x001e0000, 0x00000000)) {
 		nv_error(dmac, "fini timeout, 0x%08x\n",
-			 nv_rd32(priv, 0x610200 + (chid * 0x10)));
+			 nv_rd32(disp, 0x610200 + (chid * 0x10)));
 		if (suspend)
 			return -EBUSY;
 	}
 
 	/* disable error reporting and completion notifications */
-	nv_mask(priv, 0x610028, 0x00010001 << chid, 0x00000000 << chid);
+	nv_mask(disp, 0x610028, 0x00010001 << chid, 0x00000000 << chid);
 
 	return nv50_disp_chan_fini(&dmac->base, suspend);
 }
@@ -313,16 +313,16 @@ nv50_disp_dmac_fini(struct nvkm_object *object, bool suspend)
  ******************************************************************************/
 
 static void
-nv50_disp_mthd_list(struct nv50_disp_priv *priv, int debug, u32 base, int c,
+nv50_disp_mthd_list(struct nv50_disp *disp, int debug, u32 base, int c,
 		    const struct nv50_disp_mthd_list *list, int inst)
 {
-	struct nvkm_object *disp = nv_object(priv);
+	struct nvkm_object *object = nv_object(disp);
 	int i;
 
 	for (i = 0; list->data[i].mthd; i++) {
 		if (list->data[i].addr) {
-			u32 next = nv_rd32(priv, list->data[i].addr + base + 0);
-			u32 prev = nv_rd32(priv, list->data[i].addr + base + c);
+			u32 next = nv_rd32(disp, list->data[i].addr + base + 0);
+			u32 prev = nv_rd32(disp, list->data[i].addr + base + c);
 			u32 mthd = list->data[i].mthd + (list->mthd * inst);
 			const char *name = list->data[i].name;
 			char mods[16];
@@ -332,7 +332,7 @@ nv50_disp_mthd_list(struct nv50_disp_priv *priv, int debug, u32 base, int c,
 			else
 				snprintf(mods, sizeof(mods), "%13c", ' ');
 
-			nv_printk_(disp, debug, "\t0x%04x: 0x%08x %s%s%s\n",
+			nv_printk_(object, debug, "\t0x%04x: 0x%08x %s%s%s\n",
 				   mthd, prev, mods, name ? " // " : "",
 				   name ? name : "");
 		}
@@ -340,15 +340,15 @@ nv50_disp_mthd_list(struct nv50_disp_priv *priv, int debug, u32 base, int c,
 }
 
 void
-nv50_disp_mthd_chan(struct nv50_disp_priv *priv, int debug, int head,
+nv50_disp_mthd_chan(struct nv50_disp *disp, int debug, int head,
 		    const struct nv50_disp_mthd_chan *chan)
 {
-	struct nvkm_object *disp = nv_object(priv);
-	const struct nv50_disp_impl *impl = (void *)disp->oclass;
+	struct nvkm_object *object = nv_object(disp);
+	const struct nv50_disp_impl *impl = (void *)object->oclass;
 	const struct nv50_disp_mthd_list *list;
 	int i, j;
 
-	if (debug > nv_subdev(priv)->debug)
+	if (debug > nv_subdev(disp)->debug)
 		return;
 
 	for (i = 0; (list = chan->data[i].mthd) != NULL; i++) {
@@ -370,8 +370,8 @@ nv50_disp_mthd_chan(struct nv50_disp_priv *priv, int debug, int head,
 				sname = sname_;
 			}
 
-			nv_printk_(disp, debug, "%s%s:\n", cname, sname);
-			nv50_disp_mthd_list(priv, debug, base, impl->mthd.prev,
+			nv_printk_(object, debug, "%s%s:\n", cname, sname);
+			nv50_disp_mthd_list(disp, debug, base, impl->mthd.prev,
 					    list, j);
 		}
 	}
@@ -515,7 +515,7 @@ nv50_disp_core_ctor(struct nvkm_object *parent,
 static int
 nv50_disp_core_init(struct nvkm_object *object)
 {
-	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_dmac *mast = (void *)object;
 	int ret;
 
@@ -524,25 +524,25 @@ nv50_disp_core_init(struct nvkm_object *object)
 		return ret;
 
 	/* enable error reporting */
-	nv_mask(priv, 0x610028, 0x00010000, 0x00010000);
+	nv_mask(disp, 0x610028, 0x00010000, 0x00010000);
 
 	/* attempt to unstick channel from some unknown state */
-	if ((nv_rd32(priv, 0x610200) & 0x009f0000) == 0x00020000)
-		nv_mask(priv, 0x610200, 0x00800000, 0x00800000);
-	if ((nv_rd32(priv, 0x610200) & 0x003f0000) == 0x00030000)
-		nv_mask(priv, 0x610200, 0x00600000, 0x00600000);
+	if ((nv_rd32(disp, 0x610200) & 0x009f0000) == 0x00020000)
+		nv_mask(disp, 0x610200, 0x00800000, 0x00800000);
+	if ((nv_rd32(disp, 0x610200) & 0x003f0000) == 0x00030000)
+		nv_mask(disp, 0x610200, 0x00600000, 0x00600000);
 
 	/* initialise channel for dma command submission */
-	nv_wr32(priv, 0x610204, mast->push);
-	nv_wr32(priv, 0x610208, 0x00010000);
-	nv_wr32(priv, 0x61020c, 0x00000000);
-	nv_mask(priv, 0x610200, 0x00000010, 0x00000010);
-	nv_wr32(priv, 0x640000, 0x00000000);
-	nv_wr32(priv, 0x610200, 0x01000013);
+	nv_wr32(disp, 0x610204, mast->push);
+	nv_wr32(disp, 0x610208, 0x00010000);
+	nv_wr32(disp, 0x61020c, 0x00000000);
+	nv_mask(disp, 0x610200, 0x00000010, 0x00000010);
+	nv_wr32(disp, 0x640000, 0x00000000);
+	nv_wr32(disp, 0x610200, 0x01000013);
 
 	/* wait for it to go inactive */
-	if (!nv_wait(priv, 0x610200, 0x80000000, 0x00000000)) {
-		nv_error(mast, "init: 0x%08x\n", nv_rd32(priv, 0x610200));
+	if (!nv_wait(disp, 0x610200, 0x80000000, 0x00000000)) {
+		nv_error(mast, "init: 0x%08x\n", nv_rd32(disp, 0x610200));
 		return -EBUSY;
 	}
 
@@ -552,20 +552,20 @@ nv50_disp_core_init(struct nvkm_object *object)
 static int
 nv50_disp_core_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_dmac *mast = (void *)object;
 
 	/* deactivate channel */
-	nv_mask(priv, 0x610200, 0x00000010, 0x00000000);
-	nv_mask(priv, 0x610200, 0x00000003, 0x00000000);
-	if (!nv_wait(priv, 0x610200, 0x001e0000, 0x00000000)) {
-		nv_error(mast, "fini: 0x%08x\n", nv_rd32(priv, 0x610200));
+	nv_mask(disp, 0x610200, 0x00000010, 0x00000000);
+	nv_mask(disp, 0x610200, 0x00000003, 0x00000000);
+	if (!nv_wait(disp, 0x610200, 0x001e0000, 0x00000000)) {
+		nv_error(mast, "fini: 0x%08x\n", nv_rd32(disp, 0x610200));
 		if (suspend)
 			return -EBUSY;
 	}
 
 	/* disable error reporting and completion notifications */
-	nv_mask(priv, 0x610028, 0x00010001, 0x00000000);
+	nv_mask(disp, 0x610028, 0x00010001, 0x00000000);
 
 	return nv50_disp_chan_fini(&mast->base, suspend);
 }
@@ -648,7 +648,7 @@ nv50_disp_base_ctor(struct nvkm_object *parent,
 	union {
 		struct nv50_disp_base_channel_dma_v0 v0;
 	} *args = data;
-	struct nv50_disp_priv *priv = (void *)engine;
+	struct nv50_disp *disp = (void *)engine;
 	struct nv50_disp_dmac *dmac;
 	int ret;
 
@@ -657,7 +657,7 @@ nv50_disp_base_ctor(struct nvkm_object *parent,
 		nv_ioctl(parent, "create disp base channel dma vers %d "
 				 "pushbuf %08x head %d\n",
 			 args->v0.version, args->v0.pushbuf, args->v0.head);
-		if (args->v0.head > priv->head.nr)
+		if (args->v0.head > disp->head.nr)
 			return -EINVAL;
 	} else
 		return ret;
@@ -738,7 +738,7 @@ nv50_disp_ovly_ctor(struct nvkm_object *parent,
 	union {
 		struct nv50_disp_overlay_channel_dma_v0 v0;
 	} *args = data;
-	struct nv50_disp_priv *priv = (void *)engine;
+	struct nv50_disp *disp = (void *)engine;
 	struct nv50_disp_dmac *dmac;
 	int ret;
 
@@ -747,7 +747,7 @@ nv50_disp_ovly_ctor(struct nvkm_object *parent,
 		nv_ioctl(parent, "create disp overlay channel dma vers %d "
 				 "pushbuf %08x head %d\n",
 			 args->v0.version, args->v0.pushbuf, args->v0.head);
-		if (args->v0.head > priv->head.nr)
+		if (args->v0.head > disp->head.nr)
 			return -EINVAL;
 	} else
 		return ret;
@@ -801,7 +801,7 @@ nv50_disp_pioc_dtor(struct nvkm_object *object)
 static int
 nv50_disp_pioc_init(struct nvkm_object *object)
 {
-	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_pioc *pioc = (void *)object;
 	int chid = pioc->base.chid;
 	int ret;
@@ -810,17 +810,17 @@ nv50_disp_pioc_init(struct nvkm_object *object)
 	if (ret)
 		return ret;
 
-	nv_wr32(priv, 0x610200 + (chid * 0x10), 0x00002000);
-	if (!nv_wait(priv, 0x610200 + (chid * 0x10), 0x00000000, 0x00000000)) {
+	nv_wr32(disp, 0x610200 + (chid * 0x10), 0x00002000);
+	if (!nv_wait(disp, 0x610200 + (chid * 0x10), 0x00000000, 0x00000000)) {
 		nv_error(pioc, "timeout0: 0x%08x\n",
-			 nv_rd32(priv, 0x610200 + (chid * 0x10)));
+			 nv_rd32(disp, 0x610200 + (chid * 0x10)));
 		return -EBUSY;
 	}
 
-	nv_wr32(priv, 0x610200 + (chid * 0x10), 0x00000001);
-	if (!nv_wait(priv, 0x610200 + (chid * 0x10), 0x00030000, 0x00010000)) {
+	nv_wr32(disp, 0x610200 + (chid * 0x10), 0x00000001);
+	if (!nv_wait(disp, 0x610200 + (chid * 0x10), 0x00030000, 0x00010000)) {
 		nv_error(pioc, "timeout1: 0x%08x\n",
-			 nv_rd32(priv, 0x610200 + (chid * 0x10)));
+			 nv_rd32(disp, 0x610200 + (chid * 0x10)));
 		return -EBUSY;
 	}
 
@@ -830,14 +830,14 @@ nv50_disp_pioc_init(struct nvkm_object *object)
 static int
 nv50_disp_pioc_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_pioc *pioc = (void *)object;
 	int chid = pioc->base.chid;
 
-	nv_mask(priv, 0x610200 + (chid * 0x10), 0x00000001, 0x00000000);
-	if (!nv_wait(priv, 0x610200 + (chid * 0x10), 0x00030000, 0x00000000)) {
+	nv_mask(disp, 0x610200 + (chid * 0x10), 0x00000001, 0x00000000);
+	if (!nv_wait(disp, 0x610200 + (chid * 0x10), 0x00030000, 0x00000000)) {
 		nv_error(pioc, "timeout: 0x%08x\n",
-			 nv_rd32(priv, 0x610200 + (chid * 0x10)));
+			 nv_rd32(disp, 0x610200 + (chid * 0x10)));
 		if (suspend)
 			return -EBUSY;
 	}
@@ -858,7 +858,7 @@ nv50_disp_oimm_ctor(struct nvkm_object *parent,
 	union {
 		struct nv50_disp_overlay_v0 v0;
 	} *args = data;
-	struct nv50_disp_priv *priv = (void *)engine;
+	struct nv50_disp *disp = (void *)engine;
 	struct nv50_disp_pioc *pioc;
 	int ret;
 
@@ -866,7 +866,7 @@ nv50_disp_oimm_ctor(struct nvkm_object *parent,
 	if (nvif_unpack(args->v0, 0, 0, false)) {
 		nv_ioctl(parent, "create disp overlay vers %d head %d\n",
 			 args->v0.version, args->v0.head);
-		if (args->v0.head > priv->head.nr)
+		if (args->v0.head > disp->head.nr)
 			return -EINVAL;
 	} else
 		return ret;
@@ -906,7 +906,7 @@ nv50_disp_curs_ctor(struct nvkm_object *parent,
 	union {
 		struct nv50_disp_cursor_v0 v0;
 	} *args = data;
-	struct nv50_disp_priv *priv = (void *)engine;
+	struct nv50_disp *disp = (void *)engine;
 	struct nv50_disp_pioc *pioc;
 	int ret;
 
@@ -914,7 +914,7 @@ nv50_disp_curs_ctor(struct nvkm_object *parent,
 	if (nvif_unpack(args->v0, 0, 0, false)) {
 		nv_ioctl(parent, "create disp cursor vers %d head %d\n",
 			 args->v0.version, args->v0.head);
-		if (args->v0.head > priv->head.nr)
+		if (args->v0.head > disp->head.nr)
 			return -EINVAL;
 	} else
 		return ret;
@@ -948,9 +948,9 @@ nv50_disp_curs_ofuncs = {
 int
 nv50_disp_main_scanoutpos(NV50_DISP_MTHD_V0)
 {
-	const u32 blanke = nv_rd32(priv, 0x610aec + (head * 0x540));
-	const u32 blanks = nv_rd32(priv, 0x610af4 + (head * 0x540));
-	const u32 total  = nv_rd32(priv, 0x610afc + (head * 0x540));
+	const u32 blanke = nv_rd32(disp, 0x610aec + (head * 0x540));
+	const u32 blanks = nv_rd32(disp, 0x610af4 + (head * 0x540));
+	const u32 total  = nv_rd32(disp, 0x610afc + (head * 0x540));
 	union {
 		struct nv04_disp_scanoutpos_v0 v0;
 	} *args = data;
@@ -967,10 +967,10 @@ nv50_disp_main_scanoutpos(NV50_DISP_MTHD_V0)
 		args->v0.htotal  = ( total & 0x0000ffff);
 		args->v0.time[0] = ktime_to_ns(ktime_get());
 		args->v0.vline = /* vline read locks hline */
-			nv_rd32(priv, 0x616340 + (head * 0x800)) & 0xffff;
+			nv_rd32(disp, 0x616340 + (head * 0x800)) & 0xffff;
 		args->v0.time[1] = ktime_to_ns(ktime_get());
 		args->v0.hline =
-			nv_rd32(priv, 0x616344 + (head * 0x800)) & 0xffff;
+			nv_rd32(disp, 0x616344 + (head * 0x800)) & 0xffff;
 	} else
 		return ret;
 
@@ -985,7 +985,7 @@ nv50_disp_main_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 		struct nv50_disp_mthd_v0 v0;
 		struct nv50_disp_mthd_v1 v1;
 	} *args = data;
-	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp *disp = (void *)object->engine;
 	struct nvkm_output *outp = NULL;
 	struct nvkm_output *temp;
 	u16 type, mask = 0;
@@ -1013,11 +1013,11 @@ nv50_disp_main_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	} else
 		return ret;
 
-	if (head < 0 || head >= priv->head.nr)
+	if (head < 0 || head >= disp->head.nr)
 		return -ENXIO;
 
 	if (mask) {
-		list_for_each_entry(temp, &priv->base.outp, head) {
+		list_for_each_entry(temp, &disp->base.outp, head) {
 			if ((temp->info.hasht         == type) &&
 			    (temp->info.hashm & mask) == mask) {
 				outp = temp;
@@ -1030,26 +1030,26 @@ nv50_disp_main_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 
 	switch (mthd) {
 	case NV50_DISP_SCANOUTPOS:
-		return impl->head.scanoutpos(object, priv, data, size, head);
+		return impl->head.scanoutpos(object, disp, data, size, head);
 	default:
 		break;
 	}
 
 	switch (mthd * !!outp) {
 	case NV50_DISP_MTHD_V1_DAC_PWR:
-		return priv->dac.power(object, priv, data, size, head, outp);
+		return disp->dac.power(object, disp, data, size, head, outp);
 	case NV50_DISP_MTHD_V1_DAC_LOAD:
-		return priv->dac.sense(object, priv, data, size, head, outp);
+		return disp->dac.sense(object, disp, data, size, head, outp);
 	case NV50_DISP_MTHD_V1_SOR_PWR:
-		return priv->sor.power(object, priv, data, size, head, outp);
+		return disp->sor.power(object, disp, data, size, head, outp);
 	case NV50_DISP_MTHD_V1_SOR_HDA_ELD:
-		if (!priv->sor.hda_eld)
+		if (!disp->sor.hda_eld)
 			return -ENODEV;
-		return priv->sor.hda_eld(object, priv, data, size, head, outp);
+		return disp->sor.hda_eld(object, disp, data, size, head, outp);
 	case NV50_DISP_MTHD_V1_SOR_HDMI_PWR:
-		if (!priv->sor.hdmi)
+		if (!disp->sor.hdmi)
 			return -ENODEV;
-		return priv->sor.hdmi(object, priv, data, size, head, outp);
+		return disp->sor.hdmi(object, disp, data, size, head, outp);
 	case NV50_DISP_MTHD_V1_SOR_LVDS_SCRIPT: {
 		union {
 			struct nv50_disp_sor_lvds_script_v0 v0;
@@ -1059,7 +1059,7 @@ nv50_disp_main_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 			nv_ioctl(object, "disp sor lvds script "
 					 "vers %d name %04x\n",
 				 args->v0.version, args->v0.script);
-			priv->sor.lvdsconf = args->v0.script;
+			disp->sor.lvdsconf = args->v0.script;
 			return 0;
 		} else
 			return ret;
@@ -1090,9 +1090,9 @@ nv50_disp_main_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	}
 		break;
 	case NV50_DISP_MTHD_V1_PIOR_PWR:
-		if (!priv->pior.power)
+		if (!disp->pior.power)
 			return -ENODEV;
-		return priv->pior.power(object, priv, data, size, head, outp);
+		return disp->pior.power(object, disp, data, size, head, outp);
 	default:
 		break;
 	}
@@ -1106,12 +1106,12 @@ nv50_disp_main_ctor(struct nvkm_object *parent,
 		    struct nvkm_oclass *oclass, void *data, u32 size,
 		    struct nvkm_object **pobject)
 {
-	struct nv50_disp_priv *priv = (void *)engine;
+	struct nv50_disp *disp = (void *)engine;
 	struct nv50_disp_base *base;
 	int ret;
 
 	ret = nvkm_parent_create(parent, engine, oclass, 0,
-				 priv->sclass, 0, &base);
+				 disp->sclass, 0, &base);
 	*pobject = nv_object(base);
 	if (ret)
 		return ret;
@@ -1131,7 +1131,7 @@ nv50_disp_main_dtor(struct nvkm_object *object)
 static int
 nv50_disp_main_init(struct nvkm_object *object)
 {
-	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_base *base = (void *)object;
 	int ret, i;
 	u32 tmp;
@@ -1144,67 +1144,67 @@ nv50_disp_main_init(struct nvkm_object *object)
 	 * another appear to inform EVO of the display capabilities or
 	 * something similar.  NFI what the 0x614004 caps are for..
 	 */
-	tmp = nv_rd32(priv, 0x614004);
-	nv_wr32(priv, 0x610184, tmp);
+	tmp = nv_rd32(disp, 0x614004);
+	nv_wr32(disp, 0x610184, tmp);
 
 	/* ... CRTC caps */
-	for (i = 0; i < priv->head.nr; i++) {
-		tmp = nv_rd32(priv, 0x616100 + (i * 0x800));
-		nv_wr32(priv, 0x610190 + (i * 0x10), tmp);
-		tmp = nv_rd32(priv, 0x616104 + (i * 0x800));
-		nv_wr32(priv, 0x610194 + (i * 0x10), tmp);
-		tmp = nv_rd32(priv, 0x616108 + (i * 0x800));
-		nv_wr32(priv, 0x610198 + (i * 0x10), tmp);
-		tmp = nv_rd32(priv, 0x61610c + (i * 0x800));
-		nv_wr32(priv, 0x61019c + (i * 0x10), tmp);
+	for (i = 0; i < disp->head.nr; i++) {
+		tmp = nv_rd32(disp, 0x616100 + (i * 0x800));
+		nv_wr32(disp, 0x610190 + (i * 0x10), tmp);
+		tmp = nv_rd32(disp, 0x616104 + (i * 0x800));
+		nv_wr32(disp, 0x610194 + (i * 0x10), tmp);
+		tmp = nv_rd32(disp, 0x616108 + (i * 0x800));
+		nv_wr32(disp, 0x610198 + (i * 0x10), tmp);
+		tmp = nv_rd32(disp, 0x61610c + (i * 0x800));
+		nv_wr32(disp, 0x61019c + (i * 0x10), tmp);
 	}
 
 	/* ... DAC caps */
-	for (i = 0; i < priv->dac.nr; i++) {
-		tmp = nv_rd32(priv, 0x61a000 + (i * 0x800));
-		nv_wr32(priv, 0x6101d0 + (i * 0x04), tmp);
+	for (i = 0; i < disp->dac.nr; i++) {
+		tmp = nv_rd32(disp, 0x61a000 + (i * 0x800));
+		nv_wr32(disp, 0x6101d0 + (i * 0x04), tmp);
 	}
 
 	/* ... SOR caps */
-	for (i = 0; i < priv->sor.nr; i++) {
-		tmp = nv_rd32(priv, 0x61c000 + (i * 0x800));
-		nv_wr32(priv, 0x6101e0 + (i * 0x04), tmp);
+	for (i = 0; i < disp->sor.nr; i++) {
+		tmp = nv_rd32(disp, 0x61c000 + (i * 0x800));
+		nv_wr32(disp, 0x6101e0 + (i * 0x04), tmp);
 	}
 
 	/* ... PIOR caps */
-	for (i = 0; i < priv->pior.nr; i++) {
-		tmp = nv_rd32(priv, 0x61e000 + (i * 0x800));
-		nv_wr32(priv, 0x6101f0 + (i * 0x04), tmp);
+	for (i = 0; i < disp->pior.nr; i++) {
+		tmp = nv_rd32(disp, 0x61e000 + (i * 0x800));
+		nv_wr32(disp, 0x6101f0 + (i * 0x04), tmp);
 	}
 
 	/* steal display away from vbios, or something like that */
-	if (nv_rd32(priv, 0x610024) & 0x00000100) {
-		nv_wr32(priv, 0x610024, 0x00000100);
-		nv_mask(priv, 0x6194e8, 0x00000001, 0x00000000);
-		if (!nv_wait(priv, 0x6194e8, 0x00000002, 0x00000000)) {
-			nv_error(priv, "timeout acquiring display\n");
+	if (nv_rd32(disp, 0x610024) & 0x00000100) {
+		nv_wr32(disp, 0x610024, 0x00000100);
+		nv_mask(disp, 0x6194e8, 0x00000001, 0x00000000);
+		if (!nv_wait(disp, 0x6194e8, 0x00000002, 0x00000000)) {
+			nv_error(disp, "timeout acquiring display\n");
 			return -EBUSY;
 		}
 	}
 
 	/* point at display engine memory area (hash table, objects) */
-	nv_wr32(priv, 0x610010, (nv_gpuobj(base->ramht)->addr >> 8) | 9);
+	nv_wr32(disp, 0x610010, (nv_gpuobj(base->ramht)->addr >> 8) | 9);
 
 	/* enable supervisor interrupts, disable everything else */
-	nv_wr32(priv, 0x61002c, 0x00000370);
-	nv_wr32(priv, 0x610028, 0x00000000);
+	nv_wr32(disp, 0x61002c, 0x00000370);
+	nv_wr32(disp, 0x610028, 0x00000000);
 	return 0;
 }
 
 static int
 nv50_disp_main_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp *disp = (void *)object->engine;
 	struct nv50_disp_base *base = (void *)object;
 
 	/* disable all interrupts */
-	nv_wr32(priv, 0x610024, 0x00000000);
-	nv_wr32(priv, 0x610020, 0x00000000);
+	nv_wr32(disp, 0x610024, 0x00000000);
+	nv_wr32(disp, 0x610020, 0x00000000);
 
 	return nvkm_parent_fini(&base->base, suspend);
 }
@@ -1246,7 +1246,7 @@ nv50_disp_data_ctor(struct nvkm_object *parent,
 		    struct nvkm_oclass *oclass, void *data, u32 size,
 		    struct nvkm_object **pobject)
 {
-	struct nv50_disp_priv *priv = (void *)engine;
+	struct nv50_disp *disp = (void *)engine;
 	struct nvkm_engctx *ectx;
 	int ret = -EBUSY;
 
@@ -1258,13 +1258,13 @@ nv50_disp_data_ctor(struct nvkm_object *parent,
 	}
 
 	/* allocate display hardware to client */
-	mutex_lock(&nv_subdev(priv)->mutex);
-	if (list_empty(&nv_engine(priv)->contexts)) {
+	mutex_lock(&nv_subdev(disp)->mutex);
+	if (list_empty(&nv_engine(disp)->contexts)) {
 		ret = nvkm_engctx_create(parent, engine, oclass, NULL, 0x10000,
 					 0x10000, NVOBJ_FLAG_HEAP, &ectx);
 		*pobject = nv_object(ectx);
 	}
-	mutex_unlock(&nv_subdev(priv)->mutex);
+	mutex_unlock(&nv_subdev(disp)->mutex);
 	return ret;
 }
 
@@ -1322,11 +1322,11 @@ nv50_disp_intr_error_code[] = {
 };
 
 static void
-nv50_disp_intr_error(struct nv50_disp_priv *priv, int chid)
+nv50_disp_intr_error(struct nv50_disp *disp, int chid)
 {
-	struct nv50_disp_impl *impl = (void *)nv_object(priv)->oclass;
-	u32 data = nv_rd32(priv, 0x610084 + (chid * 0x08));
-	u32 addr = nv_rd32(priv, 0x610080 + (chid * 0x08));
+	struct nv50_disp_impl *impl = (void *)nv_object(disp)->oclass;
+	u32 data = nv_rd32(disp, 0x610084 + (chid * 0x08));
+	u32 addr = nv_rd32(disp, 0x610080 + (chid * 0x08));
 	u32 code = (addr & 0x00ff0000) >> 16;
 	u32 type = (addr & 0x00007000) >> 12;
 	u32 mthd = (addr & 0x00000ffc);
@@ -1341,14 +1341,14 @@ nv50_disp_intr_error(struct nv50_disp_priv *priv, int chid)
 	if (!ec)
 		snprintf(ecunk, sizeof(ecunk), "UNK%02X", code);
 
-	nv_error(priv, "%s [%s] chid %d mthd 0x%04x data 0x%08x\n",
+	nv_error(disp, "%s [%s] chid %d mthd 0x%04x data 0x%08x\n",
 		 et ? et->name : etunk, ec ? ec->name : ecunk,
 		 chid, mthd, data);
 
 	if (chid == 0) {
 		switch (mthd) {
 		case 0x0080:
-			nv50_disp_mthd_chan(priv, NV_DBG_ERROR, chid - 0,
+			nv50_disp_mthd_chan(disp, NV_DBG_ERROR, chid - 0,
 					    impl->mthd.core);
 			break;
 		default:
@@ -1358,7 +1358,7 @@ nv50_disp_intr_error(struct nv50_disp_priv *priv, int chid)
 	if (chid <= 2) {
 		switch (mthd) {
 		case 0x0080:
-			nv50_disp_mthd_chan(priv, NV_DBG_ERROR, chid - 1,
+			nv50_disp_mthd_chan(disp, NV_DBG_ERROR, chid - 1,
 					    impl->mthd.base);
 			break;
 		default:
@@ -1368,7 +1368,7 @@ nv50_disp_intr_error(struct nv50_disp_priv *priv, int chid)
 	if (chid <= 4) {
 		switch (mthd) {
 		case 0x0080:
-			nv50_disp_mthd_chan(priv, NV_DBG_ERROR, chid - 3,
+			nv50_disp_mthd_chan(disp, NV_DBG_ERROR, chid - 3,
 					    impl->mthd.ovly);
 			break;
 		default:
@@ -1376,16 +1376,16 @@ nv50_disp_intr_error(struct nv50_disp_priv *priv, int chid)
 		}
 	}
 
-	nv_wr32(priv, 0x610020, 0x00010000 << chid);
-	nv_wr32(priv, 0x610080 + (chid * 0x08), 0x90000000);
+	nv_wr32(disp, 0x610020, 0x00010000 << chid);
+	nv_wr32(disp, 0x610080 + (chid * 0x08), 0x90000000);
 }
 
 static struct nvkm_output *
-exec_lookup(struct nv50_disp_priv *priv, int head, int or, u32 ctrl,
+exec_lookup(struct nv50_disp *disp, int head, int or, u32 ctrl,
 	    u32 *data, u8 *ver, u8 *hdr, u8 *cnt, u8 *len,
 	    struct nvbios_outp *info)
 {
-	struct nvkm_bios *bios = nvkm_bios(priv);
+	struct nvkm_bios *bios = nvkm_bios(disp);
 	struct nvkm_output *outp;
 	u16 mask, type;
 
@@ -1402,7 +1402,7 @@ exec_lookup(struct nv50_disp_priv *priv, int head, int or, u32 ctrl,
 		case 0x00000800: type = DCB_OUTPUT_DP; mask = 1; break;
 		case 0x00000900: type = DCB_OUTPUT_DP; mask = 2; break;
 		default:
-			nv_error(priv, "unknown SOR mc 0x%08x\n", ctrl);
+			nv_error(disp, "unknown SOR mc 0x%08x\n", ctrl);
 			return NULL;
 		}
 		or  -= 4;
@@ -1411,9 +1411,9 @@ exec_lookup(struct nv50_disp_priv *priv, int head, int or, u32 ctrl,
 		type = 0x0010;
 		mask = 0;
 		switch (ctrl & 0x00000f00) {
-		case 0x00000000: type |= priv->pior.type[or]; break;
+		case 0x00000000: type |= disp->pior.type[or]; break;
 		default:
-			nv_error(priv, "unknown PIOR mc 0x%08x\n", ctrl);
+			nv_error(disp, "unknown PIOR mc 0x%08x\n", ctrl);
 			return NULL;
 		}
 	}
@@ -1422,7 +1422,7 @@ exec_lookup(struct nv50_disp_priv *priv, int head, int or, u32 ctrl,
 	mask |= 0x0001 << or;
 	mask |= 0x0100 << head;
 
-	list_for_each_entry(outp, &priv->base.outp, head) {
+	list_for_each_entry(outp, &disp->base.outp, head) {
 		if ((outp->info.hasht & 0xff) == type &&
 		    (outp->info.hashm & mask) == mask) {
 			*data = nvbios_outp_match(bios, outp->info.hasht,
@@ -1438,9 +1438,9 @@ exec_lookup(struct nv50_disp_priv *priv, int head, int or, u32 ctrl,
 }
 
 static struct nvkm_output *
-exec_script(struct nv50_disp_priv *priv, int head, int id)
+exec_script(struct nv50_disp *disp, int head, int id)
 {
-	struct nvkm_bios *bios = nvkm_bios(priv);
+	struct nvkm_bios *bios = nvkm_bios(disp);
 	struct nvkm_output *outp;
 	struct nvbios_outp info;
 	u8  ver, hdr, cnt, len;
@@ -1449,27 +1449,27 @@ exec_script(struct nv50_disp_priv *priv, int head, int id)
 	int i;
 
 	/* DAC */
-	for (i = 0; !(ctrl & (1 << head)) && i < priv->dac.nr; i++)
-		ctrl = nv_rd32(priv, 0x610b5c + (i * 8));
+	for (i = 0; !(ctrl & (1 << head)) && i < disp->dac.nr; i++)
+		ctrl = nv_rd32(disp, 0x610b5c + (i * 8));
 
 	/* SOR */
 	if (!(ctrl & (1 << head))) {
-		if (nv_device(priv)->chipset  < 0x90 ||
-		    nv_device(priv)->chipset == 0x92 ||
-		    nv_device(priv)->chipset == 0xa0) {
+		if (nv_device(disp)->chipset  < 0x90 ||
+		    nv_device(disp)->chipset == 0x92 ||
+		    nv_device(disp)->chipset == 0xa0) {
 			reg = 0x610b74;
 		} else {
 			reg = 0x610798;
 		}
-		for (i = 0; !(ctrl & (1 << head)) && i < priv->sor.nr; i++)
-			ctrl = nv_rd32(priv, reg + (i * 8));
+		for (i = 0; !(ctrl & (1 << head)) && i < disp->sor.nr; i++)
+			ctrl = nv_rd32(disp, reg + (i * 8));
 		i += 4;
 	}
 
 	/* PIOR */
 	if (!(ctrl & (1 << head))) {
-		for (i = 0; !(ctrl & (1 << head)) && i < priv->pior.nr; i++)
-			ctrl = nv_rd32(priv, 0x610b84 + (i * 8));
+		for (i = 0; !(ctrl & (1 << head)) && i < disp->pior.nr; i++)
+			ctrl = nv_rd32(disp, 0x610b84 + (i * 8));
 		i += 8;
 	}
 
@@ -1477,10 +1477,10 @@ exec_script(struct nv50_disp_priv *priv, int head, int id)
 		return NULL;
 	i--;
 
-	outp = exec_lookup(priv, head, i, ctrl, &data, &ver, &hdr, &cnt, &len, &info);
+	outp = exec_lookup(disp, head, i, ctrl, &data, &ver, &hdr, &cnt, &len, &info);
 	if (outp) {
 		struct nvbios_init init = {
-			.subdev = nv_subdev(priv),
+			.subdev = nv_subdev(disp),
 			.bios = bios,
 			.offset = info.script[id],
 			.outp = &outp->info,
@@ -1495,9 +1495,9 @@ exec_script(struct nv50_disp_priv *priv, int head, int id)
 }
 
 static struct nvkm_output *
-exec_clkcmp(struct nv50_disp_priv *priv, int head, int id, u32 pclk, u32 *conf)
+exec_clkcmp(struct nv50_disp *disp, int head, int id, u32 pclk, u32 *conf)
 {
-	struct nvkm_bios *bios = nvkm_bios(priv);
+	struct nvkm_bios *bios = nvkm_bios(disp);
 	struct nvkm_output *outp;
 	struct nvbios_outp info1;
 	struct nvbios_ocfg info2;
@@ -1507,27 +1507,27 @@ exec_clkcmp(struct nv50_disp_priv *priv, int head, int id, u32 pclk, u32 *conf)
 	int i;
 
 	/* DAC */
-	for (i = 0; !(ctrl & (1 << head)) && i < priv->dac.nr; i++)
-		ctrl = nv_rd32(priv, 0x610b58 + (i * 8));
+	for (i = 0; !(ctrl & (1 << head)) && i < disp->dac.nr; i++)
+		ctrl = nv_rd32(disp, 0x610b58 + (i * 8));
 
 	/* SOR */
 	if (!(ctrl & (1 << head))) {
-		if (nv_device(priv)->chipset  < 0x90 ||
-		    nv_device(priv)->chipset == 0x92 ||
-		    nv_device(priv)->chipset == 0xa0) {
+		if (nv_device(disp)->chipset  < 0x90 ||
+		    nv_device(disp)->chipset == 0x92 ||
+		    nv_device(disp)->chipset == 0xa0) {
 			reg = 0x610b70;
 		} else {
 			reg = 0x610794;
 		}
-		for (i = 0; !(ctrl & (1 << head)) && i < priv->sor.nr; i++)
-			ctrl = nv_rd32(priv, reg + (i * 8));
+		for (i = 0; !(ctrl & (1 << head)) && i < disp->sor.nr; i++)
+			ctrl = nv_rd32(disp, reg + (i * 8));
 		i += 4;
 	}
 
 	/* PIOR */
 	if (!(ctrl & (1 << head))) {
-		for (i = 0; !(ctrl & (1 << head)) && i < priv->pior.nr; i++)
-			ctrl = nv_rd32(priv, 0x610b80 + (i * 8));
+		for (i = 0; !(ctrl & (1 << head)) && i < disp->pior.nr; i++)
+			ctrl = nv_rd32(disp, 0x610b80 + (i * 8));
 		i += 8;
 	}
 
@@ -1535,7 +1535,7 @@ exec_clkcmp(struct nv50_disp_priv *priv, int head, int id, u32 pclk, u32 *conf)
 		return NULL;
 	i--;
 
-	outp = exec_lookup(priv, head, i, ctrl, &data, &ver, &hdr, &cnt, &len, &info1);
+	outp = exec_lookup(disp, head, i, ctrl, &data, &ver, &hdr, &cnt, &len, &info1);
 	if (!outp)
 		return NULL;
 
@@ -1547,7 +1547,7 @@ exec_clkcmp(struct nv50_disp_priv *priv, int head, int id, u32 pclk, u32 *conf)
 				*conf |= 0x0100;
 			break;
 		case DCB_OUTPUT_LVDS:
-			*conf = priv->sor.lvdsconf;
+			*conf = disp->sor.lvdsconf;
 			break;
 		case DCB_OUTPUT_DP:
 			*conf = (ctrl & 0x00000f00) >> 8;
@@ -1567,7 +1567,7 @@ exec_clkcmp(struct nv50_disp_priv *priv, int head, int id, u32 pclk, u32 *conf)
 		data = nvbios_oclk_match(bios, info2.clkcmp[id], pclk);
 		if (data) {
 			struct nvbios_init init = {
-				.subdev = nv_subdev(priv),
+				.subdev = nv_subdev(disp),
 				.bios = bios,
 				.offset = data,
 				.outp = &outp->info,
@@ -1583,15 +1583,15 @@ exec_clkcmp(struct nv50_disp_priv *priv, int head, int id, u32 pclk, u32 *conf)
 }
 
 static void
-nv50_disp_intr_unk10_0(struct nv50_disp_priv *priv, int head)
+nv50_disp_intr_unk10_0(struct nv50_disp *disp, int head)
 {
-	exec_script(priv, head, 1);
+	exec_script(disp, head, 1);
 }
 
 static void
-nv50_disp_intr_unk20_0(struct nv50_disp_priv *priv, int head)
+nv50_disp_intr_unk20_0(struct nv50_disp *disp, int head)
 {
-	struct nvkm_output *outp = exec_script(priv, head, 2);
+	struct nvkm_output *outp = exec_script(disp, head, 2);
 
 	/* the binary driver does this outside of the supervisor handling
 	 * (after the third supervisor from a detach).  we (currently?)
@@ -1609,8 +1609,8 @@ nv50_disp_intr_unk20_0(struct nv50_disp_priv *priv, int head)
 	if (outp && outp->info.type == DCB_OUTPUT_DP) {
 		struct nvkm_output_dp *outpdp = (void *)outp;
 		struct nvbios_init init = {
-			.subdev = nv_subdev(priv),
-			.bios = nvkm_bios(priv),
+			.subdev = nv_subdev(disp),
+			.bios = nvkm_bios(disp),
 			.outp = &outp->info,
 			.crtc = head,
 			.offset = outpdp->info.script[4],
@@ -1623,29 +1623,29 @@ nv50_disp_intr_unk20_0(struct nv50_disp_priv *priv, int head)
 }
 
 static void
-nv50_disp_intr_unk20_1(struct nv50_disp_priv *priv, int head)
+nv50_disp_intr_unk20_1(struct nv50_disp *disp, int head)
 {
-	struct nvkm_devinit *devinit = nvkm_devinit(priv);
-	u32 pclk = nv_rd32(priv, 0x610ad0 + (head * 0x540)) & 0x3fffff;
+	struct nvkm_devinit *devinit = nvkm_devinit(disp);
+	u32 pclk = nv_rd32(disp, 0x610ad0 + (head * 0x540)) & 0x3fffff;
 	if (pclk)
 		devinit->pll_set(devinit, PLL_VPLL0 + head, pclk);
 }
 
 static void
-nv50_disp_intr_unk20_2_dp(struct nv50_disp_priv *priv, int head,
+nv50_disp_intr_unk20_2_dp(struct nv50_disp *disp, int head,
 			  struct dcb_output *outp, u32 pclk)
 {
 	const int link = !(outp->sorconf.link & 1);
 	const int   or = ffs(outp->or) - 1;
 	const u32 soff = (  or * 0x800);
 	const u32 loff = (link * 0x080) + soff;
-	const u32 ctrl = nv_rd32(priv, 0x610794 + (or * 8));
+	const u32 ctrl = nv_rd32(disp, 0x610794 + (or * 8));
 	const u32 symbol = 100000;
-	const s32 vactive = nv_rd32(priv, 0x610af8 + (head * 0x540)) & 0xffff;
-	const s32 vblanke = nv_rd32(priv, 0x610ae8 + (head * 0x540)) & 0xffff;
-	const s32 vblanks = nv_rd32(priv, 0x610af0 + (head * 0x540)) & 0xffff;
-	u32 dpctrl = nv_rd32(priv, 0x61c10c + loff);
-	u32 clksor = nv_rd32(priv, 0x614300 + soff);
+	const s32 vactive = nv_rd32(disp, 0x610af8 + (head * 0x540)) & 0xffff;
+	const s32 vblanke = nv_rd32(disp, 0x610ae8 + (head * 0x540)) & 0xffff;
+	const s32 vblanks = nv_rd32(disp, 0x610af0 + (head * 0x540)) & 0xffff;
+	u32 dpctrl = nv_rd32(disp, 0x61c10c + loff);
+	u32 clksor = nv_rd32(disp, 0x614300 + soff);
 	int bestTU = 0, bestVTUi = 0, bestVTUf = 0, bestVTUa = 0;
 	int TU, VTUi, VTUf, VTUa;
 	u64 link_data_rate, link_ratio, unk;
@@ -1661,14 +1661,14 @@ nv50_disp_intr_unk20_2_dp(struct nv50_disp_priv *priv, int head,
 	value = value * link_bw;
 	do_div(value, pclk);
 	value = value - (3 * !!(dpctrl & 0x00004000)) - (12 / link_nr);
-	nv_mask(priv, 0x61c1e8 + soff, 0x0000ffff, value);
+	nv_mask(disp, 0x61c1e8 + soff, 0x0000ffff, value);
 
 	/* symbols/vblank - algorithm taken from comments in tegra driver */
 	value = vblanks - vblanke - 25;
 	value = value * link_bw;
 	do_div(value, pclk);
 	value = value - ((36 / link_nr) + 3) - 1;
-	nv_mask(priv, 0x61c1ec + soff, 0x00ffffff, value);
+	nv_mask(disp, 0x61c1ec + soff, 0x00ffffff, value);
 
 	/* watermark / activesym */
 	if      ((ctrl & 0xf0000) == 0x60000) bits = 30;
@@ -1733,7 +1733,7 @@ nv50_disp_intr_unk20_2_dp(struct nv50_disp_priv *priv, int head,
 	}
 
 	if (!bestTU) {
-		nv_error(priv, "unable to find suitable dp config\n");
+		nv_error(disp, "unable to find suitable dp config\n");
 		return;
 	}
 
@@ -1744,22 +1744,22 @@ nv50_disp_intr_unk20_2_dp(struct nv50_disp_priv *priv, int head,
 	do_div(unk, symbol);
 	unk += 6;
 
-	nv_mask(priv, 0x61c10c + loff, 0x000001fc, bestTU << 2);
-	nv_mask(priv, 0x61c128 + loff, 0x010f7f3f, bestVTUa << 24 |
+	nv_mask(disp, 0x61c10c + loff, 0x000001fc, bestTU << 2);
+	nv_mask(disp, 0x61c128 + loff, 0x010f7f3f, bestVTUa << 24 |
 						   bestVTUf << 16 |
 						   bestVTUi << 8 | unk);
 }
 
 static void
-nv50_disp_intr_unk20_2(struct nv50_disp_priv *priv, int head)
+nv50_disp_intr_unk20_2(struct nv50_disp *disp, int head)
 {
 	struct nvkm_output *outp;
-	u32 pclk = nv_rd32(priv, 0x610ad0 + (head * 0x540)) & 0x3fffff;
+	u32 pclk = nv_rd32(disp, 0x610ad0 + (head * 0x540)) & 0x3fffff;
 	u32 hval, hreg = 0x614200 + (head * 0x800);
 	u32 oval, oreg;
 	u32 mask, conf;
 
-	outp = exec_clkcmp(priv, head, 0xff, pclk, &conf);
+	outp = exec_clkcmp(disp, head, 0xff, pclk, &conf);
 	if (!outp)
 		return;
 
@@ -1786,10 +1786,10 @@ nv50_disp_intr_unk20_2(struct nv50_disp_priv *priv, int head)
 		u32 ctrl, datarate;
 
 		if (outp->info.location == 0) {
-			ctrl = nv_rd32(priv, 0x610794 + soff);
+			ctrl = nv_rd32(disp, 0x610794 + soff);
 			soff = 1;
 		} else {
-			ctrl = nv_rd32(priv, 0x610b80 + soff);
+			ctrl = nv_rd32(disp, 0x610b80 + soff);
 			soff = 2;
 		}
 
@@ -1806,7 +1806,7 @@ nv50_disp_intr_unk20_2(struct nv50_disp_priv *priv, int head)
 			ERR("link not trained before attach\n");
 	}
 
-	exec_clkcmp(priv, head, 0, pclk, &conf);
+	exec_clkcmp(disp, head, 0, pclk, &conf);
 
 	if (!outp->info.location && outp->info.type == DCB_OUTPUT_ANALOG) {
 		oreg = 0x614280 + (ffs(outp->info.or) - 1) * 0x800;
@@ -1816,7 +1816,7 @@ nv50_disp_intr_unk20_2(struct nv50_disp_priv *priv, int head)
 	} else
 	if (!outp->info.location) {
 		if (outp->info.type == DCB_OUTPUT_DP)
-			nv50_disp_intr_unk20_2_dp(priv, head, &outp->info, pclk);
+			nv50_disp_intr_unk20_2_dp(disp, head, &outp->info, pclk);
 		oreg = 0x614300 + (ffs(outp->info.or) - 1) * 0x800;
 		oval = (conf & 0x0100) ? 0x00000101 : 0x00000000;
 		hval = 0x00000000;
@@ -1828,8 +1828,8 @@ nv50_disp_intr_unk20_2(struct nv50_disp_priv *priv, int head)
 		mask = 0x00000707;
 	}
 
-	nv_mask(priv, hreg, 0x0000000f, hval);
-	nv_mask(priv, oreg, mask, oval);
+	nv_mask(disp, hreg, 0x0000000f, hval);
+	nv_mask(disp, oreg, mask, oval);
 }
 
 /* If programming a TMDS output on a SOR that can also be configured for
@@ -1841,10 +1841,10 @@ nv50_disp_intr_unk20_2(struct nv50_disp_priv *priv, int head)
  * programmed for DisplayPort.
  */
 static void
-nv50_disp_intr_unk40_0_tmds(struct nv50_disp_priv *priv,
+nv50_disp_intr_unk40_0_tmds(struct nv50_disp *disp,
 			    struct dcb_output *outp)
 {
-	struct nvkm_bios *bios = nvkm_bios(priv);
+	struct nvkm_bios *bios = nvkm_bios(disp);
 	const int link = !(outp->sorconf.link & 1);
 	const int   or = ffs(outp->or) - 1;
 	const u32 loff = (or * 0x800) + (link * 0x80);
@@ -1853,109 +1853,106 @@ nv50_disp_intr_unk40_0_tmds(struct nv50_disp_priv *priv,
 	u8  ver, hdr;
 
 	if (dcb_outp_match(bios, DCB_OUTPUT_DP, mask, &ver, &hdr, &match))
-		nv_mask(priv, 0x61c10c + loff, 0x00000001, 0x00000000);
+		nv_mask(disp, 0x61c10c + loff, 0x00000001, 0x00000000);
 }
 
 static void
-nv50_disp_intr_unk40_0(struct nv50_disp_priv *priv, int head)
+nv50_disp_intr_unk40_0(struct nv50_disp *disp, int head)
 {
 	struct nvkm_output *outp;
-	u32 pclk = nv_rd32(priv, 0x610ad0 + (head * 0x540)) & 0x3fffff;
+	u32 pclk = nv_rd32(disp, 0x610ad0 + (head * 0x540)) & 0x3fffff;
 	u32 conf;
 
-	outp = exec_clkcmp(priv, head, 1, pclk, &conf);
+	outp = exec_clkcmp(disp, head, 1, pclk, &conf);
 	if (!outp)
 		return;
 
 	if (outp->info.location == 0 && outp->info.type == DCB_OUTPUT_TMDS)
-		nv50_disp_intr_unk40_0_tmds(priv, &outp->info);
+		nv50_disp_intr_unk40_0_tmds(disp, &outp->info);
 }
 
 void
 nv50_disp_intr_supervisor(struct work_struct *work)
 {
-	struct nv50_disp_priv *priv =
-		container_of(work, struct nv50_disp_priv, supervisor);
-	struct nv50_disp_impl *impl = (void *)nv_object(priv)->oclass;
-	u32 super = nv_rd32(priv, 0x610030);
+	struct nv50_disp *disp =
+		container_of(work, struct nv50_disp, supervisor);
+	struct nv50_disp_impl *impl = (void *)nv_object(disp)->oclass;
+	u32 super = nv_rd32(disp, 0x610030);
 	int head;
 
-	nv_debug(priv, "supervisor 0x%08x 0x%08x\n", priv->super, super);
+	nv_debug(disp, "supervisor 0x%08x 0x%08x\n", disp->super, super);
 
-	if (priv->super & 0x00000010) {
-		nv50_disp_mthd_chan(priv, NV_DBG_DEBUG, 0, impl->mthd.core);
-		for (head = 0; head < priv->head.nr; head++) {
+	if (disp->super & 0x00000010) {
+		nv50_disp_mthd_chan(disp, NV_DBG_DEBUG, 0, impl->mthd.core);
+		for (head = 0; head < disp->head.nr; head++) {
 			if (!(super & (0x00000020 << head)))
 				continue;
 			if (!(super & (0x00000080 << head)))
 				continue;
-			nv50_disp_intr_unk10_0(priv, head);
+			nv50_disp_intr_unk10_0(disp, head);
 		}
 	} else
-	if (priv->super & 0x00000020) {
-		for (head = 0; head < priv->head.nr; head++) {
+	if (disp->super & 0x00000020) {
+		for (head = 0; head < disp->head.nr; head++) {
 			if (!(super & (0x00000080 << head)))
 				continue;
-			nv50_disp_intr_unk20_0(priv, head);
+			nv50_disp_intr_unk20_0(disp, head);
 		}
-		for (head = 0; head < priv->head.nr; head++) {
+		for (head = 0; head < disp->head.nr; head++) {
 			if (!(super & (0x00000200 << head)))
 				continue;
-			nv50_disp_intr_unk20_1(priv, head);
+			nv50_disp_intr_unk20_1(disp, head);
 		}
-		for (head = 0; head < priv->head.nr; head++) {
+		for (head = 0; head < disp->head.nr; head++) {
 			if (!(super & (0x00000080 << head)))
 				continue;
-			nv50_disp_intr_unk20_2(priv, head);
+			nv50_disp_intr_unk20_2(disp, head);
 		}
 	} else
-	if (priv->super & 0x00000040) {
-		for (head = 0; head < priv->head.nr; head++) {
+	if (disp->super & 0x00000040) {
+		for (head = 0; head < disp->head.nr; head++) {
 			if (!(super & (0x00000080 << head)))
 				continue;
-			nv50_disp_intr_unk40_0(priv, head);
+			nv50_disp_intr_unk40_0(disp, head);
 		}
 	}
 
-	nv_wr32(priv, 0x610030, 0x80000000);
+	nv_wr32(disp, 0x610030, 0x80000000);
 }
 
 void
 nv50_disp_intr(struct nvkm_subdev *subdev)
 {
-	struct nv50_disp_priv *priv = (void *)subdev;
-	u32 intr0 = nv_rd32(priv, 0x610020);
-	u32 intr1 = nv_rd32(priv, 0x610024);
+	struct nv50_disp *disp = (void *)subdev;
+	u32 intr0 = nv_rd32(disp, 0x610020);
+	u32 intr1 = nv_rd32(disp, 0x610024);
 
 	while (intr0 & 0x001f0000) {
 		u32 chid = __ffs(intr0 & 0x001f0000) - 16;
-		nv50_disp_intr_error(priv, chid);
+		nv50_disp_intr_error(disp, chid);
 		intr0 &= ~(0x00010000 << chid);
 	}
 
 	while (intr0 & 0x0000001f) {
 		u32 chid = __ffs(intr0 & 0x0000001f);
-		nv50_disp_chan_uevent_send(priv, chid);
+		nv50_disp_chan_uevent_send(disp, chid);
 		intr0 &= ~(0x00000001 << chid);
 	}
 
 	if (intr1 & 0x00000004) {
-		nvkm_disp_vblank(&priv->base, 0);
-		nv_wr32(priv, 0x610024, 0x00000004);
-		intr1 &= ~0x00000004;
+		nvkm_disp_vblank(&disp->base, 0);
+		nv_wr32(disp, 0x610024, 0x00000004);
 	}
 
 	if (intr1 & 0x00000008) {
-		nvkm_disp_vblank(&priv->base, 1);
-		nv_wr32(priv, 0x610024, 0x00000008);
-		intr1 &= ~0x00000008;
+		nvkm_disp_vblank(&disp->base, 1);
+		nv_wr32(disp, 0x610024, 0x00000008);
 	}
 
 	if (intr1 & 0x00000070) {
-		priv->super = (intr1 & 0x00000070);
-		schedule_work(&priv->supervisor);
-		nv_wr32(priv, 0x610024, priv->super);
-		intr1 &= ~0x00000070;
+		disp->super = (intr1 & 0x00000070);
+		schedule_work(&disp->supervisor);
+		nv_wr32(disp, 0x610024, disp->super);
 	}
 }
 
@@ -1964,32 +1961,32 @@ nv50_disp_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_oclass *oclass, void *data, u32 size,
 	       struct nvkm_object **pobject)
 {
-	struct nv50_disp_priv *priv;
+	struct nv50_disp *disp;
 	int ret;
 
 	ret = nvkm_disp_create(parent, engine, oclass, 2, "PDISP",
-			       "display", &priv);
-	*pobject = nv_object(priv);
+			       "display", &disp);
+	*pobject = nv_object(disp);
 	if (ret)
 		return ret;
 
-	ret = nvkm_event_init(&nv50_disp_chan_uevent, 1, 9, &priv->uevent);
+	ret = nvkm_event_init(&nv50_disp_chan_uevent, 1, 9, &disp->uevent);
 	if (ret)
 		return ret;
 
-	nv_engine(priv)->sclass = nv50_disp_main_oclass;
-	nv_engine(priv)->cclass = &nv50_disp_cclass;
-	nv_subdev(priv)->intr = nv50_disp_intr;
-	INIT_WORK(&priv->supervisor, nv50_disp_intr_supervisor);
-	priv->sclass = nv50_disp_sclass;
-	priv->head.nr = 2;
-	priv->dac.nr = 3;
-	priv->sor.nr = 2;
-	priv->pior.nr = 3;
-	priv->dac.power = nv50_dac_power;
-	priv->dac.sense = nv50_dac_sense;
-	priv->sor.power = nv50_sor_power;
-	priv->pior.power = nv50_pior_power;
+	nv_engine(disp)->sclass = nv50_disp_main_oclass;
+	nv_engine(disp)->cclass = &nv50_disp_cclass;
+	nv_subdev(disp)->intr = nv50_disp_intr;
+	INIT_WORK(&disp->supervisor, nv50_disp_intr_supervisor);
+	disp->sclass = nv50_disp_sclass;
+	disp->head.nr = 2;
+	disp->dac.nr = 3;
+	disp->sor.nr = 2;
+	disp->pior.nr = 3;
+	disp->dac.power = nv50_dac_power;
+	disp->dac.sense = nv50_dac_sense;
+	disp->sor.power = nv50_sor_power;
+	disp->pior.power = nv50_pior_power;
 	return 0;
 }
 

commit 9ace404b1098221021b01c2ba0eeea0c257fa4a5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/device: include core/device.h automatically for subdevs/engines
    
    Pretty much every subdev/engine is going to need access to nvkm_device
    shortly to touch registers and/or output messages.
    
    The odd placement of the includes is necessary to work around some
    inter-dependencies that currently exist.  This will be fixed later.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 8ba808df24ad..25fcabcb1d6c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -26,7 +26,6 @@
 #include "outpdp.h"
 
 #include <core/client.h>
-#include <core/device.h>
 #include <core/engctx.h>
 #include <core/enum.h>
 #include <core/handle.h>

commit 963e965033c002d2238dd3dbd6628109cc6d90de
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Mar 10 09:13:08 2015 +1000

    drm/nouveau/disp/nv50-: fix push buffers in vram
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 84ade810e27c..8ba808df24ad 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -229,7 +229,7 @@ nv50_disp_dmac_create_(struct nvkm_object *parent,
 
 		switch (dmac->pushdma->target) {
 		case NV_MEM_TARGET_VRAM:
-			dmac->push = 0x00000000 | dmac->pushdma->start >> 8;
+			dmac->push = 0x00000001 | dmac->pushdma->start >> 8;
 			break;
 		case NV_MEM_TARGET_PCI_NOSNOOP:
 			dmac->push = 0x00000003 | dmac->pushdma->start >> 8;

commit 878da15adb5ddce57339b87685d8b4630e60085f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:24:57 2015 +1000

    drm/nouveau/disp: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
index 44a8290aaea5..84ade810e27c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -21,35 +21,38 @@
  *
  * Authors: Ben Skeggs
  */
+#include "nv50.h"
+#include "outp.h"
+#include "outpdp.h"
 
-#include <core/object.h>
 #include <core/client.h>
-#include <core/parent.h>
-#include <core/handle.h>
+#include <core/device.h>
+#include <core/engctx.h>
 #include <core/enum.h>
-#include <nvif/unpack.h>
-#include <nvif/class.h>
-#include <nvif/event.h>
-
+#include <core/handle.h>
+#include <core/ramht.h>
+#include <engine/dmaobj.h>
 #include <subdev/bios.h>
 #include <subdev/bios/dcb.h>
 #include <subdev/bios/disp.h>
 #include <subdev/bios/init.h>
 #include <subdev/bios/pll.h>
 #include <subdev/devinit.h>
-#include <subdev/timer.h>
 #include <subdev/fb.h>
+#include <subdev/timer.h>
 
-#include "nv50.h"
+#include <nvif/class.h>
+#include <nvif/event.h>
+#include <nvif/unpack.h>
 
 /*******************************************************************************
  * EVO channel base class
  ******************************************************************************/
 
 static int
-nv50_disp_chan_create_(struct nouveau_object *parent,
-		       struct nouveau_object *engine,
-		       struct nouveau_oclass *oclass, int head,
+nv50_disp_chan_create_(struct nvkm_object *parent,
+		       struct nvkm_object *engine,
+		       struct nvkm_oclass *oclass, int head,
 		       int length, void **pobject)
 {
 	const struct nv50_disp_chan_impl *impl = (void *)oclass->ofuncs;
@@ -62,9 +65,9 @@ nv50_disp_chan_create_(struct nouveau_object *parent,
 		return -EBUSY;
 	base->chan |= (1 << chid);
 
-	ret = nouveau_namedb_create_(parent, engine, oclass, 0, NULL,
-				     (1ULL << NVDEV_ENGINE_DMAOBJ),
-				     length, pobject);
+	ret = nvkm_namedb_create_(parent, engine, oclass, 0, NULL,
+				  (1ULL << NVDEV_ENGINE_DMAOBJ),
+				  length, pobject);
 	chan = *pobject;
 	if (ret)
 		return ret;
@@ -80,7 +83,7 @@ nv50_disp_chan_destroy(struct nv50_disp_chan *chan)
 {
 	struct nv50_disp_base *base = (void *)nv_object(chan)->parent;
 	base->chan &= ~(1 << chan->chid);
-	nouveau_namedb_destroy(&chan->base);
+	nvkm_namedb_destroy(&chan->base);
 }
 
 static void
@@ -109,7 +112,7 @@ nv50_disp_chan_uevent_send(struct nv50_disp_priv *priv, int chid)
 }
 
 int
-nv50_disp_chan_uevent_ctor(struct nouveau_object *object, void *data, u32 size,
+nv50_disp_chan_uevent_ctor(struct nvkm_object *object, void *data, u32 size,
 			   struct nvkm_notify *notify)
 {
 	struct nv50_disp_dmac *dmac = (void *)object;
@@ -136,7 +139,7 @@ nv50_disp_chan_uevent = {
 };
 
 int
-nv50_disp_chan_ntfy(struct nouveau_object *object, u32 type,
+nv50_disp_chan_ntfy(struct nvkm_object *object, u32 type,
 		    struct nvkm_event **pevent)
 {
 	struct nv50_disp_priv *priv = (void *)object->engine;
@@ -151,7 +154,7 @@ nv50_disp_chan_ntfy(struct nouveau_object *object, u32 type,
 }
 
 int
-nv50_disp_chan_map(struct nouveau_object *object, u64 *addr, u32 *size)
+nv50_disp_chan_map(struct nvkm_object *object, u64 *addr, u32 *size)
 {
 	struct nv50_disp_chan *chan = (void *)object;
 	*addr = nv_device_resource_start(nv_device(object), 0) +
@@ -161,7 +164,7 @@ nv50_disp_chan_map(struct nouveau_object *object, u64 *addr, u32 *size)
 }
 
 u32
-nv50_disp_chan_rd32(struct nouveau_object *object, u64 addr)
+nv50_disp_chan_rd32(struct nvkm_object *object, u64 addr)
 {
 	struct nv50_disp_priv *priv = (void *)object->engine;
 	struct nv50_disp_chan *chan = (void *)object;
@@ -169,7 +172,7 @@ nv50_disp_chan_rd32(struct nouveau_object *object, u64 addr)
 }
 
 void
-nv50_disp_chan_wr32(struct nouveau_object *object, u64 addr, u32 data)
+nv50_disp_chan_wr32(struct nvkm_object *object, u64 addr, u32 data)
 {
 	struct nv50_disp_priv *priv = (void *)object->engine;
 	struct nv50_disp_chan *chan = (void *)object;
@@ -181,28 +184,28 @@ nv50_disp_chan_wr32(struct nouveau_object *object, u64 addr, u32 data)
  ******************************************************************************/
 
 static int
-nv50_disp_dmac_object_attach(struct nouveau_object *parent,
-			     struct nouveau_object *object, u32 name)
+nv50_disp_dmac_object_attach(struct nvkm_object *parent,
+			     struct nvkm_object *object, u32 name)
 {
 	struct nv50_disp_base *base = (void *)parent->parent;
 	struct nv50_disp_chan *chan = (void *)parent;
 	u32 addr = nv_gpuobj(object)->node->offset;
 	u32 chid = chan->chid;
 	u32 data = (chid << 28) | (addr << 10) | chid;
-	return nouveau_ramht_insert(base->ramht, chid, name, data);
+	return nvkm_ramht_insert(base->ramht, chid, name, data);
 }
 
 static void
-nv50_disp_dmac_object_detach(struct nouveau_object *parent, int cookie)
+nv50_disp_dmac_object_detach(struct nvkm_object *parent, int cookie)
 {
 	struct nv50_disp_base *base = (void *)parent->parent;
-	nouveau_ramht_remove(base->ramht, cookie);
+	nvkm_ramht_remove(base->ramht, cookie);
 }
 
 static int
-nv50_disp_dmac_create_(struct nouveau_object *parent,
-		       struct nouveau_object *engine,
-		       struct nouveau_oclass *oclass, u32 pushbuf, int head,
+nv50_disp_dmac_create_(struct nvkm_object *parent,
+		       struct nvkm_object *engine,
+		       struct nvkm_oclass *oclass, u32 pushbuf, int head,
 		       int length, void **pobject)
 {
 	struct nv50_disp_dmac *dmac;
@@ -214,7 +217,7 @@ nv50_disp_dmac_create_(struct nouveau_object *parent,
 	if (ret)
 		return ret;
 
-	dmac->pushdma = (void *)nouveau_handle_ref(parent, pushbuf);
+	dmac->pushdma = (void *)nvkm_handle_ref(parent, pushbuf);
 	if (!dmac->pushdma)
 		return -ENOENT;
 
@@ -243,15 +246,15 @@ nv50_disp_dmac_create_(struct nouveau_object *parent,
 }
 
 void
-nv50_disp_dmac_dtor(struct nouveau_object *object)
+nv50_disp_dmac_dtor(struct nvkm_object *object)
 {
 	struct nv50_disp_dmac *dmac = (void *)object;
-	nouveau_object_ref(NULL, (struct nouveau_object **)&dmac->pushdma);
+	nvkm_object_ref(NULL, (struct nvkm_object **)&dmac->pushdma);
 	nv50_disp_chan_destroy(&dmac->base);
 }
 
 static int
-nv50_disp_dmac_init(struct nouveau_object *object)
+nv50_disp_dmac_init(struct nvkm_object *object)
 {
 	struct nv50_disp_priv *priv = (void *)object->engine;
 	struct nv50_disp_dmac *dmac = (void *)object;
@@ -284,7 +287,7 @@ nv50_disp_dmac_init(struct nouveau_object *object)
 }
 
 static int
-nv50_disp_dmac_fini(struct nouveau_object *object, bool suspend)
+nv50_disp_dmac_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nv50_disp_priv *priv = (void *)object->engine;
 	struct nv50_disp_dmac *dmac = (void *)object;
@@ -314,7 +317,7 @@ static void
 nv50_disp_mthd_list(struct nv50_disp_priv *priv, int debug, u32 base, int c,
 		    const struct nv50_disp_mthd_list *list, int inst)
 {
-	struct nouveau_object *disp = nv_object(priv);
+	struct nvkm_object *disp = nv_object(priv);
 	int i;
 
 	for (i = 0; list->data[i].mthd; i++) {
@@ -341,7 +344,7 @@ void
 nv50_disp_mthd_chan(struct nv50_disp_priv *priv, int debug, int head,
 		    const struct nv50_disp_mthd_chan *chan)
 {
-	struct nouveau_object *disp = nv_object(priv);
+	struct nvkm_object *disp = nv_object(priv);
 	const struct nv50_disp_impl *impl = (void *)disp->oclass;
 	const struct nv50_disp_mthd_list *list;
 	int i, j;
@@ -482,10 +485,10 @@ nv50_disp_core_mthd_chan = {
 };
 
 int
-nv50_disp_core_ctor(struct nouveau_object *parent,
-		    struct nouveau_object *engine,
-		    struct nouveau_oclass *oclass, void *data, u32 size,
-		    struct nouveau_object **pobject)
+nv50_disp_core_ctor(struct nvkm_object *parent,
+		    struct nvkm_object *engine,
+		    struct nvkm_oclass *oclass, void *data, u32 size,
+		    struct nvkm_object **pobject)
 {
 	union {
 		struct nv50_disp_core_channel_dma_v0 v0;
@@ -511,7 +514,7 @@ nv50_disp_core_ctor(struct nouveau_object *parent,
 }
 
 static int
-nv50_disp_core_init(struct nouveau_object *object)
+nv50_disp_core_init(struct nvkm_object *object)
 {
 	struct nv50_disp_priv *priv = (void *)object->engine;
 	struct nv50_disp_dmac *mast = (void *)object;
@@ -548,7 +551,7 @@ nv50_disp_core_init(struct nouveau_object *object)
 }
 
 static int
-nv50_disp_core_fini(struct nouveau_object *object, bool suspend)
+nv50_disp_core_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nv50_disp_priv *priv = (void *)object->engine;
 	struct nv50_disp_dmac *mast = (void *)object;
@@ -638,10 +641,10 @@ nv50_disp_base_mthd_chan = {
 };
 
 int
-nv50_disp_base_ctor(struct nouveau_object *parent,
-		    struct nouveau_object *engine,
-		    struct nouveau_oclass *oclass, void *data, u32 size,
-		    struct nouveau_object **pobject)
+nv50_disp_base_ctor(struct nvkm_object *parent,
+		    struct nvkm_object *engine,
+		    struct nvkm_oclass *oclass, void *data, u32 size,
+		    struct nvkm_object **pobject)
 {
 	union {
 		struct nv50_disp_base_channel_dma_v0 v0;
@@ -728,10 +731,10 @@ nv50_disp_ovly_mthd_chan = {
 };
 
 int
-nv50_disp_ovly_ctor(struct nouveau_object *parent,
-		    struct nouveau_object *engine,
-		    struct nouveau_oclass *oclass, void *data, u32 size,
-		    struct nouveau_object **pobject)
+nv50_disp_ovly_ctor(struct nvkm_object *parent,
+		    struct nvkm_object *engine,
+		    struct nvkm_oclass *oclass, void *data, u32 size,
+		    struct nvkm_object **pobject)
 {
 	union {
 		struct nv50_disp_overlay_channel_dma_v0 v0;
@@ -780,9 +783,9 @@ nv50_disp_ovly_ofuncs = {
  ******************************************************************************/
 
 static int
-nv50_disp_pioc_create_(struct nouveau_object *parent,
-		       struct nouveau_object *engine,
-		       struct nouveau_oclass *oclass, int head,
+nv50_disp_pioc_create_(struct nvkm_object *parent,
+		       struct nvkm_object *engine,
+		       struct nvkm_oclass *oclass, int head,
 		       int length, void **pobject)
 {
 	return nv50_disp_chan_create_(parent, engine, oclass, head,
@@ -790,14 +793,14 @@ nv50_disp_pioc_create_(struct nouveau_object *parent,
 }
 
 void
-nv50_disp_pioc_dtor(struct nouveau_object *object)
+nv50_disp_pioc_dtor(struct nvkm_object *object)
 {
 	struct nv50_disp_pioc *pioc = (void *)object;
 	nv50_disp_chan_destroy(&pioc->base);
 }
 
 static int
-nv50_disp_pioc_init(struct nouveau_object *object)
+nv50_disp_pioc_init(struct nvkm_object *object)
 {
 	struct nv50_disp_priv *priv = (void *)object->engine;
 	struct nv50_disp_pioc *pioc = (void *)object;
@@ -826,7 +829,7 @@ nv50_disp_pioc_init(struct nouveau_object *object)
 }
 
 static int
-nv50_disp_pioc_fini(struct nouveau_object *object, bool suspend)
+nv50_disp_pioc_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nv50_disp_priv *priv = (void *)object->engine;
 	struct nv50_disp_pioc *pioc = (void *)object;
@@ -848,10 +851,10 @@ nv50_disp_pioc_fini(struct nouveau_object *object, bool suspend)
  ******************************************************************************/
 
 int
-nv50_disp_oimm_ctor(struct nouveau_object *parent,
-		    struct nouveau_object *engine,
-		    struct nouveau_oclass *oclass, void *data, u32 size,
-		    struct nouveau_object **pobject)
+nv50_disp_oimm_ctor(struct nvkm_object *parent,
+		    struct nvkm_object *engine,
+		    struct nvkm_oclass *oclass, void *data, u32 size,
+		    struct nvkm_object **pobject)
 {
 	union {
 		struct nv50_disp_overlay_v0 v0;
@@ -896,10 +899,10 @@ nv50_disp_oimm_ofuncs = {
  ******************************************************************************/
 
 int
-nv50_disp_curs_ctor(struct nouveau_object *parent,
-		    struct nouveau_object *engine,
-		    struct nouveau_oclass *oclass, void *data, u32 size,
-		    struct nouveau_object **pobject)
+nv50_disp_curs_ctor(struct nvkm_object *parent,
+		    struct nvkm_object *engine,
+		    struct nvkm_oclass *oclass, void *data, u32 size,
+		    struct nvkm_object **pobject)
 {
 	union {
 		struct nv50_disp_cursor_v0 v0;
@@ -976,8 +979,7 @@ nv50_disp_main_scanoutpos(NV50_DISP_MTHD_V0)
 }
 
 int
-nv50_disp_main_mthd(struct nouveau_object *object, u32 mthd,
-		    void *data, u32 size)
+nv50_disp_main_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
 	const struct nv50_disp_impl *impl = (void *)nv_oclass(object->engine);
 	union {
@@ -1100,42 +1102,42 @@ nv50_disp_main_mthd(struct nouveau_object *object, u32 mthd,
 }
 
 int
-nv50_disp_main_ctor(struct nouveau_object *parent,
-		    struct nouveau_object *engine,
-		    struct nouveau_oclass *oclass, void *data, u32 size,
-		    struct nouveau_object **pobject)
+nv50_disp_main_ctor(struct nvkm_object *parent,
+		    struct nvkm_object *engine,
+		    struct nvkm_oclass *oclass, void *data, u32 size,
+		    struct nvkm_object **pobject)
 {
 	struct nv50_disp_priv *priv = (void *)engine;
 	struct nv50_disp_base *base;
 	int ret;
 
-	ret = nouveau_parent_create(parent, engine, oclass, 0,
-				    priv->sclass, 0, &base);
+	ret = nvkm_parent_create(parent, engine, oclass, 0,
+				 priv->sclass, 0, &base);
 	*pobject = nv_object(base);
 	if (ret)
 		return ret;
 
-	return nouveau_ramht_new(nv_object(base), nv_object(base), 0x1000, 0,
-				&base->ramht);
+	return nvkm_ramht_new(nv_object(base), nv_object(base), 0x1000, 0,
+			      &base->ramht);
 }
 
 void
-nv50_disp_main_dtor(struct nouveau_object *object)
+nv50_disp_main_dtor(struct nvkm_object *object)
 {
 	struct nv50_disp_base *base = (void *)object;
-	nouveau_ramht_ref(NULL, &base->ramht);
-	nouveau_parent_destroy(&base->base);
+	nvkm_ramht_ref(NULL, &base->ramht);
+	nvkm_parent_destroy(&base->base);
 }
 
 static int
-nv50_disp_main_init(struct nouveau_object *object)
+nv50_disp_main_init(struct nvkm_object *object)
 {
 	struct nv50_disp_priv *priv = (void *)object->engine;
 	struct nv50_disp_base *base = (void *)object;
 	int ret, i;
 	u32 tmp;
 
-	ret = nouveau_parent_init(&base->base);
+	ret = nvkm_parent_init(&base->base);
 	if (ret)
 		return ret;
 
@@ -1196,7 +1198,7 @@ nv50_disp_main_init(struct nouveau_object *object)
 }
 
 static int
-nv50_disp_main_fini(struct nouveau_object *object, bool suspend)
+nv50_disp_main_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nv50_disp_priv *priv = (void *)object->engine;
 	struct nv50_disp_base *base = (void *)object;
@@ -1205,26 +1207,26 @@ nv50_disp_main_fini(struct nouveau_object *object, bool suspend)
 	nv_wr32(priv, 0x610024, 0x00000000);
 	nv_wr32(priv, 0x610020, 0x00000000);
 
-	return nouveau_parent_fini(&base->base, suspend);
+	return nvkm_parent_fini(&base->base, suspend);
 }
 
-struct nouveau_ofuncs
+struct nvkm_ofuncs
 nv50_disp_main_ofuncs = {
 	.ctor = nv50_disp_main_ctor,
 	.dtor = nv50_disp_main_dtor,
 	.init = nv50_disp_main_init,
 	.fini = nv50_disp_main_fini,
 	.mthd = nv50_disp_main_mthd,
-	.ntfy = nouveau_disp_ntfy,
+	.ntfy = nvkm_disp_ntfy,
 };
 
-static struct nouveau_oclass
+static struct nvkm_oclass
 nv50_disp_main_oclass[] = {
 	{ NV50_DISP, &nv50_disp_main_ofuncs },
 	{}
 };
 
-static struct nouveau_oclass
+static struct nvkm_oclass
 nv50_disp_sclass[] = {
 	{ NV50_DISP_CORE_CHANNEL_DMA, &nv50_disp_core_ofuncs.base },
 	{ NV50_DISP_BASE_CHANNEL_DMA, &nv50_disp_base_ofuncs.base },
@@ -1240,13 +1242,13 @@ nv50_disp_sclass[] = {
  ******************************************************************************/
 
 static int
-nv50_disp_data_ctor(struct nouveau_object *parent,
-		    struct nouveau_object *engine,
-		    struct nouveau_oclass *oclass, void *data, u32 size,
-		    struct nouveau_object **pobject)
+nv50_disp_data_ctor(struct nvkm_object *parent,
+		    struct nvkm_object *engine,
+		    struct nvkm_oclass *oclass, void *data, u32 size,
+		    struct nvkm_object **pobject)
 {
 	struct nv50_disp_priv *priv = (void *)engine;
-	struct nouveau_engctx *ectx;
+	struct nvkm_engctx *ectx;
 	int ret = -EBUSY;
 
 	/* no context needed for channel objects... */
@@ -1259,25 +1261,24 @@ nv50_disp_data_ctor(struct nouveau_object *parent,
 	/* allocate display hardware to client */
 	mutex_lock(&nv_subdev(priv)->mutex);
 	if (list_empty(&nv_engine(priv)->contexts)) {
-		ret = nouveau_engctx_create(parent, engine, oclass, NULL,
-					    0x10000, 0x10000,
-					    NVOBJ_FLAG_HEAP, &ectx);
+		ret = nvkm_engctx_create(parent, engine, oclass, NULL, 0x10000,
+					 0x10000, NVOBJ_FLAG_HEAP, &ectx);
 		*pobject = nv_object(ectx);
 	}
 	mutex_unlock(&nv_subdev(priv)->mutex);
 	return ret;
 }
 
-struct nouveau_oclass
+struct nvkm_oclass
 nv50_disp_cclass = {
 	.handle = NV_ENGCTX(DISP, 0x50),
-	.ofuncs = &(struct nouveau_ofuncs) {
+	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv50_disp_data_ctor,
-		.dtor = _nouveau_engctx_dtor,
-		.init = _nouveau_engctx_init,
-		.fini = _nouveau_engctx_fini,
-		.rd32 = _nouveau_engctx_rd32,
-		.wr32 = _nouveau_engctx_wr32,
+		.dtor = _nvkm_engctx_dtor,
+		.init = _nvkm_engctx_init,
+		.fini = _nvkm_engctx_fini,
+		.rd32 = _nvkm_engctx_rd32,
+		.wr32 = _nvkm_engctx_wr32,
 	},
 };
 
@@ -1288,25 +1289,25 @@ nv50_disp_cclass = {
 static void
 nv50_disp_vblank_fini(struct nvkm_event *event, int type, int head)
 {
-	struct nouveau_disp *disp = container_of(event, typeof(*disp), vblank);
+	struct nvkm_disp *disp = container_of(event, typeof(*disp), vblank);
 	nv_mask(disp, 0x61002c, (4 << head), 0);
 }
 
 static void
 nv50_disp_vblank_init(struct nvkm_event *event, int type, int head)
 {
-	struct nouveau_disp *disp = container_of(event, typeof(*disp), vblank);
+	struct nvkm_disp *disp = container_of(event, typeof(*disp), vblank);
 	nv_mask(disp, 0x61002c, (4 << head), (4 << head));
 }
 
 const struct nvkm_event_func
 nv50_disp_vblank_func = {
-	.ctor = nouveau_disp_vblank_ctor,
+	.ctor = nvkm_disp_vblank_ctor,
 	.init = nv50_disp_vblank_init,
 	.fini = nv50_disp_vblank_fini,
 };
 
-static const struct nouveau_enum
+static const struct nvkm_enum
 nv50_disp_intr_error_type[] = {
 	{ 3, "ILLEGAL_MTHD" },
 	{ 4, "INVALID_VALUE" },
@@ -1315,7 +1316,7 @@ nv50_disp_intr_error_type[] = {
 	{}
 };
 
-static const struct nouveau_enum
+static const struct nvkm_enum
 nv50_disp_intr_error_code[] = {
 	{ 0x00, "" },
 	{}
@@ -1330,14 +1331,14 @@ nv50_disp_intr_error(struct nv50_disp_priv *priv, int chid)
 	u32 code = (addr & 0x00ff0000) >> 16;
 	u32 type = (addr & 0x00007000) >> 12;
 	u32 mthd = (addr & 0x00000ffc);
-	const struct nouveau_enum *ec, *et;
+	const struct nvkm_enum *ec, *et;
 	char ecunk[6], etunk[6];
 
-	et = nouveau_enum_find(nv50_disp_intr_error_type, type);
+	et = nvkm_enum_find(nv50_disp_intr_error_type, type);
 	if (!et)
 		snprintf(etunk, sizeof(etunk), "UNK%02X", type);
 
-	ec = nouveau_enum_find(nv50_disp_intr_error_code, code);
+	ec = nvkm_enum_find(nv50_disp_intr_error_code, code);
 	if (!ec)
 		snprintf(ecunk, sizeof(ecunk), "UNK%02X", code);
 
@@ -1385,7 +1386,7 @@ exec_lookup(struct nv50_disp_priv *priv, int head, int or, u32 ctrl,
 	    u32 *data, u8 *ver, u8 *hdr, u8 *cnt, u8 *len,
 	    struct nvbios_outp *info)
 {
-	struct nouveau_bios *bios = nouveau_bios(priv);
+	struct nvkm_bios *bios = nvkm_bios(priv);
 	struct nvkm_output *outp;
 	u16 mask, type;
 
@@ -1440,7 +1441,7 @@ exec_lookup(struct nv50_disp_priv *priv, int head, int or, u32 ctrl,
 static struct nvkm_output *
 exec_script(struct nv50_disp_priv *priv, int head, int id)
 {
-	struct nouveau_bios *bios = nouveau_bios(priv);
+	struct nvkm_bios *bios = nvkm_bios(priv);
 	struct nvkm_output *outp;
 	struct nvbios_outp info;
 	u8  ver, hdr, cnt, len;
@@ -1497,7 +1498,7 @@ exec_script(struct nv50_disp_priv *priv, int head, int id)
 static struct nvkm_output *
 exec_clkcmp(struct nv50_disp_priv *priv, int head, int id, u32 pclk, u32 *conf)
 {
-	struct nouveau_bios *bios = nouveau_bios(priv);
+	struct nvkm_bios *bios = nvkm_bios(priv);
 	struct nvkm_output *outp;
 	struct nvbios_outp info1;
 	struct nvbios_ocfg info2;
@@ -1610,7 +1611,7 @@ nv50_disp_intr_unk20_0(struct nv50_disp_priv *priv, int head)
 		struct nvkm_output_dp *outpdp = (void *)outp;
 		struct nvbios_init init = {
 			.subdev = nv_subdev(priv),
-			.bios = nouveau_bios(priv),
+			.bios = nvkm_bios(priv),
 			.outp = &outp->info,
 			.crtc = head,
 			.offset = outpdp->info.script[4],
@@ -1625,7 +1626,7 @@ nv50_disp_intr_unk20_0(struct nv50_disp_priv *priv, int head)
 static void
 nv50_disp_intr_unk20_1(struct nv50_disp_priv *priv, int head)
 {
-	struct nouveau_devinit *devinit = nouveau_devinit(priv);
+	struct nvkm_devinit *devinit = nvkm_devinit(priv);
 	u32 pclk = nv_rd32(priv, 0x610ad0 + (head * 0x540)) & 0x3fffff;
 	if (pclk)
 		devinit->pll_set(devinit, PLL_VPLL0 + head, pclk);
@@ -1841,9 +1842,10 @@ nv50_disp_intr_unk20_2(struct nv50_disp_priv *priv, int head)
  * programmed for DisplayPort.
  */
 static void
-nv50_disp_intr_unk40_0_tmds(struct nv50_disp_priv *priv, struct dcb_output *outp)
+nv50_disp_intr_unk40_0_tmds(struct nv50_disp_priv *priv,
+			    struct dcb_output *outp)
 {
-	struct nouveau_bios *bios = nouveau_bios(priv);
+	struct nvkm_bios *bios = nvkm_bios(priv);
 	const int link = !(outp->sorconf.link & 1);
 	const int   or = ffs(outp->or) - 1;
 	const u32 loff = (or * 0x800) + (link * 0x80);
@@ -1920,7 +1922,7 @@ nv50_disp_intr_supervisor(struct work_struct *work)
 }
 
 void
-nv50_disp_intr(struct nouveau_subdev *subdev)
+nv50_disp_intr(struct nvkm_subdev *subdev)
 {
 	struct nv50_disp_priv *priv = (void *)subdev;
 	u32 intr0 = nv_rd32(priv, 0x610020);
@@ -1939,13 +1941,13 @@ nv50_disp_intr(struct nouveau_subdev *subdev)
 	}
 
 	if (intr1 & 0x00000004) {
-		nouveau_disp_vblank(&priv->base, 0);
+		nvkm_disp_vblank(&priv->base, 0);
 		nv_wr32(priv, 0x610024, 0x00000004);
 		intr1 &= ~0x00000004;
 	}
 
 	if (intr1 & 0x00000008) {
-		nouveau_disp_vblank(&priv->base, 1);
+		nvkm_disp_vblank(&priv->base, 1);
 		nv_wr32(priv, 0x610024, 0x00000008);
 		intr1 &= ~0x00000008;
 	}
@@ -1959,15 +1961,15 @@ nv50_disp_intr(struct nouveau_subdev *subdev)
 }
 
 static int
-nv50_disp_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
-	       struct nouveau_oclass *oclass, void *data, u32 size,
-	       struct nouveau_object **pobject)
+nv50_disp_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+	       struct nvkm_oclass *oclass, void *data, u32 size,
+	       struct nvkm_object **pobject)
 {
 	struct nv50_disp_priv *priv;
 	int ret;
 
-	ret = nouveau_disp_create(parent, engine, oclass, 2, "PDISP",
-				  "display", &priv);
+	ret = nvkm_disp_create(parent, engine, oclass, 2, "PDISP",
+			       "display", &priv);
 	*pobject = nv_object(priv);
 	if (ret)
 		return ret;
@@ -1992,20 +1994,20 @@ nv50_disp_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	return 0;
 }
 
-struct nouveau_oclass *
+struct nvkm_oclass *
 nv50_disp_outp_sclass[] = {
 	&nv50_pior_dp_impl.base.base,
 	NULL
 };
 
-struct nouveau_oclass *
+struct nvkm_oclass *
 nv50_disp_oclass = &(struct nv50_disp_impl) {
 	.base.base.handle = NV_ENGINE(DISP, 0x50),
-	.base.base.ofuncs = &(struct nouveau_ofuncs) {
+	.base.base.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv50_disp_ctor,
-		.dtor = _nouveau_disp_dtor,
-		.init = _nouveau_disp_init,
-		.fini = _nouveau_disp_fini,
+		.dtor = _nvkm_disp_dtor,
+		.init = _nvkm_disp_init,
+		.fini = _nvkm_disp_fini,
 	},
 	.base.vblank = &nv50_disp_vblank_func,
 	.base.outp =  nv50_disp_outp_sclass,

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
new file mode 100644
index 000000000000..44a8290aaea5
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c
@@ -0,0 +1,2017 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <core/object.h>
+#include <core/client.h>
+#include <core/parent.h>
+#include <core/handle.h>
+#include <core/enum.h>
+#include <nvif/unpack.h>
+#include <nvif/class.h>
+#include <nvif/event.h>
+
+#include <subdev/bios.h>
+#include <subdev/bios/dcb.h>
+#include <subdev/bios/disp.h>
+#include <subdev/bios/init.h>
+#include <subdev/bios/pll.h>
+#include <subdev/devinit.h>
+#include <subdev/timer.h>
+#include <subdev/fb.h>
+
+#include "nv50.h"
+
+/*******************************************************************************
+ * EVO channel base class
+ ******************************************************************************/
+
+static int
+nv50_disp_chan_create_(struct nouveau_object *parent,
+		       struct nouveau_object *engine,
+		       struct nouveau_oclass *oclass, int head,
+		       int length, void **pobject)
+{
+	const struct nv50_disp_chan_impl *impl = (void *)oclass->ofuncs;
+	struct nv50_disp_base *base = (void *)parent;
+	struct nv50_disp_chan *chan;
+	int chid = impl->chid + head;
+	int ret;
+
+	if (base->chan & (1 << chid))
+		return -EBUSY;
+	base->chan |= (1 << chid);
+
+	ret = nouveau_namedb_create_(parent, engine, oclass, 0, NULL,
+				     (1ULL << NVDEV_ENGINE_DMAOBJ),
+				     length, pobject);
+	chan = *pobject;
+	if (ret)
+		return ret;
+	chan->chid = chid;
+
+	nv_parent(chan)->object_attach = impl->attach;
+	nv_parent(chan)->object_detach = impl->detach;
+	return 0;
+}
+
+static void
+nv50_disp_chan_destroy(struct nv50_disp_chan *chan)
+{
+	struct nv50_disp_base *base = (void *)nv_object(chan)->parent;
+	base->chan &= ~(1 << chan->chid);
+	nouveau_namedb_destroy(&chan->base);
+}
+
+static void
+nv50_disp_chan_uevent_fini(struct nvkm_event *event, int type, int index)
+{
+	struct nv50_disp_priv *priv = container_of(event, typeof(*priv), uevent);
+	nv_mask(priv, 0x610028, 0x00000001 << index, 0x00000000 << index);
+	nv_wr32(priv, 0x610020, 0x00000001 << index);
+}
+
+static void
+nv50_disp_chan_uevent_init(struct nvkm_event *event, int types, int index)
+{
+	struct nv50_disp_priv *priv = container_of(event, typeof(*priv), uevent);
+	nv_wr32(priv, 0x610020, 0x00000001 << index);
+	nv_mask(priv, 0x610028, 0x00000001 << index, 0x00000001 << index);
+}
+
+void
+nv50_disp_chan_uevent_send(struct nv50_disp_priv *priv, int chid)
+{
+	struct nvif_notify_uevent_rep {
+	} rep;
+
+	nvkm_event_send(&priv->uevent, 1, chid, &rep, sizeof(rep));
+}
+
+int
+nv50_disp_chan_uevent_ctor(struct nouveau_object *object, void *data, u32 size,
+			   struct nvkm_notify *notify)
+{
+	struct nv50_disp_dmac *dmac = (void *)object;
+	union {
+		struct nvif_notify_uevent_req none;
+	} *args = data;
+	int ret;
+
+	if (nvif_unvers(args->none)) {
+		notify->size  = sizeof(struct nvif_notify_uevent_rep);
+		notify->types = 1;
+		notify->index = dmac->base.chid;
+		return 0;
+	}
+
+	return ret;
+}
+
+const struct nvkm_event_func
+nv50_disp_chan_uevent = {
+	.ctor = nv50_disp_chan_uevent_ctor,
+	.init = nv50_disp_chan_uevent_init,
+	.fini = nv50_disp_chan_uevent_fini,
+};
+
+int
+nv50_disp_chan_ntfy(struct nouveau_object *object, u32 type,
+		    struct nvkm_event **pevent)
+{
+	struct nv50_disp_priv *priv = (void *)object->engine;
+	switch (type) {
+	case NV50_DISP_CORE_CHANNEL_DMA_V0_NTFY_UEVENT:
+		*pevent = &priv->uevent;
+		return 0;
+	default:
+		break;
+	}
+	return -EINVAL;
+}
+
+int
+nv50_disp_chan_map(struct nouveau_object *object, u64 *addr, u32 *size)
+{
+	struct nv50_disp_chan *chan = (void *)object;
+	*addr = nv_device_resource_start(nv_device(object), 0) +
+		0x640000 + (chan->chid * 0x1000);
+	*size = 0x001000;
+	return 0;
+}
+
+u32
+nv50_disp_chan_rd32(struct nouveau_object *object, u64 addr)
+{
+	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp_chan *chan = (void *)object;
+	return nv_rd32(priv, 0x640000 + (chan->chid * 0x1000) + addr);
+}
+
+void
+nv50_disp_chan_wr32(struct nouveau_object *object, u64 addr, u32 data)
+{
+	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp_chan *chan = (void *)object;
+	nv_wr32(priv, 0x640000 + (chan->chid * 0x1000) + addr, data);
+}
+
+/*******************************************************************************
+ * EVO DMA channel base class
+ ******************************************************************************/
+
+static int
+nv50_disp_dmac_object_attach(struct nouveau_object *parent,
+			     struct nouveau_object *object, u32 name)
+{
+	struct nv50_disp_base *base = (void *)parent->parent;
+	struct nv50_disp_chan *chan = (void *)parent;
+	u32 addr = nv_gpuobj(object)->node->offset;
+	u32 chid = chan->chid;
+	u32 data = (chid << 28) | (addr << 10) | chid;
+	return nouveau_ramht_insert(base->ramht, chid, name, data);
+}
+
+static void
+nv50_disp_dmac_object_detach(struct nouveau_object *parent, int cookie)
+{
+	struct nv50_disp_base *base = (void *)parent->parent;
+	nouveau_ramht_remove(base->ramht, cookie);
+}
+
+static int
+nv50_disp_dmac_create_(struct nouveau_object *parent,
+		       struct nouveau_object *engine,
+		       struct nouveau_oclass *oclass, u32 pushbuf, int head,
+		       int length, void **pobject)
+{
+	struct nv50_disp_dmac *dmac;
+	int ret;
+
+	ret = nv50_disp_chan_create_(parent, engine, oclass, head,
+				     length, pobject);
+	dmac = *pobject;
+	if (ret)
+		return ret;
+
+	dmac->pushdma = (void *)nouveau_handle_ref(parent, pushbuf);
+	if (!dmac->pushdma)
+		return -ENOENT;
+
+	switch (nv_mclass(dmac->pushdma)) {
+	case 0x0002:
+	case 0x003d:
+		if (dmac->pushdma->limit - dmac->pushdma->start != 0xfff)
+			return -EINVAL;
+
+		switch (dmac->pushdma->target) {
+		case NV_MEM_TARGET_VRAM:
+			dmac->push = 0x00000000 | dmac->pushdma->start >> 8;
+			break;
+		case NV_MEM_TARGET_PCI_NOSNOOP:
+			dmac->push = 0x00000003 | dmac->pushdma->start >> 8;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void
+nv50_disp_dmac_dtor(struct nouveau_object *object)
+{
+	struct nv50_disp_dmac *dmac = (void *)object;
+	nouveau_object_ref(NULL, (struct nouveau_object **)&dmac->pushdma);
+	nv50_disp_chan_destroy(&dmac->base);
+}
+
+static int
+nv50_disp_dmac_init(struct nouveau_object *object)
+{
+	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp_dmac *dmac = (void *)object;
+	int chid = dmac->base.chid;
+	int ret;
+
+	ret = nv50_disp_chan_init(&dmac->base);
+	if (ret)
+		return ret;
+
+	/* enable error reporting */
+	nv_mask(priv, 0x610028, 0x00010000 << chid, 0x00010000 << chid);
+
+	/* initialise channel for dma command submission */
+	nv_wr32(priv, 0x610204 + (chid * 0x0010), dmac->push);
+	nv_wr32(priv, 0x610208 + (chid * 0x0010), 0x00010000);
+	nv_wr32(priv, 0x61020c + (chid * 0x0010), chid);
+	nv_mask(priv, 0x610200 + (chid * 0x0010), 0x00000010, 0x00000010);
+	nv_wr32(priv, 0x640000 + (chid * 0x1000), 0x00000000);
+	nv_wr32(priv, 0x610200 + (chid * 0x0010), 0x00000013);
+
+	/* wait for it to go inactive */
+	if (!nv_wait(priv, 0x610200 + (chid * 0x10), 0x80000000, 0x00000000)) {
+		nv_error(dmac, "init timeout, 0x%08x\n",
+			 nv_rd32(priv, 0x610200 + (chid * 0x10)));
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static int
+nv50_disp_dmac_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp_dmac *dmac = (void *)object;
+	int chid = dmac->base.chid;
+
+	/* deactivate channel */
+	nv_mask(priv, 0x610200 + (chid * 0x0010), 0x00001010, 0x00001000);
+	nv_mask(priv, 0x610200 + (chid * 0x0010), 0x00000003, 0x00000000);
+	if (!nv_wait(priv, 0x610200 + (chid * 0x10), 0x001e0000, 0x00000000)) {
+		nv_error(dmac, "fini timeout, 0x%08x\n",
+			 nv_rd32(priv, 0x610200 + (chid * 0x10)));
+		if (suspend)
+			return -EBUSY;
+	}
+
+	/* disable error reporting and completion notifications */
+	nv_mask(priv, 0x610028, 0x00010001 << chid, 0x00000000 << chid);
+
+	return nv50_disp_chan_fini(&dmac->base, suspend);
+}
+
+/*******************************************************************************
+ * EVO master channel object
+ ******************************************************************************/
+
+static void
+nv50_disp_mthd_list(struct nv50_disp_priv *priv, int debug, u32 base, int c,
+		    const struct nv50_disp_mthd_list *list, int inst)
+{
+	struct nouveau_object *disp = nv_object(priv);
+	int i;
+
+	for (i = 0; list->data[i].mthd; i++) {
+		if (list->data[i].addr) {
+			u32 next = nv_rd32(priv, list->data[i].addr + base + 0);
+			u32 prev = nv_rd32(priv, list->data[i].addr + base + c);
+			u32 mthd = list->data[i].mthd + (list->mthd * inst);
+			const char *name = list->data[i].name;
+			char mods[16];
+
+			if (prev != next)
+				snprintf(mods, sizeof(mods), "-> 0x%08x", next);
+			else
+				snprintf(mods, sizeof(mods), "%13c", ' ');
+
+			nv_printk_(disp, debug, "\t0x%04x: 0x%08x %s%s%s\n",
+				   mthd, prev, mods, name ? " // " : "",
+				   name ? name : "");
+		}
+	}
+}
+
+void
+nv50_disp_mthd_chan(struct nv50_disp_priv *priv, int debug, int head,
+		    const struct nv50_disp_mthd_chan *chan)
+{
+	struct nouveau_object *disp = nv_object(priv);
+	const struct nv50_disp_impl *impl = (void *)disp->oclass;
+	const struct nv50_disp_mthd_list *list;
+	int i, j;
+
+	if (debug > nv_subdev(priv)->debug)
+		return;
+
+	for (i = 0; (list = chan->data[i].mthd) != NULL; i++) {
+		u32 base = head * chan->addr;
+		for (j = 0; j < chan->data[i].nr; j++, base += list->addr) {
+			const char *cname = chan->name;
+			const char *sname = "";
+			char cname_[16], sname_[16];
+
+			if (chan->addr) {
+				snprintf(cname_, sizeof(cname_), "%s %d",
+					 chan->name, head);
+				cname = cname_;
+			}
+
+			if (chan->data[i].nr > 1) {
+				snprintf(sname_, sizeof(sname_), " - %s %d",
+					 chan->data[i].name, j);
+				sname = sname_;
+			}
+
+			nv_printk_(disp, debug, "%s%s:\n", cname, sname);
+			nv50_disp_mthd_list(priv, debug, base, impl->mthd.prev,
+					    list, j);
+		}
+	}
+}
+
+const struct nv50_disp_mthd_list
+nv50_disp_core_mthd_base = {
+	.mthd = 0x0000,
+	.addr = 0x000000,
+	.data = {
+		{ 0x0080, 0x000000 },
+		{ 0x0084, 0x610bb8 },
+		{ 0x0088, 0x610b9c },
+		{ 0x008c, 0x000000 },
+		{}
+	}
+};
+
+static const struct nv50_disp_mthd_list
+nv50_disp_core_mthd_dac = {
+	.mthd = 0x0080,
+	.addr = 0x000008,
+	.data = {
+		{ 0x0400, 0x610b58 },
+		{ 0x0404, 0x610bdc },
+		{ 0x0420, 0x610828 },
+		{}
+	}
+};
+
+const struct nv50_disp_mthd_list
+nv50_disp_core_mthd_sor = {
+	.mthd = 0x0040,
+	.addr = 0x000008,
+	.data = {
+		{ 0x0600, 0x610b70 },
+		{}
+	}
+};
+
+const struct nv50_disp_mthd_list
+nv50_disp_core_mthd_pior = {
+	.mthd = 0x0040,
+	.addr = 0x000008,
+	.data = {
+		{ 0x0700, 0x610b80 },
+		{}
+	}
+};
+
+static const struct nv50_disp_mthd_list
+nv50_disp_core_mthd_head = {
+	.mthd = 0x0400,
+	.addr = 0x000540,
+	.data = {
+		{ 0x0800, 0x610ad8 },
+		{ 0x0804, 0x610ad0 },
+		{ 0x0808, 0x610a48 },
+		{ 0x080c, 0x610a78 },
+		{ 0x0810, 0x610ac0 },
+		{ 0x0814, 0x610af8 },
+		{ 0x0818, 0x610b00 },
+		{ 0x081c, 0x610ae8 },
+		{ 0x0820, 0x610af0 },
+		{ 0x0824, 0x610b08 },
+		{ 0x0828, 0x610b10 },
+		{ 0x082c, 0x610a68 },
+		{ 0x0830, 0x610a60 },
+		{ 0x0834, 0x000000 },
+		{ 0x0838, 0x610a40 },
+		{ 0x0840, 0x610a24 },
+		{ 0x0844, 0x610a2c },
+		{ 0x0848, 0x610aa8 },
+		{ 0x084c, 0x610ab0 },
+		{ 0x0860, 0x610a84 },
+		{ 0x0864, 0x610a90 },
+		{ 0x0868, 0x610b18 },
+		{ 0x086c, 0x610b20 },
+		{ 0x0870, 0x610ac8 },
+		{ 0x0874, 0x610a38 },
+		{ 0x0880, 0x610a58 },
+		{ 0x0884, 0x610a9c },
+		{ 0x08a0, 0x610a70 },
+		{ 0x08a4, 0x610a50 },
+		{ 0x08a8, 0x610ae0 },
+		{ 0x08c0, 0x610b28 },
+		{ 0x08c4, 0x610b30 },
+		{ 0x08c8, 0x610b40 },
+		{ 0x08d4, 0x610b38 },
+		{ 0x08d8, 0x610b48 },
+		{ 0x08dc, 0x610b50 },
+		{ 0x0900, 0x610a18 },
+		{ 0x0904, 0x610ab8 },
+		{}
+	}
+};
+
+static const struct nv50_disp_mthd_chan
+nv50_disp_core_mthd_chan = {
+	.name = "Core",
+	.addr = 0x000000,
+	.data = {
+		{ "Global", 1, &nv50_disp_core_mthd_base },
+		{    "DAC", 3, &nv50_disp_core_mthd_dac  },
+		{    "SOR", 2, &nv50_disp_core_mthd_sor  },
+		{   "PIOR", 3, &nv50_disp_core_mthd_pior },
+		{   "HEAD", 2, &nv50_disp_core_mthd_head },
+		{}
+	}
+};
+
+int
+nv50_disp_core_ctor(struct nouveau_object *parent,
+		    struct nouveau_object *engine,
+		    struct nouveau_oclass *oclass, void *data, u32 size,
+		    struct nouveau_object **pobject)
+{
+	union {
+		struct nv50_disp_core_channel_dma_v0 v0;
+	} *args = data;
+	struct nv50_disp_dmac *mast;
+	int ret;
+
+	nv_ioctl(parent, "create disp core channel dma size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(parent, "create disp core channel dma vers %d "
+				 "pushbuf %08x\n",
+			 args->v0.version, args->v0.pushbuf);
+	} else
+		return ret;
+
+	ret = nv50_disp_dmac_create_(parent, engine, oclass, args->v0.pushbuf,
+				     0, sizeof(*mast), (void **)&mast);
+	*pobject = nv_object(mast);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int
+nv50_disp_core_init(struct nouveau_object *object)
+{
+	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp_dmac *mast = (void *)object;
+	int ret;
+
+	ret = nv50_disp_chan_init(&mast->base);
+	if (ret)
+		return ret;
+
+	/* enable error reporting */
+	nv_mask(priv, 0x610028, 0x00010000, 0x00010000);
+
+	/* attempt to unstick channel from some unknown state */
+	if ((nv_rd32(priv, 0x610200) & 0x009f0000) == 0x00020000)
+		nv_mask(priv, 0x610200, 0x00800000, 0x00800000);
+	if ((nv_rd32(priv, 0x610200) & 0x003f0000) == 0x00030000)
+		nv_mask(priv, 0x610200, 0x00600000, 0x00600000);
+
+	/* initialise channel for dma command submission */
+	nv_wr32(priv, 0x610204, mast->push);
+	nv_wr32(priv, 0x610208, 0x00010000);
+	nv_wr32(priv, 0x61020c, 0x00000000);
+	nv_mask(priv, 0x610200, 0x00000010, 0x00000010);
+	nv_wr32(priv, 0x640000, 0x00000000);
+	nv_wr32(priv, 0x610200, 0x01000013);
+
+	/* wait for it to go inactive */
+	if (!nv_wait(priv, 0x610200, 0x80000000, 0x00000000)) {
+		nv_error(mast, "init: 0x%08x\n", nv_rd32(priv, 0x610200));
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static int
+nv50_disp_core_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp_dmac *mast = (void *)object;
+
+	/* deactivate channel */
+	nv_mask(priv, 0x610200, 0x00000010, 0x00000000);
+	nv_mask(priv, 0x610200, 0x00000003, 0x00000000);
+	if (!nv_wait(priv, 0x610200, 0x001e0000, 0x00000000)) {
+		nv_error(mast, "fini: 0x%08x\n", nv_rd32(priv, 0x610200));
+		if (suspend)
+			return -EBUSY;
+	}
+
+	/* disable error reporting and completion notifications */
+	nv_mask(priv, 0x610028, 0x00010001, 0x00000000);
+
+	return nv50_disp_chan_fini(&mast->base, suspend);
+}
+
+struct nv50_disp_chan_impl
+nv50_disp_core_ofuncs = {
+	.base.ctor = nv50_disp_core_ctor,
+	.base.dtor = nv50_disp_dmac_dtor,
+	.base.init = nv50_disp_core_init,
+	.base.fini = nv50_disp_core_fini,
+	.base.map  = nv50_disp_chan_map,
+	.base.ntfy = nv50_disp_chan_ntfy,
+	.base.rd32 = nv50_disp_chan_rd32,
+	.base.wr32 = nv50_disp_chan_wr32,
+	.chid = 0,
+	.attach = nv50_disp_dmac_object_attach,
+	.detach = nv50_disp_dmac_object_detach,
+};
+
+/*******************************************************************************
+ * EVO sync channel objects
+ ******************************************************************************/
+
+static const struct nv50_disp_mthd_list
+nv50_disp_base_mthd_base = {
+	.mthd = 0x0000,
+	.addr = 0x000000,
+	.data = {
+		{ 0x0080, 0x000000 },
+		{ 0x0084, 0x0008c4 },
+		{ 0x0088, 0x0008d0 },
+		{ 0x008c, 0x0008dc },
+		{ 0x0090, 0x0008e4 },
+		{ 0x0094, 0x610884 },
+		{ 0x00a0, 0x6108a0 },
+		{ 0x00a4, 0x610878 },
+		{ 0x00c0, 0x61086c },
+		{ 0x00e0, 0x610858 },
+		{ 0x00e4, 0x610860 },
+		{ 0x00e8, 0x6108ac },
+		{ 0x00ec, 0x6108b4 },
+		{ 0x0100, 0x610894 },
+		{ 0x0110, 0x6108bc },
+		{ 0x0114, 0x61088c },
+		{}
+	}
+};
+
+const struct nv50_disp_mthd_list
+nv50_disp_base_mthd_image = {
+	.mthd = 0x0400,
+	.addr = 0x000000,
+	.data = {
+		{ 0x0800, 0x6108f0 },
+		{ 0x0804, 0x6108fc },
+		{ 0x0808, 0x61090c },
+		{ 0x080c, 0x610914 },
+		{ 0x0810, 0x610904 },
+		{}
+	}
+};
+
+static const struct nv50_disp_mthd_chan
+nv50_disp_base_mthd_chan = {
+	.name = "Base",
+	.addr = 0x000540,
+	.data = {
+		{ "Global", 1, &nv50_disp_base_mthd_base },
+		{  "Image", 2, &nv50_disp_base_mthd_image },
+		{}
+	}
+};
+
+int
+nv50_disp_base_ctor(struct nouveau_object *parent,
+		    struct nouveau_object *engine,
+		    struct nouveau_oclass *oclass, void *data, u32 size,
+		    struct nouveau_object **pobject)
+{
+	union {
+		struct nv50_disp_base_channel_dma_v0 v0;
+	} *args = data;
+	struct nv50_disp_priv *priv = (void *)engine;
+	struct nv50_disp_dmac *dmac;
+	int ret;
+
+	nv_ioctl(parent, "create disp base channel dma size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(parent, "create disp base channel dma vers %d "
+				 "pushbuf %08x head %d\n",
+			 args->v0.version, args->v0.pushbuf, args->v0.head);
+		if (args->v0.head > priv->head.nr)
+			return -EINVAL;
+	} else
+		return ret;
+
+	ret = nv50_disp_dmac_create_(parent, engine, oclass, args->v0.pushbuf,
+				     args->v0.head, sizeof(*dmac),
+				     (void **)&dmac);
+	*pobject = nv_object(dmac);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+struct nv50_disp_chan_impl
+nv50_disp_base_ofuncs = {
+	.base.ctor = nv50_disp_base_ctor,
+	.base.dtor = nv50_disp_dmac_dtor,
+	.base.init = nv50_disp_dmac_init,
+	.base.fini = nv50_disp_dmac_fini,
+	.base.ntfy = nv50_disp_chan_ntfy,
+	.base.map  = nv50_disp_chan_map,
+	.base.rd32 = nv50_disp_chan_rd32,
+	.base.wr32 = nv50_disp_chan_wr32,
+	.chid = 1,
+	.attach = nv50_disp_dmac_object_attach,
+	.detach = nv50_disp_dmac_object_detach,
+};
+
+/*******************************************************************************
+ * EVO overlay channel objects
+ ******************************************************************************/
+
+const struct nv50_disp_mthd_list
+nv50_disp_ovly_mthd_base = {
+	.mthd = 0x0000,
+	.addr = 0x000000,
+	.data = {
+		{ 0x0080, 0x000000 },
+		{ 0x0084, 0x0009a0 },
+		{ 0x0088, 0x0009c0 },
+		{ 0x008c, 0x0009c8 },
+		{ 0x0090, 0x6109b4 },
+		{ 0x0094, 0x610970 },
+		{ 0x00a0, 0x610998 },
+		{ 0x00a4, 0x610964 },
+		{ 0x00c0, 0x610958 },
+		{ 0x00e0, 0x6109a8 },
+		{ 0x00e4, 0x6109d0 },
+		{ 0x00e8, 0x6109d8 },
+		{ 0x0100, 0x61094c },
+		{ 0x0104, 0x610984 },
+		{ 0x0108, 0x61098c },
+		{ 0x0800, 0x6109f8 },
+		{ 0x0808, 0x610a08 },
+		{ 0x080c, 0x610a10 },
+		{ 0x0810, 0x610a00 },
+		{}
+	}
+};
+
+static const struct nv50_disp_mthd_chan
+nv50_disp_ovly_mthd_chan = {
+	.name = "Overlay",
+	.addr = 0x000540,
+	.data = {
+		{ "Global", 1, &nv50_disp_ovly_mthd_base },
+		{}
+	}
+};
+
+int
+nv50_disp_ovly_ctor(struct nouveau_object *parent,
+		    struct nouveau_object *engine,
+		    struct nouveau_oclass *oclass, void *data, u32 size,
+		    struct nouveau_object **pobject)
+{
+	union {
+		struct nv50_disp_overlay_channel_dma_v0 v0;
+	} *args = data;
+	struct nv50_disp_priv *priv = (void *)engine;
+	struct nv50_disp_dmac *dmac;
+	int ret;
+
+	nv_ioctl(parent, "create disp overlay channel dma size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(parent, "create disp overlay channel dma vers %d "
+				 "pushbuf %08x head %d\n",
+			 args->v0.version, args->v0.pushbuf, args->v0.head);
+		if (args->v0.head > priv->head.nr)
+			return -EINVAL;
+	} else
+		return ret;
+
+	ret = nv50_disp_dmac_create_(parent, engine, oclass, args->v0.pushbuf,
+				     args->v0.head, sizeof(*dmac),
+				     (void **)&dmac);
+	*pobject = nv_object(dmac);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+struct nv50_disp_chan_impl
+nv50_disp_ovly_ofuncs = {
+	.base.ctor = nv50_disp_ovly_ctor,
+	.base.dtor = nv50_disp_dmac_dtor,
+	.base.init = nv50_disp_dmac_init,
+	.base.fini = nv50_disp_dmac_fini,
+	.base.ntfy = nv50_disp_chan_ntfy,
+	.base.map  = nv50_disp_chan_map,
+	.base.rd32 = nv50_disp_chan_rd32,
+	.base.wr32 = nv50_disp_chan_wr32,
+	.chid = 3,
+	.attach = nv50_disp_dmac_object_attach,
+	.detach = nv50_disp_dmac_object_detach,
+};
+
+/*******************************************************************************
+ * EVO PIO channel base class
+ ******************************************************************************/
+
+static int
+nv50_disp_pioc_create_(struct nouveau_object *parent,
+		       struct nouveau_object *engine,
+		       struct nouveau_oclass *oclass, int head,
+		       int length, void **pobject)
+{
+	return nv50_disp_chan_create_(parent, engine, oclass, head,
+				      length, pobject);
+}
+
+void
+nv50_disp_pioc_dtor(struct nouveau_object *object)
+{
+	struct nv50_disp_pioc *pioc = (void *)object;
+	nv50_disp_chan_destroy(&pioc->base);
+}
+
+static int
+nv50_disp_pioc_init(struct nouveau_object *object)
+{
+	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp_pioc *pioc = (void *)object;
+	int chid = pioc->base.chid;
+	int ret;
+
+	ret = nv50_disp_chan_init(&pioc->base);
+	if (ret)
+		return ret;
+
+	nv_wr32(priv, 0x610200 + (chid * 0x10), 0x00002000);
+	if (!nv_wait(priv, 0x610200 + (chid * 0x10), 0x00000000, 0x00000000)) {
+		nv_error(pioc, "timeout0: 0x%08x\n",
+			 nv_rd32(priv, 0x610200 + (chid * 0x10)));
+		return -EBUSY;
+	}
+
+	nv_wr32(priv, 0x610200 + (chid * 0x10), 0x00000001);
+	if (!nv_wait(priv, 0x610200 + (chid * 0x10), 0x00030000, 0x00010000)) {
+		nv_error(pioc, "timeout1: 0x%08x\n",
+			 nv_rd32(priv, 0x610200 + (chid * 0x10)));
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static int
+nv50_disp_pioc_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp_pioc *pioc = (void *)object;
+	int chid = pioc->base.chid;
+
+	nv_mask(priv, 0x610200 + (chid * 0x10), 0x00000001, 0x00000000);
+	if (!nv_wait(priv, 0x610200 + (chid * 0x10), 0x00030000, 0x00000000)) {
+		nv_error(pioc, "timeout: 0x%08x\n",
+			 nv_rd32(priv, 0x610200 + (chid * 0x10)));
+		if (suspend)
+			return -EBUSY;
+	}
+
+	return nv50_disp_chan_fini(&pioc->base, suspend);
+}
+
+/*******************************************************************************
+ * EVO immediate overlay channel objects
+ ******************************************************************************/
+
+int
+nv50_disp_oimm_ctor(struct nouveau_object *parent,
+		    struct nouveau_object *engine,
+		    struct nouveau_oclass *oclass, void *data, u32 size,
+		    struct nouveau_object **pobject)
+{
+	union {
+		struct nv50_disp_overlay_v0 v0;
+	} *args = data;
+	struct nv50_disp_priv *priv = (void *)engine;
+	struct nv50_disp_pioc *pioc;
+	int ret;
+
+	nv_ioctl(parent, "create disp overlay size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(parent, "create disp overlay vers %d head %d\n",
+			 args->v0.version, args->v0.head);
+		if (args->v0.head > priv->head.nr)
+			return -EINVAL;
+	} else
+		return ret;
+
+	ret = nv50_disp_pioc_create_(parent, engine, oclass, args->v0.head,
+				     sizeof(*pioc), (void **)&pioc);
+	*pobject = nv_object(pioc);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+struct nv50_disp_chan_impl
+nv50_disp_oimm_ofuncs = {
+	.base.ctor = nv50_disp_oimm_ctor,
+	.base.dtor = nv50_disp_pioc_dtor,
+	.base.init = nv50_disp_pioc_init,
+	.base.fini = nv50_disp_pioc_fini,
+	.base.ntfy = nv50_disp_chan_ntfy,
+	.base.map  = nv50_disp_chan_map,
+	.base.rd32 = nv50_disp_chan_rd32,
+	.base.wr32 = nv50_disp_chan_wr32,
+	.chid = 5,
+};
+
+/*******************************************************************************
+ * EVO cursor channel objects
+ ******************************************************************************/
+
+int
+nv50_disp_curs_ctor(struct nouveau_object *parent,
+		    struct nouveau_object *engine,
+		    struct nouveau_oclass *oclass, void *data, u32 size,
+		    struct nouveau_object **pobject)
+{
+	union {
+		struct nv50_disp_cursor_v0 v0;
+	} *args = data;
+	struct nv50_disp_priv *priv = (void *)engine;
+	struct nv50_disp_pioc *pioc;
+	int ret;
+
+	nv_ioctl(parent, "create disp cursor size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(parent, "create disp cursor vers %d head %d\n",
+			 args->v0.version, args->v0.head);
+		if (args->v0.head > priv->head.nr)
+			return -EINVAL;
+	} else
+		return ret;
+
+	ret = nv50_disp_pioc_create_(parent, engine, oclass, args->v0.head,
+				     sizeof(*pioc), (void **)&pioc);
+	*pobject = nv_object(pioc);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+struct nv50_disp_chan_impl
+nv50_disp_curs_ofuncs = {
+	.base.ctor = nv50_disp_curs_ctor,
+	.base.dtor = nv50_disp_pioc_dtor,
+	.base.init = nv50_disp_pioc_init,
+	.base.fini = nv50_disp_pioc_fini,
+	.base.ntfy = nv50_disp_chan_ntfy,
+	.base.map  = nv50_disp_chan_map,
+	.base.rd32 = nv50_disp_chan_rd32,
+	.base.wr32 = nv50_disp_chan_wr32,
+	.chid = 7,
+};
+
+/*******************************************************************************
+ * Base display object
+ ******************************************************************************/
+
+int
+nv50_disp_main_scanoutpos(NV50_DISP_MTHD_V0)
+{
+	const u32 blanke = nv_rd32(priv, 0x610aec + (head * 0x540));
+	const u32 blanks = nv_rd32(priv, 0x610af4 + (head * 0x540));
+	const u32 total  = nv_rd32(priv, 0x610afc + (head * 0x540));
+	union {
+		struct nv04_disp_scanoutpos_v0 v0;
+	} *args = data;
+	int ret;
+
+	nv_ioctl(object, "disp scanoutpos size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nv_ioctl(object, "disp scanoutpos vers %d\n", args->v0.version);
+		args->v0.vblanke = (blanke & 0xffff0000) >> 16;
+		args->v0.hblanke = (blanke & 0x0000ffff);
+		args->v0.vblanks = (blanks & 0xffff0000) >> 16;
+		args->v0.hblanks = (blanks & 0x0000ffff);
+		args->v0.vtotal  = ( total & 0xffff0000) >> 16;
+		args->v0.htotal  = ( total & 0x0000ffff);
+		args->v0.time[0] = ktime_to_ns(ktime_get());
+		args->v0.vline = /* vline read locks hline */
+			nv_rd32(priv, 0x616340 + (head * 0x800)) & 0xffff;
+		args->v0.time[1] = ktime_to_ns(ktime_get());
+		args->v0.hline =
+			nv_rd32(priv, 0x616344 + (head * 0x800)) & 0xffff;
+	} else
+		return ret;
+
+	return 0;
+}
+
+int
+nv50_disp_main_mthd(struct nouveau_object *object, u32 mthd,
+		    void *data, u32 size)
+{
+	const struct nv50_disp_impl *impl = (void *)nv_oclass(object->engine);
+	union {
+		struct nv50_disp_mthd_v0 v0;
+		struct nv50_disp_mthd_v1 v1;
+	} *args = data;
+	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nvkm_output *outp = NULL;
+	struct nvkm_output *temp;
+	u16 type, mask = 0;
+	int head, ret;
+
+	if (mthd != NV50_DISP_MTHD)
+		return -EINVAL;
+
+	nv_ioctl(object, "disp mthd size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, true)) {
+		nv_ioctl(object, "disp mthd vers %d mthd %02x head %d\n",
+			 args->v0.version, args->v0.method, args->v0.head);
+		mthd = args->v0.method;
+		head = args->v0.head;
+	} else
+	if (nvif_unpack(args->v1, 1, 1, true)) {
+		nv_ioctl(object, "disp mthd vers %d mthd %02x "
+				 "type %04x mask %04x\n",
+			 args->v1.version, args->v1.method,
+			 args->v1.hasht, args->v1.hashm);
+		mthd = args->v1.method;
+		type = args->v1.hasht;
+		mask = args->v1.hashm;
+		head = ffs((mask >> 8) & 0x0f) - 1;
+	} else
+		return ret;
+
+	if (head < 0 || head >= priv->head.nr)
+		return -ENXIO;
+
+	if (mask) {
+		list_for_each_entry(temp, &priv->base.outp, head) {
+			if ((temp->info.hasht         == type) &&
+			    (temp->info.hashm & mask) == mask) {
+				outp = temp;
+				break;
+			}
+		}
+		if (outp == NULL)
+			return -ENXIO;
+	}
+
+	switch (mthd) {
+	case NV50_DISP_SCANOUTPOS:
+		return impl->head.scanoutpos(object, priv, data, size, head);
+	default:
+		break;
+	}
+
+	switch (mthd * !!outp) {
+	case NV50_DISP_MTHD_V1_DAC_PWR:
+		return priv->dac.power(object, priv, data, size, head, outp);
+	case NV50_DISP_MTHD_V1_DAC_LOAD:
+		return priv->dac.sense(object, priv, data, size, head, outp);
+	case NV50_DISP_MTHD_V1_SOR_PWR:
+		return priv->sor.power(object, priv, data, size, head, outp);
+	case NV50_DISP_MTHD_V1_SOR_HDA_ELD:
+		if (!priv->sor.hda_eld)
+			return -ENODEV;
+		return priv->sor.hda_eld(object, priv, data, size, head, outp);
+	case NV50_DISP_MTHD_V1_SOR_HDMI_PWR:
+		if (!priv->sor.hdmi)
+			return -ENODEV;
+		return priv->sor.hdmi(object, priv, data, size, head, outp);
+	case NV50_DISP_MTHD_V1_SOR_LVDS_SCRIPT: {
+		union {
+			struct nv50_disp_sor_lvds_script_v0 v0;
+		} *args = data;
+		nv_ioctl(object, "disp sor lvds script size %d\n", size);
+		if (nvif_unpack(args->v0, 0, 0, false)) {
+			nv_ioctl(object, "disp sor lvds script "
+					 "vers %d name %04x\n",
+				 args->v0.version, args->v0.script);
+			priv->sor.lvdsconf = args->v0.script;
+			return 0;
+		} else
+			return ret;
+	}
+		break;
+	case NV50_DISP_MTHD_V1_SOR_DP_PWR: {
+		struct nvkm_output_dp *outpdp = (void *)outp;
+		union {
+			struct nv50_disp_sor_dp_pwr_v0 v0;
+		} *args = data;
+		nv_ioctl(object, "disp sor dp pwr size %d\n", size);
+		if (nvif_unpack(args->v0, 0, 0, false)) {
+			nv_ioctl(object, "disp sor dp pwr vers %d state %d\n",
+				 args->v0.version, args->v0.state);
+			if (args->v0.state == 0) {
+				nvkm_notify_put(&outpdp->irq);
+				((struct nvkm_output_dp_impl *)nv_oclass(outp))
+					->lnk_pwr(outpdp, 0);
+				atomic_set(&outpdp->lt.done, 0);
+				return 0;
+			} else
+			if (args->v0.state != 0) {
+				nvkm_output_dp_train(&outpdp->base, 0, true);
+				return 0;
+			}
+		} else
+			return ret;
+	}
+		break;
+	case NV50_DISP_MTHD_V1_PIOR_PWR:
+		if (!priv->pior.power)
+			return -ENODEV;
+		return priv->pior.power(object, priv, data, size, head, outp);
+	default:
+		break;
+	}
+
+	return -EINVAL;
+}
+
+int
+nv50_disp_main_ctor(struct nouveau_object *parent,
+		    struct nouveau_object *engine,
+		    struct nouveau_oclass *oclass, void *data, u32 size,
+		    struct nouveau_object **pobject)
+{
+	struct nv50_disp_priv *priv = (void *)engine;
+	struct nv50_disp_base *base;
+	int ret;
+
+	ret = nouveau_parent_create(parent, engine, oclass, 0,
+				    priv->sclass, 0, &base);
+	*pobject = nv_object(base);
+	if (ret)
+		return ret;
+
+	return nouveau_ramht_new(nv_object(base), nv_object(base), 0x1000, 0,
+				&base->ramht);
+}
+
+void
+nv50_disp_main_dtor(struct nouveau_object *object)
+{
+	struct nv50_disp_base *base = (void *)object;
+	nouveau_ramht_ref(NULL, &base->ramht);
+	nouveau_parent_destroy(&base->base);
+}
+
+static int
+nv50_disp_main_init(struct nouveau_object *object)
+{
+	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp_base *base = (void *)object;
+	int ret, i;
+	u32 tmp;
+
+	ret = nouveau_parent_init(&base->base);
+	if (ret)
+		return ret;
+
+	/* The below segments of code copying values from one register to
+	 * another appear to inform EVO of the display capabilities or
+	 * something similar.  NFI what the 0x614004 caps are for..
+	 */
+	tmp = nv_rd32(priv, 0x614004);
+	nv_wr32(priv, 0x610184, tmp);
+
+	/* ... CRTC caps */
+	for (i = 0; i < priv->head.nr; i++) {
+		tmp = nv_rd32(priv, 0x616100 + (i * 0x800));
+		nv_wr32(priv, 0x610190 + (i * 0x10), tmp);
+		tmp = nv_rd32(priv, 0x616104 + (i * 0x800));
+		nv_wr32(priv, 0x610194 + (i * 0x10), tmp);
+		tmp = nv_rd32(priv, 0x616108 + (i * 0x800));
+		nv_wr32(priv, 0x610198 + (i * 0x10), tmp);
+		tmp = nv_rd32(priv, 0x61610c + (i * 0x800));
+		nv_wr32(priv, 0x61019c + (i * 0x10), tmp);
+	}
+
+	/* ... DAC caps */
+	for (i = 0; i < priv->dac.nr; i++) {
+		tmp = nv_rd32(priv, 0x61a000 + (i * 0x800));
+		nv_wr32(priv, 0x6101d0 + (i * 0x04), tmp);
+	}
+
+	/* ... SOR caps */
+	for (i = 0; i < priv->sor.nr; i++) {
+		tmp = nv_rd32(priv, 0x61c000 + (i * 0x800));
+		nv_wr32(priv, 0x6101e0 + (i * 0x04), tmp);
+	}
+
+	/* ... PIOR caps */
+	for (i = 0; i < priv->pior.nr; i++) {
+		tmp = nv_rd32(priv, 0x61e000 + (i * 0x800));
+		nv_wr32(priv, 0x6101f0 + (i * 0x04), tmp);
+	}
+
+	/* steal display away from vbios, or something like that */
+	if (nv_rd32(priv, 0x610024) & 0x00000100) {
+		nv_wr32(priv, 0x610024, 0x00000100);
+		nv_mask(priv, 0x6194e8, 0x00000001, 0x00000000);
+		if (!nv_wait(priv, 0x6194e8, 0x00000002, 0x00000000)) {
+			nv_error(priv, "timeout acquiring display\n");
+			return -EBUSY;
+		}
+	}
+
+	/* point at display engine memory area (hash table, objects) */
+	nv_wr32(priv, 0x610010, (nv_gpuobj(base->ramht)->addr >> 8) | 9);
+
+	/* enable supervisor interrupts, disable everything else */
+	nv_wr32(priv, 0x61002c, 0x00000370);
+	nv_wr32(priv, 0x610028, 0x00000000);
+	return 0;
+}
+
+static int
+nv50_disp_main_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nv50_disp_priv *priv = (void *)object->engine;
+	struct nv50_disp_base *base = (void *)object;
+
+	/* disable all interrupts */
+	nv_wr32(priv, 0x610024, 0x00000000);
+	nv_wr32(priv, 0x610020, 0x00000000);
+
+	return nouveau_parent_fini(&base->base, suspend);
+}
+
+struct nouveau_ofuncs
+nv50_disp_main_ofuncs = {
+	.ctor = nv50_disp_main_ctor,
+	.dtor = nv50_disp_main_dtor,
+	.init = nv50_disp_main_init,
+	.fini = nv50_disp_main_fini,
+	.mthd = nv50_disp_main_mthd,
+	.ntfy = nouveau_disp_ntfy,
+};
+
+static struct nouveau_oclass
+nv50_disp_main_oclass[] = {
+	{ NV50_DISP, &nv50_disp_main_ofuncs },
+	{}
+};
+
+static struct nouveau_oclass
+nv50_disp_sclass[] = {
+	{ NV50_DISP_CORE_CHANNEL_DMA, &nv50_disp_core_ofuncs.base },
+	{ NV50_DISP_BASE_CHANNEL_DMA, &nv50_disp_base_ofuncs.base },
+	{ NV50_DISP_OVERLAY_CHANNEL_DMA, &nv50_disp_ovly_ofuncs.base },
+	{ NV50_DISP_OVERLAY, &nv50_disp_oimm_ofuncs.base },
+	{ NV50_DISP_CURSOR, &nv50_disp_curs_ofuncs.base },
+	{}
+};
+
+/*******************************************************************************
+ * Display context, tracks instmem allocation and prevents more than one
+ * client using the display hardware at any time.
+ ******************************************************************************/
+
+static int
+nv50_disp_data_ctor(struct nouveau_object *parent,
+		    struct nouveau_object *engine,
+		    struct nouveau_oclass *oclass, void *data, u32 size,
+		    struct nouveau_object **pobject)
+{
+	struct nv50_disp_priv *priv = (void *)engine;
+	struct nouveau_engctx *ectx;
+	int ret = -EBUSY;
+
+	/* no context needed for channel objects... */
+	if (nv_mclass(parent) != NV_DEVICE) {
+		atomic_inc(&parent->refcount);
+		*pobject = parent;
+		return 1;
+	}
+
+	/* allocate display hardware to client */
+	mutex_lock(&nv_subdev(priv)->mutex);
+	if (list_empty(&nv_engine(priv)->contexts)) {
+		ret = nouveau_engctx_create(parent, engine, oclass, NULL,
+					    0x10000, 0x10000,
+					    NVOBJ_FLAG_HEAP, &ectx);
+		*pobject = nv_object(ectx);
+	}
+	mutex_unlock(&nv_subdev(priv)->mutex);
+	return ret;
+}
+
+struct nouveau_oclass
+nv50_disp_cclass = {
+	.handle = NV_ENGCTX(DISP, 0x50),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv50_disp_data_ctor,
+		.dtor = _nouveau_engctx_dtor,
+		.init = _nouveau_engctx_init,
+		.fini = _nouveau_engctx_fini,
+		.rd32 = _nouveau_engctx_rd32,
+		.wr32 = _nouveau_engctx_wr32,
+	},
+};
+
+/*******************************************************************************
+ * Display engine implementation
+ ******************************************************************************/
+
+static void
+nv50_disp_vblank_fini(struct nvkm_event *event, int type, int head)
+{
+	struct nouveau_disp *disp = container_of(event, typeof(*disp), vblank);
+	nv_mask(disp, 0x61002c, (4 << head), 0);
+}
+
+static void
+nv50_disp_vblank_init(struct nvkm_event *event, int type, int head)
+{
+	struct nouveau_disp *disp = container_of(event, typeof(*disp), vblank);
+	nv_mask(disp, 0x61002c, (4 << head), (4 << head));
+}
+
+const struct nvkm_event_func
+nv50_disp_vblank_func = {
+	.ctor = nouveau_disp_vblank_ctor,
+	.init = nv50_disp_vblank_init,
+	.fini = nv50_disp_vblank_fini,
+};
+
+static const struct nouveau_enum
+nv50_disp_intr_error_type[] = {
+	{ 3, "ILLEGAL_MTHD" },
+	{ 4, "INVALID_VALUE" },
+	{ 5, "INVALID_STATE" },
+	{ 7, "INVALID_HANDLE" },
+	{}
+};
+
+static const struct nouveau_enum
+nv50_disp_intr_error_code[] = {
+	{ 0x00, "" },
+	{}
+};
+
+static void
+nv50_disp_intr_error(struct nv50_disp_priv *priv, int chid)
+{
+	struct nv50_disp_impl *impl = (void *)nv_object(priv)->oclass;
+	u32 data = nv_rd32(priv, 0x610084 + (chid * 0x08));
+	u32 addr = nv_rd32(priv, 0x610080 + (chid * 0x08));
+	u32 code = (addr & 0x00ff0000) >> 16;
+	u32 type = (addr & 0x00007000) >> 12;
+	u32 mthd = (addr & 0x00000ffc);
+	const struct nouveau_enum *ec, *et;
+	char ecunk[6], etunk[6];
+
+	et = nouveau_enum_find(nv50_disp_intr_error_type, type);
+	if (!et)
+		snprintf(etunk, sizeof(etunk), "UNK%02X", type);
+
+	ec = nouveau_enum_find(nv50_disp_intr_error_code, code);
+	if (!ec)
+		snprintf(ecunk, sizeof(ecunk), "UNK%02X", code);
+
+	nv_error(priv, "%s [%s] chid %d mthd 0x%04x data 0x%08x\n",
+		 et ? et->name : etunk, ec ? ec->name : ecunk,
+		 chid, mthd, data);
+
+	if (chid == 0) {
+		switch (mthd) {
+		case 0x0080:
+			nv50_disp_mthd_chan(priv, NV_DBG_ERROR, chid - 0,
+					    impl->mthd.core);
+			break;
+		default:
+			break;
+		}
+	} else
+	if (chid <= 2) {
+		switch (mthd) {
+		case 0x0080:
+			nv50_disp_mthd_chan(priv, NV_DBG_ERROR, chid - 1,
+					    impl->mthd.base);
+			break;
+		default:
+			break;
+		}
+	} else
+	if (chid <= 4) {
+		switch (mthd) {
+		case 0x0080:
+			nv50_disp_mthd_chan(priv, NV_DBG_ERROR, chid - 3,
+					    impl->mthd.ovly);
+			break;
+		default:
+			break;
+		}
+	}
+
+	nv_wr32(priv, 0x610020, 0x00010000 << chid);
+	nv_wr32(priv, 0x610080 + (chid * 0x08), 0x90000000);
+}
+
+static struct nvkm_output *
+exec_lookup(struct nv50_disp_priv *priv, int head, int or, u32 ctrl,
+	    u32 *data, u8 *ver, u8 *hdr, u8 *cnt, u8 *len,
+	    struct nvbios_outp *info)
+{
+	struct nouveau_bios *bios = nouveau_bios(priv);
+	struct nvkm_output *outp;
+	u16 mask, type;
+
+	if (or < 4) {
+		type = DCB_OUTPUT_ANALOG;
+		mask = 0;
+	} else
+	if (or < 8) {
+		switch (ctrl & 0x00000f00) {
+		case 0x00000000: type = DCB_OUTPUT_LVDS; mask = 1; break;
+		case 0x00000100: type = DCB_OUTPUT_TMDS; mask = 1; break;
+		case 0x00000200: type = DCB_OUTPUT_TMDS; mask = 2; break;
+		case 0x00000500: type = DCB_OUTPUT_TMDS; mask = 3; break;
+		case 0x00000800: type = DCB_OUTPUT_DP; mask = 1; break;
+		case 0x00000900: type = DCB_OUTPUT_DP; mask = 2; break;
+		default:
+			nv_error(priv, "unknown SOR mc 0x%08x\n", ctrl);
+			return NULL;
+		}
+		or  -= 4;
+	} else {
+		or   = or - 8;
+		type = 0x0010;
+		mask = 0;
+		switch (ctrl & 0x00000f00) {
+		case 0x00000000: type |= priv->pior.type[or]; break;
+		default:
+			nv_error(priv, "unknown PIOR mc 0x%08x\n", ctrl);
+			return NULL;
+		}
+	}
+
+	mask  = 0x00c0 & (mask << 6);
+	mask |= 0x0001 << or;
+	mask |= 0x0100 << head;
+
+	list_for_each_entry(outp, &priv->base.outp, head) {
+		if ((outp->info.hasht & 0xff) == type &&
+		    (outp->info.hashm & mask) == mask) {
+			*data = nvbios_outp_match(bios, outp->info.hasht,
+							outp->info.hashm,
+						  ver, hdr, cnt, len, info);
+			if (!*data)
+				return NULL;
+			return outp;
+		}
+	}
+
+	return NULL;
+}
+
+static struct nvkm_output *
+exec_script(struct nv50_disp_priv *priv, int head, int id)
+{
+	struct nouveau_bios *bios = nouveau_bios(priv);
+	struct nvkm_output *outp;
+	struct nvbios_outp info;
+	u8  ver, hdr, cnt, len;
+	u32 data, ctrl = 0;
+	u32 reg;
+	int i;
+
+	/* DAC */
+	for (i = 0; !(ctrl & (1 << head)) && i < priv->dac.nr; i++)
+		ctrl = nv_rd32(priv, 0x610b5c + (i * 8));
+
+	/* SOR */
+	if (!(ctrl & (1 << head))) {
+		if (nv_device(priv)->chipset  < 0x90 ||
+		    nv_device(priv)->chipset == 0x92 ||
+		    nv_device(priv)->chipset == 0xa0) {
+			reg = 0x610b74;
+		} else {
+			reg = 0x610798;
+		}
+		for (i = 0; !(ctrl & (1 << head)) && i < priv->sor.nr; i++)
+			ctrl = nv_rd32(priv, reg + (i * 8));
+		i += 4;
+	}
+
+	/* PIOR */
+	if (!(ctrl & (1 << head))) {
+		for (i = 0; !(ctrl & (1 << head)) && i < priv->pior.nr; i++)
+			ctrl = nv_rd32(priv, 0x610b84 + (i * 8));
+		i += 8;
+	}
+
+	if (!(ctrl & (1 << head)))
+		return NULL;
+	i--;
+
+	outp = exec_lookup(priv, head, i, ctrl, &data, &ver, &hdr, &cnt, &len, &info);
+	if (outp) {
+		struct nvbios_init init = {
+			.subdev = nv_subdev(priv),
+			.bios = bios,
+			.offset = info.script[id],
+			.outp = &outp->info,
+			.crtc = head,
+			.execute = 1,
+		};
+
+		nvbios_exec(&init);
+	}
+
+	return outp;
+}
+
+static struct nvkm_output *
+exec_clkcmp(struct nv50_disp_priv *priv, int head, int id, u32 pclk, u32 *conf)
+{
+	struct nouveau_bios *bios = nouveau_bios(priv);
+	struct nvkm_output *outp;
+	struct nvbios_outp info1;
+	struct nvbios_ocfg info2;
+	u8  ver, hdr, cnt, len;
+	u32 data, ctrl = 0;
+	u32 reg;
+	int i;
+
+	/* DAC */
+	for (i = 0; !(ctrl & (1 << head)) && i < priv->dac.nr; i++)
+		ctrl = nv_rd32(priv, 0x610b58 + (i * 8));
+
+	/* SOR */
+	if (!(ctrl & (1 << head))) {
+		if (nv_device(priv)->chipset  < 0x90 ||
+		    nv_device(priv)->chipset == 0x92 ||
+		    nv_device(priv)->chipset == 0xa0) {
+			reg = 0x610b70;
+		} else {
+			reg = 0x610794;
+		}
+		for (i = 0; !(ctrl & (1 << head)) && i < priv->sor.nr; i++)
+			ctrl = nv_rd32(priv, reg + (i * 8));
+		i += 4;
+	}
+
+	/* PIOR */
+	if (!(ctrl & (1 << head))) {
+		for (i = 0; !(ctrl & (1 << head)) && i < priv->pior.nr; i++)
+			ctrl = nv_rd32(priv, 0x610b80 + (i * 8));
+		i += 8;
+	}
+
+	if (!(ctrl & (1 << head)))
+		return NULL;
+	i--;
+
+	outp = exec_lookup(priv, head, i, ctrl, &data, &ver, &hdr, &cnt, &len, &info1);
+	if (!outp)
+		return NULL;
+
+	if (outp->info.location == 0) {
+		switch (outp->info.type) {
+		case DCB_OUTPUT_TMDS:
+			*conf = (ctrl & 0x00000f00) >> 8;
+			if (pclk >= 165000)
+				*conf |= 0x0100;
+			break;
+		case DCB_OUTPUT_LVDS:
+			*conf = priv->sor.lvdsconf;
+			break;
+		case DCB_OUTPUT_DP:
+			*conf = (ctrl & 0x00000f00) >> 8;
+			break;
+		case DCB_OUTPUT_ANALOG:
+		default:
+			*conf = 0x00ff;
+			break;
+		}
+	} else {
+		*conf = (ctrl & 0x00000f00) >> 8;
+		pclk = pclk / 2;
+	}
+
+	data = nvbios_ocfg_match(bios, data, *conf, &ver, &hdr, &cnt, &len, &info2);
+	if (data && id < 0xff) {
+		data = nvbios_oclk_match(bios, info2.clkcmp[id], pclk);
+		if (data) {
+			struct nvbios_init init = {
+				.subdev = nv_subdev(priv),
+				.bios = bios,
+				.offset = data,
+				.outp = &outp->info,
+				.crtc = head,
+				.execute = 1,
+			};
+
+			nvbios_exec(&init);
+		}
+	}
+
+	return outp;
+}
+
+static void
+nv50_disp_intr_unk10_0(struct nv50_disp_priv *priv, int head)
+{
+	exec_script(priv, head, 1);
+}
+
+static void
+nv50_disp_intr_unk20_0(struct nv50_disp_priv *priv, int head)
+{
+	struct nvkm_output *outp = exec_script(priv, head, 2);
+
+	/* the binary driver does this outside of the supervisor handling
+	 * (after the third supervisor from a detach).  we (currently?)
+	 * allow both detach/attach to happen in the same set of
+	 * supervisor interrupts, so it would make sense to execute this
+	 * (full power down?) script after all the detach phases of the
+	 * supervisor handling.  like with training if needed from the
+	 * second supervisor, nvidia doesn't do this, so who knows if it's
+	 * entirely safe, but it does appear to work..
+	 *
+	 * without this script being run, on some configurations i've
+	 * seen, switching from DP to TMDS on a DP connector may result
+	 * in a blank screen (SOR_PWR off/on can restore it)
+	 */
+	if (outp && outp->info.type == DCB_OUTPUT_DP) {
+		struct nvkm_output_dp *outpdp = (void *)outp;
+		struct nvbios_init init = {
+			.subdev = nv_subdev(priv),
+			.bios = nouveau_bios(priv),
+			.outp = &outp->info,
+			.crtc = head,
+			.offset = outpdp->info.script[4],
+			.execute = 1,
+		};
+
+		nvbios_exec(&init);
+		atomic_set(&outpdp->lt.done, 0);
+	}
+}
+
+static void
+nv50_disp_intr_unk20_1(struct nv50_disp_priv *priv, int head)
+{
+	struct nouveau_devinit *devinit = nouveau_devinit(priv);
+	u32 pclk = nv_rd32(priv, 0x610ad0 + (head * 0x540)) & 0x3fffff;
+	if (pclk)
+		devinit->pll_set(devinit, PLL_VPLL0 + head, pclk);
+}
+
+static void
+nv50_disp_intr_unk20_2_dp(struct nv50_disp_priv *priv, int head,
+			  struct dcb_output *outp, u32 pclk)
+{
+	const int link = !(outp->sorconf.link & 1);
+	const int   or = ffs(outp->or) - 1;
+	const u32 soff = (  or * 0x800);
+	const u32 loff = (link * 0x080) + soff;
+	const u32 ctrl = nv_rd32(priv, 0x610794 + (or * 8));
+	const u32 symbol = 100000;
+	const s32 vactive = nv_rd32(priv, 0x610af8 + (head * 0x540)) & 0xffff;
+	const s32 vblanke = nv_rd32(priv, 0x610ae8 + (head * 0x540)) & 0xffff;
+	const s32 vblanks = nv_rd32(priv, 0x610af0 + (head * 0x540)) & 0xffff;
+	u32 dpctrl = nv_rd32(priv, 0x61c10c + loff);
+	u32 clksor = nv_rd32(priv, 0x614300 + soff);
+	int bestTU = 0, bestVTUi = 0, bestVTUf = 0, bestVTUa = 0;
+	int TU, VTUi, VTUf, VTUa;
+	u64 link_data_rate, link_ratio, unk;
+	u32 best_diff = 64 * symbol;
+	u32 link_nr, link_bw, bits;
+	u64 value;
+
+	link_bw = (clksor & 0x000c0000) ? 270000 : 162000;
+	link_nr = hweight32(dpctrl & 0x000f0000);
+
+	/* symbols/hblank - algorithm taken from comments in tegra driver */
+	value = vblanke + vactive - vblanks - 7;
+	value = value * link_bw;
+	do_div(value, pclk);
+	value = value - (3 * !!(dpctrl & 0x00004000)) - (12 / link_nr);
+	nv_mask(priv, 0x61c1e8 + soff, 0x0000ffff, value);
+
+	/* symbols/vblank - algorithm taken from comments in tegra driver */
+	value = vblanks - vblanke - 25;
+	value = value * link_bw;
+	do_div(value, pclk);
+	value = value - ((36 / link_nr) + 3) - 1;
+	nv_mask(priv, 0x61c1ec + soff, 0x00ffffff, value);
+
+	/* watermark / activesym */
+	if      ((ctrl & 0xf0000) == 0x60000) bits = 30;
+	else if ((ctrl & 0xf0000) == 0x50000) bits = 24;
+	else                                  bits = 18;
+
+	link_data_rate = (pclk * bits / 8) / link_nr;
+
+	/* calculate ratio of packed data rate to link symbol rate */
+	link_ratio = link_data_rate * symbol;
+	do_div(link_ratio, link_bw);
+
+	for (TU = 64; TU >= 32; TU--) {
+		/* calculate average number of valid symbols in each TU */
+		u32 tu_valid = link_ratio * TU;
+		u32 calc, diff;
+
+		/* find a hw representation for the fraction.. */
+		VTUi = tu_valid / symbol;
+		calc = VTUi * symbol;
+		diff = tu_valid - calc;
+		if (diff) {
+			if (diff >= (symbol / 2)) {
+				VTUf = symbol / (symbol - diff);
+				if (symbol - (VTUf * diff))
+					VTUf++;
+
+				if (VTUf <= 15) {
+					VTUa  = 1;
+					calc += symbol - (symbol / VTUf);
+				} else {
+					VTUa  = 0;
+					VTUf  = 1;
+					calc += symbol;
+				}
+			} else {
+				VTUa  = 0;
+				VTUf  = min((int)(symbol / diff), 15);
+				calc += symbol / VTUf;
+			}
+
+			diff = calc - tu_valid;
+		} else {
+			/* no remainder, but the hw doesn't like the fractional
+			 * part to be zero.  decrement the integer part and
+			 * have the fraction add a whole symbol back
+			 */
+			VTUa = 0;
+			VTUf = 1;
+			VTUi--;
+		}
+
+		if (diff < best_diff) {
+			best_diff = diff;
+			bestTU = TU;
+			bestVTUa = VTUa;
+			bestVTUf = VTUf;
+			bestVTUi = VTUi;
+			if (diff == 0)
+				break;
+		}
+	}
+
+	if (!bestTU) {
+		nv_error(priv, "unable to find suitable dp config\n");
+		return;
+	}
+
+	/* XXX close to vbios numbers, but not right */
+	unk  = (symbol - link_ratio) * bestTU;
+	unk *= link_ratio;
+	do_div(unk, symbol);
+	do_div(unk, symbol);
+	unk += 6;
+
+	nv_mask(priv, 0x61c10c + loff, 0x000001fc, bestTU << 2);
+	nv_mask(priv, 0x61c128 + loff, 0x010f7f3f, bestVTUa << 24 |
+						   bestVTUf << 16 |
+						   bestVTUi << 8 | unk);
+}
+
+static void
+nv50_disp_intr_unk20_2(struct nv50_disp_priv *priv, int head)
+{
+	struct nvkm_output *outp;
+	u32 pclk = nv_rd32(priv, 0x610ad0 + (head * 0x540)) & 0x3fffff;
+	u32 hval, hreg = 0x614200 + (head * 0x800);
+	u32 oval, oreg;
+	u32 mask, conf;
+
+	outp = exec_clkcmp(priv, head, 0xff, pclk, &conf);
+	if (!outp)
+		return;
+
+	/* we allow both encoder attach and detach operations to occur
+	 * within a single supervisor (ie. modeset) sequence.  the
+	 * encoder detach scripts quite often switch off power to the
+	 * lanes, which requires the link to be re-trained.
+	 *
+	 * this is not generally an issue as the sink "must" (heh)
+	 * signal an irq when it's lost sync so the driver can
+	 * re-train.
+	 *
+	 * however, on some boards, if one does not configure at least
+	 * the gpu side of the link *before* attaching, then various
+	 * things can go horribly wrong (PDISP disappearing from mmio,
+	 * third supervisor never happens, etc).
+	 *
+	 * the solution is simply to retrain here, if necessary.  last
+	 * i checked, the binary driver userspace does not appear to
+	 * trigger this situation (it forces an UPDATE between steps).
+	 */
+	if (outp->info.type == DCB_OUTPUT_DP) {
+		u32 soff = (ffs(outp->info.or) - 1) * 0x08;
+		u32 ctrl, datarate;
+
+		if (outp->info.location == 0) {
+			ctrl = nv_rd32(priv, 0x610794 + soff);
+			soff = 1;
+		} else {
+			ctrl = nv_rd32(priv, 0x610b80 + soff);
+			soff = 2;
+		}
+
+		switch ((ctrl & 0x000f0000) >> 16) {
+		case 6: datarate = pclk * 30; break;
+		case 5: datarate = pclk * 24; break;
+		case 2:
+		default:
+			datarate = pclk * 18;
+			break;
+		}
+
+		if (nvkm_output_dp_train(outp, datarate / soff, true))
+			ERR("link not trained before attach\n");
+	}
+
+	exec_clkcmp(priv, head, 0, pclk, &conf);
+
+	if (!outp->info.location && outp->info.type == DCB_OUTPUT_ANALOG) {
+		oreg = 0x614280 + (ffs(outp->info.or) - 1) * 0x800;
+		oval = 0x00000000;
+		hval = 0x00000000;
+		mask = 0xffffffff;
+	} else
+	if (!outp->info.location) {
+		if (outp->info.type == DCB_OUTPUT_DP)
+			nv50_disp_intr_unk20_2_dp(priv, head, &outp->info, pclk);
+		oreg = 0x614300 + (ffs(outp->info.or) - 1) * 0x800;
+		oval = (conf & 0x0100) ? 0x00000101 : 0x00000000;
+		hval = 0x00000000;
+		mask = 0x00000707;
+	} else {
+		oreg = 0x614380 + (ffs(outp->info.or) - 1) * 0x800;
+		oval = 0x00000001;
+		hval = 0x00000001;
+		mask = 0x00000707;
+	}
+
+	nv_mask(priv, hreg, 0x0000000f, hval);
+	nv_mask(priv, oreg, mask, oval);
+}
+
+/* If programming a TMDS output on a SOR that can also be configured for
+ * DisplayPort, make sure NV50_SOR_DP_CTRL_ENABLE is forced off.
+ *
+ * It looks like the VBIOS TMDS scripts make an attempt at this, however,
+ * the VBIOS scripts on at least one board I have only switch it off on
+ * link 0, causing a blank display if the output has previously been
+ * programmed for DisplayPort.
+ */
+static void
+nv50_disp_intr_unk40_0_tmds(struct nv50_disp_priv *priv, struct dcb_output *outp)
+{
+	struct nouveau_bios *bios = nouveau_bios(priv);
+	const int link = !(outp->sorconf.link & 1);
+	const int   or = ffs(outp->or) - 1;
+	const u32 loff = (or * 0x800) + (link * 0x80);
+	const u16 mask = (outp->sorconf.link << 6) | outp->or;
+	struct dcb_output match;
+	u8  ver, hdr;
+
+	if (dcb_outp_match(bios, DCB_OUTPUT_DP, mask, &ver, &hdr, &match))
+		nv_mask(priv, 0x61c10c + loff, 0x00000001, 0x00000000);
+}
+
+static void
+nv50_disp_intr_unk40_0(struct nv50_disp_priv *priv, int head)
+{
+	struct nvkm_output *outp;
+	u32 pclk = nv_rd32(priv, 0x610ad0 + (head * 0x540)) & 0x3fffff;
+	u32 conf;
+
+	outp = exec_clkcmp(priv, head, 1, pclk, &conf);
+	if (!outp)
+		return;
+
+	if (outp->info.location == 0 && outp->info.type == DCB_OUTPUT_TMDS)
+		nv50_disp_intr_unk40_0_tmds(priv, &outp->info);
+}
+
+void
+nv50_disp_intr_supervisor(struct work_struct *work)
+{
+	struct nv50_disp_priv *priv =
+		container_of(work, struct nv50_disp_priv, supervisor);
+	struct nv50_disp_impl *impl = (void *)nv_object(priv)->oclass;
+	u32 super = nv_rd32(priv, 0x610030);
+	int head;
+
+	nv_debug(priv, "supervisor 0x%08x 0x%08x\n", priv->super, super);
+
+	if (priv->super & 0x00000010) {
+		nv50_disp_mthd_chan(priv, NV_DBG_DEBUG, 0, impl->mthd.core);
+		for (head = 0; head < priv->head.nr; head++) {
+			if (!(super & (0x00000020 << head)))
+				continue;
+			if (!(super & (0x00000080 << head)))
+				continue;
+			nv50_disp_intr_unk10_0(priv, head);
+		}
+	} else
+	if (priv->super & 0x00000020) {
+		for (head = 0; head < priv->head.nr; head++) {
+			if (!(super & (0x00000080 << head)))
+				continue;
+			nv50_disp_intr_unk20_0(priv, head);
+		}
+		for (head = 0; head < priv->head.nr; head++) {
+			if (!(super & (0x00000200 << head)))
+				continue;
+			nv50_disp_intr_unk20_1(priv, head);
+		}
+		for (head = 0; head < priv->head.nr; head++) {
+			if (!(super & (0x00000080 << head)))
+				continue;
+			nv50_disp_intr_unk20_2(priv, head);
+		}
+	} else
+	if (priv->super & 0x00000040) {
+		for (head = 0; head < priv->head.nr; head++) {
+			if (!(super & (0x00000080 << head)))
+				continue;
+			nv50_disp_intr_unk40_0(priv, head);
+		}
+	}
+
+	nv_wr32(priv, 0x610030, 0x80000000);
+}
+
+void
+nv50_disp_intr(struct nouveau_subdev *subdev)
+{
+	struct nv50_disp_priv *priv = (void *)subdev;
+	u32 intr0 = nv_rd32(priv, 0x610020);
+	u32 intr1 = nv_rd32(priv, 0x610024);
+
+	while (intr0 & 0x001f0000) {
+		u32 chid = __ffs(intr0 & 0x001f0000) - 16;
+		nv50_disp_intr_error(priv, chid);
+		intr0 &= ~(0x00010000 << chid);
+	}
+
+	while (intr0 & 0x0000001f) {
+		u32 chid = __ffs(intr0 & 0x0000001f);
+		nv50_disp_chan_uevent_send(priv, chid);
+		intr0 &= ~(0x00000001 << chid);
+	}
+
+	if (intr1 & 0x00000004) {
+		nouveau_disp_vblank(&priv->base, 0);
+		nv_wr32(priv, 0x610024, 0x00000004);
+		intr1 &= ~0x00000004;
+	}
+
+	if (intr1 & 0x00000008) {
+		nouveau_disp_vblank(&priv->base, 1);
+		nv_wr32(priv, 0x610024, 0x00000008);
+		intr1 &= ~0x00000008;
+	}
+
+	if (intr1 & 0x00000070) {
+		priv->super = (intr1 & 0x00000070);
+		schedule_work(&priv->supervisor);
+		nv_wr32(priv, 0x610024, priv->super);
+		intr1 &= ~0x00000070;
+	}
+}
+
+static int
+nv50_disp_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+	       struct nouveau_oclass *oclass, void *data, u32 size,
+	       struct nouveau_object **pobject)
+{
+	struct nv50_disp_priv *priv;
+	int ret;
+
+	ret = nouveau_disp_create(parent, engine, oclass, 2, "PDISP",
+				  "display", &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	ret = nvkm_event_init(&nv50_disp_chan_uevent, 1, 9, &priv->uevent);
+	if (ret)
+		return ret;
+
+	nv_engine(priv)->sclass = nv50_disp_main_oclass;
+	nv_engine(priv)->cclass = &nv50_disp_cclass;
+	nv_subdev(priv)->intr = nv50_disp_intr;
+	INIT_WORK(&priv->supervisor, nv50_disp_intr_supervisor);
+	priv->sclass = nv50_disp_sclass;
+	priv->head.nr = 2;
+	priv->dac.nr = 3;
+	priv->sor.nr = 2;
+	priv->pior.nr = 3;
+	priv->dac.power = nv50_dac_power;
+	priv->dac.sense = nv50_dac_sense;
+	priv->sor.power = nv50_sor_power;
+	priv->pior.power = nv50_pior_power;
+	return 0;
+}
+
+struct nouveau_oclass *
+nv50_disp_outp_sclass[] = {
+	&nv50_pior_dp_impl.base.base,
+	NULL
+};
+
+struct nouveau_oclass *
+nv50_disp_oclass = &(struct nv50_disp_impl) {
+	.base.base.handle = NV_ENGINE(DISP, 0x50),
+	.base.base.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv50_disp_ctor,
+		.dtor = _nouveau_disp_dtor,
+		.init = _nouveau_disp_init,
+		.fini = _nouveau_disp_fini,
+	},
+	.base.vblank = &nv50_disp_vblank_func,
+	.base.outp =  nv50_disp_outp_sclass,
+	.mthd.core = &nv50_disp_core_mthd_chan,
+	.mthd.base = &nv50_disp_base_mthd_chan,
+	.mthd.ovly = &nv50_disp_ovly_mthd_chan,
+	.mthd.prev = 0x000004,
+	.head.scanoutpos = nv50_disp_main_scanoutpos,
+}.base.base;
