commit 7ec60c044069ac40fd0f28e2469b9dde9ea6e4ca
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed May 6 14:40:58 2020 +1000

    drm/nouveau/disp/hda/gf119-: select HDA device entry based on bound head
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
index 8a0ec7db5145..19d2d58344e4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
@@ -28,14 +28,14 @@ gf119_hda_device_entry(struct nvkm_ior *ior, int head)
 {
 	struct nvkm_device *device = ior->disp->engine.subdev.device;
 	const u32 hoff = 0x800 * head;
-	nvkm_mask(device, 0x616548 + hoff, 0x00000070, 0x00000000);
+	nvkm_mask(device, 0x616548 + hoff, 0x00000070, head << 4);
 }
 
 void
 gf119_hda_eld(struct nvkm_ior *ior, int head, u8 *data, u8 size)
 {
 	struct nvkm_device *device = ior->disp->engine.subdev.device;
-	const u32 soff = 0x030 * ior->id;
+	const u32 soff = 0x030 * ior->id + (head * 0x04);
 	int i;
 
 	for (i = 0; i < size; i++)
@@ -49,6 +49,7 @@ void
 gf119_hda_hpd(struct nvkm_ior *ior, int head, bool present)
 {
 	struct nvkm_device *device = ior->disp->engine.subdev.device;
+	const u32 soff = 0x030 * ior->id + (head * 0x04);
 	u32 data = 0x80000000;
 	u32 mask = 0x80000001;
 	if (present) {
@@ -57,5 +58,5 @@ gf119_hda_hpd(struct nvkm_ior *ior, int head, bool present)
 	} else {
 		mask |= 0x00000002;
 	}
-	nvkm_mask(device, 0x10ec10 + ior->id * 0x030, mask, data);
+	nvkm_mask(device, 0x10ec10 + soff, mask, data);
 }

commit d4115d17cd91c137b713b0e1482613093d6007c1
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed May 6 14:40:56 2020 +1000

    drm/nouveau/disp/hda/gf119-: add HAL for programming device entry in SF
    
    Register has moved on GV100.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
index 1080ba6ecd64..8a0ec7db5145 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
@@ -23,6 +23,14 @@
  */
 #include "ior.h"
 
+void
+gf119_hda_device_entry(struct nvkm_ior *ior, int head)
+{
+	struct nvkm_device *device = ior->disp->engine.subdev.device;
+	const u32 hoff = 0x800 * head;
+	nvkm_mask(device, 0x616548 + hoff, 0x00000070, 0x00000000);
+}
+
 void
 gf119_hda_eld(struct nvkm_ior *ior, int head, u8 *data, u8 size)
 {
@@ -41,11 +49,10 @@ void
 gf119_hda_hpd(struct nvkm_ior *ior, int head, bool present)
 {
 	struct nvkm_device *device = ior->disp->engine.subdev.device;
-	const u32 hoff = 0x800 * head;
 	u32 data = 0x80000000;
 	u32 mask = 0x80000001;
 	if (present) {
-		nvkm_mask(device, 0x616548 + hoff, 0x00000070, 0x00000000);
+		ior->func->hda.device_entry(ior, head);
 		data |= 0x00000001;
 	} else {
 		mask |= 0x00000002;

commit 1404e56a49f0dd6f50ded3290d37b795e3cbd6e9
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed May 6 14:40:52 2020 +1000

    drm/nouveau/disp/hda/gt215-: pass head to nvkm_ior.hda.eld()
    
    We're going to use the bound head to select HDA device entry.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
index 0fa0ec0a1de0..1080ba6ecd64 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
@@ -24,7 +24,7 @@
 #include "ior.h"
 
 void
-gf119_hda_eld(struct nvkm_ior *ior, u8 *data, u8 size)
+gf119_hda_eld(struct nvkm_ior *ior, int head, u8 *data, u8 size)
 {
 	struct nvkm_device *device = ior->disp->engine.subdev.device;
 	const u32 soff = 0x030 * ior->id;

commit 409b9e54727e700ab8dd15a1e29226eda1e04cdb
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/gt215-: port HDA ELD controls to nvkm_ior
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
index da6129b2b78f..0fa0ec0a1de0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
@@ -21,63 +21,34 @@
  *
  * Authors: Ben Skeggs
  */
-#include "nv50.h"
-#include "outp.h"
+#include "ior.h"
 
-#include <core/client.h>
-#include <subdev/bios.h>
-#include <subdev/bios/dcb.h>
-#include <subdev/timer.h>
-
-#include <nvif/cl5070.h>
-#include <nvif/unpack.h>
-
-int
-gf119_hda_eld(NV50_DISP_MTHD_V1)
+void
+gf119_hda_eld(struct nvkm_ior *ior, u8 *data, u8 size)
 {
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	union {
-		struct nv50_disp_sor_hda_eld_v0 v0;
-	} *args = data;
-	const u32 soff = outp->or * 0x030;
-	const u32 hoff = head * 0x800;
-	int ret = -ENOSYS, i;
+	struct nvkm_device *device = ior->disp->engine.subdev.device;
+	const u32 soff = 0x030 * ior->id;
+	int i;
 
-	nvif_ioctl(object, "disp sor hda eld size %d\n", size);
-	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
-		nvif_ioctl(object, "disp sor hda eld vers %d\n",
-			   args->v0.version);
-		if (size > 0x60)
-			return -E2BIG;
-	} else
-		return ret;
+	for (i = 0; i < size; i++)
+		nvkm_wr32(device, 0x10ec00 + soff, (i << 8) | data[i]);
+	for (; i < 0x60; i++)
+		nvkm_wr32(device, 0x10ec00 + soff, (i << 8));
+	nvkm_mask(device, 0x10ec10 + soff, 0x80000002, 0x80000002);
+}
 
-	if (size && args->v0.data[0]) {
-		if (outp->info.type == DCB_OUTPUT_DP) {
-			nvkm_mask(device, 0x616618 + hoff, 0x8000000c, 0x80000001);
-			nvkm_msec(device, 2000,
-				u32 tmp = nvkm_rd32(device, 0x616618 + hoff);
-				if (!(tmp & 0x80000000))
-					break;
-			);
-		}
+void
+gf119_hda_hpd(struct nvkm_ior *ior, int head, bool present)
+{
+	struct nvkm_device *device = ior->disp->engine.subdev.device;
+	const u32 hoff = 0x800 * head;
+	u32 data = 0x80000000;
+	u32 mask = 0x80000001;
+	if (present) {
 		nvkm_mask(device, 0x616548 + hoff, 0x00000070, 0x00000000);
-		for (i = 0; i < size; i++)
-			nvkm_wr32(device, 0x10ec00 + soff, (i << 8) | args->v0.data[i]);
-		for (; i < 0x60; i++)
-			nvkm_wr32(device, 0x10ec00 + soff, (i << 8));
-		nvkm_mask(device, 0x10ec10 + soff, 0x80000003, 0x80000003);
+		data |= 0x00000001;
 	} else {
-		if (outp->info.type == DCB_OUTPUT_DP) {
-			nvkm_mask(device, 0x616618 + hoff, 0x80000001, 0x80000000);
-			nvkm_msec(device, 2000,
-				u32 tmp = nvkm_rd32(device, 0x616618 + hoff);
-				if (!(tmp & 0x80000000))
-					break;
-			);
-		}
-		nvkm_mask(device, 0x10ec10 + soff, 0x80000003, 0x80000000 | !!size);
+		mask |= 0x00000002;
 	}
-
-	return 0;
+	nvkm_mask(device, 0x10ec10 + ior->id * 0x030, mask, data);
 }

commit f01c4e682c941ba70e0ebec44db754844a1b9b82
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon Nov 9 09:21:27 2015 +1000

    drm/nouveau/nvif: modify nvif_unvers/nvif_unpack macros to be more obvious
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
index ae7343dda04e..da6129b2b78f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
@@ -41,10 +41,10 @@ gf119_hda_eld(NV50_DISP_MTHD_V1)
 	} *args = data;
 	const u32 soff = outp->or * 0x030;
 	const u32 hoff = head * 0x800;
-	int ret, i;
+	int ret = -ENOSYS, i;
 
 	nvif_ioctl(object, "disp sor hda eld size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, true)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
 		nvif_ioctl(object, "disp sor hda eld vers %d\n",
 			   args->v0.version);
 		if (size > 0x60)

commit 7568b106718165feacdf411f1b8f95ae4263456a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Nov 8 10:44:19 2015 +1000

    drm/nouveau/nvif: split out display interface definitions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
index af99efbd63f7..ae7343dda04e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
@@ -29,7 +29,7 @@
 #include <subdev/bios/dcb.h>
 #include <subdev/timer.h>
 
-#include <nvif/class.h>
+#include <nvif/cl5070.h>
 #include <nvif/unpack.h>
 
 int

commit 2a7909c0ade08c66690e6115ae49765dc47873e6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/disp: split user classes out from engine implementations
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
new file mode 100644
index 000000000000..af99efbd63f7
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/hdagf119.c
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+#include "nv50.h"
+#include "outp.h"
+
+#include <core/client.h>
+#include <subdev/bios.h>
+#include <subdev/bios/dcb.h>
+#include <subdev/timer.h>
+
+#include <nvif/class.h>
+#include <nvif/unpack.h>
+
+int
+gf119_hda_eld(NV50_DISP_MTHD_V1)
+{
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	union {
+		struct nv50_disp_sor_hda_eld_v0 v0;
+	} *args = data;
+	const u32 soff = outp->or * 0x030;
+	const u32 hoff = head * 0x800;
+	int ret, i;
+
+	nvif_ioctl(object, "disp sor hda eld size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, true)) {
+		nvif_ioctl(object, "disp sor hda eld vers %d\n",
+			   args->v0.version);
+		if (size > 0x60)
+			return -E2BIG;
+	} else
+		return ret;
+
+	if (size && args->v0.data[0]) {
+		if (outp->info.type == DCB_OUTPUT_DP) {
+			nvkm_mask(device, 0x616618 + hoff, 0x8000000c, 0x80000001);
+			nvkm_msec(device, 2000,
+				u32 tmp = nvkm_rd32(device, 0x616618 + hoff);
+				if (!(tmp & 0x80000000))
+					break;
+			);
+		}
+		nvkm_mask(device, 0x616548 + hoff, 0x00000070, 0x00000000);
+		for (i = 0; i < size; i++)
+			nvkm_wr32(device, 0x10ec00 + soff, (i << 8) | args->v0.data[i]);
+		for (; i < 0x60; i++)
+			nvkm_wr32(device, 0x10ec00 + soff, (i << 8));
+		nvkm_mask(device, 0x10ec10 + soff, 0x80000003, 0x80000003);
+	} else {
+		if (outp->info.type == DCB_OUTPUT_DP) {
+			nvkm_mask(device, 0x616618 + hoff, 0x80000001, 0x80000000);
+			nvkm_msec(device, 2000,
+				u32 tmp = nvkm_rd32(device, 0x616618 + hoff);
+				if (!(tmp & 0x80000000))
+					break;
+			);
+		}
+		nvkm_mask(device, 0x10ec10 + soff, 0x80000003, 0x80000000 | !!size);
+	}
+
+	return 0;
+}
