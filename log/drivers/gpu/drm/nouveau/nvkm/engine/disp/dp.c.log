commit 409d659fe11d778a8f505f909815bc867a27ecbf
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 14 11:31:01 2020 +1000

    drm/nouveau/disp/dp: fix typo when determining failsafe link configuration
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 818d21bd28d3..3800aeb507d0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -365,7 +365,7 @@ nvkm_dp_train(struct nvkm_dp *dp, u32 dataKBps)
 	 * and it's better to have a failed modeset than that.
 	 */
 	for (cfg = nvkm_dp_rates; cfg->rate; cfg++) {
-		if (cfg->nr <= outp_nr && cfg->nr <= outp_bw) {
+		if (cfg->nr <= outp_nr && cfg->bw <= outp_bw) {
 			/* Try to respect sink limits too when selecting
 			 * lowest link configuration.
 			 */

commit 13d03e9daf70dab032c03dc172e75bb98ad899c4
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 10 11:57:04 2019 +1000

    drm/nouveau/disp/dp: respect sink limits when selecting failsafe link configuration
    
    Where possible, we want the failsafe link configuration (one which won't
    hang the OR during modeset because of not enough bandwidth for the mode)
    to also be supported by the sink.
    
    This prevents "link rate unsupported by sink" messages when link training
    fails.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 5f301e632599..818d21bd28d3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -365,8 +365,15 @@ nvkm_dp_train(struct nvkm_dp *dp, u32 dataKBps)
 	 * and it's better to have a failed modeset than that.
 	 */
 	for (cfg = nvkm_dp_rates; cfg->rate; cfg++) {
-		if (cfg->nr <= outp_nr && cfg->nr <= outp_bw)
-			failsafe = cfg;
+		if (cfg->nr <= outp_nr && cfg->nr <= outp_bw) {
+			/* Try to respect sink limits too when selecting
+			 * lowest link configuration.
+			 */
+			if (!failsafe ||
+			    (cfg->nr <= sink_nr && cfg->bw <= sink_bw))
+				failsafe = cfg;
+		}
+
 		if (failsafe && cfg[1].rate < dataKBps)
 			break;
 	}

commit e04cfdc9b7398c60dbc70212415ea63b6c6a93ae
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Sep 4 15:57:09 2018 +1000

    drm/nouveau/disp: fix DP disable race
    
    If a HPD pulse signalling the need to retrain the link occurs between
    the KMS driver releasing the output and the supervisor interrupt that
    finishes the teardown, it was possible get a NULL-ptr deref.
    
    Avoid this by marking the link as inactive earlier.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index bb34ee77458e..5f301e632599 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -413,14 +413,10 @@ nvkm_dp_train(struct nvkm_dp *dp, u32 dataKBps)
 }
 
 static void
-nvkm_dp_release(struct nvkm_outp *outp, struct nvkm_ior *ior)
+nvkm_dp_disable(struct nvkm_outp *outp, struct nvkm_ior *ior)
 {
 	struct nvkm_dp *dp = nvkm_dp(outp);
 
-	/* Prevent link from being retrained if sink sends an IRQ. */
-	atomic_set(&dp->lt.done, 0);
-	ior->dp.nr = 0;
-
 	/* Execute DisableLT script from DP Info Table. */
 	nvbios_init(&ior->disp->engine.subdev, dp->info.script[4],
 		init.outp = &dp->outp.info;
@@ -429,6 +425,16 @@ nvkm_dp_release(struct nvkm_outp *outp, struct nvkm_ior *ior)
 	);
 }
 
+static void
+nvkm_dp_release(struct nvkm_outp *outp)
+{
+	struct nvkm_dp *dp = nvkm_dp(outp);
+
+	/* Prevent link from being retrained if sink sends an IRQ. */
+	atomic_set(&dp->lt.done, 0);
+	dp->outp.ior->dp.nr = 0;
+}
+
 static int
 nvkm_dp_acquire(struct nvkm_outp *outp)
 {
@@ -607,6 +613,7 @@ nvkm_dp_func = {
 	.fini = nvkm_dp_fini,
 	.acquire = nvkm_dp_acquire,
 	.release = nvkm_dp_release,
+	.disable = nvkm_dp_disable,
 };
 
 static int

commit f6d52b2172b1adfde010df34730290c282ee641b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Sep 4 15:57:07 2018 +1000

    drm/nouveau/disp: move eDP panel power handling
    
    We need to do this earlier to prevent aux channel timeouts in resume
    paths on certain systems.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 7c5bed29ffef..bb34ee77458e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -28,6 +28,7 @@
 
 #include <subdev/bios.h>
 #include <subdev/bios/init.h>
+#include <subdev/gpio.h>
 #include <subdev/i2c.h>
 
 #include <nvif/event.h>
@@ -491,7 +492,7 @@ nvkm_dp_acquire(struct nvkm_outp *outp)
 	return ret;
 }
 
-static void
+static bool
 nvkm_dp_enable(struct nvkm_dp *dp, bool enable)
 {
 	struct nvkm_i2c_aux *aux = dp->aux;
@@ -505,7 +506,7 @@ nvkm_dp_enable(struct nvkm_dp *dp, bool enable)
 
 		if (!nvkm_rdaux(aux, DPCD_RC00_DPCD_REV, dp->dpcd,
 				sizeof(dp->dpcd)))
-			return;
+			return true;
 	}
 
 	if (dp->present) {
@@ -515,6 +516,7 @@ nvkm_dp_enable(struct nvkm_dp *dp, bool enable)
 	}
 
 	atomic_set(&dp->lt.done, 0);
+	return false;
 }
 
 static int
@@ -555,9 +557,38 @@ nvkm_dp_fini(struct nvkm_outp *outp)
 static void
 nvkm_dp_init(struct nvkm_outp *outp)
 {
+	struct nvkm_gpio *gpio = outp->disp->engine.subdev.device->gpio;
 	struct nvkm_dp *dp = nvkm_dp(outp);
+
 	nvkm_notify_put(&dp->outp.conn->hpd);
-	nvkm_dp_enable(dp, true);
+
+	/* eDP panels need powering on by us (if the VBIOS doesn't default it
+	 * to on) before doing any AUX channel transactions.  LVDS panel power
+	 * is handled by the SOR itself, and not required for LVDS DDC.
+	 */
+	if (dp->outp.conn->info.type == DCB_CONNECTOR_eDP) {
+		int power = nvkm_gpio_get(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff);
+		if (power == 0)
+			nvkm_gpio_set(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff, 1);
+
+		/* We delay here unconditionally, even if already powered,
+		 * because some laptop panels having a significant resume
+		 * delay before the panel begins responding.
+		 *
+		 * This is likely a bit of a hack, but no better idea for
+		 * handling this at the moment.
+		 */
+		msleep(300);
+
+		/* If the eDP panel can't be detected, we need to restore
+		 * the panel power GPIO to avoid breaking another output.
+		 */
+		if (!nvkm_dp_enable(dp, true) && power == 0)
+			nvkm_gpio_set(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff, 0);
+	} else {
+		nvkm_dp_enable(dp, true);
+	}
+
 	nvkm_notify_get(&dp->hpd);
 }
 

commit 8d7ef84d908877708001f3334dbf44e9d48fad57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/nv50-: implement a common supervisor 2.2
    
    This makes use of all the additional routing and state added in previous
    commits, making it possible to deal with GM20x macro link routing, while
    also sharing code between the NV50 and GF119 implementations.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 12e52529413c..7c5bed29ffef 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -428,8 +428,8 @@ nvkm_dp_release(struct nvkm_outp *outp, struct nvkm_ior *ior)
 	);
 }
 
-int
-nvkm_output_dp_train(struct nvkm_outp *outp, u32 unused)
+static int
+nvkm_dp_acquire(struct nvkm_outp *outp)
 {
 	struct nvkm_dp *dp = nvkm_dp(outp);
 	struct nvkm_ior *ior = dp->outp.ior;
@@ -529,7 +529,7 @@ nvkm_dp_hpd(struct nvkm_notify *notify)
 	OUTP_DBG(&dp->outp, "HPD: %d", line->mask);
 	if (line->mask & NVKM_I2C_IRQ) {
 		if (atomic_read(&dp->lt.done))
-			nvkm_output_dp_train(&dp->outp, 0);
+			dp->outp.func->acquire(&dp->outp);
 		rep.mask |= NVIF_NOTIFY_CONN_V0_IRQ;
 	} else {
 		nvkm_dp_enable(dp, true);
@@ -574,6 +574,7 @@ nvkm_dp_func = {
 	.dtor = nvkm_dp_dtor,
 	.init = nvkm_dp_init,
 	.fini = nvkm_dp_fini,
+	.acquire = nvkm_dp_acquire,
 	.release = nvkm_dp_release,
 };
 

commit d52e948c67b263d0ceb71d734673ff8b1d4b10ce
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/nv50-: implement a common supervisor 2.0
    
    This makes use of all the additional routing and state added in previous
    commits, making it possible to deal with GM20x macro link routing, while
    also sharing code between the NV50 and GF119 implementations.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index da5aa4683d16..12e52529413c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -411,6 +411,23 @@ nvkm_dp_train(struct nvkm_dp *dp, u32 dataKBps)
 	return ret;
 }
 
+static void
+nvkm_dp_release(struct nvkm_outp *outp, struct nvkm_ior *ior)
+{
+	struct nvkm_dp *dp = nvkm_dp(outp);
+
+	/* Prevent link from being retrained if sink sends an IRQ. */
+	atomic_set(&dp->lt.done, 0);
+	ior->dp.nr = 0;
+
+	/* Execute DisableLT script from DP Info Table. */
+	nvbios_init(&ior->disp->engine.subdev, dp->info.script[4],
+		init.outp = &dp->outp.info;
+		init.or   = ior->id;
+		init.link = ior->arm.link;
+	);
+}
+
 int
 nvkm_output_dp_train(struct nvkm_outp *outp, u32 unused)
 {
@@ -557,6 +574,7 @@ nvkm_dp_func = {
 	.dtor = nvkm_dp_dtor,
 	.init = nvkm_dp_init,
 	.fini = nvkm_dp_fini,
+	.release = nvkm_dp_release,
 };
 
 static int

commit 32a232c5144d754674f05de3c452af324fe13cac
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/dp: use new devinit script interpreter entry-point
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 4ad31302aaf4..da5aa4683d16 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -222,14 +222,6 @@ nvkm_dp_train_links(struct nvkm_dp *dp)
 	struct nvkm_disp *disp = dp->outp.disp;
 	struct nvkm_subdev *subdev = &disp->engine.subdev;
 	struct nvkm_bios *bios = subdev->device->bios;
-	struct nvbios_init init = {
-		.subdev = subdev,
-		.bios = bios,
-		.offset = 0x0000,
-		.outp = &dp->outp.info,
-		.crtc = -1,
-		.execute = 1,
-	};
 	struct lt_state lt = {
 		.dp = dp,
 	};
@@ -250,14 +242,18 @@ nvkm_dp_train_links(struct nvkm_dp *dp)
 		if (dp->version < 0x30) {
 			while ((ior->dp.bw * 2700) < nvbios_rd16(bios, lnkcmp))
 				lnkcmp += 4;
-			init.offset = nvbios_rd16(bios, lnkcmp + 2);
+			lnkcmp = nvbios_rd16(bios, lnkcmp + 2);
 		} else {
 			while (ior->dp.bw < nvbios_rd08(bios, lnkcmp))
 				lnkcmp += 3;
-			init.offset = nvbios_rd16(bios, lnkcmp + 1);
+			lnkcmp = nvbios_rd16(bios, lnkcmp + 1);
 		}
 
-		nvbios_exec(&init);
+		nvbios_init(subdev, lnkcmp,
+			init.outp = &dp->outp.info;
+			init.or   = ior->id;
+			init.link = ior->asy.link;
+		);
 	}
 
 	ret = ior->func->dp.links(ior, dp->aux);
@@ -293,42 +289,38 @@ nvkm_dp_train_links(struct nvkm_dp *dp)
 static void
 nvkm_dp_train_fini(struct nvkm_dp *dp)
 {
-	struct nvkm_subdev *subdev = &dp->outp.disp->engine.subdev;
-	struct nvbios_init init = {
-		.subdev = subdev,
-		.bios = subdev->device->bios,
-		.outp = &dp->outp.info,
-		.crtc = -1,
-		.execute = 1,
-	};
-
 	/* Execute AfterLinkTraining script from DP Info table. */
-	init.offset = dp->info.script[1],
-	nvbios_exec(&init);
+	nvbios_init(&dp->outp.disp->engine.subdev, dp->info.script[1],
+		init.outp = &dp->outp.info;
+		init.or   = dp->outp.ior->id;
+		init.link = dp->outp.ior->asy.link;
+	);
 }
 
 static void
 nvkm_dp_train_init(struct nvkm_dp *dp)
 {
-	struct nvkm_subdev *subdev = &dp->outp.disp->engine.subdev;
-	struct nvbios_init init = {
-		.subdev = subdev,
-		.bios = subdev->device->bios,
-		.outp = &dp->outp.info,
-		.crtc = -1,
-		.execute = 1,
-	};
-
 	/* Execute EnableSpread/DisableSpread script from DP Info table. */
-	if (dp->dpcd[DPCD_RC03] & DPCD_RC03_MAX_DOWNSPREAD)
-		init.offset = dp->info.script[2];
-	else
-		init.offset = dp->info.script[3];
-	nvbios_exec(&init);
+	if (dp->dpcd[DPCD_RC03] & DPCD_RC03_MAX_DOWNSPREAD) {
+		nvbios_init(&dp->outp.disp->engine.subdev, dp->info.script[2],
+			init.outp = &dp->outp.info;
+			init.or   = dp->outp.ior->id;
+			init.link = dp->outp.ior->asy.link;
+		);
+	} else {
+		nvbios_init(&dp->outp.disp->engine.subdev, dp->info.script[3],
+			init.outp = &dp->outp.info;
+			init.or   = dp->outp.ior->id;
+			init.link = dp->outp.ior->asy.link;
+		);
+	}
 
 	/* Execute BeforeLinkTraining script from DP Info table. */
-	init.offset = dp->info.script[0];
-	nvbios_exec(&init);
+	nvbios_init(&dp->outp.disp->engine.subdev, dp->info.script[0],
+		init.outp = &dp->outp.info;
+		init.or   = dp->outp.ior->id;
+		init.link = dp->outp.ior->asy.link;
+	);
 }
 
 static const struct dp_rates {

commit 9648da5a71c25e17d14feb0d7dc9ee73319e8a24
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/dp: determine link bandwidth requirements from head state
    
    Training/Untraining will be hooked up to the routing logic, which
    doesn't allow us to pass in a data rate.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 0f1c223cc7a8..4ad31302aaf4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -23,6 +23,7 @@
  */
 #include "dp.h"
 #include "conn.h"
+#include "head.h"
 #include "ior.h"
 
 #include <subdev/bios.h>
@@ -419,19 +420,28 @@ nvkm_dp_train(struct nvkm_dp *dp, u32 dataKBps)
 }
 
 int
-nvkm_output_dp_train(struct nvkm_outp *outp, u32 datakbps)
+nvkm_output_dp_train(struct nvkm_outp *outp, u32 unused)
 {
 	struct nvkm_dp *dp = nvkm_dp(outp);
 	struct nvkm_ior *ior = dp->outp.ior;
+	struct nvkm_head *head;
 	bool retrain = true;
-	u32 linkKBps;
+	u32 datakbps = 0;
 	u32 dataKBps;
+	u32 linkKBps;
 	u8  stat[3];
 	int ret, i;
 
 	mutex_lock(&dp->mutex);
 
 	/* Check that link configuration meets current requirements. */
+	list_for_each_entry(head, &outp->disp->head, head) {
+		if (ior->asy.head & (1 << head->id)) {
+			u32 khz = (head->asy.hz >> ior->asy.rgdiv) / 1000;
+			datakbps += khz * head->asy.or.depth;
+		}
+	}
+
 	linkKBps = ior->dp.bw * 27000 * ior->dp.nr;
 	dataKBps = DIV_ROUND_UP(datakbps, 8);
 	OUTP_DBG(&dp->outp, "data %d KB/s link %d KB/s mst %d->%d",

commit 6c22ea3747fd36409ce4a1e1a0cbac40f93e1e71
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp: introduce acquire/release display path methods
    
    These exist to give NVKM information on the set of display paths that
    the DD needs to be active at any given time.
    
    Previously, the supervisor attempted to determine this solely from OR
    state, but there's a few configurations where this information on its
    own isn't enough to determine the specific display paths in question:
    
    - ANX9805, where the PIOR protocol for both DP and TMDS is TMDS.
    - On a device using DCB Switched Outputs.
    - On GM20x and newer, with a crossbar between the SOR and macro links.
    
    After this commit, the DD tells NVKM *exactly* which display path it's
    attempting a modeset on.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index b531890b1a6f..0f1c223cc7a8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -24,7 +24,6 @@
 #include "dp.h"
 #include "conn.h"
 #include "ior.h"
-#include "nv50.h"
 
 #include <subdev/bios.h>
 #include <subdev/bios/init.h>
@@ -351,7 +350,6 @@ static const struct dp_rates {
 static int
 nvkm_dp_train(struct nvkm_dp *dp, u32 dataKBps)
 {
-	struct nv50_disp *disp = nv50_disp(dp->outp.disp);
 	struct nvkm_ior *ior = dp->outp.ior;
 	const u8 sink_nr = dp->dpcd[DPCD_RC02] & DPCD_RC02_MAX_LANE_COUNT;
 	const u8 sink_bw = dp->dpcd[DPCD_RC01_MAX_LINK_RATE];
@@ -361,9 +359,6 @@ nvkm_dp_train(struct nvkm_dp *dp, u32 dataKBps)
 	int ret = -EINVAL;
 	u8  pwr;
 
-	if (!dp->outp.info.location && disp->func->sor.magic)
-		disp->func->sor.magic(&dp->outp);
-
 	/* Find the lowest configuration of the OR that can support
 	 * the required link rate.
 	 *

commit 3c66c87dc96b3113b5ee84604800c2aabbb48994
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp: remove hw-specific customisation of output paths
    
    All of the necessary hw-specific logic is now handled at the output
    resource level, so all of this can go away.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 2d8f93323309..b531890b1a6f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -580,7 +580,7 @@ nvkm_dp_ctor(struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
 	dp->aux = aux;
 	if (!dp->aux) {
 		OUTP_ERR(&dp->outp, "no aux");
-		return -ENODEV;
+		return -EINVAL;
 	}
 
 	/* bios data is not optional */
@@ -589,7 +589,7 @@ nvkm_dp_ctor(struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
 				  &hdr, &cnt, &len, &dp->info);
 	if (!data) {
 		OUTP_ERR(&dp->outp, "no bios dp data");
-		return -ENODEV;
+		return -EINVAL;
 	}
 
 	OUTP_DBG(&dp->outp, "bios dp %02x %02x %02x %02x",
@@ -616,9 +616,8 @@ nvkm_dp_ctor(struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
 }
 
 int
-nvkm_output_dp_new_(const struct nvkm_output_dp_func *func,
-		    struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
-		    struct nvkm_outp **poutp)
+nvkm_dp_new(struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
+	    struct nvkm_outp **poutp)
 {
 	struct nvkm_i2c *i2c = disp->engine.subdev.device->i2c;
 	struct nvkm_i2c_aux *aux;
@@ -631,7 +630,6 @@ nvkm_output_dp_new_(const struct nvkm_output_dp_func *func,
 
 	if (!(dp = kzalloc(sizeof(*dp), GFP_KERNEL)))
 		return -ENOMEM;
-	dp->func = func;
 	*poutp = &dp->outp;
 
 	return nvkm_dp_ctor(disp, index, dcbE, aux, dp);

commit 7d1fede03c5880003a08ff080e6e41984902be46
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/g94-: port OR DP drive setting control to nvkm_ior
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index fecaa03eeb94..2d8f93323309 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -73,9 +73,15 @@ static int
 nvkm_dp_train_drive(struct lt_state *lt, bool pc)
 {
 	struct nvkm_dp *dp = lt->dp;
+	struct nvkm_ior *ior = dp->outp.ior;
+	struct nvkm_bios *bios = ior->disp->engine.subdev.device->bios;
+	struct nvbios_dpout info;
+	struct nvbios_dpcfg ocfg;
+	u8  ver, hdr, cnt, len;
+	u32 data;
 	int ret, i;
 
-	for (i = 0; i < dp->outp.ior->dp.nr; i++) {
+	for (i = 0; i < ior->dp.nr; i++) {
 		u8 lane = (lt->stat[4 + (i >> 1)] >> ((i & 1) * 4)) & 0xf;
 		u8 lpc2 = (lt->pc2stat >> (i * 2)) & 0x3;
 		u8 lpre = (lane & 0x0c) >> 2;
@@ -99,7 +105,21 @@ nvkm_dp_train_drive(struct lt_state *lt, bool pc)
 
 		OUTP_TRACE(&dp->outp, "config lane %d %02x %02x",
 			   i, lt->conf[i], lpc2);
-		dp->func->drv_ctl(dp, i, lvsw & 3, lpre & 3, lpc2 & 3);
+
+		data = nvbios_dpout_match(bios, dp->outp.info.hasht,
+						dp->outp.info.hashm,
+					  &ver, &hdr, &cnt, &len, &info);
+		if (!data)
+			continue;
+
+		data = nvbios_dpcfg_match(bios, data, lpc2 & 3, lvsw & 3,
+					  lpre & 3, &ver, &hdr, &cnt, &len,
+					  &ocfg);
+		if (!data)
+			continue;
+
+		ior->func->dp.drive(ior, i, ocfg.pc, ocfg.dc,
+					    ocfg.pe, ocfg.tx_pu);
 	}
 
 	ret = nvkm_wraux(dp->aux, DPCD_LC03(0), lt->conf, 4);

commit a1de2b522fef9fd725f2edb6989af68b8749acf5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/g94-: port OR DP training pattern control to nvkm_ior
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 545d4ccedffe..fecaa03eeb94 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -122,7 +122,7 @@ nvkm_dp_train_pattern(struct lt_state *lt, u8 pattern)
 	u8 sink_tp;
 
 	OUTP_TRACE(&dp->outp, "training pattern %d", pattern);
-	dp->func->pattern(dp, pattern);
+	dp->outp.ior->func->dp.pattern(dp->outp.ior, pattern);
 
 	nvkm_rdaux(dp->aux, DPCD_LC02, &sink_tp, 1);
 	sink_tp &= ~DPCD_LC02_TRAINING_PATTERN_SET;

commit a3e81117ce0bcec293352558613e35065659da10
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/g94-: port OR DP link power control to nvkm_ior
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 979563434da8..545d4ccedffe 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -249,7 +249,7 @@ nvkm_dp_train_links(struct nvkm_dp *dp)
 		return 0;
 	}
 
-	dp->func->lnk_pwr(dp, ior->dp.nr);
+	ior->func->dp.power(ior, ior->dp.nr);
 
 	/* Set desired link configuration on the sink. */
 	sink[0] = ior->dp.bw;

commit 7dc0bac4aabb62a91543a29782ce12955708bfe2
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/g94-: port OR DP link setup to nvkm_ior
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index f3b255027c11..979563434da8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -240,11 +240,13 @@ nvkm_dp_train_links(struct nvkm_dp *dp)
 		nvbios_exec(&init);
 	}
 
-	ret = dp->func->lnk_ctl(dp, ior->dp.nr, ior->dp.bw, ior->dp.ef);
+	ret = ior->func->dp.links(ior, dp->aux);
 	if (ret) {
-		if (ret < 0)
-			OUTP_ERR(&dp->outp, "lnk_ctl failed with %d", ret);
-		return ret;
+		if (ret < 0) {
+			OUTP_ERR(&dp->outp, "train failed with %d", ret);
+			return ret;
+		}
+		return 0;
 	}
 
 	dp->func->lnk_pwr(dp, ior->dp.nr);

commit 7d0a01a6dec9737d24be5ac223e73a0725eac8a0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/dp: train link only when actively displaying an image
    
    This essentially (unless the link becomes unstable and needs to be
    re-trained) gives us a single entry-point to link training, during
    supervisor handling, where we can ensure all routing is up to date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index a67192ad5cf3..f3b255027c11 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -417,7 +417,9 @@ nvkm_output_dp_train(struct nvkm_outp *outp, u32 datakbps)
 	/* Check that link configuration meets current requirements. */
 	linkKBps = ior->dp.bw * 27000 * ior->dp.nr;
 	dataKBps = DIV_ROUND_UP(datakbps, 8);
-	if (linkKBps < dataKBps) {
+	OUTP_DBG(&dp->outp, "data %d KB/s link %d KB/s mst %d->%d",
+		 dataKBps, linkKBps, ior->dp.mst, dp->lt.mst);
+	if (linkKBps < dataKBps || ior->dp.mst != dp->lt.mst) {
 		OUTP_DBG(&dp->outp, "link requirements changed");
 		goto done;
 	}
@@ -466,10 +468,8 @@ nvkm_dp_enable(struct nvkm_dp *dp, bool enable)
 		}
 
 		if (!nvkm_rdaux(aux, DPCD_RC00_DPCD_REV, dp->dpcd,
-				sizeof(dp->dpcd))) {
-			nvkm_output_dp_train(&dp->outp, 0);
+				sizeof(dp->dpcd)))
 			return;
-		}
 	}
 
 	if (dp->present) {

commit 22e008f90d546507d57bdac92030cece73ded09a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/dp: only check for re-train when the link is active
    
    An upcoming commit will limit link training to only when the sink is
    meant to be displaying an image.
    
    We still need IRQs enabled even when the link isn't trained (for MST
    messages), but don't want to train the link unnecessarily.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 090567d94876..a67192ad5cf3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -491,7 +491,13 @@ nvkm_dp_hpd(struct nvkm_notify *notify)
 	struct nvif_notify_conn_rep_v0 rep = {};
 
 	OUTP_DBG(&dp->outp, "HPD: %d", line->mask);
-	nvkm_dp_enable(dp, true);
+	if (line->mask & NVKM_I2C_IRQ) {
+		if (atomic_read(&dp->lt.done))
+			nvkm_output_dp_train(&dp->outp, 0);
+		rep.mask |= NVIF_NOTIFY_CONN_V0_IRQ;
+	} else {
+		nvkm_dp_enable(dp, true);
+	}
 
 	if (line->mask & NVKM_I2C_UNPLUG)
 		rep.mask |= NVIF_NOTIFY_CONN_V0_UNPLUG;
@@ -502,30 +508,11 @@ nvkm_dp_hpd(struct nvkm_notify *notify)
 	return NVKM_NOTIFY_KEEP;
 }
 
-static int
-nvkm_dp_irq(struct nvkm_notify *notify)
-{
-	const struct nvkm_i2c_ntfy_rep *line = notify->data;
-	struct nvkm_dp *dp = container_of(notify, typeof(*dp), irq);
-	struct nvkm_conn *conn = dp->outp.conn;
-	struct nvkm_disp *disp = dp->outp.disp;
-	struct nvif_notify_conn_rep_v0 rep = {
-		.mask = NVIF_NOTIFY_CONN_V0_IRQ,
-	};
-
-	OUTP_DBG(&dp->outp, "IRQ: %d", line->mask);
-	nvkm_output_dp_train(&dp->outp, 0);
-
-	nvkm_event_send(&disp->hpd, rep.mask, conn->index, &rep, sizeof(rep));
-	return NVKM_NOTIFY_KEEP;
-}
-
 static void
 nvkm_dp_fini(struct nvkm_outp *outp)
 {
 	struct nvkm_dp *dp = nvkm_dp(outp);
 	nvkm_notify_put(&dp->hpd);
-	nvkm_notify_put(&dp->irq);
 	nvkm_dp_enable(dp, false);
 }
 
@@ -535,7 +522,6 @@ nvkm_dp_init(struct nvkm_outp *outp)
 	struct nvkm_dp *dp = nvkm_dp(outp);
 	nvkm_notify_put(&dp->outp.conn->hpd);
 	nvkm_dp_enable(dp, true);
-	nvkm_notify_get(&dp->irq);
 	nvkm_notify_get(&dp->hpd);
 }
 
@@ -544,7 +530,6 @@ nvkm_dp_dtor(struct nvkm_outp *outp)
 {
 	struct nvkm_dp *dp = nvkm_dp(outp);
 	nvkm_notify_fini(&dp->hpd);
-	nvkm_notify_fini(&dp->irq);
 	return dp;
 }
 
@@ -588,27 +573,11 @@ nvkm_dp_ctor(struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
 	OUTP_DBG(&dp->outp, "bios dp %02x %02x %02x %02x",
 		 dp->version, hdr, cnt, len);
 
-	/* link maintenance */
-	ret = nvkm_notify_init(NULL, &i2c->event, nvkm_dp_irq, true,
-			       &(struct nvkm_i2c_ntfy_req) {
-				.mask = NVKM_I2C_IRQ,
-				.port = dp->aux->id,
-			       },
-			       sizeof(struct nvkm_i2c_ntfy_req),
-			       sizeof(struct nvkm_i2c_ntfy_rep),
-			       &dp->irq);
-	if (ret) {
-		OUTP_ERR(&dp->outp, "error monitoring aux irq: %d", ret);
-		return ret;
-	}
-
-	mutex_init(&dp->mutex);
-	atomic_set(&dp->lt.done, 0);
-
 	/* hotplug detect, replaces gpio-based mechanism with aux events */
 	ret = nvkm_notify_init(NULL, &i2c->event, nvkm_dp_hpd, true,
 			       &(struct nvkm_i2c_ntfy_req) {
-				.mask = NVKM_I2C_PLUG | NVKM_I2C_UNPLUG,
+				.mask = NVKM_I2C_PLUG | NVKM_I2C_UNPLUG |
+					NVKM_I2C_IRQ,
 				.port = dp->aux->id,
 			       },
 			       sizeof(struct nvkm_i2c_ntfy_req),
@@ -619,6 +588,8 @@ nvkm_dp_ctor(struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
 		return ret;
 	}
 
+	mutex_init(&dp->mutex);
+	atomic_set(&dp->lt.done, 0);
 	return 0;
 }
 

commit 49f2b376df7f9235ccbed1e90f0ec93040001a9b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/dp: determine a failsafe link training rate
    
    The aim here is to protect the OR against locking up when something
    unexpected happens (such as the display disappearing during modeset,
    or the DD misbehaving).
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 4941643dd8fa..090567d94876 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -327,7 +327,7 @@ static const struct dp_rates {
 };
 
 static int
-nvkm_dp_train(struct nvkm_dp *dp)
+nvkm_dp_train(struct nvkm_dp *dp, u32 dataKBps)
 {
 	struct nv50_disp *disp = nv50_disp(dp->outp.disp);
 	struct nvkm_ior *ior = dp->outp.ior;
@@ -335,13 +335,34 @@ nvkm_dp_train(struct nvkm_dp *dp)
 	const u8 sink_bw = dp->dpcd[DPCD_RC01_MAX_LINK_RATE];
 	const u8 outp_nr = dp->outp.info.dpconf.link_nr;
 	const u8 outp_bw = dp->outp.info.dpconf.link_bw;
-	const struct dp_rates *cfg;
+	const struct dp_rates *failsafe = NULL, *cfg;
+	int ret = -EINVAL;
 	u8  pwr;
-	int ret;
 
 	if (!dp->outp.info.location && disp->func->sor.magic)
 		disp->func->sor.magic(&dp->outp);
 
+	/* Find the lowest configuration of the OR that can support
+	 * the required link rate.
+	 *
+	 * We will refuse to program the OR to lower rates, even if
+	 * link training fails at higher rates (or even if the sink
+	 * can't support the rate at all, though the DD is supposed
+	 * to prevent such situations from happening).
+	 *
+	 * Attempting to do so can cause the entire display to hang,
+	 * and it's better to have a failed modeset than that.
+	 */
+	for (cfg = nvkm_dp_rates; cfg->rate; cfg++) {
+		if (cfg->nr <= outp_nr && cfg->nr <= outp_bw)
+			failsafe = cfg;
+		if (failsafe && cfg[1].rate < dataKBps)
+			break;
+	}
+
+	if (WARN_ON(!failsafe))
+		return ret;
+
 	/* Ensure sink is not in a low-power state. */
 	if (!nvkm_rdaux(dp->aux, DPCD_SC00, &pwr, 1)) {
 		if ((pwr & DPCD_SC00_SET_POWER) != DPCD_SC00_SET_POWER_D0) {
@@ -352,13 +373,17 @@ nvkm_dp_train(struct nvkm_dp *dp)
 	}
 
 	/* Link training. */
+	OUTP_DBG(&dp->outp, "training (min: %d x %d MB/s)",
+		 failsafe->nr, failsafe->bw * 27);
 	nvkm_dp_train_init(dp);
-	for (ret = -EINVAL, cfg = nvkm_dp_rates; ret < 0 && cfg->rate; cfg++) {
+	for (cfg = nvkm_dp_rates; ret < 0 && cfg <= failsafe; cfg++) {
 		/* Skip configurations not supported by both OR and sink. */
-		if (cfg[1].rate &&
-		    (cfg->nr > outp_nr || cfg->bw > outp_bw ||
-		     cfg->nr > sink_nr || cfg->bw > sink_bw))
-			continue;
+		if ((cfg->nr > outp_nr || cfg->bw > outp_bw ||
+		     cfg->nr > sink_nr || cfg->bw > sink_bw)) {
+			if (cfg != failsafe)
+				continue;
+			OUTP_ERR(&dp->outp, "link rate unsupported by sink");
+		}
 		ior->dp.mst = dp->lt.mst;
 		ior->dp.ef = dp->dpcd[DPCD_RC02] & DPCD_RC02_ENHANCED_FRAME_CAP;
 		ior->dp.bw = cfg->bw;
@@ -422,17 +447,8 @@ nvkm_output_dp_train(struct nvkm_outp *outp, u32 datakbps)
 	}
 
 done:
-	if (retrain || !atomic_read(&dp->lt.done)) {
-		/* no sink, but still need to configure source */
-		if (dp->dpcd[DPCD_RC00_DPCD_REV] == 0x00) {
-			dp->dpcd[DPCD_RC01_MAX_LINK_RATE] =
-				dp->outp.info.dpconf.link_bw;
-			dp->dpcd[DPCD_RC02] =
-				dp->outp.info.dpconf.link_nr;
-		}
-		ret = nvkm_dp_train(dp);
-	}
-
+	if (retrain || !atomic_read(&dp->lt.done))
+		ret = nvkm_dp_train(dp, dataKBps);
 	mutex_unlock(&dp->mutex);
 	return ret;
 }

commit fafa8b5c9f7426cef6b9b52b8582a867edbc7a06
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/dp: use cached link configuration when checking link status
    
    Saves some trips across the aux channel.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 2b3aca044975..4941643dd8fa 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -326,7 +326,7 @@ static const struct dp_rates {
 	{}
 };
 
-static void
+static int
 nvkm_dp_train(struct nvkm_dp *dp)
 {
 	struct nv50_disp *disp = nv50_disp(dp->outp.disp);
@@ -370,39 +370,34 @@ nvkm_dp_train(struct nvkm_dp *dp)
 	nvkm_dp_train_fini(dp);
 	if (ret < 0)
 		OUTP_ERR(&dp->outp, "training failed");
-
-	OUTP_DBG(&dp->outp, "training done");
+	else
+		OUTP_DBG(&dp->outp, "training done");
 	atomic_set(&dp->lt.done, 1);
+	return ret;
 }
 
 int
-nvkm_output_dp_train(struct nvkm_outp *outp, u32 datarate)
+nvkm_output_dp_train(struct nvkm_outp *outp, u32 datakbps)
 {
 	struct nvkm_dp *dp = nvkm_dp(outp);
+	struct nvkm_ior *ior = dp->outp.ior;
 	bool retrain = true;
-	u8 link[2], stat[3];
-	u32 linkrate;
+	u32 linkKBps;
+	u32 dataKBps;
+	u8  stat[3];
 	int ret, i;
 
 	mutex_lock(&dp->mutex);
 
-	/* check that the link is trained at a high enough rate */
-	ret = nvkm_rdaux(dp->aux, DPCD_LC00_LINK_BW_SET, link, 2);
-	if (ret) {
-		OUTP_DBG(&dp->outp,
-			 "failed to read link config, assuming no sink");
-		goto done;
-	}
-
-	linkrate = link[0] * 27000 * (link[1] & DPCD_LC01_LANE_COUNT_SET);
-	linkrate = (linkrate * 8) / 10; /* 8B/10B coding overhead */
-	datarate = (datarate + 9) / 10; /* -> decakilobits */
-	if (linkrate < datarate) {
-		OUTP_DBG(&dp->outp, "link not trained at sufficient rate");
+	/* Check that link configuration meets current requirements. */
+	linkKBps = ior->dp.bw * 27000 * ior->dp.nr;
+	dataKBps = DIV_ROUND_UP(datakbps, 8);
+	if (linkKBps < dataKBps) {
+		OUTP_DBG(&dp->outp, "link requirements changed");
 		goto done;
 	}
 
-	/* check that link is still trained */
+	/* Check that link is still trained. */
 	ret = nvkm_rdaux(dp->aux, DPCD_LS02, stat, 3);
 	if (ret) {
 		OUTP_DBG(&dp->outp,
@@ -411,7 +406,7 @@ nvkm_output_dp_train(struct nvkm_outp *outp, u32 datarate)
 	}
 
 	if (stat[2] & DPCD_LS04_INTERLANE_ALIGN_DONE) {
-		for (i = 0; i < (link[1] & DPCD_LC01_LANE_COUNT_SET); i++) {
+		for (i = 0; i < ior->dp.nr; i++) {
 			u8 lane = (stat[i >> 1] >> ((i & 1) * 4)) & 0x0f;
 			if (!(lane & DPCD_LS02_LANE0_CR_DONE) ||
 			    !(lane & DPCD_LS02_LANE0_CHANNEL_EQ_DONE) ||
@@ -435,7 +430,7 @@ nvkm_output_dp_train(struct nvkm_outp *outp, u32 datarate)
 			dp->dpcd[DPCD_RC02] =
 				dp->outp.info.dpconf.link_nr;
 		}
-		nvkm_dp_train(dp);
+		ret = nvkm_dp_train(dp);
 	}
 
 	mutex_unlock(&dp->mutex);

commit 4423c743ef961153d274f3ec0704672ba979419c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/dp: no need for lt_state except during manual link training
    
    This struct doesn't hold link configuration data anymore, so we can
    limit its use to internal DP training (anx9805 handles training for
    external DP).
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 94c861a3f999..2b3aca044975 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -196,9 +196,8 @@ nvkm_dp_train_cr(struct lt_state *lt)
 }
 
 static int
-nvkm_dp_train_links(struct lt_state *lt)
+nvkm_dp_train_links(struct nvkm_dp *dp)
 {
-	struct nvkm_dp *dp = lt->dp;
 	struct nvkm_ior *ior = dp->outp.ior;
 	struct nvkm_disp *disp = dp->outp.disp;
 	struct nvkm_subdev *subdev = &disp->engine.subdev;
@@ -211,6 +210,9 @@ nvkm_dp_train_links(struct lt_state *lt)
 		.crtc = -1,
 		.execute = 1,
 	};
+	struct lt_state lt = {
+		.dp = dp,
+	};
 	u32 lnkcmp;
 	u8 sink[2];
 	int ret;
@@ -220,11 +222,11 @@ nvkm_dp_train_links(struct lt_state *lt)
 
 	/* Intersect misc. capabilities of the OR and sink. */
 	if (disp->engine.subdev.device->chipset < 0xd0)
-		dp->dpcd[2] &= ~DPCD_RC02_TPS3_SUPPORTED;
-	lt->pc2 = dp->dpcd[2] & DPCD_RC02_TPS3_SUPPORTED;
+		dp->dpcd[DPCD_RC02] &= ~DPCD_RC02_TPS3_SUPPORTED;
+	lt.pc2 = dp->dpcd[DPCD_RC02] & DPCD_RC02_TPS3_SUPPORTED;
 
 	/* Set desired link configuration on the source. */
-	if ((lnkcmp = lt->dp->info.lnkcmp)) {
+	if ((lnkcmp = lt.dp->info.lnkcmp)) {
 		if (dp->version < 0x30) {
 			while ((ior->dp.bw * 2700) < nvbios_rd16(bios, lnkcmp))
 				lnkcmp += 4;
@@ -253,13 +255,22 @@ nvkm_dp_train_links(struct lt_state *lt)
 	if (ior->dp.ef)
 		sink[1] |= DPCD_LC01_ENHANCED_FRAME_EN;
 
-	return nvkm_wraux(dp->aux, DPCD_LC00_LINK_BW_SET, sink, 2);
+	ret = nvkm_wraux(dp->aux, DPCD_LC00_LINK_BW_SET, sink, 2);
+	if (ret)
+		return ret;
+
+	/* Attempt to train the link in this configuration. */
+	memset(lt.stat, 0x00, sizeof(lt.stat));
+	ret = nvkm_dp_train_cr(&lt);
+	if (ret == 0)
+		ret = nvkm_dp_train_eq(&lt);
+	nvkm_dp_train_pattern(&lt, 0);
+	return ret;
 }
 
 static void
-nvkm_dp_train_fini(struct lt_state *lt)
+nvkm_dp_train_fini(struct nvkm_dp *dp)
 {
-	struct nvkm_dp *dp = lt->dp;
 	struct nvkm_subdev *subdev = &dp->outp.disp->engine.subdev;
 	struct nvbios_init init = {
 		.subdev = subdev,
@@ -275,9 +286,8 @@ nvkm_dp_train_fini(struct lt_state *lt)
 }
 
 static void
-nvkm_dp_train_init(struct lt_state *lt)
+nvkm_dp_train_init(struct nvkm_dp *dp)
 {
-	struct nvkm_dp *dp = lt->dp;
 	struct nvkm_subdev *subdev = &dp->outp.disp->engine.subdev;
 	struct nvbios_init init = {
 		.subdev = subdev,
@@ -326,9 +336,6 @@ nvkm_dp_train(struct nvkm_dp *dp)
 	const u8 outp_nr = dp->outp.info.dpconf.link_nr;
 	const u8 outp_bw = dp->outp.info.dpconf.link_bw;
 	const struct dp_rates *cfg;
-	struct lt_state lt = {
-		.dp = dp,
-	};
 	u8  pwr;
 	int ret;
 
@@ -345,8 +352,8 @@ nvkm_dp_train(struct nvkm_dp *dp)
 	}
 
 	/* Link training. */
-	nvkm_dp_train_init(&lt);
-	for (ret = -EINVAL, cfg = nvkm_dp_rates; cfg->rate; cfg++) {
+	nvkm_dp_train_init(dp);
+	for (ret = -EINVAL, cfg = nvkm_dp_rates; ret < 0 && cfg->rate; cfg++) {
 		/* Skip configurations not supported by both OR and sink. */
 		if (cfg[1].rate &&
 		    (cfg->nr > outp_nr || cfg->bw > outp_bw ||
@@ -358,23 +365,9 @@ nvkm_dp_train(struct nvkm_dp *dp)
 		ior->dp.nr = cfg->nr;
 
 		/* Program selected link configuration. */
-		ret = nvkm_dp_train_links(&lt);
-		if (ret == 0) {
-			/* Attempt to train the link in this configuration. */
-			memset(lt.stat, 0x00, sizeof(lt.stat));
-			if (!nvkm_dp_train_cr(&lt) &&
-			    !nvkm_dp_train_eq(&lt))
-				break;
-		} else
-		if (ret) {
-			/* nvkm_dp_train_links() handled training, or
-			 * we failed to communicate with the sink.
-			 */
-			break;
-		}
+		ret = nvkm_dp_train_links(dp);
 	}
-	nvkm_dp_train_pattern(&lt, 0);
-	nvkm_dp_train_fini(&lt);
+	nvkm_dp_train_fini(dp);
 	if (ret < 0)
 		OUTP_ERR(&dp->outp, "training failed");
 

commit 75eefe95ee7565c695d1e736005876d18742537f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/dp: store current link configuration in nvkm_ior
    
    We care about this information outside of link training.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 601fa625e440..94c861a3f999 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -23,6 +23,7 @@
  */
 #include "dp.h"
 #include "conn.h"
+#include "ior.h"
 #include "nv50.h"
 
 #include <subdev/bios.h>
@@ -33,8 +34,6 @@
 
 struct lt_state {
 	struct nvkm_dp *dp;
-	int link_nr;
-	u32 link_bw;
 	u8  stat[6];
 	u8  conf[4];
 	bool pc2;
@@ -76,7 +75,7 @@ nvkm_dp_train_drive(struct lt_state *lt, bool pc)
 	struct nvkm_dp *dp = lt->dp;
 	int ret, i;
 
-	for (i = 0; i < lt->link_nr; i++) {
+	for (i = 0; i < dp->outp.ior->dp.nr; i++) {
 		u8 lane = (lt->stat[4 + (i >> 1)] >> ((i & 1) * 4)) & 0xf;
 		u8 lpc2 = (lt->pc2stat >> (i * 2)) & 0x3;
 		u8 lpre = (lane & 0x0c) >> 2;
@@ -137,7 +136,7 @@ nvkm_dp_train_eq(struct lt_state *lt)
 	bool eq_done = false, cr_done = true;
 	int tries = 0, i;
 
-	if (lt->dp->dpcd[2] & DPCD_RC02_TPS3_SUPPORTED)
+	if (lt->dp->dpcd[DPCD_RC02] & DPCD_RC02_TPS3_SUPPORTED)
 		nvkm_dp_train_pattern(lt, 3);
 	else
 		nvkm_dp_train_pattern(lt, 2);
@@ -149,7 +148,7 @@ nvkm_dp_train_eq(struct lt_state *lt)
 			break;
 
 		eq_done = !!(lt->stat[2] & DPCD_LS04_INTERLANE_ALIGN_DONE);
-		for (i = 0; i < lt->link_nr && eq_done; i++) {
+		for (i = 0; i < lt->dp->outp.ior->dp.nr && eq_done; i++) {
 			u8 lane = (lt->stat[i >> 1] >> ((i & 1) * 4)) & 0xf;
 			if (!(lane & DPCD_LS02_LANE0_CR_DONE))
 				cr_done = false;
@@ -177,7 +176,7 @@ nvkm_dp_train_cr(struct lt_state *lt)
 			break;
 
 		cr_done = true;
-		for (i = 0; i < lt->link_nr; i++) {
+		for (i = 0; i < lt->dp->outp.ior->dp.nr; i++) {
 			u8 lane = (lt->stat[i >> 1] >> ((i & 1) * 4)) & 0xf;
 			if (!(lane & DPCD_LS02_LANE0_CR_DONE)) {
 				cr_done = false;
@@ -200,6 +199,7 @@ static int
 nvkm_dp_train_links(struct lt_state *lt)
 {
 	struct nvkm_dp *dp = lt->dp;
+	struct nvkm_ior *ior = dp->outp.ior;
 	struct nvkm_disp *disp = dp->outp.disp;
 	struct nvkm_subdev *subdev = &disp->engine.subdev;
 	struct nvkm_bios *bios = subdev->device->bios;
@@ -215,7 +215,8 @@ nvkm_dp_train_links(struct lt_state *lt)
 	u8 sink[2];
 	int ret;
 
-	OUTP_DBG(&dp->outp, "%d lanes at %d KB/s", lt->link_nr, lt->link_bw);
+	OUTP_DBG(&dp->outp, "training %d x %d MB/s",
+		 ior->dp.nr, ior->dp.bw * 27);
 
 	/* Intersect misc. capabilities of the OR and sink. */
 	if (disp->engine.subdev.device->chipset < 0xd0)
@@ -225,11 +226,11 @@ nvkm_dp_train_links(struct lt_state *lt)
 	/* Set desired link configuration on the source. */
 	if ((lnkcmp = lt->dp->info.lnkcmp)) {
 		if (dp->version < 0x30) {
-			while ((lt->link_bw / 10) < nvbios_rd16(bios, lnkcmp))
+			while ((ior->dp.bw * 2700) < nvbios_rd16(bios, lnkcmp))
 				lnkcmp += 4;
 			init.offset = nvbios_rd16(bios, lnkcmp + 2);
 		} else {
-			while ((lt->link_bw / 27000) < nvbios_rd08(bios, lnkcmp))
+			while (ior->dp.bw < nvbios_rd08(bios, lnkcmp))
 				lnkcmp += 3;
 			init.offset = nvbios_rd16(bios, lnkcmp + 1);
 		}
@@ -237,21 +238,19 @@ nvkm_dp_train_links(struct lt_state *lt)
 		nvbios_exec(&init);
 	}
 
-	ret = dp->func->lnk_ctl(dp, lt->link_nr, lt->link_bw / 27000,
-				dp->dpcd[DPCD_RC02] &
-					 DPCD_RC02_ENHANCED_FRAME_CAP);
+	ret = dp->func->lnk_ctl(dp, ior->dp.nr, ior->dp.bw, ior->dp.ef);
 	if (ret) {
 		if (ret < 0)
 			OUTP_ERR(&dp->outp, "lnk_ctl failed with %d", ret);
 		return ret;
 	}
 
-	dp->func->lnk_pwr(dp, lt->link_nr);
+	dp->func->lnk_pwr(dp, ior->dp.nr);
 
 	/* Set desired link configuration on the sink. */
-	sink[0] = lt->link_bw / 27000;
-	sink[1] = lt->link_nr;
-	if (dp->dpcd[DPCD_RC02] & DPCD_RC02_ENHANCED_FRAME_CAP)
+	sink[0] = ior->dp.bw;
+	sink[1] = ior->dp.nr;
+	if (ior->dp.ef)
 		sink[1] |= DPCD_LC01_ENHANCED_FRAME_EN;
 
 	return nvkm_wraux(dp->aux, DPCD_LC00_LINK_BW_SET, sink, 2);
@@ -276,7 +275,7 @@ nvkm_dp_train_fini(struct lt_state *lt)
 }
 
 static void
-nvkm_dp_train_init(struct lt_state *lt, bool spread)
+nvkm_dp_train_init(struct lt_state *lt)
 {
 	struct nvkm_dp *dp = lt->dp;
 	struct nvkm_subdev *subdev = &dp->outp.disp->engine.subdev;
@@ -289,7 +288,7 @@ nvkm_dp_train_init(struct lt_state *lt, bool spread)
 	};
 
 	/* Execute EnableSpread/DisableSpread script from DP Info table. */
-	if (spread)
+	if (dp->dpcd[DPCD_RC03] & DPCD_RC03_MAX_DOWNSPREAD)
 		init.offset = dp->info.script[2];
 	else
 		init.offset = dp->info.script[3];
@@ -321,7 +320,12 @@ static void
 nvkm_dp_train(struct nvkm_dp *dp)
 {
 	struct nv50_disp *disp = nv50_disp(dp->outp.disp);
-	const struct dp_rates *cfg = nvkm_dp_rates - 1;
+	struct nvkm_ior *ior = dp->outp.ior;
+	const u8 sink_nr = dp->dpcd[DPCD_RC02] & DPCD_RC02_MAX_LANE_COUNT;
+	const u8 sink_bw = dp->dpcd[DPCD_RC01_MAX_LINK_RATE];
+	const u8 outp_nr = dp->outp.info.dpconf.link_nr;
+	const u8 outp_bw = dp->outp.info.dpconf.link_bw;
+	const struct dp_rates *cfg;
 	struct lt_state lt = {
 		.dp = dp,
 	};
@@ -331,13 +335,6 @@ nvkm_dp_train(struct nvkm_dp *dp)
 	if (!dp->outp.info.location && disp->func->sor.magic)
 		disp->func->sor.magic(&dp->outp);
 
-	if ((dp->dpcd[2] & 0x1f) > dp->outp.info.dpconf.link_nr) {
-		dp->dpcd[2] &= ~DPCD_RC02_MAX_LANE_COUNT;
-		dp->dpcd[2] |= dp->outp.info.dpconf.link_nr;
-	}
-	if (dp->dpcd[1] > dp->outp.info.dpconf.link_bw)
-		dp->dpcd[1] = dp->outp.info.dpconf.link_bw;
-
 	/* Ensure sink is not in a low-power state. */
 	if (!nvkm_rdaux(dp->aux, DPCD_SC00, &pwr, 1)) {
 		if ((pwr & DPCD_SC00_SET_POWER) != DPCD_SC00_SET_POWER_D0) {
@@ -348,14 +345,17 @@ nvkm_dp_train(struct nvkm_dp *dp)
 	}
 
 	/* Link training. */
-	nvkm_dp_train_init(&lt, dp->dpcd[3] & 0x01);
-	while (ret = -EIO, (++cfg)->rate) {
+	nvkm_dp_train_init(&lt);
+	for (ret = -EINVAL, cfg = nvkm_dp_rates; cfg->rate; cfg++) {
 		/* Skip configurations not supported by both OR and sink. */
-		while (cfg->nr > (dp->dpcd[2] & DPCD_RC02_MAX_LANE_COUNT) ||
-		       cfg->bw > (dp->dpcd[DPCD_RC01_MAX_LINK_RATE]))
-			cfg++;
-		lt.link_bw = cfg->bw * 27000;
-		lt.link_nr = cfg->nr;
+		if (cfg[1].rate &&
+		    (cfg->nr > outp_nr || cfg->bw > outp_bw ||
+		     cfg->nr > sink_nr || cfg->bw > sink_bw))
+			continue;
+		ior->dp.mst = dp->lt.mst;
+		ior->dp.ef = dp->dpcd[DPCD_RC02] & DPCD_RC02_ENHANCED_FRAME_CAP;
+		ior->dp.bw = cfg->bw;
+		ior->dp.nr = cfg->nr;
 
 		/* Program selected link configuration. */
 		ret = nvkm_dp_train_links(&lt);

commit 01a976376b6e57838f223dd2d2639597efd92db4
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp: identity-map display paths to output resources
    
    This essentially replicates our current behaviour in a way that's
    compatible with the new model that's emerging, so that we're able
    to start porting the hw-specific functions to it.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index d62e93bb0f70..601fa625e440 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -562,7 +562,10 @@ nvkm_dp_ctor(struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
 	u32 data;
 	int ret;
 
-	nvkm_outp_ctor(&nvkm_dp_func, disp, index, dcbE, &dp->outp);
+	ret = nvkm_outp_ctor(&nvkm_dp_func, disp, index, dcbE, &dp->outp);
+	if (ret)
+		return ret;
+
 	dp->aux = aux;
 	if (!dp->aux) {
 		OUTP_ERR(&dp->outp, "no aux");

commit 981a8162e2f8282c90f6523324bb51720699bc6a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/disp: s/nvkm_connector/nvkm_conn/
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 8a68761edc49..d62e93bb0f70 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -482,7 +482,7 @@ nvkm_dp_hpd(struct nvkm_notify *notify)
 {
 	const struct nvkm_i2c_ntfy_rep *line = notify->data;
 	struct nvkm_dp *dp = container_of(notify, typeof(*dp), hpd);
-	struct nvkm_connector *conn = dp->outp.conn;
+	struct nvkm_conn *conn = dp->outp.conn;
 	struct nvkm_disp *disp = dp->outp.disp;
 	struct nvif_notify_conn_rep_v0 rep = {};
 
@@ -503,7 +503,7 @@ nvkm_dp_irq(struct nvkm_notify *notify)
 {
 	const struct nvkm_i2c_ntfy_rep *line = notify->data;
 	struct nvkm_dp *dp = container_of(notify, typeof(*dp), irq);
-	struct nvkm_connector *conn = dp->outp.conn;
+	struct nvkm_conn *conn = dp->outp.conn;
 	struct nvkm_disp *disp = dp->outp.disp;
 	struct nvif_notify_conn_rep_v0 rep = {
 		.mask = NVIF_NOTIFY_CONN_V0_IRQ,

commit f3e70d2991df5591263f2e9f83e74cc047462240
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/disp: rename nvkm_output_dp to nvkm_dp
    
    Not all users of nvkm_output_dp have been changed here.  The remaining
    ones belong to code that's disappearing in upcoming commits.
    
    This also modifies the debug level of some messages.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 35d9f0fc3fe8..8a68761edc49 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -32,7 +32,7 @@
 #include <nvif/event.h>
 
 struct lt_state {
-	struct nvkm_output_dp *outp;
+	struct nvkm_dp *dp;
 	int link_nr;
 	u32 link_bw;
 	u8  stat[6];
@@ -45,26 +45,26 @@ struct lt_state {
 static int
 nvkm_dp_train_sense(struct lt_state *lt, bool pc, u32 delay)
 {
-	struct nvkm_output_dp *outp = lt->outp;
+	struct nvkm_dp *dp = lt->dp;
 	int ret;
 
-	if (outp->dpcd[DPCD_RC0E_AUX_RD_INTERVAL])
-		mdelay(outp->dpcd[DPCD_RC0E_AUX_RD_INTERVAL] * 4);
+	if (dp->dpcd[DPCD_RC0E_AUX_RD_INTERVAL])
+		mdelay(dp->dpcd[DPCD_RC0E_AUX_RD_INTERVAL] * 4);
 	else
 		udelay(delay);
 
-	ret = nvkm_rdaux(outp->aux, DPCD_LS02, lt->stat, 6);
+	ret = nvkm_rdaux(dp->aux, DPCD_LS02, lt->stat, 6);
 	if (ret)
 		return ret;
 
 	if (pc) {
-		ret = nvkm_rdaux(outp->aux, DPCD_LS0C, &lt->pc2stat, 1);
+		ret = nvkm_rdaux(dp->aux, DPCD_LS0C, &lt->pc2stat, 1);
 		if (ret)
 			lt->pc2stat = 0x00;
-		OUTP_DBG(&outp->base, "status %6ph pc2 %02x",
-			 lt->stat, lt->pc2stat);
+		OUTP_TRACE(&dp->outp, "status %6ph pc2 %02x",
+			   lt->stat, lt->pc2stat);
 	} else {
-		OUTP_DBG(&outp->base, "status %6ph", lt->stat);
+		OUTP_TRACE(&dp->outp, "status %6ph", lt->stat);
 	}
 
 	return 0;
@@ -73,7 +73,7 @@ nvkm_dp_train_sense(struct lt_state *lt, bool pc, u32 delay)
 static int
 nvkm_dp_train_drive(struct lt_state *lt, bool pc)
 {
-	struct nvkm_output_dp *outp = lt->outp;
+	struct nvkm_dp *dp = lt->dp;
 	int ret, i;
 
 	for (i = 0; i < lt->link_nr; i++) {
@@ -98,17 +98,17 @@ nvkm_dp_train_drive(struct lt_state *lt, bool pc)
 		lt->conf[i] = (lpre << 3) | lvsw;
 		lt->pc2conf[i >> 1] |= lpc2 << ((i & 1) * 4);
 
-		OUTP_DBG(&outp->base, "config lane %d %02x %02x",
-			 i, lt->conf[i], lpc2);
-		outp->func->drv_ctl(outp, i, lvsw & 3, lpre & 3, lpc2 & 3);
+		OUTP_TRACE(&dp->outp, "config lane %d %02x %02x",
+			   i, lt->conf[i], lpc2);
+		dp->func->drv_ctl(dp, i, lvsw & 3, lpre & 3, lpc2 & 3);
 	}
 
-	ret = nvkm_wraux(outp->aux, DPCD_LC03(0), lt->conf, 4);
+	ret = nvkm_wraux(dp->aux, DPCD_LC03(0), lt->conf, 4);
 	if (ret)
 		return ret;
 
 	if (pc) {
-		ret = nvkm_wraux(outp->aux, DPCD_LC0F, lt->pc2conf, 2);
+		ret = nvkm_wraux(dp->aux, DPCD_LC0F, lt->pc2conf, 2);
 		if (ret)
 			return ret;
 	}
@@ -119,26 +119,25 @@ nvkm_dp_train_drive(struct lt_state *lt, bool pc)
 static void
 nvkm_dp_train_pattern(struct lt_state *lt, u8 pattern)
 {
-	struct nvkm_output_dp *outp = lt->outp;
+	struct nvkm_dp *dp = lt->dp;
 	u8 sink_tp;
 
-	OUTP_DBG(&outp->base, "training pattern %d", pattern);
-	outp->func->pattern(outp, pattern);
+	OUTP_TRACE(&dp->outp, "training pattern %d", pattern);
+	dp->func->pattern(dp, pattern);
 
-	nvkm_rdaux(outp->aux, DPCD_LC02, &sink_tp, 1);
+	nvkm_rdaux(dp->aux, DPCD_LC02, &sink_tp, 1);
 	sink_tp &= ~DPCD_LC02_TRAINING_PATTERN_SET;
 	sink_tp |= pattern;
-	nvkm_wraux(outp->aux, DPCD_LC02, &sink_tp, 1);
+	nvkm_wraux(dp->aux, DPCD_LC02, &sink_tp, 1);
 }
 
 static int
 nvkm_dp_train_eq(struct lt_state *lt)
 {
-	struct nvkm_output_dp *outp = lt->outp;
 	bool eq_done = false, cr_done = true;
 	int tries = 0, i;
 
-	if (outp->dpcd[2] & DPCD_RC02_TPS3_SUPPORTED)
+	if (lt->dp->dpcd[2] & DPCD_RC02_TPS3_SUPPORTED)
 		nvkm_dp_train_pattern(lt, 3);
 	else
 		nvkm_dp_train_pattern(lt, 2);
@@ -200,15 +199,15 @@ nvkm_dp_train_cr(struct lt_state *lt)
 static int
 nvkm_dp_train_links(struct lt_state *lt)
 {
-	struct nvkm_output_dp *outp = lt->outp;
-	struct nvkm_disp *disp = outp->base.disp;
+	struct nvkm_dp *dp = lt->dp;
+	struct nvkm_disp *disp = dp->outp.disp;
 	struct nvkm_subdev *subdev = &disp->engine.subdev;
 	struct nvkm_bios *bios = subdev->device->bios;
 	struct nvbios_init init = {
 		.subdev = subdev,
 		.bios = bios,
 		.offset = 0x0000,
-		.outp = &outp->base.info,
+		.outp = &dp->outp.info,
 		.crtc = -1,
 		.execute = 1,
 	};
@@ -216,16 +215,16 @@ nvkm_dp_train_links(struct lt_state *lt)
 	u8 sink[2];
 	int ret;
 
-	OUTP_DBG(&outp->base, "%d lanes at %d KB/s", lt->link_nr, lt->link_bw);
+	OUTP_DBG(&dp->outp, "%d lanes at %d KB/s", lt->link_nr, lt->link_bw);
 
 	/* Intersect misc. capabilities of the OR and sink. */
 	if (disp->engine.subdev.device->chipset < 0xd0)
-		outp->dpcd[2] &= ~DPCD_RC02_TPS3_SUPPORTED;
-	lt->pc2 = outp->dpcd[2] & DPCD_RC02_TPS3_SUPPORTED;
+		dp->dpcd[2] &= ~DPCD_RC02_TPS3_SUPPORTED;
+	lt->pc2 = dp->dpcd[2] & DPCD_RC02_TPS3_SUPPORTED;
 
 	/* Set desired link configuration on the source. */
-	if ((lnkcmp = lt->outp->info.lnkcmp)) {
-		if (outp->version < 0x30) {
+	if ((lnkcmp = lt->dp->info.lnkcmp)) {
+		if (dp->version < 0x30) {
 			while ((lt->link_bw / 10) < nvbios_rd16(bios, lnkcmp))
 				lnkcmp += 4;
 			init.offset = nvbios_rd16(bios, lnkcmp + 2);
@@ -238,68 +237,66 @@ nvkm_dp_train_links(struct lt_state *lt)
 		nvbios_exec(&init);
 	}
 
-	ret = outp->func->lnk_ctl(outp, lt->link_nr, lt->link_bw / 27000,
-				  outp->dpcd[DPCD_RC02] &
-					     DPCD_RC02_ENHANCED_FRAME_CAP);
+	ret = dp->func->lnk_ctl(dp, lt->link_nr, lt->link_bw / 27000,
+				dp->dpcd[DPCD_RC02] &
+					 DPCD_RC02_ENHANCED_FRAME_CAP);
 	if (ret) {
 		if (ret < 0)
-			OUTP_ERR(&outp->base, "lnk_ctl failed with %d", ret);
+			OUTP_ERR(&dp->outp, "lnk_ctl failed with %d", ret);
 		return ret;
 	}
 
-	outp->func->lnk_pwr(outp, lt->link_nr);
+	dp->func->lnk_pwr(dp, lt->link_nr);
 
 	/* Set desired link configuration on the sink. */
 	sink[0] = lt->link_bw / 27000;
 	sink[1] = lt->link_nr;
-	if (outp->dpcd[DPCD_RC02] & DPCD_RC02_ENHANCED_FRAME_CAP)
+	if (dp->dpcd[DPCD_RC02] & DPCD_RC02_ENHANCED_FRAME_CAP)
 		sink[1] |= DPCD_LC01_ENHANCED_FRAME_EN;
 
-	return nvkm_wraux(outp->aux, DPCD_LC00_LINK_BW_SET, sink, 2);
+	return nvkm_wraux(dp->aux, DPCD_LC00_LINK_BW_SET, sink, 2);
 }
 
 static void
 nvkm_dp_train_fini(struct lt_state *lt)
 {
-	struct nvkm_output_dp *outp = lt->outp;
-	struct nvkm_disp *disp = outp->base.disp;
-	struct nvkm_subdev *subdev = &disp->engine.subdev;
+	struct nvkm_dp *dp = lt->dp;
+	struct nvkm_subdev *subdev = &dp->outp.disp->engine.subdev;
 	struct nvbios_init init = {
 		.subdev = subdev,
 		.bios = subdev->device->bios,
-		.outp = &outp->base.info,
+		.outp = &dp->outp.info,
 		.crtc = -1,
 		.execute = 1,
 	};
 
 	/* Execute AfterLinkTraining script from DP Info table. */
-	init.offset = outp->info.script[1],
+	init.offset = dp->info.script[1],
 	nvbios_exec(&init);
 }
 
 static void
 nvkm_dp_train_init(struct lt_state *lt, bool spread)
 {
-	struct nvkm_output_dp *outp = lt->outp;
-	struct nvkm_disp *disp = outp->base.disp;
-	struct nvkm_subdev *subdev = &disp->engine.subdev;
+	struct nvkm_dp *dp = lt->dp;
+	struct nvkm_subdev *subdev = &dp->outp.disp->engine.subdev;
 	struct nvbios_init init = {
 		.subdev = subdev,
 		.bios = subdev->device->bios,
-		.outp = &outp->base.info,
+		.outp = &dp->outp.info,
 		.crtc = -1,
 		.execute = 1,
 	};
 
 	/* Execute EnableSpread/DisableSpread script from DP Info table. */
 	if (spread)
-		init.offset = outp->info.script[2];
+		init.offset = dp->info.script[2];
 	else
-		init.offset = outp->info.script[3];
+		init.offset = dp->info.script[3];
 	nvbios_exec(&init);
 
-	/* Execute BeforeLinkTraining script from DP info table. */
-	init.offset = outp->info.script[0];
+	/* Execute BeforeLinkTraining script from DP Info table. */
+	init.offset = dp->info.script[0];
 	nvbios_exec(&init);
 }
 
@@ -321,41 +318,41 @@ static const struct dp_rates {
 };
 
 static void
-nvkm_dp_train(struct nvkm_output_dp *outp)
+nvkm_dp_train(struct nvkm_dp *dp)
 {
-	struct nv50_disp *disp = nv50_disp(outp->base.disp);
+	struct nv50_disp *disp = nv50_disp(dp->outp.disp);
 	const struct dp_rates *cfg = nvkm_dp_rates - 1;
 	struct lt_state lt = {
-		.outp = outp,
+		.dp = dp,
 	};
 	u8  pwr;
 	int ret;
 
-	if (!outp->base.info.location && disp->func->sor.magic)
-		disp->func->sor.magic(&outp->base);
+	if (!dp->outp.info.location && disp->func->sor.magic)
+		disp->func->sor.magic(&dp->outp);
 
-	if ((outp->dpcd[2] & 0x1f) > outp->base.info.dpconf.link_nr) {
-		outp->dpcd[2] &= ~DPCD_RC02_MAX_LANE_COUNT;
-		outp->dpcd[2] |= outp->base.info.dpconf.link_nr;
+	if ((dp->dpcd[2] & 0x1f) > dp->outp.info.dpconf.link_nr) {
+		dp->dpcd[2] &= ~DPCD_RC02_MAX_LANE_COUNT;
+		dp->dpcd[2] |= dp->outp.info.dpconf.link_nr;
 	}
-	if (outp->dpcd[1] > outp->base.info.dpconf.link_bw)
-		outp->dpcd[1] = outp->base.info.dpconf.link_bw;
+	if (dp->dpcd[1] > dp->outp.info.dpconf.link_bw)
+		dp->dpcd[1] = dp->outp.info.dpconf.link_bw;
 
 	/* Ensure sink is not in a low-power state. */
-	if (!nvkm_rdaux(outp->aux, DPCD_SC00, &pwr, 1)) {
+	if (!nvkm_rdaux(dp->aux, DPCD_SC00, &pwr, 1)) {
 		if ((pwr & DPCD_SC00_SET_POWER) != DPCD_SC00_SET_POWER_D0) {
 			pwr &= ~DPCD_SC00_SET_POWER;
 			pwr |=  DPCD_SC00_SET_POWER_D0;
-			nvkm_wraux(outp->aux, DPCD_SC00, &pwr, 1);
+			nvkm_wraux(dp->aux, DPCD_SC00, &pwr, 1);
 		}
 	}
 
 	/* Link training. */
-	nvkm_dp_train_init(&lt, outp->dpcd[3] & 0x01);
+	nvkm_dp_train_init(&lt, dp->dpcd[3] & 0x01);
 	while (ret = -EIO, (++cfg)->rate) {
 		/* Skip configurations not supported by both OR and sink. */
-		while (cfg->nr > (outp->dpcd[2] & DPCD_RC02_MAX_LANE_COUNT) ||
-		       cfg->bw > (outp->dpcd[DPCD_RC01_MAX_LINK_RATE]))
+		while (cfg->nr > (dp->dpcd[2] & DPCD_RC02_MAX_LANE_COUNT) ||
+		       cfg->bw > (dp->dpcd[DPCD_RC01_MAX_LINK_RATE]))
 			cfg++;
 		lt.link_bw = cfg->bw * 27000;
 		lt.link_nr = cfg->nr;
@@ -379,27 +376,27 @@ nvkm_dp_train(struct nvkm_output_dp *outp)
 	nvkm_dp_train_pattern(&lt, 0);
 	nvkm_dp_train_fini(&lt);
 	if (ret < 0)
-		OUTP_ERR(&outp->base, "link training failed");
+		OUTP_ERR(&dp->outp, "training failed");
 
-	OUTP_DBG(&outp->base, "training complete");
-	atomic_set(&outp->lt.done, 1);
+	OUTP_DBG(&dp->outp, "training done");
+	atomic_set(&dp->lt.done, 1);
 }
 
 int
-nvkm_output_dp_train(struct nvkm_output *base, u32 datarate)
+nvkm_output_dp_train(struct nvkm_outp *outp, u32 datarate)
 {
-	struct nvkm_output_dp *outp = nvkm_output_dp(base);
+	struct nvkm_dp *dp = nvkm_dp(outp);
 	bool retrain = true;
 	u8 link[2], stat[3];
 	u32 linkrate;
 	int ret, i;
 
-	mutex_lock(&outp->mutex);
+	mutex_lock(&dp->mutex);
 
 	/* check that the link is trained at a high enough rate */
-	ret = nvkm_rdaux(outp->aux, DPCD_LC00_LINK_BW_SET, link, 2);
+	ret = nvkm_rdaux(dp->aux, DPCD_LC00_LINK_BW_SET, link, 2);
 	if (ret) {
-		OUTP_DBG(&outp->base,
+		OUTP_DBG(&dp->outp,
 			 "failed to read link config, assuming no sink");
 		goto done;
 	}
@@ -408,14 +405,14 @@ nvkm_output_dp_train(struct nvkm_output *base, u32 datarate)
 	linkrate = (linkrate * 8) / 10; /* 8B/10B coding overhead */
 	datarate = (datarate + 9) / 10; /* -> decakilobits */
 	if (linkrate < datarate) {
-		OUTP_DBG(&outp->base, "link not trained at sufficient rate");
+		OUTP_DBG(&dp->outp, "link not trained at sufficient rate");
 		goto done;
 	}
 
 	/* check that link is still trained */
-	ret = nvkm_rdaux(outp->aux, DPCD_LS02, stat, 3);
+	ret = nvkm_rdaux(dp->aux, DPCD_LS02, stat, 3);
 	if (ret) {
-		OUTP_DBG(&outp->base,
+		OUTP_DBG(&dp->outp,
 			 "failed to read link status, assuming no sink");
 		goto done;
 	}
@@ -426,71 +423,71 @@ nvkm_output_dp_train(struct nvkm_output *base, u32 datarate)
 			if (!(lane & DPCD_LS02_LANE0_CR_DONE) ||
 			    !(lane & DPCD_LS02_LANE0_CHANNEL_EQ_DONE) ||
 			    !(lane & DPCD_LS02_LANE0_SYMBOL_LOCKED)) {
-				OUTP_DBG(&outp->base,
+				OUTP_DBG(&dp->outp,
 					 "lane %d not equalised", lane);
 				goto done;
 			}
 		}
 		retrain = false;
 	} else {
-		OUTP_DBG(&outp->base, "no inter-lane alignment");
+		OUTP_DBG(&dp->outp, "no inter-lane alignment");
 	}
 
 done:
-	if (retrain || !atomic_read(&outp->lt.done)) {
+	if (retrain || !atomic_read(&dp->lt.done)) {
 		/* no sink, but still need to configure source */
-		if (outp->dpcd[DPCD_RC00_DPCD_REV] == 0x00) {
-			outp->dpcd[DPCD_RC01_MAX_LINK_RATE] =
-				outp->base.info.dpconf.link_bw;
-			outp->dpcd[DPCD_RC02] =
-				outp->base.info.dpconf.link_nr;
+		if (dp->dpcd[DPCD_RC00_DPCD_REV] == 0x00) {
+			dp->dpcd[DPCD_RC01_MAX_LINK_RATE] =
+				dp->outp.info.dpconf.link_bw;
+			dp->dpcd[DPCD_RC02] =
+				dp->outp.info.dpconf.link_nr;
 		}
-		nvkm_dp_train(outp);
+		nvkm_dp_train(dp);
 	}
 
-	mutex_unlock(&outp->mutex);
+	mutex_unlock(&dp->mutex);
 	return ret;
 }
 
 static void
-nvkm_output_dp_enable(struct nvkm_output_dp *outp, bool enable)
+nvkm_dp_enable(struct nvkm_dp *dp, bool enable)
 {
-	struct nvkm_i2c_aux *aux = outp->aux;
+	struct nvkm_i2c_aux *aux = dp->aux;
 
 	if (enable) {
-		if (!outp->present) {
-			OUTP_DBG(&outp->base, "aux power -> always");
+		if (!dp->present) {
+			OUTP_DBG(&dp->outp, "aux power -> always");
 			nvkm_i2c_aux_monitor(aux, true);
-			outp->present = true;
+			dp->present = true;
 		}
 
-		if (!nvkm_rdaux(aux, DPCD_RC00_DPCD_REV, outp->dpcd,
-				sizeof(outp->dpcd))) {
-			nvkm_output_dp_train(&outp->base, 0);
+		if (!nvkm_rdaux(aux, DPCD_RC00_DPCD_REV, dp->dpcd,
+				sizeof(dp->dpcd))) {
+			nvkm_output_dp_train(&dp->outp, 0);
 			return;
 		}
 	}
 
-	if (outp->present) {
-		OUTP_DBG(&outp->base, "aux power -> demand");
+	if (dp->present) {
+		OUTP_DBG(&dp->outp, "aux power -> demand");
 		nvkm_i2c_aux_monitor(aux, false);
-		outp->present = false;
+		dp->present = false;
 	}
 
-	atomic_set(&outp->lt.done, 0);
+	atomic_set(&dp->lt.done, 0);
 }
 
 static int
-nvkm_output_dp_hpd(struct nvkm_notify *notify)
+nvkm_dp_hpd(struct nvkm_notify *notify)
 {
 	const struct nvkm_i2c_ntfy_rep *line = notify->data;
-	struct nvkm_output_dp *outp = container_of(notify, typeof(*outp), hpd);
-	struct nvkm_connector *conn = outp->base.conn;
-	struct nvkm_disp *disp = outp->base.disp;
+	struct nvkm_dp *dp = container_of(notify, typeof(*dp), hpd);
+	struct nvkm_connector *conn = dp->outp.conn;
+	struct nvkm_disp *disp = dp->outp.disp;
 	struct nvif_notify_conn_rep_v0 rep = {};
 
-	OUTP_DBG(&outp->base, "HPD: %d", line->mask);
-	nvkm_output_dp_enable(outp, true);
+	OUTP_DBG(&dp->outp, "HPD: %d", line->mask);
+	nvkm_dp_enable(dp, true);
 
 	if (line->mask & NVKM_I2C_UNPLUG)
 		rep.mask |= NVIF_NOTIFY_CONN_V0_UNPLUG;
@@ -502,62 +499,61 @@ nvkm_output_dp_hpd(struct nvkm_notify *notify)
 }
 
 static int
-nvkm_output_dp_irq(struct nvkm_notify *notify)
+nvkm_dp_irq(struct nvkm_notify *notify)
 {
 	const struct nvkm_i2c_ntfy_rep *line = notify->data;
-	struct nvkm_output_dp *outp = container_of(notify, typeof(*outp), irq);
-	struct nvkm_connector *conn = outp->base.conn;
-	struct nvkm_disp *disp = outp->base.disp;
+	struct nvkm_dp *dp = container_of(notify, typeof(*dp), irq);
+	struct nvkm_connector *conn = dp->outp.conn;
+	struct nvkm_disp *disp = dp->outp.disp;
 	struct nvif_notify_conn_rep_v0 rep = {
 		.mask = NVIF_NOTIFY_CONN_V0_IRQ,
 	};
 
-	OUTP_DBG(&outp->base, "IRQ: %d", line->mask);
-	nvkm_output_dp_train(&outp->base, 0);
+	OUTP_DBG(&dp->outp, "IRQ: %d", line->mask);
+	nvkm_output_dp_train(&dp->outp, 0);
 
 	nvkm_event_send(&disp->hpd, rep.mask, conn->index, &rep, sizeof(rep));
 	return NVKM_NOTIFY_KEEP;
 }
 
 static void
-nvkm_output_dp_fini(struct nvkm_output *base)
+nvkm_dp_fini(struct nvkm_outp *outp)
 {
-	struct nvkm_output_dp *outp = nvkm_output_dp(base);
-	nvkm_notify_put(&outp->hpd);
-	nvkm_notify_put(&outp->irq);
-	nvkm_output_dp_enable(outp, false);
+	struct nvkm_dp *dp = nvkm_dp(outp);
+	nvkm_notify_put(&dp->hpd);
+	nvkm_notify_put(&dp->irq);
+	nvkm_dp_enable(dp, false);
 }
 
 static void
-nvkm_output_dp_init(struct nvkm_output *base)
+nvkm_dp_init(struct nvkm_outp *outp)
 {
-	struct nvkm_output_dp *outp = nvkm_output_dp(base);
-	nvkm_notify_put(&outp->base.conn->hpd);
-	nvkm_output_dp_enable(outp, true);
-	nvkm_notify_get(&outp->irq);
-	nvkm_notify_get(&outp->hpd);
+	struct nvkm_dp *dp = nvkm_dp(outp);
+	nvkm_notify_put(&dp->outp.conn->hpd);
+	nvkm_dp_enable(dp, true);
+	nvkm_notify_get(&dp->irq);
+	nvkm_notify_get(&dp->hpd);
 }
 
 static void *
-nvkm_output_dp_dtor(struct nvkm_output *base)
+nvkm_dp_dtor(struct nvkm_outp *outp)
 {
-	struct nvkm_output_dp *outp = nvkm_output_dp(base);
-	nvkm_notify_fini(&outp->hpd);
-	nvkm_notify_fini(&outp->irq);
-	return outp;
+	struct nvkm_dp *dp = nvkm_dp(outp);
+	nvkm_notify_fini(&dp->hpd);
+	nvkm_notify_fini(&dp->irq);
+	return dp;
 }
 
-static const struct nvkm_output_func
-nvkm_output_dp_func = {
-	.dtor = nvkm_output_dp_dtor,
-	.init = nvkm_output_dp_init,
-	.fini = nvkm_output_dp_fini,
+static const struct nvkm_outp_func
+nvkm_dp_func = {
+	.dtor = nvkm_dp_dtor,
+	.init = nvkm_dp_init,
+	.fini = nvkm_dp_fini,
 };
 
-int
-nvkm_output_dp_ctor(const struct nvkm_output_dp_func *func,
-		    struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
-		    struct nvkm_i2c_aux *aux, struct nvkm_output_dp *outp)
+static int
+nvkm_dp_ctor(struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
+	     struct nvkm_i2c_aux *aux, struct nvkm_dp *dp)
 {
 	struct nvkm_device *device = disp->engine.subdev.device;
 	struct nvkm_bios *bios = device->bios;
@@ -566,54 +562,53 @@ nvkm_output_dp_ctor(const struct nvkm_output_dp_func *func,
 	u32 data;
 	int ret;
 
-	nvkm_outp_ctor(&nvkm_output_dp_func, disp, index, dcbE, &outp->base);
-	outp->func = func;
-	outp->aux = aux;
-	if (!outp->aux) {
-		OUTP_ERR(&outp->base, "no aux");
+	nvkm_outp_ctor(&nvkm_dp_func, disp, index, dcbE, &dp->outp);
+	dp->aux = aux;
+	if (!dp->aux) {
+		OUTP_ERR(&dp->outp, "no aux");
 		return -ENODEV;
 	}
 
 	/* bios data is not optional */
-	data = nvbios_dpout_match(bios, outp->base.info.hasht,
-				  outp->base.info.hashm, &outp->version,
-				  &hdr, &cnt, &len, &outp->info);
+	data = nvbios_dpout_match(bios, dp->outp.info.hasht,
+				  dp->outp.info.hashm, &dp->version,
+				  &hdr, &cnt, &len, &dp->info);
 	if (!data) {
-		OUTP_ERR(&outp->base, "no bios dp data");
+		OUTP_ERR(&dp->outp, "no bios dp data");
 		return -ENODEV;
 	}
 
-	OUTP_DBG(&outp->base, "bios dp %02x %02x %02x %02x",
-		 outp->version, hdr, cnt, len);
+	OUTP_DBG(&dp->outp, "bios dp %02x %02x %02x %02x",
+		 dp->version, hdr, cnt, len);
 
 	/* link maintenance */
-	ret = nvkm_notify_init(NULL, &i2c->event, nvkm_output_dp_irq, true,
+	ret = nvkm_notify_init(NULL, &i2c->event, nvkm_dp_irq, true,
 			       &(struct nvkm_i2c_ntfy_req) {
 				.mask = NVKM_I2C_IRQ,
-				.port = outp->aux->id,
+				.port = dp->aux->id,
 			       },
 			       sizeof(struct nvkm_i2c_ntfy_req),
 			       sizeof(struct nvkm_i2c_ntfy_rep),
-			       &outp->irq);
+			       &dp->irq);
 	if (ret) {
-		OUTP_ERR(&outp->base, "error monitoring aux irq: %d", ret);
+		OUTP_ERR(&dp->outp, "error monitoring aux irq: %d", ret);
 		return ret;
 	}
 
-	mutex_init(&outp->mutex);
-	atomic_set(&outp->lt.done, 0);
+	mutex_init(&dp->mutex);
+	atomic_set(&dp->lt.done, 0);
 
 	/* hotplug detect, replaces gpio-based mechanism with aux events */
-	ret = nvkm_notify_init(NULL, &i2c->event, nvkm_output_dp_hpd, true,
+	ret = nvkm_notify_init(NULL, &i2c->event, nvkm_dp_hpd, true,
 			       &(struct nvkm_i2c_ntfy_req) {
 				.mask = NVKM_I2C_PLUG | NVKM_I2C_UNPLUG,
-				.port = outp->aux->id,
+				.port = dp->aux->id,
 			       },
 			       sizeof(struct nvkm_i2c_ntfy_req),
 			       sizeof(struct nvkm_i2c_ntfy_rep),
-			       &outp->hpd);
+			       &dp->hpd);
 	if (ret) {
-		OUTP_ERR(&outp->base, "error monitoring aux hpd: %d", ret);
+		OUTP_ERR(&dp->outp, "error monitoring aux hpd: %d", ret);
 		return ret;
 	}
 
@@ -623,15 +618,21 @@ nvkm_output_dp_ctor(const struct nvkm_output_dp_func *func,
 int
 nvkm_output_dp_new_(const struct nvkm_output_dp_func *func,
 		    struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
-		    struct nvkm_output **poutp)
+		    struct nvkm_outp **poutp)
 {
 	struct nvkm_i2c *i2c = disp->engine.subdev.device->i2c;
-	struct nvkm_i2c_aux *aux = nvkm_i2c_aux_find(i2c, dcbE->i2c_index);
-	struct nvkm_output_dp *outp;
+	struct nvkm_i2c_aux *aux;
+	struct nvkm_dp *dp;
+
+	if (dcbE->location == 0)
+		aux = nvkm_i2c_aux_find(i2c, NVKM_I2C_AUX_CCB(dcbE->i2c_index));
+	else
+		aux = nvkm_i2c_aux_find(i2c, NVKM_I2C_AUX_EXT(dcbE->extdev));
 
-	if (!(outp = kzalloc(sizeof(*outp), GFP_KERNEL)))
+	if (!(dp = kzalloc(sizeof(*dp), GFP_KERNEL)))
 		return -ENOMEM;
-	*poutp = &outp->base;
+	dp->func = func;
+	*poutp = &dp->outp;
 
-	return nvkm_output_dp_ctor(func, disp, index, dcbE, aux, outp);
+	return nvkm_dp_ctor(disp, index, dcbE, aux, dp);
 }

commit d7ce92e27303082f00cf0976d673f4cc0a5f1c5f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/disp: rename nvkm_output to nvkm_outp
    
    This isn't technically "output", but, "display/output path".
    
    Not all users of nvkm_output have been changed here.  The remaining
    ones belong to code that's disappearing in upcoming commits.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
index 1a3c460bcfe9..35d9f0fc3fe8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -566,7 +566,7 @@ nvkm_output_dp_ctor(const struct nvkm_output_dp_func *func,
 	u32 data;
 	int ret;
 
-	nvkm_output_ctor(&nvkm_output_dp_func, disp, index, dcbE, &outp->base);
+	nvkm_outp_ctor(&nvkm_output_dp_func, disp, index, dcbE, &outp->base);
 	outp->func = func;
 	outp->aux = aux;
 	if (!outp->aux) {

commit af85389c614ae04970c0eea7a5c50fb889c8a480
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/disp: shuffle functions around
    
    Upcoming changes to split OR from output path drastically change the
    placement of various operations.
    
    In order to make the real changes clearer, do the moving around part
    ahead of time.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
new file mode 100644
index 000000000000..1a3c460bcfe9
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c
@@ -0,0 +1,637 @@
+/*
+ * Copyright 2014 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+#include "dp.h"
+#include "conn.h"
+#include "nv50.h"
+
+#include <subdev/bios.h>
+#include <subdev/bios/init.h>
+#include <subdev/i2c.h>
+
+#include <nvif/event.h>
+
+struct lt_state {
+	struct nvkm_output_dp *outp;
+	int link_nr;
+	u32 link_bw;
+	u8  stat[6];
+	u8  conf[4];
+	bool pc2;
+	u8  pc2stat;
+	u8  pc2conf[2];
+};
+
+static int
+nvkm_dp_train_sense(struct lt_state *lt, bool pc, u32 delay)
+{
+	struct nvkm_output_dp *outp = lt->outp;
+	int ret;
+
+	if (outp->dpcd[DPCD_RC0E_AUX_RD_INTERVAL])
+		mdelay(outp->dpcd[DPCD_RC0E_AUX_RD_INTERVAL] * 4);
+	else
+		udelay(delay);
+
+	ret = nvkm_rdaux(outp->aux, DPCD_LS02, lt->stat, 6);
+	if (ret)
+		return ret;
+
+	if (pc) {
+		ret = nvkm_rdaux(outp->aux, DPCD_LS0C, &lt->pc2stat, 1);
+		if (ret)
+			lt->pc2stat = 0x00;
+		OUTP_DBG(&outp->base, "status %6ph pc2 %02x",
+			 lt->stat, lt->pc2stat);
+	} else {
+		OUTP_DBG(&outp->base, "status %6ph", lt->stat);
+	}
+
+	return 0;
+}
+
+static int
+nvkm_dp_train_drive(struct lt_state *lt, bool pc)
+{
+	struct nvkm_output_dp *outp = lt->outp;
+	int ret, i;
+
+	for (i = 0; i < lt->link_nr; i++) {
+		u8 lane = (lt->stat[4 + (i >> 1)] >> ((i & 1) * 4)) & 0xf;
+		u8 lpc2 = (lt->pc2stat >> (i * 2)) & 0x3;
+		u8 lpre = (lane & 0x0c) >> 2;
+		u8 lvsw = (lane & 0x03) >> 0;
+		u8 hivs = 3 - lpre;
+		u8 hipe = 3;
+		u8 hipc = 3;
+
+		if (lpc2 >= hipc)
+			lpc2 = hipc | DPCD_LC0F_LANE0_MAX_POST_CURSOR2_REACHED;
+		if (lpre >= hipe) {
+			lpre = hipe | DPCD_LC03_MAX_SWING_REACHED; /* yes. */
+			lvsw = hivs = 3 - (lpre & 3);
+		} else
+		if (lvsw >= hivs) {
+			lvsw = hivs | DPCD_LC03_MAX_SWING_REACHED;
+		}
+
+		lt->conf[i] = (lpre << 3) | lvsw;
+		lt->pc2conf[i >> 1] |= lpc2 << ((i & 1) * 4);
+
+		OUTP_DBG(&outp->base, "config lane %d %02x %02x",
+			 i, lt->conf[i], lpc2);
+		outp->func->drv_ctl(outp, i, lvsw & 3, lpre & 3, lpc2 & 3);
+	}
+
+	ret = nvkm_wraux(outp->aux, DPCD_LC03(0), lt->conf, 4);
+	if (ret)
+		return ret;
+
+	if (pc) {
+		ret = nvkm_wraux(outp->aux, DPCD_LC0F, lt->pc2conf, 2);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static void
+nvkm_dp_train_pattern(struct lt_state *lt, u8 pattern)
+{
+	struct nvkm_output_dp *outp = lt->outp;
+	u8 sink_tp;
+
+	OUTP_DBG(&outp->base, "training pattern %d", pattern);
+	outp->func->pattern(outp, pattern);
+
+	nvkm_rdaux(outp->aux, DPCD_LC02, &sink_tp, 1);
+	sink_tp &= ~DPCD_LC02_TRAINING_PATTERN_SET;
+	sink_tp |= pattern;
+	nvkm_wraux(outp->aux, DPCD_LC02, &sink_tp, 1);
+}
+
+static int
+nvkm_dp_train_eq(struct lt_state *lt)
+{
+	struct nvkm_output_dp *outp = lt->outp;
+	bool eq_done = false, cr_done = true;
+	int tries = 0, i;
+
+	if (outp->dpcd[2] & DPCD_RC02_TPS3_SUPPORTED)
+		nvkm_dp_train_pattern(lt, 3);
+	else
+		nvkm_dp_train_pattern(lt, 2);
+
+	do {
+		if ((tries &&
+		    nvkm_dp_train_drive(lt, lt->pc2)) ||
+		    nvkm_dp_train_sense(lt, lt->pc2, 400))
+			break;
+
+		eq_done = !!(lt->stat[2] & DPCD_LS04_INTERLANE_ALIGN_DONE);
+		for (i = 0; i < lt->link_nr && eq_done; i++) {
+			u8 lane = (lt->stat[i >> 1] >> ((i & 1) * 4)) & 0xf;
+			if (!(lane & DPCD_LS02_LANE0_CR_DONE))
+				cr_done = false;
+			if (!(lane & DPCD_LS02_LANE0_CHANNEL_EQ_DONE) ||
+			    !(lane & DPCD_LS02_LANE0_SYMBOL_LOCKED))
+				eq_done = false;
+		}
+	} while (!eq_done && cr_done && ++tries <= 5);
+
+	return eq_done ? 0 : -1;
+}
+
+static int
+nvkm_dp_train_cr(struct lt_state *lt)
+{
+	bool cr_done = false, abort = false;
+	int voltage = lt->conf[0] & DPCD_LC03_VOLTAGE_SWING_SET;
+	int tries = 0, i;
+
+	nvkm_dp_train_pattern(lt, 1);
+
+	do {
+		if (nvkm_dp_train_drive(lt, false) ||
+		    nvkm_dp_train_sense(lt, false, 100))
+			break;
+
+		cr_done = true;
+		for (i = 0; i < lt->link_nr; i++) {
+			u8 lane = (lt->stat[i >> 1] >> ((i & 1) * 4)) & 0xf;
+			if (!(lane & DPCD_LS02_LANE0_CR_DONE)) {
+				cr_done = false;
+				if (lt->conf[i] & DPCD_LC03_MAX_SWING_REACHED)
+					abort = true;
+				break;
+			}
+		}
+
+		if ((lt->conf[0] & DPCD_LC03_VOLTAGE_SWING_SET) != voltage) {
+			voltage = lt->conf[0] & DPCD_LC03_VOLTAGE_SWING_SET;
+			tries = 0;
+		}
+	} while (!cr_done && !abort && ++tries < 5);
+
+	return cr_done ? 0 : -1;
+}
+
+static int
+nvkm_dp_train_links(struct lt_state *lt)
+{
+	struct nvkm_output_dp *outp = lt->outp;
+	struct nvkm_disp *disp = outp->base.disp;
+	struct nvkm_subdev *subdev = &disp->engine.subdev;
+	struct nvkm_bios *bios = subdev->device->bios;
+	struct nvbios_init init = {
+		.subdev = subdev,
+		.bios = bios,
+		.offset = 0x0000,
+		.outp = &outp->base.info,
+		.crtc = -1,
+		.execute = 1,
+	};
+	u32 lnkcmp;
+	u8 sink[2];
+	int ret;
+
+	OUTP_DBG(&outp->base, "%d lanes at %d KB/s", lt->link_nr, lt->link_bw);
+
+	/* Intersect misc. capabilities of the OR and sink. */
+	if (disp->engine.subdev.device->chipset < 0xd0)
+		outp->dpcd[2] &= ~DPCD_RC02_TPS3_SUPPORTED;
+	lt->pc2 = outp->dpcd[2] & DPCD_RC02_TPS3_SUPPORTED;
+
+	/* Set desired link configuration on the source. */
+	if ((lnkcmp = lt->outp->info.lnkcmp)) {
+		if (outp->version < 0x30) {
+			while ((lt->link_bw / 10) < nvbios_rd16(bios, lnkcmp))
+				lnkcmp += 4;
+			init.offset = nvbios_rd16(bios, lnkcmp + 2);
+		} else {
+			while ((lt->link_bw / 27000) < nvbios_rd08(bios, lnkcmp))
+				lnkcmp += 3;
+			init.offset = nvbios_rd16(bios, lnkcmp + 1);
+		}
+
+		nvbios_exec(&init);
+	}
+
+	ret = outp->func->lnk_ctl(outp, lt->link_nr, lt->link_bw / 27000,
+				  outp->dpcd[DPCD_RC02] &
+					     DPCD_RC02_ENHANCED_FRAME_CAP);
+	if (ret) {
+		if (ret < 0)
+			OUTP_ERR(&outp->base, "lnk_ctl failed with %d", ret);
+		return ret;
+	}
+
+	outp->func->lnk_pwr(outp, lt->link_nr);
+
+	/* Set desired link configuration on the sink. */
+	sink[0] = lt->link_bw / 27000;
+	sink[1] = lt->link_nr;
+	if (outp->dpcd[DPCD_RC02] & DPCD_RC02_ENHANCED_FRAME_CAP)
+		sink[1] |= DPCD_LC01_ENHANCED_FRAME_EN;
+
+	return nvkm_wraux(outp->aux, DPCD_LC00_LINK_BW_SET, sink, 2);
+}
+
+static void
+nvkm_dp_train_fini(struct lt_state *lt)
+{
+	struct nvkm_output_dp *outp = lt->outp;
+	struct nvkm_disp *disp = outp->base.disp;
+	struct nvkm_subdev *subdev = &disp->engine.subdev;
+	struct nvbios_init init = {
+		.subdev = subdev,
+		.bios = subdev->device->bios,
+		.outp = &outp->base.info,
+		.crtc = -1,
+		.execute = 1,
+	};
+
+	/* Execute AfterLinkTraining script from DP Info table. */
+	init.offset = outp->info.script[1],
+	nvbios_exec(&init);
+}
+
+static void
+nvkm_dp_train_init(struct lt_state *lt, bool spread)
+{
+	struct nvkm_output_dp *outp = lt->outp;
+	struct nvkm_disp *disp = outp->base.disp;
+	struct nvkm_subdev *subdev = &disp->engine.subdev;
+	struct nvbios_init init = {
+		.subdev = subdev,
+		.bios = subdev->device->bios,
+		.outp = &outp->base.info,
+		.crtc = -1,
+		.execute = 1,
+	};
+
+	/* Execute EnableSpread/DisableSpread script from DP Info table. */
+	if (spread)
+		init.offset = outp->info.script[2];
+	else
+		init.offset = outp->info.script[3];
+	nvbios_exec(&init);
+
+	/* Execute BeforeLinkTraining script from DP info table. */
+	init.offset = outp->info.script[0];
+	nvbios_exec(&init);
+}
+
+static const struct dp_rates {
+	u32 rate;
+	u8  bw;
+	u8  nr;
+} nvkm_dp_rates[] = {
+	{ 2160000, 0x14, 4 },
+	{ 1080000, 0x0a, 4 },
+	{ 1080000, 0x14, 2 },
+	{  648000, 0x06, 4 },
+	{  540000, 0x0a, 2 },
+	{  540000, 0x14, 1 },
+	{  324000, 0x06, 2 },
+	{  270000, 0x0a, 1 },
+	{  162000, 0x06, 1 },
+	{}
+};
+
+static void
+nvkm_dp_train(struct nvkm_output_dp *outp)
+{
+	struct nv50_disp *disp = nv50_disp(outp->base.disp);
+	const struct dp_rates *cfg = nvkm_dp_rates - 1;
+	struct lt_state lt = {
+		.outp = outp,
+	};
+	u8  pwr;
+	int ret;
+
+	if (!outp->base.info.location && disp->func->sor.magic)
+		disp->func->sor.magic(&outp->base);
+
+	if ((outp->dpcd[2] & 0x1f) > outp->base.info.dpconf.link_nr) {
+		outp->dpcd[2] &= ~DPCD_RC02_MAX_LANE_COUNT;
+		outp->dpcd[2] |= outp->base.info.dpconf.link_nr;
+	}
+	if (outp->dpcd[1] > outp->base.info.dpconf.link_bw)
+		outp->dpcd[1] = outp->base.info.dpconf.link_bw;
+
+	/* Ensure sink is not in a low-power state. */
+	if (!nvkm_rdaux(outp->aux, DPCD_SC00, &pwr, 1)) {
+		if ((pwr & DPCD_SC00_SET_POWER) != DPCD_SC00_SET_POWER_D0) {
+			pwr &= ~DPCD_SC00_SET_POWER;
+			pwr |=  DPCD_SC00_SET_POWER_D0;
+			nvkm_wraux(outp->aux, DPCD_SC00, &pwr, 1);
+		}
+	}
+
+	/* Link training. */
+	nvkm_dp_train_init(&lt, outp->dpcd[3] & 0x01);
+	while (ret = -EIO, (++cfg)->rate) {
+		/* Skip configurations not supported by both OR and sink. */
+		while (cfg->nr > (outp->dpcd[2] & DPCD_RC02_MAX_LANE_COUNT) ||
+		       cfg->bw > (outp->dpcd[DPCD_RC01_MAX_LINK_RATE]))
+			cfg++;
+		lt.link_bw = cfg->bw * 27000;
+		lt.link_nr = cfg->nr;
+
+		/* Program selected link configuration. */
+		ret = nvkm_dp_train_links(&lt);
+		if (ret == 0) {
+			/* Attempt to train the link in this configuration. */
+			memset(lt.stat, 0x00, sizeof(lt.stat));
+			if (!nvkm_dp_train_cr(&lt) &&
+			    !nvkm_dp_train_eq(&lt))
+				break;
+		} else
+		if (ret) {
+			/* nvkm_dp_train_links() handled training, or
+			 * we failed to communicate with the sink.
+			 */
+			break;
+		}
+	}
+	nvkm_dp_train_pattern(&lt, 0);
+	nvkm_dp_train_fini(&lt);
+	if (ret < 0)
+		OUTP_ERR(&outp->base, "link training failed");
+
+	OUTP_DBG(&outp->base, "training complete");
+	atomic_set(&outp->lt.done, 1);
+}
+
+int
+nvkm_output_dp_train(struct nvkm_output *base, u32 datarate)
+{
+	struct nvkm_output_dp *outp = nvkm_output_dp(base);
+	bool retrain = true;
+	u8 link[2], stat[3];
+	u32 linkrate;
+	int ret, i;
+
+	mutex_lock(&outp->mutex);
+
+	/* check that the link is trained at a high enough rate */
+	ret = nvkm_rdaux(outp->aux, DPCD_LC00_LINK_BW_SET, link, 2);
+	if (ret) {
+		OUTP_DBG(&outp->base,
+			 "failed to read link config, assuming no sink");
+		goto done;
+	}
+
+	linkrate = link[0] * 27000 * (link[1] & DPCD_LC01_LANE_COUNT_SET);
+	linkrate = (linkrate * 8) / 10; /* 8B/10B coding overhead */
+	datarate = (datarate + 9) / 10; /* -> decakilobits */
+	if (linkrate < datarate) {
+		OUTP_DBG(&outp->base, "link not trained at sufficient rate");
+		goto done;
+	}
+
+	/* check that link is still trained */
+	ret = nvkm_rdaux(outp->aux, DPCD_LS02, stat, 3);
+	if (ret) {
+		OUTP_DBG(&outp->base,
+			 "failed to read link status, assuming no sink");
+		goto done;
+	}
+
+	if (stat[2] & DPCD_LS04_INTERLANE_ALIGN_DONE) {
+		for (i = 0; i < (link[1] & DPCD_LC01_LANE_COUNT_SET); i++) {
+			u8 lane = (stat[i >> 1] >> ((i & 1) * 4)) & 0x0f;
+			if (!(lane & DPCD_LS02_LANE0_CR_DONE) ||
+			    !(lane & DPCD_LS02_LANE0_CHANNEL_EQ_DONE) ||
+			    !(lane & DPCD_LS02_LANE0_SYMBOL_LOCKED)) {
+				OUTP_DBG(&outp->base,
+					 "lane %d not equalised", lane);
+				goto done;
+			}
+		}
+		retrain = false;
+	} else {
+		OUTP_DBG(&outp->base, "no inter-lane alignment");
+	}
+
+done:
+	if (retrain || !atomic_read(&outp->lt.done)) {
+		/* no sink, but still need to configure source */
+		if (outp->dpcd[DPCD_RC00_DPCD_REV] == 0x00) {
+			outp->dpcd[DPCD_RC01_MAX_LINK_RATE] =
+				outp->base.info.dpconf.link_bw;
+			outp->dpcd[DPCD_RC02] =
+				outp->base.info.dpconf.link_nr;
+		}
+		nvkm_dp_train(outp);
+	}
+
+	mutex_unlock(&outp->mutex);
+	return ret;
+}
+
+static void
+nvkm_output_dp_enable(struct nvkm_output_dp *outp, bool enable)
+{
+	struct nvkm_i2c_aux *aux = outp->aux;
+
+	if (enable) {
+		if (!outp->present) {
+			OUTP_DBG(&outp->base, "aux power -> always");
+			nvkm_i2c_aux_monitor(aux, true);
+			outp->present = true;
+		}
+
+		if (!nvkm_rdaux(aux, DPCD_RC00_DPCD_REV, outp->dpcd,
+				sizeof(outp->dpcd))) {
+			nvkm_output_dp_train(&outp->base, 0);
+			return;
+		}
+	}
+
+	if (outp->present) {
+		OUTP_DBG(&outp->base, "aux power -> demand");
+		nvkm_i2c_aux_monitor(aux, false);
+		outp->present = false;
+	}
+
+	atomic_set(&outp->lt.done, 0);
+}
+
+static int
+nvkm_output_dp_hpd(struct nvkm_notify *notify)
+{
+	const struct nvkm_i2c_ntfy_rep *line = notify->data;
+	struct nvkm_output_dp *outp = container_of(notify, typeof(*outp), hpd);
+	struct nvkm_connector *conn = outp->base.conn;
+	struct nvkm_disp *disp = outp->base.disp;
+	struct nvif_notify_conn_rep_v0 rep = {};
+
+	OUTP_DBG(&outp->base, "HPD: %d", line->mask);
+	nvkm_output_dp_enable(outp, true);
+
+	if (line->mask & NVKM_I2C_UNPLUG)
+		rep.mask |= NVIF_NOTIFY_CONN_V0_UNPLUG;
+	if (line->mask & NVKM_I2C_PLUG)
+		rep.mask |= NVIF_NOTIFY_CONN_V0_PLUG;
+
+	nvkm_event_send(&disp->hpd, rep.mask, conn->index, &rep, sizeof(rep));
+	return NVKM_NOTIFY_KEEP;
+}
+
+static int
+nvkm_output_dp_irq(struct nvkm_notify *notify)
+{
+	const struct nvkm_i2c_ntfy_rep *line = notify->data;
+	struct nvkm_output_dp *outp = container_of(notify, typeof(*outp), irq);
+	struct nvkm_connector *conn = outp->base.conn;
+	struct nvkm_disp *disp = outp->base.disp;
+	struct nvif_notify_conn_rep_v0 rep = {
+		.mask = NVIF_NOTIFY_CONN_V0_IRQ,
+	};
+
+	OUTP_DBG(&outp->base, "IRQ: %d", line->mask);
+	nvkm_output_dp_train(&outp->base, 0);
+
+	nvkm_event_send(&disp->hpd, rep.mask, conn->index, &rep, sizeof(rep));
+	return NVKM_NOTIFY_KEEP;
+}
+
+static void
+nvkm_output_dp_fini(struct nvkm_output *base)
+{
+	struct nvkm_output_dp *outp = nvkm_output_dp(base);
+	nvkm_notify_put(&outp->hpd);
+	nvkm_notify_put(&outp->irq);
+	nvkm_output_dp_enable(outp, false);
+}
+
+static void
+nvkm_output_dp_init(struct nvkm_output *base)
+{
+	struct nvkm_output_dp *outp = nvkm_output_dp(base);
+	nvkm_notify_put(&outp->base.conn->hpd);
+	nvkm_output_dp_enable(outp, true);
+	nvkm_notify_get(&outp->irq);
+	nvkm_notify_get(&outp->hpd);
+}
+
+static void *
+nvkm_output_dp_dtor(struct nvkm_output *base)
+{
+	struct nvkm_output_dp *outp = nvkm_output_dp(base);
+	nvkm_notify_fini(&outp->hpd);
+	nvkm_notify_fini(&outp->irq);
+	return outp;
+}
+
+static const struct nvkm_output_func
+nvkm_output_dp_func = {
+	.dtor = nvkm_output_dp_dtor,
+	.init = nvkm_output_dp_init,
+	.fini = nvkm_output_dp_fini,
+};
+
+int
+nvkm_output_dp_ctor(const struct nvkm_output_dp_func *func,
+		    struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
+		    struct nvkm_i2c_aux *aux, struct nvkm_output_dp *outp)
+{
+	struct nvkm_device *device = disp->engine.subdev.device;
+	struct nvkm_bios *bios = device->bios;
+	struct nvkm_i2c *i2c = device->i2c;
+	u8  hdr, cnt, len;
+	u32 data;
+	int ret;
+
+	nvkm_output_ctor(&nvkm_output_dp_func, disp, index, dcbE, &outp->base);
+	outp->func = func;
+	outp->aux = aux;
+	if (!outp->aux) {
+		OUTP_ERR(&outp->base, "no aux");
+		return -ENODEV;
+	}
+
+	/* bios data is not optional */
+	data = nvbios_dpout_match(bios, outp->base.info.hasht,
+				  outp->base.info.hashm, &outp->version,
+				  &hdr, &cnt, &len, &outp->info);
+	if (!data) {
+		OUTP_ERR(&outp->base, "no bios dp data");
+		return -ENODEV;
+	}
+
+	OUTP_DBG(&outp->base, "bios dp %02x %02x %02x %02x",
+		 outp->version, hdr, cnt, len);
+
+	/* link maintenance */
+	ret = nvkm_notify_init(NULL, &i2c->event, nvkm_output_dp_irq, true,
+			       &(struct nvkm_i2c_ntfy_req) {
+				.mask = NVKM_I2C_IRQ,
+				.port = outp->aux->id,
+			       },
+			       sizeof(struct nvkm_i2c_ntfy_req),
+			       sizeof(struct nvkm_i2c_ntfy_rep),
+			       &outp->irq);
+	if (ret) {
+		OUTP_ERR(&outp->base, "error monitoring aux irq: %d", ret);
+		return ret;
+	}
+
+	mutex_init(&outp->mutex);
+	atomic_set(&outp->lt.done, 0);
+
+	/* hotplug detect, replaces gpio-based mechanism with aux events */
+	ret = nvkm_notify_init(NULL, &i2c->event, nvkm_output_dp_hpd, true,
+			       &(struct nvkm_i2c_ntfy_req) {
+				.mask = NVKM_I2C_PLUG | NVKM_I2C_UNPLUG,
+				.port = outp->aux->id,
+			       },
+			       sizeof(struct nvkm_i2c_ntfy_req),
+			       sizeof(struct nvkm_i2c_ntfy_rep),
+			       &outp->hpd);
+	if (ret) {
+		OUTP_ERR(&outp->base, "error monitoring aux hpd: %d", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int
+nvkm_output_dp_new_(const struct nvkm_output_dp_func *func,
+		    struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
+		    struct nvkm_output **poutp)
+{
+	struct nvkm_i2c *i2c = disp->engine.subdev.device->i2c;
+	struct nvkm_i2c_aux *aux = nvkm_i2c_aux_find(i2c, dcbE->i2c_index);
+	struct nvkm_output_dp *outp;
+
+	if (!(outp = kzalloc(sizeof(*outp), GFP_KERNEL)))
+		return -ENOMEM;
+	*poutp = &outp->base;
+
+	return nvkm_output_dp_ctor(func, disp, index, dcbE, aux, outp);
+}
