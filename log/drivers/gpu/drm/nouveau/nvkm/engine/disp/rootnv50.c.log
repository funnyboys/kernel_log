commit 6f8dbcf1c9cec3ec5efcf4c17b29a5b1732d1491
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jun 3 11:37:56 2020 +1000

    drm/nouveau/disp: provide hint to OR allocation about HDA requirements
    
    Will be used by a subsequent commit to influence SOR allocation policy.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index a7672ef17d3b..fb5de44e4b8d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -99,7 +99,7 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 		} *args = data;
 		int ret = -ENOSYS;
 		if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
-			ret = nvkm_outp_acquire(outp, NVKM_OUTP_USER);
+			ret = nvkm_outp_acquire(outp, NVKM_OUTP_USER, args->v0.hda);
 			if (ret == 0) {
 				args->v0.or = outp->ior->id;
 				args->v0.link = outp->ior->asy.link;
@@ -119,7 +119,7 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 		if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 			if (args->v0.data & 0xfff00000)
 				return -EINVAL;
-			ret = nvkm_outp_acquire(outp, NVKM_OUTP_PRIV);
+			ret = nvkm_outp_acquire(outp, NVKM_OUTP_PRIV, false);
 			if (ret)
 				return ret;
 			ret = outp->ior->func->sense(outp->ior, args->v0.data);

commit 1404e56a49f0dd6f50ded3290d37b795e3cbd6e9
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed May 6 14:40:52 2020 +1000

    drm/nouveau/disp/hda/gt215-: pass head to nvkm_ior.hda.eld()
    
    We're going to use the bound head to select HDA device entry.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 5f758948d6e1..a7672ef17d3b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -155,7 +155,7 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 			if (outp->info.type == DCB_OUTPUT_DP)
 				ior->func->dp.audio(ior, hidx, true);
 			ior->func->hda.hpd(ior, hidx, true);
-			ior->func->hda.eld(ior, data, size);
+			ior->func->hda.eld(ior, hidx, data, size);
 		} else {
 			if (outp->info.type == DCB_OUTPUT_DP)
 				ior->func->dp.audio(ior, hidx, false);

commit 4126b99e744b7a29746e201e2be6644d2edf3c56
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Mon Sep 3 20:57:33 2018 -0400

    drm/nouveau/disp: add a way to configure scrambling/tmds for hdmi 2.0
    
    High pixel clocks are required to use a 40 TMDS divider instead of 10,
    and even low ones may optionally use scrambling depending on device
    support.
    
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 3aa5a2879239..5f758948d6e1 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -176,9 +176,10 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 		nvif_ioctl(object, "disp sor hdmi ctrl size %d\n", size);
 		if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
 			nvif_ioctl(object, "disp sor hdmi ctrl vers %d state %d "
-					   "max_ac_packet %d rekey %d\n",
+					   "max_ac_packet %d rekey %d scdc %d\n",
 				   args->v0.version, args->v0.state,
-				   args->v0.max_ac_packet, args->v0.rekey);
+				   args->v0.max_ac_packet, args->v0.rekey,
+				   args->v0.scdc);
 			if (args->v0.max_ac_packet > 0x1f || args->v0.rekey > 0x7f)
 				return -EINVAL;
 			if ((args->v0.avi_infoframe_length
@@ -202,6 +203,11 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 					   args->v0.max_ac_packet,
 					   args->v0.rekey, avi, avi_size,
 					   vendor, vendor_size);
+
+		if (outp->ior->func->hdmi.scdc)
+			outp->ior->func->hdmi.scdc(
+					outp->ior, hidx, args->v0.scdc);
+
 		return 0;
 	}
 		break;

commit 8531f57027136fa63ddae91821ca89b32b571fe2
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: merge handling of pio and dma channels
    
    Unnecessarily complicated, and a barrier to cleanly supporting Volta.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 9d716ee7621e..3aa5a2879239 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -22,7 +22,7 @@
  * Authors: Ben Skeggs
  */
 #include "rootnv50.h"
-#include "dmacnv50.h"
+#include "channv50.h"
 #include "dp.h"
 #include "head.h"
 #include "ior.h"

commit 9b096283bf78f659e1286ef9b783b27ecf5a9977
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: simplify definiton of core channels
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 24e8b418ac65..9d716ee7621e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -268,16 +268,6 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	return -EINVAL;
 }
 
-static int
-nv50_disp_root_dmac_new_(const struct nvkm_oclass *oclass,
-			 void *data, u32 size, struct nvkm_object **pobject)
-{
-	const struct nv50_disp_dmac_oclass *sclass = oclass->priv;
-	struct nv50_disp_root *root = nv50_disp_root(oclass->parent);
-	return sclass->ctor(sclass->func, sclass->mthd, root, sclass->chid,
-			    oclass, data, size, pobject);
-}
-
 static int
 nv50_disp_root_child_new_(const struct nvkm_oclass *oclass,
 			  void *argv, u32 argc, struct nvkm_object **pobject)
@@ -293,15 +283,6 @@ nv50_disp_root_child_get_(struct nvkm_object *object, int index,
 {
 	struct nv50_disp_root *root = nv50_disp_root(object);
 
-	if (index < ARRAY_SIZE(root->func->dmac)) {
-		sclass->base = root->func->dmac[index]->base;
-		sclass->priv = root->func->dmac[index];
-		sclass->ctor = nv50_disp_root_dmac_new_;
-		return 0;
-	}
-
-	index -= ARRAY_SIZE(root->func->dmac);
-
 	if (root->func->user[index].ctor) {
 		sclass->base = root->func->user[index].base;
 		sclass->priv = root->func->user + index;
@@ -347,13 +328,11 @@ nv50_disp_root_new_(const struct nv50_disp_root_func *func,
 
 static const struct nv50_disp_root_func
 nv50_disp_root = {
-	.dmac = {
-		&nv50_disp_core_oclass,
-	},
 	.user = {
 		{{0,0,NV50_DISP_CURSOR             }, nv50_disp_curs_new },
 		{{0,0,NV50_DISP_OVERLAY            }, nv50_disp_oimm_new },
 		{{0,0,NV50_DISP_BASE_CHANNEL_DMA   }, nv50_disp_base_new },
+		{{0,0,NV50_DISP_CORE_CHANNEL_DMA   }, nv50_disp_core_new },
 		{{0,0,NV50_DISP_OVERLAY_CHANNEL_DMA}, nv50_disp_ovly_new },
 		{}
 	},

commit 6d41a7536f8cff35be9b3c4ccb94e55f1553a7a1
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: simplify definition of cursor channels
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index a87531d9a3b8..24e8b418ac65 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -278,16 +278,6 @@ nv50_disp_root_dmac_new_(const struct nvkm_oclass *oclass,
 			    oclass, data, size, pobject);
 }
 
-static int
-nv50_disp_root_pioc_new_(const struct nvkm_oclass *oclass,
-			 void *data, u32 size, struct nvkm_object **pobject)
-{
-	const struct nv50_disp_pioc_oclass *sclass = oclass->priv;
-	struct nv50_disp_root *root = nv50_disp_root(oclass->parent);
-	return sclass->ctor(sclass->func, sclass->mthd, root, sclass->chid.ctrl,
-			    sclass->chid.user, oclass, data, size, pobject);
-}
-
 static int
 nv50_disp_root_child_new_(const struct nvkm_oclass *oclass,
 			  void *argv, u32 argc, struct nvkm_object **pobject)
@@ -312,15 +302,6 @@ nv50_disp_root_child_get_(struct nvkm_object *object, int index,
 
 	index -= ARRAY_SIZE(root->func->dmac);
 
-	if (index < ARRAY_SIZE(root->func->pioc)) {
-		sclass->base = root->func->pioc[index]->base;
-		sclass->priv = root->func->pioc[index];
-		sclass->ctor = nv50_disp_root_pioc_new_;
-		return 0;
-	}
-
-	index -= ARRAY_SIZE(root->func->pioc);
-
 	if (root->func->user[index].ctor) {
 		sclass->base = root->func->user[index].base;
 		sclass->priv = root->func->user + index;
@@ -369,10 +350,8 @@ nv50_disp_root = {
 	.dmac = {
 		&nv50_disp_core_oclass,
 	},
-	.pioc = {
-		&nv50_disp_curs_oclass,
-	},
 	.user = {
+		{{0,0,NV50_DISP_CURSOR             }, nv50_disp_curs_new },
 		{{0,0,NV50_DISP_OVERLAY            }, nv50_disp_oimm_new },
 		{{0,0,NV50_DISP_BASE_CHANNEL_DMA   }, nv50_disp_base_new },
 		{{0,0,NV50_DISP_OVERLAY_CHANNEL_DMA}, nv50_disp_ovly_new },

commit 3ceeef9c03fc9ed6adbb0646b4b89096ca568670
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: simplify definition of base channels
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 41219c2d487c..a87531d9a3b8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -368,13 +368,13 @@ static const struct nv50_disp_root_func
 nv50_disp_root = {
 	.dmac = {
 		&nv50_disp_core_oclass,
-		&nv50_disp_base_oclass,
 	},
 	.pioc = {
 		&nv50_disp_curs_oclass,
 	},
 	.user = {
 		{{0,0,NV50_DISP_OVERLAY            }, nv50_disp_oimm_new },
+		{{0,0,NV50_DISP_BASE_CHANNEL_DMA   }, nv50_disp_base_new },
 		{{0,0,NV50_DISP_OVERLAY_CHANNEL_DMA}, nv50_disp_ovly_new },
 		{}
 	},

commit c2c3a00310df71e1f92d99ec3d5818d152f12bc8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: simplify definition of overlay immediate channels
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index f02368ffa1c9..41219c2d487c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -371,10 +371,10 @@ nv50_disp_root = {
 		&nv50_disp_base_oclass,
 	},
 	.pioc = {
-		&nv50_disp_oimm_oclass,
 		&nv50_disp_curs_oclass,
 	},
 	.user = {
+		{{0,0,NV50_DISP_OVERLAY            }, nv50_disp_oimm_new },
 		{{0,0,NV50_DISP_OVERLAY_CHANNEL_DMA}, nv50_disp_ovly_new },
 		{}
 	},

commit 46f74a8ad79c4da47190df8492f0534fe8c02652
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: simplify definition of overlay channels
    
    Introduces a new method of defining channels available from the display,
    common to all channel types, allowing for more flexibility in available
    channel types/counts, and reducing the amount of boiler-plate required.
    
    This will be required to support Volta.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 072c8c0e7096..f02368ffa1c9 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -288,6 +288,15 @@ nv50_disp_root_pioc_new_(const struct nvkm_oclass *oclass,
 			    sclass->chid.user, oclass, data, size, pobject);
 }
 
+static int
+nv50_disp_root_child_new_(const struct nvkm_oclass *oclass,
+			  void *argv, u32 argc, struct nvkm_object **pobject)
+{
+	struct nv50_disp *disp = nv50_disp_root(oclass->parent)->disp;
+	const struct nv50_disp_user *user = oclass->priv;
+	return user->ctor(oclass, argv, argc, disp, pobject);
+}
+
 static int
 nv50_disp_root_child_get_(struct nvkm_object *object, int index,
 			  struct nvkm_oclass *sclass)
@@ -310,6 +319,15 @@ nv50_disp_root_child_get_(struct nvkm_object *object, int index,
 		return 0;
 	}
 
+	index -= ARRAY_SIZE(root->func->pioc);
+
+	if (root->func->user[index].ctor) {
+		sclass->base = root->func->user[index].base;
+		sclass->priv = root->func->user + index;
+		sclass->ctor = nv50_disp_root_child_new_;
+		return 0;
+	}
+
 	return -EINVAL;
 }
 
@@ -351,12 +369,15 @@ nv50_disp_root = {
 	.dmac = {
 		&nv50_disp_core_oclass,
 		&nv50_disp_base_oclass,
-		&nv50_disp_ovly_oclass,
 	},
 	.pioc = {
 		&nv50_disp_oimm_oclass,
 		&nv50_disp_curs_oclass,
 	},
+	.user = {
+		{{0,0,NV50_DISP_OVERLAY_CHANNEL_DMA}, nv50_disp_ovly_new },
+		{}
+	},
 };
 
 static int

commit bb3b0a422074606400e6aff216300bb4f012b22a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: initialise from the engine, rather than the user object
    
    Engines are initialised on an as-needed basis, so this results in the
    same behaviour, whilst allowing us to simplify things a bit.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index c8379bf37a6d..072c8c0e7096 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -28,8 +28,6 @@
 #include "ior.h"
 
 #include <core/client.h>
-#include <core/ramht.h>
-#include <subdev/timer.h>
 
 #include <nvif/class.h>
 #include <nvif/cl5070.h>
@@ -315,49 +313,16 @@ nv50_disp_root_child_get_(struct nvkm_object *object, int index,
 	return -EINVAL;
 }
 
-static int
-nv50_disp_root_fini_(struct nvkm_object *object, bool suspend)
-{
-	struct nv50_disp_root *root = nv50_disp_root(object);
-	root->func->fini(root);
-	return 0;
-}
-
-static int
-nv50_disp_root_init_(struct nvkm_object *object)
-{
-	struct nv50_disp_root *root = nv50_disp_root(object);
-	struct nvkm_ior *ior;
-	int ret;
-
-	ret = root->func->init(root);
-	if (ret)
-		return ret;
-
-	/* Set 'normal' (ie. when it's attached to a head) state for
-	 * each output resource to 'fully enabled'.
-	 */
-	list_for_each_entry(ior, &root->disp->base.ior, head) {
-		ior->func->power(ior, true, true, true, true, true);
-	}
-
-	return 0;
-}
-
 static void *
 nv50_disp_root_dtor_(struct nvkm_object *object)
 {
 	struct nv50_disp_root *root = nv50_disp_root(object);
-	nvkm_ramht_del(&root->ramht);
-	nvkm_gpuobj_del(&root->instmem);
 	return root;
 }
 
 static const struct nvkm_object_func
 nv50_disp_root_ = {
 	.dtor = nv50_disp_root_dtor_,
-	.init = nv50_disp_root_init_,
-	.fini = nv50_disp_root_fini_,
 	.mthd = nv50_disp_root_mthd_,
 	.ntfy = nvkm_disp_ntfy,
 	.sclass = nv50_disp_root_child_get_,
@@ -370,8 +335,6 @@ nv50_disp_root_new_(const struct nv50_disp_root_func *func,
 {
 	struct nv50_disp *disp = nv50_disp(base);
 	struct nv50_disp_root *root;
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	int ret;
 
 	if (!(root = kzalloc(sizeof(*root), GFP_KERNEL)))
 		return -ENOMEM;
@@ -380,94 +343,11 @@ nv50_disp_root_new_(const struct nv50_disp_root_func *func,
 	nvkm_object_ctor(&nv50_disp_root_, oclass, &root->object);
 	root->func = func;
 	root->disp = disp;
-
-	ret = nvkm_gpuobj_new(disp->base.engine.subdev.device, 0x10000, 0x10000,
-			      false, NULL, &root->instmem);
-	if (ret)
-		return ret;
-
-	return nvkm_ramht_new(device, 0x1000, 0, root->instmem, &root->ramht);
-}
-
-void
-nv50_disp_root_fini(struct nv50_disp_root *root)
-{
-	struct nvkm_device *device = root->disp->base.engine.subdev.device;
-	/* disable all interrupts */
-	nvkm_wr32(device, 0x610024, 0x00000000);
-	nvkm_wr32(device, 0x610020, 0x00000000);
-}
-
-int
-nv50_disp_root_init(struct nv50_disp_root *root)
-{
-	struct nv50_disp *disp = root->disp;
-	struct nvkm_head *head;
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	u32 tmp;
-	int i;
-
-	/* The below segments of code copying values from one register to
-	 * another appear to inform EVO of the display capabilities or
-	 * something similar.  NFI what the 0x614004 caps are for..
-	 */
-	tmp = nvkm_rd32(device, 0x614004);
-	nvkm_wr32(device, 0x610184, tmp);
-
-	/* ... CRTC caps */
-	list_for_each_entry(head, &disp->base.head, head) {
-		tmp = nvkm_rd32(device, 0x616100 + (head->id * 0x800));
-		nvkm_wr32(device, 0x610190 + (head->id * 0x10), tmp);
-		tmp = nvkm_rd32(device, 0x616104 + (head->id * 0x800));
-		nvkm_wr32(device, 0x610194 + (head->id * 0x10), tmp);
-		tmp = nvkm_rd32(device, 0x616108 + (head->id * 0x800));
-		nvkm_wr32(device, 0x610198 + (head->id * 0x10), tmp);
-		tmp = nvkm_rd32(device, 0x61610c + (head->id * 0x800));
-		nvkm_wr32(device, 0x61019c + (head->id * 0x10), tmp);
-	}
-
-	/* ... DAC caps */
-	for (i = 0; i < disp->dac.nr; i++) {
-		tmp = nvkm_rd32(device, 0x61a000 + (i * 0x800));
-		nvkm_wr32(device, 0x6101d0 + (i * 0x04), tmp);
-	}
-
-	/* ... SOR caps */
-	for (i = 0; i < disp->sor.nr; i++) {
-		tmp = nvkm_rd32(device, 0x61c000 + (i * 0x800));
-		nvkm_wr32(device, 0x6101e0 + (i * 0x04), tmp);
-	}
-
-	/* ... PIOR caps */
-	for (i = 0; i < disp->pior.nr; i++) {
-		tmp = nvkm_rd32(device, 0x61e000 + (i * 0x800));
-		nvkm_wr32(device, 0x6101f0 + (i * 0x04), tmp);
-	}
-
-	/* steal display away from vbios, or something like that */
-	if (nvkm_rd32(device, 0x610024) & 0x00000100) {
-		nvkm_wr32(device, 0x610024, 0x00000100);
-		nvkm_mask(device, 0x6194e8, 0x00000001, 0x00000000);
-		if (nvkm_msec(device, 2000,
-			if (!(nvkm_rd32(device, 0x6194e8) & 0x00000002))
-				break;
-		) < 0)
-			return -EBUSY;
-	}
-
-	/* point at display engine memory area (hash table, objects) */
-	nvkm_wr32(device, 0x610010, (root->instmem->addr >> 8) | 9);
-
-	/* enable supervisor interrupts, disable everything else */
-	nvkm_wr32(device, 0x61002c, 0x00000370);
-	nvkm_wr32(device, 0x610028, 0x00000000);
 	return 0;
 }
 
 static const struct nv50_disp_root_func
 nv50_disp_root = {
-	.init = nv50_disp_root_init,
-	.fini = nv50_disp_root_fini,
 	.dmac = {
 		&nv50_disp_core_oclass,
 		&nv50_disp_base_oclass,

commit f5e088d6f0b4d969b2e7d8f931af082ba2527a56
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: fetch mask of available piors during oneinit
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 9d0b5b71d38a..c8379bf37a6d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -439,7 +439,7 @@ nv50_disp_root_init(struct nv50_disp_root *root)
 	}
 
 	/* ... PIOR caps */
-	for (i = 0; i < disp->func->pior.nr; i++) {
+	for (i = 0; i < disp->pior.nr; i++) {
 		tmp = nvkm_rd32(device, 0x61e000 + (i * 0x800));
 		nvkm_wr32(device, 0x6101f0 + (i * 0x04), tmp);
 	}

commit 9fe4e177045f4b5af25d25859e30450ff1f18be9
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: fetch mask of available sors during oneinit
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 3fbaccd9569b..9d0b5b71d38a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -433,7 +433,7 @@ nv50_disp_root_init(struct nv50_disp_root *root)
 	}
 
 	/* ... SOR caps */
-	for (i = 0; i < disp->func->sor.nr; i++) {
+	for (i = 0; i < disp->sor.nr; i++) {
 		tmp = nvkm_rd32(device, 0x61c000 + (i * 0x800));
 		nvkm_wr32(device, 0x6101e0 + (i * 0x04), tmp);
 	}

commit bf5d1a6b6a4489b7887589fca6321d4024da71c8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: fetch mask of available dacs during oneinit
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 1208524aae14..3fbaccd9569b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -427,7 +427,7 @@ nv50_disp_root_init(struct nv50_disp_root *root)
 	}
 
 	/* ... DAC caps */
-	for (i = 0; i < disp->func->dac.nr; i++) {
+	for (i = 0; i < disp->dac.nr; i++) {
 		tmp = nvkm_rd32(device, 0x61a000 + (i * 0x800));
 		nvkm_wr32(device, 0x6101d0 + (i * 0x04), tmp);
 	}

commit 8d7ef84d908877708001f3334dbf44e9d48fad57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/nv50-: implement a common supervisor 2.2
    
    This makes use of all the additional routing and state added in previous
    commits, making it possible to deal with GM20x macro link routing, while
    also sharing code between the NV50 and GF119 implementations.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 4c7b7090b1a0..1208524aae14 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -23,6 +23,7 @@
  */
 #include "rootnv50.h"
 #include "dmacnv50.h"
+#include "dp.h"
 #include "head.h"
 #include "ior.h"
 

commit 6c22ea3747fd36409ce4a1e1a0cbac40f93e1e71
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp: introduce acquire/release display path methods
    
    These exist to give NVKM information on the set of display paths that
    the DD needs to be active at any given time.
    
    Previously, the supervisor attempted to determine this solely from OR
    state, but there's a few configurations where this information on its
    own isn't enough to determine the specific display paths in question:
    
    - ANX9805, where the PIOR protocol for both DP and TMDS is TMDS.
    - On a device using DCB Switched Outputs.
    - On GM20x and newer, with a crossbar between the SOR and macro links.
    
    After this commit, the DD tells NVKM *exactly* which display path it's
    attempting a modeset on.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index f3ebdd032b9b..4c7b7090b1a0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -94,6 +94,24 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	}
 
 	switch (mthd * !!outp) {
+	case NV50_DISP_MTHD_V1_ACQUIRE: {
+		union {
+			struct nv50_disp_acquire_v0 v0;
+		} *args = data;
+		int ret = -ENOSYS;
+		if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
+			ret = nvkm_outp_acquire(outp, NVKM_OUTP_USER);
+			if (ret == 0) {
+				args->v0.or = outp->ior->id;
+				args->v0.link = outp->ior->asy.link;
+			}
+		}
+		return ret;
+	}
+		break;
+	case NV50_DISP_MTHD_V1_RELEASE:
+		nvkm_outp_release(outp, NVKM_OUTP_USER);
+		return 0;
 	case NV50_DISP_MTHD_V1_DAC_LOAD: {
 		union {
 			struct nv50_disp_dac_load_v0 v0;
@@ -102,7 +120,11 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 		if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 			if (args->v0.data & 0xfff00000)
 				return -EINVAL;
+			ret = nvkm_outp_acquire(outp, NVKM_OUTP_PRIV);
+			if (ret)
+				return ret;
 			ret = outp->ior->func->sense(outp->ior, args->v0.data);
+			nvkm_outp_release(outp, NVKM_OUTP_PRIV);
 			if (ret < 0)
 				return ret;
 			args->v0.load = ret;

commit e8ccc96dd5f4baa1deb21b6d3b2c4a07bcf62254
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/gf119-: port OR DP VCPI control to nvkm_ior
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index d6371110f5a0..f3ebdd032b9b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -217,7 +217,6 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	}
 		break;
 	case NV50_DISP_MTHD_V1_SOR_DP_MST_VCPI: {
-		struct nvkm_output_dp *outpdp = nvkm_output_dp(outp);
 		union {
 			struct nv50_disp_sor_dp_mst_vcpi_v0 v0;
 		} *args = data;
@@ -229,11 +228,13 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 				   args->v0.version, args->v0.start_slot,
 				   args->v0.num_slots, args->v0.pbn,
 				   args->v0.aligned_pbn);
-			if (!outpdp->func->vcpi)
+			if (!outp->ior->func->dp.vcpi)
 				return -ENODEV;
-			outpdp->func->vcpi(outpdp, hidx, args->v0.start_slot,
-					   args->v0.num_slots, args->v0.pbn,
-					   args->v0.aligned_pbn);
+			outp->ior->func->dp.vcpi(outp->ior, hidx,
+						 args->v0.start_slot,
+						 args->v0.num_slots,
+						 args->v0.pbn,
+						 args->v0.aligned_pbn);
 			return 0;
 		} else
 			return ret;

commit 409b9e54727e700ab8dd15a1e29226eda1e04cdb
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/gt215-: port HDA ELD controls to nvkm_ior
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index a81928de6dcd..d6371110f5a0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -43,7 +43,6 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	} *args = data;
 	struct nv50_disp_root *root = nv50_disp_root(object);
 	struct nv50_disp *disp = root->disp;
-	const struct nv50_disp_func *func = disp->func;
 	struct nvkm_outp *temp, *outp = NULL;
 	struct nvkm_head *head;
 	u16 type, mask = 0;
@@ -112,10 +111,39 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 			return ret;
 	}
 		break;
-	case NV50_DISP_MTHD_V1_SOR_HDA_ELD:
-		if (!func->sor.hda_eld)
+	case NV50_DISP_MTHD_V1_SOR_HDA_ELD: {
+		union {
+			struct nv50_disp_sor_hda_eld_v0 v0;
+		} *args = data;
+		struct nvkm_ior *ior = outp->ior;
+		int ret = -ENOSYS;
+
+		nvif_ioctl(object, "disp sor hda eld size %d\n", size);
+		if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
+			nvif_ioctl(object, "disp sor hda eld vers %d\n",
+				   args->v0.version);
+			if (size > 0x60)
+				return -E2BIG;
+		} else
+			return ret;
+
+		if (!ior->func->hda.hpd)
 			return -ENODEV;
-		return func->sor.hda_eld(object, disp, data, size, hidx, outp);
+
+		if (size && args->v0.data[0]) {
+			if (outp->info.type == DCB_OUTPUT_DP)
+				ior->func->dp.audio(ior, hidx, true);
+			ior->func->hda.hpd(ior, hidx, true);
+			ior->func->hda.eld(ior, data, size);
+		} else {
+			if (outp->info.type == DCB_OUTPUT_DP)
+				ior->func->dp.audio(ior, hidx, false);
+			ior->func->hda.hpd(ior, hidx, false);
+		}
+
+		return 0;
+	}
+		break;
 	case NV50_DISP_MTHD_V1_SOR_HDMI_PWR: {
 		union {
 			struct nv50_disp_sor_hdmi_pwr_v0 v0;

commit 797b2fb81b506d4ad30aa34e5c81c0a541d398cd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/g84-: port OR HDMI control to nvkm_ior
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 7ebea3e14e18..a81928de6dcd 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -116,10 +116,46 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 		if (!func->sor.hda_eld)
 			return -ENODEV;
 		return func->sor.hda_eld(object, disp, data, size, hidx, outp);
-	case NV50_DISP_MTHD_V1_SOR_HDMI_PWR:
-		if (!func->sor.hdmi)
+	case NV50_DISP_MTHD_V1_SOR_HDMI_PWR: {
+		union {
+			struct nv50_disp_sor_hdmi_pwr_v0 v0;
+		} *args = data;
+		u8 *vendor, vendor_size;
+		u8 *avi, avi_size;
+		int ret = -ENOSYS;
+
+		nvif_ioctl(object, "disp sor hdmi ctrl size %d\n", size);
+		if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
+			nvif_ioctl(object, "disp sor hdmi ctrl vers %d state %d "
+					   "max_ac_packet %d rekey %d\n",
+				   args->v0.version, args->v0.state,
+				   args->v0.max_ac_packet, args->v0.rekey);
+			if (args->v0.max_ac_packet > 0x1f || args->v0.rekey > 0x7f)
+				return -EINVAL;
+			if ((args->v0.avi_infoframe_length
+			     + args->v0.vendor_infoframe_length) > size)
+				return -EINVAL;
+			else
+			if ((args->v0.avi_infoframe_length
+			     + args->v0.vendor_infoframe_length) < size)
+				return -E2BIG;
+			avi = data;
+			avi_size = args->v0.avi_infoframe_length;
+			vendor = avi + avi_size;
+			vendor_size = args->v0.vendor_infoframe_length;
+		} else
+			return ret;
+
+		if (!outp->ior->func->hdmi.ctrl)
 			return -ENODEV;
-		return func->sor.hdmi(object, disp, data, size, hidx, outp);
+
+		outp->ior->func->hdmi.ctrl(outp->ior, hidx, args->v0.state,
+					   args->v0.max_ac_packet,
+					   args->v0.rekey, avi, avi_size,
+					   vendor, vendor_size);
+		return 0;
+	}
+		break;
 	case NV50_DISP_MTHD_V1_SOR_LVDS_SCRIPT: {
 		union {
 			struct nv50_disp_sor_lvds_script_v0 v0;

commit 0df182466265d39591d742839f1014f93b7cbd02
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/nv50-: port OR manual sink detection to nvkm_ior
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 3f02e37f30bb..7ebea3e14e18 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -95,8 +95,23 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	}
 
 	switch (mthd * !!outp) {
-	case NV50_DISP_MTHD_V1_DAC_LOAD:
-		return func->dac.sense(object, disp, data, size, hidx, outp);
+	case NV50_DISP_MTHD_V1_DAC_LOAD: {
+		union {
+			struct nv50_disp_dac_load_v0 v0;
+		} *args = data;
+		int ret = -ENOSYS;
+		if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
+			if (args->v0.data & 0xfff00000)
+				return -EINVAL;
+			ret = outp->ior->func->sense(outp->ior, args->v0.data);
+			if (ret < 0)
+				return ret;
+			args->v0.load = ret;
+			return 0;
+		} else
+			return ret;
+	}
+		break;
 	case NV50_DISP_MTHD_V1_SOR_HDA_ELD:
 		if (!func->sor.hda_eld)
 			return -ENODEV;

commit 9c5753bc708da0c2c544fcfe1e94afb399c2b3f6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/nv50-: port OR power state control to nvkm_ior
    
    Also removes the user-facing methods to these controls, as they're not
    currently utilised by the DD anyway.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 9cf1365f5261..3f02e37f30bb 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -24,6 +24,7 @@
 #include "rootnv50.h"
 #include "dmacnv50.h"
 #include "head.h"
+#include "ior.h"
 
 #include <core/client.h>
 #include <core/ramht.h>
@@ -94,12 +95,8 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	}
 
 	switch (mthd * !!outp) {
-	case NV50_DISP_MTHD_V1_DAC_PWR:
-		return func->dac.power(object, disp, data, size, hidx, outp);
 	case NV50_DISP_MTHD_V1_DAC_LOAD:
 		return func->dac.sense(object, disp, data, size, hidx, outp);
-	case NV50_DISP_MTHD_V1_SOR_PWR:
-		return func->sor.power(object, disp, data, size, hidx, outp);
 	case NV50_DISP_MTHD_V1_SOR_HDA_ELD:
 		if (!func->sor.hda_eld)
 			return -ENODEV;
@@ -163,10 +160,6 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 			return ret;
 	}
 		break;
-	case NV50_DISP_MTHD_V1_PIOR_PWR:
-		if (!func->pior.power)
-			return -ENODEV;
-		return func->pior.power(object, disp, data, size, hidx, outp);
 	default:
 		break;
 	}
@@ -231,7 +224,21 @@ static int
 nv50_disp_root_init_(struct nvkm_object *object)
 {
 	struct nv50_disp_root *root = nv50_disp_root(object);
-	return root->func->init(root);
+	struct nvkm_ior *ior;
+	int ret;
+
+	ret = root->func->init(root);
+	if (ret)
+		return ret;
+
+	/* Set 'normal' (ie. when it's attached to a head) state for
+	 * each output resource to 'fully enabled'.
+	 */
+	list_for_each_entry(ior, &root->disp->base.ior, head) {
+		ior->func->power(ior, true, true, true, true, true);
+	}
+
+	return 0;
 }
 
 static void *

commit 7d0a01a6dec9737d24be5ac223e73a0725eac8a0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/dp: train link only when actively displaying an image
    
    This essentially (unless the link becomes unstable and needs to be
    re-trained) gives us a single entry-point to link training, during
    supervisor handling, where we can ensure all routing is up to date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index b817cb511f35..9cf1365f5261 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -125,7 +125,7 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	}
 		break;
 	case NV50_DISP_MTHD_V1_SOR_DP_MST_LINK: {
-		struct nvkm_output_dp *outpdp = nvkm_output_dp(outp);
+		struct nvkm_dp *dp = nvkm_dp(outp);
 		union {
 			struct nv50_disp_sor_dp_mst_link_v0 v0;
 		} *args = data;
@@ -134,11 +134,7 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 		if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 			nvif_ioctl(object, "disp sor dp mst link vers %d state %d\n",
 				   args->v0.version, args->v0.state);
-			if (outpdp->lt.mst != !!args->v0.state) {
-				outpdp->lt.mst = !!args->v0.state;
-				atomic_set(&outpdp->lt.done, 0);
-				nvkm_output_dp_train(&outpdp->base, 0);
-			}
+			dp->lt.mst = !!args->v0.state;
 			return 0;
 		} else
 			return ret;

commit 02d786ccbc7eaaef6ef8380b9d450ef0f4362133
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/dp: remove DP_PWR method
    
    This hasn't been used since atomic.
    
    We may want to re-implement "fast" DPMS at some point, but for now,
    this just gets in the way.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 609bfae9acbb..b817cb511f35 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -124,30 +124,6 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 			return ret;
 	}
 		break;
-	case NV50_DISP_MTHD_V1_SOR_DP_PWR: {
-		struct nvkm_output_dp *outpdp = nvkm_output_dp(outp);
-		union {
-			struct nv50_disp_sor_dp_pwr_v0 v0;
-		} *args = data;
-		int ret = -ENOSYS;
-		nvif_ioctl(object, "disp sor dp pwr size %d\n", size);
-		if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
-			nvif_ioctl(object, "disp sor dp pwr vers %d state %d\n",
-				   args->v0.version, args->v0.state);
-			if (args->v0.state == 0) {
-				nvkm_notify_put(&outpdp->irq);
-				outpdp->func->lnk_pwr(outpdp, 0);
-				atomic_set(&outpdp->lt.done, 0);
-				return 0;
-			} else
-			if (args->v0.state != 0) {
-				nvkm_output_dp_train(&outpdp->base, 0);
-				return 0;
-			}
-		} else
-			return ret;
-	}
-		break;
 	case NV50_DISP_MTHD_V1_SOR_DP_MST_LINK: {
 		struct nvkm_output_dp *outpdp = nvkm_output_dp(outp);
 		union {

commit 57b2d73be275f853066aaf5cc33f6c59a94260b2
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp: common implementation of scanoutpos method in nvkm_head
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index b5df4e8ddbfd..609bfae9acbb 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -33,40 +33,6 @@
 #include <nvif/cl5070.h>
 #include <nvif/unpack.h>
 
-int
-nv50_disp_root_scanoutpos(NV50_DISP_MTHD_V0)
-{
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-	const u32 blanke = nvkm_rd32(device, 0x610aec + (head * 0x540));
-	const u32 blanks = nvkm_rd32(device, 0x610af4 + (head * 0x540));
-	const u32 total  = nvkm_rd32(device, 0x610afc + (head * 0x540));
-	union {
-		struct nv50_disp_scanoutpos_v0 v0;
-	} *args = data;
-	int ret = -ENOSYS;
-
-	nvif_ioctl(object, "disp scanoutpos size %d\n", size);
-	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
-		nvif_ioctl(object, "disp scanoutpos vers %d\n",
-			   args->v0.version);
-		args->v0.vblanke = (blanke & 0xffff0000) >> 16;
-		args->v0.hblanke = (blanke & 0x0000ffff);
-		args->v0.vblanks = (blanks & 0xffff0000) >> 16;
-		args->v0.hblanks = (blanks & 0x0000ffff);
-		args->v0.vtotal  = ( total & 0xffff0000) >> 16;
-		args->v0.htotal  = ( total & 0x0000ffff);
-		args->v0.time[0] = ktime_to_ns(ktime_get());
-		args->v0.vline = /* vline read locks hline */
-			nvkm_rd32(device, 0x616340 + (head * 0x800)) & 0xffff;
-		args->v0.time[1] = ktime_to_ns(ktime_get());
-		args->v0.hline =
-			nvkm_rd32(device, 0x616344 + (head * 0x800)) & 0xffff;
-	} else
-		return ret;
-
-	return 0;
-}
-
 static int
 nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
@@ -78,8 +44,9 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	struct nv50_disp *disp = root->disp;
 	const struct nv50_disp_func *func = disp->func;
 	struct nvkm_outp *temp, *outp = NULL;
+	struct nvkm_head *head;
 	u16 type, mask = 0;
-	int head, ret = -ENOSYS;
+	int hidx, ret = -ENOSYS;
 
 	if (mthd != NV50_DISP_MTHD)
 		return -EINVAL;
@@ -89,7 +56,7 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 		nvif_ioctl(object, "disp mthd vers %d mthd %02x head %d\n",
 			   args->v0.version, args->v0.method, args->v0.head);
 		mthd = args->v0.method;
-		head = args->v0.head;
+		hidx = args->v0.head;
 	} else
 	if (!(ret = nvif_unpack(ret, &data, &size, args->v1, 1, 1, true))) {
 		nvif_ioctl(object, "disp mthd vers %d mthd %02x "
@@ -99,11 +66,11 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 		mthd = args->v1.method;
 		type = args->v1.hasht;
 		mask = args->v1.hashm;
-		head = ffs((mask >> 8) & 0x0f) - 1;
+		hidx = ffs((mask >> 8) & 0x0f) - 1;
 	} else
 		return ret;
 
-	if (!nvkm_head_find(&disp->base, head))
+	if (!(head = nvkm_head_find(&disp->base, hidx)))
 		return -ENXIO;
 
 	if (mask) {
@@ -119,27 +86,28 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	}
 
 	switch (mthd) {
-	case NV50_DISP_SCANOUTPOS:
-		return func->head.scanoutpos(object, disp, data, size, head);
+	case NV50_DISP_SCANOUTPOS: {
+		return nvkm_head_mthd_scanoutpos(object, head, data, size);
+	}
 	default:
 		break;
 	}
 
 	switch (mthd * !!outp) {
 	case NV50_DISP_MTHD_V1_DAC_PWR:
-		return func->dac.power(object, disp, data, size, head, outp);
+		return func->dac.power(object, disp, data, size, hidx, outp);
 	case NV50_DISP_MTHD_V1_DAC_LOAD:
-		return func->dac.sense(object, disp, data, size, head, outp);
+		return func->dac.sense(object, disp, data, size, hidx, outp);
 	case NV50_DISP_MTHD_V1_SOR_PWR:
-		return func->sor.power(object, disp, data, size, head, outp);
+		return func->sor.power(object, disp, data, size, hidx, outp);
 	case NV50_DISP_MTHD_V1_SOR_HDA_ELD:
 		if (!func->sor.hda_eld)
 			return -ENODEV;
-		return func->sor.hda_eld(object, disp, data, size, head, outp);
+		return func->sor.hda_eld(object, disp, data, size, hidx, outp);
 	case NV50_DISP_MTHD_V1_SOR_HDMI_PWR:
 		if (!func->sor.hdmi)
 			return -ENODEV;
-		return func->sor.hdmi(object, disp, data, size, head, outp);
+		return func->sor.hdmi(object, disp, data, size, hidx, outp);
 	case NV50_DISP_MTHD_V1_SOR_LVDS_SCRIPT: {
 		union {
 			struct nv50_disp_sor_lvds_script_v0 v0;
@@ -215,7 +183,7 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 				   args->v0.aligned_pbn);
 			if (!outpdp->func->vcpi)
 				return -ENODEV;
-			outpdp->func->vcpi(outpdp, head, args->v0.start_slot,
+			outpdp->func->vcpi(outpdp, hidx, args->v0.start_slot,
 					   args->v0.num_slots, args->v0.pbn,
 					   args->v0.aligned_pbn);
 			return 0;
@@ -226,7 +194,7 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	case NV50_DISP_MTHD_V1_PIOR_PWR:
 		if (!func->pior.power)
 			return -ENODEV;
-		return func->pior.power(object, disp, data, size, head, outp);
+		return func->pior.power(object, disp, data, size, hidx, outp);
 	default:
 		break;
 	}

commit a1c930789aa51b928f804c9186f9821efd070ce1
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/disp: introduce object to track per-head functions/state
    
    Primarily intended as a way to pass per-head state around during
    supervisor handling, and share logic between NV50/GF119.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 2e73aeb86070..b5df4e8ddbfd 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -23,6 +23,7 @@
  */
 #include "rootnv50.h"
 #include "dmacnv50.h"
+#include "head.h"
 
 #include <core/client.h>
 #include <core/ramht.h>
@@ -102,7 +103,7 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	} else
 		return ret;
 
-	if (head < 0 || head >= disp->base.head.nr)
+	if (!nvkm_head_find(&disp->base, head))
 		return -ENXIO;
 
 	if (mask) {
@@ -351,6 +352,7 @@ int
 nv50_disp_root_init(struct nv50_disp_root *root)
 {
 	struct nv50_disp *disp = root->disp;
+	struct nvkm_head *head;
 	struct nvkm_device *device = disp->base.engine.subdev.device;
 	u32 tmp;
 	int i;
@@ -363,15 +365,15 @@ nv50_disp_root_init(struct nv50_disp_root *root)
 	nvkm_wr32(device, 0x610184, tmp);
 
 	/* ... CRTC caps */
-	for (i = 0; i < disp->base.head.nr; i++) {
-		tmp = nvkm_rd32(device, 0x616100 + (i * 0x800));
-		nvkm_wr32(device, 0x610190 + (i * 0x10), tmp);
-		tmp = nvkm_rd32(device, 0x616104 + (i * 0x800));
-		nvkm_wr32(device, 0x610194 + (i * 0x10), tmp);
-		tmp = nvkm_rd32(device, 0x616108 + (i * 0x800));
-		nvkm_wr32(device, 0x610198 + (i * 0x10), tmp);
-		tmp = nvkm_rd32(device, 0x61610c + (i * 0x800));
-		nvkm_wr32(device, 0x61019c + (i * 0x10), tmp);
+	list_for_each_entry(head, &disp->base.head, head) {
+		tmp = nvkm_rd32(device, 0x616100 + (head->id * 0x800));
+		nvkm_wr32(device, 0x610190 + (head->id * 0x10), tmp);
+		tmp = nvkm_rd32(device, 0x616104 + (head->id * 0x800));
+		nvkm_wr32(device, 0x610194 + (head->id * 0x10), tmp);
+		tmp = nvkm_rd32(device, 0x616108 + (head->id * 0x800));
+		nvkm_wr32(device, 0x610198 + (head->id * 0x10), tmp);
+		tmp = nvkm_rd32(device, 0x61610c + (head->id * 0x800));
+		nvkm_wr32(device, 0x61019c + (head->id * 0x10), tmp);
 	}
 
 	/* ... DAC caps */

commit d7ce92e27303082f00cf0976d673f4cc0a5f1c5f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/disp: rename nvkm_output to nvkm_outp
    
    This isn't technically "output", but, "display/output path".
    
    Not all users of nvkm_output have been changed here.  The remaining
    ones belong to code that's disappearing in upcoming commits.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index e70dc6a9ff7d..2e73aeb86070 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -76,8 +76,7 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	struct nv50_disp_root *root = nv50_disp_root(object);
 	struct nv50_disp *disp = root->disp;
 	const struct nv50_disp_func *func = disp->func;
-	struct nvkm_output *outp = NULL;
-	struct nvkm_output *temp;
+	struct nvkm_outp *temp, *outp = NULL;
 	u16 type, mask = 0;
 	int head, ret = -ENOSYS;
 

commit 2a32b9b1866a2ee9f01fbf2a48d99012f0120739
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 16 14:49:35 2016 +1000

    drm/nouveau/disp/nv50-: specify ctrl/user separately when constructing classes
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index c1158b22a721..e70dc6a9ff7d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -250,8 +250,8 @@ nv50_disp_root_pioc_new_(const struct nvkm_oclass *oclass,
 {
 	const struct nv50_disp_pioc_oclass *sclass = oclass->priv;
 	struct nv50_disp_root *root = nv50_disp_root(oclass->parent);
-	return sclass->ctor(sclass->func, sclass->mthd, root, sclass->chid,
-			    oclass, data, size, pobject);
+	return sclass->ctor(sclass->func, sclass->mthd, root, sclass->chid.ctrl,
+			    sclass->chid.user, oclass, data, size, pobject);
 }
 
 static int

commit 4cddeb9b315784c90c81db386943bca22690cb27
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 4 17:20:35 2016 +1000

    drm/nouveau/disp/sor/gf119-: add method to program mst payload information
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 1a2506767755..c1158b22a721 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -200,6 +200,29 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 			return ret;
 	}
 		break;
+	case NV50_DISP_MTHD_V1_SOR_DP_MST_VCPI: {
+		struct nvkm_output_dp *outpdp = nvkm_output_dp(outp);
+		union {
+			struct nv50_disp_sor_dp_mst_vcpi_v0 v0;
+		} *args = data;
+		int ret = -ENOSYS;
+		nvif_ioctl(object, "disp sor dp mst vcpi size %d\n", size);
+		if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
+			nvif_ioctl(object, "disp sor dp mst vcpi vers %d "
+					   "slot %02x/%02x pbn %04x/%04x\n",
+				   args->v0.version, args->v0.start_slot,
+				   args->v0.num_slots, args->v0.pbn,
+				   args->v0.aligned_pbn);
+			if (!outpdp->func->vcpi)
+				return -ENODEV;
+			outpdp->func->vcpi(outpdp, head, args->v0.start_slot,
+					   args->v0.num_slots, args->v0.pbn,
+					   args->v0.aligned_pbn);
+			return 0;
+		} else
+			return ret;
+	}
+		break;
 	case NV50_DISP_MTHD_V1_PIOR_PWR:
 		if (!func->pior.power)
 			return -ENODEV;

commit f2a4051379f8f4de418be074ccca77a6aae02f65
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 4 17:20:35 2016 +1000

    drm/nouveau/disp/sor/gf119-: add method to control mst enable
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index e9548e4fbf21..1a2506767755 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -180,6 +180,26 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 			return ret;
 	}
 		break;
+	case NV50_DISP_MTHD_V1_SOR_DP_MST_LINK: {
+		struct nvkm_output_dp *outpdp = nvkm_output_dp(outp);
+		union {
+			struct nv50_disp_sor_dp_mst_link_v0 v0;
+		} *args = data;
+		int ret = -ENOSYS;
+		nvif_ioctl(object, "disp sor dp mst link size %d\n", size);
+		if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
+			nvif_ioctl(object, "disp sor dp mst link vers %d state %d\n",
+				   args->v0.version, args->v0.state);
+			if (outpdp->lt.mst != !!args->v0.state) {
+				outpdp->lt.mst = !!args->v0.state;
+				atomic_set(&outpdp->lt.done, 0);
+				nvkm_output_dp_train(&outpdp->base, 0);
+			}
+			return 0;
+		} else
+			return ret;
+	}
+		break;
 	case NV50_DISP_MTHD_V1_PIOR_PWR:
 		if (!func->pior.power)
 			return -ENODEV;

commit 1f8711bafe0b43716592a3797f693eb7c0175123
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 4 17:20:35 2016 +1000

    drm/nouveau/disp/dp: remove workqueue for link training
    
    There haven't been any callers from an atomic context for a while now,
    so let's remove the extra complexity.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 6424b396dcde..e9548e4fbf21 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -173,7 +173,7 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 				return 0;
 			} else
 			if (args->v0.state != 0) {
-				nvkm_output_dp_train(&outpdp->base, 0, true);
+				nvkm_output_dp_train(&outpdp->base, 0);
 				return 0;
 			}
 		} else

commit e08a1d97d33e2ac05cd368b955f9fdc2823f15fd
Author: Baoyou Xie <baoyou.xie@linaro.org>
Date:   Mon Oct 24 11:09:03 2016 +0800

    drm/nouveau: mark symbols static where possible
    
    We get a few warnings when building kernel with W=1:
    drivers/gpu/drm/nouveau/nvkm/subdev/bios/fan.c:29:1: warning: no previous prototype for 'nvbios_fan_table' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/bios/fan.c:56:1: warning: no previous prototype for 'nvbios_fan_entry' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/clk/gt215.c:184:1: warning: no previous prototype for 'gt215_clk_info' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c:99:1: warning: no previous prototype for 'gt215_link_train_calc' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c:153:1: warning: no previous prototype for 'gt215_link_train' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c:271:1: warning: no previous prototype for 'gt215_link_train_init' [-Wmissing-prototypes]
    ....
    
    In fact, both functions are only used in the file in which they are
    declared and don't need a declaration, but can be made static.
    So this patch marks these functions with 'static'.
    
    Signed-off-by: Baoyou Xie <baoyou.xie@linaro.org>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 2f9cecd81d04..6424b396dcde 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -66,7 +66,7 @@ nv50_disp_root_scanoutpos(NV50_DISP_MTHD_V0)
 	return 0;
 }
 
-int
+static int
 nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
 	union {

commit f01c4e682c941ba70e0ebec44db754844a1b9b82
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon Nov 9 09:21:27 2015 +1000

    drm/nouveau/nvif: modify nvif_unvers/nvif_unpack macros to be more obvious
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 2aba84d51b1e..2f9cecd81d04 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -42,10 +42,10 @@ nv50_disp_root_scanoutpos(NV50_DISP_MTHD_V0)
 	union {
 		struct nv50_disp_scanoutpos_v0 v0;
 	} *args = data;
-	int ret;
+	int ret = -ENOSYS;
 
 	nvif_ioctl(object, "disp scanoutpos size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 		nvif_ioctl(object, "disp scanoutpos vers %d\n",
 			   args->v0.version);
 		args->v0.vblanke = (blanke & 0xffff0000) >> 16;
@@ -79,19 +79,19 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	struct nvkm_output *outp = NULL;
 	struct nvkm_output *temp;
 	u16 type, mask = 0;
-	int head, ret;
+	int head, ret = -ENOSYS;
 
 	if (mthd != NV50_DISP_MTHD)
 		return -EINVAL;
 
 	nvif_ioctl(object, "disp mthd size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, true)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {
 		nvif_ioctl(object, "disp mthd vers %d mthd %02x head %d\n",
 			   args->v0.version, args->v0.method, args->v0.head);
 		mthd = args->v0.method;
 		head = args->v0.head;
 	} else
-	if (nvif_unpack(args->v1, 1, 1, true)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v1, 1, 1, true))) {
 		nvif_ioctl(object, "disp mthd vers %d mthd %02x "
 				   "type %04x mask %04x\n",
 			   args->v1.version, args->v1.method,
@@ -144,8 +144,9 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 		union {
 			struct nv50_disp_sor_lvds_script_v0 v0;
 		} *args = data;
+		int ret = -ENOSYS;
 		nvif_ioctl(object, "disp sor lvds script size %d\n", size);
-		if (nvif_unpack(args->v0, 0, 0, false)) {
+		if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 			nvif_ioctl(object, "disp sor lvds script "
 					   "vers %d name %04x\n",
 				   args->v0.version, args->v0.script);
@@ -160,8 +161,9 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 		union {
 			struct nv50_disp_sor_dp_pwr_v0 v0;
 		} *args = data;
+		int ret = -ENOSYS;
 		nvif_ioctl(object, "disp sor dp pwr size %d\n", size);
-		if (nvif_unpack(args->v0, 0, 0, false)) {
+		if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 			nvif_ioctl(object, "disp sor dp pwr vers %d state %d\n",
 				   args->v0.version, args->v0.state);
 			if (args->v0.state == 0) {

commit 7568b106718165feacdf411f1b8f95ae4263456a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Nov 8 10:44:19 2015 +1000

    drm/nouveau/nvif: split out display interface definitions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 06fb24d88702..2aba84d51b1e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -29,6 +29,7 @@
 #include <subdev/timer.h>
 
 #include <nvif/class.h>
+#include <nvif/cl5070.h>
 #include <nvif/unpack.h>
 
 int
@@ -39,7 +40,7 @@ nv50_disp_root_scanoutpos(NV50_DISP_MTHD_V0)
 	const u32 blanks = nvkm_rd32(device, 0x610af4 + (head * 0x540));
 	const u32 total  = nvkm_rd32(device, 0x610afc + (head * 0x540));
 	union {
-		struct nv04_disp_scanoutpos_v0 v0;
+		struct nv50_disp_scanoutpos_v0 v0;
 	} *args = data;
 	int ret;
 

commit 70aa8670e5229766f12c4b818a68aa61913df0b6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/disp: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 472357f499ad..06fb24d88702 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -74,7 +74,7 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	} *args = data;
 	struct nv50_disp_root *root = nv50_disp_root(object);
 	struct nv50_disp *disp = root->disp;
-	const struct nv50_disp_impl *impl = (void *)nv_oclass(object->engine);
+	const struct nv50_disp_func *func = disp->func;
 	struct nvkm_output *outp = NULL;
 	struct nvkm_output *temp;
 	u16 type, mask = 0;
@@ -102,7 +102,7 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	} else
 		return ret;
 
-	if (head < 0 || head >= disp->head.nr)
+	if (head < 0 || head >= disp->base.head.nr)
 		return -ENXIO;
 
 	if (mask) {
@@ -119,26 +119,26 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 
 	switch (mthd) {
 	case NV50_DISP_SCANOUTPOS:
-		return impl->head.scanoutpos(object, disp, data, size, head);
+		return func->head.scanoutpos(object, disp, data, size, head);
 	default:
 		break;
 	}
 
 	switch (mthd * !!outp) {
 	case NV50_DISP_MTHD_V1_DAC_PWR:
-		return disp->dac.power(object, disp, data, size, head, outp);
+		return func->dac.power(object, disp, data, size, head, outp);
 	case NV50_DISP_MTHD_V1_DAC_LOAD:
-		return disp->dac.sense(object, disp, data, size, head, outp);
+		return func->dac.sense(object, disp, data, size, head, outp);
 	case NV50_DISP_MTHD_V1_SOR_PWR:
-		return disp->sor.power(object, disp, data, size, head, outp);
+		return func->sor.power(object, disp, data, size, head, outp);
 	case NV50_DISP_MTHD_V1_SOR_HDA_ELD:
-		if (!disp->sor.hda_eld)
+		if (!func->sor.hda_eld)
 			return -ENODEV;
-		return disp->sor.hda_eld(object, disp, data, size, head, outp);
+		return func->sor.hda_eld(object, disp, data, size, head, outp);
 	case NV50_DISP_MTHD_V1_SOR_HDMI_PWR:
-		if (!disp->sor.hdmi)
+		if (!func->sor.hdmi)
 			return -ENODEV;
-		return disp->sor.hdmi(object, disp, data, size, head, outp);
+		return func->sor.hdmi(object, disp, data, size, head, outp);
 	case NV50_DISP_MTHD_V1_SOR_LVDS_SCRIPT: {
 		union {
 			struct nv50_disp_sor_lvds_script_v0 v0;
@@ -178,9 +178,9 @@ nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	}
 		break;
 	case NV50_DISP_MTHD_V1_PIOR_PWR:
-		if (!disp->pior.power)
+		if (!func->pior.power)
 			return -ENODEV;
-		return disp->pior.power(object, disp, data, size, head, outp);
+		return func->pior.power(object, disp, data, size, head, outp);
 	default:
 		break;
 	}
@@ -318,7 +318,7 @@ nv50_disp_root_init(struct nv50_disp_root *root)
 	nvkm_wr32(device, 0x610184, tmp);
 
 	/* ... CRTC caps */
-	for (i = 0; i < disp->head.nr; i++) {
+	for (i = 0; i < disp->base.head.nr; i++) {
 		tmp = nvkm_rd32(device, 0x616100 + (i * 0x800));
 		nvkm_wr32(device, 0x610190 + (i * 0x10), tmp);
 		tmp = nvkm_rd32(device, 0x616104 + (i * 0x800));
@@ -330,19 +330,19 @@ nv50_disp_root_init(struct nv50_disp_root *root)
 	}
 
 	/* ... DAC caps */
-	for (i = 0; i < disp->dac.nr; i++) {
+	for (i = 0; i < disp->func->dac.nr; i++) {
 		tmp = nvkm_rd32(device, 0x61a000 + (i * 0x800));
 		nvkm_wr32(device, 0x6101d0 + (i * 0x04), tmp);
 	}
 
 	/* ... SOR caps */
-	for (i = 0; i < disp->sor.nr; i++) {
+	for (i = 0; i < disp->func->sor.nr; i++) {
 		tmp = nvkm_rd32(device, 0x61c000 + (i * 0x800));
 		nvkm_wr32(device, 0x6101e0 + (i * 0x04), tmp);
 	}
 
 	/* ... PIOR caps */
-	for (i = 0; i < disp->pior.nr; i++) {
+	for (i = 0; i < disp->func->pior.nr; i++) {
 		tmp = nvkm_rd32(device, 0x61e000 + (i * 0x800));
 		nvkm_wr32(device, 0x6101f0 + (i * 0x04), tmp);
 	}

commit 0ce41e3c66ca8958dec427f1c46f64efdda90f30
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/disp: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
index 83549702bbc1..472357f499ad 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -66,14 +66,15 @@ nv50_disp_root_scanoutpos(NV50_DISP_MTHD_V0)
 }
 
 int
-nv50_disp_root_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
+nv50_disp_root_mthd_(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
-	const struct nv50_disp_impl *impl = (void *)nv_oclass(object->engine);
 	union {
 		struct nv50_disp_mthd_v0 v0;
 		struct nv50_disp_mthd_v1 v1;
 	} *args = data;
-	struct nv50_disp *disp = (void *)object->engine;
+	struct nv50_disp_root *root = nv50_disp_root(object);
+	struct nv50_disp *disp = root->disp;
+	const struct nv50_disp_impl *impl = (void *)nv_oclass(object->engine);
 	struct nvkm_output *outp = NULL;
 	struct nvkm_output *temp;
 	u16 type, mask = 0;
@@ -187,48 +188,127 @@ nv50_disp_root_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 	return -EINVAL;
 }
 
+static int
+nv50_disp_root_dmac_new_(const struct nvkm_oclass *oclass,
+			 void *data, u32 size, struct nvkm_object **pobject)
+{
+	const struct nv50_disp_dmac_oclass *sclass = oclass->priv;
+	struct nv50_disp_root *root = nv50_disp_root(oclass->parent);
+	return sclass->ctor(sclass->func, sclass->mthd, root, sclass->chid,
+			    oclass, data, size, pobject);
+}
+
+static int
+nv50_disp_root_pioc_new_(const struct nvkm_oclass *oclass,
+			 void *data, u32 size, struct nvkm_object **pobject)
+{
+	const struct nv50_disp_pioc_oclass *sclass = oclass->priv;
+	struct nv50_disp_root *root = nv50_disp_root(oclass->parent);
+	return sclass->ctor(sclass->func, sclass->mthd, root, sclass->chid,
+			    oclass, data, size, pobject);
+}
+
+static int
+nv50_disp_root_child_get_(struct nvkm_object *object, int index,
+			  struct nvkm_oclass *sclass)
+{
+	struct nv50_disp_root *root = nv50_disp_root(object);
+
+	if (index < ARRAY_SIZE(root->func->dmac)) {
+		sclass->base = root->func->dmac[index]->base;
+		sclass->priv = root->func->dmac[index];
+		sclass->ctor = nv50_disp_root_dmac_new_;
+		return 0;
+	}
+
+	index -= ARRAY_SIZE(root->func->dmac);
+
+	if (index < ARRAY_SIZE(root->func->pioc)) {
+		sclass->base = root->func->pioc[index]->base;
+		sclass->priv = root->func->pioc[index];
+		sclass->ctor = nv50_disp_root_pioc_new_;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int
+nv50_disp_root_fini_(struct nvkm_object *object, bool suspend)
+{
+	struct nv50_disp_root *root = nv50_disp_root(object);
+	root->func->fini(root);
+	return 0;
+}
+
+static int
+nv50_disp_root_init_(struct nvkm_object *object)
+{
+	struct nv50_disp_root *root = nv50_disp_root(object);
+	return root->func->init(root);
+}
+
+static void *
+nv50_disp_root_dtor_(struct nvkm_object *object)
+{
+	struct nv50_disp_root *root = nv50_disp_root(object);
+	nvkm_ramht_del(&root->ramht);
+	nvkm_gpuobj_del(&root->instmem);
+	return root;
+}
+
+static const struct nvkm_object_func
+nv50_disp_root_ = {
+	.dtor = nv50_disp_root_dtor_,
+	.init = nv50_disp_root_init_,
+	.fini = nv50_disp_root_fini_,
+	.mthd = nv50_disp_root_mthd_,
+	.ntfy = nvkm_disp_ntfy,
+	.sclass = nv50_disp_root_child_get_,
+};
+
 int
-nv50_disp_root_ctor(struct nvkm_object *parent,
-		    struct nvkm_object *engine,
-		    struct nvkm_oclass *oclass, void *data, u32 size,
-		    struct nvkm_object **pobject)
+nv50_disp_root_new_(const struct nv50_disp_root_func *func,
+		    struct nvkm_disp *base, const struct nvkm_oclass *oclass,
+		    void *data, u32 size, struct nvkm_object **pobject)
 {
-	struct nv50_disp *disp = (void *)engine;
+	struct nv50_disp *disp = nv50_disp(base);
 	struct nv50_disp_root *root;
 	struct nvkm_device *device = disp->base.engine.subdev.device;
-	struct nvkm_gpuobj *instmem = (void *)parent;
 	int ret;
 
-	ret = nvkm_parent_create(parent, engine, oclass, 0,
-				 disp->sclass, 0, &root);
-	*pobject = nv_object(root);
+	if (!(root = kzalloc(sizeof(*root), GFP_KERNEL)))
+		return -ENOMEM;
+	*pobject = &root->object;
+
+	nvkm_object_ctor(&nv50_disp_root_, oclass, &root->object);
+	root->func = func;
+	root->disp = disp;
+
+	ret = nvkm_gpuobj_new(disp->base.engine.subdev.device, 0x10000, 0x10000,
+			      false, NULL, &root->instmem);
 	if (ret)
 		return ret;
 
-
-	return nvkm_ramht_new(device, 0x1000, 0, instmem, &root->ramht);
+	return nvkm_ramht_new(device, 0x1000, 0, root->instmem, &root->ramht);
 }
 
 void
-nv50_disp_root_dtor(struct nvkm_object *object)
+nv50_disp_root_fini(struct nv50_disp_root *root)
 {
-	struct nv50_disp_root *root = (void *)object;
-	nvkm_ramht_del(&root->ramht);
-	nvkm_parent_destroy(&root->base);
+	struct nvkm_device *device = root->disp->base.engine.subdev.device;
+	/* disable all interrupts */
+	nvkm_wr32(device, 0x610024, 0x00000000);
+	nvkm_wr32(device, 0x610020, 0x00000000);
 }
 
-static int
-nv50_disp_root_init(struct nvkm_object *object)
+int
+nv50_disp_root_init(struct nv50_disp_root *root)
 {
-	struct nv50_disp *disp = (void *)object->engine;
-	struct nv50_disp_root *root = (void *)object;
+	struct nv50_disp *disp = root->disp;
 	struct nvkm_device *device = disp->base.engine.subdev.device;
-	int ret, i;
 	u32 tmp;
-
-	ret = nvkm_parent_init(&root->base);
-	if (ret)
-		return ret;
+	int i;
 
 	/* The below segments of code copying values from one register to
 	 * another appear to inform EVO of the display capabilities or
@@ -279,7 +359,7 @@ nv50_disp_root_init(struct nvkm_object *object)
 	}
 
 	/* point at display engine memory area (hash table, objects) */
-	nvkm_wr32(device, 0x610010, (root->ramht->gpuobj->addr >> 8) | 9);
+	nvkm_wr32(device, 0x610010, (root->instmem->addr >> 8) | 9);
 
 	/* enable supervisor interrupts, disable everything else */
 	nvkm_wr32(device, 0x61002c, 0x00000370);
@@ -287,42 +367,33 @@ nv50_disp_root_init(struct nvkm_object *object)
 	return 0;
 }
 
-static int
-nv50_disp_root_fini(struct nvkm_object *object, bool suspend)
-{
-	struct nv50_disp *disp = (void *)object->engine;
-	struct nv50_disp_root *root = (void *)object;
-	struct nvkm_device *device = disp->base.engine.subdev.device;
-
-	/* disable all interrupts */
-	nvkm_wr32(device, 0x610024, 0x00000000);
-	nvkm_wr32(device, 0x610020, 0x00000000);
-
-	return nvkm_parent_fini(&root->base, suspend);
-}
-
-struct nvkm_ofuncs
-nv50_disp_root_ofuncs = {
-	.ctor = nv50_disp_root_ctor,
-	.dtor = nv50_disp_root_dtor,
+static const struct nv50_disp_root_func
+nv50_disp_root = {
 	.init = nv50_disp_root_init,
 	.fini = nv50_disp_root_fini,
-	.mthd = nv50_disp_root_mthd,
-	.ntfy = nvkm_disp_ntfy,
+	.dmac = {
+		&nv50_disp_core_oclass,
+		&nv50_disp_base_oclass,
+		&nv50_disp_ovly_oclass,
+	},
+	.pioc = {
+		&nv50_disp_oimm_oclass,
+		&nv50_disp_curs_oclass,
+	},
 };
 
-struct nvkm_oclass
-nv50_disp_root_oclass[] = {
-	{ NV50_DISP, &nv50_disp_root_ofuncs },
-	{}
-};
+static int
+nv50_disp_root_new(struct nvkm_disp *disp, const struct nvkm_oclass *oclass,
+		   void *data, u32 size, struct nvkm_object **pobject)
+{
+	return nv50_disp_root_new_(&nv50_disp_root, disp, oclass,
+				   data, size, pobject);
+}
 
-struct nvkm_oclass
-nv50_disp_sclass[] = {
-	{ NV50_DISP_CORE_CHANNEL_DMA, &nv50_disp_core_ofuncs.base },
-	{ NV50_DISP_BASE_CHANNEL_DMA, &nv50_disp_base_ofuncs.base },
-	{ NV50_DISP_OVERLAY_CHANNEL_DMA, &nv50_disp_ovly_ofuncs.base },
-	{ NV50_DISP_OVERLAY, &nv50_disp_oimm_ofuncs.base },
-	{ NV50_DISP_CURSOR, &nv50_disp_curs_ofuncs.base },
-	{}
+const struct nvkm_disp_oclass
+nv50_disp_root_oclass = {
+	.base.oclass = NV50_DISP,
+	.base.minver = -1,
+	.base.maxver = -1,
+	.ctor = nv50_disp_root_new,
 };

commit 2a7909c0ade08c66690e6115ae49765dc47873e6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/disp: split user classes out from engine implementations
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
new file mode 100644
index 000000000000..83549702bbc1
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/rootnv50.c
@@ -0,0 +1,328 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+#include "rootnv50.h"
+#include "dmacnv50.h"
+
+#include <core/client.h>
+#include <core/ramht.h>
+#include <subdev/timer.h>
+
+#include <nvif/class.h>
+#include <nvif/unpack.h>
+
+int
+nv50_disp_root_scanoutpos(NV50_DISP_MTHD_V0)
+{
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	const u32 blanke = nvkm_rd32(device, 0x610aec + (head * 0x540));
+	const u32 blanks = nvkm_rd32(device, 0x610af4 + (head * 0x540));
+	const u32 total  = nvkm_rd32(device, 0x610afc + (head * 0x540));
+	union {
+		struct nv04_disp_scanoutpos_v0 v0;
+	} *args = data;
+	int ret;
+
+	nvif_ioctl(object, "disp scanoutpos size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nvif_ioctl(object, "disp scanoutpos vers %d\n",
+			   args->v0.version);
+		args->v0.vblanke = (blanke & 0xffff0000) >> 16;
+		args->v0.hblanke = (blanke & 0x0000ffff);
+		args->v0.vblanks = (blanks & 0xffff0000) >> 16;
+		args->v0.hblanks = (blanks & 0x0000ffff);
+		args->v0.vtotal  = ( total & 0xffff0000) >> 16;
+		args->v0.htotal  = ( total & 0x0000ffff);
+		args->v0.time[0] = ktime_to_ns(ktime_get());
+		args->v0.vline = /* vline read locks hline */
+			nvkm_rd32(device, 0x616340 + (head * 0x800)) & 0xffff;
+		args->v0.time[1] = ktime_to_ns(ktime_get());
+		args->v0.hline =
+			nvkm_rd32(device, 0x616344 + (head * 0x800)) & 0xffff;
+	} else
+		return ret;
+
+	return 0;
+}
+
+int
+nv50_disp_root_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
+{
+	const struct nv50_disp_impl *impl = (void *)nv_oclass(object->engine);
+	union {
+		struct nv50_disp_mthd_v0 v0;
+		struct nv50_disp_mthd_v1 v1;
+	} *args = data;
+	struct nv50_disp *disp = (void *)object->engine;
+	struct nvkm_output *outp = NULL;
+	struct nvkm_output *temp;
+	u16 type, mask = 0;
+	int head, ret;
+
+	if (mthd != NV50_DISP_MTHD)
+		return -EINVAL;
+
+	nvif_ioctl(object, "disp mthd size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, true)) {
+		nvif_ioctl(object, "disp mthd vers %d mthd %02x head %d\n",
+			   args->v0.version, args->v0.method, args->v0.head);
+		mthd = args->v0.method;
+		head = args->v0.head;
+	} else
+	if (nvif_unpack(args->v1, 1, 1, true)) {
+		nvif_ioctl(object, "disp mthd vers %d mthd %02x "
+				   "type %04x mask %04x\n",
+			   args->v1.version, args->v1.method,
+			   args->v1.hasht, args->v1.hashm);
+		mthd = args->v1.method;
+		type = args->v1.hasht;
+		mask = args->v1.hashm;
+		head = ffs((mask >> 8) & 0x0f) - 1;
+	} else
+		return ret;
+
+	if (head < 0 || head >= disp->head.nr)
+		return -ENXIO;
+
+	if (mask) {
+		list_for_each_entry(temp, &disp->base.outp, head) {
+			if ((temp->info.hasht         == type) &&
+			    (temp->info.hashm & mask) == mask) {
+				outp = temp;
+				break;
+			}
+		}
+		if (outp == NULL)
+			return -ENXIO;
+	}
+
+	switch (mthd) {
+	case NV50_DISP_SCANOUTPOS:
+		return impl->head.scanoutpos(object, disp, data, size, head);
+	default:
+		break;
+	}
+
+	switch (mthd * !!outp) {
+	case NV50_DISP_MTHD_V1_DAC_PWR:
+		return disp->dac.power(object, disp, data, size, head, outp);
+	case NV50_DISP_MTHD_V1_DAC_LOAD:
+		return disp->dac.sense(object, disp, data, size, head, outp);
+	case NV50_DISP_MTHD_V1_SOR_PWR:
+		return disp->sor.power(object, disp, data, size, head, outp);
+	case NV50_DISP_MTHD_V1_SOR_HDA_ELD:
+		if (!disp->sor.hda_eld)
+			return -ENODEV;
+		return disp->sor.hda_eld(object, disp, data, size, head, outp);
+	case NV50_DISP_MTHD_V1_SOR_HDMI_PWR:
+		if (!disp->sor.hdmi)
+			return -ENODEV;
+		return disp->sor.hdmi(object, disp, data, size, head, outp);
+	case NV50_DISP_MTHD_V1_SOR_LVDS_SCRIPT: {
+		union {
+			struct nv50_disp_sor_lvds_script_v0 v0;
+		} *args = data;
+		nvif_ioctl(object, "disp sor lvds script size %d\n", size);
+		if (nvif_unpack(args->v0, 0, 0, false)) {
+			nvif_ioctl(object, "disp sor lvds script "
+					   "vers %d name %04x\n",
+				   args->v0.version, args->v0.script);
+			disp->sor.lvdsconf = args->v0.script;
+			return 0;
+		} else
+			return ret;
+	}
+		break;
+	case NV50_DISP_MTHD_V1_SOR_DP_PWR: {
+		struct nvkm_output_dp *outpdp = nvkm_output_dp(outp);
+		union {
+			struct nv50_disp_sor_dp_pwr_v0 v0;
+		} *args = data;
+		nvif_ioctl(object, "disp sor dp pwr size %d\n", size);
+		if (nvif_unpack(args->v0, 0, 0, false)) {
+			nvif_ioctl(object, "disp sor dp pwr vers %d state %d\n",
+				   args->v0.version, args->v0.state);
+			if (args->v0.state == 0) {
+				nvkm_notify_put(&outpdp->irq);
+				outpdp->func->lnk_pwr(outpdp, 0);
+				atomic_set(&outpdp->lt.done, 0);
+				return 0;
+			} else
+			if (args->v0.state != 0) {
+				nvkm_output_dp_train(&outpdp->base, 0, true);
+				return 0;
+			}
+		} else
+			return ret;
+	}
+		break;
+	case NV50_DISP_MTHD_V1_PIOR_PWR:
+		if (!disp->pior.power)
+			return -ENODEV;
+		return disp->pior.power(object, disp, data, size, head, outp);
+	default:
+		break;
+	}
+
+	return -EINVAL;
+}
+
+int
+nv50_disp_root_ctor(struct nvkm_object *parent,
+		    struct nvkm_object *engine,
+		    struct nvkm_oclass *oclass, void *data, u32 size,
+		    struct nvkm_object **pobject)
+{
+	struct nv50_disp *disp = (void *)engine;
+	struct nv50_disp_root *root;
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	struct nvkm_gpuobj *instmem = (void *)parent;
+	int ret;
+
+	ret = nvkm_parent_create(parent, engine, oclass, 0,
+				 disp->sclass, 0, &root);
+	*pobject = nv_object(root);
+	if (ret)
+		return ret;
+
+
+	return nvkm_ramht_new(device, 0x1000, 0, instmem, &root->ramht);
+}
+
+void
+nv50_disp_root_dtor(struct nvkm_object *object)
+{
+	struct nv50_disp_root *root = (void *)object;
+	nvkm_ramht_del(&root->ramht);
+	nvkm_parent_destroy(&root->base);
+}
+
+static int
+nv50_disp_root_init(struct nvkm_object *object)
+{
+	struct nv50_disp *disp = (void *)object->engine;
+	struct nv50_disp_root *root = (void *)object;
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+	int ret, i;
+	u32 tmp;
+
+	ret = nvkm_parent_init(&root->base);
+	if (ret)
+		return ret;
+
+	/* The below segments of code copying values from one register to
+	 * another appear to inform EVO of the display capabilities or
+	 * something similar.  NFI what the 0x614004 caps are for..
+	 */
+	tmp = nvkm_rd32(device, 0x614004);
+	nvkm_wr32(device, 0x610184, tmp);
+
+	/* ... CRTC caps */
+	for (i = 0; i < disp->head.nr; i++) {
+		tmp = nvkm_rd32(device, 0x616100 + (i * 0x800));
+		nvkm_wr32(device, 0x610190 + (i * 0x10), tmp);
+		tmp = nvkm_rd32(device, 0x616104 + (i * 0x800));
+		nvkm_wr32(device, 0x610194 + (i * 0x10), tmp);
+		tmp = nvkm_rd32(device, 0x616108 + (i * 0x800));
+		nvkm_wr32(device, 0x610198 + (i * 0x10), tmp);
+		tmp = nvkm_rd32(device, 0x61610c + (i * 0x800));
+		nvkm_wr32(device, 0x61019c + (i * 0x10), tmp);
+	}
+
+	/* ... DAC caps */
+	for (i = 0; i < disp->dac.nr; i++) {
+		tmp = nvkm_rd32(device, 0x61a000 + (i * 0x800));
+		nvkm_wr32(device, 0x6101d0 + (i * 0x04), tmp);
+	}
+
+	/* ... SOR caps */
+	for (i = 0; i < disp->sor.nr; i++) {
+		tmp = nvkm_rd32(device, 0x61c000 + (i * 0x800));
+		nvkm_wr32(device, 0x6101e0 + (i * 0x04), tmp);
+	}
+
+	/* ... PIOR caps */
+	for (i = 0; i < disp->pior.nr; i++) {
+		tmp = nvkm_rd32(device, 0x61e000 + (i * 0x800));
+		nvkm_wr32(device, 0x6101f0 + (i * 0x04), tmp);
+	}
+
+	/* steal display away from vbios, or something like that */
+	if (nvkm_rd32(device, 0x610024) & 0x00000100) {
+		nvkm_wr32(device, 0x610024, 0x00000100);
+		nvkm_mask(device, 0x6194e8, 0x00000001, 0x00000000);
+		if (nvkm_msec(device, 2000,
+			if (!(nvkm_rd32(device, 0x6194e8) & 0x00000002))
+				break;
+		) < 0)
+			return -EBUSY;
+	}
+
+	/* point at display engine memory area (hash table, objects) */
+	nvkm_wr32(device, 0x610010, (root->ramht->gpuobj->addr >> 8) | 9);
+
+	/* enable supervisor interrupts, disable everything else */
+	nvkm_wr32(device, 0x61002c, 0x00000370);
+	nvkm_wr32(device, 0x610028, 0x00000000);
+	return 0;
+}
+
+static int
+nv50_disp_root_fini(struct nvkm_object *object, bool suspend)
+{
+	struct nv50_disp *disp = (void *)object->engine;
+	struct nv50_disp_root *root = (void *)object;
+	struct nvkm_device *device = disp->base.engine.subdev.device;
+
+	/* disable all interrupts */
+	nvkm_wr32(device, 0x610024, 0x00000000);
+	nvkm_wr32(device, 0x610020, 0x00000000);
+
+	return nvkm_parent_fini(&root->base, suspend);
+}
+
+struct nvkm_ofuncs
+nv50_disp_root_ofuncs = {
+	.ctor = nv50_disp_root_ctor,
+	.dtor = nv50_disp_root_dtor,
+	.init = nv50_disp_root_init,
+	.fini = nv50_disp_root_fini,
+	.mthd = nv50_disp_root_mthd,
+	.ntfy = nvkm_disp_ntfy,
+};
+
+struct nvkm_oclass
+nv50_disp_root_oclass[] = {
+	{ NV50_DISP, &nv50_disp_root_ofuncs },
+	{}
+};
+
+struct nvkm_oclass
+nv50_disp_sclass[] = {
+	{ NV50_DISP_CORE_CHANNEL_DMA, &nv50_disp_core_ofuncs.base },
+	{ NV50_DISP_BASE_CHANNEL_DMA, &nv50_disp_base_ofuncs.base },
+	{ NV50_DISP_OVERLAY_CHANNEL_DMA, &nv50_disp_ovly_ofuncs.base },
+	{ NV50_DISP_OVERLAY, &nv50_disp_oimm_ofuncs.base },
+	{ NV50_DISP_CURSOR, &nv50_disp_curs_ofuncs.base },
+	{}
+};
