commit 53b0cc46f27cfc2cadca609b503a7d92b5185a47
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Sep 4 15:57:11 2018 +1000

    drm/nouveau/disp/gm200-: enforce identity-mapped SOR assignment for LVDS/eDP panels
    
    Fixes eDP backlight issues on more recent laptops.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 32fa94a9773f..cbd33e87b799 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -275,6 +275,7 @@ nvkm_disp_oneinit(struct nvkm_engine *engine)
 	struct nvkm_outp *outp, *outt, *pair;
 	struct nvkm_conn *conn;
 	struct nvkm_head *head;
+	struct nvkm_ior *ior;
 	struct nvbios_connE connE;
 	struct dcb_output dcbE;
 	u8  hpd = 0, ver, hdr;
@@ -399,6 +400,19 @@ nvkm_disp_oneinit(struct nvkm_engine *engine)
 			return ret;
 	}
 
+	/* Enforce identity-mapped SOR assignment for panels, which have
+	 * certain bits (ie. backlight controls) wired to a specific SOR.
+	 */
+	list_for_each_entry(outp, &disp->outp, head) {
+		if (outp->conn->info.type == DCB_CONNECTOR_LVDS ||
+		    outp->conn->info.type == DCB_CONNECTOR_eDP) {
+			ior = nvkm_ior_find(disp, SOR, ffs(outp->info.or) - 1);
+			if (!WARN_ON(!ior))
+				ior->identity = true;
+			outp->identity = true;
+		}
+	}
+
 	i = 0;
 	list_for_each_entry(head, &disp->head, head)
 		i = max(i, head->id + 1);

commit bb3b0a422074606400e6aff216300bb4f012b22a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: initialise from the engine, rather than the user object
    
    Engines are initialised on an as-needed basis, so this results in the
    same behaviour, whilst allowing us to simplify things a bit.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 5b9d9c632aeb..32fa94a9773f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -220,6 +220,9 @@ nvkm_disp_fini(struct nvkm_engine *engine, bool suspend)
 	struct nvkm_conn *conn;
 	struct nvkm_outp *outp;
 
+	if (disp->func->fini)
+		disp->func->fini(disp);
+
 	list_for_each_entry(outp, &disp->outp, head) {
 		nvkm_outp_fini(outp);
 	}
@@ -237,6 +240,7 @@ nvkm_disp_init(struct nvkm_engine *engine)
 	struct nvkm_disp *disp = nvkm_disp(engine);
 	struct nvkm_conn *conn;
 	struct nvkm_outp *outp;
+	struct nvkm_ior *ior;
 
 	list_for_each_entry(conn, &disp->conn, head) {
 		nvkm_conn_init(conn);
@@ -246,6 +250,19 @@ nvkm_disp_init(struct nvkm_engine *engine)
 		nvkm_outp_init(outp);
 	}
 
+	if (disp->func->init) {
+		int ret = disp->func->init(disp);
+		if (ret)
+			return ret;
+	}
+
+	/* Set 'normal' (ie. when it's attached to a head) state for
+	 * each output resource to 'fully enabled'.
+	 */
+	list_for_each_entry(ior, &disp->ior, head) {
+		ior->func->power(ior, true, true, true, true, true);
+	}
+
 	return 0;
 }
 

commit 3b9ba66ab0e027e6d7a2b9b62cbb5cd547421ebd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/disp/nv50-: delay subunit construction until oneinit
    
    We should be reading registers to determine which subunits are really
    present on a given board, and this needs to be done after DEVINIT.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 93a75e5b2791..5b9d9c632aeb 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -376,6 +376,12 @@ nvkm_disp_oneinit(struct nvkm_engine *engine)
 	if (ret)
 		return ret;
 
+	if (disp->func->oneinit) {
+		ret = disp->func->oneinit(disp);
+		if (ret)
+			return ret;
+	}
+
 	i = 0;
 	list_for_each_entry(head, &disp->head, head)
 		i = max(i, head->id + 1);

commit df00d5da609f59022ee9aafdb4e2313aefeb6bda
Author: Rosen Penev <rosenp@gmail.com>
Date:   Tue Jul 25 17:21:43 2017 -0700

    drm/nouveau/disp: Silence DCB warnings.
    
    Most of these errors seem to be WFD related. Official documentation
    says dcb type 8 is reserved. It's probably used for WFD. Silence
    the warning in either case.
    
    Connector type 70 is stated to be a virtual connector for WiFi
    display. Since we know this, don't warn that we don't.
    
    Signed-off by: Rosen Penev <rosenp@gmail.com>
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 88582af8bd89..93a75e5b2791 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -285,6 +285,10 @@ nvkm_disp_oneinit(struct nvkm_engine *engine)
 		case DCB_OUTPUT_DP:
 			ret = nvkm_dp_new(disp, i, &dcbE, &outp);
 			break;
+		case DCB_OUTPUT_WFD:
+			/* No support for WFD yet. */
+			ret = -ENODEV;
+			continue;
 		default:
 			nvkm_warn(subdev, "dcb %d type %d unknown\n",
 				  i, dcbE.type);

commit 372aa73e20197d463fc8b34524c20b089a98b1c3
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 10 11:32:18 2017 +1000

    drm/nouveau/disp/nv04: avoid creation of output paths
    
    Fixes hitting WARN_ON() during initialisation of pre-NV50 GPUs, caused
    by the recent changes to support pad macro routing on GM20x.
    
    We currently don't use them here for older GPUs anyway.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index c7c84d34d97e..88582af8bd89 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -267,6 +267,8 @@ nvkm_disp_oneinit(struct nvkm_engine *engine)
 	/* Create output path objects for each VBIOS display path. */
 	i = -1;
 	while ((data = dcb_outp_parse(bios, ++i, &ver, &hdr, &dcbE))) {
+		if (ver < 0x40) /* No support for chipsets prior to NV50. */
+			break;
 		if (dcbE.type == DCB_OUTPUT_UNUSED)
 			continue;
 		if (dcbE.type == DCB_OUTPUT_EOL)

commit 3c66c87dc96b3113b5ee84604800c2aabbb48994
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp: remove hw-specific customisation of output paths
    
    All of the necessary hw-specific logic is now handled at the output
    resource level, so all of this can go away.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 24d2f325cbc5..c7c84d34d97e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -23,6 +23,7 @@
  */
 #include "priv.h"
 #include "conn.h"
+#include "dp.h"
 #include "head.h"
 #include "ior.h"
 #include "outp.h"
@@ -252,7 +253,8 @@ static int
 nvkm_disp_oneinit(struct nvkm_engine *engine)
 {
 	struct nvkm_disp *disp = nvkm_disp(engine);
-	struct nvkm_bios *bios = disp->engine.subdev.device->bios;
+	struct nvkm_subdev *subdev = &disp->engine.subdev;
+	struct nvkm_bios *bios = subdev->device->bios;
 	struct nvkm_outp *outp, *outt, *pair;
 	struct nvkm_conn *conn;
 	struct nvkm_head *head;
@@ -265,52 +267,38 @@ nvkm_disp_oneinit(struct nvkm_engine *engine)
 	/* Create output path objects for each VBIOS display path. */
 	i = -1;
 	while ((data = dcb_outp_parse(bios, ++i, &ver, &hdr, &dcbE))) {
-		const struct nvkm_disp_func_outp *outps;
-		int (*ctor)(struct nvkm_disp *, int, struct dcb_output *,
-			    struct nvkm_outp **);
-
 		if (dcbE.type == DCB_OUTPUT_UNUSED)
 			continue;
 		if (dcbE.type == DCB_OUTPUT_EOL)
 			break;
 		outp = NULL;
 
-		switch (dcbE.location) {
-		case 0: outps = &disp->func->outp.internal; break;
-		case 1: outps = &disp->func->outp.external; break;
-		default:
-			nvkm_warn(&disp->engine.subdev,
-				  "dcb %d locn %d unknown\n", i, dcbE.location);
-			continue;
-		}
-
 		switch (dcbE.type) {
-		case DCB_OUTPUT_ANALOG: ctor = outps->crt ; break;
-		case DCB_OUTPUT_TV    : ctor = outps->tv  ; break;
-		case DCB_OUTPUT_TMDS  : ctor = outps->tmds; break;
-		case DCB_OUTPUT_LVDS  : ctor = outps->lvds; break;
-		case DCB_OUTPUT_DP    : ctor = outps->dp  ; break;
+		case DCB_OUTPUT_ANALOG:
+		case DCB_OUTPUT_TV:
+		case DCB_OUTPUT_TMDS:
+		case DCB_OUTPUT_LVDS:
+			ret = nvkm_outp_new(disp, i, &dcbE, &outp);
+			break;
+		case DCB_OUTPUT_DP:
+			ret = nvkm_dp_new(disp, i, &dcbE, &outp);
+			break;
 		default:
-			nvkm_warn(&disp->engine.subdev,
-				  "dcb %d type %d unknown\n", i, dcbE.type);
+			nvkm_warn(subdev, "dcb %d type %d unknown\n",
+				  i, dcbE.type);
 			continue;
 		}
 
-		if (ctor)
-			ret = ctor(disp, i, &dcbE, &outp);
-		else
-			ret = -ENODEV;
-
 		if (ret) {
-			if (ret == -ENODEV) {
-				nvkm_debug(&disp->engine.subdev,
-					   "dcb %d %d/%d not supported\n",
-					   i, dcbE.location, dcbE.type);
+			if (outp) {
+				if (ret != -ENODEV)
+					OUTP_ERR(outp, "ctor failed: %d", ret);
+				else
+					OUTP_DBG(outp, "not supported");
+				nvkm_outp_del(&outp);
 				continue;
 			}
-			nvkm_error(&disp->engine.subdev,
-				   "failed to create outp %d\n", i);
-			nvkm_outp_del(&outp);
+			nvkm_error(subdev, "failed to create outp %d\n", i);
 			continue;
 		}
 

commit 78f1ad6f655847411b36bda2b2acbd0648a03d5c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp: introduce input/output resource abstraction
    
    In order to properly support the SOR -> SOR + pad macro separation
    that occurred with GM20x GPUs, we need to separate OR handling out
    of the output path code.
    
    This will be used as the base to support ORs (DAC, SOR, PIOR).
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 1c655c18097e..24d2f325cbc5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -24,6 +24,7 @@
 #include "priv.h"
 #include "conn.h"
 #include "head.h"
+#include "ior.h"
 #include "outp.h"
 
 #include <core/client.h>
@@ -414,6 +415,12 @@ nvkm_disp_dtor(struct nvkm_engine *engine)
 		nvkm_outp_del(&outp);
 	}
 
+	while (!list_empty(&disp->ior)) {
+		struct nvkm_ior *ior =
+			list_first_entry(&disp->ior, typeof(*ior), head);
+		nvkm_ior_del(&ior);
+	}
+
 	while (!list_empty(&disp->head)) {
 		struct nvkm_head *head =
 			list_first_entry(&disp->head, typeof(*head), head);
@@ -439,6 +446,7 @@ nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
 {
 	disp->func = func;
 	INIT_LIST_HEAD(&disp->head);
+	INIT_LIST_HEAD(&disp->ior);
 	INIT_LIST_HEAD(&disp->outp);
 	INIT_LIST_HEAD(&disp->conn);
 	return nvkm_engine_ctor(&nvkm_disp, device, index, true, &disp->engine);

commit 14187b007e646c0dbf0813d22f7733cf6eebc099
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp: move vblank_{get,put} methods into nvkm_head
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 8489d0246cb3..1c655c18097e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -38,17 +38,21 @@
 #include <nvif/unpack.h>
 
 static void
-nvkm_disp_vblank_fini(struct nvkm_event *event, int type, int head)
+nvkm_disp_vblank_fini(struct nvkm_event *event, int type, int id)
 {
 	struct nvkm_disp *disp = container_of(event, typeof(*disp), vblank);
-	disp->func->head.vblank_fini(disp, head);
+	struct nvkm_head *head = nvkm_head_find(disp, id);
+	if (head)
+		head->func->vblank_put(head);
 }
 
 static void
-nvkm_disp_vblank_init(struct nvkm_event *event, int type, int head)
+nvkm_disp_vblank_init(struct nvkm_event *event, int type, int id)
 {
 	struct nvkm_disp *disp = container_of(event, typeof(*disp), vblank);
-	disp->func->head.vblank_init(disp, head);
+	struct nvkm_head *head = nvkm_head_find(disp, id);
+	if (head)
+		head->func->vblank_get(head);
 }
 
 static int

commit a1c930789aa51b928f804c9186f9821efd070ce1
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/disp: introduce object to track per-head functions/state
    
    Primarily intended as a way to pass per-head state around during
    supervisor handling, and share logic between NV50/GF119.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 3e02a94c3072..8489d0246cb3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -23,6 +23,7 @@
  */
 #include "priv.h"
 #include "conn.h"
+#include "head.h"
 #include "outp.h"
 
 #include <core/client.h>
@@ -249,6 +250,7 @@ nvkm_disp_oneinit(struct nvkm_engine *engine)
 	struct nvkm_bios *bios = disp->engine.subdev.device->bios;
 	struct nvkm_outp *outp, *outt, *pair;
 	struct nvkm_conn *conn;
+	struct nvkm_head *head;
 	struct nvbios_connE connE;
 	struct dcb_output dcbE;
 	u8  hpd = 0, ver, hdr;
@@ -375,8 +377,11 @@ nvkm_disp_oneinit(struct nvkm_engine *engine)
 	if (ret)
 		return ret;
 
-	return nvkm_event_init(&nvkm_disp_vblank_func, 1,
-			       disp->head.nr, &disp->vblank);
+	i = 0;
+	list_for_each_entry(head, &disp->head, head)
+		i = max(i, head->id + 1);
+
+	return nvkm_event_init(&nvkm_disp_vblank_func, 1, i, &disp->vblank);
 }
 
 static void *
@@ -405,6 +410,12 @@ nvkm_disp_dtor(struct nvkm_engine *engine)
 		nvkm_outp_del(&outp);
 	}
 
+	while (!list_empty(&disp->head)) {
+		struct nvkm_head *head =
+			list_first_entry(&disp->head, typeof(*head), head);
+		nvkm_head_del(&head);
+	}
+
 	return data;
 }
 
@@ -420,10 +431,10 @@ nvkm_disp = {
 
 int
 nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
-	       int index, int heads, struct nvkm_disp *disp)
+	       int index, struct nvkm_disp *disp)
 {
 	disp->func = func;
-	disp->head.nr = heads;
+	INIT_LIST_HEAD(&disp->head);
 	INIT_LIST_HEAD(&disp->outp);
 	INIT_LIST_HEAD(&disp->conn);
 	return nvkm_engine_ctor(&nvkm_disp, device, index, true, &disp->engine);
@@ -431,9 +442,9 @@ nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
 
 int
 nvkm_disp_new_(const struct nvkm_disp_func *func, struct nvkm_device *device,
-	       int index, int heads, struct nvkm_disp **pdisp)
+	       int index, struct nvkm_disp **pdisp)
 {
 	if (!(*pdisp = kzalloc(sizeof(**pdisp), GFP_KERNEL)))
 		return -ENOMEM;
-	return nvkm_disp_ctor(func, device, index, heads, *pdisp);
+	return nvkm_disp_ctor(func, device, index, *pdisp);
 }

commit 4b2b42f8e910c65aceb8b2d12fe392a7b7955449
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/disp: delay output path / connector construction until oneinit()
    
    This is to allow hw-specific code to instantiate output resources first,
    so we can cull unsupported output paths based on them.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 34dc165394e1..3e02a94c3072 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -242,49 +242,11 @@ nvkm_disp_init(struct nvkm_engine *engine)
 	return 0;
 }
 
-static void *
-nvkm_disp_dtor(struct nvkm_engine *engine)
+static int
+nvkm_disp_oneinit(struct nvkm_engine *engine)
 {
 	struct nvkm_disp *disp = nvkm_disp(engine);
-	struct nvkm_conn *conn;
-	struct nvkm_outp *outp;
-	void *data = disp;
-
-	if (disp->func->dtor)
-		data = disp->func->dtor(disp);
-
-	nvkm_event_fini(&disp->vblank);
-	nvkm_event_fini(&disp->hpd);
-
-	while (!list_empty(&disp->outp)) {
-		outp = list_first_entry(&disp->outp, typeof(*outp), head);
-		list_del(&outp->head);
-		nvkm_outp_del(&outp);
-	}
-
-	while (!list_empty(&disp->conn)) {
-		conn = list_first_entry(&disp->conn, typeof(*conn), head);
-		list_del(&conn->head);
-		nvkm_conn_del(&conn);
-	}
-
-	return data;
-}
-
-static const struct nvkm_engine_func
-nvkm_disp = {
-	.dtor = nvkm_disp_dtor,
-	.init = nvkm_disp_init,
-	.fini = nvkm_disp_fini,
-	.intr = nvkm_disp_intr,
-	.base.sclass = nvkm_disp_class_get,
-};
-
-int
-nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
-	       int index, int heads, struct nvkm_disp *disp)
-{
-	struct nvkm_bios *bios = device->bios;
+	struct nvkm_bios *bios = disp->engine.subdev.device->bios;
 	struct nvkm_outp *outp, *outt, *pair;
 	struct nvkm_conn *conn;
 	struct nvbios_connE connE;
@@ -293,16 +255,7 @@ nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
 	u32 data;
 	int ret, i;
 
-	INIT_LIST_HEAD(&disp->outp);
-	INIT_LIST_HEAD(&disp->conn);
-	disp->func = func;
-	disp->head.nr = heads;
-
-	ret = nvkm_engine_ctor(&nvkm_disp, device, index, true, &disp->engine);
-	if (ret)
-		return ret;
-
-	/* create output objects for each display path in the vbios */
+	/* Create output path objects for each VBIOS display path. */
 	i = -1;
 	while ((data = dcb_outp_parse(bios, ++i, &ver, &hdr, &dcbE))) {
 		const struct nvkm_disp_func_outp *outps;
@@ -349,7 +302,7 @@ nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
 				continue;
 			}
 			nvkm_error(&disp->engine.subdev,
-				   "failed to create output %d\n", i);
+				   "failed to create outp %d\n", i);
 			nvkm_outp_del(&outp);
 			continue;
 		}
@@ -358,18 +311,18 @@ nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
 		hpd = max(hpd, (u8)(dcbE.connector + 1));
 	}
 
-	/* create connector objects based on the outputs we support */
+	/* Create connector objects based on available output paths. */
 	list_for_each_entry_safe(outp, outt, &disp->outp, head) {
-		/* bios data *should* give us the most useful information */
+		/* VBIOS data *should* give us the most useful information. */
 		data = nvbios_connEp(bios, outp->info.connector, &ver, &hdr,
 				     &connE);
 
-		/* no bios connector data... */
+		/* No bios connector data... */
 		if (!data) {
-			/* heuristic: anything with the same ccb index is
+			/* Heuristic: anything with the same ccb index is
 			 * considered to be on the same connector, any
 			 * output path without an associated ccb entry will
-			 * be put on its own connector
+			 * be put on its own connector.
 			 */
 			int ccb_index = outp->info.i2c_index;
 			if (ccb_index != 0xf) {
@@ -381,7 +334,7 @@ nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
 				}
 			}
 
-			/* connector shared with another output path */
+			/* Connector shared with another output path. */
 			if (outp->conn)
 				continue;
 
@@ -392,7 +345,7 @@ nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
 			i = outp->info.connector;
 		}
 
-		/* check that we haven't already created this connector */
+		/* Check that we haven't already created this connector. */
 		list_for_each_entry(conn, &disp->conn, head) {
 			if (conn->index == outp->info.connector) {
 				outp->conn = conn;
@@ -403,11 +356,11 @@ nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
 		if (outp->conn)
 			continue;
 
-		/* apparently we need to create a new one! */
+		/* Apparently we need to create a new one! */
 		ret = nvkm_conn_new(disp, i, &connE, &outp->conn);
 		if (ret) {
 			nvkm_error(&disp->engine.subdev,
-				   "failed to create output %d conn: %d\n",
+				   "failed to create outp %d conn: %d\n",
 				   outp->index, ret);
 			nvkm_conn_del(&outp->conn);
 			list_del(&outp->head);
@@ -422,11 +375,58 @@ nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
 	if (ret)
 		return ret;
 
-	ret = nvkm_event_init(&nvkm_disp_vblank_func, 1, heads, &disp->vblank);
-	if (ret)
-		return ret;
+	return nvkm_event_init(&nvkm_disp_vblank_func, 1,
+			       disp->head.nr, &disp->vblank);
+}
 
-	return 0;
+static void *
+nvkm_disp_dtor(struct nvkm_engine *engine)
+{
+	struct nvkm_disp *disp = nvkm_disp(engine);
+	struct nvkm_conn *conn;
+	struct nvkm_outp *outp;
+	void *data = disp;
+
+	if (disp->func->dtor)
+		data = disp->func->dtor(disp);
+
+	nvkm_event_fini(&disp->vblank);
+	nvkm_event_fini(&disp->hpd);
+
+	while (!list_empty(&disp->conn)) {
+		conn = list_first_entry(&disp->conn, typeof(*conn), head);
+		list_del(&conn->head);
+		nvkm_conn_del(&conn);
+	}
+
+	while (!list_empty(&disp->outp)) {
+		outp = list_first_entry(&disp->outp, typeof(*outp), head);
+		list_del(&outp->head);
+		nvkm_outp_del(&outp);
+	}
+
+	return data;
+}
+
+static const struct nvkm_engine_func
+nvkm_disp = {
+	.dtor = nvkm_disp_dtor,
+	.oneinit = nvkm_disp_oneinit,
+	.init = nvkm_disp_init,
+	.fini = nvkm_disp_fini,
+	.intr = nvkm_disp_intr,
+	.base.sclass = nvkm_disp_class_get,
+};
+
+int
+nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
+	       int index, int heads, struct nvkm_disp *disp)
+{
+	disp->func = func;
+	disp->head.nr = heads;
+	INIT_LIST_HEAD(&disp->outp);
+	INIT_LIST_HEAD(&disp->conn);
+	return nvkm_engine_ctor(&nvkm_disp, device, index, true, &disp->engine);
 }
 
 int

commit 981a8162e2f8282c90f6523324bb51720699bc6a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/disp: s/nvkm_connector/nvkm_conn/
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 53309214718b..34dc165394e1 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -210,7 +210,7 @@ static int
 nvkm_disp_fini(struct nvkm_engine *engine, bool suspend)
 {
 	struct nvkm_disp *disp = nvkm_disp(engine);
-	struct nvkm_connector *conn;
+	struct nvkm_conn *conn;
 	struct nvkm_outp *outp;
 
 	list_for_each_entry(outp, &disp->outp, head) {
@@ -218,7 +218,7 @@ nvkm_disp_fini(struct nvkm_engine *engine, bool suspend)
 	}
 
 	list_for_each_entry(conn, &disp->conn, head) {
-		nvkm_connector_fini(conn);
+		nvkm_conn_fini(conn);
 	}
 
 	return 0;
@@ -228,11 +228,11 @@ static int
 nvkm_disp_init(struct nvkm_engine *engine)
 {
 	struct nvkm_disp *disp = nvkm_disp(engine);
-	struct nvkm_connector *conn;
+	struct nvkm_conn *conn;
 	struct nvkm_outp *outp;
 
 	list_for_each_entry(conn, &disp->conn, head) {
-		nvkm_connector_init(conn);
+		nvkm_conn_init(conn);
 	}
 
 	list_for_each_entry(outp, &disp->outp, head) {
@@ -246,7 +246,7 @@ static void *
 nvkm_disp_dtor(struct nvkm_engine *engine)
 {
 	struct nvkm_disp *disp = nvkm_disp(engine);
-	struct nvkm_connector *conn;
+	struct nvkm_conn *conn;
 	struct nvkm_outp *outp;
 	void *data = disp;
 
@@ -265,7 +265,7 @@ nvkm_disp_dtor(struct nvkm_engine *engine)
 	while (!list_empty(&disp->conn)) {
 		conn = list_first_entry(&disp->conn, typeof(*conn), head);
 		list_del(&conn->head);
-		nvkm_connector_del(&conn);
+		nvkm_conn_del(&conn);
 	}
 
 	return data;
@@ -286,7 +286,7 @@ nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
 {
 	struct nvkm_bios *bios = device->bios;
 	struct nvkm_outp *outp, *outt, *pair;
-	struct nvkm_connector *conn;
+	struct nvkm_conn *conn;
 	struct nvbios_connE connE;
 	struct dcb_output dcbE;
 	u8  hpd = 0, ver, hdr;
@@ -404,12 +404,12 @@ nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
 			continue;
 
 		/* apparently we need to create a new one! */
-		ret = nvkm_connector_new(disp, i, &connE, &outp->conn);
+		ret = nvkm_conn_new(disp, i, &connE, &outp->conn);
 		if (ret) {
 			nvkm_error(&disp->engine.subdev,
 				   "failed to create output %d conn: %d\n",
 				   outp->index, ret);
-			nvkm_connector_del(&outp->conn);
+			nvkm_conn_del(&outp->conn);
 			list_del(&outp->head);
 			nvkm_outp_del(&outp);
 			continue;

commit d7ce92e27303082f00cf0976d673f4cc0a5f1c5f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/disp: rename nvkm_output to nvkm_outp
    
    This isn't technically "output", but, "display/output path".
    
    Not all users of nvkm_output have been changed here.  The remaining
    ones belong to code that's disappearing in upcoming commits.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 1efe91b1e22b..53309214718b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -96,7 +96,7 @@ nvkm_disp_hpd_ctor(struct nvkm_object *object, void *data, u32 size,
 	union {
 		struct nvif_notify_conn_req_v0 v0;
 	} *req = data;
-	struct nvkm_output *outp;
+	struct nvkm_outp *outp;
 	int ret = -ENOSYS;
 
 	if (!(ret = nvif_unpack(ret, &data, &size, req->v0, 0, 0, false))) {
@@ -211,10 +211,10 @@ nvkm_disp_fini(struct nvkm_engine *engine, bool suspend)
 {
 	struct nvkm_disp *disp = nvkm_disp(engine);
 	struct nvkm_connector *conn;
-	struct nvkm_output *outp;
+	struct nvkm_outp *outp;
 
 	list_for_each_entry(outp, &disp->outp, head) {
-		nvkm_output_fini(outp);
+		nvkm_outp_fini(outp);
 	}
 
 	list_for_each_entry(conn, &disp->conn, head) {
@@ -229,14 +229,14 @@ nvkm_disp_init(struct nvkm_engine *engine)
 {
 	struct nvkm_disp *disp = nvkm_disp(engine);
 	struct nvkm_connector *conn;
-	struct nvkm_output *outp;
+	struct nvkm_outp *outp;
 
 	list_for_each_entry(conn, &disp->conn, head) {
 		nvkm_connector_init(conn);
 	}
 
 	list_for_each_entry(outp, &disp->outp, head) {
-		nvkm_output_init(outp);
+		nvkm_outp_init(outp);
 	}
 
 	return 0;
@@ -247,7 +247,7 @@ nvkm_disp_dtor(struct nvkm_engine *engine)
 {
 	struct nvkm_disp *disp = nvkm_disp(engine);
 	struct nvkm_connector *conn;
-	struct nvkm_output *outp;
+	struct nvkm_outp *outp;
 	void *data = disp;
 
 	if (disp->func->dtor)
@@ -259,7 +259,7 @@ nvkm_disp_dtor(struct nvkm_engine *engine)
 	while (!list_empty(&disp->outp)) {
 		outp = list_first_entry(&disp->outp, typeof(*outp), head);
 		list_del(&outp->head);
-		nvkm_output_del(&outp);
+		nvkm_outp_del(&outp);
 	}
 
 	while (!list_empty(&disp->conn)) {
@@ -285,7 +285,7 @@ nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
 	       int index, int heads, struct nvkm_disp *disp)
 {
 	struct nvkm_bios *bios = device->bios;
-	struct nvkm_output *outp, *outt, *pair;
+	struct nvkm_outp *outp, *outt, *pair;
 	struct nvkm_connector *conn;
 	struct nvbios_connE connE;
 	struct dcb_output dcbE;
@@ -307,7 +307,7 @@ nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
 	while ((data = dcb_outp_parse(bios, ++i, &ver, &hdr, &dcbE))) {
 		const struct nvkm_disp_func_outp *outps;
 		int (*ctor)(struct nvkm_disp *, int, struct dcb_output *,
-			    struct nvkm_output **);
+			    struct nvkm_outp **);
 
 		if (dcbE.type == DCB_OUTPUT_UNUSED)
 			continue;
@@ -350,7 +350,7 @@ nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
 			}
 			nvkm_error(&disp->engine.subdev,
 				   "failed to create output %d\n", i);
-			nvkm_output_del(&outp);
+			nvkm_outp_del(&outp);
 			continue;
 		}
 
@@ -411,7 +411,7 @@ nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
 				   outp->index, ret);
 			nvkm_connector_del(&outp->conn);
 			list_del(&outp->head);
-			nvkm_output_del(&outp);
+			nvkm_outp_del(&outp);
 			continue;
 		}
 

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 785fa76d0fbf..1efe91b1e22b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -298,8 +298,7 @@ nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
 	disp->func = func;
 	disp->head.nr = heads;
 
-	ret = nvkm_engine_ctor(&nvkm_disp, device, index, 0,
-			       true, &disp->engine);
+	ret = nvkm_engine_ctor(&nvkm_disp, device, index, true, &disp->engine);
 	if (ret)
 		return ret;
 

commit f01c4e682c941ba70e0ebec44db754844a1b9b82
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon Nov 9 09:21:27 2015 +1000

    drm/nouveau/nvif: modify nvif_unvers/nvif_unpack macros to be more obvious
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 9ac1638ae0ce..785fa76d0fbf 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -59,9 +59,9 @@ nvkm_disp_vblank_ctor(struct nvkm_object *object, void *data, u32 size,
 	union {
 		struct nvif_notify_head_req_v0 v0;
 	} *req = data;
-	int ret;
+	int ret = -ENOSYS;
 
-	if (nvif_unpack(req->v0, 0, 0, false)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, req->v0, 0, 0, false))) {
 		notify->size = sizeof(struct nvif_notify_head_rep_v0);
 		if (ret = -ENXIO, req->v0.head <= disp->vblank.index_nr) {
 			notify->types = 1;
@@ -97,9 +97,9 @@ nvkm_disp_hpd_ctor(struct nvkm_object *object, void *data, u32 size,
 		struct nvif_notify_conn_req_v0 v0;
 	} *req = data;
 	struct nvkm_output *outp;
-	int ret;
+	int ret = -ENOSYS;
 
-	if (nvif_unpack(req->v0, 0, 0, false)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, req->v0, 0, 0, false))) {
 		notify->size = sizeof(struct nvif_notify_conn_rep_v0);
 		list_for_each_entry(outp, &disp->outp, head) {
 			if (ret = -ENXIO, outp->conn->index == req->v0.conn) {

commit 7568b106718165feacdf411f1b8f95ae4263456a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Nov 8 10:44:19 2015 +1000

    drm/nouveau/nvif: split out display interface definitions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 44b67719f64d..9ac1638ae0ce 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -32,6 +32,7 @@
 #include <subdev/bios/dcb.h>
 
 #include <nvif/class.h>
+#include <nvif/cl0046.h>
 #include <nvif/event.h>
 #include <nvif/unpack.h>
 

commit 70aa8670e5229766f12c4b818a68aa61913df0b6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/disp: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 165f9d47d11d..44b67719f64d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -35,7 +35,21 @@
 #include <nvif/event.h>
 #include <nvif/unpack.h>
 
-int
+static void
+nvkm_disp_vblank_fini(struct nvkm_event *event, int type, int head)
+{
+	struct nvkm_disp *disp = container_of(event, typeof(*disp), vblank);
+	disp->func->head.vblank_fini(disp, head);
+}
+
+static void
+nvkm_disp_vblank_init(struct nvkm_event *event, int type, int head)
+{
+	struct nvkm_disp *disp = container_of(event, typeof(*disp), vblank);
+	disp->func->head.vblank_init(disp, head);
+}
+
+static int
 nvkm_disp_vblank_ctor(struct nvkm_object *object, void *data, u32 size,
 		      struct nvkm_notify *notify)
 {
@@ -58,6 +72,13 @@ nvkm_disp_vblank_ctor(struct nvkm_object *object, void *data, u32 size,
 	return ret;
 }
 
+static const struct nvkm_event_func
+nvkm_disp_vblank_func = {
+	.ctor = nvkm_disp_vblank_ctor,
+	.init = nvkm_disp_vblank_init,
+	.fini = nvkm_disp_vblank_fini,
+};
+
 void
 nvkm_disp_vblank(struct nvkm_disp *disp, int head)
 {
@@ -102,7 +123,7 @@ nvkm_disp_hpd_func = {
 int
 nvkm_disp_ntfy(struct nvkm_object *object, u32 type, struct nvkm_event **event)
 {
-	struct nvkm_disp *disp = (void *)object->engine;
+	struct nvkm_disp *disp = nvkm_disp(object->engine);
 	switch (type) {
 	case NV04_DISP_NTFY_VBLANK:
 		*event = &disp->vblank;
@@ -168,18 +189,26 @@ nvkm_disp_class_get(struct nvkm_oclass *oclass, int index,
 {
 	struct nvkm_disp *disp = nvkm_disp(oclass->engine);
 	if (index == 0) {
-		oclass->base = disp->func->root->base;
-		oclass->engn = disp->func->root;
+		const struct nvkm_disp_oclass *root = disp->func->root(disp);
+		oclass->base = root->base;
+		oclass->engn = root;
 		*class = &nvkm_disp_sclass;
 		return 0;
 	}
 	return 1;
 }
 
-int
-_nvkm_disp_fini(struct nvkm_object *object, bool suspend)
+static void
+nvkm_disp_intr(struct nvkm_engine *engine)
+{
+	struct nvkm_disp *disp = nvkm_disp(engine);
+	disp->func->intr(disp);
+}
+
+static int
+nvkm_disp_fini(struct nvkm_engine *engine, bool suspend)
 {
-	struct nvkm_disp *disp = (void *)object;
+	struct nvkm_disp *disp = nvkm_disp(engine);
 	struct nvkm_connector *conn;
 	struct nvkm_output *outp;
 
@@ -191,20 +220,15 @@ _nvkm_disp_fini(struct nvkm_object *object, bool suspend)
 		nvkm_connector_fini(conn);
 	}
 
-	return nvkm_engine_fini_old(&disp->engine, suspend);
+	return 0;
 }
 
-int
-_nvkm_disp_init(struct nvkm_object *object)
+static int
+nvkm_disp_init(struct nvkm_engine *engine)
 {
-	struct nvkm_disp *disp = (void *)object;
+	struct nvkm_disp *disp = nvkm_disp(engine);
 	struct nvkm_connector *conn;
 	struct nvkm_output *outp;
-	int ret;
-
-	ret = nvkm_engine_init_old(&disp->engine);
-	if (ret)
-		return ret;
 
 	list_for_each_entry(conn, &disp->conn, head) {
 		nvkm_connector_init(conn);
@@ -214,15 +238,19 @@ _nvkm_disp_init(struct nvkm_object *object)
 		nvkm_output_init(outp);
 	}
 
-	return ret;
+	return 0;
 }
 
-void
-_nvkm_disp_dtor(struct nvkm_object *object)
+static void *
+nvkm_disp_dtor(struct nvkm_engine *engine)
 {
-	struct nvkm_disp *disp = (void *)object;
+	struct nvkm_disp *disp = nvkm_disp(engine);
 	struct nvkm_connector *conn;
 	struct nvkm_output *outp;
+	void *data = disp;
+
+	if (disp->func->dtor)
+		data = disp->func->dtor(disp);
 
 	nvkm_event_fini(&disp->vblank);
 	nvkm_event_fini(&disp->hpd);
@@ -239,40 +267,40 @@ _nvkm_disp_dtor(struct nvkm_object *object)
 		nvkm_connector_del(&conn);
 	}
 
-	nvkm_engine_destroy(&disp->engine);
+	return data;
 }
 
 static const struct nvkm_engine_func
 nvkm_disp = {
+	.dtor = nvkm_disp_dtor,
+	.init = nvkm_disp_init,
+	.fini = nvkm_disp_fini,
+	.intr = nvkm_disp_intr,
 	.base.sclass = nvkm_disp_class_get,
 };
 
 int
-nvkm_disp_create_(struct nvkm_object *parent, struct nvkm_object *engine,
-		  struct nvkm_oclass *oclass, int heads, const char *intname,
-		  const char *extname, int length, void **pobject)
+nvkm_disp_ctor(const struct nvkm_disp_func *func, struct nvkm_device *device,
+	       int index, int heads, struct nvkm_disp *disp)
 {
-	struct nvkm_disp_impl *impl = (void *)oclass;
-	struct nvkm_device *device = (void *)parent;
 	struct nvkm_bios *bios = device->bios;
-	struct nvkm_disp *disp;
-	struct nvkm_connector *conn;
 	struct nvkm_output *outp, *outt, *pair;
+	struct nvkm_connector *conn;
 	struct nvbios_connE connE;
 	struct dcb_output dcbE;
 	u8  hpd = 0, ver, hdr;
 	u32 data;
 	int ret, i;
 
-	ret = nvkm_engine_create_(parent, engine, oclass, true, intname,
-				  extname, length, pobject);
-	disp = *pobject;
-	if (ret)
-		return ret;
-
-	disp->engine.func = &nvkm_disp;
 	INIT_LIST_HEAD(&disp->outp);
 	INIT_LIST_HEAD(&disp->conn);
+	disp->func = func;
+	disp->head.nr = heads;
+
+	ret = nvkm_engine_ctor(&nvkm_disp, device, index, 0,
+			       true, &disp->engine);
+	if (ret)
+		return ret;
 
 	/* create output objects for each display path in the vbios */
 	i = -1;
@@ -288,8 +316,8 @@ nvkm_disp_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		outp = NULL;
 
 		switch (dcbE.location) {
-		case 0: outps = &impl->outp.internal; break;
-		case 1: outps = &impl->outp.external; break;
+		case 0: outps = &disp->func->outp.internal; break;
+		case 1: outps = &disp->func->outp.external; break;
 		default:
 			nvkm_warn(&disp->engine.subdev,
 				  "dcb %d locn %d unknown\n", i, dcbE.location);
@@ -394,9 +422,18 @@ nvkm_disp_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	ret = nvkm_event_init(impl->vblank, 1, heads, &disp->vblank);
+	ret = nvkm_event_init(&nvkm_disp_vblank_func, 1, heads, &disp->vblank);
 	if (ret)
 		return ret;
 
 	return 0;
 }
+
+int
+nvkm_disp_new_(const struct nvkm_disp_func *func, struct nvkm_device *device,
+	       int index, int heads, struct nvkm_disp **pdisp)
+{
+	if (!(*pdisp = kzalloc(sizeof(**pdisp), GFP_KERNEL)))
+		return -ENOMEM;
+	return nvkm_disp_ctor(func, device, index, heads, *pdisp);
+}

commit 0ce41e3c66ca8958dec427f1c46f64efdda90f30
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/disp: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index fea8516220f3..165f9d47d11d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -25,7 +25,9 @@
 #include "conn.h"
 #include "outp.h"
 
+#include <core/client.h>
 #include <core/notify.h>
+#include <core/oproxy.h>
 #include <subdev/bios.h>
 #include <subdev/bios/dcb.h>
 
@@ -114,6 +116,66 @@ nvkm_disp_ntfy(struct nvkm_object *object, u32 type, struct nvkm_event **event)
 	return -EINVAL;
 }
 
+static void
+nvkm_disp_class_del(struct nvkm_oproxy *oproxy)
+{
+	struct nvkm_disp *disp = nvkm_disp(oproxy->base.engine);
+	mutex_lock(&disp->engine.subdev.mutex);
+	if (disp->client == oproxy)
+		disp->client = NULL;
+	mutex_unlock(&disp->engine.subdev.mutex);
+}
+
+static const struct nvkm_oproxy_func
+nvkm_disp_class = {
+	.dtor[1] = nvkm_disp_class_del,
+};
+
+static int
+nvkm_disp_class_new(struct nvkm_device *device,
+		    const struct nvkm_oclass *oclass, void *data, u32 size,
+		    struct nvkm_object **pobject)
+{
+	const struct nvkm_disp_oclass *sclass = oclass->engn;
+	struct nvkm_disp *disp = nvkm_disp(oclass->engine);
+	struct nvkm_oproxy *oproxy;
+	int ret;
+
+	ret = nvkm_oproxy_new_(&nvkm_disp_class, oclass, &oproxy);
+	if (ret)
+		return ret;
+	*pobject = &oproxy->base;
+
+	mutex_lock(&disp->engine.subdev.mutex);
+	if (disp->client) {
+		mutex_unlock(&disp->engine.subdev.mutex);
+		return -EBUSY;
+	}
+	disp->client = oproxy;
+	mutex_unlock(&disp->engine.subdev.mutex);
+
+	return sclass->ctor(disp, oclass, data, size, &oproxy->object);
+}
+
+static const struct nvkm_device_oclass
+nvkm_disp_sclass = {
+	.ctor = nvkm_disp_class_new,
+};
+
+static int
+nvkm_disp_class_get(struct nvkm_oclass *oclass, int index,
+		    const struct nvkm_device_oclass **class)
+{
+	struct nvkm_disp *disp = nvkm_disp(oclass->engine);
+	if (index == 0) {
+		oclass->base = disp->func->root->base;
+		oclass->engn = disp->func->root;
+		*class = &nvkm_disp_sclass;
+		return 0;
+	}
+	return 1;
+}
+
 int
 _nvkm_disp_fini(struct nvkm_object *object, bool suspend)
 {
@@ -180,6 +242,11 @@ _nvkm_disp_dtor(struct nvkm_object *object)
 	nvkm_engine_destroy(&disp->engine);
 }
 
+static const struct nvkm_engine_func
+nvkm_disp = {
+	.base.sclass = nvkm_disp_class_get,
+};
+
 int
 nvkm_disp_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		  struct nvkm_oclass *oclass, int heads, const char *intname,
@@ -203,6 +270,7 @@ nvkm_disp_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
+	disp->engine.func = &nvkm_disp;
 	INIT_LIST_HEAD(&disp->outp);
 	INIT_LIST_HEAD(&disp->conn);
 

commit 89c651e2213a148d19407109051abbf81328a4a8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/engine: rename some functions to avoid upcoming conflicts
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 7e6744536fa0..fea8516220f3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -129,7 +129,7 @@ _nvkm_disp_fini(struct nvkm_object *object, bool suspend)
 		nvkm_connector_fini(conn);
 	}
 
-	return nvkm_engine_fini(&disp->engine, suspend);
+	return nvkm_engine_fini_old(&disp->engine, suspend);
 }
 
 int
@@ -140,7 +140,7 @@ _nvkm_disp_init(struct nvkm_object *object)
 	struct nvkm_output *outp;
 	int ret;
 
-	ret = nvkm_engine_init(&disp->engine);
+	ret = nvkm_engine_init_old(&disp->engine);
 	if (ret)
 		return ret;
 

commit f2c906fc0cf1657e4164e09ae6061534eebd5430
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:15 2015 +1000

    drm/nouveau/disp: transition outp/conn away from being based on nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 2090e90d6770..7e6744536fa0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -118,29 +118,25 @@ int
 _nvkm_disp_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nvkm_disp *disp = (void *)object;
+	struct nvkm_connector *conn;
 	struct nvkm_output *outp;
-	int ret;
 
 	list_for_each_entry(outp, &disp->outp, head) {
-		ret = nv_ofuncs(outp)->fini(nv_object(outp), suspend);
-		if (ret && suspend)
-			goto fail_outp;
+		nvkm_output_fini(outp);
 	}
 
-	return nvkm_engine_fini(&disp->engine, suspend);
-
-fail_outp:
-	list_for_each_entry_continue_reverse(outp, &disp->outp, head) {
-		nv_ofuncs(outp)->init(nv_object(outp));
+	list_for_each_entry(conn, &disp->conn, head) {
+		nvkm_connector_fini(conn);
 	}
 
-	return ret;
+	return nvkm_engine_fini(&disp->engine, suspend);
 }
 
 int
 _nvkm_disp_init(struct nvkm_object *object)
 {
 	struct nvkm_disp *disp = (void *)object;
+	struct nvkm_connector *conn;
 	struct nvkm_output *outp;
 	int ret;
 
@@ -148,17 +144,12 @@ _nvkm_disp_init(struct nvkm_object *object)
 	if (ret)
 		return ret;
 
-	list_for_each_entry(outp, &disp->outp, head) {
-		ret = nv_ofuncs(outp)->init(nv_object(outp));
-		if (ret)
-			goto fail_outp;
+	list_for_each_entry(conn, &disp->conn, head) {
+		nvkm_connector_init(conn);
 	}
 
-	return ret;
-
-fail_outp:
-	list_for_each_entry_continue_reverse(outp, &disp->outp, head) {
-		nv_ofuncs(outp)->fini(nv_object(outp), false);
+	list_for_each_entry(outp, &disp->outp, head) {
+		nvkm_output_init(outp);
 	}
 
 	return ret;
@@ -168,15 +159,22 @@ void
 _nvkm_disp_dtor(struct nvkm_object *object)
 {
 	struct nvkm_disp *disp = (void *)object;
-	struct nvkm_output *outp, *outt;
+	struct nvkm_connector *conn;
+	struct nvkm_output *outp;
 
 	nvkm_event_fini(&disp->vblank);
 	nvkm_event_fini(&disp->hpd);
 
-	if (disp->outp.next) {
-		list_for_each_entry_safe(outp, outt, &disp->outp, head) {
-			nvkm_object_ref(NULL, (struct nvkm_object **)&outp);
-		}
+	while (!list_empty(&disp->outp)) {
+		outp = list_first_entry(&disp->outp, typeof(*outp), head);
+		list_del(&outp->head);
+		nvkm_output_del(&outp);
+	}
+
+	while (!list_empty(&disp->conn)) {
+		conn = list_first_entry(&disp->conn, typeof(*conn), head);
+		list_del(&conn->head);
+		nvkm_connector_del(&conn);
 	}
 
 	nvkm_engine_destroy(&disp->engine);
@@ -188,10 +186,12 @@ nvkm_disp_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		  const char *extname, int length, void **pobject)
 {
 	struct nvkm_disp_impl *impl = (void *)oclass;
-	struct nvkm_bios *bios = nvkm_bios(parent);
+	struct nvkm_device *device = (void *)parent;
+	struct nvkm_bios *bios = device->bios;
 	struct nvkm_disp *disp;
-	struct nvkm_oclass **sclass;
-	struct nvkm_object *object;
+	struct nvkm_connector *conn;
+	struct nvkm_output *outp, *outt, *pair;
+	struct nvbios_connE connE;
 	struct dcb_output dcbE;
 	u8  hpd = 0, ver, hdr;
 	u32 data;
@@ -204,30 +204,124 @@ nvkm_disp_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		return ret;
 
 	INIT_LIST_HEAD(&disp->outp);
+	INIT_LIST_HEAD(&disp->conn);
 
 	/* create output objects for each display path in the vbios */
 	i = -1;
 	while ((data = dcb_outp_parse(bios, ++i, &ver, &hdr, &dcbE))) {
+		const struct nvkm_disp_func_outp *outps;
+		int (*ctor)(struct nvkm_disp *, int, struct dcb_output *,
+			    struct nvkm_output **);
+
 		if (dcbE.type == DCB_OUTPUT_UNUSED)
 			continue;
 		if (dcbE.type == DCB_OUTPUT_EOL)
 			break;
-		data = dcbE.location << 4 | dcbE.type;
+		outp = NULL;
+
+		switch (dcbE.location) {
+		case 0: outps = &impl->outp.internal; break;
+		case 1: outps = &impl->outp.external; break;
+		default:
+			nvkm_warn(&disp->engine.subdev,
+				  "dcb %d locn %d unknown\n", i, dcbE.location);
+			continue;
+		}
 
-		oclass = nvkm_output_oclass;
-		sclass = impl->outp;
-		while (sclass && sclass[0]) {
-			if (sclass[0]->handle == data) {
-				oclass = sclass[0];
-				break;
+		switch (dcbE.type) {
+		case DCB_OUTPUT_ANALOG: ctor = outps->crt ; break;
+		case DCB_OUTPUT_TV    : ctor = outps->tv  ; break;
+		case DCB_OUTPUT_TMDS  : ctor = outps->tmds; break;
+		case DCB_OUTPUT_LVDS  : ctor = outps->lvds; break;
+		case DCB_OUTPUT_DP    : ctor = outps->dp  ; break;
+		default:
+			nvkm_warn(&disp->engine.subdev,
+				  "dcb %d type %d unknown\n", i, dcbE.type);
+			continue;
+		}
+
+		if (ctor)
+			ret = ctor(disp, i, &dcbE, &outp);
+		else
+			ret = -ENODEV;
+
+		if (ret) {
+			if (ret == -ENODEV) {
+				nvkm_debug(&disp->engine.subdev,
+					   "dcb %d %d/%d not supported\n",
+					   i, dcbE.location, dcbE.type);
+				continue;
 			}
-			sclass++;
+			nvkm_error(&disp->engine.subdev,
+				   "failed to create output %d\n", i);
+			nvkm_output_del(&outp);
+			continue;
 		}
 
-		nvkm_object_ctor(*pobject, NULL, oclass, &dcbE, i, &object);
+		list_add_tail(&outp->head, &disp->outp);
 		hpd = max(hpd, (u8)(dcbE.connector + 1));
 	}
 
+	/* create connector objects based on the outputs we support */
+	list_for_each_entry_safe(outp, outt, &disp->outp, head) {
+		/* bios data *should* give us the most useful information */
+		data = nvbios_connEp(bios, outp->info.connector, &ver, &hdr,
+				     &connE);
+
+		/* no bios connector data... */
+		if (!data) {
+			/* heuristic: anything with the same ccb index is
+			 * considered to be on the same connector, any
+			 * output path without an associated ccb entry will
+			 * be put on its own connector
+			 */
+			int ccb_index = outp->info.i2c_index;
+			if (ccb_index != 0xf) {
+				list_for_each_entry(pair, &disp->outp, head) {
+					if (pair->info.i2c_index == ccb_index) {
+						outp->conn = pair->conn;
+						break;
+					}
+				}
+			}
+
+			/* connector shared with another output path */
+			if (outp->conn)
+				continue;
+
+			memset(&connE, 0x00, sizeof(connE));
+			connE.type = DCB_CONNECTOR_NONE;
+			i = -1;
+		} else {
+			i = outp->info.connector;
+		}
+
+		/* check that we haven't already created this connector */
+		list_for_each_entry(conn, &disp->conn, head) {
+			if (conn->index == outp->info.connector) {
+				outp->conn = conn;
+				break;
+			}
+		}
+
+		if (outp->conn)
+			continue;
+
+		/* apparently we need to create a new one! */
+		ret = nvkm_connector_new(disp, i, &connE, &outp->conn);
+		if (ret) {
+			nvkm_error(&disp->engine.subdev,
+				   "failed to create output %d conn: %d\n",
+				   outp->index, ret);
+			nvkm_connector_del(&outp->conn);
+			list_del(&outp->head);
+			nvkm_output_del(&outp);
+			continue;
+		}
+
+		list_add_tail(&outp->conn->head, &disp->conn);
+	}
+
 	ret = nvkm_event_init(&nvkm_disp_hpd_func, 3, hpd, &disp->hpd);
 	if (ret)
 		return ret;

commit fd166a1832db138f22ad95eacd0879af30742f57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/disp: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index 23d1b5c0dc16..2090e90d6770 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -127,7 +127,7 @@ _nvkm_disp_fini(struct nvkm_object *object, bool suspend)
 			goto fail_outp;
 	}
 
-	return nvkm_engine_fini(&disp->base, suspend);
+	return nvkm_engine_fini(&disp->engine, suspend);
 
 fail_outp:
 	list_for_each_entry_continue_reverse(outp, &disp->outp, head) {
@@ -144,7 +144,7 @@ _nvkm_disp_init(struct nvkm_object *object)
 	struct nvkm_output *outp;
 	int ret;
 
-	ret = nvkm_engine_init(&disp->base);
+	ret = nvkm_engine_init(&disp->engine);
 	if (ret)
 		return ret;
 
@@ -179,7 +179,7 @@ _nvkm_disp_dtor(struct nvkm_object *object)
 		}
 	}
 
-	nvkm_engine_destroy(&disp->base);
+	nvkm_engine_destroy(&disp->engine);
 }
 
 int

commit 878da15adb5ddce57339b87685d8b4630e60085f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:24:57 2015 +1000

    drm/nouveau/disp: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
index c8a5f810e537..23d1b5c0dc16 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -21,21 +21,23 @@
  *
  * Authors: Ben Skeggs
  */
+#include "priv.h"
+#include "conn.h"
+#include "outp.h"
+
+#include <core/notify.h>
+#include <subdev/bios.h>
+#include <subdev/bios/dcb.h>
 
-#include <core/os.h>
-#include <nvif/unpack.h>
 #include <nvif/class.h>
 #include <nvif/event.h>
-
-#include "priv.h"
-#include "outp.h"
-#include "conn.h"
+#include <nvif/unpack.h>
 
 int
-nouveau_disp_vblank_ctor(struct nouveau_object *object, void *data, u32 size,
-			 struct nvkm_notify *notify)
+nvkm_disp_vblank_ctor(struct nvkm_object *object, void *data, u32 size,
+		      struct nvkm_notify *notify)
 {
-	struct nouveau_disp *disp =
+	struct nvkm_disp *disp =
 		container_of(notify->event, typeof(*disp), vblank);
 	union {
 		struct nvif_notify_head_req_v0 v0;
@@ -55,17 +57,17 @@ nouveau_disp_vblank_ctor(struct nouveau_object *object, void *data, u32 size,
 }
 
 void
-nouveau_disp_vblank(struct nouveau_disp *disp, int head)
+nvkm_disp_vblank(struct nvkm_disp *disp, int head)
 {
 	struct nvif_notify_head_rep_v0 rep = {};
 	nvkm_event_send(&disp->vblank, 1, head, &rep, sizeof(rep));
 }
 
 static int
-nouveau_disp_hpd_ctor(struct nouveau_object *object, void *data, u32 size,
-		      struct nvkm_notify *notify)
+nvkm_disp_hpd_ctor(struct nvkm_object *object, void *data, u32 size,
+		   struct nvkm_notify *notify)
 {
-	struct nouveau_disp *disp =
+	struct nvkm_disp *disp =
 		container_of(notify->event, typeof(*disp), hpd);
 	union {
 		struct nvif_notify_conn_req_v0 v0;
@@ -91,15 +93,14 @@ nouveau_disp_hpd_ctor(struct nouveau_object *object, void *data, u32 size,
 }
 
 static const struct nvkm_event_func
-nouveau_disp_hpd_func = {
-	.ctor = nouveau_disp_hpd_ctor
+nvkm_disp_hpd_func = {
+	.ctor = nvkm_disp_hpd_ctor
 };
 
 int
-nouveau_disp_ntfy(struct nouveau_object *object, u32 type,
-		  struct nvkm_event **event)
+nvkm_disp_ntfy(struct nvkm_object *object, u32 type, struct nvkm_event **event)
 {
-	struct nouveau_disp *disp = (void *)object->engine;
+	struct nvkm_disp *disp = (void *)object->engine;
 	switch (type) {
 	case NV04_DISP_NTFY_VBLANK:
 		*event = &disp->vblank;
@@ -114,9 +115,9 @@ nouveau_disp_ntfy(struct nouveau_object *object, u32 type,
 }
 
 int
-_nouveau_disp_fini(struct nouveau_object *object, bool suspend)
+_nvkm_disp_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nouveau_disp *disp = (void *)object;
+	struct nvkm_disp *disp = (void *)object;
 	struct nvkm_output *outp;
 	int ret;
 
@@ -126,7 +127,7 @@ _nouveau_disp_fini(struct nouveau_object *object, bool suspend)
 			goto fail_outp;
 	}
 
-	return nouveau_engine_fini(&disp->base, suspend);
+	return nvkm_engine_fini(&disp->base, suspend);
 
 fail_outp:
 	list_for_each_entry_continue_reverse(outp, &disp->outp, head) {
@@ -137,13 +138,13 @@ _nouveau_disp_fini(struct nouveau_object *object, bool suspend)
 }
 
 int
-_nouveau_disp_init(struct nouveau_object *object)
+_nvkm_disp_init(struct nvkm_object *object)
 {
-	struct nouveau_disp *disp = (void *)object;
+	struct nvkm_disp *disp = (void *)object;
 	struct nvkm_output *outp;
 	int ret;
 
-	ret = nouveau_engine_init(&disp->base);
+	ret = nvkm_engine_init(&disp->base);
 	if (ret)
 		return ret;
 
@@ -164,9 +165,9 @@ _nouveau_disp_init(struct nouveau_object *object)
 }
 
 void
-_nouveau_disp_dtor(struct nouveau_object *object)
+_nvkm_disp_dtor(struct nvkm_object *object)
 {
-	struct nouveau_disp *disp = (void *)object;
+	struct nvkm_disp *disp = (void *)object;
 	struct nvkm_output *outp, *outt;
 
 	nvkm_event_fini(&disp->vblank);
@@ -174,32 +175,30 @@ _nouveau_disp_dtor(struct nouveau_object *object)
 
 	if (disp->outp.next) {
 		list_for_each_entry_safe(outp, outt, &disp->outp, head) {
-			nouveau_object_ref(NULL, (struct nouveau_object **)&outp);
+			nvkm_object_ref(NULL, (struct nvkm_object **)&outp);
 		}
 	}
 
-	nouveau_engine_destroy(&disp->base);
+	nvkm_engine_destroy(&disp->base);
 }
 
 int
-nouveau_disp_create_(struct nouveau_object *parent,
-		     struct nouveau_object *engine,
-		     struct nouveau_oclass *oclass, int heads,
-		     const char *intname, const char *extname,
-		     int length, void **pobject)
+nvkm_disp_create_(struct nvkm_object *parent, struct nvkm_object *engine,
+		  struct nvkm_oclass *oclass, int heads, const char *intname,
+		  const char *extname, int length, void **pobject)
 {
-	struct nouveau_disp_impl *impl = (void *)oclass;
-	struct nouveau_bios *bios = nouveau_bios(parent);
-	struct nouveau_disp *disp;
-	struct nouveau_oclass **sclass;
-	struct nouveau_object *object;
+	struct nvkm_disp_impl *impl = (void *)oclass;
+	struct nvkm_bios *bios = nvkm_bios(parent);
+	struct nvkm_disp *disp;
+	struct nvkm_oclass **sclass;
+	struct nvkm_object *object;
 	struct dcb_output dcbE;
 	u8  hpd = 0, ver, hdr;
 	u32 data;
 	int ret, i;
 
-	ret = nouveau_engine_create_(parent, engine, oclass, true,
-				     intname, extname, length, pobject);
+	ret = nvkm_engine_create_(parent, engine, oclass, true, intname,
+				  extname, length, pobject);
 	disp = *pobject;
 	if (ret)
 		return ret;
@@ -225,11 +224,11 @@ nouveau_disp_create_(struct nouveau_object *parent,
 			sclass++;
 		}
 
-		nouveau_object_ctor(*pobject, NULL, oclass, &dcbE, i, &object);
+		nvkm_object_ctor(*pobject, NULL, oclass, &dcbE, i, &object);
 		hpd = max(hpd, (u8)(dcbE.connector + 1));
 	}
 
-	ret = nvkm_event_init(&nouveau_disp_hpd_func, 3, hpd, &disp->hpd);
+	ret = nvkm_event_init(&nvkm_disp_hpd_func, 3, hpd, &disp->hpd);
 	if (ret)
 		return ret;
 

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
new file mode 100644
index 000000000000..c8a5f810e537
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c
@@ -0,0 +1,241 @@
+/*
+ * Copyright 2013 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <core/os.h>
+#include <nvif/unpack.h>
+#include <nvif/class.h>
+#include <nvif/event.h>
+
+#include "priv.h"
+#include "outp.h"
+#include "conn.h"
+
+int
+nouveau_disp_vblank_ctor(struct nouveau_object *object, void *data, u32 size,
+			 struct nvkm_notify *notify)
+{
+	struct nouveau_disp *disp =
+		container_of(notify->event, typeof(*disp), vblank);
+	union {
+		struct nvif_notify_head_req_v0 v0;
+	} *req = data;
+	int ret;
+
+	if (nvif_unpack(req->v0, 0, 0, false)) {
+		notify->size = sizeof(struct nvif_notify_head_rep_v0);
+		if (ret = -ENXIO, req->v0.head <= disp->vblank.index_nr) {
+			notify->types = 1;
+			notify->index = req->v0.head;
+			return 0;
+		}
+	}
+
+	return ret;
+}
+
+void
+nouveau_disp_vblank(struct nouveau_disp *disp, int head)
+{
+	struct nvif_notify_head_rep_v0 rep = {};
+	nvkm_event_send(&disp->vblank, 1, head, &rep, sizeof(rep));
+}
+
+static int
+nouveau_disp_hpd_ctor(struct nouveau_object *object, void *data, u32 size,
+		      struct nvkm_notify *notify)
+{
+	struct nouveau_disp *disp =
+		container_of(notify->event, typeof(*disp), hpd);
+	union {
+		struct nvif_notify_conn_req_v0 v0;
+	} *req = data;
+	struct nvkm_output *outp;
+	int ret;
+
+	if (nvif_unpack(req->v0, 0, 0, false)) {
+		notify->size = sizeof(struct nvif_notify_conn_rep_v0);
+		list_for_each_entry(outp, &disp->outp, head) {
+			if (ret = -ENXIO, outp->conn->index == req->v0.conn) {
+				if (ret = -ENODEV, outp->conn->hpd.event) {
+					notify->types = req->v0.mask;
+					notify->index = req->v0.conn;
+					ret = 0;
+				}
+				break;
+			}
+		}
+	}
+
+	return ret;
+}
+
+static const struct nvkm_event_func
+nouveau_disp_hpd_func = {
+	.ctor = nouveau_disp_hpd_ctor
+};
+
+int
+nouveau_disp_ntfy(struct nouveau_object *object, u32 type,
+		  struct nvkm_event **event)
+{
+	struct nouveau_disp *disp = (void *)object->engine;
+	switch (type) {
+	case NV04_DISP_NTFY_VBLANK:
+		*event = &disp->vblank;
+		return 0;
+	case NV04_DISP_NTFY_CONN:
+		*event = &disp->hpd;
+		return 0;
+	default:
+		break;
+	}
+	return -EINVAL;
+}
+
+int
+_nouveau_disp_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nouveau_disp *disp = (void *)object;
+	struct nvkm_output *outp;
+	int ret;
+
+	list_for_each_entry(outp, &disp->outp, head) {
+		ret = nv_ofuncs(outp)->fini(nv_object(outp), suspend);
+		if (ret && suspend)
+			goto fail_outp;
+	}
+
+	return nouveau_engine_fini(&disp->base, suspend);
+
+fail_outp:
+	list_for_each_entry_continue_reverse(outp, &disp->outp, head) {
+		nv_ofuncs(outp)->init(nv_object(outp));
+	}
+
+	return ret;
+}
+
+int
+_nouveau_disp_init(struct nouveau_object *object)
+{
+	struct nouveau_disp *disp = (void *)object;
+	struct nvkm_output *outp;
+	int ret;
+
+	ret = nouveau_engine_init(&disp->base);
+	if (ret)
+		return ret;
+
+	list_for_each_entry(outp, &disp->outp, head) {
+		ret = nv_ofuncs(outp)->init(nv_object(outp));
+		if (ret)
+			goto fail_outp;
+	}
+
+	return ret;
+
+fail_outp:
+	list_for_each_entry_continue_reverse(outp, &disp->outp, head) {
+		nv_ofuncs(outp)->fini(nv_object(outp), false);
+	}
+
+	return ret;
+}
+
+void
+_nouveau_disp_dtor(struct nouveau_object *object)
+{
+	struct nouveau_disp *disp = (void *)object;
+	struct nvkm_output *outp, *outt;
+
+	nvkm_event_fini(&disp->vblank);
+	nvkm_event_fini(&disp->hpd);
+
+	if (disp->outp.next) {
+		list_for_each_entry_safe(outp, outt, &disp->outp, head) {
+			nouveau_object_ref(NULL, (struct nouveau_object **)&outp);
+		}
+	}
+
+	nouveau_engine_destroy(&disp->base);
+}
+
+int
+nouveau_disp_create_(struct nouveau_object *parent,
+		     struct nouveau_object *engine,
+		     struct nouveau_oclass *oclass, int heads,
+		     const char *intname, const char *extname,
+		     int length, void **pobject)
+{
+	struct nouveau_disp_impl *impl = (void *)oclass;
+	struct nouveau_bios *bios = nouveau_bios(parent);
+	struct nouveau_disp *disp;
+	struct nouveau_oclass **sclass;
+	struct nouveau_object *object;
+	struct dcb_output dcbE;
+	u8  hpd = 0, ver, hdr;
+	u32 data;
+	int ret, i;
+
+	ret = nouveau_engine_create_(parent, engine, oclass, true,
+				     intname, extname, length, pobject);
+	disp = *pobject;
+	if (ret)
+		return ret;
+
+	INIT_LIST_HEAD(&disp->outp);
+
+	/* create output objects for each display path in the vbios */
+	i = -1;
+	while ((data = dcb_outp_parse(bios, ++i, &ver, &hdr, &dcbE))) {
+		if (dcbE.type == DCB_OUTPUT_UNUSED)
+			continue;
+		if (dcbE.type == DCB_OUTPUT_EOL)
+			break;
+		data = dcbE.location << 4 | dcbE.type;
+
+		oclass = nvkm_output_oclass;
+		sclass = impl->outp;
+		while (sclass && sclass[0]) {
+			if (sclass[0]->handle == data) {
+				oclass = sclass[0];
+				break;
+			}
+			sclass++;
+		}
+
+		nouveau_object_ctor(*pobject, NULL, oclass, &dcbE, i, &object);
+		hpd = max(hpd, (u8)(dcbE.connector + 1));
+	}
+
+	ret = nvkm_event_init(&nouveau_disp_hpd_func, 3, hpd, &disp->hpd);
+	if (ret)
+		return ret;
+
+	ret = nvkm_event_init(impl->vblank, 1, heads, &disp->vblank);
+	if (ret)
+		return ret;
+
+	return 0;
+}
