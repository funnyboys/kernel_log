commit e6867ffa34340636252efe8e6b82be625c43d9b1
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jun 3 11:43:23 2020 +1000

    drm/nouveau/disp: modify OR allocation policy to account for HDA requirements
    
    Since GM200, SORs are no longer tied to a specific connector, and we
    allocate them instead, with the assumption that all SORs are equally
    capable.
    
    However, there's a 1<->1 mapping between SOR and HDA pin widget, and
    it turns out that it's possible for some widgets to be disabled...
    
    In order to avoid picking a SOR without a valid pin widget, some new
    rules need to be added.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
index b56224558a05..dcf08249374a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
@@ -121,14 +121,14 @@ nvkm_outp_acquire_hda(struct nvkm_outp *outp, enum nvkm_ior_type type,
 	 * on HW, if any, in order to prevent unnecessary switching.
 	 */
 	list_for_each_entry(ior, &outp->disp->ior, head) {
-		if (!ior->identity &&
+		if (!ior->identity && !!ior->func->hda.hpd == hda &&
 		    !ior->asy.outp && ior->arm.outp == outp)
 			return nvkm_outp_acquire_ior(outp, user, ior);
 	}
 
 	/* Failing that, a completely unused OR is the next best thing. */
 	list_for_each_entry(ior, &outp->disp->ior, head) {
-		if (!ior->identity &&
+		if (!ior->identity && !!ior->func->hda.hpd == hda &&
 		    !ior->asy.outp && ior->type == type && !ior->arm.outp &&
 		    (ior->func->route.set || ior->id == __ffs(outp->info.or)))
 			return nvkm_outp_acquire_ior(outp, user, ior);
@@ -138,7 +138,7 @@ nvkm_outp_acquire_hda(struct nvkm_outp *outp, enum nvkm_ior_type type,
 	 * but will be released during the next modeset.
 	 */
 	list_for_each_entry(ior, &outp->disp->ior, head) {
-		if (!ior->identity &&
+		if (!ior->identity && !!ior->func->hda.hpd == hda &&
 		    !ior->asy.outp && ior->type == type &&
 		    (ior->func->route.set || ior->id == __ffs(outp->info.or)))
 			return nvkm_outp_acquire_ior(outp, user, ior);
@@ -173,7 +173,25 @@ nvkm_outp_acquire(struct nvkm_outp *outp, u8 user, bool hda)
 		return nvkm_outp_acquire_ior(outp, user, ior);
 	}
 
-	return nvkm_outp_acquire_hda(outp, type, user, true);
+	/* If we don't need HDA, first try to acquire an OR that doesn't
+	 * support it to leave free the ones that do.
+	 */
+	if (!hda) {
+		if (!nvkm_outp_acquire_hda(outp, type, user, false))
+			return 0;
+
+		/* Use a HDA-supporting SOR anyway. */
+		return nvkm_outp_acquire_hda(outp, type, user, true);
+	}
+
+	/* We want HDA, try to acquire an OR that supports it. */
+	if (!nvkm_outp_acquire_hda(outp, type, user, true))
+		return 0;
+
+	/* There weren't any free ORs that support HDA, grab one that
+	 * doesn't and at least allow display to work still.
+	 */
+	return nvkm_outp_acquire_hda(outp, type, user, false);
 }
 
 void

commit f24b6ae19fa257ea9b10a9389d0b7046b3efd97c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jun 3 11:40:47 2020 +1000

    drm/nouveau/disp: split part of OR allocation logic into a function
    
    No logical changes here, this is just moving the code to make the
    changes in the next commit more obvious.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
index 1b1c6ff0e1bc..b56224558a05 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
@@ -111,37 +111,18 @@ nvkm_outp_acquire_ior(struct nvkm_outp *outp, u8 user, struct nvkm_ior *ior)
 	return 0;
 }
 
-int
-nvkm_outp_acquire(struct nvkm_outp *outp, u8 user, bool hda)
+static inline int
+nvkm_outp_acquire_hda(struct nvkm_outp *outp, enum nvkm_ior_type type,
+		      u8 user, bool hda)
 {
-	struct nvkm_ior *ior = outp->ior;
-	enum nvkm_ior_proto proto;
-	enum nvkm_ior_type type;
-
-	OUTP_TRACE(outp, "acquire %02x |= %02x %p", outp->acquired, user, ior);
-	if (ior) {
-		outp->acquired |= user;
-		return 0;
-	}
-
-	/* Lookup a compatible, and unused, OR to assign to the device. */
-	proto = nvkm_outp_xlat(outp, &type);
-	if (proto == UNKNOWN)
-		return -ENOSYS;
-
-	/* Deal with panels requiring identity-mapped SOR assignment. */
-	if (outp->identity) {
-		ior = nvkm_ior_find(outp->disp, SOR, ffs(outp->info.or) - 1);
-		if (WARN_ON(!ior))
-			return -ENOSPC;
-		return nvkm_outp_acquire_ior(outp, user, ior);
-	}
+	struct nvkm_ior *ior;
 
 	/* First preference is to reuse the OR that is currently armed
 	 * on HW, if any, in order to prevent unnecessary switching.
 	 */
 	list_for_each_entry(ior, &outp->disp->ior, head) {
-		if (!ior->identity && !ior->asy.outp && ior->arm.outp == outp)
+		if (!ior->identity &&
+		    !ior->asy.outp && ior->arm.outp == outp)
 			return nvkm_outp_acquire_ior(outp, user, ior);
 	}
 
@@ -157,7 +138,8 @@ nvkm_outp_acquire(struct nvkm_outp *outp, u8 user, bool hda)
 	 * but will be released during the next modeset.
 	 */
 	list_for_each_entry(ior, &outp->disp->ior, head) {
-		if (!ior->identity && !ior->asy.outp && ior->type == type &&
+		if (!ior->identity &&
+		    !ior->asy.outp && ior->type == type &&
 		    (ior->func->route.set || ior->id == __ffs(outp->info.or)))
 			return nvkm_outp_acquire_ior(outp, user, ior);
 	}
@@ -165,6 +147,35 @@ nvkm_outp_acquire(struct nvkm_outp *outp, u8 user, bool hda)
 	return -ENOSPC;
 }
 
+int
+nvkm_outp_acquire(struct nvkm_outp *outp, u8 user, bool hda)
+{
+	struct nvkm_ior *ior = outp->ior;
+	enum nvkm_ior_proto proto;
+	enum nvkm_ior_type type;
+
+	OUTP_TRACE(outp, "acquire %02x |= %02x %p", outp->acquired, user, ior);
+	if (ior) {
+		outp->acquired |= user;
+		return 0;
+	}
+
+	/* Lookup a compatible, and unused, OR to assign to the device. */
+	proto = nvkm_outp_xlat(outp, &type);
+	if (proto == UNKNOWN)
+		return -ENOSYS;
+
+	/* Deal with panels requiring identity-mapped SOR assignment. */
+	if (outp->identity) {
+		ior = nvkm_ior_find(outp->disp, SOR, ffs(outp->info.or) - 1);
+		if (WARN_ON(!ior))
+			return -ENOSPC;
+		return nvkm_outp_acquire_ior(outp, user, ior);
+	}
+
+	return nvkm_outp_acquire_hda(outp, type, user, true);
+}
+
 void
 nvkm_outp_fini(struct nvkm_outp *outp)
 {

commit 6f8dbcf1c9cec3ec5efcf4c17b29a5b1732d1491
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jun 3 11:37:56 2020 +1000

    drm/nouveau/disp: provide hint to OR allocation about HDA requirements
    
    Will be used by a subsequent commit to influence SOR allocation policy.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
index c62030c96fba..1b1c6ff0e1bc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
@@ -112,7 +112,7 @@ nvkm_outp_acquire_ior(struct nvkm_outp *outp, u8 user, struct nvkm_ior *ior)
 }
 
 int
-nvkm_outp_acquire(struct nvkm_outp *outp, u8 user)
+nvkm_outp_acquire(struct nvkm_outp *outp, u8 user, bool hda)
 {
 	struct nvkm_ior *ior = outp->ior;
 	enum nvkm_ior_proto proto;

commit 53b0cc46f27cfc2cadca609b503a7d92b5185a47
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Sep 4 15:57:11 2018 +1000

    drm/nouveau/disp/gm200-: enforce identity-mapped SOR assignment for LVDS/eDP panels
    
    Fixes eDP backlight issues on more recent laptops.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
index 9fcaf3147eb8..c62030c96fba 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
@@ -129,17 +129,26 @@ nvkm_outp_acquire(struct nvkm_outp *outp, u8 user)
 	if (proto == UNKNOWN)
 		return -ENOSYS;
 
+	/* Deal with panels requiring identity-mapped SOR assignment. */
+	if (outp->identity) {
+		ior = nvkm_ior_find(outp->disp, SOR, ffs(outp->info.or) - 1);
+		if (WARN_ON(!ior))
+			return -ENOSPC;
+		return nvkm_outp_acquire_ior(outp, user, ior);
+	}
+
 	/* First preference is to reuse the OR that is currently armed
 	 * on HW, if any, in order to prevent unnecessary switching.
 	 */
 	list_for_each_entry(ior, &outp->disp->ior, head) {
-		if (!ior->asy.outp && ior->arm.outp == outp)
+		if (!ior->identity && !ior->asy.outp && ior->arm.outp == outp)
 			return nvkm_outp_acquire_ior(outp, user, ior);
 	}
 
 	/* Failing that, a completely unused OR is the next best thing. */
 	list_for_each_entry(ior, &outp->disp->ior, head) {
-		if (!ior->asy.outp && ior->type == type && !ior->arm.outp &&
+		if (!ior->identity &&
+		    !ior->asy.outp && ior->type == type && !ior->arm.outp &&
 		    (ior->func->route.set || ior->id == __ffs(outp->info.or)))
 			return nvkm_outp_acquire_ior(outp, user, ior);
 	}
@@ -148,7 +157,7 @@ nvkm_outp_acquire(struct nvkm_outp *outp, u8 user)
 	 * but will be released during the next modeset.
 	 */
 	list_for_each_entry(ior, &outp->disp->ior, head) {
-		if (!ior->asy.outp && ior->type == type &&
+		if (!ior->identity && !ior->asy.outp && ior->type == type &&
 		    (ior->func->route.set || ior->id == __ffs(outp->info.or)))
 			return nvkm_outp_acquire_ior(outp, user, ior);
 	}

commit e04cfdc9b7398c60dbc70212415ea63b6c6a93ae
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Sep 4 15:57:09 2018 +1000

    drm/nouveau/disp: fix DP disable race
    
    If a HPD pulse signalling the need to retrain the link occurs between
    the KMS driver releasing the output and the supervisor interrupt that
    finishes the teardown, it was possible get a NULL-ptr deref.
    
    Avoid this by marking the link as inactive earlier.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
index 4b6973f90309..9fcaf3147eb8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
@@ -93,6 +93,8 @@ nvkm_outp_release(struct nvkm_outp *outp, u8 user)
 	if (ior) {
 		outp->acquired &= ~user;
 		if (!outp->acquired) {
+			if (outp->func->release && outp->ior)
+				outp->func->release(outp);
 			outp->ior->asy.outp = NULL;
 			outp->ior = NULL;
 		}

commit 606557708fa06ebf21372d8fabf6f97529ab2349
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Sep 4 15:57:04 2018 +1000

    drm/nouveau/disp: remove unused struct member
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
index be9e7f8c3b23..4b6973f90309 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
@@ -245,7 +245,6 @@ nvkm_outp_ctor(const struct nvkm_outp_func *func, struct nvkm_disp *disp,
 	outp->index = index;
 	outp->info = *dcbE;
 	outp->i2c = nvkm_i2c_bus_find(i2c, dcbE->i2c_index);
-	outp->or = ffs(outp->info.or) - 1;
 
 	OUTP_DBG(outp, "type %02x loc %d or %d link %d con %x "
 		       "edid %x bus %d head %x",

commit 587f577e0beb4d20ee60bac8d21134b4c5a9fd29
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jul 18 13:30:29 2017 +1000

    drm/nouveau/disp: add tv encoders to output resource mapping
    
    We don't support them on G80, but we need to add them to the mapping to
    avoid triggering a WARN_ON() on GPUs where the ports are present.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
index 85aff85394ac..be9e7f8c3b23 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
@@ -62,6 +62,7 @@ nvkm_outp_xlat(struct nvkm_outp *outp, enum nvkm_ior_type *type)
 	case 0:
 		switch (outp->info.type) {
 		case DCB_OUTPUT_ANALOG: *type = DAC; return  CRT;
+		case DCB_OUTPUT_TV    : *type = DAC; return   TV;
 		case DCB_OUTPUT_TMDS  : *type = SOR; return TMDS;
 		case DCB_OUTPUT_LVDS  : *type = SOR; return LVDS;
 		case DCB_OUTPUT_DP    : *type = SOR; return   DP;

commit 2863204c6208f8aabeeec163b9d9e827a3da0858
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/gm200-: allow non-identity mapping of SOR <-> macro links
    
    Finally, everything should be in place to handle this.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
index ef201f1597c7..85aff85394ac 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
@@ -137,7 +137,7 @@ nvkm_outp_acquire(struct nvkm_outp *outp, u8 user)
 	/* Failing that, a completely unused OR is the next best thing. */
 	list_for_each_entry(ior, &outp->disp->ior, head) {
 		if (!ior->asy.outp && ior->type == type && !ior->arm.outp &&
-		    ior->id == __ffs(outp->info.or))
+		    (ior->func->route.set || ior->id == __ffs(outp->info.or)))
 			return nvkm_outp_acquire_ior(outp, user, ior);
 	}
 
@@ -146,7 +146,7 @@ nvkm_outp_acquire(struct nvkm_outp *outp, u8 user)
 	 */
 	list_for_each_entry(ior, &outp->disp->ior, head) {
 		if (!ior->asy.outp && ior->type == type &&
-		    ior->id == __ffs(outp->info.or))
+		    (ior->func->route.set || ior->id == __ffs(outp->info.or)))
 			return nvkm_outp_acquire_ior(outp, user, ior);
 	}
 

commit 6c22ea3747fd36409ce4a1e1a0cbac40f93e1e71
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp: introduce acquire/release display path methods
    
    These exist to give NVKM information on the set of display paths that
    the DD needs to be active at any given time.
    
    Previously, the supervisor attempted to determine this solely from OR
    state, but there's a few configurations where this information on its
    own isn't enough to determine the specific display paths in question:
    
    - ANX9805, where the PIOR protocol for both DP and TMDS is TMDS.
    - On a device using DCB Switched Outputs.
    - On GM20x and newer, with a crossbar between the SOR and macro links.
    
    After this commit, the DD tells NVKM *exactly* which display path it's
    attempting a modeset on.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
index 09e8ebbd4ee9..ef201f1597c7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
@@ -28,8 +28,35 @@
 #include <subdev/bios/dcb.h>
 #include <subdev/i2c.h>
 
+void
+nvkm_outp_route(struct nvkm_disp *disp)
+{
+	struct nvkm_outp *outp;
+	struct nvkm_ior *ior;
+
+	list_for_each_entry(ior, &disp->ior, head) {
+		if ((outp = ior->arm.outp) && ior->arm.outp != ior->asy.outp) {
+			OUTP_DBG(outp, "release %s", ior->name);
+			if (ior->func->route.set)
+				ior->func->route.set(outp, NULL);
+			ior->arm.outp = NULL;
+		}
+	}
+
+	list_for_each_entry(ior, &disp->ior, head) {
+		if ((outp = ior->asy.outp)) {
+			OUTP_DBG(outp, "acquire %s", ior->name);
+			if (ior->asy.outp != ior->arm.outp) {
+				if (ior->func->route.set)
+					ior->func->route.set(outp, ior);
+				ior->arm.outp = ior->asy.outp;
+			}
+		}
+	}
+}
+
 static enum nvkm_ior_proto
-nvkm_outp_xlat(struct nvkm_output *outp, enum nvkm_ior_type *type)
+nvkm_outp_xlat(struct nvkm_outp *outp, enum nvkm_ior_type *type)
 {
 	switch (outp->info.location) {
 	case 0:
@@ -57,6 +84,75 @@ nvkm_outp_xlat(struct nvkm_output *outp, enum nvkm_ior_type *type)
 	return UNKNOWN;
 }
 
+void
+nvkm_outp_release(struct nvkm_outp *outp, u8 user)
+{
+	struct nvkm_ior *ior = outp->ior;
+	OUTP_TRACE(outp, "release %02x &= %02x %p", outp->acquired, ~user, ior);
+	if (ior) {
+		outp->acquired &= ~user;
+		if (!outp->acquired) {
+			outp->ior->asy.outp = NULL;
+			outp->ior = NULL;
+		}
+	}
+}
+
+static inline int
+nvkm_outp_acquire_ior(struct nvkm_outp *outp, u8 user, struct nvkm_ior *ior)
+{
+	outp->ior = ior;
+	outp->ior->asy.outp = outp;
+	outp->ior->asy.link = outp->info.sorconf.link;
+	outp->acquired |= user;
+	return 0;
+}
+
+int
+nvkm_outp_acquire(struct nvkm_outp *outp, u8 user)
+{
+	struct nvkm_ior *ior = outp->ior;
+	enum nvkm_ior_proto proto;
+	enum nvkm_ior_type type;
+
+	OUTP_TRACE(outp, "acquire %02x |= %02x %p", outp->acquired, user, ior);
+	if (ior) {
+		outp->acquired |= user;
+		return 0;
+	}
+
+	/* Lookup a compatible, and unused, OR to assign to the device. */
+	proto = nvkm_outp_xlat(outp, &type);
+	if (proto == UNKNOWN)
+		return -ENOSYS;
+
+	/* First preference is to reuse the OR that is currently armed
+	 * on HW, if any, in order to prevent unnecessary switching.
+	 */
+	list_for_each_entry(ior, &outp->disp->ior, head) {
+		if (!ior->asy.outp && ior->arm.outp == outp)
+			return nvkm_outp_acquire_ior(outp, user, ior);
+	}
+
+	/* Failing that, a completely unused OR is the next best thing. */
+	list_for_each_entry(ior, &outp->disp->ior, head) {
+		if (!ior->asy.outp && ior->type == type && !ior->arm.outp &&
+		    ior->id == __ffs(outp->info.or))
+			return nvkm_outp_acquire_ior(outp, user, ior);
+	}
+
+	/* Last resort is to assign an OR that's already active on HW,
+	 * but will be released during the next modeset.
+	 */
+	list_for_each_entry(ior, &outp->disp->ior, head) {
+		if (!ior->asy.outp && ior->type == type &&
+		    ior->id == __ffs(outp->info.or))
+			return nvkm_outp_acquire_ior(outp, user, ior);
+	}
+
+	return -ENOSPC;
+}
+
 void
 nvkm_outp_fini(struct nvkm_outp *outp)
 {
@@ -65,22 +161,36 @@ nvkm_outp_fini(struct nvkm_outp *outp)
 }
 
 static void
-nvkm_outp_init_route(struct nvkm_output *outp)
+nvkm_outp_init_route(struct nvkm_outp *outp)
 {
 	struct nvkm_disp *disp = outp->disp;
 	enum nvkm_ior_proto proto;
 	enum nvkm_ior_type type;
 	struct nvkm_ior *ior;
-	int id;
+	int id, link;
 
+	/* Find any OR from the class that is able to support this device. */
 	proto = nvkm_outp_xlat(outp, &type);
 	if (proto == UNKNOWN)
 		return;
 
+	ior = nvkm_ior_find(disp, type, -1);
+	if (!ior) {
+		WARN_ON(1);
+		return;
+	}
+
 	/* Determine the specific OR, if any, this device is attached to. */
-	if (1) {
+	if (ior->func->route.get) {
+		id = ior->func->route.get(outp, &link);
+		if (id < 0) {
+			OUTP_DBG(outp, "no route");
+			return;
+		}
+	} else {
 		/* Prior to DCB 4.1, this is hardwired like so. */
-		id = ffs(outp->info.or) - 1;
+		id   = ffs(outp->info.or) - 1;
+		link = (ior->type == SOR) ? outp->info.sorconf.link : 0;
 	}
 
 	ior = nvkm_ior_find(disp, type, id);
@@ -89,7 +199,16 @@ nvkm_outp_init_route(struct nvkm_output *outp)
 		return;
 	}
 
-	outp->ior = ior;
+	/* Determine if the OR is already configured for this device. */
+	ior->func->state(ior, &ior->arm);
+	if (!ior->arm.head || ior->arm.proto != proto) {
+		OUTP_DBG(outp, "no heads (%x %d %d)", ior->arm.head,
+			 ior->arm.proto, proto);
+		return;
+	}
+
+	OUTP_DBG(outp, "on %s link %x", ior->name, ior->arm.link);
+	ior->arm.outp = outp;
 }
 
 void

commit 3c66c87dc96b3113b5ee84604800c2aabbb48994
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp: remove hw-specific customisation of output paths
    
    All of the necessary hw-specific logic is now handled at the output
    resource level, so all of this can go away.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
index 895a84ca1501..09e8ebbd4ee9 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
@@ -142,12 +142,15 @@ nvkm_outp_ctor(const struct nvkm_outp_func *func, struct nvkm_disp *disp,
 	return 0;
 }
 
+static const struct nvkm_outp_func
+nvkm_outp = {
+};
+
 int
-nvkm_outp_new_(const struct nvkm_outp_func *func,
-	       struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
-	       struct nvkm_outp **poutp)
+nvkm_outp_new(struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
+	      struct nvkm_outp **poutp)
 {
 	if (!(*poutp = kzalloc(sizeof(**poutp), GFP_KERNEL)))
 		return -ENOMEM;
-	return nvkm_outp_ctor(func, disp, index, dcbE, *poutp);
+	return nvkm_outp_ctor(&nvkm_outp, disp, index, dcbE, *poutp);
 }

commit 01a976376b6e57838f223dd2d2639597efd92db4
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp: identity-map display paths to output resources
    
    This essentially replicates our current behaviour in a way that's
    compatible with the new model that's emerging, so that we're able
    to start porting the hw-specific functions to it.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
index f030ff51d076..895a84ca1501 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
@@ -22,11 +22,41 @@
  * Authors: Ben Skeggs
  */
 #include "outp.h"
+#include "ior.h"
 
 #include <subdev/bios.h>
 #include <subdev/bios/dcb.h>
 #include <subdev/i2c.h>
 
+static enum nvkm_ior_proto
+nvkm_outp_xlat(struct nvkm_output *outp, enum nvkm_ior_type *type)
+{
+	switch (outp->info.location) {
+	case 0:
+		switch (outp->info.type) {
+		case DCB_OUTPUT_ANALOG: *type = DAC; return  CRT;
+		case DCB_OUTPUT_TMDS  : *type = SOR; return TMDS;
+		case DCB_OUTPUT_LVDS  : *type = SOR; return LVDS;
+		case DCB_OUTPUT_DP    : *type = SOR; return   DP;
+		default:
+			break;
+		}
+		break;
+	case 1:
+		switch (outp->info.type) {
+		case DCB_OUTPUT_TMDS: *type = PIOR; return TMDS;
+		case DCB_OUTPUT_DP  : *type = PIOR; return TMDS; /* not a bug */
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+	WARN_ON(1);
+	return UNKNOWN;
+}
+
 void
 nvkm_outp_fini(struct nvkm_outp *outp)
 {
@@ -34,9 +64,38 @@ nvkm_outp_fini(struct nvkm_outp *outp)
 		outp->func->fini(outp);
 }
 
+static void
+nvkm_outp_init_route(struct nvkm_output *outp)
+{
+	struct nvkm_disp *disp = outp->disp;
+	enum nvkm_ior_proto proto;
+	enum nvkm_ior_type type;
+	struct nvkm_ior *ior;
+	int id;
+
+	proto = nvkm_outp_xlat(outp, &type);
+	if (proto == UNKNOWN)
+		return;
+
+	/* Determine the specific OR, if any, this device is attached to. */
+	if (1) {
+		/* Prior to DCB 4.1, this is hardwired like so. */
+		id = ffs(outp->info.or) - 1;
+	}
+
+	ior = nvkm_ior_find(disp, type, id);
+	if (!ior) {
+		WARN_ON(1);
+		return;
+	}
+
+	outp->ior = ior;
+}
+
 void
 nvkm_outp_init(struct nvkm_outp *outp)
 {
+	nvkm_outp_init_route(outp);
 	if (outp->func->init)
 		outp->func->init(outp);
 }
@@ -53,11 +112,13 @@ nvkm_outp_del(struct nvkm_outp **poutp)
 	}
 }
 
-void
+int
 nvkm_outp_ctor(const struct nvkm_outp_func *func, struct nvkm_disp *disp,
 	       int index, struct dcb_output *dcbE, struct nvkm_outp *outp)
 {
 	struct nvkm_i2c *i2c = disp->engine.subdev.device->i2c;
+	enum nvkm_ior_proto proto;
+	enum nvkm_ior_type type;
 
 	outp->func = func;
 	outp->disp = disp;
@@ -72,6 +133,13 @@ nvkm_outp_ctor(const struct nvkm_outp_func *func, struct nvkm_disp *disp,
 		 outp->info.type >= 2 ? outp->info.sorconf.link : 0,
 		 outp->info.connector, outp->info.i2c_index,
 		 outp->info.bus, outp->info.heads);
+
+	/* Cull output paths we can't map to an output resource. */
+	proto = nvkm_outp_xlat(outp, &type);
+	if (proto == UNKNOWN)
+		return -ENODEV;
+
+	return 0;
 }
 
 int
@@ -81,7 +149,5 @@ nvkm_outp_new_(const struct nvkm_outp_func *func,
 {
 	if (!(*poutp = kzalloc(sizeof(**poutp), GFP_KERNEL)))
 		return -ENOMEM;
-
-	nvkm_outp_ctor(func, disp, index, dcbE, *poutp);
-	return 0;
+	return nvkm_outp_ctor(func, disp, index, dcbE, *poutp);
 }

commit d7ce92e27303082f00cf0976d673f4cc0a5f1c5f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/disp: rename nvkm_output to nvkm_outp
    
    This isn't technically "output", but, "display/output path".
    
    Not all users of nvkm_output have been changed here.  The remaining
    ones belong to code that's disappearing in upcoming commits.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
index bbe5ec0dedb2..f030ff51d076 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
@@ -28,23 +28,23 @@
 #include <subdev/i2c.h>
 
 void
-nvkm_output_fini(struct nvkm_output *outp)
+nvkm_outp_fini(struct nvkm_outp *outp)
 {
 	if (outp->func->fini)
 		outp->func->fini(outp);
 }
 
 void
-nvkm_output_init(struct nvkm_output *outp)
+nvkm_outp_init(struct nvkm_outp *outp)
 {
 	if (outp->func->init)
 		outp->func->init(outp);
 }
 
 void
-nvkm_output_del(struct nvkm_output **poutp)
+nvkm_outp_del(struct nvkm_outp **poutp)
 {
-	struct nvkm_output *outp = *poutp;
+	struct nvkm_outp *outp = *poutp;
 	if (outp && !WARN_ON(!outp->func)) {
 		if (outp->func->dtor)
 			*poutp = outp->func->dtor(outp);
@@ -54,8 +54,8 @@ nvkm_output_del(struct nvkm_output **poutp)
 }
 
 void
-nvkm_output_ctor(const struct nvkm_output_func *func, struct nvkm_disp *disp,
-		 int index, struct dcb_output *dcbE, struct nvkm_output *outp)
+nvkm_outp_ctor(const struct nvkm_outp_func *func, struct nvkm_disp *disp,
+	       int index, struct dcb_output *dcbE, struct nvkm_outp *outp)
 {
 	struct nvkm_i2c *i2c = disp->engine.subdev.device->i2c;
 
@@ -75,13 +75,13 @@ nvkm_output_ctor(const struct nvkm_output_func *func, struct nvkm_disp *disp,
 }
 
 int
-nvkm_output_new_(const struct nvkm_output_func *func,
-		 struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
-		 struct nvkm_output **poutp)
+nvkm_outp_new_(const struct nvkm_outp_func *func,
+	       struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
+	       struct nvkm_outp **poutp)
 {
 	if (!(*poutp = kzalloc(sizeof(**poutp), GFP_KERNEL)))
 		return -ENOMEM;
 
-	nvkm_output_ctor(func, disp, index, dcbE, *poutp);
+	nvkm_outp_ctor(func, disp, index, dcbE, *poutp);
 	return 0;
 }

commit f2c906fc0cf1657e4164e09ae6061534eebd5430
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:15 2015 +1000

    drm/nouveau/disp: transition outp/conn away from being based on nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
index 88a990ec7025..bbe5ec0dedb2 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
@@ -22,117 +22,66 @@
  * Authors: Ben Skeggs
  */
 #include "outp.h"
-#include "priv.h"
 
 #include <subdev/bios.h>
-#include <subdev/bios/conn.h>
 #include <subdev/bios/dcb.h>
 #include <subdev/i2c.h>
 
-int
-_nvkm_output_fini(struct nvkm_object *object, bool suspend)
+void
+nvkm_output_fini(struct nvkm_output *outp)
 {
-	struct nvkm_output *outp = (void *)object;
-	nv_ofuncs(outp->conn)->fini(nv_object(outp->conn), suspend);
-	return nvkm_object_fini(&outp->base, suspend);
+	if (outp->func->fini)
+		outp->func->fini(outp);
 }
 
-int
-_nvkm_output_init(struct nvkm_object *object)
+void
+nvkm_output_init(struct nvkm_output *outp)
 {
-	struct nvkm_output *outp = (void *)object;
-	int ret = nvkm_object_init(&outp->base);
-	if (ret == 0)
-		nv_ofuncs(outp->conn)->init(nv_object(outp->conn));
-	return 0;
+	if (outp->func->init)
+		outp->func->init(outp);
 }
 
 void
-_nvkm_output_dtor(struct nvkm_object *object)
+nvkm_output_del(struct nvkm_output **poutp)
 {
-	struct nvkm_output *outp = (void *)object;
-	list_del(&outp->head);
-	nvkm_object_ref(NULL, (void *)&outp->conn);
-	nvkm_object_destroy(&outp->base);
+	struct nvkm_output *outp = *poutp;
+	if (outp && !WARN_ON(!outp->func)) {
+		if (outp->func->dtor)
+			*poutp = outp->func->dtor(outp);
+		kfree(*poutp);
+		*poutp = NULL;
+	}
 }
 
-int
-nvkm_output_create_(struct nvkm_object *parent,
-		    struct nvkm_object *engine,
-		    struct nvkm_oclass *oclass,
-		    struct dcb_output *dcbE, int index,
-		    int length, void **pobject)
+void
+nvkm_output_ctor(const struct nvkm_output_func *func, struct nvkm_disp *disp,
+		 int index, struct dcb_output *dcbE, struct nvkm_output *outp)
 {
-	struct nvkm_disp *disp = nvkm_disp(parent);
-	struct nvkm_bios *bios = nvkm_bios(parent);
-	struct nvkm_i2c *i2c = nvkm_i2c(parent);
-	struct nvbios_connE connE;
-	struct nvkm_output *outp;
-	u8  ver, hdr;
-	u32 data;
-	int ret;
+	struct nvkm_i2c *i2c = disp->engine.subdev.device->i2c;
 
-	ret = nvkm_object_create_(parent, engine, oclass, 0, length, pobject);
-	outp = *pobject;
-	if (ret)
-		return ret;
-
-	outp->info = *dcbE;
+	outp->func = func;
+	outp->disp = disp;
 	outp->index = index;
+	outp->info = *dcbE;
+	outp->i2c = nvkm_i2c_bus_find(i2c, dcbE->i2c_index);
 	outp->or = ffs(outp->info.or) - 1;
 
-	DBG("type %02x loc %d or %d link %d con %x edid %x bus %d head %x\n",
-	    dcbE->type, dcbE->location, dcbE->or, dcbE->type >= 2 ?
-	    dcbE->sorconf.link : 0, dcbE->connector, dcbE->i2c_index,
-	    dcbE->bus, dcbE->heads);
-
-	outp->i2c = nvkm_i2c_bus_find(i2c, outp->info.i2c_index);
-
-	data = nvbios_connEp(bios, outp->info.connector, &ver, &hdr, &connE);
-	if (!data) {
-		DBG("vbios connector data not found\n");
-		memset(&connE, 0x00, sizeof(connE));
-		connE.type = DCB_CONNECTOR_NONE;
-	}
-
-	ret = nvkm_object_ctor(parent, NULL, nvkm_connector_oclass,
-			       &connE, outp->info.connector,
-			       (struct nvkm_object **)&outp->conn);
-	if (ret < 0) {
-		ERR("error %d creating connector, disabling\n", ret);
-		return ret;
-	}
-
-	list_add_tail(&outp->head, &disp->outp);
-	return 0;
+	OUTP_DBG(outp, "type %02x loc %d or %d link %d con %x "
+		       "edid %x bus %d head %x",
+		 outp->info.type, outp->info.location, outp->info.or,
+		 outp->info.type >= 2 ? outp->info.sorconf.link : 0,
+		 outp->info.connector, outp->info.i2c_index,
+		 outp->info.bus, outp->info.heads);
 }
 
 int
-_nvkm_output_ctor(struct nvkm_object *parent,
-		  struct nvkm_object *engine,
-		  struct nvkm_oclass *oclass, void *dcbE, u32 index,
-		  struct nvkm_object **pobject)
+nvkm_output_new_(const struct nvkm_output_func *func,
+		 struct nvkm_disp *disp, int index, struct dcb_output *dcbE,
+		 struct nvkm_output **poutp)
 {
-	struct nvkm_output *outp;
-	int ret;
-
-	ret = nvkm_output_create(parent, engine, oclass, dcbE, index, &outp);
-	*pobject = nv_object(outp);
-	if (ret)
-		return ret;
+	if (!(*poutp = kzalloc(sizeof(**poutp), GFP_KERNEL)))
+		return -ENOMEM;
 
+	nvkm_output_ctor(func, disp, index, dcbE, *poutp);
 	return 0;
 }
-
-struct nvkm_oclass *
-nvkm_output_oclass = &(struct nvkm_output_impl) {
-	.base = {
-		.handle = 0,
-		.ofuncs = &(struct nvkm_ofuncs) {
-			.ctor = _nvkm_output_ctor,
-			.dtor = _nvkm_output_dtor,
-			.init = _nvkm_output_init,
-			.fini = _nvkm_output_fini,
-		},
-	},
-}.base;

commit 2aa5eac5163fedf09f2d61992cb5ea4d75bec9db
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:15 2015 +1000

    drm/nouveau/i2c: transition pad/ports away from being based on nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
index 9224bcbf0159..88a990ec7025 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
@@ -86,11 +86,7 @@ nvkm_output_create_(struct nvkm_object *parent,
 	    dcbE->sorconf.link : 0, dcbE->connector, dcbE->i2c_index,
 	    dcbE->bus, dcbE->heads);
 
-	if (outp->info.type != DCB_OUTPUT_DP)
-		outp->port = i2c->find(i2c, NV_I2C_PORT(outp->info.i2c_index));
-	else
-		outp->port = i2c->find(i2c, NV_I2C_AUX(outp->info.i2c_index));
-	outp->edid = outp->port;
+	outp->i2c = nvkm_i2c_bus_find(i2c, outp->info.i2c_index);
 
 	data = nvbios_connEp(bios, outp->info.connector, &ver, &hdr, &connE);
 	if (!data) {

commit 878da15adb5ddce57339b87685d8b4630e60085f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:24:57 2015 +1000

    drm/nouveau/disp: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
index c5589c26e07d..9224bcbf0159 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
@@ -21,57 +21,58 @@
  *
  * Authors: Ben Skeggs
  */
+#include "outp.h"
+#include "priv.h"
 
-#include <subdev/i2c.h>
 #include <subdev/bios.h>
 #include <subdev/bios/conn.h>
-
-#include "outp.h"
+#include <subdev/bios/dcb.h>
+#include <subdev/i2c.h>
 
 int
-_nvkm_output_fini(struct nouveau_object *object, bool suspend)
+_nvkm_output_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nvkm_output *outp = (void *)object;
 	nv_ofuncs(outp->conn)->fini(nv_object(outp->conn), suspend);
-	return nouveau_object_fini(&outp->base, suspend);
+	return nvkm_object_fini(&outp->base, suspend);
 }
 
 int
-_nvkm_output_init(struct nouveau_object *object)
+_nvkm_output_init(struct nvkm_object *object)
 {
 	struct nvkm_output *outp = (void *)object;
-	int ret = nouveau_object_init(&outp->base);
+	int ret = nvkm_object_init(&outp->base);
 	if (ret == 0)
 		nv_ofuncs(outp->conn)->init(nv_object(outp->conn));
 	return 0;
 }
 
 void
-_nvkm_output_dtor(struct nouveau_object *object)
+_nvkm_output_dtor(struct nvkm_object *object)
 {
 	struct nvkm_output *outp = (void *)object;
 	list_del(&outp->head);
-	nouveau_object_ref(NULL, (void *)&outp->conn);
-	nouveau_object_destroy(&outp->base);
+	nvkm_object_ref(NULL, (void *)&outp->conn);
+	nvkm_object_destroy(&outp->base);
 }
 
 int
-nvkm_output_create_(struct nouveau_object *parent,
-		    struct nouveau_object *engine,
-		    struct nouveau_oclass *oclass,
+nvkm_output_create_(struct nvkm_object *parent,
+		    struct nvkm_object *engine,
+		    struct nvkm_oclass *oclass,
 		    struct dcb_output *dcbE, int index,
 		    int length, void **pobject)
 {
-	struct nouveau_disp *disp = nouveau_disp(parent);
-	struct nouveau_bios *bios = nouveau_bios(parent);
-	struct nouveau_i2c *i2c = nouveau_i2c(parent);
+	struct nvkm_disp *disp = nvkm_disp(parent);
+	struct nvkm_bios *bios = nvkm_bios(parent);
+	struct nvkm_i2c *i2c = nvkm_i2c(parent);
 	struct nvbios_connE connE;
 	struct nvkm_output *outp;
 	u8  ver, hdr;
 	u32 data;
 	int ret;
 
-	ret = nouveau_object_create_(parent, engine, oclass, 0, length, pobject);
+	ret = nvkm_object_create_(parent, engine, oclass, 0, length, pobject);
 	outp = *pobject;
 	if (ret)
 		return ret;
@@ -98,9 +99,9 @@ nvkm_output_create_(struct nouveau_object *parent,
 		connE.type = DCB_CONNECTOR_NONE;
 	}
 
-	ret = nouveau_object_ctor(parent, NULL, nvkm_connector_oclass,
-				 &connE, outp->info.connector,
-				 (struct nouveau_object **)&outp->conn);
+	ret = nvkm_object_ctor(parent, NULL, nvkm_connector_oclass,
+			       &connE, outp->info.connector,
+			       (struct nvkm_object **)&outp->conn);
 	if (ret < 0) {
 		ERR("error %d creating connector, disabling\n", ret);
 		return ret;
@@ -111,10 +112,10 @@ nvkm_output_create_(struct nouveau_object *parent,
 }
 
 int
-_nvkm_output_ctor(struct nouveau_object *parent,
-		  struct nouveau_object *engine,
-		  struct nouveau_oclass *oclass, void *dcbE, u32 index,
-		  struct nouveau_object **pobject)
+_nvkm_output_ctor(struct nvkm_object *parent,
+		  struct nvkm_object *engine,
+		  struct nvkm_oclass *oclass, void *dcbE, u32 index,
+		  struct nvkm_object **pobject)
 {
 	struct nvkm_output *outp;
 	int ret;
@@ -127,11 +128,11 @@ _nvkm_output_ctor(struct nouveau_object *parent,
 	return 0;
 }
 
-struct nouveau_oclass *
+struct nvkm_oclass *
 nvkm_output_oclass = &(struct nvkm_output_impl) {
 	.base = {
 		.handle = 0,
-		.ofuncs = &(struct nouveau_ofuncs) {
+		.ofuncs = &(struct nvkm_ofuncs) {
 			.ctor = _nvkm_output_ctor,
 			.dtor = _nvkm_output_dtor,
 			.init = _nvkm_output_init,

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
new file mode 100644
index 000000000000..c5589c26e07d
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c
@@ -0,0 +1,141 @@
+/*
+ * Copyright 2014 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <subdev/i2c.h>
+#include <subdev/bios.h>
+#include <subdev/bios/conn.h>
+
+#include "outp.h"
+
+int
+_nvkm_output_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nvkm_output *outp = (void *)object;
+	nv_ofuncs(outp->conn)->fini(nv_object(outp->conn), suspend);
+	return nouveau_object_fini(&outp->base, suspend);
+}
+
+int
+_nvkm_output_init(struct nouveau_object *object)
+{
+	struct nvkm_output *outp = (void *)object;
+	int ret = nouveau_object_init(&outp->base);
+	if (ret == 0)
+		nv_ofuncs(outp->conn)->init(nv_object(outp->conn));
+	return 0;
+}
+
+void
+_nvkm_output_dtor(struct nouveau_object *object)
+{
+	struct nvkm_output *outp = (void *)object;
+	list_del(&outp->head);
+	nouveau_object_ref(NULL, (void *)&outp->conn);
+	nouveau_object_destroy(&outp->base);
+}
+
+int
+nvkm_output_create_(struct nouveau_object *parent,
+		    struct nouveau_object *engine,
+		    struct nouveau_oclass *oclass,
+		    struct dcb_output *dcbE, int index,
+		    int length, void **pobject)
+{
+	struct nouveau_disp *disp = nouveau_disp(parent);
+	struct nouveau_bios *bios = nouveau_bios(parent);
+	struct nouveau_i2c *i2c = nouveau_i2c(parent);
+	struct nvbios_connE connE;
+	struct nvkm_output *outp;
+	u8  ver, hdr;
+	u32 data;
+	int ret;
+
+	ret = nouveau_object_create_(parent, engine, oclass, 0, length, pobject);
+	outp = *pobject;
+	if (ret)
+		return ret;
+
+	outp->info = *dcbE;
+	outp->index = index;
+	outp->or = ffs(outp->info.or) - 1;
+
+	DBG("type %02x loc %d or %d link %d con %x edid %x bus %d head %x\n",
+	    dcbE->type, dcbE->location, dcbE->or, dcbE->type >= 2 ?
+	    dcbE->sorconf.link : 0, dcbE->connector, dcbE->i2c_index,
+	    dcbE->bus, dcbE->heads);
+
+	if (outp->info.type != DCB_OUTPUT_DP)
+		outp->port = i2c->find(i2c, NV_I2C_PORT(outp->info.i2c_index));
+	else
+		outp->port = i2c->find(i2c, NV_I2C_AUX(outp->info.i2c_index));
+	outp->edid = outp->port;
+
+	data = nvbios_connEp(bios, outp->info.connector, &ver, &hdr, &connE);
+	if (!data) {
+		DBG("vbios connector data not found\n");
+		memset(&connE, 0x00, sizeof(connE));
+		connE.type = DCB_CONNECTOR_NONE;
+	}
+
+	ret = nouveau_object_ctor(parent, NULL, nvkm_connector_oclass,
+				 &connE, outp->info.connector,
+				 (struct nouveau_object **)&outp->conn);
+	if (ret < 0) {
+		ERR("error %d creating connector, disabling\n", ret);
+		return ret;
+	}
+
+	list_add_tail(&outp->head, &disp->outp);
+	return 0;
+}
+
+int
+_nvkm_output_ctor(struct nouveau_object *parent,
+		  struct nouveau_object *engine,
+		  struct nouveau_oclass *oclass, void *dcbE, u32 index,
+		  struct nouveau_object **pobject)
+{
+	struct nvkm_output *outp;
+	int ret;
+
+	ret = nvkm_output_create(parent, engine, oclass, dcbE, index, &outp);
+	*pobject = nv_object(outp);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+struct nouveau_oclass *
+nvkm_output_oclass = &(struct nvkm_output_impl) {
+	.base = {
+		.handle = 0,
+		.ofuncs = &(struct nouveau_ofuncs) {
+			.ctor = _nvkm_output_ctor,
+			.dtor = _nvkm_output_dtor,
+			.init = _nvkm_output_init,
+			.fini = _nvkm_output_fini,
+		},
+	},
+}.base;
