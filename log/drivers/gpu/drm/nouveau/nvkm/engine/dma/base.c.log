commit 83e85d91b2bc38d4067baf05a7fe9e47436e1d8c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 17 19:40:29 2016 +1000

    drm/nouveau/dma: lookup objects with nvkm_object_search()
    
    Custom code is no longer needed here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
index 4655d1750b95..11b7b8fd5dda 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
@@ -28,24 +28,6 @@
 
 #include <nvif/class.h>
 
-struct nvkm_dmaobj *
-nvkm_dma_search(struct nvkm_dma *dma, struct nvkm_client *client, u64 object)
-{
-	struct rb_node *node = client->dmaroot.rb_node;
-	while (node) {
-		struct nvkm_dmaobj *dmaobj =
-			rb_entry(node, typeof(*dmaobj), rb);
-		if (object < dmaobj->handle)
-			node = node->rb_left;
-		else
-		if (object > dmaobj->handle)
-			node = node->rb_right;
-		else
-			return dmaobj;
-	}
-	return NULL;
-}
-
 static int
 nvkm_dma_oclass_new(struct nvkm_device *device,
 		    const struct nvkm_oclass *oclass, void *data, u32 size,
@@ -53,34 +35,12 @@ nvkm_dma_oclass_new(struct nvkm_device *device,
 {
 	struct nvkm_dma *dma = nvkm_dma(oclass->engine);
 	struct nvkm_dmaobj *dmaobj = NULL;
-	struct nvkm_client *client = oclass->client;
-	struct rb_node **ptr = &client->dmaroot.rb_node;
-	struct rb_node *parent = NULL;
 	int ret;
 
 	ret = dma->func->class_new(dma, oclass, data, size, &dmaobj);
 	if (dmaobj)
 		*pobject = &dmaobj->object;
-	if (ret)
-		return ret;
-
-	dmaobj->handle = oclass->object;
-
-	while (*ptr) {
-		struct nvkm_dmaobj *obj = rb_entry(*ptr, typeof(*obj), rb);
-		parent = *ptr;
-		if (dmaobj->handle < obj->handle)
-			ptr = &parent->rb_left;
-		else
-		if (dmaobj->handle > obj->handle)
-			ptr = &parent->rb_right;
-		else
-			return -EEXIST;
-	}
-
-	rb_link_node(&dmaobj->rb, parent, ptr);
-	rb_insert_color(&dmaobj->rb, &client->dmaroot);
-	return 0;
+	return ret;
 }
 
 static const struct nvkm_device_oclass

commit 05073caeedd1ea6bfc5b1ebd051f2a6694e4b26b
Author: Geliang Tang <geliangtang@gmail.com>
Date:   Tue Dec 20 22:02:11 2016 +0800

    drm/nouveau/dma: use rb_entry()
    
    To make the code clearer, use rb_entry() instead of container_of() to
    deal with rbtree.
    
    Signed-off-by: Geliang Tang <geliangtang@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
index f11ebdd16c77..4655d1750b95 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
@@ -34,7 +34,7 @@ nvkm_dma_search(struct nvkm_dma *dma, struct nvkm_client *client, u64 object)
 	struct rb_node *node = client->dmaroot.rb_node;
 	while (node) {
 		struct nvkm_dmaobj *dmaobj =
-			container_of(node, typeof(*dmaobj), rb);
+			rb_entry(node, typeof(*dmaobj), rb);
 		if (object < dmaobj->handle)
 			node = node->rb_left;
 		else
@@ -67,7 +67,7 @@ nvkm_dma_oclass_new(struct nvkm_device *device,
 	dmaobj->handle = oclass->object;
 
 	while (*ptr) {
-		struct nvkm_dmaobj *obj = container_of(*ptr, typeof(*obj), rb);
+		struct nvkm_dmaobj *obj = rb_entry(*ptr, typeof(*obj), rb);
 		parent = *ptr;
 		if (dmaobj->handle < obj->handle)
 			ptr = &parent->rb_left;

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
index 9769fc0d5351..f11ebdd16c77 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
@@ -152,6 +152,5 @@ nvkm_dma_new_(const struct nvkm_dma_func *func, struct nvkm_device *device,
 		return -ENOMEM;
 	dma->func = func;
 
-	return nvkm_engine_ctor(&nvkm_dma, device, index,
-				0, true, &dma->engine);
+	return nvkm_engine_ctor(&nvkm_dma, device, index, true, &dma->engine);
 }

commit bd70563f015a5204c62a52a87a35c32377940187
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:21 2015 +1000

    drm/nouveau/dma: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
index 1a377201949c..9769fc0d5351 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
@@ -52,14 +52,13 @@ nvkm_dma_oclass_new(struct nvkm_device *device,
 		    struct nvkm_object **pobject)
 {
 	struct nvkm_dma *dma = nvkm_dma(oclass->engine);
-	struct nvkm_dma_impl *impl = (void *)dma->engine.subdev.object.oclass;
 	struct nvkm_dmaobj *dmaobj = NULL;
 	struct nvkm_client *client = oclass->client;
 	struct rb_node **ptr = &client->dmaroot.rb_node;
 	struct rb_node *parent = NULL;
 	int ret;
 
-	ret = impl->class_new(dma, oclass, data, size, &dmaobj);
+	ret = dma->func->class_new(dma, oclass, data, size, &dmaobj);
 	if (dmaobj)
 		*pobject = &dmaobj->object;
 	if (ret)
@@ -130,26 +129,29 @@ nvkm_dma_oclass_fifo_get(struct nvkm_oclass *oclass, int index)
 	return count;
 }
 
+static void *
+nvkm_dma_dtor(struct nvkm_engine *engine)
+{
+	return nvkm_dma(engine);
+}
+
 static const struct nvkm_engine_func
 nvkm_dma = {
+	.dtor = nvkm_dma_dtor,
 	.base.sclass = nvkm_dma_oclass_base_get,
 	.fifo.sclass = nvkm_dma_oclass_fifo_get,
 };
 
 int
-_nvkm_dma_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-		  struct nvkm_oclass *oclass, void *data, u32 size,
-		  struct nvkm_object **pobject)
+nvkm_dma_new_(const struct nvkm_dma_func *func, struct nvkm_device *device,
+	      int index, struct nvkm_dma **pdma)
 {
-	struct nvkm_dma *dmaeng;
-	int ret;
+	struct nvkm_dma *dma;
 
-	ret = nvkm_engine_create(parent, engine, oclass, true, "DMAOBJ",
-				 "dmaobj", &dmaeng);
-	*pobject = nv_object(dmaeng);
-	if (ret)
-		return ret;
+	if (!(dma = *pdma = kzalloc(sizeof(*dma), GFP_KERNEL)))
+		return -ENOMEM;
+	dma->func = func;
 
-	dmaeng->engine.func = &nvkm_dma;
-	return 0;
+	return nvkm_engine_ctor(&nvkm_dma, device, index,
+				0, true, &dma->engine);
 }

commit 8f0649b5c6e70ec18122255690e39f010c12a614
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/fifo: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
index 57f6eca078ef..1a377201949c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
@@ -24,6 +24,7 @@
 #include "priv.h"
 
 #include <core/client.h>
+#include <engine/fifo.h>
 
 #include <nvif/class.h>
 
@@ -88,11 +89,19 @@ nvkm_dma_oclass_base = {
 	.ctor = nvkm_dma_oclass_new,
 };
 
+static int
+nvkm_dma_oclass_fifo_new(const struct nvkm_oclass *oclass, void *data, u32 size,
+			 struct nvkm_object **pobject)
+{
+	return nvkm_dma_oclass_new(oclass->engine->subdev.device,
+				   oclass, data, size, pobject);
+}
+
 static const struct nvkm_sclass
 nvkm_dma_sclass[] = {
-	{ 0, 0, NV_DMA_FROM_MEMORY },
-	{ 0, 0, NV_DMA_TO_MEMORY },
-	{ 0, 0, NV_DMA_IN_MEMORY },
+	{ 0, 0, NV_DMA_FROM_MEMORY, NULL, nvkm_dma_oclass_fifo_new },
+	{ 0, 0, NV_DMA_TO_MEMORY, NULL, nvkm_dma_oclass_fifo_new },
+	{ 0, 0, NV_DMA_IN_MEMORY, NULL, nvkm_dma_oclass_fifo_new },
 };
 
 static int
@@ -110,89 +119,21 @@ nvkm_dma_oclass_base_get(struct nvkm_oclass *sclass, int index,
 	return count;
 }
 
-static const struct nvkm_engine_func
-nvkm_dma = {
-	.base.sclass = nvkm_dma_oclass_base_get,
-};
-
-#include <core/gpuobj.h>
-
-static struct nvkm_oclass empty = {
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.dtor = nvkm_object_destroy,
-		.init = _nvkm_object_init,
-		.fini = _nvkm_object_fini,
-	},
-};
-
 static int
-nvkm_dmaobj_compat_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-			struct nvkm_oclass *oclass, void *data, u32 size,
-			struct nvkm_object **pobject)
-{
-	struct nvkm_oclass hack = {
-		.base.oclass = oclass->handle,
-		.client = nvkm_client(parent),
-		.parent = parent,
-		.engine = nv_engine(engine),
-	};
-	struct nvkm_dma *dma = (void *)engine;
-	struct nvkm_dma_impl *impl = (void *)dma->engine.subdev.object.oclass;
-	struct nvkm_dmaobj *dmaobj = NULL;
-	struct nvkm_gpuobj *gpuobj;
-	int ret;
-
-	ret = impl->class_new(dma, &hack, data, size, &dmaobj);
-	if (dmaobj)
-		*pobject = &dmaobj->object;
-	if (ret)
-		return ret;
-
-	gpuobj = (void *)nv_pclass(parent, NV_GPUOBJ_CLASS);
-
-	ret = dmaobj->func->bind(dmaobj, gpuobj, 16, &gpuobj);
-	nvkm_object_ref(NULL, pobject);
-	if (ret)
-		return ret;
-
-	ret = nvkm_object_create(parent, engine, &empty, 0, pobject);
-	if (ret)
-		return ret;
-
-	gpuobj->object.parent = *pobject;
-	gpuobj->object.engine = &dma->engine;
-	gpuobj->object.oclass = oclass;
-	gpuobj->object.pclass = NV_GPUOBJ_CLASS;
-#if CONFIG_NOUVEAU_DEBUG >= NV_DBG_PARANOIA
-	gpuobj->object._magic = NVKM_OBJECT_MAGIC;
-#endif
-	*pobject = &gpuobj->object;
-	return 0;
-}
-
-static void
-nvkm_dmaobj_compat_dtor(struct nvkm_object *object)
+nvkm_dma_oclass_fifo_get(struct nvkm_oclass *oclass, int index)
 {
-	struct nvkm_object *parent = object->parent;
-	struct nvkm_gpuobj *gpuobj = (void *)object;
-	nvkm_gpuobj_del(&gpuobj);
-	nvkm_object_ref(NULL, &parent);
+	const int count = ARRAY_SIZE(nvkm_dma_sclass);
+	if (index < count) {
+		oclass->base = nvkm_dma_sclass[index];
+		return index;
+	}
+	return count;
 }
 
-static struct nvkm_ofuncs
-nvkm_dmaobj_compat_ofuncs = {
-	.ctor = nvkm_dmaobj_compat_ctor,
-	.dtor = nvkm_dmaobj_compat_dtor,
-	.init = _nvkm_object_init,
-	.fini = _nvkm_object_fini,
-};
-
-static struct nvkm_oclass
-nvkm_dma_compat_sclass[] = {
-	{ NV_DMA_FROM_MEMORY, &nvkm_dmaobj_compat_ofuncs },
-	{ NV_DMA_TO_MEMORY, &nvkm_dmaobj_compat_ofuncs },
-	{ NV_DMA_IN_MEMORY, &nvkm_dmaobj_compat_ofuncs },
-	{}
+static const struct nvkm_engine_func
+nvkm_dma = {
+	.base.sclass = nvkm_dma_oclass_base_get,
+	.fifo.sclass = nvkm_dma_oclass_fifo_get,
 };
 
 int
@@ -209,7 +150,6 @@ _nvkm_dma_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	dmaeng->engine.sclass = nvkm_dma_compat_sclass;
 	dmaeng->engine.func = &nvkm_dma;
 	return 0;
 }

commit 0710cc31482ae3711367c42e61580126c50c8ec0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/dma: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
index a48978d39843..57f6eca078ef 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
@@ -24,77 +24,182 @@
 #include "priv.h"
 
 #include <core/client.h>
-#include <core/gpuobj.h>
 
-struct hack {
-	struct nvkm_gpuobj object;
-	struct nvkm_gpuobj *parent;
+#include <nvif/class.h>
+
+struct nvkm_dmaobj *
+nvkm_dma_search(struct nvkm_dma *dma, struct nvkm_client *client, u64 object)
+{
+	struct rb_node *node = client->dmaroot.rb_node;
+	while (node) {
+		struct nvkm_dmaobj *dmaobj =
+			container_of(node, typeof(*dmaobj), rb);
+		if (object < dmaobj->handle)
+			node = node->rb_left;
+		else
+		if (object > dmaobj->handle)
+			node = node->rb_right;
+		else
+			return dmaobj;
+	}
+	return NULL;
+}
+
+static int
+nvkm_dma_oclass_new(struct nvkm_device *device,
+		    const struct nvkm_oclass *oclass, void *data, u32 size,
+		    struct nvkm_object **pobject)
+{
+	struct nvkm_dma *dma = nvkm_dma(oclass->engine);
+	struct nvkm_dma_impl *impl = (void *)dma->engine.subdev.object.oclass;
+	struct nvkm_dmaobj *dmaobj = NULL;
+	struct nvkm_client *client = oclass->client;
+	struct rb_node **ptr = &client->dmaroot.rb_node;
+	struct rb_node *parent = NULL;
+	int ret;
+
+	ret = impl->class_new(dma, oclass, data, size, &dmaobj);
+	if (dmaobj)
+		*pobject = &dmaobj->object;
+	if (ret)
+		return ret;
+
+	dmaobj->handle = oclass->object;
+
+	while (*ptr) {
+		struct nvkm_dmaobj *obj = container_of(*ptr, typeof(*obj), rb);
+		parent = *ptr;
+		if (dmaobj->handle < obj->handle)
+			ptr = &parent->rb_left;
+		else
+		if (dmaobj->handle > obj->handle)
+			ptr = &parent->rb_right;
+		else
+			return -EEXIST;
+	}
+
+	rb_link_node(&dmaobj->rb, parent, ptr);
+	rb_insert_color(&dmaobj->rb, &client->dmaroot);
+	return 0;
+}
+
+static const struct nvkm_device_oclass
+nvkm_dma_oclass_base = {
+	.ctor = nvkm_dma_oclass_new,
 };
 
-static void
-dtor(struct nvkm_object *object)
+static const struct nvkm_sclass
+nvkm_dma_sclass[] = {
+	{ 0, 0, NV_DMA_FROM_MEMORY },
+	{ 0, 0, NV_DMA_TO_MEMORY },
+	{ 0, 0, NV_DMA_IN_MEMORY },
+};
+
+static int
+nvkm_dma_oclass_base_get(struct nvkm_oclass *sclass, int index,
+			 const struct nvkm_device_oclass **class)
 {
-	struct hack *hack = (void *)object;
-	nvkm_gpuobj_del(&hack->parent);
-	nvkm_object_destroy(&hack->object.object);
+	const int count = ARRAY_SIZE(nvkm_dma_sclass);
+	if (index < count) {
+		const struct nvkm_sclass *oclass = &nvkm_dma_sclass[index];
+		sclass->base = oclass[0];
+		sclass->engn = oclass;
+		*class = &nvkm_dma_oclass_base;
+		return index;
+	}
+	return count;
 }
 
-static struct nvkm_oclass
-hack = {
-	.handle = NV_GPUOBJ_CLASS,
+static const struct nvkm_engine_func
+nvkm_dma = {
+	.base.sclass = nvkm_dma_oclass_base_get,
+};
+
+#include <core/gpuobj.h>
+
+static struct nvkm_oclass empty = {
 	.ofuncs = &(struct nvkm_ofuncs) {
-		.dtor = dtor,
+		.dtor = nvkm_object_destroy,
 		.init = _nvkm_object_init,
 		.fini = _nvkm_object_fini,
 	},
 };
 
 static int
-nvkm_dmaobj_bind(struct nvkm_dmaobj *dmaobj, struct nvkm_gpuobj *pargpu,
-		 struct nvkm_gpuobj **pgpuobj)
+nvkm_dmaobj_compat_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+			struct nvkm_oclass *oclass, void *data, u32 size,
+			struct nvkm_object **pobject)
 {
-	const struct nvkm_dma_impl *impl = (void *)
-		nv_oclass(nv_object(dmaobj)->engine);
-	int ret = 0;
+	struct nvkm_oclass hack = {
+		.base.oclass = oclass->handle,
+		.client = nvkm_client(parent),
+		.parent = parent,
+		.engine = nv_engine(engine),
+	};
+	struct nvkm_dma *dma = (void *)engine;
+	struct nvkm_dma_impl *impl = (void *)dma->engine.subdev.object.oclass;
+	struct nvkm_dmaobj *dmaobj = NULL;
+	struct nvkm_gpuobj *gpuobj;
+	int ret;
 
-	if (&dmaobj->base == &pargpu->object) { /* ctor bind */
-		struct nvkm_object *parent = (void *)pargpu;
-		struct hack *object;
+	ret = impl->class_new(dma, &hack, data, size, &dmaobj);
+	if (dmaobj)
+		*pobject = &dmaobj->object;
+	if (ret)
+		return ret;
 
-		if (parent->parent->parent == &nvkm_client(parent)->object) {
-			/* delayed, or no, binding */
-			return 0;
-		}
+	gpuobj = (void *)nv_pclass(parent, NV_GPUOBJ_CLASS);
 
-		pargpu = (void *)nv_pclass((void *)pargpu, NV_GPUOBJ_CLASS);
+	ret = dmaobj->func->bind(dmaobj, gpuobj, 16, &gpuobj);
+	nvkm_object_ref(NULL, pobject);
+	if (ret)
+		return ret;
 
-		ret = nvkm_object_create(parent, NULL, &hack, NV_GPUOBJ_CLASS, &object);
-		if (ret == 0) {
-			nvkm_object_ref(NULL, &parent);
-			*pgpuobj = &object->object;
+	ret = nvkm_object_create(parent, engine, &empty, 0, pobject);
+	if (ret)
+		return ret;
 
-			ret = impl->bind(dmaobj, pargpu, &object->parent);
-			if (ret)
-				return ret;
+	gpuobj->object.parent = *pobject;
+	gpuobj->object.engine = &dma->engine;
+	gpuobj->object.oclass = oclass;
+	gpuobj->object.pclass = NV_GPUOBJ_CLASS;
+#if CONFIG_NOUVEAU_DEBUG >= NV_DBG_PARANOIA
+	gpuobj->object._magic = NVKM_OBJECT_MAGIC;
+#endif
+	*pobject = &gpuobj->object;
+	return 0;
+}
 
-			object->object.node = object->parent->node;
-			object->object.addr = object->parent->addr;
-			object->object.size = object->parent->size;
-			return 0;
-		}
+static void
+nvkm_dmaobj_compat_dtor(struct nvkm_object *object)
+{
+	struct nvkm_object *parent = object->parent;
+	struct nvkm_gpuobj *gpuobj = (void *)object;
+	nvkm_gpuobj_del(&gpuobj);
+	nvkm_object_ref(NULL, &parent);
+}
 
-		return ret;
-	}
+static struct nvkm_ofuncs
+nvkm_dmaobj_compat_ofuncs = {
+	.ctor = nvkm_dmaobj_compat_ctor,
+	.dtor = nvkm_dmaobj_compat_dtor,
+	.init = _nvkm_object_init,
+	.fini = _nvkm_object_fini,
+};
 
-	return impl->bind(dmaobj, pargpu, pgpuobj);
-}
+static struct nvkm_oclass
+nvkm_dma_compat_sclass[] = {
+	{ NV_DMA_FROM_MEMORY, &nvkm_dmaobj_compat_ofuncs },
+	{ NV_DMA_TO_MEMORY, &nvkm_dmaobj_compat_ofuncs },
+	{ NV_DMA_IN_MEMORY, &nvkm_dmaobj_compat_ofuncs },
+	{}
+};
 
 int
 _nvkm_dma_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		  struct nvkm_oclass *oclass, void *data, u32 size,
 		  struct nvkm_object **pobject)
 {
-	const struct nvkm_dma_impl *impl = (void *)oclass;
 	struct nvkm_dma *dmaeng;
 	int ret;
 
@@ -104,7 +209,7 @@ _nvkm_dma_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	nv_engine(dmaeng)->sclass = impl->sclass;
-	dmaeng->bind = nvkm_dmaobj_bind;
+	dmaeng->engine.sclass = nvkm_dma_compat_sclass;
+	dmaeng->engine.func = &nvkm_dma;
 	return 0;
 }

commit 19fef52d93518cc01fd284b55ee93c0a9967634f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/dma: split user classes out from engine implementations
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
new file mode 100644
index 000000000000..a48978d39843
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/dma/base.c
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+#include "priv.h"
+
+#include <core/client.h>
+#include <core/gpuobj.h>
+
+struct hack {
+	struct nvkm_gpuobj object;
+	struct nvkm_gpuobj *parent;
+};
+
+static void
+dtor(struct nvkm_object *object)
+{
+	struct hack *hack = (void *)object;
+	nvkm_gpuobj_del(&hack->parent);
+	nvkm_object_destroy(&hack->object.object);
+}
+
+static struct nvkm_oclass
+hack = {
+	.handle = NV_GPUOBJ_CLASS,
+	.ofuncs = &(struct nvkm_ofuncs) {
+		.dtor = dtor,
+		.init = _nvkm_object_init,
+		.fini = _nvkm_object_fini,
+	},
+};
+
+static int
+nvkm_dmaobj_bind(struct nvkm_dmaobj *dmaobj, struct nvkm_gpuobj *pargpu,
+		 struct nvkm_gpuobj **pgpuobj)
+{
+	const struct nvkm_dma_impl *impl = (void *)
+		nv_oclass(nv_object(dmaobj)->engine);
+	int ret = 0;
+
+	if (&dmaobj->base == &pargpu->object) { /* ctor bind */
+		struct nvkm_object *parent = (void *)pargpu;
+		struct hack *object;
+
+		if (parent->parent->parent == &nvkm_client(parent)->object) {
+			/* delayed, or no, binding */
+			return 0;
+		}
+
+		pargpu = (void *)nv_pclass((void *)pargpu, NV_GPUOBJ_CLASS);
+
+		ret = nvkm_object_create(parent, NULL, &hack, NV_GPUOBJ_CLASS, &object);
+		if (ret == 0) {
+			nvkm_object_ref(NULL, &parent);
+			*pgpuobj = &object->object;
+
+			ret = impl->bind(dmaobj, pargpu, &object->parent);
+			if (ret)
+				return ret;
+
+			object->object.node = object->parent->node;
+			object->object.addr = object->parent->addr;
+			object->object.size = object->parent->size;
+			return 0;
+		}
+
+		return ret;
+	}
+
+	return impl->bind(dmaobj, pargpu, pgpuobj);
+}
+
+int
+_nvkm_dma_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+		  struct nvkm_oclass *oclass, void *data, u32 size,
+		  struct nvkm_object **pobject)
+{
+	const struct nvkm_dma_impl *impl = (void *)oclass;
+	struct nvkm_dma *dmaeng;
+	int ret;
+
+	ret = nvkm_engine_create(parent, engine, oclass, true, "DMAOBJ",
+				 "dmaobj", &dmaeng);
+	*pobject = nv_object(dmaeng);
+	if (ret)
+		return ret;
+
+	nv_engine(dmaeng)->sclass = impl->sclass;
+	dmaeng->bind = nvkm_dmaobj_bind;
+	return 0;
+}
