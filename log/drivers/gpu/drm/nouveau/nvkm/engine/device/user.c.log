commit 13e957290647eafe75cfa46a5f1aaa2282d9a09c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:48 2018 +1000

    drm/nouveau/fault/gp100: expose MaxwellFaultBufferA
    
    This nvclass exposes the replayable fault buffer, which will be used
    by SVM to manage GPU page faults.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index 092ddc4ffefa..03c6d9aef075 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -365,16 +365,15 @@ nvkm_udevice_child_get(struct nvkm_object *object, int index,
 	}
 
 	if (!sclass) {
-		switch (index) {
-		case 0: sclass = &nvkm_control_oclass; break;
-		case 1:
-			if (!device->mmu)
-				return -EINVAL;
+		if (index-- == 0)
+			sclass = &nvkm_control_oclass;
+		else if (device->mmu && index-- == 0)
 			sclass = &device->mmu->user;
-			break;
-		default:
+		else if (device->fault && index-- == 0)
+			sclass = &device->fault->user;
+		else
 			return -EINVAL;
-		}
+
 		oclass->base = sclass->base;
 	}
 

commit 344d9c8f35b99bbb893d0e2bce5f41b72f9b5f26
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Dec 11 14:50:02 2018 +1000

    drm/nouveau/core: recognise TU104
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index 91072836e816..092ddc4ffefa 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -175,6 +175,7 @@ nvkm_udevice_info(struct nvkm_udevice *udev, void *data, u32 size)
 	case GM100: args->v0.family = NV_DEVICE_INFO_V0_MAXWELL; break;
 	case GP100: args->v0.family = NV_DEVICE_INFO_V0_PASCAL; break;
 	case GV100: args->v0.family = NV_DEVICE_INFO_V0_VOLTA; break;
+	case TU100: args->v0.family = NV_DEVICE_INFO_V0_TURING; break;
 	default:
 		args->v0.family = 0;
 		break;

commit 936a1678f3f8b3c918185f0c5ba3a03ccedfb8d5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Dec 11 14:50:02 2018 +1000

    drm/nouveau/core: support multiple nvdec instances
    
    Turing GPUs can have more than one.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index dde6bbafa709..91072836e816 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -91,7 +91,7 @@ nvkm_udevice_info_v1(struct nvkm_device *device,
 	case ENGINE_A(MSENC ); break;
 	case ENGINE_A(VIC   ); break;
 	case ENGINE_A(SEC2  ); break;
-	case ENGINE_A(NVDEC ); break;
+	case ENGINE_B(NVDEC ); break;
 	case ENGINE_B(NVENC ); break;
 	default:
 		args->mthd = NV_DEVICE_INFO_INVALID;

commit c1f856bb99499f82420d74886884d193e9d63db7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:47 2018 +1000

    drm/nouveau/core: recognise gv100
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index 600bdb870462..dde6bbafa709 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -174,6 +174,7 @@ nvkm_udevice_info(struct nvkm_udevice *udev, void *data, u32 size)
 	case NV_E0: args->v0.family = NV_DEVICE_INFO_V0_KEPLER; break;
 	case GM100: args->v0.family = NV_DEVICE_INFO_V0_MAXWELL; break;
 	case GP100: args->v0.family = NV_DEVICE_INFO_V0_PASCAL; break;
+	case GV100: args->v0.family = NV_DEVICE_INFO_V0_VOLTA; break;
 	default:
 		args->v0.family = 0;
 		break;

commit eb47db4f3bb58b0143a911b29417e89f28e1b0c8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/fifo: support channel count query
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index 42a552d314ef..600bdb870462 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -46,6 +46,7 @@ nvkm_udevice_info_subdev(struct nvkm_device *device, u64 mthd, u64 *data)
 	enum nvkm_devidx subidx;
 
 	switch (mthd & NV_DEVICE_INFO_UNIT) {
+	case NV_DEVICE_FIFO(0): subidx = NVKM_ENGINE_FIFO; break;
 	default:
 		return -EINVAL;
 	}

commit 6eb01aa8988873167adc5285f4afef310d01b8fb
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/device: support querying available engines of a specific type
    
    Will be used for fifo runlist selection.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index 3526516765f8..42a552d314ef 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -67,6 +67,31 @@ nvkm_udevice_info_v1(struct nvkm_device *device,
 	}
 
 	switch (args->mthd) {
+#define ENGINE__(A,B,C) NV_DEVICE_INFO_ENGINE_##A: { int _i;                   \
+	for (_i = (B), args->data = 0ULL; _i <= (C); _i++) {                   \
+		if (nvkm_device_engine(device, _i))                            \
+			args->data |= BIT_ULL(_i);                             \
+	}                                                                      \
+}
+#define ENGINE_A(A) ENGINE__(A, NVKM_ENGINE_##A   , NVKM_ENGINE_##A)
+#define ENGINE_B(A) ENGINE__(A, NVKM_ENGINE_##A##0, NVKM_ENGINE_##A##_LAST)
+	case ENGINE_A(SW    ); break;
+	case ENGINE_A(GR    ); break;
+	case ENGINE_A(MPEG  ); break;
+	case ENGINE_A(ME    ); break;
+	case ENGINE_A(CIPHER); break;
+	case ENGINE_A(BSP   ); break;
+	case ENGINE_A(VP    ); break;
+	case ENGINE_B(CE    ); break;
+	case ENGINE_A(SEC   ); break;
+	case ENGINE_A(MSVLD ); break;
+	case ENGINE_A(MSPDEC); break;
+	case ENGINE_A(MSPPP ); break;
+	case ENGINE_A(MSENC ); break;
+	case ENGINE_A(VIC   ); break;
+	case ENGINE_A(SEC2  ); break;
+	case ENGINE_A(NVDEC ); break;
+	case ENGINE_B(NVENC ); break;
 	default:
 		args->mthd = NV_DEVICE_INFO_INVALID;
 		break;

commit c5c9127b25b2946369877d16b3c208cf54d4bf54
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:46 2018 +1000

    drm/nouveau/device: implement a generic method to query device-specific properties
    
    We have a need to fetch data from GPU-specific sub-devices that is not
    tied to any particular engine object.
    
    This commit provides the framework to support such queries.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index 17adcb4e8854..3526516765f8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -39,6 +39,40 @@ struct nvkm_udevice {
 	struct nvkm_device *device;
 };
 
+static int
+nvkm_udevice_info_subdev(struct nvkm_device *device, u64 mthd, u64 *data)
+{
+	struct nvkm_subdev *subdev;
+	enum nvkm_devidx subidx;
+
+	switch (mthd & NV_DEVICE_INFO_UNIT) {
+	default:
+		return -EINVAL;
+	}
+
+	subdev = nvkm_device_subdev(device, subidx);
+	if (subdev)
+		return nvkm_subdev_info(subdev, mthd, data);
+	return -ENODEV;
+}
+
+static void
+nvkm_udevice_info_v1(struct nvkm_device *device,
+		     struct nv_device_info_v1_data *args)
+{
+	if (args->mthd & NV_DEVICE_INFO_UNIT) {
+		if (nvkm_udevice_info_subdev(device, args->mthd, &args->data))
+			args->mthd = NV_DEVICE_INFO_INVALID;
+		return;
+	}
+
+	switch (args->mthd) {
+	default:
+		args->mthd = NV_DEVICE_INFO_INVALID;
+		break;
+	}
+}
+
 static int
 nvkm_udevice_info(struct nvkm_udevice *udev, void *data, u32 size)
 {
@@ -48,10 +82,21 @@ nvkm_udevice_info(struct nvkm_udevice *udev, void *data, u32 size)
 	struct nvkm_instmem *imem = device->imem;
 	union {
 		struct nv_device_info_v0 v0;
+		struct nv_device_info_v1 v1;
 	} *args = data;
-	int ret = -ENOSYS;
+	int ret = -ENOSYS, i;
 
 	nvif_ioctl(object, "device info size %d\n", size);
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v1, 1, 1, true))) {
+		nvif_ioctl(object, "device info vers %d count %d\n",
+			   args->v1.version, args->v1.count);
+		if (args->v1.count * sizeof(args->v1.data[0]) == size) {
+			for (i = 0; i < args->v1.count; i++)
+				nvkm_udevice_info_v1(device, &args->v1.data[i]);
+			return 0;
+		}
+		return -EINVAL;
+	} else
 	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 		nvif_ioctl(object, "device info vers %d\n", args->v0.version);
 	} else

commit eea5cf0f0170fbc54fbb3c501b0ec7cce7f68369
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/mmu: define user interfaces to mmu
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index e9b90e40f274..17adcb4e8854 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -294,6 +294,11 @@ nvkm_udevice_child_get(struct nvkm_object *object, int index,
 	if (!sclass) {
 		switch (index) {
 		case 0: sclass = &nvkm_control_oclass; break;
+		case 1:
+			if (!device->mmu)
+				return -EINVAL;
+			sclass = &device->mmu->user;
+			break;
 		default:
 			return -EINVAL;
 		}

commit 01326050391ceee2cf1b6c91c108414a35f40861
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/core/object: allow arguments to be passed to map function
    
    MMU will be needing this to specify kind info on BAR mappings.
    
    We have no userspace currently using these interfaces, so break the ABI
    instead of supporting both.  NVIF version bump so any future use can be
    guarded.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index 513ee6b79553..e9b90e40f274 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -206,10 +206,12 @@ nvkm_udevice_wr32(struct nvkm_object *object, u64 addr, u32 data)
 }
 
 static int
-nvkm_udevice_map(struct nvkm_object *object, u64 *addr, u32 *size)
+nvkm_udevice_map(struct nvkm_object *object, void *argv, u32 argc,
+		 enum nvkm_object_map *type, u64 *addr, u64 *size)
 {
 	struct nvkm_udevice *udev = nvkm_udevice(object);
 	struct nvkm_device *device = udev->device;
+	*type = NVKM_OBJECT_MAP_IO;
 	*addr = device->func->resource_addr(device, 0);
 	*size = device->func->resource_size(device, 0);
 	return 0;

commit e08a1d97d33e2ac05cd368b955f9fdc2823f15fd
Author: Baoyou Xie <baoyou.xie@linaro.org>
Date:   Mon Oct 24 11:09:03 2016 +0800

    drm/nouveau: mark symbols static where possible
    
    We get a few warnings when building kernel with W=1:
    drivers/gpu/drm/nouveau/nvkm/subdev/bios/fan.c:29:1: warning: no previous prototype for 'nvbios_fan_table' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/bios/fan.c:56:1: warning: no previous prototype for 'nvbios_fan_entry' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/clk/gt215.c:184:1: warning: no previous prototype for 'gt215_clk_info' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c:99:1: warning: no previous prototype for 'gt215_link_train_calc' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c:153:1: warning: no previous prototype for 'gt215_link_train' [-Wmissing-prototypes]
    drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c:271:1: warning: no previous prototype for 'gt215_link_train_init' [-Wmissing-prototypes]
    ....
    
    In fact, both functions are only used in the file in which they are
    declared and don't need a declaration, but can be made static.
    So this patch marks these functions with 'static'.
    
    Signed-off-by: Baoyou Xie <baoyou.xie@linaro.org>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index 79a8f71cf788..513ee6b79553 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -326,7 +326,7 @@ nvkm_udevice = {
 	.sclass = nvkm_udevice_child_get,
 };
 
-int
+static int
 nvkm_udevice_new(const struct nvkm_oclass *oclass, void *data, u32 size,
 		 struct nvkm_object **pobject)
 {

commit 7f53abdb95d14704d0282ee7b5de65476c29efb0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sat Jul 9 10:41:01 2016 +1000

    drm/nouveau/core: recognise GP100 chipset
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index 137066426ed7..79a8f71cf788 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -102,6 +102,7 @@ nvkm_udevice_info(struct nvkm_udevice *udev, void *data, u32 size)
 	case NV_C0: args->v0.family = NV_DEVICE_INFO_V0_FERMI; break;
 	case NV_E0: args->v0.family = NV_DEVICE_INFO_V0_KEPLER; break;
 	case GM100: args->v0.family = NV_DEVICE_INFO_V0_MAXWELL; break;
+	case GP100: args->v0.family = NV_DEVICE_INFO_V0_PASCAL; break;
 	default:
 		args->v0.family = 0;
 		break;

commit f01c4e682c941ba70e0ebec44db754844a1b9b82
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon Nov 9 09:21:27 2015 +1000

    drm/nouveau/nvif: modify nvif_unvers/nvif_unpack macros to be more obvious
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index 22a2d7632d49..137066426ed7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -49,10 +49,10 @@ nvkm_udevice_info(struct nvkm_udevice *udev, void *data, u32 size)
 	union {
 		struct nv_device_info_v0 v0;
 	} *args = data;
-	int ret;
+	int ret = -ENOSYS;
 
 	nvif_ioctl(object, "device info size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 		nvif_ioctl(object, "device info vers %d\n", args->v0.version);
 	} else
 		return ret;
@@ -124,13 +124,16 @@ nvkm_udevice_info(struct nvkm_udevice *udev, void *data, u32 size)
 static int
 nvkm_udevice_time(struct nvkm_udevice *udev, void *data, u32 size)
 {
+	struct nvkm_object *object = &udev->object;
 	struct nvkm_device *device = udev->device;
 	union {
 		struct nv_device_time_v0 v0;
 	} *args = data;
-	int ret;
+	int ret = -ENOSYS;
 
-	if (nvif_unpack(args->v0, 0, 0, false)) {
+	nvif_ioctl(object, "device time size %d\n", size);
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
+		nvif_ioctl(object, "device time vers %d\n", args->v0.version);
 		args->v0.time = nvkm_timer_read(device->timer);
 	}
 
@@ -141,6 +144,7 @@ static int
 nvkm_udevice_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
 	struct nvkm_udevice *udev = nvkm_udevice(object);
+	nvif_ioctl(object, "device mthd %08x\n", mthd);
 	switch (mthd) {
 	case NV_DEVICE_V0_INFO:
 		return nvkm_udevice_info(udev, data, size);
@@ -332,10 +336,10 @@ nvkm_udevice_new(const struct nvkm_oclass *oclass, void *data, u32 size,
 	struct nvkm_object *parent = &client->object;
 	const struct nvkm_object_func *func;
 	struct nvkm_udevice *udev;
-	int ret;
+	int ret = -ENOSYS;
 
 	nvif_ioctl(parent, "create device size %d\n", size);
-	if (nvif_unpack(args->v0, 0, 0, false)) {
+	if (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {
 		nvif_ioctl(parent, "create device v%d device %016llx\n",
 			   args->v0.version, args->v0.device);
 	} else

commit 923bc416aa1a4be7d31b0388116965245b73c3e4
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Nov 8 12:23:16 2015 +1000

    drm/nouveau/nvif: split out device interface definitions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index 1ae48f27029d..22a2d7632d49 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -31,6 +31,7 @@
 #include <subdev/timer.h>
 
 #include <nvif/class.h>
+#include <nvif/cl0080.h>
 #include <nvif/unpack.h>
 
 struct nvkm_udevice {

commit 26c9e8effebb9166eb1cfba2d164676e98c505c7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:23 2015 +1000

    drm/nouveau/device: remove pci/platform_device from common struct
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index eddf9b1d3340..1ae48f27029d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -70,16 +70,22 @@ nvkm_udevice_info(struct nvkm_udevice *udev, void *data, u32 size)
 		args->v0.platform = NV_DEVICE_INFO_V0_IGP;
 		break;
 	default:
-		if (device->pdev) {
-			if (pci_find_capability(device->pdev, PCI_CAP_ID_AGP))
-				args->v0.platform = NV_DEVICE_INFO_V0_AGP;
-			else
-			if (pci_is_pcie(device->pdev))
-				args->v0.platform = NV_DEVICE_INFO_V0_PCIE;
-			else
-				args->v0.platform = NV_DEVICE_INFO_V0_PCI;
-		} else {
+		switch (device->type) {
+		case NVKM_DEVICE_PCI:
+			args->v0.platform = NV_DEVICE_INFO_V0_PCI;
+			break;
+		case NVKM_DEVICE_AGP:
+			args->v0.platform = NV_DEVICE_INFO_V0_AGP;
+			break;
+		case NVKM_DEVICE_PCIE:
+			args->v0.platform = NV_DEVICE_INFO_V0_PCIE;
+			break;
+		case NVKM_DEVICE_TEGRA:
 			args->v0.platform = NV_DEVICE_INFO_V0_SOC;
+			break;
+		default:
+			WARN_ON(1);
+			break;
 		}
 		break;
 	}

commit 7e8820fed712c6de1933dcc91edbf08dcec74925
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:23 2015 +1000

    drm/nouveau/device: cleaner abstraction for device resource functions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index a948960cc056..eddf9b1d3340 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -198,8 +198,8 @@ nvkm_udevice_map(struct nvkm_object *object, u64 *addr, u32 *size)
 {
 	struct nvkm_udevice *udev = nvkm_udevice(object);
 	struct nvkm_device *device = udev->device;
-	*addr = nv_device_resource_start(device, 0);
-	*size = nv_device_resource_len(device, 0);
+	*addr = device->func->resource_addr(device, 0);
+	*size = device->func->resource_size(device, 0);
 	return 0;
 }
 

commit 68f3f702b6a430a8d1e909455a60d26c0f2da530
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/core: remove the remainder of the previous style
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index a9df61bf3780..a948960cc056 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -261,10 +261,10 @@ nvkm_udevice_child_get(struct nvkm_object *object, int index,
 	struct nvkm_udevice *udev = nvkm_udevice(object);
 	struct nvkm_device *device = udev->device;
 	struct nvkm_engine *engine;
-	u64 mask = (1ULL << NVDEV_ENGINE_DMAOBJ) |
-		   (1ULL << NVDEV_ENGINE_FIFO) |
-		   (1ULL << NVDEV_ENGINE_DISP) |
-		   (1ULL << NVDEV_ENGINE_PM);
+	u64 mask = (1ULL << NVKM_ENGINE_DMAOBJ) |
+		   (1ULL << NVKM_ENGINE_FIFO) |
+		   (1ULL << NVKM_ENGINE_DISP) |
+		   (1ULL << NVKM_ENGINE_PM);
 	const struct nvkm_device_oclass *sclass = NULL;
 	int i;
 

commit 31649ecf47a44e02e73bffc5680c8f56d6cf587a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:21 2015 +1000

    drm/nouveau/tmr: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index c5da091c058c..a9df61bf3780 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -118,14 +118,13 @@ static int
 nvkm_udevice_time(struct nvkm_udevice *udev, void *data, u32 size)
 {
 	struct nvkm_device *device = udev->device;
-	struct nvkm_timer *tmr = device->timer;
 	union {
 		struct nv_device_time_v0 v0;
 	} *args = data;
 	int ret;
 
 	if (nvif_unpack(args->v0, 0, 0, false)) {
-		args->v0.time = tmr->read(tmr);
+		args->v0.time = nvkm_timer_read(device->timer);
 	}
 
 	return ret;

commit ef8bc5760b51d69741ed5f42224f1fdd2935541a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/core: kill some (now) dead code
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index 39f31e2e281b..c5da091c058c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -26,7 +26,6 @@
 #include "ctrl.h"
 
 #include <core/client.h>
-#include <core/parent.h>
 #include <subdev/fb.h>
 #include <subdev/instmem.h>
 #include <subdev/timer.h>
@@ -247,31 +246,6 @@ nvkm_udevice_init(struct nvkm_object *object)
 	return ret;
 }
 
-static int
-nvkm_udevice_child_old(const struct nvkm_oclass *oclass,
-		       void *data, u32 size, struct nvkm_object **pobject)
-{
-	struct nvkm_object *parent = oclass->parent;
-	struct nvkm_engine *engine = oclass->engine;
-	struct nvkm_oclass *eclass = (void *)oclass->priv;
-	struct nvkm_object *engctx = NULL;
-	int ret;
-
-	if (engine->cclass) {
-		ret = nvkm_object_old(parent, &engine->subdev.object,
-				      engine->cclass, NULL, 0, &engctx);
-		if (ret)
-			return ret;
-	} else {
-		nvkm_object_ref(parent, &engctx);
-	}
-
-	ret = nvkm_object_old(engctx, &engine->subdev.object, eclass,
-			      data, size, pobject);
-	nvkm_object_ref(NULL, &engctx);
-	return ret;
-}
-
 static int
 nvkm_udevice_child_new(const struct nvkm_oclass *oclass,
 		       void *data, u32 size, struct nvkm_object **pobject)
@@ -296,26 +270,6 @@ nvkm_udevice_child_get(struct nvkm_object *object, int index,
 	int i;
 
 	for (; i = __ffs64(mask), mask && !sclass; mask &= ~(1ULL << i)) {
-		if ((engine = nvkm_device_engine(device, i)) &&
-		    !engine->func) {
-			struct nvkm_oclass *sclass = engine->sclass;
-			int c = 0;
-			while (sclass && sclass->ofuncs) {
-				if (c++ == index) {
-					oclass->base.oclass = sclass->handle;
-					oclass->base.minver = -2;
-					oclass->base.maxver = -2;
-					oclass->ctor = nvkm_udevice_child_old;
-					oclass->priv = sclass;
-					oclass->engine = engine;
-					return 0;
-				}
-				sclass++;
-			}
-			index -= c;
-			continue;
-		}
-
 		if (!(engine = nvkm_device_engine(device, i)) ||
 		    !(engine->func->base.sclass))
 			continue;

commit 0710cc31482ae3711367c42e61580126c50c8ec0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/dma: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index 58a09f828b7f..39f31e2e281b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -292,11 +292,12 @@ nvkm_udevice_child_get(struct nvkm_object *object, int index,
 		   (1ULL << NVDEV_ENGINE_FIFO) |
 		   (1ULL << NVDEV_ENGINE_DISP) |
 		   (1ULL << NVDEV_ENGINE_PM);
-	const struct nvkm_device_oclass *sclass;
+	const struct nvkm_device_oclass *sclass = NULL;
 	int i;
 
-	for (; i = __ffs64(mask), mask; mask &= ~(1ULL << i)) {
-		if ((engine = nvkm_device_engine(device, i))) {
+	for (; i = __ffs64(mask), mask && !sclass; mask &= ~(1ULL << i)) {
+		if ((engine = nvkm_device_engine(device, i)) &&
+		    !engine->func) {
 			struct nvkm_oclass *sclass = engine->sclass;
 			int c = 0;
 			while (sclass && sclass->ofuncs) {
@@ -312,17 +313,27 @@ nvkm_udevice_child_get(struct nvkm_object *object, int index,
 				sclass++;
 			}
 			index -= c;
+			continue;
 		}
+
+		if (!(engine = nvkm_device_engine(device, i)) ||
+		    !(engine->func->base.sclass))
+			continue;
+		oclass->engine = engine;
+
+		index -= engine->func->base.sclass(oclass, index, &sclass);
 	}
 
-	switch (index) {
-	case 0: sclass = &nvkm_control_oclass; break;
-	default:
-		return -EINVAL;
+	if (!sclass) {
+		switch (index) {
+		case 0: sclass = &nvkm_control_oclass; break;
+		default:
+			return -EINVAL;
+		}
+		oclass->base = sclass->base;
 	}
 
 	oclass->ctor = nvkm_udevice_child_new;
-	oclass->base = sclass->base;
 	oclass->priv = sclass;
 	return 0;
 }

commit 19fef52d93518cc01fd284b55ee93c0a9967634f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/dma: split user classes out from engine implementations
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index d9d15385d0ad..58a09f828b7f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -30,10 +30,6 @@
 #include <subdev/fb.h>
 #include <subdev/instmem.h>
 #include <subdev/timer.h>
-#include <engine/disp.h>
-#include <engine/dmaobj.h>
-#include <engine/fifo.h>
-#include <engine/pm.h>
 
 #include <nvif/class.h>
 #include <nvif/unpack.h>

commit 0e29998a89a6254f5ca9f78167f9ce790d01da45
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/device: convert ctrl class to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index fb4d04dc9340..d9d15385d0ad 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -23,6 +23,7 @@
  */
 #define nvkm_udevice(p) container_of((p), struct nvkm_udevice, object)
 #include "priv.h"
+#include "ctrl.h"
 
 #include <core/client.h>
 #include <core/parent.h>
@@ -280,10 +281,8 @@ nvkm_udevice_child_new(const struct nvkm_oclass *oclass,
 		       void *data, u32 size, struct nvkm_object **pobject)
 {
 	struct nvkm_udevice *udev = nvkm_udevice(oclass->parent);
-	const struct nvkm_oclass *sclass = oclass->priv;
-	return nvkm_object_old(&udev->object, NULL,
-			       (struct nvkm_oclass *)sclass,
-			       data, size, pobject);
+	const struct nvkm_device_oclass *sclass = oclass->priv;
+	return sclass->ctor(udev->device, oclass, data, size, pobject);
 }
 
 static int
@@ -297,6 +296,7 @@ nvkm_udevice_child_get(struct nvkm_object *object, int index,
 		   (1ULL << NVDEV_ENGINE_FIFO) |
 		   (1ULL << NVDEV_ENGINE_DISP) |
 		   (1ULL << NVDEV_ENGINE_PM);
+	const struct nvkm_device_oclass *sclass;
 	int i;
 
 	for (; i = __ffs64(mask), mask; mask &= ~(1ULL << i)) {
@@ -319,16 +319,16 @@ nvkm_udevice_child_get(struct nvkm_object *object, int index,
 		}
 	}
 
-	if (index == 0) {
-		oclass->ctor = nvkm_udevice_child_new;
-		oclass->base.oclass = nvkm_control_oclass[0].handle;
-		oclass->base.minver = -2;
-		oclass->base.maxver = -2;
-		oclass->priv = &nvkm_control_oclass[0];
-		return 0;
+	switch (index) {
+	case 0: sclass = &nvkm_control_oclass; break;
+	default:
+		return -EINVAL;
 	}
 
-	return -EINVAL;
+	oclass->ctor = nvkm_udevice_child_new;
+	oclass->base = sclass->base;
+	oclass->priv = sclass;
+	return 0;
 }
 
 static const struct nvkm_object_func

commit 2a9f847f5d43d15c0401d050cdd77fb4cbe7da06
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/device: convert user class to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index 59b28cbe6634..fb4d04dc9340 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -21,6 +21,7 @@
  *
  * Authors: Ben Skeggs
  */
+#define nvkm_udevice(p) container_of((p), struct nvkm_udevice, object)
 #include "priv.h"
 
 #include <core/client.h>
@@ -28,19 +29,23 @@
 #include <subdev/fb.h>
 #include <subdev/instmem.h>
 #include <subdev/timer.h>
+#include <engine/disp.h>
+#include <engine/dmaobj.h>
+#include <engine/fifo.h>
+#include <engine/pm.h>
 
 #include <nvif/class.h>
 #include <nvif/unpack.h>
 
 struct nvkm_udevice {
-	struct nvkm_parent base;
+	struct nvkm_object object;
 	struct nvkm_device *device;
 };
 
 static int
-nvkm_udevice_info(struct nvkm_object *object, void *data, u32 size)
+nvkm_udevice_info(struct nvkm_udevice *udev, void *data, u32 size)
 {
-	struct nvkm_udevice *udev = (void *)object;
+	struct nvkm_object *object = &udev->object;
 	struct nvkm_device *device = udev->device;
 	struct nvkm_fb *fb = device->fb;
 	struct nvkm_instmem *imem = device->imem;
@@ -114,9 +119,8 @@ nvkm_udevice_info(struct nvkm_object *object, void *data, u32 size)
 }
 
 static int
-nvkm_udevice_time(struct nvkm_object *object, void *data, u32 size)
+nvkm_udevice_time(struct nvkm_udevice *udev, void *data, u32 size)
 {
-	struct nvkm_udevice *udev = (void *)object;
 	struct nvkm_device *device = udev->device;
 	struct nvkm_timer *tmr = device->timer;
 	union {
@@ -134,63 +138,70 @@ nvkm_udevice_time(struct nvkm_object *object, void *data, u32 size)
 static int
 nvkm_udevice_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
+	struct nvkm_udevice *udev = nvkm_udevice(object);
 	switch (mthd) {
 	case NV_DEVICE_V0_INFO:
-		return nvkm_udevice_info(object, data, size);
+		return nvkm_udevice_info(udev, data, size);
 	case NV_DEVICE_V0_TIME:
-		return nvkm_udevice_time(object, data, size);
+		return nvkm_udevice_time(udev, data, size);
 	default:
 		break;
 	}
 	return -EINVAL;
 }
 
-static u8
-nvkm_udevice_rd08(struct nvkm_object *object, u64 addr)
+static int
+nvkm_udevice_rd08(struct nvkm_object *object, u64 addr, u8 *data)
 {
-	struct nvkm_udevice *udev = (void *)object;
-	return nvkm_rd08(udev->device, addr);
+	struct nvkm_udevice *udev = nvkm_udevice(object);
+	*data = nvkm_rd08(udev->device, addr);
+	return 0;
 }
 
-static u16
-nvkm_udevice_rd16(struct nvkm_object *object, u64 addr)
+static int
+nvkm_udevice_rd16(struct nvkm_object *object, u64 addr, u16 *data)
 {
-	struct nvkm_udevice *udev = (void *)object;
-	return nvkm_rd16(udev->device, addr);
+	struct nvkm_udevice *udev = nvkm_udevice(object);
+	*data = nvkm_rd16(udev->device, addr);
+	return 0;
 }
 
-static u32
-nvkm_udevice_rd32(struct nvkm_object *object, u64 addr)
+static int
+nvkm_udevice_rd32(struct nvkm_object *object, u64 addr, u32 *data)
 {
-	struct nvkm_udevice *udev = (void *)object;
-	return nvkm_rd32(udev->device, addr);
+	struct nvkm_udevice *udev = nvkm_udevice(object);
+	*data = nvkm_rd32(udev->device, addr);
+	return 0;
 }
 
-static void
+static int
 nvkm_udevice_wr08(struct nvkm_object *object, u64 addr, u8 data)
 {
-	struct nvkm_udevice *udev = (void *)object;
+	struct nvkm_udevice *udev = nvkm_udevice(object);
 	nvkm_wr08(udev->device, addr, data);
+	return 0;
 }
 
-static void
+static int
 nvkm_udevice_wr16(struct nvkm_object *object, u64 addr, u16 data)
 {
-	struct nvkm_udevice *udev = (void *)object;
+	struct nvkm_udevice *udev = nvkm_udevice(object);
 	nvkm_wr16(udev->device, addr, data);
+	return 0;
 }
 
-static void
+static int
 nvkm_udevice_wr32(struct nvkm_object *object, u64 addr, u32 data)
 {
-	struct nvkm_udevice *udev = (void *)object;
+	struct nvkm_udevice *udev = nvkm_udevice(object);
 	nvkm_wr32(udev->device, addr, data);
+	return 0;
 }
 
 static int
 nvkm_udevice_map(struct nvkm_object *object, u64 *addr, u32 *size)
 {
-	struct nvkm_udevice *udev = (void *)object;
+	struct nvkm_udevice *udev = nvkm_udevice(object);
 	struct nvkm_device *device = udev->device;
 	*addr = nv_device_resource_start(device, 0);
 	*size = nv_device_resource_len(device, 0);
@@ -200,7 +211,7 @@ nvkm_udevice_map(struct nvkm_object *object, u64 *addr, u32 *size)
 static int
 nvkm_udevice_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nvkm_udevice *udev = (void *)object;
+	struct nvkm_udevice *udev = nvkm_udevice(object);
 	struct nvkm_device *device = udev->device;
 	int ret = 0;
 
@@ -221,7 +232,7 @@ nvkm_udevice_fini(struct nvkm_object *object, bool suspend)
 static int
 nvkm_udevice_init(struct nvkm_object *object)
 {
-	struct nvkm_udevice *udev = (void *)object;
+	struct nvkm_udevice *udev = nvkm_udevice(object);
 	struct nvkm_device *device = udev->device;
 	int ret = 0;
 
@@ -239,34 +250,120 @@ nvkm_udevice_init(struct nvkm_object *object)
 	return ret;
 }
 
-static struct nvkm_oclass
-nvkm_udevice_oclass_super = {
-	.handle = NV_DEVICE,
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.dtor = _nvkm_parent_dtor,
-		.init = nvkm_udevice_init,
-		.fini = nvkm_udevice_fini,
-		.mthd = nvkm_udevice_mthd,
-		.map  = nvkm_udevice_map,
-		.rd08 = nvkm_udevice_rd08,
-		.rd16 = nvkm_udevice_rd16,
-		.rd32 = nvkm_udevice_rd32,
-		.wr08 = nvkm_udevice_wr08,
-		.wr16 = nvkm_udevice_wr16,
-		.wr32 = nvkm_udevice_wr32,
+static int
+nvkm_udevice_child_old(const struct nvkm_oclass *oclass,
+		       void *data, u32 size, struct nvkm_object **pobject)
+{
+	struct nvkm_object *parent = oclass->parent;
+	struct nvkm_engine *engine = oclass->engine;
+	struct nvkm_oclass *eclass = (void *)oclass->priv;
+	struct nvkm_object *engctx = NULL;
+	int ret;
+
+	if (engine->cclass) {
+		ret = nvkm_object_old(parent, &engine->subdev.object,
+				      engine->cclass, NULL, 0, &engctx);
+		if (ret)
+			return ret;
+	} else {
+		nvkm_object_ref(parent, &engctx);
 	}
-};
+
+	ret = nvkm_object_old(engctx, &engine->subdev.object, eclass,
+			      data, size, pobject);
+	nvkm_object_ref(NULL, &engctx);
+	return ret;
+}
 
 static int
-nvkm_udevice_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-		 struct nvkm_oclass *oclass, void *data, u32 size,
+nvkm_udevice_child_new(const struct nvkm_oclass *oclass,
+		       void *data, u32 size, struct nvkm_object **pobject)
+{
+	struct nvkm_udevice *udev = nvkm_udevice(oclass->parent);
+	const struct nvkm_oclass *sclass = oclass->priv;
+	return nvkm_object_old(&udev->object, NULL,
+			       (struct nvkm_oclass *)sclass,
+			       data, size, pobject);
+}
+
+static int
+nvkm_udevice_child_get(struct nvkm_object *object, int index,
+		       struct nvkm_oclass *oclass)
+{
+	struct nvkm_udevice *udev = nvkm_udevice(object);
+	struct nvkm_device *device = udev->device;
+	struct nvkm_engine *engine;
+	u64 mask = (1ULL << NVDEV_ENGINE_DMAOBJ) |
+		   (1ULL << NVDEV_ENGINE_FIFO) |
+		   (1ULL << NVDEV_ENGINE_DISP) |
+		   (1ULL << NVDEV_ENGINE_PM);
+	int i;
+
+	for (; i = __ffs64(mask), mask; mask &= ~(1ULL << i)) {
+		if ((engine = nvkm_device_engine(device, i))) {
+			struct nvkm_oclass *sclass = engine->sclass;
+			int c = 0;
+			while (sclass && sclass->ofuncs) {
+				if (c++ == index) {
+					oclass->base.oclass = sclass->handle;
+					oclass->base.minver = -2;
+					oclass->base.maxver = -2;
+					oclass->ctor = nvkm_udevice_child_old;
+					oclass->priv = sclass;
+					oclass->engine = engine;
+					return 0;
+				}
+				sclass++;
+			}
+			index -= c;
+		}
+	}
+
+	if (index == 0) {
+		oclass->ctor = nvkm_udevice_child_new;
+		oclass->base.oclass = nvkm_control_oclass[0].handle;
+		oclass->base.minver = -2;
+		oclass->base.maxver = -2;
+		oclass->priv = &nvkm_control_oclass[0];
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static const struct nvkm_object_func
+nvkm_udevice_super = {
+	.init = nvkm_udevice_init,
+	.fini = nvkm_udevice_fini,
+	.mthd = nvkm_udevice_mthd,
+	.map = nvkm_udevice_map,
+	.rd08 = nvkm_udevice_rd08,
+	.rd16 = nvkm_udevice_rd16,
+	.rd32 = nvkm_udevice_rd32,
+	.wr08 = nvkm_udevice_wr08,
+	.wr16 = nvkm_udevice_wr16,
+	.wr32 = nvkm_udevice_wr32,
+	.sclass = nvkm_udevice_child_get,
+};
+
+static const struct nvkm_object_func
+nvkm_udevice = {
+	.init = nvkm_udevice_init,
+	.fini = nvkm_udevice_fini,
+	.mthd = nvkm_udevice_mthd,
+	.sclass = nvkm_udevice_child_get,
+};
+
+int
+nvkm_udevice_new(const struct nvkm_oclass *oclass, void *data, u32 size,
 		 struct nvkm_object **pobject)
 {
 	union {
 		struct nv_device_v0 v0;
 	} *args = data;
-	struct nvkm_client *client = nvkm_client(parent);
-	struct nvkm_device *device;
+	struct nvkm_client *client = oclass->client;
+	struct nvkm_object *parent = &client->object;
+	const struct nvkm_object_func *func;
 	struct nvkm_udevice *udev;
 	int ret;
 
@@ -279,34 +376,30 @@ nvkm_udevice_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	/* give priviledged clients register access */
 	if (client->super)
-		oclass = &nvkm_udevice_oclass_super;
+		func = &nvkm_udevice_super;
+	else
+		func = &nvkm_udevice;
 
-	/* find the device subdev that matches what the client requested */
+	if (!(udev = kzalloc(sizeof(*udev), GFP_KERNEL)))
+		return -ENOMEM;
+	nvkm_object_ctor(func, oclass, &udev->object);
+	*pobject = &udev->object;
+
+	/* find the device that matches what the client requested */
 	if (args->v0.device != ~0)
-		device = nvkm_device_find(args->v0.device);
+		udev->device = nvkm_device_find(args->v0.device);
 	else
-		device = nvkm_device_find(client->device);
-	if (!device)
+		udev->device = nvkm_device_find(client->device);
+	if (!udev->device)
 		return -ENODEV;
 
-	ret = nvkm_parent_create(parent, NULL, oclass, 0, nvkm_control_oclass,
-				 (1ULL << NVDEV_ENGINE_DMAOBJ) |
-				 (1ULL << NVDEV_ENGINE_FIFO) |
-				 (1ULL << NVDEV_ENGINE_DISP) |
-				 (1ULL << NVDEV_ENGINE_PM), &udev);
-	*pobject = nv_object(udev);
-	if (ret)
-		return ret;
-
-	udev->device = device;
 	return 0;
 }
 
-struct nvkm_ofuncs
-nvkm_udevice_ofuncs = {
-	.ctor = nvkm_udevice_ctor,
-	.dtor = _nvkm_parent_dtor,
-	.init = nvkm_udevice_init,
-	.fini = nvkm_udevice_fini,
-	.mthd = nvkm_udevice_mthd,
+const struct nvkm_sclass
+nvkm_udevice_sclass = {
+	.oclass = NV_DEVICE,
+	.minver = 0,
+	.maxver = 0,
+	.ctor = nvkm_udevice_new,
 };

commit 24bd0930bedea1182aaadc52757897d2b9b3ca99
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/client: convert to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index 0df54c657469..59b28cbe6634 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -24,6 +24,7 @@
 #include "priv.h"
 
 #include <core/client.h>
+#include <core/parent.h>
 #include <subdev/fb.h>
 #include <subdev/instmem.h>
 #include <subdev/timer.h>

commit 6cf813fb26640ef539051fb7f965af8c9ff10d92
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/device: prepare for new-style subdevs
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index cb3f3deefb01..0df54c657469 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -107,8 +107,8 @@ nvkm_udevice_info(struct nvkm_object *object, void *data, u32 size)
 	if (imem && args->v0.ram_size > 0)
 		args->v0.ram_user = args->v0.ram_user - imem->reserved;
 
-	strncpy(args->v0.chip, device->cname, sizeof(args->v0.chip));
-	strncpy(args->v0.name, device->cname, sizeof(args->v0.name));
+	strncpy(args->v0.chip, device->chip->name, sizeof(args->v0.chip));
+	strncpy(args->v0.name, device->name, sizeof(args->v0.name));
 	return 0;
 }
 

commit d61f4c178cb36a7b15871fcc60814f1f94a5044d
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/nvif: device time mthd
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index e44d60739b56..cb3f3deefb01 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -26,6 +26,7 @@
 #include <core/client.h>
 #include <subdev/fb.h>
 #include <subdev/instmem.h>
+#include <subdev/timer.h>
 
 #include <nvif/class.h>
 #include <nvif/unpack.h>
@@ -111,12 +112,32 @@ nvkm_udevice_info(struct nvkm_object *object, void *data, u32 size)
 	return 0;
 }
 
+static int
+nvkm_udevice_time(struct nvkm_object *object, void *data, u32 size)
+{
+	struct nvkm_udevice *udev = (void *)object;
+	struct nvkm_device *device = udev->device;
+	struct nvkm_timer *tmr = device->timer;
+	union {
+		struct nv_device_time_v0 v0;
+	} *args = data;
+	int ret;
+
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		args->v0.time = tmr->read(tmr);
+	}
+
+	return ret;
+}
+
 static int
 nvkm_udevice_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
 {
 	switch (mthd) {
 	case NV_DEVICE_V0_INFO:
 		return nvkm_udevice_info(object, data, size);
+	case NV_DEVICE_V0_TIME:
+		return nvkm_udevice_time(object, data, size);
 	default:
 		break;
 	}

commit 22827fa42b0baa9287ea56691f26dc45fecea049
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/nvif: return chipset/board names from device info method
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index c16bde41c279..e44d60739b56 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -106,6 +106,8 @@ nvkm_udevice_info(struct nvkm_object *object, void *data, u32 size)
 	if (imem && args->v0.ram_size > 0)
 		args->v0.ram_user = args->v0.ram_user - imem->reserved;
 
+	strncpy(args->v0.chip, device->cname, sizeof(args->v0.chip));
+	strncpy(args->v0.name, device->cname, sizeof(args->v0.name));
 	return 0;
 }
 

commit 4e7e62d607a711bc8e8576a0fc7d8f242d25c9b3
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:15 2015 +1000

    drm/nouveau/client: store default device by handle, not reference
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index 4867bbd0788f..c16bde41c279 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -258,12 +258,12 @@ nvkm_udevice_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		oclass = &nvkm_udevice_oclass_super;
 
 	/* find the device subdev that matches what the client requested */
-	device = client->device;
-	if (args->v0.device != ~0) {
+	if (args->v0.device != ~0)
 		device = nvkm_device_find(args->v0.device);
-		if (!device)
-			return -ENODEV;
-	}
+	else
+		device = nvkm_device_find(client->device);
+	if (!device)
+		return -ENODEV;
 
 	ret = nvkm_parent_create(parent, NULL, oclass, 0, nvkm_control_oclass,
 				 (1ULL << NVDEV_ENGINE_DMAOBJ) |

commit a1e88736221d2e971726931c449ed7d0af31755b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:15 2015 +1000

    drm/nouveau/device: decouple from engine machinery
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
index 16bb0410382f..4867bbd0788f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -173,13 +173,55 @@ nvkm_udevice_map(struct nvkm_object *object, u64 *addr, u32 *size)
 	return 0;
 }
 
+static int
+nvkm_udevice_fini(struct nvkm_object *object, bool suspend)
+{
+	struct nvkm_udevice *udev = (void *)object;
+	struct nvkm_device *device = udev->device;
+	int ret = 0;
+
+	mutex_lock(&device->mutex);
+	if (!--device->refcount) {
+		ret = nvkm_device_fini(device, suspend);
+		if (ret && suspend) {
+			device->refcount++;
+			goto done;
+		}
+	}
+
+done:
+	mutex_unlock(&device->mutex);
+	return ret;
+}
+
+static int
+nvkm_udevice_init(struct nvkm_object *object)
+{
+	struct nvkm_udevice *udev = (void *)object;
+	struct nvkm_device *device = udev->device;
+	int ret = 0;
+
+	mutex_lock(&device->mutex);
+	if (!device->refcount++) {
+		ret = nvkm_device_init(device);
+		if (ret) {
+			device->refcount--;
+			goto done;
+		}
+	}
+
+done:
+	mutex_unlock(&device->mutex);
+	return ret;
+}
+
 static struct nvkm_oclass
 nvkm_udevice_oclass_super = {
 	.handle = NV_DEVICE,
 	.ofuncs = &(struct nvkm_ofuncs) {
 		.dtor = _nvkm_parent_dtor,
-		.init = _nvkm_parent_init,
-		.fini = _nvkm_parent_fini,
+		.init = nvkm_udevice_init,
+		.fini = nvkm_udevice_fini,
 		.mthd = nvkm_udevice_mthd,
 		.map  = nvkm_udevice_map,
 		.rd08 = nvkm_udevice_rd08,
@@ -223,8 +265,7 @@ nvkm_udevice_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 			return -ENODEV;
 	}
 
-	ret = nvkm_parent_create(parent, nv_object(device), oclass, 0,
-				 nvkm_control_oclass,
+	ret = nvkm_parent_create(parent, NULL, oclass, 0, nvkm_control_oclass,
 				 (1ULL << NVDEV_ENGINE_DMAOBJ) |
 				 (1ULL << NVDEV_ENGINE_FIFO) |
 				 (1ULL << NVDEV_ENGINE_DISP) |
@@ -241,7 +282,7 @@ struct nvkm_ofuncs
 nvkm_udevice_ofuncs = {
 	.ctor = nvkm_udevice_ctor,
 	.dtor = _nvkm_parent_dtor,
-	.init = _nvkm_parent_init,
-	.fini = _nvkm_parent_fini,
+	.init = nvkm_udevice_init,
+	.fini = nvkm_udevice_fini,
 	.mthd = nvkm_udevice_mthd,
 };

commit a1bfb29a33521efa6b1714589bf68cb4afebacb1
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:15 2015 +1000

    drm/nouveau/device: split user device implementation out on its own
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
new file mode 100644
index 000000000000..16bb0410382f
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c
@@ -0,0 +1,247 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+#include "priv.h"
+
+#include <core/client.h>
+#include <subdev/fb.h>
+#include <subdev/instmem.h>
+
+#include <nvif/class.h>
+#include <nvif/unpack.h>
+
+struct nvkm_udevice {
+	struct nvkm_parent base;
+	struct nvkm_device *device;
+};
+
+static int
+nvkm_udevice_info(struct nvkm_object *object, void *data, u32 size)
+{
+	struct nvkm_udevice *udev = (void *)object;
+	struct nvkm_device *device = udev->device;
+	struct nvkm_fb *fb = device->fb;
+	struct nvkm_instmem *imem = device->imem;
+	union {
+		struct nv_device_info_v0 v0;
+	} *args = data;
+	int ret;
+
+	nvif_ioctl(object, "device info size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nvif_ioctl(object, "device info vers %d\n", args->v0.version);
+	} else
+		return ret;
+
+	switch (device->chipset) {
+	case 0x01a:
+	case 0x01f:
+	case 0x04c:
+	case 0x04e:
+	case 0x063:
+	case 0x067:
+	case 0x068:
+	case 0x0aa:
+	case 0x0ac:
+	case 0x0af:
+		args->v0.platform = NV_DEVICE_INFO_V0_IGP;
+		break;
+	default:
+		if (device->pdev) {
+			if (pci_find_capability(device->pdev, PCI_CAP_ID_AGP))
+				args->v0.platform = NV_DEVICE_INFO_V0_AGP;
+			else
+			if (pci_is_pcie(device->pdev))
+				args->v0.platform = NV_DEVICE_INFO_V0_PCIE;
+			else
+				args->v0.platform = NV_DEVICE_INFO_V0_PCI;
+		} else {
+			args->v0.platform = NV_DEVICE_INFO_V0_SOC;
+		}
+		break;
+	}
+
+	switch (device->card_type) {
+	case NV_04: args->v0.family = NV_DEVICE_INFO_V0_TNT; break;
+	case NV_10:
+	case NV_11: args->v0.family = NV_DEVICE_INFO_V0_CELSIUS; break;
+	case NV_20: args->v0.family = NV_DEVICE_INFO_V0_KELVIN; break;
+	case NV_30: args->v0.family = NV_DEVICE_INFO_V0_RANKINE; break;
+	case NV_40: args->v0.family = NV_DEVICE_INFO_V0_CURIE; break;
+	case NV_50: args->v0.family = NV_DEVICE_INFO_V0_TESLA; break;
+	case NV_C0: args->v0.family = NV_DEVICE_INFO_V0_FERMI; break;
+	case NV_E0: args->v0.family = NV_DEVICE_INFO_V0_KEPLER; break;
+	case GM100: args->v0.family = NV_DEVICE_INFO_V0_MAXWELL; break;
+	default:
+		args->v0.family = 0;
+		break;
+	}
+
+	args->v0.chipset  = device->chipset;
+	args->v0.revision = device->chiprev;
+	if (fb && fb->ram)
+		args->v0.ram_size = args->v0.ram_user = fb->ram->size;
+	else
+		args->v0.ram_size = args->v0.ram_user = 0;
+	if (imem && args->v0.ram_size > 0)
+		args->v0.ram_user = args->v0.ram_user - imem->reserved;
+
+	return 0;
+}
+
+static int
+nvkm_udevice_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)
+{
+	switch (mthd) {
+	case NV_DEVICE_V0_INFO:
+		return nvkm_udevice_info(object, data, size);
+	default:
+		break;
+	}
+	return -EINVAL;
+}
+
+static u8
+nvkm_udevice_rd08(struct nvkm_object *object, u64 addr)
+{
+	struct nvkm_udevice *udev = (void *)object;
+	return nvkm_rd08(udev->device, addr);
+}
+
+static u16
+nvkm_udevice_rd16(struct nvkm_object *object, u64 addr)
+{
+	struct nvkm_udevice *udev = (void *)object;
+	return nvkm_rd16(udev->device, addr);
+}
+
+static u32
+nvkm_udevice_rd32(struct nvkm_object *object, u64 addr)
+{
+	struct nvkm_udevice *udev = (void *)object;
+	return nvkm_rd32(udev->device, addr);
+}
+
+static void
+nvkm_udevice_wr08(struct nvkm_object *object, u64 addr, u8 data)
+{
+	struct nvkm_udevice *udev = (void *)object;
+	nvkm_wr08(udev->device, addr, data);
+}
+
+static void
+nvkm_udevice_wr16(struct nvkm_object *object, u64 addr, u16 data)
+{
+	struct nvkm_udevice *udev = (void *)object;
+	nvkm_wr16(udev->device, addr, data);
+}
+
+static void
+nvkm_udevice_wr32(struct nvkm_object *object, u64 addr, u32 data)
+{
+	struct nvkm_udevice *udev = (void *)object;
+	nvkm_wr32(udev->device, addr, data);
+}
+
+static int
+nvkm_udevice_map(struct nvkm_object *object, u64 *addr, u32 *size)
+{
+	struct nvkm_udevice *udev = (void *)object;
+	struct nvkm_device *device = udev->device;
+	*addr = nv_device_resource_start(device, 0);
+	*size = nv_device_resource_len(device, 0);
+	return 0;
+}
+
+static struct nvkm_oclass
+nvkm_udevice_oclass_super = {
+	.handle = NV_DEVICE,
+	.ofuncs = &(struct nvkm_ofuncs) {
+		.dtor = _nvkm_parent_dtor,
+		.init = _nvkm_parent_init,
+		.fini = _nvkm_parent_fini,
+		.mthd = nvkm_udevice_mthd,
+		.map  = nvkm_udevice_map,
+		.rd08 = nvkm_udevice_rd08,
+		.rd16 = nvkm_udevice_rd16,
+		.rd32 = nvkm_udevice_rd32,
+		.wr08 = nvkm_udevice_wr08,
+		.wr16 = nvkm_udevice_wr16,
+		.wr32 = nvkm_udevice_wr32,
+	}
+};
+
+static int
+nvkm_udevice_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+		 struct nvkm_oclass *oclass, void *data, u32 size,
+		 struct nvkm_object **pobject)
+{
+	union {
+		struct nv_device_v0 v0;
+	} *args = data;
+	struct nvkm_client *client = nvkm_client(parent);
+	struct nvkm_device *device;
+	struct nvkm_udevice *udev;
+	int ret;
+
+	nvif_ioctl(parent, "create device size %d\n", size);
+	if (nvif_unpack(args->v0, 0, 0, false)) {
+		nvif_ioctl(parent, "create device v%d device %016llx\n",
+			   args->v0.version, args->v0.device);
+	} else
+		return ret;
+
+	/* give priviledged clients register access */
+	if (client->super)
+		oclass = &nvkm_udevice_oclass_super;
+
+	/* find the device subdev that matches what the client requested */
+	device = client->device;
+	if (args->v0.device != ~0) {
+		device = nvkm_device_find(args->v0.device);
+		if (!device)
+			return -ENODEV;
+	}
+
+	ret = nvkm_parent_create(parent, nv_object(device), oclass, 0,
+				 nvkm_control_oclass,
+				 (1ULL << NVDEV_ENGINE_DMAOBJ) |
+				 (1ULL << NVDEV_ENGINE_FIFO) |
+				 (1ULL << NVDEV_ENGINE_DISP) |
+				 (1ULL << NVDEV_ENGINE_PM), &udev);
+	*pobject = nv_object(udev);
+	if (ret)
+		return ret;
+
+	udev->device = device;
+	return 0;
+}
+
+struct nvkm_ofuncs
+nvkm_udevice_ofuncs = {
+	.ctor = nvkm_udevice_ctor,
+	.dtor = _nvkm_parent_dtor,
+	.init = _nvkm_parent_init,
+	.fini = _nvkm_parent_fini,
+	.mthd = nvkm_udevice_mthd,
+};
