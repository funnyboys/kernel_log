commit 08f7633c1de8007c3735764d5ca0c1bde4239b84
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Nov 8 10:18:19 2015 +1000

    drm/nouveau/nvif: move internal class identifiers to class.h
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
index a381196af69d..01573d187f2c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -28,8 +28,8 @@
 #include <engine/fifo/chan.h>
 #include <subdev/bar.h>
 
+#include <nvif/class.h>
 #include <nvif/event.h>
-#include <nvif/ioctl.h>
 
 /*******************************************************************************
  * software context
@@ -136,7 +136,7 @@ static const struct nvkm_sw_func
 nv50_sw = {
 	.chan_new = nv50_sw_chan_new,
 	.sclass = {
-		{ nvkm_nvsw_new, { -1, -1, NVIF_IOCTL_NEW_V0_SW_NV50 } },
+		{ nvkm_nvsw_new, { -1, -1, NVIF_CLASS_SW_NV50 } },
 		{}
 	}
 };

commit fbd58ebda9c8572ca6285b88e3348c7712f125ec
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/object: merge with handle
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
index ef36ba18bff8..a381196af69d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -24,7 +24,6 @@
 #include "nv50.h"
 
 #include <core/gpuobj.h>
-#include <core/handle.h>
 #include <engine/disp.h>
 #include <engine/fifo/chan.h>
 #include <subdev/bar.h>

commit 6f41c7c56929b3a2ad943d5b6dd4d66d716e74d7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/sw: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
index a00d9a55e53b..ef36ba18bff8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -48,7 +48,7 @@ nv50_sw_chan_vblsem_release(struct nvkm_notify *notify)
 	nvkm_wr32(device, 0x001710, 0x80000000 | chan->vblank.ctxdma);
 	nvkm_bar_flush(device->bar);
 
-	if (nv_device(sw)->chipset == 0x50) {
+	if (device->chipset == 0x50) {
 		nvkm_wr32(device, 0x001570, chan->vblank.offset);
 		nvkm_wr32(device, 0x001574, chan->vblank.value);
 	} else {
@@ -133,27 +133,8 @@ nv50_sw_chan_new(struct nvkm_sw *sw, struct nvkm_fifo_chan *fifoch,
  * software engine/subdev functions
  ******************************************************************************/
 
-int
-nv50_sw_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-	     struct nvkm_oclass *oclass, void *data, u32 size,
-	     struct nvkm_object **pobject)
-{
-	struct nv50_sw_oclass *pclass = (void *)oclass;
-	struct nvkm_sw *sw;
-	int ret;
-
-	ret = nvkm_sw_create(parent, engine, oclass, &sw);
-	*pobject = nv_object(sw);
-	if (ret)
-		return ret;
-
-	sw->func = pclass->func;
-	nv_subdev(sw)->intr = nv04_sw_intr;
-	return 0;
-}
-
 static const struct nvkm_sw_func
-nv50_sw_func = {
+nv50_sw = {
 	.chan_new = nv50_sw_chan_new,
 	.sclass = {
 		{ nvkm_nvsw_new, { -1, -1, NVIF_IOCTL_NEW_V0_SW_NV50 } },
@@ -161,14 +142,8 @@ nv50_sw_func = {
 	}
 };
 
-struct nvkm_oclass *
-nv50_sw_oclass = &(struct nv50_sw_oclass) {
-	.base.handle = NV_ENGINE(SW, 0x50),
-	.base.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nv50_sw_ctor,
-		.dtor = _nvkm_sw_dtor,
-		.init = _nvkm_sw_init,
-		.fini = _nvkm_sw_fini,
-	},
-	.func = &nv50_sw_func,
-}.base;
+int
+nv50_sw_new(struct nvkm_device *device, int index, struct nvkm_sw **psw)
+{
+	return nvkm_sw_new_(&nv50_sw, device, index, psw);
+}

commit 13de7f462902d1a452d501cdb2d06ef02cabbfff
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/fifo: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
index 6c93a20295a4..a00d9a55e53b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -23,6 +23,7 @@
  */
 #include "nv50.h"
 
+#include <core/gpuobj.h>
 #include <core/handle.h>
 #include <engine/disp.h>
 #include <engine/fifo/chan.h>

commit 3293228174e4d44cca56d809cc8409c3f88f8b90
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/bar: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
index 451f758f5ebf..6c93a20295a4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -42,11 +42,10 @@ nv50_sw_chan_vblsem_release(struct nvkm_notify *notify)
 		container_of(notify, typeof(*chan), vblank.notify[notify->index]);
 	struct nvkm_sw *sw = chan->base.sw;
 	struct nvkm_device *device = sw->engine.subdev.device;
-	struct nvkm_bar *bar = device->bar;
 
 	nvkm_wr32(device, 0x001704, chan->base.fifo->inst->addr >> 12);
 	nvkm_wr32(device, 0x001710, 0x80000000 | chan->vblank.ctxdma);
-	bar->flush(bar);
+	nvkm_bar_flush(device->bar);
 
 	if (nv_device(sw)->chipset == 0x50) {
 		nvkm_wr32(device, 0x001570, chan->vblank.offset);

commit 07b9e6cc957195bd1e6908612d67a92ba0ed2cb6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/sw: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
index 35ec1cffb53a..451f758f5ebf 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -31,30 +31,20 @@
 #include <nvif/event.h>
 #include <nvif/ioctl.h>
 
-/*******************************************************************************
- * software object classes
- ******************************************************************************/
-
-static struct nvkm_oclass
-nv50_sw_sclass[] = {
-	{ NVIF_IOCTL_NEW_V0_SW_NV50, &nvkm_nvsw_ofuncs },
-	{}
-};
-
 /*******************************************************************************
  * software context
  ******************************************************************************/
 
 static int
-nv50_sw_vblsem_release(struct nvkm_notify *notify)
+nv50_sw_chan_vblsem_release(struct nvkm_notify *notify)
 {
 	struct nv50_sw_chan *chan =
 		container_of(notify, typeof(*chan), vblank.notify[notify->index]);
-	struct nvkm_sw *sw = (void *)nv_object(chan)->engine;
+	struct nvkm_sw *sw = chan->base.sw;
 	struct nvkm_device *device = sw->engine.subdev.device;
 	struct nvkm_bar *bar = device->bar;
 
-	nvkm_wr32(device, 0x001704, chan->vblank.channel);
+	nvkm_wr32(device, 0x001704, chan->base.fifo->inst->addr >> 12);
 	nvkm_wr32(device, 0x001710, 0x80000000 | chan->vblank.ctxdma);
 	bar->flush(bar);
 
@@ -73,7 +63,7 @@ static bool
 nv50_sw_chan_mthd(struct nvkm_sw_chan *base, int subc, u32 mthd, u32 data)
 {
 	struct nv50_sw_chan *chan = nv50_sw_chan(base);
-	struct nvkm_engine *engine = chan->base.base.gpuobj.object.engine;
+	struct nvkm_engine *engine = chan->base.object.engine;
 	struct nvkm_device *device = engine->subdev.device;
 	switch (mthd) {
 	case 0x018c: chan->vblank.ctxdma = data; return true;
@@ -91,41 +81,41 @@ nv50_sw_chan_mthd(struct nvkm_sw_chan *base, int subc, u32 mthd, u32 data)
 	return false;
 }
 
-static const struct nvkm_sw_chan_func
-nv50_sw_chan_func = {
-	.mthd = nv50_sw_chan_mthd,
-};
-
-void
-nv50_sw_context_dtor(struct nvkm_object *object)
+void *
+nv50_sw_chan_dtor(struct nvkm_sw_chan *base)
 {
-	struct nv50_sw_chan *chan = (void *)object;
+	struct nv50_sw_chan *chan = nv50_sw_chan(base);
 	int i;
-
 	for (i = 0; i < ARRAY_SIZE(chan->vblank.notify); i++)
 		nvkm_notify_fini(&chan->vblank.notify[i]);
-
-	nvkm_sw_chan_dtor(&chan->base.base.gpuobj.object);
+	return chan;
 }
 
-int
-nv50_sw_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-		     struct nvkm_oclass *oclass, void *data, u32 size,
-		     struct nvkm_object **pobject)
+static const struct nvkm_sw_chan_func
+nv50_sw_chan = {
+	.dtor = nv50_sw_chan_dtor,
+	.mthd = nv50_sw_chan_mthd,
+};
+
+static int
+nv50_sw_chan_new(struct nvkm_sw *sw, struct nvkm_fifo_chan *fifoch,
+		 const struct nvkm_oclass *oclass, struct nvkm_object **pobject)
 {
-	struct nvkm_disp *disp = parent->engine->subdev.device->disp;
-	struct nv50_sw_cclass *pclass = (void *)oclass;
+	struct nvkm_disp *disp = sw->engine.subdev.device->disp;
 	struct nv50_sw_chan *chan;
 	int ret, i;
 
-	ret = nvkm_sw_context_create(pclass->chan, parent, engine, oclass, &chan);
-	*pobject = nv_object(chan);
+	if (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))
+		return -ENOMEM;
+	*pobject = &chan->base.object;
+
+	ret = nvkm_sw_chan_ctor(&nv50_sw_chan, sw, fifoch, oclass, &chan->base);
 	if (ret)
 		return ret;
 
 	for (i = 0; disp && i < disp->vblank.index_nr; i++) {
-		ret = nvkm_notify_init(NULL, &disp->vblank, pclass->vblank,
-				       false,
+		ret = nvkm_notify_init(NULL, &disp->vblank,
+				       nv50_sw_chan_vblsem_release, false,
 				       &(struct nvif_notify_head_req_v0) {
 					.head = i,
 				       },
@@ -136,23 +126,9 @@ nv50_sw_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 			return ret;
 	}
 
-	chan->vblank.channel = nvkm_fifo_chan(parent)->inst->addr >> 12;
 	return 0;
 }
 
-static struct nv50_sw_cclass
-nv50_sw_cclass = {
-	.base.handle = NV_ENGCTX(SW, 0x50),
-	.base.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nv50_sw_context_ctor,
-		.dtor = nv50_sw_context_dtor,
-		.init = _nvkm_sw_context_init,
-		.fini = _nvkm_sw_context_fini,
-	},
-	.vblank = nv50_sw_vblsem_release,
-	.chan = &nv50_sw_chan_func,
-};
-
 /*******************************************************************************
  * software engine/subdev functions
  ******************************************************************************/
@@ -171,12 +147,20 @@ nv50_sw_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	nv_engine(sw)->cclass = pclass->cclass;
-	nv_engine(sw)->sclass = pclass->sclass;
+	sw->func = pclass->func;
 	nv_subdev(sw)->intr = nv04_sw_intr;
 	return 0;
 }
 
+static const struct nvkm_sw_func
+nv50_sw_func = {
+	.chan_new = nv50_sw_chan_new,
+	.sclass = {
+		{ nvkm_nvsw_new, { -1, -1, NVIF_IOCTL_NEW_V0_SW_NV50 } },
+		{}
+	}
+};
+
 struct nvkm_oclass *
 nv50_sw_oclass = &(struct nv50_sw_oclass) {
 	.base.handle = NV_ENGINE(SW, 0x50),
@@ -186,6 +170,5 @@ nv50_sw_oclass = &(struct nv50_sw_oclass) {
 		.init = _nvkm_sw_init,
 		.fini = _nvkm_sw_fini,
 	},
-	.cclass = &nv50_sw_cclass.base,
-	.sclass =  nv50_sw_sclass,
+	.func = &nv50_sw_func,
 }.base;

commit 8f0649b5c6e70ec18122255690e39f010c12a614
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/fifo: convert user classes to new-style nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
index 4e8b632ef5b1..35ec1cffb53a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -24,8 +24,8 @@
 #include "nv50.h"
 
 #include <core/handle.h>
-#include <core/namedb.h>
 #include <engine/disp.h>
+#include <engine/fifo/chan.h>
 #include <subdev/bar.h>
 
 #include <nvif/event.h>
@@ -136,7 +136,7 @@ nv50_sw_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 			return ret;
 	}
 
-	chan->vblank.channel = nv_gpuobj(parent->parent)->addr >> 12;
+	chan->vblank.channel = nvkm_fifo_chan(parent)->inst->addr >> 12;
 	return 0;
 }
 

commit 2a7909c0ade08c66690e6115ae49765dc47873e6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:19 2015 +1000

    drm/nouveau/disp: split user classes out from engine implementations
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
index c3af125c7132..4e8b632ef5b1 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -73,12 +73,14 @@ static bool
 nv50_sw_chan_mthd(struct nvkm_sw_chan *base, int subc, u32 mthd, u32 data)
 {
 	struct nv50_sw_chan *chan = nv50_sw_chan(base);
+	struct nvkm_engine *engine = chan->base.base.gpuobj.object.engine;
+	struct nvkm_device *device = engine->subdev.device;
 	switch (mthd) {
 	case 0x018c: chan->vblank.ctxdma = data; return true;
 	case 0x0400: chan->vblank.offset = data; return true;
 	case 0x0404: chan->vblank.value  = data; return true;
 	case 0x0408:
-		if (data < nvkm_disp(chan)->vblank.index_nr) {
+		if (data < device->disp->vblank.index_nr) {
 			nvkm_notify_get(&chan->vblank.notify[data]);
 			return true;
 		}
@@ -111,7 +113,7 @@ nv50_sw_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		     struct nvkm_oclass *oclass, void *data, u32 size,
 		     struct nvkm_object **pobject)
 {
-	struct nvkm_disp *disp = nvkm_disp(parent);
+	struct nvkm_disp *disp = parent->engine->subdev.device->disp;
 	struct nv50_sw_cclass *pclass = (void *)oclass;
 	struct nv50_sw_chan *chan;
 	int ret, i;

commit 6157091177102638c7d94ffc159c0b157a1c9b56
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/sw: remove dependence on namedb/engctx lookup
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
index 9322bde518d2..c3af125c7132 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -35,80 +35,9 @@
  * software object classes
  ******************************************************************************/
 
-static int
-nv50_sw_mthd_dma_vblsem(struct nvkm_object *object, u32 mthd,
-			void *args, u32 size)
-{
-	struct nv50_sw_chan *chan = (void *)nv_engctx(object->parent);
-	struct nvkm_fifo_chan *fifo = (void *)nv_object(chan)->parent;
-	struct nvkm_handle *handle;
-	int ret = -EINVAL;
-
-	handle = nvkm_namedb_get(nv_namedb(fifo), *(u32 *)args);
-	if (!handle)
-		return -ENOENT;
-
-	if (nv_iclass(handle->object, NV_GPUOBJ_CLASS)) {
-		struct nvkm_gpuobj *gpuobj = nv_gpuobj(handle->object);
-		chan->vblank.ctxdma = gpuobj->node->offset >> 4;
-		ret = 0;
-	}
-	nvkm_namedb_put(handle);
-	return ret;
-}
-
-static int
-nv50_sw_mthd_vblsem_offset(struct nvkm_object *object, u32 mthd,
-			   void *args, u32 size)
-{
-	struct nv50_sw_chan *chan = (void *)nv_engctx(object->parent);
-	chan->vblank.offset = *(u32 *)args;
-	return 0;
-}
-
-int
-nv50_sw_mthd_vblsem_value(struct nvkm_object *object, u32 mthd,
-			  void *args, u32 size)
-{
-	struct nv50_sw_chan *chan = (void *)nv_engctx(object->parent);
-	chan->vblank.value = *(u32 *)args;
-	return 0;
-}
-
-int
-nv50_sw_mthd_vblsem_release(struct nvkm_object *object, u32 mthd,
-			    void *args, u32 size)
-{
-	struct nv50_sw_chan *chan = (void *)nv_engctx(object->parent);
-	u32 head = *(u32 *)args;
-	if (head >= nvkm_disp(chan)->vblank.index_nr)
-		return -EINVAL;
-
-	nvkm_notify_get(&chan->vblank.notify[head]);
-	return 0;
-}
-
-int
-nv50_sw_mthd_flip(struct nvkm_object *object, u32 mthd, void *args, u32 size)
-{
-	struct nv50_sw_chan *chan = (void *)nv_engctx(object->parent);
-	nvkm_event_send(&chan->base.event, 1, 0, NULL, 0);
-	return 0;
-}
-
-static struct nvkm_omthds
-nv50_sw_omthds[] = {
-	{ 0x018c, 0x018c, nv50_sw_mthd_dma_vblsem },
-	{ 0x0400, 0x0400, nv50_sw_mthd_vblsem_offset },
-	{ 0x0404, 0x0404, nv50_sw_mthd_vblsem_value },
-	{ 0x0408, 0x0408, nv50_sw_mthd_vblsem_release },
-	{ 0x0500, 0x0500, nv50_sw_mthd_flip },
-	{}
-};
-
 static struct nvkm_oclass
 nv50_sw_sclass[] = {
-	{ NVIF_IOCTL_NEW_V0_SW_NV50, &nvkm_nvsw_ofuncs, nv50_sw_omthds },
+	{ NVIF_IOCTL_NEW_V0_SW_NV50, &nvkm_nvsw_ofuncs },
 	{}
 };
 
@@ -140,6 +69,31 @@ nv50_sw_vblsem_release(struct nvkm_notify *notify)
 	return NVKM_NOTIFY_DROP;
 }
 
+static bool
+nv50_sw_chan_mthd(struct nvkm_sw_chan *base, int subc, u32 mthd, u32 data)
+{
+	struct nv50_sw_chan *chan = nv50_sw_chan(base);
+	switch (mthd) {
+	case 0x018c: chan->vblank.ctxdma = data; return true;
+	case 0x0400: chan->vblank.offset = data; return true;
+	case 0x0404: chan->vblank.value  = data; return true;
+	case 0x0408:
+		if (data < nvkm_disp(chan)->vblank.index_nr) {
+			nvkm_notify_get(&chan->vblank.notify[data]);
+			return true;
+		}
+		break;
+	default:
+		break;
+	}
+	return false;
+}
+
+static const struct nvkm_sw_chan_func
+nv50_sw_chan_func = {
+	.mthd = nv50_sw_chan_mthd,
+};
+
 void
 nv50_sw_context_dtor(struct nvkm_object *object)
 {
@@ -162,7 +116,7 @@ nv50_sw_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	struct nv50_sw_chan *chan;
 	int ret, i;
 
-	ret = nvkm_sw_context_create(parent, engine, oclass, &chan);
+	ret = nvkm_sw_context_create(pclass->chan, parent, engine, oclass, &chan);
 	*pobject = nv_object(chan);
 	if (ret)
 		return ret;
@@ -194,6 +148,7 @@ nv50_sw_cclass = {
 		.fini = _nvkm_sw_context_fini,
 	},
 	.vblank = nv50_sw_vblsem_release,
+	.chan = &nv50_sw_chan_func,
 };
 
 /*******************************************************************************

commit 898a2b32138da26ed8f7abc0cc8232741ca03de7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:18 2015 +1000

    drm/nouveau/sw: turn flip completion into an event
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
index ca4b8a02b971..9322bde518d2 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -92,9 +92,8 @@ int
 nv50_sw_mthd_flip(struct nvkm_object *object, u32 mthd, void *args, u32 size)
 {
 	struct nv50_sw_chan *chan = (void *)nv_engctx(object->parent);
-	if (chan->base.flip)
-		return chan->base.flip(chan->base.flip_data);
-	return -EINVAL;
+	nvkm_event_send(&chan->base.event, 1, 0, NULL, 0);
+	return 0;
 }
 
 static struct nvkm_omthds
@@ -109,7 +108,7 @@ nv50_sw_omthds[] = {
 
 static struct nvkm_oclass
 nv50_sw_sclass[] = {
-	{ NVIF_IOCTL_NEW_V0_SW_NV50, &nvkm_object_ofuncs, nv50_sw_omthds },
+	{ NVIF_IOCTL_NEW_V0_SW_NV50, &nvkm_nvsw_ofuncs, nv50_sw_omthds },
 	{}
 };
 
@@ -150,7 +149,7 @@ nv50_sw_context_dtor(struct nvkm_object *object)
 	for (i = 0; i < ARRAY_SIZE(chan->vblank.notify); i++)
 		nvkm_notify_fini(&chan->vblank.notify[i]);
 
-	nvkm_sw_context_destroy(&chan->base);
+	nvkm_sw_chan_dtor(&chan->base.base.gpuobj.object);
 }
 
 int

commit f58ddf9581655d3fea51465f06f292d365af9c87
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/nvif: assign internal class identifiers to sw classes
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
index ab3175af88fe..ca4b8a02b971 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -29,6 +29,7 @@
 #include <subdev/bar.h>
 
 #include <nvif/event.h>
+#include <nvif/ioctl.h>
 
 /*******************************************************************************
  * software object classes
@@ -108,7 +109,7 @@ nv50_sw_omthds[] = {
 
 static struct nvkm_oclass
 nv50_sw_sclass[] = {
-	{ 0x506e, &nvkm_object_ofuncs, nv50_sw_omthds },
+	{ NVIF_IOCTL_NEW_V0_SW_NV50, &nvkm_object_ofuncs, nv50_sw_omthds },
 	{}
 };
 

commit 01d64afc2e3238cf1658184427fa2563963c8708
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:10 2015 +1000

    drm/nouveau/sw: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
index af2c1afaae55..ab3175af88fe 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -122,18 +122,19 @@ nv50_sw_vblsem_release(struct nvkm_notify *notify)
 	struct nv50_sw_chan *chan =
 		container_of(notify, typeof(*chan), vblank.notify[notify->index]);
 	struct nvkm_sw *sw = (void *)nv_object(chan)->engine;
-	struct nvkm_bar *bar = nvkm_bar(sw);
+	struct nvkm_device *device = sw->engine.subdev.device;
+	struct nvkm_bar *bar = device->bar;
 
-	nv_wr32(sw, 0x001704, chan->vblank.channel);
-	nv_wr32(sw, 0x001710, 0x80000000 | chan->vblank.ctxdma);
+	nvkm_wr32(device, 0x001704, chan->vblank.channel);
+	nvkm_wr32(device, 0x001710, 0x80000000 | chan->vblank.ctxdma);
 	bar->flush(bar);
 
 	if (nv_device(sw)->chipset == 0x50) {
-		nv_wr32(sw, 0x001570, chan->vblank.offset);
-		nv_wr32(sw, 0x001574, chan->vblank.value);
+		nvkm_wr32(device, 0x001570, chan->vblank.offset);
+		nvkm_wr32(device, 0x001574, chan->vblank.value);
 	} else {
-		nv_wr32(sw, 0x060010, chan->vblank.offset);
-		nv_wr32(sw, 0x060014, chan->vblank.value);
+		nvkm_wr32(device, 0x060010, chan->vblank.offset);
+		nvkm_wr32(device, 0x060014, chan->vblank.value);
 	}
 
 	return NVKM_NOTIFY_DROP;

commit 226dcefe706ff8854bca1bb75ae7bfd2fe3296c5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:08 2015 +1000

    drm/nouveau/sw: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
index 0946280a54b0..af2c1afaae55 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -121,19 +121,19 @@ nv50_sw_vblsem_release(struct nvkm_notify *notify)
 {
 	struct nv50_sw_chan *chan =
 		container_of(notify, typeof(*chan), vblank.notify[notify->index]);
-	struct nv50_sw_priv *priv = (void *)nv_object(chan)->engine;
-	struct nvkm_bar *bar = nvkm_bar(priv);
+	struct nvkm_sw *sw = (void *)nv_object(chan)->engine;
+	struct nvkm_bar *bar = nvkm_bar(sw);
 
-	nv_wr32(priv, 0x001704, chan->vblank.channel);
-	nv_wr32(priv, 0x001710, 0x80000000 | chan->vblank.ctxdma);
+	nv_wr32(sw, 0x001704, chan->vblank.channel);
+	nv_wr32(sw, 0x001710, 0x80000000 | chan->vblank.ctxdma);
 	bar->flush(bar);
 
-	if (nv_device(priv)->chipset == 0x50) {
-		nv_wr32(priv, 0x001570, chan->vblank.offset);
-		nv_wr32(priv, 0x001574, chan->vblank.value);
+	if (nv_device(sw)->chipset == 0x50) {
+		nv_wr32(sw, 0x001570, chan->vblank.offset);
+		nv_wr32(sw, 0x001574, chan->vblank.value);
 	} else {
-		nv_wr32(priv, 0x060010, chan->vblank.offset);
-		nv_wr32(priv, 0x060014, chan->vblank.value);
+		nv_wr32(sw, 0x060010, chan->vblank.offset);
+		nv_wr32(sw, 0x060014, chan->vblank.value);
 	}
 
 	return NVKM_NOTIFY_DROP;
@@ -205,17 +205,17 @@ nv50_sw_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	     struct nvkm_object **pobject)
 {
 	struct nv50_sw_oclass *pclass = (void *)oclass;
-	struct nv50_sw_priv *priv;
+	struct nvkm_sw *sw;
 	int ret;
 
-	ret = nvkm_sw_create(parent, engine, oclass, &priv);
-	*pobject = nv_object(priv);
+	ret = nvkm_sw_create(parent, engine, oclass, &sw);
+	*pobject = nv_object(sw);
 	if (ret)
 		return ret;
 
-	nv_engine(priv)->cclass = pclass->cclass;
-	nv_engine(priv)->sclass = pclass->sclass;
-	nv_subdev(priv)->intr = nv04_sw_intr;
+	nv_engine(sw)->cclass = pclass->cclass;
+	nv_engine(sw)->sclass = pclass->sclass;
+	nv_subdev(sw)->intr = nv04_sw_intr;
 	return 0;
 }
 

commit fd166a1832db138f22ad95eacd0879af30742f57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/disp: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
index 14d9650f4779..0946280a54b0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -156,7 +156,7 @@ nv50_sw_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		     struct nvkm_oclass *oclass, void *data, u32 size,
 		     struct nvkm_object **pobject)
 {
-	struct nvkm_disp *pdisp = nvkm_disp(parent);
+	struct nvkm_disp *disp = nvkm_disp(parent);
 	struct nv50_sw_cclass *pclass = (void *)oclass;
 	struct nv50_sw_chan *chan;
 	int ret, i;
@@ -166,8 +166,8 @@ nv50_sw_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	for (i = 0; pdisp && i < pdisp->vblank.index_nr; i++) {
-		ret = nvkm_notify_init(NULL, &pdisp->vblank, pclass->vblank,
+	for (i = 0; disp && i < disp->vblank.index_nr; i++) {
+		ret = nvkm_notify_init(NULL, &disp->vblank, pclass->vblank,
 				       false,
 				       &(struct nvif_notify_head_req_v0) {
 					.head = i,

commit 9ace404b1098221021b01c2ba0eeea0c257fa4a5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/device: include core/device.h automatically for subdevs/engines
    
    Pretty much every subdev/engine is going to need access to nvkm_device
    shortly to touch registers and/or output messages.
    
    The odd placement of the includes is necessary to work around some
    inter-dependencies that currently exist.  This will be fixed later.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
index 401fcd73086b..14d9650f4779 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -23,7 +23,6 @@
  */
 #include "nv50.h"
 
-#include <core/device.h>
 #include <core/handle.h>
 #include <core/namedb.h>
 #include <engine/disp.h>

commit f84aff4ed4942add5c3bafd8464746209bc1f51c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:32:15 2015 +1000

    drm/nouveau/sw: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
index 6833e00827c2..401fcd73086b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -21,51 +21,45 @@
  *
  * Authors: Ben Skeggs
  */
+#include "nv50.h"
 
-#include <core/os.h>
 #include <core/device.h>
-#include <core/engctx.h>
-#include <core/namedb.h>
 #include <core/handle.h>
-#include <core/gpuobj.h>
-#include <core/event.h>
-#include <nvif/event.h>
-
-#include <subdev/bar.h>
-
+#include <core/namedb.h>
 #include <engine/disp.h>
+#include <subdev/bar.h>
 
-#include "nv50.h"
+#include <nvif/event.h>
 
 /*******************************************************************************
  * software object classes
  ******************************************************************************/
 
 static int
-nv50_sw_mthd_dma_vblsem(struct nouveau_object *object, u32 mthd,
-			      void *args, u32 size)
+nv50_sw_mthd_dma_vblsem(struct nvkm_object *object, u32 mthd,
+			void *args, u32 size)
 {
 	struct nv50_sw_chan *chan = (void *)nv_engctx(object->parent);
-	struct nouveau_fifo_chan *fifo = (void *)nv_object(chan)->parent;
-	struct nouveau_handle *handle;
+	struct nvkm_fifo_chan *fifo = (void *)nv_object(chan)->parent;
+	struct nvkm_handle *handle;
 	int ret = -EINVAL;
 
-	handle = nouveau_namedb_get(nv_namedb(fifo), *(u32 *)args);
+	handle = nvkm_namedb_get(nv_namedb(fifo), *(u32 *)args);
 	if (!handle)
 		return -ENOENT;
 
 	if (nv_iclass(handle->object, NV_GPUOBJ_CLASS)) {
-		struct nouveau_gpuobj *gpuobj = nv_gpuobj(handle->object);
+		struct nvkm_gpuobj *gpuobj = nv_gpuobj(handle->object);
 		chan->vblank.ctxdma = gpuobj->node->offset >> 4;
 		ret = 0;
 	}
-	nouveau_namedb_put(handle);
+	nvkm_namedb_put(handle);
 	return ret;
 }
 
 static int
-nv50_sw_mthd_vblsem_offset(struct nouveau_object *object, u32 mthd,
-				 void *args, u32 size)
+nv50_sw_mthd_vblsem_offset(struct nvkm_object *object, u32 mthd,
+			   void *args, u32 size)
 {
 	struct nv50_sw_chan *chan = (void *)nv_engctx(object->parent);
 	chan->vblank.offset = *(u32 *)args;
@@ -73,8 +67,8 @@ nv50_sw_mthd_vblsem_offset(struct nouveau_object *object, u32 mthd,
 }
 
 int
-nv50_sw_mthd_vblsem_value(struct nouveau_object *object, u32 mthd,
-				void *args, u32 size)
+nv50_sw_mthd_vblsem_value(struct nvkm_object *object, u32 mthd,
+			  void *args, u32 size)
 {
 	struct nv50_sw_chan *chan = (void *)nv_engctx(object->parent);
 	chan->vblank.value = *(u32 *)args;
@@ -82,12 +76,12 @@ nv50_sw_mthd_vblsem_value(struct nouveau_object *object, u32 mthd,
 }
 
 int
-nv50_sw_mthd_vblsem_release(struct nouveau_object *object, u32 mthd,
-				  void *args, u32 size)
+nv50_sw_mthd_vblsem_release(struct nvkm_object *object, u32 mthd,
+			    void *args, u32 size)
 {
 	struct nv50_sw_chan *chan = (void *)nv_engctx(object->parent);
 	u32 head = *(u32 *)args;
-	if (head >= nouveau_disp(chan)->vblank.index_nr)
+	if (head >= nvkm_disp(chan)->vblank.index_nr)
 		return -EINVAL;
 
 	nvkm_notify_get(&chan->vblank.notify[head]);
@@ -95,8 +89,7 @@ nv50_sw_mthd_vblsem_release(struct nouveau_object *object, u32 mthd,
 }
 
 int
-nv50_sw_mthd_flip(struct nouveau_object *object, u32 mthd,
-			void *args, u32 size)
+nv50_sw_mthd_flip(struct nvkm_object *object, u32 mthd, void *args, u32 size)
 {
 	struct nv50_sw_chan *chan = (void *)nv_engctx(object->parent);
 	if (chan->base.flip)
@@ -104,7 +97,7 @@ nv50_sw_mthd_flip(struct nouveau_object *object, u32 mthd,
 	return -EINVAL;
 }
 
-static struct nouveau_omthds
+static struct nvkm_omthds
 nv50_sw_omthds[] = {
 	{ 0x018c, 0x018c, nv50_sw_mthd_dma_vblsem },
 	{ 0x0400, 0x0400, nv50_sw_mthd_vblsem_offset },
@@ -114,9 +107,9 @@ nv50_sw_omthds[] = {
 	{}
 };
 
-static struct nouveau_oclass
+static struct nvkm_oclass
 nv50_sw_sclass[] = {
-	{ 0x506e, &nouveau_object_ofuncs, nv50_sw_omthds },
+	{ 0x506e, &nvkm_object_ofuncs, nv50_sw_omthds },
 	{}
 };
 
@@ -130,7 +123,7 @@ nv50_sw_vblsem_release(struct nvkm_notify *notify)
 	struct nv50_sw_chan *chan =
 		container_of(notify, typeof(*chan), vblank.notify[notify->index]);
 	struct nv50_sw_priv *priv = (void *)nv_object(chan)->engine;
-	struct nouveau_bar *bar = nouveau_bar(priv);
+	struct nvkm_bar *bar = nvkm_bar(priv);
 
 	nv_wr32(priv, 0x001704, chan->vblank.channel);
 	nv_wr32(priv, 0x001710, 0x80000000 | chan->vblank.ctxdma);
@@ -148,7 +141,7 @@ nv50_sw_vblsem_release(struct nvkm_notify *notify)
 }
 
 void
-nv50_sw_context_dtor(struct nouveau_object *object)
+nv50_sw_context_dtor(struct nvkm_object *object)
 {
 	struct nv50_sw_chan *chan = (void *)object;
 	int i;
@@ -156,21 +149,20 @@ nv50_sw_context_dtor(struct nouveau_object *object)
 	for (i = 0; i < ARRAY_SIZE(chan->vblank.notify); i++)
 		nvkm_notify_fini(&chan->vblank.notify[i]);
 
-	nouveau_sw_context_destroy(&chan->base);
+	nvkm_sw_context_destroy(&chan->base);
 }
 
 int
-nv50_sw_context_ctor(struct nouveau_object *parent,
-			   struct nouveau_object *engine,
-			   struct nouveau_oclass *oclass, void *data, u32 size,
-			   struct nouveau_object **pobject)
+nv50_sw_context_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+		     struct nvkm_oclass *oclass, void *data, u32 size,
+		     struct nvkm_object **pobject)
 {
-	struct nouveau_disp *pdisp = nouveau_disp(parent);
+	struct nvkm_disp *pdisp = nvkm_disp(parent);
 	struct nv50_sw_cclass *pclass = (void *)oclass;
 	struct nv50_sw_chan *chan;
 	int ret, i;
 
-	ret = nouveau_sw_context_create(parent, engine, oclass, &chan);
+	ret = nvkm_sw_context_create(parent, engine, oclass, &chan);
 	*pobject = nv_object(chan);
 	if (ret)
 		return ret;
@@ -195,11 +187,11 @@ nv50_sw_context_ctor(struct nouveau_object *parent,
 static struct nv50_sw_cclass
 nv50_sw_cclass = {
 	.base.handle = NV_ENGCTX(SW, 0x50),
-	.base.ofuncs = &(struct nouveau_ofuncs) {
+	.base.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv50_sw_context_ctor,
 		.dtor = nv50_sw_context_dtor,
-		.init = _nouveau_sw_context_init,
-		.fini = _nouveau_sw_context_fini,
+		.init = _nvkm_sw_context_init,
+		.fini = _nvkm_sw_context_fini,
 	},
 	.vblank = nv50_sw_vblsem_release,
 };
@@ -209,15 +201,15 @@ nv50_sw_cclass = {
  ******************************************************************************/
 
 int
-nv50_sw_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
-		   struct nouveau_oclass *oclass, void *data, u32 size,
-		   struct nouveau_object **pobject)
+nv50_sw_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+	     struct nvkm_oclass *oclass, void *data, u32 size,
+	     struct nvkm_object **pobject)
 {
 	struct nv50_sw_oclass *pclass = (void *)oclass;
 	struct nv50_sw_priv *priv;
 	int ret;
 
-	ret = nouveau_sw_create(parent, engine, oclass, &priv);
+	ret = nvkm_sw_create(parent, engine, oclass, &priv);
 	*pobject = nv_object(priv);
 	if (ret)
 		return ret;
@@ -228,14 +220,14 @@ nv50_sw_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	return 0;
 }
 
-struct nouveau_oclass *
+struct nvkm_oclass *
 nv50_sw_oclass = &(struct nv50_sw_oclass) {
 	.base.handle = NV_ENGINE(SW, 0x50),
-	.base.ofuncs = &(struct nouveau_ofuncs) {
+	.base.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv50_sw_ctor,
-		.dtor = _nouveau_sw_dtor,
-		.init = _nouveau_sw_init,
-		.fini = _nouveau_sw_fini,
+		.dtor = _nvkm_sw_dtor,
+		.init = _nvkm_sw_init,
+		.fini = _nvkm_sw_fini,
 	},
 	.cclass = &nv50_sw_cclass.base,
 	.sclass =  nv50_sw_sclass,

commit 878da15adb5ddce57339b87685d8b4630e60085f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:24:57 2015 +1000

    drm/nouveau/disp: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
index a214a4debcc4..6833e00827c2 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -23,6 +23,7 @@
  */
 
 #include <core/os.h>
+#include <core/device.h>
 #include <core/engctx.h>
 #include <core/namedb.h>
 #include <core/handle.h>

commit 8700287be2b12d091d477fe0568c3858bdedf4e7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 12:34:00 2015 +1000

    drm/nouveau/sw: rename from software (no binary change)
    
    Shorter device name, make consistent with our engine enums.
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
new file mode 100644
index 000000000000..a214a4debcc4
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c
@@ -0,0 +1,241 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <core/os.h>
+#include <core/engctx.h>
+#include <core/namedb.h>
+#include <core/handle.h>
+#include <core/gpuobj.h>
+#include <core/event.h>
+#include <nvif/event.h>
+
+#include <subdev/bar.h>
+
+#include <engine/disp.h>
+
+#include "nv50.h"
+
+/*******************************************************************************
+ * software object classes
+ ******************************************************************************/
+
+static int
+nv50_sw_mthd_dma_vblsem(struct nouveau_object *object, u32 mthd,
+			      void *args, u32 size)
+{
+	struct nv50_sw_chan *chan = (void *)nv_engctx(object->parent);
+	struct nouveau_fifo_chan *fifo = (void *)nv_object(chan)->parent;
+	struct nouveau_handle *handle;
+	int ret = -EINVAL;
+
+	handle = nouveau_namedb_get(nv_namedb(fifo), *(u32 *)args);
+	if (!handle)
+		return -ENOENT;
+
+	if (nv_iclass(handle->object, NV_GPUOBJ_CLASS)) {
+		struct nouveau_gpuobj *gpuobj = nv_gpuobj(handle->object);
+		chan->vblank.ctxdma = gpuobj->node->offset >> 4;
+		ret = 0;
+	}
+	nouveau_namedb_put(handle);
+	return ret;
+}
+
+static int
+nv50_sw_mthd_vblsem_offset(struct nouveau_object *object, u32 mthd,
+				 void *args, u32 size)
+{
+	struct nv50_sw_chan *chan = (void *)nv_engctx(object->parent);
+	chan->vblank.offset = *(u32 *)args;
+	return 0;
+}
+
+int
+nv50_sw_mthd_vblsem_value(struct nouveau_object *object, u32 mthd,
+				void *args, u32 size)
+{
+	struct nv50_sw_chan *chan = (void *)nv_engctx(object->parent);
+	chan->vblank.value = *(u32 *)args;
+	return 0;
+}
+
+int
+nv50_sw_mthd_vblsem_release(struct nouveau_object *object, u32 mthd,
+				  void *args, u32 size)
+{
+	struct nv50_sw_chan *chan = (void *)nv_engctx(object->parent);
+	u32 head = *(u32 *)args;
+	if (head >= nouveau_disp(chan)->vblank.index_nr)
+		return -EINVAL;
+
+	nvkm_notify_get(&chan->vblank.notify[head]);
+	return 0;
+}
+
+int
+nv50_sw_mthd_flip(struct nouveau_object *object, u32 mthd,
+			void *args, u32 size)
+{
+	struct nv50_sw_chan *chan = (void *)nv_engctx(object->parent);
+	if (chan->base.flip)
+		return chan->base.flip(chan->base.flip_data);
+	return -EINVAL;
+}
+
+static struct nouveau_omthds
+nv50_sw_omthds[] = {
+	{ 0x018c, 0x018c, nv50_sw_mthd_dma_vblsem },
+	{ 0x0400, 0x0400, nv50_sw_mthd_vblsem_offset },
+	{ 0x0404, 0x0404, nv50_sw_mthd_vblsem_value },
+	{ 0x0408, 0x0408, nv50_sw_mthd_vblsem_release },
+	{ 0x0500, 0x0500, nv50_sw_mthd_flip },
+	{}
+};
+
+static struct nouveau_oclass
+nv50_sw_sclass[] = {
+	{ 0x506e, &nouveau_object_ofuncs, nv50_sw_omthds },
+	{}
+};
+
+/*******************************************************************************
+ * software context
+ ******************************************************************************/
+
+static int
+nv50_sw_vblsem_release(struct nvkm_notify *notify)
+{
+	struct nv50_sw_chan *chan =
+		container_of(notify, typeof(*chan), vblank.notify[notify->index]);
+	struct nv50_sw_priv *priv = (void *)nv_object(chan)->engine;
+	struct nouveau_bar *bar = nouveau_bar(priv);
+
+	nv_wr32(priv, 0x001704, chan->vblank.channel);
+	nv_wr32(priv, 0x001710, 0x80000000 | chan->vblank.ctxdma);
+	bar->flush(bar);
+
+	if (nv_device(priv)->chipset == 0x50) {
+		nv_wr32(priv, 0x001570, chan->vblank.offset);
+		nv_wr32(priv, 0x001574, chan->vblank.value);
+	} else {
+		nv_wr32(priv, 0x060010, chan->vblank.offset);
+		nv_wr32(priv, 0x060014, chan->vblank.value);
+	}
+
+	return NVKM_NOTIFY_DROP;
+}
+
+void
+nv50_sw_context_dtor(struct nouveau_object *object)
+{
+	struct nv50_sw_chan *chan = (void *)object;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(chan->vblank.notify); i++)
+		nvkm_notify_fini(&chan->vblank.notify[i]);
+
+	nouveau_sw_context_destroy(&chan->base);
+}
+
+int
+nv50_sw_context_ctor(struct nouveau_object *parent,
+			   struct nouveau_object *engine,
+			   struct nouveau_oclass *oclass, void *data, u32 size,
+			   struct nouveau_object **pobject)
+{
+	struct nouveau_disp *pdisp = nouveau_disp(parent);
+	struct nv50_sw_cclass *pclass = (void *)oclass;
+	struct nv50_sw_chan *chan;
+	int ret, i;
+
+	ret = nouveau_sw_context_create(parent, engine, oclass, &chan);
+	*pobject = nv_object(chan);
+	if (ret)
+		return ret;
+
+	for (i = 0; pdisp && i < pdisp->vblank.index_nr; i++) {
+		ret = nvkm_notify_init(NULL, &pdisp->vblank, pclass->vblank,
+				       false,
+				       &(struct nvif_notify_head_req_v0) {
+					.head = i,
+				       },
+				       sizeof(struct nvif_notify_head_req_v0),
+				       sizeof(struct nvif_notify_head_rep_v0),
+				       &chan->vblank.notify[i]);
+		if (ret)
+			return ret;
+	}
+
+	chan->vblank.channel = nv_gpuobj(parent->parent)->addr >> 12;
+	return 0;
+}
+
+static struct nv50_sw_cclass
+nv50_sw_cclass = {
+	.base.handle = NV_ENGCTX(SW, 0x50),
+	.base.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv50_sw_context_ctor,
+		.dtor = nv50_sw_context_dtor,
+		.init = _nouveau_sw_context_init,
+		.fini = _nouveau_sw_context_fini,
+	},
+	.vblank = nv50_sw_vblsem_release,
+};
+
+/*******************************************************************************
+ * software engine/subdev functions
+ ******************************************************************************/
+
+int
+nv50_sw_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+		   struct nouveau_oclass *oclass, void *data, u32 size,
+		   struct nouveau_object **pobject)
+{
+	struct nv50_sw_oclass *pclass = (void *)oclass;
+	struct nv50_sw_priv *priv;
+	int ret;
+
+	ret = nouveau_sw_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	nv_engine(priv)->cclass = pclass->cclass;
+	nv_engine(priv)->sclass = pclass->sclass;
+	nv_subdev(priv)->intr = nv04_sw_intr;
+	return 0;
+}
+
+struct nouveau_oclass *
+nv50_sw_oclass = &(struct nv50_sw_oclass) {
+	.base.handle = NV_ENGINE(SW, 0x50),
+	.base.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv50_sw_ctor,
+		.dtor = _nouveau_sw_dtor,
+		.init = _nouveau_sw_init,
+		.fini = _nouveau_sw_fini,
+	},
+	.cclass = &nv50_sw_cclass.base,
+	.sclass =  nv50_sw_sclass,
+}.base;
