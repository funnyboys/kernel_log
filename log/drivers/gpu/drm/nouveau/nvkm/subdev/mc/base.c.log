commit f2e55b9ea903ccd31f8d38f460a063f41e646232
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Dec 11 14:50:02 2018 +1000

    drm/nouveau/mc/tu104: initial support
    
    Things are a bit different here on Turing, and will require further changes
    yet once I've investigated them more thoroughly.
    
    For now though, the existing GP100 code is compatible enough with one small
    hack to forward on fault buffer interrupts.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 09f669ac6630..0e57ab2a709f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -108,6 +108,9 @@ nvkm_mc_intr(struct nvkm_device *device, bool *handled)
 	if (stat)
 		nvkm_error(&mc->subdev, "intr %08x\n", stat);
 	*handled = intr != 0;
+
+	if (mc->func->intr_hack)
+		mc->func->intr_hack(mc, handled);
 }
 
 static u32

commit c599dd4b70d3d8a485be6b80d8b190beb3df874b
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Tue Dec 13 17:11:18 2016 +0900

    drm/nouveau/mc: add nvkm_mc_enabled() function
    
    Add a function that allows us to query whether a given subdev is
    currently enabled or not.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 6b25e25f9eba..09f669ac6630 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -161,6 +161,16 @@ nvkm_mc_enable(struct nvkm_device *device, enum nvkm_devidx devidx)
 	}
 }
 
+bool
+nvkm_mc_enabled(struct nvkm_device *device, enum nvkm_devidx devidx)
+{
+	u64 pmc_enable = nvkm_mc_reset_mask(device, false, devidx);
+
+	return (pmc_enable != 0) &&
+	       ((nvkm_rd32(device, 0x000200) & pmc_enable) == pmc_enable);
+}
+
+
 static int
 nvkm_mc_fini(struct nvkm_subdev *subdev, bool suspend)
 {

commit 66adbfb00d55996079661d11ff9b6064b925b44e
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon May 30 08:39:27 2016 +1000

    drm/nouveau/mc: support for temporarily masking interrupts from a specific device
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 6f10638ab9e4..6b25e25f9eba 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -34,6 +34,21 @@ nvkm_mc_unk260(struct nvkm_device *device, u32 data)
 		mc->func->unk260(mc, data);
 }
 
+void
+nvkm_mc_intr_mask(struct nvkm_device *device, enum nvkm_devidx devidx, bool en)
+{
+	struct nvkm_mc *mc = device->mc;
+	const struct nvkm_mc_map *map;
+	if (likely(mc) && mc->func->intr_mask) {
+		u32 mask = nvkm_top_intr_mask(device, devidx);
+		for (map = mc->func->intr; !mask && map->stat; map++) {
+			if (map->unit == devidx)
+				mask = map->stat;
+		}
+		mc->func->intr_mask(mc, mask, en ? mask : 0);
+	}
+}
+
 void
 nvkm_mc_intr_unarm(struct nvkm_device *device)
 {

commit 6e09a578995f4e724b90b1a8b1d5207a2ce5e3c8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon May 30 08:27:22 2016 +1000

    drm/nouveau/mc: s/intr_mask/intr_stat/
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index e887df08e8cf..6f10638ab9e4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -51,9 +51,9 @@ nvkm_mc_intr_rearm(struct nvkm_device *device)
 }
 
 static u32
-nvkm_mc_intr_mask(struct nvkm_mc *mc)
+nvkm_mc_intr_stat(struct nvkm_mc *mc)
 {
-	u32 intr = mc->func->intr_mask(mc);
+	u32 intr = mc->func->intr_stat(mc);
 	if (WARN_ON_ONCE(intr == 0xffffffff))
 		intr = 0; /* likely fallen off the bus */
 	return intr;
@@ -71,7 +71,7 @@ nvkm_mc_intr(struct nvkm_device *device, bool *handled)
 	if (unlikely(!mc))
 		return;
 
-	intr = nvkm_mc_intr_mask(mc);
+	intr = nvkm_mc_intr_stat(mc);
 	stat = nvkm_top_intr(device, intr, &subdevs);
 	while (subdevs) {
 		enum nvkm_devidx subidx = __ffs64(subdevs);

commit 3c2a536b0cbac98035cba42c880c58fd399cb167
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon May 30 08:23:41 2016 +1000

    drm/nouveau/mc: expose device enable/disable separately, as well as reset
    
    There are cases where subdevs need to perform additonal actions around
    the master reset, so we want to expost the operations separately.
    
    This commit also adds a flag to the NV_PMC_ENABLE bitfield definitions
    which allow skipping the automatic reset() called from core/subdev.c.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 563a528d42ce..e887df08e8cf 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -95,22 +95,32 @@ nvkm_mc_intr(struct nvkm_device *device, bool *handled)
 	*handled = intr != 0;
 }
 
-static void
-nvkm_mc_reset_(struct nvkm_mc *mc, enum nvkm_devidx devidx)
+static u32
+nvkm_mc_reset_mask(struct nvkm_device *device, bool isauto,
+		   enum nvkm_devidx devidx)
 {
-	struct nvkm_device *device = mc->subdev.device;
+	struct nvkm_mc *mc = device->mc;
 	const struct nvkm_mc_map *map;
-	u64 pmc_enable;
-
-	if (!(pmc_enable = nvkm_top_reset(device, devidx))) {
-		for (map = mc->func->reset; map && map->stat; map++) {
-			if (map->unit == devidx) {
-				pmc_enable = map->stat;
-				break;
+	u64 pmc_enable = 0;
+	if (likely(mc)) {
+		if (!(pmc_enable = nvkm_top_reset(device, devidx))) {
+			for (map = mc->func->reset; map && map->stat; map++) {
+				if (!isauto || !map->noauto) {
+					if (map->unit == devidx) {
+						pmc_enable = map->stat;
+						break;
+					}
+				}
 			}
 		}
 	}
+	return pmc_enable;
+}
 
+void
+nvkm_mc_reset(struct nvkm_device *device, enum nvkm_devidx devidx)
+{
+	u64 pmc_enable = nvkm_mc_reset_mask(device, true, devidx);
 	if (pmc_enable) {
 		nvkm_mask(device, 0x000200, pmc_enable, 0x00000000);
 		nvkm_mask(device, 0x000200, pmc_enable, pmc_enable);
@@ -119,11 +129,21 @@ nvkm_mc_reset_(struct nvkm_mc *mc, enum nvkm_devidx devidx)
 }
 
 void
-nvkm_mc_reset(struct nvkm_device *device, enum nvkm_devidx devidx)
+nvkm_mc_disable(struct nvkm_device *device, enum nvkm_devidx devidx)
 {
-	struct nvkm_mc *mc = device->mc;
-	if (likely(mc))
-		nvkm_mc_reset_(mc, devidx);
+	u64 pmc_enable = nvkm_mc_reset_mask(device, false, devidx);
+	if (pmc_enable)
+		nvkm_mask(device, 0x000200, pmc_enable, 0x00000000);
+}
+
+void
+nvkm_mc_enable(struct nvkm_device *device, enum nvkm_devidx devidx)
+{
+	u64 pmc_enable = nvkm_mc_reset_mask(device, false, devidx);
+	if (pmc_enable) {
+		nvkm_mask(device, 0x000200, pmc_enable, pmc_enable);
+		nvkm_rd32(device, 0x000200);
+	}
 }
 
 static int

commit d398119034a4b78d475e3853b3b0ad9fa26f6c52
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon May 30 08:17:58 2016 +1000

    drm/nouveau/mc: take nvkm_device as argument to public functions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index fa6b9932d327..563a528d42ce 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -27,22 +27,27 @@
 #include <subdev/top.h>
 
 void
-nvkm_mc_unk260(struct nvkm_mc *mc, u32 data)
+nvkm_mc_unk260(struct nvkm_device *device, u32 data)
 {
-	if (mc->func->unk260)
+	struct nvkm_mc *mc = device->mc;
+	if (likely(mc) && mc->func->unk260)
 		mc->func->unk260(mc, data);
 }
 
 void
-nvkm_mc_intr_unarm(struct nvkm_mc *mc)
+nvkm_mc_intr_unarm(struct nvkm_device *device)
 {
-	return mc->func->intr_unarm(mc);
+	struct nvkm_mc *mc = device->mc;
+	if (likely(mc))
+		mc->func->intr_unarm(mc);
 }
 
 void
-nvkm_mc_intr_rearm(struct nvkm_mc *mc)
+nvkm_mc_intr_rearm(struct nvkm_device *device)
 {
-	return mc->func->intr_rearm(mc);
+	struct nvkm_mc *mc = device->mc;
+	if (likely(mc))
+		mc->func->intr_rearm(mc);
 }
 
 static u32
@@ -55,14 +60,18 @@ nvkm_mc_intr_mask(struct nvkm_mc *mc)
 }
 
 void
-nvkm_mc_intr(struct nvkm_mc *mc, bool *handled)
+nvkm_mc_intr(struct nvkm_device *device, bool *handled)
 {
-	struct nvkm_device *device = mc->subdev.device;
+	struct nvkm_mc *mc = device->mc;
 	struct nvkm_subdev *subdev;
-	const struct nvkm_mc_map *map = mc->func->intr;
-	u32 stat, intr = nvkm_mc_intr_mask(mc);
+	const struct nvkm_mc_map *map;
+	u32 stat, intr;
 	u64 subdevs;
 
+	if (unlikely(!mc))
+		return;
+
+	intr = nvkm_mc_intr_mask(mc);
 	stat = nvkm_top_intr(device, intr, &subdevs);
 	while (subdevs) {
 		enum nvkm_devidx subidx = __ffs64(subdevs);
@@ -72,14 +81,13 @@ nvkm_mc_intr(struct nvkm_mc *mc, bool *handled)
 		subdevs &= ~BIT_ULL(subidx);
 	}
 
-	while (map->stat) {
+	for (map = mc->func->intr; map->stat; map++) {
 		if (intr & map->stat) {
 			subdev = nvkm_device_subdev(device, map->unit);
 			if (subdev)
 				nvkm_subdev_intr(subdev);
 			stat &= ~map->stat;
 		}
-		map++;
 	}
 
 	if (stat)
@@ -111,8 +119,9 @@ nvkm_mc_reset_(struct nvkm_mc *mc, enum nvkm_devidx devidx)
 }
 
 void
-nvkm_mc_reset(struct nvkm_mc *mc, enum nvkm_devidx devidx)
+nvkm_mc_reset(struct nvkm_device *device, enum nvkm_devidx devidx)
 {
+	struct nvkm_mc *mc = device->mc;
 	if (likely(mc))
 		nvkm_mc_reset_(mc, devidx);
 }
@@ -120,8 +129,7 @@ nvkm_mc_reset(struct nvkm_mc *mc, enum nvkm_devidx devidx)
 static int
 nvkm_mc_fini(struct nvkm_subdev *subdev, bool suspend)
 {
-	struct nvkm_mc *mc = nvkm_mc(subdev);
-	nvkm_mc_intr_unarm(mc);
+	nvkm_mc_intr_unarm(subdev->device);
 	return 0;
 }
 
@@ -131,7 +139,7 @@ nvkm_mc_init(struct nvkm_subdev *subdev)
 	struct nvkm_mc *mc = nvkm_mc(subdev);
 	if (mc->func->init)
 		mc->func->init(mc);
-	nvkm_mc_intr_rearm(mc);
+	nvkm_mc_intr_rearm(subdev->device);
 	return 0;
 }
 

commit d6adbe949d57f6933d6ac29cce3e7168a53e3749
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon May 30 09:23:06 2016 +1000

    drm/nouveau/mc: allow construction of subclassed device
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 60d5c956f676..fa6b9932d327 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -148,16 +148,21 @@ nvkm_mc = {
 	.fini = nvkm_mc_fini,
 };
 
+void
+nvkm_mc_ctor(const struct nvkm_mc_func *func, struct nvkm_device *device,
+	     int index, struct nvkm_mc *mc)
+{
+	nvkm_subdev_ctor(&nvkm_mc, device, index, &mc->subdev);
+	mc->func = func;
+}
+
 int
 nvkm_mc_new_(const struct nvkm_mc_func *func, struct nvkm_device *device,
 	     int index, struct nvkm_mc **pmc)
 {
 	struct nvkm_mc *mc;
-
 	if (!(mc = *pmc = kzalloc(sizeof(*mc), GFP_KERNEL)))
 		return -ENOMEM;
-
-	nvkm_subdev_ctor(&nvkm_mc, device, index, &mc->subdev);
-	mc->func = func;
+	nvkm_mc_ctor(func, device, index, *pmc);
 	return 0;
 }

commit 952eb819e3234b9deceb3287398f0c2a272e4760
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon May 30 10:32:55 2016 +1000

    drm/nouveau/top: take nvkm_device as argument to public functions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 350a8caa84c8..60d5c956f676 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -63,7 +63,7 @@ nvkm_mc_intr(struct nvkm_mc *mc, bool *handled)
 	u32 stat, intr = nvkm_mc_intr_mask(mc);
 	u64 subdevs;
 
-	stat = nvkm_top_intr(device->top, intr, &subdevs);
+	stat = nvkm_top_intr(device, intr, &subdevs);
 	while (subdevs) {
 		enum nvkm_devidx subidx = __ffs64(subdevs);
 		subdev = nvkm_device_subdev(device, subidx);
@@ -94,7 +94,7 @@ nvkm_mc_reset_(struct nvkm_mc *mc, enum nvkm_devidx devidx)
 	const struct nvkm_mc_map *map;
 	u64 pmc_enable;
 
-	if (!(pmc_enable = nvkm_top_reset(device->top, devidx))) {
+	if (!(pmc_enable = nvkm_top_reset(device, devidx))) {
 		for (map = mc->func->reset; map && map->stat; map++) {
 			if (map->unit == devidx) {
 				pmc_enable = map->stat;

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 184325cdc138..350a8caa84c8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -103,11 +103,6 @@ nvkm_mc_reset_(struct nvkm_mc *mc, enum nvkm_devidx devidx)
 		}
 	}
 
-	if (!pmc_enable) {
-		struct nvkm_subdev *subdev = nvkm_device_subdev(device, devidx);
-		pmc_enable = subdev->pmc_enable;
-	}
-
 	if (pmc_enable) {
 		nvkm_mask(device, 0x000200, pmc_enable, 0x00000000);
 		nvkm_mask(device, 0x000200, pmc_enable, pmc_enable);
@@ -162,7 +157,7 @@ nvkm_mc_new_(const struct nvkm_mc_func *func, struct nvkm_device *device,
 	if (!(mc = *pmc = kzalloc(sizeof(*mc), GFP_KERNEL)))
 		return -ENOMEM;
 
-	nvkm_subdev_ctor(&nvkm_mc, device, index, 0, &mc->subdev);
+	nvkm_subdev_ctor(&nvkm_mc, device, index, &mc->subdev);
 	mc->func = func;
 	return 0;
 }

commit 921be10d85ca10973b374ef10273c2f228081ee8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/mc: implement support for PTOP interrupt routing
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 134d44aba1e5..184325cdc138 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -60,9 +60,18 @@ nvkm_mc_intr(struct nvkm_mc *mc, bool *handled)
 	struct nvkm_device *device = mc->subdev.device;
 	struct nvkm_subdev *subdev;
 	const struct nvkm_mc_map *map = mc->func->intr;
-	u32 stat, intr;
+	u32 stat, intr = nvkm_mc_intr_mask(mc);
+	u64 subdevs;
+
+	stat = nvkm_top_intr(device->top, intr, &subdevs);
+	while (subdevs) {
+		enum nvkm_devidx subidx = __ffs64(subdevs);
+		subdev = nvkm_device_subdev(device, subidx);
+		if (subdev)
+			nvkm_subdev_intr(subdev);
+		subdevs &= ~BIT_ULL(subidx);
+	}
 
-	stat = intr = nvkm_mc_intr_mask(mc);
 	while (map->stat) {
 		if (intr & map->stat) {
 			subdev = nvkm_device_subdev(device, map->unit);

commit 583f8e4ea216d9d0212e63ede384893ec0c1b742
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/mc: implement support for PTOP reset info
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 3793bc7889d5..134d44aba1e5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -24,6 +24,7 @@
 #include "priv.h"
 
 #include <core/option.h>
+#include <subdev/top.h>
 
 void
 nvkm_mc_unk260(struct nvkm_mc *mc, u32 data)
@@ -82,12 +83,14 @@ nvkm_mc_reset_(struct nvkm_mc *mc, enum nvkm_devidx devidx)
 {
 	struct nvkm_device *device = mc->subdev.device;
 	const struct nvkm_mc_map *map;
-	u64 pmc_enable = 0;
-
-	for (map = mc->func->reset; map && map->stat; map++) {
-		if (map->unit == devidx) {
-			pmc_enable = map->stat;
-			break;
+	u64 pmc_enable;
+
+	if (!(pmc_enable = nvkm_top_reset(device->top, devidx))) {
+		for (map = mc->func->reset; map && map->stat; map++) {
+			if (map->unit == devidx) {
+				pmc_enable = map->stat;
+				break;
+			}
 		}
 	}
 

commit 70b01f07dbd093c96e9910ba613c3d40346ee222
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/mc: allow for local definition of reset bits
    
    With the addition of PTOP-specified reset bits, it makes more sense to
    move the definitions here rather than in individual subdev
    implementations.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 95183011510e..3793bc7889d5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -81,8 +81,21 @@ static void
 nvkm_mc_reset_(struct nvkm_mc *mc, enum nvkm_devidx devidx)
 {
 	struct nvkm_device *device = mc->subdev.device;
-	struct nvkm_subdev *subdev = nvkm_device_subdev(device, devidx);
-	u64 pmc_enable = subdev->pmc_enable;
+	const struct nvkm_mc_map *map;
+	u64 pmc_enable = 0;
+
+	for (map = mc->func->reset; map && map->stat; map++) {
+		if (map->unit == devidx) {
+			pmc_enable = map->stat;
+			break;
+		}
+	}
+
+	if (!pmc_enable) {
+		struct nvkm_subdev *subdev = nvkm_device_subdev(device, devidx);
+		pmc_enable = subdev->pmc_enable;
+	}
+
 	if (pmc_enable) {
 		nvkm_mask(device, 0x000200, pmc_enable, 0x00000000);
 		nvkm_mask(device, 0x000200, pmc_enable, pmc_enable);

commit 6defde5ab3e1d8b8fcd187517f878955b5e30465
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/mc: add helper function to handle device reset
    
    This will be later extended to handle PTOP-specified reset masks as well
    as the hardcoded ones.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index e6c5bc461ba6..95183011510e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -77,6 +77,26 @@ nvkm_mc_intr(struct nvkm_mc *mc, bool *handled)
 	*handled = intr != 0;
 }
 
+static void
+nvkm_mc_reset_(struct nvkm_mc *mc, enum nvkm_devidx devidx)
+{
+	struct nvkm_device *device = mc->subdev.device;
+	struct nvkm_subdev *subdev = nvkm_device_subdev(device, devidx);
+	u64 pmc_enable = subdev->pmc_enable;
+	if (pmc_enable) {
+		nvkm_mask(device, 0x000200, pmc_enable, 0x00000000);
+		nvkm_mask(device, 0x000200, pmc_enable, pmc_enable);
+		nvkm_rd32(device, 0x000200);
+	}
+}
+
+void
+nvkm_mc_reset(struct nvkm_mc *mc, enum nvkm_devidx devidx)
+{
+	if (likely(mc))
+		nvkm_mc_reset_(mc, devidx);
+}
+
 static int
 nvkm_mc_fini(struct nvkm_subdev *subdev, bool suspend)
 {

commit 87f313e6e6dcd1f46cc4ad134980584c822b67d6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/mc: rename struct nvkm_mc_intr to nvkm_mc_map
    
    This will also be used to define NV_PMC_ENABLE <-> subdev mappings in an
    upcoming commit.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 954fbbe56c4b..e6c5bc461ba6 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -58,7 +58,7 @@ nvkm_mc_intr(struct nvkm_mc *mc, bool *handled)
 {
 	struct nvkm_device *device = mc->subdev.device;
 	struct nvkm_subdev *subdev;
-	const struct nvkm_mc_intr *map = mc->func->intr;
+	const struct nvkm_mc_map *map = mc->func->intr;
 	u32 stat, intr;
 
 	stat = intr = nvkm_mc_intr_mask(mc);

commit 2b700825e7a7702fb862edba1262c98040dc1bf6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/mc: move device irq handling to platform-specific code
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 6a8d56c7201e..954fbbe56c4b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -44,7 +44,7 @@ nvkm_mc_intr_rearm(struct nvkm_mc *mc)
 	return mc->func->intr_rearm(mc);
 }
 
-u32
+static u32
 nvkm_mc_intr_mask(struct nvkm_mc *mc)
 {
 	u32 intr = mc->func->intr_mask(mc);
@@ -53,39 +53,28 @@ nvkm_mc_intr_mask(struct nvkm_mc *mc)
 	return intr;
 }
 
-static irqreturn_t
-nvkm_mc_intr(int irq, void *arg)
+void
+nvkm_mc_intr(struct nvkm_mc *mc, bool *handled)
 {
-	struct nvkm_mc *mc = arg;
-	struct nvkm_subdev *subdev = &mc->subdev;
-	struct nvkm_device *device = subdev->device;
+	struct nvkm_device *device = mc->subdev.device;
+	struct nvkm_subdev *subdev;
 	const struct nvkm_mc_intr *map = mc->func->intr;
-	struct nvkm_subdev *unit;
-	u32 intr;
-
-	nvkm_mc_intr_unarm(mc);
-	intr = nvkm_mc_intr_mask(mc);
-	if (mc->use_msi)
-		mc->func->msi_rearm(mc);
-
-	if (intr) {
-		u32 stat = intr = nvkm_mc_intr_mask(mc);
-		while (map->stat) {
-			if (intr & map->stat) {
-				unit = nvkm_device_subdev(device, map->unit);
-				if (unit)
-					nvkm_subdev_intr(unit);
-				stat &= ~map->stat;
-			}
-			map++;
+	u32 stat, intr;
+
+	stat = intr = nvkm_mc_intr_mask(mc);
+	while (map->stat) {
+		if (intr & map->stat) {
+			subdev = nvkm_device_subdev(device, map->unit);
+			if (subdev)
+				nvkm_subdev_intr(subdev);
+			stat &= ~map->stat;
 		}
-
-		if (stat)
-			nvkm_error(subdev, "unknown intr %08x\n", stat);
+		map++;
 	}
 
-	nvkm_mc_intr_rearm(mc);
-	return intr ? IRQ_HANDLED : IRQ_NONE;
+	if (stat)
+		nvkm_error(&mc->subdev, "intr %08x\n", stat);
+	*handled = intr != 0;
 }
 
 static int
@@ -96,13 +85,6 @@ nvkm_mc_fini(struct nvkm_subdev *subdev, bool suspend)
 	return 0;
 }
 
-static int
-nvkm_mc_oneinit(struct nvkm_subdev *subdev)
-{
-	struct nvkm_mc *mc = nvkm_mc(subdev);
-	return request_irq(mc->irq, nvkm_mc_intr, IRQF_SHARED, "nvkm", mc);
-}
-
 static int
 nvkm_mc_init(struct nvkm_subdev *subdev)
 {
@@ -116,18 +98,12 @@ nvkm_mc_init(struct nvkm_subdev *subdev)
 static void *
 nvkm_mc_dtor(struct nvkm_subdev *subdev)
 {
-	struct nvkm_mc *mc = nvkm_mc(subdev);
-	struct nvkm_device *device = mc->subdev.device;
-	free_irq(mc->irq, mc);
-	if (mc->use_msi)
-		pci_disable_msi(device->pdev);
-	return mc;
+	return nvkm_mc(subdev);
 }
 
 static const struct nvkm_subdev_func
 nvkm_mc = {
 	.dtor = nvkm_mc_dtor,
-	.oneinit = nvkm_mc_oneinit,
 	.init = nvkm_mc_init,
 	.fini = nvkm_mc_fini,
 };
@@ -137,48 +113,11 @@ nvkm_mc_new_(const struct nvkm_mc_func *func, struct nvkm_device *device,
 	     int index, struct nvkm_mc **pmc)
 {
 	struct nvkm_mc *mc;
-	int ret;
 
 	if (!(mc = *pmc = kzalloc(sizeof(*mc), GFP_KERNEL)))
 		return -ENOMEM;
 
 	nvkm_subdev_ctor(&nvkm_mc, device, index, 0, &mc->subdev);
 	mc->func = func;
-
-	if (nv_device_is_pci(device)) {
-		switch (device->pdev->device & 0x0ff0) {
-		case 0x00f0:
-		case 0x02e0:
-			/* BR02? NFI how these would be handled yet exactly */
-			break;
-		default:
-			switch (device->chipset) {
-			case 0xaa:
-				/* reported broken, nv also disable it */
-				break;
-			default:
-				mc->use_msi = true;
-				break;
-			}
-		}
-
-		mc->use_msi = nvkm_boolopt(device->cfgopt, "NvMSI",
-					    mc->use_msi);
-
-		if (mc->use_msi && mc->func->msi_rearm) {
-			mc->use_msi = pci_enable_msi(device->pdev) == 0;
-			if (mc->use_msi) {
-				nvkm_debug(&mc->subdev, "MSI enabled\n");
-				mc->func->msi_rearm(mc);
-			}
-		} else {
-			mc->use_msi = false;
-		}
-	}
-
-	ret = nv_device_get_irq(device, true);
-	if (ret < 0)
-		return ret;
-	mc->irq = ret;
 	return 0;
 }

commit d4c4cc8373806d0f822f8847f8bcda64f36cb73f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/mc: abstract interface to master intr registers
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 8d0f5aca3d53..6a8d56c7201e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -32,13 +32,24 @@ nvkm_mc_unk260(struct nvkm_mc *mc, u32 data)
 		mc->func->unk260(mc, data);
 }
 
-static inline u32
+void
+nvkm_mc_intr_unarm(struct nvkm_mc *mc)
+{
+	return mc->func->intr_unarm(mc);
+}
+
+void
+nvkm_mc_intr_rearm(struct nvkm_mc *mc)
+{
+	return mc->func->intr_rearm(mc);
+}
+
+u32
 nvkm_mc_intr_mask(struct nvkm_mc *mc)
 {
-	struct nvkm_device *device = mc->subdev.device;
-	u32 intr = nvkm_rd32(device, 0x000100);
-	if (intr == 0xffffffff) /* likely fallen off the bus */
-		intr = 0x00000000;
+	u32 intr = mc->func->intr_mask(mc);
+	if (WARN_ON_ONCE(intr == 0xffffffff))
+		intr = 0; /* likely fallen off the bus */
 	return intr;
 }
 
@@ -52,8 +63,7 @@ nvkm_mc_intr(int irq, void *arg)
 	struct nvkm_subdev *unit;
 	u32 intr;
 
-	nvkm_wr32(device, 0x000140, 0x00000000);
-	nvkm_rd32(device, 0x000140);
+	nvkm_mc_intr_unarm(mc);
 	intr = nvkm_mc_intr_mask(mc);
 	if (mc->use_msi)
 		mc->func->msi_rearm(mc);
@@ -74,14 +84,15 @@ nvkm_mc_intr(int irq, void *arg)
 			nvkm_error(subdev, "unknown intr %08x\n", stat);
 	}
 
-	nvkm_wr32(device, 0x000140, 0x00000001);
+	nvkm_mc_intr_rearm(mc);
 	return intr ? IRQ_HANDLED : IRQ_NONE;
 }
 
 static int
 nvkm_mc_fini(struct nvkm_subdev *subdev, bool suspend)
 {
-	nvkm_wr32(subdev->device, 0x000140, 0x00000000);
+	struct nvkm_mc *mc = nvkm_mc(subdev);
+	nvkm_mc_intr_unarm(mc);
 	return 0;
 }
 
@@ -96,10 +107,9 @@ static int
 nvkm_mc_init(struct nvkm_subdev *subdev)
 {
 	struct nvkm_mc *mc = nvkm_mc(subdev);
-	struct nvkm_device *device = mc->subdev.device;
 	if (mc->func->init)
 		mc->func->init(mc);
-	nvkm_wr32(device, 0x000140, 0x00000001);
+	nvkm_mc_intr_rearm(mc);
 	return 0;
 }
 

commit 54dcadd5b65e12f851ff80af4afef606040ad8b9
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:21 2015 +1000

    drm/nouveau/mc: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index ee4c34f4b9c4..8d0f5aca3d53 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -25,12 +25,11 @@
 
 #include <core/option.h>
 
-static inline void
+void
 nvkm_mc_unk260(struct nvkm_mc *mc, u32 data)
 {
-	const struct nvkm_mc_oclass *impl = (void *)nv_oclass(mc);
-	if (impl->unk260)
-		impl->unk260(mc, data);
+	if (mc->func->unk260)
+		mc->func->unk260(mc, data);
 }
 
 static inline u32
@@ -49,8 +48,7 @@ nvkm_mc_intr(int irq, void *arg)
 	struct nvkm_mc *mc = arg;
 	struct nvkm_subdev *subdev = &mc->subdev;
 	struct nvkm_device *device = subdev->device;
-	const struct nvkm_mc_oclass *oclass = (void *)nv_object(mc)->oclass;
-	const struct nvkm_mc_intr *map = oclass->intr;
+	const struct nvkm_mc_intr *map = mc->func->intr;
 	struct nvkm_subdev *unit;
 	u32 intr;
 
@@ -58,13 +56,13 @@ nvkm_mc_intr(int irq, void *arg)
 	nvkm_rd32(device, 0x000140);
 	intr = nvkm_mc_intr_mask(mc);
 	if (mc->use_msi)
-		oclass->msi_rearm(mc);
+		mc->func->msi_rearm(mc);
 
 	if (intr) {
 		u32 stat = intr = nvkm_mc_intr_mask(mc);
 		while (map->stat) {
 			if (intr & map->stat) {
-				unit = nvkm_subdev(mc, map->unit);
+				unit = nvkm_device_subdev(device, map->unit);
 				if (unit)
 					nvkm_subdev_intr(unit);
 				stat &= ~map->stat;
@@ -80,54 +78,62 @@ nvkm_mc_intr(int irq, void *arg)
 	return intr ? IRQ_HANDLED : IRQ_NONE;
 }
 
-int
-_nvkm_mc_fini(struct nvkm_object *object, bool suspend)
+static int
+nvkm_mc_fini(struct nvkm_subdev *subdev, bool suspend)
 {
-	struct nvkm_mc *mc = (void *)object;
-	struct nvkm_device *device = mc->subdev.device;
-	nvkm_wr32(device, 0x000140, 0x00000000);
-	return nvkm_subdev_fini_old(&mc->subdev, suspend);
+	nvkm_wr32(subdev->device, 0x000140, 0x00000000);
+	return 0;
 }
 
-int
-_nvkm_mc_init(struct nvkm_object *object)
+static int
+nvkm_mc_oneinit(struct nvkm_subdev *subdev)
+{
+	struct nvkm_mc *mc = nvkm_mc(subdev);
+	return request_irq(mc->irq, nvkm_mc_intr, IRQF_SHARED, "nvkm", mc);
+}
+
+static int
+nvkm_mc_init(struct nvkm_subdev *subdev)
 {
-	struct nvkm_mc *mc = (void *)object;
+	struct nvkm_mc *mc = nvkm_mc(subdev);
 	struct nvkm_device *device = mc->subdev.device;
-	int ret = nvkm_subdev_init_old(&mc->subdev);
-	if (ret)
-		return ret;
+	if (mc->func->init)
+		mc->func->init(mc);
 	nvkm_wr32(device, 0x000140, 0x00000001);
 	return 0;
 }
 
-void
-_nvkm_mc_dtor(struct nvkm_object *object)
+static void *
+nvkm_mc_dtor(struct nvkm_subdev *subdev)
 {
-	struct nvkm_mc *mc = (void *)object;
+	struct nvkm_mc *mc = nvkm_mc(subdev);
 	struct nvkm_device *device = mc->subdev.device;
 	free_irq(mc->irq, mc);
 	if (mc->use_msi)
 		pci_disable_msi(device->pdev);
-	nvkm_subdev_destroy(&mc->subdev);
+	return mc;
 }
 
+static const struct nvkm_subdev_func
+nvkm_mc = {
+	.dtor = nvkm_mc_dtor,
+	.oneinit = nvkm_mc_oneinit,
+	.init = nvkm_mc_init,
+	.fini = nvkm_mc_fini,
+};
+
 int
-nvkm_mc_create_(struct nvkm_object *parent, struct nvkm_object *engine,
-		struct nvkm_oclass *bclass, int length, void **pobject)
+nvkm_mc_new_(const struct nvkm_mc_func *func, struct nvkm_device *device,
+	     int index, struct nvkm_mc **pmc)
 {
-	const struct nvkm_mc_oclass *oclass = (void *)bclass;
-	struct nvkm_device *device = (void *)parent;
 	struct nvkm_mc *mc;
 	int ret;
 
-	ret = nvkm_subdev_create_(parent, engine, bclass, 0, "PMC",
-				  "master", length, pobject);
-	mc = *pobject;
-	if (ret)
-		return ret;
+	if (!(mc = *pmc = kzalloc(sizeof(*mc), GFP_KERNEL)))
+		return -ENOMEM;
 
-	mc->unk260 = nvkm_mc_unk260;
+	nvkm_subdev_ctor(&nvkm_mc, device, index, 0, &mc->subdev);
+	mc->func = func;
 
 	if (nv_device_is_pci(device)) {
 		switch (device->pdev->device & 0x0ff0) {
@@ -149,11 +155,11 @@ nvkm_mc_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		mc->use_msi = nvkm_boolopt(device->cfgopt, "NvMSI",
 					    mc->use_msi);
 
-		if (mc->use_msi && oclass->msi_rearm) {
+		if (mc->use_msi && mc->func->msi_rearm) {
 			mc->use_msi = pci_enable_msi(device->pdev) == 0;
 			if (mc->use_msi) {
 				nvkm_debug(&mc->subdev, "MSI enabled\n");
-				oclass->msi_rearm(mc);
+				mc->func->msi_rearm(mc);
 			}
 		} else {
 			mc->use_msi = false;
@@ -164,10 +170,5 @@ nvkm_mc_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret < 0)
 		return ret;
 	mc->irq = ret;
-
-	ret = request_irq(mc->irq, nvkm_mc_intr, IRQF_SHARED, "nvkm", mc);
-	if (ret < 0)
-		return ret;
-
 	return 0;
 }

commit 6cf813fb26640ef539051fb7f965af8c9ff10d92
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/device: prepare for new-style subdevs
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index f861a02d8d59..ee4c34f4b9c4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -65,8 +65,8 @@ nvkm_mc_intr(int irq, void *arg)
 		while (map->stat) {
 			if (intr & map->stat) {
 				unit = nvkm_subdev(mc, map->unit);
-				if (unit && unit->intr)
-					unit->intr(unit);
+				if (unit)
+					nvkm_subdev_intr(unit);
 				stat &= ~map->stat;
 			}
 			map++;

commit 3a8c3400f3e74638bedd0d2410416aa8b794c0fd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/subdev: rename some functions to avoid upcoming conflicts
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index babd6d8725f0..f861a02d8d59 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -86,7 +86,7 @@ _nvkm_mc_fini(struct nvkm_object *object, bool suspend)
 	struct nvkm_mc *mc = (void *)object;
 	struct nvkm_device *device = mc->subdev.device;
 	nvkm_wr32(device, 0x000140, 0x00000000);
-	return nvkm_subdev_fini(&mc->subdev, suspend);
+	return nvkm_subdev_fini_old(&mc->subdev, suspend);
 }
 
 int
@@ -94,7 +94,7 @@ _nvkm_mc_init(struct nvkm_object *object)
 {
 	struct nvkm_mc *mc = (void *)object;
 	struct nvkm_device *device = mc->subdev.device;
-	int ret = nvkm_subdev_init(&mc->subdev);
+	int ret = nvkm_subdev_init_old(&mc->subdev);
 	if (ret)
 		return ret;
 	nvkm_wr32(device, 0x000140, 0x00000001);

commit c47a48a544ba47eb26ff922203fa0f99c0306907
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:12 2015 +1000

    drm/nouveau/mc: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 80c3c5062e91..babd6d8725f0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -47,7 +47,8 @@ static irqreturn_t
 nvkm_mc_intr(int irq, void *arg)
 {
 	struct nvkm_mc *mc = arg;
-	struct nvkm_device *device = mc->subdev.device;
+	struct nvkm_subdev *subdev = &mc->subdev;
+	struct nvkm_device *device = subdev->device;
 	const struct nvkm_mc_oclass *oclass = (void *)nv_object(mc)->oclass;
 	const struct nvkm_mc_intr *map = oclass->intr;
 	struct nvkm_subdev *unit;
@@ -72,7 +73,7 @@ nvkm_mc_intr(int irq, void *arg)
 		}
 
 		if (stat)
-			nv_error(mc, "unknown intr 0x%08x\n", stat);
+			nvkm_error(subdev, "unknown intr %08x\n", stat);
 	}
 
 	nvkm_wr32(device, 0x000140, 0x00000001);
@@ -151,7 +152,7 @@ nvkm_mc_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		if (mc->use_msi && oclass->msi_rearm) {
 			mc->use_msi = pci_enable_msi(device->pdev) == 0;
 			if (mc->use_msi) {
-				nv_info(mc, "MSI interrupts enabled\n");
+				nvkm_debug(&mc->subdev, "MSI enabled\n");
 				oclass->msi_rearm(mc);
 			}
 		} else {

commit 25e3a463fc1bd39c01cc6d19d2c8b4c4725699b9
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:09 2015 +1000

    drm/nouveau/mc: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 3aa6efcf6725..80c3c5062e91 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -36,7 +36,8 @@ nvkm_mc_unk260(struct nvkm_mc *mc, u32 data)
 static inline u32
 nvkm_mc_intr_mask(struct nvkm_mc *mc)
 {
-	u32 intr = nv_rd32(mc, 0x000100);
+	struct nvkm_device *device = mc->subdev.device;
+	u32 intr = nvkm_rd32(device, 0x000100);
 	if (intr == 0xffffffff) /* likely fallen off the bus */
 		intr = 0x00000000;
 	return intr;
@@ -46,13 +47,14 @@ static irqreturn_t
 nvkm_mc_intr(int irq, void *arg)
 {
 	struct nvkm_mc *mc = arg;
+	struct nvkm_device *device = mc->subdev.device;
 	const struct nvkm_mc_oclass *oclass = (void *)nv_object(mc)->oclass;
 	const struct nvkm_mc_intr *map = oclass->intr;
 	struct nvkm_subdev *unit;
 	u32 intr;
 
-	nv_wr32(mc, 0x000140, 0x00000000);
-	nv_rd32(mc, 0x000140);
+	nvkm_wr32(device, 0x000140, 0x00000000);
+	nvkm_rd32(device, 0x000140);
 	intr = nvkm_mc_intr_mask(mc);
 	if (mc->use_msi)
 		oclass->msi_rearm(mc);
@@ -73,7 +75,7 @@ nvkm_mc_intr(int irq, void *arg)
 			nv_error(mc, "unknown intr 0x%08x\n", stat);
 	}
 
-	nv_wr32(mc, 0x000140, 0x00000001);
+	nvkm_wr32(device, 0x000140, 0x00000001);
 	return intr ? IRQ_HANDLED : IRQ_NONE;
 }
 
@@ -81,7 +83,8 @@ int
 _nvkm_mc_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nvkm_mc *mc = (void *)object;
-	nv_wr32(mc, 0x000140, 0x00000000);
+	struct nvkm_device *device = mc->subdev.device;
+	nvkm_wr32(device, 0x000140, 0x00000000);
 	return nvkm_subdev_fini(&mc->subdev, suspend);
 }
 
@@ -89,18 +92,19 @@ int
 _nvkm_mc_init(struct nvkm_object *object)
 {
 	struct nvkm_mc *mc = (void *)object;
+	struct nvkm_device *device = mc->subdev.device;
 	int ret = nvkm_subdev_init(&mc->subdev);
 	if (ret)
 		return ret;
-	nv_wr32(mc, 0x000140, 0x00000001);
+	nvkm_wr32(device, 0x000140, 0x00000001);
 	return 0;
 }
 
 void
 _nvkm_mc_dtor(struct nvkm_object *object)
 {
-	struct nvkm_device *device = nv_device(object);
 	struct nvkm_mc *mc = (void *)object;
+	struct nvkm_device *device = mc->subdev.device;
 	free_irq(mc->irq, mc);
 	if (mc->use_msi)
 		pci_disable_msi(device->pdev);
@@ -112,7 +116,7 @@ nvkm_mc_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		struct nvkm_oclass *bclass, int length, void **pobject)
 {
 	const struct nvkm_mc_oclass *oclass = (void *)bclass;
-	struct nvkm_device *device = nv_device(parent);
+	struct nvkm_device *device = (void *)parent;
 	struct nvkm_mc *mc;
 	int ret;
 

commit 2ca0ddbc03917f94c6d34820f91d0c920c057df2
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/mc: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 8699e5b2f497..3aa6efcf6725 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -26,17 +26,17 @@
 #include <core/option.h>
 
 static inline void
-nvkm_mc_unk260(struct nvkm_mc *pmc, u32 data)
+nvkm_mc_unk260(struct nvkm_mc *mc, u32 data)
 {
-	const struct nvkm_mc_oclass *impl = (void *)nv_oclass(pmc);
+	const struct nvkm_mc_oclass *impl = (void *)nv_oclass(mc);
 	if (impl->unk260)
-		impl->unk260(pmc, data);
+		impl->unk260(mc, data);
 }
 
 static inline u32
-nvkm_mc_intr_mask(struct nvkm_mc *pmc)
+nvkm_mc_intr_mask(struct nvkm_mc *mc)
 {
-	u32 intr = nv_rd32(pmc, 0x000100);
+	u32 intr = nv_rd32(mc, 0x000100);
 	if (intr == 0xffffffff) /* likely fallen off the bus */
 		intr = 0x00000000;
 	return intr;
@@ -45,23 +45,23 @@ nvkm_mc_intr_mask(struct nvkm_mc *pmc)
 static irqreturn_t
 nvkm_mc_intr(int irq, void *arg)
 {
-	struct nvkm_mc *pmc = arg;
-	const struct nvkm_mc_oclass *oclass = (void *)nv_object(pmc)->oclass;
+	struct nvkm_mc *mc = arg;
+	const struct nvkm_mc_oclass *oclass = (void *)nv_object(mc)->oclass;
 	const struct nvkm_mc_intr *map = oclass->intr;
 	struct nvkm_subdev *unit;
 	u32 intr;
 
-	nv_wr32(pmc, 0x000140, 0x00000000);
-	nv_rd32(pmc, 0x000140);
-	intr = nvkm_mc_intr_mask(pmc);
-	if (pmc->use_msi)
-		oclass->msi_rearm(pmc);
+	nv_wr32(mc, 0x000140, 0x00000000);
+	nv_rd32(mc, 0x000140);
+	intr = nvkm_mc_intr_mask(mc);
+	if (mc->use_msi)
+		oclass->msi_rearm(mc);
 
 	if (intr) {
-		u32 stat = intr = nvkm_mc_intr_mask(pmc);
+		u32 stat = intr = nvkm_mc_intr_mask(mc);
 		while (map->stat) {
 			if (intr & map->stat) {
-				unit = nvkm_subdev(pmc, map->unit);
+				unit = nvkm_subdev(mc, map->unit);
 				if (unit && unit->intr)
 					unit->intr(unit);
 				stat &= ~map->stat;
@@ -70,29 +70,29 @@ nvkm_mc_intr(int irq, void *arg)
 		}
 
 		if (stat)
-			nv_error(pmc, "unknown intr 0x%08x\n", stat);
+			nv_error(mc, "unknown intr 0x%08x\n", stat);
 	}
 
-	nv_wr32(pmc, 0x000140, 0x00000001);
+	nv_wr32(mc, 0x000140, 0x00000001);
 	return intr ? IRQ_HANDLED : IRQ_NONE;
 }
 
 int
 _nvkm_mc_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nvkm_mc *pmc = (void *)object;
-	nv_wr32(pmc, 0x000140, 0x00000000);
-	return nvkm_subdev_fini(&pmc->base, suspend);
+	struct nvkm_mc *mc = (void *)object;
+	nv_wr32(mc, 0x000140, 0x00000000);
+	return nvkm_subdev_fini(&mc->subdev, suspend);
 }
 
 int
 _nvkm_mc_init(struct nvkm_object *object)
 {
-	struct nvkm_mc *pmc = (void *)object;
-	int ret = nvkm_subdev_init(&pmc->base);
+	struct nvkm_mc *mc = (void *)object;
+	int ret = nvkm_subdev_init(&mc->subdev);
 	if (ret)
 		return ret;
-	nv_wr32(pmc, 0x000140, 0x00000001);
+	nv_wr32(mc, 0x000140, 0x00000001);
 	return 0;
 }
 
@@ -100,11 +100,11 @@ void
 _nvkm_mc_dtor(struct nvkm_object *object)
 {
 	struct nvkm_device *device = nv_device(object);
-	struct nvkm_mc *pmc = (void *)object;
-	free_irq(pmc->irq, pmc);
-	if (pmc->use_msi)
+	struct nvkm_mc *mc = (void *)object;
+	free_irq(mc->irq, mc);
+	if (mc->use_msi)
 		pci_disable_msi(device->pdev);
-	nvkm_subdev_destroy(&pmc->base);
+	nvkm_subdev_destroy(&mc->subdev);
 }
 
 int
@@ -113,16 +113,16 @@ nvkm_mc_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 {
 	const struct nvkm_mc_oclass *oclass = (void *)bclass;
 	struct nvkm_device *device = nv_device(parent);
-	struct nvkm_mc *pmc;
+	struct nvkm_mc *mc;
 	int ret;
 
 	ret = nvkm_subdev_create_(parent, engine, bclass, 0, "PMC",
 				  "master", length, pobject);
-	pmc = *pobject;
+	mc = *pobject;
 	if (ret)
 		return ret;
 
-	pmc->unk260 = nvkm_mc_unk260;
+	mc->unk260 = nvkm_mc_unk260;
 
 	if (nv_device_is_pci(device)) {
 		switch (device->pdev->device & 0x0ff0) {
@@ -136,31 +136,31 @@ nvkm_mc_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 				/* reported broken, nv also disable it */
 				break;
 			default:
-				pmc->use_msi = true;
+				mc->use_msi = true;
 				break;
 			}
 		}
 
-		pmc->use_msi = nvkm_boolopt(device->cfgopt, "NvMSI",
-					    pmc->use_msi);
+		mc->use_msi = nvkm_boolopt(device->cfgopt, "NvMSI",
+					    mc->use_msi);
 
-		if (pmc->use_msi && oclass->msi_rearm) {
-			pmc->use_msi = pci_enable_msi(device->pdev) == 0;
-			if (pmc->use_msi) {
-				nv_info(pmc, "MSI interrupts enabled\n");
-				oclass->msi_rearm(pmc);
+		if (mc->use_msi && oclass->msi_rearm) {
+			mc->use_msi = pci_enable_msi(device->pdev) == 0;
+			if (mc->use_msi) {
+				nv_info(mc, "MSI interrupts enabled\n");
+				oclass->msi_rearm(mc);
 			}
 		} else {
-			pmc->use_msi = false;
+			mc->use_msi = false;
 		}
 	}
 
 	ret = nv_device_get_irq(device, true);
 	if (ret < 0)
 		return ret;
-	pmc->irq = ret;
+	mc->irq = ret;
 
-	ret = request_irq(pmc->irq, nvkm_mc_intr, IRQF_SHARED, "nvkm", pmc);
+	ret = request_irq(mc->irq, nvkm_mc_intr, IRQF_SHARED, "nvkm", mc);
 	if (ret < 0)
 		return ret;
 

commit 9ace404b1098221021b01c2ba0eeea0c257fa4a5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/device: include core/device.h automatically for subdevs/engines
    
    Pretty much every subdev/engine is going to need access to nvkm_device
    shortly to touch registers and/or output messages.
    
    The odd placement of the includes is necessary to work around some
    inter-dependencies that currently exist.  This will be fixed later.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 5b051a26653e..8699e5b2f497 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -23,7 +23,6 @@
  */
 #include "priv.h"
 
-#include <core/device.h>
 #include <core/option.h>
 
 static inline void

commit d7e5fcd2e7455094d6f8326b00f70864a700017a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:08:21 2015 +1000

    drm/nouveau/mc: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
index 25e3b9644a3f..5b051a26653e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -21,20 +21,21 @@
  *
  * Authors: Ben Skeggs
  */
-
 #include "priv.h"
+
+#include <core/device.h>
 #include <core/option.h>
 
 static inline void
-nouveau_mc_unk260(struct nouveau_mc *pmc, u32 data)
+nvkm_mc_unk260(struct nvkm_mc *pmc, u32 data)
 {
-	const struct nouveau_mc_oclass *impl = (void *)nv_oclass(pmc);
+	const struct nvkm_mc_oclass *impl = (void *)nv_oclass(pmc);
 	if (impl->unk260)
 		impl->unk260(pmc, data);
 }
 
 static inline u32
-nouveau_mc_intr_mask(struct nouveau_mc *pmc)
+nvkm_mc_intr_mask(struct nvkm_mc *pmc)
 {
 	u32 intr = nv_rd32(pmc, 0x000100);
 	if (intr == 0xffffffff) /* likely fallen off the bus */
@@ -43,25 +44,25 @@ nouveau_mc_intr_mask(struct nouveau_mc *pmc)
 }
 
 static irqreturn_t
-nouveau_mc_intr(int irq, void *arg)
+nvkm_mc_intr(int irq, void *arg)
 {
-	struct nouveau_mc *pmc = arg;
-	const struct nouveau_mc_oclass *oclass = (void *)nv_object(pmc)->oclass;
-	const struct nouveau_mc_intr *map = oclass->intr;
-	struct nouveau_subdev *unit;
+	struct nvkm_mc *pmc = arg;
+	const struct nvkm_mc_oclass *oclass = (void *)nv_object(pmc)->oclass;
+	const struct nvkm_mc_intr *map = oclass->intr;
+	struct nvkm_subdev *unit;
 	u32 intr;
 
 	nv_wr32(pmc, 0x000140, 0x00000000);
 	nv_rd32(pmc, 0x000140);
-	intr = nouveau_mc_intr_mask(pmc);
+	intr = nvkm_mc_intr_mask(pmc);
 	if (pmc->use_msi)
 		oclass->msi_rearm(pmc);
 
 	if (intr) {
-		u32 stat = intr = nouveau_mc_intr_mask(pmc);
+		u32 stat = intr = nvkm_mc_intr_mask(pmc);
 		while (map->stat) {
 			if (intr & map->stat) {
-				unit = nouveau_subdev(pmc, map->unit);
+				unit = nvkm_subdev(pmc, map->unit);
 				if (unit && unit->intr)
 					unit->intr(unit);
 				stat &= ~map->stat;
@@ -78,18 +79,18 @@ nouveau_mc_intr(int irq, void *arg)
 }
 
 int
-_nouveau_mc_fini(struct nouveau_object *object, bool suspend)
+_nvkm_mc_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nouveau_mc *pmc = (void *)object;
+	struct nvkm_mc *pmc = (void *)object;
 	nv_wr32(pmc, 0x000140, 0x00000000);
-	return nouveau_subdev_fini(&pmc->base, suspend);
+	return nvkm_subdev_fini(&pmc->base, suspend);
 }
 
 int
-_nouveau_mc_init(struct nouveau_object *object)
+_nvkm_mc_init(struct nvkm_object *object)
 {
-	struct nouveau_mc *pmc = (void *)object;
-	int ret = nouveau_subdev_init(&pmc->base);
+	struct nvkm_mc *pmc = (void *)object;
+	int ret = nvkm_subdev_init(&pmc->base);
 	if (ret)
 		return ret;
 	nv_wr32(pmc, 0x000140, 0x00000001);
@@ -97,32 +98,32 @@ _nouveau_mc_init(struct nouveau_object *object)
 }
 
 void
-_nouveau_mc_dtor(struct nouveau_object *object)
+_nvkm_mc_dtor(struct nvkm_object *object)
 {
-	struct nouveau_device *device = nv_device(object);
-	struct nouveau_mc *pmc = (void *)object;
+	struct nvkm_device *device = nv_device(object);
+	struct nvkm_mc *pmc = (void *)object;
 	free_irq(pmc->irq, pmc);
 	if (pmc->use_msi)
 		pci_disable_msi(device->pdev);
-	nouveau_subdev_destroy(&pmc->base);
+	nvkm_subdev_destroy(&pmc->base);
 }
 
 int
-nouveau_mc_create_(struct nouveau_object *parent, struct nouveau_object *engine,
-		   struct nouveau_oclass *bclass, int length, void **pobject)
+nvkm_mc_create_(struct nvkm_object *parent, struct nvkm_object *engine,
+		struct nvkm_oclass *bclass, int length, void **pobject)
 {
-	const struct nouveau_mc_oclass *oclass = (void *)bclass;
-	struct nouveau_device *device = nv_device(parent);
-	struct nouveau_mc *pmc;
+	const struct nvkm_mc_oclass *oclass = (void *)bclass;
+	struct nvkm_device *device = nv_device(parent);
+	struct nvkm_mc *pmc;
 	int ret;
 
-	ret = nouveau_subdev_create_(parent, engine, bclass, 0, "PMC",
-				     "master", length, pobject);
+	ret = nvkm_subdev_create_(parent, engine, bclass, 0, "PMC",
+				  "master", length, pobject);
 	pmc = *pobject;
 	if (ret)
 		return ret;
 
-	pmc->unk260 = nouveau_mc_unk260;
+	pmc->unk260 = nvkm_mc_unk260;
 
 	if (nv_device_is_pci(device)) {
 		switch (device->pdev->device & 0x0ff0) {
@@ -141,8 +142,8 @@ nouveau_mc_create_(struct nouveau_object *parent, struct nouveau_object *engine,
 			}
 		}
 
-		pmc->use_msi = nouveau_boolopt(device->cfgopt, "NvMSI",
-					       pmc->use_msi);
+		pmc->use_msi = nvkm_boolopt(device->cfgopt, "NvMSI",
+					    pmc->use_msi);
 
 		if (pmc->use_msi && oclass->msi_rearm) {
 			pmc->use_msi = pci_enable_msi(device->pdev) == 0;
@@ -160,9 +161,7 @@ nouveau_mc_create_(struct nouveau_object *parent, struct nouveau_object *engine,
 		return ret;
 	pmc->irq = ret;
 
-	ret = request_irq(pmc->irq, nouveau_mc_intr, IRQF_SHARED, "nouveau",
-			  pmc);
-
+	ret = request_irq(pmc->irq, nvkm_mc_intr, IRQF_SHARED, "nvkm", pmc);
 	if (ret < 0)
 		return ret;
 

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
new file mode 100644
index 000000000000..25e3b9644a3f
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c
@@ -0,0 +1,170 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include "priv.h"
+#include <core/option.h>
+
+static inline void
+nouveau_mc_unk260(struct nouveau_mc *pmc, u32 data)
+{
+	const struct nouveau_mc_oclass *impl = (void *)nv_oclass(pmc);
+	if (impl->unk260)
+		impl->unk260(pmc, data);
+}
+
+static inline u32
+nouveau_mc_intr_mask(struct nouveau_mc *pmc)
+{
+	u32 intr = nv_rd32(pmc, 0x000100);
+	if (intr == 0xffffffff) /* likely fallen off the bus */
+		intr = 0x00000000;
+	return intr;
+}
+
+static irqreturn_t
+nouveau_mc_intr(int irq, void *arg)
+{
+	struct nouveau_mc *pmc = arg;
+	const struct nouveau_mc_oclass *oclass = (void *)nv_object(pmc)->oclass;
+	const struct nouveau_mc_intr *map = oclass->intr;
+	struct nouveau_subdev *unit;
+	u32 intr;
+
+	nv_wr32(pmc, 0x000140, 0x00000000);
+	nv_rd32(pmc, 0x000140);
+	intr = nouveau_mc_intr_mask(pmc);
+	if (pmc->use_msi)
+		oclass->msi_rearm(pmc);
+
+	if (intr) {
+		u32 stat = intr = nouveau_mc_intr_mask(pmc);
+		while (map->stat) {
+			if (intr & map->stat) {
+				unit = nouveau_subdev(pmc, map->unit);
+				if (unit && unit->intr)
+					unit->intr(unit);
+				stat &= ~map->stat;
+			}
+			map++;
+		}
+
+		if (stat)
+			nv_error(pmc, "unknown intr 0x%08x\n", stat);
+	}
+
+	nv_wr32(pmc, 0x000140, 0x00000001);
+	return intr ? IRQ_HANDLED : IRQ_NONE;
+}
+
+int
+_nouveau_mc_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nouveau_mc *pmc = (void *)object;
+	nv_wr32(pmc, 0x000140, 0x00000000);
+	return nouveau_subdev_fini(&pmc->base, suspend);
+}
+
+int
+_nouveau_mc_init(struct nouveau_object *object)
+{
+	struct nouveau_mc *pmc = (void *)object;
+	int ret = nouveau_subdev_init(&pmc->base);
+	if (ret)
+		return ret;
+	nv_wr32(pmc, 0x000140, 0x00000001);
+	return 0;
+}
+
+void
+_nouveau_mc_dtor(struct nouveau_object *object)
+{
+	struct nouveau_device *device = nv_device(object);
+	struct nouveau_mc *pmc = (void *)object;
+	free_irq(pmc->irq, pmc);
+	if (pmc->use_msi)
+		pci_disable_msi(device->pdev);
+	nouveau_subdev_destroy(&pmc->base);
+}
+
+int
+nouveau_mc_create_(struct nouveau_object *parent, struct nouveau_object *engine,
+		   struct nouveau_oclass *bclass, int length, void **pobject)
+{
+	const struct nouveau_mc_oclass *oclass = (void *)bclass;
+	struct nouveau_device *device = nv_device(parent);
+	struct nouveau_mc *pmc;
+	int ret;
+
+	ret = nouveau_subdev_create_(parent, engine, bclass, 0, "PMC",
+				     "master", length, pobject);
+	pmc = *pobject;
+	if (ret)
+		return ret;
+
+	pmc->unk260 = nouveau_mc_unk260;
+
+	if (nv_device_is_pci(device)) {
+		switch (device->pdev->device & 0x0ff0) {
+		case 0x00f0:
+		case 0x02e0:
+			/* BR02? NFI how these would be handled yet exactly */
+			break;
+		default:
+			switch (device->chipset) {
+			case 0xaa:
+				/* reported broken, nv also disable it */
+				break;
+			default:
+				pmc->use_msi = true;
+				break;
+			}
+		}
+
+		pmc->use_msi = nouveau_boolopt(device->cfgopt, "NvMSI",
+					       pmc->use_msi);
+
+		if (pmc->use_msi && oclass->msi_rearm) {
+			pmc->use_msi = pci_enable_msi(device->pdev) == 0;
+			if (pmc->use_msi) {
+				nv_info(pmc, "MSI interrupts enabled\n");
+				oclass->msi_rearm(pmc);
+			}
+		} else {
+			pmc->use_msi = false;
+		}
+	}
+
+	ret = nv_device_get_irq(device, true);
+	if (ret < 0)
+		return ret;
+	pmc->irq = ret;
+
+	ret = request_irq(pmc->irq, nouveau_mc_intr, IRQF_SHARED, "nouveau",
+			  pmc);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
