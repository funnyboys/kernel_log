commit 5cca4bdc0d0518b31c7bf8f5e8a895af01c4c90a
Author: Karol Herbst <nouveau@karolherbst.de>
Date:   Tue Jan 5 21:44:18 2016 +0100

    drm/nouveau/pci: implement pcie speed change for tesla
    
    v5: don't set fermi or kepler func pointers
    v6: fix alignment

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pci/g84.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pci/g84.c
index 3faa6bfb895b..62438d892f42 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pci/g84.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pci/g84.c
@@ -25,6 +25,80 @@
 
 #include <core/pci.h>
 
+static int
+g84_pcie_version_supported(struct nvkm_pci *pci)
+{
+	/* g84 and g86 report wrong information about what they support */
+	return 1;
+}
+
+int
+g84_pcie_version(struct nvkm_pci *pci)
+{
+	struct nvkm_device *device = pci->subdev.device;
+	return (nvkm_rd32(device, 0x00154c) & 0x1) + 1;
+}
+
+void
+g84_pcie_set_version(struct nvkm_pci *pci, u8 ver)
+{
+	struct nvkm_device *device = pci->subdev.device;
+	nvkm_mask(device, 0x00154c, 0x1, (ver >= 2 ? 0x1 : 0x0));
+}
+
+static void
+g84_pcie_set_cap_speed(struct nvkm_pci *pci, bool full_speed)
+{
+	struct nvkm_device *device = pci->subdev.device;
+	nvkm_mask(device, 0x00154c, 0x80, full_speed ? 0x80 : 0x0);
+}
+
+enum nvkm_pcie_speed
+g84_pcie_cur_speed(struct nvkm_pci *pci)
+{
+	u32 reg_v = nvkm_pci_rd32(pci, 0x88) & 0x30000;
+	switch (reg_v) {
+	case 0x30000:
+		return NVKM_PCIE_SPEED_8_0;
+	case 0x20000:
+		return NVKM_PCIE_SPEED_5_0;
+	case 0x10000:
+	default:
+		return NVKM_PCIE_SPEED_2_5;
+	}
+}
+
+enum nvkm_pcie_speed
+g84_pcie_max_speed(struct nvkm_pci *pci)
+{
+	u32 reg_v = nvkm_pci_rd32(pci, 0x460) & 0x3300;
+	if (reg_v == 0x2200)
+		return NVKM_PCIE_SPEED_5_0;
+	return NVKM_PCIE_SPEED_2_5;
+}
+
+void
+g84_pcie_set_link_speed(struct nvkm_pci *pci, enum nvkm_pcie_speed speed)
+{
+	u32 mask_value;
+
+	if (speed == NVKM_PCIE_SPEED_5_0)
+		mask_value = 0x20;
+	else
+		mask_value = 0x10;
+
+	nvkm_pci_mask(pci, 0x460, 0x30, mask_value);
+	nvkm_pci_mask(pci, 0x460, 0x1, 0x1);
+}
+
+int
+g84_pcie_set_link(struct nvkm_pci *pci, enum nvkm_pcie_speed speed, u8 width)
+{
+	g84_pcie_set_cap_speed(pci, speed == NVKM_PCIE_SPEED_5_0);
+	g84_pcie_set_link_speed(pci, speed);
+	return 0;
+}
+
 void
 g84_pci_init(struct nvkm_pci *pci)
 {
@@ -48,6 +122,14 @@ g84_pci_init(struct nvkm_pci *pci)
 		nvkm_pci_mask(pci, 0x041c, 0x00000060, 0x00000000);
 }
 
+int
+g84_pcie_init(struct nvkm_pci *pci)
+{
+	bool full_speed = g84_pcie_cur_speed(pci) == NVKM_PCIE_SPEED_5_0;
+	g84_pcie_set_cap_speed(pci, full_speed);
+	return 0;
+}
+
 static const struct nvkm_pci_func
 g84_pci_func = {
 	.init = g84_pci_init,
@@ -55,6 +137,16 @@ g84_pci_func = {
 	.wr08 = nv40_pci_wr08,
 	.wr32 = nv40_pci_wr32,
 	.msi_rearm = nv46_pci_msi_rearm,
+
+	.pcie.init = g84_pcie_init,
+	.pcie.set_link = g84_pcie_set_link,
+
+	.pcie.max_speed = g84_pcie_max_speed,
+	.pcie.cur_speed = g84_pcie_cur_speed,
+
+	.pcie.set_version = g84_pcie_set_version,
+	.pcie.version = g84_pcie_version,
+	.pcie.version_supported = g84_pcie_version_supported,
 };
 
 int

commit 5d5b43f59bd214506265ea05a013229ff5291101
Author: Pierre Moreau <pierre.morrow@free.fr>
Date:   Sat Oct 3 21:35:16 2015 +0200

    drm/nouveau/pci: Handle 5-bit and 8-bit tag field
    
    If the hardware supports extended tag field (8-bit ones), then enable it.
    
    This is usually done by the VBIOS, but not on some MBPs (see fdo#86537).
    
    In case extended tag field is not supported, 5-bit tag field is used which
    limits the possible number of requests to 32. Apparently bits 7:0 of
    0x08841c stores some number of outstanding requests, so cap it to 32 if
    extended tag is unsupported.
    
    Fixes: fdo#86537
    
    v2: Restrict changes to chipsets >= 0x84
    v3:
      * Add nvkm_pci_mask to pci.h
      * Mask bit 8 before setting it
    v4:
      * Rename `add` argument of nvkm_pci_mask to `value`
      * Move code from nvkm_pci_init to g84_pci_init and remove PCIe and chipset
        checks
    v5:
      * Rebase code on latest PCI structure
      * Restore PCIe check
      * Fix namings in nvkm_pci_mask
      * Rephrase part of the commit message
    
    Signed-off-by: Pierre Moreau <pierre.morrow@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pci/g84.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pci/g84.c
index 8f3b00199d14..3faa6bfb895b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pci/g84.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pci/g84.c
@@ -25,8 +25,32 @@
 
 #include <core/pci.h>
 
+void
+g84_pci_init(struct nvkm_pci *pci)
+{
+	/* The following only concerns PCIe cards. */
+	if (!pci_is_pcie(pci->pdev))
+		return;
+
+	/* Tag field is 8-bit long, regardless of EXT_TAG.
+	 * However, if EXT_TAG is disabled, only the lower 5 bits of the tag
+	 * field should be used, limiting the number of request to 32.
+	 *
+	 * Apparently, 0x041c stores some limit on the number of requests
+	 * possible, so if EXT_TAG is disabled, limit that requests number to
+	 * 32
+	 *
+	 * Fixes fdo#86537
+	 */
+	if (nvkm_pci_rd32(pci, 0x007c) & 0x00000020)
+		nvkm_pci_mask(pci, 0x0080, 0x00000100, 0x00000100);
+	else
+		nvkm_pci_mask(pci, 0x041c, 0x00000060, 0x00000000);
+}
+
 static const struct nvkm_pci_func
 g84_pci_func = {
+	.init = g84_pci_init,
 	.rd32 = nv40_pci_rd32,
 	.wr08 = nv40_pci_wr08,
 	.wr32 = nv40_pci_wr32,

commit c4266a9c7b0ee66b3d1ca22745d8eb9472e21b4b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Oct 1 11:36:58 2015 +1000

    drm/nouveau/pci/nv46: attempt to fix msi, and re-enable by default
    
    Was not able to obtain a trace of NVRM due to kernel version annoyances,
    however, experimentally confirmed that the WAR we use on NV50/G8x boards
    works here too.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pci/g84.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pci/g84.c
index 30be277edf2a..8f3b00199d14 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pci/g84.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pci/g84.c
@@ -30,7 +30,7 @@ g84_pci_func = {
 	.rd32 = nv40_pci_rd32,
 	.wr08 = nv40_pci_wr08,
 	.wr32 = nv40_pci_wr32,
-	.msi_rearm = nv50_pci_msi_rearm,
+	.msi_rearm = nv46_pci_msi_rearm,
 };
 
 int

commit 3e55b53bc7039f1a6b051aa1a5ba15eec6dce2e7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Oct 1 09:29:58 2015 +1000

    drm/nouveau/pci/g84: split implementation from nv50
    
    An upcoming patch will implement functionality that we don't use on the
    original NV50.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pci/g84.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pci/g84.c
new file mode 100644
index 000000000000..30be277edf2a
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pci/g84.c
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2015 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs <bskeggs@redhat.com>
+ */
+#include "priv.h"
+
+#include <core/pci.h>
+
+static const struct nvkm_pci_func
+g84_pci_func = {
+	.rd32 = nv40_pci_rd32,
+	.wr08 = nv40_pci_wr08,
+	.wr32 = nv40_pci_wr32,
+	.msi_rearm = nv50_pci_msi_rearm,
+};
+
+int
+g84_pci_new(struct nvkm_device *device, int index, struct nvkm_pci **ppci)
+{
+	return nvkm_pci_new_(&g84_pci_func, device, index, ppci);
+}
