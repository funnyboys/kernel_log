commit 997a89003c2d950466bc289147ffb823c0c51fb0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/core/memory: add reference counting
    
    We need to be able to prevent memory from being freed while it's still
    mapped in a GPU's address-space.
    
    Will be used by upcoming MMU changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index b03940591a3a..364ea4492acc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -120,7 +120,7 @@ nvkm_instobj_new(struct nvkm_instmem *imem, u32 size, u32 align, bool zero,
 
 done:
 	if (ret)
-		nvkm_memory_del(&memory);
+		nvkm_memory_unref(&memory);
 	*pmemory = memory;
 	return ret;
 }

commit ffd937bbd219331e4b67344c104dea09b9ed4a6a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/imem: use fast-path for resume restore
    
    Before: "imem: init completed in 299277us"
     After: "imem: init completed in  11574us"
    
    Suspend from Fedora 26 gnome desktop on GP102.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index d7df7cb6bed3..b03940591a3a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -33,10 +33,17 @@ nvkm_instobj_load(struct nvkm_instobj *iobj)
 {
 	struct nvkm_memory *memory = &iobj->memory;
 	const u64 size = nvkm_memory_size(memory);
+	void __iomem *map;
 	int i;
 
-	for (i = 0; i < size; i += 4)
-		nvkm_wo32(memory, i, iobj->suspend[i / 4]);
+	if (!(map = nvkm_kmap(memory))) {
+		for (i = 0; i < size; i += 4)
+			nvkm_wo32(memory, i, iobj->suspend[i / 4]);
+	} else {
+		memcpy_toio(map, iobj->suspend, size);
+	}
+	nvkm_done(memory);
+
 	kvfree(iobj->suspend);
 	iobj->suspend = NULL;
 }
@@ -188,6 +195,8 @@ nvkm_instmem_init(struct nvkm_subdev *subdev)
 			nvkm_instobj_load(iobj);
 	}
 
+	nvkm_bar_bar2_init(subdev->device);
+
 	list_for_each_entry(iobj, &imem->list, head) {
 		if (iobj->suspend)
 			nvkm_instobj_load(iobj);

commit e9be3c7d7ae0aa6e273ac5cf66dfd2d53479bdbf
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/imem: use fast-path for suspend backup
    
    Before: "imem: suspend completed in 5540487us"
     After: "imem: suspend completed in 1871526us"
    
    Suspend from Fedora 26 gnome desktop on GP102.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index 8fc63ec20d6e..d7df7cb6bed3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -46,15 +46,20 @@ nvkm_instobj_save(struct nvkm_instobj *iobj)
 {
 	struct nvkm_memory *memory = &iobj->memory;
 	const u64 size = nvkm_memory_size(memory);
+	void __iomem *map;
 	int i;
 
 	iobj->suspend = kvmalloc(size, GFP_KERNEL);
 	if (!iobj->suspend)
 		return -ENOMEM;
 
-	for (i = 0; i < size; i += 4)
-		iobj->suspend[i / 4] = nvkm_ro32(memory, i);
-
+	if (!(map = nvkm_kmap(memory))) {
+		for (i = 0; i < size; i += 4)
+			iobj->suspend[i / 4] = nvkm_ro32(memory, i);
+	} else {
+		memcpy_fromio(iobj->suspend, map, size);
+	}
+	nvkm_done(memory);
 	return 0;
 }
 
@@ -157,6 +162,8 @@ nvkm_instmem_fini(struct nvkm_subdev *subdev, bool suspend)
 				return ret;
 		}
 
+		nvkm_bar_bar2_fini(subdev->device);
+
 		list_for_each_entry(iobj, &imem->boot, head) {
 			int ret = nvkm_instobj_save(iobj);
 			if (ret)

commit b00b8430468d2922c5ea9a0557c7a36136df98c2
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/imem: separate pre-BAR2-bootstrap objects from the rest
    
    These will require slow-path access during suspend/resume.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index 36b3424149b3..8fc63ec20d6e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -129,6 +129,21 @@ nvkm_instmem_wr32(struct nvkm_instmem *imem, u32 addr, u32 data)
 	return imem->func->wr32(imem, addr, data);
 }
 
+void
+nvkm_instmem_boot(struct nvkm_instmem *imem)
+{
+	/* Separate bootstrapped objects from normal list, as we need
+	 * to make sure they're accessed with the slowpath on suspend
+	 * and resume.
+	 */
+	struct nvkm_instobj *iobj, *itmp;
+	spin_lock(&imem->lock);
+	list_for_each_entry_safe(iobj, itmp, &imem->list, head) {
+		list_move_tail(&iobj->head, &imem->boot);
+	}
+	spin_unlock(&imem->lock);
+}
+
 static int
 nvkm_instmem_fini(struct nvkm_subdev *subdev, bool suspend)
 {
@@ -141,6 +156,12 @@ nvkm_instmem_fini(struct nvkm_subdev *subdev, bool suspend)
 			if (ret)
 				return ret;
 		}
+
+		list_for_each_entry(iobj, &imem->boot, head) {
+			int ret = nvkm_instobj_save(iobj);
+			if (ret)
+				return ret;
+		}
 	}
 
 	if (imem->func->fini)
@@ -155,6 +176,11 @@ nvkm_instmem_init(struct nvkm_subdev *subdev)
 	struct nvkm_instmem *imem = nvkm_instmem(subdev);
 	struct nvkm_instobj *iobj;
 
+	list_for_each_entry(iobj, &imem->boot, head) {
+		if (iobj->suspend)
+			nvkm_instobj_load(iobj);
+	}
+
 	list_for_each_entry(iobj, &imem->list, head) {
 		if (iobj->suspend)
 			nvkm_instobj_load(iobj);
@@ -198,4 +224,5 @@ nvkm_instmem_ctor(const struct nvkm_instmem_func *func,
 	imem->func = func;
 	spin_lock_init(&imem->lock);
 	INIT_LIST_HEAD(&imem->list);
+	INIT_LIST_HEAD(&imem->boot);
 }

commit 54c70e3ac6d5634982edd586418710eb7fbb7c76
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/imem: switch to kvmalloc/kvfree for suspend/resume backup
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index 8ad31b436fa0..36b3424149b3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -37,7 +37,7 @@ nvkm_instobj_load(struct nvkm_instobj *iobj)
 
 	for (i = 0; i < size; i += 4)
 		nvkm_wo32(memory, i, iobj->suspend[i / 4]);
-	vfree(iobj->suspend);
+	kvfree(iobj->suspend);
 	iobj->suspend = NULL;
 }
 
@@ -48,7 +48,7 @@ nvkm_instobj_save(struct nvkm_instobj *iobj)
 	const u64 size = nvkm_memory_size(memory);
 	int i;
 
-	iobj->suspend = vmalloc(size);
+	iobj->suspend = kvmalloc(size, GFP_KERNEL);
 	if (!iobj->suspend)
 		return -ENOMEM;
 

commit d52ddc953e7f74a8271c88fc0aa3bd0d436b04f0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/imem: separate suspend/resume backup handling into their own functions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index 4c2fa5c460c7..8ad31b436fa0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -28,6 +28,36 @@
 /******************************************************************************
  * instmem object base implementation
  *****************************************************************************/
+static void
+nvkm_instobj_load(struct nvkm_instobj *iobj)
+{
+	struct nvkm_memory *memory = &iobj->memory;
+	const u64 size = nvkm_memory_size(memory);
+	int i;
+
+	for (i = 0; i < size; i += 4)
+		nvkm_wo32(memory, i, iobj->suspend[i / 4]);
+	vfree(iobj->suspend);
+	iobj->suspend = NULL;
+}
+
+static int
+nvkm_instobj_save(struct nvkm_instobj *iobj)
+{
+	struct nvkm_memory *memory = &iobj->memory;
+	const u64 size = nvkm_memory_size(memory);
+	int i;
+
+	iobj->suspend = vmalloc(size);
+	if (!iobj->suspend)
+		return -ENOMEM;
+
+	for (i = 0; i < size; i += 4)
+		iobj->suspend[i / 4] = nvkm_ro32(memory, i);
+
+	return 0;
+}
+
 void
 nvkm_instobj_dtor(struct nvkm_instmem *imem, struct nvkm_instobj *iobj)
 {
@@ -104,34 +134,18 @@ nvkm_instmem_fini(struct nvkm_subdev *subdev, bool suspend)
 {
 	struct nvkm_instmem *imem = nvkm_instmem(subdev);
 	struct nvkm_instobj *iobj;
-	int i;
-
-	if (imem->func->fini)
-		imem->func->fini(imem);
 
 	if (suspend) {
 		list_for_each_entry(iobj, &imem->list, head) {
-			struct nvkm_memory *memory = &iobj->memory;
-			u64 size = nvkm_memory_size(memory);
-
-			iobj->suspend = vmalloc(size);
-			if (!iobj->suspend)
-				return -ENOMEM;
-
-			for (i = 0; i < size; i += 4)
-				iobj->suspend[i / 4] = nvkm_ro32(memory, i);
+			int ret = nvkm_instobj_save(iobj);
+			if (ret)
+				return ret;
 		}
 	}
 
-	return 0;
-}
+	if (imem->func->fini)
+		imem->func->fini(imem);
 
-static int
-nvkm_instmem_oneinit(struct nvkm_subdev *subdev)
-{
-	struct nvkm_instmem *imem = nvkm_instmem(subdev);
-	if (imem->func->oneinit)
-		return imem->func->oneinit(imem);
 	return 0;
 }
 
@@ -140,22 +154,24 @@ nvkm_instmem_init(struct nvkm_subdev *subdev)
 {
 	struct nvkm_instmem *imem = nvkm_instmem(subdev);
 	struct nvkm_instobj *iobj;
-	int i;
 
 	list_for_each_entry(iobj, &imem->list, head) {
-		if (iobj->suspend) {
-			struct nvkm_memory *memory = &iobj->memory;
-			u64 size = nvkm_memory_size(memory);
-			for (i = 0; i < size; i += 4)
-				nvkm_wo32(memory, i, iobj->suspend[i / 4]);
-			vfree(iobj->suspend);
-			iobj->suspend = NULL;
-		}
+		if (iobj->suspend)
+			nvkm_instobj_load(iobj);
 	}
 
 	return 0;
 }
 
+static int
+nvkm_instmem_oneinit(struct nvkm_subdev *subdev)
+{
+	struct nvkm_instmem *imem = nvkm_instmem(subdev);
+	if (imem->func->oneinit)
+		return imem->func->oneinit(imem);
+	return 0;
+}
+
 static void *
 nvkm_instmem_dtor(struct nvkm_subdev *subdev)
 {

commit 71370e620a97fe98daebea86c6ae3775cf0f4fc8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/imem: remove now-unused wrapper for backend objects
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index 78f9c2332edd..4c2fa5c460c7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -28,148 +28,6 @@
 /******************************************************************************
  * instmem object base implementation
  *****************************************************************************/
-#define nvkm_instobj(p) container_of((p), struct nvkm_instobj, memory)
-
-static enum nvkm_memory_target
-nvkm_instobj_target(struct nvkm_memory *memory)
-{
-	memory = nvkm_instobj(memory)->parent;
-	return nvkm_memory_target(memory);
-}
-
-static u64
-nvkm_instobj_addr(struct nvkm_memory *memory)
-{
-	memory = nvkm_instobj(memory)->parent;
-	return nvkm_memory_addr(memory);
-}
-
-static u64
-nvkm_instobj_size(struct nvkm_memory *memory)
-{
-	memory = nvkm_instobj(memory)->parent;
-	return nvkm_memory_size(memory);
-}
-
-static void
-nvkm_instobj_release(struct nvkm_memory *memory)
-{
-	struct nvkm_instobj *iobj = nvkm_instobj(memory);
-	nvkm_bar_flush(iobj->imem->subdev.device->bar);
-}
-
-static void __iomem *
-nvkm_instobj_acquire(struct nvkm_memory *memory)
-{
-	return nvkm_instobj(memory)->map;
-}
-
-static u32
-nvkm_instobj_rd32(struct nvkm_memory *memory, u64 offset)
-{
-	return ioread32_native(nvkm_instobj(memory)->map + offset);
-}
-
-static void
-nvkm_instobj_wr32(struct nvkm_memory *memory, u64 offset, u32 data)
-{
-	iowrite32_native(data, nvkm_instobj(memory)->map + offset);
-}
-
-static void
-nvkm_instobj_map(struct nvkm_memory *memory, struct nvkm_vma *vma, u64 offset)
-{
-	memory = nvkm_instobj(memory)->parent;
-	nvkm_memory_map(memory, vma, offset);
-}
-
-static void *
-nvkm_instobj_dtor_old(struct nvkm_memory *memory)
-{
-	struct nvkm_instobj *iobj = nvkm_instobj(memory);
-	spin_lock(&iobj->imem->lock);
-	list_del(&iobj->head);
-	spin_unlock(&iobj->imem->lock);
-	nvkm_memory_del(&iobj->parent);
-	return iobj;
-}
-
-static const struct nvkm_memory_func
-nvkm_instobj_func = {
-	.dtor = nvkm_instobj_dtor_old,
-	.target = nvkm_instobj_target,
-	.addr = nvkm_instobj_addr,
-	.size = nvkm_instobj_size,
-	.acquire = nvkm_instobj_acquire,
-	.release = nvkm_instobj_release,
-	.map = nvkm_instobj_map,
-};
-
-static const struct nvkm_memory_ptrs
-nvkm_instobj_ptrs = {
-	.rd32 = nvkm_instobj_rd32,
-	.wr32 = nvkm_instobj_wr32,
-};
-
-static void
-nvkm_instobj_boot(struct nvkm_memory *memory, struct nvkm_vm *vm)
-{
-	memory = nvkm_instobj(memory)->parent;
-	nvkm_memory_boot(memory, vm);
-}
-
-static void
-nvkm_instobj_release_slow(struct nvkm_memory *memory)
-{
-	struct nvkm_instobj *iobj = nvkm_instobj(memory);
-	nvkm_instobj_release(memory);
-	nvkm_done(iobj->parent);
-}
-
-static void __iomem *
-nvkm_instobj_acquire_slow(struct nvkm_memory *memory)
-{
-	struct nvkm_instobj *iobj = nvkm_instobj(memory);
-	iobj->map = nvkm_kmap(iobj->parent);
-	if (iobj->map) {
-		memory->func = &nvkm_instobj_func;
-		memory->ptrs = &nvkm_instobj_ptrs;
-	}
-	return iobj->map;
-}
-
-static u32
-nvkm_instobj_rd32_slow(struct nvkm_memory *memory, u64 offset)
-{
-	struct nvkm_instobj *iobj = nvkm_instobj(memory);
-	return nvkm_ro32(iobj->parent, offset);
-}
-
-static void
-nvkm_instobj_wr32_slow(struct nvkm_memory *memory, u64 offset, u32 data)
-{
-	struct nvkm_instobj *iobj = nvkm_instobj(memory);
-	return nvkm_wo32(iobj->parent, offset, data);
-}
-
-static const struct nvkm_memory_func
-nvkm_instobj_func_slow = {
-	.dtor = nvkm_instobj_dtor_old,
-	.target = nvkm_instobj_target,
-	.addr = nvkm_instobj_addr,
-	.size = nvkm_instobj_size,
-	.boot = nvkm_instobj_boot,
-	.acquire = nvkm_instobj_acquire_slow,
-	.release = nvkm_instobj_release_slow,
-	.map = nvkm_instobj_map,
-};
-
-static const struct nvkm_memory_ptrs
-nvkm_instobj_ptrs_slow = {
-	.rd32 = nvkm_instobj_rd32_slow,
-	.wr32 = nvkm_instobj_wr32_slow,
-};
-
 void
 nvkm_instobj_dtor(struct nvkm_instmem *imem, struct nvkm_instobj *iobj)
 {
@@ -183,7 +41,6 @@ nvkm_instobj_ctor(const struct nvkm_memory_func *func,
 		  struct nvkm_instmem *imem, struct nvkm_instobj *iobj)
 {
 	nvkm_memory_ctor(func, &iobj->memory);
-	iobj->parent = &iobj->memory;
 	iobj->suspend = NULL;
 	spin_lock(&imem->lock);
 	list_add_tail(&iobj->head, &imem->list);
@@ -196,7 +53,6 @@ nvkm_instobj_new(struct nvkm_instmem *imem, u32 size, u32 align, bool zero,
 {
 	struct nvkm_subdev *subdev = &imem->subdev;
 	struct nvkm_memory *memory = NULL;
-	struct nvkm_instobj *iobj;
 	u32 offset;
 	int ret;
 
@@ -209,22 +65,6 @@ nvkm_instobj_new(struct nvkm_instmem *imem, u32 size, u32 align, bool zero,
 	nvkm_trace(subdev, "new %08x %08x %d: %010llx %010llx\n", size, align,
 		   zero, nvkm_memory_addr(memory), nvkm_memory_size(memory));
 
-	if (!imem->func->persistent) {
-		if (!(iobj = kzalloc(sizeof(*iobj), GFP_KERNEL))) {
-			ret = -ENOMEM;
-			goto done;
-		}
-
-		nvkm_memory_ctor(&nvkm_instobj_func_slow, &iobj->memory);
-		iobj->memory.ptrs = &nvkm_instobj_ptrs_slow;
-		iobj->parent = memory;
-		iobj->imem = imem;
-		spin_lock(&iobj->imem->lock);
-		list_add_tail(&iobj->head, &imem->list);
-		spin_unlock(&iobj->imem->lock);
-		memory = &iobj->memory;
-	}
-
 	if (!imem->func->zero && zero) {
 		void __iomem *map = nvkm_kmap(memory);
 		if (unlikely(!map)) {
@@ -271,7 +111,7 @@ nvkm_instmem_fini(struct nvkm_subdev *subdev, bool suspend)
 
 	if (suspend) {
 		list_for_each_entry(iobj, &imem->list, head) {
-			struct nvkm_memory *memory = iobj->parent;
+			struct nvkm_memory *memory = &iobj->memory;
 			u64 size = nvkm_memory_size(memory);
 
 			iobj->suspend = vmalloc(size);
@@ -304,7 +144,7 @@ nvkm_instmem_init(struct nvkm_subdev *subdev)
 
 	list_for_each_entry(iobj, &imem->list, head) {
 		if (iobj->suspend) {
-			struct nvkm_memory *memory = iobj->parent;
+			struct nvkm_memory *memory = &iobj->memory;
 			u64 size = nvkm_memory_size(memory);
 			for (i = 0; i < size; i += 4)
 				nvkm_wo32(memory, i, iobj->suspend[i / 4]);

commit 49814f62a26bd5b8f2ad5a16ccb1340ede30ee1a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/imem: allow nvkm_instobj to be directly embedded in backend object
    
    This will eliminate a step through the call chain, and give backends
    more flexibility.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index a15125ed455d..78f9c2332edd 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -23,7 +23,6 @@
  */
 #include "priv.h"
 
-#include <core/memory.h>
 #include <subdev/bar.h>
 
 /******************************************************************************
@@ -31,15 +30,6 @@
  *****************************************************************************/
 #define nvkm_instobj(p) container_of((p), struct nvkm_instobj, memory)
 
-struct nvkm_instobj {
-	struct nvkm_memory memory;
-	struct nvkm_memory *parent;
-	struct nvkm_instmem *imem;
-	struct list_head head;
-	u32 *suspend;
-	void __iomem *map;
-};
-
 static enum nvkm_memory_target
 nvkm_instobj_target(struct nvkm_memory *memory)
 {
@@ -94,7 +84,7 @@ nvkm_instobj_map(struct nvkm_memory *memory, struct nvkm_vma *vma, u64 offset)
 }
 
 static void *
-nvkm_instobj_dtor(struct nvkm_memory *memory)
+nvkm_instobj_dtor_old(struct nvkm_memory *memory)
 {
 	struct nvkm_instobj *iobj = nvkm_instobj(memory);
 	spin_lock(&iobj->imem->lock);
@@ -106,7 +96,7 @@ nvkm_instobj_dtor(struct nvkm_memory *memory)
 
 static const struct nvkm_memory_func
 nvkm_instobj_func = {
-	.dtor = nvkm_instobj_dtor,
+	.dtor = nvkm_instobj_dtor_old,
 	.target = nvkm_instobj_target,
 	.addr = nvkm_instobj_addr,
 	.size = nvkm_instobj_size,
@@ -164,7 +154,7 @@ nvkm_instobj_wr32_slow(struct nvkm_memory *memory, u64 offset, u32 data)
 
 static const struct nvkm_memory_func
 nvkm_instobj_func_slow = {
-	.dtor = nvkm_instobj_dtor,
+	.dtor = nvkm_instobj_dtor_old,
 	.target = nvkm_instobj_target,
 	.addr = nvkm_instobj_addr,
 	.size = nvkm_instobj_size,
@@ -180,6 +170,26 @@ nvkm_instobj_ptrs_slow = {
 	.wr32 = nvkm_instobj_wr32_slow,
 };
 
+void
+nvkm_instobj_dtor(struct nvkm_instmem *imem, struct nvkm_instobj *iobj)
+{
+	spin_lock(&imem->lock);
+	list_del(&iobj->head);
+	spin_unlock(&imem->lock);
+}
+
+void
+nvkm_instobj_ctor(const struct nvkm_memory_func *func,
+		  struct nvkm_instmem *imem, struct nvkm_instobj *iobj)
+{
+	nvkm_memory_ctor(func, &iobj->memory);
+	iobj->parent = &iobj->memory;
+	iobj->suspend = NULL;
+	spin_lock(&imem->lock);
+	list_add_tail(&iobj->head, &imem->list);
+	spin_unlock(&imem->lock);
+}
+
 int
 nvkm_instobj_new(struct nvkm_instmem *imem, u32 size, u32 align, bool zero,
 		 struct nvkm_memory **pmemory)

commit 07bbc1c5f49b64323d9e5c1e0d5d7d201e1f2627
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/core/memory: split info pointers from accessor pointers
    
    The accessor functions can change as a result of acquire()/release() calls,
    and are protected by any refcounting done there.
    
    Other functions must remain constant, as they can be called any time.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index 372f01ba7766..a15125ed455d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -112,9 +112,13 @@ nvkm_instobj_func = {
 	.size = nvkm_instobj_size,
 	.acquire = nvkm_instobj_acquire,
 	.release = nvkm_instobj_release,
+	.map = nvkm_instobj_map,
+};
+
+static const struct nvkm_memory_ptrs
+nvkm_instobj_ptrs = {
 	.rd32 = nvkm_instobj_rd32,
 	.wr32 = nvkm_instobj_wr32,
-	.map = nvkm_instobj_map,
 };
 
 static void
@@ -137,8 +141,10 @@ nvkm_instobj_acquire_slow(struct nvkm_memory *memory)
 {
 	struct nvkm_instobj *iobj = nvkm_instobj(memory);
 	iobj->map = nvkm_kmap(iobj->parent);
-	if (iobj->map)
+	if (iobj->map) {
 		memory->func = &nvkm_instobj_func;
+		memory->ptrs = &nvkm_instobj_ptrs;
+	}
 	return iobj->map;
 }
 
@@ -165,9 +171,13 @@ nvkm_instobj_func_slow = {
 	.boot = nvkm_instobj_boot,
 	.acquire = nvkm_instobj_acquire_slow,
 	.release = nvkm_instobj_release_slow,
+	.map = nvkm_instobj_map,
+};
+
+static const struct nvkm_memory_ptrs
+nvkm_instobj_ptrs_slow = {
 	.rd32 = nvkm_instobj_rd32_slow,
 	.wr32 = nvkm_instobj_wr32_slow,
-	.map = nvkm_instobj_map,
 };
 
 int
@@ -196,6 +206,7 @@ nvkm_instobj_new(struct nvkm_instmem *imem, u32 size, u32 align, bool zero,
 		}
 
 		nvkm_memory_ctor(&nvkm_instobj_func_slow, &iobj->memory);
+		iobj->memory.ptrs = &nvkm_instobj_ptrs_slow;
 		iobj->parent = memory;
 		iobj->imem = imem;
 		spin_lock(&iobj->imem->lock);

commit dde59b9c341a1b5ce2229f7d4a57f19435da82d7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/imem: add some useful debug output
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index 10c987a654ec..372f01ba7766 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -174,14 +174,20 @@ int
 nvkm_instobj_new(struct nvkm_instmem *imem, u32 size, u32 align, bool zero,
 		 struct nvkm_memory **pmemory)
 {
+	struct nvkm_subdev *subdev = &imem->subdev;
 	struct nvkm_memory *memory = NULL;
 	struct nvkm_instobj *iobj;
 	u32 offset;
 	int ret;
 
 	ret = imem->func->memory_new(imem, size, align, zero, &memory);
-	if (ret)
+	if (ret) {
+		nvkm_error(subdev, "OOM: %08x %08x %d\n", size, align, ret);
 		goto done;
+	}
+
+	nvkm_trace(subdev, "new %08x %08x %d: %010llx %010llx\n", size, align,
+		   zero, nvkm_memory_addr(memory), nvkm_memory_size(memory));
 
 	if (!imem->func->persistent) {
 		if (!(iobj = kzalloc(sizeof(*iobj), GFP_KERNEL))) {

commit f3a8b6645dc2e60d11f20c1c23afd964ff4e55ae
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 4 11:44:21 2016 +1000

    drm/nouveau: silence sparse warnings about symbols not being marked static
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index 8ed8f65ff664..10c987a654ec 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -104,7 +104,7 @@ nvkm_instobj_dtor(struct nvkm_memory *memory)
 	return iobj;
 }
 
-const struct nvkm_memory_func
+static const struct nvkm_memory_func
 nvkm_instobj_func = {
 	.dtor = nvkm_instobj_dtor,
 	.target = nvkm_instobj_target,
@@ -156,7 +156,7 @@ nvkm_instobj_wr32_slow(struct nvkm_memory *memory, u64 offset, u32 data)
 	return nvkm_wo32(iobj->parent, offset, data);
 }
 
-const struct nvkm_memory_func
+static const struct nvkm_memory_func
 nvkm_instobj_func_slow = {
 	.dtor = nvkm_instobj_dtor,
 	.target = nvkm_instobj_target,

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index 1d7dd38292b3..8ed8f65ff664 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -311,7 +311,7 @@ nvkm_instmem_ctor(const struct nvkm_instmem_func *func,
 		  struct nvkm_device *device, int index,
 		  struct nvkm_instmem *imem)
 {
-	nvkm_subdev_ctor(&nvkm_instmem, device, index, 0, &imem->subdev);
+	nvkm_subdev_ctor(&nvkm_instmem, device, index, &imem->subdev);
 	imem->func = func;
 	spin_lock_init(&imem->lock);
 	INIT_LIST_HEAD(&imem->list);

commit 950950327bd63b7f54808c7028839a37899035f9
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 11 09:48:13 2015 +1000

    drm/nouveau/instmem: protect instobj list with a spinlock
    
    No locking is required for the traversal of this list, as it only
    happens during suspend/resume where nothing else can be executing.
    
    Fixes some of the issues noticed during parallel piglit runs.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index 895ba74057d4..1d7dd38292b3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -97,7 +97,9 @@ static void *
 nvkm_instobj_dtor(struct nvkm_memory *memory)
 {
 	struct nvkm_instobj *iobj = nvkm_instobj(memory);
+	spin_lock(&iobj->imem->lock);
 	list_del(&iobj->head);
+	spin_unlock(&iobj->imem->lock);
 	nvkm_memory_del(&iobj->parent);
 	return iobj;
 }
@@ -190,7 +192,9 @@ nvkm_instobj_new(struct nvkm_instmem *imem, u32 size, u32 align, bool zero,
 		nvkm_memory_ctor(&nvkm_instobj_func_slow, &iobj->memory);
 		iobj->parent = memory;
 		iobj->imem = imem;
+		spin_lock(&iobj->imem->lock);
 		list_add_tail(&iobj->head, &imem->list);
+		spin_unlock(&iobj->imem->lock);
 		memory = &iobj->memory;
 	}
 
@@ -309,5 +313,6 @@ nvkm_instmem_ctor(const struct nvkm_instmem_func *func,
 {
 	nvkm_subdev_ctor(&nvkm_instmem, device, index, 0, &imem->subdev);
 	imem->func = func;
+	spin_lock_init(&imem->lock);
 	INIT_LIST_HEAD(&imem->list);
 }

commit b7a2bc1886d00f5f1358079e1e6f4979006a4ed6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/imem: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index 6a356f348c58..895ba74057d4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -168,21 +168,20 @@ nvkm_instobj_func_slow = {
 	.map = nvkm_instobj_map,
 };
 
-static int
+int
 nvkm_instobj_new(struct nvkm_instmem *imem, u32 size, u32 align, bool zero,
 		 struct nvkm_memory **pmemory)
 {
-	struct nvkm_instmem_impl *impl = (void *)imem->subdev.object.oclass;
-	struct nvkm_memory *memory;
+	struct nvkm_memory *memory = NULL;
 	struct nvkm_instobj *iobj;
 	u32 offset;
 	int ret;
 
-	ret = impl->memory_new(imem, size, align, zero, &memory);
+	ret = imem->func->memory_new(imem, size, align, zero, &memory);
 	if (ret)
 		goto done;
 
-	if (!impl->persistent) {
+	if (!imem->func->persistent) {
 		if (!(iobj = kzalloc(sizeof(*iobj), GFP_KERNEL))) {
 			ret = -ENOMEM;
 			goto done;
@@ -195,7 +194,7 @@ nvkm_instobj_new(struct nvkm_instmem *imem, u32 size, u32 align, bool zero,
 		memory = &iobj->memory;
 	}
 
-	if (!impl->zero && zero) {
+	if (!imem->func->zero && zero) {
 		void __iomem *map = nvkm_kmap(memory);
 		if (unlikely(!map)) {
 			for (offset = 0; offset < size; offset += 4)
@@ -217,13 +216,28 @@ nvkm_instobj_new(struct nvkm_instmem *imem, u32 size, u32 align, bool zero,
  * instmem subdev base implementation
  *****************************************************************************/
 
-int
-_nvkm_instmem_fini(struct nvkm_object *object, bool suspend)
+u32
+nvkm_instmem_rd32(struct nvkm_instmem *imem, u32 addr)
+{
+	return imem->func->rd32(imem, addr);
+}
+
+void
+nvkm_instmem_wr32(struct nvkm_instmem *imem, u32 addr, u32 data)
+{
+	return imem->func->wr32(imem, addr, data);
+}
+
+static int
+nvkm_instmem_fini(struct nvkm_subdev *subdev, bool suspend)
 {
-	struct nvkm_instmem *imem = (void *)object;
+	struct nvkm_instmem *imem = nvkm_instmem(subdev);
 	struct nvkm_instobj *iobj;
 	int i;
 
+	if (imem->func->fini)
+		imem->func->fini(imem);
+
 	if (suspend) {
 		list_for_each_entry(iobj, &imem->list, head) {
 			struct nvkm_memory *memory = iobj->parent;
@@ -238,19 +252,24 @@ _nvkm_instmem_fini(struct nvkm_object *object, bool suspend)
 		}
 	}
 
-	return nvkm_subdev_fini_old(&imem->subdev, suspend);
+	return 0;
 }
 
-int
-_nvkm_instmem_init(struct nvkm_object *object)
+static int
+nvkm_instmem_oneinit(struct nvkm_subdev *subdev)
 {
-	struct nvkm_instmem *imem = (void *)object;
-	struct nvkm_instobj *iobj;
-	int ret, i;
+	struct nvkm_instmem *imem = nvkm_instmem(subdev);
+	if (imem->func->oneinit)
+		return imem->func->oneinit(imem);
+	return 0;
+}
 
-	ret = nvkm_subdev_init_old(&imem->subdev);
-	if (ret)
-		return ret;
+static int
+nvkm_instmem_init(struct nvkm_subdev *subdev)
+{
+	struct nvkm_instmem *imem = nvkm_instmem(subdev);
+	struct nvkm_instobj *iobj;
+	int i;
 
 	list_for_each_entry(iobj, &imem->list, head) {
 		if (iobj->suspend) {
@@ -266,23 +285,29 @@ _nvkm_instmem_init(struct nvkm_object *object)
 	return 0;
 }
 
-int
-nvkm_instmem_create_(struct nvkm_object *parent, struct nvkm_object *engine,
-		     struct nvkm_oclass *oclass, int length, void **pobject)
+static void *
+nvkm_instmem_dtor(struct nvkm_subdev *subdev)
 {
-	struct nvkm_device *device = (void *)parent;
-	struct nvkm_instmem *imem;
-	int ret;
-
-	ret = nvkm_subdev_create_(parent, engine, oclass, 0, "INSTMEM",
-				  "instmem", length, pobject);
-	imem = *pobject;
-	if (ret)
-		return ret;
+	struct nvkm_instmem *imem = nvkm_instmem(subdev);
+	if (imem->func->dtor)
+		return imem->func->dtor(imem);
+	return imem;
+}
 
-	device->imem = imem;
+static const struct nvkm_subdev_func
+nvkm_instmem = {
+	.dtor = nvkm_instmem_dtor,
+	.oneinit = nvkm_instmem_oneinit,
+	.init = nvkm_instmem_init,
+	.fini = nvkm_instmem_fini,
+};
 
+void
+nvkm_instmem_ctor(const struct nvkm_instmem_func *func,
+		  struct nvkm_device *device, int index,
+		  struct nvkm_instmem *imem)
+{
+	nvkm_subdev_ctor(&nvkm_instmem, device, index, 0, &imem->subdev);
+	imem->func = func;
 	INIT_LIST_HEAD(&imem->list);
-	imem->alloc = nvkm_instobj_new;
-	return 0;
 }

commit 3293228174e4d44cca56d809cc8409c3f88f8b90
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/bar: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index 2a1dab304087..6a356f348c58 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -65,9 +65,7 @@ static void
 nvkm_instobj_release(struct nvkm_memory *memory)
 {
 	struct nvkm_instobj *iobj = nvkm_instobj(memory);
-	struct nvkm_bar *bar = iobj->imem->subdev.device->bar;
-	if (bar && bar->flush)
-		bar->flush(bar);
+	nvkm_bar_flush(iobj->imem->subdev.device->bar);
 }
 
 static void __iomem *

commit d8e83994aaf6749b7124a219f5b46bd1329e2a08
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/imem: improve management of instance memory
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index 8ac8e4f4fa4b..2a1dab304087 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -23,83 +23,221 @@
  */
 #include "priv.h"
 
-#include <core/engine.h>
+#include <core/memory.h>
+#include <subdev/bar.h>
 
 /******************************************************************************
  * instmem object base implementation
  *****************************************************************************/
+#define nvkm_instobj(p) container_of((p), struct nvkm_instobj, memory)
 
-void
-_nvkm_instobj_dtor(struct nvkm_object *object)
+struct nvkm_instobj {
+	struct nvkm_memory memory;
+	struct nvkm_memory *parent;
+	struct nvkm_instmem *imem;
+	struct list_head head;
+	u32 *suspend;
+	void __iomem *map;
+};
+
+static enum nvkm_memory_target
+nvkm_instobj_target(struct nvkm_memory *memory)
+{
+	memory = nvkm_instobj(memory)->parent;
+	return nvkm_memory_target(memory);
+}
+
+static u64
+nvkm_instobj_addr(struct nvkm_memory *memory)
+{
+	memory = nvkm_instobj(memory)->parent;
+	return nvkm_memory_addr(memory);
+}
+
+static u64
+nvkm_instobj_size(struct nvkm_memory *memory)
+{
+	memory = nvkm_instobj(memory)->parent;
+	return nvkm_memory_size(memory);
+}
+
+static void
+nvkm_instobj_release(struct nvkm_memory *memory)
+{
+	struct nvkm_instobj *iobj = nvkm_instobj(memory);
+	struct nvkm_bar *bar = iobj->imem->subdev.device->bar;
+	if (bar && bar->flush)
+		bar->flush(bar);
+}
+
+static void __iomem *
+nvkm_instobj_acquire(struct nvkm_memory *memory)
+{
+	return nvkm_instobj(memory)->map;
+}
+
+static u32
+nvkm_instobj_rd32(struct nvkm_memory *memory, u64 offset)
+{
+	return ioread32_native(nvkm_instobj(memory)->map + offset);
+}
+
+static void
+nvkm_instobj_wr32(struct nvkm_memory *memory, u64 offset, u32 data)
 {
-	struct nvkm_instmem *imem = nvkm_instmem(object);
-	struct nvkm_instobj *iobj = (void *)object;
+	iowrite32_native(data, nvkm_instobj(memory)->map + offset);
+}
+
+static void
+nvkm_instobj_map(struct nvkm_memory *memory, struct nvkm_vma *vma, u64 offset)
+{
+	memory = nvkm_instobj(memory)->parent;
+	nvkm_memory_map(memory, vma, offset);
+}
 
-	mutex_lock(&nv_subdev(imem)->mutex);
+static void *
+nvkm_instobj_dtor(struct nvkm_memory *memory)
+{
+	struct nvkm_instobj *iobj = nvkm_instobj(memory);
 	list_del(&iobj->head);
-	mutex_unlock(&nv_subdev(imem)->mutex);
+	nvkm_memory_del(&iobj->parent);
+	return iobj;
+}
 
-	return nvkm_object_destroy(&iobj->object);
+const struct nvkm_memory_func
+nvkm_instobj_func = {
+	.dtor = nvkm_instobj_dtor,
+	.target = nvkm_instobj_target,
+	.addr = nvkm_instobj_addr,
+	.size = nvkm_instobj_size,
+	.acquire = nvkm_instobj_acquire,
+	.release = nvkm_instobj_release,
+	.rd32 = nvkm_instobj_rd32,
+	.wr32 = nvkm_instobj_wr32,
+	.map = nvkm_instobj_map,
+};
+
+static void
+nvkm_instobj_boot(struct nvkm_memory *memory, struct nvkm_vm *vm)
+{
+	memory = nvkm_instobj(memory)->parent;
+	nvkm_memory_boot(memory, vm);
 }
 
-int
-nvkm_instobj_create_(struct nvkm_object *parent, struct nvkm_object *engine,
-		     struct nvkm_oclass *oclass, int length, void **pobject)
+static void
+nvkm_instobj_release_slow(struct nvkm_memory *memory)
+{
+	struct nvkm_instobj *iobj = nvkm_instobj(memory);
+	nvkm_instobj_release(memory);
+	nvkm_done(iobj->parent);
+}
+
+static void __iomem *
+nvkm_instobj_acquire_slow(struct nvkm_memory *memory)
+{
+	struct nvkm_instobj *iobj = nvkm_instobj(memory);
+	iobj->map = nvkm_kmap(iobj->parent);
+	if (iobj->map)
+		memory->func = &nvkm_instobj_func;
+	return iobj->map;
+}
+
+static u32
+nvkm_instobj_rd32_slow(struct nvkm_memory *memory, u64 offset)
+{
+	struct nvkm_instobj *iobj = nvkm_instobj(memory);
+	return nvkm_ro32(iobj->parent, offset);
+}
+
+static void
+nvkm_instobj_wr32_slow(struct nvkm_memory *memory, u64 offset, u32 data)
+{
+	struct nvkm_instobj *iobj = nvkm_instobj(memory);
+	return nvkm_wo32(iobj->parent, offset, data);
+}
+
+const struct nvkm_memory_func
+nvkm_instobj_func_slow = {
+	.dtor = nvkm_instobj_dtor,
+	.target = nvkm_instobj_target,
+	.addr = nvkm_instobj_addr,
+	.size = nvkm_instobj_size,
+	.boot = nvkm_instobj_boot,
+	.acquire = nvkm_instobj_acquire_slow,
+	.release = nvkm_instobj_release_slow,
+	.rd32 = nvkm_instobj_rd32_slow,
+	.wr32 = nvkm_instobj_wr32_slow,
+	.map = nvkm_instobj_map,
+};
+
+static int
+nvkm_instobj_new(struct nvkm_instmem *imem, u32 size, u32 align, bool zero,
+		 struct nvkm_memory **pmemory)
 {
-	struct nvkm_instmem *imem = nvkm_instmem(parent);
+	struct nvkm_instmem_impl *impl = (void *)imem->subdev.object.oclass;
+	struct nvkm_memory *memory;
 	struct nvkm_instobj *iobj;
+	u32 offset;
 	int ret;
 
-	ret = nvkm_object_create_(parent, engine, oclass, NV_MEMOBJ_CLASS,
-				  length, pobject);
-	iobj = *pobject;
+	ret = impl->memory_new(imem, size, align, zero, &memory);
 	if (ret)
-		return ret;
+		goto done;
 
-	mutex_lock(&imem->subdev.mutex);
-	list_add(&iobj->head, &imem->list);
-	mutex_unlock(&imem->subdev.mutex);
-	return 0;
+	if (!impl->persistent) {
+		if (!(iobj = kzalloc(sizeof(*iobj), GFP_KERNEL))) {
+			ret = -ENOMEM;
+			goto done;
+		}
+
+		nvkm_memory_ctor(&nvkm_instobj_func_slow, &iobj->memory);
+		iobj->parent = memory;
+		iobj->imem = imem;
+		list_add_tail(&iobj->head, &imem->list);
+		memory = &iobj->memory;
+	}
+
+	if (!impl->zero && zero) {
+		void __iomem *map = nvkm_kmap(memory);
+		if (unlikely(!map)) {
+			for (offset = 0; offset < size; offset += 4)
+				nvkm_wo32(memory, offset, 0x00000000);
+		} else {
+			memset_io(map, 0x00, size);
+		}
+		nvkm_done(memory);
+	}
+
+done:
+	if (ret)
+		nvkm_memory_del(&memory);
+	*pmemory = memory;
+	return ret;
 }
 
 /******************************************************************************
  * instmem subdev base implementation
  *****************************************************************************/
 
-static int
-nvkm_instmem_alloc(struct nvkm_instmem *imem, struct nvkm_object *parent,
-		   u32 size, u32 align, struct nvkm_object **pobject)
-{
-	struct nvkm_instmem_impl *impl = (void *)imem->subdev.object.oclass;
-	struct nvkm_instobj_args args = { .size = size, .align = align };
-	return nvkm_object_old(parent, &parent->engine->subdev.object,
-				impl->instobj, &args, sizeof(args), pobject);
-}
-
 int
 _nvkm_instmem_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nvkm_instmem *imem = (void *)object;
 	struct nvkm_instobj *iobj;
-	int i, ret = 0;
+	int i;
 
 	if (suspend) {
-		mutex_lock(&imem->subdev.mutex);
 		list_for_each_entry(iobj, &imem->list, head) {
-			iobj->suspend = vmalloc(iobj->size);
-			if (!iobj->suspend) {
-				ret = -ENOMEM;
-				break;
-			}
-
-			for (i = 0; i < iobj->size; i += 4) {
-				nvkm_object_rd32(&iobj->object, i, (u32 *)
-						 &iobj->suspend[i/4]);
-			}
+			struct nvkm_memory *memory = iobj->parent;
+			u64 size = nvkm_memory_size(memory);
+
+			iobj->suspend = vmalloc(size);
+			if (!iobj->suspend)
+				return -ENOMEM;
+
+			for (i = 0; i < size; i += 4)
+				iobj->suspend[i / 4] = nvkm_ro32(memory, i);
 		}
-		mutex_unlock(&imem->subdev.mutex);
-		if (ret)
-			return ret;
 	}
 
 	return nvkm_subdev_fini_old(&imem->subdev, suspend);
@@ -116,18 +254,17 @@ _nvkm_instmem_init(struct nvkm_object *object)
 	if (ret)
 		return ret;
 
-	mutex_lock(&imem->subdev.mutex);
 	list_for_each_entry(iobj, &imem->list, head) {
 		if (iobj->suspend) {
-			for (i = 0; i < iobj->size; i += 4) {
-				nvkm_object_wr32(&iobj->object, i, *(u32 *)
-						 &iobj->suspend[i/4]);
-			}
+			struct nvkm_memory *memory = iobj->parent;
+			u64 size = nvkm_memory_size(memory);
+			for (i = 0; i < size; i += 4)
+				nvkm_wo32(memory, i, iobj->suspend[i / 4]);
 			vfree(iobj->suspend);
 			iobj->suspend = NULL;
 		}
 	}
-	mutex_unlock(&imem->subdev.mutex);
+
 	return 0;
 }
 
@@ -135,6 +272,7 @@ int
 nvkm_instmem_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		     struct nvkm_oclass *oclass, int length, void **pobject)
 {
+	struct nvkm_device *device = (void *)parent;
 	struct nvkm_instmem *imem;
 	int ret;
 
@@ -144,7 +282,9 @@ nvkm_instmem_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
+	device->imem = imem;
+
 	INIT_LIST_HEAD(&imem->list);
-	imem->alloc = nvkm_instmem_alloc;
+	imem->alloc = nvkm_instobj_new;
 	return 0;
 }

commit 3a8c3400f3e74638bedd0d2410416aa8b794c0fd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/subdev: rename some functions to avoid upcoming conflicts
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index 495da913bd11..8ac8e4f4fa4b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -102,7 +102,7 @@ _nvkm_instmem_fini(struct nvkm_object *object, bool suspend)
 			return ret;
 	}
 
-	return nvkm_subdev_fini(&imem->subdev, suspend);
+	return nvkm_subdev_fini_old(&imem->subdev, suspend);
 }
 
 int
@@ -112,7 +112,7 @@ _nvkm_instmem_init(struct nvkm_object *object)
 	struct nvkm_instobj *iobj;
 	int ret, i;
 
-	ret = nvkm_subdev_init(&imem->subdev);
+	ret = nvkm_subdev_init_old(&imem->subdev);
 	if (ret)
 		return ret;
 

commit aa35888ff024b18c7b6b29eb773a221f642987f7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/object: rename some functions to avoid upcoming conflicts
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index 4219eb39cf45..495da913bd11 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -72,7 +72,7 @@ nvkm_instmem_alloc(struct nvkm_instmem *imem, struct nvkm_object *parent,
 {
 	struct nvkm_instmem_impl *impl = (void *)imem->subdev.object.oclass;
 	struct nvkm_instobj_args args = { .size = size, .align = align };
-	return nvkm_object_ctor(parent, &parent->engine->subdev.object,
+	return nvkm_object_old(parent, &parent->engine->subdev.object,
 				impl->instobj, &args, sizeof(args), pobject);
 }
 

commit 95cf469cc3b266324cd9129f93a2d44b85ea27ed
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:14 2015 +1000

    drm/nouveau/imem: use object accessor function for suspend/resume
    
    Very much not ideal, but this will be improved later.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index 43a8f4e19eb6..4219eb39cf45 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -39,7 +39,7 @@ _nvkm_instobj_dtor(struct nvkm_object *object)
 	list_del(&iobj->head);
 	mutex_unlock(&nv_subdev(imem)->mutex);
 
-	return nvkm_object_destroy(&iobj->base);
+	return nvkm_object_destroy(&iobj->object);
 }
 
 int
@@ -92,8 +92,10 @@ _nvkm_instmem_fini(struct nvkm_object *object, bool suspend)
 				break;
 			}
 
-			for (i = 0; i < iobj->size; i += 4)
-				iobj->suspend[i / 4] = nv_ro32(iobj, i);
+			for (i = 0; i < iobj->size; i += 4) {
+				nvkm_object_rd32(&iobj->object, i, (u32 *)
+						 &iobj->suspend[i/4]);
+			}
 		}
 		mutex_unlock(&imem->subdev.mutex);
 		if (ret)
@@ -117,8 +119,10 @@ _nvkm_instmem_init(struct nvkm_object *object)
 	mutex_lock(&imem->subdev.mutex);
 	list_for_each_entry(iobj, &imem->list, head) {
 		if (iobj->suspend) {
-			for (i = 0; i < iobj->size; i += 4)
-				nv_wo32(iobj, i, iobj->suspend[i / 4]);
+			for (i = 0; i < iobj->size; i += 4) {
+				nvkm_object_wr32(&iobj->object, i, *(u32 *)
+						 &iobj->suspend[i/4]);
+			}
 			vfree(iobj->suspend);
 			iobj->suspend = NULL;
 		}

commit c44c06aeebf481fb69c665a21090f2f0aac878c5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/imem: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index d16358cc6cbb..43a8f4e19eb6 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -56,9 +56,9 @@ nvkm_instobj_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	mutex_lock(&imem->base.mutex);
+	mutex_lock(&imem->subdev.mutex);
 	list_add(&iobj->head, &imem->list);
-	mutex_unlock(&imem->base.mutex);
+	mutex_unlock(&imem->subdev.mutex);
 	return 0;
 }
 
@@ -70,7 +70,7 @@ static int
 nvkm_instmem_alloc(struct nvkm_instmem *imem, struct nvkm_object *parent,
 		   u32 size, u32 align, struct nvkm_object **pobject)
 {
-	struct nvkm_instmem_impl *impl = (void *)imem->base.object.oclass;
+	struct nvkm_instmem_impl *impl = (void *)imem->subdev.object.oclass;
 	struct nvkm_instobj_args args = { .size = size, .align = align };
 	return nvkm_object_ctor(parent, &parent->engine->subdev.object,
 				impl->instobj, &args, sizeof(args), pobject);
@@ -84,7 +84,7 @@ _nvkm_instmem_fini(struct nvkm_object *object, bool suspend)
 	int i, ret = 0;
 
 	if (suspend) {
-		mutex_lock(&imem->base.mutex);
+		mutex_lock(&imem->subdev.mutex);
 		list_for_each_entry(iobj, &imem->list, head) {
 			iobj->suspend = vmalloc(iobj->size);
 			if (!iobj->suspend) {
@@ -95,12 +95,12 @@ _nvkm_instmem_fini(struct nvkm_object *object, bool suspend)
 			for (i = 0; i < iobj->size; i += 4)
 				iobj->suspend[i / 4] = nv_ro32(iobj, i);
 		}
-		mutex_unlock(&imem->base.mutex);
+		mutex_unlock(&imem->subdev.mutex);
 		if (ret)
 			return ret;
 	}
 
-	return nvkm_subdev_fini(&imem->base, suspend);
+	return nvkm_subdev_fini(&imem->subdev, suspend);
 }
 
 int
@@ -110,11 +110,11 @@ _nvkm_instmem_init(struct nvkm_object *object)
 	struct nvkm_instobj *iobj;
 	int ret, i;
 
-	ret = nvkm_subdev_init(&imem->base);
+	ret = nvkm_subdev_init(&imem->subdev);
 	if (ret)
 		return ret;
 
-	mutex_lock(&imem->base.mutex);
+	mutex_lock(&imem->subdev.mutex);
 	list_for_each_entry(iobj, &imem->list, head) {
 		if (iobj->suspend) {
 			for (i = 0; i < iobj->size; i += 4)
@@ -123,7 +123,7 @@ _nvkm_instmem_init(struct nvkm_object *object)
 			iobj->suspend = NULL;
 		}
 	}
-	mutex_unlock(&imem->base.mutex);
+	mutex_unlock(&imem->subdev.mutex);
 	return 0;
 }
 

commit 78b2b4e76be2100637a92b9721aaa2ce73d0fa22
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:05:26 2015 +1000

    drm/nouveau/instmem: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
index 767fcf70f98f..d16358cc6cbb 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -21,38 +21,37 @@
  *
  * Authors: Ben Skeggs
  */
-
 #include "priv.h"
 
+#include <core/engine.h>
+
 /******************************************************************************
  * instmem object base implementation
  *****************************************************************************/
 
 void
-_nouveau_instobj_dtor(struct nouveau_object *object)
+_nvkm_instobj_dtor(struct nvkm_object *object)
 {
-	struct nouveau_instmem *imem = nouveau_instmem(object);
-	struct nouveau_instobj *iobj = (void *)object;
+	struct nvkm_instmem *imem = nvkm_instmem(object);
+	struct nvkm_instobj *iobj = (void *)object;
 
 	mutex_lock(&nv_subdev(imem)->mutex);
 	list_del(&iobj->head);
 	mutex_unlock(&nv_subdev(imem)->mutex);
 
-	return nouveau_object_destroy(&iobj->base);
+	return nvkm_object_destroy(&iobj->base);
 }
 
 int
-nouveau_instobj_create_(struct nouveau_object *parent,
-			struct nouveau_object *engine,
-			struct nouveau_oclass *oclass,
-			int length, void **pobject)
+nvkm_instobj_create_(struct nvkm_object *parent, struct nvkm_object *engine,
+		     struct nvkm_oclass *oclass, int length, void **pobject)
 {
-	struct nouveau_instmem *imem = nouveau_instmem(parent);
-	struct nouveau_instobj *iobj;
+	struct nvkm_instmem *imem = nvkm_instmem(parent);
+	struct nvkm_instobj *iobj;
 	int ret;
 
-	ret = nouveau_object_create_(parent, engine, oclass, NV_MEMOBJ_CLASS,
-				     length, pobject);
+	ret = nvkm_object_create_(parent, engine, oclass, NV_MEMOBJ_CLASS,
+				  length, pobject);
 	iobj = *pobject;
 	if (ret)
 		return ret;
@@ -68,26 +67,24 @@ nouveau_instobj_create_(struct nouveau_object *parent,
  *****************************************************************************/
 
 static int
-nouveau_instmem_alloc(struct nouveau_instmem *imem,
-		      struct nouveau_object *parent, u32 size, u32 align,
-		      struct nouveau_object **pobject)
+nvkm_instmem_alloc(struct nvkm_instmem *imem, struct nvkm_object *parent,
+		   u32 size, u32 align, struct nvkm_object **pobject)
 {
-	struct nouveau_instmem_impl *impl = (void *)imem->base.object.oclass;
-	struct nouveau_instobj_args args = { .size = size, .align = align };
-	return nouveau_object_ctor(parent, &parent->engine->subdev.object,
-				   impl->instobj, &args, sizeof(args), pobject);
+	struct nvkm_instmem_impl *impl = (void *)imem->base.object.oclass;
+	struct nvkm_instobj_args args = { .size = size, .align = align };
+	return nvkm_object_ctor(parent, &parent->engine->subdev.object,
+				impl->instobj, &args, sizeof(args), pobject);
 }
 
 int
-_nouveau_instmem_fini(struct nouveau_object *object, bool suspend)
+_nvkm_instmem_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nouveau_instmem *imem = (void *)object;
-	struct nouveau_instobj *iobj;
+	struct nvkm_instmem *imem = (void *)object;
+	struct nvkm_instobj *iobj;
 	int i, ret = 0;
 
 	if (suspend) {
 		mutex_lock(&imem->base.mutex);
-
 		list_for_each_entry(iobj, &imem->list, head) {
 			iobj->suspend = vmalloc(iobj->size);
 			if (!iobj->suspend) {
@@ -98,29 +95,26 @@ _nouveau_instmem_fini(struct nouveau_object *object, bool suspend)
 			for (i = 0; i < iobj->size; i += 4)
 				iobj->suspend[i / 4] = nv_ro32(iobj, i);
 		}
-
 		mutex_unlock(&imem->base.mutex);
-
 		if (ret)
 			return ret;
 	}
 
-	return nouveau_subdev_fini(&imem->base, suspend);
+	return nvkm_subdev_fini(&imem->base, suspend);
 }
 
 int
-_nouveau_instmem_init(struct nouveau_object *object)
+_nvkm_instmem_init(struct nvkm_object *object)
 {
-	struct nouveau_instmem *imem = (void *)object;
-	struct nouveau_instobj *iobj;
+	struct nvkm_instmem *imem = (void *)object;
+	struct nvkm_instobj *iobj;
 	int ret, i;
 
-	ret = nouveau_subdev_init(&imem->base);
+	ret = nvkm_subdev_init(&imem->base);
 	if (ret)
 		return ret;
 
 	mutex_lock(&imem->base.mutex);
-
 	list_for_each_entry(iobj, &imem->list, head) {
 		if (iobj->suspend) {
 			for (i = 0; i < iobj->size; i += 4)
@@ -129,28 +123,24 @@ _nouveau_instmem_init(struct nouveau_object *object)
 			iobj->suspend = NULL;
 		}
 	}
-
 	mutex_unlock(&imem->base.mutex);
-
 	return 0;
 }
 
 int
-nouveau_instmem_create_(struct nouveau_object *parent,
-			struct nouveau_object *engine,
-			struct nouveau_oclass *oclass,
-			int length, void **pobject)
+nvkm_instmem_create_(struct nvkm_object *parent, struct nvkm_object *engine,
+		     struct nvkm_oclass *oclass, int length, void **pobject)
 {
-	struct nouveau_instmem *imem;
+	struct nvkm_instmem *imem;
 	int ret;
 
-	ret = nouveau_subdev_create_(parent, engine, oclass, 0,
-				     "INSTMEM", "instmem", length, pobject);
+	ret = nvkm_subdev_create_(parent, engine, oclass, 0, "INSTMEM",
+				  "instmem", length, pobject);
 	imem = *pobject;
 	if (ret)
 		return ret;
 
 	INIT_LIST_HEAD(&imem->list);
-	imem->alloc = nouveau_instmem_alloc;
+	imem->alloc = nvkm_instmem_alloc;
 	return 0;
 }

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
new file mode 100644
index 000000000000..767fcf70f98f
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c
@@ -0,0 +1,156 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include "priv.h"
+
+/******************************************************************************
+ * instmem object base implementation
+ *****************************************************************************/
+
+void
+_nouveau_instobj_dtor(struct nouveau_object *object)
+{
+	struct nouveau_instmem *imem = nouveau_instmem(object);
+	struct nouveau_instobj *iobj = (void *)object;
+
+	mutex_lock(&nv_subdev(imem)->mutex);
+	list_del(&iobj->head);
+	mutex_unlock(&nv_subdev(imem)->mutex);
+
+	return nouveau_object_destroy(&iobj->base);
+}
+
+int
+nouveau_instobj_create_(struct nouveau_object *parent,
+			struct nouveau_object *engine,
+			struct nouveau_oclass *oclass,
+			int length, void **pobject)
+{
+	struct nouveau_instmem *imem = nouveau_instmem(parent);
+	struct nouveau_instobj *iobj;
+	int ret;
+
+	ret = nouveau_object_create_(parent, engine, oclass, NV_MEMOBJ_CLASS,
+				     length, pobject);
+	iobj = *pobject;
+	if (ret)
+		return ret;
+
+	mutex_lock(&imem->base.mutex);
+	list_add(&iobj->head, &imem->list);
+	mutex_unlock(&imem->base.mutex);
+	return 0;
+}
+
+/******************************************************************************
+ * instmem subdev base implementation
+ *****************************************************************************/
+
+static int
+nouveau_instmem_alloc(struct nouveau_instmem *imem,
+		      struct nouveau_object *parent, u32 size, u32 align,
+		      struct nouveau_object **pobject)
+{
+	struct nouveau_instmem_impl *impl = (void *)imem->base.object.oclass;
+	struct nouveau_instobj_args args = { .size = size, .align = align };
+	return nouveau_object_ctor(parent, &parent->engine->subdev.object,
+				   impl->instobj, &args, sizeof(args), pobject);
+}
+
+int
+_nouveau_instmem_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nouveau_instmem *imem = (void *)object;
+	struct nouveau_instobj *iobj;
+	int i, ret = 0;
+
+	if (suspend) {
+		mutex_lock(&imem->base.mutex);
+
+		list_for_each_entry(iobj, &imem->list, head) {
+			iobj->suspend = vmalloc(iobj->size);
+			if (!iobj->suspend) {
+				ret = -ENOMEM;
+				break;
+			}
+
+			for (i = 0; i < iobj->size; i += 4)
+				iobj->suspend[i / 4] = nv_ro32(iobj, i);
+		}
+
+		mutex_unlock(&imem->base.mutex);
+
+		if (ret)
+			return ret;
+	}
+
+	return nouveau_subdev_fini(&imem->base, suspend);
+}
+
+int
+_nouveau_instmem_init(struct nouveau_object *object)
+{
+	struct nouveau_instmem *imem = (void *)object;
+	struct nouveau_instobj *iobj;
+	int ret, i;
+
+	ret = nouveau_subdev_init(&imem->base);
+	if (ret)
+		return ret;
+
+	mutex_lock(&imem->base.mutex);
+
+	list_for_each_entry(iobj, &imem->list, head) {
+		if (iobj->suspend) {
+			for (i = 0; i < iobj->size; i += 4)
+				nv_wo32(iobj, i, iobj->suspend[i / 4]);
+			vfree(iobj->suspend);
+			iobj->suspend = NULL;
+		}
+	}
+
+	mutex_unlock(&imem->base.mutex);
+
+	return 0;
+}
+
+int
+nouveau_instmem_create_(struct nouveau_object *parent,
+			struct nouveau_object *engine,
+			struct nouveau_oclass *oclass,
+			int length, void **pobject)
+{
+	struct nouveau_instmem *imem;
+	int ret;
+
+	ret = nouveau_subdev_create_(parent, engine, oclass, 0,
+				     "INSTMEM", "instmem", length, pobject);
+	imem = *pobject;
+	if (ret)
+		return ret;
+
+	INIT_LIST_HEAD(&imem->list);
+	imem->alloc = nouveau_instmem_alloc;
+	return 0;
+}
