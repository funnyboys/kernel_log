commit f8a1203920e7de49bd99bfed76a82f0c93de2020
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/ltc/gm200: limit NV_MMU_PTE_COMPTAGLINE bits to 16 where required
    
    If NV_PFB_MMU_CTRL_USE_FULL_COMP_TAG_LINE is TRUE, then the last bit of
    NV_MMU_PTE_COMPTAGLINE is re-purposed to select the upper/lower half of
    a compression tag when using 64KiB big pages.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
index 59acf568faeb..a21ef45b8572 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
@@ -156,6 +156,7 @@ gf100_ltc_oneinit_tag_ram(struct nvkm_ltc *ltc)
 	struct nvkm_device *device = ltc->subdev.device;
 	struct nvkm_fb *fb = device->fb;
 	struct nvkm_ram *ram = fb->ram;
+	u32 bits = (nvkm_rd32(device, 0x100c80) & 0x00001000) ? 16 : 17;
 	u32 tag_size, tag_margin, tag_align;
 	int ret;
 
@@ -167,8 +168,8 @@ gf100_ltc_oneinit_tag_ram(struct nvkm_ltc *ltc)
 
 	/* tags for 1/4 of VRAM should be enough (8192/4 per GiB of VRAM) */
 	ltc->num_tags = (ram->size >> 17) / 4;
-	if (ltc->num_tags > (1 << 17))
-		ltc->num_tags = 1 << 17; /* we have 17 bits in PTE */
+	if (ltc->num_tags > (1 << bits))
+		ltc->num_tags = 1 << bits; /* we have 16/17 bits in PTE */
 	ltc->num_tags = (ltc->num_tags + 63) & ~63; /* round up to 64 */
 
 	tag_align = ltc->ltc_nr * 0x800;

commit bd447053b33d9c2a173e1d3953c95a7cd5182656
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/ltc/gf100-: allocate tagram with nvkm_ram_get()
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
index 60a5e9e2b264..59acf568faeb 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
@@ -23,6 +23,7 @@
  */
 #include "priv.h"
 
+#include <core/memory.h>
 #include <subdev/fb.h>
 #include <subdev/timer.h>
 
@@ -152,7 +153,8 @@ gf100_ltc_flush(struct nvkm_ltc *ltc)
 int
 gf100_ltc_oneinit_tag_ram(struct nvkm_ltc *ltc)
 {
-	struct nvkm_fb *fb = ltc->subdev.device->fb;
+	struct nvkm_device *device = ltc->subdev.device;
+	struct nvkm_fb *fb = device->fb;
 	struct nvkm_ram *ram = fb->ram;
 	u32 tag_size, tag_margin, tag_align;
 	int ret;
@@ -182,14 +184,13 @@ gf100_ltc_oneinit_tag_ram(struct nvkm_ltc *ltc)
 	 */
 	tag_size  = (ltc->num_tags / 64) * 0x6000 + tag_margin;
 	tag_size += tag_align;
-	tag_size  = (tag_size + 0xfff) >> 12; /* round up */
 
-	ret = nvkm_mm_tail(&ram->vram, NVKM_RAM_MM_NORMAL, 1, tag_size,
-			   tag_size, 1, &ltc->tag_ram);
+	ret = nvkm_ram_get(device, NVKM_RAM_MM_NORMAL, 0x01, 12, tag_size,
+			   true, true, &ltc->tag_ram);
 	if (ret) {
 		ltc->num_tags = 0;
 	} else {
-		u64 tag_base = ((u64)ltc->tag_ram->offset << 12) + tag_margin;
+		u64 tag_base = nvkm_memory_addr(ltc->tag_ram) + tag_margin;
 
 		tag_base += tag_align - 1;
 		do_div(tag_base, tag_align);

commit 6cd7670c1e2a4a70a3d421521aea548e68992621
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/ltc: init comptag mm in fb subdev
    
    A single location for the MM allows us to share allocation logic.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
index 6b0cb7f3fa77..60a5e9e2b264 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
@@ -152,7 +152,8 @@ gf100_ltc_flush(struct nvkm_ltc *ltc)
 int
 gf100_ltc_oneinit_tag_ram(struct nvkm_ltc *ltc)
 {
-	struct nvkm_ram *ram = ltc->subdev.device->fb->ram;
+	struct nvkm_fb *fb = ltc->subdev.device->fb;
+	struct nvkm_ram *ram = fb->ram;
 	u32 tag_size, tag_margin, tag_align;
 	int ret;
 
@@ -197,7 +198,8 @@ gf100_ltc_oneinit_tag_ram(struct nvkm_ltc *ltc)
 	}
 
 mm_init:
-	return nvkm_mm_init(&ltc->tags, 0, 0, ltc->num_tags, 1);
+	nvkm_mm_fini(&fb->tags);
+	return nvkm_mm_init(&fb->tags, 0, 0, ltc->num_tags, 1);
 }
 
 int

commit 4d058fab63f79e5cf13d21edd9db1a63748da0a1
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/core/mm: have users explicitly define heap identifiers
    
    Different sections of VRAM may have different properties (ie. can't be used
    for compression/display, can't be mapped, etc).
    
    We currently already support this, but it's a bit magic.  This change makes
    it more obvious where we're allocating from.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
index 4a0fa0a9b802..6b0cb7f3fa77 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
@@ -183,8 +183,8 @@ gf100_ltc_oneinit_tag_ram(struct nvkm_ltc *ltc)
 	tag_size += tag_align;
 	tag_size  = (tag_size + 0xfff) >> 12; /* round up */
 
-	ret = nvkm_mm_tail(&ram->vram, 1, 1, tag_size, tag_size, 1,
-			   &ltc->tag_ram);
+	ret = nvkm_mm_tail(&ram->vram, NVKM_RAM_MM_NORMAL, 1, tag_size,
+			   tag_size, 1, &ltc->tag_ram);
 	if (ret) {
 		ltc->num_tags = 0;
 	} else {
@@ -197,7 +197,7 @@ gf100_ltc_oneinit_tag_ram(struct nvkm_ltc *ltc)
 	}
 
 mm_init:
-	return nvkm_mm_init(&ltc->tags, 0, ltc->num_tags, 1);
+	return nvkm_mm_init(&ltc->tags, 0, 0, ltc->num_tags, 1);
 }
 
 int

commit 86b40432bd1986ad0e3b5822c4ef54c0dc1dacbc
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jun 21 12:41:36 2016 +1000

    drm/nouveau/ltc/gm107-: decode interrupt status to human-readable strings
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
index c9eb677967a8..4a0fa0a9b802 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
@@ -23,7 +23,6 @@
  */
 #include "priv.h"
 
-#include <core/enum.h>
 #include <subdev/fb.h>
 #include <subdev/timer.h>
 
@@ -71,7 +70,7 @@ gf100_ltc_zbc_clear_depth(struct nvkm_ltc *ltc, int i, const u32 depth)
 	nvkm_wr32(device, 0x17ea58, depth);
 }
 
-static const struct nvkm_bitfield
+const struct nvkm_bitfield
 gf100_ltc_lts_intr_name[] = {
 	{ 0x00000001, "IDLE_ERROR_IQ" },
 	{ 0x00000002, "IDLE_ERROR_CBC" },

commit ab08f38cacd47168db1d568ae0a8249105e0cc06
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Tue Mar 1 17:39:00 2016 +0900

    drm/nouveau/ltc/gf100: use more reasonable timeout value
    
    LTC operations timeout was set to 2ms, which may be too low for devices
    that run at very low clocks (e.g. GM20B) and trigger timeout messages.
    
    Set the timeout to the default 2s. Also remove the redundant error
    messages since nvkm_wait_msec() will already display a warning.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
index fb0de83da13c..c9eb677967a8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
@@ -129,9 +129,7 @@ gf100_ltc_invalidate(struct nvkm_ltc *ltc)
 	s64 taken;
 
 	nvkm_wr32(device, 0x70004, 0x00000001);
-	taken = nvkm_wait_msec(device, 2, 0x70004, 0x00000003, 0x00000000);
-	if (taken < 0)
-		nvkm_warn(&ltc->subdev, "LTC invalidate timeout\n");
+	taken = nvkm_wait_msec(device, 2000, 0x70004, 0x00000003, 0x00000000);
 
 	if (taken > 0)
 		nvkm_debug(&ltc->subdev, "LTC invalidate took %lld ns\n", taken);
@@ -144,9 +142,7 @@ gf100_ltc_flush(struct nvkm_ltc *ltc)
 	s64 taken;
 
 	nvkm_wr32(device, 0x70010, 0x00000001);
-	taken = nvkm_wait_msec(device, 2, 0x70010, 0x00000003, 0x00000000);
-	if (taken < 0)
-		nvkm_warn(&ltc->subdev, "LTC flush timeout\n");
+	taken = nvkm_wait_msec(device, 2000, 0x70010, 0x00000003, 0x00000000);
 
 	if (taken > 0)
 		nvkm_debug(&ltc->subdev, "LTC flush took %lld ns\n", taken);

commit a0a49bac2fe18375b7ccb9de4671960531294470
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Thu Sep 3 17:48:15 2015 +0900

    drm/nouveau/ltc/gf100: add flush/invalidate functions
    
    Allow clients to manually flush and invalidate L2. This will be useful
    for Tegra systems for which we want to write instmem using the CPU.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
index 45ac765b753e..fb0de83da13c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
@@ -122,6 +122,36 @@ gf100_ltc_intr(struct nvkm_ltc *ltc)
 	}
 }
 
+void
+gf100_ltc_invalidate(struct nvkm_ltc *ltc)
+{
+	struct nvkm_device *device = ltc->subdev.device;
+	s64 taken;
+
+	nvkm_wr32(device, 0x70004, 0x00000001);
+	taken = nvkm_wait_msec(device, 2, 0x70004, 0x00000003, 0x00000000);
+	if (taken < 0)
+		nvkm_warn(&ltc->subdev, "LTC invalidate timeout\n");
+
+	if (taken > 0)
+		nvkm_debug(&ltc->subdev, "LTC invalidate took %lld ns\n", taken);
+}
+
+void
+gf100_ltc_flush(struct nvkm_ltc *ltc)
+{
+	struct nvkm_device *device = ltc->subdev.device;
+	s64 taken;
+
+	nvkm_wr32(device, 0x70010, 0x00000001);
+	taken = nvkm_wait_msec(device, 2, 0x70010, 0x00000003, 0x00000000);
+	if (taken < 0)
+		nvkm_warn(&ltc->subdev, "LTC flush timeout\n");
+
+	if (taken > 0)
+		nvkm_debug(&ltc->subdev, "LTC flush took %lld ns\n", taken);
+}
+
 /* TODO: Figure out tag memory details and drop the over-cautious allocation.
  */
 int
@@ -215,6 +245,8 @@ gf100_ltc = {
 	.zbc = 16,
 	.zbc_clear_color = gf100_ltc_zbc_clear_color,
 	.zbc_clear_depth = gf100_ltc_zbc_clear_depth,
+	.invalidate = gf100_ltc_invalidate,
+	.flush = gf100_ltc_flush,
 };
 
 int

commit 70bc7182cbf1bb07e414bbb553890ddf1b540264
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:21 2015 +1000

    drm/nouveau/ltc: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
index 5cb7604beeb6..45ac765b753e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
@@ -28,18 +28,18 @@
 #include <subdev/timer.h>
 
 void
-gf100_ltc_cbc_clear(struct nvkm_ltc_priv *ltc, u32 start, u32 limit)
+gf100_ltc_cbc_clear(struct nvkm_ltc *ltc, u32 start, u32 limit)
 {
-	struct nvkm_device *device = ltc->base.subdev.device;
+	struct nvkm_device *device = ltc->subdev.device;
 	nvkm_wr32(device, 0x17e8cc, start);
 	nvkm_wr32(device, 0x17e8d0, limit);
 	nvkm_wr32(device, 0x17e8c8, 0x00000004);
 }
 
 void
-gf100_ltc_cbc_wait(struct nvkm_ltc_priv *ltc)
+gf100_ltc_cbc_wait(struct nvkm_ltc *ltc)
 {
-	struct nvkm_device *device = ltc->base.subdev.device;
+	struct nvkm_device *device = ltc->subdev.device;
 	int c, s;
 	for (c = 0; c < ltc->ltc_nr; c++) {
 		for (s = 0; s < ltc->lts_nr; s++) {
@@ -53,9 +53,9 @@ gf100_ltc_cbc_wait(struct nvkm_ltc_priv *ltc)
 }
 
 void
-gf100_ltc_zbc_clear_color(struct nvkm_ltc_priv *ltc, int i, const u32 color[4])
+gf100_ltc_zbc_clear_color(struct nvkm_ltc *ltc, int i, const u32 color[4])
 {
-	struct nvkm_device *device = ltc->base.subdev.device;
+	struct nvkm_device *device = ltc->subdev.device;
 	nvkm_mask(device, 0x17ea44, 0x0000000f, i);
 	nvkm_wr32(device, 0x17ea48, color[0]);
 	nvkm_wr32(device, 0x17ea4c, color[1]);
@@ -64,9 +64,9 @@ gf100_ltc_zbc_clear_color(struct nvkm_ltc_priv *ltc, int i, const u32 color[4])
 }
 
 void
-gf100_ltc_zbc_clear_depth(struct nvkm_ltc_priv *ltc, int i, const u32 depth)
+gf100_ltc_zbc_clear_depth(struct nvkm_ltc *ltc, int i, const u32 depth)
 {
-	struct nvkm_device *device = ltc->base.subdev.device;
+	struct nvkm_device *device = ltc->subdev.device;
 	nvkm_mask(device, 0x17ea44, 0x0000000f, i);
 	nvkm_wr32(device, 0x17ea58, depth);
 }
@@ -90,9 +90,9 @@ gf100_ltc_lts_intr_name[] = {
 };
 
 static void
-gf100_ltc_lts_intr(struct nvkm_ltc_priv *ltc, int c, int s)
+gf100_ltc_lts_intr(struct nvkm_ltc *ltc, int c, int s)
 {
-	struct nvkm_subdev *subdev = &ltc->base.subdev;
+	struct nvkm_subdev *subdev = &ltc->subdev;
 	struct nvkm_device *device = subdev->device;
 	u32 base = 0x141000 + (c * 0x2000) + (s * 0x400);
 	u32 intr = nvkm_rd32(device, base + 0x020);
@@ -108,10 +108,9 @@ gf100_ltc_lts_intr(struct nvkm_ltc_priv *ltc, int c, int s)
 }
 
 void
-gf100_ltc_intr(struct nvkm_subdev *subdev)
+gf100_ltc_intr(struct nvkm_ltc *ltc)
 {
-	struct nvkm_ltc_priv *ltc = (void *)subdev;
-	struct nvkm_device *device = ltc->base.subdev.device;
+	struct nvkm_device *device = ltc->subdev.device;
 	u32 mask;
 
 	mask = nvkm_rd32(device, 0x00017c);
@@ -123,44 +122,12 @@ gf100_ltc_intr(struct nvkm_subdev *subdev)
 	}
 }
 
-static int
-gf100_ltc_init(struct nvkm_object *object)
-{
-	struct nvkm_ltc_priv *ltc = (void *)object;
-	struct nvkm_device *device = ltc->base.subdev.device;
-	u32 lpg128 = !(nvkm_rd32(device, 0x100c80) & 0x00000001);
-	int ret;
-
-	ret = nvkm_ltc_init(ltc);
-	if (ret)
-		return ret;
-
-	nvkm_mask(device, 0x17e820, 0x00100000, 0x00000000); /* INTR_EN &= ~0x10 */
-	nvkm_wr32(device, 0x17e8d8, ltc->ltc_nr);
-	nvkm_wr32(device, 0x17e8d4, ltc->tag_base);
-	nvkm_mask(device, 0x17e8c0, 0x00000002, lpg128 ? 0x00000002 : 0x00000000);
-	return 0;
-}
-
-void
-gf100_ltc_dtor(struct nvkm_object *object)
-{
-	struct nvkm_ltc_priv *ltc = (void *)object;
-	struct nvkm_ram *ram = ltc->base.subdev.device->fb->ram;
-
-	nvkm_mm_fini(&ltc->tags);
-	if (ram)
-		nvkm_mm_free(&ram->vram, &ltc->tag_ram);
-
-	nvkm_ltc_destroy(ltc);
-}
-
 /* TODO: Figure out tag memory details and drop the over-cautious allocation.
  */
 int
-gf100_ltc_init_tag_ram(struct nvkm_ltc_priv *ltc)
+gf100_ltc_oneinit_tag_ram(struct nvkm_ltc *ltc)
 {
-	struct nvkm_ram *ram = ltc->base.subdev.device->fb->ram;
+	struct nvkm_ram *ram = ltc->subdev.device->fb->ram;
 	u32 tag_size, tag_margin, tag_align;
 	int ret;
 
@@ -205,54 +172,53 @@ gf100_ltc_init_tag_ram(struct nvkm_ltc_priv *ltc)
 	}
 
 mm_init:
-	ret = nvkm_mm_init(&ltc->tags, 0, ltc->num_tags, 1);
-	return ret;
+	return nvkm_mm_init(&ltc->tags, 0, ltc->num_tags, 1);
 }
 
 int
-gf100_ltc_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-	       struct nvkm_oclass *oclass, void *data, u32 size,
-	       struct nvkm_object **pobject)
+gf100_ltc_oneinit(struct nvkm_ltc *ltc)
 {
-	struct nvkm_device *device = (void *)parent;
-	struct nvkm_ltc_priv *ltc;
-	u32 parts, mask;
-	int ret, i;
-
-	ret = nvkm_ltc_create(parent, engine, oclass, &ltc);
-	*pobject = nv_object(ltc);
-	if (ret)
-		return ret;
+	struct nvkm_device *device = ltc->subdev.device;
+	const u32 parts = nvkm_rd32(device, 0x022438);
+	const u32  mask = nvkm_rd32(device, 0x022554);
+	const u32 slice = nvkm_rd32(device, 0x17e8dc) >> 28;
+	int i;
 
-	parts = nvkm_rd32(device, 0x022438);
-	mask = nvkm_rd32(device, 0x022554);
 	for (i = 0; i < parts; i++) {
 		if (!(mask & (1 << i)))
 			ltc->ltc_nr++;
 	}
-	ltc->lts_nr = nvkm_rd32(device, 0x17e8dc) >> 28;
+	ltc->lts_nr = slice;
+
+	return gf100_ltc_oneinit_tag_ram(ltc);
+}
 
-	ret = gf100_ltc_init_tag_ram(ltc);
-	if (ret)
-		return ret;
+static void
+gf100_ltc_init(struct nvkm_ltc *ltc)
+{
+	struct nvkm_device *device = ltc->subdev.device;
+	u32 lpg128 = !(nvkm_rd32(device, 0x100c80) & 0x00000001);
 
-	nv_subdev(ltc)->intr = gf100_ltc_intr;
-	return 0;
+	nvkm_mask(device, 0x17e820, 0x00100000, 0x00000000); /* INTR_EN &= ~0x10 */
+	nvkm_wr32(device, 0x17e8d8, ltc->ltc_nr);
+	nvkm_wr32(device, 0x17e8d4, ltc->tag_base);
+	nvkm_mask(device, 0x17e8c0, 0x00000002, lpg128 ? 0x00000002 : 0x00000000);
 }
 
-struct nvkm_oclass *
-gf100_ltc_oclass = &(struct nvkm_ltc_impl) {
-	.base.handle = NV_SUBDEV(LTC, 0xc0),
-	.base.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = gf100_ltc_ctor,
-		.dtor = gf100_ltc_dtor,
-		.init = gf100_ltc_init,
-		.fini = _nvkm_ltc_fini,
-	},
+static const struct nvkm_ltc_func
+gf100_ltc = {
+	.oneinit = gf100_ltc_oneinit,
+	.init = gf100_ltc_init,
 	.intr = gf100_ltc_intr,
 	.cbc_clear = gf100_ltc_cbc_clear,
 	.cbc_wait = gf100_ltc_cbc_wait,
 	.zbc = 16,
 	.zbc_clear_color = gf100_ltc_zbc_clear_color,
 	.zbc_clear_depth = gf100_ltc_zbc_clear_depth,
-}.base;
+};
+
+int
+gf100_ltc_new(struct nvkm_device *device, int index, struct nvkm_ltc **pltc)
+{
+	return nvkm_ltc_new_(&gf100_ltc, device, index, pltc);
+}

commit d36a99d2da22bdffebf644e4a5f811e8eff82360
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:14 2015 +1000

    drm/nouveau/fb: transition nvkm_ram away from being based on nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
index 22712cdc01b3..5cb7604beeb6 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
@@ -145,12 +145,12 @@ gf100_ltc_init(struct nvkm_object *object)
 void
 gf100_ltc_dtor(struct nvkm_object *object)
 {
-	struct nvkm_fb *fb = nvkm_fb(object);
 	struct nvkm_ltc_priv *ltc = (void *)object;
+	struct nvkm_ram *ram = ltc->base.subdev.device->fb->ram;
 
 	nvkm_mm_fini(&ltc->tags);
-	if (fb->ram)
-		nvkm_mm_free(&fb->vram, &ltc->tag_ram);
+	if (ram)
+		nvkm_mm_free(&ram->vram, &ltc->tag_ram);
 
 	nvkm_ltc_destroy(ltc);
 }
@@ -158,19 +158,20 @@ gf100_ltc_dtor(struct nvkm_object *object)
 /* TODO: Figure out tag memory details and drop the over-cautious allocation.
  */
 int
-gf100_ltc_init_tag_ram(struct nvkm_fb *fb, struct nvkm_ltc_priv *ltc)
+gf100_ltc_init_tag_ram(struct nvkm_ltc_priv *ltc)
 {
+	struct nvkm_ram *ram = ltc->base.subdev.device->fb->ram;
 	u32 tag_size, tag_margin, tag_align;
 	int ret;
 
 	/* No VRAM, no tags for now. */
-	if (!fb->ram) {
+	if (!ram) {
 		ltc->num_tags = 0;
 		goto mm_init;
 	}
 
 	/* tags for 1/4 of VRAM should be enough (8192/4 per GiB of VRAM) */
-	ltc->num_tags = (fb->ram->size >> 17) / 4;
+	ltc->num_tags = (ram->size >> 17) / 4;
 	if (ltc->num_tags > (1 << 17))
 		ltc->num_tags = 1 << 17; /* we have 17 bits in PTE */
 	ltc->num_tags = (ltc->num_tags + 63) & ~63; /* round up to 64 */
@@ -190,7 +191,7 @@ gf100_ltc_init_tag_ram(struct nvkm_fb *fb, struct nvkm_ltc_priv *ltc)
 	tag_size += tag_align;
 	tag_size  = (tag_size + 0xfff) >> 12; /* round up */
 
-	ret = nvkm_mm_tail(&fb->vram, 1, 1, tag_size, tag_size, 1,
+	ret = nvkm_mm_tail(&ram->vram, 1, 1, tag_size, tag_size, 1,
 			   &ltc->tag_ram);
 	if (ret) {
 		ltc->num_tags = 0;
@@ -214,7 +215,6 @@ gf100_ltc_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_object **pobject)
 {
 	struct nvkm_device *device = (void *)parent;
-	struct nvkm_fb *fb = device->fb;
 	struct nvkm_ltc_priv *ltc;
 	u32 parts, mask;
 	int ret, i;
@@ -232,7 +232,7 @@ gf100_ltc_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	}
 	ltc->lts_nr = nvkm_rd32(device, 0x17e8dc) >> 28;
 
-	ret = gf100_ltc_init_tag_ram(fb, ltc);
+	ret = gf100_ltc_init_tag_ram(ltc);
 	if (ret)
 		return ret;
 

commit 59e1a2f1a665c6defc0050060846ed3d89291e8c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:12 2015 +1000

    drm/nouveau/ltc: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
index 7e60a1393fc8..22712cdc01b3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
@@ -92,15 +92,16 @@ gf100_ltc_lts_intr_name[] = {
 static void
 gf100_ltc_lts_intr(struct nvkm_ltc_priv *ltc, int c, int s)
 {
-	struct nvkm_device *device = ltc->base.subdev.device;
+	struct nvkm_subdev *subdev = &ltc->base.subdev;
+	struct nvkm_device *device = subdev->device;
 	u32 base = 0x141000 + (c * 0x2000) + (s * 0x400);
 	u32 intr = nvkm_rd32(device, base + 0x020);
 	u32 stat = intr & 0x0000ffff;
+	char msg[128];
 
 	if (stat) {
-		nv_info(ltc, "LTC%d_LTS%d:", c, s);
-		nvkm_bitfield_print(gf100_ltc_lts_intr_name, stat);
-		pr_cont("\n");
+		nvkm_snprintbf(msg, sizeof(msg), gf100_ltc_lts_intr_name, stat);
+		nvkm_error(subdev, "LTC%d_LTS%d: %08x [%s]\n", c, s, stat, msg);
 	}
 
 	nvkm_wr32(device, base + 0x020, intr);

commit 1302bcbb8229b0575401be87765277629330384a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:11 2015 +1000

    drm/nouveau/ltc: switch to new-style timer macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
index df60ee264b95..7e60a1393fc8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
@@ -39,10 +39,16 @@ gf100_ltc_cbc_clear(struct nvkm_ltc_priv *ltc, u32 start, u32 limit)
 void
 gf100_ltc_cbc_wait(struct nvkm_ltc_priv *ltc)
 {
+	struct nvkm_device *device = ltc->base.subdev.device;
 	int c, s;
 	for (c = 0; c < ltc->ltc_nr; c++) {
-		for (s = 0; s < ltc->lts_nr; s++)
-			nv_wait(ltc, 0x1410c8 + c * 0x2000 + s * 0x400, ~0, 0);
+		for (s = 0; s < ltc->lts_nr; s++) {
+			const u32 addr = 0x1410c8 + (c * 0x2000) + (s * 0x400);
+			nvkm_msec(device, 2000,
+				if (!nvkm_rd32(device, addr))
+					break;
+			);
+		}
 	}
 }
 

commit 99336ed363f49f484b4d93600c4dfec1f2ebb84a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:09 2015 +1000

    drm/nouveau/ltc: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
index b56e63f507d3..df60ee264b95 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
@@ -30,9 +30,10 @@
 void
 gf100_ltc_cbc_clear(struct nvkm_ltc_priv *ltc, u32 start, u32 limit)
 {
-	nv_wr32(ltc, 0x17e8cc, start);
-	nv_wr32(ltc, 0x17e8d0, limit);
-	nv_wr32(ltc, 0x17e8c8, 0x00000004);
+	struct nvkm_device *device = ltc->base.subdev.device;
+	nvkm_wr32(device, 0x17e8cc, start);
+	nvkm_wr32(device, 0x17e8d0, limit);
+	nvkm_wr32(device, 0x17e8c8, 0x00000004);
 }
 
 void
@@ -48,18 +49,20 @@ gf100_ltc_cbc_wait(struct nvkm_ltc_priv *ltc)
 void
 gf100_ltc_zbc_clear_color(struct nvkm_ltc_priv *ltc, int i, const u32 color[4])
 {
-	nv_mask(ltc, 0x17ea44, 0x0000000f, i);
-	nv_wr32(ltc, 0x17ea48, color[0]);
-	nv_wr32(ltc, 0x17ea4c, color[1]);
-	nv_wr32(ltc, 0x17ea50, color[2]);
-	nv_wr32(ltc, 0x17ea54, color[3]);
+	struct nvkm_device *device = ltc->base.subdev.device;
+	nvkm_mask(device, 0x17ea44, 0x0000000f, i);
+	nvkm_wr32(device, 0x17ea48, color[0]);
+	nvkm_wr32(device, 0x17ea4c, color[1]);
+	nvkm_wr32(device, 0x17ea50, color[2]);
+	nvkm_wr32(device, 0x17ea54, color[3]);
 }
 
 void
 gf100_ltc_zbc_clear_depth(struct nvkm_ltc_priv *ltc, int i, const u32 depth)
 {
-	nv_mask(ltc, 0x17ea44, 0x0000000f, i);
-	nv_wr32(ltc, 0x17ea58, depth);
+	struct nvkm_device *device = ltc->base.subdev.device;
+	nvkm_mask(device, 0x17ea44, 0x0000000f, i);
+	nvkm_wr32(device, 0x17ea58, depth);
 }
 
 static const struct nvkm_bitfield
@@ -83,8 +86,9 @@ gf100_ltc_lts_intr_name[] = {
 static void
 gf100_ltc_lts_intr(struct nvkm_ltc_priv *ltc, int c, int s)
 {
+	struct nvkm_device *device = ltc->base.subdev.device;
 	u32 base = 0x141000 + (c * 0x2000) + (s * 0x400);
-	u32 intr = nv_rd32(ltc, base + 0x020);
+	u32 intr = nvkm_rd32(device, base + 0x020);
 	u32 stat = intr & 0x0000ffff;
 
 	if (stat) {
@@ -93,16 +97,17 @@ gf100_ltc_lts_intr(struct nvkm_ltc_priv *ltc, int c, int s)
 		pr_cont("\n");
 	}
 
-	nv_wr32(ltc, base + 0x020, intr);
+	nvkm_wr32(device, base + 0x020, intr);
 }
 
 void
 gf100_ltc_intr(struct nvkm_subdev *subdev)
 {
 	struct nvkm_ltc_priv *ltc = (void *)subdev;
+	struct nvkm_device *device = ltc->base.subdev.device;
 	u32 mask;
 
-	mask = nv_rd32(ltc, 0x00017c);
+	mask = nvkm_rd32(device, 0x00017c);
 	while (mask) {
 		u32 s, c = __ffs(mask);
 		for (s = 0; s < ltc->lts_nr; s++)
@@ -115,17 +120,18 @@ static int
 gf100_ltc_init(struct nvkm_object *object)
 {
 	struct nvkm_ltc_priv *ltc = (void *)object;
-	u32 lpg128 = !(nv_rd32(ltc, 0x100c80) & 0x00000001);
+	struct nvkm_device *device = ltc->base.subdev.device;
+	u32 lpg128 = !(nvkm_rd32(device, 0x100c80) & 0x00000001);
 	int ret;
 
 	ret = nvkm_ltc_init(ltc);
 	if (ret)
 		return ret;
 
-	nv_mask(ltc, 0x17e820, 0x00100000, 0x00000000); /* INTR_EN &= ~0x10 */
-	nv_wr32(ltc, 0x17e8d8, ltc->ltc_nr);
-	nv_wr32(ltc, 0x17e8d4, ltc->tag_base);
-	nv_mask(ltc, 0x17e8c0, 0x00000002, lpg128 ? 0x00000002 : 0x00000000);
+	nvkm_mask(device, 0x17e820, 0x00100000, 0x00000000); /* INTR_EN &= ~0x10 */
+	nvkm_wr32(device, 0x17e8d8, ltc->ltc_nr);
+	nvkm_wr32(device, 0x17e8d4, ltc->tag_base);
+	nvkm_mask(device, 0x17e8c0, 0x00000002, lpg128 ? 0x00000002 : 0x00000000);
 	return 0;
 }
 
@@ -200,7 +206,8 @@ gf100_ltc_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_oclass *oclass, void *data, u32 size,
 	       struct nvkm_object **pobject)
 {
-	struct nvkm_fb *fb = nvkm_fb(parent);
+	struct nvkm_device *device = (void *)parent;
+	struct nvkm_fb *fb = device->fb;
 	struct nvkm_ltc_priv *ltc;
 	u32 parts, mask;
 	int ret, i;
@@ -210,13 +217,13 @@ gf100_ltc_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	parts = nv_rd32(ltc, 0x022438);
-	mask = nv_rd32(ltc, 0x022554);
+	parts = nvkm_rd32(device, 0x022438);
+	mask = nvkm_rd32(device, 0x022554);
 	for (i = 0; i < parts; i++) {
 		if (!(mask & (1 << i)))
 			ltc->ltc_nr++;
 	}
-	ltc->lts_nr = nv_rd32(ltc, 0x17e8dc) >> 28;
+	ltc->lts_nr = nvkm_rd32(device, 0x17e8dc) >> 28;
 
 	ret = gf100_ltc_init_tag_ram(fb, ltc);
 	if (ret)

commit c7750cfbc150460a507deb27b8eed93fcf60ea8d
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/ltc: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
index a78ae4ea4008..b56e63f507d3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
@@ -28,38 +28,38 @@
 #include <subdev/timer.h>
 
 void
-gf100_ltc_cbc_clear(struct nvkm_ltc_priv *priv, u32 start, u32 limit)
+gf100_ltc_cbc_clear(struct nvkm_ltc_priv *ltc, u32 start, u32 limit)
 {
-	nv_wr32(priv, 0x17e8cc, start);
-	nv_wr32(priv, 0x17e8d0, limit);
-	nv_wr32(priv, 0x17e8c8, 0x00000004);
+	nv_wr32(ltc, 0x17e8cc, start);
+	nv_wr32(ltc, 0x17e8d0, limit);
+	nv_wr32(ltc, 0x17e8c8, 0x00000004);
 }
 
 void
-gf100_ltc_cbc_wait(struct nvkm_ltc_priv *priv)
+gf100_ltc_cbc_wait(struct nvkm_ltc_priv *ltc)
 {
 	int c, s;
-	for (c = 0; c < priv->ltc_nr; c++) {
-		for (s = 0; s < priv->lts_nr; s++)
-			nv_wait(priv, 0x1410c8 + c * 0x2000 + s * 0x400, ~0, 0);
+	for (c = 0; c < ltc->ltc_nr; c++) {
+		for (s = 0; s < ltc->lts_nr; s++)
+			nv_wait(ltc, 0x1410c8 + c * 0x2000 + s * 0x400, ~0, 0);
 	}
 }
 
 void
-gf100_ltc_zbc_clear_color(struct nvkm_ltc_priv *priv, int i, const u32 color[4])
+gf100_ltc_zbc_clear_color(struct nvkm_ltc_priv *ltc, int i, const u32 color[4])
 {
-	nv_mask(priv, 0x17ea44, 0x0000000f, i);
-	nv_wr32(priv, 0x17ea48, color[0]);
-	nv_wr32(priv, 0x17ea4c, color[1]);
-	nv_wr32(priv, 0x17ea50, color[2]);
-	nv_wr32(priv, 0x17ea54, color[3]);
+	nv_mask(ltc, 0x17ea44, 0x0000000f, i);
+	nv_wr32(ltc, 0x17ea48, color[0]);
+	nv_wr32(ltc, 0x17ea4c, color[1]);
+	nv_wr32(ltc, 0x17ea50, color[2]);
+	nv_wr32(ltc, 0x17ea54, color[3]);
 }
 
 void
-gf100_ltc_zbc_clear_depth(struct nvkm_ltc_priv *priv, int i, const u32 depth)
+gf100_ltc_zbc_clear_depth(struct nvkm_ltc_priv *ltc, int i, const u32 depth)
 {
-	nv_mask(priv, 0x17ea44, 0x0000000f, i);
-	nv_wr32(priv, 0x17ea58, depth);
+	nv_mask(ltc, 0x17ea44, 0x0000000f, i);
+	nv_wr32(ltc, 0x17ea58, depth);
 }
 
 static const struct nvkm_bitfield
@@ -81,51 +81,51 @@ gf100_ltc_lts_intr_name[] = {
 };
 
 static void
-gf100_ltc_lts_intr(struct nvkm_ltc_priv *priv, int ltc, int lts)
+gf100_ltc_lts_intr(struct nvkm_ltc_priv *ltc, int c, int s)
 {
-	u32 base = 0x141000 + (ltc * 0x2000) + (lts * 0x400);
-	u32 intr = nv_rd32(priv, base + 0x020);
+	u32 base = 0x141000 + (c * 0x2000) + (s * 0x400);
+	u32 intr = nv_rd32(ltc, base + 0x020);
 	u32 stat = intr & 0x0000ffff;
 
 	if (stat) {
-		nv_info(priv, "LTC%d_LTS%d:", ltc, lts);
+		nv_info(ltc, "LTC%d_LTS%d:", c, s);
 		nvkm_bitfield_print(gf100_ltc_lts_intr_name, stat);
 		pr_cont("\n");
 	}
 
-	nv_wr32(priv, base + 0x020, intr);
+	nv_wr32(ltc, base + 0x020, intr);
 }
 
 void
 gf100_ltc_intr(struct nvkm_subdev *subdev)
 {
-	struct nvkm_ltc_priv *priv = (void *)subdev;
+	struct nvkm_ltc_priv *ltc = (void *)subdev;
 	u32 mask;
 
-	mask = nv_rd32(priv, 0x00017c);
+	mask = nv_rd32(ltc, 0x00017c);
 	while (mask) {
-		u32 lts, ltc = __ffs(mask);
-		for (lts = 0; lts < priv->lts_nr; lts++)
-			gf100_ltc_lts_intr(priv, ltc, lts);
-		mask &= ~(1 << ltc);
+		u32 s, c = __ffs(mask);
+		for (s = 0; s < ltc->lts_nr; s++)
+			gf100_ltc_lts_intr(ltc, c, s);
+		mask &= ~(1 << c);
 	}
 }
 
 static int
 gf100_ltc_init(struct nvkm_object *object)
 {
-	struct nvkm_ltc_priv *priv = (void *)object;
-	u32 lpg128 = !(nv_rd32(priv, 0x100c80) & 0x00000001);
+	struct nvkm_ltc_priv *ltc = (void *)object;
+	u32 lpg128 = !(nv_rd32(ltc, 0x100c80) & 0x00000001);
 	int ret;
 
-	ret = nvkm_ltc_init(priv);
+	ret = nvkm_ltc_init(ltc);
 	if (ret)
 		return ret;
 
-	nv_mask(priv, 0x17e820, 0x00100000, 0x00000000); /* INTR_EN &= ~0x10 */
-	nv_wr32(priv, 0x17e8d8, priv->ltc_nr);
-	nv_wr32(priv, 0x17e8d4, priv->tag_base);
-	nv_mask(priv, 0x17e8c0, 0x00000002, lpg128 ? 0x00000002 : 0x00000000);
+	nv_mask(ltc, 0x17e820, 0x00100000, 0x00000000); /* INTR_EN &= ~0x10 */
+	nv_wr32(ltc, 0x17e8d8, ltc->ltc_nr);
+	nv_wr32(ltc, 0x17e8d4, ltc->tag_base);
+	nv_mask(ltc, 0x17e8c0, 0x00000002, lpg128 ? 0x00000002 : 0x00000000);
 	return 0;
 }
 
@@ -133,36 +133,36 @@ void
 gf100_ltc_dtor(struct nvkm_object *object)
 {
 	struct nvkm_fb *fb = nvkm_fb(object);
-	struct nvkm_ltc_priv *priv = (void *)object;
+	struct nvkm_ltc_priv *ltc = (void *)object;
 
-	nvkm_mm_fini(&priv->tags);
+	nvkm_mm_fini(&ltc->tags);
 	if (fb->ram)
-		nvkm_mm_free(&fb->vram, &priv->tag_ram);
+		nvkm_mm_free(&fb->vram, &ltc->tag_ram);
 
-	nvkm_ltc_destroy(priv);
+	nvkm_ltc_destroy(ltc);
 }
 
 /* TODO: Figure out tag memory details and drop the over-cautious allocation.
  */
 int
-gf100_ltc_init_tag_ram(struct nvkm_fb *fb, struct nvkm_ltc_priv *priv)
+gf100_ltc_init_tag_ram(struct nvkm_fb *fb, struct nvkm_ltc_priv *ltc)
 {
 	u32 tag_size, tag_margin, tag_align;
 	int ret;
 
 	/* No VRAM, no tags for now. */
 	if (!fb->ram) {
-		priv->num_tags = 0;
+		ltc->num_tags = 0;
 		goto mm_init;
 	}
 
 	/* tags for 1/4 of VRAM should be enough (8192/4 per GiB of VRAM) */
-	priv->num_tags = (fb->ram->size >> 17) / 4;
-	if (priv->num_tags > (1 << 17))
-		priv->num_tags = 1 << 17; /* we have 17 bits in PTE */
-	priv->num_tags = (priv->num_tags + 63) & ~63; /* round up to 64 */
+	ltc->num_tags = (fb->ram->size >> 17) / 4;
+	if (ltc->num_tags > (1 << 17))
+		ltc->num_tags = 1 << 17; /* we have 17 bits in PTE */
+	ltc->num_tags = (ltc->num_tags + 63) & ~63; /* round up to 64 */
 
-	tag_align = priv->ltc_nr * 0x800;
+	tag_align = ltc->ltc_nr * 0x800;
 	tag_margin = (tag_align < 0x6000) ? 0x6000 : tag_align;
 
 	/* 4 part 4 sub: 0x2000 bytes for 56 tags */
@@ -173,25 +173,25 @@ gf100_ltc_init_tag_ram(struct nvkm_fb *fb, struct nvkm_ltc_priv *priv)
 	 *
 	 * For 4 GiB of memory we'll have 8192 tags which makes 3 MiB, < 0.1 %.
 	 */
-	tag_size  = (priv->num_tags / 64) * 0x6000 + tag_margin;
+	tag_size  = (ltc->num_tags / 64) * 0x6000 + tag_margin;
 	tag_size += tag_align;
 	tag_size  = (tag_size + 0xfff) >> 12; /* round up */
 
 	ret = nvkm_mm_tail(&fb->vram, 1, 1, tag_size, tag_size, 1,
-			   &priv->tag_ram);
+			   &ltc->tag_ram);
 	if (ret) {
-		priv->num_tags = 0;
+		ltc->num_tags = 0;
 	} else {
-		u64 tag_base = ((u64)priv->tag_ram->offset << 12) + tag_margin;
+		u64 tag_base = ((u64)ltc->tag_ram->offset << 12) + tag_margin;
 
 		tag_base += tag_align - 1;
-		ret = do_div(tag_base, tag_align);
+		do_div(tag_base, tag_align);
 
-		priv->tag_base = tag_base;
+		ltc->tag_base = tag_base;
 	}
 
 mm_init:
-	ret = nvkm_mm_init(&priv->tags, 0, priv->num_tags, 1);
+	ret = nvkm_mm_init(&ltc->tags, 0, ltc->num_tags, 1);
 	return ret;
 }
 
@@ -201,28 +201,28 @@ gf100_ltc_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_object **pobject)
 {
 	struct nvkm_fb *fb = nvkm_fb(parent);
-	struct nvkm_ltc_priv *priv;
+	struct nvkm_ltc_priv *ltc;
 	u32 parts, mask;
 	int ret, i;
 
-	ret = nvkm_ltc_create(parent, engine, oclass, &priv);
-	*pobject = nv_object(priv);
+	ret = nvkm_ltc_create(parent, engine, oclass, &ltc);
+	*pobject = nv_object(ltc);
 	if (ret)
 		return ret;
 
-	parts = nv_rd32(priv, 0x022438);
-	mask = nv_rd32(priv, 0x022554);
+	parts = nv_rd32(ltc, 0x022438);
+	mask = nv_rd32(ltc, 0x022554);
 	for (i = 0; i < parts; i++) {
 		if (!(mask & (1 << i)))
-			priv->ltc_nr++;
+			ltc->ltc_nr++;
 	}
-	priv->lts_nr = nv_rd32(priv, 0x17e8dc) >> 28;
+	ltc->lts_nr = nv_rd32(ltc, 0x17e8dc) >> 28;
 
-	ret = gf100_ltc_init_tag_ram(fb, priv);
+	ret = gf100_ltc_init_tag_ram(fb, ltc);
 	if (ret)
 		return ret;
 
-	nv_subdev(priv)->intr = gf100_ltc_intr;
+	nv_subdev(ltc)->intr = gf100_ltc_intr;
 	return 0;
 }
 

commit b1e4553cb1f9deddbd8c13d95e9cef81967a3f41
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/fb: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
index 7fb5ea0314cb..a78ae4ea4008 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
@@ -132,12 +132,12 @@ gf100_ltc_init(struct nvkm_object *object)
 void
 gf100_ltc_dtor(struct nvkm_object *object)
 {
-	struct nvkm_fb *pfb = nvkm_fb(object);
+	struct nvkm_fb *fb = nvkm_fb(object);
 	struct nvkm_ltc_priv *priv = (void *)object;
 
 	nvkm_mm_fini(&priv->tags);
-	if (pfb->ram)
-		nvkm_mm_free(&pfb->vram, &priv->tag_ram);
+	if (fb->ram)
+		nvkm_mm_free(&fb->vram, &priv->tag_ram);
 
 	nvkm_ltc_destroy(priv);
 }
@@ -145,19 +145,19 @@ gf100_ltc_dtor(struct nvkm_object *object)
 /* TODO: Figure out tag memory details and drop the over-cautious allocation.
  */
 int
-gf100_ltc_init_tag_ram(struct nvkm_fb *pfb, struct nvkm_ltc_priv *priv)
+gf100_ltc_init_tag_ram(struct nvkm_fb *fb, struct nvkm_ltc_priv *priv)
 {
 	u32 tag_size, tag_margin, tag_align;
 	int ret;
 
 	/* No VRAM, no tags for now. */
-	if (!pfb->ram) {
+	if (!fb->ram) {
 		priv->num_tags = 0;
 		goto mm_init;
 	}
 
 	/* tags for 1/4 of VRAM should be enough (8192/4 per GiB of VRAM) */
-	priv->num_tags = (pfb->ram->size >> 17) / 4;
+	priv->num_tags = (fb->ram->size >> 17) / 4;
 	if (priv->num_tags > (1 << 17))
 		priv->num_tags = 1 << 17; /* we have 17 bits in PTE */
 	priv->num_tags = (priv->num_tags + 63) & ~63; /* round up to 64 */
@@ -177,7 +177,7 @@ gf100_ltc_init_tag_ram(struct nvkm_fb *pfb, struct nvkm_ltc_priv *priv)
 	tag_size += tag_align;
 	tag_size  = (tag_size + 0xfff) >> 12; /* round up */
 
-	ret = nvkm_mm_tail(&pfb->vram, 1, 1, tag_size, tag_size, 1,
+	ret = nvkm_mm_tail(&fb->vram, 1, 1, tag_size, tag_size, 1,
 			   &priv->tag_ram);
 	if (ret) {
 		priv->num_tags = 0;
@@ -200,7 +200,7 @@ gf100_ltc_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_oclass *oclass, void *data, u32 size,
 	       struct nvkm_object **pobject)
 {
-	struct nvkm_fb *pfb = nvkm_fb(parent);
+	struct nvkm_fb *fb = nvkm_fb(parent);
 	struct nvkm_ltc_priv *priv;
 	u32 parts, mask;
 	int ret, i;
@@ -218,7 +218,7 @@ gf100_ltc_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	}
 	priv->lts_nr = nv_rd32(priv, 0x17e8dc) >> 28;
 
-	ret = gf100_ltc_init_tag_ram(pfb, priv);
+	ret = gf100_ltc_init_tag_ram(fb, priv);
 	if (ret)
 		return ret;
 

commit eaecf0326f096faaba462eae48a3b30bcb1f7009
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Fri Feb 20 18:22:59 2015 +0900

    make RAM device optional
    
    Having a RAM device does not make sense for chips like GK20A which have
    no dedicated video memory. The dummy RAM device that we used so far
    works as a temporary band-aid, but in the longer term it is desirable
    for the driver to be able to work without any kind of VRAM.
    
    This patch adds a few conditionals in places where a RAM device was
    assumed to be present and allows some more objects to be allocated from
    the TT domain, allowing Nouveau to handle GPUs for which
    pfb->ram == NULL.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
index 8e7cc6200d60..7fb5ea0314cb 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
@@ -136,7 +136,8 @@ gf100_ltc_dtor(struct nvkm_object *object)
 	struct nvkm_ltc_priv *priv = (void *)object;
 
 	nvkm_mm_fini(&priv->tags);
-	nvkm_mm_free(&pfb->vram, &priv->tag_ram);
+	if (pfb->ram)
+		nvkm_mm_free(&pfb->vram, &priv->tag_ram);
 
 	nvkm_ltc_destroy(priv);
 }
@@ -149,6 +150,12 @@ gf100_ltc_init_tag_ram(struct nvkm_fb *pfb, struct nvkm_ltc_priv *priv)
 	u32 tag_size, tag_margin, tag_align;
 	int ret;
 
+	/* No VRAM, no tags for now. */
+	if (!pfb->ram) {
+		priv->num_tags = 0;
+		goto mm_init;
+	}
+
 	/* tags for 1/4 of VRAM should be enough (8192/4 per GiB of VRAM) */
 	priv->num_tags = (pfb->ram->size >> 17) / 4;
 	if (priv->num_tags > (1 << 17))
@@ -183,6 +190,7 @@ gf100_ltc_init_tag_ram(struct nvkm_fb *pfb, struct nvkm_ltc_priv *priv)
 		priv->tag_base = tag_base;
 	}
 
+mm_init:
 	ret = nvkm_mm_init(&priv->tags, 0, priv->num_tags, 1);
 	return ret;
 }

commit 2799bba69a1caf54889035ed63247d09c4a2fc84
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:06:26 2015 +1000

    drm/nouveau/ltc: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
index 2db0977284f8..8e7cc6200d60 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
@@ -21,12 +21,12 @@
  *
  * Authors: Ben Skeggs
  */
+#include "priv.h"
 
+#include <core/enum.h>
 #include <subdev/fb.h>
 #include <subdev/timer.h>
 
-#include "priv.h"
-
 void
 gf100_ltc_cbc_clear(struct nvkm_ltc_priv *priv, u32 start, u32 limit)
 {
@@ -62,7 +62,7 @@ gf100_ltc_zbc_clear_depth(struct nvkm_ltc_priv *priv, int i, const u32 depth)
 	nv_wr32(priv, 0x17ea58, depth);
 }
 
-static const struct nouveau_bitfield
+static const struct nvkm_bitfield
 gf100_ltc_lts_intr_name[] = {
 	{ 0x00000001, "IDLE_ERROR_IQ" },
 	{ 0x00000002, "IDLE_ERROR_CBC" },
@@ -89,7 +89,7 @@ gf100_ltc_lts_intr(struct nvkm_ltc_priv *priv, int ltc, int lts)
 
 	if (stat) {
 		nv_info(priv, "LTC%d_LTS%d:", ltc, lts);
-		nouveau_bitfield_print(gf100_ltc_lts_intr_name, stat);
+		nvkm_bitfield_print(gf100_ltc_lts_intr_name, stat);
 		pr_cont("\n");
 	}
 
@@ -97,7 +97,7 @@ gf100_ltc_lts_intr(struct nvkm_ltc_priv *priv, int ltc, int lts)
 }
 
 void
-gf100_ltc_intr(struct nouveau_subdev *subdev)
+gf100_ltc_intr(struct nvkm_subdev *subdev)
 {
 	struct nvkm_ltc_priv *priv = (void *)subdev;
 	u32 mask;
@@ -112,7 +112,7 @@ gf100_ltc_intr(struct nouveau_subdev *subdev)
 }
 
 static int
-gf100_ltc_init(struct nouveau_object *object)
+gf100_ltc_init(struct nvkm_object *object)
 {
 	struct nvkm_ltc_priv *priv = (void *)object;
 	u32 lpg128 = !(nv_rd32(priv, 0x100c80) & 0x00000001);
@@ -130,13 +130,13 @@ gf100_ltc_init(struct nouveau_object *object)
 }
 
 void
-gf100_ltc_dtor(struct nouveau_object *object)
+gf100_ltc_dtor(struct nvkm_object *object)
 {
-	struct nouveau_fb *pfb = nouveau_fb(object);
+	struct nvkm_fb *pfb = nvkm_fb(object);
 	struct nvkm_ltc_priv *priv = (void *)object;
 
-	nouveau_mm_fini(&priv->tags);
-	nouveau_mm_free(&pfb->vram, &priv->tag_ram);
+	nvkm_mm_fini(&priv->tags);
+	nvkm_mm_free(&pfb->vram, &priv->tag_ram);
 
 	nvkm_ltc_destroy(priv);
 }
@@ -144,7 +144,7 @@ gf100_ltc_dtor(struct nouveau_object *object)
 /* TODO: Figure out tag memory details and drop the over-cautious allocation.
  */
 int
-gf100_ltc_init_tag_ram(struct nouveau_fb *pfb, struct nvkm_ltc_priv *priv)
+gf100_ltc_init_tag_ram(struct nvkm_fb *pfb, struct nvkm_ltc_priv *priv)
 {
 	u32 tag_size, tag_margin, tag_align;
 	int ret;
@@ -170,8 +170,8 @@ gf100_ltc_init_tag_ram(struct nouveau_fb *pfb, struct nvkm_ltc_priv *priv)
 	tag_size += tag_align;
 	tag_size  = (tag_size + 0xfff) >> 12; /* round up */
 
-	ret = nouveau_mm_tail(&pfb->vram, 1, 1, tag_size, tag_size, 1,
-	                      &priv->tag_ram);
+	ret = nvkm_mm_tail(&pfb->vram, 1, 1, tag_size, tag_size, 1,
+			   &priv->tag_ram);
 	if (ret) {
 		priv->num_tags = 0;
 	} else {
@@ -183,16 +183,16 @@ gf100_ltc_init_tag_ram(struct nouveau_fb *pfb, struct nvkm_ltc_priv *priv)
 		priv->tag_base = tag_base;
 	}
 
-	ret = nouveau_mm_init(&priv->tags, 0, priv->num_tags, 1);
+	ret = nvkm_mm_init(&priv->tags, 0, priv->num_tags, 1);
 	return ret;
 }
 
 int
-gf100_ltc_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
-	       struct nouveau_oclass *oclass, void *data, u32 size,
-	       struct nouveau_object **pobject)
+gf100_ltc_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+	       struct nvkm_oclass *oclass, void *data, u32 size,
+	       struct nvkm_object **pobject)
 {
-	struct nouveau_fb *pfb = nouveau_fb(parent);
+	struct nvkm_fb *pfb = nvkm_fb(parent);
 	struct nvkm_ltc_priv *priv;
 	u32 parts, mask;
 	int ret, i;
@@ -218,10 +218,10 @@ gf100_ltc_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	return 0;
 }
 
-struct nouveau_oclass *
+struct nvkm_oclass *
 gf100_ltc_oclass = &(struct nvkm_ltc_impl) {
 	.base.handle = NV_SUBDEV(LTC, 0xc0),
-	.base.ofuncs = &(struct nouveau_ofuncs) {
+	.base.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = gf100_ltc_ctor,
 		.dtor = gf100_ltc_dtor,
 		.init = gf100_ltc_init,

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
new file mode 100644
index 000000000000..2db0977284f8
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c
@@ -0,0 +1,236 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <subdev/fb.h>
+#include <subdev/timer.h>
+
+#include "priv.h"
+
+void
+gf100_ltc_cbc_clear(struct nvkm_ltc_priv *priv, u32 start, u32 limit)
+{
+	nv_wr32(priv, 0x17e8cc, start);
+	nv_wr32(priv, 0x17e8d0, limit);
+	nv_wr32(priv, 0x17e8c8, 0x00000004);
+}
+
+void
+gf100_ltc_cbc_wait(struct nvkm_ltc_priv *priv)
+{
+	int c, s;
+	for (c = 0; c < priv->ltc_nr; c++) {
+		for (s = 0; s < priv->lts_nr; s++)
+			nv_wait(priv, 0x1410c8 + c * 0x2000 + s * 0x400, ~0, 0);
+	}
+}
+
+void
+gf100_ltc_zbc_clear_color(struct nvkm_ltc_priv *priv, int i, const u32 color[4])
+{
+	nv_mask(priv, 0x17ea44, 0x0000000f, i);
+	nv_wr32(priv, 0x17ea48, color[0]);
+	nv_wr32(priv, 0x17ea4c, color[1]);
+	nv_wr32(priv, 0x17ea50, color[2]);
+	nv_wr32(priv, 0x17ea54, color[3]);
+}
+
+void
+gf100_ltc_zbc_clear_depth(struct nvkm_ltc_priv *priv, int i, const u32 depth)
+{
+	nv_mask(priv, 0x17ea44, 0x0000000f, i);
+	nv_wr32(priv, 0x17ea58, depth);
+}
+
+static const struct nouveau_bitfield
+gf100_ltc_lts_intr_name[] = {
+	{ 0x00000001, "IDLE_ERROR_IQ" },
+	{ 0x00000002, "IDLE_ERROR_CBC" },
+	{ 0x00000004, "IDLE_ERROR_TSTG" },
+	{ 0x00000008, "IDLE_ERROR_DSTG" },
+	{ 0x00000010, "EVICTED_CB" },
+	{ 0x00000020, "ILLEGAL_COMPSTAT" },
+	{ 0x00000040, "BLOCKLINEAR_CB" },
+	{ 0x00000100, "ECC_SEC_ERROR" },
+	{ 0x00000200, "ECC_DED_ERROR" },
+	{ 0x00000400, "DEBUG" },
+	{ 0x00000800, "ATOMIC_TO_Z" },
+	{ 0x00001000, "ILLEGAL_ATOMIC" },
+	{ 0x00002000, "BLKACTIVITY_ERR" },
+	{}
+};
+
+static void
+gf100_ltc_lts_intr(struct nvkm_ltc_priv *priv, int ltc, int lts)
+{
+	u32 base = 0x141000 + (ltc * 0x2000) + (lts * 0x400);
+	u32 intr = nv_rd32(priv, base + 0x020);
+	u32 stat = intr & 0x0000ffff;
+
+	if (stat) {
+		nv_info(priv, "LTC%d_LTS%d:", ltc, lts);
+		nouveau_bitfield_print(gf100_ltc_lts_intr_name, stat);
+		pr_cont("\n");
+	}
+
+	nv_wr32(priv, base + 0x020, intr);
+}
+
+void
+gf100_ltc_intr(struct nouveau_subdev *subdev)
+{
+	struct nvkm_ltc_priv *priv = (void *)subdev;
+	u32 mask;
+
+	mask = nv_rd32(priv, 0x00017c);
+	while (mask) {
+		u32 lts, ltc = __ffs(mask);
+		for (lts = 0; lts < priv->lts_nr; lts++)
+			gf100_ltc_lts_intr(priv, ltc, lts);
+		mask &= ~(1 << ltc);
+	}
+}
+
+static int
+gf100_ltc_init(struct nouveau_object *object)
+{
+	struct nvkm_ltc_priv *priv = (void *)object;
+	u32 lpg128 = !(nv_rd32(priv, 0x100c80) & 0x00000001);
+	int ret;
+
+	ret = nvkm_ltc_init(priv);
+	if (ret)
+		return ret;
+
+	nv_mask(priv, 0x17e820, 0x00100000, 0x00000000); /* INTR_EN &= ~0x10 */
+	nv_wr32(priv, 0x17e8d8, priv->ltc_nr);
+	nv_wr32(priv, 0x17e8d4, priv->tag_base);
+	nv_mask(priv, 0x17e8c0, 0x00000002, lpg128 ? 0x00000002 : 0x00000000);
+	return 0;
+}
+
+void
+gf100_ltc_dtor(struct nouveau_object *object)
+{
+	struct nouveau_fb *pfb = nouveau_fb(object);
+	struct nvkm_ltc_priv *priv = (void *)object;
+
+	nouveau_mm_fini(&priv->tags);
+	nouveau_mm_free(&pfb->vram, &priv->tag_ram);
+
+	nvkm_ltc_destroy(priv);
+}
+
+/* TODO: Figure out tag memory details and drop the over-cautious allocation.
+ */
+int
+gf100_ltc_init_tag_ram(struct nouveau_fb *pfb, struct nvkm_ltc_priv *priv)
+{
+	u32 tag_size, tag_margin, tag_align;
+	int ret;
+
+	/* tags for 1/4 of VRAM should be enough (8192/4 per GiB of VRAM) */
+	priv->num_tags = (pfb->ram->size >> 17) / 4;
+	if (priv->num_tags > (1 << 17))
+		priv->num_tags = 1 << 17; /* we have 17 bits in PTE */
+	priv->num_tags = (priv->num_tags + 63) & ~63; /* round up to 64 */
+
+	tag_align = priv->ltc_nr * 0x800;
+	tag_margin = (tag_align < 0x6000) ? 0x6000 : tag_align;
+
+	/* 4 part 4 sub: 0x2000 bytes for 56 tags */
+	/* 3 part 4 sub: 0x6000 bytes for 168 tags */
+	/*
+	 * About 147 bytes per tag. Let's be safe and allocate x2, which makes
+	 * 0x4980 bytes for 64 tags, and round up to 0x6000 bytes for 64 tags.
+	 *
+	 * For 4 GiB of memory we'll have 8192 tags which makes 3 MiB, < 0.1 %.
+	 */
+	tag_size  = (priv->num_tags / 64) * 0x6000 + tag_margin;
+	tag_size += tag_align;
+	tag_size  = (tag_size + 0xfff) >> 12; /* round up */
+
+	ret = nouveau_mm_tail(&pfb->vram, 1, 1, tag_size, tag_size, 1,
+	                      &priv->tag_ram);
+	if (ret) {
+		priv->num_tags = 0;
+	} else {
+		u64 tag_base = ((u64)priv->tag_ram->offset << 12) + tag_margin;
+
+		tag_base += tag_align - 1;
+		ret = do_div(tag_base, tag_align);
+
+		priv->tag_base = tag_base;
+	}
+
+	ret = nouveau_mm_init(&priv->tags, 0, priv->num_tags, 1);
+	return ret;
+}
+
+int
+gf100_ltc_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+	       struct nouveau_oclass *oclass, void *data, u32 size,
+	       struct nouveau_object **pobject)
+{
+	struct nouveau_fb *pfb = nouveau_fb(parent);
+	struct nvkm_ltc_priv *priv;
+	u32 parts, mask;
+	int ret, i;
+
+	ret = nvkm_ltc_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	parts = nv_rd32(priv, 0x022438);
+	mask = nv_rd32(priv, 0x022554);
+	for (i = 0; i < parts; i++) {
+		if (!(mask & (1 << i)))
+			priv->ltc_nr++;
+	}
+	priv->lts_nr = nv_rd32(priv, 0x17e8dc) >> 28;
+
+	ret = gf100_ltc_init_tag_ram(pfb, priv);
+	if (ret)
+		return ret;
+
+	nv_subdev(priv)->intr = gf100_ltc_intr;
+	return 0;
+}
+
+struct nouveau_oclass *
+gf100_ltc_oclass = &(struct nvkm_ltc_impl) {
+	.base.handle = NV_SUBDEV(LTC, 0xc0),
+	.base.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = gf100_ltc_ctor,
+		.dtor = gf100_ltc_dtor,
+		.init = gf100_ltc_init,
+		.fini = _nvkm_ltc_fini,
+	},
+	.intr = gf100_ltc_intr,
+	.cbc_clear = gf100_ltc_cbc_clear,
+	.cbc_wait = gf100_ltc_cbc_wait,
+	.zbc = 16,
+	.zbc_clear_color = gf100_ltc_zbc_clear_color,
+	.zbc_clear_depth = gf100_ltc_zbc_clear_depth,
+}.base;
