commit 4b2c71edf0d7832ef4d2fe5b17402d1130b415dc
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:47 2018 +1000

    drm/nouveau/gr/gp102-: setup stencil zbc
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
index 1f185274d3e6..23242179e600 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
@@ -55,6 +55,14 @@ nvkm_ltc_zbc_depth_get(struct nvkm_ltc *ltc, int index, const u32 depth)
 	return index;
 }
 
+int
+nvkm_ltc_zbc_stencil_get(struct nvkm_ltc *ltc, int index, const u32 stencil)
+{
+	ltc->zbc_stencil[index] = stencil;
+	ltc->func->zbc_clear_stencil(ltc, index, stencil);
+	return index;
+}
+
 void
 nvkm_ltc_invalidate(struct nvkm_ltc *ltc)
 {
@@ -92,6 +100,8 @@ nvkm_ltc_init(struct nvkm_subdev *subdev)
 	for (i = ltc->zbc_min; i <= ltc->zbc_max; i++) {
 		ltc->func->zbc_clear_color(ltc, i, ltc->zbc_color[i]);
 		ltc->func->zbc_clear_depth(ltc, i, ltc->zbc_depth[i]);
+		if (ltc->func->zbc_clear_stencil)
+			ltc->func->zbc_clear_stencil(ltc, i, ltc->zbc_stencil[i]);
 	}
 
 	ltc->func->init(ltc);

commit 7b8656636add64ea5c184a5de4a326d33a1d021e
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau: directly handle comptag allocation
    
    Another transition step to allow finer-grained patches transitioning to
    new MMU backends.
    
    Old backends will continue operate as before (accessing nvkm_mem::tag),
    and new backends will get a reference to the tags allocated here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
index 3bb97b171435..1f185274d3e6 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
@@ -24,24 +24,6 @@
 #include "priv.h"
 
 #include <core/memory.h>
-#include <subdev/fb.h>
-
-int
-nvkm_ltc_tags_alloc(struct nvkm_ltc *ltc, u32 n, struct nvkm_mm_node **pnode)
-{
-	struct nvkm_fb *fb = ltc->subdev.device->fb;
-	int ret = nvkm_mm_head(&fb->tags, 0, 1, n, n, 1, pnode);
-	if (ret)
-		*pnode = NULL;
-	return ret;
-}
-
-void
-nvkm_ltc_tags_free(struct nvkm_ltc *ltc, struct nvkm_mm_node **pnode)
-{
-	struct nvkm_fb *fb = ltc->subdev.device->fb;
-	nvkm_mm_free(&fb->tags, pnode);
-}
 
 void
 nvkm_ltc_tags_clear(struct nvkm_device *device, u32 first, u32 count)

commit bd447053b33d9c2a173e1d3953c95a7cd5182656
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/ltc/gf100-: allocate tagram with nvkm_ram_get()
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
index f4aa81dd8978..3bb97b171435 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
@@ -23,6 +23,7 @@
  */
 #include "priv.h"
 
+#include <core/memory.h>
 #include <subdev/fb.h>
 
 int
@@ -119,9 +120,7 @@ static void *
 nvkm_ltc_dtor(struct nvkm_subdev *subdev)
 {
 	struct nvkm_ltc *ltc = nvkm_ltc(subdev);
-	struct nvkm_ram *ram = ltc->subdev.device->fb->ram;
-	if (ram)
-		nvkm_mm_free(&ram->vram, &ltc->tag_ram);
+	nvkm_memory_unref(&ltc->tag_ram);
 	return ltc;
 }
 

commit 6cd7670c1e2a4a70a3d421521aea548e68992621
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/ltc: init comptag mm in fb subdev
    
    A single location for the MM allows us to share allocation logic.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
index a75320943187..f4aa81dd8978 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
@@ -28,7 +28,8 @@
 int
 nvkm_ltc_tags_alloc(struct nvkm_ltc *ltc, u32 n, struct nvkm_mm_node **pnode)
 {
-	int ret = nvkm_mm_head(&ltc->tags, 0, 1, n, n, 1, pnode);
+	struct nvkm_fb *fb = ltc->subdev.device->fb;
+	int ret = nvkm_mm_head(&fb->tags, 0, 1, n, n, 1, pnode);
 	if (ret)
 		*pnode = NULL;
 	return ret;
@@ -37,7 +38,8 @@ nvkm_ltc_tags_alloc(struct nvkm_ltc *ltc, u32 n, struct nvkm_mm_node **pnode)
 void
 nvkm_ltc_tags_free(struct nvkm_ltc *ltc, struct nvkm_mm_node **pnode)
 {
-	nvkm_mm_free(&ltc->tags, pnode);
+	struct nvkm_fb *fb = ltc->subdev.device->fb;
+	nvkm_mm_free(&fb->tags, pnode);
 }
 
 void
@@ -118,7 +120,6 @@ nvkm_ltc_dtor(struct nvkm_subdev *subdev)
 {
 	struct nvkm_ltc *ltc = nvkm_ltc(subdev);
 	struct nvkm_ram *ram = ltc->subdev.device->fb->ram;
-	nvkm_mm_fini(&ltc->tags);
 	if (ram)
 		nvkm_mm_free(&ram->vram, &ltc->tag_ram);
 	return ltc;

commit b1e839f3b3d82a0774c296f9950214057b045b72
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/fb/gf100: clear comptags at allocation time rather than mmu map
    
    We probably don't want to destroy compression data when doing multiple
    mappings of a memory object.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
index 0c7ef250dcaf..a75320943187 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
@@ -41,8 +41,9 @@ nvkm_ltc_tags_free(struct nvkm_ltc *ltc, struct nvkm_mm_node **pnode)
 }
 
 void
-nvkm_ltc_tags_clear(struct nvkm_ltc *ltc, u32 first, u32 count)
+nvkm_ltc_tags_clear(struct nvkm_device *device, u32 first, u32 count)
 {
+	struct nvkm_ltc *ltc = device->ltc;
 	const u32 limit = first + count - 1;
 
 	BUG_ON((first > limit) || (limit >= ltc->num_tags));

commit f4e65efc88b64c1dbca275d42a188edccedb56c6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Dec 13 09:29:55 2016 +1000

    drm/nouveau/ltc: protect clearing of comptags with mutex
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
index 39c2a38e54f7..0c7ef250dcaf 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
@@ -47,8 +47,10 @@ nvkm_ltc_tags_clear(struct nvkm_ltc *ltc, u32 first, u32 count)
 
 	BUG_ON((first > limit) || (limit >= ltc->num_tags));
 
+	mutex_lock(&ltc->subdev.mutex);
 	ltc->func->cbc_clear(ltc, first, limit);
 	ltc->func->cbc_wait(ltc);
+	mutex_unlock(&ltc->subdev.mutex);
 }
 
 int

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
index 85b1464c0194..39c2a38e54f7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
@@ -138,7 +138,7 @@ nvkm_ltc_new_(const struct nvkm_ltc_func *func, struct nvkm_device *device,
 	if (!(ltc = *pltc = kzalloc(sizeof(*ltc), GFP_KERNEL)))
 		return -ENOMEM;
 
-	nvkm_subdev_ctor(&nvkm_ltc, device, index, 0, &ltc->subdev);
+	nvkm_subdev_ctor(&nvkm_ltc, device, index, &ltc->subdev);
 	ltc->func = func;
 	ltc->zbc_min = 1; /* reserve 0 for disabled */
 	ltc->zbc_max = min(func->zbc, NVKM_LTC_MAX_ZBC_CNT) - 1;

commit 38a8fc78d00749328888bb0e37ad93535e7e9992
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Thu Sep 3 17:48:14 2015 +0900

    drm/nouveau/ltc: add hooks for invalidate and flush
    
    These are useful for systems without a coherent CPU/GPU bus. For such
    systems we may need to maintain the L2 ourselves.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
index 930d25b6e63c..85b1464c0194 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
@@ -67,6 +67,20 @@ nvkm_ltc_zbc_depth_get(struct nvkm_ltc *ltc, int index, const u32 depth)
 	return index;
 }
 
+void
+nvkm_ltc_invalidate(struct nvkm_ltc *ltc)
+{
+	if (ltc->func->invalidate)
+		ltc->func->invalidate(ltc);
+}
+
+void
+nvkm_ltc_flush(struct nvkm_ltc *ltc)
+{
+	if (ltc->func->flush)
+		ltc->func->flush(ltc);
+}
+
 static void
 nvkm_ltc_intr(struct nvkm_subdev *subdev)
 {

commit 70bc7182cbf1bb07e414bbb553890ddf1b540264
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:21 2015 +1000

    drm/nouveau/ltc: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
index d0af1aec0fc6..930d25b6e63c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
@@ -23,102 +23,110 @@
  */
 #include "priv.h"
 
-static int
-nvkm_ltc_tags_alloc(struct nvkm_ltc *obj, u32 n, struct nvkm_mm_node **pnode)
-{
-	struct nvkm_ltc_priv *ltc = container_of(obj, typeof(*ltc), base);
-	int ret;
+#include <subdev/fb.h>
 
-	ret = nvkm_mm_head(&ltc->tags, 0, 1, n, n, 1, pnode);
+int
+nvkm_ltc_tags_alloc(struct nvkm_ltc *ltc, u32 n, struct nvkm_mm_node **pnode)
+{
+	int ret = nvkm_mm_head(&ltc->tags, 0, 1, n, n, 1, pnode);
 	if (ret)
 		*pnode = NULL;
-
 	return ret;
 }
 
-static void
-nvkm_ltc_tags_free(struct nvkm_ltc *obj, struct nvkm_mm_node **pnode)
+void
+nvkm_ltc_tags_free(struct nvkm_ltc *ltc, struct nvkm_mm_node **pnode)
 {
-	struct nvkm_ltc_priv *ltc = container_of(obj, typeof(*ltc), base);
 	nvkm_mm_free(&ltc->tags, pnode);
 }
 
-static void
-nvkm_ltc_tags_clear(struct nvkm_ltc *obj, u32 first, u32 count)
+void
+nvkm_ltc_tags_clear(struct nvkm_ltc *ltc, u32 first, u32 count)
 {
-	struct nvkm_ltc_priv *ltc = container_of(obj, typeof(*ltc), base);
-	const struct nvkm_ltc_impl *impl = (void *)nv_oclass(ltc);
 	const u32 limit = first + count - 1;
 
 	BUG_ON((first > limit) || (limit >= ltc->num_tags));
 
-	impl->cbc_clear(ltc, first, limit);
-	impl->cbc_wait(ltc);
+	ltc->func->cbc_clear(ltc, first, limit);
+	ltc->func->cbc_wait(ltc);
 }
 
-static int
-nvkm_ltc_zbc_color_get(struct nvkm_ltc *obj, int index, const u32 color[4])
+int
+nvkm_ltc_zbc_color_get(struct nvkm_ltc *ltc, int index, const u32 color[4])
 {
-	struct nvkm_ltc_priv *ltc = container_of(obj, typeof(*ltc), base);
-	const struct nvkm_ltc_impl *impl = (void *)nv_oclass(ltc);
 	memcpy(ltc->zbc_color[index], color, sizeof(ltc->zbc_color[index]));
-	impl->zbc_clear_color(ltc, index, color);
+	ltc->func->zbc_clear_color(ltc, index, color);
 	return index;
 }
 
-static int
-nvkm_ltc_zbc_depth_get(struct nvkm_ltc *obj, int index, const u32 depth)
+int
+nvkm_ltc_zbc_depth_get(struct nvkm_ltc *ltc, int index, const u32 depth)
 {
-	struct nvkm_ltc_priv *ltc = container_of(obj, typeof(*ltc), base);
-	const struct nvkm_ltc_impl *impl = (void *)nv_oclass(ltc);
 	ltc->zbc_depth[index] = depth;
-	impl->zbc_clear_depth(ltc, index, depth);
+	ltc->func->zbc_clear_depth(ltc, index, depth);
 	return index;
 }
 
-int
-_nvkm_ltc_init(struct nvkm_object *object)
+static void
+nvkm_ltc_intr(struct nvkm_subdev *subdev)
 {
-	struct nvkm_ltc_priv *ltc = (void *)object;
-	const struct nvkm_ltc_impl *impl = (void *)nv_oclass(object);
-	int ret, i;
+	struct nvkm_ltc *ltc = nvkm_ltc(subdev);
+	ltc->func->intr(ltc);
+}
 
-	ret = nvkm_subdev_init_old(&ltc->base.subdev);
-	if (ret)
-		return ret;
+static int
+nvkm_ltc_oneinit(struct nvkm_subdev *subdev)
+{
+	struct nvkm_ltc *ltc = nvkm_ltc(subdev);
+	return ltc->func->oneinit(ltc);
+}
+
+static int
+nvkm_ltc_init(struct nvkm_subdev *subdev)
+{
+	struct nvkm_ltc *ltc = nvkm_ltc(subdev);
+	int i;
 
-	for (i = ltc->base.zbc_min; i <= ltc->base.zbc_max; i++) {
-		impl->zbc_clear_color(ltc, i, ltc->zbc_color[i]);
-		impl->zbc_clear_depth(ltc, i, ltc->zbc_depth[i]);
+	for (i = ltc->zbc_min; i <= ltc->zbc_max; i++) {
+		ltc->func->zbc_clear_color(ltc, i, ltc->zbc_color[i]);
+		ltc->func->zbc_clear_depth(ltc, i, ltc->zbc_depth[i]);
 	}
 
+	ltc->func->init(ltc);
 	return 0;
 }
 
+static void *
+nvkm_ltc_dtor(struct nvkm_subdev *subdev)
+{
+	struct nvkm_ltc *ltc = nvkm_ltc(subdev);
+	struct nvkm_ram *ram = ltc->subdev.device->fb->ram;
+	nvkm_mm_fini(&ltc->tags);
+	if (ram)
+		nvkm_mm_free(&ram->vram, &ltc->tag_ram);
+	return ltc;
+}
+
+static const struct nvkm_subdev_func
+nvkm_ltc = {
+	.dtor = nvkm_ltc_dtor,
+	.oneinit = nvkm_ltc_oneinit,
+	.init = nvkm_ltc_init,
+	.intr = nvkm_ltc_intr,
+};
+
 int
-nvkm_ltc_create_(struct nvkm_object *parent, struct nvkm_object *engine,
-		 struct nvkm_oclass *oclass, int length, void **pobject)
+nvkm_ltc_new_(const struct nvkm_ltc_func *func, struct nvkm_device *device,
+	      int index, struct nvkm_ltc **pltc)
 {
-	const struct nvkm_ltc_impl *impl = (void *)oclass;
-	struct nvkm_ltc_priv *ltc;
-	int ret;
+	struct nvkm_ltc *ltc;
 
-	ret = nvkm_subdev_create_(parent, engine, oclass, 0, "PLTCG",
-				  "l2c", length, pobject);
-	ltc = *pobject;
-	if (ret)
-		return ret;
-
-	memset(ltc->zbc_color, 0x00, sizeof(ltc->zbc_color));
-	memset(ltc->zbc_depth, 0x00, sizeof(ltc->zbc_depth));
-
-	ltc->base.subdev.intr = impl->intr;
-	ltc->base.tags_alloc = nvkm_ltc_tags_alloc;
-	ltc->base.tags_free = nvkm_ltc_tags_free;
-	ltc->base.tags_clear = nvkm_ltc_tags_clear;
-	ltc->base.zbc_min = 1; /* reserve 0 for disabled */
-	ltc->base.zbc_max = min(impl->zbc, NVKM_LTC_MAX_ZBC_CNT) - 1;
-	ltc->base.zbc_color_get = nvkm_ltc_zbc_color_get;
-	ltc->base.zbc_depth_get = nvkm_ltc_zbc_depth_get;
+	if (!(ltc = *pltc = kzalloc(sizeof(*ltc), GFP_KERNEL)))
+		return -ENOMEM;
+
+	nvkm_subdev_ctor(&nvkm_ltc, device, index, 0, &ltc->subdev);
+	ltc->func = func;
+	ltc->zbc_min = 1; /* reserve 0 for disabled */
+	ltc->zbc_max = min(func->zbc, NVKM_LTC_MAX_ZBC_CNT) - 1;
 	return 0;
 }

commit 3a8c3400f3e74638bedd0d2410416aa8b794c0fd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/subdev: rename some functions to avoid upcoming conflicts
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
index f9cfbabeeeb3..d0af1aec0fc6 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
@@ -83,7 +83,7 @@ _nvkm_ltc_init(struct nvkm_object *object)
 	const struct nvkm_ltc_impl *impl = (void *)nv_oclass(object);
 	int ret, i;
 
-	ret = nvkm_subdev_init(&ltc->base.subdev);
+	ret = nvkm_subdev_init_old(&ltc->base.subdev);
 	if (ret)
 		return ret;
 

commit c7750cfbc150460a507deb27b8eed93fcf60ea8d
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/ltc: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
index 2fb87fbfd11c..f9cfbabeeeb3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
@@ -24,12 +24,12 @@
 #include "priv.h"
 
 static int
-nvkm_ltc_tags_alloc(struct nvkm_ltc *ltc, u32 n, struct nvkm_mm_node **pnode)
+nvkm_ltc_tags_alloc(struct nvkm_ltc *obj, u32 n, struct nvkm_mm_node **pnode)
 {
-	struct nvkm_ltc_priv *priv = (void *)ltc;
+	struct nvkm_ltc_priv *ltc = container_of(obj, typeof(*ltc), base);
 	int ret;
 
-	ret = nvkm_mm_head(&priv->tags, 0, 1, n, n, 1, pnode);
+	ret = nvkm_mm_head(&ltc->tags, 0, 1, n, n, 1, pnode);
 	if (ret)
 		*pnode = NULL;
 
@@ -37,59 +37,59 @@ nvkm_ltc_tags_alloc(struct nvkm_ltc *ltc, u32 n, struct nvkm_mm_node **pnode)
 }
 
 static void
-nvkm_ltc_tags_free(struct nvkm_ltc *ltc, struct nvkm_mm_node **pnode)
+nvkm_ltc_tags_free(struct nvkm_ltc *obj, struct nvkm_mm_node **pnode)
 {
-	struct nvkm_ltc_priv *priv = (void *)ltc;
-	nvkm_mm_free(&priv->tags, pnode);
+	struct nvkm_ltc_priv *ltc = container_of(obj, typeof(*ltc), base);
+	nvkm_mm_free(&ltc->tags, pnode);
 }
 
 static void
-nvkm_ltc_tags_clear(struct nvkm_ltc *ltc, u32 first, u32 count)
+nvkm_ltc_tags_clear(struct nvkm_ltc *obj, u32 first, u32 count)
 {
+	struct nvkm_ltc_priv *ltc = container_of(obj, typeof(*ltc), base);
 	const struct nvkm_ltc_impl *impl = (void *)nv_oclass(ltc);
-	struct nvkm_ltc_priv *priv = (void *)ltc;
 	const u32 limit = first + count - 1;
 
-	BUG_ON((first > limit) || (limit >= priv->num_tags));
+	BUG_ON((first > limit) || (limit >= ltc->num_tags));
 
-	impl->cbc_clear(priv, first, limit);
-	impl->cbc_wait(priv);
+	impl->cbc_clear(ltc, first, limit);
+	impl->cbc_wait(ltc);
 }
 
 static int
-nvkm_ltc_zbc_color_get(struct nvkm_ltc *ltc, int index, const u32 color[4])
+nvkm_ltc_zbc_color_get(struct nvkm_ltc *obj, int index, const u32 color[4])
 {
+	struct nvkm_ltc_priv *ltc = container_of(obj, typeof(*ltc), base);
 	const struct nvkm_ltc_impl *impl = (void *)nv_oclass(ltc);
-	struct nvkm_ltc_priv *priv = (void *)ltc;
-	memcpy(priv->zbc_color[index], color, sizeof(priv->zbc_color[index]));
-	impl->zbc_clear_color(priv, index, color);
+	memcpy(ltc->zbc_color[index], color, sizeof(ltc->zbc_color[index]));
+	impl->zbc_clear_color(ltc, index, color);
 	return index;
 }
 
 static int
-nvkm_ltc_zbc_depth_get(struct nvkm_ltc *ltc, int index, const u32 depth)
+nvkm_ltc_zbc_depth_get(struct nvkm_ltc *obj, int index, const u32 depth)
 {
+	struct nvkm_ltc_priv *ltc = container_of(obj, typeof(*ltc), base);
 	const struct nvkm_ltc_impl *impl = (void *)nv_oclass(ltc);
-	struct nvkm_ltc_priv *priv = (void *)ltc;
-	priv->zbc_depth[index] = depth;
-	impl->zbc_clear_depth(priv, index, depth);
+	ltc->zbc_depth[index] = depth;
+	impl->zbc_clear_depth(ltc, index, depth);
 	return index;
 }
 
 int
 _nvkm_ltc_init(struct nvkm_object *object)
 {
+	struct nvkm_ltc_priv *ltc = (void *)object;
 	const struct nvkm_ltc_impl *impl = (void *)nv_oclass(object);
-	struct nvkm_ltc_priv *priv = (void *)object;
 	int ret, i;
 
-	ret = nvkm_subdev_init(&priv->base.base);
+	ret = nvkm_subdev_init(&ltc->base.subdev);
 	if (ret)
 		return ret;
 
-	for (i = priv->base.zbc_min; i <= priv->base.zbc_max; i++) {
-		impl->zbc_clear_color(priv, i, priv->zbc_color[i]);
-		impl->zbc_clear_depth(priv, i, priv->zbc_depth[i]);
+	for (i = ltc->base.zbc_min; i <= ltc->base.zbc_max; i++) {
+		impl->zbc_clear_color(ltc, i, ltc->zbc_color[i]);
+		impl->zbc_clear_depth(ltc, i, ltc->zbc_depth[i]);
 	}
 
 	return 0;
@@ -100,25 +100,25 @@ nvkm_ltc_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		 struct nvkm_oclass *oclass, int length, void **pobject)
 {
 	const struct nvkm_ltc_impl *impl = (void *)oclass;
-	struct nvkm_ltc_priv *priv;
+	struct nvkm_ltc_priv *ltc;
 	int ret;
 
 	ret = nvkm_subdev_create_(parent, engine, oclass, 0, "PLTCG",
 				  "l2c", length, pobject);
-	priv = *pobject;
+	ltc = *pobject;
 	if (ret)
 		return ret;
 
-	memset(priv->zbc_color, 0x00, sizeof(priv->zbc_color));
-	memset(priv->zbc_depth, 0x00, sizeof(priv->zbc_depth));
-
-	priv->base.base.intr = impl->intr;
-	priv->base.tags_alloc = nvkm_ltc_tags_alloc;
-	priv->base.tags_free = nvkm_ltc_tags_free;
-	priv->base.tags_clear = nvkm_ltc_tags_clear;
-	priv->base.zbc_min = 1; /* reserve 0 for disabled */
-	priv->base.zbc_max = min(impl->zbc, NVKM_LTC_MAX_ZBC_CNT) - 1;
-	priv->base.zbc_color_get = nvkm_ltc_zbc_color_get;
-	priv->base.zbc_depth_get = nvkm_ltc_zbc_depth_get;
+	memset(ltc->zbc_color, 0x00, sizeof(ltc->zbc_color));
+	memset(ltc->zbc_depth, 0x00, sizeof(ltc->zbc_depth));
+
+	ltc->base.subdev.intr = impl->intr;
+	ltc->base.tags_alloc = nvkm_ltc_tags_alloc;
+	ltc->base.tags_free = nvkm_ltc_tags_free;
+	ltc->base.tags_clear = nvkm_ltc_tags_clear;
+	ltc->base.zbc_min = 1; /* reserve 0 for disabled */
+	ltc->base.zbc_max = min(impl->zbc, NVKM_LTC_MAX_ZBC_CNT) - 1;
+	ltc->base.zbc_color_get = nvkm_ltc_zbc_color_get;
+	ltc->base.zbc_depth_get = nvkm_ltc_zbc_depth_get;
 	return 0;
 }

commit 2799bba69a1caf54889035ed63247d09c4a2fc84
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:06:26 2015 +1000

    drm/nouveau/ltc: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
index 7fa331516f84..2fb87fbfd11c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
@@ -21,17 +21,15 @@
  *
  * Authors: Ben Skeggs <bskeggs@redhat.com>
  */
-
 #include "priv.h"
 
 static int
-nvkm_ltc_tags_alloc(struct nouveau_ltc *ltc, u32 n,
-		    struct nouveau_mm_node **pnode)
+nvkm_ltc_tags_alloc(struct nvkm_ltc *ltc, u32 n, struct nvkm_mm_node **pnode)
 {
 	struct nvkm_ltc_priv *priv = (void *)ltc;
 	int ret;
 
-	ret = nouveau_mm_head(&priv->tags, 0, 1, n, n, 1, pnode);
+	ret = nvkm_mm_head(&priv->tags, 0, 1, n, n, 1, pnode);
 	if (ret)
 		*pnode = NULL;
 
@@ -39,14 +37,14 @@ nvkm_ltc_tags_alloc(struct nouveau_ltc *ltc, u32 n,
 }
 
 static void
-nvkm_ltc_tags_free(struct nouveau_ltc *ltc, struct nouveau_mm_node **pnode)
+nvkm_ltc_tags_free(struct nvkm_ltc *ltc, struct nvkm_mm_node **pnode)
 {
 	struct nvkm_ltc_priv *priv = (void *)ltc;
-	nouveau_mm_free(&priv->tags, pnode);
+	nvkm_mm_free(&priv->tags, pnode);
 }
 
 static void
-nvkm_ltc_tags_clear(struct nouveau_ltc *ltc, u32 first, u32 count)
+nvkm_ltc_tags_clear(struct nvkm_ltc *ltc, u32 first, u32 count)
 {
 	const struct nvkm_ltc_impl *impl = (void *)nv_oclass(ltc);
 	struct nvkm_ltc_priv *priv = (void *)ltc;
@@ -59,7 +57,7 @@ nvkm_ltc_tags_clear(struct nouveau_ltc *ltc, u32 first, u32 count)
 }
 
 static int
-nvkm_ltc_zbc_color_get(struct nouveau_ltc *ltc, int index, const u32 color[4])
+nvkm_ltc_zbc_color_get(struct nvkm_ltc *ltc, int index, const u32 color[4])
 {
 	const struct nvkm_ltc_impl *impl = (void *)nv_oclass(ltc);
 	struct nvkm_ltc_priv *priv = (void *)ltc;
@@ -69,7 +67,7 @@ nvkm_ltc_zbc_color_get(struct nouveau_ltc *ltc, int index, const u32 color[4])
 }
 
 static int
-nvkm_ltc_zbc_depth_get(struct nouveau_ltc *ltc, int index, const u32 depth)
+nvkm_ltc_zbc_depth_get(struct nvkm_ltc *ltc, int index, const u32 depth)
 {
 	const struct nvkm_ltc_impl *impl = (void *)nv_oclass(ltc);
 	struct nvkm_ltc_priv *priv = (void *)ltc;
@@ -79,13 +77,13 @@ nvkm_ltc_zbc_depth_get(struct nouveau_ltc *ltc, int index, const u32 depth)
 }
 
 int
-_nvkm_ltc_init(struct nouveau_object *object)
+_nvkm_ltc_init(struct nvkm_object *object)
 {
 	const struct nvkm_ltc_impl *impl = (void *)nv_oclass(object);
 	struct nvkm_ltc_priv *priv = (void *)object;
 	int ret, i;
 
-	ret = nouveau_subdev_init(&priv->base.base);
+	ret = nvkm_subdev_init(&priv->base.base);
 	if (ret)
 		return ret;
 
@@ -98,15 +96,15 @@ _nvkm_ltc_init(struct nouveau_object *object)
 }
 
 int
-nvkm_ltc_create_(struct nouveau_object *parent, struct nouveau_object *engine,
-		 struct nouveau_oclass *oclass, int length, void **pobject)
+nvkm_ltc_create_(struct nvkm_object *parent, struct nvkm_object *engine,
+		 struct nvkm_oclass *oclass, int length, void **pobject)
 {
 	const struct nvkm_ltc_impl *impl = (void *)oclass;
 	struct nvkm_ltc_priv *priv;
 	int ret;
 
-	ret = nouveau_subdev_create_(parent, engine, oclass, 0, "PLTCG",
-				     "l2c", length, pobject);
+	ret = nvkm_subdev_create_(parent, engine, oclass, 0, "PLTCG",
+				  "l2c", length, pobject);
 	priv = *pobject;
 	if (ret)
 		return ret;
@@ -119,7 +117,7 @@ nvkm_ltc_create_(struct nouveau_object *parent, struct nouveau_object *engine,
 	priv->base.tags_free = nvkm_ltc_tags_free;
 	priv->base.tags_clear = nvkm_ltc_tags_clear;
 	priv->base.zbc_min = 1; /* reserve 0 for disabled */
-	priv->base.zbc_max = min(impl->zbc, NOUVEAU_LTC_MAX_ZBC_CNT) - 1;
+	priv->base.zbc_max = min(impl->zbc, NVKM_LTC_MAX_ZBC_CNT) - 1;
 	priv->base.zbc_color_get = nvkm_ltc_zbc_color_get;
 	priv->base.zbc_depth_get = nvkm_ltc_zbc_depth_get;
 	return 0;

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
new file mode 100644
index 000000000000..7fa331516f84
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2014 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs <bskeggs@redhat.com>
+ */
+
+#include "priv.h"
+
+static int
+nvkm_ltc_tags_alloc(struct nouveau_ltc *ltc, u32 n,
+		    struct nouveau_mm_node **pnode)
+{
+	struct nvkm_ltc_priv *priv = (void *)ltc;
+	int ret;
+
+	ret = nouveau_mm_head(&priv->tags, 0, 1, n, n, 1, pnode);
+	if (ret)
+		*pnode = NULL;
+
+	return ret;
+}
+
+static void
+nvkm_ltc_tags_free(struct nouveau_ltc *ltc, struct nouveau_mm_node **pnode)
+{
+	struct nvkm_ltc_priv *priv = (void *)ltc;
+	nouveau_mm_free(&priv->tags, pnode);
+}
+
+static void
+nvkm_ltc_tags_clear(struct nouveau_ltc *ltc, u32 first, u32 count)
+{
+	const struct nvkm_ltc_impl *impl = (void *)nv_oclass(ltc);
+	struct nvkm_ltc_priv *priv = (void *)ltc;
+	const u32 limit = first + count - 1;
+
+	BUG_ON((first > limit) || (limit >= priv->num_tags));
+
+	impl->cbc_clear(priv, first, limit);
+	impl->cbc_wait(priv);
+}
+
+static int
+nvkm_ltc_zbc_color_get(struct nouveau_ltc *ltc, int index, const u32 color[4])
+{
+	const struct nvkm_ltc_impl *impl = (void *)nv_oclass(ltc);
+	struct nvkm_ltc_priv *priv = (void *)ltc;
+	memcpy(priv->zbc_color[index], color, sizeof(priv->zbc_color[index]));
+	impl->zbc_clear_color(priv, index, color);
+	return index;
+}
+
+static int
+nvkm_ltc_zbc_depth_get(struct nouveau_ltc *ltc, int index, const u32 depth)
+{
+	const struct nvkm_ltc_impl *impl = (void *)nv_oclass(ltc);
+	struct nvkm_ltc_priv *priv = (void *)ltc;
+	priv->zbc_depth[index] = depth;
+	impl->zbc_clear_depth(priv, index, depth);
+	return index;
+}
+
+int
+_nvkm_ltc_init(struct nouveau_object *object)
+{
+	const struct nvkm_ltc_impl *impl = (void *)nv_oclass(object);
+	struct nvkm_ltc_priv *priv = (void *)object;
+	int ret, i;
+
+	ret = nouveau_subdev_init(&priv->base.base);
+	if (ret)
+		return ret;
+
+	for (i = priv->base.zbc_min; i <= priv->base.zbc_max; i++) {
+		impl->zbc_clear_color(priv, i, priv->zbc_color[i]);
+		impl->zbc_clear_depth(priv, i, priv->zbc_depth[i]);
+	}
+
+	return 0;
+}
+
+int
+nvkm_ltc_create_(struct nouveau_object *parent, struct nouveau_object *engine,
+		 struct nouveau_oclass *oclass, int length, void **pobject)
+{
+	const struct nvkm_ltc_impl *impl = (void *)oclass;
+	struct nvkm_ltc_priv *priv;
+	int ret;
+
+	ret = nouveau_subdev_create_(parent, engine, oclass, 0, "PLTCG",
+				     "l2c", length, pobject);
+	priv = *pobject;
+	if (ret)
+		return ret;
+
+	memset(priv->zbc_color, 0x00, sizeof(priv->zbc_color));
+	memset(priv->zbc_depth, 0x00, sizeof(priv->zbc_depth));
+
+	priv->base.base.intr = impl->intr;
+	priv->base.tags_alloc = nvkm_ltc_tags_alloc;
+	priv->base.tags_free = nvkm_ltc_tags_free;
+	priv->base.tags_clear = nvkm_ltc_tags_clear;
+	priv->base.zbc_min = 1; /* reserve 0 for disabled */
+	priv->base.zbc_max = min(impl->zbc, NOUVEAU_LTC_MAX_ZBC_CNT) - 1;
+	priv->base.zbc_color_get = nvkm_ltc_zbc_color_get;
+	priv->base.zbc_depth_get = nvkm_ltc_zbc_depth_get;
+	return 0;
+}
