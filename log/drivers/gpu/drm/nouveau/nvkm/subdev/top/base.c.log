commit eec9ffe47f60db8e2ff96b49939d4c2b1be2c36f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Feb 12 22:28:13 2019 +1000

    drm/nouveau/top: add function to lookup PRI address for devices
    
    Will be using this in upcoming changes to avoid the need for entirely
    new subdevs to deal with Turing register moves.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
index 67ada1d9a28c..cce6e4e90ebf 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
@@ -40,6 +40,22 @@ nvkm_top_device_new(struct nvkm_top *top)
 	return info;
 }
 
+u32
+nvkm_top_addr(struct nvkm_device *device, enum nvkm_devidx index)
+{
+	struct nvkm_top *top = device->top;
+	struct nvkm_top_device *info;
+
+	if (top) {
+		list_for_each_entry(info, &top->device, head) {
+			if (info->index == index)
+				return info->addr;
+		}
+	}
+
+	return 0;
+}
+
 u32
 nvkm_top_reset(struct nvkm_device *device, enum nvkm_devidx index)
 {

commit 13416077e54354df19d3a4f98e574cce451cec2d
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 18 14:57:01 2017 +1000

    drm/nouveau/top: add function to translate subdev index to mmu fault id
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
index fe063d5728e2..67ada1d9a28c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
@@ -95,6 +95,20 @@ nvkm_top_intr(struct nvkm_device *device, u32 intr, u64 *psubdevs)
 	return intr & ~handled;
 }
 
+int
+nvkm_top_fault_id(struct nvkm_device *device, enum nvkm_devidx devidx)
+{
+	struct nvkm_top *top = device->top;
+	struct nvkm_top_device *info;
+
+	list_for_each_entry(info, &top->device, head) {
+		if (info->index == devidx && info->fault >= 0)
+			return info->fault;
+	}
+
+	return -ENOENT;
+}
+
 enum nvkm_devidx
 nvkm_top_fault(struct nvkm_device *device, int fault)
 {

commit 3560e1703f4f7605da203561bad0e231706b93bd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon May 30 10:36:02 2016 +1000

    drm/nouveau/top: add function to lookup interrupt mask for a given device
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
index 19fbcfdb08e8..fe063d5728e2 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
@@ -56,6 +56,22 @@ nvkm_top_reset(struct nvkm_device *device, enum nvkm_devidx index)
 	return 0;
 }
 
+u32
+nvkm_top_intr_mask(struct nvkm_device *device, enum nvkm_devidx devidx)
+{
+	struct nvkm_top *top = device->top;
+	struct nvkm_top_device *info;
+
+	if (top) {
+		list_for_each_entry(info, &top->device, head) {
+			if (info->index == devidx && info->intr >= 0)
+				return BIT(info->intr);
+		}
+	}
+
+	return 0;
+}
+
 u32
 nvkm_top_intr(struct nvkm_device *device, u32 intr, u64 *psubdevs)
 {

commit 952eb819e3234b9deceb3287398f0c2a272e4760
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon May 30 10:32:55 2016 +1000

    drm/nouveau/top: take nvkm_device as argument to public functions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
index a1b264664aad..19fbcfdb08e8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
@@ -41,8 +41,9 @@ nvkm_top_device_new(struct nvkm_top *top)
 }
 
 u32
-nvkm_top_reset(struct nvkm_top *top, enum nvkm_devidx index)
+nvkm_top_reset(struct nvkm_device *device, enum nvkm_devidx index)
 {
+	struct nvkm_top *top = device->top;
 	struct nvkm_top_device *info;
 
 	if (top) {
@@ -56,8 +57,9 @@ nvkm_top_reset(struct nvkm_top *top, enum nvkm_devidx index)
 }
 
 u32
-nvkm_top_intr(struct nvkm_top *top, u32 intr, u64 *psubdevs)
+nvkm_top_intr(struct nvkm_device *device, u32 intr, u64 *psubdevs)
 {
+	struct nvkm_top *top = device->top;
 	struct nvkm_top_device *info;
 	u64 subdevs = 0;
 	u32 handled = 0;
@@ -78,8 +80,9 @@ nvkm_top_intr(struct nvkm_top *top, u32 intr, u64 *psubdevs)
 }
 
 enum nvkm_devidx
-nvkm_top_fault(struct nvkm_top *top, int fault)
+nvkm_top_fault(struct nvkm_device *device, int fault)
 {
+	struct nvkm_top *top = device->top;
 	struct nvkm_top_device *info;
 
 	list_for_each_entry(info, &top->device, head) {
@@ -91,8 +94,9 @@ nvkm_top_fault(struct nvkm_top *top, int fault)
 }
 
 enum nvkm_devidx
-nvkm_top_engine(struct nvkm_top *top, int index, int *runl, int *engn)
+nvkm_top_engine(struct nvkm_device *device, int index, int *runl, int *engn)
 {
+	struct nvkm_top *top = device->top;
 	struct nvkm_top_device *info;
 	int n = 0;
 

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
index d8e9bfbe9fec..a1b264664aad 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
@@ -141,7 +141,7 @@ nvkm_top_new_(const struct nvkm_top_func *func, struct nvkm_device *device,
 	struct nvkm_top *top;
 	if (!(top = *ptop = kzalloc(sizeof(*top), GFP_KERNEL)))
 		return -ENOMEM;
-	nvkm_subdev_ctor(&nvkm_top, device, index, 0, &top->subdev);
+	nvkm_subdev_ctor(&nvkm_top, device, index, &top->subdev);
 	top->func = func;
 	INIT_LIST_HEAD(&top->device);
 	return 0;

commit 5f76f294d1ffb2955370b439226ea072c378a3f7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/top: initial implementation
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
new file mode 100644
index 000000000000..d8e9bfbe9fec
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2016 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs <bskeggs@redhat.com>
+ */
+#include "priv.h"
+
+struct nvkm_top_device *
+nvkm_top_device_new(struct nvkm_top *top)
+{
+	struct nvkm_top_device *info = kmalloc(sizeof(*info), GFP_KERNEL);
+	if (info) {
+		info->index = NVKM_SUBDEV_NR;
+		info->addr = 0;
+		info->fault = -1;
+		info->engine = -1;
+		info->runlist = -1;
+		info->reset = -1;
+		info->intr = -1;
+		list_add_tail(&info->head, &top->device);
+	}
+	return info;
+}
+
+u32
+nvkm_top_reset(struct nvkm_top *top, enum nvkm_devidx index)
+{
+	struct nvkm_top_device *info;
+
+	if (top) {
+		list_for_each_entry(info, &top->device, head) {
+			if (info->index == index && info->reset >= 0)
+				return BIT(info->reset);
+		}
+	}
+
+	return 0;
+}
+
+u32
+nvkm_top_intr(struct nvkm_top *top, u32 intr, u64 *psubdevs)
+{
+	struct nvkm_top_device *info;
+	u64 subdevs = 0;
+	u32 handled = 0;
+
+	if (top) {
+		list_for_each_entry(info, &top->device, head) {
+			if (info->index != NVKM_SUBDEV_NR && info->intr >= 0) {
+				if (intr & BIT(info->intr)) {
+					subdevs |= BIT_ULL(info->index);
+					handled |= BIT(info->intr);
+				}
+			}
+		}
+	}
+
+	*psubdevs = subdevs;
+	return intr & ~handled;
+}
+
+enum nvkm_devidx
+nvkm_top_fault(struct nvkm_top *top, int fault)
+{
+	struct nvkm_top_device *info;
+
+	list_for_each_entry(info, &top->device, head) {
+		if (info->fault == fault)
+			return info->index;
+	}
+
+	return NVKM_SUBDEV_NR;
+}
+
+enum nvkm_devidx
+nvkm_top_engine(struct nvkm_top *top, int index, int *runl, int *engn)
+{
+	struct nvkm_top_device *info;
+	int n = 0;
+
+	list_for_each_entry(info, &top->device, head) {
+		if (info->engine >= 0 && info->runlist >= 0 && n++ == index) {
+			*runl = info->runlist;
+			*engn = info->engine;
+			return info->index;
+		}
+	}
+
+	return -ENODEV;
+}
+
+static int
+nvkm_top_oneinit(struct nvkm_subdev *subdev)
+{
+	struct nvkm_top *top = nvkm_top(subdev);
+	return top->func->oneinit(top);
+}
+
+static void *
+nvkm_top_dtor(struct nvkm_subdev *subdev)
+{
+	struct nvkm_top *top = nvkm_top(subdev);
+	struct nvkm_top_device *info, *temp;
+
+	list_for_each_entry_safe(info, temp, &top->device, head) {
+		list_del(&info->head);
+		kfree(info);
+	}
+
+	return top;
+}
+
+static const struct nvkm_subdev_func
+nvkm_top = {
+	.dtor = nvkm_top_dtor,
+	.oneinit = nvkm_top_oneinit,
+};
+
+int
+nvkm_top_new_(const struct nvkm_top_func *func, struct nvkm_device *device,
+	      int index, struct nvkm_top **ptop)
+{
+	struct nvkm_top *top;
+	if (!(top = *ptop = kzalloc(sizeof(*top), GFP_KERNEL)))
+		return -ENOMEM;
+	nvkm_subdev_ctor(&nvkm_top, device, index, 0, &top->subdev);
+	top->func = func;
+	INIT_LIST_HEAD(&top->device);
+	return 0;
+}
