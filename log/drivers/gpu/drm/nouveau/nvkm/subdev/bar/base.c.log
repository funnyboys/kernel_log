commit 302daab1a7b1206d33a9191d5b42ce606ed46e21
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Dec 11 14:50:02 2018 +1000

    drm/nouveau/fifo/gf100-: call into BAR to reset BARs after MMU fault
    
    This is needed for Turing, but we're supposed to wait for completion after
    re-writing the value on older GPUs anyway.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index 243f0a5c8a62..209a6a40834a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -36,6 +36,16 @@ nvkm_bar_bar1_vmm(struct nvkm_device *device)
 	return device->bar->func->bar1.vmm(device->bar);
 }
 
+void
+nvkm_bar_bar1_reset(struct nvkm_device *device)
+{
+	struct nvkm_bar *bar = device->bar;
+	if (bar) {
+		bar->func->bar1.init(bar);
+		bar->func->bar1.wait(bar);
+	}
+}
+
 struct nvkm_vmm *
 nvkm_bar_bar2_vmm(struct nvkm_device *device)
 {
@@ -48,6 +58,16 @@ nvkm_bar_bar2_vmm(struct nvkm_device *device)
 	return NULL;
 }
 
+void
+nvkm_bar_bar2_reset(struct nvkm_device *device)
+{
+	struct nvkm_bar *bar = device->bar;
+	if (bar && bar->bar2) {
+		bar->func->bar2.init(bar);
+		bar->func->bar2.wait(bar);
+	}
+}
+
 void
 nvkm_bar_bar2_fini(struct nvkm_device *device)
 {

commit e062a01e6daa2555ed13cf3f4e8cd3a05bbe474c
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Thu Jan 4 11:29:09 2018 +0000

    drm/nouveau/bar/gk20a: Avoid bar teardown during init
    
    Commit bbb163e18960 ("drm/nouveau/bar: implement bar1 teardown")
    introduced add a teardown helper function for BAR1. During
    initialisation of the Nouveau, initially all the teardown helpers are
    called once, before calling their init counterparts. For gk20a, after
    the BAR1 teardown function is called, the device is hanging during the
    initialisation of the FB sub-device. At this point it is unclear why
    this is happening and this is still under investigation. However, this
    change is preventing Tegra124 devices from booting when Nouveau is
    enabled. To allow Tegra124 to boot, remove the teardown helper for
    gk20a.
    
    This is based upon a previous patch by Guillaume Tucker but limits
    the workaround to only gk20a GPUs.
    
    Fixes: bbb163e18960 ("drm/nouveau/bar: implement bar1 teardown")
    Reported-by: Guillaume Tucker <guillaume.tucker@collabora.com>
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index 9646adec57cb..243f0a5c8a62 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -73,7 +73,8 @@ static int
 nvkm_bar_fini(struct nvkm_subdev *subdev, bool suspend)
 {
 	struct nvkm_bar *bar = nvkm_bar(subdev);
-	bar->func->bar1.fini(bar);
+	if (bar->func->bar1.fini)
+		bar->func->bar1.fini(bar);
 	return 0;
 }
 

commit ffd937bbd219331e4b67344c104dea09b9ed4a6a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/imem: use fast-path for resume restore
    
    Before: "imem: init completed in 299277us"
     After: "imem: init completed in  11574us"
    
    Suspend from Fedora 26 gnome desktop on GP102.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index 190fb730de17..9646adec57cb 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -81,7 +81,6 @@ static int
 nvkm_bar_init(struct nvkm_subdev *subdev)
 {
 	struct nvkm_bar *bar = nvkm_bar(subdev);
-	nvkm_bar_bar2_init(subdev->device);
 	bar->func->bar1.init(bar);
 	bar->func->bar1.wait(bar);
 	if (bar->func->init)

commit e9be3c7d7ae0aa6e273ac5cf66dfd2d53479bdbf
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/imem: use fast-path for suspend backup
    
    Before: "imem: suspend completed in 5540487us"
     After: "imem: suspend completed in 1871526us"
    
    Suspend from Fedora 26 gnome desktop on GP102.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index c8cb8b8b1323..190fb730de17 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -74,7 +74,6 @@ nvkm_bar_fini(struct nvkm_subdev *subdev, bool suspend)
 {
 	struct nvkm_bar *bar = nvkm_bar(subdev);
 	bar->func->bar1.fini(bar);
-	nvkm_bar_bar2_fini(subdev->device);
 	return 0;
 }
 
@@ -101,6 +100,7 @@ static void *
 nvkm_bar_dtor(struct nvkm_subdev *subdev)
 {
 	struct nvkm_bar *bar = nvkm_bar(subdev);
+	nvkm_bar_bar2_fini(subdev->device);
 	return bar->func->dtor(bar);
 }
 

commit bb7e501a661f820788279063fd9e225bbe9c38e9
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: prevent BAR2 mapping of objects during destructor
    
    GP100's page table nests a lot more deeply than the GF100-compatible
    layout we're currently using, which means our hackish-but-simple way
    of dealing with BAR2 VMM teardown won't work anymore.
    
    In order to sanely handle the chicken-and-egg (BAR2's PTs get mapped
    into themselves) problem, we need prevent page tables getting mapped
    back into BAR2 during the destruction of its VMM.
    
    To do this, we simply key off the state that's now maintained by the
    BAR2 init/fini functions.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index d600aafae315..c8cb8b8b1323 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -43,7 +43,7 @@ nvkm_bar_bar2_vmm(struct nvkm_device *device)
 	 * to know when object access needs to go through the BAR0 window.
 	 */
 	struct nvkm_bar *bar = device->bar;
-	if (bar && bar->func->bar2.vmm && bar->subdev.oneinit)
+	if (bar && bar->bar2)
 		return bar->func->bar2.vmm(bar);
 	return NULL;
 }

commit a78dbce9a161a3a985b837bd07afd8651d42cabd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: modify interface to bar2 vmm mapping
    
    Match API with the BAR1 version.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index 5a80cf5f9eb0..d600aafae315 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -30,19 +30,22 @@ nvkm_bar_flush(struct nvkm_bar *bar)
 		bar->func->flush(bar);
 }
 
-struct nvkm_vm *
-nvkm_bar_kmap(struct nvkm_bar *bar)
+struct nvkm_vmm *
+nvkm_bar_bar1_vmm(struct nvkm_device *device)
 {
-	/* disallow kmap() until after vm has been bootstrapped */
-	if (bar && bar->func->kmap && bar->subdev.oneinit)
-		return bar->func->kmap(bar);
-	return NULL;
+	return device->bar->func->bar1.vmm(device->bar);
 }
 
 struct nvkm_vmm *
-nvkm_bar_bar1_vmm(struct nvkm_device *device)
+nvkm_bar_bar2_vmm(struct nvkm_device *device)
 {
-	return device->bar->func->bar1.vmm(device->bar);
+	/* Denies access to BAR2 when it's not initialised, used by INSTMEM
+	 * to know when object access needs to go through the BAR0 window.
+	 */
+	struct nvkm_bar *bar = device->bar;
+	if (bar && bar->func->bar2.vmm && bar->subdev.oneinit)
+		return bar->func->bar2.vmm(bar);
+	return NULL;
 }
 
 void

commit 570889dc5070e1f98b5898dce426f970c9b9329b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: modify interface to bar1 vmm mapping
    
    Upcoming changes will remove the nvkm_vmm pointer from nvkm_vma, instead
    requiring it to be explicitly specified on each operation.
    
    It's not currently possible to get this information for BAR1 mappings,
    so let's fix that ahead of time.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index b495f7796fa3..5a80cf5f9eb0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -39,10 +39,10 @@ nvkm_bar_kmap(struct nvkm_bar *bar)
 	return NULL;
 }
 
-int
-nvkm_bar_umap(struct nvkm_bar *bar, u64 size, int type, struct nvkm_vma *vma)
+struct nvkm_vmm *
+nvkm_bar_bar1_vmm(struct nvkm_device *device)
 {
-	return bar->func->umap(bar, size, type, vma);
+	return device->bar->func->bar1.vmm(device->bar);
 }
 
 void

commit e988952eefd923a40cea1077bcb939025dafb0f1
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: expose interface to bar2 teardown
    
    Will prevent spurious MMU fault interrupts if something decides to touch
    BAR1 after we've unloaded the driver.
    
    Exposed external to BAR so that INSTMEM can use it to better control the
    suspend/resume fast-path access.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index b55ab7183cb9..b495f7796fa3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -45,6 +45,16 @@ nvkm_bar_umap(struct nvkm_bar *bar, u64 size, int type, struct nvkm_vma *vma)
 	return bar->func->umap(bar, size, type, vma);
 }
 
+void
+nvkm_bar_bar2_fini(struct nvkm_device *device)
+{
+	struct nvkm_bar *bar = device->bar;
+	if (bar && bar->bar2) {
+		bar->func->bar2.fini(bar);
+		bar->bar2 = false;
+	}
+}
+
 void
 nvkm_bar_bar2_init(struct nvkm_device *device)
 {
@@ -61,7 +71,7 @@ nvkm_bar_fini(struct nvkm_subdev *subdev, bool suspend)
 {
 	struct nvkm_bar *bar = nvkm_bar(subdev);
 	bar->func->bar1.fini(bar);
-	bar->bar2 = false;
+	nvkm_bar_bar2_fini(subdev->device);
 	return 0;
 }
 

commit 48fe02478a0ddb89930f3595f8217fa2dfd98796
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: expose interface to bar2 initialisation
    
    If we want to be able to hit the instmem fast-path in a few trickier cases,
    we need to be more flexible with when we can initialise BAR2 access.
    
    There's probably a decent case to be made for merging BAR/INSTMEM into BUS,
    but that's something to ponder another day.
    
    Flushes have been added after the write to bind the instance block,
    as later commits will reveal the need for them.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index 0fee5e0a090e..b55ab7183cb9 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -45,11 +45,23 @@ nvkm_bar_umap(struct nvkm_bar *bar, u64 size, int type, struct nvkm_vma *vma)
 	return bar->func->umap(bar, size, type, vma);
 }
 
+void
+nvkm_bar_bar2_init(struct nvkm_device *device)
+{
+	struct nvkm_bar *bar = device->bar;
+	if (bar && bar->subdev.oneinit && !bar->bar2 && bar->func->bar2.init) {
+		bar->func->bar2.init(bar);
+		bar->func->bar2.wait(bar);
+		bar->bar2 = true;
+	}
+}
+
 static int
 nvkm_bar_fini(struct nvkm_subdev *subdev, bool suspend)
 {
 	struct nvkm_bar *bar = nvkm_bar(subdev);
 	bar->func->bar1.fini(bar);
+	bar->bar2 = false;
 	return 0;
 }
 
@@ -57,9 +69,11 @@ static int
 nvkm_bar_init(struct nvkm_subdev *subdev)
 {
 	struct nvkm_bar *bar = nvkm_bar(subdev);
+	nvkm_bar_bar2_init(subdev->device);
 	bar->func->bar1.init(bar);
 	bar->func->bar1.wait(bar);
-	bar->func->init(bar);
+	if (bar->func->init)
+		bar->func->init(bar);
 	return 0;
 }
 

commit bbb163e18960a90b0c5974fe448ad78a5df8e5d7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: implement bar1 teardown
    
    Will prevent spurious MMU fault interrupts if something decides to touch
    BAR1 after we've unloaded the driver.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index adaf91ee8326..0fee5e0a090e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -45,6 +45,14 @@ nvkm_bar_umap(struct nvkm_bar *bar, u64 size, int type, struct nvkm_vma *vma)
 	return bar->func->umap(bar, size, type, vma);
 }
 
+static int
+nvkm_bar_fini(struct nvkm_subdev *subdev, bool suspend)
+{
+	struct nvkm_bar *bar = nvkm_bar(subdev);
+	bar->func->bar1.fini(bar);
+	return 0;
+}
+
 static int
 nvkm_bar_init(struct nvkm_subdev *subdev)
 {
@@ -74,6 +82,7 @@ nvkm_bar = {
 	.dtor = nvkm_bar_dtor,
 	.oneinit = nvkm_bar_oneinit,
 	.init = nvkm_bar_init,
+	.fini = nvkm_bar_fini,
 };
 
 void

commit 7313cfa4f6e30384fa04083698d1e865cf812a6a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: move bar1 initialisation into its own function
    
    BAR2 being done for practical reasons, this is just for consistency.
    
    Flushes have been added after the write to bind the instance block,
    as later commits will reveal the need for them.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index f849db6ef541..adaf91ee8326 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -49,6 +49,8 @@ static int
 nvkm_bar_init(struct nvkm_subdev *subdev)
 {
 	struct nvkm_bar *bar = nvkm_bar(subdev);
+	bar->func->bar1.init(bar);
+	bar->func->bar1.wait(bar);
 	bar->func->init(bar);
 	return 0;
 }

commit 269fe32d3343b7b9e48ba533887f58eb877581c8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: swap oneinit/init ordering, and rename bar3 to bar2
    
    NVIDIA call it BAR2, Linux APIs treat it as BAR3 due to BAR1 being a
    64-bit BAR, which I presume take two slots or something.
    
    No actual code changes here, just to make future commits less messy.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index 2eab979e94df..f849db6ef541 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -46,18 +46,18 @@ nvkm_bar_umap(struct nvkm_bar *bar, u64 size, int type, struct nvkm_vma *vma)
 }
 
 static int
-nvkm_bar_oneinit(struct nvkm_subdev *subdev)
+nvkm_bar_init(struct nvkm_subdev *subdev)
 {
 	struct nvkm_bar *bar = nvkm_bar(subdev);
-	return bar->func->oneinit(bar);
+	bar->func->init(bar);
+	return 0;
 }
 
 static int
-nvkm_bar_init(struct nvkm_subdev *subdev)
+nvkm_bar_oneinit(struct nvkm_subdev *subdev)
 {
 	struct nvkm_bar *bar = nvkm_bar(subdev);
-	bar->func->init(bar);
-	return 0;
+	return bar->func->oneinit(bar);
 }
 
 static void *

commit e69dae85c90b3e07ed5538a8ad8a7ee807fbbf64
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar/nv50,g84: drop mmu invalidate
    
    Will already be done by MMU as a result of the PT writes that occur
    during BAR2 bootstrapping.
    
    This is likely just a left-over from the days when it was hardcoded.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index c561d148cebc..2eab979e94df 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -56,7 +56,8 @@ static int
 nvkm_bar_init(struct nvkm_subdev *subdev)
 {
 	struct nvkm_bar *bar = nvkm_bar(subdev);
-	return bar->func->init(bar);
+	bar->func->init(bar);
+	return 0;
 }
 
 static void *

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index a9433ad45b1e..c561d148cebc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -77,7 +77,7 @@ void
 nvkm_bar_ctor(const struct nvkm_bar_func *func, struct nvkm_device *device,
 	      int index, struct nvkm_bar *bar)
 {
-	nvkm_subdev_ctor(&nvkm_bar, device, index, 0, &bar->subdev);
+	nvkm_subdev_ctor(&nvkm_bar, device, index, &bar->subdev);
 	bar->func = func;
 	spin_lock_init(&bar->lock);
 }

commit 3293228174e4d44cca56d809cc8409c3f88f8b90
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/bar: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index 8daaa65fc8cf..a9433ad45b1e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -23,23 +23,61 @@
  */
 #include "priv.h"
 
+void
+nvkm_bar_flush(struct nvkm_bar *bar)
+{
+	if (bar && bar->func->flush)
+		bar->func->flush(bar);
+}
+
+struct nvkm_vm *
+nvkm_bar_kmap(struct nvkm_bar *bar)
+{
+	/* disallow kmap() until after vm has been bootstrapped */
+	if (bar && bar->func->kmap && bar->subdev.oneinit)
+		return bar->func->kmap(bar);
+	return NULL;
+}
+
 int
-nvkm_bar_create_(struct nvkm_object *parent, struct nvkm_object *engine,
-		 struct nvkm_oclass *oclass, int length, void **pobject)
+nvkm_bar_umap(struct nvkm_bar *bar, u64 size, int type, struct nvkm_vma *vma)
 {
-	return nvkm_subdev_create_(parent, engine, oclass, 0, "BARCTL",
-				   "bar", length, pobject);
+	return bar->func->umap(bar, size, type, vma);
 }
 
-void
-nvkm_bar_destroy(struct nvkm_bar *bar)
+static int
+nvkm_bar_oneinit(struct nvkm_subdev *subdev)
 {
-	nvkm_subdev_destroy(&bar->subdev);
+	struct nvkm_bar *bar = nvkm_bar(subdev);
+	return bar->func->oneinit(bar);
 }
 
+static int
+nvkm_bar_init(struct nvkm_subdev *subdev)
+{
+	struct nvkm_bar *bar = nvkm_bar(subdev);
+	return bar->func->init(bar);
+}
+
+static void *
+nvkm_bar_dtor(struct nvkm_subdev *subdev)
+{
+	struct nvkm_bar *bar = nvkm_bar(subdev);
+	return bar->func->dtor(bar);
+}
+
+static const struct nvkm_subdev_func
+nvkm_bar = {
+	.dtor = nvkm_bar_dtor,
+	.oneinit = nvkm_bar_oneinit,
+	.init = nvkm_bar_init,
+};
+
 void
-_nvkm_bar_dtor(struct nvkm_object *object)
+nvkm_bar_ctor(const struct nvkm_bar_func *func, struct nvkm_device *device,
+	      int index, struct nvkm_bar *bar)
 {
-	struct nvkm_bar *bar = (void *)object;
-	nvkm_bar_destroy(bar);
+	nvkm_subdev_ctor(&nvkm_bar, device, index, 0, &bar->subdev);
+	bar->func = func;
+	spin_lock_init(&bar->lock);
 }

commit d8e83994aaf6749b7124a219f5b46bd1329e2a08
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/imem: improve management of instance memory
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index 6fe71b2276cc..8daaa65fc8cf 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -23,96 +23,6 @@
  */
 #include "priv.h"
 
-#include <subdev/fb.h>
-#include <subdev/mmu.h>
-
-struct nvkm_barobj {
-	struct nvkm_object base;
-	struct nvkm_vma vma;
-	void __iomem *iomem;
-};
-
-static int
-nvkm_barobj_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-		 struct nvkm_oclass *oclass, void *data, u32 size,
-		 struct nvkm_object **pobject)
-{
-	struct nvkm_device *device = nv_device(parent);
-	struct nvkm_bar *bar = nvkm_bar(device);
-	struct nvkm_mem *mem = data;
-	struct nvkm_barobj *barobj;
-	int ret;
-
-	ret = nvkm_object_create(parent, engine, oclass, 0, &barobj);
-	*pobject = nv_object(barobj);
-	if (ret)
-		return ret;
-
-	ret = bar->kmap(bar, mem, NV_MEM_ACCESS_RW, &barobj->vma);
-	if (ret)
-		return ret;
-
-	barobj->iomem = ioremap(nv_device_resource_start(device, 3) +
-				(u32)barobj->vma.offset, mem->size << 12);
-	if (!barobj->iomem) {
-		nvkm_warn(&bar->subdev, "PRAMIN ioremap failed\n");
-		return -ENOMEM;
-	}
-
-	return 0;
-}
-
-static void
-nvkm_barobj_dtor(struct nvkm_object *object)
-{
-	struct nvkm_bar *bar = nvkm_bar(object);
-	struct nvkm_barobj *barobj = (void *)object;
-	if (barobj->vma.node) {
-		if (barobj->iomem)
-			iounmap(barobj->iomem);
-		bar->unmap(bar, &barobj->vma);
-	}
-	nvkm_object_destroy(&barobj->base);
-}
-
-static u32
-nvkm_barobj_rd32(struct nvkm_object *object, u64 addr)
-{
-	struct nvkm_barobj *barobj = (void *)object;
-	return ioread32_native(barobj->iomem + addr);
-}
-
-static void
-nvkm_barobj_wr32(struct nvkm_object *object, u64 addr, u32 data)
-{
-	struct nvkm_barobj *barobj = (void *)object;
-	iowrite32_native(data, barobj->iomem + addr);
-}
-
-static struct nvkm_oclass
-nvkm_barobj_oclass = {
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nvkm_barobj_ctor,
-		.dtor = nvkm_barobj_dtor,
-		.init = _nvkm_object_init,
-		.fini = _nvkm_object_fini,
-		.rd32 = nvkm_barobj_rd32,
-		.wr32 = nvkm_barobj_wr32,
-	},
-};
-
-int
-nvkm_bar_alloc(struct nvkm_bar *bar, struct nvkm_object *parent,
-	       struct nvkm_mem *mem, struct nvkm_object **pobject)
-{
-	struct nvkm_object *gpuobj;
-	int ret = nvkm_object_old(parent, &parent->engine->subdev.object,
-				   &nvkm_barobj_oclass, mem, 0, &gpuobj);
-	if (ret == 0)
-		*pobject = gpuobj;
-	return ret;
-}
-
 int
 nvkm_bar_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		 struct nvkm_oclass *oclass, int length, void **pobject)

commit aa35888ff024b18c7b6b29eb773a221f642987f7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/object: rename some functions to avoid upcoming conflicts
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index 0cdb49e983ab..6fe71b2276cc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -94,8 +94,8 @@ nvkm_barobj_oclass = {
 	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nvkm_barobj_ctor,
 		.dtor = nvkm_barobj_dtor,
-		.init = nvkm_object_init,
-		.fini = nvkm_object_fini,
+		.init = _nvkm_object_init,
+		.fini = _nvkm_object_fini,
 		.rd32 = nvkm_barobj_rd32,
 		.wr32 = nvkm_barobj_wr32,
 	},
@@ -106,7 +106,7 @@ nvkm_bar_alloc(struct nvkm_bar *bar, struct nvkm_object *parent,
 	       struct nvkm_mem *mem, struct nvkm_object **pobject)
 {
 	struct nvkm_object *gpuobj;
-	int ret = nvkm_object_ctor(parent, &parent->engine->subdev.object,
+	int ret = nvkm_object_old(parent, &parent->engine->subdev.object,
 				   &nvkm_barobj_oclass, mem, 0, &gpuobj);
 	if (ret == 0)
 		*pobject = gpuobj;

commit 0df18e6d52fab22e841e734c384c86f3b7b762b8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:11 2015 +1000

    drm/nouveau/bar: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index 664a1789500a..0cdb49e983ab 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -55,7 +55,7 @@ nvkm_barobj_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	barobj->iomem = ioremap(nv_device_resource_start(device, 3) +
 				(u32)barobj->vma.offset, mem->size << 12);
 	if (!barobj->iomem) {
-		nv_warn(bar, "PRAMIN ioremap failed\n");
+		nvkm_warn(&bar->subdev, "PRAMIN ioremap failed\n");
 		return -ENOMEM;
 	}
 

commit 5b0c189fcb232daa1cabac8892e42cdee57254bd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/bar: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index 9b6b9ac34ced..664a1789500a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -117,22 +117,14 @@ int
 nvkm_bar_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		 struct nvkm_oclass *oclass, int length, void **pobject)
 {
-	struct nvkm_bar *bar;
-	int ret;
-
-	ret = nvkm_subdev_create_(parent, engine, oclass, 0, "BARCTL",
-				  "bar", length, pobject);
-	bar = *pobject;
-	if (ret)
-		return ret;
-
-	return 0;
+	return nvkm_subdev_create_(parent, engine, oclass, 0, "BARCTL",
+				   "bar", length, pobject);
 }
 
 void
 nvkm_bar_destroy(struct nvkm_bar *bar)
 {
-	nvkm_subdev_destroy(&bar->base);
+	nvkm_subdev_destroy(&bar->subdev);
 }
 
 void

commit 9ace404b1098221021b01c2ba0eeea0c257fa4a5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/device: include core/device.h automatically for subdevs/engines
    
    Pretty much every subdev/engine is going to need access to nvkm_device
    shortly to touch registers and/or output messages.
    
    The odd placement of the includes is necessary to work around some
    inter-dependencies that currently exist.  This will be fixed later.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index 3502d00122ef..9b6b9ac34ced 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -23,7 +23,6 @@
  */
 #include "priv.h"
 
-#include <core/device.h>
 #include <subdev/fb.h>
 #include <subdev/mmu.h>
 

commit 245dcfe96f6900dbf64e48a350badf4c90fabc2e
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 14:35:35 2015 +1000

    drm/nouveau/bar: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index 1b37afe4a4ea..3502d00122ef 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -21,33 +21,30 @@
  *
  * Authors: Ben Skeggs
  */
+#include "priv.h"
 
-#include <core/object.h>
-
+#include <core/device.h>
 #include <subdev/fb.h>
 #include <subdev/mmu.h>
 
-#include "priv.h"
-
-struct nouveau_barobj {
-	struct nouveau_object base;
-	struct nouveau_vma vma;
+struct nvkm_barobj {
+	struct nvkm_object base;
+	struct nvkm_vma vma;
 	void __iomem *iomem;
 };
 
 static int
-nouveau_barobj_ctor(struct nouveau_object *parent,
-		    struct nouveau_object *engine,
-		    struct nouveau_oclass *oclass, void *data, u32 size,
-		    struct nouveau_object **pobject)
+nvkm_barobj_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+		 struct nvkm_oclass *oclass, void *data, u32 size,
+		 struct nvkm_object **pobject)
 {
-	struct nouveau_device *device = nv_device(parent);
-	struct nouveau_bar *bar = nouveau_bar(device);
-	struct nouveau_mem *mem = data;
-	struct nouveau_barobj *barobj;
+	struct nvkm_device *device = nv_device(parent);
+	struct nvkm_bar *bar = nvkm_bar(device);
+	struct nvkm_mem *mem = data;
+	struct nvkm_barobj *barobj;
 	int ret;
 
-	ret = nouveau_object_create(parent, engine, oclass, 0, &barobj);
+	ret = nvkm_object_create(parent, engine, oclass, 0, &barobj);
 	*pobject = nv_object(barobj);
 	if (ret)
 		return ret;
@@ -67,67 +64,65 @@ nouveau_barobj_ctor(struct nouveau_object *parent,
 }
 
 static void
-nouveau_barobj_dtor(struct nouveau_object *object)
+nvkm_barobj_dtor(struct nvkm_object *object)
 {
-	struct nouveau_bar *bar = nouveau_bar(object);
-	struct nouveau_barobj *barobj = (void *)object;
+	struct nvkm_bar *bar = nvkm_bar(object);
+	struct nvkm_barobj *barobj = (void *)object;
 	if (barobj->vma.node) {
 		if (barobj->iomem)
 			iounmap(barobj->iomem);
 		bar->unmap(bar, &barobj->vma);
 	}
-	nouveau_object_destroy(&barobj->base);
+	nvkm_object_destroy(&barobj->base);
 }
 
 static u32
-nouveau_barobj_rd32(struct nouveau_object *object, u64 addr)
+nvkm_barobj_rd32(struct nvkm_object *object, u64 addr)
 {
-	struct nouveau_barobj *barobj = (void *)object;
+	struct nvkm_barobj *barobj = (void *)object;
 	return ioread32_native(barobj->iomem + addr);
 }
 
 static void
-nouveau_barobj_wr32(struct nouveau_object *object, u64 addr, u32 data)
+nvkm_barobj_wr32(struct nvkm_object *object, u64 addr, u32 data)
 {
-	struct nouveau_barobj *barobj = (void *)object;
+	struct nvkm_barobj *barobj = (void *)object;
 	iowrite32_native(data, barobj->iomem + addr);
 }
 
-static struct nouveau_oclass
-nouveau_barobj_oclass = {
-	.ofuncs = &(struct nouveau_ofuncs) {
-		.ctor = nouveau_barobj_ctor,
-		.dtor = nouveau_barobj_dtor,
-		.init = nouveau_object_init,
-		.fini = nouveau_object_fini,
-		.rd32 = nouveau_barobj_rd32,
-		.wr32 = nouveau_barobj_wr32,
+static struct nvkm_oclass
+nvkm_barobj_oclass = {
+	.ofuncs = &(struct nvkm_ofuncs) {
+		.ctor = nvkm_barobj_ctor,
+		.dtor = nvkm_barobj_dtor,
+		.init = nvkm_object_init,
+		.fini = nvkm_object_fini,
+		.rd32 = nvkm_barobj_rd32,
+		.wr32 = nvkm_barobj_wr32,
 	},
 };
 
 int
-nouveau_bar_alloc(struct nouveau_bar *bar, struct nouveau_object *parent,
-		  struct nouveau_mem *mem, struct nouveau_object **pobject)
+nvkm_bar_alloc(struct nvkm_bar *bar, struct nvkm_object *parent,
+	       struct nvkm_mem *mem, struct nvkm_object **pobject)
 {
-	struct nouveau_object *gpuobj;
-	int ret = nouveau_object_ctor(parent, &parent->engine->subdev.object,
-				      &nouveau_barobj_oclass,
-				      mem, 0, &gpuobj);
+	struct nvkm_object *gpuobj;
+	int ret = nvkm_object_ctor(parent, &parent->engine->subdev.object,
+				   &nvkm_barobj_oclass, mem, 0, &gpuobj);
 	if (ret == 0)
 		*pobject = gpuobj;
 	return ret;
 }
 
 int
-nouveau_bar_create_(struct nouveau_object *parent,
-		    struct nouveau_object *engine,
-		    struct nouveau_oclass *oclass, int length, void **pobject)
+nvkm_bar_create_(struct nvkm_object *parent, struct nvkm_object *engine,
+		 struct nvkm_oclass *oclass, int length, void **pobject)
 {
-	struct nouveau_bar *bar;
+	struct nvkm_bar *bar;
 	int ret;
 
-	ret = nouveau_subdev_create_(parent, engine, oclass, 0, "BARCTL",
-				     "bar", length, pobject);
+	ret = nvkm_subdev_create_(parent, engine, oclass, 0, "BARCTL",
+				  "bar", length, pobject);
 	bar = *pobject;
 	if (ret)
 		return ret;
@@ -136,14 +131,14 @@ nouveau_bar_create_(struct nouveau_object *parent,
 }
 
 void
-nouveau_bar_destroy(struct nouveau_bar *bar)
+nvkm_bar_destroy(struct nvkm_bar *bar)
 {
-	nouveau_subdev_destroy(&bar->base);
+	nvkm_subdev_destroy(&bar->base);
 }
 
 void
-_nouveau_bar_dtor(struct nouveau_object *object)
+_nvkm_bar_dtor(struct nvkm_object *object)
 {
-	struct nouveau_bar *bar = (void *)object;
-	nouveau_bar_destroy(bar);
+	struct nvkm_bar *bar = (void *)object;
+	nvkm_bar_destroy(bar);
 }

commit 5ce3bf3c72436c49fbd9a5b71d7d278665f4bf55
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 09:57:36 2015 +1000

    drm/nouveau/mmu: rename from vmmgr (no binary change)
    
    Switch to NVIDIA's name for the device.
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
index 188c638411b2..1b37afe4a4ea 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -25,7 +25,7 @@
 #include <core/object.h>
 
 #include <subdev/fb.h>
-#include <subdev/vm.h>
+#include <subdev/mmu.h>
 
 #include "priv.h"
 

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
new file mode 100644
index 000000000000..188c638411b2
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/base.c
@@ -0,0 +1,149 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <core/object.h>
+
+#include <subdev/fb.h>
+#include <subdev/vm.h>
+
+#include "priv.h"
+
+struct nouveau_barobj {
+	struct nouveau_object base;
+	struct nouveau_vma vma;
+	void __iomem *iomem;
+};
+
+static int
+nouveau_barobj_ctor(struct nouveau_object *parent,
+		    struct nouveau_object *engine,
+		    struct nouveau_oclass *oclass, void *data, u32 size,
+		    struct nouveau_object **pobject)
+{
+	struct nouveau_device *device = nv_device(parent);
+	struct nouveau_bar *bar = nouveau_bar(device);
+	struct nouveau_mem *mem = data;
+	struct nouveau_barobj *barobj;
+	int ret;
+
+	ret = nouveau_object_create(parent, engine, oclass, 0, &barobj);
+	*pobject = nv_object(barobj);
+	if (ret)
+		return ret;
+
+	ret = bar->kmap(bar, mem, NV_MEM_ACCESS_RW, &barobj->vma);
+	if (ret)
+		return ret;
+
+	barobj->iomem = ioremap(nv_device_resource_start(device, 3) +
+				(u32)barobj->vma.offset, mem->size << 12);
+	if (!barobj->iomem) {
+		nv_warn(bar, "PRAMIN ioremap failed\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void
+nouveau_barobj_dtor(struct nouveau_object *object)
+{
+	struct nouveau_bar *bar = nouveau_bar(object);
+	struct nouveau_barobj *barobj = (void *)object;
+	if (barobj->vma.node) {
+		if (barobj->iomem)
+			iounmap(barobj->iomem);
+		bar->unmap(bar, &barobj->vma);
+	}
+	nouveau_object_destroy(&barobj->base);
+}
+
+static u32
+nouveau_barobj_rd32(struct nouveau_object *object, u64 addr)
+{
+	struct nouveau_barobj *barobj = (void *)object;
+	return ioread32_native(barobj->iomem + addr);
+}
+
+static void
+nouveau_barobj_wr32(struct nouveau_object *object, u64 addr, u32 data)
+{
+	struct nouveau_barobj *barobj = (void *)object;
+	iowrite32_native(data, barobj->iomem + addr);
+}
+
+static struct nouveau_oclass
+nouveau_barobj_oclass = {
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nouveau_barobj_ctor,
+		.dtor = nouveau_barobj_dtor,
+		.init = nouveau_object_init,
+		.fini = nouveau_object_fini,
+		.rd32 = nouveau_barobj_rd32,
+		.wr32 = nouveau_barobj_wr32,
+	},
+};
+
+int
+nouveau_bar_alloc(struct nouveau_bar *bar, struct nouveau_object *parent,
+		  struct nouveau_mem *mem, struct nouveau_object **pobject)
+{
+	struct nouveau_object *gpuobj;
+	int ret = nouveau_object_ctor(parent, &parent->engine->subdev.object,
+				      &nouveau_barobj_oclass,
+				      mem, 0, &gpuobj);
+	if (ret == 0)
+		*pobject = gpuobj;
+	return ret;
+}
+
+int
+nouveau_bar_create_(struct nouveau_object *parent,
+		    struct nouveau_object *engine,
+		    struct nouveau_oclass *oclass, int length, void **pobject)
+{
+	struct nouveau_bar *bar;
+	int ret;
+
+	ret = nouveau_subdev_create_(parent, engine, oclass, 0, "BARCTL",
+				     "bar", length, pobject);
+	bar = *pobject;
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+void
+nouveau_bar_destroy(struct nouveau_bar *bar)
+{
+	nouveau_subdev_destroy(&bar->base);
+}
+
+void
+_nouveau_bar_dtor(struct nouveau_object *object)
+{
+	struct nouveau_bar *bar = (void *)object;
+	nouveau_bar_destroy(bar);
+}
