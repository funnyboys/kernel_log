commit f10b83de1fd49216a4c657816f48001437e4bdd5
Author: Jon Derrick <jonathan.derrick@intel.com>
Date:   Fri Mar 15 18:05:16 2019 -0600

    drm/nouveau/bar/nv50: ensure BAR is mapped
    
    If the BAR is zero size, it indicates it was never successfully mapped.
    Ensure that the BAR is valid during initialization before attempting to
    use it.
    
    Signed-off-by: Jon Derrick <jonathan.derrick@intel.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 8e64b19f3f8a..f23a0ccc2bec 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -109,7 +109,7 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 	struct nvkm_device *device = bar->base.subdev.device;
 	static struct lock_class_key bar1_lock;
 	static struct lock_class_key bar2_lock;
-	u64 start, limit;
+	u64 start, limit, size;
 	int ret;
 
 	ret = nvkm_gpuobj_new(device, 0x20000, 0, false, NULL, &bar->mem);
@@ -127,7 +127,10 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 
 	/* BAR2 */
 	start = 0x0100000000ULL;
-	limit = start + device->func->resource_size(device, 3);
+	size = device->func->resource_size(device, 3);
+	if (!size)
+		return -ENOMEM;
+	limit = start + size;
 
 	ret = nvkm_vmm_new(device, start, limit-- - start, NULL, 0,
 			   &bar2_lock, "bar2", &bar->bar2_vmm);
@@ -164,7 +167,10 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 
 	/* BAR1 */
 	start = 0x0000000000ULL;
-	limit = start + device->func->resource_size(device, 1);
+	size = device->func->resource_size(device, 1);
+	if (!size)
+		return -ENOMEM;
+	limit = start + size;
 
 	ret = nvkm_vmm_new(device, start, limit-- - start, NULL, 0,
 			   &bar1_lock, "bar1", &bar->bar1_vmm);

commit 307a312df9c43fdea286ad17f748aaf777cc434a
Author: Jon Derrick <jonathan.derrick@intel.com>
Date:   Fri Mar 15 18:05:15 2019 -0600

    drm/nouveau/bar/nv50: check bar1 vmm return value
    
    Check bar1's new vmm creation return value for errors.
    
    Signed-off-by: Jon Derrick <jonathan.derrick@intel.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 157b076a1272..8e64b19f3f8a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -168,6 +168,8 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 
 	ret = nvkm_vmm_new(device, start, limit-- - start, NULL, 0,
 			   &bar1_lock, "bar1", &bar->bar1_vmm);
+	if (ret)
+		return ret;
 
 	atomic_inc(&bar->bar1_vmm->engref[NVKM_SUBDEV_BAR]);
 	bar->bar1_vmm->debug = bar->base.subdev.debug;

commit fc584e1a4a579c3279ed563b890415c13b2f85ac
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar/nv50: initialise vmm with new interfaces
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 9300529917fc..157b076a1272 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -46,7 +46,7 @@ nv50_bar_flush(struct nvkm_bar *base)
 struct nvkm_vmm *
 nv50_bar_bar1_vmm(struct nvkm_bar *base)
 {
-	return nv50_bar(base)->bar1_vm;
+	return nv50_bar(base)->bar1_vmm;
 }
 
 void
@@ -72,7 +72,7 @@ nv50_bar_bar1_init(struct nvkm_bar *base)
 struct nvkm_vmm *
 nv50_bar_bar2_vmm(struct nvkm_bar *base)
 {
-	return nv50_bar(base)->bar2_vm;
+	return nv50_bar(base)->bar2_vmm;
 }
 
 void
@@ -109,7 +109,6 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 	struct nvkm_device *device = bar->base.subdev.device;
 	static struct lock_class_key bar1_lock;
 	static struct lock_class_key bar2_lock;
-	struct nvkm_vm *vm;
 	u64 start, limit;
 	int ret;
 
@@ -130,18 +129,19 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 	start = 0x0100000000ULL;
 	limit = start + device->func->resource_size(device, 3);
 
-	ret = nvkm_vm_new(device, start, limit - start, start, &bar2_lock, &vm);
+	ret = nvkm_vmm_new(device, start, limit-- - start, NULL, 0,
+			   &bar2_lock, "bar2", &bar->bar2_vmm);
 	if (ret)
 		return ret;
 
-	atomic_inc(&vm->engref[NVKM_SUBDEV_BAR]);
+	atomic_inc(&bar->bar2_vmm->engref[NVKM_SUBDEV_BAR]);
+	bar->bar2_vmm->debug = bar->base.subdev.debug;
 
-	ret = nvkm_vm_boot(vm, limit-- - start);
+	ret = nvkm_vmm_boot(bar->bar2_vmm);
 	if (ret)
 		return ret;
 
-	ret = nvkm_vm_ref(vm, &bar->bar2_vm, bar->mem->memory);
-	nvkm_vm_ref(NULL, &vm, NULL);
+	ret = nvkm_vmm_join(bar->bar2_vmm, bar->mem->memory);
 	if (ret)
 		return ret;
 
@@ -166,14 +166,13 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 	start = 0x0000000000ULL;
 	limit = start + device->func->resource_size(device, 1);
 
-	ret = nvkm_vm_new(device, start, limit-- - start, start, &bar1_lock, &vm);
-	if (ret)
-		return ret;
+	ret = nvkm_vmm_new(device, start, limit-- - start, NULL, 0,
+			   &bar1_lock, "bar1", &bar->bar1_vmm);
 
-	atomic_inc(&vm->engref[NVKM_SUBDEV_BAR]);
+	atomic_inc(&bar->bar1_vmm->engref[NVKM_SUBDEV_BAR]);
+	bar->bar1_vmm->debug = bar->base.subdev.debug;
 
-	ret = nvkm_vm_ref(vm, &bar->bar1_vm, bar->mem->memory);
-	nvkm_vm_ref(NULL, &vm, NULL);
+	ret = nvkm_vmm_join(bar->bar1_vmm, bar->mem->memory);
 	if (ret)
 		return ret;
 
@@ -199,9 +198,11 @@ nv50_bar_dtor(struct nvkm_bar *base)
 	struct nv50_bar *bar = nv50_bar(base);
 	if (bar->mem) {
 		nvkm_gpuobj_del(&bar->bar1);
-		nvkm_vm_ref(NULL, &bar->bar1_vm, bar->mem->memory);
+		nvkm_vmm_part(bar->bar1_vmm, bar->mem->memory);
+		nvkm_vmm_unref(&bar->bar1_vmm);
 		nvkm_gpuobj_del(&bar->bar2);
-		nvkm_vm_ref(NULL, &bar->bar2_vm, bar->mem->memory);
+		nvkm_vmm_part(bar->bar2_vmm, bar->mem->memory);
+		nvkm_vmm_unref(&bar->bar2_vmm);
 		nvkm_gpuobj_del(&bar->pgd);
 		nvkm_gpuobj_del(&bar->pad);
 		nvkm_gpuobj_del(&bar->mem);

commit d30af7ce2c96e57b503da1d70454818331f0a6d5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/mmu: handle instance block setup
    
    We previously required each VMM user to allocate their own page directory
    and fill in the instance block themselves.
    
    It makes more sense to handle this in a common location.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index b40c131af20e..9300529917fc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -140,7 +140,7 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 	if (ret)
 		return ret;
 
-	ret = nvkm_vm_ref(vm, &bar->bar2_vm, bar->pgd);
+	ret = nvkm_vm_ref(vm, &bar->bar2_vm, bar->mem->memory);
 	nvkm_vm_ref(NULL, &vm, NULL);
 	if (ret)
 		return ret;
@@ -172,7 +172,7 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 
 	atomic_inc(&vm->engref[NVKM_SUBDEV_BAR]);
 
-	ret = nvkm_vm_ref(vm, &bar->bar1_vm, bar->pgd);
+	ret = nvkm_vm_ref(vm, &bar->bar1_vm, bar->mem->memory);
 	nvkm_vm_ref(NULL, &vm, NULL);
 	if (ret)
 		return ret;
@@ -197,13 +197,15 @@ void *
 nv50_bar_dtor(struct nvkm_bar *base)
 {
 	struct nv50_bar *bar = nv50_bar(base);
-	nvkm_gpuobj_del(&bar->bar1);
-	nvkm_vm_ref(NULL, &bar->bar1_vm, bar->pgd);
-	nvkm_gpuobj_del(&bar->bar2);
-	nvkm_vm_ref(NULL, &bar->bar2_vm, bar->pgd);
-	nvkm_gpuobj_del(&bar->pgd);
-	nvkm_gpuobj_del(&bar->pad);
-	nvkm_gpuobj_del(&bar->mem);
+	if (bar->mem) {
+		nvkm_gpuobj_del(&bar->bar1);
+		nvkm_vm_ref(NULL, &bar->bar1_vm, bar->mem->memory);
+		nvkm_gpuobj_del(&bar->bar2);
+		nvkm_vm_ref(NULL, &bar->bar2_vm, bar->mem->memory);
+		nvkm_gpuobj_del(&bar->pgd);
+		nvkm_gpuobj_del(&bar->pad);
+		nvkm_gpuobj_del(&bar->mem);
+	}
 	return bar;
 }
 

commit 5e075fdeb166098a3dc493026534c7631e845782
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/mmu: automatically handle "un-bootstrapping" of vmm
    
    Removes the need to expose internals outside of MMU, and GP100 is both
    different, and a lot harder to deal with.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 1aa6b5390d79..b40c131af20e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -200,10 +200,7 @@ nv50_bar_dtor(struct nvkm_bar *base)
 	nvkm_gpuobj_del(&bar->bar1);
 	nvkm_vm_ref(NULL, &bar->bar1_vm, bar->pgd);
 	nvkm_gpuobj_del(&bar->bar2);
-	if (bar->bar2_vm) {
-		nvkm_memory_unref(&bar->bar2_vm->pgt[0].mem[0]);
-		nvkm_vm_ref(NULL, &bar->bar2_vm, bar->pgd);
-	}
+	nvkm_vm_ref(NULL, &bar->bar2_vm, bar->pgd);
 	nvkm_gpuobj_del(&bar->pgd);
 	nvkm_gpuobj_del(&bar->pad);
 	nvkm_gpuobj_del(&bar->mem);

commit 997a89003c2d950466bc289147ffb823c0c51fb0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/core/memory: add reference counting
    
    We need to be able to prevent memory from being freed while it's still
    mapped in a GPU's address-space.
    
    Will be used by upcoming MMU changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index cf1d0acd2afc..1aa6b5390d79 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -201,7 +201,7 @@ nv50_bar_dtor(struct nvkm_bar *base)
 	nvkm_vm_ref(NULL, &bar->bar1_vm, bar->pgd);
 	nvkm_gpuobj_del(&bar->bar2);
 	if (bar->bar2_vm) {
-		nvkm_memory_del(&bar->bar2_vm->pgt[0].mem[0]);
+		nvkm_memory_unref(&bar->bar2_vm->pgt[0].mem[0]);
 		nvkm_vm_ref(NULL, &bar->bar2_vm, bar->pgd);
 	}
 	nvkm_gpuobj_del(&bar->pgd);

commit 8e644cb29c33dcd2fb718d78d8c33d4eb88cf6f7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: initialise bar2 during oneinit
    
    If we initialise BAR2 earlier, we're able to complete BAR1 setup using
    the instmem fast-path.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 4b912c905551..cf1d0acd2afc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -159,6 +159,9 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 	nvkm_wo32(bar->bar2, 0x14, 0x00000000);
 	nvkm_done(bar->bar2);
 
+	bar->base.subdev.oneinit = true;
+	nvkm_bar_bar2_init(device);
+
 	/* BAR1 */
 	start = 0x0000000000ULL;
 	limit = start + device->func->resource_size(device, 1);

commit a78dbce9a161a3a985b837bd07afd8651d42cabd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: modify interface to bar2 vmm mapping
    
    Match API with the BAR1 version.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 8020cc996d1a..4b912c905551 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -28,12 +28,6 @@
 #include <subdev/mmu.h>
 #include <subdev/timer.h>
 
-struct nvkm_vm *
-nv50_bar_kmap(struct nvkm_bar *base)
-{
-	return nv50_bar(base)->bar2_vm;
-}
-
 static void
 nv50_bar_flush(struct nvkm_bar *base)
 {
@@ -75,6 +69,12 @@ nv50_bar_bar1_init(struct nvkm_bar *base)
 	nvkm_wr32(device, 0x001708, 0x80000000 | bar->bar1->node->offset >> 4);
 }
 
+struct nvkm_vmm *
+nv50_bar_bar2_vmm(struct nvkm_bar *base)
+{
+	return nv50_bar(base)->bar2_vm;
+}
+
 void
 nv50_bar_bar2_fini(struct nvkm_bar *bar)
 {
@@ -232,7 +232,7 @@ nv50_bar_func = {
 	.bar2.init = nv50_bar_bar2_init,
 	.bar2.fini = nv50_bar_bar2_fini,
 	.bar2.wait = nv50_bar_bar1_wait,
-	.kmap = nv50_bar_kmap,
+	.bar2.vmm = nv50_bar_bar2_vmm,
 	.flush = nv50_bar_flush,
 };
 

commit 570889dc5070e1f98b5898dce426f970c9b9329b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: modify interface to bar1 vmm mapping
    
    Upcoming changes will remove the nvkm_vmm pointer from nvkm_vma, instead
    requiring it to be explicitly specified on each operation.
    
    It's not currently possible to get this information for BAR1 mappings,
    so let's fix that ahead of time.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 8d3f7ac42e02..8020cc996d1a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -34,13 +34,6 @@ nv50_bar_kmap(struct nvkm_bar *base)
 	return nv50_bar(base)->bar2_vm;
 }
 
-int
-nv50_bar_umap(struct nvkm_bar *base, u64 size, int type, struct nvkm_vma *vma)
-{
-	struct nv50_bar *bar = nv50_bar(base);
-	return nvkm_vm_get(bar->bar1_vm, size, type, NV_MEM_ACCESS_RW, vma);
-}
-
 static void
 nv50_bar_flush(struct nvkm_bar *base)
 {
@@ -56,6 +49,12 @@ nv50_bar_flush(struct nvkm_bar *base)
 	spin_unlock_irqrestore(&bar->base.lock, flags);
 }
 
+struct nvkm_vmm *
+nv50_bar_bar1_vmm(struct nvkm_bar *base)
+{
+	return nv50_bar(base)->bar1_vm;
+}
+
 void
 nv50_bar_bar1_wait(struct nvkm_bar *base)
 {
@@ -229,11 +228,11 @@ nv50_bar_func = {
 	.bar1.init = nv50_bar_bar1_init,
 	.bar1.fini = nv50_bar_bar1_fini,
 	.bar1.wait = nv50_bar_bar1_wait,
+	.bar1.vmm = nv50_bar_bar1_vmm,
 	.bar2.init = nv50_bar_bar2_init,
 	.bar2.fini = nv50_bar_bar2_fini,
 	.bar2.wait = nv50_bar_bar1_wait,
 	.kmap = nv50_bar_kmap,
-	.umap = nv50_bar_umap,
 	.flush = nv50_bar_flush,
 };
 

commit e988952eefd923a40cea1077bcb939025dafb0f1
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: expose interface to bar2 teardown
    
    Will prevent spurious MMU fault interrupts if something decides to touch
    BAR1 after we've unloaded the driver.
    
    Exposed external to BAR so that INSTMEM can use it to better control the
    suspend/resume fast-path access.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index d6d9a1d09722..8d3f7ac42e02 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -76,6 +76,12 @@ nv50_bar_bar1_init(struct nvkm_bar *base)
 	nvkm_wr32(device, 0x001708, 0x80000000 | bar->bar1->node->offset >> 4);
 }
 
+void
+nv50_bar_bar2_fini(struct nvkm_bar *bar)
+{
+	nvkm_wr32(bar->subdev.device, 0x00170c, 0x00000000);
+}
+
 void
 nv50_bar_bar2_init(struct nvkm_bar *base)
 {
@@ -224,6 +230,7 @@ nv50_bar_func = {
 	.bar1.fini = nv50_bar_bar1_fini,
 	.bar1.wait = nv50_bar_bar1_wait,
 	.bar2.init = nv50_bar_bar2_init,
+	.bar2.fini = nv50_bar_bar2_fini,
 	.bar2.wait = nv50_bar_bar1_wait,
 	.kmap = nv50_bar_kmap,
 	.umap = nv50_bar_umap,

commit 48fe02478a0ddb89930f3595f8217fa2dfd98796
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: expose interface to bar2 initialisation
    
    If we want to be able to hit the instmem fast-path in a few trickier cases,
    we need to be more flexible with when we can initialise BAR2 access.
    
    There's probably a decent case to be made for merging BAR/INSTMEM into BUS,
    but that's something to ponder another day.
    
    Flushes have been added after the write to bind the instance block,
    as later commits will reveal the need for them.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index c9776121a076..d6d9a1d09722 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -76,6 +76,16 @@ nv50_bar_bar1_init(struct nvkm_bar *base)
 	nvkm_wr32(device, 0x001708, 0x80000000 | bar->bar1->node->offset >> 4);
 }
 
+void
+nv50_bar_bar2_init(struct nvkm_bar *base)
+{
+	struct nvkm_device *device = base->subdev.device;
+	struct nv50_bar *bar = nv50_bar(base);
+	nvkm_wr32(device, 0x001704, 0x00000000 | bar->mem->addr >> 12);
+	nvkm_wr32(device, 0x001704, 0x40000000 | bar->mem->addr >> 12);
+	nvkm_wr32(device, 0x00170c, 0x80000000 | bar->bar2->node->offset >> 4);
+}
+
 void
 nv50_bar_init(struct nvkm_bar *base)
 {
@@ -83,9 +93,6 @@ nv50_bar_init(struct nvkm_bar *base)
 	struct nvkm_device *device = bar->base.subdev.device;
 	int i;
 
-	nvkm_wr32(device, 0x001704, 0x00000000 | bar->mem->addr >> 12);
-	nvkm_wr32(device, 0x001704, 0x40000000 | bar->mem->addr >> 12);
-	nvkm_wr32(device, 0x00170c, 0x80000000 | bar->bar2->node->offset >> 4);
 	for (i = 0; i < 8; i++)
 		nvkm_wr32(device, 0x001900 + (i * 4), 0x00000000);
 }
@@ -216,6 +223,8 @@ nv50_bar_func = {
 	.bar1.init = nv50_bar_bar1_init,
 	.bar1.fini = nv50_bar_bar1_fini,
 	.bar1.wait = nv50_bar_bar1_wait,
+	.bar2.init = nv50_bar_bar2_init,
+	.bar2.wait = nv50_bar_bar1_wait,
 	.kmap = nv50_bar_kmap,
 	.umap = nv50_bar_umap,
 	.flush = nv50_bar_flush,

commit bbb163e18960a90b0c5974fe448ad78a5df8e5d7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: implement bar1 teardown
    
    Will prevent spurious MMU fault interrupts if something decides to touch
    BAR1 after we've unloaded the driver.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 8cb8e721a515..c9776121a076 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -62,6 +62,12 @@ nv50_bar_bar1_wait(struct nvkm_bar *base)
 	nvkm_bar_flush(base);
 }
 
+void
+nv50_bar_bar1_fini(struct nvkm_bar *bar)
+{
+	nvkm_wr32(bar->subdev.device, 0x001708, 0x00000000);
+}
+
 void
 nv50_bar_bar1_init(struct nvkm_bar *base)
 {
@@ -208,6 +214,7 @@ nv50_bar_func = {
 	.oneinit = nv50_bar_oneinit,
 	.init = nv50_bar_init,
 	.bar1.init = nv50_bar_bar1_init,
+	.bar1.fini = nv50_bar_bar1_fini,
 	.bar1.wait = nv50_bar_bar1_wait,
 	.kmap = nv50_bar_kmap,
 	.umap = nv50_bar_umap,

commit 7313cfa4f6e30384fa04083698d1e865cf812a6a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: move bar1 initialisation into its own function
    
    BAR2 being done for practical reasons, this is just for consistency.
    
    Flushes have been added after the write to bind the instance block,
    as later commits will reveal the need for them.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 8a4c42f9a96a..8cb8e721a515 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -56,6 +56,20 @@ nv50_bar_flush(struct nvkm_bar *base)
 	spin_unlock_irqrestore(&bar->base.lock, flags);
 }
 
+void
+nv50_bar_bar1_wait(struct nvkm_bar *base)
+{
+	nvkm_bar_flush(base);
+}
+
+void
+nv50_bar_bar1_init(struct nvkm_bar *base)
+{
+	struct nvkm_device *device = base->subdev.device;
+	struct nv50_bar *bar = nv50_bar(base);
+	nvkm_wr32(device, 0x001708, 0x80000000 | bar->bar1->node->offset >> 4);
+}
+
 void
 nv50_bar_init(struct nvkm_bar *base)
 {
@@ -65,7 +79,6 @@ nv50_bar_init(struct nvkm_bar *base)
 
 	nvkm_wr32(device, 0x001704, 0x00000000 | bar->mem->addr >> 12);
 	nvkm_wr32(device, 0x001704, 0x40000000 | bar->mem->addr >> 12);
-	nvkm_wr32(device, 0x001708, 0x80000000 | bar->bar1->node->offset >> 4);
 	nvkm_wr32(device, 0x00170c, 0x80000000 | bar->bar2->node->offset >> 4);
 	for (i = 0; i < 8; i++)
 		nvkm_wr32(device, 0x001900 + (i * 4), 0x00000000);
@@ -194,6 +207,8 @@ nv50_bar_func = {
 	.dtor = nv50_bar_dtor,
 	.oneinit = nv50_bar_oneinit,
 	.init = nv50_bar_init,
+	.bar1.init = nv50_bar_bar1_init,
+	.bar1.wait = nv50_bar_bar1_wait,
 	.kmap = nv50_bar_kmap,
 	.umap = nv50_bar_umap,
 	.flush = nv50_bar_flush,

commit 269fe32d3343b7b9e48ba533887f58eb877581c8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: swap oneinit/init ordering, and rename bar3 to bar2
    
    NVIDIA call it BAR2, Linux APIs treat it as BAR3 due to BAR1 being a
    64-bit BAR, which I presume take two slots or something.
    
    No actual code changes here, just to make future commits less messy.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index aca65506cbc8..8a4c42f9a96a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -31,7 +31,7 @@
 struct nvkm_vm *
 nv50_bar_kmap(struct nvkm_bar *base)
 {
-	return nv50_bar(base)->bar3_vm;
+	return nv50_bar(base)->bar2_vm;
 }
 
 int
@@ -56,13 +56,28 @@ nv50_bar_flush(struct nvkm_bar *base)
 	spin_unlock_irqrestore(&bar->base.lock, flags);
 }
 
+void
+nv50_bar_init(struct nvkm_bar *base)
+{
+	struct nv50_bar *bar = nv50_bar(base);
+	struct nvkm_device *device = bar->base.subdev.device;
+	int i;
+
+	nvkm_wr32(device, 0x001704, 0x00000000 | bar->mem->addr >> 12);
+	nvkm_wr32(device, 0x001704, 0x40000000 | bar->mem->addr >> 12);
+	nvkm_wr32(device, 0x001708, 0x80000000 | bar->bar1->node->offset >> 4);
+	nvkm_wr32(device, 0x00170c, 0x80000000 | bar->bar2->node->offset >> 4);
+	for (i = 0; i < 8; i++)
+		nvkm_wr32(device, 0x001900 + (i * 4), 0x00000000);
+}
+
 int
 nv50_bar_oneinit(struct nvkm_bar *base)
 {
 	struct nv50_bar *bar = nv50_bar(base);
 	struct nvkm_device *device = bar->base.subdev.device;
 	static struct lock_class_key bar1_lock;
-	static struct lock_class_key bar3_lock;
+	static struct lock_class_key bar2_lock;
 	struct nvkm_vm *vm;
 	u64 start, limit;
 	int ret;
@@ -80,11 +95,11 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 	if (ret)
 		return ret;
 
-	/* BAR3 */
+	/* BAR2 */
 	start = 0x0100000000ULL;
 	limit = start + device->func->resource_size(device, 3);
 
-	ret = nvkm_vm_new(device, start, limit - start, start, &bar3_lock, &vm);
+	ret = nvkm_vm_new(device, start, limit - start, start, &bar2_lock, &vm);
 	if (ret)
 		return ret;
 
@@ -94,24 +109,24 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 	if (ret)
 		return ret;
 
-	ret = nvkm_vm_ref(vm, &bar->bar3_vm, bar->pgd);
+	ret = nvkm_vm_ref(vm, &bar->bar2_vm, bar->pgd);
 	nvkm_vm_ref(NULL, &vm, NULL);
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(device, 24, 16, false, bar->mem, &bar->bar3);
+	ret = nvkm_gpuobj_new(device, 24, 16, false, bar->mem, &bar->bar2);
 	if (ret)
 		return ret;
 
-	nvkm_kmap(bar->bar3);
-	nvkm_wo32(bar->bar3, 0x00, 0x7fc00000);
-	nvkm_wo32(bar->bar3, 0x04, lower_32_bits(limit));
-	nvkm_wo32(bar->bar3, 0x08, lower_32_bits(start));
-	nvkm_wo32(bar->bar3, 0x0c, upper_32_bits(limit) << 24 |
+	nvkm_kmap(bar->bar2);
+	nvkm_wo32(bar->bar2, 0x00, 0x7fc00000);
+	nvkm_wo32(bar->bar2, 0x04, lower_32_bits(limit));
+	nvkm_wo32(bar->bar2, 0x08, lower_32_bits(start));
+	nvkm_wo32(bar->bar2, 0x0c, upper_32_bits(limit) << 24 |
 				   upper_32_bits(start));
-	nvkm_wo32(bar->bar3, 0x10, 0x00000000);
-	nvkm_wo32(bar->bar3, 0x14, 0x00000000);
-	nvkm_done(bar->bar3);
+	nvkm_wo32(bar->bar2, 0x10, 0x00000000);
+	nvkm_wo32(bar->bar2, 0x14, 0x00000000);
+	nvkm_done(bar->bar2);
 
 	/* BAR1 */
 	start = 0x0000000000ULL;
@@ -144,31 +159,16 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 	return 0;
 }
 
-void
-nv50_bar_init(struct nvkm_bar *base)
-{
-	struct nv50_bar *bar = nv50_bar(base);
-	struct nvkm_device *device = bar->base.subdev.device;
-	int i;
-
-	nvkm_wr32(device, 0x001704, 0x00000000 | bar->mem->addr >> 12);
-	nvkm_wr32(device, 0x001704, 0x40000000 | bar->mem->addr >> 12);
-	nvkm_wr32(device, 0x001708, 0x80000000 | bar->bar1->node->offset >> 4);
-	nvkm_wr32(device, 0x00170c, 0x80000000 | bar->bar3->node->offset >> 4);
-	for (i = 0; i < 8; i++)
-		nvkm_wr32(device, 0x001900 + (i * 4), 0x00000000);
-}
-
 void *
 nv50_bar_dtor(struct nvkm_bar *base)
 {
 	struct nv50_bar *bar = nv50_bar(base);
 	nvkm_gpuobj_del(&bar->bar1);
 	nvkm_vm_ref(NULL, &bar->bar1_vm, bar->pgd);
-	nvkm_gpuobj_del(&bar->bar3);
-	if (bar->bar3_vm) {
-		nvkm_memory_del(&bar->bar3_vm->pgt[0].mem[0]);
-		nvkm_vm_ref(NULL, &bar->bar3_vm, bar->pgd);
+	nvkm_gpuobj_del(&bar->bar2);
+	if (bar->bar2_vm) {
+		nvkm_memory_del(&bar->bar2_vm->pgt[0].mem[0]);
+		nvkm_vm_ref(NULL, &bar->bar2_vm, bar->pgd);
 	}
 	nvkm_gpuobj_del(&bar->pgd);
 	nvkm_gpuobj_del(&bar->pad);

commit c9e70592963d1588da4a300209cd4913d12ae689
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: remove NV_PMC_ENABLE_PFIFO twiddling
    
    It's handled by FIFO preinit() now.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 4bfe6db006ac..aca65506cbc8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -151,9 +151,6 @@ nv50_bar_init(struct nvkm_bar *base)
 	struct nvkm_device *device = bar->base.subdev.device;
 	int i;
 
-	nvkm_mask(device, 0x000200, 0x00000100, 0x00000000);
-	nvkm_mask(device, 0x000200, 0x00000100, 0x00000100);
-
 	nvkm_wr32(device, 0x001704, 0x00000000 | bar->mem->addr >> 12);
 	nvkm_wr32(device, 0x001704, 0x40000000 | bar->mem->addr >> 12);
 	nvkm_wr32(device, 0x001708, 0x80000000 | bar->bar1->node->offset >> 4);

commit e69dae85c90b3e07ed5538a8ad8a7ee807fbbf64
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar/nv50,g84: drop mmu invalidate
    
    Will already be done by MMU as a result of the PT writes that occur
    during BAR2 bootstrapping.
    
    This is likely just a left-over from the days when it was hardcoded.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 6eff637ac301..4bfe6db006ac 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -144,7 +144,7 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 	return 0;
 }
 
-int
+void
 nv50_bar_init(struct nvkm_bar *base)
 {
 	struct nv50_bar *bar = nv50_bar(base);
@@ -153,12 +153,6 @@ nv50_bar_init(struct nvkm_bar *base)
 
 	nvkm_mask(device, 0x000200, 0x00000100, 0x00000000);
 	nvkm_mask(device, 0x000200, 0x00000100, 0x00000100);
-	nvkm_wr32(device, 0x100c80, 0x00060001);
-	if (nvkm_msec(device, 2000,
-		if (!(nvkm_rd32(device, 0x100c80) & 0x00000001))
-			break;
-	) < 0)
-		return -EBUSY;
 
 	nvkm_wr32(device, 0x001704, 0x00000000 | bar->mem->addr >> 12);
 	nvkm_wr32(device, 0x001704, 0x40000000 | bar->mem->addr >> 12);
@@ -166,7 +160,6 @@ nv50_bar_init(struct nvkm_bar *base)
 	nvkm_wr32(device, 0x00170c, 0x80000000 | bar->bar3->node->offset >> 4);
 	for (i = 0; i < 8; i++)
 		nvkm_wr32(device, 0x001900 + (i * 4), 0x00000000);
-	return 0;
 }
 
 void *

commit f9c0715e39f09bd5ea6f6357a4ce7a969b673007
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed May 11 16:28:30 2016 +1000

    drm/nouveau/bar/nv50: fix bar2 vm size
    
    The BAR2 page table was being made WAY too big - oops.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 370dcd8ff7b5..6eff637ac301 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -84,7 +84,7 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 	start = 0x0100000000ULL;
 	limit = start + device->func->resource_size(device, 3);
 
-	ret = nvkm_vm_new(device, start, limit, start, &bar3_lock, &vm);
+	ret = nvkm_vm_new(device, start, limit - start, start, &bar3_lock, &vm);
 	if (ret)
 		return ret;
 
@@ -117,7 +117,7 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 	start = 0x0000000000ULL;
 	limit = start + device->func->resource_size(device, 1);
 
-	ret = nvkm_vm_new(device, start, limit--, start, &bar1_lock, &vm);
+	ret = nvkm_vm_new(device, start, limit-- - start, start, &bar1_lock, &vm);
 	if (ret)
 		return ret;
 

commit 7e8820fed712c6de1933dcc91edbf08dcec74925
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:23 2015 +1000

    drm/nouveau/device: cleaner abstraction for device resource functions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index fac54f97217e..370dcd8ff7b5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -82,7 +82,7 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 
 	/* BAR3 */
 	start = 0x0100000000ULL;
-	limit = start + nv_device_resource_len(device, 3);
+	limit = start + device->func->resource_size(device, 3);
 
 	ret = nvkm_vm_new(device, start, limit, start, &bar3_lock, &vm);
 	if (ret)
@@ -115,7 +115,7 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 
 	/* BAR1 */
 	start = 0x0000000000ULL;
-	limit = start + nv_device_resource_len(device, 1);
+	limit = start + device->func->resource_size(device, 1);
 
 	ret = nvkm_vm_new(device, start, limit--, start, &bar1_lock, &vm);
 	if (ret)

commit 68f3f702b6a430a8d1e909455a60d26c0f2da530
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/core: remove the remainder of the previous style
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 65646fb917c1..fac54f97217e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -88,7 +88,7 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 	if (ret)
 		return ret;
 
-	atomic_inc(&vm->engref[NVDEV_SUBDEV_BAR]);
+	atomic_inc(&vm->engref[NVKM_SUBDEV_BAR]);
 
 	ret = nvkm_vm_boot(vm, limit-- - start);
 	if (ret)
@@ -121,7 +121,7 @@ nv50_bar_oneinit(struct nvkm_bar *base)
 	if (ret)
 		return ret;
 
-	atomic_inc(&vm->engref[NVDEV_SUBDEV_BAR]);
+	atomic_inc(&vm->engref[NVKM_SUBDEV_BAR]);
 
 	ret = nvkm_vm_ref(vm, &bar->bar1_vm, bar->pgd);
 	nvkm_vm_ref(NULL, &vm, NULL);

commit 3293228174e4d44cca56d809cc8409c3f88f8b90
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/bar: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index add132b2ed7a..65646fb917c1 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -21,100 +21,57 @@
  *
  * Authors: Ben Skeggs
  */
-#include "priv.h"
+#include "nv50.h"
 
 #include <core/gpuobj.h>
 #include <subdev/fb.h>
 #include <subdev/mmu.h>
 #include <subdev/timer.h>
 
-struct nv50_bar {
-	struct nvkm_bar base;
-	spinlock_t lock;
-	struct nvkm_gpuobj *mem;
-	struct nvkm_gpuobj *pad;
-	struct nvkm_gpuobj *pgd;
-	struct nvkm_vm *bar1_vm;
-	struct nvkm_gpuobj *bar1;
-	struct nvkm_vm *bar3_vm;
-	struct nvkm_gpuobj *bar3;
-};
-
-static struct nvkm_vm *
-nv50_bar_kmap(struct nvkm_bar *obj)
+struct nvkm_vm *
+nv50_bar_kmap(struct nvkm_bar *base)
 {
-	struct nv50_bar *bar = container_of(obj, typeof(*bar), base);
-	return bar->bar3_vm;
+	return nv50_bar(base)->bar3_vm;
 }
 
-static int
-nv50_bar_umap(struct nvkm_bar *obj, u64 size, int type, struct nvkm_vma *vma)
+int
+nv50_bar_umap(struct nvkm_bar *base, u64 size, int type, struct nvkm_vma *vma)
 {
-	struct nv50_bar *bar = container_of(obj, typeof(*bar), base);
+	struct nv50_bar *bar = nv50_bar(base);
 	return nvkm_vm_get(bar->bar1_vm, size, type, NV_MEM_ACCESS_RW, vma);
 }
 
 static void
-nv50_bar_unmap(struct nvkm_bar *bar, struct nvkm_vma *vma)
+nv50_bar_flush(struct nvkm_bar *base)
 {
-	nvkm_vm_unmap(vma);
-	nvkm_vm_put(vma);
-}
-
-static void
-nv50_bar_flush(struct nvkm_bar *obj)
-{
-	struct nv50_bar *bar = container_of(obj, typeof(*bar), base);
+	struct nv50_bar *bar = nv50_bar(base);
 	struct nvkm_device *device = bar->base.subdev.device;
 	unsigned long flags;
-	spin_lock_irqsave(&bar->lock, flags);
+	spin_lock_irqsave(&bar->base.lock, flags);
 	nvkm_wr32(device, 0x00330c, 0x00000001);
 	nvkm_msec(device, 2000,
 		if (!(nvkm_rd32(device, 0x00330c) & 0x00000002))
 			break;
 	);
-	spin_unlock_irqrestore(&bar->lock, flags);
+	spin_unlock_irqrestore(&bar->base.lock, flags);
 }
 
-void
-g84_bar_flush(struct nvkm_bar *obj)
+int
+nv50_bar_oneinit(struct nvkm_bar *base)
 {
-	struct nv50_bar *bar = container_of(obj, typeof(*bar), base);
+	struct nv50_bar *bar = nv50_bar(base);
 	struct nvkm_device *device = bar->base.subdev.device;
-	unsigned long flags;
-	spin_lock_irqsave(&bar->lock, flags);
-	nvkm_wr32(device, 0x070000, 0x00000001);
-	nvkm_msec(device, 2000,
-		if (!(nvkm_rd32(device, 0x070000) & 0x00000002))
-			break;
-	);
-	spin_unlock_irqrestore(&bar->lock, flags);
-}
-
-static int
-nv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-	      struct nvkm_oclass *oclass, void *data, u32 size,
-	      struct nvkm_object **pobject)
-{
 	static struct lock_class_key bar1_lock;
 	static struct lock_class_key bar3_lock;
-	struct nvkm_device *device = nv_device(parent);
 	struct nvkm_vm *vm;
-	struct nv50_bar *bar;
 	u64 start, limit;
 	int ret;
 
-	ret = nvkm_bar_create(parent, engine, oclass, &bar);
-	*pobject = nv_object(bar);
-	if (ret)
-		return ret;
-
 	ret = nvkm_gpuobj_new(device, 0x20000, 0, false, NULL, &bar->mem);
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(device, (device->chipset == 0x50) ?
-			      0x1400 : 0x200, 0, false, bar->mem,
+	ret = nvkm_gpuobj_new(device, bar->pgd_addr, 0, false, bar->mem,
 			      &bar->pad);
 	if (ret)
 		return ret;
@@ -184,45 +141,15 @@ nv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	nvkm_wo32(bar->bar1, 0x10, 0x00000000);
 	nvkm_wo32(bar->bar1, 0x14, 0x00000000);
 	nvkm_done(bar->bar1);
-
-	bar->base.kmap = nv50_bar_kmap;
-	bar->base.umap = nv50_bar_umap;
-	bar->base.unmap = nv50_bar_unmap;
-	if (device->chipset == 0x50)
-		bar->base.flush = nv50_bar_flush;
-	else
-		bar->base.flush = g84_bar_flush;
-	spin_lock_init(&bar->lock);
 	return 0;
 }
 
-static void
-nv50_bar_dtor(struct nvkm_object *object)
+int
+nv50_bar_init(struct nvkm_bar *base)
 {
-	struct nv50_bar *bar = (void *)object;
-	nvkm_gpuobj_del(&bar->bar1);
-	nvkm_vm_ref(NULL, &bar->bar1_vm, bar->pgd);
-	nvkm_gpuobj_del(&bar->bar3);
-	if (bar->bar3_vm) {
-		nvkm_memory_del(&bar->bar3_vm->pgt[0].mem[0]);
-		nvkm_vm_ref(NULL, &bar->bar3_vm, bar->pgd);
-	}
-	nvkm_gpuobj_del(&bar->pgd);
-	nvkm_gpuobj_del(&bar->pad);
-	nvkm_gpuobj_del(&bar->mem);
-	nvkm_bar_destroy(&bar->base);
-}
-
-static int
-nv50_bar_init(struct nvkm_object *object)
-{
-	struct nv50_bar *bar = (void *)object;
+	struct nv50_bar *bar = nv50_bar(base);
 	struct nvkm_device *device = bar->base.subdev.device;
-	int ret, i;
-
-	ret = nvkm_bar_init(&bar->base);
-	if (ret)
-		return ret;
+	int i;
 
 	nvkm_mask(device, 0x000200, 0x00000100, 0x00000000);
 	nvkm_mask(device, 0x000200, 0x00000100, 0x00000100);
@@ -242,20 +169,48 @@ nv50_bar_init(struct nvkm_object *object)
 	return 0;
 }
 
-static int
-nv50_bar_fini(struct nvkm_object *object, bool suspend)
+void *
+nv50_bar_dtor(struct nvkm_bar *base)
+{
+	struct nv50_bar *bar = nv50_bar(base);
+	nvkm_gpuobj_del(&bar->bar1);
+	nvkm_vm_ref(NULL, &bar->bar1_vm, bar->pgd);
+	nvkm_gpuobj_del(&bar->bar3);
+	if (bar->bar3_vm) {
+		nvkm_memory_del(&bar->bar3_vm->pgt[0].mem[0]);
+		nvkm_vm_ref(NULL, &bar->bar3_vm, bar->pgd);
+	}
+	nvkm_gpuobj_del(&bar->pgd);
+	nvkm_gpuobj_del(&bar->pad);
+	nvkm_gpuobj_del(&bar->mem);
+	return bar;
+}
+
+int
+nv50_bar_new_(const struct nvkm_bar_func *func, struct nvkm_device *device,
+	      int index, u32 pgd_addr, struct nvkm_bar **pbar)
 {
-	struct nv50_bar *bar = (void *)object;
-	return nvkm_bar_fini(&bar->base, suspend);
+	struct nv50_bar *bar;
+	if (!(bar = kzalloc(sizeof(*bar), GFP_KERNEL)))
+		return -ENOMEM;
+	nvkm_bar_ctor(func, device, index, &bar->base);
+	bar->pgd_addr = pgd_addr;
+	*pbar = &bar->base;
+	return 0;
 }
 
-struct nvkm_oclass
-nv50_bar_oclass = {
-	.handle = NV_SUBDEV(BAR, 0x50),
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = nv50_bar_ctor,
-		.dtor = nv50_bar_dtor,
-		.init = nv50_bar_init,
-		.fini = nv50_bar_fini,
-	},
+static const struct nvkm_bar_func
+nv50_bar_func = {
+	.dtor = nv50_bar_dtor,
+	.oneinit = nv50_bar_oneinit,
+	.init = nv50_bar_init,
+	.kmap = nv50_bar_kmap,
+	.umap = nv50_bar_umap,
+	.flush = nv50_bar_flush,
 };
+
+int
+nv50_bar_new(struct nvkm_device *device, int index, struct nvkm_bar **pbar)
+{
+	return nv50_bar_new_(&nv50_bar_func, device, index, 0x1400, pbar);
+}

commit f027f49166171c98d5945af12ac3ee9bc9f9bf4c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/gpuobj: separate allocation from nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 8e17b62fa1da..add132b2ed7a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -99,7 +99,6 @@ nv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	static struct lock_class_key bar1_lock;
 	static struct lock_class_key bar3_lock;
 	struct nvkm_device *device = nv_device(parent);
-	struct nvkm_object *heap;
 	struct nvkm_vm *vm;
 	struct nv50_bar *bar;
 	u64 start, limit;
@@ -110,19 +109,17 @@ nv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(nv_object(bar), NULL, 0x20000, 0,
-			      NVOBJ_FLAG_HEAP, &bar->mem);
-	heap = nv_object(bar->mem);
+	ret = nvkm_gpuobj_new(device, 0x20000, 0, false, NULL, &bar->mem);
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(nv_object(bar), heap,
-			      (device->chipset == 0x50) ? 0x1400 : 0x0200,
-			      0, 0, &bar->pad);
+	ret = nvkm_gpuobj_new(device, (device->chipset == 0x50) ?
+			      0x1400 : 0x200, 0, false, bar->mem,
+			      &bar->pad);
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(nv_object(bar), heap, 0x4000, 0, 0, &bar->pgd);
+	ret = nvkm_gpuobj_new(device, 0x4000, 0, false, bar->mem, &bar->pgd);
 	if (ret)
 		return ret;
 
@@ -145,7 +142,7 @@ nv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(nv_object(bar), heap, 24, 16, 0, &bar->bar3);
+	ret = nvkm_gpuobj_new(device, 24, 16, false, bar->mem, &bar->bar3);
 	if (ret)
 		return ret;
 
@@ -174,7 +171,7 @@ nv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(nv_object(bar), heap, 24, 16, 0, &bar->bar1);
+	ret = nvkm_gpuobj_new(device, 24, 16, false, bar->mem, &bar->bar1);
 	if (ret)
 		return ret;
 
@@ -203,16 +200,16 @@ static void
 nv50_bar_dtor(struct nvkm_object *object)
 {
 	struct nv50_bar *bar = (void *)object;
-	nvkm_gpuobj_ref(NULL, &bar->bar1);
+	nvkm_gpuobj_del(&bar->bar1);
 	nvkm_vm_ref(NULL, &bar->bar1_vm, bar->pgd);
-	nvkm_gpuobj_ref(NULL, &bar->bar3);
+	nvkm_gpuobj_del(&bar->bar3);
 	if (bar->bar3_vm) {
 		nvkm_memory_del(&bar->bar3_vm->pgt[0].mem[0]);
 		nvkm_vm_ref(NULL, &bar->bar3_vm, bar->pgd);
 	}
-	nvkm_gpuobj_ref(NULL, &bar->pgd);
-	nvkm_gpuobj_ref(NULL, &bar->pad);
-	nvkm_gpuobj_ref(NULL, &bar->mem);
+	nvkm_gpuobj_del(&bar->pgd);
+	nvkm_gpuobj_del(&bar->pad);
+	nvkm_gpuobj_del(&bar->mem);
 	nvkm_bar_destroy(&bar->base);
 }
 

commit d0659d3277cd7bf50e45d48f4692a7fbb11e5957
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/mmu: directly use instmem for page tables
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index ec864afc8862..8e17b62fa1da 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -207,7 +207,7 @@ nv50_bar_dtor(struct nvkm_object *object)
 	nvkm_vm_ref(NULL, &bar->bar1_vm, bar->pgd);
 	nvkm_gpuobj_ref(NULL, &bar->bar3);
 	if (bar->bar3_vm) {
-		nvkm_gpuobj_ref(NULL, &bar->bar3_vm->pgt[0].obj[0]);
+		nvkm_memory_del(&bar->bar3_vm->pgt[0].mem[0]);
 		nvkm_vm_ref(NULL, &bar->bar3_vm, bar->pgd);
 	}
 	nvkm_gpuobj_ref(NULL, &bar->pgd);

commit d8e83994aaf6749b7124a219f5b46bd1329e2a08
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/imem: improve management of instance memory
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index cb58cc5b2b57..ec864afc8862 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -40,34 +40,18 @@ struct nv50_bar {
 	struct nvkm_gpuobj *bar3;
 };
 
-static int
-nv50_bar_kmap(struct nvkm_bar *obj, struct nvkm_mem *mem, u32 flags,
-	      struct nvkm_vma *vma)
+static struct nvkm_vm *
+nv50_bar_kmap(struct nvkm_bar *obj)
 {
 	struct nv50_bar *bar = container_of(obj, typeof(*bar), base);
-	int ret;
-
-	ret = nvkm_vm_get(bar->bar3_vm, mem->size << 12, 12, flags, vma);
-	if (ret)
-		return ret;
-
-	nvkm_vm_map(vma, mem);
-	return 0;
+	return bar->bar3_vm;
 }
 
 static int
-nv50_bar_umap(struct nvkm_bar *obj, struct nvkm_mem *mem, u32 flags,
-	      struct nvkm_vma *vma)
+nv50_bar_umap(struct nvkm_bar *obj, u64 size, int type, struct nvkm_vma *vma)
 {
 	struct nv50_bar *bar = container_of(obj, typeof(*bar), base);
-	int ret;
-
-	ret = nvkm_vm_get(bar->bar1_vm, mem->size << 12, 12, flags, vma);
-	if (ret)
-		return ret;
-
-	nvkm_vm_map(vma, mem);
-	return 0;
+	return nvkm_vm_get(bar->bar1_vm, size, type, NV_MEM_ACCESS_RW, vma);
 }
 
 static void
@@ -152,10 +136,7 @@ nv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	atomic_inc(&vm->engref[NVDEV_SUBDEV_BAR]);
 
-	ret = nvkm_gpuobj_new(nv_object(bar), heap,
-			      ((limit-- - start) >> 12) * 8, 0x1000,
-			      NVOBJ_FLAG_ZERO_ALLOC, &vm->pgt[0].obj[0]);
-	vm->pgt[0].refcount[0] = 1;
+	ret = nvkm_vm_boot(vm, limit-- - start);
 	if (ret)
 		return ret;
 
@@ -207,7 +188,6 @@ nv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	nvkm_wo32(bar->bar1, 0x14, 0x00000000);
 	nvkm_done(bar->bar1);
 
-	bar->base.alloc = nvkm_bar_alloc;
 	bar->base.kmap = nv50_bar_kmap;
 	bar->base.umap = nv50_bar_umap;
 	bar->base.unmap = nv50_bar_unmap;

commit 1de68568d69ac518db076cc6118af91e930b5f90
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/mmu: protect each vm with its own mutex
    
    An upcoming commit requires being able to modify the PRAMIN BAR page
    tables while already holding the MMU subdev mutex.
    
    To solve this issue, each VM has been given its own mutex.  As a nice
    side-effect, this also allows separate VMs to be updated concurrently.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 6909e52a6d8d..cb58cc5b2b57 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -112,6 +112,8 @@ nv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	      struct nvkm_oclass *oclass, void *data, u32 size,
 	      struct nvkm_object **pobject)
 {
+	static struct lock_class_key bar1_lock;
+	static struct lock_class_key bar3_lock;
 	struct nvkm_device *device = nv_device(parent);
 	struct nvkm_object *heap;
 	struct nvkm_vm *vm;
@@ -144,7 +146,7 @@ nv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	start = 0x0100000000ULL;
 	limit = start + nv_device_resource_len(device, 3);
 
-	ret = nvkm_vm_new(device, start, limit, start, &vm);
+	ret = nvkm_vm_new(device, start, limit, start, &bar3_lock, &vm);
 	if (ret)
 		return ret;
 
@@ -180,7 +182,7 @@ nv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	start = 0x0000000000ULL;
 	limit = start + nv_device_resource_len(device, 1);
 
-	ret = nvkm_vm_new(device, start, limit--, start, &vm);
+	ret = nvkm_vm_new(device, start, limit--, start, &bar1_lock, &vm);
 	if (ret)
 		return ret;
 

commit 1918707556986e9460682845a2bf4055c43a8b65
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:14 2015 +1000

    drm/nouveau/bar: switch to gpuobj accessor macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index a47d64d3b0fd..6909e52a6d8d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -166,13 +166,15 @@ nv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	nv_wo32(bar->bar3, 0x00, 0x7fc00000);
-	nv_wo32(bar->bar3, 0x04, lower_32_bits(limit));
-	nv_wo32(bar->bar3, 0x08, lower_32_bits(start));
-	nv_wo32(bar->bar3, 0x0c, upper_32_bits(limit) << 24 |
-				  upper_32_bits(start));
-	nv_wo32(bar->bar3, 0x10, 0x00000000);
-	nv_wo32(bar->bar3, 0x14, 0x00000000);
+	nvkm_kmap(bar->bar3);
+	nvkm_wo32(bar->bar3, 0x00, 0x7fc00000);
+	nvkm_wo32(bar->bar3, 0x04, lower_32_bits(limit));
+	nvkm_wo32(bar->bar3, 0x08, lower_32_bits(start));
+	nvkm_wo32(bar->bar3, 0x0c, upper_32_bits(limit) << 24 |
+				   upper_32_bits(start));
+	nvkm_wo32(bar->bar3, 0x10, 0x00000000);
+	nvkm_wo32(bar->bar3, 0x14, 0x00000000);
+	nvkm_done(bar->bar3);
 
 	/* BAR1 */
 	start = 0x0000000000ULL;
@@ -193,13 +195,15 @@ nv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	nv_wo32(bar->bar1, 0x00, 0x7fc00000);
-	nv_wo32(bar->bar1, 0x04, lower_32_bits(limit));
-	nv_wo32(bar->bar1, 0x08, lower_32_bits(start));
-	nv_wo32(bar->bar1, 0x0c, upper_32_bits(limit) << 24 |
-				  upper_32_bits(start));
-	nv_wo32(bar->bar1, 0x10, 0x00000000);
-	nv_wo32(bar->bar1, 0x14, 0x00000000);
+	nvkm_kmap(bar->bar1);
+	nvkm_wo32(bar->bar1, 0x00, 0x7fc00000);
+	nvkm_wo32(bar->bar1, 0x04, lower_32_bits(limit));
+	nvkm_wo32(bar->bar1, 0x08, lower_32_bits(start));
+	nvkm_wo32(bar->bar1, 0x0c, upper_32_bits(limit) << 24 |
+				   upper_32_bits(start));
+	nvkm_wo32(bar->bar1, 0x10, 0x00000000);
+	nvkm_wo32(bar->bar1, 0x14, 0x00000000);
+	nvkm_done(bar->bar1);
 
 	bar->base.alloc = nvkm_bar_alloc;
 	bar->base.kmap = nv50_bar_kmap;

commit 4dd308f446c31e8f4a2b5033ba2de6f53f015114
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:10 2015 +1000

    drm/nouveau/bar: switch to new-style timer macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index dcfb11895a61..a47d64d3b0fd 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -85,8 +85,10 @@ nv50_bar_flush(struct nvkm_bar *obj)
 	unsigned long flags;
 	spin_lock_irqsave(&bar->lock, flags);
 	nvkm_wr32(device, 0x00330c, 0x00000001);
-	if (!nv_wait(bar, 0x00330c, 0x00000002, 0x00000000))
-		nv_warn(bar, "flush timeout\n");
+	nvkm_msec(device, 2000,
+		if (!(nvkm_rd32(device, 0x00330c) & 0x00000002))
+			break;
+	);
 	spin_unlock_irqrestore(&bar->lock, flags);
 }
 
@@ -98,8 +100,10 @@ g84_bar_flush(struct nvkm_bar *obj)
 	unsigned long flags;
 	spin_lock_irqsave(&bar->lock, flags);
 	nvkm_wr32(device, 0x070000, 0x00000001);
-	if (!nv_wait(bar, 0x070000, 0x00000002, 0x00000000))
-		nv_warn(bar, "flush timeout\n");
+	nvkm_msec(device, 2000,
+		if (!(nvkm_rd32(device, 0x070000) & 0x00000002))
+			break;
+	);
 	spin_unlock_irqrestore(&bar->lock, flags);
 }
 
@@ -240,10 +244,11 @@ nv50_bar_init(struct nvkm_object *object)
 	nvkm_mask(device, 0x000200, 0x00000100, 0x00000000);
 	nvkm_mask(device, 0x000200, 0x00000100, 0x00000100);
 	nvkm_wr32(device, 0x100c80, 0x00060001);
-	if (!nv_wait(bar, 0x100c80, 0x00000001, 0x00000000)) {
-		nv_error(bar, "vm flush timeout\n");
+	if (nvkm_msec(device, 2000,
+		if (!(nvkm_rd32(device, 0x100c80) & 0x00000001))
+			break;
+	) < 0)
 		return -EBUSY;
-	}
 
 	nvkm_wr32(device, 0x001704, 0x00000000 | bar->mem->addr >> 12);
 	nvkm_wr32(device, 0x001704, 0x40000000 | bar->mem->addr >> 12);

commit 9155c16214631e064d0d1edcd60a62347f823c80
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:08 2015 +1000

    drm/nouveau/bar: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 07f6b2a7d3c4..dcfb11895a61 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -81,9 +81,10 @@ static void
 nv50_bar_flush(struct nvkm_bar *obj)
 {
 	struct nv50_bar *bar = container_of(obj, typeof(*bar), base);
+	struct nvkm_device *device = bar->base.subdev.device;
 	unsigned long flags;
 	spin_lock_irqsave(&bar->lock, flags);
-	nv_wr32(bar, 0x00330c, 0x00000001);
+	nvkm_wr32(device, 0x00330c, 0x00000001);
 	if (!nv_wait(bar, 0x00330c, 0x00000002, 0x00000000))
 		nv_warn(bar, "flush timeout\n");
 	spin_unlock_irqrestore(&bar->lock, flags);
@@ -93,9 +94,10 @@ void
 g84_bar_flush(struct nvkm_bar *obj)
 {
 	struct nv50_bar *bar = container_of(obj, typeof(*bar), base);
+	struct nvkm_device *device = bar->base.subdev.device;
 	unsigned long flags;
 	spin_lock_irqsave(&bar->lock, flags);
-	nv_wr32(bar, 0x070000, 0x00000001);
+	nvkm_wr32(device, 0x070000, 0x00000001);
 	if (!nv_wait(bar, 0x070000, 0x00000002, 0x00000000))
 		nv_warn(bar, "flush timeout\n");
 	spin_unlock_irqrestore(&bar->lock, flags);
@@ -228,26 +230,27 @@ static int
 nv50_bar_init(struct nvkm_object *object)
 {
 	struct nv50_bar *bar = (void *)object;
+	struct nvkm_device *device = bar->base.subdev.device;
 	int ret, i;
 
 	ret = nvkm_bar_init(&bar->base);
 	if (ret)
 		return ret;
 
-	nv_mask(bar, 0x000200, 0x00000100, 0x00000000);
-	nv_mask(bar, 0x000200, 0x00000100, 0x00000100);
-	nv_wr32(bar, 0x100c80, 0x00060001);
+	nvkm_mask(device, 0x000200, 0x00000100, 0x00000000);
+	nvkm_mask(device, 0x000200, 0x00000100, 0x00000100);
+	nvkm_wr32(device, 0x100c80, 0x00060001);
 	if (!nv_wait(bar, 0x100c80, 0x00000001, 0x00000000)) {
 		nv_error(bar, "vm flush timeout\n");
 		return -EBUSY;
 	}
 
-	nv_wr32(bar, 0x001704, 0x00000000 | bar->mem->addr >> 12);
-	nv_wr32(bar, 0x001704, 0x40000000 | bar->mem->addr >> 12);
-	nv_wr32(bar, 0x001708, 0x80000000 | bar->bar1->node->offset >> 4);
-	nv_wr32(bar, 0x00170c, 0x80000000 | bar->bar3->node->offset >> 4);
+	nvkm_wr32(device, 0x001704, 0x00000000 | bar->mem->addr >> 12);
+	nvkm_wr32(device, 0x001704, 0x40000000 | bar->mem->addr >> 12);
+	nvkm_wr32(device, 0x001708, 0x80000000 | bar->bar1->node->offset >> 4);
+	nvkm_wr32(device, 0x00170c, 0x80000000 | bar->bar3->node->offset >> 4);
 	for (i = 0; i < 8; i++)
-		nv_wr32(bar, 0x001900 + (i * 4), 0x00000000);
+		nvkm_wr32(device, 0x001900 + (i * 4), 0x00000000);
 	return 0;
 }
 

commit 5b0c189fcb232daa1cabac8892e42cdee57254bd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/bar: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 36c5c083c1e9..07f6b2a7d3c4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -28,7 +28,7 @@
 #include <subdev/mmu.h>
 #include <subdev/timer.h>
 
-struct nv50_bar_priv {
+struct nv50_bar {
 	struct nvkm_bar base;
 	spinlock_t lock;
 	struct nvkm_gpuobj *mem;
@@ -41,13 +41,13 @@ struct nv50_bar_priv {
 };
 
 static int
-nv50_bar_kmap(struct nvkm_bar *bar, struct nvkm_mem *mem, u32 flags,
+nv50_bar_kmap(struct nvkm_bar *obj, struct nvkm_mem *mem, u32 flags,
 	      struct nvkm_vma *vma)
 {
-	struct nv50_bar_priv *priv = (void *)bar;
+	struct nv50_bar *bar = container_of(obj, typeof(*bar), base);
 	int ret;
 
-	ret = nvkm_vm_get(priv->bar3_vm, mem->size << 12, 12, flags, vma);
+	ret = nvkm_vm_get(bar->bar3_vm, mem->size << 12, 12, flags, vma);
 	if (ret)
 		return ret;
 
@@ -56,13 +56,13 @@ nv50_bar_kmap(struct nvkm_bar *bar, struct nvkm_mem *mem, u32 flags,
 }
 
 static int
-nv50_bar_umap(struct nvkm_bar *bar, struct nvkm_mem *mem, u32 flags,
+nv50_bar_umap(struct nvkm_bar *obj, struct nvkm_mem *mem, u32 flags,
 	      struct nvkm_vma *vma)
 {
-	struct nv50_bar_priv *priv = (void *)bar;
+	struct nv50_bar *bar = container_of(obj, typeof(*bar), base);
 	int ret;
 
-	ret = nvkm_vm_get(priv->bar1_vm, mem->size << 12, 12, flags, vma);
+	ret = nvkm_vm_get(bar->bar1_vm, mem->size << 12, 12, flags, vma);
 	if (ret)
 		return ret;
 
@@ -78,27 +78,27 @@ nv50_bar_unmap(struct nvkm_bar *bar, struct nvkm_vma *vma)
 }
 
 static void
-nv50_bar_flush(struct nvkm_bar *bar)
+nv50_bar_flush(struct nvkm_bar *obj)
 {
-	struct nv50_bar_priv *priv = (void *)bar;
+	struct nv50_bar *bar = container_of(obj, typeof(*bar), base);
 	unsigned long flags;
-	spin_lock_irqsave(&priv->lock, flags);
-	nv_wr32(priv, 0x00330c, 0x00000001);
-	if (!nv_wait(priv, 0x00330c, 0x00000002, 0x00000000))
-		nv_warn(priv, "flush timeout\n");
-	spin_unlock_irqrestore(&priv->lock, flags);
+	spin_lock_irqsave(&bar->lock, flags);
+	nv_wr32(bar, 0x00330c, 0x00000001);
+	if (!nv_wait(bar, 0x00330c, 0x00000002, 0x00000000))
+		nv_warn(bar, "flush timeout\n");
+	spin_unlock_irqrestore(&bar->lock, flags);
 }
 
 void
-g84_bar_flush(struct nvkm_bar *bar)
+g84_bar_flush(struct nvkm_bar *obj)
 {
-	struct nv50_bar_priv *priv = (void *)bar;
+	struct nv50_bar *bar = container_of(obj, typeof(*bar), base);
 	unsigned long flags;
-	spin_lock_irqsave(&priv->lock, flags);
+	spin_lock_irqsave(&bar->lock, flags);
 	nv_wr32(bar, 0x070000, 0x00000001);
-	if (!nv_wait(priv, 0x070000, 0x00000002, 0x00000000))
-		nv_warn(priv, "flush timeout\n");
-	spin_unlock_irqrestore(&priv->lock, flags);
+	if (!nv_wait(bar, 0x070000, 0x00000002, 0x00000000))
+		nv_warn(bar, "flush timeout\n");
+	spin_unlock_irqrestore(&bar->lock, flags);
 }
 
 static int
@@ -109,28 +109,28 @@ nv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	struct nvkm_device *device = nv_device(parent);
 	struct nvkm_object *heap;
 	struct nvkm_vm *vm;
-	struct nv50_bar_priv *priv;
+	struct nv50_bar *bar;
 	u64 start, limit;
 	int ret;
 
-	ret = nvkm_bar_create(parent, engine, oclass, &priv);
-	*pobject = nv_object(priv);
+	ret = nvkm_bar_create(parent, engine, oclass, &bar);
+	*pobject = nv_object(bar);
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(nv_object(priv), NULL, 0x20000, 0,
-			      NVOBJ_FLAG_HEAP, &priv->mem);
-	heap = nv_object(priv->mem);
+	ret = nvkm_gpuobj_new(nv_object(bar), NULL, 0x20000, 0,
+			      NVOBJ_FLAG_HEAP, &bar->mem);
+	heap = nv_object(bar->mem);
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(nv_object(priv), heap,
+	ret = nvkm_gpuobj_new(nv_object(bar), heap,
 			      (device->chipset == 0x50) ? 0x1400 : 0x0200,
-			      0, 0, &priv->pad);
+			      0, 0, &bar->pad);
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(nv_object(priv), heap, 0x4000, 0, 0, &priv->pgd);
+	ret = nvkm_gpuobj_new(nv_object(bar), heap, 0x4000, 0, 0, &bar->pgd);
 	if (ret)
 		return ret;
 
@@ -144,29 +144,29 @@ nv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	atomic_inc(&vm->engref[NVDEV_SUBDEV_BAR]);
 
-	ret = nvkm_gpuobj_new(nv_object(priv), heap,
+	ret = nvkm_gpuobj_new(nv_object(bar), heap,
 			      ((limit-- - start) >> 12) * 8, 0x1000,
 			      NVOBJ_FLAG_ZERO_ALLOC, &vm->pgt[0].obj[0]);
 	vm->pgt[0].refcount[0] = 1;
 	if (ret)
 		return ret;
 
-	ret = nvkm_vm_ref(vm, &priv->bar3_vm, priv->pgd);
+	ret = nvkm_vm_ref(vm, &bar->bar3_vm, bar->pgd);
 	nvkm_vm_ref(NULL, &vm, NULL);
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(nv_object(priv), heap, 24, 16, 0, &priv->bar3);
+	ret = nvkm_gpuobj_new(nv_object(bar), heap, 24, 16, 0, &bar->bar3);
 	if (ret)
 		return ret;
 
-	nv_wo32(priv->bar3, 0x00, 0x7fc00000);
-	nv_wo32(priv->bar3, 0x04, lower_32_bits(limit));
-	nv_wo32(priv->bar3, 0x08, lower_32_bits(start));
-	nv_wo32(priv->bar3, 0x0c, upper_32_bits(limit) << 24 |
+	nv_wo32(bar->bar3, 0x00, 0x7fc00000);
+	nv_wo32(bar->bar3, 0x04, lower_32_bits(limit));
+	nv_wo32(bar->bar3, 0x08, lower_32_bits(start));
+	nv_wo32(bar->bar3, 0x0c, upper_32_bits(limit) << 24 |
 				  upper_32_bits(start));
-	nv_wo32(priv->bar3, 0x10, 0x00000000);
-	nv_wo32(priv->bar3, 0x14, 0x00000000);
+	nv_wo32(bar->bar3, 0x10, 0x00000000);
+	nv_wo32(bar->bar3, 0x14, 0x00000000);
 
 	/* BAR1 */
 	start = 0x0000000000ULL;
@@ -178,84 +178,84 @@ nv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	atomic_inc(&vm->engref[NVDEV_SUBDEV_BAR]);
 
-	ret = nvkm_vm_ref(vm, &priv->bar1_vm, priv->pgd);
+	ret = nvkm_vm_ref(vm, &bar->bar1_vm, bar->pgd);
 	nvkm_vm_ref(NULL, &vm, NULL);
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(nv_object(priv), heap, 24, 16, 0, &priv->bar1);
+	ret = nvkm_gpuobj_new(nv_object(bar), heap, 24, 16, 0, &bar->bar1);
 	if (ret)
 		return ret;
 
-	nv_wo32(priv->bar1, 0x00, 0x7fc00000);
-	nv_wo32(priv->bar1, 0x04, lower_32_bits(limit));
-	nv_wo32(priv->bar1, 0x08, lower_32_bits(start));
-	nv_wo32(priv->bar1, 0x0c, upper_32_bits(limit) << 24 |
+	nv_wo32(bar->bar1, 0x00, 0x7fc00000);
+	nv_wo32(bar->bar1, 0x04, lower_32_bits(limit));
+	nv_wo32(bar->bar1, 0x08, lower_32_bits(start));
+	nv_wo32(bar->bar1, 0x0c, upper_32_bits(limit) << 24 |
 				  upper_32_bits(start));
-	nv_wo32(priv->bar1, 0x10, 0x00000000);
-	nv_wo32(priv->bar1, 0x14, 0x00000000);
+	nv_wo32(bar->bar1, 0x10, 0x00000000);
+	nv_wo32(bar->bar1, 0x14, 0x00000000);
 
-	priv->base.alloc = nvkm_bar_alloc;
-	priv->base.kmap = nv50_bar_kmap;
-	priv->base.umap = nv50_bar_umap;
-	priv->base.unmap = nv50_bar_unmap;
+	bar->base.alloc = nvkm_bar_alloc;
+	bar->base.kmap = nv50_bar_kmap;
+	bar->base.umap = nv50_bar_umap;
+	bar->base.unmap = nv50_bar_unmap;
 	if (device->chipset == 0x50)
-		priv->base.flush = nv50_bar_flush;
+		bar->base.flush = nv50_bar_flush;
 	else
-		priv->base.flush = g84_bar_flush;
-	spin_lock_init(&priv->lock);
+		bar->base.flush = g84_bar_flush;
+	spin_lock_init(&bar->lock);
 	return 0;
 }
 
 static void
 nv50_bar_dtor(struct nvkm_object *object)
 {
-	struct nv50_bar_priv *priv = (void *)object;
-	nvkm_gpuobj_ref(NULL, &priv->bar1);
-	nvkm_vm_ref(NULL, &priv->bar1_vm, priv->pgd);
-	nvkm_gpuobj_ref(NULL, &priv->bar3);
-	if (priv->bar3_vm) {
-		nvkm_gpuobj_ref(NULL, &priv->bar3_vm->pgt[0].obj[0]);
-		nvkm_vm_ref(NULL, &priv->bar3_vm, priv->pgd);
+	struct nv50_bar *bar = (void *)object;
+	nvkm_gpuobj_ref(NULL, &bar->bar1);
+	nvkm_vm_ref(NULL, &bar->bar1_vm, bar->pgd);
+	nvkm_gpuobj_ref(NULL, &bar->bar3);
+	if (bar->bar3_vm) {
+		nvkm_gpuobj_ref(NULL, &bar->bar3_vm->pgt[0].obj[0]);
+		nvkm_vm_ref(NULL, &bar->bar3_vm, bar->pgd);
 	}
-	nvkm_gpuobj_ref(NULL, &priv->pgd);
-	nvkm_gpuobj_ref(NULL, &priv->pad);
-	nvkm_gpuobj_ref(NULL, &priv->mem);
-	nvkm_bar_destroy(&priv->base);
+	nvkm_gpuobj_ref(NULL, &bar->pgd);
+	nvkm_gpuobj_ref(NULL, &bar->pad);
+	nvkm_gpuobj_ref(NULL, &bar->mem);
+	nvkm_bar_destroy(&bar->base);
 }
 
 static int
 nv50_bar_init(struct nvkm_object *object)
 {
-	struct nv50_bar_priv *priv = (void *)object;
+	struct nv50_bar *bar = (void *)object;
 	int ret, i;
 
-	ret = nvkm_bar_init(&priv->base);
+	ret = nvkm_bar_init(&bar->base);
 	if (ret)
 		return ret;
 
-	nv_mask(priv, 0x000200, 0x00000100, 0x00000000);
-	nv_mask(priv, 0x000200, 0x00000100, 0x00000100);
-	nv_wr32(priv, 0x100c80, 0x00060001);
-	if (!nv_wait(priv, 0x100c80, 0x00000001, 0x00000000)) {
-		nv_error(priv, "vm flush timeout\n");
+	nv_mask(bar, 0x000200, 0x00000100, 0x00000000);
+	nv_mask(bar, 0x000200, 0x00000100, 0x00000100);
+	nv_wr32(bar, 0x100c80, 0x00060001);
+	if (!nv_wait(bar, 0x100c80, 0x00000001, 0x00000000)) {
+		nv_error(bar, "vm flush timeout\n");
 		return -EBUSY;
 	}
 
-	nv_wr32(priv, 0x001704, 0x00000000 | priv->mem->addr >> 12);
-	nv_wr32(priv, 0x001704, 0x40000000 | priv->mem->addr >> 12);
-	nv_wr32(priv, 0x001708, 0x80000000 | priv->bar1->node->offset >> 4);
-	nv_wr32(priv, 0x00170c, 0x80000000 | priv->bar3->node->offset >> 4);
+	nv_wr32(bar, 0x001704, 0x00000000 | bar->mem->addr >> 12);
+	nv_wr32(bar, 0x001704, 0x40000000 | bar->mem->addr >> 12);
+	nv_wr32(bar, 0x001708, 0x80000000 | bar->bar1->node->offset >> 4);
+	nv_wr32(bar, 0x00170c, 0x80000000 | bar->bar3->node->offset >> 4);
 	for (i = 0; i < 8; i++)
-		nv_wr32(priv, 0x001900 + (i * 4), 0x00000000);
+		nv_wr32(bar, 0x001900 + (i * 4), 0x00000000);
 	return 0;
 }
 
 static int
 nv50_bar_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nv50_bar_priv *priv = (void *)object;
-	return nvkm_bar_fini(&priv->base, suspend);
+	struct nv50_bar *bar = (void *)object;
+	return nvkm_bar_fini(&bar->base, suspend);
 }
 
 struct nvkm_oclass

commit 9ace404b1098221021b01c2ba0eeea0c257fa4a5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/device: include core/device.h automatically for subdevs/engines
    
    Pretty much every subdev/engine is going to need access to nvkm_device
    shortly to touch registers and/or output messages.
    
    The odd placement of the includes is necessary to work around some
    inter-dependencies that currently exist.  This will be fixed later.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 8548adb91dcc..36c5c083c1e9 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -23,7 +23,6 @@
  */
 #include "priv.h"
 
-#include <core/device.h>
 #include <core/gpuobj.h>
 #include <subdev/fb.h>
 #include <subdev/mmu.h>

commit 9e79a85343e2191ac83f0ef4fe49b71b9d80ad38
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:12:11 2015 +1000

    drm/nouveau/timer: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 36c5c083c1e9..8548adb91dcc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -23,6 +23,7 @@
  */
 #include "priv.h"
 
+#include <core/device.h>
 #include <core/gpuobj.h>
 #include <subdev/fb.h>
 #include <subdev/mmu.h>

commit 245dcfe96f6900dbf64e48a350badf4c90fabc2e
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 14:35:35 2015 +1000

    drm/nouveau/bar: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index 6d0dd6a01e64..36c5c083c1e9 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -21,66 +21,64 @@
  *
  * Authors: Ben Skeggs
  */
+#include "priv.h"
 
 #include <core/gpuobj.h>
-
-#include <subdev/timer.h>
 #include <subdev/fb.h>
 #include <subdev/mmu.h>
-
-#include "priv.h"
+#include <subdev/timer.h>
 
 struct nv50_bar_priv {
-	struct nouveau_bar base;
+	struct nvkm_bar base;
 	spinlock_t lock;
-	struct nouveau_gpuobj *mem;
-	struct nouveau_gpuobj *pad;
-	struct nouveau_gpuobj *pgd;
-	struct nouveau_vm *bar1_vm;
-	struct nouveau_gpuobj *bar1;
-	struct nouveau_vm *bar3_vm;
-	struct nouveau_gpuobj *bar3;
+	struct nvkm_gpuobj *mem;
+	struct nvkm_gpuobj *pad;
+	struct nvkm_gpuobj *pgd;
+	struct nvkm_vm *bar1_vm;
+	struct nvkm_gpuobj *bar1;
+	struct nvkm_vm *bar3_vm;
+	struct nvkm_gpuobj *bar3;
 };
 
 static int
-nv50_bar_kmap(struct nouveau_bar *bar, struct nouveau_mem *mem,
-	      u32 flags, struct nouveau_vma *vma)
+nv50_bar_kmap(struct nvkm_bar *bar, struct nvkm_mem *mem, u32 flags,
+	      struct nvkm_vma *vma)
 {
 	struct nv50_bar_priv *priv = (void *)bar;
 	int ret;
 
-	ret = nouveau_vm_get(priv->bar3_vm, mem->size << 12, 12, flags, vma);
+	ret = nvkm_vm_get(priv->bar3_vm, mem->size << 12, 12, flags, vma);
 	if (ret)
 		return ret;
 
-	nouveau_vm_map(vma, mem);
+	nvkm_vm_map(vma, mem);
 	return 0;
 }
 
 static int
-nv50_bar_umap(struct nouveau_bar *bar, struct nouveau_mem *mem,
-	      u32 flags, struct nouveau_vma *vma)
+nv50_bar_umap(struct nvkm_bar *bar, struct nvkm_mem *mem, u32 flags,
+	      struct nvkm_vma *vma)
 {
 	struct nv50_bar_priv *priv = (void *)bar;
 	int ret;
 
-	ret = nouveau_vm_get(priv->bar1_vm, mem->size << 12, 12, flags, vma);
+	ret = nvkm_vm_get(priv->bar1_vm, mem->size << 12, 12, flags, vma);
 	if (ret)
 		return ret;
 
-	nouveau_vm_map(vma, mem);
+	nvkm_vm_map(vma, mem);
 	return 0;
 }
 
 static void
-nv50_bar_unmap(struct nouveau_bar *bar, struct nouveau_vma *vma)
+nv50_bar_unmap(struct nvkm_bar *bar, struct nvkm_vma *vma)
 {
-	nouveau_vm_unmap(vma);
-	nouveau_vm_put(vma);
+	nvkm_vm_unmap(vma);
+	nvkm_vm_put(vma);
 }
 
 static void
-nv50_bar_flush(struct nouveau_bar *bar)
+nv50_bar_flush(struct nvkm_bar *bar)
 {
 	struct nv50_bar_priv *priv = (void *)bar;
 	unsigned long flags;
@@ -92,7 +90,7 @@ nv50_bar_flush(struct nouveau_bar *bar)
 }
 
 void
-nv84_bar_flush(struct nouveau_bar *bar)
+g84_bar_flush(struct nvkm_bar *bar)
 {
 	struct nv50_bar_priv *priv = (void *)bar;
 	unsigned long flags;
@@ -104,36 +102,35 @@ nv84_bar_flush(struct nouveau_bar *bar)
 }
 
 static int
-nv50_bar_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
-	      struct nouveau_oclass *oclass, void *data, u32 size,
-	      struct nouveau_object **pobject)
+nv50_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+	      struct nvkm_oclass *oclass, void *data, u32 size,
+	      struct nvkm_object **pobject)
 {
-	struct nouveau_device *device = nv_device(parent);
-	struct nouveau_object *heap;
-	struct nouveau_vm *vm;
+	struct nvkm_device *device = nv_device(parent);
+	struct nvkm_object *heap;
+	struct nvkm_vm *vm;
 	struct nv50_bar_priv *priv;
 	u64 start, limit;
 	int ret;
 
-	ret = nouveau_bar_create(parent, engine, oclass, &priv);
+	ret = nvkm_bar_create(parent, engine, oclass, &priv);
 	*pobject = nv_object(priv);
 	if (ret)
 		return ret;
 
-	ret = nouveau_gpuobj_new(nv_object(priv), NULL, 0x20000, 0,
-				 NVOBJ_FLAG_HEAP, &priv->mem);
+	ret = nvkm_gpuobj_new(nv_object(priv), NULL, 0x20000, 0,
+			      NVOBJ_FLAG_HEAP, &priv->mem);
 	heap = nv_object(priv->mem);
 	if (ret)
 		return ret;
 
-	ret = nouveau_gpuobj_new(nv_object(priv), heap,
-				(device->chipset == 0x50) ? 0x1400 : 0x0200,
-				 0, 0, &priv->pad);
+	ret = nvkm_gpuobj_new(nv_object(priv), heap,
+			      (device->chipset == 0x50) ? 0x1400 : 0x0200,
+			      0, 0, &priv->pad);
 	if (ret)
 		return ret;
 
-	ret = nouveau_gpuobj_new(nv_object(priv), heap, 0x4000, 0,
-				 0, &priv->pgd);
+	ret = nvkm_gpuobj_new(nv_object(priv), heap, 0x4000, 0, 0, &priv->pgd);
 	if (ret)
 		return ret;
 
@@ -141,25 +138,25 @@ nv50_bar_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	start = 0x0100000000ULL;
 	limit = start + nv_device_resource_len(device, 3);
 
-	ret = nouveau_vm_new(device, start, limit, start, &vm);
+	ret = nvkm_vm_new(device, start, limit, start, &vm);
 	if (ret)
 		return ret;
 
 	atomic_inc(&vm->engref[NVDEV_SUBDEV_BAR]);
 
-	ret = nouveau_gpuobj_new(nv_object(priv), heap,
-				 ((limit-- - start) >> 12) * 8, 0x1000,
-				 NVOBJ_FLAG_ZERO_ALLOC, &vm->pgt[0].obj[0]);
+	ret = nvkm_gpuobj_new(nv_object(priv), heap,
+			      ((limit-- - start) >> 12) * 8, 0x1000,
+			      NVOBJ_FLAG_ZERO_ALLOC, &vm->pgt[0].obj[0]);
 	vm->pgt[0].refcount[0] = 1;
 	if (ret)
 		return ret;
 
-	ret = nouveau_vm_ref(vm, &priv->bar3_vm, priv->pgd);
-	nouveau_vm_ref(NULL, &vm, NULL);
+	ret = nvkm_vm_ref(vm, &priv->bar3_vm, priv->pgd);
+	nvkm_vm_ref(NULL, &vm, NULL);
 	if (ret)
 		return ret;
 
-	ret = nouveau_gpuobj_new(nv_object(priv), heap, 24, 16, 0, &priv->bar3);
+	ret = nvkm_gpuobj_new(nv_object(priv), heap, 24, 16, 0, &priv->bar3);
 	if (ret)
 		return ret;
 
@@ -175,18 +172,18 @@ nv50_bar_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	start = 0x0000000000ULL;
 	limit = start + nv_device_resource_len(device, 1);
 
-	ret = nouveau_vm_new(device, start, limit--, start, &vm);
+	ret = nvkm_vm_new(device, start, limit--, start, &vm);
 	if (ret)
 		return ret;
 
 	atomic_inc(&vm->engref[NVDEV_SUBDEV_BAR]);
 
-	ret = nouveau_vm_ref(vm, &priv->bar1_vm, priv->pgd);
-	nouveau_vm_ref(NULL, &vm, NULL);
+	ret = nvkm_vm_ref(vm, &priv->bar1_vm, priv->pgd);
+	nvkm_vm_ref(NULL, &vm, NULL);
 	if (ret)
 		return ret;
 
-	ret = nouveau_gpuobj_new(nv_object(priv), heap, 24, 16, 0, &priv->bar1);
+	ret = nvkm_gpuobj_new(nv_object(priv), heap, 24, 16, 0, &priv->bar1);
 	if (ret)
 		return ret;
 
@@ -198,42 +195,42 @@ nv50_bar_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	nv_wo32(priv->bar1, 0x10, 0x00000000);
 	nv_wo32(priv->bar1, 0x14, 0x00000000);
 
-	priv->base.alloc = nouveau_bar_alloc;
+	priv->base.alloc = nvkm_bar_alloc;
 	priv->base.kmap = nv50_bar_kmap;
 	priv->base.umap = nv50_bar_umap;
 	priv->base.unmap = nv50_bar_unmap;
 	if (device->chipset == 0x50)
 		priv->base.flush = nv50_bar_flush;
 	else
-		priv->base.flush = nv84_bar_flush;
+		priv->base.flush = g84_bar_flush;
 	spin_lock_init(&priv->lock);
 	return 0;
 }
 
 static void
-nv50_bar_dtor(struct nouveau_object *object)
+nv50_bar_dtor(struct nvkm_object *object)
 {
 	struct nv50_bar_priv *priv = (void *)object;
-	nouveau_gpuobj_ref(NULL, &priv->bar1);
-	nouveau_vm_ref(NULL, &priv->bar1_vm, priv->pgd);
-	nouveau_gpuobj_ref(NULL, &priv->bar3);
+	nvkm_gpuobj_ref(NULL, &priv->bar1);
+	nvkm_vm_ref(NULL, &priv->bar1_vm, priv->pgd);
+	nvkm_gpuobj_ref(NULL, &priv->bar3);
 	if (priv->bar3_vm) {
-		nouveau_gpuobj_ref(NULL, &priv->bar3_vm->pgt[0].obj[0]);
-		nouveau_vm_ref(NULL, &priv->bar3_vm, priv->pgd);
+		nvkm_gpuobj_ref(NULL, &priv->bar3_vm->pgt[0].obj[0]);
+		nvkm_vm_ref(NULL, &priv->bar3_vm, priv->pgd);
 	}
-	nouveau_gpuobj_ref(NULL, &priv->pgd);
-	nouveau_gpuobj_ref(NULL, &priv->pad);
-	nouveau_gpuobj_ref(NULL, &priv->mem);
-	nouveau_bar_destroy(&priv->base);
+	nvkm_gpuobj_ref(NULL, &priv->pgd);
+	nvkm_gpuobj_ref(NULL, &priv->pad);
+	nvkm_gpuobj_ref(NULL, &priv->mem);
+	nvkm_bar_destroy(&priv->base);
 }
 
 static int
-nv50_bar_init(struct nouveau_object *object)
+nv50_bar_init(struct nvkm_object *object)
 {
 	struct nv50_bar_priv *priv = (void *)object;
 	int ret, i;
 
-	ret = nouveau_bar_init(&priv->base);
+	ret = nvkm_bar_init(&priv->base);
 	if (ret)
 		return ret;
 
@@ -255,16 +252,16 @@ nv50_bar_init(struct nouveau_object *object)
 }
 
 static int
-nv50_bar_fini(struct nouveau_object *object, bool suspend)
+nv50_bar_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nv50_bar_priv *priv = (void *)object;
-	return nouveau_bar_fini(&priv->base, suspend);
+	return nvkm_bar_fini(&priv->base, suspend);
 }
 
-struct nouveau_oclass
+struct nvkm_oclass
 nv50_bar_oclass = {
 	.handle = NV_SUBDEV(BAR, 0x50),
-	.ofuncs = &(struct nouveau_ofuncs) {
+	.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = nv50_bar_ctor,
 		.dtor = nv50_bar_dtor,
 		.init = nv50_bar_init,

commit 5ce3bf3c72436c49fbd9a5b71d7d278665f4bf55
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 09:57:36 2015 +1000

    drm/nouveau/mmu: rename from vmmgr (no binary change)
    
    Switch to NVIDIA's name for the device.
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
index f748ba49dfc8..6d0dd6a01e64 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -26,7 +26,7 @@
 
 #include <subdev/timer.h>
 #include <subdev/fb.h>
-#include <subdev/vm.h>
+#include <subdev/mmu.h>
 
 #include "priv.h"
 

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
new file mode 100644
index 000000000000..f748ba49dfc8
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c
@@ -0,0 +1,273 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <core/gpuobj.h>
+
+#include <subdev/timer.h>
+#include <subdev/fb.h>
+#include <subdev/vm.h>
+
+#include "priv.h"
+
+struct nv50_bar_priv {
+	struct nouveau_bar base;
+	spinlock_t lock;
+	struct nouveau_gpuobj *mem;
+	struct nouveau_gpuobj *pad;
+	struct nouveau_gpuobj *pgd;
+	struct nouveau_vm *bar1_vm;
+	struct nouveau_gpuobj *bar1;
+	struct nouveau_vm *bar3_vm;
+	struct nouveau_gpuobj *bar3;
+};
+
+static int
+nv50_bar_kmap(struct nouveau_bar *bar, struct nouveau_mem *mem,
+	      u32 flags, struct nouveau_vma *vma)
+{
+	struct nv50_bar_priv *priv = (void *)bar;
+	int ret;
+
+	ret = nouveau_vm_get(priv->bar3_vm, mem->size << 12, 12, flags, vma);
+	if (ret)
+		return ret;
+
+	nouveau_vm_map(vma, mem);
+	return 0;
+}
+
+static int
+nv50_bar_umap(struct nouveau_bar *bar, struct nouveau_mem *mem,
+	      u32 flags, struct nouveau_vma *vma)
+{
+	struct nv50_bar_priv *priv = (void *)bar;
+	int ret;
+
+	ret = nouveau_vm_get(priv->bar1_vm, mem->size << 12, 12, flags, vma);
+	if (ret)
+		return ret;
+
+	nouveau_vm_map(vma, mem);
+	return 0;
+}
+
+static void
+nv50_bar_unmap(struct nouveau_bar *bar, struct nouveau_vma *vma)
+{
+	nouveau_vm_unmap(vma);
+	nouveau_vm_put(vma);
+}
+
+static void
+nv50_bar_flush(struct nouveau_bar *bar)
+{
+	struct nv50_bar_priv *priv = (void *)bar;
+	unsigned long flags;
+	spin_lock_irqsave(&priv->lock, flags);
+	nv_wr32(priv, 0x00330c, 0x00000001);
+	if (!nv_wait(priv, 0x00330c, 0x00000002, 0x00000000))
+		nv_warn(priv, "flush timeout\n");
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+void
+nv84_bar_flush(struct nouveau_bar *bar)
+{
+	struct nv50_bar_priv *priv = (void *)bar;
+	unsigned long flags;
+	spin_lock_irqsave(&priv->lock, flags);
+	nv_wr32(bar, 0x070000, 0x00000001);
+	if (!nv_wait(priv, 0x070000, 0x00000002, 0x00000000))
+		nv_warn(priv, "flush timeout\n");
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+static int
+nv50_bar_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+	      struct nouveau_oclass *oclass, void *data, u32 size,
+	      struct nouveau_object **pobject)
+{
+	struct nouveau_device *device = nv_device(parent);
+	struct nouveau_object *heap;
+	struct nouveau_vm *vm;
+	struct nv50_bar_priv *priv;
+	u64 start, limit;
+	int ret;
+
+	ret = nouveau_bar_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	ret = nouveau_gpuobj_new(nv_object(priv), NULL, 0x20000, 0,
+				 NVOBJ_FLAG_HEAP, &priv->mem);
+	heap = nv_object(priv->mem);
+	if (ret)
+		return ret;
+
+	ret = nouveau_gpuobj_new(nv_object(priv), heap,
+				(device->chipset == 0x50) ? 0x1400 : 0x0200,
+				 0, 0, &priv->pad);
+	if (ret)
+		return ret;
+
+	ret = nouveau_gpuobj_new(nv_object(priv), heap, 0x4000, 0,
+				 0, &priv->pgd);
+	if (ret)
+		return ret;
+
+	/* BAR3 */
+	start = 0x0100000000ULL;
+	limit = start + nv_device_resource_len(device, 3);
+
+	ret = nouveau_vm_new(device, start, limit, start, &vm);
+	if (ret)
+		return ret;
+
+	atomic_inc(&vm->engref[NVDEV_SUBDEV_BAR]);
+
+	ret = nouveau_gpuobj_new(nv_object(priv), heap,
+				 ((limit-- - start) >> 12) * 8, 0x1000,
+				 NVOBJ_FLAG_ZERO_ALLOC, &vm->pgt[0].obj[0]);
+	vm->pgt[0].refcount[0] = 1;
+	if (ret)
+		return ret;
+
+	ret = nouveau_vm_ref(vm, &priv->bar3_vm, priv->pgd);
+	nouveau_vm_ref(NULL, &vm, NULL);
+	if (ret)
+		return ret;
+
+	ret = nouveau_gpuobj_new(nv_object(priv), heap, 24, 16, 0, &priv->bar3);
+	if (ret)
+		return ret;
+
+	nv_wo32(priv->bar3, 0x00, 0x7fc00000);
+	nv_wo32(priv->bar3, 0x04, lower_32_bits(limit));
+	nv_wo32(priv->bar3, 0x08, lower_32_bits(start));
+	nv_wo32(priv->bar3, 0x0c, upper_32_bits(limit) << 24 |
+				  upper_32_bits(start));
+	nv_wo32(priv->bar3, 0x10, 0x00000000);
+	nv_wo32(priv->bar3, 0x14, 0x00000000);
+
+	/* BAR1 */
+	start = 0x0000000000ULL;
+	limit = start + nv_device_resource_len(device, 1);
+
+	ret = nouveau_vm_new(device, start, limit--, start, &vm);
+	if (ret)
+		return ret;
+
+	atomic_inc(&vm->engref[NVDEV_SUBDEV_BAR]);
+
+	ret = nouveau_vm_ref(vm, &priv->bar1_vm, priv->pgd);
+	nouveau_vm_ref(NULL, &vm, NULL);
+	if (ret)
+		return ret;
+
+	ret = nouveau_gpuobj_new(nv_object(priv), heap, 24, 16, 0, &priv->bar1);
+	if (ret)
+		return ret;
+
+	nv_wo32(priv->bar1, 0x00, 0x7fc00000);
+	nv_wo32(priv->bar1, 0x04, lower_32_bits(limit));
+	nv_wo32(priv->bar1, 0x08, lower_32_bits(start));
+	nv_wo32(priv->bar1, 0x0c, upper_32_bits(limit) << 24 |
+				  upper_32_bits(start));
+	nv_wo32(priv->bar1, 0x10, 0x00000000);
+	nv_wo32(priv->bar1, 0x14, 0x00000000);
+
+	priv->base.alloc = nouveau_bar_alloc;
+	priv->base.kmap = nv50_bar_kmap;
+	priv->base.umap = nv50_bar_umap;
+	priv->base.unmap = nv50_bar_unmap;
+	if (device->chipset == 0x50)
+		priv->base.flush = nv50_bar_flush;
+	else
+		priv->base.flush = nv84_bar_flush;
+	spin_lock_init(&priv->lock);
+	return 0;
+}
+
+static void
+nv50_bar_dtor(struct nouveau_object *object)
+{
+	struct nv50_bar_priv *priv = (void *)object;
+	nouveau_gpuobj_ref(NULL, &priv->bar1);
+	nouveau_vm_ref(NULL, &priv->bar1_vm, priv->pgd);
+	nouveau_gpuobj_ref(NULL, &priv->bar3);
+	if (priv->bar3_vm) {
+		nouveau_gpuobj_ref(NULL, &priv->bar3_vm->pgt[0].obj[0]);
+		nouveau_vm_ref(NULL, &priv->bar3_vm, priv->pgd);
+	}
+	nouveau_gpuobj_ref(NULL, &priv->pgd);
+	nouveau_gpuobj_ref(NULL, &priv->pad);
+	nouveau_gpuobj_ref(NULL, &priv->mem);
+	nouveau_bar_destroy(&priv->base);
+}
+
+static int
+nv50_bar_init(struct nouveau_object *object)
+{
+	struct nv50_bar_priv *priv = (void *)object;
+	int ret, i;
+
+	ret = nouveau_bar_init(&priv->base);
+	if (ret)
+		return ret;
+
+	nv_mask(priv, 0x000200, 0x00000100, 0x00000000);
+	nv_mask(priv, 0x000200, 0x00000100, 0x00000100);
+	nv_wr32(priv, 0x100c80, 0x00060001);
+	if (!nv_wait(priv, 0x100c80, 0x00000001, 0x00000000)) {
+		nv_error(priv, "vm flush timeout\n");
+		return -EBUSY;
+	}
+
+	nv_wr32(priv, 0x001704, 0x00000000 | priv->mem->addr >> 12);
+	nv_wr32(priv, 0x001704, 0x40000000 | priv->mem->addr >> 12);
+	nv_wr32(priv, 0x001708, 0x80000000 | priv->bar1->node->offset >> 4);
+	nv_wr32(priv, 0x00170c, 0x80000000 | priv->bar3->node->offset >> 4);
+	for (i = 0; i < 8; i++)
+		nv_wr32(priv, 0x001900 + (i * 4), 0x00000000);
+	return 0;
+}
+
+static int
+nv50_bar_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nv50_bar_priv *priv = (void *)object;
+	return nouveau_bar_fini(&priv->base, suspend);
+}
+
+struct nouveau_oclass
+nv50_bar_oclass = {
+	.handle = NV_SUBDEV(BAR, 0x50),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv50_bar_ctor,
+		.dtor = nv50_bar_dtor,
+		.init = nv50_bar_init,
+		.fini = nv50_bar_fini,
+	},
+};
