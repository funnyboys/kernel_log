commit 12e08beb32d64b6070b718630490db83dd321c8c
Author: Jon Derrick <jonathan.derrick@intel.com>
Date:   Fri Mar 15 18:05:17 2019 -0600

    drm/nouveau/bar/gf100: ensure BAR is mapped
    
    If the BAR is zero size, it indicates it was never successfully mapped.
    Ensure that the BAR is valid during initialization before attempting to
    use it.
    
    Signed-off-by: Jon Derrick <jonathan.derrick@intel.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index a3ba7f50198b..a3dcb09a40ee 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -94,6 +94,8 @@ gf100_bar_oneinit_bar(struct gf100_bar *bar, struct gf100_barN *bar_vm,
 		return ret;
 
 	bar_len = device->func->resource_size(device, bar_nr);
+	if (!bar_len)
+		return -ENOMEM;
 	if (bar_nr == 3 && bar->bar2_halve)
 		bar_len >>= 1;
 

commit 7eac5f4eb06a661ddee9b2ebb75799bf0c7cbf65
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar/gf100: initialise vmm with new interfaces
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 8077e1a5017a..a3ba7f50198b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -31,7 +31,7 @@
 struct nvkm_vmm *
 gf100_bar_bar1_vmm(struct nvkm_bar *base)
 {
-	return gf100_bar(base)->bar[1].vm;
+	return gf100_bar(base)->bar[1].vmm;
 }
 
 void
@@ -60,7 +60,7 @@ gf100_bar_bar1_init(struct nvkm_bar *base)
 struct nvkm_vmm *
 gf100_bar_bar2_vmm(struct nvkm_bar *base)
 {
-	return gf100_bar(base)->bar[0].vm;
+	return gf100_bar(base)->bar[0].vmm;
 }
 
 void
@@ -85,7 +85,6 @@ gf100_bar_oneinit_bar(struct gf100_bar *bar, struct gf100_barN *bar_vm,
 		      struct lock_class_key *key, int bar_nr)
 {
 	struct nvkm_device *device = bar->base.subdev.device;
-	struct nvkm_vm *vm;
 	resource_size_t bar_len;
 	int ret;
 
@@ -98,29 +97,24 @@ gf100_bar_oneinit_bar(struct gf100_bar *bar, struct gf100_barN *bar_vm,
 	if (bar_nr == 3 && bar->bar2_halve)
 		bar_len >>= 1;
 
-	ret = nvkm_vm_new(device, 0, bar_len, 0, key, &vm);
+	ret = nvkm_vmm_new(device, 0, bar_len, NULL, 0, key,
+			   (bar_nr == 3) ? "bar2" : "bar1", &bar_vm->vmm);
 	if (ret)
 		return ret;
 
-	atomic_inc(&vm->engref[NVKM_SUBDEV_BAR]);
+	atomic_inc(&bar_vm->vmm->engref[NVKM_SUBDEV_BAR]);
+	bar_vm->vmm->debug = bar->base.subdev.debug;
 
 	/*
 	 * Bootstrap page table lookup.
 	 */
 	if (bar_nr == 3) {
-		ret = nvkm_vm_boot(vm, bar_len);
-		if (ret) {
-			nvkm_vm_ref(NULL, &vm, NULL);
+		ret = nvkm_vmm_boot(bar_vm->vmm);
+		if (ret)
 			return ret;
-		}
 	}
 
-	ret = nvkm_vm_ref(vm, &bar_vm->vm, bar_vm->inst);
-	nvkm_vm_ref(NULL, &vm, NULL);
-	if (ret)
-		return ret;
-
-	return 0;
+	return nvkm_vmm_join(bar_vm->vmm, bar_vm->inst);
 }
 
 int
@@ -154,10 +148,12 @@ gf100_bar_dtor(struct nvkm_bar *base)
 {
 	struct gf100_bar *bar = gf100_bar(base);
 
-	nvkm_vm_ref(NULL, &bar->bar[1].vm, bar->bar[1].inst);
+	nvkm_vmm_part(bar->bar[1].vmm, bar->bar[1].inst);
+	nvkm_vmm_unref(&bar->bar[1].vmm);
 	nvkm_memory_unref(&bar->bar[1].inst);
 
-	nvkm_vm_ref(NULL, &bar->bar[0].vm, bar->bar[0].inst);
+	nvkm_vmm_part(bar->bar[0].vmm, bar->bar[0].inst);
+	nvkm_vmm_unref(&bar->bar[0].vmm);
 	nvkm_memory_unref(&bar->bar[0].inst);
 	return bar;
 }

commit d30af7ce2c96e57b503da1d70454818331f0a6d5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/mmu: handle instance block setup
    
    We previously required each VMM user to allocate their own page directory
    and fill in the instance block themselves.
    
    It makes more sense to handle this in a common location.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 8b588d1c776b..8077e1a5017a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -23,7 +23,7 @@
  */
 #include "gf100.h"
 
-#include <core/gpuobj.h>
+#include <core/memory.h>
 #include <core/option.h>
 #include <subdev/fb.h>
 #include <subdev/mmu.h>
@@ -53,7 +53,7 @@ gf100_bar_bar1_init(struct nvkm_bar *base)
 {
 	struct nvkm_device *device = base->subdev.device;
 	struct gf100_bar *bar = gf100_bar(base);
-	const u32 addr = nvkm_memory_addr(bar->bar[1].mem) >> 12;
+	const u32 addr = nvkm_memory_addr(bar->bar[1].inst) >> 12;
 	nvkm_wr32(device, 0x001704, 0x80000000 | addr);
 }
 
@@ -74,7 +74,7 @@ gf100_bar_bar2_init(struct nvkm_bar *base)
 {
 	struct nvkm_device *device = base->subdev.device;
 	struct gf100_bar *bar = gf100_bar(base);
-	u32 addr = nvkm_memory_addr(bar->bar[0].mem) >> 12;
+	u32 addr = nvkm_memory_addr(bar->bar[0].inst) >> 12;
 	if (bar->bar2_halve)
 		addr |= 0x40000000;
 	nvkm_wr32(device, 0x001714, 0x80000000 | addr);
@@ -90,11 +90,7 @@ gf100_bar_oneinit_bar(struct gf100_bar *bar, struct gf100_barN *bar_vm,
 	int ret;
 
 	ret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST, 0x1000, 0, false,
-			      &bar_vm->mem);
-	if (ret)
-		return ret;
-
-	ret = nvkm_gpuobj_new(device, 0x8000, 0, false, NULL, &bar_vm->pgd);
+			      &bar_vm->inst);
 	if (ret)
 		return ret;
 
@@ -119,17 +115,11 @@ gf100_bar_oneinit_bar(struct gf100_bar *bar, struct gf100_barN *bar_vm,
 		}
 	}
 
-	ret = nvkm_vm_ref(vm, &bar_vm->vm, bar_vm->pgd);
+	ret = nvkm_vm_ref(vm, &bar_vm->vm, bar_vm->inst);
 	nvkm_vm_ref(NULL, &vm, NULL);
 	if (ret)
 		return ret;
 
-	nvkm_kmap(bar_vm->mem);
-	nvkm_wo32(bar_vm->mem, 0x0200, lower_32_bits(bar_vm->pgd->addr));
-	nvkm_wo32(bar_vm->mem, 0x0204, upper_32_bits(bar_vm->pgd->addr));
-	nvkm_wo32(bar_vm->mem, 0x0208, lower_32_bits(bar_len - 1));
-	nvkm_wo32(bar_vm->mem, 0x020c, upper_32_bits(bar_len - 1));
-	nvkm_done(bar_vm->mem);
 	return 0;
 }
 
@@ -164,13 +154,11 @@ gf100_bar_dtor(struct nvkm_bar *base)
 {
 	struct gf100_bar *bar = gf100_bar(base);
 
-	nvkm_vm_ref(NULL, &bar->bar[1].vm, bar->bar[1].pgd);
-	nvkm_gpuobj_del(&bar->bar[1].pgd);
-	nvkm_memory_unref(&bar->bar[1].mem);
+	nvkm_vm_ref(NULL, &bar->bar[1].vm, bar->bar[1].inst);
+	nvkm_memory_unref(&bar->bar[1].inst);
 
-	nvkm_vm_ref(NULL, &bar->bar[0].vm, bar->bar[0].pgd);
-	nvkm_gpuobj_del(&bar->bar[0].pgd);
-	nvkm_memory_unref(&bar->bar[0].mem);
+	nvkm_vm_ref(NULL, &bar->bar[0].vm, bar->bar[0].inst);
+	nvkm_memory_unref(&bar->bar[0].inst);
 	return bar;
 }
 

commit 5e075fdeb166098a3dc493026534c7631e845782
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/mmu: automatically handle "un-bootstrapping" of vmm
    
    Removes the need to expose internals outside of MMU, and GP100 is both
    different, and a lot harder to deal with.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 9f7b4e7532b7..8b588d1c776b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -168,10 +168,7 @@ gf100_bar_dtor(struct nvkm_bar *base)
 	nvkm_gpuobj_del(&bar->bar[1].pgd);
 	nvkm_memory_unref(&bar->bar[1].mem);
 
-	if (bar->bar[0].vm) {
-		nvkm_memory_unref(&bar->bar[0].vm->pgt[0].mem[0]);
-		nvkm_vm_ref(NULL, &bar->bar[0].vm, bar->bar[0].pgd);
-	}
+	nvkm_vm_ref(NULL, &bar->bar[0].vm, bar->bar[0].pgd);
 	nvkm_gpuobj_del(&bar->bar[0].pgd);
 	nvkm_memory_unref(&bar->bar[0].mem);
 	return bar;

commit 997a89003c2d950466bc289147ffb823c0c51fb0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/core/memory: add reference counting
    
    We need to be able to prevent memory from being freed while it's still
    mapped in a GPU's address-space.
    
    Will be used by upcoming MMU changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index b155a7f76ca7..9f7b4e7532b7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -166,14 +166,14 @@ gf100_bar_dtor(struct nvkm_bar *base)
 
 	nvkm_vm_ref(NULL, &bar->bar[1].vm, bar->bar[1].pgd);
 	nvkm_gpuobj_del(&bar->bar[1].pgd);
-	nvkm_memory_del(&bar->bar[1].mem);
+	nvkm_memory_unref(&bar->bar[1].mem);
 
 	if (bar->bar[0].vm) {
-		nvkm_memory_del(&bar->bar[0].vm->pgt[0].mem[0]);
+		nvkm_memory_unref(&bar->bar[0].vm->pgt[0].mem[0]);
 		nvkm_vm_ref(NULL, &bar->bar[0].vm, bar->bar[0].pgd);
 	}
 	nvkm_gpuobj_del(&bar->bar[0].pgd);
-	nvkm_memory_del(&bar->bar[0].mem);
+	nvkm_memory_unref(&bar->bar[0].mem);
 	return bar;
 }
 

commit 8e644cb29c33dcd2fb718d78d8c33d4eb88cf6f7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: initialise bar2 during oneinit
    
    If we initialise BAR2 earlier, we're able to complete BAR1 setup using
    the instmem fast-path.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index c6317a0f04a7..b155a7f76ca7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -146,6 +146,9 @@ gf100_bar_oneinit(struct nvkm_bar *base)
 		ret = gf100_bar_oneinit_bar(bar, &bar->bar[0], &bar2_lock, 3);
 		if (ret)
 			return ret;
+
+		bar->base.subdev.oneinit = true;
+		nvkm_bar_bar2_init(bar->base.subdev.device);
 	}
 
 	/* BAR1 */

commit a78dbce9a161a3a985b837bd07afd8651d42cabd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: modify interface to bar2 vmm mapping
    
    Match API with the BAR1 version.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 379fa339dbaf..c6317a0f04a7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -28,12 +28,6 @@
 #include <subdev/fb.h>
 #include <subdev/mmu.h>
 
-static struct nvkm_vm *
-gf100_bar_kmap(struct nvkm_bar *base)
-{
-	return gf100_bar(base)->bar[0].vm;
-}
-
 struct nvkm_vmm *
 gf100_bar_bar1_vmm(struct nvkm_bar *base)
 {
@@ -63,6 +57,12 @@ gf100_bar_bar1_init(struct nvkm_bar *base)
 	nvkm_wr32(device, 0x001704, 0x80000000 | addr);
 }
 
+struct nvkm_vmm *
+gf100_bar_bar2_vmm(struct nvkm_bar *base)
+{
+	return gf100_bar(base)->bar[0].vm;
+}
+
 void
 gf100_bar_bar2_fini(struct nvkm_bar *bar)
 {
@@ -142,7 +142,7 @@ gf100_bar_oneinit(struct nvkm_bar *base)
 	int ret;
 
 	/* BAR2 */
-	if (bar->base.func->kmap) {
+	if (bar->base.func->bar2.init) {
 		ret = gf100_bar_oneinit_bar(bar, &bar->bar[0], &bar2_lock, 3);
 		if (ret)
 			return ret;
@@ -198,7 +198,7 @@ gf100_bar_func = {
 	.bar2.init = gf100_bar_bar2_init,
 	.bar2.fini = gf100_bar_bar2_fini,
 	.bar2.wait = gf100_bar_bar1_wait,
-	.kmap = gf100_bar_kmap,
+	.bar2.vmm = gf100_bar_bar2_vmm,
 	.flush = g84_bar_flush,
 };
 

commit 570889dc5070e1f98b5898dce426f970c9b9329b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: modify interface to bar1 vmm mapping
    
    Upcoming changes will remove the nvkm_vmm pointer from nvkm_vma, instead
    requiring it to be explicitly specified on each operation.
    
    It's not currently possible to get this information for BAR1 mappings,
    so let's fix that ahead of time.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 13d5a04f41df..379fa339dbaf 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -34,11 +34,10 @@ gf100_bar_kmap(struct nvkm_bar *base)
 	return gf100_bar(base)->bar[0].vm;
 }
 
-int
-gf100_bar_umap(struct nvkm_bar *base, u64 size, int type, struct nvkm_vma *vma)
+struct nvkm_vmm *
+gf100_bar_bar1_vmm(struct nvkm_bar *base)
 {
-	struct gf100_bar *bar = gf100_bar(base);
-	return nvkm_vm_get(bar->bar[1].vm, size, type, NV_MEM_ACCESS_RW, vma);
+	return gf100_bar(base)->bar[1].vm;
 }
 
 void
@@ -195,11 +194,11 @@ gf100_bar_func = {
 	.bar1.init = gf100_bar_bar1_init,
 	.bar1.fini = gf100_bar_bar1_fini,
 	.bar1.wait = gf100_bar_bar1_wait,
+	.bar1.vmm = gf100_bar_bar1_vmm,
 	.bar2.init = gf100_bar_bar2_init,
 	.bar2.fini = gf100_bar_bar2_fini,
 	.bar2.wait = gf100_bar_bar1_wait,
 	.kmap = gf100_bar_kmap,
-	.umap = gf100_bar_umap,
 	.flush = g84_bar_flush,
 };
 

commit e988952eefd923a40cea1077bcb939025dafb0f1
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: expose interface to bar2 teardown
    
    Will prevent spurious MMU fault interrupts if something decides to touch
    BAR1 after we've unloaded the driver.
    
    Exposed external to BAR so that INSTMEM can use it to better control the
    suspend/resume fast-path access.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 7504450972fa..13d5a04f41df 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -64,6 +64,12 @@ gf100_bar_bar1_init(struct nvkm_bar *base)
 	nvkm_wr32(device, 0x001704, 0x80000000 | addr);
 }
 
+void
+gf100_bar_bar2_fini(struct nvkm_bar *bar)
+{
+	nvkm_mask(bar->subdev.device, 0x001714, 0x80000000, 0x00000000);
+}
+
 void
 gf100_bar_bar2_init(struct nvkm_bar *base)
 {
@@ -190,6 +196,7 @@ gf100_bar_func = {
 	.bar1.fini = gf100_bar_bar1_fini,
 	.bar1.wait = gf100_bar_bar1_wait,
 	.bar2.init = gf100_bar_bar2_init,
+	.bar2.fini = gf100_bar_bar2_fini,
 	.bar2.wait = gf100_bar_bar1_wait,
 	.kmap = gf100_bar_kmap,
 	.umap = gf100_bar_umap,

commit 48fe02478a0ddb89930f3595f8217fa2dfd98796
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: expose interface to bar2 initialisation
    
    If we want to be able to hit the instmem fast-path in a few trickier cases,
    we need to be more flexible with when we can initialise BAR2 access.
    
    There's probably a decent case to be made for merging BAR/INSTMEM into BUS,
    but that's something to ponder another day.
    
    Flushes have been added after the write to bind the instance block,
    as later commits will reveal the need for them.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index fb57c0175e57..7504450972fa 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -65,18 +65,14 @@ gf100_bar_bar1_init(struct nvkm_bar *base)
 }
 
 void
-gf100_bar_init(struct nvkm_bar *base)
+gf100_bar_bar2_init(struct nvkm_bar *base)
 {
+	struct nvkm_device *device = base->subdev.device;
 	struct gf100_bar *bar = gf100_bar(base);
-	struct nvkm_device *device = bar->base.subdev.device;
-	u32 addr;
-
-	if (bar->bar[0].mem) {
-		addr = nvkm_memory_addr(bar->bar[0].mem) >> 12;
-		if (bar->bar2_halve)
-			addr |= 0x40000000;
-		nvkm_wr32(device, 0x001714, 0x80000000 | addr);
-	}
+	u32 addr = nvkm_memory_addr(bar->bar[0].mem) >> 12;
+	if (bar->bar2_halve)
+		addr |= 0x40000000;
+	nvkm_wr32(device, 0x001714, 0x80000000 | addr);
 }
 
 static int
@@ -190,10 +186,11 @@ static const struct nvkm_bar_func
 gf100_bar_func = {
 	.dtor = gf100_bar_dtor,
 	.oneinit = gf100_bar_oneinit,
-	.init = gf100_bar_init,
 	.bar1.init = gf100_bar_bar1_init,
 	.bar1.fini = gf100_bar_bar1_fini,
 	.bar1.wait = gf100_bar_bar1_wait,
+	.bar2.init = gf100_bar_bar2_init,
+	.bar2.wait = gf100_bar_bar1_wait,
 	.kmap = gf100_bar_kmap,
 	.umap = gf100_bar_umap,
 	.flush = g84_bar_flush,

commit bbb163e18960a90b0c5974fe448ad78a5df8e5d7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: implement bar1 teardown
    
    Will prevent spurious MMU fault interrupts if something decides to touch
    BAR1 after we've unloaded the driver.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index fc3d771cef50..fb57c0175e57 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -49,6 +49,12 @@ gf100_bar_bar1_wait(struct nvkm_bar *base)
 	nvkm_bar_flush(base);
 }
 
+void
+gf100_bar_bar1_fini(struct nvkm_bar *bar)
+{
+	nvkm_mask(bar->subdev.device, 0x001704, 0x80000000, 0x00000000);
+}
+
 void
 gf100_bar_bar1_init(struct nvkm_bar *base)
 {
@@ -186,6 +192,7 @@ gf100_bar_func = {
 	.oneinit = gf100_bar_oneinit,
 	.init = gf100_bar_init,
 	.bar1.init = gf100_bar_bar1_init,
+	.bar1.fini = gf100_bar_bar1_fini,
 	.bar1.wait = gf100_bar_bar1_wait,
 	.kmap = gf100_bar_kmap,
 	.umap = gf100_bar_umap,

commit 7313cfa4f6e30384fa04083698d1e865cf812a6a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: move bar1 initialisation into its own function
    
    BAR2 being done for practical reasons, this is just for consistency.
    
    Flushes have been added after the write to bind the instance block,
    as later commits will reveal the need for them.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index d2496cd736fa..fc3d771cef50 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -41,6 +41,23 @@ gf100_bar_umap(struct nvkm_bar *base, u64 size, int type, struct nvkm_vma *vma)
 	return nvkm_vm_get(bar->bar[1].vm, size, type, NV_MEM_ACCESS_RW, vma);
 }
 
+void
+gf100_bar_bar1_wait(struct nvkm_bar *base)
+{
+	/* NFI why it's twice. */
+	nvkm_bar_flush(base);
+	nvkm_bar_flush(base);
+}
+
+void
+gf100_bar_bar1_init(struct nvkm_bar *base)
+{
+	struct nvkm_device *device = base->subdev.device;
+	struct gf100_bar *bar = gf100_bar(base);
+	const u32 addr = nvkm_memory_addr(bar->bar[1].mem) >> 12;
+	nvkm_wr32(device, 0x001704, 0x80000000 | addr);
+}
+
 void
 gf100_bar_init(struct nvkm_bar *base)
 {
@@ -48,9 +65,6 @@ gf100_bar_init(struct nvkm_bar *base)
 	struct nvkm_device *device = bar->base.subdev.device;
 	u32 addr;
 
-	addr = nvkm_memory_addr(bar->bar[1].mem) >> 12;
-	nvkm_wr32(device, 0x001704, 0x80000000 | addr);
-
 	if (bar->bar[0].mem) {
 		addr = nvkm_memory_addr(bar->bar[0].mem) >> 12;
 		if (bar->bar2_halve)
@@ -171,6 +185,8 @@ gf100_bar_func = {
 	.dtor = gf100_bar_dtor,
 	.oneinit = gf100_bar_oneinit,
 	.init = gf100_bar_init,
+	.bar1.init = gf100_bar_bar1_init,
+	.bar1.wait = gf100_bar_bar1_wait,
 	.kmap = gf100_bar_kmap,
 	.umap = gf100_bar_umap,
 	.flush = g84_bar_flush,

commit 269fe32d3343b7b9e48ba533887f58eb877581c8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: swap oneinit/init ordering, and rename bar3 to bar2
    
    NVIDIA call it BAR2, Linux APIs treat it as BAR3 due to BAR1 being a
    64-bit BAR, which I presume take two slots or something.
    
    No actual code changes here, just to make future commits less messy.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 3a6b2e4c66ba..d2496cd736fa 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -41,9 +41,27 @@ gf100_bar_umap(struct nvkm_bar *base, u64 size, int type, struct nvkm_vma *vma)
 	return nvkm_vm_get(bar->bar[1].vm, size, type, NV_MEM_ACCESS_RW, vma);
 }
 
+void
+gf100_bar_init(struct nvkm_bar *base)
+{
+	struct gf100_bar *bar = gf100_bar(base);
+	struct nvkm_device *device = bar->base.subdev.device;
+	u32 addr;
+
+	addr = nvkm_memory_addr(bar->bar[1].mem) >> 12;
+	nvkm_wr32(device, 0x001704, 0x80000000 | addr);
+
+	if (bar->bar[0].mem) {
+		addr = nvkm_memory_addr(bar->bar[0].mem) >> 12;
+		if (bar->bar2_halve)
+			addr |= 0x40000000;
+		nvkm_wr32(device, 0x001714, 0x80000000 | addr);
+	}
+}
+
 static int
-gf100_bar_ctor_vm(struct gf100_bar *bar, struct gf100_bar_vm *bar_vm,
-		  struct lock_class_key *key, int bar_nr)
+gf100_bar_oneinit_bar(struct gf100_bar *bar, struct gf100_barN *bar_vm,
+		      struct lock_class_key *key, int bar_nr)
 {
 	struct nvkm_device *device = bar->base.subdev.device;
 	struct nvkm_vm *vm;
@@ -98,43 +116,25 @@ int
 gf100_bar_oneinit(struct nvkm_bar *base)
 {
 	static struct lock_class_key bar1_lock;
-	static struct lock_class_key bar3_lock;
+	static struct lock_class_key bar2_lock;
 	struct gf100_bar *bar = gf100_bar(base);
 	int ret;
 
-	/* BAR3 */
+	/* BAR2 */
 	if (bar->base.func->kmap) {
-		ret = gf100_bar_ctor_vm(bar, &bar->bar[0], &bar3_lock, 3);
+		ret = gf100_bar_oneinit_bar(bar, &bar->bar[0], &bar2_lock, 3);
 		if (ret)
 			return ret;
 	}
 
 	/* BAR1 */
-	ret = gf100_bar_ctor_vm(bar, &bar->bar[1], &bar1_lock, 1);
+	ret = gf100_bar_oneinit_bar(bar, &bar->bar[1], &bar1_lock, 1);
 	if (ret)
 		return ret;
 
 	return 0;
 }
 
-void
-gf100_bar_init(struct nvkm_bar *base)
-{
-	struct gf100_bar *bar = gf100_bar(base);
-	struct nvkm_device *device = bar->base.subdev.device;
-	u32 addr;
-
-	addr = nvkm_memory_addr(bar->bar[1].mem) >> 12;
-	nvkm_wr32(device, 0x001704, 0x80000000 | addr);
-
-	if (bar->bar[0].mem) {
-		addr = nvkm_memory_addr(bar->bar[0].mem) >> 12;
-		if (bar->bar2_halve)
-			addr |= 0x40000000;
-		nvkm_wr32(device, 0x001714, 0x80000000 | addr);
-	}
-}
-
 void *
 gf100_bar_dtor(struct nvkm_bar *base)
 {

commit c9e70592963d1588da4a300209cd4913d12ae689
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar: remove NV_PMC_ENABLE_PFIFO twiddling
    
    It's handled by FIFO preinit() now.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 1befe4464155..3a6b2e4c66ba 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -124,9 +124,6 @@ gf100_bar_init(struct nvkm_bar *base)
 	struct nvkm_device *device = bar->base.subdev.device;
 	u32 addr;
 
-	nvkm_mask(device, 0x000200, 0x00000100, 0x00000000);
-	nvkm_mask(device, 0x000200, 0x00000100, 0x00000100);
-
 	addr = nvkm_memory_addr(bar->bar[1].mem) >> 12;
 	nvkm_wr32(device, 0x001704, 0x80000000 | addr);
 

commit e69dae85c90b3e07ed5538a8ad8a7ee807fbbf64
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bar/nv50,g84: drop mmu invalidate
    
    Will already be done by MMU as a result of the PT writes that occur
    during BAR2 bootstrapping.
    
    This is likely just a left-over from the days when it was hardcoded.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 676c167c95b9..1befe4464155 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -117,7 +117,7 @@ gf100_bar_oneinit(struct nvkm_bar *base)
 	return 0;
 }
 
-int
+void
 gf100_bar_init(struct nvkm_bar *base)
 {
 	struct gf100_bar *bar = gf100_bar(base);
@@ -136,8 +136,6 @@ gf100_bar_init(struct nvkm_bar *base)
 			addr |= 0x40000000;
 		nvkm_wr32(device, 0x001714, 0x80000000 | addr);
 	}
-
-	return 0;
 }
 
 void *

commit 485c2c91d403185c126dd18bfc98599be9db3acf
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Aug 4 10:44:34 2017 +1000

    drm/nouveau/bar/gf100: add config option to limit BAR2 to 16MiB
    
    Useful for testing, and for the userspace build where we can't kick
    a framebuffer driver off the device.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 6d8f21290aa2..676c167c95b9 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -24,6 +24,7 @@
 #include "gf100.h"
 
 #include <core/gpuobj.h>
+#include <core/option.h>
 #include <subdev/fb.h>
 #include <subdev/mmu.h>
 
@@ -59,6 +60,8 @@ gf100_bar_ctor_vm(struct gf100_bar *bar, struct gf100_bar_vm *bar_vm,
 		return ret;
 
 	bar_len = device->func->resource_size(device, bar_nr);
+	if (bar_nr == 3 && bar->bar2_halve)
+		bar_len >>= 1;
 
 	ret = nvkm_vm_new(device, 0, bar_len, 0, key, &vm);
 	if (ret)
@@ -129,6 +132,8 @@ gf100_bar_init(struct nvkm_bar *base)
 
 	if (bar->bar[0].mem) {
 		addr = nvkm_memory_addr(bar->bar[0].mem) >> 12;
+		if (bar->bar2_halve)
+			addr |= 0x40000000;
 		nvkm_wr32(device, 0x001714, 0x80000000 | addr);
 	}
 
@@ -161,6 +166,7 @@ gf100_bar_new_(const struct nvkm_bar_func *func, struct nvkm_device *device,
 	if (!(bar = kzalloc(sizeof(*bar), GFP_KERNEL)))
 		return -ENOMEM;
 	nvkm_bar_ctor(func, device, index, &bar->base);
+	bar->bar2_halve = nvkm_boolopt(device->cfgopt, "NvBar2Halve", false);
 	*pbar = &bar->base;
 	return 0;
 }

commit 38bcb208f60924a031b9f809f7cd252ea4a94e5f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jul 25 11:06:47 2017 +1000

    drm/nouveau/bar/gf100: fix access to upper half of BAR2
    
    Bit 30 being set causes the upper half of BAR2 to stay in physical mode,
    mapped over the end of VRAM, even when the rest of the BAR has been set
    to virtual mode.
    
    We inherited our initial value from RM, but I'm not aware of any reason
    we need to keep it that way.
    
    This fixes severe GPU hang/lockup issues revealed by Wayland on F26.
    
    Shout-out to NVIDIA for the quick response with the potential cause!
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Cc: stable@vger.kernel.org # 4.3+

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index c794b2c2d21e..6d8f21290aa2 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -129,7 +129,7 @@ gf100_bar_init(struct nvkm_bar *base)
 
 	if (bar->bar[0].mem) {
 		addr = nvkm_memory_addr(bar->bar[0].mem) >> 12;
-		nvkm_wr32(device, 0x001714, 0xc0000000 | addr);
+		nvkm_wr32(device, 0x001714, 0x80000000 | addr);
 	}
 
 	return 0;

commit 7e8820fed712c6de1933dcc91edbf08dcec74925
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:23 2015 +1000

    drm/nouveau/device: cleaner abstraction for device resource functions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 2eb0a370a3a0..c794b2c2d21e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -58,7 +58,7 @@ gf100_bar_ctor_vm(struct gf100_bar *bar, struct gf100_bar_vm *bar_vm,
 	if (ret)
 		return ret;
 
-	bar_len = nv_device_resource_len(device, bar_nr);
+	bar_len = device->func->resource_size(device, bar_nr);
 
 	ret = nvkm_vm_new(device, 0, bar_len, 0, key, &vm);
 	if (ret)

commit 68f3f702b6a430a8d1e909455a60d26c0f2da530
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/core: remove the remainder of the previous style
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 03ce10fcba4f..2eb0a370a3a0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -64,7 +64,7 @@ gf100_bar_ctor_vm(struct gf100_bar *bar, struct gf100_bar_vm *bar_vm,
 	if (ret)
 		return ret;
 
-	atomic_inc(&vm->engref[NVDEV_SUBDEV_BAR]);
+	atomic_inc(&vm->engref[NVKM_SUBDEV_BAR]);
 
 	/*
 	 * Bootstrap page table lookup.

commit 3293228174e4d44cca56d809cc8409c3f88f8b90
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/bar: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 7d304ccc6a64..03ce10fcba4f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -21,51 +21,30 @@
  *
  * Authors: Ben Skeggs
  */
-#include "priv.h"
+#include "gf100.h"
 
 #include <core/gpuobj.h>
 #include <subdev/fb.h>
 #include <subdev/mmu.h>
 
-struct gf100_bar_vm {
-	struct nvkm_memory *mem;
-	struct nvkm_gpuobj *pgd;
-	struct nvkm_vm *vm;
-};
-
-struct gf100_bar {
-	struct nvkm_bar base;
-	spinlock_t lock;
-	struct gf100_bar_vm bar[2];
-};
-
 static struct nvkm_vm *
-gf100_bar_kmap(struct nvkm_bar *obj)
+gf100_bar_kmap(struct nvkm_bar *base)
 {
-	struct gf100_bar *bar = container_of(obj, typeof(*bar), base);
-	return bar->bar[0].vm;
+	return gf100_bar(base)->bar[0].vm;
 }
 
-static int
-gf100_bar_umap(struct nvkm_bar *obj, u64 size, int type, struct nvkm_vma *vma)
+int
+gf100_bar_umap(struct nvkm_bar *base, u64 size, int type, struct nvkm_vma *vma)
 {
-	struct gf100_bar *bar = container_of(obj, typeof(*bar), base);
+	struct gf100_bar *bar = gf100_bar(base);
 	return nvkm_vm_get(bar->bar[1].vm, size, type, NV_MEM_ACCESS_RW, vma);
 }
 
-static void
-gf100_bar_unmap(struct nvkm_bar *bar, struct nvkm_vma *vma)
-{
-	nvkm_vm_unmap(vma);
-	nvkm_vm_put(vma);
-}
-
-
 static int
 gf100_bar_ctor_vm(struct gf100_bar *bar, struct gf100_bar_vm *bar_vm,
 		  struct lock_class_key *key, int bar_nr)
 {
-	struct nvkm_device *device = nv_device(&bar->base);
+	struct nvkm_device *device = bar->base.subdev.device;
 	struct nvkm_vm *vm;
 	resource_size_t bar_len;
 	int ret;
@@ -92,8 +71,10 @@ gf100_bar_ctor_vm(struct gf100_bar *bar, struct gf100_bar_vm *bar_vm,
 	 */
 	if (bar_nr == 3) {
 		ret = nvkm_vm_boot(vm, bar_len);
-		if (ret)
+		if (ret) {
+			nvkm_vm_ref(NULL, &vm, NULL);
 			return ret;
+		}
 	}
 
 	ret = nvkm_vm_ref(vm, &bar_vm->vm, bar_vm->pgd);
@@ -111,28 +92,15 @@ gf100_bar_ctor_vm(struct gf100_bar *bar, struct gf100_bar_vm *bar_vm,
 }
 
 int
-gf100_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-	       struct nvkm_oclass *oclass, void *data, u32 size,
-	       struct nvkm_object **pobject)
+gf100_bar_oneinit(struct nvkm_bar *base)
 {
 	static struct lock_class_key bar1_lock;
 	static struct lock_class_key bar3_lock;
-	struct nvkm_device *device = nv_device(parent);
-	struct gf100_bar *bar;
-	bool has_bar3 = nv_device_resource_len(device, 3) != 0;
+	struct gf100_bar *bar = gf100_bar(base);
 	int ret;
 
-	ret = nvkm_bar_create(parent, engine, oclass, &bar);
-	*pobject = nv_object(bar);
-	if (ret)
-		return ret;
-
-	device->bar = &bar->base;
-	bar->base.flush = g84_bar_flush;
-	spin_lock_init(&bar->lock);
-
 	/* BAR3 */
-	if (has_bar3) {
+	if (bar->base.func->kmap) {
 		ret = gf100_bar_ctor_vm(bar, &bar->bar[0], &bar3_lock, 3);
 		if (ret)
 			return ret;
@@ -143,43 +111,15 @@ gf100_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	if (has_bar3)
-		bar->base.kmap = gf100_bar_kmap;
-	bar->base.umap = gf100_bar_umap;
-	bar->base.unmap = gf100_bar_unmap;
 	return 0;
 }
 
-void
-gf100_bar_dtor(struct nvkm_object *object)
-{
-	struct gf100_bar *bar = (void *)object;
-
-	nvkm_vm_ref(NULL, &bar->bar[1].vm, bar->bar[1].pgd);
-	nvkm_gpuobj_del(&bar->bar[1].pgd);
-	nvkm_memory_del(&bar->bar[1].mem);
-
-	if (bar->bar[0].vm) {
-		nvkm_memory_del(&bar->bar[0].vm->pgt[0].mem[0]);
-		nvkm_vm_ref(NULL, &bar->bar[0].vm, bar->bar[0].pgd);
-	}
-	nvkm_gpuobj_del(&bar->bar[0].pgd);
-	nvkm_memory_del(&bar->bar[0].mem);
-
-	nvkm_bar_destroy(&bar->base);
-}
-
 int
-gf100_bar_init(struct nvkm_object *object)
+gf100_bar_init(struct nvkm_bar *base)
 {
-	struct gf100_bar *bar = (void *)object;
+	struct gf100_bar *bar = gf100_bar(base);
 	struct nvkm_device *device = bar->base.subdev.device;
 	u32 addr;
-	int ret;
-
-	ret = nvkm_bar_init(&bar->base);
-	if (ret)
-		return ret;
 
 	nvkm_mask(device, 0x000200, 0x00000100, 0x00000000);
 	nvkm_mask(device, 0x000200, 0x00000100, 0x00000100);
@@ -195,13 +135,48 @@ gf100_bar_init(struct nvkm_object *object)
 	return 0;
 }
 
-struct nvkm_oclass
-gf100_bar_oclass = {
-	.handle = NV_SUBDEV(BAR, 0xc0),
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = gf100_bar_ctor,
-		.dtor = gf100_bar_dtor,
-		.init = gf100_bar_init,
-		.fini = _nvkm_bar_fini,
-	},
+void *
+gf100_bar_dtor(struct nvkm_bar *base)
+{
+	struct gf100_bar *bar = gf100_bar(base);
+
+	nvkm_vm_ref(NULL, &bar->bar[1].vm, bar->bar[1].pgd);
+	nvkm_gpuobj_del(&bar->bar[1].pgd);
+	nvkm_memory_del(&bar->bar[1].mem);
+
+	if (bar->bar[0].vm) {
+		nvkm_memory_del(&bar->bar[0].vm->pgt[0].mem[0]);
+		nvkm_vm_ref(NULL, &bar->bar[0].vm, bar->bar[0].pgd);
+	}
+	nvkm_gpuobj_del(&bar->bar[0].pgd);
+	nvkm_memory_del(&bar->bar[0].mem);
+	return bar;
+}
+
+int
+gf100_bar_new_(const struct nvkm_bar_func *func, struct nvkm_device *device,
+	       int index, struct nvkm_bar **pbar)
+{
+	struct gf100_bar *bar;
+	if (!(bar = kzalloc(sizeof(*bar), GFP_KERNEL)))
+		return -ENOMEM;
+	nvkm_bar_ctor(func, device, index, &bar->base);
+	*pbar = &bar->base;
+	return 0;
+}
+
+static const struct nvkm_bar_func
+gf100_bar_func = {
+	.dtor = gf100_bar_dtor,
+	.oneinit = gf100_bar_oneinit,
+	.init = gf100_bar_init,
+	.kmap = gf100_bar_kmap,
+	.umap = gf100_bar_umap,
+	.flush = g84_bar_flush,
 };
+
+int
+gf100_bar_new(struct nvkm_device *device, int index, struct nvkm_bar **pbar)
+{
+	return gf100_bar_new_(&gf100_bar_func, device, index, pbar);
+}

commit f027f49166171c98d5945af12ac3ee9bc9f9bf4c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/gpuobj: separate allocation from nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 8e3574631068..7d304ccc6a64 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -75,8 +75,7 @@ gf100_bar_ctor_vm(struct gf100_bar *bar, struct gf100_bar_vm *bar_vm,
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(nv_object(bar), NULL, 0x8000, 0, 0,
-			      &bar_vm->pgd);
+	ret = nvkm_gpuobj_new(device, 0x8000, 0, false, NULL, &bar_vm->pgd);
 	if (ret)
 		return ret;
 
@@ -157,14 +156,14 @@ gf100_bar_dtor(struct nvkm_object *object)
 	struct gf100_bar *bar = (void *)object;
 
 	nvkm_vm_ref(NULL, &bar->bar[1].vm, bar->bar[1].pgd);
-	nvkm_gpuobj_ref(NULL, &bar->bar[1].pgd);
+	nvkm_gpuobj_del(&bar->bar[1].pgd);
 	nvkm_memory_del(&bar->bar[1].mem);
 
 	if (bar->bar[0].vm) {
 		nvkm_memory_del(&bar->bar[0].vm->pgt[0].mem[0]);
 		nvkm_vm_ref(NULL, &bar->bar[0].vm, bar->bar[0].pgd);
 	}
-	nvkm_gpuobj_ref(NULL, &bar->bar[0].pgd);
+	nvkm_gpuobj_del(&bar->bar[0].pgd);
 	nvkm_memory_del(&bar->bar[0].mem);
 
 	nvkm_bar_destroy(&bar->base);

commit adb53d2773a7b0e95bb47e092c71906c7d989366
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/bar/gf100: directly use instmem for channel descriptors
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index ccbc1fbc1d1e..8e3574631068 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -28,7 +28,7 @@
 #include <subdev/mmu.h>
 
 struct gf100_bar_vm {
-	struct nvkm_gpuobj *mem;
+	struct nvkm_memory *mem;
 	struct nvkm_gpuobj *pgd;
 	struct nvkm_vm *vm;
 };
@@ -70,7 +70,7 @@ gf100_bar_ctor_vm(struct gf100_bar *bar, struct gf100_bar_vm *bar_vm,
 	resource_size_t bar_len;
 	int ret;
 
-	ret = nvkm_gpuobj_new(nv_object(bar), NULL, 0x1000, 0, 0,
+	ret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST, 0x1000, 0, false,
 			      &bar_vm->mem);
 	if (ret)
 		return ret;
@@ -158,14 +158,14 @@ gf100_bar_dtor(struct nvkm_object *object)
 
 	nvkm_vm_ref(NULL, &bar->bar[1].vm, bar->bar[1].pgd);
 	nvkm_gpuobj_ref(NULL, &bar->bar[1].pgd);
-	nvkm_gpuobj_ref(NULL, &bar->bar[1].mem);
+	nvkm_memory_del(&bar->bar[1].mem);
 
 	if (bar->bar[0].vm) {
 		nvkm_memory_del(&bar->bar[0].vm->pgt[0].mem[0]);
 		nvkm_vm_ref(NULL, &bar->bar[0].vm, bar->bar[0].pgd);
 	}
 	nvkm_gpuobj_ref(NULL, &bar->bar[0].pgd);
-	nvkm_gpuobj_ref(NULL, &bar->bar[0].mem);
+	nvkm_memory_del(&bar->bar[0].mem);
 
 	nvkm_bar_destroy(&bar->base);
 }
@@ -175,6 +175,7 @@ gf100_bar_init(struct nvkm_object *object)
 {
 	struct gf100_bar *bar = (void *)object;
 	struct nvkm_device *device = bar->base.subdev.device;
+	u32 addr;
 	int ret;
 
 	ret = nvkm_bar_init(&bar->base);
@@ -184,10 +185,14 @@ gf100_bar_init(struct nvkm_object *object)
 	nvkm_mask(device, 0x000200, 0x00000100, 0x00000000);
 	nvkm_mask(device, 0x000200, 0x00000100, 0x00000100);
 
-	nvkm_wr32(device, 0x001704, 0x80000000 | bar->bar[1].mem->addr >> 12);
-	if (bar->bar[0].mem)
-		nvkm_wr32(device, 0x001714,
-			0xc0000000 | bar->bar[0].mem->addr >> 12);
+	addr = nvkm_memory_addr(bar->bar[1].mem) >> 12;
+	nvkm_wr32(device, 0x001704, 0x80000000 | addr);
+
+	if (bar->bar[0].mem) {
+		addr = nvkm_memory_addr(bar->bar[0].mem) >> 12;
+		nvkm_wr32(device, 0x001714, 0xc0000000 | addr);
+	}
+
 	return 0;
 }
 

commit d0659d3277cd7bf50e45d48f4692a7fbb11e5957
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/mmu: directly use instmem for page tables
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 1ea6b3909c3a..ccbc1fbc1d1e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -161,7 +161,7 @@ gf100_bar_dtor(struct nvkm_object *object)
 	nvkm_gpuobj_ref(NULL, &bar->bar[1].mem);
 
 	if (bar->bar[0].vm) {
-		nvkm_gpuobj_ref(NULL, &bar->bar[0].vm->pgt[0].obj[0]);
+		nvkm_memory_del(&bar->bar[0].vm->pgt[0].mem[0]);
 		nvkm_vm_ref(NULL, &bar->bar[0].vm, bar->bar[0].pgd);
 	}
 	nvkm_gpuobj_ref(NULL, &bar->bar[0].pgd);

commit d8e83994aaf6749b7124a219f5b46bd1329e2a08
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/imem: improve management of instance memory
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 01e26213fd88..1ea6b3909c3a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -39,35 +39,18 @@ struct gf100_bar {
 	struct gf100_bar_vm bar[2];
 };
 
-static int
-gf100_bar_kmap(struct nvkm_bar *obj, struct nvkm_mem *mem, u32 flags,
-	       struct nvkm_vma *vma)
+static struct nvkm_vm *
+gf100_bar_kmap(struct nvkm_bar *obj)
 {
 	struct gf100_bar *bar = container_of(obj, typeof(*bar), base);
-	int ret;
-
-	ret = nvkm_vm_get(bar->bar[0].vm, mem->size << 12, 12, flags, vma);
-	if (ret)
-		return ret;
-
-	nvkm_vm_map(vma, mem);
-	return 0;
+	return bar->bar[0].vm;
 }
 
 static int
-gf100_bar_umap(struct nvkm_bar *obj, struct nvkm_mem *mem, u32 flags,
-	       struct nvkm_vma *vma)
+gf100_bar_umap(struct nvkm_bar *obj, u64 size, int type, struct nvkm_vma *vma)
 {
 	struct gf100_bar *bar = container_of(obj, typeof(*bar), base);
-	int ret;
-
-	ret = nvkm_vm_get(bar->bar[1].vm, mem->size << 12,
-			  mem->page_shift, flags, vma);
-	if (ret)
-		return ret;
-
-	nvkm_vm_map(vma, mem);
-	return 0;
+	return nvkm_vm_get(bar->bar[1].vm, size, type, NV_MEM_ACCESS_RW, vma);
 }
 
 static void
@@ -109,11 +92,7 @@ gf100_bar_ctor_vm(struct gf100_bar *bar, struct gf100_bar_vm *bar_vm,
 	 * Bootstrap page table lookup.
 	 */
 	if (bar_nr == 3) {
-		ret = nvkm_gpuobj_new(nv_object(bar), NULL,
-				      (bar_len >> 12) * 8, 0x1000,
-				      NVOBJ_FLAG_ZERO_ALLOC,
-				      &vm->pgt[0].obj[0]);
-		vm->pgt[0].refcount[0] = 1;
+		ret = nvkm_vm_boot(vm, bar_len);
 		if (ret)
 			return ret;
 	}
@@ -149,6 +128,10 @@ gf100_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
+	device->bar = &bar->base;
+	bar->base.flush = g84_bar_flush;
+	spin_lock_init(&bar->lock);
+
 	/* BAR3 */
 	if (has_bar3) {
 		ret = gf100_bar_ctor_vm(bar, &bar->bar[0], &bar3_lock, 3);
@@ -161,14 +144,10 @@ gf100_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	if (ret)
 		return ret;
 
-	if (has_bar3) {
-		bar->base.alloc = nvkm_bar_alloc;
+	if (has_bar3)
 		bar->base.kmap = gf100_bar_kmap;
-	}
 	bar->base.umap = gf100_bar_umap;
 	bar->base.unmap = gf100_bar_unmap;
-	bar->base.flush = g84_bar_flush;
-	spin_lock_init(&bar->lock);
 	return 0;
 }
 

commit 1de68568d69ac518db076cc6118af91e930b5f90
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:17 2015 +1000

    drm/nouveau/mmu: protect each vm with its own mutex
    
    An upcoming commit requires being able to modify the PRAMIN BAR page
    tables while already holding the MMU subdev mutex.
    
    To solve this issue, each VM has been given its own mutex.  As a nice
    side-effect, this also allows separate VMs to be updated concurrently.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index b997d8d128c5..01e26213fd88 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -77,9 +77,10 @@ gf100_bar_unmap(struct nvkm_bar *bar, struct nvkm_vma *vma)
 	nvkm_vm_put(vma);
 }
 
+
 static int
 gf100_bar_ctor_vm(struct gf100_bar *bar, struct gf100_bar_vm *bar_vm,
-		  int bar_nr)
+		  struct lock_class_key *key, int bar_nr)
 {
 	struct nvkm_device *device = nv_device(&bar->base);
 	struct nvkm_vm *vm;
@@ -98,7 +99,7 @@ gf100_bar_ctor_vm(struct gf100_bar *bar, struct gf100_bar_vm *bar_vm,
 
 	bar_len = nv_device_resource_len(device, bar_nr);
 
-	ret = nvkm_vm_new(device, 0, bar_len, 0, &vm);
+	ret = nvkm_vm_new(device, 0, bar_len, 0, key, &vm);
 	if (ret)
 		return ret;
 
@@ -136,6 +137,8 @@ gf100_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_oclass *oclass, void *data, u32 size,
 	       struct nvkm_object **pobject)
 {
+	static struct lock_class_key bar1_lock;
+	static struct lock_class_key bar3_lock;
 	struct nvkm_device *device = nv_device(parent);
 	struct gf100_bar *bar;
 	bool has_bar3 = nv_device_resource_len(device, 3) != 0;
@@ -148,13 +151,13 @@ gf100_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	/* BAR3 */
 	if (has_bar3) {
-		ret = gf100_bar_ctor_vm(bar, &bar->bar[0], 3);
+		ret = gf100_bar_ctor_vm(bar, &bar->bar[0], &bar3_lock, 3);
 		if (ret)
 			return ret;
 	}
 
 	/* BAR1 */
-	ret = gf100_bar_ctor_vm(bar, &bar->bar[1], 1);
+	ret = gf100_bar_ctor_vm(bar, &bar->bar[1], &bar1_lock, 1);
 	if (ret)
 		return ret;
 

commit 1918707556986e9460682845a2bf4055c43a8b65
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:14 2015 +1000

    drm/nouveau/bar: switch to gpuobj accessor macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 09e36b64d889..b997d8d128c5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -122,10 +122,12 @@ gf100_bar_ctor_vm(struct gf100_bar *bar, struct gf100_bar_vm *bar_vm,
 	if (ret)
 		return ret;
 
-	nv_wo32(bar_vm->mem, 0x0200, lower_32_bits(bar_vm->pgd->addr));
-	nv_wo32(bar_vm->mem, 0x0204, upper_32_bits(bar_vm->pgd->addr));
-	nv_wo32(bar_vm->mem, 0x0208, lower_32_bits(bar_len - 1));
-	nv_wo32(bar_vm->mem, 0x020c, upper_32_bits(bar_len - 1));
+	nvkm_kmap(bar_vm->mem);
+	nvkm_wo32(bar_vm->mem, 0x0200, lower_32_bits(bar_vm->pgd->addr));
+	nvkm_wo32(bar_vm->mem, 0x0204, upper_32_bits(bar_vm->pgd->addr));
+	nvkm_wo32(bar_vm->mem, 0x0208, lower_32_bits(bar_len - 1));
+	nvkm_wo32(bar_vm->mem, 0x020c, upper_32_bits(bar_len - 1));
+	nvkm_done(bar_vm->mem);
 	return 0;
 }
 

commit 9155c16214631e064d0d1edcd60a62347f823c80
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:08 2015 +1000

    drm/nouveau/bar: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 5f091d2c560b..09e36b64d889 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -190,18 +190,19 @@ int
 gf100_bar_init(struct nvkm_object *object)
 {
 	struct gf100_bar *bar = (void *)object;
+	struct nvkm_device *device = bar->base.subdev.device;
 	int ret;
 
 	ret = nvkm_bar_init(&bar->base);
 	if (ret)
 		return ret;
 
-	nv_mask(bar, 0x000200, 0x00000100, 0x00000000);
-	nv_mask(bar, 0x000200, 0x00000100, 0x00000100);
+	nvkm_mask(device, 0x000200, 0x00000100, 0x00000000);
+	nvkm_mask(device, 0x000200, 0x00000100, 0x00000100);
 
-	nv_wr32(bar, 0x001704, 0x80000000 | bar->bar[1].mem->addr >> 12);
+	nvkm_wr32(device, 0x001704, 0x80000000 | bar->bar[1].mem->addr >> 12);
 	if (bar->bar[0].mem)
-		nv_wr32(bar, 0x001714,
+		nvkm_wr32(device, 0x001714,
 			0xc0000000 | bar->bar[0].mem->addr >> 12);
 	return 0;
 }

commit 5b0c189fcb232daa1cabac8892e42cdee57254bd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/bar: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 4c6d238dd3da..5f091d2c560b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -27,26 +27,26 @@
 #include <subdev/fb.h>
 #include <subdev/mmu.h>
 
-struct gf100_bar_priv_vm {
+struct gf100_bar_vm {
 	struct nvkm_gpuobj *mem;
 	struct nvkm_gpuobj *pgd;
 	struct nvkm_vm *vm;
 };
 
-struct gf100_bar_priv {
+struct gf100_bar {
 	struct nvkm_bar base;
 	spinlock_t lock;
-	struct gf100_bar_priv_vm bar[2];
+	struct gf100_bar_vm bar[2];
 };
 
 static int
-gf100_bar_kmap(struct nvkm_bar *bar, struct nvkm_mem *mem, u32 flags,
+gf100_bar_kmap(struct nvkm_bar *obj, struct nvkm_mem *mem, u32 flags,
 	       struct nvkm_vma *vma)
 {
-	struct gf100_bar_priv *priv = (void *)bar;
+	struct gf100_bar *bar = container_of(obj, typeof(*bar), base);
 	int ret;
 
-	ret = nvkm_vm_get(priv->bar[0].vm, mem->size << 12, 12, flags, vma);
+	ret = nvkm_vm_get(bar->bar[0].vm, mem->size << 12, 12, flags, vma);
 	if (ret)
 		return ret;
 
@@ -55,13 +55,13 @@ gf100_bar_kmap(struct nvkm_bar *bar, struct nvkm_mem *mem, u32 flags,
 }
 
 static int
-gf100_bar_umap(struct nvkm_bar *bar, struct nvkm_mem *mem, u32 flags,
+gf100_bar_umap(struct nvkm_bar *obj, struct nvkm_mem *mem, u32 flags,
 	       struct nvkm_vma *vma)
 {
-	struct gf100_bar_priv *priv = (void *)bar;
+	struct gf100_bar *bar = container_of(obj, typeof(*bar), base);
 	int ret;
 
-	ret = nvkm_vm_get(priv->bar[1].vm, mem->size << 12,
+	ret = nvkm_vm_get(bar->bar[1].vm, mem->size << 12,
 			  mem->page_shift, flags, vma);
 	if (ret)
 		return ret;
@@ -78,20 +78,20 @@ gf100_bar_unmap(struct nvkm_bar *bar, struct nvkm_vma *vma)
 }
 
 static int
-gf100_bar_ctor_vm(struct gf100_bar_priv *priv, struct gf100_bar_priv_vm *bar_vm,
+gf100_bar_ctor_vm(struct gf100_bar *bar, struct gf100_bar_vm *bar_vm,
 		  int bar_nr)
 {
-	struct nvkm_device *device = nv_device(&priv->base);
+	struct nvkm_device *device = nv_device(&bar->base);
 	struct nvkm_vm *vm;
 	resource_size_t bar_len;
 	int ret;
 
-	ret = nvkm_gpuobj_new(nv_object(priv), NULL, 0x1000, 0, 0,
+	ret = nvkm_gpuobj_new(nv_object(bar), NULL, 0x1000, 0, 0,
 			      &bar_vm->mem);
 	if (ret)
 		return ret;
 
-	ret = nvkm_gpuobj_new(nv_object(priv), NULL, 0x8000, 0, 0,
+	ret = nvkm_gpuobj_new(nv_object(bar), NULL, 0x8000, 0, 0,
 			      &bar_vm->pgd);
 	if (ret)
 		return ret;
@@ -108,7 +108,7 @@ gf100_bar_ctor_vm(struct gf100_bar_priv *priv, struct gf100_bar_priv_vm *bar_vm,
 	 * Bootstrap page table lookup.
 	 */
 	if (bar_nr == 3) {
-		ret = nvkm_gpuobj_new(nv_object(priv), NULL,
+		ret = nvkm_gpuobj_new(nv_object(bar), NULL,
 				      (bar_len >> 12) * 8, 0x1000,
 				      NVOBJ_FLAG_ZERO_ALLOC,
 				      &vm->pgt[0].obj[0]);
@@ -135,74 +135,74 @@ gf100_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_object **pobject)
 {
 	struct nvkm_device *device = nv_device(parent);
-	struct gf100_bar_priv *priv;
+	struct gf100_bar *bar;
 	bool has_bar3 = nv_device_resource_len(device, 3) != 0;
 	int ret;
 
-	ret = nvkm_bar_create(parent, engine, oclass, &priv);
-	*pobject = nv_object(priv);
+	ret = nvkm_bar_create(parent, engine, oclass, &bar);
+	*pobject = nv_object(bar);
 	if (ret)
 		return ret;
 
 	/* BAR3 */
 	if (has_bar3) {
-		ret = gf100_bar_ctor_vm(priv, &priv->bar[0], 3);
+		ret = gf100_bar_ctor_vm(bar, &bar->bar[0], 3);
 		if (ret)
 			return ret;
 	}
 
 	/* BAR1 */
-	ret = gf100_bar_ctor_vm(priv, &priv->bar[1], 1);
+	ret = gf100_bar_ctor_vm(bar, &bar->bar[1], 1);
 	if (ret)
 		return ret;
 
 	if (has_bar3) {
-		priv->base.alloc = nvkm_bar_alloc;
-		priv->base.kmap = gf100_bar_kmap;
+		bar->base.alloc = nvkm_bar_alloc;
+		bar->base.kmap = gf100_bar_kmap;
 	}
-	priv->base.umap = gf100_bar_umap;
-	priv->base.unmap = gf100_bar_unmap;
-	priv->base.flush = g84_bar_flush;
-	spin_lock_init(&priv->lock);
+	bar->base.umap = gf100_bar_umap;
+	bar->base.unmap = gf100_bar_unmap;
+	bar->base.flush = g84_bar_flush;
+	spin_lock_init(&bar->lock);
 	return 0;
 }
 
 void
 gf100_bar_dtor(struct nvkm_object *object)
 {
-	struct gf100_bar_priv *priv = (void *)object;
+	struct gf100_bar *bar = (void *)object;
 
-	nvkm_vm_ref(NULL, &priv->bar[1].vm, priv->bar[1].pgd);
-	nvkm_gpuobj_ref(NULL, &priv->bar[1].pgd);
-	nvkm_gpuobj_ref(NULL, &priv->bar[1].mem);
+	nvkm_vm_ref(NULL, &bar->bar[1].vm, bar->bar[1].pgd);
+	nvkm_gpuobj_ref(NULL, &bar->bar[1].pgd);
+	nvkm_gpuobj_ref(NULL, &bar->bar[1].mem);
 
-	if (priv->bar[0].vm) {
-		nvkm_gpuobj_ref(NULL, &priv->bar[0].vm->pgt[0].obj[0]);
-		nvkm_vm_ref(NULL, &priv->bar[0].vm, priv->bar[0].pgd);
+	if (bar->bar[0].vm) {
+		nvkm_gpuobj_ref(NULL, &bar->bar[0].vm->pgt[0].obj[0]);
+		nvkm_vm_ref(NULL, &bar->bar[0].vm, bar->bar[0].pgd);
 	}
-	nvkm_gpuobj_ref(NULL, &priv->bar[0].pgd);
-	nvkm_gpuobj_ref(NULL, &priv->bar[0].mem);
+	nvkm_gpuobj_ref(NULL, &bar->bar[0].pgd);
+	nvkm_gpuobj_ref(NULL, &bar->bar[0].mem);
 
-	nvkm_bar_destroy(&priv->base);
+	nvkm_bar_destroy(&bar->base);
 }
 
 int
 gf100_bar_init(struct nvkm_object *object)
 {
-	struct gf100_bar_priv *priv = (void *)object;
+	struct gf100_bar *bar = (void *)object;
 	int ret;
 
-	ret = nvkm_bar_init(&priv->base);
+	ret = nvkm_bar_init(&bar->base);
 	if (ret)
 		return ret;
 
-	nv_mask(priv, 0x000200, 0x00000100, 0x00000000);
-	nv_mask(priv, 0x000200, 0x00000100, 0x00000100);
+	nv_mask(bar, 0x000200, 0x00000100, 0x00000000);
+	nv_mask(bar, 0x000200, 0x00000100, 0x00000100);
 
-	nv_wr32(priv, 0x001704, 0x80000000 | priv->bar[1].mem->addr >> 12);
-	if (priv->bar[0].mem)
-		nv_wr32(priv, 0x001714,
-			0xc0000000 | priv->bar[0].mem->addr >> 12);
+	nv_wr32(bar, 0x001704, 0x80000000 | bar->bar[1].mem->addr >> 12);
+	if (bar->bar[0].mem)
+		nv_wr32(bar, 0x001714,
+			0xc0000000 | bar->bar[0].mem->addr >> 12);
 	return 0;
 }
 

commit 9ace404b1098221021b01c2ba0eeea0c257fa4a5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/device: include core/device.h automatically for subdevs/engines
    
    Pretty much every subdev/engine is going to need access to nvkm_device
    shortly to touch registers and/or output messages.
    
    The odd placement of the includes is necessary to work around some
    inter-dependencies that currently exist.  This will be fixed later.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 12a1aebd9a96..4c6d238dd3da 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -23,7 +23,6 @@
  */
 #include "priv.h"
 
-#include <core/device.h>
 #include <core/gpuobj.h>
 #include <subdev/fb.h>
 #include <subdev/mmu.h>

commit 42594600095f03244a674fecdd2b5f6da2441180
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:09:19 2015 +1000

    drm/nouveau/mmu: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
index 4c6d238dd3da..12a1aebd9a96 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -23,6 +23,7 @@
  */
 #include "priv.h"
 
+#include <core/device.h>
 #include <core/gpuobj.h>
 #include <subdev/fb.h>
 #include <subdev/mmu.h>

commit 245dcfe96f6900dbf64e48a350badf4c90fabc2e
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 14:35:35 2015 +1000

    drm/nouveau/bar: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
new file mode 100644
index 000000000000..4c6d238dd3da
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c
@@ -0,0 +1,218 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+#include "priv.h"
+
+#include <core/gpuobj.h>
+#include <subdev/fb.h>
+#include <subdev/mmu.h>
+
+struct gf100_bar_priv_vm {
+	struct nvkm_gpuobj *mem;
+	struct nvkm_gpuobj *pgd;
+	struct nvkm_vm *vm;
+};
+
+struct gf100_bar_priv {
+	struct nvkm_bar base;
+	spinlock_t lock;
+	struct gf100_bar_priv_vm bar[2];
+};
+
+static int
+gf100_bar_kmap(struct nvkm_bar *bar, struct nvkm_mem *mem, u32 flags,
+	       struct nvkm_vma *vma)
+{
+	struct gf100_bar_priv *priv = (void *)bar;
+	int ret;
+
+	ret = nvkm_vm_get(priv->bar[0].vm, mem->size << 12, 12, flags, vma);
+	if (ret)
+		return ret;
+
+	nvkm_vm_map(vma, mem);
+	return 0;
+}
+
+static int
+gf100_bar_umap(struct nvkm_bar *bar, struct nvkm_mem *mem, u32 flags,
+	       struct nvkm_vma *vma)
+{
+	struct gf100_bar_priv *priv = (void *)bar;
+	int ret;
+
+	ret = nvkm_vm_get(priv->bar[1].vm, mem->size << 12,
+			  mem->page_shift, flags, vma);
+	if (ret)
+		return ret;
+
+	nvkm_vm_map(vma, mem);
+	return 0;
+}
+
+static void
+gf100_bar_unmap(struct nvkm_bar *bar, struct nvkm_vma *vma)
+{
+	nvkm_vm_unmap(vma);
+	nvkm_vm_put(vma);
+}
+
+static int
+gf100_bar_ctor_vm(struct gf100_bar_priv *priv, struct gf100_bar_priv_vm *bar_vm,
+		  int bar_nr)
+{
+	struct nvkm_device *device = nv_device(&priv->base);
+	struct nvkm_vm *vm;
+	resource_size_t bar_len;
+	int ret;
+
+	ret = nvkm_gpuobj_new(nv_object(priv), NULL, 0x1000, 0, 0,
+			      &bar_vm->mem);
+	if (ret)
+		return ret;
+
+	ret = nvkm_gpuobj_new(nv_object(priv), NULL, 0x8000, 0, 0,
+			      &bar_vm->pgd);
+	if (ret)
+		return ret;
+
+	bar_len = nv_device_resource_len(device, bar_nr);
+
+	ret = nvkm_vm_new(device, 0, bar_len, 0, &vm);
+	if (ret)
+		return ret;
+
+	atomic_inc(&vm->engref[NVDEV_SUBDEV_BAR]);
+
+	/*
+	 * Bootstrap page table lookup.
+	 */
+	if (bar_nr == 3) {
+		ret = nvkm_gpuobj_new(nv_object(priv), NULL,
+				      (bar_len >> 12) * 8, 0x1000,
+				      NVOBJ_FLAG_ZERO_ALLOC,
+				      &vm->pgt[0].obj[0]);
+		vm->pgt[0].refcount[0] = 1;
+		if (ret)
+			return ret;
+	}
+
+	ret = nvkm_vm_ref(vm, &bar_vm->vm, bar_vm->pgd);
+	nvkm_vm_ref(NULL, &vm, NULL);
+	if (ret)
+		return ret;
+
+	nv_wo32(bar_vm->mem, 0x0200, lower_32_bits(bar_vm->pgd->addr));
+	nv_wo32(bar_vm->mem, 0x0204, upper_32_bits(bar_vm->pgd->addr));
+	nv_wo32(bar_vm->mem, 0x0208, lower_32_bits(bar_len - 1));
+	nv_wo32(bar_vm->mem, 0x020c, upper_32_bits(bar_len - 1));
+	return 0;
+}
+
+int
+gf100_bar_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+	       struct nvkm_oclass *oclass, void *data, u32 size,
+	       struct nvkm_object **pobject)
+{
+	struct nvkm_device *device = nv_device(parent);
+	struct gf100_bar_priv *priv;
+	bool has_bar3 = nv_device_resource_len(device, 3) != 0;
+	int ret;
+
+	ret = nvkm_bar_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	/* BAR3 */
+	if (has_bar3) {
+		ret = gf100_bar_ctor_vm(priv, &priv->bar[0], 3);
+		if (ret)
+			return ret;
+	}
+
+	/* BAR1 */
+	ret = gf100_bar_ctor_vm(priv, &priv->bar[1], 1);
+	if (ret)
+		return ret;
+
+	if (has_bar3) {
+		priv->base.alloc = nvkm_bar_alloc;
+		priv->base.kmap = gf100_bar_kmap;
+	}
+	priv->base.umap = gf100_bar_umap;
+	priv->base.unmap = gf100_bar_unmap;
+	priv->base.flush = g84_bar_flush;
+	spin_lock_init(&priv->lock);
+	return 0;
+}
+
+void
+gf100_bar_dtor(struct nvkm_object *object)
+{
+	struct gf100_bar_priv *priv = (void *)object;
+
+	nvkm_vm_ref(NULL, &priv->bar[1].vm, priv->bar[1].pgd);
+	nvkm_gpuobj_ref(NULL, &priv->bar[1].pgd);
+	nvkm_gpuobj_ref(NULL, &priv->bar[1].mem);
+
+	if (priv->bar[0].vm) {
+		nvkm_gpuobj_ref(NULL, &priv->bar[0].vm->pgt[0].obj[0]);
+		nvkm_vm_ref(NULL, &priv->bar[0].vm, priv->bar[0].pgd);
+	}
+	nvkm_gpuobj_ref(NULL, &priv->bar[0].pgd);
+	nvkm_gpuobj_ref(NULL, &priv->bar[0].mem);
+
+	nvkm_bar_destroy(&priv->base);
+}
+
+int
+gf100_bar_init(struct nvkm_object *object)
+{
+	struct gf100_bar_priv *priv = (void *)object;
+	int ret;
+
+	ret = nvkm_bar_init(&priv->base);
+	if (ret)
+		return ret;
+
+	nv_mask(priv, 0x000200, 0x00000100, 0x00000000);
+	nv_mask(priv, 0x000200, 0x00000100, 0x00000100);
+
+	nv_wr32(priv, 0x001704, 0x80000000 | priv->bar[1].mem->addr >> 12);
+	if (priv->bar[0].mem)
+		nv_wr32(priv, 0x001714,
+			0xc0000000 | priv->bar[0].mem->addr >> 12);
+	return 0;
+}
+
+struct nvkm_oclass
+gf100_bar_oclass = {
+	.handle = NV_SUBDEV(BAR, 0xc0),
+	.ofuncs = &(struct nvkm_ofuncs) {
+		.ctor = gf100_bar_ctor,
+		.dtor = gf100_bar_dtor,
+		.init = gf100_bar_init,
+		.fini = _nvkm_bar_fini,
+	},
+};
