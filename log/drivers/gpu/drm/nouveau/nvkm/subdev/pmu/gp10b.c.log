commit 89b34254bb61d0ad5c701413572cf3d993c9bff8
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Jan 15 15:06:13 2020 +0100

    drm/nouveau/pmu/gm20b,gp10b: Fix Falcon bootstrapping
    
    The low-level Falcon bootstrapping callbacks are expected to return 0 on
    success or a negative error code on failure. However, the implementation
    on Tegra returns the ID or mask of the Falcons that were bootstrapped on
    success, thus breaking the calling code, which treats this as failure.
    
    Fix this by making sure we only return 0 or a negative error code, just
    like the code for discrete GPUs does.
    
    Fixes: 86ce2a71539c ("drm/nouveau/flcn/cmdq: move command generation to subdevs")
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
index 39c86bc56310..5b81c7320479 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
@@ -52,8 +52,13 @@ gp10b_pmu_acr_bootstrap_multiple_falcons(struct nvkm_falcon *falcon, u32 mask)
 	ret = nvkm_falcon_cmdq_send(pmu->hpq, &cmd.cmd.hdr,
 				    gp10b_pmu_acr_bootstrap_multiple_falcons_cb,
 				    &pmu->subdev, msecs_to_jiffies(1000));
-	if (ret >= 0 && ret != cmd.falcon_mask)
-		ret = -EIO;
+	if (ret >= 0) {
+		if (ret != cmd.falcon_mask)
+			ret = -EIO;
+		else
+			ret = 0;
+	}
+
 	return ret;
 }
 

commit 22dcda45a3d1dfe6eeb4ab0a3b9aaa2333cb649d
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 15 06:34:22 2020 +1000

    drm/nouveau/acr: implement new subdev to replace "secure boot"
    
    ACR is responsible for managing the firmware for LS (Low Secure) falcons,
    this was previously handled in the driver by SECBOOT.
    
    This rewrite started from some test code that attempted to replicate the
    procedure RM uses in order to debug early Turing ACR firmwares that were
    provided by NVIDIA for development.
    
    Compared with SECBOOT, the code is structured into more individual steps,
    with the aim of making the process easier to follow/debug, whilst making
    it possible to support newer firmware versions that may have a different
    binary format or API interface.
    
    The HS (High Secure) binary(s) are now booted earlier in device init, to
    match the behaviour of RM, whereas SECBOOT would delay this until we try
    to boot the first LS falcon.
    
    There's also additional debugging features available, with the intention
    of making it easier to solve issues during FW/HW bring-up in the future.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
index 0e0ebd6857da..39c86bc56310 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
@@ -23,6 +23,7 @@
 
 #include <subdev/acr.h>
 
+#include <nvfw/flcn.h>
 #include <nvfw/pmu.h>
 
 static int
@@ -58,6 +59,11 @@ gp10b_pmu_acr_bootstrap_multiple_falcons(struct nvkm_falcon *falcon, u32 mask)
 
 static const struct nvkm_acr_lsf_func
 gp10b_pmu_acr = {
+	.flags = NVKM_ACR_LSF_DMACTL_REQ_CTX,
+	.bld_size = sizeof(struct loader_config),
+	.bld_write = gm20b_pmu_acr_bld_write,
+	.bld_patch = gm20b_pmu_acr_bld_patch,
+	.boot = gm20b_pmu_acr_boot,
 	.bootstrap_falcon = gm20b_pmu_acr_bootstrap_falcon,
 	.bootstrap_multiple_falcons = gp10b_pmu_acr_bootstrap_multiple_falcons,
 };

commit d114a1393fa01c4034d895072905578319a903f9
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 15 06:34:22 2020 +1000

    drm/nouveau/flcn/msgq: move handling of init message to subdevs
    
    When the PMU/SEC2 LS FWs have booted, they'll send a message to the host
    with various information, including the configuration of message/command
    queues that are available.
    
    Move the handling for this to the relevant subdevs.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
index b2baf9b636a3..0e0ebd6857da 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
@@ -68,6 +68,7 @@ gp10b_pmu = {
 	.enabled = gf100_pmu_enabled,
 	.intr = gt215_pmu_intr,
 	.recv = gm20b_pmu_recv,
+	.initmsg = gm20b_pmu_initmsg,
 };
 
 #if IS_ENABLED(CONFIG_ARCH_TEGRA_210_SOC)

commit 86ce2a71539c47241dc8f471d8724f5bd1e41ae6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 15 06:34:22 2020 +1000

    drm/nouveau/flcn/cmdq: move command generation to subdevs
    
    This moves the code to generate commands for the ACR unit of the PMU/SEC2 LS
    firmwares to those subdevs.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
index 7134ef9d91af..b2baf9b636a3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
@@ -20,10 +20,46 @@
  * DEALINGS IN THE SOFTWARE.
  */
 #include "priv.h"
+
 #include <subdev/acr.h>
 
+#include <nvfw/pmu.h>
+
+static int
+gp10b_pmu_acr_bootstrap_multiple_falcons_cb(void *priv,
+					    struct nv_falcon_msg *hdr)
+{
+	struct nv_pmu_acr_bootstrap_multiple_falcons_msg *msg =
+		container_of(hdr, typeof(*msg), msg.hdr);
+	return msg->falcon_mask;
+}
+static int
+gp10b_pmu_acr_bootstrap_multiple_falcons(struct nvkm_falcon *falcon, u32 mask)
+{
+	struct nvkm_pmu *pmu = container_of(falcon, typeof(*pmu), falcon);
+	struct nv_pmu_acr_bootstrap_multiple_falcons_cmd cmd = {
+		.cmd.hdr.unit_id = NV_PMU_UNIT_ACR,
+		.cmd.hdr.size = sizeof(cmd),
+		.cmd.cmd_type = NV_PMU_ACR_CMD_BOOTSTRAP_MULTIPLE_FALCONS,
+		.flags = NV_PMU_ACR_BOOTSTRAP_MULTIPLE_FALCONS_FLAGS_RESET_YES,
+		.falcon_mask = mask,
+		.wpr_lo = 0, /*XXX*/
+		.wpr_hi = 0, /*XXX*/
+	};
+	int ret;
+
+	ret = nvkm_falcon_cmdq_send(pmu->hpq, &cmd.cmd.hdr,
+				    gp10b_pmu_acr_bootstrap_multiple_falcons_cb,
+				    &pmu->subdev, msecs_to_jiffies(1000));
+	if (ret >= 0 && ret != cmd.falcon_mask)
+		ret = -EIO;
+	return ret;
+}
+
 static const struct nvkm_acr_lsf_func
 gp10b_pmu_acr = {
+	.bootstrap_falcon = gm20b_pmu_acr_bootstrap_falcon,
+	.bootstrap_multiple_falcons = gp10b_pmu_acr_bootstrap_multiple_falcons,
 };
 
 static const struct nvkm_pmu_func

commit 2952a2b42e17ea0f72ee52de061975dddb9c62ec
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 15 06:34:21 2020 +1000

    drm/nouveau/pmu: initialise SW state for falcon from constructor
    
    This will allow us to register the falcon with ACR, and further customise
    its behaviour by providing the nvkm_falcon_func structure directly.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
index 2440e230f398..7134ef9d91af 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
@@ -28,6 +28,7 @@ gp10b_pmu_acr = {
 
 static const struct nvkm_pmu_func
 gp10b_pmu = {
+	.flcn = &gt215_pmu_flcn,
 	.enabled = gf100_pmu_enabled,
 	.intr = gt215_pmu_intr,
 	.recv = gm20b_pmu_recv,

commit 989863d7cbe58180cf0e69fd5ed72279c7fac901
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 15 06:34:21 2020 +1000

    drm/nouveau/pmu: select implementation based on available firmware
    
    This will allow for further customisation of the subdev depending on what
    firmware is available.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
index d028f50090ae..2440e230f398 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
@@ -20,6 +20,11 @@
  * DEALINGS IN THE SOFTWARE.
  */
 #include "priv.h"
+#include <subdev/acr.h>
+
+static const struct nvkm_acr_lsf_func
+gp10b_pmu_acr = {
+};
 
 static const struct nvkm_pmu_func
 gp10b_pmu = {
@@ -28,8 +33,20 @@ gp10b_pmu = {
 	.recv = gm20b_pmu_recv,
 };
 
+#if IS_ENABLED(CONFIG_ARCH_TEGRA_210_SOC)
+MODULE_FIRMWARE("nvidia/gp10b/pmu/desc.bin");
+MODULE_FIRMWARE("nvidia/gp10b/pmu/image.bin");
+MODULE_FIRMWARE("nvidia/gp10b/pmu/sig.bin");
+#endif
+
+static const struct nvkm_pmu_fwif
+gp10b_pmu_fwif[] = {
+	{ 0, gm20b_pmu_load, &gp10b_pmu, &gp10b_pmu_acr },
+	{}
+};
+
 int
 gp10b_pmu_new(struct nvkm_device *device, int index, struct nvkm_pmu **ppmu)
 {
-	return nvkm_pmu_new_(&gp10b_pmu, device, index, ppmu);
+	return nvkm_pmu_new_(gp10b_pmu_fwif, device, index, ppmu);
 }

commit e905736c6d7328ce2d34640741f4b7e75c64a737
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 15 06:34:21 2020 +1000

    drm/nouveau/pmu/gp10b: split from gm20b implementation
    
    ACR LS FW loading is moving out of SECBOOT and into their specific subdevs,
    and the available GM20B/GP10B FWs have interface differences.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
new file mode 100644
index 000000000000..d028f50090ae
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gp10b.c
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2016, NVIDIA CORPORATION. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#include "priv.h"
+
+static const struct nvkm_pmu_func
+gp10b_pmu = {
+	.enabled = gf100_pmu_enabled,
+	.intr = gt215_pmu_intr,
+	.recv = gm20b_pmu_recv,
+};
+
+int
+gp10b_pmu_new(struct nvkm_device *device, int index, struct nvkm_pmu **ppmu)
+{
+	return nvkm_pmu_new_(&gp10b_pmu, device, index, ppmu);
+}
