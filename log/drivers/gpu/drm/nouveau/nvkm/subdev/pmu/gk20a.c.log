commit 2952a2b42e17ea0f72ee52de061975dddb9c62ec
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 15 06:34:21 2020 +1000

    drm/nouveau/pmu: initialise SW state for falcon from constructor
    
    This will allow us to register the falcon with ACR, and further customise
    its behaviour by providing the nvkm_falcon_func structure directly.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index 67f65c54c7fd..26c1adf8f44c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -95,7 +95,7 @@ static void
 gk20a_pmu_dvfs_get_dev_status(struct gk20a_pmu *pmu,
 			      struct gk20a_pmu_dvfs_dev_status *status)
 {
-	struct nvkm_falcon *falcon = pmu->base.falcon;
+	struct nvkm_falcon *falcon = &pmu->base.falcon;
 
 	status->busy = nvkm_falcon_rd32(falcon, 0x508 + (BUSY_SLOT * 0x10));
 	status->total= nvkm_falcon_rd32(falcon, 0x508 + (CLK_SLOT * 0x10));
@@ -104,7 +104,7 @@ gk20a_pmu_dvfs_get_dev_status(struct gk20a_pmu *pmu,
 static void
 gk20a_pmu_dvfs_reset_dev_status(struct gk20a_pmu *pmu)
 {
-	struct nvkm_falcon *falcon = pmu->base.falcon;
+	struct nvkm_falcon *falcon = &pmu->base.falcon;
 
 	nvkm_falcon_wr32(falcon, 0x508 + (BUSY_SLOT * 0x10), 0x80000000);
 	nvkm_falcon_wr32(falcon, 0x508 + (CLK_SLOT * 0x10), 0x80000000);
@@ -160,7 +160,7 @@ gk20a_pmu_fini(struct nvkm_pmu *pmu)
 	struct gk20a_pmu *gpmu = gk20a_pmu(pmu);
 	nvkm_timer_alarm(pmu->subdev.device->timer, 0, &gpmu->alarm);
 
-	nvkm_falcon_put(pmu->falcon, &pmu->subdev);
+	nvkm_falcon_put(&pmu->falcon, &pmu->subdev);
 }
 
 static int
@@ -169,7 +169,7 @@ gk20a_pmu_init(struct nvkm_pmu *pmu)
 	struct gk20a_pmu *gpmu = gk20a_pmu(pmu);
 	struct nvkm_subdev *subdev = &pmu->subdev;
 	struct nvkm_device *device = pmu->subdev.device;
-	struct nvkm_falcon *falcon = pmu->falcon;
+	struct nvkm_falcon *falcon = &pmu->falcon;
 	int ret;
 
 	ret = nvkm_falcon_get(falcon, subdev);
@@ -196,6 +196,7 @@ gk20a_dvfs_data= {
 
 static const struct nvkm_pmu_func
 gk20a_pmu = {
+	.flcn = &gt215_pmu_flcn,
 	.enabled = gf100_pmu_enabled,
 	.init = gk20a_pmu_init,
 	.fini = gk20a_pmu_fini,

commit 989863d7cbe58180cf0e69fd5ed72279c7fac901
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 15 06:34:21 2020 +1000

    drm/nouveau/pmu: select implementation based on available firmware
    
    This will allow for further customisation of the subdev depending on what
    firmware is available.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index 05e81855c367..67f65c54c7fd 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -202,19 +202,27 @@ gk20a_pmu = {
 	.reset = gf100_pmu_reset,
 };
 
+static const struct nvkm_pmu_fwif
+gk20a_pmu_fwif[] = {
+	{ -1, gf100_pmu_nofw, &gk20a_pmu },
+	{}
+};
+
 int
 gk20a_pmu_new(struct nvkm_device *device, int index, struct nvkm_pmu **ppmu)
 {
 	struct gk20a_pmu *pmu;
+	int ret;
 
 	if (!(pmu = kzalloc(sizeof(*pmu), GFP_KERNEL)))
 		return -ENOMEM;
 	*ppmu = &pmu->base;
 
-	nvkm_pmu_ctor(&gk20a_pmu, device, index, &pmu->base);
+	ret = nvkm_pmu_ctor(gk20a_pmu_fwif, device, index, &pmu->base);
+	if (ret)
+		return ret;
 
 	pmu->data = &gk20a_dvfs_data;
 	nvkm_alarm_init(&pmu->alarm, gk20a_pmu_dvfs_work);
-
 	return 0;
 }

commit 6b1277c837630749b55f743dd62023d9dd7a510a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Jul 21 10:45:32 2017 +1000

    drm/nouveau/pmu/gt215-: abstract detection of whether reset is needed
    
    GT215, GF100-GP100, and GP10x are all different.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index 14862452a597..05e81855c367 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -196,6 +196,7 @@ gk20a_dvfs_data= {
 
 static const struct nvkm_pmu_func
 gk20a_pmu = {
+	.enabled = gf100_pmu_enabled,
 	.init = gk20a_pmu_init,
 	.fini = gk20a_pmu_fini,
 	.reset = gf100_pmu_reset,

commit 715e7d261dea75911c4dad468a1103168933d913
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Jul 21 10:33:52 2017 +1000

    drm/nouveau/pmu/gt215: fix reset
    
    The NV_PMC_ENABLE bit for PMU did not appear until GF100, and some other
    unknown register needs to be poked instead.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index 978aae3c1001..14862452a597 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -198,7 +198,7 @@ static const struct nvkm_pmu_func
 gk20a_pmu = {
 	.init = gk20a_pmu_init,
 	.fini = gk20a_pmu_fini,
-	.reset = gt215_pmu_reset,
+	.reset = gf100_pmu_reset,
 };
 
 int

commit 7eaf1198a9aaa9c31c9270e370088d8a79c149ab
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu May 11 17:29:58 2017 +1000

    drm/nouveau/tmr: remove nvkm_timer_alarm_cancel()
    
    nvkm_timer_alarm() already handles this as part of protecting against
    callers passing in no timeout value.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index 9ca0db796cbe..978aae3c1001 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -158,7 +158,7 @@ static void
 gk20a_pmu_fini(struct nvkm_pmu *pmu)
 {
 	struct gk20a_pmu *gpmu = gk20a_pmu(pmu);
-	nvkm_timer_alarm_cancel(pmu->subdev.device->timer, &gpmu->alarm);
+	nvkm_timer_alarm(pmu->subdev.device->timer, 0, &gpmu->alarm);
 
 	nvkm_falcon_put(pmu->falcon, &pmu->subdev);
 }

commit 9b071c7935f053bf05ab4d0b2f4a8ae4069b4b89
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Tue Dec 13 17:11:24 2016 +0900

    drm/nouveau/pmu/gk20a: use falcon library functions
    
    Use the falcon library functions where relevant.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index 4a0f80983564..9ca0db796cbe 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -95,17 +95,19 @@ static void
 gk20a_pmu_dvfs_get_dev_status(struct gk20a_pmu *pmu,
 			      struct gk20a_pmu_dvfs_dev_status *status)
 {
-	struct nvkm_device *device = pmu->base.subdev.device;
-	status->busy = nvkm_rd32(device, 0x10a508 + (BUSY_SLOT * 0x10));
-	status->total= nvkm_rd32(device, 0x10a508 + (CLK_SLOT * 0x10));
+	struct nvkm_falcon *falcon = pmu->base.falcon;
+
+	status->busy = nvkm_falcon_rd32(falcon, 0x508 + (BUSY_SLOT * 0x10));
+	status->total= nvkm_falcon_rd32(falcon, 0x508 + (CLK_SLOT * 0x10));
 }
 
 static void
 gk20a_pmu_dvfs_reset_dev_status(struct gk20a_pmu *pmu)
 {
-	struct nvkm_device *device = pmu->base.subdev.device;
-	nvkm_wr32(device, 0x10a508 + (BUSY_SLOT * 0x10), 0x80000000);
-	nvkm_wr32(device, 0x10a508 + (CLK_SLOT * 0x10), 0x80000000);
+	struct nvkm_falcon *falcon = pmu->base.falcon;
+
+	nvkm_falcon_wr32(falcon, 0x508 + (BUSY_SLOT * 0x10), 0x80000000);
+	nvkm_falcon_wr32(falcon, 0x508 + (CLK_SLOT * 0x10), 0x80000000);
 }
 
 static void
@@ -157,18 +159,29 @@ gk20a_pmu_fini(struct nvkm_pmu *pmu)
 {
 	struct gk20a_pmu *gpmu = gk20a_pmu(pmu);
 	nvkm_timer_alarm_cancel(pmu->subdev.device->timer, &gpmu->alarm);
+
+	nvkm_falcon_put(pmu->falcon, &pmu->subdev);
 }
 
 static int
 gk20a_pmu_init(struct nvkm_pmu *pmu)
 {
 	struct gk20a_pmu *gpmu = gk20a_pmu(pmu);
+	struct nvkm_subdev *subdev = &pmu->subdev;
 	struct nvkm_device *device = pmu->subdev.device;
+	struct nvkm_falcon *falcon = pmu->falcon;
+	int ret;
+
+	ret = nvkm_falcon_get(falcon, subdev);
+	if (ret) {
+		nvkm_error(subdev, "cannot acquire %s falcon!\n", falcon->name);
+		return ret;
+	}
 
 	/* init pwr perf counter */
-	nvkm_wr32(device, 0x10a504 + (BUSY_SLOT * 0x10), 0x00200001);
-	nvkm_wr32(device, 0x10a50c + (BUSY_SLOT * 0x10), 0x00000002);
-	nvkm_wr32(device, 0x10a50c + (CLK_SLOT * 0x10), 0x00000003);
+	nvkm_falcon_wr32(falcon, 0x504 + (BUSY_SLOT * 0x10), 0x00200001);
+	nvkm_falcon_wr32(falcon, 0x50c + (BUSY_SLOT * 0x10), 0x00000002);
+	nvkm_falcon_wr32(falcon, 0x50c + (CLK_SLOT * 0x10), 0x00000003);
 
 	nvkm_timer_alarm(device->timer, 2000000000, &gpmu->alarm);
 	return 0;

commit 68d82161fdab51f44767bcde801fd6a58bef9548
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Tue Dec 13 17:11:23 2016 +0900

    drm/nouveau/pmu/gk20a: simplify code a bit
    
    Some functions always succeed - change their return type to void and
    remove the error-handling code in their caller.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index e897bbde44f2..4a0f80983564 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -43,9 +43,8 @@ struct gk20a_pmu {
 };
 
 struct gk20a_pmu_dvfs_dev_status {
-	unsigned long total;
-	unsigned long busy;
-	int cur_state;
+	u32 total;
+	u32 busy;
 };
 
 static int
@@ -56,13 +55,12 @@ gk20a_pmu_dvfs_target(struct gk20a_pmu *pmu, int *state)
 	return nvkm_clk_astate(clk, *state, 0, false);
 }
 
-static int
+static void
 gk20a_pmu_dvfs_get_cur_state(struct gk20a_pmu *pmu, int *state)
 {
 	struct nvkm_clk *clk = pmu->base.subdev.device->clk;
 
 	*state = clk->pstate;
-	return 0;
 }
 
 static int
@@ -90,20 +88,16 @@ gk20a_pmu_dvfs_get_target_state(struct gk20a_pmu *pmu,
 
 	*state = level;
 
-	if (level == cur_level)
-		return 0;
-	else
-		return 1;
+	return (level != cur_level);
 }
 
-static int
+static void
 gk20a_pmu_dvfs_get_dev_status(struct gk20a_pmu *pmu,
 			      struct gk20a_pmu_dvfs_dev_status *status)
 {
 	struct nvkm_device *device = pmu->base.subdev.device;
 	status->busy = nvkm_rd32(device, 0x10a508 + (BUSY_SLOT * 0x10));
 	status->total= nvkm_rd32(device, 0x10a508 + (CLK_SLOT * 0x10));
-	return 0;
 }
 
 static void
@@ -127,7 +121,7 @@ gk20a_pmu_dvfs_work(struct nvkm_alarm *alarm)
 	struct nvkm_timer *tmr = device->timer;
 	struct nvkm_volt *volt = device->volt;
 	u32 utilization = 0;
-	int state, ret;
+	int state;
 
 	/*
 	 * The PMU is initialized before CLK and VOLT, so we have to make sure the
@@ -136,11 +130,7 @@ gk20a_pmu_dvfs_work(struct nvkm_alarm *alarm)
 	if (!clk || !volt)
 		goto resched;
 
-	ret = gk20a_pmu_dvfs_get_dev_status(pmu, &status);
-	if (ret) {
-		nvkm_warn(subdev, "failed to get device status\n");
-		goto resched;
-	}
+	gk20a_pmu_dvfs_get_dev_status(pmu, &status);
 
 	if (status.total)
 		utilization = div_u64((u64)status.busy * 100, status.total);
@@ -150,11 +140,7 @@ gk20a_pmu_dvfs_work(struct nvkm_alarm *alarm)
 	nvkm_trace(subdev, "utilization = %d %%, avg_load = %d %%\n",
 		   utilization, data->avg_load);
 
-	ret = gk20a_pmu_dvfs_get_cur_state(pmu, &state);
-	if (ret) {
-		nvkm_warn(subdev, "failed to get current state\n");
-		goto resched;
-	}
+	gk20a_pmu_dvfs_get_cur_state(pmu, &state);
 
 	if (gk20a_pmu_dvfs_get_target_state(pmu, &state, data->avg_load)) {
 		nvkm_trace(subdev, "set new state to %d\n", state);

commit d8711c5a9cfd6b06d611a64a30ae3e98ef4e6962
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Tue Dec 13 17:11:22 2016 +0900

    drm/nouveau/pmu/gk20a: use nvkm_pmu_ctor()
    
    Use the PMU constructor so that all base members (in particular the
    falcon instance) are initialized properly.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index f996d90c9f0d..e897bbde44f2 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -19,7 +19,7 @@
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  */
-#define gk20a_pmu(p) container_of((p), struct gk20a_pmu, base.subdev)
+#define gk20a_pmu(p) container_of((p), struct gk20a_pmu, base)
 #include "priv.h"
 
 #include <subdev/clk.h>
@@ -166,32 +166,25 @@ gk20a_pmu_dvfs_work(struct nvkm_alarm *alarm)
 	nvkm_timer_alarm(tmr, 100000000, alarm);
 }
 
-static int
-gk20a_pmu_fini(struct nvkm_subdev *subdev, bool suspend)
-{
-	struct gk20a_pmu *pmu = gk20a_pmu(subdev);
-	nvkm_timer_alarm_cancel(subdev->device->timer, &pmu->alarm);
-	return 0;
-}
-
-static void *
-gk20a_pmu_dtor(struct nvkm_subdev *subdev)
+static void
+gk20a_pmu_fini(struct nvkm_pmu *pmu)
 {
-	return gk20a_pmu(subdev);
+	struct gk20a_pmu *gpmu = gk20a_pmu(pmu);
+	nvkm_timer_alarm_cancel(pmu->subdev.device->timer, &gpmu->alarm);
 }
 
 static int
-gk20a_pmu_init(struct nvkm_subdev *subdev)
+gk20a_pmu_init(struct nvkm_pmu *pmu)
 {
-	struct gk20a_pmu *pmu = gk20a_pmu(subdev);
-	struct nvkm_device *device = pmu->base.subdev.device;
+	struct gk20a_pmu *gpmu = gk20a_pmu(pmu);
+	struct nvkm_device *device = pmu->subdev.device;
 
 	/* init pwr perf counter */
 	nvkm_wr32(device, 0x10a504 + (BUSY_SLOT * 0x10), 0x00200001);
 	nvkm_wr32(device, 0x10a50c + (BUSY_SLOT * 0x10), 0x00000002);
 	nvkm_wr32(device, 0x10a50c + (CLK_SLOT * 0x10), 0x00000003);
 
-	nvkm_timer_alarm(device->timer, 2000000000, &pmu->alarm);
+	nvkm_timer_alarm(device->timer, 2000000000, &gpmu->alarm);
 	return 0;
 }
 
@@ -202,26 +195,26 @@ gk20a_dvfs_data= {
 	.p_smooth = 1,
 };
 
-static const struct nvkm_subdev_func
+static const struct nvkm_pmu_func
 gk20a_pmu = {
 	.init = gk20a_pmu_init,
 	.fini = gk20a_pmu_fini,
-	.dtor = gk20a_pmu_dtor,
+	.reset = gt215_pmu_reset,
 };
 
 int
 gk20a_pmu_new(struct nvkm_device *device, int index, struct nvkm_pmu **ppmu)
 {
-	static const struct nvkm_pmu_func func = {};
 	struct gk20a_pmu *pmu;
 
 	if (!(pmu = kzalloc(sizeof(*pmu), GFP_KERNEL)))
 		return -ENOMEM;
-	pmu->base.func = &func;
 	*ppmu = &pmu->base;
 
-	nvkm_subdev_ctor(&gk20a_pmu, device, index, &pmu->base.subdev);
+	nvkm_pmu_ctor(&gk20a_pmu, device, index, &pmu->base);
+
 	pmu->data = &gk20a_dvfs_data;
 	nvkm_alarm_init(&pmu->alarm, gk20a_pmu_dvfs_work);
+
 	return 0;
 }

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index 6689d0290a7e..f996d90c9f0d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -220,7 +220,7 @@ gk20a_pmu_new(struct nvkm_device *device, int index, struct nvkm_pmu **ppmu)
 	pmu->base.func = &func;
 	*ppmu = &pmu->base;
 
-	nvkm_subdev_ctor(&gk20a_pmu, device, index, 0, &pmu->base.subdev);
+	nvkm_subdev_ctor(&gk20a_pmu, device, index, &pmu->base.subdev);
 	pmu->data = &gk20a_dvfs_data;
 	nvkm_alarm_init(&pmu->alarm, gk20a_pmu_dvfs_work);
 	return 0;

commit 31649ecf47a44e02e73bffc5680c8f56d6cf587a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:21 2015 +1000

    drm/nouveau/tmr: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index 860c8bc2b422..6689d0290a7e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -124,6 +124,7 @@ gk20a_pmu_dvfs_work(struct nvkm_alarm *alarm)
 	struct nvkm_subdev *subdev = &pmu->base.subdev;
 	struct nvkm_device *device = subdev->device;
 	struct nvkm_clk *clk = device->clk;
+	struct nvkm_timer *tmr = device->timer;
 	struct nvkm_volt *volt = device->volt;
 	u32 utilization = 0;
 	int state, ret;
@@ -162,14 +163,14 @@ gk20a_pmu_dvfs_work(struct nvkm_alarm *alarm)
 
 resched:
 	gk20a_pmu_dvfs_reset_dev_status(pmu);
-	nvkm_timer_alarm(pmu, 100000000, alarm);
+	nvkm_timer_alarm(tmr, 100000000, alarm);
 }
 
 static int
 gk20a_pmu_fini(struct nvkm_subdev *subdev, bool suspend)
 {
 	struct gk20a_pmu *pmu = gk20a_pmu(subdev);
-	nvkm_timer_alarm_cancel(pmu, &pmu->alarm);
+	nvkm_timer_alarm_cancel(subdev->device->timer, &pmu->alarm);
 	return 0;
 }
 
@@ -190,7 +191,7 @@ gk20a_pmu_init(struct nvkm_subdev *subdev)
 	nvkm_wr32(device, 0x10a50c + (BUSY_SLOT * 0x10), 0x00000002);
 	nvkm_wr32(device, 0x10a50c + (CLK_SLOT * 0x10), 0x00000003);
 
-	nvkm_timer_alarm(pmu, 2000000000, &pmu->alarm);
+	nvkm_timer_alarm(device->timer, 2000000000, &pmu->alarm);
 	return 0;
 }
 

commit e2ca4e7d6e56cb73a068708f0b0c9bd62ab9e02c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:21 2015 +1000

    drm/nouveau/pmu: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index bf3c53851352..860c8bc2b422 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -19,6 +19,7 @@
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  */
+#define gk20a_pmu(p) container_of((p), struct gk20a_pmu, base.subdev)
 #include "priv.h"
 
 #include <subdev/clk.h>
@@ -165,27 +166,24 @@ gk20a_pmu_dvfs_work(struct nvkm_alarm *alarm)
 }
 
 static int
-gk20a_pmu_fini(struct nvkm_object *object, bool suspend)
+gk20a_pmu_fini(struct nvkm_subdev *subdev, bool suspend)
 {
-	struct gk20a_pmu *pmu = (void *)object;
-
+	struct gk20a_pmu *pmu = gk20a_pmu(subdev);
 	nvkm_timer_alarm_cancel(pmu, &pmu->alarm);
+	return 0;
+}
 
-	return nvkm_subdev_fini_old(&pmu->base.subdev, suspend);
+static void *
+gk20a_pmu_dtor(struct nvkm_subdev *subdev)
+{
+	return gk20a_pmu(subdev);
 }
 
 static int
-gk20a_pmu_init(struct nvkm_object *object)
+gk20a_pmu_init(struct nvkm_subdev *subdev)
 {
-	struct gk20a_pmu *pmu = (void *)object;
+	struct gk20a_pmu *pmu = gk20a_pmu(subdev);
 	struct nvkm_device *device = pmu->base.subdev.device;
-	int ret;
-
-	ret = nvkm_subdev_init_old(&pmu->base.subdev);
-	if (ret)
-		return ret;
-
-	pmu->base.pgob = nvkm_pmu_pgob;
 
 	/* init pwr perf counter */
 	nvkm_wr32(device, 0x10a504 + (BUSY_SLOT * 0x10), 0x00200001);
@@ -193,7 +191,7 @@ gk20a_pmu_init(struct nvkm_object *object)
 	nvkm_wr32(device, 0x10a50c + (CLK_SLOT * 0x10), 0x00000003);
 
 	nvkm_timer_alarm(pmu, 2000000000, &pmu->alarm);
-	return ret;
+	return 0;
 }
 
 static struct gk20a_pmu_dvfs_data
@@ -203,32 +201,26 @@ gk20a_dvfs_data= {
 	.p_smooth = 1,
 };
 
-static int
-gk20a_pmu_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-	       struct nvkm_oclass *oclass, void *data, u32 size,
-	       struct nvkm_object **pobject)
+static const struct nvkm_subdev_func
+gk20a_pmu = {
+	.init = gk20a_pmu_init,
+	.fini = gk20a_pmu_fini,
+	.dtor = gk20a_pmu_dtor,
+};
+
+int
+gk20a_pmu_new(struct nvkm_device *device, int index, struct nvkm_pmu **ppmu)
 {
+	static const struct nvkm_pmu_func func = {};
 	struct gk20a_pmu *pmu;
-	int ret;
 
-	ret = nvkm_pmu_create(parent, engine, oclass, &pmu);
-	*pobject = nv_object(pmu);
-	if (ret)
-		return ret;
+	if (!(pmu = kzalloc(sizeof(*pmu), GFP_KERNEL)))
+		return -ENOMEM;
+	pmu->base.func = &func;
+	*ppmu = &pmu->base;
 
+	nvkm_subdev_ctor(&gk20a_pmu, device, index, 0, &pmu->base.subdev);
 	pmu->data = &gk20a_dvfs_data;
-
 	nvkm_alarm_init(&pmu->alarm, gk20a_pmu_dvfs_work);
 	return 0;
 }
-
-struct nvkm_oclass *
-gk20a_pmu_oclass = &(struct nvkm_pmu_impl) {
-	.base.handle = NV_SUBDEV(PMU, 0xea),
-	.base.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = gk20a_pmu_ctor,
-		.dtor = _nvkm_pmu_dtor,
-		.init = gk20a_pmu_init,
-		.fini = gk20a_pmu_fini,
-	},
-}.base;

commit 6625f55c080f888ccf51b6881f0bad13f5762d15
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/clk: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index 47c6dbe8fff3..bf3c53851352 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -50,7 +50,7 @@ struct gk20a_pmu_dvfs_dev_status {
 static int
 gk20a_pmu_dvfs_target(struct gk20a_pmu *pmu, int *state)
 {
-	struct nvkm_clk *clk = nvkm_clk(pmu);
+	struct nvkm_clk *clk = pmu->base.subdev.device->clk;
 
 	return nvkm_clk_astate(clk, *state, 0, false);
 }
@@ -58,7 +58,7 @@ gk20a_pmu_dvfs_target(struct gk20a_pmu *pmu, int *state)
 static int
 gk20a_pmu_dvfs_get_cur_state(struct gk20a_pmu *pmu, int *state)
 {
-	struct nvkm_clk *clk = nvkm_clk(pmu);
+	struct nvkm_clk *clk = pmu->base.subdev.device->clk;
 
 	*state = clk->pstate;
 	return 0;
@@ -69,7 +69,7 @@ gk20a_pmu_dvfs_get_target_state(struct gk20a_pmu *pmu,
 				int *state, int load)
 {
 	struct gk20a_pmu_dvfs_data *data = pmu->data;
-	struct nvkm_clk *clk = nvkm_clk(pmu);
+	struct nvkm_clk *clk = pmu->base.subdev.device->clk;
 	int cur_level, level;
 
 	/* For GK20A, the performance level is directly mapped to pstate */

commit 3a8c3400f3e74638bedd0d2410416aa8b794c0fd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/subdev: rename some functions to avoid upcoming conflicts
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index 1003013666a9..47c6dbe8fff3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -171,7 +171,7 @@ gk20a_pmu_fini(struct nvkm_object *object, bool suspend)
 
 	nvkm_timer_alarm_cancel(pmu, &pmu->alarm);
 
-	return nvkm_subdev_fini(&pmu->base.subdev, suspend);
+	return nvkm_subdev_fini_old(&pmu->base.subdev, suspend);
 }
 
 static int
@@ -181,7 +181,7 @@ gk20a_pmu_init(struct nvkm_object *object)
 	struct nvkm_device *device = pmu->base.subdev.device;
 	int ret;
 
-	ret = nvkm_subdev_init(&pmu->base.subdev);
+	ret = nvkm_subdev_init_old(&pmu->base.subdev);
 	if (ret)
 		return ret;
 

commit c19e329d663715014b367c4fedb217e0378342bf
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:12 2015 +1000

    drm/nouveau/pmu: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index 20087d53fb9c..1003013666a9 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -84,7 +84,8 @@ gk20a_pmu_dvfs_get_target_state(struct gk20a_pmu *pmu,
 		level = min(clk->state_nr - 1, level);
 	}
 
-	nv_trace(pmu, "cur level = %d, new level = %d\n", cur_level, level);
+	nvkm_trace(&pmu->base.subdev, "cur level = %d, new level = %d\n",
+		   cur_level, level);
 
 	*state = level;
 
@@ -119,8 +120,10 @@ gk20a_pmu_dvfs_work(struct nvkm_alarm *alarm)
 		container_of(alarm, struct gk20a_pmu, alarm);
 	struct gk20a_pmu_dvfs_data *data = pmu->data;
 	struct gk20a_pmu_dvfs_dev_status status;
-	struct nvkm_clk *clk = nvkm_clk(pmu);
-	struct nvkm_volt *volt = nvkm_volt(pmu);
+	struct nvkm_subdev *subdev = &pmu->base.subdev;
+	struct nvkm_device *device = subdev->device;
+	struct nvkm_clk *clk = device->clk;
+	struct nvkm_volt *volt = device->volt;
 	u32 utilization = 0;
 	int state, ret;
 
@@ -133,7 +136,7 @@ gk20a_pmu_dvfs_work(struct nvkm_alarm *alarm)
 
 	ret = gk20a_pmu_dvfs_get_dev_status(pmu, &status);
 	if (ret) {
-		nv_warn(pmu, "failed to get device status\n");
+		nvkm_warn(subdev, "failed to get device status\n");
 		goto resched;
 	}
 
@@ -142,17 +145,17 @@ gk20a_pmu_dvfs_work(struct nvkm_alarm *alarm)
 
 	data->avg_load = (data->p_smooth * data->avg_load) + utilization;
 	data->avg_load /= data->p_smooth + 1;
-	nv_trace(pmu, "utilization = %d %%, avg_load = %d %%\n",
-			utilization, data->avg_load);
+	nvkm_trace(subdev, "utilization = %d %%, avg_load = %d %%\n",
+		   utilization, data->avg_load);
 
 	ret = gk20a_pmu_dvfs_get_cur_state(pmu, &state);
 	if (ret) {
-		nv_warn(pmu, "failed to get current state\n");
+		nvkm_warn(subdev, "failed to get current state\n");
 		goto resched;
 	}
 
 	if (gk20a_pmu_dvfs_get_target_state(pmu, &state, data->avg_load)) {
-		nv_trace(pmu, "set new state to %d\n", state);
+		nvkm_trace(subdev, "set new state to %d\n", state);
 		gk20a_pmu_dvfs_target(pmu, &state);
 	}
 

commit bef002e87f1accc12a7fc7c98b80354c136c199e
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:09 2015 +1000

    drm/nouveau/pmu: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index 069e9dacc6d3..20087d53fb9c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -98,16 +98,18 @@ static int
 gk20a_pmu_dvfs_get_dev_status(struct gk20a_pmu *pmu,
 			      struct gk20a_pmu_dvfs_dev_status *status)
 {
-	status->busy = nv_rd32(pmu, 0x10a508 + (BUSY_SLOT * 0x10));
-	status->total= nv_rd32(pmu, 0x10a508 + (CLK_SLOT * 0x10));
+	struct nvkm_device *device = pmu->base.subdev.device;
+	status->busy = nvkm_rd32(device, 0x10a508 + (BUSY_SLOT * 0x10));
+	status->total= nvkm_rd32(device, 0x10a508 + (CLK_SLOT * 0x10));
 	return 0;
 }
 
 static void
 gk20a_pmu_dvfs_reset_dev_status(struct gk20a_pmu *pmu)
 {
-	nv_wr32(pmu, 0x10a508 + (BUSY_SLOT * 0x10), 0x80000000);
-	nv_wr32(pmu, 0x10a508 + (CLK_SLOT * 0x10), 0x80000000);
+	struct nvkm_device *device = pmu->base.subdev.device;
+	nvkm_wr32(device, 0x10a508 + (BUSY_SLOT * 0x10), 0x80000000);
+	nvkm_wr32(device, 0x10a508 + (CLK_SLOT * 0x10), 0x80000000);
 }
 
 static void
@@ -173,6 +175,7 @@ static int
 gk20a_pmu_init(struct nvkm_object *object)
 {
 	struct gk20a_pmu *pmu = (void *)object;
+	struct nvkm_device *device = pmu->base.subdev.device;
 	int ret;
 
 	ret = nvkm_subdev_init(&pmu->base.subdev);
@@ -182,9 +185,9 @@ gk20a_pmu_init(struct nvkm_object *object)
 	pmu->base.pgob = nvkm_pmu_pgob;
 
 	/* init pwr perf counter */
-	nv_wr32(pmu, 0x10a504 + (BUSY_SLOT * 0x10), 0x00200001);
-	nv_wr32(pmu, 0x10a50c + (BUSY_SLOT * 0x10), 0x00000002);
-	nv_wr32(pmu, 0x10a50c + (CLK_SLOT * 0x10), 0x00000003);
+	nvkm_wr32(device, 0x10a504 + (BUSY_SLOT * 0x10), 0x00200001);
+	nvkm_wr32(device, 0x10a50c + (BUSY_SLOT * 0x10), 0x00000002);
+	nvkm_wr32(device, 0x10a50c + (CLK_SLOT * 0x10), 0x00000003);
 
 	nvkm_timer_alarm(pmu, 2000000000, &pmu->alarm);
 	return ret;

commit 5a7d1e22feedd3cfab5a94bba5f26ab61610bc62
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/pmu: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index 594f746e68f2..069e9dacc6d3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -35,7 +35,7 @@ struct gk20a_pmu_dvfs_data {
 	unsigned int avg_load;
 };
 
-struct gk20a_pmu_priv {
+struct gk20a_pmu {
 	struct nvkm_pmu base;
 	struct nvkm_alarm alarm;
 	struct gk20a_pmu_dvfs_data *data;
@@ -48,28 +48,28 @@ struct gk20a_pmu_dvfs_dev_status {
 };
 
 static int
-gk20a_pmu_dvfs_target(struct gk20a_pmu_priv *priv, int *state)
+gk20a_pmu_dvfs_target(struct gk20a_pmu *pmu, int *state)
 {
-	struct nvkm_clk *clk = nvkm_clk(priv);
+	struct nvkm_clk *clk = nvkm_clk(pmu);
 
 	return nvkm_clk_astate(clk, *state, 0, false);
 }
 
 static int
-gk20a_pmu_dvfs_get_cur_state(struct gk20a_pmu_priv *priv, int *state)
+gk20a_pmu_dvfs_get_cur_state(struct gk20a_pmu *pmu, int *state)
 {
-	struct nvkm_clk *clk = nvkm_clk(priv);
+	struct nvkm_clk *clk = nvkm_clk(pmu);
 
 	*state = clk->pstate;
 	return 0;
 }
 
 static int
-gk20a_pmu_dvfs_get_target_state(struct gk20a_pmu_priv *priv,
+gk20a_pmu_dvfs_get_target_state(struct gk20a_pmu *pmu,
 				int *state, int load)
 {
-	struct gk20a_pmu_dvfs_data *data = priv->data;
-	struct nvkm_clk *clk = nvkm_clk(priv);
+	struct gk20a_pmu_dvfs_data *data = pmu->data;
+	struct nvkm_clk *clk = nvkm_clk(pmu);
 	int cur_level, level;
 
 	/* For GK20A, the performance level is directly mapped to pstate */
@@ -84,7 +84,7 @@ gk20a_pmu_dvfs_get_target_state(struct gk20a_pmu_priv *priv,
 		level = min(clk->state_nr - 1, level);
 	}
 
-	nv_trace(priv, "cur level = %d, new level = %d\n", cur_level, level);
+	nv_trace(pmu, "cur level = %d, new level = %d\n", cur_level, level);
 
 	*state = level;
 
@@ -95,30 +95,30 @@ gk20a_pmu_dvfs_get_target_state(struct gk20a_pmu_priv *priv,
 }
 
 static int
-gk20a_pmu_dvfs_get_dev_status(struct gk20a_pmu_priv *priv,
+gk20a_pmu_dvfs_get_dev_status(struct gk20a_pmu *pmu,
 			      struct gk20a_pmu_dvfs_dev_status *status)
 {
-	status->busy = nv_rd32(priv, 0x10a508 + (BUSY_SLOT * 0x10));
-	status->total= nv_rd32(priv, 0x10a508 + (CLK_SLOT * 0x10));
+	status->busy = nv_rd32(pmu, 0x10a508 + (BUSY_SLOT * 0x10));
+	status->total= nv_rd32(pmu, 0x10a508 + (CLK_SLOT * 0x10));
 	return 0;
 }
 
 static void
-gk20a_pmu_dvfs_reset_dev_status(struct gk20a_pmu_priv *priv)
+gk20a_pmu_dvfs_reset_dev_status(struct gk20a_pmu *pmu)
 {
-	nv_wr32(priv, 0x10a508 + (BUSY_SLOT * 0x10), 0x80000000);
-	nv_wr32(priv, 0x10a508 + (CLK_SLOT * 0x10), 0x80000000);
+	nv_wr32(pmu, 0x10a508 + (BUSY_SLOT * 0x10), 0x80000000);
+	nv_wr32(pmu, 0x10a508 + (CLK_SLOT * 0x10), 0x80000000);
 }
 
 static void
 gk20a_pmu_dvfs_work(struct nvkm_alarm *alarm)
 {
-	struct gk20a_pmu_priv *priv =
-		container_of(alarm, struct gk20a_pmu_priv, alarm);
-	struct gk20a_pmu_dvfs_data *data = priv->data;
+	struct gk20a_pmu *pmu =
+		container_of(alarm, struct gk20a_pmu, alarm);
+	struct gk20a_pmu_dvfs_data *data = pmu->data;
 	struct gk20a_pmu_dvfs_dev_status status;
-	struct nvkm_clk *clk = nvkm_clk(priv);
-	struct nvkm_volt *volt = nvkm_volt(priv);
+	struct nvkm_clk *clk = nvkm_clk(pmu);
+	struct nvkm_volt *volt = nvkm_volt(pmu);
 	u32 utilization = 0;
 	int state, ret;
 
@@ -129,9 +129,9 @@ gk20a_pmu_dvfs_work(struct nvkm_alarm *alarm)
 	if (!clk || !volt)
 		goto resched;
 
-	ret = gk20a_pmu_dvfs_get_dev_status(priv, &status);
+	ret = gk20a_pmu_dvfs_get_dev_status(pmu, &status);
 	if (ret) {
-		nv_warn(priv, "failed to get device status\n");
+		nv_warn(pmu, "failed to get device status\n");
 		goto resched;
 	}
 
@@ -140,55 +140,53 @@ gk20a_pmu_dvfs_work(struct nvkm_alarm *alarm)
 
 	data->avg_load = (data->p_smooth * data->avg_load) + utilization;
 	data->avg_load /= data->p_smooth + 1;
-	nv_trace(priv, "utilization = %d %%, avg_load = %d %%\n",
+	nv_trace(pmu, "utilization = %d %%, avg_load = %d %%\n",
 			utilization, data->avg_load);
 
-	ret = gk20a_pmu_dvfs_get_cur_state(priv, &state);
+	ret = gk20a_pmu_dvfs_get_cur_state(pmu, &state);
 	if (ret) {
-		nv_warn(priv, "failed to get current state\n");
+		nv_warn(pmu, "failed to get current state\n");
 		goto resched;
 	}
 
-	if (gk20a_pmu_dvfs_get_target_state(priv, &state, data->avg_load)) {
-		nv_trace(priv, "set new state to %d\n", state);
-		gk20a_pmu_dvfs_target(priv, &state);
+	if (gk20a_pmu_dvfs_get_target_state(pmu, &state, data->avg_load)) {
+		nv_trace(pmu, "set new state to %d\n", state);
+		gk20a_pmu_dvfs_target(pmu, &state);
 	}
 
 resched:
-	gk20a_pmu_dvfs_reset_dev_status(priv);
-	nvkm_timer_alarm(priv, 100000000, alarm);
+	gk20a_pmu_dvfs_reset_dev_status(pmu);
+	nvkm_timer_alarm(pmu, 100000000, alarm);
 }
 
 static int
 gk20a_pmu_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nvkm_pmu *pmu = (void *)object;
-	struct gk20a_pmu_priv *priv = (void *)pmu;
+	struct gk20a_pmu *pmu = (void *)object;
 
-	nvkm_timer_alarm_cancel(priv, &priv->alarm);
+	nvkm_timer_alarm_cancel(pmu, &pmu->alarm);
 
-	return nvkm_subdev_fini(&pmu->base, suspend);
+	return nvkm_subdev_fini(&pmu->base.subdev, suspend);
 }
 
 static int
 gk20a_pmu_init(struct nvkm_object *object)
 {
-	struct nvkm_pmu *pmu = (void *)object;
-	struct gk20a_pmu_priv *priv = (void *)pmu;
+	struct gk20a_pmu *pmu = (void *)object;
 	int ret;
 
-	ret = nvkm_subdev_init(&pmu->base);
+	ret = nvkm_subdev_init(&pmu->base.subdev);
 	if (ret)
 		return ret;
 
-	pmu->pgob = nvkm_pmu_pgob;
+	pmu->base.pgob = nvkm_pmu_pgob;
 
 	/* init pwr perf counter */
 	nv_wr32(pmu, 0x10a504 + (BUSY_SLOT * 0x10), 0x00200001);
 	nv_wr32(pmu, 0x10a50c + (BUSY_SLOT * 0x10), 0x00000002);
 	nv_wr32(pmu, 0x10a50c + (CLK_SLOT * 0x10), 0x00000003);
 
-	nvkm_timer_alarm(pmu, 2000000000, &priv->alarm);
+	nvkm_timer_alarm(pmu, 2000000000, &pmu->alarm);
 	return ret;
 }
 
@@ -204,17 +202,17 @@ gk20a_pmu_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	       struct nvkm_oclass *oclass, void *data, u32 size,
 	       struct nvkm_object **pobject)
 {
-	struct gk20a_pmu_priv *priv;
+	struct gk20a_pmu *pmu;
 	int ret;
 
-	ret = nvkm_pmu_create(parent, engine, oclass, &priv);
-	*pobject = nv_object(priv);
+	ret = nvkm_pmu_create(parent, engine, oclass, &pmu);
+	*pobject = nv_object(pmu);
 	if (ret)
 		return ret;
 
-	priv->data = &gk20a_dvfs_data;
+	pmu->data = &gk20a_dvfs_data;
 
-	nvkm_alarm_init(&priv->alarm, gk20a_pmu_dvfs_work);
+	nvkm_alarm_init(&pmu->alarm, gk20a_pmu_dvfs_work);
 	return 0;
 }
 

commit 7120908d12db5d2d1ba136ee014fee4e95513fc0
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Fri Mar 20 19:41:06 2015 +0900

    drm/nouveau/pmu/gk20a: add some missing statics
    
    Make static a few functions and structures that should be.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index a49934bbe637..594f746e68f2 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -159,7 +159,7 @@ gk20a_pmu_dvfs_work(struct nvkm_alarm *alarm)
 	nvkm_timer_alarm(priv, 100000000, alarm);
 }
 
-int
+static int
 gk20a_pmu_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nvkm_pmu *pmu = (void *)object;
@@ -170,7 +170,7 @@ gk20a_pmu_fini(struct nvkm_object *object, bool suspend)
 	return nvkm_subdev_fini(&pmu->base, suspend);
 }
 
-int
+static int
 gk20a_pmu_init(struct nvkm_object *object)
 {
 	struct nvkm_pmu *pmu = (void *)object;
@@ -192,7 +192,8 @@ gk20a_pmu_init(struct nvkm_object *object)
 	return ret;
 }
 
-struct gk20a_pmu_dvfs_data gk20a_dvfs_data= {
+static struct gk20a_pmu_dvfs_data
+gk20a_dvfs_data= {
 	.p_load_target = 70,
 	.p_load_max = 90,
 	.p_smooth = 1,

commit 21b137916ec25a507dbf7b6fe8b353fe9dc723c0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:10:40 2015 +1000

    drm/nouveau/pmu: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
index 28d858a875bf..a49934bbe637 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -36,8 +36,8 @@ struct gk20a_pmu_dvfs_data {
 };
 
 struct gk20a_pmu_priv {
-	struct nouveau_pmu base;
-	struct nouveau_alarm alarm;
+	struct nvkm_pmu base;
+	struct nvkm_alarm alarm;
 	struct gk20a_pmu_dvfs_data *data;
 };
 
@@ -50,15 +50,15 @@ struct gk20a_pmu_dvfs_dev_status {
 static int
 gk20a_pmu_dvfs_target(struct gk20a_pmu_priv *priv, int *state)
 {
-	struct nouveau_clk *clk = nouveau_clk(priv);
+	struct nvkm_clk *clk = nvkm_clk(priv);
 
-	return nouveau_clk_astate(clk, *state, 0, false);
+	return nvkm_clk_astate(clk, *state, 0, false);
 }
 
 static int
 gk20a_pmu_dvfs_get_cur_state(struct gk20a_pmu_priv *priv, int *state)
 {
-	struct nouveau_clk *clk = nouveau_clk(priv);
+	struct nvkm_clk *clk = nvkm_clk(priv);
 
 	*state = clk->pstate;
 	return 0;
@@ -66,10 +66,10 @@ gk20a_pmu_dvfs_get_cur_state(struct gk20a_pmu_priv *priv, int *state)
 
 static int
 gk20a_pmu_dvfs_get_target_state(struct gk20a_pmu_priv *priv,
-		int *state, int load)
+				int *state, int load)
 {
 	struct gk20a_pmu_dvfs_data *data = priv->data;
-	struct nouveau_clk *clk = nouveau_clk(priv);
+	struct nvkm_clk *clk = nvkm_clk(priv);
 	int cur_level, level;
 
 	/* For GK20A, the performance level is directly mapped to pstate */
@@ -96,7 +96,7 @@ gk20a_pmu_dvfs_get_target_state(struct gk20a_pmu_priv *priv,
 
 static int
 gk20a_pmu_dvfs_get_dev_status(struct gk20a_pmu_priv *priv,
-		struct gk20a_pmu_dvfs_dev_status *status)
+			      struct gk20a_pmu_dvfs_dev_status *status)
 {
 	status->busy = nv_rd32(priv, 0x10a508 + (BUSY_SLOT * 0x10));
 	status->total= nv_rd32(priv, 0x10a508 + (CLK_SLOT * 0x10));
@@ -111,14 +111,14 @@ gk20a_pmu_dvfs_reset_dev_status(struct gk20a_pmu_priv *priv)
 }
 
 static void
-gk20a_pmu_dvfs_work(struct nouveau_alarm *alarm)
+gk20a_pmu_dvfs_work(struct nvkm_alarm *alarm)
 {
-	struct gk20a_pmu_priv *priv = container_of(alarm,
-					struct gk20a_pmu_priv, alarm);
+	struct gk20a_pmu_priv *priv =
+		container_of(alarm, struct gk20a_pmu_priv, alarm);
 	struct gk20a_pmu_dvfs_data *data = priv->data;
 	struct gk20a_pmu_dvfs_dev_status status;
-	struct nouveau_clk *clk = nouveau_clk(priv);
-	struct nouveau_volt *volt = nouveau_volt(priv);
+	struct nvkm_clk *clk = nvkm_clk(priv);
+	struct nvkm_volt *volt = nvkm_volt(priv);
 	u32 utilization = 0;
 	int state, ret;
 
@@ -156,40 +156,39 @@ gk20a_pmu_dvfs_work(struct nouveau_alarm *alarm)
 
 resched:
 	gk20a_pmu_dvfs_reset_dev_status(priv);
-	nouveau_timer_alarm(priv, 100000000, alarm);
+	nvkm_timer_alarm(priv, 100000000, alarm);
 }
 
 int
-gk20a_pmu_fini(struct nouveau_object *object, bool suspend)
+gk20a_pmu_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nouveau_pmu *pmu = (void *)object;
+	struct nvkm_pmu *pmu = (void *)object;
 	struct gk20a_pmu_priv *priv = (void *)pmu;
 
-	nouveau_timer_alarm_cancel(priv, &priv->alarm);
+	nvkm_timer_alarm_cancel(priv, &priv->alarm);
 
-	return nouveau_subdev_fini(&pmu->base, suspend);
+	return nvkm_subdev_fini(&pmu->base, suspend);
 }
 
 int
-gk20a_pmu_init(struct nouveau_object *object)
+gk20a_pmu_init(struct nvkm_object *object)
 {
-	struct nouveau_pmu *pmu = (void *)object;
+	struct nvkm_pmu *pmu = (void *)object;
 	struct gk20a_pmu_priv *priv = (void *)pmu;
 	int ret;
 
-	ret = nouveau_subdev_init(&pmu->base);
+	ret = nvkm_subdev_init(&pmu->base);
 	if (ret)
 		return ret;
 
-	pmu->pgob = nouveau_pmu_pgob;
+	pmu->pgob = nvkm_pmu_pgob;
 
 	/* init pwr perf counter */
 	nv_wr32(pmu, 0x10a504 + (BUSY_SLOT * 0x10), 0x00200001);
 	nv_wr32(pmu, 0x10a50c + (BUSY_SLOT * 0x10), 0x00000002);
 	nv_wr32(pmu, 0x10a50c + (CLK_SLOT * 0x10), 0x00000003);
 
-	nouveau_timer_alarm(pmu, 2000000000, &priv->alarm);
-
+	nvkm_timer_alarm(pmu, 2000000000, &priv->alarm);
 	return ret;
 }
 
@@ -200,32 +199,30 @@ struct gk20a_pmu_dvfs_data gk20a_dvfs_data= {
 };
 
 static int
-gk20a_pmu_ctor(struct nouveau_object *parent,
-		  struct nouveau_object *engine,
-		  struct nouveau_oclass *oclass, void *data, u32 size,
-		  struct nouveau_object **pobject)
+gk20a_pmu_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+	       struct nvkm_oclass *oclass, void *data, u32 size,
+	       struct nvkm_object **pobject)
 {
 	struct gk20a_pmu_priv *priv;
 	int ret;
 
-	ret = nouveau_pmu_create(parent, engine, oclass, &priv);
+	ret = nvkm_pmu_create(parent, engine, oclass, &priv);
 	*pobject = nv_object(priv);
 	if (ret)
 		return ret;
 
 	priv->data = &gk20a_dvfs_data;
 
-	nouveau_alarm_init(&priv->alarm, gk20a_pmu_dvfs_work);
-
+	nvkm_alarm_init(&priv->alarm, gk20a_pmu_dvfs_work);
 	return 0;
 }
 
-struct nouveau_oclass *
+struct nvkm_oclass *
 gk20a_pmu_oclass = &(struct nvkm_pmu_impl) {
 	.base.handle = NV_SUBDEV(PMU, 0xea),
-	.base.ofuncs = &(struct nouveau_ofuncs) {
+	.base.ofuncs = &(struct nvkm_ofuncs) {
 		.ctor = gk20a_pmu_ctor,
-		.dtor = _nouveau_pmu_dtor,
+		.dtor = _nvkm_pmu_dtor,
 		.init = gk20a_pmu_init,
 		.fini = gk20a_pmu_fini,
 	},

commit ebb58dc2ef8c62d1affa28160f57faa7b0e1dc02
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 00:04:21 2015 +1000

    drm/nouveau/pmu: rename from pwr (no binary change)
    
    Switch to NVIDIA's name for the device.
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
new file mode 100644
index 000000000000..28d858a875bf
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c
@@ -0,0 +1,232 @@
+/*
+ * Copyright (c) 2014, NVIDIA CORPORATION. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#include "priv.h"
+
+#include <subdev/clk.h>
+#include <subdev/timer.h>
+#include <subdev/volt.h>
+
+#define BUSY_SLOT	0
+#define CLK_SLOT	7
+
+struct gk20a_pmu_dvfs_data {
+	int p_load_target;
+	int p_load_max;
+	int p_smooth;
+	unsigned int avg_load;
+};
+
+struct gk20a_pmu_priv {
+	struct nouveau_pmu base;
+	struct nouveau_alarm alarm;
+	struct gk20a_pmu_dvfs_data *data;
+};
+
+struct gk20a_pmu_dvfs_dev_status {
+	unsigned long total;
+	unsigned long busy;
+	int cur_state;
+};
+
+static int
+gk20a_pmu_dvfs_target(struct gk20a_pmu_priv *priv, int *state)
+{
+	struct nouveau_clk *clk = nouveau_clk(priv);
+
+	return nouveau_clk_astate(clk, *state, 0, false);
+}
+
+static int
+gk20a_pmu_dvfs_get_cur_state(struct gk20a_pmu_priv *priv, int *state)
+{
+	struct nouveau_clk *clk = nouveau_clk(priv);
+
+	*state = clk->pstate;
+	return 0;
+}
+
+static int
+gk20a_pmu_dvfs_get_target_state(struct gk20a_pmu_priv *priv,
+		int *state, int load)
+{
+	struct gk20a_pmu_dvfs_data *data = priv->data;
+	struct nouveau_clk *clk = nouveau_clk(priv);
+	int cur_level, level;
+
+	/* For GK20A, the performance level is directly mapped to pstate */
+	level = cur_level = clk->pstate;
+
+	if (load > data->p_load_max) {
+		level = min(clk->state_nr - 1, level + (clk->state_nr / 3));
+	} else {
+		level += ((load - data->p_load_target) * 10 /
+				data->p_load_target) / 2;
+		level = max(0, level);
+		level = min(clk->state_nr - 1, level);
+	}
+
+	nv_trace(priv, "cur level = %d, new level = %d\n", cur_level, level);
+
+	*state = level;
+
+	if (level == cur_level)
+		return 0;
+	else
+		return 1;
+}
+
+static int
+gk20a_pmu_dvfs_get_dev_status(struct gk20a_pmu_priv *priv,
+		struct gk20a_pmu_dvfs_dev_status *status)
+{
+	status->busy = nv_rd32(priv, 0x10a508 + (BUSY_SLOT * 0x10));
+	status->total= nv_rd32(priv, 0x10a508 + (CLK_SLOT * 0x10));
+	return 0;
+}
+
+static void
+gk20a_pmu_dvfs_reset_dev_status(struct gk20a_pmu_priv *priv)
+{
+	nv_wr32(priv, 0x10a508 + (BUSY_SLOT * 0x10), 0x80000000);
+	nv_wr32(priv, 0x10a508 + (CLK_SLOT * 0x10), 0x80000000);
+}
+
+static void
+gk20a_pmu_dvfs_work(struct nouveau_alarm *alarm)
+{
+	struct gk20a_pmu_priv *priv = container_of(alarm,
+					struct gk20a_pmu_priv, alarm);
+	struct gk20a_pmu_dvfs_data *data = priv->data;
+	struct gk20a_pmu_dvfs_dev_status status;
+	struct nouveau_clk *clk = nouveau_clk(priv);
+	struct nouveau_volt *volt = nouveau_volt(priv);
+	u32 utilization = 0;
+	int state, ret;
+
+	/*
+	 * The PMU is initialized before CLK and VOLT, so we have to make sure the
+	 * CLK and VOLT are ready here.
+	 */
+	if (!clk || !volt)
+		goto resched;
+
+	ret = gk20a_pmu_dvfs_get_dev_status(priv, &status);
+	if (ret) {
+		nv_warn(priv, "failed to get device status\n");
+		goto resched;
+	}
+
+	if (status.total)
+		utilization = div_u64((u64)status.busy * 100, status.total);
+
+	data->avg_load = (data->p_smooth * data->avg_load) + utilization;
+	data->avg_load /= data->p_smooth + 1;
+	nv_trace(priv, "utilization = %d %%, avg_load = %d %%\n",
+			utilization, data->avg_load);
+
+	ret = gk20a_pmu_dvfs_get_cur_state(priv, &state);
+	if (ret) {
+		nv_warn(priv, "failed to get current state\n");
+		goto resched;
+	}
+
+	if (gk20a_pmu_dvfs_get_target_state(priv, &state, data->avg_load)) {
+		nv_trace(priv, "set new state to %d\n", state);
+		gk20a_pmu_dvfs_target(priv, &state);
+	}
+
+resched:
+	gk20a_pmu_dvfs_reset_dev_status(priv);
+	nouveau_timer_alarm(priv, 100000000, alarm);
+}
+
+int
+gk20a_pmu_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nouveau_pmu *pmu = (void *)object;
+	struct gk20a_pmu_priv *priv = (void *)pmu;
+
+	nouveau_timer_alarm_cancel(priv, &priv->alarm);
+
+	return nouveau_subdev_fini(&pmu->base, suspend);
+}
+
+int
+gk20a_pmu_init(struct nouveau_object *object)
+{
+	struct nouveau_pmu *pmu = (void *)object;
+	struct gk20a_pmu_priv *priv = (void *)pmu;
+	int ret;
+
+	ret = nouveau_subdev_init(&pmu->base);
+	if (ret)
+		return ret;
+
+	pmu->pgob = nouveau_pmu_pgob;
+
+	/* init pwr perf counter */
+	nv_wr32(pmu, 0x10a504 + (BUSY_SLOT * 0x10), 0x00200001);
+	nv_wr32(pmu, 0x10a50c + (BUSY_SLOT * 0x10), 0x00000002);
+	nv_wr32(pmu, 0x10a50c + (CLK_SLOT * 0x10), 0x00000003);
+
+	nouveau_timer_alarm(pmu, 2000000000, &priv->alarm);
+
+	return ret;
+}
+
+struct gk20a_pmu_dvfs_data gk20a_dvfs_data= {
+	.p_load_target = 70,
+	.p_load_max = 90,
+	.p_smooth = 1,
+};
+
+static int
+gk20a_pmu_ctor(struct nouveau_object *parent,
+		  struct nouveau_object *engine,
+		  struct nouveau_oclass *oclass, void *data, u32 size,
+		  struct nouveau_object **pobject)
+{
+	struct gk20a_pmu_priv *priv;
+	int ret;
+
+	ret = nouveau_pmu_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	priv->data = &gk20a_dvfs_data;
+
+	nouveau_alarm_init(&priv->alarm, gk20a_pmu_dvfs_work);
+
+	return 0;
+}
+
+struct nouveau_oclass *
+gk20a_pmu_oclass = &(struct nvkm_pmu_impl) {
+	.base.handle = NV_SUBDEV(PMU, 0xea),
+	.base.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = gk20a_pmu_ctor,
+		.dtor = _nouveau_pmu_dtor,
+		.init = gk20a_pmu_init,
+		.fini = gk20a_pmu_fini,
+	},
+}.base;
