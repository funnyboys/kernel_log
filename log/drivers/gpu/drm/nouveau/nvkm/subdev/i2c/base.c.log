commit 7cb95eeea6706c790571042a06782e378b2561ea
Author: Lyude Paul <lyude@redhat.com>
Date:   Wed Jun 26 14:10:27 2019 -0400

    drm/nouveau/i2c: Enable i2c pads & busses during preinit
    
    It turns out that while disabling i2c bus access from software when the
    GPU is suspended was a step in the right direction with:
    
    commit 342406e4fbba ("drm/nouveau/i2c: Disable i2c bus access after
    ->fini()")
    
    We also ended up accidentally breaking the vbios init scripts on some
    older Tesla GPUs, as apparently said scripts can actually use the i2c
    bus. Since these scripts are executed before initializing any
    subdevices, we end up failing to acquire access to the i2c bus which has
    left a number of cards with their fan controllers uninitialized. Luckily
    this doesn't break hardware - it just means the fan gets stuck at 100%.
    
    This also means that we've always been using our i2c busses before
    initializing them during the init scripts for older GPUs, we just didn't
    notice it until we started preventing them from being used until init.
    It's pretty impressive this never caused us any issues before!
    
    So, fix this by initializing our i2c pad and busses during subdev
    pre-init. We skip initializing aux busses during pre-init, as those are
    guaranteed to only ever be used by nouveau for DP aux transactions.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Tested-by: Marc Meledandri <m.meledandri@gmail.com>
    Fixes: 342406e4fbba ("drm/nouveau/i2c: Disable i2c bus access after ->fini()")
    Cc: stable@vger.kernel.org
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
index ecacb22834d7..719345074711 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
@@ -184,6 +184,25 @@ nvkm_i2c_fini(struct nvkm_subdev *subdev, bool suspend)
 	return 0;
 }
 
+static int
+nvkm_i2c_preinit(struct nvkm_subdev *subdev)
+{
+	struct nvkm_i2c *i2c = nvkm_i2c(subdev);
+	struct nvkm_i2c_bus *bus;
+	struct nvkm_i2c_pad *pad;
+
+	/*
+	 * We init our i2c busses as early as possible, since they may be
+	 * needed by the vbios init scripts on some cards
+	 */
+	list_for_each_entry(pad, &i2c->pad, head)
+		nvkm_i2c_pad_init(pad);
+	list_for_each_entry(bus, &i2c->bus, head)
+		nvkm_i2c_bus_init(bus);
+
+	return 0;
+}
+
 static int
 nvkm_i2c_init(struct nvkm_subdev *subdev)
 {
@@ -238,6 +257,7 @@ nvkm_i2c_dtor(struct nvkm_subdev *subdev)
 static const struct nvkm_subdev_func
 nvkm_i2c = {
 	.dtor = nvkm_i2c_dtor,
+	.preinit = nvkm_i2c_preinit,
 	.init = nvkm_i2c_init,
 	.fini = nvkm_i2c_fini,
 	.intr = nvkm_i2c_intr,

commit 342406e4fbba9a174125fbfe6aeac3d64ef90f76
Author: Lyude Paul <lyude@redhat.com>
Date:   Tue Apr 9 16:23:30 2019 -0400

    drm/nouveau/i2c: Disable i2c bus access after ->fini()
    
    For a while, we've had the problem of i2c bus access not grabbing
    a runtime PM ref when it's being used in userspace by i2c-dev, resulting
    in nouveau spamming the kernel log with errors if anything attempts to
    access the i2c bus while the GPU is in runtime suspend. An example:
    
    [  130.078386] nouveau 0000:01:00.0: i2c: aux 000d: begin idle timeout ffffffff
    
    Since the GPU is in runtime suspend, the MMIO region that the i2c bus is
    on isn't accessible. On x86, the standard behavior for accessing an
    unavailable MMIO region is to just return ~0.
    
    Except, that turned out to be a lie. While computers with a clean
    concious will return ~0 in this scenario, some machines will actually
    completely hang a CPU on certian bad MMIO accesses. This was witnessed
    with someone's Lenovo ThinkPad P50, where sensors-detect attempting to
    access the i2c bus while the GPU was suspended would result in a CPU
    hang:
    
      CPU: 5 PID: 12438 Comm: sensors-detect Not tainted 5.0.0-0.rc4.git3.1.fc30.x86_64 #1
      Hardware name: LENOVO 20EQS64N17/20EQS64N17, BIOS N1EET74W (1.47 ) 11/21/2017
      RIP: 0010:ioread32+0x2b/0x30
      Code: 81 ff ff ff 03 00 77 20 48 81 ff 00 00 01 00 76 05 0f b7 d7 ed c3
      48 c7 c6 e1 0c 36 96 e8 2d ff ff ff b8 ff ff ff ff c3 8b 07 <c3> 0f 1f
      40 00 49 89 f0 48 81 fe ff ff 03 00 76 04 40 88 3e c3 48
      RSP: 0018:ffffaac3c5007b48 EFLAGS: 00000292 ORIG_RAX: ffffffffffffff13
      RAX: 0000000001111000 RBX: 0000000001111000 RCX: 0000043017a97186
      RDX: 0000000000000aaa RSI: 0000000000000005 RDI: ffffaac3c400e4e4
      RBP: ffff9e6443902c00 R08: ffffaac3c400e4e4 R09: ffffaac3c5007be7
      R10: 0000000000000004 R11: 0000000000000001 R12: ffff9e6445dd0000
      R13: 000000000000e4e4 R14: 00000000000003c4 R15: 0000000000000000
      FS:  00007f253155a740(0000) GS:ffff9e644f600000(0000) knlGS:0000000000000000
      CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
      CR2: 00005630d1500358 CR3: 0000000417c44006 CR4: 00000000003606e0
      DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
      DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
      Call Trace:
       g94_i2c_aux_xfer+0x326/0x850 [nouveau]
       nvkm_i2c_aux_i2c_xfer+0x9e/0x140 [nouveau]
       __i2c_transfer+0x14b/0x620
       i2c_smbus_xfer_emulated+0x159/0x680
       ? _raw_spin_unlock_irqrestore+0x1/0x60
       ? rt_mutex_slowlock.constprop.0+0x13d/0x1e0
       ? __lock_is_held+0x59/0xa0
       __i2c_smbus_xfer+0x138/0x5a0
       i2c_smbus_xfer+0x4f/0x80
       i2cdev_ioctl_smbus+0x162/0x2d0 [i2c_dev]
       i2cdev_ioctl+0x1db/0x2c0 [i2c_dev]
       do_vfs_ioctl+0x408/0x750
       ksys_ioctl+0x5e/0x90
       __x64_sys_ioctl+0x16/0x20
       do_syscall_64+0x60/0x1e0
       entry_SYSCALL_64_after_hwframe+0x49/0xbe
      RIP: 0033:0x7f25317f546b
      Code: 0f 1e fa 48 8b 05 1d da 0c 00 64 c7 00 26 00 00 00 48 c7 c0 ff ff
      ff ff c3 66 0f 1f 44 00 00 f3 0f 1e fa b8 10 00 00 00 0f 05 <48> 3d 01
      f0 ff ff 73 01 c3 48 8b 0d ed d9 0c 00 f7 d8 64 89 01 48
      RSP: 002b:00007ffc88caab68 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
      RAX: ffffffffffffffda RBX: 00005630d0fe7260 RCX: 00007f25317f546b
      RDX: 00005630d1598e80 RSI: 0000000000000720 RDI: 0000000000000003
      RBP: 00005630d155b968 R08: 0000000000000001 R09: 00005630d15a1da0
      R10: 0000000000000070 R11: 0000000000000246 R12: 00005630d1598e80
      R13: 00005630d12f3d28 R14: 0000000000000720 R15: 00005630d12f3ce0
      watchdog: BUG: soft lockup - CPU#5 stuck for 23s! [sensors-detect:12438]
    
    Yikes! While I wanted to try to make it so that accessing an i2c bus on
    nouveau would wake up the GPU as needed, airlied pointed out that pretty
    much any usecase for userspace accessing an i2c bus on a GPU (mainly for
    the DDC brightness control that some displays have) is going to only be
    useful while there's at least one display enabled on the GPU anyway, and
    the GPU never sleeps while there's displays running.
    
    Since teaching the i2c bus to wake up the GPU on userspace accesses is a
    good deal more difficult than it might seem, mostly due to the fact that
    we have to use the i2c bus during runtime resume of the GPU, we instead
    opt for the easiest solution: don't let userspace access i2c busses on
    the GPU at all while it's in runtime suspend.
    
    Changes since v1:
    * Also disable i2c busses that run over DP AUX
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
index 4f197b15acf6..ecacb22834d7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
@@ -160,8 +160,18 @@ nvkm_i2c_fini(struct nvkm_subdev *subdev, bool suspend)
 {
 	struct nvkm_i2c *i2c = nvkm_i2c(subdev);
 	struct nvkm_i2c_pad *pad;
+	struct nvkm_i2c_bus *bus;
+	struct nvkm_i2c_aux *aux;
 	u32 mask;
 
+	list_for_each_entry(aux, &i2c->aux, head) {
+		nvkm_i2c_aux_fini(aux);
+	}
+
+	list_for_each_entry(bus, &i2c->bus, head) {
+		nvkm_i2c_bus_fini(bus);
+	}
+
 	if ((mask = (1 << i2c->func->aux) - 1), i2c->func->aux_stat) {
 		i2c->func->aux_mask(i2c, NVKM_I2C_ANY, mask, 0);
 		i2c->func->aux_stat(i2c, &mask, &mask, &mask, &mask);
@@ -180,6 +190,7 @@ nvkm_i2c_init(struct nvkm_subdev *subdev)
 	struct nvkm_i2c *i2c = nvkm_i2c(subdev);
 	struct nvkm_i2c_bus *bus;
 	struct nvkm_i2c_pad *pad;
+	struct nvkm_i2c_aux *aux;
 
 	list_for_each_entry(pad, &i2c->pad, head) {
 		nvkm_i2c_pad_init(pad);
@@ -189,6 +200,10 @@ nvkm_i2c_init(struct nvkm_subdev *subdev)
 		nvkm_i2c_bus_init(bus);
 	}
 
+	list_for_each_entry(aux, &i2c->aux, head) {
+		nvkm_i2c_aux_init(aux);
+	}
+
 	return 0;
 }
 

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
index 243a71ff0a0d..4f197b15acf6 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
@@ -254,7 +254,7 @@ nvkm_i2c_new_(const struct nvkm_i2c_func *func, struct nvkm_device *device,
 	if (!(i2c = *pi2c = kzalloc(sizeof(*i2c), GFP_KERNEL)))
 		return -ENOMEM;
 
-	nvkm_subdev_ctor(&nvkm_i2c, device, index, 0, &i2c->subdev);
+	nvkm_subdev_ctor(&nvkm_i2c, device, index, &i2c->subdev);
 	i2c->func = func;
 	INIT_LIST_HEAD(&i2c->pad);
 	INIT_LIST_HEAD(&i2c->bus);

commit 49bd8da5130aa2de1c891c71163a033254eaf932
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/i2c: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
index fe29e728a602..243a71ff0a0d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
@@ -91,9 +91,8 @@ nvkm_i2c_intr_fini(struct nvkm_event *event, int type, int id)
 {
 	struct nvkm_i2c *i2c = container_of(event, typeof(*i2c), event);
 	struct nvkm_i2c_aux *aux = nvkm_i2c_aux_find(i2c, id);
-	const struct nvkm_i2c_impl *impl = (void *)nv_object(i2c)->oclass;
 	if (aux)
-		impl->aux_mask(i2c, type, aux->intr, 0);
+		i2c->func->aux_mask(i2c, type, aux->intr, 0);
 }
 
 static void
@@ -101,9 +100,8 @@ nvkm_i2c_intr_init(struct nvkm_event *event, int type, int id)
 {
 	struct nvkm_i2c *i2c = container_of(event, typeof(*i2c), event);
 	struct nvkm_i2c_aux *aux = nvkm_i2c_aux_find(i2c, id);
-	const struct nvkm_i2c_impl *impl = (void *)nv_object(i2c)->oclass;
 	if (aux)
-		impl->aux_mask(i2c, type, aux->intr, aux->intr);
+		i2c->func->aux_mask(i2c, type, aux->intr, aux->intr);
 }
 
 static int
@@ -120,18 +118,24 @@ nvkm_i2c_intr_ctor(struct nvkm_object *object, void *data, u32 size,
 	return -EINVAL;
 }
 
+static const struct nvkm_event_func
+nvkm_i2c_intr_func = {
+	.ctor = nvkm_i2c_intr_ctor,
+	.init = nvkm_i2c_intr_init,
+	.fini = nvkm_i2c_intr_fini,
+};
+
 static void
-nvkm_i2c_intr(struct nvkm_subdev *obj)
+nvkm_i2c_intr(struct nvkm_subdev *subdev)
 {
-	struct nvkm_i2c *i2c = container_of(obj, typeof(*i2c), subdev);
-	struct nvkm_i2c_impl *impl = (void *)i2c->subdev.object.oclass;
+	struct nvkm_i2c *i2c = nvkm_i2c(subdev);
 	struct nvkm_i2c_aux *aux;
 	u32 hi, lo, rq, tx;
 
-	if (!impl->aux_stat)
+	if (!i2c->func->aux_stat)
 		return;
 
-	impl->aux_stat(i2c, &hi, &lo, &rq, &tx);
+	i2c->func->aux_stat(i2c, &hi, &lo, &rq, &tx);
 	if (!hi && !lo && !rq && !tx)
 		return;
 
@@ -151,44 +155,31 @@ nvkm_i2c_intr(struct nvkm_subdev *obj)
 	}
 }
 
-static const struct nvkm_event_func
-nvkm_i2c_intr_func = {
-	.ctor = nvkm_i2c_intr_ctor,
-	.init = nvkm_i2c_intr_init,
-	.fini = nvkm_i2c_intr_fini,
-};
-
-int
-_nvkm_i2c_fini(struct nvkm_object *object, bool suspend)
+static int
+nvkm_i2c_fini(struct nvkm_subdev *subdev, bool suspend)
 {
-	struct nvkm_i2c_impl *impl = (void *)nv_oclass(object);
-	struct nvkm_i2c *i2c = (void *)object;
+	struct nvkm_i2c *i2c = nvkm_i2c(subdev);
 	struct nvkm_i2c_pad *pad;
 	u32 mask;
 
-	if ((mask = (1 << impl->aux) - 1), impl->aux_stat) {
-		impl->aux_mask(i2c, NVKM_I2C_ANY, mask, 0);
-		impl->aux_stat(i2c, &mask, &mask, &mask, &mask);
+	if ((mask = (1 << i2c->func->aux) - 1), i2c->func->aux_stat) {
+		i2c->func->aux_mask(i2c, NVKM_I2C_ANY, mask, 0);
+		i2c->func->aux_stat(i2c, &mask, &mask, &mask, &mask);
 	}
 
 	list_for_each_entry(pad, &i2c->pad, head) {
 		nvkm_i2c_pad_fini(pad);
 	}
 
-	return nvkm_subdev_fini_old(&i2c->subdev, suspend);
+	return 0;
 }
 
-int
-_nvkm_i2c_init(struct nvkm_object *object)
+static int
+nvkm_i2c_init(struct nvkm_subdev *subdev)
 {
-	struct nvkm_i2c *i2c = (void *)object;
+	struct nvkm_i2c *i2c = nvkm_i2c(subdev);
 	struct nvkm_i2c_bus *bus;
 	struct nvkm_i2c_pad *pad;
-	int ret;
-
-	ret = nvkm_subdev_init_old(&i2c->subdev);
-	if (ret)
-		return ret;
 
 	list_for_each_entry(pad, &i2c->pad, head) {
 		nvkm_i2c_pad_init(pad);
@@ -201,10 +192,10 @@ _nvkm_i2c_init(struct nvkm_object *object)
 	return 0;
 }
 
-void
-_nvkm_i2c_dtor(struct nvkm_object *object)
+static void *
+nvkm_i2c_dtor(struct nvkm_subdev *subdev)
 {
-	struct nvkm_i2c *i2c = (void *)object;
+	struct nvkm_i2c *i2c = nvkm_i2c(subdev);
 
 	nvkm_event_fini(&i2c->event);
 
@@ -226,9 +217,17 @@ _nvkm_i2c_dtor(struct nvkm_object *object)
 		nvkm_i2c_pad_del(&pad);
 	}
 
-	nvkm_subdev_destroy(&i2c->subdev);
+	return i2c;
 }
 
+static const struct nvkm_subdev_func
+nvkm_i2c = {
+	.dtor = nvkm_i2c_dtor,
+	.init = nvkm_i2c_init,
+	.fini = nvkm_i2c_fini,
+	.intr = nvkm_i2c_intr,
+};
+
 static const struct nvkm_i2c_drv {
 	u8 bios;
 	u8 addr;
@@ -242,11 +241,9 @@ nvkm_i2c_drv[] = {
 };
 
 int
-nvkm_i2c_create_(struct nvkm_object *parent, struct nvkm_object *engine,
-		 struct nvkm_oclass *oclass, int length, void **pobject)
+nvkm_i2c_new_(const struct nvkm_i2c_func *func, struct nvkm_device *device,
+	      int index, struct nvkm_i2c **pi2c)
 {
-	struct nvkm_i2c_impl *impl = (void *)oclass;
-	struct nvkm_device *device = (void *)parent;
 	struct nvkm_bios *bios = device->bios;
 	struct nvkm_i2c *i2c;
 	struct dcb_i2c_entry ccbE;
@@ -254,17 +251,15 @@ nvkm_i2c_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 	u8 ver, hdr;
 	int ret, i;
 
-	ret = nvkm_subdev_create(parent, engine, oclass, 0, "I2C", "i2c", &i2c);
-	*pobject = nv_object(i2c);
-	if (ret)
-		return ret;
+	if (!(i2c = *pi2c = kzalloc(sizeof(*i2c), GFP_KERNEL)))
+		return -ENOMEM;
 
+	nvkm_subdev_ctor(&nvkm_i2c, device, index, 0, &i2c->subdev);
+	i2c->func = func;
 	INIT_LIST_HEAD(&i2c->pad);
 	INIT_LIST_HEAD(&i2c->bus);
 	INIT_LIST_HEAD(&i2c->aux);
 
-	nv_subdev(i2c)->intr = nvkm_i2c_intr;
-
 	i = -1;
 	while (!dcb_i2c_parse(bios, ++i, &ccbE)) {
 		struct nvkm_i2c_pad *pad = NULL;
@@ -278,11 +273,11 @@ nvkm_i2c_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		if (ccbE.share != DCB_I2C_UNUSED) {
 			const int id = NVKM_I2C_PAD_HYBRID(ccbE.share);
 			if (!(pad = nvkm_i2c_pad_find(i2c, id)))
-				ret = impl->pad_s_new(i2c, id, &pad);
+				ret = func->pad_s_new(i2c, id, &pad);
 			else
 				ret = 0;
 		} else {
-			ret = impl->pad_x_new(i2c, NVKM_I2C_PAD_CCB(i), &pad);
+			ret = func->pad_x_new(i2c, NVKM_I2C_PAD_CCB(i), &pad);
 		}
 
 		if (ret) {
@@ -397,25 +392,5 @@ nvkm_i2c_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		}
 	}
 
-	ret = nvkm_event_init(&nvkm_i2c_intr_func, 4, i, &i2c->event);
-	if (ret)
-		return ret;
-
-	return 0;
-}
-
-int
-_nvkm_i2c_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-	       struct nvkm_oclass *oclass, void *data, u32 size,
-	       struct nvkm_object **pobject)
-{
-	struct nvkm_i2c *i2c;
-	int ret;
-
-	ret = nvkm_i2c_create(parent, engine, oclass, &i2c);
-	*pobject = nv_object(i2c);
-	if (ret)
-		return ret;
-
-	return 0;
+	return nvkm_event_init(&nvkm_i2c_intr_func, 4, i, &i2c->event);
 }

commit 3a8c3400f3e74638bedd0d2410416aa8b794c0fd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/subdev: rename some functions to avoid upcoming conflicts
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
index 86bff984e7e1..fe29e728a602 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
@@ -175,7 +175,7 @@ _nvkm_i2c_fini(struct nvkm_object *object, bool suspend)
 		nvkm_i2c_pad_fini(pad);
 	}
 
-	return nvkm_subdev_fini(&i2c->subdev, suspend);
+	return nvkm_subdev_fini_old(&i2c->subdev, suspend);
 }
 
 int
@@ -186,7 +186,7 @@ _nvkm_i2c_init(struct nvkm_object *object)
 	struct nvkm_i2c_pad *pad;
 	int ret;
 
-	ret = nvkm_subdev_init(&i2c->subdev);
+	ret = nvkm_subdev_init_old(&i2c->subdev);
 	if (ret)
 		return ret;
 

commit 2aa5eac5163fedf09f2d61992cb5ea4d75bec9db
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:15 2015 +1000

    drm/nouveau/i2c: transition pad/ports away from being based on nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
index 6b0f8f0746f5..86bff984e7e1 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
@@ -22,330 +22,93 @@
  * Authors: Ben Skeggs
  */
 #include "priv.h"
+#include "aux.h"
+#include "bus.h"
 #include "pad.h"
 
 #include <core/notify.h>
 #include <core/option.h>
 #include <subdev/bios.h>
 #include <subdev/bios/dcb.h>
+#include <subdev/bios/i2c.h>
 
-/******************************************************************************
- * interface to linux i2c bit-banging algorithm
- *****************************************************************************/
-
-#ifdef CONFIG_NOUVEAU_I2C_INTERNAL_DEFAULT
-#define CSTMSEL true
-#else
-#define CSTMSEL false
-#endif
-
-static int
-nvkm_i2c_pre_xfer(struct i2c_adapter *adap)
-{
-	struct i2c_algo_bit_data *bit = adap->algo_data;
-	struct nvkm_i2c_port *port = bit->data;
-	return nvkm_i2c(port)->acquire(port, bit->timeout);
-}
-
-static void
-nvkm_i2c_post_xfer(struct i2c_adapter *adap)
-{
-	struct i2c_algo_bit_data *bit = adap->algo_data;
-	struct nvkm_i2c_port *port = bit->data;
-	return nvkm_i2c(port)->release(port);
-}
-
-static void
-nvkm_i2c_setscl(void *data, int state)
-{
-	struct nvkm_i2c_port *port = data;
-	port->func->drive_scl(port, state);
-}
-
-static void
-nvkm_i2c_setsda(void *data, int state)
-{
-	struct nvkm_i2c_port *port = data;
-	port->func->drive_sda(port, state);
-}
-
-static int
-nvkm_i2c_getscl(void *data)
+static struct nvkm_i2c_pad *
+nvkm_i2c_pad_find(struct nvkm_i2c *i2c, int id)
 {
-	struct nvkm_i2c_port *port = data;
-	return port->func->sense_scl(port);
-}
-
-static int
-nvkm_i2c_getsda(void *data)
-{
-	struct nvkm_i2c_port *port = data;
-	return port->func->sense_sda(port);
-}
-
-/******************************************************************************
- * base i2c "port" class implementation
- *****************************************************************************/
-
-int
-_nvkm_i2c_port_fini(struct nvkm_object *object, bool suspend)
-{
-	struct nvkm_i2c_port *port = (void *)object;
-	struct nvkm_i2c_pad *pad = nvkm_i2c_pad(port);
-	nv_ofuncs(pad)->fini(nv_object(pad), suspend);
-	return nvkm_object_fini(&port->base, suspend);
-}
-
-void
-_nvkm_i2c_port_dtor(struct nvkm_object *object)
-{
-	struct nvkm_i2c_port *port = (void *)object;
-	i2c_del_adapter(&port->adapter);
-	nvkm_object_destroy(&port->base);
-}
-
-int
-nvkm_i2c_port_create_(struct nvkm_object *parent, struct nvkm_object *engine,
-		      struct nvkm_oclass *oclass, u8 index,
-		      const struct i2c_algorithm *algo,
-		      const struct nvkm_i2c_func *func,
-		      int size, void **pobject)
-{
-	struct nvkm_device *device = nv_device(parent);
-	struct nvkm_i2c *i2c = nvkm_i2c(parent);
-	struct nvkm_i2c_port *port;
-	int ret;
+	struct nvkm_i2c_pad *pad;
 
-	ret = nvkm_object_create_(parent, engine, oclass, 0, size, pobject);
-	port = *pobject;
-	if (ret)
-		return ret;
-
-	snprintf(port->adapter.name, sizeof(port->adapter.name),
-		 "nvkm-%s-%d", device->name, index);
-	port->adapter.owner = THIS_MODULE;
-	port->adapter.dev.parent = nv_device_base(device);
-	port->index = index;
-	port->aux = -1;
-	port->func = func;
-	mutex_init(&port->mutex);
-
-	if ( algo == &nvkm_i2c_bit_algo &&
-	    !nvkm_boolopt(device->cfgopt, "NvI2C", CSTMSEL)) {
-		struct i2c_algo_bit_data *bit;
-
-		bit = kzalloc(sizeof(*bit), GFP_KERNEL);
-		if (!bit)
-			return -ENOMEM;
-
-		bit->udelay = 10;
-		bit->timeout = usecs_to_jiffies(2200);
-		bit->data = port;
-		bit->pre_xfer = nvkm_i2c_pre_xfer;
-		bit->post_xfer = nvkm_i2c_post_xfer;
-		bit->setsda = nvkm_i2c_setsda;
-		bit->setscl = nvkm_i2c_setscl;
-		bit->getsda = nvkm_i2c_getsda;
-		bit->getscl = nvkm_i2c_getscl;
-
-		port->adapter.algo_data = bit;
-		ret = i2c_bit_add_bus(&port->adapter);
-	} else {
-		port->adapter.algo_data = port;
-		port->adapter.algo = algo;
-		ret = i2c_add_adapter(&port->adapter);
+	list_for_each_entry(pad, &i2c->pad, head) {
+		if (pad->id == id)
+			return pad;
 	}
 
-	if (ret == 0)
-		list_add_tail(&port->head, &i2c->ports);
-	return ret;
+	return NULL;
 }
 
-/******************************************************************************
- * base i2c subdev class implementation
- *****************************************************************************/
-
-static struct nvkm_i2c_port *
-nvkm_i2c_find(struct nvkm_i2c *i2c, u8 index)
+struct nvkm_i2c_bus *
+nvkm_i2c_bus_find(struct nvkm_i2c *i2c, int id)
 {
-	struct nvkm_bios *bios = nvkm_bios(i2c);
-	struct nvkm_i2c_port *port;
+	struct nvkm_bios *bios = i2c->subdev.device->bios;
+	struct nvkm_i2c_bus *bus;
 
-	if (index == NV_I2C_DEFAULT(0) ||
-	    index == NV_I2C_DEFAULT(1)) {
+	if (id == NVKM_I2C_BUS_PRI || id == NVKM_I2C_BUS_SEC) {
 		u8  ver, hdr, cnt, len;
 		u16 i2c = dcb_i2c_table(bios, &ver, &hdr, &cnt, &len);
 		if (i2c && ver >= 0x30) {
 			u8 auxidx = nvbios_rd08(bios, i2c + 4);
-			if (index == NV_I2C_DEFAULT(0))
-				index = (auxidx & 0x0f) >> 0;
+			if (id == NVKM_I2C_BUS_PRI)
+				id = NVKM_I2C_BUS_CCB((auxidx & 0x0f) >> 0);
 			else
-				index = (auxidx & 0xf0) >> 4;
+				id = NVKM_I2C_BUS_CCB((auxidx & 0xf0) >> 4);
 		} else {
-			index = 2;
+			id = NVKM_I2C_BUS_CCB(2);
 		}
 	}
 
-	list_for_each_entry(port, &i2c->ports, head) {
-		if (port->index == index)
-			return port;
+	list_for_each_entry(bus, &i2c->bus, head) {
+		if (bus->id == id)
+			return bus;
 	}
 
 	return NULL;
 }
 
-static struct nvkm_i2c_port *
-nvkm_i2c_find_type(struct nvkm_i2c *i2c, u16 type)
+struct nvkm_i2c_aux *
+nvkm_i2c_aux_find(struct nvkm_i2c *i2c, int id)
 {
-	struct nvkm_i2c_port *port;
+	struct nvkm_i2c_aux *aux;
 
-	list_for_each_entry(port, &i2c->ports, head) {
-		if (nv_hclass(port) == type)
-			return port;
+	list_for_each_entry(aux, &i2c->aux, head) {
+		if (aux->id == id)
+			return aux;
 	}
 
 	return NULL;
 }
 
 static void
-nvkm_i2c_release_pad(struct nvkm_i2c_port *port)
-{
-	struct nvkm_i2c_pad *pad = nvkm_i2c_pad(port);
-	struct nvkm_i2c *i2c = nvkm_i2c(port);
-
-	if (atomic_dec_and_test(&nv_object(pad)->usecount)) {
-		nv_ofuncs(pad)->fini(nv_object(pad), false);
-		wake_up_all(&i2c->wait);
-	}
-}
-
-static int
-nvkm_i2c_try_acquire_pad(struct nvkm_i2c_port *port)
-{
-	struct nvkm_i2c_pad *pad = nvkm_i2c_pad(port);
-
-	if (atomic_add_return(1, &nv_object(pad)->usecount) != 1) {
-		struct nvkm_object *owner = (void *)pad->port;
-		do {
-			if (owner == (void *)port)
-				return 0;
-			owner = owner->parent;
-		} while(owner);
-		nvkm_i2c_release_pad(port);
-		return -EBUSY;
-	}
-
-	pad->next = port;
-	nv_ofuncs(pad)->init(nv_object(pad));
-	return 0;
-}
-
-static int
-nvkm_i2c_acquire_pad(struct nvkm_i2c_port *port, unsigned long timeout)
-{
-	struct nvkm_i2c *i2c = nvkm_i2c(port);
-
-	if (timeout) {
-		if (wait_event_timeout(i2c->wait,
-				       nvkm_i2c_try_acquire_pad(port) == 0,
-				       timeout) == 0)
-			return -EBUSY;
-	} else {
-		wait_event(i2c->wait, nvkm_i2c_try_acquire_pad(port) == 0);
-	}
-
-	return 0;
-}
-
-static void
-nvkm_i2c_release(struct nvkm_i2c_port *port)
-__releases(pad->mutex)
-{
-	nvkm_i2c(port)->release_pad(port);
-	mutex_unlock(&port->mutex);
-}
-
-static int
-nvkm_i2c_acquire(struct nvkm_i2c_port *port, unsigned long timeout)
-__acquires(pad->mutex)
-{
-	int ret;
-	mutex_lock(&port->mutex);
-	if ((ret = nvkm_i2c(port)->acquire_pad(port, timeout)))
-		mutex_unlock(&port->mutex);
-	return ret;
-}
-
-static int
-nvkm_i2c_identify(struct nvkm_i2c *i2c, int index, const char *what,
-		  struct nvkm_i2c_board_info *info,
-		  bool (*match)(struct nvkm_i2c_port *,
-				struct i2c_board_info *, void *), void *data)
-{
-	struct nvkm_subdev *subdev = &i2c->subdev;
-	struct nvkm_i2c_port *port = nvkm_i2c_find(i2c, index);
-	int i;
-
-	if (!port) {
-		nvkm_debug(subdev, "no bus when probing %s on %d\n",
-			   what, index);
-		return -ENODEV;
-	}
-
-	nvkm_debug(subdev, "probing %ss on bus: %d\n", what, port->index);
-	for (i = 0; info[i].dev.addr; i++) {
-		u8 orig_udelay = 0;
-
-		if ((port->adapter.algo == &i2c_bit_algo) &&
-		    (info[i].udelay != 0)) {
-			struct i2c_algo_bit_data *algo = port->adapter.algo_data;
-			nvkm_debug(subdev,
-				   "using custom udelay %d instead of %d\n",
-				   info[i].udelay, algo->udelay);
-			orig_udelay = algo->udelay;
-			algo->udelay = info[i].udelay;
-		}
-
-		if (nv_probe_i2c(port, info[i].dev.addr) &&
-		    (!match || match(port, &info[i].dev, data))) {
-			nvkm_info(subdev, "detected %s: %s\n", what,
-				  info[i].dev.type);
-			return i;
-		}
-
-		if (orig_udelay) {
-			struct i2c_algo_bit_data *algo = port->adapter.algo_data;
-			algo->udelay = orig_udelay;
-		}
-	}
-
-	nvkm_debug(subdev, "no devices found.\n");
-	return -ENODEV;
-}
-
-static void
-nvkm_i2c_intr_fini(struct nvkm_event *event, int type, int index)
+nvkm_i2c_intr_fini(struct nvkm_event *event, int type, int id)
 {
 	struct nvkm_i2c *i2c = container_of(event, typeof(*i2c), event);
-	struct nvkm_i2c_port *port = i2c->find(i2c, index);
+	struct nvkm_i2c_aux *aux = nvkm_i2c_aux_find(i2c, id);
 	const struct nvkm_i2c_impl *impl = (void *)nv_object(i2c)->oclass;
-	if (port && port->aux >= 0)
-		impl->aux_mask(i2c, type, 1 << port->aux, 0);
+	if (aux)
+		impl->aux_mask(i2c, type, aux->intr, 0);
 }
 
 static void
-nvkm_i2c_intr_init(struct nvkm_event *event, int type, int index)
+nvkm_i2c_intr_init(struct nvkm_event *event, int type, int id)
 {
 	struct nvkm_i2c *i2c = container_of(event, typeof(*i2c), event);
-	struct nvkm_i2c_port *port = i2c->find(i2c, index);
+	struct nvkm_i2c_aux *aux = nvkm_i2c_aux_find(i2c, id);
 	const struct nvkm_i2c_impl *impl = (void *)nv_object(i2c)->oclass;
-	if (port && port->aux >= 0)
-		impl->aux_mask(i2c, type, 1 << port->aux, 1 << port->aux);
+	if (aux)
+		impl->aux_mask(i2c, type, aux->intr, aux->intr);
 }
 
 static int
 nvkm_i2c_intr_ctor(struct nvkm_object *object, void *data, u32 size,
-		      struct nvkm_notify *notify)
+		   struct nvkm_notify *notify)
 {
 	struct nvkm_i2c_ntfy_req *req = data;
 	if (!WARN_ON(size != sizeof(*req))) {
@@ -358,33 +121,32 @@ nvkm_i2c_intr_ctor(struct nvkm_object *object, void *data, u32 size,
 }
 
 static void
-nvkm_i2c_intr(struct nvkm_subdev *subdev)
+nvkm_i2c_intr(struct nvkm_subdev *obj)
 {
-	struct nvkm_i2c_impl *impl = (void *)nv_oclass(subdev);
-	struct nvkm_i2c *i2c = nvkm_i2c(subdev);
-	struct nvkm_i2c_port *port;
-	u32 hi, lo, rq, tx, e;
-
-	if (impl->aux_stat) {
-		impl->aux_stat(i2c, &hi, &lo, &rq, &tx);
-		if (hi || lo || rq || tx) {
-			list_for_each_entry(port, &i2c->ports, head) {
-				if (e = 0, port->aux < 0)
-					continue;
-
-				if (hi & (1 << port->aux)) e |= NVKM_I2C_PLUG;
-				if (lo & (1 << port->aux)) e |= NVKM_I2C_UNPLUG;
-				if (rq & (1 << port->aux)) e |= NVKM_I2C_IRQ;
-				if (tx & (1 << port->aux)) e |= NVKM_I2C_DONE;
-				if (e) {
-					struct nvkm_i2c_ntfy_rep rep = {
-						.mask = e,
-					};
-					nvkm_event_send(&i2c->event, rep.mask,
-							port->index, &rep,
-							sizeof(rep));
-				}
-			}
+	struct nvkm_i2c *i2c = container_of(obj, typeof(*i2c), subdev);
+	struct nvkm_i2c_impl *impl = (void *)i2c->subdev.object.oclass;
+	struct nvkm_i2c_aux *aux;
+	u32 hi, lo, rq, tx;
+
+	if (!impl->aux_stat)
+		return;
+
+	impl->aux_stat(i2c, &hi, &lo, &rq, &tx);
+	if (!hi && !lo && !rq && !tx)
+		return;
+
+	list_for_each_entry(aux, &i2c->aux, head) {
+		u32 mask = 0;
+		if (hi & aux->intr) mask |= NVKM_I2C_PLUG;
+		if (lo & aux->intr) mask |= NVKM_I2C_UNPLUG;
+		if (rq & aux->intr) mask |= NVKM_I2C_IRQ;
+		if (tx & aux->intr) mask |= NVKM_I2C_DONE;
+		if (mask) {
+			struct nvkm_i2c_ntfy_rep rep = {
+				.mask = mask,
+			};
+			nvkm_event_send(&i2c->event, rep.mask, aux->id,
+					&rep, sizeof(rep));
 		}
 	}
 }
@@ -401,206 +163,241 @@ _nvkm_i2c_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nvkm_i2c_impl *impl = (void *)nv_oclass(object);
 	struct nvkm_i2c *i2c = (void *)object;
-	struct nvkm_i2c_port *port;
+	struct nvkm_i2c_pad *pad;
 	u32 mask;
-	int ret;
-
-	list_for_each_entry(port, &i2c->ports, head) {
-		ret = nv_ofuncs(port)->fini(nv_object(port), suspend);
-		if (ret && suspend)
-			goto fail;
-	}
 
 	if ((mask = (1 << impl->aux) - 1), impl->aux_stat) {
 		impl->aux_mask(i2c, NVKM_I2C_ANY, mask, 0);
 		impl->aux_stat(i2c, &mask, &mask, &mask, &mask);
 	}
 
-	return nvkm_subdev_fini(&i2c->subdev, suspend);
-fail:
-	list_for_each_entry_continue_reverse(port, &i2c->ports, head) {
-		nv_ofuncs(port)->init(nv_object(port));
+	list_for_each_entry(pad, &i2c->pad, head) {
+		nvkm_i2c_pad_fini(pad);
 	}
 
-	return ret;
+	return nvkm_subdev_fini(&i2c->subdev, suspend);
 }
 
 int
 _nvkm_i2c_init(struct nvkm_object *object)
 {
 	struct nvkm_i2c *i2c = (void *)object;
-	struct nvkm_i2c_port *port;
+	struct nvkm_i2c_bus *bus;
+	struct nvkm_i2c_pad *pad;
 	int ret;
 
 	ret = nvkm_subdev_init(&i2c->subdev);
-	if (ret == 0) {
-		list_for_each_entry(port, &i2c->ports, head) {
-			ret = nv_ofuncs(port)->init(nv_object(port));
-			if (ret)
-				goto fail;
-		}
+	if (ret)
+		return ret;
+
+	list_for_each_entry(pad, &i2c->pad, head) {
+		nvkm_i2c_pad_init(pad);
 	}
 
-	return ret;
-fail:
-	list_for_each_entry_continue_reverse(port, &i2c->ports, head) {
-		nv_ofuncs(port)->fini(nv_object(port), false);
+	list_for_each_entry(bus, &i2c->bus, head) {
+		nvkm_i2c_bus_init(bus);
 	}
 
-	return ret;
+	return 0;
 }
 
 void
 _nvkm_i2c_dtor(struct nvkm_object *object)
 {
 	struct nvkm_i2c *i2c = (void *)object;
-	struct nvkm_i2c_port *port, *temp;
 
 	nvkm_event_fini(&i2c->event);
 
-	list_for_each_entry_safe(port, temp, &i2c->ports, head) {
-		nvkm_object_ref(NULL, (struct nvkm_object **)&port);
+	while (!list_empty(&i2c->aux)) {
+		struct nvkm_i2c_aux *aux =
+			list_first_entry(&i2c->aux, typeof(*aux), head);
+		nvkm_i2c_aux_del(&aux);
 	}
 
-	nvkm_subdev_destroy(&i2c->subdev);
-}
-
-static struct nvkm_oclass *
-nvkm_i2c_extdev_sclass[] = {
-	nvkm_anx9805_sclass,
-};
-
-static void
-nvkm_i2c_create_port(struct nvkm_i2c *i2c, int index, u8 type,
-		     struct dcb_i2c_entry *info)
-{
-	const struct nvkm_i2c_impl *impl = (void *)nv_oclass(i2c);
-	struct nvkm_oclass *oclass;
-	struct nvkm_object *parent;
-	struct nvkm_object *object;
-	int ret, pad;
-
-	if (info->share != DCB_I2C_UNUSED) {
-		pad    = info->share;
-		oclass = impl->pad_s;
-	} else {
-		if (type != DCB_I2C_NVIO_AUX)
-			pad = 0x100 + info->drive;
-		else
-			pad = 0x100 + info->auxch;
-		oclass = impl->pad_x;
+	while (!list_empty(&i2c->bus)) {
+		struct nvkm_i2c_bus *bus =
+			list_first_entry(&i2c->bus, typeof(*bus), head);
+		nvkm_i2c_bus_del(&bus);
 	}
 
-	ret = nvkm_object_ctor(nv_object(i2c), NULL, oclass,
-			       NULL, pad, &parent);
-	if (ret < 0)
-		return;
+	while (!list_empty(&i2c->pad)) {
+		struct nvkm_i2c_pad *pad =
+			list_first_entry(&i2c->pad, typeof(*pad), head);
+		nvkm_i2c_pad_del(&pad);
+	}
 
-	oclass = impl->sclass;
-	do {
-		ret = -EINVAL;
-		if (oclass->handle == type) {
-			ret = nvkm_object_ctor(parent, NULL, oclass,
-					       info, index, &object);
-		}
-	} while (ret && (++oclass)->handle);
+	nvkm_subdev_destroy(&i2c->subdev);
+}
 
-	nvkm_object_ref(NULL, &parent);
+static const struct nvkm_i2c_drv {
+	u8 bios;
+	u8 addr;
+	int (*pad_new)(struct nvkm_i2c_bus *, int id, u8 addr,
+		       struct nvkm_i2c_pad **);
 }
+nvkm_i2c_drv[] = {
+	{ 0x0d, 0x39, anx9805_pad_new },
+	{ 0x0e, 0x3b, anx9805_pad_new },
+	{}
+};
 
 int
 nvkm_i2c_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		 struct nvkm_oclass *oclass, int length, void **pobject)
 {
-	struct nvkm_bios *bios = nvkm_bios(parent);
+	struct nvkm_i2c_impl *impl = (void *)oclass;
+	struct nvkm_device *device = (void *)parent;
+	struct nvkm_bios *bios = device->bios;
 	struct nvkm_i2c *i2c;
-	struct nvkm_object *object;
-	struct dcb_i2c_entry info;
-	int ret, i, j, index = -1;
-	struct dcb_output outp;
-	u8  ver, hdr;
-	u32 data;
+	struct dcb_i2c_entry ccbE;
+	struct dcb_output dcbE;
+	u8 ver, hdr;
+	int ret, i;
 
 	ret = nvkm_subdev_create(parent, engine, oclass, 0, "I2C", "i2c", &i2c);
 	*pobject = nv_object(i2c);
 	if (ret)
 		return ret;
 
+	INIT_LIST_HEAD(&i2c->pad);
+	INIT_LIST_HEAD(&i2c->bus);
+	INIT_LIST_HEAD(&i2c->aux);
+
 	nv_subdev(i2c)->intr = nvkm_i2c_intr;
-	i2c->find = nvkm_i2c_find;
-	i2c->find_type = nvkm_i2c_find_type;
-	i2c->acquire_pad = nvkm_i2c_acquire_pad;
-	i2c->release_pad = nvkm_i2c_release_pad;
-	i2c->acquire = nvkm_i2c_acquire;
-	i2c->release = nvkm_i2c_release;
-	i2c->identify = nvkm_i2c_identify;
-	init_waitqueue_head(&i2c->wait);
-	INIT_LIST_HEAD(&i2c->ports);
-
-	while (!dcb_i2c_parse(bios, ++index, &info)) {
-		switch (info.type) {
-		case DCB_I2C_NV04_BIT:
-		case DCB_I2C_NV4E_BIT:
-		case DCB_I2C_NVIO_BIT:
-			nvkm_i2c_create_port(i2c, NV_I2C_PORT(index),
-					     info.type, &info);
-			break;
-		case DCB_I2C_NVIO_AUX:
-			nvkm_i2c_create_port(i2c, NV_I2C_AUX(index),
-					     info.type, &info);
-			break;
-		case DCB_I2C_PMGR:
-			if (info.drive != DCB_I2C_UNUSED) {
-				nvkm_i2c_create_port(i2c, NV_I2C_PORT(index),
-						     DCB_I2C_NVIO_BIT, &info);
-			}
-			if (info.auxch != DCB_I2C_UNUSED) {
-				nvkm_i2c_create_port(i2c, NV_I2C_AUX(index),
-						     DCB_I2C_NVIO_AUX, &info);
-			}
-			break;
-		case DCB_I2C_UNUSED:
-		default:
+
+	i = -1;
+	while (!dcb_i2c_parse(bios, ++i, &ccbE)) {
+		struct nvkm_i2c_pad *pad = NULL;
+		struct nvkm_i2c_bus *bus = NULL;
+		struct nvkm_i2c_aux *aux = NULL;
+
+		nvkm_debug(&i2c->subdev, "ccb %02x: type %02x drive %02x "
+			   "sense %02x share %02x auxch %02x\n", i, ccbE.type,
+			   ccbE.drive, ccbE.sense, ccbE.share, ccbE.auxch);
+
+		if (ccbE.share != DCB_I2C_UNUSED) {
+			const int id = NVKM_I2C_PAD_HYBRID(ccbE.share);
+			if (!(pad = nvkm_i2c_pad_find(i2c, id)))
+				ret = impl->pad_s_new(i2c, id, &pad);
+			else
+				ret = 0;
+		} else {
+			ret = impl->pad_x_new(i2c, NVKM_I2C_PAD_CCB(i), &pad);
+		}
+
+		if (ret) {
+			nvkm_error(&i2c->subdev, "ccb %02x pad, %d\n", i, ret);
+			nvkm_i2c_pad_del(&pad);
+			continue;
+		}
+
+		if (pad->func->bus_new_0 && ccbE.type == DCB_I2C_NV04_BIT) {
+			ret = pad->func->bus_new_0(pad, NVKM_I2C_BUS_CCB(i),
+						   ccbE.drive,
+						   ccbE.sense, &bus);
+		} else
+		if (pad->func->bus_new_4 &&
+		    ( ccbE.type == DCB_I2C_NV4E_BIT ||
+		      ccbE.type == DCB_I2C_NVIO_BIT ||
+		     (ccbE.type == DCB_I2C_PMGR &&
+		      ccbE.drive != DCB_I2C_UNUSED))) {
+			ret = pad->func->bus_new_4(pad, NVKM_I2C_BUS_CCB(i),
+						   ccbE.drive, &bus);
+		}
+
+		if (ret) {
+			nvkm_error(&i2c->subdev, "ccb %02x bus, %d\n", i, ret);
+			nvkm_i2c_bus_del(&bus);
+		}
+
+		if (pad->func->aux_new_6 &&
+		    ( ccbE.type == DCB_I2C_NVIO_AUX ||
+		     (ccbE.type == DCB_I2C_PMGR &&
+		      ccbE.auxch != DCB_I2C_UNUSED))) {
+			ret = pad->func->aux_new_6(pad, NVKM_I2C_BUS_CCB(i),
+						   ccbE.auxch, &aux);
+		} else {
+			ret = 0;
+		}
+
+		if (ret) {
+			nvkm_error(&i2c->subdev, "ccb %02x aux, %d\n", i, ret);
+			nvkm_i2c_aux_del(&aux);
+		}
+
+		if (ccbE.type != DCB_I2C_UNUSED && !bus && !aux) {
+			nvkm_warn(&i2c->subdev, "ccb %02x was ignored\n", i);
 			continue;
 		}
 	}
 
-	/* in addition to the busses specified in the i2c table, there
-	 * may be ddc/aux channels hiding behind external tmds/dp/etc
-	 * transmitters.
-	 */
-	index = NV_I2C_EXT(0);
 	i = -1;
-	while ((data = dcb_outp_parse(bios, ++i, &ver, &hdr, &outp))) {
-		if (!outp.location || !outp.extdev)
+	while (dcb_outp_parse(bios, ++i, &ver, &hdr, &dcbE)) {
+		const struct nvkm_i2c_drv *drv = nvkm_i2c_drv;
+		struct nvkm_i2c_bus *bus;
+		struct nvkm_i2c_pad *pad;
+
+		/* internal outputs handled by native i2c busses (above) */
+		if (!dcbE.location)
+			continue;
+
+		/* we need an i2c bus to talk to the external encoder */
+		bus = nvkm_i2c_bus_find(i2c, dcbE.i2c_index);
+		if (!bus) {
+			nvkm_debug(&i2c->subdev, "dcb %02x no bus\n", i);
 			continue;
+		}
 
-		switch (outp.type) {
-		case DCB_OUTPUT_TMDS:
-			info.type = NV_I2C_TYPE_EXTDDC(outp.extdev);
-			break;
-		case DCB_OUTPUT_DP:
-			info.type = NV_I2C_TYPE_EXTAUX(outp.extdev);
-			break;
-		default:
+		/* ... and a driver for it */
+		while (drv->pad_new) {
+			if (drv->bios == dcbE.extdev)
+				break;
+			drv++;
+		}
+
+		if (!drv->pad_new) {
+			nvkm_debug(&i2c->subdev, "dcb %02x drv %02x unknown\n",
+				   i, dcbE.extdev);
 			continue;
 		}
 
-		ret = -ENODEV;
-		j = -1;
-		while (ret && ++j < ARRAY_SIZE(nvkm_i2c_extdev_sclass)) {
-			parent = nv_object(i2c->find(i2c, outp.i2c_index));
-			oclass = nvkm_i2c_extdev_sclass[j];
-			do {
-				if (oclass->handle != info.type)
-					continue;
-				ret = nvkm_object_ctor(parent, NULL, oclass,
-						       NULL, index++, &object);
-			} while (ret && (++oclass)->handle);
+		/* find/create an instance of the driver */
+		pad = nvkm_i2c_pad_find(i2c, NVKM_I2C_PAD_EXT(dcbE.extdev));
+		if (!pad) {
+			const int id = NVKM_I2C_PAD_EXT(dcbE.extdev);
+			ret = drv->pad_new(bus, id, drv->addr, &pad);
+			if (ret) {
+				nvkm_error(&i2c->subdev, "dcb %02x pad, %d\n",
+					   i, ret);
+				nvkm_i2c_pad_del(&pad);
+				continue;
+			}
+		}
+
+		/* create any i2c bus / aux channel required by the output */
+		if (pad->func->aux_new_6 && dcbE.type == DCB_OUTPUT_DP) {
+			const int id = NVKM_I2C_AUX_EXT(dcbE.extdev);
+			struct nvkm_i2c_aux *aux = NULL;
+			ret = pad->func->aux_new_6(pad, id, 0, &aux);
+			if (ret) {
+				nvkm_error(&i2c->subdev, "dcb %02x aux, %d\n",
+					   i, ret);
+				nvkm_i2c_aux_del(&aux);
+			}
+		} else
+		if (pad->func->bus_new_4) {
+			const int id = NVKM_I2C_BUS_EXT(dcbE.extdev);
+			struct nvkm_i2c_bus *bus = NULL;
+			ret = pad->func->bus_new_4(pad, id, 0, &bus);
+			if (ret) {
+				nvkm_error(&i2c->subdev, "dcb %02x bus, %d\n",
+					   i, ret);
+				nvkm_i2c_bus_del(&bus);
+			}
 		}
 	}
 
-	ret = nvkm_event_init(&nvkm_i2c_intr_func, 4, index, &i2c->event);
+	ret = nvkm_event_init(&nvkm_i2c_intr_func, 4, i, &i2c->event);
 	if (ret)
 		return ret;
 

commit 7f5f518fd70b1b72ca4cf8249ca3306846383ed4
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:13 2015 +1000

    drm/nouveau/bios: remove object accessor functions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
index 3496dfd93264..6b0f8f0746f5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
@@ -176,7 +176,7 @@ nvkm_i2c_find(struct nvkm_i2c *i2c, u8 index)
 		u8  ver, hdr, cnt, len;
 		u16 i2c = dcb_i2c_table(bios, &ver, &hdr, &cnt, &len);
 		if (i2c && ver >= 0x30) {
-			u8 auxidx = nv_ro08(bios, i2c + 4);
+			u8 auxidx = nvbios_rd08(bios, i2c + 4);
 			if (index == NV_I2C_DEFAULT(0))
 				index = (auxidx & 0x0f) >> 0;
 			else

commit 1cb57d25b6b62b39f07c4ff4370c2c48803000e9
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:12 2015 +1000

    drm/nouveau/i2c: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
index 187af1183f2d..3496dfd93264 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
@@ -282,31 +282,34 @@ nvkm_i2c_identify(struct nvkm_i2c *i2c, int index, const char *what,
 		  bool (*match)(struct nvkm_i2c_port *,
 				struct i2c_board_info *, void *), void *data)
 {
+	struct nvkm_subdev *subdev = &i2c->subdev;
 	struct nvkm_i2c_port *port = nvkm_i2c_find(i2c, index);
 	int i;
 
 	if (!port) {
-		nv_debug(i2c, "no bus when probing %s on %d\n", what, index);
+		nvkm_debug(subdev, "no bus when probing %s on %d\n",
+			   what, index);
 		return -ENODEV;
 	}
 
-	nv_debug(i2c, "probing %ss on bus: %d\n", what, port->index);
+	nvkm_debug(subdev, "probing %ss on bus: %d\n", what, port->index);
 	for (i = 0; info[i].dev.addr; i++) {
 		u8 orig_udelay = 0;
 
 		if ((port->adapter.algo == &i2c_bit_algo) &&
 		    (info[i].udelay != 0)) {
 			struct i2c_algo_bit_data *algo = port->adapter.algo_data;
-			nv_debug(i2c, "using custom udelay %d instead of %d\n",
-			         info[i].udelay, algo->udelay);
+			nvkm_debug(subdev,
+				   "using custom udelay %d instead of %d\n",
+				   info[i].udelay, algo->udelay);
 			orig_udelay = algo->udelay;
 			algo->udelay = info[i].udelay;
 		}
 
 		if (nv_probe_i2c(port, info[i].dev.addr) &&
 		    (!match || match(port, &info[i].dev, data))) {
-			nv_info(i2c, "detected %s: %s\n", what,
-				info[i].dev.type);
+			nvkm_info(subdev, "detected %s: %s\n", what,
+				  info[i].dev.type);
 			return i;
 		}
 
@@ -316,7 +319,7 @@ nvkm_i2c_identify(struct nvkm_i2c *i2c, int index, const char *what,
 		}
 	}
 
-	nv_debug(i2c, "no devices found.\n");
+	nvkm_debug(subdev, "no devices found.\n");
 	return -ENODEV;
 }
 

commit 5b920d926422fdc5b40b703d72344d5e20b3872a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/i2c: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
index 3e2c2882d515..187af1183f2d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
@@ -413,7 +413,7 @@ _nvkm_i2c_fini(struct nvkm_object *object, bool suspend)
 		impl->aux_stat(i2c, &mask, &mask, &mask, &mask);
 	}
 
-	return nvkm_subdev_fini(&i2c->base, suspend);
+	return nvkm_subdev_fini(&i2c->subdev, suspend);
 fail:
 	list_for_each_entry_continue_reverse(port, &i2c->ports, head) {
 		nv_ofuncs(port)->init(nv_object(port));
@@ -429,7 +429,7 @@ _nvkm_i2c_init(struct nvkm_object *object)
 	struct nvkm_i2c_port *port;
 	int ret;
 
-	ret = nvkm_subdev_init(&i2c->base);
+	ret = nvkm_subdev_init(&i2c->subdev);
 	if (ret == 0) {
 		list_for_each_entry(port, &i2c->ports, head) {
 			ret = nv_ofuncs(port)->init(nv_object(port));
@@ -459,7 +459,7 @@ _nvkm_i2c_dtor(struct nvkm_object *object)
 		nvkm_object_ref(NULL, (struct nvkm_object **)&port);
 	}
 
-	nvkm_subdev_destroy(&i2c->base);
+	nvkm_subdev_destroy(&i2c->subdev);
 }
 
 static struct nvkm_oclass *

commit 9ace404b1098221021b01c2ba0eeea0c257fa4a5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/device: include core/device.h automatically for subdevs/engines
    
    Pretty much every subdev/engine is going to need access to nvkm_device
    shortly to touch registers and/or output messages.
    
    The odd placement of the includes is necessary to work around some
    inter-dependencies that currently exist.  This will be fixed later.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
index 9200f122c02c..3e2c2882d515 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
@@ -24,7 +24,6 @@
 #include "priv.h"
 #include "pad.h"
 
-#include <core/device.h>
 #include <core/notify.h>
 #include <core/option.h>
 #include <subdev/bios.h>

commit 78b2b4e76be2100637a92b9721aaa2ce73d0fa22
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:05:26 2015 +1000

    drm/nouveau/instmem: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
index bfb0388f8d5b..9200f122c02c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
@@ -34,7 +34,7 @@
  * interface to linux i2c bit-banging algorithm
  *****************************************************************************/
 
-#ifdef CONFIG_NVKM_I2C_INTERNAL_DEFAULT
+#ifdef CONFIG_NOUVEAU_I2C_INTERNAL_DEFAULT
 #define CSTMSEL true
 #else
 #define CSTMSEL false

commit b9ec14246dc4260294ccfb25ec40b113d23e5b9a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:04:16 2015 +1000

    drm/nouveau/i2c: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
index bd477cd8a919..bfb0388f8d5b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
@@ -21,71 +21,66 @@
  *
  * Authors: Ben Skeggs
  */
+#include "priv.h"
+#include "pad.h"
 
+#include <core/device.h>
 #include <core/notify.h>
 #include <core/option.h>
-#include <core/object.h>
-#include <core/event.h>
-
 #include <subdev/bios.h>
 #include <subdev/bios/dcb.h>
-#include <subdev/bios/i2c.h>
-#include <subdev/vga.h>
-
-#include "priv.h"
-#include "pad.h"
 
 /******************************************************************************
  * interface to linux i2c bit-banging algorithm
  *****************************************************************************/
 
-#ifdef CONFIG_NOUVEAU_I2C_INTERNAL_DEFAULT
+#ifdef CONFIG_NVKM_I2C_INTERNAL_DEFAULT
 #define CSTMSEL true
 #else
 #define CSTMSEL false
 #endif
 
 static int
-nouveau_i2c_pre_xfer(struct i2c_adapter *adap)
+nvkm_i2c_pre_xfer(struct i2c_adapter *adap)
 {
 	struct i2c_algo_bit_data *bit = adap->algo_data;
-	struct nouveau_i2c_port *port = bit->data;
-	return nouveau_i2c(port)->acquire(port, bit->timeout);
+	struct nvkm_i2c_port *port = bit->data;
+	return nvkm_i2c(port)->acquire(port, bit->timeout);
 }
 
 static void
-nouveau_i2c_post_xfer(struct i2c_adapter *adap)
+nvkm_i2c_post_xfer(struct i2c_adapter *adap)
 {
 	struct i2c_algo_bit_data *bit = adap->algo_data;
-	struct nouveau_i2c_port *port = bit->data;
-	return nouveau_i2c(port)->release(port);
+	struct nvkm_i2c_port *port = bit->data;
+	return nvkm_i2c(port)->release(port);
 }
 
 static void
-nouveau_i2c_setscl(void *data, int state)
+nvkm_i2c_setscl(void *data, int state)
 {
-	struct nouveau_i2c_port *port = data;
+	struct nvkm_i2c_port *port = data;
 	port->func->drive_scl(port, state);
 }
 
 static void
-nouveau_i2c_setsda(void *data, int state)
+nvkm_i2c_setsda(void *data, int state)
 {
-	struct nouveau_i2c_port *port = data;
+	struct nvkm_i2c_port *port = data;
 	port->func->drive_sda(port, state);
 }
 
 static int
-nouveau_i2c_getscl(void *data)
+nvkm_i2c_getscl(void *data)
 {
-	struct nouveau_i2c_port *port = data;
+	struct nvkm_i2c_port *port = data;
 	return port->func->sense_scl(port);
 }
 
 static int
-nouveau_i2c_getsda(void *data)
+nvkm_i2c_getsda(void *data)
 {
-	struct nouveau_i2c_port *port = data;
+	struct nvkm_i2c_port *port = data;
 	return port->func->sense_sda(port);
 }
 
@@ -94,42 +89,41 @@ nouveau_i2c_getsda(void *data)
  *****************************************************************************/
 
 int
-_nouveau_i2c_port_fini(struct nouveau_object *object, bool suspend)
+_nvkm_i2c_port_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nouveau_i2c_port *port = (void *)object;
+	struct nvkm_i2c_port *port = (void *)object;
 	struct nvkm_i2c_pad *pad = nvkm_i2c_pad(port);
 	nv_ofuncs(pad)->fini(nv_object(pad), suspend);
-	return nouveau_object_fini(&port->base, suspend);
+	return nvkm_object_fini(&port->base, suspend);
 }
 
 void
-_nouveau_i2c_port_dtor(struct nouveau_object *object)
+_nvkm_i2c_port_dtor(struct nvkm_object *object)
 {
-	struct nouveau_i2c_port *port = (void *)object;
+	struct nvkm_i2c_port *port = (void *)object;
 	i2c_del_adapter(&port->adapter);
-	nouveau_object_destroy(&port->base);
+	nvkm_object_destroy(&port->base);
 }
 
 int
-nouveau_i2c_port_create_(struct nouveau_object *parent,
-			 struct nouveau_object *engine,
-			 struct nouveau_oclass *oclass, u8 index,
-			 const struct i2c_algorithm *algo,
-			 const struct nouveau_i2c_func *func,
-			 int size, void **pobject)
+nvkm_i2c_port_create_(struct nvkm_object *parent, struct nvkm_object *engine,
+		      struct nvkm_oclass *oclass, u8 index,
+		      const struct i2c_algorithm *algo,
+		      const struct nvkm_i2c_func *func,
+		      int size, void **pobject)
 {
-	struct nouveau_device *device = nv_device(parent);
-	struct nouveau_i2c *i2c = nouveau_i2c(parent);
-	struct nouveau_i2c_port *port;
+	struct nvkm_device *device = nv_device(parent);
+	struct nvkm_i2c *i2c = nvkm_i2c(parent);
+	struct nvkm_i2c_port *port;
 	int ret;
 
-	ret = nouveau_object_create_(parent, engine, oclass, 0, size, pobject);
+	ret = nvkm_object_create_(parent, engine, oclass, 0, size, pobject);
 	port = *pobject;
 	if (ret)
 		return ret;
 
 	snprintf(port->adapter.name, sizeof(port->adapter.name),
-		 "nouveau-%s-%d", device->name, index);
+		 "nvkm-%s-%d", device->name, index);
 	port->adapter.owner = THIS_MODULE;
 	port->adapter.dev.parent = nv_device_base(device);
 	port->index = index;
@@ -137,8 +131,8 @@ nouveau_i2c_port_create_(struct nouveau_object *parent,
 	port->func = func;
 	mutex_init(&port->mutex);
 
-	if ( algo == &nouveau_i2c_bit_algo &&
-	    !nouveau_boolopt(device->cfgopt, "NvI2C", CSTMSEL)) {
+	if ( algo == &nvkm_i2c_bit_algo &&
+	    !nvkm_boolopt(device->cfgopt, "NvI2C", CSTMSEL)) {
 		struct i2c_algo_bit_data *bit;
 
 		bit = kzalloc(sizeof(*bit), GFP_KERNEL);
@@ -148,12 +142,12 @@ nouveau_i2c_port_create_(struct nouveau_object *parent,
 		bit->udelay = 10;
 		bit->timeout = usecs_to_jiffies(2200);
 		bit->data = port;
-		bit->pre_xfer = nouveau_i2c_pre_xfer;
-		bit->post_xfer = nouveau_i2c_post_xfer;
-		bit->setsda = nouveau_i2c_setsda;
-		bit->setscl = nouveau_i2c_setscl;
-		bit->getsda = nouveau_i2c_getsda;
-		bit->getscl = nouveau_i2c_getscl;
+		bit->pre_xfer = nvkm_i2c_pre_xfer;
+		bit->post_xfer = nvkm_i2c_post_xfer;
+		bit->setsda = nvkm_i2c_setsda;
+		bit->setscl = nvkm_i2c_setscl;
+		bit->getsda = nvkm_i2c_getsda;
+		bit->getscl = nvkm_i2c_getscl;
 
 		port->adapter.algo_data = bit;
 		ret = i2c_bit_add_bus(&port->adapter);
@@ -172,11 +166,11 @@ nouveau_i2c_port_create_(struct nouveau_object *parent,
  * base i2c subdev class implementation
  *****************************************************************************/
 
-static struct nouveau_i2c_port *
-nouveau_i2c_find(struct nouveau_i2c *i2c, u8 index)
+static struct nvkm_i2c_port *
+nvkm_i2c_find(struct nvkm_i2c *i2c, u8 index)
 {
-	struct nouveau_bios *bios = nouveau_bios(i2c);
-	struct nouveau_i2c_port *port;
+	struct nvkm_bios *bios = nvkm_bios(i2c);
+	struct nvkm_i2c_port *port;
 
 	if (index == NV_I2C_DEFAULT(0) ||
 	    index == NV_I2C_DEFAULT(1)) {
@@ -201,10 +195,10 @@ nouveau_i2c_find(struct nouveau_i2c *i2c, u8 index)
 	return NULL;
 }
 
-static struct nouveau_i2c_port *
-nouveau_i2c_find_type(struct nouveau_i2c *i2c, u16 type)
+static struct nvkm_i2c_port *
+nvkm_i2c_find_type(struct nvkm_i2c *i2c, u16 type)
 {
-	struct nouveau_i2c_port *port;
+	struct nvkm_i2c_port *port;
 
 	list_for_each_entry(port, &i2c->ports, head) {
 		if (nv_hclass(port) == type)
@@ -215,10 +209,10 @@ nouveau_i2c_find_type(struct nouveau_i2c *i2c, u16 type)
 }
 
 static void
-nouveau_i2c_release_pad(struct nouveau_i2c_port *port)
+nvkm_i2c_release_pad(struct nvkm_i2c_port *port)
 {
 	struct nvkm_i2c_pad *pad = nvkm_i2c_pad(port);
-	struct nouveau_i2c *i2c = nouveau_i2c(port);
+	struct nvkm_i2c *i2c = nvkm_i2c(port);
 
 	if (atomic_dec_and_test(&nv_object(pad)->usecount)) {
 		nv_ofuncs(pad)->fini(nv_object(pad), false);
@@ -227,18 +221,18 @@ nouveau_i2c_release_pad(struct nouveau_i2c_port *port)
 }
 
 static int
-nouveau_i2c_try_acquire_pad(struct nouveau_i2c_port *port)
+nvkm_i2c_try_acquire_pad(struct nvkm_i2c_port *port)
 {
 	struct nvkm_i2c_pad *pad = nvkm_i2c_pad(port);
 
 	if (atomic_add_return(1, &nv_object(pad)->usecount) != 1) {
-		struct nouveau_object *owner = (void *)pad->port;
+		struct nvkm_object *owner = (void *)pad->port;
 		do {
 			if (owner == (void *)port)
 				return 0;
 			owner = owner->parent;
 		} while(owner);
-		nouveau_i2c_release_pad(port);
+		nvkm_i2c_release_pad(port);
 		return -EBUSY;
 	}
 
@@ -248,48 +242,48 @@ nouveau_i2c_try_acquire_pad(struct nouveau_i2c_port *port)
 }
 
 static int
-nouveau_i2c_acquire_pad(struct nouveau_i2c_port *port, unsigned long timeout)
+nvkm_i2c_acquire_pad(struct nvkm_i2c_port *port, unsigned long timeout)
 {
-	struct nouveau_i2c *i2c = nouveau_i2c(port);
+	struct nvkm_i2c *i2c = nvkm_i2c(port);
 
 	if (timeout) {
 		if (wait_event_timeout(i2c->wait,
-				       nouveau_i2c_try_acquire_pad(port) == 0,
+				       nvkm_i2c_try_acquire_pad(port) == 0,
 				       timeout) == 0)
 			return -EBUSY;
 	} else {
-		wait_event(i2c->wait, nouveau_i2c_try_acquire_pad(port) == 0);
+		wait_event(i2c->wait, nvkm_i2c_try_acquire_pad(port) == 0);
 	}
 
 	return 0;
 }
 
 static void
-nouveau_i2c_release(struct nouveau_i2c_port *port)
+nvkm_i2c_release(struct nvkm_i2c_port *port)
 __releases(pad->mutex)
 {
-	nouveau_i2c(port)->release_pad(port);
+	nvkm_i2c(port)->release_pad(port);
 	mutex_unlock(&port->mutex);
 }
 
 static int
-nouveau_i2c_acquire(struct nouveau_i2c_port *port, unsigned long timeout)
+nvkm_i2c_acquire(struct nvkm_i2c_port *port, unsigned long timeout)
 __acquires(pad->mutex)
 {
 	int ret;
 	mutex_lock(&port->mutex);
-	if ((ret = nouveau_i2c(port)->acquire_pad(port, timeout)))
+	if ((ret = nvkm_i2c(port)->acquire_pad(port, timeout)))
 		mutex_unlock(&port->mutex);
 	return ret;
 }
 
 static int
-nouveau_i2c_identify(struct nouveau_i2c *i2c, int index, const char *what,
-		     struct nouveau_i2c_board_info *info,
-		     bool (*match)(struct nouveau_i2c_port *,
-				   struct i2c_board_info *, void *), void *data)
+nvkm_i2c_identify(struct nvkm_i2c *i2c, int index, const char *what,
+		  struct nvkm_i2c_board_info *info,
+		  bool (*match)(struct nvkm_i2c_port *,
+				struct i2c_board_info *, void *), void *data)
 {
-	struct nouveau_i2c_port *port = nouveau_i2c_find(i2c, index);
+	struct nvkm_i2c_port *port = nvkm_i2c_find(i2c, index);
 	int i;
 
 	if (!port) {
@@ -328,27 +322,27 @@ nouveau_i2c_identify(struct nouveau_i2c *i2c, int index, const char *what,
 }
 
 static void
-nouveau_i2c_intr_fini(struct nvkm_event *event, int type, int index)
+nvkm_i2c_intr_fini(struct nvkm_event *event, int type, int index)
 {
-	struct nouveau_i2c *i2c = container_of(event, typeof(*i2c), event);
-	struct nouveau_i2c_port *port = i2c->find(i2c, index);
-	const struct nouveau_i2c_impl *impl = (void *)nv_object(i2c)->oclass;
+	struct nvkm_i2c *i2c = container_of(event, typeof(*i2c), event);
+	struct nvkm_i2c_port *port = i2c->find(i2c, index);
+	const struct nvkm_i2c_impl *impl = (void *)nv_object(i2c)->oclass;
 	if (port && port->aux >= 0)
 		impl->aux_mask(i2c, type, 1 << port->aux, 0);
 }
 
 static void
-nouveau_i2c_intr_init(struct nvkm_event *event, int type, int index)
+nvkm_i2c_intr_init(struct nvkm_event *event, int type, int index)
 {
-	struct nouveau_i2c *i2c = container_of(event, typeof(*i2c), event);
-	struct nouveau_i2c_port *port = i2c->find(i2c, index);
-	const struct nouveau_i2c_impl *impl = (void *)nv_object(i2c)->oclass;
+	struct nvkm_i2c *i2c = container_of(event, typeof(*i2c), event);
+	struct nvkm_i2c_port *port = i2c->find(i2c, index);
+	const struct nvkm_i2c_impl *impl = (void *)nv_object(i2c)->oclass;
 	if (port && port->aux >= 0)
 		impl->aux_mask(i2c, type, 1 << port->aux, 1 << port->aux);
 }
 
 static int
-nouveau_i2c_intr_ctor(struct nouveau_object *object, void *data, u32 size,
+nvkm_i2c_intr_ctor(struct nvkm_object *object, void *data, u32 size,
 		      struct nvkm_notify *notify)
 {
 	struct nvkm_i2c_ntfy_req *req = data;
@@ -362,11 +356,11 @@ nouveau_i2c_intr_ctor(struct nouveau_object *object, void *data, u32 size,
 }
 
 static void
-nouveau_i2c_intr(struct nouveau_subdev *subdev)
+nvkm_i2c_intr(struct nvkm_subdev *subdev)
 {
-	struct nouveau_i2c_impl *impl = (void *)nv_oclass(subdev);
-	struct nouveau_i2c *i2c = nouveau_i2c(subdev);
-	struct nouveau_i2c_port *port;
+	struct nvkm_i2c_impl *impl = (void *)nv_oclass(subdev);
+	struct nvkm_i2c *i2c = nvkm_i2c(subdev);
+	struct nvkm_i2c_port *port;
 	u32 hi, lo, rq, tx, e;
 
 	if (impl->aux_stat) {
@@ -394,18 +388,18 @@ nouveau_i2c_intr(struct nouveau_subdev *subdev)
 }
 
 static const struct nvkm_event_func
-nouveau_i2c_intr_func = {
-	.ctor = nouveau_i2c_intr_ctor,
-	.init = nouveau_i2c_intr_init,
-	.fini = nouveau_i2c_intr_fini,
+nvkm_i2c_intr_func = {
+	.ctor = nvkm_i2c_intr_ctor,
+	.init = nvkm_i2c_intr_init,
+	.fini = nvkm_i2c_intr_fini,
 };
 
 int
-_nouveau_i2c_fini(struct nouveau_object *object, bool suspend)
+_nvkm_i2c_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nouveau_i2c_impl *impl = (void *)nv_oclass(object);
-	struct nouveau_i2c *i2c = (void *)object;
-	struct nouveau_i2c_port *port;
+	struct nvkm_i2c_impl *impl = (void *)nv_oclass(object);
+	struct nvkm_i2c *i2c = (void *)object;
+	struct nvkm_i2c_port *port;
 	u32 mask;
 	int ret;
 
@@ -420,7 +414,7 @@ _nouveau_i2c_fini(struct nouveau_object *object, bool suspend)
 		impl->aux_stat(i2c, &mask, &mask, &mask, &mask);
 	}
 
-	return nouveau_subdev_fini(&i2c->base, suspend);
+	return nvkm_subdev_fini(&i2c->base, suspend);
 fail:
 	list_for_each_entry_continue_reverse(port, &i2c->ports, head) {
 		nv_ofuncs(port)->init(nv_object(port));
@@ -430,13 +424,13 @@ _nouveau_i2c_fini(struct nouveau_object *object, bool suspend)
 }
 
 int
-_nouveau_i2c_init(struct nouveau_object *object)
+_nvkm_i2c_init(struct nvkm_object *object)
 {
-	struct nouveau_i2c *i2c = (void *)object;
-	struct nouveau_i2c_port *port;
+	struct nvkm_i2c *i2c = (void *)object;
+	struct nvkm_i2c_port *port;
 	int ret;
 
-	ret = nouveau_subdev_init(&i2c->base);
+	ret = nvkm_subdev_init(&i2c->base);
 	if (ret == 0) {
 		list_for_each_entry(port, &i2c->ports, head) {
 			ret = nv_ofuncs(port)->init(nv_object(port));
@@ -455,33 +449,33 @@ _nouveau_i2c_init(struct nouveau_object *object)
 }
 
 void
-_nouveau_i2c_dtor(struct nouveau_object *object)
+_nvkm_i2c_dtor(struct nvkm_object *object)
 {
-	struct nouveau_i2c *i2c = (void *)object;
-	struct nouveau_i2c_port *port, *temp;
+	struct nvkm_i2c *i2c = (void *)object;
+	struct nvkm_i2c_port *port, *temp;
 
 	nvkm_event_fini(&i2c->event);
 
 	list_for_each_entry_safe(port, temp, &i2c->ports, head) {
-		nouveau_object_ref(NULL, (struct nouveau_object **)&port);
+		nvkm_object_ref(NULL, (struct nvkm_object **)&port);
 	}
 
-	nouveau_subdev_destroy(&i2c->base);
+	nvkm_subdev_destroy(&i2c->base);
 }
 
-static struct nouveau_oclass *
-nouveau_i2c_extdev_sclass[] = {
-	nouveau_anx9805_sclass,
+static struct nvkm_oclass *
+nvkm_i2c_extdev_sclass[] = {
+	nvkm_anx9805_sclass,
 };
 
 static void
-nouveau_i2c_create_port(struct nouveau_i2c *i2c, int index, u8 type,
-			struct dcb_i2c_entry *info)
+nvkm_i2c_create_port(struct nvkm_i2c *i2c, int index, u8 type,
+		     struct dcb_i2c_entry *info)
 {
-	const struct nouveau_i2c_impl *impl = (void *)nv_oclass(i2c);
-	struct nouveau_oclass *oclass;
-	struct nouveau_object *parent;
-	struct nouveau_object *object;
+	const struct nvkm_i2c_impl *impl = (void *)nv_oclass(i2c);
+	struct nvkm_oclass *oclass;
+	struct nvkm_object *parent;
+	struct nvkm_object *object;
 	int ret, pad;
 
 	if (info->share != DCB_I2C_UNUSED) {
@@ -495,8 +489,8 @@ nouveau_i2c_create_port(struct nouveau_i2c *i2c, int index, u8 type,
 		oclass = impl->pad_x;
 	}
 
-	ret = nouveau_object_ctor(nv_object(i2c), NULL, oclass,
-				  NULL, pad, &parent);
+	ret = nvkm_object_ctor(nv_object(i2c), NULL, oclass,
+			       NULL, pad, &parent);
 	if (ret < 0)
 		return;
 
@@ -504,44 +498,40 @@ nouveau_i2c_create_port(struct nouveau_i2c *i2c, int index, u8 type,
 	do {
 		ret = -EINVAL;
 		if (oclass->handle == type) {
-			ret = nouveau_object_ctor(parent, NULL,
-						  oclass, info, index,
-						 &object);
+			ret = nvkm_object_ctor(parent, NULL, oclass,
+					       info, index, &object);
 		}
 	} while (ret && (++oclass)->handle);
 
-	nouveau_object_ref(NULL, &parent);
+	nvkm_object_ref(NULL, &parent);
 }
 
 int
-nouveau_i2c_create_(struct nouveau_object *parent,
-		    struct nouveau_object *engine,
-		    struct nouveau_oclass *oclass,
-		    int length, void **pobject)
+nvkm_i2c_create_(struct nvkm_object *parent, struct nvkm_object *engine,
+		 struct nvkm_oclass *oclass, int length, void **pobject)
 {
-	struct nouveau_bios *bios = nouveau_bios(parent);
-	struct nouveau_i2c *i2c;
-	struct nouveau_object *object;
+	struct nvkm_bios *bios = nvkm_bios(parent);
+	struct nvkm_i2c *i2c;
+	struct nvkm_object *object;
 	struct dcb_i2c_entry info;
 	int ret, i, j, index = -1;
 	struct dcb_output outp;
 	u8  ver, hdr;
 	u32 data;
 
-	ret = nouveau_subdev_create(parent, engine, oclass, 0,
-				    "I2C", "i2c", &i2c);
+	ret = nvkm_subdev_create(parent, engine, oclass, 0, "I2C", "i2c", &i2c);
 	*pobject = nv_object(i2c);
 	if (ret)
 		return ret;
 
-	nv_subdev(i2c)->intr = nouveau_i2c_intr;
-	i2c->find = nouveau_i2c_find;
-	i2c->find_type = nouveau_i2c_find_type;
-	i2c->acquire_pad = nouveau_i2c_acquire_pad;
-	i2c->release_pad = nouveau_i2c_release_pad;
-	i2c->acquire = nouveau_i2c_acquire;
-	i2c->release = nouveau_i2c_release;
-	i2c->identify = nouveau_i2c_identify;
+	nv_subdev(i2c)->intr = nvkm_i2c_intr;
+	i2c->find = nvkm_i2c_find;
+	i2c->find_type = nvkm_i2c_find_type;
+	i2c->acquire_pad = nvkm_i2c_acquire_pad;
+	i2c->release_pad = nvkm_i2c_release_pad;
+	i2c->acquire = nvkm_i2c_acquire;
+	i2c->release = nvkm_i2c_release;
+	i2c->identify = nvkm_i2c_identify;
 	init_waitqueue_head(&i2c->wait);
 	INIT_LIST_HEAD(&i2c->ports);
 
@@ -550,23 +540,21 @@ nouveau_i2c_create_(struct nouveau_object *parent,
 		case DCB_I2C_NV04_BIT:
 		case DCB_I2C_NV4E_BIT:
 		case DCB_I2C_NVIO_BIT:
-			nouveau_i2c_create_port(i2c, NV_I2C_PORT(index),
-						info.type, &info);
+			nvkm_i2c_create_port(i2c, NV_I2C_PORT(index),
+					     info.type, &info);
 			break;
 		case DCB_I2C_NVIO_AUX:
-			nouveau_i2c_create_port(i2c, NV_I2C_AUX(index),
-						info.type, &info);
+			nvkm_i2c_create_port(i2c, NV_I2C_AUX(index),
+					     info.type, &info);
 			break;
 		case DCB_I2C_PMGR:
 			if (info.drive != DCB_I2C_UNUSED) {
-				nouveau_i2c_create_port(i2c, NV_I2C_PORT(index),
-							DCB_I2C_NVIO_BIT,
-							&info);
+				nvkm_i2c_create_port(i2c, NV_I2C_PORT(index),
+						     DCB_I2C_NVIO_BIT, &info);
 			}
 			if (info.auxch != DCB_I2C_UNUSED) {
-				nouveau_i2c_create_port(i2c, NV_I2C_AUX(index),
-							DCB_I2C_NVIO_AUX,
-							&info);
+				nvkm_i2c_create_port(i2c, NV_I2C_AUX(index),
+						     DCB_I2C_NVIO_AUX, &info);
 			}
 			break;
 		case DCB_I2C_UNUSED:
@@ -598,20 +586,19 @@ nouveau_i2c_create_(struct nouveau_object *parent,
 
 		ret = -ENODEV;
 		j = -1;
-		while (ret && ++j < ARRAY_SIZE(nouveau_i2c_extdev_sclass)) {
+		while (ret && ++j < ARRAY_SIZE(nvkm_i2c_extdev_sclass)) {
 			parent = nv_object(i2c->find(i2c, outp.i2c_index));
-			oclass = nouveau_i2c_extdev_sclass[j];
+			oclass = nvkm_i2c_extdev_sclass[j];
 			do {
 				if (oclass->handle != info.type)
 					continue;
-				ret = nouveau_object_ctor(parent, NULL,
-							  oclass, NULL,
-							  index++, &object);
+				ret = nvkm_object_ctor(parent, NULL, oclass,
+						       NULL, index++, &object);
 			} while (ret && (++oclass)->handle);
 		}
 	}
 
-	ret = nvkm_event_init(&nouveau_i2c_intr_func, 4, index, &i2c->event);
+	ret = nvkm_event_init(&nvkm_i2c_intr_func, 4, index, &i2c->event);
 	if (ret)
 		return ret;
 
@@ -619,14 +606,14 @@ nouveau_i2c_create_(struct nouveau_object *parent,
 }
 
 int
-_nouveau_i2c_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
-		  struct nouveau_oclass *oclass, void *data, u32 size,
-		  struct nouveau_object **pobject)
+_nvkm_i2c_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+	       struct nvkm_oclass *oclass, void *data, u32 size,
+	       struct nvkm_object **pobject)
 {
-	struct nouveau_i2c *i2c;
+	struct nvkm_i2c *i2c;
 	int ret;
 
-	ret = nouveau_i2c_create(parent, engine, oclass, &i2c);
+	ret = nvkm_i2c_create(parent, engine, oclass, &i2c);
 	*pobject = nv_object(i2c);
 	if (ret)
 		return ret;

commit 5025407b9862349d17b1dff25737aaef6520a439
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 14:11:21 2015 +1000

    drm/nouveau/core: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
index d1f06e9aaca2..bd477cd8a919 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
@@ -22,6 +22,7 @@
  * Authors: Ben Skeggs
  */
 
+#include <core/notify.h>
 #include <core/option.h>
 #include <core/object.h>
 #include <core/event.h>

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
new file mode 100644
index 000000000000..d1f06e9aaca2
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c
@@ -0,0 +1,634 @@
+/*
+ * Copyright 2013 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <core/option.h>
+#include <core/object.h>
+#include <core/event.h>
+
+#include <subdev/bios.h>
+#include <subdev/bios/dcb.h>
+#include <subdev/bios/i2c.h>
+#include <subdev/vga.h>
+
+#include "priv.h"
+#include "pad.h"
+
+/******************************************************************************
+ * interface to linux i2c bit-banging algorithm
+ *****************************************************************************/
+
+#ifdef CONFIG_NOUVEAU_I2C_INTERNAL_DEFAULT
+#define CSTMSEL true
+#else
+#define CSTMSEL false
+#endif
+
+static int
+nouveau_i2c_pre_xfer(struct i2c_adapter *adap)
+{
+	struct i2c_algo_bit_data *bit = adap->algo_data;
+	struct nouveau_i2c_port *port = bit->data;
+	return nouveau_i2c(port)->acquire(port, bit->timeout);
+}
+
+static void
+nouveau_i2c_post_xfer(struct i2c_adapter *adap)
+{
+	struct i2c_algo_bit_data *bit = adap->algo_data;
+	struct nouveau_i2c_port *port = bit->data;
+	return nouveau_i2c(port)->release(port);
+}
+
+static void
+nouveau_i2c_setscl(void *data, int state)
+{
+	struct nouveau_i2c_port *port = data;
+	port->func->drive_scl(port, state);
+}
+
+static void
+nouveau_i2c_setsda(void *data, int state)
+{
+	struct nouveau_i2c_port *port = data;
+	port->func->drive_sda(port, state);
+}
+
+static int
+nouveau_i2c_getscl(void *data)
+{
+	struct nouveau_i2c_port *port = data;
+	return port->func->sense_scl(port);
+}
+
+static int
+nouveau_i2c_getsda(void *data)
+{
+	struct nouveau_i2c_port *port = data;
+	return port->func->sense_sda(port);
+}
+
+/******************************************************************************
+ * base i2c "port" class implementation
+ *****************************************************************************/
+
+int
+_nouveau_i2c_port_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nouveau_i2c_port *port = (void *)object;
+	struct nvkm_i2c_pad *pad = nvkm_i2c_pad(port);
+	nv_ofuncs(pad)->fini(nv_object(pad), suspend);
+	return nouveau_object_fini(&port->base, suspend);
+}
+
+void
+_nouveau_i2c_port_dtor(struct nouveau_object *object)
+{
+	struct nouveau_i2c_port *port = (void *)object;
+	i2c_del_adapter(&port->adapter);
+	nouveau_object_destroy(&port->base);
+}
+
+int
+nouveau_i2c_port_create_(struct nouveau_object *parent,
+			 struct nouveau_object *engine,
+			 struct nouveau_oclass *oclass, u8 index,
+			 const struct i2c_algorithm *algo,
+			 const struct nouveau_i2c_func *func,
+			 int size, void **pobject)
+{
+	struct nouveau_device *device = nv_device(parent);
+	struct nouveau_i2c *i2c = nouveau_i2c(parent);
+	struct nouveau_i2c_port *port;
+	int ret;
+
+	ret = nouveau_object_create_(parent, engine, oclass, 0, size, pobject);
+	port = *pobject;
+	if (ret)
+		return ret;
+
+	snprintf(port->adapter.name, sizeof(port->adapter.name),
+		 "nouveau-%s-%d", device->name, index);
+	port->adapter.owner = THIS_MODULE;
+	port->adapter.dev.parent = nv_device_base(device);
+	port->index = index;
+	port->aux = -1;
+	port->func = func;
+	mutex_init(&port->mutex);
+
+	if ( algo == &nouveau_i2c_bit_algo &&
+	    !nouveau_boolopt(device->cfgopt, "NvI2C", CSTMSEL)) {
+		struct i2c_algo_bit_data *bit;
+
+		bit = kzalloc(sizeof(*bit), GFP_KERNEL);
+		if (!bit)
+			return -ENOMEM;
+
+		bit->udelay = 10;
+		bit->timeout = usecs_to_jiffies(2200);
+		bit->data = port;
+		bit->pre_xfer = nouveau_i2c_pre_xfer;
+		bit->post_xfer = nouveau_i2c_post_xfer;
+		bit->setsda = nouveau_i2c_setsda;
+		bit->setscl = nouveau_i2c_setscl;
+		bit->getsda = nouveau_i2c_getsda;
+		bit->getscl = nouveau_i2c_getscl;
+
+		port->adapter.algo_data = bit;
+		ret = i2c_bit_add_bus(&port->adapter);
+	} else {
+		port->adapter.algo_data = port;
+		port->adapter.algo = algo;
+		ret = i2c_add_adapter(&port->adapter);
+	}
+
+	if (ret == 0)
+		list_add_tail(&port->head, &i2c->ports);
+	return ret;
+}
+
+/******************************************************************************
+ * base i2c subdev class implementation
+ *****************************************************************************/
+
+static struct nouveau_i2c_port *
+nouveau_i2c_find(struct nouveau_i2c *i2c, u8 index)
+{
+	struct nouveau_bios *bios = nouveau_bios(i2c);
+	struct nouveau_i2c_port *port;
+
+	if (index == NV_I2C_DEFAULT(0) ||
+	    index == NV_I2C_DEFAULT(1)) {
+		u8  ver, hdr, cnt, len;
+		u16 i2c = dcb_i2c_table(bios, &ver, &hdr, &cnt, &len);
+		if (i2c && ver >= 0x30) {
+			u8 auxidx = nv_ro08(bios, i2c + 4);
+			if (index == NV_I2C_DEFAULT(0))
+				index = (auxidx & 0x0f) >> 0;
+			else
+				index = (auxidx & 0xf0) >> 4;
+		} else {
+			index = 2;
+		}
+	}
+
+	list_for_each_entry(port, &i2c->ports, head) {
+		if (port->index == index)
+			return port;
+	}
+
+	return NULL;
+}
+
+static struct nouveau_i2c_port *
+nouveau_i2c_find_type(struct nouveau_i2c *i2c, u16 type)
+{
+	struct nouveau_i2c_port *port;
+
+	list_for_each_entry(port, &i2c->ports, head) {
+		if (nv_hclass(port) == type)
+			return port;
+	}
+
+	return NULL;
+}
+
+static void
+nouveau_i2c_release_pad(struct nouveau_i2c_port *port)
+{
+	struct nvkm_i2c_pad *pad = nvkm_i2c_pad(port);
+	struct nouveau_i2c *i2c = nouveau_i2c(port);
+
+	if (atomic_dec_and_test(&nv_object(pad)->usecount)) {
+		nv_ofuncs(pad)->fini(nv_object(pad), false);
+		wake_up_all(&i2c->wait);
+	}
+}
+
+static int
+nouveau_i2c_try_acquire_pad(struct nouveau_i2c_port *port)
+{
+	struct nvkm_i2c_pad *pad = nvkm_i2c_pad(port);
+
+	if (atomic_add_return(1, &nv_object(pad)->usecount) != 1) {
+		struct nouveau_object *owner = (void *)pad->port;
+		do {
+			if (owner == (void *)port)
+				return 0;
+			owner = owner->parent;
+		} while(owner);
+		nouveau_i2c_release_pad(port);
+		return -EBUSY;
+	}
+
+	pad->next = port;
+	nv_ofuncs(pad)->init(nv_object(pad));
+	return 0;
+}
+
+static int
+nouveau_i2c_acquire_pad(struct nouveau_i2c_port *port, unsigned long timeout)
+{
+	struct nouveau_i2c *i2c = nouveau_i2c(port);
+
+	if (timeout) {
+		if (wait_event_timeout(i2c->wait,
+				       nouveau_i2c_try_acquire_pad(port) == 0,
+				       timeout) == 0)
+			return -EBUSY;
+	} else {
+		wait_event(i2c->wait, nouveau_i2c_try_acquire_pad(port) == 0);
+	}
+
+	return 0;
+}
+
+static void
+nouveau_i2c_release(struct nouveau_i2c_port *port)
+__releases(pad->mutex)
+{
+	nouveau_i2c(port)->release_pad(port);
+	mutex_unlock(&port->mutex);
+}
+
+static int
+nouveau_i2c_acquire(struct nouveau_i2c_port *port, unsigned long timeout)
+__acquires(pad->mutex)
+{
+	int ret;
+	mutex_lock(&port->mutex);
+	if ((ret = nouveau_i2c(port)->acquire_pad(port, timeout)))
+		mutex_unlock(&port->mutex);
+	return ret;
+}
+
+static int
+nouveau_i2c_identify(struct nouveau_i2c *i2c, int index, const char *what,
+		     struct nouveau_i2c_board_info *info,
+		     bool (*match)(struct nouveau_i2c_port *,
+				   struct i2c_board_info *, void *), void *data)
+{
+	struct nouveau_i2c_port *port = nouveau_i2c_find(i2c, index);
+	int i;
+
+	if (!port) {
+		nv_debug(i2c, "no bus when probing %s on %d\n", what, index);
+		return -ENODEV;
+	}
+
+	nv_debug(i2c, "probing %ss on bus: %d\n", what, port->index);
+	for (i = 0; info[i].dev.addr; i++) {
+		u8 orig_udelay = 0;
+
+		if ((port->adapter.algo == &i2c_bit_algo) &&
+		    (info[i].udelay != 0)) {
+			struct i2c_algo_bit_data *algo = port->adapter.algo_data;
+			nv_debug(i2c, "using custom udelay %d instead of %d\n",
+			         info[i].udelay, algo->udelay);
+			orig_udelay = algo->udelay;
+			algo->udelay = info[i].udelay;
+		}
+
+		if (nv_probe_i2c(port, info[i].dev.addr) &&
+		    (!match || match(port, &info[i].dev, data))) {
+			nv_info(i2c, "detected %s: %s\n", what,
+				info[i].dev.type);
+			return i;
+		}
+
+		if (orig_udelay) {
+			struct i2c_algo_bit_data *algo = port->adapter.algo_data;
+			algo->udelay = orig_udelay;
+		}
+	}
+
+	nv_debug(i2c, "no devices found.\n");
+	return -ENODEV;
+}
+
+static void
+nouveau_i2c_intr_fini(struct nvkm_event *event, int type, int index)
+{
+	struct nouveau_i2c *i2c = container_of(event, typeof(*i2c), event);
+	struct nouveau_i2c_port *port = i2c->find(i2c, index);
+	const struct nouveau_i2c_impl *impl = (void *)nv_object(i2c)->oclass;
+	if (port && port->aux >= 0)
+		impl->aux_mask(i2c, type, 1 << port->aux, 0);
+}
+
+static void
+nouveau_i2c_intr_init(struct nvkm_event *event, int type, int index)
+{
+	struct nouveau_i2c *i2c = container_of(event, typeof(*i2c), event);
+	struct nouveau_i2c_port *port = i2c->find(i2c, index);
+	const struct nouveau_i2c_impl *impl = (void *)nv_object(i2c)->oclass;
+	if (port && port->aux >= 0)
+		impl->aux_mask(i2c, type, 1 << port->aux, 1 << port->aux);
+}
+
+static int
+nouveau_i2c_intr_ctor(struct nouveau_object *object, void *data, u32 size,
+		      struct nvkm_notify *notify)
+{
+	struct nvkm_i2c_ntfy_req *req = data;
+	if (!WARN_ON(size != sizeof(*req))) {
+		notify->size  = sizeof(struct nvkm_i2c_ntfy_rep);
+		notify->types = req->mask;
+		notify->index = req->port;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static void
+nouveau_i2c_intr(struct nouveau_subdev *subdev)
+{
+	struct nouveau_i2c_impl *impl = (void *)nv_oclass(subdev);
+	struct nouveau_i2c *i2c = nouveau_i2c(subdev);
+	struct nouveau_i2c_port *port;
+	u32 hi, lo, rq, tx, e;
+
+	if (impl->aux_stat) {
+		impl->aux_stat(i2c, &hi, &lo, &rq, &tx);
+		if (hi || lo || rq || tx) {
+			list_for_each_entry(port, &i2c->ports, head) {
+				if (e = 0, port->aux < 0)
+					continue;
+
+				if (hi & (1 << port->aux)) e |= NVKM_I2C_PLUG;
+				if (lo & (1 << port->aux)) e |= NVKM_I2C_UNPLUG;
+				if (rq & (1 << port->aux)) e |= NVKM_I2C_IRQ;
+				if (tx & (1 << port->aux)) e |= NVKM_I2C_DONE;
+				if (e) {
+					struct nvkm_i2c_ntfy_rep rep = {
+						.mask = e,
+					};
+					nvkm_event_send(&i2c->event, rep.mask,
+							port->index, &rep,
+							sizeof(rep));
+				}
+			}
+		}
+	}
+}
+
+static const struct nvkm_event_func
+nouveau_i2c_intr_func = {
+	.ctor = nouveau_i2c_intr_ctor,
+	.init = nouveau_i2c_intr_init,
+	.fini = nouveau_i2c_intr_fini,
+};
+
+int
+_nouveau_i2c_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nouveau_i2c_impl *impl = (void *)nv_oclass(object);
+	struct nouveau_i2c *i2c = (void *)object;
+	struct nouveau_i2c_port *port;
+	u32 mask;
+	int ret;
+
+	list_for_each_entry(port, &i2c->ports, head) {
+		ret = nv_ofuncs(port)->fini(nv_object(port), suspend);
+		if (ret && suspend)
+			goto fail;
+	}
+
+	if ((mask = (1 << impl->aux) - 1), impl->aux_stat) {
+		impl->aux_mask(i2c, NVKM_I2C_ANY, mask, 0);
+		impl->aux_stat(i2c, &mask, &mask, &mask, &mask);
+	}
+
+	return nouveau_subdev_fini(&i2c->base, suspend);
+fail:
+	list_for_each_entry_continue_reverse(port, &i2c->ports, head) {
+		nv_ofuncs(port)->init(nv_object(port));
+	}
+
+	return ret;
+}
+
+int
+_nouveau_i2c_init(struct nouveau_object *object)
+{
+	struct nouveau_i2c *i2c = (void *)object;
+	struct nouveau_i2c_port *port;
+	int ret;
+
+	ret = nouveau_subdev_init(&i2c->base);
+	if (ret == 0) {
+		list_for_each_entry(port, &i2c->ports, head) {
+			ret = nv_ofuncs(port)->init(nv_object(port));
+			if (ret)
+				goto fail;
+		}
+	}
+
+	return ret;
+fail:
+	list_for_each_entry_continue_reverse(port, &i2c->ports, head) {
+		nv_ofuncs(port)->fini(nv_object(port), false);
+	}
+
+	return ret;
+}
+
+void
+_nouveau_i2c_dtor(struct nouveau_object *object)
+{
+	struct nouveau_i2c *i2c = (void *)object;
+	struct nouveau_i2c_port *port, *temp;
+
+	nvkm_event_fini(&i2c->event);
+
+	list_for_each_entry_safe(port, temp, &i2c->ports, head) {
+		nouveau_object_ref(NULL, (struct nouveau_object **)&port);
+	}
+
+	nouveau_subdev_destroy(&i2c->base);
+}
+
+static struct nouveau_oclass *
+nouveau_i2c_extdev_sclass[] = {
+	nouveau_anx9805_sclass,
+};
+
+static void
+nouveau_i2c_create_port(struct nouveau_i2c *i2c, int index, u8 type,
+			struct dcb_i2c_entry *info)
+{
+	const struct nouveau_i2c_impl *impl = (void *)nv_oclass(i2c);
+	struct nouveau_oclass *oclass;
+	struct nouveau_object *parent;
+	struct nouveau_object *object;
+	int ret, pad;
+
+	if (info->share != DCB_I2C_UNUSED) {
+		pad    = info->share;
+		oclass = impl->pad_s;
+	} else {
+		if (type != DCB_I2C_NVIO_AUX)
+			pad = 0x100 + info->drive;
+		else
+			pad = 0x100 + info->auxch;
+		oclass = impl->pad_x;
+	}
+
+	ret = nouveau_object_ctor(nv_object(i2c), NULL, oclass,
+				  NULL, pad, &parent);
+	if (ret < 0)
+		return;
+
+	oclass = impl->sclass;
+	do {
+		ret = -EINVAL;
+		if (oclass->handle == type) {
+			ret = nouveau_object_ctor(parent, NULL,
+						  oclass, info, index,
+						 &object);
+		}
+	} while (ret && (++oclass)->handle);
+
+	nouveau_object_ref(NULL, &parent);
+}
+
+int
+nouveau_i2c_create_(struct nouveau_object *parent,
+		    struct nouveau_object *engine,
+		    struct nouveau_oclass *oclass,
+		    int length, void **pobject)
+{
+	struct nouveau_bios *bios = nouveau_bios(parent);
+	struct nouveau_i2c *i2c;
+	struct nouveau_object *object;
+	struct dcb_i2c_entry info;
+	int ret, i, j, index = -1;
+	struct dcb_output outp;
+	u8  ver, hdr;
+	u32 data;
+
+	ret = nouveau_subdev_create(parent, engine, oclass, 0,
+				    "I2C", "i2c", &i2c);
+	*pobject = nv_object(i2c);
+	if (ret)
+		return ret;
+
+	nv_subdev(i2c)->intr = nouveau_i2c_intr;
+	i2c->find = nouveau_i2c_find;
+	i2c->find_type = nouveau_i2c_find_type;
+	i2c->acquire_pad = nouveau_i2c_acquire_pad;
+	i2c->release_pad = nouveau_i2c_release_pad;
+	i2c->acquire = nouveau_i2c_acquire;
+	i2c->release = nouveau_i2c_release;
+	i2c->identify = nouveau_i2c_identify;
+	init_waitqueue_head(&i2c->wait);
+	INIT_LIST_HEAD(&i2c->ports);
+
+	while (!dcb_i2c_parse(bios, ++index, &info)) {
+		switch (info.type) {
+		case DCB_I2C_NV04_BIT:
+		case DCB_I2C_NV4E_BIT:
+		case DCB_I2C_NVIO_BIT:
+			nouveau_i2c_create_port(i2c, NV_I2C_PORT(index),
+						info.type, &info);
+			break;
+		case DCB_I2C_NVIO_AUX:
+			nouveau_i2c_create_port(i2c, NV_I2C_AUX(index),
+						info.type, &info);
+			break;
+		case DCB_I2C_PMGR:
+			if (info.drive != DCB_I2C_UNUSED) {
+				nouveau_i2c_create_port(i2c, NV_I2C_PORT(index),
+							DCB_I2C_NVIO_BIT,
+							&info);
+			}
+			if (info.auxch != DCB_I2C_UNUSED) {
+				nouveau_i2c_create_port(i2c, NV_I2C_AUX(index),
+							DCB_I2C_NVIO_AUX,
+							&info);
+			}
+			break;
+		case DCB_I2C_UNUSED:
+		default:
+			continue;
+		}
+	}
+
+	/* in addition to the busses specified in the i2c table, there
+	 * may be ddc/aux channels hiding behind external tmds/dp/etc
+	 * transmitters.
+	 */
+	index = NV_I2C_EXT(0);
+	i = -1;
+	while ((data = dcb_outp_parse(bios, ++i, &ver, &hdr, &outp))) {
+		if (!outp.location || !outp.extdev)
+			continue;
+
+		switch (outp.type) {
+		case DCB_OUTPUT_TMDS:
+			info.type = NV_I2C_TYPE_EXTDDC(outp.extdev);
+			break;
+		case DCB_OUTPUT_DP:
+			info.type = NV_I2C_TYPE_EXTAUX(outp.extdev);
+			break;
+		default:
+			continue;
+		}
+
+		ret = -ENODEV;
+		j = -1;
+		while (ret && ++j < ARRAY_SIZE(nouveau_i2c_extdev_sclass)) {
+			parent = nv_object(i2c->find(i2c, outp.i2c_index));
+			oclass = nouveau_i2c_extdev_sclass[j];
+			do {
+				if (oclass->handle != info.type)
+					continue;
+				ret = nouveau_object_ctor(parent, NULL,
+							  oclass, NULL,
+							  index++, &object);
+			} while (ret && (++oclass)->handle);
+		}
+	}
+
+	ret = nvkm_event_init(&nouveau_i2c_intr_func, 4, index, &i2c->event);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+int
+_nouveau_i2c_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+		  struct nouveau_oclass *oclass, void *data, u32 size,
+		  struct nouveau_object **pobject)
+{
+	struct nouveau_i2c *i2c;
+	int ret;
+
+	ret = nouveau_i2c_create(parent, engine, oclass, &i2c);
+	*pobject = nv_object(i2c);
+	if (ret)
+		return ret;
+
+	return 0;
+}
