commit 69cbbb7b04ff57c17018b27a86e9c2d758d4366e
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jul 2 14:19:12 2019 +1000

    drm/nouveau/therm: don't attempt fan control where PMU is already managing it
    
    There's already a condition in place which attempts to detect this, but
    since we've begun to require a PMU subdev even on boards where we don't
    load a custom FW, it's become inaccurate.
    
    This will prevent unnecessarily running a periodic fan update thread on
    GP100 and newer, where we don't yet override the default PMU FW.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index 07914e36939e..4a4d1e224126 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -21,9 +21,11 @@
  *
  * Authors: Martin Peres
  */
-#include <nvkm/core/option.h>
 #include "priv.h"
 
+#include <core/option.h>
+#include <subdev/pmu.h>
+
 int
 nvkm_therm_temp_get(struct nvkm_therm *therm)
 {
@@ -192,8 +194,7 @@ nvkm_therm_fan_mode(struct nvkm_therm *therm, int mode)
 
 	/* The default PPWR ucode on fermi interferes with fan management */
 	if ((mode >= ARRAY_SIZE(name)) ||
-	    (mode != NVKM_THERM_CTRL_NONE && device->card_type >= NV_C0 &&
-	     !device->pmu))
+	    (mode != NVKM_THERM_CTRL_NONE && nvkm_pmu_fan_controlled(device)))
 		return -EINVAL;
 
 	/* do not allow automatic fan management if the thermal sensor is

commit 118780066e30c34de3d9349710b51780bfa0ba83
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Sep 12 12:58:43 2018 +0200

    drm/nouveau: Don't disable polling in fallback mode
    
    When a fan is controlled via linear fallback without cstate, we
    shouldn't stop polling.  Otherwise it won't be adjusted again and
    keeps running at an initial crazy pace.
    
    Fixes: 800efb4c2857 ("drm/nouveau/drm/therm/fan: add a fallback if no fan control is specified in the vbios")
    Bugzilla: https://bugzilla.suse.com/show_bug.cgi?id=1103356
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=107447
    Reported-by: Thomas Blume <thomas.blume@suse.com>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index 3695cde669f8..07914e36939e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -132,11 +132,12 @@ nvkm_therm_update(struct nvkm_therm *therm, int mode)
 			duty = nvkm_therm_update_linear(therm);
 			break;
 		case NVBIOS_THERM_FAN_OTHER:
-			if (therm->cstate)
+			if (therm->cstate) {
 				duty = therm->cstate;
-			else
+				poll = false;
+			} else {
 				duty = nvkm_therm_update_linear_fallback(therm);
-			poll = false;
+			}
 			break;
 		}
 		immd = false;

commit 92256269893e96e5f9e8ac6dd882a0bef63fcea7
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Feb 7 18:40:27 2018 +0100

    drm/nouveau: Make clock gate support conditional
    
    The recently introduced clock gate support breaks on Tegra chips because
    no thermal support is enabled for those devices. Conditionalize the code
    on the existence of thermal support to fix this.
    
    Fixes: b138eca661cc ("drm/nouveau: Add support for basic clockgating on Kepler1")
    Cc: Martin Peres <martin.peres@free.fr>
    Cc: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index bf62303571b3..3695cde669f8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -301,7 +301,7 @@ nvkm_therm_attr_set(struct nvkm_therm *therm,
 void
 nvkm_therm_clkgate_enable(struct nvkm_therm *therm)
 {
-	if (!therm->func->clkgate_enable || !therm->clkgating_enabled)
+	if (!therm || !therm->func->clkgate_enable || !therm->clkgating_enabled)
 		return;
 
 	nvkm_debug(&therm->subdev,
@@ -312,7 +312,7 @@ nvkm_therm_clkgate_enable(struct nvkm_therm *therm)
 void
 nvkm_therm_clkgate_fini(struct nvkm_therm *therm, bool suspend)
 {
-	if (!therm->func->clkgate_fini || !therm->clkgating_enabled)
+	if (!therm || !therm->func->clkgate_fini || !therm->clkgating_enabled)
 		return;
 
 	nvkm_debug(&therm->subdev,
@@ -395,7 +395,7 @@ void
 nvkm_therm_clkgate_init(struct nvkm_therm *therm,
 			const struct nvkm_therm_clkgate_pack *p)
 {
-	if (!therm->func->clkgate_init || !therm->clkgating_enabled)
+	if (!therm || !therm->func->clkgate_init || !therm->clkgating_enabled)
 		return;
 
 	therm->func->clkgate_init(therm, p);

commit 3ea74559d851b0e3f611da45d0dd9d505c4f44d5
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Feb 1 13:13:59 2018 -0500

    drm/nouveau: Introduce NvPmEnableGating option
    
    This adds the NvPmEnableGating config option to nouveau, which can be
    used to enable or disable clockgating for supported chipsets. Enabling
    can be done by passing
    
            config=NvPmEnableGating=1
    
    To nouveau. If your chipset supports it, you'll see a message in your
    kernel log indicating that clockgating is enabled. Since clockgating has
    only had limited testing thus far, we leave this option disabled by
    default for now.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index de07bc07abdb..bf62303571b3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -434,7 +434,9 @@ nvkm_therm_ctor(struct nvkm_therm *therm, struct nvkm_device *device,
 	therm->attr_get = nvkm_therm_attr_get;
 	therm->attr_set = nvkm_therm_attr_set;
 	therm->mode = therm->suspend = -1; /* undefined */
-	therm->clkgating_enabled = false;
+
+	therm->clkgating_enabled = nvkm_boolopt(device->cfgopt,
+						"NvPmEnableGating", false);
 }
 
 int

commit 1bab09acc9b165c5cd87dc46bc983372e103ae5d
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Feb 1 13:13:56 2018 -0500

    drm/nouveau: Add support for BLCG on Kepler1
    
    This enables BLCG optimization for kepler1. When using clockgating,
    nvidia's firmware has a set of registers which are initially programmed
    by the vbios with various engine delays and other mysterious settings
    that are safe enough to bring up the GPU. However, the values used by
    the vbios are more power hungry then they need to be, so the nvidia driver
    writes it's own more optimized set of BLCG settings before enabling
    CG_CTRL. This adds support for programming the optimized BLCG values
    during engine/subdev init, which enables rather significant power
    savings.
    
    This introduces the nvkm_therm_clkgate_init() helper, which we use to
    program the optimized BLCG settings before enabling clockgating with
    nvkm_therm_clkgate_enable.
    
    As well, this commit shares a lot more code with Fermi since BLCG is
    mostly the same there as far as we can tell. In the future, it's likely
    we'll reformat the clkgate_packs for kepler1 so that they share a list
    of mmio packs with Fermi.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index cf1d5af30f5f..de07bc07abdb 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -391,6 +391,16 @@ nvkm_therm_init(struct nvkm_subdev *subdev)
 	return 0;
 }
 
+void
+nvkm_therm_clkgate_init(struct nvkm_therm *therm,
+			const struct nvkm_therm_clkgate_pack *p)
+{
+	if (!therm->func->clkgate_init || !therm->clkgating_enabled)
+		return;
+
+	therm->func->clkgate_init(therm, p);
+}
+
 static void *
 nvkm_therm_dtor(struct nvkm_subdev *subdev)
 {

commit b138eca661ccee2b43f8ef3cfd952a5c71c1dc90
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Feb 1 13:13:55 2018 -0500

    drm/nouveau: Add support for basic clockgating on Kepler1
    
    This adds support for enabling automatic clockgating on nvidia GPUs for
    Kepler1. While this is not technically a clockgating level, it does
    enable clockgating using the clockgating values initially set by the
    vbios (which should be safe to use).
    
    This introduces two therm helpers for controlling basic clockgating:
            nvkm_therm_clkgate_enable() - enables clockgating through
            CG_CTRL, done after initializing the GPU fully
            nvkm_therm_clkgate_fini() - prepares clockgating for suspend or
            driver unload
    
    A lot of this code was originally going to be based off of fermi;
    however it turns out that while Fermi's the first line of GPUs that
    introduced this kind of power saving, Fermi requires more fine tuned
    control of the CG_CTRL registers from the driver while reclocking that
    we don't entirely understand yet.
    
    For the simple parts we will be sharing with Fermi for certain however,
    we at least add those into a new subdev/therm/gf100.h header.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index f27fc6d0d4c6..cf1d5af30f5f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -21,6 +21,7 @@
  *
  * Authors: Martin Peres
  */
+#include <nvkm/core/option.h>
 #include "priv.h"
 
 int
@@ -297,6 +298,38 @@ nvkm_therm_attr_set(struct nvkm_therm *therm,
 	return -EINVAL;
 }
 
+void
+nvkm_therm_clkgate_enable(struct nvkm_therm *therm)
+{
+	if (!therm->func->clkgate_enable || !therm->clkgating_enabled)
+		return;
+
+	nvkm_debug(&therm->subdev,
+		   "Enabling clockgating\n");
+	therm->func->clkgate_enable(therm);
+}
+
+void
+nvkm_therm_clkgate_fini(struct nvkm_therm *therm, bool suspend)
+{
+	if (!therm->func->clkgate_fini || !therm->clkgating_enabled)
+		return;
+
+	nvkm_debug(&therm->subdev,
+		   "Preparing clockgating for %s\n",
+		   suspend ? "suspend" : "fini");
+	therm->func->clkgate_fini(therm, suspend);
+}
+
+static void
+nvkm_therm_clkgate_oneinit(struct nvkm_therm *therm)
+{
+	if (!therm->func->clkgate_enable || !therm->clkgating_enabled)
+		return;
+
+	nvkm_info(&therm->subdev, "Clockgating enabled\n");
+}
+
 static void
 nvkm_therm_intr(struct nvkm_subdev *subdev)
 {
@@ -333,6 +366,7 @@ nvkm_therm_oneinit(struct nvkm_subdev *subdev)
 	nvkm_therm_fan_ctor(therm);
 	nvkm_therm_fan_mode(therm, NVKM_THERM_CTRL_AUTO);
 	nvkm_therm_sensor_preinit(therm);
+	nvkm_therm_clkgate_oneinit(therm);
 	return 0;
 }
 
@@ -374,15 +408,10 @@ nvkm_therm = {
 	.intr = nvkm_therm_intr,
 };
 
-int
-nvkm_therm_new_(const struct nvkm_therm_func *func, struct nvkm_device *device,
-		int index, struct nvkm_therm **ptherm)
+void
+nvkm_therm_ctor(struct nvkm_therm *therm, struct nvkm_device *device,
+		int index, const struct nvkm_therm_func *func)
 {
-	struct nvkm_therm *therm;
-
-	if (!(therm = *ptherm = kzalloc(sizeof(*therm), GFP_KERNEL)))
-		return -ENOMEM;
-
 	nvkm_subdev_ctor(&nvkm_therm, device, index, &therm->subdev);
 	therm->func = func;
 
@@ -395,5 +424,18 @@ nvkm_therm_new_(const struct nvkm_therm_func *func, struct nvkm_device *device,
 	therm->attr_get = nvkm_therm_attr_get;
 	therm->attr_set = nvkm_therm_attr_set;
 	therm->mode = therm->suspend = -1; /* undefined */
+	therm->clkgating_enabled = false;
+}
+
+int
+nvkm_therm_new_(const struct nvkm_therm_func *func, struct nvkm_device *device,
+		int index, struct nvkm_therm **ptherm)
+{
+	struct nvkm_therm *therm;
+
+	if (!(therm = *ptherm = kzalloc(sizeof(*therm), GFP_KERNEL)))
+		return -ENOMEM;
+
+	nvkm_therm_ctor(therm, device, index, func);
 	return 0;
 }

commit d32656373857839c82e3941a9e26cf228ca319b3
Author: Rhys Kidd <rhyskidd@gmail.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/therm/gp100: initial implementation of new gp1xx temperature sensor
    
    v2:
     - add nv138 and drop nv13b chipsets (Ilia Mirkin)
     - refactor out status variable and instead mask tsensor (Ilia Mirkin)
     - switch SHADOWed state message away from nvkm_error() (Ilia Mirkin)
     - rename internal temperature variable (Karol Herbst)
    
    v3:
     - use nvkm_trace() for SHADOWed state message (Ben Skeggs)
    
    Signed-off-by: Rhys Kidd <rhyskidd@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index 952a7cb0a59a..f27fc6d0d4c6 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -341,7 +341,8 @@ nvkm_therm_init(struct nvkm_subdev *subdev)
 {
 	struct nvkm_therm *therm = nvkm_therm(subdev);
 
-	therm->func->init(therm);
+	if (therm->func->init)
+		therm->func->init(therm);
 
 	if (therm->suspend >= 0) {
 		/* restore the pwm value only when on manual or auto mode */

commit 7eaf1198a9aaa9c31c9270e370088d8a79c149ab
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu May 11 17:29:58 2017 +1000

    drm/nouveau/tmr: remove nvkm_timer_alarm_cancel()
    
    nvkm_timer_alarm() already handles this as part of protecting against
    callers passing in no timeout value.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index be691a7b972f..952a7cb0a59a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -116,7 +116,7 @@ nvkm_therm_update(struct nvkm_therm *therm, int mode)
 
 	switch (mode) {
 	case NVKM_THERM_CTRL_MANUAL:
-		nvkm_timer_alarm_cancel(tmr, &therm->alarm);
+		nvkm_timer_alarm(tmr, 0, &therm->alarm);
 		duty = nvkm_therm_fan_get(therm);
 		if (duty < 0)
 			duty = 100;
@@ -142,7 +142,7 @@ nvkm_therm_update(struct nvkm_therm *therm, int mode)
 		break;
 	case NVKM_THERM_CTRL_NONE:
 	default:
-		nvkm_timer_alarm_cancel(tmr, &therm->alarm);
+		nvkm_timer_alarm(tmr, 0, &therm->alarm);
 		poll = false;
 	}
 

commit e4311ee51d1e2676001b2d8fcefd92bdd79aad85
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu May 11 17:33:39 2017 +1000

    drm/nouveau/therm: remove ineffective workarounds for alarm bugs
    
    These were ineffective due to touching the list without the alarm lock,
    but should no longer be required.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index df949fa7d05d..be691a7b972f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -146,7 +146,7 @@ nvkm_therm_update(struct nvkm_therm *therm, int mode)
 		poll = false;
 	}
 
-	if (list_empty(&therm->alarm.head) && poll)
+	if (poll)
 		nvkm_timer_alarm(tmr, 1000000000ULL, &therm->alarm);
 	spin_unlock_irqrestore(&therm->lock, flags);
 

commit 800efb4c2857ec543fdc33585bbcb1fd5ef28337
Author: Martin Peres <martin.peres@free.fr>
Date:   Thu Sep 29 03:41:35 2016 +0300

    drm/nouveau/drm/therm/fan: add a fallback if no fan control is specified in the vbios
    
    This seems to be absolutely necessary for a lot of NV40.
    
    Reported-by: gsgf on IRC/freenode
    Signed-off-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index 8894fee30cbc..df949fa7d05d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -64,10 +64,9 @@ nvkm_therm_update_trip(struct nvkm_therm *therm)
 }
 
 static int
-nvkm_therm_update_linear(struct nvkm_therm *therm)
+nvkm_therm_compute_linear_duty(struct nvkm_therm *therm, u8 linear_min_temp,
+                               u8 linear_max_temp)
 {
-	u8  linear_min_temp = therm->fan->bios.linear_min_temp;
-	u8  linear_max_temp = therm->fan->bios.linear_max_temp;
 	u8  temp = therm->func->temp_get(therm);
 	u16 duty;
 
@@ -85,6 +84,21 @@ nvkm_therm_update_linear(struct nvkm_therm *therm)
 	return duty;
 }
 
+static int
+nvkm_therm_update_linear(struct nvkm_therm *therm)
+{
+	u8  min = therm->fan->bios.linear_min_temp;
+	u8  max = therm->fan->bios.linear_max_temp;
+	return nvkm_therm_compute_linear_duty(therm, min, max);
+}
+
+static int
+nvkm_therm_update_linear_fallback(struct nvkm_therm *therm)
+{
+	u8 max = therm->bios_sensor.thrs_fan_boost.temp;
+	return nvkm_therm_compute_linear_duty(therm, 30, max);
+}
+
 static void
 nvkm_therm_update(struct nvkm_therm *therm, int mode)
 {
@@ -119,6 +133,8 @@ nvkm_therm_update(struct nvkm_therm *therm, int mode)
 		case NVBIOS_THERM_FAN_OTHER:
 			if (therm->cstate)
 				duty = therm->cstate;
+			else
+				duty = nvkm_therm_update_linear_fallback(therm);
 			poll = false;
 			break;
 		}

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index 949dc6101a58..8894fee30cbc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -366,7 +366,7 @@ nvkm_therm_new_(const struct nvkm_therm_func *func, struct nvkm_device *device,
 	if (!(therm = *ptherm = kzalloc(sizeof(*therm), GFP_KERNEL)))
 		return -ENOMEM;
 
-	nvkm_subdev_ctor(&nvkm_therm, device, index, 0, &therm->subdev);
+	nvkm_subdev_ctor(&nvkm_therm, device, index, &therm->subdev);
 	therm->func = func;
 
 	nvkm_alarm_init(&therm->alarm, nvkm_therm_alarm);

commit 31649ecf47a44e02e73bffc5680c8f56d6cf587a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:21 2015 +1000

    drm/nouveau/tmr: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index 304bdfc54445..949dc6101a58 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -102,7 +102,7 @@ nvkm_therm_update(struct nvkm_therm *therm, int mode)
 
 	switch (mode) {
 	case NVKM_THERM_CTRL_MANUAL:
-		tmr->alarm_cancel(tmr, &therm->alarm);
+		nvkm_timer_alarm_cancel(tmr, &therm->alarm);
 		duty = nvkm_therm_fan_get(therm);
 		if (duty < 0)
 			duty = 100;
@@ -126,12 +126,12 @@ nvkm_therm_update(struct nvkm_therm *therm, int mode)
 		break;
 	case NVKM_THERM_CTRL_NONE:
 	default:
-		tmr->alarm_cancel(tmr, &therm->alarm);
+		nvkm_timer_alarm_cancel(tmr, &therm->alarm);
 		poll = false;
 	}
 
 	if (list_empty(&therm->alarm.head) && poll)
-		tmr->alarm(tmr, 1000000000ULL, &therm->alarm);
+		nvkm_timer_alarm(tmr, 1000000000ULL, &therm->alarm);
 	spin_unlock_irqrestore(&therm->lock, flags);
 
 	if (duty >= 0) {

commit 57113c0170b9efeacb3e3e9d4c2178c30d9cd991
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:21 2015 +1000

    drm/nouveau/therm: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index e757fd9b7a07..304bdfc54445 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -23,14 +23,21 @@
  */
 #include "priv.h"
 
+int
+nvkm_therm_temp_get(struct nvkm_therm *therm)
+{
+	if (therm->func->temp_get)
+		return therm->func->temp_get(therm);
+	return -ENODEV;
+}
+
 static int
-nvkm_therm_update_trip(struct nvkm_therm *obj)
+nvkm_therm_update_trip(struct nvkm_therm *therm)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 	struct nvbios_therm_trip_point *trip = therm->fan->bios.trip,
 				       *cur_trip = NULL,
 				       *last_trip = therm->last_trip;
-	u8  temp = therm->base.temp_get(&therm->base);
+	u8  temp = therm->func->temp_get(therm);
 	u16 duty, i;
 
 	/* look for the trip point corresponding to the current temperature */
@@ -57,12 +64,11 @@ nvkm_therm_update_trip(struct nvkm_therm *obj)
 }
 
 static int
-nvkm_therm_update_linear(struct nvkm_therm *obj)
+nvkm_therm_update_linear(struct nvkm_therm *therm)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 	u8  linear_min_temp = therm->fan->bios.linear_min_temp;
 	u8  linear_max_temp = therm->fan->bios.linear_max_temp;
-	u8  temp = therm->base.temp_get(&therm->base);
+	u8  temp = therm->func->temp_get(therm);
 	u16 duty;
 
 	/* handle the non-linear part first */
@@ -80,10 +86,9 @@ nvkm_therm_update_linear(struct nvkm_therm *obj)
 }
 
 static void
-nvkm_therm_update(struct nvkm_therm *obj, int mode)
+nvkm_therm_update(struct nvkm_therm *therm, int mode)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	struct nvkm_subdev *subdev = &therm->base.subdev;
+	struct nvkm_subdev *subdev = &therm->subdev;
 	struct nvkm_timer *tmr = subdev->device->timer;
 	unsigned long flags;
 	bool immd = true;
@@ -98,7 +103,7 @@ nvkm_therm_update(struct nvkm_therm *obj, int mode)
 	switch (mode) {
 	case NVKM_THERM_CTRL_MANUAL:
 		tmr->alarm_cancel(tmr, &therm->alarm);
-		duty = nvkm_therm_fan_get(&therm->base);
+		duty = nvkm_therm_fan_get(therm);
 		if (duty < 0)
 			duty = 100;
 		poll = false;
@@ -106,10 +111,10 @@ nvkm_therm_update(struct nvkm_therm *obj, int mode)
 	case NVKM_THERM_CTRL_AUTO:
 		switch(therm->fan->bios.fan_mode) {
 		case NVBIOS_THERM_FAN_TRIP:
-			duty = nvkm_therm_update_trip(&therm->base);
+			duty = nvkm_therm_update_trip(therm);
 			break;
 		case NVBIOS_THERM_FAN_LINEAR:
-			duty = nvkm_therm_update_linear(&therm->base);
+			duty = nvkm_therm_update_linear(therm);
 			break;
 		case NVBIOS_THERM_FAN_OTHER:
 			if (therm->cstate)
@@ -131,20 +136,19 @@ nvkm_therm_update(struct nvkm_therm *obj, int mode)
 
 	if (duty >= 0) {
 		nvkm_debug(subdev, "FAN target request: %d%%\n", duty);
-		nvkm_therm_fan_set(&therm->base, immd, duty);
+		nvkm_therm_fan_set(therm, immd, duty);
 	}
 }
 
 int
-nvkm_therm_cstate(struct nvkm_therm *obj, int fan, int dir)
+nvkm_therm_cstate(struct nvkm_therm *therm, int fan, int dir)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	struct nvkm_subdev *subdev = &therm->base.subdev;
+	struct nvkm_subdev *subdev = &therm->subdev;
 	if (!dir || (dir < 0 && fan < therm->cstate) ||
 		    (dir > 0 && fan > therm->cstate)) {
 		nvkm_debug(subdev, "default fan speed -> %d%%\n", fan);
 		therm->cstate = fan;
-		nvkm_therm_update(&therm->base, -1);
+		nvkm_therm_update(therm, -1);
 	}
 	return 0;
 }
@@ -152,16 +156,15 @@ nvkm_therm_cstate(struct nvkm_therm *obj, int fan, int dir)
 static void
 nvkm_therm_alarm(struct nvkm_alarm *alarm)
 {
-	struct nvkm_therm_priv *therm =
-	       container_of(alarm, struct nvkm_therm_priv, alarm);
-	nvkm_therm_update(&therm->base, -1);
+	struct nvkm_therm *therm =
+	       container_of(alarm, struct nvkm_therm, alarm);
+	nvkm_therm_update(therm, -1);
 }
 
 int
-nvkm_therm_fan_mode(struct nvkm_therm *obj, int mode)
+nvkm_therm_fan_mode(struct nvkm_therm *therm, int mode)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	struct nvkm_subdev *subdev = &therm->base.subdev;
+	struct nvkm_subdev *subdev = &therm->subdev;
 	struct nvkm_device *device = subdev->device;
 	static const char *name[] = {
 		"disabled",
@@ -172,28 +175,26 @@ nvkm_therm_fan_mode(struct nvkm_therm *obj, int mode)
 	/* The default PPWR ucode on fermi interferes with fan management */
 	if ((mode >= ARRAY_SIZE(name)) ||
 	    (mode != NVKM_THERM_CTRL_NONE && device->card_type >= NV_C0 &&
-	     !nvkm_subdev(device, NVDEV_SUBDEV_PMU)))
+	     !device->pmu))
 		return -EINVAL;
 
 	/* do not allow automatic fan management if the thermal sensor is
 	 * not available */
 	if (mode == NVKM_THERM_CTRL_AUTO &&
-	    therm->base.temp_get(&therm->base) < 0)
+	    therm->func->temp_get(therm) < 0)
 		return -EINVAL;
 
 	if (therm->mode == mode)
 		return 0;
 
 	nvkm_debug(subdev, "fan management: %s\n", name[mode]);
-	nvkm_therm_update(&therm->base, mode);
+	nvkm_therm_update(therm, mode);
 	return 0;
 }
 
 int
-nvkm_therm_attr_get(struct nvkm_therm *obj, enum nvkm_therm_attr_type type)
+nvkm_therm_attr_get(struct nvkm_therm *therm, enum nvkm_therm_attr_type type)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-
 	switch (type) {
 	case NVKM_THERM_ATTR_FAN_MIN_DUTY:
 		return therm->fan->bios.min_duty;
@@ -223,11 +224,9 @@ nvkm_therm_attr_get(struct nvkm_therm *obj, enum nvkm_therm_attr_type type)
 }
 
 int
-nvkm_therm_attr_set(struct nvkm_therm *obj,
+nvkm_therm_attr_set(struct nvkm_therm *therm,
 		    enum nvkm_therm_attr_type type, int value)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-
 	switch (type) {
 	case NVKM_THERM_ATTR_FAN_MIN_DUTY:
 		if (value < 0)
@@ -244,123 +243,140 @@ nvkm_therm_attr_set(struct nvkm_therm *obj,
 		therm->fan->bios.max_duty = value;
 		return 0;
 	case NVKM_THERM_ATTR_FAN_MODE:
-		return nvkm_therm_fan_mode(&therm->base, value);
+		return nvkm_therm_fan_mode(therm, value);
 	case NVKM_THERM_ATTR_THRS_FAN_BOOST:
 		therm->bios_sensor.thrs_fan_boost.temp = value;
-		therm->sensor.program_alarms(&therm->base);
+		therm->func->program_alarms(therm);
 		return 0;
 	case NVKM_THERM_ATTR_THRS_FAN_BOOST_HYST:
 		therm->bios_sensor.thrs_fan_boost.hysteresis = value;
-		therm->sensor.program_alarms(&therm->base);
+		therm->func->program_alarms(therm);
 		return 0;
 	case NVKM_THERM_ATTR_THRS_DOWN_CLK:
 		therm->bios_sensor.thrs_down_clock.temp = value;
-		therm->sensor.program_alarms(&therm->base);
+		therm->func->program_alarms(therm);
 		return 0;
 	case NVKM_THERM_ATTR_THRS_DOWN_CLK_HYST:
 		therm->bios_sensor.thrs_down_clock.hysteresis = value;
-		therm->sensor.program_alarms(&therm->base);
+		therm->func->program_alarms(therm);
 		return 0;
 	case NVKM_THERM_ATTR_THRS_CRITICAL:
 		therm->bios_sensor.thrs_critical.temp = value;
-		therm->sensor.program_alarms(&therm->base);
+		therm->func->program_alarms(therm);
 		return 0;
 	case NVKM_THERM_ATTR_THRS_CRITICAL_HYST:
 		therm->bios_sensor.thrs_critical.hysteresis = value;
-		therm->sensor.program_alarms(&therm->base);
+		therm->func->program_alarms(therm);
 		return 0;
 	case NVKM_THERM_ATTR_THRS_SHUTDOWN:
 		therm->bios_sensor.thrs_shutdown.temp = value;
-		therm->sensor.program_alarms(&therm->base);
+		therm->func->program_alarms(therm);
 		return 0;
 	case NVKM_THERM_ATTR_THRS_SHUTDOWN_HYST:
 		therm->bios_sensor.thrs_shutdown.hysteresis = value;
-		therm->sensor.program_alarms(&therm->base);
+		therm->func->program_alarms(therm);
 		return 0;
 	}
 
 	return -EINVAL;
 }
 
-int
-_nvkm_therm_init(struct nvkm_object *object)
+static void
+nvkm_therm_intr(struct nvkm_subdev *subdev)
 {
-	struct nvkm_therm_priv *therm = (void *)object;
-	int ret;
-
-	ret = nvkm_subdev_init_old(&therm->base.subdev);
-	if (ret)
-		return ret;
-
-	if (therm->suspend >= 0) {
-		/* restore the pwm value only when on manual or auto mode */
-		if (therm->suspend > 0)
-			nvkm_therm_fan_set(&therm->base, true, therm->fan->percent);
-
-		nvkm_therm_fan_mode(&therm->base, therm->suspend);
-	}
-	nvkm_therm_sensor_init(&therm->base);
-	nvkm_therm_fan_init(&therm->base);
-	return 0;
+	struct nvkm_therm *therm = nvkm_therm(subdev);
+	if (therm->func->intr)
+		therm->func->intr(therm);
 }
 
-int
-_nvkm_therm_fini(struct nvkm_object *object, bool suspend)
+static int
+nvkm_therm_fini(struct nvkm_subdev *subdev, bool suspend)
 {
-	struct nvkm_therm_priv *therm = (void *)object;
+	struct nvkm_therm *therm = nvkm_therm(subdev);
+
+	if (therm->func->fini)
+		therm->func->fini(therm);
+
+	nvkm_therm_fan_fini(therm, suspend);
+	nvkm_therm_sensor_fini(therm, suspend);
 
-	nvkm_therm_fan_fini(&therm->base, suspend);
-	nvkm_therm_sensor_fini(&therm->base, suspend);
 	if (suspend) {
 		therm->suspend = therm->mode;
 		therm->mode = NVKM_THERM_CTRL_NONE;
 	}
 
-	return nvkm_subdev_fini_old(&therm->base.subdev, suspend);
-}
-
-int
-nvkm_therm_create_(struct nvkm_object *parent, struct nvkm_object *engine,
-		   struct nvkm_oclass *oclass, int length, void **pobject)
-{
-	struct nvkm_therm_priv *therm;
-	int ret;
-
-	ret = nvkm_subdev_create_(parent, engine, oclass, 0, "PTHERM",
-				  "therm", length, pobject);
-	therm = *pobject;
-	if (ret)
-		return ret;
-
-	nvkm_alarm_init(&therm->alarm, nvkm_therm_alarm);
-	spin_lock_init(&therm->lock);
-	spin_lock_init(&therm->sensor.alarm_program_lock);
-
-	therm->base.fan_get = nvkm_therm_fan_user_get;
-	therm->base.fan_set = nvkm_therm_fan_user_set;
-	therm->base.fan_sense = nvkm_therm_fan_sense;
-	therm->base.attr_get = nvkm_therm_attr_get;
-	therm->base.attr_set = nvkm_therm_attr_set;
-	therm->mode = therm->suspend = -1; /* undefined */
 	return 0;
 }
 
-int
-nvkm_therm_preinit(struct nvkm_therm *therm)
+static int
+nvkm_therm_oneinit(struct nvkm_subdev *subdev)
 {
+	struct nvkm_therm *therm = nvkm_therm(subdev);
 	nvkm_therm_sensor_ctor(therm);
 	nvkm_therm_ic_ctor(therm);
 	nvkm_therm_fan_ctor(therm);
-
 	nvkm_therm_fan_mode(therm, NVKM_THERM_CTRL_AUTO);
 	nvkm_therm_sensor_preinit(therm);
 	return 0;
 }
 
-void
-_nvkm_therm_dtor(struct nvkm_object *object)
+static int
+nvkm_therm_init(struct nvkm_subdev *subdev)
+{
+	struct nvkm_therm *therm = nvkm_therm(subdev);
+
+	therm->func->init(therm);
+
+	if (therm->suspend >= 0) {
+		/* restore the pwm value only when on manual or auto mode */
+		if (therm->suspend > 0)
+			nvkm_therm_fan_set(therm, true, therm->fan->percent);
+
+		nvkm_therm_fan_mode(therm, therm->suspend);
+	}
+
+	nvkm_therm_sensor_init(therm);
+	nvkm_therm_fan_init(therm);
+	return 0;
+}
+
+static void *
+nvkm_therm_dtor(struct nvkm_subdev *subdev)
 {
-	struct nvkm_therm_priv *therm = (void *)object;
+	struct nvkm_therm *therm = nvkm_therm(subdev);
 	kfree(therm->fan);
-	nvkm_subdev_destroy(&therm->base.subdev);
+	return therm;
+}
+
+static const struct nvkm_subdev_func
+nvkm_therm = {
+	.dtor = nvkm_therm_dtor,
+	.oneinit = nvkm_therm_oneinit,
+	.init = nvkm_therm_init,
+	.fini = nvkm_therm_fini,
+	.intr = nvkm_therm_intr,
+};
+
+int
+nvkm_therm_new_(const struct nvkm_therm_func *func, struct nvkm_device *device,
+		int index, struct nvkm_therm **ptherm)
+{
+	struct nvkm_therm *therm;
+
+	if (!(therm = *ptherm = kzalloc(sizeof(*therm), GFP_KERNEL)))
+		return -ENOMEM;
+
+	nvkm_subdev_ctor(&nvkm_therm, device, index, 0, &therm->subdev);
+	therm->func = func;
+
+	nvkm_alarm_init(&therm->alarm, nvkm_therm_alarm);
+	spin_lock_init(&therm->lock);
+	spin_lock_init(&therm->sensor.alarm_program_lock);
+
+	therm->fan_get = nvkm_therm_fan_user_get;
+	therm->fan_set = nvkm_therm_fan_user_set;
+	therm->attr_get = nvkm_therm_attr_get;
+	therm->attr_set = nvkm_therm_attr_set;
+	therm->mode = therm->suspend = -1; /* undefined */
+	return 0;
 }

commit 3a8c3400f3e74638bedd0d2410416aa8b794c0fd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/subdev: rename some functions to avoid upcoming conflicts
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index 18fa0443b6d3..e757fd9b7a07 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -288,7 +288,7 @@ _nvkm_therm_init(struct nvkm_object *object)
 	struct nvkm_therm_priv *therm = (void *)object;
 	int ret;
 
-	ret = nvkm_subdev_init(&therm->base.subdev);
+	ret = nvkm_subdev_init_old(&therm->base.subdev);
 	if (ret)
 		return ret;
 
@@ -316,7 +316,7 @@ _nvkm_therm_fini(struct nvkm_object *object, bool suspend)
 		therm->mode = NVKM_THERM_CTRL_NONE;
 	}
 
-	return nvkm_subdev_fini(&therm->base.subdev, suspend);
+	return nvkm_subdev_fini_old(&therm->base.subdev, suspend);
 }
 
 int

commit b3c418bb48228a206a8c421adaf269cdc83c3c52
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:12 2015 +1000

    drm/nouveau/therm: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index 87c20d197102..18fa0443b6d3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -83,7 +83,8 @@ static void
 nvkm_therm_update(struct nvkm_therm *obj, int mode)
 {
 	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	struct nvkm_timer *tmr = nvkm_timer(therm);
+	struct nvkm_subdev *subdev = &therm->base.subdev;
+	struct nvkm_timer *tmr = subdev->device->timer;
 	unsigned long flags;
 	bool immd = true;
 	bool poll = true;
@@ -129,7 +130,7 @@ nvkm_therm_update(struct nvkm_therm *obj, int mode)
 	spin_unlock_irqrestore(&therm->lock, flags);
 
 	if (duty >= 0) {
-		nv_debug(therm, "FAN target request: %d%%\n", duty);
+		nvkm_debug(subdev, "FAN target request: %d%%\n", duty);
 		nvkm_therm_fan_set(&therm->base, immd, duty);
 	}
 }
@@ -138,9 +139,10 @@ int
 nvkm_therm_cstate(struct nvkm_therm *obj, int fan, int dir)
 {
 	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
+	struct nvkm_subdev *subdev = &therm->base.subdev;
 	if (!dir || (dir < 0 && fan < therm->cstate) ||
 		    (dir > 0 && fan > therm->cstate)) {
-		nv_debug(therm, "default fan speed -> %d%%\n", fan);
+		nvkm_debug(subdev, "default fan speed -> %d%%\n", fan);
 		therm->cstate = fan;
 		nvkm_therm_update(&therm->base, -1);
 	}
@@ -159,7 +161,8 @@ int
 nvkm_therm_fan_mode(struct nvkm_therm *obj, int mode)
 {
 	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	struct nvkm_device *device = nv_device(therm);
+	struct nvkm_subdev *subdev = &therm->base.subdev;
+	struct nvkm_device *device = subdev->device;
 	static const char *name[] = {
 		"disabled",
 		"manual",
@@ -181,7 +184,7 @@ nvkm_therm_fan_mode(struct nvkm_therm *obj, int mode)
 	if (therm->mode == mode)
 		return 0;
 
-	nv_info(therm, "fan management: %s\n", name[mode]);
+	nvkm_debug(subdev, "fan management: %s\n", name[mode]);
 	nvkm_therm_update(&therm->base, mode);
 	return 0;
 }

commit cb8bb9cedb6015eafd56ef9e9c5b2c216e8e7960
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/tmr: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index abb3fdc18910..87c20d197102 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -83,7 +83,7 @@ static void
 nvkm_therm_update(struct nvkm_therm *obj, int mode)
 {
 	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	struct nvkm_timer *ptimer = nvkm_timer(therm);
+	struct nvkm_timer *tmr = nvkm_timer(therm);
 	unsigned long flags;
 	bool immd = true;
 	bool poll = true;
@@ -96,7 +96,7 @@ nvkm_therm_update(struct nvkm_therm *obj, int mode)
 
 	switch (mode) {
 	case NVKM_THERM_CTRL_MANUAL:
-		ptimer->alarm_cancel(ptimer, &therm->alarm);
+		tmr->alarm_cancel(tmr, &therm->alarm);
 		duty = nvkm_therm_fan_get(&therm->base);
 		if (duty < 0)
 			duty = 100;
@@ -120,12 +120,12 @@ nvkm_therm_update(struct nvkm_therm *obj, int mode)
 		break;
 	case NVKM_THERM_CTRL_NONE:
 	default:
-		ptimer->alarm_cancel(ptimer, &therm->alarm);
+		tmr->alarm_cancel(tmr, &therm->alarm);
 		poll = false;
 	}
 
 	if (list_empty(&therm->alarm.head) && poll)
-		ptimer->alarm(ptimer, 1000000000ULL, &therm->alarm);
+		tmr->alarm(tmr, 1000000000ULL, &therm->alarm);
 	spin_unlock_irqrestore(&therm->lock, flags);
 
 	if (duty >= 0) {

commit da06b46b720687117178d3ee85a601762f1c36b5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/therm: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index eb86c3ed5f56..abb3fdc18910 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -24,18 +24,18 @@
 #include "priv.h"
 
 static int
-nvkm_therm_update_trip(struct nvkm_therm *therm)
+nvkm_therm_update_trip(struct nvkm_therm *obj)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
-	struct nvbios_therm_trip_point *trip = priv->fan->bios.trip,
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
+	struct nvbios_therm_trip_point *trip = therm->fan->bios.trip,
 				       *cur_trip = NULL,
-				       *last_trip = priv->last_trip;
-	u8  temp = therm->temp_get(therm);
+				       *last_trip = therm->last_trip;
+	u8  temp = therm->base.temp_get(&therm->base);
 	u16 duty, i;
 
 	/* look for the trip point corresponding to the current temperature */
 	cur_trip = NULL;
-	for (i = 0; i < priv->fan->bios.nr_fan_trip; i++) {
+	for (i = 0; i < therm->fan->bios.nr_fan_trip; i++) {
 		if (temp >= trip[i].temp)
 			cur_trip = &trip[i];
 	}
@@ -47,72 +47,72 @@ nvkm_therm_update_trip(struct nvkm_therm *therm)
 
 	if (cur_trip) {
 		duty = cur_trip->fan_duty;
-		priv->last_trip = cur_trip;
+		therm->last_trip = cur_trip;
 	} else {
 		duty = 0;
-		priv->last_trip = NULL;
+		therm->last_trip = NULL;
 	}
 
 	return duty;
 }
 
 static int
-nvkm_therm_update_linear(struct nvkm_therm *therm)
+nvkm_therm_update_linear(struct nvkm_therm *obj)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
-	u8  linear_min_temp = priv->fan->bios.linear_min_temp;
-	u8  linear_max_temp = priv->fan->bios.linear_max_temp;
-	u8  temp = therm->temp_get(therm);
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
+	u8  linear_min_temp = therm->fan->bios.linear_min_temp;
+	u8  linear_max_temp = therm->fan->bios.linear_max_temp;
+	u8  temp = therm->base.temp_get(&therm->base);
 	u16 duty;
 
 	/* handle the non-linear part first */
 	if (temp < linear_min_temp)
-		return priv->fan->bios.min_duty;
+		return therm->fan->bios.min_duty;
 	else if (temp > linear_max_temp)
-		return priv->fan->bios.max_duty;
+		return therm->fan->bios.max_duty;
 
 	/* we are in the linear zone */
 	duty  = (temp - linear_min_temp);
-	duty *= (priv->fan->bios.max_duty - priv->fan->bios.min_duty);
+	duty *= (therm->fan->bios.max_duty - therm->fan->bios.min_duty);
 	duty /= (linear_max_temp - linear_min_temp);
-	duty += priv->fan->bios.min_duty;
+	duty += therm->fan->bios.min_duty;
 	return duty;
 }
 
 static void
-nvkm_therm_update(struct nvkm_therm *therm, int mode)
+nvkm_therm_update(struct nvkm_therm *obj, int mode)
 {
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 	struct nvkm_timer *ptimer = nvkm_timer(therm);
-	struct nvkm_therm_priv *priv = (void *)therm;
 	unsigned long flags;
 	bool immd = true;
 	bool poll = true;
 	int duty = -1;
 
-	spin_lock_irqsave(&priv->lock, flags);
+	spin_lock_irqsave(&therm->lock, flags);
 	if (mode < 0)
-		mode = priv->mode;
-	priv->mode = mode;
+		mode = therm->mode;
+	therm->mode = mode;
 
 	switch (mode) {
 	case NVKM_THERM_CTRL_MANUAL:
-		ptimer->alarm_cancel(ptimer, &priv->alarm);
-		duty = nvkm_therm_fan_get(therm);
+		ptimer->alarm_cancel(ptimer, &therm->alarm);
+		duty = nvkm_therm_fan_get(&therm->base);
 		if (duty < 0)
 			duty = 100;
 		poll = false;
 		break;
 	case NVKM_THERM_CTRL_AUTO:
-		switch(priv->fan->bios.fan_mode) {
+		switch(therm->fan->bios.fan_mode) {
 		case NVBIOS_THERM_FAN_TRIP:
-			duty = nvkm_therm_update_trip(therm);
+			duty = nvkm_therm_update_trip(&therm->base);
 			break;
 		case NVBIOS_THERM_FAN_LINEAR:
-			duty = nvkm_therm_update_linear(therm);
+			duty = nvkm_therm_update_linear(&therm->base);
 			break;
 		case NVBIOS_THERM_FAN_OTHER:
-			if (priv->cstate)
-				duty = priv->cstate;
+			if (therm->cstate)
+				duty = therm->cstate;
 			poll = false;
 			break;
 		}
@@ -120,29 +120,29 @@ nvkm_therm_update(struct nvkm_therm *therm, int mode)
 		break;
 	case NVKM_THERM_CTRL_NONE:
 	default:
-		ptimer->alarm_cancel(ptimer, &priv->alarm);
+		ptimer->alarm_cancel(ptimer, &therm->alarm);
 		poll = false;
 	}
 
-	if (list_empty(&priv->alarm.head) && poll)
-		ptimer->alarm(ptimer, 1000000000ULL, &priv->alarm);
-	spin_unlock_irqrestore(&priv->lock, flags);
+	if (list_empty(&therm->alarm.head) && poll)
+		ptimer->alarm(ptimer, 1000000000ULL, &therm->alarm);
+	spin_unlock_irqrestore(&therm->lock, flags);
 
 	if (duty >= 0) {
 		nv_debug(therm, "FAN target request: %d%%\n", duty);
-		nvkm_therm_fan_set(therm, immd, duty);
+		nvkm_therm_fan_set(&therm->base, immd, duty);
 	}
 }
 
 int
-nvkm_therm_cstate(struct nvkm_therm *ptherm, int fan, int dir)
+nvkm_therm_cstate(struct nvkm_therm *obj, int fan, int dir)
 {
-	struct nvkm_therm_priv *priv = (void *)ptherm;
-	if (!dir || (dir < 0 && fan < priv->cstate) ||
-		    (dir > 0 && fan > priv->cstate)) {
-		nv_debug(ptherm, "default fan speed -> %d%%\n", fan);
-		priv->cstate = fan;
-		nvkm_therm_update(ptherm, -1);
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
+	if (!dir || (dir < 0 && fan < therm->cstate) ||
+		    (dir > 0 && fan > therm->cstate)) {
+		nv_debug(therm, "default fan speed -> %d%%\n", fan);
+		therm->cstate = fan;
+		nvkm_therm_update(&therm->base, -1);
 	}
 	return 0;
 }
@@ -150,15 +150,15 @@ nvkm_therm_cstate(struct nvkm_therm *ptherm, int fan, int dir)
 static void
 nvkm_therm_alarm(struct nvkm_alarm *alarm)
 {
-	struct nvkm_therm_priv *priv =
+	struct nvkm_therm_priv *therm =
 	       container_of(alarm, struct nvkm_therm_priv, alarm);
-	nvkm_therm_update(&priv->base, -1);
+	nvkm_therm_update(&therm->base, -1);
 }
 
 int
-nvkm_therm_fan_mode(struct nvkm_therm *therm, int mode)
+nvkm_therm_fan_mode(struct nvkm_therm *obj, int mode)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 	struct nvkm_device *device = nv_device(therm);
 	static const char *name[] = {
 		"disabled",
@@ -174,105 +174,105 @@ nvkm_therm_fan_mode(struct nvkm_therm *therm, int mode)
 
 	/* do not allow automatic fan management if the thermal sensor is
 	 * not available */
-	if (mode == NVKM_THERM_CTRL_AUTO && therm->temp_get(therm) < 0)
+	if (mode == NVKM_THERM_CTRL_AUTO &&
+	    therm->base.temp_get(&therm->base) < 0)
 		return -EINVAL;
 
-	if (priv->mode == mode)
+	if (therm->mode == mode)
 		return 0;
 
 	nv_info(therm, "fan management: %s\n", name[mode]);
-	nvkm_therm_update(therm, mode);
+	nvkm_therm_update(&therm->base, mode);
 	return 0;
 }
 
 int
-nvkm_therm_attr_get(struct nvkm_therm *therm,
-		       enum nvkm_therm_attr_type type)
+nvkm_therm_attr_get(struct nvkm_therm *obj, enum nvkm_therm_attr_type type)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 
 	switch (type) {
 	case NVKM_THERM_ATTR_FAN_MIN_DUTY:
-		return priv->fan->bios.min_duty;
+		return therm->fan->bios.min_duty;
 	case NVKM_THERM_ATTR_FAN_MAX_DUTY:
-		return priv->fan->bios.max_duty;
+		return therm->fan->bios.max_duty;
 	case NVKM_THERM_ATTR_FAN_MODE:
-		return priv->mode;
+		return therm->mode;
 	case NVKM_THERM_ATTR_THRS_FAN_BOOST:
-		return priv->bios_sensor.thrs_fan_boost.temp;
+		return therm->bios_sensor.thrs_fan_boost.temp;
 	case NVKM_THERM_ATTR_THRS_FAN_BOOST_HYST:
-		return priv->bios_sensor.thrs_fan_boost.hysteresis;
+		return therm->bios_sensor.thrs_fan_boost.hysteresis;
 	case NVKM_THERM_ATTR_THRS_DOWN_CLK:
-		return priv->bios_sensor.thrs_down_clock.temp;
+		return therm->bios_sensor.thrs_down_clock.temp;
 	case NVKM_THERM_ATTR_THRS_DOWN_CLK_HYST:
-		return priv->bios_sensor.thrs_down_clock.hysteresis;
+		return therm->bios_sensor.thrs_down_clock.hysteresis;
 	case NVKM_THERM_ATTR_THRS_CRITICAL:
-		return priv->bios_sensor.thrs_critical.temp;
+		return therm->bios_sensor.thrs_critical.temp;
 	case NVKM_THERM_ATTR_THRS_CRITICAL_HYST:
-		return priv->bios_sensor.thrs_critical.hysteresis;
+		return therm->bios_sensor.thrs_critical.hysteresis;
 	case NVKM_THERM_ATTR_THRS_SHUTDOWN:
-		return priv->bios_sensor.thrs_shutdown.temp;
+		return therm->bios_sensor.thrs_shutdown.temp;
 	case NVKM_THERM_ATTR_THRS_SHUTDOWN_HYST:
-		return priv->bios_sensor.thrs_shutdown.hysteresis;
+		return therm->bios_sensor.thrs_shutdown.hysteresis;
 	}
 
 	return -EINVAL;
 }
 
 int
-nvkm_therm_attr_set(struct nvkm_therm *therm,
+nvkm_therm_attr_set(struct nvkm_therm *obj,
 		    enum nvkm_therm_attr_type type, int value)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 
 	switch (type) {
 	case NVKM_THERM_ATTR_FAN_MIN_DUTY:
 		if (value < 0)
 			value = 0;
-		if (value > priv->fan->bios.max_duty)
-			value = priv->fan->bios.max_duty;
-		priv->fan->bios.min_duty = value;
+		if (value > therm->fan->bios.max_duty)
+			value = therm->fan->bios.max_duty;
+		therm->fan->bios.min_duty = value;
 		return 0;
 	case NVKM_THERM_ATTR_FAN_MAX_DUTY:
 		if (value < 0)
 			value = 0;
-		if (value < priv->fan->bios.min_duty)
-			value = priv->fan->bios.min_duty;
-		priv->fan->bios.max_duty = value;
+		if (value < therm->fan->bios.min_duty)
+			value = therm->fan->bios.min_duty;
+		therm->fan->bios.max_duty = value;
 		return 0;
 	case NVKM_THERM_ATTR_FAN_MODE:
-		return nvkm_therm_fan_mode(therm, value);
+		return nvkm_therm_fan_mode(&therm->base, value);
 	case NVKM_THERM_ATTR_THRS_FAN_BOOST:
-		priv->bios_sensor.thrs_fan_boost.temp = value;
-		priv->sensor.program_alarms(therm);
+		therm->bios_sensor.thrs_fan_boost.temp = value;
+		therm->sensor.program_alarms(&therm->base);
 		return 0;
 	case NVKM_THERM_ATTR_THRS_FAN_BOOST_HYST:
-		priv->bios_sensor.thrs_fan_boost.hysteresis = value;
-		priv->sensor.program_alarms(therm);
+		therm->bios_sensor.thrs_fan_boost.hysteresis = value;
+		therm->sensor.program_alarms(&therm->base);
 		return 0;
 	case NVKM_THERM_ATTR_THRS_DOWN_CLK:
-		priv->bios_sensor.thrs_down_clock.temp = value;
-		priv->sensor.program_alarms(therm);
+		therm->bios_sensor.thrs_down_clock.temp = value;
+		therm->sensor.program_alarms(&therm->base);
 		return 0;
 	case NVKM_THERM_ATTR_THRS_DOWN_CLK_HYST:
-		priv->bios_sensor.thrs_down_clock.hysteresis = value;
-		priv->sensor.program_alarms(therm);
+		therm->bios_sensor.thrs_down_clock.hysteresis = value;
+		therm->sensor.program_alarms(&therm->base);
 		return 0;
 	case NVKM_THERM_ATTR_THRS_CRITICAL:
-		priv->bios_sensor.thrs_critical.temp = value;
-		priv->sensor.program_alarms(therm);
+		therm->bios_sensor.thrs_critical.temp = value;
+		therm->sensor.program_alarms(&therm->base);
 		return 0;
 	case NVKM_THERM_ATTR_THRS_CRITICAL_HYST:
-		priv->bios_sensor.thrs_critical.hysteresis = value;
-		priv->sensor.program_alarms(therm);
+		therm->bios_sensor.thrs_critical.hysteresis = value;
+		therm->sensor.program_alarms(&therm->base);
 		return 0;
 	case NVKM_THERM_ATTR_THRS_SHUTDOWN:
-		priv->bios_sensor.thrs_shutdown.temp = value;
-		priv->sensor.program_alarms(therm);
+		therm->bios_sensor.thrs_shutdown.temp = value;
+		therm->sensor.program_alarms(&therm->base);
 		return 0;
 	case NVKM_THERM_ATTR_THRS_SHUTDOWN_HYST:
-		priv->bios_sensor.thrs_shutdown.hysteresis = value;
-		priv->sensor.program_alarms(therm);
+		therm->bios_sensor.thrs_shutdown.hysteresis = value;
+		therm->sensor.program_alarms(&therm->base);
 		return 0;
 	}
 
@@ -282,65 +282,63 @@ nvkm_therm_attr_set(struct nvkm_therm *therm,
 int
 _nvkm_therm_init(struct nvkm_object *object)
 {
-	struct nvkm_therm *therm = (void *)object;
-	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *therm = (void *)object;
 	int ret;
 
-	ret = nvkm_subdev_init(&therm->base);
+	ret = nvkm_subdev_init(&therm->base.subdev);
 	if (ret)
 		return ret;
 
-	if (priv->suspend >= 0) {
+	if (therm->suspend >= 0) {
 		/* restore the pwm value only when on manual or auto mode */
-		if (priv->suspend > 0)
-			nvkm_therm_fan_set(therm, true, priv->fan->percent);
+		if (therm->suspend > 0)
+			nvkm_therm_fan_set(&therm->base, true, therm->fan->percent);
 
-		nvkm_therm_fan_mode(therm, priv->suspend);
+		nvkm_therm_fan_mode(&therm->base, therm->suspend);
 	}
-	nvkm_therm_sensor_init(therm);
-	nvkm_therm_fan_init(therm);
+	nvkm_therm_sensor_init(&therm->base);
+	nvkm_therm_fan_init(&therm->base);
 	return 0;
 }
 
 int
 _nvkm_therm_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nvkm_therm *therm = (void *)object;
-	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *therm = (void *)object;
 
-	nvkm_therm_fan_fini(therm, suspend);
-	nvkm_therm_sensor_fini(therm, suspend);
+	nvkm_therm_fan_fini(&therm->base, suspend);
+	nvkm_therm_sensor_fini(&therm->base, suspend);
 	if (suspend) {
-		priv->suspend = priv->mode;
-		priv->mode = NVKM_THERM_CTRL_NONE;
+		therm->suspend = therm->mode;
+		therm->mode = NVKM_THERM_CTRL_NONE;
 	}
 
-	return nvkm_subdev_fini(&therm->base, suspend);
+	return nvkm_subdev_fini(&therm->base.subdev, suspend);
 }
 
 int
 nvkm_therm_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		   struct nvkm_oclass *oclass, int length, void **pobject)
 {
-	struct nvkm_therm_priv *priv;
+	struct nvkm_therm_priv *therm;
 	int ret;
 
 	ret = nvkm_subdev_create_(parent, engine, oclass, 0, "PTHERM",
 				  "therm", length, pobject);
-	priv = *pobject;
+	therm = *pobject;
 	if (ret)
 		return ret;
 
-	nvkm_alarm_init(&priv->alarm, nvkm_therm_alarm);
-	spin_lock_init(&priv->lock);
-	spin_lock_init(&priv->sensor.alarm_program_lock);
+	nvkm_alarm_init(&therm->alarm, nvkm_therm_alarm);
+	spin_lock_init(&therm->lock);
+	spin_lock_init(&therm->sensor.alarm_program_lock);
 
-	priv->base.fan_get = nvkm_therm_fan_user_get;
-	priv->base.fan_set = nvkm_therm_fan_user_set;
-	priv->base.fan_sense = nvkm_therm_fan_sense;
-	priv->base.attr_get = nvkm_therm_attr_get;
-	priv->base.attr_set = nvkm_therm_attr_set;
-	priv->mode = priv->suspend = -1; /* undefined */
+	therm->base.fan_get = nvkm_therm_fan_user_get;
+	therm->base.fan_set = nvkm_therm_fan_user_set;
+	therm->base.fan_sense = nvkm_therm_fan_sense;
+	therm->base.attr_get = nvkm_therm_attr_get;
+	therm->base.attr_set = nvkm_therm_attr_set;
+	therm->mode = therm->suspend = -1; /* undefined */
 	return 0;
 }
 
@@ -359,7 +357,7 @@ nvkm_therm_preinit(struct nvkm_therm *therm)
 void
 _nvkm_therm_dtor(struct nvkm_object *object)
 {
-	struct nvkm_therm_priv *priv = (void *)object;
-	kfree(priv->fan);
-	nvkm_subdev_destroy(&priv->base.base);
+	struct nvkm_therm_priv *therm = (void *)object;
+	kfree(therm->fan);
+	nvkm_subdev_destroy(&therm->base.subdev);
 }

commit 9ace404b1098221021b01c2ba0eeea0c257fa4a5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/device: include core/device.h automatically for subdevs/engines
    
    Pretty much every subdev/engine is going to need access to nvkm_device
    shortly to touch registers and/or output messages.
    
    The odd placement of the includes is necessary to work around some
    inter-dependencies that currently exist.  This will be fixed later.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index ec327cb64a0d..eb86c3ed5f56 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -23,8 +23,6 @@
  */
 #include "priv.h"
 
-#include <core/device.h>
-
 static int
 nvkm_therm_update_trip(struct nvkm_therm *therm)
 {

commit e1404611d5f6a7c75e2b745f5eb7fbcdd23751c5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:11:48 2015 +1000

    drm/nouveau/therm: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index 67ad8ea468a9..ec327cb64a0d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -21,18 +21,14 @@
  *
  * Authors: Martin Peres
  */
+#include "priv.h"
 
-#include <core/object.h>
 #include <core/device.h>
 
-#include <subdev/bios.h>
-
-#include "priv.h"
-
 static int
-nouveau_therm_update_trip(struct nouveau_therm *therm)
+nvkm_therm_update_trip(struct nvkm_therm *therm)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *priv = (void *)therm;
 	struct nvbios_therm_trip_point *trip = priv->fan->bios.trip,
 				       *cur_trip = NULL,
 				       *last_trip = priv->last_trip;
@@ -63,9 +59,9 @@ nouveau_therm_update_trip(struct nouveau_therm *therm)
 }
 
 static int
-nouveau_therm_update_linear(struct nouveau_therm *therm)
+nvkm_therm_update_linear(struct nvkm_therm *therm)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *priv = (void *)therm;
 	u8  linear_min_temp = priv->fan->bios.linear_min_temp;
 	u8  linear_max_temp = priv->fan->bios.linear_max_temp;
 	u8  temp = therm->temp_get(therm);
@@ -82,15 +78,14 @@ nouveau_therm_update_linear(struct nouveau_therm *therm)
 	duty *= (priv->fan->bios.max_duty - priv->fan->bios.min_duty);
 	duty /= (linear_max_temp - linear_min_temp);
 	duty += priv->fan->bios.min_duty;
-
 	return duty;
 }
 
 static void
-nouveau_therm_update(struct nouveau_therm *therm, int mode)
+nvkm_therm_update(struct nvkm_therm *therm, int mode)
 {
-	struct nouveau_timer *ptimer = nouveau_timer(therm);
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_timer *ptimer = nvkm_timer(therm);
+	struct nvkm_therm_priv *priv = (void *)therm;
 	unsigned long flags;
 	bool immd = true;
 	bool poll = true;
@@ -102,20 +97,20 @@ nouveau_therm_update(struct nouveau_therm *therm, int mode)
 	priv->mode = mode;
 
 	switch (mode) {
-	case NOUVEAU_THERM_CTRL_MANUAL:
+	case NVKM_THERM_CTRL_MANUAL:
 		ptimer->alarm_cancel(ptimer, &priv->alarm);
-		duty = nouveau_therm_fan_get(therm);
+		duty = nvkm_therm_fan_get(therm);
 		if (duty < 0)
 			duty = 100;
 		poll = false;
 		break;
-	case NOUVEAU_THERM_CTRL_AUTO:
+	case NVKM_THERM_CTRL_AUTO:
 		switch(priv->fan->bios.fan_mode) {
 		case NVBIOS_THERM_FAN_TRIP:
-			duty = nouveau_therm_update_trip(therm);
+			duty = nvkm_therm_update_trip(therm);
 			break;
 		case NVBIOS_THERM_FAN_LINEAR:
-			duty = nouveau_therm_update_linear(therm);
+			duty = nvkm_therm_update_linear(therm);
 			break;
 		case NVBIOS_THERM_FAN_OTHER:
 			if (priv->cstate)
@@ -125,7 +120,7 @@ nouveau_therm_update(struct nouveau_therm *therm, int mode)
 		}
 		immd = false;
 		break;
-	case NOUVEAU_THERM_CTRL_NONE:
+	case NVKM_THERM_CTRL_NONE:
 	default:
 		ptimer->alarm_cancel(ptimer, &priv->alarm);
 		poll = false;
@@ -137,36 +132,36 @@ nouveau_therm_update(struct nouveau_therm *therm, int mode)
 
 	if (duty >= 0) {
 		nv_debug(therm, "FAN target request: %d%%\n", duty);
-		nouveau_therm_fan_set(therm, immd, duty);
+		nvkm_therm_fan_set(therm, immd, duty);
 	}
 }
 
 int
-nouveau_therm_cstate(struct nouveau_therm *ptherm, int fan, int dir)
+nvkm_therm_cstate(struct nvkm_therm *ptherm, int fan, int dir)
 {
-	struct nouveau_therm_priv *priv = (void *)ptherm;
+	struct nvkm_therm_priv *priv = (void *)ptherm;
 	if (!dir || (dir < 0 && fan < priv->cstate) ||
 		    (dir > 0 && fan > priv->cstate)) {
 		nv_debug(ptherm, "default fan speed -> %d%%\n", fan);
 		priv->cstate = fan;
-		nouveau_therm_update(ptherm, -1);
+		nvkm_therm_update(ptherm, -1);
 	}
 	return 0;
 }
 
 static void
-nouveau_therm_alarm(struct nouveau_alarm *alarm)
+nvkm_therm_alarm(struct nvkm_alarm *alarm)
 {
-	struct nouveau_therm_priv *priv =
-	       container_of(alarm, struct nouveau_therm_priv, alarm);
-	nouveau_therm_update(&priv->base, -1);
+	struct nvkm_therm_priv *priv =
+	       container_of(alarm, struct nvkm_therm_priv, alarm);
+	nvkm_therm_update(&priv->base, -1);
 }
 
 int
-nouveau_therm_fan_mode(struct nouveau_therm *therm, int mode)
+nvkm_therm_fan_mode(struct nvkm_therm *therm, int mode)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
-	struct nouveau_device *device = nv_device(therm);
+	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_device *device = nv_device(therm);
 	static const char *name[] = {
 		"disabled",
 		"manual",
@@ -175,51 +170,51 @@ nouveau_therm_fan_mode(struct nouveau_therm *therm, int mode)
 
 	/* The default PPWR ucode on fermi interferes with fan management */
 	if ((mode >= ARRAY_SIZE(name)) ||
-	    (mode != NOUVEAU_THERM_CTRL_NONE && device->card_type >= NV_C0 &&
-	     !nouveau_subdev(device, NVDEV_SUBDEV_PMU)))
+	    (mode != NVKM_THERM_CTRL_NONE && device->card_type >= NV_C0 &&
+	     !nvkm_subdev(device, NVDEV_SUBDEV_PMU)))
 		return -EINVAL;
 
 	/* do not allow automatic fan management if the thermal sensor is
 	 * not available */
-	if (mode == NOUVEAU_THERM_CTRL_AUTO && therm->temp_get(therm) < 0)
+	if (mode == NVKM_THERM_CTRL_AUTO && therm->temp_get(therm) < 0)
 		return -EINVAL;
 
 	if (priv->mode == mode)
 		return 0;
 
 	nv_info(therm, "fan management: %s\n", name[mode]);
-	nouveau_therm_update(therm, mode);
+	nvkm_therm_update(therm, mode);
 	return 0;
 }
 
 int
-nouveau_therm_attr_get(struct nouveau_therm *therm,
-		       enum nouveau_therm_attr_type type)
+nvkm_therm_attr_get(struct nvkm_therm *therm,
+		       enum nvkm_therm_attr_type type)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *priv = (void *)therm;
 
 	switch (type) {
-	case NOUVEAU_THERM_ATTR_FAN_MIN_DUTY:
+	case NVKM_THERM_ATTR_FAN_MIN_DUTY:
 		return priv->fan->bios.min_duty;
-	case NOUVEAU_THERM_ATTR_FAN_MAX_DUTY:
+	case NVKM_THERM_ATTR_FAN_MAX_DUTY:
 		return priv->fan->bios.max_duty;
-	case NOUVEAU_THERM_ATTR_FAN_MODE:
+	case NVKM_THERM_ATTR_FAN_MODE:
 		return priv->mode;
-	case NOUVEAU_THERM_ATTR_THRS_FAN_BOOST:
+	case NVKM_THERM_ATTR_THRS_FAN_BOOST:
 		return priv->bios_sensor.thrs_fan_boost.temp;
-	case NOUVEAU_THERM_ATTR_THRS_FAN_BOOST_HYST:
+	case NVKM_THERM_ATTR_THRS_FAN_BOOST_HYST:
 		return priv->bios_sensor.thrs_fan_boost.hysteresis;
-	case NOUVEAU_THERM_ATTR_THRS_DOWN_CLK:
+	case NVKM_THERM_ATTR_THRS_DOWN_CLK:
 		return priv->bios_sensor.thrs_down_clock.temp;
-	case NOUVEAU_THERM_ATTR_THRS_DOWN_CLK_HYST:
+	case NVKM_THERM_ATTR_THRS_DOWN_CLK_HYST:
 		return priv->bios_sensor.thrs_down_clock.hysteresis;
-	case NOUVEAU_THERM_ATTR_THRS_CRITICAL:
+	case NVKM_THERM_ATTR_THRS_CRITICAL:
 		return priv->bios_sensor.thrs_critical.temp;
-	case NOUVEAU_THERM_ATTR_THRS_CRITICAL_HYST:
+	case NVKM_THERM_ATTR_THRS_CRITICAL_HYST:
 		return priv->bios_sensor.thrs_critical.hysteresis;
-	case NOUVEAU_THERM_ATTR_THRS_SHUTDOWN:
+	case NVKM_THERM_ATTR_THRS_SHUTDOWN:
 		return priv->bios_sensor.thrs_shutdown.temp;
-	case NOUVEAU_THERM_ATTR_THRS_SHUTDOWN_HYST:
+	case NVKM_THERM_ATTR_THRS_SHUTDOWN_HYST:
 		return priv->bios_sensor.thrs_shutdown.hysteresis;
 	}
 
@@ -227,57 +222,57 @@ nouveau_therm_attr_get(struct nouveau_therm *therm,
 }
 
 int
-nouveau_therm_attr_set(struct nouveau_therm *therm,
-		       enum nouveau_therm_attr_type type, int value)
+nvkm_therm_attr_set(struct nvkm_therm *therm,
+		    enum nvkm_therm_attr_type type, int value)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *priv = (void *)therm;
 
 	switch (type) {
-	case NOUVEAU_THERM_ATTR_FAN_MIN_DUTY:
+	case NVKM_THERM_ATTR_FAN_MIN_DUTY:
 		if (value < 0)
 			value = 0;
 		if (value > priv->fan->bios.max_duty)
 			value = priv->fan->bios.max_duty;
 		priv->fan->bios.min_duty = value;
 		return 0;
-	case NOUVEAU_THERM_ATTR_FAN_MAX_DUTY:
+	case NVKM_THERM_ATTR_FAN_MAX_DUTY:
 		if (value < 0)
 			value = 0;
 		if (value < priv->fan->bios.min_duty)
 			value = priv->fan->bios.min_duty;
 		priv->fan->bios.max_duty = value;
 		return 0;
-	case NOUVEAU_THERM_ATTR_FAN_MODE:
-		return nouveau_therm_fan_mode(therm, value);
-	case NOUVEAU_THERM_ATTR_THRS_FAN_BOOST:
+	case NVKM_THERM_ATTR_FAN_MODE:
+		return nvkm_therm_fan_mode(therm, value);
+	case NVKM_THERM_ATTR_THRS_FAN_BOOST:
 		priv->bios_sensor.thrs_fan_boost.temp = value;
 		priv->sensor.program_alarms(therm);
 		return 0;
-	case NOUVEAU_THERM_ATTR_THRS_FAN_BOOST_HYST:
+	case NVKM_THERM_ATTR_THRS_FAN_BOOST_HYST:
 		priv->bios_sensor.thrs_fan_boost.hysteresis = value;
 		priv->sensor.program_alarms(therm);
 		return 0;
-	case NOUVEAU_THERM_ATTR_THRS_DOWN_CLK:
+	case NVKM_THERM_ATTR_THRS_DOWN_CLK:
 		priv->bios_sensor.thrs_down_clock.temp = value;
 		priv->sensor.program_alarms(therm);
 		return 0;
-	case NOUVEAU_THERM_ATTR_THRS_DOWN_CLK_HYST:
+	case NVKM_THERM_ATTR_THRS_DOWN_CLK_HYST:
 		priv->bios_sensor.thrs_down_clock.hysteresis = value;
 		priv->sensor.program_alarms(therm);
 		return 0;
-	case NOUVEAU_THERM_ATTR_THRS_CRITICAL:
+	case NVKM_THERM_ATTR_THRS_CRITICAL:
 		priv->bios_sensor.thrs_critical.temp = value;
 		priv->sensor.program_alarms(therm);
 		return 0;
-	case NOUVEAU_THERM_ATTR_THRS_CRITICAL_HYST:
+	case NVKM_THERM_ATTR_THRS_CRITICAL_HYST:
 		priv->bios_sensor.thrs_critical.hysteresis = value;
 		priv->sensor.program_alarms(therm);
 		return 0;
-	case NOUVEAU_THERM_ATTR_THRS_SHUTDOWN:
+	case NVKM_THERM_ATTR_THRS_SHUTDOWN:
 		priv->bios_sensor.thrs_shutdown.temp = value;
 		priv->sensor.program_alarms(therm);
 		return 0;
-	case NOUVEAU_THERM_ATTR_THRS_SHUTDOWN_HYST:
+	case NVKM_THERM_ATTR_THRS_SHUTDOWN_HYST:
 		priv->bios_sensor.thrs_shutdown.hysteresis = value;
 		priv->sensor.program_alarms(therm);
 		return 0;
@@ -287,88 +282,86 @@ nouveau_therm_attr_set(struct nouveau_therm *therm,
 }
 
 int
-_nouveau_therm_init(struct nouveau_object *object)
+_nvkm_therm_init(struct nvkm_object *object)
 {
-	struct nouveau_therm *therm = (void *)object;
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_therm *therm = (void *)object;
+	struct nvkm_therm_priv *priv = (void *)therm;
 	int ret;
 
-	ret = nouveau_subdev_init(&therm->base);
+	ret = nvkm_subdev_init(&therm->base);
 	if (ret)
 		return ret;
 
 	if (priv->suspend >= 0) {
 		/* restore the pwm value only when on manual or auto mode */
 		if (priv->suspend > 0)
-			nouveau_therm_fan_set(therm, true, priv->fan->percent);
+			nvkm_therm_fan_set(therm, true, priv->fan->percent);
 
-		nouveau_therm_fan_mode(therm, priv->suspend);
+		nvkm_therm_fan_mode(therm, priv->suspend);
 	}
-	nouveau_therm_sensor_init(therm);
-	nouveau_therm_fan_init(therm);
+	nvkm_therm_sensor_init(therm);
+	nvkm_therm_fan_init(therm);
 	return 0;
 }
 
 int
-_nouveau_therm_fini(struct nouveau_object *object, bool suspend)
+_nvkm_therm_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nouveau_therm *therm = (void *)object;
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_therm *therm = (void *)object;
+	struct nvkm_therm_priv *priv = (void *)therm;
 
-	nouveau_therm_fan_fini(therm, suspend);
-	nouveau_therm_sensor_fini(therm, suspend);
+	nvkm_therm_fan_fini(therm, suspend);
+	nvkm_therm_sensor_fini(therm, suspend);
 	if (suspend) {
 		priv->suspend = priv->mode;
-		priv->mode = NOUVEAU_THERM_CTRL_NONE;
+		priv->mode = NVKM_THERM_CTRL_NONE;
 	}
 
-	return nouveau_subdev_fini(&therm->base, suspend);
+	return nvkm_subdev_fini(&therm->base, suspend);
 }
 
 int
-nouveau_therm_create_(struct nouveau_object *parent,
-		      struct nouveau_object *engine,
-		      struct nouveau_oclass *oclass,
-		      int length, void **pobject)
+nvkm_therm_create_(struct nvkm_object *parent, struct nvkm_object *engine,
+		   struct nvkm_oclass *oclass, int length, void **pobject)
 {
-	struct nouveau_therm_priv *priv;
+	struct nvkm_therm_priv *priv;
 	int ret;
 
-	ret = nouveau_subdev_create_(parent, engine, oclass, 0, "PTHERM",
-				     "therm", length, pobject);
+	ret = nvkm_subdev_create_(parent, engine, oclass, 0, "PTHERM",
+				  "therm", length, pobject);
 	priv = *pobject;
 	if (ret)
 		return ret;
 
-	nouveau_alarm_init(&priv->alarm, nouveau_therm_alarm);
+	nvkm_alarm_init(&priv->alarm, nvkm_therm_alarm);
 	spin_lock_init(&priv->lock);
 	spin_lock_init(&priv->sensor.alarm_program_lock);
 
-	priv->base.fan_get = nouveau_therm_fan_user_get;
-	priv->base.fan_set = nouveau_therm_fan_user_set;
-	priv->base.fan_sense = nouveau_therm_fan_sense;
-	priv->base.attr_get = nouveau_therm_attr_get;
-	priv->base.attr_set = nouveau_therm_attr_set;
+	priv->base.fan_get = nvkm_therm_fan_user_get;
+	priv->base.fan_set = nvkm_therm_fan_user_set;
+	priv->base.fan_sense = nvkm_therm_fan_sense;
+	priv->base.attr_get = nvkm_therm_attr_get;
+	priv->base.attr_set = nvkm_therm_attr_set;
 	priv->mode = priv->suspend = -1; /* undefined */
 	return 0;
 }
 
 int
-nouveau_therm_preinit(struct nouveau_therm *therm)
+nvkm_therm_preinit(struct nvkm_therm *therm)
 {
-	nouveau_therm_sensor_ctor(therm);
-	nouveau_therm_ic_ctor(therm);
-	nouveau_therm_fan_ctor(therm);
+	nvkm_therm_sensor_ctor(therm);
+	nvkm_therm_ic_ctor(therm);
+	nvkm_therm_fan_ctor(therm);
 
-	nouveau_therm_fan_mode(therm, NOUVEAU_THERM_CTRL_AUTO);
-	nouveau_therm_sensor_preinit(therm);
+	nvkm_therm_fan_mode(therm, NVKM_THERM_CTRL_AUTO);
+	nvkm_therm_sensor_preinit(therm);
 	return 0;
 }
 
 void
-_nouveau_therm_dtor(struct nouveau_object *object)
+_nvkm_therm_dtor(struct nvkm_object *object)
 {
-	struct nouveau_therm_priv *priv = (void *)object;
+	struct nvkm_therm_priv *priv = (void *)object;
 	kfree(priv->fan);
-	nouveau_subdev_destroy(&priv->base.base);
+	nvkm_subdev_destroy(&priv->base.base);
 }

commit d390b48027f886c9b8c60a4578044958f517047d
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 14:40:03 2015 +1000

    drm/nouveau/bios: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index 7d4bfd8d5b93..67ad8ea468a9 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -33,9 +33,9 @@ static int
 nouveau_therm_update_trip(struct nouveau_therm *therm)
 {
 	struct nouveau_therm_priv *priv = (void *)therm;
-	struct nouveau_therm_trip_point *trip = priv->fan->bios.trip,
-					*cur_trip = NULL,
-					*last_trip = priv->last_trip;
+	struct nvbios_therm_trip_point *trip = priv->fan->bios.trip,
+				       *cur_trip = NULL,
+				       *last_trip = priv->last_trip;
 	u8  temp = therm->temp_get(therm);
 	u16 duty, i;
 

commit ebb58dc2ef8c62d1affa28160f57faa7b0e1dc02
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 00:04:21 2015 +1000

    drm/nouveau/pmu: rename from pwr (no binary change)
    
    Switch to NVIDIA's name for the device.
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
index 9ad01da6eacb..7d4bfd8d5b93 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -176,7 +176,7 @@ nouveau_therm_fan_mode(struct nouveau_therm *therm, int mode)
 	/* The default PPWR ucode on fermi interferes with fan management */
 	if ((mode >= ARRAY_SIZE(name)) ||
 	    (mode != NOUVEAU_THERM_CTRL_NONE && device->card_type >= NV_C0 &&
-	     !nouveau_subdev(device, NVDEV_SUBDEV_PWR)))
+	     !nouveau_subdev(device, NVDEV_SUBDEV_PMU)))
 		return -EINVAL;
 
 	/* do not allow automatic fan management if the thermal sensor is

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
new file mode 100644
index 000000000000..9ad01da6eacb
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c
@@ -0,0 +1,374 @@
+/*
+ * Copyright 2012 The Nouveau community
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Martin Peres
+ */
+
+#include <core/object.h>
+#include <core/device.h>
+
+#include <subdev/bios.h>
+
+#include "priv.h"
+
+static int
+nouveau_therm_update_trip(struct nouveau_therm *therm)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nouveau_therm_trip_point *trip = priv->fan->bios.trip,
+					*cur_trip = NULL,
+					*last_trip = priv->last_trip;
+	u8  temp = therm->temp_get(therm);
+	u16 duty, i;
+
+	/* look for the trip point corresponding to the current temperature */
+	cur_trip = NULL;
+	for (i = 0; i < priv->fan->bios.nr_fan_trip; i++) {
+		if (temp >= trip[i].temp)
+			cur_trip = &trip[i];
+	}
+
+	/* account for the hysteresis cycle */
+	if (last_trip && temp <= (last_trip->temp) &&
+	    temp > (last_trip->temp - last_trip->hysteresis))
+		cur_trip = last_trip;
+
+	if (cur_trip) {
+		duty = cur_trip->fan_duty;
+		priv->last_trip = cur_trip;
+	} else {
+		duty = 0;
+		priv->last_trip = NULL;
+	}
+
+	return duty;
+}
+
+static int
+nouveau_therm_update_linear(struct nouveau_therm *therm)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	u8  linear_min_temp = priv->fan->bios.linear_min_temp;
+	u8  linear_max_temp = priv->fan->bios.linear_max_temp;
+	u8  temp = therm->temp_get(therm);
+	u16 duty;
+
+	/* handle the non-linear part first */
+	if (temp < linear_min_temp)
+		return priv->fan->bios.min_duty;
+	else if (temp > linear_max_temp)
+		return priv->fan->bios.max_duty;
+
+	/* we are in the linear zone */
+	duty  = (temp - linear_min_temp);
+	duty *= (priv->fan->bios.max_duty - priv->fan->bios.min_duty);
+	duty /= (linear_max_temp - linear_min_temp);
+	duty += priv->fan->bios.min_duty;
+
+	return duty;
+}
+
+static void
+nouveau_therm_update(struct nouveau_therm *therm, int mode)
+{
+	struct nouveau_timer *ptimer = nouveau_timer(therm);
+	struct nouveau_therm_priv *priv = (void *)therm;
+	unsigned long flags;
+	bool immd = true;
+	bool poll = true;
+	int duty = -1;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	if (mode < 0)
+		mode = priv->mode;
+	priv->mode = mode;
+
+	switch (mode) {
+	case NOUVEAU_THERM_CTRL_MANUAL:
+		ptimer->alarm_cancel(ptimer, &priv->alarm);
+		duty = nouveau_therm_fan_get(therm);
+		if (duty < 0)
+			duty = 100;
+		poll = false;
+		break;
+	case NOUVEAU_THERM_CTRL_AUTO:
+		switch(priv->fan->bios.fan_mode) {
+		case NVBIOS_THERM_FAN_TRIP:
+			duty = nouveau_therm_update_trip(therm);
+			break;
+		case NVBIOS_THERM_FAN_LINEAR:
+			duty = nouveau_therm_update_linear(therm);
+			break;
+		case NVBIOS_THERM_FAN_OTHER:
+			if (priv->cstate)
+				duty = priv->cstate;
+			poll = false;
+			break;
+		}
+		immd = false;
+		break;
+	case NOUVEAU_THERM_CTRL_NONE:
+	default:
+		ptimer->alarm_cancel(ptimer, &priv->alarm);
+		poll = false;
+	}
+
+	if (list_empty(&priv->alarm.head) && poll)
+		ptimer->alarm(ptimer, 1000000000ULL, &priv->alarm);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	if (duty >= 0) {
+		nv_debug(therm, "FAN target request: %d%%\n", duty);
+		nouveau_therm_fan_set(therm, immd, duty);
+	}
+}
+
+int
+nouveau_therm_cstate(struct nouveau_therm *ptherm, int fan, int dir)
+{
+	struct nouveau_therm_priv *priv = (void *)ptherm;
+	if (!dir || (dir < 0 && fan < priv->cstate) ||
+		    (dir > 0 && fan > priv->cstate)) {
+		nv_debug(ptherm, "default fan speed -> %d%%\n", fan);
+		priv->cstate = fan;
+		nouveau_therm_update(ptherm, -1);
+	}
+	return 0;
+}
+
+static void
+nouveau_therm_alarm(struct nouveau_alarm *alarm)
+{
+	struct nouveau_therm_priv *priv =
+	       container_of(alarm, struct nouveau_therm_priv, alarm);
+	nouveau_therm_update(&priv->base, -1);
+}
+
+int
+nouveau_therm_fan_mode(struct nouveau_therm *therm, int mode)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nouveau_device *device = nv_device(therm);
+	static const char *name[] = {
+		"disabled",
+		"manual",
+		"automatic"
+	};
+
+	/* The default PPWR ucode on fermi interferes with fan management */
+	if ((mode >= ARRAY_SIZE(name)) ||
+	    (mode != NOUVEAU_THERM_CTRL_NONE && device->card_type >= NV_C0 &&
+	     !nouveau_subdev(device, NVDEV_SUBDEV_PWR)))
+		return -EINVAL;
+
+	/* do not allow automatic fan management if the thermal sensor is
+	 * not available */
+	if (mode == NOUVEAU_THERM_CTRL_AUTO && therm->temp_get(therm) < 0)
+		return -EINVAL;
+
+	if (priv->mode == mode)
+		return 0;
+
+	nv_info(therm, "fan management: %s\n", name[mode]);
+	nouveau_therm_update(therm, mode);
+	return 0;
+}
+
+int
+nouveau_therm_attr_get(struct nouveau_therm *therm,
+		       enum nouveau_therm_attr_type type)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+
+	switch (type) {
+	case NOUVEAU_THERM_ATTR_FAN_MIN_DUTY:
+		return priv->fan->bios.min_duty;
+	case NOUVEAU_THERM_ATTR_FAN_MAX_DUTY:
+		return priv->fan->bios.max_duty;
+	case NOUVEAU_THERM_ATTR_FAN_MODE:
+		return priv->mode;
+	case NOUVEAU_THERM_ATTR_THRS_FAN_BOOST:
+		return priv->bios_sensor.thrs_fan_boost.temp;
+	case NOUVEAU_THERM_ATTR_THRS_FAN_BOOST_HYST:
+		return priv->bios_sensor.thrs_fan_boost.hysteresis;
+	case NOUVEAU_THERM_ATTR_THRS_DOWN_CLK:
+		return priv->bios_sensor.thrs_down_clock.temp;
+	case NOUVEAU_THERM_ATTR_THRS_DOWN_CLK_HYST:
+		return priv->bios_sensor.thrs_down_clock.hysteresis;
+	case NOUVEAU_THERM_ATTR_THRS_CRITICAL:
+		return priv->bios_sensor.thrs_critical.temp;
+	case NOUVEAU_THERM_ATTR_THRS_CRITICAL_HYST:
+		return priv->bios_sensor.thrs_critical.hysteresis;
+	case NOUVEAU_THERM_ATTR_THRS_SHUTDOWN:
+		return priv->bios_sensor.thrs_shutdown.temp;
+	case NOUVEAU_THERM_ATTR_THRS_SHUTDOWN_HYST:
+		return priv->bios_sensor.thrs_shutdown.hysteresis;
+	}
+
+	return -EINVAL;
+}
+
+int
+nouveau_therm_attr_set(struct nouveau_therm *therm,
+		       enum nouveau_therm_attr_type type, int value)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+
+	switch (type) {
+	case NOUVEAU_THERM_ATTR_FAN_MIN_DUTY:
+		if (value < 0)
+			value = 0;
+		if (value > priv->fan->bios.max_duty)
+			value = priv->fan->bios.max_duty;
+		priv->fan->bios.min_duty = value;
+		return 0;
+	case NOUVEAU_THERM_ATTR_FAN_MAX_DUTY:
+		if (value < 0)
+			value = 0;
+		if (value < priv->fan->bios.min_duty)
+			value = priv->fan->bios.min_duty;
+		priv->fan->bios.max_duty = value;
+		return 0;
+	case NOUVEAU_THERM_ATTR_FAN_MODE:
+		return nouveau_therm_fan_mode(therm, value);
+	case NOUVEAU_THERM_ATTR_THRS_FAN_BOOST:
+		priv->bios_sensor.thrs_fan_boost.temp = value;
+		priv->sensor.program_alarms(therm);
+		return 0;
+	case NOUVEAU_THERM_ATTR_THRS_FAN_BOOST_HYST:
+		priv->bios_sensor.thrs_fan_boost.hysteresis = value;
+		priv->sensor.program_alarms(therm);
+		return 0;
+	case NOUVEAU_THERM_ATTR_THRS_DOWN_CLK:
+		priv->bios_sensor.thrs_down_clock.temp = value;
+		priv->sensor.program_alarms(therm);
+		return 0;
+	case NOUVEAU_THERM_ATTR_THRS_DOWN_CLK_HYST:
+		priv->bios_sensor.thrs_down_clock.hysteresis = value;
+		priv->sensor.program_alarms(therm);
+		return 0;
+	case NOUVEAU_THERM_ATTR_THRS_CRITICAL:
+		priv->bios_sensor.thrs_critical.temp = value;
+		priv->sensor.program_alarms(therm);
+		return 0;
+	case NOUVEAU_THERM_ATTR_THRS_CRITICAL_HYST:
+		priv->bios_sensor.thrs_critical.hysteresis = value;
+		priv->sensor.program_alarms(therm);
+		return 0;
+	case NOUVEAU_THERM_ATTR_THRS_SHUTDOWN:
+		priv->bios_sensor.thrs_shutdown.temp = value;
+		priv->sensor.program_alarms(therm);
+		return 0;
+	case NOUVEAU_THERM_ATTR_THRS_SHUTDOWN_HYST:
+		priv->bios_sensor.thrs_shutdown.hysteresis = value;
+		priv->sensor.program_alarms(therm);
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+int
+_nouveau_therm_init(struct nouveau_object *object)
+{
+	struct nouveau_therm *therm = (void *)object;
+	struct nouveau_therm_priv *priv = (void *)therm;
+	int ret;
+
+	ret = nouveau_subdev_init(&therm->base);
+	if (ret)
+		return ret;
+
+	if (priv->suspend >= 0) {
+		/* restore the pwm value only when on manual or auto mode */
+		if (priv->suspend > 0)
+			nouveau_therm_fan_set(therm, true, priv->fan->percent);
+
+		nouveau_therm_fan_mode(therm, priv->suspend);
+	}
+	nouveau_therm_sensor_init(therm);
+	nouveau_therm_fan_init(therm);
+	return 0;
+}
+
+int
+_nouveau_therm_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nouveau_therm *therm = (void *)object;
+	struct nouveau_therm_priv *priv = (void *)therm;
+
+	nouveau_therm_fan_fini(therm, suspend);
+	nouveau_therm_sensor_fini(therm, suspend);
+	if (suspend) {
+		priv->suspend = priv->mode;
+		priv->mode = NOUVEAU_THERM_CTRL_NONE;
+	}
+
+	return nouveau_subdev_fini(&therm->base, suspend);
+}
+
+int
+nouveau_therm_create_(struct nouveau_object *parent,
+		      struct nouveau_object *engine,
+		      struct nouveau_oclass *oclass,
+		      int length, void **pobject)
+{
+	struct nouveau_therm_priv *priv;
+	int ret;
+
+	ret = nouveau_subdev_create_(parent, engine, oclass, 0, "PTHERM",
+				     "therm", length, pobject);
+	priv = *pobject;
+	if (ret)
+		return ret;
+
+	nouveau_alarm_init(&priv->alarm, nouveau_therm_alarm);
+	spin_lock_init(&priv->lock);
+	spin_lock_init(&priv->sensor.alarm_program_lock);
+
+	priv->base.fan_get = nouveau_therm_fan_user_get;
+	priv->base.fan_set = nouveau_therm_fan_user_set;
+	priv->base.fan_sense = nouveau_therm_fan_sense;
+	priv->base.attr_get = nouveau_therm_attr_get;
+	priv->base.attr_set = nouveau_therm_attr_set;
+	priv->mode = priv->suspend = -1; /* undefined */
+	return 0;
+}
+
+int
+nouveau_therm_preinit(struct nouveau_therm *therm)
+{
+	nouveau_therm_sensor_ctor(therm);
+	nouveau_therm_ic_ctor(therm);
+	nouveau_therm_fan_ctor(therm);
+
+	nouveau_therm_fan_mode(therm, NOUVEAU_THERM_CTRL_AUTO);
+	nouveau_therm_sensor_preinit(therm);
+	return 0;
+}
+
+void
+_nouveau_therm_dtor(struct nouveau_object *object)
+{
+	struct nouveau_therm_priv *priv = (void *)object;
+	kfree(priv->fan);
+	nouveau_subdev_destroy(&priv->base.base);
+}
