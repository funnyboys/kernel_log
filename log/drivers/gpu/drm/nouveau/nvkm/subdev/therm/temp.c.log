commit 4a84a6fd9a50e4a10dccaaff9cf9e12d04f2c83f
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Jun 27 09:08:58 2017 +0100

    drm/nouveau/therm: fix spelling mistake on array thresolds
    
    Array thresolds should be named thresholds, rename it. Also make it static
    static const char * const
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
index e93b2410c38b..ddb2b2c600ca 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
@@ -83,7 +83,7 @@ nvkm_therm_sensor_event(struct nvkm_therm *therm, enum nvkm_therm_thrs thrs,
 {
 	struct nvkm_subdev *subdev = &therm->subdev;
 	bool active;
-	const char *thresolds[] = {
+	static const char * const thresholds[] = {
 		"fanboost", "downclock", "critical", "shutdown"
 	};
 	int temperature = therm->func->temp_get(therm);
@@ -94,10 +94,10 @@ nvkm_therm_sensor_event(struct nvkm_therm *therm, enum nvkm_therm_thrs thrs,
 	if (dir == NVKM_THERM_THRS_FALLING)
 		nvkm_info(subdev,
 			  "temperature (%i C) went below the '%s' threshold\n",
-			  temperature, thresolds[thrs]);
+			  temperature, thresholds[thrs]);
 	else
 		nvkm_info(subdev, "temperature (%i C) hit the '%s' threshold\n",
-			  temperature, thresolds[thrs]);
+			  temperature, thresholds[thrs]);
 
 	active = (dir == NVKM_THERM_THRS_RISING);
 	switch (thrs) {

commit 7eaf1198a9aaa9c31c9270e370088d8a79c149ab
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu May 11 17:29:58 2017 +1000

    drm/nouveau/tmr: remove nvkm_timer_alarm_cancel()
    
    nvkm_timer_alarm() already handles this as part of protecting against
    callers passing in no timeout value.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
index 9a79e91fdfdc..e93b2410c38b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
@@ -220,7 +220,7 @@ nvkm_therm_sensor_fini(struct nvkm_therm *therm, bool suspend)
 {
 	struct nvkm_timer *tmr = therm->subdev.device->timer;
 	if (suspend)
-		nvkm_timer_alarm_cancel(tmr, &therm->sensor.therm_poll_alarm);
+		nvkm_timer_alarm(tmr, 0, &therm->sensor.therm_poll_alarm);
 	return 0;
 }
 

commit e4311ee51d1e2676001b2d8fcefd92bdd79aad85
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu May 11 17:33:39 2017 +1000

    drm/nouveau/therm: remove ineffective workarounds for alarm bugs
    
    These were ineffective due to touching the list without the alarm lock,
    but should no longer be required.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
index b9703c02d8ca..9a79e91fdfdc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
@@ -185,7 +185,7 @@ alarm_timer_callback(struct nvkm_alarm *alarm)
 	spin_unlock_irqrestore(&therm->sensor.alarm_program_lock, flags);
 
 	/* schedule the next poll in one second */
-	if (therm->func->temp_get(therm) >= 0 && list_empty(&alarm->head))
+	if (therm->func->temp_get(therm) >= 0)
 		nvkm_timer_alarm(tmr, 1000000000ULL, alarm);
 }
 

commit 31649ecf47a44e02e73bffc5680c8f56d6cf587a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:21 2015 +1000

    drm/nouveau/tmr: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
index 4ab7ef7da254..b9703c02d8ca 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
@@ -186,7 +186,7 @@ alarm_timer_callback(struct nvkm_alarm *alarm)
 
 	/* schedule the next poll in one second */
 	if (therm->func->temp_get(therm) >= 0 && list_empty(&alarm->head))
-		tmr->alarm(tmr, 1000000000ULL, alarm);
+		nvkm_timer_alarm(tmr, 1000000000ULL, alarm);
 }
 
 void
@@ -220,7 +220,7 @@ nvkm_therm_sensor_fini(struct nvkm_therm *therm, bool suspend)
 {
 	struct nvkm_timer *tmr = therm->subdev.device->timer;
 	if (suspend)
-		tmr->alarm_cancel(tmr, &therm->sensor.therm_poll_alarm);
+		nvkm_timer_alarm_cancel(tmr, &therm->sensor.therm_poll_alarm);
 	return 0;
 }
 

commit 57113c0170b9efeacb3e3e9d4c2178c30d9cd991
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:21 2015 +1000

    drm/nouveau/therm: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
index 2622c4403a73..4ab7ef7da254 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
@@ -24,10 +24,8 @@
 #include "priv.h"
 
 static void
-nvkm_therm_temp_set_defaults(struct nvkm_therm *obj)
+nvkm_therm_temp_set_defaults(struct nvkm_therm *therm)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-
 	therm->bios_sensor.offset_constant = 0;
 
 	therm->bios_sensor.thrs_fan_boost.temp = 90;
@@ -43,11 +41,9 @@ nvkm_therm_temp_set_defaults(struct nvkm_therm *obj)
 	therm->bios_sensor.thrs_shutdown.hysteresis = 5; /*not that it matters */
 }
 
-
 static void
-nvkm_therm_temp_safety_checks(struct nvkm_therm *obj)
+nvkm_therm_temp_safety_checks(struct nvkm_therm *therm)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 	struct nvbios_therm_sensor *s = &therm->bios_sensor;
 
 	/* enforce a minimum hysteresis on thresholds */
@@ -59,20 +55,18 @@ nvkm_therm_temp_safety_checks(struct nvkm_therm *obj)
 
 /* must be called with alarm_program_lock taken ! */
 void
-nvkm_therm_sensor_set_threshold_state(struct nvkm_therm *obj,
+nvkm_therm_sensor_set_threshold_state(struct nvkm_therm *therm,
 				      enum nvkm_therm_thrs thrs,
 				      enum nvkm_therm_thrs_state st)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 	therm->sensor.alarm_state[thrs] = st;
 }
 
 /* must be called with alarm_program_lock taken ! */
 enum nvkm_therm_thrs_state
-nvkm_therm_sensor_get_threshold_state(struct nvkm_therm *obj,
+nvkm_therm_sensor_get_threshold_state(struct nvkm_therm *therm,
 				      enum nvkm_therm_thrs thrs)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 	return therm->sensor.alarm_state[thrs];
 }
 
@@ -84,16 +78,15 @@ nv_poweroff_work(struct work_struct *work)
 }
 
 void
-nvkm_therm_sensor_event(struct nvkm_therm *obj, enum nvkm_therm_thrs thrs,
+nvkm_therm_sensor_event(struct nvkm_therm *therm, enum nvkm_therm_thrs thrs,
 			enum nvkm_therm_thrs_direction dir)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	struct nvkm_subdev *subdev = &therm->base.subdev;
+	struct nvkm_subdev *subdev = &therm->subdev;
 	bool active;
 	const char *thresolds[] = {
 		"fanboost", "downclock", "critical", "shutdown"
 	};
-	int temperature = therm->base.temp_get(&therm->base);
+	int temperature = therm->func->temp_get(therm);
 
 	if (thrs < 0 || thrs > 3)
 		return;
@@ -110,17 +103,17 @@ nvkm_therm_sensor_event(struct nvkm_therm *obj, enum nvkm_therm_thrs thrs,
 	switch (thrs) {
 	case NVKM_THERM_THRS_FANBOOST:
 		if (active) {
-			nvkm_therm_fan_set(&therm->base, true, 100);
-			nvkm_therm_fan_mode(&therm->base, NVKM_THERM_CTRL_AUTO);
+			nvkm_therm_fan_set(therm, true, 100);
+			nvkm_therm_fan_mode(therm, NVKM_THERM_CTRL_AUTO);
 		}
 		break;
 	case NVKM_THERM_THRS_DOWNCLOCK:
 		if (therm->emergency.downclock)
-			therm->emergency.downclock(&therm->base, active);
+			therm->emergency.downclock(therm, active);
 		break;
 	case NVKM_THERM_THRS_CRITICAL:
 		if (therm->emergency.pause)
-			therm->emergency.pause(&therm->base, active);
+			therm->emergency.pause(therm, active);
 		break;
 	case NVKM_THERM_THRS_SHUTDOWN:
 		if (active) {
@@ -147,7 +140,7 @@ nvkm_therm_threshold_hyst_polling(struct nvkm_therm *therm,
 {
 	enum nvkm_therm_thrs_direction direction;
 	enum nvkm_therm_thrs_state prev_state, new_state;
-	int temp = therm->temp_get(therm);
+	int temp = therm->func->temp_get(therm);
 
 	prev_state = nvkm_therm_sensor_get_threshold_state(therm, thrs_name);
 
@@ -168,41 +161,40 @@ nvkm_therm_threshold_hyst_polling(struct nvkm_therm *therm,
 static void
 alarm_timer_callback(struct nvkm_alarm *alarm)
 {
-	struct nvkm_therm_priv *therm =
-	container_of(alarm, struct nvkm_therm_priv, sensor.therm_poll_alarm);
+	struct nvkm_therm *therm =
+		container_of(alarm, struct nvkm_therm, sensor.therm_poll_alarm);
 	struct nvbios_therm_sensor *sensor = &therm->bios_sensor;
-	struct nvkm_timer *tmr = nvkm_timer(therm);
+	struct nvkm_timer *tmr = therm->subdev.device->timer;
 	unsigned long flags;
 
 	spin_lock_irqsave(&therm->sensor.alarm_program_lock, flags);
 
-	nvkm_therm_threshold_hyst_polling(&therm->base, &sensor->thrs_fan_boost,
+	nvkm_therm_threshold_hyst_polling(therm, &sensor->thrs_fan_boost,
 					  NVKM_THERM_THRS_FANBOOST);
 
-	nvkm_therm_threshold_hyst_polling(&therm->base,
+	nvkm_therm_threshold_hyst_polling(therm,
 					  &sensor->thrs_down_clock,
 					  NVKM_THERM_THRS_DOWNCLOCK);
 
-	nvkm_therm_threshold_hyst_polling(&therm->base, &sensor->thrs_critical,
+	nvkm_therm_threshold_hyst_polling(therm, &sensor->thrs_critical,
 					  NVKM_THERM_THRS_CRITICAL);
 
-	nvkm_therm_threshold_hyst_polling(&therm->base, &sensor->thrs_shutdown,
+	nvkm_therm_threshold_hyst_polling(therm, &sensor->thrs_shutdown,
 					  NVKM_THERM_THRS_SHUTDOWN);
 
 	spin_unlock_irqrestore(&therm->sensor.alarm_program_lock, flags);
 
 	/* schedule the next poll in one second */
-	if (therm->base.temp_get(&therm->base) >= 0 && list_empty(&alarm->head))
+	if (therm->func->temp_get(therm) >= 0 && list_empty(&alarm->head))
 		tmr->alarm(tmr, 1000000000ULL, alarm);
 }
 
 void
-nvkm_therm_program_alarms_polling(struct nvkm_therm *obj)
+nvkm_therm_program_alarms_polling(struct nvkm_therm *therm)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 	struct nvbios_therm_sensor *sensor = &therm->bios_sensor;
 
-	nvkm_debug(&therm->base.subdev,
+	nvkm_debug(&therm->subdev,
 		   "programmed thresholds [ %d(%d), %d(%d), %d(%d), %d(%d) ]\n",
 		   sensor->thrs_fan_boost.temp,
 		   sensor->thrs_fan_boost.hysteresis,
@@ -217,19 +209,16 @@ nvkm_therm_program_alarms_polling(struct nvkm_therm *obj)
 }
 
 int
-nvkm_therm_sensor_init(struct nvkm_therm *obj)
+nvkm_therm_sensor_init(struct nvkm_therm *therm)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	therm->sensor.program_alarms(&therm->base);
+	therm->func->program_alarms(therm);
 	return 0;
 }
 
 int
-nvkm_therm_sensor_fini(struct nvkm_therm *obj, bool suspend)
+nvkm_therm_sensor_fini(struct nvkm_therm *therm, bool suspend)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	struct nvkm_timer *tmr = nvkm_timer(therm);
-
+	struct nvkm_timer *tmr = therm->subdev.device->timer;
 	if (suspend)
 		tmr->alarm_cancel(tmr, &therm->sensor.therm_poll_alarm);
 	return 0;
@@ -240,26 +229,25 @@ nvkm_therm_sensor_preinit(struct nvkm_therm *therm)
 {
 	const char *sensor_avail = "yes";
 
-	if (therm->temp_get(therm) < 0)
+	if (therm->func->temp_get(therm) < 0)
 		sensor_avail = "no";
 
 	nvkm_debug(&therm->subdev, "internal sensor: %s\n", sensor_avail);
 }
 
 int
-nvkm_therm_sensor_ctor(struct nvkm_therm *obj)
+nvkm_therm_sensor_ctor(struct nvkm_therm *therm)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	struct nvkm_subdev *subdev = &therm->base.subdev;
+	struct nvkm_subdev *subdev = &therm->subdev;
 	struct nvkm_bios *bios = subdev->device->bios;
 
 	nvkm_alarm_init(&therm->sensor.therm_poll_alarm, alarm_timer_callback);
 
-	nvkm_therm_temp_set_defaults(&therm->base);
+	nvkm_therm_temp_set_defaults(therm);
 	if (nvbios_therm_sensor_parse(bios, NVBIOS_THERM_DOMAIN_CORE,
 				      &therm->bios_sensor))
 		nvkm_error(subdev, "nvbios_therm_sensor_parse failed\n");
-	nvkm_therm_temp_safety_checks(&therm->base);
+	nvkm_therm_temp_safety_checks(therm);
 
 	return 0;
 }

commit 46484438ab7dbab6ed29cf647d029e0b1ef3d9d8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/bios: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
index b346f3a0ff11..2622c4403a73 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
@@ -251,7 +251,7 @@ nvkm_therm_sensor_ctor(struct nvkm_therm *obj)
 {
 	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 	struct nvkm_subdev *subdev = &therm->base.subdev;
-	struct nvkm_bios *bios = nvkm_bios(therm);
+	struct nvkm_bios *bios = subdev->device->bios;
 
 	nvkm_alarm_init(&therm->sensor.therm_poll_alarm, alarm_timer_callback);
 

commit b3c418bb48228a206a8c421adaf269cdc83c3c52
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:12 2015 +1000

    drm/nouveau/therm: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
index 41628de3bf6c..b346f3a0ff11 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
@@ -88,6 +88,7 @@ nvkm_therm_sensor_event(struct nvkm_therm *obj, enum nvkm_therm_thrs thrs,
 			enum nvkm_therm_thrs_direction dir)
 {
 	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
+	struct nvkm_subdev *subdev = &therm->base.subdev;
 	bool active;
 	const char *thresolds[] = {
 		"fanboost", "downclock", "critical", "shutdown"
@@ -98,11 +99,12 @@ nvkm_therm_sensor_event(struct nvkm_therm *obj, enum nvkm_therm_thrs thrs,
 		return;
 
 	if (dir == NVKM_THERM_THRS_FALLING)
-		nv_info(therm, "temperature (%i C) went below the '%s' threshold\n",
-			temperature, thresolds[thrs]);
+		nvkm_info(subdev,
+			  "temperature (%i C) went below the '%s' threshold\n",
+			  temperature, thresolds[thrs]);
 	else
-		nv_info(therm, "temperature (%i C) hit the '%s' threshold\n",
-			temperature, thresolds[thrs]);
+		nvkm_info(subdev, "temperature (%i C) hit the '%s' threshold\n",
+			  temperature, thresolds[thrs]);
 
 	active = (dir == NVKM_THERM_THRS_RISING);
 	switch (thrs) {
@@ -200,13 +202,16 @@ nvkm_therm_program_alarms_polling(struct nvkm_therm *obj)
 	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 	struct nvbios_therm_sensor *sensor = &therm->bios_sensor;
 
-	nv_debug(therm,
-		 "programmed thresholds [ %d(%d), %d(%d), %d(%d), %d(%d) ]\n",
-		 sensor->thrs_fan_boost.temp, sensor->thrs_fan_boost.hysteresis,
-		 sensor->thrs_down_clock.temp,
-		 sensor->thrs_down_clock.hysteresis,
-		 sensor->thrs_critical.temp, sensor->thrs_critical.hysteresis,
-		 sensor->thrs_shutdown.temp, sensor->thrs_shutdown.hysteresis);
+	nvkm_debug(&therm->base.subdev,
+		   "programmed thresholds [ %d(%d), %d(%d), %d(%d), %d(%d) ]\n",
+		   sensor->thrs_fan_boost.temp,
+		   sensor->thrs_fan_boost.hysteresis,
+		   sensor->thrs_down_clock.temp,
+		   sensor->thrs_down_clock.hysteresis,
+		   sensor->thrs_critical.temp,
+		   sensor->thrs_critical.hysteresis,
+		   sensor->thrs_shutdown.temp,
+		   sensor->thrs_shutdown.hysteresis);
 
 	alarm_timer_callback(&therm->sensor.therm_poll_alarm);
 }
@@ -238,13 +243,14 @@ nvkm_therm_sensor_preinit(struct nvkm_therm *therm)
 	if (therm->temp_get(therm) < 0)
 		sensor_avail = "no";
 
-	nv_info(therm, "internal sensor: %s\n", sensor_avail);
+	nvkm_debug(&therm->subdev, "internal sensor: %s\n", sensor_avail);
 }
 
 int
 nvkm_therm_sensor_ctor(struct nvkm_therm *obj)
 {
 	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
+	struct nvkm_subdev *subdev = &therm->base.subdev;
 	struct nvkm_bios *bios = nvkm_bios(therm);
 
 	nvkm_alarm_init(&therm->sensor.therm_poll_alarm, alarm_timer_callback);
@@ -252,7 +258,7 @@ nvkm_therm_sensor_ctor(struct nvkm_therm *obj)
 	nvkm_therm_temp_set_defaults(&therm->base);
 	if (nvbios_therm_sensor_parse(bios, NVBIOS_THERM_DOMAIN_CORE,
 				      &therm->bios_sensor))
-		nv_error(therm, "nvbios_therm_sensor_parse failed\n");
+		nvkm_error(subdev, "nvbios_therm_sensor_parse failed\n");
 	nvkm_therm_temp_safety_checks(&therm->base);
 
 	return 0;

commit cb8bb9cedb6015eafd56ef9e9c5b2c216e8e7960
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/tmr: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
index a6f46ed0e2ae..41628de3bf6c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
@@ -169,7 +169,7 @@ alarm_timer_callback(struct nvkm_alarm *alarm)
 	struct nvkm_therm_priv *therm =
 	container_of(alarm, struct nvkm_therm_priv, sensor.therm_poll_alarm);
 	struct nvbios_therm_sensor *sensor = &therm->bios_sensor;
-	struct nvkm_timer *ptimer = nvkm_timer(therm);
+	struct nvkm_timer *tmr = nvkm_timer(therm);
 	unsigned long flags;
 
 	spin_lock_irqsave(&therm->sensor.alarm_program_lock, flags);
@@ -191,7 +191,7 @@ alarm_timer_callback(struct nvkm_alarm *alarm)
 
 	/* schedule the next poll in one second */
 	if (therm->base.temp_get(&therm->base) >= 0 && list_empty(&alarm->head))
-		ptimer->alarm(ptimer, 1000000000ULL, alarm);
+		tmr->alarm(tmr, 1000000000ULL, alarm);
 }
 
 void
@@ -223,10 +223,10 @@ int
 nvkm_therm_sensor_fini(struct nvkm_therm *obj, bool suspend)
 {
 	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	struct nvkm_timer *ptimer = nvkm_timer(therm);
+	struct nvkm_timer *tmr = nvkm_timer(therm);
 
 	if (suspend)
-		ptimer->alarm_cancel(ptimer, &therm->sensor.therm_poll_alarm);
+		tmr->alarm_cancel(tmr, &therm->sensor.therm_poll_alarm);
 	return 0;
 }
 

commit da06b46b720687117178d3ee85a601762f1c36b5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/therm: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
index aa13744f3854..a6f46ed0e2ae 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
@@ -24,31 +24,31 @@
 #include "priv.h"
 
 static void
-nvkm_therm_temp_set_defaults(struct nvkm_therm *therm)
+nvkm_therm_temp_set_defaults(struct nvkm_therm *obj)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 
-	priv->bios_sensor.offset_constant = 0;
+	therm->bios_sensor.offset_constant = 0;
 
-	priv->bios_sensor.thrs_fan_boost.temp = 90;
-	priv->bios_sensor.thrs_fan_boost.hysteresis = 3;
+	therm->bios_sensor.thrs_fan_boost.temp = 90;
+	therm->bios_sensor.thrs_fan_boost.hysteresis = 3;
 
-	priv->bios_sensor.thrs_down_clock.temp = 95;
-	priv->bios_sensor.thrs_down_clock.hysteresis = 3;
+	therm->bios_sensor.thrs_down_clock.temp = 95;
+	therm->bios_sensor.thrs_down_clock.hysteresis = 3;
 
-	priv->bios_sensor.thrs_critical.temp = 105;
-	priv->bios_sensor.thrs_critical.hysteresis = 5;
+	therm->bios_sensor.thrs_critical.temp = 105;
+	therm->bios_sensor.thrs_critical.hysteresis = 5;
 
-	priv->bios_sensor.thrs_shutdown.temp = 135;
-	priv->bios_sensor.thrs_shutdown.hysteresis = 5; /*not that it matters */
+	therm->bios_sensor.thrs_shutdown.temp = 135;
+	therm->bios_sensor.thrs_shutdown.hysteresis = 5; /*not that it matters */
 }
 
 
 static void
-nvkm_therm_temp_safety_checks(struct nvkm_therm *therm)
+nvkm_therm_temp_safety_checks(struct nvkm_therm *obj)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
-	struct nvbios_therm_sensor *s = &priv->bios_sensor;
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
+	struct nvbios_therm_sensor *s = &therm->bios_sensor;
 
 	/* enforce a minimum hysteresis on thresholds */
 	s->thrs_fan_boost.hysteresis = max_t(u8, s->thrs_fan_boost.hysteresis, 2);
@@ -59,21 +59,21 @@ nvkm_therm_temp_safety_checks(struct nvkm_therm *therm)
 
 /* must be called with alarm_program_lock taken ! */
 void
-nvkm_therm_sensor_set_threshold_state(struct nvkm_therm *therm,
+nvkm_therm_sensor_set_threshold_state(struct nvkm_therm *obj,
 				      enum nvkm_therm_thrs thrs,
 				      enum nvkm_therm_thrs_state st)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
-	priv->sensor.alarm_state[thrs] = st;
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
+	therm->sensor.alarm_state[thrs] = st;
 }
 
 /* must be called with alarm_program_lock taken ! */
 enum nvkm_therm_thrs_state
-nvkm_therm_sensor_get_threshold_state(struct nvkm_therm *therm,
+nvkm_therm_sensor_get_threshold_state(struct nvkm_therm *obj,
 				      enum nvkm_therm_thrs thrs)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
-	return priv->sensor.alarm_state[thrs];
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
+	return therm->sensor.alarm_state[thrs];
 }
 
 static void
@@ -84,15 +84,15 @@ nv_poweroff_work(struct work_struct *work)
 }
 
 void
-nvkm_therm_sensor_event(struct nvkm_therm *therm, enum nvkm_therm_thrs thrs,
+nvkm_therm_sensor_event(struct nvkm_therm *obj, enum nvkm_therm_thrs thrs,
 			enum nvkm_therm_thrs_direction dir)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 	bool active;
 	const char *thresolds[] = {
 		"fanboost", "downclock", "critical", "shutdown"
 	};
-	int temperature = therm->temp_get(therm);
+	int temperature = therm->base.temp_get(&therm->base);
 
 	if (thrs < 0 || thrs > 3)
 		return;
@@ -108,17 +108,17 @@ nvkm_therm_sensor_event(struct nvkm_therm *therm, enum nvkm_therm_thrs thrs,
 	switch (thrs) {
 	case NVKM_THERM_THRS_FANBOOST:
 		if (active) {
-			nvkm_therm_fan_set(therm, true, 100);
-			nvkm_therm_fan_mode(therm, NVKM_THERM_CTRL_AUTO);
+			nvkm_therm_fan_set(&therm->base, true, 100);
+			nvkm_therm_fan_mode(&therm->base, NVKM_THERM_CTRL_AUTO);
 		}
 		break;
 	case NVKM_THERM_THRS_DOWNCLOCK:
-		if (priv->emergency.downclock)
-			priv->emergency.downclock(therm, active);
+		if (therm->emergency.downclock)
+			therm->emergency.downclock(&therm->base, active);
 		break;
 	case NVKM_THERM_THRS_CRITICAL:
-		if (priv->emergency.pause)
-			priv->emergency.pause(therm, active);
+		if (therm->emergency.pause)
+			therm->emergency.pause(&therm->base, active);
 		break;
 	case NVKM_THERM_THRS_SHUTDOWN:
 		if (active) {
@@ -166,39 +166,39 @@ nvkm_therm_threshold_hyst_polling(struct nvkm_therm *therm,
 static void
 alarm_timer_callback(struct nvkm_alarm *alarm)
 {
-	struct nvkm_therm_priv *priv =
+	struct nvkm_therm_priv *therm =
 	container_of(alarm, struct nvkm_therm_priv, sensor.therm_poll_alarm);
-	struct nvbios_therm_sensor *sensor = &priv->bios_sensor;
-	struct nvkm_timer *ptimer = nvkm_timer(priv);
-	struct nvkm_therm *therm = &priv->base;
+	struct nvbios_therm_sensor *sensor = &therm->bios_sensor;
+	struct nvkm_timer *ptimer = nvkm_timer(therm);
 	unsigned long flags;
 
-	spin_lock_irqsave(&priv->sensor.alarm_program_lock, flags);
+	spin_lock_irqsave(&therm->sensor.alarm_program_lock, flags);
 
-	nvkm_therm_threshold_hyst_polling(therm, &sensor->thrs_fan_boost,
+	nvkm_therm_threshold_hyst_polling(&therm->base, &sensor->thrs_fan_boost,
 					  NVKM_THERM_THRS_FANBOOST);
 
-	nvkm_therm_threshold_hyst_polling(therm, &sensor->thrs_down_clock,
+	nvkm_therm_threshold_hyst_polling(&therm->base,
+					  &sensor->thrs_down_clock,
 					  NVKM_THERM_THRS_DOWNCLOCK);
 
-	nvkm_therm_threshold_hyst_polling(therm, &sensor->thrs_critical,
+	nvkm_therm_threshold_hyst_polling(&therm->base, &sensor->thrs_critical,
 					  NVKM_THERM_THRS_CRITICAL);
 
-	nvkm_therm_threshold_hyst_polling(therm, &sensor->thrs_shutdown,
+	nvkm_therm_threshold_hyst_polling(&therm->base, &sensor->thrs_shutdown,
 					  NVKM_THERM_THRS_SHUTDOWN);
 
-	spin_unlock_irqrestore(&priv->sensor.alarm_program_lock, flags);
+	spin_unlock_irqrestore(&therm->sensor.alarm_program_lock, flags);
 
 	/* schedule the next poll in one second */
-	if (therm->temp_get(therm) >= 0 && list_empty(&alarm->head))
+	if (therm->base.temp_get(&therm->base) >= 0 && list_empty(&alarm->head))
 		ptimer->alarm(ptimer, 1000000000ULL, alarm);
 }
 
 void
-nvkm_therm_program_alarms_polling(struct nvkm_therm *therm)
+nvkm_therm_program_alarms_polling(struct nvkm_therm *obj)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
-	struct nvbios_therm_sensor *sensor = &priv->bios_sensor;
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
+	struct nvbios_therm_sensor *sensor = &therm->bios_sensor;
 
 	nv_debug(therm,
 		 "programmed thresholds [ %d(%d), %d(%d), %d(%d), %d(%d) ]\n",
@@ -208,25 +208,25 @@ nvkm_therm_program_alarms_polling(struct nvkm_therm *therm)
 		 sensor->thrs_critical.temp, sensor->thrs_critical.hysteresis,
 		 sensor->thrs_shutdown.temp, sensor->thrs_shutdown.hysteresis);
 
-	alarm_timer_callback(&priv->sensor.therm_poll_alarm);
+	alarm_timer_callback(&therm->sensor.therm_poll_alarm);
 }
 
 int
-nvkm_therm_sensor_init(struct nvkm_therm *therm)
+nvkm_therm_sensor_init(struct nvkm_therm *obj)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
-	priv->sensor.program_alarms(therm);
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
+	therm->sensor.program_alarms(&therm->base);
 	return 0;
 }
 
 int
-nvkm_therm_sensor_fini(struct nvkm_therm *therm, bool suspend)
+nvkm_therm_sensor_fini(struct nvkm_therm *obj, bool suspend)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 	struct nvkm_timer *ptimer = nvkm_timer(therm);
 
 	if (suspend)
-		ptimer->alarm_cancel(ptimer, &priv->sensor.therm_poll_alarm);
+		ptimer->alarm_cancel(ptimer, &therm->sensor.therm_poll_alarm);
 	return 0;
 }
 
@@ -242,18 +242,18 @@ nvkm_therm_sensor_preinit(struct nvkm_therm *therm)
 }
 
 int
-nvkm_therm_sensor_ctor(struct nvkm_therm *therm)
+nvkm_therm_sensor_ctor(struct nvkm_therm *obj)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 	struct nvkm_bios *bios = nvkm_bios(therm);
 
-	nvkm_alarm_init(&priv->sensor.therm_poll_alarm, alarm_timer_callback);
+	nvkm_alarm_init(&therm->sensor.therm_poll_alarm, alarm_timer_callback);
 
-	nvkm_therm_temp_set_defaults(therm);
+	nvkm_therm_temp_set_defaults(&therm->base);
 	if (nvbios_therm_sensor_parse(bios, NVBIOS_THERM_DOMAIN_CORE,
-				      &priv->bios_sensor))
+				      &therm->bios_sensor))
 		nv_error(therm, "nvbios_therm_sensor_parse failed\n");
-	nvkm_therm_temp_safety_checks(therm);
+	nvkm_therm_temp_safety_checks(&therm->base);
 
 	return 0;
 }

commit e1404611d5f6a7c75e2b745f5eb7fbcdd23751c5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:11:48 2015 +1000

    drm/nouveau/therm: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
index 6212537b90c5..aa13744f3854 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
@@ -21,18 +21,12 @@
  *
  * Authors: Martin Peres
  */
-
 #include "priv.h"
 
-#include <core/object.h>
-#include <core/device.h>
-
-#include <subdev/bios.h>
-
 static void
-nouveau_therm_temp_set_defaults(struct nouveau_therm *therm)
+nvkm_therm_temp_set_defaults(struct nvkm_therm *therm)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *priv = (void *)therm;
 
 	priv->bios_sensor.offset_constant = 0;
 
@@ -51,9 +45,9 @@ nouveau_therm_temp_set_defaults(struct nouveau_therm *therm)
 
 
 static void
-nouveau_therm_temp_safety_checks(struct nouveau_therm *therm)
+nvkm_therm_temp_safety_checks(struct nvkm_therm *therm)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *priv = (void *)therm;
 	struct nvbios_therm_sensor *s = &priv->bios_sensor;
 
 	/* enforce a minimum hysteresis on thresholds */
@@ -64,20 +58,21 @@ nouveau_therm_temp_safety_checks(struct nouveau_therm *therm)
 }
 
 /* must be called with alarm_program_lock taken ! */
-void nouveau_therm_sensor_set_threshold_state(struct nouveau_therm *therm,
-					     enum nouveau_therm_thrs thrs,
-					     enum nouveau_therm_thrs_state st)
+void
+nvkm_therm_sensor_set_threshold_state(struct nvkm_therm *therm,
+				      enum nvkm_therm_thrs thrs,
+				      enum nvkm_therm_thrs_state st)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *priv = (void *)therm;
 	priv->sensor.alarm_state[thrs] = st;
 }
 
 /* must be called with alarm_program_lock taken ! */
-enum nouveau_therm_thrs_state
-nouveau_therm_sensor_get_threshold_state(struct nouveau_therm *therm,
-					 enum nouveau_therm_thrs thrs)
+enum nvkm_therm_thrs_state
+nvkm_therm_sensor_get_threshold_state(struct nvkm_therm *therm,
+				      enum nvkm_therm_thrs thrs)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *priv = (void *)therm;
 	return priv->sensor.alarm_state[thrs];
 }
 
@@ -88,11 +83,11 @@ nv_poweroff_work(struct work_struct *work)
 	kfree(work);
 }
 
-void nouveau_therm_sensor_event(struct nouveau_therm *therm,
-			        enum nouveau_therm_thrs thrs,
-			        enum nouveau_therm_thrs_direction dir)
+void
+nvkm_therm_sensor_event(struct nvkm_therm *therm, enum nvkm_therm_thrs thrs,
+			enum nvkm_therm_thrs_direction dir)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *priv = (void *)therm;
 	bool active;
 	const char *thresolds[] = {
 		"fanboost", "downclock", "critical", "shutdown"
@@ -102,30 +97,30 @@ void nouveau_therm_sensor_event(struct nouveau_therm *therm,
 	if (thrs < 0 || thrs > 3)
 		return;
 
-	if (dir == NOUVEAU_THERM_THRS_FALLING)
+	if (dir == NVKM_THERM_THRS_FALLING)
 		nv_info(therm, "temperature (%i C) went below the '%s' threshold\n",
 			temperature, thresolds[thrs]);
 	else
 		nv_info(therm, "temperature (%i C) hit the '%s' threshold\n",
 			temperature, thresolds[thrs]);
 
-	active = (dir == NOUVEAU_THERM_THRS_RISING);
+	active = (dir == NVKM_THERM_THRS_RISING);
 	switch (thrs) {
-	case NOUVEAU_THERM_THRS_FANBOOST:
+	case NVKM_THERM_THRS_FANBOOST:
 		if (active) {
-			nouveau_therm_fan_set(therm, true, 100);
-			nouveau_therm_fan_mode(therm, NOUVEAU_THERM_CTRL_AUTO);
+			nvkm_therm_fan_set(therm, true, 100);
+			nvkm_therm_fan_mode(therm, NVKM_THERM_CTRL_AUTO);
 		}
 		break;
-	case NOUVEAU_THERM_THRS_DOWNCLOCK:
+	case NVKM_THERM_THRS_DOWNCLOCK:
 		if (priv->emergency.downclock)
 			priv->emergency.downclock(therm, active);
 		break;
-	case NOUVEAU_THERM_THRS_CRITICAL:
+	case NVKM_THERM_THRS_CRITICAL:
 		if (priv->emergency.pause)
 			priv->emergency.pause(therm, active);
 		break;
-	case NOUVEAU_THERM_THRS_SHUTDOWN:
+	case NVKM_THERM_THRS_SHUTDOWN:
 		if (active) {
 			struct work_struct *work;
 
@@ -136,7 +131,7 @@ void nouveau_therm_sensor_event(struct nouveau_therm *therm,
 			}
 		}
 		break;
-	case NOUVEAU_THERM_THRS_NR:
+	case NVKM_THERM_THRS_NR:
 		break;
 	}
 
@@ -144,53 +139,53 @@ void nouveau_therm_sensor_event(struct nouveau_therm *therm,
 
 /* must be called with alarm_program_lock taken ! */
 static void
-nouveau_therm_threshold_hyst_polling(struct nouveau_therm *therm,
-				   const struct nvbios_therm_threshold *thrs,
-				   enum nouveau_therm_thrs thrs_name)
+nvkm_therm_threshold_hyst_polling(struct nvkm_therm *therm,
+				  const struct nvbios_therm_threshold *thrs,
+				  enum nvkm_therm_thrs thrs_name)
 {
-	enum nouveau_therm_thrs_direction direction;
-	enum nouveau_therm_thrs_state prev_state, new_state;
+	enum nvkm_therm_thrs_direction direction;
+	enum nvkm_therm_thrs_state prev_state, new_state;
 	int temp = therm->temp_get(therm);
 
-	prev_state = nouveau_therm_sensor_get_threshold_state(therm, thrs_name);
+	prev_state = nvkm_therm_sensor_get_threshold_state(therm, thrs_name);
 
-	if (temp >= thrs->temp && prev_state == NOUVEAU_THERM_THRS_LOWER) {
-		direction = NOUVEAU_THERM_THRS_RISING;
-		new_state = NOUVEAU_THERM_THRS_HIGHER;
+	if (temp >= thrs->temp && prev_state == NVKM_THERM_THRS_LOWER) {
+		direction = NVKM_THERM_THRS_RISING;
+		new_state = NVKM_THERM_THRS_HIGHER;
 	} else if (temp <= thrs->temp - thrs->hysteresis &&
-			prev_state == NOUVEAU_THERM_THRS_HIGHER) {
-		direction = NOUVEAU_THERM_THRS_FALLING;
-		new_state = NOUVEAU_THERM_THRS_LOWER;
+			prev_state == NVKM_THERM_THRS_HIGHER) {
+		direction = NVKM_THERM_THRS_FALLING;
+		new_state = NVKM_THERM_THRS_LOWER;
 	} else
 		return; /* nothing to do */
 
-	nouveau_therm_sensor_set_threshold_state(therm, thrs_name, new_state);
-	nouveau_therm_sensor_event(therm, thrs_name, direction);
+	nvkm_therm_sensor_set_threshold_state(therm, thrs_name, new_state);
+	nvkm_therm_sensor_event(therm, thrs_name, direction);
 }
 
 static void
-alarm_timer_callback(struct nouveau_alarm *alarm)
+alarm_timer_callback(struct nvkm_alarm *alarm)
 {
-	struct nouveau_therm_priv *priv =
-	container_of(alarm, struct nouveau_therm_priv, sensor.therm_poll_alarm);
+	struct nvkm_therm_priv *priv =
+	container_of(alarm, struct nvkm_therm_priv, sensor.therm_poll_alarm);
 	struct nvbios_therm_sensor *sensor = &priv->bios_sensor;
-	struct nouveau_timer *ptimer = nouveau_timer(priv);
-	struct nouveau_therm *therm = &priv->base;
+	struct nvkm_timer *ptimer = nvkm_timer(priv);
+	struct nvkm_therm *therm = &priv->base;
 	unsigned long flags;
 
 	spin_lock_irqsave(&priv->sensor.alarm_program_lock, flags);
 
-	nouveau_therm_threshold_hyst_polling(therm, &sensor->thrs_fan_boost,
-					     NOUVEAU_THERM_THRS_FANBOOST);
+	nvkm_therm_threshold_hyst_polling(therm, &sensor->thrs_fan_boost,
+					  NVKM_THERM_THRS_FANBOOST);
 
-	nouveau_therm_threshold_hyst_polling(therm, &sensor->thrs_down_clock,
-					     NOUVEAU_THERM_THRS_DOWNCLOCK);
+	nvkm_therm_threshold_hyst_polling(therm, &sensor->thrs_down_clock,
+					  NVKM_THERM_THRS_DOWNCLOCK);
 
-	nouveau_therm_threshold_hyst_polling(therm, &sensor->thrs_critical,
-					     NOUVEAU_THERM_THRS_CRITICAL);
+	nvkm_therm_threshold_hyst_polling(therm, &sensor->thrs_critical,
+					  NVKM_THERM_THRS_CRITICAL);
 
-	nouveau_therm_threshold_hyst_polling(therm, &sensor->thrs_shutdown,
-					     NOUVEAU_THERM_THRS_SHUTDOWN);
+	nvkm_therm_threshold_hyst_polling(therm, &sensor->thrs_shutdown,
+					  NVKM_THERM_THRS_SHUTDOWN);
 
 	spin_unlock_irqrestore(&priv->sensor.alarm_program_lock, flags);
 
@@ -200,9 +195,9 @@ alarm_timer_callback(struct nouveau_alarm *alarm)
 }
 
 void
-nouveau_therm_program_alarms_polling(struct nouveau_therm *therm)
+nvkm_therm_program_alarms_polling(struct nvkm_therm *therm)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *priv = (void *)therm;
 	struct nvbios_therm_sensor *sensor = &priv->bios_sensor;
 
 	nv_debug(therm,
@@ -217,18 +212,18 @@ nouveau_therm_program_alarms_polling(struct nouveau_therm *therm)
 }
 
 int
-nouveau_therm_sensor_init(struct nouveau_therm *therm)
+nvkm_therm_sensor_init(struct nvkm_therm *therm)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *priv = (void *)therm;
 	priv->sensor.program_alarms(therm);
 	return 0;
 }
 
 int
-nouveau_therm_sensor_fini(struct nouveau_therm *therm, bool suspend)
+nvkm_therm_sensor_fini(struct nvkm_therm *therm, bool suspend)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
-	struct nouveau_timer *ptimer = nouveau_timer(therm);
+	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_timer *ptimer = nvkm_timer(therm);
 
 	if (suspend)
 		ptimer->alarm_cancel(ptimer, &priv->sensor.therm_poll_alarm);
@@ -236,7 +231,7 @@ nouveau_therm_sensor_fini(struct nouveau_therm *therm, bool suspend)
 }
 
 void
-nouveau_therm_sensor_preinit(struct nouveau_therm *therm)
+nvkm_therm_sensor_preinit(struct nvkm_therm *therm)
 {
 	const char *sensor_avail = "yes";
 
@@ -247,18 +242,18 @@ nouveau_therm_sensor_preinit(struct nouveau_therm *therm)
 }
 
 int
-nouveau_therm_sensor_ctor(struct nouveau_therm *therm)
+nvkm_therm_sensor_ctor(struct nvkm_therm *therm)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
-	struct nouveau_bios *bios = nouveau_bios(therm);
+	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_bios *bios = nvkm_bios(therm);
 
-	nouveau_alarm_init(&priv->sensor.therm_poll_alarm, alarm_timer_callback);
+	nvkm_alarm_init(&priv->sensor.therm_poll_alarm, alarm_timer_callback);
 
-	nouveau_therm_temp_set_defaults(therm);
+	nvkm_therm_temp_set_defaults(therm);
 	if (nvbios_therm_sensor_parse(bios, NVBIOS_THERM_DOMAIN_CORE,
 				      &priv->bios_sensor))
 		nv_error(therm, "nvbios_therm_sensor_parse failed\n");
-	nouveau_therm_temp_safety_checks(therm);
+	nvkm_therm_temp_safety_checks(therm);
 
 	return 0;
 }

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
new file mode 100644
index 000000000000..6212537b90c5
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c
@@ -0,0 +1,264 @@
+/*
+ * Copyright 2012 The Nouveau community
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Martin Peres
+ */
+
+#include "priv.h"
+
+#include <core/object.h>
+#include <core/device.h>
+
+#include <subdev/bios.h>
+
+static void
+nouveau_therm_temp_set_defaults(struct nouveau_therm *therm)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+
+	priv->bios_sensor.offset_constant = 0;
+
+	priv->bios_sensor.thrs_fan_boost.temp = 90;
+	priv->bios_sensor.thrs_fan_boost.hysteresis = 3;
+
+	priv->bios_sensor.thrs_down_clock.temp = 95;
+	priv->bios_sensor.thrs_down_clock.hysteresis = 3;
+
+	priv->bios_sensor.thrs_critical.temp = 105;
+	priv->bios_sensor.thrs_critical.hysteresis = 5;
+
+	priv->bios_sensor.thrs_shutdown.temp = 135;
+	priv->bios_sensor.thrs_shutdown.hysteresis = 5; /*not that it matters */
+}
+
+
+static void
+nouveau_therm_temp_safety_checks(struct nouveau_therm *therm)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvbios_therm_sensor *s = &priv->bios_sensor;
+
+	/* enforce a minimum hysteresis on thresholds */
+	s->thrs_fan_boost.hysteresis = max_t(u8, s->thrs_fan_boost.hysteresis, 2);
+	s->thrs_down_clock.hysteresis = max_t(u8, s->thrs_down_clock.hysteresis, 2);
+	s->thrs_critical.hysteresis = max_t(u8, s->thrs_critical.hysteresis, 2);
+	s->thrs_shutdown.hysteresis = max_t(u8, s->thrs_shutdown.hysteresis, 2);
+}
+
+/* must be called with alarm_program_lock taken ! */
+void nouveau_therm_sensor_set_threshold_state(struct nouveau_therm *therm,
+					     enum nouveau_therm_thrs thrs,
+					     enum nouveau_therm_thrs_state st)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	priv->sensor.alarm_state[thrs] = st;
+}
+
+/* must be called with alarm_program_lock taken ! */
+enum nouveau_therm_thrs_state
+nouveau_therm_sensor_get_threshold_state(struct nouveau_therm *therm,
+					 enum nouveau_therm_thrs thrs)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	return priv->sensor.alarm_state[thrs];
+}
+
+static void
+nv_poweroff_work(struct work_struct *work)
+{
+	orderly_poweroff(true);
+	kfree(work);
+}
+
+void nouveau_therm_sensor_event(struct nouveau_therm *therm,
+			        enum nouveau_therm_thrs thrs,
+			        enum nouveau_therm_thrs_direction dir)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	bool active;
+	const char *thresolds[] = {
+		"fanboost", "downclock", "critical", "shutdown"
+	};
+	int temperature = therm->temp_get(therm);
+
+	if (thrs < 0 || thrs > 3)
+		return;
+
+	if (dir == NOUVEAU_THERM_THRS_FALLING)
+		nv_info(therm, "temperature (%i C) went below the '%s' threshold\n",
+			temperature, thresolds[thrs]);
+	else
+		nv_info(therm, "temperature (%i C) hit the '%s' threshold\n",
+			temperature, thresolds[thrs]);
+
+	active = (dir == NOUVEAU_THERM_THRS_RISING);
+	switch (thrs) {
+	case NOUVEAU_THERM_THRS_FANBOOST:
+		if (active) {
+			nouveau_therm_fan_set(therm, true, 100);
+			nouveau_therm_fan_mode(therm, NOUVEAU_THERM_CTRL_AUTO);
+		}
+		break;
+	case NOUVEAU_THERM_THRS_DOWNCLOCK:
+		if (priv->emergency.downclock)
+			priv->emergency.downclock(therm, active);
+		break;
+	case NOUVEAU_THERM_THRS_CRITICAL:
+		if (priv->emergency.pause)
+			priv->emergency.pause(therm, active);
+		break;
+	case NOUVEAU_THERM_THRS_SHUTDOWN:
+		if (active) {
+			struct work_struct *work;
+
+			work = kmalloc(sizeof(*work), GFP_ATOMIC);
+			if (work) {
+				INIT_WORK(work, nv_poweroff_work);
+				schedule_work(work);
+			}
+		}
+		break;
+	case NOUVEAU_THERM_THRS_NR:
+		break;
+	}
+
+}
+
+/* must be called with alarm_program_lock taken ! */
+static void
+nouveau_therm_threshold_hyst_polling(struct nouveau_therm *therm,
+				   const struct nvbios_therm_threshold *thrs,
+				   enum nouveau_therm_thrs thrs_name)
+{
+	enum nouveau_therm_thrs_direction direction;
+	enum nouveau_therm_thrs_state prev_state, new_state;
+	int temp = therm->temp_get(therm);
+
+	prev_state = nouveau_therm_sensor_get_threshold_state(therm, thrs_name);
+
+	if (temp >= thrs->temp && prev_state == NOUVEAU_THERM_THRS_LOWER) {
+		direction = NOUVEAU_THERM_THRS_RISING;
+		new_state = NOUVEAU_THERM_THRS_HIGHER;
+	} else if (temp <= thrs->temp - thrs->hysteresis &&
+			prev_state == NOUVEAU_THERM_THRS_HIGHER) {
+		direction = NOUVEAU_THERM_THRS_FALLING;
+		new_state = NOUVEAU_THERM_THRS_LOWER;
+	} else
+		return; /* nothing to do */
+
+	nouveau_therm_sensor_set_threshold_state(therm, thrs_name, new_state);
+	nouveau_therm_sensor_event(therm, thrs_name, direction);
+}
+
+static void
+alarm_timer_callback(struct nouveau_alarm *alarm)
+{
+	struct nouveau_therm_priv *priv =
+	container_of(alarm, struct nouveau_therm_priv, sensor.therm_poll_alarm);
+	struct nvbios_therm_sensor *sensor = &priv->bios_sensor;
+	struct nouveau_timer *ptimer = nouveau_timer(priv);
+	struct nouveau_therm *therm = &priv->base;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->sensor.alarm_program_lock, flags);
+
+	nouveau_therm_threshold_hyst_polling(therm, &sensor->thrs_fan_boost,
+					     NOUVEAU_THERM_THRS_FANBOOST);
+
+	nouveau_therm_threshold_hyst_polling(therm, &sensor->thrs_down_clock,
+					     NOUVEAU_THERM_THRS_DOWNCLOCK);
+
+	nouveau_therm_threshold_hyst_polling(therm, &sensor->thrs_critical,
+					     NOUVEAU_THERM_THRS_CRITICAL);
+
+	nouveau_therm_threshold_hyst_polling(therm, &sensor->thrs_shutdown,
+					     NOUVEAU_THERM_THRS_SHUTDOWN);
+
+	spin_unlock_irqrestore(&priv->sensor.alarm_program_lock, flags);
+
+	/* schedule the next poll in one second */
+	if (therm->temp_get(therm) >= 0 && list_empty(&alarm->head))
+		ptimer->alarm(ptimer, 1000000000ULL, alarm);
+}
+
+void
+nouveau_therm_program_alarms_polling(struct nouveau_therm *therm)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvbios_therm_sensor *sensor = &priv->bios_sensor;
+
+	nv_debug(therm,
+		 "programmed thresholds [ %d(%d), %d(%d), %d(%d), %d(%d) ]\n",
+		 sensor->thrs_fan_boost.temp, sensor->thrs_fan_boost.hysteresis,
+		 sensor->thrs_down_clock.temp,
+		 sensor->thrs_down_clock.hysteresis,
+		 sensor->thrs_critical.temp, sensor->thrs_critical.hysteresis,
+		 sensor->thrs_shutdown.temp, sensor->thrs_shutdown.hysteresis);
+
+	alarm_timer_callback(&priv->sensor.therm_poll_alarm);
+}
+
+int
+nouveau_therm_sensor_init(struct nouveau_therm *therm)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	priv->sensor.program_alarms(therm);
+	return 0;
+}
+
+int
+nouveau_therm_sensor_fini(struct nouveau_therm *therm, bool suspend)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nouveau_timer *ptimer = nouveau_timer(therm);
+
+	if (suspend)
+		ptimer->alarm_cancel(ptimer, &priv->sensor.therm_poll_alarm);
+	return 0;
+}
+
+void
+nouveau_therm_sensor_preinit(struct nouveau_therm *therm)
+{
+	const char *sensor_avail = "yes";
+
+	if (therm->temp_get(therm) < 0)
+		sensor_avail = "no";
+
+	nv_info(therm, "internal sensor: %s\n", sensor_avail);
+}
+
+int
+nouveau_therm_sensor_ctor(struct nouveau_therm *therm)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nouveau_bios *bios = nouveau_bios(therm);
+
+	nouveau_alarm_init(&priv->sensor.therm_poll_alarm, alarm_timer_callback);
+
+	nouveau_therm_temp_set_defaults(therm);
+	if (nvbios_therm_sensor_parse(bios, NVBIOS_THERM_DOMAIN_CORE,
+				      &priv->bios_sensor))
+		nv_error(therm, "nvbios_therm_sensor_parse failed\n");
+	nouveau_therm_temp_safety_checks(therm);
+
+	return 0;
+}
