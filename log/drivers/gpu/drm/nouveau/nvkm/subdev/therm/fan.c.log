commit 7eaf1198a9aaa9c31c9270e370088d8a79c149ab
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu May 11 17:29:58 2017 +1000

    drm/nouveau/tmr: remove nvkm_timer_alarm_cancel()
    
    nvkm_timer_alarm() already handles this as part of protecting against
    callers passing in no timeout value.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
index e2feccec25f5..f8fa43c8a7d2 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
@@ -215,7 +215,7 @@ nvkm_therm_fan_fini(struct nvkm_therm *therm, bool suspend)
 {
 	struct nvkm_timer *tmr = therm->subdev.device->timer;
 	if (suspend)
-		nvkm_timer_alarm_cancel(tmr, &therm->fan->alarm);
+		nvkm_timer_alarm(tmr, 0, &therm->fan->alarm);
 	return 0;
 }
 

commit e4311ee51d1e2676001b2d8fcefd92bdd79aad85
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu May 11 17:33:39 2017 +1000

    drm/nouveau/therm: remove ineffective workarounds for alarm bugs
    
    These were ineffective due to touching the list without the alarm lock,
    but should no longer be required.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
index 91198d79393a..e2feccec25f5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
@@ -83,7 +83,7 @@ nvkm_fan_update(struct nvkm_fan *fan, bool immediate, int target)
 	spin_unlock_irqrestore(&fan->lock, flags);
 
 	/* schedule next fan update, if not at target speed already */
-	if (list_empty(&fan->alarm.head) && target != duty) {
+	if (target != duty) {
 		u16 bump_period = fan->bios.bump_period;
 		u16 slow_down_period = fan->bios.slow_down_period;
 		u64 delay;

commit 31649ecf47a44e02e73bffc5680c8f56d6cf587a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:21 2015 +1000

    drm/nouveau/tmr: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
index a2be18167770..91198d79393a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
@@ -95,7 +95,7 @@ nvkm_fan_update(struct nvkm_fan *fan, bool immediate, int target)
 		else
 			delay = bump_period;
 
-		tmr->alarm(tmr, delay * 1000 * 1000, &fan->alarm);
+		nvkm_timer_alarm(tmr, delay * 1000 * 1000, &fan->alarm);
 	}
 
 	return ret;
@@ -139,7 +139,7 @@ nvkm_therm_fan_sense(struct nvkm_therm *therm)
 	 * When the fan spins, it changes the value of GPIO FAN_SENSE.
 	 * We get 4 changes (0 -> 1 -> 0 -> 1) per complete rotation.
 	 */
-	start = tmr->read(tmr);
+	start = nvkm_timer_read(tmr);
 	prev = nvkm_gpio_get(gpio, 0, therm->fan->tach.func,
 				      therm->fan->tach.line);
 	cycles = 0;
@@ -150,12 +150,12 @@ nvkm_therm_fan_sense(struct nvkm_therm *therm)
 					     therm->fan->tach.line);
 		if (prev != cur) {
 			if (!start)
-				start = tmr->read(tmr);
+				start = nvkm_timer_read(tmr);
 			cycles++;
 			prev = cur;
 		}
-	} while (cycles < 5 && tmr->read(tmr) - start < 250000000);
-	end = tmr->read(tmr);
+	} while (cycles < 5 && nvkm_timer_read(tmr) - start < 250000000);
+	end = nvkm_timer_read(tmr);
 
 	if (cycles == 5) {
 		tach = (u64)60000000000ULL;
@@ -215,7 +215,7 @@ nvkm_therm_fan_fini(struct nvkm_therm *therm, bool suspend)
 {
 	struct nvkm_timer *tmr = therm->subdev.device->timer;
 	if (suspend)
-		tmr->alarm_cancel(tmr, &therm->fan->alarm);
+		nvkm_timer_alarm_cancel(tmr, &therm->fan->alarm);
 	return 0;
 }
 

commit 57113c0170b9efeacb3e3e9d4c2178c30d9cd991
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:21 2015 +1000

    drm/nouveau/therm: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
index e017607673a5..a2be18167770 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
@@ -31,8 +31,8 @@
 static int
 nvkm_fan_update(struct nvkm_fan *fan, bool immediate, int target)
 {
-	struct nvkm_therm_priv *therm = (void *)fan->parent;
-	struct nvkm_subdev *subdev = &therm->base.subdev;
+	struct nvkm_therm *therm = fan->parent;
+	struct nvkm_subdev *subdev = &therm->subdev;
 	struct nvkm_timer *tmr = subdev->device->timer;
 	unsigned long flags;
 	int ret = 0;
@@ -50,7 +50,7 @@ nvkm_fan_update(struct nvkm_fan *fan, bool immediate, int target)
 	}
 
 	/* check that we're not already at the target duty cycle */
-	duty = fan->get(&therm->base);
+	duty = fan->get(therm);
 	if (duty == target) {
 		spin_unlock_irqrestore(&fan->lock, flags);
 		return 0;
@@ -71,7 +71,7 @@ nvkm_fan_update(struct nvkm_fan *fan, bool immediate, int target)
 	}
 
 	nvkm_debug(subdev, "FAN update: %d\n", duty);
-	ret = fan->set(&therm->base, duty);
+	ret = fan->set(therm, duty);
 	if (ret) {
 		spin_unlock_irqrestore(&fan->lock, flags);
 		return ret;
@@ -109,29 +109,29 @@ nvkm_fan_alarm(struct nvkm_alarm *alarm)
 }
 
 int
-nvkm_therm_fan_get(struct nvkm_therm *obj)
+nvkm_therm_fan_get(struct nvkm_therm *therm)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	return therm->fan->get(&therm->base);
+	return therm->fan->get(therm);
 }
 
 int
-nvkm_therm_fan_set(struct nvkm_therm *obj, bool immediate, int percent)
+nvkm_therm_fan_set(struct nvkm_therm *therm, bool immediate, int percent)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 	return nvkm_fan_update(therm->fan, immediate, percent);
 }
 
 int
-nvkm_therm_fan_sense(struct nvkm_therm *obj)
+nvkm_therm_fan_sense(struct nvkm_therm *therm)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	struct nvkm_device *device = therm->base.subdev.device;
+	struct nvkm_device *device = therm->subdev.device;
 	struct nvkm_timer *tmr = device->timer;
 	struct nvkm_gpio *gpio = device->gpio;
 	u32 cycles, cur, prev;
 	u64 start, end, tach;
 
+	if (therm->func->fan_sense)
+		return therm->func->fan_sense(therm);
+
 	if (therm->fan->tach.func == DCB_GPIO_UNUSED)
 		return -ENODEV;
 
@@ -166,28 +166,23 @@ nvkm_therm_fan_sense(struct nvkm_therm *obj)
 }
 
 int
-nvkm_therm_fan_user_get(struct nvkm_therm *obj)
+nvkm_therm_fan_user_get(struct nvkm_therm *therm)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	return nvkm_therm_fan_get(&therm->base);
+	return nvkm_therm_fan_get(therm);
 }
 
 int
-nvkm_therm_fan_user_set(struct nvkm_therm *obj, int percent)
+nvkm_therm_fan_user_set(struct nvkm_therm *therm, int percent)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-
 	if (therm->mode != NVKM_THERM_CTRL_MANUAL)
 		return -EINVAL;
 
-	return nvkm_therm_fan_set(&therm->base, true, percent);
+	return nvkm_therm_fan_set(therm, true, percent);
 }
 
 static void
-nvkm_therm_fan_set_defaults(struct nvkm_therm *obj)
+nvkm_therm_fan_set_defaults(struct nvkm_therm *therm)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-
 	therm->fan->bios.pwm_freq = 0;
 	therm->fan->bios.min_duty = 0;
 	therm->fan->bios.max_duty = 100;
@@ -198,10 +193,8 @@ nvkm_therm_fan_set_defaults(struct nvkm_therm *obj)
 }
 
 static void
-nvkm_therm_fan_safety_checks(struct nvkm_therm *obj)
+nvkm_therm_fan_safety_checks(struct nvkm_therm *therm)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-
 	if (therm->fan->bios.min_duty > 100)
 		therm->fan->bios.min_duty = 100;
 	if (therm->fan->bios.max_duty > 100)
@@ -212,27 +205,24 @@ nvkm_therm_fan_safety_checks(struct nvkm_therm *obj)
 }
 
 int
-nvkm_therm_fan_init(struct nvkm_therm *obj)
+nvkm_therm_fan_init(struct nvkm_therm *therm)
 {
 	return 0;
 }
 
 int
-nvkm_therm_fan_fini(struct nvkm_therm *obj, bool suspend)
+nvkm_therm_fan_fini(struct nvkm_therm *therm, bool suspend)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	struct nvkm_timer *tmr = nvkm_timer(therm);
-
+	struct nvkm_timer *tmr = therm->subdev.device->timer;
 	if (suspend)
 		tmr->alarm_cancel(tmr, &therm->fan->alarm);
 	return 0;
 }
 
 int
-nvkm_therm_fan_ctor(struct nvkm_therm *obj)
+nvkm_therm_fan_ctor(struct nvkm_therm *therm)
 {
-	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	struct nvkm_subdev *subdev = &therm->base.subdev;
+	struct nvkm_subdev *subdev = &therm->subdev;
 	struct nvkm_device *device = subdev->device;
 	struct nvkm_gpio *gpio = device->gpio;
 	struct nvkm_bios *bios = device->bios;
@@ -247,15 +237,15 @@ nvkm_therm_fan_ctor(struct nvkm_therm *obj)
 			nvkm_debug(subdev, "GPIO_FAN is in input mode\n");
 			ret = -EINVAL;
 		} else {
-			ret = nvkm_fanpwm_create(&therm->base, &func);
+			ret = nvkm_fanpwm_create(therm, &func);
 			if (ret != 0)
-				ret = nvkm_fantog_create(&therm->base, &func);
+				ret = nvkm_fantog_create(therm, &func);
 		}
 	}
 
 	/* no controllable fan found, create a dummy fan module */
 	if (ret != 0) {
-		ret = nvkm_fannil_create(&therm->base);
+		ret = nvkm_fannil_create(therm);
 		if (ret)
 			return ret;
 	}
@@ -263,7 +253,7 @@ nvkm_therm_fan_ctor(struct nvkm_therm *obj)
 	nvkm_debug(subdev, "FAN control: %s\n", therm->fan->type);
 
 	/* read the current speed, it is useful when resuming */
-	therm->fan->percent = nvkm_therm_fan_get(&therm->base);
+	therm->fan->percent = nvkm_therm_fan_get(therm);
 
 	/* attempt to detect a tachometer connection */
 	ret = nvkm_gpio_find(gpio, 0, DCB_GPIO_FAN_SENSE, 0xff,
@@ -272,18 +262,18 @@ nvkm_therm_fan_ctor(struct nvkm_therm *obj)
 		therm->fan->tach.func = DCB_GPIO_UNUSED;
 
 	/* initialise fan bump/slow update handling */
-	therm->fan->parent = &therm->base;
+	therm->fan->parent = therm;
 	nvkm_alarm_init(&therm->fan->alarm, nvkm_fan_alarm);
 	spin_lock_init(&therm->fan->lock);
 
 	/* other random init... */
-	nvkm_therm_fan_set_defaults(&therm->base);
+	nvkm_therm_fan_set_defaults(therm);
 	nvbios_perf_fan_parse(bios, &therm->fan->perf);
 	if (!nvbios_fan_parse(bios, &therm->fan->bios)) {
 		nvkm_debug(subdev, "parsing the fan table failed\n");
 		if (nvbios_therm_fan_parse(bios, &therm->fan->bios))
 			nvkm_error(subdev, "parsing both fan tables failed\n");
 	}
-	nvkm_therm_fan_safety_checks(&therm->base);
+	nvkm_therm_fan_safety_checks(therm);
 	return 0;
 }

commit 2ea7249fe2d4815fc6d0b50021bcbd8bb72b8437
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/gpio: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
index 43fff761a177..e017607673a5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
@@ -126,8 +126,9 @@ int
 nvkm_therm_fan_sense(struct nvkm_therm *obj)
 {
 	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	struct nvkm_timer *tmr = nvkm_timer(therm);
-	struct nvkm_gpio *gpio = nvkm_gpio(therm);
+	struct nvkm_device *device = therm->base.subdev.device;
+	struct nvkm_timer *tmr = device->timer;
+	struct nvkm_gpio *gpio = device->gpio;
 	u32 cycles, cur, prev;
 	u64 start, end, tach;
 
@@ -139,12 +140,14 @@ nvkm_therm_fan_sense(struct nvkm_therm *obj)
 	 * We get 4 changes (0 -> 1 -> 0 -> 1) per complete rotation.
 	 */
 	start = tmr->read(tmr);
-	prev = gpio->get(gpio, 0, therm->fan->tach.func, therm->fan->tach.line);
+	prev = nvkm_gpio_get(gpio, 0, therm->fan->tach.func,
+				      therm->fan->tach.line);
 	cycles = 0;
 	do {
 		usleep_range(500, 1000); /* supports 0 < rpm < 7500 */
 
-		cur = gpio->get(gpio, 0, therm->fan->tach.func, therm->fan->tach.line);
+		cur = nvkm_gpio_get(gpio, 0, therm->fan->tach.func,
+					     therm->fan->tach.line);
 		if (prev != cur) {
 			if (!start)
 				start = tmr->read(tmr);
@@ -237,7 +240,7 @@ nvkm_therm_fan_ctor(struct nvkm_therm *obj)
 	int ret;
 
 	/* attempt to locate a drivable fan, and determine control method */
-	ret = gpio->find(gpio, 0, DCB_GPIO_FAN, 0xff, &func);
+	ret = nvkm_gpio_find(gpio, 0, DCB_GPIO_FAN, 0xff, &func);
 	if (ret == 0) {
 		/* FIXME: is this really the place to perform such checks ? */
 		if (func.line != 16 && func.log[0] & DCB_GPIO_LOG_DIR_IN) {
@@ -263,7 +266,8 @@ nvkm_therm_fan_ctor(struct nvkm_therm *obj)
 	therm->fan->percent = nvkm_therm_fan_get(&therm->base);
 
 	/* attempt to detect a tachometer connection */
-	ret = gpio->find(gpio, 0, DCB_GPIO_FAN_SENSE, 0xff, &therm->fan->tach);
+	ret = nvkm_gpio_find(gpio, 0, DCB_GPIO_FAN_SENSE, 0xff,
+			     &therm->fan->tach);
 	if (ret)
 		therm->fan->tach.func = DCB_GPIO_UNUSED;
 

commit b3c418bb48228a206a8c421adaf269cdc83c3c52
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:12 2015 +1000

    drm/nouveau/therm: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
index 83ebf366a221..43fff761a177 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
@@ -32,7 +32,8 @@ static int
 nvkm_fan_update(struct nvkm_fan *fan, bool immediate, int target)
 {
 	struct nvkm_therm_priv *therm = (void *)fan->parent;
-	struct nvkm_timer *tmr = nvkm_timer(therm);
+	struct nvkm_subdev *subdev = &therm->base.subdev;
+	struct nvkm_timer *tmr = subdev->device->timer;
 	unsigned long flags;
 	int ret = 0;
 	int duty;
@@ -44,7 +45,7 @@ nvkm_fan_update(struct nvkm_fan *fan, bool immediate, int target)
 	target = max_t(u8, target, fan->bios.min_duty);
 	target = min_t(u8, target, fan->bios.max_duty);
 	if (fan->percent != target) {
-		nv_debug(therm, "FAN target: %d\n", target);
+		nvkm_debug(subdev, "FAN target: %d\n", target);
 		fan->percent = target;
 	}
 
@@ -69,7 +70,7 @@ nvkm_fan_update(struct nvkm_fan *fan, bool immediate, int target)
 		duty = target;
 	}
 
-	nv_debug(therm, "FAN update: %d\n", duty);
+	nvkm_debug(subdev, "FAN update: %d\n", duty);
 	ret = fan->set(&therm->base, duty);
 	if (ret) {
 		spin_unlock_irqrestore(&fan->lock, flags);
@@ -228,8 +229,10 @@ int
 nvkm_therm_fan_ctor(struct nvkm_therm *obj)
 {
 	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	struct nvkm_gpio *gpio = nvkm_gpio(therm);
-	struct nvkm_bios *bios = nvkm_bios(therm);
+	struct nvkm_subdev *subdev = &therm->base.subdev;
+	struct nvkm_device *device = subdev->device;
+	struct nvkm_gpio *gpio = device->gpio;
+	struct nvkm_bios *bios = device->bios;
 	struct dcb_gpio_func func;
 	int ret;
 
@@ -238,7 +241,7 @@ nvkm_therm_fan_ctor(struct nvkm_therm *obj)
 	if (ret == 0) {
 		/* FIXME: is this really the place to perform such checks ? */
 		if (func.line != 16 && func.log[0] & DCB_GPIO_LOG_DIR_IN) {
-			nv_debug(therm, "GPIO_FAN is in input mode\n");
+			nvkm_debug(subdev, "GPIO_FAN is in input mode\n");
 			ret = -EINVAL;
 		} else {
 			ret = nvkm_fanpwm_create(&therm->base, &func);
@@ -254,7 +257,7 @@ nvkm_therm_fan_ctor(struct nvkm_therm *obj)
 			return ret;
 	}
 
-	nv_info(therm, "FAN control: %s\n", therm->fan->type);
+	nvkm_debug(subdev, "FAN control: %s\n", therm->fan->type);
 
 	/* read the current speed, it is useful when resuming */
 	therm->fan->percent = nvkm_therm_fan_get(&therm->base);
@@ -273,9 +276,9 @@ nvkm_therm_fan_ctor(struct nvkm_therm *obj)
 	nvkm_therm_fan_set_defaults(&therm->base);
 	nvbios_perf_fan_parse(bios, &therm->fan->perf);
 	if (!nvbios_fan_parse(bios, &therm->fan->bios)) {
-		nv_debug(therm, "parsing the fan table failed\n");
+		nvkm_debug(subdev, "parsing the fan table failed\n");
 		if (nvbios_therm_fan_parse(bios, &therm->fan->bios))
-			nv_error(therm, "parsing both fan tables failed\n");
+			nvkm_error(subdev, "parsing both fan tables failed\n");
 	}
 	nvkm_therm_fan_safety_checks(&therm->base);
 	return 0;

commit cb8bb9cedb6015eafd56ef9e9c5b2c216e8e7960
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/tmr: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
index 37b9f47f663c..83ebf366a221 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
@@ -32,7 +32,7 @@ static int
 nvkm_fan_update(struct nvkm_fan *fan, bool immediate, int target)
 {
 	struct nvkm_therm_priv *therm = (void *)fan->parent;
-	struct nvkm_timer *ptimer = nvkm_timer(therm);
+	struct nvkm_timer *tmr = nvkm_timer(therm);
 	unsigned long flags;
 	int ret = 0;
 	int duty;
@@ -94,7 +94,7 @@ nvkm_fan_update(struct nvkm_fan *fan, bool immediate, int target)
 		else
 			delay = bump_period;
 
-		ptimer->alarm(ptimer, delay * 1000 * 1000, &fan->alarm);
+		tmr->alarm(tmr, delay * 1000 * 1000, &fan->alarm);
 	}
 
 	return ret;
@@ -125,7 +125,7 @@ int
 nvkm_therm_fan_sense(struct nvkm_therm *obj)
 {
 	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	struct nvkm_timer *ptimer = nvkm_timer(therm);
+	struct nvkm_timer *tmr = nvkm_timer(therm);
 	struct nvkm_gpio *gpio = nvkm_gpio(therm);
 	u32 cycles, cur, prev;
 	u64 start, end, tach;
@@ -137,7 +137,7 @@ nvkm_therm_fan_sense(struct nvkm_therm *obj)
 	 * When the fan spins, it changes the value of GPIO FAN_SENSE.
 	 * We get 4 changes (0 -> 1 -> 0 -> 1) per complete rotation.
 	 */
-	start = ptimer->read(ptimer);
+	start = tmr->read(tmr);
 	prev = gpio->get(gpio, 0, therm->fan->tach.func, therm->fan->tach.line);
 	cycles = 0;
 	do {
@@ -146,12 +146,12 @@ nvkm_therm_fan_sense(struct nvkm_therm *obj)
 		cur = gpio->get(gpio, 0, therm->fan->tach.func, therm->fan->tach.line);
 		if (prev != cur) {
 			if (!start)
-				start = ptimer->read(ptimer);
+				start = tmr->read(tmr);
 			cycles++;
 			prev = cur;
 		}
-	} while (cycles < 5 && ptimer->read(ptimer) - start < 250000000);
-	end = ptimer->read(ptimer);
+	} while (cycles < 5 && tmr->read(tmr) - start < 250000000);
+	end = tmr->read(tmr);
 
 	if (cycles == 5) {
 		tach = (u64)60000000000ULL;
@@ -217,10 +217,10 @@ int
 nvkm_therm_fan_fini(struct nvkm_therm *obj, bool suspend)
 {
 	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
-	struct nvkm_timer *ptimer = nvkm_timer(therm);
+	struct nvkm_timer *tmr = nvkm_timer(therm);
 
 	if (suspend)
-		ptimer->alarm_cancel(ptimer, &therm->fan->alarm);
+		tmr->alarm_cancel(tmr, &therm->fan->alarm);
 	return 0;
 }
 

commit da06b46b720687117178d3ee85a601762f1c36b5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/therm: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
index 434fa745ca40..37b9f47f663c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
@@ -31,9 +31,8 @@
 static int
 nvkm_fan_update(struct nvkm_fan *fan, bool immediate, int target)
 {
-	struct nvkm_therm *therm = fan->parent;
-	struct nvkm_therm_priv *priv = (void *)therm;
-	struct nvkm_timer *ptimer = nvkm_timer(priv);
+	struct nvkm_therm_priv *therm = (void *)fan->parent;
+	struct nvkm_timer *ptimer = nvkm_timer(therm);
 	unsigned long flags;
 	int ret = 0;
 	int duty;
@@ -50,7 +49,7 @@ nvkm_fan_update(struct nvkm_fan *fan, bool immediate, int target)
 	}
 
 	/* check that we're not already at the target duty cycle */
-	duty = fan->get(therm);
+	duty = fan->get(&therm->base);
 	if (duty == target) {
 		spin_unlock_irqrestore(&fan->lock, flags);
 		return 0;
@@ -71,7 +70,7 @@ nvkm_fan_update(struct nvkm_fan *fan, bool immediate, int target)
 	}
 
 	nv_debug(therm, "FAN update: %d\n", duty);
-	ret = fan->set(therm, duty);
+	ret = fan->set(&therm->base, duty);
 	if (ret) {
 		spin_unlock_irqrestore(&fan->lock, flags);
 		return ret;
@@ -109,29 +108,29 @@ nvkm_fan_alarm(struct nvkm_alarm *alarm)
 }
 
 int
-nvkm_therm_fan_get(struct nvkm_therm *therm)
+nvkm_therm_fan_get(struct nvkm_therm *obj)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
-	return priv->fan->get(therm);
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
+	return therm->fan->get(&therm->base);
 }
 
 int
-nvkm_therm_fan_set(struct nvkm_therm *therm, bool immediate, int percent)
+nvkm_therm_fan_set(struct nvkm_therm *obj, bool immediate, int percent)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
-	return nvkm_fan_update(priv->fan, immediate, percent);
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
+	return nvkm_fan_update(therm->fan, immediate, percent);
 }
 
 int
-nvkm_therm_fan_sense(struct nvkm_therm *therm)
+nvkm_therm_fan_sense(struct nvkm_therm *obj)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 	struct nvkm_timer *ptimer = nvkm_timer(therm);
 	struct nvkm_gpio *gpio = nvkm_gpio(therm);
 	u32 cycles, cur, prev;
 	u64 start, end, tach;
 
-	if (priv->fan->tach.func == DCB_GPIO_UNUSED)
+	if (therm->fan->tach.func == DCB_GPIO_UNUSED)
 		return -ENODEV;
 
 	/* Time a complete rotation and extrapolate to RPM:
@@ -139,12 +138,12 @@ nvkm_therm_fan_sense(struct nvkm_therm *therm)
 	 * We get 4 changes (0 -> 1 -> 0 -> 1) per complete rotation.
 	 */
 	start = ptimer->read(ptimer);
-	prev = gpio->get(gpio, 0, priv->fan->tach.func, priv->fan->tach.line);
+	prev = gpio->get(gpio, 0, therm->fan->tach.func, therm->fan->tach.line);
 	cycles = 0;
 	do {
 		usleep_range(500, 1000); /* supports 0 < rpm < 7500 */
 
-		cur = gpio->get(gpio, 0, priv->fan->tach.func, priv->fan->tach.line);
+		cur = gpio->get(gpio, 0, therm->fan->tach.func, therm->fan->tach.line);
 		if (prev != cur) {
 			if (!start)
 				start = ptimer->read(ptimer);
@@ -163,71 +162,72 @@ nvkm_therm_fan_sense(struct nvkm_therm *therm)
 }
 
 int
-nvkm_therm_fan_user_get(struct nvkm_therm *therm)
+nvkm_therm_fan_user_get(struct nvkm_therm *obj)
 {
-	return nvkm_therm_fan_get(therm);
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
+	return nvkm_therm_fan_get(&therm->base);
 }
 
 int
-nvkm_therm_fan_user_set(struct nvkm_therm *therm, int percent)
+nvkm_therm_fan_user_set(struct nvkm_therm *obj, int percent)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 
-	if (priv->mode != NVKM_THERM_CTRL_MANUAL)
+	if (therm->mode != NVKM_THERM_CTRL_MANUAL)
 		return -EINVAL;
 
-	return nvkm_therm_fan_set(therm, true, percent);
+	return nvkm_therm_fan_set(&therm->base, true, percent);
 }
 
 static void
-nvkm_therm_fan_set_defaults(struct nvkm_therm *therm)
+nvkm_therm_fan_set_defaults(struct nvkm_therm *obj)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
-
-	priv->fan->bios.pwm_freq = 0;
-	priv->fan->bios.min_duty = 0;
-	priv->fan->bios.max_duty = 100;
-	priv->fan->bios.bump_period = 500;
-	priv->fan->bios.slow_down_period = 2000;
-	priv->fan->bios.linear_min_temp = 40;
-	priv->fan->bios.linear_max_temp = 85;
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
+
+	therm->fan->bios.pwm_freq = 0;
+	therm->fan->bios.min_duty = 0;
+	therm->fan->bios.max_duty = 100;
+	therm->fan->bios.bump_period = 500;
+	therm->fan->bios.slow_down_period = 2000;
+	therm->fan->bios.linear_min_temp = 40;
+	therm->fan->bios.linear_max_temp = 85;
 }
 
 static void
-nvkm_therm_fan_safety_checks(struct nvkm_therm *therm)
+nvkm_therm_fan_safety_checks(struct nvkm_therm *obj)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 
-	if (priv->fan->bios.min_duty > 100)
-		priv->fan->bios.min_duty = 100;
-	if (priv->fan->bios.max_duty > 100)
-		priv->fan->bios.max_duty = 100;
+	if (therm->fan->bios.min_duty > 100)
+		therm->fan->bios.min_duty = 100;
+	if (therm->fan->bios.max_duty > 100)
+		therm->fan->bios.max_duty = 100;
 
-	if (priv->fan->bios.min_duty > priv->fan->bios.max_duty)
-		priv->fan->bios.min_duty = priv->fan->bios.max_duty;
+	if (therm->fan->bios.min_duty > therm->fan->bios.max_duty)
+		therm->fan->bios.min_duty = therm->fan->bios.max_duty;
 }
 
 int
-nvkm_therm_fan_init(struct nvkm_therm *therm)
+nvkm_therm_fan_init(struct nvkm_therm *obj)
 {
 	return 0;
 }
 
 int
-nvkm_therm_fan_fini(struct nvkm_therm *therm, bool suspend)
+nvkm_therm_fan_fini(struct nvkm_therm *obj, bool suspend)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 	struct nvkm_timer *ptimer = nvkm_timer(therm);
 
 	if (suspend)
-		ptimer->alarm_cancel(ptimer, &priv->fan->alarm);
+		ptimer->alarm_cancel(ptimer, &therm->fan->alarm);
 	return 0;
 }
 
 int
-nvkm_therm_fan_ctor(struct nvkm_therm *therm)
+nvkm_therm_fan_ctor(struct nvkm_therm *obj)
 {
-	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *therm = container_of(obj, typeof(*therm), base);
 	struct nvkm_gpio *gpio = nvkm_gpio(therm);
 	struct nvkm_bios *bios = nvkm_bios(therm);
 	struct dcb_gpio_func func;
@@ -241,42 +241,42 @@ nvkm_therm_fan_ctor(struct nvkm_therm *therm)
 			nv_debug(therm, "GPIO_FAN is in input mode\n");
 			ret = -EINVAL;
 		} else {
-			ret = nvkm_fanpwm_create(therm, &func);
+			ret = nvkm_fanpwm_create(&therm->base, &func);
 			if (ret != 0)
-				ret = nvkm_fantog_create(therm, &func);
+				ret = nvkm_fantog_create(&therm->base, &func);
 		}
 	}
 
 	/* no controllable fan found, create a dummy fan module */
 	if (ret != 0) {
-		ret = nvkm_fannil_create(therm);
+		ret = nvkm_fannil_create(&therm->base);
 		if (ret)
 			return ret;
 	}
 
-	nv_info(therm, "FAN control: %s\n", priv->fan->type);
+	nv_info(therm, "FAN control: %s\n", therm->fan->type);
 
 	/* read the current speed, it is useful when resuming */
-	priv->fan->percent = nvkm_therm_fan_get(therm);
+	therm->fan->percent = nvkm_therm_fan_get(&therm->base);
 
 	/* attempt to detect a tachometer connection */
-	ret = gpio->find(gpio, 0, DCB_GPIO_FAN_SENSE, 0xff, &priv->fan->tach);
+	ret = gpio->find(gpio, 0, DCB_GPIO_FAN_SENSE, 0xff, &therm->fan->tach);
 	if (ret)
-		priv->fan->tach.func = DCB_GPIO_UNUSED;
+		therm->fan->tach.func = DCB_GPIO_UNUSED;
 
 	/* initialise fan bump/slow update handling */
-	priv->fan->parent = therm;
-	nvkm_alarm_init(&priv->fan->alarm, nvkm_fan_alarm);
-	spin_lock_init(&priv->fan->lock);
+	therm->fan->parent = &therm->base;
+	nvkm_alarm_init(&therm->fan->alarm, nvkm_fan_alarm);
+	spin_lock_init(&therm->fan->lock);
 
 	/* other random init... */
-	nvkm_therm_fan_set_defaults(therm);
-	nvbios_perf_fan_parse(bios, &priv->fan->perf);
-	if (!nvbios_fan_parse(bios, &priv->fan->bios)) {
+	nvkm_therm_fan_set_defaults(&therm->base);
+	nvbios_perf_fan_parse(bios, &therm->fan->perf);
+	if (!nvbios_fan_parse(bios, &therm->fan->bios)) {
 		nv_debug(therm, "parsing the fan table failed\n");
-		if (nvbios_therm_fan_parse(bios, &priv->fan->bios))
+		if (nvbios_therm_fan_parse(bios, &therm->fan->bios))
 			nv_error(therm, "parsing both fan tables failed\n");
 	}
-	nvkm_therm_fan_safety_checks(therm);
+	nvkm_therm_fan_safety_checks(&therm->base);
 	return 0;
 }

commit e1404611d5f6a7c75e2b745f5eb7fbcdd23751c5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:11:48 2015 +1000

    drm/nouveau/therm: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
index 3656d605168f..434fa745ca40 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
@@ -22,23 +22,18 @@
  * Authors: Ben Skeggs
  * 	    Martin Peres
  */
-
 #include "priv.h"
 
-#include <core/object.h>
-#include <core/device.h>
-
+#include <subdev/bios/fan.h>
 #include <subdev/gpio.h>
 #include <subdev/timer.h>
 
-#include <subdev/bios/fan.h>
-
 static int
-nouveau_fan_update(struct nouveau_fan *fan, bool immediate, int target)
+nvkm_fan_update(struct nvkm_fan *fan, bool immediate, int target)
 {
-	struct nouveau_therm *therm = fan->parent;
-	struct nouveau_therm_priv *priv = (void *)therm;
-	struct nouveau_timer *ptimer = nouveau_timer(priv);
+	struct nvkm_therm *therm = fan->parent;
+	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_timer *ptimer = nvkm_timer(priv);
 	unsigned long flags;
 	int ret = 0;
 	int duty;
@@ -107,32 +102,32 @@ nouveau_fan_update(struct nouveau_fan *fan, bool immediate, int target)
 }
 
 static void
-nouveau_fan_alarm(struct nouveau_alarm *alarm)
+nvkm_fan_alarm(struct nvkm_alarm *alarm)
 {
-	struct nouveau_fan *fan = container_of(alarm, struct nouveau_fan, alarm);
-	nouveau_fan_update(fan, false, -1);
+	struct nvkm_fan *fan = container_of(alarm, struct nvkm_fan, alarm);
+	nvkm_fan_update(fan, false, -1);
 }
 
 int
-nouveau_therm_fan_get(struct nouveau_therm *therm)
+nvkm_therm_fan_get(struct nvkm_therm *therm)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *priv = (void *)therm;
 	return priv->fan->get(therm);
 }
 
 int
-nouveau_therm_fan_set(struct nouveau_therm *therm, bool immediate, int percent)
+nvkm_therm_fan_set(struct nvkm_therm *therm, bool immediate, int percent)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
-	return nouveau_fan_update(priv->fan, immediate, percent);
+	struct nvkm_therm_priv *priv = (void *)therm;
+	return nvkm_fan_update(priv->fan, immediate, percent);
 }
 
 int
-nouveau_therm_fan_sense(struct nouveau_therm *therm)
+nvkm_therm_fan_sense(struct nvkm_therm *therm)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
-	struct nouveau_timer *ptimer = nouveau_timer(therm);
-	struct nouveau_gpio *gpio = nouveau_gpio(therm);
+	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_timer *ptimer = nvkm_timer(therm);
+	struct nvkm_gpio *gpio = nvkm_gpio(therm);
 	u32 cycles, cur, prev;
 	u64 start, end, tach;
 
@@ -168,26 +163,26 @@ nouveau_therm_fan_sense(struct nouveau_therm *therm)
 }
 
 int
-nouveau_therm_fan_user_get(struct nouveau_therm *therm)
+nvkm_therm_fan_user_get(struct nvkm_therm *therm)
 {
-	return nouveau_therm_fan_get(therm);
+	return nvkm_therm_fan_get(therm);
 }
 
 int
-nouveau_therm_fan_user_set(struct nouveau_therm *therm, int percent)
+nvkm_therm_fan_user_set(struct nvkm_therm *therm, int percent)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *priv = (void *)therm;
 
-	if (priv->mode != NOUVEAU_THERM_CTRL_MANUAL)
+	if (priv->mode != NVKM_THERM_CTRL_MANUAL)
 		return -EINVAL;
 
-	return nouveau_therm_fan_set(therm, true, percent);
+	return nvkm_therm_fan_set(therm, true, percent);
 }
 
 static void
-nouveau_therm_fan_set_defaults(struct nouveau_therm *therm)
+nvkm_therm_fan_set_defaults(struct nvkm_therm *therm)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *priv = (void *)therm;
 
 	priv->fan->bios.pwm_freq = 0;
 	priv->fan->bios.min_duty = 0;
@@ -199,9 +194,9 @@ nouveau_therm_fan_set_defaults(struct nouveau_therm *therm)
 }
 
 static void
-nouveau_therm_fan_safety_checks(struct nouveau_therm *therm)
+nvkm_therm_fan_safety_checks(struct nvkm_therm *therm)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvkm_therm_priv *priv = (void *)therm;
 
 	if (priv->fan->bios.min_duty > 100)
 		priv->fan->bios.min_duty = 100;
@@ -213,16 +208,16 @@ nouveau_therm_fan_safety_checks(struct nouveau_therm *therm)
 }
 
 int
-nouveau_therm_fan_init(struct nouveau_therm *therm)
+nvkm_therm_fan_init(struct nvkm_therm *therm)
 {
 	return 0;
 }
 
 int
-nouveau_therm_fan_fini(struct nouveau_therm *therm, bool suspend)
+nvkm_therm_fan_fini(struct nvkm_therm *therm, bool suspend)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
-	struct nouveau_timer *ptimer = nouveau_timer(therm);
+	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_timer *ptimer = nvkm_timer(therm);
 
 	if (suspend)
 		ptimer->alarm_cancel(ptimer, &priv->fan->alarm);
@@ -230,11 +225,11 @@ nouveau_therm_fan_fini(struct nouveau_therm *therm, bool suspend)
 }
 
 int
-nouveau_therm_fan_ctor(struct nouveau_therm *therm)
+nvkm_therm_fan_ctor(struct nvkm_therm *therm)
 {
-	struct nouveau_therm_priv *priv = (void *)therm;
-	struct nouveau_gpio *gpio = nouveau_gpio(therm);
-	struct nouveau_bios *bios = nouveau_bios(therm);
+	struct nvkm_therm_priv *priv = (void *)therm;
+	struct nvkm_gpio *gpio = nvkm_gpio(therm);
+	struct nvkm_bios *bios = nvkm_bios(therm);
 	struct dcb_gpio_func func;
 	int ret;
 
@@ -246,15 +241,15 @@ nouveau_therm_fan_ctor(struct nouveau_therm *therm)
 			nv_debug(therm, "GPIO_FAN is in input mode\n");
 			ret = -EINVAL;
 		} else {
-			ret = nouveau_fanpwm_create(therm, &func);
+			ret = nvkm_fanpwm_create(therm, &func);
 			if (ret != 0)
-				ret = nouveau_fantog_create(therm, &func);
+				ret = nvkm_fantog_create(therm, &func);
 		}
 	}
 
 	/* no controllable fan found, create a dummy fan module */
 	if (ret != 0) {
-		ret = nouveau_fannil_create(therm);
+		ret = nvkm_fannil_create(therm);
 		if (ret)
 			return ret;
 	}
@@ -262,7 +257,7 @@ nouveau_therm_fan_ctor(struct nouveau_therm *therm)
 	nv_info(therm, "FAN control: %s\n", priv->fan->type);
 
 	/* read the current speed, it is useful when resuming */
-	priv->fan->percent = nouveau_therm_fan_get(therm);
+	priv->fan->percent = nvkm_therm_fan_get(therm);
 
 	/* attempt to detect a tachometer connection */
 	ret = gpio->find(gpio, 0, DCB_GPIO_FAN_SENSE, 0xff, &priv->fan->tach);
@@ -271,17 +266,17 @@ nouveau_therm_fan_ctor(struct nouveau_therm *therm)
 
 	/* initialise fan bump/slow update handling */
 	priv->fan->parent = therm;
-	nouveau_alarm_init(&priv->fan->alarm, nouveau_fan_alarm);
+	nvkm_alarm_init(&priv->fan->alarm, nvkm_fan_alarm);
 	spin_lock_init(&priv->fan->lock);
 
 	/* other random init... */
-	nouveau_therm_fan_set_defaults(therm);
+	nvkm_therm_fan_set_defaults(therm);
 	nvbios_perf_fan_parse(bios, &priv->fan->perf);
 	if (!nvbios_fan_parse(bios, &priv->fan->bios)) {
 		nv_debug(therm, "parsing the fan table failed\n");
 		if (nvbios_therm_fan_parse(bios, &priv->fan->bios))
 			nv_error(therm, "parsing both fan tables failed\n");
 	}
-	nouveau_therm_fan_safety_checks(therm);
+	nvkm_therm_fan_safety_checks(therm);
 	return 0;
 }

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
new file mode 100644
index 000000000000..3656d605168f
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c
@@ -0,0 +1,287 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ * 	    Martin Peres
+ */
+
+#include "priv.h"
+
+#include <core/object.h>
+#include <core/device.h>
+
+#include <subdev/gpio.h>
+#include <subdev/timer.h>
+
+#include <subdev/bios/fan.h>
+
+static int
+nouveau_fan_update(struct nouveau_fan *fan, bool immediate, int target)
+{
+	struct nouveau_therm *therm = fan->parent;
+	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nouveau_timer *ptimer = nouveau_timer(priv);
+	unsigned long flags;
+	int ret = 0;
+	int duty;
+
+	/* update target fan speed, restricting to allowed range */
+	spin_lock_irqsave(&fan->lock, flags);
+	if (target < 0)
+		target = fan->percent;
+	target = max_t(u8, target, fan->bios.min_duty);
+	target = min_t(u8, target, fan->bios.max_duty);
+	if (fan->percent != target) {
+		nv_debug(therm, "FAN target: %d\n", target);
+		fan->percent = target;
+	}
+
+	/* check that we're not already at the target duty cycle */
+	duty = fan->get(therm);
+	if (duty == target) {
+		spin_unlock_irqrestore(&fan->lock, flags);
+		return 0;
+	}
+
+	/* smooth out the fanspeed increase/decrease */
+	if (!immediate && duty >= 0) {
+		/* the constant "3" is a rough approximation taken from
+		 * nvidia's behaviour.
+		 * it is meant to bump the fan speed more incrementally
+		 */
+		if (duty < target)
+			duty = min(duty + 3, target);
+		else if (duty > target)
+			duty = max(duty - 3, target);
+	} else {
+		duty = target;
+	}
+
+	nv_debug(therm, "FAN update: %d\n", duty);
+	ret = fan->set(therm, duty);
+	if (ret) {
+		spin_unlock_irqrestore(&fan->lock, flags);
+		return ret;
+	}
+
+	/* fan speed updated, drop the fan lock before grabbing the
+	 * alarm-scheduling lock and risking a deadlock
+	 */
+	spin_unlock_irqrestore(&fan->lock, flags);
+
+	/* schedule next fan update, if not at target speed already */
+	if (list_empty(&fan->alarm.head) && target != duty) {
+		u16 bump_period = fan->bios.bump_period;
+		u16 slow_down_period = fan->bios.slow_down_period;
+		u64 delay;
+
+		if (duty > target)
+			delay = slow_down_period;
+		else if (duty == target)
+			delay = min(bump_period, slow_down_period) ;
+		else
+			delay = bump_period;
+
+		ptimer->alarm(ptimer, delay * 1000 * 1000, &fan->alarm);
+	}
+
+	return ret;
+}
+
+static void
+nouveau_fan_alarm(struct nouveau_alarm *alarm)
+{
+	struct nouveau_fan *fan = container_of(alarm, struct nouveau_fan, alarm);
+	nouveau_fan_update(fan, false, -1);
+}
+
+int
+nouveau_therm_fan_get(struct nouveau_therm *therm)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	return priv->fan->get(therm);
+}
+
+int
+nouveau_therm_fan_set(struct nouveau_therm *therm, bool immediate, int percent)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	return nouveau_fan_update(priv->fan, immediate, percent);
+}
+
+int
+nouveau_therm_fan_sense(struct nouveau_therm *therm)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nouveau_timer *ptimer = nouveau_timer(therm);
+	struct nouveau_gpio *gpio = nouveau_gpio(therm);
+	u32 cycles, cur, prev;
+	u64 start, end, tach;
+
+	if (priv->fan->tach.func == DCB_GPIO_UNUSED)
+		return -ENODEV;
+
+	/* Time a complete rotation and extrapolate to RPM:
+	 * When the fan spins, it changes the value of GPIO FAN_SENSE.
+	 * We get 4 changes (0 -> 1 -> 0 -> 1) per complete rotation.
+	 */
+	start = ptimer->read(ptimer);
+	prev = gpio->get(gpio, 0, priv->fan->tach.func, priv->fan->tach.line);
+	cycles = 0;
+	do {
+		usleep_range(500, 1000); /* supports 0 < rpm < 7500 */
+
+		cur = gpio->get(gpio, 0, priv->fan->tach.func, priv->fan->tach.line);
+		if (prev != cur) {
+			if (!start)
+				start = ptimer->read(ptimer);
+			cycles++;
+			prev = cur;
+		}
+	} while (cycles < 5 && ptimer->read(ptimer) - start < 250000000);
+	end = ptimer->read(ptimer);
+
+	if (cycles == 5) {
+		tach = (u64)60000000000ULL;
+		do_div(tach, (end - start));
+		return tach;
+	} else
+		return 0;
+}
+
+int
+nouveau_therm_fan_user_get(struct nouveau_therm *therm)
+{
+	return nouveau_therm_fan_get(therm);
+}
+
+int
+nouveau_therm_fan_user_set(struct nouveau_therm *therm, int percent)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+
+	if (priv->mode != NOUVEAU_THERM_CTRL_MANUAL)
+		return -EINVAL;
+
+	return nouveau_therm_fan_set(therm, true, percent);
+}
+
+static void
+nouveau_therm_fan_set_defaults(struct nouveau_therm *therm)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+
+	priv->fan->bios.pwm_freq = 0;
+	priv->fan->bios.min_duty = 0;
+	priv->fan->bios.max_duty = 100;
+	priv->fan->bios.bump_period = 500;
+	priv->fan->bios.slow_down_period = 2000;
+	priv->fan->bios.linear_min_temp = 40;
+	priv->fan->bios.linear_max_temp = 85;
+}
+
+static void
+nouveau_therm_fan_safety_checks(struct nouveau_therm *therm)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+
+	if (priv->fan->bios.min_duty > 100)
+		priv->fan->bios.min_duty = 100;
+	if (priv->fan->bios.max_duty > 100)
+		priv->fan->bios.max_duty = 100;
+
+	if (priv->fan->bios.min_duty > priv->fan->bios.max_duty)
+		priv->fan->bios.min_duty = priv->fan->bios.max_duty;
+}
+
+int
+nouveau_therm_fan_init(struct nouveau_therm *therm)
+{
+	return 0;
+}
+
+int
+nouveau_therm_fan_fini(struct nouveau_therm *therm, bool suspend)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nouveau_timer *ptimer = nouveau_timer(therm);
+
+	if (suspend)
+		ptimer->alarm_cancel(ptimer, &priv->fan->alarm);
+	return 0;
+}
+
+int
+nouveau_therm_fan_ctor(struct nouveau_therm *therm)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nouveau_gpio *gpio = nouveau_gpio(therm);
+	struct nouveau_bios *bios = nouveau_bios(therm);
+	struct dcb_gpio_func func;
+	int ret;
+
+	/* attempt to locate a drivable fan, and determine control method */
+	ret = gpio->find(gpio, 0, DCB_GPIO_FAN, 0xff, &func);
+	if (ret == 0) {
+		/* FIXME: is this really the place to perform such checks ? */
+		if (func.line != 16 && func.log[0] & DCB_GPIO_LOG_DIR_IN) {
+			nv_debug(therm, "GPIO_FAN is in input mode\n");
+			ret = -EINVAL;
+		} else {
+			ret = nouveau_fanpwm_create(therm, &func);
+			if (ret != 0)
+				ret = nouveau_fantog_create(therm, &func);
+		}
+	}
+
+	/* no controllable fan found, create a dummy fan module */
+	if (ret != 0) {
+		ret = nouveau_fannil_create(therm);
+		if (ret)
+			return ret;
+	}
+
+	nv_info(therm, "FAN control: %s\n", priv->fan->type);
+
+	/* read the current speed, it is useful when resuming */
+	priv->fan->percent = nouveau_therm_fan_get(therm);
+
+	/* attempt to detect a tachometer connection */
+	ret = gpio->find(gpio, 0, DCB_GPIO_FAN_SENSE, 0xff, &priv->fan->tach);
+	if (ret)
+		priv->fan->tach.func = DCB_GPIO_UNUSED;
+
+	/* initialise fan bump/slow update handling */
+	priv->fan->parent = therm;
+	nouveau_alarm_init(&priv->fan->alarm, nouveau_fan_alarm);
+	spin_lock_init(&priv->fan->lock);
+
+	/* other random init... */
+	nouveau_therm_fan_set_defaults(therm);
+	nvbios_perf_fan_parse(bios, &priv->fan->perf);
+	if (!nvbios_fan_parse(bios, &priv->fan->bios)) {
+		nv_debug(therm, "parsing the fan table failed\n");
+		if (nvbios_therm_fan_parse(bios, &priv->fan->bios))
+			nv_error(therm, "parsing both fan tables failed\n");
+	}
+	nouveau_therm_fan_safety_checks(therm);
+	return 0;
+}
