commit c3463aed05abf06bd5ebaac12f2c015db298b98f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 29 11:29:05 2020 +1000

    drm/nouveau/fb/gp102-: allow module to load even when scrubber binary is missing
    
    Without relaxing this requirement, TU10x boards will fail to load without
    an updated linux-firmware, and TU11x will completely fail to load because
    FW isn't available yet.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index d09db7c6b7ee..5940e0dea2f8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -125,6 +125,34 @@ nvkm_fb_oneinit(struct nvkm_subdev *subdev)
 	return nvkm_mm_init(&fb->tags, 0, 0, tags, 1);
 }
 
+static int
+nvkm_fb_init_scrub_vpr(struct nvkm_fb *fb)
+{
+	struct nvkm_subdev *subdev = &fb->subdev;
+	int ret;
+
+	nvkm_debug(subdev, "VPR locked, running scrubber binary\n");
+
+	if (!fb->vpr_scrubber.size) {
+		nvkm_warn(subdev, "VPR locked, but no scrubber binary!\n");
+		return 0;
+	}
+
+	ret = fb->func->vpr.scrub(fb);
+	if (ret) {
+		nvkm_error(subdev, "VPR scrubber binary failed\n");
+		return ret;
+	}
+
+	if (fb->func->vpr.scrub_required(fb)) {
+		nvkm_error(subdev, "VPR still locked after scrub!\n");
+		return -EIO;
+	}
+
+	nvkm_debug(subdev, "VPR scrubber binary successful\n");
+	return 0;
+}
+
 static int
 nvkm_fb_init(struct nvkm_subdev *subdev)
 {
@@ -157,18 +185,9 @@ nvkm_fb_init(struct nvkm_subdev *subdev)
 
 	if (fb->func->vpr.scrub_required &&
 	    fb->func->vpr.scrub_required(fb)) {
-		nvkm_debug(subdev, "VPR locked, running scrubber binary\n");
-
-		ret = fb->func->vpr.scrub(fb);
+		ret = nvkm_fb_init_scrub_vpr(fb);
 		if (ret)
 			return ret;
-
-		if (fb->func->vpr.scrub_required(fb)) {
-			nvkm_error(subdev, "VPR still locked after scrub!\n");
-			return -EIO;
-		}
-
-		nvkm_debug(subdev, "VPR scrubber binary successful\n");
 	}
 
 	return 0;

commit ebe52a58acca308142ba2811e50a1b3bf047240d
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 15 06:34:22 2020 +1000

    drm/nouveau/fb/gp102-: unlock VPR as part of FB init
    
    We perform memory allocations long before we hit the code in SECBOOT that
    would unlock the VPR, which could potentially result in memory allocation
    within the locked region.
    
    Run the scrubber binary right after VRAM init to ensure we don't.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index b2bb5a3ccb02..d09db7c6b7ee 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -154,6 +154,23 @@ nvkm_fb_init(struct nvkm_subdev *subdev)
 
 	if (fb->func->init_unkn)
 		fb->func->init_unkn(fb);
+
+	if (fb->func->vpr.scrub_required &&
+	    fb->func->vpr.scrub_required(fb)) {
+		nvkm_debug(subdev, "VPR locked, running scrubber binary\n");
+
+		ret = fb->func->vpr.scrub(fb);
+		if (ret)
+			return ret;
+
+		if (fb->func->vpr.scrub_required(fb)) {
+			nvkm_error(subdev, "VPR still locked after scrub!\n");
+			return -EIO;
+		}
+
+		nvkm_debug(subdev, "VPR scrubber binary successful\n");
+	}
+
 	return 0;
 }
 
@@ -172,6 +189,8 @@ nvkm_fb_dtor(struct nvkm_subdev *subdev)
 	nvkm_mm_fini(&fb->tags);
 	nvkm_ram_del(&fb->ram);
 
+	nvkm_blob_dtor(&fb->vpr_scrubber);
+
 	if (fb->func->dtor)
 		return fb->func->dtor(fb);
 	return fb;

commit 2d5257b73e1ac97e1ead4328940cd10d8b4956ee
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Dec 11 14:50:02 2018 +1000

    drm/nouveau/bios: translate additional memory types
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index 434d2fc5bb1c..b2bb5a3ccb02 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -68,10 +68,13 @@ nvkm_fb_bios_memtype(struct nvkm_bios *bios)
 
 	if (nvbios_M0203Em(bios, ramcfg, &ver, &hdr, &M0203E)) {
 		switch (M0203E.type) {
-		case M0203E_TYPE_DDR2 : return NVKM_RAM_TYPE_DDR2;
-		case M0203E_TYPE_DDR3 : return NVKM_RAM_TYPE_DDR3;
-		case M0203E_TYPE_GDDR3: return NVKM_RAM_TYPE_GDDR3;
-		case M0203E_TYPE_GDDR5: return NVKM_RAM_TYPE_GDDR5;
+		case M0203E_TYPE_DDR2  : return NVKM_RAM_TYPE_DDR2;
+		case M0203E_TYPE_DDR3  : return NVKM_RAM_TYPE_DDR3;
+		case M0203E_TYPE_GDDR3 : return NVKM_RAM_TYPE_GDDR3;
+		case M0203E_TYPE_GDDR5 : return NVKM_RAM_TYPE_GDDR5;
+		case M0203E_TYPE_GDDR5X: return NVKM_RAM_TYPE_GDDR5X;
+		case M0203E_TYPE_GDDR6 : return NVKM_RAM_TYPE_GDDR6;
+		case M0203E_TYPE_HBM2  : return NVKM_RAM_TYPE_HBM2;
 		default:
 			nvkm_warn(subdev, "M0203E type %02x\n", M0203E.type);
 			return NVKM_RAM_TYPE_UNKNOWN;

commit 2f958e8240be28acee26085ba1686b4321ba4306
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jul 18 16:10:58 2018 +1000

    drm/nouveau/fb/gp100-: disable address remapper
    
    This was causing problems on a system with a large amount of RAM, where
    display push buffers were being fetched incorrectly when placed in high
    system memory addresses.
    
    While this commit will resolve the issue on that particular system, the
    issue will be avoided completely with another patch to more fully solve
    problems with display and large amounts of system memory on Pascal.
    
    It's still probably a good idea to disable this to prevent weird issues
    in the future.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index 73b5d46104bd..434d2fc5bb1c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -140,6 +140,9 @@ nvkm_fb_init(struct nvkm_subdev *subdev)
 	if (fb->func->init)
 		fb->func->init(fb);
 
+	if (fb->func->init_remapper)
+		fb->func->init_remapper(fb);
+
 	if (fb->func->init_page) {
 		ret = fb->func->init_page(fb);
 		if (WARN_ON(ret))

commit 632b740c5481988152a3a60319aaa49c99577b77
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:20 2017 +1000

    drm/nouveau/mmu: remove old vmm frontend
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index 78248e21a5f0..73b5d46104bd 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -31,12 +31,6 @@
 #include <engine/gr.h>
 #include <engine/mpeg.h>
 
-bool
-nvkm_fb_memtype_valid(struct nvkm_fb *fb, u32 memtype)
-{
-	return fb->func->memtype_valid(fb, memtype);
-}
-
 void
 nvkm_fb_tile_fini(struct nvkm_fb *fb, int region, struct nvkm_fb_tile *tile)
 {

commit 997a89003c2d950466bc289147ffb823c0c51fb0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/core/memory: add reference counting
    
    We need to be able to prevent memory from being freed while it's still
    mapped in a GPU's address-space.
    
    Will be used by upcoming MMU changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index 94c53454501d..78248e21a5f0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -163,8 +163,8 @@ nvkm_fb_dtor(struct nvkm_subdev *subdev)
 	struct nvkm_fb *fb = nvkm_fb(subdev);
 	int i;
 
-	nvkm_memory_del(&fb->mmu_wr);
-	nvkm_memory_del(&fb->mmu_rd);
+	nvkm_memory_unref(&fb->mmu_wr);
+	nvkm_memory_unref(&fb->mmu_rd);
 
 	for (i = 0; i < fb->tile.regions; i++)
 		fb->func->tile.fini(fb, i, &fb->tile.region[i]);

commit af793b8cd9f62880852379897519bbe69fb59c05
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/fb: move comptag init out of ram submodule
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index dea04406816d..94c53454501d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -100,6 +100,7 @@ static int
 nvkm_fb_oneinit(struct nvkm_subdev *subdev)
 {
 	struct nvkm_fb *fb = nvkm_fb(subdev);
+	u32 tags = 0;
 
 	if (fb->func->ram_new) {
 		int ret = fb->func->ram_new(fb, &fb->ram);
@@ -115,7 +116,16 @@ nvkm_fb_oneinit(struct nvkm_subdev *subdev)
 			return ret;
 	}
 
-	return 0;
+	/* Initialise compression tag allocator.
+	 *
+	 * LTC oneinit() will override this on Fermi and newer.
+	 */
+	if (fb->func->tags) {
+		tags = fb->func->tags(fb);
+		nvkm_debug(subdev, "%d comptags\n", tags);
+	}
+
+	return nvkm_mm_init(&fb->tags, 0, 0, tags, 1);
 }
 
 static int

commit 7ef44bee64c68db7b7bc0cb341eec41891c6d0a5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/fb: move comptags mm into nvkm_fb
    
    We're moving towards having a central place to handle comptag allocation,
    and as some GPUs don't have a ram submodule (ie. Tegra), we need to move
    the mm somewhere else.
    
    It probably never belonged in ram anyways.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index fa0fad10b62c..dea04406816d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -159,6 +159,7 @@ nvkm_fb_dtor(struct nvkm_subdev *subdev)
 	for (i = 0; i < fb->tile.regions; i++)
 		fb->func->tile.fini(fb, i, &fb->tile.region[i]);
 
+	nvkm_mm_fini(&fb->tags);
 	nvkm_ram_del(&fb->ram);
 
 	if (fb->func->dtor)

commit 2854ab8dd81b73ffd867399fd506f44f6f624bca
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/fb: finalise big page size selection in constructor
    
    MMU will need to know this during its constructor, so we can't delay
    deciding this until init-time.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index a7049c041594..fa0fad10b62c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -135,8 +135,13 @@ nvkm_fb_init(struct nvkm_subdev *subdev)
 
 	if (fb->func->init)
 		fb->func->init(fb);
-	if (fb->func->init_page)
-		fb->func->init_page(fb);
+
+	if (fb->func->init_page) {
+		ret = fb->func->init_page(fb);
+		if (WARN_ON(ret))
+			return ret;
+	}
+
 	if (fb->func->init_unkn)
 		fb->func->init_unkn(fb);
 	return 0;
@@ -176,7 +181,8 @@ nvkm_fb_ctor(const struct nvkm_fb_func *func, struct nvkm_device *device,
 	nvkm_subdev_ctor(&nvkm_fb, device, index, &fb->subdev);
 	fb->func = func;
 	fb->tile.regions = fb->func->tile.regions;
-	fb->page = nvkm_longopt(device->cfgopt, "NvFbBigPage", 0);
+	fb->page = nvkm_longopt(device->cfgopt, "NvFbBigPage",
+				fb->func->default_bigpage);
 }
 
 int

commit 7ff51f8200f40911902ede518298e90528b57260
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sat Jul 9 10:41:01 2016 +1000

    drm/nouveau/fb/gp100: initial support
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index 4742e5ee37ac..a7049c041594 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -137,6 +137,8 @@ nvkm_fb_init(struct nvkm_subdev *subdev)
 		fb->func->init(fb);
 	if (fb->func->init_page)
 		fb->func->init_page(fb);
+	if (fb->func->init_unkn)
+		fb->func->init_unkn(fb);
 	return 0;
 }
 

commit c73baa831fe5c035a41e52d75b763b3c942fa6d0
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sat Jul 9 10:41:01 2016 +1000

    drm/nouveau/fb/gf100-: allow selection of an alternate big page size
    
    GFxxx/GM1xx support the selection of 64/128KiB big pages globally.
    
    GM2xx supports the same, as well as another mode where the page size
    can be selected per-instance.
    
    We default to 128KiB pages (With per-instance for GM200, but the current
    code selects 128KiB there already) as the MMU code isn't currently able
    to handle otherwise.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index ce90242b8cce..4742e5ee37ac 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -25,6 +25,7 @@
 #include "ram.h"
 
 #include <core/memory.h>
+#include <core/option.h>
 #include <subdev/bios.h>
 #include <subdev/bios/M0203.h>
 #include <engine/gr.h>
@@ -134,6 +135,8 @@ nvkm_fb_init(struct nvkm_subdev *subdev)
 
 	if (fb->func->init)
 		fb->func->init(fb);
+	if (fb->func->init_page)
+		fb->func->init_page(fb);
 	return 0;
 }
 
@@ -171,6 +174,7 @@ nvkm_fb_ctor(const struct nvkm_fb_func *func, struct nvkm_device *device,
 	nvkm_subdev_ctor(&nvkm_fb, device, index, &fb->subdev);
 	fb->func = func;
 	fb->tile.regions = fb->func->tile.regions;
+	fb->page = nvkm_longopt(device->cfgopt, "NvFbBigPage", 0);
 }
 
 int

commit 99c5917253a6c5584a7052f9ee578e2c6852253f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Apr 14 10:39:18 2016 +1000

    drm/nouveau/fb/gf100-: allocate mmu debug buffers
    
    Later chipsets require setting this up both in FB and GR, so let's just
    move the allocation to FB.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index f1a1a52aab12..ce90242b8cce 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -24,6 +24,7 @@
 #include "priv.h"
 #include "ram.h"
 
+#include <core/memory.h>
 #include <subdev/bios.h>
 #include <subdev/bios/M0203.h>
 #include <engine/gr.h>
@@ -142,6 +143,9 @@ nvkm_fb_dtor(struct nvkm_subdev *subdev)
 	struct nvkm_fb *fb = nvkm_fb(subdev);
 	int i;
 
+	nvkm_memory_del(&fb->mmu_wr);
+	nvkm_memory_del(&fb->mmu_rd);
+
 	for (i = 0; i < fb->tile.regions; i++)
 		fb->func->tile.fini(fb, i, &fb->tile.region[i]);
 

commit 917d95a86e7b7036d481323240443566be82a619
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Apr 14 10:38:55 2016 +1000

    drm/nouveau/fb: allow chipset-specific actions for oneinit()
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index 9ee587258557..f1a1a52aab12 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -98,6 +98,7 @@ static int
 nvkm_fb_oneinit(struct nvkm_subdev *subdev)
 {
 	struct nvkm_fb *fb = nvkm_fb(subdev);
+
 	if (fb->func->ram_new) {
 		int ret = fb->func->ram_new(fb, &fb->ram);
 		if (ret) {
@@ -105,6 +106,13 @@ nvkm_fb_oneinit(struct nvkm_subdev *subdev)
 			return ret;
 		}
 	}
+
+	if (fb->func->oneinit) {
+		int ret = fb->func->oneinit(fb);
+		if (ret)
+			return ret;
+	}
+
 	return 0;
 }
 

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index a719b9becb73..9ee587258557 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -156,7 +156,7 @@ void
 nvkm_fb_ctor(const struct nvkm_fb_func *func, struct nvkm_device *device,
 	     int index, struct nvkm_fb *fb)
 {
-	nvkm_subdev_ctor(&nvkm_fb, device, index, 0, &fb->subdev);
+	nvkm_subdev_ctor(&nvkm_fb, device, index, &fb->subdev);
 	fb->func = func;
 	fb->tile.regions = fb->func->tile.regions;
 }

commit 7624fc011e56902a83e409b14d6c1efa75aa4a58
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/mpeg: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index 1ca02f870095..a719b9becb73 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -56,8 +56,8 @@ nvkm_fb_tile_prog(struct nvkm_fb *fb, int region, struct nvkm_fb_tile *tile)
 		fb->func->tile.prog(fb, region, tile);
 		if (device->gr)
 			nvkm_engine_tile(&device->gr->engine, region);
-		if (likely(device->mpeg))
-			device->mpeg->tile_prog(device->mpeg, region);
+		if (device->mpeg)
+			nvkm_engine_tile(device->mpeg, region);
 	}
 }
 

commit c85ee6ca79590cd51356bf24fb8936bc352138cf
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:22 2015 +1000

    drm/nouveau/gr: convert to new-style nvkm_engine
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index 0f39ff883ec0..1ca02f870095 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -52,11 +52,13 @@ void
 nvkm_fb_tile_prog(struct nvkm_fb *fb, int region, struct nvkm_fb_tile *tile)
 {
 	struct nvkm_device *device = fb->subdev.device;
-	fb->func->tile.prog(fb, region, tile);
-	if (likely(device->gr))
-		device->gr->engine.tile_prog(&device->gr->engine, region);
-	if (likely(device->mpeg))
-		device->mpeg->tile_prog(device->mpeg, region);
+	if (fb->func->tile.prog) {
+		fb->func->tile.prog(fb, region, tile);
+		if (device->gr)
+			nvkm_engine_tile(&device->gr->engine, region);
+		if (likely(device->mpeg))
+			device->mpeg->tile_prog(device->mpeg, region);
+	}
 }
 
 int

commit 03c8952fb36b58e451b8a93a1a2abd59e09ddf7b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/fb: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index d435bd155684..0f39ff883ec0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -26,6 +26,38 @@
 
 #include <subdev/bios.h>
 #include <subdev/bios/M0203.h>
+#include <engine/gr.h>
+#include <engine/mpeg.h>
+
+bool
+nvkm_fb_memtype_valid(struct nvkm_fb *fb, u32 memtype)
+{
+	return fb->func->memtype_valid(fb, memtype);
+}
+
+void
+nvkm_fb_tile_fini(struct nvkm_fb *fb, int region, struct nvkm_fb_tile *tile)
+{
+	fb->func->tile.fini(fb, region, tile);
+}
+
+void
+nvkm_fb_tile_init(struct nvkm_fb *fb, int region, u32 addr, u32 size,
+		  u32 pitch, u32 flags, struct nvkm_fb_tile *tile)
+{
+	fb->func->tile.init(fb, region, addr, size, pitch, flags, tile);
+}
+
+void
+nvkm_fb_tile_prog(struct nvkm_fb *fb, int region, struct nvkm_fb_tile *tile)
+{
+	struct nvkm_device *device = fb->subdev.device;
+	fb->func->tile.prog(fb, region, tile);
+	if (likely(device->gr))
+		device->gr->engine.tile_prog(&device->gr->engine, region);
+	if (likely(device->mpeg))
+		device->mpeg->tile_prog(device->mpeg, region);
+}
 
 int
 nvkm_fb_bios_memtype(struct nvkm_bios *bios)
@@ -52,69 +84,87 @@ nvkm_fb_bios_memtype(struct nvkm_bios *bios)
 	return NVKM_RAM_TYPE_UNKNOWN;
 }
 
-int
-_nvkm_fb_fini(struct nvkm_object *object, bool suspend)
+static void
+nvkm_fb_intr(struct nvkm_subdev *subdev)
 {
-	struct nvkm_fb *fb = (void *)object;
-	return nvkm_subdev_fini_old(&fb->subdev, suspend);
+	struct nvkm_fb *fb = nvkm_fb(subdev);
+	if (fb->func->intr)
+		fb->func->intr(fb);
 }
 
-int
-_nvkm_fb_init(struct nvkm_object *object)
+static int
+nvkm_fb_oneinit(struct nvkm_subdev *subdev)
 {
-	struct nvkm_fb *fb = (void *)object;
-	int ret, i;
+	struct nvkm_fb *fb = nvkm_fb(subdev);
+	if (fb->func->ram_new) {
+		int ret = fb->func->ram_new(fb, &fb->ram);
+		if (ret) {
+			nvkm_error(subdev, "vram setup failed, %d\n", ret);
+			return ret;
+		}
+	}
+	return 0;
+}
 
-	ret = nvkm_subdev_init_old(&fb->subdev);
-	if (ret)
-		return ret;
+static int
+nvkm_fb_init(struct nvkm_subdev *subdev)
+{
+	struct nvkm_fb *fb = nvkm_fb(subdev);
+	int ret, i;
 
-	if (fb->ram)
-		nvkm_ram_init(fb->ram);
+	if (fb->ram) {
+		ret = nvkm_ram_init(fb->ram);
+		if (ret)
+			return ret;
+	}
 
 	for (i = 0; i < fb->tile.regions; i++)
-		fb->tile.prog(fb, i, &fb->tile.region[i]);
+		fb->func->tile.prog(fb, i, &fb->tile.region[i]);
 
+	if (fb->func->init)
+		fb->func->init(fb);
 	return 0;
 }
 
-void
-_nvkm_fb_dtor(struct nvkm_object *object)
+static void *
+nvkm_fb_dtor(struct nvkm_subdev *subdev)
 {
-	struct nvkm_fb *fb = (void *)object;
+	struct nvkm_fb *fb = nvkm_fb(subdev);
 	int i;
 
 	for (i = 0; i < fb->tile.regions; i++)
-		fb->tile.fini(fb, i, &fb->tile.region[i]);
+		fb->func->tile.fini(fb, i, &fb->tile.region[i]);
 
 	nvkm_ram_del(&fb->ram);
-	nvkm_subdev_destroy(&fb->subdev);
-}
 
-int
-nvkm_fb_create_(struct nvkm_object *parent, struct nvkm_object *engine,
-		struct nvkm_oclass *oclass, int length, void **pobject)
-{
-	struct nvkm_fb_impl *impl = (void *)oclass;
-	struct nvkm_fb *fb;
-	int ret;
-
-	ret = nvkm_subdev_create_(parent, engine, oclass, 0, "PFB", "fb",
-				  length, pobject);
-	fb = *pobject;
-	if (ret)
-		return ret;
-
-	fb->memtype_valid = impl->memtype;
+	if (fb->func->dtor)
+		return fb->func->dtor(fb);
+	return fb;
+}
 
-	if (!impl->ram_new)
-		return 0;
+static const struct nvkm_subdev_func
+nvkm_fb = {
+	.dtor = nvkm_fb_dtor,
+	.oneinit = nvkm_fb_oneinit,
+	.init = nvkm_fb_init,
+	.intr = nvkm_fb_intr,
+};
 
-	ret = impl->ram_new(fb, &fb->ram);
-	if (ret) {
-		nvkm_error(&fb->subdev, "vram init failed, %d\n", ret);
-		return ret;
-	}
+void
+nvkm_fb_ctor(const struct nvkm_fb_func *func, struct nvkm_device *device,
+	     int index, struct nvkm_fb *fb)
+{
+	nvkm_subdev_ctor(&nvkm_fb, device, index, 0, &fb->subdev);
+	fb->func = func;
+	fb->tile.regions = fb->func->tile.regions;
+}
 
+int
+nvkm_fb_new_(const struct nvkm_fb_func *func, struct nvkm_device *device,
+	     int index, struct nvkm_fb **pfb)
+{
+	if (!(*pfb = kzalloc(sizeof(**pfb), GFP_KERNEL)))
+		return -ENOMEM;
+	nvkm_fb_ctor(func, device, index, *pfb);
 	return 0;
 }

commit 3a8c3400f3e74638bedd0d2410416aa8b794c0fd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/subdev: rename some functions to avoid upcoming conflicts
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index 328381b8f0ac..d435bd155684 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -56,7 +56,7 @@ int
 _nvkm_fb_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nvkm_fb *fb = (void *)object;
-	return nvkm_subdev_fini(&fb->subdev, suspend);
+	return nvkm_subdev_fini_old(&fb->subdev, suspend);
 }
 
 int
@@ -65,7 +65,7 @@ _nvkm_fb_init(struct nvkm_object *object)
 	struct nvkm_fb *fb = (void *)object;
 	int ret, i;
 
-	ret = nvkm_subdev_init(&fb->subdev);
+	ret = nvkm_subdev_init_old(&fb->subdev);
 	if (ret)
 		return ret;
 

commit d36a99d2da22bdffebf644e4a5f811e8eff82360
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:14 2015 +1000

    drm/nouveau/fb: transition nvkm_ram away from being based on nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index f0a5d197e7a0..328381b8f0ac 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -22,6 +22,7 @@
  * Authors: Ben Skeggs
  */
 #include "priv.h"
+#include "ram.h"
 
 #include <subdev/bios.h>
 #include <subdev/bios/M0203.h>
@@ -37,32 +38,24 @@ nvkm_fb_bios_memtype(struct nvkm_bios *bios)
 
 	if (nvbios_M0203Em(bios, ramcfg, &ver, &hdr, &M0203E)) {
 		switch (M0203E.type) {
-		case M0203E_TYPE_DDR2 : return NV_MEM_TYPE_DDR2;
-		case M0203E_TYPE_DDR3 : return NV_MEM_TYPE_DDR3;
-		case M0203E_TYPE_GDDR3: return NV_MEM_TYPE_GDDR3;
-		case M0203E_TYPE_GDDR5: return NV_MEM_TYPE_GDDR5;
+		case M0203E_TYPE_DDR2 : return NVKM_RAM_TYPE_DDR2;
+		case M0203E_TYPE_DDR3 : return NVKM_RAM_TYPE_DDR3;
+		case M0203E_TYPE_GDDR3: return NVKM_RAM_TYPE_GDDR3;
+		case M0203E_TYPE_GDDR5: return NVKM_RAM_TYPE_GDDR5;
 		default:
 			nvkm_warn(subdev, "M0203E type %02x\n", M0203E.type);
-			return NV_MEM_TYPE_UNKNOWN;
+			return NVKM_RAM_TYPE_UNKNOWN;
 		}
 	}
 
 	nvkm_warn(subdev, "M0203E not matched!\n");
-	return NV_MEM_TYPE_UNKNOWN;
+	return NVKM_RAM_TYPE_UNKNOWN;
 }
 
 int
 _nvkm_fb_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nvkm_fb *fb = (void *)object;
-	int ret;
-
-	if (fb->ram) {
-		ret = nv_ofuncs(fb->ram)->fini(nv_object(fb->ram), suspend);
-		if (ret && suspend)
-			return ret;
-	}
-
 	return nvkm_subdev_fini(&fb->subdev, suspend);
 }
 
@@ -76,11 +69,8 @@ _nvkm_fb_init(struct nvkm_object *object)
 	if (ret)
 		return ret;
 
-	if (fb->ram) {
-		ret = nv_ofuncs(fb->ram)->init(nv_object(fb->ram));
-		if (ret)
-			return ret;
-	}
+	if (fb->ram)
+		nvkm_ram_init(fb->ram);
 
 	for (i = 0; i < fb->tile.regions; i++)
 		fb->tile.prog(fb, i, &fb->tile.region[i]);
@@ -96,13 +86,8 @@ _nvkm_fb_dtor(struct nvkm_object *object)
 
 	for (i = 0; i < fb->tile.regions; i++)
 		fb->tile.fini(fb, i, &fb->tile.region[i]);
-	nvkm_mm_fini(&fb->tags);
-
-	if (fb->ram) {
-		nvkm_mm_fini(&fb->vram);
-		nvkm_object_ref(NULL, (struct nvkm_object **)&fb->ram);
-	}
 
+	nvkm_ram_del(&fb->ram);
 	nvkm_subdev_destroy(&fb->subdev);
 }
 
@@ -111,20 +96,6 @@ nvkm_fb_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		struct nvkm_oclass *oclass, int length, void **pobject)
 {
 	struct nvkm_fb_impl *impl = (void *)oclass;
-	static const char *name[] = {
-		[NV_MEM_TYPE_UNKNOWN] = "of unknown memory type",
-		[NV_MEM_TYPE_STOLEN ] = "stolen system memory",
-		[NV_MEM_TYPE_SGRAM  ] = "SGRAM",
-		[NV_MEM_TYPE_SDRAM  ] = "SDRAM",
-		[NV_MEM_TYPE_DDR1   ] = "DDR1",
-		[NV_MEM_TYPE_DDR2   ] = "DDR2",
-		[NV_MEM_TYPE_DDR3   ] = "DDR3",
-		[NV_MEM_TYPE_GDDR2  ] = "GDDR2",
-		[NV_MEM_TYPE_GDDR3  ] = "GDDR3",
-		[NV_MEM_TYPE_GDDR4  ] = "GDDR4",
-		[NV_MEM_TYPE_GDDR5  ] = "GDDR5",
-	};
-	struct nvkm_object *ram;
 	struct nvkm_fb *fb;
 	int ret;
 
@@ -136,33 +107,14 @@ nvkm_fb_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	fb->memtype_valid = impl->memtype;
 
-	if (!impl->ram)
+	if (!impl->ram_new)
 		return 0;
 
-	ret = nvkm_object_ctor(nv_object(fb), NULL, impl->ram, NULL, 0, &ram);
+	ret = impl->ram_new(fb, &fb->ram);
 	if (ret) {
 		nvkm_error(&fb->subdev, "vram init failed, %d\n", ret);
 		return ret;
 	}
 
-	fb->ram = (void *)ram;
-
-	if (!nvkm_mm_initialised(&fb->vram)) {
-		ret = nvkm_mm_init(&fb->vram, 0, fb->ram->size >> 12, 1);
-		if (ret)
-			return ret;
-	}
-
-	if (!nvkm_mm_initialised(&fb->tags)) {
-		ret = nvkm_mm_init(&fb->tags, 0, fb->ram->tags ?
-				   ++fb->ram->tags : 0, 1);
-		if (ret)
-			return ret;
-
-		nvkm_debug(&fb->subdev, "%d compression tags\n", fb->ram->tags);
-	}
-
-	nvkm_info(&fb->subdev, "%d MiB %s\n", (int)(fb->ram->size >> 20),
-		  name[fb->ram->type]);
 	return 0;
 }

commit 3ecd329b6445efdcad26e94edd57f0fd5ccd080b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:12 2015 +1000

    drm/nouveau/fb: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index be1842057226..f0a5d197e7a0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -29,7 +29,8 @@
 int
 nvkm_fb_bios_memtype(struct nvkm_bios *bios)
 {
-	struct nvkm_device *device = bios->subdev.device;
+	struct nvkm_subdev *subdev = &bios->subdev;
+	struct nvkm_device *device = subdev->device;
 	const u8 ramcfg = (nvkm_rd32(device, 0x101000) & 0x0000003c) >> 2;
 	struct nvbios_M0203E M0203E;
 	u8 ver, hdr;
@@ -41,12 +42,12 @@ nvkm_fb_bios_memtype(struct nvkm_bios *bios)
 		case M0203E_TYPE_GDDR3: return NV_MEM_TYPE_GDDR3;
 		case M0203E_TYPE_GDDR5: return NV_MEM_TYPE_GDDR5;
 		default:
-			nv_warn(bios, "M0203E type %02x\n", M0203E.type);
+			nvkm_warn(subdev, "M0203E type %02x\n", M0203E.type);
 			return NV_MEM_TYPE_UNKNOWN;
 		}
 	}
 
-	nv_warn(bios, "M0203E not matched!\n");
+	nvkm_warn(subdev, "M0203E not matched!\n");
 	return NV_MEM_TYPE_UNKNOWN;
 }
 
@@ -111,7 +112,7 @@ nvkm_fb_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 {
 	struct nvkm_fb_impl *impl = (void *)oclass;
 	static const char *name[] = {
-		[NV_MEM_TYPE_UNKNOWN] = "unknown",
+		[NV_MEM_TYPE_UNKNOWN] = "of unknown memory type",
 		[NV_MEM_TYPE_STOLEN ] = "stolen system memory",
 		[NV_MEM_TYPE_SGRAM  ] = "SGRAM",
 		[NV_MEM_TYPE_SDRAM  ] = "SDRAM",
@@ -140,7 +141,7 @@ nvkm_fb_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	ret = nvkm_object_ctor(nv_object(fb), NULL, impl->ram, NULL, 0, &ram);
 	if (ret) {
-		nv_fatal(fb, "error detecting memory configuration!!\n");
+		nvkm_error(&fb->subdev, "vram init failed, %d\n", ret);
 		return ret;
 	}
 
@@ -157,10 +158,11 @@ nvkm_fb_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 				   ++fb->ram->tags : 0, 1);
 		if (ret)
 			return ret;
+
+		nvkm_debug(&fb->subdev, "%d compression tags\n", fb->ram->tags);
 	}
 
-	nv_info(fb, "RAM type: %s\n", name[fb->ram->type]);
-	nv_info(fb, "RAM size: %d MiB\n", (int)(fb->ram->size >> 20));
-	nv_info(fb, "   ZCOMP: %d tags\n", fb->ram->tags);
+	nvkm_info(&fb->subdev, "%d MiB %s\n", (int)(fb->ram->size >> 20),
+		  name[fb->ram->type]);
 	return 0;
 }

commit 6758745b2821bddcec1aae0c4cffaa9608aeda59
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:09 2015 +1000

    drm/nouveau/fb: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index 8bd560d61bd8..be1842057226 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -29,7 +29,8 @@
 int
 nvkm_fb_bios_memtype(struct nvkm_bios *bios)
 {
-	const u8 ramcfg = (nv_rd32(bios, 0x101000) & 0x0000003c) >> 2;
+	struct nvkm_device *device = bios->subdev.device;
+	const u8 ramcfg = (nvkm_rd32(device, 0x101000) & 0x0000003c) >> 2;
 	struct nvbios_M0203E M0203E;
 	u8 ver, hdr;
 

commit b1e4553cb1f9deddbd8c13d95e9cef81967a3f41
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/fb: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index 61fde43dab71..8bd560d61bd8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -52,36 +52,36 @@ nvkm_fb_bios_memtype(struct nvkm_bios *bios)
 int
 _nvkm_fb_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nvkm_fb *pfb = (void *)object;
+	struct nvkm_fb *fb = (void *)object;
 	int ret;
 
-	if (pfb->ram) {
-		ret = nv_ofuncs(pfb->ram)->fini(nv_object(pfb->ram), suspend);
+	if (fb->ram) {
+		ret = nv_ofuncs(fb->ram)->fini(nv_object(fb->ram), suspend);
 		if (ret && suspend)
 			return ret;
 	}
 
-	return nvkm_subdev_fini(&pfb->base, suspend);
+	return nvkm_subdev_fini(&fb->subdev, suspend);
 }
 
 int
 _nvkm_fb_init(struct nvkm_object *object)
 {
-	struct nvkm_fb *pfb = (void *)object;
+	struct nvkm_fb *fb = (void *)object;
 	int ret, i;
 
-	ret = nvkm_subdev_init(&pfb->base);
+	ret = nvkm_subdev_init(&fb->subdev);
 	if (ret)
 		return ret;
 
-	if (pfb->ram) {
-		ret = nv_ofuncs(pfb->ram)->init(nv_object(pfb->ram));
+	if (fb->ram) {
+		ret = nv_ofuncs(fb->ram)->init(nv_object(fb->ram));
 		if (ret)
 			return ret;
 	}
 
-	for (i = 0; i < pfb->tile.regions; i++)
-		pfb->tile.prog(pfb, i, &pfb->tile.region[i]);
+	for (i = 0; i < fb->tile.regions; i++)
+		fb->tile.prog(fb, i, &fb->tile.region[i]);
 
 	return 0;
 }
@@ -89,19 +89,19 @@ _nvkm_fb_init(struct nvkm_object *object)
 void
 _nvkm_fb_dtor(struct nvkm_object *object)
 {
-	struct nvkm_fb *pfb = (void *)object;
+	struct nvkm_fb *fb = (void *)object;
 	int i;
 
-	for (i = 0; i < pfb->tile.regions; i++)
-		pfb->tile.fini(pfb, i, &pfb->tile.region[i]);
-	nvkm_mm_fini(&pfb->tags);
+	for (i = 0; i < fb->tile.regions; i++)
+		fb->tile.fini(fb, i, &fb->tile.region[i]);
+	nvkm_mm_fini(&fb->tags);
 
-	if (pfb->ram) {
-		nvkm_mm_fini(&pfb->vram);
-		nvkm_object_ref(NULL, (struct nvkm_object **)&pfb->ram);
+	if (fb->ram) {
+		nvkm_mm_fini(&fb->vram);
+		nvkm_object_ref(NULL, (struct nvkm_object **)&fb->ram);
 	}
 
-	nvkm_subdev_destroy(&pfb->base);
+	nvkm_subdev_destroy(&fb->subdev);
 }
 
 int
@@ -123,43 +123,43 @@ nvkm_fb_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		[NV_MEM_TYPE_GDDR5  ] = "GDDR5",
 	};
 	struct nvkm_object *ram;
-	struct nvkm_fb *pfb;
+	struct nvkm_fb *fb;
 	int ret;
 
 	ret = nvkm_subdev_create_(parent, engine, oclass, 0, "PFB", "fb",
 				  length, pobject);
-	pfb = *pobject;
+	fb = *pobject;
 	if (ret)
 		return ret;
 
-	pfb->memtype_valid = impl->memtype;
+	fb->memtype_valid = impl->memtype;
 
 	if (!impl->ram)
 		return 0;
 
-	ret = nvkm_object_ctor(nv_object(pfb), NULL, impl->ram, NULL, 0, &ram);
+	ret = nvkm_object_ctor(nv_object(fb), NULL, impl->ram, NULL, 0, &ram);
 	if (ret) {
-		nv_fatal(pfb, "error detecting memory configuration!!\n");
+		nv_fatal(fb, "error detecting memory configuration!!\n");
 		return ret;
 	}
 
-	pfb->ram = (void *)ram;
+	fb->ram = (void *)ram;
 
-	if (!nvkm_mm_initialised(&pfb->vram)) {
-		ret = nvkm_mm_init(&pfb->vram, 0, pfb->ram->size >> 12, 1);
+	if (!nvkm_mm_initialised(&fb->vram)) {
+		ret = nvkm_mm_init(&fb->vram, 0, fb->ram->size >> 12, 1);
 		if (ret)
 			return ret;
 	}
 
-	if (!nvkm_mm_initialised(&pfb->tags)) {
-		ret = nvkm_mm_init(&pfb->tags, 0, pfb->ram->tags ?
-				   ++pfb->ram->tags : 0, 1);
+	if (!nvkm_mm_initialised(&fb->tags)) {
+		ret = nvkm_mm_init(&fb->tags, 0, fb->ram->tags ?
+				   ++fb->ram->tags : 0, 1);
 		if (ret)
 			return ret;
 	}
 
-	nv_info(pfb, "RAM type: %s\n", name[pfb->ram->type]);
-	nv_info(pfb, "RAM size: %d MiB\n", (int)(pfb->ram->size >> 20));
-	nv_info(pfb, "   ZCOMP: %d tags\n", pfb->ram->tags);
+	nv_info(fb, "RAM type: %s\n", name[fb->ram->type]);
+	nv_info(fb, "RAM size: %d MiB\n", (int)(fb->ram->size >> 20));
+	nv_info(fb, "   ZCOMP: %d tags\n", fb->ram->tags);
 	return 0;
 }

commit eaecf0326f096faaba462eae48a3b30bcb1f7009
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Fri Feb 20 18:22:59 2015 +0900

    make RAM device optional
    
    Having a RAM device does not make sense for chips like GK20A which have
    no dedicated video memory. The dummy RAM device that we used so far
    works as a temporary band-aid, but in the longer term it is desirable
    for the driver to be able to work without any kind of VRAM.
    
    This patch adds a few conditionals in places where a RAM device was
    assumed to be present and allows some more objects to be allocated from
    the TT domain, allowing Nouveau to handle GPUs for which
    pfb->ram == NULL.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index 16589fa613cd..61fde43dab71 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -55,9 +55,11 @@ _nvkm_fb_fini(struct nvkm_object *object, bool suspend)
 	struct nvkm_fb *pfb = (void *)object;
 	int ret;
 
-	ret = nv_ofuncs(pfb->ram)->fini(nv_object(pfb->ram), suspend);
-	if (ret && suspend)
-		return ret;
+	if (pfb->ram) {
+		ret = nv_ofuncs(pfb->ram)->fini(nv_object(pfb->ram), suspend);
+		if (ret && suspend)
+			return ret;
+	}
 
 	return nvkm_subdev_fini(&pfb->base, suspend);
 }
@@ -72,9 +74,11 @@ _nvkm_fb_init(struct nvkm_object *object)
 	if (ret)
 		return ret;
 
-	ret = nv_ofuncs(pfb->ram)->init(nv_object(pfb->ram));
-	if (ret)
-		return ret;
+	if (pfb->ram) {
+		ret = nv_ofuncs(pfb->ram)->init(nv_object(pfb->ram));
+		if (ret)
+			return ret;
+	}
 
 	for (i = 0; i < pfb->tile.regions; i++)
 		pfb->tile.prog(pfb, i, &pfb->tile.region[i]);
@@ -91,9 +95,12 @@ _nvkm_fb_dtor(struct nvkm_object *object)
 	for (i = 0; i < pfb->tile.regions; i++)
 		pfb->tile.fini(pfb, i, &pfb->tile.region[i]);
 	nvkm_mm_fini(&pfb->tags);
-	nvkm_mm_fini(&pfb->vram);
 
-	nvkm_object_ref(NULL, (struct nvkm_object **)&pfb->ram);
+	if (pfb->ram) {
+		nvkm_mm_fini(&pfb->vram);
+		nvkm_object_ref(NULL, (struct nvkm_object **)&pfb->ram);
+	}
+
 	nvkm_subdev_destroy(&pfb->base);
 }
 
@@ -127,6 +134,9 @@ nvkm_fb_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	pfb->memtype_valid = impl->memtype;
 
+	if (!impl->ram)
+		return 0;
+
 	ret = nvkm_object_ctor(nv_object(pfb), NULL, impl->ram, NULL, 0, &ram);
 	if (ret) {
 		nv_fatal(pfb, "error detecting memory configuration!!\n");

commit 639c308effb945732feb26fe416a6f00f3147ae4
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 14:52:58 2015 +1000

    drm/nouveau/fb: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
index 090a7f2ac9b3..16589fa613cd 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -21,14 +21,13 @@
  *
  * Authors: Ben Skeggs
  */
+#include "priv.h"
 
 #include <subdev/bios.h>
 #include <subdev/bios/M0203.h>
 
-#include "priv.h"
-
 int
-nouveau_fb_bios_memtype(struct nouveau_bios *bios)
+nvkm_fb_bios_memtype(struct nvkm_bios *bios)
 {
 	const u8 ramcfg = (nv_rd32(bios, 0x101000) & 0x0000003c) >> 2;
 	struct nvbios_M0203E M0203E;
@@ -51,25 +50,25 @@ nouveau_fb_bios_memtype(struct nouveau_bios *bios)
 }
 
 int
-_nouveau_fb_fini(struct nouveau_object *object, bool suspend)
+_nvkm_fb_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nouveau_fb *pfb = (void *)object;
+	struct nvkm_fb *pfb = (void *)object;
 	int ret;
 
 	ret = nv_ofuncs(pfb->ram)->fini(nv_object(pfb->ram), suspend);
 	if (ret && suspend)
 		return ret;
 
-	return nouveau_subdev_fini(&pfb->base, suspend);
+	return nvkm_subdev_fini(&pfb->base, suspend);
 }
 
 int
-_nouveau_fb_init(struct nouveau_object *object)
+_nvkm_fb_init(struct nvkm_object *object)
 {
-	struct nouveau_fb *pfb = (void *)object;
+	struct nvkm_fb *pfb = (void *)object;
 	int ret, i;
 
-	ret = nouveau_subdev_init(&pfb->base);
+	ret = nvkm_subdev_init(&pfb->base);
 	if (ret)
 		return ret;
 
@@ -84,25 +83,25 @@ _nouveau_fb_init(struct nouveau_object *object)
 }
 
 void
-_nouveau_fb_dtor(struct nouveau_object *object)
+_nvkm_fb_dtor(struct nvkm_object *object)
 {
-	struct nouveau_fb *pfb = (void *)object;
+	struct nvkm_fb *pfb = (void *)object;
 	int i;
 
 	for (i = 0; i < pfb->tile.regions; i++)
 		pfb->tile.fini(pfb, i, &pfb->tile.region[i]);
-	nouveau_mm_fini(&pfb->tags);
-	nouveau_mm_fini(&pfb->vram);
+	nvkm_mm_fini(&pfb->tags);
+	nvkm_mm_fini(&pfb->vram);
 
-	nouveau_object_ref(NULL, (struct nouveau_object **)&pfb->ram);
-	nouveau_subdev_destroy(&pfb->base);
+	nvkm_object_ref(NULL, (struct nvkm_object **)&pfb->ram);
+	nvkm_subdev_destroy(&pfb->base);
 }
 
 int
-nouveau_fb_create_(struct nouveau_object *parent, struct nouveau_object *engine,
-		   struct nouveau_oclass *oclass, int length, void **pobject)
+nvkm_fb_create_(struct nvkm_object *parent, struct nvkm_object *engine,
+		struct nvkm_oclass *oclass, int length, void **pobject)
 {
-	struct nouveau_fb_impl *impl = (void *)oclass;
+	struct nvkm_fb_impl *impl = (void *)oclass;
 	static const char *name[] = {
 		[NV_MEM_TYPE_UNKNOWN] = "unknown",
 		[NV_MEM_TYPE_STOLEN ] = "stolen system memory",
@@ -116,20 +115,19 @@ nouveau_fb_create_(struct nouveau_object *parent, struct nouveau_object *engine,
 		[NV_MEM_TYPE_GDDR4  ] = "GDDR4",
 		[NV_MEM_TYPE_GDDR5  ] = "GDDR5",
 	};
-	struct nouveau_object *ram;
-	struct nouveau_fb *pfb;
+	struct nvkm_object *ram;
+	struct nvkm_fb *pfb;
 	int ret;
 
-	ret = nouveau_subdev_create_(parent, engine, oclass, 0, "PFB", "fb",
-				     length, pobject);
+	ret = nvkm_subdev_create_(parent, engine, oclass, 0, "PFB", "fb",
+				  length, pobject);
 	pfb = *pobject;
 	if (ret)
 		return ret;
 
 	pfb->memtype_valid = impl->memtype;
 
-	ret = nouveau_object_ctor(nv_object(pfb), NULL,
-				  impl->ram, NULL, 0, &ram);
+	ret = nvkm_object_ctor(nv_object(pfb), NULL, impl->ram, NULL, 0, &ram);
 	if (ret) {
 		nv_fatal(pfb, "error detecting memory configuration!!\n");
 		return ret;
@@ -137,15 +135,15 @@ nouveau_fb_create_(struct nouveau_object *parent, struct nouveau_object *engine,
 
 	pfb->ram = (void *)ram;
 
-	if (!nouveau_mm_initialised(&pfb->vram)) {
-		ret = nouveau_mm_init(&pfb->vram, 0, pfb->ram->size >> 12, 1);
+	if (!nvkm_mm_initialised(&pfb->vram)) {
+		ret = nvkm_mm_init(&pfb->vram, 0, pfb->ram->size >> 12, 1);
 		if (ret)
 			return ret;
 	}
 
-	if (!nouveau_mm_initialised(&pfb->tags)) {
-		ret = nouveau_mm_init(&pfb->tags, 0, pfb->ram->tags ?
-				     ++pfb->ram->tags : 0, 1);
+	if (!nvkm_mm_initialised(&pfb->tags)) {
+		ret = nvkm_mm_init(&pfb->tags, 0, pfb->ram->tags ?
+				   ++pfb->ram->tags : 0, 1);
 		if (ret)
 			return ret;
 	}

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
new file mode 100644
index 000000000000..090a7f2ac9b3
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c
@@ -0,0 +1,157 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <subdev/bios.h>
+#include <subdev/bios/M0203.h>
+
+#include "priv.h"
+
+int
+nouveau_fb_bios_memtype(struct nouveau_bios *bios)
+{
+	const u8 ramcfg = (nv_rd32(bios, 0x101000) & 0x0000003c) >> 2;
+	struct nvbios_M0203E M0203E;
+	u8 ver, hdr;
+
+	if (nvbios_M0203Em(bios, ramcfg, &ver, &hdr, &M0203E)) {
+		switch (M0203E.type) {
+		case M0203E_TYPE_DDR2 : return NV_MEM_TYPE_DDR2;
+		case M0203E_TYPE_DDR3 : return NV_MEM_TYPE_DDR3;
+		case M0203E_TYPE_GDDR3: return NV_MEM_TYPE_GDDR3;
+		case M0203E_TYPE_GDDR5: return NV_MEM_TYPE_GDDR5;
+		default:
+			nv_warn(bios, "M0203E type %02x\n", M0203E.type);
+			return NV_MEM_TYPE_UNKNOWN;
+		}
+	}
+
+	nv_warn(bios, "M0203E not matched!\n");
+	return NV_MEM_TYPE_UNKNOWN;
+}
+
+int
+_nouveau_fb_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nouveau_fb *pfb = (void *)object;
+	int ret;
+
+	ret = nv_ofuncs(pfb->ram)->fini(nv_object(pfb->ram), suspend);
+	if (ret && suspend)
+		return ret;
+
+	return nouveau_subdev_fini(&pfb->base, suspend);
+}
+
+int
+_nouveau_fb_init(struct nouveau_object *object)
+{
+	struct nouveau_fb *pfb = (void *)object;
+	int ret, i;
+
+	ret = nouveau_subdev_init(&pfb->base);
+	if (ret)
+		return ret;
+
+	ret = nv_ofuncs(pfb->ram)->init(nv_object(pfb->ram));
+	if (ret)
+		return ret;
+
+	for (i = 0; i < pfb->tile.regions; i++)
+		pfb->tile.prog(pfb, i, &pfb->tile.region[i]);
+
+	return 0;
+}
+
+void
+_nouveau_fb_dtor(struct nouveau_object *object)
+{
+	struct nouveau_fb *pfb = (void *)object;
+	int i;
+
+	for (i = 0; i < pfb->tile.regions; i++)
+		pfb->tile.fini(pfb, i, &pfb->tile.region[i]);
+	nouveau_mm_fini(&pfb->tags);
+	nouveau_mm_fini(&pfb->vram);
+
+	nouveau_object_ref(NULL, (struct nouveau_object **)&pfb->ram);
+	nouveau_subdev_destroy(&pfb->base);
+}
+
+int
+nouveau_fb_create_(struct nouveau_object *parent, struct nouveau_object *engine,
+		   struct nouveau_oclass *oclass, int length, void **pobject)
+{
+	struct nouveau_fb_impl *impl = (void *)oclass;
+	static const char *name[] = {
+		[NV_MEM_TYPE_UNKNOWN] = "unknown",
+		[NV_MEM_TYPE_STOLEN ] = "stolen system memory",
+		[NV_MEM_TYPE_SGRAM  ] = "SGRAM",
+		[NV_MEM_TYPE_SDRAM  ] = "SDRAM",
+		[NV_MEM_TYPE_DDR1   ] = "DDR1",
+		[NV_MEM_TYPE_DDR2   ] = "DDR2",
+		[NV_MEM_TYPE_DDR3   ] = "DDR3",
+		[NV_MEM_TYPE_GDDR2  ] = "GDDR2",
+		[NV_MEM_TYPE_GDDR3  ] = "GDDR3",
+		[NV_MEM_TYPE_GDDR4  ] = "GDDR4",
+		[NV_MEM_TYPE_GDDR5  ] = "GDDR5",
+	};
+	struct nouveau_object *ram;
+	struct nouveau_fb *pfb;
+	int ret;
+
+	ret = nouveau_subdev_create_(parent, engine, oclass, 0, "PFB", "fb",
+				     length, pobject);
+	pfb = *pobject;
+	if (ret)
+		return ret;
+
+	pfb->memtype_valid = impl->memtype;
+
+	ret = nouveau_object_ctor(nv_object(pfb), NULL,
+				  impl->ram, NULL, 0, &ram);
+	if (ret) {
+		nv_fatal(pfb, "error detecting memory configuration!!\n");
+		return ret;
+	}
+
+	pfb->ram = (void *)ram;
+
+	if (!nouveau_mm_initialised(&pfb->vram)) {
+		ret = nouveau_mm_init(&pfb->vram, 0, pfb->ram->size >> 12, 1);
+		if (ret)
+			return ret;
+	}
+
+	if (!nouveau_mm_initialised(&pfb->tags)) {
+		ret = nouveau_mm_init(&pfb->tags, 0, pfb->ram->tags ?
+				     ++pfb->ram->tags : 0, 1);
+		if (ret)
+			return ret;
+	}
+
+	nv_info(pfb, "RAM type: %s\n", name[pfb->ram->type]);
+	nv_info(pfb, "RAM size: %d MiB\n", (int)(pfb->ram->size >> 20));
+	nv_info(pfb, "   ZCOMP: %d tags\n", pfb->ram->tags);
+	return 0;
+}
