commit d2bcfce7f8a4ba8df28d3bebb81225bd7f9c046f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Feb 11 17:36:49 2020 +1000

    drm/nouveau/ibus: use nvkm_subdev_new_()
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
index 9025ed1bd2a9..f3915f85838e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
@@ -117,9 +117,5 @@ int
 gk104_ibus_new(struct nvkm_device *device, int index,
 	       struct nvkm_subdev **pibus)
 {
-	struct nvkm_subdev *ibus;
-	if (!(ibus = *pibus = kzalloc(sizeof(*ibus), GFP_KERNEL)))
-		return -ENOMEM;
-	nvkm_subdev_ctor(&gk104_ibus, device, index, ibus);
-	return 0;
+	return nvkm_subdev_new_(&gk104_ibus, device, index, pibus);
 }

commit 69d468f4775b0da504140d0ed5e8f25c6ac44e7a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Feb 21 10:05:58 2017 +1000

    drm/nouveau/priv: punt messages to debug level
    
    Ideally we'd be able to keep these at a more obvious error level, as
    they're a good indication of us doing something wrong.
    
    However, NVIDIA's FECS/GPCCS firmware touches registers that trigger
    priv ring faults, and we can't do anything to fix that ourselves due
    to the need for them to be signed by NVIDIA.
    
    This issue was reported a while back, but hasn't been fixed, so, for
    now we will hide the messages to prevent spamming Optimus users with
    messages whenever the NVIDIA GPU is powered off and on again.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
index c673853f3213..9025ed1bd2a9 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
@@ -30,7 +30,7 @@ gk104_ibus_intr_hub(struct nvkm_subdev *ibus, int i)
 	u32 addr = nvkm_rd32(device, 0x122120 + (i * 0x0800));
 	u32 data = nvkm_rd32(device, 0x122124 + (i * 0x0800));
 	u32 stat = nvkm_rd32(device, 0x122128 + (i * 0x0800));
-	nvkm_error(ibus, "HUB%d: %06x %08x (%08x)\n", i, addr, data, stat);
+	nvkm_debug(ibus, "HUB%d: %06x %08x (%08x)\n", i, addr, data, stat);
 	nvkm_mask(device, 0x122128 + (i * 0x0800), 0x00000200, 0x00000000);
 }
 
@@ -41,7 +41,7 @@ gk104_ibus_intr_rop(struct nvkm_subdev *ibus, int i)
 	u32 addr = nvkm_rd32(device, 0x124120 + (i * 0x0800));
 	u32 data = nvkm_rd32(device, 0x124124 + (i * 0x0800));
 	u32 stat = nvkm_rd32(device, 0x124128 + (i * 0x0800));
-	nvkm_error(ibus, "ROP%d: %06x %08x (%08x)\n", i, addr, data, stat);
+	nvkm_debug(ibus, "ROP%d: %06x %08x (%08x)\n", i, addr, data, stat);
 	nvkm_mask(device, 0x124128 + (i * 0x0800), 0x00000200, 0x00000000);
 }
 
@@ -52,7 +52,7 @@ gk104_ibus_intr_gpc(struct nvkm_subdev *ibus, int i)
 	u32 addr = nvkm_rd32(device, 0x128120 + (i * 0x0800));
 	u32 data = nvkm_rd32(device, 0x128124 + (i * 0x0800));
 	u32 stat = nvkm_rd32(device, 0x128128 + (i * 0x0800));
-	nvkm_error(ibus, "GPC%d: %06x %08x (%08x)\n", i, addr, data, stat);
+	nvkm_debug(ibus, "GPC%d: %06x %08x (%08x)\n", i, addr, data, stat);
 	nvkm_mask(device, 0x128128 + (i * 0x0800), 0x00000200, 0x00000000);
 }
 

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
index b5cee3f89aaa..c673853f3213 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
@@ -120,6 +120,6 @@ gk104_ibus_new(struct nvkm_device *device, int index,
 	struct nvkm_subdev *ibus;
 	if (!(ibus = *pibus = kzalloc(sizeof(*ibus), GFP_KERNEL)))
 		return -ENOMEM;
-	nvkm_subdev_ctor(&gk104_ibus, device, index, 0, ibus);
+	nvkm_subdev_ctor(&gk104_ibus, device, index, ibus);
 	return 0;
 }

commit e3d26d0860920080f9fa1fc10a9bd01d98a96261
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sat Dec 19 16:24:10 2015 +1000

    drm/nouveau/ibus/gm204: split implementation from gk104
    
    GM20x doesn't require the priv ring timeout bumps that GK/GM10x have.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
index ba33609f643c..b5cee3f89aaa 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
@@ -21,7 +21,7 @@
  *
  * Authors: Ben Skeggs
  */
-#include <subdev/ibus.h>
+#include "priv.h"
 
 static void
 gk104_ibus_intr_hub(struct nvkm_subdev *ibus, int i)
@@ -56,7 +56,7 @@ gk104_ibus_intr_gpc(struct nvkm_subdev *ibus, int i)
 	nvkm_mask(device, 0x128128 + (i * 0x0800), 0x00000200, 0x00000000);
 }
 
-static void
+void
 gk104_ibus_intr(struct nvkm_subdev *ibus)
 {
 	struct nvkm_device *device = ibus->device;

commit 551d341755e2ade4a915d889524a4187f2cd210e
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/ibus: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
index 0ac0bbaa9d2a..ba33609f643c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
@@ -24,46 +24,42 @@
 #include <subdev/ibus.h>
 
 static void
-gk104_ibus_intr_hub(struct nvkm_ibus *ibus, int i)
+gk104_ibus_intr_hub(struct nvkm_subdev *ibus, int i)
 {
-	struct nvkm_subdev *subdev = &ibus->subdev;
-	struct nvkm_device *device = subdev->device;
+	struct nvkm_device *device = ibus->device;
 	u32 addr = nvkm_rd32(device, 0x122120 + (i * 0x0800));
 	u32 data = nvkm_rd32(device, 0x122124 + (i * 0x0800));
 	u32 stat = nvkm_rd32(device, 0x122128 + (i * 0x0800));
-	nvkm_error(subdev, "HUB%d: %06x %08x (%08x)\n", i, addr, data, stat);
+	nvkm_error(ibus, "HUB%d: %06x %08x (%08x)\n", i, addr, data, stat);
 	nvkm_mask(device, 0x122128 + (i * 0x0800), 0x00000200, 0x00000000);
 }
 
 static void
-gk104_ibus_intr_rop(struct nvkm_ibus *ibus, int i)
+gk104_ibus_intr_rop(struct nvkm_subdev *ibus, int i)
 {
-	struct nvkm_subdev *subdev = &ibus->subdev;
-	struct nvkm_device *device = subdev->device;
+	struct nvkm_device *device = ibus->device;
 	u32 addr = nvkm_rd32(device, 0x124120 + (i * 0x0800));
 	u32 data = nvkm_rd32(device, 0x124124 + (i * 0x0800));
 	u32 stat = nvkm_rd32(device, 0x124128 + (i * 0x0800));
-	nvkm_error(subdev, "ROP%d: %06x %08x (%08x)\n", i, addr, data, stat);
+	nvkm_error(ibus, "ROP%d: %06x %08x (%08x)\n", i, addr, data, stat);
 	nvkm_mask(device, 0x124128 + (i * 0x0800), 0x00000200, 0x00000000);
 }
 
 static void
-gk104_ibus_intr_gpc(struct nvkm_ibus *ibus, int i)
+gk104_ibus_intr_gpc(struct nvkm_subdev *ibus, int i)
 {
-	struct nvkm_subdev *subdev = &ibus->subdev;
-	struct nvkm_device *device = subdev->device;
+	struct nvkm_device *device = ibus->device;
 	u32 addr = nvkm_rd32(device, 0x128120 + (i * 0x0800));
 	u32 data = nvkm_rd32(device, 0x128124 + (i * 0x0800));
 	u32 stat = nvkm_rd32(device, 0x128128 + (i * 0x0800));
-	nvkm_error(subdev, "GPC%d: %06x %08x (%08x)\n", i, addr, data, stat);
+	nvkm_error(ibus, "GPC%d: %06x %08x (%08x)\n", i, addr, data, stat);
 	nvkm_mask(device, 0x128128 + (i * 0x0800), 0x00000200, 0x00000000);
 }
 
 static void
-gk104_ibus_intr(struct nvkm_subdev *subdev)
+gk104_ibus_intr(struct nvkm_subdev *ibus)
 {
-	struct nvkm_ibus *ibus = (void *)subdev;
-	struct nvkm_device *device = ibus->subdev.device;
+	struct nvkm_device *device = ibus->device;
 	u32 intr0 = nvkm_rd32(device, 0x120058);
 	u32 intr1 = nvkm_rd32(device, 0x12005c);
 	u32 hubnr = nvkm_rd32(device, 0x120070);
@@ -97,47 +93,33 @@ gk104_ibus_intr(struct nvkm_subdev *subdev)
 }
 
 static int
-gk104_ibus_init(struct nvkm_object *object)
+gk104_ibus_init(struct nvkm_subdev *ibus)
 {
-	struct nvkm_ibus *ibus = (void *)object;
-	struct nvkm_device *device = ibus->subdev.device;
-	int ret = nvkm_ibus_init(ibus);
-	if (ret == 0) {
-		nvkm_mask(device, 0x122318, 0x0003ffff, 0x00001000);
-		nvkm_mask(device, 0x12231c, 0x0003ffff, 0x00000200);
-		nvkm_mask(device, 0x122310, 0x0003ffff, 0x00000800);
-		nvkm_mask(device, 0x122348, 0x0003ffff, 0x00000100);
-		nvkm_mask(device, 0x1223b0, 0x0003ffff, 0x00000fff);
-		nvkm_mask(device, 0x122348, 0x0003ffff, 0x00000200);
-		nvkm_mask(device, 0x122358, 0x0003ffff, 0x00002880);
-	}
-	return ret;
+	struct nvkm_device *device = ibus->device;
+	nvkm_mask(device, 0x122318, 0x0003ffff, 0x00001000);
+	nvkm_mask(device, 0x12231c, 0x0003ffff, 0x00000200);
+	nvkm_mask(device, 0x122310, 0x0003ffff, 0x00000800);
+	nvkm_mask(device, 0x122348, 0x0003ffff, 0x00000100);
+	nvkm_mask(device, 0x1223b0, 0x0003ffff, 0x00000fff);
+	nvkm_mask(device, 0x122348, 0x0003ffff, 0x00000200);
+	nvkm_mask(device, 0x122358, 0x0003ffff, 0x00002880);
+	return 0;
 }
 
-static int
-gk104_ibus_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
-		struct nvkm_oclass *oclass, void *data, u32 size,
-		struct nvkm_object **pobject)
-{
-	struct nvkm_ibus *ibus;
-	int ret;
-
-	ret = nvkm_ibus_create(parent, engine, oclass, &ibus);
-	*pobject = nv_object(ibus);
-	if (ret)
-		return ret;
+static const struct nvkm_subdev_func
+gk104_ibus = {
+	.preinit = gk104_ibus_init,
+	.init = gk104_ibus_init,
+	.intr = gk104_ibus_intr,
+};
 
-	nv_subdev(ibus)->intr = gk104_ibus_intr;
+int
+gk104_ibus_new(struct nvkm_device *device, int index,
+	       struct nvkm_subdev **pibus)
+{
+	struct nvkm_subdev *ibus;
+	if (!(ibus = *pibus = kzalloc(sizeof(*ibus), GFP_KERNEL)))
+		return -ENOMEM;
+	nvkm_subdev_ctor(&gk104_ibus, device, index, 0, ibus);
 	return 0;
 }
-
-struct nvkm_oclass
-gk104_ibus_oclass = {
-	.handle = NV_SUBDEV(IBUS, 0xe0),
-	.ofuncs = &(struct nvkm_ofuncs) {
-		.ctor = gk104_ibus_ctor,
-		.dtor = _nvkm_ibus_dtor,
-		.init = gk104_ibus_init,
-		.fini = _nvkm_ibus_fini,
-	},
-};

commit 18019e95de4ffdfb020d61197b8da2af1a442c8e
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:12 2015 +1000

    drm/nouveau/ibus: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
index 53dd1ba389d7..0ac0bbaa9d2a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
@@ -26,33 +26,36 @@
 static void
 gk104_ibus_intr_hub(struct nvkm_ibus *ibus, int i)
 {
-	struct nvkm_device *device = ibus->subdev.device;
+	struct nvkm_subdev *subdev = &ibus->subdev;
+	struct nvkm_device *device = subdev->device;
 	u32 addr = nvkm_rd32(device, 0x122120 + (i * 0x0800));
 	u32 data = nvkm_rd32(device, 0x122124 + (i * 0x0800));
 	u32 stat = nvkm_rd32(device, 0x122128 + (i * 0x0800));
-	nv_error(ibus, "HUB%d: 0x%06x 0x%08x (0x%08x)\n", i, addr, data, stat);
+	nvkm_error(subdev, "HUB%d: %06x %08x (%08x)\n", i, addr, data, stat);
 	nvkm_mask(device, 0x122128 + (i * 0x0800), 0x00000200, 0x00000000);
 }
 
 static void
 gk104_ibus_intr_rop(struct nvkm_ibus *ibus, int i)
 {
-	struct nvkm_device *device = ibus->subdev.device;
+	struct nvkm_subdev *subdev = &ibus->subdev;
+	struct nvkm_device *device = subdev->device;
 	u32 addr = nvkm_rd32(device, 0x124120 + (i * 0x0800));
 	u32 data = nvkm_rd32(device, 0x124124 + (i * 0x0800));
 	u32 stat = nvkm_rd32(device, 0x124128 + (i * 0x0800));
-	nv_error(ibus, "ROP%d: 0x%06x 0x%08x (0x%08x)\n", i, addr, data, stat);
+	nvkm_error(subdev, "ROP%d: %06x %08x (%08x)\n", i, addr, data, stat);
 	nvkm_mask(device, 0x124128 + (i * 0x0800), 0x00000200, 0x00000000);
 }
 
 static void
 gk104_ibus_intr_gpc(struct nvkm_ibus *ibus, int i)
 {
-	struct nvkm_device *device = ibus->subdev.device;
+	struct nvkm_subdev *subdev = &ibus->subdev;
+	struct nvkm_device *device = subdev->device;
 	u32 addr = nvkm_rd32(device, 0x128120 + (i * 0x0800));
 	u32 data = nvkm_rd32(device, 0x128124 + (i * 0x0800));
 	u32 stat = nvkm_rd32(device, 0x128128 + (i * 0x0800));
-	nv_error(ibus, "GPC%d: 0x%06x 0x%08x (0x%08x)\n", i, addr, data, stat);
+	nvkm_error(subdev, "GPC%d: %06x %08x (%08x)\n", i, addr, data, stat);
 	nvkm_mask(device, 0x128128 + (i * 0x0800), 0x00000200, 0x00000000);
 }
 

commit fef5cc0f258d68d3a9ead1058461bf5f2e2796da
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:09 2015 +1000

    drm/nouveau/ibus: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
index 4107d9d25a04..53dd1ba389d7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
@@ -26,42 +26,46 @@
 static void
 gk104_ibus_intr_hub(struct nvkm_ibus *ibus, int i)
 {
-	u32 addr = nv_rd32(ibus, 0x122120 + (i * 0x0800));
-	u32 data = nv_rd32(ibus, 0x122124 + (i * 0x0800));
-	u32 stat = nv_rd32(ibus, 0x122128 + (i * 0x0800));
+	struct nvkm_device *device = ibus->subdev.device;
+	u32 addr = nvkm_rd32(device, 0x122120 + (i * 0x0800));
+	u32 data = nvkm_rd32(device, 0x122124 + (i * 0x0800));
+	u32 stat = nvkm_rd32(device, 0x122128 + (i * 0x0800));
 	nv_error(ibus, "HUB%d: 0x%06x 0x%08x (0x%08x)\n", i, addr, data, stat);
-	nv_mask(ibus, 0x122128 + (i * 0x0800), 0x00000200, 0x00000000);
+	nvkm_mask(device, 0x122128 + (i * 0x0800), 0x00000200, 0x00000000);
 }
 
 static void
 gk104_ibus_intr_rop(struct nvkm_ibus *ibus, int i)
 {
-	u32 addr = nv_rd32(ibus, 0x124120 + (i * 0x0800));
-	u32 data = nv_rd32(ibus, 0x124124 + (i * 0x0800));
-	u32 stat = nv_rd32(ibus, 0x124128 + (i * 0x0800));
+	struct nvkm_device *device = ibus->subdev.device;
+	u32 addr = nvkm_rd32(device, 0x124120 + (i * 0x0800));
+	u32 data = nvkm_rd32(device, 0x124124 + (i * 0x0800));
+	u32 stat = nvkm_rd32(device, 0x124128 + (i * 0x0800));
 	nv_error(ibus, "ROP%d: 0x%06x 0x%08x (0x%08x)\n", i, addr, data, stat);
-	nv_mask(ibus, 0x124128 + (i * 0x0800), 0x00000200, 0x00000000);
+	nvkm_mask(device, 0x124128 + (i * 0x0800), 0x00000200, 0x00000000);
 }
 
 static void
 gk104_ibus_intr_gpc(struct nvkm_ibus *ibus, int i)
 {
-	u32 addr = nv_rd32(ibus, 0x128120 + (i * 0x0800));
-	u32 data = nv_rd32(ibus, 0x128124 + (i * 0x0800));
-	u32 stat = nv_rd32(ibus, 0x128128 + (i * 0x0800));
+	struct nvkm_device *device = ibus->subdev.device;
+	u32 addr = nvkm_rd32(device, 0x128120 + (i * 0x0800));
+	u32 data = nvkm_rd32(device, 0x128124 + (i * 0x0800));
+	u32 stat = nvkm_rd32(device, 0x128128 + (i * 0x0800));
 	nv_error(ibus, "GPC%d: 0x%06x 0x%08x (0x%08x)\n", i, addr, data, stat);
-	nv_mask(ibus, 0x128128 + (i * 0x0800), 0x00000200, 0x00000000);
+	nvkm_mask(device, 0x128128 + (i * 0x0800), 0x00000200, 0x00000000);
 }
 
 static void
 gk104_ibus_intr(struct nvkm_subdev *subdev)
 {
 	struct nvkm_ibus *ibus = (void *)subdev;
-	u32 intr0 = nv_rd32(ibus, 0x120058);
-	u32 intr1 = nv_rd32(ibus, 0x12005c);
-	u32 hubnr = nv_rd32(ibus, 0x120070);
-	u32 ropnr = nv_rd32(ibus, 0x120074);
-	u32 gpcnr = nv_rd32(ibus, 0x120078);
+	struct nvkm_device *device = ibus->subdev.device;
+	u32 intr0 = nvkm_rd32(device, 0x120058);
+	u32 intr1 = nvkm_rd32(device, 0x12005c);
+	u32 hubnr = nvkm_rd32(device, 0x120070);
+	u32 ropnr = nvkm_rd32(device, 0x120074);
+	u32 gpcnr = nvkm_rd32(device, 0x120078);
 	u32 i;
 
 	for (i = 0; (intr0 & 0x0000ff00) && i < hubnr; i++) {
@@ -93,15 +97,16 @@ static int
 gk104_ibus_init(struct nvkm_object *object)
 {
 	struct nvkm_ibus *ibus = (void *)object;
+	struct nvkm_device *device = ibus->subdev.device;
 	int ret = nvkm_ibus_init(ibus);
 	if (ret == 0) {
-		nv_mask(ibus, 0x122318, 0x0003ffff, 0x00001000);
-		nv_mask(ibus, 0x12231c, 0x0003ffff, 0x00000200);
-		nv_mask(ibus, 0x122310, 0x0003ffff, 0x00000800);
-		nv_mask(ibus, 0x122348, 0x0003ffff, 0x00000100);
-		nv_mask(ibus, 0x1223b0, 0x0003ffff, 0x00000fff);
-		nv_mask(ibus, 0x122348, 0x0003ffff, 0x00000200);
-		nv_mask(ibus, 0x122358, 0x0003ffff, 0x00002880);
+		nvkm_mask(device, 0x122318, 0x0003ffff, 0x00001000);
+		nvkm_mask(device, 0x12231c, 0x0003ffff, 0x00000200);
+		nvkm_mask(device, 0x122310, 0x0003ffff, 0x00000800);
+		nvkm_mask(device, 0x122348, 0x0003ffff, 0x00000100);
+		nvkm_mask(device, 0x1223b0, 0x0003ffff, 0x00000fff);
+		nvkm_mask(device, 0x122348, 0x0003ffff, 0x00000200);
+		nvkm_mask(device, 0x122358, 0x0003ffff, 0x00002880);
 	}
 	return ret;
 }

commit ac51596f27d5cece39cb63b857e6ebbffa05ca33
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/ibus: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
index 7b6e9a6cd7b2..4107d9d25a04 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
@@ -23,55 +23,51 @@
  */
 #include <subdev/ibus.h>
 
-struct gk104_ibus_priv {
-	struct nvkm_ibus base;
-};
-
 static void
-gk104_ibus_intr_hub(struct gk104_ibus_priv *priv, int i)
+gk104_ibus_intr_hub(struct nvkm_ibus *ibus, int i)
 {
-	u32 addr = nv_rd32(priv, 0x122120 + (i * 0x0800));
-	u32 data = nv_rd32(priv, 0x122124 + (i * 0x0800));
-	u32 stat = nv_rd32(priv, 0x122128 + (i * 0x0800));
-	nv_error(priv, "HUB%d: 0x%06x 0x%08x (0x%08x)\n", i, addr, data, stat);
-	nv_mask(priv, 0x122128 + (i * 0x0800), 0x00000200, 0x00000000);
+	u32 addr = nv_rd32(ibus, 0x122120 + (i * 0x0800));
+	u32 data = nv_rd32(ibus, 0x122124 + (i * 0x0800));
+	u32 stat = nv_rd32(ibus, 0x122128 + (i * 0x0800));
+	nv_error(ibus, "HUB%d: 0x%06x 0x%08x (0x%08x)\n", i, addr, data, stat);
+	nv_mask(ibus, 0x122128 + (i * 0x0800), 0x00000200, 0x00000000);
 }
 
 static void
-gk104_ibus_intr_rop(struct gk104_ibus_priv *priv, int i)
+gk104_ibus_intr_rop(struct nvkm_ibus *ibus, int i)
 {
-	u32 addr = nv_rd32(priv, 0x124120 + (i * 0x0800));
-	u32 data = nv_rd32(priv, 0x124124 + (i * 0x0800));
-	u32 stat = nv_rd32(priv, 0x124128 + (i * 0x0800));
-	nv_error(priv, "ROP%d: 0x%06x 0x%08x (0x%08x)\n", i, addr, data, stat);
-	nv_mask(priv, 0x124128 + (i * 0x0800), 0x00000200, 0x00000000);
+	u32 addr = nv_rd32(ibus, 0x124120 + (i * 0x0800));
+	u32 data = nv_rd32(ibus, 0x124124 + (i * 0x0800));
+	u32 stat = nv_rd32(ibus, 0x124128 + (i * 0x0800));
+	nv_error(ibus, "ROP%d: 0x%06x 0x%08x (0x%08x)\n", i, addr, data, stat);
+	nv_mask(ibus, 0x124128 + (i * 0x0800), 0x00000200, 0x00000000);
 }
 
 static void
-gk104_ibus_intr_gpc(struct gk104_ibus_priv *priv, int i)
+gk104_ibus_intr_gpc(struct nvkm_ibus *ibus, int i)
 {
-	u32 addr = nv_rd32(priv, 0x128120 + (i * 0x0800));
-	u32 data = nv_rd32(priv, 0x128124 + (i * 0x0800));
-	u32 stat = nv_rd32(priv, 0x128128 + (i * 0x0800));
-	nv_error(priv, "GPC%d: 0x%06x 0x%08x (0x%08x)\n", i, addr, data, stat);
-	nv_mask(priv, 0x128128 + (i * 0x0800), 0x00000200, 0x00000000);
+	u32 addr = nv_rd32(ibus, 0x128120 + (i * 0x0800));
+	u32 data = nv_rd32(ibus, 0x128124 + (i * 0x0800));
+	u32 stat = nv_rd32(ibus, 0x128128 + (i * 0x0800));
+	nv_error(ibus, "GPC%d: 0x%06x 0x%08x (0x%08x)\n", i, addr, data, stat);
+	nv_mask(ibus, 0x128128 + (i * 0x0800), 0x00000200, 0x00000000);
 }
 
 static void
 gk104_ibus_intr(struct nvkm_subdev *subdev)
 {
-	struct gk104_ibus_priv *priv = (void *)subdev;
-	u32 intr0 = nv_rd32(priv, 0x120058);
-	u32 intr1 = nv_rd32(priv, 0x12005c);
-	u32 hubnr = nv_rd32(priv, 0x120070);
-	u32 ropnr = nv_rd32(priv, 0x120074);
-	u32 gpcnr = nv_rd32(priv, 0x120078);
+	struct nvkm_ibus *ibus = (void *)subdev;
+	u32 intr0 = nv_rd32(ibus, 0x120058);
+	u32 intr1 = nv_rd32(ibus, 0x12005c);
+	u32 hubnr = nv_rd32(ibus, 0x120070);
+	u32 ropnr = nv_rd32(ibus, 0x120074);
+	u32 gpcnr = nv_rd32(ibus, 0x120078);
 	u32 i;
 
 	for (i = 0; (intr0 & 0x0000ff00) && i < hubnr; i++) {
 		u32 stat = 0x00000100 << i;
 		if (intr0 & stat) {
-			gk104_ibus_intr_hub(priv, i);
+			gk104_ibus_intr_hub(ibus, i);
 			intr0 &= ~stat;
 		}
 	}
@@ -79,7 +75,7 @@ gk104_ibus_intr(struct nvkm_subdev *subdev)
 	for (i = 0; (intr0 & 0xffff0000) && i < ropnr; i++) {
 		u32 stat = 0x00010000 << i;
 		if (intr0 & stat) {
-			gk104_ibus_intr_rop(priv, i);
+			gk104_ibus_intr_rop(ibus, i);
 			intr0 &= ~stat;
 		}
 	}
@@ -87,7 +83,7 @@ gk104_ibus_intr(struct nvkm_subdev *subdev)
 	for (i = 0; intr1 && i < gpcnr; i++) {
 		u32 stat = 0x00000001 << i;
 		if (intr1 & stat) {
-			gk104_ibus_intr_gpc(priv, i);
+			gk104_ibus_intr_gpc(ibus, i);
 			intr1 &= ~stat;
 		}
 	}
@@ -96,16 +92,16 @@ gk104_ibus_intr(struct nvkm_subdev *subdev)
 static int
 gk104_ibus_init(struct nvkm_object *object)
 {
-	struct gk104_ibus_priv *priv = (void *)object;
-	int ret = nvkm_ibus_init(&priv->base);
+	struct nvkm_ibus *ibus = (void *)object;
+	int ret = nvkm_ibus_init(ibus);
 	if (ret == 0) {
-		nv_mask(priv, 0x122318, 0x0003ffff, 0x00001000);
-		nv_mask(priv, 0x12231c, 0x0003ffff, 0x00000200);
-		nv_mask(priv, 0x122310, 0x0003ffff, 0x00000800);
-		nv_mask(priv, 0x122348, 0x0003ffff, 0x00000100);
-		nv_mask(priv, 0x1223b0, 0x0003ffff, 0x00000fff);
-		nv_mask(priv, 0x122348, 0x0003ffff, 0x00000200);
-		nv_mask(priv, 0x122358, 0x0003ffff, 0x00002880);
+		nv_mask(ibus, 0x122318, 0x0003ffff, 0x00001000);
+		nv_mask(ibus, 0x12231c, 0x0003ffff, 0x00000200);
+		nv_mask(ibus, 0x122310, 0x0003ffff, 0x00000800);
+		nv_mask(ibus, 0x122348, 0x0003ffff, 0x00000100);
+		nv_mask(ibus, 0x1223b0, 0x0003ffff, 0x00000fff);
+		nv_mask(ibus, 0x122348, 0x0003ffff, 0x00000200);
+		nv_mask(ibus, 0x122358, 0x0003ffff, 0x00002880);
 	}
 	return ret;
 }
@@ -115,15 +111,15 @@ gk104_ibus_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		struct nvkm_oclass *oclass, void *data, u32 size,
 		struct nvkm_object **pobject)
 {
-	struct gk104_ibus_priv *priv;
+	struct nvkm_ibus *ibus;
 	int ret;
 
-	ret = nvkm_ibus_create(parent, engine, oclass, &priv);
-	*pobject = nv_object(priv);
+	ret = nvkm_ibus_create(parent, engine, oclass, &ibus);
+	*pobject = nv_object(ibus);
 	if (ret)
 		return ret;
 
-	nv_subdev(priv)->intr = gk104_ibus_intr;
+	nv_subdev(ibus)->intr = gk104_ibus_intr;
 	return 0;
 }
 

commit 5ecfadeb89a63b414bfd26ad469b39037930485e
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:04:31 2015 +1000

    drm/nouveau/ibus: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
new file mode 100644
index 000000000000..7b6e9a6cd7b2
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/ibus/gk104.c
@@ -0,0 +1,139 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+#include <subdev/ibus.h>
+
+struct gk104_ibus_priv {
+	struct nvkm_ibus base;
+};
+
+static void
+gk104_ibus_intr_hub(struct gk104_ibus_priv *priv, int i)
+{
+	u32 addr = nv_rd32(priv, 0x122120 + (i * 0x0800));
+	u32 data = nv_rd32(priv, 0x122124 + (i * 0x0800));
+	u32 stat = nv_rd32(priv, 0x122128 + (i * 0x0800));
+	nv_error(priv, "HUB%d: 0x%06x 0x%08x (0x%08x)\n", i, addr, data, stat);
+	nv_mask(priv, 0x122128 + (i * 0x0800), 0x00000200, 0x00000000);
+}
+
+static void
+gk104_ibus_intr_rop(struct gk104_ibus_priv *priv, int i)
+{
+	u32 addr = nv_rd32(priv, 0x124120 + (i * 0x0800));
+	u32 data = nv_rd32(priv, 0x124124 + (i * 0x0800));
+	u32 stat = nv_rd32(priv, 0x124128 + (i * 0x0800));
+	nv_error(priv, "ROP%d: 0x%06x 0x%08x (0x%08x)\n", i, addr, data, stat);
+	nv_mask(priv, 0x124128 + (i * 0x0800), 0x00000200, 0x00000000);
+}
+
+static void
+gk104_ibus_intr_gpc(struct gk104_ibus_priv *priv, int i)
+{
+	u32 addr = nv_rd32(priv, 0x128120 + (i * 0x0800));
+	u32 data = nv_rd32(priv, 0x128124 + (i * 0x0800));
+	u32 stat = nv_rd32(priv, 0x128128 + (i * 0x0800));
+	nv_error(priv, "GPC%d: 0x%06x 0x%08x (0x%08x)\n", i, addr, data, stat);
+	nv_mask(priv, 0x128128 + (i * 0x0800), 0x00000200, 0x00000000);
+}
+
+static void
+gk104_ibus_intr(struct nvkm_subdev *subdev)
+{
+	struct gk104_ibus_priv *priv = (void *)subdev;
+	u32 intr0 = nv_rd32(priv, 0x120058);
+	u32 intr1 = nv_rd32(priv, 0x12005c);
+	u32 hubnr = nv_rd32(priv, 0x120070);
+	u32 ropnr = nv_rd32(priv, 0x120074);
+	u32 gpcnr = nv_rd32(priv, 0x120078);
+	u32 i;
+
+	for (i = 0; (intr0 & 0x0000ff00) && i < hubnr; i++) {
+		u32 stat = 0x00000100 << i;
+		if (intr0 & stat) {
+			gk104_ibus_intr_hub(priv, i);
+			intr0 &= ~stat;
+		}
+	}
+
+	for (i = 0; (intr0 & 0xffff0000) && i < ropnr; i++) {
+		u32 stat = 0x00010000 << i;
+		if (intr0 & stat) {
+			gk104_ibus_intr_rop(priv, i);
+			intr0 &= ~stat;
+		}
+	}
+
+	for (i = 0; intr1 && i < gpcnr; i++) {
+		u32 stat = 0x00000001 << i;
+		if (intr1 & stat) {
+			gk104_ibus_intr_gpc(priv, i);
+			intr1 &= ~stat;
+		}
+	}
+}
+
+static int
+gk104_ibus_init(struct nvkm_object *object)
+{
+	struct gk104_ibus_priv *priv = (void *)object;
+	int ret = nvkm_ibus_init(&priv->base);
+	if (ret == 0) {
+		nv_mask(priv, 0x122318, 0x0003ffff, 0x00001000);
+		nv_mask(priv, 0x12231c, 0x0003ffff, 0x00000200);
+		nv_mask(priv, 0x122310, 0x0003ffff, 0x00000800);
+		nv_mask(priv, 0x122348, 0x0003ffff, 0x00000100);
+		nv_mask(priv, 0x1223b0, 0x0003ffff, 0x00000fff);
+		nv_mask(priv, 0x122348, 0x0003ffff, 0x00000200);
+		nv_mask(priv, 0x122358, 0x0003ffff, 0x00002880);
+	}
+	return ret;
+}
+
+static int
+gk104_ibus_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
+		struct nvkm_oclass *oclass, void *data, u32 size,
+		struct nvkm_object **pobject)
+{
+	struct gk104_ibus_priv *priv;
+	int ret;
+
+	ret = nvkm_ibus_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	nv_subdev(priv)->intr = gk104_ibus_intr;
+	return 0;
+}
+
+struct nvkm_oclass
+gk104_ibus_oclass = {
+	.handle = NV_SUBDEV(IBUS, 0xe0),
+	.ofuncs = &(struct nvkm_ofuncs) {
+		.ctor = gk104_ibus_ctor,
+		.dtor = _nvkm_ibus_dtor,
+		.init = gk104_ibus_init,
+		.fini = _nvkm_ibus_fini,
+	},
+};
