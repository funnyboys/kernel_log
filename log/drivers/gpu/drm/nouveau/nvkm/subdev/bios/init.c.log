commit 9f9b450752d38c86f4f830214bb9276ed174d5d3
Author: Rhys Kidd <rhyskidd@gmail.com>
Date:   Mon Jun 3 00:13:15 2019 +1000

    drm/nouveau/bios/init: handle INIT_RESET_END devinit opcode
    
    Signal that the reset sequence has completed.
    
    This opcode signals that the software reset sequence has completed.
    Ordinarily, no actual operations are performed by the opcode.
    However it allows for possible software work arounds by devinit
    engines in software agents other than the VBIOS, such as the resman,
    FCODE, and EFI driver.
    
    Signed-off-by: Rhys Kidd <rhyskidd@gmail.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index 5e02832304e2..9de74f41dcd2 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -1945,6 +1945,17 @@ init_reset_begun(struct nvbios_init *init)
 	init->offset += 1;
 }
 
+/**
+ * INIT_RESET_END - opcode 0x8d
+ *
+ */
+static void
+init_reset_end(struct nvbios_init *init)
+{
+	trace("RESET_END\n");
+	init->offset += 1;
+}
+
 /**
  * INIT_GPIO - opcode 0x8e
  *
@@ -2272,7 +2283,7 @@ static struct nvbios_init_opcode {
 	[0x7a] = { init_zm_reg },
 	[0x87] = { init_ram_restrict_pll },
 	[0x8c] = { init_reset_begun },
-	[0x8d] = { init_reserved },
+	[0x8d] = { init_reset_end },
 	[0x8e] = { init_gpio },
 	[0x8f] = { init_ram_restrict_zm_reg_group },
 	[0x90] = { init_copy_zm_reg },

commit 66cbcc72ae34711854ae7af8056bfb7169f874fd
Author: Rhys Kidd <rhyskidd@gmail.com>
Date:   Mon Jun 3 00:13:14 2019 +1000

    drm/nouveau/bios/init: handle INIT_RESET_BEGUN devinit opcode
    
    Signal that the reset sequence has begun.
    
    This opcode signals that the software reset sequence has begun.
    Ordinarily, no actual operations are performed by the opcode.
    However it allows for possible software work arounds by devinit
    engines in software agents other than the VBIOS, such as the resman,
    FCODE, and EFI driver.
    
    Signed-off-by: Rhys Kidd <rhyskidd@gmail.com>
    Reviewed-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index 3f4f27d191ae..5e02832304e2 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -1934,6 +1934,17 @@ init_ram_restrict_pll(struct nvbios_init *init)
 	}
 }
 
+/**
+ * INIT_RESET_BEGUN - opcode 0x8c
+ *
+ */
+static void
+init_reset_begun(struct nvbios_init *init)
+{
+	trace("RESET_BEGUN\n");
+	init->offset += 1;
+}
+
 /**
  * INIT_GPIO - opcode 0x8e
  *
@@ -2260,7 +2271,7 @@ static struct nvbios_init_opcode {
 	[0x79] = { init_pll },
 	[0x7a] = { init_zm_reg },
 	[0x87] = { init_ram_restrict_pll },
-	[0x8c] = { init_reserved },
+	[0x8c] = { init_reset_begun },
 	[0x8d] = { init_reserved },
 	[0x8e] = { init_gpio },
 	[0x8f] = { init_ram_restrict_zm_reg_group },

commit fcca420d66046d5ddac55a9ddecb0e387547f7a0
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue May 14 21:57:01 2019 +0100

    drm/nouveau/bios/init: fix spelling mistake "CONDITON" -> "CONDITION"
    
    There is a spelling mistake in a warning message. Fix it.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Mukesh Ojha <mojha@codeaurora.org>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index ec0e9f7224b5..3f4f27d191ae 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -834,7 +834,7 @@ init_generic_condition(struct nvbios_init *init)
 		init_exec_set(init, false);
 		break;
 	default:
-		warn("INIT_GENERIC_CONDITON: unknown 0x%02x\n", cond);
+		warn("INIT_GENERIC_CONDITION: unknown 0x%02x\n", cond);
 		init->offset += size;
 		break;
 	}

commit eb972d1474717a329ac6b682e9e9e9f17197ff10
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Feb 12 22:28:13 2019 +1000

    drm/nouveau/bios/init: handle INIT_GENERIC_CONDITION_ID_NO_PANEL_SEQ_DELAYS
    
    As I currently understand it, this is related to features we have no
    support for as of yet.
    
    In theory, this change should be a noop, just without the warning.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index 5146359430df..ec0e9f7224b5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -830,6 +830,9 @@ init_generic_condition(struct nvbios_init *init)
 		if (!(init_rdauxr(init, 0x0d) & 1))
 			init_exec_set(init, false);
 		break;
+	case 7: /* CONDITION_ID_NO_PANEL_SEQ_DELAYS. */
+		init_exec_set(init, false);
+		break;
 	default:
 		warn("INIT_GENERIC_CONDITON: unknown 0x%02x\n", cond);
 		init->offset += size;

commit 81f2bb5d65721acf1d98017623c0dd603f2bc767
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Feb 12 22:28:13 2019 +1000

    drm/nouveau/bios/init: label existing INIT_GENERIC_CONDITION types
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index 9cc10e438b3d..5146359430df 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -806,12 +806,12 @@ init_generic_condition(struct nvbios_init *init)
 	init->offset += 3;
 
 	switch (cond) {
-	case 0:
+	case 0: /* CONDITION_ID_INT_DP. */
 		if (init_conn(init) != DCB_CONNECTOR_eDP)
 			init_exec_set(init, false);
 		break;
-	case 1:
-	case 2:
+	case 1: /* CONDITION_ID_USE_SPPLL0. */
+	case 2: /* CONDITION_ID_USE_SPPLL1. */
 		if ( init->outp &&
 		    (data = nvbios_dpout_match(bios, DCB_OUTPUT_DP,
 					       (init->outp->or << 0) |
@@ -826,7 +826,7 @@ init_generic_condition(struct nvbios_init *init)
 		if (init_exec(init))
 			warn("script needs dp output table data\n");
 		break;
-	case 5:
+	case 5: /* CONDITION_ID_ASSR_SUPPORT. */
 		if (!(init_rdauxr(init, 0x0d) & 1))
 			init_exec_set(init, false);
 		break;

commit 73cef6cee71b7a1029e4951a97095c2e4fee4be7
Author: Jérémy Lefaure <jeremy.lefaure@lse.epita.fr>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/bios/init: use ARRAY_SIZE
    
    Using the ARRAY_SIZE macro improves the readability of the code. Also,
    it is useless to re-invent it.
    
    Found with Coccinelle with the following semantic patch:
    @r depends on (org || report)@
    type T;
    T[] E;
    position p;
    @@
    (
     (sizeof(E)@p /sizeof(*E))
    |
     (sizeof(E)@p /sizeof(E[...]))
    |
     (sizeof(E)@p /sizeof(T))
    )
    
    Reviewed-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Jérémy Lefaure <jeremy.lefaure@lse.epita.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index b58ee99f7bfc..9cc10e438b3d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -36,6 +36,8 @@
 #include <subdev/i2c.h>
 #include <subdev/vga.h>
 
+#include <linux/kernel.h>
+
 #define bioslog(lvl, fmt, args...) do {                                        \
 	nvkm_printk(init->subdev, lvl, info, "0x%08x[%c]: "fmt,                \
 		    init->offset, init_exec(init) ?                            \
@@ -2271,8 +2273,6 @@ static struct nvbios_init_opcode {
 	[0xaa] = { init_reserved },
 };
 
-#define init_opcode_nr (sizeof(init_opcode) / sizeof(init_opcode[0]))
-
 int
 nvbios_exec(struct nvbios_init *init)
 {
@@ -2281,7 +2281,8 @@ nvbios_exec(struct nvbios_init *init)
 	init->nested++;
 	while (init->offset) {
 		u8 opcode = nvbios_rd08(bios, init->offset);
-		if (opcode >= init_opcode_nr || !init_opcode[opcode].exec) {
+		if (opcode >= ARRAY_SIZE(init_opcode) ||
+		    !init_opcode[opcode].exec) {
 			error("unknown opcode 0x%02x\n", opcode);
 			return -EINVAL;
 		}

commit 0d93cd92bd616474da0c842bc4e88f6921da18f1
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:35 2017 +1000

    drm/nouveau/disp/nv50-: implement a common supervisor 3.0
    
    This makes use of all the additional routing and state added in previous
    commits, making it possible to deal with GM20x macro link routing, while
    also sharing code between the NV50 and GF119 implementations.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index 2095f43e16ac..b58ee99f7bfc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -2278,11 +2278,6 @@ nvbios_exec(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->subdev->device->bios;
 
-	if (init->bios) {
-		init->or = init->outp ? ffs(init->outp->or) - 1 : -1;
-		init->link = init->outp ? init->outp->sorconf.link : 0;
-	}
-
 	init->nested++;
 	while (init->offset) {
 		u8 opcode = nvbios_rd08(bios, init->offset);

commit 28c62976a8a7de7cbdc6908ec0d575cef3cfe288
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/devinit: use new devinit script interpreter entry-point
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index b1256aba2fdb..2095f43e16ac 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -2308,32 +2308,18 @@ nvbios_post(struct nvkm_subdev *subdev, bool execute)
 	if (execute)
 		nvkm_debug(subdev, "running init tables\n");
 	while (!ret && (data = (init_script(bios, ++i)))) {
-		struct nvbios_init init = {
-			.subdev = subdev,
-			.bios = bios,
-			.offset = data,
-			.outp = NULL,
-			.head = -1,
-			.execute = execute ? 1 : 0,
-		};
-
-		ret = nvbios_exec(&init);
+		ret = nvbios_init(subdev, data,
+			init.execute = execute ? 1 : 0;
+		      );
 	}
 
 	/* the vbios parser will run this right after the normal init
 	 * tables, whereas the binary driver appears to run it later.
 	 */
 	if (!ret && (data = init_unknown_script(bios))) {
-		struct nvbios_init init = {
-			.subdev = subdev,
-			.bios = bios,
-			.offset = data,
-			.outp = NULL,
-			.head = -1,
-			.execute = execute ? 1 : 0,
-		};
-
-		ret = nvbios_exec(&init);
+		ret = nvbios_init(subdev, data,
+			init.execute = execute ? 1 : 0;
+		      );
 	}
 
 	return ret;

commit b88afa43967578741e3b258c80e01969fddd5fe6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/bios/init: add or/link args separate from output path
    
    As of DCB 4.1, these are not the same thing.
    
    Compatibility temporarily in place until callers have been updated.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index 249d018ee32c..b1256aba2fdb 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -87,8 +87,8 @@ static inline int
 init_or(struct nvbios_init *init)
 {
 	if (init_exec(init)) {
-		if (init->outp)
-			return ffs(init->outp->or) - 1;
+		if (init->or >= 0)
+			return init->or;
 		error("script needs OR!!\n");
 	}
 	return 0;
@@ -98,8 +98,8 @@ static inline int
 init_link(struct nvbios_init *init)
 {
 	if (init_exec(init)) {
-		if (init->outp)
-			return !(init->outp->sorconf.link & 1);
+		if (init->link)
+			return init->link == 2;
 		error("script needs OR link\n");
 	}
 	return 0;
@@ -2277,6 +2277,12 @@ int
 nvbios_exec(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->subdev->device->bios;
+
+	if (init->bios) {
+		init->or = init->outp ? ffs(init->outp->or) - 1 : -1;
+		init->link = init->outp ? init->outp->sorconf.link : 0;
+	}
+
 	init->nested++;
 	while (init->offset) {
 		u8 opcode = nvbios_rd08(bios, init->offset);

commit ca9c2d5b28b4d5aa1d229950b88f7c559eee4164
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/bios/init: bump script offset to 32-bits
    
    No (known) case yet, but other tables have been moving beyond 16-bits,
    so we may as well be prepared.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index e177457084a7..249d018ee32c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -37,7 +37,7 @@
 #include <subdev/vga.h>
 
 #define bioslog(lvl, fmt, args...) do {                                        \
-	nvkm_printk(init->subdev, lvl, info, "0x%04x[%c]: "fmt,                \
+	nvkm_printk(init->subdev, lvl, info, "0x%08x[%c]: "fmt,                \
 		    init->offset, init_exec(init) ?                            \
 		    '0' + (init->nested - 1) : ' ', ##args);                   \
 } while(0)

commit 2195a22f6dd9f413c952b81dd228db606e32c67c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/bios/init: rename 'crtc' to 'head'
    
    Compatibility temporarily in place until all callers have been updated.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index 1894b2490651..e177457084a7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -106,12 +106,12 @@ init_link(struct nvbios_init *init)
 }
 
 static inline int
-init_crtc(struct nvbios_init *init)
+init_head(struct nvbios_init *init)
 {
 	if (init_exec(init)) {
-		if (init->crtc >= 0)
-			return init->crtc;
-		error("script needs crtc\n");
+		if (init->head >= 0)
+			return init->head;
+		error("script needs head\n");
 	}
 	return 0;
 }
@@ -156,7 +156,7 @@ init_nvreg(struct nvbios_init *init, u32 reg)
 	 */
 	if (init->subdev->device->card_type >= NV_50) {
 		if (reg & 0x80000000) {
-			reg += init_crtc(init) * 0x800;
+			reg += init_head(init) * 0x800;
 			reg &= ~0x80000000;
 		}
 
@@ -212,7 +212,7 @@ static u8
 init_rdport(struct nvbios_init *init, u16 port)
 {
 	if (init_exec(init))
-		return nvkm_rdport(init->subdev->device, init->crtc, port);
+		return nvkm_rdport(init->subdev->device, init->head, port);
 	return 0x00;
 }
 
@@ -220,7 +220,7 @@ static void
 init_wrport(struct nvbios_init *init, u16 port, u8 value)
 {
 	if (init_exec(init))
-		nvkm_wrport(init->subdev->device, init->crtc, port, value);
+		nvkm_wrport(init->subdev->device, init->head, port, value);
 }
 
 static u8
@@ -228,7 +228,7 @@ init_rdvgai(struct nvbios_init *init, u16 port, u8 index)
 {
 	struct nvkm_subdev *subdev = init->subdev;
 	if (init_exec(init)) {
-		int head = init->crtc < 0 ? 0 : init->crtc;
+		int head = init->head < 0 ? 0 : init->head;
 		return nvkm_rdvgai(subdev->device, head, port, index);
 	}
 	return 0x00;
@@ -242,18 +242,18 @@ init_wrvgai(struct nvbios_init *init, u16 port, u8 index, u8 value)
 	/* force head 0 for updates to cr44, it only exists on first head */
 	if (device->card_type < NV_50) {
 		if (port == 0x03d4 && index == 0x44)
-			init->crtc = 0;
+			init->head = 0;
 	}
 
 	if (init_exec(init)) {
-		int head = init->crtc < 0 ? 0 : init->crtc;
+		int head = init->head < 0 ? 0 : init->head;
 		nvkm_wrvgai(device, head, port, index, value);
 	}
 
 	/* select head 1 if cr44 write selected it */
 	if (device->card_type < NV_50) {
 		if (port == 0x03d4 && index == 0x44 && value == 3)
-			init->crtc = 1;
+			init->head = 1;
 	}
 }
 
@@ -2307,7 +2307,7 @@ nvbios_post(struct nvkm_subdev *subdev, bool execute)
 			.bios = bios,
 			.offset = data,
 			.outp = NULL,
-			.crtc = -1,
+			.head = -1,
 			.execute = execute ? 1 : 0,
 		};
 
@@ -2323,7 +2323,7 @@ nvbios_post(struct nvkm_subdev *subdev, bool execute)
 			.bios = bios,
 			.offset = data,
 			.outp = NULL,
-			.crtc = -1,
+			.head = -1,
 			.execute = execute ? 1 : 0,
 		};
 

commit 5b0e787ad599a8e6803daf743dfc4642018ba469
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/bios/init: remove internal use of nvbios_init.bios
    
    We already have a subdev pointer, from which we can locate the device's
    BIOS subdev.  No need for a separate pointer.
    
    Structure/callers not updated yet, as I want to batch more changes and
    only touch the callers once.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index 1d5f29a5c07c..1894b2490651 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -119,7 +119,7 @@ init_crtc(struct nvbios_init *init)
 static u8
 init_conn(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	struct nvbios_connE connE;
 	u8  ver, hdr;
 	u32 conn;
@@ -141,7 +141,7 @@ init_conn(struct nvbios_init *init)
 static inline u32
 init_nvreg(struct nvbios_init *init, u32 reg)
 {
-	struct nvkm_devinit *devinit = init->bios->subdev.device->devinit;
+	struct nvkm_devinit *devinit = init->subdev->device->devinit;
 
 	/* C51 (at least) sometimes has the lower bits set which the VBIOS
 	 * interprets to mean that access needs to go through certain IO
@@ -154,7 +154,7 @@ init_nvreg(struct nvbios_init *init, u32 reg)
 	/* GF8+ display scripts need register addresses mangled a bit to
 	 * select a specific CRTC/OR
 	 */
-	if (init->bios->subdev.device->card_type >= NV_50) {
+	if (init->subdev->device->card_type >= NV_50) {
 		if (reg & 0x80000000) {
 			reg += init_crtc(init) * 0x800;
 			reg &= ~0x80000000;
@@ -179,7 +179,7 @@ init_nvreg(struct nvbios_init *init, u32 reg)
 static u32
 init_rd32(struct nvbios_init *init, u32 reg)
 {
-	struct nvkm_device *device = init->bios->subdev.device;
+	struct nvkm_device *device = init->subdev->device;
 	reg = init_nvreg(init, reg);
 	if (reg != ~0 && init_exec(init))
 		return nvkm_rd32(device, reg);
@@ -189,7 +189,7 @@ init_rd32(struct nvbios_init *init, u32 reg)
 static void
 init_wr32(struct nvbios_init *init, u32 reg, u32 val)
 {
-	struct nvkm_device *device = init->bios->subdev.device;
+	struct nvkm_device *device = init->subdev->device;
 	reg = init_nvreg(init, reg);
 	if (reg != ~0 && init_exec(init))
 		nvkm_wr32(device, reg, val);
@@ -198,7 +198,7 @@ init_wr32(struct nvbios_init *init, u32 reg, u32 val)
 static u32
 init_mask(struct nvbios_init *init, u32 reg, u32 mask, u32 val)
 {
-	struct nvkm_device *device = init->bios->subdev.device;
+	struct nvkm_device *device = init->subdev->device;
 	reg = init_nvreg(init, reg);
 	if (reg != ~0 && init_exec(init)) {
 		u32 tmp = nvkm_rd32(device, reg);
@@ -260,7 +260,7 @@ init_wrvgai(struct nvbios_init *init, u16 port, u8 index, u8 value)
 static struct i2c_adapter *
 init_i2c(struct nvbios_init *init, int index)
 {
-	struct nvkm_i2c *i2c = init->bios->subdev.device->i2c;
+	struct nvkm_i2c *i2c = init->subdev->device->i2c;
 	struct nvkm_i2c_bus *bus;
 
 	if (index == 0xff) {
@@ -300,7 +300,7 @@ init_wri2cr(struct nvbios_init *init, u8 index, u8 addr, u8 reg, u8 val)
 static struct nvkm_i2c_aux *
 init_aux(struct nvbios_init *init)
 {
-	struct nvkm_i2c *i2c = init->bios->subdev.device->i2c;
+	struct nvkm_i2c *i2c = init->subdev->device->i2c;
 	if (!init->outp) {
 		if (init_exec(init))
 			error("script needs output for aux\n");
@@ -341,7 +341,7 @@ init_wrauxr(struct nvbios_init *init, u32 addr, u8 data)
 static void
 init_prog_pll(struct nvbios_init *init, u32 id, u32 freq)
 {
-	struct nvkm_devinit *devinit = init->bios->subdev.device->devinit;
+	struct nvkm_devinit *devinit = init->subdev->device->devinit;
 	if (init_exec(init)) {
 		int ret = nvkm_devinit_pll_set(devinit, id, freq);
 		if (ret)
@@ -374,7 +374,7 @@ init_table(struct nvkm_bios *bios, u16 *len)
 static u16
 init_table_(struct nvbios_init *init, u16 offset, const char *name)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u16 len, data = init_table(bios, &len);
 	if (data) {
 		if (len >= offset + 2) {
@@ -406,7 +406,7 @@ init_table_(struct nvbios_init *init, u16 offset, const char *name)
 static u16
 init_script(struct nvkm_bios *bios, int index)
 {
-	struct nvbios_init init = { .bios = bios };
+	struct nvbios_init init = { .subdev = &bios->subdev };
 	u16 bmp_ver = bmp_version(bios), data;
 
 	if (bmp_ver && bmp_ver < 0x0510) {
@@ -436,7 +436,7 @@ init_unknown_script(struct nvkm_bios *bios)
 static u8
 init_ram_restrict_group_count(struct nvbios_init *init)
 {
-	return nvbios_ramcfg_count(init->bios);
+	return nvbios_ramcfg_count(init->subdev->device->bios);
 }
 
 static u8
@@ -450,7 +450,7 @@ init_ram_restrict(struct nvbios_init *init)
 	 * Preserving the non-caching behaviour on earlier chipsets just
 	 * in case *not* re-reading the strap causes similar breakage.
 	 */
-	if (!init->ramcfg || init->bios->version.major < 0x70)
+	if (!init->ramcfg || init->subdev->device->bios->version.major < 0x70)
 		init->ramcfg = 0x80000000 | nvbios_ramcfg_index(init->subdev);
 	return (init->ramcfg & 0x7fffffff);
 }
@@ -458,7 +458,7 @@ init_ram_restrict(struct nvbios_init *init)
 static u8
 init_xlat_(struct nvbios_init *init, u8 index, u8 offset)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u16 table = init_xlat_table(init);
 	if (table) {
 		u16 data = nvbios_rd16(bios, table + (index * 2));
@@ -476,7 +476,7 @@ init_xlat_(struct nvbios_init *init, u8 index, u8 offset)
 static bool
 init_condition_met(struct nvbios_init *init, u8 cond)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u16 table = init_condition_table(init);
 	if (table) {
 		u32 reg = nvbios_rd32(bios, table + (cond * 12) + 0);
@@ -492,7 +492,7 @@ init_condition_met(struct nvbios_init *init, u8 cond)
 static bool
 init_io_condition_met(struct nvbios_init *init, u8 cond)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u16 table = init_io_condition_table(init);
 	if (table) {
 		u16 port = nvbios_rd16(bios, table + (cond * 5) + 0);
@@ -509,7 +509,7 @@ init_io_condition_met(struct nvbios_init *init, u8 cond)
 static bool
 init_io_flag_condition_met(struct nvbios_init *init, u8 cond)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u16 table = init_io_flag_condition_table(init);
 	if (table) {
 		u16 port = nvbios_rd16(bios, table + (cond * 9) + 0);
@@ -580,7 +580,8 @@ init_tmds_reg(struct nvbios_init *init, u8 tmds)
 static void
 init_reserved(struct nvbios_init *init)
 {
-	u8 opcode = nvbios_rd08(init->bios, init->offset);
+	struct nvkm_bios *bios = init->subdev->device->bios;
+	u8 opcode = nvbios_rd08(bios, init->offset);
 	u8 length, i;
 
 	switch (opcode) {
@@ -594,7 +595,7 @@ init_reserved(struct nvbios_init *init)
 
 	trace("RESERVED 0x%02x\t", opcode);
 	for (i = 1; i < length; i++)
-		cont(" 0x%02x", nvbios_rd08(init->bios, init->offset + i));
+		cont(" 0x%02x", nvbios_rd08(bios, init->offset + i));
 	cont("\n");
 	init->offset += length;
 }
@@ -617,7 +618,7 @@ init_done(struct nvbios_init *init)
 static void
 init_io_restrict_prog(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u16 port = nvbios_rd16(bios, init->offset + 1);
 	u8 index = nvbios_rd08(bios, init->offset + 3);
 	u8  mask = nvbios_rd08(bios, init->offset + 4);
@@ -654,7 +655,7 @@ init_io_restrict_prog(struct nvbios_init *init)
 static void
 init_repeat(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8 count = nvbios_rd08(bios, init->offset + 1);
 	u16 repeat = init->repeat;
 
@@ -680,7 +681,7 @@ init_repeat(struct nvbios_init *init)
 static void
 init_io_restrict_pll(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u16 port = nvbios_rd16(bios, init->offset + 1);
 	u8 index = nvbios_rd08(bios, init->offset + 3);
 	u8  mask = nvbios_rd08(bios, init->offset + 4);
@@ -736,7 +737,7 @@ init_end_repeat(struct nvbios_init *init)
 static void
 init_copy(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32  reg = nvbios_rd32(bios, init->offset + 1);
 	u8 shift = nvbios_rd08(bios, init->offset + 5);
 	u8 smask = nvbios_rd08(bios, init->offset + 6);
@@ -775,7 +776,7 @@ init_not(struct nvbios_init *init)
 static void
 init_io_flag_condition(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8 cond = nvbios_rd08(bios, init->offset + 1);
 
 	trace("IO_FLAG_CONDITION\t0x%02x\n", cond);
@@ -792,7 +793,7 @@ init_io_flag_condition(struct nvbios_init *init)
 static void
 init_generic_condition(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	struct nvbios_dpout info;
 	u8  cond = nvbios_rd08(bios, init->offset + 1);
 	u8  size = nvbios_rd08(bios, init->offset + 2);
@@ -841,7 +842,7 @@ init_generic_condition(struct nvbios_init *init)
 static void
 init_io_mask_or(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8 index = nvbios_rd08(bios, init->offset + 1);
 	u8    or = init_or(init);
 	u8  data;
@@ -860,7 +861,7 @@ init_io_mask_or(struct nvbios_init *init)
 static void
 init_io_or(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8 index = nvbios_rd08(bios, init->offset + 1);
 	u8    or = init_or(init);
 	u8  data;
@@ -879,7 +880,7 @@ init_io_or(struct nvbios_init *init)
 static void
 init_andn_reg(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32  reg = nvbios_rd32(bios, init->offset + 1);
 	u32 mask = nvbios_rd32(bios, init->offset + 5);
 
@@ -896,7 +897,7 @@ init_andn_reg(struct nvbios_init *init)
 static void
 init_or_reg(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32  reg = nvbios_rd32(bios, init->offset + 1);
 	u32 mask = nvbios_rd32(bios, init->offset + 5);
 
@@ -913,7 +914,7 @@ init_or_reg(struct nvbios_init *init)
 static void
 init_idx_addr_latched(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32 creg = nvbios_rd32(bios, init->offset + 1);
 	u32 dreg = nvbios_rd32(bios, init->offset + 5);
 	u32 mask = nvbios_rd32(bios, init->offset + 9);
@@ -943,7 +944,7 @@ init_idx_addr_latched(struct nvbios_init *init)
 static void
 init_io_restrict_pll2(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u16 port = nvbios_rd16(bios, init->offset + 1);
 	u8 index = nvbios_rd08(bios, init->offset + 3);
 	u8  mask = nvbios_rd08(bios, init->offset + 4);
@@ -978,7 +979,7 @@ init_io_restrict_pll2(struct nvbios_init *init)
 static void
 init_pll2(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32  reg = nvbios_rd32(bios, init->offset + 1);
 	u32 freq = nvbios_rd32(bios, init->offset + 5);
 
@@ -995,7 +996,7 @@ init_pll2(struct nvbios_init *init)
 static void
 init_i2c_byte(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8 index = nvbios_rd08(bios, init->offset + 1);
 	u8  addr = nvbios_rd08(bios, init->offset + 2) >> 1;
 	u8 count = nvbios_rd08(bios, init->offset + 3);
@@ -1026,7 +1027,7 @@ init_i2c_byte(struct nvbios_init *init)
 static void
 init_zm_i2c_byte(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8 index = nvbios_rd08(bios, init->offset + 1);
 	u8  addr = nvbios_rd08(bios, init->offset + 2) >> 1;
 	u8 count = nvbios_rd08(bios, init->offset + 3);
@@ -1052,7 +1053,7 @@ init_zm_i2c_byte(struct nvbios_init *init)
 static void
 init_zm_i2c(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8 index = nvbios_rd08(bios, init->offset + 1);
 	u8  addr = nvbios_rd08(bios, init->offset + 2) >> 1;
 	u8 count = nvbios_rd08(bios, init->offset + 3);
@@ -1086,7 +1087,7 @@ init_zm_i2c(struct nvbios_init *init)
 static void
 init_tmds(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8 tmds = nvbios_rd08(bios, init->offset + 1);
 	u8 addr = nvbios_rd08(bios, init->offset + 2);
 	u8 mask = nvbios_rd08(bios, init->offset + 3);
@@ -1112,7 +1113,7 @@ init_tmds(struct nvbios_init *init)
 static void
 init_zm_tmds_group(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8  tmds = nvbios_rd08(bios, init->offset + 1);
 	u8 count = nvbios_rd08(bios, init->offset + 2);
 	u32  reg = init_tmds_reg(init, tmds);
@@ -1139,7 +1140,7 @@ init_zm_tmds_group(struct nvbios_init *init)
 static void
 init_cr_idx_adr_latch(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8 addr0 = nvbios_rd08(bios, init->offset + 1);
 	u8 addr1 = nvbios_rd08(bios, init->offset + 2);
 	u8  base = nvbios_rd08(bios, init->offset + 3);
@@ -1169,7 +1170,7 @@ init_cr_idx_adr_latch(struct nvbios_init *init)
 static void
 init_cr(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8 addr = nvbios_rd08(bios, init->offset + 1);
 	u8 mask = nvbios_rd08(bios, init->offset + 2);
 	u8 data = nvbios_rd08(bios, init->offset + 3);
@@ -1189,7 +1190,7 @@ init_cr(struct nvbios_init *init)
 static void
 init_zm_cr(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8 addr = nvbios_rd08(bios, init->offset + 1);
 	u8 data = nvbios_rd08(bios, init->offset + 2);
 
@@ -1206,7 +1207,7 @@ init_zm_cr(struct nvbios_init *init)
 static void
 init_zm_cr_group(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8 count = nvbios_rd08(bios, init->offset + 1);
 
 	trace("ZM_CR_GROUP\n");
@@ -1230,7 +1231,7 @@ init_zm_cr_group(struct nvbios_init *init)
 static void
 init_condition_time(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8  cond = nvbios_rd08(bios, init->offset + 1);
 	u8 retry = nvbios_rd08(bios, init->offset + 2);
 	u8  wait = min((u16)retry * 50, 100);
@@ -1257,7 +1258,7 @@ init_condition_time(struct nvbios_init *init)
 static void
 init_ltime(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u16 msec = nvbios_rd16(bios, init->offset + 1);
 
 	trace("LTIME\t0x%04x\n", msec);
@@ -1274,7 +1275,7 @@ init_ltime(struct nvbios_init *init)
 static void
 init_zm_reg_sequence(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32 base = nvbios_rd32(bios, init->offset + 1);
 	u8 count = nvbios_rd08(bios, init->offset + 5);
 
@@ -1299,7 +1300,7 @@ init_zm_reg_sequence(struct nvbios_init *init)
 static void
 init_pll_indirect(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32  reg = nvbios_rd32(bios, init->offset + 1);
 	u16 addr = nvbios_rd16(bios, init->offset + 5);
 	u32 freq = (u32)nvbios_rd16(bios, addr) * 1000;
@@ -1318,7 +1319,7 @@ init_pll_indirect(struct nvbios_init *init)
 static void
 init_zm_reg_indirect(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32  reg = nvbios_rd32(bios, init->offset + 1);
 	u16 addr = nvbios_rd16(bios, init->offset + 5);
 	u32 data = nvbios_rd32(bios, addr);
@@ -1337,7 +1338,7 @@ init_zm_reg_indirect(struct nvbios_init *init)
 static void
 init_sub_direct(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u16 addr = nvbios_rd16(bios, init->offset + 1);
 	u16 save;
 
@@ -1363,7 +1364,7 @@ init_sub_direct(struct nvbios_init *init)
 static void
 init_jump(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u16 offset = nvbios_rd16(bios, init->offset + 1);
 
 	trace("JUMP\t0x%04x\n", offset);
@@ -1381,7 +1382,7 @@ init_jump(struct nvbios_init *init)
 static void
 init_i2c_if(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8 index = nvbios_rd08(bios, init->offset + 1);
 	u8  addr = nvbios_rd08(bios, init->offset + 2);
 	u8   reg = nvbios_rd08(bios, init->offset + 3);
@@ -1408,7 +1409,7 @@ init_i2c_if(struct nvbios_init *init)
 static void
 init_copy_nv_reg(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32  sreg = nvbios_rd32(bios, init->offset + 1);
 	u8  shift = nvbios_rd08(bios, init->offset + 5);
 	u32 smask = nvbios_rd32(bios, init->offset + 6);
@@ -1434,7 +1435,7 @@ init_copy_nv_reg(struct nvbios_init *init)
 static void
 init_zm_index_io(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u16 port = nvbios_rd16(bios, init->offset + 1);
 	u8 index = nvbios_rd08(bios, init->offset + 3);
 	u8  data = nvbios_rd08(bios, init->offset + 4);
@@ -1452,7 +1453,7 @@ init_zm_index_io(struct nvbios_init *init)
 static void
 init_compute_mem(struct nvbios_init *init)
 {
-	struct nvkm_devinit *devinit = init->bios->subdev.device->devinit;
+	struct nvkm_devinit *devinit = init->subdev->device->devinit;
 
 	trace("COMPUTE_MEM\n");
 	init->offset += 1;
@@ -1470,7 +1471,7 @@ init_compute_mem(struct nvbios_init *init)
 static void
 init_reset(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32   reg = nvbios_rd32(bios, init->offset + 1);
 	u32 data1 = nvbios_rd32(bios, init->offset + 5);
 	u32 data2 = nvbios_rd32(bios, init->offset + 9);
@@ -1497,7 +1498,7 @@ init_reset(struct nvbios_init *init)
 static u16
 init_configure_mem_clk(struct nvbios_init *init)
 {
-	u16 mdata = bmp_mem_init_table(init->bios);
+	u16 mdata = bmp_mem_init_table(init->subdev->device->bios);
 	if (mdata)
 		mdata += (init_rdvgai(init, 0x03d4, 0x3c) >> 4) * 66;
 	return mdata;
@@ -1506,7 +1507,7 @@ init_configure_mem_clk(struct nvbios_init *init)
 static void
 init_configure_mem(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u16 mdata, sdata;
 	u32 addr, data;
 
@@ -1556,7 +1557,7 @@ init_configure_mem(struct nvbios_init *init)
 static void
 init_configure_clk(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u16 mdata, clock;
 
 	trace("CONFIGURE_CLK\n");
@@ -1590,7 +1591,7 @@ init_configure_clk(struct nvbios_init *init)
 static void
 init_configure_preinit(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32 strap;
 
 	trace("CONFIGURE_PREINIT\n");
@@ -1616,7 +1617,7 @@ init_configure_preinit(struct nvbios_init *init)
 static void
 init_io(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u16 port = nvbios_rd16(bios, init->offset + 1);
 	u8  mask = nvbios_rd16(bios, init->offset + 3);
 	u8  data = nvbios_rd16(bios, init->offset + 4);
@@ -1656,7 +1657,7 @@ init_io(struct nvbios_init *init)
 static void
 init_sub(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8 index = nvbios_rd08(bios, init->offset + 1);
 	u16 addr, save;
 
@@ -1683,7 +1684,7 @@ init_sub(struct nvbios_init *init)
 static void
 init_ram_condition(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8  mask = nvbios_rd08(bios, init->offset + 1);
 	u8 value = nvbios_rd08(bios, init->offset + 2);
 
@@ -1702,7 +1703,7 @@ init_ram_condition(struct nvbios_init *init)
 static void
 init_nv_reg(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32  reg = nvbios_rd32(bios, init->offset + 1);
 	u32 mask = nvbios_rd32(bios, init->offset + 5);
 	u32 data = nvbios_rd32(bios, init->offset + 9);
@@ -1720,7 +1721,7 @@ init_nv_reg(struct nvbios_init *init)
 static void
 init_macro(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8  macro = nvbios_rd08(bios, init->offset + 1);
 	u16 table;
 
@@ -1756,7 +1757,7 @@ init_resume(struct nvbios_init *init)
 static void
 init_strap_condition(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32 mask = nvbios_rd32(bios, init->offset + 1);
 	u32 value = nvbios_rd32(bios, init->offset + 5);
 
@@ -1774,7 +1775,7 @@ init_strap_condition(struct nvbios_init *init)
 static void
 init_time(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u16 usec = nvbios_rd16(bios, init->offset + 1);
 
 	trace("TIME\t0x%04x\n", usec);
@@ -1795,7 +1796,7 @@ init_time(struct nvbios_init *init)
 static void
 init_condition(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8 cond = nvbios_rd08(bios, init->offset + 1);
 
 	trace("CONDITION\t0x%02x\n", cond);
@@ -1812,7 +1813,7 @@ init_condition(struct nvbios_init *init)
 static void
 init_io_condition(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8 cond = nvbios_rd08(bios, init->offset + 1);
 
 	trace("IO_CONDITION\t0x%02x\n", cond);
@@ -1829,7 +1830,7 @@ init_io_condition(struct nvbios_init *init)
 static void
 init_zm_reg16(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32 addr = nvbios_rd32(bios, init->offset + 1);
 	u16 data = nvbios_rd16(bios, init->offset + 5);
 
@@ -1846,7 +1847,7 @@ init_zm_reg16(struct nvbios_init *init)
 static void
 init_index_io(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u16 port = nvbios_rd16(bios, init->offset + 1);
 	u8 index = nvbios_rd16(bios, init->offset + 3);
 	u8  mask = nvbios_rd08(bios, init->offset + 4);
@@ -1868,7 +1869,7 @@ init_index_io(struct nvbios_init *init)
 static void
 init_pll(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32  reg = nvbios_rd32(bios, init->offset + 1);
 	u32 freq = nvbios_rd16(bios, init->offset + 5) * 10;
 
@@ -1885,7 +1886,7 @@ init_pll(struct nvbios_init *init)
 static void
 init_zm_reg(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32 addr = nvbios_rd32(bios, init->offset + 1);
 	u32 data = nvbios_rd32(bios, init->offset + 5);
 
@@ -1905,7 +1906,7 @@ init_zm_reg(struct nvbios_init *init)
 static void
 init_ram_restrict_pll(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8  type = nvbios_rd08(bios, init->offset + 1);
 	u8 count = init_ram_restrict_group_count(init);
 	u8 strap = init_ram_restrict(init);
@@ -1935,7 +1936,7 @@ init_ram_restrict_pll(struct nvbios_init *init)
 static void
 init_gpio(struct nvbios_init *init)
 {
-	struct nvkm_gpio *gpio = init->bios->subdev.device->gpio;
+	struct nvkm_gpio *gpio = init->subdev->device->gpio;
 
 	trace("GPIO\n");
 	init->offset += 1;
@@ -1951,7 +1952,7 @@ init_gpio(struct nvbios_init *init)
 static void
 init_ram_restrict_zm_reg_group(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32 addr = nvbios_rd32(bios, init->offset + 1);
 	u8  incr = nvbios_rd08(bios, init->offset + 5);
 	u8   num = nvbios_rd08(bios, init->offset + 6);
@@ -1989,7 +1990,7 @@ init_ram_restrict_zm_reg_group(struct nvbios_init *init)
 static void
 init_copy_zm_reg(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32 sreg = nvbios_rd32(bios, init->offset + 1);
 	u32 dreg = nvbios_rd32(bios, init->offset + 5);
 
@@ -2006,7 +2007,7 @@ init_copy_zm_reg(struct nvbios_init *init)
 static void
 init_zm_reg_group(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32 addr = nvbios_rd32(bios, init->offset + 1);
 	u8 count = nvbios_rd08(bios, init->offset + 5);
 
@@ -2028,7 +2029,7 @@ init_zm_reg_group(struct nvbios_init *init)
 static void
 init_xlat(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32 saddr = nvbios_rd32(bios, init->offset + 1);
 	u8 sshift = nvbios_rd08(bios, init->offset + 5);
 	u8  smask = nvbios_rd08(bios, init->offset + 6);
@@ -2056,7 +2057,7 @@ init_xlat(struct nvbios_init *init)
 static void
 init_zm_mask_add(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32 addr = nvbios_rd32(bios, init->offset + 1);
 	u32 mask = nvbios_rd32(bios, init->offset + 5);
 	u32  add = nvbios_rd32(bios, init->offset + 9);
@@ -2077,7 +2078,7 @@ init_zm_mask_add(struct nvbios_init *init)
 static void
 init_auxch(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32 addr = nvbios_rd32(bios, init->offset + 1);
 	u8 count = nvbios_rd08(bios, init->offset + 5);
 
@@ -2101,7 +2102,7 @@ init_auxch(struct nvbios_init *init)
 static void
 init_zm_auxch(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u32 addr = nvbios_rd32(bios, init->offset + 1);
 	u8 count = nvbios_rd08(bios, init->offset + 5);
 
@@ -2123,7 +2124,7 @@ init_zm_auxch(struct nvbios_init *init)
 static void
 init_i2c_long_if(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	u8 index = nvbios_rd08(bios, init->offset + 1);
 	u8  addr = nvbios_rd08(bios, init->offset + 2) >> 1;
 	u8 reglo = nvbios_rd08(bios, init->offset + 3);
@@ -2162,7 +2163,7 @@ init_i2c_long_if(struct nvbios_init *init)
 static void
 init_gpio_ne(struct nvbios_init *init)
 {
-	struct nvkm_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	struct nvkm_gpio *gpio = bios->subdev.device->gpio;
 	struct dcb_gpio_func func;
 	u8 count = nvbios_rd08(bios, init->offset + 1);
@@ -2275,9 +2276,10 @@ static struct nvbios_init_opcode {
 int
 nvbios_exec(struct nvbios_init *init)
 {
+	struct nvkm_bios *bios = init->subdev->device->bios;
 	init->nested++;
 	while (init->offset) {
-		u8 opcode = nvbios_rd08(init->bios, init->offset);
+		u8 opcode = nvbios_rd08(bios, init->offset);
 		if (opcode >= init_opcode_nr || !init_opcode[opcode].exec) {
 			error("unknown opcode 0x%02x\n", opcode);
 			return -EINVAL;

commit 4bb4a7466af6d96d4fc8471336eb738d13c2471c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 19 23:59:34 2017 +1000

    drm/nouveau/bios/init: rename nvbios_init() to nvbios_devinit()
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index 38ed09fd3d2f..1d5f29a5c07c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -2290,7 +2290,7 @@ nvbios_exec(struct nvbios_init *init)
 }
 
 int
-nvbios_init(struct nvkm_subdev *subdev, bool execute)
+nvbios_post(struct nvkm_subdev *subdev, bool execute)
 {
 	struct nvkm_bios *bios = subdev->device->bios;
 	int ret = 0;

commit e24c9c44d7a3b4a57661100efc11b340ecdc873c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Feb 18 04:10:04 2016 +1000

    drm/nouveau/bios/devinit: properly handle unknown generic conditions
    
    Upon encountering an unknown condition code, the script interpreter
    is supposed to skip 'size' bytes and continue at the next devinit
    token.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index c99b6676171b..38ed09fd3d2f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -795,11 +795,11 @@ init_generic_condition(struct nvbios_init *init)
 	struct nvkm_bios *bios = init->bios;
 	struct nvbios_dpout info;
 	u8  cond = nvbios_rd08(bios, init->offset + 1);
-	u8  unkn = nvbios_rd08(bios, init->offset + 2);
+	u8  size = nvbios_rd08(bios, init->offset + 2);
 	u8  ver, hdr, cnt, len;
 	u16 data;
 
-	trace("GENERIC_CONDITION\t0x%02x 0x%02x\n", cond, unkn);
+	trace("GENERIC_CONDITION\t0x%02x 0x%02x\n", cond, size);
 	init->offset += 3;
 
 	switch (cond) {
@@ -829,6 +829,7 @@ init_generic_condition(struct nvbios_init *init)
 		break;
 	default:
 		warn("INIT_GENERIC_CONDITON: unknown 0x%02x\n", cond);
+		init->offset += size;
 		break;
 	}
 }

commit 989f57847396d1d042204747985d6aacf5399c8a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Feb 18 04:03:39 2016 +1000

    drm/nouveau/bios/devinit: rename INIT_DP_CONDITION to INIT_GENERIC_CONDITION
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index a7d69ce7abc1..c99b6676171b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -786,11 +786,11 @@ init_io_flag_condition(struct nvbios_init *init)
 }
 
 /**
- * INIT_DP_CONDITION - opcode 0x3a
+ * INIT_GENERIC_CONDITION - opcode 0x3a
  *
  */
 static void
-init_dp_condition(struct nvbios_init *init)
+init_generic_condition(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
 	struct nvbios_dpout info;
@@ -799,7 +799,7 @@ init_dp_condition(struct nvbios_init *init)
 	u8  ver, hdr, cnt, len;
 	u16 data;
 
-	trace("DP_CONDITION\t0x%02x 0x%02x\n", cond, unkn);
+	trace("GENERIC_CONDITION\t0x%02x 0x%02x\n", cond, unkn);
 	init->offset += 3;
 
 	switch (cond) {
@@ -828,7 +828,7 @@ init_dp_condition(struct nvbios_init *init)
 			init_exec_set(init, false);
 		break;
 	default:
-		warn("unknown dp condition 0x%02x\n", cond);
+		warn("INIT_GENERIC_CONDITON: unknown 0x%02x\n", cond);
 		break;
 	}
 }
@@ -2205,7 +2205,7 @@ static struct nvbios_init_opcode {
 	[0x37] = { init_copy },
 	[0x38] = { init_not },
 	[0x39] = { init_io_flag_condition },
-	[0x3a] = { init_dp_condition },
+	[0x3a] = { init_generic_condition },
 	[0x3b] = { init_io_mask_or },
 	[0x3c] = { init_io_or },
 	[0x47] = { init_andn_reg },

commit 2239b76b0b1782160d5ca91ea1653dd67aa37e8a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Sep 29 12:08:35 2015 +1000

    drm/nouveau/bios: translate devinit pri/sec i2c bus to internal identifiers
    
    fdo#92013.
    
    Regression from "i2c: transition pad/ports away from being based on nvkm_object"
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index 65af31441e9c..a7d69ce7abc1 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -267,6 +267,12 @@ init_i2c(struct nvbios_init *init, int index)
 		index = NVKM_I2C_BUS_PRI;
 		if (init->outp && init->outp->i2c_upper_default)
 			index = NVKM_I2C_BUS_SEC;
+	} else
+	if (index == 0x80) {
+		index = NVKM_I2C_BUS_PRI;
+	} else
+	if (index == 0x81) {
+		index = NVKM_I2C_BUS_SEC;
 	}
 
 	bus = nvkm_i2c_bus_find(i2c, index);

commit 2ea7249fe2d4815fc6d0b50021bcbd8bb72b8437
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/gpio: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index a50b027cf703..65af31441e9c 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -1933,8 +1933,8 @@ init_gpio(struct nvbios_init *init)
 	trace("GPIO\n");
 	init->offset += 1;
 
-	if (init_exec(init) && gpio && gpio->reset)
-		gpio->reset(gpio, DCB_GPIO_UNUSED);
+	if (init_exec(init))
+		nvkm_gpio_reset(gpio, DCB_GPIO_UNUSED);
 }
 
 /**
@@ -2179,8 +2179,8 @@ init_gpio_ne(struct nvbios_init *init)
 			trace("\tFUNC[0x%02x]", func.func);
 			if (i == (init->offset + count)) {
 				cont(" *");
-				if (init_exec(init) && gpio && gpio->reset)
-					gpio->reset(gpio, func.func);
+				if (init_exec(init))
+					nvkm_gpio_reset(gpio, func.func);
 			}
 			cont("\n");
 		}

commit 151abd44c27c1562f348a99c176b078a876ebe93
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/devinit: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index f119bc81d39e..a50b027cf703 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -173,9 +173,7 @@ init_nvreg(struct nvbios_init *init, u32 reg)
 	if (reg & ~0x00fffffc)
 		warn("unknown bits in register 0x%08x\n", reg);
 
-	if (devinit->mmio)
-		reg = devinit->mmio(devinit, reg);
-	return reg;
+	return nvkm_devinit_mmio(devinit, reg);
 }
 
 static u32
@@ -338,8 +336,8 @@ static void
 init_prog_pll(struct nvbios_init *init, u32 id, u32 freq)
 {
 	struct nvkm_devinit *devinit = init->bios->subdev.device->devinit;
-	if (devinit->pll_set && init_exec(init)) {
-		int ret = devinit->pll_set(devinit, id, freq);
+	if (init_exec(init)) {
+		int ret = nvkm_devinit_pll_set(devinit, id, freq);
 		if (ret)
 			warn("failed to prog pll 0x%08x to %dkHz\n", id, freq);
 	}
@@ -1453,8 +1451,8 @@ init_compute_mem(struct nvbios_init *init)
 	init->offset += 1;
 
 	init_exec_force(init, true);
-	if (init_exec(init) && devinit->meminit)
-		devinit->meminit(devinit);
+	if (init_exec(init))
+		nvkm_devinit_meminit(devinit);
 	init_exec_force(init, false);
 }
 

commit 46484438ab7dbab6ed29cf647d029e0b1ef3d9d8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/bios: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index c2c2d90e04f5..f119bc81d39e 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -141,7 +141,7 @@ init_conn(struct nvbios_init *init)
 static inline u32
 init_nvreg(struct nvbios_init *init, u32 reg)
 {
-	struct nvkm_devinit *devinit = nvkm_devinit(init->bios);
+	struct nvkm_devinit *devinit = init->bios->subdev.device->devinit;
 
 	/* C51 (at least) sometimes has the lower bits set which the VBIOS
 	 * interprets to mean that access needs to go through certain IO
@@ -154,7 +154,7 @@ init_nvreg(struct nvbios_init *init, u32 reg)
 	/* GF8+ display scripts need register addresses mangled a bit to
 	 * select a specific CRTC/OR
 	 */
-	if (nv_device(init->bios)->card_type >= NV_50) {
+	if (init->bios->subdev.device->card_type >= NV_50) {
 		if (reg & 0x80000000) {
 			reg += init_crtc(init) * 0x800;
 			reg &= ~0x80000000;
@@ -337,7 +337,7 @@ init_wrauxr(struct nvbios_init *init, u32 addr, u8 data)
 static void
 init_prog_pll(struct nvbios_init *init, u32 id, u32 freq)
 {
-	struct nvkm_devinit *devinit = nvkm_devinit(init->bios);
+	struct nvkm_devinit *devinit = init->bios->subdev.device->devinit;
 	if (devinit->pll_set && init_exec(init)) {
 		int ret = devinit->pll_set(devinit, id, freq);
 		if (ret)
@@ -1447,7 +1447,7 @@ init_zm_index_io(struct nvbios_init *init)
 static void
 init_compute_mem(struct nvbios_init *init)
 {
-	struct nvkm_devinit *devinit = nvkm_devinit(init->bios);
+	struct nvkm_devinit *devinit = init->bios->subdev.device->devinit;
 
 	trace("COMPUTE_MEM\n");
 	init->offset += 1;
@@ -1624,7 +1624,7 @@ init_io(struct nvbios_init *init)
 	 * needed some day..  it's almost certainly wrong, but, it also
 	 * somehow makes things work...
 	 */
-	if (nv_device(init->bios)->card_type >= NV_50 &&
+	if (bios->subdev.device->card_type >= NV_50 &&
 	    port == 0x03c3 && data == 0x01) {
 		init_mask(init, 0x614100, 0xf0800000, 0x00800000);
 		init_mask(init, 0x00e18c, 0x00020000, 0x00020000);
@@ -1930,7 +1930,7 @@ init_ram_restrict_pll(struct nvbios_init *init)
 static void
 init_gpio(struct nvbios_init *init)
 {
-	struct nvkm_gpio *gpio = nvkm_gpio(init->bios);
+	struct nvkm_gpio *gpio = init->bios->subdev.device->gpio;
 
 	trace("GPIO\n");
 	init->offset += 1;
@@ -2158,7 +2158,7 @@ static void
 init_gpio_ne(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	struct nvkm_gpio *gpio = nvkm_gpio(bios);
+	struct nvkm_gpio *gpio = bios->subdev.device->gpio;
 	struct dcb_gpio_func func;
 	u8 count = nvbios_rd08(bios, init->offset + 1);
 	u8 idx = 0, ver, len;
@@ -2287,7 +2287,7 @@ nvbios_exec(struct nvbios_init *init)
 int
 nvbios_init(struct nvkm_subdev *subdev, bool execute)
 {
-	struct nvkm_bios *bios = nvkm_bios(subdev);
+	struct nvkm_bios *bios = subdev->device->bios;
 	int ret = 0;
 	int i = -1;
 	u16 data;

commit 2aa5eac5163fedf09f2d61992cb5ea4d75bec9db
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:15 2015 +1000

    drm/nouveau/i2c: transition pad/ports away from being based on nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index 8b175d8cec66..c2c2d90e04f5 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -259,62 +259,60 @@ init_wrvgai(struct nvbios_init *init, u16 port, u8 index, u8 value)
 	}
 }
 
-static struct nvkm_i2c_port *
+static struct i2c_adapter *
 init_i2c(struct nvbios_init *init, int index)
 {
-	struct nvkm_i2c *i2c = nvkm_i2c(init->bios);
+	struct nvkm_i2c *i2c = init->bios->subdev.device->i2c;
+	struct nvkm_i2c_bus *bus;
 
 	if (index == 0xff) {
-		index = NV_I2C_DEFAULT(0);
+		index = NVKM_I2C_BUS_PRI;
 		if (init->outp && init->outp->i2c_upper_default)
-			index = NV_I2C_DEFAULT(1);
-	} else
-	if (index < 0) {
-		if (!init->outp) {
-			if (init_exec(init))
-				error("script needs output for i2c\n");
-			return NULL;
-		}
-
-		if (index == -2 && init->outp->location) {
-			index = NV_I2C_TYPE_EXTAUX(init->outp->extdev);
-			return i2c->find_type(i2c, index);
-		}
-
-		index = init->outp->i2c_index;
-		if (init->outp->type == DCB_OUTPUT_DP)
-			index += NV_I2C_AUX(0);
+			index = NVKM_I2C_BUS_SEC;
 	}
 
-	return i2c->find(i2c, index);
+	bus = nvkm_i2c_bus_find(i2c, index);
+	return bus ? &bus->i2c : NULL;
 }
 
 static int
 init_rdi2cr(struct nvbios_init *init, u8 index, u8 addr, u8 reg)
 {
-	struct nvkm_i2c_port *port = init_i2c(init, index);
-	if (port && init_exec(init))
-		return nv_rdi2cr(port, addr, reg);
+	struct i2c_adapter *adap = init_i2c(init, index);
+	if (adap && init_exec(init))
+		return nvkm_rdi2cr(adap, addr, reg);
 	return -ENODEV;
 }
 
 static int
 init_wri2cr(struct nvbios_init *init, u8 index, u8 addr, u8 reg, u8 val)
 {
-	struct nvkm_i2c_port *port = init_i2c(init, index);
-	if (port && init_exec(init))
-		return nv_wri2cr(port, addr, reg, val);
+	struct i2c_adapter *adap = init_i2c(init, index);
+	if (adap && init_exec(init))
+		return nvkm_wri2cr(adap, addr, reg, val);
 	return -ENODEV;
 }
 
+static struct nvkm_i2c_aux *
+init_aux(struct nvbios_init *init)
+{
+	struct nvkm_i2c *i2c = init->bios->subdev.device->i2c;
+	if (!init->outp) {
+		if (init_exec(init))
+			error("script needs output for aux\n");
+		return NULL;
+	}
+	return nvkm_i2c_aux_find(i2c, init->outp->i2c_index);
+}
+
 static u8
 init_rdauxr(struct nvbios_init *init, u32 addr)
 {
-	struct nvkm_i2c_port *port = init_i2c(init, -2);
+	struct nvkm_i2c_aux *aux = init_aux(init);
 	u8 data;
 
-	if (port && init_exec(init)) {
-		int ret = nv_rdaux(port, addr, &data, 1);
+	if (aux && init_exec(init)) {
+		int ret = nvkm_rdaux(aux, addr, &data, 1);
 		if (ret == 0)
 			return data;
 		trace("auxch read failed with %d\n", ret);
@@ -326,9 +324,9 @@ init_rdauxr(struct nvbios_init *init, u32 addr)
 static int
 init_wrauxr(struct nvbios_init *init, u32 addr, u8 data)
 {
-	struct nvkm_i2c_port *port = init_i2c(init, -2);
-	if (port && init_exec(init)) {
-		int ret = nv_wraux(port, addr, &data, 1);
+	struct nvkm_i2c_aux *aux = init_aux(init);
+	if (aux && init_exec(init)) {
+		int ret = nvkm_wraux(aux, addr, &data, 1);
 		if (ret)
 			trace("auxch write failed with %d\n", ret);
 		return ret;
@@ -1065,13 +1063,13 @@ init_zm_i2c(struct nvbios_init *init)
 	}
 
 	if (init_exec(init)) {
-		struct nvkm_i2c_port *port = init_i2c(init, index);
+		struct i2c_adapter *adap = init_i2c(init, index);
 		struct i2c_msg msg = {
 			.addr = addr, .flags = 0, .len = count, .buf = data,
 		};
 		int ret;
 
-		if (port && (ret = i2c_transfer(&port->adapter, &msg, 1)) != 1)
+		if (adap && (ret = i2c_transfer(adap, &msg, 1)) != 1)
 			warn("i2c wr failed, %d\n", ret);
 	}
 }
@@ -2127,15 +2125,15 @@ init_i2c_long_if(struct nvbios_init *init)
 	u8 reghi = nvbios_rd08(bios, init->offset + 4);
 	u8  mask = nvbios_rd08(bios, init->offset + 5);
 	u8  data = nvbios_rd08(bios, init->offset + 6);
-	struct nvkm_i2c_port *port;
+	struct i2c_adapter *adap;
 
 	trace("I2C_LONG_IF\t"
 	      "I2C[0x%02x][0x%02x][0x%02x%02x] & 0x%02x == 0x%02x\n",
 	      index, addr, reglo, reghi, mask, data);
 	init->offset += 7;
 
-	port = init_i2c(init, index);
-	if (port) {
+	adap = init_i2c(init, index);
+	if (adap) {
 		u8 i[2] = { reghi, reglo };
 		u8 o[1] = {};
 		struct i2c_msg msg[] = {
@@ -2144,7 +2142,7 @@ init_i2c_long_if(struct nvbios_init *init)
 		};
 		int ret;
 
-		ret = i2c_transfer(&port->adapter, msg, 2);
+		ret = i2c_transfer(adap, msg, 2);
 		if (ret == 2 && ((o[0] & mask) == data))
 			return;
 	}

commit a8dae9fe0e8ad94de1bb2bfda90d288c1b9eb6e6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:14 2015 +1000

    drm/nouveau/vga: require nvkm_device pointer in accessor functions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index 95b6468d5f27..8b175d8cec66 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -214,7 +214,7 @@ static u8
 init_rdport(struct nvbios_init *init, u16 port)
 {
 	if (init_exec(init))
-		return nv_rdport(init->subdev, init->crtc, port);
+		return nvkm_rdport(init->subdev->device, init->crtc, port);
 	return 0x00;
 }
 
@@ -222,7 +222,7 @@ static void
 init_wrport(struct nvbios_init *init, u16 port, u8 value)
 {
 	if (init_exec(init))
-		nv_wrport(init->subdev, init->crtc, port, value);
+		nvkm_wrport(init->subdev->device, init->crtc, port, value);
 }
 
 static u8
@@ -231,7 +231,7 @@ init_rdvgai(struct nvbios_init *init, u16 port, u8 index)
 	struct nvkm_subdev *subdev = init->subdev;
 	if (init_exec(init)) {
 		int head = init->crtc < 0 ? 0 : init->crtc;
-		return nv_rdvgai(subdev, head, port, index);
+		return nvkm_rdvgai(subdev->device, head, port, index);
 	}
 	return 0x00;
 }
@@ -239,19 +239,21 @@ init_rdvgai(struct nvbios_init *init, u16 port, u8 index)
 static void
 init_wrvgai(struct nvbios_init *init, u16 port, u8 index, u8 value)
 {
+	struct nvkm_device *device = init->subdev->device;
+
 	/* force head 0 for updates to cr44, it only exists on first head */
-	if (nv_device(init->subdev)->card_type < NV_50) {
+	if (device->card_type < NV_50) {
 		if (port == 0x03d4 && index == 0x44)
 			init->crtc = 0;
 	}
 
 	if (init_exec(init)) {
 		int head = init->crtc < 0 ? 0 : init->crtc;
-		nv_wrvgai(init->subdev, head, port, index, value);
+		nvkm_wrvgai(device, head, port, index, value);
 	}
 
 	/* select head 1 if cr44 write selected it */
-	if (nv_device(init->subdev)->card_type < NV_50) {
+	if (device->card_type < NV_50) {
 		if (port == 0x03d4 && index == 0x44 && value == 3)
 			init->crtc = 1;
 	}

commit 7f5f518fd70b1b72ca4cf8249ca3306846383ed4
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:13 2015 +1000

    drm/nouveau/bios: remove object accessor functions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index b03076e9a0ef..95b6468d5f27 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -374,7 +374,7 @@ init_table_(struct nvbios_init *init, u16 offset, const char *name)
 	u16 len, data = init_table(bios, &len);
 	if (data) {
 		if (len >= offset + 2) {
-			data = nv_ro16(bios, data + offset);
+			data = nvbios_rd16(bios, data + offset);
 			if (data)
 				return data;
 
@@ -410,12 +410,12 @@ init_script(struct nvkm_bios *bios, int index)
 			return 0x0000;
 
 		data = bios->bmp_offset + (bmp_ver < 0x0200 ? 14 : 18);
-		return nv_ro16(bios, data + (index * 2));
+		return nvbios_rd16(bios, data + (index * 2));
 	}
 
 	data = init_script_table(&init);
 	if (data)
-		return nv_ro16(bios, data + (index * 2));
+		return nvbios_rd16(bios, data + (index * 2));
 
 	return 0x0000;
 }
@@ -425,7 +425,7 @@ init_unknown_script(struct nvkm_bios *bios)
 {
 	u16 len, data = init_table(bios, &len);
 	if (data && len >= 16)
-		return nv_ro16(bios, data + 14);
+		return nvbios_rd16(bios, data + 14);
 	return 0x0000;
 }
 
@@ -457,9 +457,9 @@ init_xlat_(struct nvbios_init *init, u8 index, u8 offset)
 	struct nvkm_bios *bios = init->bios;
 	u16 table = init_xlat_table(init);
 	if (table) {
-		u16 data = nv_ro16(bios, table + (index * 2));
+		u16 data = nvbios_rd16(bios, table + (index * 2));
 		if (data)
-			return nv_ro08(bios, data + offset);
+			return nvbios_rd08(bios, data + offset);
 		warn("xlat table pointer %d invalid\n", index);
 	}
 	return 0x00;
@@ -475,9 +475,9 @@ init_condition_met(struct nvbios_init *init, u8 cond)
 	struct nvkm_bios *bios = init->bios;
 	u16 table = init_condition_table(init);
 	if (table) {
-		u32 reg = nv_ro32(bios, table + (cond * 12) + 0);
-		u32 msk = nv_ro32(bios, table + (cond * 12) + 4);
-		u32 val = nv_ro32(bios, table + (cond * 12) + 8);
+		u32 reg = nvbios_rd32(bios, table + (cond * 12) + 0);
+		u32 msk = nvbios_rd32(bios, table + (cond * 12) + 4);
+		u32 val = nvbios_rd32(bios, table + (cond * 12) + 8);
 		trace("\t[0x%02x] (R[0x%06x] & 0x%08x) == 0x%08x\n",
 		      cond, reg, msk, val);
 		return (init_rd32(init, reg) & msk) == val;
@@ -491,10 +491,10 @@ init_io_condition_met(struct nvbios_init *init, u8 cond)
 	struct nvkm_bios *bios = init->bios;
 	u16 table = init_io_condition_table(init);
 	if (table) {
-		u16 port = nv_ro16(bios, table + (cond * 5) + 0);
-		u8 index = nv_ro08(bios, table + (cond * 5) + 2);
-		u8  mask = nv_ro08(bios, table + (cond * 5) + 3);
-		u8 value = nv_ro08(bios, table + (cond * 5) + 4);
+		u16 port = nvbios_rd16(bios, table + (cond * 5) + 0);
+		u8 index = nvbios_rd08(bios, table + (cond * 5) + 2);
+		u8  mask = nvbios_rd08(bios, table + (cond * 5) + 3);
+		u8 value = nvbios_rd08(bios, table + (cond * 5) + 4);
 		trace("\t[0x%02x] (0x%04x[0x%02x] & 0x%02x) == 0x%02x\n",
 		      cond, port, index, mask, value);
 		return (init_rdvgai(init, port, index) & mask) == value;
@@ -508,15 +508,15 @@ init_io_flag_condition_met(struct nvbios_init *init, u8 cond)
 	struct nvkm_bios *bios = init->bios;
 	u16 table = init_io_flag_condition_table(init);
 	if (table) {
-		u16 port = nv_ro16(bios, table + (cond * 9) + 0);
-		u8 index = nv_ro08(bios, table + (cond * 9) + 2);
-		u8  mask = nv_ro08(bios, table + (cond * 9) + 3);
-		u8 shift = nv_ro08(bios, table + (cond * 9) + 4);
-		u16 data = nv_ro16(bios, table + (cond * 9) + 5);
-		u8 dmask = nv_ro08(bios, table + (cond * 9) + 7);
-		u8 value = nv_ro08(bios, table + (cond * 9) + 8);
+		u16 port = nvbios_rd16(bios, table + (cond * 9) + 0);
+		u8 index = nvbios_rd08(bios, table + (cond * 9) + 2);
+		u8  mask = nvbios_rd08(bios, table + (cond * 9) + 3);
+		u8 shift = nvbios_rd08(bios, table + (cond * 9) + 4);
+		u16 data = nvbios_rd16(bios, table + (cond * 9) + 5);
+		u8 dmask = nvbios_rd08(bios, table + (cond * 9) + 7);
+		u8 value = nvbios_rd08(bios, table + (cond * 9) + 8);
 		u8 ioval = (init_rdvgai(init, port, index) & mask) >> shift;
-		return (nv_ro08(bios, data + ioval) & dmask) == value;
+		return (nvbios_rd08(bios, data + ioval) & dmask) == value;
 	}
 	return false;
 }
@@ -576,7 +576,7 @@ init_tmds_reg(struct nvbios_init *init, u8 tmds)
 static void
 init_reserved(struct nvbios_init *init)
 {
-	u8 opcode = nv_ro08(init->bios, init->offset);
+	u8 opcode = nvbios_rd08(init->bios, init->offset);
 	u8 length, i;
 
 	switch (opcode) {
@@ -590,7 +590,7 @@ init_reserved(struct nvbios_init *init)
 
 	trace("RESERVED 0x%02x\t", opcode);
 	for (i = 1; i < length; i++)
-		cont(" 0x%02x", nv_ro08(init->bios, init->offset + i));
+		cont(" 0x%02x", nvbios_rd08(init->bios, init->offset + i));
 	cont("\n");
 	init->offset += length;
 }
@@ -614,12 +614,12 @@ static void
 init_io_restrict_prog(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u16 port = nv_ro16(bios, init->offset + 1);
-	u8 index = nv_ro08(bios, init->offset + 3);
-	u8  mask = nv_ro08(bios, init->offset + 4);
-	u8 shift = nv_ro08(bios, init->offset + 5);
-	u8 count = nv_ro08(bios, init->offset + 6);
-	u32  reg = nv_ro32(bios, init->offset + 7);
+	u16 port = nvbios_rd16(bios, init->offset + 1);
+	u8 index = nvbios_rd08(bios, init->offset + 3);
+	u8  mask = nvbios_rd08(bios, init->offset + 4);
+	u8 shift = nvbios_rd08(bios, init->offset + 5);
+	u8 count = nvbios_rd08(bios, init->offset + 6);
+	u32  reg = nvbios_rd32(bios, init->offset + 7);
 	u8 conf, i;
 
 	trace("IO_RESTRICT_PROG\tR[0x%06x] = "
@@ -629,7 +629,7 @@ init_io_restrict_prog(struct nvbios_init *init)
 
 	conf = (init_rdvgai(init, port, index) & mask) >> shift;
 	for (i = 0; i < count; i++) {
-		u32 data = nv_ro32(bios, init->offset);
+		u32 data = nvbios_rd32(bios, init->offset);
 
 		if (i == conf) {
 			trace("\t0x%08x *\n", data);
@@ -651,7 +651,7 @@ static void
 init_repeat(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8 count = nv_ro08(bios, init->offset + 1);
+	u8 count = nvbios_rd08(bios, init->offset + 1);
 	u16 repeat = init->repeat;
 
 	trace("REPEAT\t0x%02x\n", count);
@@ -677,13 +677,13 @@ static void
 init_io_restrict_pll(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u16 port = nv_ro16(bios, init->offset + 1);
-	u8 index = nv_ro08(bios, init->offset + 3);
-	u8  mask = nv_ro08(bios, init->offset + 4);
-	u8 shift = nv_ro08(bios, init->offset + 5);
-	s8  iofc = nv_ro08(bios, init->offset + 6);
-	u8 count = nv_ro08(bios, init->offset + 7);
-	u32  reg = nv_ro32(bios, init->offset + 8);
+	u16 port = nvbios_rd16(bios, init->offset + 1);
+	u8 index = nvbios_rd08(bios, init->offset + 3);
+	u8  mask = nvbios_rd08(bios, init->offset + 4);
+	u8 shift = nvbios_rd08(bios, init->offset + 5);
+	s8  iofc = nvbios_rd08(bios, init->offset + 6);
+	u8 count = nvbios_rd08(bios, init->offset + 7);
+	u32  reg = nvbios_rd32(bios, init->offset + 8);
 	u8 conf, i;
 
 	trace("IO_RESTRICT_PLL\tR[0x%06x] =PLL= "
@@ -693,7 +693,7 @@ init_io_restrict_pll(struct nvbios_init *init)
 
 	conf = (init_rdvgai(init, port, index) & mask) >> shift;
 	for (i = 0; i < count; i++) {
-		u32 freq = nv_ro16(bios, init->offset) * 10;
+		u32 freq = nvbios_rd16(bios, init->offset) * 10;
 
 		if (i == conf) {
 			trace("\t%dkHz *\n", freq);
@@ -733,12 +733,12 @@ static void
 init_copy(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32  reg = nv_ro32(bios, init->offset + 1);
-	u8 shift = nv_ro08(bios, init->offset + 5);
-	u8 smask = nv_ro08(bios, init->offset + 6);
-	u16 port = nv_ro16(bios, init->offset + 7);
-	u8 index = nv_ro08(bios, init->offset + 9);
-	u8  mask = nv_ro08(bios, init->offset + 10);
+	u32  reg = nvbios_rd32(bios, init->offset + 1);
+	u8 shift = nvbios_rd08(bios, init->offset + 5);
+	u8 smask = nvbios_rd08(bios, init->offset + 6);
+	u16 port = nvbios_rd16(bios, init->offset + 7);
+	u8 index = nvbios_rd08(bios, init->offset + 9);
+	u8  mask = nvbios_rd08(bios, init->offset + 10);
 	u8  data;
 
 	trace("COPY\t0x%04x[0x%02x] &= 0x%02x |= "
@@ -772,7 +772,7 @@ static void
 init_io_flag_condition(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8 cond = nv_ro08(bios, init->offset + 1);
+	u8 cond = nvbios_rd08(bios, init->offset + 1);
 
 	trace("IO_FLAG_CONDITION\t0x%02x\n", cond);
 	init->offset += 2;
@@ -790,8 +790,8 @@ init_dp_condition(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
 	struct nvbios_dpout info;
-	u8  cond = nv_ro08(bios, init->offset + 1);
-	u8  unkn = nv_ro08(bios, init->offset + 2);
+	u8  cond = nvbios_rd08(bios, init->offset + 1);
+	u8  unkn = nvbios_rd08(bios, init->offset + 2);
 	u8  ver, hdr, cnt, len;
 	u16 data;
 
@@ -837,7 +837,7 @@ static void
 init_io_mask_or(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8 index = nv_ro08(bios, init->offset + 1);
+	u8 index = nvbios_rd08(bios, init->offset + 1);
 	u8    or = init_or(init);
 	u8  data;
 
@@ -856,7 +856,7 @@ static void
 init_io_or(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8 index = nv_ro08(bios, init->offset + 1);
+	u8 index = nvbios_rd08(bios, init->offset + 1);
 	u8    or = init_or(init);
 	u8  data;
 
@@ -875,8 +875,8 @@ static void
 init_andn_reg(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32  reg = nv_ro32(bios, init->offset + 1);
-	u32 mask = nv_ro32(bios, init->offset + 5);
+	u32  reg = nvbios_rd32(bios, init->offset + 1);
+	u32 mask = nvbios_rd32(bios, init->offset + 5);
 
 	trace("ANDN_REG\tR[0x%06x] &= ~0x%08x\n", reg, mask);
 	init->offset += 9;
@@ -892,8 +892,8 @@ static void
 init_or_reg(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32  reg = nv_ro32(bios, init->offset + 1);
-	u32 mask = nv_ro32(bios, init->offset + 5);
+	u32  reg = nvbios_rd32(bios, init->offset + 1);
+	u32 mask = nvbios_rd32(bios, init->offset + 5);
 
 	trace("OR_REG\tR[0x%06x] |= 0x%08x\n", reg, mask);
 	init->offset += 9;
@@ -909,19 +909,19 @@ static void
 init_idx_addr_latched(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32 creg = nv_ro32(bios, init->offset + 1);
-	u32 dreg = nv_ro32(bios, init->offset + 5);
-	u32 mask = nv_ro32(bios, init->offset + 9);
-	u32 data = nv_ro32(bios, init->offset + 13);
-	u8 count = nv_ro08(bios, init->offset + 17);
+	u32 creg = nvbios_rd32(bios, init->offset + 1);
+	u32 dreg = nvbios_rd32(bios, init->offset + 5);
+	u32 mask = nvbios_rd32(bios, init->offset + 9);
+	u32 data = nvbios_rd32(bios, init->offset + 13);
+	u8 count = nvbios_rd08(bios, init->offset + 17);
 
 	trace("INDEX_ADDRESS_LATCHED\tR[0x%06x] : R[0x%06x]\n", creg, dreg);
 	trace("\tCTRL &= 0x%08x |= 0x%08x\n", mask, data);
 	init->offset += 18;
 
 	while (count--) {
-		u8 iaddr = nv_ro08(bios, init->offset + 0);
-		u8 idata = nv_ro08(bios, init->offset + 1);
+		u8 iaddr = nvbios_rd08(bios, init->offset + 0);
+		u8 idata = nvbios_rd08(bios, init->offset + 1);
 
 		trace("\t[0x%02x] = 0x%02x\n", iaddr, idata);
 		init->offset += 2;
@@ -939,12 +939,12 @@ static void
 init_io_restrict_pll2(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u16 port = nv_ro16(bios, init->offset + 1);
-	u8 index = nv_ro08(bios, init->offset + 3);
-	u8  mask = nv_ro08(bios, init->offset + 4);
-	u8 shift = nv_ro08(bios, init->offset + 5);
-	u8 count = nv_ro08(bios, init->offset + 6);
-	u32  reg = nv_ro32(bios, init->offset + 7);
+	u16 port = nvbios_rd16(bios, init->offset + 1);
+	u8 index = nvbios_rd08(bios, init->offset + 3);
+	u8  mask = nvbios_rd08(bios, init->offset + 4);
+	u8 shift = nvbios_rd08(bios, init->offset + 5);
+	u8 count = nvbios_rd08(bios, init->offset + 6);
+	u32  reg = nvbios_rd32(bios, init->offset + 7);
 	u8  conf, i;
 
 	trace("IO_RESTRICT_PLL2\t"
@@ -954,7 +954,7 @@ init_io_restrict_pll2(struct nvbios_init *init)
 
 	conf = (init_rdvgai(init, port, index) & mask) >> shift;
 	for (i = 0; i < count; i++) {
-		u32 freq = nv_ro32(bios, init->offset);
+		u32 freq = nvbios_rd32(bios, init->offset);
 		if (i == conf) {
 			trace("\t%dkHz *\n", freq);
 			init_prog_pll(init, reg, freq);
@@ -974,8 +974,8 @@ static void
 init_pll2(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32  reg = nv_ro32(bios, init->offset + 1);
-	u32 freq = nv_ro32(bios, init->offset + 5);
+	u32  reg = nvbios_rd32(bios, init->offset + 1);
+	u32 freq = nvbios_rd32(bios, init->offset + 5);
 
 	trace("PLL2\tR[0x%06x] =PLL= %dkHz\n", reg, freq);
 	init->offset += 9;
@@ -991,17 +991,17 @@ static void
 init_i2c_byte(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8 index = nv_ro08(bios, init->offset + 1);
-	u8  addr = nv_ro08(bios, init->offset + 2) >> 1;
-	u8 count = nv_ro08(bios, init->offset + 3);
+	u8 index = nvbios_rd08(bios, init->offset + 1);
+	u8  addr = nvbios_rd08(bios, init->offset + 2) >> 1;
+	u8 count = nvbios_rd08(bios, init->offset + 3);
 
 	trace("I2C_BYTE\tI2C[0x%02x][0x%02x]\n", index, addr);
 	init->offset += 4;
 
 	while (count--) {
-		u8  reg = nv_ro08(bios, init->offset + 0);
-		u8 mask = nv_ro08(bios, init->offset + 1);
-		u8 data = nv_ro08(bios, init->offset + 2);
+		u8  reg = nvbios_rd08(bios, init->offset + 0);
+		u8 mask = nvbios_rd08(bios, init->offset + 1);
+		u8 data = nvbios_rd08(bios, init->offset + 2);
 		int val;
 
 		trace("\t[0x%02x] &= 0x%02x |= 0x%02x\n", reg, mask, data);
@@ -1022,16 +1022,16 @@ static void
 init_zm_i2c_byte(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8 index = nv_ro08(bios, init->offset + 1);
-	u8  addr = nv_ro08(bios, init->offset + 2) >> 1;
-	u8 count = nv_ro08(bios, init->offset + 3);
+	u8 index = nvbios_rd08(bios, init->offset + 1);
+	u8  addr = nvbios_rd08(bios, init->offset + 2) >> 1;
+	u8 count = nvbios_rd08(bios, init->offset + 3);
 
 	trace("ZM_I2C_BYTE\tI2C[0x%02x][0x%02x]\n", index, addr);
 	init->offset += 4;
 
 	while (count--) {
-		u8  reg = nv_ro08(bios, init->offset + 0);
-		u8 data = nv_ro08(bios, init->offset + 1);
+		u8  reg = nvbios_rd08(bios, init->offset + 0);
+		u8 data = nvbios_rd08(bios, init->offset + 1);
 
 		trace("\t[0x%02x] = 0x%02x\n", reg, data);
 		init->offset += 2;
@@ -1048,16 +1048,16 @@ static void
 init_zm_i2c(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8 index = nv_ro08(bios, init->offset + 1);
-	u8  addr = nv_ro08(bios, init->offset + 2) >> 1;
-	u8 count = nv_ro08(bios, init->offset + 3);
+	u8 index = nvbios_rd08(bios, init->offset + 1);
+	u8  addr = nvbios_rd08(bios, init->offset + 2) >> 1;
+	u8 count = nvbios_rd08(bios, init->offset + 3);
 	u8 data[256], i;
 
 	trace("ZM_I2C\tI2C[0x%02x][0x%02x]\n", index, addr);
 	init->offset += 4;
 
 	for (i = 0; i < count; i++) {
-		data[i] = nv_ro08(bios, init->offset);
+		data[i] = nvbios_rd08(bios, init->offset);
 		trace("\t0x%02x\n", data[i]);
 		init->offset++;
 	}
@@ -1082,10 +1082,10 @@ static void
 init_tmds(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8 tmds = nv_ro08(bios, init->offset + 1);
-	u8 addr = nv_ro08(bios, init->offset + 2);
-	u8 mask = nv_ro08(bios, init->offset + 3);
-	u8 data = nv_ro08(bios, init->offset + 4);
+	u8 tmds = nvbios_rd08(bios, init->offset + 1);
+	u8 addr = nvbios_rd08(bios, init->offset + 2);
+	u8 mask = nvbios_rd08(bios, init->offset + 3);
+	u8 data = nvbios_rd08(bios, init->offset + 4);
 	u32 reg = init_tmds_reg(init, tmds);
 
 	trace("TMDS\tT[0x%02x][0x%02x] &= 0x%02x |= 0x%02x\n",
@@ -1108,16 +1108,16 @@ static void
 init_zm_tmds_group(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8  tmds = nv_ro08(bios, init->offset + 1);
-	u8 count = nv_ro08(bios, init->offset + 2);
+	u8  tmds = nvbios_rd08(bios, init->offset + 1);
+	u8 count = nvbios_rd08(bios, init->offset + 2);
 	u32  reg = init_tmds_reg(init, tmds);
 
 	trace("TMDS_ZM_GROUP\tT[0x%02x]\n", tmds);
 	init->offset += 3;
 
 	while (count--) {
-		u8 addr = nv_ro08(bios, init->offset + 0);
-		u8 data = nv_ro08(bios, init->offset + 1);
+		u8 addr = nvbios_rd08(bios, init->offset + 0);
+		u8 data = nvbios_rd08(bios, init->offset + 1);
 
 		trace("\t[0x%02x] = 0x%02x\n", addr, data);
 		init->offset += 2;
@@ -1135,10 +1135,10 @@ static void
 init_cr_idx_adr_latch(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8 addr0 = nv_ro08(bios, init->offset + 1);
-	u8 addr1 = nv_ro08(bios, init->offset + 2);
-	u8  base = nv_ro08(bios, init->offset + 3);
-	u8 count = nv_ro08(bios, init->offset + 4);
+	u8 addr0 = nvbios_rd08(bios, init->offset + 1);
+	u8 addr1 = nvbios_rd08(bios, init->offset + 2);
+	u8  base = nvbios_rd08(bios, init->offset + 3);
+	u8 count = nvbios_rd08(bios, init->offset + 4);
 	u8 save0;
 
 	trace("CR_INDEX_ADDR C[%02x] C[%02x]\n", addr0, addr1);
@@ -1146,7 +1146,7 @@ init_cr_idx_adr_latch(struct nvbios_init *init)
 
 	save0 = init_rdvgai(init, 0x03d4, addr0);
 	while (count--) {
-		u8 data = nv_ro08(bios, init->offset);
+		u8 data = nvbios_rd08(bios, init->offset);
 
 		trace("\t\t[0x%02x] = 0x%02x\n", base, data);
 		init->offset += 1;
@@ -1165,9 +1165,9 @@ static void
 init_cr(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8 addr = nv_ro08(bios, init->offset + 1);
-	u8 mask = nv_ro08(bios, init->offset + 2);
-	u8 data = nv_ro08(bios, init->offset + 3);
+	u8 addr = nvbios_rd08(bios, init->offset + 1);
+	u8 mask = nvbios_rd08(bios, init->offset + 2);
+	u8 data = nvbios_rd08(bios, init->offset + 3);
 	u8 val;
 
 	trace("CR\t\tC[0x%02x] &= 0x%02x |= 0x%02x\n", addr, mask, data);
@@ -1185,8 +1185,8 @@ static void
 init_zm_cr(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8 addr = nv_ro08(bios, init->offset + 1);
-	u8 data = nv_ro08(bios, init->offset + 2);
+	u8 addr = nvbios_rd08(bios, init->offset + 1);
+	u8 data = nvbios_rd08(bios, init->offset + 2);
 
 	trace("ZM_CR\tC[0x%02x] = 0x%02x\n", addr,  data);
 	init->offset += 3;
@@ -1202,14 +1202,14 @@ static void
 init_zm_cr_group(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8 count = nv_ro08(bios, init->offset + 1);
+	u8 count = nvbios_rd08(bios, init->offset + 1);
 
 	trace("ZM_CR_GROUP\n");
 	init->offset += 2;
 
 	while (count--) {
-		u8 addr = nv_ro08(bios, init->offset + 0);
-		u8 data = nv_ro08(bios, init->offset + 1);
+		u8 addr = nvbios_rd08(bios, init->offset + 0);
+		u8 data = nvbios_rd08(bios, init->offset + 1);
 
 		trace("\t\tC[0x%02x] = 0x%02x\n", addr, data);
 		init->offset += 2;
@@ -1226,8 +1226,8 @@ static void
 init_condition_time(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8  cond = nv_ro08(bios, init->offset + 1);
-	u8 retry = nv_ro08(bios, init->offset + 2);
+	u8  cond = nvbios_rd08(bios, init->offset + 1);
+	u8 retry = nvbios_rd08(bios, init->offset + 2);
 	u8  wait = min((u16)retry * 50, 100);
 
 	trace("CONDITION_TIME\t0x%02x 0x%02x\n", cond, retry);
@@ -1253,7 +1253,7 @@ static void
 init_ltime(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u16 msec = nv_ro16(bios, init->offset + 1);
+	u16 msec = nvbios_rd16(bios, init->offset + 1);
 
 	trace("LTIME\t0x%04x\n", msec);
 	init->offset += 3;
@@ -1270,14 +1270,14 @@ static void
 init_zm_reg_sequence(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32 base = nv_ro32(bios, init->offset + 1);
-	u8 count = nv_ro08(bios, init->offset + 5);
+	u32 base = nvbios_rd32(bios, init->offset + 1);
+	u8 count = nvbios_rd08(bios, init->offset + 5);
 
 	trace("ZM_REG_SEQUENCE\t0x%02x\n", count);
 	init->offset += 6;
 
 	while (count--) {
-		u32 data = nv_ro32(bios, init->offset);
+		u32 data = nvbios_rd32(bios, init->offset);
 
 		trace("\t\tR[0x%06x] = 0x%08x\n", base, data);
 		init->offset += 4;
@@ -1295,9 +1295,9 @@ static void
 init_pll_indirect(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32  reg = nv_ro32(bios, init->offset + 1);
-	u16 addr = nv_ro16(bios, init->offset + 5);
-	u32 freq = (u32)nv_ro16(bios, addr) * 1000;
+	u32  reg = nvbios_rd32(bios, init->offset + 1);
+	u16 addr = nvbios_rd16(bios, init->offset + 5);
+	u32 freq = (u32)nvbios_rd16(bios, addr) * 1000;
 
 	trace("PLL_INDIRECT\tR[0x%06x] =PLL= VBIOS[%04x] = %dkHz\n",
 	      reg, addr, freq);
@@ -1314,9 +1314,9 @@ static void
 init_zm_reg_indirect(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32  reg = nv_ro32(bios, init->offset + 1);
-	u16 addr = nv_ro16(bios, init->offset + 5);
-	u32 data = nv_ro32(bios, addr);
+	u32  reg = nvbios_rd32(bios, init->offset + 1);
+	u16 addr = nvbios_rd16(bios, init->offset + 5);
+	u32 data = nvbios_rd32(bios, addr);
 
 	trace("ZM_REG_INDIRECT\tR[0x%06x] = VBIOS[0x%04x] = 0x%08x\n",
 	      reg, addr, data);
@@ -1333,7 +1333,7 @@ static void
 init_sub_direct(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u16 addr = nv_ro16(bios, init->offset + 1);
+	u16 addr = nvbios_rd16(bios, init->offset + 1);
 	u16 save;
 
 	trace("SUB_DIRECT\t0x%04x\n", addr);
@@ -1359,7 +1359,7 @@ static void
 init_jump(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u16 offset = nv_ro16(bios, init->offset + 1);
+	u16 offset = nvbios_rd16(bios, init->offset + 1);
 
 	trace("JUMP\t0x%04x\n", offset);
 
@@ -1377,11 +1377,11 @@ static void
 init_i2c_if(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8 index = nv_ro08(bios, init->offset + 1);
-	u8  addr = nv_ro08(bios, init->offset + 2);
-	u8   reg = nv_ro08(bios, init->offset + 3);
-	u8  mask = nv_ro08(bios, init->offset + 4);
-	u8  data = nv_ro08(bios, init->offset + 5);
+	u8 index = nvbios_rd08(bios, init->offset + 1);
+	u8  addr = nvbios_rd08(bios, init->offset + 2);
+	u8   reg = nvbios_rd08(bios, init->offset + 3);
+	u8  mask = nvbios_rd08(bios, init->offset + 4);
+	u8  data = nvbios_rd08(bios, init->offset + 5);
 	u8 value;
 
 	trace("I2C_IF\tI2C[0x%02x][0x%02x][0x%02x] & 0x%02x == 0x%02x\n",
@@ -1404,12 +1404,12 @@ static void
 init_copy_nv_reg(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32  sreg = nv_ro32(bios, init->offset + 1);
-	u8  shift = nv_ro08(bios, init->offset + 5);
-	u32 smask = nv_ro32(bios, init->offset + 6);
-	u32  sxor = nv_ro32(bios, init->offset + 10);
-	u32  dreg = nv_ro32(bios, init->offset + 14);
-	u32 dmask = nv_ro32(bios, init->offset + 18);
+	u32  sreg = nvbios_rd32(bios, init->offset + 1);
+	u8  shift = nvbios_rd08(bios, init->offset + 5);
+	u32 smask = nvbios_rd32(bios, init->offset + 6);
+	u32  sxor = nvbios_rd32(bios, init->offset + 10);
+	u32  dreg = nvbios_rd32(bios, init->offset + 14);
+	u32 dmask = nvbios_rd32(bios, init->offset + 18);
 	u32 data;
 
 	trace("COPY_NV_REG\tR[0x%06x] &= 0x%08x |= "
@@ -1430,9 +1430,9 @@ static void
 init_zm_index_io(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u16 port = nv_ro16(bios, init->offset + 1);
-	u8 index = nv_ro08(bios, init->offset + 3);
-	u8  data = nv_ro08(bios, init->offset + 4);
+	u16 port = nvbios_rd16(bios, init->offset + 1);
+	u8 index = nvbios_rd08(bios, init->offset + 3);
+	u8  data = nvbios_rd08(bios, init->offset + 4);
 
 	trace("ZM_INDEX_IO\tI[0x%04x][0x%02x] = 0x%02x\n", port, index, data);
 	init->offset += 5;
@@ -1466,9 +1466,9 @@ static void
 init_reset(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32   reg = nv_ro32(bios, init->offset + 1);
-	u32 data1 = nv_ro32(bios, init->offset + 5);
-	u32 data2 = nv_ro32(bios, init->offset + 9);
+	u32   reg = nvbios_rd32(bios, init->offset + 1);
+	u32 data1 = nvbios_rd32(bios, init->offset + 5);
+	u32 data2 = nvbios_rd32(bios, init->offset + 9);
 	u32 savepci19;
 
 	trace("RESET\tR[0x%08x] = 0x%08x, 0x%08x", reg, data1, data2);
@@ -1516,14 +1516,14 @@ init_configure_mem(struct nvbios_init *init)
 
 	mdata = init_configure_mem_clk(init);
 	sdata = bmp_sdr_seq_table(bios);
-	if (nv_ro08(bios, mdata) & 0x01)
+	if (nvbios_rd08(bios, mdata) & 0x01)
 		sdata = bmp_ddr_seq_table(bios);
 	mdata += 6; /* skip to data */
 
 	data = init_rdvgai(init, 0x03c4, 0x01);
 	init_wrvgai(init, 0x03c4, 0x01, data | 0x20);
 
-	for (; (addr = nv_ro32(bios, sdata)) != 0xffffffff; sdata += 4) {
+	for (; (addr = nvbios_rd32(bios, sdata)) != 0xffffffff; sdata += 4) {
 		switch (addr) {
 		case 0x10021c: /* CKE_NORMAL */
 		case 0x1002d0: /* CMD_REFRESH */
@@ -1531,7 +1531,7 @@ init_configure_mem(struct nvbios_init *init)
 			data = 0x00000001;
 			break;
 		default:
-			data = nv_ro32(bios, mdata);
+			data = nvbios_rd32(bios, mdata);
 			mdata += 4;
 			if (data == 0xffffffff)
 				continue;
@@ -1566,12 +1566,12 @@ init_configure_clk(struct nvbios_init *init)
 	mdata = init_configure_mem_clk(init);
 
 	/* NVPLL */
-	clock = nv_ro16(bios, mdata + 4) * 10;
+	clock = nvbios_rd16(bios, mdata + 4) * 10;
 	init_prog_pll(init, 0x680500, clock);
 
 	/* MPLL */
-	clock = nv_ro16(bios, mdata + 2) * 10;
-	if (nv_ro08(bios, mdata) & 0x01)
+	clock = nvbios_rd16(bios, mdata + 2) * 10;
+	if (nvbios_rd08(bios, mdata) & 0x01)
 		clock *= 2;
 	init_prog_pll(init, 0x680504, clock);
 
@@ -1612,9 +1612,9 @@ static void
 init_io(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u16 port = nv_ro16(bios, init->offset + 1);
-	u8  mask = nv_ro16(bios, init->offset + 3);
-	u8  data = nv_ro16(bios, init->offset + 4);
+	u16 port = nvbios_rd16(bios, init->offset + 1);
+	u8  mask = nvbios_rd16(bios, init->offset + 3);
+	u8  data = nvbios_rd16(bios, init->offset + 4);
 	u8 value;
 
 	trace("IO\t\tI[0x%04x] &= 0x%02x |= 0x%02x\n", port, mask, data);
@@ -1652,7 +1652,7 @@ static void
 init_sub(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8 index = nv_ro08(bios, init->offset + 1);
+	u8 index = nvbios_rd08(bios, init->offset + 1);
 	u16 addr, save;
 
 	trace("SUB\t0x%02x\n", index);
@@ -1679,8 +1679,8 @@ static void
 init_ram_condition(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8  mask = nv_ro08(bios, init->offset + 1);
-	u8 value = nv_ro08(bios, init->offset + 2);
+	u8  mask = nvbios_rd08(bios, init->offset + 1);
+	u8 value = nvbios_rd08(bios, init->offset + 2);
 
 	trace("RAM_CONDITION\t"
 	      "(R[0x100000] & 0x%02x) == 0x%02x\n", mask, value);
@@ -1698,9 +1698,9 @@ static void
 init_nv_reg(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32  reg = nv_ro32(bios, init->offset + 1);
-	u32 mask = nv_ro32(bios, init->offset + 5);
-	u32 data = nv_ro32(bios, init->offset + 9);
+	u32  reg = nvbios_rd32(bios, init->offset + 1);
+	u32 mask = nvbios_rd32(bios, init->offset + 5);
+	u32 data = nvbios_rd32(bios, init->offset + 9);
 
 	trace("NV_REG\tR[0x%06x] &= 0x%08x |= 0x%08x\n", reg, mask, data);
 	init->offset += 13;
@@ -1716,15 +1716,15 @@ static void
 init_macro(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8  macro = nv_ro08(bios, init->offset + 1);
+	u8  macro = nvbios_rd08(bios, init->offset + 1);
 	u16 table;
 
 	trace("MACRO\t0x%02x\n", macro);
 
 	table = init_macro_table(init);
 	if (table) {
-		u32 addr = nv_ro32(bios, table + (macro * 8) + 0);
-		u32 data = nv_ro32(bios, table + (macro * 8) + 4);
+		u32 addr = nvbios_rd32(bios, table + (macro * 8) + 0);
+		u32 data = nvbios_rd32(bios, table + (macro * 8) + 4);
 		trace("\t\tR[0x%06x] = 0x%08x\n", addr, data);
 		init_wr32(init, addr, data);
 	}
@@ -1752,8 +1752,8 @@ static void
 init_strap_condition(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32 mask = nv_ro32(bios, init->offset + 1);
-	u32 value = nv_ro32(bios, init->offset + 5);
+	u32 mask = nvbios_rd32(bios, init->offset + 1);
+	u32 value = nvbios_rd32(bios, init->offset + 5);
 
 	trace("STRAP_CONDITION\t(R[0x101000] & 0x%08x) == 0x%08x\n", mask, value);
 	init->offset += 9;
@@ -1770,7 +1770,7 @@ static void
 init_time(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u16 usec = nv_ro16(bios, init->offset + 1);
+	u16 usec = nvbios_rd16(bios, init->offset + 1);
 
 	trace("TIME\t0x%04x\n", usec);
 	init->offset += 3;
@@ -1791,7 +1791,7 @@ static void
 init_condition(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8 cond = nv_ro08(bios, init->offset + 1);
+	u8 cond = nvbios_rd08(bios, init->offset + 1);
 
 	trace("CONDITION\t0x%02x\n", cond);
 	init->offset += 2;
@@ -1808,7 +1808,7 @@ static void
 init_io_condition(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8 cond = nv_ro08(bios, init->offset + 1);
+	u8 cond = nvbios_rd08(bios, init->offset + 1);
 
 	trace("IO_CONDITION\t0x%02x\n", cond);
 	init->offset += 2;
@@ -1825,8 +1825,8 @@ static void
 init_zm_reg16(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32 addr = nv_ro32(bios, init->offset + 1);
-	u16 data = nv_ro16(bios, init->offset + 5);
+	u32 addr = nvbios_rd32(bios, init->offset + 1);
+	u16 data = nvbios_rd16(bios, init->offset + 5);
 
 	trace("ZM_REG\tR[0x%06x] = 0x%04x\n", addr, data);
 	init->offset += 7;
@@ -1842,10 +1842,10 @@ static void
 init_index_io(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u16 port = nv_ro16(bios, init->offset + 1);
-	u8 index = nv_ro16(bios, init->offset + 3);
-	u8  mask = nv_ro08(bios, init->offset + 4);
-	u8  data = nv_ro08(bios, init->offset + 5);
+	u16 port = nvbios_rd16(bios, init->offset + 1);
+	u8 index = nvbios_rd16(bios, init->offset + 3);
+	u8  mask = nvbios_rd08(bios, init->offset + 4);
+	u8  data = nvbios_rd08(bios, init->offset + 5);
 	u8 value;
 
 	trace("INDEX_IO\tI[0x%04x][0x%02x] &= 0x%02x |= 0x%02x\n",
@@ -1864,8 +1864,8 @@ static void
 init_pll(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32  reg = nv_ro32(bios, init->offset + 1);
-	u32 freq = nv_ro16(bios, init->offset + 5) * 10;
+	u32  reg = nvbios_rd32(bios, init->offset + 1);
+	u32 freq = nvbios_rd16(bios, init->offset + 5) * 10;
 
 	trace("PLL\tR[0x%06x] =PLL= %dkHz\n", reg, freq);
 	init->offset += 7;
@@ -1881,8 +1881,8 @@ static void
 init_zm_reg(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32 addr = nv_ro32(bios, init->offset + 1);
-	u32 data = nv_ro32(bios, init->offset + 5);
+	u32 addr = nvbios_rd32(bios, init->offset + 1);
+	u32 data = nvbios_rd32(bios, init->offset + 5);
 
 	trace("ZM_REG\tR[0x%06x] = 0x%08x\n", addr, data);
 	init->offset += 9;
@@ -1901,7 +1901,7 @@ static void
 init_ram_restrict_pll(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8  type = nv_ro08(bios, init->offset + 1);
+	u8  type = nvbios_rd08(bios, init->offset + 1);
 	u8 count = init_ram_restrict_group_count(init);
 	u8 strap = init_ram_restrict(init);
 	u8 cconf;
@@ -1910,7 +1910,7 @@ init_ram_restrict_pll(struct nvbios_init *init)
 	init->offset += 2;
 
 	for (cconf = 0; cconf < count; cconf++) {
-		u32 freq = nv_ro32(bios, init->offset);
+		u32 freq = nvbios_rd32(bios, init->offset);
 
 		if (cconf == strap) {
 			trace("%dkHz *\n", freq);
@@ -1947,9 +1947,9 @@ static void
 init_ram_restrict_zm_reg_group(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32 addr = nv_ro32(bios, init->offset + 1);
-	u8  incr = nv_ro08(bios, init->offset + 5);
-	u8   num = nv_ro08(bios, init->offset + 6);
+	u32 addr = nvbios_rd32(bios, init->offset + 1);
+	u8  incr = nvbios_rd08(bios, init->offset + 5);
+	u8   num = nvbios_rd08(bios, init->offset + 6);
 	u8 count = init_ram_restrict_group_count(init);
 	u8 index = init_ram_restrict(init);
 	u8 i, j;
@@ -1961,7 +1961,7 @@ init_ram_restrict_zm_reg_group(struct nvbios_init *init)
 	for (i = 0; i < num; i++) {
 		trace("\tR[0x%06x] = {\n", addr);
 		for (j = 0; j < count; j++) {
-			u32 data = nv_ro32(bios, init->offset);
+			u32 data = nvbios_rd32(bios, init->offset);
 
 			if (j == index) {
 				trace("\t\t0x%08x *\n", data);
@@ -1985,8 +1985,8 @@ static void
 init_copy_zm_reg(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32 sreg = nv_ro32(bios, init->offset + 1);
-	u32 dreg = nv_ro32(bios, init->offset + 5);
+	u32 sreg = nvbios_rd32(bios, init->offset + 1);
+	u32 dreg = nvbios_rd32(bios, init->offset + 5);
 
 	trace("COPY_ZM_REG\tR[0x%06x] = R[0x%06x]\n", dreg, sreg);
 	init->offset += 9;
@@ -2002,14 +2002,14 @@ static void
 init_zm_reg_group(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32 addr = nv_ro32(bios, init->offset + 1);
-	u8 count = nv_ro08(bios, init->offset + 5);
+	u32 addr = nvbios_rd32(bios, init->offset + 1);
+	u8 count = nvbios_rd08(bios, init->offset + 5);
 
 	trace("ZM_REG_GROUP\tR[0x%06x] =\n", addr);
 	init->offset += 6;
 
 	while (count--) {
-		u32 data = nv_ro32(bios, init->offset);
+		u32 data = nvbios_rd32(bios, init->offset);
 		trace("\t0x%08x\n", data);
 		init_wr32(init, addr, data);
 		init->offset += 4;
@@ -2024,13 +2024,13 @@ static void
 init_xlat(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32 saddr = nv_ro32(bios, init->offset + 1);
-	u8 sshift = nv_ro08(bios, init->offset + 5);
-	u8  smask = nv_ro08(bios, init->offset + 6);
-	u8  index = nv_ro08(bios, init->offset + 7);
-	u32 daddr = nv_ro32(bios, init->offset + 8);
-	u32 dmask = nv_ro32(bios, init->offset + 12);
-	u8  shift = nv_ro08(bios, init->offset + 16);
+	u32 saddr = nvbios_rd32(bios, init->offset + 1);
+	u8 sshift = nvbios_rd08(bios, init->offset + 5);
+	u8  smask = nvbios_rd08(bios, init->offset + 6);
+	u8  index = nvbios_rd08(bios, init->offset + 7);
+	u32 daddr = nvbios_rd32(bios, init->offset + 8);
+	u32 dmask = nvbios_rd32(bios, init->offset + 12);
+	u8  shift = nvbios_rd08(bios, init->offset + 16);
 	u32 data;
 
 	trace("INIT_XLAT\tR[0x%06x] &= 0x%08x |= "
@@ -2052,9 +2052,9 @@ static void
 init_zm_mask_add(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32 addr = nv_ro32(bios, init->offset + 1);
-	u32 mask = nv_ro32(bios, init->offset + 5);
-	u32  add = nv_ro32(bios, init->offset + 9);
+	u32 addr = nvbios_rd32(bios, init->offset + 1);
+	u32 mask = nvbios_rd32(bios, init->offset + 5);
+	u32  add = nvbios_rd32(bios, init->offset + 9);
 	u32 data;
 
 	trace("ZM_MASK_ADD\tR[0x%06x] &= 0x%08x += 0x%08x\n", addr, mask, add);
@@ -2073,15 +2073,15 @@ static void
 init_auxch(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32 addr = nv_ro32(bios, init->offset + 1);
-	u8 count = nv_ro08(bios, init->offset + 5);
+	u32 addr = nvbios_rd32(bios, init->offset + 1);
+	u8 count = nvbios_rd08(bios, init->offset + 5);
 
 	trace("AUXCH\tAUX[0x%08x] 0x%02x\n", addr, count);
 	init->offset += 6;
 
 	while (count--) {
-		u8 mask = nv_ro08(bios, init->offset + 0);
-		u8 data = nv_ro08(bios, init->offset + 1);
+		u8 mask = nvbios_rd08(bios, init->offset + 0);
+		u8 data = nvbios_rd08(bios, init->offset + 1);
 		trace("\tAUX[0x%08x] &= 0x%02x |= 0x%02x\n", addr, mask, data);
 		mask = init_rdauxr(init, addr) & mask;
 		init_wrauxr(init, addr, mask | data);
@@ -2097,14 +2097,14 @@ static void
 init_zm_auxch(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u32 addr = nv_ro32(bios, init->offset + 1);
-	u8 count = nv_ro08(bios, init->offset + 5);
+	u32 addr = nvbios_rd32(bios, init->offset + 1);
+	u8 count = nvbios_rd08(bios, init->offset + 5);
 
 	trace("ZM_AUXCH\tAUX[0x%08x] 0x%02x\n", addr, count);
 	init->offset += 6;
 
 	while (count--) {
-		u8 data = nv_ro08(bios, init->offset + 0);
+		u8 data = nvbios_rd08(bios, init->offset + 0);
 		trace("\tAUX[0x%08x] = 0x%02x\n", addr, data);
 		init_wrauxr(init, addr, data);
 		init->offset += 1;
@@ -2119,12 +2119,12 @@ static void
 init_i2c_long_if(struct nvbios_init *init)
 {
 	struct nvkm_bios *bios = init->bios;
-	u8 index = nv_ro08(bios, init->offset + 1);
-	u8  addr = nv_ro08(bios, init->offset + 2) >> 1;
-	u8 reglo = nv_ro08(bios, init->offset + 3);
-	u8 reghi = nv_ro08(bios, init->offset + 4);
-	u8  mask = nv_ro08(bios, init->offset + 5);
-	u8  data = nv_ro08(bios, init->offset + 6);
+	u8 index = nvbios_rd08(bios, init->offset + 1);
+	u8  addr = nvbios_rd08(bios, init->offset + 2) >> 1;
+	u8 reglo = nvbios_rd08(bios, init->offset + 3);
+	u8 reghi = nvbios_rd08(bios, init->offset + 4);
+	u8  mask = nvbios_rd08(bios, init->offset + 5);
+	u8  data = nvbios_rd08(bios, init->offset + 6);
 	struct nvkm_i2c_port *port;
 
 	trace("I2C_LONG_IF\t"
@@ -2160,7 +2160,7 @@ init_gpio_ne(struct nvbios_init *init)
 	struct nvkm_bios *bios = init->bios;
 	struct nvkm_gpio *gpio = nvkm_gpio(bios);
 	struct dcb_gpio_func func;
-	u8 count = nv_ro08(bios, init->offset + 1);
+	u8 count = nvbios_rd08(bios, init->offset + 1);
 	u8 idx = 0, ver, len;
 	u16 data, i;
 
@@ -2168,13 +2168,13 @@ init_gpio_ne(struct nvbios_init *init)
 	init->offset += 2;
 
 	for (i = init->offset; i < init->offset + count; i++)
-		cont("0x%02x ", nv_ro08(bios, i));
+		cont("0x%02x ", nvbios_rd08(bios, i));
 	cont("\n");
 
 	while ((data = dcb_gpio_parse(bios, 0, idx++, &ver, &len, &func))) {
 		if (func.func != DCB_GPIO_UNUSED) {
 			for (i = init->offset; i < init->offset + count; i++) {
-				if (func.func == nv_ro08(bios, i))
+				if (func.func == nvbios_rd08(bios, i))
 					break;
 			}
 
@@ -2272,7 +2272,7 @@ nvbios_exec(struct nvbios_init *init)
 {
 	init->nested++;
 	while (init->offset) {
-		u8 opcode = nv_ro08(init->bios, init->offset);
+		u8 opcode = nvbios_rd08(init->bios, init->offset);
 		if (opcode >= init_opcode_nr || !init_opcode[opcode].exec) {
 			error("unknown opcode 0x%02x\n", opcode);
 			return -EINVAL;

commit 60b29d2071795d322221cfcfe377e6778b09ca90
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:11 2015 +1000

    drm/nouveau/bios: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index 64d7b482674d..b03076e9a0ef 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -37,11 +37,12 @@
 #include <subdev/vga.h>
 
 #define bioslog(lvl, fmt, args...) do {                                        \
-	nv_printk(init->bios, lvl, "0x%04x[%c]: "fmt, init->offset,            \
-		  init_exec(init) ? '0' + (init->nested - 1) : ' ', ##args);   \
+	nvkm_printk(init->subdev, lvl, info, "0x%04x[%c]: "fmt,                \
+		    init->offset, init_exec(init) ?                            \
+		    '0' + (init->nested - 1) : ' ', ##args);                   \
 } while(0)
 #define cont(fmt, args...) do {                                                \
-	if (nv_subdev(init->bios)->debug >= NV_DBG_TRACE)                      \
+	if (init->subdev->debug >= NV_DBG_TRACE)                               \
 		printk(fmt, ##args);                                           \
 } while(0)
 #define trace(fmt, args...) bioslog(TRACE, fmt, ##args)
@@ -2292,7 +2293,7 @@ nvbios_init(struct nvkm_subdev *subdev, bool execute)
 	u16 data;
 
 	if (execute)
-		nv_info(bios, "running init tables\n");
+		nvkm_debug(subdev, "running init tables\n");
 	while (!ret && (data = (init_script(bios, ++i)))) {
 		struct nvbios_init init = {
 			.subdev = subdev,

commit d8f266a353cb397aa792b59d5aa16ea09579f9ac
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:08 2015 +1000

    drm/nouveau/bios: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index 045b7ddb4d66..64d7b482674d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -180,27 +180,30 @@ init_nvreg(struct nvbios_init *init, u32 reg)
 static u32
 init_rd32(struct nvbios_init *init, u32 reg)
 {
+	struct nvkm_device *device = init->bios->subdev.device;
 	reg = init_nvreg(init, reg);
 	if (reg != ~0 && init_exec(init))
-		return nv_rd32(init->subdev, reg);
+		return nvkm_rd32(device, reg);
 	return 0x00000000;
 }
 
 static void
 init_wr32(struct nvbios_init *init, u32 reg, u32 val)
 {
+	struct nvkm_device *device = init->bios->subdev.device;
 	reg = init_nvreg(init, reg);
 	if (reg != ~0 && init_exec(init))
-		nv_wr32(init->subdev, reg, val);
+		nvkm_wr32(device, reg, val);
 }
 
 static u32
 init_mask(struct nvbios_init *init, u32 reg, u32 mask, u32 val)
 {
+	struct nvkm_device *device = init->bios->subdev.device;
 	reg = init_nvreg(init, reg);
 	if (reg != ~0 && init_exec(init)) {
-		u32 tmp = nv_rd32(init->subdev, reg);
-		nv_wr32(init->subdev, reg, (tmp & ~mask) | val);
+		u32 tmp = nvkm_rd32(device, reg);
+		nvkm_wr32(device, reg, (tmp & ~mask) | val);
 		return tmp;
 	}
 	return 0x00000000;

commit 9ace404b1098221021b01c2ba0eeea0c257fa4a5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/device: include core/device.h automatically for subdevs/engines
    
    Pretty much every subdev/engine is going to need access to nvkm_device
    shortly to touch registers and/or output messages.
    
    The odd placement of the includes is necessary to work around some
    inter-dependencies that currently exist.  This will be fixed later.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index 8e5f6ce76232..045b7ddb4d66 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -31,7 +31,6 @@
 #include <subdev/bios/init.h>
 #include <subdev/bios/ramcfg.h>
 
-#include <core/device.h>
 #include <subdev/devinit.h>
 #include <subdev/gpio.h>
 #include <subdev/i2c.h>

commit bacbad17fbc636125bf472240860a58a54ad62db
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Fri Jun 19 02:51:23 2015 -0400

    drm/nouveau/bios: add opcodes 0x73 and 0x77
    
    No known VBIOSes use these, but they are present in the actual VBIOS
    table parsing logic. No harm in adding these too.
    
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index f4611e3f0971..8e5f6ce76232 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -1741,6 +1741,24 @@ init_resume(struct nvbios_init *init)
 	init_exec_set(init, true);
 }
 
+/**
+ * INIT_STRAP_CONDITION - opcode 0x73
+ *
+ */
+static void
+init_strap_condition(struct nvbios_init *init)
+{
+	struct nvkm_bios *bios = init->bios;
+	u32 mask = nv_ro32(bios, init->offset + 1);
+	u32 value = nv_ro32(bios, init->offset + 5);
+
+	trace("STRAP_CONDITION\t(R[0x101000] & 0x%08x) == 0x%08x\n", mask, value);
+	init->offset += 9;
+
+	if ((init_rd32(init, 0x101000) & mask) != value)
+		init_exec_set(init, false);
+}
+
 /**
  * INIT_TIME - opcode 0x74
  *
@@ -1796,6 +1814,23 @@ init_io_condition(struct nvbios_init *init)
 		init_exec_set(init, false);
 }
 
+/**
+ * INIT_ZM_REG16 - opcode 0x77
+ *
+ */
+static void
+init_zm_reg16(struct nvbios_init *init)
+{
+	struct nvkm_bios *bios = init->bios;
+	u32 addr = nv_ro32(bios, init->offset + 1);
+	u16 data = nv_ro16(bios, init->offset + 5);
+
+	trace("ZM_REG\tR[0x%06x] = 0x%04x\n", addr, data);
+	init->offset += 7;
+
+	init_wr32(init, addr, data);
+}
+
 /**
  * INIT_INDEX_IO - opcode 0x78
  *
@@ -2202,9 +2237,11 @@ static struct nvbios_init_opcode {
 	[0x6f] = { init_macro },
 	[0x71] = { init_done },
 	[0x72] = { init_resume },
+	[0x73] = { init_strap_condition },
 	[0x74] = { init_time },
 	[0x75] = { init_condition },
 	[0x76] = { init_io_condition },
+	[0x77] = { init_zm_reg16 },
 	[0x78] = { init_index_io },
 	[0x79] = { init_pll },
 	[0x7a] = { init_zm_reg },

commit d31b11d85814ff669cfeb93c0f85b9d659a85ef8
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Fri Jun 19 01:19:40 2015 -0400

    drm/nouveau/bios: add proper support for opcode 0x59
    
    More analysis shows that this is identical to 0x79 except that it loads
    the frequency indirectly from elsewhere in the VBIOS.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=91025
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index 1f590f839f76..f4611e3f0971 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -577,9 +577,6 @@ init_reserved(struct nvbios_init *init)
 	u8 length, i;
 
 	switch (opcode) {
-	case 0x59:
-		length = 7;
-		break;
 	case 0xaa:
 		length = 4;
 		break;
@@ -1287,6 +1284,25 @@ init_zm_reg_sequence(struct nvbios_init *init)
 	}
 }
 
+/**
+ * INIT_PLL_INDIRECT - opcode 0x59
+ *
+ */
+static void
+init_pll_indirect(struct nvbios_init *init)
+{
+	struct nvkm_bios *bios = init->bios;
+	u32  reg = nv_ro32(bios, init->offset + 1);
+	u16 addr = nv_ro16(bios, init->offset + 5);
+	u32 freq = (u32)nv_ro16(bios, addr) * 1000;
+
+	trace("PLL_INDIRECT\tR[0x%06x] =PLL= VBIOS[%04x] = %dkHz\n",
+	      reg, addr, freq);
+	init->offset += 7;
+
+	init_prog_pll(init, reg, freq);
+}
+
 /**
  * INIT_ZM_REG_INDIRECT - opcode 0x5a
  *
@@ -2167,7 +2183,7 @@ static struct nvbios_init_opcode {
 	[0x56] = { init_condition_time },
 	[0x57] = { init_ltime },
 	[0x58] = { init_zm_reg_sequence },
-	[0x59] = { init_reserved },
+	[0x59] = { init_pll_indirect },
 	[0x5a] = { init_zm_reg_indirect },
 	[0x5b] = { init_sub_direct },
 	[0x5c] = { init_jump },

commit 360ccb8436ce83b9c25f969cee7b1b607899063b
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Thu Jun 18 23:59:06 2015 -0400

    drm/nouveau/bios: add 0x59 and 0x5a opcodes
    
    Opcode 0x5a is a register write for data looked up from another part of
    the VBIOS image. 0x59 is a more complex opcode, but we may as well
    recognize it. These occur on a single known instance of Riva TNT2
    hardware.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=91025
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index f67cdae1e90a..1f590f839f76 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -577,6 +577,9 @@ init_reserved(struct nvbios_init *init)
 	u8 length, i;
 
 	switch (opcode) {
+	case 0x59:
+		length = 7;
+		break;
 	case 0xaa:
 		length = 4;
 		break;
@@ -1284,6 +1287,25 @@ init_zm_reg_sequence(struct nvbios_init *init)
 	}
 }
 
+/**
+ * INIT_ZM_REG_INDIRECT - opcode 0x5a
+ *
+ */
+static void
+init_zm_reg_indirect(struct nvbios_init *init)
+{
+	struct nvkm_bios *bios = init->bios;
+	u32  reg = nv_ro32(bios, init->offset + 1);
+	u16 addr = nv_ro16(bios, init->offset + 5);
+	u32 data = nv_ro32(bios, addr);
+
+	trace("ZM_REG_INDIRECT\tR[0x%06x] = VBIOS[0x%04x] = 0x%08x\n",
+	      reg, addr, data);
+	init->offset += 7;
+
+	init_wr32(init, addr, data);
+}
+
 /**
  * INIT_SUB_DIRECT - opcode 0x5b
  *
@@ -2145,6 +2167,8 @@ static struct nvbios_init_opcode {
 	[0x56] = { init_condition_time },
 	[0x57] = { init_ltime },
 	[0x58] = { init_zm_reg_sequence },
+	[0x59] = { init_reserved },
+	[0x5a] = { init_zm_reg_indirect },
 	[0x5b] = { init_sub_direct },
 	[0x5c] = { init_jump },
 	[0x5e] = { init_i2c_if },

commit b9ec14246dc4260294ccfb25ec40b113d23e5b9a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:04:16 2015 +1000

    drm/nouveau/i2c: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index 63c9607a0116..f67cdae1e90a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -30,6 +30,8 @@
 #include <subdev/bios/gpio.h>
 #include <subdev/bios/init.h>
 #include <subdev/bios/ramcfg.h>
+
+#include <core/device.h>
 #include <subdev/devinit.h>
 #include <subdev/gpio.h>
 #include <subdev/i2c.h>

commit d390b48027f886c9b8c60a4578044958f517047d
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 14:40:03 2015 +1000

    drm/nouveau/bios: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
index c6579ef32cd1..63c9607a0116 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -1,9 +1,29 @@
-#include <core/engine.h>
-#include <core/device.h>
-
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
 #include <subdev/bios.h>
-#include <subdev/bios/bmp.h>
 #include <subdev/bios/bit.h>
+#include <subdev/bios/bmp.h>
 #include <subdev/bios/conn.h>
 #include <subdev/bios/dcb.h>
 #include <subdev/bios/dp.h>
@@ -11,9 +31,9 @@
 #include <subdev/bios/init.h>
 #include <subdev/bios/ramcfg.h>
 #include <subdev/devinit.h>
+#include <subdev/gpio.h>
 #include <subdev/i2c.h>
 #include <subdev/vga.h>
-#include <subdev/gpio.h>
 
 #define bioslog(lvl, fmt, args...) do {                                        \
 	nv_printk(init->bios, lvl, "0x%04x[%c]: "fmt, init->offset,            \
@@ -97,7 +117,7 @@ init_crtc(struct nvbios_init *init)
 static u8
 init_conn(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	struct nvbios_connE connE;
 	u8  ver, hdr;
 	u32 conn;
@@ -119,7 +139,7 @@ init_conn(struct nvbios_init *init)
 static inline u32
 init_nvreg(struct nvbios_init *init, u32 reg)
 {
-	struct nouveau_devinit *devinit = nouveau_devinit(init->bios);
+	struct nvkm_devinit *devinit = nvkm_devinit(init->bios);
 
 	/* C51 (at least) sometimes has the lower bits set which the VBIOS
 	 * interprets to mean that access needs to go through certain IO
@@ -203,7 +223,7 @@ init_wrport(struct nvbios_init *init, u16 port, u8 value)
 static u8
 init_rdvgai(struct nvbios_init *init, u16 port, u8 index)
 {
-	struct nouveau_subdev *subdev = init->subdev;
+	struct nvkm_subdev *subdev = init->subdev;
 	if (init_exec(init)) {
 		int head = init->crtc < 0 ? 0 : init->crtc;
 		return nv_rdvgai(subdev, head, port, index);
@@ -232,10 +252,10 @@ init_wrvgai(struct nvbios_init *init, u16 port, u8 index, u8 value)
 	}
 }
 
-static struct nouveau_i2c_port *
+static struct nvkm_i2c_port *
 init_i2c(struct nvbios_init *init, int index)
 {
-	struct nouveau_i2c *i2c = nouveau_i2c(init->bios);
+	struct nvkm_i2c *i2c = nvkm_i2c(init->bios);
 
 	if (index == 0xff) {
 		index = NV_I2C_DEFAULT(0);
@@ -265,7 +285,7 @@ init_i2c(struct nvbios_init *init, int index)
 static int
 init_rdi2cr(struct nvbios_init *init, u8 index, u8 addr, u8 reg)
 {
-	struct nouveau_i2c_port *port = init_i2c(init, index);
+	struct nvkm_i2c_port *port = init_i2c(init, index);
 	if (port && init_exec(init))
 		return nv_rdi2cr(port, addr, reg);
 	return -ENODEV;
@@ -274,7 +294,7 @@ init_rdi2cr(struct nvbios_init *init, u8 index, u8 addr, u8 reg)
 static int
 init_wri2cr(struct nvbios_init *init, u8 index, u8 addr, u8 reg, u8 val)
 {
-	struct nouveau_i2c_port *port = init_i2c(init, index);
+	struct nvkm_i2c_port *port = init_i2c(init, index);
 	if (port && init_exec(init))
 		return nv_wri2cr(port, addr, reg, val);
 	return -ENODEV;
@@ -283,7 +303,7 @@ init_wri2cr(struct nvbios_init *init, u8 index, u8 addr, u8 reg, u8 val)
 static u8
 init_rdauxr(struct nvbios_init *init, u32 addr)
 {
-	struct nouveau_i2c_port *port = init_i2c(init, -2);
+	struct nvkm_i2c_port *port = init_i2c(init, -2);
 	u8 data;
 
 	if (port && init_exec(init)) {
@@ -299,7 +319,7 @@ init_rdauxr(struct nvbios_init *init, u32 addr)
 static int
 init_wrauxr(struct nvbios_init *init, u32 addr, u8 data)
 {
-	struct nouveau_i2c_port *port = init_i2c(init, -2);
+	struct nvkm_i2c_port *port = init_i2c(init, -2);
 	if (port && init_exec(init)) {
 		int ret = nv_wraux(port, addr, &data, 1);
 		if (ret)
@@ -312,7 +332,7 @@ init_wrauxr(struct nvbios_init *init, u32 addr, u8 data)
 static void
 init_prog_pll(struct nvbios_init *init, u32 id, u32 freq)
 {
-	struct nouveau_devinit *devinit = nouveau_devinit(init->bios);
+	struct nvkm_devinit *devinit = nvkm_devinit(init->bios);
 	if (devinit->pll_set && init_exec(init)) {
 		int ret = devinit->pll_set(devinit, id, freq);
 		if (ret)
@@ -325,7 +345,7 @@ init_prog_pll(struct nvbios_init *init, u32 id, u32 freq)
  *****************************************************************************/
 
 static u16
-init_table(struct nouveau_bios *bios, u16 *len)
+init_table(struct nvkm_bios *bios, u16 *len)
 {
 	struct bit_entry bit_I;
 
@@ -345,7 +365,7 @@ init_table(struct nouveau_bios *bios, u16 *len)
 static u16
 init_table_(struct nvbios_init *init, u16 offset, const char *name)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u16 len, data = init_table(bios, &len);
 	if (data) {
 		if (len >= offset + 2) {
@@ -375,7 +395,7 @@ init_table_(struct nvbios_init *init, u16 offset, const char *name)
 #define init_xlat_table(b) init_table_((b), 0x10, "xlat table");
 
 static u16
-init_script(struct nouveau_bios *bios, int index)
+init_script(struct nvkm_bios *bios, int index)
 {
 	struct nvbios_init init = { .bios = bios };
 	u16 bmp_ver = bmp_version(bios), data;
@@ -396,7 +416,7 @@ init_script(struct nouveau_bios *bios, int index)
 }
 
 static u16
-init_unknown_script(struct nouveau_bios *bios)
+init_unknown_script(struct nvkm_bios *bios)
 {
 	u16 len, data = init_table(bios, &len);
 	if (data && len >= 16)
@@ -429,7 +449,7 @@ init_ram_restrict(struct nvbios_init *init)
 static u8
 init_xlat_(struct nvbios_init *init, u8 index, u8 offset)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u16 table = init_xlat_table(init);
 	if (table) {
 		u16 data = nv_ro16(bios, table + (index * 2));
@@ -447,7 +467,7 @@ init_xlat_(struct nvbios_init *init, u8 index, u8 offset)
 static bool
 init_condition_met(struct nvbios_init *init, u8 cond)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u16 table = init_condition_table(init);
 	if (table) {
 		u32 reg = nv_ro32(bios, table + (cond * 12) + 0);
@@ -463,7 +483,7 @@ init_condition_met(struct nvbios_init *init, u8 cond)
 static bool
 init_io_condition_met(struct nvbios_init *init, u8 cond)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u16 table = init_io_condition_table(init);
 	if (table) {
 		u16 port = nv_ro16(bios, table + (cond * 5) + 0);
@@ -480,7 +500,7 @@ init_io_condition_met(struct nvbios_init *init, u8 cond)
 static bool
 init_io_flag_condition_met(struct nvbios_init *init, u8 cond)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u16 table = init_io_flag_condition_table(init);
 	if (table) {
 		u16 port = nv_ro16(bios, table + (cond * 9) + 0);
@@ -515,7 +535,6 @@ init_tmds_reg(struct nvbios_init *init, u8 tmds)
 	 * CR58 for CR57 = 0 to index a table of offsets to the basic
 	 * 0x6808b0 address, and then flip the offset by 8.
 	 */
-
 	const int pramdac_offset[13] = {
 		0, 0, 0x8, 0, 0x2000, 0, 0, 0, 0x2008, 0, 0, 0, 0x2000 };
 	const u32 pramdac_table[4] = {
@@ -589,7 +608,7 @@ init_done(struct nvbios_init *init)
 static void
 init_io_restrict_prog(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u16 port = nv_ro16(bios, init->offset + 1);
 	u8 index = nv_ro08(bios, init->offset + 3);
 	u8  mask = nv_ro08(bios, init->offset + 4);
@@ -626,7 +645,7 @@ init_io_restrict_prog(struct nvbios_init *init)
 static void
 init_repeat(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8 count = nv_ro08(bios, init->offset + 1);
 	u16 repeat = init->repeat;
 
@@ -652,7 +671,7 @@ init_repeat(struct nvbios_init *init)
 static void
 init_io_restrict_pll(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u16 port = nv_ro16(bios, init->offset + 1);
 	u8 index = nv_ro08(bios, init->offset + 3);
 	u8  mask = nv_ro08(bios, init->offset + 4);
@@ -708,7 +727,7 @@ init_end_repeat(struct nvbios_init *init)
 static void
 init_copy(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32  reg = nv_ro32(bios, init->offset + 1);
 	u8 shift = nv_ro08(bios, init->offset + 5);
 	u8 smask = nv_ro08(bios, init->offset + 6);
@@ -747,7 +766,7 @@ init_not(struct nvbios_init *init)
 static void
 init_io_flag_condition(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8 cond = nv_ro08(bios, init->offset + 1);
 
 	trace("IO_FLAG_CONDITION\t0x%02x\n", cond);
@@ -764,7 +783,7 @@ init_io_flag_condition(struct nvbios_init *init)
 static void
 init_dp_condition(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	struct nvbios_dpout info;
 	u8  cond = nv_ro08(bios, init->offset + 1);
 	u8  unkn = nv_ro08(bios, init->offset + 2);
@@ -812,7 +831,7 @@ init_dp_condition(struct nvbios_init *init)
 static void
 init_io_mask_or(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8 index = nv_ro08(bios, init->offset + 1);
 	u8    or = init_or(init);
 	u8  data;
@@ -831,7 +850,7 @@ init_io_mask_or(struct nvbios_init *init)
 static void
 init_io_or(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8 index = nv_ro08(bios, init->offset + 1);
 	u8    or = init_or(init);
 	u8  data;
@@ -850,7 +869,7 @@ init_io_or(struct nvbios_init *init)
 static void
 init_andn_reg(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32  reg = nv_ro32(bios, init->offset + 1);
 	u32 mask = nv_ro32(bios, init->offset + 5);
 
@@ -867,7 +886,7 @@ init_andn_reg(struct nvbios_init *init)
 static void
 init_or_reg(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32  reg = nv_ro32(bios, init->offset + 1);
 	u32 mask = nv_ro32(bios, init->offset + 5);
 
@@ -884,7 +903,7 @@ init_or_reg(struct nvbios_init *init)
 static void
 init_idx_addr_latched(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32 creg = nv_ro32(bios, init->offset + 1);
 	u32 dreg = nv_ro32(bios, init->offset + 5);
 	u32 mask = nv_ro32(bios, init->offset + 9);
@@ -914,7 +933,7 @@ init_idx_addr_latched(struct nvbios_init *init)
 static void
 init_io_restrict_pll2(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u16 port = nv_ro16(bios, init->offset + 1);
 	u8 index = nv_ro08(bios, init->offset + 3);
 	u8  mask = nv_ro08(bios, init->offset + 4);
@@ -949,7 +968,7 @@ init_io_restrict_pll2(struct nvbios_init *init)
 static void
 init_pll2(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32  reg = nv_ro32(bios, init->offset + 1);
 	u32 freq = nv_ro32(bios, init->offset + 5);
 
@@ -966,7 +985,7 @@ init_pll2(struct nvbios_init *init)
 static void
 init_i2c_byte(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8 index = nv_ro08(bios, init->offset + 1);
 	u8  addr = nv_ro08(bios, init->offset + 2) >> 1;
 	u8 count = nv_ro08(bios, init->offset + 3);
@@ -997,7 +1016,7 @@ init_i2c_byte(struct nvbios_init *init)
 static void
 init_zm_i2c_byte(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8 index = nv_ro08(bios, init->offset + 1);
 	u8  addr = nv_ro08(bios, init->offset + 2) >> 1;
 	u8 count = nv_ro08(bios, init->offset + 3);
@@ -1014,7 +1033,6 @@ init_zm_i2c_byte(struct nvbios_init *init)
 
 		init_wri2cr(init, index, addr, reg, data);
 	}
-
 }
 
 /**
@@ -1024,7 +1042,7 @@ init_zm_i2c_byte(struct nvbios_init *init)
 static void
 init_zm_i2c(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8 index = nv_ro08(bios, init->offset + 1);
 	u8  addr = nv_ro08(bios, init->offset + 2) >> 1;
 	u8 count = nv_ro08(bios, init->offset + 3);
@@ -1040,7 +1058,7 @@ init_zm_i2c(struct nvbios_init *init)
 	}
 
 	if (init_exec(init)) {
-		struct nouveau_i2c_port *port = init_i2c(init, index);
+		struct nvkm_i2c_port *port = init_i2c(init, index);
 		struct i2c_msg msg = {
 			.addr = addr, .flags = 0, .len = count, .buf = data,
 		};
@@ -1058,7 +1076,7 @@ init_zm_i2c(struct nvbios_init *init)
 static void
 init_tmds(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8 tmds = nv_ro08(bios, init->offset + 1);
 	u8 addr = nv_ro08(bios, init->offset + 2);
 	u8 mask = nv_ro08(bios, init->offset + 3);
@@ -1084,7 +1102,7 @@ init_tmds(struct nvbios_init *init)
 static void
 init_zm_tmds_group(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8  tmds = nv_ro08(bios, init->offset + 1);
 	u8 count = nv_ro08(bios, init->offset + 2);
 	u32  reg = init_tmds_reg(init, tmds);
@@ -1111,7 +1129,7 @@ init_zm_tmds_group(struct nvbios_init *init)
 static void
 init_cr_idx_adr_latch(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8 addr0 = nv_ro08(bios, init->offset + 1);
 	u8 addr1 = nv_ro08(bios, init->offset + 2);
 	u8  base = nv_ro08(bios, init->offset + 3);
@@ -1141,7 +1159,7 @@ init_cr_idx_adr_latch(struct nvbios_init *init)
 static void
 init_cr(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8 addr = nv_ro08(bios, init->offset + 1);
 	u8 mask = nv_ro08(bios, init->offset + 2);
 	u8 data = nv_ro08(bios, init->offset + 3);
@@ -1161,7 +1179,7 @@ init_cr(struct nvbios_init *init)
 static void
 init_zm_cr(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8 addr = nv_ro08(bios, init->offset + 1);
 	u8 data = nv_ro08(bios, init->offset + 2);
 
@@ -1178,7 +1196,7 @@ init_zm_cr(struct nvbios_init *init)
 static void
 init_zm_cr_group(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8 count = nv_ro08(bios, init->offset + 1);
 
 	trace("ZM_CR_GROUP\n");
@@ -1202,7 +1220,7 @@ init_zm_cr_group(struct nvbios_init *init)
 static void
 init_condition_time(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8  cond = nv_ro08(bios, init->offset + 1);
 	u8 retry = nv_ro08(bios, init->offset + 2);
 	u8  wait = min((u16)retry * 50, 100);
@@ -1229,7 +1247,7 @@ init_condition_time(struct nvbios_init *init)
 static void
 init_ltime(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u16 msec = nv_ro16(bios, init->offset + 1);
 
 	trace("LTIME\t0x%04x\n", msec);
@@ -1246,7 +1264,7 @@ init_ltime(struct nvbios_init *init)
 static void
 init_zm_reg_sequence(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32 base = nv_ro32(bios, init->offset + 1);
 	u8 count = nv_ro08(bios, init->offset + 5);
 
@@ -1271,7 +1289,7 @@ init_zm_reg_sequence(struct nvbios_init *init)
 static void
 init_sub_direct(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u16 addr = nv_ro16(bios, init->offset + 1);
 	u16 save;
 
@@ -1297,7 +1315,7 @@ init_sub_direct(struct nvbios_init *init)
 static void
 init_jump(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u16 offset = nv_ro16(bios, init->offset + 1);
 
 	trace("JUMP\t0x%04x\n", offset);
@@ -1315,7 +1333,7 @@ init_jump(struct nvbios_init *init)
 static void
 init_i2c_if(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8 index = nv_ro08(bios, init->offset + 1);
 	u8  addr = nv_ro08(bios, init->offset + 2);
 	u8   reg = nv_ro08(bios, init->offset + 3);
@@ -1342,7 +1360,7 @@ init_i2c_if(struct nvbios_init *init)
 static void
 init_copy_nv_reg(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32  sreg = nv_ro32(bios, init->offset + 1);
 	u8  shift = nv_ro08(bios, init->offset + 5);
 	u32 smask = nv_ro32(bios, init->offset + 6);
@@ -1368,7 +1386,7 @@ init_copy_nv_reg(struct nvbios_init *init)
 static void
 init_zm_index_io(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u16 port = nv_ro16(bios, init->offset + 1);
 	u8 index = nv_ro08(bios, init->offset + 3);
 	u8  data = nv_ro08(bios, init->offset + 4);
@@ -1386,7 +1404,7 @@ init_zm_index_io(struct nvbios_init *init)
 static void
 init_compute_mem(struct nvbios_init *init)
 {
-	struct nouveau_devinit *devinit = nouveau_devinit(init->bios);
+	struct nvkm_devinit *devinit = nvkm_devinit(init->bios);
 
 	trace("COMPUTE_MEM\n");
 	init->offset += 1;
@@ -1404,7 +1422,7 @@ init_compute_mem(struct nvbios_init *init)
 static void
 init_reset(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32   reg = nv_ro32(bios, init->offset + 1);
 	u32 data1 = nv_ro32(bios, init->offset + 5);
 	u32 data2 = nv_ro32(bios, init->offset + 9);
@@ -1440,7 +1458,7 @@ init_configure_mem_clk(struct nvbios_init *init)
 static void
 init_configure_mem(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u16 mdata, sdata;
 	u32 addr, data;
 
@@ -1490,7 +1508,7 @@ init_configure_mem(struct nvbios_init *init)
 static void
 init_configure_clk(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u16 mdata, clock;
 
 	trace("CONFIGURE_CLK\n");
@@ -1524,7 +1542,7 @@ init_configure_clk(struct nvbios_init *init)
 static void
 init_configure_preinit(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32 strap;
 
 	trace("CONFIGURE_PREINIT\n");
@@ -1550,7 +1568,7 @@ init_configure_preinit(struct nvbios_init *init)
 static void
 init_io(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u16 port = nv_ro16(bios, init->offset + 1);
 	u8  mask = nv_ro16(bios, init->offset + 3);
 	u8  data = nv_ro16(bios, init->offset + 4);
@@ -1590,7 +1608,7 @@ init_io(struct nvbios_init *init)
 static void
 init_sub(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8 index = nv_ro08(bios, init->offset + 1);
 	u16 addr, save;
 
@@ -1617,7 +1635,7 @@ init_sub(struct nvbios_init *init)
 static void
 init_ram_condition(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8  mask = nv_ro08(bios, init->offset + 1);
 	u8 value = nv_ro08(bios, init->offset + 2);
 
@@ -1636,7 +1654,7 @@ init_ram_condition(struct nvbios_init *init)
 static void
 init_nv_reg(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32  reg = nv_ro32(bios, init->offset + 1);
 	u32 mask = nv_ro32(bios, init->offset + 5);
 	u32 data = nv_ro32(bios, init->offset + 9);
@@ -1654,7 +1672,7 @@ init_nv_reg(struct nvbios_init *init)
 static void
 init_macro(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8  macro = nv_ro08(bios, init->offset + 1);
 	u16 table;
 
@@ -1690,7 +1708,7 @@ init_resume(struct nvbios_init *init)
 static void
 init_time(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u16 usec = nv_ro16(bios, init->offset + 1);
 
 	trace("TIME\t0x%04x\n", usec);
@@ -1711,7 +1729,7 @@ init_time(struct nvbios_init *init)
 static void
 init_condition(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8 cond = nv_ro08(bios, init->offset + 1);
 
 	trace("CONDITION\t0x%02x\n", cond);
@@ -1728,7 +1746,7 @@ init_condition(struct nvbios_init *init)
 static void
 init_io_condition(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8 cond = nv_ro08(bios, init->offset + 1);
 
 	trace("IO_CONDITION\t0x%02x\n", cond);
@@ -1745,7 +1763,7 @@ init_io_condition(struct nvbios_init *init)
 static void
 init_index_io(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u16 port = nv_ro16(bios, init->offset + 1);
 	u8 index = nv_ro16(bios, init->offset + 3);
 	u8  mask = nv_ro08(bios, init->offset + 4);
@@ -1767,7 +1785,7 @@ init_index_io(struct nvbios_init *init)
 static void
 init_pll(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32  reg = nv_ro32(bios, init->offset + 1);
 	u32 freq = nv_ro16(bios, init->offset + 5) * 10;
 
@@ -1784,7 +1802,7 @@ init_pll(struct nvbios_init *init)
 static void
 init_zm_reg(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32 addr = nv_ro32(bios, init->offset + 1);
 	u32 data = nv_ro32(bios, init->offset + 5);
 
@@ -1804,7 +1822,7 @@ init_zm_reg(struct nvbios_init *init)
 static void
 init_ram_restrict_pll(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8  type = nv_ro08(bios, init->offset + 1);
 	u8 count = init_ram_restrict_group_count(init);
 	u8 strap = init_ram_restrict(init);
@@ -1834,7 +1852,7 @@ init_ram_restrict_pll(struct nvbios_init *init)
 static void
 init_gpio(struct nvbios_init *init)
 {
-	struct nouveau_gpio *gpio = nouveau_gpio(init->bios);
+	struct nvkm_gpio *gpio = nvkm_gpio(init->bios);
 
 	trace("GPIO\n");
 	init->offset += 1;
@@ -1850,7 +1868,7 @@ init_gpio(struct nvbios_init *init)
 static void
 init_ram_restrict_zm_reg_group(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32 addr = nv_ro32(bios, init->offset + 1);
 	u8  incr = nv_ro08(bios, init->offset + 5);
 	u8   num = nv_ro08(bios, init->offset + 6);
@@ -1888,7 +1906,7 @@ init_ram_restrict_zm_reg_group(struct nvbios_init *init)
 static void
 init_copy_zm_reg(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32 sreg = nv_ro32(bios, init->offset + 1);
 	u32 dreg = nv_ro32(bios, init->offset + 5);
 
@@ -1905,7 +1923,7 @@ init_copy_zm_reg(struct nvbios_init *init)
 static void
 init_zm_reg_group(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32 addr = nv_ro32(bios, init->offset + 1);
 	u8 count = nv_ro08(bios, init->offset + 5);
 
@@ -1927,7 +1945,7 @@ init_zm_reg_group(struct nvbios_init *init)
 static void
 init_xlat(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32 saddr = nv_ro32(bios, init->offset + 1);
 	u8 sshift = nv_ro08(bios, init->offset + 5);
 	u8  smask = nv_ro08(bios, init->offset + 6);
@@ -1955,7 +1973,7 @@ init_xlat(struct nvbios_init *init)
 static void
 init_zm_mask_add(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32 addr = nv_ro32(bios, init->offset + 1);
 	u32 mask = nv_ro32(bios, init->offset + 5);
 	u32  add = nv_ro32(bios, init->offset + 9);
@@ -1976,7 +1994,7 @@ init_zm_mask_add(struct nvbios_init *init)
 static void
 init_auxch(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32 addr = nv_ro32(bios, init->offset + 1);
 	u8 count = nv_ro08(bios, init->offset + 5);
 
@@ -2000,7 +2018,7 @@ init_auxch(struct nvbios_init *init)
 static void
 init_zm_auxch(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u32 addr = nv_ro32(bios, init->offset + 1);
 	u8 count = nv_ro08(bios, init->offset + 5);
 
@@ -2022,14 +2040,14 @@ init_zm_auxch(struct nvbios_init *init)
 static void
 init_i2c_long_if(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
+	struct nvkm_bios *bios = init->bios;
 	u8 index = nv_ro08(bios, init->offset + 1);
 	u8  addr = nv_ro08(bios, init->offset + 2) >> 1;
 	u8 reglo = nv_ro08(bios, init->offset + 3);
 	u8 reghi = nv_ro08(bios, init->offset + 4);
 	u8  mask = nv_ro08(bios, init->offset + 5);
 	u8  data = nv_ro08(bios, init->offset + 6);
-	struct nouveau_i2c_port *port;
+	struct nvkm_i2c_port *port;
 
 	trace("I2C_LONG_IF\t"
 	      "I2C[0x%02x][0x%02x][0x%02x%02x] & 0x%02x == 0x%02x\n",
@@ -2061,8 +2079,8 @@ init_i2c_long_if(struct nvbios_init *init)
 static void
 init_gpio_ne(struct nvbios_init *init)
 {
-	struct nouveau_bios *bios = init->bios;
-	struct nouveau_gpio *gpio = nouveau_gpio(bios);
+	struct nvkm_bios *bios = init->bios;
+	struct nvkm_gpio *gpio = nvkm_gpio(bios);
 	struct dcb_gpio_func func;
 	u8 count = nv_ro08(bios, init->offset + 1);
 	u8 idx = 0, ver, len;
@@ -2185,9 +2203,9 @@ nvbios_exec(struct nvbios_init *init)
 }
 
 int
-nvbios_init(struct nouveau_subdev *subdev, bool execute)
+nvbios_init(struct nvkm_subdev *subdev, bool execute)
 {
-	struct nouveau_bios *bios = nouveau_bios(subdev);
+	struct nvkm_bios *bios = nvkm_bios(subdev);
 	int ret = 0;
 	int i = -1;
 	u16 data;

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
new file mode 100644
index 000000000000..c6579ef32cd1
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c
@@ -0,0 +1,2227 @@
+#include <core/engine.h>
+#include <core/device.h>
+
+#include <subdev/bios.h>
+#include <subdev/bios/bmp.h>
+#include <subdev/bios/bit.h>
+#include <subdev/bios/conn.h>
+#include <subdev/bios/dcb.h>
+#include <subdev/bios/dp.h>
+#include <subdev/bios/gpio.h>
+#include <subdev/bios/init.h>
+#include <subdev/bios/ramcfg.h>
+#include <subdev/devinit.h>
+#include <subdev/i2c.h>
+#include <subdev/vga.h>
+#include <subdev/gpio.h>
+
+#define bioslog(lvl, fmt, args...) do {                                        \
+	nv_printk(init->bios, lvl, "0x%04x[%c]: "fmt, init->offset,            \
+		  init_exec(init) ? '0' + (init->nested - 1) : ' ', ##args);   \
+} while(0)
+#define cont(fmt, args...) do {                                                \
+	if (nv_subdev(init->bios)->debug >= NV_DBG_TRACE)                      \
+		printk(fmt, ##args);                                           \
+} while(0)
+#define trace(fmt, args...) bioslog(TRACE, fmt, ##args)
+#define warn(fmt, args...) bioslog(WARN, fmt, ##args)
+#define error(fmt, args...) bioslog(ERROR, fmt, ##args)
+
+/******************************************************************************
+ * init parser control flow helpers
+ *****************************************************************************/
+
+static inline bool
+init_exec(struct nvbios_init *init)
+{
+	return (init->execute == 1) || ((init->execute & 5) == 5);
+}
+
+static inline void
+init_exec_set(struct nvbios_init *init, bool exec)
+{
+	if (exec) init->execute &= 0xfd;
+	else      init->execute |= 0x02;
+}
+
+static inline void
+init_exec_inv(struct nvbios_init *init)
+{
+	init->execute ^= 0x02;
+}
+
+static inline void
+init_exec_force(struct nvbios_init *init, bool exec)
+{
+	if (exec) init->execute |= 0x04;
+	else      init->execute &= 0xfb;
+}
+
+/******************************************************************************
+ * init parser wrappers for normal register/i2c/whatever accessors
+ *****************************************************************************/
+
+static inline int
+init_or(struct nvbios_init *init)
+{
+	if (init_exec(init)) {
+		if (init->outp)
+			return ffs(init->outp->or) - 1;
+		error("script needs OR!!\n");
+	}
+	return 0;
+}
+
+static inline int
+init_link(struct nvbios_init *init)
+{
+	if (init_exec(init)) {
+		if (init->outp)
+			return !(init->outp->sorconf.link & 1);
+		error("script needs OR link\n");
+	}
+	return 0;
+}
+
+static inline int
+init_crtc(struct nvbios_init *init)
+{
+	if (init_exec(init)) {
+		if (init->crtc >= 0)
+			return init->crtc;
+		error("script needs crtc\n");
+	}
+	return 0;
+}
+
+static u8
+init_conn(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	struct nvbios_connE connE;
+	u8  ver, hdr;
+	u32 conn;
+
+	if (init_exec(init)) {
+		if (init->outp) {
+			conn = init->outp->connector;
+			conn = nvbios_connEp(bios, conn, &ver, &hdr, &connE);
+			if (conn)
+				return connE.type;
+		}
+
+		error("script needs connector type\n");
+	}
+
+	return 0xff;
+}
+
+static inline u32
+init_nvreg(struct nvbios_init *init, u32 reg)
+{
+	struct nouveau_devinit *devinit = nouveau_devinit(init->bios);
+
+	/* C51 (at least) sometimes has the lower bits set which the VBIOS
+	 * interprets to mean that access needs to go through certain IO
+	 * ports instead.  The NVIDIA binary driver has been seen to access
+	 * these through the NV register address, so lets assume we can
+	 * do the same
+	 */
+	reg &= ~0x00000003;
+
+	/* GF8+ display scripts need register addresses mangled a bit to
+	 * select a specific CRTC/OR
+	 */
+	if (nv_device(init->bios)->card_type >= NV_50) {
+		if (reg & 0x80000000) {
+			reg += init_crtc(init) * 0x800;
+			reg &= ~0x80000000;
+		}
+
+		if (reg & 0x40000000) {
+			reg += init_or(init) * 0x800;
+			reg &= ~0x40000000;
+			if (reg & 0x20000000) {
+				reg += init_link(init) * 0x80;
+				reg &= ~0x20000000;
+			}
+		}
+	}
+
+	if (reg & ~0x00fffffc)
+		warn("unknown bits in register 0x%08x\n", reg);
+
+	if (devinit->mmio)
+		reg = devinit->mmio(devinit, reg);
+	return reg;
+}
+
+static u32
+init_rd32(struct nvbios_init *init, u32 reg)
+{
+	reg = init_nvreg(init, reg);
+	if (reg != ~0 && init_exec(init))
+		return nv_rd32(init->subdev, reg);
+	return 0x00000000;
+}
+
+static void
+init_wr32(struct nvbios_init *init, u32 reg, u32 val)
+{
+	reg = init_nvreg(init, reg);
+	if (reg != ~0 && init_exec(init))
+		nv_wr32(init->subdev, reg, val);
+}
+
+static u32
+init_mask(struct nvbios_init *init, u32 reg, u32 mask, u32 val)
+{
+	reg = init_nvreg(init, reg);
+	if (reg != ~0 && init_exec(init)) {
+		u32 tmp = nv_rd32(init->subdev, reg);
+		nv_wr32(init->subdev, reg, (tmp & ~mask) | val);
+		return tmp;
+	}
+	return 0x00000000;
+}
+
+static u8
+init_rdport(struct nvbios_init *init, u16 port)
+{
+	if (init_exec(init))
+		return nv_rdport(init->subdev, init->crtc, port);
+	return 0x00;
+}
+
+static void
+init_wrport(struct nvbios_init *init, u16 port, u8 value)
+{
+	if (init_exec(init))
+		nv_wrport(init->subdev, init->crtc, port, value);
+}
+
+static u8
+init_rdvgai(struct nvbios_init *init, u16 port, u8 index)
+{
+	struct nouveau_subdev *subdev = init->subdev;
+	if (init_exec(init)) {
+		int head = init->crtc < 0 ? 0 : init->crtc;
+		return nv_rdvgai(subdev, head, port, index);
+	}
+	return 0x00;
+}
+
+static void
+init_wrvgai(struct nvbios_init *init, u16 port, u8 index, u8 value)
+{
+	/* force head 0 for updates to cr44, it only exists on first head */
+	if (nv_device(init->subdev)->card_type < NV_50) {
+		if (port == 0x03d4 && index == 0x44)
+			init->crtc = 0;
+	}
+
+	if (init_exec(init)) {
+		int head = init->crtc < 0 ? 0 : init->crtc;
+		nv_wrvgai(init->subdev, head, port, index, value);
+	}
+
+	/* select head 1 if cr44 write selected it */
+	if (nv_device(init->subdev)->card_type < NV_50) {
+		if (port == 0x03d4 && index == 0x44 && value == 3)
+			init->crtc = 1;
+	}
+}
+
+static struct nouveau_i2c_port *
+init_i2c(struct nvbios_init *init, int index)
+{
+	struct nouveau_i2c *i2c = nouveau_i2c(init->bios);
+
+	if (index == 0xff) {
+		index = NV_I2C_DEFAULT(0);
+		if (init->outp && init->outp->i2c_upper_default)
+			index = NV_I2C_DEFAULT(1);
+	} else
+	if (index < 0) {
+		if (!init->outp) {
+			if (init_exec(init))
+				error("script needs output for i2c\n");
+			return NULL;
+		}
+
+		if (index == -2 && init->outp->location) {
+			index = NV_I2C_TYPE_EXTAUX(init->outp->extdev);
+			return i2c->find_type(i2c, index);
+		}
+
+		index = init->outp->i2c_index;
+		if (init->outp->type == DCB_OUTPUT_DP)
+			index += NV_I2C_AUX(0);
+	}
+
+	return i2c->find(i2c, index);
+}
+
+static int
+init_rdi2cr(struct nvbios_init *init, u8 index, u8 addr, u8 reg)
+{
+	struct nouveau_i2c_port *port = init_i2c(init, index);
+	if (port && init_exec(init))
+		return nv_rdi2cr(port, addr, reg);
+	return -ENODEV;
+}
+
+static int
+init_wri2cr(struct nvbios_init *init, u8 index, u8 addr, u8 reg, u8 val)
+{
+	struct nouveau_i2c_port *port = init_i2c(init, index);
+	if (port && init_exec(init))
+		return nv_wri2cr(port, addr, reg, val);
+	return -ENODEV;
+}
+
+static u8
+init_rdauxr(struct nvbios_init *init, u32 addr)
+{
+	struct nouveau_i2c_port *port = init_i2c(init, -2);
+	u8 data;
+
+	if (port && init_exec(init)) {
+		int ret = nv_rdaux(port, addr, &data, 1);
+		if (ret == 0)
+			return data;
+		trace("auxch read failed with %d\n", ret);
+	}
+
+	return 0x00;
+}
+
+static int
+init_wrauxr(struct nvbios_init *init, u32 addr, u8 data)
+{
+	struct nouveau_i2c_port *port = init_i2c(init, -2);
+	if (port && init_exec(init)) {
+		int ret = nv_wraux(port, addr, &data, 1);
+		if (ret)
+			trace("auxch write failed with %d\n", ret);
+		return ret;
+	}
+	return -ENODEV;
+}
+
+static void
+init_prog_pll(struct nvbios_init *init, u32 id, u32 freq)
+{
+	struct nouveau_devinit *devinit = nouveau_devinit(init->bios);
+	if (devinit->pll_set && init_exec(init)) {
+		int ret = devinit->pll_set(devinit, id, freq);
+		if (ret)
+			warn("failed to prog pll 0x%08x to %dkHz\n", id, freq);
+	}
+}
+
+/******************************************************************************
+ * parsing of bios structures that are required to execute init tables
+ *****************************************************************************/
+
+static u16
+init_table(struct nouveau_bios *bios, u16 *len)
+{
+	struct bit_entry bit_I;
+
+	if (!bit_entry(bios, 'I', &bit_I)) {
+		*len = bit_I.length;
+		return bit_I.offset;
+	}
+
+	if (bmp_version(bios) >= 0x0510) {
+		*len = 14;
+		return bios->bmp_offset + 75;
+	}
+
+	return 0x0000;
+}
+
+static u16
+init_table_(struct nvbios_init *init, u16 offset, const char *name)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 len, data = init_table(bios, &len);
+	if (data) {
+		if (len >= offset + 2) {
+			data = nv_ro16(bios, data + offset);
+			if (data)
+				return data;
+
+			warn("%s pointer invalid\n", name);
+			return 0x0000;
+		}
+
+		warn("init data too short for %s pointer", name);
+		return 0x0000;
+	}
+
+	warn("init data not found\n");
+	return 0x0000;
+}
+
+#define init_script_table(b) init_table_((b), 0x00, "script table")
+#define init_macro_index_table(b) init_table_((b), 0x02, "macro index table")
+#define init_macro_table(b) init_table_((b), 0x04, "macro table")
+#define init_condition_table(b) init_table_((b), 0x06, "condition table")
+#define init_io_condition_table(b) init_table_((b), 0x08, "io condition table")
+#define init_io_flag_condition_table(b) init_table_((b), 0x0a, "io flag conditon table")
+#define init_function_table(b) init_table_((b), 0x0c, "function table")
+#define init_xlat_table(b) init_table_((b), 0x10, "xlat table");
+
+static u16
+init_script(struct nouveau_bios *bios, int index)
+{
+	struct nvbios_init init = { .bios = bios };
+	u16 bmp_ver = bmp_version(bios), data;
+
+	if (bmp_ver && bmp_ver < 0x0510) {
+		if (index > 1 || bmp_ver < 0x0100)
+			return 0x0000;
+
+		data = bios->bmp_offset + (bmp_ver < 0x0200 ? 14 : 18);
+		return nv_ro16(bios, data + (index * 2));
+	}
+
+	data = init_script_table(&init);
+	if (data)
+		return nv_ro16(bios, data + (index * 2));
+
+	return 0x0000;
+}
+
+static u16
+init_unknown_script(struct nouveau_bios *bios)
+{
+	u16 len, data = init_table(bios, &len);
+	if (data && len >= 16)
+		return nv_ro16(bios, data + 14);
+	return 0x0000;
+}
+
+static u8
+init_ram_restrict_group_count(struct nvbios_init *init)
+{
+	return nvbios_ramcfg_count(init->bios);
+}
+
+static u8
+init_ram_restrict(struct nvbios_init *init)
+{
+	/* This appears to be the behaviour of the VBIOS parser, and *is*
+	 * important to cache the NV_PEXTDEV_BOOT0 on later chipsets to
+	 * avoid fucking up the memory controller (somehow) by reading it
+	 * on every INIT_RAM_RESTRICT_ZM_GROUP opcode.
+	 *
+	 * Preserving the non-caching behaviour on earlier chipsets just
+	 * in case *not* re-reading the strap causes similar breakage.
+	 */
+	if (!init->ramcfg || init->bios->version.major < 0x70)
+		init->ramcfg = 0x80000000 | nvbios_ramcfg_index(init->subdev);
+	return (init->ramcfg & 0x7fffffff);
+}
+
+static u8
+init_xlat_(struct nvbios_init *init, u8 index, u8 offset)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 table = init_xlat_table(init);
+	if (table) {
+		u16 data = nv_ro16(bios, table + (index * 2));
+		if (data)
+			return nv_ro08(bios, data + offset);
+		warn("xlat table pointer %d invalid\n", index);
+	}
+	return 0x00;
+}
+
+/******************************************************************************
+ * utility functions used by various init opcode handlers
+ *****************************************************************************/
+
+static bool
+init_condition_met(struct nvbios_init *init, u8 cond)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 table = init_condition_table(init);
+	if (table) {
+		u32 reg = nv_ro32(bios, table + (cond * 12) + 0);
+		u32 msk = nv_ro32(bios, table + (cond * 12) + 4);
+		u32 val = nv_ro32(bios, table + (cond * 12) + 8);
+		trace("\t[0x%02x] (R[0x%06x] & 0x%08x) == 0x%08x\n",
+		      cond, reg, msk, val);
+		return (init_rd32(init, reg) & msk) == val;
+	}
+	return false;
+}
+
+static bool
+init_io_condition_met(struct nvbios_init *init, u8 cond)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 table = init_io_condition_table(init);
+	if (table) {
+		u16 port = nv_ro16(bios, table + (cond * 5) + 0);
+		u8 index = nv_ro08(bios, table + (cond * 5) + 2);
+		u8  mask = nv_ro08(bios, table + (cond * 5) + 3);
+		u8 value = nv_ro08(bios, table + (cond * 5) + 4);
+		trace("\t[0x%02x] (0x%04x[0x%02x] & 0x%02x) == 0x%02x\n",
+		      cond, port, index, mask, value);
+		return (init_rdvgai(init, port, index) & mask) == value;
+	}
+	return false;
+}
+
+static bool
+init_io_flag_condition_met(struct nvbios_init *init, u8 cond)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 table = init_io_flag_condition_table(init);
+	if (table) {
+		u16 port = nv_ro16(bios, table + (cond * 9) + 0);
+		u8 index = nv_ro08(bios, table + (cond * 9) + 2);
+		u8  mask = nv_ro08(bios, table + (cond * 9) + 3);
+		u8 shift = nv_ro08(bios, table + (cond * 9) + 4);
+		u16 data = nv_ro16(bios, table + (cond * 9) + 5);
+		u8 dmask = nv_ro08(bios, table + (cond * 9) + 7);
+		u8 value = nv_ro08(bios, table + (cond * 9) + 8);
+		u8 ioval = (init_rdvgai(init, port, index) & mask) >> shift;
+		return (nv_ro08(bios, data + ioval) & dmask) == value;
+	}
+	return false;
+}
+
+static inline u32
+init_shift(u32 data, u8 shift)
+{
+	if (shift < 0x80)
+		return data >> shift;
+	return data << (0x100 - shift);
+}
+
+static u32
+init_tmds_reg(struct nvbios_init *init, u8 tmds)
+{
+	/* For mlv < 0x80, it is an index into a table of TMDS base addresses.
+	 * For mlv == 0x80 use the "or" value of the dcb_entry indexed by
+	 * CR58 for CR57 = 0 to index a table of offsets to the basic
+	 * 0x6808b0 address.
+	 * For mlv == 0x81 use the "or" value of the dcb_entry indexed by
+	 * CR58 for CR57 = 0 to index a table of offsets to the basic
+	 * 0x6808b0 address, and then flip the offset by 8.
+	 */
+
+	const int pramdac_offset[13] = {
+		0, 0, 0x8, 0, 0x2000, 0, 0, 0, 0x2008, 0, 0, 0, 0x2000 };
+	const u32 pramdac_table[4] = {
+		0x6808b0, 0x6808b8, 0x6828b0, 0x6828b8 };
+
+	if (tmds >= 0x80) {
+		if (init->outp) {
+			u32 dacoffset = pramdac_offset[init->outp->or];
+			if (tmds == 0x81)
+				dacoffset ^= 8;
+			return 0x6808b0 + dacoffset;
+		}
+
+		if (init_exec(init))
+			error("tmds opcodes need dcb\n");
+	} else {
+		if (tmds < ARRAY_SIZE(pramdac_table))
+			return pramdac_table[tmds];
+
+		error("tmds selector 0x%02x unknown\n", tmds);
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+ * init opcode handlers
+ *****************************************************************************/
+
+/**
+ * init_reserved - stub for various unknown/unused single-byte opcodes
+ *
+ */
+static void
+init_reserved(struct nvbios_init *init)
+{
+	u8 opcode = nv_ro08(init->bios, init->offset);
+	u8 length, i;
+
+	switch (opcode) {
+	case 0xaa:
+		length = 4;
+		break;
+	default:
+		length = 1;
+		break;
+	}
+
+	trace("RESERVED 0x%02x\t", opcode);
+	for (i = 1; i < length; i++)
+		cont(" 0x%02x", nv_ro08(init->bios, init->offset + i));
+	cont("\n");
+	init->offset += length;
+}
+
+/**
+ * INIT_DONE - opcode 0x71
+ *
+ */
+static void
+init_done(struct nvbios_init *init)
+{
+	trace("DONE\n");
+	init->offset = 0x0000;
+}
+
+/**
+ * INIT_IO_RESTRICT_PROG - opcode 0x32
+ *
+ */
+static void
+init_io_restrict_prog(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 port = nv_ro16(bios, init->offset + 1);
+	u8 index = nv_ro08(bios, init->offset + 3);
+	u8  mask = nv_ro08(bios, init->offset + 4);
+	u8 shift = nv_ro08(bios, init->offset + 5);
+	u8 count = nv_ro08(bios, init->offset + 6);
+	u32  reg = nv_ro32(bios, init->offset + 7);
+	u8 conf, i;
+
+	trace("IO_RESTRICT_PROG\tR[0x%06x] = "
+	      "((0x%04x[0x%02x] & 0x%02x) >> %d) [{\n",
+	      reg, port, index, mask, shift);
+	init->offset += 11;
+
+	conf = (init_rdvgai(init, port, index) & mask) >> shift;
+	for (i = 0; i < count; i++) {
+		u32 data = nv_ro32(bios, init->offset);
+
+		if (i == conf) {
+			trace("\t0x%08x *\n", data);
+			init_wr32(init, reg, data);
+		} else {
+			trace("\t0x%08x\n", data);
+		}
+
+		init->offset += 4;
+	}
+	trace("}]\n");
+}
+
+/**
+ * INIT_REPEAT - opcode 0x33
+ *
+ */
+static void
+init_repeat(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 count = nv_ro08(bios, init->offset + 1);
+	u16 repeat = init->repeat;
+
+	trace("REPEAT\t0x%02x\n", count);
+	init->offset += 2;
+
+	init->repeat = init->offset;
+	init->repend = init->offset;
+	while (count--) {
+		init->offset = init->repeat;
+		nvbios_exec(init);
+		if (count)
+			trace("REPEAT\t0x%02x\n", count);
+	}
+	init->offset = init->repend;
+	init->repeat = repeat;
+}
+
+/**
+ * INIT_IO_RESTRICT_PLL - opcode 0x34
+ *
+ */
+static void
+init_io_restrict_pll(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 port = nv_ro16(bios, init->offset + 1);
+	u8 index = nv_ro08(bios, init->offset + 3);
+	u8  mask = nv_ro08(bios, init->offset + 4);
+	u8 shift = nv_ro08(bios, init->offset + 5);
+	s8  iofc = nv_ro08(bios, init->offset + 6);
+	u8 count = nv_ro08(bios, init->offset + 7);
+	u32  reg = nv_ro32(bios, init->offset + 8);
+	u8 conf, i;
+
+	trace("IO_RESTRICT_PLL\tR[0x%06x] =PLL= "
+	      "((0x%04x[0x%02x] & 0x%02x) >> 0x%02x) IOFCOND 0x%02x [{\n",
+	      reg, port, index, mask, shift, iofc);
+	init->offset += 12;
+
+	conf = (init_rdvgai(init, port, index) & mask) >> shift;
+	for (i = 0; i < count; i++) {
+		u32 freq = nv_ro16(bios, init->offset) * 10;
+
+		if (i == conf) {
+			trace("\t%dkHz *\n", freq);
+			if (iofc > 0 && init_io_flag_condition_met(init, iofc))
+				freq *= 2;
+			init_prog_pll(init, reg, freq);
+		} else {
+			trace("\t%dkHz\n", freq);
+		}
+
+		init->offset += 2;
+	}
+	trace("}]\n");
+}
+
+/**
+ * INIT_END_REPEAT - opcode 0x36
+ *
+ */
+static void
+init_end_repeat(struct nvbios_init *init)
+{
+	trace("END_REPEAT\n");
+	init->offset += 1;
+
+	if (init->repeat) {
+		init->repend = init->offset;
+		init->offset = 0;
+	}
+}
+
+/**
+ * INIT_COPY - opcode 0x37
+ *
+ */
+static void
+init_copy(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32  reg = nv_ro32(bios, init->offset + 1);
+	u8 shift = nv_ro08(bios, init->offset + 5);
+	u8 smask = nv_ro08(bios, init->offset + 6);
+	u16 port = nv_ro16(bios, init->offset + 7);
+	u8 index = nv_ro08(bios, init->offset + 9);
+	u8  mask = nv_ro08(bios, init->offset + 10);
+	u8  data;
+
+	trace("COPY\t0x%04x[0x%02x] &= 0x%02x |= "
+	      "((R[0x%06x] %s 0x%02x) & 0x%02x)\n",
+	      port, index, mask, reg, (shift & 0x80) ? "<<" : ">>",
+	      (shift & 0x80) ? (0x100 - shift) : shift, smask);
+	init->offset += 11;
+
+	data  = init_rdvgai(init, port, index) & mask;
+	data |= init_shift(init_rd32(init, reg), shift) & smask;
+	init_wrvgai(init, port, index, data);
+}
+
+/**
+ * INIT_NOT - opcode 0x38
+ *
+ */
+static void
+init_not(struct nvbios_init *init)
+{
+	trace("NOT\n");
+	init->offset += 1;
+	init_exec_inv(init);
+}
+
+/**
+ * INIT_IO_FLAG_CONDITION - opcode 0x39
+ *
+ */
+static void
+init_io_flag_condition(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 cond = nv_ro08(bios, init->offset + 1);
+
+	trace("IO_FLAG_CONDITION\t0x%02x\n", cond);
+	init->offset += 2;
+
+	if (!init_io_flag_condition_met(init, cond))
+		init_exec_set(init, false);
+}
+
+/**
+ * INIT_DP_CONDITION - opcode 0x3a
+ *
+ */
+static void
+init_dp_condition(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	struct nvbios_dpout info;
+	u8  cond = nv_ro08(bios, init->offset + 1);
+	u8  unkn = nv_ro08(bios, init->offset + 2);
+	u8  ver, hdr, cnt, len;
+	u16 data;
+
+	trace("DP_CONDITION\t0x%02x 0x%02x\n", cond, unkn);
+	init->offset += 3;
+
+	switch (cond) {
+	case 0:
+		if (init_conn(init) != DCB_CONNECTOR_eDP)
+			init_exec_set(init, false);
+		break;
+	case 1:
+	case 2:
+		if ( init->outp &&
+		    (data = nvbios_dpout_match(bios, DCB_OUTPUT_DP,
+					       (init->outp->or << 0) |
+					       (init->outp->sorconf.link << 6),
+					       &ver, &hdr, &cnt, &len, &info)))
+		{
+			if (!(info.flags & cond))
+				init_exec_set(init, false);
+			break;
+		}
+
+		if (init_exec(init))
+			warn("script needs dp output table data\n");
+		break;
+	case 5:
+		if (!(init_rdauxr(init, 0x0d) & 1))
+			init_exec_set(init, false);
+		break;
+	default:
+		warn("unknown dp condition 0x%02x\n", cond);
+		break;
+	}
+}
+
+/**
+ * INIT_IO_MASK_OR - opcode 0x3b
+ *
+ */
+static void
+init_io_mask_or(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 index = nv_ro08(bios, init->offset + 1);
+	u8    or = init_or(init);
+	u8  data;
+
+	trace("IO_MASK_OR\t0x03d4[0x%02x] &= ~(1 << 0x%02x)\n", index, or);
+	init->offset += 2;
+
+	data = init_rdvgai(init, 0x03d4, index);
+	init_wrvgai(init, 0x03d4, index, data &= ~(1 << or));
+}
+
+/**
+ * INIT_IO_OR - opcode 0x3c
+ *
+ */
+static void
+init_io_or(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 index = nv_ro08(bios, init->offset + 1);
+	u8    or = init_or(init);
+	u8  data;
+
+	trace("IO_OR\t0x03d4[0x%02x] |= (1 << 0x%02x)\n", index, or);
+	init->offset += 2;
+
+	data = init_rdvgai(init, 0x03d4, index);
+	init_wrvgai(init, 0x03d4, index, data | (1 << or));
+}
+
+/**
+ * INIT_ANDN_REG - opcode 0x47
+ *
+ */
+static void
+init_andn_reg(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32  reg = nv_ro32(bios, init->offset + 1);
+	u32 mask = nv_ro32(bios, init->offset + 5);
+
+	trace("ANDN_REG\tR[0x%06x] &= ~0x%08x\n", reg, mask);
+	init->offset += 9;
+
+	init_mask(init, reg, mask, 0);
+}
+
+/**
+ * INIT_OR_REG - opcode 0x48
+ *
+ */
+static void
+init_or_reg(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32  reg = nv_ro32(bios, init->offset + 1);
+	u32 mask = nv_ro32(bios, init->offset + 5);
+
+	trace("OR_REG\tR[0x%06x] |= 0x%08x\n", reg, mask);
+	init->offset += 9;
+
+	init_mask(init, reg, 0, mask);
+}
+
+/**
+ * INIT_INDEX_ADDRESS_LATCHED - opcode 0x49
+ *
+ */
+static void
+init_idx_addr_latched(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 creg = nv_ro32(bios, init->offset + 1);
+	u32 dreg = nv_ro32(bios, init->offset + 5);
+	u32 mask = nv_ro32(bios, init->offset + 9);
+	u32 data = nv_ro32(bios, init->offset + 13);
+	u8 count = nv_ro08(bios, init->offset + 17);
+
+	trace("INDEX_ADDRESS_LATCHED\tR[0x%06x] : R[0x%06x]\n", creg, dreg);
+	trace("\tCTRL &= 0x%08x |= 0x%08x\n", mask, data);
+	init->offset += 18;
+
+	while (count--) {
+		u8 iaddr = nv_ro08(bios, init->offset + 0);
+		u8 idata = nv_ro08(bios, init->offset + 1);
+
+		trace("\t[0x%02x] = 0x%02x\n", iaddr, idata);
+		init->offset += 2;
+
+		init_wr32(init, dreg, idata);
+		init_mask(init, creg, ~mask, data | iaddr);
+	}
+}
+
+/**
+ * INIT_IO_RESTRICT_PLL2 - opcode 0x4a
+ *
+ */
+static void
+init_io_restrict_pll2(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 port = nv_ro16(bios, init->offset + 1);
+	u8 index = nv_ro08(bios, init->offset + 3);
+	u8  mask = nv_ro08(bios, init->offset + 4);
+	u8 shift = nv_ro08(bios, init->offset + 5);
+	u8 count = nv_ro08(bios, init->offset + 6);
+	u32  reg = nv_ro32(bios, init->offset + 7);
+	u8  conf, i;
+
+	trace("IO_RESTRICT_PLL2\t"
+	      "R[0x%06x] =PLL= ((0x%04x[0x%02x] & 0x%02x) >> 0x%02x) [{\n",
+	      reg, port, index, mask, shift);
+	init->offset += 11;
+
+	conf = (init_rdvgai(init, port, index) & mask) >> shift;
+	for (i = 0; i < count; i++) {
+		u32 freq = nv_ro32(bios, init->offset);
+		if (i == conf) {
+			trace("\t%dkHz *\n", freq);
+			init_prog_pll(init, reg, freq);
+		} else {
+			trace("\t%dkHz\n", freq);
+		}
+		init->offset += 4;
+	}
+	trace("}]\n");
+}
+
+/**
+ * INIT_PLL2 - opcode 0x4b
+ *
+ */
+static void
+init_pll2(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32  reg = nv_ro32(bios, init->offset + 1);
+	u32 freq = nv_ro32(bios, init->offset + 5);
+
+	trace("PLL2\tR[0x%06x] =PLL= %dkHz\n", reg, freq);
+	init->offset += 9;
+
+	init_prog_pll(init, reg, freq);
+}
+
+/**
+ * INIT_I2C_BYTE - opcode 0x4c
+ *
+ */
+static void
+init_i2c_byte(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 index = nv_ro08(bios, init->offset + 1);
+	u8  addr = nv_ro08(bios, init->offset + 2) >> 1;
+	u8 count = nv_ro08(bios, init->offset + 3);
+
+	trace("I2C_BYTE\tI2C[0x%02x][0x%02x]\n", index, addr);
+	init->offset += 4;
+
+	while (count--) {
+		u8  reg = nv_ro08(bios, init->offset + 0);
+		u8 mask = nv_ro08(bios, init->offset + 1);
+		u8 data = nv_ro08(bios, init->offset + 2);
+		int val;
+
+		trace("\t[0x%02x] &= 0x%02x |= 0x%02x\n", reg, mask, data);
+		init->offset += 3;
+
+		val = init_rdi2cr(init, index, addr, reg);
+		if (val < 0)
+			continue;
+		init_wri2cr(init, index, addr, reg, (val & mask) | data);
+	}
+}
+
+/**
+ * INIT_ZM_I2C_BYTE - opcode 0x4d
+ *
+ */
+static void
+init_zm_i2c_byte(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 index = nv_ro08(bios, init->offset + 1);
+	u8  addr = nv_ro08(bios, init->offset + 2) >> 1;
+	u8 count = nv_ro08(bios, init->offset + 3);
+
+	trace("ZM_I2C_BYTE\tI2C[0x%02x][0x%02x]\n", index, addr);
+	init->offset += 4;
+
+	while (count--) {
+		u8  reg = nv_ro08(bios, init->offset + 0);
+		u8 data = nv_ro08(bios, init->offset + 1);
+
+		trace("\t[0x%02x] = 0x%02x\n", reg, data);
+		init->offset += 2;
+
+		init_wri2cr(init, index, addr, reg, data);
+	}
+
+}
+
+/**
+ * INIT_ZM_I2C - opcode 0x4e
+ *
+ */
+static void
+init_zm_i2c(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 index = nv_ro08(bios, init->offset + 1);
+	u8  addr = nv_ro08(bios, init->offset + 2) >> 1;
+	u8 count = nv_ro08(bios, init->offset + 3);
+	u8 data[256], i;
+
+	trace("ZM_I2C\tI2C[0x%02x][0x%02x]\n", index, addr);
+	init->offset += 4;
+
+	for (i = 0; i < count; i++) {
+		data[i] = nv_ro08(bios, init->offset);
+		trace("\t0x%02x\n", data[i]);
+		init->offset++;
+	}
+
+	if (init_exec(init)) {
+		struct nouveau_i2c_port *port = init_i2c(init, index);
+		struct i2c_msg msg = {
+			.addr = addr, .flags = 0, .len = count, .buf = data,
+		};
+		int ret;
+
+		if (port && (ret = i2c_transfer(&port->adapter, &msg, 1)) != 1)
+			warn("i2c wr failed, %d\n", ret);
+	}
+}
+
+/**
+ * INIT_TMDS - opcode 0x4f
+ *
+ */
+static void
+init_tmds(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 tmds = nv_ro08(bios, init->offset + 1);
+	u8 addr = nv_ro08(bios, init->offset + 2);
+	u8 mask = nv_ro08(bios, init->offset + 3);
+	u8 data = nv_ro08(bios, init->offset + 4);
+	u32 reg = init_tmds_reg(init, tmds);
+
+	trace("TMDS\tT[0x%02x][0x%02x] &= 0x%02x |= 0x%02x\n",
+	      tmds, addr, mask, data);
+	init->offset += 5;
+
+	if (reg == 0)
+		return;
+
+	init_wr32(init, reg + 0, addr | 0x00010000);
+	init_wr32(init, reg + 4, data | (init_rd32(init, reg + 4) & mask));
+	init_wr32(init, reg + 0, addr);
+}
+
+/**
+ * INIT_ZM_TMDS_GROUP - opcode 0x50
+ *
+ */
+static void
+init_zm_tmds_group(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8  tmds = nv_ro08(bios, init->offset + 1);
+	u8 count = nv_ro08(bios, init->offset + 2);
+	u32  reg = init_tmds_reg(init, tmds);
+
+	trace("TMDS_ZM_GROUP\tT[0x%02x]\n", tmds);
+	init->offset += 3;
+
+	while (count--) {
+		u8 addr = nv_ro08(bios, init->offset + 0);
+		u8 data = nv_ro08(bios, init->offset + 1);
+
+		trace("\t[0x%02x] = 0x%02x\n", addr, data);
+		init->offset += 2;
+
+		init_wr32(init, reg + 4, data);
+		init_wr32(init, reg + 0, addr);
+	}
+}
+
+/**
+ * INIT_CR_INDEX_ADDRESS_LATCHED - opcode 0x51
+ *
+ */
+static void
+init_cr_idx_adr_latch(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 addr0 = nv_ro08(bios, init->offset + 1);
+	u8 addr1 = nv_ro08(bios, init->offset + 2);
+	u8  base = nv_ro08(bios, init->offset + 3);
+	u8 count = nv_ro08(bios, init->offset + 4);
+	u8 save0;
+
+	trace("CR_INDEX_ADDR C[%02x] C[%02x]\n", addr0, addr1);
+	init->offset += 5;
+
+	save0 = init_rdvgai(init, 0x03d4, addr0);
+	while (count--) {
+		u8 data = nv_ro08(bios, init->offset);
+
+		trace("\t\t[0x%02x] = 0x%02x\n", base, data);
+		init->offset += 1;
+
+		init_wrvgai(init, 0x03d4, addr0, base++);
+		init_wrvgai(init, 0x03d4, addr1, data);
+	}
+	init_wrvgai(init, 0x03d4, addr0, save0);
+}
+
+/**
+ * INIT_CR - opcode 0x52
+ *
+ */
+static void
+init_cr(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 addr = nv_ro08(bios, init->offset + 1);
+	u8 mask = nv_ro08(bios, init->offset + 2);
+	u8 data = nv_ro08(bios, init->offset + 3);
+	u8 val;
+
+	trace("CR\t\tC[0x%02x] &= 0x%02x |= 0x%02x\n", addr, mask, data);
+	init->offset += 4;
+
+	val = init_rdvgai(init, 0x03d4, addr) & mask;
+	init_wrvgai(init, 0x03d4, addr, val | data);
+}
+
+/**
+ * INIT_ZM_CR - opcode 0x53
+ *
+ */
+static void
+init_zm_cr(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 addr = nv_ro08(bios, init->offset + 1);
+	u8 data = nv_ro08(bios, init->offset + 2);
+
+	trace("ZM_CR\tC[0x%02x] = 0x%02x\n", addr,  data);
+	init->offset += 3;
+
+	init_wrvgai(init, 0x03d4, addr, data);
+}
+
+/**
+ * INIT_ZM_CR_GROUP - opcode 0x54
+ *
+ */
+static void
+init_zm_cr_group(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 count = nv_ro08(bios, init->offset + 1);
+
+	trace("ZM_CR_GROUP\n");
+	init->offset += 2;
+
+	while (count--) {
+		u8 addr = nv_ro08(bios, init->offset + 0);
+		u8 data = nv_ro08(bios, init->offset + 1);
+
+		trace("\t\tC[0x%02x] = 0x%02x\n", addr, data);
+		init->offset += 2;
+
+		init_wrvgai(init, 0x03d4, addr, data);
+	}
+}
+
+/**
+ * INIT_CONDITION_TIME - opcode 0x56
+ *
+ */
+static void
+init_condition_time(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8  cond = nv_ro08(bios, init->offset + 1);
+	u8 retry = nv_ro08(bios, init->offset + 2);
+	u8  wait = min((u16)retry * 50, 100);
+
+	trace("CONDITION_TIME\t0x%02x 0x%02x\n", cond, retry);
+	init->offset += 3;
+
+	if (!init_exec(init))
+		return;
+
+	while (wait--) {
+		if (init_condition_met(init, cond))
+			return;
+		mdelay(20);
+	}
+
+	init_exec_set(init, false);
+}
+
+/**
+ * INIT_LTIME - opcode 0x57
+ *
+ */
+static void
+init_ltime(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 msec = nv_ro16(bios, init->offset + 1);
+
+	trace("LTIME\t0x%04x\n", msec);
+	init->offset += 3;
+
+	if (init_exec(init))
+		mdelay(msec);
+}
+
+/**
+ * INIT_ZM_REG_SEQUENCE - opcode 0x58
+ *
+ */
+static void
+init_zm_reg_sequence(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 base = nv_ro32(bios, init->offset + 1);
+	u8 count = nv_ro08(bios, init->offset + 5);
+
+	trace("ZM_REG_SEQUENCE\t0x%02x\n", count);
+	init->offset += 6;
+
+	while (count--) {
+		u32 data = nv_ro32(bios, init->offset);
+
+		trace("\t\tR[0x%06x] = 0x%08x\n", base, data);
+		init->offset += 4;
+
+		init_wr32(init, base, data);
+		base += 4;
+	}
+}
+
+/**
+ * INIT_SUB_DIRECT - opcode 0x5b
+ *
+ */
+static void
+init_sub_direct(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 addr = nv_ro16(bios, init->offset + 1);
+	u16 save;
+
+	trace("SUB_DIRECT\t0x%04x\n", addr);
+
+	if (init_exec(init)) {
+		save = init->offset;
+		init->offset = addr;
+		if (nvbios_exec(init)) {
+			error("error parsing sub-table\n");
+			return;
+		}
+		init->offset = save;
+	}
+
+	init->offset += 3;
+}
+
+/**
+ * INIT_JUMP - opcode 0x5c
+ *
+ */
+static void
+init_jump(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 offset = nv_ro16(bios, init->offset + 1);
+
+	trace("JUMP\t0x%04x\n", offset);
+
+	if (init_exec(init))
+		init->offset = offset;
+	else
+		init->offset += 3;
+}
+
+/**
+ * INIT_I2C_IF - opcode 0x5e
+ *
+ */
+static void
+init_i2c_if(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 index = nv_ro08(bios, init->offset + 1);
+	u8  addr = nv_ro08(bios, init->offset + 2);
+	u8   reg = nv_ro08(bios, init->offset + 3);
+	u8  mask = nv_ro08(bios, init->offset + 4);
+	u8  data = nv_ro08(bios, init->offset + 5);
+	u8 value;
+
+	trace("I2C_IF\tI2C[0x%02x][0x%02x][0x%02x] & 0x%02x == 0x%02x\n",
+	      index, addr, reg, mask, data);
+	init->offset += 6;
+	init_exec_force(init, true);
+
+	value = init_rdi2cr(init, index, addr, reg);
+	if ((value & mask) != data)
+		init_exec_set(init, false);
+
+	init_exec_force(init, false);
+}
+
+/**
+ * INIT_COPY_NV_REG - opcode 0x5f
+ *
+ */
+static void
+init_copy_nv_reg(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32  sreg = nv_ro32(bios, init->offset + 1);
+	u8  shift = nv_ro08(bios, init->offset + 5);
+	u32 smask = nv_ro32(bios, init->offset + 6);
+	u32  sxor = nv_ro32(bios, init->offset + 10);
+	u32  dreg = nv_ro32(bios, init->offset + 14);
+	u32 dmask = nv_ro32(bios, init->offset + 18);
+	u32 data;
+
+	trace("COPY_NV_REG\tR[0x%06x] &= 0x%08x |= "
+	      "((R[0x%06x] %s 0x%02x) & 0x%08x ^ 0x%08x)\n",
+	      dreg, dmask, sreg, (shift & 0x80) ? "<<" : ">>",
+	      (shift & 0x80) ? (0x100 - shift) : shift, smask, sxor);
+	init->offset += 22;
+
+	data = init_shift(init_rd32(init, sreg), shift);
+	init_mask(init, dreg, ~dmask, (data & smask) ^ sxor);
+}
+
+/**
+ * INIT_ZM_INDEX_IO - opcode 0x62
+ *
+ */
+static void
+init_zm_index_io(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 port = nv_ro16(bios, init->offset + 1);
+	u8 index = nv_ro08(bios, init->offset + 3);
+	u8  data = nv_ro08(bios, init->offset + 4);
+
+	trace("ZM_INDEX_IO\tI[0x%04x][0x%02x] = 0x%02x\n", port, index, data);
+	init->offset += 5;
+
+	init_wrvgai(init, port, index, data);
+}
+
+/**
+ * INIT_COMPUTE_MEM - opcode 0x63
+ *
+ */
+static void
+init_compute_mem(struct nvbios_init *init)
+{
+	struct nouveau_devinit *devinit = nouveau_devinit(init->bios);
+
+	trace("COMPUTE_MEM\n");
+	init->offset += 1;
+
+	init_exec_force(init, true);
+	if (init_exec(init) && devinit->meminit)
+		devinit->meminit(devinit);
+	init_exec_force(init, false);
+}
+
+/**
+ * INIT_RESET - opcode 0x65
+ *
+ */
+static void
+init_reset(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32   reg = nv_ro32(bios, init->offset + 1);
+	u32 data1 = nv_ro32(bios, init->offset + 5);
+	u32 data2 = nv_ro32(bios, init->offset + 9);
+	u32 savepci19;
+
+	trace("RESET\tR[0x%08x] = 0x%08x, 0x%08x", reg, data1, data2);
+	init->offset += 13;
+	init_exec_force(init, true);
+
+	savepci19 = init_mask(init, 0x00184c, 0x00000f00, 0x00000000);
+	init_wr32(init, reg, data1);
+	udelay(10);
+	init_wr32(init, reg, data2);
+	init_wr32(init, 0x00184c, savepci19);
+	init_mask(init, 0x001850, 0x00000001, 0x00000000);
+
+	init_exec_force(init, false);
+}
+
+/**
+ * INIT_CONFIGURE_MEM - opcode 0x66
+ *
+ */
+static u16
+init_configure_mem_clk(struct nvbios_init *init)
+{
+	u16 mdata = bmp_mem_init_table(init->bios);
+	if (mdata)
+		mdata += (init_rdvgai(init, 0x03d4, 0x3c) >> 4) * 66;
+	return mdata;
+}
+
+static void
+init_configure_mem(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 mdata, sdata;
+	u32 addr, data;
+
+	trace("CONFIGURE_MEM\n");
+	init->offset += 1;
+
+	if (bios->version.major > 2) {
+		init_done(init);
+		return;
+	}
+	init_exec_force(init, true);
+
+	mdata = init_configure_mem_clk(init);
+	sdata = bmp_sdr_seq_table(bios);
+	if (nv_ro08(bios, mdata) & 0x01)
+		sdata = bmp_ddr_seq_table(bios);
+	mdata += 6; /* skip to data */
+
+	data = init_rdvgai(init, 0x03c4, 0x01);
+	init_wrvgai(init, 0x03c4, 0x01, data | 0x20);
+
+	for (; (addr = nv_ro32(bios, sdata)) != 0xffffffff; sdata += 4) {
+		switch (addr) {
+		case 0x10021c: /* CKE_NORMAL */
+		case 0x1002d0: /* CMD_REFRESH */
+		case 0x1002d4: /* CMD_PRECHARGE */
+			data = 0x00000001;
+			break;
+		default:
+			data = nv_ro32(bios, mdata);
+			mdata += 4;
+			if (data == 0xffffffff)
+				continue;
+			break;
+		}
+
+		init_wr32(init, addr, data);
+	}
+
+	init_exec_force(init, false);
+}
+
+/**
+ * INIT_CONFIGURE_CLK - opcode 0x67
+ *
+ */
+static void
+init_configure_clk(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 mdata, clock;
+
+	trace("CONFIGURE_CLK\n");
+	init->offset += 1;
+
+	if (bios->version.major > 2) {
+		init_done(init);
+		return;
+	}
+	init_exec_force(init, true);
+
+	mdata = init_configure_mem_clk(init);
+
+	/* NVPLL */
+	clock = nv_ro16(bios, mdata + 4) * 10;
+	init_prog_pll(init, 0x680500, clock);
+
+	/* MPLL */
+	clock = nv_ro16(bios, mdata + 2) * 10;
+	if (nv_ro08(bios, mdata) & 0x01)
+		clock *= 2;
+	init_prog_pll(init, 0x680504, clock);
+
+	init_exec_force(init, false);
+}
+
+/**
+ * INIT_CONFIGURE_PREINIT - opcode 0x68
+ *
+ */
+static void
+init_configure_preinit(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 strap;
+
+	trace("CONFIGURE_PREINIT\n");
+	init->offset += 1;
+
+	if (bios->version.major > 2) {
+		init_done(init);
+		return;
+	}
+	init_exec_force(init, true);
+
+	strap = init_rd32(init, 0x101000);
+	strap = ((strap << 2) & 0xf0) | ((strap & 0x40) >> 6);
+	init_wrvgai(init, 0x03d4, 0x3c, strap);
+
+	init_exec_force(init, false);
+}
+
+/**
+ * INIT_IO - opcode 0x69
+ *
+ */
+static void
+init_io(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 port = nv_ro16(bios, init->offset + 1);
+	u8  mask = nv_ro16(bios, init->offset + 3);
+	u8  data = nv_ro16(bios, init->offset + 4);
+	u8 value;
+
+	trace("IO\t\tI[0x%04x] &= 0x%02x |= 0x%02x\n", port, mask, data);
+	init->offset += 5;
+
+	/* ummm.. yes.. should really figure out wtf this is and why it's
+	 * needed some day..  it's almost certainly wrong, but, it also
+	 * somehow makes things work...
+	 */
+	if (nv_device(init->bios)->card_type >= NV_50 &&
+	    port == 0x03c3 && data == 0x01) {
+		init_mask(init, 0x614100, 0xf0800000, 0x00800000);
+		init_mask(init, 0x00e18c, 0x00020000, 0x00020000);
+		init_mask(init, 0x614900, 0xf0800000, 0x00800000);
+		init_mask(init, 0x000200, 0x40000000, 0x00000000);
+		mdelay(10);
+		init_mask(init, 0x00e18c, 0x00020000, 0x00000000);
+		init_mask(init, 0x000200, 0x40000000, 0x40000000);
+		init_wr32(init, 0x614100, 0x00800018);
+		init_wr32(init, 0x614900, 0x00800018);
+		mdelay(10);
+		init_wr32(init, 0x614100, 0x10000018);
+		init_wr32(init, 0x614900, 0x10000018);
+	}
+
+	value = init_rdport(init, port) & mask;
+	init_wrport(init, port, data | value);
+}
+
+/**
+ * INIT_SUB - opcode 0x6b
+ *
+ */
+static void
+init_sub(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 index = nv_ro08(bios, init->offset + 1);
+	u16 addr, save;
+
+	trace("SUB\t0x%02x\n", index);
+
+	addr = init_script(bios, index);
+	if (addr && init_exec(init)) {
+		save = init->offset;
+		init->offset = addr;
+		if (nvbios_exec(init)) {
+			error("error parsing sub-table\n");
+			return;
+		}
+		init->offset = save;
+	}
+
+	init->offset += 2;
+}
+
+/**
+ * INIT_RAM_CONDITION - opcode 0x6d
+ *
+ */
+static void
+init_ram_condition(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8  mask = nv_ro08(bios, init->offset + 1);
+	u8 value = nv_ro08(bios, init->offset + 2);
+
+	trace("RAM_CONDITION\t"
+	      "(R[0x100000] & 0x%02x) == 0x%02x\n", mask, value);
+	init->offset += 3;
+
+	if ((init_rd32(init, 0x100000) & mask) != value)
+		init_exec_set(init, false);
+}
+
+/**
+ * INIT_NV_REG - opcode 0x6e
+ *
+ */
+static void
+init_nv_reg(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32  reg = nv_ro32(bios, init->offset + 1);
+	u32 mask = nv_ro32(bios, init->offset + 5);
+	u32 data = nv_ro32(bios, init->offset + 9);
+
+	trace("NV_REG\tR[0x%06x] &= 0x%08x |= 0x%08x\n", reg, mask, data);
+	init->offset += 13;
+
+	init_mask(init, reg, ~mask, data);
+}
+
+/**
+ * INIT_MACRO - opcode 0x6f
+ *
+ */
+static void
+init_macro(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8  macro = nv_ro08(bios, init->offset + 1);
+	u16 table;
+
+	trace("MACRO\t0x%02x\n", macro);
+
+	table = init_macro_table(init);
+	if (table) {
+		u32 addr = nv_ro32(bios, table + (macro * 8) + 0);
+		u32 data = nv_ro32(bios, table + (macro * 8) + 4);
+		trace("\t\tR[0x%06x] = 0x%08x\n", addr, data);
+		init_wr32(init, addr, data);
+	}
+
+	init->offset += 2;
+}
+
+/**
+ * INIT_RESUME - opcode 0x72
+ *
+ */
+static void
+init_resume(struct nvbios_init *init)
+{
+	trace("RESUME\n");
+	init->offset += 1;
+	init_exec_set(init, true);
+}
+
+/**
+ * INIT_TIME - opcode 0x74
+ *
+ */
+static void
+init_time(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 usec = nv_ro16(bios, init->offset + 1);
+
+	trace("TIME\t0x%04x\n", usec);
+	init->offset += 3;
+
+	if (init_exec(init)) {
+		if (usec < 1000)
+			udelay(usec);
+		else
+			mdelay((usec + 900) / 1000);
+	}
+}
+
+/**
+ * INIT_CONDITION - opcode 0x75
+ *
+ */
+static void
+init_condition(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 cond = nv_ro08(bios, init->offset + 1);
+
+	trace("CONDITION\t0x%02x\n", cond);
+	init->offset += 2;
+
+	if (!init_condition_met(init, cond))
+		init_exec_set(init, false);
+}
+
+/**
+ * INIT_IO_CONDITION - opcode 0x76
+ *
+ */
+static void
+init_io_condition(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 cond = nv_ro08(bios, init->offset + 1);
+
+	trace("IO_CONDITION\t0x%02x\n", cond);
+	init->offset += 2;
+
+	if (!init_io_condition_met(init, cond))
+		init_exec_set(init, false);
+}
+
+/**
+ * INIT_INDEX_IO - opcode 0x78
+ *
+ */
+static void
+init_index_io(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 port = nv_ro16(bios, init->offset + 1);
+	u8 index = nv_ro16(bios, init->offset + 3);
+	u8  mask = nv_ro08(bios, init->offset + 4);
+	u8  data = nv_ro08(bios, init->offset + 5);
+	u8 value;
+
+	trace("INDEX_IO\tI[0x%04x][0x%02x] &= 0x%02x |= 0x%02x\n",
+	      port, index, mask, data);
+	init->offset += 6;
+
+	value = init_rdvgai(init, port, index) & mask;
+	init_wrvgai(init, port, index, data | value);
+}
+
+/**
+ * INIT_PLL - opcode 0x79
+ *
+ */
+static void
+init_pll(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32  reg = nv_ro32(bios, init->offset + 1);
+	u32 freq = nv_ro16(bios, init->offset + 5) * 10;
+
+	trace("PLL\tR[0x%06x] =PLL= %dkHz\n", reg, freq);
+	init->offset += 7;
+
+	init_prog_pll(init, reg, freq);
+}
+
+/**
+ * INIT_ZM_REG - opcode 0x7a
+ *
+ */
+static void
+init_zm_reg(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 addr = nv_ro32(bios, init->offset + 1);
+	u32 data = nv_ro32(bios, init->offset + 5);
+
+	trace("ZM_REG\tR[0x%06x] = 0x%08x\n", addr, data);
+	init->offset += 9;
+
+	if (addr == 0x000200)
+		data |= 0x00000001;
+
+	init_wr32(init, addr, data);
+}
+
+/**
+ * INIT_RAM_RESTRICT_PLL - opcde 0x87
+ *
+ */
+static void
+init_ram_restrict_pll(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8  type = nv_ro08(bios, init->offset + 1);
+	u8 count = init_ram_restrict_group_count(init);
+	u8 strap = init_ram_restrict(init);
+	u8 cconf;
+
+	trace("RAM_RESTRICT_PLL\t0x%02x\n", type);
+	init->offset += 2;
+
+	for (cconf = 0; cconf < count; cconf++) {
+		u32 freq = nv_ro32(bios, init->offset);
+
+		if (cconf == strap) {
+			trace("%dkHz *\n", freq);
+			init_prog_pll(init, type, freq);
+		} else {
+			trace("%dkHz\n", freq);
+		}
+
+		init->offset += 4;
+	}
+}
+
+/**
+ * INIT_GPIO - opcode 0x8e
+ *
+ */
+static void
+init_gpio(struct nvbios_init *init)
+{
+	struct nouveau_gpio *gpio = nouveau_gpio(init->bios);
+
+	trace("GPIO\n");
+	init->offset += 1;
+
+	if (init_exec(init) && gpio && gpio->reset)
+		gpio->reset(gpio, DCB_GPIO_UNUSED);
+}
+
+/**
+ * INIT_RAM_RESTRICT_ZM_GROUP - opcode 0x8f
+ *
+ */
+static void
+init_ram_restrict_zm_reg_group(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 addr = nv_ro32(bios, init->offset + 1);
+	u8  incr = nv_ro08(bios, init->offset + 5);
+	u8   num = nv_ro08(bios, init->offset + 6);
+	u8 count = init_ram_restrict_group_count(init);
+	u8 index = init_ram_restrict(init);
+	u8 i, j;
+
+	trace("RAM_RESTRICT_ZM_REG_GROUP\t"
+	      "R[0x%08x] 0x%02x 0x%02x\n", addr, incr, num);
+	init->offset += 7;
+
+	for (i = 0; i < num; i++) {
+		trace("\tR[0x%06x] = {\n", addr);
+		for (j = 0; j < count; j++) {
+			u32 data = nv_ro32(bios, init->offset);
+
+			if (j == index) {
+				trace("\t\t0x%08x *\n", data);
+				init_wr32(init, addr, data);
+			} else {
+				trace("\t\t0x%08x\n", data);
+			}
+
+			init->offset += 4;
+		}
+		trace("\t}\n");
+		addr += incr;
+	}
+}
+
+/**
+ * INIT_COPY_ZM_REG - opcode 0x90
+ *
+ */
+static void
+init_copy_zm_reg(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 sreg = nv_ro32(bios, init->offset + 1);
+	u32 dreg = nv_ro32(bios, init->offset + 5);
+
+	trace("COPY_ZM_REG\tR[0x%06x] = R[0x%06x]\n", dreg, sreg);
+	init->offset += 9;
+
+	init_wr32(init, dreg, init_rd32(init, sreg));
+}
+
+/**
+ * INIT_ZM_REG_GROUP - opcode 0x91
+ *
+ */
+static void
+init_zm_reg_group(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 addr = nv_ro32(bios, init->offset + 1);
+	u8 count = nv_ro08(bios, init->offset + 5);
+
+	trace("ZM_REG_GROUP\tR[0x%06x] =\n", addr);
+	init->offset += 6;
+
+	while (count--) {
+		u32 data = nv_ro32(bios, init->offset);
+		trace("\t0x%08x\n", data);
+		init_wr32(init, addr, data);
+		init->offset += 4;
+	}
+}
+
+/**
+ * INIT_XLAT - opcode 0x96
+ *
+ */
+static void
+init_xlat(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 saddr = nv_ro32(bios, init->offset + 1);
+	u8 sshift = nv_ro08(bios, init->offset + 5);
+	u8  smask = nv_ro08(bios, init->offset + 6);
+	u8  index = nv_ro08(bios, init->offset + 7);
+	u32 daddr = nv_ro32(bios, init->offset + 8);
+	u32 dmask = nv_ro32(bios, init->offset + 12);
+	u8  shift = nv_ro08(bios, init->offset + 16);
+	u32 data;
+
+	trace("INIT_XLAT\tR[0x%06x] &= 0x%08x |= "
+	      "(X%02x((R[0x%06x] %s 0x%02x) & 0x%02x) << 0x%02x)\n",
+	      daddr, dmask, index, saddr, (sshift & 0x80) ? "<<" : ">>",
+	      (sshift & 0x80) ? (0x100 - sshift) : sshift, smask, shift);
+	init->offset += 17;
+
+	data = init_shift(init_rd32(init, saddr), sshift) & smask;
+	data = init_xlat_(init, index, data) << shift;
+	init_mask(init, daddr, ~dmask, data);
+}
+
+/**
+ * INIT_ZM_MASK_ADD - opcode 0x97
+ *
+ */
+static void
+init_zm_mask_add(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 addr = nv_ro32(bios, init->offset + 1);
+	u32 mask = nv_ro32(bios, init->offset + 5);
+	u32  add = nv_ro32(bios, init->offset + 9);
+	u32 data;
+
+	trace("ZM_MASK_ADD\tR[0x%06x] &= 0x%08x += 0x%08x\n", addr, mask, add);
+	init->offset += 13;
+
+	data =  init_rd32(init, addr);
+	data = (data & mask) | ((data + add) & ~mask);
+	init_wr32(init, addr, data);
+}
+
+/**
+ * INIT_AUXCH - opcode 0x98
+ *
+ */
+static void
+init_auxch(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 addr = nv_ro32(bios, init->offset + 1);
+	u8 count = nv_ro08(bios, init->offset + 5);
+
+	trace("AUXCH\tAUX[0x%08x] 0x%02x\n", addr, count);
+	init->offset += 6;
+
+	while (count--) {
+		u8 mask = nv_ro08(bios, init->offset + 0);
+		u8 data = nv_ro08(bios, init->offset + 1);
+		trace("\tAUX[0x%08x] &= 0x%02x |= 0x%02x\n", addr, mask, data);
+		mask = init_rdauxr(init, addr) & mask;
+		init_wrauxr(init, addr, mask | data);
+		init->offset += 2;
+	}
+}
+
+/**
+ * INIT_AUXCH - opcode 0x99
+ *
+ */
+static void
+init_zm_auxch(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 addr = nv_ro32(bios, init->offset + 1);
+	u8 count = nv_ro08(bios, init->offset + 5);
+
+	trace("ZM_AUXCH\tAUX[0x%08x] 0x%02x\n", addr, count);
+	init->offset += 6;
+
+	while (count--) {
+		u8 data = nv_ro08(bios, init->offset + 0);
+		trace("\tAUX[0x%08x] = 0x%02x\n", addr, data);
+		init_wrauxr(init, addr, data);
+		init->offset += 1;
+	}
+}
+
+/**
+ * INIT_I2C_LONG_IF - opcode 0x9a
+ *
+ */
+static void
+init_i2c_long_if(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 index = nv_ro08(bios, init->offset + 1);
+	u8  addr = nv_ro08(bios, init->offset + 2) >> 1;
+	u8 reglo = nv_ro08(bios, init->offset + 3);
+	u8 reghi = nv_ro08(bios, init->offset + 4);
+	u8  mask = nv_ro08(bios, init->offset + 5);
+	u8  data = nv_ro08(bios, init->offset + 6);
+	struct nouveau_i2c_port *port;
+
+	trace("I2C_LONG_IF\t"
+	      "I2C[0x%02x][0x%02x][0x%02x%02x] & 0x%02x == 0x%02x\n",
+	      index, addr, reglo, reghi, mask, data);
+	init->offset += 7;
+
+	port = init_i2c(init, index);
+	if (port) {
+		u8 i[2] = { reghi, reglo };
+		u8 o[1] = {};
+		struct i2c_msg msg[] = {
+			{ .addr = addr, .flags = 0, .len = 2, .buf = i },
+			{ .addr = addr, .flags = I2C_M_RD, .len = 1, .buf = o }
+		};
+		int ret;
+
+		ret = i2c_transfer(&port->adapter, msg, 2);
+		if (ret == 2 && ((o[0] & mask) == data))
+			return;
+	}
+
+	init_exec_set(init, false);
+}
+
+/**
+ * INIT_GPIO_NE - opcode 0xa9
+ *
+ */
+static void
+init_gpio_ne(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	struct nouveau_gpio *gpio = nouveau_gpio(bios);
+	struct dcb_gpio_func func;
+	u8 count = nv_ro08(bios, init->offset + 1);
+	u8 idx = 0, ver, len;
+	u16 data, i;
+
+	trace("GPIO_NE\t");
+	init->offset += 2;
+
+	for (i = init->offset; i < init->offset + count; i++)
+		cont("0x%02x ", nv_ro08(bios, i));
+	cont("\n");
+
+	while ((data = dcb_gpio_parse(bios, 0, idx++, &ver, &len, &func))) {
+		if (func.func != DCB_GPIO_UNUSED) {
+			for (i = init->offset; i < init->offset + count; i++) {
+				if (func.func == nv_ro08(bios, i))
+					break;
+			}
+
+			trace("\tFUNC[0x%02x]", func.func);
+			if (i == (init->offset + count)) {
+				cont(" *");
+				if (init_exec(init) && gpio && gpio->reset)
+					gpio->reset(gpio, func.func);
+			}
+			cont("\n");
+		}
+	}
+
+	init->offset += count;
+}
+
+static struct nvbios_init_opcode {
+	void (*exec)(struct nvbios_init *);
+} init_opcode[] = {
+	[0x32] = { init_io_restrict_prog },
+	[0x33] = { init_repeat },
+	[0x34] = { init_io_restrict_pll },
+	[0x36] = { init_end_repeat },
+	[0x37] = { init_copy },
+	[0x38] = { init_not },
+	[0x39] = { init_io_flag_condition },
+	[0x3a] = { init_dp_condition },
+	[0x3b] = { init_io_mask_or },
+	[0x3c] = { init_io_or },
+	[0x47] = { init_andn_reg },
+	[0x48] = { init_or_reg },
+	[0x49] = { init_idx_addr_latched },
+	[0x4a] = { init_io_restrict_pll2 },
+	[0x4b] = { init_pll2 },
+	[0x4c] = { init_i2c_byte },
+	[0x4d] = { init_zm_i2c_byte },
+	[0x4e] = { init_zm_i2c },
+	[0x4f] = { init_tmds },
+	[0x50] = { init_zm_tmds_group },
+	[0x51] = { init_cr_idx_adr_latch },
+	[0x52] = { init_cr },
+	[0x53] = { init_zm_cr },
+	[0x54] = { init_zm_cr_group },
+	[0x56] = { init_condition_time },
+	[0x57] = { init_ltime },
+	[0x58] = { init_zm_reg_sequence },
+	[0x5b] = { init_sub_direct },
+	[0x5c] = { init_jump },
+	[0x5e] = { init_i2c_if },
+	[0x5f] = { init_copy_nv_reg },
+	[0x62] = { init_zm_index_io },
+	[0x63] = { init_compute_mem },
+	[0x65] = { init_reset },
+	[0x66] = { init_configure_mem },
+	[0x67] = { init_configure_clk },
+	[0x68] = { init_configure_preinit },
+	[0x69] = { init_io },
+	[0x6b] = { init_sub },
+	[0x6d] = { init_ram_condition },
+	[0x6e] = { init_nv_reg },
+	[0x6f] = { init_macro },
+	[0x71] = { init_done },
+	[0x72] = { init_resume },
+	[0x74] = { init_time },
+	[0x75] = { init_condition },
+	[0x76] = { init_io_condition },
+	[0x78] = { init_index_io },
+	[0x79] = { init_pll },
+	[0x7a] = { init_zm_reg },
+	[0x87] = { init_ram_restrict_pll },
+	[0x8c] = { init_reserved },
+	[0x8d] = { init_reserved },
+	[0x8e] = { init_gpio },
+	[0x8f] = { init_ram_restrict_zm_reg_group },
+	[0x90] = { init_copy_zm_reg },
+	[0x91] = { init_zm_reg_group },
+	[0x92] = { init_reserved },
+	[0x96] = { init_xlat },
+	[0x97] = { init_zm_mask_add },
+	[0x98] = { init_auxch },
+	[0x99] = { init_zm_auxch },
+	[0x9a] = { init_i2c_long_if },
+	[0xa9] = { init_gpio_ne },
+	[0xaa] = { init_reserved },
+};
+
+#define init_opcode_nr (sizeof(init_opcode) / sizeof(init_opcode[0]))
+
+int
+nvbios_exec(struct nvbios_init *init)
+{
+	init->nested++;
+	while (init->offset) {
+		u8 opcode = nv_ro08(init->bios, init->offset);
+		if (opcode >= init_opcode_nr || !init_opcode[opcode].exec) {
+			error("unknown opcode 0x%02x\n", opcode);
+			return -EINVAL;
+		}
+
+		init_opcode[opcode].exec(init);
+	}
+	init->nested--;
+	return 0;
+}
+
+int
+nvbios_init(struct nouveau_subdev *subdev, bool execute)
+{
+	struct nouveau_bios *bios = nouveau_bios(subdev);
+	int ret = 0;
+	int i = -1;
+	u16 data;
+
+	if (execute)
+		nv_info(bios, "running init tables\n");
+	while (!ret && (data = (init_script(bios, ++i)))) {
+		struct nvbios_init init = {
+			.subdev = subdev,
+			.bios = bios,
+			.offset = data,
+			.outp = NULL,
+			.crtc = -1,
+			.execute = execute ? 1 : 0,
+		};
+
+		ret = nvbios_exec(&init);
+	}
+
+	/* the vbios parser will run this right after the normal init
+	 * tables, whereas the binary driver appears to run it later.
+	 */
+	if (!ret && (data = init_unknown_script(bios))) {
+		struct nvbios_init init = {
+			.subdev = subdev,
+			.bios = bios,
+			.offset = data,
+			.outp = NULL,
+			.crtc = -1,
+			.execute = execute ? 1 : 0,
+		};
+
+		ret = nvbios_exec(&init);
+	}
+
+	return ret;
+}
