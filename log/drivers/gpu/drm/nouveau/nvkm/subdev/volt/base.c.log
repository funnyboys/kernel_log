commit ff5354120fa1e3c0654f7bda5a8614f37daf387c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 18 11:18:45 2016 +1000

    drm/nouveau/bios/volt: pointers are 32-bit
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 5b5cc5cd08a9..e344901cfdc7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -189,7 +189,7 @@ nvkm_volt_parse_bios(struct nvkm_bios *bios, struct nvkm_volt *volt)
 	struct nvbios_volt_entry ivid;
 	struct nvbios_volt info;
 	u8  ver, hdr, cnt, len;
-	u16 data;
+	u32 data;
 	int i;
 
 	data = nvbios_volt_parse(bios, &ver, &hdr, &cnt, &len, &info);

commit 60fb7064e495bd70dd2151b18536ed969806b98e
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 18 11:22:33 2016 +1000

    drm/nouveau/bios/vmap: pointers are 32-bit
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index e8569b04b55d..5b5cc5cd08a9 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -84,7 +84,7 @@ nvkm_volt_map_min(struct nvkm_volt *volt, u8 id)
 	struct nvkm_bios *bios = volt->subdev.device->bios;
 	struct nvbios_vmap_entry info;
 	u8  ver, len;
-	u16 vmap;
+	u32 vmap;
 
 	vmap = nvbios_vmap_entry_parse(bios, id, &ver, &len, &info);
 	if (vmap) {
@@ -106,7 +106,7 @@ nvkm_volt_map(struct nvkm_volt *volt, u8 id, u8 temp)
 	struct nvkm_bios *bios = volt->subdev.device->bios;
 	struct nvbios_vmap_entry info;
 	u8  ver, len;
-	u16 vmap;
+	u32 vmap;
 
 	vmap = nvbios_vmap_entry_parse(bios, id, &ver, &len, &info);
 	if (vmap) {

commit 321c258e9192377cff2cb34b9d12fca0ee60b13f
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Fri Sep 16 18:09:12 2016 +0900

    drm/nouveau/volt: use kernel's 64-bit signed division function
    
    Doing direct 64 bit divisions in kernel code leads to references to
    undefined symbols on 32 bit architectures. Replace such divisions with
    calls to div64_s64 to make the module usable on 32 bit archs.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Reviewed-by: Karol Herbst <karolherbst@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 90d234231eed..e8569b04b55d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -116,9 +116,9 @@ nvkm_volt_map(struct nvkm_volt *volt, u8 id, u8 temp)
 			return volt->speedo;
 
 		if (ver == 0x10 || (ver == 0x20 && info.mode == 0)) {
-			result  =  (s64)info.arg[0] / 10;
-			result += ((s64)info.arg[1] * volt->speedo) / 10;
-			result += ((s64)info.arg[2] * volt->speedo * volt->speedo) / 100000;
+			result  = div64_s64((s64)info.arg[0], 10);
+			result += div64_s64((s64)info.arg[1] * volt->speedo, 10);
+			result += div64_s64((s64)info.arg[2] * volt->speedo * volt->speedo, 100000);
 		} else if (ver == 0x20) {
 			switch (info.mode) {
 			/* 0x0 handled above! */

commit 114653c7593a4dd52cc1721b0d325d43b00e2371
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Tue Jul 12 21:36:09 2016 +0200

    drm/nouveau/volt: Make use of cvb coefficients
    
    I'm quite sure that those coefficients are real close, because while
    testing the biggest error compared to nvidia was around -1.5% (biggest
    error with right coefficients is 12.5mV / 600mV = 2%).
    
    These coefficients were REed by modifing the voltage map entries and by
    calculating the set voltage back until I was able to forecast which voltage
    nvidia sets for a given voltage map entry.
    
    With these formulars I am able to precisely predict at which exact
    temperature Nvidia down- or upvolts due to a changed therm reading.
    
    That's why I am quite sure these are right, or at least really really
    close.
    
    v4: Use better coefficients and speedo.
    v5: Add error message when speedo is missing.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 771419ff8338..90d234231eed 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -110,13 +110,47 @@ nvkm_volt_map(struct nvkm_volt *volt, u8 id, u8 temp)
 
 	vmap = nvbios_vmap_entry_parse(bios, id, &ver, &len, &info);
 	if (vmap) {
+		s64 result;
+
+		if (volt->speedo < 0)
+			return volt->speedo;
+
+		if (ver == 0x10 || (ver == 0x20 && info.mode == 0)) {
+			result  =  (s64)info.arg[0] / 10;
+			result += ((s64)info.arg[1] * volt->speedo) / 10;
+			result += ((s64)info.arg[2] * volt->speedo * volt->speedo) / 100000;
+		} else if (ver == 0x20) {
+			switch (info.mode) {
+			/* 0x0 handled above! */
+			case 0x1:
+				result =  ((s64)info.arg[0] * 15625) >> 18;
+				result += ((s64)info.arg[1] * volt->speedo * 15625) >> 18;
+				result += ((s64)info.arg[2] * temp * 15625) >> 10;
+				result += ((s64)info.arg[3] * volt->speedo * temp * 15625) >> 18;
+				result += ((s64)info.arg[4] * volt->speedo * volt->speedo * 15625) >> 30;
+				result += ((s64)info.arg[5] * temp * temp * 15625) >> 18;
+				break;
+			case 0x3:
+				result = (info.min + info.max) / 2;
+				break;
+			case 0x2:
+			default:
+				result = info.min;
+				break;
+			}
+		} else {
+			return -ENODEV;
+		}
+
+		result = min(max(result, (s64)info.min), (s64)info.max);
+
 		if (info.link != 0xff) {
 			int ret = nvkm_volt_map(volt, info.link, temp);
 			if (ret < 0)
 				return ret;
-			info.min += ret;
+			result += ret;
 		}
-		return info.min;
+		return result;
 	}
 
 	return id ? id * 10000 : -ENODEV;

commit 08de5743db9250dc915d85f9f7d1a9016a8f8975
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Sun Jul 17 20:05:45 2016 +0200

    drm/nouveau/volt/gf100-: Add speedo
    
    v5: Squashed speedo related commits.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index ec59d58becdc..771419ff8338 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -195,6 +195,14 @@ nvkm_volt_parse_bios(struct nvkm_bios *bios, struct nvkm_volt *volt)
 	}
 }
 
+static int
+nvkm_volt_speedo_read(struct nvkm_volt *volt)
+{
+	if (volt->func->speedo_read)
+		return volt->func->speedo_read(volt);
+	return -EINVAL;
+}
+
 static int
 nvkm_volt_init(struct nvkm_subdev *subdev)
 {
@@ -209,6 +217,21 @@ nvkm_volt_init(struct nvkm_subdev *subdev)
 	return 0;
 }
 
+static int
+nvkm_volt_oneinit(struct nvkm_subdev *subdev)
+{
+	struct nvkm_volt *volt = nvkm_volt(subdev);
+
+	volt->speedo = nvkm_volt_speedo_read(volt);
+	if (volt->speedo > 0)
+		nvkm_debug(&volt->subdev, "speedo %x\n", volt->speedo);
+
+	if (volt->func->oneinit)
+		return volt->func->oneinit(volt);
+
+	return 0;
+}
+
 static void *
 nvkm_volt_dtor(struct nvkm_subdev *subdev)
 {
@@ -219,6 +242,7 @@ static const struct nvkm_subdev_func
 nvkm_volt = {
 	.dtor = nvkm_volt_dtor,
 	.init = nvkm_volt_init,
+	.oneinit = nvkm_volt_oneinit,
 };
 
 void

commit 5e00e3263ba68bd32337063a43aa8467b27acd1d
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Tue Jul 12 21:36:08 2016 +0200

    drm/nouveau/volt: Don't require perfect fit
    
    If we calculate the voltage in the table right, we get all kinds of values,
    which never fit the hardware steps, so we use the closest higher value the
    hardware can do.
    
    v3: Simplify the implementation.
    v5: Initialize best_err with volt->max_uv.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 5e07bd3aaccc..ec59d58becdc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -51,18 +51,30 @@ static int
 nvkm_volt_set(struct nvkm_volt *volt, u32 uv)
 {
 	struct nvkm_subdev *subdev = &volt->subdev;
-	int i, ret = -EINVAL;
+	int i, ret = -EINVAL, best_err = volt->max_uv, best = -1;
 
 	if (volt->func->volt_set)
 		return volt->func->volt_set(volt, uv);
 
 	for (i = 0; i < volt->vid_nr; i++) {
-		if (volt->vid[i].uv == uv) {
-			ret = volt->func->vid_set(volt, volt->vid[i].vid);
-			nvkm_debug(subdev, "set %duv: %d\n", uv, ret);
+		int err = volt->vid[i].uv - uv;
+		if (err < 0 || err > best_err)
+			continue;
+
+		best_err = err;
+		best = i;
+		if (best_err == 0)
 			break;
-		}
 	}
+
+	if (best == -1) {
+		nvkm_error(subdev, "couldn't set %iuv\n", uv);
+		return ret;
+	}
+
+	ret = volt->func->vid_set(volt, volt->vid[best].vid);
+	nvkm_debug(subdev, "set req %duv to %duv: %d\n", uv,
+		   volt->vid[best].uv, ret);
 	return ret;
 }
 

commit 1f7f3d91ad38afc706f838fb5a642b21d28e4485
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Sat Jul 16 15:26:25 2016 +0200

    drm/nouveau/clk: Respect voltage limits in nvkm_cstate_prog
    
    We should never allow to select a cstate which current voltage (depending
    on the temperature) is higher than
    
    1. the max volt entries in the voltage map table.
    2. what tha gpu actually can volt to.
    
    v3: Use find_best for all cstates before actually trying.
        Add nvkm_cstate_get function to get cstate by index.
    v5: Cstates with voltages lower then min_uv are valid.
        Move nvkm_cstate_get into the previous commit.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 40ba088a5c81..5e07bd3aaccc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -88,7 +88,7 @@ nvkm_volt_map_min(struct nvkm_volt *volt, u8 id)
 	return id ? id * 10000 : -ENODEV;
 }
 
-static int
+int
 nvkm_volt_map(struct nvkm_volt *volt, u8 id, u8 temp)
 {
 	struct nvkm_bios *bios = volt->subdev.device->bios;

commit 8d08c264d2b26c7b9c10790f95464b21e28dc30d
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Tue Jul 12 21:36:08 2016 +0200

    drm/nouveau/volt: Add temperature parameter to nvkm_volt_map
    
    The voltage entries actually may map to a different voltage depending on
    the current temperature.
    
    v2: Only read the temperature when actually needed.
    v5: Be smarter about using max().
        Don't read the temperature anymore.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 960505be5e28..40ba088a5c81 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -26,6 +26,7 @@
 #include <subdev/bios.h>
 #include <subdev/bios/vmap.h>
 #include <subdev/bios/volt.h>
+#include <subdev/therm.h>
 
 int
 nvkm_volt_get(struct nvkm_volt *volt)
@@ -88,7 +89,7 @@ nvkm_volt_map_min(struct nvkm_volt *volt, u8 id)
 }
 
 static int
-nvkm_volt_map(struct nvkm_volt *volt, u8 id)
+nvkm_volt_map(struct nvkm_volt *volt, u8 id, u8 temp)
 {
 	struct nvkm_bios *bios = volt->subdev.device->bios;
 	struct nvbios_vmap_entry info;
@@ -98,7 +99,7 @@ nvkm_volt_map(struct nvkm_volt *volt, u8 id)
 	vmap = nvbios_vmap_entry_parse(bios, id, &ver, &len, &info);
 	if (vmap) {
 		if (info.link != 0xff) {
-			int ret = nvkm_volt_map(volt, info.link);
+			int ret = nvkm_volt_map(volt, info.link, temp);
 			if (ret < 0)
 				return ret;
 			info.min += ret;
@@ -110,20 +111,21 @@ nvkm_volt_map(struct nvkm_volt *volt, u8 id)
 }
 
 int
-nvkm_volt_set_id(struct nvkm_volt *volt, u8 id, u8 min_id, int condition)
+nvkm_volt_set_id(struct nvkm_volt *volt, u8 id, u8 min_id, u8 temp,
+		 int condition)
 {
 	int ret;
 
 	if (volt->func->set_id)
 		return volt->func->set_id(volt, id, condition);
 
-	ret = nvkm_volt_map(volt, id);
+	ret = nvkm_volt_map(volt, id, temp);
 	if (ret >= 0) {
 		int prev = nvkm_volt_get(volt);
 		if (!condition || prev < 0 ||
 		    (condition < 0 && ret < prev) ||
 		    (condition > 0 && ret > prev)) {
-			int min = nvkm_volt_map(volt, min_id);
+			int min = nvkm_volt_map(volt, min_id, temp);
 			if (min >= 0)
 				ret = max(min, ret);
 			ret = nvkm_volt_set(volt, ret);

commit fa6c4d8e2c614817c956a4ab59ab8bb24fb3653f
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Tue Jul 12 21:36:08 2016 +0200

    drm/nouveau/volt: Add min_id parameter to nvkm_volt_set_id
    
    Each pstate has its own voltage map entry like each cstate has.
    
    The voltages of those entries act as a floor value for the currently
    selected pstate and nvidia never sets a voltage below them.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 8445e4c9fe54..960505be5e28 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -110,7 +110,7 @@ nvkm_volt_map(struct nvkm_volt *volt, u8 id)
 }
 
 int
-nvkm_volt_set_id(struct nvkm_volt *volt, u8 id, int condition)
+nvkm_volt_set_id(struct nvkm_volt *volt, u8 id, u8 min_id, int condition)
 {
 	int ret;
 
@@ -123,6 +123,9 @@ nvkm_volt_set_id(struct nvkm_volt *volt, u8 id, int condition)
 		if (!condition || prev < 0 ||
 		    (condition < 0 && ret < prev) ||
 		    (condition > 0 && ret > prev)) {
+			int min = nvkm_volt_map(volt, min_id);
+			if (min >= 0)
+				ret = max(min, ret);
 			ret = nvkm_volt_set(volt, ret);
 		} else {
 			ret = 0;

commit 4a4555a7f1dd60fe34336f440ff1de73313820ee
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Tue Jul 12 21:36:08 2016 +0200

    drm/nouveau/volt: Parse the max voltage map entries
    
    There are at least three "max" entries, which specify the max voltage.
    Because they are actually normal voltage map entries, they can also be
    affected by the temperature.
    
    Nvidia respects those entries and if they get changed, nvidia uses the
    lower voltage from all three.
    
    We shouldn't exceed those voltages at any given time.
    
    v2: State what those entries do in the source.
    v3: Add the third max entry.
    v5: Better describe the entries.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 6eeb9d9de334..8445e4c9fe54 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -216,9 +216,22 @@ nvkm_volt_ctor(const struct nvkm_volt_func *func, struct nvkm_device *device,
 
 	/* Assuming the non-bios device should build the voltage table later */
 	if (bios) {
+		u8 ver, hdr, cnt, len;
+		struct nvbios_vmap vmap;
+
 		nvkm_volt_parse_bios(bios, volt);
 		nvkm_debug(&volt->subdev, "min: %iuv max: %iuv\n",
 			   volt->min_uv, volt->max_uv);
+
+		if (nvbios_vmap_parse(bios, &ver, &hdr, &cnt, &len, &vmap)) {
+			volt->max0_id = vmap.max0;
+			volt->max1_id = vmap.max1;
+			volt->max2_id = vmap.max2;
+		} else {
+			volt->max0_id = 0xff;
+			volt->max1_id = 0xff;
+			volt->max2_id = 0xff;
+		}
 	}
 
 	if (volt->vid_nr) {

commit 17d063dbdce3bab04957b2281dcdceecb7407170
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Tue Jul 12 21:36:08 2016 +0200

    drm/nouveau/clk: Don't create cstates with voltages higher than what the gpu can do
    
    nvkm_volt_map_min is a copy of nvkm_volt_map, which always returns the
    lowest possible voltage for a cstate.
    
    nvkm_volt_map will get a temperature parameter there later and also fix
    the voltage calculation, so that this functions will be completly
    different later.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Tested-by: Pierre Moreau <pierre.morrow@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 53a1cba6ad8d..6eeb9d9de334 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -65,6 +65,28 @@ nvkm_volt_set(struct nvkm_volt *volt, u32 uv)
 	return ret;
 }
 
+int
+nvkm_volt_map_min(struct nvkm_volt *volt, u8 id)
+{
+	struct nvkm_bios *bios = volt->subdev.device->bios;
+	struct nvbios_vmap_entry info;
+	u8  ver, len;
+	u16 vmap;
+
+	vmap = nvbios_vmap_entry_parse(bios, id, &ver, &len, &info);
+	if (vmap) {
+		if (info.link != 0xff) {
+			int ret = nvkm_volt_map_min(volt, info.link);
+			if (ret < 0)
+				return ret;
+			info.min += ret;
+		}
+		return info.min;
+	}
+
+	return id ? id * 10000 : -ENODEV;
+}
+
 static int
 nvkm_volt_map(struct nvkm_volt *volt, u8 id)
 {

commit 17f486de6a56ee255eaa6dae272f70255cc41d3d
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Tue Jul 12 21:36:08 2016 +0200

    drm/nouveau/volt: Properly detect entry based voltage tables
    
    There is a field in the voltage table which tells us if the VIDs are taken
    from the entries or calculated through the header.
    
    v2: Don't break older versions.
    v5: Reverse flag name.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Tested-by: Pierre Moreau <pierre.morrow@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 1c3d23b0e84a..53a1cba6ad8d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -112,6 +112,7 @@ nvkm_volt_set_id(struct nvkm_volt *volt, u8 id, int condition)
 static void
 nvkm_volt_parse_bios(struct nvkm_bios *bios, struct nvkm_volt *volt)
 {
+	struct nvkm_subdev *subdev = &bios->subdev;
 	struct nvbios_volt_entry ivid;
 	struct nvbios_volt info;
 	u8  ver, hdr, cnt, len;
@@ -119,7 +120,8 @@ nvkm_volt_parse_bios(struct nvkm_bios *bios, struct nvkm_volt *volt)
 	int i;
 
 	data = nvbios_volt_parse(bios, &ver, &hdr, &cnt, &len, &info);
-	if (data && info.vidmask && info.base && info.step) {
+	if (data && info.vidmask && info.base && info.step && info.ranged) {
+		nvkm_debug(subdev, "found ranged based VIDs\n");
 		volt->min_uv = info.min;
 		volt->max_uv = info.max;
 		for (i = 0; i < info.vidmask + 1; i++) {
@@ -132,7 +134,8 @@ nvkm_volt_parse_bios(struct nvkm_bios *bios, struct nvkm_volt *volt)
 			info.base += info.step;
 		}
 		volt->vid_mask = info.vidmask;
-	} else if (data && info.vidmask) {
+	} else if (data && info.vidmask && !info.ranged) {
+		nvkm_debug(subdev, "found entry based VIDs\n");
 		volt->min_uv = 0xffffffff;
 		volt->max_uv = 0;
 		for (i = 0; i < cnt; i++) {

commit 437bb44d382c9570307393bad8d4eb0bc6e21b62
Author: Karol Herbst <nouveau@karolherbst.de>
Date:   Fri Feb 26 07:49:08 2016 +0100

    drm/nouveau/volt: save the voltage range we are able to set
    
    We shouldn't set voltages below the min or above the max voltage the gpu is
    able to set, so save the range for future lookups.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.de>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Tested-by: Pierre Moreau <pierre.morrow@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 6b2d7531a7ff..1c3d23b0e84a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -120,6 +120,8 @@ nvkm_volt_parse_bios(struct nvkm_bios *bios, struct nvkm_volt *volt)
 
 	data = nvbios_volt_parse(bios, &ver, &hdr, &cnt, &len, &info);
 	if (data && info.vidmask && info.base && info.step) {
+		volt->min_uv = info.min;
+		volt->max_uv = info.max;
 		for (i = 0; i < info.vidmask + 1; i++) {
 			if (info.base >= info.min &&
 				info.base <= info.max) {
@@ -131,6 +133,8 @@ nvkm_volt_parse_bios(struct nvkm_bios *bios, struct nvkm_volt *volt)
 		}
 		volt->vid_mask = info.vidmask;
 	} else if (data && info.vidmask) {
+		volt->min_uv = 0xffffffff;
+		volt->max_uv = 0;
 		for (i = 0; i < cnt; i++) {
 			data = nvbios_volt_entry_parse(bios, i, &ver, &hdr,
 						       &ivid);
@@ -138,9 +142,14 @@ nvkm_volt_parse_bios(struct nvkm_bios *bios, struct nvkm_volt *volt)
 				volt->vid[volt->vid_nr].uv = ivid.voltage;
 				volt->vid[volt->vid_nr].vid = ivid.vid;
 				volt->vid_nr++;
+				volt->min_uv = min(volt->min_uv, ivid.voltage);
+				volt->max_uv = max(volt->max_uv, ivid.voltage);
 			}
 		}
 		volt->vid_mask = info.vidmask;
+	} else if (data && info.type == NVBIOS_VOLT_PWM) {
+		volt->min_uv = info.base;
+		volt->max_uv = info.base + info.pwm_range;
 	}
 }
 
@@ -181,8 +190,11 @@ nvkm_volt_ctor(const struct nvkm_volt_func *func, struct nvkm_device *device,
 	volt->func = func;
 
 	/* Assuming the non-bios device should build the voltage table later */
-	if (bios)
+	if (bios) {
 		nvkm_volt_parse_bios(bios, volt);
+		nvkm_debug(&volt->subdev, "min: %iuv max: %iuv\n",
+			   volt->min_uv, volt->max_uv);
+	}
 
 	if (volt->vid_nr) {
 		for (i = 0; i < volt->vid_nr; i++) {

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 50b5649ad1a4..6b2d7531a7ff 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -177,7 +177,7 @@ nvkm_volt_ctor(const struct nvkm_volt_func *func, struct nvkm_device *device,
 	struct nvkm_bios *bios = device->bios;
 	int i;
 
-	nvkm_subdev_ctor(&nvkm_volt, device, index, 0, &volt->subdev);
+	nvkm_subdev_ctor(&nvkm_volt, device, index, &volt->subdev);
 	volt->func = func;
 
 	/* Assuming the non-bios device should build the voltage table later */

commit 4c58a05b4a4709db7a1667d740f3ac2725fa3ce4
Author: Martin Peres <martin.peres@free.fr>
Date:   Wed Sep 9 04:05:51 2015 +0300

    drm/nouveau/volt: add support for non-vid-based voltage controllers
    
    This patch is not ideal but it definitely beats a rewrite of the current
    interface and is very self-contained.
    
    Signed-off-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 4752dbd33923..50b5649ad1a4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -30,7 +30,12 @@
 int
 nvkm_volt_get(struct nvkm_volt *volt)
 {
-	int ret = volt->func->vid_get(volt), i;
+	int ret, i;
+
+	if (volt->func->volt_get)
+		return volt->func->volt_get(volt);
+
+	ret = volt->func->vid_get(volt);
 	if (ret >= 0) {
 		for (i = 0; i < volt->vid_nr; i++) {
 			if (volt->vid[i].vid == ret)
@@ -46,6 +51,10 @@ nvkm_volt_set(struct nvkm_volt *volt, u32 uv)
 {
 	struct nvkm_subdev *subdev = &volt->subdev;
 	int i, ret = -EINVAL;
+
+	if (volt->func->volt_set)
+		return volt->func->volt_set(volt, uv);
+
 	for (i = 0; i < volt->vid_nr; i++) {
 		if (volt->vid[i].uv == uv) {
 			ret = volt->func->vid_set(volt, volt->vid[i].vid);

commit 437b2296ced574eada632b11346e22f6b0103e17
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:21 2015 +1000

    drm/nouveau/volt: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index c1668c86f521..4752dbd33923 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -21,44 +21,39 @@
  *
  * Authors: Ben Skeggs
  */
-#include <subdev/volt.h>
+#include "priv.h"
+
 #include <subdev/bios.h>
 #include <subdev/bios/vmap.h>
 #include <subdev/bios/volt.h>
 
-static int
+int
 nvkm_volt_get(struct nvkm_volt *volt)
 {
-	if (volt->vid_get) {
-		int ret = volt->vid_get(volt), i;
-		if (ret >= 0) {
-			for (i = 0; i < volt->vid_nr; i++) {
-				if (volt->vid[i].vid == ret)
-					return volt->vid[i].uv;
-			}
-			ret = -EINVAL;
+	int ret = volt->func->vid_get(volt), i;
+	if (ret >= 0) {
+		for (i = 0; i < volt->vid_nr; i++) {
+			if (volt->vid[i].vid == ret)
+				return volt->vid[i].uv;
 		}
-		return ret;
+		ret = -EINVAL;
 	}
-	return -ENODEV;
+	return ret;
 }
 
 static int
 nvkm_volt_set(struct nvkm_volt *volt, u32 uv)
 {
 	struct nvkm_subdev *subdev = &volt->subdev;
-	if (volt->vid_set) {
-		int i, ret = -EINVAL;
-		for (i = 0; i < volt->vid_nr; i++) {
-			if (volt->vid[i].uv == uv) {
-				ret = volt->vid_set(volt, volt->vid[i].vid);
-				nvkm_debug(subdev, "set %duv: %d\n", uv, ret);
-				break;
-			}
+	int i, ret = -EINVAL;
+	for (i = 0; i < volt->vid_nr; i++) {
+		if (volt->vid[i].uv == uv) {
+			ret = volt->func->vid_set(volt, volt->vid[i].vid);
+			nvkm_debug(subdev, "set %duv: %d\n", uv, ret);
+			break;
 		}
-		return ret;
 	}
-	return -ENODEV;
+	return ret;
 }
 
 static int
@@ -83,10 +78,15 @@ nvkm_volt_map(struct nvkm_volt *volt, u8 id)
 	return id ? id * 10000 : -ENODEV;
 }
 
-static int
+int
 nvkm_volt_set_id(struct nvkm_volt *volt, u8 id, int condition)
 {
-	int ret = nvkm_volt_map(volt, id);
+	int ret;
+
+	if (volt->func->set_id)
+		return volt->func->set_id(volt, id, condition);
+
+	ret = nvkm_volt_map(volt, id);
 	if (ret >= 0) {
 		int prev = nvkm_volt_get(volt);
 		if (!condition || prev < 0 ||
@@ -135,53 +135,41 @@ nvkm_volt_parse_bios(struct nvkm_bios *bios, struct nvkm_volt *volt)
 	}
 }
 
-int
-_nvkm_volt_init(struct nvkm_object *object)
+static int
+nvkm_volt_init(struct nvkm_subdev *subdev)
 {
-	struct nvkm_volt *volt = (void *)object;
-	struct nvkm_subdev *subdev = &volt->subdev;
-	int ret;
-
-	ret = nvkm_subdev_init_old(&volt->subdev);
-	if (ret)
-		return ret;
-
-	ret = volt->get(volt);
+	struct nvkm_volt *volt = nvkm_volt(subdev);
+	int ret = nvkm_volt_get(volt);
 	if (ret < 0) {
 		if (ret != -ENODEV)
 			nvkm_debug(subdev, "current voltage unknown\n");
 		return 0;
 	}
-
 	nvkm_debug(subdev, "current voltage: %duv\n", ret);
 	return 0;
 }
 
-void
-_nvkm_volt_dtor(struct nvkm_object *object)
+static void *
+nvkm_volt_dtor(struct nvkm_subdev *subdev)
 {
-	struct nvkm_volt *volt = (void *)object;
-	nvkm_subdev_destroy(&volt->subdev);
+	return nvkm_volt(subdev);
 }
 
-int
-nvkm_volt_create_(struct nvkm_object *parent, struct nvkm_object *engine,
-		  struct nvkm_oclass *oclass, int length, void **pobject)
+static const struct nvkm_subdev_func
+nvkm_volt = {
+	.dtor = nvkm_volt_dtor,
+	.init = nvkm_volt_init,
+};
+
+void
+nvkm_volt_ctor(const struct nvkm_volt_func *func, struct nvkm_device *device,
+	       int index, struct nvkm_volt *volt)
 {
-	struct nvkm_device *device = (void *)parent;
 	struct nvkm_bios *bios = device->bios;
-	struct nvkm_volt *volt;
-	int ret, i;
-
-	ret = nvkm_subdev_create_(parent, engine, oclass, 0, "VOLT",
-				  "voltage", length, pobject);
-	volt = *pobject;
-	if (ret)
-		return ret;
+	int i;
 
-	volt->get = nvkm_volt_get;
-	volt->set = nvkm_volt_set;
-	volt->set_id = nvkm_volt_set_id;
+	nvkm_subdev_ctor(&nvkm_volt, device, index, 0, &volt->subdev);
+	volt->func = func;
 
 	/* Assuming the non-bios device should build the voltage table later */
 	if (bios)
@@ -192,16 +180,15 @@ nvkm_volt_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 			nvkm_debug(&volt->subdev, "VID %02x: %duv\n",
 				   volt->vid[i].vid, volt->vid[i].uv);
 		}
-
-		/*XXX: this is an assumption.. there probably exists boards
-		 * out there with i2c-connected voltage controllers too..
-		 */
-		ret = nvkm_voltgpio_init(volt);
-		if (ret == 0) {
-			volt->vid_get = nvkm_voltgpio_get;
-			volt->vid_set = nvkm_voltgpio_set;
-		}
 	}
+}
 
-	return ret;
+int
+nvkm_volt_new_(const struct nvkm_volt_func *func, struct nvkm_device *device,
+	       int index, struct nvkm_volt **pvolt)
+{
+	if (!(*pvolt = kzalloc(sizeof(**pvolt), GFP_KERNEL)))
+		return -ENOMEM;
+	nvkm_volt_ctor(func, device, index, *pvolt);
+	return 0;
 }

commit 46484438ab7dbab6ed29cf647d029e0b1ef3d9d8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/bios: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 88e5f62ec772..c1668c86f521 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -64,7 +64,7 @@ nvkm_volt_set(struct nvkm_volt *volt, u32 uv)
 static int
 nvkm_volt_map(struct nvkm_volt *volt, u8 id)
 {
-	struct nvkm_bios *bios = nvkm_bios(volt);
+	struct nvkm_bios *bios = volt->subdev.device->bios;
 	struct nvbios_vmap_entry info;
 	u8  ver, len;
 	u16 vmap;

commit 3a8c3400f3e74638bedd0d2410416aa8b794c0fd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/subdev: rename some functions to avoid upcoming conflicts
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 67650a351a96..88e5f62ec772 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -142,7 +142,7 @@ _nvkm_volt_init(struct nvkm_object *object)
 	struct nvkm_subdev *subdev = &volt->subdev;
 	int ret;
 
-	ret = nvkm_subdev_init(&volt->subdev);
+	ret = nvkm_subdev_init_old(&volt->subdev);
 	if (ret)
 		return ret;
 

commit 185eda33394af09dbb0c9d330811718e84c0b070
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:12 2015 +1000

    drm/nouveau/volt: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 53a173694fb4..67650a351a96 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -46,12 +46,13 @@ nvkm_volt_get(struct nvkm_volt *volt)
 static int
 nvkm_volt_set(struct nvkm_volt *volt, u32 uv)
 {
+	struct nvkm_subdev *subdev = &volt->subdev;
 	if (volt->vid_set) {
 		int i, ret = -EINVAL;
 		for (i = 0; i < volt->vid_nr; i++) {
 			if (volt->vid[i].uv == uv) {
 				ret = volt->vid_set(volt, volt->vid[i].vid);
-				nv_debug(volt, "set %duv: %d\n", uv, ret);
+				nvkm_debug(subdev, "set %duv: %d\n", uv, ret);
 				break;
 			}
 		}
@@ -138,6 +139,7 @@ int
 _nvkm_volt_init(struct nvkm_object *object)
 {
 	struct nvkm_volt *volt = (void *)object;
+	struct nvkm_subdev *subdev = &volt->subdev;
 	int ret;
 
 	ret = nvkm_subdev_init(&volt->subdev);
@@ -147,11 +149,11 @@ _nvkm_volt_init(struct nvkm_object *object)
 	ret = volt->get(volt);
 	if (ret < 0) {
 		if (ret != -ENODEV)
-			nv_debug(volt, "current voltage unknown\n");
+			nvkm_debug(subdev, "current voltage unknown\n");
 		return 0;
 	}
 
-	nv_info(volt, "GPU voltage: %duv\n", ret);
+	nvkm_debug(subdev, "current voltage: %duv\n", ret);
 	return 0;
 }
 
@@ -166,7 +168,8 @@ int
 nvkm_volt_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 		  struct nvkm_oclass *oclass, int length, void **pobject)
 {
-	struct nvkm_bios *bios = nvkm_bios(parent);
+	struct nvkm_device *device = (void *)parent;
+	struct nvkm_bios *bios = device->bios;
 	struct nvkm_volt *volt;
 	int ret, i;
 
@@ -186,8 +189,8 @@ nvkm_volt_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	if (volt->vid_nr) {
 		for (i = 0; i < volt->vid_nr; i++) {
-			nv_debug(volt, "VID %02x: %duv\n",
-				 volt->vid[i].vid, volt->vid[i].uv);
+			nvkm_debug(&volt->subdev, "VID %02x: %duv\n",
+				   volt->vid[i].vid, volt->vid[i].uv);
 		}
 
 		/*XXX: this is an assumption.. there probably exists boards

commit 6052dc5775ac0be49db3e25d2719c72a250189a2
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/volt: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 39f15803f2d4..53a173694fb4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -140,7 +140,7 @@ _nvkm_volt_init(struct nvkm_object *object)
 	struct nvkm_volt *volt = (void *)object;
 	int ret;
 
-	ret = nvkm_subdev_init(&volt->base);
+	ret = nvkm_subdev_init(&volt->subdev);
 	if (ret)
 		return ret;
 
@@ -159,7 +159,7 @@ void
 _nvkm_volt_dtor(struct nvkm_object *object)
 {
 	struct nvkm_volt *volt = (void *)object;
-	nvkm_subdev_destroy(&volt->base);
+	nvkm_subdev_destroy(&volt->subdev);
 }
 
 int

commit de3aaa6651ed7075e293c4e48c482012e8e8c87d
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:13:36 2015 +1000

    drm/nouveau/volt: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
index 26ccd8df193f..39f15803f2d4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -21,15 +21,13 @@
  *
  * Authors: Ben Skeggs
  */
-
 #include <subdev/volt.h>
-
 #include <subdev/bios.h>
 #include <subdev/bios/vmap.h>
 #include <subdev/bios/volt.h>
 
 static int
-nouveau_volt_get(struct nouveau_volt *volt)
+nvkm_volt_get(struct nvkm_volt *volt)
 {
 	if (volt->vid_get) {
 		int ret = volt->vid_get(volt), i;
@@ -46,7 +44,7 @@ nouveau_volt_get(struct nouveau_volt *volt)
 }
 
 static int
-nouveau_volt_set(struct nouveau_volt *volt, u32 uv)
+nvkm_volt_set(struct nvkm_volt *volt, u32 uv)
 {
 	if (volt->vid_set) {
 		int i, ret = -EINVAL;
@@ -63,9 +61,9 @@ nouveau_volt_set(struct nouveau_volt *volt, u32 uv)
 }
 
 static int
-nouveau_volt_map(struct nouveau_volt *volt, u8 id)
+nvkm_volt_map(struct nvkm_volt *volt, u8 id)
 {
-	struct nouveau_bios *bios = nouveau_bios(volt);
+	struct nvkm_bios *bios = nvkm_bios(volt);
 	struct nvbios_vmap_entry info;
 	u8  ver, len;
 	u16 vmap;
@@ -73,7 +71,7 @@ nouveau_volt_map(struct nouveau_volt *volt, u8 id)
 	vmap = nvbios_vmap_entry_parse(bios, id, &ver, &len, &info);
 	if (vmap) {
 		if (info.link != 0xff) {
-			int ret = nouveau_volt_map(volt, info.link);
+			int ret = nvkm_volt_map(volt, info.link);
 			if (ret < 0)
 				return ret;
 			info.min += ret;
@@ -85,15 +83,15 @@ nouveau_volt_map(struct nouveau_volt *volt, u8 id)
 }
 
 static int
-nouveau_volt_set_id(struct nouveau_volt *volt, u8 id, int condition)
+nvkm_volt_set_id(struct nvkm_volt *volt, u8 id, int condition)
 {
-	int ret = nouveau_volt_map(volt, id);
+	int ret = nvkm_volt_map(volt, id);
 	if (ret >= 0) {
-		int prev = nouveau_volt_get(volt);
+		int prev = nvkm_volt_get(volt);
 		if (!condition || prev < 0 ||
 		    (condition < 0 && ret < prev) ||
 		    (condition > 0 && ret > prev)) {
-			ret = nouveau_volt_set(volt, ret);
+			ret = nvkm_volt_set(volt, ret);
 		} else {
 			ret = 0;
 		}
@@ -101,8 +99,8 @@ nouveau_volt_set_id(struct nouveau_volt *volt, u8 id, int condition)
 	return ret;
 }
 
-static void nouveau_volt_parse_bios(struct nouveau_bios *bios,
-		struct nouveau_volt *volt)
+static void
+nvkm_volt_parse_bios(struct nvkm_bios *bios, struct nvkm_volt *volt)
 {
 	struct nvbios_volt_entry ivid;
 	struct nvbios_volt info;
@@ -125,7 +123,7 @@ static void nouveau_volt_parse_bios(struct nouveau_bios *bios,
 	} else if (data && info.vidmask) {
 		for (i = 0; i < cnt; i++) {
 			data = nvbios_volt_entry_parse(bios, i, &ver, &hdr,
-							  &ivid);
+						       &ivid);
 			if (data) {
 				volt->vid[volt->vid_nr].uv = ivid.voltage;
 				volt->vid[volt->vid_nr].vid = ivid.vid;
@@ -137,12 +135,12 @@ static void nouveau_volt_parse_bios(struct nouveau_bios *bios,
 }
 
 int
-_nouveau_volt_init(struct nouveau_object *object)
+_nvkm_volt_init(struct nvkm_object *object)
 {
-	struct nouveau_volt *volt = (void *)object;
+	struct nvkm_volt *volt = (void *)object;
 	int ret;
 
-	ret = nouveau_subdev_init(&volt->base);
+	ret = nvkm_subdev_init(&volt->base);
 	if (ret)
 		return ret;
 
@@ -158,34 +156,33 @@ _nouveau_volt_init(struct nouveau_object *object)
 }
 
 void
-_nouveau_volt_dtor(struct nouveau_object *object)
+_nvkm_volt_dtor(struct nvkm_object *object)
 {
-	struct nouveau_volt *volt = (void *)object;
-	nouveau_subdev_destroy(&volt->base);
+	struct nvkm_volt *volt = (void *)object;
+	nvkm_subdev_destroy(&volt->base);
 }
 
 int
-nouveau_volt_create_(struct nouveau_object *parent,
-		     struct nouveau_object *engine,
-		     struct nouveau_oclass *oclass, int length, void **pobject)
+nvkm_volt_create_(struct nvkm_object *parent, struct nvkm_object *engine,
+		  struct nvkm_oclass *oclass, int length, void **pobject)
 {
-	struct nouveau_bios *bios = nouveau_bios(parent);
-	struct nouveau_volt *volt;
+	struct nvkm_bios *bios = nvkm_bios(parent);
+	struct nvkm_volt *volt;
 	int ret, i;
 
-	ret = nouveau_subdev_create_(parent, engine, oclass, 0, "VOLT",
-				     "voltage", length, pobject);
+	ret = nvkm_subdev_create_(parent, engine, oclass, 0, "VOLT",
+				  "voltage", length, pobject);
 	volt = *pobject;
 	if (ret)
 		return ret;
 
-	volt->get = nouveau_volt_get;
-	volt->set = nouveau_volt_set;
-	volt->set_id = nouveau_volt_set_id;
+	volt->get = nvkm_volt_get;
+	volt->set = nvkm_volt_set;
+	volt->set_id = nvkm_volt_set_id;
 
 	/* Assuming the non-bios device should build the voltage table later */
 	if (bios)
-		nouveau_volt_parse_bios(bios, volt);
+		nvkm_volt_parse_bios(bios, volt);
 
 	if (volt->vid_nr) {
 		for (i = 0; i < volt->vid_nr; i++) {
@@ -196,10 +193,10 @@ nouveau_volt_create_(struct nouveau_object *parent,
 		/*XXX: this is an assumption.. there probably exists boards
 		 * out there with i2c-connected voltage controllers too..
 		 */
-		ret = nouveau_voltgpio_init(volt);
+		ret = nvkm_voltgpio_init(volt);
 		if (ret == 0) {
-			volt->vid_get = nouveau_voltgpio_get;
-			volt->vid_set = nouveau_voltgpio_set;
+			volt->vid_get = nvkm_voltgpio_get;
+			volt->vid_set = nvkm_voltgpio_set;
 		}
 	}
 

commit c39f472e9f14e49a9bc091977ced0ec45fc00c57
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 22:13:14 2015 +1000

    drm/nouveau: remove symlinks, move core/ to nvkm/ (no code changes)
    
    The symlinks were annoying some people, and they're not used anywhere
    else in the kernel tree.  The include directory structure has been
    changed so that symlinks aren't needed anymore.
    
    NVKM has been moved from core/ to nvkm/ to make it more obvious as to
    what the directory is for, and as some minor prep for when NVKM gets
    split out into its own module (virt) at a later date.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
new file mode 100644
index 000000000000..26ccd8df193f
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c
@@ -0,0 +1,207 @@
+/*
+ * Copyright 2013 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <subdev/volt.h>
+
+#include <subdev/bios.h>
+#include <subdev/bios/vmap.h>
+#include <subdev/bios/volt.h>
+
+static int
+nouveau_volt_get(struct nouveau_volt *volt)
+{
+	if (volt->vid_get) {
+		int ret = volt->vid_get(volt), i;
+		if (ret >= 0) {
+			for (i = 0; i < volt->vid_nr; i++) {
+				if (volt->vid[i].vid == ret)
+					return volt->vid[i].uv;
+			}
+			ret = -EINVAL;
+		}
+		return ret;
+	}
+	return -ENODEV;
+}
+
+static int
+nouveau_volt_set(struct nouveau_volt *volt, u32 uv)
+{
+	if (volt->vid_set) {
+		int i, ret = -EINVAL;
+		for (i = 0; i < volt->vid_nr; i++) {
+			if (volt->vid[i].uv == uv) {
+				ret = volt->vid_set(volt, volt->vid[i].vid);
+				nv_debug(volt, "set %duv: %d\n", uv, ret);
+				break;
+			}
+		}
+		return ret;
+	}
+	return -ENODEV;
+}
+
+static int
+nouveau_volt_map(struct nouveau_volt *volt, u8 id)
+{
+	struct nouveau_bios *bios = nouveau_bios(volt);
+	struct nvbios_vmap_entry info;
+	u8  ver, len;
+	u16 vmap;
+
+	vmap = nvbios_vmap_entry_parse(bios, id, &ver, &len, &info);
+	if (vmap) {
+		if (info.link != 0xff) {
+			int ret = nouveau_volt_map(volt, info.link);
+			if (ret < 0)
+				return ret;
+			info.min += ret;
+		}
+		return info.min;
+	}
+
+	return id ? id * 10000 : -ENODEV;
+}
+
+static int
+nouveau_volt_set_id(struct nouveau_volt *volt, u8 id, int condition)
+{
+	int ret = nouveau_volt_map(volt, id);
+	if (ret >= 0) {
+		int prev = nouveau_volt_get(volt);
+		if (!condition || prev < 0 ||
+		    (condition < 0 && ret < prev) ||
+		    (condition > 0 && ret > prev)) {
+			ret = nouveau_volt_set(volt, ret);
+		} else {
+			ret = 0;
+		}
+	}
+	return ret;
+}
+
+static void nouveau_volt_parse_bios(struct nouveau_bios *bios,
+		struct nouveau_volt *volt)
+{
+	struct nvbios_volt_entry ivid;
+	struct nvbios_volt info;
+	u8  ver, hdr, cnt, len;
+	u16 data;
+	int i;
+
+	data = nvbios_volt_parse(bios, &ver, &hdr, &cnt, &len, &info);
+	if (data && info.vidmask && info.base && info.step) {
+		for (i = 0; i < info.vidmask + 1; i++) {
+			if (info.base >= info.min &&
+				info.base <= info.max) {
+				volt->vid[volt->vid_nr].uv = info.base;
+				volt->vid[volt->vid_nr].vid = i;
+				volt->vid_nr++;
+			}
+			info.base += info.step;
+		}
+		volt->vid_mask = info.vidmask;
+	} else if (data && info.vidmask) {
+		for (i = 0; i < cnt; i++) {
+			data = nvbios_volt_entry_parse(bios, i, &ver, &hdr,
+							  &ivid);
+			if (data) {
+				volt->vid[volt->vid_nr].uv = ivid.voltage;
+				volt->vid[volt->vid_nr].vid = ivid.vid;
+				volt->vid_nr++;
+			}
+		}
+		volt->vid_mask = info.vidmask;
+	}
+}
+
+int
+_nouveau_volt_init(struct nouveau_object *object)
+{
+	struct nouveau_volt *volt = (void *)object;
+	int ret;
+
+	ret = nouveau_subdev_init(&volt->base);
+	if (ret)
+		return ret;
+
+	ret = volt->get(volt);
+	if (ret < 0) {
+		if (ret != -ENODEV)
+			nv_debug(volt, "current voltage unknown\n");
+		return 0;
+	}
+
+	nv_info(volt, "GPU voltage: %duv\n", ret);
+	return 0;
+}
+
+void
+_nouveau_volt_dtor(struct nouveau_object *object)
+{
+	struct nouveau_volt *volt = (void *)object;
+	nouveau_subdev_destroy(&volt->base);
+}
+
+int
+nouveau_volt_create_(struct nouveau_object *parent,
+		     struct nouveau_object *engine,
+		     struct nouveau_oclass *oclass, int length, void **pobject)
+{
+	struct nouveau_bios *bios = nouveau_bios(parent);
+	struct nouveau_volt *volt;
+	int ret, i;
+
+	ret = nouveau_subdev_create_(parent, engine, oclass, 0, "VOLT",
+				     "voltage", length, pobject);
+	volt = *pobject;
+	if (ret)
+		return ret;
+
+	volt->get = nouveau_volt_get;
+	volt->set = nouveau_volt_set;
+	volt->set_id = nouveau_volt_set_id;
+
+	/* Assuming the non-bios device should build the voltage table later */
+	if (bios)
+		nouveau_volt_parse_bios(bios, volt);
+
+	if (volt->vid_nr) {
+		for (i = 0; i < volt->vid_nr; i++) {
+			nv_debug(volt, "VID %02x: %duv\n",
+				 volt->vid[i].vid, volt->vid[i].uv);
+		}
+
+		/*XXX: this is an assumption.. there probably exists boards
+		 * out there with i2c-connected voltage controllers too..
+		 */
+		ret = nouveau_voltgpio_init(volt);
+		if (ret == 0) {
+			volt->vid_get = nouveau_voltgpio_get;
+			volt->vid_set = nouveau_voltgpio_set;
+		}
+	}
+
+	return ret;
+}
