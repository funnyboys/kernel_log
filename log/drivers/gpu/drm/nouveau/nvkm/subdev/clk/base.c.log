commit 322b38ce3dd6458b92ee25acee68c973281dbbde
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Wed Oct 17 16:28:51 2018 +0200

    drm/nouveau/nvkm: mark expected switch fall-throughs
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    This patch aims to suppress 29 missing-break-in-switch false positives.
    
    Addresses-Coverity-ID: 1456891 ("Missing break in switch")
    Addresses-Coverity-ID: 1324063 ("Missing break in switch")
    Addresses-Coverity-ID: 1324063 ("Missing break in switch")
    Addresses-Coverity-ID: 141432 ("Missing break in switch")
    Addresses-Coverity-ID: 141433 ("Missing break in switch")
    Addresses-Coverity-ID: 141434 ("Missing break in switch")
    Addresses-Coverity-ID: 141435 ("Missing break in switch")
    Addresses-Coverity-ID: 141436 ("Missing break in switch")
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index ba6a868d4c95..40e564524b7a 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -90,6 +90,7 @@ nvkm_cstate_valid(struct nvkm_clk *clk, struct nvkm_cstate *cstate,
 			case NVKM_CLK_BOOST_NONE:
 				if (clk->base_khz && freq > clk->base_khz)
 					return false;
+				/* fall through */
 			case NVKM_CLK_BOOST_BIOS:
 				if (clk->boost_khz && freq > clk->boost_khz)
 					return false;

commit dd3b89be3eafd1c9977e350e81c5556230319101
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Tue May 8 23:13:09 2018 +1000

    drm/nouveau/clk: Use list_for_each_entry_from_reverse
    
    It's better to use "list_for_each_entry_from_reverse" for iterating list
    than "for loop" as it makes the code more clear to read.
    This patch replace "for loop" with "list_for_each_entry_from_reverse"
    and "start" variable with "cstate" which helps in refactoring
    the code and also "cstate" variable is more commonly used in the other
    functions.
    
    changes in v2:
    "start" variable is removed, before "cstate" variable was removed
    but "cstate" is more common so preferred "cstate" over "start".
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index 81c3567d4e67..ba6a868d4c95 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -109,18 +109,17 @@ nvkm_cstate_valid(struct nvkm_clk *clk, struct nvkm_cstate *cstate,
 
 static struct nvkm_cstate *
 nvkm_cstate_find_best(struct nvkm_clk *clk, struct nvkm_pstate *pstate,
-		      struct nvkm_cstate *start)
+		      struct nvkm_cstate *cstate)
 {
 	struct nvkm_device *device = clk->subdev.device;
 	struct nvkm_volt *volt = device->volt;
-	struct nvkm_cstate *cstate;
 	int max_volt;
 
-	if (!pstate || !start)
+	if (!pstate || !cstate)
 		return NULL;
 
 	if (!volt)
-		return start;
+		return cstate;
 
 	max_volt = volt->max_uv;
 	if (volt->max0_id != 0xff)
@@ -133,8 +132,7 @@ nvkm_cstate_find_best(struct nvkm_clk *clk, struct nvkm_pstate *pstate,
 		max_volt = min(max_volt,
 			       nvkm_volt_map(volt, volt->max2_id, clk->temp));
 
-	for (cstate = start; &cstate->head != &pstate->list;
-	     cstate = list_prev_entry(cstate, head)) {
+	list_for_each_entry_from_reverse(cstate, &pstate->list, head) {
 		if (nvkm_cstate_valid(clk, cstate, max_volt, clk->temp))
 			break;
 	}

commit 3f07f28b9712605d1adb589344ced72e8397dc8a
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Sun Mar 25 23:31:33 2018 +0530

    gpu: drm: nouveau: Use list_{next/prev}_entry instead of list_entry
    
    It's better to use list_entry instead of list_{next/prev}_entry
    as it makes the code more clear to read.
    This patch replace list_entry with list_{next/prev}_entry.
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Acked-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1522000893-5331-3-git-send-email-arushisinghal19971997@gmail.com

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index e4c8d310d870..81c3567d4e67 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -134,7 +134,7 @@ nvkm_cstate_find_best(struct nvkm_clk *clk, struct nvkm_pstate *pstate,
 			       nvkm_volt_map(volt, volt->max2_id, clk->temp));
 
 	for (cstate = start; &cstate->head != &pstate->list;
-	     cstate = list_entry(cstate->head.prev, typeof(*cstate), head)) {
+	     cstate = list_prev_entry(cstate, head)) {
 		if (nvkm_cstate_valid(clk, cstate, max_volt, clk->temp))
 			break;
 	}

commit 6496b4e5ab5db1306f06d0eabe28fe0be80f07cd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 18 11:28:42 2016 +1000

    drm/nouveau/bios/cstep: pointers are 32-bit
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index f43970156558..e4c8d310d870 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -229,7 +229,7 @@ nvkm_cstate_new(struct nvkm_clk *clk, int idx, struct nvkm_pstate *pstate)
 	struct nvkm_cstate *cstate = NULL;
 	struct nvbios_cstepX cstepX;
 	u8  ver, hdr;
-	u16 data;
+	u32 data;
 
 	data = nvbios_cstepXp(bios, idx, &ver, &hdr, &cstepX);
 	if (!data)
@@ -408,7 +408,7 @@ nvkm_pstate_new(struct nvkm_clk *clk, int idx)
 	struct nvbios_cstepE cstepE;
 	struct nvbios_perfE perfE;
 	u8  ver, hdr, cnt, len;
-	u16 data;
+	u32 data;
 
 	data = nvbios_perfEp(bios, idx, &ver, &hdr, &cnt, &len, &perfE);
 	if (!data)

commit 5878601767bfa46f0f9856b726a487ae02b57b9c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Nov 18 11:24:35 2016 +1000

    drm/nouveau/bios/boost: pointers are 32-bit
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index fa1c12185e19..f43970156558 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -44,13 +44,13 @@ nvkm_clk_adjust(struct nvkm_clk *clk, bool adjust,
 	struct nvkm_bios *bios = clk->subdev.device->bios;
 	struct nvbios_boostE boostE;
 	u8  ver, hdr, cnt, len;
-	u16 data;
+	u32 data;
 
 	data = nvbios_boostEm(bios, pstate, &ver, &hdr, &cnt, &len, &boostE);
 	if (data) {
 		struct nvbios_boostS boostS;
 		u8  idx = 0, sver, shdr;
-		u16 subd;
+		u32 subd;
 
 		input = max(boostE.min, input);
 		input = min(boostE.max, input);

commit 4b9ce6e7b68683ac3874f9ebb243eb6f29c46812
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Tue Jul 12 21:36:08 2016 +0200

    drm/nouveau/clk: Allow boosting only when NvBoost is set
    
    0: base clock from the vbios is max clock (default)
    1: boost only to boost clock from the vbios
    2: boost to max clock available
    
    v2: Moved into nvkm_cstate_valid.
    v4: Check the existence of the clocks before limiting.
    v5: Default to boost level 0.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index 60392b2edcbb..fa1c12185e19 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -27,6 +27,7 @@
 #include <subdev/bios/boost.h>
 #include <subdev/bios/cstep.h>
 #include <subdev/bios/perf.h>
+#include <subdev/bios/vpstate.h>
 #include <subdev/fb.h>
 #include <subdev/therm.h>
 #include <subdev/volt.h>
@@ -78,9 +79,25 @@ static bool
 nvkm_cstate_valid(struct nvkm_clk *clk, struct nvkm_cstate *cstate,
 		  u32 max_volt, int temp)
 {
+	const struct nvkm_domain *domain = clk->domains;
 	struct nvkm_volt *volt = clk->subdev.device->volt;
 	int voltage;
 
+	while (domain && domain->name != nv_clk_src_max) {
+		if (domain->flags & NVKM_CLK_DOM_FLAG_VPSTATE) {
+			u32 freq = cstate->domain[domain->name];
+			switch (clk->boost_mode) {
+			case NVKM_CLK_BOOST_NONE:
+				if (clk->base_khz && freq > clk->base_khz)
+					return false;
+			case NVKM_CLK_BOOST_BIOS:
+				if (clk->boost_khz && freq > clk->boost_khz)
+					return false;
+			}
+		}
+		domain++;
+	}
+
 	if (!volt)
 		return true;
 
@@ -635,10 +652,22 @@ int
 nvkm_clk_ctor(const struct nvkm_clk_func *func, struct nvkm_device *device,
 	      int index, bool allow_reclock, struct nvkm_clk *clk)
 {
+	struct nvkm_subdev *subdev = &clk->subdev;
+	struct nvkm_bios *bios = device->bios;
 	int ret, idx, arglen;
 	const char *mode;
+	struct nvbios_vpstate_header h;
+
+	nvkm_subdev_ctor(&nvkm_clk, device, index, subdev);
+
+	if (bios && !nvbios_vpstate_parse(bios, &h)) {
+		struct nvbios_vpstate_entry base, boost;
+		if (!nvbios_vpstate_entry(bios, &h, h.boost_id, &boost))
+			clk->boost_khz = boost.clock_mhz * 1000;
+		if (!nvbios_vpstate_entry(bios, &h, h.base_id, &base))
+			clk->base_khz = base.clock_mhz * 1000;
+	}
 
-	nvkm_subdev_ctor(&nvkm_clk, device, index, &clk->subdev);
 	clk->func = func;
 	INIT_LIST_HEAD(&clk->states);
 	clk->domains = func->domains;
@@ -681,6 +710,8 @@ nvkm_clk_ctor(const struct nvkm_clk_func *func, struct nvkm_device *device,
 	if (mode)
 		clk->ustate_dc = nvkm_clk_nstate(clk, mode, arglen);
 
+	clk->boost_mode = nvkm_longopt(device->cfgopt, "NvBoost",
+				       NVKM_CLK_BOOST_NONE);
 	return 0;
 }
 

commit 1f7f3d91ad38afc706f838fb5a642b21d28e4485
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Sat Jul 16 15:26:25 2016 +0200

    drm/nouveau/clk: Respect voltage limits in nvkm_cstate_prog
    
    We should never allow to select a cstate which current voltage (depending
    on the temperature) is higher than
    
    1. the max volt entries in the voltage map table.
    2. what tha gpu actually can volt to.
    
    v3: Use find_best for all cstates before actually trying.
        Add nvkm_cstate_get function to get cstate by index.
    v5: Cstates with voltages lower then min_uv are valid.
        Move nvkm_cstate_get into the previous commit.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index 688c908908d8..60392b2edcbb 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -74,6 +74,57 @@ nvkm_clk_adjust(struct nvkm_clk *clk, bool adjust,
 /******************************************************************************
  * C-States
  *****************************************************************************/
+static bool
+nvkm_cstate_valid(struct nvkm_clk *clk, struct nvkm_cstate *cstate,
+		  u32 max_volt, int temp)
+{
+	struct nvkm_volt *volt = clk->subdev.device->volt;
+	int voltage;
+
+	if (!volt)
+		return true;
+
+	voltage = nvkm_volt_map(volt, cstate->voltage, temp);
+	if (voltage < 0)
+		return false;
+	return voltage <= min(max_volt, volt->max_uv);
+}
+
+static struct nvkm_cstate *
+nvkm_cstate_find_best(struct nvkm_clk *clk, struct nvkm_pstate *pstate,
+		      struct nvkm_cstate *start)
+{
+	struct nvkm_device *device = clk->subdev.device;
+	struct nvkm_volt *volt = device->volt;
+	struct nvkm_cstate *cstate;
+	int max_volt;
+
+	if (!pstate || !start)
+		return NULL;
+
+	if (!volt)
+		return start;
+
+	max_volt = volt->max_uv;
+	if (volt->max0_id != 0xff)
+		max_volt = min(max_volt,
+			       nvkm_volt_map(volt, volt->max0_id, clk->temp));
+	if (volt->max1_id != 0xff)
+		max_volt = min(max_volt,
+			       nvkm_volt_map(volt, volt->max1_id, clk->temp));
+	if (volt->max2_id != 0xff)
+		max_volt = min(max_volt,
+			       nvkm_volt_map(volt, volt->max2_id, clk->temp));
+
+	for (cstate = start; &cstate->head != &pstate->list;
+	     cstate = list_entry(cstate->head.prev, typeof(*cstate), head)) {
+		if (nvkm_cstate_valid(clk, cstate, max_volt, clk->temp))
+			break;
+	}
+
+	return cstate;
+}
+
 static struct nvkm_cstate *
 nvkm_cstate_get(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 {
@@ -101,6 +152,7 @@ nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 
 	if (!list_empty(&pstate->list)) {
 		cstate = nvkm_cstate_get(clk, pstate, cstatei);
+		cstate = nvkm_cstate_find_best(clk, pstate, cstate);
 	} else {
 		cstate = &pstate->base;
 	}

commit 0d6f81003e9ecc2d6552be92d3d894c916097552
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Tue Jul 12 21:36:08 2016 +0200

    drm/nouveau/clk: Fixup cstate selection
    
    Now the cstatei parameter can be used of the nvkm_cstate_prog function to
    select a specific cstate.
    
    v5: Make a constant for the magic value.
        Use list_last_entry.
        Add nvkm_cstate_get here instead of in the next commit.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index 98168be93515..688c908908d8 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -74,6 +74,21 @@ nvkm_clk_adjust(struct nvkm_clk *clk, bool adjust,
 /******************************************************************************
  * C-States
  *****************************************************************************/
+static struct nvkm_cstate *
+nvkm_cstate_get(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
+{
+	struct nvkm_cstate *cstate;
+	if (cstatei == NVKM_CLK_CSTATE_HIGHEST)
+		return list_last_entry(&pstate->list, typeof(*cstate), head);
+	else {
+		list_for_each_entry(cstate, &pstate->list, head) {
+			if (cstate->id == cstatei)
+				return cstate;
+		}
+	}
+	return NULL;
+}
+
 static int
 nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 {
@@ -85,7 +100,7 @@ nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 	int ret;
 
 	if (!list_empty(&pstate->list)) {
-		cstate = list_entry(pstate->list.prev, typeof(*cstate), head);
+		cstate = nvkm_cstate_get(clk, pstate, cstatei);
 	} else {
 		cstate = &pstate->base;
 	}
@@ -208,7 +223,7 @@ nvkm_pstate_prog(struct nvkm_clk *clk, int pstatei)
 		ram->func->tidy(ram);
 	}
 
-	return nvkm_cstate_prog(clk, pstate, 0);
+	return nvkm_cstate_prog(clk, pstate, NVKM_CLK_CSTATE_HIGHEST);
 }
 
 static void

commit 8d08c264d2b26c7b9c10790f95464b21e28dc30d
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Tue Jul 12 21:36:08 2016 +0200

    drm/nouveau/volt: Add temperature parameter to nvkm_volt_map
    
    The voltage entries actually may map to a different voltage depending on
    the current temperature.
    
    v2: Only read the temperature when actually needed.
    v5: Be smarter about using max().
        Don't read the temperature anymore.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index 88a517c33842..98168be93515 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -100,7 +100,7 @@ nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 
 	if (volt) {
 		ret = nvkm_volt_set_id(volt, cstate->voltage,
-				       pstate->base.voltage, +1);
+				       pstate->base.voltage, clk->temp, +1);
 		if (ret && ret != -ENODEV) {
 			nvkm_error(subdev, "failed to raise voltage: %d\n", ret);
 			return ret;
@@ -115,7 +115,7 @@ nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 
 	if (volt) {
 		ret = nvkm_volt_set_id(volt, cstate->voltage,
-				       pstate->base.voltage, -1);
+				       pstate->base.voltage, clk->temp, -1);
 		if (ret && ret != -ENODEV)
 			nvkm_error(subdev, "failed to lower voltage: %d\n", ret);
 	}

commit 61a8b84f1cff6051f51b30ad96417dd948dc72da
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Sun Jul 17 09:40:23 2016 +0200

    drm/nouveau/clk: Let nvkm_clk_tstate take a temperature value
    
    This way other subdevs can notify the clk subdev about temperature changes
    without the need of clk to poll that value.
    
    Also make this function safe to be called from an interrupt handler.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index 23cc04c37c07..88a517c33842 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -222,14 +222,14 @@ nvkm_pstate_work(struct work_struct *work)
 		return;
 	clk->pwrsrc = power_supply_is_system_supplied();
 
-	nvkm_trace(subdev, "P %d PWR %d U(AC) %d U(DC) %d A %d T %d D %d\n",
+	nvkm_trace(subdev, "P %d PWR %d U(AC) %d U(DC) %d A %d T %d°C D %d\n",
 		   clk->pstate, clk->pwrsrc, clk->ustate_ac, clk->ustate_dc,
-		   clk->astate, clk->tstate, clk->dstate);
+		   clk->astate, clk->temp, clk->dstate);
 
 	pstate = clk->pwrsrc ? clk->ustate_ac : clk->ustate_dc;
 	if (clk->state_nr && pstate != -1) {
 		pstate = (pstate < 0) ? clk->astate : pstate;
-		pstate = min(pstate, clk->state_nr - 1 + clk->tstate);
+		pstate = min(pstate, clk->state_nr - 1);
 		pstate = max(pstate, clk->dstate);
 	} else {
 		pstate = clk->pstate = -1;
@@ -456,13 +456,12 @@ nvkm_clk_astate(struct nvkm_clk *clk, int req, int rel, bool wait)
 }
 
 int
-nvkm_clk_tstate(struct nvkm_clk *clk, int req, int rel)
+nvkm_clk_tstate(struct nvkm_clk *clk, u8 temp)
 {
-	if (!rel) clk->tstate  = req;
-	if ( rel) clk->tstate += rel;
-	clk->tstate = min(clk->tstate, 0);
-	clk->tstate = max(clk->tstate, -(clk->state_nr - 1));
-	return nvkm_pstate_calc(clk, true);
+	if (clk->temp == temp)
+		return 0;
+	clk->temp = temp;
+	return nvkm_pstate_calc(clk, false);
 }
 
 int
@@ -532,9 +531,9 @@ nvkm_clk_init(struct nvkm_subdev *subdev)
 		return clk->func->init(clk);
 
 	clk->astate = clk->state_nr - 1;
-	clk->tstate = 0;
 	clk->dstate = 0;
 	clk->pstate = -1;
+	clk->temp = 90; /* reasonable default value */
 	nvkm_pstate_calc(clk, true);
 	return 0;
 }

commit 761c8f69afdf34c100ccdde1df01163cda4f25e8
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Tue Jul 12 21:36:08 2016 +0200

    drm/nouveau/clk: Add index field to nvkm_cstate
    
    It is better to read out the id out of the cstate struct directly instead
    of iterating over the list of cstates over and over again. Especially when
    we start saving pointers to a nvkm_cstate struct, it makes things easier.
    
    v5: Rename field to id.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index 9ee24ec2869b..23cc04c37c07 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -160,6 +160,7 @@ nvkm_cstate_new(struct nvkm_clk *clk, int idx, struct nvkm_pstate *pstate)
 
 	*cstate = pstate->base;
 	cstate->voltage = cstepX.voltage;
+	cstate->id = idx;
 
 	while (domain && domain->name != nv_clk_src_max) {
 		if (domain->flags & NVKM_CLK_DOM_FLAG_CORE) {

commit fa6c4d8e2c614817c956a4ab59ab8bb24fb3653f
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Tue Jul 12 21:36:08 2016 +0200

    drm/nouveau/volt: Add min_id parameter to nvkm_volt_set_id
    
    Each pstate has its own voltage map entry like each cstate has.
    
    The voltages of those entries act as a floor value for the currently
    selected pstate and nvidia never sets a voltage below them.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index 2881b2ceda32..9ee24ec2869b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -99,7 +99,8 @@ nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 	}
 
 	if (volt) {
-		ret = nvkm_volt_set_id(volt, cstate->voltage, +1);
+		ret = nvkm_volt_set_id(volt, cstate->voltage,
+				       pstate->base.voltage, +1);
 		if (ret && ret != -ENODEV) {
 			nvkm_error(subdev, "failed to raise voltage: %d\n", ret);
 			return ret;
@@ -113,7 +114,8 @@ nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 	}
 
 	if (volt) {
-		ret = nvkm_volt_set_id(volt, cstate->voltage, -1);
+		ret = nvkm_volt_set_id(volt, cstate->voltage,
+				       pstate->base.voltage, -1);
 		if (ret && ret != -ENODEV)
 			nvkm_error(subdev, "failed to lower voltage: %d\n", ret);
 	}

commit 17d063dbdce3bab04957b2281dcdceecb7407170
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Tue Jul 12 21:36:08 2016 +0200

    drm/nouveau/clk: Don't create cstates with voltages higher than what the gpu can do
    
    nvkm_volt_map_min is a copy of nvkm_volt_map, which always returns the
    lowest possible voltage for a cstate.
    
    nvkm_volt_map will get a temperature parameter there later and also fix
    the voltage calculation, so that this functions will be completly
    different later.
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Reviewed-by: Martin Peres <martin.peres@free.fr>
    Tested-by: Pierre Moreau <pierre.morrow@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index 1defd3215ed3..2881b2ceda32 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -138,6 +138,7 @@ static int
 nvkm_cstate_new(struct nvkm_clk *clk, int idx, struct nvkm_pstate *pstate)
 {
 	struct nvkm_bios *bios = clk->subdev.device->bios;
+	struct nvkm_volt *volt = clk->subdev.device->volt;
 	const struct nvkm_domain *domain = clk->domains;
 	struct nvkm_cstate *cstate = NULL;
 	struct nvbios_cstepX cstepX;
@@ -148,6 +149,9 @@ nvkm_cstate_new(struct nvkm_clk *clk, int idx, struct nvkm_pstate *pstate)
 	if (!data)
 		return -ENOENT;
 
+	if (volt && nvkm_volt_map_min(volt, cstepX.voltage) > volt->max_uv)
+		return -EINVAL;
+
 	cstate = kzalloc(sizeof(*cstate), GFP_KERNEL);
 	if (!cstate)
 		return -ENOMEM;

commit cc90badd3c077ee18f82114988dbd53faf8f34c3
Author: Karol Herbst <karolherbst@gmail.com>
Date:   Tue Jul 12 21:36:08 2016 +0200

    drm/nouveau/clk: Fix potential NULL pointer access when there is no fb subdev
    
    Signed-off-by: Karol Herbst <karolherbst@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index 7102c25320fc..1defd3215ed3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -175,7 +175,7 @@ static int
 nvkm_pstate_prog(struct nvkm_clk *clk, int pstatei)
 {
 	struct nvkm_subdev *subdev = &clk->subdev;
-	struct nvkm_ram *ram = subdev->device->fb->ram;
+	struct nvkm_fb *fb = subdev->device->fb;
 	struct nvkm_pci *pci = subdev->device->pci;
 	struct nvkm_pstate *pstate;
 	int ret, idx = 0;
@@ -190,7 +190,8 @@ nvkm_pstate_prog(struct nvkm_clk *clk, int pstatei)
 
 	nvkm_pcie_set_link(pci, pstate->pcie_speed, pstate->pcie_width);
 
-	if (ram && ram->func->calc) {
+	if (fb && fb->ram && fb->ram->func->calc) {
+		struct nvkm_ram *ram = fb->ram;
 		int khz = pstate->base.domain[nv_clk_src_mem];
 		do {
 			ret = ram->func->calc(ram, khz);

commit 56d06fa29edd58c448766014afd833b7ff51247b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Apr 8 17:24:40 2016 +1000

    drm/nouveau/core: remove pmc_enable argument from subdev ctor
    
    These are now specified directly in the MC subdev.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index 889cce2eb727..7102c25320fc 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -564,7 +564,7 @@ nvkm_clk_ctor(const struct nvkm_clk_func *func, struct nvkm_device *device,
 	int ret, idx, arglen;
 	const char *mode;
 
-	nvkm_subdev_ctor(&nvkm_clk, device, index, 0, &clk->subdev);
+	nvkm_subdev_ctor(&nvkm_clk, device, index, &clk->subdev);
 	clk->func = func;
 	INIT_LIST_HEAD(&clk->states);
 	clk->domains = func->domains;

commit f68f4c960a3f39bf1ca30313f690486361639745
Author: Karol Herbst <nouveau@karolherbst.de>
Date:   Tue Sep 15 18:49:32 2015 +0200

    drm/nouveau/perf: change pcie speed on pstate change
    
    v2: remove error and only set link for pcie devices
    v6: remove check for pcie device
    
    Signed-off-by: Karol Herbst <nouveau@karolherbst.de>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index c769aff04531..889cce2eb727 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -176,6 +176,7 @@ nvkm_pstate_prog(struct nvkm_clk *clk, int pstatei)
 {
 	struct nvkm_subdev *subdev = &clk->subdev;
 	struct nvkm_ram *ram = subdev->device->fb->ram;
+	struct nvkm_pci *pci = subdev->device->pci;
 	struct nvkm_pstate *pstate;
 	int ret, idx = 0;
 
@@ -187,6 +188,8 @@ nvkm_pstate_prog(struct nvkm_clk *clk, int pstatei)
 	nvkm_debug(subdev, "setting performance state %d\n", pstatei);
 	clk->pstate = pstatei;
 
+	nvkm_pcie_set_link(pci, pstate->pcie_speed, pstate->pcie_width);
+
 	if (ram && ram->func->calc) {
 		int khz = pstate->base.domain[nv_clk_src_mem];
 		do {

commit d3b378c09c7b81e9005c2118343f8b7feeaaca8b
Author: Karol Herbst <nouveau@karolherbst.de>
Date:   Tue Sep 15 18:49:08 2015 +0200

    drm/nouveau/perf: add fields for pci speed and width and use it for the pstates
    
    Signed-off-by: Karol Herbst <nouveau@karolherbst.de>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index dc8682c91cc7..c769aff04531 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -330,6 +330,8 @@ nvkm_pstate_new(struct nvkm_clk *clk, int idx)
 
 	pstate->pstate = perfE.pstate;
 	pstate->fanspeed = perfE.fanspeed;
+	pstate->pcie_speed = perfE.pcie_speed;
+	pstate->pcie_width = perfE.pcie_width;
 	cstate->voltage = perfE.voltage;
 	cstate->domain[nv_clk_src_core] = perfE.core;
 	cstate->domain[nv_clk_src_shader] = perfE.shader;

commit 437b2296ced574eada632b11346e22f6b0103e17
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:21 2015 +1000

    drm/nouveau/volt: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index cdb87e2900f1..dc8682c91cc7 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -99,7 +99,7 @@ nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 	}
 
 	if (volt) {
-		ret = volt->set_id(volt, cstate->voltage, +1);
+		ret = nvkm_volt_set_id(volt, cstate->voltage, +1);
 		if (ret && ret != -ENODEV) {
 			nvkm_error(subdev, "failed to raise voltage: %d\n", ret);
 			return ret;
@@ -113,7 +113,7 @@ nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 	}
 
 	if (volt) {
-		ret = volt->set_id(volt, cstate->voltage, -1);
+		ret = nvkm_volt_set_id(volt, cstate->voltage, -1);
 		if (ret && ret != -ENODEV)
 			nvkm_error(subdev, "failed to lower voltage: %d\n", ret);
 	}

commit 6625f55c080f888ccf51b6881f0bad13f5762d15
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/clk: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index c99385329ef4..cdb87e2900f1 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -21,7 +21,8 @@
  *
  * Authors: Ben Skeggs
  */
-#include <subdev/clk.h>
+#include "priv.h"
+
 #include <subdev/bios.h>
 #include <subdev/bios/boost.h>
 #include <subdev/bios/cstep.h>
@@ -105,10 +106,10 @@ nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 		}
 	}
 
-	ret = clk->calc(clk, cstate);
+	ret = clk->func->calc(clk, cstate);
 	if (ret == 0) {
-		ret = clk->prog(clk);
-		clk->tidy(clk);
+		ret = clk->func->prog(clk);
+		clk->func->tidy(clk);
 	}
 
 	if (volt) {
@@ -137,7 +138,7 @@ static int
 nvkm_cstate_new(struct nvkm_clk *clk, int idx, struct nvkm_pstate *pstate)
 {
 	struct nvkm_bios *bios = clk->subdev.device->bios;
-	struct nvkm_domain *domain = clk->domains;
+	const struct nvkm_domain *domain = clk->domains;
 	struct nvkm_cstate *cstate = NULL;
 	struct nvbios_cstepX cstepX;
 	u8  ver, hdr;
@@ -249,7 +250,7 @@ nvkm_pstate_calc(struct nvkm_clk *clk, bool wait)
 static void
 nvkm_pstate_info(struct nvkm_clk *clk, struct nvkm_pstate *pstate)
 {
-	struct nvkm_domain *clock = clk->domains - 1;
+	const struct nvkm_domain *clock = clk->domains - 1;
 	struct nvkm_cstate *cstate;
 	struct nvkm_subdev *subdev = &clk->subdev;
 	char info[3][32] = { "", "", "" };
@@ -306,7 +307,7 @@ static int
 nvkm_pstate_new(struct nvkm_clk *clk, int idx)
 {
 	struct nvkm_bios *bios = clk->subdev.device->bios;
-	struct nvkm_domain *domain = clk->domains - 1;
+	const struct nvkm_domain *domain = clk->domains - 1;
 	struct nvkm_pstate *pstate;
 	struct nvkm_cstate *cstate;
 	struct nvbios_cstepE cstepE;
@@ -475,31 +476,35 @@ nvkm_clk_pwrsrc(struct nvkm_notify *notify)
  *****************************************************************************/
 
 int
-_nvkm_clk_fini(struct nvkm_object *object, bool suspend)
+nvkm_clk_read(struct nvkm_clk *clk, enum nv_clk_src src)
 {
-	struct nvkm_clk *clk = (void *)object;
+	return clk->func->read(clk, src);
+}
+
+static int
+nvkm_clk_fini(struct nvkm_subdev *subdev, bool suspend)
+{
+	struct nvkm_clk *clk = nvkm_clk(subdev);
 	nvkm_notify_put(&clk->pwrsrc_ntfy);
-	return nvkm_subdev_fini_old(&clk->subdev, suspend);
+	flush_work(&clk->work);
+	if (clk->func->fini)
+		clk->func->fini(clk);
+	return 0;
 }
 
-int
-_nvkm_clk_init(struct nvkm_object *object)
+static int
+nvkm_clk_init(struct nvkm_subdev *subdev)
 {
-	struct nvkm_clk *clk = (void *)object;
-	struct nvkm_subdev *subdev = &clk->subdev;
-	struct nvkm_domain *clock = clk->domains;
+	struct nvkm_clk *clk = nvkm_clk(subdev);
+	const struct nvkm_domain *clock = clk->domains;
 	int ret;
 
-	ret = nvkm_subdev_init_old(&clk->subdev);
-	if (ret)
-		return ret;
-
 	memset(&clk->bstate, 0x00, sizeof(clk->bstate));
 	INIT_LIST_HEAD(&clk->bstate.list);
 	clk->bstate.pstate = 0xff;
 
 	while (clock->name != nv_clk_src_max) {
-		ret = clk->read(clk, clock->name);
+		ret = nvkm_clk_read(clk, clock->name);
 		if (ret < 0) {
 			nvkm_error(subdev, "%02x freq unknown\n", clock->name);
 			return ret;
@@ -510,6 +515,9 @@ _nvkm_clk_init(struct nvkm_object *object)
 
 	nvkm_pstate_info(clk, &clk->bstate);
 
+	if (clk->func->init)
+		return clk->func->init(clk);
+
 	clk->astate = clk->state_nr - 1;
 	clk->tstate = 0;
 	clk->dstate = 0;
@@ -518,61 +526,63 @@ _nvkm_clk_init(struct nvkm_object *object)
 	return 0;
 }
 
-void
-_nvkm_clk_dtor(struct nvkm_object *object)
+static void *
+nvkm_clk_dtor(struct nvkm_subdev *subdev)
 {
-	struct nvkm_clk *clk = (void *)object;
+	struct nvkm_clk *clk = nvkm_clk(subdev);
 	struct nvkm_pstate *pstate, *temp;
 
 	nvkm_notify_fini(&clk->pwrsrc_ntfy);
 
+	/* Early return if the pstates have been provided statically */
+	if (clk->func->pstates)
+		return clk;
+
 	list_for_each_entry_safe(pstate, temp, &clk->states, head) {
 		nvkm_pstate_del(pstate);
 	}
 
-	nvkm_subdev_destroy(&clk->subdev);
+	return clk;
 }
 
+static const struct nvkm_subdev_func
+nvkm_clk = {
+	.dtor = nvkm_clk_dtor,
+	.init = nvkm_clk_init,
+	.fini = nvkm_clk_fini,
+};
+
 int
-nvkm_clk_create_(struct nvkm_object *parent, struct nvkm_object *engine,
-		 struct nvkm_oclass *oclass, struct nvkm_domain *clocks,
-		 struct nvkm_pstate *pstates, int nb_pstates,
-		 bool allow_reclock, int length, void **object)
+nvkm_clk_ctor(const struct nvkm_clk_func *func, struct nvkm_device *device,
+	      int index, bool allow_reclock, struct nvkm_clk *clk)
 {
-	struct nvkm_device *device = nv_device(parent);
-	struct nvkm_clk *clk;
 	int ret, idx, arglen;
 	const char *mode;
 
-	ret = nvkm_subdev_create_(parent, engine, oclass, 0, "CLK",
-				  "clock", length, object);
-	clk = *object;
-	if (ret)
-		return ret;
-
+	nvkm_subdev_ctor(&nvkm_clk, device, index, 0, &clk->subdev);
+	clk->func = func;
 	INIT_LIST_HEAD(&clk->states);
-	clk->domains = clocks;
+	clk->domains = func->domains;
 	clk->ustate_ac = -1;
 	clk->ustate_dc = -1;
+	clk->allow_reclock = allow_reclock;
 
 	INIT_WORK(&clk->work, nvkm_pstate_work);
 	init_waitqueue_head(&clk->wait);
 	atomic_set(&clk->waiting, 0);
 
 	/* If no pstates are provided, try and fetch them from the BIOS */
-	if (!pstates) {
+	if (!func->pstates) {
 		idx = 0;
 		do {
 			ret = nvkm_pstate_new(clk, idx++);
 		} while (ret == 0);
 	} else {
-		for (idx = 0; idx < nb_pstates; idx++)
-			list_add_tail(&pstates[idx].head, &clk->states);
-		clk->state_nr = nb_pstates;
+		for (idx = 0; idx < func->nr_pstates; idx++)
+			list_add_tail(&func->pstates[idx].head, &clk->states);
+		clk->state_nr = func->nr_pstates;
 	}
 
-	clk->allow_reclock = allow_reclock;
-
 	ret = nvkm_notify_init(NULL, &device->event, nvkm_clk_pwrsrc, true,
 			       NULL, 0, 0, &clk->pwrsrc_ntfy);
 	if (ret)
@@ -594,3 +604,12 @@ nvkm_clk_create_(struct nvkm_object *parent, struct nvkm_object *engine,
 
 	return 0;
 }
+
+int
+nvkm_clk_new_(const struct nvkm_clk_func *func, struct nvkm_device *device,
+	      int index, bool allow_reclock, struct nvkm_clk **pclk)
+{
+	if (!(*pclk = kzalloc(sizeof(**pclk), GFP_KERNEL)))
+		return -ENOMEM;
+	return nvkm_clk_ctor(func, device, index, allow_reclock, *pclk);
+}

commit 46484438ab7dbab6ed29cf647d029e0b1ef3d9d8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:20 2015 +1000

    drm/nouveau/bios: convert to new-style nvkm_subdev
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index 659122721b7d..c99385329ef4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -39,7 +39,7 @@ static u32
 nvkm_clk_adjust(struct nvkm_clk *clk, bool adjust,
 		u8 pstate, u8 domain, u32 input)
 {
-	struct nvkm_bios *bios = nvkm_bios(clk);
+	struct nvkm_bios *bios = clk->subdev.device->bios;
 	struct nvbios_boostE boostE;
 	u8  ver, hdr, cnt, len;
 	u16 data;
@@ -136,7 +136,7 @@ nvkm_cstate_del(struct nvkm_cstate *cstate)
 static int
 nvkm_cstate_new(struct nvkm_clk *clk, int idx, struct nvkm_pstate *pstate)
 {
-	struct nvkm_bios *bios = nvkm_bios(clk);
+	struct nvkm_bios *bios = clk->subdev.device->bios;
 	struct nvkm_domain *domain = clk->domains;
 	struct nvkm_cstate *cstate = NULL;
 	struct nvbios_cstepX cstepX;
@@ -305,7 +305,7 @@ nvkm_pstate_del(struct nvkm_pstate *pstate)
 static int
 nvkm_pstate_new(struct nvkm_clk *clk, int idx)
 {
-	struct nvkm_bios *bios = nvkm_bios(clk);
+	struct nvkm_bios *bios = clk->subdev.device->bios;
 	struct nvkm_domain *domain = clk->domains - 1;
 	struct nvkm_pstate *pstate;
 	struct nvkm_cstate *cstate;

commit 3a8c3400f3e74638bedd0d2410416aa8b794c0fd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:16 2015 +1000

    drm/nouveau/subdev: rename some functions to avoid upcoming conflicts
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index cfd1feed99c3..659122721b7d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -479,7 +479,7 @@ _nvkm_clk_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nvkm_clk *clk = (void *)object;
 	nvkm_notify_put(&clk->pwrsrc_ntfy);
-	return nvkm_subdev_fini(&clk->subdev, suspend);
+	return nvkm_subdev_fini_old(&clk->subdev, suspend);
 }
 
 int
@@ -490,7 +490,7 @@ _nvkm_clk_init(struct nvkm_object *object)
 	struct nvkm_domain *clock = clk->domains;
 	int ret;
 
-	ret = nvkm_subdev_init(&clk->subdev);
+	ret = nvkm_subdev_init_old(&clk->subdev);
 	if (ret)
 		return ret;
 

commit d36a99d2da22bdffebf644e4a5f811e8eff82360
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:14 2015 +1000

    drm/nouveau/fb: transition nvkm_ram away from being based on nvkm_object
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index a05ec57150c6..cfd1feed99c3 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -174,7 +174,7 @@ static int
 nvkm_pstate_prog(struct nvkm_clk *clk, int pstatei)
 {
 	struct nvkm_subdev *subdev = &clk->subdev;
-	struct nvkm_fb *fb = subdev->device->fb;
+	struct nvkm_ram *ram = subdev->device->fb->ram;
 	struct nvkm_pstate *pstate;
 	int ret, idx = 0;
 
@@ -186,14 +186,14 @@ nvkm_pstate_prog(struct nvkm_clk *clk, int pstatei)
 	nvkm_debug(subdev, "setting performance state %d\n", pstatei);
 	clk->pstate = pstatei;
 
-	if (fb->ram && fb->ram->calc) {
+	if (ram && ram->func->calc) {
 		int khz = pstate->base.domain[nv_clk_src_mem];
 		do {
-			ret = fb->ram->calc(fb, khz);
+			ret = ram->func->calc(ram, khz);
 			if (ret == 0)
-				ret = fb->ram->prog(fb);
+				ret = ram->func->prog(ram);
 		} while (ret > 0);
-		fb->ram->tidy(fb);
+		ram->func->tidy(ram);
 	}
 
 	return nvkm_cstate_prog(clk, pstate, 0);

commit b907649e7be734a4911f83b67a14e3425fa8a2a1
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:12 2015 +1000

    drm/nouveau/clk: switch to subdev printk macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index d54d84aaf763..a05ec57150c6 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -76,8 +76,10 @@ nvkm_clk_adjust(struct nvkm_clk *clk, bool adjust,
 static int
 nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 {
-	struct nvkm_therm *therm = nvkm_therm(clk);
-	struct nvkm_volt *volt = nvkm_volt(clk);
+	struct nvkm_subdev *subdev = &clk->subdev;
+	struct nvkm_device *device = subdev->device;
+	struct nvkm_therm *therm = device->therm;
+	struct nvkm_volt *volt = device->volt;
 	struct nvkm_cstate *cstate;
 	int ret;
 
@@ -90,7 +92,7 @@ nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 	if (therm) {
 		ret = nvkm_therm_cstate(therm, pstate->fanspeed, +1);
 		if (ret && ret != -ENODEV) {
-			nv_error(clk, "failed to raise fan speed: %d\n", ret);
+			nvkm_error(subdev, "failed to raise fan speed: %d\n", ret);
 			return ret;
 		}
 	}
@@ -98,7 +100,7 @@ nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 	if (volt) {
 		ret = volt->set_id(volt, cstate->voltage, +1);
 		if (ret && ret != -ENODEV) {
-			nv_error(clk, "failed to raise voltage: %d\n", ret);
+			nvkm_error(subdev, "failed to raise voltage: %d\n", ret);
 			return ret;
 		}
 	}
@@ -112,13 +114,13 @@ nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 	if (volt) {
 		ret = volt->set_id(volt, cstate->voltage, -1);
 		if (ret && ret != -ENODEV)
-			nv_error(clk, "failed to lower voltage: %d\n", ret);
+			nvkm_error(subdev, "failed to lower voltage: %d\n", ret);
 	}
 
 	if (therm) {
 		ret = nvkm_therm_cstate(therm, pstate->fanspeed, -1);
 		if (ret && ret != -ENODEV)
-			nv_error(clk, "failed to lower fan speed: %d\n", ret);
+			nvkm_error(subdev, "failed to lower fan speed: %d\n", ret);
 	}
 
 	return ret;
@@ -171,7 +173,8 @@ nvkm_cstate_new(struct nvkm_clk *clk, int idx, struct nvkm_pstate *pstate)
 static int
 nvkm_pstate_prog(struct nvkm_clk *clk, int pstatei)
 {
-	struct nvkm_fb *fb = nvkm_fb(clk);
+	struct nvkm_subdev *subdev = &clk->subdev;
+	struct nvkm_fb *fb = subdev->device->fb;
 	struct nvkm_pstate *pstate;
 	int ret, idx = 0;
 
@@ -180,7 +183,7 @@ nvkm_pstate_prog(struct nvkm_clk *clk, int pstatei)
 			break;
 	}
 
-	nv_debug(clk, "setting performance state %d\n", pstatei);
+	nvkm_debug(subdev, "setting performance state %d\n", pstatei);
 	clk->pstate = pstatei;
 
 	if (fb->ram && fb->ram->calc) {
@@ -200,15 +203,16 @@ static void
 nvkm_pstate_work(struct work_struct *work)
 {
 	struct nvkm_clk *clk = container_of(work, typeof(*clk), work);
+	struct nvkm_subdev *subdev = &clk->subdev;
 	int pstate;
 
 	if (!atomic_xchg(&clk->waiting, 0))
 		return;
 	clk->pwrsrc = power_supply_is_system_supplied();
 
-	nv_trace(clk, "P %d PWR %d U(AC) %d U(DC) %d A %d T %d D %d\n",
-		 clk->pstate, clk->pwrsrc, clk->ustate_ac, clk->ustate_dc,
-		 clk->astate, clk->tstate, clk->dstate);
+	nvkm_trace(subdev, "P %d PWR %d U(AC) %d U(DC) %d A %d T %d D %d\n",
+		   clk->pstate, clk->pwrsrc, clk->ustate_ac, clk->ustate_dc,
+		   clk->astate, clk->tstate, clk->dstate);
 
 	pstate = clk->pwrsrc ? clk->ustate_ac : clk->ustate_dc;
 	if (clk->state_nr && pstate != -1) {
@@ -219,12 +223,12 @@ nvkm_pstate_work(struct work_struct *work)
 		pstate = clk->pstate = -1;
 	}
 
-	nv_trace(clk, "-> %d\n", pstate);
+	nvkm_trace(subdev, "-> %d\n", pstate);
 	if (pstate != clk->pstate) {
 		int ret = nvkm_pstate_prog(clk, pstate);
 		if (ret) {
-			nv_error(clk, "error setting pstate %d: %d\n",
-				 pstate, ret);
+			nvkm_error(subdev, "error setting pstate %d: %d\n",
+				   pstate, ret);
 		}
 	}
 
@@ -247,6 +251,7 @@ nvkm_pstate_info(struct nvkm_clk *clk, struct nvkm_pstate *pstate)
 {
 	struct nvkm_domain *clock = clk->domains - 1;
 	struct nvkm_cstate *cstate;
+	struct nvkm_subdev *subdev = &clk->subdev;
 	char info[3][32] = { "", "", "" };
 	char name[4] = "--";
 	int i = -1;
@@ -260,12 +265,12 @@ nvkm_pstate_info(struct nvkm_clk *clk, struct nvkm_pstate *pstate)
 		if (hi == 0)
 			continue;
 
-		nv_debug(clk, "%02x: %10d KHz\n", clock->name, lo);
+		nvkm_debug(subdev, "%02x: %10d KHz\n", clock->name, lo);
 		list_for_each_entry(cstate, &pstate->list, head) {
 			u32 freq = cstate->domain[clock->name];
 			lo = min(lo, freq);
 			hi = max(hi, freq);
-			nv_debug(clk, "%10d KHz\n", freq);
+			nvkm_debug(subdev, "%10d KHz\n", freq);
 		}
 
 		if (clock->mname && ++i < ARRAY_SIZE(info)) {
@@ -281,7 +286,7 @@ nvkm_pstate_info(struct nvkm_clk *clk, struct nvkm_pstate *pstate)
 		}
 	}
 
-	nv_info(clk, "%s: %s %s %s\n", name, info[0], info[1], info[2]);
+	nvkm_debug(subdev, "%s: %s %s %s\n", name, info[0], info[1], info[2]);
 }
 
 static void
@@ -481,6 +486,7 @@ int
 _nvkm_clk_init(struct nvkm_object *object)
 {
 	struct nvkm_clk *clk = (void *)object;
+	struct nvkm_subdev *subdev = &clk->subdev;
 	struct nvkm_domain *clock = clk->domains;
 	int ret;
 
@@ -495,7 +501,7 @@ _nvkm_clk_init(struct nvkm_object *object)
 	while (clock->name != nv_clk_src_max) {
 		ret = clk->read(clk, clock->name);
 		if (ret < 0) {
-			nv_error(clk, "%02x freq unknown\n", clock->name);
+			nvkm_error(subdev, "%02x freq unknown\n", clock->name);
 			return ret;
 		}
 		clk->bstate.base.domain[clock->name] = ret;

commit da06b46b720687117178d3ee85a601762f1c36b5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:07 2015 +1000

    drm/nouveau/therm: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index a624e9eb0c3b..d54d84aaf763 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -76,7 +76,7 @@ nvkm_clk_adjust(struct nvkm_clk *clk, bool adjust,
 static int
 nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 {
-	struct nvkm_therm *ptherm = nvkm_therm(clk);
+	struct nvkm_therm *therm = nvkm_therm(clk);
 	struct nvkm_volt *volt = nvkm_volt(clk);
 	struct nvkm_cstate *cstate;
 	int ret;
@@ -87,8 +87,8 @@ nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 		cstate = &pstate->base;
 	}
 
-	if (ptherm) {
-		ret = nvkm_therm_cstate(ptherm, pstate->fanspeed, +1);
+	if (therm) {
+		ret = nvkm_therm_cstate(therm, pstate->fanspeed, +1);
 		if (ret && ret != -ENODEV) {
 			nv_error(clk, "failed to raise fan speed: %d\n", ret);
 			return ret;
@@ -115,8 +115,8 @@ nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 			nv_error(clk, "failed to lower voltage: %d\n", ret);
 	}
 
-	if (ptherm) {
-		ret = nvkm_therm_cstate(ptherm, pstate->fanspeed, -1);
+	if (therm) {
+		ret = nvkm_therm_cstate(therm, pstate->fanspeed, -1);
 		if (ret && ret != -ENODEV)
 			nv_error(clk, "failed to lower fan speed: %d\n", ret);
 	}

commit b1e4553cb1f9deddbd8c13d95e9cef81967a3f41
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/fb: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index 572fbf1bc72f..a624e9eb0c3b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -171,7 +171,7 @@ nvkm_cstate_new(struct nvkm_clk *clk, int idx, struct nvkm_pstate *pstate)
 static int
 nvkm_pstate_prog(struct nvkm_clk *clk, int pstatei)
 {
-	struct nvkm_fb *pfb = nvkm_fb(clk);
+	struct nvkm_fb *fb = nvkm_fb(clk);
 	struct nvkm_pstate *pstate;
 	int ret, idx = 0;
 
@@ -183,14 +183,14 @@ nvkm_pstate_prog(struct nvkm_clk *clk, int pstatei)
 	nv_debug(clk, "setting performance state %d\n", pstatei);
 	clk->pstate = pstatei;
 
-	if (pfb->ram && pfb->ram->calc) {
+	if (fb->ram && fb->ram->calc) {
 		int khz = pstate->base.domain[nv_clk_src_mem];
 		do {
-			ret = pfb->ram->calc(pfb, khz);
+			ret = fb->ram->calc(fb, khz);
 			if (ret == 0)
-				ret = pfb->ram->prog(pfb);
+				ret = fb->ram->prog(fb);
 		} while (ret > 0);
-		pfb->ram->tidy(pfb);
+		fb->ram->tidy(fb);
 	}
 
 	return nvkm_cstate_prog(clk, pstate, 0);

commit 3eca809b3c05ea6918c1d13da478abdae5e712ba
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/clk: cosmetic changes
    
    This is purely preparation for upcoming commits, there should be no
    code changes here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index cba018d02b4b..572fbf1bc72f 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -121,7 +121,7 @@ nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 			nv_error(clk, "failed to lower fan speed: %d\n", ret);
 	}
 
-	return 0;
+	return ret;
 }
 
 static void
@@ -474,7 +474,7 @@ _nvkm_clk_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nvkm_clk *clk = (void *)object;
 	nvkm_notify_put(&clk->pwrsrc_ntfy);
-	return nvkm_subdev_fini(&clk->base, suspend);
+	return nvkm_subdev_fini(&clk->subdev, suspend);
 }
 
 int
@@ -484,7 +484,7 @@ _nvkm_clk_init(struct nvkm_object *object)
 	struct nvkm_domain *clock = clk->domains;
 	int ret;
 
-	ret = nvkm_subdev_init(&clk->base);
+	ret = nvkm_subdev_init(&clk->subdev);
 	if (ret)
 		return ret;
 
@@ -524,7 +524,7 @@ _nvkm_clk_dtor(struct nvkm_object *object)
 		nvkm_pstate_del(pstate);
 	}
 
-	nvkm_subdev_destroy(&clk->base);
+	nvkm_subdev_destroy(&clk->subdev);
 }
 
 int

commit 9ace404b1098221021b01c2ba0eeea0c257fa4a5
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:06 2015 +1000

    drm/nouveau/device: include core/device.h automatically for subdevs/engines
    
    Pretty much every subdev/engine is going to need access to nvkm_device
    shortly to touch registers and/or output messages.
    
    The odd placement of the includes is necessary to work around some
    inter-dependencies that currently exist.  This will be fixed later.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index 77a0ab5ca3b0..cba018d02b4b 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -30,7 +30,6 @@
 #include <subdev/therm.h>
 #include <subdev/volt.h>
 
-#include <core/device.h>
 #include <core/option.h>
 
 /******************************************************************************

commit 85fa319d8a5240bab2e4123cfc9178bff55694ca
Author: Wei Ni <wni@nvidia.com>
Date:   Tue Jun 16 17:35:12 2015 +0800

    drm/nouveau/drm/nouveau/clk: fix tstate to pstate calculation
    
    According to the tstate calculation in nvkm_clk_tstate(),
    the range of tstate is from -(clk->state_nr - 1) to 0,
    it mean the tstate is negative value. But in nvkm_pstate_work(),
    it use (clk->state_nr - 1 - clk->tstate) to limit pstate,
    it's not correct.
    This patch fix it to use (clk->state_nr - 1 + clk->tstate) to
    limit pstate.
    
    Signed-off-by: Wei Ni <wni@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index 39a83d82e0cd..77a0ab5ca3b0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -214,7 +214,7 @@ nvkm_pstate_work(struct work_struct *work)
 	pstate = clk->pwrsrc ? clk->ustate_ac : clk->ustate_dc;
 	if (clk->state_nr && pstate != -1) {
 		pstate = (pstate < 0) ? clk->astate : pstate;
-		pstate = min(pstate, clk->state_nr - 1 - clk->tstate);
+		pstate = min(pstate, clk->state_nr - 1 + clk->tstate);
 		pstate = max(pstate, clk->dstate);
 	} else {
 		pstate = clk->pstate = -1;

commit eaecf0326f096faaba462eae48a3b30bcb1f7009
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Fri Feb 20 18:22:59 2015 +0900

    make RAM device optional
    
    Having a RAM device does not make sense for chips like GK20A which have
    no dedicated video memory. The dummy RAM device that we used so far
    works as a temporary band-aid, but in the longer term it is desirable
    for the driver to be able to work without any kind of VRAM.
    
    This patch adds a few conditionals in places where a RAM device was
    assumed to be present and allows some more objects to be allocated from
    the TT domain, allowing Nouveau to handle GPUs for which
    pfb->ram == NULL.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index b24a9cc04b73..39a83d82e0cd 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -184,7 +184,7 @@ nvkm_pstate_prog(struct nvkm_clk *clk, int pstatei)
 	nv_debug(clk, "setting performance state %d\n", pstatei);
 	clk->pstate = pstatei;
 
-	if (pfb->ram->calc) {
+	if (pfb->ram && pfb->ram->calc) {
 		int khz = pstate->base.domain[nv_clk_src_mem];
 		do {
 			ret = pfb->ram->calc(pfb, khz);

commit de3aaa6651ed7075e293c4e48c482012e8e8c87d
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 15:13:36 2015 +1000

    drm/nouveau/volt: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index adfd3d93e066..b24a9cc04b73 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -30,6 +30,7 @@
 #include <subdev/therm.h>
 #include <subdev/volt.h>
 
+#include <core/device.h>
 #include <core/option.h>
 
 /******************************************************************************

commit 7632b30e4b8be39270b098948c5b2f05fae8b691
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jan 14 14:47:24 2015 +1000

    drm/nouveau/clk: namespace + nvidia gpu names (no binary change)
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
index a0c21ec3f61d..adfd3d93e066 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -21,27 +21,25 @@
  *
  * Authors: Ben Skeggs
  */
-
-#include <core/option.h>
-
 #include <subdev/clk.h>
-#include <subdev/therm.h>
-#include <subdev/volt.h>
-#include <subdev/fb.h>
-
 #include <subdev/bios.h>
 #include <subdev/bios/boost.h>
 #include <subdev/bios/cstep.h>
 #include <subdev/bios/perf.h>
+#include <subdev/fb.h>
+#include <subdev/therm.h>
+#include <subdev/volt.h>
+
+#include <core/option.h>
 
 /******************************************************************************
  * misc
  *****************************************************************************/
 static u32
-nouveau_clk_adjust(struct nouveau_clk *clk, bool adjust,
-		     u8 pstate, u8 domain, u32 input)
+nvkm_clk_adjust(struct nvkm_clk *clk, bool adjust,
+		u8 pstate, u8 domain, u32 input)
 {
-	struct nouveau_bios *bios = nouveau_bios(clk);
+	struct nvkm_bios *bios = nvkm_bios(clk);
 	struct nvbios_boostE boostE;
 	u8  ver, hdr, cnt, len;
 	u16 data;
@@ -76,12 +74,11 @@ nouveau_clk_adjust(struct nouveau_clk *clk, bool adjust,
  * C-States
  *****************************************************************************/
 static int
-nouveau_cstate_prog(struct nouveau_clk *clk,
-		    struct nouveau_pstate *pstate, int cstatei)
+nvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)
 {
-	struct nouveau_therm *ptherm = nouveau_therm(clk);
-	struct nouveau_volt *volt = nouveau_volt(clk);
-	struct nouveau_cstate *cstate;
+	struct nvkm_therm *ptherm = nvkm_therm(clk);
+	struct nvkm_volt *volt = nvkm_volt(clk);
+	struct nvkm_cstate *cstate;
 	int ret;
 
 	if (!list_empty(&pstate->list)) {
@@ -91,7 +88,7 @@ nouveau_cstate_prog(struct nouveau_clk *clk,
 	}
 
 	if (ptherm) {
-		ret = nouveau_therm_cstate(ptherm, pstate->fanspeed, +1);
+		ret = nvkm_therm_cstate(ptherm, pstate->fanspeed, +1);
 		if (ret && ret != -ENODEV) {
 			nv_error(clk, "failed to raise fan speed: %d\n", ret);
 			return ret;
@@ -119,7 +116,7 @@ nouveau_cstate_prog(struct nouveau_clk *clk,
 	}
 
 	if (ptherm) {
-		ret = nouveau_therm_cstate(ptherm, pstate->fanspeed, -1);
+		ret = nvkm_therm_cstate(ptherm, pstate->fanspeed, -1);
 		if (ret && ret != -ENODEV)
 			nv_error(clk, "failed to lower fan speed: %d\n", ret);
 	}
@@ -128,19 +125,18 @@ nouveau_cstate_prog(struct nouveau_clk *clk,
 }
 
 static void
-nouveau_cstate_del(struct nouveau_cstate *cstate)
+nvkm_cstate_del(struct nvkm_cstate *cstate)
 {
 	list_del(&cstate->head);
 	kfree(cstate);
 }
 
 static int
-nouveau_cstate_new(struct nouveau_clk *clk, int idx,
-		   struct nouveau_pstate *pstate)
+nvkm_cstate_new(struct nvkm_clk *clk, int idx, struct nvkm_pstate *pstate)
 {
-	struct nouveau_bios *bios = nouveau_bios(clk);
-	struct nouveau_domain *domain = clk->domains;
-	struct nouveau_cstate *cstate = NULL;
+	struct nvkm_bios *bios = nvkm_bios(clk);
+	struct nvkm_domain *domain = clk->domains;
+	struct nvkm_cstate *cstate = NULL;
 	struct nvbios_cstepX cstepX;
 	u8  ver, hdr;
 	u16 data;
@@ -158,10 +154,8 @@ nouveau_cstate_new(struct nouveau_clk *clk, int idx,
 
 	while (domain && domain->name != nv_clk_src_max) {
 		if (domain->flags & NVKM_CLK_DOM_FLAG_CORE) {
-			u32 freq = nouveau_clk_adjust(clk, true,
-							pstate->pstate,
-							domain->bios,
-							cstepX.freq);
+			u32 freq = nvkm_clk_adjust(clk, true, pstate->pstate,
+						   domain->bios, cstepX.freq);
 			cstate->domain[domain->name] = freq;
 		}
 		domain++;
@@ -175,10 +169,10 @@ nouveau_cstate_new(struct nouveau_clk *clk, int idx,
  * P-States
  *****************************************************************************/
 static int
-nouveau_pstate_prog(struct nouveau_clk *clk, int pstatei)
+nvkm_pstate_prog(struct nvkm_clk *clk, int pstatei)
 {
-	struct nouveau_fb *pfb = nouveau_fb(clk);
-	struct nouveau_pstate *pstate;
+	struct nvkm_fb *pfb = nvkm_fb(clk);
+	struct nvkm_pstate *pstate;
 	int ret, idx = 0;
 
 	list_for_each_entry(pstate, &clk->states, head) {
@@ -199,13 +193,13 @@ nouveau_pstate_prog(struct nouveau_clk *clk, int pstatei)
 		pfb->ram->tidy(pfb);
 	}
 
-	return nouveau_cstate_prog(clk, pstate, 0);
+	return nvkm_cstate_prog(clk, pstate, 0);
 }
 
 static void
-nouveau_pstate_work(struct work_struct *work)
+nvkm_pstate_work(struct work_struct *work)
 {
-	struct nouveau_clk *clk = container_of(work, typeof(*clk), work);
+	struct nvkm_clk *clk = container_of(work, typeof(*clk), work);
 	int pstate;
 
 	if (!atomic_xchg(&clk->waiting, 0))
@@ -227,7 +221,7 @@ nouveau_pstate_work(struct work_struct *work)
 
 	nv_trace(clk, "-> %d\n", pstate);
 	if (pstate != clk->pstate) {
-		int ret = nouveau_pstate_prog(clk, pstate);
+		int ret = nvkm_pstate_prog(clk, pstate);
 		if (ret) {
 			nv_error(clk, "error setting pstate %d: %d\n",
 				 pstate, ret);
@@ -239,7 +233,7 @@ nouveau_pstate_work(struct work_struct *work)
 }
 
 static int
-nouveau_pstate_calc(struct nouveau_clk *clk, bool wait)
+nvkm_pstate_calc(struct nvkm_clk *clk, bool wait)
 {
 	atomic_set(&clk->waiting, 1);
 	schedule_work(&clk->work);
@@ -249,10 +243,10 @@ nouveau_pstate_calc(struct nouveau_clk *clk, bool wait)
 }
 
 static void
-nouveau_pstate_info(struct nouveau_clk *clk, struct nouveau_pstate *pstate)
+nvkm_pstate_info(struct nvkm_clk *clk, struct nvkm_pstate *pstate)
 {
-	struct nouveau_domain *clock = clk->domains - 1;
-	struct nouveau_cstate *cstate;
+	struct nvkm_domain *clock = clk->domains - 1;
+	struct nvkm_cstate *cstate;
 	char info[3][32] = { "", "", "" };
 	char name[4] = "--";
 	int i = -1;
@@ -291,12 +285,12 @@ nouveau_pstate_info(struct nouveau_clk *clk, struct nouveau_pstate *pstate)
 }
 
 static void
-nouveau_pstate_del(struct nouveau_pstate *pstate)
+nvkm_pstate_del(struct nvkm_pstate *pstate)
 {
-	struct nouveau_cstate *cstate, *temp;
+	struct nvkm_cstate *cstate, *temp;
 
 	list_for_each_entry_safe(cstate, temp, &pstate->list, head) {
-		nouveau_cstate_del(cstate);
+		nvkm_cstate_del(cstate);
 	}
 
 	list_del(&pstate->head);
@@ -304,12 +298,12 @@ nouveau_pstate_del(struct nouveau_pstate *pstate)
 }
 
 static int
-nouveau_pstate_new(struct nouveau_clk *clk, int idx)
+nvkm_pstate_new(struct nvkm_clk *clk, int idx)
 {
-	struct nouveau_bios *bios = nouveau_bios(clk);
-	struct nouveau_domain *domain = clk->domains - 1;
-	struct nouveau_pstate *pstate;
-	struct nouveau_cstate *cstate;
+	struct nvkm_bios *bios = nvkm_bios(clk);
+	struct nvkm_domain *domain = clk->domains - 1;
+	struct nvkm_pstate *pstate;
+	struct nvkm_cstate *cstate;
 	struct nvbios_cstepE cstepE;
 	struct nvbios_perfE perfE;
 	u8  ver, hdr, cnt, len;
@@ -346,10 +340,10 @@ nouveau_pstate_new(struct nouveau_clk *clk, int idx)
 			continue;
 
 		if (domain->flags & NVKM_CLK_DOM_FLAG_CORE) {
-			perfS.v40.freq = nouveau_clk_adjust(clk, false,
-							      pstate->pstate,
-							      domain->bios,
-							      perfS.v40.freq);
+			perfS.v40.freq = nvkm_clk_adjust(clk, false,
+							 pstate->pstate,
+							 domain->bios,
+							 perfS.v40.freq);
 		}
 
 		cstate->domain[domain->name] = perfS.v40.freq;
@@ -359,11 +353,11 @@ nouveau_pstate_new(struct nouveau_clk *clk, int idx)
 	if (data) {
 		int idx = cstepE.index;
 		do {
-			nouveau_cstate_new(clk, idx, pstate);
+			nvkm_cstate_new(clk, idx, pstate);
 		} while(idx--);
 	}
 
-	nouveau_pstate_info(clk, pstate);
+	nvkm_pstate_info(clk, pstate);
 	list_add_tail(&pstate->head, &clk->states);
 	clk->state_nr++;
 	return 0;
@@ -373,9 +367,9 @@ nouveau_pstate_new(struct nouveau_clk *clk, int idx)
  * Adjustment triggers
  *****************************************************************************/
 static int
-nouveau_clk_ustate_update(struct nouveau_clk *clk, int req)
+nvkm_clk_ustate_update(struct nvkm_clk *clk, int req)
 {
-	struct nouveau_pstate *pstate;
+	struct nvkm_pstate *pstate;
 	int i = 0;
 
 	if (!clk->allow_reclock)
@@ -397,7 +391,7 @@ nouveau_clk_ustate_update(struct nouveau_clk *clk, int req)
 }
 
 static int
-nouveau_clk_nstate(struct nouveau_clk *clk, const char *mode, int arglen)
+nvkm_clk_nstate(struct nvkm_clk *clk, const char *mode, int arglen)
 {
 	int ret = 1;
 
@@ -410,7 +404,7 @@ nouveau_clk_nstate(struct nouveau_clk *clk, const char *mode, int arglen)
 
 		((char *)mode)[arglen] = '\0';
 		if (!kstrtol(mode, 0, &v)) {
-			ret = nouveau_clk_ustate_update(clk, v);
+			ret = nvkm_clk_ustate_update(clk, v);
 			if (ret < 0)
 				ret = 1;
 		}
@@ -421,53 +415,53 @@ nouveau_clk_nstate(struct nouveau_clk *clk, const char *mode, int arglen)
 }
 
 int
-nouveau_clk_ustate(struct nouveau_clk *clk, int req, int pwr)
+nvkm_clk_ustate(struct nvkm_clk *clk, int req, int pwr)
 {
-	int ret = nouveau_clk_ustate_update(clk, req);
+	int ret = nvkm_clk_ustate_update(clk, req);
 	if (ret >= 0) {
 		if (ret -= 2, pwr) clk->ustate_ac = ret;
 		else		   clk->ustate_dc = ret;
-		return nouveau_pstate_calc(clk, true);
+		return nvkm_pstate_calc(clk, true);
 	}
 	return ret;
 }
 
 int
-nouveau_clk_astate(struct nouveau_clk *clk, int req, int rel, bool wait)
+nvkm_clk_astate(struct nvkm_clk *clk, int req, int rel, bool wait)
 {
 	if (!rel) clk->astate  = req;
 	if ( rel) clk->astate += rel;
 	clk->astate = min(clk->astate, clk->state_nr - 1);
 	clk->astate = max(clk->astate, 0);
-	return nouveau_pstate_calc(clk, wait);
+	return nvkm_pstate_calc(clk, wait);
 }
 
 int
-nouveau_clk_tstate(struct nouveau_clk *clk, int req, int rel)
+nvkm_clk_tstate(struct nvkm_clk *clk, int req, int rel)
 {
 	if (!rel) clk->tstate  = req;
 	if ( rel) clk->tstate += rel;
 	clk->tstate = min(clk->tstate, 0);
 	clk->tstate = max(clk->tstate, -(clk->state_nr - 1));
-	return nouveau_pstate_calc(clk, true);
+	return nvkm_pstate_calc(clk, true);
 }
 
 int
-nouveau_clk_dstate(struct nouveau_clk *clk, int req, int rel)
+nvkm_clk_dstate(struct nvkm_clk *clk, int req, int rel)
 {
 	if (!rel) clk->dstate  = req;
 	if ( rel) clk->dstate += rel;
 	clk->dstate = min(clk->dstate, clk->state_nr - 1);
 	clk->dstate = max(clk->dstate, 0);
-	return nouveau_pstate_calc(clk, true);
+	return nvkm_pstate_calc(clk, true);
 }
 
 static int
-nouveau_clk_pwrsrc(struct nvkm_notify *notify)
+nvkm_clk_pwrsrc(struct nvkm_notify *notify)
 {
-	struct nouveau_clk *clk =
+	struct nvkm_clk *clk =
 		container_of(notify, typeof(*clk), pwrsrc_ntfy);
-	nouveau_pstate_calc(clk, false);
+	nvkm_pstate_calc(clk, false);
 	return NVKM_NOTIFY_DROP;
 }
 
@@ -476,21 +470,21 @@ nouveau_clk_pwrsrc(struct nvkm_notify *notify)
  *****************************************************************************/
 
 int
-_nouveau_clk_fini(struct nouveau_object *object, bool suspend)
+_nvkm_clk_fini(struct nvkm_object *object, bool suspend)
 {
-	struct nouveau_clk *clk = (void *)object;
+	struct nvkm_clk *clk = (void *)object;
 	nvkm_notify_put(&clk->pwrsrc_ntfy);
-	return nouveau_subdev_fini(&clk->base, suspend);
+	return nvkm_subdev_fini(&clk->base, suspend);
 }
 
 int
-_nouveau_clk_init(struct nouveau_object *object)
+_nvkm_clk_init(struct nvkm_object *object)
 {
-	struct nouveau_clk *clk = (void *)object;
-	struct nouveau_domain *clock = clk->domains;
+	struct nvkm_clk *clk = (void *)object;
+	struct nvkm_domain *clock = clk->domains;
 	int ret;
 
-	ret = nouveau_subdev_init(&clk->base);
+	ret = nvkm_subdev_init(&clk->base);
 	if (ret)
 		return ret;
 
@@ -508,47 +502,44 @@ _nouveau_clk_init(struct nouveau_object *object)
 		clock++;
 	}
 
-	nouveau_pstate_info(clk, &clk->bstate);
+	nvkm_pstate_info(clk, &clk->bstate);
 
 	clk->astate = clk->state_nr - 1;
 	clk->tstate = 0;
 	clk->dstate = 0;
 	clk->pstate = -1;
-	nouveau_pstate_calc(clk, true);
+	nvkm_pstate_calc(clk, true);
 	return 0;
 }
 
 void
-_nouveau_clk_dtor(struct nouveau_object *object)
+_nvkm_clk_dtor(struct nvkm_object *object)
 {
-	struct nouveau_clk *clk = (void *)object;
-	struct nouveau_pstate *pstate, *temp;
+	struct nvkm_clk *clk = (void *)object;
+	struct nvkm_pstate *pstate, *temp;
 
 	nvkm_notify_fini(&clk->pwrsrc_ntfy);
 
 	list_for_each_entry_safe(pstate, temp, &clk->states, head) {
-		nouveau_pstate_del(pstate);
+		nvkm_pstate_del(pstate);
 	}
 
-	nouveau_subdev_destroy(&clk->base);
+	nvkm_subdev_destroy(&clk->base);
 }
 
 int
-nouveau_clk_create_(struct nouveau_object *parent,
-		      struct nouveau_object *engine,
-		      struct nouveau_oclass *oclass,
-		      struct nouveau_domain *clocks,
-		      struct nouveau_pstate *pstates, int nb_pstates,
-		      bool allow_reclock,
-		      int length, void **object)
+nvkm_clk_create_(struct nvkm_object *parent, struct nvkm_object *engine,
+		 struct nvkm_oclass *oclass, struct nvkm_domain *clocks,
+		 struct nvkm_pstate *pstates, int nb_pstates,
+		 bool allow_reclock, int length, void **object)
 {
-	struct nouveau_device *device = nv_device(parent);
-	struct nouveau_clk *clk;
+	struct nvkm_device *device = nv_device(parent);
+	struct nvkm_clk *clk;
 	int ret, idx, arglen;
 	const char *mode;
 
-	ret = nouveau_subdev_create_(parent, engine, oclass, 0, "CLK",
-				     "clock", length, object);
+	ret = nvkm_subdev_create_(parent, engine, oclass, 0, "CLK",
+				  "clock", length, object);
 	clk = *object;
 	if (ret)
 		return ret;
@@ -558,7 +549,7 @@ nouveau_clk_create_(struct nouveau_object *parent,
 	clk->ustate_ac = -1;
 	clk->ustate_dc = -1;
 
-	INIT_WORK(&clk->work, nouveau_pstate_work);
+	INIT_WORK(&clk->work, nvkm_pstate_work);
 	init_waitqueue_head(&clk->wait);
 	atomic_set(&clk->waiting, 0);
 
@@ -566,7 +557,7 @@ nouveau_clk_create_(struct nouveau_object *parent,
 	if (!pstates) {
 		idx = 0;
 		do {
-			ret = nouveau_pstate_new(clk, idx++);
+			ret = nvkm_pstate_new(clk, idx++);
 		} while (ret == 0);
 	} else {
 		for (idx = 0; idx < nb_pstates; idx++)
@@ -576,25 +567,24 @@ nouveau_clk_create_(struct nouveau_object *parent,
 
 	clk->allow_reclock = allow_reclock;
 
-	ret = nvkm_notify_init(NULL, &device->event, nouveau_clk_pwrsrc, true,
+	ret = nvkm_notify_init(NULL, &device->event, nvkm_clk_pwrsrc, true,
 			       NULL, 0, 0, &clk->pwrsrc_ntfy);
 	if (ret)
 		return ret;
 
-	mode = nouveau_stropt(device->cfgopt, "NvClkMode", &arglen);
+	mode = nvkm_stropt(device->cfgopt, "NvClkMode", &arglen);
 	if (mode) {
-		clk->ustate_ac = nouveau_clk_nstate(clk, mode, arglen);
-		clk->ustate_dc = nouveau_clk_nstate(clk, mode, arglen);
+		clk->ustate_ac = nvkm_clk_nstate(clk, mode, arglen);
+		clk->ustate_dc = nvkm_clk_nstate(clk, mode, arglen);
 	}
 
-	mode = nouveau_stropt(device->cfgopt, "NvClkModeAC", &arglen);
+	mode = nvkm_stropt(device->cfgopt, "NvClkModeAC", &arglen);
 	if (mode)
-		clk->ustate_ac = nouveau_clk_nstate(clk, mode, arglen);
+		clk->ustate_ac = nvkm_clk_nstate(clk, mode, arglen);
 
-	mode = nouveau_stropt(device->cfgopt, "NvClkModeDC", &arglen);
+	mode = nvkm_stropt(device->cfgopt, "NvClkModeDC", &arglen);
 	if (mode)
-		clk->ustate_dc = nouveau_clk_nstate(clk, mode, arglen);
-
+		clk->ustate_dc = nvkm_clk_nstate(clk, mode, arglen);
 
 	return 0;
 }

commit f3867f439fd610db0cbcf1bb739001e95b7b25c6
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jan 13 23:37:38 2015 +1000

    drm/nouveau/clk: rename from clock (no binary change)
    
    Rename to match the Linux subsystem responsible for the same kind of
    things.  Will be investigating how feasible it will be to expose the
    GPU clock trees with it at some point.
    
    The namespace of NVKM is being changed to nvkm_ instead of nouveau_,
    which will be used for the DRM part of the driver.  This is being
    done in order to make it very clear as to what part of the driver a
    given symbol belongs to, and as a minor step towards splitting the
    DRM driver out to be able to stand on its own (for virt).
    
    Because there's already a large amount of churn here anyway, this is
    as good a time as any to also switch to NVIDIA's device and chipset
    naming to ease collaboration with them.
    
    A comparison of objdump disassemblies proves no code changes.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
new file mode 100644
index 000000000000..a0c21ec3f61d
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c
@@ -0,0 +1,600 @@
+/*
+ * Copyright 2013 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <core/option.h>
+
+#include <subdev/clk.h>
+#include <subdev/therm.h>
+#include <subdev/volt.h>
+#include <subdev/fb.h>
+
+#include <subdev/bios.h>
+#include <subdev/bios/boost.h>
+#include <subdev/bios/cstep.h>
+#include <subdev/bios/perf.h>
+
+/******************************************************************************
+ * misc
+ *****************************************************************************/
+static u32
+nouveau_clk_adjust(struct nouveau_clk *clk, bool adjust,
+		     u8 pstate, u8 domain, u32 input)
+{
+	struct nouveau_bios *bios = nouveau_bios(clk);
+	struct nvbios_boostE boostE;
+	u8  ver, hdr, cnt, len;
+	u16 data;
+
+	data = nvbios_boostEm(bios, pstate, &ver, &hdr, &cnt, &len, &boostE);
+	if (data) {
+		struct nvbios_boostS boostS;
+		u8  idx = 0, sver, shdr;
+		u16 subd;
+
+		input = max(boostE.min, input);
+		input = min(boostE.max, input);
+		do {
+			sver = ver;
+			shdr = hdr;
+			subd = nvbios_boostSp(bios, idx++, data, &sver, &shdr,
+					      cnt, len, &boostS);
+			if (subd && boostS.domain == domain) {
+				if (adjust)
+					input = input * boostS.percent / 100;
+				input = max(boostS.min, input);
+				input = min(boostS.max, input);
+				break;
+			}
+		} while (subd);
+	}
+
+	return input;
+}
+
+/******************************************************************************
+ * C-States
+ *****************************************************************************/
+static int
+nouveau_cstate_prog(struct nouveau_clk *clk,
+		    struct nouveau_pstate *pstate, int cstatei)
+{
+	struct nouveau_therm *ptherm = nouveau_therm(clk);
+	struct nouveau_volt *volt = nouveau_volt(clk);
+	struct nouveau_cstate *cstate;
+	int ret;
+
+	if (!list_empty(&pstate->list)) {
+		cstate = list_entry(pstate->list.prev, typeof(*cstate), head);
+	} else {
+		cstate = &pstate->base;
+	}
+
+	if (ptherm) {
+		ret = nouveau_therm_cstate(ptherm, pstate->fanspeed, +1);
+		if (ret && ret != -ENODEV) {
+			nv_error(clk, "failed to raise fan speed: %d\n", ret);
+			return ret;
+		}
+	}
+
+	if (volt) {
+		ret = volt->set_id(volt, cstate->voltage, +1);
+		if (ret && ret != -ENODEV) {
+			nv_error(clk, "failed to raise voltage: %d\n", ret);
+			return ret;
+		}
+	}
+
+	ret = clk->calc(clk, cstate);
+	if (ret == 0) {
+		ret = clk->prog(clk);
+		clk->tidy(clk);
+	}
+
+	if (volt) {
+		ret = volt->set_id(volt, cstate->voltage, -1);
+		if (ret && ret != -ENODEV)
+			nv_error(clk, "failed to lower voltage: %d\n", ret);
+	}
+
+	if (ptherm) {
+		ret = nouveau_therm_cstate(ptherm, pstate->fanspeed, -1);
+		if (ret && ret != -ENODEV)
+			nv_error(clk, "failed to lower fan speed: %d\n", ret);
+	}
+
+	return 0;
+}
+
+static void
+nouveau_cstate_del(struct nouveau_cstate *cstate)
+{
+	list_del(&cstate->head);
+	kfree(cstate);
+}
+
+static int
+nouveau_cstate_new(struct nouveau_clk *clk, int idx,
+		   struct nouveau_pstate *pstate)
+{
+	struct nouveau_bios *bios = nouveau_bios(clk);
+	struct nouveau_domain *domain = clk->domains;
+	struct nouveau_cstate *cstate = NULL;
+	struct nvbios_cstepX cstepX;
+	u8  ver, hdr;
+	u16 data;
+
+	data = nvbios_cstepXp(bios, idx, &ver, &hdr, &cstepX);
+	if (!data)
+		return -ENOENT;
+
+	cstate = kzalloc(sizeof(*cstate), GFP_KERNEL);
+	if (!cstate)
+		return -ENOMEM;
+
+	*cstate = pstate->base;
+	cstate->voltage = cstepX.voltage;
+
+	while (domain && domain->name != nv_clk_src_max) {
+		if (domain->flags & NVKM_CLK_DOM_FLAG_CORE) {
+			u32 freq = nouveau_clk_adjust(clk, true,
+							pstate->pstate,
+							domain->bios,
+							cstepX.freq);
+			cstate->domain[domain->name] = freq;
+		}
+		domain++;
+	}
+
+	list_add(&cstate->head, &pstate->list);
+	return 0;
+}
+
+/******************************************************************************
+ * P-States
+ *****************************************************************************/
+static int
+nouveau_pstate_prog(struct nouveau_clk *clk, int pstatei)
+{
+	struct nouveau_fb *pfb = nouveau_fb(clk);
+	struct nouveau_pstate *pstate;
+	int ret, idx = 0;
+
+	list_for_each_entry(pstate, &clk->states, head) {
+		if (idx++ == pstatei)
+			break;
+	}
+
+	nv_debug(clk, "setting performance state %d\n", pstatei);
+	clk->pstate = pstatei;
+
+	if (pfb->ram->calc) {
+		int khz = pstate->base.domain[nv_clk_src_mem];
+		do {
+			ret = pfb->ram->calc(pfb, khz);
+			if (ret == 0)
+				ret = pfb->ram->prog(pfb);
+		} while (ret > 0);
+		pfb->ram->tidy(pfb);
+	}
+
+	return nouveau_cstate_prog(clk, pstate, 0);
+}
+
+static void
+nouveau_pstate_work(struct work_struct *work)
+{
+	struct nouveau_clk *clk = container_of(work, typeof(*clk), work);
+	int pstate;
+
+	if (!atomic_xchg(&clk->waiting, 0))
+		return;
+	clk->pwrsrc = power_supply_is_system_supplied();
+
+	nv_trace(clk, "P %d PWR %d U(AC) %d U(DC) %d A %d T %d D %d\n",
+		 clk->pstate, clk->pwrsrc, clk->ustate_ac, clk->ustate_dc,
+		 clk->astate, clk->tstate, clk->dstate);
+
+	pstate = clk->pwrsrc ? clk->ustate_ac : clk->ustate_dc;
+	if (clk->state_nr && pstate != -1) {
+		pstate = (pstate < 0) ? clk->astate : pstate;
+		pstate = min(pstate, clk->state_nr - 1 - clk->tstate);
+		pstate = max(pstate, clk->dstate);
+	} else {
+		pstate = clk->pstate = -1;
+	}
+
+	nv_trace(clk, "-> %d\n", pstate);
+	if (pstate != clk->pstate) {
+		int ret = nouveau_pstate_prog(clk, pstate);
+		if (ret) {
+			nv_error(clk, "error setting pstate %d: %d\n",
+				 pstate, ret);
+		}
+	}
+
+	wake_up_all(&clk->wait);
+	nvkm_notify_get(&clk->pwrsrc_ntfy);
+}
+
+static int
+nouveau_pstate_calc(struct nouveau_clk *clk, bool wait)
+{
+	atomic_set(&clk->waiting, 1);
+	schedule_work(&clk->work);
+	if (wait)
+		wait_event(clk->wait, !atomic_read(&clk->waiting));
+	return 0;
+}
+
+static void
+nouveau_pstate_info(struct nouveau_clk *clk, struct nouveau_pstate *pstate)
+{
+	struct nouveau_domain *clock = clk->domains - 1;
+	struct nouveau_cstate *cstate;
+	char info[3][32] = { "", "", "" };
+	char name[4] = "--";
+	int i = -1;
+
+	if (pstate->pstate != 0xff)
+		snprintf(name, sizeof(name), "%02x", pstate->pstate);
+
+	while ((++clock)->name != nv_clk_src_max) {
+		u32 lo = pstate->base.domain[clock->name];
+		u32 hi = lo;
+		if (hi == 0)
+			continue;
+
+		nv_debug(clk, "%02x: %10d KHz\n", clock->name, lo);
+		list_for_each_entry(cstate, &pstate->list, head) {
+			u32 freq = cstate->domain[clock->name];
+			lo = min(lo, freq);
+			hi = max(hi, freq);
+			nv_debug(clk, "%10d KHz\n", freq);
+		}
+
+		if (clock->mname && ++i < ARRAY_SIZE(info)) {
+			lo /= clock->mdiv;
+			hi /= clock->mdiv;
+			if (lo == hi) {
+				snprintf(info[i], sizeof(info[i]), "%s %d MHz",
+					 clock->mname, lo);
+			} else {
+				snprintf(info[i], sizeof(info[i]),
+					 "%s %d-%d MHz", clock->mname, lo, hi);
+			}
+		}
+	}
+
+	nv_info(clk, "%s: %s %s %s\n", name, info[0], info[1], info[2]);
+}
+
+static void
+nouveau_pstate_del(struct nouveau_pstate *pstate)
+{
+	struct nouveau_cstate *cstate, *temp;
+
+	list_for_each_entry_safe(cstate, temp, &pstate->list, head) {
+		nouveau_cstate_del(cstate);
+	}
+
+	list_del(&pstate->head);
+	kfree(pstate);
+}
+
+static int
+nouveau_pstate_new(struct nouveau_clk *clk, int idx)
+{
+	struct nouveau_bios *bios = nouveau_bios(clk);
+	struct nouveau_domain *domain = clk->domains - 1;
+	struct nouveau_pstate *pstate;
+	struct nouveau_cstate *cstate;
+	struct nvbios_cstepE cstepE;
+	struct nvbios_perfE perfE;
+	u8  ver, hdr, cnt, len;
+	u16 data;
+
+	data = nvbios_perfEp(bios, idx, &ver, &hdr, &cnt, &len, &perfE);
+	if (!data)
+		return -EINVAL;
+	if (perfE.pstate == 0xff)
+		return 0;
+
+	pstate = kzalloc(sizeof(*pstate), GFP_KERNEL);
+	cstate = &pstate->base;
+	if (!pstate)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&pstate->list);
+
+	pstate->pstate = perfE.pstate;
+	pstate->fanspeed = perfE.fanspeed;
+	cstate->voltage = perfE.voltage;
+	cstate->domain[nv_clk_src_core] = perfE.core;
+	cstate->domain[nv_clk_src_shader] = perfE.shader;
+	cstate->domain[nv_clk_src_mem] = perfE.memory;
+	cstate->domain[nv_clk_src_vdec] = perfE.vdec;
+	cstate->domain[nv_clk_src_dom6] = perfE.disp;
+
+	while (ver >= 0x40 && (++domain)->name != nv_clk_src_max) {
+		struct nvbios_perfS perfS;
+		u8  sver = ver, shdr = hdr;
+		u32 perfSe = nvbios_perfSp(bios, data, domain->bios,
+					  &sver, &shdr, cnt, len, &perfS);
+		if (perfSe == 0 || sver != 0x40)
+			continue;
+
+		if (domain->flags & NVKM_CLK_DOM_FLAG_CORE) {
+			perfS.v40.freq = nouveau_clk_adjust(clk, false,
+							      pstate->pstate,
+							      domain->bios,
+							      perfS.v40.freq);
+		}
+
+		cstate->domain[domain->name] = perfS.v40.freq;
+	}
+
+	data = nvbios_cstepEm(bios, pstate->pstate, &ver, &hdr, &cstepE);
+	if (data) {
+		int idx = cstepE.index;
+		do {
+			nouveau_cstate_new(clk, idx, pstate);
+		} while(idx--);
+	}
+
+	nouveau_pstate_info(clk, pstate);
+	list_add_tail(&pstate->head, &clk->states);
+	clk->state_nr++;
+	return 0;
+}
+
+/******************************************************************************
+ * Adjustment triggers
+ *****************************************************************************/
+static int
+nouveau_clk_ustate_update(struct nouveau_clk *clk, int req)
+{
+	struct nouveau_pstate *pstate;
+	int i = 0;
+
+	if (!clk->allow_reclock)
+		return -ENOSYS;
+
+	if (req != -1 && req != -2) {
+		list_for_each_entry(pstate, &clk->states, head) {
+			if (pstate->pstate == req)
+				break;
+			i++;
+		}
+
+		if (pstate->pstate != req)
+			return -EINVAL;
+		req = i;
+	}
+
+	return req + 2;
+}
+
+static int
+nouveau_clk_nstate(struct nouveau_clk *clk, const char *mode, int arglen)
+{
+	int ret = 1;
+
+	if (clk->allow_reclock && !strncasecmpz(mode, "auto", arglen))
+		return -2;
+
+	if (strncasecmpz(mode, "disabled", arglen)) {
+		char save = mode[arglen];
+		long v;
+
+		((char *)mode)[arglen] = '\0';
+		if (!kstrtol(mode, 0, &v)) {
+			ret = nouveau_clk_ustate_update(clk, v);
+			if (ret < 0)
+				ret = 1;
+		}
+		((char *)mode)[arglen] = save;
+	}
+
+	return ret - 2;
+}
+
+int
+nouveau_clk_ustate(struct nouveau_clk *clk, int req, int pwr)
+{
+	int ret = nouveau_clk_ustate_update(clk, req);
+	if (ret >= 0) {
+		if (ret -= 2, pwr) clk->ustate_ac = ret;
+		else		   clk->ustate_dc = ret;
+		return nouveau_pstate_calc(clk, true);
+	}
+	return ret;
+}
+
+int
+nouveau_clk_astate(struct nouveau_clk *clk, int req, int rel, bool wait)
+{
+	if (!rel) clk->astate  = req;
+	if ( rel) clk->astate += rel;
+	clk->astate = min(clk->astate, clk->state_nr - 1);
+	clk->astate = max(clk->astate, 0);
+	return nouveau_pstate_calc(clk, wait);
+}
+
+int
+nouveau_clk_tstate(struct nouveau_clk *clk, int req, int rel)
+{
+	if (!rel) clk->tstate  = req;
+	if ( rel) clk->tstate += rel;
+	clk->tstate = min(clk->tstate, 0);
+	clk->tstate = max(clk->tstate, -(clk->state_nr - 1));
+	return nouveau_pstate_calc(clk, true);
+}
+
+int
+nouveau_clk_dstate(struct nouveau_clk *clk, int req, int rel)
+{
+	if (!rel) clk->dstate  = req;
+	if ( rel) clk->dstate += rel;
+	clk->dstate = min(clk->dstate, clk->state_nr - 1);
+	clk->dstate = max(clk->dstate, 0);
+	return nouveau_pstate_calc(clk, true);
+}
+
+static int
+nouveau_clk_pwrsrc(struct nvkm_notify *notify)
+{
+	struct nouveau_clk *clk =
+		container_of(notify, typeof(*clk), pwrsrc_ntfy);
+	nouveau_pstate_calc(clk, false);
+	return NVKM_NOTIFY_DROP;
+}
+
+/******************************************************************************
+ * subdev base class implementation
+ *****************************************************************************/
+
+int
+_nouveau_clk_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nouveau_clk *clk = (void *)object;
+	nvkm_notify_put(&clk->pwrsrc_ntfy);
+	return nouveau_subdev_fini(&clk->base, suspend);
+}
+
+int
+_nouveau_clk_init(struct nouveau_object *object)
+{
+	struct nouveau_clk *clk = (void *)object;
+	struct nouveau_domain *clock = clk->domains;
+	int ret;
+
+	ret = nouveau_subdev_init(&clk->base);
+	if (ret)
+		return ret;
+
+	memset(&clk->bstate, 0x00, sizeof(clk->bstate));
+	INIT_LIST_HEAD(&clk->bstate.list);
+	clk->bstate.pstate = 0xff;
+
+	while (clock->name != nv_clk_src_max) {
+		ret = clk->read(clk, clock->name);
+		if (ret < 0) {
+			nv_error(clk, "%02x freq unknown\n", clock->name);
+			return ret;
+		}
+		clk->bstate.base.domain[clock->name] = ret;
+		clock++;
+	}
+
+	nouveau_pstate_info(clk, &clk->bstate);
+
+	clk->astate = clk->state_nr - 1;
+	clk->tstate = 0;
+	clk->dstate = 0;
+	clk->pstate = -1;
+	nouveau_pstate_calc(clk, true);
+	return 0;
+}
+
+void
+_nouveau_clk_dtor(struct nouveau_object *object)
+{
+	struct nouveau_clk *clk = (void *)object;
+	struct nouveau_pstate *pstate, *temp;
+
+	nvkm_notify_fini(&clk->pwrsrc_ntfy);
+
+	list_for_each_entry_safe(pstate, temp, &clk->states, head) {
+		nouveau_pstate_del(pstate);
+	}
+
+	nouveau_subdev_destroy(&clk->base);
+}
+
+int
+nouveau_clk_create_(struct nouveau_object *parent,
+		      struct nouveau_object *engine,
+		      struct nouveau_oclass *oclass,
+		      struct nouveau_domain *clocks,
+		      struct nouveau_pstate *pstates, int nb_pstates,
+		      bool allow_reclock,
+		      int length, void **object)
+{
+	struct nouveau_device *device = nv_device(parent);
+	struct nouveau_clk *clk;
+	int ret, idx, arglen;
+	const char *mode;
+
+	ret = nouveau_subdev_create_(parent, engine, oclass, 0, "CLK",
+				     "clock", length, object);
+	clk = *object;
+	if (ret)
+		return ret;
+
+	INIT_LIST_HEAD(&clk->states);
+	clk->domains = clocks;
+	clk->ustate_ac = -1;
+	clk->ustate_dc = -1;
+
+	INIT_WORK(&clk->work, nouveau_pstate_work);
+	init_waitqueue_head(&clk->wait);
+	atomic_set(&clk->waiting, 0);
+
+	/* If no pstates are provided, try and fetch them from the BIOS */
+	if (!pstates) {
+		idx = 0;
+		do {
+			ret = nouveau_pstate_new(clk, idx++);
+		} while (ret == 0);
+	} else {
+		for (idx = 0; idx < nb_pstates; idx++)
+			list_add_tail(&pstates[idx].head, &clk->states);
+		clk->state_nr = nb_pstates;
+	}
+
+	clk->allow_reclock = allow_reclock;
+
+	ret = nvkm_notify_init(NULL, &device->event, nouveau_clk_pwrsrc, true,
+			       NULL, 0, 0, &clk->pwrsrc_ntfy);
+	if (ret)
+		return ret;
+
+	mode = nouveau_stropt(device->cfgopt, "NvClkMode", &arglen);
+	if (mode) {
+		clk->ustate_ac = nouveau_clk_nstate(clk, mode, arglen);
+		clk->ustate_dc = nouveau_clk_nstate(clk, mode, arglen);
+	}
+
+	mode = nouveau_stropt(device->cfgopt, "NvClkModeAC", &arglen);
+	if (mode)
+		clk->ustate_ac = nouveau_clk_nstate(clk, mode, arglen);
+
+	mode = nouveau_stropt(device->cfgopt, "NvClkModeDC", &arglen);
+	if (mode)
+		clk->ustate_dc = nouveau_clk_nstate(clk, mode, arglen);
+
+
+	return 0;
+}
