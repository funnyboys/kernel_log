commit 71871aa6df5009ebf39ae94d15d0e9836bf91c03
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Mon Jul 9 16:07:40 2018 +1000

    drm/nouveau/mmu/gp100-: add privileged methods for fault replay/cancel
    
    Host methods exist to do at least some of what we need, but we are not
    currently pushing replay/cancels through a channel like UVM does as it's
    not clear whether it's necessary in our case (UVM also updates PTEs with
    the GPU).
    
    UVM also pushes a software method for fault cancels on Pascal, seemingly
    because the host methods don't appear to be sufficient.  If/when we want
    to push the replay/cancel on the GPU, we can re-purpose the cancellation
    code here to implement that swmthd.
    
    Keep it simple for now, until we figure out exactly what we need here.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/include/nvif/if000c.h b/drivers/gpu/drm/nouveau/include/nvif/if000c.h
index 20374882ac8f..d6dd40f21eed 100644
--- a/drivers/gpu/drm/nouveau/include/nvif/if000c.h
+++ b/drivers/gpu/drm/nouveau/include/nvif/if000c.h
@@ -17,6 +17,7 @@ struct nvif_vmm_v0 {
 #define NVIF_VMM_V0_UNMAP                                                  0x04
 #define NVIF_VMM_V0_PFNMAP                                                 0x05
 #define NVIF_VMM_V0_PFNCLR                                                 0x06
+#define NVIF_VMM_V0_MTHD(i)                                         ((i) + 0x80)
 
 struct nvif_vmm_page_v0 {
 	__u8  version;

commit a5ff307fe1f2dfe91253e3c19586643a77b6ce52
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sat Jul 7 12:35:48 2018 +1000

    drm/nouveau/mmu: add a privileged method to directly manage PTEs
    
    This provides a somewhat more direct method of manipulating the GPU page
    tables, which will be required to support SVM.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/include/nvif/if000c.h b/drivers/gpu/drm/nouveau/include/nvif/if000c.h
index f8e29cfee7f8..20374882ac8f 100644
--- a/drivers/gpu/drm/nouveau/include/nvif/if000c.h
+++ b/drivers/gpu/drm/nouveau/include/nvif/if000c.h
@@ -15,6 +15,8 @@ struct nvif_vmm_v0 {
 #define NVIF_VMM_V0_PUT                                                    0x02
 #define NVIF_VMM_V0_MAP                                                    0x03
 #define NVIF_VMM_V0_UNMAP                                                  0x04
+#define NVIF_VMM_V0_PFNMAP                                                 0x05
+#define NVIF_VMM_V0_PFNCLR                                                 0x06
 
 struct nvif_vmm_page_v0 {
 	__u8  version;
@@ -62,4 +64,28 @@ struct nvif_vmm_unmap_v0 {
 	__u8  pad01[7];
 	__u64 addr;
 };
+
+struct nvif_vmm_pfnmap_v0 {
+	__u8  version;
+	__u8  page;
+	__u8  pad02[6];
+	__u64 addr;
+	__u64 size;
+#define NVIF_VMM_PFNMAP_V0_ADDR                           0xfffffffffffff000ULL
+#define NVIF_VMM_PFNMAP_V0_ADDR_SHIFT                                        12
+#define NVIF_VMM_PFNMAP_V0_APER                           0x00000000000000f0ULL
+#define NVIF_VMM_PFNMAP_V0_HOST                           0x0000000000000000ULL
+#define NVIF_VMM_PFNMAP_V0_VRAM                           0x0000000000000010ULL
+#define NVIF_VMM_PFNMAP_V0_W                              0x0000000000000002ULL
+#define NVIF_VMM_PFNMAP_V0_V                              0x0000000000000001ULL
+#define NVIF_VMM_PFNMAP_V0_NONE                           0x0000000000000000ULL
+	__u64 phys[];
+};
+
+struct nvif_vmm_pfnclr_v0 {
+	__u8  version;
+	__u8  pad01[7];
+	__u64 addr;
+	__u64 size;
+};
 #endif

commit 2606f291621eb319726243e0f3893644114277f8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jun 13 16:25:53 2018 +1000

    drm/nouveau/mmu: support initialisation of client-managed address-spaces
    
    NVKM is currently responsible for managing the allocation of a client's
    GPU address-space, but there's various use-cases (ie. HMM address-space
    mirroring) where giving a client more direct control is desirable.
    
    This commit allows for a VMM to be created where the area allocated for
    NVKM is limited to a client-specified window, the remainder of address-
    space is controlled directly by the client.
    
    Leaving a window is necessary to support various internal requirements,
    but also to support existing allocation interfaces as not all of the HW
    is capable of working with a HMM allocation.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/include/nvif/if000c.h b/drivers/gpu/drm/nouveau/include/nvif/if000c.h
index 2928ecd989ad..f8e29cfee7f8 100644
--- a/drivers/gpu/drm/nouveau/include/nvif/if000c.h
+++ b/drivers/gpu/drm/nouveau/include/nvif/if000c.h
@@ -3,7 +3,8 @@
 struct nvif_vmm_v0 {
 	__u8  version;
 	__u8  page_nr;
-	__u8  pad02[6];
+	__u8  managed;
+	__u8  pad03[5];
 	__u64 addr;
 	__u64 size;
 	__u8  data[];

commit 920d2b5ef2157e169d85cb778feca558c56b8370
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/mmu: define user interfaces to mmu vmm opertaions
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/include/nvif/if000c.h b/drivers/gpu/drm/nouveau/include/nvif/if000c.h
index 6363e22f9dcc..2928ecd989ad 100644
--- a/drivers/gpu/drm/nouveau/include/nvif/if000c.h
+++ b/drivers/gpu/drm/nouveau/include/nvif/if000c.h
@@ -1,3 +1,64 @@
 #ifndef __NVIF_IF000C_H__
 #define __NVIF_IF000C_H__
+struct nvif_vmm_v0 {
+	__u8  version;
+	__u8  page_nr;
+	__u8  pad02[6];
+	__u64 addr;
+	__u64 size;
+	__u8  data[];
+};
+
+#define NVIF_VMM_V0_PAGE                                                   0x00
+#define NVIF_VMM_V0_GET                                                    0x01
+#define NVIF_VMM_V0_PUT                                                    0x02
+#define NVIF_VMM_V0_MAP                                                    0x03
+#define NVIF_VMM_V0_UNMAP                                                  0x04
+
+struct nvif_vmm_page_v0 {
+	__u8  version;
+	__u8  index;
+	__u8  shift;
+	__u8  sparse;
+	__u8  vram;
+	__u8  host;
+	__u8  comp;
+	__u8  pad07[1];
+};
+
+struct nvif_vmm_get_v0 {
+	__u8  version;
+#define NVIF_VMM_GET_V0_ADDR                                               0x00
+#define NVIF_VMM_GET_V0_PTES                                               0x01
+#define NVIF_VMM_GET_V0_LAZY	                                           0x02
+	__u8  type;
+	__u8  sparse;
+	__u8  page;
+	__u8  align;
+	__u8  pad05[3];
+	__u64 size;
+	__u64 addr;
+};
+
+struct nvif_vmm_put_v0 {
+	__u8  version;
+	__u8  pad01[7];
+	__u64 addr;
+};
+
+struct nvif_vmm_map_v0 {
+	__u8  version;
+	__u8  pad01[7];
+	__u64 addr;
+	__u64 size;
+	__u64 memory;
+	__u64 offset;
+	__u8  data[];
+};
+
+struct nvif_vmm_unmap_v0 {
+	__u8  version;
+	__u8  pad01[7];
+	__u64 addr;
+};
 #endif

commit 806a7335653743a33f476a3705d55bada95b7dfe
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/mmu: implement base for new vm management
    
    This is the first chunk of the new VMM code that provides the structures
    needed to describe a GPU virtual address-space layout, as well as common
    interfaces to handle VMM creation, and connecting instances to a VMM.
    
    The constructor now allocates the PD itself, rather than having the user
    handle that manually.  This won't/can't be used until after all backends
    have been ported to these interfaces, so a little bit of memory will be
    wasted on Fermi and newer for a couple of commits in the series.
    
    Compatibility has been hacked into the old code to allow each GPU backend
    to be ported individually.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/include/nvif/if000c.h b/drivers/gpu/drm/nouveau/include/nvif/if000c.h
new file mode 100644
index 000000000000..6363e22f9dcc
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/include/nvif/if000c.h
@@ -0,0 +1,3 @@
+#ifndef __NVIF_IF000C_H__
+#define __NVIF_IF000C_H__
+#endif
