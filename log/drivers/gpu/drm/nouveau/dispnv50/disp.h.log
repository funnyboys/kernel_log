commit 4a2cb4181b077cf028c955d1f61d9244b2e93263
Author: Lyude Paul <lyude@redhat.com>
Date:   Mon May 11 18:41:24 2020 -0400

    drm/nouveau/kms/nv50-: Probe SOR and PIOR caps for DP interlacing support
    
    Right now, we make the mistake of allowing interlacing on all
    connectors. Nvidia hardware does not always support interlacing with DP
    though, so we need to make sure that we don't allow interlaced modes to
    be set in such situations as otherwise we'll end up accidentally hanging
    the display HW.
    
    This fixes some hangs with Turing, which would be caused by attempting
    to set an interlaced mode on hardware that doesn't support it. This
    patch likely fixes other hardware hanging in the same way as well.
    
    Note that we say we probe PIOR caps, but they don't actually have any
    interlacing caps. So, the get_caps() function for PIORs just sets
    interlacing support to true.
    
    Changes since v1:
    * Actually probe caps correctly this time, both on EVO and NVDisplay.
    Changes since v2:
    * Fix probing for < GF119
    * Use vfunc table, in prep for adding more caps in the future.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/dispnv50/disp.h b/drivers/gpu/drm/nouveau/dispnv50/disp.h
index 1743c3a76216..696e70a6b98b 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.h
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.h
@@ -9,6 +9,7 @@ struct nv50_msto;
 struct nv50_disp {
 	struct nvif_disp *disp;
 	struct nv50_core *core;
+	struct nvif_object caps;
 
 #define NV50_DISP_SYNC(c, o)                                ((c) * 0x040 + (o))
 #define NV50_DISP_CORE_NTFY                       NV50_DISP_SYNC(0      , 0x00)

commit c586f30bf74cb580c1748222b05a0bad57d7dcd4
Author: James Jones <jajones@nvidia.com>
Date:   Mon Feb 10 15:15:53 2020 -0800

    drm/nouveau/kms: Add format mod prop to base/ovly/nvdisp
    
    Advertise support for the full list of format
    modifiers supported by each class of NVIDIA
    desktop GPU display hardware.  Stash the array
    of modifiers in the nouveau_display struct for
    use when validating userspace framebuffer
    creation requests, which will be supportd in
    a subsequent change.
    
    Signed-off-by: James Jones <jajones@nvidia.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/dispnv50/disp.h b/drivers/gpu/drm/nouveau/dispnv50/disp.h
index d54fe00ac3a3..1743c3a76216 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.h
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.h
@@ -78,6 +78,10 @@ void nv50_dmac_destroy(struct nv50_dmac *);
 u32 *evo_wait(struct nv50_dmac *, int nr);
 void evo_kick(u32 *, struct nv50_dmac *);
 
+extern const u64 disp50xx_modifiers[];
+extern const u64 disp90xx_modifiers[];
+extern const u64 wndwc57e_modifiers[];
+
 #define evo_mthd(p, m, s) do {						\
 	const u32 _m = (m), _s = (s);					\
 	if (drm_debug_enabled(DRM_UT_KMS))				\

commit 5ff0cb1ce2536321045b5bc33ab8fb2467750f33
Author: Lyude Paul <lyude@redhat.com>
Date:   Fri Sep 13 18:03:52 2019 -0400

    drm/nouveau/kms/nv50-: Use less encoders by making mstos per-head
    
    Currently, for every single MST capable DRM connector we create a set of
    fake encoders, one for each possible head. Unfortunately this ends up
    being a huge waste of encoders. While this currently isn't causing us
    any problems, it's extremely close to doing so.
    
    The ThinkPad P71 is a good example of this. Originally when trying to
    figure out why nouveau was failing to load on this laptop, I discovered
    it was because nouveau was creating too many encoders. This ended up
    being because we were mistakenly creating MST encoders for the eDP port,
    however we are still extremely close to hitting the encoder limit on
    this machine as it exposes 1 eDP port and 5 DP ports, resulting in 31
    encoders.
    
    So while this fix didn't end up being necessary to fix the P71, we still
    need to implement this so that we avoid hitting the encoder limit for
    valid display configurations in the event that some machine with more
    connectors then this becomes available. Plus, we don't want to let good
    code go to waste :)
    
    So, use less encoders by only creating one MSTO per head. Then, attach
    each new MSTC to each MSTO which corresponds to a head that it's parent
    DP port is capable of using. This brings the number of encoders we
    register on the ThinkPad P71 from 31, down to just 15. Yay!
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/dispnv50/disp.h b/drivers/gpu/drm/nouveau/dispnv50/disp.h
index c0a79531b087..d54fe00ac3a3 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.h
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.h
@@ -4,6 +4,8 @@
 
 #include "nouveau_display.h"
 
+struct nv50_msto;
+
 struct nv50_disp {
 	struct nvif_disp *disp;
 	struct nv50_core *core;

commit 4f632fb23583b9ba598be879436bd555c7da5f3b
Author: Jani Nikula <jani.nikula@intel.com>
Date:   Mon Oct 28 12:38:16 2019 +0200

    drm/nouveau: use drm_debug_enabled() to check for debug categories
    
    Allow better abstraction of the drm_debug global variable in the
    future. No functional changes.
    
    v2: move unlikely() to drm_debug_enabled()
    
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: nouveau@lists.freedesktop.org
    Acked-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Sean Paul <sean@poorly.run>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/34a1e7db6eab6467c6607d9a57581d1de75d87da.1572258936.git.jani.nikula@intel.com

diff --git a/drivers/gpu/drm/nouveau/dispnv50/disp.h b/drivers/gpu/drm/nouveau/dispnv50/disp.h
index 7c41b0599d1a..c0a79531b087 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.h
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.h
@@ -78,14 +78,14 @@ void evo_kick(u32 *, struct nv50_dmac *);
 
 #define evo_mthd(p, m, s) do {						\
 	const u32 _m = (m), _s = (s);					\
-	if (drm_debug & DRM_UT_KMS)					\
+	if (drm_debug_enabled(DRM_UT_KMS))				\
 		pr_err("%04x %d %s\n", _m, _s, __func__);		\
 	*((p)++) = ((_s << 18) | _m);					\
 } while(0)
 
 #define evo_data(p, d) do {						\
 	const u32 _d = (d);						\
-	if (drm_debug & DRM_UT_KMS)					\
+	if (drm_debug_enabled(DRM_UT_KMS))				\
 		pr_err("\t%08x\n", _d);					\
 	*((p)++) = _d;							\
 } while(0)

commit d2434e4d942c32cadcbdbcd32c58f35098f3b604
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 3 12:23:55 2019 +1000

    drm/nouveau/kms/gv100-: fix spurious window immediate interlocks
    
    Cursor position updates were accidentally causing us to attempt to interlock
    window with window immediate, and without a matching window immediate update,
    NVDisplay could hang forever in some circumstances.
    
    Fixes suspend/resume on (at least) Quadro RTX4000 (TU104).
    
    Reported-by: Lyude Paul <lyude@redhat.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/dispnv50/disp.h b/drivers/gpu/drm/nouveau/dispnv50/disp.h
index 2216c58620c2..7c41b0599d1a 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.h
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.h
@@ -41,6 +41,7 @@ struct nv50_disp_interlock {
 		NV50_DISP_INTERLOCK__SIZE
 	} type;
 	u32 data;
+	u32 wimm;
 };
 
 void corec37d_ntfy_init(struct nouveau_bo *, u32);

commit cb55cd0c66a16fd965a44e2634755b060dc64bd7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Dec 11 14:50:02 2018 +1000

    drm/nouveau/kms/nv50-: allow more flexibility with lut formats
    
    Will be required for Turing.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/dispnv50/disp.h b/drivers/gpu/drm/nouveau/dispnv50/disp.h
index e48c5eb35b49..2216c58620c2 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.h
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.h
@@ -45,6 +45,8 @@ struct nv50_disp_interlock {
 
 void corec37d_ntfy_init(struct nouveau_bo *, u32);
 
+void head907d_olut_load(struct drm_color_lut *, int size, void __iomem *);
+
 struct nv50_chan {
 	struct nvif_object user;
 	struct nvif_device *device;

commit facaed62b4cba3a6334fc1798fa8f51ea6a1962d
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:48 2018 +1000

    drm/nouveau/kms/gv100: initial support
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/dispnv50/disp.h b/drivers/gpu/drm/nouveau/dispnv50/disp.h
index a89b83f95187..e48c5eb35b49 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.h
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.h
@@ -36,11 +36,15 @@ struct nv50_disp_interlock {
 		NV50_DISP_INTERLOCK_CURS,
 		NV50_DISP_INTERLOCK_BASE,
 		NV50_DISP_INTERLOCK_OVLY,
+		NV50_DISP_INTERLOCK_WNDW,
+		NV50_DISP_INTERLOCK_WIMM,
 		NV50_DISP_INTERLOCK__SIZE
 	} type;
 	u32 data;
 };
 
+void corec37d_ntfy_init(struct nouveau_bo *, u32);
+
 struct nv50_chan {
 	struct nvif_object user;
 	struct nvif_device *device;

commit 2ce7f38629891eeaf3e5d406add102a3fa6f6632
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:47 2018 +1000

    drm/nouveau/kms/nv50-: initial overlay support
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/dispnv50/disp.h b/drivers/gpu/drm/nouveau/dispnv50/disp.h
index f3a963b0ab77..a89b83f95187 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.h
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.h
@@ -16,6 +16,9 @@ struct nv50_disp {
 #define NV50_DISP_BASE_SEM0(c)                    NV50_DISP_WNDW_SEM0(0 + (c))
 #define NV50_DISP_BASE_SEM1(c)                    NV50_DISP_WNDW_SEM1(0 + (c))
 #define NV50_DISP_BASE_NTFY(c)                    NV50_DISP_WNDW_NTFY(0 + (c))
+#define NV50_DISP_OVLY_SEM0(c)                    NV50_DISP_WNDW_SEM0(4 + (c))
+#define NV50_DISP_OVLY_SEM1(c)                    NV50_DISP_WNDW_SEM1(4 + (c))
+#define NV50_DISP_OVLY_NTFY(c)                    NV50_DISP_WNDW_NTFY(4 + (c))
 	struct nouveau_bo *sync;
 
 	struct mutex mutex;

commit 53e0a3e70de69dc9f498d26c6b5495b2771ee374
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:47 2018 +1000

    drm/nouveau/kms/nv50-: simplify tracking of channel interlocks
    
    Instead of windows returning their core channel interlock mask if they
    know core has been modified, it's recorded unconditionally and used if
    required when update methods are emitted.
    
    This will be required to support Volta.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/dispnv50/disp.h b/drivers/gpu/drm/nouveau/dispnv50/disp.h
index 7cbd66849743..f3a963b0ab77 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/disp.h
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.h
@@ -27,6 +27,17 @@ nv50_disp(struct drm_device *dev)
 	return nouveau_display(dev)->priv;
 }
 
+struct nv50_disp_interlock {
+	enum nv50_disp_interlock_type {
+		NV50_DISP_INTERLOCK_CORE = 0,
+		NV50_DISP_INTERLOCK_CURS,
+		NV50_DISP_INTERLOCK_BASE,
+		NV50_DISP_INTERLOCK_OVLY,
+		NV50_DISP_INTERLOCK__SIZE
+	} type;
+	u32 data;
+};
+
 struct nv50_chan {
 	struct nvif_object user;
 	struct nvif_device *device;

commit 1590700d94ac53772491ed3103a4e8b8de01640a
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue May 8 20:39:47 2018 +1000

    drm/nouveau/kms/nv50-: split each resource type into their own source files
    
    There should be no code changes here, just shuffling stuff around.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/dispnv50/disp.h b/drivers/gpu/drm/nouveau/dispnv50/disp.h
new file mode 100644
index 000000000000..7cbd66849743
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv50/disp.h
@@ -0,0 +1,71 @@
+#ifndef __NV50_KMS_H__
+#define __NV50_KMS_H__
+#include <nvif/mem.h>
+
+#include "nouveau_display.h"
+
+struct nv50_disp {
+	struct nvif_disp *disp;
+	struct nv50_core *core;
+
+#define NV50_DISP_SYNC(c, o)                                ((c) * 0x040 + (o))
+#define NV50_DISP_CORE_NTFY                       NV50_DISP_SYNC(0      , 0x00)
+#define NV50_DISP_WNDW_SEM0(c)                    NV50_DISP_SYNC(1 + (c), 0x00)
+#define NV50_DISP_WNDW_SEM1(c)                    NV50_DISP_SYNC(1 + (c), 0x10)
+#define NV50_DISP_WNDW_NTFY(c)                    NV50_DISP_SYNC(1 + (c), 0x20)
+#define NV50_DISP_BASE_SEM0(c)                    NV50_DISP_WNDW_SEM0(0 + (c))
+#define NV50_DISP_BASE_SEM1(c)                    NV50_DISP_WNDW_SEM1(0 + (c))
+#define NV50_DISP_BASE_NTFY(c)                    NV50_DISP_WNDW_NTFY(0 + (c))
+	struct nouveau_bo *sync;
+
+	struct mutex mutex;
+};
+
+static inline struct nv50_disp *
+nv50_disp(struct drm_device *dev)
+{
+	return nouveau_display(dev)->priv;
+}
+
+struct nv50_chan {
+	struct nvif_object user;
+	struct nvif_device *device;
+};
+
+struct nv50_dmac {
+	struct nv50_chan base;
+
+	struct nvif_mem push;
+	u32 *ptr;
+
+	struct nvif_object sync;
+	struct nvif_object vram;
+
+	/* Protects against concurrent pushbuf access to this channel, lock is
+	 * grabbed by evo_wait (if the pushbuf reservation is successful) and
+	 * dropped again by evo_kick. */
+	struct mutex lock;
+};
+
+int nv50_dmac_create(struct nvif_device *device, struct nvif_object *disp,
+		     const s32 *oclass, u8 head, void *data, u32 size,
+		     u64 syncbuf, struct nv50_dmac *dmac);
+void nv50_dmac_destroy(struct nv50_dmac *);
+
+u32 *evo_wait(struct nv50_dmac *, int nr);
+void evo_kick(u32 *, struct nv50_dmac *);
+
+#define evo_mthd(p, m, s) do {						\
+	const u32 _m = (m), _s = (s);					\
+	if (drm_debug & DRM_UT_KMS)					\
+		pr_err("%04x %d %s\n", _m, _s, __func__);		\
+	*((p)++) = ((_s << 18) | _m);					\
+} while(0)
+
+#define evo_data(p, d) do {						\
+	const u32 _d = (d);						\
+	if (drm_debug & DRM_UT_KMS)					\
+		pr_err("\t%08x\n", _d);					\
+	*((p)++) = _d;							\
+} while(0)
+#endif
