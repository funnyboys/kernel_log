commit 15f77c4ade3364106a3a397f0a8d6fce9d6a6326
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Jan 11 16:08:20 2019 +1000

    drm/nouveau: register backlight on pascal and newer
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 5f5be6368aed..c7a94c94dbf3 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -253,6 +253,9 @@ nouveau_backlight_init(struct drm_connector *connector)
 	case NV_DEVICE_INFO_V0_FERMI:
 	case NV_DEVICE_INFO_V0_KEPLER:
 	case NV_DEVICE_INFO_V0_MAXWELL:
+	case NV_DEVICE_INFO_V0_PASCAL:
+	case NV_DEVICE_INFO_V0_VOLTA:
+	case NV_DEVICE_INFO_V0_TURING:
 		ret = nv50_backlight_init(nv_encoder, &props, &ops);
 		break;
 	default:

commit e15e4c13e5b77e8b8e8c5e6d23831b1180249788
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Sep 6 17:43:26 2018 -0400

    drm/nouveau: Refactor nvXX_backlight_init()
    
    There's literally no difference between any of the backlight init
    functions besides the backlight properties they set and the backlight
    callbacks that they set, so move all of the duplicated backlight init
    code out of there and into nouveau_backlight_init().
    
    This gets rid of a lot of copy pasta!
    
    Changes since v1:
    - Some of the pre-refactor callbacks were storing nv_encoder in callback
      data for the backlight devices that they registered, as opposed to
      nouveau_drm. This got missed and caused some bugs that didn't
      originally appear on my setup (NULL kernel derefs) for some reason.
      So, fix this by finding the nouveau_encoder in
      nouveau_backlight_init(), and using that as the callback data for all
      gens instead even if they don't care about the encoder.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Cc: Jeffery Miller <jmiller@neverware.com>
    Cc: Karol Herbst <kherbst@redhat.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 01d08acac2f0..5f5be6368aed 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -65,7 +65,8 @@ nouveau_get_backlight_name(char backlight_name[BL_NAME_SIZE],
 static int
 nv40_get_intensity(struct backlight_device *bd)
 {
-	struct nouveau_drm *drm = bl_get_data(bd);
+	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
+	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
 	struct nvif_object *device = &drm->client.device.object;
 	int val = (nvif_rd32(device, NV40_PMC_BACKLIGHT) &
 		   NV40_PMC_BACKLIGHT_MASK) >> 16;
@@ -76,7 +77,8 @@ nv40_get_intensity(struct backlight_device *bd)
 static int
 nv40_set_intensity(struct backlight_device *bd)
 {
-	struct nouveau_drm *drm = bl_get_data(bd);
+	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
+	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
 	struct nvif_object *device = &drm->client.device.object;
 	int val = bd->props.brightness;
 	int reg = nvif_rd32(device, NV40_PMC_BACKLIGHT);
@@ -94,48 +96,20 @@ static const struct backlight_ops nv40_bl_ops = {
 };
 
 static int
-nv40_backlight_init(struct drm_connector *connector)
+nv40_backlight_init(struct nouveau_encoder *encoder,
+		    struct backlight_properties *props,
+		    const struct backlight_ops **ops)
 {
-	struct nouveau_drm *drm = nouveau_drm(connector->dev);
-	struct nouveau_backlight *bl;
+	struct nouveau_drm *drm = nouveau_drm(encoder->base.base.dev);
 	struct nvif_object *device = &drm->client.device.object;
-	struct backlight_properties props;
-	char backlight_name[BL_NAME_SIZE];
-	int ret = 0;
 
 	if (!(nvif_rd32(device, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK))
-		return 0;
-
-	bl = kzalloc(sizeof(*bl), GFP_KERNEL);
-	if (!bl)
-		return -ENOMEM;
-
-	memset(&props, 0, sizeof(struct backlight_properties));
-	props.type = BACKLIGHT_RAW;
-	props.max_brightness = 31;
-	if (!nouveau_get_backlight_name(backlight_name, bl)) {
-		NV_ERROR(drm, "Failed to retrieve a unique name for the backlight interface\n");
-		goto fail_alloc;
-	}
-
-	bl->dev = backlight_device_register(backlight_name, connector->kdev,
-					    drm, &nv40_bl_ops, &props);
-	if (IS_ERR(bl->dev)) {
-		if (bl->id >= 0)
-			ida_simple_remove(&bl_ida, bl->id);
-
-		ret = PTR_ERR(bl->dev);
-		goto fail_alloc;
-	}
-
-	nouveau_connector(connector)->backlight = bl;
-	bl->dev->props.brightness = nv40_get_intensity(bl->dev);
-	backlight_update_status(bl->dev);
+		return -ENODEV;
 
+	props->type = BACKLIGHT_RAW;
+	props->max_brightness = 31;
+	*ops = &nv40_bl_ops;
 	return 0;
-fail_alloc:
-	kfree(bl);
-	return ret;
 }
 
 static int
@@ -221,92 +195,102 @@ static const struct backlight_ops nva3_bl_ops = {
 };
 
 static int
-nv50_backlight_init(struct drm_connector *connector)
+nv50_backlight_init(struct nouveau_encoder *nv_encoder,
+		    struct backlight_properties *props,
+		    const struct backlight_ops **ops)
 {
-	struct nouveau_drm *drm = nouveau_drm(connector->dev);
+	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
 	struct nvif_object *device = &drm->client.device.object;
-	struct nouveau_encoder *nv_encoder;
-	struct nouveau_backlight *bl;
-	struct backlight_properties props;
-	const struct backlight_ops *ops;
-	char backlight_name[BL_NAME_SIZE];
-	int ret = 0;
-
-	nv_encoder = find_encoder(connector, DCB_OUTPUT_LVDS);
-	if (!nv_encoder) {
-		nv_encoder = find_encoder(connector, DCB_OUTPUT_DP);
-		if (!nv_encoder)
-			return -ENODEV;
-	}
 
 	if (!nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(ffs(nv_encoder->dcb->or) - 1)))
-		return 0;
-
-	bl = kzalloc(sizeof(*bl), GFP_KERNEL);
-	if (!bl)
-		return -ENOMEM;
+		return -ENODEV;
 
 	if (drm->client.device.info.chipset <= 0xa0 ||
 	    drm->client.device.info.chipset == 0xaa ||
 	    drm->client.device.info.chipset == 0xac)
-		ops = &nv50_bl_ops;
+		*ops = &nv50_bl_ops;
 	else
-		ops = &nva3_bl_ops;
+		*ops = &nva3_bl_ops;
 
-	memset(&props, 0, sizeof(struct backlight_properties));
-	props.type = BACKLIGHT_RAW;
-	props.max_brightness = 100;
-	if (!nouveau_get_backlight_name(backlight_name, bl)) {
-		NV_ERROR(drm, "Failed to retrieve a unique name for the backlight interface\n");
-		goto fail_alloc;
-	}
+	props->type = BACKLIGHT_RAW;
+	props->max_brightness = 100;
 
-	bl->dev = backlight_device_register(backlight_name, connector->kdev,
-					    nv_encoder, ops, &props);
-	if (IS_ERR(bl->dev)) {
-		if (bl->id >= 0)
-			ida_simple_remove(&bl_ida, bl->id);
-
-		ret = PTR_ERR(bl->dev);
-		goto fail_alloc;
-	}
-
-	nouveau_connector(connector)->backlight = bl;
-	bl->dev->props.brightness = bl->dev->ops->get_brightness(bl->dev);
-	backlight_update_status(bl->dev);
 	return 0;
-
-fail_alloc:
-	kfree(bl);
-	return ret;
 }
 
 int
 nouveau_backlight_init(struct drm_connector *connector)
 {
 	struct nouveau_drm *drm = nouveau_drm(connector->dev);
+	struct nouveau_backlight *bl;
+	struct nouveau_encoder *nv_encoder = NULL;
 	struct nvif_device *device = &drm->client.device;
+	char backlight_name[BL_NAME_SIZE];
+	struct backlight_properties props = {0};
+	const struct backlight_ops *ops;
+	int ret;
 
 	if (apple_gmux_present()) {
 		NV_INFO_ONCE(drm, "Apple GMUX detected: not registering Nouveau backlight interface\n");
 		return 0;
 	}
 
-	if (connector->connector_type != DRM_MODE_CONNECTOR_LVDS &&
-	    connector->connector_type != DRM_MODE_CONNECTOR_eDP)
+	if (connector->connector_type == DRM_MODE_CONNECTOR_LVDS)
+		nv_encoder = find_encoder(connector, DCB_OUTPUT_LVDS);
+	else if (connector->connector_type == DRM_MODE_CONNECTOR_eDP)
+		nv_encoder = find_encoder(connector, DCB_OUTPUT_DP);
+	else
+		return 0;
+
+	if (!nv_encoder)
 		return 0;
 
 	switch (device->info.family) {
 	case NV_DEVICE_INFO_V0_CURIE:
-		return nv40_backlight_init(connector);
+		ret = nv40_backlight_init(nv_encoder, &props, &ops);
+		break;
 	case NV_DEVICE_INFO_V0_TESLA:
 	case NV_DEVICE_INFO_V0_FERMI:
 	case NV_DEVICE_INFO_V0_KEPLER:
 	case NV_DEVICE_INFO_V0_MAXWELL:
-		return nv50_backlight_init(connector);
+		ret = nv50_backlight_init(nv_encoder, &props, &ops);
+		break;
 	default:
 		return 0;
 	}
+
+	if (ret == -ENODEV)
+		return 0;
+	else if (ret)
+		return ret;
+
+	bl = kzalloc(sizeof(*bl), GFP_KERNEL);
+	if (!bl)
+		return -ENOMEM;
+
+	if (!nouveau_get_backlight_name(backlight_name, bl)) {
+		NV_ERROR(drm, "Failed to retrieve a unique name for the backlight interface\n");
+		goto fail_alloc;
+	}
+
+	bl->dev = backlight_device_register(backlight_name, connector->kdev,
+					    nv_encoder, ops, &props);
+	if (IS_ERR(bl->dev)) {
+		if (bl->id >= 0)
+			ida_simple_remove(&bl_ida, bl->id);
+		ret = PTR_ERR(bl->dev);
+		goto fail_alloc;
+	}
+
+	nouveau_connector(connector)->backlight = bl;
+	bl->dev->props.brightness = bl->dev->ops->get_brightness(bl->dev);
+	backlight_update_status(bl->dev);
+
+	return 0;
+
+fail_alloc:
+	kfree(bl);
+	return ret;
 }
 
 void

commit f76e174bd30a8a43f5c50a33f2988f84ee5d57de
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Sep 6 17:43:25 2018 -0400

    drm/nouveau: Cleanup indenting in nouveau_backlight.c
    
    Still no functional changes.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Karol Herbst <kherbst@redhat.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index f4400a6408b4..01d08acac2f0 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -68,7 +68,7 @@ nv40_get_intensity(struct backlight_device *bd)
 	struct nouveau_drm *drm = bl_get_data(bd);
 	struct nvif_object *device = &drm->client.device.object;
 	int val = (nvif_rd32(device, NV40_PMC_BACKLIGHT) &
-				   NV40_PMC_BACKLIGHT_MASK) >> 16;
+		   NV40_PMC_BACKLIGHT_MASK) >> 16;
 
 	return val;
 }
@@ -82,7 +82,7 @@ nv40_set_intensity(struct backlight_device *bd)
 	int reg = nvif_rd32(device, NV40_PMC_BACKLIGHT);
 
 	nvif_wr32(device, NV40_PMC_BACKLIGHT,
-		 (val << 16) | (reg & ~NV40_PMC_BACKLIGHT_MASK));
+		  (val << 16) | (reg & ~NV40_PMC_BACKLIGHT_MASK));
 
 	return 0;
 }
@@ -164,7 +164,7 @@ nv50_set_intensity(struct backlight_device *bd)
 	u32 val = (bd->props.brightness * div) / 100;
 
 	nvif_wr32(device, NV50_PDISP_SOR_PWM_CTL(or),
-			NV50_PDISP_SOR_PWM_CTL_NEW | val);
+		  NV50_PDISP_SOR_PWM_CTL_NEW | val);
 	return 0;
 }
 
@@ -204,9 +204,10 @@ nva3_set_intensity(struct backlight_device *bd)
 	div = nvif_rd32(device, NV50_PDISP_SOR_PWM_DIV(or));
 	val = (bd->props.brightness * div) / 100;
 	if (div) {
-		nvif_wr32(device, NV50_PDISP_SOR_PWM_CTL(or), val |
-				NV50_PDISP_SOR_PWM_CTL_NEW |
-				NVA3_PDISP_SOR_PWM_CTL_UNK);
+		nvif_wr32(device, NV50_PDISP_SOR_PWM_CTL(or),
+			  val |
+			  NV50_PDISP_SOR_PWM_CTL_NEW |
+			  NVA3_PDISP_SOR_PWM_CTL_UNK);
 		return 0;
 	}
 

commit a4e05f415e2fb22b1804c86bbf84cc1d5d29b9f1
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Sep 6 17:43:24 2018 -0400

    drm/nouveau/drm/nouveau: s/nouveau_backlight_exit/nouveau_backlight_fini/
    
    More consistent with the rest of the codebase, no functional changes
    here.
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Karol Herbst <kherbst@redhat.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 5d0694680f59..f4400a6408b4 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -309,7 +309,7 @@ nouveau_backlight_init(struct drm_connector *connector)
 }
 
 void
-nouveau_backlight_exit(struct drm_connector *connector)
+nouveau_backlight_fini(struct drm_connector *connector)
 {
 	struct nouveau_connector *nv_conn = nouveau_connector(connector);
 	struct nouveau_backlight *bl = nv_conn->backlight;

commit 6d757753cef8d523342fe544299068d30b5be490
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Sep 6 17:43:23 2018 -0400

    drm/nouveau: Move backlight device into nouveau_connector
    
    Currently module unloading is broken in nouveau due to a rather annoying
    race condition resulting from nouveau_backlight.c having gone a bit
    stale over time:
    
    [ 1960.791143] ==================================================================
    [ 1960.791394] BUG: KASAN: use-after-free in nouveau_backlight_exit+0x112/0x150 [nouveau]
    [ 1960.791460] Read of size 4 at addr ffff88075accf350 by task zsh/11185
    [ 1960.791521]
    [ 1960.791545] CPU: 7 PID: 11185 Comm: zsh Kdump: loaded Tainted: G           O      4.18.0Lyude-Test+ #4
    [ 1960.791580] Hardware name: LENOVO 20EQS64N0B/20EQS64N0B, BIOS N1EET79W (1.52 ) 07/13/2018
    [ 1960.791628] Call Trace:
    [ 1960.791680]  dump_stack+0xa4/0xfd
    [ 1960.791721]  print_address_description+0x71/0x239
    [ 1960.791833]  ? nouveau_backlight_exit+0x112/0x150 [nouveau]
    [ 1960.791877]  kasan_report.cold.6+0x242/0x2fe
    [ 1960.791919]  __asan_report_load4_noabort+0x19/0x20
    [ 1960.792012]  nouveau_backlight_exit+0x112/0x150 [nouveau]
    [ 1960.792081]  nouveau_display_destroy+0x76/0x150 [nouveau]
    [ 1960.792150]  nouveau_drm_device_fini+0xb7/0x190 [nouveau]
    [ 1960.792265]  nouveau_drm_device_remove+0x14b/0x1d0 [nouveau]
    [ 1960.792347]  ? nouveau_cli_work_queue+0x2e0/0x2e0 [nouveau]
    [ 1960.792378]  ? trace_hardirqs_on_caller+0x38b/0x570
    [ 1960.792406]  ? trace_hardirqs_on+0xd/0x10
    [ 1960.792472]  nouveau_drm_remove+0x37/0x50 [nouveau]
    [ 1960.792502]  pci_device_remove+0x112/0x2d0
    [ 1960.792530]  ? pcibios_free_irq+0x10/0x10
    [ 1960.792558]  ? kasan_check_write+0x14/0x20
    [ 1960.792587]  device_release_driver_internal+0x35c/0x650
    [ 1960.792617]  device_release_driver+0x12/0x20
    [ 1960.792643]  pci_stop_bus_device+0x172/0x1e0
    [ 1960.792671]  pci_stop_and_remove_bus_device_locked+0x1a/0x30
    [ 1960.792715]  remove_store+0xcb/0xe0
    [ 1960.792753]  ? sriov_numvfs_store+0x2e0/0x2e0
    [ 1960.792779]  ? __lock_is_held+0xb5/0x140
    [ 1960.792808]  ? component_add+0x530/0x530
    [ 1960.792834]  dev_attr_store+0x3f/0x70
    [ 1960.792859]  ? sysfs_file_ops+0x11d/0x170
    [ 1960.792885]  sysfs_kf_write+0x104/0x150
    [ 1960.792915]  ? sysfs_file_ops+0x170/0x170
    [ 1960.792940]  kernfs_fop_write+0x24f/0x400
    [ 1960.792978]  ? __lock_acquire+0x6ea/0x47f0
    [ 1960.793021]  __vfs_write+0xeb/0x760
    [ 1960.793048]  ? kernel_read+0x130/0x130
    [ 1960.793076]  ? __lock_is_held+0xb5/0x140
    [ 1960.793107]  ? rcu_read_lock_sched_held+0xdd/0x110
    [ 1960.793135]  ? rcu_sync_lockdep_assert+0x78/0xb0
    [ 1960.793162]  ? __sb_start_write+0x183/0x220
    [ 1960.793189]  vfs_write+0x14d/0x4a0
    [ 1960.793229]  ksys_write+0xd2/0x1b0
    [ 1960.793255]  ? __ia32_sys_read+0xb0/0xb0
    [ 1960.793298]  ? fput+0x1d/0x120
    [ 1960.793324]  ? filp_close+0xf3/0x130
    [ 1960.793349]  ? entry_SYSCALL_64_after_hwframe+0x59/0xbe
    [ 1960.793380]  __x64_sys_write+0x73/0xb0
    [ 1960.793407]  do_syscall_64+0xaa/0x400
    [ 1960.793433]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [ 1960.793460] RIP: 0033:0x7f59df433164
    [ 1960.793486] Code: 89 02 48 c7 c0 ff ff ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 8d 05 81 38 2d 00 8b 00 85 c0 75 13 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 c3 0f 1f 00 41 54 49 89 d4 55 48 89 f5 53
    [ 1960.793541] RSP: 002b:00007ffd70ee2fb8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    [ 1960.793576] RAX: ffffffffffffffda RBX: 0000000000000002 RCX: 00007f59df433164
    [ 1960.793620] RDX: 0000000000000002 RSI: 00005578088640c0 RDI: 0000000000000001
    [ 1960.793665] RBP: 00005578088640c0 R08: 00007f59df7038c0 R09: 00007f59e0995b80
    [ 1960.793696] R10: 000000000000000a R11: 0000000000000246 R12: 00007f59df702760
    [ 1960.793730] R13: 0000000000000002 R14: 00007f59df6fd760 R15: 0000000000000002
    [ 1960.793768]
    [ 1960.793790] Allocated by task 11167:
    [ 1960.793816]  save_stack+0x43/0xd0
    [ 1960.793841]  kasan_kmalloc+0xc4/0xe0
    [ 1960.793880]  kasan_slab_alloc+0x11/0x20
    [ 1960.793905]  kmem_cache_alloc+0xd7/0x270
    [ 1960.793944]  getname_flags+0xbd/0x520
    [ 1960.793969]  user_path_at_empty+0x23/0x50
    [ 1960.793994]  do_faccessat+0x1fc/0x5d0
    [ 1960.794018]  __x64_sys_access+0x59/0x80
    [ 1960.794043]  do_syscall_64+0xaa/0x400
    [ 1960.794067]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [ 1960.794093]
    [ 1960.794127] Freed by task 11167:
    [ 1960.794152]  save_stack+0x43/0xd0
    [ 1960.794190]  __kasan_slab_free+0x139/0x190
    [ 1960.794215]  kasan_slab_free+0xe/0x10
    [ 1960.794239]  kmem_cache_free+0xcb/0x2c0
    [ 1960.794264]  putname+0xad/0xe0
    [ 1960.794287]  filename_lookup.part.59+0x1f1/0x360
    [ 1960.794313]  user_path_at_empty+0x3e/0x50
    [ 1960.794338]  do_faccessat+0x1fc/0x5d0
    [ 1960.794362]  __x64_sys_access+0x59/0x80
    [ 1960.794393]  do_syscall_64+0xaa/0x400
    [ 1960.794421]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [ 1960.794461]
    [ 1960.794483] The buggy address belongs to the object at ffff88075acceac0
    [ 1960.794483]  which belongs to the cache names_cache of size 4096
    [ 1960.794540] The buggy address is located 2192 bytes inside of
    [ 1960.794540]  4096-byte region [ffff88075acceac0, ffff88075accfac0)
    [ 1960.794581] The buggy address belongs to the page:
    [ 1960.794609] page:ffffea001d6b3200 count:1 mapcount:0 mapping:ffff880778e4b1c0 index:0x0 compound_mapcount: 0
    [ 1960.794651] flags: 0x8000000000008100(slab|head)
    [ 1960.794679] raw: 8000000000008100 ffffea001d39e808 ffffea001d39ea08 ffff880778e4b1c0
    [ 1960.794739] raw: 0000000000000000 0000000000070007 00000001ffffffff 0000000000000000
    [ 1960.794785] page dumped because: kasan: bad access detected
    [ 1960.794813]
    [ 1960.794834] Memory state around the buggy address:
    [ 1960.794861]  ffff88075accf200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [ 1960.794894]  ffff88075accf280: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [ 1960.794925] >ffff88075accf300: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [ 1960.794956]                                                  ^
    [ 1960.794985]  ffff88075accf380: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [ 1960.795017]  ffff88075accf400: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [ 1960.795061] ==================================================================
    [ 1960.795106] Disabling lock debugging due to kernel taint
    [ 1960.795131] ------------[ cut here ]------------
    [ 1960.795148] ida_remove called for id=1802201963 which is not allocated.
    [ 1960.795193] WARNING: CPU: 7 PID: 11185 at lib/idr.c:521 ida_remove+0x184/0x210
    [ 1960.795213] Modules linked in: nouveau(O) mxm_wmi ttm i2c_algo_bit drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops drm joydev vfat fat intel_rapl x86_pkg_temp_thermal coretemp crc32_pclmul iTCO_wdt psmouse wmi_bmof mei_me tpm_tis mei tpm_tis_core tpm i2c_i801 thinkpad_acpi pcc_cpufreq crc32c_intel serio_raw xhci_pci xhci_hcd wmi video i2c_dev i2c_core
    [ 1960.795305] CPU: 7 PID: 11185 Comm: zsh Kdump: loaded Tainted: G    B      O      4.18.0Lyude-Test+ #4
    [ 1960.795330] Hardware name: LENOVO 20EQS64N0B/20EQS64N0B, BIOS N1EET79W (1.52 ) 07/13/2018
    [ 1960.795352] RIP: 0010:ida_remove+0x184/0x210
    [ 1960.795370] Code: 4c 89 f7 e8 ae c8 00 00 eb 22 41 83 c4 02 4c 89 e8 41 83 fc 3f 0f 86 64 ff ff ff 44 89 fe 48 c7 c7 20 94 1e 83 e8 54 ed 81 fe <0f> 0b 48 b8 00 00 00 00 00 fc ff df 48 01 c3 c7 03 00 00 00 00 c7
    [ 1960.795402] RSP: 0018:ffff88074d4df7b8 EFLAGS: 00010082
    [ 1960.795421] RAX: 0000000000000000 RBX: 1ffff100e9a9befa RCX: ffffffff81479975
    [ 1960.795440] RDX: 0000000000000000 RSI: 0000000000000008 RDI: ffff88077c1de690
    [ 1960.795460] RBP: ffff88074d4df878 R08: ffffed00ef83bcd3 R09: ffffed00ef83bcd2
    [ 1960.795479] R10: ffffed00ef83bcd2 R11: ffff88077c1de697 R12: 000000000000036b
    [ 1960.795498] R13: 0000000000000202 R14: ffffffffa0aa7fa0 R15: 000000006b6b6b6b
    [ 1960.795518] FS:  00007f59e0995b80(0000) GS:ffff88077c1c0000(0000) knlGS:0000000000000000
    [ 1960.795553] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [ 1960.795571] CR2: 00007f59e09a2010 CR3: 00000004a1a70005 CR4: 00000000003606e0
    [ 1960.795596] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [ 1960.795629] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [ 1960.795649] Call Trace:
    [ 1960.795667]  ? ida_destroy+0x1d0/0x1d0
    [ 1960.795686]  ? kasan_check_write+0x14/0x20
    [ 1960.795704]  ? do_raw_spin_lock+0xc2/0x1c0
    [ 1960.795724]  ida_simple_remove+0x26/0x40
    [ 1960.795794]  nouveau_backlight_exit+0x9d/0x150 [nouveau]
    [ 1960.795867]  nouveau_display_destroy+0x76/0x150 [nouveau]
    [ 1960.795930]  nouveau_drm_device_fini+0xb7/0x190 [nouveau]
    [ 1960.795989]  nouveau_drm_device_remove+0x14b/0x1d0 [nouveau]
    [ 1960.796047]  ? nouveau_cli_work_queue+0x2e0/0x2e0 [nouveau]
    [ 1960.796067]  ? trace_hardirqs_on_caller+0x38b/0x570
    [ 1960.796089]  ? trace_hardirqs_on+0xd/0x10
    [ 1960.796146]  nouveau_drm_remove+0x37/0x50 [nouveau]
    [ 1960.796167]  pci_device_remove+0x112/0x2d0
    [ 1960.796186]  ? pcibios_free_irq+0x10/0x10
    [ 1960.796218]  ? kasan_check_write+0x14/0x20
    [ 1960.796237]  device_release_driver_internal+0x35c/0x650
    [ 1960.796257]  device_release_driver+0x12/0x20
    [ 1960.796289]  pci_stop_bus_device+0x172/0x1e0
    [ 1960.796308]  pci_stop_and_remove_bus_device_locked+0x1a/0x30
    [ 1960.796328]  remove_store+0xcb/0xe0
    [ 1960.796345]  ? sriov_numvfs_store+0x2e0/0x2e0
    [ 1960.796364]  ? __lock_is_held+0xb5/0x140
    [ 1960.796383]  ? component_add+0x530/0x530
    [ 1960.796401]  dev_attr_store+0x3f/0x70
    [ 1960.796419]  ? sysfs_file_ops+0x11d/0x170
    [ 1960.796436]  sysfs_kf_write+0x104/0x150
    [ 1960.796454]  ? sysfs_file_ops+0x170/0x170
    [ 1960.796471]  kernfs_fop_write+0x24f/0x400
    [ 1960.796488]  ? __lock_acquire+0x6ea/0x47f0
    [ 1960.796520]  __vfs_write+0xeb/0x760
    [ 1960.796538]  ? kernel_read+0x130/0x130
    [ 1960.796556]  ? __lock_is_held+0xb5/0x140
    [ 1960.796590]  ? rcu_read_lock_sched_held+0xdd/0x110
    [ 1960.796608]  ? rcu_sync_lockdep_assert+0x78/0xb0
    [ 1960.796626]  ? __sb_start_write+0x183/0x220
    [ 1960.796648]  vfs_write+0x14d/0x4a0
    [ 1960.796666]  ksys_write+0xd2/0x1b0
    [ 1960.796684]  ? __ia32_sys_read+0xb0/0xb0
    [ 1960.796701]  ? fput+0x1d/0x120
    [ 1960.796732]  ? filp_close+0xf3/0x130
    [ 1960.796749]  ? entry_SYSCALL_64_after_hwframe+0x59/0xbe
    [ 1960.796768]  __x64_sys_write+0x73/0xb0
    [ 1960.796800]  do_syscall_64+0xaa/0x400
    [ 1960.796818]  entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [ 1960.796836] RIP: 0033:0x7f59df433164
    [ 1960.796854] Code: 89 02 48 c7 c0 ff ff ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 8d 05 81 38 2d 00 8b 00 85 c0 75 13 b8 01 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 54 c3 0f 1f 00 41 54 49 89 d4 55 48 89 f5 53
    [ 1960.796884] RSP: 002b:00007ffd70ee2fb8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
    [ 1960.796906] RAX: ffffffffffffffda RBX: 0000000000000002 RCX: 00007f59df433164
    [ 1960.796926] RDX: 0000000000000002 RSI: 00005578088640c0 RDI: 0000000000000001
    [ 1960.796946] RBP: 00005578088640c0 R08: 00007f59df7038c0 R09: 00007f59e0995b80
    [ 1960.796966] R10: 000000000000000a R11: 0000000000000246 R12: 00007f59df702760
    [ 1960.796985] R13: 0000000000000002 R14: 00007f59df6fd760 R15: 0000000000000002
    [ 1960.797008] irq event stamp: 509990
    [ 1960.797026] hardirqs last  enabled at (509989): [<ffffffff8119ff78>] flush_work+0x4b8/0x6d0
    [ 1960.797063] hardirqs last disabled at (509990): [<ffffffff8297c395>] _raw_spin_lock_irqsave+0x25/0x60
    [ 1960.797085] softirqs last  enabled at (509744): [<ffffffff82c005ad>] __do_softirq+0x5ad/0x8c0
    [ 1960.797121] softirqs last disabled at (509735): [<ffffffff8115aa15>] irq_exit+0x1a5/0x1e0
    [ 1960.797142] ---[ end trace fb1342325f1846b8 ]---
    
    While I haven't actually gone into the details of what's causing this to
    happen (maybe the kernel removes the backlight device in the device core
    before we get to it?), it doesn't really matter anyway because the way
    nouveau handles backlights has long since been deprecated.
    
    According to the documentation on the drm_connector->late_register()
    hook, the ->late_register() hook should be used for adding extra
    connector-related devices. Vice versa, the ->early_unregister() hook is
    meant to be used for removing those devices.
    
    So: gut nouveau_drm->bl_list and nouveau_drm->backlight, and replace
    them with per-connector backlight structures. Additionally, move
    backlight registration/teardown into the ->late_register() and
    ->early_unregister() hooks so that DRM can give us a chance to remove
    the backlight before the connector is even removed. This appears to fix
    the problem once and for all.
    
    Changes since v2:
    - Use NV_INFO_ONCE for printing GMUX information, since otherwise this
      will end up printing that message for as many times as we have
      connectors
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Karol Herbst <kherbst@redhat.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 6dd72bc32897..5d0694680f59 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -37,18 +37,19 @@
 #include "nouveau_drv.h"
 #include "nouveau_reg.h"
 #include "nouveau_encoder.h"
+#include "nouveau_connector.h"
 
 static struct ida bl_ida;
 #define BL_NAME_SIZE 15 // 12 for name + 2 for digits + 1 for '\0'
 
-struct backlight_connector {
-	struct list_head head;
+struct nouveau_backlight {
+	struct backlight_device *dev;
 	int id;
 };
 
 static bool
-nouveau_get_backlight_name(char backlight_name[BL_NAME_SIZE], struct backlight_connector
-		*connector)
+nouveau_get_backlight_name(char backlight_name[BL_NAME_SIZE],
+			   struct nouveau_backlight *bl)
 {
 	const int nb = ida_simple_get(&bl_ida, 0, 0, GFP_KERNEL);
 	if (nb < 0 || nb >= 100)
@@ -57,7 +58,7 @@ nouveau_get_backlight_name(char backlight_name[BL_NAME_SIZE], struct backlight_c
 		snprintf(backlight_name, BL_NAME_SIZE, "nv_backlight%d", nb);
 	else
 		snprintf(backlight_name, BL_NAME_SIZE, "nv_backlight");
-	connector->id = nb;
+	bl->id = nb;
 	return true;
 }
 
@@ -96,36 +97,45 @@ static int
 nv40_backlight_init(struct drm_connector *connector)
 {
 	struct nouveau_drm *drm = nouveau_drm(connector->dev);
+	struct nouveau_backlight *bl;
 	struct nvif_object *device = &drm->client.device.object;
 	struct backlight_properties props;
-	struct backlight_device *bd;
-	struct backlight_connector bl_connector;
 	char backlight_name[BL_NAME_SIZE];
+	int ret = 0;
 
 	if (!(nvif_rd32(device, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK))
 		return 0;
 
+	bl = kzalloc(sizeof(*bl), GFP_KERNEL);
+	if (!bl)
+		return -ENOMEM;
+
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
 	props.max_brightness = 31;
-	if (!nouveau_get_backlight_name(backlight_name, &bl_connector)) {
+	if (!nouveau_get_backlight_name(backlight_name, bl)) {
 		NV_ERROR(drm, "Failed to retrieve a unique name for the backlight interface\n");
-		return 0;
+		goto fail_alloc;
 	}
-	bd = backlight_device_register(backlight_name , connector->kdev, drm,
-				       &nv40_bl_ops, &props);
 
-	if (IS_ERR(bd)) {
-		if (bl_connector.id >= 0)
-			ida_simple_remove(&bl_ida, bl_connector.id);
-		return PTR_ERR(bd);
+	bl->dev = backlight_device_register(backlight_name, connector->kdev,
+					    drm, &nv40_bl_ops, &props);
+	if (IS_ERR(bl->dev)) {
+		if (bl->id >= 0)
+			ida_simple_remove(&bl_ida, bl->id);
+
+		ret = PTR_ERR(bl->dev);
+		goto fail_alloc;
 	}
-	list_add(&bl_connector.head, &drm->bl_connectors);
-	drm->backlight = bd;
-	bd->props.brightness = nv40_get_intensity(bd);
-	backlight_update_status(bd);
+
+	nouveau_connector(connector)->backlight = bl;
+	bl->dev->props.brightness = nv40_get_intensity(bl->dev);
+	backlight_update_status(bl->dev);
 
 	return 0;
+fail_alloc:
+	kfree(bl);
+	return ret;
 }
 
 static int
@@ -215,11 +225,11 @@ nv50_backlight_init(struct drm_connector *connector)
 	struct nouveau_drm *drm = nouveau_drm(connector->dev);
 	struct nvif_object *device = &drm->client.device.object;
 	struct nouveau_encoder *nv_encoder;
+	struct nouveau_backlight *bl;
 	struct backlight_properties props;
-	struct backlight_device *bd;
 	const struct backlight_ops *ops;
-	struct backlight_connector bl_connector;
 	char backlight_name[BL_NAME_SIZE];
+	int ret = 0;
 
 	nv_encoder = find_encoder(connector, DCB_OUTPUT_LVDS);
 	if (!nv_encoder) {
@@ -231,6 +241,10 @@ nv50_backlight_init(struct drm_connector *connector)
 	if (!nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(ffs(nv_encoder->dcb->or) - 1)))
 		return 0;
 
+	bl = kzalloc(sizeof(*bl), GFP_KERNEL);
+	if (!bl)
+		return -ENOMEM;
+
 	if (drm->client.device.info.chipset <= 0xa0 ||
 	    drm->client.device.info.chipset == 0xaa ||
 	    drm->client.device.info.chipset == 0xac)
@@ -241,79 +255,74 @@ nv50_backlight_init(struct drm_connector *connector)
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
 	props.max_brightness = 100;
-	if (!nouveau_get_backlight_name(backlight_name, &bl_connector)) {
+	if (!nouveau_get_backlight_name(backlight_name, bl)) {
 		NV_ERROR(drm, "Failed to retrieve a unique name for the backlight interface\n");
-		return 0;
+		goto fail_alloc;
 	}
-	bd = backlight_device_register(backlight_name , connector->kdev,
-				       nv_encoder, ops, &props);
 
-	if (IS_ERR(bd)) {
-		if (bl_connector.id >= 0)
-			ida_simple_remove(&bl_ida, bl_connector.id);
-		return PTR_ERR(bd);
+	bl->dev = backlight_device_register(backlight_name, connector->kdev,
+					    nv_encoder, ops, &props);
+	if (IS_ERR(bl->dev)) {
+		if (bl->id >= 0)
+			ida_simple_remove(&bl_ida, bl->id);
+
+		ret = PTR_ERR(bl->dev);
+		goto fail_alloc;
 	}
 
-	list_add(&bl_connector.head, &drm->bl_connectors);
-	drm->backlight = bd;
-	bd->props.brightness = bd->ops->get_brightness(bd);
-	backlight_update_status(bd);
+	nouveau_connector(connector)->backlight = bl;
+	bl->dev->props.brightness = bl->dev->ops->get_brightness(bl->dev);
+	backlight_update_status(bl->dev);
 	return 0;
+
+fail_alloc:
+	kfree(bl);
+	return ret;
 }
 
 int
-nouveau_backlight_init(struct drm_device *dev)
+nouveau_backlight_init(struct drm_connector *connector)
 {
-	struct nouveau_drm *drm = nouveau_drm(dev);
+	struct nouveau_drm *drm = nouveau_drm(connector->dev);
 	struct nvif_device *device = &drm->client.device;
-	struct drm_connector *connector;
-	struct drm_connector_list_iter conn_iter;
-
-	INIT_LIST_HEAD(&drm->bl_connectors);
 
 	if (apple_gmux_present()) {
-		NV_INFO(drm, "Apple GMUX detected: not registering Nouveau backlight interface\n");
+		NV_INFO_ONCE(drm, "Apple GMUX detected: not registering Nouveau backlight interface\n");
 		return 0;
 	}
 
-	drm_connector_list_iter_begin(dev, &conn_iter);
-	drm_for_each_connector_iter(connector, &conn_iter) {
-		if (connector->connector_type != DRM_MODE_CONNECTOR_LVDS &&
-		    connector->connector_type != DRM_MODE_CONNECTOR_eDP)
-			continue;
-
-		switch (device->info.family) {
-		case NV_DEVICE_INFO_V0_CURIE:
-			return nv40_backlight_init(connector);
-		case NV_DEVICE_INFO_V0_TESLA:
-		case NV_DEVICE_INFO_V0_FERMI:
-		case NV_DEVICE_INFO_V0_KEPLER:
-		case NV_DEVICE_INFO_V0_MAXWELL:
-			return nv50_backlight_init(connector);
-		default:
-			break;
-		}
-	}
-	drm_connector_list_iter_end(&conn_iter);
+	if (connector->connector_type != DRM_MODE_CONNECTOR_LVDS &&
+	    connector->connector_type != DRM_MODE_CONNECTOR_eDP)
+		return 0;
 
-	return 0;
+	switch (device->info.family) {
+	case NV_DEVICE_INFO_V0_CURIE:
+		return nv40_backlight_init(connector);
+	case NV_DEVICE_INFO_V0_TESLA:
+	case NV_DEVICE_INFO_V0_FERMI:
+	case NV_DEVICE_INFO_V0_KEPLER:
+	case NV_DEVICE_INFO_V0_MAXWELL:
+		return nv50_backlight_init(connector);
+	default:
+		return 0;
+	}
 }
 
 void
-nouveau_backlight_exit(struct drm_device *dev)
+nouveau_backlight_exit(struct drm_connector *connector)
 {
-	struct nouveau_drm *drm = nouveau_drm(dev);
-	struct backlight_connector *connector;
+	struct nouveau_connector *nv_conn = nouveau_connector(connector);
+	struct nouveau_backlight *bl = nv_conn->backlight;
 
-	list_for_each_entry(connector, &drm->bl_connectors, head) {
-		if (connector->id >= 0)
-			ida_simple_remove(&bl_ida, connector->id);
-	}
+	if (!bl)
+		return;
 
-	if (drm->backlight) {
-		backlight_device_unregister(drm->backlight);
-		drm->backlight = NULL;
-	}
+	if (bl->id >= 0)
+		ida_simple_remove(&bl_ida, bl->id);
+
+	backlight_device_unregister(bl->dev);
+	nv_conn->backlight = NULL;
+	kfree(bl);
 }
 
 void

commit dc854914999d5d52ac1b31740cb0ea8d89d0372e
Author: Lyude Paul <lyude@redhat.com>
Date:   Thu Sep 6 17:43:21 2018 -0400

    drm/nouveau: Check backlight IDs are >= 0, not > 0
    
    Remember, ida IDs start at 0, not 1!
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Reviewed-by: Karol Herbst <kherbst@redhat.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 408b955e5c39..6dd72bc32897 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -116,7 +116,7 @@ nv40_backlight_init(struct drm_connector *connector)
 				       &nv40_bl_ops, &props);
 
 	if (IS_ERR(bd)) {
-		if (bl_connector.id > 0)
+		if (bl_connector.id >= 0)
 			ida_simple_remove(&bl_ida, bl_connector.id);
 		return PTR_ERR(bd);
 	}
@@ -249,7 +249,7 @@ nv50_backlight_init(struct drm_connector *connector)
 				       nv_encoder, ops, &props);
 
 	if (IS_ERR(bd)) {
-		if (bl_connector.id > 0)
+		if (bl_connector.id >= 0)
 			ida_simple_remove(&bl_ida, bl_connector.id);
 		return PTR_ERR(bd);
 	}

commit 22b76bbe089cd901f5260ecb9a3dc41f9edb97a0
Author: Lyude Paul <lyude@redhat.com>
Date:   Fri Jul 13 13:06:32 2018 -0400

    drm/nouveau: Use drm_connector_list_iter_* for iterating connectors
    
    Every codepath in nouveau that loops through the connector list
    currently does so using the old method, which is prone to race
    conditions from MST connectors being created and destroyed. This has
    been causing a multitude of problems, including memory corruption from
    trying to access connectors that have already been freed!
    
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Cc: stable@vger.kernel.org
    Cc: Karol Herbst <karolherbst@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index debbbf0fd4bd..408b955e5c39 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -267,6 +267,7 @@ nouveau_backlight_init(struct drm_device *dev)
 	struct nouveau_drm *drm = nouveau_drm(dev);
 	struct nvif_device *device = &drm->client.device;
 	struct drm_connector *connector;
+	struct drm_connector_list_iter conn_iter;
 
 	INIT_LIST_HEAD(&drm->bl_connectors);
 
@@ -275,7 +276,8 @@ nouveau_backlight_init(struct drm_device *dev)
 		return 0;
 	}
 
-	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+	drm_connector_list_iter_begin(dev, &conn_iter);
+	drm_for_each_connector_iter(connector, &conn_iter) {
 		if (connector->connector_type != DRM_MODE_CONNECTOR_LVDS &&
 		    connector->connector_type != DRM_MODE_CONNECTOR_eDP)
 			continue;
@@ -292,7 +294,7 @@ nouveau_backlight_init(struct drm_device *dev)
 			break;
 		}
 	}
-
+	drm_connector_list_iter_end(&conn_iter);
 
 	return 0;
 }

commit 9e75dc61eaa9acd1bff83c3b814ac2af6dc1f64c
Author: Karol Herbst <kherbst@redhat.com>
Date:   Mon Feb 19 17:09:45 2018 +0100

    drm/nouveau/bl: fix backlight regression
    
    Fixes: 3c66c87dc9 ("drm/nouveau/disp: remove hw-specific customisation
    of output paths")
    Suggested-by: Ben Skeggs <skeggsb@redhat.com>
    Signed-off-by: Karol Herbst <kherbst@redhat.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index f56f60f695e1..debbbf0fd4bd 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -134,7 +134,7 @@ nv50_get_intensity(struct backlight_device *bd)
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
 	struct nvif_object *device = &drm->client.device.object;
-	int or = nv_encoder->or;
+	int or = ffs(nv_encoder->dcb->or) - 1;
 	u32 div = 1025;
 	u32 val;
 
@@ -149,7 +149,7 @@ nv50_set_intensity(struct backlight_device *bd)
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
 	struct nvif_object *device = &drm->client.device.object;
-	int or = nv_encoder->or;
+	int or = ffs(nv_encoder->dcb->or) - 1;
 	u32 div = 1025;
 	u32 val = (bd->props.brightness * div) / 100;
 
@@ -170,7 +170,7 @@ nva3_get_intensity(struct backlight_device *bd)
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
 	struct nvif_object *device = &drm->client.device.object;
-	int or = nv_encoder->or;
+	int or = ffs(nv_encoder->dcb->or) - 1;
 	u32 div, val;
 
 	div  = nvif_rd32(device, NV50_PDISP_SOR_PWM_DIV(or));
@@ -188,7 +188,7 @@ nva3_set_intensity(struct backlight_device *bd)
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
 	struct nvif_object *device = &drm->client.device.object;
-	int or = nv_encoder->or;
+	int or = ffs(nv_encoder->dcb->or) - 1;
 	u32 div, val;
 
 	div = nvif_rd32(device, NV50_PDISP_SOR_PWM_DIV(or));
@@ -228,7 +228,7 @@ nv50_backlight_init(struct drm_connector *connector)
 			return -ENODEV;
 	}
 
-	if (!nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(nv_encoder->or)))
+	if (!nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(ffs(nv_encoder->dcb->or) - 1)))
 		return 0;
 
 	if (drm->client.device.info.chipset <= 0xa0 ||

commit 76f2e2bc627f7d08360ac731b6277d744d4eb599
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Feb 17 13:40:23 2018 +0100

    drm/nouveau/bl: Fix oops on driver unbind
    
    Unbinding nouveau on a dual GPU MacBook Pro oopses because we iterate
    over the bl_connectors list in nouveau_backlight_exit() but skipped
    initializing it in nouveau_backlight_init().  Stacktrace for posterity:
    
        BUG: unable to handle kernel NULL pointer dereference at 0000000000000010
        IP: nouveau_backlight_exit+0x2b/0x70 [nouveau]
        nouveau_display_destroy+0x29/0x80 [nouveau]
        nouveau_drm_unload+0x65/0xe0 [nouveau]
        drm_dev_unregister+0x3c/0xe0 [drm]
        drm_put_dev+0x2e/0x60 [drm]
        nouveau_drm_device_remove+0x47/0x70 [nouveau]
        pci_device_remove+0x36/0xb0
        device_release_driver_internal+0x157/0x220
        driver_detach+0x39/0x70
        bus_remove_driver+0x51/0xd0
        pci_unregister_driver+0x2a/0xa0
        nouveau_drm_exit+0x15/0xfb0 [nouveau]
        SyS_delete_module+0x18c/0x290
        system_call_fast_compare_end+0xc/0x6f
    
    Fixes: b53ac1ee12a3 ("drm/nouveau/bl: Do not register interface if Apple GMUX detected")
    Cc: stable@vger.kernel.org # v4.10+
    Cc: Pierre Moreau <pierre.morrow@free.fr>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 380f340204e8..f56f60f695e1 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -268,13 +268,13 @@ nouveau_backlight_init(struct drm_device *dev)
 	struct nvif_device *device = &drm->client.device;
 	struct drm_connector *connector;
 
+	INIT_LIST_HEAD(&drm->bl_connectors);
+
 	if (apple_gmux_present()) {
 		NV_INFO(drm, "Apple GMUX detected: not registering Nouveau backlight interface\n");
 		return 0;
 	}
 
-	INIT_LIST_HEAD(&drm->bl_connectors);
-
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
 		if (connector->connector_type != DRM_MODE_CONNECTOR_LVDS &&
 		    connector->connector_type != DRM_MODE_CONNECTOR_eDP)

commit 1167c6bc51880cb74a3b1a02286fc25392684281
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed May 18 13:57:42 2016 +1000

    drm/nouveau: allocate device object for every client
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 8b1ca4add2ed..380f340204e8 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -65,7 +65,7 @@ static int
 nv40_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_drm *drm = bl_get_data(bd);
-	struct nvif_object *device = &drm->device.object;
+	struct nvif_object *device = &drm->client.device.object;
 	int val = (nvif_rd32(device, NV40_PMC_BACKLIGHT) &
 				   NV40_PMC_BACKLIGHT_MASK) >> 16;
 
@@ -76,7 +76,7 @@ static int
 nv40_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_drm *drm = bl_get_data(bd);
-	struct nvif_object *device = &drm->device.object;
+	struct nvif_object *device = &drm->client.device.object;
 	int val = bd->props.brightness;
 	int reg = nvif_rd32(device, NV40_PMC_BACKLIGHT);
 
@@ -96,7 +96,7 @@ static int
 nv40_backlight_init(struct drm_connector *connector)
 {
 	struct nouveau_drm *drm = nouveau_drm(connector->dev);
-	struct nvif_object *device = &drm->device.object;
+	struct nvif_object *device = &drm->client.device.object;
 	struct backlight_properties props;
 	struct backlight_device *bd;
 	struct backlight_connector bl_connector;
@@ -133,7 +133,7 @@ nv50_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
-	struct nvif_object *device = &drm->device.object;
+	struct nvif_object *device = &drm->client.device.object;
 	int or = nv_encoder->or;
 	u32 div = 1025;
 	u32 val;
@@ -148,7 +148,7 @@ nv50_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
-	struct nvif_object *device = &drm->device.object;
+	struct nvif_object *device = &drm->client.device.object;
 	int or = nv_encoder->or;
 	u32 div = 1025;
 	u32 val = (bd->props.brightness * div) / 100;
@@ -169,7 +169,7 @@ nva3_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
-	struct nvif_object *device = &drm->device.object;
+	struct nvif_object *device = &drm->client.device.object;
 	int or = nv_encoder->or;
 	u32 div, val;
 
@@ -187,7 +187,7 @@ nva3_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
-	struct nvif_object *device = &drm->device.object;
+	struct nvif_object *device = &drm->client.device.object;
 	int or = nv_encoder->or;
 	u32 div, val;
 
@@ -213,7 +213,7 @@ static int
 nv50_backlight_init(struct drm_connector *connector)
 {
 	struct nouveau_drm *drm = nouveau_drm(connector->dev);
-	struct nvif_object *device = &drm->device.object;
+	struct nvif_object *device = &drm->client.device.object;
 	struct nouveau_encoder *nv_encoder;
 	struct backlight_properties props;
 	struct backlight_device *bd;
@@ -231,9 +231,9 @@ nv50_backlight_init(struct drm_connector *connector)
 	if (!nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(nv_encoder->or)))
 		return 0;
 
-	if (drm->device.info.chipset <= 0xa0 ||
-	    drm->device.info.chipset == 0xaa ||
-	    drm->device.info.chipset == 0xac)
+	if (drm->client.device.info.chipset <= 0xa0 ||
+	    drm->client.device.info.chipset == 0xaa ||
+	    drm->client.device.info.chipset == 0xac)
 		ops = &nv50_bl_ops;
 	else
 		ops = &nva3_bl_ops;
@@ -265,7 +265,7 @@ int
 nouveau_backlight_init(struct drm_device *dev)
 {
 	struct nouveau_drm *drm = nouveau_drm(dev);
-	struct nvif_device *device = &drm->device;
+	struct nvif_device *device = &drm->client.device;
 	struct drm_connector *connector;
 
 	if (apple_gmux_present()) {

commit b53ac1ee12a330dea59243e240aef398e951ff32
Author: Pierre Moreau <pierre.morrow@free.fr>
Date:   Thu Dec 8 00:57:09 2016 +0100

    drm/nouveau/bl: Do not register interface if Apple GMUX detected
    
    The Apple GMUX is the one managing the backlight, so there is no need for
    Nouveau to register its own backlight interface.
    
    v2: Do not split information message on two lines as it prevents from grepping
        it, as pointed out by Lukas Wunner
    
    v3: Add a missing end-of-line character to the printed message
    
    Signed-off-by: Pierre Moreau <pierre.morrow@free.fr>
    Reviewed-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index a34cd35d4965..8b1ca4add2ed 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -30,6 +30,7 @@
  * Register locations derived from NVClock by Roderick Colenbrander
  */
 
+#include <linux/apple-gmux.h>
 #include <linux/backlight.h>
 #include <linux/idr.h>
 
@@ -267,6 +268,11 @@ nouveau_backlight_init(struct drm_device *dev)
 	struct nvif_device *device = &drm->device;
 	struct drm_connector *connector;
 
+	if (apple_gmux_present()) {
+		NV_INFO(drm, "Apple GMUX detected: not registering Nouveau backlight interface\n");
+		return 0;
+	}
+
 	INIT_LIST_HEAD(&drm->bl_connectors);
 
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {

commit db1a0ae21461afa4bc435651a6dd55e0e6ef4a8b
Author: Pierre Moreau <pierre.morrow@free.fr>
Date:   Thu Dec 8 00:57:08 2016 +0100

    drm/nouveau/bl: Assign different names to interfaces
    
    Currently, every backlight interface created by Nouveau uses the same name,
    nv_backlight. This leads to a sysfs warning as it tries to create an already
    existing folder. This patch adds a incremented number to the name, but keeps
    the initial name as nv_backlight, to avoid possibly breaking userspace; the
    second interface will be named nv_backlight1, and so on.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=86539
    
    v2:
    * Switch to using ida for generating unique IDs, as suggested by Ilia Mirkin;
    * Allocate backlight name on the stack, as suggested by Ilia Mirkin;
    * Move `nouveau_get_backlight_name()` to avoid forward declaration, as
      suggested by Ilia Mirkin;
    * Fix reference to bug report formatting, as reported by Nick Tenney.
    
    v3:
    * Define a macro for the size of the backlight name, to avoid defining
      it multiple times;
    * Use snprintf in place of sprintf.
    
    v4:
    * Do not create similarly named interfaces when reaching the maximum
      amount of unique names, but fail instead, as pointed out by Lukas Wunner
    
    Signed-off-by: Pierre Moreau <pierre.morrow@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 5e2c5685b4dd..a34cd35d4965 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -31,11 +31,35 @@
  */
 
 #include <linux/backlight.h>
+#include <linux/idr.h>
 
 #include "nouveau_drv.h"
 #include "nouveau_reg.h"
 #include "nouveau_encoder.h"
 
+static struct ida bl_ida;
+#define BL_NAME_SIZE 15 // 12 for name + 2 for digits + 1 for '\0'
+
+struct backlight_connector {
+	struct list_head head;
+	int id;
+};
+
+static bool
+nouveau_get_backlight_name(char backlight_name[BL_NAME_SIZE], struct backlight_connector
+		*connector)
+{
+	const int nb = ida_simple_get(&bl_ida, 0, 0, GFP_KERNEL);
+	if (nb < 0 || nb >= 100)
+		return false;
+	if (nb > 0)
+		snprintf(backlight_name, BL_NAME_SIZE, "nv_backlight%d", nb);
+	else
+		snprintf(backlight_name, BL_NAME_SIZE, "nv_backlight");
+	connector->id = nb;
+	return true;
+}
+
 static int
 nv40_get_intensity(struct backlight_device *bd)
 {
@@ -74,6 +98,8 @@ nv40_backlight_init(struct drm_connector *connector)
 	struct nvif_object *device = &drm->device.object;
 	struct backlight_properties props;
 	struct backlight_device *bd;
+	struct backlight_connector bl_connector;
+	char backlight_name[BL_NAME_SIZE];
 
 	if (!(nvif_rd32(device, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK))
 		return 0;
@@ -81,10 +107,19 @@ nv40_backlight_init(struct drm_connector *connector)
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
 	props.max_brightness = 31;
-	bd = backlight_device_register("nv_backlight", connector->kdev, drm,
+	if (!nouveau_get_backlight_name(backlight_name, &bl_connector)) {
+		NV_ERROR(drm, "Failed to retrieve a unique name for the backlight interface\n");
+		return 0;
+	}
+	bd = backlight_device_register(backlight_name , connector->kdev, drm,
 				       &nv40_bl_ops, &props);
-	if (IS_ERR(bd))
+
+	if (IS_ERR(bd)) {
+		if (bl_connector.id > 0)
+			ida_simple_remove(&bl_ida, bl_connector.id);
 		return PTR_ERR(bd);
+	}
+	list_add(&bl_connector.head, &drm->bl_connectors);
 	drm->backlight = bd;
 	bd->props.brightness = nv40_get_intensity(bd);
 	backlight_update_status(bd);
@@ -182,6 +217,8 @@ nv50_backlight_init(struct drm_connector *connector)
 	struct backlight_properties props;
 	struct backlight_device *bd;
 	const struct backlight_ops *ops;
+	struct backlight_connector bl_connector;
+	char backlight_name[BL_NAME_SIZE];
 
 	nv_encoder = find_encoder(connector, DCB_OUTPUT_LVDS);
 	if (!nv_encoder) {
@@ -203,11 +240,20 @@ nv50_backlight_init(struct drm_connector *connector)
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
 	props.max_brightness = 100;
-	bd = backlight_device_register("nv_backlight", connector->kdev,
+	if (!nouveau_get_backlight_name(backlight_name, &bl_connector)) {
+		NV_ERROR(drm, "Failed to retrieve a unique name for the backlight interface\n");
+		return 0;
+	}
+	bd = backlight_device_register(backlight_name , connector->kdev,
 				       nv_encoder, ops, &props);
-	if (IS_ERR(bd))
+
+	if (IS_ERR(bd)) {
+		if (bl_connector.id > 0)
+			ida_simple_remove(&bl_ida, bl_connector.id);
 		return PTR_ERR(bd);
+	}
 
+	list_add(&bl_connector.head, &drm->bl_connectors);
 	drm->backlight = bd;
 	bd->props.brightness = bd->ops->get_brightness(bd);
 	backlight_update_status(bd);
@@ -221,6 +267,8 @@ nouveau_backlight_init(struct drm_device *dev)
 	struct nvif_device *device = &drm->device;
 	struct drm_connector *connector;
 
+	INIT_LIST_HEAD(&drm->bl_connectors);
+
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
 		if (connector->connector_type != DRM_MODE_CONNECTOR_LVDS &&
 		    connector->connector_type != DRM_MODE_CONNECTOR_eDP)
@@ -247,9 +295,27 @@ void
 nouveau_backlight_exit(struct drm_device *dev)
 {
 	struct nouveau_drm *drm = nouveau_drm(dev);
+	struct backlight_connector *connector;
+
+	list_for_each_entry(connector, &drm->bl_connectors, head) {
+		if (connector->id >= 0)
+			ida_simple_remove(&bl_ida, connector->id);
+	}
 
 	if (drm->backlight) {
 		backlight_device_unregister(drm->backlight);
 		drm->backlight = NULL;
 	}
 }
+
+void
+nouveau_backlight_ctor(void)
+{
+	ida_init(&bl_ida);
+}
+
+void
+nouveau_backlight_dtor(void)
+{
+	ida_destroy(&bl_ida);
+}

commit bbe1f94a8b3f2e8622dd400a6827d3242005d951
Author: Faris Alsalama <farisbenbrahem@gmail.com>
Date:   Sat May 21 14:41:43 2016 -0400

    drm/nouveau/kms: add Maxwell to backlight initialization
    
    Signed-off-by: Faris Alsalama <farisbenbrahem@gmail.com>
    Acked-by: Acked-by: Pierre Moreau <pierre.morrow@free.fr>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index f5101be806cb..5e2c5685b4dd 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -232,6 +232,7 @@ nouveau_backlight_init(struct drm_device *dev)
 		case NV_DEVICE_INFO_V0_TESLA:
 		case NV_DEVICE_INFO_V0_FERMI:
 		case NV_DEVICE_INFO_V0_KEPLER:
+		case NV_DEVICE_INFO_V0_MAXWELL:
 			return nv50_backlight_init(connector);
 		default:
 			break;

commit 4dc28134a8c124aa01b441e1e5b8b54312edc5dd
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri May 20 09:22:55 2016 +1000

    drm/nouveau: rename nouveau_drm.h to nouveau_drv.h
    
    Fixes out-of-tree build issue where uapi/drm/nouveau_drm.h gets picked
    up instead.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 89eb46040b13..f5101be806cb 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -32,7 +32,7 @@
 
 #include <linux/backlight.h>
 
-#include "nouveau_drm.h"
+#include "nouveau_drv.h"
 #include "nouveau_reg.h"
 #include "nouveau_encoder.h"
 

commit a01ca78c8f118e5a24f1527ecf078ab56ddd4805
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:15 2015 +1000

    drm/nouveau/nvif: simplify and tidy library interfaces
    
    A variety of tweaks to the NVIF library interfaces, mostly ripping out
    things that turned out to be not so useful.
    
    - Removed refcounting from nvif_object, callers are expected to not be
      stupid instead.
    - nvif_client is directly reachable from anything derived from nvif_object,
      removing the need for heuristics to locate it
    - _new() versions of interfaces, that allocate memory for the object
      they construct, have been removed.  The vast majority of callers used
      the embedded _init() interfaces.
    - No longer storing constructor arguments (and the data returned from
      nvkm) inside nvif_object, it's more or less unused and just wastes
      memory.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index e566c5b53651..89eb46040b13 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -40,7 +40,7 @@ static int
 nv40_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_drm *drm = bl_get_data(bd);
-	struct nvif_device *device = &drm->device;
+	struct nvif_object *device = &drm->device.object;
 	int val = (nvif_rd32(device, NV40_PMC_BACKLIGHT) &
 				   NV40_PMC_BACKLIGHT_MASK) >> 16;
 
@@ -51,7 +51,7 @@ static int
 nv40_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_drm *drm = bl_get_data(bd);
-	struct nvif_device *device = &drm->device;
+	struct nvif_object *device = &drm->device.object;
 	int val = bd->props.brightness;
 	int reg = nvif_rd32(device, NV40_PMC_BACKLIGHT);
 
@@ -71,7 +71,7 @@ static int
 nv40_backlight_init(struct drm_connector *connector)
 {
 	struct nouveau_drm *drm = nouveau_drm(connector->dev);
-	struct nvif_device *device = &drm->device;
+	struct nvif_object *device = &drm->device.object;
 	struct backlight_properties props;
 	struct backlight_device *bd;
 
@@ -97,7 +97,7 @@ nv50_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
-	struct nvif_device *device = &drm->device;
+	struct nvif_object *device = &drm->device.object;
 	int or = nv_encoder->or;
 	u32 div = 1025;
 	u32 val;
@@ -112,7 +112,7 @@ nv50_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
-	struct nvif_device *device = &drm->device;
+	struct nvif_object *device = &drm->device.object;
 	int or = nv_encoder->or;
 	u32 div = 1025;
 	u32 val = (bd->props.brightness * div) / 100;
@@ -133,7 +133,7 @@ nva3_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
-	struct nvif_device *device = &drm->device;
+	struct nvif_object *device = &drm->device.object;
 	int or = nv_encoder->or;
 	u32 div, val;
 
@@ -151,7 +151,7 @@ nva3_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
-	struct nvif_device *device = &drm->device;
+	struct nvif_object *device = &drm->device.object;
 	int or = nv_encoder->or;
 	u32 div, val;
 
@@ -177,7 +177,7 @@ static int
 nv50_backlight_init(struct drm_connector *connector)
 {
 	struct nouveau_drm *drm = nouveau_drm(connector->dev);
-	struct nvif_device *device = &drm->device;
+	struct nvif_object *device = &drm->device.object;
 	struct nouveau_encoder *nv_encoder;
 	struct backlight_properties props;
 	struct backlight_device *bd;
@@ -193,9 +193,9 @@ nv50_backlight_init(struct drm_connector *connector)
 	if (!nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(nv_encoder->or)))
 		return 0;
 
-	if (device->info.chipset <= 0xa0 ||
-	    device->info.chipset == 0xaa ||
-	    device->info.chipset == 0xac)
+	if (drm->device.info.chipset <= 0xa0 ||
+	    drm->device.info.chipset == 0xaa ||
+	    drm->device.info.chipset == 0xac)
 		ops = &nv50_bl_ops;
 	else
 		ops = &nva3_bl_ops;

commit 967e7bde8739fe3b215f7537e8f1f39c044902af
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Aug 10 04:10:22 2014 +1000

    drm/nouveau: initial pass at moving to struct nvif_device
    
    This is an attempt at isolating some of the changes necessary to port
    to NVIF in a separate commit.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index dd2accd69f65..e566c5b53651 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -40,7 +40,7 @@ static int
 nv40_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_drm *drm = bl_get_data(bd);
-	struct nouveau_object *device = drm->device;
+	struct nvif_device *device = &drm->device;
 	int val = (nvif_rd32(device, NV40_PMC_BACKLIGHT) &
 				   NV40_PMC_BACKLIGHT_MASK) >> 16;
 
@@ -51,7 +51,7 @@ static int
 nv40_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_drm *drm = bl_get_data(bd);
-	struct nouveau_object *device = drm->device;
+	struct nvif_device *device = &drm->device;
 	int val = bd->props.brightness;
 	int reg = nvif_rd32(device, NV40_PMC_BACKLIGHT);
 
@@ -71,7 +71,7 @@ static int
 nv40_backlight_init(struct drm_connector *connector)
 {
 	struct nouveau_drm *drm = nouveau_drm(connector->dev);
-	struct nouveau_object *device = drm->device;
+	struct nvif_device *device = &drm->device;
 	struct backlight_properties props;
 	struct backlight_device *bd;
 
@@ -97,7 +97,7 @@ nv50_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
-	struct nouveau_object *device = drm->device;
+	struct nvif_device *device = &drm->device;
 	int or = nv_encoder->or;
 	u32 div = 1025;
 	u32 val;
@@ -112,7 +112,7 @@ nv50_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
-	struct nouveau_object *device = drm->device;
+	struct nvif_device *device = &drm->device;
 	int or = nv_encoder->or;
 	u32 div = 1025;
 	u32 val = (bd->props.brightness * div) / 100;
@@ -133,7 +133,7 @@ nva3_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
-	struct nouveau_object *device = drm->device;
+	struct nvif_device *device = &drm->device;
 	int or = nv_encoder->or;
 	u32 div, val;
 
@@ -151,7 +151,7 @@ nva3_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
-	struct nouveau_object *device = drm->device;
+	struct nvif_device *device = &drm->device;
 	int or = nv_encoder->or;
 	u32 div, val;
 
@@ -177,7 +177,7 @@ static int
 nv50_backlight_init(struct drm_connector *connector)
 {
 	struct nouveau_drm *drm = nouveau_drm(connector->dev);
-	struct nouveau_object *device = drm->device;
+	struct nvif_device *device = &drm->device;
 	struct nouveau_encoder *nv_encoder;
 	struct backlight_properties props;
 	struct backlight_device *bd;
@@ -193,9 +193,9 @@ nv50_backlight_init(struct drm_connector *connector)
 	if (!nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(nv_encoder->or)))
 		return 0;
 
-	if (nv_device(device)->chipset <= 0xa0 ||
-	    nv_device(device)->chipset == 0xaa ||
-	    nv_device(device)->chipset == 0xac)
+	if (device->info.chipset <= 0xa0 ||
+	    device->info.chipset == 0xaa ||
+	    device->info.chipset == 0xac)
 		ops = &nv50_bl_ops;
 	else
 		ops = &nva3_bl_ops;
@@ -218,7 +218,7 @@ int
 nouveau_backlight_init(struct drm_device *dev)
 {
 	struct nouveau_drm *drm = nouveau_drm(dev);
-	struct nouveau_object *device = drm->device;
+	struct nvif_device *device = &drm->device;
 	struct drm_connector *connector;
 
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
@@ -226,12 +226,12 @@ nouveau_backlight_init(struct drm_device *dev)
 		    connector->connector_type != DRM_MODE_CONNECTOR_eDP)
 			continue;
 
-		switch (nv_device(device)->card_type) {
-		case NV_40:
+		switch (device->info.family) {
+		case NV_DEVICE_INFO_V0_CURIE:
 			return nv40_backlight_init(connector);
-		case NV_50:
-		case NV_C0:
-		case NV_E0:
+		case NV_DEVICE_INFO_V0_TESLA:
+		case NV_DEVICE_INFO_V0_FERMI:
+		case NV_DEVICE_INFO_V0_KEPLER:
 			return nv50_backlight_init(connector);
 		default:
 			break;

commit db2bec187dd68e79d512112df1f6e7a849e7f0ce
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Aug 10 04:10:22 2014 +1000

    drm/nouveau: kill nouveau_dev() + wrap register macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 3986d198eff3..dd2accd69f65 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -40,8 +40,8 @@ static int
 nv40_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_drm *drm = bl_get_data(bd);
-	struct nouveau_device *device = nv_device(drm->device);
-	int val = (nv_rd32(device, NV40_PMC_BACKLIGHT) &
+	struct nouveau_object *device = drm->device;
+	int val = (nvif_rd32(device, NV40_PMC_BACKLIGHT) &
 				   NV40_PMC_BACKLIGHT_MASK) >> 16;
 
 	return val;
@@ -51,11 +51,11 @@ static int
 nv40_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_drm *drm = bl_get_data(bd);
-	struct nouveau_device *device = nv_device(drm->device);
+	struct nouveau_object *device = drm->device;
 	int val = bd->props.brightness;
-	int reg = nv_rd32(device, NV40_PMC_BACKLIGHT);
+	int reg = nvif_rd32(device, NV40_PMC_BACKLIGHT);
 
-	nv_wr32(device, NV40_PMC_BACKLIGHT,
+	nvif_wr32(device, NV40_PMC_BACKLIGHT,
 		 (val << 16) | (reg & ~NV40_PMC_BACKLIGHT_MASK));
 
 	return 0;
@@ -71,11 +71,11 @@ static int
 nv40_backlight_init(struct drm_connector *connector)
 {
 	struct nouveau_drm *drm = nouveau_drm(connector->dev);
-	struct nouveau_device *device = nv_device(drm->device);
+	struct nouveau_object *device = drm->device;
 	struct backlight_properties props;
 	struct backlight_device *bd;
 
-	if (!(nv_rd32(device, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK))
+	if (!(nvif_rd32(device, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK))
 		return 0;
 
 	memset(&props, 0, sizeof(struct backlight_properties));
@@ -97,12 +97,12 @@ nv50_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
-	struct nouveau_device *device = nv_device(drm->device);
+	struct nouveau_object *device = drm->device;
 	int or = nv_encoder->or;
 	u32 div = 1025;
 	u32 val;
 
-	val  = nv_rd32(device, NV50_PDISP_SOR_PWM_CTL(or));
+	val  = nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(or));
 	val &= NV50_PDISP_SOR_PWM_CTL_VAL;
 	return ((val * 100) + (div / 2)) / div;
 }
@@ -112,12 +112,12 @@ nv50_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
-	struct nouveau_device *device = nv_device(drm->device);
+	struct nouveau_object *device = drm->device;
 	int or = nv_encoder->or;
 	u32 div = 1025;
 	u32 val = (bd->props.brightness * div) / 100;
 
-	nv_wr32(device, NV50_PDISP_SOR_PWM_CTL(or),
+	nvif_wr32(device, NV50_PDISP_SOR_PWM_CTL(or),
 			NV50_PDISP_SOR_PWM_CTL_NEW | val);
 	return 0;
 }
@@ -133,12 +133,12 @@ nva3_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
-	struct nouveau_device *device = nv_device(drm->device);
+	struct nouveau_object *device = drm->device;
 	int or = nv_encoder->or;
 	u32 div, val;
 
-	div  = nv_rd32(device, NV50_PDISP_SOR_PWM_DIV(or));
-	val  = nv_rd32(device, NV50_PDISP_SOR_PWM_CTL(or));
+	div  = nvif_rd32(device, NV50_PDISP_SOR_PWM_DIV(or));
+	val  = nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(or));
 	val &= NVA3_PDISP_SOR_PWM_CTL_VAL;
 	if (div && div >= val)
 		return ((val * 100) + (div / 2)) / div;
@@ -151,14 +151,14 @@ nva3_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
-	struct nouveau_device *device = nv_device(drm->device);
+	struct nouveau_object *device = drm->device;
 	int or = nv_encoder->or;
 	u32 div, val;
 
-	div = nv_rd32(device, NV50_PDISP_SOR_PWM_DIV(or));
+	div = nvif_rd32(device, NV50_PDISP_SOR_PWM_DIV(or));
 	val = (bd->props.brightness * div) / 100;
 	if (div) {
-		nv_wr32(device, NV50_PDISP_SOR_PWM_CTL(or), val |
+		nvif_wr32(device, NV50_PDISP_SOR_PWM_CTL(or), val |
 				NV50_PDISP_SOR_PWM_CTL_NEW |
 				NVA3_PDISP_SOR_PWM_CTL_UNK);
 		return 0;
@@ -177,7 +177,7 @@ static int
 nv50_backlight_init(struct drm_connector *connector)
 {
 	struct nouveau_drm *drm = nouveau_drm(connector->dev);
-	struct nouveau_device *device = nv_device(drm->device);
+	struct nouveau_object *device = drm->device;
 	struct nouveau_encoder *nv_encoder;
 	struct backlight_properties props;
 	struct backlight_device *bd;
@@ -190,12 +190,12 @@ nv50_backlight_init(struct drm_connector *connector)
 			return -ENODEV;
 	}
 
-	if (!nv_rd32(device, NV50_PDISP_SOR_PWM_CTL(nv_encoder->or)))
+	if (!nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(nv_encoder->or)))
 		return 0;
 
-	if (device->chipset <= 0xa0 ||
-	    device->chipset == 0xaa ||
-	    device->chipset == 0xac)
+	if (nv_device(device)->chipset <= 0xa0 ||
+	    nv_device(device)->chipset == 0xaa ||
+	    nv_device(device)->chipset == 0xac)
 		ops = &nv50_bl_ops;
 	else
 		ops = &nva3_bl_ops;
@@ -218,7 +218,7 @@ int
 nouveau_backlight_init(struct drm_device *dev)
 {
 	struct nouveau_drm *drm = nouveau_drm(dev);
-	struct nouveau_device *device = nv_device(drm->device);
+	struct nouveau_object *device = drm->device;
 	struct drm_connector *connector;
 
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
@@ -226,7 +226,7 @@ nouveau_backlight_init(struct drm_device *dev)
 		    connector->connector_type != DRM_MODE_CONNECTOR_eDP)
 			continue;
 
-		switch (device->card_type) {
+		switch (nv_device(device)->card_type) {
 		case NV_40:
 			return nv40_backlight_init(connector);
 		case NV_50:

commit 9c210f378f7cee5f1a5eabe5a78c5ec98251cb5b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Sun Aug 10 04:10:21 2014 +1000

    drm/nouveau/core: remove NV_D0 family
    
    The one place where it mattered has been replaced with a class check,
    which is more appropriate anyway.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 2c1e4aad7da3..3986d198eff3 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -231,7 +231,6 @@ nouveau_backlight_init(struct drm_device *dev)
 			return nv40_backlight_init(connector);
 		case NV_50:
 		case NV_C0:
-		case NV_D0:
 		case NV_E0:
 			return nv50_backlight_init(connector);
 		default:

commit bee564430feec1175ee64bcfd4913cacc519f817
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed May 21 15:39:53 2014 +0200

    nouveau: Don't check acpi_video_backlight_support() before registering backlight
    
    acpi_video_backlight_support() is supposed to be called by other (vendor
    specific) firmware backlight controls, not by native / raw backlight controls
    like nv_backlight.
    
    Userspace will normally prefer firmware interfaces over raw interfaces, so
    if acpi_video backlight support is present it will use that even if
    nv_backlight is registered as well.
    
    Except when video.use_native_backlight is present on the kernel cmdline
    (or enabled through a dmi based quirk). As the name indicates the goal here
    is to make only the raw interface available to userspace so that it will use
    that (it only does this when it sees a win8 compliant bios).
    
    This is done by:
    1) Not registering any acpi_video# backlight devices; and
    2) Making acpi_video_backlight_support() return true so that other firmware
    drivers, ie acer_wmi, thinkpad_acpi, dell_laptop, etc. Don't register their
    own vender specific interfaces.
    
    Currently nouveau breaks this setup, as when acpi_video_backlight_support()
    returns true, it does not register itself, resulting in no backlight control
    at all.
    
    This is esp. going to be a problem with 3.16 which will default to
    video.use_native_backlight=1, and thus nouveau based laptops with a win8 bios
    will get no backlight control at all.
    
    This also likely explains why the previous attempt to make
    video.use_native_backlight=1 the default was not a success, as without this
    patch having a default of video.use_native_backlight=1 will cause regressions.
    
    Note this effectively reverts commit 5bead799d3f8 (drm/nouveau: don't
    expose backlight control when available through ACPI).
    
    References: https://bugzilla.redhat.com/show_bug.cgi?id=1093171
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 630f6e84fc01..2c1e4aad7da3 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -31,7 +31,6 @@
  */
 
 #include <linux/backlight.h>
-#include <linux/acpi.h>
 
 #include "nouveau_drm.h"
 #include "nouveau_reg.h"
@@ -222,14 +221,6 @@ nouveau_backlight_init(struct drm_device *dev)
 	struct nouveau_device *device = nv_device(drm->device);
 	struct drm_connector *connector;
 
-#ifdef CONFIG_ACPI
-	if (acpi_video_backlight_support()) {
-		NV_INFO(drm, "ACPI backlight interface available, "
-			     "not registering our own\n");
-		return 0;
-	}
-#endif
-
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
 		if (connector->connector_type != DRM_MODE_CONNECTOR_LVDS &&
 		    connector->connector_type != DRM_MODE_CONNECTOR_eDP)

commit 5bdebb183c9702a8c57a01dff09337be3de337a6
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Oct 11 14:07:25 2013 +1000

    drm/sysfs: sort out minor and connector device object lifetimes.
    
    So drm was abusing device lifetimes, by having embedded device structures
    in the minor and connector it meant that the lifetime of the internal drm
    objects (drm_minor and drm_connector) were tied to the lifetime of the device
    files in sysfs, so if something kept those files opened the current code
    would kfree the objects and things would go downhill from there.
    
    Now in reality there is no need for these lifetimes to be so intertwined,
    especailly with hotplugging of devices where we wish to remove the sysfs
    and userspace facing pieces before we can unwind the internal objects due
    to open userspace files or mmaps, so split the objects out so the struct
    device is no longer embedded and do what fbdev does and just allocate
    and remove the sysfs inodes separately.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 2ffad2176b7f..630f6e84fc01 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -82,7 +82,7 @@ nv40_backlight_init(struct drm_connector *connector)
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
 	props.max_brightness = 31;
-	bd = backlight_device_register("nv_backlight", &connector->kdev, drm,
+	bd = backlight_device_register("nv_backlight", connector->kdev, drm,
 				       &nv40_bl_ops, &props);
 	if (IS_ERR(bd))
 		return PTR_ERR(bd);
@@ -204,7 +204,7 @@ nv50_backlight_init(struct drm_connector *connector)
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
 	props.max_brightness = 100;
-	bd = backlight_device_register("nv_backlight", &connector->kdev,
+	bd = backlight_device_register("nv_backlight", connector->kdev,
 				       nv_encoder, ops, &props);
 	if (IS_ERR(bd))
 		return PTR_ERR(bd);

commit cade2413e940763cd99e9febba873fe1899d98cb
Author: Florian Scholz <florian.scholz@stud.hn.de>
Date:   Tue Apr 2 23:16:38 2013 +0200

    drm/nouveau/drm: adding support for backlight control of GT525M (NVC0)
    
    This patch adds support for the backlight control of the NVIDIA GT
    525M, which identifies itself as a member of the NVC0 family.
    
    v2. Extended to handle Kepler too
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 5d940302d2aa..2ffad2176b7f 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -239,6 +239,9 @@ nouveau_backlight_init(struct drm_device *dev)
 		case NV_40:
 			return nv40_backlight_init(connector);
 		case NV_50:
+		case NV_C0:
+		case NV_D0:
+		case NV_E0:
 			return nv50_backlight_init(connector);
 		default:
 			break;

commit b795016cd2c6aebfa40cbccb3bad4e0325815fb4
Author: Marcin Slusarz <marcin.slusarz@gmail.com>
Date:   Sun Jan 27 17:13:52 2013 +0100

    drm/nouveau: handle backlight_device_register failure
    
    Found by smatch.
    
    Signed-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index f65b20a375f6..5d940302d2aa 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -84,6 +84,8 @@ nv40_backlight_init(struct drm_connector *connector)
 	props.max_brightness = 31;
 	bd = backlight_device_register("nv_backlight", &connector->kdev, drm,
 				       &nv40_bl_ops, &props);
+	if (IS_ERR(bd))
+		return PTR_ERR(bd);
 	drm->backlight = bd;
 	bd->props.brightness = nv40_get_intensity(bd);
 	backlight_update_status(bd);

commit 77145f1cbdf8d28b46ff8070ca749bad821e0774
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Jul 31 16:16:21 2012 +1000

    drm/nouveau: port remainder of drm code, and rip out compat layer
    
    v2: Ben Skeggs <bskeggs@redhat.com>
    - fill in nouveau_pm.dev to prevent oops
    - fix ppc issues (build + OF shadow)
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 5c4cc7a2117a..f65b20a375f6 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -71,7 +71,7 @@ static const struct backlight_ops nv40_bl_ops = {
 static int
 nv40_backlight_init(struct drm_connector *connector)
 {
-	struct nouveau_drm *drm = nouveau_newpriv(connector->dev);
+	struct nouveau_drm *drm = nouveau_drm(connector->dev);
 	struct nouveau_device *device = nv_device(drm->device);
 	struct backlight_properties props;
 	struct backlight_device *bd;
@@ -95,7 +95,7 @@ static int
 nv50_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
-	struct nouveau_drm *drm = nouveau_newpriv(nv_encoder->base.base.dev);
+	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
 	struct nouveau_device *device = nv_device(drm->device);
 	int or = nv_encoder->or;
 	u32 div = 1025;
@@ -110,7 +110,7 @@ static int
 nv50_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
-	struct nouveau_drm *drm = nouveau_newpriv(nv_encoder->base.base.dev);
+	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
 	struct nouveau_device *device = nv_device(drm->device);
 	int or = nv_encoder->or;
 	u32 div = 1025;
@@ -131,7 +131,7 @@ static int
 nva3_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
-	struct nouveau_drm *drm = nouveau_newpriv(nv_encoder->base.base.dev);
+	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
 	struct nouveau_device *device = nv_device(drm->device);
 	int or = nv_encoder->or;
 	u32 div, val;
@@ -149,7 +149,7 @@ static int
 nva3_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
-	struct nouveau_drm *drm = nouveau_newpriv(nv_encoder->base.base.dev);
+	struct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);
 	struct nouveau_device *device = nv_device(drm->device);
 	int or = nv_encoder->or;
 	u32 div, val;
@@ -175,7 +175,7 @@ static const struct backlight_ops nva3_bl_ops = {
 static int
 nv50_backlight_init(struct drm_connector *connector)
 {
-	struct nouveau_drm *drm = nouveau_newpriv(connector->dev);
+	struct nouveau_drm *drm = nouveau_drm(connector->dev);
 	struct nouveau_device *device = nv_device(drm->device);
 	struct nouveau_encoder *nv_encoder;
 	struct backlight_properties props;
@@ -216,7 +216,7 @@ nv50_backlight_init(struct drm_connector *connector)
 int
 nouveau_backlight_init(struct drm_device *dev)
 {
-	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	struct nouveau_drm *drm = nouveau_drm(dev);
 	struct nouveau_device *device = nv_device(drm->device);
 	struct drm_connector *connector;
 
@@ -250,7 +250,7 @@ nouveau_backlight_init(struct drm_device *dev)
 void
 nouveau_backlight_exit(struct drm_device *dev)
 {
-	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	struct nouveau_drm *drm = nouveau_drm(dev);
 
 	if (drm->backlight) {
 		backlight_device_unregister(drm->backlight);

commit 51a3d3425663698a79e8a9d01998a8a32ddee13b
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Jul 26 09:12:47 2012 +1000

    drm/nouveau/backlight: remove dependence on nouveau_drv.h
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index d33e94a34517..5c4cc7a2117a 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -33,18 +33,17 @@
 #include <linux/backlight.h>
 #include <linux/acpi.h>
 
-#include "drmP.h"
-#include "nouveau_drv.h"
-#include <nouveau_drm.h>
+#include "nouveau_drm.h"
 #include "nouveau_reg.h"
 #include "nouveau_encoder.h"
 
 static int
 nv40_get_intensity(struct backlight_device *bd)
 {
-	struct drm_device *dev = bl_get_data(bd);
-	int val = (nv_rd32(dev, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK)
-									>> 16;
+	struct nouveau_drm *drm = bl_get_data(bd);
+	struct nouveau_device *device = nv_device(drm->device);
+	int val = (nv_rd32(device, NV40_PMC_BACKLIGHT) &
+				   NV40_PMC_BACKLIGHT_MASK) >> 16;
 
 	return val;
 }
@@ -52,11 +51,12 @@ nv40_get_intensity(struct backlight_device *bd)
 static int
 nv40_set_intensity(struct backlight_device *bd)
 {
-	struct drm_device *dev = bl_get_data(bd);
+	struct nouveau_drm *drm = bl_get_data(bd);
+	struct nouveau_device *device = nv_device(drm->device);
 	int val = bd->props.brightness;
-	int reg = nv_rd32(dev, NV40_PMC_BACKLIGHT);
+	int reg = nv_rd32(device, NV40_PMC_BACKLIGHT);
 
-	nv_wr32(dev, NV40_PMC_BACKLIGHT,
+	nv_wr32(device, NV40_PMC_BACKLIGHT,
 		 (val << 16) | (reg & ~NV40_PMC_BACKLIGHT_MASK));
 
 	return 0;
@@ -71,23 +71,20 @@ static const struct backlight_ops nv40_bl_ops = {
 static int
 nv40_backlight_init(struct drm_connector *connector)
 {
-	struct drm_device *dev = connector->dev;
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_drm *drm = nouveau_newpriv(connector->dev);
+	struct nouveau_device *device = nv_device(drm->device);
 	struct backlight_properties props;
 	struct backlight_device *bd;
 
-	if (!(nv_rd32(dev, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK))
+	if (!(nv_rd32(device, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK))
 		return 0;
 
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
 	props.max_brightness = 31;
-	bd = backlight_device_register("nv_backlight", &connector->kdev, dev,
+	bd = backlight_device_register("nv_backlight", &connector->kdev, drm,
 				       &nv40_bl_ops, &props);
-	if (IS_ERR(bd))
-		return PTR_ERR(bd);
-
-	dev_priv->backlight = bd;
+	drm->backlight = bd;
 	bd->props.brightness = nv40_get_intensity(bd);
 	backlight_update_status(bd);
 
@@ -98,12 +95,13 @@ static int
 nv50_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
-	struct drm_device *dev = nv_encoder->base.base.dev;
+	struct nouveau_drm *drm = nouveau_newpriv(nv_encoder->base.base.dev);
+	struct nouveau_device *device = nv_device(drm->device);
 	int or = nv_encoder->or;
 	u32 div = 1025;
 	u32 val;
 
-	val  = nv_rd32(dev, NV50_PDISP_SOR_PWM_CTL(or));
+	val  = nv_rd32(device, NV50_PDISP_SOR_PWM_CTL(or));
 	val &= NV50_PDISP_SOR_PWM_CTL_VAL;
 	return ((val * 100) + (div / 2)) / div;
 }
@@ -112,13 +110,14 @@ static int
 nv50_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
-	struct drm_device *dev = nv_encoder->base.base.dev;
+	struct nouveau_drm *drm = nouveau_newpriv(nv_encoder->base.base.dev);
+	struct nouveau_device *device = nv_device(drm->device);
 	int or = nv_encoder->or;
 	u32 div = 1025;
 	u32 val = (bd->props.brightness * div) / 100;
 
-	nv_wr32(dev, NV50_PDISP_SOR_PWM_CTL(or),
-		     NV50_PDISP_SOR_PWM_CTL_NEW | val);
+	nv_wr32(device, NV50_PDISP_SOR_PWM_CTL(or),
+			NV50_PDISP_SOR_PWM_CTL_NEW | val);
 	return 0;
 }
 
@@ -132,12 +131,13 @@ static int
 nva3_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
-	struct drm_device *dev = nv_encoder->base.base.dev;
+	struct nouveau_drm *drm = nouveau_newpriv(nv_encoder->base.base.dev);
+	struct nouveau_device *device = nv_device(drm->device);
 	int or = nv_encoder->or;
 	u32 div, val;
 
-	div  = nv_rd32(dev, NV50_PDISP_SOR_PWM_DIV(or));
-	val  = nv_rd32(dev, NV50_PDISP_SOR_PWM_CTL(or));
+	div  = nv_rd32(device, NV50_PDISP_SOR_PWM_DIV(or));
+	val  = nv_rd32(device, NV50_PDISP_SOR_PWM_CTL(or));
 	val &= NVA3_PDISP_SOR_PWM_CTL_VAL;
 	if (div && div >= val)
 		return ((val * 100) + (div / 2)) / div;
@@ -149,16 +149,17 @@ static int
 nva3_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
-	struct drm_device *dev = nv_encoder->base.base.dev;
+	struct nouveau_drm *drm = nouveau_newpriv(nv_encoder->base.base.dev);
+	struct nouveau_device *device = nv_device(drm->device);
 	int or = nv_encoder->or;
 	u32 div, val;
 
-	div = nv_rd32(dev, NV50_PDISP_SOR_PWM_DIV(or));
+	div = nv_rd32(device, NV50_PDISP_SOR_PWM_DIV(or));
 	val = (bd->props.brightness * div) / 100;
 	if (div) {
-		nv_wr32(dev, NV50_PDISP_SOR_PWM_CTL(or), val |
-			     NV50_PDISP_SOR_PWM_CTL_NEW |
-			     NVA3_PDISP_SOR_PWM_CTL_UNK);
+		nv_wr32(device, NV50_PDISP_SOR_PWM_CTL(or), val |
+				NV50_PDISP_SOR_PWM_CTL_NEW |
+				NVA3_PDISP_SOR_PWM_CTL_UNK);
 		return 0;
 	}
 
@@ -174,8 +175,8 @@ static const struct backlight_ops nva3_bl_ops = {
 static int
 nv50_backlight_init(struct drm_connector *connector)
 {
-	struct drm_device *dev = connector->dev;
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_drm *drm = nouveau_newpriv(connector->dev);
+	struct nouveau_device *device = nv_device(drm->device);
 	struct nouveau_encoder *nv_encoder;
 	struct backlight_properties props;
 	struct backlight_device *bd;
@@ -188,12 +189,12 @@ nv50_backlight_init(struct drm_connector *connector)
 			return -ENODEV;
 	}
 
-	if (!nv_rd32(dev, NV50_PDISP_SOR_PWM_CTL(nv_encoder->or)))
+	if (!nv_rd32(device, NV50_PDISP_SOR_PWM_CTL(nv_encoder->or)))
 		return 0;
 
-	if (dev_priv->chipset <= 0xa0 ||
-	    dev_priv->chipset == 0xaa ||
-	    dev_priv->chipset == 0xac)
+	if (device->chipset <= 0xa0 ||
+	    device->chipset == 0xaa ||
+	    device->chipset == 0xac)
 		ops = &nv50_bl_ops;
 	else
 		ops = &nva3_bl_ops;
@@ -206,7 +207,7 @@ nv50_backlight_init(struct drm_connector *connector)
 	if (IS_ERR(bd))
 		return PTR_ERR(bd);
 
-	dev_priv->backlight = bd;
+	drm->backlight = bd;
 	bd->props.brightness = bd->ops->get_brightness(bd);
 	backlight_update_status(bd);
 	return 0;
@@ -215,12 +216,13 @@ nv50_backlight_init(struct drm_connector *connector)
 int
 nouveau_backlight_init(struct drm_device *dev)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	struct nouveau_device *device = nv_device(drm->device);
 	struct drm_connector *connector;
 
 #ifdef CONFIG_ACPI
 	if (acpi_video_backlight_support()) {
-		NV_INFO(dev, "ACPI backlight interface available, "
+		NV_INFO(drm, "ACPI backlight interface available, "
 			     "not registering our own\n");
 		return 0;
 	}
@@ -231,7 +233,7 @@ nouveau_backlight_init(struct drm_device *dev)
 		    connector->connector_type != DRM_MODE_CONNECTOR_eDP)
 			continue;
 
-		switch (dev_priv->card_type) {
+		switch (device->card_type) {
 		case NV_40:
 			return nv40_backlight_init(connector);
 		case NV_50:
@@ -248,10 +250,10 @@ nouveau_backlight_init(struct drm_device *dev)
 void
 nouveau_backlight_exit(struct drm_device *dev)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
 
-	if (dev_priv->backlight) {
-		backlight_device_unregister(dev_priv->backlight);
-		dev_priv->backlight = NULL;
+	if (drm->backlight) {
+		backlight_device_unregister(drm->backlight);
+		drm->backlight = NULL;
 	}
 }

commit cb75d97e9c77743ecfcc43375be135a55a4d9b25
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Jul 11 10:44:20 2012 +1000

    drm/nouveau: implement devinit subdev, and new init table parser
    
    v2:
    - make sure not to execute display scripts unless resuming
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 7266902a74ed..d33e94a34517 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -181,9 +181,9 @@ nv50_backlight_init(struct drm_connector *connector)
 	struct backlight_device *bd;
 	const struct backlight_ops *ops;
 
-	nv_encoder = find_encoder(connector, OUTPUT_LVDS);
+	nv_encoder = find_encoder(connector, DCB_OUTPUT_LVDS);
 	if (!nv_encoder) {
-		nv_encoder = find_encoder(connector, OUTPUT_DP);
+		nv_encoder = find_encoder(connector, DCB_OUTPUT_DP);
 		if (!nv_encoder)
 			return -ENODEV;
 	}

commit 9458029940ffc64bca0c5a30ea626c377205842e
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Jul 6 12:14:00 2012 +1000

    drm/nouveau: implement module init functions in nouveau_drm.c
    
    These currently just call the existing ones in nouveau_drv.c, but will be
    extended in upcoming commits.  This needed to be separated from the current
    code as there will be some header clashes until things are ported.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index fa22b28e8777..7266902a74ed 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -35,7 +35,7 @@
 
 #include "drmP.h"
 #include "nouveau_drv.h"
-#include "nouveau_drm.h"
+#include <nouveau_drm.h>
 #include "nouveau_reg.h"
 #include "nouveau_encoder.h"
 

commit 5024c54b5cc6e93a8e2713f53981423d0deb60d7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Wed Aug 3 08:52:39 2011 +1000

    drm/nva3/backlight: add suppport for newer style backlight regs
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 757a6f87edf2..fa22b28e8777 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -103,7 +103,8 @@ nv50_get_intensity(struct backlight_device *bd)
 	u32 div = 1025;
 	u32 val;
 
-	val = nv_rd32(dev, NV50_PDISPLAY_SOR_BACKLIGHT + (or * 0x800));
+	val  = nv_rd32(dev, NV50_PDISP_SOR_PWM_CTL(or));
+	val &= NV50_PDISP_SOR_PWM_CTL_VAL;
 	return ((val * 100) + (div / 2)) / div;
 }
 
@@ -116,8 +117,8 @@ nv50_set_intensity(struct backlight_device *bd)
 	u32 div = 1025;
 	u32 val = (bd->props.brightness * div) / 100;
 
-	nv_wr32(dev, NV50_PDISPLAY_SOR_BACKLIGHT + (or * 0x800),
-		val | NV50_PDISPLAY_SOR_BACKLIGHT_ENABLE);
+	nv_wr32(dev, NV50_PDISP_SOR_PWM_CTL(or),
+		     NV50_PDISP_SOR_PWM_CTL_NEW | val);
 	return 0;
 }
 
@@ -127,6 +128,49 @@ static const struct backlight_ops nv50_bl_ops = {
 	.update_status = nv50_set_intensity,
 };
 
+static int
+nva3_get_intensity(struct backlight_device *bd)
+{
+	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
+	struct drm_device *dev = nv_encoder->base.base.dev;
+	int or = nv_encoder->or;
+	u32 div, val;
+
+	div  = nv_rd32(dev, NV50_PDISP_SOR_PWM_DIV(or));
+	val  = nv_rd32(dev, NV50_PDISP_SOR_PWM_CTL(or));
+	val &= NVA3_PDISP_SOR_PWM_CTL_VAL;
+	if (div && div >= val)
+		return ((val * 100) + (div / 2)) / div;
+
+	return 100;
+}
+
+static int
+nva3_set_intensity(struct backlight_device *bd)
+{
+	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
+	struct drm_device *dev = nv_encoder->base.base.dev;
+	int or = nv_encoder->or;
+	u32 div, val;
+
+	div = nv_rd32(dev, NV50_PDISP_SOR_PWM_DIV(or));
+	val = (bd->props.brightness * div) / 100;
+	if (div) {
+		nv_wr32(dev, NV50_PDISP_SOR_PWM_CTL(or), val |
+			     NV50_PDISP_SOR_PWM_CTL_NEW |
+			     NVA3_PDISP_SOR_PWM_CTL_UNK);
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static const struct backlight_ops nva3_bl_ops = {
+	.options = BL_CORE_SUSPENDRESUME,
+	.get_brightness = nva3_get_intensity,
+	.update_status = nva3_set_intensity,
+};
+
 static int
 nv50_backlight_init(struct drm_connector *connector)
 {
@@ -135,7 +179,7 @@ nv50_backlight_init(struct drm_connector *connector)
 	struct nouveau_encoder *nv_encoder;
 	struct backlight_properties props;
 	struct backlight_device *bd;
-	int or;
+	const struct backlight_ops *ops;
 
 	nv_encoder = find_encoder(connector, OUTPUT_LVDS);
 	if (!nv_encoder) {
@@ -144,21 +188,26 @@ nv50_backlight_init(struct drm_connector *connector)
 			return -ENODEV;
 	}
 
-	or = nv_encoder->or;
-
-	if (!nv_rd32(dev, NV50_PDISPLAY_SOR_BACKLIGHT + (or * 0x800)))
+	if (!nv_rd32(dev, NV50_PDISP_SOR_PWM_CTL(nv_encoder->or)))
 		return 0;
 
+	if (dev_priv->chipset <= 0xa0 ||
+	    dev_priv->chipset == 0xaa ||
+	    dev_priv->chipset == 0xac)
+		ops = &nv50_bl_ops;
+	else
+		ops = &nva3_bl_ops;
+
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
 	props.max_brightness = 100;
 	bd = backlight_device_register("nv_backlight", &connector->kdev,
-				       nv_encoder, &nv50_bl_ops, &props);
+				       nv_encoder, ops, &props);
 	if (IS_ERR(bd))
 		return PTR_ERR(bd);
 
 	dev_priv->backlight = bd;
-	bd->props.brightness = nv50_get_intensity(bd);
+	bd->props.brightness = bd->ops->get_brightness(bd);
 	backlight_update_status(bd);
 	return 0;
 }

commit 09461459e12019375dbda88f81d1fe8926ce139c
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Aug 2 20:45:35 2011 +1000

    drm/nv50/backlight: express brightness level in percent
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 4f3d1ff3e472..757a6f87edf2 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -100,8 +100,11 @@ nv50_get_intensity(struct backlight_device *bd)
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct drm_device *dev = nv_encoder->base.base.dev;
 	int or = nv_encoder->or;
+	u32 div = 1025;
+	u32 val;
 
-	return nv_rd32(dev, NV50_PDISPLAY_SOR_BACKLIGHT + (or * 0x800));
+	val = nv_rd32(dev, NV50_PDISPLAY_SOR_BACKLIGHT + (or * 0x800));
+	return ((val * 100) + (div / 2)) / div;
 }
 
 static int
@@ -109,8 +112,9 @@ nv50_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
 	struct drm_device *dev = nv_encoder->base.base.dev;
-	int val = bd->props.brightness;
 	int or = nv_encoder->or;
+	u32 div = 1025;
+	u32 val = (bd->props.brightness * div) / 100;
 
 	nv_wr32(dev, NV50_PDISPLAY_SOR_BACKLIGHT + (or * 0x800),
 		val | NV50_PDISPLAY_SOR_BACKLIGHT_ENABLE);
@@ -147,7 +151,7 @@ nv50_backlight_init(struct drm_connector *connector)
 
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
-	props.max_brightness = 1025;
+	props.max_brightness = 100;
 	bd = backlight_device_register("nv_backlight", &connector->kdev,
 				       nv_encoder, &nv50_bl_ops, &props);
 	if (IS_ERR(bd))

commit 10b461e40a5a5522fe996805a0625c9cd4e5c1a7
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Aug 2 19:29:37 2011 +1000

    drm/nv50/backlight: take the sor into account when bashing regs
    
    I'm sure that out there somewhere, someone will need this.  We currently
    haven't seen an example of LVDS being on a non-0 SOR so far though.
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index d412adc67403..4f3d1ff3e472 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -37,6 +37,7 @@
 #include "nouveau_drv.h"
 #include "nouveau_drm.h"
 #include "nouveau_reg.h"
+#include "nouveau_encoder.h"
 
 static int
 nv40_get_intensity(struct backlight_device *bd)
@@ -96,18 +97,22 @@ nv40_backlight_init(struct drm_connector *connector)
 static int
 nv50_get_intensity(struct backlight_device *bd)
 {
-	struct drm_device *dev = bl_get_data(bd);
+	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
+	struct drm_device *dev = nv_encoder->base.base.dev;
+	int or = nv_encoder->or;
 
-	return nv_rd32(dev, NV50_PDISPLAY_SOR_BACKLIGHT);
+	return nv_rd32(dev, NV50_PDISPLAY_SOR_BACKLIGHT + (or * 0x800));
 }
 
 static int
 nv50_set_intensity(struct backlight_device *bd)
 {
-	struct drm_device *dev = bl_get_data(bd);
+	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
+	struct drm_device *dev = nv_encoder->base.base.dev;
 	int val = bd->props.brightness;
+	int or = nv_encoder->or;
 
-	nv_wr32(dev, NV50_PDISPLAY_SOR_BACKLIGHT,
+	nv_wr32(dev, NV50_PDISPLAY_SOR_BACKLIGHT + (or * 0x800),
 		val | NV50_PDISPLAY_SOR_BACKLIGHT_ENABLE);
 	return 0;
 }
@@ -123,17 +128,28 @@ nv50_backlight_init(struct drm_connector *connector)
 {
 	struct drm_device *dev = connector->dev;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_encoder *nv_encoder;
 	struct backlight_properties props;
 	struct backlight_device *bd;
+	int or;
+
+	nv_encoder = find_encoder(connector, OUTPUT_LVDS);
+	if (!nv_encoder) {
+		nv_encoder = find_encoder(connector, OUTPUT_DP);
+		if (!nv_encoder)
+			return -ENODEV;
+	}
+
+	or = nv_encoder->or;
 
-	if (!nv_rd32(dev, NV50_PDISPLAY_SOR_BACKLIGHT))
+	if (!nv_rd32(dev, NV50_PDISPLAY_SOR_BACKLIGHT + (or * 0x800)))
 		return 0;
 
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
 	props.max_brightness = 1025;
-	bd = backlight_device_register("nv_backlight", &connector->kdev, dev,
-				       &nv50_bl_ops, &props);
+	bd = backlight_device_register("nv_backlight", &connector->kdev,
+				       nv_encoder, &nv50_bl_ops, &props);
 	if (IS_ERR(bd))
 		return PTR_ERR(bd);
 
@@ -144,10 +160,10 @@ nv50_backlight_init(struct drm_connector *connector)
 }
 
 int
-nouveau_backlight_init(struct drm_connector *connector)
+nouveau_backlight_init(struct drm_device *dev)
 {
-	struct drm_device *dev = connector->dev;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct drm_connector *connector;
 
 #ifdef CONFIG_ACPI
 	if (acpi_video_backlight_support()) {
@@ -157,22 +173,28 @@ nouveau_backlight_init(struct drm_connector *connector)
 	}
 #endif
 
-	switch (dev_priv->card_type) {
-	case NV_40:
-		return nv40_backlight_init(connector);
-	case NV_50:
-		return nv50_backlight_init(connector);
-	default:
-		break;
+	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+		if (connector->connector_type != DRM_MODE_CONNECTOR_LVDS &&
+		    connector->connector_type != DRM_MODE_CONNECTOR_eDP)
+			continue;
+
+		switch (dev_priv->card_type) {
+		case NV_40:
+			return nv40_backlight_init(connector);
+		case NV_50:
+			return nv50_backlight_init(connector);
+		default:
+			break;
+		}
 	}
 
+
 	return 0;
 }
 
 void
-nouveau_backlight_exit(struct drm_connector *connector)
+nouveau_backlight_exit(struct drm_device *dev)
 {
-	struct drm_device *dev = connector->dev;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 
 	if (dev_priv->backlight) {

commit 730764812ded8b53643670131219b3abbdab52c8
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Tue Aug 2 18:54:43 2011 +1000

    drm/nouveau/backlight: make more consistent with rest of driver style
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 00a55dfdba82..d412adc67403 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -38,7 +38,8 @@
 #include "nouveau_drm.h"
 #include "nouveau_reg.h"
 
-static int nv40_get_intensity(struct backlight_device *bd)
+static int
+nv40_get_intensity(struct backlight_device *bd)
 {
 	struct drm_device *dev = bl_get_data(bd);
 	int val = (nv_rd32(dev, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK)
@@ -47,7 +48,8 @@ static int nv40_get_intensity(struct backlight_device *bd)
 	return val;
 }
 
-static int nv40_set_intensity(struct backlight_device *bd)
+static int
+nv40_set_intensity(struct backlight_device *bd)
 {
 	struct drm_device *dev = bl_get_data(bd);
 	int val = bd->props.brightness;
@@ -65,30 +67,8 @@ static const struct backlight_ops nv40_bl_ops = {
 	.update_status = nv40_set_intensity,
 };
 
-static int nv50_get_intensity(struct backlight_device *bd)
-{
-	struct drm_device *dev = bl_get_data(bd);
-
-	return nv_rd32(dev, NV50_PDISPLAY_SOR_BACKLIGHT);
-}
-
-static int nv50_set_intensity(struct backlight_device *bd)
-{
-	struct drm_device *dev = bl_get_data(bd);
-	int val = bd->props.brightness;
-
-	nv_wr32(dev, NV50_PDISPLAY_SOR_BACKLIGHT,
-		val | NV50_PDISPLAY_SOR_BACKLIGHT_ENABLE);
-	return 0;
-}
-
-static const struct backlight_ops nv50_bl_ops = {
-	.options = BL_CORE_SUSPENDRESUME,
-	.get_brightness = nv50_get_intensity,
-	.update_status = nv50_set_intensity,
-};
-
-static int nouveau_nv40_backlight_init(struct drm_connector *connector)
+static int
+nv40_backlight_init(struct drm_connector *connector)
 {
 	struct drm_device *dev = connector->dev;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
@@ -113,7 +93,33 @@ static int nouveau_nv40_backlight_init(struct drm_connector *connector)
 	return 0;
 }
 
-static int nouveau_nv50_backlight_init(struct drm_connector *connector)
+static int
+nv50_get_intensity(struct backlight_device *bd)
+{
+	struct drm_device *dev = bl_get_data(bd);
+
+	return nv_rd32(dev, NV50_PDISPLAY_SOR_BACKLIGHT);
+}
+
+static int
+nv50_set_intensity(struct backlight_device *bd)
+{
+	struct drm_device *dev = bl_get_data(bd);
+	int val = bd->props.brightness;
+
+	nv_wr32(dev, NV50_PDISPLAY_SOR_BACKLIGHT,
+		val | NV50_PDISPLAY_SOR_BACKLIGHT_ENABLE);
+	return 0;
+}
+
+static const struct backlight_ops nv50_bl_ops = {
+	.options = BL_CORE_SUSPENDRESUME,
+	.get_brightness = nv50_get_intensity,
+	.update_status = nv50_set_intensity,
+};
+
+static int
+nv50_backlight_init(struct drm_connector *connector)
 {
 	struct drm_device *dev = connector->dev;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
@@ -137,7 +143,8 @@ static int nouveau_nv50_backlight_init(struct drm_connector *connector)
 	return 0;
 }
 
-int nouveau_backlight_init(struct drm_connector *connector)
+int
+nouveau_backlight_init(struct drm_connector *connector)
 {
 	struct drm_device *dev = connector->dev;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
@@ -152,9 +159,9 @@ int nouveau_backlight_init(struct drm_connector *connector)
 
 	switch (dev_priv->card_type) {
 	case NV_40:
-		return nouveau_nv40_backlight_init(connector);
+		return nv40_backlight_init(connector);
 	case NV_50:
-		return nouveau_nv50_backlight_init(connector);
+		return nv50_backlight_init(connector);
 	default:
 		break;
 	}
@@ -162,7 +169,8 @@ int nouveau_backlight_init(struct drm_connector *connector)
 	return 0;
 }
 
-void nouveau_backlight_exit(struct drm_connector *connector)
+void
+nouveau_backlight_exit(struct drm_connector *connector)
 {
 	struct drm_device *dev = connector->dev;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;

commit 7eae3efa13c5d1c8e7d8dd0504ad524963b8add1
Author: Matthew Garrett <mjg@redhat.com>
Date:   Tue Mar 22 16:30:24 2011 -0700

    nouveau: change the backlight parent device to the connector, not the PCI dev
    
    We may eventually end up with per-connector backlights, especially with
    ddcci devices.  Make sure that the parent node for the backlight device is
    the connector rather than the PCI device.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Alex Deucher <alexdeucher@gmail.com>
    Acked-by: Ben Skeggs <bskeggs@redhat.com>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Tested-by: Sedat Dilek <sedat.dilek@googlemail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 18d7bcc54ce0..00a55dfdba82 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -88,10 +88,11 @@ static const struct backlight_ops nv50_bl_ops = {
 	.update_status = nv50_set_intensity,
 };
 
-static int nouveau_nv40_backlight_init(struct drm_device *dev)
+static int nouveau_nv40_backlight_init(struct drm_connector *connector)
 {
-	struct backlight_properties props;
+	struct drm_device *dev = connector->dev;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct backlight_properties props;
 	struct backlight_device *bd;
 
 	if (!(nv_rd32(dev, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK))
@@ -100,7 +101,7 @@ static int nouveau_nv40_backlight_init(struct drm_device *dev)
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
 	props.max_brightness = 31;
-	bd = backlight_device_register("nv_backlight", &dev->pdev->dev, dev,
+	bd = backlight_device_register("nv_backlight", &connector->kdev, dev,
 				       &nv40_bl_ops, &props);
 	if (IS_ERR(bd))
 		return PTR_ERR(bd);
@@ -112,10 +113,11 @@ static int nouveau_nv40_backlight_init(struct drm_device *dev)
 	return 0;
 }
 
-static int nouveau_nv50_backlight_init(struct drm_device *dev)
+static int nouveau_nv50_backlight_init(struct drm_connector *connector)
 {
-	struct backlight_properties props;
+	struct drm_device *dev = connector->dev;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct backlight_properties props;
 	struct backlight_device *bd;
 
 	if (!nv_rd32(dev, NV50_PDISPLAY_SOR_BACKLIGHT))
@@ -124,7 +126,7 @@ static int nouveau_nv50_backlight_init(struct drm_device *dev)
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
 	props.max_brightness = 1025;
-	bd = backlight_device_register("nv_backlight", &dev->pdev->dev, dev,
+	bd = backlight_device_register("nv_backlight", &connector->kdev, dev,
 				       &nv50_bl_ops, &props);
 	if (IS_ERR(bd))
 		return PTR_ERR(bd);
@@ -135,8 +137,9 @@ static int nouveau_nv50_backlight_init(struct drm_device *dev)
 	return 0;
 }
 
-int nouveau_backlight_init(struct drm_device *dev)
+int nouveau_backlight_init(struct drm_connector *connector)
 {
+	struct drm_device *dev = connector->dev;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 
 #ifdef CONFIG_ACPI
@@ -149,9 +152,9 @@ int nouveau_backlight_init(struct drm_device *dev)
 
 	switch (dev_priv->card_type) {
 	case NV_40:
-		return nouveau_nv40_backlight_init(dev);
+		return nouveau_nv40_backlight_init(connector);
 	case NV_50:
-		return nouveau_nv50_backlight_init(dev);
+		return nouveau_nv50_backlight_init(connector);
 	default:
 		break;
 	}
@@ -159,8 +162,9 @@ int nouveau_backlight_init(struct drm_device *dev)
 	return 0;
 }
 
-void nouveau_backlight_exit(struct drm_device *dev)
+void nouveau_backlight_exit(struct drm_connector *connector)
 {
+	struct drm_device *dev = connector->dev;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 
 	if (dev_priv->backlight) {

commit bb7ca747f8d6243b3943c5b133048652020f4a50
Author: Matthew Garrett <mjg@redhat.com>
Date:   Tue Mar 22 16:30:21 2011 -0700

    backlight: add backlight type
    
    There may be multiple ways of controlling the backlight on a given
    machine.  Allow drivers to expose the type of interface they are
    providing, making it possible for userspace to make appropriate policy
    decisions.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Alex Deucher <alexdeucher@gmail.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index d3a9c6e02477..18d7bcc54ce0 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -98,6 +98,7 @@ static int nouveau_nv40_backlight_init(struct drm_device *dev)
 		return 0;
 
 	memset(&props, 0, sizeof(struct backlight_properties));
+	props.type = BACKLIGHT_RAW;
 	props.max_brightness = 31;
 	bd = backlight_device_register("nv_backlight", &dev->pdev->dev, dev,
 				       &nv40_bl_ops, &props);
@@ -121,6 +122,7 @@ static int nouveau_nv50_backlight_init(struct drm_device *dev)
 		return 0;
 
 	memset(&props, 0, sizeof(struct backlight_properties));
+	props.type = BACKLIGHT_RAW;
 	props.max_brightness = 1025;
 	bd = backlight_device_register("nv_backlight", &dev->pdev->dev, dev,
 				       &nv50_bl_ops, &props);

commit 4b7bd364700d9ac8372eff48832062b936d0793b
Merge: c0d8768af260 90a8a73c06cc
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Dec 22 18:57:02 2010 +0100

    Merge branch 'master' into for-next
    
    Conflicts:
            MAINTAINERS
            arch/arm/mach-omap2/pm24xx.c
            drivers/scsi/bfa/bfa_fcpim.c
    
    Needed to update to apply fixes for which the old branch was too
    outdated.

commit 5bead799d3f8f1500c4b59301b8a2732a92f559f
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Nov 4 09:56:12 2010 +1000

    drm/nouveau: don't expose backlight control when available through ACPI
    
    Avoid confusing userspace by not publishing backlight controls if ACPI
    equivalents are available.
    
    Reported-by: Aaron Sowry <aaron@aeneby.se>
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 406228f4a2a0..b14c81110575 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -31,6 +31,7 @@
  */
 
 #include <linux/backlight.h>
+#include <linux/acpi.h>
 
 #include "drmP.h"
 #include "nouveau_drv.h"
@@ -136,6 +137,14 @@ int nouveau_backlight_init(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 
+#ifdef CONFIG_ACPI
+	if (acpi_video_backlight_support()) {
+		NV_INFO(dev, "ACPI backlight interface available, "
+			     "not registering our own\n");
+		return 0;
+	}
+#endif
+
 	switch (dev_priv->card_type) {
 	case NV_40:
 		return nouveau_nv40_backlight_init(dev);

commit acc2472ed33fc5e72482cc3b3b846077d97c2f8b
Author: Lionel Debroux <lionel_debroux@yahoo.fr>
Date:   Tue Nov 16 14:14:02 2010 +0100

    backlight: constify backlight_ops
    
    backlight_device_register has been expecting a const "ops" argument, and using
    it as such, since 9905a43b2d563e6f89e4c63c4278ada03f2ebb14. Let's make the
    remaining backlight_ops instances const.
    
    Inspired by hunks of the grsecurity patch, updated for newer kernels.
    
    Signed-off-by: Lionel Debroux <lionel_debroux@yahoo.fr>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 406228f4a2a0..8933e985c227 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -58,7 +58,7 @@ static int nv40_set_intensity(struct backlight_device *bd)
 	return 0;
 }
 
-static struct backlight_ops nv40_bl_ops = {
+static const struct backlight_ops nv40_bl_ops = {
 	.options = BL_CORE_SUSPENDRESUME,
 	.get_brightness = nv40_get_intensity,
 	.update_status = nv40_set_intensity,
@@ -81,7 +81,7 @@ static int nv50_set_intensity(struct backlight_device *bd)
 	return 0;
 }
 
-static struct backlight_ops nv50_bl_ops = {
+static const struct backlight_ops nv50_bl_ops = {
 	.options = BL_CORE_SUSPENDRESUME,
 	.get_brightness = nv50_get_intensity,
 	.update_status = nv50_set_intensity,

commit a19a6ee6cad2b20292a774c2f56ba8039b0fac9c
Author: Matthew Garrett <mjg@redhat.com>
Date:   Wed Feb 17 16:39:44 2010 -0500

    backlight: Allow properties to be passed at registration
    
    Values such as max_brightness should be set before backlights are
    registered, but the current API doesn't allow that. Add a parameter to
    backlight_device_register and update drivers to ensure that they
    set this correctly.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
index 20564f8cb0ec..406228f4a2a0 100644
--- a/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -89,19 +89,21 @@ static struct backlight_ops nv50_bl_ops = {
 
 static int nouveau_nv40_backlight_init(struct drm_device *dev)
 {
+	struct backlight_properties props;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct backlight_device *bd;
 
 	if (!(nv_rd32(dev, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK))
 		return 0;
 
+	memset(&props, 0, sizeof(struct backlight_properties));
+	props.max_brightness = 31;
 	bd = backlight_device_register("nv_backlight", &dev->pdev->dev, dev,
-				       &nv40_bl_ops);
+				       &nv40_bl_ops, &props);
 	if (IS_ERR(bd))
 		return PTR_ERR(bd);
 
 	dev_priv->backlight = bd;
-	bd->props.max_brightness = 31;
 	bd->props.brightness = nv40_get_intensity(bd);
 	backlight_update_status(bd);
 
@@ -110,19 +112,21 @@ static int nouveau_nv40_backlight_init(struct drm_device *dev)
 
 static int nouveau_nv50_backlight_init(struct drm_device *dev)
 {
+	struct backlight_properties props;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct backlight_device *bd;
 
 	if (!nv_rd32(dev, NV50_PDISPLAY_SOR_BACKLIGHT))
 		return 0;
 
+	memset(&props, 0, sizeof(struct backlight_properties));
+	props.max_brightness = 1025;
 	bd = backlight_device_register("nv_backlight", &dev->pdev->dev, dev,
-				       &nv50_bl_ops);
+				       &nv50_bl_ops, &props);
 	if (IS_ERR(bd))
 		return PTR_ERR(bd);
 
 	dev_priv->backlight = bd;
-	bd->props.max_brightness = 1025;
 	bd->props.brightness = nv50_get_intensity(bd);
 	backlight_update_status(bd);
 	return 0;

commit 6ee738610f41b59733f63718f0bdbcba7d3a3f12
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Fri Dec 11 19:24:15 2009 +1000

    drm/nouveau: Add DRM driver for NVIDIA GPUs
    
    This adds a drm/kms staging non-API stable driver for GPUs from NVIDIA.
    
    This driver is a KMS-based driver and requires a compatible nouveau
    userspace libdrm and nouveau X.org driver.
    
    This driver requires firmware files not available in this kernel tree,
    interested parties can find them via the nouveau project git archive.
    
    This driver is reverse engineered, and is in no way supported by nVidia.
    
    Support for nearly the complete range of nvidia hw from nv04->g80 (nv50)
    is available, and the kms driver should support driving nearly all
    output types (displayport is under development still) along with supporting
    suspend/resume.
    
    This work is all from the upstream nouveau project found at
    nouveau.freedesktop.org.
    
    The original authors list from nouveau git tree is:
    Anssi Hannula <anssi.hannula@iki.fi>
    Ben Skeggs <bskeggs@redhat.com>
    Francisco Jerez <currojerez@riseup.net>
    Maarten Maathuis <madman2003@gmail.com>
    Marcin Kościelnicki <koriakin@0x04.net>
    Matthew Garrett <mjg@redhat.com>
    Matt Parnell <mparnell@gmail.com>
    Patrice Mandin <patmandin@gmail.com>
    Pekka Paalanen <pq@iki.fi>
    Xavier Chantry <shiningxc@gmail.com>
    along with project founder Stephane Marchesin <marchesin@icps.u-strasbg.fr>
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nouveau_backlight.c b/drivers/gpu/drm/nouveau/nouveau_backlight.c
new file mode 100644
index 000000000000..20564f8cb0ec
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2009 Red Hat <mjg@redhat.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/*
+ * Authors:
+ *  Matthew Garrett <mjg@redhat.com>
+ *
+ * Register locations derived from NVClock by Roderick Colenbrander
+ */
+
+#include <linux/backlight.h>
+
+#include "drmP.h"
+#include "nouveau_drv.h"
+#include "nouveau_drm.h"
+#include "nouveau_reg.h"
+
+static int nv40_get_intensity(struct backlight_device *bd)
+{
+	struct drm_device *dev = bl_get_data(bd);
+	int val = (nv_rd32(dev, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK)
+									>> 16;
+
+	return val;
+}
+
+static int nv40_set_intensity(struct backlight_device *bd)
+{
+	struct drm_device *dev = bl_get_data(bd);
+	int val = bd->props.brightness;
+	int reg = nv_rd32(dev, NV40_PMC_BACKLIGHT);
+
+	nv_wr32(dev, NV40_PMC_BACKLIGHT,
+		 (val << 16) | (reg & ~NV40_PMC_BACKLIGHT_MASK));
+
+	return 0;
+}
+
+static struct backlight_ops nv40_bl_ops = {
+	.options = BL_CORE_SUSPENDRESUME,
+	.get_brightness = nv40_get_intensity,
+	.update_status = nv40_set_intensity,
+};
+
+static int nv50_get_intensity(struct backlight_device *bd)
+{
+	struct drm_device *dev = bl_get_data(bd);
+
+	return nv_rd32(dev, NV50_PDISPLAY_SOR_BACKLIGHT);
+}
+
+static int nv50_set_intensity(struct backlight_device *bd)
+{
+	struct drm_device *dev = bl_get_data(bd);
+	int val = bd->props.brightness;
+
+	nv_wr32(dev, NV50_PDISPLAY_SOR_BACKLIGHT,
+		val | NV50_PDISPLAY_SOR_BACKLIGHT_ENABLE);
+	return 0;
+}
+
+static struct backlight_ops nv50_bl_ops = {
+	.options = BL_CORE_SUSPENDRESUME,
+	.get_brightness = nv50_get_intensity,
+	.update_status = nv50_set_intensity,
+};
+
+static int nouveau_nv40_backlight_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct backlight_device *bd;
+
+	if (!(nv_rd32(dev, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK))
+		return 0;
+
+	bd = backlight_device_register("nv_backlight", &dev->pdev->dev, dev,
+				       &nv40_bl_ops);
+	if (IS_ERR(bd))
+		return PTR_ERR(bd);
+
+	dev_priv->backlight = bd;
+	bd->props.max_brightness = 31;
+	bd->props.brightness = nv40_get_intensity(bd);
+	backlight_update_status(bd);
+
+	return 0;
+}
+
+static int nouveau_nv50_backlight_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct backlight_device *bd;
+
+	if (!nv_rd32(dev, NV50_PDISPLAY_SOR_BACKLIGHT))
+		return 0;
+
+	bd = backlight_device_register("nv_backlight", &dev->pdev->dev, dev,
+				       &nv50_bl_ops);
+	if (IS_ERR(bd))
+		return PTR_ERR(bd);
+
+	dev_priv->backlight = bd;
+	bd->props.max_brightness = 1025;
+	bd->props.brightness = nv50_get_intensity(bd);
+	backlight_update_status(bd);
+	return 0;
+}
+
+int nouveau_backlight_init(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	switch (dev_priv->card_type) {
+	case NV_40:
+		return nouveau_nv40_backlight_init(dev);
+	case NV_50:
+		return nouveau_nv50_backlight_init(dev);
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+void nouveau_backlight_exit(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+
+	if (dev_priv->backlight) {
+		backlight_device_unregister(dev_priv->backlight);
+		dev_priv->backlight = NULL;
+	}
+}
