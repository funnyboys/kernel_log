commit 02bb1317d5e4002e65a3debfb27ae2a1bfd0a3c2
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Apr 15 09:39:59 2020 +0200

    drm/tidss: Don't use drm_device->dev_private
    
    Upcasting using a container_of macro is more typesafe, faster and
    easier for the compiler to optimize.
    
    Tested-by: Jyri Sarha <jsarha@ti.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200415074034.175360-25-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/tidss/tidss_drv.c b/drivers/gpu/drm/tidss/tidss_drv.c
index 7d4465d58be8..99edc66ebdef 100644
--- a/drivers/gpu/drm/tidss/tidss_drv.c
+++ b/drivers/gpu/drm/tidss/tidss_drv.c
@@ -147,8 +147,6 @@ static int tidss_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, tidss);
 
-	ddev->dev_private = tidss;
-
 	ret = dispc_init(tidss);
 	if (ret) {
 		dev_err(dev, "failed to initialize dispc: %d\n", ret);

commit b3b134007e2c795f78bb34bc92ee68608cb92b04
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Apr 15 09:39:58 2020 +0200

    drm/tidss: Use devm_drm_dev_alloc
    
    Already using devm_drm_dev_init, so very simple replacment.
    
    Tested-by: Jyri Sarha <jsarha@ti.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200415074034.175360-24-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/tidss/tidss_drv.c b/drivers/gpu/drm/tidss/tidss_drv.c
index ad449d104306..7d4465d58be8 100644
--- a/drivers/gpu/drm/tidss/tidss_drv.c
+++ b/drivers/gpu/drm/tidss/tidss_drv.c
@@ -135,20 +135,13 @@ static int tidss_probe(struct platform_device *pdev)
 
 	dev_dbg(dev, "%s\n", __func__);
 
-	/* Can't use devm_* since drm_device's lifetime may exceed dev's */
-	tidss = kzalloc(sizeof(*tidss), GFP_KERNEL);
-	if (!tidss)
-		return -ENOMEM;
+	tidss = devm_drm_dev_alloc(&pdev->dev, &tidss_driver,
+				   struct tidss_device, ddev);
+	if (IS_ERR(tidss))
+		return PTR_ERR(tidss);
 
 	ddev = &tidss->ddev;
 
-	ret = devm_drm_dev_init(&pdev->dev, ddev, &tidss_driver);
-	if (ret) {
-		kfree(ddev);
-		return ret;
-	}
-	drmm_add_final_kfree(ddev, tidss);
-
 	tidss->dev = dev;
 	tidss->feat = of_device_get_match_data(dev);
 

commit c792098baf22714b7023cea15acf8432d1ee08e1
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Mar 23 15:49:40 2020 +0100

    drm/tidss: Drop explicit drm_mode_config_cleanup call
    
    It's right above the drm_dev_put().
    
    This is made possible by a preceeding patch which added a drmm_
    cleanup action to drm_mode_config_init(), hence all we need to do to
    ensure that drm_mode_config_cleanup() is run on final drm_device
    cleanup is check the new error code for _init().
    
    Aside: Another driver with a bit much devm_kzalloc, which should
    probably use drmm_kzalloc instead ...
    
    I'm pretty sure this one blows up already under KASAN because it's
    using devm_drm_dev_init, and later on devm_kzalloc. Hence the memory
    will get freed before the final drm_dev_put (all from the devres
    code), but the cleanup in that final drm_dev_put will access the just
    freed memory.
    
    Unfortunately fixing this properly needs slightly more work, namely
    drmm_ versions for all the drm objects (planes, crtc, ...), so that
    the cleanup actually happens before even drmm_kzalloc would release
    the underlying memory. Not quite there yet.
    
    v2: Explain why this cleanup is possible (Laurent).
    
    v3: Use drmm_mode_config_init() for more clarity (Sam, Thomas)
    
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Thomas Zimmermann <tzimmermann@suse.de>
    Acked-by: Jyri Sarha <jsarha@ti.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200323144950.3018436-42-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/tidss/tidss_drv.c b/drivers/gpu/drm/tidss/tidss_drv.c
index 460d5e9d0cf4..ad449d104306 100644
--- a/drivers/gpu/drm/tidss/tidss_drv.c
+++ b/drivers/gpu/drm/tidss/tidss_drv.c
@@ -103,11 +103,7 @@ static const struct dev_pm_ops tidss_pm_ops = {
 
 static void tidss_release(struct drm_device *ddev)
 {
-	struct tidss_device *tidss = ddev->dev_private;
-
 	drm_kms_helper_poll_fini(ddev);
-
-	tidss_modeset_cleanup(tidss);
 }
 
 DEFINE_DRM_GEM_CMA_FOPS(tidss_fops);

commit d33b58d0115e7eee011fddee2d8e25c6a09fb279
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Mar 23 15:49:24 2020 +0100

    drm: Garbage collect drm_dev_fini
    
    It has become empty. Given the few users I figured not much point
    splitting this up.
    
    v2: Rebase over i915 changes.
    
    v3: Rebase over patch split fix.
    
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200323144950.3018436-26-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/tidss/tidss_drv.c b/drivers/gpu/drm/tidss/tidss_drv.c
index 32a85628dbec..460d5e9d0cf4 100644
--- a/drivers/gpu/drm/tidss/tidss_drv.c
+++ b/drivers/gpu/drm/tidss/tidss_drv.c
@@ -108,8 +108,6 @@ static void tidss_release(struct drm_device *ddev)
 	drm_kms_helper_poll_fini(ddev);
 
 	tidss_modeset_cleanup(tidss);
-
-	drm_dev_fini(ddev);
 }
 
 DEFINE_DRM_GEM_CMA_FOPS(tidss_fops);

commit afeeabb88babf22647f3483a2f428f70be93e289
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Mar 23 15:49:10 2020 +0100

    drm/tidss: Use drmm_add_final_kfree
    
    With this we can drop the final kfree from the release function.
    
    Acked-by: Jyri Sarha <jsarha@ti.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Jyri Sarha <jsarha@ti.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200323144950.3018436-12-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/tidss/tidss_drv.c b/drivers/gpu/drm/tidss/tidss_drv.c
index d95e4be2c7b9..32a85628dbec 100644
--- a/drivers/gpu/drm/tidss/tidss_drv.c
+++ b/drivers/gpu/drm/tidss/tidss_drv.c
@@ -17,6 +17,7 @@
 #include <drm/drm_fb_helper.h>
 #include <drm/drm_gem_cma_helper.h>
 #include <drm/drm_irq.h>
+#include <drm/drm_managed.h>
 #include <drm/drm_probe_helper.h>
 
 #include "tidss_dispc.h"
@@ -109,8 +110,6 @@ static void tidss_release(struct drm_device *ddev)
 	tidss_modeset_cleanup(tidss);
 
 	drm_dev_fini(ddev);
-
-	kfree(tidss);
 }
 
 DEFINE_DRM_GEM_CMA_FOPS(tidss_fops);
@@ -154,6 +153,7 @@ static int tidss_probe(struct platform_device *pdev)
 		kfree(ddev);
 		return ret;
 	}
+	drmm_add_final_kfree(ddev, tidss);
 
 	tidss->dev = dev;
 	tidss->feat = of_device_get_match_data(dev);

commit 32a1795f57eecc3974901760400618571c9d357f
Author: Jyri Sarha <jsarha@ti.com>
Date:   Fri Nov 8 09:45:28 2019 +0200

    drm/tidss: New driver for TI Keystone platform Display SubSystem
    
    This patch adds a new DRM driver for Texas Instruments DSS IPs used on
    Texas Instruments Keystone K2G, AM65x, and J721e SoCs. The new DSS IP is
    a major change to the older DSS IP versions, which are supported by
    the omapdrm driver. While on higher level the Keystone DSS resembles
    the older DSS versions, the registers are completely different and the
    internal pipelines differ a lot.
    
    DSS IP found on K2G is an "ultra-light" version, and has only a single
    plane and a single output. The K3 DSS IPs are found on AM65x and J721E
    SoCs. AM65x DSS has two video ports, one full video plane, and another
    "lite" plane without scaling support. J721E has 4 video ports, 2 video
    planes and 2 lite planes. AM65x DSS has also an integrated OLDI (LVDS)
    output.
    
    Version history:
    
    v2: - rebased on top of drm-next-2019-11-27
        - sort all include lines in all files
        - remove all include <drm/drmP.h>
        - remove select "select VIDEOMODE_HELPERS"
        - call dispc_vp_setup() later in tidss_crtc_atomic_flush() (there is no
          to call it in new modeset case as it is also called in vp_enable())
        - change probe sequence and drm_device allocation (follow example in
          drm_drv.c)
        - use __maybe_unused instead of #ifdef for pm functions
        - remove "struct drm_fbdev_cma *fbdev;" from driver data
        - check panel connector type before connecting it
    
    v3: no change
    
    v4: no change
    
    v5: - remove fifo underflow irq handling, it is not an error and
          it should be used for debug purposes only
        - memory tuning, prefetch plane fifo up to high-threshold value to
          minimize possibility of underflows.
    
    v6: - Check CTM and gamma support from dispc_features when creating crtc
        - Implement CTM support for k2g and fix k3 CTM implementation
        - Remove gamma property persistence and always write color properties
          in a new modeset
    
    v7: - Fix checkpatch.pl --strict issues
        - Rebase on top of drm-misc-next-2020-01-10
    
    v8: - Remove idle debug prints from dispc_init()
        - Add Reviewed-by: Benoit Parrot <bparrot@ti.com>
    
    v9: - Rename dispc_write_irqenable() to dispc_set_irqenable() to avoid
          conflict exported omapfb function with same name
        - Add Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    
    Co-developed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/925fbfad58ff828e8e07fdff7073a0ee65750c3d.1580129724.git.jsarha@ti.com

diff --git a/drivers/gpu/drm/tidss/tidss_drv.c b/drivers/gpu/drm/tidss/tidss_drv.c
new file mode 100644
index 000000000000..d95e4be2c7b9
--- /dev/null
+++ b/drivers/gpu/drm/tidss/tidss_drv.c
@@ -0,0 +1,285 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
+ */
+
+#include <linux/console.h>
+#include <linux/of_device.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_irq.h>
+#include <drm/drm_probe_helper.h>
+
+#include "tidss_dispc.h"
+#include "tidss_drv.h"
+#include "tidss_kms.h"
+#include "tidss_irq.h"
+
+/* Power management */
+
+int tidss_runtime_get(struct tidss_device *tidss)
+{
+	int r;
+
+	dev_dbg(tidss->dev, "%s\n", __func__);
+
+	r = pm_runtime_get_sync(tidss->dev);
+	WARN_ON(r < 0);
+	return r < 0 ? r : 0;
+}
+
+void tidss_runtime_put(struct tidss_device *tidss)
+{
+	int r;
+
+	dev_dbg(tidss->dev, "%s\n", __func__);
+
+	r = pm_runtime_put_sync(tidss->dev);
+	WARN_ON(r < 0);
+}
+
+static int __maybe_unused tidss_pm_runtime_suspend(struct device *dev)
+{
+	struct tidss_device *tidss = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	return dispc_runtime_suspend(tidss->dispc);
+}
+
+static int __maybe_unused tidss_pm_runtime_resume(struct device *dev)
+{
+	struct tidss_device *tidss = dev_get_drvdata(dev);
+	int r;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	r = dispc_runtime_resume(tidss->dispc);
+	if (r)
+		return r;
+
+	return 0;
+}
+
+static int __maybe_unused tidss_suspend(struct device *dev)
+{
+	struct tidss_device *tidss = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	return drm_mode_config_helper_suspend(&tidss->ddev);
+}
+
+static int __maybe_unused tidss_resume(struct device *dev)
+{
+	struct tidss_device *tidss = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	return drm_mode_config_helper_resume(&tidss->ddev);
+}
+
+#ifdef CONFIG_PM
+
+static const struct dev_pm_ops tidss_pm_ops = {
+	.runtime_suspend = tidss_pm_runtime_suspend,
+	.runtime_resume = tidss_pm_runtime_resume,
+	SET_SYSTEM_SLEEP_PM_OPS(tidss_suspend, tidss_resume)
+};
+
+#endif /* CONFIG_PM */
+
+/* DRM device Information */
+
+static void tidss_release(struct drm_device *ddev)
+{
+	struct tidss_device *tidss = ddev->dev_private;
+
+	drm_kms_helper_poll_fini(ddev);
+
+	tidss_modeset_cleanup(tidss);
+
+	drm_dev_fini(ddev);
+
+	kfree(tidss);
+}
+
+DEFINE_DRM_GEM_CMA_FOPS(tidss_fops);
+
+static struct drm_driver tidss_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
+	.fops			= &tidss_fops,
+	.release		= tidss_release,
+	DRM_GEM_CMA_VMAP_DRIVER_OPS,
+	.name			= "tidss",
+	.desc			= "TI Keystone DSS",
+	.date			= "20180215",
+	.major			= 1,
+	.minor			= 0,
+
+	.irq_preinstall		= tidss_irq_preinstall,
+	.irq_postinstall	= tidss_irq_postinstall,
+	.irq_handler		= tidss_irq_handler,
+	.irq_uninstall		= tidss_irq_uninstall,
+};
+
+static int tidss_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct tidss_device *tidss;
+	struct drm_device *ddev;
+	int ret;
+	int irq;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	/* Can't use devm_* since drm_device's lifetime may exceed dev's */
+	tidss = kzalloc(sizeof(*tidss), GFP_KERNEL);
+	if (!tidss)
+		return -ENOMEM;
+
+	ddev = &tidss->ddev;
+
+	ret = devm_drm_dev_init(&pdev->dev, ddev, &tidss_driver);
+	if (ret) {
+		kfree(ddev);
+		return ret;
+	}
+
+	tidss->dev = dev;
+	tidss->feat = of_device_get_match_data(dev);
+
+	platform_set_drvdata(pdev, tidss);
+
+	ddev->dev_private = tidss;
+
+	ret = dispc_init(tidss);
+	if (ret) {
+		dev_err(dev, "failed to initialize dispc: %d\n", ret);
+		return ret;
+	}
+
+	pm_runtime_enable(dev);
+
+#ifndef CONFIG_PM
+	/* If we don't have PM, we need to call resume manually */
+	dispc_runtime_resume(tidss->dispc);
+#endif
+
+	ret = tidss_modeset_init(tidss);
+	if (ret < 0) {
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "failed to init DRM/KMS (%d)\n", ret);
+		goto err_runtime_suspend;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		ret = irq;
+		goto err_runtime_suspend;
+	}
+
+	ret = drm_irq_install(ddev, irq);
+	if (ret) {
+		dev_err(dev, "drm_irq_install failed: %d\n", ret);
+		goto err_runtime_suspend;
+	}
+
+	drm_kms_helper_poll_init(ddev);
+
+	drm_mode_config_reset(ddev);
+
+	ret = drm_dev_register(ddev, 0);
+	if (ret) {
+		dev_err(dev, "failed to register DRM device\n");
+		goto err_irq_uninstall;
+	}
+
+	drm_fbdev_generic_setup(ddev, 32);
+
+	dev_dbg(dev, "%s done\n", __func__);
+
+	return 0;
+
+err_irq_uninstall:
+	drm_irq_uninstall(ddev);
+
+err_runtime_suspend:
+#ifndef CONFIG_PM
+	dispc_runtime_suspend(tidss->dispc);
+#endif
+	pm_runtime_disable(dev);
+
+	return ret;
+}
+
+static int tidss_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct tidss_device *tidss = platform_get_drvdata(pdev);
+	struct drm_device *ddev = &tidss->ddev;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	drm_dev_unregister(ddev);
+
+	drm_atomic_helper_shutdown(ddev);
+
+	drm_irq_uninstall(ddev);
+
+#ifndef CONFIG_PM
+	/* If we don't have PM, we need to call suspend manually */
+	dispc_runtime_suspend(tidss->dispc);
+#endif
+	pm_runtime_disable(dev);
+
+	/* devm allocated dispc goes away with the dev so mark it NULL */
+	dispc_remove(tidss);
+
+	dev_dbg(dev, "%s done\n", __func__);
+
+	return 0;
+}
+
+static void tidss_shutdown(struct platform_device *pdev)
+{
+	drm_atomic_helper_shutdown(platform_get_drvdata(pdev));
+}
+
+static const struct of_device_id tidss_of_table[] = {
+	{ .compatible = "ti,k2g-dss", .data = &dispc_k2g_feats, },
+	{ .compatible = "ti,am65x-dss", .data = &dispc_am65x_feats, },
+	{ .compatible = "ti,j721e-dss", .data = &dispc_j721e_feats, },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, tidss_of_table);
+
+static struct platform_driver tidss_platform_driver = {
+	.probe		= tidss_probe,
+	.remove		= tidss_remove,
+	.shutdown	= tidss_shutdown,
+	.driver		= {
+		.name	= "tidss",
+#ifdef CONFIG_PM
+		.pm	= &tidss_pm_ops,
+#endif
+		.of_match_table = tidss_of_table,
+		.suppress_bind_attrs = true,
+	},
+};
+
+module_platform_driver(tidss_platform_driver);
+
+MODULE_AUTHOR("Tomi Valkeinen <tomi.valkeinen@ti.com>");
+MODULE_DESCRIPTION("TI Keystone DSS Driver");
+MODULE_LICENSE("GPL v2");
