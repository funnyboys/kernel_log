commit a8d9d7da1546349f18eb2d6b6b3a04bdeb38719d
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Wed Apr 29 15:10:22 2020 +0300

    drm/tidss: remove AM65x PG1 YUV erratum code
    
    AM65x PG1 has a HW issue with YUV pixel formats, resulting in wrong
    colors on the screen. This issue is fixed in PG2 hardware.
    
    The driver currently has code to hide YUV pixel formats from the
    userspace. To support PG2, we would need to add code to detect the SoC
    version and hide the YUV formats based on that.
    
    However, as PG1 will be phased out and PG2 will be the main platform, a
    much simpler solution is just to drop the code in question. The downside
    is that the users will be able to use YUV formats on PG1, getting wrong
    colors on the screen. On the other hand, that may also be a plus, as the
    same applications will now work on PG1 and PG2, even if the colors are
    wrong on PG1.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200429121022.3871-1-tomi.valkeinen@ti.com
    Reviewed-by: Jyri Sarha <jsarha@ti.com>

diff --git a/drivers/gpu/drm/tidss/tidss_dispc.h b/drivers/gpu/drm/tidss/tidss_dispc.h
index a4a68249e44b..902e612ff7ac 100644
--- a/drivers/gpu/drm/tidss/tidss_dispc.h
+++ b/drivers/gpu/drm/tidss/tidss_dispc.h
@@ -46,10 +46,6 @@ struct dispc_features_scaling {
 	u32 xinc_max;
 };
 
-struct dispc_errata {
-	bool i2000; /* DSS Does Not Support YUV Pixel Data Formats */
-};
-
 enum dispc_vp_bus_type {
 	DISPC_VP_DPI,		/* DPI output */
 	DISPC_VP_OLDI,		/* OLDI (LVDS) output */
@@ -83,8 +79,6 @@ struct dispc_features {
 	const char *vid_name[TIDSS_MAX_PLANES]; /* Should match dt reg names */
 	bool vid_lite[TIDSS_MAX_PLANES];
 	u32 vid_order[TIDSS_MAX_PLANES];
-
-	struct dispc_errata errata;
 };
 
 extern const struct dispc_features dispc_k2g_feats;

commit b33b54748866f7bc29696837c472f49413169d4e
Author: Jyri Sarha <jsarha@ti.com>
Date:   Thu Feb 27 14:00:52 2020 +0200

    drm/tidss: dispc: Fix broken plane positioning code
    
    The old implementation of placing planes on the CRTC while configuring
    the planes was naive and relied on the order in which the planes were
    configured, enabled, and disabled. The situation where a plane's zpos
    was changed on the fly was completely broken. The usual symptoms of
    this problem was scrambled display and a flood of sync lost errors,
    when a plane was active in two layers at the same time, or a missing
    plane, in case when a layer was accidentally disabled.
    
    The rewrite takes a more straight forward approach when HW is
    concerned. The plane positioning registers are in the CRTC (or
    actually OVR) register space and it is more natural to configure them
    in a one go when configuring the CRTC. To do this we need make sure we
    have all the planes on the updated CRTCs in the new atomic state. The
    untouched planes on CRTCs that need plane position update are added to
    the atomic state in tidss_atomic_check().
    
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Reviewed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200227120052.23168-1-jsarha@ti.com

diff --git a/drivers/gpu/drm/tidss/tidss_dispc.h b/drivers/gpu/drm/tidss/tidss_dispc.h
index e65e6a2bb821..a4a68249e44b 100644
--- a/drivers/gpu/drm/tidss/tidss_dispc.h
+++ b/drivers/gpu/drm/tidss/tidss_dispc.h
@@ -94,6 +94,11 @@ extern const struct dispc_features dispc_j721e_feats;
 void dispc_set_irqenable(struct dispc_device *dispc, dispc_irq_t mask);
 dispc_irq_t dispc_read_and_clear_irqstatus(struct dispc_device *dispc);
 
+void dispc_ovr_set_plane(struct dispc_device *dispc, u32 hw_plane,
+			 u32 hw_videoport, u32 x, u32 y, u32 layer);
+void dispc_ovr_enable_layer(struct dispc_device *dispc,
+			    u32 hw_videoport, u32 layer, bool enable);
+
 void dispc_vp_prepare(struct dispc_device *dispc, u32 hw_videoport,
 		      const struct drm_crtc_state *state);
 void dispc_vp_enable(struct dispc_device *dispc, u32 hw_videoport,

commit 32a1795f57eecc3974901760400618571c9d357f
Author: Jyri Sarha <jsarha@ti.com>
Date:   Fri Nov 8 09:45:28 2019 +0200

    drm/tidss: New driver for TI Keystone platform Display SubSystem
    
    This patch adds a new DRM driver for Texas Instruments DSS IPs used on
    Texas Instruments Keystone K2G, AM65x, and J721e SoCs. The new DSS IP is
    a major change to the older DSS IP versions, which are supported by
    the omapdrm driver. While on higher level the Keystone DSS resembles
    the older DSS versions, the registers are completely different and the
    internal pipelines differ a lot.
    
    DSS IP found on K2G is an "ultra-light" version, and has only a single
    plane and a single output. The K3 DSS IPs are found on AM65x and J721E
    SoCs. AM65x DSS has two video ports, one full video plane, and another
    "lite" plane without scaling support. J721E has 4 video ports, 2 video
    planes and 2 lite planes. AM65x DSS has also an integrated OLDI (LVDS)
    output.
    
    Version history:
    
    v2: - rebased on top of drm-next-2019-11-27
        - sort all include lines in all files
        - remove all include <drm/drmP.h>
        - remove select "select VIDEOMODE_HELPERS"
        - call dispc_vp_setup() later in tidss_crtc_atomic_flush() (there is no
          to call it in new modeset case as it is also called in vp_enable())
        - change probe sequence and drm_device allocation (follow example in
          drm_drv.c)
        - use __maybe_unused instead of #ifdef for pm functions
        - remove "struct drm_fbdev_cma *fbdev;" from driver data
        - check panel connector type before connecting it
    
    v3: no change
    
    v4: no change
    
    v5: - remove fifo underflow irq handling, it is not an error and
          it should be used for debug purposes only
        - memory tuning, prefetch plane fifo up to high-threshold value to
          minimize possibility of underflows.
    
    v6: - Check CTM and gamma support from dispc_features when creating crtc
        - Implement CTM support for k2g and fix k3 CTM implementation
        - Remove gamma property persistence and always write color properties
          in a new modeset
    
    v7: - Fix checkpatch.pl --strict issues
        - Rebase on top of drm-misc-next-2020-01-10
    
    v8: - Remove idle debug prints from dispc_init()
        - Add Reviewed-by: Benoit Parrot <bparrot@ti.com>
    
    v9: - Rename dispc_write_irqenable() to dispc_set_irqenable() to avoid
          conflict exported omapfb function with same name
        - Add Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    
    Co-developed-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Jyri Sarha <jsarha@ti.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Benoit Parrot <bparrot@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/925fbfad58ff828e8e07fdff7073a0ee65750c3d.1580129724.git.jsarha@ti.com

diff --git a/drivers/gpu/drm/tidss/tidss_dispc.h b/drivers/gpu/drm/tidss/tidss_dispc.h
new file mode 100644
index 000000000000..e65e6a2bb821
--- /dev/null
+++ b/drivers/gpu/drm/tidss/tidss_dispc.h
@@ -0,0 +1,132 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
+ */
+
+#ifndef __TIDSS_DISPC_H__
+#define __TIDSS_DISPC_H__
+
+#include "tidss_drv.h"
+
+struct dispc_device;
+
+struct drm_crtc_state;
+
+enum tidss_gamma_type { TIDSS_GAMMA_8BIT, TIDSS_GAMMA_10BIT };
+
+struct tidss_vp_feat {
+	struct tidss_vp_color_feat {
+		u32 gamma_size;
+		enum tidss_gamma_type gamma_type;
+		bool has_ctm;
+	} color;
+};
+
+struct tidss_plane_feat {
+	struct tidss_plane_color_feat {
+		u32 encodings;
+		u32 ranges;
+		enum drm_color_encoding default_encoding;
+		enum drm_color_range default_range;
+	} color;
+	struct tidss_plane_blend_feat {
+		bool global_alpha;
+	} blend;
+};
+
+struct dispc_features_scaling {
+	u32 in_width_max_5tap_rgb;
+	u32 in_width_max_3tap_rgb;
+	u32 in_width_max_5tap_yuv;
+	u32 in_width_max_3tap_yuv;
+	u32 upscale_limit;
+	u32 downscale_limit_5tap;
+	u32 downscale_limit_3tap;
+	u32 xinc_max;
+};
+
+struct dispc_errata {
+	bool i2000; /* DSS Does Not Support YUV Pixel Data Formats */
+};
+
+enum dispc_vp_bus_type {
+	DISPC_VP_DPI,		/* DPI output */
+	DISPC_VP_OLDI,		/* OLDI (LVDS) output */
+	DISPC_VP_INTERNAL,	/* SoC internal routing */
+	DISPC_VP_MAX_BUS_TYPE,
+};
+
+enum dispc_dss_subrevision {
+	DISPC_K2G,
+	DISPC_AM65X,
+	DISPC_J721E,
+};
+
+struct dispc_features {
+	int min_pclk_khz;
+	int max_pclk_khz[DISPC_VP_MAX_BUS_TYPE];
+
+	struct dispc_features_scaling scaling;
+
+	enum dispc_dss_subrevision subrev;
+
+	const char *common;
+	const u16 *common_regs;
+	u32 num_vps;
+	const char *vp_name[TIDSS_MAX_PORTS]; /* Should match dt reg names */
+	const char *ovr_name[TIDSS_MAX_PORTS]; /* Should match dt reg names */
+	const char *vpclk_name[TIDSS_MAX_PORTS]; /* Should match dt clk names */
+	const enum dispc_vp_bus_type vp_bus_type[TIDSS_MAX_PORTS];
+	struct tidss_vp_feat vp_feat;
+	u32 num_planes;
+	const char *vid_name[TIDSS_MAX_PLANES]; /* Should match dt reg names */
+	bool vid_lite[TIDSS_MAX_PLANES];
+	u32 vid_order[TIDSS_MAX_PLANES];
+
+	struct dispc_errata errata;
+};
+
+extern const struct dispc_features dispc_k2g_feats;
+extern const struct dispc_features dispc_am65x_feats;
+extern const struct dispc_features dispc_j721e_feats;
+
+void dispc_set_irqenable(struct dispc_device *dispc, dispc_irq_t mask);
+dispc_irq_t dispc_read_and_clear_irqstatus(struct dispc_device *dispc);
+
+void dispc_vp_prepare(struct dispc_device *dispc, u32 hw_videoport,
+		      const struct drm_crtc_state *state);
+void dispc_vp_enable(struct dispc_device *dispc, u32 hw_videoport,
+		     const struct drm_crtc_state *state);
+void dispc_vp_disable(struct dispc_device *dispc, u32 hw_videoport);
+void dispc_vp_unprepare(struct dispc_device *dispc, u32 hw_videoport);
+bool dispc_vp_go_busy(struct dispc_device *dispc, u32 hw_videoport);
+void dispc_vp_go(struct dispc_device *dispc, u32 hw_videoport);
+int dispc_vp_bus_check(struct dispc_device *dispc, u32 hw_videoport,
+		       const struct drm_crtc_state *state);
+enum drm_mode_status dispc_vp_mode_valid(struct dispc_device *dispc,
+					 u32 hw_videoport,
+					 const struct drm_display_mode *mode);
+int dispc_vp_enable_clk(struct dispc_device *dispc, u32 hw_videoport);
+void dispc_vp_disable_clk(struct dispc_device *dispc, u32 hw_videoport);
+int dispc_vp_set_clk_rate(struct dispc_device *dispc, u32 hw_videoport,
+			  unsigned long rate);
+void dispc_vp_setup(struct dispc_device *dispc, u32 hw_videoport,
+		    const struct drm_crtc_state *state, bool newmodeset);
+
+int dispc_runtime_suspend(struct dispc_device *dispc);
+int dispc_runtime_resume(struct dispc_device *dispc);
+
+int dispc_plane_check(struct dispc_device *dispc, u32 hw_plane,
+		      const struct drm_plane_state *state,
+		      u32 hw_videoport);
+int dispc_plane_setup(struct dispc_device *dispc, u32 hw_plane,
+		      const struct drm_plane_state *state,
+		      u32 hw_videoport);
+int dispc_plane_enable(struct dispc_device *dispc, u32 hw_plane, bool enable);
+const u32 *dispc_plane_formats(struct dispc_device *dispc, unsigned int *len);
+
+int dispc_init(struct tidss_device *tidss);
+void dispc_remove(struct tidss_device *tidss);
+
+#endif
