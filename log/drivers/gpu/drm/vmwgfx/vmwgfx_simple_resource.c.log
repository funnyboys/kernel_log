commit 5724f899ed8265386c2b1f067f836c35aebc7d6e
Author: Deepak Rawat <drawat@vmware.com>
Date:   Mon Feb 11 11:46:27 2019 -0800

    drm/vmwgfx: Add a new define for vmwgfx user-space debugging
    
    Error messages or debugging message reported during user-space command
    submission should not be printed to dmesg by default. So add a new
    preprocessor define called VMW_DEBUG_USER which translates to
    DRM_DEBUG_DRIVER.
    
    v2: Use VMW_DEBUG_USER instead of using DRM_DEBUG_DRIVER directly.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c b/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c
index 6a6865384e91..73e9a487e659 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c
@@ -239,17 +239,17 @@ vmw_simple_resource_lookup(struct ttm_object_file *tfile,
 
 	base = ttm_base_object_lookup(tfile, handle);
 	if (!base) {
-		DRM_ERROR("Invalid %s handle 0x%08lx.\n",
-			  func->res_func.type_name,
-			  (unsigned long) handle);
+		VMW_DEBUG_USER("Invalid %s handle 0x%08lx.\n",
+			       func->res_func.type_name,
+			       (unsigned long) handle);
 		return ERR_PTR(-ESRCH);
 	}
 
 	if (ttm_base_object_type(base) != func->ttm_res_type) {
 		ttm_base_object_unref(&base);
-		DRM_ERROR("Invalid type of %s handle 0x%08lx.\n",
-			  func->res_func.type_name,
-			  (unsigned long) handle);
+		VMW_DEBUG_USER("Invalid type of %s handle 0x%08lx.\n",
+			       func->res_func.type_name,
+			       (unsigned long) handle);
 		return ERR_PTR(-EINVAL);
 	}
 

commit c7eae62666ade1c8c9960085911e420227144d5a
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Wed Sep 26 15:50:13 2018 +0200

    drm/vmwgfx: Make the object handles idr-generated
    
    Instead of generating user-space object handles based on a, possibly
    processed, hash of the kernel address of the object, use idr to generate
    and lookup those handles. This might improve somewhat on security since
    we loose all connections to the object's kernel address. Also idr is
    designed to do just this.
    
    As a todo-item, since user-space handles are now generated in sequence,
    we can probably use a much simpler hash function to hash them.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Deepak Rawat <drawat@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c b/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c
index 3bd60f7a9d6d..6a6865384e91 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c
@@ -159,7 +159,8 @@ vmw_simple_resource_create_ioctl(struct drm_device *dev, void *data,
 
 	alloc_size = offsetof(struct vmw_user_simple_resource, simple) +
 	  func->size;
-	account_size = ttm_round_pot(alloc_size) + VMW_IDA_ACC_SIZE;
+	account_size = ttm_round_pot(alloc_size) + VMW_IDA_ACC_SIZE +
+		TTM_OBJ_EXTRA_SIZE;
 
 	ret = ttm_read_lock(&dev_priv->reservation_sem, true);
 	if (ret)
@@ -208,7 +209,7 @@ vmw_simple_resource_create_ioctl(struct drm_device *dev, void *data,
 		goto out_err;
 	}
 
-	func->set_arg_handle(data, usimple->base.hash.key);
+	func->set_arg_handle(data, usimple->base.handle);
 out_err:
 	vmw_resource_unreference(&res);
 out_ret:

commit 13289241fe8b8c336ec8277b9c4643ea7fbb2f70
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Wed Sep 26 15:41:52 2018 +0200

    drm/vmwgfx: Remove the resource avail field
    
    This field was previously used to prevent a lookup of a resource before its
    constructor had run to its end. This was mainly intended for an interface
    that is now removed that allowed looking up a resource by its device id.
    
    Currently all affected resources are added to the lookup mechanism (its
    TTM prime object is initialized) late in the constructor where it's OK to
    look up the resource.
    
    This means we can change the device resource_lock to an ordinary spinlock
    instead of an rwlock and remove a locking sequence during lookup.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Deepak Rawat <drawat@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c b/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c
index 6ebc5affde14..3bd60f7a9d6d 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c
@@ -81,7 +81,7 @@ static int vmw_simple_resource_init(struct vmw_private *dev_priv,
 		return ret;
 	}
 
-	vmw_resource_activate(&simple->res, simple->func->hw_destroy);
+	simple->res.hw_destroy = simple->func->hw_destroy;
 
 	return 0;
 }

commit dff96888860a9ebaa618be973b51f4d86aec1211
Author: Dirk Hohndel (VMware) <dirk@hohndel.org>
Date:   Mon May 7 01:16:26 2018 +0200

    drm/vmwgfx: add SPDX idenitifier and clarify license
    
    This is dual licensed under GPL-2.0 or MIT.
    vmwgfx_msg.h is the odd one out that is GPL-2.0+ or MIT.
    
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Dirk Hohndel (VMware) <dirk@hohndel.org>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180506231626.115996-9-dirk@hohndel.org

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c b/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c
index a0cb310665cc..6ebc5affde14 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0 OR MIT
 /**************************************************************************
  *
- * Copyright © 2016 VMware, Inc., Palo Alto, CA., USA
- * All Rights Reserved.
+ * Copyright 2016 VMware, Inc., Palo Alto, CA., USA
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the

commit 279c01f6ef626d59b93383d183fb69173d3f7ac7
Author: Roger He <Hongbo.He@amd.com>
Date:   Fri Dec 8 15:09:50 2017 +0800

    drm/ttm: use an operation ctx for ttm_mem_global_alloc
    
    forward the operation context to ttm_mem_global_alloc as well, and the
    ultimate goal is swapout enablement for reserved BOs
    
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Roger He <Hongbo.He@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c b/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c
index 051d3b39b0ea..a0cb310665cc 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c
@@ -149,6 +149,10 @@ vmw_simple_resource_create_ioctl(struct drm_device *dev, void *data,
 	struct vmw_resource *res;
 	struct vmw_resource *tmp;
 	struct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;
+	struct ttm_operation_ctx ctx = {
+		.interruptible = true,
+		.no_wait_gpu = false
+	};
 	size_t alloc_size;
 	size_t account_size;
 	int ret;
@@ -162,7 +166,7 @@ vmw_simple_resource_create_ioctl(struct drm_device *dev, void *data,
 		return ret;
 
 	ret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv), account_size,
-				   false, true);
+				   &ctx);
 	ttm_read_unlock(&dev_priv->reservation_sem);
 	if (ret) {
 		if (ret != -ERESTARTSYS)

commit d4d21902222d44acc76a520f11f78040b1e34b5a
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Thu Mar 23 15:09:42 2017 -0700

    drm/vmwgfx: Introduce a simple resource type
    
    The callbacks we need to provide to many resources are very similar, so
    provide a simple resource type with a number of helpers for these
    callbacks.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c b/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c
new file mode 100644
index 000000000000..051d3b39b0ea
--- /dev/null
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_simple_resource.c
@@ -0,0 +1,256 @@
+/**************************************************************************
+ *
+ * Copyright © 2016 VMware, Inc., Palo Alto, CA., USA
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ **************************************************************************/
+
+#include "vmwgfx_drv.h"
+#include "vmwgfx_resource_priv.h"
+
+/**
+ * struct vmw_user_simple_resource - User-space simple resource struct
+ *
+ * @base: The TTM base object implementing user-space visibility.
+ * @account_size: How much memory was accounted for this object.
+ * @simple: The embedded struct vmw_simple_resource.
+ */
+struct vmw_user_simple_resource {
+	struct ttm_base_object base;
+	size_t account_size;
+	struct vmw_simple_resource simple;
+/*
+ * Nothing to be placed after @simple, since size of @simple is
+ * unknown.
+ */
+};
+
+
+/**
+ * vmw_simple_resource_init - Initialize a simple resource object.
+ *
+ * @dev_priv: Pointer to a struct device private.
+ * @simple: The struct vmw_simple_resource to initialize.
+ * @data: Data passed to the information initialization function.
+ * @res_free: Function pointer to destroy the simple resource.
+ *
+ * Returns:
+ *   0 if succeeded.
+ *   Negative error value if error, in which case the resource will have been
+ * freed.
+ */
+static int vmw_simple_resource_init(struct vmw_private *dev_priv,
+				    struct vmw_simple_resource *simple,
+				    void *data,
+				    void (*res_free)(struct vmw_resource *res))
+{
+	struct vmw_resource *res = &simple->res;
+	int ret;
+
+	ret = vmw_resource_init(dev_priv, res, false, res_free,
+				&simple->func->res_func);
+
+	if (ret) {
+		res_free(res);
+		return ret;
+	}
+
+	ret = simple->func->init(res, data);
+	if (ret) {
+		vmw_resource_unreference(&res);
+		return ret;
+	}
+
+	vmw_resource_activate(&simple->res, simple->func->hw_destroy);
+
+	return 0;
+}
+
+/**
+ * vmw_simple_resource_free - Free a simple resource object.
+ *
+ * @res: The struct vmw_resource member of the simple resource object.
+ *
+ * Frees memory and memory accounting for the object.
+ */
+static void vmw_simple_resource_free(struct vmw_resource *res)
+{
+	struct vmw_user_simple_resource *usimple =
+		container_of(res, struct vmw_user_simple_resource,
+			     simple.res);
+	struct vmw_private *dev_priv = res->dev_priv;
+	size_t size = usimple->account_size;
+
+	ttm_base_object_kfree(usimple, base);
+	ttm_mem_global_free(vmw_mem_glob(dev_priv), size);
+}
+
+/**
+ * vmw_simple_resource_base_release - TTM object release callback
+ *
+ * @p_base: The struct ttm_base_object member of the simple resource object.
+ *
+ * Called when the last reference to the embedded struct ttm_base_object is
+ * gone. Typically results in an object free, unless there are other
+ * references to the embedded struct vmw_resource.
+ */
+static void vmw_simple_resource_base_release(struct ttm_base_object **p_base)
+{
+	struct ttm_base_object *base = *p_base;
+	struct vmw_user_simple_resource *usimple =
+		container_of(base, struct vmw_user_simple_resource, base);
+	struct vmw_resource *res = &usimple->simple.res;
+
+	*p_base = NULL;
+	vmw_resource_unreference(&res);
+}
+
+/**
+ * vmw_simple_resource_create_ioctl - Helper to set up an ioctl function to
+ * create a struct vmw_simple_resource.
+ *
+ * @dev: Pointer to a struct drm device.
+ * @data: Ioctl argument.
+ * @file_priv: Pointer to a struct drm_file identifying the caller.
+ * @func: Pointer to a struct vmw_simple_resource_func identifying the
+ * simple resource type.
+ *
+ * Returns:
+ *   0 if success,
+ *   Negative error value on error.
+ */
+int
+vmw_simple_resource_create_ioctl(struct drm_device *dev, void *data,
+				 struct drm_file *file_priv,
+				 const struct vmw_simple_resource_func *func)
+{
+	struct vmw_private *dev_priv = vmw_priv(dev);
+	struct vmw_user_simple_resource *usimple;
+	struct vmw_resource *res;
+	struct vmw_resource *tmp;
+	struct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;
+	size_t alloc_size;
+	size_t account_size;
+	int ret;
+
+	alloc_size = offsetof(struct vmw_user_simple_resource, simple) +
+	  func->size;
+	account_size = ttm_round_pot(alloc_size) + VMW_IDA_ACC_SIZE;
+
+	ret = ttm_read_lock(&dev_priv->reservation_sem, true);
+	if (ret)
+		return ret;
+
+	ret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv), account_size,
+				   false, true);
+	ttm_read_unlock(&dev_priv->reservation_sem);
+	if (ret) {
+		if (ret != -ERESTARTSYS)
+			DRM_ERROR("Out of graphics memory for %s"
+				  " creation.\n", func->res_func.type_name);
+
+		goto out_ret;
+	}
+
+	usimple = kzalloc(alloc_size, GFP_KERNEL);
+	if (!usimple) {
+		ttm_mem_global_free(vmw_mem_glob(dev_priv),
+				    account_size);
+		ret = -ENOMEM;
+		goto out_ret;
+	}
+
+	usimple->simple.func = func;
+	usimple->account_size = account_size;
+	res = &usimple->simple.res;
+	usimple->base.shareable = false;
+	usimple->base.tfile = NULL;
+
+	/*
+	 * From here on, the destructor takes over resource freeing.
+	 */
+	ret = vmw_simple_resource_init(dev_priv, &usimple->simple,
+				       data, vmw_simple_resource_free);
+	if (ret)
+		goto out_ret;
+
+	tmp = vmw_resource_reference(res);
+	ret = ttm_base_object_init(tfile, &usimple->base, false,
+				   func->ttm_res_type,
+				   &vmw_simple_resource_base_release, NULL);
+
+	if (ret) {
+		vmw_resource_unreference(&tmp);
+		goto out_err;
+	}
+
+	func->set_arg_handle(data, usimple->base.hash.key);
+out_err:
+	vmw_resource_unreference(&res);
+out_ret:
+	return ret;
+}
+
+/**
+ * vmw_simple_resource_lookup - Look up a simple resource from its user-space
+ * handle.
+ *
+ * @tfile: struct ttm_object_file identifying the caller.
+ * @handle: The user-space handle.
+ * @func: The struct vmw_simple_resource_func identifying the simple resource
+ * type.
+ *
+ * Returns: Refcounted pointer to the embedded struct vmw_resource if
+ * successfule. Error pointer otherwise.
+ */
+struct vmw_resource *
+vmw_simple_resource_lookup(struct ttm_object_file *tfile,
+			   uint32_t handle,
+			   const struct vmw_simple_resource_func *func)
+{
+	struct vmw_user_simple_resource *usimple;
+	struct ttm_base_object *base;
+	struct vmw_resource *res;
+
+	base = ttm_base_object_lookup(tfile, handle);
+	if (!base) {
+		DRM_ERROR("Invalid %s handle 0x%08lx.\n",
+			  func->res_func.type_name,
+			  (unsigned long) handle);
+		return ERR_PTR(-ESRCH);
+	}
+
+	if (ttm_base_object_type(base) != func->ttm_res_type) {
+		ttm_base_object_unref(&base);
+		DRM_ERROR("Invalid type of %s handle 0x%08lx.\n",
+			  func->res_func.type_name,
+			  (unsigned long) handle);
+		return ERR_PTR(-EINVAL);
+	}
+
+	usimple = container_of(base, typeof(*usimple), base);
+	res = vmw_resource_reference(&usimple->simple.res);
+	ttm_base_object_unref(&base);
+
+	return res;
+}
