commit d5c1f0110dd6cb182d698b2df7e0445282a1392d
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Jun 23 12:23:33 2019 +0200

    drm/vmwgfx: drop use of drmP.h in header files
    
    To facilitate removal of drmP.h in the .c
    files remove the use from header files first.
    Fix fallout in the other files.
    
    Sorted include files in blocks and sorted files
    within each block in alphabetical order.
    
    This revealed a dependency from an uapi header to a header
    located below drivers/gpu/drm/vmwgfx/.
    Added FIXME to remind someone to fix this.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: VMware Graphics <linux-graphics-maintainer@vmware.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Reviewed-by: Deepak Rawat <drawat@vmware.com>
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 535b03599e55..3ee03227607c 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -28,9 +28,9 @@
 #ifndef VMWGFX_KMS_H_
 #define VMWGFX_KMS_H_
 
-#include <drm/drmP.h>
 #include <drm/drm_encoder.h>
 #include <drm/drm_probe_helper.h>
+
 #include "vmwgfx_drv.h"
 
 /**

commit fcd70cd36b9bf697122538c9e38e8cf954b2342b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 17 22:03:34 2019 +0100

    drm: Split out drm_probe_helper.h
    
    Having the probe helper stuff (which pretty much everyone needs) in
    the drm_crtc_helper.h file (which atomic drivers should never need) is
    confusing. Split them out.
    
    To make sure I actually achieved the goal here I went through all
    drivers. And indeed, all atomic drivers are now free of
    drm_crtc_helper.h includes.
    
    v2: Make it compile. There was so much compile fail on arm drivers
    that I figured I'll better not include any of the acks on v1.
    
    v3: Massive rebase because i915 has lost a lot of drmP.h includes, but
    not all: Through drm_crtc_helper.h > drm_modeset_helper.h -> drmP.h
    there was still one, which this patch largely removes. Which means
    rolling out lots more includes all over.
    
    This will also conflict with ongoing drmP.h cleanup by others I
    expect.
    
    v3: Rebase on top of atomic bochs.
    
    v4: Review from Laurent for bridge/rcar/omap/shmob/core bits:
    - (re)move some of the added includes, use the better include files in
      other places (all suggested from Laurent adopted unchanged).
    - sort alphabetically
    
    v5: Actually try to sort them, and while at it, sort all the ones I
    touch.
    
    v6: Rebase onto i915 changes.
    
    v7: Rebase once more.
    
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Acked-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Oleksandr Andrushchenko <oleksandr_andrushchenko@epam.com>
    Acked-by: CK Hu <ck.hu@mediatek.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Liviu Dudau <liviu.dudau@arm.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: virtualization@lists.linux-foundation.org
    Cc: etnaviv@lists.freedesktop.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: intel-gfx@lists.freedesktop.org
    Cc: linux-mediatek@lists.infradead.org
    Cc: linux-amlogic@lists.infradead.org
    Cc: linux-arm-msm@vger.kernel.org
    Cc: freedreno@lists.freedesktop.org
    Cc: nouveau@lists.freedesktop.org
    Cc: spice-devel@lists.freedesktop.org
    Cc: amd-gfx@lists.freedesktop.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-stm32@st-md-mailman.stormreply.com
    Cc: linux-tegra@vger.kernel.org
    Cc: xen-devel@lists.xen.org
    Link: https://patchwork.freedesktop.org/patch/msgid/20190117210334.13234-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 655abbcd4058..535b03599e55 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -29,8 +29,8 @@
 #define VMWGFX_KMS_H_
 
 #include <drm/drmP.h>
-#include <drm/drm_crtc_helper.h>
 #include <drm/drm_encoder.h>
+#include <drm/drm_probe_helper.h>
 #include "vmwgfx_drv.h"
 
 /**

commit 9d9486e43728cd513e10ed3dd54e156c8ab7bd2a
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Thu Oct 4 22:38:17 2018 +0000

    drm/vmwgfx: Fix up the implicit display unit handling
    
    Make the connector is_implicit property immutable.
    As far as we know, no user-space application is writing to it.
    
    Also move the verification that all implicit display units scan out
    from the same framebuffer to atomic_check().
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Deepak Rawat <drawat@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index bc5bccf1db42..655abbcd4058 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -307,8 +307,6 @@ struct vmw_plane_state {
 struct vmw_connector_state {
 	struct drm_connector_state base;
 
-	bool is_implicit;
-
 	/**
 	 * @gui_x:
 	 *
@@ -370,7 +368,6 @@ struct vmw_display_unit {
 	int gui_x;
 	int gui_y;
 	bool is_implicit;
-	bool active_implicit;
 	int set_gui_x;
 	int set_gui_y;
 };
@@ -450,17 +447,8 @@ int vmw_kms_fbdev_init_data(struct vmw_private *dev_priv,
 			    struct drm_crtc **p_crtc,
 			    struct drm_display_mode **p_mode);
 void vmw_guess_mode_timing(struct drm_display_mode *mode);
-void vmw_kms_del_active(struct vmw_private *dev_priv,
-			struct vmw_display_unit *du);
-void vmw_kms_add_active(struct vmw_private *dev_priv,
-			struct vmw_display_unit *du,
-			struct vmw_framebuffer *vfb);
-bool vmw_kms_crtc_flippable(struct vmw_private *dev_priv,
-			    struct drm_crtc *crtc);
-void vmw_kms_update_implicit_fb(struct vmw_private *dev_priv,
-				struct drm_crtc *crtc);
-void vmw_kms_create_implicit_placement_property(struct vmw_private *dev_priv,
-						bool immutable);
+void vmw_kms_update_implicit_fb(struct vmw_private *dev_priv);
+void vmw_kms_create_implicit_placement_property(struct vmw_private *dev_priv);
 
 /* Universal Plane Helpers */
 void vmw_du_primary_plane_destroy(struct drm_plane *plane);

commit b4fa61ba05f2afa17558914fdd2b819e9e7e466f
Author: Deepak Rawat <drawat@vmware.com>
Date:   Wed Sep 26 17:17:33 2018 -0700

    drm/vmwgfx: Don't clear mode::type anymore
    
    With kernel commit "drm/modes: Kill off the oddball DRM_MODE_TYPE_CRTC_C
    vs. DRM_MODE_TYPE_BUILTIN handling", no need to clear mode::type for
    user-space bug.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 3e8b8b3d33aa..bc5bccf1db42 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -572,9 +572,6 @@ int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
 		     bool interruptible,
 		     struct drm_crtc *crtc);
 
-int vmw_kms_set_config(struct drm_mode_set *set,
-		       struct drm_modeset_acquire_ctx *ctx);
-
 int vmw_du_helper_plane_update(struct vmw_du_update_plane *update);
 
 /**

commit 43d1e627144ae1bf8de778a583bdf77c2e521cb3
Author: Deepak Rawat <drawat@vmware.com>
Date:   Wed Aug 8 12:39:31 2018 -0700

    drm/vmwgfx: Implement SOU plane update for surface backed fb
    
    Using the new interface implement SOU plane update for surface backed
    fb.
    
    v2: Rebase to new resource validation.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 73fc51f43400..3e8b8b3d33aa 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -129,6 +129,17 @@ struct vmw_du_update_plane {
 	bool intr;
 };
 
+/**
+ * struct vmw_du_update_plane_surface - closure structure for surface
+ * @base: base closure structure.
+ * @cmd_start: FIFO command start address (used by SOU only).
+ */
+struct vmw_du_update_plane_surface {
+	struct vmw_du_update_plane base;
+	/* This member is to handle special case SOU surface update */
+	void *cmd_start;
+};
+
 /**
  * struct vmw_du_update_plane_buffer - Closure structure for buffer object
  * @base: Base closure structure.

commit bc7be607a0edc1bf1ea403efbdd0fe81a71dc369
Author: Deepak Rawat <drawat@vmware.com>
Date:   Mon Jul 9 16:17:17 2018 -0700

    drm/vmwgfx: Implement STDU plane update for BO backed fb
    
    Using the new interface implement STDU plane update for BO backed fb.
    
    v2: Rebase to new resource validation.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index f2f57e58dd88..73fc51f43400 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -129,6 +129,17 @@ struct vmw_du_update_plane {
 	bool intr;
 };
 
+/**
+ * struct vmw_du_update_plane_buffer - Closure structure for buffer object
+ * @base: Base closure structure.
+ * @fb_left: x1 for fb damage bounding box.
+ * @fb_top: y1 for fb damage bounding box.
+ */
+struct vmw_du_update_plane_buffer {
+	struct vmw_du_update_plane base;
+	int fb_left, fb_top;
+};
+
 /**
  * struct vmw_kms_dirty - closure structure for the vmw_kms_helper_dirty
  * function.

commit e41774c08ede53d96501f28f68645107f232960d
Author: Deepak Rawat <drawat@vmware.com>
Date:   Wed Jul 11 15:42:45 2018 -0700

    drm/vmwgfx: Add a new interface for plane update on a display unit
    
    Add a new struct vmw_du_update_plane similar to vmw_kms_dirty which
    represent the flow of operations needed to update a display unit from
    surface or bo (blit a new framebuffer).
    
    v2:
    - Kernel doc correction.
    - Rebase.
    
    v3: Rebase to new resource validation.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 76ec570c0684..f2f57e58dd88 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -33,7 +33,101 @@
 #include <drm/drm_encoder.h>
 #include "vmwgfx_drv.h"
 
+/**
+ * struct vmw_du_update_plane - Closure structure for vmw_du_helper_plane_update
+ * @plane: Plane which is being updated.
+ * @old_state: Old state of plane.
+ * @dev_priv: Device private.
+ * @du: Display unit on which to update the plane.
+ * @vfb: Framebuffer which is blitted to display unit.
+ * @out_fence: Out fence for resource finish.
+ * @mutex: The mutex used to protect resource reservation.
+ * @cpu_blit: True if need cpu blit.
+ * @intr: Whether to perform waits interruptible if possible.
+ *
+ * This structure loosely represent the set of operations needed to perform a
+ * plane update on a display unit. Implementer will define that functionality
+ * according to the function callbacks for this structure. In brief it involves
+ * surface/buffer object validation, populate FIFO commands and command
+ * submission to the device.
+ */
+struct vmw_du_update_plane {
+	/**
+	 * @calc_fifo_size: Calculate fifo size.
+	 *
+	 * Determine fifo size for the commands needed for update. The number of
+	 * damage clips on display unit @num_hits will be passed to allocate
+	 * sufficient fifo space.
+	 *
+	 * Return: Fifo size needed
+	 */
+	uint32_t (*calc_fifo_size)(struct vmw_du_update_plane *update,
+				   uint32_t num_hits);
+
+	/**
+	 * @post_prepare: Populate fifo for resource preparation.
+	 *
+	 * Some surface resource or buffer object need some extra cmd submission
+	 * like update GB image for proxy surface and define a GMRFB for screen
+	 * object. That should should be done here as this callback will be
+	 * called after FIFO allocation with the address of command buufer.
+	 *
+	 * This callback is optional.
+	 *
+	 * Return: Size of commands populated to command buffer.
+	 */
+	uint32_t (*post_prepare)(struct vmw_du_update_plane *update, void *cmd);
+
+	/**
+	 * @pre_clip: Populate fifo before clip.
+	 *
+	 * This is where pre clip related command should be populated like
+	 * surface copy/DMA, etc.
+	 *
+	 * This callback is optional.
+	 *
+	 * Return: Size of commands populated to command buffer.
+	 */
+	uint32_t (*pre_clip)(struct vmw_du_update_plane *update, void *cmd,
+			     uint32_t num_hits);
 
+	/**
+	 * @clip: Populate fifo for clip.
+	 *
+	 * This is where to populate clips for surface copy/dma or blit commands
+	 * if needed. This will be called times have damage in display unit,
+	 * which is one if doing full update. @clip is the damage in destination
+	 * coordinates which is crtc/DU and @src_x, @src_y is damage clip src in
+	 * framebuffer coordinate.
+	 *
+	 * This callback is optional.
+	 *
+	 * Return: Size of commands populated to command buffer.
+	 */
+	uint32_t (*clip)(struct vmw_du_update_plane *update, void *cmd,
+			 struct drm_rect *clip, uint32_t src_x, uint32_t src_y);
+
+	/**
+	 * @post_clip: Populate fifo after clip.
+	 *
+	 * This is where to populate display unit update commands or blit
+	 * commands.
+	 *
+	 * Return: Size of commands populated to command buffer.
+	 */
+	uint32_t (*post_clip)(struct vmw_du_update_plane *update, void *cmd,
+				    struct drm_rect *bb);
+
+	struct drm_plane *plane;
+	struct drm_plane_state *old_state;
+	struct vmw_private *dev_priv;
+	struct vmw_display_unit *du;
+	struct vmw_framebuffer *vfb;
+	struct vmw_fence_obj **out_fence;
+	struct mutex *mutex;
+	bool cpu_blit;
+	bool intr;
+};
 
 /**
  * struct vmw_kms_dirty - closure structure for the vmw_kms_helper_dirty
@@ -458,4 +552,21 @@ int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
 
 int vmw_kms_set_config(struct drm_mode_set *set,
 		       struct drm_modeset_acquire_ctx *ctx);
+
+int vmw_du_helper_plane_update(struct vmw_du_update_plane *update);
+
+/**
+ * vmw_du_translate_to_crtc - Translate a rect from framebuffer to crtc
+ * @state: Plane state.
+ * @r: Rectangle to translate.
+ */
+static inline void vmw_du_translate_to_crtc(struct drm_plane_state *state,
+					    struct drm_rect *r)
+{
+	int translate_crtc_x = -((state->src_x >> 16) - state->crtc_x);
+	int translate_crtc_y = -((state->src_y >> 16) - state->crtc_y);
+
+	drm_rect_translate(r, translate_crtc_x, translate_crtc_y);
+}
+
 #endif

commit 2724b2d54cdad7de12e53e7ff2666822bafeae2a
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Wed Sep 26 15:34:50 2018 +0200

    drm/vmwgfx: Use new validation interface for the modesetting code v2
    
    Strip the old KMS helpers and use the new validation interface also in
    the modesetting code.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Deepak Rawat <drawat@vmware.com> #v1
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 31311298ec0b..76ec570c0684 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -308,24 +308,12 @@ int vmw_kms_helper_dirty(struct vmw_private *dev_priv,
 			 int increment,
 			 struct vmw_kms_dirty *dirty);
 
-int vmw_kms_helper_buffer_prepare(struct vmw_private *dev_priv,
-				  struct vmw_buffer_object *buf,
-				  bool interruptible,
-				  bool validate_as_mob,
-				  bool for_cpu_blit);
-void vmw_kms_helper_buffer_revert(struct vmw_buffer_object *buf);
-void vmw_kms_helper_buffer_finish(struct vmw_private *dev_priv,
-				  struct drm_file *file_priv,
-				  struct vmw_buffer_object *buf,
-				  struct vmw_fence_obj **out_fence,
-				  struct drm_vmw_fence_rep __user *
-				  user_fence_rep);
-int vmw_kms_helper_resource_prepare(struct vmw_resource *res,
-				    bool interruptible,
-				    struct vmw_validation_ctx *ctx);
-void vmw_kms_helper_resource_revert(struct vmw_validation_ctx *ctx);
-void vmw_kms_helper_resource_finish(struct vmw_validation_ctx *ctx,
-				    struct vmw_fence_obj **out_fence);
+void vmw_kms_helper_validation_finish(struct vmw_private *dev_priv,
+				      struct drm_file *file_priv,
+				      struct vmw_validation_context *ctx,
+				      struct vmw_fence_obj **out_fence,
+				      struct drm_vmw_fence_rep __user *
+				      user_fence_rep);
 int vmw_kms_readback(struct vmw_private *dev_priv,
 		     struct drm_file *file_priv,
 		     struct vmw_framebuffer *vfb,

commit 8038d2a9e6cde825be46359ad98a084da92294fe
Merge: ba7ca97d73b4 812a954b787a
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Jul 10 11:05:46 2018 +1000

    Merge tag 'vmwgfx-next-4.19-2' of git://people.freedesktop.org/~thomash/linux into drm-next
    
    A series of cleanups / reorganizations and modesetting changes that
    mostly target atomic state validation.
    
    [airlied: conflicts with SPDX stuff in amdgpu tree]
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    Link: https://patchwork.freedesktop.org/patch/msgid/1a88485e-e509-b00e-8485-19194f074115@vmware.com

commit 3e79ecdad8897dad4d311576989b6856dbcb958e
Author: Deepak Rawat <drawat@vmware.com>
Date:   Wed Jun 20 11:34:26 2018 +0200

    drm/vmwgfx: Add gui_x/y to vmw_connector_state
    
    As gui_x/y positioning is display unit is protected by
    requested_layout_mutex adding vmw_connector_state copy of the same and
    modeset commit will refer the state copy to sync with modeset_check
    state.
    
    v2: Tested with CONFIG_PROVE_LOCKING enabled.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index ff1caed38f94..1f2b01862652 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -192,6 +192,24 @@ struct vmw_connector_state {
 	struct drm_connector_state base;
 
 	bool is_implicit;
+
+	/**
+	 * @gui_x:
+	 *
+	 * vmwgfx connector property representing the x position of this display
+	 * unit (connector is synonymous to display unit) in overall topology.
+	 * This is what the device expect as xRoot while creating screen.
+	 */
+	int gui_x;
+
+	/**
+	 * @gui_y:
+	 *
+	 * vmwgfx connector property representing the y position of this display
+	 * unit (connector is synonymous to display unit) in overall topology.
+	 * This is what the device expect as yRoot while creating screen.
+	 */
+	int gui_y;
 };
 
 /**

commit f1d34bfd70b1b4543a139ea28bad4c001c5f413d
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Tue Jun 19 15:02:16 2018 +0200

    drm/vmwgfx: Replace vmw_dma_buffer with vmw_buffer_object
    
    Initially vmware buffer objects were only used as DMA buffers, so the name
    DMA buffer was a natural one. However, currently they are used also as
    dumb buffers and MOBs backing guest backed objects so renaming them to
    buffer objects is logical. Particularly since there is a dmabuf subsystem
    in the kernel where a dma buffer means something completely different.
    
    This also renames user-space api structures and IOCTL names
    correspondingly, but the old names remain defined for now and the ABI
    hasn't changed.
    
    There are a couple of minor style changes to make checkpatch happy.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Deepak Rawat <drawat@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 6b7c012719f1..ff1caed38f94 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -90,7 +90,7 @@ struct vmw_kms_dirty {
 #define vmw_framebuffer_to_vfbs(x) \
 	container_of(x, struct vmw_framebuffer_surface, base.base)
 #define vmw_framebuffer_to_vfbd(x) \
-	container_of(x, struct vmw_framebuffer_dmabuf, base.base)
+	container_of(x, struct vmw_framebuffer_bo, base.base)
 
 /**
  * Base class for framebuffers
@@ -102,7 +102,7 @@ struct vmw_framebuffer {
 	struct drm_framebuffer base;
 	int (*pin)(struct vmw_framebuffer *fb);
 	int (*unpin)(struct vmw_framebuffer *fb);
-	bool dmabuf;
+	bool bo;
 	struct ttm_base_object *user_obj;
 	uint32_t user_handle;
 };
@@ -117,15 +117,15 @@ struct vmw_clip_rect {
 struct vmw_framebuffer_surface {
 	struct vmw_framebuffer base;
 	struct vmw_surface *surface;
-	struct vmw_dma_buffer *buffer;
+	struct vmw_buffer_object *buffer;
 	struct list_head head;
-	bool is_dmabuf_proxy;  /* true if this is proxy surface for DMA buf */
+	bool is_bo_proxy;  /* true if this is proxy surface for DMA buf */
 };
 
 
-struct vmw_framebuffer_dmabuf {
+struct vmw_framebuffer_bo {
 	struct vmw_framebuffer base;
-	struct vmw_dma_buffer *buffer;
+	struct vmw_buffer_object *buffer;
 };
 
 
@@ -161,18 +161,18 @@ struct vmw_crtc_state {
  *
  * @base DRM plane object
  * @surf Display surface for STDU
- * @dmabuf display dmabuf for SOU
+ * @bo display bo for SOU
  * @content_fb_type Used by STDU.
- * @dmabuf_size Size of the dmabuf, used by Screen Object Display Unit
+ * @bo_size Size of the bo, used by Screen Object Display Unit
  * @pinned pin count for STDU display surface
  */
 struct vmw_plane_state {
 	struct drm_plane_state base;
 	struct vmw_surface *surf;
-	struct vmw_dma_buffer *dmabuf;
+	struct vmw_buffer_object *bo;
 
 	int content_fb_type;
-	unsigned long dmabuf_size;
+	unsigned long bo_size;
 
 	int pinned;
 
@@ -209,7 +209,7 @@ struct vmw_display_unit {
 	struct drm_plane cursor;
 
 	struct vmw_surface *cursor_surface;
-	struct vmw_dma_buffer *cursor_dmabuf;
+	struct vmw_buffer_object *cursor_bo;
 	size_t cursor_age;
 
 	int cursor_x;
@@ -243,7 +243,7 @@ struct vmw_display_unit {
 
 struct vmw_validation_ctx {
 	struct vmw_resource *res;
-	struct vmw_dma_buffer *buf;
+	struct vmw_buffer_object *buf;
 };
 
 #define vmw_crtc_to_du(x) \
@@ -291,14 +291,14 @@ int vmw_kms_helper_dirty(struct vmw_private *dev_priv,
 			 struct vmw_kms_dirty *dirty);
 
 int vmw_kms_helper_buffer_prepare(struct vmw_private *dev_priv,
-				  struct vmw_dma_buffer *buf,
+				  struct vmw_buffer_object *buf,
 				  bool interruptible,
 				  bool validate_as_mob,
 				  bool for_cpu_blit);
-void vmw_kms_helper_buffer_revert(struct vmw_dma_buffer *buf);
+void vmw_kms_helper_buffer_revert(struct vmw_buffer_object *buf);
 void vmw_kms_helper_buffer_finish(struct vmw_private *dev_priv,
 				  struct drm_file *file_priv,
-				  struct vmw_dma_buffer *buf,
+				  struct vmw_buffer_object *buf,
 				  struct vmw_fence_obj **out_fence,
 				  struct drm_vmw_fence_rep __user *
 				  user_fence_rep);
@@ -316,7 +316,7 @@ int vmw_kms_readback(struct vmw_private *dev_priv,
 		     uint32_t num_clips);
 struct vmw_framebuffer *
 vmw_kms_new_framebuffer(struct vmw_private *dev_priv,
-			struct vmw_dma_buffer *dmabuf,
+			struct vmw_buffer_object *bo,
 			struct vmw_surface *surface,
 			bool only_2d,
 			const struct drm_mode_fb_cmd2 *mode_cmd);
@@ -384,11 +384,11 @@ void vmw_du_connector_destroy_state(struct drm_connector *connector,
  */
 int vmw_kms_ldu_init_display(struct vmw_private *dev_priv);
 int vmw_kms_ldu_close_display(struct vmw_private *dev_priv);
-int vmw_kms_ldu_do_dmabuf_dirty(struct vmw_private *dev_priv,
-				struct vmw_framebuffer *framebuffer,
-				unsigned flags, unsigned color,
-				struct drm_clip_rect *clips,
-				unsigned num_clips, int increment);
+int vmw_kms_ldu_do_bo_dirty(struct vmw_private *dev_priv,
+			    struct vmw_framebuffer *framebuffer,
+			    unsigned int flags, unsigned int color,
+			    struct drm_clip_rect *clips,
+			    unsigned int num_clips, int increment);
 int vmw_kms_update_proxy(struct vmw_resource *res,
 			 const struct drm_clip_rect *clips,
 			 unsigned num_clips,
@@ -408,14 +408,14 @@ int vmw_kms_sou_do_surface_dirty(struct vmw_private *dev_priv,
 				 unsigned num_clips, int inc,
 				 struct vmw_fence_obj **out_fence,
 				 struct drm_crtc *crtc);
-int vmw_kms_sou_do_dmabuf_dirty(struct vmw_private *dev_priv,
-				struct vmw_framebuffer *framebuffer,
-				struct drm_clip_rect *clips,
-				struct drm_vmw_rect *vclips,
-				unsigned num_clips, int increment,
-				bool interruptible,
-				struct vmw_fence_obj **out_fence,
-				struct drm_crtc *crtc);
+int vmw_kms_sou_do_bo_dirty(struct vmw_private *dev_priv,
+			    struct vmw_framebuffer *framebuffer,
+			    struct drm_clip_rect *clips,
+			    struct drm_vmw_rect *vclips,
+			    unsigned int num_clips, int increment,
+			    bool interruptible,
+			    struct vmw_fence_obj **out_fence,
+			    struct drm_crtc *crtc);
 int vmw_kms_sou_readback(struct vmw_private *dev_priv,
 			 struct drm_file *file_priv,
 			 struct vmw_framebuffer *vfb,

commit dff96888860a9ebaa618be973b51f4d86aec1211
Author: Dirk Hohndel (VMware) <dirk@hohndel.org>
Date:   Mon May 7 01:16:26 2018 +0200

    drm/vmwgfx: add SPDX idenitifier and clarify license
    
    This is dual licensed under GPL-2.0 or MIT.
    vmwgfx_msg.h is the odd one out that is GPL-2.0+ or MIT.
    
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Dirk Hohndel (VMware) <dirk@hohndel.org>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180506231626.115996-9-dirk@hohndel.org

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 6b7c012719f1..27c41c227120 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -1,7 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0 OR MIT */
 /**************************************************************************
  *
- * Copyright © 2009-2015 VMware, Inc., Palo Alto, CA., USA
- * All Rights Reserved.
+ * Copyright 2009-2015 VMware, Inc., Palo Alto, CA., USA
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the

commit 2b4f44eec2be2688511c2b617d0e1b4f94c45ba4
Merge: 33d009cd8894 3eb2ce825ea1
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Mar 28 14:30:41 2018 +1000

    Backmerge tag 'v4.16-rc7' into drm-next
    
    Linux 4.16-rc7
    
    This was requested by Daniel, and things were getting
    a bit hard to reconcile, most of the conflicts were
    trivial though.

commit ef86cfee7d74baf2e3b883871087a684acecb595
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Tue Jan 16 11:07:30 2018 +0100

    drm/vmwgfx: Use the cpu blit utility for framebuffer to screen target blits
    
    This blit was previously performed using two large vmaps, one of which
    was teared down and remapped on each blit. Use the more resource-
    conserving TTM cpu blit instead.
    
    The blit is used in boundary-box computing mode which makes it possible
    to minimize the bounding box used in host operations.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Brian Paul <brianp@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 42b0f1589d3f..4e8749a8717e 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -177,7 +177,6 @@ struct vmw_plane_state {
 	int pinned;
 
 	/* For CPU Blit */
-	struct ttm_bo_kmap_obj host_map;
 	unsigned int cpp;
 };
 
@@ -289,7 +288,8 @@ int vmw_kms_helper_dirty(struct vmw_private *dev_priv,
 int vmw_kms_helper_buffer_prepare(struct vmw_private *dev_priv,
 				  struct vmw_dma_buffer *buf,
 				  bool interruptible,
-				  bool validate_as_mob);
+				  bool validate_as_mob,
+				  bool for_cpu_blit);
 void vmw_kms_helper_buffer_revert(struct vmw_dma_buffer *buf);
 void vmw_kms_helper_buffer_finish(struct vmw_private *dev_priv,
 				  struct drm_file *file_priv,

commit 91e9f352cd1b79772b4883fd31e04655d4a97318
Author: Deepak Rawat <drawat@vmware.com>
Date:   Tue Jan 16 08:24:17 2018 +0100

    drm/vmwgfx: Avoid iterating over display unit if crtc is available
    
    In case of page flip there is no need to iterate over all display unit
    in the function "vmw_kms_helper_dirty". If crtc is available then
    dirty commands is performed on that crtc only.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index cd9da2dd79af..42b0f1589d3f 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -50,6 +50,7 @@
  * @unit: The current display unit. Set up by the helper before a call to @clip.
  * @cmd: The allocated fifo space. Set up by the helper before the first @clip
  * call.
+ * @crtc: The crtc for which to build dirty commands.
  * @num_hits: Number of clip rect commands for this display unit.
  * Cleared by the helper before the first @clip call. Updated by the @clip
  * callback.
@@ -71,6 +72,7 @@ struct vmw_kms_dirty {
 	struct vmw_private *dev_priv;
 	struct vmw_display_unit *unit;
 	void *cmd;
+	struct drm_crtc *crtc;
 	u32 num_hits;
 	s32 fb_x;
 	s32 fb_y;
@@ -398,20 +400,23 @@ int vmw_kms_sou_do_surface_dirty(struct vmw_private *dev_priv,
 				 s32 dest_x,
 				 s32 dest_y,
 				 unsigned num_clips, int inc,
-				 struct vmw_fence_obj **out_fence);
+				 struct vmw_fence_obj **out_fence,
+				 struct drm_crtc *crtc);
 int vmw_kms_sou_do_dmabuf_dirty(struct vmw_private *dev_priv,
 				struct vmw_framebuffer *framebuffer,
 				struct drm_clip_rect *clips,
 				struct drm_vmw_rect *vclips,
 				unsigned num_clips, int increment,
 				bool interruptible,
-				struct vmw_fence_obj **out_fence);
+				struct vmw_fence_obj **out_fence,
+				struct drm_crtc *crtc);
 int vmw_kms_sou_readback(struct vmw_private *dev_priv,
 			 struct drm_file *file_priv,
 			 struct vmw_framebuffer *vfb,
 			 struct drm_vmw_fence_rep __user *user_fence_rep,
 			 struct drm_vmw_rect *vclips,
-			 uint32_t num_clips);
+			 uint32_t num_clips,
+			 struct drm_crtc *crtc);
 
 /*
  * Screen Target Display Unit functions - vmwgfx_stdu.c
@@ -425,7 +430,8 @@ int vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,
 			       s32 dest_x,
 			       s32 dest_y,
 			       unsigned num_clips, int inc,
-			       struct vmw_fence_obj **out_fence);
+			       struct vmw_fence_obj **out_fence,
+			       struct drm_crtc *crtc);
 int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
 		     struct drm_file *file_priv,
 		     struct vmw_framebuffer *vfb,
@@ -435,7 +441,8 @@ int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
 		     uint32_t num_clips,
 		     int increment,
 		     bool to_surface,
-		     bool interruptible);
+		     bool interruptible,
+		     struct drm_crtc *crtc);
 
 int vmw_kms_set_config(struct drm_mode_set *set,
 		       struct drm_modeset_acquire_ctx *ctx);

commit 73a88250b70954a8f27c2444e1c2411bba3c29d9
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Wed Mar 21 10:18:38 2018 +0100

    drm/vmwgfx: Fix a destoy-while-held mutex problem.
    
    When validating legacy surfaces, the backup bo might be destroyed at
    surface validate time. However, the kms resource validation code may have
    the bo reserved, so we will destroy a locked mutex. While there shouldn't
    be any other users of that mutex when it is destroyed, it causes a lock
    leak and thus throws a lockdep error.
    
    Fix this by having the kms resource validation code hold a reference to
    the bo while we have it reserved. We do this by introducing a validation
    context which might come in handy when the kms code is extended to validate
    multiple resources or buffers.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Brian Paul <brianp@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 948362c43c73..3d2ca280eaa7 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -240,6 +240,11 @@ struct vmw_display_unit {
 	int set_gui_y;
 };
 
+struct vmw_validation_ctx {
+	struct vmw_resource *res;
+	struct vmw_dma_buffer *buf;
+};
+
 #define vmw_crtc_to_du(x) \
 	container_of(x, struct vmw_display_unit, crtc)
 #define vmw_connector_to_du(x) \
@@ -296,9 +301,10 @@ void vmw_kms_helper_buffer_finish(struct vmw_private *dev_priv,
 				  struct drm_vmw_fence_rep __user *
 				  user_fence_rep);
 int vmw_kms_helper_resource_prepare(struct vmw_resource *res,
-				    bool interruptible);
-void vmw_kms_helper_resource_revert(struct vmw_resource *res);
-void vmw_kms_helper_resource_finish(struct vmw_resource *res,
+				    bool interruptible,
+				    struct vmw_validation_ctx *ctx);
+void vmw_kms_helper_resource_revert(struct vmw_validation_ctx *ctx);
+void vmw_kms_helper_resource_finish(struct vmw_validation_ctx *ctx,
 				    struct vmw_fence_obj **out_fence);
 int vmw_kms_readback(struct vmw_private *dev_priv,
 		     struct drm_file *file_priv,

commit 140bcaa23a1c37b694910424075a15e009120dbe
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Thu Mar 8 10:07:37 2018 +0100

    drm/vmwgfx: Fix black screen and device errors when running without fbdev
    
    When we are running without fbdev, transitioning from the login screen to
    X or gnome-shell/wayland will cause a vt switch and the driver will disable
    svga mode, losing all modesetting resources. However, the kms atomic state
    does not reflect that and may think that a crtc is still turned on, which
    will cause device errors when we try to bind an fb to the crtc, and the
    screen will remain black.
    
    Fix this by turning off all kms resources before disabling svga mode.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index cd9da2dd79af..948362c43c73 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -439,5 +439,4 @@ int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
 
 int vmw_kms_set_config(struct drm_mode_set *set,
 		       struct drm_modeset_acquire_ctx *ctx);
-
 #endif

commit 98648ae6ef6bdcdcb88c46cad963906ab452e96d
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Tue Jan 9 15:33:42 2018 +0100

    drm/vmwgfx: Don't cache framebuffer maps
    
    Buffer objects need to be either pinned or reserved while a map is active,
    that's not the case here, so avoid caching the framebuffer map.
    This will cause increasing mapping activity mainly when we don't do
    page flipping.
    
    This fixes occasional garbage filled screens when the framebuffer has been
    evicted after the map.
    
    Since in-kernel mapping of whole buffer objects is error-prone on 32-bit
    architectures and also quite inefficient, we will revisit this later.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Cc: <stable@vger.kernel.org>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index ff9c8389ff21..cd9da2dd79af 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -175,7 +175,7 @@ struct vmw_plane_state {
 	int pinned;
 
 	/* For CPU Blit */
-	struct ttm_bo_kmap_obj host_map, guest_map;
+	struct ttm_bo_kmap_obj host_map;
 	unsigned int cpp;
 };
 

commit b740e76936c14354a9c5676a3eed839ea8472c41
Merge: 7141fd3e5ba9 6d61e70ccc21
Author: Sean Paul <seanpaul@chromium.org>
Date:   Tue Jun 27 09:18:17 2017 -0400

    Merge remote-tracking branch 'airlied/drm-next' into drm-misc-next
    
    Required for Daniel's drm_vblank_cleanup cleanup

commit 5f58e9742df3f1cdf1034a26569649f5f4fd776b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jun 26 18:19:48 2017 +0200

    drm/vmwgfx: Drop drm_vblank_cleanup
    
    Again stopping the vblank before uninstalling the irq handler is kinda
    the wrong way round, but the fb_off stuff should take care of
    disabling the dsiplay at least in most cases. So drop the
    drm_vblank_cleanup code since it's not really doing anything, it looks
    all cargo-culted.
    
    v2: Appease gcc better.
    
    v3: Simplify code (Sean Paul)
    
    Cc: Sinclair Yeh <syeh@vmware.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170626161949.25629-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 13f2f1d2818a..f94b4ca38ab2 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -405,7 +405,6 @@ int vmw_kms_update_proxy(struct vmw_resource *res,
  * Screen Objects display functions - vmwgfx_scrn.c
  */
 int vmw_kms_sou_init_display(struct vmw_private *dev_priv);
-int vmw_kms_sou_close_display(struct vmw_private *dev_priv);
 int vmw_kms_sou_do_surface_dirty(struct vmw_private *dev_priv,
 				 struct vmw_framebuffer *framebuffer,
 				 struct drm_clip_rect *clips,
@@ -433,7 +432,6 @@ int vmw_kms_sou_readback(struct vmw_private *dev_priv,
  * Screen Target Display Unit functions - vmwgfx_stdu.c
  */
 int vmw_kms_stdu_init_display(struct vmw_private *dev_priv);
-int vmw_kms_stdu_close_display(struct vmw_private *dev_priv);
 int vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,
 			       struct vmw_framebuffer *framebuffer,
 			       struct drm_clip_rect *clips,

commit f470a7740f8c7577df1db5923ec89d890cf32040
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Wed Jun 7 14:24:08 2017 +0200

    drm/vmwgfx: Remove unused legacy cursor functions
    
    These function implementations and/or declarations are no longer used
    now that atomic is enabled.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reported-by: Daniel Vetter <daniel@ffwll.ch>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 13f2f1d2818a..5f8d678ae675 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -256,10 +256,6 @@ int vmw_du_crtc_gamma_set(struct drm_crtc *crtc,
 			   u16 *r, u16 *g, u16 *b,
 			   uint32_t size,
 			   struct drm_modeset_acquire_ctx *ctx);
-int vmw_du_crtc_cursor_set2(struct drm_crtc *crtc, struct drm_file *file_priv,
-			    uint32_t handle, uint32_t width, uint32_t height,
-			    int32_t hot_x, int32_t hot_y);
-int vmw_du_crtc_cursor_move(struct drm_crtc *crtc, int x, int y);
 int vmw_du_connector_set_property(struct drm_connector *connector,
 				  struct drm_property *property,
 				  uint64_t val);
@@ -339,15 +335,6 @@ void vmw_kms_create_implicit_placement_property(struct vmw_private *dev_priv,
 /* Universal Plane Helpers */
 void vmw_du_primary_plane_destroy(struct drm_plane *plane);
 void vmw_du_cursor_plane_destroy(struct drm_plane *plane);
-int vmw_du_cursor_plane_disable(struct drm_plane *plane);
-int vmw_du_cursor_plane_update(struct drm_plane *plane,
-			       struct drm_crtc *crtc,
-			       struct drm_framebuffer *fb,
-			       int crtc_x, int crtc_y,
-			       unsigned int crtc_w,
-			       unsigned int crtc_h,
-			       uint32_t src_x, uint32_t src_y,
-			       uint32_t src_w, uint32_t src_h);
 
 /* Atomic Helpers */
 int vmw_du_primary_plane_atomic_check(struct drm_plane *plane,
@@ -356,8 +343,6 @@ int vmw_du_cursor_plane_atomic_check(struct drm_plane *plane,
 				     struct drm_plane_state *state);
 void vmw_du_cursor_plane_atomic_update(struct drm_plane *plane,
 				       struct drm_plane_state *old_state);
-void vmw_du_cursor_plane_atomic_disable(struct drm_plane *plane,
-					struct drm_plane_state *old_state);
 int vmw_du_cursor_plane_prepare_fb(struct drm_plane *plane,
 				   struct drm_plane_state *new_state);
 void vmw_du_plane_cleanup_fb(struct drm_plane *plane,

commit 6d124ff845334bc466f56c059147e7ad587c2e7e
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Apr 3 10:33:01 2017 +0200

    drm: Add acquire ctx to ->gamma_set hook
    
    Atomic helpers really want this instead of the hacked-up legacy
    backoff trick, which unfortunately prevents drivers from using their
    own private drm_modeset_locks.
    
    Aside: There's a few atomic drivers (nv50, vc4, soon vmwgfx) which
    don't yet use the new atomic color mgmt/gamma table stuff. Would be
    nice if they could switch over and just hook up
    drm_atomic_helper_legacy_gamma_set() instead.
    
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Christian König <christian.koenig@amd.com>
    Cc: Gerd Hoffmann <kraxel@redhat.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Sinclair Yeh <syeh@vmware.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Eric Anholt <eric@anholt.net>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170403083304.9083-13-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 0c226b2adea5..13f2f1d2818a 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -254,7 +254,8 @@ void vmw_du_crtc_save(struct drm_crtc *crtc);
 void vmw_du_crtc_restore(struct drm_crtc *crtc);
 int vmw_du_crtc_gamma_set(struct drm_crtc *crtc,
 			   u16 *r, u16 *g, u16 *b,
-			   uint32_t size);
+			   uint32_t size,
+			   struct drm_modeset_acquire_ctx *ctx);
 int vmw_du_crtc_cursor_set2(struct drm_crtc *crtc, struct drm_file *file_priv,
 			    uint32_t handle, uint32_t width, uint32_t height,
 			    int32_t hot_x, int32_t hot_y);

commit 320d8c3d38739fa8e31a076b86cbdafcf8897d5e
Merge: 7558ab66424e b121b051d14c
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Apr 3 16:30:24 2017 +1000

    Merge tag 'drm-misc-next-2017-03-31' of git://anongit.freedesktop.org/git/drm-misc into drm-next
    
    drm-misc for 4.12:
    
    Core:
    - Removed some fb subsampling dimension checks from core (Ville)
    - Some MST slot cleanup (Dhinakaran)
    - Extracted drm_debugfs.h & drm_ioctl.h from drmP.h (Daniel)
    - Added drm_atomic_helper_shutdown() to compliment suspend/resume counterparts
      (Daniel)
    - Pipe context through legacy modeset to remove legacy_backoff nasties (Daniel)
    - Cleanups around vblank as well as allowing lockless counter reads (Chris W.)
    - VGA Switcheroo added to MAINTAINERS with Lukas Wunner as reviewer (Lukas)
    
    Drivers:
    - Enhancements to rockchip driver probe (Jeffy) and dsi (Chris Z.)
    - Thunderbolt external GPU awareness added (Lukas)
    
    * tag 'drm-misc-next-2017-03-31' of git://anongit.freedesktop.org/git/drm-misc: (63 commits)
      apple-gmux: Don't switch external DP port on 2011+ MacBook Pros
      drm/nouveau: Don't register Thunderbolt eGPU with vga_switcheroo
      drm/amdgpu: Don't register Thunderbolt eGPU with vga_switcheroo
      drm/radeon: Don't register Thunderbolt eGPU with vga_switcheroo
      PCI: Recognize Thunderbolt devices
      MAINTAINERS: Add Lukas Wunner as reviewer for vga_switcheroo
      drm: Fix locking gotcha in page_flip ioctl
      drm: Clarify the role of plane_state argument to drm_simple update().
      drm: Clear e after kfree in drm_mode_page_flip_ioctl
      drm: Convert cmpxchg(bool) back to a two step operation
      drm/bridge: ti-tfp410: support hpd via gpio
      drm: use .hword to represent 16-bit numbers
      Revert unrelated part of "drm: simplify the locking in the GETCRTC ioctl"
      drm: Fixup failure paths in drm_atomic_helper_set_config
      drm: Peek at the current counter/timestamp for vblank queries
      drm: Refactor vblank sequence number comparison
      drm: vblank cannot be enabled if dev->irq_enabled is false
      drm: Mark up accesses of vblank->enabled outside of its spinlock
      drm: Make the decision to keep vblank irq enabled earlier
      drm/atomic-helper: Remove the backoff hack from set_config
      ...

commit 810b3e1683d00e51c8392bcee7dc7a1c65354777
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 15:39:16 2017 -0700

    drm/vmwgfx: Support topology greater than texture size
    
    Most of the display servers today use a single surface to represent the
    entire desktop even if it's stretched across multiple screens.
    
    For vmwgfx with STDU, the maximum surface size is limited to the
    maximum texture size on the host.  On a 2D VM, this limits our
    ability to support configurations with more than one 4K monitor.
    
    To get past this limitation, we will now allow using a large DMA buf
    as the framebuffer, and take care of blitting contents from this DMA buf
    to the display buffer.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 7689f477b726..9c161d29aaeb 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -173,6 +173,10 @@ struct vmw_plane_state {
 	unsigned long dmabuf_size;
 
 	int pinned;
+
+	/* For CPU Blit */
+	struct ttm_bo_kmap_obj host_map, guest_map;
+	unsigned int cpp;
 };
 
 

commit 904bb5e5817f5c5b42e6e3775699c728fd420284
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 14:29:22 2017 -0700

    drm/vmwgfx: Switch over to internal atomic API for STDU
    
    Switch over to using internal atomic API for mode set.
    
    This removes the legacy set_config API, replacing it with
    drm_atomic_helper_set_config().  The DRM helper will use various
    vmwgfx-specific atomic functions to set a mode.
    
    DRIVER_ATOMIC capability flag is not yet set, so the user mode
    will still use the legacy mode set IOCTL.
    
    v2:
    * Avoid a clash between page-flip pinning and setcrtc pinning, modify
    the page-flip code to use the page-flip helper and the atomic callbacks.
    To enable this, we will need to add a wrapper around atomic_commit.
    
    * Add vmw_kms_set_config() to work around vmwgfx xorg driver bug
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index de6a0b64bb4b..7689f477b726 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -449,5 +449,6 @@ int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
 		     bool to_surface,
 		     bool interruptible);
 
+int vmw_kms_set_config(struct drm_mode_set *set);
 
 #endif

commit 060e2ad57041b42ccecd0047ef4d893f200692c2
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 14:18:32 2017 -0700

    drm/vmwgfx: Add and connect plane helper functions
    
    Refactor previous FB and cursor plane update code into their
    atomic counterparts: check, update, prepare, cleanup, and disable.
    
    These helpers won't be called until we flip on the atomic support
    flag or set drm_crtc_funcs->set_config to using the atomic
    helper.
    
    v2:
    * Removed unnecessary pinning of cursor surface
    * Added a few function headers
    
    v3:
    * Set clip region equal to the destination region
    * Fixed surface pinning policy
    * Enable SVGA mode in vmw_sou_primary_plane_prepare_fb
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index f711b5da73e5..de6a0b64bb4b 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -345,10 +345,25 @@ int vmw_du_cursor_plane_update(struct drm_plane *plane,
 			       uint32_t src_w, uint32_t src_h);
 
 /* Atomic Helpers */
+int vmw_du_primary_plane_atomic_check(struct drm_plane *plane,
+				      struct drm_plane_state *state);
+int vmw_du_cursor_plane_atomic_check(struct drm_plane *plane,
+				     struct drm_plane_state *state);
+void vmw_du_cursor_plane_atomic_update(struct drm_plane *plane,
+				       struct drm_plane_state *old_state);
+void vmw_du_cursor_plane_atomic_disable(struct drm_plane *plane,
+					struct drm_plane_state *old_state);
+int vmw_du_cursor_plane_prepare_fb(struct drm_plane *plane,
+				   struct drm_plane_state *new_state);
+void vmw_du_plane_cleanup_fb(struct drm_plane *plane,
+			     struct drm_plane_state *old_state);
 void vmw_du_plane_reset(struct drm_plane *plane);
 struct drm_plane_state *vmw_du_plane_duplicate_state(struct drm_plane *plane);
 void vmw_du_plane_destroy_state(struct drm_plane *plane,
 				struct drm_plane_state *state);
+void vmw_du_plane_unpin_surf(struct vmw_plane_state *vps,
+			     bool unreference);
+
 int vmw_du_crtc_atomic_check(struct drm_crtc *crtc,
 			     struct drm_crtc_state *state);
 void vmw_du_crtc_atomic_begin(struct drm_crtc *crtc,

commit 06ec41909e31be3347f8679e9667d12ac6f7ee6e
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 13:14:54 2017 -0700

    drm/vmwgfx: Add and connect CRTC helper functions
    
    Atomic mode set requires us to refactor existing vmw_stdu_crtc_set_config
    code into sections that check the validity of the new mode, and sections
    that actually program the hardware state.
    
    vmw_du_crtc_atomic_check() takes CRTC-related checking code.  In a later
    patch, vmw_du_primary_plane_atomic_check() will take framebuffer-related
    checking code.
    
    These helpers won't be called until we flip on the atomic support
    flag or set drm_crtc_funcs->set_config to using the atomic
    helper.
    
    v2:
    * The state->num_connector is actually the total number of potential
      connectors, not just the one associated with the display unit.
      The proper one to check is ->connector_mask.
    
    * Add the check to only allow plane state to be the same as crtc state
      (Thanks to mlankhorst)
    
    * Make sure to turn on SVGA mode before using VRAM.  SVGA mode is
      disabled in master_drop if dbdev is not running.
    
    v3:
    * Moved dot clock override to crtc_atomic_check
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index cc50bf35aeca..f711b5da73e5 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -161,6 +161,7 @@ struct vmw_crtc_state {
  * @surf Display surface for STDU
  * @dmabuf display dmabuf for SOU
  * @content_fb_type Used by STDU.
+ * @dmabuf_size Size of the dmabuf, used by Screen Object Display Unit
  * @pinned pin count for STDU display surface
  */
 struct vmw_plane_state {
@@ -169,6 +170,7 @@ struct vmw_plane_state {
 	struct vmw_dma_buffer *dmabuf;
 
 	int content_fb_type;
+	unsigned long dmabuf_size;
 
 	int pinned;
 };
@@ -342,10 +344,17 @@ int vmw_du_cursor_plane_update(struct drm_plane *plane,
 			       uint32_t src_x, uint32_t src_y,
 			       uint32_t src_w, uint32_t src_h);
 
+/* Atomic Helpers */
 void vmw_du_plane_reset(struct drm_plane *plane);
 struct drm_plane_state *vmw_du_plane_duplicate_state(struct drm_plane *plane);
 void vmw_du_plane_destroy_state(struct drm_plane *plane,
 				struct drm_plane_state *state);
+int vmw_du_crtc_atomic_check(struct drm_crtc *crtc,
+			     struct drm_crtc_state *state);
+void vmw_du_crtc_atomic_begin(struct drm_crtc *crtc,
+			      struct drm_crtc_state *old_crtc_state);
+void vmw_du_crtc_atomic_flush(struct drm_crtc *crtc,
+			      struct drm_crtc_state *old_crtc_state);
 void vmw_du_crtc_reset(struct drm_crtc *crtc);
 struct drm_crtc_state *vmw_du_crtc_duplicate_state(struct drm_crtc *crtc);
 void vmw_du_crtc_destroy_state(struct drm_crtc *crtc,

commit d7721ca71126b222fb5d66af444d33950a0e3ba3
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 11:48:44 2017 -0700

    drm/vmwgfx: Connector atomic state
    
    Add connector handling functions. Start tracking is_implicity in
    the connector state.  Eventually, this field should be tracked
    exclusively in a connector state.
    
    Now that plane and connector states have been created, we can also
    activate the code that use CRTC state.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 5602c2430719..cc50bf35aeca 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -142,7 +142,8 @@ static const uint32_t vmw_cursor_plane_formats[] = {
 
 #define vmw_crtc_state_to_vcs(x) container_of(x, struct vmw_crtc_state, base)
 #define vmw_plane_state_to_vps(x) container_of(x, struct vmw_plane_state, base)
-
+#define vmw_connector_state_to_vcs(x) \
+		container_of(x, struct vmw_connector_state, base)
 
 /**
  * Derived class for crtc state object
@@ -172,6 +173,20 @@ struct vmw_plane_state {
 	int pinned;
 };
 
+
+/**
+ * Derived class for connector state object
+ *
+ * @base DRM connector object
+ * @is_implicit connector property
+ *
+ */
+struct vmw_connector_state {
+	struct drm_connector_state base;
+
+	bool is_implicit;
+};
+
 /**
  * Base class display unit.
  *
@@ -241,6 +256,15 @@ int vmw_du_crtc_cursor_move(struct drm_crtc *crtc, int x, int y);
 int vmw_du_connector_set_property(struct drm_connector *connector,
 				  struct drm_property *property,
 				  uint64_t val);
+int vmw_du_connector_atomic_set_property(struct drm_connector *connector,
+					 struct drm_connector_state *state,
+					 struct drm_property *property,
+					 uint64_t val);
+int
+vmw_du_connector_atomic_get_property(struct drm_connector *connector,
+				     const struct drm_connector_state *state,
+				     struct drm_property *property,
+				     uint64_t *val);
 int vmw_du_connector_dpms(struct drm_connector *connector, int mode);
 void vmw_du_connector_save(struct drm_connector *connector);
 void vmw_du_connector_restore(struct drm_connector *connector);
@@ -326,6 +350,12 @@ void vmw_du_crtc_reset(struct drm_crtc *crtc);
 struct drm_crtc_state *vmw_du_crtc_duplicate_state(struct drm_crtc *crtc);
 void vmw_du_crtc_destroy_state(struct drm_crtc *crtc,
 				struct drm_crtc_state *state);
+void vmw_du_connector_reset(struct drm_connector *connector);
+struct drm_connector_state *
+vmw_du_connector_duplicate_state(struct drm_connector *connector);
+
+void vmw_du_connector_destroy_state(struct drm_connector *connector,
+				    struct drm_connector_state *state);
 
 /*
  * Legacy display unit functions - vmwgfx_ldu.c

commit cc5ec459de323fe32514d5f47a4d00460ee30f7b
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 11:36:05 2017 -0700

    drm/vmwgfx: Plane atomic state
    
    Add plane state handling functions.
    
    We have to keep track of a few plane states so we cannot use the
    DRM helper for this.
    
    Created vmw_plane_state along with functions to reset, duplicate,
    and destroty it.
    
    v2
    * Removed cursor clean up special case
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 370f75c95f56..5602c2430719 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -141,6 +141,7 @@ static const uint32_t vmw_cursor_plane_formats[] = {
 
 
 #define vmw_crtc_state_to_vcs(x) container_of(x, struct vmw_crtc_state, base)
+#define vmw_plane_state_to_vps(x) container_of(x, struct vmw_plane_state, base)
 
 
 /**
@@ -152,6 +153,25 @@ struct vmw_crtc_state {
 	struct drm_crtc_state base;
 };
 
+/**
+ * Derived class for plane state object
+ *
+ * @base DRM plane object
+ * @surf Display surface for STDU
+ * @dmabuf display dmabuf for SOU
+ * @content_fb_type Used by STDU.
+ * @pinned pin count for STDU display surface
+ */
+struct vmw_plane_state {
+	struct drm_plane_state base;
+	struct vmw_surface *surf;
+	struct vmw_dma_buffer *dmabuf;
+
+	int content_fb_type;
+
+	int pinned;
+};
+
 /**
  * Base class display unit.
  *
@@ -298,6 +318,10 @@ int vmw_du_cursor_plane_update(struct drm_plane *plane,
 			       uint32_t src_x, uint32_t src_y,
 			       uint32_t src_w, uint32_t src_h);
 
+void vmw_du_plane_reset(struct drm_plane *plane);
+struct drm_plane_state *vmw_du_plane_duplicate_state(struct drm_plane *plane);
+void vmw_du_plane_destroy_state(struct drm_plane *plane,
+				struct drm_plane_state *state);
 void vmw_du_crtc_reset(struct drm_crtc *crtc);
 struct drm_crtc_state *vmw_du_crtc_duplicate_state(struct drm_crtc *crtc);
 void vmw_du_crtc_destroy_state(struct drm_crtc *crtc,

commit 9c2542a41f559452d570b96239a81038c49becfc
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 11:33:39 2017 -0700

    drm/vmwgfx: CRTC atomic state
    
    Create and Add CRTC state.  We currently do not track any properties
    or custom states so we can technically use the DRM helpers.  Creating
    this code just to make potential future additions easier.
    
    Most of the new code will be compiled but not enabled until
    plane/connector state handling code is also in place.
    
    This is the first of a series to enable atomic mode set for vmwgfx.
    
    The atomic enabling effort was done in collaboration with Thomas
    Hellstrom and the VMware Graphics Team.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index e400bfb26167..370f75c95f56 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -139,6 +139,19 @@ static const uint32_t vmw_cursor_plane_formats[] = {
 	DRM_FORMAT_ARGB8888,
 };
 
+
+#define vmw_crtc_state_to_vcs(x) container_of(x, struct vmw_crtc_state, base)
+
+
+/**
+ * Derived class for crtc state object
+ *
+ * @base DRM crtc object
+ */
+struct vmw_crtc_state {
+	struct drm_crtc_state base;
+};
+
 /**
  * Base class display unit.
  *
@@ -205,6 +218,9 @@ int vmw_du_crtc_cursor_set2(struct drm_crtc *crtc, struct drm_file *file_priv,
 			    uint32_t handle, uint32_t width, uint32_t height,
 			    int32_t hot_x, int32_t hot_y);
 int vmw_du_crtc_cursor_move(struct drm_crtc *crtc, int x, int y);
+int vmw_du_connector_set_property(struct drm_connector *connector,
+				  struct drm_property *property,
+				  uint64_t val);
 int vmw_du_connector_dpms(struct drm_connector *connector, int mode);
 void vmw_du_connector_save(struct drm_connector *connector);
 void vmw_du_connector_restore(struct drm_connector *connector);
@@ -212,9 +228,6 @@ enum drm_connector_status
 vmw_du_connector_detect(struct drm_connector *connector, bool force);
 int vmw_du_connector_fill_modes(struct drm_connector *connector,
 				uint32_t max_width, uint32_t max_height);
-int vmw_du_connector_set_property(struct drm_connector *connector,
-				  struct drm_property *property,
-				  uint64_t val);
 int vmw_kms_helper_dirty(struct vmw_private *dev_priv,
 			 struct vmw_framebuffer *framebuffer,
 			 const struct drm_clip_rect *clips,
@@ -285,6 +298,10 @@ int vmw_du_cursor_plane_update(struct drm_plane *plane,
 			       uint32_t src_x, uint32_t src_y,
 			       uint32_t src_w, uint32_t src_h);
 
+void vmw_du_crtc_reset(struct drm_crtc *crtc);
+struct drm_crtc_state *vmw_du_crtc_duplicate_state(struct drm_crtc *crtc);
+void vmw_du_crtc_destroy_state(struct drm_crtc *crtc,
+				struct drm_crtc_state *state);
 
 /*
  * Legacy display unit functions - vmwgfx_ldu.c

commit 36cc79bc9077319c04bd3b132edcacaa9a0d9f2b
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 11:28:11 2017 -0700

    drm/vmwgfx: Add universal plane support
    
    Universal support is prerequisite for atomic mode set.
    
    Explicitly create planes for the cursor and the primary FB.  With
    a functional cursor plane, the DRM will no longer use the legacy
    cursor_set2 and cursor_move entry points.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index cb36e1d70133..e400bfb26167 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -33,6 +33,8 @@
 #include <drm/drm_encoder.h>
 #include "vmwgfx_drv.h"
 
+
+
 /**
  * struct vmw_kms_dirty - closure structure for the vmw_kms_helper_dirty
  * function.
@@ -125,19 +127,17 @@ struct vmw_framebuffer_dmabuf {
 };
 
 
-/*
- * Basic cursor manipulation
- */
-int vmw_cursor_update_image(struct vmw_private *dev_priv,
-			    u32 *image, u32 width, u32 height,
-			    u32 hotspotX, u32 hotspotY);
-int vmw_cursor_update_dmabuf(struct vmw_private *dev_priv,
-			     struct vmw_dma_buffer *dmabuf,
-			     u32 width, u32 height,
-			     u32 hotspotX, u32 hotspotY);
-void vmw_cursor_update_position(struct vmw_private *dev_priv,
-				bool show, int x, int y);
+static const uint32_t vmw_primary_plane_formats[] = {
+	DRM_FORMAT_XRGB1555,
+	DRM_FORMAT_RGB565,
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_ARGB8888,
+};
 
+static const uint32_t vmw_cursor_plane_formats[] = {
+	DRM_FORMAT_ARGB8888,
+};
 
 /**
  * Base class display unit.
@@ -150,6 +150,8 @@ struct vmw_display_unit {
 	struct drm_crtc crtc;
 	struct drm_encoder encoder;
 	struct drm_connector connector;
+	struct drm_plane primary;
+	struct drm_plane cursor;
 
 	struct vmw_surface *cursor_surface;
 	struct vmw_dma_buffer *cursor_dmabuf;
@@ -270,6 +272,19 @@ void vmw_kms_update_implicit_fb(struct vmw_private *dev_priv,
 void vmw_kms_create_implicit_placement_property(struct vmw_private *dev_priv,
 						bool immutable);
 
+/* Universal Plane Helpers */
+void vmw_du_primary_plane_destroy(struct drm_plane *plane);
+void vmw_du_cursor_plane_destroy(struct drm_plane *plane);
+int vmw_du_cursor_plane_disable(struct drm_plane *plane);
+int vmw_du_cursor_plane_update(struct drm_plane *plane,
+			       struct drm_crtc *crtc,
+			       struct drm_framebuffer *fb,
+			       int crtc_x, int crtc_y,
+			       unsigned int crtc_w,
+			       unsigned int crtc_h,
+			       uint32_t src_x, uint32_t src_y,
+			       uint32_t src_w, uint32_t src_h);
+
 
 /*
  * Legacy display unit functions - vmwgfx_ldu.c

commit 9338203c4f03ffe323b67f0b2fa17b9811fa9bb6
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Nov 28 20:51:09 2016 +0200

    drm: Don't include <drm/drm_encoder.h> in <drm/drm_crtc.h>
    
    <drm/drm_crtc.h> used to define most of the in-kernel KMS API. It has
    now been split into separate files for each object type, but still
    includes most other KMS headers to avoid breaking driver compilation.
    
    As a step towards fixing that problem, remove the inclusion of
    <drm/drm_encoder.h> from <drm/drm_crtc.h> and include it instead where
    appropriate. Also remove the forward declarations of the drm_encoder and
    drm_encoder_helper_funcs structures from <drm/drm_crtc.h> as they're not
    needed in the header.
    
    <drm/drm_encoder.h> now has to include <drm/drm_mode.h> and contain a
    forward declaration of struct drm_encoder in order to allow including it
    as the first header in a compilation unit.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com> # For vmwgfx
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/1481709550-29226-2-git-send-email-laurent.pinchart+renesas@ideasonboard.com

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index f42ce9a1c3ac..cb36e1d70133 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -30,6 +30,7 @@
 
 #include <drm/drmP.h>
 #include <drm/drm_crtc_helper.h>
+#include <drm/drm_encoder.h>
 #include "vmwgfx_drv.h"
 
 /**

commit dabdcdc9822ae4e23cd7ff07090098d34f287b28
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Dec 2 08:07:40 2016 +0100

    drm/vmwgfx: Switch to mode_cmd2
    
    Surprisingly few changes needed to make it happen. Compile-tested
    only. The idea is that this replaces the 2 patches from Ville's big
    fb->format patch series as a prep patch. Only impact to later patches
    should be the one instace added in this patch where we look at
    fb->pixel_format (instead of fb->bpp and fb->depth), so minor
    adjustements in the cocci-generated patches needed.
    
    v2: Restore pitch computation in vmw_fb_kms_framebuffer (Sinclair).
    
    Cc: ville.syrjala@linux.intel.com
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: linux-graphics-maintainer@vmware.com
    Cc: Sinclair Yeh <syeh@vmware.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Acked-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161202070740.31689-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index ff4803c107bc..f42ce9a1c3ac 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -248,7 +248,7 @@ vmw_kms_new_framebuffer(struct vmw_private *dev_priv,
 			struct vmw_dma_buffer *dmabuf,
 			struct vmw_surface *surface,
 			bool only_2d,
-			const struct drm_mode_fb_cmd *mode_cmd);
+			const struct drm_mode_fb_cmd2 *mode_cmd);
 int vmw_kms_fbdev_init_data(struct vmw_private *dev_priv,
 			    unsigned unit,
 			    u32 max_width,

commit 7ea7728387820a21a89a7c3845dbe60926f82dc4
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue Jun 7 12:49:30 2016 +0200

    drm/core: Change declaration for gamma_set.
    
    Change return value to int to propagate errors from gamma_set,
    and remove start parameter. Updates always use the full size,
    and some drivers even ignore the start parameter altogether.
    
    This is needed for atomic drivers, where an atomic commit can
    fail with -EINTR or -ENOMEM and should be restarted. This is already
    and issue for drm_atomic_helper_legacy_set_gamma, which this patch
    fixes up.
    
    Changes since v1:
    - Fix compiler warning. (Emil)
    - Fix commit message (Daniel)
    
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: Christian König <christian.koenig@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: VMware Graphics <linux-graphics-maintainer@vmware.com>
    Cc: Mathieu Larouche <mathieu.larouche@matrox.com>
    Cc: Thierry Reding <treding@nvidia.com>
    Acked-by: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    [danvet: Improve commit message a bit more, mention that this fixes
    the helper.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/742944bc-9f41-1acb-df4f-0fd4c8a10168@linux.intel.com

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 57203212c501..ff4803c107bc 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -195,9 +195,9 @@ struct vmw_display_unit {
 void vmw_du_cleanup(struct vmw_display_unit *du);
 void vmw_du_crtc_save(struct drm_crtc *crtc);
 void vmw_du_crtc_restore(struct drm_crtc *crtc);
-void vmw_du_crtc_gamma_set(struct drm_crtc *crtc,
+int vmw_du_crtc_gamma_set(struct drm_crtc *crtc,
 			   u16 *r, u16 *g, u16 *b,
-			   uint32_t start, uint32_t size);
+			   uint32_t size);
 int vmw_du_crtc_cursor_set2(struct drm_crtc *crtc, struct drm_file *file_priv,
 			    uint32_t handle, uint32_t width, uint32_t height,
 			    int32_t hot_x, int32_t hot_y);

commit 6dd687b42fff7aa681978e117cf3051de0d023a5
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Fri Feb 12 09:57:15 2016 +0100

    drm/vmwgfx: Calculate the cursor position based on the crtc gui origin
    
    Base the cursor position on the coordinate of the crtc origin in the
    gui coordinate system rather than in the framebuffer coordinate system.
    
    With explicit placement, these may differ (for example when two crtcs
    scan out of the same framebuffer location).
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index aa21aff9870d..57203212c501 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -179,6 +179,8 @@ struct vmw_display_unit {
 	int gui_y;
 	bool is_implicit;
 	bool active_implicit;
+	int set_gui_x;
+	int set_gui_y;
 };
 
 #define vmw_crtc_to_du(x) \

commit 76404ac0a2c358dd63b8ed32e4df69f3b781b7eb
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Fri Feb 12 09:55:45 2016 +0100

    drm/vmwgfx: Add connector properties to switch between explicit and implicit placement
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 0b5c9ab4a2f8..aa21aff9870d 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -264,7 +264,8 @@ bool vmw_kms_crtc_flippable(struct vmw_private *dev_priv,
 			    struct drm_crtc *crtc);
 void vmw_kms_update_implicit_fb(struct vmw_private *dev_priv,
 				struct drm_crtc *crtc);
-
+void vmw_kms_create_implicit_placement_property(struct vmw_private *dev_priv,
+						bool immutable);
 
 
 /*

commit 75c0685549bb4af6e66bcc1c4c055add531b3880
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Fri Feb 12 09:00:26 2016 +0100

    drm/vmwgfx: Break out implicit fb code
    
    Preparation for supporting explicit fbs for screen objects and screen
    targets.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index d41928c12a42..0b5c9ab4a2f8 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -178,6 +178,7 @@ struct vmw_display_unit {
 	int gui_x;
 	int gui_y;
 	bool is_implicit;
+	bool active_implicit;
 };
 
 #define vmw_crtc_to_du(x) \
@@ -254,6 +255,17 @@ int vmw_kms_fbdev_init_data(struct vmw_private *dev_priv,
 			    struct drm_crtc **p_crtc,
 			    struct drm_display_mode **p_mode);
 void vmw_guess_mode_timing(struct drm_display_mode *mode);
+void vmw_kms_del_active(struct vmw_private *dev_priv,
+			struct vmw_display_unit *du);
+void vmw_kms_add_active(struct vmw_private *dev_priv,
+			struct vmw_display_unit *du,
+			struct vmw_framebuffer *vfb);
+bool vmw_kms_crtc_flippable(struct vmw_private *dev_priv,
+			    struct drm_crtc *crtc);
+void vmw_kms_update_implicit_fb(struct vmw_private *dev_priv,
+				struct drm_crtc *crtc);
+
+
 
 /*
  * Legacy display unit functions - vmwgfx_ldu.c

commit 897b818077f3c11eda82ead57fd173c7f12f9796
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Fri Feb 12 08:32:08 2016 +0100

    drm/vmwgfx: Fix screen object page flips for large framebuffers
    
    For page flips the framebuffer may be much larger than the crtc
    scanout area and may be attached to multiple crtcs.
    When flipping a crtc, make sure we dirty only that crtc's area of the
    framebuffer.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index edd81503516d..d41928c12a42 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -287,6 +287,7 @@ int vmw_kms_sou_do_surface_dirty(struct vmw_private *dev_priv,
 int vmw_kms_sou_do_dmabuf_dirty(struct vmw_private *dev_priv,
 				struct vmw_framebuffer *framebuffer,
 				struct drm_clip_rect *clips,
+				struct drm_vmw_rect *vclips,
 				unsigned num_clips, int increment,
 				bool interruptible,
 				struct vmw_fence_obj **out_fence);

commit 8fbf9d92a7bc4cadd3a0139698cf17031dfcdfca
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Thu Nov 26 19:45:16 2015 +0100

    drm/vmwgfx: Implement the cursor_set2 callback v2
    
    Fixes native drm clients like Fedora 23 Wayland which now appears to
    be able to use cursor hotspots without strange cursor offsets.
    Also fixes a couple of ignored error paths.
    
    Since the core drm cursor hotspot is incompatible with the legacy vmwgfx
    hotspot (the core drm hotspot is reset when the drm_mode_cursor ioctl
    is used), we need to keep track of both and add them when the device
    hotspot is set. We assume that either is always zero.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 782df7ca9794..edd81503516d 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -159,6 +159,8 @@ struct vmw_display_unit {
 
 	int hotspot_x;
 	int hotspot_y;
+	s32 core_hotspot_x;
+	s32 core_hotspot_y;
 
 	unsigned unit;
 
@@ -193,8 +195,9 @@ void vmw_du_crtc_restore(struct drm_crtc *crtc);
 void vmw_du_crtc_gamma_set(struct drm_crtc *crtc,
 			   u16 *r, u16 *g, u16 *b,
 			   uint32_t start, uint32_t size);
-int vmw_du_crtc_cursor_set(struct drm_crtc *crtc, struct drm_file *file_priv,
-			   uint32_t handle, uint32_t width, uint32_t height);
+int vmw_du_crtc_cursor_set2(struct drm_crtc *crtc, struct drm_file *file_priv,
+			    uint32_t handle, uint32_t width, uint32_t height,
+			    int32_t hot_x, int32_t hot_y);
 int vmw_du_crtc_cursor_move(struct drm_crtc *crtc, int x, int y);
 int vmw_du_connector_dpms(struct drm_connector *connector, int mode);
 void vmw_du_connector_save(struct drm_connector *connector);

commit 294947a5c7f6d228b70fcc51a89527e74a38a2c5
Merge: 6406e45cc6f4 54fbde8a94a8
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Aug 17 16:03:48 2015 +1000

    Merge branch 'vmwgfx-next' of git://people.freedesktop.org/~thomash/linux into drm-next
    
    A couple of fixes from the previous pull request as well as gl3 support.
    There is one drm core change, an export of a previously private function.
    
    Take 2 implementing screen targets, this time with the fbdev code adjusted
    accordingly.
    
    Also there is an implementation of register-driven command buffers, that
    overrides the FIFO ring for command processing. It's needed for our upcoming
    hardware revision.
    * 'vmwgfx-next' of git://people.freedesktop.org/~thomash/linux: (35 commits)
      drm/vmwgfx: Fix copyright headers
      drm/vmwgfx: Add DX query support. Various fixes.
      drm/vmwgfx: Add command parser support for a couple of DX commands
      drm/vmwgfx: Command parser fixes for DX
      drm/vmwgfx: Initial DX support
      drm/vmwgfx: Update device includes for DX device functionality
      drm: export the DRM permission check code
      drm/vmwgfx: Fix crash when unloading vmwgfx v2
      drm/vmwgfx: Fix framebuffer creation on older hardware
      drm/vmwgfx: Fixed topology boundary checking for Screen Targets
      drm/vmwgfx: Fix an uninitialized value
      drm/vmwgfx: Fix compiler warning with 32-bit dma_addr_t
      drm/vmwgfx: Kill a bunch of sparse warnings
      drm/vmwgfx: Fix kms preferred mode sorting
      drm/vmwgfx: Reinstate the legacy display system dirty callback
      drm/vmwgfx: Implement fbdev on kms v2
      drm/vmwgfx: Add a kernel interface to create a framebuffer v2
      drm/vmwgfx: Avoid cmdbuf alloc sleeping if !TASK_RUNNING
      drm/vmwgfx: Convert screen targets to new helpers v3
      drm/vmwgfx: Convert screen objects to the new helpers
      ...

commit 54fbde8a94a8a78547597215c9e4be590d075ee0
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Wed Jul 29 12:38:02 2015 -0700

    drm/vmwgfx: Fix copyright headers
    
    Updating and fixing copyright headers.
    Bump version minor to signal vgpu10 support.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Brian Paul <brianp@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index eb6c8536866f..876de908fce3 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -1,6 +1,6 @@
 /**************************************************************************
  *
- * Copyright © 2009-2014 VMware, Inc., Palo Alto, CA., USA
+ * Copyright © 2009-2015 VMware, Inc., Palo Alto, CA., USA
  * All Rights Reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a

commit a278724aa23c544c2087cb7537db6b950877c291
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Mon Jun 29 12:55:07 2015 -0700

    drm/vmwgfx: Implement fbdev on kms v2
    
    With screen targets the old legacy display system fbdev doesn't work
    satisfactory anymore. At best the resolution is severely restricted.
    Therefore implement fbdev on top of the kms system. With this change, fbdev
    will be using whatever KMS backend is chosen.
    
    There are helpers available for this, so in the future we'd probably want
    to implement the helper callbacks instead of calling into our KMS
    implementation directly.
    
    v2: Make sure we take the mode_config mutex around modesetting,
    Also clear the initial framebuffer using vzalloc instead of vmalloc.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 311effc7ee74..eb6c8536866f 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -243,6 +243,14 @@ vmw_kms_new_framebuffer(struct vmw_private *dev_priv,
 			struct vmw_surface *surface,
 			bool only_2d,
 			const struct drm_mode_fb_cmd *mode_cmd);
+int vmw_kms_fbdev_init_data(struct vmw_private *dev_priv,
+			    unsigned unit,
+			    u32 max_width,
+			    u32 max_height,
+			    struct drm_connector **p_con,
+			    struct drm_crtc **p_crtc,
+			    struct drm_display_mode **p_mode);
+void vmw_guess_mode_timing(struct drm_display_mode *mode);
 
 /*
  * Legacy display unit functions - vmwgfx_ldu.c

commit fd006a43a8c4c9356ace60eacd8ae68954fa25e0
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Sun Jun 28 02:50:56 2015 -0700

    drm/vmwgfx: Add a kernel interface to create a framebuffer v2
    
    The kernel interface is needed for fbdev, and needs to be free from
    a file_priv member. To accomplish this, remove the fb surface mutex
    and list which isn't used anymore, anyway.
    
    Finally, make the pin() and unpin() pin the framebuffer for all display
    system backends, so that fbdev can pin its framebuffer before mapping it.
    
    v2: Address review comments:
    - Fix vmw_framebuffer_unpin() to handle also the surface framebuffer case.
    - Fix vmw_kms_new_framebuffer() to actually use the only_2d parameter.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index f941f92338a6..311effc7ee74 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -114,7 +114,6 @@ struct vmw_framebuffer_surface {
 	struct vmw_surface *surface;
 	struct vmw_dma_buffer *buffer;
 	struct list_head head;
-	struct drm_master *master;
 	bool is_dmabuf_proxy;  /* true if this is proxy surface for DMA buf */
 };
 
@@ -238,7 +237,12 @@ int vmw_kms_readback(struct vmw_private *dev_priv,
 		     struct drm_vmw_fence_rep __user *user_fence_rep,
 		     struct drm_vmw_rect *vclips,
 		     uint32_t num_clips);
-
+struct vmw_framebuffer *
+vmw_kms_new_framebuffer(struct vmw_private *dev_priv,
+			struct vmw_dma_buffer *dmabuf,
+			struct vmw_surface *surface,
+			bool only_2d,
+			const struct drm_mode_fb_cmd *mode_cmd);
 
 /*
  * Legacy display unit functions - vmwgfx_ldu.c

commit 6bf6bf03b37b5ba0f3399fa9bb3d62edfa117c87
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Fri Jun 26 02:22:40 2015 -0700

    drm/vmwgfx: Convert screen targets to new helpers v3
    
    Also implements the missing readback function and
    fixes page flip in case of no event.
    
    v2:
    - Adapt to the work done for screen targets for 2d, in particular
    Handle proxy surface updates.
    - Remove execbuf quirks since we now use fifo reserve / commit.
    - Revert the initial placement of vmw dma buffers.
    
    v3: Address review comments.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 8a8203c66adc..f941f92338a6 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -239,6 +239,7 @@ int vmw_kms_readback(struct vmw_private *dev_priv,
 		     struct drm_vmw_rect *vclips,
 		     uint32_t num_clips);
 
+
 /*
  * Legacy display unit functions - vmwgfx_ldu.c
  */
@@ -249,6 +250,10 @@ int vmw_kms_ldu_do_dmabuf_dirty(struct vmw_private *dev_priv,
 				unsigned flags, unsigned color,
 				struct drm_clip_rect *clips,
 				unsigned num_clips, int increment);
+int vmw_kms_update_proxy(struct vmw_resource *res,
+			 const struct drm_clip_rect *clips,
+			 unsigned num_clips,
+			 int increment);
 
 /*
  * Screen Objects display functions - vmwgfx_scrn.c
@@ -282,17 +287,25 @@ int vmw_kms_sou_readback(struct vmw_private *dev_priv,
  */
 int vmw_kms_stdu_init_display(struct vmw_private *dev_priv);
 int vmw_kms_stdu_close_display(struct vmw_private *dev_priv);
-int vmw_kms_stdu_do_surface_dirty(struct vmw_private *dev_priv,
-				  struct drm_file *file_priv,
-				  struct vmw_framebuffer *framebuffer,
-				  struct drm_clip_rect *clips,
-				  unsigned num_clips, int increment);
-int vmw_kms_stdu_present(struct vmw_private *dev_priv,
-			 struct drm_file *file_priv,
-			 struct vmw_framebuffer *vfb,
-			 uint32_t user_handle,
-			 int32_t dest_x, int32_t dest_y,
-			 struct drm_vmw_rect *clips,
-			 uint32_t num_clips);
+int vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,
+			       struct vmw_framebuffer *framebuffer,
+			       struct drm_clip_rect *clips,
+			       struct drm_vmw_rect *vclips,
+			       struct vmw_resource *srf,
+			       s32 dest_x,
+			       s32 dest_y,
+			       unsigned num_clips, int inc,
+			       struct vmw_fence_obj **out_fence);
+int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
+		     struct drm_file *file_priv,
+		     struct vmw_framebuffer *vfb,
+		     struct drm_vmw_fence_rep __user *user_fence_rep,
+		     struct drm_clip_rect *clips,
+		     struct drm_vmw_rect *vclips,
+		     uint32_t num_clips,
+		     int increment,
+		     bool to_surface,
+		     bool interruptible);
+
 
 #endif

commit 10b1e0ca9c32deb3a9b0ecc93fc4920fc24b4a57
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Fri Jun 26 02:14:27 2015 -0700

    drm/vmwgfx: Convert screen objects to the new helpers
    
    This makes it possible to use the same function for surface dirty and
    present. Also fixes page flip without events.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index c19a515b139b..8a8203c66adc 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -125,15 +125,6 @@ struct vmw_framebuffer_dmabuf {
 };
 
 
-/*
- * Basic clip rect manipulation
- */
-void vmw_clip_cliprects(struct drm_clip_rect *rects,
-			int num_rects,
-			struct vmw_clip_rect clip,
-			SVGASignedRect *out_rects,
-			int *out_num);
-
 /*
  * Basic cursor manipulation
  */
@@ -241,6 +232,12 @@ int vmw_kms_helper_resource_prepare(struct vmw_resource *res,
 void vmw_kms_helper_resource_revert(struct vmw_resource *res);
 void vmw_kms_helper_resource_finish(struct vmw_resource *res,
 				    struct vmw_fence_obj **out_fence);
+int vmw_kms_readback(struct vmw_private *dev_priv,
+		     struct drm_file *file_priv,
+		     struct vmw_framebuffer *vfb,
+		     struct drm_vmw_fence_rep __user *user_fence_rep,
+		     struct drm_vmw_rect *vclips,
+		     uint32_t num_clips);
 
 /*
  * Legacy display unit functions - vmwgfx_ldu.c
@@ -259,20 +256,26 @@ int vmw_kms_ldu_do_dmabuf_dirty(struct vmw_private *dev_priv,
 int vmw_kms_sou_init_display(struct vmw_private *dev_priv);
 int vmw_kms_sou_close_display(struct vmw_private *dev_priv);
 int vmw_kms_sou_do_surface_dirty(struct vmw_private *dev_priv,
-				 struct drm_file *file_priv,
 				 struct vmw_framebuffer *framebuffer,
-				 unsigned flags, unsigned color,
 				 struct drm_clip_rect *clips,
+				 struct drm_vmw_rect *vclips,
+				 struct vmw_resource *srf,
+				 s32 dest_x,
+				 s32 dest_y,
 				 unsigned num_clips, int inc,
 				 struct vmw_fence_obj **out_fence);
-int vmw_kms_sou_do_dmabuf_dirty(struct drm_file *file_priv,
-				struct vmw_private *dev_priv,
+int vmw_kms_sou_do_dmabuf_dirty(struct vmw_private *dev_priv,
 				struct vmw_framebuffer *framebuffer,
-				unsigned flags, unsigned color,
 				struct drm_clip_rect *clips,
 				unsigned num_clips, int increment,
+				bool interruptible,
 				struct vmw_fence_obj **out_fence);
-
+int vmw_kms_sou_readback(struct vmw_private *dev_priv,
+			 struct drm_file *file_priv,
+			 struct vmw_framebuffer *vfb,
+			 struct drm_vmw_fence_rep __user *user_fence_rep,
+			 struct drm_vmw_rect *vclips,
+			 uint32_t num_clips);
 
 /*
  * Screen Target Display Unit functions - vmwgfx_stdu.c

commit 1a4b172ac96edd7f571772e83c09c5a18718a4fa
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Fri Jun 26 02:03:53 2015 -0700

    drm/vmwgfx: Add kms helpers for dirty- and readback functions
    
    We need to make the dirty- and readback functions callable without a struct
    drm_file pointer. We also need to unify the handling of dirty- and readback
    cliprects that are now implemented in various places across the kms system,
    som add helpers to facilitate this.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index db8ae94c403c..c19a515b139b 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -32,7 +32,50 @@
 #include <drm/drm_crtc_helper.h>
 #include "vmwgfx_drv.h"
 
-
+/**
+ * struct vmw_kms_dirty - closure structure for the vmw_kms_helper_dirty
+ * function.
+ *
+ * @fifo_commit: Callback that is called once for each display unit after
+ * all clip rects. This function must commit the fifo space reserved by the
+ * helper. Set up by the caller.
+ * @clip: Callback that is called for each cliprect on each display unit.
+ * Set up by the caller.
+ * @fifo_reserve_size: Fifo size that the helper should try to allocat for
+ * each display unit. Set up by the caller.
+ * @dev_priv: Pointer to the device private. Set up by the helper.
+ * @unit: The current display unit. Set up by the helper before a call to @clip.
+ * @cmd: The allocated fifo space. Set up by the helper before the first @clip
+ * call.
+ * @num_hits: Number of clip rect commands for this display unit.
+ * Cleared by the helper before the first @clip call. Updated by the @clip
+ * callback.
+ * @fb_x: Clip rect left side in framebuffer coordinates.
+ * @fb_y: Clip rect right side in framebuffer coordinates.
+ * @unit_x1: Clip rect left side in crtc coordinates.
+ * @unit_y1: Clip rect top side in crtc coordinates.
+ * @unit_x2: Clip rect right side in crtc coordinates.
+ * @unit_y2: Clip rect bottom side in crtc coordinates.
+ *
+ * The clip rect coordinates are updated by the helper for each @clip call.
+ * Note that this may be derived from if more info needs to be passed between
+ * helper caller and helper callbacks.
+ */
+struct vmw_kms_dirty {
+	void (*fifo_commit)(struct vmw_kms_dirty *);
+	void (*clip)(struct vmw_kms_dirty *);
+	size_t fifo_reserve_size;
+	struct vmw_private *dev_priv;
+	struct vmw_display_unit *unit;
+	void *cmd;
+	u32 num_hits;
+	s32 fb_x;
+	s32 fb_y;
+	s32 unit_x1;
+	s32 unit_y1;
+	s32 unit_x2;
+	s32 unit_y2;
+};
 
 #define VMWGFX_NUM_DISPLAY_UNITS 8
 
@@ -173,7 +216,31 @@ int vmw_du_connector_fill_modes(struct drm_connector *connector,
 int vmw_du_connector_set_property(struct drm_connector *connector,
 				  struct drm_property *property,
 				  uint64_t val);
-
+int vmw_kms_helper_dirty(struct vmw_private *dev_priv,
+			 struct vmw_framebuffer *framebuffer,
+			 const struct drm_clip_rect *clips,
+			 const struct drm_vmw_rect *vclips,
+			 s32 dest_x, s32 dest_y,
+			 int num_clips,
+			 int increment,
+			 struct vmw_kms_dirty *dirty);
+
+int vmw_kms_helper_buffer_prepare(struct vmw_private *dev_priv,
+				  struct vmw_dma_buffer *buf,
+				  bool interruptible,
+				  bool validate_as_mob);
+void vmw_kms_helper_buffer_revert(struct vmw_dma_buffer *buf);
+void vmw_kms_helper_buffer_finish(struct vmw_private *dev_priv,
+				  struct drm_file *file_priv,
+				  struct vmw_dma_buffer *buf,
+				  struct vmw_fence_obj **out_fence,
+				  struct drm_vmw_fence_rep __user *
+				  user_fence_rep);
+int vmw_kms_helper_resource_prepare(struct vmw_resource *res,
+				    bool interruptible);
+void vmw_kms_helper_resource_revert(struct vmw_resource *res);
+void vmw_kms_helper_resource_finish(struct vmw_resource *res,
+				    struct vmw_fence_obj **out_fence);
 
 /*
  * Legacy display unit functions - vmwgfx_ldu.c

commit f89c6c321c4a7c0188922f331b70d83af01ab53e
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Fri Jun 26 01:54:28 2015 -0700

    drm/vmwgfx: Replace SurfaceDMA usage with SurfaceCopy in 2D VMs
    
    This patch address the following underlying issues with SurfaceDMA
    
    * SurfaceDMA command does not work in a 2D VM, but we can wrap a
      proxy surface around the same DMA buffer and use the SurfaceCopy
      command which does work in a 2D VM.
    
    * Wrapping a DMA buffer with a proxy surface also gives us an
      added optimization path for the case when the DMA buf
      dimensions match the mode.  In this case, the DMA buf can
      be pinned as the display surface, saving an extra copy.
      This only works in a 2D VM because we won't be doing any
      rendering operations directly to the display surface.
    
    v2
    * Moved is_dmabuf_proxy field to vmw_framebuffer_surface
    * Undone coding style changes
    * Addressed other issues from review
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 548fa872b39c..db8ae94c403c 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -72,6 +72,7 @@ struct vmw_framebuffer_surface {
 	struct vmw_dma_buffer *buffer;
 	struct list_head head;
 	struct drm_master *master;
+	bool is_dmabuf_proxy;  /* true if this is proxy surface for DMA buf */
 };
 
 

commit 35c051258e8fd7cb97222f4aa887bcd404c156d0
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Fri Jun 26 01:42:06 2015 -0700

    drm/vmwgfx: Implement screen targets
    
    Add support for the screen target device interface.
    Add a getparam parameter and bump minor to signal availability.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 0f2c29166f7c..548fa872b39c 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -204,4 +204,24 @@ int vmw_kms_sou_do_dmabuf_dirty(struct drm_file *file_priv,
 				struct drm_clip_rect *clips,
 				unsigned num_clips, int increment,
 				struct vmw_fence_obj **out_fence);
+
+
+/*
+ * Screen Target Display Unit functions - vmwgfx_stdu.c
+ */
+int vmw_kms_stdu_init_display(struct vmw_private *dev_priv);
+int vmw_kms_stdu_close_display(struct vmw_private *dev_priv);
+int vmw_kms_stdu_do_surface_dirty(struct vmw_private *dev_priv,
+				  struct drm_file *file_priv,
+				  struct vmw_framebuffer *framebuffer,
+				  struct drm_clip_rect *clips,
+				  unsigned num_clips, int increment);
+int vmw_kms_stdu_present(struct vmw_private *dev_priv,
+			 struct drm_file *file_priv,
+			 struct vmw_framebuffer *vfb,
+			 uint32_t user_handle,
+			 int32_t dest_x, int32_t dest_y,
+			 struct drm_vmw_rect *clips,
+			 uint32_t num_clips);
+
 #endif

commit c8261a961ece4206bd60708eafa24ab81347f87c
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Fri Jun 26 01:23:42 2015 -0700

    vmwgfx: Major KMS refactoring / cleanup in preparation of screen targets
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 8d038c36bd57..0f2c29166f7c 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -1,6 +1,6 @@
 /**************************************************************************
  *
- * Copyright © 2009 VMware, Inc., Palo Alto, CA., USA
+ * Copyright © 2009-2014 VMware, Inc., Palo Alto, CA., USA
  * All Rights Reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -32,11 +32,17 @@
 #include <drm/drm_crtc_helper.h>
 #include "vmwgfx_drv.h"
 
+
+
 #define VMWGFX_NUM_DISPLAY_UNITS 8
 
 
 #define vmw_framebuffer_to_vfb(x) \
 	container_of(x, struct vmw_framebuffer, base)
+#define vmw_framebuffer_to_vfbs(x) \
+	container_of(x, struct vmw_framebuffer_surface, base.base)
+#define vmw_framebuffer_to_vfbd(x) \
+	container_of(x, struct vmw_framebuffer_dmabuf, base.base)
 
 /**
  * Base class for framebuffers
@@ -53,9 +59,36 @@ struct vmw_framebuffer {
 	uint32_t user_handle;
 };
 
+/*
+ * Clip rectangle
+ */
+struct vmw_clip_rect {
+	int x1, x2, y1, y2;
+};
+
+struct vmw_framebuffer_surface {
+	struct vmw_framebuffer base;
+	struct vmw_surface *surface;
+	struct vmw_dma_buffer *buffer;
+	struct list_head head;
+	struct drm_master *master;
+};
 
-#define vmw_crtc_to_du(x) \
-	container_of(x, struct vmw_display_unit, crtc)
+
+struct vmw_framebuffer_dmabuf {
+	struct vmw_framebuffer base;
+	struct vmw_dma_buffer *buffer;
+};
+
+
+/*
+ * Basic clip rect manipulation
+ */
+void vmw_clip_cliprects(struct drm_clip_rect *rects,
+			int num_rects,
+			struct vmw_clip_rect clip,
+			SVGASignedRect *out_rects,
+			int *out_num);
 
 /*
  * Basic cursor manipulation
@@ -120,11 +153,7 @@ struct vmw_display_unit {
 /*
  * Shared display unit functions - vmwgfx_kms.c
  */
-void vmw_display_unit_cleanup(struct vmw_display_unit *du);
-int vmw_du_page_flip(struct drm_crtc *crtc,
-		     struct drm_framebuffer *fb,
-		     struct drm_pending_vblank_event *event,
-		     uint32_t page_flip_flags);
+void vmw_du_cleanup(struct vmw_display_unit *du);
 void vmw_du_crtc_save(struct drm_crtc *crtc);
 void vmw_du_crtc_restore(struct drm_crtc *crtc);
 void vmw_du_crtc_gamma_set(struct drm_crtc *crtc,
@@ -148,20 +177,31 @@ int vmw_du_connector_set_property(struct drm_connector *connector,
 /*
  * Legacy display unit functions - vmwgfx_ldu.c
  */
-int vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv);
-int vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv);
+int vmw_kms_ldu_init_display(struct vmw_private *dev_priv);
+int vmw_kms_ldu_close_display(struct vmw_private *dev_priv);
+int vmw_kms_ldu_do_dmabuf_dirty(struct vmw_private *dev_priv,
+				struct vmw_framebuffer *framebuffer,
+				unsigned flags, unsigned color,
+				struct drm_clip_rect *clips,
+				unsigned num_clips, int increment);
 
 /*
  * Screen Objects display functions - vmwgfx_scrn.c
  */
-int vmw_kms_init_screen_object_display(struct vmw_private *dev_priv);
-int vmw_kms_close_screen_object_display(struct vmw_private *dev_priv);
-int vmw_kms_sou_update_layout(struct vmw_private *dev_priv, unsigned num,
-			      struct drm_vmw_rect *rects);
-bool vmw_kms_screen_object_flippable(struct vmw_private *dev_priv,
-				     struct drm_crtc *crtc);
-void vmw_kms_screen_object_update_implicit_fb(struct vmw_private *dev_priv,
-					      struct drm_crtc *crtc);
-
-
+int vmw_kms_sou_init_display(struct vmw_private *dev_priv);
+int vmw_kms_sou_close_display(struct vmw_private *dev_priv);
+int vmw_kms_sou_do_surface_dirty(struct vmw_private *dev_priv,
+				 struct drm_file *file_priv,
+				 struct vmw_framebuffer *framebuffer,
+				 unsigned flags, unsigned color,
+				 struct drm_clip_rect *clips,
+				 unsigned num_clips, int inc,
+				 struct vmw_fence_obj **out_fence);
+int vmw_kms_sou_do_dmabuf_dirty(struct drm_file *file_priv,
+				struct vmw_private *dev_priv,
+				struct vmw_framebuffer *framebuffer,
+				unsigned flags, unsigned color,
+				struct drm_clip_rect *clips,
+				unsigned num_clips, int increment,
+				struct vmw_fence_obj **out_fence);
 #endif

commit 9a69a9ac20f7f3435dd18019f902351c61a9ad1d
Author: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date:   Tue Jul 21 11:34:55 2015 +0200

    drm: Make the connector dpms callback return a value, v2.
    
    This is required to properly handle failing dpms calls.
    When making a wait in i915 interruptible, I've noticed
    that the dpms sequence could fail with -ERESTARTSYS because
    it was waiting interruptibly for flips. So from now on
    allow drivers to fail in their connector dpms callback.
    
    Encoder and crtc dpms callbacks are unaffected.
    
    Changes since v1:
    - Update kerneldoc for the drm helper functions.
    
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    [danvet: Resolve conflicts due to different merge order.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 8d038c36bd57..f1a324cfb4c3 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -133,7 +133,7 @@ void vmw_du_crtc_gamma_set(struct drm_crtc *crtc,
 int vmw_du_crtc_cursor_set(struct drm_crtc *crtc, struct drm_file *file_priv,
 			   uint32_t handle, uint32_t width, uint32_t height);
 int vmw_du_crtc_cursor_move(struct drm_crtc *crtc, int x, int y);
-void vmw_du_connector_dpms(struct drm_connector *connector, int mode);
+int vmw_du_connector_dpms(struct drm_connector *connector, int mode);
 void vmw_du_connector_save(struct drm_connector *connector);
 void vmw_du_connector_restore(struct drm_connector *connector);
 enum drm_connector_status

commit ed8d19756e80ec63003a93aa4d70406e6ba61522
Author: Keith Packard <keithp@keithp.com>
Date:   Mon Jul 22 18:49:58 2013 -0700

    drm: Pass page flip ioctl flags to driver
    
    This lets drivers see the flags requested by the application
    
    [airlied: fixup for rcar/imx/msm]
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Dave Airlie <airlied@gmail.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 6fa89c9d6214..8d038c36bd57 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -123,7 +123,8 @@ struct vmw_display_unit {
 void vmw_display_unit_cleanup(struct vmw_display_unit *du);
 int vmw_du_page_flip(struct drm_crtc *crtc,
 		     struct drm_framebuffer *fb,
-		     struct drm_pending_vblank_event *event);
+		     struct drm_pending_vblank_event *event,
+		     uint32_t page_flip_flags);
 void vmw_du_crtc_save(struct drm_crtc *crtc);
 void vmw_du_crtc_restore(struct drm_crtc *crtc);
 void vmw_du_crtc_gamma_set(struct drm_crtc *crtc,

commit 760285e7e7ab282c25b5e90816f7c47000557f4f
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 2 18:01:07 2012 +0100

    UAPI: (Scripted) Convert #include "..." to #include <path/...> in drivers/gpu/
    
    Convert #include "..." to #include <path/...> in drivers/gpu/.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Dave Airlie <airlied@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 8184bc5b1730..6fa89c9d6214 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -28,8 +28,8 @@
 #ifndef VMWGFX_KMS_H_
 #define VMWGFX_KMS_H_
 
-#include "drmP.h"
-#include "drm_crtc_helper.h"
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
 #include "vmwgfx_drv.h"
 
 #define VMWGFX_NUM_DISPLAY_UNITS 8

commit b5ec427e8d8c66ea1bb9a3bf09663c1361ecf0b6
Author: Jakob Bornecrantz <jakob@vmware.com>
Date:   Thu Feb 9 16:56:45 2012 +0100

    vmwgfx: Add page flip support
    
    Signed-off-by: Jakob Bornecrantz <jakob@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index a4f7f034996a..8184bc5b1730 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -121,6 +121,9 @@ struct vmw_display_unit {
  * Shared display unit functions - vmwgfx_kms.c
  */
 void vmw_display_unit_cleanup(struct vmw_display_unit *du);
+int vmw_du_page_flip(struct drm_crtc *crtc,
+		     struct drm_framebuffer *fb,
+		     struct drm_pending_vblank_event *event);
 void vmw_du_crtc_save(struct drm_crtc *crtc);
 void vmw_du_crtc_restore(struct drm_crtc *crtc);
 void vmw_du_crtc_gamma_set(struct drm_crtc *crtc,
@@ -154,5 +157,10 @@ int vmw_kms_init_screen_object_display(struct vmw_private *dev_priv);
 int vmw_kms_close_screen_object_display(struct vmw_private *dev_priv);
 int vmw_kms_sou_update_layout(struct vmw_private *dev_priv, unsigned num,
 			      struct drm_vmw_rect *rects);
+bool vmw_kms_screen_object_flippable(struct vmw_private *dev_priv,
+				     struct drm_crtc *crtc);
+void vmw_kms_screen_object_update_implicit_fb(struct vmw_private *dev_priv,
+					      struct drm_crtc *crtc);
+
 
 #endif

commit 4cf73129cbe001b41be2f8b56f763fbf3acaa4ce
Merge: 3e54f5b72b44 6abff3c78051
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Dec 21 09:50:56 2011 +0000

    Merge remote-tracking branch 'pfdo/drm-fixes' into drm-core-next
    
    -next reported a messy merge, so I've merged my upstream pull into
    my -next tree.
    
    Conflicts:
            drivers/gpu/drm/vmwgfx/vmwgfx_kms.c

commit bfc2638dc05f2b27538e40821fdbc8399730b1ea
Author: Jakob Bornecrantz <jakob@vmware.com>
Date:   Mon Nov 28 13:19:14 2011 +0100

    vmwgfx: Resend the cursor after legacy modeset
    
    Signed-off-by: Jakob Bornecrantz <jakob@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index af8e6e5bd964..e1cb8556355f 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -62,9 +62,14 @@ struct vmw_framebuffer {
 int vmw_cursor_update_image(struct vmw_private *dev_priv,
 			    u32 *image, u32 width, u32 height,
 			    u32 hotspotX, u32 hotspotY);
+int vmw_cursor_update_dmabuf(struct vmw_private *dev_priv,
+			     struct vmw_dma_buffer *dmabuf,
+			     u32 width, u32 height,
+			     u32 hotspotX, u32 hotspotY);
 void vmw_cursor_update_position(struct vmw_private *dev_priv,
 				bool show, int x, int y);
 
+
 /**
  * Base class display unit.
  *

commit 308e5bcbdb10452e8aba31aa21432fb67ee46d72
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Nov 14 14:51:28 2011 -0800

    drm: add an fb creation ioctl that takes a pixel format v5
    
    To properly support the various plane formats supported by different
    hardware, the kernel must know the pixel format of a framebuffer object.
    So add a new ioctl taking a format argument corresponding to a fourcc
    name from the new drm_fourcc.h header file.  Implement the fb creation
    hooks in terms of the new mode_fb_cmd2 using helpers where the old
    bpp/depth values are needed.
    
    v2: create DRM specific fourcc header file for sharing with libdrm etc
    v3: fix rebase failure and use DRM fourcc codes in intel_display.c and
        update commit message
    v4: make fb_cmd2 handle field into an array for multi-object formats
        pull in Ville's fix for the memcpy in drm_plane_init
        apply Ville's cleanup to zero out fb_cmd2 arg in drm_mode_addfb
    v5: add 'flags' field for interlaced support (from Ville)
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Acked-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Reviewed-by: Rob Clark <rob.clark@linaro.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index af8e6e5bd964..055b844bd80f 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -29,6 +29,7 @@
 #define VMWGFX_KMS_H_
 
 #include "drmP.h"
+#include "drm_crtc_helper.h"
 #include "vmwgfx_drv.h"
 
 #define VMWGFX_NUM_DISPLAY_UNITS 8

commit 6987427a3953c5038dc14d2a090b5a6c93669428
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Wed Nov 2 09:43:11 2011 +0100

    vmwgfx: Infrastructure for explicit placement
    
    Make it possible to use explicit placement
    (although not hooked up with a user-space interface yet)
    and relax the single framebuffer limit to only apply to implicit placement.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Jakob Bornecrantz <jakob@vmware.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 815cf99ce06e..af8e6e5bd964 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -102,6 +102,7 @@ struct vmw_display_unit {
 	 */
 	int gui_x;
 	int gui_y;
+	bool is_implicit;
 };
 
 #define vmw_crtc_to_du(x) \

commit cd2b89e7e8c036903e7fa0c3dceca25e755fe78d
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Tue Oct 25 23:35:53 2011 +0200

    vmwgfx: Reinstate the update_layout ioctl
    
    We need to redefine a connector as "connected" if it matches a window
    in the host preferred GUI layout.
    Otherwise "smart" window managers would turn on Xorg outputs that we don't
    want to be on.
    
    This reinstates the update_layout and adds the following information to
    the modesetting system.
    a) Connection status <-> Equivalent to real hardware connection status
    b) Preferred mode <-> Equivalent to real hardware reading EDID
    c) Host window position <-> Equivalent to a real hardware scanout address
    dynamic register.
    
    It should be noted that there is no assumption here about what should be
    displayed and where. Only how to access the host windows.
    
    This also bumps minor to signal availability of the new IOCTL.
    
    Based on code originally written by Jakob Bornecrantz
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index db0b901f8c3f..815cf99ce06e 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -96,6 +96,12 @@ struct vmw_display_unit {
 	unsigned pref_height;
 	bool pref_active;
 	struct drm_display_mode *pref_mode;
+
+	/*
+	 * Gui positioning
+	 */
+	int gui_x;
+	int gui_y;
 };
 
 #define vmw_crtc_to_du(x) \
@@ -126,8 +132,7 @@ int vmw_du_connector_fill_modes(struct drm_connector *connector,
 int vmw_du_connector_set_property(struct drm_connector *connector,
 				  struct drm_property *property,
 				  uint64_t val);
-int vmw_du_update_layout(struct vmw_private *dev_priv, unsigned num,
-			 struct drm_vmw_rect *rects);
+
 
 /*
  * Legacy display unit functions - vmwgfx_ldu.c

commit 90ff18bc3a1ff56e3948ccf7ae4031b8e9662981
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Tue Oct 4 20:13:32 2011 +0200

    vmwgfx: Make sure we always have a user-space handle to use for objects that are backing kms framebuffers.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Jakob Bornecrantz <jakob@vmware.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 08d2630ac3a7..db0b901f8c3f 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -48,6 +48,8 @@ struct vmw_framebuffer {
 	int (*pin)(struct vmw_framebuffer *fb);
 	int (*unpin)(struct vmw_framebuffer *fb);
 	bool dmabuf;
+	struct ttm_base_object *user_obj;
+	uint32_t user_handle;
 };
 
 

commit 2fcd5a73bfd5341876f9ea6b5adcc1dd814226d4
Author: Jakob Bornecrantz <jakob@vmware.com>
Date:   Tue Oct 4 20:13:26 2011 +0200

    vmwgfx: Add present and readback ioctls
    
    Signed-off-by: Jakob Bornecrantz <jakob@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index ee16a06e4ca1..08d2630ac3a7 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -47,6 +47,7 @@ struct vmw_framebuffer {
 	struct drm_framebuffer base;
 	int (*pin)(struct vmw_framebuffer *fb);
 	int (*unpin)(struct vmw_framebuffer *fb);
+	bool dmabuf;
 };
 
 
@@ -95,6 +96,8 @@ struct vmw_display_unit {
 	struct drm_display_mode *pref_mode;
 };
 
+#define vmw_crtc_to_du(x) \
+	container_of(x, struct vmw_display_unit, crtc)
 #define vmw_connector_to_du(x) \
 	container_of(x, struct vmw_display_unit, connector)
 

commit 56d1c78df52323cdcd937505dccaa5d665dfab97
Author: Jakob Bornecrantz <jakob@vmware.com>
Date:   Tue Oct 4 20:13:22 2011 +0200

    vmwgfx: Add screen object support
    
    Signed-off-by: Jakob Bornecrantz <jakob@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 4e4313fd3012..ee16a06e4ca1 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -31,6 +31,8 @@
 #include "drmP.h"
 #include "vmwgfx_drv.h"
 
+#define VMWGFX_NUM_DISPLAY_UNITS 8
+
 
 #define vmw_framebuffer_to_vfb(x) \
 	container_of(x, struct vmw_framebuffer, base)
@@ -128,4 +130,12 @@ int vmw_du_update_layout(struct vmw_private *dev_priv, unsigned num,
 int vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv);
 int vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv);
 
+/*
+ * Screen Objects display functions - vmwgfx_scrn.c
+ */
+int vmw_kms_init_screen_object_display(struct vmw_private *dev_priv);
+int vmw_kms_close_screen_object_display(struct vmw_private *dev_priv);
+int vmw_kms_sou_update_layout(struct vmw_private *dev_priv, unsigned num,
+			      struct drm_vmw_rect *rects);
+
 #endif

commit 626ab771c2f2d060d29470f18b3f7d710ba909dc
Author: Jakob Bornecrantz <jakob@vmware.com>
Date:   Tue Oct 4 20:13:20 2011 +0200

    vmwgfx: Refactor common display unit functions to shared file
    
    More preparation for Screen Object support.
    
    Signed-off-by: Jakob Bornecrantz <jakob@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 8a398a0339b6..4e4313fd3012 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -83,22 +83,49 @@ struct vmw_display_unit {
 	int hotspot_y;
 
 	unsigned unit;
+
+	/*
+	 * Prefered mode tracking.
+	 */
+	unsigned pref_width;
+	unsigned pref_height;
+	bool pref_active;
+	struct drm_display_mode *pref_mode;
 };
 
+#define vmw_connector_to_du(x) \
+	container_of(x, struct vmw_display_unit, connector)
+
+
 /*
  * Shared display unit functions - vmwgfx_kms.c
  */
 void vmw_display_unit_cleanup(struct vmw_display_unit *du);
+void vmw_du_crtc_save(struct drm_crtc *crtc);
+void vmw_du_crtc_restore(struct drm_crtc *crtc);
+void vmw_du_crtc_gamma_set(struct drm_crtc *crtc,
+			   u16 *r, u16 *g, u16 *b,
+			   uint32_t start, uint32_t size);
 int vmw_du_crtc_cursor_set(struct drm_crtc *crtc, struct drm_file *file_priv,
 			   uint32_t handle, uint32_t width, uint32_t height);
 int vmw_du_crtc_cursor_move(struct drm_crtc *crtc, int x, int y);
+void vmw_du_connector_dpms(struct drm_connector *connector, int mode);
+void vmw_du_connector_save(struct drm_connector *connector);
+void vmw_du_connector_restore(struct drm_connector *connector);
+enum drm_connector_status
+vmw_du_connector_detect(struct drm_connector *connector, bool force);
+int vmw_du_connector_fill_modes(struct drm_connector *connector,
+				uint32_t max_width, uint32_t max_height);
+int vmw_du_connector_set_property(struct drm_connector *connector,
+				  struct drm_property *property,
+				  uint64_t val);
+int vmw_du_update_layout(struct vmw_private *dev_priv, unsigned num,
+			 struct drm_vmw_rect *rects);
 
 /*
  * Legacy display unit functions - vmwgfx_ldu.c
  */
 int vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv);
 int vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv);
-int vmw_kms_ldu_update_layout(struct vmw_private *dev_priv, unsigned num,
-			      struct drm_vmw_rect *rects);
 
 #endif

commit d8bd19d2aff95e52c7f356cc2fc722584a656065
Author: Jakob Bornecrantz <jakob@vmware.com>
Date:   Tue Jun 1 11:54:20 2010 +0200

    drm/vmwgfx: Allow userspace to change default layout. Bump minor.
    
    The host may change the layout and, since the change is
    communicated to the master, the master needs a way to
    communicate the change to the kernel driver.
    
    The minor version number is bumped to advertize the
    availability of this feature.
    
    Signed-off-by: Jakob Bornecrantz <jakob@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
index 8b95249f0531..8a398a0339b6 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -94,9 +94,11 @@ int vmw_du_crtc_cursor_set(struct drm_crtc *crtc, struct drm_file *file_priv,
 int vmw_du_crtc_cursor_move(struct drm_crtc *crtc, int x, int y);
 
 /*
- * Legacy display unit functions - vmwgfx_ldu.h
+ * Legacy display unit functions - vmwgfx_ldu.c
  */
 int vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv);
 int vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv);
+int vmw_kms_ldu_update_layout(struct vmw_private *dev_priv, unsigned num,
+			      struct drm_vmw_rect *rects);
 
 #endif

commit fb1d9738ca053ea8afa5e86af6463155f983b01c
Author: Jakob Bornecrantz <jakob@vmware.com>
Date:   Thu Dec 10 00:19:58 2009 +0000

    drm/vmwgfx: Add DRM driver for VMware Virtual GPU
    
    This commit adds the vmwgfx driver for the VWware Virtual GPU aka SVGA.
    The driver is under staging the same as Nouveau and Radeon KMS. Hopefully
    the 2D ioctls are bug free and don't need changing, so that part of the
    API should be stable. But there there is a pretty big chance that the 3D API
    will change in the future.
    
    Signed-off-by: Thomas Hellström <thellstrom@vmware.com>
    Signed-off-by: Jakob Bornecrantz <jakob@vmware.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
new file mode 100644
index 000000000000..8b95249f0531
--- /dev/null
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h
@@ -0,0 +1,102 @@
+/**************************************************************************
+ *
+ * Copyright © 2009 VMware, Inc., Palo Alto, CA., USA
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ **************************************************************************/
+
+#ifndef VMWGFX_KMS_H_
+#define VMWGFX_KMS_H_
+
+#include "drmP.h"
+#include "vmwgfx_drv.h"
+
+
+#define vmw_framebuffer_to_vfb(x) \
+	container_of(x, struct vmw_framebuffer, base)
+
+/**
+ * Base class for framebuffers
+ *
+ * @pin is called the when ever a crtc uses this framebuffer
+ * @unpin is called
+ */
+struct vmw_framebuffer {
+	struct drm_framebuffer base;
+	int (*pin)(struct vmw_framebuffer *fb);
+	int (*unpin)(struct vmw_framebuffer *fb);
+};
+
+
+#define vmw_crtc_to_du(x) \
+	container_of(x, struct vmw_display_unit, crtc)
+
+/*
+ * Basic cursor manipulation
+ */
+int vmw_cursor_update_image(struct vmw_private *dev_priv,
+			    u32 *image, u32 width, u32 height,
+			    u32 hotspotX, u32 hotspotY);
+void vmw_cursor_update_position(struct vmw_private *dev_priv,
+				bool show, int x, int y);
+
+/**
+ * Base class display unit.
+ *
+ * Since the SVGA hw doesn't have a concept of a crtc, encoder or connector
+ * so the display unit is all of them at the same time. This is true for both
+ * legacy multimon and screen objects.
+ */
+struct vmw_display_unit {
+	struct drm_crtc crtc;
+	struct drm_encoder encoder;
+	struct drm_connector connector;
+
+	struct vmw_surface *cursor_surface;
+	struct vmw_dma_buffer *cursor_dmabuf;
+	size_t cursor_age;
+
+	int cursor_x;
+	int cursor_y;
+
+	int hotspot_x;
+	int hotspot_y;
+
+	unsigned unit;
+};
+
+/*
+ * Shared display unit functions - vmwgfx_kms.c
+ */
+void vmw_display_unit_cleanup(struct vmw_display_unit *du);
+int vmw_du_crtc_cursor_set(struct drm_crtc *crtc, struct drm_file *file_priv,
+			   uint32_t handle, uint32_t width, uint32_t height);
+int vmw_du_crtc_cursor_move(struct drm_crtc *crtc, int x, int y);
+
+/*
+ * Legacy display unit functions - vmwgfx_ldu.h
+ */
+int vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv);
+int vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv);
+
+#endif
