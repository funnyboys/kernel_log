commit 1f054fd26e29784d373c3d29c348ee48f1c41fb2
Author: Roland Scheidegger <sroland@vmware.com>
Date:   Thu Jul 9 18:54:14 2020 +0200

    drm/vmwgfx: fix update of display surface when resolution changes
    
    The assignment of metadata overwrote the new display resolution values,
    hence we'd miss the size actually changed and wouldn't redefine the
    surface. This would then lead to command buffer error when trying to
    update the screen target (due to the size mismatch), and result in a
    VM with black screen.
    
    Fixes: 504901dbb0b5 ("drm/vmwgfx: Refactor surface_define to use vmw_surface_metadata")
    Reviewed-by: Charmaine Lee <charmainel@vmware.com>
    Signed-off-by: Roland Scheidegger <sroland@vmware.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 9ffa9c75a5da..16b385629688 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1069,10 +1069,6 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 	if (new_content_type != SAME_AS_DISPLAY) {
 		struct vmw_surface_metadata metadata = {0};
 
-		metadata.base_size.width = hdisplay;
-		metadata.base_size.height = vdisplay;
-		metadata.base_size.depth = 1;
-
 		/*
 		 * If content buffer is a buffer object, then we have to
 		 * construct surface info
@@ -1104,6 +1100,10 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 			metadata = new_vfbs->surface->metadata;
 		}
 
+		metadata.base_size.width = hdisplay;
+		metadata.base_size.height = vdisplay;
+		metadata.base_size.depth = 1;
+
 		if (vps->surf) {
 			struct drm_vmw_size cur_base_size =
 				vps->surf->metadata.base_size;

commit 504901dbb0b565fcbe466b0c56f3131586df5afd
Author: Deepak Rawat <drawat.floss@gmail.com>
Date:   Mon Apr 29 14:55:44 2019 -0700

    drm/vmwgfx: Refactor surface_define to use vmw_surface_metadata
    
    Makes surface_define cleaner by sending vmw_surface_metadata instead of
    all the arguments individually.
    
    v2: fix uninitialized return value, error message
    
    Signed-off-by: Deepak Rawat <drawat.floss@gmail.com>
    Reviewed-by: Brian Paul <brianp@vmware.com>
    Reviewed-by: Thomas Hellström (VMware) <thomas_os@shipmail.org>
    Reviewed-by: Roland Scheidegger <sroland@vmware.com>
    Signed-off-by: Roland Scheidegger <sroland@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 60275fe0db94..9ffa9c75a5da 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1041,7 +1041,6 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 	struct vmw_plane_state *vps = vmw_plane_state_to_vps(new_state);
 	enum stdu_content_type new_content_type;
 	struct vmw_framebuffer_surface *new_vfbs;
-	struct drm_crtc *crtc = new_state->crtc;
 	uint32_t hdisplay = new_state->crtc_w, vdisplay = new_state->crtc_h;
 	int ret;
 
@@ -1068,12 +1067,11 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 		new_content_type = SEPARATE_SURFACE;
 
 	if (new_content_type != SAME_AS_DISPLAY) {
-		struct vmw_surface content_srf;
-		struct drm_vmw_size display_base_size = {0};
+		struct vmw_surface_metadata metadata = {0};
 
-		display_base_size.width  = hdisplay;
-		display_base_size.height = vdisplay;
-		display_base_size.depth  = 1;
+		metadata.base_size.width = hdisplay;
+		metadata.base_size.height = vdisplay;
+		metadata.base_size.depth = 1;
 
 		/*
 		 * If content buffer is a buffer object, then we have to
@@ -1083,15 +1081,15 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 
 			switch (new_fb->format->cpp[0]*8) {
 			case 32:
-				content_srf.metadata.format = SVGA3D_X8R8G8B8;
+				metadata.format = SVGA3D_X8R8G8B8;
 				break;
 
 			case 16:
-				content_srf.metadata.format = SVGA3D_R5G6B5;
+				metadata.format = SVGA3D_R5G6B5;
 				break;
 
 			case 8:
-				content_srf.metadata.format = SVGA3D_P8;
+				metadata.format = SVGA3D_P8;
 				break;
 
 			default:
@@ -1099,25 +1097,20 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 				return -EINVAL;
 			}
 
-			content_srf.metadata.flags = 0;
-			content_srf.metadata.mip_levels[0] = 1;
-			content_srf.metadata.multisample_count = 0;
-			content_srf.metadata.multisample_pattern =
-				SVGA3D_MS_PATTERN_NONE;
-			content_srf.metadata.quality_level =
-				SVGA3D_MS_QUALITY_NONE;
+			metadata.mip_levels[0] = 1;
+			metadata.num_sizes = 1;
+			metadata.scanout = true;
 		} else {
-			content_srf = *new_vfbs->surface;
+			metadata = new_vfbs->surface->metadata;
 		}
 
 		if (vps->surf) {
 			struct drm_vmw_size cur_base_size =
 				vps->surf->metadata.base_size;
 
-			if (cur_base_size.width != display_base_size.width ||
-			    cur_base_size.height != display_base_size.height ||
-			    vps->surf->metadata.format !=
-			    content_srf.metadata.format) {
+			if (cur_base_size.width != metadata.base_size.width ||
+			    cur_base_size.height != metadata.base_size.height ||
+			    vps->surf->metadata.format != metadata.format) {
 				WARN_ON(vps->pinned != 0);
 				vmw_surface_unreference(&vps->surf);
 			}
@@ -1125,20 +1118,8 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 		}
 
 		if (!vps->surf) {
-			ret = vmw_surface_gb_priv_define
-				(crtc->dev,
-				 /* Kernel visible only */
-				 0,
-				 content_srf.metadata.flags,
-				 content_srf.metadata.format,
-				 true,  /* a scanout buffer */
-				 content_srf.metadata.mip_levels[0],
-				 content_srf.metadata.multisample_count,
-				 0,
-				 display_base_size,
-				 content_srf.metadata.multisample_pattern,
-				 content_srf.metadata.quality_level,
-				 &vps->surf);
+			ret = vmw_gb_surface_define(dev_priv, 0, &metadata,
+						    &vps->surf);
 			if (ret != 0) {
 				DRM_ERROR("Couldn't allocate STDU surface.\n");
 				return ret;

commit 26b82873a4a41cd699001ea634e2fc789789e5bd
Author: Deepak Rawat <drawat.floss@gmail.com>
Date:   Mon Apr 29 11:42:45 2019 -0700

    drm/vmwgfx: Split surface metadata from struct vmw_surface
    
    Create a new structure vmw_surface_metadata representing the metadata
    used for creating surface. With this can make the surface_define_priv
    a bit cleaner.
    
    Signed-off-by: Deepak Rawat <drawat.floss@gmail.com>
    Reviewed-by: Brian Paul <brianp@vmware.com>
    Reviewed-by: Thomas Hellström (VMware) <thomas_os@shipmail.org>
    Reviewed-by: Roland Scheidegger <sroland@vmware.com>
    Signed-off-by: Roland Scheidegger <sroland@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 68aecb6d9f87..60275fe0db94 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -590,7 +590,7 @@ static void vmw_stdu_bo_cpu_commit(struct vmw_kms_dirty *dirty)
 		return;
 
 	/* Assume we are blitting from Guest (bo) to Host (display_srf) */
-	dst_pitch = stdu->display_srf->base_size.width * stdu->cpp;
+	dst_pitch = stdu->display_srf->metadata.base_size.width * stdu->cpp;
 	dst_bo = &stdu->display_srf->res.backup->base;
 	dst_offset = ddirty->top * dst_pitch + ddirty->left * stdu->cpp;
 
@@ -1058,8 +1058,9 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 	vfb = vmw_framebuffer_to_vfb(new_fb);
 	new_vfbs = (vfb->bo) ? NULL : vmw_framebuffer_to_vfbs(new_fb);
 
-	if (new_vfbs && new_vfbs->surface->base_size.width == hdisplay &&
-	    new_vfbs->surface->base_size.height == vdisplay)
+	if (new_vfbs &&
+	    new_vfbs->surface->metadata.base_size.width == hdisplay &&
+	    new_vfbs->surface->metadata.base_size.height == vdisplay)
 		new_content_type = SAME_AS_DISPLAY;
 	else if (vfb->bo)
 		new_content_type = SEPARATE_BO;
@@ -1082,15 +1083,15 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 
 			switch (new_fb->format->cpp[0]*8) {
 			case 32:
-				content_srf.format = SVGA3D_X8R8G8B8;
+				content_srf.metadata.format = SVGA3D_X8R8G8B8;
 				break;
 
 			case 16:
-				content_srf.format = SVGA3D_R5G6B5;
+				content_srf.metadata.format = SVGA3D_R5G6B5;
 				break;
 
 			case 8:
-				content_srf.format = SVGA3D_P8;
+				content_srf.metadata.format = SVGA3D_P8;
 				break;
 
 			default:
@@ -1098,22 +1099,25 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 				return -EINVAL;
 			}
 
-			content_srf.flags             = 0;
-			content_srf.mip_levels[0]     = 1;
-			content_srf.multisample_count = 0;
-			content_srf.multisample_pattern =
+			content_srf.metadata.flags = 0;
+			content_srf.metadata.mip_levels[0] = 1;
+			content_srf.metadata.multisample_count = 0;
+			content_srf.metadata.multisample_pattern =
 				SVGA3D_MS_PATTERN_NONE;
-			content_srf.quality_level = SVGA3D_MS_QUALITY_NONE;
+			content_srf.metadata.quality_level =
+				SVGA3D_MS_QUALITY_NONE;
 		} else {
 			content_srf = *new_vfbs->surface;
 		}
 
 		if (vps->surf) {
-			struct drm_vmw_size cur_base_size = vps->surf->base_size;
+			struct drm_vmw_size cur_base_size =
+				vps->surf->metadata.base_size;
 
 			if (cur_base_size.width != display_base_size.width ||
 			    cur_base_size.height != display_base_size.height ||
-			    vps->surf->format != content_srf.format) {
+			    vps->surf->metadata.format !=
+			    content_srf.metadata.format) {
 				WARN_ON(vps->pinned != 0);
 				vmw_surface_unreference(&vps->surf);
 			}
@@ -1125,15 +1129,15 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 				(crtc->dev,
 				 /* Kernel visible only */
 				 0,
-				 content_srf.flags,
-				 content_srf.format,
+				 content_srf.metadata.flags,
+				 content_srf.metadata.format,
 				 true,  /* a scanout buffer */
-				 content_srf.mip_levels[0],
-				 content_srf.multisample_count,
+				 content_srf.metadata.mip_levels[0],
+				 content_srf.metadata.multisample_count,
 				 0,
 				 display_base_size,
-				 content_srf.multisample_pattern,
-				 content_srf.quality_level,
+				 content_srf.metadata.multisample_pattern,
+				 content_srf.metadata.quality_level,
 				 &vps->surf);
 			if (ret != 0) {
 				DRM_ERROR("Couldn't allocate STDU surface.\n");
@@ -1311,7 +1315,7 @@ vmw_stdu_bo_populate_update_cpu(struct vmw_du_update_plane  *update, void *cmd,
 	diff.cpp = stdu->cpp;
 
 	dst_bo = &stdu->display_srf->res.backup->base;
-	dst_pitch = stdu->display_srf->base_size.width * stdu->cpp;
+	dst_pitch = stdu->display_srf->metadata.base_size.width * stdu->cpp;
 	dst_offset = bb->y1 * dst_pitch + bb->x1 * stdu->cpp;
 
 	src_bo = &vfbbo->buffer->base;

commit 81a00960d3fa83bbff9939ff52e89f0b74801937
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Wed Jan 15 21:48:19 2020 +0100

    drm/vmwgfx: Fix the refuse_dma mode when using guest-backed objects
    
    When we refuse DMA from system pages for whatever reason, we don't
    handle that correctly when guest-backed objects was enabled.
    Since guest-backed objects by definition require DMA to and from
    system pages, disable all functionality that relies on them.
    That basically amounts to 3D acceleration and screen targets.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Brian Paul <brianp@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 570687a1a327..68aecb6d9f87 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1888,7 +1888,7 @@ int vmw_kms_stdu_init_display(struct vmw_private *dev_priv)
 
 
 	/* Do nothing if Screen Target support is turned off */
-	if (!VMWGFX_ENABLE_SCREEN_TARGET_OTABLE)
+	if (!VMWGFX_ENABLE_SCREEN_TARGET_OTABLE || !dev_priv->has_mob)
 		return -ENOSYS;
 
 	if (!(dev_priv->capabilities & SVGA_CAP_GBOBJECTS))

commit 4bebe91adbf58a042bb2d16701b9d3f7ac7b42ec
Author: Thomas Zimmermann <tzimmermann@suse.de>
Date:   Thu Jan 23 14:59:41 2020 +0100

    drm/vmwgfx: Convert to CRTC VBLANK callbacks
    
    VBLANK callbacks in struct drm_driver are deprecated in favor of
    their equivalents in struct drm_crtc_funcs. Convert vmwgfx over.
    
    v2:
            * remove accidental whitespace fixes
    
    Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
    Acked-by: Thomas Hellstrom <thellstrom@vmware.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200123135943.24140-21-tzimmermann@suse.de

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 41a96fb49835..570687a1a327 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -916,6 +916,9 @@ static const struct drm_crtc_funcs vmw_stdu_crtc_funcs = {
 	.atomic_destroy_state = vmw_du_crtc_destroy_state,
 	.set_config = drm_atomic_helper_set_config,
 	.page_flip = drm_atomic_helper_page_flip,
+	.get_vblank_counter = vmw_get_vblank_counter,
+	.enable_vblank = vmw_enable_vblank,
+	.disable_vblank = vmw_disable_vblank,
 };
 
 

commit d5c1f0110dd6cb182d698b2df7e0445282a1392d
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Jun 23 12:23:33 2019 +0200

    drm/vmwgfx: drop use of drmP.h in header files
    
    To facilitate removal of drmP.h in the .c
    files remove the use from header files first.
    Fix fallout in the other files.
    
    Sorted include files in blocks and sorted files
    within each block in alphabetical order.
    
    This revealed a dependency from an uapi header to a header
    located below drivers/gpu/drm/vmwgfx/.
    Added FIXME to remind someone to fix this.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: VMware Graphics <linux-graphics-maintainer@vmware.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Reviewed-by: Deepak Rawat <drawat@vmware.com>
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index f803bb5e782b..41a96fb49835 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -25,12 +25,15 @@
  *
  ******************************************************************************/
 
-#include "vmwgfx_kms.h"
-#include "device_include/svga3d_surfacedefs.h"
-#include <drm/drm_plane_helper.h>
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_damage_helper.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_vblank.h>
+
+#include "vmwgfx_kms.h"
+#include "device_include/svga3d_surfacedefs.h"
 
 #define vmw_crtc_to_stdu(x) \
 	container_of(x, struct vmw_screen_target_display_unit, base.crtc)

commit 11c454196610ae25784ac19dc3f886a4328007e4
Author: Deepak Rawat <drawat@vmware.com>
Date:   Thu Feb 14 16:15:39 2019 -0800

    drm/vmwgfx: Use preprocessor macro for FIFO allocation
    
    Whenever FIFO allocation fails an error message is printed to dmesg.
    Since this is common operation a lot of similar messages are scattered
    everywhere. Use preprocessor macro to remove this cluttering.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 1a65008a27b2..f803bb5e782b 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -167,12 +167,9 @@ static int vmw_stdu_define_st(struct vmw_private *dev_priv,
 		SVGA3dCmdDefineGBScreenTarget body;
 	} *cmd;
 
-	cmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));
-
-	if (unlikely(cmd == NULL)) {
-		DRM_ERROR("Out of FIFO space defining Screen Target\n");
+	cmd = VMW_FIFO_RESERVE(dev_priv, sizeof(*cmd));
+	if (unlikely(cmd == NULL))
 		return -ENOMEM;
-	}
 
 	cmd->header.id   = SVGA_3D_CMD_DEFINE_GB_SCREENTARGET;
 	cmd->header.size = sizeof(cmd->body);
@@ -229,12 +226,9 @@ static int vmw_stdu_bind_st(struct vmw_private *dev_priv,
 	memset(&image, 0, sizeof(image));
 	image.sid = res ? res->id : SVGA3D_INVALID_ID;
 
-	cmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));
-
-	if (unlikely(cmd == NULL)) {
-		DRM_ERROR("Out of FIFO space binding a screen target\n");
+	cmd = VMW_FIFO_RESERVE(dev_priv, sizeof(*cmd));
+	if (unlikely(cmd == NULL))
 		return -ENOMEM;
-	}
 
 	cmd->header.id   = SVGA_3D_CMD_BIND_GB_SCREENTARGET;
 	cmd->header.size = sizeof(cmd->body);
@@ -296,12 +290,9 @@ static int vmw_stdu_update_st(struct vmw_private *dev_priv,
 		return -EINVAL;
 	}
 
-	cmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));
-
-	if (unlikely(cmd == NULL)) {
-		DRM_ERROR("Out of FIFO space updating a Screen Target\n");
+	cmd = VMW_FIFO_RESERVE(dev_priv, sizeof(*cmd));
+	if (unlikely(cmd == NULL))
 		return -ENOMEM;
-	}
 
 	vmw_stdu_populate_update(cmd, stdu->base.unit,
 				 0, stdu->display_width,
@@ -335,12 +326,9 @@ static int vmw_stdu_destroy_st(struct vmw_private *dev_priv,
 	if (unlikely(!stdu->defined))
 		return 0;
 
-	cmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));
-
-	if (unlikely(cmd == NULL)) {
-		DRM_ERROR("Out of FIFO space, screen target not destroyed\n");
+	cmd = VMW_FIFO_RESERVE(dev_priv, sizeof(*cmd));
+	if (unlikely(cmd == NULL))
 		return -ENOMEM;
-	}
 
 	cmd->header.id   = SVGA_3D_CMD_DESTROY_GB_SCREENTARGET;
 	cmd->header.size = sizeof(cmd->body);
@@ -637,12 +625,9 @@ static void vmw_stdu_bo_cpu_commit(struct vmw_kms_dirty *dirty)
 
 
 		dev_priv = vmw_priv(stdu->base.crtc.dev);
-		cmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));
-
-		if (!cmd) {
-			DRM_ERROR("Cannot reserve FIFO space to update STDU");
+		cmd = VMW_FIFO_RESERVE(dev_priv, sizeof(*cmd));
+		if (!cmd)
 			goto out_cleanup;
-		}
 
 		vmw_stdu_populate_update(cmd, stdu->base.unit,
 					 region.x1, region.x2,

commit a9f58c456e9dde6f272e7be4d6bed607fd7008aa
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Wed Feb 20 08:21:26 2019 +0100

    drm/vmwgfx: Be more restrictive when dirtying resources
    
    Currently we flag resources as dirty (GPU contents not yet read back to
    the backing MOB) whenever they have been part of a command stream.
    Obviously many resources can't be dirty and others can only be dirty when
    written to by the GPU. That is when they are either bound to the context as
    render-targets, depth-stencil, copy / clear destinations and
    stream-output targets, or similarly when there are corresponding views into
    them.
    So mark resources dirty only in these special cases. Context- and cotable
    resources are always marked dirty when referenced.
    This is important for upcoming emulated coherent memory, since we can avoid
    issuing automatic readbacks to non-dirty resources when the CPU tries to
    access part of the backing MOB.
    
    Testing: Unigine Heaven with max GPU memory set to 256MB resulting in
    heavy resource thrashing.
    ---
    v2: Addressed review comments by Deepak Rawat.
    v3: Added some documentation
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Deepak Rawat <drawat@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 096c2941a8e4..1a65008a27b2 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -111,7 +111,7 @@ struct vmw_stdu_update_gb_image {
  */
 struct vmw_screen_target_display_unit {
 	struct vmw_display_unit base;
-	const struct vmw_surface *display_srf;
+	struct vmw_surface *display_srf;
 	enum stdu_content_type content_fb_type;
 	s32 display_width, display_height;
 
@@ -533,6 +533,7 @@ static void vmw_stdu_bo_fifo_commit(struct vmw_kms_dirty *dirty)
 
 	vmw_fifo_commit(dirty->dev_priv, sizeof(*cmd) + blit_size);
 
+	stdu->display_srf->res.res_dirty = true;
 	ddirty->left = ddirty->top = S32_MAX;
 	ddirty->right = ddirty->bottom = S32_MIN;
 }
@@ -629,9 +630,8 @@ static void vmw_stdu_bo_cpu_commit(struct vmw_kms_dirty *dirty)
 		region.x2 = diff.rect.x2;
 		region.y1 = diff.rect.y1;
 		region.y2 = diff.rect.y2;
-		ret = vmw_kms_update_proxy(
-			(struct vmw_resource *) &stdu->display_srf->res,
-			(const struct drm_clip_rect *) &region, 1, 1);
+		ret = vmw_kms_update_proxy(&stdu->display_srf->res, &region,
+					   1, 1);
 		if (ret)
 			goto out_cleanup;
 
@@ -820,6 +820,7 @@ static void vmw_kms_stdu_surface_fifo_commit(struct vmw_kms_dirty *dirty)
 		cmd->body.dest.sid = stdu->display_srf->res.id;
 		update = (struct vmw_stdu_update *) &blit[dirty->num_hits];
 		commit_size = sizeof(*cmd) + blit_size + sizeof(*update);
+		stdu->display_srf->res.res_dirty = true;
 	} else {
 		update = dirty->cmd;
 		commit_size = sizeof(*update);
@@ -876,7 +877,8 @@ int vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,
 	if (!srf)
 		srf = &vfbs->surface->res;
 
-	ret = vmw_validation_add_resource(&val_ctx, srf, 0, NULL, NULL);
+	ret = vmw_validation_add_resource(&val_ctx, srf, 0, VMW_RES_DIRTY_NONE,
+					  NULL, NULL);
 	if (ret)
 		return ret;
 

commit 9a01135b98b9d5a7033c544245da7aad0d886758
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Wed Nov 14 08:11:05 2018 +0100

    drm/vmwgfx: Use the standard atomic helpers for page-flip
    
    Our wrappers don't do anything useful anymore except calling the
    atomic helpers.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Brian Paul <brianp@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 26a3515ae718..096c2941a8e4 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -452,48 +452,6 @@ static void vmw_stdu_crtc_atomic_disable(struct drm_crtc *crtc,
 	}
 }
 
-/**
- * vmw_stdu_crtc_page_flip - Binds a buffer to a screen target
- *
- * @crtc: CRTC to attach FB to
- * @fb: FB to attach
- * @event: Event to be posted. This event should've been alloced
- *         using k[mz]alloc, and should've been completely initialized.
- * @page_flip_flags: Input flags.
- *
- * If the STDU uses the same display and content buffers, i.e. a true flip,
- * this function will replace the existing display buffer with the new content
- * buffer.
- *
- * If the STDU uses different display and content buffers, i.e. a blit, then
- * only the content buffer will be updated.
- *
- * RETURNS:
- * 0 on success, error code on failure
- */
-static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
-				   struct drm_framebuffer *new_fb,
-				   struct drm_pending_vblank_event *event,
-				   uint32_t flags,
-				   struct drm_modeset_acquire_ctx *ctx)
-
-{
-	struct vmw_screen_target_display_unit *stdu = vmw_crtc_to_stdu(crtc);
-	int ret;
-
-	if (!stdu->defined)
-		return -EINVAL;
-
-	ret = drm_atomic_helper_page_flip(crtc, new_fb, event, flags, ctx);
-	if (ret) {
-		DRM_ERROR("Page flip error %d.\n", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-
 /**
  * vmw_stdu_bo_clip - Callback to encode a suface DMA command cliprect
  *
@@ -967,7 +925,7 @@ static const struct drm_crtc_funcs vmw_stdu_crtc_funcs = {
 	.atomic_duplicate_state = vmw_du_crtc_duplicate_state,
 	.atomic_destroy_state = vmw_du_crtc_destroy_state,
 	.set_config = drm_atomic_helper_set_config,
-	.page_flip = vmw_stdu_crtc_page_flip,
+	.page_flip = drm_atomic_helper_page_flip,
 };
 
 

commit 9d9486e43728cd513e10ed3dd54e156c8ab7bd2a
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Thu Oct 4 22:38:17 2018 +0000

    drm/vmwgfx: Fix up the implicit display unit handling
    
    Make the connector is_implicit property immutable.
    As far as we know, no user-space application is writing to it.
    
    Also move the verification that all implicit display units scan out
    from the same framebuffer to atomic_check().
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Deepak Rawat <drawat@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 9f645aa00c48..26a3515ae718 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -400,13 +400,8 @@ static void vmw_stdu_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	if (!crtc->state->enable)
 		return;
 
-	if (stdu->base.is_implicit) {
-		x = crtc->x;
-		y = crtc->y;
-	} else {
-		x = vmw_conn_state->gui_x;
-		y = vmw_conn_state->gui_y;
-	}
+	x = vmw_conn_state->gui_x;
+	y = vmw_conn_state->gui_y;
 
 	vmw_svga_enable(dev_priv);
 	ret = vmw_stdu_define_st(dev_priv, stdu, &crtc->mode, x, y);
@@ -421,27 +416,9 @@ static void vmw_stdu_crtc_helper_prepare(struct drm_crtc *crtc)
 {
 }
 
-
 static void vmw_stdu_crtc_atomic_enable(struct drm_crtc *crtc,
 					struct drm_crtc_state *old_state)
 {
-	struct drm_plane_state *plane_state = crtc->primary->state;
-	struct vmw_private *dev_priv;
-	struct vmw_screen_target_display_unit *stdu;
-	struct vmw_framebuffer *vfb;
-	struct drm_framebuffer *fb;
-
-
-	stdu     = vmw_crtc_to_stdu(crtc);
-	dev_priv = vmw_priv(crtc->dev);
-	fb       = plane_state->fb;
-
-	vfb = (fb) ? vmw_framebuffer_to_vfb(fb) : NULL;
-
-	if (vfb)
-		vmw_kms_add_active(dev_priv, &stdu->base, vfb);
-	else
-		vmw_kms_del_active(dev_priv, &stdu->base);
 }
 
 static void vmw_stdu_crtc_atomic_disable(struct drm_crtc *crtc,
@@ -501,11 +478,10 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 				   struct drm_modeset_acquire_ctx *ctx)
 
 {
-	struct vmw_private *dev_priv = vmw_priv(crtc->dev);
 	struct vmw_screen_target_display_unit *stdu = vmw_crtc_to_stdu(crtc);
 	int ret;
 
-	if (!stdu->defined || !vmw_kms_crtc_flippable(dev_priv, crtc))
+	if (!stdu->defined)
 		return -EINVAL;
 
 	ret = drm_atomic_helper_page_flip(crtc, new_fb, event, flags, ctx);
@@ -1046,13 +1022,10 @@ static const struct drm_connector_funcs vmw_stdu_connector_funcs = {
 	.dpms = vmw_du_connector_dpms,
 	.detect = vmw_du_connector_detect,
 	.fill_modes = vmw_du_connector_fill_modes,
-	.set_property = vmw_du_connector_set_property,
 	.destroy = vmw_stdu_connector_destroy,
 	.reset = vmw_du_connector_reset,
 	.atomic_duplicate_state = vmw_du_connector_duplicate_state,
 	.atomic_destroy_state = vmw_du_connector_destroy_state,
-	.atomic_set_property = vmw_du_connector_atomic_set_property,
-	.atomic_get_property = vmw_du_connector_atomic_get_property,
 };
 
 
@@ -1826,11 +1799,6 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 	stdu->base.pref_active = (unit == 0);
 	stdu->base.pref_width  = dev_priv->initial_width;
 	stdu->base.pref_height = dev_priv->initial_height;
-
-	/*
-	 * Remove this after enabling atomic because property values can
-	 * only exist in a state object
-	 */
 	stdu->base.is_implicit = false;
 
 	/* Initialize primary plane */
@@ -1876,7 +1844,6 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 
 	drm_connector_helper_add(connector, &vmw_stdu_connector_helper_funcs);
 	connector->status = vmw_du_connector_detect(connector, false);
-	vmw_connector_state_to_vcs(connector->state)->is_implicit = false;
 
 	ret = drm_encoder_init(dev, encoder, &vmw_stdu_encoder_funcs,
 			       DRM_MODE_ENCODER_VIRTUAL, NULL);
@@ -1914,11 +1881,6 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 				   dev->mode_config.suggested_x_property, 0);
 	drm_object_attach_property(&connector->base,
 				   dev->mode_config.suggested_y_property, 0);
-	if (dev_priv->implicit_placement_property)
-		drm_object_attach_property
-			(&connector->base,
-			 dev_priv->implicit_placement_property,
-			 stdu->base.is_implicit);
 	return 0;
 
 err_free_unregister:
@@ -1987,8 +1949,6 @@ int vmw_kms_stdu_init_display(struct vmw_private *dev_priv)
 
 	dev_priv->active_display_unit = vmw_du_screen_target;
 
-	vmw_kms_create_implicit_placement_property(dev_priv, false);
-
 	for (i = 0; i < VMWGFX_NUM_DISPLAY_UNITS; ++i) {
 		ret = vmw_stdu_init(dev_priv, i);
 

commit b4fa61ba05f2afa17558914fdd2b819e9e7e466f
Author: Deepak Rawat <drawat@vmware.com>
Date:   Wed Sep 26 17:17:33 2018 -0700

    drm/vmwgfx: Don't clear mode::type anymore
    
    With kernel commit "drm/modes: Kill off the oddball DRM_MODE_TYPE_CRTC_C
    vs. DRM_MODE_TYPE_BUILTIN handling", no need to clear mode::type for
    user-space bug.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 4a060e6e8297..9f645aa00c48 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -990,7 +990,7 @@ static const struct drm_crtc_funcs vmw_stdu_crtc_funcs = {
 	.reset = vmw_du_crtc_reset,
 	.atomic_duplicate_state = vmw_du_crtc_duplicate_state,
 	.atomic_destroy_state = vmw_du_crtc_destroy_state,
-	.set_config = vmw_kms_set_config,
+	.set_config = drm_atomic_helper_set_config,
 	.page_flip = vmw_stdu_crtc_page_flip,
 };
 

commit 8bb6af5b0cbec157e1481d66d562f4752d28d361
Author: Deepak Rawat <drawat@vmware.com>
Date:   Fri Jul 27 17:28:17 2018 -0700

    drm/vmwgfx: Enable FB_DAMAGE_CLIPS property for STDU primary plane
    
    STDU primary plane now support damage clips, enable it for user-space.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index f6f788b4a19d..4a060e6e8297 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1847,6 +1847,7 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 	}
 
 	drm_plane_helper_add(primary, &vmw_stdu_primary_plane_helper_funcs);
+	drm_plane_enable_fb_damage_clips(primary);
 
 	/* Initialize cursor plane */
 	vmw_du_plane_reset(cursor);

commit 88b37c3ae769beb9f0b2a15604788a497211ad45
Author: Deepak Rawat <drawat@vmware.com>
Date:   Fri Sep 21 13:46:42 2018 -0700

    drm/vmwgfx: Update comments for stdu plane update
    
    Update the comments to sync with code.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 0dcaec59ebe8..f6f788b4a19d 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1656,7 +1656,6 @@ static int vmw_stdu_plane_update_surface(struct vmw_private *dev_priv,
 
 /**
  * vmw_stdu_primary_plane_atomic_update - formally switches STDU to new plane
- *
  * @plane: display plane
  * @old_state: Only used to get crtc info
  *
@@ -1677,10 +1676,7 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 	struct vmw_private *dev_priv;
 	int ret;
 
-	/*
-	 * We cannot really fail this function, so if we do, then output an
-	 * error and maintain consistent atomic state.
-	 */
+	/* If case of device error, maintain consistent atomic state */
 	if (crtc && plane->state->fb) {
 		struct vmw_framebuffer *vfb =
 			vmw_framebuffer_to_vfb(plane->state->fb);
@@ -1709,12 +1705,7 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 		stdu = vmw_crtc_to_stdu(crtc);
 		dev_priv = vmw_priv(crtc->dev);
 
-		/*
-		 * When disabling a plane, CRTC and FB should always be NULL
-		 * together, otherwise it's an error.
-		 * Here primary plane is being disable so blank the screen
-		 * target display unit, if not already done.
-		 */
+		/* Blank STDU when fb and crtc are NULL */
 		if (!stdu->defined)
 			return;
 
@@ -1729,11 +1720,8 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 		return;
 	}
 
+	/* In case of error, vblank event is send in vmw_du_crtc_atomic_flush */
 	event = crtc->state->event;
-	/*
-	 * In case of failure and other cases, vblank event will be sent in
-	 * vmw_du_crtc_atomic_flush.
-	 */
 	if (event && fence) {
 		struct drm_file *file_priv = event->base.file_priv;
 

commit 4606eeaf679b796c98a9fe69f324c7ddfab35409
Author: Deepak Rawat <drawat@vmware.com>
Date:   Fri Sep 21 13:42:35 2018 -0700

    drm/vmwgfx: Use the new interface for STDU plane update
    
    With new interface to do plane update on STDU available, use that
    instead of old kms_dirty.
    
    v2: Use fence from new resource validation.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index e976aa0235e6..0dcaec59ebe8 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1673,6 +1673,7 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 	struct drm_crtc *crtc = plane->state->crtc;
 	struct vmw_screen_target_display_unit *stdu;
 	struct drm_pending_vblank_event *event;
+	struct vmw_fence_obj *fence = NULL;
 	struct vmw_private *dev_priv;
 	int ret;
 
@@ -1683,7 +1684,6 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 	if (crtc && plane->state->fb) {
 		struct vmw_framebuffer *vfb =
 			vmw_framebuffer_to_vfb(plane->state->fb);
-		struct drm_vmw_rect vclips;
 		stdu = vmw_crtc_to_stdu(crtc);
 		dev_priv = vmw_priv(crtc->dev);
 
@@ -1691,23 +1691,17 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 		stdu->content_fb_type = vps->content_fb_type;
 		stdu->cpp = vps->cpp;
 
-		vclips.x = crtc->x;
-		vclips.y = crtc->y;
-		vclips.w = crtc->mode.hdisplay;
-		vclips.h = crtc->mode.vdisplay;
-
 		ret = vmw_stdu_bind_st(dev_priv, stdu, &stdu->display_srf->res);
 		if (ret)
 			DRM_ERROR("Failed to bind surface to STDU.\n");
 
 		if (vfb->bo)
-			ret = vmw_kms_stdu_dma(dev_priv, NULL, vfb, NULL, NULL,
-					       &vclips, 1, 1, true, false,
-					       crtc);
+			ret = vmw_stdu_plane_update_bo(dev_priv, plane,
+						       old_state, vfb, &fence);
 		else
-			ret = vmw_kms_stdu_surface_dirty(dev_priv, vfb, NULL,
-							 &vclips, NULL, 0, 0,
-							 1, 1, NULL, crtc);
+			ret = vmw_stdu_plane_update_surface(dev_priv, plane,
+							    old_state, vfb,
+							    &fence);
 		if (ret)
 			DRM_ERROR("Failed to update STDU.\n");
 	} else {
@@ -1740,31 +1734,23 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 	 * In case of failure and other cases, vblank event will be sent in
 	 * vmw_du_crtc_atomic_flush.
 	 */
-	if (event && (ret == 0)) {
-		struct vmw_fence_obj *fence = NULL;
+	if (event && fence) {
 		struct drm_file *file_priv = event->base.file_priv;
 
-		vmw_execbuf_fence_commands(NULL, dev_priv, &fence, NULL);
-
-		/*
-		 * If fence is NULL, then already sync.
-		 */
-		if (fence) {
-			ret = vmw_event_fence_action_queue(
-				file_priv, fence, &event->base,
-				&event->event.vbl.tv_sec,
-				&event->event.vbl.tv_usec,
-				true);
-			if (ret)
-				DRM_ERROR("Failed to queue event on fence.\n");
-			else
-				crtc->state->event = NULL;
-
-			vmw_fence_obj_unreference(&fence);
-		}
-	} else {
-		(void) vmw_fifo_flush(dev_priv, false);
+		ret = vmw_event_fence_action_queue(file_priv,
+						   fence,
+						   &event->base,
+						   &event->event.vbl.tv_sec,
+						   &event->event.vbl.tv_usec,
+						   true);
+		if (ret)
+			DRM_ERROR("Failed to queue event on fence.\n");
+		else
+			crtc->state->event = NULL;
 	}
+
+	if (fence)
+		vmw_fence_obj_unreference(&fence);
 }
 
 

commit bc7be607a0edc1bf1ea403efbdd0fe81a71dc369
Author: Deepak Rawat <drawat@vmware.com>
Date:   Mon Jul 9 16:17:17 2018 -0700

    drm/vmwgfx: Implement STDU plane update for BO backed fb
    
    Using the new interface implement STDU plane update for BO backed fb.
    
    v2: Rebase to new resource validation.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 86368c5b778d..e976aa0235e6 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1260,6 +1260,222 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 	return ret;
 }
 
+static uint32_t vmw_stdu_bo_fifo_size(struct vmw_du_update_plane *update,
+				      uint32_t num_hits)
+{
+	return sizeof(struct vmw_stdu_dma) + sizeof(SVGA3dCopyBox) * num_hits +
+		sizeof(SVGA3dCmdSurfaceDMASuffix) +
+		sizeof(struct vmw_stdu_update);
+}
+
+static uint32_t vmw_stdu_bo_fifo_size_cpu(struct vmw_du_update_plane *update,
+					  uint32_t num_hits)
+{
+	return sizeof(struct vmw_stdu_update_gb_image) +
+		sizeof(struct vmw_stdu_update);
+}
+
+static uint32_t vmw_stdu_bo_populate_dma(struct vmw_du_update_plane  *update,
+					 void *cmd, uint32_t num_hits)
+{
+	struct vmw_screen_target_display_unit *stdu;
+	struct vmw_framebuffer_bo *vfbbo;
+	struct vmw_stdu_dma *cmd_dma = cmd;
+
+	stdu = container_of(update->du, typeof(*stdu), base);
+	vfbbo = container_of(update->vfb, typeof(*vfbbo), base);
+
+	cmd_dma->header.id = SVGA_3D_CMD_SURFACE_DMA;
+	cmd_dma->header.size = sizeof(cmd_dma->body) +
+		sizeof(struct SVGA3dCopyBox) * num_hits +
+		sizeof(SVGA3dCmdSurfaceDMASuffix);
+	vmw_bo_get_guest_ptr(&vfbbo->buffer->base, &cmd_dma->body.guest.ptr);
+	cmd_dma->body.guest.pitch = update->vfb->base.pitches[0];
+	cmd_dma->body.host.sid = stdu->display_srf->res.id;
+	cmd_dma->body.host.face = 0;
+	cmd_dma->body.host.mipmap = 0;
+	cmd_dma->body.transfer = SVGA3D_WRITE_HOST_VRAM;
+
+	return sizeof(*cmd_dma);
+}
+
+static uint32_t vmw_stdu_bo_populate_clip(struct vmw_du_update_plane  *update,
+					  void *cmd, struct drm_rect *clip,
+					  uint32_t fb_x, uint32_t fb_y)
+{
+	struct SVGA3dCopyBox *box = cmd;
+
+	box->srcx = fb_x;
+	box->srcy = fb_y;
+	box->srcz = 0;
+	box->x = clip->x1;
+	box->y = clip->y1;
+	box->z = 0;
+	box->w = drm_rect_width(clip);
+	box->h = drm_rect_height(clip);
+	box->d = 1;
+
+	return sizeof(*box);
+}
+
+static uint32_t vmw_stdu_bo_populate_update(struct vmw_du_update_plane  *update,
+					    void *cmd, struct drm_rect *bb)
+{
+	struct vmw_screen_target_display_unit *stdu;
+	struct vmw_framebuffer_bo *vfbbo;
+	SVGA3dCmdSurfaceDMASuffix *suffix = cmd;
+
+	stdu = container_of(update->du, typeof(*stdu), base);
+	vfbbo = container_of(update->vfb, typeof(*vfbbo), base);
+
+	suffix->suffixSize = sizeof(*suffix);
+	suffix->maximumOffset = vfbbo->buffer->base.num_pages * PAGE_SIZE;
+
+	vmw_stdu_populate_update(&suffix[1], stdu->base.unit, bb->x1, bb->x2,
+				 bb->y1, bb->y2);
+
+	return sizeof(*suffix) + sizeof(struct vmw_stdu_update);
+}
+
+static uint32_t vmw_stdu_bo_pre_clip_cpu(struct vmw_du_update_plane  *update,
+					 void *cmd, uint32_t num_hits)
+{
+	struct vmw_du_update_plane_buffer *bo_update =
+		container_of(update, typeof(*bo_update), base);
+
+	bo_update->fb_left = INT_MAX;
+	bo_update->fb_top = INT_MAX;
+
+	return 0;
+}
+
+static uint32_t vmw_stdu_bo_clip_cpu(struct vmw_du_update_plane  *update,
+				     void *cmd, struct drm_rect *clip,
+				     uint32_t fb_x, uint32_t fb_y)
+{
+	struct vmw_du_update_plane_buffer *bo_update =
+		container_of(update, typeof(*bo_update), base);
+
+	bo_update->fb_left = min_t(int, bo_update->fb_left, fb_x);
+	bo_update->fb_top = min_t(int, bo_update->fb_top, fb_y);
+
+	return 0;
+}
+
+static uint32_t
+vmw_stdu_bo_populate_update_cpu(struct vmw_du_update_plane  *update, void *cmd,
+				struct drm_rect *bb)
+{
+	struct vmw_du_update_plane_buffer *bo_update;
+	struct vmw_screen_target_display_unit *stdu;
+	struct vmw_framebuffer_bo *vfbbo;
+	struct vmw_diff_cpy diff = VMW_CPU_BLIT_DIFF_INITIALIZER(0);
+	struct vmw_stdu_update_gb_image *cmd_img = cmd;
+	struct vmw_stdu_update *cmd_update;
+	struct ttm_buffer_object *src_bo, *dst_bo;
+	u32 src_offset, dst_offset;
+	s32 src_pitch, dst_pitch;
+	s32 width, height;
+
+	bo_update = container_of(update, typeof(*bo_update), base);
+	stdu = container_of(update->du, typeof(*stdu), base);
+	vfbbo = container_of(update->vfb, typeof(*vfbbo), base);
+
+	width = bb->x2 - bb->x1;
+	height = bb->y2 - bb->y1;
+
+	diff.cpp = stdu->cpp;
+
+	dst_bo = &stdu->display_srf->res.backup->base;
+	dst_pitch = stdu->display_srf->base_size.width * stdu->cpp;
+	dst_offset = bb->y1 * dst_pitch + bb->x1 * stdu->cpp;
+
+	src_bo = &vfbbo->buffer->base;
+	src_pitch = update->vfb->base.pitches[0];
+	src_offset = bo_update->fb_top * src_pitch + bo_update->fb_left *
+		stdu->cpp;
+
+	(void) vmw_bo_cpu_blit(dst_bo, dst_offset, dst_pitch, src_bo,
+			       src_offset, src_pitch, width * stdu->cpp, height,
+			       &diff);
+
+	if (drm_rect_visible(&diff.rect)) {
+		SVGA3dBox *box = &cmd_img->body.box;
+
+		cmd_img->header.id = SVGA_3D_CMD_UPDATE_GB_IMAGE;
+		cmd_img->header.size = sizeof(cmd_img->body);
+		cmd_img->body.image.sid = stdu->display_srf->res.id;
+		cmd_img->body.image.face = 0;
+		cmd_img->body.image.mipmap = 0;
+
+		box->x = diff.rect.x1;
+		box->y = diff.rect.y1;
+		box->z = 0;
+		box->w = drm_rect_width(&diff.rect);
+		box->h = drm_rect_height(&diff.rect);
+		box->d = 1;
+
+		cmd_update = (struct vmw_stdu_update *)&cmd_img[1];
+		vmw_stdu_populate_update(cmd_update, stdu->base.unit,
+					 diff.rect.x1, diff.rect.x2,
+					 diff.rect.y1, diff.rect.y2);
+
+		return sizeof(*cmd_img) + sizeof(*cmd_update);
+	}
+
+	return 0;
+}
+
+/**
+ * vmw_stdu_plane_update_bo - Update display unit for bo backed fb.
+ * @dev_priv: device private.
+ * @plane: plane state.
+ * @old_state: old plane state.
+ * @vfb: framebuffer which is blitted to display unit.
+ * @out_fence: If non-NULL, will return a ref-counted pointer to vmw_fence_obj.
+ *             The returned fence pointer may be NULL in which case the device
+ *             has already synchronized.
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+static int vmw_stdu_plane_update_bo(struct vmw_private *dev_priv,
+				    struct drm_plane *plane,
+				    struct drm_plane_state *old_state,
+				    struct vmw_framebuffer *vfb,
+				    struct vmw_fence_obj **out_fence)
+{
+	struct vmw_du_update_plane_buffer bo_update;
+
+	memset(&bo_update, 0, sizeof(struct vmw_du_update_plane_buffer));
+	bo_update.base.plane = plane;
+	bo_update.base.old_state = old_state;
+	bo_update.base.dev_priv = dev_priv;
+	bo_update.base.du = vmw_crtc_to_du(plane->state->crtc);
+	bo_update.base.vfb = vfb;
+	bo_update.base.out_fence = out_fence;
+	bo_update.base.mutex = NULL;
+	bo_update.base.cpu_blit = !(dev_priv->capabilities & SVGA_CAP_3D);
+	bo_update.base.intr = false;
+
+	/*
+	 * VM without 3D support don't have surface DMA command and framebuffer
+	 * should be moved out of VRAM.
+	 */
+	if (bo_update.base.cpu_blit) {
+		bo_update.base.calc_fifo_size = vmw_stdu_bo_fifo_size_cpu;
+		bo_update.base.pre_clip = vmw_stdu_bo_pre_clip_cpu;
+		bo_update.base.clip = vmw_stdu_bo_clip_cpu;
+		bo_update.base.post_clip = vmw_stdu_bo_populate_update_cpu;
+	} else {
+		bo_update.base.calc_fifo_size = vmw_stdu_bo_fifo_size;
+		bo_update.base.pre_clip = vmw_stdu_bo_populate_dma;
+		bo_update.base.clip = vmw_stdu_bo_populate_clip;
+		bo_update.base.post_clip = vmw_stdu_bo_populate_update;
+	}
+
+	return vmw_du_helper_plane_update(&bo_update.base);
+}
+
 static uint32_t
 vmw_stdu_surface_fifo_size_same_display(struct vmw_du_update_plane *update,
 					uint32_t num_hits)

commit ad377b433b8072861be86ba435944c8a42a20228
Author: Deepak Rawat <drawat@vmware.com>
Date:   Wed Jul 11 16:25:19 2018 -0700

    drm/vmwgfx: Implement STDU plane update for surface backed fb
    
    Using the new interface implement STDU plane update for surface backed
    fb.
    
    v2: Rebase to new resource validation.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index c3e435f444c1..86368c5b778d 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -30,7 +30,7 @@
 #include <drm/drm_plane_helper.h>
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
-
+#include <drm/drm_damage_helper.h>
 
 #define vmw_crtc_to_stdu(x) \
 	container_of(x, struct vmw_screen_target_display_unit, base.crtc)
@@ -92,6 +92,10 @@ struct vmw_stdu_surface_copy {
 	SVGA3dCmdSurfaceCopy body;
 };
 
+struct vmw_stdu_update_gb_image {
+	SVGA3dCmdHeader header;
+	SVGA3dCmdUpdateGBImage body;
+};
 
 /**
  * struct vmw_screen_target_display_unit
@@ -1256,7 +1260,183 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 	return ret;
 }
 
+static uint32_t
+vmw_stdu_surface_fifo_size_same_display(struct vmw_du_update_plane *update,
+					uint32_t num_hits)
+{
+	struct vmw_framebuffer_surface *vfbs;
+	uint32_t size = 0;
+
+	vfbs = container_of(update->vfb, typeof(*vfbs), base);
+
+	if (vfbs->is_bo_proxy)
+		size += sizeof(struct vmw_stdu_update_gb_image) * num_hits;
+
+	size += sizeof(struct vmw_stdu_update);
+
+	return size;
+}
+
+static uint32_t vmw_stdu_surface_fifo_size(struct vmw_du_update_plane *update,
+					   uint32_t num_hits)
+{
+	struct vmw_framebuffer_surface *vfbs;
+	uint32_t size = 0;
+
+	vfbs = container_of(update->vfb, typeof(*vfbs), base);
+
+	if (vfbs->is_bo_proxy)
+		size += sizeof(struct vmw_stdu_update_gb_image) * num_hits;
+
+	size += sizeof(struct vmw_stdu_surface_copy) + sizeof(SVGA3dCopyBox) *
+		num_hits + sizeof(struct vmw_stdu_update);
+
+	return size;
+}
+
+static uint32_t
+vmw_stdu_surface_update_proxy(struct vmw_du_update_plane *update, void *cmd)
+{
+	struct vmw_framebuffer_surface *vfbs;
+	struct drm_plane_state *state = update->plane->state;
+	struct drm_plane_state *old_state = update->old_state;
+	struct vmw_stdu_update_gb_image *cmd_update = cmd;
+	struct drm_atomic_helper_damage_iter iter;
+	struct drm_rect clip;
+	uint32_t copy_size = 0;
+
+	vfbs = container_of(update->vfb, typeof(*vfbs), base);
+
+	/*
+	 * proxy surface is special where a buffer object type fb is wrapped
+	 * in a surface and need an update gb image command to sync with device.
+	 */
+	drm_atomic_helper_damage_iter_init(&iter, old_state, state);
+	drm_atomic_for_each_plane_damage(&iter, &clip) {
+		SVGA3dBox *box = &cmd_update->body.box;
+
+		cmd_update->header.id = SVGA_3D_CMD_UPDATE_GB_IMAGE;
+		cmd_update->header.size = sizeof(cmd_update->body);
+		cmd_update->body.image.sid = vfbs->surface->res.id;
+		cmd_update->body.image.face = 0;
+		cmd_update->body.image.mipmap = 0;
+
+		box->x = clip.x1;
+		box->y = clip.y1;
+		box->z = 0;
+		box->w = drm_rect_width(&clip);
+		box->h = drm_rect_height(&clip);
+		box->d = 1;
+
+		copy_size += sizeof(*cmd_update);
+		cmd_update++;
+	}
+
+	return copy_size;
+}
 
+static uint32_t
+vmw_stdu_surface_populate_copy(struct vmw_du_update_plane  *update, void *cmd,
+			       uint32_t num_hits)
+{
+	struct vmw_screen_target_display_unit *stdu;
+	struct vmw_framebuffer_surface *vfbs;
+	struct vmw_stdu_surface_copy *cmd_copy = cmd;
+
+	stdu = container_of(update->du, typeof(*stdu), base);
+	vfbs = container_of(update->vfb, typeof(*vfbs), base);
+
+	cmd_copy->header.id = SVGA_3D_CMD_SURFACE_COPY;
+	cmd_copy->header.size = sizeof(cmd_copy->body) + sizeof(SVGA3dCopyBox) *
+		num_hits;
+	cmd_copy->body.src.sid = vfbs->surface->res.id;
+	cmd_copy->body.dest.sid = stdu->display_srf->res.id;
+
+	return sizeof(*cmd_copy);
+}
+
+static uint32_t
+vmw_stdu_surface_populate_clip(struct vmw_du_update_plane  *update, void *cmd,
+			       struct drm_rect *clip, uint32_t fb_x,
+			       uint32_t fb_y)
+{
+	struct SVGA3dCopyBox *box = cmd;
+
+	box->srcx = fb_x;
+	box->srcy = fb_y;
+	box->srcz = 0;
+	box->x = clip->x1;
+	box->y = clip->y1;
+	box->z = 0;
+	box->w = drm_rect_width(clip);
+	box->h = drm_rect_height(clip);
+	box->d = 1;
+
+	return sizeof(*box);
+}
+
+static uint32_t
+vmw_stdu_surface_populate_update(struct vmw_du_update_plane  *update, void *cmd,
+				 struct drm_rect *bb)
+{
+	vmw_stdu_populate_update(cmd, update->du->unit, bb->x1, bb->x2, bb->y1,
+				 bb->y2);
+
+	return sizeof(struct vmw_stdu_update);
+}
+
+/**
+ * vmw_stdu_plane_update_surface - Update display unit for surface backed fb
+ * @dev_priv: Device private
+ * @plane: Plane state
+ * @old_state: Old plane state
+ * @vfb: Framebuffer which is blitted to display unit
+ * @out_fence: If non-NULL, will return a ref-counted pointer to vmw_fence_obj.
+ *             The returned fence pointer may be NULL in which case the device
+ *             has already synchronized.
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+static int vmw_stdu_plane_update_surface(struct vmw_private *dev_priv,
+					 struct drm_plane *plane,
+					 struct drm_plane_state *old_state,
+					 struct vmw_framebuffer *vfb,
+					 struct vmw_fence_obj **out_fence)
+{
+	struct vmw_du_update_plane srf_update;
+	struct vmw_screen_target_display_unit *stdu;
+	struct vmw_framebuffer_surface *vfbs;
+
+	stdu = vmw_crtc_to_stdu(plane->state->crtc);
+	vfbs = container_of(vfb, typeof(*vfbs), base);
+
+	memset(&srf_update, 0, sizeof(struct vmw_du_update_plane));
+	srf_update.plane = plane;
+	srf_update.old_state = old_state;
+	srf_update.dev_priv = dev_priv;
+	srf_update.du = vmw_crtc_to_du(plane->state->crtc);
+	srf_update.vfb = vfb;
+	srf_update.out_fence = out_fence;
+	srf_update.mutex = &dev_priv->cmdbuf_mutex;
+	srf_update.cpu_blit = false;
+	srf_update.intr = true;
+
+	if (vfbs->is_bo_proxy)
+		srf_update.post_prepare = vmw_stdu_surface_update_proxy;
+
+	if (vfbs->surface->res.id != stdu->display_srf->res.id) {
+		srf_update.calc_fifo_size = vmw_stdu_surface_fifo_size;
+		srf_update.pre_clip = vmw_stdu_surface_populate_copy;
+		srf_update.clip = vmw_stdu_surface_populate_clip;
+	} else {
+		srf_update.calc_fifo_size =
+			vmw_stdu_surface_fifo_size_same_display;
+	}
+
+	srf_update.post_clip = vmw_stdu_surface_populate_update;
+
+	return vmw_du_helper_plane_update(&srf_update);
+}
 
 /**
  * vmw_stdu_primary_plane_atomic_update - formally switches STDU to new plane

commit 6542e9adc0da1e23d81ff9314265a029b961906d
Merge: 2b02a05bdc3a f2bfc71aee75
Author: Sean Paul <seanpaul@chromium.org>
Date:   Wed Oct 24 14:26:04 2018 -0400

    Merge drm/drm-next into drm-misc-next
    
    4.19 is out, Lyude asked for a backmerge, and it's been a while. All
    very good reasons on their own :-)
    
    Signed-off-by: Sean Paul <seanpaul@chromium.org>

commit 297e30b5d9b6ddaa53da3026b4a762aa22e10fb0
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Oct 4 22:24:27 2018 +0200

    drm/atomic-helper: Unexport drm_atomic_helper_best_encoder
    
    It's the default. The exported version was kinda a transition state,
    before we made this the default.
    
    To stop new atomic drivers from using it (instead of just relying on
    the default) let's unexport it.
    
    v2: rename the default implementation to a more fitting name and add a
    comment (Laurent)
    
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Gustavo Padovan <gustavo@padovan.org>
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: David Airlie <airlied@linux.ie>
    Cc: VMware Graphics <linux-graphics-maintainer@vmware.com>
    Cc: Sinclair Yeh <syeh@vmware.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Archit Taneja <architt@codeaurora.org>
    Cc: Neil Armstrong <narmstrong@baylibre.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Hans Verkuil <hverkuil@xs4all.nl>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Cc: Jernej Skrabec <jernej.skrabec@siol.net>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Pierre-Hugues Husson <phh@phh.me>
    Cc: Fabio Estevam <fabio.estevam@nxp.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181004202446.22905-3-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index f30e839f7bfd..e28bb08114a5 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1037,7 +1037,6 @@ static const struct drm_connector_funcs vmw_stdu_connector_funcs = {
 
 static const struct
 drm_connector_helper_funcs vmw_stdu_connector_helper_funcs = {
-	.best_encoder = drm_atomic_helper_best_encoder,
 };
 
 

commit d04a836ea76c49db8c5547612d9c9cbb97f0402d
Merge: 87c2ee740c07 e8c66efbfe3a
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Oct 4 10:19:33 2018 +1000

    Merge branch 'vmwgfx-next' of git://people.freedesktop.org/~thomash/linux into drm-next
    
    Mostly code reorganizations and optimizations for vmwgfx.
    - Move TTM code that's only used by vmwgfx to vmwgfx
    - Break out the vmwgfx buffer- and resource validation code to a separate source file
    - Get rid of a number of atomic operations during command buffer validation.
    
    From: Thomas Hellstrom <thellstrom@vmware.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180928131157.2810-1-thellstrom@vmware.com

commit 2724b2d54cdad7de12e53e7ff2666822bafeae2a
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Wed Sep 26 15:34:50 2018 +0200

    drm/vmwgfx: Use new validation interface for the modesetting code v2
    
    Strip the old KMS helpers and use the new validation interface also in
    the modesetting code.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Deepak Rawat <drawat@vmware.com> #v1
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 93f6b96ca7bb..d3a9eba12b0e 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -759,17 +759,21 @@ int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
 	struct vmw_stdu_dirty ddirty;
 	int ret;
 	bool cpu_blit = !(dev_priv->capabilities & SVGA_CAP_3D);
+	DECLARE_VAL_CONTEXT(val_ctx, NULL, 0);
 
 	/*
 	 * VMs without 3D support don't have the surface DMA command and
 	 * we'll be using a CPU blit, and the framebuffer should be moved out
 	 * of VRAM.
 	 */
-	ret = vmw_kms_helper_buffer_prepare(dev_priv, buf, interruptible,
-					    false, cpu_blit);
+	ret = vmw_validation_add_bo(&val_ctx, buf, false, cpu_blit);
 	if (ret)
 		return ret;
 
+	ret = vmw_validation_prepare(&val_ctx, NULL, interruptible);
+	if (ret)
+		goto out_unref;
+
 	ddirty.transfer = (to_surface) ? SVGA3D_WRITE_HOST_VRAM :
 		SVGA3D_READ_HOST_VRAM;
 	ddirty.left = ddirty.top = S32_MAX;
@@ -796,9 +800,13 @@ int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
 
 	ret = vmw_kms_helper_dirty(dev_priv, vfb, clips, vclips,
 				   0, 0, num_clips, increment, &ddirty.base);
-	vmw_kms_helper_buffer_finish(dev_priv, file_priv, buf, NULL,
-				     user_fence_rep);
 
+	vmw_kms_helper_validation_finish(dev_priv, file_priv, &val_ctx, NULL,
+					 user_fence_rep);
+	return ret;
+
+out_unref:
+	vmw_validation_unref_lists(&val_ctx);
 	return ret;
 }
 
@@ -924,16 +932,20 @@ int vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,
 	struct vmw_framebuffer_surface *vfbs =
 		container_of(framebuffer, typeof(*vfbs), base);
 	struct vmw_stdu_dirty sdirty;
-	struct vmw_validation_ctx ctx;
+	DECLARE_VAL_CONTEXT(val_ctx, NULL, 0);
 	int ret;
 
 	if (!srf)
 		srf = &vfbs->surface->res;
 
-	ret = vmw_kms_helper_resource_prepare(srf, true, &ctx);
+	ret = vmw_validation_add_resource(&val_ctx, srf, 0, NULL, NULL);
 	if (ret)
 		return ret;
 
+	ret = vmw_validation_prepare(&val_ctx, &dev_priv->cmdbuf_mutex, true);
+	if (ret)
+		goto out_unref;
+
 	if (vfbs->is_bo_proxy) {
 		ret = vmw_kms_update_proxy(srf, clips, num_clips, inc);
 		if (ret)
@@ -954,8 +966,13 @@ int vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,
 				   dest_x, dest_y, num_clips, inc,
 				   &sdirty.base);
 out_finish:
-	vmw_kms_helper_resource_finish(&ctx, out_fence);
+	vmw_kms_helper_validation_finish(dev_priv, NULL, &val_ctx, out_fence,
+					 NULL);
+
+	return ret;
 
+out_unref:
+	vmw_validation_unref_lists(&val_ctx);
 	return ret;
 }
 

commit a4bd815a94b7aae27e2413f2ce7b458f9843b8ae
Author: Deepak Rawat <drawat@vmware.com>
Date:   Thu Sep 13 12:46:10 2018 +0200

    drm/vmwgfx: Don't impose STDU limits on framebuffer size
    
    If framebuffers are larger, we create bounce surfaces that are within
    STDU limits.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 93f6b96ca7bb..f30e839f7bfd 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1600,31 +1600,6 @@ int vmw_kms_stdu_init_display(struct vmw_private *dev_priv)
 
 	dev_priv->active_display_unit = vmw_du_screen_target;
 
-	if (dev_priv->capabilities & SVGA_CAP_3D) {
-		/*
-		 * For 3D VMs, display (scanout) buffer size is the smaller of
-		 * max texture and max STDU
-		 */
-		uint32_t max_width, max_height;
-
-		max_width = min(dev_priv->texture_max_width,
-				dev_priv->stdu_max_width);
-		max_height = min(dev_priv->texture_max_height,
-				 dev_priv->stdu_max_height);
-
-		dev->mode_config.max_width = max_width;
-		dev->mode_config.max_height = max_height;
-	} else {
-		/*
-		 * Given various display aspect ratios, there's no way to
-		 * estimate these using prim_bb_mem.  So just set these to
-		 * something arbitrarily large and we will reject any layout
-		 * that doesn't fit prim_bb_mem later
-		 */
-		dev->mode_config.max_width = 8192;
-		dev->mode_config.max_height = 8192;
-	}
-
 	vmw_kms_create_implicit_placement_property(dev_priv, false);
 
 	for (i = 0; i < VMWGFX_NUM_DISPLAY_UNITS; ++i) {

commit 294f96ae8aa53415272045649e3e7a1749cc0575
Merge: 090cbdd0735b 979c11ef39ce
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Jul 20 10:40:25 2018 +1000

    Merge tag 'drm-misc-next-2018-07-18' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for 4.19:
    
    Core Changes:
    - add support for DisplayPort CEC-Tunneling-over-AUX (Hans Verkuil)
    - more doc updates (Daniel Vetter)
    - fourcc: Add is_yuv field to drm_format_info (Ayan Kumar Halder)
    - dma-buf: correctly place BUG_ON (Michel Dänzer)
    
    Driver Changes:
    - more vkms support(Rodrigo Siqueira)
    - many fixes and small improments to all drivers
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180718200826.GA20165@juma

commit cde4c44d8769c1be16074c097592c46c7d64092b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jul 9 10:40:07 2018 +0200

    drm: drop _mode_ from drm_mode_connector_attach_encoder
    
    Again to align with the usual prefix of just drm_connector_. Again
    done with sed + manual fixup for indent issues.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180709084016.23750-7-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index a474d87b1af3..4cca78cab03f 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1486,7 +1486,7 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 		goto err_free_connector;
 	}
 
-	(void) drm_mode_connector_attach_encoder(connector, encoder);
+	(void) drm_connector_attach_encoder(connector, encoder);
 	encoder->possible_crtcs = (1 << unit);
 	encoder->possible_clones = 0;
 

commit b861686b18538eaaf3530255eb37b4133146fbe2
Merge: 8038d2a9e6cd 9b07b287aa3e
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Jul 10 11:13:36 2018 +1000

    Merge tag 'vmwgfx-next-4.19-3' of git://people.freedesktop.org/~thomash/linux into drm-next
    
    This introduces a header update and support for multisample surfaces.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/d020efb8-776d-5e8f-9d9f-122591e074d6@vmware.com

commit 8038d2a9e6cde825be46359ad98a084da92294fe
Merge: ba7ca97d73b4 812a954b787a
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Jul 10 11:05:46 2018 +1000

    Merge tag 'vmwgfx-next-4.19-2' of git://people.freedesktop.org/~thomash/linux into drm-next
    
    A series of cleanups / reorganizations and modesetting changes that
    mostly target atomic state validation.
    
    [airlied: conflicts with SPDX stuff in amdgpu tree]
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    Link: https://patchwork.freedesktop.org/patch/msgid/1a88485e-e509-b00e-8485-19194f074115@vmware.com

commit 14b1c33e84295693c3b1a1d7c6ac82b3f384cd17
Author: Deepak Rawat <drawat@vmware.com>
Date:   Wed Jun 20 14:48:35 2018 -0700

    drm/vmwgfx: Add new ioctl for GB surface create and reference
    
    New ioctls DRM_VMW_GB_SURFACE_CREATE_EXT and DRM_VMW_GB_SURFACE_REF_EXT
    are added which support 64-bit wide svga device surface flags, quality
    level and multisample pattern.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Brian Paul <brianp@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Charmaine Lee <charmainel@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 6630abf3a95c..f9872c9e60c4 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1188,6 +1188,8 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 				 content_srf.multisample_count,
 				 0,
 				 display_base_size,
+				 content_srf.multisample_pattern,
+				 content_srf.quality_level,
 				 &vps->surf);
 			if (ret != 0) {
 				DRM_ERROR("Couldn't allocate STDU surface.\n");

commit cdff8e73006c05ee342dd588b5ba90b5def56184
Author: Deepak Rawat <drawat@vmware.com>
Date:   Wed Jun 20 14:20:23 2018 -0700

    drm/vmwgfx: Add support for SVGA3dCmdDefineGBSurface_v3
    
    SVGA device added new command SVGA3dCmdDefineGBSurface_v3 which allows
    64-bit SVGA3dSurfaceAllFlags. This commit adds support for
    SVGA3dCmdDefineGBSurface_v3 command in vmwgfx.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Brian Paul <brianp@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Charmaine Lee <charmainel@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 15f2cb2a151b..6630abf3a95c 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1157,6 +1157,9 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 			content_srf.flags             = 0;
 			content_srf.mip_levels[0]     = 1;
 			content_srf.multisample_count = 0;
+			content_srf.multisample_pattern =
+				SVGA3D_MS_PATTERN_NONE;
+			content_srf.quality_level = SVGA3D_MS_QUALITY_NONE;
 		} else {
 			content_srf = *new_vfbs->surface;
 		}

commit 3e79ecdad8897dad4d311576989b6856dbcb958e
Author: Deepak Rawat <drawat@vmware.com>
Date:   Wed Jun 20 11:34:26 2018 +0200

    drm/vmwgfx: Add gui_x/y to vmw_connector_state
    
    As gui_x/y positioning is display unit is protected by
    requested_layout_mutex adding vmw_connector_state copy of the same and
    modeset commit will refer the state copy to sync with modeset_check
    state.
    
    v2: Tested with CONFIG_PROVE_LOCKING enabled.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 537df9034008..15f2cb2a151b 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -178,13 +178,9 @@ static int vmw_stdu_define_st(struct vmw_private *dev_priv,
 	cmd->body.height = mode->vdisplay;
 	cmd->body.flags  = (0 == cmd->body.stid) ? SVGA_STFLAG_PRIMARY : 0;
 	cmd->body.dpi    = 0;
-	if (stdu->base.is_implicit) {
-		cmd->body.xRoot  = crtc_x;
-		cmd->body.yRoot  = crtc_y;
-	} else {
-		cmd->body.xRoot  = stdu->base.gui_x;
-		cmd->body.yRoot  = stdu->base.gui_y;
-	}
+	cmd->body.xRoot  = crtc_x;
+	cmd->body.yRoot  = crtc_y;
+
 	stdu->base.set_gui_x = cmd->body.xRoot;
 	stdu->base.set_gui_y = cmd->body.yRoot;
 
@@ -374,11 +370,14 @@ static void vmw_stdu_crtc_mode_set_nofb(struct drm_crtc *crtc)
 {
 	struct vmw_private *dev_priv;
 	struct vmw_screen_target_display_unit *stdu;
-	int ret;
-
+	struct drm_connector_state *conn_state;
+	struct vmw_connector_state *vmw_conn_state;
+	int x, y, ret;
 
-	stdu     = vmw_crtc_to_stdu(crtc);
+	stdu = vmw_crtc_to_stdu(crtc);
 	dev_priv = vmw_priv(crtc->dev);
+	conn_state = stdu->base.connector.state;
+	vmw_conn_state = vmw_connector_state_to_vcs(conn_state);
 
 	if (stdu->defined) {
 		ret = vmw_stdu_bind_st(dev_priv, stdu, NULL);
@@ -397,8 +396,16 @@ static void vmw_stdu_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	if (!crtc->state->enable)
 		return;
 
+	if (stdu->base.is_implicit) {
+		x = crtc->x;
+		y = crtc->y;
+	} else {
+		x = vmw_conn_state->gui_x;
+		y = vmw_conn_state->gui_y;
+	}
+
 	vmw_svga_enable(dev_priv);
-	ret = vmw_stdu_define_st(dev_priv, stdu, &crtc->mode, crtc->x, crtc->y);
+	ret = vmw_stdu_define_st(dev_priv, stdu, &crtc->mode, x, y);
 
 	if (ret)
 		DRM_ERROR("Failed to define Screen Target of size %dx%d\n",

commit f1d34bfd70b1b4543a139ea28bad4c001c5f413d
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Tue Jun 19 15:02:16 2018 +0200

    drm/vmwgfx: Replace vmw_dma_buffer with vmw_buffer_object
    
    Initially vmware buffer objects were only used as DMA buffers, so the name
    DMA buffer was a natural one. However, currently they are used also as
    dumb buffers and MOBs backing guest backed objects so renaming them to
    buffer objects is logical. Particularly since there is a dmabuf subsystem
    in the kernel where a dma buffer means something completely different.
    
    This also renames user-space api structures and IOCTL names
    correspondingly, but the old names remain defined for now and the ABI
    hasn't changed.
    
    There are a couple of minor style changes to make checkpatch happy.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Deepak Rawat <drawat@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 152e96cb1c01..537df9034008 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -44,7 +44,7 @@
 enum stdu_content_type {
 	SAME_AS_DISPLAY = 0,
 	SEPARATE_SURFACE,
-	SEPARATE_DMA
+	SEPARATE_BO
 };
 
 /**
@@ -58,7 +58,7 @@ enum stdu_content_type {
  * @bottom: Bottom side of bounding box.
  * @fb_left: Left side of the framebuffer/content bounding box
  * @fb_top: Top of the framebuffer/content bounding box
- * @buf: DMA buffer when DMA-ing between buffer and screen targets.
+ * @buf: buffer object when DMA-ing between buffer and screen targets.
  * @sid: Surface ID when copying between surface and screen targets.
  */
 struct vmw_stdu_dirty {
@@ -68,7 +68,7 @@ struct vmw_stdu_dirty {
 	s32 fb_left, fb_top;
 	u32 pitch;
 	union {
-		struct vmw_dma_buffer *buf;
+		struct vmw_buffer_object *buf;
 		u32 sid;
 	};
 };
@@ -508,14 +508,14 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 
 
 /**
- * vmw_stdu_dmabuf_clip - Callback to encode a suface DMA command cliprect
+ * vmw_stdu_bo_clip - Callback to encode a suface DMA command cliprect
  *
  * @dirty: The closure structure.
  *
  * Encodes a surface DMA command cliprect and updates the bounding box
  * for the DMA.
  */
-static void vmw_stdu_dmabuf_clip(struct vmw_kms_dirty *dirty)
+static void vmw_stdu_bo_clip(struct vmw_kms_dirty *dirty)
 {
 	struct vmw_stdu_dirty *ddirty =
 		container_of(dirty, struct vmw_stdu_dirty, base);
@@ -543,14 +543,14 @@ static void vmw_stdu_dmabuf_clip(struct vmw_kms_dirty *dirty)
 }
 
 /**
- * vmw_stdu_dmabuf_fifo_commit - Callback to fill in and submit a DMA command.
+ * vmw_stdu_bo_fifo_commit - Callback to fill in and submit a DMA command.
  *
  * @dirty: The closure structure.
  *
  * Fills in the missing fields in a DMA command, and optionally encodes
  * a screen target update command, depending on transfer direction.
  */
-static void vmw_stdu_dmabuf_fifo_commit(struct vmw_kms_dirty *dirty)
+static void vmw_stdu_bo_fifo_commit(struct vmw_kms_dirty *dirty)
 {
 	struct vmw_stdu_dirty *ddirty =
 		container_of(dirty, struct vmw_stdu_dirty, base);
@@ -594,13 +594,13 @@ static void vmw_stdu_dmabuf_fifo_commit(struct vmw_kms_dirty *dirty)
 
 
 /**
- * vmw_stdu_dmabuf_cpu_clip - Callback to encode a CPU blit
+ * vmw_stdu_bo_cpu_clip - Callback to encode a CPU blit
  *
  * @dirty: The closure structure.
  *
  * This function calculates the bounding box for all the incoming clips.
  */
-static void vmw_stdu_dmabuf_cpu_clip(struct vmw_kms_dirty *dirty)
+static void vmw_stdu_bo_cpu_clip(struct vmw_kms_dirty *dirty)
 {
 	struct vmw_stdu_dirty *ddirty =
 		container_of(dirty, struct vmw_stdu_dirty, base);
@@ -624,14 +624,14 @@ static void vmw_stdu_dmabuf_cpu_clip(struct vmw_kms_dirty *dirty)
 
 
 /**
- * vmw_stdu_dmabuf_cpu_commit - Callback to do a CPU blit from DMAbuf
+ * vmw_stdu_bo_cpu_commit - Callback to do a CPU blit from buffer object
  *
  * @dirty: The closure structure.
  *
  * For the special case when we cannot create a proxy surface in a
  * 2D VM, we have to do a CPU blit ourselves.
  */
-static void vmw_stdu_dmabuf_cpu_commit(struct vmw_kms_dirty *dirty)
+static void vmw_stdu_bo_cpu_commit(struct vmw_kms_dirty *dirty)
 {
 	struct vmw_stdu_dirty *ddirty =
 		container_of(dirty, struct vmw_stdu_dirty, base);
@@ -652,7 +652,7 @@ static void vmw_stdu_dmabuf_cpu_commit(struct vmw_kms_dirty *dirty)
 	if (width == 0 || height == 0)
 		return;
 
-	/* Assume we are blitting from Guest (dmabuf) to Host (display_srf) */
+	/* Assume we are blitting from Guest (bo) to Host (display_srf) */
 	dst_pitch = stdu->display_srf->base_size.width * stdu->cpp;
 	dst_bo = &stdu->display_srf->res.backup->base;
 	dst_offset = ddirty->top * dst_pitch + ddirty->left * stdu->cpp;
@@ -712,13 +712,13 @@ static void vmw_stdu_dmabuf_cpu_commit(struct vmw_kms_dirty *dirty)
 }
 
 /**
- * vmw_kms_stdu_dma - Perform a DMA transfer between a dma-buffer backed
+ * vmw_kms_stdu_dma - Perform a DMA transfer between a buffer-object backed
  * framebuffer and the screen target system.
  *
  * @dev_priv: Pointer to the device private structure.
  * @file_priv: Pointer to a struct drm-file identifying the caller. May be
  * set to NULL, but then @user_fence_rep must also be set to NULL.
- * @vfb: Pointer to the dma-buffer backed framebuffer.
+ * @vfb: Pointer to the buffer-object backed framebuffer.
  * @clips: Array of clip rects. Either @clips or @vclips must be NULL.
  * @vclips: Alternate array of clip rects. Either @clips or @vclips must
  * be NULL.
@@ -747,8 +747,8 @@ int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
 		     bool interruptible,
 		     struct drm_crtc *crtc)
 {
-	struct vmw_dma_buffer *buf =
-		container_of(vfb, struct vmw_framebuffer_dmabuf, base)->buffer;
+	struct vmw_buffer_object *buf =
+		container_of(vfb, struct vmw_framebuffer_bo, base)->buffer;
 	struct vmw_stdu_dirty ddirty;
 	int ret;
 	bool cpu_blit = !(dev_priv->capabilities & SVGA_CAP_3D);
@@ -770,8 +770,8 @@ int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
 	ddirty.fb_left = ddirty.fb_top = S32_MAX;
 	ddirty.pitch = vfb->base.pitches[0];
 	ddirty.buf = buf;
-	ddirty.base.fifo_commit = vmw_stdu_dmabuf_fifo_commit;
-	ddirty.base.clip = vmw_stdu_dmabuf_clip;
+	ddirty.base.fifo_commit = vmw_stdu_bo_fifo_commit;
+	ddirty.base.clip = vmw_stdu_bo_clip;
 	ddirty.base.fifo_reserve_size = sizeof(struct vmw_stdu_dma) +
 		num_clips * sizeof(SVGA3dCopyBox) +
 		sizeof(SVGA3dCmdSurfaceDMASuffix);
@@ -780,8 +780,8 @@ int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
 
 
 	if (cpu_blit) {
-		ddirty.base.fifo_commit = vmw_stdu_dmabuf_cpu_commit;
-		ddirty.base.clip = vmw_stdu_dmabuf_cpu_clip;
+		ddirty.base.fifo_commit = vmw_stdu_bo_cpu_commit;
+		ddirty.base.clip = vmw_stdu_bo_cpu_clip;
 		ddirty.base.fifo_reserve_size = 0;
 	}
 
@@ -927,7 +927,7 @@ int vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,
 	if (ret)
 		return ret;
 
-	if (vfbs->is_dmabuf_proxy) {
+	if (vfbs->is_bo_proxy) {
 		ret = vmw_kms_update_proxy(srf, clips, num_clips, inc);
 		if (ret)
 			goto out_finish;
@@ -1075,7 +1075,7 @@ vmw_stdu_primary_plane_cleanup_fb(struct drm_plane *plane,
  * @new_state: info on the new plane state, including the FB
  *
  * This function allocates a new display surface if the content is
- * backed by a DMA.  The display surface is pinned here, and it'll
+ * backed by a buffer object.  The display surface is pinned here, and it'll
  * be unpinned in .cleanup_fb()
  *
  * Returns 0 on success
@@ -1105,13 +1105,13 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 	}
 
 	vfb = vmw_framebuffer_to_vfb(new_fb);
-	new_vfbs = (vfb->dmabuf) ? NULL : vmw_framebuffer_to_vfbs(new_fb);
+	new_vfbs = (vfb->bo) ? NULL : vmw_framebuffer_to_vfbs(new_fb);
 
 	if (new_vfbs && new_vfbs->surface->base_size.width == hdisplay &&
 	    new_vfbs->surface->base_size.height == vdisplay)
 		new_content_type = SAME_AS_DISPLAY;
-	else if (vfb->dmabuf)
-		new_content_type = SEPARATE_DMA;
+	else if (vfb->bo)
+		new_content_type = SEPARATE_BO;
 	else
 		new_content_type = SEPARATE_SURFACE;
 
@@ -1124,10 +1124,10 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 		display_base_size.depth  = 1;
 
 		/*
-		 * If content buffer is a DMA buf, then we have to construct
-		 * surface info
+		 * If content buffer is a buffer object, then we have to
+		 * construct surface info
 		 */
-		if (new_content_type == SEPARATE_DMA) {
+		if (new_content_type == SEPARATE_BO) {
 
 			switch (new_fb->format->cpp[0]*8) {
 			case 32:
@@ -1212,12 +1212,12 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 	vps->content_fb_type = new_content_type;
 
 	/*
-	 * This should only happen if the DMA buf is too large to create a
+	 * This should only happen if the buffer object is too large to create a
 	 * proxy surface for.
-	 * If we are a 2D VM with a DMA buffer then we have to use CPU blit
+	 * If we are a 2D VM with a buffer object then we have to use CPU blit
 	 * so cache these mappings
 	 */
-	if (vps->content_fb_type == SEPARATE_DMA &&
+	if (vps->content_fb_type == SEPARATE_BO &&
 	    !(dev_priv->capabilities & SVGA_CAP_3D))
 		vps->cpp = new_fb->pitches[0] / new_fb->width;
 
@@ -1276,7 +1276,7 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 		if (ret)
 			DRM_ERROR("Failed to bind surface to STDU.\n");
 
-		if (vfb->dmabuf)
+		if (vfb->bo)
 			ret = vmw_kms_stdu_dma(dev_priv, NULL, vfb, NULL, NULL,
 					       &vclips, 1, 1, true, false,
 					       crtc);

commit dff96888860a9ebaa618be973b51f4d86aec1211
Author: Dirk Hohndel (VMware) <dirk@hohndel.org>
Date:   Mon May 7 01:16:26 2018 +0200

    drm/vmwgfx: add SPDX idenitifier and clarify license
    
    This is dual licensed under GPL-2.0 or MIT.
    vmwgfx_msg.h is the odd one out that is GPL-2.0+ or MIT.
    
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Dirk Hohndel (VMware) <dirk@hohndel.org>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180506231626.115996-9-dirk@hohndel.org

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 152e96cb1c01..a474d87b1af3 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1,7 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0 OR MIT
 /******************************************************************************
  *
- * COPYRIGHT © 2014-2015 VMware, Inc., Palo Alto, CA., USA
- * All Rights Reserved.
+ * COPYRIGHT (C) 2014-2015 VMware, Inc., Palo Alto, CA., USA
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the

commit 0d45d79de22feb4f32de08249e93d878fa6fdab8
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri May 25 21:50:37 2018 +0300

    drm/vmwgfx: Stop using plane->fb in atomic_enable()
    
    Instead of looking at the (soon to be deprecated) plane->fb we'll
    examing plane->state->fb instead. We can do this because
    vmw_du_crtc_atomic_check() prevents us from enabling a crtc
    without the primary plane also being enabled.
    
    Due to that same reason, I'm actually not sure what the checks here are
    for NULL fb. If we can't enable the crtc without an enabled plane
    we should always have an fb. But I'll leave that for someone else
    to figure out.
    
    Cc: Deepak Rawat <drawat@vmware.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Sinclair Yeh <syeh@vmware.com>
    Cc: VMware Graphics <linux-graphics-maintainer@vmware.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Deepak Rawat <drawat@vmware.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180525185045.29689-6-ville.syrjala@linux.intel.com
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 90445bc590cb..152e96cb1c01 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -414,6 +414,7 @@ static void vmw_stdu_crtc_helper_prepare(struct drm_crtc *crtc)
 static void vmw_stdu_crtc_atomic_enable(struct drm_crtc *crtc,
 					struct drm_crtc_state *old_state)
 {
+	struct drm_plane_state *plane_state = crtc->primary->state;
 	struct vmw_private *dev_priv;
 	struct vmw_screen_target_display_unit *stdu;
 	struct vmw_framebuffer *vfb;
@@ -422,7 +423,7 @@ static void vmw_stdu_crtc_atomic_enable(struct drm_crtc *crtc,
 
 	stdu     = vmw_crtc_to_stdu(crtc);
 	dev_priv = vmw_priv(crtc->dev);
-	fb       = crtc->primary->fb;
+	fb       = plane_state->fb;
 
 	vfb = (fb) ? vmw_framebuffer_to_vfb(fb) : NULL;
 

commit e1cd4f8e45937ce7bbf2613de2c9503d3cda6c12
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri May 25 21:50:36 2018 +0300

    drm/vmwgfx: Stop updating plane->fb
    
    We want to get rid of plane->fb on atomic drivers. Stop setting it.
    
    Cc: Deepak Rawat <drawat@vmware.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Sinclair Yeh <syeh@vmware.com>
    Cc: VMware Graphics <linux-graphics-maintainer@vmware.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Deepak Rawat <drawat@vmware.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180525185045.29689-5-ville.syrjala@linux.intel.com
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 67331f01ef32..90445bc590cb 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1285,8 +1285,6 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 							 1, 1, NULL, crtc);
 		if (ret)
 			DRM_ERROR("Failed to update STDU.\n");
-
-		crtc->primary->fb = plane->state->fb;
 	} else {
 		crtc = old_state->crtc;
 		stdu = vmw_crtc_to_stdu(crtc);

commit 2b4f44eec2be2688511c2b617d0e1b4f94c45ba4
Merge: 33d009cd8894 3eb2ce825ea1
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Mar 28 14:30:41 2018 +1000

    Backmerge tag 'v4.16-rc7' into drm-next
    
    Linux 4.16-rc7
    
    This was requested by Daniel, and things were getting
    a bit hard to reconcile, most of the conflicts were
    trivial though.

commit ef86cfee7d74baf2e3b883871087a684acecb595
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Tue Jan 16 11:07:30 2018 +0100

    drm/vmwgfx: Use the cpu blit utility for framebuffer to screen target blits
    
    This blit was previously performed using two large vmaps, one of which
    was teared down and remapped on each blit. Use the more resource-
    conserving TTM cpu blit instead.
    
    The blit is used in boundary-box computing mode which makes it possible
    to minimize the bounding box used in host operations.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Brian Paul <brianp@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 6de28746f6f7..8eec88920851 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -114,7 +114,6 @@ struct vmw_screen_target_display_unit {
 	bool defined;
 
 	/* For CPU Blit */
-	struct ttm_bo_kmap_obj host_map;
 	unsigned int cpp;
 };
 
@@ -639,10 +638,9 @@ static void vmw_stdu_dmabuf_cpu_commit(struct vmw_kms_dirty *dirty)
 		container_of(dirty->unit, typeof(*stdu), base);
 	s32 width, height;
 	s32 src_pitch, dst_pitch;
-	u8 *src, *dst;
-	bool not_used;
-	struct ttm_bo_kmap_obj guest_map;
-	int ret;
+	struct ttm_buffer_object *src_bo, *dst_bo;
+	u32 src_offset, dst_offset;
+	struct vmw_diff_cpy diff = VMW_CPU_BLIT_DIFF_INITIALIZER(stdu->cpp);
 
 	if (!dirty->num_hits)
 		return;
@@ -653,57 +651,38 @@ static void vmw_stdu_dmabuf_cpu_commit(struct vmw_kms_dirty *dirty)
 	if (width == 0 || height == 0)
 		return;
 
-	ret = ttm_bo_kmap(&ddirty->buf->base, 0, ddirty->buf->base.num_pages,
-			  &guest_map);
-	if (ret) {
-		DRM_ERROR("Failed mapping framebuffer for blit: %d\n",
-			  ret);
-		goto out_cleanup;
-	}
-
-	/* Assume we are blitting from Host (display_srf) to Guest (dmabuf) */
-	src_pitch = stdu->display_srf->base_size.width * stdu->cpp;
-	src = ttm_kmap_obj_virtual(&stdu->host_map, &not_used);
-	src += ddirty->top * src_pitch + ddirty->left * stdu->cpp;
-
-	dst_pitch = ddirty->pitch;
-	dst = ttm_kmap_obj_virtual(&guest_map, &not_used);
-	dst += ddirty->fb_top * dst_pitch + ddirty->fb_left * stdu->cpp;
+	/* Assume we are blitting from Guest (dmabuf) to Host (display_srf) */
+	dst_pitch = stdu->display_srf->base_size.width * stdu->cpp;
+	dst_bo = &stdu->display_srf->res.backup->base;
+	dst_offset = ddirty->top * dst_pitch + ddirty->left * stdu->cpp;
 
+	src_pitch = ddirty->pitch;
+	src_bo = &ddirty->buf->base;
+	src_offset = ddirty->fb_top * src_pitch + ddirty->fb_left * stdu->cpp;
 
-	/* Figure out the real direction */
-	if (ddirty->transfer == SVGA3D_WRITE_HOST_VRAM) {
-		u8 *tmp;
-		s32 tmp_pitch;
-
-		tmp = src;
-		tmp_pitch = src_pitch;
-
-		src = dst;
-		src_pitch = dst_pitch;
-
-		dst = tmp;
-		dst_pitch = tmp_pitch;
+	/* Swap src and dst if the assumption was wrong. */
+	if (ddirty->transfer != SVGA3D_WRITE_HOST_VRAM) {
+		swap(dst_pitch, src_pitch);
+		swap(dst_bo, src_bo);
+		swap(src_offset, dst_offset);
 	}
 
-	/* CPU Blit */
-	while (height-- > 0) {
-		memcpy(dst, src, width * stdu->cpp);
-		dst += dst_pitch;
-		src += src_pitch;
-	}
+	(void) vmw_bo_cpu_blit(dst_bo, dst_offset, dst_pitch,
+			       src_bo, src_offset, src_pitch,
+			       width * stdu->cpp, height, &diff);
 
-	if (ddirty->transfer == SVGA3D_WRITE_HOST_VRAM) {
+	if (ddirty->transfer == SVGA3D_WRITE_HOST_VRAM &&
+	    drm_rect_visible(&diff.rect)) {
 		struct vmw_private *dev_priv;
 		struct vmw_stdu_update *cmd;
 		struct drm_clip_rect region;
 		int ret;
 
 		/* We are updating the actual surface, not a proxy */
-		region.x1 = ddirty->left;
-		region.x2 = ddirty->right;
-		region.y1 = ddirty->top;
-		region.y2 = ddirty->bottom;
+		region.x1 = diff.rect.x1;
+		region.x2 = diff.rect.x2;
+		region.y1 = diff.rect.y1;
+		region.y2 = diff.rect.y2;
 		ret = vmw_kms_update_proxy(
 			(struct vmw_resource *) &stdu->display_srf->res,
 			(const struct drm_clip_rect *) &region, 1, 1);
@@ -720,13 +699,12 @@ static void vmw_stdu_dmabuf_cpu_commit(struct vmw_kms_dirty *dirty)
 		}
 
 		vmw_stdu_populate_update(cmd, stdu->base.unit,
-					 ddirty->left, ddirty->right,
-					 ddirty->top, ddirty->bottom);
+					 region.x1, region.x2,
+					 region.y1, region.y2);
 
 		vmw_fifo_commit(dev_priv, sizeof(*cmd));
 	}
 
-	ttm_bo_kunmap(&guest_map);
 out_cleanup:
 	ddirty->left = ddirty->top = ddirty->fb_left = ddirty->fb_top = S32_MAX;
 	ddirty->right = ddirty->bottom = S32_MIN;
@@ -772,9 +750,15 @@ int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
 		container_of(vfb, struct vmw_framebuffer_dmabuf, base)->buffer;
 	struct vmw_stdu_dirty ddirty;
 	int ret;
+	bool cpu_blit = !(dev_priv->capabilities & SVGA_CAP_3D);
 
+	/*
+	 * VMs without 3D support don't have the surface DMA command and
+	 * we'll be using a CPU blit, and the framebuffer should be moved out
+	 * of VRAM.
+	 */
 	ret = vmw_kms_helper_buffer_prepare(dev_priv, buf, interruptible,
-					    false);
+					    false, cpu_blit);
 	if (ret)
 		return ret;
 
@@ -793,8 +777,8 @@ int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
 	if (to_surface)
 		ddirty.base.fifo_reserve_size += sizeof(struct vmw_stdu_update);
 
-	/* 2D VMs cannot use SVGA_3D_CMD_SURFACE_DMA so do CPU blit instead */
-	if (!(dev_priv->capabilities & SVGA_CAP_3D)) {
+
+	if (cpu_blit) {
 		ddirty.base.fifo_commit = vmw_stdu_dmabuf_cpu_commit;
 		ddirty.base.clip = vmw_stdu_dmabuf_cpu_clip;
 		ddirty.base.fifo_reserve_size = 0;
@@ -1071,9 +1055,6 @@ vmw_stdu_primary_plane_cleanup_fb(struct drm_plane *plane,
 {
 	struct vmw_plane_state *vps = vmw_plane_state_to_vps(old_state);
 
-	if (vps->host_map.virtual)
-		ttm_bo_kunmap(&vps->host_map);
-
 	if (vps->surf)
 		WARN_ON(!vps->pinned);
 
@@ -1235,24 +1216,11 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 	 * so cache these mappings
 	 */
 	if (vps->content_fb_type == SEPARATE_DMA &&
-	    !(dev_priv->capabilities & SVGA_CAP_3D)) {
-		ret = ttm_bo_kmap(&vps->surf->res.backup->base, 0,
-				  vps->surf->res.backup->base.num_pages,
-				  &vps->host_map);
-		if (ret) {
-			DRM_ERROR("Failed to map display buffer to CPU\n");
-			goto out_srf_unpin;
-		}
-
+	    !(dev_priv->capabilities & SVGA_CAP_3D))
 		vps->cpp = new_fb->pitches[0] / new_fb->width;
-	}
 
 	return 0;
 
-out_srf_unpin:
-	vmw_resource_unpin(&vps->surf->res);
-	vps->pinned--;
-
 out_srf_unref:
 	vmw_surface_unreference(&vps->surf);
 	return ret;
@@ -1296,7 +1264,6 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 		stdu->display_srf = vps->surf;
 		stdu->content_fb_type = vps->content_fb_type;
 		stdu->cpp = vps->cpp;
-		memcpy(&stdu->host_map, &vps->host_map, sizeof(vps->host_map));
 
 		vclips.x = crtc->x;
 		vclips.y = crtc->y;

commit ac3069e67f5659131d7ac5f54d966005bbc40af8
Author: Deepak Rawat <drawat@vmware.com>
Date:   Tue Jan 16 08:44:42 2018 +0100

    drm/vmwgfx: Move the stdu vblank event to atomic function
    
    Atomic ioctl can also send the same page flip flags as legacy ioctl.
    In those cases also need to send the vblank event to userspace.
    
    vmwgfx does not support flag DRM_MODE_PAGE_FLIP_ASYNC, so this flag is
    never expected.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index dfbcd41303ad..6de28746f6f7 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -494,47 +494,15 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 	struct vmw_screen_target_display_unit *stdu = vmw_crtc_to_stdu(crtc);
 	int ret;
 
-	dev_priv          = vmw_priv(crtc->dev);
-	stdu              = vmw_crtc_to_stdu(crtc);
-
 	if (!stdu->defined || !vmw_kms_crtc_flippable(dev_priv, crtc))
 		return -EINVAL;
 
-	/*
-	 * We're always async, but the helper doesn't know how to set async
-	 * so lie to the helper. Also, the helper expects someone
-	 * to pick the event up from the crtc state, and if nobody does,
-	 * it will free it. Since we handle the event in this function,
-	 * don't hand it to the helper.
-	 */
-	flags &= ~DRM_MODE_PAGE_FLIP_ASYNC;
-	ret = drm_atomic_helper_page_flip(crtc, new_fb, NULL, flags, ctx);
+	ret = drm_atomic_helper_page_flip(crtc, new_fb, event, flags, ctx);
 	if (ret) {
 		DRM_ERROR("Page flip error %d.\n", ret);
 		return ret;
 	}
 
-	if (stdu->base.is_implicit)
-		vmw_kms_update_implicit_fb(dev_priv, crtc);
-
-	if (event) {
-		struct vmw_fence_obj *fence = NULL;
-		struct drm_file *file_priv = event->base.file_priv;
-
-		vmw_execbuf_fence_commands(NULL, dev_priv, &fence, NULL);
-		if (!fence)
-			return -ENOMEM;
-
-		ret = vmw_event_fence_action_queue(file_priv, fence,
-						   &event->base,
-						   &event->event.vbl.tv_sec,
-						   &event->event.vbl.tv_usec,
-						   true);
-		vmw_fence_obj_unreference(&fence);
-	} else {
-		(void) vmw_fifo_flush(dev_priv, false);
-	}
-
 	return 0;
 }
 
@@ -1307,47 +1275,38 @@ static void
 vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 				     struct drm_plane_state *old_state)
 {
-	struct vmw_private *dev_priv;
-	struct vmw_screen_target_display_unit *stdu;
 	struct vmw_plane_state *vps = vmw_plane_state_to_vps(plane->state);
-	struct drm_crtc *crtc = plane->state->crtc ?: old_state->crtc;
-	struct vmw_framebuffer *vfb = NULL;
+	struct drm_crtc *crtc = plane->state->crtc;
+	struct vmw_screen_target_display_unit *stdu;
+	struct drm_pending_vblank_event *event;
+	struct vmw_private *dev_priv;
 	int ret;
 
-	stdu     = vmw_crtc_to_stdu(crtc);
-	dev_priv = vmw_priv(crtc->dev);
-
-	stdu->display_srf = vps->surf;
-	stdu->content_fb_type = vps->content_fb_type;
-	stdu->cpp = vps->cpp;
-	memcpy(&stdu->host_map, &vps->host_map, sizeof(vps->host_map));
-
-	if (!stdu->defined)
-		return;
-
-	if (plane->state->fb) {
-		vfb = vmw_framebuffer_to_vfb(plane->state->fb);
-		ret = vmw_stdu_bind_st(dev_priv, stdu, &stdu->display_srf->res);
-	} else
-		ret = vmw_stdu_bind_st(dev_priv, stdu, NULL);
-
 	/*
 	 * We cannot really fail this function, so if we do, then output an
-	 * error and quit
+	 * error and maintain consistent atomic state.
 	 */
-	if (ret)
-		DRM_ERROR("Failed to bind surface to STDU.\n");
-	else
-		crtc->primary->fb = plane->state->fb;
-
-	if (vfb) {
+	if (crtc && plane->state->fb) {
+		struct vmw_framebuffer *vfb =
+			vmw_framebuffer_to_vfb(plane->state->fb);
 		struct drm_vmw_rect vclips;
+		stdu = vmw_crtc_to_stdu(crtc);
+		dev_priv = vmw_priv(crtc->dev);
+
+		stdu->display_srf = vps->surf;
+		stdu->content_fb_type = vps->content_fb_type;
+		stdu->cpp = vps->cpp;
+		memcpy(&stdu->host_map, &vps->host_map, sizeof(vps->host_map));
 
 		vclips.x = crtc->x;
 		vclips.y = crtc->y;
 		vclips.w = crtc->mode.hdisplay;
 		vclips.h = crtc->mode.vdisplay;
 
+		ret = vmw_stdu_bind_st(dev_priv, stdu, &stdu->display_srf->res);
+		if (ret)
+			DRM_ERROR("Failed to bind surface to STDU.\n");
+
 		if (vfb->dmabuf)
 			ret = vmw_kms_stdu_dma(dev_priv, NULL, vfb, NULL, NULL,
 					       &vclips, 1, 1, true, false,
@@ -1356,11 +1315,65 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 			ret = vmw_kms_stdu_surface_dirty(dev_priv, vfb, NULL,
 							 &vclips, NULL, 0, 0,
 							 1, 1, NULL, crtc);
-	} else
+		if (ret)
+			DRM_ERROR("Failed to update STDU.\n");
+
+		crtc->primary->fb = plane->state->fb;
+	} else {
+		crtc = old_state->crtc;
+		stdu = vmw_crtc_to_stdu(crtc);
+		dev_priv = vmw_priv(crtc->dev);
+
+		/*
+		 * When disabling a plane, CRTC and FB should always be NULL
+		 * together, otherwise it's an error.
+		 * Here primary plane is being disable so blank the screen
+		 * target display unit, if not already done.
+		 */
+		if (!stdu->defined)
+			return;
+
+		ret = vmw_stdu_bind_st(dev_priv, stdu, NULL);
+		if (ret)
+			DRM_ERROR("Failed to blank STDU\n");
+
 		ret = vmw_stdu_update_st(dev_priv, stdu);
+		if (ret)
+			DRM_ERROR("Failed to update STDU.\n");
 
-	if (ret)
-		DRM_ERROR("Failed to update STDU.\n");
+		return;
+	}
+
+	event = crtc->state->event;
+	/*
+	 * In case of failure and other cases, vblank event will be sent in
+	 * vmw_du_crtc_atomic_flush.
+	 */
+	if (event && (ret == 0)) {
+		struct vmw_fence_obj *fence = NULL;
+		struct drm_file *file_priv = event->base.file_priv;
+
+		vmw_execbuf_fence_commands(NULL, dev_priv, &fence, NULL);
+
+		/*
+		 * If fence is NULL, then already sync.
+		 */
+		if (fence) {
+			ret = vmw_event_fence_action_queue(
+				file_priv, fence, &event->base,
+				&event->event.vbl.tv_sec,
+				&event->event.vbl.tv_usec,
+				true);
+			if (ret)
+				DRM_ERROR("Failed to queue event on fence.\n");
+			else
+				crtc->state->event = NULL;
+
+			vmw_fence_obj_unreference(&fence);
+		}
+	} else {
+		(void) vmw_fifo_flush(dev_priv, false);
+	}
 }
 
 

commit 4e2f9fa7ffb5324adfc62fa3da6e1e36827fd5ad
Author: Deepak Rawat <drawat@vmware.com>
Date:   Tue Jan 16 08:25:55 2018 +0100

    drm/vmwgfx: Move surface copy cmd to atomic function
    
    When display surface is different than the framebuffer surface, atomic
    path do not copy the surface data. This commit moved the code to copy
    surface from legacy to atomic path.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index c22bf80d4ddd..dfbcd41303ad 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -492,8 +492,6 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 {
 	struct vmw_private *dev_priv = vmw_priv(crtc->dev);
 	struct vmw_screen_target_display_unit *stdu = vmw_crtc_to_stdu(crtc);
-	struct vmw_framebuffer *vfb = vmw_framebuffer_to_vfb(new_fb);
-	struct drm_vmw_rect vclips;
 	int ret;
 
 	dev_priv          = vmw_priv(crtc->dev);
@@ -519,26 +517,6 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 	if (stdu->base.is_implicit)
 		vmw_kms_update_implicit_fb(dev_priv, crtc);
 
-	/*
-	 * Now that we've bound a new surface to the screen target,
-	 * update the contents.
-	 */
-	vclips.x = crtc->x;
-	vclips.y = crtc->y;
-	vclips.w = crtc->mode.hdisplay;
-	vclips.h = crtc->mode.vdisplay;
-
-	if (vfb->dmabuf)
-		ret = vmw_kms_stdu_dma(dev_priv, NULL, vfb, NULL, NULL, &vclips,
-				       1, 1, true, false, crtc);
-	else
-		ret = vmw_kms_stdu_surface_dirty(dev_priv, vfb, NULL, &vclips,
-						 NULL, 0, 0, 1, 1, NULL, crtc);
-	if (ret) {
-		DRM_ERROR("Page flip update error %d.\n", ret);
-		return ret;
-	}
-
 	if (event) {
 		struct vmw_fence_obj *fence = NULL;
 		struct drm_file *file_priv = event->base.file_priv;
@@ -1333,6 +1311,7 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 	struct vmw_screen_target_display_unit *stdu;
 	struct vmw_plane_state *vps = vmw_plane_state_to_vps(plane->state);
 	struct drm_crtc *crtc = plane->state->crtc ?: old_state->crtc;
+	struct vmw_framebuffer *vfb = NULL;
 	int ret;
 
 	stdu     = vmw_crtc_to_stdu(crtc);
@@ -1346,9 +1325,10 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 	if (!stdu->defined)
 		return;
 
-	if (plane->state->fb)
+	if (plane->state->fb) {
+		vfb = vmw_framebuffer_to_vfb(plane->state->fb);
 		ret = vmw_stdu_bind_st(dev_priv, stdu, &stdu->display_srf->res);
-	else
+	} else
 		ret = vmw_stdu_bind_st(dev_priv, stdu, NULL);
 
 	/*
@@ -1360,7 +1340,24 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 	else
 		crtc->primary->fb = plane->state->fb;
 
-	ret = vmw_stdu_update_st(dev_priv, stdu);
+	if (vfb) {
+		struct drm_vmw_rect vclips;
+
+		vclips.x = crtc->x;
+		vclips.y = crtc->y;
+		vclips.w = crtc->mode.hdisplay;
+		vclips.h = crtc->mode.vdisplay;
+
+		if (vfb->dmabuf)
+			ret = vmw_kms_stdu_dma(dev_priv, NULL, vfb, NULL, NULL,
+					       &vclips, 1, 1, true, false,
+					       crtc);
+		else
+			ret = vmw_kms_stdu_surface_dirty(dev_priv, vfb, NULL,
+							 &vclips, NULL, 0, 0,
+							 1, 1, NULL, crtc);
+	} else
+		ret = vmw_stdu_update_st(dev_priv, stdu);
 
 	if (ret)
 		DRM_ERROR("Failed to update STDU.\n");

commit 91e9f352cd1b79772b4883fd31e04655d4a97318
Author: Deepak Rawat <drawat@vmware.com>
Date:   Tue Jan 16 08:24:17 2018 +0100

    drm/vmwgfx: Avoid iterating over display unit if crtc is available
    
    In case of page flip there is no need to iterate over all display unit
    in the function "vmw_kms_helper_dirty". If crtc is available then
    dirty commands is performed on that crtc only.
    
    Signed-off-by: Deepak Rawat <drawat@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index b68d74888ab1..c22bf80d4ddd 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -530,10 +530,10 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 
 	if (vfb->dmabuf)
 		ret = vmw_kms_stdu_dma(dev_priv, NULL, vfb, NULL, NULL, &vclips,
-				       1, 1, true, false);
+				       1, 1, true, false, crtc);
 	else
 		ret = vmw_kms_stdu_surface_dirty(dev_priv, vfb, NULL, &vclips,
-						 NULL, 0, 0, 1, 1, NULL);
+						 NULL, 0, 0, 1, 1, NULL, crtc);
 	if (ret) {
 		DRM_ERROR("Page flip update error %d.\n", ret);
 		return ret;
@@ -802,6 +802,7 @@ static void vmw_stdu_dmabuf_cpu_commit(struct vmw_kms_dirty *dirty)
  * @to_surface: Whether to DMA to the screen target system as opposed to
  * from the screen target system.
  * @interruptible: Whether to perform waits interruptible if possible.
+ * @crtc: If crtc is passed, perform stdu dma on that crtc only.
  *
  * If DMA-ing till the screen target system, the function will also notify
  * the screen target system that a bounding box of the cliprects has been
@@ -818,7 +819,8 @@ int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
 		     uint32_t num_clips,
 		     int increment,
 		     bool to_surface,
-		     bool interruptible)
+		     bool interruptible,
+		     struct drm_crtc *crtc)
 {
 	struct vmw_dma_buffer *buf =
 		container_of(vfb, struct vmw_framebuffer_dmabuf, base)->buffer;
@@ -852,6 +854,8 @@ int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
 		ddirty.base.fifo_reserve_size = 0;
 	}
 
+	ddirty.base.crtc = crtc;
+
 	ret = vmw_kms_helper_dirty(dev_priv, vfb, clips, vclips,
 				   0, 0, num_clips, increment, &ddirty.base);
 	vmw_kms_helper_buffer_finish(dev_priv, file_priv, buf, NULL,
@@ -963,6 +967,7 @@ static void vmw_kms_stdu_surface_fifo_commit(struct vmw_kms_dirty *dirty)
  * @out_fence: If non-NULL, will return a ref-counted pointer to a
  * struct vmw_fence_obj. The returned fence pointer may be NULL in which
  * case the device has already synchronized.
+ * @crtc: If crtc is passed, perform surface dirty on that crtc only.
  *
  * Returns 0 on success, negative error code on failure. -ERESTARTSYS if
  * interrupted.
@@ -975,7 +980,8 @@ int vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,
 			       s32 dest_x,
 			       s32 dest_y,
 			       unsigned num_clips, int inc,
-			       struct vmw_fence_obj **out_fence)
+			       struct vmw_fence_obj **out_fence,
+			       struct drm_crtc *crtc)
 {
 	struct vmw_framebuffer_surface *vfbs =
 		container_of(framebuffer, typeof(*vfbs), base);
@@ -1000,6 +1006,7 @@ int vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,
 	sdirty.base.fifo_reserve_size = sizeof(struct vmw_stdu_surface_copy) +
 		sizeof(SVGA3dCopyBox) * num_clips +
 		sizeof(struct vmw_stdu_update);
+	sdirty.base.crtc = crtc;
 	sdirty.sid = srf->id;
 	sdirty.left = sdirty.top = S32_MAX;
 	sdirty.right = sdirty.bottom = S32_MIN;

commit 73a88250b70954a8f27c2444e1c2411bba3c29d9
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Wed Mar 21 10:18:38 2018 +0100

    drm/vmwgfx: Fix a destoy-while-held mutex problem.
    
    When validating legacy surfaces, the backup bo might be destroyed at
    surface validate time. However, the kms resource validation code may have
    the bo reserved, so we will destroy a locked mutex. While there shouldn't
    be any other users of that mutex when it is destroyed, it causes a lock
    leak and thus throws a lockdep error.
    
    Fix this by having the kms resource validation code hold a reference to
    the bo while we have it reserved. We do this by introducing a validation
    context which might come in handy when the kms code is extended to validate
    multiple resources or buffers.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Brian Paul <brianp@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index b68d74888ab1..6b969e5dea2a 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -980,12 +980,13 @@ int vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,
 	struct vmw_framebuffer_surface *vfbs =
 		container_of(framebuffer, typeof(*vfbs), base);
 	struct vmw_stdu_dirty sdirty;
+	struct vmw_validation_ctx ctx;
 	int ret;
 
 	if (!srf)
 		srf = &vfbs->surface->res;
 
-	ret = vmw_kms_helper_resource_prepare(srf, true);
+	ret = vmw_kms_helper_resource_prepare(srf, true, &ctx);
 	if (ret)
 		return ret;
 
@@ -1008,7 +1009,7 @@ int vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,
 				   dest_x, dest_y, num_clips, inc,
 				   &sdirty.base);
 out_finish:
-	vmw_kms_helper_resource_finish(srf, out_fence);
+	vmw_kms_helper_resource_finish(&ctx, out_fence);
 
 	return ret;
 }

commit 98648ae6ef6bdcdcb88c46cad963906ab452e96d
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Tue Jan 9 15:33:42 2018 +0100

    drm/vmwgfx: Don't cache framebuffer maps
    
    Buffer objects need to be either pinned or reserved while a map is active,
    that's not the case here, so avoid caching the framebuffer map.
    This will cause increasing mapping activity mainly when we don't do
    page flipping.
    
    This fixes occasional garbage filled screens when the framebuffer has been
    evicted after the map.
    
    Since in-kernel mapping of whole buffer objects is error-prone on 32-bit
    architectures and also quite inefficient, we will revisit this later.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Cc: <stable@vger.kernel.org>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 90b5437fd787..b68d74888ab1 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -114,7 +114,7 @@ struct vmw_screen_target_display_unit {
 	bool defined;
 
 	/* For CPU Blit */
-	struct ttm_bo_kmap_obj host_map, guest_map;
+	struct ttm_bo_kmap_obj host_map;
 	unsigned int cpp;
 };
 
@@ -695,7 +695,8 @@ static void vmw_stdu_dmabuf_cpu_commit(struct vmw_kms_dirty *dirty)
 	s32 src_pitch, dst_pitch;
 	u8 *src, *dst;
 	bool not_used;
-
+	struct ttm_bo_kmap_obj guest_map;
+	int ret;
 
 	if (!dirty->num_hits)
 		return;
@@ -706,6 +707,13 @@ static void vmw_stdu_dmabuf_cpu_commit(struct vmw_kms_dirty *dirty)
 	if (width == 0 || height == 0)
 		return;
 
+	ret = ttm_bo_kmap(&ddirty->buf->base, 0, ddirty->buf->base.num_pages,
+			  &guest_map);
+	if (ret) {
+		DRM_ERROR("Failed mapping framebuffer for blit: %d\n",
+			  ret);
+		goto out_cleanup;
+	}
 
 	/* Assume we are blitting from Host (display_srf) to Guest (dmabuf) */
 	src_pitch = stdu->display_srf->base_size.width * stdu->cpp;
@@ -713,7 +721,7 @@ static void vmw_stdu_dmabuf_cpu_commit(struct vmw_kms_dirty *dirty)
 	src += ddirty->top * src_pitch + ddirty->left * stdu->cpp;
 
 	dst_pitch = ddirty->pitch;
-	dst = ttm_kmap_obj_virtual(&stdu->guest_map, &not_used);
+	dst = ttm_kmap_obj_virtual(&guest_map, &not_used);
 	dst += ddirty->fb_top * dst_pitch + ddirty->fb_left * stdu->cpp;
 
 
@@ -772,6 +780,7 @@ static void vmw_stdu_dmabuf_cpu_commit(struct vmw_kms_dirty *dirty)
 		vmw_fifo_commit(dev_priv, sizeof(*cmd));
 	}
 
+	ttm_bo_kunmap(&guest_map);
 out_cleanup:
 	ddirty->left = ddirty->top = ddirty->fb_left = ddirty->fb_top = S32_MAX;
 	ddirty->right = ddirty->bottom = S32_MIN;
@@ -1109,9 +1118,6 @@ vmw_stdu_primary_plane_cleanup_fb(struct drm_plane *plane,
 {
 	struct vmw_plane_state *vps = vmw_plane_state_to_vps(old_state);
 
-	if (vps->guest_map.virtual)
-		ttm_bo_kunmap(&vps->guest_map);
-
 	if (vps->host_map.virtual)
 		ttm_bo_kunmap(&vps->host_map);
 
@@ -1277,33 +1283,11 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 	 */
 	if (vps->content_fb_type == SEPARATE_DMA &&
 	    !(dev_priv->capabilities & SVGA_CAP_3D)) {
-
-		struct vmw_framebuffer_dmabuf *new_vfbd;
-
-		new_vfbd = vmw_framebuffer_to_vfbd(new_fb);
-
-		ret = ttm_bo_reserve(&new_vfbd->buffer->base, false, false,
-				     NULL);
-		if (ret)
-			goto out_srf_unpin;
-
-		ret = ttm_bo_kmap(&new_vfbd->buffer->base, 0,
-				  new_vfbd->buffer->base.num_pages,
-				  &vps->guest_map);
-
-		ttm_bo_unreserve(&new_vfbd->buffer->base);
-
-		if (ret) {
-			DRM_ERROR("Failed to map content buffer to CPU\n");
-			goto out_srf_unpin;
-		}
-
 		ret = ttm_bo_kmap(&vps->surf->res.backup->base, 0,
 				  vps->surf->res.backup->base.num_pages,
 				  &vps->host_map);
 		if (ret) {
 			DRM_ERROR("Failed to map display buffer to CPU\n");
-			ttm_bo_kunmap(&vps->guest_map);
 			goto out_srf_unpin;
 		}
 
@@ -1350,7 +1334,6 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 	stdu->display_srf = vps->surf;
 	stdu->content_fb_type = vps->content_fb_type;
 	stdu->cpp = vps->cpp;
-	memcpy(&stdu->guest_map, &vps->guest_map, sizeof(vps->guest_map));
 	memcpy(&stdu->host_map, &vps->host_map, sizeof(vps->host_map));
 
 	if (!stdu->defined)

commit bd386e51805632abed4a0873a84af35f0c6461e3
Author: Keith Packard <keithp@keithp.com>
Date:   Wed Jul 5 14:34:23 2017 -0700

    drm: Reorganize drm_pending_event to support future event types [v2]
    
    Place drm_event_vblank in a new union that includes that and a bare
    drm_event structure. This will allow new members of that union to be
    added in the future without changing code related to the existing vbl
    event type.
    
    Assignments to the crtc_id field are now done when the event is
    allocated, rather than when delievered. This way, delivery doesn't
    need to have the crtc ID available.
    
    v2:
     * Remove 'dev' argument from create_vblank_event
    
            It wasn't being used anyways, and if we need it in the future,
            we can always get it from crtc->dev.
    
     * Check for MODESETTING before looking for crtc in queue_vblank_event
    
            UMS drivers will oops if we try to get a crtc, so make sure
            we're modesetting before we try to find a crtc_id to fill into
            the event.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    (cherry picked from commit dc695b85fde88eca3ef3b03fcd82f15b6bc6e462)

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index ca3afae2db1f..90b5437fd787 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -549,8 +549,8 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 
 		ret = vmw_event_fence_action_queue(file_priv, fence,
 						   &event->base,
-						   &event->event.tv_sec,
-						   &event->event.tv_usec,
+						   &event->event.vbl.tv_sec,
+						   &event->event.vbl.tv_usec,
 						   true);
 		vmw_fence_obj_unreference(&fence);
 	} else {

commit 0c697fafc66830ca7d5dc19123a1d0641deaa1f6
Merge: 09ef2378dc42 ef954844c7ac
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Aug 15 16:16:58 2017 +1000

    Backmerge tag 'v4.13-rc5' into drm-next
    
    Linux 4.13-rc5
    
    There's a really nasty nouveau collision, hopefully someone can take a look
    once I pushed this out.

commit e6fc3b68558e4c6d8d160b5daf2511b99afa8814
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Sun Jul 23 20:46:38 2017 -0700

    drm: Plumb modifiers through plane init
    
    This is the plumbing for supporting fb modifiers on planes. Modifiers
    have already been introduced to some extent, but this series will extend
    this to allow querying modifiers per plane. Based on this, the client to
    enable optimal modifications for framebuffers.
    
    This patch simply allows the DRM drivers to initialize their list of
    supported modifiers upon initializing the plane.
    
    v2: A minor addition from Daniel
    
    v3:
    * Updated commit message
    * s/INVALID/DRM_FORMAT_MOD_INVALID (Liviu)
    * Remove some excess newlines (Liviu)
    * Update comment for > 64 modifiers (Liviu)
    
    v4: Minor comment adjustments (Liviu)
    
    v5: Some new platforms added due to rebase
    
    v6: Add some missed plane inits (or maybe they're new - who knows at
    this point) (Daniel)
    
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Reviewed-by: Daniel Stone <daniels@collabora.com> (v2)
    Reviewed-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Daniel Stone <daniels@collabora.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index ed9404a7f457..c4de4ad0543b 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1475,7 +1475,7 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 				       0, &vmw_stdu_plane_funcs,
 				       vmw_primary_plane_formats,
 				       ARRAY_SIZE(vmw_primary_plane_formats),
-				       DRM_PLANE_TYPE_PRIMARY, NULL);
+				       NULL, DRM_PLANE_TYPE_PRIMARY, NULL);
 	if (ret) {
 		DRM_ERROR("Failed to initialize primary plane");
 		goto err_free;
@@ -1490,7 +1490,7 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 			0, &vmw_stdu_cursor_funcs,
 			vmw_cursor_plane_formats,
 			ARRAY_SIZE(vmw_cursor_plane_formats),
-			DRM_PLANE_TYPE_CURSOR, NULL);
+			NULL, DRM_PLANE_TYPE_CURSOR, NULL);
 	if (ret) {
 		DRM_ERROR("Failed to initialize cursor plane");
 		drm_plane_cleanup(&stdu->base.primary);

commit 7b009e76797c82178d7a03ae0eaad5951d975277
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Mon Jul 17 07:49:22 2017 -0700

    drm/vmwgfx: Limit max desktop dimensions to 8Kx8K
    
    This was originally chosen to be an arbitrarily large number.  However,
    some user mode may actually try to set a 16Kx16K mode and run into other
    issues.
    
    Since 8Kx8K is the current texture limit for Mesa LLVM driver, we will
    just use this limit for now.
    
    Cc: <stable@vger.kernel.org> # 4.12.x
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Brian Paul <brianp@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 50be1f034f9e..5284e8d2f7ba 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1640,8 +1640,8 @@ int vmw_kms_stdu_init_display(struct vmw_private *dev_priv)
 		 * something arbitrarily large and we will reject any layout
 		 * that doesn't fit prim_bb_mem later
 		 */
-		dev->mode_config.max_width = 16384;
-		dev->mode_config.max_height = 16384;
+		dev->mode_config.max_width = 8192;
+		dev->mode_config.max_height = 8192;
 	}
 
 	vmw_kms_create_implicit_placement_property(dev_priv, false);

commit 64581714b58bc3e16ede8dc37a025c3aa0e0eef1
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Jun 30 12:36:45 2017 +0300

    drm: Convert atomic drivers from CRTC .disable() to .atomic_disable()
    
    The CRTC .disable() helper operation is deprecated for atomic drivers,
    the new .atomic_disable() helper operation being preferred. Convert all
    atomic drivers to .atomic_disable() to avoid cargo-cult use of
    .disable() in new drivers.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com> # for sun4i
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de> # for mediatek
    Acked-by: Alexey Brodkin <abrodkin@synopsys.com> # for arcpgu
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com> # for atmel-hlcdc
    Tested-by: Philippe Cornu <philippe.cornu@st.com> # for stm
    Acked-by: Philippe Cornu <philippe.cornu@st.com> # for stm
    Acked-by: Vincent Abriou <vincent.abriou@st.com> # for sti
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com> # for vmwgfx
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170630093646.7928-3-laurent.pinchart+renesas@ideasonboard.com

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index f2b39d9c51cc..ed9404a7f457 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -433,7 +433,8 @@ static void vmw_stdu_crtc_atomic_enable(struct drm_crtc *crtc,
 		vmw_kms_del_active(dev_priv, &stdu->base);
 }
 
-static void vmw_stdu_crtc_helper_disable(struct drm_crtc *crtc)
+static void vmw_stdu_crtc_atomic_disable(struct drm_crtc *crtc,
+					 struct drm_crtc_state *old_state)
 {
 	struct vmw_private *dev_priv;
 	struct vmw_screen_target_display_unit *stdu;
@@ -1416,12 +1417,12 @@ drm_plane_helper_funcs vmw_stdu_primary_plane_helper_funcs = {
 
 static const struct drm_crtc_helper_funcs vmw_stdu_crtc_helper_funcs = {
 	.prepare = vmw_stdu_crtc_helper_prepare,
-	.disable = vmw_stdu_crtc_helper_disable,
 	.mode_set_nofb = vmw_stdu_crtc_mode_set_nofb,
 	.atomic_check = vmw_du_crtc_atomic_check,
 	.atomic_begin = vmw_du_crtc_atomic_begin,
 	.atomic_flush = vmw_du_crtc_atomic_flush,
 	.atomic_enable = vmw_stdu_crtc_atomic_enable,
+	.atomic_disable = vmw_stdu_crtc_atomic_disable,
 };
 
 

commit 0b20a0f8c3cb6f74fe326101b62eeb5e2c56a53c
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Jun 30 12:36:44 2017 +0300

    drm: Add old state pointer to CRTC .enable() helper function
    
    The old state is useful for drivers that need to perform operations at
    enable time that depend on the transition between the old and new
    states.
    
    While at it, rename the operation to .atomic_enable() to be consistent
    with .atomic_disable(), as the .enable() operation is used by atomic
    helpers only.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com> # for sun4i
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de> # for imx-drm and mediatek
    Acked-by: Alexey Brodkin <abrodkin@synopsys.com> # for arcpgu
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com> # for atmel-hlcdc
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com> # for hdlcd and mali-dp
    Acked-by: Stefan Agner <stefan@agner.ch> # for fsl-dcu
    Tested-by: Philippe Cornu <philippe.cornu@st.com> # for stm
    Acked-by: Philippe Cornu <philippe.cornu@st.com> # for stm
    Acked-by: Vincent Abriou <vincent.abriou@st.com> # for sti
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com> # for vmwgfx
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170630093646.7928-2-laurent.pinchart+renesas@ideasonboard.com

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 4eb93b47d6db..f2b39d9c51cc 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -412,7 +412,8 @@ static void vmw_stdu_crtc_helper_prepare(struct drm_crtc *crtc)
 }
 
 
-static void vmw_stdu_crtc_helper_enable(struct drm_crtc *crtc)
+static void vmw_stdu_crtc_atomic_enable(struct drm_crtc *crtc,
+					struct drm_crtc_state *old_state)
 {
 	struct vmw_private *dev_priv;
 	struct vmw_screen_target_display_unit *stdu;
@@ -1415,12 +1416,12 @@ drm_plane_helper_funcs vmw_stdu_primary_plane_helper_funcs = {
 
 static const struct drm_crtc_helper_funcs vmw_stdu_crtc_helper_funcs = {
 	.prepare = vmw_stdu_crtc_helper_prepare,
-	.enable = vmw_stdu_crtc_helper_enable,
 	.disable = vmw_stdu_crtc_helper_disable,
 	.mode_set_nofb = vmw_stdu_crtc_mode_set_nofb,
 	.atomic_check = vmw_du_crtc_atomic_check,
 	.atomic_begin = vmw_du_crtc_atomic_begin,
 	.atomic_flush = vmw_du_crtc_atomic_flush,
+	.atomic_enable = vmw_stdu_crtc_atomic_enable,
 };
 
 

commit 4177b51e1949468c74a54dde99c775f5746fa11e
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Jun 28 00:16:19 2017 +0300

    drm: vmwgfx: Replace CRTC .commit() helper operation with .enable()
    
    The CRTC helper .commit() operation is legacy code, the atomic helpers
    prefer the .enable() operation. Replace the .commit() helper operation
    with .enable() in the driver.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170627211621.27767-6-laurent.pinchart+renesas@ideasonboard.com

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 6aecba6cd5e2..4eb93b47d6db 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -412,7 +412,7 @@ static void vmw_stdu_crtc_helper_prepare(struct drm_crtc *crtc)
 }
 
 
-static void vmw_stdu_crtc_helper_commit(struct drm_crtc *crtc)
+static void vmw_stdu_crtc_helper_enable(struct drm_crtc *crtc)
 {
 	struct vmw_private *dev_priv;
 	struct vmw_screen_target_display_unit *stdu;
@@ -1415,7 +1415,7 @@ drm_plane_helper_funcs vmw_stdu_primary_plane_helper_funcs = {
 
 static const struct drm_crtc_helper_funcs vmw_stdu_crtc_helper_funcs = {
 	.prepare = vmw_stdu_crtc_helper_prepare,
-	.commit = vmw_stdu_crtc_helper_commit,
+	.enable = vmw_stdu_crtc_helper_enable,
 	.disable = vmw_stdu_crtc_helper_disable,
 	.mode_set_nofb = vmw_stdu_crtc_mode_set_nofb,
 	.atomic_check = vmw_du_crtc_atomic_check,

commit b740e76936c14354a9c5676a3eed839ea8472c41
Merge: 7141fd3e5ba9 6d61e70ccc21
Author: Sean Paul <seanpaul@chromium.org>
Date:   Tue Jun 27 09:18:17 2017 -0400

    Merge remote-tracking branch 'airlied/drm-next' into drm-misc-next
    
    Required for Daniel's drm_vblank_cleanup cleanup

commit 5f58e9742df3f1cdf1034a26569649f5f4fd776b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Jun 26 18:19:48 2017 +0200

    drm/vmwgfx: Drop drm_vblank_cleanup
    
    Again stopping the vblank before uninstalling the irq handler is kinda
    the wrong way round, but the fb_off stuff should take care of
    disabling the dsiplay at least in most cases. So drop the
    drm_vblank_cleanup code since it's not really doing anything, it looks
    all cargo-culted.
    
    v2: Appease gcc better.
    
    v3: Simplify code (Sean Paul)
    
    Cc: Sinclair Yeh <syeh@vmware.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170626161949.25629-1-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index bad31bdf09b6..b4d4074c0ae0 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1634,36 +1634,11 @@ int vmw_kms_stdu_init_display(struct vmw_private *dev_priv)
 
 		if (unlikely(ret != 0)) {
 			DRM_ERROR("Failed to initialize STDU %d", i);
-			goto err_vblank_cleanup;
+			return ret;
 		}
 	}
 
 	DRM_INFO("Screen Target Display device initialized\n");
 
-	return 0;
-
-err_vblank_cleanup:
-	drm_vblank_cleanup(dev);
-	return ret;
-}
-
-
-
-/**
- * vmw_kms_stdu_close_display - Cleans up after vmw_kms_stdu_init_display
- *
- * @dev_priv: VMW DRM device
- *
- * Frees up any resources allocated by vmw_kms_stdu_init_display
- *
- * RETURNS:
- * 0 on success
- */
-int vmw_kms_stdu_close_display(struct vmw_private *dev_priv)
-{
-	struct drm_device *dev = dev_priv->dev;
-
-	drm_vblank_cleanup(dev);
-
 	return 0;
 }

commit a1ac633912305168bf432c3d47979d43b16164f8
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Fri Jun 2 07:55:50 2017 +0200

    drm/vmwgfx: Fix large topology crash
    
    The previous attempt at this had an issue with with num_clips > 1
    because it would always end up using the coordinates of the last
    clip while using width and height calculated from the bounding
    box of all the clips.
    
    So if the last clip happens to be not at the top-left corner of
    the bounding box, the CPU blit operation would go out of bounds.
    
    The original intent was to coalesce all the clips into one blit,
    and to do that we need to also track the starting point of the
    content buffer.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 60ace30246cf..50be1f034f9e 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -56,6 +56,8 @@ enum stdu_content_type {
  * @right: Right side of bounding box.
  * @top: Top side of bounding box.
  * @bottom: Bottom side of bounding box.
+ * @fb_left: Left side of the framebuffer/content bounding box
+ * @fb_top: Top of the framebuffer/content bounding box
  * @buf: DMA buffer when DMA-ing between buffer and screen targets.
  * @sid: Surface ID when copying between surface and screen targets.
  */
@@ -63,6 +65,7 @@ struct vmw_stdu_dirty {
 	struct vmw_kms_dirty base;
 	SVGA3dTransferType  transfer;
 	s32 left, right, top, bottom;
+	s32 fb_left, fb_top;
 	u32 pitch;
 	union {
 		struct vmw_dma_buffer *buf;
@@ -647,7 +650,7 @@ static void vmw_stdu_dmabuf_fifo_commit(struct vmw_kms_dirty *dirty)
  *
  * @dirty: The closure structure.
  *
- * This function calculates the bounding box for all the incoming clips
+ * This function calculates the bounding box for all the incoming clips.
  */
 static void vmw_stdu_dmabuf_cpu_clip(struct vmw_kms_dirty *dirty)
 {
@@ -656,11 +659,19 @@ static void vmw_stdu_dmabuf_cpu_clip(struct vmw_kms_dirty *dirty)
 
 	dirty->num_hits = 1;
 
-	/* Calculate bounding box */
+	/* Calculate destination bounding box */
 	ddirty->left = min_t(s32, ddirty->left, dirty->unit_x1);
 	ddirty->top = min_t(s32, ddirty->top, dirty->unit_y1);
 	ddirty->right = max_t(s32, ddirty->right, dirty->unit_x2);
 	ddirty->bottom = max_t(s32, ddirty->bottom, dirty->unit_y2);
+
+	/*
+	 * Calculate content bounding box.  We only need the top-left
+	 * coordinate because width and height will be the same as the
+	 * destination bounding box above
+	 */
+	ddirty->fb_left = min_t(s32, ddirty->fb_left, dirty->fb_x);
+	ddirty->fb_top  = min_t(s32, ddirty->fb_top, dirty->fb_y);
 }
 
 
@@ -697,11 +708,11 @@ static void vmw_stdu_dmabuf_cpu_commit(struct vmw_kms_dirty *dirty)
 	/* Assume we are blitting from Host (display_srf) to Guest (dmabuf) */
 	src_pitch = stdu->display_srf->base_size.width * stdu->cpp;
 	src = ttm_kmap_obj_virtual(&stdu->host_map, &not_used);
-	src += dirty->unit_y1 * src_pitch + dirty->unit_x1 * stdu->cpp;
+	src += ddirty->top * src_pitch + ddirty->left * stdu->cpp;
 
 	dst_pitch = ddirty->pitch;
 	dst = ttm_kmap_obj_virtual(&stdu->guest_map, &not_used);
-	dst += dirty->fb_y * dst_pitch + dirty->fb_x * stdu->cpp;
+	dst += ddirty->fb_top * dst_pitch + ddirty->fb_left * stdu->cpp;
 
 
 	/* Figure out the real direction */
@@ -760,7 +771,7 @@ static void vmw_stdu_dmabuf_cpu_commit(struct vmw_kms_dirty *dirty)
 	}
 
 out_cleanup:
-	ddirty->left = ddirty->top = S32_MAX;
+	ddirty->left = ddirty->top = ddirty->fb_left = ddirty->fb_top = S32_MAX;
 	ddirty->right = ddirty->bottom = S32_MIN;
 }
 
@@ -812,6 +823,7 @@ int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
 		SVGA3D_READ_HOST_VRAM;
 	ddirty.left = ddirty.top = S32_MAX;
 	ddirty.right = ddirty.bottom = S32_MIN;
+	ddirty.fb_left = ddirty.fb_top = S32_MAX;
 	ddirty.pitch = vfb->base.pitches[0];
 	ddirty.buf = buf;
 	ddirty.base.fifo_commit = vmw_stdu_dmabuf_fifo_commit;

commit 8a309c8a2d0619efe29ec652c163d6b89eff9f9f
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Fri Jun 2 07:53:27 2017 +0200

    drm/vmwgfx: Make sure to update STDU when FB is updated
    
    When a new FB is bound, we have to send an update command otherwise
    the new FB may not be shown
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index bad31bdf09b6..60ace30246cf 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1355,6 +1355,11 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 		DRM_ERROR("Failed to bind surface to STDU.\n");
 	else
 		crtc->primary->fb = plane->state->fb;
+
+	ret = vmw_stdu_update_st(dev_priv, stdu);
+
+	if (ret)
+		DRM_ERROR("Failed to update STDU.\n");
 }
 
 

commit 320d8c3d38739fa8e31a076b86cbdafcf8897d5e
Merge: 7558ab66424e b121b051d14c
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Apr 3 16:30:24 2017 +1000

    Merge tag 'drm-misc-next-2017-03-31' of git://anongit.freedesktop.org/git/drm-misc into drm-next
    
    drm-misc for 4.12:
    
    Core:
    - Removed some fb subsampling dimension checks from core (Ville)
    - Some MST slot cleanup (Dhinakaran)
    - Extracted drm_debugfs.h & drm_ioctl.h from drmP.h (Daniel)
    - Added drm_atomic_helper_shutdown() to compliment suspend/resume counterparts
      (Daniel)
    - Pipe context through legacy modeset to remove legacy_backoff nasties (Daniel)
    - Cleanups around vblank as well as allowing lockless counter reads (Chris W.)
    - VGA Switcheroo added to MAINTAINERS with Lukas Wunner as reviewer (Lukas)
    
    Drivers:
    - Enhancements to rockchip driver probe (Jeffy) and dsi (Chris Z.)
    - Thunderbolt external GPU awareness added (Lukas)
    
    * tag 'drm-misc-next-2017-03-31' of git://anongit.freedesktop.org/git/drm-misc: (63 commits)
      apple-gmux: Don't switch external DP port on 2011+ MacBook Pros
      drm/nouveau: Don't register Thunderbolt eGPU with vga_switcheroo
      drm/amdgpu: Don't register Thunderbolt eGPU with vga_switcheroo
      drm/radeon: Don't register Thunderbolt eGPU with vga_switcheroo
      PCI: Recognize Thunderbolt devices
      MAINTAINERS: Add Lukas Wunner as reviewer for vga_switcheroo
      drm: Fix locking gotcha in page_flip ioctl
      drm: Clarify the role of plane_state argument to drm_simple update().
      drm: Clear e after kfree in drm_mode_page_flip_ioctl
      drm: Convert cmpxchg(bool) back to a two step operation
      drm/bridge: ti-tfp410: support hpd via gpio
      drm: use .hword to represent 16-bit numbers
      Revert unrelated part of "drm: simplify the locking in the GETCRTC ioctl"
      drm: Fixup failure paths in drm_atomic_helper_set_config
      drm: Peek at the current counter/timestamp for vblank queries
      drm: Refactor vblank sequence number comparison
      drm: vblank cannot be enabled if dev->irq_enabled is false
      drm: Mark up accesses of vblank->enabled outside of its spinlock
      drm: Make the decision to keep vblank irq enabled earlier
      drm/atomic-helper: Remove the backoff hack from set_config
      ...

commit 28c954299cd2b5cb5411816c9eeaf3f51ed4638e
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Mon Mar 27 11:12:27 2017 -0700

    drm/vmwgfx: Properly check display/scanout surface size
    
    The scanout surface size is the smaller of max texture size and
    max STDU size.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 4fc46b23ba8b..e872ffe5f0db 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1601,7 +1601,21 @@ int vmw_kms_stdu_init_display(struct vmw_private *dev_priv)
 
 	dev_priv->active_display_unit = vmw_du_screen_target;
 
-	if (!(dev_priv->capabilities & SVGA_CAP_3D)) {
+	if (dev_priv->capabilities & SVGA_CAP_3D) {
+		/*
+		 * For 3D VMs, display (scanout) buffer size is the smaller of
+		 * max texture and max STDU
+		 */
+		uint32_t max_width, max_height;
+
+		max_width = min(dev_priv->texture_max_width,
+				dev_priv->stdu_max_width);
+		max_height = min(dev_priv->texture_max_height,
+				 dev_priv->stdu_max_height);
+
+		dev->mode_config.max_width = max_width;
+		dev->mode_config.max_height = max_height;
+	} else {
 		/*
 		 * Given various display aspect ratios, there's no way to
 		 * estimate these using prim_bb_mem.  So just set these to

commit 810b3e1683d00e51c8392bcee7dc7a1c65354777
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 15:39:16 2017 -0700

    drm/vmwgfx: Support topology greater than texture size
    
    Most of the display servers today use a single surface to represent the
    entire desktop even if it's stretched across multiple screens.
    
    For vmwgfx with STDU, the maximum surface size is limited to the
    maximum texture size on the host.  On a 2D VM, this limits our
    ability to support configurations with more than one 4K monitor.
    
    To get past this limitation, we will now allow using a large DMA buf
    as the framebuffer, and take care of blitting contents from this DMA buf
    to the display buffer.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 2757cda391bb..4fc46b23ba8b 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -109,6 +109,10 @@ struct vmw_screen_target_display_unit {
 	s32 display_width, display_height;
 
 	bool defined;
+
+	/* For CPU Blit */
+	struct ttm_bo_kmap_obj host_map, guest_map;
+	unsigned int cpp;
 };
 
 
@@ -636,6 +640,129 @@ static void vmw_stdu_dmabuf_fifo_commit(struct vmw_kms_dirty *dirty)
 	ddirty->right = ddirty->bottom = S32_MIN;
 }
 
+
+/**
+ * vmw_stdu_dmabuf_cpu_clip - Callback to encode a CPU blit
+ *
+ * @dirty: The closure structure.
+ *
+ * This function calculates the bounding box for all the incoming clips
+ */
+static void vmw_stdu_dmabuf_cpu_clip(struct vmw_kms_dirty *dirty)
+{
+	struct vmw_stdu_dirty *ddirty =
+		container_of(dirty, struct vmw_stdu_dirty, base);
+
+	dirty->num_hits = 1;
+
+	/* Calculate bounding box */
+	ddirty->left = min_t(s32, ddirty->left, dirty->unit_x1);
+	ddirty->top = min_t(s32, ddirty->top, dirty->unit_y1);
+	ddirty->right = max_t(s32, ddirty->right, dirty->unit_x2);
+	ddirty->bottom = max_t(s32, ddirty->bottom, dirty->unit_y2);
+}
+
+
+/**
+ * vmw_stdu_dmabuf_cpu_commit - Callback to do a CPU blit from DMAbuf
+ *
+ * @dirty: The closure structure.
+ *
+ * For the special case when we cannot create a proxy surface in a
+ * 2D VM, we have to do a CPU blit ourselves.
+ */
+static void vmw_stdu_dmabuf_cpu_commit(struct vmw_kms_dirty *dirty)
+{
+	struct vmw_stdu_dirty *ddirty =
+		container_of(dirty, struct vmw_stdu_dirty, base);
+	struct vmw_screen_target_display_unit *stdu =
+		container_of(dirty->unit, typeof(*stdu), base);
+	s32 width, height;
+	s32 src_pitch, dst_pitch;
+	u8 *src, *dst;
+	bool not_used;
+
+
+	if (!dirty->num_hits)
+		return;
+
+	width = ddirty->right - ddirty->left;
+	height = ddirty->bottom - ddirty->top;
+
+	if (width == 0 || height == 0)
+		return;
+
+
+	/* Assume we are blitting from Host (display_srf) to Guest (dmabuf) */
+	src_pitch = stdu->display_srf->base_size.width * stdu->cpp;
+	src = ttm_kmap_obj_virtual(&stdu->host_map, &not_used);
+	src += dirty->unit_y1 * src_pitch + dirty->unit_x1 * stdu->cpp;
+
+	dst_pitch = ddirty->pitch;
+	dst = ttm_kmap_obj_virtual(&stdu->guest_map, &not_used);
+	dst += dirty->fb_y * dst_pitch + dirty->fb_x * stdu->cpp;
+
+
+	/* Figure out the real direction */
+	if (ddirty->transfer == SVGA3D_WRITE_HOST_VRAM) {
+		u8 *tmp;
+		s32 tmp_pitch;
+
+		tmp = src;
+		tmp_pitch = src_pitch;
+
+		src = dst;
+		src_pitch = dst_pitch;
+
+		dst = tmp;
+		dst_pitch = tmp_pitch;
+	}
+
+	/* CPU Blit */
+	while (height-- > 0) {
+		memcpy(dst, src, width * stdu->cpp);
+		dst += dst_pitch;
+		src += src_pitch;
+	}
+
+	if (ddirty->transfer == SVGA3D_WRITE_HOST_VRAM) {
+		struct vmw_private *dev_priv;
+		struct vmw_stdu_update *cmd;
+		struct drm_clip_rect region;
+		int ret;
+
+		/* We are updating the actual surface, not a proxy */
+		region.x1 = ddirty->left;
+		region.x2 = ddirty->right;
+		region.y1 = ddirty->top;
+		region.y2 = ddirty->bottom;
+		ret = vmw_kms_update_proxy(
+			(struct vmw_resource *) &stdu->display_srf->res,
+			(const struct drm_clip_rect *) &region, 1, 1);
+		if (ret)
+			goto out_cleanup;
+
+
+		dev_priv = vmw_priv(stdu->base.crtc.dev);
+		cmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));
+
+		if (!cmd) {
+			DRM_ERROR("Cannot reserve FIFO space to update STDU");
+			goto out_cleanup;
+		}
+
+		vmw_stdu_populate_update(cmd, stdu->base.unit,
+					 ddirty->left, ddirty->right,
+					 ddirty->top, ddirty->bottom);
+
+		vmw_fifo_commit(dev_priv, sizeof(*cmd));
+	}
+
+out_cleanup:
+	ddirty->left = ddirty->top = S32_MAX;
+	ddirty->right = ddirty->bottom = S32_MIN;
+}
+
 /**
  * vmw_kms_stdu_dma - Perform a DMA transfer between a dma-buffer backed
  * framebuffer and the screen target system.
@@ -694,6 +821,13 @@ int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
 	if (to_surface)
 		ddirty.base.fifo_reserve_size += sizeof(struct vmw_stdu_update);
 
+	/* 2D VMs cannot use SVGA_3D_CMD_SURFACE_DMA so do CPU blit instead */
+	if (!(dev_priv->capabilities & SVGA_CAP_3D)) {
+		ddirty.base.fifo_commit = vmw_stdu_dmabuf_cpu_commit;
+		ddirty.base.clip = vmw_stdu_dmabuf_cpu_clip;
+		ddirty.base.fifo_reserve_size = 0;
+	}
+
 	ret = vmw_kms_helper_dirty(dev_priv, vfb, clips, vclips,
 				   0, 0, num_clips, increment, &ddirty.base);
 	vmw_kms_helper_buffer_finish(dev_priv, file_priv, buf, NULL,
@@ -960,12 +1094,19 @@ vmw_stdu_primary_plane_cleanup_fb(struct drm_plane *plane,
 {
 	struct vmw_plane_state *vps = vmw_plane_state_to_vps(old_state);
 
+	if (vps->guest_map.virtual)
+		ttm_bo_kunmap(&vps->guest_map);
+
+	if (vps->host_map.virtual)
+		ttm_bo_kunmap(&vps->host_map);
+
 	if (vps->surf)
 		WARN_ON(!vps->pinned);
 
 	vmw_du_plane_cleanup_fb(plane, old_state);
 
 	vps->content_fb_type = SAME_AS_DISPLAY;
+	vps->cpp = 0;
 }
 
 
@@ -986,6 +1127,7 @@ static int
 vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 				  struct drm_plane_state *new_state)
 {
+	struct vmw_private *dev_priv = vmw_priv(plane->dev);
 	struct drm_framebuffer *new_fb = new_state->fb;
 	struct vmw_framebuffer *vfb;
 	struct vmw_plane_state *vps = vmw_plane_state_to_vps(new_state);
@@ -1111,8 +1253,54 @@ vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
 	}
 
 	vps->content_fb_type = new_content_type;
+
+	/*
+	 * This should only happen if the DMA buf is too large to create a
+	 * proxy surface for.
+	 * If we are a 2D VM with a DMA buffer then we have to use CPU blit
+	 * so cache these mappings
+	 */
+	if (vps->content_fb_type == SEPARATE_DMA &&
+	    !(dev_priv->capabilities & SVGA_CAP_3D)) {
+
+		struct vmw_framebuffer_dmabuf *new_vfbd;
+
+		new_vfbd = vmw_framebuffer_to_vfbd(new_fb);
+
+		ret = ttm_bo_reserve(&new_vfbd->buffer->base, false, false,
+				     NULL);
+		if (ret)
+			goto out_srf_unpin;
+
+		ret = ttm_bo_kmap(&new_vfbd->buffer->base, 0,
+				  new_vfbd->buffer->base.num_pages,
+				  &vps->guest_map);
+
+		ttm_bo_unreserve(&new_vfbd->buffer->base);
+
+		if (ret) {
+			DRM_ERROR("Failed to map content buffer to CPU\n");
+			goto out_srf_unpin;
+		}
+
+		ret = ttm_bo_kmap(&vps->surf->res.backup->base, 0,
+				  vps->surf->res.backup->base.num_pages,
+				  &vps->host_map);
+		if (ret) {
+			DRM_ERROR("Failed to map display buffer to CPU\n");
+			ttm_bo_kunmap(&vps->guest_map);
+			goto out_srf_unpin;
+		}
+
+		vps->cpp = new_fb->pitches[0] / new_fb->width;
+	}
+
 	return 0;
 
+out_srf_unpin:
+	vmw_resource_unpin(&vps->surf->res);
+	vps->pinned--;
+
 out_srf_unref:
 	vmw_surface_unreference(&vps->surf);
 	return ret;
@@ -1146,6 +1334,9 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 
 	stdu->display_srf = vps->surf;
 	stdu->content_fb_type = vps->content_fb_type;
+	stdu->cpp = vps->cpp;
+	memcpy(&stdu->guest_map, &vps->guest_map, sizeof(vps->guest_map));
+	memcpy(&stdu->host_map, &vps->host_map, sizeof(vps->host_map));
 
 	if (!stdu->defined)
 		return;
@@ -1410,6 +1601,17 @@ int vmw_kms_stdu_init_display(struct vmw_private *dev_priv)
 
 	dev_priv->active_display_unit = vmw_du_screen_target;
 
+	if (!(dev_priv->capabilities & SVGA_CAP_3D)) {
+		/*
+		 * Given various display aspect ratios, there's no way to
+		 * estimate these using prim_bb_mem.  So just set these to
+		 * something arbitrarily large and we will reject any layout
+		 * that doesn't fit prim_bb_mem later
+		 */
+		dev->mode_config.max_width = 16384;
+		dev->mode_config.max_height = 16384;
+	}
+
 	vmw_kms_create_implicit_placement_property(dev_priv, false);
 
 	for (i = 0; i < VMWGFX_NUM_DISPLAY_UNITS; ++i) {

commit 9aa8dcab7e44288c6fd620c5b831d2ca535866c2
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 14:40:04 2017 -0700

    drm/vmwgfx: Explicityly track screen target width and height
    
    We can no longer make the assumption that vmw_stdu_update_st() will
    be called when there's a valid display surface attached.  So
    instead of using display_srf for width and height, make a record of
    these paremeters when the screen target is first defined.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index e5a38f4ddb62..2757cda391bb 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -106,6 +106,7 @@ struct vmw_screen_target_display_unit {
 	struct vmw_display_unit base;
 	const struct vmw_surface *display_srf;
 	enum stdu_content_type content_fb_type;
+	s32 display_width, display_height;
 
 	bool defined;
 };
@@ -184,6 +185,8 @@ static int vmw_stdu_define_st(struct vmw_private *dev_priv,
 	vmw_fifo_commit(dev_priv, sizeof(*cmd));
 
 	stdu->defined = true;
+	stdu->display_width  = mode->hdisplay;
+	stdu->display_height = mode->vdisplay;
 
 	return 0;
 }
@@ -281,7 +284,6 @@ static int vmw_stdu_update_st(struct vmw_private *dev_priv,
 			      struct vmw_screen_target_display_unit *stdu)
 {
 	struct vmw_stdu_update *cmd;
-	struct drm_crtc *crtc = &stdu->base.crtc;
 
 	if (!stdu->defined) {
 		DRM_ERROR("No screen target defined");
@@ -295,8 +297,9 @@ static int vmw_stdu_update_st(struct vmw_private *dev_priv,
 		return -ENOMEM;
 	}
 
-	vmw_stdu_populate_update(cmd, stdu->base.unit, 0, crtc->mode.hdisplay,
-				 0, crtc->mode.vdisplay);
+	vmw_stdu_populate_update(cmd, stdu->base.unit,
+				 0, stdu->display_width,
+				 0, stdu->display_height);
 
 	vmw_fifo_commit(dev_priv, sizeof(*cmd));
 
@@ -346,6 +349,8 @@ static int vmw_stdu_destroy_st(struct vmw_private *dev_priv,
 		DRM_ERROR("Failed to sync with HW");
 
 	stdu->defined = false;
+	stdu->display_width  = 0;
+	stdu->display_height = 0;
 
 	return ret;
 }

commit f7c478be0abb5f6db5dfa13bb8118628817b9afe
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Fri Mar 31 10:16:22 2017 -0700

    drm/vmwgfx: Turn on DRIVER_ATOMIC flag
    
    Now that the legacy path has been tested, turn on the
    DRIVER_ATOMIC flag so user mode driver can start going through
    the Atomic path.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index b7999eb4f5fc..e5a38f4ddb62 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1203,7 +1203,6 @@ static const struct drm_crtc_helper_funcs vmw_stdu_crtc_helper_funcs = {
 	.prepare = vmw_stdu_crtc_helper_prepare,
 	.commit = vmw_stdu_crtc_helper_commit,
 	.disable = vmw_stdu_crtc_helper_disable,
-	.mode_set = drm_helper_crtc_mode_set,
 	.mode_set_nofb = vmw_stdu_crtc_mode_set_nofb,
 	.atomic_check = vmw_du_crtc_atomic_check,
 	.atomic_begin = vmw_du_crtc_atomic_begin,

commit 904bb5e5817f5c5b42e6e3775699c728fd420284
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 14:29:22 2017 -0700

    drm/vmwgfx: Switch over to internal atomic API for STDU
    
    Switch over to using internal atomic API for mode set.
    
    This removes the legacy set_config API, replacing it with
    drm_atomic_helper_set_config().  The DRM helper will use various
    vmwgfx-specific atomic functions to set a mode.
    
    DRIVER_ATOMIC capability flag is not yet set, so the user mode
    will still use the legacy mode set IOCTL.
    
    v2:
    * Avoid a clash between page-flip pinning and setcrtc pinning, modify
    the page-flip code to use the page-flip helper and the atomic callbacks.
    To enable this, we will need to add a wrapper around atomic_commit.
    
    * Add vmw_kms_set_config() to work around vmwgfx xorg driver bug
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 76ca5fa1e3bf..b7999eb4f5fc 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -104,8 +104,7 @@ struct vmw_stdu_surface_copy {
  */
 struct vmw_screen_target_display_unit {
 	struct vmw_display_unit base;
-
-	struct vmw_surface     *display_srf;
+	const struct vmw_surface *display_srf;
 	enum stdu_content_type content_fb_type;
 
 	bool defined;
@@ -117,32 +116,6 @@ static void vmw_stdu_destroy(struct vmw_screen_target_display_unit *stdu);
 
 
 
-/******************************************************************************
- * Screen Target Display Unit helper Functions
- *****************************************************************************/
-
-/**
- * vmw_stdu_unpin_display - unpins the resource associated with display surface
- *
- * @stdu: contains the display surface
- *
- * If the display surface was privatedly allocated by
- * vmw_surface_gb_priv_define() and not registered as a framebuffer, then it
- * won't be automatically cleaned up when all the framebuffers are freed.  As
- * such, we have to explicitly call vmw_resource_unreference() to get it freed.
- */
-static void vmw_stdu_unpin_display(struct vmw_screen_target_display_unit *stdu)
-{
-	if (stdu->display_srf) {
-		struct vmw_resource *res = &stdu->display_srf->res;
-
-		vmw_resource_unpin(res);
-		vmw_surface_unreference(&stdu->display_srf);
-	}
-}
-
-
-
 /******************************************************************************
  * Screen Target Display Unit CRTC Functions
  *****************************************************************************/
@@ -228,7 +201,7 @@ static int vmw_stdu_define_st(struct vmw_private *dev_priv,
  */
 static int vmw_stdu_bind_st(struct vmw_private *dev_priv,
 			    struct vmw_screen_target_display_unit *stdu,
-			    struct vmw_resource *res)
+			    const struct vmw_resource *res)
 {
 	SVGA3dSurfaceImageId image;
 
@@ -377,129 +350,6 @@ static int vmw_stdu_destroy_st(struct vmw_private *dev_priv,
 	return ret;
 }
 
-/**
- * vmw_stdu_bind_fb - Bind an fb to a defined screen target
- *
- * @dev_priv: Pointer to a device private struct.
- * @crtc: The crtc holding the screen target.
- * @mode: The mode currently used by the screen target. Must be non-NULL.
- * @new_fb: The new framebuffer to bind. Must be non-NULL.
- *
- * RETURNS:
- * 0 on success, error code on failure.
- */
-static int vmw_stdu_bind_fb(struct vmw_private *dev_priv,
-			    struct drm_crtc *crtc,
-			    struct drm_display_mode *mode,
-			    struct drm_framebuffer *new_fb)
-{
-	struct vmw_screen_target_display_unit *stdu = vmw_crtc_to_stdu(crtc);
-	struct vmw_framebuffer *vfb = vmw_framebuffer_to_vfb(new_fb);
-	struct vmw_surface *new_display_srf = NULL;
-	enum stdu_content_type new_content_type;
-	struct vmw_framebuffer_surface *new_vfbs;
-	int ret;
-
-	WARN_ON_ONCE(!stdu->defined);
-
-	new_vfbs = (vfb->dmabuf) ? NULL : vmw_framebuffer_to_vfbs(new_fb);
-
-	if (new_vfbs && new_vfbs->surface->base_size.width == mode->hdisplay &&
-	    new_vfbs->surface->base_size.height == mode->vdisplay)
-		new_content_type = SAME_AS_DISPLAY;
-	else if (vfb->dmabuf)
-		new_content_type = SEPARATE_DMA;
-	else
-		new_content_type = SEPARATE_SURFACE;
-
-	if (new_content_type != SAME_AS_DISPLAY &&
-	    !stdu->display_srf) {
-		struct vmw_surface content_srf;
-		struct drm_vmw_size display_base_size = {0};
-
-		display_base_size.width  = mode->hdisplay;
-		display_base_size.height = mode->vdisplay;
-		display_base_size.depth  = 1;
-
-		/*
-		 * If content buffer is a DMA buf, then we have to construct
-		 * surface info
-		 */
-		if (new_content_type == SEPARATE_DMA) {
-
-			switch (new_fb->format->cpp[0] * 8) {
-			case 32:
-				content_srf.format = SVGA3D_X8R8G8B8;
-				break;
-
-			case 16:
-				content_srf.format = SVGA3D_R5G6B5;
-				break;
-
-			case 8:
-				content_srf.format = SVGA3D_P8;
-				break;
-
-			default:
-				DRM_ERROR("Invalid format\n");
-				return -EINVAL;
-			}
-
-			content_srf.flags             = 0;
-			content_srf.mip_levels[0]     = 1;
-			content_srf.multisample_count = 0;
-		} else {
-			content_srf = *new_vfbs->surface;
-		}
-
-
-		ret = vmw_surface_gb_priv_define(crtc->dev,
-				0, /* because kernel visible only */
-				content_srf.flags,
-				content_srf.format,
-				true, /* a scanout buffer */
-				content_srf.mip_levels[0],
-				content_srf.multisample_count,
-				0,
-				display_base_size,
-				&new_display_srf);
-		if (unlikely(ret != 0)) {
-			DRM_ERROR("Could not allocate screen target surface.\n");
-			return ret;
-		}
-	} else if (new_content_type == SAME_AS_DISPLAY) {
-		new_display_srf = vmw_surface_reference(new_vfbs->surface);
-	}
-
-	if (new_display_srf) {
-		/* Pin new surface before flipping */
-		ret = vmw_resource_pin(&new_display_srf->res, false);
-		if (ret)
-			goto out_srf_unref;
-
-		ret = vmw_stdu_bind_st(dev_priv, stdu, &new_display_srf->res);
-		if (ret)
-			goto out_srf_unpin;
-
-		/* Unpin and unreference old surface */
-		vmw_stdu_unpin_display(stdu);
-
-		/* Transfer the reference */
-		stdu->display_srf = new_display_srf;
-		new_display_srf = NULL;
-	}
-
-	crtc->primary->fb = new_fb;
-	stdu->content_fb_type = new_content_type;
-	return 0;
-
-out_srf_unpin:
-	vmw_resource_unpin(&new_display_srf->res);
-out_srf_unref:
-	vmw_surface_unreference(&new_display_srf);
-	return ret;
-}
-
 
 /**
  * vmw_stdu_crtc_mode_set_nofb - Updates screen target size
@@ -600,136 +450,6 @@ static void vmw_stdu_crtc_helper_disable(struct drm_crtc *crtc)
 	}
 }
 
-/**
- * vmw_stdu_crtc_set_config - Sets a mode
- *
- * @set:  mode parameters
- *
- * This function is the device-specific portion of the DRM CRTC mode set.
- * For the SVGA device, we do this by defining a Screen Target, binding a
- * GB Surface to that target, and finally update the screen target.
- *
- * RETURNS:
- * 0 on success, error code otherwise
- */
-static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
-{
-	struct vmw_private *dev_priv;
-	struct vmw_framebuffer *vfb;
-	struct vmw_screen_target_display_unit *stdu;
-	struct drm_display_mode *mode;
-	struct drm_framebuffer  *new_fb;
-	struct drm_crtc      *crtc;
-	struct drm_encoder   *encoder;
-	struct drm_connector *connector;
-	bool turning_off;
-	int    ret;
-
-
-	if (!set || !set->crtc)
-		return -EINVAL;
-
-	crtc     = set->crtc;
-	stdu     = vmw_crtc_to_stdu(crtc);
-	mode     = set->mode;
-	new_fb   = set->fb;
-	dev_priv = vmw_priv(crtc->dev);
-	turning_off = set->num_connectors == 0 || !mode || !new_fb;
-	vfb = (new_fb) ? vmw_framebuffer_to_vfb(new_fb) : NULL;
-
-	if (set->num_connectors > 1) {
-		DRM_ERROR("Too many connectors\n");
-		return -EINVAL;
-	}
-
-	if (set->num_connectors == 1 &&
-	    set->connectors[0] != &stdu->base.connector) {
-		DRM_ERROR("Connectors don't match %p %p\n",
-			set->connectors[0], &stdu->base.connector);
-		return -EINVAL;
-	}
-
-	if (!turning_off && (set->x + mode->hdisplay > new_fb->width ||
-			     set->y + mode->vdisplay > new_fb->height)) {
-		DRM_ERROR("Set outside of framebuffer\n");
-		return -EINVAL;
-	}
-
-	/* Only one active implicit frame-buffer at a time. */
-	mutex_lock(&dev_priv->global_kms_state_mutex);
-	if (!turning_off && stdu->base.is_implicit && dev_priv->implicit_fb &&
-	    !(dev_priv->num_implicit == 1 && stdu->base.active_implicit)
-	    && dev_priv->implicit_fb != vfb) {
-		mutex_unlock(&dev_priv->global_kms_state_mutex);
-		DRM_ERROR("Multiple implicit framebuffers not supported.\n");
-		return -EINVAL;
-	}
-	mutex_unlock(&dev_priv->global_kms_state_mutex);
-
-	/* Since they always map one to one these are safe */
-	connector = &stdu->base.connector;
-	encoder   = &stdu->base.encoder;
-
-	if (stdu->defined) {
-		ret = vmw_stdu_bind_st(dev_priv, stdu, NULL);
-		if (ret)
-			return ret;
-
-		vmw_stdu_unpin_display(stdu);
-		(void) vmw_stdu_update_st(dev_priv, stdu);
-		vmw_kms_del_active(dev_priv, &stdu->base);
-
-		ret = vmw_stdu_destroy_st(dev_priv, stdu);
-		if (ret)
-			return ret;
-
-		crtc->primary->fb = NULL;
-		crtc->enabled = false;
-		encoder->crtc = NULL;
-		connector->encoder = NULL;
-		stdu->content_fb_type = SAME_AS_DISPLAY;
-		crtc->x = set->x;
-		crtc->y = set->y;
-	}
-
-	if (turning_off)
-		return 0;
-
-	/*
-	 * Steps to displaying a surface, assume surface is already
-	 * bound:
-	 *   1.  define a screen target
-	 *   2.  bind a fb to the screen target
-	 *   3.  update that screen target (this is done later by
-	 *       vmw_kms_stdu_do_surface_dirty_or_present)
-	 */
-	/*
-	 * Note on error handling: We can't really restore the crtc to
-	 * it's original state on error, but we at least update the
-	 * current state to what's submitted to hardware to enable
-	 * future recovery.
-	 */
-	vmw_svga_enable(dev_priv);
-	ret = vmw_stdu_define_st(dev_priv, stdu, mode, set->x, set->y);
-	if (ret)
-		return ret;
-
-	crtc->x = set->x;
-	crtc->y = set->y;
-	crtc->mode = *mode;
-
-	ret = vmw_stdu_bind_fb(dev_priv, crtc, mode, new_fb);
-	if (ret)
-		return ret;
-
-	vmw_kms_add_active(dev_priv, &stdu->base, vfb);
-	crtc->enabled = true;
-	connector->encoder = encoder;
-	encoder->crtc      = crtc;
-
-	return 0;
-}
-
 /**
  * vmw_stdu_crtc_page_flip - Binds a buffer to a screen target
  *
@@ -756,9 +476,9 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 
 {
 	struct vmw_private *dev_priv = vmw_priv(crtc->dev);
-	struct vmw_screen_target_display_unit *stdu;
-	struct drm_vmw_rect vclips;
+	struct vmw_screen_target_display_unit *stdu = vmw_crtc_to_stdu(crtc);
 	struct vmw_framebuffer *vfb = vmw_framebuffer_to_vfb(new_fb);
+	struct drm_vmw_rect vclips;
 	int ret;
 
 	dev_priv          = vmw_priv(crtc->dev);
@@ -767,25 +487,42 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 	if (!stdu->defined || !vmw_kms_crtc_flippable(dev_priv, crtc))
 		return -EINVAL;
 
-	ret = vmw_stdu_bind_fb(dev_priv, crtc, &crtc->mode, new_fb);
-	if (ret)
+	/*
+	 * We're always async, but the helper doesn't know how to set async
+	 * so lie to the helper. Also, the helper expects someone
+	 * to pick the event up from the crtc state, and if nobody does,
+	 * it will free it. Since we handle the event in this function,
+	 * don't hand it to the helper.
+	 */
+	flags &= ~DRM_MODE_PAGE_FLIP_ASYNC;
+	ret = drm_atomic_helper_page_flip(crtc, new_fb, NULL, flags);
+	if (ret) {
+		DRM_ERROR("Page flip error %d.\n", ret);
 		return ret;
+	}
 
 	if (stdu->base.is_implicit)
 		vmw_kms_update_implicit_fb(dev_priv, crtc);
 
+	/*
+	 * Now that we've bound a new surface to the screen target,
+	 * update the contents.
+	 */
 	vclips.x = crtc->x;
 	vclips.y = crtc->y;
 	vclips.w = crtc->mode.hdisplay;
 	vclips.h = crtc->mode.vdisplay;
+
 	if (vfb->dmabuf)
 		ret = vmw_kms_stdu_dma(dev_priv, NULL, vfb, NULL, NULL, &vclips,
 				       1, 1, true, false);
 	else
 		ret = vmw_kms_stdu_surface_dirty(dev_priv, vfb, NULL, &vclips,
 						 NULL, 0, 0, 1, 1, NULL);
-	if (ret)
+	if (ret) {
+		DRM_ERROR("Page flip update error %d.\n", ret);
 		return ret;
+	}
 
 	if (event) {
 		struct vmw_fence_obj *fence = NULL;
@@ -802,7 +539,7 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 						   true);
 		vmw_fence_obj_unreference(&fence);
 	} else {
-		vmw_fifo_flush(dev_priv, false);
+		(void) vmw_fifo_flush(dev_priv, false);
 	}
 
 	return 0;
@@ -1123,7 +860,7 @@ static const struct drm_crtc_funcs vmw_stdu_crtc_funcs = {
 	.reset = vmw_du_crtc_reset,
 	.atomic_duplicate_state = vmw_du_crtc_duplicate_state,
 	.atomic_destroy_state = vmw_du_crtc_destroy_state,
-	.set_config = vmw_stdu_crtc_set_config,
+	.set_config = vmw_kms_set_config,
 	.page_flip = vmw_stdu_crtc_page_flip,
 };
 
@@ -1425,8 +1162,8 @@ vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
 
 
 static const struct drm_plane_funcs vmw_stdu_plane_funcs = {
-	.update_plane = drm_primary_helper_update,
-	.disable_plane = drm_primary_helper_disable,
+	.update_plane = drm_atomic_helper_update_plane,
+	.disable_plane = drm_atomic_helper_disable_plane,
 	.destroy = vmw_du_primary_plane_destroy,
 	.reset = vmw_du_plane_reset,
 	.atomic_duplicate_state = vmw_du_plane_duplicate_state,
@@ -1434,8 +1171,8 @@ static const struct drm_plane_funcs vmw_stdu_plane_funcs = {
 };
 
 static const struct drm_plane_funcs vmw_stdu_cursor_funcs = {
-	.update_plane = vmw_du_cursor_plane_update,
-	.disable_plane = vmw_du_cursor_plane_disable,
+	.update_plane = drm_atomic_helper_update_plane,
+	.disable_plane = drm_atomic_helper_disable_plane,
 	.destroy = vmw_du_cursor_plane_destroy,
 	.reset = vmw_du_plane_reset,
 	.atomic_duplicate_state = vmw_du_plane_duplicate_state,
@@ -1625,8 +1362,6 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
  */
 static void vmw_stdu_destroy(struct vmw_screen_target_display_unit *stdu)
 {
-	vmw_stdu_unpin_display(stdu);
-
 	vmw_du_cleanup(&stdu->base);
 	kfree(stdu);
 }

commit d947d1b71deb1efa0e7b2600f09e7fe7ea1e622b
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 14:23:20 2017 -0700

    drm/vmwgfx: Add and connect connector helper function
    
    These helpers won't be called until we flip on the atomic support
    flag or set drm_crtc_funcs->set_config to using the atomic
    helper.
    
    v2
    Use drm_atomic_helper_best_encoder() rather than a vmwgfx-specific one
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index cce5e5b02e20..76ca5fa1e3bf 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1189,6 +1189,12 @@ static const struct drm_connector_funcs vmw_stdu_connector_funcs = {
 };
 
 
+static const struct
+drm_connector_helper_funcs vmw_stdu_connector_helper_funcs = {
+	.best_encoder = drm_atomic_helper_best_encoder,
+};
+
+
 
 /******************************************************************************
  * Screen Target Display Plane Functions
@@ -1549,6 +1555,8 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 		DRM_ERROR("Failed to initialize connector\n");
 		goto err_free;
 	}
+
+	drm_connector_helper_add(connector, &vmw_stdu_connector_helper_funcs);
 	connector->status = vmw_du_connector_detect(connector, false);
 	vmw_connector_state_to_vcs(connector->state)->is_implicit = false;
 

commit 060e2ad57041b42ccecd0047ef4d893f200692c2
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 14:18:32 2017 -0700

    drm/vmwgfx: Add and connect plane helper functions
    
    Refactor previous FB and cursor plane update code into their
    atomic counterparts: check, update, prepare, cleanup, and disable.
    
    These helpers won't be called until we flip on the atomic support
    flag or set drm_crtc_funcs->set_config to using the atomic
    helper.
    
    v2:
    * Removed unnecessary pinning of cursor surface
    * Added a few function headers
    
    v3:
    * Set clip region equal to the destination region
    * Fixed surface pinning policy
    * Enable SVGA mode in vmw_sou_primary_plane_prepare_fb
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 6e3cfad336b0..cce5e5b02e20 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1194,6 +1194,230 @@ static const struct drm_connector_funcs vmw_stdu_connector_funcs = {
  * Screen Target Display Plane Functions
  *****************************************************************************/
 
+
+
+/**
+ * vmw_stdu_primary_plane_cleanup_fb - Unpins the display surface
+ *
+ * @plane:  display plane
+ * @old_state: Contains the FB to clean up
+ *
+ * Unpins the display surface
+ *
+ * Returns 0 on success
+ */
+static void
+vmw_stdu_primary_plane_cleanup_fb(struct drm_plane *plane,
+				  struct drm_plane_state *old_state)
+{
+	struct vmw_plane_state *vps = vmw_plane_state_to_vps(old_state);
+
+	if (vps->surf)
+		WARN_ON(!vps->pinned);
+
+	vmw_du_plane_cleanup_fb(plane, old_state);
+
+	vps->content_fb_type = SAME_AS_DISPLAY;
+}
+
+
+
+/**
+ * vmw_stdu_primary_plane_prepare_fb - Readies the display surface
+ *
+ * @plane:  display plane
+ * @new_state: info on the new plane state, including the FB
+ *
+ * This function allocates a new display surface if the content is
+ * backed by a DMA.  The display surface is pinned here, and it'll
+ * be unpinned in .cleanup_fb()
+ *
+ * Returns 0 on success
+ */
+static int
+vmw_stdu_primary_plane_prepare_fb(struct drm_plane *plane,
+				  struct drm_plane_state *new_state)
+{
+	struct drm_framebuffer *new_fb = new_state->fb;
+	struct vmw_framebuffer *vfb;
+	struct vmw_plane_state *vps = vmw_plane_state_to_vps(new_state);
+	enum stdu_content_type new_content_type;
+	struct vmw_framebuffer_surface *new_vfbs;
+	struct drm_crtc *crtc = new_state->crtc;
+	uint32_t hdisplay = new_state->crtc_w, vdisplay = new_state->crtc_h;
+	int ret;
+
+	/* No FB to prepare */
+	if (!new_fb) {
+		if (vps->surf) {
+			WARN_ON(vps->pinned != 0);
+			vmw_surface_unreference(&vps->surf);
+		}
+
+		return 0;
+	}
+
+	vfb = vmw_framebuffer_to_vfb(new_fb);
+	new_vfbs = (vfb->dmabuf) ? NULL : vmw_framebuffer_to_vfbs(new_fb);
+
+	if (new_vfbs && new_vfbs->surface->base_size.width == hdisplay &&
+	    new_vfbs->surface->base_size.height == vdisplay)
+		new_content_type = SAME_AS_DISPLAY;
+	else if (vfb->dmabuf)
+		new_content_type = SEPARATE_DMA;
+	else
+		new_content_type = SEPARATE_SURFACE;
+
+	if (new_content_type != SAME_AS_DISPLAY) {
+		struct vmw_surface content_srf;
+		struct drm_vmw_size display_base_size = {0};
+
+		display_base_size.width  = hdisplay;
+		display_base_size.height = vdisplay;
+		display_base_size.depth  = 1;
+
+		/*
+		 * If content buffer is a DMA buf, then we have to construct
+		 * surface info
+		 */
+		if (new_content_type == SEPARATE_DMA) {
+
+			switch (new_fb->format->cpp[0]*8) {
+			case 32:
+				content_srf.format = SVGA3D_X8R8G8B8;
+				break;
+
+			case 16:
+				content_srf.format = SVGA3D_R5G6B5;
+				break;
+
+			case 8:
+				content_srf.format = SVGA3D_P8;
+				break;
+
+			default:
+				DRM_ERROR("Invalid format\n");
+				return -EINVAL;
+			}
+
+			content_srf.flags             = 0;
+			content_srf.mip_levels[0]     = 1;
+			content_srf.multisample_count = 0;
+		} else {
+			content_srf = *new_vfbs->surface;
+		}
+
+		if (vps->surf) {
+			struct drm_vmw_size cur_base_size = vps->surf->base_size;
+
+			if (cur_base_size.width != display_base_size.width ||
+			    cur_base_size.height != display_base_size.height ||
+			    vps->surf->format != content_srf.format) {
+				WARN_ON(vps->pinned != 0);
+				vmw_surface_unreference(&vps->surf);
+			}
+
+		}
+
+		if (!vps->surf) {
+			ret = vmw_surface_gb_priv_define
+				(crtc->dev,
+				 /* Kernel visible only */
+				 0,
+				 content_srf.flags,
+				 content_srf.format,
+				 true,  /* a scanout buffer */
+				 content_srf.mip_levels[0],
+				 content_srf.multisample_count,
+				 0,
+				 display_base_size,
+				 &vps->surf);
+			if (ret != 0) {
+				DRM_ERROR("Couldn't allocate STDU surface.\n");
+				return ret;
+			}
+		}
+	} else {
+		/*
+		 * prepare_fb and clean_fb should only take care of pinning
+		 * and unpinning.  References are tracked by state objects.
+		 * The only time we add a reference in prepare_fb is if the
+		 * state object doesn't have a reference to begin with
+		 */
+		if (vps->surf) {
+			WARN_ON(vps->pinned != 0);
+			vmw_surface_unreference(&vps->surf);
+		}
+
+		vps->surf = vmw_surface_reference(new_vfbs->surface);
+	}
+
+	if (vps->surf) {
+
+		/* Pin new surface before flipping */
+		ret = vmw_resource_pin(&vps->surf->res, false);
+		if (ret)
+			goto out_srf_unref;
+
+		vps->pinned++;
+	}
+
+	vps->content_fb_type = new_content_type;
+	return 0;
+
+out_srf_unref:
+	vmw_surface_unreference(&vps->surf);
+	return ret;
+}
+
+
+
+/**
+ * vmw_stdu_primary_plane_atomic_update - formally switches STDU to new plane
+ *
+ * @plane: display plane
+ * @old_state: Only used to get crtc info
+ *
+ * Formally update stdu->display_srf to the new plane, and bind the new
+ * plane STDU.  This function is called during the commit phase when
+ * all the preparation have been done and all the configurations have
+ * been checked.
+ */
+static void
+vmw_stdu_primary_plane_atomic_update(struct drm_plane *plane,
+				     struct drm_plane_state *old_state)
+{
+	struct vmw_private *dev_priv;
+	struct vmw_screen_target_display_unit *stdu;
+	struct vmw_plane_state *vps = vmw_plane_state_to_vps(plane->state);
+	struct drm_crtc *crtc = plane->state->crtc ?: old_state->crtc;
+	int ret;
+
+	stdu     = vmw_crtc_to_stdu(crtc);
+	dev_priv = vmw_priv(crtc->dev);
+
+	stdu->display_srf = vps->surf;
+	stdu->content_fb_type = vps->content_fb_type;
+
+	if (!stdu->defined)
+		return;
+
+	if (plane->state->fb)
+		ret = vmw_stdu_bind_st(dev_priv, stdu, &stdu->display_srf->res);
+	else
+		ret = vmw_stdu_bind_st(dev_priv, stdu, NULL);
+
+	/*
+	 * We cannot really fail this function, so if we do, then output an
+	 * error and quit
+	 */
+	if (ret)
+		DRM_ERROR("Failed to bind surface to STDU.\n");
+	else
+		crtc->primary->fb = plane->state->fb;
+}
+
+
 static const struct drm_plane_funcs vmw_stdu_plane_funcs = {
 	.update_plane = drm_primary_helper_update,
 	.disable_plane = drm_primary_helper_disable,
@@ -1216,6 +1440,22 @@ static const struct drm_plane_funcs vmw_stdu_cursor_funcs = {
 /*
  * Atomic Helpers
  */
+static const struct
+drm_plane_helper_funcs vmw_stdu_cursor_plane_helper_funcs = {
+	.atomic_check = vmw_du_cursor_plane_atomic_check,
+	.atomic_update = vmw_du_cursor_plane_atomic_update,
+	.prepare_fb = vmw_du_cursor_plane_prepare_fb,
+	.cleanup_fb = vmw_du_plane_cleanup_fb,
+};
+
+static const struct
+drm_plane_helper_funcs vmw_stdu_primary_plane_helper_funcs = {
+	.atomic_check = vmw_du_primary_plane_atomic_check,
+	.atomic_update = vmw_stdu_primary_plane_atomic_update,
+	.prepare_fb = vmw_stdu_primary_plane_prepare_fb,
+	.cleanup_fb = vmw_stdu_primary_plane_cleanup_fb,
+};
+
 static const struct drm_crtc_helper_funcs vmw_stdu_crtc_helper_funcs = {
 	.prepare = vmw_stdu_crtc_helper_prepare,
 	.commit = vmw_stdu_crtc_helper_commit,
@@ -1283,6 +1523,8 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 		goto err_free;
 	}
 
+	drm_plane_helper_add(primary, &vmw_stdu_primary_plane_helper_funcs);
+
 	/* Initialize cursor plane */
 	vmw_du_plane_reset(cursor);
 
@@ -1297,6 +1539,8 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 		goto err_free;
 	}
 
+	drm_plane_helper_add(cursor, &vmw_stdu_cursor_plane_helper_funcs);
+
 	vmw_du_connector_reset(connector);
 
 	ret = drm_connector_init(dev, connector, &vmw_stdu_connector_funcs,

commit 06ec41909e31be3347f8679e9667d12ac6f7ee6e
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 13:14:54 2017 -0700

    drm/vmwgfx: Add and connect CRTC helper functions
    
    Atomic mode set requires us to refactor existing vmw_stdu_crtc_set_config
    code into sections that check the validity of the new mode, and sections
    that actually program the hardware state.
    
    vmw_du_crtc_atomic_check() takes CRTC-related checking code.  In a later
    patch, vmw_du_primary_plane_atomic_check() will take framebuffer-related
    checking code.
    
    These helpers won't be called until we flip on the atomic support
    flag or set drm_crtc_funcs->set_config to using the atomic
    helper.
    
    v2:
    * The state->num_connector is actually the total number of potential
      connectors, not just the one associated with the display unit.
      The proper one to check is ->connector_mask.
    
    * Add the check to only allow plane state to be the same as crtc state
      (Thanks to mlankhorst)
    
    * Make sure to turn on SVGA mode before using VRAM.  SVGA mode is
      disabled in master_drop if dbdev is not running.
    
    v3:
    * Moved dot clock override to crtc_atomic_check
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index b1fae4975247..6e3cfad336b0 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -500,6 +500,106 @@ static int vmw_stdu_bind_fb(struct vmw_private *dev_priv,
 	return ret;
 }
 
+
+/**
+ * vmw_stdu_crtc_mode_set_nofb - Updates screen target size
+ *
+ * @crtc: CRTC associated with the screen target
+ *
+ * This function defines/destroys a screen target
+ *
+ */
+static void vmw_stdu_crtc_mode_set_nofb(struct drm_crtc *crtc)
+{
+	struct vmw_private *dev_priv;
+	struct vmw_screen_target_display_unit *stdu;
+	int ret;
+
+
+	stdu     = vmw_crtc_to_stdu(crtc);
+	dev_priv = vmw_priv(crtc->dev);
+
+	if (stdu->defined) {
+		ret = vmw_stdu_bind_st(dev_priv, stdu, NULL);
+		if (ret)
+			DRM_ERROR("Failed to blank CRTC\n");
+
+		(void) vmw_stdu_update_st(dev_priv, stdu);
+
+		ret = vmw_stdu_destroy_st(dev_priv, stdu);
+		if (ret)
+			DRM_ERROR("Failed to destroy Screen Target\n");
+
+		stdu->content_fb_type = SAME_AS_DISPLAY;
+	}
+
+	if (!crtc->state->enable)
+		return;
+
+	vmw_svga_enable(dev_priv);
+	ret = vmw_stdu_define_st(dev_priv, stdu, &crtc->mode, crtc->x, crtc->y);
+
+	if (ret)
+		DRM_ERROR("Failed to define Screen Target of size %dx%d\n",
+			  crtc->x, crtc->y);
+}
+
+
+static void vmw_stdu_crtc_helper_prepare(struct drm_crtc *crtc)
+{
+}
+
+
+static void vmw_stdu_crtc_helper_commit(struct drm_crtc *crtc)
+{
+	struct vmw_private *dev_priv;
+	struct vmw_screen_target_display_unit *stdu;
+	struct vmw_framebuffer *vfb;
+	struct drm_framebuffer *fb;
+
+
+	stdu     = vmw_crtc_to_stdu(crtc);
+	dev_priv = vmw_priv(crtc->dev);
+	fb       = crtc->primary->fb;
+
+	vfb = (fb) ? vmw_framebuffer_to_vfb(fb) : NULL;
+
+	if (vfb)
+		vmw_kms_add_active(dev_priv, &stdu->base, vfb);
+	else
+		vmw_kms_del_active(dev_priv, &stdu->base);
+}
+
+static void vmw_stdu_crtc_helper_disable(struct drm_crtc *crtc)
+{
+	struct vmw_private *dev_priv;
+	struct vmw_screen_target_display_unit *stdu;
+	int ret;
+
+
+	if (!crtc) {
+		DRM_ERROR("CRTC is NULL\n");
+		return;
+	}
+
+	stdu     = vmw_crtc_to_stdu(crtc);
+	dev_priv = vmw_priv(crtc->dev);
+
+	if (stdu->defined) {
+		ret = vmw_stdu_bind_st(dev_priv, stdu, NULL);
+		if (ret)
+			DRM_ERROR("Failed to blank CRTC\n");
+
+		(void) vmw_stdu_update_st(dev_priv, stdu);
+
+		ret = vmw_stdu_destroy_st(dev_priv, stdu);
+		if (ret)
+			DRM_ERROR("Failed to destroy Screen Target\n");
+
+		stdu->content_fb_type = SAME_AS_DISPLAY;
+	}
+}
+
 /**
  * vmw_stdu_crtc_set_config - Sets a mode
  *
@@ -1113,6 +1213,21 @@ static const struct drm_plane_funcs vmw_stdu_cursor_funcs = {
 };
 
 
+/*
+ * Atomic Helpers
+ */
+static const struct drm_crtc_helper_funcs vmw_stdu_crtc_helper_funcs = {
+	.prepare = vmw_stdu_crtc_helper_prepare,
+	.commit = vmw_stdu_crtc_helper_commit,
+	.disable = vmw_stdu_crtc_helper_disable,
+	.mode_set = drm_helper_crtc_mode_set,
+	.mode_set_nofb = vmw_stdu_crtc_mode_set_nofb,
+	.atomic_check = vmw_du_crtc_atomic_check,
+	.atomic_begin = vmw_du_crtc_atomic_begin,
+	.atomic_flush = vmw_du_crtc_atomic_flush,
+};
+
+
 /**
  * vmw_stdu_init - Sets up a Screen Target Display Unit
  *
@@ -1219,6 +1334,8 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 		goto err_free_unregister;
 	}
 
+	drm_crtc_helper_add(crtc, &vmw_stdu_crtc_helper_funcs);
+
 	drm_mode_crtc_set_gamma_size(crtc, 256);
 
 	drm_object_attach_property(&connector->base,

commit d7721ca71126b222fb5d66af444d33950a0e3ba3
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 11:48:44 2017 -0700

    drm/vmwgfx: Connector atomic state
    
    Add connector handling functions. Start tracking is_implicity in
    the connector state.  Eventually, this field should be tracked
    exclusively in a connector state.
    
    Now that plane and connector states have been created, we can also
    activate the code that use CRTC state.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 2a0f550235c0..b1fae4975247 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -28,6 +28,9 @@
 #include "vmwgfx_kms.h"
 #include "device_include/svga3d_surfacedefs.h"
 #include <drm/drm_plane_helper.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+
 
 #define vmw_crtc_to_stdu(x) \
 	container_of(x, struct vmw_screen_target_display_unit, base.crtc)
@@ -1078,6 +1081,11 @@ static const struct drm_connector_funcs vmw_stdu_connector_funcs = {
 	.fill_modes = vmw_du_connector_fill_modes,
 	.set_property = vmw_du_connector_set_property,
 	.destroy = vmw_stdu_connector_destroy,
+	.reset = vmw_du_connector_reset,
+	.atomic_duplicate_state = vmw_du_connector_duplicate_state,
+	.atomic_destroy_state = vmw_du_connector_destroy_state,
+	.atomic_set_property = vmw_du_connector_atomic_set_property,
+	.atomic_get_property = vmw_du_connector_atomic_get_property,
 };
 
 
@@ -1174,6 +1182,8 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 		goto err_free;
 	}
 
+	vmw_du_connector_reset(connector);
+
 	ret = drm_connector_init(dev, connector, &vmw_stdu_connector_funcs,
 				 DRM_MODE_CONNECTOR_VIRTUAL);
 	if (ret) {
@@ -1181,6 +1191,7 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 		goto err_free;
 	}
 	connector->status = vmw_du_connector_detect(connector, false);
+	vmw_connector_state_to_vcs(connector->state)->is_implicit = false;
 
 	ret = drm_encoder_init(dev, encoder, &vmw_stdu_encoder_funcs,
 			       DRM_MODE_ENCODER_VIRTUAL, NULL);
@@ -1199,8 +1210,7 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 		goto err_free_encoder;
 	}
 
-	/* FIXME: Turn on after plane/connector states are implemented. */
-	/* vmw_du_crtc_reset(crtc); */
+	vmw_du_crtc_reset(crtc);
 	ret = drm_crtc_init_with_planes(dev, crtc, &stdu->base.primary,
 					&stdu->base.cursor,
 					&vmw_stdu_crtc_funcs, NULL);

commit cc5ec459de323fe32514d5f47a4d00460ee30f7b
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 11:36:05 2017 -0700

    drm/vmwgfx: Plane atomic state
    
    Add plane state handling functions.
    
    We have to keep track of a few plane states so we cannot use the
    DRM helper for this.
    
    Created vmw_plane_state along with functions to reset, duplicate,
    and destroty it.
    
    v2
    * Removed cursor clean up special case
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Acked-by: Daniel Vetter <daniel@ffwll.ch>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 3b8fafe1586e..2a0f550235c0 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1090,12 +1090,18 @@ static const struct drm_plane_funcs vmw_stdu_plane_funcs = {
 	.update_plane = drm_primary_helper_update,
 	.disable_plane = drm_primary_helper_disable,
 	.destroy = vmw_du_primary_plane_destroy,
+	.reset = vmw_du_plane_reset,
+	.atomic_duplicate_state = vmw_du_plane_duplicate_state,
+	.atomic_destroy_state = vmw_du_plane_destroy_state,
 };
 
 static const struct drm_plane_funcs vmw_stdu_cursor_funcs = {
 	.update_plane = vmw_du_cursor_plane_update,
 	.disable_plane = vmw_du_cursor_plane_disable,
 	.destroy = vmw_du_cursor_plane_destroy,
+	.reset = vmw_du_plane_reset,
+	.atomic_duplicate_state = vmw_du_plane_duplicate_state,
+	.atomic_destroy_state = vmw_du_plane_destroy_state,
 };
 
 
@@ -1142,6 +1148,8 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 	stdu->base.is_implicit = false;
 
 	/* Initialize primary plane */
+	vmw_du_plane_reset(primary);
+
 	ret = drm_universal_plane_init(dev, primary,
 				       0, &vmw_stdu_plane_funcs,
 				       vmw_primary_plane_formats,
@@ -1153,6 +1161,8 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 	}
 
 	/* Initialize cursor plane */
+	vmw_du_plane_reset(cursor);
+
 	ret = drm_universal_plane_init(dev, cursor,
 			0, &vmw_stdu_cursor_funcs,
 			vmw_cursor_plane_formats,

commit 9c2542a41f559452d570b96239a81038c49becfc
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 11:33:39 2017 -0700

    drm/vmwgfx: CRTC atomic state
    
    Create and Add CRTC state.  We currently do not track any properties
    or custom states so we can technically use the DRM helpers.  Creating
    this code just to make potential future additions easier.
    
    Most of the new code will be compiled but not enabled until
    plane/connector state handling code is also in place.
    
    This is the first of a series to enable atomic mode set for vmwgfx.
    
    The atomic enabling effort was done in collaboration with Thomas
    Hellstrom and the VMware Graphics Team.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 4d9dd1b67b93..3b8fafe1586e 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1017,6 +1017,9 @@ int vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,
 static const struct drm_crtc_funcs vmw_stdu_crtc_funcs = {
 	.gamma_set = vmw_du_crtc_gamma_set,
 	.destroy = vmw_stdu_crtc_destroy,
+	.reset = vmw_du_crtc_reset,
+	.atomic_duplicate_state = vmw_du_crtc_duplicate_state,
+	.atomic_destroy_state = vmw_du_crtc_destroy_state,
 	.set_config = vmw_stdu_crtc_set_config,
 	.page_flip = vmw_stdu_crtc_page_flip,
 };
@@ -1131,6 +1134,11 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 	stdu->base.pref_active = (unit == 0);
 	stdu->base.pref_width  = dev_priv->initial_width;
 	stdu->base.pref_height = dev_priv->initial_height;
+
+	/*
+	 * Remove this after enabling atomic because property values can
+	 * only exist in a state object
+	 */
 	stdu->base.is_implicit = false;
 
 	/* Initialize primary plane */
@@ -1181,6 +1189,8 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 		goto err_free_encoder;
 	}
 
+	/* FIXME: Turn on after plane/connector states are implemented. */
+	/* vmw_du_crtc_reset(crtc); */
 	ret = drm_crtc_init_with_planes(dev, crtc, &stdu->base.primary,
 					&stdu->base.cursor,
 					&vmw_stdu_crtc_funcs, NULL);

commit 36cc79bc9077319c04bd3b132edcacaa9a0d9f2b
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Thu Mar 23 11:28:11 2017 -0700

    drm/vmwgfx: Add universal plane support
    
    Universal support is prerequisite for atomic mode set.
    
    Explicitly create planes for the cursor and the primary FB.  With
    a functional cursor plane, the DRM will no longer use the legacy
    cursor_set2 and cursor_move entry points.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index b27cd18ee66a..4d9dd1b67b93 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1015,8 +1015,6 @@ int vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,
  *  Screen Target CRTC dispatch table
  */
 static const struct drm_crtc_funcs vmw_stdu_crtc_funcs = {
-	.cursor_set2 = vmw_du_crtc_cursor_set2,
-	.cursor_move = vmw_du_crtc_cursor_move,
 	.gamma_set = vmw_du_crtc_gamma_set,
 	.destroy = vmw_stdu_crtc_destroy,
 	.set_config = vmw_stdu_crtc_set_config,
@@ -1081,6 +1079,23 @@ static const struct drm_connector_funcs vmw_stdu_connector_funcs = {
 
 
 
+/******************************************************************************
+ * Screen Target Display Plane Functions
+ *****************************************************************************/
+
+static const struct drm_plane_funcs vmw_stdu_plane_funcs = {
+	.update_plane = drm_primary_helper_update,
+	.disable_plane = drm_primary_helper_disable,
+	.destroy = vmw_du_primary_plane_destroy,
+};
+
+static const struct drm_plane_funcs vmw_stdu_cursor_funcs = {
+	.update_plane = vmw_du_cursor_plane_update,
+	.disable_plane = vmw_du_cursor_plane_disable,
+	.destroy = vmw_du_cursor_plane_destroy,
+};
+
+
 /**
  * vmw_stdu_init - Sets up a Screen Target Display Unit
  *
@@ -1097,7 +1112,9 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 	struct drm_device *dev = dev_priv->dev;
 	struct drm_connector *connector;
 	struct drm_encoder *encoder;
+	struct drm_plane *primary, *cursor;
 	struct drm_crtc *crtc;
+	int    ret;
 
 
 	stdu = kzalloc(sizeof(*stdu), GFP_KERNEL);
@@ -1108,25 +1125,69 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 	crtc = &stdu->base.crtc;
 	encoder = &stdu->base.encoder;
 	connector = &stdu->base.connector;
+	primary = &stdu->base.primary;
+	cursor = &stdu->base.cursor;
 
 	stdu->base.pref_active = (unit == 0);
 	stdu->base.pref_width  = dev_priv->initial_width;
 	stdu->base.pref_height = dev_priv->initial_height;
 	stdu->base.is_implicit = false;
 
-	drm_connector_init(dev, connector, &vmw_stdu_connector_funcs,
-			   DRM_MODE_CONNECTOR_VIRTUAL);
+	/* Initialize primary plane */
+	ret = drm_universal_plane_init(dev, primary,
+				       0, &vmw_stdu_plane_funcs,
+				       vmw_primary_plane_formats,
+				       ARRAY_SIZE(vmw_primary_plane_formats),
+				       DRM_PLANE_TYPE_PRIMARY, NULL);
+	if (ret) {
+		DRM_ERROR("Failed to initialize primary plane");
+		goto err_free;
+	}
+
+	/* Initialize cursor plane */
+	ret = drm_universal_plane_init(dev, cursor,
+			0, &vmw_stdu_cursor_funcs,
+			vmw_cursor_plane_formats,
+			ARRAY_SIZE(vmw_cursor_plane_formats),
+			DRM_PLANE_TYPE_CURSOR, NULL);
+	if (ret) {
+		DRM_ERROR("Failed to initialize cursor plane");
+		drm_plane_cleanup(&stdu->base.primary);
+		goto err_free;
+	}
+
+	ret = drm_connector_init(dev, connector, &vmw_stdu_connector_funcs,
+				 DRM_MODE_CONNECTOR_VIRTUAL);
+	if (ret) {
+		DRM_ERROR("Failed to initialize connector\n");
+		goto err_free;
+	}
 	connector->status = vmw_du_connector_detect(connector, false);
 
-	drm_encoder_init(dev, encoder, &vmw_stdu_encoder_funcs,
-			 DRM_MODE_ENCODER_VIRTUAL, NULL);
-	drm_mode_connector_attach_encoder(connector, encoder);
+	ret = drm_encoder_init(dev, encoder, &vmw_stdu_encoder_funcs,
+			       DRM_MODE_ENCODER_VIRTUAL, NULL);
+	if (ret) {
+		DRM_ERROR("Failed to initialize encoder\n");
+		goto err_free_connector;
+	}
+
+	(void) drm_mode_connector_attach_encoder(connector, encoder);
 	encoder->possible_crtcs = (1 << unit);
 	encoder->possible_clones = 0;
 
-	(void) drm_connector_register(connector);
+	ret = drm_connector_register(connector);
+	if (ret) {
+		DRM_ERROR("Failed to register connector\n");
+		goto err_free_encoder;
+	}
 
-	drm_crtc_init(dev, crtc, &vmw_stdu_crtc_funcs);
+	ret = drm_crtc_init_with_planes(dev, crtc, &stdu->base.primary,
+					&stdu->base.cursor,
+					&vmw_stdu_crtc_funcs, NULL);
+	if (ret) {
+		DRM_ERROR("Failed to initialize CRTC\n");
+		goto err_free_unregister;
+	}
 
 	drm_mode_crtc_set_gamma_size(crtc, 256);
 
@@ -1142,6 +1203,16 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 			 dev_priv->implicit_placement_property,
 			 stdu->base.is_implicit);
 	return 0;
+
+err_free_unregister:
+	drm_connector_unregister(connector);
+err_free_encoder:
+	drm_encoder_cleanup(encoder);
+err_free_connector:
+	drm_connector_cleanup(connector);
+err_free:
+	kfree(stdu);
+	return ret;
 }
 
 

commit a4eff9aa6db8eb3d1864118f3558214b26f630b4
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 22 22:50:57 2017 +0100

    drm: Add acquire ctx parameter to ->set_config
    
    Surprisingly a lot of legacy drivers roll their own, for
    runtime pm and because vmwgfx.
    
    Also make nouveau's set_config static while at it.
    
    Cc: Sinclair Yeh <syeh@vmware.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Christian König <christian.koenig@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170322215058.8671-19-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 85e12309cb71..b2c9d6ce7ce4 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -509,7 +509,8 @@ static int vmw_stdu_bind_fb(struct vmw_private *dev_priv,
  * RETURNS:
  * 0 on success, error code otherwise
  */
-static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
+static int vmw_stdu_crtc_set_config(struct drm_mode_set *set,
+				    struct drm_modeset_acquire_ctx *ctx)
 {
 	struct vmw_private *dev_priv;
 	struct vmw_framebuffer *vfb;

commit 41292b1fa13a894c1108d4a1c7f8a59fbb307aa6
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 22 22:50:50 2017 +0100

    drm: Add acquire ctx parameter to ->page_flip(_target)
    
    Again just going through the motions, no functional changes in here.
    
    Cc: Gerd Hoffmann <kraxel@redhat.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Eric Anholt <eric@anholt.net>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Christian König <christian.koenig@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>t
    Link: http://patchwork.freedesktop.org/patch/msgid/20170322215058.8671-12-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index b27cd18ee66a..85e12309cb71 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -649,7 +649,8 @@ static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
 static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 				   struct drm_framebuffer *new_fb,
 				   struct drm_pending_vblank_event *event,
-				   uint32_t flags)
+				   uint32_t flags,
+				   struct drm_modeset_acquire_ctx *ctx)
 
 {
 	struct vmw_private *dev_priv = vmw_priv(crtc->dev);

commit 272725c7db4da1fd3229d944fc76d2e98e3a144e
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 14 23:32:20 2016 +0200

    drm: Nuke fb->bits_per_pixel
    
    Replace uses of fb->bits_per_pixel with fb->format->cpp[0]*8.
    Less duplicated information is a good thing.
    
    Note that I didn't put parens around the cpp*8 in the below cocci script,
    on account of not wanting spurious parens all over the place. Instead I
    did the unsafe way, and tried to look over the entire diff to spot if
    any dangerous expressions were produced. I didn't see any.
    
    There are some cases where previously the code did X*bpp/8, so the
    division happened after the multiplication. Those are now just X*cpp
    so the division effectively happens before the multiplication,
    but that is perfectly fine since bpp is always a multiple of 8.
    
    @@
    struct drm_framebuffer *FB;
    expression E;
    @@
     drm_helper_mode_fill_fb_struct(...) {
            ...
    -       FB->bits_per_pixel = E;
            ...
     }
    
    @@
    struct drm_framebuffer *FB;
    expression E;
    @@
     i9xx_get_initial_plane_config(...) {
            ...
    -       FB->bits_per_pixel = E;
            ...
     }
    
    @@
    struct drm_framebuffer *FB;
    expression E;
    @@
     ironlake_get_initial_plane_config(...) {
            ...
    -       FB->bits_per_pixel = E;
            ...
     }
    
    @@
    struct drm_framebuffer *FB;
    expression E;
    @@
     skylake_get_initial_plane_config(...) {
            ...
    -       FB->bits_per_pixel = E;
            ...
     }
    
    @@
    struct drm_framebuffer FB;
    expression E;
    @@
    (
    - E * FB.bits_per_pixel / 8
    + E * FB.format->cpp[0]
    |
    - FB.bits_per_pixel / 8
    + FB.format->cpp[0]
    |
    - E * FB.bits_per_pixel >> 3
    + E * FB.format->cpp[0]
    |
    - FB.bits_per_pixel >> 3
    + FB.format->cpp[0]
    |
    - (FB.bits_per_pixel + 7) / 8
    + FB.format->cpp[0]
    |
    - FB.bits_per_pixel
    + FB.format->cpp[0] * 8
    |
    - FB.format->cpp[0] * 8 != 8
    + FB.format->cpp[0] != 1
    )
    
    @@
    struct drm_framebuffer *FB;
    expression E;
    @@
    (
    - E * FB->bits_per_pixel / 8
    + E * FB->format->cpp[0]
    |
    - FB->bits_per_pixel / 8
    + FB->format->cpp[0]
    |
    - E * FB->bits_per_pixel >> 3
    + E * FB->format->cpp[0]
    |
    - FB->bits_per_pixel >> 3
    + FB->format->cpp[0]
    |
    - (FB->bits_per_pixel + 7) / 8
    + FB->format->cpp[0]
    |
    - FB->bits_per_pixel
    + FB->format->cpp[0] * 8
    |
    - FB->format->cpp[0] * 8 != 8
    + FB->format->cpp[0] != 1
    )
    
    @@
    struct drm_plane_state *state;
    expression E;
    @@
    (
    - E * state->fb->bits_per_pixel / 8
    + E * state->fb->format->cpp[0]
    |
    - state->fb->bits_per_pixel / 8
    + state->fb->format->cpp[0]
    |
    - E * state->fb->bits_per_pixel >> 3
    + E * state->fb->format->cpp[0]
    |
    - state->fb->bits_per_pixel >> 3
    + state->fb->format->cpp[0]
    |
    - (state->fb->bits_per_pixel + 7) / 8
    + state->fb->format->cpp[0]
    |
    - state->fb->bits_per_pixel
    + state->fb->format->cpp[0] * 8
    |
    - state->fb->format->cpp[0] * 8 != 8
    + state->fb->format->cpp[0] != 1
    )
    
    @@
    @@
    - (8 * 8)
    + 8 * 8
    
    @@
    struct drm_framebuffer FB;
    @@
    - (FB.format->cpp[0])
    + FB.format->cpp[0]
    
    @@
    struct drm_framebuffer *FB;
    @@
    - (FB->format->cpp[0])
    + FB->format->cpp[0]
    
    @@
    @@
     struct drm_framebuffer {
             ...
    -        int bits_per_pixel;
             ...
     };
    
    v2: Clean up the 'cpp*8 != 8' and '(8 * 8)' cases (Laurent)
    v3: Adjusted the semantic patch a bit and regenerated due to code
        changes
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com> (v1)
    Link: http://patchwork.freedesktop.org/patch/msgid/1481751140-18352-1-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 94ad8d2acf9a..b27cd18ee66a 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -424,7 +424,7 @@ static int vmw_stdu_bind_fb(struct vmw_private *dev_priv,
 		 */
 		if (new_content_type == SEPARATE_DMA) {
 
-			switch (new_fb->bits_per_pixel) {
+			switch (new_fb->format->cpp[0] * 8) {
 			case 32:
 				content_srf.format = SVGA3D_X8R8G8B8;
 				break;

commit 6ab10b76ff6252bd9be0849c40f5865e39a29961
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Aug 12 22:48:45 2016 +0200

    drm/kms: Nuke dirty_info property
    
    It was added way back together with the dirty_fb ioctl, but neither
    generic xfree86-modesetting nor the vmware driver use it. Everyone is
    supposed to just unconditionally call the dirtyfb when they do
    frontbuffer rendering.
    
    And since unused uabi is bad uabi (there's reasons we require open
    source userspace for everything) let's nuke this.
    
    For reference see
    
    commit 884840aa3ce3214259e69557be5b4ce0d781ffa4
    Author: Jakob Bornecrantz <jakob@vmware.com>
    Date:   Thu Dec 3 23:25:47 2009 +0000
    
        drm: Add dirty ioctl and property
    
    Cc: Jakob Bornecrantz <jakob@vmware.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Sinclair Yeh <syeh@vmware.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Acked-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1471034937-651-9-git-send-email-daniel.vetter@ffwll.ch

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 41932a7c4f79..94ad8d2acf9a 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1130,9 +1130,6 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 
 	drm_mode_crtc_set_gamma_size(crtc, 256);
 
-	drm_object_attach_property(&connector->base,
-				   dev->mode_config.dirty_info_property,
-				   1);
 	drm_object_attach_property(&connector->base,
 				   dev_priv->hotplug_mode_update_property, 1);
 	drm_object_attach_property(&connector->base,
@@ -1202,10 +1199,6 @@ int vmw_kms_stdu_init_display(struct vmw_private *dev_priv)
 	if (unlikely(ret != 0))
 		return ret;
 
-	ret = drm_mode_create_dirty_info_property(dev);
-	if (unlikely(ret != 0))
-		goto err_vblank_cleanup;
-
 	dev_priv->active_display_unit = vmw_du_screen_target;
 
 	vmw_kms_create_implicit_placement_property(dev_priv, false);

commit beca4cf55323147ca9c8a98de1871be6e4fe8f34
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Wed Jun 29 13:37:35 2016 -0700

    drm/vmwgfx: Fix corner case screen target management
    
    When the surface backing a framebuffer doesn't match the framebuffer's
    dimensions, the screen target code would test the framebuffer dimensions
    rather than the surface dimensions when deciding whether to bind the
    surface as a screen target directly. This causes a screen target -
    surface dimension mismatch and a subsequent device error.
    
    Fix this by testing against the surface dimension.
    
    v2: Fix review comments by Sinclair Yeh.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Cc: <stable@vger.kernel.org>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 9ca818fb034c..41932a7c4f79 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -399,8 +399,10 @@ static int vmw_stdu_bind_fb(struct vmw_private *dev_priv,
 
 	WARN_ON_ONCE(!stdu->defined);
 
-	if (!vfb->dmabuf && new_fb->width == mode->hdisplay &&
-	    new_fb->height == mode->vdisplay)
+	new_vfbs = (vfb->dmabuf) ? NULL : vmw_framebuffer_to_vfbs(new_fb);
+
+	if (new_vfbs && new_vfbs->surface->base_size.width == mode->hdisplay &&
+	    new_vfbs->surface->base_size.height == mode->vdisplay)
 		new_content_type = SAME_AS_DISPLAY;
 	else if (vfb->dmabuf)
 		new_content_type = SEPARATE_DMA;
@@ -444,7 +446,6 @@ static int vmw_stdu_bind_fb(struct vmw_private *dev_priv,
 			content_srf.mip_levels[0]     = 1;
 			content_srf.multisample_count = 0;
 		} else {
-			new_vfbs = vmw_framebuffer_to_vfbs(new_fb);
 			content_srf = *new_vfbs->surface;
 		}
 
@@ -464,7 +465,6 @@ static int vmw_stdu_bind_fb(struct vmw_private *dev_priv,
 			return ret;
 		}
 	} else if (new_content_type == SAME_AS_DISPLAY) {
-		new_vfbs = vmw_framebuffer_to_vfbs(new_fb);
 		new_display_srf = vmw_surface_reference(new_vfbs->surface);
 	}
 

commit 93cd16817ae5ddcfc548784b51c76bf6d7923442
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Tue May 3 11:24:35 2016 +0200

    drm/vmwgfx: Kill some lockdep warnings
    
    Some global KMS state that is elsewhere protected by the mode_config
    mutex here needs to be protected with a local mutex. Remove corresponding
    lockdep checks and introduce a new driver-private global_kms_state_mutex,
    and make sure its locking order is *after* the crtc locks in order to
    avoid having to release those when the new mutex is taken.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Brian Paul <brianp@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>
    Cc: <stable@vger.kernel.org> # 4.6

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index b949102ad864..9ca818fb034c 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -553,12 +553,15 @@ static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
 	}
 
 	/* Only one active implicit frame-buffer at a time. */
+	mutex_lock(&dev_priv->global_kms_state_mutex);
 	if (!turning_off && stdu->base.is_implicit && dev_priv->implicit_fb &&
 	    !(dev_priv->num_implicit == 1 && stdu->base.active_implicit)
 	    && dev_priv->implicit_fb != vfb) {
+		mutex_unlock(&dev_priv->global_kms_state_mutex);
 		DRM_ERROR("Multiple implicit framebuffers not supported.\n");
 		return -EINVAL;
 	}
+	mutex_unlock(&dev_priv->global_kms_state_mutex);
 
 	/* Since they always map one to one these are safe */
 	connector = &stdu->base.connector;

commit 2e69b25bb12cfd32250684b600652589d823a96c
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Fri Feb 12 09:59:50 2016 +0100

    drm/vmwgfx: Default to explicit crtc placement for screen targets and screen objects
    
    Enables using multiple framebuffers. For legacy display units,
    explicit crtc placement is not supported due to hardware limitations.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index fe42a2cefb86..b949102ad864 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1109,7 +1109,7 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 	stdu->base.pref_active = (unit == 0);
 	stdu->base.pref_width  = dev_priv->initial_width;
 	stdu->base.pref_height = dev_priv->initial_height;
-	stdu->base.is_implicit = true;
+	stdu->base.is_implicit = false;
 
 	drm_connector_init(dev, connector, &vmw_stdu_connector_funcs,
 			   DRM_MODE_CONNECTOR_VIRTUAL);

commit 6dd687b42fff7aa681978e117cf3051de0d023a5
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Fri Feb 12 09:57:15 2016 +0100

    drm/vmwgfx: Calculate the cursor position based on the crtc gui origin
    
    Base the cursor position on the coordinate of the crtc origin in the
    gui coordinate system rather than in the framebuffer coordinate system.
    
    With explicit placement, these may differ (for example when two crtcs
    scan out of the same framebuffer location).
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 1cd88d197840..fe42a2cefb86 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -202,6 +202,8 @@ static int vmw_stdu_define_st(struct vmw_private *dev_priv,
 		cmd->body.xRoot  = stdu->base.gui_x;
 		cmd->body.yRoot  = stdu->base.gui_y;
 	}
+	stdu->base.set_gui_x = cmd->body.xRoot;
+	stdu->base.set_gui_y = cmd->body.yRoot;
 
 	vmw_fifo_commit(dev_priv, sizeof(*cmd));
 

commit 76404ac0a2c358dd63b8ed32e4df69f3b781b7eb
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Fri Feb 12 09:55:45 2016 +0100

    drm/vmwgfx: Add connector properties to switch between explicit and implicit placement
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index f02bb702c282..1cd88d197840 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1134,7 +1134,11 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 				   dev->mode_config.suggested_x_property, 0);
 	drm_object_attach_property(&connector->base,
 				   dev->mode_config.suggested_y_property, 0);
-
+	if (dev_priv->implicit_placement_property)
+		drm_object_attach_property
+			(&connector->base,
+			 dev_priv->implicit_placement_property,
+			 stdu->base.is_implicit);
 	return 0;
 }
 
@@ -1199,6 +1203,8 @@ int vmw_kms_stdu_init_display(struct vmw_private *dev_priv)
 
 	dev_priv->active_display_unit = vmw_du_screen_target;
 
+	vmw_kms_create_implicit_placement_property(dev_priv, false);
+
 	for (i = 0; i < VMWGFX_NUM_DISPLAY_UNITS; ++i) {
 		ret = vmw_stdu_init(dev_priv, i);
 

commit 578e609a096e086dc1259611cfb47b1499bcded6
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Fri Feb 12 09:45:42 2016 +0100

    drm/vmwgfx: Add suggested screen x and y connector properties
    
    Introduced by qxl, add these properties as a generic way to tell a
    display manager about the GUI layout.
    
    Also add the hotplug_mode_update_property which advises display managers to
    reread the mode list on a hotplug event.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Jakob Bornecrantz <jakob@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index a5ab826879d1..f02bb702c282 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1128,6 +1128,12 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 	drm_object_attach_property(&connector->base,
 				   dev->mode_config.dirty_info_property,
 				   1);
+	drm_object_attach_property(&connector->base,
+				   dev_priv->hotplug_mode_update_property, 1);
+	drm_object_attach_property(&connector->base,
+				   dev->mode_config.suggested_x_property, 0);
+	drm_object_attach_property(&connector->base,
+				   dev->mode_config.suggested_y_property, 0);
 
 	return 0;
 }

commit 4d492a07ad62e58c47d863266ff347a9f202016b
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Fri Feb 12 09:01:29 2016 +0100

    drm/vmwgfx: Add implicit framebuffer checks to the screen target code
    
    Just like for screen objects, make sure we use only a single framebuffer
    for implicit placement.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index c93af718a740..a5ab826879d1 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -510,6 +510,7 @@ static int vmw_stdu_bind_fb(struct vmw_private *dev_priv,
 static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
 {
 	struct vmw_private *dev_priv;
+	struct vmw_framebuffer *vfb;
 	struct vmw_screen_target_display_unit *stdu;
 	struct drm_display_mode *mode;
 	struct drm_framebuffer  *new_fb;
@@ -529,6 +530,7 @@ static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
 	new_fb   = set->fb;
 	dev_priv = vmw_priv(crtc->dev);
 	turning_off = set->num_connectors == 0 || !mode || !new_fb;
+	vfb = (new_fb) ? vmw_framebuffer_to_vfb(new_fb) : NULL;
 
 	if (set->num_connectors > 1) {
 		DRM_ERROR("Too many connectors\n");
@@ -548,6 +550,14 @@ static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
 		return -EINVAL;
 	}
 
+	/* Only one active implicit frame-buffer at a time. */
+	if (!turning_off && stdu->base.is_implicit && dev_priv->implicit_fb &&
+	    !(dev_priv->num_implicit == 1 && stdu->base.active_implicit)
+	    && dev_priv->implicit_fb != vfb) {
+		DRM_ERROR("Multiple implicit framebuffers not supported.\n");
+		return -EINVAL;
+	}
+
 	/* Since they always map one to one these are safe */
 	connector = &stdu->base.connector;
 	encoder   = &stdu->base.encoder;
@@ -559,6 +569,7 @@ static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
 
 		vmw_stdu_unpin_display(stdu);
 		(void) vmw_stdu_update_st(dev_priv, stdu);
+		vmw_kms_del_active(dev_priv, &stdu->base);
 
 		ret = vmw_stdu_destroy_st(dev_priv, stdu);
 		if (ret)
@@ -603,6 +614,7 @@ static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
 	if (ret)
 		return ret;
 
+	vmw_kms_add_active(dev_priv, &stdu->base, vfb);
 	crtc->enabled = true;
 	connector->encoder = encoder;
 	encoder->crtc      = crtc;
@@ -644,13 +656,16 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 	dev_priv          = vmw_priv(crtc->dev);
 	stdu              = vmw_crtc_to_stdu(crtc);
 
-	if (!stdu->defined)
+	if (!stdu->defined || !vmw_kms_crtc_flippable(dev_priv, crtc))
 		return -EINVAL;
 
 	ret = vmw_stdu_bind_fb(dev_priv, crtc, &crtc->mode, new_fb);
 	if (ret)
 		return ret;
 
+	if (stdu->base.is_implicit)
+		vmw_kms_update_implicit_fb(dev_priv, crtc);
+
 	vclips.x = crtc->x;
 	vclips.y = crtc->y;
 	vclips.w = crtc->mode.hdisplay;

commit b1097aeb6f23433c4e073a8d7447a8d919e1e163
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Fri Feb 12 08:54:07 2016 +0100

    drm/vmwgfx: Rework screen target page flips v2
    
    Gnome-Shell / Wayland assumes that page-flips can be done on a crtc
    regardless of framebuffer size and the crtc position within the
    framebuffer.
    
    Therefore rework the screen target code to correctly handle changes in
    framebuffer size and content_fb_type. Also make sure that we update
    the screen target correctly when the content_fb_type is not
    SAME_AS_DISPLAY.
    
    This commit breaks out the framebuffer binding code from crtc_set so it
    can be used both from page_flip() and crtc_set() and reworks those
    functions a bit to be more robust.
    
    v2: Address review comments by Sinclair Yeh.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 4ef5ffd7189d..c93af718a740 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -96,7 +96,6 @@ struct vmw_stdu_surface_copy {
  *               content_vfbs dimensions, then this is a pointer into the
  *               corresponding field in content_vfbs.  If not, then this
  *               is a separate buffer to which content_vfbs will blit to.
- * @content_fb: holds the rendered content, can be a surface or DMA buffer
  * @content_type:  content_fb type
  * @defined:  true if the current display unit has been initialized
  */
@@ -104,8 +103,6 @@ struct vmw_screen_target_display_unit {
 	struct vmw_display_unit base;
 
 	struct vmw_surface     *display_srf;
-	struct drm_framebuffer *content_fb;
-
 	enum stdu_content_type content_fb_type;
 
 	bool defined;
@@ -121,22 +118,6 @@ static void vmw_stdu_destroy(struct vmw_screen_target_display_unit *stdu);
  * Screen Target Display Unit helper Functions
  *****************************************************************************/
 
-/**
- * vmw_stdu_pin_display - pins the resource associated with the display surface
- *
- * @stdu: contains the display surface
- *
- * Since the display surface can either be a private surface allocated by us,
- * or it can point to the content surface, we use this function to not pin the
- * same resource twice.
- */
-static int vmw_stdu_pin_display(struct vmw_screen_target_display_unit *stdu)
-{
-	return vmw_resource_pin(&stdu->display_srf->res, false);
-}
-
-
-
 /**
  * vmw_stdu_unpin_display - unpins the resource associated with display surface
  *
@@ -153,13 +134,7 @@ static void vmw_stdu_unpin_display(struct vmw_screen_target_display_unit *stdu)
 		struct vmw_resource *res = &stdu->display_srf->res;
 
 		vmw_resource_unpin(res);
-
-		if (stdu->content_fb_type != SAME_AS_DISPLAY) {
-			vmw_resource_unreference(&res);
-			stdu->content_fb_type = SAME_AS_DISPLAY;
-		}
-
-		stdu->display_srf = NULL;
+		vmw_surface_unreference(&stdu->display_srf);
 	}
 }
 
@@ -185,6 +160,9 @@ static void vmw_stdu_crtc_destroy(struct drm_crtc *crtc)
  *
  * @dev_priv:  VMW DRM device
  * @stdu: display unit to create a Screen Target for
+ * @mode: The mode to set.
+ * @crtc_x: X coordinate of screen target relative to framebuffer origin.
+ * @crtc_y: Y coordinate of screen target relative to framebuffer origin.
  *
  * Creates a STDU that we can used later.  This function is called whenever the
  * framebuffer size changes.
@@ -193,7 +171,9 @@ static void vmw_stdu_crtc_destroy(struct drm_crtc *crtc)
  * 0 on success, error code on failure
  */
 static int vmw_stdu_define_st(struct vmw_private *dev_priv,
-			      struct vmw_screen_target_display_unit *stdu)
+			      struct vmw_screen_target_display_unit *stdu,
+			      struct drm_display_mode *mode,
+			      int crtc_x, int crtc_y)
 {
 	struct {
 		SVGA3dCmdHeader header;
@@ -211,14 +191,14 @@ static int vmw_stdu_define_st(struct vmw_private *dev_priv,
 	cmd->header.size = sizeof(cmd->body);
 
 	cmd->body.stid   = stdu->base.unit;
-	cmd->body.width  = stdu->display_srf->base_size.width;
-	cmd->body.height = stdu->display_srf->base_size.height;
+	cmd->body.width  = mode->hdisplay;
+	cmd->body.height = mode->vdisplay;
 	cmd->body.flags  = (0 == cmd->body.stid) ? SVGA_STFLAG_PRIMARY : 0;
 	cmd->body.dpi    = 0;
-	cmd->body.xRoot  = stdu->base.crtc.x;
-	cmd->body.yRoot  = stdu->base.crtc.y;
-
-	if (!stdu->base.is_implicit) {
+	if (stdu->base.is_implicit) {
+		cmd->body.xRoot  = crtc_x;
+		cmd->body.yRoot  = crtc_y;
+	} else {
 		cmd->body.xRoot  = stdu->base.gui_x;
 		cmd->body.yRoot  = stdu->base.gui_y;
 	}
@@ -392,126 +372,43 @@ static int vmw_stdu_destroy_st(struct vmw_private *dev_priv,
 	return ret;
 }
 
-
-
 /**
- * vmw_stdu_crtc_set_config - Sets a mode
- *
- * @set:  mode parameters
+ * vmw_stdu_bind_fb - Bind an fb to a defined screen target
  *
- * This function is the device-specific portion of the DRM CRTC mode set.
- * For the SVGA device, we do this by defining a Screen Target, binding a
- * GB Surface to that target, and finally update the screen target.
+ * @dev_priv: Pointer to a device private struct.
+ * @crtc: The crtc holding the screen target.
+ * @mode: The mode currently used by the screen target. Must be non-NULL.
+ * @new_fb: The new framebuffer to bind. Must be non-NULL.
  *
  * RETURNS:
- * 0 on success, error code otherwise
+ * 0 on success, error code on failure.
  */
-static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
+static int vmw_stdu_bind_fb(struct vmw_private *dev_priv,
+			    struct drm_crtc *crtc,
+			    struct drm_display_mode *mode,
+			    struct drm_framebuffer *new_fb)
 {
-	struct vmw_private *dev_priv;
-	struct vmw_screen_target_display_unit *stdu;
-	struct vmw_framebuffer *vfb;
+	struct vmw_screen_target_display_unit *stdu = vmw_crtc_to_stdu(crtc);
+	struct vmw_framebuffer *vfb = vmw_framebuffer_to_vfb(new_fb);
+	struct vmw_surface *new_display_srf = NULL;
+	enum stdu_content_type new_content_type;
 	struct vmw_framebuffer_surface *new_vfbs;
-	struct drm_display_mode *mode;
-	struct drm_framebuffer  *new_fb;
-	struct drm_crtc      *crtc;
-	struct drm_encoder   *encoder;
-	struct drm_connector *connector;
-	int    ret;
-
-
-	if (!set || !set->crtc)
-		return -EINVAL;
-
-	crtc     = set->crtc;
-	crtc->x  = set->x;
-	crtc->y  = set->y;
-	stdu     = vmw_crtc_to_stdu(crtc);
-	mode     = set->mode;
-	new_fb   = set->fb;
-	dev_priv = vmw_priv(crtc->dev);
-
-
-	if (set->num_connectors > 1) {
-		DRM_ERROR("Too many connectors\n");
-		return -EINVAL;
-	}
-
-	if (set->num_connectors == 1 &&
-	    set->connectors[0] != &stdu->base.connector) {
-		DRM_ERROR("Connectors don't match %p %p\n",
-			set->connectors[0], &stdu->base.connector);
-		return -EINVAL;
-	}
-
-
-	/* Since they always map one to one these are safe */
-	connector = &stdu->base.connector;
-	encoder   = &stdu->base.encoder;
-
-
-	/*
-	 * After this point the CRTC will be considered off unless a new fb
-	 * is bound
-	 */
-	if (stdu->defined) {
-		/* Unbind current surface by binding an invalid one */
-		ret = vmw_stdu_bind_st(dev_priv, stdu, NULL);
-		if (unlikely(ret != 0))
-			return ret;
-
-		/* Update Screen Target, display will now be blank */
-		if (crtc->primary->fb) {
-			vmw_stdu_update_st(dev_priv, stdu);
-			if (unlikely(ret != 0))
-				return ret;
-		}
-
-		crtc->primary->fb  = NULL;
-		crtc->enabled      = false;
-		encoder->crtc      = NULL;
-		connector->encoder = NULL;
-
-		vmw_stdu_unpin_display(stdu);
-		stdu->content_fb      = NULL;
-		stdu->content_fb_type = SAME_AS_DISPLAY;
-
-		ret = vmw_stdu_destroy_st(dev_priv, stdu);
-		/* The hardware is hung, give up */
-		if (unlikely(ret != 0))
-			return ret;
-	}
-
-
-	/* Any of these conditions means the caller wants CRTC off */
-	if (set->num_connectors == 0 || !mode || !new_fb)
-		return 0;
-
-
-	if (set->x + mode->hdisplay > new_fb->width ||
-	    set->y + mode->vdisplay > new_fb->height) {
-		DRM_ERROR("Set outside of framebuffer\n");
-		return -EINVAL;
-	}
+	int ret;
 
-	stdu->content_fb = new_fb;
-	vfb = vmw_framebuffer_to_vfb(stdu->content_fb);
+	WARN_ON_ONCE(!stdu->defined);
 
-	if (vfb->dmabuf)
-		stdu->content_fb_type = SEPARATE_DMA;
+	if (!vfb->dmabuf && new_fb->width == mode->hdisplay &&
+	    new_fb->height == mode->vdisplay)
+		new_content_type = SAME_AS_DISPLAY;
+	else if (vfb->dmabuf)
+		new_content_type = SEPARATE_DMA;
+	else
+		new_content_type = SEPARATE_SURFACE;
 
-	/*
-	 * If the requested mode is different than the width and height
-	 * of the FB or if the content buffer is a DMA buf, then allocate
-	 * a display FB that matches the dimension of the mode
-	 */
-	if (mode->hdisplay != new_fb->width  ||
-	    mode->vdisplay != new_fb->height ||
-	    stdu->content_fb_type != SAME_AS_DISPLAY) {
+	if (new_content_type != SAME_AS_DISPLAY &&
+	    !stdu->display_srf) {
 		struct vmw_surface content_srf;
 		struct drm_vmw_size display_base_size = {0};
-		struct vmw_surface *display_srf;
-
 
 		display_base_size.width  = mode->hdisplay;
 		display_base_size.height = mode->vdisplay;
@@ -521,7 +418,7 @@ static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
 		 * If content buffer is a DMA buf, then we have to construct
 		 * surface info
 		 */
-		if (stdu->content_fb_type == SEPARATE_DMA) {
+		if (new_content_type == SEPARATE_DMA) {
 
 			switch (new_fb->bits_per_pixel) {
 			case 32:
@@ -538,17 +435,13 @@ static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
 
 			default:
 				DRM_ERROR("Invalid format\n");
-				ret = -EINVAL;
-				goto err_unref_content;
+				return -EINVAL;
 			}
 
 			content_srf.flags             = 0;
 			content_srf.mip_levels[0]     = 1;
 			content_srf.multisample_count = 0;
 		} else {
-
-			stdu->content_fb_type = SEPARATE_SURFACE;
-
 			new_vfbs = vmw_framebuffer_to_vfbs(new_fb);
 			content_srf = *new_vfbs->surface;
 		}
@@ -563,26 +456,125 @@ static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
 				content_srf.multisample_count,
 				0,
 				display_base_size,
-				&display_srf);
+				&new_display_srf);
 		if (unlikely(ret != 0)) {
-			DRM_ERROR("Cannot allocate a display FB.\n");
-			goto err_unref_content;
+			DRM_ERROR("Could not allocate screen target surface.\n");
+			return ret;
 		}
-
-		stdu->display_srf = display_srf;
-	} else {
+	} else if (new_content_type == SAME_AS_DISPLAY) {
 		new_vfbs = vmw_framebuffer_to_vfbs(new_fb);
-		stdu->display_srf = new_vfbs->surface;
+		new_display_srf = vmw_surface_reference(new_vfbs->surface);
 	}
 
+	if (new_display_srf) {
+		/* Pin new surface before flipping */
+		ret = vmw_resource_pin(&new_display_srf->res, false);
+		if (ret)
+			goto out_srf_unref;
+
+		ret = vmw_stdu_bind_st(dev_priv, stdu, &new_display_srf->res);
+		if (ret)
+			goto out_srf_unpin;
 
-	ret = vmw_stdu_pin_display(stdu);
-	if (unlikely(ret != 0)) {
-		stdu->display_srf = NULL;
-		goto err_unref_content;
+		/* Unpin and unreference old surface */
+		vmw_stdu_unpin_display(stdu);
+
+		/* Transfer the reference */
+		stdu->display_srf = new_display_srf;
+		new_display_srf = NULL;
 	}
 
-	vmw_svga_enable(dev_priv);
+	crtc->primary->fb = new_fb;
+	stdu->content_fb_type = new_content_type;
+	return 0;
+
+out_srf_unpin:
+	vmw_resource_unpin(&new_display_srf->res);
+out_srf_unref:
+	vmw_surface_unreference(&new_display_srf);
+	return ret;
+}
+
+/**
+ * vmw_stdu_crtc_set_config - Sets a mode
+ *
+ * @set:  mode parameters
+ *
+ * This function is the device-specific portion of the DRM CRTC mode set.
+ * For the SVGA device, we do this by defining a Screen Target, binding a
+ * GB Surface to that target, and finally update the screen target.
+ *
+ * RETURNS:
+ * 0 on success, error code otherwise
+ */
+static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
+{
+	struct vmw_private *dev_priv;
+	struct vmw_screen_target_display_unit *stdu;
+	struct drm_display_mode *mode;
+	struct drm_framebuffer  *new_fb;
+	struct drm_crtc      *crtc;
+	struct drm_encoder   *encoder;
+	struct drm_connector *connector;
+	bool turning_off;
+	int    ret;
+
+
+	if (!set || !set->crtc)
+		return -EINVAL;
+
+	crtc     = set->crtc;
+	stdu     = vmw_crtc_to_stdu(crtc);
+	mode     = set->mode;
+	new_fb   = set->fb;
+	dev_priv = vmw_priv(crtc->dev);
+	turning_off = set->num_connectors == 0 || !mode || !new_fb;
+
+	if (set->num_connectors > 1) {
+		DRM_ERROR("Too many connectors\n");
+		return -EINVAL;
+	}
+
+	if (set->num_connectors == 1 &&
+	    set->connectors[0] != &stdu->base.connector) {
+		DRM_ERROR("Connectors don't match %p %p\n",
+			set->connectors[0], &stdu->base.connector);
+		return -EINVAL;
+	}
+
+	if (!turning_off && (set->x + mode->hdisplay > new_fb->width ||
+			     set->y + mode->vdisplay > new_fb->height)) {
+		DRM_ERROR("Set outside of framebuffer\n");
+		return -EINVAL;
+	}
+
+	/* Since they always map one to one these are safe */
+	connector = &stdu->base.connector;
+	encoder   = &stdu->base.encoder;
+
+	if (stdu->defined) {
+		ret = vmw_stdu_bind_st(dev_priv, stdu, NULL);
+		if (ret)
+			return ret;
+
+		vmw_stdu_unpin_display(stdu);
+		(void) vmw_stdu_update_st(dev_priv, stdu);
+
+		ret = vmw_stdu_destroy_st(dev_priv, stdu);
+		if (ret)
+			return ret;
+
+		crtc->primary->fb = NULL;
+		crtc->enabled = false;
+		encoder->crtc = NULL;
+		connector->encoder = NULL;
+		stdu->content_fb_type = SAME_AS_DISPLAY;
+		crtc->x = set->x;
+		crtc->y = set->y;
+	}
+
+	if (turning_off)
+		return 0;
 
 	/*
 	 * Steps to displaying a surface, assume surface is already
@@ -592,35 +584,32 @@ static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
 	 *   3.  update that screen target (this is done later by
 	 *       vmw_kms_stdu_do_surface_dirty_or_present)
 	 */
-	ret = vmw_stdu_define_st(dev_priv, stdu);
-	if (unlikely(ret != 0))
-		goto err_unpin_display_and_content;
+	/*
+	 * Note on error handling: We can't really restore the crtc to
+	 * it's original state on error, but we at least update the
+	 * current state to what's submitted to hardware to enable
+	 * future recovery.
+	 */
+	vmw_svga_enable(dev_priv);
+	ret = vmw_stdu_define_st(dev_priv, stdu, mode, set->x, set->y);
+	if (ret)
+		return ret;
 
-	ret = vmw_stdu_bind_st(dev_priv, stdu, &stdu->display_srf->res);
-	if (unlikely(ret != 0))
-		goto err_unpin_destroy_st;
+	crtc->x = set->x;
+	crtc->y = set->y;
+	crtc->mode = *mode;
 
+	ret = vmw_stdu_bind_fb(dev_priv, crtc, mode, new_fb);
+	if (ret)
+		return ret;
 
+	crtc->enabled = true;
 	connector->encoder = encoder;
 	encoder->crtc      = crtc;
 
-	crtc->mode    = *mode;
-	crtc->primary->fb = new_fb;
-	crtc->enabled = true;
-
-	return ret;
-
-err_unpin_destroy_st:
-	vmw_stdu_destroy_st(dev_priv, stdu);
-err_unpin_display_and_content:
-	vmw_stdu_unpin_display(stdu);
-err_unref_content:
-	stdu->content_fb = NULL;
-	return ret;
+	return 0;
 }
 
-
-
 /**
  * vmw_stdu_crtc_page_flip - Binds a buffer to a screen target
  *
@@ -648,59 +637,31 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 {
 	struct vmw_private *dev_priv = vmw_priv(crtc->dev);
 	struct vmw_screen_target_display_unit *stdu;
+	struct drm_vmw_rect vclips;
+	struct vmw_framebuffer *vfb = vmw_framebuffer_to_vfb(new_fb);
 	int ret;
 
-	if (crtc == NULL)
-		return -EINVAL;
-
 	dev_priv          = vmw_priv(crtc->dev);
 	stdu              = vmw_crtc_to_stdu(crtc);
-	crtc->primary->fb = new_fb;
-	stdu->content_fb  = new_fb;
-
-	if (stdu->display_srf) {
-		/*
-		 * If the display surface is the same as the content surface
-		 * then remove the reference
-		 */
-		if (stdu->content_fb_type == SAME_AS_DISPLAY) {
-			if (stdu->defined) {
-				/* Unbind the current surface */
-				ret = vmw_stdu_bind_st(dev_priv, stdu, NULL);
-				if (unlikely(ret != 0))
-					goto err_out;
-			}
-			vmw_stdu_unpin_display(stdu);
-			stdu->display_srf = NULL;
-		}
-	}
-
-
-	if (!new_fb) {
-		/* Blanks the display */
-		(void) vmw_stdu_update_st(dev_priv, stdu);
-
-		return 0;
-	}
 
+	if (!stdu->defined)
+		return -EINVAL;
 
-	if (stdu->content_fb_type == SAME_AS_DISPLAY) {
-		stdu->display_srf = vmw_framebuffer_to_vfbs(new_fb)->surface;
-		ret = vmw_stdu_pin_display(stdu);
-		if (ret) {
-			stdu->display_srf = NULL;
-			goto err_out;
-		}
-
-		/* Bind display surface */
-		ret = vmw_stdu_bind_st(dev_priv, stdu, &stdu->display_srf->res);
-		if (unlikely(ret != 0))
-			goto err_unpin_display_and_content;
-	}
+	ret = vmw_stdu_bind_fb(dev_priv, crtc, &crtc->mode, new_fb);
+	if (ret)
+		return ret;
 
-	/* Update display surface: after this point everything is bound */
-	ret = vmw_stdu_update_st(dev_priv, stdu);
-	if (unlikely(ret != 0))
+	vclips.x = crtc->x;
+	vclips.y = crtc->y;
+	vclips.w = crtc->mode.hdisplay;
+	vclips.h = crtc->mode.vdisplay;
+	if (vfb->dmabuf)
+		ret = vmw_kms_stdu_dma(dev_priv, NULL, vfb, NULL, NULL, &vclips,
+				       1, 1, true, false);
+	else
+		ret = vmw_kms_stdu_surface_dirty(dev_priv, vfb, NULL, &vclips,
+						 NULL, 0, 0, 1, 1, NULL);
+	if (ret)
 		return ret;
 
 	if (event) {
@@ -721,14 +682,7 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 		vmw_fifo_flush(dev_priv, false);
 	}
 
-	return ret;
-
-err_unpin_display_and_content:
-	vmw_stdu_unpin_display(stdu);
-err_out:
-	crtc->primary->fb = NULL;
-	stdu->content_fb = NULL;
-	return ret;
+	return 0;
 }
 
 

commit 20f8e032e6dc7053ab803f488e2a8839cd2f69a6
Merge: ade1ba734607 5b726e06d6e8
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Dec 24 08:08:47 2015 +1000

    Backmerge drm-fixes merge into Linus's tree into drm-next.
    
    This merges '5b726e06d6e8309e5c9ef4109a32caf27c71dfc8' into drm-next
    
    Just to resolve some merges to make Daniel's life easier.
    
    Signed-off-by: DAve Airlie <airlied@redhat.com>

commit d7955fcff889ec9a78bac387aec929154465423a
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Tue Dec 15 12:21:15 2015 +0100

    drm/vmwgfx: Constify function pointer structs
    
    Moves a bunch of junk to .rodata from .data.
    
     drivers/gpu/drm/vmwgfx/vmwgfx.ko:
    -.text                       132244
    +.text                       132240
    -.rodata                      18296
    +.rodata                      18680
    -.data                         5096
    +.data                         4712
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1450178476-26284-28-git-send-email-boris.brezillon@free-electrons.com
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 45e72c2f15cd..87fc00af8d28 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1040,7 +1040,7 @@ int vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,
 /*
  *  Screen Target CRTC dispatch table
  */
-static struct drm_crtc_funcs vmw_stdu_crtc_funcs = {
+static const struct drm_crtc_funcs vmw_stdu_crtc_funcs = {
 	.cursor_set = vmw_du_crtc_cursor_set,
 	.cursor_move = vmw_du_crtc_cursor_move,
 	.gamma_set = vmw_du_crtc_gamma_set,
@@ -1070,7 +1070,7 @@ static void vmw_stdu_encoder_destroy(struct drm_encoder *encoder)
 	vmw_stdu_destroy(vmw_encoder_to_stdu(encoder));
 }
 
-static struct drm_encoder_funcs vmw_stdu_encoder_funcs = {
+static const struct drm_encoder_funcs vmw_stdu_encoder_funcs = {
 	.destroy = vmw_stdu_encoder_destroy,
 };
 
@@ -1097,7 +1097,7 @@ static void vmw_stdu_connector_destroy(struct drm_connector *connector)
 
 
 
-static struct drm_connector_funcs vmw_stdu_connector_funcs = {
+static const struct drm_connector_funcs vmw_stdu_connector_funcs = {
 	.dpms = vmw_du_connector_dpms,
 	.detect = vmw_du_connector_detect,
 	.fill_modes = vmw_du_connector_fill_modes,

commit 13a3d91f17a5f7ed2acd275d18b6acfdb131fb15
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Wed Dec 9 16:20:18 2015 +0200

    drm: Pass 'name' to drm_encoder_init()
    
    Done with coccinelle for the most part. However, it thinks '...' is
    part of the semantic patch, so I put an 'int DOTDOTDOT' placeholder
    in its place and got rid of it with sed afterwards.
    
    @@
    identifier dev, encoder, funcs;
    @@
     int drm_encoder_init(struct drm_device *dev,
                          struct drm_encoder *encoder,
                          const struct drm_encoder_funcs *funcs,
                          int encoder_type
    +                     ,const char *name, int DOTDOTDOT
                          )
    { ... }
    
    @@
    identifier dev, encoder, funcs;
    @@
     int drm_encoder_init(struct drm_device *dev,
                          struct drm_encoder *encoder,
                          const struct drm_encoder_funcs *funcs,
                          int encoder_type
    +                     ,const char *name, int DOTDOTDOT
                          );
    
    @@
    expression E1, E2, E3, E4;
    @@
     drm_encoder_init(E1, E2, E3, E4
    +                 ,NULL
                      )
    
    v2: Add ', or NULL...' to @name kernel doc (Jani)
        Annotate the function with __printf() attribute (Jani)
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449670818-2966-1-git-send-email-ville.syrjala@linux.intel.com

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 05375a8cc129..45e72c2f15cd 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1145,7 +1145,7 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 	connector->status = vmw_du_connector_detect(connector, false);
 
 	drm_encoder_init(dev, encoder, &vmw_stdu_encoder_funcs,
-			 DRM_MODE_ENCODER_VIRTUAL);
+			 DRM_MODE_ENCODER_VIRTUAL, NULL);
 	drm_mode_connector_attach_encoder(connector, encoder);
 	encoder->possible_crtcs = (1 << unit);
 	encoder->possible_clones = 0;

commit f80de66eca654d9363918a1b4c0a62059586feff
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Dec 4 09:45:52 2015 +0100

    drm/vmwgfx: Drop dummy save/restore hooks
    
    These hooks will be gone soon.
    
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449218769-16577-12-git-send-email-daniel.vetter@ffwll.ch
    Reviewed-by: Thierry Reding <treding@nvidia.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index b1fc1c02792d..05375a8cc129 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1041,8 +1041,6 @@ int vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,
  *  Screen Target CRTC dispatch table
  */
 static struct drm_crtc_funcs vmw_stdu_crtc_funcs = {
-	.save = vmw_du_crtc_save,
-	.restore = vmw_du_crtc_restore,
 	.cursor_set = vmw_du_crtc_cursor_set,
 	.cursor_move = vmw_du_crtc_cursor_move,
 	.gamma_set = vmw_du_crtc_gamma_set,
@@ -1101,8 +1099,6 @@ static void vmw_stdu_connector_destroy(struct drm_connector *connector)
 
 static struct drm_connector_funcs vmw_stdu_connector_funcs = {
 	.dpms = vmw_du_connector_dpms,
-	.save = vmw_du_connector_save,
-	.restore = vmw_du_connector_restore,
 	.detect = vmw_du_connector_detect,
 	.fill_modes = vmw_du_connector_fill_modes,
 	.set_property = vmw_du_connector_set_property,

commit 8fbf9d92a7bc4cadd3a0139698cf17031dfcdfca
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Thu Nov 26 19:45:16 2015 +0100

    drm/vmwgfx: Implement the cursor_set2 callback v2
    
    Fixes native drm clients like Fedora 23 Wayland which now appears to
    be able to use cursor hotspots without strange cursor offsets.
    Also fixes a couple of ignored error paths.
    
    Since the core drm cursor hotspot is incompatible with the legacy vmwgfx
    hotspot (the core drm hotspot is reset when the drm_mode_cursor ioctl
    is used), we need to keep track of both and add them when the device
    hotspot is set. We assume that either is always zero.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index b1fc1c02792d..f823fc3efed7 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1043,7 +1043,7 @@ int vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,
 static struct drm_crtc_funcs vmw_stdu_crtc_funcs = {
 	.save = vmw_du_crtc_save,
 	.restore = vmw_du_crtc_restore,
-	.cursor_set = vmw_du_crtc_cursor_set,
+	.cursor_set2 = vmw_du_crtc_cursor_set2,
 	.cursor_move = vmw_du_crtc_cursor_move,
 	.gamma_set = vmw_du_crtc_gamma_set,
 	.destroy = vmw_stdu_crtc_destroy,

commit 4e0858a682c008a2a8f5f4fb3aec705500575ae1
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Thu Nov 5 02:18:55 2015 -0800

    drm/vmwgfx: Properly flush cursor updates and page-flips
    
    With the introduction of the new command buffer mechanism,
    proper care wasn't taken to flush cursor image updates and
    event-less screen-target page-flips.
    
    Fix this by introducing explicit flush points.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Brian Paul <brianp@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index c22e2df1b336..b1fc1c02792d 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -717,6 +717,8 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 						   &event->event.tv_usec,
 						   true);
 		vmw_fence_obj_unreference(&fence);
+	} else {
+		vmw_fifo_flush(dev_priv, false);
 	}
 
 	return ret;

commit 54fbde8a94a8a78547597215c9e4be590d075ee0
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Wed Jul 29 12:38:02 2015 -0700

    drm/vmwgfx: Fix copyright headers
    
    Updating and fixing copyright headers.
    Bump version minor to signal vgpu10 support.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Brian Paul <brianp@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index ae6773e171b0..c22e2df1b336 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * COPYRIGHT © 2014 VMware, Inc., Palo Alto, CA., USA
+ * COPYRIGHT © 2014-2015 VMware, Inc., Palo Alto, CA., USA
  * All Rights Reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a

commit d80efd5cb3dec16a8d1aea9b8a4a7921972dba65
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Mon Aug 10 10:39:35 2015 -0700

    drm/vmwgfx: Initial DX support
    
    Initial DX support.
    Co-authored with Sinclair Yeh, Charmaine Lee and Jakob Bornecrantz.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Charmaine Lee <charmainel@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index d4a453703eed..ae6773e171b0 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -561,6 +561,7 @@ static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
 				true, /* a scanout buffer */
 				content_srf.mip_levels[0],
 				content_srf.multisample_count,
+				0,
 				display_base_size,
 				&display_srf);
 		if (unlikely(ret != 0)) {

commit 8ce75f8ab9044fe11caaaf2b2c82471023212f9f
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Wed Jul 8 21:20:39 2015 -0700

    drm/vmwgfx: Update device includes for DX device functionality
    
    Add DX includes and move all device includes to a separate directory.
    
    Co-authored with Thomas Hellstrom, Charmaine Lee and above all,
    the VMware device team.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Charmaine Lee <charmainel@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 493fcd1eb803..d4a453703eed 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -26,7 +26,7 @@
  ******************************************************************************/
 
 #include "vmwgfx_kms.h"
-#include "svga3d_surfacedefs.h"
+#include "device_include/svga3d_surfacedefs.h"
 #include <drm/drm_plane_helper.h>
 
 #define vmw_crtc_to_stdu(x) \

commit 6bf6bf03b37b5ba0f3399fa9bb3d62edfa117c87
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Fri Jun 26 02:22:40 2015 -0700

    drm/vmwgfx: Convert screen targets to new helpers v3
    
    Also implements the missing readback function and
    fixes page flip in case of no event.
    
    v2:
    - Adapt to the work done for screen targets for 2d, in particular
    Handle proxy surface updates.
    - Remove execbuf quirks since we now use fifo reserve / commit.
    - Revert the initial placement of vmw dma buffers.
    
    v3: Address review comments.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index becf9650c228..493fcd1eb803 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright © 2014 VMware, Inc., Palo Alto, CA., USA
+ * COPYRIGHT © 2014 VMware, Inc., Palo Alto, CA., USA
  * All Rights Reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
@@ -44,6 +44,47 @@ enum stdu_content_type {
 	SEPARATE_DMA
 };
 
+/**
+ * struct vmw_stdu_dirty - closure structure for the update functions
+ *
+ * @base: The base type we derive from. Used by vmw_kms_helper_dirty().
+ * @transfer: Transfer direction for DMA command.
+ * @left: Left side of bounding box.
+ * @right: Right side of bounding box.
+ * @top: Top side of bounding box.
+ * @bottom: Bottom side of bounding box.
+ * @buf: DMA buffer when DMA-ing between buffer and screen targets.
+ * @sid: Surface ID when copying between surface and screen targets.
+ */
+struct vmw_stdu_dirty {
+	struct vmw_kms_dirty base;
+	SVGA3dTransferType  transfer;
+	s32 left, right, top, bottom;
+	u32 pitch;
+	union {
+		struct vmw_dma_buffer *buf;
+		u32 sid;
+	};
+};
+
+/*
+ * SVGA commands that are used by this code. Please see the device headers
+ * for explanation.
+ */
+struct vmw_stdu_update {
+	SVGA3dCmdHeader header;
+	SVGA3dCmdUpdateGBScreenTarget body;
+};
+
+struct vmw_stdu_dma {
+	SVGA3dCmdHeader     header;
+	SVGA3dCmdSurfaceDMA body;
+};
+
+struct vmw_stdu_surface_copy {
+	SVGA3dCmdHeader      header;
+	SVGA3dCmdSurfaceCopy body;
+};
 
 
 /**
@@ -139,254 +180,6 @@ static void vmw_stdu_crtc_destroy(struct drm_crtc *crtc)
 	vmw_stdu_destroy(vmw_crtc_to_stdu(crtc));
 }
 
-
-
-/**
- * vmw_stdu_dma_update - Update DMA buf dirty region on the SVGA device
- *
- * @dev_priv:  VMW DRM device
- * @file_priv: Pointer to a drm file private structure
- * @vfbs: VMW framebuffer surface that may need a DMA buf update
- * @x: top/left corner of the content area to blit from
- * @y: top/left corner of the content area to blit from
- * @width: width of the blit area
- * @height: height of the blit area
- *
- * The SVGA device may have the DMA buf cached, so before letting the
- * device use it as the source image for a subsequent operation, we
- * update the cached copy.
- *
- * RETURNs:
- * 0 on success, error code on failure
- */
-static int vmw_stdu_dma_update(struct vmw_private *dev_priv,
-			       struct drm_file *file_priv,
-			       struct vmw_framebuffer_surface *vfbs,
-			       uint32_t x, uint32_t y,
-			       uint32_t width, uint32_t height)
-{
-	size_t fifo_size;
-	struct {
-		SVGA3dCmdHeader header;
-		SVGA3dCmdUpdateGBImage body;
-	} img_update_cmd;
-
-
-	/* Only need to do this if the surface is a DMA buf proxy */
-	if (!vfbs->is_dmabuf_proxy)
-		return 0;
-
-	fifo_size = sizeof(img_update_cmd);
-
-	memset(&img_update_cmd, 0, fifo_size);
-	img_update_cmd.header.id   = SVGA_3D_CMD_UPDATE_GB_IMAGE;
-	img_update_cmd.header.size = sizeof(img_update_cmd.body);
-
-	img_update_cmd.body.image.sid = vfbs->surface->res.id;
-
-	img_update_cmd.body.box.x = x;
-	img_update_cmd.body.box.y = y;
-	img_update_cmd.body.box.w = width;
-	img_update_cmd.body.box.h = height;
-	img_update_cmd.body.box.d = 1;
-
-	return vmw_execbuf_process(file_priv, dev_priv, NULL,
-				   (void *) &img_update_cmd,
-				   fifo_size, 0, VMW_QUIRK_SRC_SID_OK,
-				   NULL, NULL);
-}
-
-
-
-/**
- * vmw_stdu_content_copy - copies an area from the content to display surface
- *
- * @dev_priv:  VMW DRM device
- * @file_priv: Pointer to a drm file private structure
- * @stdu: STDU whose display surface will be blitted to
- * @content_x: top/left corner of the content area to blit from
- * @content_y: top/left corner of the content area to blit from
- * @width: width of the blit area
- * @height: height of the blit area
- * @display_x: top/left corner of the display area to blit to
- * @display_y: top/left corner of the display area to blit to
- *
- * Copies an area from the content surface to the display surface.
- *
- * RETURNs:
- * 0 on success, error code on failure
- */
-static int vmw_stdu_content_copy(struct vmw_private *dev_priv,
-				 struct drm_file *file_priv,
-				 struct vmw_screen_target_display_unit *stdu,
-				 uint32_t content_x, uint32_t content_y,
-				 uint32_t width, uint32_t height,
-				 uint32_t display_x, uint32_t display_y)
-{
-	struct vmw_framebuffer_surface *content_vfbs;
-	size_t fifo_size;	
-	int ret;
-	void *cmd;
-	u32 quirks = VMW_QUIRK_DST_SID_OK;
-
-	struct {
-		SVGA3dCmdHeader     header;
-		SVGA3dCmdSurfaceDMA body;
-		SVGA3dCopyBox       area;
-		SVGA3dCmdSurfaceDMASuffix suffix;
-	} surface_dma_cmd;
-
-	struct {
-		SVGA3dCmdHeader      header;
-		SVGA3dCmdSurfaceCopy body;
-		SVGA3dCopyBox        area;
-	} surface_cpy_cmd;
-
-
-	/*
-	 * Can only copy if content and display surfaces exist and are not
-	 * the same surface
-	 */
-	if (stdu->display_srf == NULL || stdu->content_fb == NULL ||
-	    stdu->content_fb_type == SAME_AS_DISPLAY) {
-		return -EINVAL;
-	}
-
-
-	if (stdu->content_fb_type == SEPARATE_DMA) {
-		struct vmw_framebuffer *content_vfb;
-		struct drm_vmw_size cur_size = {0};
-		const struct svga3d_surface_desc *desc;
-		enum SVGA3dSurfaceFormat format;
-		SVGA3dCmdSurfaceDMASuffix *suffix;
-		SVGAGuestPtr ptr;
-
-
-		content_vfb  = vmw_framebuffer_to_vfb(stdu->content_fb);
-
-		cur_size.width  = width;
-		cur_size.height = height;
-		cur_size.depth  = 1;
-
-		/* Derive a SVGA3dSurfaceFormat for the DMA buf */
-		switch (content_vfb->base.bits_per_pixel) {
-		case 32:
-			format = SVGA3D_A8R8G8B8;
-			break;
-		case 24:
-			format = SVGA3D_X8R8G8B8;
-			break;
-		case 16:
-			format = SVGA3D_R5G6B5;
-			break;
-		case 15:
-			format = SVGA3D_A1R5G5B5;
-			break;
-		default:
-			DRM_ERROR("Invalid color depth: %d\n",
-					content_vfb->base.depth);
-			return -EINVAL;
-		}
-
-		desc = svga3dsurface_get_desc(format);
-
-
-		fifo_size = sizeof(surface_dma_cmd);
-
-		memset(&surface_dma_cmd, 0, fifo_size);
-
-		ptr.gmrId  = content_vfb->user_handle;
-		ptr.offset = 0;
-
-		surface_dma_cmd.header.id   = SVGA_3D_CMD_SURFACE_DMA;
-		surface_dma_cmd.header.size = sizeof(surface_dma_cmd.body) +
-					      sizeof(surface_dma_cmd.area) +
-					      sizeof(surface_dma_cmd.suffix);
-
-		surface_dma_cmd.body.guest.ptr   = ptr;
-		surface_dma_cmd.body.guest.pitch = stdu->content_fb->pitches[0];
-		surface_dma_cmd.body.host.sid    = stdu->display_srf->res.id;
-		surface_dma_cmd.body.host.face   = 0;
-		surface_dma_cmd.body.host.mipmap = 0;
-		surface_dma_cmd.body.transfer    = SVGA3D_WRITE_HOST_VRAM;
-
-		surface_dma_cmd.area.srcx = content_x;
-		surface_dma_cmd.area.srcy = content_y;
-		surface_dma_cmd.area.x    = display_x;
-		surface_dma_cmd.area.y    = display_y;
-		surface_dma_cmd.area.d    = 1;
-		surface_dma_cmd.area.w    = width;
-		surface_dma_cmd.area.h    = height;
-
-		suffix = &surface_dma_cmd.suffix;
-
-		suffix->suffixSize    = sizeof(*suffix);
-		suffix->maximumOffset = svga3dsurface_get_image_buffer_size(
-						desc,
-						&cur_size,
-						stdu->content_fb->pitches[0]);
-
-		cmd = (void *) &surface_dma_cmd;
-	} else {
-		u32 src_id;
-
-
-		content_vfbs = vmw_framebuffer_to_vfbs(stdu->content_fb);
-
-		if (content_vfbs->is_dmabuf_proxy) {
-			ret = vmw_stdu_dma_update(dev_priv, file_priv,
-						  content_vfbs,
-						  content_x, content_y,
-						  width, height);
-
-			if (ret != 0) {
-				DRM_ERROR("Failed to update cached DMA buf\n");
-				return ret;
-			}
-
-			quirks |= VMW_QUIRK_SRC_SID_OK;
-			src_id = content_vfbs->surface->res.id;
-		} else {
-			struct vmw_framebuffer *content_vfb;
-
-			content_vfb = vmw_framebuffer_to_vfb(stdu->content_fb);
-			src_id = content_vfb->user_handle;
-		}
- 
-		fifo_size = sizeof(surface_cpy_cmd);
-
-		memset(&surface_cpy_cmd, 0, fifo_size);
-
-		surface_cpy_cmd.header.id   = SVGA_3D_CMD_SURFACE_COPY;
-		surface_cpy_cmd.header.size = sizeof(surface_cpy_cmd.body) +
-					      sizeof(surface_cpy_cmd.area);
-
-		surface_cpy_cmd.body.src.sid  = src_id;
-		surface_cpy_cmd.body.dest.sid = stdu->display_srf->res.id;
-
-		surface_cpy_cmd.area.srcx = content_x;
-		surface_cpy_cmd.area.srcy = content_y;
-		surface_cpy_cmd.area.x    = display_x;
-		surface_cpy_cmd.area.y    = display_y;
-		surface_cpy_cmd.area.d    = 1;
-		surface_cpy_cmd.area.w    = width;
-		surface_cpy_cmd.area.h    = height;
-
-		cmd = (void *) &surface_cpy_cmd;
-	}
-
-
-
-	ret = vmw_execbuf_process(file_priv, dev_priv, NULL,
-				  (void *) cmd,
-				  fifo_size, 0, quirks,
-				  NULL, NULL);
-
-	return ret;
-}
-
-
-
 /**
  * vmw_stdu_define_st - Defines a Screen Target
  *
@@ -487,108 +280,56 @@ static int vmw_stdu_bind_st(struct vmw_private *dev_priv,
 	return 0;
 }
 
+/**
+ * vmw_stdu_populate_update - populate an UPDATE_GB_SCREENTARGET command with a
+ * bounding box.
+ *
+ * @cmd: Pointer to command stream.
+ * @unit: Screen target unit.
+ * @left: Left side of bounding box.
+ * @right: Right side of bounding box.
+ * @top: Top side of bounding box.
+ * @bottom: Bottom side of bounding box.
+ */
+static void vmw_stdu_populate_update(void *cmd, int unit,
+				     s32 left, s32 right, s32 top, s32 bottom)
+{
+	struct vmw_stdu_update *update = cmd;
+
+	update->header.id   = SVGA_3D_CMD_UPDATE_GB_SCREENTARGET;
+	update->header.size = sizeof(update->body);
 
+	update->body.stid   = unit;
+	update->body.rect.x = left;
+	update->body.rect.y = top;
+	update->body.rect.w = right - left;
+	update->body.rect.h = bottom - top;
+}
 
 /**
- * vmw_stdu_update_st - Updates a Screen Target
+ * vmw_stdu_update_st - Full update of a Screen Target
  *
  * @dev_priv: VMW DRM device
- * @file_priv: Pointer to DRM file private structure.  Set to NULL when
- *             we want to blank display.
  * @stdu: display unit affected
- * @update_area: area that needs to be updated
  *
  * This function needs to be called whenever the content of a screen
- * target changes.
- * If the display and content buffers are different, then this function does
- * a blit first from the content buffer to the display buffer before issuing
- * the Screen Target update command.
+ * target has changed completely. Typically as a result of a backing
+ * surface change.
  *
  * RETURNS:
  * 0 on success, error code on failure
  */
 static int vmw_stdu_update_st(struct vmw_private *dev_priv,
-			      struct drm_file *file_priv,
-			      struct vmw_screen_target_display_unit *stdu,
-			      struct drm_clip_rect *update_area)
+			      struct vmw_screen_target_display_unit *stdu)
 {
-	u32 width, height;
-	u32 display_update_x, display_update_y;
-	unsigned short display_x1, display_y1, display_x2, display_y2;
-	int ret;
-
-	struct {
-		SVGA3dCmdHeader header;
-		SVGA3dCmdUpdateGBScreenTarget body;
-	} *cmd;
-
+	struct vmw_stdu_update *cmd;
+	struct drm_crtc *crtc = &stdu->base.crtc;
 
 	if (!stdu->defined) {
 		DRM_ERROR("No screen target defined");
 		return -EINVAL;
 	}
 
-	/* Display coordinates relative to its position in content surface */
-	display_x1 = stdu->base.crtc.x;
-	display_y1 = stdu->base.crtc.y;
-	display_x2 = display_x1 + stdu->display_srf->base_size.width;
-	display_y2 = display_y1 + stdu->display_srf->base_size.height;
-
-	/* Do nothing if the update area is outside of the display surface */
-	if (update_area->x2 <= display_x1 || update_area->x1 >= display_x2 ||
-	    update_area->y2 <= display_y1 || update_area->y1 >= display_y2)
-		return 0;
-
-	/* The top-left hand corner of the update area in display surface */
-	display_update_x = max(update_area->x1 - display_x1, 0);
-	display_update_y = max(update_area->y1 - display_y1, 0);
-
-	width  = min(update_area->x2, display_x2) -
-		 max(update_area->x1, display_x1);
-	height = min(update_area->y2, display_y2) -
-		 max(update_area->y1, display_y1);
-
-	/*
-	 * If content is on a separate surface, then copy the dirty area to
-	 * the display surface
-	 */
-	if (file_priv && stdu->content_fb_type != SAME_AS_DISPLAY) {
-
-		ret = vmw_stdu_content_copy(dev_priv, file_priv,
-					    stdu,
-					    max(update_area->x1, display_x1),
-					    max(update_area->y1, display_y1),
-					    width, height,
-					    display_update_x, display_update_y);
-		if (unlikely(ret != 0)) {
-			DRM_ERROR("Failed to blit content\n");
-			return ret;
-		}
-	}
-
-
-	/*
-	 * If the display surface is the same as the content surface, then
-	 * it may be backed by a DMA buf.  If it is then we need to update
-	 * the device's cached copy of the DMA buf before issuing the screen
-	 * target update.
-	 */
-	if (file_priv && stdu->content_fb_type == SAME_AS_DISPLAY) {
-		struct vmw_framebuffer_surface *vfbs;
-
-		vfbs = vmw_framebuffer_to_vfbs(stdu->content_fb);
-		ret = vmw_stdu_dma_update(dev_priv, file_priv,
-					  vfbs,
-					  max(update_area->x1, display_x1),
-					  max(update_area->y1, display_y1),
-					  width, height);
-
-		if (ret != 0) {
-			DRM_ERROR("Failed to update cached DMA buffer\n");
-			return ret;
-		}
-	}
-
 	cmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));
 
 	if (unlikely(cmd == NULL)) {
@@ -596,14 +337,8 @@ static int vmw_stdu_update_st(struct vmw_private *dev_priv,
 		return -ENOMEM;
 	}
 
-	cmd->header.id   = SVGA_3D_CMD_UPDATE_GB_SCREENTARGET;
-	cmd->header.size = sizeof(cmd->body);
-
-	cmd->body.stid   = stdu->base.unit;
-	cmd->body.rect.x = display_update_x;
-	cmd->body.rect.y = display_update_y;
-	cmd->body.rect.w = width;
-	cmd->body.rect.h = height;
+	vmw_stdu_populate_update(cmd, stdu->base.unit, 0, crtc->mode.hdisplay,
+				 0, crtc->mode.vdisplay);
 
 	vmw_fifo_commit(dev_priv, sizeof(*cmd));
 
@@ -682,7 +417,6 @@ static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
 	struct drm_crtc      *crtc;
 	struct drm_encoder   *encoder;
 	struct drm_connector *connector;
-	struct drm_clip_rect update_area = {0};
 	int    ret;
 
 
@@ -728,12 +462,7 @@ static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
 
 		/* Update Screen Target, display will now be blank */
 		if (crtc->primary->fb) {
-			update_area.x2 = crtc->primary->fb->width;
-			update_area.y2 = crtc->primary->fb->height;
-
-			ret = vmw_stdu_update_st(dev_priv, NULL,
-						 stdu,
-						 &update_area);
+			vmw_stdu_update_st(dev_priv, stdu);
 			if (unlikely(ret != 0))
 				return ret;
 		}
@@ -852,7 +581,6 @@ static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
 		goto err_unref_content;
 	}
 
-	vmw_fb_off(dev_priv);
 	vmw_svga_enable(dev_priv);
 
 	/*
@@ -919,17 +647,8 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 {
 	struct vmw_private *dev_priv = vmw_priv(crtc->dev);
 	struct vmw_screen_target_display_unit *stdu;
-	struct drm_file *file_priv;
-	struct drm_clip_rect update_area = {0};
 	int ret;
 
-	/*
-	 * Temporarily don't support event == NULL. We need the
-	 * @file_priv pointer!
-	 */
-	if (event == NULL)
-		return -EINVAL;
-
 	if (crtc == NULL)
 		return -EINVAL;
 
@@ -939,9 +658,6 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 	stdu->content_fb  = new_fb;
 
 	if (stdu->display_srf) {
-		update_area.x2 = stdu->display_srf->base_size.width;
-		update_area.y2 = stdu->display_srf->base_size.height;
-
 		/*
 		 * If the display surface is the same as the content surface
 		 * then remove the reference
@@ -961,7 +677,7 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 
 	if (!new_fb) {
 		/* Blanks the display */
-		(void) vmw_stdu_update_st(dev_priv, NULL, stdu, &update_area);
+		(void) vmw_stdu_update_st(dev_priv, stdu);
 
 		return 0;
 	}
@@ -982,16 +698,13 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 	}
 
 	/* Update display surface: after this point everything is bound */
-	update_area.x2 = stdu->display_srf->base_size.width;
-	update_area.y2 = stdu->display_srf->base_size.height;
-
-	file_priv = event->base.file_priv;
-	ret = vmw_stdu_update_st(dev_priv, file_priv, stdu, &update_area);
+	ret = vmw_stdu_update_st(dev_priv, stdu);
 	if (unlikely(ret != 0))
 		return ret;
 
 	if (event) {
 		struct vmw_fence_obj *fence = NULL;
+		struct drm_file *file_priv = event->base.file_priv;
 
 		vmw_execbuf_fence_commands(NULL, dev_priv, &fence, NULL);
 		if (!fence)
@@ -1016,6 +729,310 @@ static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
 }
 
 
+/**
+ * vmw_stdu_dmabuf_clip - Callback to encode a suface DMA command cliprect
+ *
+ * @dirty: The closure structure.
+ *
+ * Encodes a surface DMA command cliprect and updates the bounding box
+ * for the DMA.
+ */
+static void vmw_stdu_dmabuf_clip(struct vmw_kms_dirty *dirty)
+{
+	struct vmw_stdu_dirty *ddirty =
+		container_of(dirty, struct vmw_stdu_dirty, base);
+	struct vmw_stdu_dma *cmd = dirty->cmd;
+	struct SVGA3dCopyBox *blit = (struct SVGA3dCopyBox *) &cmd[1];
+
+	blit += dirty->num_hits;
+	blit->srcx = dirty->fb_x;
+	blit->srcy = dirty->fb_y;
+	blit->x = dirty->unit_x1;
+	blit->y = dirty->unit_y1;
+	blit->d = 1;
+	blit->w = dirty->unit_x2 - dirty->unit_x1;
+	blit->h = dirty->unit_y2 - dirty->unit_y1;
+	dirty->num_hits++;
+
+	if (ddirty->transfer != SVGA3D_WRITE_HOST_VRAM)
+		return;
+
+	/* Destination bounding box */
+	ddirty->left = min_t(s32, ddirty->left, dirty->unit_x1);
+	ddirty->top = min_t(s32, ddirty->top, dirty->unit_y1);
+	ddirty->right = max_t(s32, ddirty->right, dirty->unit_x2);
+	ddirty->bottom = max_t(s32, ddirty->bottom, dirty->unit_y2);
+}
+
+/**
+ * vmw_stdu_dmabuf_fifo_commit - Callback to fill in and submit a DMA command.
+ *
+ * @dirty: The closure structure.
+ *
+ * Fills in the missing fields in a DMA command, and optionally encodes
+ * a screen target update command, depending on transfer direction.
+ */
+static void vmw_stdu_dmabuf_fifo_commit(struct vmw_kms_dirty *dirty)
+{
+	struct vmw_stdu_dirty *ddirty =
+		container_of(dirty, struct vmw_stdu_dirty, base);
+	struct vmw_screen_target_display_unit *stdu =
+		container_of(dirty->unit, typeof(*stdu), base);
+	struct vmw_stdu_dma *cmd = dirty->cmd;
+	struct SVGA3dCopyBox *blit = (struct SVGA3dCopyBox *) &cmd[1];
+	SVGA3dCmdSurfaceDMASuffix *suffix =
+		(SVGA3dCmdSurfaceDMASuffix *) &blit[dirty->num_hits];
+	size_t blit_size = sizeof(*blit) * dirty->num_hits + sizeof(*suffix);
+
+	if (!dirty->num_hits) {
+		vmw_fifo_commit(dirty->dev_priv, 0);
+		return;
+	}
+
+	cmd->header.id = SVGA_3D_CMD_SURFACE_DMA;
+	cmd->header.size = sizeof(cmd->body) + blit_size;
+	vmw_bo_get_guest_ptr(&ddirty->buf->base, &cmd->body.guest.ptr);
+	cmd->body.guest.pitch = ddirty->pitch;
+	cmd->body.host.sid = stdu->display_srf->res.id;
+	cmd->body.host.face = 0;
+	cmd->body.host.mipmap = 0;
+	cmd->body.transfer = ddirty->transfer;
+	suffix->suffixSize = sizeof(*suffix);
+	suffix->maximumOffset = ddirty->buf->base.num_pages * PAGE_SIZE;
+
+	if (ddirty->transfer == SVGA3D_WRITE_HOST_VRAM) {
+		blit_size += sizeof(struct vmw_stdu_update);
+
+		vmw_stdu_populate_update(&suffix[1], stdu->base.unit,
+					 ddirty->left, ddirty->right,
+					 ddirty->top, ddirty->bottom);
+	}
+
+	vmw_fifo_commit(dirty->dev_priv, sizeof(*cmd) + blit_size);
+
+	ddirty->left = ddirty->top = S32_MAX;
+	ddirty->right = ddirty->bottom = S32_MIN;
+}
+
+/**
+ * vmw_kms_stdu_dma - Perform a DMA transfer between a dma-buffer backed
+ * framebuffer and the screen target system.
+ *
+ * @dev_priv: Pointer to the device private structure.
+ * @file_priv: Pointer to a struct drm-file identifying the caller. May be
+ * set to NULL, but then @user_fence_rep must also be set to NULL.
+ * @vfb: Pointer to the dma-buffer backed framebuffer.
+ * @clips: Array of clip rects. Either @clips or @vclips must be NULL.
+ * @vclips: Alternate array of clip rects. Either @clips or @vclips must
+ * be NULL.
+ * @num_clips: Number of clip rects in @clips or @vclips.
+ * @increment: Increment to use when looping over @clips or @vclips.
+ * @to_surface: Whether to DMA to the screen target system as opposed to
+ * from the screen target system.
+ * @interruptible: Whether to perform waits interruptible if possible.
+ *
+ * If DMA-ing till the screen target system, the function will also notify
+ * the screen target system that a bounding box of the cliprects has been
+ * updated.
+ * Returns 0 on success, negative error code on failure. -ERESTARTSYS if
+ * interrupted.
+ */
+int vmw_kms_stdu_dma(struct vmw_private *dev_priv,
+		     struct drm_file *file_priv,
+		     struct vmw_framebuffer *vfb,
+		     struct drm_vmw_fence_rep __user *user_fence_rep,
+		     struct drm_clip_rect *clips,
+		     struct drm_vmw_rect *vclips,
+		     uint32_t num_clips,
+		     int increment,
+		     bool to_surface,
+		     bool interruptible)
+{
+	struct vmw_dma_buffer *buf =
+		container_of(vfb, struct vmw_framebuffer_dmabuf, base)->buffer;
+	struct vmw_stdu_dirty ddirty;
+	int ret;
+
+	ret = vmw_kms_helper_buffer_prepare(dev_priv, buf, interruptible,
+					    false);
+	if (ret)
+		return ret;
+
+	ddirty.transfer = (to_surface) ? SVGA3D_WRITE_HOST_VRAM :
+		SVGA3D_READ_HOST_VRAM;
+	ddirty.left = ddirty.top = S32_MAX;
+	ddirty.right = ddirty.bottom = S32_MIN;
+	ddirty.pitch = vfb->base.pitches[0];
+	ddirty.buf = buf;
+	ddirty.base.fifo_commit = vmw_stdu_dmabuf_fifo_commit;
+	ddirty.base.clip = vmw_stdu_dmabuf_clip;
+	ddirty.base.fifo_reserve_size = sizeof(struct vmw_stdu_dma) +
+		num_clips * sizeof(SVGA3dCopyBox) +
+		sizeof(SVGA3dCmdSurfaceDMASuffix);
+	if (to_surface)
+		ddirty.base.fifo_reserve_size += sizeof(struct vmw_stdu_update);
+
+	ret = vmw_kms_helper_dirty(dev_priv, vfb, clips, vclips,
+				   0, 0, num_clips, increment, &ddirty.base);
+	vmw_kms_helper_buffer_finish(dev_priv, file_priv, buf, NULL,
+				     user_fence_rep);
+
+	return ret;
+}
+
+/**
+ * vmw_stdu_surface_clip - Callback to encode a surface copy command cliprect
+ *
+ * @dirty: The closure structure.
+ *
+ * Encodes a surface copy command cliprect and updates the bounding box
+ * for the copy.
+ */
+static void vmw_kms_stdu_surface_clip(struct vmw_kms_dirty *dirty)
+{
+	struct vmw_stdu_dirty *sdirty =
+		container_of(dirty, struct vmw_stdu_dirty, base);
+	struct vmw_stdu_surface_copy *cmd = dirty->cmd;
+	struct vmw_screen_target_display_unit *stdu =
+		container_of(dirty->unit, typeof(*stdu), base);
+
+	if (sdirty->sid != stdu->display_srf->res.id) {
+		struct SVGA3dCopyBox *blit = (struct SVGA3dCopyBox *) &cmd[1];
+
+		blit += dirty->num_hits;
+		blit->srcx = dirty->fb_x;
+		blit->srcy = dirty->fb_y;
+		blit->x = dirty->unit_x1;
+		blit->y = dirty->unit_y1;
+		blit->d = 1;
+		blit->w = dirty->unit_x2 - dirty->unit_x1;
+		blit->h = dirty->unit_y2 - dirty->unit_y1;
+	}
+
+	dirty->num_hits++;
+
+	/* Destination bounding box */
+	sdirty->left = min_t(s32, sdirty->left, dirty->unit_x1);
+	sdirty->top = min_t(s32, sdirty->top, dirty->unit_y1);
+	sdirty->right = max_t(s32, sdirty->right, dirty->unit_x2);
+	sdirty->bottom = max_t(s32, sdirty->bottom, dirty->unit_y2);
+}
+
+/**
+ * vmw_stdu_surface_fifo_commit - Callback to fill in and submit a surface
+ * copy command.
+ *
+ * @dirty: The closure structure.
+ *
+ * Fills in the missing fields in a surface copy command, and encodes a screen
+ * target update command.
+ */
+static void vmw_kms_stdu_surface_fifo_commit(struct vmw_kms_dirty *dirty)
+{
+	struct vmw_stdu_dirty *sdirty =
+		container_of(dirty, struct vmw_stdu_dirty, base);
+	struct vmw_screen_target_display_unit *stdu =
+		container_of(dirty->unit, typeof(*stdu), base);
+	struct vmw_stdu_surface_copy *cmd = dirty->cmd;
+	struct vmw_stdu_update *update;
+	size_t blit_size = sizeof(SVGA3dCopyBox) * dirty->num_hits;
+	size_t commit_size;
+
+	if (!dirty->num_hits) {
+		vmw_fifo_commit(dirty->dev_priv, 0);
+		return;
+	}
+
+	if (sdirty->sid != stdu->display_srf->res.id) {
+		struct SVGA3dCopyBox *blit = (struct SVGA3dCopyBox *) &cmd[1];
+
+		cmd->header.id = SVGA_3D_CMD_SURFACE_COPY;
+		cmd->header.size = sizeof(cmd->body) + blit_size;
+		cmd->body.src.sid = sdirty->sid;
+		cmd->body.dest.sid = stdu->display_srf->res.id;
+		update = (struct vmw_stdu_update *) &blit[dirty->num_hits];
+		commit_size = sizeof(*cmd) + blit_size + sizeof(*update);
+	} else {
+		update = dirty->cmd;
+		commit_size = sizeof(*update);
+	}
+
+	vmw_stdu_populate_update(update, stdu->base.unit, sdirty->left,
+				 sdirty->right, sdirty->top, sdirty->bottom);
+
+	vmw_fifo_commit(dirty->dev_priv, commit_size);
+
+	sdirty->left = sdirty->top = S32_MAX;
+	sdirty->right = sdirty->bottom = S32_MIN;
+}
+
+/**
+ * vmw_kms_stdu_surface_dirty - Dirty part of a surface backed framebuffer
+ *
+ * @dev_priv: Pointer to the device private structure.
+ * @framebuffer: Pointer to the surface-buffer backed framebuffer.
+ * @clips: Array of clip rects. Either @clips or @vclips must be NULL.
+ * @vclips: Alternate array of clip rects. Either @clips or @vclips must
+ * be NULL.
+ * @srf: Pointer to surface to blit from. If NULL, the surface attached
+ * to @framebuffer will be used.
+ * @dest_x: X coordinate offset to align @srf with framebuffer coordinates.
+ * @dest_y: Y coordinate offset to align @srf with framebuffer coordinates.
+ * @num_clips: Number of clip rects in @clips.
+ * @inc: Increment to use when looping over @clips.
+ * @out_fence: If non-NULL, will return a ref-counted pointer to a
+ * struct vmw_fence_obj. The returned fence pointer may be NULL in which
+ * case the device has already synchronized.
+ *
+ * Returns 0 on success, negative error code on failure. -ERESTARTSYS if
+ * interrupted.
+ */
+int vmw_kms_stdu_surface_dirty(struct vmw_private *dev_priv,
+			       struct vmw_framebuffer *framebuffer,
+			       struct drm_clip_rect *clips,
+			       struct drm_vmw_rect *vclips,
+			       struct vmw_resource *srf,
+			       s32 dest_x,
+			       s32 dest_y,
+			       unsigned num_clips, int inc,
+			       struct vmw_fence_obj **out_fence)
+{
+	struct vmw_framebuffer_surface *vfbs =
+		container_of(framebuffer, typeof(*vfbs), base);
+	struct vmw_stdu_dirty sdirty;
+	int ret;
+
+	if (!srf)
+		srf = &vfbs->surface->res;
+
+	ret = vmw_kms_helper_resource_prepare(srf, true);
+	if (ret)
+		return ret;
+
+	if (vfbs->is_dmabuf_proxy) {
+		ret = vmw_kms_update_proxy(srf, clips, num_clips, inc);
+		if (ret)
+			goto out_finish;
+	}
+
+	sdirty.base.fifo_commit = vmw_kms_stdu_surface_fifo_commit;
+	sdirty.base.clip = vmw_kms_stdu_surface_clip;
+	sdirty.base.fifo_reserve_size = sizeof(struct vmw_stdu_surface_copy) +
+		sizeof(SVGA3dCopyBox) * num_clips +
+		sizeof(struct vmw_stdu_update);
+	sdirty.sid = srf->id;
+	sdirty.left = sdirty.top = S32_MAX;
+	sdirty.right = sdirty.bottom = S32_MIN;
+
+	ret = vmw_kms_helper_dirty(dev_priv, framebuffer, clips, vclips,
+				   dest_x, dest_y, num_clips, inc,
+				   &sdirty.base);
+out_finish:
+	vmw_kms_helper_resource_finish(srf, out_fence);
+
+	return ret;
+}
+
 
 /*
  *  Screen Target CRTC dispatch table
@@ -1122,7 +1139,6 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
 	stdu->base.pref_active = (unit == 0);
 	stdu->base.pref_width  = dev_priv->initial_width;
 	stdu->base.pref_height = dev_priv->initial_height;
-	stdu->base.pref_mode   = NULL;
 	stdu->base.is_implicit = true;
 
 	drm_connector_init(dev, connector, &vmw_stdu_connector_funcs,
@@ -1207,6 +1223,8 @@ int vmw_kms_stdu_init_display(struct vmw_private *dev_priv)
 	if (unlikely(ret != 0))
 		goto err_vblank_cleanup;
 
+	dev_priv->active_display_unit = vmw_du_screen_target;
+
 	for (i = 0; i < VMWGFX_NUM_DISPLAY_UNITS; ++i) {
 		ret = vmw_stdu_init(dev_priv, i);
 
@@ -1216,8 +1234,6 @@ int vmw_kms_stdu_init_display(struct vmw_private *dev_priv)
 		}
 	}
 
-	dev_priv->active_display_unit = vmw_du_screen_target;
-
 	DRM_INFO("Screen Target Display device initialized\n");
 
 	return 0;
@@ -1247,247 +1263,3 @@ int vmw_kms_stdu_close_display(struct vmw_private *dev_priv)
 
 	return 0;
 }
-
-
-
-/**
- * vmw_kms_stdu_do_surface_dirty - updates a dirty rectange to SVGA device
- *
- * @dev_priv: VMW DRM device
- * @file_priv: Pointer to a drm file private structure
- * @framebuffer: FB with the new content to be copied to SVGA device
- * @clip_rects: array of dirty rectanges
- * @num_of_clip_rects: number of rectanges in @clips
- * @increment: increment to the next dirty rect in @clips
- *
- * This function sends an Update command to the SVGA device.  This will notify
- * the device that a region needs to be copied to the screen.  At this time
- * we are not coalescing clip rects into one large clip rect because the SVGA
- * device will do it for us.
- *
- * RETURNS:
- * 0 on success, error code otherwise
- */
-int vmw_kms_stdu_do_surface_dirty(struct vmw_private *dev_priv,
-				  struct drm_file *file_priv,
-				  struct vmw_framebuffer *framebuffer,
-				  struct drm_clip_rect *clip_rects,
-				  unsigned num_of_clip_rects, int increment)
-{
-	struct vmw_screen_target_display_unit *stdu[VMWGFX_NUM_DISPLAY_UNITS];
-	struct drm_clip_rect *cur_rect;
-	struct drm_crtc *crtc;
-
-	unsigned num_of_du = 0, cur_du, count = 0;
-	int      ret = 0;
-
-
-	BUG_ON(!clip_rects || !num_of_clip_rects);
-
-	/* Figure out all the DU affected by this surface */
-	list_for_each_entry(crtc, &dev_priv->dev->mode_config.crtc_list,
-			    head) {
-		if (crtc->primary->fb != &framebuffer->base)
-			continue;
-
-		stdu[num_of_du++] = vmw_crtc_to_stdu(crtc);
-	}
-
-	for (cur_du = 0; cur_du < num_of_du; cur_du++)
-		for (cur_rect = clip_rects, count = 0;
-		     count < num_of_clip_rects && ret == 0;
-		     cur_rect += increment, count++) {
-			ret = vmw_stdu_update_st(dev_priv, file_priv,
-						 stdu[cur_du],
-						 cur_rect);
-		}
-
-	return ret;
-}
-
-
-
-/**
- * vmw_kms_stdu_present - present a surface to the display surface
- *
- * @dev_priv: VMW DRM device
- * @file_priv: Pointer to a drm file private structure
- * @vfb: Used to pick which STDU(s) is affected
- * @user_handle: user handle for the source surface
- * @dest_x: top/left corner of the display area to blit to
- * @dest_y: top/left corner of the display area to blit to
- * @clip_rects: array of dirty rectanges
- * @num_of_clip_rects: number of rectanges in @clips
- *
- * This function copies a surface onto the display surface, and
- * updates the screen target.  Strech blit is currently not
- * supported.
- *
- * RETURNS:
- * 0 on success, error code otherwise
- */
-int vmw_kms_stdu_present(struct vmw_private *dev_priv,
-			 struct drm_file *file_priv,
-			 struct vmw_framebuffer *vfb,
-			 uint32_t user_handle,
-			 int32_t dest_x, int32_t dest_y,
-			 struct drm_vmw_rect *clip_rects,
-			 uint32_t num_of_clip_rects)
-{
-	struct vmw_screen_target_display_unit *stdu[VMWGFX_NUM_DISPLAY_UNITS];
-	struct drm_clip_rect *update_area;
-	struct drm_crtc *crtc;
-	size_t fifo_size;
-	int num_of_du = 0, cur_du, i;
-	int ret = 0;
-	struct vmw_clip_rect src_bb;
-
-	struct {
-		SVGA3dCmdHeader      header;
-		SVGA3dCmdSurfaceCopy body;
-	} *cmd;
-	SVGA3dCopyBox *blits;
-
-
-	BUG_ON(!clip_rects || !num_of_clip_rects);
-
-	list_for_each_entry(crtc, &dev_priv->dev->mode_config.crtc_list, head) {
-		if (crtc->primary->fb != &vfb->base)
-			continue;
-
-		stdu[num_of_du++] = vmw_crtc_to_stdu(crtc);
-	}
-
-
-	update_area = kcalloc(num_of_clip_rects, sizeof(*update_area),
-			      GFP_KERNEL);
-	if (unlikely(update_area == NULL)) {
-		DRM_ERROR("Temporary clip rect memory alloc failed.\n");
-		return -ENOMEM;
-	}
-
-
-	fifo_size = sizeof(*cmd) + sizeof(SVGA3dCopyBox) * num_of_clip_rects;
-
-	cmd = kmalloc(fifo_size, GFP_KERNEL);
-	if (unlikely(cmd == NULL)) {
-		DRM_ERROR("Failed to allocate memory for surface copy.\n");
-		ret = -ENOMEM;
-		goto out_free_update_area;
-	}
-
-	memset(cmd, 0, fifo_size);
-	cmd->header.id = SVGA_3D_CMD_SURFACE_COPY;
-
-	blits = (SVGA3dCopyBox *)&cmd[1];
-
-
-	/* Figure out the source bounding box */
-	src_bb.x1 = clip_rects->x;
-	src_bb.y1 = clip_rects->y;
-	src_bb.x2 = clip_rects->x + clip_rects->w;
-	src_bb.y2 = clip_rects->y + clip_rects->h;
-
-	for (i = 1; i < num_of_clip_rects; i++) {
-		src_bb.x1 = min_t(int, src_bb.x1, clip_rects[i].x);
-		src_bb.x2 = max_t(int, src_bb.x2,
-				  clip_rects[i].x + (int) clip_rects[i].w);
-		src_bb.y1 = min_t(int, src_bb.y1, clip_rects[i].y);
-		src_bb.y2 = max_t(int, src_bb.y2,
-				  clip_rects[i].y + (int) clip_rects[i].h);
-	}
-
-	for (i = 0; i < num_of_clip_rects; i++) {
-		update_area[i].x1 = clip_rects[i].x - src_bb.x1;
-		update_area[i].x2 = update_area[i].x1 + clip_rects[i].w;
-		update_area[i].y1 = clip_rects[i].y - src_bb.y1;
-		update_area[i].y2 = update_area[i].y1 + clip_rects[i].h;
-	}
-
-
-	for (cur_du = 0; cur_du < num_of_du; cur_du++) {
-		struct vmw_clip_rect dest_bb;
-		int num_of_blits;
-
-		crtc = &stdu[cur_du]->base.crtc;
-
-		dest_bb.x1 = src_bb.x1 + dest_x - crtc->x;
-		dest_bb.y1 = src_bb.y1 + dest_y - crtc->y;
-		dest_bb.x2 = src_bb.x2 + dest_x - crtc->x;
-		dest_bb.y2 = src_bb.y2 + dest_y - crtc->y;
-
-		/* Skip any STDU outside of the destination bounding box */
-		if (dest_bb.x1 >= crtc->mode.hdisplay ||
-		    dest_bb.y1 >= crtc->mode.vdisplay ||
-		    dest_bb.x2 <= 0 || dest_bb.y2 <= 0)
-			continue;
-
-		/* Normalize to top-left of src bounding box in dest coord */
-		dest_bb.x2 = crtc->mode.hdisplay - dest_bb.x1;
-		dest_bb.y2 = crtc->mode.vdisplay - dest_bb.y1;
-		dest_bb.x1 = 0 - dest_bb.x1;
-		dest_bb.y1 = 0 - dest_bb.y1;
-
-		for (i = 0, num_of_blits = 0; i < num_of_clip_rects; i++) {
-			int x1 = max_t(int, dest_bb.x1, (int)update_area[i].x1);
-			int y1 = max_t(int, dest_bb.y1, (int)update_area[i].y1);
-			int x2 = min_t(int, dest_bb.x2, (int)update_area[i].x2);
-			int y2 = min_t(int, dest_bb.y2, (int)update_area[i].y2);
-
-			if (x1 >= x2)
-				continue;
-
-			if (y1 >= y2)
-				continue;
-
-			blits[num_of_blits].srcx =  src_bb.x1  + x1;
-			blits[num_of_blits].srcy =  src_bb.y1  + y1;
-			blits[num_of_blits].x    = -dest_bb.x1 + x1;
-			blits[num_of_blits].y    = -dest_bb.y1 + y1;
-			blits[num_of_blits].d    = 1;
-			blits[num_of_blits].w    = x2 - x1;
-			blits[num_of_blits].h    = y2 - y1;
-			num_of_blits++;
-		}
-
-		if (num_of_blits == 0)
-			continue;
-
-		/* Calculate new command size */
-		fifo_size = sizeof(*cmd) + sizeof(SVGA3dCopyBox) * num_of_blits;
-
-		cmd->header.size = cpu_to_le32(fifo_size - sizeof(cmd->header));
-
-		cmd->body.src.sid  = user_handle;
-		cmd->body.dest.sid = stdu[cur_du]->display_srf->res.id;
-
-		ret = vmw_execbuf_process(file_priv, dev_priv, NULL, cmd,
-					  fifo_size, 0, VMW_QUIRK_DST_SID_OK,
-					  NULL, NULL);
-
-		if (unlikely(ret != 0))
-			break;
-
-		for (i = 0; i < num_of_blits; i++) {
-			struct drm_clip_rect blit_area;
-
-			/*
-			 * Add crtc offset because vmw_stdu_update_st expects
-			 * desktop coordinates
-			 */
-			blit_area.x1 = blits[i].x + crtc->x;
-			blit_area.x2 = blit_area.x1 + blits[i].w;
-			blit_area.y1 = blits[i].y + crtc->y;
-			blit_area.y2 = blit_area.y1 + blits[i].h;
-			(void) vmw_stdu_update_st(dev_priv, NULL, stdu[cur_du],
-						  &blit_area);
-		}
-	}
-
-	kfree(cmd);
-
-out_free_update_area:
-	kfree(update_area);
-
-	return ret;
-}

commit 1a4b172ac96edd7f571772e83c09c5a18718a4fa
Author: Thomas Hellstrom <thellstrom@vmware.com>
Date:   Fri Jun 26 02:03:53 2015 -0700

    drm/vmwgfx: Add kms helpers for dirty- and readback functions
    
    We need to make the dirty- and readback functions callable without a struct
    drm_file pointer. We also need to unify the handling of dirty- and readback
    cliprects that are now implemented in various places across the kms system,
    som add helpers to facilitate this.
    
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
    Reviewed-by: Sinclair Yeh <syeh@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index ef99df7463f3..becf9650c228 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -91,7 +91,7 @@ static void vmw_stdu_destroy(struct vmw_screen_target_display_unit *stdu);
  */
 static int vmw_stdu_pin_display(struct vmw_screen_target_display_unit *stdu)
 {
-	return vmw_resource_pin(&stdu->display_srf->res);
+	return vmw_resource_pin(&stdu->display_srf->res, false);
 }
 
 

commit f89c6c321c4a7c0188922f331b70d83af01ab53e
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Fri Jun 26 01:54:28 2015 -0700

    drm/vmwgfx: Replace SurfaceDMA usage with SurfaceCopy in 2D VMs
    
    This patch address the following underlying issues with SurfaceDMA
    
    * SurfaceDMA command does not work in a 2D VM, but we can wrap a
      proxy surface around the same DMA buffer and use the SurfaceCopy
      command which does work in a 2D VM.
    
    * Wrapping a DMA buffer with a proxy surface also gives us an
      added optimization path for the case when the DMA buf
      dimensions match the mode.  In this case, the DMA buf can
      be pinned as the display surface, saving an extra copy.
      This only works in a 2D VM because we won't be doing any
      rendering operations directly to the display surface.
    
    v2
    * Moved is_dmabuf_proxy field to vmw_framebuffer_surface
    * Undone coding style changes
    * Addressed other issues from review
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 3b8235c7ee42..ef99df7463f3 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -141,6 +141,63 @@ static void vmw_stdu_crtc_destroy(struct drm_crtc *crtc)
 
 
 
+/**
+ * vmw_stdu_dma_update - Update DMA buf dirty region on the SVGA device
+ *
+ * @dev_priv:  VMW DRM device
+ * @file_priv: Pointer to a drm file private structure
+ * @vfbs: VMW framebuffer surface that may need a DMA buf update
+ * @x: top/left corner of the content area to blit from
+ * @y: top/left corner of the content area to blit from
+ * @width: width of the blit area
+ * @height: height of the blit area
+ *
+ * The SVGA device may have the DMA buf cached, so before letting the
+ * device use it as the source image for a subsequent operation, we
+ * update the cached copy.
+ *
+ * RETURNs:
+ * 0 on success, error code on failure
+ */
+static int vmw_stdu_dma_update(struct vmw_private *dev_priv,
+			       struct drm_file *file_priv,
+			       struct vmw_framebuffer_surface *vfbs,
+			       uint32_t x, uint32_t y,
+			       uint32_t width, uint32_t height)
+{
+	size_t fifo_size;
+	struct {
+		SVGA3dCmdHeader header;
+		SVGA3dCmdUpdateGBImage body;
+	} img_update_cmd;
+
+
+	/* Only need to do this if the surface is a DMA buf proxy */
+	if (!vfbs->is_dmabuf_proxy)
+		return 0;
+
+	fifo_size = sizeof(img_update_cmd);
+
+	memset(&img_update_cmd, 0, fifo_size);
+	img_update_cmd.header.id   = SVGA_3D_CMD_UPDATE_GB_IMAGE;
+	img_update_cmd.header.size = sizeof(img_update_cmd.body);
+
+	img_update_cmd.body.image.sid = vfbs->surface->res.id;
+
+	img_update_cmd.body.box.x = x;
+	img_update_cmd.body.box.y = y;
+	img_update_cmd.body.box.w = width;
+	img_update_cmd.body.box.h = height;
+	img_update_cmd.body.box.d = 1;
+
+	return vmw_execbuf_process(file_priv, dev_priv, NULL,
+				   (void *) &img_update_cmd,
+				   fifo_size, 0, VMW_QUIRK_SRC_SID_OK,
+				   NULL, NULL);
+}
+
+
+
 /**
  * vmw_stdu_content_copy - copies an area from the content to display surface
  *
@@ -166,11 +223,13 @@ static int vmw_stdu_content_copy(struct vmw_private *dev_priv,
 				 uint32_t width, uint32_t height,
 				 uint32_t display_x, uint32_t display_y)
 {
-	size_t fifo_size;
+	struct vmw_framebuffer_surface *content_vfbs;
+	size_t fifo_size;	
 	int ret;
 	void *cmd;
+	u32 quirks = VMW_QUIRK_DST_SID_OK;
 
-	struct vmw_surface_dma {
+	struct {
 		SVGA3dCmdHeader     header;
 		SVGA3dCmdSurfaceDMA body;
 		SVGA3dCopyBox       area;
@@ -193,24 +252,43 @@ static int vmw_stdu_content_copy(struct vmw_private *dev_priv,
 		return -EINVAL;
 	}
 
+
 	if (stdu->content_fb_type == SEPARATE_DMA) {
 		struct vmw_framebuffer *content_vfb;
-		struct vmw_framebuffer_dmabuf *content_vfbd;
-		struct vmw_framebuffer_surface *content_vfbs;
 		struct drm_vmw_size cur_size = {0};
 		const struct svga3d_surface_desc *desc;
+		enum SVGA3dSurfaceFormat format;
 		SVGA3dCmdSurfaceDMASuffix *suffix;
 		SVGAGuestPtr ptr;
 
+
 		content_vfb  = vmw_framebuffer_to_vfb(stdu->content_fb);
-		content_vfbd = vmw_framebuffer_to_vfbd(stdu->content_fb);
-		content_vfbs = vmw_framebuffer_to_vfbs(stdu->content_fb);
 
 		cur_size.width  = width;
 		cur_size.height = height;
 		cur_size.depth  = 1;
 
-		desc = svga3dsurface_get_desc(content_vfbs->surface->format);
+		/* Derive a SVGA3dSurfaceFormat for the DMA buf */
+		switch (content_vfb->base.bits_per_pixel) {
+		case 32:
+			format = SVGA3D_A8R8G8B8;
+			break;
+		case 24:
+			format = SVGA3D_X8R8G8B8;
+			break;
+		case 16:
+			format = SVGA3D_R5G6B5;
+			break;
+		case 15:
+			format = SVGA3D_A1R5G5B5;
+			break;
+		default:
+			DRM_ERROR("Invalid color depth: %d\n",
+					content_vfb->base.depth);
+			return -EINVAL;
+		}
+
+		desc = svga3dsurface_get_desc(format);
 
 
 		fifo_size = sizeof(surface_dma_cmd);
@@ -250,19 +328,40 @@ static int vmw_stdu_content_copy(struct vmw_private *dev_priv,
 
 		cmd = (void *) &surface_dma_cmd;
 	} else {
-		struct vmw_framebuffer *content_vfb;
+		u32 src_id;
+
+
+		content_vfbs = vmw_framebuffer_to_vfbs(stdu->content_fb);
+
+		if (content_vfbs->is_dmabuf_proxy) {
+			ret = vmw_stdu_dma_update(dev_priv, file_priv,
+						  content_vfbs,
+						  content_x, content_y,
+						  width, height);
+
+			if (ret != 0) {
+				DRM_ERROR("Failed to update cached DMA buf\n");
+				return ret;
+			}
 
-		content_vfb = vmw_framebuffer_to_vfb(stdu->content_fb);
+			quirks |= VMW_QUIRK_SRC_SID_OK;
+			src_id = content_vfbs->surface->res.id;
+		} else {
+			struct vmw_framebuffer *content_vfb;
 
+			content_vfb = vmw_framebuffer_to_vfb(stdu->content_fb);
+			src_id = content_vfb->user_handle;
+		}
+ 
 		fifo_size = sizeof(surface_cpy_cmd);
 
-		memset(&surface_cpy_cmd, 0, sizeof(surface_cpy_cmd));
+		memset(&surface_cpy_cmd, 0, fifo_size);
 
 		surface_cpy_cmd.header.id   = SVGA_3D_CMD_SURFACE_COPY;
 		surface_cpy_cmd.header.size = sizeof(surface_cpy_cmd.body) +
 					      sizeof(surface_cpy_cmd.area);
 
-		surface_cpy_cmd.body.src.sid  = content_vfb->user_handle;
+		surface_cpy_cmd.body.src.sid  = src_id;
 		surface_cpy_cmd.body.dest.sid = stdu->display_srf->res.id;
 
 		surface_cpy_cmd.area.srcx = content_x;
@@ -276,8 +375,11 @@ static int vmw_stdu_content_copy(struct vmw_private *dev_priv,
 		cmd = (void *) &surface_cpy_cmd;
 	}
 
-	ret = vmw_execbuf_process(file_priv, dev_priv, NULL, cmd,
-				  fifo_size, 0, VMW_QUIRK_SCREENTARGET,
+
+
+	ret = vmw_execbuf_process(file_priv, dev_priv, NULL,
+				  (void *) cmd,
+				  fifo_size, 0, quirks,
 				  NULL, NULL);
 
 	return ret;
@@ -391,7 +493,8 @@ static int vmw_stdu_bind_st(struct vmw_private *dev_priv,
  * vmw_stdu_update_st - Updates a Screen Target
  *
  * @dev_priv: VMW DRM device
- * @file_priv: Pointer to a drm file private structure
+ * @file_priv: Pointer to DRM file private structure.  Set to NULL when
+ *             we want to blank display.
  * @stdu: display unit affected
  * @update_area: area that needs to be updated
  *
@@ -412,6 +515,7 @@ static int vmw_stdu_update_st(struct vmw_private *dev_priv,
 	u32 width, height;
 	u32 display_update_x, display_update_y;
 	unsigned short display_x1, display_y1, display_x2, display_y2;
+	int ret;
 
 	struct {
 		SVGA3dCmdHeader header;
@@ -444,8 +548,11 @@ static int vmw_stdu_update_st(struct vmw_private *dev_priv,
 	height = min(update_area->y2, display_y2) -
 		 max(update_area->y1, display_y1);
 
+	/*
+	 * If content is on a separate surface, then copy the dirty area to
+	 * the display surface
+	 */
 	if (file_priv && stdu->content_fb_type != SAME_AS_DISPLAY) {
-		int ret;
 
 		ret = vmw_stdu_content_copy(dev_priv, file_priv,
 					    stdu,
@@ -459,6 +566,29 @@ static int vmw_stdu_update_st(struct vmw_private *dev_priv,
 		}
 	}
 
+
+	/*
+	 * If the display surface is the same as the content surface, then
+	 * it may be backed by a DMA buf.  If it is then we need to update
+	 * the device's cached copy of the DMA buf before issuing the screen
+	 * target update.
+	 */
+	if (file_priv && stdu->content_fb_type == SAME_AS_DISPLAY) {
+		struct vmw_framebuffer_surface *vfbs;
+
+		vfbs = vmw_framebuffer_to_vfbs(stdu->content_fb);
+		ret = vmw_stdu_dma_update(dev_priv, file_priv,
+					  vfbs,
+					  max(update_area->x1, display_x1),
+					  max(update_area->y1, display_y1),
+					  width, height);
+
+		if (ret != 0) {
+			DRM_ERROR("Failed to update cached DMA buffer\n");
+			return ret;
+		}
+	}
+
 	cmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));
 
 	if (unlikely(cmd == NULL)) {
@@ -1066,8 +1196,7 @@ int vmw_kms_stdu_init_display(struct vmw_private *dev_priv)
 	if (!VMWGFX_ENABLE_SCREEN_TARGET_OTABLE)
 		return -ENOSYS;
 
-	if (!(dev_priv->capabilities & SVGA_CAP_GBOBJECTS) ||
-	    !(dev_priv->capabilities & SVGA_CAP_3D))
+	if (!(dev_priv->capabilities & SVGA_CAP_GBOBJECTS))
 		return -ENOSYS;
 
 	ret = drm_vblank_init(dev, VMWGFX_NUM_DISPLAY_UNITS);
@@ -1333,7 +1462,7 @@ int vmw_kms_stdu_present(struct vmw_private *dev_priv,
 		cmd->body.dest.sid = stdu[cur_du]->display_srf->res.id;
 
 		ret = vmw_execbuf_process(file_priv, dev_priv, NULL, cmd,
-					  fifo_size, 0, VMW_QUIRK_SCREENTARGET,
+					  fifo_size, 0, VMW_QUIRK_DST_SID_OK,
 					  NULL, NULL);
 
 		if (unlikely(ret != 0))

commit 35c051258e8fd7cb97222f4aa887bcd404c156d0
Author: Sinclair Yeh <syeh@vmware.com>
Date:   Fri Jun 26 01:42:06 2015 -0700

    drm/vmwgfx: Implement screen targets
    
    Add support for the screen target device interface.
    Add a getparam parameter and bump minor to signal availability.
    
    Signed-off-by: Sinclair Yeh <syeh@vmware.com>
    Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
new file mode 100644
index 000000000000..3b8235c7ee42
--- /dev/null
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -0,0 +1,1364 @@
+/******************************************************************************
+ *
+ * Copyright © 2014 VMware, Inc., Palo Alto, CA., USA
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ ******************************************************************************/
+
+#include "vmwgfx_kms.h"
+#include "svga3d_surfacedefs.h"
+#include <drm/drm_plane_helper.h>
+
+#define vmw_crtc_to_stdu(x) \
+	container_of(x, struct vmw_screen_target_display_unit, base.crtc)
+#define vmw_encoder_to_stdu(x) \
+	container_of(x, struct vmw_screen_target_display_unit, base.encoder)
+#define vmw_connector_to_stdu(x) \
+	container_of(x, struct vmw_screen_target_display_unit, base.connector)
+
+
+
+enum stdu_content_type {
+	SAME_AS_DISPLAY = 0,
+	SEPARATE_SURFACE,
+	SEPARATE_DMA
+};
+
+
+
+/**
+ * struct vmw_screen_target_display_unit
+ *
+ * @base: VMW specific DU structure
+ * @display_srf: surface to be displayed.  The dimension of this will always
+ *               match the display mode.  If the display mode matches
+ *               content_vfbs dimensions, then this is a pointer into the
+ *               corresponding field in content_vfbs.  If not, then this
+ *               is a separate buffer to which content_vfbs will blit to.
+ * @content_fb: holds the rendered content, can be a surface or DMA buffer
+ * @content_type:  content_fb type
+ * @defined:  true if the current display unit has been initialized
+ */
+struct vmw_screen_target_display_unit {
+	struct vmw_display_unit base;
+
+	struct vmw_surface     *display_srf;
+	struct drm_framebuffer *content_fb;
+
+	enum stdu_content_type content_fb_type;
+
+	bool defined;
+};
+
+
+
+static void vmw_stdu_destroy(struct vmw_screen_target_display_unit *stdu);
+
+
+
+/******************************************************************************
+ * Screen Target Display Unit helper Functions
+ *****************************************************************************/
+
+/**
+ * vmw_stdu_pin_display - pins the resource associated with the display surface
+ *
+ * @stdu: contains the display surface
+ *
+ * Since the display surface can either be a private surface allocated by us,
+ * or it can point to the content surface, we use this function to not pin the
+ * same resource twice.
+ */
+static int vmw_stdu_pin_display(struct vmw_screen_target_display_unit *stdu)
+{
+	return vmw_resource_pin(&stdu->display_srf->res);
+}
+
+
+
+/**
+ * vmw_stdu_unpin_display - unpins the resource associated with display surface
+ *
+ * @stdu: contains the display surface
+ *
+ * If the display surface was privatedly allocated by
+ * vmw_surface_gb_priv_define() and not registered as a framebuffer, then it
+ * won't be automatically cleaned up when all the framebuffers are freed.  As
+ * such, we have to explicitly call vmw_resource_unreference() to get it freed.
+ */
+static void vmw_stdu_unpin_display(struct vmw_screen_target_display_unit *stdu)
+{
+	if (stdu->display_srf) {
+		struct vmw_resource *res = &stdu->display_srf->res;
+
+		vmw_resource_unpin(res);
+
+		if (stdu->content_fb_type != SAME_AS_DISPLAY) {
+			vmw_resource_unreference(&res);
+			stdu->content_fb_type = SAME_AS_DISPLAY;
+		}
+
+		stdu->display_srf = NULL;
+	}
+}
+
+
+
+/******************************************************************************
+ * Screen Target Display Unit CRTC Functions
+ *****************************************************************************/
+
+
+/**
+ * vmw_stdu_crtc_destroy - cleans up the STDU
+ *
+ * @crtc: used to get a reference to the containing STDU
+ */
+static void vmw_stdu_crtc_destroy(struct drm_crtc *crtc)
+{
+	vmw_stdu_destroy(vmw_crtc_to_stdu(crtc));
+}
+
+
+
+/**
+ * vmw_stdu_content_copy - copies an area from the content to display surface
+ *
+ * @dev_priv:  VMW DRM device
+ * @file_priv: Pointer to a drm file private structure
+ * @stdu: STDU whose display surface will be blitted to
+ * @content_x: top/left corner of the content area to blit from
+ * @content_y: top/left corner of the content area to blit from
+ * @width: width of the blit area
+ * @height: height of the blit area
+ * @display_x: top/left corner of the display area to blit to
+ * @display_y: top/left corner of the display area to blit to
+ *
+ * Copies an area from the content surface to the display surface.
+ *
+ * RETURNs:
+ * 0 on success, error code on failure
+ */
+static int vmw_stdu_content_copy(struct vmw_private *dev_priv,
+				 struct drm_file *file_priv,
+				 struct vmw_screen_target_display_unit *stdu,
+				 uint32_t content_x, uint32_t content_y,
+				 uint32_t width, uint32_t height,
+				 uint32_t display_x, uint32_t display_y)
+{
+	size_t fifo_size;
+	int ret;
+	void *cmd;
+
+	struct vmw_surface_dma {
+		SVGA3dCmdHeader     header;
+		SVGA3dCmdSurfaceDMA body;
+		SVGA3dCopyBox       area;
+		SVGA3dCmdSurfaceDMASuffix suffix;
+	} surface_dma_cmd;
+
+	struct {
+		SVGA3dCmdHeader      header;
+		SVGA3dCmdSurfaceCopy body;
+		SVGA3dCopyBox        area;
+	} surface_cpy_cmd;
+
+
+	/*
+	 * Can only copy if content and display surfaces exist and are not
+	 * the same surface
+	 */
+	if (stdu->display_srf == NULL || stdu->content_fb == NULL ||
+	    stdu->content_fb_type == SAME_AS_DISPLAY) {
+		return -EINVAL;
+	}
+
+	if (stdu->content_fb_type == SEPARATE_DMA) {
+		struct vmw_framebuffer *content_vfb;
+		struct vmw_framebuffer_dmabuf *content_vfbd;
+		struct vmw_framebuffer_surface *content_vfbs;
+		struct drm_vmw_size cur_size = {0};
+		const struct svga3d_surface_desc *desc;
+		SVGA3dCmdSurfaceDMASuffix *suffix;
+		SVGAGuestPtr ptr;
+
+		content_vfb  = vmw_framebuffer_to_vfb(stdu->content_fb);
+		content_vfbd = vmw_framebuffer_to_vfbd(stdu->content_fb);
+		content_vfbs = vmw_framebuffer_to_vfbs(stdu->content_fb);
+
+		cur_size.width  = width;
+		cur_size.height = height;
+		cur_size.depth  = 1;
+
+		desc = svga3dsurface_get_desc(content_vfbs->surface->format);
+
+
+		fifo_size = sizeof(surface_dma_cmd);
+
+		memset(&surface_dma_cmd, 0, fifo_size);
+
+		ptr.gmrId  = content_vfb->user_handle;
+		ptr.offset = 0;
+
+		surface_dma_cmd.header.id   = SVGA_3D_CMD_SURFACE_DMA;
+		surface_dma_cmd.header.size = sizeof(surface_dma_cmd.body) +
+					      sizeof(surface_dma_cmd.area) +
+					      sizeof(surface_dma_cmd.suffix);
+
+		surface_dma_cmd.body.guest.ptr   = ptr;
+		surface_dma_cmd.body.guest.pitch = stdu->content_fb->pitches[0];
+		surface_dma_cmd.body.host.sid    = stdu->display_srf->res.id;
+		surface_dma_cmd.body.host.face   = 0;
+		surface_dma_cmd.body.host.mipmap = 0;
+		surface_dma_cmd.body.transfer    = SVGA3D_WRITE_HOST_VRAM;
+
+		surface_dma_cmd.area.srcx = content_x;
+		surface_dma_cmd.area.srcy = content_y;
+		surface_dma_cmd.area.x    = display_x;
+		surface_dma_cmd.area.y    = display_y;
+		surface_dma_cmd.area.d    = 1;
+		surface_dma_cmd.area.w    = width;
+		surface_dma_cmd.area.h    = height;
+
+		suffix = &surface_dma_cmd.suffix;
+
+		suffix->suffixSize    = sizeof(*suffix);
+		suffix->maximumOffset = svga3dsurface_get_image_buffer_size(
+						desc,
+						&cur_size,
+						stdu->content_fb->pitches[0]);
+
+		cmd = (void *) &surface_dma_cmd;
+	} else {
+		struct vmw_framebuffer *content_vfb;
+
+		content_vfb = vmw_framebuffer_to_vfb(stdu->content_fb);
+
+		fifo_size = sizeof(surface_cpy_cmd);
+
+		memset(&surface_cpy_cmd, 0, sizeof(surface_cpy_cmd));
+
+		surface_cpy_cmd.header.id   = SVGA_3D_CMD_SURFACE_COPY;
+		surface_cpy_cmd.header.size = sizeof(surface_cpy_cmd.body) +
+					      sizeof(surface_cpy_cmd.area);
+
+		surface_cpy_cmd.body.src.sid  = content_vfb->user_handle;
+		surface_cpy_cmd.body.dest.sid = stdu->display_srf->res.id;
+
+		surface_cpy_cmd.area.srcx = content_x;
+		surface_cpy_cmd.area.srcy = content_y;
+		surface_cpy_cmd.area.x    = display_x;
+		surface_cpy_cmd.area.y    = display_y;
+		surface_cpy_cmd.area.d    = 1;
+		surface_cpy_cmd.area.w    = width;
+		surface_cpy_cmd.area.h    = height;
+
+		cmd = (void *) &surface_cpy_cmd;
+	}
+
+	ret = vmw_execbuf_process(file_priv, dev_priv, NULL, cmd,
+				  fifo_size, 0, VMW_QUIRK_SCREENTARGET,
+				  NULL, NULL);
+
+	return ret;
+}
+
+
+
+/**
+ * vmw_stdu_define_st - Defines a Screen Target
+ *
+ * @dev_priv:  VMW DRM device
+ * @stdu: display unit to create a Screen Target for
+ *
+ * Creates a STDU that we can used later.  This function is called whenever the
+ * framebuffer size changes.
+ *
+ * RETURNs:
+ * 0 on success, error code on failure
+ */
+static int vmw_stdu_define_st(struct vmw_private *dev_priv,
+			      struct vmw_screen_target_display_unit *stdu)
+{
+	struct {
+		SVGA3dCmdHeader header;
+		SVGA3dCmdDefineGBScreenTarget body;
+	} *cmd;
+
+	cmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));
+
+	if (unlikely(cmd == NULL)) {
+		DRM_ERROR("Out of FIFO space defining Screen Target\n");
+		return -ENOMEM;
+	}
+
+	cmd->header.id   = SVGA_3D_CMD_DEFINE_GB_SCREENTARGET;
+	cmd->header.size = sizeof(cmd->body);
+
+	cmd->body.stid   = stdu->base.unit;
+	cmd->body.width  = stdu->display_srf->base_size.width;
+	cmd->body.height = stdu->display_srf->base_size.height;
+	cmd->body.flags  = (0 == cmd->body.stid) ? SVGA_STFLAG_PRIMARY : 0;
+	cmd->body.dpi    = 0;
+	cmd->body.xRoot  = stdu->base.crtc.x;
+	cmd->body.yRoot  = stdu->base.crtc.y;
+
+	if (!stdu->base.is_implicit) {
+		cmd->body.xRoot  = stdu->base.gui_x;
+		cmd->body.yRoot  = stdu->base.gui_y;
+	}
+
+	vmw_fifo_commit(dev_priv, sizeof(*cmd));
+
+	stdu->defined = true;
+
+	return 0;
+}
+
+
+
+/**
+ * vmw_stdu_bind_st - Binds a surface to a Screen Target
+ *
+ * @dev_priv: VMW DRM device
+ * @stdu: display unit affected
+ * @res: Buffer to bind to the screen target.  Set to NULL to blank screen.
+ *
+ * Binding a surface to a Screen Target the same as flipping
+ */
+static int vmw_stdu_bind_st(struct vmw_private *dev_priv,
+			    struct vmw_screen_target_display_unit *stdu,
+			    struct vmw_resource *res)
+{
+	SVGA3dSurfaceImageId image;
+
+	struct {
+		SVGA3dCmdHeader header;
+		SVGA3dCmdBindGBScreenTarget body;
+	} *cmd;
+
+
+	if (!stdu->defined) {
+		DRM_ERROR("No screen target defined\n");
+		return -EINVAL;
+	}
+
+	/* Set up image using information in vfb */
+	memset(&image, 0, sizeof(image));
+	image.sid = res ? res->id : SVGA3D_INVALID_ID;
+
+	cmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));
+
+	if (unlikely(cmd == NULL)) {
+		DRM_ERROR("Out of FIFO space binding a screen target\n");
+		return -ENOMEM;
+	}
+
+	cmd->header.id   = SVGA_3D_CMD_BIND_GB_SCREENTARGET;
+	cmd->header.size = sizeof(cmd->body);
+
+	cmd->body.stid   = stdu->base.unit;
+	cmd->body.image  = image;
+
+	vmw_fifo_commit(dev_priv, sizeof(*cmd));
+
+	return 0;
+}
+
+
+
+/**
+ * vmw_stdu_update_st - Updates a Screen Target
+ *
+ * @dev_priv: VMW DRM device
+ * @file_priv: Pointer to a drm file private structure
+ * @stdu: display unit affected
+ * @update_area: area that needs to be updated
+ *
+ * This function needs to be called whenever the content of a screen
+ * target changes.
+ * If the display and content buffers are different, then this function does
+ * a blit first from the content buffer to the display buffer before issuing
+ * the Screen Target update command.
+ *
+ * RETURNS:
+ * 0 on success, error code on failure
+ */
+static int vmw_stdu_update_st(struct vmw_private *dev_priv,
+			      struct drm_file *file_priv,
+			      struct vmw_screen_target_display_unit *stdu,
+			      struct drm_clip_rect *update_area)
+{
+	u32 width, height;
+	u32 display_update_x, display_update_y;
+	unsigned short display_x1, display_y1, display_x2, display_y2;
+
+	struct {
+		SVGA3dCmdHeader header;
+		SVGA3dCmdUpdateGBScreenTarget body;
+	} *cmd;
+
+
+	if (!stdu->defined) {
+		DRM_ERROR("No screen target defined");
+		return -EINVAL;
+	}
+
+	/* Display coordinates relative to its position in content surface */
+	display_x1 = stdu->base.crtc.x;
+	display_y1 = stdu->base.crtc.y;
+	display_x2 = display_x1 + stdu->display_srf->base_size.width;
+	display_y2 = display_y1 + stdu->display_srf->base_size.height;
+
+	/* Do nothing if the update area is outside of the display surface */
+	if (update_area->x2 <= display_x1 || update_area->x1 >= display_x2 ||
+	    update_area->y2 <= display_y1 || update_area->y1 >= display_y2)
+		return 0;
+
+	/* The top-left hand corner of the update area in display surface */
+	display_update_x = max(update_area->x1 - display_x1, 0);
+	display_update_y = max(update_area->y1 - display_y1, 0);
+
+	width  = min(update_area->x2, display_x2) -
+		 max(update_area->x1, display_x1);
+	height = min(update_area->y2, display_y2) -
+		 max(update_area->y1, display_y1);
+
+	if (file_priv && stdu->content_fb_type != SAME_AS_DISPLAY) {
+		int ret;
+
+		ret = vmw_stdu_content_copy(dev_priv, file_priv,
+					    stdu,
+					    max(update_area->x1, display_x1),
+					    max(update_area->y1, display_y1),
+					    width, height,
+					    display_update_x, display_update_y);
+		if (unlikely(ret != 0)) {
+			DRM_ERROR("Failed to blit content\n");
+			return ret;
+		}
+	}
+
+	cmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));
+
+	if (unlikely(cmd == NULL)) {
+		DRM_ERROR("Out of FIFO space updating a Screen Target\n");
+		return -ENOMEM;
+	}
+
+	cmd->header.id   = SVGA_3D_CMD_UPDATE_GB_SCREENTARGET;
+	cmd->header.size = sizeof(cmd->body);
+
+	cmd->body.stid   = stdu->base.unit;
+	cmd->body.rect.x = display_update_x;
+	cmd->body.rect.y = display_update_y;
+	cmd->body.rect.w = width;
+	cmd->body.rect.h = height;
+
+	vmw_fifo_commit(dev_priv, sizeof(*cmd));
+
+	return 0;
+}
+
+
+
+/**
+ * vmw_stdu_destroy_st - Destroy a Screen Target
+ *
+ * @dev_priv:  VMW DRM device
+ * @stdu: display unit to destroy
+ */
+static int vmw_stdu_destroy_st(struct vmw_private *dev_priv,
+			       struct vmw_screen_target_display_unit *stdu)
+{
+	int    ret;
+
+	struct {
+		SVGA3dCmdHeader header;
+		SVGA3dCmdDestroyGBScreenTarget body;
+	} *cmd;
+
+
+	/* Nothing to do if not successfully defined */
+	if (unlikely(!stdu->defined))
+		return 0;
+
+	cmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));
+
+	if (unlikely(cmd == NULL)) {
+		DRM_ERROR("Out of FIFO space, screen target not destroyed\n");
+		return -ENOMEM;
+	}
+
+	cmd->header.id   = SVGA_3D_CMD_DESTROY_GB_SCREENTARGET;
+	cmd->header.size = sizeof(cmd->body);
+
+	cmd->body.stid   = stdu->base.unit;
+
+	vmw_fifo_commit(dev_priv, sizeof(*cmd));
+
+	/* Force sync */
+	ret = vmw_fallback_wait(dev_priv, false, true, 0, false, 3*HZ);
+	if (unlikely(ret != 0))
+		DRM_ERROR("Failed to sync with HW");
+
+	stdu->defined = false;
+
+	return ret;
+}
+
+
+
+/**
+ * vmw_stdu_crtc_set_config - Sets a mode
+ *
+ * @set:  mode parameters
+ *
+ * This function is the device-specific portion of the DRM CRTC mode set.
+ * For the SVGA device, we do this by defining a Screen Target, binding a
+ * GB Surface to that target, and finally update the screen target.
+ *
+ * RETURNS:
+ * 0 on success, error code otherwise
+ */
+static int vmw_stdu_crtc_set_config(struct drm_mode_set *set)
+{
+	struct vmw_private *dev_priv;
+	struct vmw_screen_target_display_unit *stdu;
+	struct vmw_framebuffer *vfb;
+	struct vmw_framebuffer_surface *new_vfbs;
+	struct drm_display_mode *mode;
+	struct drm_framebuffer  *new_fb;
+	struct drm_crtc      *crtc;
+	struct drm_encoder   *encoder;
+	struct drm_connector *connector;
+	struct drm_clip_rect update_area = {0};
+	int    ret;
+
+
+	if (!set || !set->crtc)
+		return -EINVAL;
+
+	crtc     = set->crtc;
+	crtc->x  = set->x;
+	crtc->y  = set->y;
+	stdu     = vmw_crtc_to_stdu(crtc);
+	mode     = set->mode;
+	new_fb   = set->fb;
+	dev_priv = vmw_priv(crtc->dev);
+
+
+	if (set->num_connectors > 1) {
+		DRM_ERROR("Too many connectors\n");
+		return -EINVAL;
+	}
+
+	if (set->num_connectors == 1 &&
+	    set->connectors[0] != &stdu->base.connector) {
+		DRM_ERROR("Connectors don't match %p %p\n",
+			set->connectors[0], &stdu->base.connector);
+		return -EINVAL;
+	}
+
+
+	/* Since they always map one to one these are safe */
+	connector = &stdu->base.connector;
+	encoder   = &stdu->base.encoder;
+
+
+	/*
+	 * After this point the CRTC will be considered off unless a new fb
+	 * is bound
+	 */
+	if (stdu->defined) {
+		/* Unbind current surface by binding an invalid one */
+		ret = vmw_stdu_bind_st(dev_priv, stdu, NULL);
+		if (unlikely(ret != 0))
+			return ret;
+
+		/* Update Screen Target, display will now be blank */
+		if (crtc->primary->fb) {
+			update_area.x2 = crtc->primary->fb->width;
+			update_area.y2 = crtc->primary->fb->height;
+
+			ret = vmw_stdu_update_st(dev_priv, NULL,
+						 stdu,
+						 &update_area);
+			if (unlikely(ret != 0))
+				return ret;
+		}
+
+		crtc->primary->fb  = NULL;
+		crtc->enabled      = false;
+		encoder->crtc      = NULL;
+		connector->encoder = NULL;
+
+		vmw_stdu_unpin_display(stdu);
+		stdu->content_fb      = NULL;
+		stdu->content_fb_type = SAME_AS_DISPLAY;
+
+		ret = vmw_stdu_destroy_st(dev_priv, stdu);
+		/* The hardware is hung, give up */
+		if (unlikely(ret != 0))
+			return ret;
+	}
+
+
+	/* Any of these conditions means the caller wants CRTC off */
+	if (set->num_connectors == 0 || !mode || !new_fb)
+		return 0;
+
+
+	if (set->x + mode->hdisplay > new_fb->width ||
+	    set->y + mode->vdisplay > new_fb->height) {
+		DRM_ERROR("Set outside of framebuffer\n");
+		return -EINVAL;
+	}
+
+	stdu->content_fb = new_fb;
+	vfb = vmw_framebuffer_to_vfb(stdu->content_fb);
+
+	if (vfb->dmabuf)
+		stdu->content_fb_type = SEPARATE_DMA;
+
+	/*
+	 * If the requested mode is different than the width and height
+	 * of the FB or if the content buffer is a DMA buf, then allocate
+	 * a display FB that matches the dimension of the mode
+	 */
+	if (mode->hdisplay != new_fb->width  ||
+	    mode->vdisplay != new_fb->height ||
+	    stdu->content_fb_type != SAME_AS_DISPLAY) {
+		struct vmw_surface content_srf;
+		struct drm_vmw_size display_base_size = {0};
+		struct vmw_surface *display_srf;
+
+
+		display_base_size.width  = mode->hdisplay;
+		display_base_size.height = mode->vdisplay;
+		display_base_size.depth  = 1;
+
+		/*
+		 * If content buffer is a DMA buf, then we have to construct
+		 * surface info
+		 */
+		if (stdu->content_fb_type == SEPARATE_DMA) {
+
+			switch (new_fb->bits_per_pixel) {
+			case 32:
+				content_srf.format = SVGA3D_X8R8G8B8;
+				break;
+
+			case 16:
+				content_srf.format = SVGA3D_R5G6B5;
+				break;
+
+			case 8:
+				content_srf.format = SVGA3D_P8;
+				break;
+
+			default:
+				DRM_ERROR("Invalid format\n");
+				ret = -EINVAL;
+				goto err_unref_content;
+			}
+
+			content_srf.flags             = 0;
+			content_srf.mip_levels[0]     = 1;
+			content_srf.multisample_count = 0;
+		} else {
+
+			stdu->content_fb_type = SEPARATE_SURFACE;
+
+			new_vfbs = vmw_framebuffer_to_vfbs(new_fb);
+			content_srf = *new_vfbs->surface;
+		}
+
+
+		ret = vmw_surface_gb_priv_define(crtc->dev,
+				0, /* because kernel visible only */
+				content_srf.flags,
+				content_srf.format,
+				true, /* a scanout buffer */
+				content_srf.mip_levels[0],
+				content_srf.multisample_count,
+				display_base_size,
+				&display_srf);
+		if (unlikely(ret != 0)) {
+			DRM_ERROR("Cannot allocate a display FB.\n");
+			goto err_unref_content;
+		}
+
+		stdu->display_srf = display_srf;
+	} else {
+		new_vfbs = vmw_framebuffer_to_vfbs(new_fb);
+		stdu->display_srf = new_vfbs->surface;
+	}
+
+
+	ret = vmw_stdu_pin_display(stdu);
+	if (unlikely(ret != 0)) {
+		stdu->display_srf = NULL;
+		goto err_unref_content;
+	}
+
+	vmw_fb_off(dev_priv);
+	vmw_svga_enable(dev_priv);
+
+	/*
+	 * Steps to displaying a surface, assume surface is already
+	 * bound:
+	 *   1.  define a screen target
+	 *   2.  bind a fb to the screen target
+	 *   3.  update that screen target (this is done later by
+	 *       vmw_kms_stdu_do_surface_dirty_or_present)
+	 */
+	ret = vmw_stdu_define_st(dev_priv, stdu);
+	if (unlikely(ret != 0))
+		goto err_unpin_display_and_content;
+
+	ret = vmw_stdu_bind_st(dev_priv, stdu, &stdu->display_srf->res);
+	if (unlikely(ret != 0))
+		goto err_unpin_destroy_st;
+
+
+	connector->encoder = encoder;
+	encoder->crtc      = crtc;
+
+	crtc->mode    = *mode;
+	crtc->primary->fb = new_fb;
+	crtc->enabled = true;
+
+	return ret;
+
+err_unpin_destroy_st:
+	vmw_stdu_destroy_st(dev_priv, stdu);
+err_unpin_display_and_content:
+	vmw_stdu_unpin_display(stdu);
+err_unref_content:
+	stdu->content_fb = NULL;
+	return ret;
+}
+
+
+
+/**
+ * vmw_stdu_crtc_page_flip - Binds a buffer to a screen target
+ *
+ * @crtc: CRTC to attach FB to
+ * @fb: FB to attach
+ * @event: Event to be posted. This event should've been alloced
+ *         using k[mz]alloc, and should've been completely initialized.
+ * @page_flip_flags: Input flags.
+ *
+ * If the STDU uses the same display and content buffers, i.e. a true flip,
+ * this function will replace the existing display buffer with the new content
+ * buffer.
+ *
+ * If the STDU uses different display and content buffers, i.e. a blit, then
+ * only the content buffer will be updated.
+ *
+ * RETURNS:
+ * 0 on success, error code on failure
+ */
+static int vmw_stdu_crtc_page_flip(struct drm_crtc *crtc,
+				   struct drm_framebuffer *new_fb,
+				   struct drm_pending_vblank_event *event,
+				   uint32_t flags)
+
+{
+	struct vmw_private *dev_priv = vmw_priv(crtc->dev);
+	struct vmw_screen_target_display_unit *stdu;
+	struct drm_file *file_priv;
+	struct drm_clip_rect update_area = {0};
+	int ret;
+
+	/*
+	 * Temporarily don't support event == NULL. We need the
+	 * @file_priv pointer!
+	 */
+	if (event == NULL)
+		return -EINVAL;
+
+	if (crtc == NULL)
+		return -EINVAL;
+
+	dev_priv          = vmw_priv(crtc->dev);
+	stdu              = vmw_crtc_to_stdu(crtc);
+	crtc->primary->fb = new_fb;
+	stdu->content_fb  = new_fb;
+
+	if (stdu->display_srf) {
+		update_area.x2 = stdu->display_srf->base_size.width;
+		update_area.y2 = stdu->display_srf->base_size.height;
+
+		/*
+		 * If the display surface is the same as the content surface
+		 * then remove the reference
+		 */
+		if (stdu->content_fb_type == SAME_AS_DISPLAY) {
+			if (stdu->defined) {
+				/* Unbind the current surface */
+				ret = vmw_stdu_bind_st(dev_priv, stdu, NULL);
+				if (unlikely(ret != 0))
+					goto err_out;
+			}
+			vmw_stdu_unpin_display(stdu);
+			stdu->display_srf = NULL;
+		}
+	}
+
+
+	if (!new_fb) {
+		/* Blanks the display */
+		(void) vmw_stdu_update_st(dev_priv, NULL, stdu, &update_area);
+
+		return 0;
+	}
+
+
+	if (stdu->content_fb_type == SAME_AS_DISPLAY) {
+		stdu->display_srf = vmw_framebuffer_to_vfbs(new_fb)->surface;
+		ret = vmw_stdu_pin_display(stdu);
+		if (ret) {
+			stdu->display_srf = NULL;
+			goto err_out;
+		}
+
+		/* Bind display surface */
+		ret = vmw_stdu_bind_st(dev_priv, stdu, &stdu->display_srf->res);
+		if (unlikely(ret != 0))
+			goto err_unpin_display_and_content;
+	}
+
+	/* Update display surface: after this point everything is bound */
+	update_area.x2 = stdu->display_srf->base_size.width;
+	update_area.y2 = stdu->display_srf->base_size.height;
+
+	file_priv = event->base.file_priv;
+	ret = vmw_stdu_update_st(dev_priv, file_priv, stdu, &update_area);
+	if (unlikely(ret != 0))
+		return ret;
+
+	if (event) {
+		struct vmw_fence_obj *fence = NULL;
+
+		vmw_execbuf_fence_commands(NULL, dev_priv, &fence, NULL);
+		if (!fence)
+			return -ENOMEM;
+
+		ret = vmw_event_fence_action_queue(file_priv, fence,
+						   &event->base,
+						   &event->event.tv_sec,
+						   &event->event.tv_usec,
+						   true);
+		vmw_fence_obj_unreference(&fence);
+	}
+
+	return ret;
+
+err_unpin_display_and_content:
+	vmw_stdu_unpin_display(stdu);
+err_out:
+	crtc->primary->fb = NULL;
+	stdu->content_fb = NULL;
+	return ret;
+}
+
+
+
+/*
+ *  Screen Target CRTC dispatch table
+ */
+static struct drm_crtc_funcs vmw_stdu_crtc_funcs = {
+	.save = vmw_du_crtc_save,
+	.restore = vmw_du_crtc_restore,
+	.cursor_set = vmw_du_crtc_cursor_set,
+	.cursor_move = vmw_du_crtc_cursor_move,
+	.gamma_set = vmw_du_crtc_gamma_set,
+	.destroy = vmw_stdu_crtc_destroy,
+	.set_config = vmw_stdu_crtc_set_config,
+	.page_flip = vmw_stdu_crtc_page_flip,
+};
+
+
+
+/******************************************************************************
+ * Screen Target Display Unit Encoder Functions
+ *****************************************************************************/
+
+/**
+ * vmw_stdu_encoder_destroy - cleans up the STDU
+ *
+ * @encoder: used the get the containing STDU
+ *
+ * vmwgfx cleans up crtc/encoder/connector all at the same time so technically
+ * this can be a no-op.  Nevertheless, it doesn't hurt of have this in case
+ * the common KMS code changes and somehow vmw_stdu_crtc_destroy() doesn't
+ * get called.
+ */
+static void vmw_stdu_encoder_destroy(struct drm_encoder *encoder)
+{
+	vmw_stdu_destroy(vmw_encoder_to_stdu(encoder));
+}
+
+static struct drm_encoder_funcs vmw_stdu_encoder_funcs = {
+	.destroy = vmw_stdu_encoder_destroy,
+};
+
+
+
+/******************************************************************************
+ * Screen Target Display Unit Connector Functions
+ *****************************************************************************/
+
+/**
+ * vmw_stdu_connector_destroy - cleans up the STDU
+ *
+ * @connector: used to get the containing STDU
+ *
+ * vmwgfx cleans up crtc/encoder/connector all at the same time so technically
+ * this can be a no-op.  Nevertheless, it doesn't hurt of have this in case
+ * the common KMS code changes and somehow vmw_stdu_crtc_destroy() doesn't
+ * get called.
+ */
+static void vmw_stdu_connector_destroy(struct drm_connector *connector)
+{
+	vmw_stdu_destroy(vmw_connector_to_stdu(connector));
+}
+
+
+
+static struct drm_connector_funcs vmw_stdu_connector_funcs = {
+	.dpms = vmw_du_connector_dpms,
+	.save = vmw_du_connector_save,
+	.restore = vmw_du_connector_restore,
+	.detect = vmw_du_connector_detect,
+	.fill_modes = vmw_du_connector_fill_modes,
+	.set_property = vmw_du_connector_set_property,
+	.destroy = vmw_stdu_connector_destroy,
+};
+
+
+
+/**
+ * vmw_stdu_init - Sets up a Screen Target Display Unit
+ *
+ * @dev_priv: VMW DRM device
+ * @unit: unit number range from 0 to VMWGFX_NUM_DISPLAY_UNITS
+ *
+ * This function is called once per CRTC, and allocates one Screen Target
+ * display unit to represent that CRTC.  Since the SVGA device does not separate
+ * out encoder and connector, they are represented as part of the STDU as well.
+ */
+static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
+{
+	struct vmw_screen_target_display_unit *stdu;
+	struct drm_device *dev = dev_priv->dev;
+	struct drm_connector *connector;
+	struct drm_encoder *encoder;
+	struct drm_crtc *crtc;
+
+
+	stdu = kzalloc(sizeof(*stdu), GFP_KERNEL);
+	if (!stdu)
+		return -ENOMEM;
+
+	stdu->base.unit = unit;
+	crtc = &stdu->base.crtc;
+	encoder = &stdu->base.encoder;
+	connector = &stdu->base.connector;
+
+	stdu->base.pref_active = (unit == 0);
+	stdu->base.pref_width  = dev_priv->initial_width;
+	stdu->base.pref_height = dev_priv->initial_height;
+	stdu->base.pref_mode   = NULL;
+	stdu->base.is_implicit = true;
+
+	drm_connector_init(dev, connector, &vmw_stdu_connector_funcs,
+			   DRM_MODE_CONNECTOR_VIRTUAL);
+	connector->status = vmw_du_connector_detect(connector, false);
+
+	drm_encoder_init(dev, encoder, &vmw_stdu_encoder_funcs,
+			 DRM_MODE_ENCODER_VIRTUAL);
+	drm_mode_connector_attach_encoder(connector, encoder);
+	encoder->possible_crtcs = (1 << unit);
+	encoder->possible_clones = 0;
+
+	(void) drm_connector_register(connector);
+
+	drm_crtc_init(dev, crtc, &vmw_stdu_crtc_funcs);
+
+	drm_mode_crtc_set_gamma_size(crtc, 256);
+
+	drm_object_attach_property(&connector->base,
+				   dev->mode_config.dirty_info_property,
+				   1);
+
+	return 0;
+}
+
+
+
+/**
+ *  vmw_stdu_destroy - Cleans up a vmw_screen_target_display_unit
+ *
+ *  @stdu:  Screen Target Display Unit to be destroyed
+ *
+ *  Clean up after vmw_stdu_init
+ */
+static void vmw_stdu_destroy(struct vmw_screen_target_display_unit *stdu)
+{
+	vmw_stdu_unpin_display(stdu);
+
+	vmw_du_cleanup(&stdu->base);
+	kfree(stdu);
+}
+
+
+
+/******************************************************************************
+ * Screen Target Display KMS Functions
+ *
+ * These functions are called by the common KMS code in vmwgfx_kms.c
+ *****************************************************************************/
+
+/**
+ * vmw_kms_stdu_init_display - Initializes a Screen Target based display
+ *
+ * @dev_priv: VMW DRM device
+ *
+ * This function initialize a Screen Target based display device.  It checks
+ * the capability bits to make sure the underlying hardware can support
+ * screen targets, and then creates the maximum number of CRTCs, a.k.a Display
+ * Units, as supported by the display hardware.
+ *
+ * RETURNS:
+ * 0 on success, error code otherwise
+ */
+int vmw_kms_stdu_init_display(struct vmw_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+	int i, ret;
+
+
+	/* Do nothing if Screen Target support is turned off */
+	if (!VMWGFX_ENABLE_SCREEN_TARGET_OTABLE)
+		return -ENOSYS;
+
+	if (!(dev_priv->capabilities & SVGA_CAP_GBOBJECTS) ||
+	    !(dev_priv->capabilities & SVGA_CAP_3D))
+		return -ENOSYS;
+
+	ret = drm_vblank_init(dev, VMWGFX_NUM_DISPLAY_UNITS);
+	if (unlikely(ret != 0))
+		return ret;
+
+	ret = drm_mode_create_dirty_info_property(dev);
+	if (unlikely(ret != 0))
+		goto err_vblank_cleanup;
+
+	for (i = 0; i < VMWGFX_NUM_DISPLAY_UNITS; ++i) {
+		ret = vmw_stdu_init(dev_priv, i);
+
+		if (unlikely(ret != 0)) {
+			DRM_ERROR("Failed to initialize STDU %d", i);
+			goto err_vblank_cleanup;
+		}
+	}
+
+	dev_priv->active_display_unit = vmw_du_screen_target;
+
+	DRM_INFO("Screen Target Display device initialized\n");
+
+	return 0;
+
+err_vblank_cleanup:
+	drm_vblank_cleanup(dev);
+	return ret;
+}
+
+
+
+/**
+ * vmw_kms_stdu_close_display - Cleans up after vmw_kms_stdu_init_display
+ *
+ * @dev_priv: VMW DRM device
+ *
+ * Frees up any resources allocated by vmw_kms_stdu_init_display
+ *
+ * RETURNS:
+ * 0 on success
+ */
+int vmw_kms_stdu_close_display(struct vmw_private *dev_priv)
+{
+	struct drm_device *dev = dev_priv->dev;
+
+	drm_vblank_cleanup(dev);
+
+	return 0;
+}
+
+
+
+/**
+ * vmw_kms_stdu_do_surface_dirty - updates a dirty rectange to SVGA device
+ *
+ * @dev_priv: VMW DRM device
+ * @file_priv: Pointer to a drm file private structure
+ * @framebuffer: FB with the new content to be copied to SVGA device
+ * @clip_rects: array of dirty rectanges
+ * @num_of_clip_rects: number of rectanges in @clips
+ * @increment: increment to the next dirty rect in @clips
+ *
+ * This function sends an Update command to the SVGA device.  This will notify
+ * the device that a region needs to be copied to the screen.  At this time
+ * we are not coalescing clip rects into one large clip rect because the SVGA
+ * device will do it for us.
+ *
+ * RETURNS:
+ * 0 on success, error code otherwise
+ */
+int vmw_kms_stdu_do_surface_dirty(struct vmw_private *dev_priv,
+				  struct drm_file *file_priv,
+				  struct vmw_framebuffer *framebuffer,
+				  struct drm_clip_rect *clip_rects,
+				  unsigned num_of_clip_rects, int increment)
+{
+	struct vmw_screen_target_display_unit *stdu[VMWGFX_NUM_DISPLAY_UNITS];
+	struct drm_clip_rect *cur_rect;
+	struct drm_crtc *crtc;
+
+	unsigned num_of_du = 0, cur_du, count = 0;
+	int      ret = 0;
+
+
+	BUG_ON(!clip_rects || !num_of_clip_rects);
+
+	/* Figure out all the DU affected by this surface */
+	list_for_each_entry(crtc, &dev_priv->dev->mode_config.crtc_list,
+			    head) {
+		if (crtc->primary->fb != &framebuffer->base)
+			continue;
+
+		stdu[num_of_du++] = vmw_crtc_to_stdu(crtc);
+	}
+
+	for (cur_du = 0; cur_du < num_of_du; cur_du++)
+		for (cur_rect = clip_rects, count = 0;
+		     count < num_of_clip_rects && ret == 0;
+		     cur_rect += increment, count++) {
+			ret = vmw_stdu_update_st(dev_priv, file_priv,
+						 stdu[cur_du],
+						 cur_rect);
+		}
+
+	return ret;
+}
+
+
+
+/**
+ * vmw_kms_stdu_present - present a surface to the display surface
+ *
+ * @dev_priv: VMW DRM device
+ * @file_priv: Pointer to a drm file private structure
+ * @vfb: Used to pick which STDU(s) is affected
+ * @user_handle: user handle for the source surface
+ * @dest_x: top/left corner of the display area to blit to
+ * @dest_y: top/left corner of the display area to blit to
+ * @clip_rects: array of dirty rectanges
+ * @num_of_clip_rects: number of rectanges in @clips
+ *
+ * This function copies a surface onto the display surface, and
+ * updates the screen target.  Strech blit is currently not
+ * supported.
+ *
+ * RETURNS:
+ * 0 on success, error code otherwise
+ */
+int vmw_kms_stdu_present(struct vmw_private *dev_priv,
+			 struct drm_file *file_priv,
+			 struct vmw_framebuffer *vfb,
+			 uint32_t user_handle,
+			 int32_t dest_x, int32_t dest_y,
+			 struct drm_vmw_rect *clip_rects,
+			 uint32_t num_of_clip_rects)
+{
+	struct vmw_screen_target_display_unit *stdu[VMWGFX_NUM_DISPLAY_UNITS];
+	struct drm_clip_rect *update_area;
+	struct drm_crtc *crtc;
+	size_t fifo_size;
+	int num_of_du = 0, cur_du, i;
+	int ret = 0;
+	struct vmw_clip_rect src_bb;
+
+	struct {
+		SVGA3dCmdHeader      header;
+		SVGA3dCmdSurfaceCopy body;
+	} *cmd;
+	SVGA3dCopyBox *blits;
+
+
+	BUG_ON(!clip_rects || !num_of_clip_rects);
+
+	list_for_each_entry(crtc, &dev_priv->dev->mode_config.crtc_list, head) {
+		if (crtc->primary->fb != &vfb->base)
+			continue;
+
+		stdu[num_of_du++] = vmw_crtc_to_stdu(crtc);
+	}
+
+
+	update_area = kcalloc(num_of_clip_rects, sizeof(*update_area),
+			      GFP_KERNEL);
+	if (unlikely(update_area == NULL)) {
+		DRM_ERROR("Temporary clip rect memory alloc failed.\n");
+		return -ENOMEM;
+	}
+
+
+	fifo_size = sizeof(*cmd) + sizeof(SVGA3dCopyBox) * num_of_clip_rects;
+
+	cmd = kmalloc(fifo_size, GFP_KERNEL);
+	if (unlikely(cmd == NULL)) {
+		DRM_ERROR("Failed to allocate memory for surface copy.\n");
+		ret = -ENOMEM;
+		goto out_free_update_area;
+	}
+
+	memset(cmd, 0, fifo_size);
+	cmd->header.id = SVGA_3D_CMD_SURFACE_COPY;
+
+	blits = (SVGA3dCopyBox *)&cmd[1];
+
+
+	/* Figure out the source bounding box */
+	src_bb.x1 = clip_rects->x;
+	src_bb.y1 = clip_rects->y;
+	src_bb.x2 = clip_rects->x + clip_rects->w;
+	src_bb.y2 = clip_rects->y + clip_rects->h;
+
+	for (i = 1; i < num_of_clip_rects; i++) {
+		src_bb.x1 = min_t(int, src_bb.x1, clip_rects[i].x);
+		src_bb.x2 = max_t(int, src_bb.x2,
+				  clip_rects[i].x + (int) clip_rects[i].w);
+		src_bb.y1 = min_t(int, src_bb.y1, clip_rects[i].y);
+		src_bb.y2 = max_t(int, src_bb.y2,
+				  clip_rects[i].y + (int) clip_rects[i].h);
+	}
+
+	for (i = 0; i < num_of_clip_rects; i++) {
+		update_area[i].x1 = clip_rects[i].x - src_bb.x1;
+		update_area[i].x2 = update_area[i].x1 + clip_rects[i].w;
+		update_area[i].y1 = clip_rects[i].y - src_bb.y1;
+		update_area[i].y2 = update_area[i].y1 + clip_rects[i].h;
+	}
+
+
+	for (cur_du = 0; cur_du < num_of_du; cur_du++) {
+		struct vmw_clip_rect dest_bb;
+		int num_of_blits;
+
+		crtc = &stdu[cur_du]->base.crtc;
+
+		dest_bb.x1 = src_bb.x1 + dest_x - crtc->x;
+		dest_bb.y1 = src_bb.y1 + dest_y - crtc->y;
+		dest_bb.x2 = src_bb.x2 + dest_x - crtc->x;
+		dest_bb.y2 = src_bb.y2 + dest_y - crtc->y;
+
+		/* Skip any STDU outside of the destination bounding box */
+		if (dest_bb.x1 >= crtc->mode.hdisplay ||
+		    dest_bb.y1 >= crtc->mode.vdisplay ||
+		    dest_bb.x2 <= 0 || dest_bb.y2 <= 0)
+			continue;
+
+		/* Normalize to top-left of src bounding box in dest coord */
+		dest_bb.x2 = crtc->mode.hdisplay - dest_bb.x1;
+		dest_bb.y2 = crtc->mode.vdisplay - dest_bb.y1;
+		dest_bb.x1 = 0 - dest_bb.x1;
+		dest_bb.y1 = 0 - dest_bb.y1;
+
+		for (i = 0, num_of_blits = 0; i < num_of_clip_rects; i++) {
+			int x1 = max_t(int, dest_bb.x1, (int)update_area[i].x1);
+			int y1 = max_t(int, dest_bb.y1, (int)update_area[i].y1);
+			int x2 = min_t(int, dest_bb.x2, (int)update_area[i].x2);
+			int y2 = min_t(int, dest_bb.y2, (int)update_area[i].y2);
+
+			if (x1 >= x2)
+				continue;
+
+			if (y1 >= y2)
+				continue;
+
+			blits[num_of_blits].srcx =  src_bb.x1  + x1;
+			blits[num_of_blits].srcy =  src_bb.y1  + y1;
+			blits[num_of_blits].x    = -dest_bb.x1 + x1;
+			blits[num_of_blits].y    = -dest_bb.y1 + y1;
+			blits[num_of_blits].d    = 1;
+			blits[num_of_blits].w    = x2 - x1;
+			blits[num_of_blits].h    = y2 - y1;
+			num_of_blits++;
+		}
+
+		if (num_of_blits == 0)
+			continue;
+
+		/* Calculate new command size */
+		fifo_size = sizeof(*cmd) + sizeof(SVGA3dCopyBox) * num_of_blits;
+
+		cmd->header.size = cpu_to_le32(fifo_size - sizeof(cmd->header));
+
+		cmd->body.src.sid  = user_handle;
+		cmd->body.dest.sid = stdu[cur_du]->display_srf->res.id;
+
+		ret = vmw_execbuf_process(file_priv, dev_priv, NULL, cmd,
+					  fifo_size, 0, VMW_QUIRK_SCREENTARGET,
+					  NULL, NULL);
+
+		if (unlikely(ret != 0))
+			break;
+
+		for (i = 0; i < num_of_blits; i++) {
+			struct drm_clip_rect blit_area;
+
+			/*
+			 * Add crtc offset because vmw_stdu_update_st expects
+			 * desktop coordinates
+			 */
+			blit_area.x1 = blits[i].x + crtc->x;
+			blit_area.x2 = blit_area.x1 + blits[i].w;
+			blit_area.y1 = blits[i].y + crtc->y;
+			blit_area.y2 = blit_area.y1 + blits[i].h;
+			(void) vmw_stdu_update_st(dev_priv, NULL, stdu[cur_du],
+						  &blit_area);
+		}
+	}
+
+	kfree(cmd);
+
+out_free_update_area:
+	kfree(update_area);
+
+	return ret;
+}
